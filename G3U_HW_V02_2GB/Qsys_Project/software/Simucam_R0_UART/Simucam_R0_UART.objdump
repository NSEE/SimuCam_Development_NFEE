
Simucam_R0_UART.elf:     file format elf32-littlenios2
Simucam_R0_UART.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x8110025c

Program Header:
    LOAD off    0x00001020 vaddr 0x81100020 paddr 0x81100020 align 2**12
         filesz 0x000534e4 memsz 0x0006d758 flags rwx
    LOAD off    0x00055000 vaddr 0x86020000 paddr 0x86020000 align 2**12
         filesz 0x00000000 memsz 0x00000000 flags r-x

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000000  86020000  86020000  00055000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   0000023c  81100020  81100020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0004b2b4  8110025c  8110025c  0000125c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00006200  8114b510  8114b510  0004c510  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001df4  81151710  81151710  00052710  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          0001a274  81153504  81153504  00054504  2**2
                  ALLOC, SMALL_DATA
  6 .onchip_memory 00000000  8116d778  8116d778  00055000  2**0
                  CONTENTS
  7 .ext_flash    00000000  86020020  86020020  00055000  2**0
                  CONTENTS
  8 .comment      00000023  00000000  00000000  00055000  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00001da0  00000000  00000000  00055028  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   000727b7  00000000  00000000  00056dc8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00016d22  00000000  00000000  000c957f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   000230ba  00000000  00000000  000e02a1  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00009a2c  00000000  00000000  0010335c  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0000cba0  00000000  00000000  0010cd88  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00026fb3  00000000  00000000  00119928  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_alt_sim_info 00000040  00000000  00000000  001408dc  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 000023b8  00000000  00000000  00140920  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .thread_model 00000006  00000000  00000000  0014f1b9  2**0
                  CONTENTS, READONLY
 19 .cpu          0000000c  00000000  00000000  0014f1bf  2**0
                  CONTENTS, READONLY
 20 .qsys         00000001  00000000  00000000  0014f1cb  2**0
                  CONTENTS, READONLY
 21 .simulation_enabled 00000001  00000000  00000000  0014f1cc  2**0
                  CONTENTS, READONLY
 22 .sysid_hash   00000004  00000000  00000000  0014f1cd  2**0
                  CONTENTS, READONLY
 23 .sysid_base   00000004  00000000  00000000  0014f1d1  2**0
                  CONTENTS, READONLY
 24 .sysid_time   00000004  00000000  00000000  0014f1d5  2**0
                  CONTENTS, READONLY
 25 .stderr_dev   0000000b  00000000  00000000  0014f1d9  2**0
                  CONTENTS, READONLY
 26 .stdin_dev    0000000a  00000000  00000000  0014f1e4  2**0
                  CONTENTS, READONLY
 27 .stdout_dev   0000000a  00000000  00000000  0014f1ee  2**0
                  CONTENTS, READONLY
 28 .sopc_system_name 00000011  00000000  00000000  0014f1f8  2**0
                  CONTENTS, READONLY
 29 .quartus_project_dir 0000004d  00000000  00000000  0014f209  2**0
                  CONTENTS, READONLY
 30 .sopcinfo     00226f57  00000000  00000000  0014f256  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
86020000 l    d  .entry	00000000 .entry
81100020 l    d  .exceptions	00000000 .exceptions
8110025c l    d  .text	00000000 .text
8114b510 l    d  .rodata	00000000 .rodata
81151710 l    d  .rwdata	00000000 .rwdata
81153504 l    d  .bss	00000000 .bss
8116d778 l    d  .onchip_memory	00000000 .onchip_memory
86020020 l    d  .ext_flash	00000000 .ext_flash
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../Simucam_R0_UART_bsp//obj/HAL/src/crt0.o
81100304 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 ddr2.c
00000000 l    df *ABS*	00000000 dma.c
00000000 l    df *ABS*	00000000 sense.c
00000000 l    df *ABS*	00000000 simucam_dma.c
00000000 l    df *ABS*	00000000 comm_channel.c
81104990 l     F .text	00000050 uliCommReadReg
8110493c l     F .text	00000054 vCommWriteReg
00000000 l    df *ABS*	00000000 data_packet.c
811051d0 l     F .text	00000050 uliDpktReadReg
8110517c l     F .text	00000054 vDpktWriteReg
00000000 l    df *ABS*	00000000 fee_buffers.c
81153528 l     O .bss	00000004 viCh1HoldContext
8115352c l     O .bss	00000004 viCh2HoldContext
81153530 l     O .bss	00000004 viCh3HoldContext
81153534 l     O .bss	00000004 viCh4HoldContext
81153538 l     O .bss	00000004 viCh5HoldContext
8115353c l     O .bss	00000004 viCh6HoldContext
81153540 l     O .bss	00000004 viCh7HoldContext
81153544 l     O .bss	00000004 viCh8HoldContext
81106e14 l     F .text	00000054 vFeebWriteReg
81106e68 l     F .text	00000050 uliFeebReadReg
00000000 l    df *ABS*	00000000 rmap.c
81153548 l     O .bss	00000004 viCh1HoldContext
8115354c l     O .bss	00000004 viCh2HoldContext
81153550 l     O .bss	00000004 viCh3HoldContext
81153554 l     O .bss	00000004 viCh4HoldContext
81153558 l     O .bss	00000004 viCh5HoldContext
8115355c l     O .bss	00000004 viCh6HoldContext
81153560 l     O .bss	00000004 viCh7HoldContext
81153564 l     O .bss	00000004 viCh8HoldContext
8110a06c l     F .text	00000054 vRmapWriteReg
8110a110 l     F .text	00000268 uliConvRmapCfgAddr
00000000 l    df *ABS*	00000000 spw_controller.c
8110aa44 l     F .text	00000050 uliSpwcReadReg
8110a9f0 l     F .text	00000054 vSpwcWriteReg
00000000 l    df *ABS*	00000000 ctrl_io_lvds.c
8115342c l     O .rwdata	00000001 ucIoValue
8110ac44 l     F .text	0000007c bCtrlIoLvdsDrive
00000000 l    df *ABS*	00000000 i2c.c
00000000 l    df *ABS*	00000000 leds.c
00000000 l    df *ABS*	00000000 msgdma.c
8110b534 l     F .text	0000013c msgdma_write_extended_descriptor
8110b670 l     F .text	00000164 msgdma_construct_extended_descriptor
8110b7d4 l     F .text	00000240 msgdma_descriptor_async_transfer
8110ba14 l     F .text	00000380 msgdma_descriptor_sync_transfer
00000000 l    df *ABS*	00000000 power_spi.c
00000000 l    df *ABS*	00000000 reset.c
8110c514 l     F .text	00000054 vRstcWriteReg
8110c568 l     F .text	00000050 uliRstReadReg
00000000 l    df *ABS*	00000000 rtcc_spi.c
00000000 l    df *ABS*	00000000 seven_seg.c
00000000 l    df *ABS*	00000000 sync.c
8115356c l     O .bss	00000004 viHoldContext
00000000 l    df *ABS*	00000000 data_control_task.c
00000000 l    df *ABS*	00000000 fee_task.c
81153574 l     O .bss	00000004 pxNFee.5679
81153578 l     O .bss	00000004 incrementador.5684
8115357c l     O .bss	00000004 tCodFeeTask.5682
00000000 l    df *ABS*	00000000 in_ack_handler_task.c
81153582 l     O .bss	00000004 xRAckLocal.5606
00000000 l    df *ABS*	00000000 initialization_task.c
00000000 l    df *ABS*	00000000 nfee_control_task.c
81153588 l     O .bss	00000004 bDmaBack.5647
8115358c l     O .bss	00000001 ucWhoGetDMA.5648
00000000 l    df *ABS*	00000000 out_ack_handler_task.c
8115358e l     O .bss	00000004 xSAckLocal.5591
00000000 l    df *ABS*	00000000 parser_comm_task.c
81153708 l     O .bss	0000004c PreParsedLocal.5644
81153754 l     O .bss	00000054 xTcPusL.5643
00000000 l    df *ABS*	00000000 receiver_uart_task.c
811537a8 l     O .bss	0000004c xPreParsedReader.5636
00000000 l    df *ABS*	00000000 sender_com_task.c
00000000 l    df *ABS*	00000000 sim_meb_task.c
811537f4 l     O .bss	00000054 xPusLocal.5879
00000000 l    df *ABS*	00000000 stack_monitor_task.c
00000000 l    df *ABS*	00000000 timeout_checker_ack_task.c
00000000 l    df *ABS*	00000000 simucam_main.c
00000000 l    df *ABS*	00000000 ccd.c
00000000 l    df *ABS*	00000000 communication_utils.c
00000000 l    df *ABS*	00000000 configs_simucam.c
00000000 l    df *ABS*	00000000 crc8.c
8114f01f l     O .rodata	00000100 crc8_table
00000000 l    df *ABS*	00000000 data_controller.c
00000000 l    df *ABS*	00000000 error_handler_simucam.c
00000000 l    df *ABS*	00000000 events_handler.c
00000000 l    df *ABS*	00000000 fee.c
00000000 l    df *ABS*	00000000 fee_controller.c
00000000 l    df *ABS*	00000000 initialization_simucam.c
00000000 l    df *ABS*	00000000 log_manager_simucam.c
00000000 l    df *ABS*	00000000 meb.c
00000000 l    df *ABS*	00000000 pattern.c
00000000 l    df *ABS*	00000000 sdcard_file_manager.c
00000000 l    df *ABS*	00000000 sync_handler.c
00000000 l    df *ABS*	00000000 test_module_simucam.c
00000000 l    df *ABS*	00000000 util.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 divsf3.c
00000000 l    df *ABS*	00000000 mulsf3.c
00000000 l    df *ABS*	00000000 floatsisf.c
00000000 l    df *ABS*	00000000 floatunsisf.c
00000000 l    df *ABS*	00000000 gedf2.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 subdf3.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 extendsfdf2.c
00000000 l    df *ABS*	00000000 truncdfsf2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 atoi.c
00000000 l    df *ABS*	00000000 atoll.c
00000000 l    df *ABS*	00000000 ctype_.c
81150b51 l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 fopen.c
00000000 l    df *ABS*	00000000 fprintf.c
00000000 l    df *ABS*	00000000 fputc.c
00000000 l    df *ABS*	00000000 fseek.c
00000000 l    df *ABS*	00000000 fseeko.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 fwrite.c
00000000 l    df *ABS*	00000000 impure.c
81151710 l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 openr.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 refill.c
81122c40 l     F .text	0000001c lflush
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 scanf.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strcspn.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 strnlen.c
00000000 l    df *ABS*	00000000 strtol.c
00000000 l    df *ABS*	00000000 strtoll.c
00000000 l    df *ABS*	00000000 strtoll_r.c
00000000 l    df *ABS*	00000000 vfprintf.c
81150d1e l     O .rodata	00000010 zeroes.4389
81150d2e l     O .rodata	00000010 blanks.4388
00000000 l    df *ABS*	00000000 vfprintf.c
81150d3e l     O .rodata	00000010 zeroes.4404
81127bbc l     F .text	000000c4 __sbprintf
81150d4e l     O .rodata	00000010 blanks.4403
00000000 l    df *ABS*	00000000 vfscanf.c
81150d66 l     O .rodata	00000022 basefix.4359
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 dtoa.c
811298a4 l     F .text	00000208 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
8112b3f4 l     F .text	00000008 __fp_unlock
8112b408 l     F .text	000001a4 __sinit.part.1
8112b5ac l     F .text	00000008 __fp_lock
00000000 l    df *ABS*	00000000 flags.c
00000000 l    df *ABS*	00000000 fread.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 iswspace.c
00000000 l    df *ABS*	00000000 locale.c
81151f5c l     O .rwdata	00000020 lc_ctype_charset
81151f3c l     O .rwdata	00000020 lc_message_charset
81151f7c l     O .rwdata	00000038 lconv
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 mbrtowc.c
00000000 l    df *ABS*	00000000 mbtowc_r.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mprec.c
81150da4 l     O .rodata	0000000c p05.2768
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 sccl.c
00000000 l    df *ABS*	00000000 sf_nan.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 strtod.c
8112e41c l     F .text	0000006c sulp
81150eec l     O .rodata	00000014 fpi.2737
81150f00 l     O .rodata	00000028 tinytens
81150ed8 l     O .rodata	00000014 fpinan.2773
00000000 l    df *ABS*	00000000 strtoul.c
00000000 l    df *ABS*	00000000 strtoull_r.c
00000000 l    df *ABS*	00000000 vfprintf.c
81150f38 l     O .rodata	00000010 blanks.4332
81150f28 l     O .rodata	00000010 zeroes.4333
00000000 l    df *ABS*	00000000 ungetc.c
00000000 l    df *ABS*	00000000 vfprintf.c
811317a4 l     F .text	00000104 __sprint_r.part.0
81150f58 l     O .rodata	00000010 blanks.4348
81150f48 l     O .rodata	00000010 zeroes.4349
81132d40 l     F .text	000000c4 __sbprintf
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fputwc.c
00000000 l    df *ABS*	00000000 gdtoa-gethex.c
811331f4 l     F .text	00000100 rshift
00000000 l    df *ABS*	00000000 gdtoa-hexnan.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 wcrtomb.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 eqsf2.c
00000000 l    df *ABS*	00000000 gesf2.c
00000000 l    df *ABS*	00000000 lesf2.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 divdf3.c
00000000 l    df *ABS*	00000000 eqdf2.c
00000000 l    df *ABS*	00000000 ledf2.c
00000000 l    df *ABS*	00000000 floatunsidf.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_close.c
811363d0 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
81136514 l     F .text	00000034 alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
81136548 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_irq_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_isatty.c
811367cc l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_log_macro.o
811368c4 l       .text	00000000 tx_next_char
811368ec l       .text	00000000 end_tx
811368cc l       .text	00000000 wait_tx_ready_loop
00000000 l    df *ABS*	00000000 alt_log_printf.c
00000000 l    df *ABS*	00000000 alt_lseek.c
811373c8 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_open.c
81137644 l     F .text	00000044 alt_get_errno
81137688 l     F .text	000000cc alt_file_locked
00000000 l    df *ABS*	00000000 alt_read.c
811378b0 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
81153474 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
81137e50 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_env_lock.c
81153480 l     O .rwdata	00000004 lockid
81153650 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
81153484 l     O .rwdata	00000004 lockid
81153658 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 os_core.c
811398dc l     F .text	00000050 OS_InitMisc
8113992c l     F .text	00000074 OS_InitRdyList
81139ab0 l     F .text	000000ec OS_InitTCBList
811397f4 l     F .text	000000e8 OS_InitEventList
811399a0 l     F .text	00000088 OS_InitTaskIdle
81139a28 l     F .text	00000088 OS_InitTaskStat
81139d40 l     F .text	0000007c OS_SchedNew
00000000 l    df *ABS*	00000000 os_dbg.c
00000000 l    df *ABS*	00000000 os_flag.c
8113bb58 l     F .text	000000fc OS_FlagTaskRdy
8113b908 l     F .text	00000168 OS_FlagBlock
00000000 l    df *ABS*	00000000 os_mem.c
00000000 l    df *ABS*	00000000 os_mutex.c
8113d444 l     F .text	00000198 OSMutex_RdyAtPrio
00000000 l    df *ABS*	00000000 os_q.c
00000000 l    df *ABS*	00000000 os_sem.c
00000000 l    df *ABS*	00000000 os_task.c
00000000 l    df *ABS*	00000000 os_time.c
00000000 l    df *ABS*	00000000 os_tmr.c
81141e74 l     F .text	00000044 OSTmr_Lock
81141914 l     F .text	00000074 OSTmr_Alloc
81141eb8 l     F .text	0000003c OSTmr_Unlock
81141d78 l     F .text	000000fc OSTmr_Unlink
81141988 l     F .text	000000a4 OSTmr_Free
81141c28 l     F .text	00000150 OSTmr_Link
81141ba0 l     F .text	00000088 OSTmr_InitTask
81141ef4 l     F .text	00000110 OSTmr_Task
00000000 l    df *ABS*	00000000 alt_sys_init.c
81142004 l     F .text	0000003c alt_dev_reg
811521f8 l     O .rwdata	0000106c jtag_uart_0
81153264 l     O .rwdata	000000d0 rs232_uart
81153334 l     O .rwdata	00000064 dma_DDR_M1
81153398 l     O .rwdata	00000064 dma_DDR_M2
811533fc l     O .rwdata	0000002c Altera_UP_SD_Card_Avalon_Interface_0
00000000 l    df *ABS*	00000000 Altera_UP_SD_Card_Avalon_Interface.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
81146894 l     F .text	000002bc altera_avalon_jtag_uart_irq
81146b50 l     F .text	0000010c altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
81147354 l     F .text	00000084 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
811476ec l     F .text	000000a4 altera_avalon_uart_irq
81147790 l     F .text	00000140 altera_avalon_uart_rxirq
811478d0 l     F .text	000001ac altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
81147ad8 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
81147d8c l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 altera_msgdma.c
81148010 l     F .text	00000044 alt_get_errno
81148054 l     F .text	0000009c alt_msgdma_write_standard_descriptor
811480f0 l     F .text	00000134 alt_msgdma_write_extended_descriptor
81148224 l     F .text	0000018c alt_msgdma_irq
811483b0 l     F .text	00000094 alt_msgdma_construct_standard_descriptor
81148444 l     F .text	0000015c alt_msgdma_construct_extended_descriptor
811485a0 l     F .text	00000340 alt_msgdma_descriptor_async_transfer
811488e0 l     F .text	00000408 alt_msgdma_descriptor_sync_transfer
81148fe8 l     F .text	000000ac alt_msgdma_construct_prefetcher_standard_descriptor
81149094 l     F .text	0000019c alt_msgdma_construct_prefetcher_extended_descriptor
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
8114a260 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
8114a8a4 l     F .text	000000cc alt_open_fd
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 os_cpu_a.o
00000044 l       *ABS*	00000000 OSCtxSw_SWITCH_PC
00000000 l    df *ABS*	00000000 os_cpu_c.c
81153700 l     O .bss	00000002 OSTmrCtr
00000014 l       *ABS*	00000000 OSTCBNext_OFFSET
00000032 l       *ABS*	00000000 OSTCBPrio_OFFSET
00000000 l       *ABS*	00000000 OSTCBStkPtr_OFFSET
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 strncpy.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
81153704 g     O .bss	00000004 alt_instruction_exception_handler
8110733c g     F .text	00000044 vRmapCh7IrqFlagClrWriteCmd
81153f88 g     O .bss	00001000 vFeeTask0_stk
8111be94 g     F .text	0000004c vFailDeleteInitialization
8111a6ac g     F .text	00000fd0 vLoadDebugConfs
811536d4 g     O .bss	00000004 aux_status_register
81154f88 g     O .bss	00001000 vInAckHandlerTask_stk
8114a01c g     F .text	00000044 alt_msgdma_standard_descriptor_async_transfer
81107684 g     F .text	00000050 uliRmapCh1WriteCmdAddress
8110cbb4 g     F .text	0000004c vSyncInitIrq
81116e80 g     F .text	00000284 vCheckRetransmission128
8112daa0 g     F .text	0000007c _mprec_log10
8110cdbc g     F .text	00000040 bSyncSetMbt
8111d458 g     F .text	00000054 vFailRequestDMAFromIRQ
8110ae28 g     F .text	00000108 I2C_Read
811534d2 g     O .rwdata	00000002 OSTaskNameSize
81153598 g     O .bss	00000004 xWaitSyncQFee
81155f88 g     O .bss	00000260 xBuffer64
8112db94 g     F .text	0000008c __any_on
8112c568 g     F .text	0000005c _isatty_r
81150db0 g     O .rodata	00000028 __mprec_tinytens
8110762c g     F .text	00000058 bRmapCh8IrqFlagWriteCmd
811374e8 g     F .text	0000015c alt_main
811066d0 g     F .text	00000078 bFeebGetRightBufferEmpty
81122b64 g     F .text	000000c8 _puts_r
81105918 g     F .text	00000058 bFeebCh3IrqFlagBufferEmpty
81153660 g     O .bss	00000004 OSTmrFreeList
8116d678 g     O .bss	00000100 alt_irq
8112c6d8 g     F .text	00000068 _lseek_r
8111e744 g     F .text	00000030 vChangeDefaultAutoResetSync
8113c3b8 g     F .text	000000d4 OS_MemInit
8111d404 g     F .text	00000054 vFailRequestDMA
81106748 g     F .text	00000068 bFeebGetCh1LeftBufferEmpty
811199a4 g     F .text	000009d8 vLoadDefaultETHConf
8111227c g     F .text	0000014c bCheckInAck64
811561e8 g     O .bss	00000150 xPus
81140e54 g     F .text	00000068 OSTimeSet
81115b2c g     F .text	0000008c vPusType250run
8112b7ac g     F .text	000000ac __sflags
8111cdd8 g     F .text	00000068 vCoudlNotCreateNFee2Task
8111d1c4 g     F .text	0000004c vCouldNotGetMutexMebPus
81136074 g     F .text	00000088 .hidden __eqdf2
811161f8 g     F .text	00000088 vSendCmdQToDataCTRL
81102a8c g     F .text	0000004c DMA_DESCRIPTOR_BUFFER_FULL
8111e630 g     F .text	00000034 vLoadDefaultSyncSource
8111b92c g     F .text	0000004c vFailCreateMutexDMA
81142504 g     F .text	000001ac Check_for_Master_Boot_Record
8116708c g     O .bss	00000010 OSTmrWheelTbl
81107724 g     F .text	00000050 uliRmapCh3WriteCmdAddress
81148da8 g     F .text	00000060 alt_msgdma_construct_standard_mm_to_mm_descriptor
81156338 g     O .bss	00000020 xFeeQueueTBL3
81138540 g     F .text	00000594 OSEventPendMulti
8115359c g     O .bss	00000004 xNfeeSchedule
8116d778 g       *ABS*	00000000 __alt_heap_start
8114aedc g     F .text	0000002c OSTaskCreateHook
8114637c g     F .text	000001c4 alt_up_sd_card_fclose
811535a0 g     O .bss	00000004 xSemCountBuffer64
81104700 g     F .text	0000016c bCommSetGlobalIrqEn
81107b28 g     F .text	00000088 bRmapGetIrqControl
811229a8 g     F .text	00000044 printf
81153569 g     O .bss	00000001 SspdConfigControl
8110d1d8 g     F .text	00000054 bSyncCtrReset
811534aa g     O .rwdata	00000002 OSMboxEn
8111038c g     F .text	00000424 vQCmdFeeRMAPWaitingSync
8111f2bc g     F .text	000000a4 aatoh
81138b38 g     F .text	00000054 OSIntEnter
81133e60 g     F .text	000000a4 _wcrtomb_r
81105824 g     F .text	00000044 vFeebCh8IrqFlagClrBufferEmpty
8111bdfc g     F .text	0000004c vFailReceiverCreate
811535a4 g     O .bss	00000004 xQMaskDataCtrl
81105378 g     F .text	00000040 vFeebCh2HandleIrq
811230cc g     F .text	00000064 __sseek
8112b75c g     F .text	00000010 __sinit
8110be54 g     F .text	00000044 iMsgdmaExtendedDescriptorAsyncTransfer
81129524 g     F .text	00000148 __swbuf_r
81117658 g     F .text	00000470 bResourcesInitRTOS
8110a590 g     F .text	000000f4 bSpwcGetLinkError
811534ba g     O .rwdata	00000002 OSQEn
8110fa18 g     F .text	00000518 vQCmdFeeRMAPinStandBy
81107064 g     F .text	00000040 vRmapCh4HandleIrq
8112c5f4 g     F .text	00000084 _setlocale_r
81156358 g     O .bss	00000020 SyncTBL2
81153430 g     O .rwdata	00000004 LedsPainelControl
81153870 g     O .bss	00000100 cDebugBuffer
8112b5b4 g     F .text	00000070 __sfmoreglue
8113178c g     F .text	00000018 ungetc
81105b28 g     F .text	000000d4 bFeebCh1SetBufferSize
811381fc g     F .text	000000d4 __malloc_unlock
81102d88 g     F .text	00000214 DMA_MULTIPLE_TRANSFER
8114af5c g     F .text	00000028 OSTaskStatHook
81116054 g     F .text	00000088 vSendCmdQToNFeeCTRL
8111e6a0 g     F .text	00000030 vChangeDefaultSyncSource
81153664 g     O .bss	00000001 OSLockNesting
81153668 g     O .bss	00000004 OSTmrSemSignal
8111d884 g     F .text	0000023c vNFeeStructureInit
811535a8 g     O .bss	00000004 xSemCommInit
81102910 g     F .text	00000080 uliXorshift32
8112e488 g     F .text	00001600 _strtod_r
811535ac g     O .bss	00000004 xSemCountSenderACK
8111f474 g     F .text	00000448 .hidden __divsf3
811536f8 g     O .bss	00000004 current_sector_modified
811534f8 g     O .rwdata	00000002 OSDataSize
8115366c g     O .bss	00000001 OSRunning
8110a86c g     F .text	00000184 bSpwcInitCh
811371b0 g     F .text	00000064 alt_log_jtag_uart_isr_proc
81156378 g     O .bss	00001000 senderTask_stk
8110861c g     F .text	00000094 bRmapGetMemConfigStat
811535b0 g     O .bss	00000004 fp
81157378 g     O .bss	00000048 xNfeeScheduleTBL
81112134 g     F .text	00000148 bCheckInAck128
8112ca68 g     F .text	0000015c memmove
8114afd8 g     F .text	0000002c OSInitHookBegin
8110d674 g     F .text	00000074 bSyncCtrCh8OutEnable
8111091c g     F .text	00000098 bEnableDbBuffer
811534f0 g     O .rwdata	00000002 OSTmrSize
8112b744 g     F .text	00000018 _cleanup
8111eb60 g     F .text	00000040 siCloseFile
81106c90 g     F .text	00000184 bFeebInitCh
8112cbc4 g     F .text	000000b0 _Balloc
8111e6d0 g     F .text	00000038 vLoadDefaultAutoResetSync
81107c38 g     F .text	000000d8 bRmapSetCodecConfig
81144f58 g     F .text	000000cc alt_up_sd_card_is_Present
81148ce8 g     F .text	00000060 alt_msgdma_construct_standard_st_to_mm_descriptor
8115350c g     O .bss	00000004 pxDmaM1Dev
81102b24 g     F .text	000000a8 DMA_DISPATCHER_STOP
8114222c g     F .text	00000054 Save_Modified_Sector
81105a78 g     F .text	00000058 bFeebCh7IrqFlagBufferEmpty
81153670 g     O .bss	00000004 OSIdleCtr
8115362c g     O .bss	00000001 alt_log_write_on_flag
8110aa94 g     F .text	0000003c bEnableIsoDrivers
8111fee4 g     F .text	000000dc .hidden __gtdf2
8114ac6c g     F .text	0000002c altera_nios2_gen2_irq_init
8114ad54 g       .text	00000000 OSStartTsk
8110cf30 g     F .text	00000070 bSyncSetNCycles
8113a0b0 g     F .text	000002dc OS_TCBInit
8115362f g     O .bss	00000001 alt_log_jtag_uart_isr_on_flag
8111e2b8 g     F .text	00000078 vInitSimucamBasicHW
811573c0 g     O .bss	00001000 vTimeoutCheckerTask_stk
8110d58c g     F .text	00000074 bSyncCtrCh6OutEnable
8110b1a4 g     F .text	00000138 i2c_write
86020000 g     F .entry	00000000 __reset
811536f0 g     O .bss	00000004 fat_partition_size_in_512_byte_sectors
81153674 g     O .bss	00000002 OSTmrUsed
811535b4 g     O .bss	00000004 xSemCountBuffer128
81103264 g     F .text	000000f8 TEMP_Read
81107a80 g     F .text	000000a8 bRmapSetIrqControl
81105e78 g     F .text	000000d4 bFeebCh5SetBufferSize
811583c0 g     O .bss	00001000 vDataControlTask_stk
8110543c g     F .text	00000084 vFeebCh4HandleIrq
811534f6 g     O .rwdata	00000002 OSTmrWheelTblSize
8111df60 g     F .text	0000002c cFeeSpwChannelDisable
81153496 g     O .rwdata	00000002 OSEventSize
81153676 g     O .bss	00000001 OSPrioHighRdy
81121b44 g     F .text	00000064 _fstat_r
8114af08 g     F .text	0000002c OSTaskDelHook
81153608 g     O .bss	00000004 errno
8110d968 g     F .text	0000003c uliSyncGetCtr
811294b4 g     F .text	0000001c __svfscanf
81123040 g     F .text	00000008 __seofread
8114ad34 g       .text	00000000 OSStartHighRdy
8111d7e4 g     F .text	00000028 vEvtChangeFeeControllerMode
81110b68 g     F .text	00000968 vPrintConsoleNFee
811130e8 g     F .text	000000c8 bSendCmdQToNFeeInst
81107124 g     F .text	00000040 vRmapCh7HandleIrq
8113f884 g     F .text	000001ec OSTaskCreateExt
81167060 g     O .bss	00000011 alt_log_write_buf
81104c0c g     F .text	0000012c bDpktGetPacketConfig
811078b4 g     F .text	00000050 uliRmapCh8WriteCmdAddress
8111c1b8 g     F .text	00000068 vFailGetCountSemaphorePreParsedBuffer
811302d0 g     F .text	00001244 ___svfiprintf_internal_r
81114c84 g     F .text	00000364 bPreParserV2
8113b438 g     F .text	00000068 OSFlagPendGetFlagsRdy
811534d6 g     O .rwdata	00000002 OSTaskStatStkSize
81106880 g     F .text	00000068 bFeebGetCh2RightBufferEmpty
8113a584 g     F .text	00000310 OSFlagAccept
8113db60 g     F .text	000000c0 OSQFlush
81153d70 g     O .bss	00000118 xRmap
8113d5dc g     F .text	00000148 OSQAccept
81153640 g     O .bss	00000004 alt_argv
8115b428 g       *ABS*	00000000 _gp
8111bac4 g     F .text	0000004c vFailSendPreAckReceiverSemaphore
81137d14 g     F .text	0000013c usleep
81145530 g     F .text	00000384 alt_up_sd_card_fopen
8111e9cc g     F .text	00000030 bSDcardIsPresent
81114fe8 g     F .text	00000178 vSenderComTask
81145098 g     F .text	000000d8 alt_up_sd_card_find_first
8113f6d0 g     F .text	000001b4 OSTaskCreate
8111c358 g     F .text	00000068 vFailSendNack
811536e4 g     O .bss	00000004 command_argument_register
8113f1d8 g     F .text	000004f8 OSTaskChangePrio
811156f0 g     F .text	000000ac vPusMebInTaskConfigMode
8111cad0 g     F .text	00000088 vCouldNotSendTMPusCommand
8115365c g     O .bss	00000004 alt_heapsem
8111de00 g     F .text	000000b0 vResetMemCCDFEE
8110b43c g     F .text	00000080 bSetBoardLeds
8113a38c g     F .text	000001f8 OSDebugInit
8113fa70 g     F .text	0000034c OSTaskDel
8113c48c g     F .text	000001ac OSMutexAccept
811593c0 g     O .bss	000002b8 xSimMeb
8111e19c g     F .text	00000040 vSetTimeCode
81149890 g     F .text	000000dc alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits
811535b8 g     O .bss	00000004 xSemCountPreParsed
81151fdc g     O .rwdata	00000180 alt_fd_list
811059c8 g     F .text	00000058 bFeebCh5IrqFlagBufferEmpty
81152178 g     O .rwdata	0000001d alt_log_msg_alt_main
8116709c g     O .bss	00000840 OSFlagTbl
811073c4 g     F .text	00000058 bRmapCh1IrqFlagWriteCmd
8111bc2c g     F .text	00000068 vFailGetCountSemaphoreReceiverTask
811077c4 g     F .text	00000050 uliRmapCh5WriteCmdAddress
8111e588 g     F .text	0000003c vLoadDefaultRTValue
811395bc g     F .text	000000c0 OS_EventTaskRemove
81159678 g     O .bss	00001000 vFeeTask5_stk
8115362e g     O .bss	00000001 alt_log_jtag_uart_alarm_on_flag
811447ac g     F .text	00000134 find_first_empty_record_in_root_directory
8114a350 g     F .text	00000098 alt_find_dev
81122690 g     F .text	00000150 memcpy
81133b2c g     F .text	00000264 __hexnan
81105008 g     F .text	00000174 bDpktInitCh
8115a678 g     O .bss	00000160 xBuffer32
811534c0 g     O .rwdata	00000002 OSRdyTblSize
811678dc g     O .bss	000001a0 OSTmrTbl
8112b3fc g     F .text	0000000c _cleanup_r
81121064 g     F .text	000000e4 .hidden __floatsidf
811195cc g     F .text	000001a8 vSendPusTM64
8110cd2c g     F .text	0000004c ucSyncStatusErrorCode
81116164 g     F .text	00000094 vSendCmdQToNFeeCTRL_GEN
8111e05c g     F .text	00000034 cFeeRMAPLogDisable
81113570 g     F .text	00000df0 vParserCommTask
8114a970 g     F .text	00000084 alt_io_redirect
8111dff0 g     F .text	00000034 cFeeRMAPEchoingDisable
811360fc g     F .text	000000f4 .hidden __ltdf2
8111d110 g     F .text	0000004c vFailSendPUStoMebTask
811075d4 g     F .text	00000058 bRmapCh7IrqFlagWriteCmd
81106344 g     F .text	000000d4 bFeebSetIrqControl
8111c8c8 g     F .text	00000068 vCouldNotRetransmitB128TimeoutTask
811535bc g     O .bss	00000004 xMutexReceivedACK
81103be0 g     F .text	000000b0 bSdmaInitM2Dma
81153524 g     O .bss	00000004 EDpktMode
81149d18 g     F .text	00000094 alt_msgdma_start_prefetcher_with_extd_desc_list
8114a060 g     F .text	00000044 alt_msgdma_extended_descriptor_async_transfer
8110d280 g     F .text	00000054 bSyncCtrErrInj
81149fc0 g     F .text	0000005c alt_msgdma_register_callback
8111a37c g     F .text	00000330 vShowEthConfig
8111e330 g     F .text	00000030 bLogWriteSDCard
8111bf48 g     F .text	00000068 vFailSetCountSemaphorexBuffer64
81122c2c g     F .text	00000014 puts
8111ebe0 g     F .text	000002bc bInitSync
8114b080 g     F .text	000000a4 alt_exception_cause_generated_bad_addr
8110ca60 g     F .text	00000128 vSyncHandleIrq
811382d0 g     F .text	00000128 OSEventNameGet
8110568c g     F .text	00000044 vFeebCh2IrqFlagClrBufferEmpty
811534a4 g     O .rwdata	00000002 OSFlagMax
8112c7f4 g     F .text	000000e0 mbrtowc
811443a4 g     F .text	000001b4 find_first_empty_cluster
81116280 g     F .text	00000088 vSendCmdQToDataCTRL_PRIO
8110d518 g     F .text	00000074 bSyncCtrCh5OutEnable
81153570 g     O .bss	00000001 vucN
8112e1f4 g     F .text	00000074 __fpclassifyd
8110cc8c g     F .text	00000054 bSyncStatusExtnIrq
811294d0 g     F .text	00000054 _vfscanf_r
8113cb0c g     F .text	000005a4 OSMutexPend
8112d9f4 g     F .text	000000ac __ratio
81144e94 g     F .text	000000c4 alt_up_sd_card_open_dev
8111cb58 g     F .text	00000068 vWarnCouldNotgetMutexRetrans128
81138b8c g     F .text	00000100 OSIntExit
8110cdfc g     F .text	00000040 bSyncSetBt
81132d24 g     F .text	0000001c __vfiprintf_internal
8111d210 g     F .text	00000068 vCouldNotCreateQueueMaskNfeeCtrl
811534de g     O .rwdata	00000002 OSTCBSize
81105648 g     F .text	00000044 vFeebCh1IrqFlagClrBufferEmpty
81153677 g     O .bss	00000001 OSPrioCur
81146dc4 g     F .text	000002c4 altera_avalon_jtag_uart_read
81149558 g     F .text	000000f8 alt_msgdma_prefetcher_add_standard_desc_to_list
81122970 g     F .text	00000038 _printf_r
81134c18 g     F .text	00000064 .hidden __udivsi3
81136810 g     F .text	000000ac isatty
81153568 g     O .bss	00000001 LedsBoardControl
811535c0 g     O .bss	00000004 xSemCountReceivedACK
811534c4 g     O .rwdata	00000002 OSStkWidth
8112c5c4 g     F .text	00000030 iswspace
81150e00 g     O .rodata	000000c8 __mprec_tens
811534b8 g     O .rwdata	00000002 OSPtrSize
8111d4ac g     F .text	00000054 vFailSendRMAPFromIRQ
8111cf78 g     F .text	00000068 vCoudlNotCreateNFeeControllerTask
8112c678 g     F .text	0000000c __locale_charset
8110d430 g     F .text	00000074 bSyncCtrCh3OutEnable
811234bc g     F .text	0000001c strtoll
81134e08 g     F .text	000000c8 .hidden __lesf2
81153498 g     O .rwdata	00000002 OSEventTblSize
8111f3f8 g     F .text	0000007c .hidden __fixunsdfsi
8114ac98 g       .text	00000000 OSCtxSw
8110af30 g     F .text	00000160 I2C_MultipleRead
81137354 g     F .text	00000074 alt_log_system_clock
81153614 g     O .bss	00000004 __malloc_top_pad
81153678 g     O .bss	00000004 OSTCBList
811418d4 g     F .text	00000040 OSTmrSignal
81153624 g     O .bss	00000004 alt_fd_list_lock
8112fdfc g     F .text	0000001c strtoul
81153448 g     O .rwdata	00000004 __mb_cur_max
8112c6a8 g     F .text	0000000c _localeconv_r
8112fe18 g     F .text	000002e0 _strtoull_r
8110c4a4 g     F .text	00000070 vRstcHoldDeviceReset
8112cfe8 g     F .text	00000044 __i2b
8112bf0c g     F .text	000004c4 __sfvwrite_r
81143684 g     F .text	000000c0 get_dir_divider_location
81107270 g     F .text	00000044 vRmapCh4IrqFlagClrWriteCmd
81167a7c g     O .bss	00000c30 OSMemTbl
8115367c g     O .bss	00000001 OSTickStepState
81136f64 g     F .text	00000060 alt_log_printf_proc
81104f44 g     F .text	000000c4 bDpktGetPixelDelay
8115a7d8 g     O .bss	00001800 vReceiverUartTask_stk
81122e38 g     F .text	0000005c _sbrk_r
811535c4 g     O .bss	00000004 xSemTimeoutChecker
81143344 g     F .text	000000cc filename_to_upper_case
81153630 g     O .bss	00000001 alt_log_jtag_uart_startup_info_on_flag
811534bc g     O .rwdata	00000002 OSQMax
811458b4 g     F .text	00000090 alt_up_sd_card_set_attributes
8113c808 g     F .text	00000304 OSMutexDel
811686ac g     O .bss	00001000 OSTaskStatStk
8111e9fc g     F .text	00000030 bSDcardFAT16Check
8113bfd4 g     F .text	000000f8 OSMemNameGet
8111b8cc g     F .text	00000060 vFailCreateMutexSResources
811426b0 g     F .text	00000284 Read_File_Record_At_Offset
8115bfd8 g     O .bss	00000040 xQMaskCMDNDataCtrlTBL
8115349c g     O .rwdata	00000002 OSFlagEn
8112dc20 g     F .text	00000068 _read_r
811534e2 g     O .rwdata	00000002 OSTimeTickHookEn
8113bc54 g     F .text	000000ac OS_FlagUnlink
8113e028 g     F .text	00000170 OSQPost
81102478 g     F .text	00000498 bDdr2MemoryRandomReadTest
81153464 g     O .rwdata	00000004 alt_max_fd
8111c674 g     F .text	0000004c vFailTimeoutCheckerTaskCreate
81139bf8 g     F .text	00000070 OS_MemCopy
81139c68 g     F .text	000000d8 OS_Sched
81143f28 g     F .text	0000047c find_file_in_directory
81132ed0 g     F .text	000000f8 _fclose_r
8113bedc g     F .text	000000f8 OSMemGet
811400b4 g     F .text	000001bc OSTaskNameSet
8112b3c4 g     F .text	00000030 fflush
81153610 g     O .bss	00000004 __malloc_max_sbrked_mem
81153680 g     O .bss	00000004 OSCtxSwCtr
81105f4c g     F .text	000000d4 bFeebCh6SetBufferSize
8114af84 g     F .text	00000054 OSTimeTickHook
8115c018 g     O .bss	00001000 vOutAckHandlerTask_stk
81136644 g     F .text	00000188 alt_irq_register
811534a6 g     O .rwdata	00000002 OSFlagNameSize
81121148 g     F .text	00000118 .hidden __extendsfdf2
8113967c g     F .text	00000108 OS_EventTaskRemoveMulti
8111cc98 g     F .text	00000070 vFailCreateNFEESyncQueue
81145024 g     F .text	00000074 alt_up_sd_card_is_FAT16
8110acc0 g     F .text	00000088 I2C_TestAdress
81134ed0 g     F .text	000008b4 .hidden __adddf3
81167074 g     O .bss	00000018 alt_log_jtag_uart_alarm_1
81134cd4 g     F .text	00000078 .hidden __nesf2
8110722c g     F .text	00000044 vRmapCh3IrqFlagClrWriteCmd
811052ac g     F .text	0000008c usiLineTrDelayCalcPeriodNs
81139464 g     F .text	00000158 OS_EventTaskWaitMulti
8115d018 g     O .bss	00000020 SyncTBL4
8112d78c g     F .text	00000114 __b2d
81149290 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor
811534be g     O .rwdata	00000002 OSQSize
811345e0 g     F .text	00000540 .hidden __umoddi3
8113740c g     F .text	000000dc lseek
8113eb18 g     F .text	00000214 OSSemPend
8111d15c g     F .text	00000068 vCouldNotGetCmdQueueMeb
81107d9c g     F .text	00000160 bRmapGetCodecStatus
8110a684 g     F .text	000000d0 bSpwcGetLinkStatus
81106a70 g     F .text	00000088 bFeebGetWindowing
81153438 g     O .rwdata	00000004 _global_impure_ptr
8110ca14 g     F .text	0000004c bSSDisplayUpdate
81121490 g     F .text	0000000c _atoll_r
811439e8 g     F .text	00000540 get_home_directory_cluster_for_file
8112dc88 g     F .text	0000056c _realloc_r
811534a8 g     O .rwdata	00000002 OSLowestPrio
8116d778 g       *ABS*	00000000 __bss_end
8114a7ac g     F .text	000000f8 alt_iic_isr_register
8114b054 g     F .text	0000002c OSTCBInitHook
811534ee g     O .rwdata	00000002 OSTmrCfgTicksPerSec
81137c04 g     F .text	00000110 alt_tick
81107904 g     F .text	0000017c vRmapInitIrq
8111bbc4 g     F .text	00000068 vFailGetMutexSenderTask
8110c3c4 g     F .text	0000006c vRstcSimucamReset
81110a20 g     F .text	000000a4 bSendRequestNFeeCtrl
81150f68 g     O .rodata	00000100 __hexdig
81149e0c g     F .text	000001b4 alt_msgdma_init
81134060 g     F .text	00000580 .hidden __udivdi3
8111496c g     F .text	0000017c setPreAckSenderFreePos
81133148 g     F .text	00000024 _fputwc_r
81153490 g     O .rwdata	00000002 OSEventEn
81150dd8 g     O .rodata	00000028 __mprec_bigtens
8112cdc4 g     F .text	0000010c __s2b
811534ea g     O .rwdata	00000002 OSTmrCfgNameSize
8115d038 g     O .bss	00000020 xFeeQueueTBL4
8110cebc g     F .text	00000074 bSyncSetPolarity
81117104 g     F .text	0000028c vCheckRetransmission64
811361f0 g     F .text	000000b0 .hidden __floatunsidf
81153634 g     O .bss	00000004 alt_system_clock_in_sec
8113715c g     F .text	00000054 alt_log_jtag_uart_startup_info
8111c150 g     F .text	00000068 vFailFoundBufferRetransmission
8112d4c4 g     F .text	00000060 __mcmp
811536fc g     O .bss	00000004 current_sector_index
81147584 g     F .text	00000168 altera_avalon_uart_init
8114a0e8 g     F .text	00000044 alt_msgdma_extended_descriptor_sync_transfer
811041c4 g     F .text	0000053c bSdmaDmaM2Transfer
8111e1dc g     F .text	00000034 vResetTimeCode
8111df34 g     F .text	0000002c cFeeSpwChannelEnable
8112b77c g     F .text	00000018 __fp_lock_all
8111d640 g     F .text	0000004c vFailSendMsgDataCTRL
8114a758 g     F .text	00000054 alt_ic_irq_enabled
8110ad48 g     F .text	000000e0 I2C_Write
81107474 g     F .text	00000058 bRmapCh3IrqFlagWriteCmd
81153684 g     O .bss	00000002 OSTmrFree
8113ba70 g     F .text	000000e8 OS_FlagInit
81137b60 g     F .text	000000a4 alt_alarm_stop
811234a0 g     F .text	0000001c strtol
8115362d g     O .bss	00000001 alt_log_sys_clk_on_flag
81141080 g     F .text	00000140 OSTmrDel
8114241c g     F .text	000000e8 mark_cluster
811534cc g     O .rwdata	00000002 OSTaskIdleStkSize
81153628 g     O .bss	00000004 alt_irq_active
8113e738 g     F .text	000000b8 OSSemAccept
811216dc g     F .text	0000044c _fseeko_r
81117fa0 g     F .text	00000260 vFillMemmoryPattern
8112321c g     F .text	00000044 strnlen
8113c1e8 g     F .text	000000e0 OSMemPut
8113bd00 g     F .text	000001dc OSMemCreate
81153688 g     O .bss	00000004 OSIdleCtrMax
81119774 g     F .text	000001a8 vSendPusTM128
81100104 g     F .exceptions	000000dc alt_irq_handler
811369ac g     F .text	000005b8 alt_log_private_printf
81151fb4 g     O .rwdata	00000028 alt_dev_null
81148ea0 g     F .text	00000098 alt_msgdma_construct_extended_mm_to_st_descriptor
8110ce7c g     F .text	00000040 bSyncSetOst
811534e0 g     O .rwdata	00000002 OSTicksPerSec
8115215c g     O .rwdata	00000019 alt_log_msg_bss
811448e0 g     F .text	00000194 convert_filename_to_name_extension
811086b0 g     F .text	0000104c bRmapSetRmapMemHKArea
811068e8 g     F .text	000000e0 bFeebSetBufferSize
81115160 g     F .text	00000434 vSimMebTask
8110b090 g     F .text	00000094 i2c_start
8114ac98 g       .text	00000000 OSIntCtxSw
8111d500 g     F .text	00000054 vFailSendMsgSync
8110d4a4 g     F .text	00000074 bSyncCtrCh4OutEnable
81149c84 g     F .text	00000094 alt_msgdma_start_prefetcher_with_std_desc_list
811364ec g     F .text	00000028 alt_dcache_flush_all
8112ced0 g     F .text	00000068 __hi0bits
81115bb8 g     F .text	00000114 vPusType251run
81107814 g     F .text	00000050 uliRmapCh6WriteCmdAddress
8111e5c4 g     F .text	0000003c vChangeRTValue
811536d0 g     O .bss	00000004 is_sd_card_formated_as_FAT16
81116cfc g     F .text	00000184 vCheck
8111d834 g     F .text	00000050 vNFeeNotInUse
81120fe4 g     F .text	00000080 .hidden __fixdfsi
811131b0 g     F .text	000000c8 bSendCmdQToNFeeInst_Prio
811060f4 g     F .text	000000d4 bFeebCh8SetBufferSize
81106b80 g     F .text	00000088 bFeebStopCh
8110da94 g     F .text	00000084 uliPerCalcPeriodMs
81112b0c g     F .text	000003ec vNFeeControlTask
8115d058 g     O .bss	00001000 vInitialTask_stk
811535c8 g     O .bss	00000002 usiIdCMD
8115e058 g     O .bss	00000020 SyncTBL3
8110d184 g     F .text	00000054 bSyncCtrStart
81144558 g     F .text	00000254 find_first_empty_record_in_a_subdirectory
8112fa88 g     F .text	00000018 strtod
81106c08 g     F .text	00000088 bFeebClrCh
8115368c g     O .bss	00000004 OSTCBFreeList
8110757c g     F .text	00000058 bRmapCh6IrqFlagWriteCmd
8113ed2c g     F .text	00000174 OSSemPendAbort
8111bd64 g     F .text	0000004c vFailGetMacRTC
81107774 g     F .text	00000050 uliRmapCh4WriteCmdAddress
81100000 g       *ABS*	00000000 __alt_mem_onchip_memory
8111c5dc g     F .text	0000004c vFailCreateTimerRetransmisison
8111c0e8 g     F .text	00000068 vFailGetCountSemaphorexBuffer32
8111863c g     F .text	000002f0 bSendUART128v2
8111e3f8 g     F .text	000000ec vSimucamStructureInit
8115345c g     O .rwdata	00000008 alt_dev_list
8112160c g     F .text	0000004c _fputc_r
81137e94 g     F .text	0000010c write
811229ec g     F .text	000000a8 _putc_r
811536f4 g     O .bss	00000004 device_pointer
811534e4 g     O .rwdata	00000002 OSVersionNbr
81134d4c g     F .text	000000bc .hidden __gtsf2
8111d724 g     F .text	0000004c vFailFlushMEBQueue
81114360 g     F .text	00000118 getPreParsedPacket
811108bc g     F .text	00000060 bEnableSPWChannel
8113658c g     F .text	000000b8 fstat
8111e244 g     F .text	00000040 vChangeIdNFEEMaster
811215e0 g     F .text	0000002c fprintf
8111e024 g     F .text	00000038 cFeeRMAPLogEnable
81102c74 g     F .text	00000114 DMA_SINGLE_TRANSFER
81105a20 g     F .text	00000058 bFeebCh6IrqFlagBufferEmpty
8111c728 g     F .text	00000068 vFailPostBlockingSemTimeoutTask
8111ef9c g     F .text	00000058 _reg_write
8111e284 g     F .text	00000034 vChangeDefaultIdNFEEMaster
811360fc g     F .text	000000f4 .hidden __ledf2
811070a4 g     F .text	00000040 vRmapCh5HandleIrq
811107b0 g     F .text	00000054 bDisableRmapIRQ
8115e078 g     O .bss	00001000 vStackMonitor_stk
8111ca68 g     F .text	00000068 vCouldNotSendLog
81141300 g     F .text	000001b8 OSTmrRemainGet
8115348c g     O .rwdata	00000004 OSEndiannessTest
8110c5b8 g     F .text	00000058 v_spi_start
8112d22c g     F .text	00000148 __pow5mult
811076d4 g     F .text	00000050 uliRmapCh2WriteCmdAddress
811318c0 g     F .text	00001464 ___vfiprintf_internal_r
81153620 g     O .bss	00000004 __nlocale_changed
81134c7c g     F .text	00000058 .hidden __umodsi3
8110d2d4 g     F .text	00000074 bSyncCtrSyncOutEnable
8111ea2c g     F .text	000000f8 bInitializeSDCard
8111c4f8 g     F .text	0000004c vFailParserCommTaskCreate
8111ca00 g     F .text	00000068 vCouldNotSendReset
81122ed8 g     F .text	00000038 _scanf_r
8111c590 g     F .text	0000004c vFailOutAckHandlerTaskCreate
8115349e g     O .rwdata	00000002 OSFlagGrpSize
8111579c g     F .text	0000008c vPusType250conf
8115f078 g     O .bss	00000058 xInUseRetrans
8110cc3c g     F .text	00000050 bSyncIrqFlagSync
811492f0 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor
811414b8 g     F .text	000000ec OSTmrStateGet
8116d778 g       *ABS*	00000000 end
81105544 g     F .text	00000084 vFeebCh6HandleIrq
81118200 g     F .text	00000260 vPrintMemmoryPattern
8111c288 g     F .text	00000068 vNoContentInPreParsedBuffer
81121b28 g     F .text	0000001c fseeko
81114478 g     F .text	00000168 bSendMessagePUStoMebTask
8111cc28 g     F .text	00000070 vFailCreateNFEEQueue
81121478 g     F .text	0000000c _atoi_r
81147dd0 g     F .text	00000240 altera_avalon_uart_write
811368f0 g     F .text	00000054 alt_log_txchar
811216c0 g     F .text	0000001c fseek
811185ac g     F .text	00000090 vCCDChangeValues
811466c4 g     F .text	000001d0 altera_avalon_jtag_uart_init
81139ef8 g     F .text	000000e4 OS_TaskStat
811001e0 g     F .exceptions	0000007c alt_instruction_exception_entry
8111b9c4 g     F .text	0000004c vFailTestCriticasParts
811fa000 g       *ABS*	00000000 __alt_stack_pointer
8110200c g     F .text	0000046c bDdr2MemoryRandomWriteTest
811473d8 g     F .text	00000084 alt_avalon_timer_sc_init
811069c8 g     F .text	000000a8 bFeebSetWindowing
811474c4 g     F .text	00000068 altera_avalon_uart_write_fd
81121408 g     F .text	00000064 .hidden __clzsi2
8114752c g     F .text	00000058 altera_avalon_uart_close_fd
8115f0d0 g     O .bss	00000020 xMebQTBL
81147088 g     F .text	000002cc altera_avalon_jtag_uart_write
81141a2c g     F .text	00000174 OSTmr_Init
8115f0f0 g     O .bss	00000348 xBuffer128
8112b76c g     F .text	00000004 __sfp_lock_acquire
8110335c g     F .text	00000048 sense_log_temp
8112c984 g     F .text	000000e4 memchr
81139b9c g     F .text	0000005c OS_MemClr
811259a0 g     F .text	00002200 ___vfprintf_internal_r
8114ad78 g     F .text	00000164 OSTaskStkInit
81122f10 g     F .text	00000060 _sprintf_r
81108348 g     F .text	000002d4 bRmapGetMemConfigArea
811535ca g     O .bss	00000001 SemCount32
8112bbf4 g     F .text	00000318 _free_r
8114a9f4 g     F .text	00000234 alt_printf
8111957c g     F .text	00000050 vTimeoutCheck
8111f04c g     F .text	000001fc _print_codec_status
8112c684 g     F .text	00000010 __locale_mb_cur_max
811391ac g     F .text	000001a0 OS_EventTaskRdy
81107bb0 g     F .text	00000088 bRmapGetIrqFlags
81102bcc g     F .text	000000a8 DMA_DISPATCHER_RESET
8114b2cc g     F .text	00000188 __call_exitprocs
81112fc0 g     F .text	00000128 vPerformActionNFCRunning
81153690 g     O .bss	00000001 OSCPUUsage
8111cea8 g     F .text	00000068 vCoudlNotCreateNFee4Task
8115361c g     O .bss	00000004 __mlocale_changed
81112ef8 g     F .text	000000c8 vPerformActionNFCConfig
8110d22c g     F .text	00000054 bSyncCtrOneShot
81153440 g     O .rwdata	00000004 __malloc_sbrk_base
8110025c g     F .text	000000ac _start
8110d9a4 g     F .text	0000003c uliSyncReadStatus
81153648 g     O .bss	00000004 _alt_tick_rate
8113dc20 g     F .text	00000294 OSQPend
811234d8 g     F .text	000002e8 _strtoll_r
8115f438 g     O .bss	00000040 xQMaskCMDNFeeCtrlTBL
81167000 g     O .bss	00000044 xDefaults
811409a4 g     F .text	0000010c OSTimeDly
81115a80 g     F .text	000000ac vPusMebInTaskRunningMode
8110cc00 g     F .text	0000003c vSyncIrqFlagClrSync
8112d374 g     F .text	00000150 __lshift
81113278 g     F .text	000002f8 vOutAckHandlerTask
81148d48 g     F .text	00000060 alt_msgdma_construct_standard_mm_to_st_descriptor
8115364c g     O .bss	00000004 _alt_nticks
811378f4 g     F .text	00000104 read
81142080 g     F .text	000000f0 alt_sys_init
8111fcc0 g     F .text	0000012c .hidden __floatsisf
811071e8 g     F .text	00000044 vRmapCh2IrqFlagClrWriteCmd
811300f8 g     F .text	000001d8 __ssprint_r
81122908 g     F .text	00000068 _open_r
8111ef3c g     F .text	00000060 bTestSimucamCriticalHW
8110654c g     F .text	0000010c bFeebGetBuffersStatus
8111b67c g     F .text	000000a4 ucCrc8
81100818 g     F .text	00000cb0 bDdr2EepromDump
81153691 g     O .bss	00000001 OSTaskCtr
811368bc g       .text	00000000 tx_log_str
81115594 g     F .text	0000015c vPusMebTask
8111952c g     F .text	00000050 siPosStr
811160dc g     F .text	00000088 vSendCmdQToNFeeCTRL_PRIO
81133d90 g     F .text	000000d0 strncmp
8110d9e0 g     F .text	0000005c bSyncWriteReg
81107524 g     F .text	00000058 bRmapCh5IrqFlagWriteCmd
81140ab0 g     F .text	00000164 OSTimeDlyHMSM
8112d02c g     F .text	00000200 __multiply
81146c5c g     F .text	00000070 altera_avalon_jtag_uart_close
8110c788 g     F .text	00000058 v_spi_end
8111eba0 g     F .text	00000040 cGetNextChar
8114b1e0 g     F .text	000000ec strncpy
81153848 g     O .bss	00000028 __malloc_current_mallinfo
81153492 g     O .rwdata	00000002 OSEventMax
81134cd4 g     F .text	00000078 .hidden __eqsf2
8112d8a0 g     F .text	00000154 __d2b
8113eea0 g     F .text	00000118 OSSemPost
81105714 g     F .text	00000044 vFeebCh4IrqFlagClrBufferEmpty
8111e600 g     F .text	00000030 vChangeDefaultRTValue
81105608 g     F .text	00000040 vFeebCh8HandleIrq
811536cc g     O .bss	00000004 initialized
811193dc g     F .text	00000100 vSendLog
81138d20 g     F .text	000000e4 OSSchedUnlock
8110c7e0 g     F .text	00000164 RTCC_SPI_R_MAC
81153470 g     O .rwdata	00000004 alt_log_boot_on_flag
81146540 g     F .text	00000068 altera_avalon_jtag_uart_read_fd
8112fba8 g     F .text	00000254 _strtoul_r
8115f478 g     O .bss	00000020 xFeeQueueTBL5
8114a4f8 g     F .text	000000e4 alt_get_fd
81153694 g     O .bss	00000004 OSMemFreeList
81138e7c g     F .text	000000b8 OSStatInit
8111ef08 g     F .text	00000034 bClearCounterSync
81102990 g     F .text	00000064 DMA_OPEN_DEVICE
8116d110 g     O .bss	00000014 search_data
8110a378 g     F .text	00000134 bSpwcSetLink
811362a0 g     F .text	00000130 alt_busy_sleep
8113b83c g     F .text	000000cc OSFlagQuery
8110d348 g     F .text	00000074 bSyncCtrCh1OutEnable
811534c8 g     O .rwdata	00000002 OSTaskCreateExtEn
8111f248 g     F .text	00000074 _split_codec_status
81129848 g     F .text	0000005c _close_r
8111c2f0 g     F .text	00000068 vCouldNotSendEthConfUART
81112514 g     F .text	000005f8 vInitialTask
81137064 g     F .text	000000f8 alt_log_jtag_uart_print_control_reg
81149230 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor
8114b164 g     F .text	0000007c memcmp
81139184 g     F .text	00000028 OS_Dummy
81146610 g     F .text	00000058 altera_avalon_jtag_uart_close_fd
8116d778 g       *ABS*	00000000 __alt_stack_base
81106020 g     F .text	000000d4 bFeebCh7SetBufferSize
81146668 g     F .text	0000005c altera_avalon_jtag_uart_ioctl_fd
81105758 g     F .text	00000044 vFeebCh5IrqFlagClrBufferEmpty
81121ba8 g     F .text	000000d4 _fwrite_r
81116410 g     F .text	000000a4 vReleaseSyncMessages
81149350 g     F .text	000000a8 alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor
81105868 g     F .text	00000058 bFeebCh1IrqFlagBufferEmpty
811296ec g     F .text	0000015c __swsetup_r
811696ac g     O .bss	00000300 OSQTbl
8111d2e0 g     F .text	00000068 vCouldNotGetQueueMaskNfeeCtrl
81167044 g     O .bss	0000001c xConfEth
81135784 g     F .text	000008f0 .hidden __divdf3
8111e664 g     F .text	0000003c vChangeSyncSource
8112b624 g     F .text	00000120 __sfp
8116d124 g     O .bss	00000054 boot_sector_data
8111d278 g     F .text	00000068 vCouldNotCreateQueueMaskDataCtrl
8110a7e4 g     F .text	00000088 bSpwcClearTimecode
81102ad8 g     F .text	0000004c DMA_DESCRIPTOR_BUFFER_EMPTY
8112db1c g     F .text	00000078 __copybits
81151b34 g     O .rwdata	00000408 __malloc_av_
8112b778 g     F .text	00000004 __sinit_lock_release
81153504 g     O .bss	00000004 uliInitialState
8110b124 g     F .text	00000080 i2c_stop
8111f360 g     F .text	00000064 Verif_Error
8111f3c4 g     F .text	00000034 toInt
8111bb10 g     F .text	0000004c vFailSendPreAckSenderSemaphore
81153698 g     O .bss	00000004 OSTCBHighRdy
8111ffc0 g     F .text	00000720 .hidden __muldf3
81122fe4 g     F .text	0000005c __sread
8112ba8c g     F .text	0000003c fread
8115369c g     O .bss	00000004 OSQFreeList
8114a3e8 g     F .text	00000110 alt_find_file
8114a2a4 g     F .text	000000ac alt_dev_llist_insert
811380d4 g     F .text	00000128 __malloc_lock
811215b0 g     F .text	00000030 _fprintf_r
81137a64 g     F .text	000000fc sbrk
8111deb0 g     F .text	0000002c vFeeSpwRMAPLoadDefault
8111c080 g     F .text	00000068 vFailGetCountSemaphorexBuffer64
811237c0 g     F .text	000021e0 ___svfprintf_internal_r
8111991c g     F .text	00000088 vTMPusTestConnection
811535cc g     O .bss	00000004 xMebQ
811383f8 g     F .text	00000148 OSEventNameSet
8112b360 g     F .text	00000064 _fflush_r
81132e04 g     F .text	000000cc _calloc_r
811536a0 g     O .bss	00000001 OSRdyGrp
8111d5f4 g     F .text	0000004c vFailSendMsgFeeCTRL
8110cd78 g     F .text	00000044 ucSyncStatusCycleNumber
81107d10 g     F .text	0000008c bRmapGetCodecConfig
811415a4 g     F .text	00000148 OSTmrStart
811054c0 g     F .text	00000084 vFeebCh5HandleIrq
81121598 g     F .text	00000018 fopen
811029f4 g     F .text	0000004c DMA_CONFIG
81153504 g       *ABS*	00000000 __bss_start
81105da4 g     F .text	000000d4 bFeebCh4SetBufferSize
811227e0 g     F .text	00000128 memset
81114830 g     F .text	0000013c setPreParsedFreePos
8110f5ec g     F .text	000001fc vQCmdFEEinStandBy
81149dac g     F .text	00000060 alt_msgdma_open
8111e7bc g     F .text	00000210 pattern_createPattern
81117ddc g     F .text	000001c4 main
8111bc94 g     F .text	00000068 vFailGetMutexReceiverTask
8115f498 g     O .bss	00001000 vNFeeControlTask_stk
81107380 g     F .text	00000044 vRmapCh8IrqFlagClrWriteCmd
8111e51c g     F .text	0000003c vChangeEPValue
811074cc g     F .text	00000058 bRmapCh4IrqFlagWriteCmd
81153644 g     O .bss	00000004 alt_envp
8111d68c g     F .text	0000004c vFailFlushQueue
8115360c g     O .bss	00000004 __malloc_max_total_mem
81149650 g     F .text	000001a0 alt_msgdma_prefetcher_add_extended_desc_to_list
8111b720 g     F .text	0000005c ucCrc8wInit
8111c628 g     F .text	0000004c vCouldNotCheckBufferTimeOutFunction
811465a8 g     F .text	00000068 altera_avalon_jtag_uart_write_fd
81102f9c g     F .text	000002c8 POWER_Read
8110b2dc g     F .text	00000160 i2c_read
81160498 g     O .bss	00000020 SyncTBL5
8112966c g     F .text	00000018 __swbuf
81151268 g     O .rodata	00000100 OSUnMapTbl
81134e08 g     F .text	000000c8 .hidden __ltsf2
81145944 g     F .text	00000090 alt_up_sd_card_get_attributes
8112b858 g     F .text	00000234 _fread_r
8111bb5c g     F .text	00000068 vFailGetCountSemaphoreSenderTask
8110aad0 g     F .text	0000003c bDisableIsoDrivers
811534c2 g     O .rwdata	00000002 OSSemEn
81142170 g     F .text	000000bc Write_Sector_Data
81145d54 g     F .text	00000628 alt_up_sd_card_write
811535d0 g     O .bss	00000004 xFeeQ
811067b0 g     F .text	00000068 bFeebGetCh1RightBufferEmpty
8113b4a0 g     F .text	0000039c OSFlagPost
81123130 g     F .text	00000008 __sclose
8111c930 g     F .text	00000068 vFailStartTimerRetransmission
811fa000 g       *ABS*	00000000 __alt_heap_limit
81132fc8 g     F .text	00000014 fclose
8113934c g     F .text	00000118 OS_EventTaskWait
8111c7f8 g     F .text	00000068 vCouldNotRetransmitB32TimeoutTask
81123260 g     F .text	00000240 _strtol_r
81121260 g     F .text	000001a8 .hidden __truncdfsf2
811604b8 g     O .bss	00000020 xFeeQueueTBL2
81139fdc g     F .text	000000d4 OS_TaskStatStkChk
8113fdbc g     F .text	00000158 OSTaskDelReq
81104d38 g     F .text	000000c4 bDpktGetPacketHeader
81106eb8 g     F .text	000000c4 vRmapCh1HandleIrq
81129aac g     F .text	00001690 _dtoa_r
8114996c g     F .text	00000318 alt_msgdma_start_prefetcher_with_list_addr
81121e7c g     F .text	00000814 _malloc_r
811604d8 g     O .bss	00000020 SyncTBL0
81133fcc g     F .text	00000030 __ascii_wctomb
8113c638 g     F .text	000001d0 OSMutexCreate
8111c790 g     F .text	00000068 vFailCouldNotRetransmitTimeoutTask
811123c8 g     F .text	0000014c bCheckInAck32
81153468 g     O .rwdata	00000004 alt_errno
81149498 g     F .text	000000c0 alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor
81138e04 g     F .text	00000078 OSStart
8110a4ac g     F .text	000000e4 bSpwcGetLink
8110bedc g     F .text	000004e8 POWER_SPI_RW
81131514 g     F .text	000000dc __submore
81136fc4 g     F .text	000000a0 altera_avalon_jtag_uart_report_log
8113806c g     F .text	00000068 __env_unlock
8111cd70 g     F .text	00000068 vCoudlNotCreateNFee1Task
8112c3d0 g     F .text	000000cc _fwalk
81140270 g     F .text	000001dc OSTaskResume
8113c2c8 g     F .text	000000f0 OSMemQuery
811534d4 g     O .rwdata	00000002 OSTaskStatEn
8116d778 g       *ABS*	00000000 __alt_stack_limit
81153514 g     O .bss	00000004 ECommSpwCh
8111e708 g     F .text	0000003c vChangeAutoResetSync
8112c920 g     F .text	00000064 _mbtowc_r
81111de4 g     F .text	00000350 vInAckHandlerTaskV2
811534ae g     O .rwdata	00000002 OSMemMax
8113e198 g     F .text	00000178 OSQPostFront
81122a94 g     F .text	000000d0 putc
81134b20 g     F .text	00000084 .hidden __divsi3
811536a1 g     O .bss	00000006 OSRdyTbl
81153488 g     O .rwdata	00000002 OSDebugEn
811521cc g     O .rwdata	0000002a alt_log_msg_cache
8112bac8 g     F .text	0000012c _malloc_trim_r
81109ec8 g     F .text	000001a4 bRmapInitCh
81153600 g     O .bss	00000008 xSdHandle
8111f8bc g     F .text	00000404 .hidden __mulsf3
811534a0 g     O .rwdata	00000002 OSFlagNodeSize
81153508 g     O .bss	00000004 pnt_memory
8111e774 g     F .text	00000048 vSyncReset
811118bc g     F .text	00000528 vLoadCtemp
8110ce3c g     F .text	00000040 bSyncSetPer
81100308 g     F .text	00000510 bDdr2EepromTest
811536d8 g     O .bss	00000004 status_register
811534e8 g     O .rwdata	00000002 OSTmrCfgMax
8110d7d0 g     F .text	00000074 bSyncIrqFlagClrError
8111c3c0 g     F .text	00000068 vFailSetPreAckSenderBuffer
8112e340 g     F .text	000000dc strcmp
811536e0 g     O .bss	00000004 command_register
8113d724 g     F .text	000001b4 OSQCreate
8113ff14 g     F .text	000001a0 OSTaskNameGet
811604f8 g     O .bss	00001000 vFeeTask4_stk
811614f8 g     O .bss	00000018 xReceivedACK
8113e310 g     F .text	00000214 OSQPostOpt
81138f34 g     F .text	00000228 OSTimeTick
811534d0 g     O .rwdata	00000002 OSTaskMax
8113e7f0 g     F .text	000000e0 OSSemCreate
811534f4 g     O .rwdata	00000002 OSTmrWheelSize
8111cbc0 g     F .text	00000068 vFailCreateScheduleQueue
8111eff4 g     F .text	00000058 _reg_read
8113d2d0 g     F .text	00000174 OSMutexQuery
81110ac4 g     F .text	000000a4 bSendGiveBackNFeeCtrl
81136074 g     F .text	00000088 .hidden __nedf2
811534ca g     O .rwdata	00000002 OSTaskDelEn
8111e4e4 g     F .text	00000038 vLoadDefaultEPValue
81161510 g     O .bss	00001000 vFeeTask1_stk
8110d600 g     F .text	00000074 bSyncCtrCh7OutEnable
8113efb8 g     F .text	00000118 OSSemQuery
8113d8d8 g     F .text	00000288 OSQDel
8113deb4 g     F .text	00000174 OSQPendAbort
811535d4 g     O .bss	00000004 xMutexPreParsed
81142040 g     F .text	00000040 alt_irq_init
811379f8 g     F .text	0000006c alt_release_fd
81142360 g     F .text	000000bc get_cluster_flag
8110d844 g     F .text	00000074 bSyncIrqFlagClrBlank
8114a0a4 g     F .text	00000044 alt_msgdma_standard_descriptor_sync_transfer
8110cb88 g     F .text	0000002c vSyncClearCounter
811114d0 g     F .text	000003ec bPrepareDoubleBuffer
81152198 g     O .rwdata	00000031 alt_log_msg_stackpointer
81122f70 g     F .text	00000074 sprintf
81150950 g     O .rodata	00000100 .hidden __clz_tab
81142934 g     F .text	00000294 Write_File_Record_At_Offset
81101584 g     F .text	0000057c bDdr2MemoryWriteTest
8111bcfc g     F .text	00000068 vFailGetMutexTxUARTSenderTask
81153618 g     O .bss	00000004 _PathLocale
8110d910 g     F .text	00000058 bSyncIrqFlagBlank
8110bd94 g     F .text	000000c0 iMsgdmaConstructExtendedMmToMmDescriptor
811416ec g     F .text	000001e8 OSTmrStop
8110a0c0 g     F .text	00000050 uliRmapReadReg
811194dc g     F .text	00000050 usiGetIdCMD
8110da3c g     F .text	00000058 uliSyncReadReg
8112faa0 g     F .text	00000108 strtof
811053b8 g     F .text	00000084 vFeebCh3HandleIrq
81134d4c g     F .text	000000bc .hidden __gesf2
81123138 g     F .text	0000004c strcspn
81129684 g     F .text	00000068 _write_r
8110c430 g     F .text	00000074 vRstcReleaseDeviceReset
8111c544 g     F .text	0000004c vFailInAckHandlerTaskCreate
81138c8c g     F .text	00000094 OSSchedLock
8111ce40 g     F .text	00000068 vCoudlNotCreateNFee3Task
8112c6b4 g     F .text	00000018 setlocale
811493f8 g     F .text	000000a0 alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor
811699ac g     O .bss	00000800 OSTmrTaskStk
81122e94 g     F .text	00000044 scanf
8111d0b0 g     F .text	00000060 vFailCreateMutexSPUSQueueMeb
8113a894 g     F .text	00000110 OSFlagCreate
81142bc8 g     F .text	00000688 Check_for_DOS_FAT
81116308 g     F .text	00000064 vMebInit
81144a74 g     F .text	000002d0 create_file
8112e338 g     F .text	00000008 nanf
8115343c g     O .rwdata	00000004 _impure_ptr
811536dc g     O .bss	00000004 CSD_register_w0
8115363c g     O .bss	00000004 alt_argc
8111c018 g     F .text	00000068 vFailGetCountSemaphorexBuffer128
8112b13c g     F .text	00000224 __sflush_r
8112c740 g     F .text	000000b4 _mbrtowc_r
8110a754 g     F .text	00000090 bSpwcGetTimecode
8112c6a0 g     F .text	00000008 __locale_cjk_lang
811033a4 g     F .text	0000078c sense_log
81153518 g     O .bss	00000004 ESdmaBufferSide
8115349a g     O .rwdata	00000002 OSEventMultiEn
811216bc g     F .text	00000004 _fseek_r
81162510 g     O .bss	00001800 vParserCommTask_stk
8111b85c g     F .text	00000070 printErrorTask
8111e558 g     F .text	00000030 vChangeDefaultEPValue
81117390 g     F .text	000002c8 vCheckRetransmission32
81140ebc g     F .text	000001c4 OSTmrCreate
811164b4 g     F .text	000007dc vStackMonitor
81122c5c g     F .text	000001dc __srefill_r
8110ab0c g     F .text	0000003c bEnableLvdsBoard
811535d8 g     O .bss	00000004 xMutexBuffer32
81153580 g     O .bss	00000001 ucIterationSide
81106f7c g     F .text	000000a8 vRmapCh2HandleIrq
8113a9a4 g     F .text	00000250 OSFlagDel
811536a8 g     O .bss	00000004 OSEventFreeList
8110ab84 g     F .text	000000c0 bSetPreEmphasys
8110f428 g     F .text	000001c4 vQCmdFEEinConfig
81100020 g       .exceptions	00000000 alt_irq_entry
8112c8d4 g     F .text	0000004c __ascii_mbtowc
8110d10c g     F .text	00000078 bSyncCtrExtnIrq
81106818 g     F .text	00000068 bFeebGetCh2LeftBufferEmpty
8112d728 g     F .text	00000064 __ulp
8111e090 g     F .text	0000010c vNFeeControlInit
8111636c g     F .text	000000a4 vSwapMemmory
8113ae78 g     F .text	000005c0 OSFlagPend
811534e6 g     O .rwdata	00000002 OSTmrEn
8112b794 g     F .text	00000018 __fp_unlock_all
81163d10 g     O .bss	00000010 xDma
81121658 g     F .text	00000064 fputc
81110804 g     F .text	00000058 bEnableRmapIRQ
81118c24 g     F .text	000002f8 bSendUART32v2
81114ae8 g     F .text	0000019c setPreAckReceiverFreePos
8110d0cc g     F .text	00000040 bSyncErrInj
81153454 g     O .rwdata	00000008 alt_fs_list
81163d20 g     O .bss	00001000 vSimMebTask_stk
8111d048 g     F .text	00000068 vCoudlNotCreateMebTask
81143410 g     F .text	00000274 check_file_name_for_FAT16_compliance
81164d20 g     O .bss	00001000 vFeeTask3_stk
811411c0 g     F .text	00000140 OSTmrNameGet
81153970 g     O .bss	00000400 xSZData
8110f7e8 g     F .text	00000230 vQCmdFEEinFullPattern
81139dbc g     F .text	0000007c OS_StrCopy
811536e8 g     O .bss	00000004 buffer_memory
8111c220 g     F .text	00000068 vFailGetxMutexPreParsedParserRxTask
8111e360 g     F .text	00000098 vLogWriteNUC
811534b0 g     O .rwdata	00000002 OSMemNameSize
81103b30 g     F .text	000000b0 bSdmaInitM1Dma
8110d75c g     F .text	00000074 bSyncIrqEnableBlank
8114b004 g     F .text	00000028 OSInitHookEnd
8111dac0 g     F .text	00000340 vUpdateMemMapFEE
8111c490 g     F .text	00000068 vFailSetPreAckReceiverBuffer
81105ad0 g     F .text	00000058 bFeebCh8IrqFlagBufferEmpty
811534dc g     O .rwdata	00000002 OSTCBPrioTblMax
8112c6cc g     F .text	0000000c localeconv
8111cfe0 g     F .text	00000068 vCoudlNotCreateDataControllerTask
811535dc g     O .bss	00000004 xTimerRetransmission
811145e0 g     F .text	00000250 vReceiverUartTask
81153638 g     O .bss	00000004 alt_log_sys_clk_count
811534d8 g     O .rwdata	00000002 OSTaskStatStkChkEn
81137214 g     F .text	00000140 alt_log_write
81165d20 g     O .bss	00001000 vFeeTask2_stk
811535e0 g     O .bss	00000004 xMutexBuffer128
81105338 g     F .text	00000040 vFeebCh1HandleIrq
8111ee9c g     F .text	0000003c bStartSync
811055c8 g     F .text	00000040 vFeebCh7HandleIrq
8111eed8 g     F .text	00000030 bStopSync
8115351c g     O .bss	00000004 ECommBufferSide
8114a5dc g     F .text	00000058 alt_ic_isr_register
811534ac g     O .rwdata	00000002 OSMemEn
81107024 g     F .text	00000040 vRmapCh3HandleIrq
81153428 g     O .rwdata	00000004 alt_stack_limit_value
81115ccc g     F .text	00000388 vPusType252run
8111d5a8 g     F .text	0000004c vFailSendMsgMasterSyncMeb
81121c7c g     F .text	0000003c fwrite
811536ec g     O .bss	00000004 fat_partition_offset_in_512_byte_sectors
811534b6 g     O .rwdata	00000002 OSMutexEn
8111d348 g     F .text	00000068 vCouldNotGetQueueMaskDataCtrl
81153504 g       *ABS*	00000000 _edata
8114745c g     F .text	00000068 altera_avalon_uart_read_fd
8111e210 g     F .text	00000034 vLoadDefaultIdNFEEMaster
81105220 g     F .text	0000008c usiAdcPxDelayCalcPeriodNs
8116d778 g       *ABS*	00000000 _end
8116d178 g     O .bss	00000500 active_files
811536ac g     O .bss	00000001 OSIntNesting
8111bdb0 g     F .text	0000004c vFailInitialization
811014c8 g     F .text	000000bc bDdr2SwitchMemory
8111df8c g     F .text	0000002c cFeeRMAPDump
81105cd0 g     F .text	000000d4 bFeebCh3SetBufferSize
811535e4 g     O .bss	00000004 xSemCountBuffer32
81132fdc g     F .text	0000016c __fputwc
811535e8 g     O .bss	00000004 xQMaskFeeCtrl
8111dedc g     F .text	0000002c vFeeSpwRMAPChangeConfig
81129444 g     F .text	00000070 vfscanf
81144d44 g     F .text	00000150 copy_file_record_name_to_string
81146ccc g     F .text	000000f8 altera_avalon_jtag_uart_ioctl
81140c14 g     F .text	000001dc OSTimeDlyResume
81143250 g     F .text	000000f4 Look_for_FAT16
8111085c g     F .text	00000060 bDisableSPWChannel
8113ad24 g     F .text	00000154 OSFlagNameSet
811109b4 g     F .text	0000006c bDisAndClrDbBuffer
811535ec g     O .bss	00000004 xMutexBuffer64
81107efc g     F .text	00000160 bRmapGetCodecError
8114044c g     F .text	000001c8 OSTaskStkChk
8114a6c4 g     F .text	00000094 alt_ic_irq_disable
81103c90 g     F .text	00000534 bSdmaDmaM1Transfer
811534b2 g     O .rwdata	00000002 OSMemSize
8111587c g     F .text	00000204 vPusType252conf
8111bee0 g     F .text	00000068 vFailSetCountSemaphorexBuffer32
81123048 g     F .text	00000084 __swrite
81153444 g     O .rwdata	00000004 __malloc_trim_threshold
8112c694 g     F .text	0000000c __locale_msgcharset
81166d20 g     O .bss	00000020 xFeeQueueTBL1
811536b0 g     O .bss	00000004 OSTCBCur
8111c860 g     F .text	00000068 vCouldNotRetransmitB64TimeoutTask
8110be98 g     F .text	00000044 iMsgdmaExtendedDescriptorSyncTransfer
8114b124 g     F .text	00000040 exit
8113d0b0 g     F .text	00000220 OSMutexPost
8110d8b8 g     F .text	00000058 bSyncIrqFlagError
81145170 g     F .text	000003c0 alt_up_sd_card_find_next
811534b4 g     O .rwdata	00000002 OSMemTblSize
8112c49c g     F .text	000000cc _fwalk_reent
811497f0 g     F .text	000000a0 alt_msgdma_prefetcher_set_std_list_own_by_hw_bits
8111fdec g     F .text	000000f8 .hidden __floatunsisf
8112d524 g     F .text	00000204 __mdiff
8111cd08 g     F .text	00000068 vCoudlNotCreateNFee0Task
811061c8 g     F .text	0000017c vFeebInitIrq
811049e0 g     F .text	0000022c bDpktSetPacketConfig
8111be48 g     F .text	0000004c vFailSenderCreate
81134ba4 g     F .text	00000074 .hidden __modsi3
8111cf10 g     F .text	00000068 vCoudlNotCreateNFee5Task
8110d018 g     F .text	0000003c uliSyncGetPer
811070e4 g     F .text	00000040 vRmapCh6HandleIrq
811535f0 g     O .bss	00000004 xMutexSenderACK
8111c6c0 g     F .text	00000068 vFailGetBlockingSemTimeoutTask
81153434 g     O .rwdata	00000004 __ctype_ptr__
8111c428 g     F .text	00000068 vFailSetPreParsedBuffer
81142280 g     F .text	000000e0 Read_Sector_Data
811fa000 g       *ABS*	00000000 __alt_data_end
81100020 g     F .exceptions	00000000 alt_exception
8112b770 g     F .text	00000004 __sfp_lock_release
81106418 g     F .text	000000ac bFeebGetIrqControl
8111c998 g     F .text	00000068 vCouldNotSendTurnOff
81138ad4 g     F .text	00000064 OSInit
8110b4bc g     F .text	00000078 bSetPainelLeds
81148f38 g     F .text	000000b0 alt_msgdma_construct_extended_mm_to_mm_descriptor
811536b4 g     O .bss	00000004 OSTmrTime
81101b00 g     F .text	0000050c bDdr2MemoryReadTest
8110805c g     F .text	000002ec bRmapSetMemConfigArea
81140800 g     F .text	0000012c OSTaskQuery
8110d6e8 g     F .text	00000074 bSyncIrqEnableError
811535f4 g     O .bss	00000004 xMutexPus
8113e688 g     F .text	000000b0 OS_QInit
8112e268 g     F .text	000000d0 __sccl
8112146c g     F .text	0000000c atoi
8110dbb8 g     F .text	00001688 vFeeTask
81139e38 g     F .text	0000005c OS_StrLen
8111d770 g     F .text	0000004c vFailFlushNFEEQueue
811058c0 g     F .text	00000058 bFeebCh2IrqFlagBufferEmpty
8111b77c g     F .text	000000e0 vDataControllerInit
8113c0cc g     F .text	0000011c OSMemNameSet
81150a50 g     O .rodata	00000101 _ctype_
8110cfdc g     F .text	0000003c uliSyncGetBt
84000000 g       *ABS*	00000000 __alt_mem_ext_flash
8111bfb0 g     F .text	00000068 vFailSetCountSemaphorexBuffer128
811534ce g     O .rwdata	00000002 OSTaskProfileEn
8111d7bc g     F .text	00000028 vEvtChangeMebMode
81148e08 g     F .text	00000098 alt_msgdma_construct_extended_st_to_mm_descriptor
811535f8 g     O .bss	00000004 xTxUARTMutex
811536b8 g     O .bss	00000004 OSTime
8115344c g     O .rwdata	00000004 __mbtowc
81147a7c g     F .text	0000005c altera_avalon_uart_close
8110f240 g     F .text	000001e8 vQCmdFEEinWaitingSync
811536bc g     O .bss	00000004 OSTmrSem
81115828 g     F .text	00000054 vPusType251conf
8116a1ac g     O .bss	00001000 OSTaskIdleStk
8112149c g     F .text	000000fc _fopen_r
81153594 g     O .bss	00000004 pdata
8114b454 g     F .text	000000bc _exit
81106658 g     F .text	00000078 bFeebGetLeftBufferEmpty
8114a12c g     F .text	00000134 alt_alarm_start
8113abf4 g     F .text	00000130 OSFlagNameGet
81140df0 g     F .text	00000064 OSTimeGet
81153520 g     O .bss	00000004 ESdmaChBufferId
811459d4 g     F .text	00000380 alt_up_sd_card_read
811072b4 g     F .text	00000044 vRmapCh5IrqFlagClrWriteCmd
81121cb8 g     F .text	000001c4 __smakebuf_r
811535fc g     O .bss	00000001 SemCount64
8111892c g     F .text	000002f8 bSendUART64v2
8111d6d8 g     F .text	0000004c vFailFlushQueueData
81105970 g     F .text	00000058 bFeebCh4IrqFlagBufferEmpty
811534fc g     O .rwdata	00000008 alt_msgdma_list
81123184 g     F .text	00000098 strlen
8110c6d4 g     F .text	000000b4 uc_spi_get_byte
811072f8 g     F .text	00000044 vRmapCh6IrqFlagClrWriteCmd
8111d3b0 g     F .text	00000054 vFailSendMsgAccessDMA
8114af34 g     F .text	00000028 OSTaskSwHook
81137754 g     F .text	0000015c open
811096fc g     F .text	000007cc bRmapGetRmapMemHKArea
8116b1ac g     O .bss	00000d00 OSEventTbl
8111df08 g     F .text	0000002c vFeeSpwRMAPChangeDefault
8111fee4 g     F .text	000000dc .hidden __gedf2
8111d554 g     F .text	00000054 vFailSendMsgSyncRMAPTRIGGER
81166d40 g     O .bss	00000020 xSenderACK
8114ac28 g     F .text	00000044 alt_putchar
81121484 g     F .text	0000000c atoll
8116beac g     O .bss	000011b8 OSTCBTbl
811332f4 g     F .text	00000838 __gethex
8113f0d0 g     F .text	00000108 OSSemSet
81116c90 g     F .text	0000006c vTimeoutCheckerTaskv2
8111dfb8 g     F .text	00000038 cFeeRMAPEchoingEnable
81153450 g     O .rwdata	00000004 __wctomb
81117ac8 g     F .text	00000314 vVariablesInitialization
811318a8 g     F .text	00000018 __sprint_r
8110ff30 g     F .text	0000045c vQCmdFeeRMAPinFullPattern
811064c4 g     F .text	00000088 bFeebGetIrqFlags
81153510 g     O .bss	00000004 pxDmaM2Dev
8111b978 g     F .text	0000004c vFailCreateSemaphoreResources
8115346c g     O .rwdata	00000004 alt_priority_mask
8110ab48 g     F .text	0000003c bDisableLvdsBoard
8113e8d0 g     F .text	00000248 OSSemDel
81105bfc g     F .text	000000d4 bFeebCh2SetBufferSize
811536c0 g     O .bss	00000004 OSFlagFreeList
8110c610 g     F .text	000000c4 v_spi_send_byte
8110c944 g     F .text	000000d0 bSSDisplayConfig
8114a634 g     F .text	00000090 alt_ic_irq_enable
81153494 g     O .rwdata	00000002 OSEventNameSize
81127ba0 g     F .text	0000001c __vfprintf_internal
811536c4 g     O .bss	00000001 OSStatRdy
8110d3bc g     F .text	00000074 bSyncCtrCh2OutEnable
8116d064 g     O .bss	000000ac OSTCBPrioTbl
81147b1c g     F .text	00000270 altera_avalon_uart_read
81133ffc g     F .text	00000064 _wctomb_r
81137fa0 g     F .text	000000cc __env_lock
811534da g     O .rwdata	00000002 OSTaskSwHookEn
81153e88 g     O .bss	00000100 cTemp
811056d0 g     F .text	00000044 vFeebCh3IrqFlagClrBufferEmpty
811206e0 g     F .text	00000904 .hidden __subdf3
81166d60 g     O .bss	00000260 xPreParsed
8110d054 g     F .text	0000003c uliSyncGetOst
811535fd g     O .bss	00000001 SemCount128
81107164 g     F .text	00000040 vRmapCh8HandleIrq
8110579c g     F .text	00000044 vFeebCh6IrqFlagClrBufferEmpty
81118f1c g     F .text	00000290 vSendEthConf
8110486c g     F .text	000000d0 bCommInitCh
8112cf38 g     F .text	000000b0 __lo0bits
81127c80 g     F .text	000017c4 __svfscanf_r
81153478 g     O .rwdata	00000008 alt_alarm_list
811315f0 g     F .text	0000019c _ungetc_r
811534a2 g     O .rwdata	00000002 OSFlagWidth
811071a4 g     F .text	00000044 vRmapCh1IrqFlagClrWriteCmd
81102a40 g     F .text	0000004c DMA_BUSY
81133f04 g     F .text	000000c8 wcrtomb
81104dfc g     F .text	00000148 bDpktSetPixelDelay
81118460 g     F .text	0000014c vCCDLoadDefaultValues
81136414 g     F .text	000000d8 close
8110d090 g     F .text	0000003c uliSyncGetGeneral
8111d80c g     F .text	00000028 vEvtChangeDataControllerMode
81153654 g     O .bss	00000004 alt_envsem
81136944 g     F .text	00000068 alt_log_repchar
811536c8 g     O .bss	00000004 OSIdleCtrRun
8113915c g     F .text	00000028 OSVersion
811534ec g     O .rwdata	00000002 OSTmrCfgWheelSize
8114092c g     F .text	00000078 OS_TaskStkClr
8111eb24 g     F .text	0000003c siOpenFile
8110db18 g     F .text	000000a0 vDataControlTask
811534c6 g     O .rwdata	00000002 OSTaskCreateEn
8110741c g     F .text	00000058 bRmapCh2IrqFlagWriteCmd
81107864 g     F .text	00000050 uliRmapCh7WriteCmdAddress
81106af8 g     F .text	00000088 bFeebStartCh
811191ac g     F .text	00000118 vSendTurnOff
8111ba78 g     F .text	0000004c vFailSendPreParsedSemaphore
81143744 g     F .text	000002a4 match_file_record_to_name_ext
81139784 g     F .text	00000070 OS_EventWaitListInit
8113316c g     F .text	00000088 fputwc
81166fc0 g     O .bss	00000020 xFeeQueueTBL0
8111ba10 g     F .text	00000068 vFailSendxSemCommInit
8114b02c g     F .text	00000028 OSTaskIdleHook
811192c4 g     F .text	00000118 vSendReset
8112b774 g     F .text	00000004 __sinit_lock_acquire
8112cc9c g     F .text	00000128 __multadd
81166fe0 g     O .bss	00000020 SyncTBL1
811057e0 g     F .text	00000044 vFeebCh7IrqFlagClrBufferEmpty
8110cce0 g     F .text	0000004c ucSyncStatusState
81140614 g     F .text	000001ec OSTaskSuspend
8112cc74 g     F .text	00000028 _Bfree
8110cfa0 g     F .text	0000003c uliSyncGetMbt
81139e94 g     F .text	00000064 OS_TaskIdle
811534f2 g     O .rwdata	00000002 OSTmrTblSize
8113e524 g     F .text	00000164 OSQQuery



Disassembly of section .exceptions:

81100020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
81100020:	deffed04 	addi	sp,sp,-76

#ifdef ALT_STACK_CHECK
        /* Ensure stack didn't just overflow. */
        bltu  sp, et, .Lstack_overflow
81100024:	de003636 	bltu	sp,et,81100100 <alt_exception+0xe0>
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
81100028:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
8110002c:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
81100030:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
81100034:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
81100038:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
8110003c:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
81100040:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
81100044:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
81100048:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
8110004c:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
81100050:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
81100054:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
81100058:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
8110005c:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
81100060:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
81100064:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
81100068:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
8110006c:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
81100070:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
81100074:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
81100078:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
8110007c:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
81100080:	10000326 	beq	r2,zero,81100090 <alt_exception+0x70>
        beq   r4, zero, .Lnot_irq
81100084:	20000226 	beq	r4,zero,81100090 <alt_exception+0x70>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
81100088:	11001040 	call	81100104 <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
8110008c:	00000706 	br	811000ac <alt_exception+0x8c>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
81100090:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
81100094:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
81100098:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
8110009c:	11001e00 	call	811001e0 <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
811000a0:	1000021e 	bne	r2,zero,811000ac <alt_exception+0x8c>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
811000a4:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
811000a8:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
811000ac:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
811000b0:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
811000b4:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
811000b8:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
811000bc:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
811000c0:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
811000c4:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
811000c8:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
811000cc:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
811000d0:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
811000d4:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
811000d8:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
811000dc:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
811000e0:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
811000e4:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
811000e8:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
811000ec:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
811000f0:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
811000f4:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
811000f8:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
811000fc:	ef80083a 	eret

#ifdef ALT_STACK_CHECK
.Lstack_overflow:
        break 3
81100100:	003da0fa 	break	3

81100104 <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
81100104:	defff904 	addi	sp,sp,-28
81100108:	de00012e 	bgeu	sp,et,81100110 <alt_irq_handler+0xc>
8110010c:	003b68fa 	trap	3
81100110:	dfc00615 	stw	ra,24(sp)
81100114:	df000515 	stw	fp,20(sp)
81100118:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
8110011c:	1138b380 	call	81138b38 <OSIntEnter>
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
81100120:	0005313a 	rdctl	r2,ipending
81100124:	e0bffe15 	stw	r2,-8(fp)

  return active;
81100128:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
8110012c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
81100130:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
81100134:	00800044 	movi	r2,1
81100138:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
8110013c:	e0fffb17 	ldw	r3,-20(fp)
81100140:	e0bffc17 	ldw	r2,-16(fp)
81100144:	1884703a 	and	r2,r3,r2
81100148:	10001426 	beq	r2,zero,8110019c <alt_irq_handler+0x98>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
8110014c:	00a045f4 	movhi	r2,33047
81100150:	10b59e04 	addi	r2,r2,-10632
81100154:	e0fffd17 	ldw	r3,-12(fp)
81100158:	180690fa 	slli	r3,r3,3
8110015c:	10c5883a 	add	r2,r2,r3
81100160:	10c00017 	ldw	r3,0(r2)
81100164:	00a045f4 	movhi	r2,33047
81100168:	10b59e04 	addi	r2,r2,-10632
8110016c:	e13ffd17 	ldw	r4,-12(fp)
81100170:	200890fa 	slli	r4,r4,3
81100174:	1105883a 	add	r2,r2,r4
81100178:	10800104 	addi	r2,r2,4
8110017c:	10800017 	ldw	r2,0(r2)
81100180:	1009883a 	mov	r4,r2
81100184:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
81100188:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
8110018c:	0005313a 	rdctl	r2,ipending
81100190:	e0bfff15 	stw	r2,-4(fp)

  return active;
81100194:	e0bfff17 	ldw	r2,-4(fp)
81100198:	00000706 	br	811001b8 <alt_irq_handler+0xb4>
      }
      mask <<= 1;
8110019c:	e0bffc17 	ldw	r2,-16(fp)
811001a0:	1085883a 	add	r2,r2,r2
811001a4:	e0bffc15 	stw	r2,-16(fp)
      i++;
811001a8:	e0bffd17 	ldw	r2,-12(fp)
811001ac:	10800044 	addi	r2,r2,1
811001b0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
811001b4:	003fe106 	br	8110013c <__reset+0xfb0e013c>

    active = alt_irq_pending ();
811001b8:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
811001bc:	e0bffb17 	ldw	r2,-20(fp)
811001c0:	103fdb1e 	bne	r2,zero,81100130 <__reset+0xfb0e0130>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
811001c4:	1138b8c0 	call	81138b8c <OSIntExit>
}
811001c8:	0001883a 	nop
811001cc:	e037883a 	mov	sp,fp
811001d0:	dfc00117 	ldw	ra,4(sp)
811001d4:	df000017 	ldw	fp,0(sp)
811001d8:	dec00204 	addi	sp,sp,8
811001dc:	f800283a 	ret

811001e0 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
811001e0:	defffb04 	addi	sp,sp,-20
811001e4:	de00012e 	bgeu	sp,et,811001ec <alt_instruction_exception_entry+0xc>
811001e8:	003b68fa 	trap	3
811001ec:	dfc00415 	stw	ra,16(sp)
811001f0:	df000315 	stw	fp,12(sp)
811001f4:	df000304 	addi	fp,sp,12
811001f8:	e13fff15 	stw	r4,-4(fp)
 * NIOS2_EXCEPTION_CAUSE_NOT_PRESENT. Your handling routine should
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
811001fc:	000531fa 	rdctl	r2,exception
81100200:	e0bffd15 	stw	r2,-12(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
81100204:	e0bffd17 	ldw	r2,-12(fp)
81100208:	10801f0c 	andi	r2,r2,124
8110020c:	1004d0ba 	srli	r2,r2,2
81100210:	e0bffd15 	stw	r2,-12(fp)
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
81100214:	0005333a 	rdctl	r2,badaddr
81100218:	e0bffe15 	stw	r2,-8(fp)
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
8110021c:	d0a0b717 	ldw	r2,-32036(gp)
81100220:	10000726 	beq	r2,zero,81100240 <alt_instruction_exception_entry+0x60>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
81100224:	d0a0b717 	ldw	r2,-32036(gp)
81100228:	e0fffd17 	ldw	r3,-12(fp)
8110022c:	e1bffe17 	ldw	r6,-8(fp)
81100230:	e17fff17 	ldw	r5,-4(fp)
81100234:	1809883a 	mov	r4,r3
81100238:	103ee83a 	callr	r2
8110023c:	00000206 	br	81100248 <alt_instruction_exception_entry+0x68>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
81100240:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
81100244:	0005883a 	mov	r2,zero
}
81100248:	e037883a 	mov	sp,fp
8110024c:	dfc00117 	ldw	ra,4(sp)
81100250:	df000017 	ldw	fp,0(sp)
81100254:	dec00204 	addi	sp,sp,8
81100258:	f800283a 	ret

Disassembly of section .text:

8110025c <_start>:
    .int 2, 1, 0b, 1b
    .popsection
#endif /* Initialize Data Cache */

    /* Log that caches have been initialized. */
    ALT_LOG_PUTS(alt_log_msg_cache)
8110025c:	01204574 	movhi	r4,33045
81100260:	210d1c04 	addi	r4,r4,13424
81100264:	21400037 	ldwio	r5,0(r4)
81100268:	01400326 	beq	zero,r5,81100278 <_start+0x1c>
8110026c:	01204574 	movhi	r4,33045
81100270:	21087304 	addi	r4,r4,8652
81100274:	11368bc0 	call	811368bc <tx_log_str>

    /* Log that the stack pointer is about to be setup. */
    ALT_LOG_PUTS(alt_log_msg_stackpointer)
81100278:	01204574 	movhi	r4,33045
8110027c:	210d1c04 	addi	r4,r4,13424
81100280:	21400037 	ldwio	r5,0(r4)
81100284:	01400326 	beq	zero,r5,81100294 <_start+0x38>
81100288:	01204574 	movhi	r4,33045
8110028c:	21086604 	addi	r4,r4,8600
81100290:	11368bc0 	call	811368bc <tx_log_str>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
81100294:	06e047f4 	movhi	sp,33055
    ori sp, sp, %lo(__alt_stack_pointer)
81100298:	dee80014 	ori	sp,sp,40960
    movhi gp, %hi(_gp)
8110029c:	06a04574 	movhi	gp,33045
    ori gp, gp, %lo(_gp)
811002a0:	d6ad0a14 	ori	gp,gp,46120
 * by the linker script. They mark the begining and the end of the bss
 * region. The linker script guarantees that these values are word aligned.
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)
811002a4:	01204574 	movhi	r4,33045
811002a8:	210d1c04 	addi	r4,r4,13424
811002ac:	21400037 	ldwio	r5,0(r4)
811002b0:	01400326 	beq	zero,r5,811002c0 <_start+0x64>
811002b4:	01204574 	movhi	r4,33045
811002b8:	21085704 	addi	r4,r4,8540
811002bc:	11368bc0 	call	811368bc <tx_log_str>

    movhi r2, %hi(__bss_start)
811002c0:	00a04574 	movhi	r2,33045
    ori r2, r2, %lo(__bss_start)
811002c4:	108d4114 	ori	r2,r2,13572

    movhi r3, %hi(__bss_end)
811002c8:	00e045b4 	movhi	r3,33046
    ori r3, r3, %lo(__bss_end)
811002cc:	18f5de14 	ori	r3,r3,55160

    beq r2, r3, 1f
811002d0:	10c00326 	beq	r2,r3,811002e0 <_start+0x84>

0:
    stw zero, (r2)
811002d4:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
811002d8:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
811002dc:	10fffd36 	bltu	r2,r3,811002d4 <__reset+0xfb0e02d4>
    /*
     * Set up the stack limit (if required).  The linker has set up the
     * copy of the variable which is in memory.
     */

    ldw   et, %gprel(alt_stack_limit_value)(gp)
811002e0:	d6200017 	ldw	et,-32768(gp)
#endif

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)
811002e4:	01204574 	movhi	r4,33045
811002e8:	210d1c04 	addi	r4,r4,13424
811002ec:	21400037 	ldwio	r5,0(r4)
811002f0:	01400326 	beq	zero,r5,81100300 <_start+0xa4>
811002f4:	01204574 	movhi	r4,33045
811002f8:	21085e04 	addi	r4,r4,8568
811002fc:	11368bc0 	call	811368bc <tx_log_str>

    /* Call the C entry point. It should never return. */
    call alt_main
81100300:	11374e80 	call	811374e8 <alt_main>

81100304 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
81100304:	003fff06 	br	81100304 <__reset+0xfb0e0304>

81100308 <bDdr2EepromTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2EepromTest(alt_u8 ucMemoryId) {
81100308:	defff604 	addi	sp,sp,-40
8110030c:	de00012e 	bgeu	sp,et,81100314 <bDdr2EepromTest+0xc>
81100310:	003b68fa 	trap	3
81100314:	dfc00915 	stw	ra,36(sp)
81100318:	df000815 	stw	fp,32(sp)
8110031c:	df000804 	addi	fp,sp,32
81100320:	2005883a 	mov	r2,r4
81100324:	e0bfff05 	stb	r2,-4(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 EEPROM Test =====\n");
81100328:	00e04574 	movhi	r3,33045
8110032c:	18ce1c04 	addi	r3,r3,14448
81100330:	00a04574 	movhi	r2,33045
81100334:	10ad4404 	addi	r2,r2,-19184
81100338:	1009883a 	mov	r4,r2
8110033c:	00800884 	movi	r2,34
81100340:	100d883a 	mov	r6,r2
81100344:	200b883a 	mov	r5,r4
81100348:	1809883a 	mov	r4,r3
8110034c:	11226900 	call	81122690 <memcpy>
	debug(fp, cDebugBuffer);
81100350:	d0a06217 	ldw	r2,-32376(gp)
81100354:	01604574 	movhi	r5,33045
81100358:	294e1c04 	addi	r5,r5,14448
8110035c:	1009883a 	mov	r4,r2
81100360:	11215e00 	call	811215e0 <fprintf>
#endif
	const alt_u8 cucDeviceAddr = DDR2_EEPROM_I2C_ADDRESS;
81100364:	00bfe804 	movi	r2,-96
81100368:	e0bffd05 	stb	r2,-12(fp)
	bool bSuccess;
	alt_u32 uliI2cSclBase;
	alt_u32 uliI2cSdaBase;
	int iI;

	bSuccess = TRUE;
8110036c:	00800044 	movi	r2,1
81100370:	e0bff915 	stw	r2,-28(fp)
	switch (ucMemoryId) {
81100374:	e0bfff03 	ldbu	r2,-4(fp)
81100378:	10000326 	beq	r2,zero,81100388 <bDdr2EepromTest+0x80>
8110037c:	10800060 	cmpeqi	r2,r2,1
81100380:	1000081e 	bne	r2,zero,811003a4 <bDdr2EepromTest+0x9c>
81100384:	00000e06 	br	811003c0 <bDdr2EepromTest+0xb8>
	case DDR2_M1_ID:
		uliI2cSclBase = DDR2_M1_EEPROM_I2C_SCL_BASE;
81100388:	00a00034 	movhi	r2,32768
8110038c:	10827c04 	addi	r2,r2,2544
81100390:	e0bffa15 	stw	r2,-24(fp)
		uliI2cSdaBase = DDR2_M1_EEPROM_I2C_SDA_BASE;
81100394:	00a00034 	movhi	r2,32768
81100398:	10828004 	addi	r2,r2,2560
8110039c:	e0bffb15 	stw	r2,-20(fp)
		break;
811003a0:	00001906 	br	81100408 <bDdr2EepromTest+0x100>
	case DDR2_M2_ID:
		uliI2cSclBase = DDR2_M2_EEPROM_I2C_SCL_BASE;
811003a4:	00a00034 	movhi	r2,32768
811003a8:	10825804 	addi	r2,r2,2400
811003ac:	e0bffa15 	stw	r2,-24(fp)
		uliI2cSdaBase = DDR2_M2_EEPROM_I2C_SDA_BASE;
811003b0:	00a00034 	movhi	r2,32768
811003b4:	10825c04 	addi	r2,r2,2416
811003b8:	e0bffb15 	stw	r2,-20(fp)
		break;
811003bc:	00001206 	br	81100408 <bDdr2EepromTest+0x100>
	default:
		bSuccess = FALSE;
811003c0:	e03ff915 	stw	zero,-28(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811003c4:	00e04574 	movhi	r3,33045
811003c8:	18ce1c04 	addi	r3,r3,14448
811003cc:	00a04574 	movhi	r2,33045
811003d0:	10ad4d04 	addi	r2,r2,-19148
811003d4:	1009883a 	mov	r4,r2
811003d8:	00800bc4 	movi	r2,47
811003dc:	100d883a 	mov	r6,r2
811003e0:	200b883a 	mov	r5,r4
811003e4:	1809883a 	mov	r4,r3
811003e8:	11226900 	call	81122690 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
811003ec:	d0a06217 	ldw	r2,-32376(gp)
811003f0:	01604574 	movhi	r5,33045
811003f4:	294e1c04 	addi	r5,r5,14448
811003f8:	1009883a 	mov	r4,r2
811003fc:	11215e00 	call	811215e0 <fprintf>
		;
#endif
		return bSuccess;
81100400:	e0bff917 	ldw	r2,-28(fp)
81100404:	0000ff06 	br	81100804 <bDdr2EepromTest+0x4fc>
	}

	alt_u8 ucControlAddr, ucValue;
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Read Test\n");
81100408:	00e04574 	movhi	r3,33045
8110040c:	18ce1c04 	addi	r3,r3,14448
81100410:	00a04574 	movhi	r2,33045
81100414:	10ad5904 	addi	r2,r2,-19100
81100418:	1009883a 	mov	r4,r2
8110041c:	008005c4 	movi	r2,23
81100420:	100d883a 	mov	r6,r2
81100424:	200b883a 	mov	r5,r4
81100428:	1809883a 	mov	r4,r3
8110042c:	11226900 	call	81122690 <memcpy>
	debug(fp, cDebugBuffer);
81100430:	d0a06217 	ldw	r2,-32376(gp)
81100434:	01604574 	movhi	r5,33045
81100438:	294e1c04 	addi	r5,r5,14448
8110043c:	1009883a 	mov	r4,r2
81100440:	11215e00 	call	811215e0 <fprintf>
#endif
	usleep(20 * 1000);
81100444:	01138804 	movi	r4,20000
81100448:	1137d140 	call	81137d14 <usleep>
	for (iI = 0; iI < 256 && bSuccess; iI++) {
8110044c:	e03ffc15 	stw	zero,-16(fp)
81100450:	00003306 	br	81100520 <bDdr2EepromTest+0x218>
		ucControlAddr = iI;
81100454:	e0bffc17 	ldw	r2,-16(fp)
81100458:	e0bffd45 	stb	r2,-11(fp)
		bSuccess = I2C_Read(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
8110045c:	e0bffd03 	ldbu	r2,-12(fp)
81100460:	10c03fcc 	andi	r3,r2,255
81100464:	18c0201c 	xori	r3,r3,128
81100468:	18ffe004 	addi	r3,r3,-128
8110046c:	e13ffd43 	ldbu	r4,-11(fp)
81100470:	e0bffe04 	addi	r2,fp,-8
81100474:	d8800015 	stw	r2,0(sp)
81100478:	200f883a 	mov	r7,r4
8110047c:	180d883a 	mov	r6,r3
81100480:	e17ffb17 	ldw	r5,-20(fp)
81100484:	e13ffa17 	ldw	r4,-24(fp)
81100488:	110ae280 	call	8110ae28 <I2C_Read>
8110048c:	e0bff915 	stw	r2,-28(fp)
				ucControlAddr, &ucValue);
		if (bSuccess) {
81100490:	e0bff917 	ldw	r2,-28(fp)
81100494:	10001026 	beq	r2,zero,811004d8 <bDdr2EepromTest+0x1d0>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "EEPROM[%03d]=%02Xh\n", ucControlAddr,
81100498:	e0bffd43 	ldbu	r2,-11(fp)
8110049c:	e0fffe03 	ldbu	r3,-8(fp)
811004a0:	18c03fcc 	andi	r3,r3,255
811004a4:	180f883a 	mov	r7,r3
811004a8:	100d883a 	mov	r6,r2
811004ac:	01604574 	movhi	r5,33045
811004b0:	296d5f04 	addi	r5,r5,-19076
811004b4:	01204574 	movhi	r4,33045
811004b8:	210e1c04 	addi	r4,r4,14448
811004bc:	1122f700 	call	81122f70 <sprintf>
					ucValue);
			debug(fp, cDebugBuffer);
811004c0:	d0a06217 	ldw	r2,-32376(gp)
811004c4:	01604574 	movhi	r5,33045
811004c8:	294e1c04 	addi	r5,r5,14448
811004cc:	1009883a 	mov	r4,r2
811004d0:	11215e00 	call	811215e0 <fprintf>
811004d4:	00000f06 	br	81100514 <bDdr2EepromTest+0x20c>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "Failed to read EEPROM\n");
811004d8:	00e04574 	movhi	r3,33045
811004dc:	18ce1c04 	addi	r3,r3,14448
811004e0:	00a04574 	movhi	r2,33045
811004e4:	10ad6404 	addi	r2,r2,-19056
811004e8:	1009883a 	mov	r4,r2
811004ec:	008005c4 	movi	r2,23
811004f0:	100d883a 	mov	r6,r2
811004f4:	200b883a 	mov	r5,r4
811004f8:	1809883a 	mov	r4,r3
811004fc:	11226900 	call	81122690 <memcpy>
			debug(fp, cDebugBuffer);
81100500:	d0a06217 	ldw	r2,-32376(gp)
81100504:	01604574 	movhi	r5,33045
81100508:	294e1c04 	addi	r5,r5,14448
8110050c:	1009883a 	mov	r4,r2
81100510:	11215e00 	call	811215e0 <fprintf>
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Read Test\n");
	debug(fp, cDebugBuffer);
#endif
	usleep(20 * 1000);
	for (iI = 0; iI < 256 && bSuccess; iI++) {
81100514:	e0bffc17 	ldw	r2,-16(fp)
81100518:	10800044 	addi	r2,r2,1
8110051c:	e0bffc15 	stw	r2,-16(fp)
81100520:	e0bffc17 	ldw	r2,-16(fp)
81100524:	10804008 	cmpgei	r2,r2,256
81100528:	1000021e 	bne	r2,zero,81100534 <bDdr2EepromTest+0x22c>
8110052c:	e0bff917 	ldw	r2,-28(fp)
81100530:	103fc81e 	bne	r2,zero,81100454 <__reset+0xfb0e0454>
			sprintf(cDebugBuffer, "Failed to read EEPROM\n");
			debug(fp, cDebugBuffer);
#endif
		}
	}
	if (bSuccess) {
81100534:	e0bff917 	ldw	r2,-28(fp)
81100538:	10001026 	beq	r2,zero,8110057c <bDdr2EepromTest+0x274>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Read Test Completed\n\n");
8110053c:	00e04574 	movhi	r3,33045
81100540:	18ce1c04 	addi	r3,r3,14448
81100544:	00a04574 	movhi	r2,33045
81100548:	10ad6a04 	addi	r2,r2,-19032
8110054c:	1009883a 	mov	r4,r2
81100550:	00800884 	movi	r2,34
81100554:	100d883a 	mov	r6,r2
81100558:	200b883a 	mov	r5,r4
8110055c:	1809883a 	mov	r4,r3
81100560:	11226900 	call	81122690 <memcpy>
		debug(fp, cDebugBuffer);
81100564:	d0a06217 	ldw	r2,-32376(gp)
81100568:	01604574 	movhi	r5,33045
8110056c:	294e1c04 	addi	r5,r5,14448
81100570:	1009883a 	mov	r4,r2
81100574:	11215e00 	call	811215e0 <fprintf>
81100578:	00000f06 	br	811005b8 <bDdr2EepromTest+0x2b0>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Read Test Failed\n\n");
8110057c:	00e04574 	movhi	r3,33045
81100580:	18ce1c04 	addi	r3,r3,14448
81100584:	00a04574 	movhi	r2,33045
81100588:	10ad7304 	addi	r2,r2,-18996
8110058c:	1009883a 	mov	r4,r2
81100590:	008007c4 	movi	r2,31
81100594:	100d883a 	mov	r6,r2
81100598:	200b883a 	mov	r5,r4
8110059c:	1809883a 	mov	r4,r3
811005a0:	11226900 	call	81122690 <memcpy>
		debug(fp, cDebugBuffer);
811005a4:	d0a06217 	ldw	r2,-32376(gp)
811005a8:	01604574 	movhi	r5,33045
811005ac:	294e1c04 	addi	r5,r5,14448
811005b0:	1009883a 	mov	r4,r2
811005b4:	11215e00 	call	811215e0 <fprintf>
#endif
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Write Test\n");
811005b8:	00e04574 	movhi	r3,33045
811005bc:	18ce1c04 	addi	r3,r3,14448
811005c0:	00a04574 	movhi	r2,33045
811005c4:	10ad7b04 	addi	r2,r2,-18964
811005c8:	1009883a 	mov	r4,r2
811005cc:	00800604 	movi	r2,24
811005d0:	100d883a 	mov	r6,r2
811005d4:	200b883a 	mov	r5,r4
811005d8:	1809883a 	mov	r4,r3
811005dc:	11226900 	call	81122690 <memcpy>
	debug(fp, cDebugBuffer);
811005e0:	d0a06217 	ldw	r2,-32376(gp)
811005e4:	01604574 	movhi	r5,33045
811005e8:	294e1c04 	addi	r5,r5,14448
811005ec:	1009883a 	mov	r4,r2
811005f0:	11215e00 	call	811215e0 <fprintf>
#endif
	alt_u8 ucWriteData = 0x12, ucTestAddr = 128;
811005f4:	00800484 	movi	r2,18
811005f8:	e0bffd85 	stb	r2,-10(fp)
811005fc:	00bfe004 	movi	r2,-128
81100600:	e0bffdc5 	stb	r2,-9(fp)
	alt_u8 ucReadData;
	usleep(20 * 1000);
81100604:	01138804 	movi	r4,20000
81100608:	1137d140 	call	81137d14 <usleep>
	bSuccess = I2C_Write(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
8110060c:	e0bffd03 	ldbu	r2,-12(fp)
81100610:	10c03fcc 	andi	r3,r2,255
81100614:	18c0201c 	xori	r3,r3,128
81100618:	18ffe004 	addi	r3,r3,-128
8110061c:	e13ffdc3 	ldbu	r4,-9(fp)
81100620:	e0bffd83 	ldbu	r2,-10(fp)
81100624:	d8800015 	stw	r2,0(sp)
81100628:	200f883a 	mov	r7,r4
8110062c:	180d883a 	mov	r6,r3
81100630:	e17ffb17 	ldw	r5,-20(fp)
81100634:	e13ffa17 	ldw	r4,-24(fp)
81100638:	110ad480 	call	8110ad48 <I2C_Write>
8110063c:	e0bff915 	stw	r2,-28(fp)
			ucTestAddr, ucWriteData);
	if (!bSuccess) {
81100640:	e0bff917 	ldw	r2,-28(fp)
81100644:	1000101e 	bne	r2,zero,81100688 <bDdr2EepromTest+0x380>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Failed to write EEPROM\n");
81100648:	00e04574 	movhi	r3,33045
8110064c:	18ce1c04 	addi	r3,r3,14448
81100650:	00a04574 	movhi	r2,33045
81100654:	10ad8104 	addi	r2,r2,-18940
81100658:	1009883a 	mov	r4,r2
8110065c:	00800604 	movi	r2,24
81100660:	100d883a 	mov	r6,r2
81100664:	200b883a 	mov	r5,r4
81100668:	1809883a 	mov	r4,r3
8110066c:	11226900 	call	81122690 <memcpy>
		debug(fp, cDebugBuffer);
81100670:	d0a06217 	ldw	r2,-32376(gp)
81100674:	01604574 	movhi	r5,33045
81100678:	294e1c04 	addi	r5,r5,14448
8110067c:	1009883a 	mov	r4,r2
81100680:	11215e00 	call	811215e0 <fprintf>
81100684:	00003306 	br	81100754 <bDdr2EepromTest+0x44c>
#endif
	} else {
		bSuccess = I2C_Read(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100688:	e0bffd03 	ldbu	r2,-12(fp)
8110068c:	10c03fcc 	andi	r3,r2,255
81100690:	18c0201c 	xori	r3,r3,128
81100694:	18ffe004 	addi	r3,r3,-128
81100698:	e13ffdc3 	ldbu	r4,-9(fp)
8110069c:	e0bffe44 	addi	r2,fp,-7
811006a0:	d8800015 	stw	r2,0(sp)
811006a4:	200f883a 	mov	r7,r4
811006a8:	180d883a 	mov	r6,r3
811006ac:	e17ffb17 	ldw	r5,-20(fp)
811006b0:	e13ffa17 	ldw	r4,-24(fp)
811006b4:	110ae280 	call	8110ae28 <I2C_Read>
811006b8:	e0bff915 	stw	r2,-28(fp)
				ucTestAddr, &ucReadData);
		if (!bSuccess) {
811006bc:	e0bff917 	ldw	r2,-28(fp)
811006c0:	1000101e 	bne	r2,zero,81100704 <bDdr2EepromTest+0x3fc>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "Failed to read EEPROM for verify\n");
811006c4:	00e04574 	movhi	r3,33045
811006c8:	18ce1c04 	addi	r3,r3,14448
811006cc:	00a04574 	movhi	r2,33045
811006d0:	10ad8704 	addi	r2,r2,-18916
811006d4:	1009883a 	mov	r4,r2
811006d8:	00800884 	movi	r2,34
811006dc:	100d883a 	mov	r6,r2
811006e0:	200b883a 	mov	r5,r4
811006e4:	1809883a 	mov	r4,r3
811006e8:	11226900 	call	81122690 <memcpy>
			debug(fp, cDebugBuffer);
811006ec:	d0a06217 	ldw	r2,-32376(gp)
811006f0:	01604574 	movhi	r5,33045
811006f4:	294e1c04 	addi	r5,r5,14448
811006f8:	1009883a 	mov	r4,r2
811006fc:	11215e00 	call	811215e0 <fprintf>
81100700:	00001406 	br	81100754 <bDdr2EepromTest+0x44c>
#endif
		} else {
			if (ucReadData != ucWriteData) {
81100704:	e0bffe43 	ldbu	r2,-7(fp)
81100708:	10c03fcc 	andi	r3,r2,255
8110070c:	e0bffd83 	ldbu	r2,-10(fp)
81100710:	18801026 	beq	r3,r2,81100754 <bDdr2EepromTest+0x44c>
				bSuccess = FALSE;
81100714:	e03ff915 	stw	zero,-28(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100718:	e0bffe43 	ldbu	r2,-7(fp)
8110071c:	10803fcc 	andi	r2,r2,255
81100720:	e0fffd83 	ldbu	r3,-10(fp)
81100724:	180f883a 	mov	r7,r3
81100728:	100d883a 	mov	r6,r2
8110072c:	01604574 	movhi	r5,33045
81100730:	296d9004 	addi	r5,r5,-18880
81100734:	01204574 	movhi	r4,33045
81100738:	210e1c04 	addi	r4,r4,14448
8110073c:	1122f700 	call	81122f70 <sprintf>
						"Verify EEPROM write fail, ReadData=%02Xh, WriteData=%02Xh\n",
						ucReadData, ucWriteData);
				debug(fp, cDebugBuffer);
81100740:	d0a06217 	ldw	r2,-32376(gp)
81100744:	01604574 	movhi	r5,33045
81100748:	294e1c04 	addi	r5,r5,14448
8110074c:	1009883a 	mov	r4,r2
81100750:	11215e00 	call	811215e0 <fprintf>
#endif
			}
		}
	}
	if (bSuccess) {
81100754:	e0bff917 	ldw	r2,-28(fp)
81100758:	10001026 	beq	r2,zero,8110079c <bDdr2EepromTest+0x494>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Write Test Completed\n\n");
8110075c:	00e04574 	movhi	r3,33045
81100760:	18ce1c04 	addi	r3,r3,14448
81100764:	00a04574 	movhi	r2,33045
81100768:	10ad9f04 	addi	r2,r2,-18820
8110076c:	1009883a 	mov	r4,r2
81100770:	008008c4 	movi	r2,35
81100774:	100d883a 	mov	r6,r2
81100778:	200b883a 	mov	r5,r4
8110077c:	1809883a 	mov	r4,r3
81100780:	11226900 	call	81122690 <memcpy>
		debug(fp, cDebugBuffer);
81100784:	d0a06217 	ldw	r2,-32376(gp)
81100788:	01604574 	movhi	r5,33045
8110078c:	294e1c04 	addi	r5,r5,14448
81100790:	1009883a 	mov	r4,r2
81100794:	11215e00 	call	811215e0 <fprintf>
81100798:	00000f06 	br	811007d8 <bDdr2EepromTest+0x4d0>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Write Test Failed\n\n");
8110079c:	00e04574 	movhi	r3,33045
811007a0:	18ce1c04 	addi	r3,r3,14448
811007a4:	00a04574 	movhi	r2,33045
811007a8:	10ada804 	addi	r2,r2,-18784
811007ac:	1009883a 	mov	r4,r2
811007b0:	00800804 	movi	r2,32
811007b4:	100d883a 	mov	r6,r2
811007b8:	200b883a 	mov	r5,r4
811007bc:	1809883a 	mov	r4,r3
811007c0:	11226900 	call	81122690 <memcpy>
		debug(fp, cDebugBuffer);
811007c4:	d0a06217 	ldw	r2,-32376(gp)
811007c8:	01604574 	movhi	r5,33045
811007cc:	294e1c04 	addi	r5,r5,14448
811007d0:	1009883a 	mov	r4,r2
811007d4:	11215e00 	call	811215e0 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811007d8:	00a04574 	movhi	r2,33045
811007dc:	108e1c04 	addi	r2,r2,14448
811007e0:	00c00284 	movi	r3,10
811007e4:	10c00005 	stb	r3,0(r2)
811007e8:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811007ec:	d0a06217 	ldw	r2,-32376(gp)
811007f0:	01604574 	movhi	r5,33045
811007f4:	294e1c04 	addi	r5,r5,14448
811007f8:	1009883a 	mov	r4,r2
811007fc:	11215e00 	call	811215e0 <fprintf>
#endif

	return bSuccess;
81100800:	e0bff917 	ldw	r2,-28(fp)
}
81100804:	e037883a 	mov	sp,fp
81100808:	dfc00117 	ldw	ra,4(sp)
8110080c:	df000017 	ldw	fp,0(sp)
81100810:	dec00204 	addi	sp,sp,8
81100814:	f800283a 	ret

81100818 <bDdr2EepromDump>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2EepromDump(alt_u8 ucMemoryId) {
81100818:	deffb704 	addi	sp,sp,-292
8110081c:	de00012e 	bgeu	sp,et,81100824 <bDdr2EepromDump+0xc>
81100820:	003b68fa 	trap	3
81100824:	dfc04815 	stw	ra,288(sp)
81100828:	df004715 	stw	fp,284(sp)
8110082c:	df004704 	addi	fp,sp,284
81100830:	2005883a 	mov	r2,r4
81100834:	e0bfff05 	stb	r2,-4(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 EEPROM Dump =====\n");
81100838:	00e04574 	movhi	r3,33045
8110083c:	18ce1c04 	addi	r3,r3,14448
81100840:	00a04574 	movhi	r2,33045
81100844:	10adb004 	addi	r2,r2,-18752
81100848:	1009883a 	mov	r4,r2
8110084c:	00800884 	movi	r2,34
81100850:	100d883a 	mov	r6,r2
81100854:	200b883a 	mov	r5,r4
81100858:	1809883a 	mov	r4,r3
8110085c:	11226900 	call	81122690 <memcpy>
	debug(fp, cDebugBuffer);
81100860:	d0a06217 	ldw	r2,-32376(gp)
81100864:	01604574 	movhi	r5,33045
81100868:	294e1c04 	addi	r5,r5,14448
8110086c:	1009883a 	mov	r4,r2
81100870:	11215e00 	call	811215e0 <fprintf>
#endif
	const alt_u8 cucDeviceAddr = DDR2_EEPROM_I2C_ADDRESS;
81100874:	00bfe804 	movi	r2,-96
81100878:	e0bfbd05 	stb	r2,-268(fp)
	bool bSuccess;
	alt_u32 uliI2cSclBase;
	alt_u32 uliI2cSdaBase;
	int iI;

	bSuccess = TRUE;
8110087c:	00800044 	movi	r2,1
81100880:	e0bfbe15 	stw	r2,-264(fp)
	switch (ucMemoryId) {
81100884:	e0bfff03 	ldbu	r2,-4(fp)
81100888:	10000326 	beq	r2,zero,81100898 <bDdr2EepromDump+0x80>
8110088c:	10800060 	cmpeqi	r2,r2,1
81100890:	1000081e 	bne	r2,zero,811008b4 <bDdr2EepromDump+0x9c>
81100894:	00000e06 	br	811008d0 <bDdr2EepromDump+0xb8>
	case DDR2_M1_ID:
		uliI2cSclBase = DDR2_M1_EEPROM_I2C_SCL_BASE;
81100898:	00a00034 	movhi	r2,32768
8110089c:	10827c04 	addi	r2,r2,2544
811008a0:	e0bfba15 	stw	r2,-280(fp)
		uliI2cSdaBase = DDR2_M1_EEPROM_I2C_SDA_BASE;
811008a4:	00a00034 	movhi	r2,32768
811008a8:	10828004 	addi	r2,r2,2560
811008ac:	e0bfbb15 	stw	r2,-276(fp)
		break;
811008b0:	00001906 	br	81100918 <bDdr2EepromDump+0x100>
	case DDR2_M2_ID:
		uliI2cSclBase = DDR2_M2_EEPROM_I2C_SCL_BASE;
811008b4:	00a00034 	movhi	r2,32768
811008b8:	10825804 	addi	r2,r2,2400
811008bc:	e0bfba15 	stw	r2,-280(fp)
		uliI2cSdaBase = DDR2_M2_EEPROM_I2C_SDA_BASE;
811008c0:	00a00034 	movhi	r2,32768
811008c4:	10825c04 	addi	r2,r2,2416
811008c8:	e0bfbb15 	stw	r2,-276(fp)
		break;
811008cc:	00001206 	br	81100918 <bDdr2EepromDump+0x100>
	default:
		bSuccess = FALSE;
811008d0:	e03fbe15 	stw	zero,-264(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811008d4:	00e04574 	movhi	r3,33045
811008d8:	18ce1c04 	addi	r3,r3,14448
811008dc:	00a04574 	movhi	r2,33045
811008e0:	10adb904 	addi	r2,r2,-18716
811008e4:	1009883a 	mov	r4,r2
811008e8:	00800bc4 	movi	r2,47
811008ec:	100d883a 	mov	r6,r2
811008f0:	200b883a 	mov	r5,r4
811008f4:	1809883a 	mov	r4,r3
811008f8:	11226900 	call	81122690 <memcpy>
				"DR2 Memory ID not identified!! Aborting Dump \n");
		debug(fp, cDebugBuffer)
811008fc:	d0a06217 	ldw	r2,-32376(gp)
81100900:	01604574 	movhi	r5,33045
81100904:	294e1c04 	addi	r5,r5,14448
81100908:	1009883a 	mov	r4,r2
8110090c:	11215e00 	call	811215e0 <fprintf>
		;
#endif
		return bSuccess;
81100910:	e0bfbe17 	ldw	r2,-264(fp)
81100914:	0002e706 	br	811014b4 <bDdr2EepromDump+0xc9c>
	}

	alt_u8 ucSZData[256];
	bSuccess = I2C_MultipleRead(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100918:	e0bfbd03 	ldbu	r2,-268(fp)
8110091c:	10c03fcc 	andi	r3,r2,255
81100920:	18c0201c 	xori	r3,r3,128
81100924:	18ffe004 	addi	r3,r3,-128
81100928:	e13fbf04 	addi	r4,fp,-260
8110092c:	00804004 	movi	r2,256
81100930:	d8800015 	stw	r2,0(sp)
81100934:	200f883a 	mov	r7,r4
81100938:	180d883a 	mov	r6,r3
8110093c:	e17fbb17 	ldw	r5,-276(fp)
81100940:	e13fba17 	ldw	r4,-280(fp)
81100944:	110af300 	call	8110af30 <I2C_MultipleRead>
81100948:	e0bfbe15 	stw	r2,-264(fp)
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
8110094c:	e0bfbe17 	ldw	r2,-264(fp)
81100950:	1002be26 	beq	r2,zero,8110144c <bDdr2EepromDump+0xc34>
		for (iI = 0; iI < 256 && bSuccess; iI++) {
81100954:	e03fbc15 	stw	zero,-272(fp)
81100958:	0002b606 	br	81101434 <bDdr2EepromDump+0xc1c>
			if (iI == 0) {
8110095c:	e0bfbc17 	ldw	r2,-272(fp)
81100960:	1000121e 	bne	r2,zero,811009ac <bDdr2EepromDump+0x194>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"(Number of SPD Bytes Used)\n" "EEPROM[%03d]=%02Xh ",
						iI, ucSZData[iI]);
81100964:	e0ffbf04 	addi	r3,fp,-260
81100968:	e0bfbc17 	ldw	r2,-272(fp)
8110096c:	1885883a 	add	r2,r3,r2
81100970:	10800003 	ldbu	r2,0(r2)
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
		for (iI = 0; iI < 256 && bSuccess; iI++) {
			if (iI == 0) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100974:	10803fcc 	andi	r2,r2,255
81100978:	100f883a 	mov	r7,r2
8110097c:	e1bfbc17 	ldw	r6,-272(fp)
81100980:	01604574 	movhi	r5,33045
81100984:	296dc504 	addi	r5,r5,-18668
81100988:	01204574 	movhi	r4,33045
8110098c:	210e1c04 	addi	r4,r4,14448
81100990:	1122f700 	call	81122f70 <sprintf>
						"(Number of SPD Bytes Used)\n" "EEPROM[%03d]=%02Xh ",
						iI, ucSZData[iI]);
				debug(fp, cDebugBuffer);
81100994:	d0a06217 	ldw	r2,-32376(gp)
81100998:	01604574 	movhi	r5,33045
8110099c:	294e1c04 	addi	r5,r5,14448
811009a0:	1009883a 	mov	r4,r2
811009a4:	11215e00 	call	811215e0 <fprintf>
811009a8:	00029f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 1) {
811009ac:	e0bfbc17 	ldw	r2,-272(fp)
811009b0:	10800058 	cmpnei	r2,r2,1
811009b4:	1000101e 	bne	r2,zero,811009f8 <bDdr2EepromDump+0x1e0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811009b8:	00e04574 	movhi	r3,33045
811009bc:	18ce1c04 	addi	r3,r3,14448
811009c0:	00a04574 	movhi	r2,33045
811009c4:	10add104 	addi	r2,r2,-18620
811009c8:	1009883a 	mov	r4,r2
811009cc:	00800c04 	movi	r2,48
811009d0:	100d883a 	mov	r6,r2
811009d4:	200b883a 	mov	r5,r4
811009d8:	1809883a 	mov	r4,r3
811009dc:	11226900 	call	81122690 <memcpy>
						"(Total Number of Bytes in SPD Device, Log2(N))\n");
				debug(fp, cDebugBuffer);
811009e0:	d0a06217 	ldw	r2,-32376(gp)
811009e4:	01604574 	movhi	r5,33045
811009e8:	294e1c04 	addi	r5,r5,14448
811009ec:	1009883a 	mov	r4,r2
811009f0:	11215e00 	call	811215e0 <fprintf>
811009f4:	00028c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 2) {
811009f8:	e0bfbc17 	ldw	r2,-272(fp)
811009fc:	10800098 	cmpnei	r2,r2,2
81100a00:	1000101e 	bne	r2,zero,81100a44 <bDdr2EepromDump+0x22c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Basic Memory Type[08h:DDR2])\n");
81100a04:	00e04574 	movhi	r3,33045
81100a08:	18ce1c04 	addi	r3,r3,14448
81100a0c:	00a04574 	movhi	r2,33045
81100a10:	10addd04 	addi	r2,r2,-18572
81100a14:	1009883a 	mov	r4,r2
81100a18:	008007c4 	movi	r2,31
81100a1c:	100d883a 	mov	r6,r2
81100a20:	200b883a 	mov	r5,r4
81100a24:	1809883a 	mov	r4,r3
81100a28:	11226900 	call	81122690 <memcpy>
				debug(fp, cDebugBuffer);
81100a2c:	d0a06217 	ldw	r2,-32376(gp)
81100a30:	01604574 	movhi	r5,33045
81100a34:	294e1c04 	addi	r5,r5,14448
81100a38:	1009883a 	mov	r4,r2
81100a3c:	11215e00 	call	811215e0 <fprintf>
81100a40:	00027906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 3) {
81100a44:	e0bfbc17 	ldw	r2,-272(fp)
81100a48:	108000d8 	cmpnei	r2,r2,3
81100a4c:	1000101e 	bne	r2,zero,81100a90 <bDdr2EepromDump+0x278>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100a50:	00e04574 	movhi	r3,33045
81100a54:	18ce1c04 	addi	r3,r3,14448
81100a58:	00a04574 	movhi	r2,33045
81100a5c:	10ade504 	addi	r2,r2,-18540
81100a60:	1009883a 	mov	r4,r2
81100a64:	008009c4 	movi	r2,39
81100a68:	100d883a 	mov	r6,r2
81100a6c:	200b883a 	mov	r5,r4
81100a70:	1809883a 	mov	r4,r3
81100a74:	11226900 	call	81122690 <memcpy>
						"(Number of Row Addresses on Assembly)\n");
				debug(fp, cDebugBuffer);
81100a78:	d0a06217 	ldw	r2,-32376(gp)
81100a7c:	01604574 	movhi	r5,33045
81100a80:	294e1c04 	addi	r5,r5,14448
81100a84:	1009883a 	mov	r4,r2
81100a88:	11215e00 	call	811215e0 <fprintf>
81100a8c:	00026606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 4) {
81100a90:	e0bfbc17 	ldw	r2,-272(fp)
81100a94:	10800118 	cmpnei	r2,r2,4
81100a98:	1000101e 	bne	r2,zero,81100adc <bDdr2EepromDump+0x2c4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100a9c:	00e04574 	movhi	r3,33045
81100aa0:	18ce1c04 	addi	r3,r3,14448
81100aa4:	00a04574 	movhi	r2,33045
81100aa8:	10adef04 	addi	r2,r2,-18500
81100aac:	1009883a 	mov	r4,r2
81100ab0:	00800a84 	movi	r2,42
81100ab4:	100d883a 	mov	r6,r2
81100ab8:	200b883a 	mov	r5,r4
81100abc:	1809883a 	mov	r4,r3
81100ac0:	11226900 	call	81122690 <memcpy>
						"(Number of Column Addresses on Assembly)\n");
				debug(fp, cDebugBuffer);
81100ac4:	d0a06217 	ldw	r2,-32376(gp)
81100ac8:	01604574 	movhi	r5,33045
81100acc:	294e1c04 	addi	r5,r5,14448
81100ad0:	1009883a 	mov	r4,r2
81100ad4:	11215e00 	call	811215e0 <fprintf>
81100ad8:	00025306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 5) {
81100adc:	e0bfbc17 	ldw	r2,-272(fp)
81100ae0:	10800158 	cmpnei	r2,r2,5
81100ae4:	1000101e 	bne	r2,zero,81100b28 <bDdr2EepromDump+0x310>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100ae8:	00e04574 	movhi	r3,33045
81100aec:	18ce1c04 	addi	r3,r3,14448
81100af0:	00a04574 	movhi	r2,33045
81100af4:	10adfa04 	addi	r2,r2,-18456
81100af8:	1009883a 	mov	r4,r2
81100afc:	00800c04 	movi	r2,48
81100b00:	100d883a 	mov	r6,r2
81100b04:	200b883a 	mov	r5,r4
81100b08:	1809883a 	mov	r4,r3
81100b0c:	11226900 	call	81122690 <memcpy>
						"(DIMM Height and Module Rank Number[b2b1b0+1])\n");
				debug(fp, cDebugBuffer);
81100b10:	d0a06217 	ldw	r2,-32376(gp)
81100b14:	01604574 	movhi	r5,33045
81100b18:	294e1c04 	addi	r5,r5,14448
81100b1c:	1009883a 	mov	r4,r2
81100b20:	11215e00 	call	811215e0 <fprintf>
81100b24:	00024006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 6) {
81100b28:	e0bfbc17 	ldw	r2,-272(fp)
81100b2c:	10800198 	cmpnei	r2,r2,6
81100b30:	1000101e 	bne	r2,zero,81100b74 <bDdr2EepromDump+0x35c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Module Data Width)\n");
81100b34:	00e04574 	movhi	r3,33045
81100b38:	18ce1c04 	addi	r3,r3,14448
81100b3c:	00a04574 	movhi	r2,33045
81100b40:	10ae0604 	addi	r2,r2,-18408
81100b44:	1009883a 	mov	r4,r2
81100b48:	00800544 	movi	r2,21
81100b4c:	100d883a 	mov	r6,r2
81100b50:	200b883a 	mov	r5,r4
81100b54:	1809883a 	mov	r4,r3
81100b58:	11226900 	call	81122690 <memcpy>
				debug(fp, cDebugBuffer);
81100b5c:	d0a06217 	ldw	r2,-32376(gp)
81100b60:	01604574 	movhi	r5,33045
81100b64:	294e1c04 	addi	r5,r5,14448
81100b68:	1009883a 	mov	r4,r2
81100b6c:	11215e00 	call	811215e0 <fprintf>
81100b70:	00022d06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 7) {
81100b74:	e0bfbc17 	ldw	r2,-272(fp)
81100b78:	108001d8 	cmpnei	r2,r2,7
81100b7c:	1000101e 	bne	r2,zero,81100bc0 <bDdr2EepromDump+0x3a8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Module Data Width, Continued)\n");
81100b80:	00e04574 	movhi	r3,33045
81100b84:	18ce1c04 	addi	r3,r3,14448
81100b88:	00a04574 	movhi	r2,33045
81100b8c:	10ae0c04 	addi	r2,r2,-18384
81100b90:	1009883a 	mov	r4,r2
81100b94:	00800804 	movi	r2,32
81100b98:	100d883a 	mov	r6,r2
81100b9c:	200b883a 	mov	r5,r4
81100ba0:	1809883a 	mov	r4,r3
81100ba4:	11226900 	call	81122690 <memcpy>
				debug(fp, cDebugBuffer);
81100ba8:	d0a06217 	ldw	r2,-32376(gp)
81100bac:	01604574 	movhi	r5,33045
81100bb0:	294e1c04 	addi	r5,r5,14448
81100bb4:	1009883a 	mov	r4,r2
81100bb8:	11215e00 	call	811215e0 <fprintf>
81100bbc:	00021a06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 16) {
81100bc0:	e0bfbc17 	ldw	r2,-272(fp)
81100bc4:	10800418 	cmpnei	r2,r2,16
81100bc8:	1000101e 	bne	r2,zero,81100c0c <bDdr2EepromDump+0x3f4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100bcc:	00e04574 	movhi	r3,33045
81100bd0:	18ce1c04 	addi	r3,r3,14448
81100bd4:	00a04574 	movhi	r2,33045
81100bd8:	10ae1404 	addi	r2,r2,-18352
81100bdc:	1009883a 	mov	r4,r2
81100be0:	00800d04 	movi	r2,52
81100be4:	100d883a 	mov	r6,r2
81100be8:	200b883a 	mov	r5,r4
81100bec:	1809883a 	mov	r4,r3
81100bf0:	11226900 	call	81122690 <memcpy>
						"(Burst Lengths Supported[bitmap: x x x x 8 4 x x])\n");
				debug(fp, cDebugBuffer);
81100bf4:	d0a06217 	ldw	r2,-32376(gp)
81100bf8:	01604574 	movhi	r5,33045
81100bfc:	294e1c04 	addi	r5,r5,14448
81100c00:	1009883a 	mov	r4,r2
81100c04:	11215e00 	call	811215e0 <fprintf>
81100c08:	00020706 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 13) {
81100c0c:	e0bfbc17 	ldw	r2,-272(fp)
81100c10:	10800358 	cmpnei	r2,r2,13
81100c14:	1000101e 	bne	r2,zero,81100c58 <bDdr2EepromDump+0x440>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Primary SDRAM width)\n");
81100c18:	00e04574 	movhi	r3,33045
81100c1c:	18ce1c04 	addi	r3,r3,14448
81100c20:	00a04574 	movhi	r2,33045
81100c24:	10ae2104 	addi	r2,r2,-18300
81100c28:	1009883a 	mov	r4,r2
81100c2c:	008005c4 	movi	r2,23
81100c30:	100d883a 	mov	r6,r2
81100c34:	200b883a 	mov	r5,r4
81100c38:	1809883a 	mov	r4,r3
81100c3c:	11226900 	call	81122690 <memcpy>
				debug(fp, cDebugBuffer);
81100c40:	d0a06217 	ldw	r2,-32376(gp)
81100c44:	01604574 	movhi	r5,33045
81100c48:	294e1c04 	addi	r5,r5,14448
81100c4c:	1009883a 	mov	r4,r2
81100c50:	11215e00 	call	811215e0 <fprintf>
81100c54:	0001f406 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 14) {
81100c58:	e0bfbc17 	ldw	r2,-272(fp)
81100c5c:	10800398 	cmpnei	r2,r2,14
81100c60:	1000101e 	bne	r2,zero,81100ca4 <bDdr2EepromDump+0x48c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(ECC SDRAM width)\n");
81100c64:	00e04574 	movhi	r3,33045
81100c68:	18ce1c04 	addi	r3,r3,14448
81100c6c:	00a04574 	movhi	r2,33045
81100c70:	10ae2704 	addi	r2,r2,-18276
81100c74:	1009883a 	mov	r4,r2
81100c78:	008004c4 	movi	r2,19
81100c7c:	100d883a 	mov	r6,r2
81100c80:	200b883a 	mov	r5,r4
81100c84:	1809883a 	mov	r4,r3
81100c88:	11226900 	call	81122690 <memcpy>
				debug(fp, cDebugBuffer);
81100c8c:	d0a06217 	ldw	r2,-32376(gp)
81100c90:	01604574 	movhi	r5,33045
81100c94:	294e1c04 	addi	r5,r5,14448
81100c98:	1009883a 	mov	r4,r2
81100c9c:	11215e00 	call	811215e0 <fprintf>
81100ca0:	0001e106 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 17) {
81100ca4:	e0bfbc17 	ldw	r2,-272(fp)
81100ca8:	10800458 	cmpnei	r2,r2,17
81100cac:	1000101e 	bne	r2,zero,81100cf0 <bDdr2EepromDump+0x4d8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Banks per SDRAM device)\n");
81100cb0:	00e04574 	movhi	r3,33045
81100cb4:	18ce1c04 	addi	r3,r3,14448
81100cb8:	00a04574 	movhi	r2,33045
81100cbc:	10ae2c04 	addi	r2,r2,-18256
81100cc0:	1009883a 	mov	r4,r2
81100cc4:	00800684 	movi	r2,26
81100cc8:	100d883a 	mov	r6,r2
81100ccc:	200b883a 	mov	r5,r4
81100cd0:	1809883a 	mov	r4,r3
81100cd4:	11226900 	call	81122690 <memcpy>
				debug(fp, cDebugBuffer);
81100cd8:	d0a06217 	ldw	r2,-32376(gp)
81100cdc:	01604574 	movhi	r5,33045
81100ce0:	294e1c04 	addi	r5,r5,14448
81100ce4:	1009883a 	mov	r4,r2
81100ce8:	11215e00 	call	811215e0 <fprintf>
81100cec:	0001ce06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 18) {
81100cf0:	e0bfbc17 	ldw	r2,-272(fp)
81100cf4:	10800498 	cmpnei	r2,r2,18
81100cf8:	1000101e 	bne	r2,zero,81100d3c <bDdr2EepromDump+0x524>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100cfc:	00e04574 	movhi	r3,33045
81100d00:	18ce1c04 	addi	r3,r3,14448
81100d04:	00a04574 	movhi	r2,33045
81100d08:	10ae3304 	addi	r2,r2,-18228
81100d0c:	1009883a 	mov	r4,r2
81100d10:	00800d44 	movi	r2,53
81100d14:	100d883a 	mov	r6,r2
81100d18:	200b883a 	mov	r5,r4
81100d1c:	1809883a 	mov	r4,r3
81100d20:	11226900 	call	81122690 <memcpy>
						"(CAS lantencies supported[bitmap: x x 5 4 3 2 x x])\n");
				debug(fp, cDebugBuffer);
81100d24:	d0a06217 	ldw	r2,-32376(gp)
81100d28:	01604574 	movhi	r5,33045
81100d2c:	294e1c04 	addi	r5,r5,14448
81100d30:	1009883a 	mov	r4,r2
81100d34:	11215e00 	call	811215e0 <fprintf>
81100d38:	0001bb06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 20) {
81100d3c:	e0bfbc17 	ldw	r2,-272(fp)
81100d40:	10800518 	cmpnei	r2,r2,20
81100d44:	1000101e 	bne	r2,zero,81100d88 <bDdr2EepromDump+0x570>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100d48:	00e04574 	movhi	r3,33045
81100d4c:	18ce1c04 	addi	r3,r3,14448
81100d50:	00a04574 	movhi	r2,33045
81100d54:	10ae4104 	addi	r2,r2,-18172
81100d58:	1009883a 	mov	r4,r2
81100d5c:	00801204 	movi	r2,72
81100d60:	100d883a 	mov	r6,r2
81100d64:	200b883a 	mov	r5,r4
81100d68:	1809883a 	mov	r4,r3
81100d6c:	11226900 	call	81122690 <memcpy>
						"(DIMM Type: x x Mini-UDIMM Mini-RDIMM Micro-DIMM SO-DIMM UDIMMM RDIMM)\n");
				debug(fp, cDebugBuffer);
81100d70:	d0a06217 	ldw	r2,-32376(gp)
81100d74:	01604574 	movhi	r5,33045
81100d78:	294e1c04 	addi	r5,r5,14448
81100d7c:	1009883a 	mov	r4,r2
81100d80:	11215e00 	call	811215e0 <fprintf>
81100d84:	0001a806 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 22) {
81100d88:	e0bfbc17 	ldw	r2,-272(fp)
81100d8c:	10800598 	cmpnei	r2,r2,22
81100d90:	1000101e 	bne	r2,zero,81100dd4 <bDdr2EepromDump+0x5bc>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Memory Chip feature bitmap)\n");
81100d94:	00e04574 	movhi	r3,33045
81100d98:	18ce1c04 	addi	r3,r3,14448
81100d9c:	00a04574 	movhi	r2,33045
81100da0:	10ae5304 	addi	r2,r2,-18100
81100da4:	1009883a 	mov	r4,r2
81100da8:	00800784 	movi	r2,30
81100dac:	100d883a 	mov	r6,r2
81100db0:	200b883a 	mov	r5,r4
81100db4:	1809883a 	mov	r4,r3
81100db8:	11226900 	call	81122690 <memcpy>
				debug(fp, cDebugBuffer);
81100dbc:	d0a06217 	ldw	r2,-32376(gp)
81100dc0:	01604574 	movhi	r5,33045
81100dc4:	294e1c04 	addi	r5,r5,14448
81100dc8:	1009883a 	mov	r4,r2
81100dcc:	11215e00 	call	811215e0 <fprintf>
81100dd0:	00019506 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 27) {
81100dd4:	e0bfbc17 	ldw	r2,-272(fp)
81100dd8:	108006d8 	cmpnei	r2,r2,27
81100ddc:	1000101e 	bne	r2,zero,81100e20 <bDdr2EepromDump+0x608>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100de0:	00e04574 	movhi	r3,33045
81100de4:	18ce1c04 	addi	r3,r3,14448
81100de8:	00a04574 	movhi	r2,33045
81100dec:	10ae5b04 	addi	r2,r2,-18068
81100df0:	1009883a 	mov	r4,r2
81100df4:	00800a04 	movi	r2,40
81100df8:	100d883a 	mov	r6,r2
81100dfc:	200b883a 	mov	r5,r4
81100e00:	1809883a 	mov	r4,r3
81100e04:	11226900 	call	81122690 <memcpy>
						"(Minimun row precharge time[tRP;nsx4])\n");
				debug(fp, cDebugBuffer);
81100e08:	d0a06217 	ldw	r2,-32376(gp)
81100e0c:	01604574 	movhi	r5,33045
81100e10:	294e1c04 	addi	r5,r5,14448
81100e14:	1009883a 	mov	r4,r2
81100e18:	11215e00 	call	811215e0 <fprintf>
81100e1c:	00018206 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 28) {
81100e20:	e0bfbc17 	ldw	r2,-272(fp)
81100e24:	10800718 	cmpnei	r2,r2,28
81100e28:	1000101e 	bne	r2,zero,81100e6c <bDdr2EepromDump+0x654>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100e2c:	00e04574 	movhi	r3,33045
81100e30:	18ce1c04 	addi	r3,r3,14448
81100e34:	00a04574 	movhi	r2,33045
81100e38:	10ae6504 	addi	r2,r2,-18028
81100e3c:	1009883a 	mov	r4,r2
81100e40:	00800cc4 	movi	r2,51
81100e44:	100d883a 	mov	r6,r2
81100e48:	200b883a 	mov	r5,r4
81100e4c:	1809883a 	mov	r4,r3
81100e50:	11226900 	call	81122690 <memcpy>
						"(Minimun row active-row activce delay[tRRD;nsx4])\n");
				debug(fp, cDebugBuffer);
81100e54:	d0a06217 	ldw	r2,-32376(gp)
81100e58:	01604574 	movhi	r5,33045
81100e5c:	294e1c04 	addi	r5,r5,14448
81100e60:	1009883a 	mov	r4,r2
81100e64:	11215e00 	call	811215e0 <fprintf>
81100e68:	00016f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 29) {
81100e6c:	e0bfbc17 	ldw	r2,-272(fp)
81100e70:	10800758 	cmpnei	r2,r2,29
81100e74:	1000101e 	bne	r2,zero,81100eb8 <bDdr2EepromDump+0x6a0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100e78:	00e04574 	movhi	r3,33045
81100e7c:	18ce1c04 	addi	r3,r3,14448
81100e80:	00a04574 	movhi	r2,33045
81100e84:	10ae7204 	addi	r2,r2,-17976
81100e88:	1009883a 	mov	r4,r2
81100e8c:	008009c4 	movi	r2,39
81100e90:	100d883a 	mov	r6,r2
81100e94:	200b883a 	mov	r5,r4
81100e98:	1809883a 	mov	r4,r3
81100e9c:	11226900 	call	81122690 <memcpy>
						"(Minimun RAS to CAS delay[tRCD;nsx4])\n");
				debug(fp, cDebugBuffer);
81100ea0:	d0a06217 	ldw	r2,-32376(gp)
81100ea4:	01604574 	movhi	r5,33045
81100ea8:	294e1c04 	addi	r5,r5,14448
81100eac:	1009883a 	mov	r4,r2
81100eb0:	11215e00 	call	811215e0 <fprintf>
81100eb4:	00015c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 30) {
81100eb8:	e0bfbc17 	ldw	r2,-272(fp)
81100ebc:	10800798 	cmpnei	r2,r2,30
81100ec0:	1000101e 	bne	r2,zero,81100f04 <bDdr2EepromDump+0x6ec>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100ec4:	00e04574 	movhi	r3,33045
81100ec8:	18ce1c04 	addi	r3,r3,14448
81100ecc:	00a04574 	movhi	r2,33045
81100ed0:	10ae7c04 	addi	r2,r2,-17936
81100ed4:	1009883a 	mov	r4,r2
81100ed8:	00800b04 	movi	r2,44
81100edc:	100d883a 	mov	r6,r2
81100ee0:	200b883a 	mov	r5,r4
81100ee4:	1809883a 	mov	r4,r3
81100ee8:	11226900 	call	81122690 <memcpy>
						"(Minimun acive to precharge time[tRAS;ns])\n");
				debug(fp, cDebugBuffer);
81100eec:	d0a06217 	ldw	r2,-32376(gp)
81100ef0:	01604574 	movhi	r5,33045
81100ef4:	294e1c04 	addi	r5,r5,14448
81100ef8:	1009883a 	mov	r4,r2
81100efc:	11215e00 	call	811215e0 <fprintf>
81100f00:	00014906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 31) {
81100f04:	e0bfbc17 	ldw	r2,-272(fp)
81100f08:	108007d8 	cmpnei	r2,r2,31
81100f0c:	1000101e 	bne	r2,zero,81100f50 <bDdr2EepromDump+0x738>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100f10:	00e04574 	movhi	r3,33045
81100f14:	18ce1c04 	addi	r3,r3,14448
81100f18:	00a04574 	movhi	r2,33045
81100f1c:	10ae8704 	addi	r2,r2,-17892
81100f20:	1009883a 	mov	r4,r2
81100f24:	008010c4 	movi	r2,67
81100f28:	100d883a 	mov	r6,r2
81100f2c:	200b883a 	mov	r5,r4
81100f30:	1809883a 	mov	r4,r3
81100f34:	11226900 	call	81122690 <memcpy>
						"(Size of each rank[bitmap:512MB,256MB,128MB,16GB,8GB,4GB,2GB,1GB)\n");
				debug(fp, cDebugBuffer);
81100f38:	d0a06217 	ldw	r2,-32376(gp)
81100f3c:	01604574 	movhi	r5,33045
81100f40:	294e1c04 	addi	r5,r5,14448
81100f44:	1009883a 	mov	r4,r2
81100f48:	11215e00 	call	811215e0 <fprintf>
81100f4c:	00013606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 36) {
81100f50:	e0bfbc17 	ldw	r2,-272(fp)
81100f54:	10800918 	cmpnei	r2,r2,36
81100f58:	1000101e 	bne	r2,zero,81100f9c <bDdr2EepromDump+0x784>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100f5c:	00e04574 	movhi	r3,33045
81100f60:	18ce1c04 	addi	r3,r3,14448
81100f64:	00a04574 	movhi	r2,33045
81100f68:	10ae9804 	addi	r2,r2,-17824
81100f6c:	1009883a 	mov	r4,r2
81100f70:	00800a84 	movi	r2,42
81100f74:	100d883a 	mov	r6,r2
81100f78:	200b883a 	mov	r5,r4
81100f7c:	1809883a 	mov	r4,r3
81100f80:	11226900 	call	81122690 <memcpy>
						"(Minimun write receovery time[tWR;nsx4])\n");
				debug(fp, cDebugBuffer);
81100f84:	d0a06217 	ldw	r2,-32376(gp)
81100f88:	01604574 	movhi	r5,33045
81100f8c:	294e1c04 	addi	r5,r5,14448
81100f90:	1009883a 	mov	r4,r2
81100f94:	11215e00 	call	811215e0 <fprintf>
81100f98:	00012306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 37) {
81100f9c:	e0bfbc17 	ldw	r2,-272(fp)
81100fa0:	10800958 	cmpnei	r2,r2,37
81100fa4:	1000101e 	bne	r2,zero,81100fe8 <bDdr2EepromDump+0x7d0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100fa8:	00e04574 	movhi	r3,33045
81100fac:	18ce1c04 	addi	r3,r3,14448
81100fb0:	00a04574 	movhi	r2,33045
81100fb4:	10aea304 	addi	r2,r2,-17780
81100fb8:	1009883a 	mov	r4,r2
81100fbc:	00800cc4 	movi	r2,51
81100fc0:	100d883a 	mov	r6,r2
81100fc4:	200b883a 	mov	r5,r4
81100fc8:	1809883a 	mov	r4,r3
81100fcc:	11226900 	call	81122690 <memcpy>
						"(Internal write to read command delay[tWTR;nsx4])\n");
				debug(fp, cDebugBuffer);
81100fd0:	d0a06217 	ldw	r2,-32376(gp)
81100fd4:	01604574 	movhi	r5,33045
81100fd8:	294e1c04 	addi	r5,r5,14448
81100fdc:	1009883a 	mov	r4,r2
81100fe0:	11215e00 	call	811215e0 <fprintf>
81100fe4:	00011006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 38) {
81100fe8:	e0bfbc17 	ldw	r2,-272(fp)
81100fec:	10800998 	cmpnei	r2,r2,38
81100ff0:	1000101e 	bne	r2,zero,81101034 <bDdr2EepromDump+0x81c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100ff4:	00e04574 	movhi	r3,33045
81100ff8:	18ce1c04 	addi	r3,r3,14448
81100ffc:	00a04574 	movhi	r2,33045
81101000:	10aeb004 	addi	r2,r2,-17728
81101004:	1009883a 	mov	r4,r2
81101008:	00800dc4 	movi	r2,55
8110100c:	100d883a 	mov	r6,r2
81101010:	200b883a 	mov	r5,r4
81101014:	1809883a 	mov	r4,r3
81101018:	11226900 	call	81122690 <memcpy>
						"(Internal read to precharge command delay[tRTP;nsx4])\n");
				debug(fp, cDebugBuffer);
8110101c:	d0a06217 	ldw	r2,-32376(gp)
81101020:	01604574 	movhi	r5,33045
81101024:	294e1c04 	addi	r5,r5,14448
81101028:	1009883a 	mov	r4,r2
8110102c:	11215e00 	call	811215e0 <fprintf>
81101030:	0000fd06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 41) {
81101034:	e0bfbc17 	ldw	r2,-272(fp)
81101038:	10800a58 	cmpnei	r2,r2,41
8110103c:	1000101e 	bne	r2,zero,81101080 <bDdr2EepromDump+0x868>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101040:	00e04574 	movhi	r3,33045
81101044:	18ce1c04 	addi	r3,r3,14448
81101048:	00a04574 	movhi	r2,33045
8110104c:	10aebe04 	addi	r2,r2,-17672
81101050:	1009883a 	mov	r4,r2
81101054:	00800c84 	movi	r2,50
81101058:	100d883a 	mov	r6,r2
8110105c:	200b883a 	mov	r5,r4
81101060:	1809883a 	mov	r4,r3
81101064:	11226900 	call	81122690 <memcpy>
						"(Minimun activce to active/refresh time[tRC;ns])\n");
				debug(fp, cDebugBuffer);
81101068:	d0a06217 	ldw	r2,-32376(gp)
8110106c:	01604574 	movhi	r5,33045
81101070:	294e1c04 	addi	r5,r5,14448
81101074:	1009883a 	mov	r4,r2
81101078:	11215e00 	call	811215e0 <fprintf>
8110107c:	0000ea06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 42) {
81101080:	e0bfbc17 	ldw	r2,-272(fp)
81101084:	10800a98 	cmpnei	r2,r2,42
81101088:	1000101e 	bne	r2,zero,811010cc <bDdr2EepromDump+0x8b4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
8110108c:	00e04574 	movhi	r3,33045
81101090:	18ce1c04 	addi	r3,r3,14448
81101094:	00a04574 	movhi	r2,33045
81101098:	10aecb04 	addi	r2,r2,-17620
8110109c:	1009883a 	mov	r4,r2
811010a0:	00800cc4 	movi	r2,51
811010a4:	100d883a 	mov	r6,r2
811010a8:	200b883a 	mov	r5,r4
811010ac:	1809883a 	mov	r4,r3
811010b0:	11226900 	call	81122690 <memcpy>
						"(Minimun refresh to active/refresh time[tRFC;ns])\n");
				debug(fp, cDebugBuffer);
811010b4:	d0a06217 	ldw	r2,-32376(gp)
811010b8:	01604574 	movhi	r5,33045
811010bc:	294e1c04 	addi	r5,r5,14448
811010c0:	1009883a 	mov	r4,r2
811010c4:	11215e00 	call	811215e0 <fprintf>
811010c8:	0000d706 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 62) {
811010cc:	e0bfbc17 	ldw	r2,-272(fp)
811010d0:	10800f98 	cmpnei	r2,r2,62
811010d4:	1000101e 	bne	r2,zero,81101118 <bDdr2EepromDump+0x900>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(SPD Revision)\n");
811010d8:	00e04574 	movhi	r3,33045
811010dc:	18ce1c04 	addi	r3,r3,14448
811010e0:	00a04574 	movhi	r2,33045
811010e4:	10aed804 	addi	r2,r2,-17568
811010e8:	1009883a 	mov	r4,r2
811010ec:	00800404 	movi	r2,16
811010f0:	100d883a 	mov	r6,r2
811010f4:	200b883a 	mov	r5,r4
811010f8:	1809883a 	mov	r4,r3
811010fc:	11226900 	call	81122690 <memcpy>
				debug(fp, cDebugBuffer);
81101100:	d0a06217 	ldw	r2,-32376(gp)
81101104:	01604574 	movhi	r5,33045
81101108:	294e1c04 	addi	r5,r5,14448
8110110c:	1009883a 	mov	r4,r2
81101110:	11215e00 	call	811215e0 <fprintf>
81101114:	0000c406 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 63) {
81101118:	e0bfbc17 	ldw	r2,-272(fp)
8110111c:	10800fd8 	cmpnei	r2,r2,63
81101120:	10001f1e 	bne	r2,zero,811011a0 <bDdr2EepromDump+0x988>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Checksum)\n");
81101124:	00a04574 	movhi	r2,33045
81101128:	108e1c04 	addi	r2,r2,14448
8110112c:	00c00a04 	movi	r3,40
81101130:	10c00005 	stb	r3,0(r2)
81101134:	00c010c4 	movi	r3,67
81101138:	10c00045 	stb	r3,1(r2)
8110113c:	00c01a04 	movi	r3,104
81101140:	10c00085 	stb	r3,2(r2)
81101144:	00c01944 	movi	r3,101
81101148:	10c000c5 	stb	r3,3(r2)
8110114c:	00c018c4 	movi	r3,99
81101150:	10c00105 	stb	r3,4(r2)
81101154:	00c01ac4 	movi	r3,107
81101158:	10c00145 	stb	r3,5(r2)
8110115c:	00c01cc4 	movi	r3,115
81101160:	10c00185 	stb	r3,6(r2)
81101164:	00c01d44 	movi	r3,117
81101168:	10c001c5 	stb	r3,7(r2)
8110116c:	00c01b44 	movi	r3,109
81101170:	10c00205 	stb	r3,8(r2)
81101174:	00c00a44 	movi	r3,41
81101178:	10c00245 	stb	r3,9(r2)
8110117c:	00c00284 	movi	r3,10
81101180:	10c00285 	stb	r3,10(r2)
81101184:	100002c5 	stb	zero,11(r2)
				debug(fp, cDebugBuffer);
81101188:	d0a06217 	ldw	r2,-32376(gp)
8110118c:	01604574 	movhi	r5,33045
81101190:	294e1c04 	addi	r5,r5,14448
81101194:	1009883a 	mov	r4,r2
81101198:	11215e00 	call	811215e0 <fprintf>
8110119c:	0000a206 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 64) {
811011a0:	e0bfbc17 	ldw	r2,-272(fp)
811011a4:	10801018 	cmpnei	r2,r2,64
811011a8:	1000101e 	bne	r2,zero,811011ec <bDdr2EepromDump+0x9d4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(64~71: Manufacturer JEDEC ID)\n");
811011ac:	00e04574 	movhi	r3,33045
811011b0:	18ce1c04 	addi	r3,r3,14448
811011b4:	00a04574 	movhi	r2,33045
811011b8:	10aedc04 	addi	r2,r2,-17552
811011bc:	1009883a 	mov	r4,r2
811011c0:	00800804 	movi	r2,32
811011c4:	100d883a 	mov	r6,r2
811011c8:	200b883a 	mov	r5,r4
811011cc:	1809883a 	mov	r4,r3
811011d0:	11226900 	call	81122690 <memcpy>
				debug(fp, cDebugBuffer);
811011d4:	d0a06217 	ldw	r2,-32376(gp)
811011d8:	01604574 	movhi	r5,33045
811011dc:	294e1c04 	addi	r5,r5,14448
811011e0:	1009883a 	mov	r4,r2
811011e4:	11215e00 	call	811215e0 <fprintf>
811011e8:	00008f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 72) {
811011ec:	e0bfbc17 	ldw	r2,-272(fp)
811011f0:	10801218 	cmpnei	r2,r2,72
811011f4:	1000101e 	bne	r2,zero,81101238 <bDdr2EepromDump+0xa20>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811011f8:	00e04574 	movhi	r3,33045
811011fc:	18ce1c04 	addi	r3,r3,14448
81101200:	00a04574 	movhi	r2,33045
81101204:	10aee404 	addi	r2,r2,-17520
81101208:	1009883a 	mov	r4,r2
8110120c:	00800dc4 	movi	r2,55
81101210:	100d883a 	mov	r6,r2
81101214:	200b883a 	mov	r5,r4
81101218:	1809883a 	mov	r4,r3
8110121c:	11226900 	call	81122690 <memcpy>
						"(Module manufacturing location[Vendor-specific code])\n");
				debug(fp, cDebugBuffer);
81101220:	d0a06217 	ldw	r2,-32376(gp)
81101224:	01604574 	movhi	r5,33045
81101228:	294e1c04 	addi	r5,r5,14448
8110122c:	1009883a 	mov	r4,r2
81101230:	11215e00 	call	811215e0 <fprintf>
81101234:	00007c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 73) {
81101238:	e0bfbc17 	ldw	r2,-272(fp)
8110123c:	10801258 	cmpnei	r2,r2,73
81101240:	1000101e 	bne	r2,zero,81101284 <bDdr2EepromDump+0xa6c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(73~90: Moduloe part number)\n");
81101244:	00e04574 	movhi	r3,33045
81101248:	18ce1c04 	addi	r3,r3,14448
8110124c:	00a04574 	movhi	r2,33045
81101250:	10aef204 	addi	r2,r2,-17464
81101254:	1009883a 	mov	r4,r2
81101258:	00800784 	movi	r2,30
8110125c:	100d883a 	mov	r6,r2
81101260:	200b883a 	mov	r5,r4
81101264:	1809883a 	mov	r4,r3
81101268:	11226900 	call	81122690 <memcpy>
				debug(fp, cDebugBuffer);
8110126c:	d0a06217 	ldw	r2,-32376(gp)
81101270:	01604574 	movhi	r5,33045
81101274:	294e1c04 	addi	r5,r5,14448
81101278:	1009883a 	mov	r4,r2
8110127c:	11215e00 	call	811215e0 <fprintf>
81101280:	00006906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 91) {
81101284:	e0bfbc17 	ldw	r2,-272(fp)
81101288:	108016d8 	cmpnei	r2,r2,91
8110128c:	1000101e 	bne	r2,zero,811012d0 <bDdr2EepromDump+0xab8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(91~92: Moduloe revision code)\n");
81101290:	00e04574 	movhi	r3,33045
81101294:	18ce1c04 	addi	r3,r3,14448
81101298:	00a04574 	movhi	r2,33045
8110129c:	10aefa04 	addi	r2,r2,-17432
811012a0:	1009883a 	mov	r4,r2
811012a4:	00800804 	movi	r2,32
811012a8:	100d883a 	mov	r6,r2
811012ac:	200b883a 	mov	r5,r4
811012b0:	1809883a 	mov	r4,r3
811012b4:	11226900 	call	81122690 <memcpy>
				debug(fp, cDebugBuffer);
811012b8:	d0a06217 	ldw	r2,-32376(gp)
811012bc:	01604574 	movhi	r5,33045
811012c0:	294e1c04 	addi	r5,r5,14448
811012c4:	1009883a 	mov	r4,r2
811012c8:	11215e00 	call	811215e0 <fprintf>
811012cc:	00005606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 93) {
811012d0:	e0bfbc17 	ldw	r2,-272(fp)
811012d4:	10801758 	cmpnei	r2,r2,93
811012d8:	1000101e 	bne	r2,zero,8110131c <bDdr2EepromDump+0xb04>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811012dc:	00e04574 	movhi	r3,33045
811012e0:	18ce1c04 	addi	r3,r3,14448
811012e4:	00a04574 	movhi	r2,33045
811012e8:	10af0204 	addi	r2,r2,-17400
811012ec:	1009883a 	mov	r4,r2
811012f0:	008009c4 	movi	r2,39
811012f4:	100d883a 	mov	r6,r2
811012f8:	200b883a 	mov	r5,r4
811012fc:	1809883a 	mov	r4,r3
81101300:	11226900 	call	81122690 <memcpy>
						"(Manufacture Years since 2000[0-255])\n");
				debug(fp, cDebugBuffer);
81101304:	d0a06217 	ldw	r2,-32376(gp)
81101308:	01604574 	movhi	r5,33045
8110130c:	294e1c04 	addi	r5,r5,14448
81101310:	1009883a 	mov	r4,r2
81101314:	11215e00 	call	811215e0 <fprintf>
81101318:	00004306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 94) {
8110131c:	e0bfbc17 	ldw	r2,-272(fp)
81101320:	10801798 	cmpnei	r2,r2,94
81101324:	1000101e 	bne	r2,zero,81101368 <bDdr2EepromDump+0xb50>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Manufacture Weeks[1-52])\n");
81101328:	00e04574 	movhi	r3,33045
8110132c:	18ce1c04 	addi	r3,r3,14448
81101330:	00a04574 	movhi	r2,33045
81101334:	10af0c04 	addi	r2,r2,-17360
81101338:	1009883a 	mov	r4,r2
8110133c:	008006c4 	movi	r2,27
81101340:	100d883a 	mov	r6,r2
81101344:	200b883a 	mov	r5,r4
81101348:	1809883a 	mov	r4,r3
8110134c:	11226900 	call	81122690 <memcpy>
				debug(fp, cDebugBuffer);
81101350:	d0a06217 	ldw	r2,-32376(gp)
81101354:	01604574 	movhi	r5,33045
81101358:	294e1c04 	addi	r5,r5,14448
8110135c:	1009883a 	mov	r4,r2
81101360:	11215e00 	call	811215e0 <fprintf>
81101364:	00003006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 95) {
81101368:	e0bfbc17 	ldw	r2,-272(fp)
8110136c:	108017d8 	cmpnei	r2,r2,95
81101370:	1000101e 	bne	r2,zero,811013b4 <bDdr2EepromDump+0xb9c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101374:	00e04574 	movhi	r3,33045
81101378:	18ce1c04 	addi	r3,r3,14448
8110137c:	00a04574 	movhi	r2,33045
81101380:	10af1304 	addi	r2,r2,-17332
81101384:	1009883a 	mov	r4,r2
81101388:	00800a04 	movi	r2,40
8110138c:	100d883a 	mov	r6,r2
81101390:	200b883a 	mov	r5,r4
81101394:	1809883a 	mov	r4,r3
81101398:	11226900 	call	81122690 <memcpy>
						"(95~98[4-bytes]: Module serial number)\n");
				debug(fp, cDebugBuffer);
8110139c:	d0a06217 	ldw	r2,-32376(gp)
811013a0:	01604574 	movhi	r5,33045
811013a4:	294e1c04 	addi	r5,r5,14448
811013a8:	1009883a 	mov	r4,r2
811013ac:	11215e00 	call	811215e0 <fprintf>
811013b0:	00001d06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 99) {
811013b4:	e0bfbc17 	ldw	r2,-272(fp)
811013b8:	108018d8 	cmpnei	r2,r2,99
811013bc:	1000101e 	bne	r2,zero,81101400 <bDdr2EepromDump+0xbe8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(99~128: Manufacturer-specific data)\n");
811013c0:	00e04574 	movhi	r3,33045
811013c4:	18ce1c04 	addi	r3,r3,14448
811013c8:	00a04574 	movhi	r2,33045
811013cc:	10af1d04 	addi	r2,r2,-17292
811013d0:	1009883a 	mov	r4,r2
811013d4:	00800984 	movi	r2,38
811013d8:	100d883a 	mov	r6,r2
811013dc:	200b883a 	mov	r5,r4
811013e0:	1809883a 	mov	r4,r3
811013e4:	11226900 	call	81122690 <memcpy>
				debug(fp, cDebugBuffer);
811013e8:	d0a06217 	ldw	r2,-32376(gp)
811013ec:	01604574 	movhi	r5,33045
811013f0:	294e1c04 	addi	r5,r5,14448
811013f4:	1009883a 	mov	r4,r2
811013f8:	11215e00 	call	811215e0 <fprintf>
811013fc:	00000a06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "\n");
81101400:	00a04574 	movhi	r2,33045
81101404:	108e1c04 	addi	r2,r2,14448
81101408:	00c00284 	movi	r3,10
8110140c:	10c00005 	stb	r3,0(r2)
81101410:	10000045 	stb	zero,1(r2)
				debug(fp, cDebugBuffer);
81101414:	d0a06217 	ldw	r2,-32376(gp)
81101418:	01604574 	movhi	r5,33045
8110141c:	294e1c04 	addi	r5,r5,14448
81101420:	1009883a 	mov	r4,r2
81101424:	11215e00 	call	811215e0 <fprintf>

	alt_u8 ucSZData[256];
	bSuccess = I2C_MultipleRead(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
		for (iI = 0; iI < 256 && bSuccess; iI++) {
81101428:	e0bfbc17 	ldw	r2,-272(fp)
8110142c:	10800044 	addi	r2,r2,1
81101430:	e0bfbc15 	stw	r2,-272(fp)
81101434:	e0bfbc17 	ldw	r2,-272(fp)
81101438:	10804008 	cmpgei	r2,r2,256
8110143c:	1000121e 	bne	r2,zero,81101488 <bDdr2EepromDump+0xc70>
81101440:	e0bfbe17 	ldw	r2,-264(fp)
81101444:	103d451e 	bne	r2,zero,8110095c <__reset+0xfb0e095c>
81101448:	00000f06 	br	81101488 <bDdr2EepromDump+0xc70>
#endif
			}
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Failed to dump EEPROM\n");
8110144c:	00e04574 	movhi	r3,33045
81101450:	18ce1c04 	addi	r3,r3,14448
81101454:	00a04574 	movhi	r2,33045
81101458:	10af2704 	addi	r2,r2,-17252
8110145c:	1009883a 	mov	r4,r2
81101460:	008005c4 	movi	r2,23
81101464:	100d883a 	mov	r6,r2
81101468:	200b883a 	mov	r5,r4
8110146c:	1809883a 	mov	r4,r3
81101470:	11226900 	call	81122690 <memcpy>
		debug(fp, cDebugBuffer);
81101474:	d0a06217 	ldw	r2,-32376(gp)
81101478:	01604574 	movhi	r5,33045
8110147c:	294e1c04 	addi	r5,r5,14448
81101480:	1009883a 	mov	r4,r2
81101484:	11215e00 	call	811215e0 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101488:	00a04574 	movhi	r2,33045
8110148c:	108e1c04 	addi	r2,r2,14448
81101490:	00c00284 	movi	r3,10
81101494:	10c00005 	stb	r3,0(r2)
81101498:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
8110149c:	d0a06217 	ldw	r2,-32376(gp)
811014a0:	01604574 	movhi	r5,33045
811014a4:	294e1c04 	addi	r5,r5,14448
811014a8:	1009883a 	mov	r4,r2
811014ac:	11215e00 	call	811215e0 <fprintf>
#endif

	return bSuccess;
811014b0:	e0bfbe17 	ldw	r2,-264(fp)
}
811014b4:	e037883a 	mov	sp,fp
811014b8:	dfc00117 	ldw	ra,4(sp)
811014bc:	df000017 	ldw	fp,0(sp)
811014c0:	dec00204 	addi	sp,sp,8
811014c4:	f800283a 	ret

811014c8 <bDdr2SwitchMemory>:

bool bDdr2SwitchMemory(alt_u8 ucMemoryId) {
811014c8:	defffb04 	addi	sp,sp,-20
811014cc:	de00012e 	bgeu	sp,et,811014d4 <bDdr2SwitchMemory+0xc>
811014d0:	003b68fa 	trap	3
811014d4:	dfc00415 	stw	ra,16(sp)
811014d8:	df000315 	stw	fp,12(sp)
811014dc:	df000304 	addi	fp,sp,12
811014e0:	2005883a 	mov	r2,r4
811014e4:	e0bfff05 	stb	r2,-4(fp)

	bool bSuccess;
	alt_u32 *puliDdr2MemAddr = (alt_u32 *) DDR2_EXT_ADDR_CONTROL_BASE;
811014e8:	00a04834 	movhi	r2,33056
811014ec:	108c2204 	addi	r2,r2,12424
811014f0:	e0bffe15 	stw	r2,-8(fp)

	bSuccess = TRUE;
811014f4:	00800044 	movi	r2,1
811014f8:	e0bffd15 	stw	r2,-12(fp)
	switch (ucMemoryId) {
811014fc:	e0bfff03 	ldbu	r2,-4(fp)
81101500:	10000326 	beq	r2,zero,81101510 <bDdr2SwitchMemory+0x48>
81101504:	10800060 	cmpeqi	r2,r2,1
81101508:	1000041e 	bne	r2,zero,8110151c <bDdr2SwitchMemory+0x54>
8110150c:	00000706 	br	8110152c <bDdr2SwitchMemory+0x64>
	case DDR2_M1_ID:
		*(puliDdr2MemAddr) = (alt_u32) DDR2_M1_MEMORY_WINDOWED_OFFSET;
81101510:	e0bffe17 	ldw	r2,-8(fp)
81101514:	10000015 	stw	zero,0(r2)
		break;
81101518:	00001406 	br	8110156c <bDdr2SwitchMemory+0xa4>
	case DDR2_M2_ID:
		*(puliDdr2MemAddr) = (alt_u32) DDR2_M2_MEMORY_WINDOWED_OFFSET;
8110151c:	e0bffe17 	ldw	r2,-8(fp)
81101520:	00e00034 	movhi	r3,32768
81101524:	10c00015 	stw	r3,0(r2)
		break;
81101528:	00001006 	br	8110156c <bDdr2SwitchMemory+0xa4>
	default:
		bSuccess = FALSE;
8110152c:	e03ffd15 	stw	zero,-12(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101530:	00e04574 	movhi	r3,33045
81101534:	18ce1c04 	addi	r3,r3,14448
81101538:	00a04574 	movhi	r2,33045
8110153c:	10af2d04 	addi	r2,r2,-17228
81101540:	1009883a 	mov	r4,r2
81101544:	00800f04 	movi	r2,60
81101548:	100d883a 	mov	r6,r2
8110154c:	200b883a 	mov	r5,r4
81101550:	1809883a 	mov	r4,r3
81101554:	11226900 	call	81122690 <memcpy>
				"DR2 Memory ID not identified!! Error switching memories!! \n");
		debug(fp, cDebugBuffer)
81101558:	d0a06217 	ldw	r2,-32376(gp)
8110155c:	01604574 	movhi	r5,33045
81101560:	294e1c04 	addi	r5,r5,14448
81101564:	1009883a 	mov	r4,r2
81101568:	11215e00 	call	811215e0 <fprintf>
		;
#endif
	}

	return bSuccess;
8110156c:	e0bffd17 	ldw	r2,-12(fp)
}
81101570:	e037883a 	mov	sp,fp
81101574:	dfc00117 	ldw	ra,4(sp)
81101578:	df000017 	ldw	fp,0(sp)
8110157c:	dec00204 	addi	sp,sp,8
81101580:	f800283a 	ret

81101584 <bDdr2MemoryWriteTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryWriteTest(alt_u8 ucMemoryId) {
81101584:	deffe204 	addi	sp,sp,-120
81101588:	de00012e 	bgeu	sp,et,81101590 <bDdr2MemoryWriteTest+0xc>
8110158c:	003b68fa 	trap	3
81101590:	dfc01d15 	stw	ra,116(sp)
81101594:	df001c15 	stw	fp,112(sp)
81101598:	dc401b15 	stw	r17,108(sp)
8110159c:	dc001a15 	stw	r16,104(sp)
811015a0:	df001c04 	addi	fp,sp,112
811015a4:	2005883a 	mov	r2,r4
811015a8:	e0bffd05 	stb	r2,-12(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Write Test =====\n");
811015ac:	00e04574 	movhi	r3,33045
811015b0:	18ce1c04 	addi	r3,r3,14448
811015b4:	00a04574 	movhi	r2,33045
811015b8:	10af3c04 	addi	r2,r2,-17168
811015bc:	1009883a 	mov	r4,r2
811015c0:	00800a04 	movi	r2,40
811015c4:	100d883a 	mov	r6,r2
811015c8:	200b883a 	mov	r5,r4
811015cc:	1809883a 	mov	r4,r3
811015d0:	11226900 	call	81122690 <memcpy>
	debug(fp, cDebugBuffer);
811015d4:	d0a06217 	ldw	r2,-32376(gp)
811015d8:	01604574 	movhi	r5,33045
811015dc:	294e1c04 	addi	r5,r5,14448
811015e0:	1009883a 	mov	r4,r2
811015e4:	11215e00 	call	811215e0 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
811015e8:	00800044 	movi	r2,1
811015ec:	e0bfed15 	stw	r2,-76(fp)
	switch (ucMemoryId) {
811015f0:	e0bffd03 	ldbu	r2,-12(fp)
811015f4:	10000326 	beq	r2,zero,81101604 <bDdr2MemoryWriteTest+0x80>
811015f8:	10800060 	cmpeqi	r2,r2,1
811015fc:	1000081e 	bne	r2,zero,81101620 <bDdr2MemoryWriteTest+0x9c>
81101600:	00000e06 	br	8110163c <bDdr2MemoryWriteTest+0xb8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101604:	e0bffd03 	ldbu	r2,-12(fp)
81101608:	1009883a 	mov	r4,r2
8110160c:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101610:	e03fe515 	stw	zero,-108(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81101614:	00a00034 	movhi	r2,32768
81101618:	e0bfe615 	stw	r2,-104(fp)
		break;
8110161c:	00001906 	br	81101684 <bDdr2MemoryWriteTest+0x100>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101620:	e0bffd03 	ldbu	r2,-12(fp)
81101624:	1009883a 	mov	r4,r2
81101628:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
8110162c:	e03fe515 	stw	zero,-108(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81101630:	00a00034 	movhi	r2,32768
81101634:	e0bfe615 	stw	r2,-104(fp)
		break;
81101638:	00001206 	br	81101684 <bDdr2MemoryWriteTest+0x100>
	default:
		bSuccess = FALSE;
8110163c:	e03fed15 	stw	zero,-76(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101640:	00e04574 	movhi	r3,33045
81101644:	18ce1c04 	addi	r3,r3,14448
81101648:	00a04574 	movhi	r2,33045
8110164c:	10ad4d04 	addi	r2,r2,-19148
81101650:	1009883a 	mov	r4,r2
81101654:	00800bc4 	movi	r2,47
81101658:	100d883a 	mov	r6,r2
8110165c:	200b883a 	mov	r5,r4
81101660:	1809883a 	mov	r4,r3
81101664:	11226900 	call	81122690 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81101668:	d0a06217 	ldw	r2,-32376(gp)
8110166c:	01604574 	movhi	r5,33045
81101670:	294e1c04 	addi	r5,r5,14448
81101674:	1009883a 	mov	r4,r2
81101678:	11215e00 	call	811215e0 <fprintf>
		;
#endif
		return bSuccess;
8110167c:	e0bfed17 	ldw	r2,-76(fp)
81101680:	00011806 	br	81101ae4 <bDdr2MemoryWriteTest+0x560>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
81101684:	e0bfe617 	ldw	r2,-104(fp)
81101688:	1004d53a 	srli	r2,r2,20
8110168c:	100d883a 	mov	r6,r2
81101690:	01604574 	movhi	r5,33045
81101694:	296f4604 	addi	r5,r5,-17128
81101698:	01204574 	movhi	r4,33045
8110169c:	210e1c04 	addi	r4,r4,14448
811016a0:	1122f700 	call	81122f70 <sprintf>
	debug(fp, cDebugBuffer);
811016a4:	d0a06217 	ldw	r2,-32376(gp)
811016a8:	01604574 	movhi	r5,33045
811016ac:	294e1c04 	addi	r5,r5,14448
811016b0:	1009883a 	mov	r4,r2
811016b4:	11215e00 	call	811215e0 <fprintf>

	int iI, iNRemainedLen, iNAccessLen;
	TMyData *pxDes;

	int iNItemNum, iNPos;
	const int ciMyDataSize = sizeof(TMyData);
811016b8:	00800104 	movi	r2,4
811016bc:	e0bfee15 	stw	r2,-72(fp)
	int iNProgressIndex = 0;
811016c0:	e03fec15 	stw	zero,-80(fp)
	alt_u32 uliInitValue;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;
811016c4:	e03fef15 	stw	zero,-68(fp)

	for (iI = 0; iI < 10; iI++) {
811016c8:	e03fe715 	stw	zero,-100(fp)
811016cc:	00001506 	br	81101724 <bDdr2MemoryWriteTest+0x1a0>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
811016d0:	e0ffe617 	ldw	r3,-104(fp)
811016d4:	00b33374 	movhi	r2,52429
811016d8:	10b33344 	addi	r2,r2,-13107
811016dc:	1888383a 	mulxuu	r4,r3,r2
811016e0:	1885383a 	mul	r2,r3,r2
811016e4:	1021883a 	mov	r16,r2
811016e8:	2023883a 	mov	r17,r4
811016ec:	8804d0fa 	srli	r2,r17,3
811016f0:	e0ffe717 	ldw	r3,-100(fp)
811016f4:	18c00044 	addi	r3,r3,1
811016f8:	10c7383a 	mul	r3,r2,r3
811016fc:	e0bfe717 	ldw	r2,-100(fp)
81101700:	1085883a 	add	r2,r2,r2
81101704:	1085883a 	add	r2,r2,r2
81101708:	e13fe504 	addi	r4,fp,-108
8110170c:	2085883a 	add	r2,r4,r2
81101710:	10800e04 	addi	r2,r2,56
81101714:	10c00015 	stw	r3,0(r2)
	int iNProgressIndex = 0;
	alt_u32 uliInitValue;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;

	for (iI = 0; iI < 10; iI++) {
81101718:	e0bfe717 	ldw	r2,-100(fp)
8110171c:	10800044 	addi	r2,r2,1
81101720:	e0bfe715 	stw	r2,-100(fp)
81101724:	e0bfe717 	ldw	r2,-100(fp)
81101728:	10800290 	cmplti	r2,r2,10
8110172c:	103fe81e 	bne	r2,zero,811016d0 <__reset+0xfb0e16d0>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81101730:	d0a08917 	ldw	r2,-32220(gp)
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}
	uliInitValue = alt_nticks();
81101734:	e0bff015 	stw	r2,-64(fp)
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
81101738:	00804004 	movi	r2,256
8110173c:	e0bfea15 	stw	r2,-88(fp)
	for (iI = 0; iI < iNItemNum; iI++) {
81101740:	e03fe715 	stw	zero,-100(fp)
81101744:	00001e06 	br	811017c0 <bDdr2MemoryWriteTest+0x23c>
		if (iI == 0) {
81101748:	e0bfe717 	ldw	r2,-100(fp)
8110174c:	1000091e 	bne	r2,zero,81101774 <bDdr2MemoryWriteTest+0x1f0>
			xSZData[iI] = uliInitValue;
81101750:	00a04574 	movhi	r2,33045
81101754:	108e5c04 	addi	r2,r2,14704
81101758:	e0ffe717 	ldw	r3,-100(fp)
8110175c:	18c7883a 	add	r3,r3,r3
81101760:	18c7883a 	add	r3,r3,r3
81101764:	10c5883a 	add	r2,r2,r3
81101768:	e0fff017 	ldw	r3,-64(fp)
8110176c:	10c00015 	stw	r3,0(r2)
81101770:	00001006 	br	811017b4 <bDdr2MemoryWriteTest+0x230>
		} else {
			xSZData[iI] = xSZData[iI - 1] * 13;
81101774:	e0bfe717 	ldw	r2,-100(fp)
81101778:	10ffffc4 	addi	r3,r2,-1
8110177c:	00a04574 	movhi	r2,33045
81101780:	108e5c04 	addi	r2,r2,14704
81101784:	18c7883a 	add	r3,r3,r3
81101788:	18c7883a 	add	r3,r3,r3
8110178c:	10c5883a 	add	r2,r2,r3
81101790:	10800017 	ldw	r2,0(r2)
81101794:	11000364 	muli	r4,r2,13
81101798:	00a04574 	movhi	r2,33045
8110179c:	108e5c04 	addi	r2,r2,14704
811017a0:	e0ffe717 	ldw	r3,-100(fp)
811017a4:	18c7883a 	add	r3,r3,r3
811017a8:	18c7883a 	add	r3,r3,r3
811017ac:	10c5883a 	add	r2,r2,r3
811017b0:	11000015 	stw	r4,0(r2)
	for (iI = 0; iI < 10; iI++) {
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}
	uliInitValue = alt_nticks();
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
	for (iI = 0; iI < iNItemNum; iI++) {
811017b4:	e0bfe717 	ldw	r2,-100(fp)
811017b8:	10800044 	addi	r2,r2,1
811017bc:	e0bfe715 	stw	r2,-100(fp)
811017c0:	e0ffe717 	ldw	r3,-100(fp)
811017c4:	e0bfea17 	ldw	r2,-88(fp)
811017c8:	18bfdf16 	blt	r3,r2,81101748 <__reset+0xfb0e1748>
			xSZData[iI] = uliInitValue;
		} else {
			xSZData[iI] = xSZData[iI - 1] * 13;
		}
	}
	xSZData[iNItemNum - 1] = 0xAAAAAAAA;
811017cc:	e0bfea17 	ldw	r2,-88(fp)
811017d0:	10ffffc4 	addi	r3,r2,-1
811017d4:	00a04574 	movhi	r2,33045
811017d8:	108e5c04 	addi	r2,r2,14704
811017dc:	18c7883a 	add	r3,r3,r3
811017e0:	18c7883a 	add	r3,r3,r3
811017e4:	10c7883a 	add	r3,r2,r3
811017e8:	00aaaaf4 	movhi	r2,43691
811017ec:	10aaaa84 	addi	r2,r2,-21846
811017f0:	18800015 	stw	r2,0(r3)
	xSZData[iNItemNum - 2] = 0x55555555;
811017f4:	e0bfea17 	ldw	r2,-88(fp)
811017f8:	10ffff84 	addi	r3,r2,-2
811017fc:	00a04574 	movhi	r2,33045
81101800:	108e5c04 	addi	r2,r2,14704
81101804:	18c7883a 	add	r3,r3,r3
81101808:	18c7883a 	add	r3,r3,r3
8110180c:	10c7883a 	add	r3,r2,r3
81101810:	00955574 	movhi	r2,21845
81101814:	10955544 	addi	r2,r2,21845
81101818:	18800015 	stw	r2,0(r3)
	xSZData[iNItemNum - 3] = 0x00000000;
8110181c:	e0bfea17 	ldw	r2,-88(fp)
81101820:	10ffff44 	addi	r3,r2,-3
81101824:	00a04574 	movhi	r2,33045
81101828:	108e5c04 	addi	r2,r2,14704
8110182c:	18c7883a 	add	r3,r3,r3
81101830:	18c7883a 	add	r3,r3,r3
81101834:	10c5883a 	add	r2,r2,r3
81101838:	10000015 	stw	zero,0(r2)
	xSZData[iNItemNum - 4] = 0xFFFFFFFF;
8110183c:	e0bfea17 	ldw	r2,-88(fp)
81101840:	10ffff04 	addi	r3,r2,-4
81101844:	00a04574 	movhi	r2,33045
81101848:	108e5c04 	addi	r2,r2,14704
8110184c:	18c7883a 	add	r3,r3,r3
81101850:	18c7883a 	add	r3,r3,r3
81101854:	10c5883a 	add	r2,r2,r3
81101858:	00ffffc4 	movi	r3,-1
8110185c:	10c00015 	stw	r3,0(r2)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Writing data...\n");
81101860:	00e04574 	movhi	r3,33045
81101864:	18ce1c04 	addi	r3,r3,14448
81101868:	00a04574 	movhi	r2,33045
8110186c:	10af4c04 	addi	r2,r2,-17104
81101870:	1009883a 	mov	r4,r2
81101874:	00800444 	movi	r2,17
81101878:	100d883a 	mov	r6,r2
8110187c:	200b883a 	mov	r5,r4
81101880:	1809883a 	mov	r4,r3
81101884:	11226900 	call	81122690 <memcpy>
	debug(fp, cDebugBuffer);
81101888:	d0a06217 	ldw	r2,-32376(gp)
8110188c:	01604574 	movhi	r5,33045
81101890:	294e1c04 	addi	r5,r5,14448
81101894:	1009883a 	mov	r4,r2
81101898:	11215e00 	call	811215e0 <fprintf>
8110189c:	d0a08917 	ldw	r2,-32220(gp)
#endif
	iTimeStart = alt_nticks();
811018a0:	e0bff115 	stw	r2,-60(fp)
	pxDes = (TMyData *) uliDdr2Base;
811018a4:	e0bfe517 	ldw	r2,-108(fp)
811018a8:	e0bfe915 	stw	r2,-92(fp)
	iNAccessLen = sizeof(xSZData);
811018ac:	00810004 	movi	r2,1024
811018b0:	e0bfe815 	stw	r2,-96(fp)
	iNItemNum = iNAccessLen / ciMyDataSize;
811018b4:	e0ffe817 	ldw	r3,-96(fp)
811018b8:	e0bfee17 	ldw	r2,-72(fp)
811018bc:	1885283a 	div	r2,r3,r2
811018c0:	e0bfea15 	stw	r2,-88(fp)
	iNPos = 0;
811018c4:	e03feb15 	stw	zero,-84(fp)
	while (iNPos < uliByteLen) {
811018c8:	00003a06 	br	811019b4 <bDdr2MemoryWriteTest+0x430>
		iNRemainedLen = uliByteLen - iNPos;
811018cc:	e0bfeb17 	ldw	r2,-84(fp)
811018d0:	e0ffe617 	ldw	r3,-104(fp)
811018d4:	1885c83a 	sub	r2,r3,r2
811018d8:	e0bff215 	stw	r2,-56(fp)
		if (iNAccessLen > iNRemainedLen) {
811018dc:	e0bfe817 	ldw	r2,-96(fp)
811018e0:	e0fff217 	ldw	r3,-56(fp)
811018e4:	1880060e 	bge	r3,r2,81101900 <bDdr2MemoryWriteTest+0x37c>
			iNAccessLen = iNRemainedLen;
811018e8:	e0bff217 	ldw	r2,-56(fp)
811018ec:	e0bfe815 	stw	r2,-96(fp)
			iNItemNum = iNAccessLen / ciMyDataSize;
811018f0:	e0ffe817 	ldw	r3,-96(fp)
811018f4:	e0bfee17 	ldw	r2,-72(fp)
811018f8:	1885283a 	div	r2,r3,r2
811018fc:	e0bfea15 	stw	r2,-88(fp)
		}
		memcpy(pxDes, xSZData, iNAccessLen);
81101900:	e0bfe817 	ldw	r2,-96(fp)
81101904:	100d883a 	mov	r6,r2
81101908:	01604574 	movhi	r5,33045
8110190c:	294e5c04 	addi	r5,r5,14704
81101910:	e13fe917 	ldw	r4,-92(fp)
81101914:	11226900 	call	81122690 <memcpy>
		pxDes += iNItemNum;
81101918:	e0bfea17 	ldw	r2,-88(fp)
8110191c:	1085883a 	add	r2,r2,r2
81101920:	1085883a 	add	r2,r2,r2
81101924:	1007883a 	mov	r3,r2
81101928:	e0bfe917 	ldw	r2,-92(fp)
8110192c:	10c5883a 	add	r2,r2,r3
81101930:	e0bfe915 	stw	r2,-92(fp)
		iNPos += iNAccessLen;
81101934:	e0ffeb17 	ldw	r3,-84(fp)
81101938:	e0bfe817 	ldw	r2,-96(fp)
8110193c:	1885883a 	add	r2,r3,r2
81101940:	e0bfeb15 	stw	r2,-84(fp)
		if (iNProgressIndex <= 9 && iNPos >= uliSZProgress[iNProgressIndex]) {
81101944:	e0bfec17 	ldw	r2,-80(fp)
81101948:	10800288 	cmpgei	r2,r2,10
8110194c:	1000191e 	bne	r2,zero,811019b4 <bDdr2MemoryWriteTest+0x430>
81101950:	e0bfec17 	ldw	r2,-80(fp)
81101954:	1085883a 	add	r2,r2,r2
81101958:	1085883a 	add	r2,r2,r2
8110195c:	e0ffe504 	addi	r3,fp,-108
81101960:	1885883a 	add	r2,r3,r2
81101964:	10800e04 	addi	r2,r2,56
81101968:	10800017 	ldw	r2,0(r2)
8110196c:	e0ffeb17 	ldw	r3,-84(fp)
81101970:	18801036 	bltu	r3,r2,811019b4 <bDdr2MemoryWriteTest+0x430>
			iNProgressIndex++;
81101974:	e0bfec17 	ldw	r2,-80(fp)
81101978:	10800044 	addi	r2,r2,1
8110197c:	e0bfec15 	stw	r2,-80(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
81101980:	e0bfec17 	ldw	r2,-80(fp)
81101984:	108002a4 	muli	r2,r2,10
81101988:	100d883a 	mov	r6,r2
8110198c:	01604574 	movhi	r5,33045
81101990:	296f5104 	addi	r5,r5,-17084
81101994:	01204574 	movhi	r4,33045
81101998:	210e1c04 	addi	r4,r4,14448
8110199c:	1122f700 	call	81122f70 <sprintf>
			debug(fp, cDebugBuffer);
811019a0:	d0a06217 	ldw	r2,-32376(gp)
811019a4:	01604574 	movhi	r5,33045
811019a8:	294e1c04 	addi	r5,r5,14448
811019ac:	1009883a 	mov	r4,r2
811019b0:	11215e00 	call	811215e0 <fprintf>
	iTimeStart = alt_nticks();
	pxDes = (TMyData *) uliDdr2Base;
	iNAccessLen = sizeof(xSZData);
	iNItemNum = iNAccessLen / ciMyDataSize;
	iNPos = 0;
	while (iNPos < uliByteLen) {
811019b4:	e0ffeb17 	ldw	r3,-84(fp)
811019b8:	e0bfe617 	ldw	r2,-104(fp)
811019bc:	18bfc336 	bltu	r3,r2,811018cc <__reset+0xfb0e18cc>
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
			debug(fp, cDebugBuffer);
#endif
		}
	}
	alt_dcache_flush_all();
811019c0:	11364ec0 	call	811364ec <alt_dcache_flush_all>
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811019c4:	00a04574 	movhi	r2,33045
811019c8:	108e1c04 	addi	r2,r2,14448
811019cc:	00c00284 	movi	r3,10
811019d0:	10c00005 	stb	r3,0(r2)
811019d4:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811019d8:	d0a06217 	ldw	r2,-32376(gp)
811019dc:	01604574 	movhi	r5,33045
811019e0:	294e1c04 	addi	r5,r5,14448
811019e4:	1009883a 	mov	r4,r2
811019e8:	11215e00 	call	811215e0 <fprintf>
811019ec:	d0e08917 	ldw	r3,-32220(gp)
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
811019f0:	e0bff117 	ldw	r2,-60(fp)
811019f4:	1885c83a 	sub	r2,r3,r2
811019f8:	e0bfef15 	stw	r2,-68(fp)
	if (bSuccess) {
811019fc:	e0bfed17 	ldw	r2,-76(fp)
81101a00:	10001e26 	beq	r2,zero,81101a7c <bDdr2MemoryWriteTest+0x4f8>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
				"DDR2 write test pass, size=%lu bytes, %.3f sec\n", uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
81101a04:	e13fef17 	ldw	r4,-68(fp)
81101a08:	111fcc00 	call	8111fcc0 <__floatsisf>
81101a0c:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81101a10:	d0a08817 	ldw	r2,-32224(gp)
81101a14:	1009883a 	mov	r4,r2
81101a18:	111fdec0 	call	8111fdec <__floatunsisf>
81101a1c:	1007883a 	mov	r3,r2
81101a20:	180b883a 	mov	r5,r3
81101a24:	8009883a 	mov	r4,r16
81101a28:	111f4740 	call	8111f474 <__divsf3>
81101a2c:	1007883a 	mov	r3,r2
81101a30:	1805883a 	mov	r2,r3
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
	if (bSuccess) {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101a34:	1009883a 	mov	r4,r2
81101a38:	11211480 	call	81121148 <__extendsfdf2>
81101a3c:	1009883a 	mov	r4,r2
81101a40:	180b883a 	mov	r5,r3
81101a44:	d9400015 	stw	r5,0(sp)
81101a48:	200f883a 	mov	r7,r4
81101a4c:	e1bfe617 	ldw	r6,-104(fp)
81101a50:	01604574 	movhi	r5,33045
81101a54:	296f5304 	addi	r5,r5,-17076
81101a58:	01204574 	movhi	r4,33045
81101a5c:	210e1c04 	addi	r4,r4,14448
81101a60:	1122f700 	call	81122f70 <sprintf>
				"DDR2 write test pass, size=%lu bytes, %.3f sec\n", uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
		debug(fp, cDebugBuffer);
81101a64:	d0a06217 	ldw	r2,-32376(gp)
81101a68:	01604574 	movhi	r5,33045
81101a6c:	294e1c04 	addi	r5,r5,14448
81101a70:	1009883a 	mov	r4,r2
81101a74:	11215e00 	call	811215e0 <fprintf>
81101a78:	00000f06 	br	81101ab8 <bDdr2MemoryWriteTest+0x534>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 write test fail\n");
81101a7c:	00e04574 	movhi	r3,33045
81101a80:	18ce1c04 	addi	r3,r3,14448
81101a84:	00a04574 	movhi	r2,33045
81101a88:	10af5f04 	addi	r2,r2,-17028
81101a8c:	1009883a 	mov	r4,r2
81101a90:	00800584 	movi	r2,22
81101a94:	100d883a 	mov	r6,r2
81101a98:	200b883a 	mov	r5,r4
81101a9c:	1809883a 	mov	r4,r3
81101aa0:	11226900 	call	81122690 <memcpy>
		debug(fp, cDebugBuffer);
81101aa4:	d0a06217 	ldw	r2,-32376(gp)
81101aa8:	01604574 	movhi	r5,33045
81101aac:	294e1c04 	addi	r5,r5,14448
81101ab0:	1009883a 	mov	r4,r2
81101ab4:	11215e00 	call	811215e0 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101ab8:	00a04574 	movhi	r2,33045
81101abc:	108e1c04 	addi	r2,r2,14448
81101ac0:	00c00284 	movi	r3,10
81101ac4:	10c00005 	stb	r3,0(r2)
81101ac8:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101acc:	d0a06217 	ldw	r2,-32376(gp)
81101ad0:	01604574 	movhi	r5,33045
81101ad4:	294e1c04 	addi	r5,r5,14448
81101ad8:	1009883a 	mov	r4,r2
81101adc:	11215e00 	call	811215e0 <fprintf>
#endif

	return bSuccess;
81101ae0:	e0bfed17 	ldw	r2,-76(fp)
}
81101ae4:	e6fffe04 	addi	sp,fp,-8
81101ae8:	dfc00317 	ldw	ra,12(sp)
81101aec:	df000217 	ldw	fp,8(sp)
81101af0:	dc400117 	ldw	r17,4(sp)
81101af4:	dc000017 	ldw	r16,0(sp)
81101af8:	dec00404 	addi	sp,sp,16
81101afc:	f800283a 	ret

81101b00 <bDdr2MemoryReadTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryReadTest(alt_u8 ucMemoryId) {
81101b00:	deffe204 	addi	sp,sp,-120
81101b04:	de00012e 	bgeu	sp,et,81101b0c <bDdr2MemoryReadTest+0xc>
81101b08:	003b68fa 	trap	3
81101b0c:	dfc01d15 	stw	ra,116(sp)
81101b10:	df001c15 	stw	fp,112(sp)
81101b14:	dc401b15 	stw	r17,108(sp)
81101b18:	dc001a15 	stw	r16,104(sp)
81101b1c:	df001c04 	addi	fp,sp,112
81101b20:	2005883a 	mov	r2,r4
81101b24:	e0bffd05 	stb	r2,-12(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Read Test =====\n");
81101b28:	00e04574 	movhi	r3,33045
81101b2c:	18ce1c04 	addi	r3,r3,14448
81101b30:	00a04574 	movhi	r2,33045
81101b34:	10af6504 	addi	r2,r2,-17004
81101b38:	1009883a 	mov	r4,r2
81101b3c:	008009c4 	movi	r2,39
81101b40:	100d883a 	mov	r6,r2
81101b44:	200b883a 	mov	r5,r4
81101b48:	1809883a 	mov	r4,r3
81101b4c:	11226900 	call	81122690 <memcpy>
	debug(fp, cDebugBuffer);
81101b50:	d0a06217 	ldw	r2,-32376(gp)
81101b54:	01604574 	movhi	r5,33045
81101b58:	294e1c04 	addi	r5,r5,14448
81101b5c:	1009883a 	mov	r4,r2
81101b60:	11215e00 	call	811215e0 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
81101b64:	00800044 	movi	r2,1
81101b68:	e0bfe515 	stw	r2,-108(fp)
	switch (ucMemoryId) {
81101b6c:	e0bffd03 	ldbu	r2,-12(fp)
81101b70:	10000326 	beq	r2,zero,81101b80 <bDdr2MemoryReadTest+0x80>
81101b74:	10800060 	cmpeqi	r2,r2,1
81101b78:	1000081e 	bne	r2,zero,81101b9c <bDdr2MemoryReadTest+0x9c>
81101b7c:	00000e06 	br	81101bb8 <bDdr2MemoryReadTest+0xb8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101b80:	e0bffd03 	ldbu	r2,-12(fp)
81101b84:	1009883a 	mov	r4,r2
81101b88:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101b8c:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81101b90:	00a00034 	movhi	r2,32768
81101b94:	e0bfe715 	stw	r2,-100(fp)
		break;
81101b98:	00001906 	br	81101c00 <bDdr2MemoryReadTest+0x100>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101b9c:	e0bffd03 	ldbu	r2,-12(fp)
81101ba0:	1009883a 	mov	r4,r2
81101ba4:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101ba8:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81101bac:	00a00034 	movhi	r2,32768
81101bb0:	e0bfe715 	stw	r2,-100(fp)
		break;
81101bb4:	00001206 	br	81101c00 <bDdr2MemoryReadTest+0x100>
	default:
		bSuccess = FALSE;
81101bb8:	e03fe515 	stw	zero,-108(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101bbc:	00e04574 	movhi	r3,33045
81101bc0:	18ce1c04 	addi	r3,r3,14448
81101bc4:	00a04574 	movhi	r2,33045
81101bc8:	10ad4d04 	addi	r2,r2,-19148
81101bcc:	1009883a 	mov	r4,r2
81101bd0:	00800bc4 	movi	r2,47
81101bd4:	100d883a 	mov	r6,r2
81101bd8:	200b883a 	mov	r5,r4
81101bdc:	1809883a 	mov	r4,r3
81101be0:	11226900 	call	81122690 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81101be4:	d0a06217 	ldw	r2,-32376(gp)
81101be8:	01604574 	movhi	r5,33045
81101bec:	294e1c04 	addi	r5,r5,14448
81101bf0:	1009883a 	mov	r4,r2
81101bf4:	11215e00 	call	811215e0 <fprintf>
		;
#endif
		return bSuccess;
81101bf8:	e0bfe517 	ldw	r2,-108(fp)
81101bfc:	0000fc06 	br	81101ff0 <bDdr2MemoryReadTest+0x4f0>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %lu MBytes\n", uliByteLen / 1024 / 1024);
81101c00:	e0bfe717 	ldw	r2,-100(fp)
81101c04:	1004d53a 	srli	r2,r2,20
81101c08:	100d883a 	mov	r6,r2
81101c0c:	01604574 	movhi	r5,33045
81101c10:	296f6f04 	addi	r5,r5,-16964
81101c14:	01204574 	movhi	r4,33045
81101c18:	210e1c04 	addi	r4,r4,14448
81101c1c:	1122f700 	call	81122f70 <sprintf>
	debug(fp, cDebugBuffer);
81101c20:	d0a06217 	ldw	r2,-32376(gp)
81101c24:	01604574 	movhi	r5,33045
81101c28:	294e1c04 	addi	r5,r5,14448
81101c2c:	1009883a 	mov	r4,r2
81101c30:	11215e00 	call	811215e0 <fprintf>
#endif

	int iI, iNRemainedLen, iNAccessLen;
	TMyData *pxDes, *pxSrc;
	int iNItemNum, iNPos;
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
81101c34:	00804004 	movi	r2,256
81101c38:	e0bfec15 	stw	r2,-80(fp)
	const int ciMyDataSize = sizeof(TMyData);
81101c3c:	00800104 	movi	r2,4
81101c40:	e0bfef15 	stw	r2,-68(fp)
	iNAccessLen = iNItemNum * ciMyDataSize;
81101c44:	e0ffec17 	ldw	r3,-80(fp)
81101c48:	e0bfef17 	ldw	r2,-68(fp)
81101c4c:	1885383a 	mul	r2,r3,r2
81101c50:	e0bfe915 	stw	r2,-92(fp)
	int iNProgressIndex = 0;
81101c54:	e03fee15 	stw	zero,-72(fp)
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;
81101c58:	e03ff015 	stw	zero,-64(fp)

	for (iI = 0; iI < 10; iI++) {
81101c5c:	e03fe815 	stw	zero,-96(fp)
81101c60:	00001506 	br	81101cb8 <bDdr2MemoryReadTest+0x1b8>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
81101c64:	e0ffe717 	ldw	r3,-100(fp)
81101c68:	00b33374 	movhi	r2,52429
81101c6c:	10b33344 	addi	r2,r2,-13107
81101c70:	1888383a 	mulxuu	r4,r3,r2
81101c74:	1885383a 	mul	r2,r3,r2
81101c78:	1021883a 	mov	r16,r2
81101c7c:	2023883a 	mov	r17,r4
81101c80:	8804d0fa 	srli	r2,r17,3
81101c84:	e0ffe817 	ldw	r3,-96(fp)
81101c88:	18c00044 	addi	r3,r3,1
81101c8c:	10c7383a 	mul	r3,r2,r3
81101c90:	e0bfe817 	ldw	r2,-96(fp)
81101c94:	1085883a 	add	r2,r2,r2
81101c98:	1085883a 	add	r2,r2,r2
81101c9c:	e13fe504 	addi	r4,fp,-108
81101ca0:	2085883a 	add	r2,r4,r2
81101ca4:	10800e04 	addi	r2,r2,56
81101ca8:	10c00015 	stw	r3,0(r2)
	iNAccessLen = iNItemNum * ciMyDataSize;
	int iNProgressIndex = 0;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;

	for (iI = 0; iI < 10; iI++) {
81101cac:	e0bfe817 	ldw	r2,-96(fp)
81101cb0:	10800044 	addi	r2,r2,1
81101cb4:	e0bfe815 	stw	r2,-96(fp)
81101cb8:	e0bfe817 	ldw	r2,-96(fp)
81101cbc:	10800290 	cmplti	r2,r2,10
81101cc0:	103fe81e 	bne	r2,zero,81101c64 <__reset+0xfb0e1c64>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}

	iNProgressIndex = 0;
81101cc4:	e03fee15 	stw	zero,-72(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Reading/Verifying Data...\n");
81101cc8:	00e04574 	movhi	r3,33045
81101ccc:	18ce1c04 	addi	r3,r3,14448
81101cd0:	00a04574 	movhi	r2,33045
81101cd4:	10af7504 	addi	r2,r2,-16940
81101cd8:	1009883a 	mov	r4,r2
81101cdc:	008006c4 	movi	r2,27
81101ce0:	100d883a 	mov	r6,r2
81101ce4:	200b883a 	mov	r5,r4
81101ce8:	1809883a 	mov	r4,r3
81101cec:	11226900 	call	81122690 <memcpy>
	debug(fp, cDebugBuffer);
81101cf0:	d0a06217 	ldw	r2,-32376(gp)
81101cf4:	01604574 	movhi	r5,33045
81101cf8:	294e1c04 	addi	r5,r5,14448
81101cfc:	1009883a 	mov	r4,r2
81101d00:	11215e00 	call	811215e0 <fprintf>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81101d04:	d0a08917 	ldw	r2,-32220(gp)
#endif
	iTimeStart = alt_nticks();
81101d08:	e0bff115 	stw	r2,-60(fp)

	pxSrc = (TMyData *) uliDdr2Base;
81101d0c:	e0bfe617 	ldw	r2,-104(fp)
81101d10:	e0bfeb15 	stw	r2,-84(fp)
	iNAccessLen = sizeof(xSZData);
81101d14:	00810004 	movi	r2,1024
81101d18:	e0bfe915 	stw	r2,-92(fp)
	iNItemNum = iNAccessLen / ciMyDataSize;
81101d1c:	e0ffe917 	ldw	r3,-92(fp)
81101d20:	e0bfef17 	ldw	r2,-68(fp)
81101d24:	1885283a 	div	r2,r3,r2
81101d28:	e0bfec15 	stw	r2,-80(fp)
	iNPos = 0;
81101d2c:	e03fed15 	stw	zero,-76(fp)
	while (bSuccess && iNPos < uliByteLen) {
81101d30:	00006206 	br	81101ebc <bDdr2MemoryReadTest+0x3bc>
		iNRemainedLen = uliByteLen - iNPos;
81101d34:	e0bfed17 	ldw	r2,-76(fp)
81101d38:	e0ffe717 	ldw	r3,-100(fp)
81101d3c:	1885c83a 	sub	r2,r3,r2
81101d40:	e0bff215 	stw	r2,-56(fp)
		if (iNAccessLen > iNRemainedLen) {
81101d44:	e0bfe917 	ldw	r2,-92(fp)
81101d48:	e0fff217 	ldw	r3,-56(fp)
81101d4c:	1880060e 	bge	r3,r2,81101d68 <bDdr2MemoryReadTest+0x268>
			iNAccessLen = iNRemainedLen;
81101d50:	e0bff217 	ldw	r2,-56(fp)
81101d54:	e0bfe915 	stw	r2,-92(fp)
			iNItemNum = iNAccessLen / ciMyDataSize;
81101d58:	e0ffe917 	ldw	r3,-92(fp)
81101d5c:	e0bfef17 	ldw	r2,-68(fp)
81101d60:	1885283a 	div	r2,r3,r2
81101d64:	e0bfec15 	stw	r2,-80(fp)
		}
		pxDes = xSZData;
81101d68:	00a04574 	movhi	r2,33045
81101d6c:	108e5c04 	addi	r2,r2,14704
81101d70:	e0bfea15 	stw	r2,-88(fp)
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
81101d74:	e03fe815 	stw	zero,-96(fp)
81101d78:	00002b06 	br	81101e28 <bDdr2MemoryReadTest+0x328>
			if (*pxSrc++ != *pxDes++) {
81101d7c:	e0bfeb17 	ldw	r2,-84(fp)
81101d80:	10c00104 	addi	r3,r2,4
81101d84:	e0ffeb15 	stw	r3,-84(fp)
81101d88:	10c00017 	ldw	r3,0(r2)
81101d8c:	e0bfea17 	ldw	r2,-88(fp)
81101d90:	11000104 	addi	r4,r2,4
81101d94:	e13fea15 	stw	r4,-88(fp)
81101d98:	10800017 	ldw	r2,0(r2)
81101d9c:	18801f26 	beq	r3,r2,81101e1c <bDdr2MemoryReadTest+0x31c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
81101da0:	e0bfeb17 	ldw	r2,-84(fp)
81101da4:	10bfff04 	addi	r2,r2,-4
81101da8:	10800017 	ldw	r2,0(r2)
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101dac:	1009883a 	mov	r4,r2
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
81101db0:	00a04574 	movhi	r2,33045
81101db4:	108e5c04 	addi	r2,r2,14704
81101db8:	e0ffe817 	ldw	r3,-96(fp)
81101dbc:	18c7883a 	add	r3,r3,r3
81101dc0:	18c7883a 	add	r3,r3,r3
81101dc4:	10c5883a 	add	r2,r2,r3
81101dc8:	10800017 	ldw	r2,0(r2)
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101dcc:	100b883a 	mov	r5,r2
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
						(iNPos / ciMyDataSize) + iI);
81101dd0:	e0ffed17 	ldw	r3,-76(fp)
81101dd4:	e0bfef17 	ldw	r2,-68(fp)
81101dd8:	1887283a 	div	r3,r3,r2
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101ddc:	e0bfe817 	ldw	r2,-96(fp)
81101de0:	1885883a 	add	r2,r3,r2
81101de4:	d8800015 	stw	r2,0(sp)
81101de8:	280f883a 	mov	r7,r5
81101dec:	200d883a 	mov	r6,r4
81101df0:	01604574 	movhi	r5,33045
81101df4:	296f7c04 	addi	r5,r5,-16912
81101df8:	01204574 	movhi	r4,33045
81101dfc:	210e1c04 	addi	r4,r4,14448
81101e00:	1122f700 	call	81122f70 <sprintf>
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
						(iNPos / ciMyDataSize) + iI);
				debug(fp, cDebugBuffer);
81101e04:	d0a06217 	ldw	r2,-32376(gp)
81101e08:	01604574 	movhi	r5,33045
81101e0c:	294e1c04 	addi	r5,r5,14448
81101e10:	1009883a 	mov	r4,r2
81101e14:	11215e00 	call	811215e0 <fprintf>
#endif
				bSuccess = FALSE;
81101e18:	e03fe515 	stw	zero,-108(fp)
		if (iNAccessLen > iNRemainedLen) {
			iNAccessLen = iNRemainedLen;
			iNItemNum = iNAccessLen / ciMyDataSize;
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
81101e1c:	e0bfe817 	ldw	r2,-96(fp)
81101e20:	10800044 	addi	r2,r2,1
81101e24:	e0bfe815 	stw	r2,-96(fp)
81101e28:	e0ffe817 	ldw	r3,-96(fp)
81101e2c:	e0bfec17 	ldw	r2,-80(fp)
81101e30:	1880020e 	bge	r3,r2,81101e3c <bDdr2MemoryReadTest+0x33c>
81101e34:	e0bfe517 	ldw	r2,-108(fp)
81101e38:	103fd01e 	bne	r2,zero,81101d7c <__reset+0xfb0e1d7c>
				debug(fp, cDebugBuffer);
#endif
				bSuccess = FALSE;
			}
		}
		iNPos += iNAccessLen;
81101e3c:	e0ffed17 	ldw	r3,-76(fp)
81101e40:	e0bfe917 	ldw	r2,-92(fp)
81101e44:	1885883a 	add	r2,r3,r2
81101e48:	e0bfed15 	stw	r2,-76(fp)
		if (iNProgressIndex <= 9 && iNPos >= uliSZProgress[iNProgressIndex]) {
81101e4c:	e0bfee17 	ldw	r2,-72(fp)
81101e50:	10800288 	cmpgei	r2,r2,10
81101e54:	1000191e 	bne	r2,zero,81101ebc <bDdr2MemoryReadTest+0x3bc>
81101e58:	e0bfee17 	ldw	r2,-72(fp)
81101e5c:	1085883a 	add	r2,r2,r2
81101e60:	1085883a 	add	r2,r2,r2
81101e64:	e0ffe504 	addi	r3,fp,-108
81101e68:	1885883a 	add	r2,r3,r2
81101e6c:	10800e04 	addi	r2,r2,56
81101e70:	10800017 	ldw	r2,0(r2)
81101e74:	e0ffed17 	ldw	r3,-76(fp)
81101e78:	18801036 	bltu	r3,r2,81101ebc <bDdr2MemoryReadTest+0x3bc>
			iNProgressIndex++;
81101e7c:	e0bfee17 	ldw	r2,-72(fp)
81101e80:	10800044 	addi	r2,r2,1
81101e84:	e0bfee15 	stw	r2,-72(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
81101e88:	e0bfee17 	ldw	r2,-72(fp)
81101e8c:	108002a4 	muli	r2,r2,10
81101e90:	100d883a 	mov	r6,r2
81101e94:	01604574 	movhi	r5,33045
81101e98:	296f5104 	addi	r5,r5,-17084
81101e9c:	01204574 	movhi	r4,33045
81101ea0:	210e1c04 	addi	r4,r4,14448
81101ea4:	1122f700 	call	81122f70 <sprintf>
			debug(fp, cDebugBuffer);
81101ea8:	d0a06217 	ldw	r2,-32376(gp)
81101eac:	01604574 	movhi	r5,33045
81101eb0:	294e1c04 	addi	r5,r5,14448
81101eb4:	1009883a 	mov	r4,r2
81101eb8:	11215e00 	call	811215e0 <fprintf>

	pxSrc = (TMyData *) uliDdr2Base;
	iNAccessLen = sizeof(xSZData);
	iNItemNum = iNAccessLen / ciMyDataSize;
	iNPos = 0;
	while (bSuccess && iNPos < uliByteLen) {
81101ebc:	e0bfe517 	ldw	r2,-108(fp)
81101ec0:	10000326 	beq	r2,zero,81101ed0 <bDdr2MemoryReadTest+0x3d0>
81101ec4:	e0ffed17 	ldw	r3,-76(fp)
81101ec8:	e0bfe717 	ldw	r2,-100(fp)
81101ecc:	18bf9936 	bltu	r3,r2,81101d34 <__reset+0xfb0e1d34>
			debug(fp, cDebugBuffer);
#endif
		}
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101ed0:	00a04574 	movhi	r2,33045
81101ed4:	108e1c04 	addi	r2,r2,14448
81101ed8:	00c00284 	movi	r3,10
81101edc:	10c00005 	stb	r3,0(r2)
81101ee0:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101ee4:	d0a06217 	ldw	r2,-32376(gp)
81101ee8:	01604574 	movhi	r5,33045
81101eec:	294e1c04 	addi	r5,r5,14448
81101ef0:	1009883a 	mov	r4,r2
81101ef4:	11215e00 	call	811215e0 <fprintf>
81101ef8:	d0e08917 	ldw	r3,-32220(gp)
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
81101efc:	e0bff117 	ldw	r2,-60(fp)
81101f00:	1885c83a 	sub	r2,r3,r2
81101f04:	e0bff015 	stw	r2,-64(fp)
	if (bSuccess) {
81101f08:	e0bfe517 	ldw	r2,-108(fp)
81101f0c:	10001e26 	beq	r2,zero,81101f88 <bDdr2MemoryReadTest+0x488>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test pass, size=%ld bytes, %.3f sec\n",
				uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
81101f10:	e13ff017 	ldw	r4,-64(fp)
81101f14:	111fcc00 	call	8111fcc0 <__floatsisf>
81101f18:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81101f1c:	d0a08817 	ldw	r2,-32224(gp)
81101f20:	1009883a 	mov	r4,r2
81101f24:	111fdec0 	call	8111fdec <__floatunsisf>
81101f28:	1007883a 	mov	r3,r2
81101f2c:	180b883a 	mov	r5,r3
81101f30:	8009883a 	mov	r4,r16
81101f34:	111f4740 	call	8111f474 <__divsf3>
81101f38:	1007883a 	mov	r3,r2
81101f3c:	1805883a 	mov	r2,r3
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
	if (bSuccess) {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test pass, size=%ld bytes, %.3f sec\n",
81101f40:	1009883a 	mov	r4,r2
81101f44:	11211480 	call	81121148 <__extendsfdf2>
81101f48:	1009883a 	mov	r4,r2
81101f4c:	180b883a 	mov	r5,r3
81101f50:	d9400015 	stw	r5,0(sp)
81101f54:	200f883a 	mov	r7,r4
81101f58:	e1bfe717 	ldw	r6,-100(fp)
81101f5c:	01604574 	movhi	r5,33045
81101f60:	296f8a04 	addi	r5,r5,-16856
81101f64:	01204574 	movhi	r4,33045
81101f68:	210e1c04 	addi	r4,r4,14448
81101f6c:	1122f700 	call	81122f70 <sprintf>
				uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
		debug(fp, cDebugBuffer);
81101f70:	d0a06217 	ldw	r2,-32376(gp)
81101f74:	01604574 	movhi	r5,33045
81101f78:	294e1c04 	addi	r5,r5,14448
81101f7c:	1009883a 	mov	r4,r2
81101f80:	11215e00 	call	811215e0 <fprintf>
81101f84:	00000f06 	br	81101fc4 <bDdr2MemoryReadTest+0x4c4>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test fail\n");
81101f88:	00e04574 	movhi	r3,33045
81101f8c:	18ce1c04 	addi	r3,r3,14448
81101f90:	00a04574 	movhi	r2,33045
81101f94:	10af9604 	addi	r2,r2,-16808
81101f98:	1009883a 	mov	r4,r2
81101f9c:	00800544 	movi	r2,21
81101fa0:	100d883a 	mov	r6,r2
81101fa4:	200b883a 	mov	r5,r4
81101fa8:	1809883a 	mov	r4,r3
81101fac:	11226900 	call	81122690 <memcpy>
		debug(fp, cDebugBuffer);
81101fb0:	d0a06217 	ldw	r2,-32376(gp)
81101fb4:	01604574 	movhi	r5,33045
81101fb8:	294e1c04 	addi	r5,r5,14448
81101fbc:	1009883a 	mov	r4,r2
81101fc0:	11215e00 	call	811215e0 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101fc4:	00a04574 	movhi	r2,33045
81101fc8:	108e1c04 	addi	r2,r2,14448
81101fcc:	00c00284 	movi	r3,10
81101fd0:	10c00005 	stb	r3,0(r2)
81101fd4:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101fd8:	d0a06217 	ldw	r2,-32376(gp)
81101fdc:	01604574 	movhi	r5,33045
81101fe0:	294e1c04 	addi	r5,r5,14448
81101fe4:	1009883a 	mov	r4,r2
81101fe8:	11215e00 	call	811215e0 <fprintf>
#endif

	return bSuccess;
81101fec:	e0bfe517 	ldw	r2,-108(fp)
}
81101ff0:	e6fffe04 	addi	sp,fp,-8
81101ff4:	dfc00317 	ldw	ra,12(sp)
81101ff8:	df000217 	ldw	fp,8(sp)
81101ffc:	dc400117 	ldw	r17,4(sp)
81102000:	dc000017 	ldw	r16,0(sp)
81102004:	dec00404 	addi	sp,sp,16
81102008:	f800283a 	ret

8110200c <bDdr2MemoryRandomWriteTest>:
 * @param [in] bTime  Controla se a durao da funo ser medida
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryRandomWriteTest(alt_u8 ucMemoryId, bool bVerbose, bool bTime) {
8110200c:	deffec04 	addi	sp,sp,-80
81102010:	de00012e 	bgeu	sp,et,81102018 <bDdr2MemoryRandomWriteTest+0xc>
81102014:	003b68fa 	trap	3
81102018:	dfc01315 	stw	ra,76(sp)
8110201c:	df001215 	stw	fp,72(sp)
81102020:	dcc01115 	stw	r19,68(sp)
81102024:	dc801015 	stw	r18,64(sp)
81102028:	dc400f15 	stw	r17,60(sp)
8110202c:	dc000e15 	stw	r16,56(sp)
81102030:	df001204 	addi	fp,sp,72
81102034:	2005883a 	mov	r2,r4
81102038:	e17ffa15 	stw	r5,-24(fp)
8110203c:	e1bffb15 	stw	r6,-20(fp)
81102040:	e0bff905 	stb	r2,-28(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Random Write Test =====\n");
81102044:	00e04574 	movhi	r3,33045
81102048:	18ce1c04 	addi	r3,r3,14448
8110204c:	00a04574 	movhi	r2,33045
81102050:	10af9c04 	addi	r2,r2,-16784
81102054:	1009883a 	mov	r4,r2
81102058:	00800bc4 	movi	r2,47
8110205c:	100d883a 	mov	r6,r2
81102060:	200b883a 	mov	r5,r4
81102064:	1809883a 	mov	r4,r3
81102068:	11226900 	call	81122690 <memcpy>
	debug(fp, cDebugBuffer);
8110206c:	d0a06217 	ldw	r2,-32376(gp)
81102070:	01604574 	movhi	r5,33045
81102074:	294e1c04 	addi	r5,r5,14448
81102078:	1009883a 	mov	r4,r2
8110207c:	11215e00 	call	811215e0 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
81102080:	00800044 	movi	r2,1
81102084:	e0bff415 	stw	r2,-48(fp)
	switch (ucMemoryId) {
81102088:	e0bff903 	ldbu	r2,-28(fp)
8110208c:	10000326 	beq	r2,zero,8110209c <bDdr2MemoryRandomWriteTest+0x90>
81102090:	10800060 	cmpeqi	r2,r2,1
81102094:	1000081e 	bne	r2,zero,811020b8 <bDdr2MemoryRandomWriteTest+0xac>
81102098:	00000e06 	br	811020d4 <bDdr2MemoryRandomWriteTest+0xc8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
8110209c:	e0bff903 	ldbu	r2,-28(fp)
811020a0:	1009883a 	mov	r4,r2
811020a4:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
811020a8:	e03fef15 	stw	zero,-68(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
811020ac:	00a00034 	movhi	r2,32768
811020b0:	e0bff015 	stw	r2,-64(fp)
		break;
811020b4:	00001906 	br	8110211c <bDdr2MemoryRandomWriteTest+0x110>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
811020b8:	e0bff903 	ldbu	r2,-28(fp)
811020bc:	1009883a 	mov	r4,r2
811020c0:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
811020c4:	e03fef15 	stw	zero,-68(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
811020c8:	00a00034 	movhi	r2,32768
811020cc:	e0bff015 	stw	r2,-64(fp)
		break;
811020d0:	00001206 	br	8110211c <bDdr2MemoryRandomWriteTest+0x110>
	default:
		bSuccess = FALSE;
811020d4:	e03ff415 	stw	zero,-48(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811020d8:	00e04574 	movhi	r3,33045
811020dc:	18ce1c04 	addi	r3,r3,14448
811020e0:	00a04574 	movhi	r2,33045
811020e4:	10ad4d04 	addi	r2,r2,-19148
811020e8:	1009883a 	mov	r4,r2
811020ec:	00800bc4 	movi	r2,47
811020f0:	100d883a 	mov	r6,r2
811020f4:	200b883a 	mov	r5,r4
811020f8:	1809883a 	mov	r4,r3
811020fc:	11226900 	call	81122690 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81102100:	d0a06217 	ldw	r2,-32376(gp)
81102104:	01604574 	movhi	r5,33045
81102108:	294e1c04 	addi	r5,r5,14448
8110210c:	1009883a 	mov	r4,r2
81102110:	11215e00 	call	811215e0 <fprintf>
		;
#endif
		return bSuccess;
81102114:	e0bff417 	ldw	r2,-48(fp)
81102118:	0000ce06 	br	81102454 <bDdr2MemoryRandomWriteTest+0x448>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
8110211c:	e0bff017 	ldw	r2,-64(fp)
81102120:	1004d53a 	srli	r2,r2,20
81102124:	100d883a 	mov	r6,r2
81102128:	01604574 	movhi	r5,33045
8110212c:	296f4604 	addi	r5,r5,-17128
81102130:	01204574 	movhi	r4,33045
81102134:	210e1c04 	addi	r4,r4,14448
81102138:	1122f700 	call	81122f70 <sprintf>
	debug(fp, cDebugBuffer);
8110213c:	d0a06217 	ldw	r2,-32376(gp)
81102140:	01604574 	movhi	r5,33045
81102144:	294e1c04 	addi	r5,r5,14448
81102148:	1009883a 	mov	r4,r2
8110214c:	11215e00 	call	811215e0 <fprintf>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81102150:	d0a08917 	ldw	r2,-32220(gp)
	alt_u32 uliCurrentState;
	alt_u32 uliMemoryEndAddress;
	alt_u32 uliNextMilestone;
	alt_u8 ucPercentage;

	uliInitialState = alt_nticks();
81102154:	d0a03715 	stw	r2,-32548(gp)
	uliCurrentState = uliInitialState;
81102158:	d0a03717 	ldw	r2,-32548(gp)
8110215c:	e0bff815 	stw	r2,-32(fp)
	uliMemoryEndAddress = uliDdr2Base + uliByteLen;
81102160:	e0ffef17 	ldw	r3,-68(fp)
81102164:	e0bff017 	ldw	r2,-64(fp)
81102168:	1885883a 	add	r2,r3,r2
8110216c:	e0bff515 	stw	r2,-44(fp)
	uliNextMilestone = uliDdr2Base + uliByteLen / 20;
81102170:	e0fff017 	ldw	r3,-64(fp)
81102174:	00b33374 	movhi	r2,52429
81102178:	10b33344 	addi	r2,r2,-13107
8110217c:	1888383a 	mulxuu	r4,r3,r2
81102180:	1885383a 	mul	r2,r3,r2
81102184:	1025883a 	mov	r18,r2
81102188:	2027883a 	mov	r19,r4
8110218c:	9806d13a 	srli	r3,r19,4
81102190:	e0bfef17 	ldw	r2,-68(fp)
81102194:	1885883a 	add	r2,r3,r2
81102198:	e0bff215 	stw	r2,-56(fp)
	ucPercentage = 5;
8110219c:	00800144 	movi	r2,5
811021a0:	e0bff305 	stb	r2,-52(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Writing to memory...\n");
811021a4:	00e04574 	movhi	r3,33045
811021a8:	18ce1c04 	addi	r3,r3,14448
811021ac:	00a04574 	movhi	r2,33045
811021b0:	10afa804 	addi	r2,r2,-16736
811021b4:	1009883a 	mov	r4,r2
811021b8:	00800584 	movi	r2,22
811021bc:	100d883a 	mov	r6,r2
811021c0:	200b883a 	mov	r5,r4
811021c4:	1809883a 	mov	r4,r3
811021c8:	11226900 	call	81122690 <memcpy>
	debug(fp, cDebugBuffer);
811021cc:	d0a06217 	ldw	r2,-32376(gp)
811021d0:	01604574 	movhi	r5,33045
811021d4:	294e1c04 	addi	r5,r5,14448
811021d8:	1009883a 	mov	r4,r2
811021dc:	11215e00 	call	811215e0 <fprintf>
#endif
	if (bVerbose == DDR2_VERBOSE) {
811021e0:	e0bffa17 	ldw	r2,-24(fp)
811021e4:	10800058 	cmpnei	r2,r2,1
811021e8:	10000a1e 	bne	r2,zero,81102214 <bDdr2MemoryRandomWriteTest+0x208>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "00%%..");
811021ec:	01604574 	movhi	r5,33045
811021f0:	296fae04 	addi	r5,r5,-16712
811021f4:	01204574 	movhi	r4,33045
811021f8:	210e1c04 	addi	r4,r4,14448
811021fc:	1122f700 	call	81122f70 <sprintf>
		debug(fp, cDebugBuffer);
81102200:	d0a06217 	ldw	r2,-32376(gp)
81102204:	01604574 	movhi	r5,33045
81102208:	294e1c04 	addi	r5,r5,14448
8110220c:	1009883a 	mov	r4,r2
81102210:	11215e00 	call	811215e0 <fprintf>
#endif
	}
	int TimeStart, TimeElapsed = 0;
81102214:	e03ff615 	stw	zero,-40(fp)
81102218:	d0a08917 	ldw	r2,-32220(gp)

	TimeStart = alt_nticks();
8110221c:	e0bff715 	stw	r2,-36(fp)
	for (puliDestination = (alt_u32*) uliDdr2Base;
81102220:	e0bfef17 	ldw	r2,-68(fp)
81102224:	e0bff115 	stw	r2,-60(fp)
81102228:	00002c06 	br	811022dc <bDdr2MemoryRandomWriteTest+0x2d0>
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
		*puliDestination = uliXorshift32(&uliCurrentState);
8110222c:	e0bff804 	addi	r2,fp,-32
81102230:	1009883a 	mov	r4,r2
81102234:	11029100 	call	81102910 <uliXorshift32>
81102238:	1007883a 	mov	r3,r2
8110223c:	e0bff117 	ldw	r2,-60(fp)
81102240:	10c00015 	stw	r3,0(r2)
		if ((bVerbose == DDR2_VERBOSE)
				& ((alt_u32) puliDestination > uliNextMilestone)) {
81102244:	e0bffa17 	ldw	r2,-24(fp)
81102248:	10800060 	cmpeqi	r2,r2,1
8110224c:	1009883a 	mov	r4,r2
81102250:	e0bff117 	ldw	r2,-60(fp)
81102254:	e0fff217 	ldw	r3,-56(fp)
81102258:	1885803a 	cmpltu	r2,r3,r2
8110225c:	2084703a 	and	r2,r4,r2
	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
		*puliDestination = uliXorshift32(&uliCurrentState);
		if ((bVerbose == DDR2_VERBOSE)
81102260:	10803fcc 	andi	r2,r2,255
81102264:	10001a26 	beq	r2,zero,811022d0 <bDdr2MemoryRandomWriteTest+0x2c4>
				& ((alt_u32) puliDestination > uliNextMilestone)) {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "..%02d%%..", ucPercentage);
81102268:	e0bff303 	ldbu	r2,-52(fp)
8110226c:	100d883a 	mov	r6,r2
81102270:	01604574 	movhi	r5,33045
81102274:	296fb004 	addi	r5,r5,-16704
81102278:	01204574 	movhi	r4,33045
8110227c:	210e1c04 	addi	r4,r4,14448
81102280:	1122f700 	call	81122f70 <sprintf>
			debug(fp, cDebugBuffer);
81102284:	d0a06217 	ldw	r2,-32376(gp)
81102288:	01604574 	movhi	r5,33045
8110228c:	294e1c04 	addi	r5,r5,14448
81102290:	1009883a 	mov	r4,r2
81102294:	11215e00 	call	811215e0 <fprintf>
#endif
			uliNextMilestone += uliByteLen / 20;
81102298:	e0fff017 	ldw	r3,-64(fp)
8110229c:	00b33374 	movhi	r2,52429
811022a0:	10b33344 	addi	r2,r2,-13107
811022a4:	1888383a 	mulxuu	r4,r3,r2
811022a8:	1885383a 	mul	r2,r3,r2
811022ac:	1021883a 	mov	r16,r2
811022b0:	2023883a 	mov	r17,r4
811022b4:	8804d13a 	srli	r2,r17,4
811022b8:	e0fff217 	ldw	r3,-56(fp)
811022bc:	1885883a 	add	r2,r3,r2
811022c0:	e0bff215 	stw	r2,-56(fp)
			ucPercentage += 5;
811022c4:	e0bff303 	ldbu	r2,-52(fp)
811022c8:	10800144 	addi	r2,r2,5
811022cc:	e0bff305 	stb	r2,-52(fp)
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
811022d0:	e0bff117 	ldw	r2,-60(fp)
811022d4:	10800104 	addi	r2,r2,4
811022d8:	e0bff115 	stw	r2,-60(fp)
	}
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
811022dc:	e0fff117 	ldw	r3,-60(fp)
#endif
	}
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
811022e0:	e0bff517 	ldw	r2,-44(fp)
811022e4:	18bfd136 	bltu	r3,r2,8110222c <__reset+0xfb0e222c>
#endif
			uliNextMilestone += uliByteLen / 20;
			ucPercentage += 5;
		}
	}
	alt_dcache_flush_all();
811022e8:	11364ec0 	call	811364ec <alt_dcache_flush_all>
	if (bVerbose == DDR2_VERBOSE) {
811022ec:	e0bffa17 	ldw	r2,-24(fp)
811022f0:	10800058 	cmpnei	r2,r2,1
811022f4:	10000a1e 	bne	r2,zero,81102320 <bDdr2MemoryRandomWriteTest+0x314>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "..100%%\n");
811022f8:	01604574 	movhi	r5,33045
811022fc:	296fb304 	addi	r5,r5,-16692
81102300:	01204574 	movhi	r4,33045
81102304:	210e1c04 	addi	r4,r4,14448
81102308:	1122f700 	call	81122f70 <sprintf>
		debug(fp, cDebugBuffer);
8110230c:	d0a06217 	ldw	r2,-32376(gp)
81102310:	01604574 	movhi	r5,33045
81102314:	294e1c04 	addi	r5,r5,14448
81102318:	1009883a 	mov	r4,r2
8110231c:	11215e00 	call	811215e0 <fprintf>
#endif
	}

	if (bSuccess) {
81102320:	e0bff417 	ldw	r2,-48(fp)
81102324:	10003126 	beq	r2,zero,811023ec <bDdr2MemoryRandomWriteTest+0x3e0>
		if (bTime == TRUE) {
81102328:	e0bffb17 	ldw	r2,-20(fp)
8110232c:	10800058 	cmpnei	r2,r2,1
81102330:	1000221e 	bne	r2,zero,811023bc <bDdr2MemoryRandomWriteTest+0x3b0>
81102334:	d0e08917 	ldw	r3,-32220(gp)
			TimeElapsed = alt_nticks() - TimeStart;
81102338:	e0bff717 	ldw	r2,-36(fp)
8110233c:	1885c83a 	sub	r2,r3,r2
81102340:	e0bff615 	stw	r2,-40(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
					"DDR2 write test pass, size=%ld bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
81102344:	e13ff617 	ldw	r4,-40(fp)
81102348:	111fcc00 	call	8111fcc0 <__floatsisf>
8110234c:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81102350:	d0a08817 	ldw	r2,-32224(gp)
81102354:	1009883a 	mov	r4,r2
81102358:	111fdec0 	call	8111fdec <__floatunsisf>
8110235c:	1007883a 	mov	r3,r2
81102360:	180b883a 	mov	r5,r3
81102364:	8009883a 	mov	r4,r16
81102368:	111f4740 	call	8111f474 <__divsf3>
8110236c:	1007883a 	mov	r3,r2
81102370:	1805883a 	mov	r2,r3

	if (bSuccess) {
		if (bTime == TRUE) {
			TimeElapsed = alt_nticks() - TimeStart;
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
81102374:	1009883a 	mov	r4,r2
81102378:	11211480 	call	81121148 <__extendsfdf2>
8110237c:	1009883a 	mov	r4,r2
81102380:	180b883a 	mov	r5,r3
81102384:	d9400015 	stw	r5,0(sp)
81102388:	200f883a 	mov	r7,r4
8110238c:	e1bff017 	ldw	r6,-64(fp)
81102390:	01604574 	movhi	r5,33045
81102394:	296fb604 	addi	r5,r5,-16680
81102398:	01204574 	movhi	r4,33045
8110239c:	210e1c04 	addi	r4,r4,14448
811023a0:	1122f700 	call	81122f70 <sprintf>
					"DDR2 write test pass, size=%ld bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
			debug(fp, cDebugBuffer);
811023a4:	d0a06217 	ldw	r2,-32376(gp)
811023a8:	01604574 	movhi	r5,33045
811023ac:	294e1c04 	addi	r5,r5,14448
811023b0:	1009883a 	mov	r4,r2
811023b4:	11215e00 	call	811215e0 <fprintf>
811023b8:	00001b06 	br	81102428 <bDdr2MemoryRandomWriteTest+0x41c>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "DDR2 write test pass, size=%ld bytes\n",
811023bc:	e1bff017 	ldw	r6,-64(fp)
811023c0:	01604574 	movhi	r5,33045
811023c4:	296fc204 	addi	r5,r5,-16632
811023c8:	01204574 	movhi	r4,33045
811023cc:	210e1c04 	addi	r4,r4,14448
811023d0:	1122f700 	call	81122f70 <sprintf>
					uliByteLen);
			debug(fp, cDebugBuffer);
811023d4:	d0a06217 	ldw	r2,-32376(gp)
811023d8:	01604574 	movhi	r5,33045
811023dc:	294e1c04 	addi	r5,r5,14448
811023e0:	1009883a 	mov	r4,r2
811023e4:	11215e00 	call	811215e0 <fprintf>
811023e8:	00000f06 	br	81102428 <bDdr2MemoryRandomWriteTest+0x41c>
#endif
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 write test fail\n");
811023ec:	00e04574 	movhi	r3,33045
811023f0:	18ce1c04 	addi	r3,r3,14448
811023f4:	00a04574 	movhi	r2,33045
811023f8:	10af5f04 	addi	r2,r2,-17028
811023fc:	1009883a 	mov	r4,r2
81102400:	00800584 	movi	r2,22
81102404:	100d883a 	mov	r6,r2
81102408:	200b883a 	mov	r5,r4
8110240c:	1809883a 	mov	r4,r3
81102410:	11226900 	call	81122690 <memcpy>
		debug(fp, cDebugBuffer);
81102414:	d0a06217 	ldw	r2,-32376(gp)
81102418:	01604574 	movhi	r5,33045
8110241c:	294e1c04 	addi	r5,r5,14448
81102420:	1009883a 	mov	r4,r2
81102424:	11215e00 	call	811215e0 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81102428:	00a04574 	movhi	r2,33045
8110242c:	108e1c04 	addi	r2,r2,14448
81102430:	00c00284 	movi	r3,10
81102434:	10c00005 	stb	r3,0(r2)
81102438:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
8110243c:	d0a06217 	ldw	r2,-32376(gp)
81102440:	01604574 	movhi	r5,33045
81102444:	294e1c04 	addi	r5,r5,14448
81102448:	1009883a 	mov	r4,r2
8110244c:	11215e00 	call	811215e0 <fprintf>
#endif

	return bSuccess;
81102450:	e0bff417 	ldw	r2,-48(fp)
}
81102454:	e6fffc04 	addi	sp,fp,-16
81102458:	dfc00517 	ldw	ra,20(sp)
8110245c:	df000417 	ldw	fp,16(sp)
81102460:	dcc00317 	ldw	r19,12(sp)
81102464:	dc800217 	ldw	r18,8(sp)
81102468:	dc400117 	ldw	r17,4(sp)
8110246c:	dc000017 	ldw	r16,0(sp)
81102470:	dec00604 	addi	sp,sp,24
81102474:	f800283a 	ret

81102478 <bDdr2MemoryRandomReadTest>:
 * @param [in] bTime  Controla se a durao da funo ser medida
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryRandomReadTest(alt_u8 ucMemoryId, bool bVerbose, bool bTime) {
81102478:	deffec04 	addi	sp,sp,-80
8110247c:	de00012e 	bgeu	sp,et,81102484 <bDdr2MemoryRandomReadTest+0xc>
81102480:	003b68fa 	trap	3
81102484:	dfc01315 	stw	ra,76(sp)
81102488:	df001215 	stw	fp,72(sp)
8110248c:	dcc01115 	stw	r19,68(sp)
81102490:	dc801015 	stw	r18,64(sp)
81102494:	dc400f15 	stw	r17,60(sp)
81102498:	dc000e15 	stw	r16,56(sp)
8110249c:	df001204 	addi	fp,sp,72
811024a0:	2005883a 	mov	r2,r4
811024a4:	e17ffa15 	stw	r5,-24(fp)
811024a8:	e1bffb15 	stw	r6,-20(fp)
811024ac:	e0bff905 	stb	r2,-28(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Random Read Test =====\n");
811024b0:	00e04574 	movhi	r3,33045
811024b4:	18ce1c04 	addi	r3,r3,14448
811024b8:	00a04574 	movhi	r2,33045
811024bc:	10afcc04 	addi	r2,r2,-16592
811024c0:	1009883a 	mov	r4,r2
811024c4:	00800b84 	movi	r2,46
811024c8:	100d883a 	mov	r6,r2
811024cc:	200b883a 	mov	r5,r4
811024d0:	1809883a 	mov	r4,r3
811024d4:	11226900 	call	81122690 <memcpy>
	debug(fp, cDebugBuffer);
811024d8:	d0a06217 	ldw	r2,-32376(gp)
811024dc:	01604574 	movhi	r5,33045
811024e0:	294e1c04 	addi	r5,r5,14448
811024e4:	1009883a 	mov	r4,r2
811024e8:	11215e00 	call	811215e0 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
811024ec:	00800044 	movi	r2,1
811024f0:	e0bfef15 	stw	r2,-68(fp)
	switch (ucMemoryId) {
811024f4:	e0bff903 	ldbu	r2,-28(fp)
811024f8:	10000326 	beq	r2,zero,81102508 <bDdr2MemoryRandomReadTest+0x90>
811024fc:	10800060 	cmpeqi	r2,r2,1
81102500:	1000081e 	bne	r2,zero,81102524 <bDdr2MemoryRandomReadTest+0xac>
81102504:	00000e06 	br	81102540 <bDdr2MemoryRandomReadTest+0xc8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81102508:	e0bff903 	ldbu	r2,-28(fp)
8110250c:	1009883a 	mov	r4,r2
81102510:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81102514:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81102518:	00a00034 	movhi	r2,32768
8110251c:	e0bff115 	stw	r2,-60(fp)
		break;
81102520:	00001906 	br	81102588 <bDdr2MemoryRandomReadTest+0x110>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81102524:	e0bff903 	ldbu	r2,-28(fp)
81102528:	1009883a 	mov	r4,r2
8110252c:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81102530:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81102534:	00a00034 	movhi	r2,32768
81102538:	e0bff115 	stw	r2,-60(fp)
		break;
8110253c:	00001206 	br	81102588 <bDdr2MemoryRandomReadTest+0x110>
	default:
		bSuccess = FALSE;
81102540:	e03fef15 	stw	zero,-68(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81102544:	00e04574 	movhi	r3,33045
81102548:	18ce1c04 	addi	r3,r3,14448
8110254c:	00a04574 	movhi	r2,33045
81102550:	10ad4d04 	addi	r2,r2,-19148
81102554:	1009883a 	mov	r4,r2
81102558:	00800bc4 	movi	r2,47
8110255c:	100d883a 	mov	r6,r2
81102560:	200b883a 	mov	r5,r4
81102564:	1809883a 	mov	r4,r3
81102568:	11226900 	call	81122690 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
8110256c:	d0a06217 	ldw	r2,-32376(gp)
81102570:	01604574 	movhi	r5,33045
81102574:	294e1c04 	addi	r5,r5,14448
81102578:	1009883a 	mov	r4,r2
8110257c:	11215e00 	call	811215e0 <fprintf>
		;
#endif
		return bSuccess;
81102580:	e0bfef17 	ldw	r2,-68(fp)
81102584:	0000d906 	br	811028ec <bDdr2MemoryRandomReadTest+0x474>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
81102588:	e0bff117 	ldw	r2,-60(fp)
8110258c:	1004d53a 	srli	r2,r2,20
81102590:	100d883a 	mov	r6,r2
81102594:	01604574 	movhi	r5,33045
81102598:	296f4604 	addi	r5,r5,-17128
8110259c:	01204574 	movhi	r4,33045
811025a0:	210e1c04 	addi	r4,r4,14448
811025a4:	1122f700 	call	81122f70 <sprintf>
	debug(fp, cDebugBuffer);
811025a8:	d0a06217 	ldw	r2,-32376(gp)
811025ac:	01604574 	movhi	r5,33045
811025b0:	294e1c04 	addi	r5,r5,14448
811025b4:	1009883a 	mov	r4,r2
811025b8:	11215e00 	call	811215e0 <fprintf>
	alt_u32 uliCurrentState;
	alt_u32 uliMemoryEndAddress;
	alt_u32 uliNextMilestone;
	alt_u8 ucPercentage;

	uliCurrentState = uliInitialState;
811025bc:	d0a03717 	ldw	r2,-32548(gp)
811025c0:	e0bff815 	stw	r2,-32(fp)
	uliMemoryEndAddress = uliDdr2Base + uliByteLen;
811025c4:	e0fff017 	ldw	r3,-64(fp)
811025c8:	e0bff117 	ldw	r2,-60(fp)
811025cc:	1885883a 	add	r2,r3,r2
811025d0:	e0bff515 	stw	r2,-44(fp)
	uliNextMilestone = uliDdr2Base + uliByteLen / 20;
811025d4:	e0fff117 	ldw	r3,-60(fp)
811025d8:	00b33374 	movhi	r2,52429
811025dc:	10b33344 	addi	r2,r2,-13107
811025e0:	1888383a 	mulxuu	r4,r3,r2
811025e4:	1885383a 	mul	r2,r3,r2
811025e8:	1025883a 	mov	r18,r2
811025ec:	2027883a 	mov	r19,r4
811025f0:	9806d13a 	srli	r3,r19,4
811025f4:	e0bff017 	ldw	r2,-64(fp)
811025f8:	1885883a 	add	r2,r3,r2
811025fc:	e0bff315 	stw	r2,-52(fp)
	ucPercentage = 5;
81102600:	00800144 	movi	r2,5
81102604:	e0bff405 	stb	r2,-48(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Reading from memory...\n");
81102608:	00e04574 	movhi	r3,33045
8110260c:	18ce1c04 	addi	r3,r3,14448
81102610:	00a04574 	movhi	r2,33045
81102614:	10afd804 	addi	r2,r2,-16544
81102618:	1009883a 	mov	r4,r2
8110261c:	00800604 	movi	r2,24
81102620:	100d883a 	mov	r6,r2
81102624:	200b883a 	mov	r5,r4
81102628:	1809883a 	mov	r4,r3
8110262c:	11226900 	call	81122690 <memcpy>
	debug(fp, cDebugBuffer);
81102630:	d0a06217 	ldw	r2,-32376(gp)
81102634:	01604574 	movhi	r5,33045
81102638:	294e1c04 	addi	r5,r5,14448
8110263c:	1009883a 	mov	r4,r2
81102640:	11215e00 	call	811215e0 <fprintf>
#endif
	if (bVerbose == DDR2_VERBOSE) {
81102644:	e0bffa17 	ldw	r2,-24(fp)
81102648:	10800058 	cmpnei	r2,r2,1
8110264c:	10000a1e 	bne	r2,zero,81102678 <bDdr2MemoryRandomReadTest+0x200>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "00%%..");
81102650:	01604574 	movhi	r5,33045
81102654:	296fae04 	addi	r5,r5,-16712
81102658:	01204574 	movhi	r4,33045
8110265c:	210e1c04 	addi	r4,r4,14448
81102660:	1122f700 	call	81122f70 <sprintf>
		debug(fp, cDebugBuffer);
81102664:	d0a06217 	ldw	r2,-32376(gp)
81102668:	01604574 	movhi	r5,33045
8110266c:	294e1c04 	addi	r5,r5,14448
81102670:	1009883a 	mov	r4,r2
81102674:	11215e00 	call	811215e0 <fprintf>
#endif
	}

	int TimeStart, TimeElapsed = 0;
81102678:	e03ff615 	stw	zero,-40(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
8110267c:	d0a08917 	ldw	r2,-32220(gp)

	TimeStart = alt_nticks();
81102680:	e0bff715 	stw	r2,-36(fp)
	for (puliSource = (alt_u32*) uliDdr2Base;
81102684:	e0bff017 	ldw	r2,-64(fp)
81102688:	e0bff215 	stw	r2,-56(fp)
8110268c:	00003a06 	br	81102778 <bDdr2MemoryRandomReadTest+0x300>
			(alt_u32) puliSource < uliMemoryEndAddress; puliSource++) {
		if (uliXorshift32(&uliCurrentState) != *puliSource) {
81102690:	e0bff804 	addi	r2,fp,-32
81102694:	1009883a 	mov	r4,r2
81102698:	11029100 	call	81102910 <uliXorshift32>
8110269c:	1007883a 	mov	r3,r2
811026a0:	e0bff217 	ldw	r2,-56(fp)
811026a4:	10800017 	ldw	r2,0(r2)
811026a8:	18801026 	beq	r3,r2,811026ec <bDdr2MemoryRandomReadTest+0x274>
			bSuccess = FALSE;
811026ac:	e03fef15 	stw	zero,-68(fp)
			if (bVerbose == DDR2_VERBOSE) {
811026b0:	e0bffa17 	ldw	r2,-24(fp)
811026b4:	10800058 	cmpnei	r2,r2,1
811026b8:	10000c1e 	bne	r2,zero,811026ec <bDdr2MemoryRandomReadTest+0x274>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "Failed to read adress 0x%08lX\n",
811026bc:	e0bff217 	ldw	r2,-56(fp)
811026c0:	100d883a 	mov	r6,r2
811026c4:	01604574 	movhi	r5,33045
811026c8:	296fde04 	addi	r5,r5,-16520
811026cc:	01204574 	movhi	r4,33045
811026d0:	210e1c04 	addi	r4,r4,14448
811026d4:	1122f700 	call	81122f70 <sprintf>
						(alt_u32)puliSource);
				debug(fp, cDebugBuffer);
811026d8:	d0a06217 	ldw	r2,-32376(gp)
811026dc:	01604574 	movhi	r5,33045
811026e0:	294e1c04 	addi	r5,r5,14448
811026e4:	1009883a 	mov	r4,r2
811026e8:	11215e00 	call	811215e0 <fprintf>
#endif
			}
		}
		if ((bVerbose == DDR2_VERBOSE)
811026ec:	e0bffa17 	ldw	r2,-24(fp)
811026f0:	10800058 	cmpnei	r2,r2,1
811026f4:	10001d1e 	bne	r2,zero,8110276c <bDdr2MemoryRandomReadTest+0x2f4>
				&& ((alt_u32) puliSource > uliNextMilestone)) {
811026f8:	e0bff217 	ldw	r2,-56(fp)
811026fc:	e0fff317 	ldw	r3,-52(fp)
81102700:	18801a2e 	bgeu	r3,r2,8110276c <bDdr2MemoryRandomReadTest+0x2f4>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "..%02d%%..", ucPercentage);
81102704:	e0bff403 	ldbu	r2,-48(fp)
81102708:	100d883a 	mov	r6,r2
8110270c:	01604574 	movhi	r5,33045
81102710:	296fb004 	addi	r5,r5,-16704
81102714:	01204574 	movhi	r4,33045
81102718:	210e1c04 	addi	r4,r4,14448
8110271c:	1122f700 	call	81122f70 <sprintf>
			debug(fp, cDebugBuffer);
81102720:	d0a06217 	ldw	r2,-32376(gp)
81102724:	01604574 	movhi	r5,33045
81102728:	294e1c04 	addi	r5,r5,14448
8110272c:	1009883a 	mov	r4,r2
81102730:	11215e00 	call	811215e0 <fprintf>
#endif
			uliNextMilestone += uliByteLen / 20;
81102734:	e0fff117 	ldw	r3,-60(fp)
81102738:	00b33374 	movhi	r2,52429
8110273c:	10b33344 	addi	r2,r2,-13107
81102740:	1888383a 	mulxuu	r4,r3,r2
81102744:	1885383a 	mul	r2,r3,r2
81102748:	1021883a 	mov	r16,r2
8110274c:	2023883a 	mov	r17,r4
81102750:	8804d13a 	srli	r2,r17,4
81102754:	e0fff317 	ldw	r3,-52(fp)
81102758:	1885883a 	add	r2,r3,r2
8110275c:	e0bff315 	stw	r2,-52(fp)
			ucPercentage += 5;
81102760:	e0bff403 	ldbu	r2,-48(fp)
81102764:	10800144 	addi	r2,r2,5
81102768:	e0bff405 	stb	r2,-48(fp)

	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliSource = (alt_u32*) uliDdr2Base;
			(alt_u32) puliSource < uliMemoryEndAddress; puliSource++) {
8110276c:	e0bff217 	ldw	r2,-56(fp)
81102770:	10800104 	addi	r2,r2,4
81102774:	e0bff215 	stw	r2,-56(fp)
81102778:	e0fff217 	ldw	r3,-56(fp)
	}

	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliSource = (alt_u32*) uliDdr2Base;
8110277c:	e0bff517 	ldw	r2,-44(fp)
81102780:	18bfc336 	bltu	r3,r2,81102690 <__reset+0xfb0e2690>
#endif
			uliNextMilestone += uliByteLen / 20;
			ucPercentage += 5;
		}
	}
	if (bVerbose == DDR2_VERBOSE) {
81102784:	e0bffa17 	ldw	r2,-24(fp)
81102788:	10800058 	cmpnei	r2,r2,1
8110278c:	10000a1e 	bne	r2,zero,811027b8 <bDdr2MemoryRandomReadTest+0x340>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "..100%%\n");
81102790:	01604574 	movhi	r5,33045
81102794:	296fb304 	addi	r5,r5,-16692
81102798:	01204574 	movhi	r4,33045
8110279c:	210e1c04 	addi	r4,r4,14448
811027a0:	1122f700 	call	81122f70 <sprintf>
		debug(fp, cDebugBuffer);
811027a4:	d0a06217 	ldw	r2,-32376(gp)
811027a8:	01604574 	movhi	r5,33045
811027ac:	294e1c04 	addi	r5,r5,14448
811027b0:	1009883a 	mov	r4,r2
811027b4:	11215e00 	call	811215e0 <fprintf>
#endif
	}

	if (bSuccess) {
811027b8:	e0bfef17 	ldw	r2,-68(fp)
811027bc:	10003126 	beq	r2,zero,81102884 <bDdr2MemoryRandomReadTest+0x40c>
		if (bTime == TRUE) {
811027c0:	e0bffb17 	ldw	r2,-20(fp)
811027c4:	10800058 	cmpnei	r2,r2,1
811027c8:	1000221e 	bne	r2,zero,81102854 <bDdr2MemoryRandomReadTest+0x3dc>
811027cc:	d0e08917 	ldw	r3,-32220(gp)
			TimeElapsed = alt_nticks() - TimeStart;
811027d0:	e0bff717 	ldw	r2,-36(fp)
811027d4:	1885c83a 	sub	r2,r3,r2
811027d8:	e0bff615 	stw	r2,-40(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
					"DDR2 read test pass, size=%lu bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
811027dc:	e13ff617 	ldw	r4,-40(fp)
811027e0:	111fcc00 	call	8111fcc0 <__floatsisf>
811027e4:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
811027e8:	d0a08817 	ldw	r2,-32224(gp)
811027ec:	1009883a 	mov	r4,r2
811027f0:	111fdec0 	call	8111fdec <__floatunsisf>
811027f4:	1007883a 	mov	r3,r2
811027f8:	180b883a 	mov	r5,r3
811027fc:	8009883a 	mov	r4,r16
81102800:	111f4740 	call	8111f474 <__divsf3>
81102804:	1007883a 	mov	r3,r2
81102808:	1805883a 	mov	r2,r3

	if (bSuccess) {
		if (bTime == TRUE) {
			TimeElapsed = alt_nticks() - TimeStart;
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
8110280c:	1009883a 	mov	r4,r2
81102810:	11211480 	call	81121148 <__extendsfdf2>
81102814:	1009883a 	mov	r4,r2
81102818:	180b883a 	mov	r5,r3
8110281c:	d9400015 	stw	r5,0(sp)
81102820:	200f883a 	mov	r7,r4
81102824:	e1bff117 	ldw	r6,-60(fp)
81102828:	01604574 	movhi	r5,33045
8110282c:	296fe604 	addi	r5,r5,-16488
81102830:	01204574 	movhi	r4,33045
81102834:	210e1c04 	addi	r4,r4,14448
81102838:	1122f700 	call	81122f70 <sprintf>
					"DDR2 read test pass, size=%lu bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
			debug(fp, cDebugBuffer);
8110283c:	d0a06217 	ldw	r2,-32376(gp)
81102840:	01604574 	movhi	r5,33045
81102844:	294e1c04 	addi	r5,r5,14448
81102848:	1009883a 	mov	r4,r2
8110284c:	11215e00 	call	811215e0 <fprintf>
81102850:	00001b06 	br	811028c0 <bDdr2MemoryRandomReadTest+0x448>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "DDR2 read test pass, size=%lu bytes\n",
81102854:	e1bff117 	ldw	r6,-60(fp)
81102858:	01604574 	movhi	r5,33045
8110285c:	296ff204 	addi	r5,r5,-16440
81102860:	01204574 	movhi	r4,33045
81102864:	210e1c04 	addi	r4,r4,14448
81102868:	1122f700 	call	81122f70 <sprintf>
					uliByteLen);
			debug(fp, cDebugBuffer);
8110286c:	d0a06217 	ldw	r2,-32376(gp)
81102870:	01604574 	movhi	r5,33045
81102874:	294e1c04 	addi	r5,r5,14448
81102878:	1009883a 	mov	r4,r2
8110287c:	11215e00 	call	811215e0 <fprintf>
81102880:	00000f06 	br	811028c0 <bDdr2MemoryRandomReadTest+0x448>
#endif
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test fail\n");
81102884:	00e04574 	movhi	r3,33045
81102888:	18ce1c04 	addi	r3,r3,14448
8110288c:	00a04574 	movhi	r2,33045
81102890:	10af9604 	addi	r2,r2,-16808
81102894:	1009883a 	mov	r4,r2
81102898:	00800544 	movi	r2,21
8110289c:	100d883a 	mov	r6,r2
811028a0:	200b883a 	mov	r5,r4
811028a4:	1809883a 	mov	r4,r3
811028a8:	11226900 	call	81122690 <memcpy>
		debug(fp, cDebugBuffer);
811028ac:	d0a06217 	ldw	r2,-32376(gp)
811028b0:	01604574 	movhi	r5,33045
811028b4:	294e1c04 	addi	r5,r5,14448
811028b8:	1009883a 	mov	r4,r2
811028bc:	11215e00 	call	811215e0 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811028c0:	00a04574 	movhi	r2,33045
811028c4:	108e1c04 	addi	r2,r2,14448
811028c8:	00c00284 	movi	r3,10
811028cc:	10c00005 	stb	r3,0(r2)
811028d0:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811028d4:	d0a06217 	ldw	r2,-32376(gp)
811028d8:	01604574 	movhi	r5,33045
811028dc:	294e1c04 	addi	r5,r5,14448
811028e0:	1009883a 	mov	r4,r2
811028e4:	11215e00 	call	811215e0 <fprintf>
#endif

	return bSuccess;
811028e8:	e0bfef17 	ldw	r2,-68(fp)
}
811028ec:	e6fffc04 	addi	sp,fp,-16
811028f0:	dfc00517 	ldw	ra,20(sp)
811028f4:	df000417 	ldw	fp,16(sp)
811028f8:	dcc00317 	ldw	r19,12(sp)
811028fc:	dc800217 	ldw	r18,8(sp)
81102900:	dc400117 	ldw	r17,4(sp)
81102904:	dc000017 	ldw	r16,0(sp)
81102908:	dec00604 	addi	sp,sp,24
8110290c:	f800283a 	ret

81102910 <uliXorshift32>:
 * @param [in] bDRIVE  Estado atual do RNG
 *
 * @retval Nmero aleatrio resultate do RNG
 *
 */
alt_u32 uliXorshift32(alt_u32 *puliState) {
81102910:	defffd04 	addi	sp,sp,-12
81102914:	de00012e 	bgeu	sp,et,8110291c <uliXorshift32+0xc>
81102918:	003b68fa 	trap	3
8110291c:	df000215 	stw	fp,8(sp)
81102920:	df000204 	addi	fp,sp,8
81102924:	e13fff15 	stw	r4,-4(fp)

	alt_u32 uliX = *puliState;
81102928:	e0bfff17 	ldw	r2,-4(fp)
8110292c:	10800017 	ldw	r2,0(r2)
81102930:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX << 13;
81102934:	e0bffe17 	ldw	r2,-8(fp)
81102938:	1004937a 	slli	r2,r2,13
8110293c:	e0fffe17 	ldw	r3,-8(fp)
81102940:	1884f03a 	xor	r2,r3,r2
81102944:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX >> 17;
81102948:	e0bffe17 	ldw	r2,-8(fp)
8110294c:	1004d47a 	srli	r2,r2,17
81102950:	e0fffe17 	ldw	r3,-8(fp)
81102954:	1884f03a 	xor	r2,r3,r2
81102958:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX << 5;
8110295c:	e0bffe17 	ldw	r2,-8(fp)
81102960:	1004917a 	slli	r2,r2,5
81102964:	e0fffe17 	ldw	r3,-8(fp)
81102968:	1884f03a 	xor	r2,r3,r2
8110296c:	e0bffe15 	stw	r2,-8(fp)
	*puliState = uliX;
81102970:	e0bfff17 	ldw	r2,-4(fp)
81102974:	e0fffe17 	ldw	r3,-8(fp)
81102978:	10c00015 	stw	r3,0(r2)

	return uliX;
8110297c:	e0bffe17 	ldw	r2,-8(fp)
}
81102980:	e037883a 	mov	sp,fp
81102984:	df000017 	ldw	fp,0(sp)
81102988:	dec00104 	addi	sp,sp,4
8110298c:	f800283a 	ret

81102990 <DMA_OPEN_DEVICE>:
 * @param [in] DmaName  String com o nome do DMA (XXX_CSR_NAME)
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_OPEN_DEVICE(alt_msgdma_dev **DmaDevice, const char* DmaName){
81102990:	defffb04 	addi	sp,sp,-20
81102994:	de00012e 	bgeu	sp,et,8110299c <DMA_OPEN_DEVICE+0xc>
81102998:	003b68fa 	trap	3
8110299c:	dfc00415 	stw	ra,16(sp)
811029a0:	df000315 	stw	fp,12(sp)
811029a4:	df000304 	addi	fp,sp,12
811029a8:	e13ffe15 	stw	r4,-8(fp)
811029ac:	e17fff15 	stw	r5,-4(fp)
  bool bSuccess = TRUE;
811029b0:	00800044 	movi	r2,1
811029b4:	e0bffd15 	stw	r2,-12(fp)
  
  //Open DMA based on name

  *DmaDevice = alt_msgdma_open((char *)DmaName);
811029b8:	e13fff17 	ldw	r4,-4(fp)
811029bc:	1149dac0 	call	81149dac <alt_msgdma_open>
811029c0:	1007883a 	mov	r3,r2
811029c4:	e0bffe17 	ldw	r2,-8(fp)
811029c8:	10c00015 	stw	r3,0(r2)
  
  //Check if DMA opened correctly;
  if(*DmaDevice == NULL){
811029cc:	e0bffe17 	ldw	r2,-8(fp)
811029d0:	10800017 	ldw	r2,0(r2)
811029d4:	1000011e 	bne	r2,zero,811029dc <DMA_OPEN_DEVICE+0x4c>
    bSuccess = FALSE;
811029d8:	e03ffd15 	stw	zero,-12(fp)
  }
  
  return bSuccess;
811029dc:	e0bffd17 	ldw	r2,-12(fp)
}
811029e0:	e037883a 	mov	sp,fp
811029e4:	dfc00117 	ldw	ra,4(sp)
811029e8:	df000017 	ldw	fp,0(sp)
811029ec:	dec00204 	addi	sp,sp,8
811029f0:	f800283a 	ret

811029f4 <DMA_CONFIG>:
 * @param [in] ConfigMask  Mascara com as configuraes do DMA (overwrite)
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_CONFIG(alt_msgdma_dev *DmaDevice, alt_u32 ConfigMask){
811029f4:	defffc04 	addi	sp,sp,-16
811029f8:	de00012e 	bgeu	sp,et,81102a00 <DMA_CONFIG+0xc>
811029fc:	003b68fa 	trap	3
81102a00:	df000315 	stw	fp,12(sp)
81102a04:	df000304 	addi	fp,sp,12
81102a08:	e13ffe15 	stw	r4,-8(fp)
81102a0c:	e17fff15 	stw	r5,-4(fp)
  bool bSuccess = TRUE;
81102a10:	00800044 	movi	r2,1
81102a14:	e0bffd15 	stw	r2,-12(fp)
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ConfigMask);
81102a18:	e0bffe17 	ldw	r2,-8(fp)
81102a1c:	10800317 	ldw	r2,12(r2)
81102a20:	10800104 	addi	r2,r2,4
81102a24:	e0ffff17 	ldw	r3,-4(fp)
81102a28:	10c00035 	stwio	r3,0(r2)
  return bSuccess;
81102a2c:	e0bffd17 	ldw	r2,-12(fp)
}
81102a30:	e037883a 	mov	sp,fp
81102a34:	df000017 	ldw	fp,0(sp)
81102a38:	dec00104 	addi	sp,sp,4
81102a3c:	f800283a 	ret

81102a40 <DMA_BUSY>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : DMA Ocupado
 *
 */
bool DMA_BUSY(alt_msgdma_dev *DmaDevice){
81102a40:	defffd04 	addi	sp,sp,-12
81102a44:	de00012e 	bgeu	sp,et,81102a4c <DMA_BUSY+0xc>
81102a48:	003b68fa 	trap	3
81102a4c:	df000215 	stw	fp,8(sp)
81102a50:	df000204 	addi	fp,sp,8
81102a54:	e13fff15 	stw	r4,-4(fp)
  bool bBusy = FALSE;
81102a58:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK){
81102a5c:	e0bfff17 	ldw	r2,-4(fp)
81102a60:	10800317 	ldw	r2,12(r2)
81102a64:	10800037 	ldwio	r2,0(r2)
81102a68:	1080004c 	andi	r2,r2,1
81102a6c:	10000226 	beq	r2,zero,81102a78 <DMA_BUSY+0x38>
    bBusy = TRUE;
81102a70:	00800044 	movi	r2,1
81102a74:	e0bffe15 	stw	r2,-8(fp)
  }
  return bBusy;
81102a78:	e0bffe17 	ldw	r2,-8(fp)
}
81102a7c:	e037883a 	mov	sp,fp
81102a80:	df000017 	ldw	fp,0(sp)
81102a84:	dec00104 	addi	sp,sp,4
81102a88:	f800283a 	ret

81102a8c <DMA_DESCRIPTOR_BUFFER_FULL>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : Buffer Cheio
 *
 */
bool DMA_DESCRIPTOR_BUFFER_FULL(alt_msgdma_dev *DmaDevice){
81102a8c:	defffd04 	addi	sp,sp,-12
81102a90:	de00012e 	bgeu	sp,et,81102a98 <DMA_DESCRIPTOR_BUFFER_FULL+0xc>
81102a94:	003b68fa 	trap	3
81102a98:	df000215 	stw	fp,8(sp)
81102a9c:	df000204 	addi	fp,sp,8
81102aa0:	e13fff15 	stw	r4,-4(fp)
  bool bFull = FALSE;
81102aa4:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK){
81102aa8:	e0bfff17 	ldw	r2,-4(fp)
81102aac:	10800317 	ldw	r2,12(r2)
81102ab0:	10800037 	ldwio	r2,0(r2)
81102ab4:	1080010c 	andi	r2,r2,4
81102ab8:	10000226 	beq	r2,zero,81102ac4 <DMA_DESCRIPTOR_BUFFER_FULL+0x38>
    bFull = TRUE;
81102abc:	00800044 	movi	r2,1
81102ac0:	e0bffe15 	stw	r2,-8(fp)
  }
  return bFull;
81102ac4:	e0bffe17 	ldw	r2,-8(fp)
}
81102ac8:	e037883a 	mov	sp,fp
81102acc:	df000017 	ldw	fp,0(sp)
81102ad0:	dec00104 	addi	sp,sp,4
81102ad4:	f800283a 	ret

81102ad8 <DMA_DESCRIPTOR_BUFFER_EMPTY>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : Buffer Vazio
 *
 */
bool DMA_DESCRIPTOR_BUFFER_EMPTY(alt_msgdma_dev *DmaDevice){
81102ad8:	defffd04 	addi	sp,sp,-12
81102adc:	de00012e 	bgeu	sp,et,81102ae4 <DMA_DESCRIPTOR_BUFFER_EMPTY+0xc>
81102ae0:	003b68fa 	trap	3
81102ae4:	df000215 	stw	fp,8(sp)
81102ae8:	df000204 	addi	fp,sp,8
81102aec:	e13fff15 	stw	r4,-4(fp)
  bool bEmpty = FALSE;
81102af0:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_EMPTY_MASK){
81102af4:	e0bfff17 	ldw	r2,-4(fp)
81102af8:	10800317 	ldw	r2,12(r2)
81102afc:	10800037 	ldwio	r2,0(r2)
81102b00:	1080008c 	andi	r2,r2,2
81102b04:	10000226 	beq	r2,zero,81102b10 <DMA_DESCRIPTOR_BUFFER_EMPTY+0x38>
    bEmpty = TRUE;
81102b08:	00800044 	movi	r2,1
81102b0c:	e0bffe15 	stw	r2,-8(fp)
  }
  return bEmpty;
81102b10:	e0bffe17 	ldw	r2,-8(fp)
}
81102b14:	e037883a 	mov	sp,fp
81102b18:	df000017 	ldw	fp,0(sp)
81102b1c:	dec00104 	addi	sp,sp,4
81102b20:	f800283a 	ret

81102b24 <DMA_DISPATCHER_STOP>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_DISPATCHER_STOP(alt_msgdma_dev *DmaDevice, bool bWait, alt_32 WaitPeriodUs){
81102b24:	defffa04 	addi	sp,sp,-24
81102b28:	de00012e 	bgeu	sp,et,81102b30 <DMA_DISPATCHER_STOP+0xc>
81102b2c:	003b68fa 	trap	3
81102b30:	dfc00515 	stw	ra,20(sp)
81102b34:	df000415 	stw	fp,16(sp)
81102b38:	df000404 	addi	fp,sp,16
81102b3c:	e13ffd15 	stw	r4,-12(fp)
81102b40:	e17ffe15 	stw	r5,-8(fp)
81102b44:	e1bfff15 	stw	r6,-4(fp)
  bool bSuccess = TRUE;
81102b48:	00800044 	movi	r2,1
81102b4c:	e0bffc15 	stw	r2,-16(fp)
  
  //Send stop command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_STOP_MASK);
81102b50:	e0bffd17 	ldw	r2,-12(fp)
81102b54:	10800317 	ldw	r2,12(r2)
81102b58:	10800104 	addi	r2,r2,4
81102b5c:	00c00044 	movi	r3,1
81102b60:	10c00035 	stwio	r3,0(r2)
  
  if (bWait == DMA_WAIT) {
81102b64:	e0bffe17 	ldw	r2,-8(fp)
81102b68:	10800058 	cmpnei	r2,r2,1
81102b6c:	10000f1e 	bne	r2,zero,81102bac <DMA_DISPATCHER_STOP+0x88>
    //Wait stop to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_STOP_STATE_MASK) {
81102b70:	00000806 	br	81102b94 <DMA_DISPATCHER_STOP+0x70>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102b74:	e0bfff17 	ldw	r2,-4(fp)
81102b78:	1000031e 	bne	r2,zero,81102b88 <DMA_DISPATCHER_STOP+0x64>
        usleep(1);
81102b7c:	01000044 	movi	r4,1
81102b80:	1137d140 	call	81137d14 <usleep>
81102b84:	00000306 	br	81102b94 <DMA_DISPATCHER_STOP+0x70>
      } else {
        usleep(WaitPeriodUs);
81102b88:	e0bfff17 	ldw	r2,-4(fp)
81102b8c:	1009883a 	mov	r4,r2
81102b90:	1137d140 	call	81137d14 <usleep>
  //Send stop command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_STOP_MASK);
  
  if (bWait == DMA_WAIT) {
    //Wait stop to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_STOP_STATE_MASK) {
81102b94:	e0bffd17 	ldw	r2,-12(fp)
81102b98:	10800317 	ldw	r2,12(r2)
81102b9c:	10800037 	ldwio	r2,0(r2)
81102ba0:	1080080c 	andi	r2,r2,32
81102ba4:	103ff31e 	bne	r2,zero,81102b74 <__reset+0xfb0e2b74>
81102ba8:	00000206 	br	81102bb4 <DMA_DISPATCHER_STOP+0x90>
      } else {
        usleep(WaitPeriodUs);
      }
    }
  } else {
    return bSuccess;
81102bac:	e0bffc17 	ldw	r2,-16(fp)
81102bb0:	00000106 	br	81102bb8 <DMA_DISPATCHER_STOP+0x94>
  }
  
  return bSuccess;
81102bb4:	e0bffc17 	ldw	r2,-16(fp)
}
81102bb8:	e037883a 	mov	sp,fp
81102bbc:	dfc00117 	ldw	ra,4(sp)
81102bc0:	df000017 	ldw	fp,0(sp)
81102bc4:	dec00204 	addi	sp,sp,8
81102bc8:	f800283a 	ret

81102bcc <DMA_DISPATCHER_RESET>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_DISPATCHER_RESET(alt_msgdma_dev *DmaDevice, bool bWait, alt_32 WaitPeriodUs){
81102bcc:	defffa04 	addi	sp,sp,-24
81102bd0:	de00012e 	bgeu	sp,et,81102bd8 <DMA_DISPATCHER_RESET+0xc>
81102bd4:	003b68fa 	trap	3
81102bd8:	dfc00515 	stw	ra,20(sp)
81102bdc:	df000415 	stw	fp,16(sp)
81102be0:	df000404 	addi	fp,sp,16
81102be4:	e13ffd15 	stw	r4,-12(fp)
81102be8:	e17ffe15 	stw	r5,-8(fp)
81102bec:	e1bfff15 	stw	r6,-4(fp)
  bool bSuccess = TRUE;
81102bf0:	00800044 	movi	r2,1
81102bf4:	e0bffc15 	stw	r2,-16(fp)
  
  //Send reset command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
81102bf8:	e0bffd17 	ldw	r2,-12(fp)
81102bfc:	10800317 	ldw	r2,12(r2)
81102c00:	10800104 	addi	r2,r2,4
81102c04:	00c00084 	movi	r3,2
81102c08:	10c00035 	stwio	r3,0(r2)
  
  if (bWait == DMA_WAIT) {
81102c0c:	e0bffe17 	ldw	r2,-8(fp)
81102c10:	10800058 	cmpnei	r2,r2,1
81102c14:	10000f1e 	bne	r2,zero,81102c54 <DMA_DISPATCHER_RESET+0x88>
    //Wait reset to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81102c18:	00000806 	br	81102c3c <DMA_DISPATCHER_RESET+0x70>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102c1c:	e0bfff17 	ldw	r2,-4(fp)
81102c20:	1000031e 	bne	r2,zero,81102c30 <DMA_DISPATCHER_RESET+0x64>
        usleep(1);
81102c24:	01000044 	movi	r4,1
81102c28:	1137d140 	call	81137d14 <usleep>
81102c2c:	00000306 	br	81102c3c <DMA_DISPATCHER_RESET+0x70>
      } else {
        usleep(WaitPeriodUs);
81102c30:	e0bfff17 	ldw	r2,-4(fp)
81102c34:	1009883a 	mov	r4,r2
81102c38:	1137d140 	call	81137d14 <usleep>
  //Send reset command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
  
  if (bWait == DMA_WAIT) {
    //Wait reset to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81102c3c:	e0bffd17 	ldw	r2,-12(fp)
81102c40:	10800317 	ldw	r2,12(r2)
81102c44:	10800037 	ldwio	r2,0(r2)
81102c48:	1080100c 	andi	r2,r2,64
81102c4c:	103ff31e 	bne	r2,zero,81102c1c <__reset+0xfb0e2c1c>
81102c50:	00000206 	br	81102c5c <DMA_DISPATCHER_RESET+0x90>
      } else {
        usleep(WaitPeriodUs);
      }
    }
  } else {
    return bSuccess;
81102c54:	e0bffc17 	ldw	r2,-16(fp)
81102c58:	00000106 	br	81102c60 <DMA_DISPATCHER_RESET+0x94>
  }
  
  return bSuccess;
81102c5c:	e0bffc17 	ldw	r2,-16(fp)
}
81102c60:	e037883a 	mov	sp,fp
81102c64:	dfc00117 	ldw	ra,4(sp)
81102c68:	df000017 	ldw	fp,0(sp)
81102c6c:	dec00204 	addi	sp,sp,8
81102c70:	f800283a 	ret

81102c74 <DMA_SINGLE_TRANSFER>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_SINGLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddress, alt_u32 DestinationAddress, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
81102c74:	defff604 	addi	sp,sp,-40
81102c78:	de00012e 	bgeu	sp,et,81102c80 <DMA_SINGLE_TRANSFER+0xc>
81102c7c:	003b68fa 	trap	3
81102c80:	dfc00915 	stw	ra,36(sp)
81102c84:	df000815 	stw	fp,32(sp)
81102c88:	dc000715 	stw	r16,28(sp)
81102c8c:	df000804 	addi	fp,sp,32
81102c90:	e13ffb15 	stw	r4,-20(fp)
81102c94:	e17ffc15 	stw	r5,-16(fp)
81102c98:	e1bffd15 	stw	r6,-12(fp)
81102c9c:	e1fffe15 	stw	r7,-8(fp)
81102ca0:	defff804 	addi	sp,sp,-32
81102ca4:	d8800204 	addi	r2,sp,8
81102ca8:	108003c4 	addi	r2,r2,15
81102cac:	1004d13a 	srli	r2,r2,4
81102cb0:	1020913a 	slli	r16,r2,4
  bool bSuccess = TRUE;
81102cb4:	00800044 	movi	r2,1
81102cb8:	e0bffa15 	stw	r2,-24(fp)
  alt_msgdma_standard_descriptor DmaDescriptor;

  if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddress, (alt_u32 *)DestinationAddress, TransferSize, ControlBits) != 0){
81102cbc:	e0fffc17 	ldw	r3,-16(fp)
81102cc0:	e13ffd17 	ldw	r4,-12(fp)
81102cc4:	e0800217 	ldw	r2,8(fp)
81102cc8:	d8800115 	stw	r2,4(sp)
81102ccc:	e0bffe17 	ldw	r2,-8(fp)
81102cd0:	d8800015 	stw	r2,0(sp)
81102cd4:	200f883a 	mov	r7,r4
81102cd8:	180d883a 	mov	r6,r3
81102cdc:	800b883a 	mov	r5,r16
81102ce0:	e13ffb17 	ldw	r4,-20(fp)
81102ce4:	1148da80 	call	81148da8 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102ce8:	10000326 	beq	r2,zero,81102cf8 <DMA_SINGLE_TRANSFER+0x84>
    bSuccess = FALSE;
81102cec:	e03ffa15 	stw	zero,-24(fp)
    return bSuccess;
81102cf0:	e0bffa17 	ldw	r2,-24(fp)
81102cf4:	00001e06 	br	81102d70 <DMA_SINGLE_TRANSFER+0xfc>
  } else {
    if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102cf8:	800b883a 	mov	r5,r16
81102cfc:	e13ffb17 	ldw	r4,-20(fp)
81102d00:	114a01c0 	call	8114a01c <alt_msgdma_standard_descriptor_async_transfer>
81102d04:	10000326 	beq	r2,zero,81102d14 <DMA_SINGLE_TRANSFER+0xa0>
      bSuccess = FALSE;
81102d08:	e03ffa15 	stw	zero,-24(fp)
      return bSuccess;
81102d0c:	e0bffa17 	ldw	r2,-24(fp)
81102d10:	00001706 	br	81102d70 <DMA_SINGLE_TRANSFER+0xfc>
    }
  }
  
  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
81102d14:	e0bffa17 	ldw	r2,-24(fp)
81102d18:	10800060 	cmpeqi	r2,r2,1
81102d1c:	1007883a 	mov	r3,r2
81102d20:	e0800317 	ldw	r2,12(fp)
81102d24:	10800060 	cmpeqi	r2,r2,1
81102d28:	1884703a 	and	r2,r3,r2
81102d2c:	10803fcc 	andi	r2,r2,255
81102d30:	10000e26 	beq	r2,zero,81102d6c <DMA_SINGLE_TRANSFER+0xf8>
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102d34:	00000806 	br	81102d58 <DMA_SINGLE_TRANSFER+0xe4>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102d38:	e0800417 	ldw	r2,16(fp)
81102d3c:	1000031e 	bne	r2,zero,81102d4c <DMA_SINGLE_TRANSFER+0xd8>
        usleep(1000);
81102d40:	0100fa04 	movi	r4,1000
81102d44:	1137d140 	call	81137d14 <usleep>
81102d48:	00000306 	br	81102d58 <DMA_SINGLE_TRANSFER+0xe4>
      } else {
        usleep(WaitPeriodUs);
81102d4c:	e0800417 	ldw	r2,16(fp)
81102d50:	1009883a 	mov	r4,r2
81102d54:	1137d140 	call	81137d14 <usleep>
      return bSuccess;
    }
  }
  
  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102d58:	e0bffb17 	ldw	r2,-20(fp)
81102d5c:	10800317 	ldw	r2,12(r2)
81102d60:	10800037 	ldwio	r2,0(r2)
81102d64:	1080004c 	andi	r2,r2,1
81102d68:	103ff31e 	bne	r2,zero,81102d38 <__reset+0xfb0e2d38>
        usleep(WaitPeriodUs);
      }
    }
  }
  
  return bSuccess;
81102d6c:	e0bffa17 	ldw	r2,-24(fp)
}
81102d70:	e6ffff04 	addi	sp,fp,-4
81102d74:	dfc00217 	ldw	ra,8(sp)
81102d78:	df000117 	ldw	fp,4(sp)
81102d7c:	dc000017 	ldw	r16,0(sp)
81102d80:	dec00304 	addi	sp,sp,12
81102d84:	f800283a 	ret

81102d88 <DMA_MULTIPLE_TRANSFER>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_MULTIPLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddressArray[], alt_u32 DestinationAddressArray[], alt_u8 TransferNumber, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
81102d88:	defff504 	addi	sp,sp,-44
81102d8c:	de00012e 	bgeu	sp,et,81102d94 <DMA_MULTIPLE_TRANSFER+0xc>
81102d90:	003b68fa 	trap	3
81102d94:	dfc00a15 	stw	ra,40(sp)
81102d98:	df000915 	stw	fp,36(sp)
81102d9c:	dc000815 	stw	r16,32(sp)
81102da0:	df000904 	addi	fp,sp,36
81102da4:	e13ffb15 	stw	r4,-20(fp)
81102da8:	e17ffc15 	stw	r5,-16(fp)
81102dac:	e1bffd15 	stw	r6,-12(fp)
81102db0:	3805883a 	mov	r2,r7
81102db4:	e0bffe05 	stb	r2,-8(fp)
81102db8:	defff804 	addi	sp,sp,-32
81102dbc:	d8800204 	addi	r2,sp,8
81102dc0:	108003c4 	addi	r2,r2,15
81102dc4:	1004d13a 	srli	r2,r2,4
81102dc8:	1020913a 	slli	r16,r2,4
  bool bSuccess = TRUE;
81102dcc:	00800044 	movi	r2,1
81102dd0:	e0bff915 	stw	r2,-28(fp)
  alt_msgdma_standard_descriptor DmaDescriptor;
  alt_u8 i = 0;
81102dd4:	e03ffa05 	stb	zero,-24(fp)

  while ((bSuccess == TRUE) & (i < (TransferNumber - 1))){
81102dd8:	00002506 	br	81102e70 <DMA_MULTIPLE_TRANSFER+0xe8>
    if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddressArray[i], (alt_u32 *)DestinationAddressArray[i], TransferSize, (ControlBits | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_EARLY_DONE_ENABLE_MASK)) != 0){
81102ddc:	e0bffa03 	ldbu	r2,-24(fp)
81102de0:	1085883a 	add	r2,r2,r2
81102de4:	1085883a 	add	r2,r2,r2
81102de8:	1007883a 	mov	r3,r2
81102dec:	e0bffc17 	ldw	r2,-16(fp)
81102df0:	10c5883a 	add	r2,r2,r3
81102df4:	10800017 	ldw	r2,0(r2)
81102df8:	1009883a 	mov	r4,r2
81102dfc:	e0bffa03 	ldbu	r2,-24(fp)
81102e00:	1085883a 	add	r2,r2,r2
81102e04:	1085883a 	add	r2,r2,r2
81102e08:	1007883a 	mov	r3,r2
81102e0c:	e0bffd17 	ldw	r2,-12(fp)
81102e10:	10c5883a 	add	r2,r2,r3
81102e14:	10800017 	ldw	r2,0(r2)
81102e18:	1007883a 	mov	r3,r2
81102e1c:	e0800317 	ldw	r2,12(fp)
81102e20:	10804034 	orhi	r2,r2,256
81102e24:	d8800115 	stw	r2,4(sp)
81102e28:	e0800217 	ldw	r2,8(fp)
81102e2c:	d8800015 	stw	r2,0(sp)
81102e30:	180f883a 	mov	r7,r3
81102e34:	200d883a 	mov	r6,r4
81102e38:	800b883a 	mov	r5,r16
81102e3c:	e13ffb17 	ldw	r4,-20(fp)
81102e40:	1148da80 	call	81148da8 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102e44:	10000226 	beq	r2,zero,81102e50 <DMA_MULTIPLE_TRANSFER+0xc8>
      bSuccess = FALSE;
81102e48:	e03ff915 	stw	zero,-28(fp)
81102e4c:	00000506 	br	81102e64 <DMA_MULTIPLE_TRANSFER+0xdc>
    } else {
      if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102e50:	800b883a 	mov	r5,r16
81102e54:	e13ffb17 	ldw	r4,-20(fp)
81102e58:	114a01c0 	call	8114a01c <alt_msgdma_standard_descriptor_async_transfer>
81102e5c:	10000126 	beq	r2,zero,81102e64 <DMA_MULTIPLE_TRANSFER+0xdc>
        bSuccess = FALSE;
81102e60:	e03ff915 	stw	zero,-28(fp)
      }
    }
	i++;
81102e64:	e0bffa03 	ldbu	r2,-24(fp)
81102e68:	10800044 	addi	r2,r2,1
81102e6c:	e0bffa05 	stb	r2,-24(fp)
bool DMA_MULTIPLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddressArray[], alt_u32 DestinationAddressArray[], alt_u8 TransferNumber, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
  bool bSuccess = TRUE;
  alt_msgdma_standard_descriptor DmaDescriptor;
  alt_u8 i = 0;

  while ((bSuccess == TRUE) & (i < (TransferNumber - 1))){
81102e70:	e0bff917 	ldw	r2,-28(fp)
81102e74:	10800060 	cmpeqi	r2,r2,1
81102e78:	1009883a 	mov	r4,r2
81102e7c:	e0fffa03 	ldbu	r3,-24(fp)
81102e80:	e0bffe03 	ldbu	r2,-8(fp)
81102e84:	10bfffc4 	addi	r2,r2,-1
81102e88:	1884803a 	cmplt	r2,r3,r2
81102e8c:	2084703a 	and	r2,r4,r2
81102e90:	10803fcc 	andi	r2,r2,255
81102e94:	103fd11e 	bne	r2,zero,81102ddc <__reset+0xfb0e2ddc>
        bSuccess = FALSE;
      }
    }
	i++;
  }
  if (bSuccess == TRUE){
81102e98:	e0bff917 	ldw	r2,-28(fp)
81102e9c:	10800058 	cmpnei	r2,r2,1
81102ea0:	1000211e 	bne	r2,zero,81102f28 <DMA_MULTIPLE_TRANSFER+0x1a0>
    if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddressArray[i], (alt_u32 *)DestinationAddressArray[i], TransferSize, ControlBits) != 0){
81102ea4:	e0bffa03 	ldbu	r2,-24(fp)
81102ea8:	1085883a 	add	r2,r2,r2
81102eac:	1085883a 	add	r2,r2,r2
81102eb0:	1007883a 	mov	r3,r2
81102eb4:	e0bffc17 	ldw	r2,-16(fp)
81102eb8:	10c5883a 	add	r2,r2,r3
81102ebc:	10800017 	ldw	r2,0(r2)
81102ec0:	1009883a 	mov	r4,r2
81102ec4:	e0bffa03 	ldbu	r2,-24(fp)
81102ec8:	1085883a 	add	r2,r2,r2
81102ecc:	1085883a 	add	r2,r2,r2
81102ed0:	1007883a 	mov	r3,r2
81102ed4:	e0bffd17 	ldw	r2,-12(fp)
81102ed8:	10c5883a 	add	r2,r2,r3
81102edc:	10800017 	ldw	r2,0(r2)
81102ee0:	1007883a 	mov	r3,r2
81102ee4:	e0800317 	ldw	r2,12(fp)
81102ee8:	d8800115 	stw	r2,4(sp)
81102eec:	e0800217 	ldw	r2,8(fp)
81102ef0:	d8800015 	stw	r2,0(sp)
81102ef4:	180f883a 	mov	r7,r3
81102ef8:	200d883a 	mov	r6,r4
81102efc:	800b883a 	mov	r5,r16
81102f00:	e13ffb17 	ldw	r4,-20(fp)
81102f04:	1148da80 	call	81148da8 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102f08:	10000226 	beq	r2,zero,81102f14 <DMA_MULTIPLE_TRANSFER+0x18c>
      bSuccess = FALSE;
81102f0c:	e03ff915 	stw	zero,-28(fp)
81102f10:	00000506 	br	81102f28 <DMA_MULTIPLE_TRANSFER+0x1a0>
    } else {
      if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102f14:	800b883a 	mov	r5,r16
81102f18:	e13ffb17 	ldw	r4,-20(fp)
81102f1c:	114a01c0 	call	8114a01c <alt_msgdma_standard_descriptor_async_transfer>
81102f20:	10000126 	beq	r2,zero,81102f28 <DMA_MULTIPLE_TRANSFER+0x1a0>
        bSuccess = FALSE;
81102f24:	e03ff915 	stw	zero,-28(fp)
      }
    }
  }

  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
81102f28:	e0bff917 	ldw	r2,-28(fp)
81102f2c:	10800060 	cmpeqi	r2,r2,1
81102f30:	1007883a 	mov	r3,r2
81102f34:	e0800417 	ldw	r2,16(fp)
81102f38:	10800060 	cmpeqi	r2,r2,1
81102f3c:	1884703a 	and	r2,r3,r2
81102f40:	10803fcc 	andi	r2,r2,255
81102f44:	10000e26 	beq	r2,zero,81102f80 <DMA_MULTIPLE_TRANSFER+0x1f8>
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102f48:	00000806 	br	81102f6c <DMA_MULTIPLE_TRANSFER+0x1e4>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102f4c:	e0800517 	ldw	r2,20(fp)
81102f50:	1000031e 	bne	r2,zero,81102f60 <DMA_MULTIPLE_TRANSFER+0x1d8>
    	usleep(1000);
81102f54:	0100fa04 	movi	r4,1000
81102f58:	1137d140 	call	81137d14 <usleep>
81102f5c:	00000306 	br	81102f6c <DMA_MULTIPLE_TRANSFER+0x1e4>
      } else {
    	usleep(WaitPeriodUs);
81102f60:	e0800517 	ldw	r2,20(fp)
81102f64:	1009883a 	mov	r4,r2
81102f68:	1137d140 	call	81137d14 <usleep>
      }
    }
  }

  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102f6c:	e0bffb17 	ldw	r2,-20(fp)
81102f70:	10800317 	ldw	r2,12(r2)
81102f74:	10800037 	ldwio	r2,0(r2)
81102f78:	1080004c 	andi	r2,r2,1
81102f7c:	103ff31e 	bne	r2,zero,81102f4c <__reset+0xfb0e2f4c>
    	usleep(WaitPeriodUs);
      }
    }
  }
  
  return bSuccess;
81102f80:	e0bff917 	ldw	r2,-28(fp)
}
81102f84:	e6ffff04 	addi	sp,fp,-4
81102f88:	dfc00217 	ldw	ra,8(sp)
81102f8c:	df000117 	ldw	fp,4(sp)
81102f90:	dc000017 	ldw	r16,0(sp)
81102f94:	dec00304 	addi	sp,sp,12
81102f98:	f800283a 	ret

81102f9c <POWER_Read>:

#ifdef DEBUG_ON
char cDebugBuffer[256];
#endif

bool POWER_Read(alt_u32 szVol[POWER_PORT_NUM]) {
81102f9c:	deffef04 	addi	sp,sp,-68
81102fa0:	de00012e 	bgeu	sp,et,81102fa8 <POWER_Read+0xc>
81102fa4:	003b68fa 	trap	3
81102fa8:	dfc01015 	stw	ra,64(sp)
81102fac:	df000f15 	stw	fp,60(sp)
81102fb0:	df000f04 	addi	fp,sp,60
81102fb4:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess = TRUE;
81102fb8:	00800044 	movi	r2,1
81102fbc:	e0bff315 	stw	r2,-52(fp)
	int i, c, nPortIndex = 0;
81102fc0:	e03ff615 	stw	zero,-40(fp)
	int szPortNum[] = { POWER_DEVICE0_PORT_NUM, POWER_DEVICE1_PORT_NUM };
81102fc4:	00800204 	movi	r2,8
81102fc8:	e0bffc15 	stw	r2,-16(fp)
81102fcc:	00800104 	movi	r2,4
81102fd0:	e0bffd15 	stw	r2,-12(fp)
	alt_u32 Value32;
	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL, PARITY;
	const bool bEN = TRUE; // alwasy update next conversion channel
81102fd4:	00800044 	movi	r2,1
81102fd8:	e0bff715 	stw	r2,-36(fp)
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
81102fdc:	00800044 	movi	r2,1
81102fe0:	e0bff815 	stw	r2,-32(fp)
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
81102fe4:	e03ff915 	stw	zero,-28(fp)
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
81102fe8:	e03ff515 	stw	zero,-44(fp)
81102fec:	00009206 	br	81103238 <POWER_Read+0x29c>
		NextChannel = 0;
81102ff0:	e03ffa05 	stb	zero,-24(fp)
		bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
81102ff4:	e0bff517 	ldw	r2,-44(fp)
81102ff8:	10c03fcc 	andi	r3,r2,255
81102ffc:	e13ffa03 	ldbu	r4,-24(fp)
81103000:	e0bfff17 	ldw	r2,-4(fp)
81103004:	d8800115 	stw	r2,4(sp)
81103008:	e0bff917 	ldw	r2,-28(fp)
8110300c:	d8800015 	stw	r2,0(sp)
81103010:	e1fff817 	ldw	r7,-32(fp)
81103014:	e1bff717 	ldw	r6,-36(fp)
81103018:	200b883a 	mov	r5,r4
8110301c:	1809883a 	mov	r4,r3
81103020:	110bedc0 	call	8110bedc <POWER_SPI_RW>
81103024:	e0bff315 	stw	r2,-52(fp)
		for (i = 0; i < szPortNum[c] && bSuccess; i++) {
81103028:	e03ff415 	stw	zero,-48(fp)
8110302c:	00007406 	br	81103200 <POWER_Read+0x264>
			NextChannel = i + 1;
81103030:	e0bff417 	ldw	r2,-48(fp)
81103034:	10800044 	addi	r2,r2,1
81103038:	e0bffa05 	stb	r2,-24(fp)
			bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &Value32);
8110303c:	e0bff517 	ldw	r2,-44(fp)
81103040:	10c03fcc 	andi	r3,r2,255
81103044:	e13ffa03 	ldbu	r4,-24(fp)
81103048:	e0bffe04 	addi	r2,fp,-8
8110304c:	d8800115 	stw	r2,4(sp)
81103050:	e0bff917 	ldw	r2,-28(fp)
81103054:	d8800015 	stw	r2,0(sp)
81103058:	e1fff817 	ldw	r7,-32(fp)
8110305c:	e1bff717 	ldw	r6,-36(fp)
81103060:	200b883a 	mov	r5,r4
81103064:	1809883a 	mov	r4,r3
81103068:	110bedc0 	call	8110bedc <POWER_SPI_RW>
8110306c:	e0bff315 	stw	r2,-52(fp)
			if (bSuccess) {
81103070:	e0bff317 	ldw	r2,-52(fp)
81103074:	10005026 	beq	r2,zero,811031b8 <POWER_Read+0x21c>
				HEAD = (Value32 >> 30) & 0x03;
81103078:	e0bffe17 	ldw	r2,-8(fp)
8110307c:	1004d7ba 	srli	r2,r2,30
81103080:	e0bffa45 	stb	r2,-23(fp)
				Channel = (Value32 >> 1) & 0x07;
81103084:	e0bffe17 	ldw	r2,-8(fp)
81103088:	1004d07a 	srli	r2,r2,1
8110308c:	108001cc 	andi	r2,r2,7
81103090:	e0bffa85 	stb	r2,-22(fp)
				SIGN = (Value32 >> 4) & 0x01;
81103094:	e0bffe17 	ldw	r2,-8(fp)
81103098:	1004d13a 	srli	r2,r2,4
8110309c:	1080004c 	andi	r2,r2,1
811030a0:	e0bffac5 	stb	r2,-21(fp)
				SGL = (Value32 >> 5) & 0x01;
811030a4:	e0bffe17 	ldw	r2,-8(fp)
811030a8:	1004d17a 	srli	r2,r2,5
811030ac:	1080004c 	andi	r2,r2,1
811030b0:	e0bffb05 	stb	r2,-20(fp)
				PARITY = Value32 & 0x01;
811030b4:	e0bffe17 	ldw	r2,-8(fp)
811030b8:	1080004c 	andi	r2,r2,1
811030bc:	e0bffb45 	stb	r2,-19(fp)
				if (HEAD != 0) {
811030c0:	e0bffa43 	ldbu	r2,-23(fp)
811030c4:	10000d26 	beq	r2,zero,811030fc <POWER_Read+0x160>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer, "[%d]Unexpected HEAD\r\n", i);
811030c8:	e1bff417 	ldw	r6,-48(fp)
811030cc:	01604574 	movhi	r5,33045
811030d0:	296ffc04 	addi	r5,r5,-16400
811030d4:	01204574 	movhi	r4,33045
811030d8:	210e1c04 	addi	r4,r4,14448
811030dc:	1122f700 	call	81122f70 <sprintf>
					debug(fp, cDebugBuffer);
811030e0:	d0a06217 	ldw	r2,-32376(gp)
811030e4:	01604574 	movhi	r5,33045
811030e8:	294e1c04 	addi	r5,r5,14448
811030ec:	1009883a 	mov	r4,r2
811030f0:	11215e00 	call	811215e0 <fprintf>
#endif
					bSuccess = FALSE;
811030f4:	e03ff315 	stw	zero,-52(fp)
811030f8:	00002206 	br	81103184 <POWER_Read+0x1e8>
				} else if (Channel != i) {
811030fc:	e0fffa83 	ldbu	r3,-22(fp)
81103100:	e0bff417 	ldw	r2,-48(fp)
81103104:	18801026 	beq	r3,r2,81103148 <POWER_Read+0x1ac>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer,
81103108:	e0bffa83 	ldbu	r2,-22(fp)
8110310c:	d8800015 	stw	r2,0(sp)
81103110:	e1fff417 	ldw	r7,-48(fp)
81103114:	e1bff417 	ldw	r6,-48(fp)
81103118:	01604574 	movhi	r5,33045
8110311c:	29700204 	addi	r5,r5,-16376
81103120:	01204574 	movhi	r4,33045
81103124:	210e1c04 	addi	r4,r4,14448
81103128:	1122f700 	call	81122f70 <sprintf>
							"[%d]Unexpected Channel. Expected:%d, Read:%d\r\n",
							i, i, Channel);
					debug(fp, cDebugBuffer);
8110312c:	d0a06217 	ldw	r2,-32376(gp)
81103130:	01604574 	movhi	r5,33045
81103134:	294e1c04 	addi	r5,r5,14448
81103138:	1009883a 	mov	r4,r2
8110313c:	11215e00 	call	811215e0 <fprintf>
#endif
					bSuccess = FALSE;
81103140:	e03ff315 	stw	zero,-52(fp)
81103144:	00000f06 	br	81103184 <POWER_Read+0x1e8>
				} else if (SIGN ^ bSIGN) {
81103148:	e0fffac3 	ldbu	r3,-21(fp)
8110314c:	e0bff817 	ldw	r2,-32(fp)
81103150:	18800c26 	beq	r3,r2,81103184 <POWER_Read+0x1e8>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer, "[%d]Unexpected SIGN\r\n", i);
81103154:	e1bff417 	ldw	r6,-48(fp)
81103158:	01604574 	movhi	r5,33045
8110315c:	29700e04 	addi	r5,r5,-16328
81103160:	01204574 	movhi	r4,33045
81103164:	210e1c04 	addi	r4,r4,14448
81103168:	1122f700 	call	81122f70 <sprintf>
					debug(fp, cDebugBuffer);
8110316c:	d0a06217 	ldw	r2,-32376(gp)
81103170:	01604574 	movhi	r5,33045
81103174:	294e1c04 	addi	r5,r5,14448
81103178:	1009883a 	mov	r4,r2
8110317c:	11215e00 	call	811215e0 <fprintf>
#endif
					bSuccess = FALSE;
81103180:	e03ff315 	stw	zero,-52(fp)
					sprintf(cDebugBuffer, "[%d]Unexpected SGL\r\n", i);
					debug(fp, cDebugBuffer);
#endif
					bSuccess = FALSE;
				}
				if (bSuccess)
81103184:	e0bff317 	ldw	r2,-52(fp)
81103188:	10001a26 	beq	r2,zero,811031f4 <POWER_Read+0x258>
					szVol[nPortIndex++] = Value32; //(Value32 >> 6) & 0xFFFFFF; // 24 bits
8110318c:	e0bff617 	ldw	r2,-40(fp)
81103190:	10c00044 	addi	r3,r2,1
81103194:	e0fff615 	stw	r3,-40(fp)
81103198:	1085883a 	add	r2,r2,r2
8110319c:	1085883a 	add	r2,r2,r2
811031a0:	1007883a 	mov	r3,r2
811031a4:	e0bfff17 	ldw	r2,-4(fp)
811031a8:	10c5883a 	add	r2,r2,r3
811031ac:	e0fffe17 	ldw	r3,-8(fp)
811031b0:	10c00015 	stw	r3,0(r2)
811031b4:	00000f06 	br	811031f4 <POWER_Read+0x258>
			} else {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "SPI Read Error\r\n");
811031b8:	00e04574 	movhi	r3,33045
811031bc:	18ce1c04 	addi	r3,r3,14448
811031c0:	00a04574 	movhi	r2,33045
811031c4:	10b01404 	addi	r2,r2,-16304
811031c8:	1009883a 	mov	r4,r2
811031cc:	00800444 	movi	r2,17
811031d0:	100d883a 	mov	r6,r2
811031d4:	200b883a 	mov	r5,r4
811031d8:	1809883a 	mov	r4,r3
811031dc:	11226900 	call	81122690 <memcpy>
				debug(fp, cDebugBuffer);
811031e0:	d0a06217 	ldw	r2,-32376(gp)
811031e4:	01604574 	movhi	r5,33045
811031e8:	294e1c04 	addi	r5,r5,14448
811031ec:	1009883a 	mov	r4,r2
811031f0:	11215e00 	call	811215e0 <fprintf>
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
		NextChannel = 0;
		bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
		for (i = 0; i < szPortNum[c] && bSuccess; i++) {
811031f4:	e0bff417 	ldw	r2,-48(fp)
811031f8:	10800044 	addi	r2,r2,1
811031fc:	e0bff415 	stw	r2,-48(fp)
81103200:	e0bff517 	ldw	r2,-44(fp)
81103204:	1085883a 	add	r2,r2,r2
81103208:	1085883a 	add	r2,r2,r2
8110320c:	e0fff304 	addi	r3,fp,-52
81103210:	1885883a 	add	r2,r3,r2
81103214:	10800904 	addi	r2,r2,36
81103218:	10800017 	ldw	r2,0(r2)
8110321c:	e0fff417 	ldw	r3,-48(fp)
81103220:	1880020e 	bge	r3,r2,8110322c <POWER_Read+0x290>
81103224:	e0bff317 	ldw	r2,-52(fp)
81103228:	103f811e 	bne	r2,zero,81103030 <__reset+0xfb0e3030>
	alt_u32 Value32;
	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL, PARITY;
	const bool bEN = TRUE; // alwasy update next conversion channel
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
8110322c:	e0bff517 	ldw	r2,-44(fp)
81103230:	10800044 	addi	r2,r2,1
81103234:	e0bff515 	stw	r2,-44(fp)
81103238:	e0bff517 	ldw	r2,-44(fp)
8110323c:	10800088 	cmpgei	r2,r2,2
81103240:	1000021e 	bne	r2,zero,8110324c <POWER_Read+0x2b0>
81103244:	e0bff317 	ldw	r2,-52(fp)
81103248:	103f691e 	bne	r2,zero,81102ff0 <__reset+0xfb0e2ff0>
				debug(fp, cDebugBuffer);
#endif
			}
		} // for i
	} // for c
	return bSuccess;
8110324c:	e0bff317 	ldw	r2,-52(fp)
}
81103250:	e037883a 	mov	sp,fp
81103254:	dfc00117 	ldw	ra,4(sp)
81103258:	df000017 	ldw	fp,0(sp)
8110325c:	dec00204 	addi	sp,sp,8
81103260:	f800283a 	ret

81103264 <TEMP_Read>:

bool TEMP_Read(alt_8 *pFpgaTemp, alt_8 *pBoardTemp) {
81103264:	defff904 	addi	sp,sp,-28
81103268:	de00012e 	bgeu	sp,et,81103270 <TEMP_Read+0xc>
8110326c:	003b68fa 	trap	3
81103270:	dfc00615 	stw	ra,24(sp)
81103274:	df000515 	stw	fp,20(sp)
81103278:	df000504 	addi	fp,sp,20
8110327c:	e13ffe15 	stw	r4,-8(fp)
81103280:	e17fff15 	stw	r5,-4(fp)
	bool bSuccess;
	const alt_u8 DeviceAddr = 0x30;
81103284:	00800c04 	movi	r2,48
81103288:	e0bffd85 	stb	r2,-10(fp)
	alt_8 FpgaTemp, BoardTemp;
	char Data;

	// read local temp
	bSuccess = I2C_Read(TEMP_SCL_BASE, TEMP_SDA_BASE, DeviceAddr, 0x00,
8110328c:	e0bffd83 	ldbu	r2,-10(fp)
81103290:	10c03fcc 	andi	r3,r2,255
81103294:	18c0201c 	xori	r3,r3,128
81103298:	18ffe004 	addi	r3,r3,-128
8110329c:	e0bffdc4 	addi	r2,fp,-9
811032a0:	d8800015 	stw	r2,0(sp)
811032a4:	000f883a 	mov	r7,zero
811032a8:	180d883a 	mov	r6,r3
811032ac:	01600034 	movhi	r5,32768
811032b0:	29426004 	addi	r5,r5,2432
811032b4:	01200034 	movhi	r4,32768
811032b8:	21026404 	addi	r4,r4,2448
811032bc:	110ae280 	call	8110ae28 <I2C_Read>
811032c0:	e0bffc15 	stw	r2,-16(fp)
			(alt_u8 *) &Data);
	if (bSuccess)
811032c4:	e0bffc17 	ldw	r2,-16(fp)
811032c8:	10000226 	beq	r2,zero,811032d4 <TEMP_Read+0x70>
		BoardTemp = Data;
811032cc:	e0bffdc3 	ldbu	r2,-9(fp)
811032d0:	e0bffd45 	stb	r2,-11(fp)

	// read remote temp
	if (bSuccess) {
811032d4:	e0bffc17 	ldw	r2,-16(fp)
811032d8:	10001226 	beq	r2,zero,81103324 <TEMP_Read+0xc0>
		bSuccess = I2C_Read(TEMP_SCL_BASE, TEMP_SDA_BASE, DeviceAddr, 0x01,
811032dc:	e0bffd83 	ldbu	r2,-10(fp)
811032e0:	10c03fcc 	andi	r3,r2,255
811032e4:	18c0201c 	xori	r3,r3,128
811032e8:	18ffe004 	addi	r3,r3,-128
811032ec:	e0bffdc4 	addi	r2,fp,-9
811032f0:	d8800015 	stw	r2,0(sp)
811032f4:	01c00044 	movi	r7,1
811032f8:	180d883a 	mov	r6,r3
811032fc:	01600034 	movhi	r5,32768
81103300:	29426004 	addi	r5,r5,2432
81103304:	01200034 	movhi	r4,32768
81103308:	21026404 	addi	r4,r4,2448
8110330c:	110ae280 	call	8110ae28 <I2C_Read>
81103310:	e0bffc15 	stw	r2,-16(fp)
				(alt_u8 *) &Data);
		if (bSuccess)
81103314:	e0bffc17 	ldw	r2,-16(fp)
81103318:	10000226 	beq	r2,zero,81103324 <TEMP_Read+0xc0>
			FpgaTemp = Data;
8110331c:	e0bffdc3 	ldbu	r2,-9(fp)
81103320:	e0bffd05 	stb	r2,-12(fp)
	}
	//
	if (bSuccess) {
81103324:	e0bffc17 	ldw	r2,-16(fp)
81103328:	10000626 	beq	r2,zero,81103344 <TEMP_Read+0xe0>
		*pFpgaTemp = FpgaTemp;
8110332c:	e0bffe17 	ldw	r2,-8(fp)
81103330:	e0fffd03 	ldbu	r3,-12(fp)
81103334:	10c00005 	stb	r3,0(r2)
		*pBoardTemp = BoardTemp;
81103338:	e0bfff17 	ldw	r2,-4(fp)
8110333c:	e0fffd43 	ldbu	r3,-11(fp)
81103340:	10c00005 	stb	r3,0(r2)
	}

	return bSuccess;
81103344:	e0bffc17 	ldw	r2,-16(fp)
}
81103348:	e037883a 	mov	sp,fp
8110334c:	dfc00117 	ldw	ra,4(sp)
81103350:	df000017 	ldw	fp,0(sp)
81103354:	dec00204 	addi	sp,sp,8
81103358:	f800283a 	ret

8110335c <sense_log_temp>:

bool sense_log_temp(alt_u8 *FpgaTemp, alt_u8 *BoardTemp) {
8110335c:	defffb04 	addi	sp,sp,-20
81103360:	de00012e 	bgeu	sp,et,81103368 <sense_log_temp+0xc>
81103364:	003b68fa 	trap	3
81103368:	dfc00415 	stw	ra,16(sp)
8110336c:	df000315 	stw	fp,12(sp)
81103370:	df000304 	addi	fp,sp,12
81103374:	e13ffe15 	stw	r4,-8(fp)
81103378:	e17fff15 	stw	r5,-4(fp)
	bool bSuccess;

	// show temp
	bSuccess = TEMP_Read((alt_8*) FpgaTemp, (alt_8*) BoardTemp);
8110337c:	e17fff17 	ldw	r5,-4(fp)
81103380:	e13ffe17 	ldw	r4,-8(fp)
81103384:	11032640 	call	81103264 <TEMP_Read>
81103388:	e0bffd15 	stw	r2,-12(fp)

	return (bSuccess);
8110338c:	e0bffd17 	ldw	r2,-12(fp)
}
81103390:	e037883a 	mov	sp,fp
81103394:	dfc00117 	ldw	ra,4(sp)
81103398:	df000017 	ldw	fp,0(sp)
8110339c:	dec00204 	addi	sp,sp,8
811033a0:	f800283a 	ret

811033a4 <sense_log>:

void sense_log(void) {
811033a4:	deff0404 	addi	sp,sp,-1008
811033a8:	de00012e 	bgeu	sp,et,811033b0 <sense_log+0xc>
811033ac:	003b68fa 	trap	3
811033b0:	dfc0fb15 	stw	ra,1004(sp)
811033b4:	df00fa15 	stw	fp,1000(sp)
811033b8:	dd40f915 	stw	r21,996(sp)
811033bc:	dd00f815 	stw	r20,992(sp)
811033c0:	dcc0f715 	stw	r19,988(sp)
811033c4:	dc80f615 	stw	r18,984(sp)
811033c8:	dc40f515 	stw	r17,980(sp)
811033cc:	dc00f415 	stw	r16,976(sp)
811033d0:	df00fa04 	addi	fp,sp,1000
	bool bSuccess;
	int i;
	const float fRef = 5.0; // 5.0V
811033d4:	00902834 	movhi	r2,16544
811033d8:	e0bf0e15 	stw	r2,-968(fp)
	float fVolDrop, fCurrent, fPower, fVol;
	alt_u32 szVol[POWER_PORT_NUM];
	alt_u32 SIG, MSB, RESULT;
	float szRes[] = { 0.003, 0.001, 0.003, 0.003, 0.003, 0.003, 0.003, 0.003,
811033dc:	008ed174 	movhi	r2,15173
811033e0:	10a6e984 	addi	r2,r2,-25690
811033e4:	e0bf2215 	stw	r2,-888(fp)
811033e8:	008ea0f4 	movhi	r2,14979
811033ec:	10849bc4 	addi	r2,r2,4719
811033f0:	e0bf2315 	stw	r2,-884(fp)
811033f4:	008ed174 	movhi	r2,15173
811033f8:	10a6e984 	addi	r2,r2,-25690
811033fc:	e0bf2415 	stw	r2,-880(fp)
81103400:	008ed174 	movhi	r2,15173
81103404:	10a6e984 	addi	r2,r2,-25690
81103408:	e0bf2515 	stw	r2,-876(fp)
8110340c:	008ed174 	movhi	r2,15173
81103410:	10a6e984 	addi	r2,r2,-25690
81103414:	e0bf2615 	stw	r2,-872(fp)
81103418:	008ed174 	movhi	r2,15173
8110341c:	10a6e984 	addi	r2,r2,-25690
81103420:	e0bf2715 	stw	r2,-868(fp)
81103424:	008ed174 	movhi	r2,15173
81103428:	10a6e984 	addi	r2,r2,-25690
8110342c:	e0bf2815 	stw	r2,-864(fp)
81103430:	008ed174 	movhi	r2,15173
81103434:	10a6e984 	addi	r2,r2,-25690
81103438:	e0bf2915 	stw	r2,-860(fp)
8110343c:	008ed174 	movhi	r2,15173
81103440:	10a6e984 	addi	r2,r2,-25690
81103444:	e0bf2a15 	stw	r2,-856(fp)
81103448:	008ed174 	movhi	r2,15173
8110344c:	10a6e984 	addi	r2,r2,-25690
81103450:	e0bf2b15 	stw	r2,-852(fp)
81103454:	008ed174 	movhi	r2,15173
81103458:	10a6e984 	addi	r2,r2,-25690
8110345c:	e0bf2c15 	stw	r2,-848(fp)
81103460:	008ed174 	movhi	r2,15173
81103464:	10a6e984 	addi	r2,r2,-25690
81103468:	e0bf2d15 	stw	r2,-844(fp)
			0.003, 0.003, 0.003, 0.003 };
	float szRefVol[] = { 0.9, 0.9, 3.0, 0.9, 1.8, 2.5, 1.8, 2.5, 1.1, 1.4, 3.3,
8110346c:	008fd9b4 	movhi	r2,16230
81103470:	10999984 	addi	r2,r2,26214
81103474:	e0bf2e15 	stw	r2,-840(fp)
81103478:	008fd9b4 	movhi	r2,16230
8110347c:	10999984 	addi	r2,r2,26214
81103480:	e0bf2f15 	stw	r2,-836(fp)
81103484:	00901034 	movhi	r2,16448
81103488:	e0bf3015 	stw	r2,-832(fp)
8110348c:	008fd9b4 	movhi	r2,16230
81103490:	10999984 	addi	r2,r2,26214
81103494:	e0bf3115 	stw	r2,-828(fp)
81103498:	008ff9b4 	movhi	r2,16358
8110349c:	10999984 	addi	r2,r2,26214
811034a0:	e0bf3215 	stw	r2,-824(fp)
811034a4:	00900834 	movhi	r2,16416
811034a8:	e0bf3315 	stw	r2,-820(fp)
811034ac:	008ff9b4 	movhi	r2,16358
811034b0:	10999984 	addi	r2,r2,26214
811034b4:	e0bf3415 	stw	r2,-816(fp)
811034b8:	00900834 	movhi	r2,16416
811034bc:	e0bf3515 	stw	r2,-812(fp)
811034c0:	008fe374 	movhi	r2,16269
811034c4:	10b33344 	addi	r2,r2,-13107
811034c8:	e0bf3615 	stw	r2,-808(fp)
811034cc:	008fecf4 	movhi	r2,16307
811034d0:	108cccc4 	addi	r2,r2,13107
811034d4:	e0bf3715 	stw	r2,-804(fp)
811034d8:	009014f4 	movhi	r2,16467
811034dc:	108cccc4 	addi	r2,r2,13107
811034e0:	e0bf3815 	stw	r2,-800(fp)
811034e4:	00900834 	movhi	r2,16416
811034e8:	e0bf3915 	stw	r2,-796(fp)
			2.5 };
	char szName[][64] = { "VCCD_PLL", "VCC0P9", "GPIO_VCCIOPD", "VCCHIP",
811034ec:	00a04574 	movhi	r2,33045
811034f0:	10b04b04 	addi	r2,r2,-16084
811034f4:	e0ff3a04 	addi	r3,fp,-792
811034f8:	1009883a 	mov	r4,r2
811034fc:	0080c004 	movi	r2,768
81103500:	100d883a 	mov	r6,r2
81103504:	200b883a 	mov	r5,r4
81103508:	1809883a 	mov	r4,r3
8110350c:	11226900 	call	81122690 <memcpy>
			"VCC1P8_34R", "HSMA_VCCIO", "VCC1P8_78R", "VCCA_PLL", "VCCL_GXB",
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };

	// show power
	bSuccess = POWER_Read(szVol);
81103510:	e0bf1604 	addi	r2,fp,-936
81103514:	1009883a 	mov	r4,r2
81103518:	1102f9c0 	call	81102f9c <POWER_Read>
8110351c:	e0bf0f15 	stw	r2,-964(fp)
	if (bSuccess) {
81103520:	e0bf0f17 	ldw	r2,-964(fp)
81103524:	10016026 	beq	r2,zero,81103aa8 <sense_log+0x704>
		for (i = 0; i < POWER_PORT_NUM && bSuccess; i++) {
81103528:	e03f0c15 	stw	zero,-976(fp)
8110352c:	00014c06 	br	81103a60 <sense_log+0x6bc>
			SIG = (szVol[i] >> 29) & 0x01;
81103530:	e0bf0c17 	ldw	r2,-976(fp)
81103534:	1085883a 	add	r2,r2,r2
81103538:	1085883a 	add	r2,r2,r2
8110353c:	e0ff0c04 	addi	r3,fp,-976
81103540:	1885883a 	add	r2,r3,r2
81103544:	10800a04 	addi	r2,r2,40
81103548:	10800017 	ldw	r2,0(r2)
8110354c:	1004d77a 	srli	r2,r2,29
81103550:	1080004c 	andi	r2,r2,1
81103554:	e0bf1015 	stw	r2,-960(fp)
			MSB = (szVol[i] >> 28) & 0x01;
81103558:	e0bf0c17 	ldw	r2,-976(fp)
8110355c:	1085883a 	add	r2,r2,r2
81103560:	1085883a 	add	r2,r2,r2
81103564:	e0ff0c04 	addi	r3,fp,-976
81103568:	1885883a 	add	r2,r3,r2
8110356c:	10800a04 	addi	r2,r2,40
81103570:	10800017 	ldw	r2,0(r2)
81103574:	1004d73a 	srli	r2,r2,28
81103578:	1080004c 	andi	r2,r2,1
8110357c:	e0bf1115 	stw	r2,-956(fp)
			RESULT = (szVol[i] >> 6) & 0x3FFFFF; // 22 bits
81103580:	e0bf0c17 	ldw	r2,-976(fp)
81103584:	1085883a 	add	r2,r2,r2
81103588:	1085883a 	add	r2,r2,r2
8110358c:	e0ff0c04 	addi	r3,fp,-976
81103590:	1885883a 	add	r2,r3,r2
81103594:	10800a04 	addi	r2,r2,40
81103598:	10800017 	ldw	r2,0(r2)
8110359c:	1006d1ba 	srli	r3,r2,6
811035a0:	00801034 	movhi	r2,64
811035a4:	10bfffc4 	addi	r2,r2,-1
811035a8:	1884703a 	and	r2,r3,r2
811035ac:	e0bf1215 	stw	r2,-952(fp)
			if (MSB == 0)
811035b0:	e0bf1117 	ldw	r2,-956(fp)
811035b4:	1000091e 	bne	r2,zero,811035dc <sense_log+0x238>
				fVolDrop = (float) (RESULT) / (float) 0x400000;
811035b8:	e13f1217 	ldw	r4,-952(fp)
811035bc:	111fdec0 	call	8111fdec <__floatunsisf>
811035c0:	1007883a 	mov	r3,r2
811035c4:	0152a034 	movhi	r5,19072
811035c8:	1809883a 	mov	r4,r3
811035cc:	111f4740 	call	8111f474 <__divsf3>
811035d0:	1007883a 	mov	r3,r2
811035d4:	e0ff0d15 	stw	r3,-972(fp)
811035d8:	00000106 	br	811035e0 <sense_log+0x23c>
			else
				fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
811035dc:	e03f0d15 	stw	zero,-972(fp)
			if (SIG && MSB) {
811035e0:	e0bf1017 	ldw	r2,-960(fp)
811035e4:	10002626 	beq	r2,zero,81103680 <sense_log+0x2dc>
811035e8:	e0bf1117 	ldw	r2,-956(fp)
811035ec:	10002426 	beq	r2,zero,81103680 <sense_log+0x2dc>
				fVol = fRef * 0.5;
811035f0:	014fc034 	movhi	r5,16128
811035f4:	e13f0e17 	ldw	r4,-968(fp)
811035f8:	111f8bc0 	call	8111f8bc <__mulsf3>
811035fc:	1007883a 	mov	r3,r2
81103600:	e0ff1315 	stw	r3,-948(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Over]\r\n  VolDrop:%f(V)\r\n",
						szName[i], (int) szVol[i], fVol);
81103604:	e0ff3a04 	addi	r3,fp,-792
81103608:	e0bf0c17 	ldw	r2,-976(fp)
8110360c:	100491ba 	slli	r2,r2,6
81103610:	18a1883a 	add	r16,r3,r2
81103614:	e0bf0c17 	ldw	r2,-976(fp)
81103618:	1085883a 	add	r2,r2,r2
8110361c:	1085883a 	add	r2,r2,r2
81103620:	e0ff0c04 	addi	r3,fp,-976
81103624:	1885883a 	add	r2,r3,r2
81103628:	10800a04 	addi	r2,r2,40
8110362c:	10800017 	ldw	r2,0(r2)
			else
				fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
			if (SIG && MSB) {
				fVol = fRef * 0.5;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Over]\r\n  VolDrop:%f(V)\r\n",
81103630:	1023883a 	mov	r17,r2
81103634:	e13f1317 	ldw	r4,-948(fp)
81103638:	11211480 	call	81121148 <__extendsfdf2>
8110363c:	1009883a 	mov	r4,r2
81103640:	180b883a 	mov	r5,r3
81103644:	d9000015 	stw	r4,0(sp)
81103648:	d9400115 	stw	r5,4(sp)
8110364c:	880f883a 	mov	r7,r17
81103650:	800d883a 	mov	r6,r16
81103654:	01604574 	movhi	r5,33045
81103658:	29701904 	addi	r5,r5,-16284
8110365c:	01204574 	movhi	r4,33045
81103660:	210e1c04 	addi	r4,r4,14448
81103664:	1122f700 	call	81122f70 <sprintf>
						szName[i], (int) szVol[i], fVol);
				debug(fp, cDebugBuffer);
81103668:	d0a06217 	ldw	r2,-32376(gp)
8110366c:	01604574 	movhi	r5,33045
81103670:	294e1c04 	addi	r5,r5,14448
81103674:	1009883a 	mov	r4,r2
81103678:	11215e00 	call	811215e0 <fprintf>
8110367c:	0000f506 	br	81103a54 <sense_log+0x6b0>
#endif
			} else if (SIG && !MSB) {
81103680:	e0bf1017 	ldw	r2,-960(fp)
81103684:	10006426 	beq	r2,zero,81103818 <sense_log+0x474>
81103688:	e0bf1117 	ldw	r2,-956(fp)
8110368c:	1000621e 	bne	r2,zero,81103818 <sense_log+0x474>
				fVol = fRef * 0.5 * fVolDrop;
81103690:	e13f0e17 	ldw	r4,-968(fp)
81103694:	11211480 	call	81121148 <__extendsfdf2>
81103698:	1011883a 	mov	r8,r2
8110369c:	1813883a 	mov	r9,r3
811036a0:	000d883a 	mov	r6,zero
811036a4:	01cff834 	movhi	r7,16352
811036a8:	4009883a 	mov	r4,r8
811036ac:	480b883a 	mov	r5,r9
811036b0:	111ffc00 	call	8111ffc0 <__muldf3>
811036b4:	1009883a 	mov	r4,r2
811036b8:	180b883a 	mov	r5,r3
811036bc:	2021883a 	mov	r16,r4
811036c0:	2823883a 	mov	r17,r5
811036c4:	e13f0d17 	ldw	r4,-972(fp)
811036c8:	11211480 	call	81121148 <__extendsfdf2>
811036cc:	1009883a 	mov	r4,r2
811036d0:	180b883a 	mov	r5,r3
811036d4:	200d883a 	mov	r6,r4
811036d8:	280f883a 	mov	r7,r5
811036dc:	8009883a 	mov	r4,r16
811036e0:	880b883a 	mov	r5,r17
811036e4:	111ffc00 	call	8111ffc0 <__muldf3>
811036e8:	1009883a 	mov	r4,r2
811036ec:	180b883a 	mov	r5,r3
811036f0:	2005883a 	mov	r2,r4
811036f4:	2807883a 	mov	r3,r5
811036f8:	1009883a 	mov	r4,r2
811036fc:	180b883a 	mov	r5,r3
81103700:	11212600 	call	81121260 <__truncdfsf2>
81103704:	1007883a 	mov	r3,r2
81103708:	e0ff1315 	stw	r3,-948(fp)
				fCurrent = fVolDrop / szRes[i];
8110370c:	e0bf0c17 	ldw	r2,-976(fp)
81103710:	1085883a 	add	r2,r2,r2
81103714:	1085883a 	add	r2,r2,r2
81103718:	e0ff0c04 	addi	r3,fp,-976
8110371c:	1885883a 	add	r2,r3,r2
81103720:	10801604 	addi	r2,r2,88
81103724:	10c00017 	ldw	r3,0(r2)
81103728:	180b883a 	mov	r5,r3
8110372c:	e13f0d17 	ldw	r4,-972(fp)
81103730:	111f4740 	call	8111f474 <__divsf3>
81103734:	1007883a 	mov	r3,r2
81103738:	e0ff1415 	stw	r3,-944(fp)
				fPower = szRefVol[i] * fCurrent;
8110373c:	e0bf0c17 	ldw	r2,-976(fp)
81103740:	1085883a 	add	r2,r2,r2
81103744:	1085883a 	add	r2,r2,r2
81103748:	e0ff0c04 	addi	r3,fp,-976
8110374c:	1885883a 	add	r2,r3,r2
81103750:	10802204 	addi	r2,r2,136
81103754:	10c00017 	ldw	r3,0(r2)
81103758:	e17f1417 	ldw	r5,-944(fp)
8110375c:	1809883a 	mov	r4,r3
81103760:	111f8bc0 	call	8111f8bc <__mulsf3>
81103764:	1007883a 	mov	r3,r2
81103768:	e0ff1515 	stw	r3,-940(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"[%s:%06XH,Pos]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
8110376c:	e0ff3a04 	addi	r3,fp,-792
81103770:	e0bf0c17 	ldw	r2,-976(fp)
81103774:	100491ba 	slli	r2,r2,6
81103778:	18a9883a 	add	r20,r3,r2
8110377c:	e0bf0c17 	ldw	r2,-976(fp)
81103780:	1085883a 	add	r2,r2,r2
81103784:	1085883a 	add	r2,r2,r2
81103788:	e0ff0c04 	addi	r3,fp,-976
8110378c:	1885883a 	add	r2,r3,r2
81103790:	10800a04 	addi	r2,r2,40
81103794:	10800017 	ldw	r2,0(r2)
			} else if (SIG && !MSB) {
				fVol = fRef * 0.5 * fVolDrop;
				fCurrent = fVolDrop / szRes[i];
				fPower = szRefVol[i] * fCurrent;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81103798:	102b883a 	mov	r21,r2
8110379c:	e13f0d17 	ldw	r4,-972(fp)
811037a0:	11211480 	call	81121148 <__extendsfdf2>
811037a4:	1021883a 	mov	r16,r2
811037a8:	1823883a 	mov	r17,r3
811037ac:	e13f1417 	ldw	r4,-944(fp)
811037b0:	11211480 	call	81121148 <__extendsfdf2>
811037b4:	1025883a 	mov	r18,r2
811037b8:	1827883a 	mov	r19,r3
811037bc:	e13f1517 	ldw	r4,-940(fp)
811037c0:	11211480 	call	81121148 <__extendsfdf2>
811037c4:	1009883a 	mov	r4,r2
811037c8:	180b883a 	mov	r5,r3
811037cc:	d9000415 	stw	r4,16(sp)
811037d0:	d9400515 	stw	r5,20(sp)
811037d4:	dc800215 	stw	r18,8(sp)
811037d8:	dcc00315 	stw	r19,12(sp)
811037dc:	dc000015 	stw	r16,0(sp)
811037e0:	dc400115 	stw	r17,4(sp)
811037e4:	a80f883a 	mov	r7,r21
811037e8:	a00d883a 	mov	r6,r20
811037ec:	01604574 	movhi	r5,33045
811037f0:	29702204 	addi	r5,r5,-16248
811037f4:	01204574 	movhi	r4,33045
811037f8:	210e1c04 	addi	r4,r4,14448
811037fc:	1122f700 	call	81122f70 <sprintf>
						"[%s:%06XH,Pos]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
				debug(fp, cDebugBuffer);
81103800:	d0a06217 	ldw	r2,-32376(gp)
81103804:	01604574 	movhi	r5,33045
81103808:	294e1c04 	addi	r5,r5,14448
8110380c:	1009883a 	mov	r4,r2
81103810:	11215e00 	call	811215e0 <fprintf>
81103814:	00008f06 	br	81103a54 <sense_log+0x6b0>
#endif
			} else if (!SIG && MSB) {
81103818:	e0bf1017 	ldw	r2,-960(fp)
8110381c:	1000641e 	bne	r2,zero,811039b0 <sense_log+0x60c>
81103820:	e0bf1117 	ldw	r2,-956(fp)
81103824:	10006226 	beq	r2,zero,811039b0 <sense_log+0x60c>
				fVol = fRef * 0.5 * fVolDrop;
81103828:	e13f0e17 	ldw	r4,-968(fp)
8110382c:	11211480 	call	81121148 <__extendsfdf2>
81103830:	1011883a 	mov	r8,r2
81103834:	1813883a 	mov	r9,r3
81103838:	000d883a 	mov	r6,zero
8110383c:	01cff834 	movhi	r7,16352
81103840:	4009883a 	mov	r4,r8
81103844:	480b883a 	mov	r5,r9
81103848:	111ffc00 	call	8111ffc0 <__muldf3>
8110384c:	1009883a 	mov	r4,r2
81103850:	180b883a 	mov	r5,r3
81103854:	2021883a 	mov	r16,r4
81103858:	2823883a 	mov	r17,r5
8110385c:	e13f0d17 	ldw	r4,-972(fp)
81103860:	11211480 	call	81121148 <__extendsfdf2>
81103864:	1009883a 	mov	r4,r2
81103868:	180b883a 	mov	r5,r3
8110386c:	200d883a 	mov	r6,r4
81103870:	280f883a 	mov	r7,r5
81103874:	8009883a 	mov	r4,r16
81103878:	880b883a 	mov	r5,r17
8110387c:	111ffc00 	call	8111ffc0 <__muldf3>
81103880:	1009883a 	mov	r4,r2
81103884:	180b883a 	mov	r5,r3
81103888:	2005883a 	mov	r2,r4
8110388c:	2807883a 	mov	r3,r5
81103890:	1009883a 	mov	r4,r2
81103894:	180b883a 	mov	r5,r3
81103898:	11212600 	call	81121260 <__truncdfsf2>
8110389c:	1007883a 	mov	r3,r2
811038a0:	e0ff1315 	stw	r3,-948(fp)
				fCurrent = fVolDrop / szRes[i];
811038a4:	e0bf0c17 	ldw	r2,-976(fp)
811038a8:	1085883a 	add	r2,r2,r2
811038ac:	1085883a 	add	r2,r2,r2
811038b0:	e0ff0c04 	addi	r3,fp,-976
811038b4:	1885883a 	add	r2,r3,r2
811038b8:	10801604 	addi	r2,r2,88
811038bc:	10c00017 	ldw	r3,0(r2)
811038c0:	180b883a 	mov	r5,r3
811038c4:	e13f0d17 	ldw	r4,-972(fp)
811038c8:	111f4740 	call	8111f474 <__divsf3>
811038cc:	1007883a 	mov	r3,r2
811038d0:	e0ff1415 	stw	r3,-944(fp)
				fPower = szRefVol[i] * fCurrent;
811038d4:	e0bf0c17 	ldw	r2,-976(fp)
811038d8:	1085883a 	add	r2,r2,r2
811038dc:	1085883a 	add	r2,r2,r2
811038e0:	e0ff0c04 	addi	r3,fp,-976
811038e4:	1885883a 	add	r2,r3,r2
811038e8:	10802204 	addi	r2,r2,136
811038ec:	10c00017 	ldw	r3,0(r2)
811038f0:	e17f1417 	ldw	r5,-944(fp)
811038f4:	1809883a 	mov	r4,r3
811038f8:	111f8bc0 	call	8111f8bc <__mulsf3>
811038fc:	1007883a 	mov	r3,r2
81103900:	e0ff1515 	stw	r3,-940(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"[%s:%06XH,Neg]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
81103904:	e0ff3a04 	addi	r3,fp,-792
81103908:	e0bf0c17 	ldw	r2,-976(fp)
8110390c:	100491ba 	slli	r2,r2,6
81103910:	18a9883a 	add	r20,r3,r2
81103914:	e0bf0c17 	ldw	r2,-976(fp)
81103918:	1085883a 	add	r2,r2,r2
8110391c:	1085883a 	add	r2,r2,r2
81103920:	e0ff0c04 	addi	r3,fp,-976
81103924:	1885883a 	add	r2,r3,r2
81103928:	10800a04 	addi	r2,r2,40
8110392c:	10800017 	ldw	r2,0(r2)
			} else if (!SIG && MSB) {
				fVol = fRef * 0.5 * fVolDrop;
				fCurrent = fVolDrop / szRes[i];
				fPower = szRefVol[i] * fCurrent;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81103930:	102b883a 	mov	r21,r2
81103934:	e13f0d17 	ldw	r4,-972(fp)
81103938:	11211480 	call	81121148 <__extendsfdf2>
8110393c:	1021883a 	mov	r16,r2
81103940:	1823883a 	mov	r17,r3
81103944:	e13f1417 	ldw	r4,-944(fp)
81103948:	11211480 	call	81121148 <__extendsfdf2>
8110394c:	1025883a 	mov	r18,r2
81103950:	1827883a 	mov	r19,r3
81103954:	e13f1517 	ldw	r4,-940(fp)
81103958:	11211480 	call	81121148 <__extendsfdf2>
8110395c:	1009883a 	mov	r4,r2
81103960:	180b883a 	mov	r5,r3
81103964:	d9000415 	stw	r4,16(sp)
81103968:	d9400515 	stw	r5,20(sp)
8110396c:	dc800215 	stw	r18,8(sp)
81103970:	dcc00315 	stw	r19,12(sp)
81103974:	dc000015 	stw	r16,0(sp)
81103978:	dc400115 	stw	r17,4(sp)
8110397c:	a80f883a 	mov	r7,r21
81103980:	a00d883a 	mov	r6,r20
81103984:	01604574 	movhi	r5,33045
81103988:	29703204 	addi	r5,r5,-16184
8110398c:	01204574 	movhi	r4,33045
81103990:	210e1c04 	addi	r4,r4,14448
81103994:	1122f700 	call	81122f70 <sprintf>
						"[%s:%06XH,Neg]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
				debug(fp, cDebugBuffer);
81103998:	d0a06217 	ldw	r2,-32376(gp)
8110399c:	01604574 	movhi	r5,33045
811039a0:	294e1c04 	addi	r5,r5,14448
811039a4:	1009883a 	mov	r4,r2
811039a8:	11215e00 	call	811215e0 <fprintf>
811039ac:	00002906 	br	81103a54 <sense_log+0x6b0>
#endif
			} else if (!SIG && !MSB) {
811039b0:	e0bf1017 	ldw	r2,-960(fp)
811039b4:	1000271e 	bne	r2,zero,81103a54 <sense_log+0x6b0>
811039b8:	e0bf1117 	ldw	r2,-956(fp)
811039bc:	1000251e 	bne	r2,zero,81103a54 <sense_log+0x6b0>
				fVol = -fRef * 0.5;
811039c0:	e0bf0e17 	ldw	r2,-968(fp)
811039c4:	10a0003c 	xorhi	r2,r2,32768
811039c8:	014fc034 	movhi	r5,16128
811039cc:	1009883a 	mov	r4,r2
811039d0:	111f8bc0 	call	8111f8bc <__mulsf3>
811039d4:	1007883a 	mov	r3,r2
811039d8:	e0ff1315 	stw	r3,-948(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Under]\r\n  VolDrop:%f(V)\r\n",
						szName[i], (int) szVol[i], fVol);
811039dc:	e0ff3a04 	addi	r3,fp,-792
811039e0:	e0bf0c17 	ldw	r2,-976(fp)
811039e4:	100491ba 	slli	r2,r2,6
811039e8:	18a1883a 	add	r16,r3,r2
811039ec:	e0bf0c17 	ldw	r2,-976(fp)
811039f0:	1085883a 	add	r2,r2,r2
811039f4:	1085883a 	add	r2,r2,r2
811039f8:	e0ff0c04 	addi	r3,fp,-976
811039fc:	1885883a 	add	r2,r3,r2
81103a00:	10800a04 	addi	r2,r2,40
81103a04:	10800017 	ldw	r2,0(r2)
				debug(fp, cDebugBuffer);
#endif
			} else if (!SIG && !MSB) {
				fVol = -fRef * 0.5;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Under]\r\n  VolDrop:%f(V)\r\n",
81103a08:	1023883a 	mov	r17,r2
81103a0c:	e13f1317 	ldw	r4,-948(fp)
81103a10:	11211480 	call	81121148 <__extendsfdf2>
81103a14:	1009883a 	mov	r4,r2
81103a18:	180b883a 	mov	r5,r3
81103a1c:	d9000015 	stw	r4,0(sp)
81103a20:	d9400115 	stw	r5,4(sp)
81103a24:	880f883a 	mov	r7,r17
81103a28:	800d883a 	mov	r6,r16
81103a2c:	01604574 	movhi	r5,33045
81103a30:	29704204 	addi	r5,r5,-16120
81103a34:	01204574 	movhi	r4,33045
81103a38:	210e1c04 	addi	r4,r4,14448
81103a3c:	1122f700 	call	81122f70 <sprintf>
						szName[i], (int) szVol[i], fVol);
				debug(fp, cDebugBuffer);
81103a40:	d0a06217 	ldw	r2,-32376(gp)
81103a44:	01604574 	movhi	r5,33045
81103a48:	294e1c04 	addi	r5,r5,14448
81103a4c:	1009883a 	mov	r4,r2
81103a50:	11215e00 	call	811215e0 <fprintf>
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };

	// show power
	bSuccess = POWER_Read(szVol);
	if (bSuccess) {
		for (i = 0; i < POWER_PORT_NUM && bSuccess; i++) {
81103a54:	e0bf0c17 	ldw	r2,-976(fp)
81103a58:	10800044 	addi	r2,r2,1
81103a5c:	e0bf0c15 	stw	r2,-976(fp)
81103a60:	e0bf0c17 	ldw	r2,-976(fp)
81103a64:	10800308 	cmpgei	r2,r2,12
81103a68:	1000021e 	bne	r2,zero,81103a74 <sense_log+0x6d0>
81103a6c:	e0bf0f17 	ldw	r2,-964(fp)
81103a70:	103eaf1e 	bne	r2,zero,81103530 <__reset+0xfb0e3530>
				debug(fp, cDebugBuffer);
#endif
			}
		}
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "\r\n");
81103a74:	00a04574 	movhi	r2,33045
81103a78:	108e1c04 	addi	r2,r2,14448
81103a7c:	00c00344 	movi	r3,13
81103a80:	10c00005 	stb	r3,0(r2)
81103a84:	00c00284 	movi	r3,10
81103a88:	10c00045 	stb	r3,1(r2)
81103a8c:	10000085 	stb	zero,2(r2)
		debug(fp, cDebugBuffer);
81103a90:	d0a06217 	ldw	r2,-32376(gp)
81103a94:	01604574 	movhi	r5,33045
81103a98:	294e1c04 	addi	r5,r5,14448
81103a9c:	1009883a 	mov	r4,r2
81103aa0:	11215e00 	call	811215e0 <fprintf>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Error\r\n");
		debug(fp, cDebugBuffer);
#endif
	}
}
81103aa4:	00001606 	br	81103b00 <sense_log+0x75c>
		sprintf(cDebugBuffer, "\r\n");
		debug(fp, cDebugBuffer);
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Error\r\n");
81103aa8:	00a04574 	movhi	r2,33045
81103aac:	108e1c04 	addi	r2,r2,14448
81103ab0:	00c01144 	movi	r3,69
81103ab4:	10c00005 	stb	r3,0(r2)
81103ab8:	00c01c84 	movi	r3,114
81103abc:	10c00045 	stb	r3,1(r2)
81103ac0:	00c01c84 	movi	r3,114
81103ac4:	10c00085 	stb	r3,2(r2)
81103ac8:	00c01bc4 	movi	r3,111
81103acc:	10c000c5 	stb	r3,3(r2)
81103ad0:	00c01c84 	movi	r3,114
81103ad4:	10c00105 	stb	r3,4(r2)
81103ad8:	00c00344 	movi	r3,13
81103adc:	10c00145 	stb	r3,5(r2)
81103ae0:	00c00284 	movi	r3,10
81103ae4:	10c00185 	stb	r3,6(r2)
81103ae8:	100001c5 	stb	zero,7(r2)
		debug(fp, cDebugBuffer);
81103aec:	d0a06217 	ldw	r2,-32376(gp)
81103af0:	01604574 	movhi	r5,33045
81103af4:	294e1c04 	addi	r5,r5,14448
81103af8:	1009883a 	mov	r4,r2
81103afc:	11215e00 	call	811215e0 <fprintf>
#endif
	}
}
81103b00:	0001883a 	nop
81103b04:	e6fffa04 	addi	sp,fp,-24
81103b08:	dfc00717 	ldw	ra,28(sp)
81103b0c:	df000617 	ldw	fp,24(sp)
81103b10:	dd400517 	ldw	r21,20(sp)
81103b14:	dd000417 	ldw	r20,16(sp)
81103b18:	dcc00317 	ldw	r19,12(sp)
81103b1c:	dc800217 	ldw	r18,8(sp)
81103b20:	dc400117 	ldw	r17,4(sp)
81103b24:	dc000017 	ldw	r16,0(sp)
81103b28:	dec00804 	addi	sp,sp,32
81103b2c:	f800283a 	ret

81103b30 <bSdmaInitM1Dma>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bSdmaInitM1Dma(void) {
81103b30:	defffc04 	addi	sp,sp,-16
81103b34:	de00012e 	bgeu	sp,et,81103b3c <bSdmaInitM1Dma+0xc>
81103b38:	003b68fa 	trap	3
81103b3c:	dfc00315 	stw	ra,12(sp)
81103b40:	df000215 	stw	fp,8(sp)
81103b44:	df000204 	addi	fp,sp,8
	bool bStatus = TRUE;
81103b48:	00800044 	movi	r2,1
81103b4c:	e0bffe15 	stw	r2,-8(fp)
	alt_u16 usiCounter = 0;
81103b50:	e03fff0d 	sth	zero,-4(fp)

	// open dma device
	pxDmaM1Dev = alt_msgdma_open((char *) SDMA_DMA_M1_NAME);
81103b54:	01204574 	movhi	r4,33045
81103b58:	21310b04 	addi	r4,r4,-15316
81103b5c:	1149dac0 	call	81149dac <alt_msgdma_open>
81103b60:	d0a03915 	stw	r2,-32540(gp)

	// check if the device was opened
	if (pxDmaM1Dev == NULL) {
81103b64:	d0a03917 	ldw	r2,-32540(gp)
81103b68:	1000021e 	bne	r2,zero,81103b74 <bSdmaInitM1Dma+0x44>
		// device not opened
		bStatus = FALSE;
81103b6c:	e03ffe15 	stw	zero,-8(fp)
81103b70:	00001506 	br	81103bc8 <bSdmaInitM1Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
81103b74:	d0a03917 	ldw	r2,-32540(gp)
81103b78:	10800317 	ldw	r2,12(r2)
81103b7c:	10800104 	addi	r2,r2,4
81103b80:	00c00084 	movi	r3,2
81103b84:	10c00035 	stwio	r3,0(r2)
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103b88:	00000a06 	br	81103bb4 <bSdmaInitM1Dma+0x84>
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
			usleep(1);
81103b8c:	01000044 	movi	r4,1
81103b90:	1137d140 	call	81137d14 <usleep>
			usiCounter++;
81103b94:	e0bfff0b 	ldhu	r2,-4(fp)
81103b98:	10800044 	addi	r2,r2,1
81103b9c:	e0bfff0d 	sth	r2,-4(fp)
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
81103ba0:	e0bfff0b 	ldhu	r2,-4(fp)
81103ba4:	1084e230 	cmpltui	r2,r2,5000
81103ba8:	1000021e 	bne	r2,zero,81103bb4 <bSdmaInitM1Dma+0x84>
				bStatus = FALSE;
81103bac:	e03ffe15 	stw	zero,-8(fp)
				break;
81103bb0:	00000506 	br	81103bc8 <bSdmaInitM1Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103bb4:	d0a03917 	ldw	r2,-32540(gp)
81103bb8:	10800317 	ldw	r2,12(r2)
81103bbc:	10800037 	ldwio	r2,0(r2)
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103bc0:	1080100c 	andi	r2,r2,64
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103bc4:	103ff11e 	bne	r2,zero,81103b8c <__reset+0xfb0e3b8c>
				break;
			}
		}
	}

	return bStatus;
81103bc8:	e0bffe17 	ldw	r2,-8(fp)
}
81103bcc:	e037883a 	mov	sp,fp
81103bd0:	dfc00117 	ldw	ra,4(sp)
81103bd4:	df000017 	ldw	fp,0(sp)
81103bd8:	dec00204 	addi	sp,sp,8
81103bdc:	f800283a 	ret

81103be0 <bSdmaInitM2Dma>:

bool bSdmaInitM2Dma(void) {
81103be0:	defffc04 	addi	sp,sp,-16
81103be4:	de00012e 	bgeu	sp,et,81103bec <bSdmaInitM2Dma+0xc>
81103be8:	003b68fa 	trap	3
81103bec:	dfc00315 	stw	ra,12(sp)
81103bf0:	df000215 	stw	fp,8(sp)
81103bf4:	df000204 	addi	fp,sp,8
	bool bStatus = TRUE;
81103bf8:	00800044 	movi	r2,1
81103bfc:	e0bffe15 	stw	r2,-8(fp)
	alt_u16 usiCounter = 0;
81103c00:	e03fff0d 	sth	zero,-4(fp)

	// open dma device
	pxDmaM2Dev = alt_msgdma_open((char *) SDMA_DMA_M2_NAME);
81103c04:	01204574 	movhi	r4,33045
81103c08:	21311004 	addi	r4,r4,-15296
81103c0c:	1149dac0 	call	81149dac <alt_msgdma_open>
81103c10:	d0a03a15 	stw	r2,-32536(gp)

	// check if the device was opened
	if (pxDmaM2Dev == NULL) {
81103c14:	d0a03a17 	ldw	r2,-32536(gp)
81103c18:	1000021e 	bne	r2,zero,81103c24 <bSdmaInitM2Dma+0x44>
		// device not opened
		bStatus = FALSE;
81103c1c:	e03ffe15 	stw	zero,-8(fp)
81103c20:	00001506 	br	81103c78 <bSdmaInitM2Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
81103c24:	d0a03a17 	ldw	r2,-32536(gp)
81103c28:	10800317 	ldw	r2,12(r2)
81103c2c:	10800104 	addi	r2,r2,4
81103c30:	00c00084 	movi	r3,2
81103c34:	10c00035 	stwio	r3,0(r2)
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103c38:	00000a06 	br	81103c64 <bSdmaInitM2Dma+0x84>
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
			usleep(1);
81103c3c:	01000044 	movi	r4,1
81103c40:	1137d140 	call	81137d14 <usleep>
			usiCounter++;
81103c44:	e0bfff0b 	ldhu	r2,-4(fp)
81103c48:	10800044 	addi	r2,r2,1
81103c4c:	e0bfff0d 	sth	r2,-4(fp)
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
81103c50:	e0bfff0b 	ldhu	r2,-4(fp)
81103c54:	1084e230 	cmpltui	r2,r2,5000
81103c58:	1000021e 	bne	r2,zero,81103c64 <bSdmaInitM2Dma+0x84>
				bStatus = FALSE;
81103c5c:	e03ffe15 	stw	zero,-8(fp)
				break;
81103c60:	00000506 	br	81103c78 <bSdmaInitM2Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103c64:	d0a03a17 	ldw	r2,-32536(gp)
81103c68:	10800317 	ldw	r2,12(r2)
81103c6c:	10800037 	ldwio	r2,0(r2)
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103c70:	1080100c 	andi	r2,r2,64
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103c74:	103ff11e 	bne	r2,zero,81103c3c <__reset+0xfb0e3c3c>
				break;
			}
		}
	}

	return bStatus;
81103c78:	e0bffe17 	ldw	r2,-8(fp)
}
81103c7c:	e037883a 	mov	sp,fp
81103c80:	dfc00117 	ldw	ra,4(sp)
81103c84:	df000017 	ldw	fp,0(sp)
81103c88:	dec00204 	addi	sp,sp,8
81103c8c:	f800283a 	ret

81103c90 <bSdmaDmaM1Transfer>:
//		}
//	}
//	return bStatus;
//}

bool bSdmaDmaM1Transfer(alt_u32 *uliDdrInitialAddr, alt_u16 usiTransferSizeInBlocks, alt_u8 ucBufferSide, alt_u8 ucChBufferId) {
81103c90:	deffe804 	addi	sp,sp,-96
81103c94:	de00012e 	bgeu	sp,et,81103c9c <bSdmaDmaM1Transfer+0xc>
81103c98:	003b68fa 	trap	3
81103c9c:	dfc01715 	stw	ra,92(sp)
81103ca0:	df001615 	stw	fp,88(sp)
81103ca4:	dc001515 	stw	r16,84(sp)
81103ca8:	df001604 	addi	fp,sp,88
81103cac:	e13ffb15 	stw	r4,-20(fp)
81103cb0:	2809883a 	mov	r4,r5
81103cb4:	3007883a 	mov	r3,r6
81103cb8:	3805883a 	mov	r2,r7
81103cbc:	e13ffc0d 	sth	r4,-16(fp)
81103cc0:	e0fffd05 	stb	r3,-12(fp)
81103cc4:	e0bffe05 	stb	r2,-8(fp)
81103cc8:	defff004 	addi	sp,sp,-64
81103ccc:	d8800904 	addi	r2,sp,36
81103cd0:	108007c4 	addi	r2,r2,31
81103cd4:	1004d17a 	srli	r2,r2,5
81103cd8:	1020917a 	slli	r16,r2,5
	bool bStatus = TRUE;
81103cdc:	00800044 	movi	r2,1
81103ce0:	e0bff315 	stw	r2,-52(fp)
	alt_u16 usiCnt = 0;
81103ce4:	e03ff70d 	sth	zero,-36(fp)

	alt_msgdma_extended_descriptor xDmaExtendedDescriptor;

	alt_u32 uliDestAddrLow = 0;
81103ce8:	e03ff415 	stw	zero,-48(fp)
	alt_u32 uliDestAddrHigh = 0;
81103cec:	e03ff515 	stw	zero,-44(fp)

	alt_u32 uliSrcAddrLow = 0;
81103cf0:	e03ff815 	stw	zero,-32(fp)
	alt_u32 uliSrcAddrHigh = 0;
81103cf4:	e03ff915 	stw	zero,-28(fp)

	alt_u32 uliControlBits = 0x00000000;
81103cf8:	e03ffa15 	stw	zero,-24(fp)

	bool bBufferEmptyFlag = FALSE;
81103cfc:	e03ff615 	stw	zero,-40(fp)

	switch (ucChBufferId) {
81103d00:	e0bffe03 	ldbu	r2,-8(fp)
81103d04:	10c00228 	cmpgeui	r3,r2,8
81103d08:	1800b81e 	bne	r3,zero,81103fec <bSdmaDmaM1Transfer+0x35c>
81103d0c:	100690ba 	slli	r3,r2,2
81103d10:	00a04434 	movhi	r2,33040
81103d14:	108f4904 	addi	r2,r2,15652
81103d18:	1885883a 	add	r2,r3,r2
81103d1c:	10800017 	ldw	r2,0(r2)
81103d20:	1000683a 	jmp	r2
81103d24:	81103d44 	addi	r4,r16,16629
81103d28:	81103d98 	cmpnei	r4,r16,16630
81103d2c:	81103df4 	orhi	r4,r16,16631
81103d30:	81103e48 	cmpgei	r4,r16,16633
81103d34:	81103e9c 	xori	r4,r16,16634
81103d38:	81103ef0 	cmpltui	r4,r16,16635
81103d3c:	81103f44 	addi	r4,r16,16637
81103d40:	81103f98 	cmpnei	r4,r16,16638
	case eSdmaCh1Buffer:
		switch (ucBufferSide) {
81103d44:	e0bffd03 	ldbu	r2,-12(fp)
81103d48:	10000826 	beq	r2,zero,81103d6c <bSdmaDmaM1Transfer+0xdc>
81103d4c:	10800060 	cmpeqi	r2,r2,1
81103d50:	10000d26 	beq	r2,zero,81103d88 <bSdmaDmaM1Transfer+0xf8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_LOW;
81103d54:	e03ff415 	stw	zero,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_HIGH;
81103d58:	00800044 	movi	r2,1
81103d5c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh1RightBufferEmpty();
81103d60:	11067b00 	call	811067b0 <bFeebGetCh1RightBufferEmpty>
81103d64:	e0bff615 	stw	r2,-40(fp)
			break;
81103d68:	00000a06 	br	81103d94 <bSdmaDmaM1Transfer+0x104>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_LOW;
81103d6c:	00800074 	movhi	r2,1
81103d70:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_HIGH;
81103d74:	00800044 	movi	r2,1
81103d78:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh1LeftBufferEmpty();
81103d7c:	11067480 	call	81106748 <bFeebGetCh1LeftBufferEmpty>
81103d80:	e0bff615 	stw	r2,-40(fp)
			break;
81103d84:	00000306 	br	81103d94 <bSdmaDmaM1Transfer+0x104>
		default:
			bStatus = FALSE;
81103d88:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81103d8c:	e03ff615 	stw	zero,-40(fp)
			break;
81103d90:	0001883a 	nop
		}
		break;
81103d94:	00009706 	br	81103ff4 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh2Buffer:
		switch (ucBufferSide) {
81103d98:	e0bffd03 	ldbu	r2,-12(fp)
81103d9c:	10000926 	beq	r2,zero,81103dc4 <bSdmaDmaM1Transfer+0x134>
81103da0:	10800060 	cmpeqi	r2,r2,1
81103da4:	10000f26 	beq	r2,zero,81103de4 <bSdmaDmaM1Transfer+0x154>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_LOW;
81103da8:	00880004 	movi	r2,8192
81103dac:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_HIGH;
81103db0:	00800044 	movi	r2,1
81103db4:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh2RightBufferEmpty();
81103db8:	11068800 	call	81106880 <bFeebGetCh2RightBufferEmpty>
81103dbc:	e0bff615 	stw	r2,-40(fp)
			break;
81103dc0:	00000b06 	br	81103df0 <bSdmaDmaM1Transfer+0x160>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_LOW;
81103dc4:	00800074 	movhi	r2,1
81103dc8:	10880004 	addi	r2,r2,8192
81103dcc:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_HIGH;
81103dd0:	00800044 	movi	r2,1
81103dd4:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh2LeftBufferEmpty();
81103dd8:	11068180 	call	81106818 <bFeebGetCh2LeftBufferEmpty>
81103ddc:	e0bff615 	stw	r2,-40(fp)
			break;
81103de0:	00000306 	br	81103df0 <bSdmaDmaM1Transfer+0x160>
		default:
			bStatus = FALSE;
81103de4:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81103de8:	e03ff615 	stw	zero,-40(fp)
			break;
81103dec:	0001883a 	nop
		}
		break;
81103df0:	00008006 	br	81103ff4 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh3Buffer:
		switch (ucBufferSide) {
81103df4:	e0bffd03 	ldbu	r2,-12(fp)
81103df8:	10000826 	beq	r2,zero,81103e1c <bSdmaDmaM1Transfer+0x18c>
81103dfc:	10800060 	cmpeqi	r2,r2,1
81103e00:	10000d26 	beq	r2,zero,81103e38 <bSdmaDmaM1Transfer+0x1a8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_LOW;
81103e04:	00900004 	movi	r2,16384
81103e08:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_HIGH;
81103e0c:	00800044 	movi	r2,1
81103e10:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103e14:	e03ff615 	stw	zero,-40(fp)
			break;
81103e18:	00000a06 	br	81103e44 <bSdmaDmaM1Transfer+0x1b4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_LOW;
81103e1c:	00800074 	movhi	r2,1
81103e20:	10900004 	addi	r2,r2,16384
81103e24:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_HIGH;
81103e28:	00800044 	movi	r2,1
81103e2c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103e30:	e03ff615 	stw	zero,-40(fp)
			break;
81103e34:	00000306 	br	81103e44 <bSdmaDmaM1Transfer+0x1b4>
		default:
			bStatus = FALSE;
81103e38:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81103e3c:	e03ff615 	stw	zero,-40(fp)
			break;
81103e40:	0001883a 	nop
		}
		break;
81103e44:	00006b06 	br	81103ff4 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh4Buffer:
		switch (ucBufferSide) {
81103e48:	e0bffd03 	ldbu	r2,-12(fp)
81103e4c:	10000826 	beq	r2,zero,81103e70 <bSdmaDmaM1Transfer+0x1e0>
81103e50:	10800060 	cmpeqi	r2,r2,1
81103e54:	10000d26 	beq	r2,zero,81103e8c <bSdmaDmaM1Transfer+0x1fc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_LOW;
81103e58:	00980004 	movi	r2,24576
81103e5c:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_HIGH;
81103e60:	00800044 	movi	r2,1
81103e64:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103e68:	e03ff615 	stw	zero,-40(fp)
			break;
81103e6c:	00000a06 	br	81103e98 <bSdmaDmaM1Transfer+0x208>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_LOW;
81103e70:	00800074 	movhi	r2,1
81103e74:	10980004 	addi	r2,r2,24576
81103e78:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_HIGH;
81103e7c:	00800044 	movi	r2,1
81103e80:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103e84:	e03ff615 	stw	zero,-40(fp)
			break;
81103e88:	00000306 	br	81103e98 <bSdmaDmaM1Transfer+0x208>
		default:
			bStatus = FALSE;
81103e8c:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81103e90:	e03ff615 	stw	zero,-40(fp)
			break;
81103e94:	0001883a 	nop
		}
		break;
81103e98:	00005606 	br	81103ff4 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh5Buffer:
		switch (ucBufferSide) {
81103e9c:	e0bffd03 	ldbu	r2,-12(fp)
81103ea0:	10000826 	beq	r2,zero,81103ec4 <bSdmaDmaM1Transfer+0x234>
81103ea4:	10800060 	cmpeqi	r2,r2,1
81103ea8:	10000d26 	beq	r2,zero,81103ee0 <bSdmaDmaM1Transfer+0x250>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_LOW;
81103eac:	00a00014 	movui	r2,32768
81103eb0:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_HIGH;
81103eb4:	00800044 	movi	r2,1
81103eb8:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103ebc:	e03ff615 	stw	zero,-40(fp)
			break;
81103ec0:	00000a06 	br	81103eec <bSdmaDmaM1Transfer+0x25c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_LOW;
81103ec4:	008000b4 	movhi	r2,2
81103ec8:	10a00004 	addi	r2,r2,-32768
81103ecc:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_HIGH;
81103ed0:	00800044 	movi	r2,1
81103ed4:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103ed8:	e03ff615 	stw	zero,-40(fp)
			break;
81103edc:	00000306 	br	81103eec <bSdmaDmaM1Transfer+0x25c>
		default:
			bStatus = FALSE;
81103ee0:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81103ee4:	e03ff615 	stw	zero,-40(fp)
			break;
81103ee8:	0001883a 	nop
		}
		break;
81103eec:	00004106 	br	81103ff4 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh6Buffer:
		switch (ucBufferSide) {
81103ef0:	e0bffd03 	ldbu	r2,-12(fp)
81103ef4:	10000826 	beq	r2,zero,81103f18 <bSdmaDmaM1Transfer+0x288>
81103ef8:	10800060 	cmpeqi	r2,r2,1
81103efc:	10000d26 	beq	r2,zero,81103f34 <bSdmaDmaM1Transfer+0x2a4>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_LOW;
81103f00:	00a80014 	movui	r2,40960
81103f04:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_HIGH;
81103f08:	00800044 	movi	r2,1
81103f0c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103f10:	e03ff615 	stw	zero,-40(fp)
			break;
81103f14:	00000a06 	br	81103f40 <bSdmaDmaM1Transfer+0x2b0>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_LOW;
81103f18:	008000b4 	movhi	r2,2
81103f1c:	10a80004 	addi	r2,r2,-24576
81103f20:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_HIGH;
81103f24:	00800044 	movi	r2,1
81103f28:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103f2c:	e03ff615 	stw	zero,-40(fp)
			break;
81103f30:	00000306 	br	81103f40 <bSdmaDmaM1Transfer+0x2b0>
		default:
			bStatus = FALSE;
81103f34:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81103f38:	e03ff615 	stw	zero,-40(fp)
			break;
81103f3c:	0001883a 	nop
		}
		break;
81103f40:	00002c06 	br	81103ff4 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh7Buffer:
		switch (ucBufferSide) {
81103f44:	e0bffd03 	ldbu	r2,-12(fp)
81103f48:	10000826 	beq	r2,zero,81103f6c <bSdmaDmaM1Transfer+0x2dc>
81103f4c:	10800060 	cmpeqi	r2,r2,1
81103f50:	10000d26 	beq	r2,zero,81103f88 <bSdmaDmaM1Transfer+0x2f8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_LOW;
81103f54:	00b00014 	movui	r2,49152
81103f58:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_HIGH;
81103f5c:	00800044 	movi	r2,1
81103f60:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103f64:	e03ff615 	stw	zero,-40(fp)
			break;
81103f68:	00000a06 	br	81103f94 <bSdmaDmaM1Transfer+0x304>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_LOW;
81103f6c:	008000b4 	movhi	r2,2
81103f70:	10b00004 	addi	r2,r2,-16384
81103f74:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_HIGH;
81103f78:	00800044 	movi	r2,1
81103f7c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103f80:	e03ff615 	stw	zero,-40(fp)
			break;
81103f84:	00000306 	br	81103f94 <bSdmaDmaM1Transfer+0x304>
		default:
			bStatus = FALSE;
81103f88:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81103f8c:	e03ff615 	stw	zero,-40(fp)
			break;
81103f90:	0001883a 	nop
		}
		break;
81103f94:	00001706 	br	81103ff4 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh8Buffer:
		switch (ucBufferSide) {
81103f98:	e0bffd03 	ldbu	r2,-12(fp)
81103f9c:	10000826 	beq	r2,zero,81103fc0 <bSdmaDmaM1Transfer+0x330>
81103fa0:	10800060 	cmpeqi	r2,r2,1
81103fa4:	10000d26 	beq	r2,zero,81103fdc <bSdmaDmaM1Transfer+0x34c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_LOW;
81103fa8:	00b80014 	movui	r2,57344
81103fac:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_HIGH;
81103fb0:	00800044 	movi	r2,1
81103fb4:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103fb8:	e03ff615 	stw	zero,-40(fp)
			break;
81103fbc:	00000a06 	br	81103fe8 <bSdmaDmaM1Transfer+0x358>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_LOW;
81103fc0:	008000b4 	movhi	r2,2
81103fc4:	10b80004 	addi	r2,r2,-8192
81103fc8:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_HIGH;
81103fcc:	00800044 	movi	r2,1
81103fd0:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103fd4:	e03ff615 	stw	zero,-40(fp)
			break;
81103fd8:	00000306 	br	81103fe8 <bSdmaDmaM1Transfer+0x358>
		default:
			bStatus = FALSE;
81103fdc:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81103fe0:	e03ff615 	stw	zero,-40(fp)
			break;
81103fe4:	0001883a 	nop
		}
		break;
81103fe8:	00000206 	br	81103ff4 <bSdmaDmaM1Transfer+0x364>
	default:
		bStatus = FALSE;
81103fec:	e03ff315 	stw	zero,-52(fp)
		break;
81103ff0:	0001883a 	nop
	}

	bStatus = bBufferEmptyFlag;
81103ff4:	e0bff617 	ldw	r2,-40(fp)
81103ff8:	e0bff315 	stw	r2,-52(fp)

	uliSrcAddrLow = (alt_u32) SDMA_M1_BASE_ADDR_LOW
81103ffc:	e0bffb17 	ldw	r2,-20(fp)
81104000:	e0bff815 	stw	r2,-32(fp)
			+ (alt_u32) uliDdrInitialAddr;
	uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
81104004:	e03ff915 	stw	zero,-28(fp)


	if ( bBufferEmptyFlag == FALSE ) {
81104008:	e0bff617 	ldw	r2,-40(fp)
8110400c:	1000071e 	bne	r2,zero,8110402c <bSdmaDmaM1Transfer+0x39c>

		#ifdef DEBUG_ON
			fprintf(fp,"-------DEBUG-------- FEE Buffer FULL \n");
81104010:	d0a06217 	ldw	r2,-32376(gp)
81104014:	100f883a 	mov	r7,r2
81104018:	01800984 	movi	r6,38
8110401c:	01400044 	movi	r5,1
81104020:	01204574 	movhi	r4,33045
81104024:	21311504 	addi	r4,r4,-15276
81104028:	1121c7c0 	call	81121c7c <fwrite>
		#endif
	}


	if ( (usiTransferSizeInBlocks > 16) ) {
8110402c:	e0bffc0b 	ldhu	r2,-16(fp)
81104030:	10800470 	cmpltui	r2,r2,17
81104034:	1000071e 	bne	r2,zero,81104054 <bSdmaDmaM1Transfer+0x3c4>
		#ifdef DEBUG_ON
			fprintf(fp,"-------DEBUG-------- Bloco Maior que 16 \n");
81104038:	d0a06217 	ldw	r2,-32376(gp)
8110403c:	100f883a 	mov	r7,r2
81104040:	01800a44 	movi	r6,41
81104044:	01400044 	movi	r5,1
81104048:	01204574 	movhi	r4,33045
8110404c:	21311f04 	addi	r4,r4,-15236
81104050:	1121c7c0 	call	81121c7c <fwrite>
		#endif
	}

	if ((bStatus) && (bBufferEmptyFlag) && (usiTransferSizeInBlocks <= 16)) {
81104054:	e0bff317 	ldw	r2,-52(fp)
81104058:	10005026 	beq	r2,zero,8110419c <bSdmaDmaM1Transfer+0x50c>
8110405c:	e0bff617 	ldw	r2,-40(fp)
81104060:	10004e26 	beq	r2,zero,8110419c <bSdmaDmaM1Transfer+0x50c>
81104064:	e0bffc0b 	ldhu	r2,-16(fp)
81104068:	10800468 	cmpgeui	r2,r2,17
8110406c:	10004b1e 	bne	r2,zero,8110419c <bSdmaDmaM1Transfer+0x50c>
		if (pxDmaM1Dev == NULL) {
81104070:	d0a03917 	ldw	r2,-32540(gp)
81104074:	1000021e 	bne	r2,zero,81104080 <bSdmaDmaM1Transfer+0x3f0>
			bStatus = FALSE;
81104078:	e03ff315 	stw	zero,-52(fp)
			fprintf(fp,"-------DEBUG-------- Bloco Maior que 16 \n");
		#endif
	}

	if ((bStatus) && (bBufferEmptyFlag) && (usiTransferSizeInBlocks <= 16)) {
		if (pxDmaM1Dev == NULL) {
8110407c:	00004906 	br	811041a4 <bSdmaDmaM1Transfer+0x514>
			bStatus = FALSE;
		} else {
//			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				#ifdef DEBUG_ON
					fprintf(fp,"-------DEBUG-------- Antes do IORD_ALTERA_MSGDMA_CSR_STATUS \n");
81104080:	d0a06217 	ldw	r2,-32376(gp)
81104084:	100f883a 	mov	r7,r2
81104088:	01800f44 	movi	r6,61
8110408c:	01400044 	movi	r5,1
81104090:	01204574 	movhi	r4,33045
81104094:	21312a04 	addi	r4,r4,-15192
81104098:	1121c7c0 	call	81121c7c <fwrite>
				#endif
				while (0
8110409c:	00000206 	br	811040a8 <bSdmaDmaM1Transfer+0x418>
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
811040a0:	01000044 	movi	r4,1
811040a4:	11362a00 	call	811362a0 <alt_busy_sleep>
				// hold transfers for descriptor fifo space
				#ifdef DEBUG_ON
					fprintf(fp,"-------DEBUG-------- Antes do IORD_ALTERA_MSGDMA_CSR_STATUS \n");
				#endif
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
811040a8:	d0a03a17 	ldw	r2,-32536(gp)
811040ac:	10800317 	ldw	r2,12(r2)
811040b0:	10800037 	ldwio	r2,0(r2)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
811040b4:	1080010c 	andi	r2,r2,4
//			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				#ifdef DEBUG_ON
					fprintf(fp,"-------DEBUG-------- Antes do IORD_ALTERA_MSGDMA_CSR_STATUS \n");
				#endif
				while (0
811040b8:	103ff91e 	bne	r2,zero,811040a0 <__reset+0xfb0e40a0>
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
				}

				#ifdef DEBUG_ON
					fprintf(fp,"-------DEBUG-------- OK - Depois do IORD_ALTERA_MSGDMA_CSR_STATUS \n");
811040bc:	d0a06217 	ldw	r2,-32376(gp)
811040c0:	100f883a 	mov	r7,r2
811040c4:	018010c4 	movi	r6,67
811040c8:	01400044 	movi	r5,1
811040cc:	01204574 	movhi	r4,33045
811040d0:	21313a04 	addi	r4,r4,-15128
811040d4:	1121c7c0 	call	81121c7c <fwrite>
				#endif
				if (iMsgdmaConstructExtendedMmToMmDescriptor(pxDmaM1Dev,
811040d8:	d2203917 	ldw	r8,-32540(gp)
811040dc:	e1bff817 	ldw	r6,-32(fp)
811040e0:	e1fff417 	ldw	r7,-48(fp)
811040e4:	e0bffc0b 	ldhu	r2,-16(fp)
811040e8:	10802224 	muli	r2,r2,136
811040ec:	e0fff917 	ldw	r3,-28(fp)
811040f0:	e13ff517 	ldw	r4,-44(fp)
811040f4:	01400044 	movi	r5,1
811040f8:	d9400815 	stw	r5,32(sp)
811040fc:	01400044 	movi	r5,1
81104100:	d9400715 	stw	r5,28(sp)
81104104:	01400044 	movi	r5,1
81104108:	d9400615 	stw	r5,24(sp)
8110410c:	01400044 	movi	r5,1
81104110:	d9400515 	stw	r5,20(sp)
81104114:	01400044 	movi	r5,1
81104118:	d9400415 	stw	r5,16(sp)
8110411c:	d9000315 	stw	r4,12(sp)
81104120:	d8c00215 	stw	r3,8(sp)
81104124:	e0fffa17 	ldw	r3,-24(fp)
81104128:	d8c00115 	stw	r3,4(sp)
8110412c:	d8800015 	stw	r2,0(sp)
81104130:	800b883a 	mov	r5,r16
81104134:	4009883a 	mov	r4,r8
81104138:	110bd940 	call	8110bd94 <iMsgdmaConstructExtendedMmToMmDescriptor>
8110413c:	10000926 	beq	r2,zero,81104164 <bSdmaDmaM1Transfer+0x4d4>
						&xDmaExtendedDescriptor, (alt_u32 *) uliSrcAddrLow,
						(alt_u32 *) uliDestAddrLow,
						SDMA_PIXEL_BLOCK_SIZE_BYTES*usiTransferSizeInBlocks, uliControlBits,
						(alt_u32 *) uliSrcAddrHigh, (alt_u32 *) uliDestAddrHigh,
						1, 1, 1, 1, 1)) {
					bStatus = FALSE;
81104140:	e03ff315 	stw	zero,-52(fp)

					#ifdef DEBUG_ON
						fprintf(fp,"-------DEBUG-------- FAIL - iMsgdmaConstructExtendedMmToMmDescriptor FAIL \n");
81104144:	d0a06217 	ldw	r2,-32376(gp)
81104148:	100f883a 	mov	r7,r2
8110414c:	018012c4 	movi	r6,75
81104150:	01400044 	movi	r5,1
81104154:	01204574 	movhi	r4,33045
81104158:	21314b04 	addi	r4,r4,-15060
8110415c:	1121c7c0 	call	81121c7c <fwrite>
			fprintf(fp,"-------DEBUG-------- Bloco Maior que 16 \n");
		#endif
	}

	if ((bStatus) && (bBufferEmptyFlag) && (usiTransferSizeInBlocks <= 16)) {
		if (pxDmaM1Dev == NULL) {
81104160:	00001006 	br	811041a4 <bSdmaDmaM1Transfer+0x514>
						fprintf(fp,"-------DEBUG-------- FAIL - iMsgdmaConstructExtendedMmToMmDescriptor FAIL \n");
					#endif

//					break;
				} else {
					if (iMsgdmaExtendedDescriptorAsyncTransfer(pxDmaM1Dev,
81104164:	d0a03917 	ldw	r2,-32540(gp)
81104168:	800b883a 	mov	r5,r16
8110416c:	1009883a 	mov	r4,r2
81104170:	110be540 	call	8110be54 <iMsgdmaExtendedDescriptorAsyncTransfer>
81104174:	10000b26 	beq	r2,zero,811041a4 <bSdmaDmaM1Transfer+0x514>
							&xDmaExtendedDescriptor)) {
						bStatus = FALSE;
81104178:	e03ff315 	stw	zero,-52(fp)
					#ifdef DEBUG_ON
						fprintf(fp,"-------DEBUG-------- FAIL - iMsgdmaExtendedDescriptorAsyncTransfer FAIL \n");
8110417c:	d0a06217 	ldw	r2,-32376(gp)
81104180:	100f883a 	mov	r7,r2
81104184:	01801244 	movi	r6,73
81104188:	01400044 	movi	r5,1
8110418c:	01204574 	movhi	r4,33045
81104190:	21315e04 	addi	r4,r4,-14984
81104194:	1121c7c0 	call	81121c7c <fwrite>
			fprintf(fp,"-------DEBUG-------- Bloco Maior que 16 \n");
		#endif
	}

	if ((bStatus) && (bBufferEmptyFlag) && (usiTransferSizeInBlocks <= 16)) {
		if (pxDmaM1Dev == NULL) {
81104198:	00000206 	br	811041a4 <bSdmaDmaM1Transfer+0x514>
//					uliSrcAddrLow += (alt_u32) SDMA_PIXEL_BLOCK_SIZE_BYTES;
//					uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
				}
//			}
		}
	} else { bStatus = FALSE; }
8110419c:	e03ff315 	stw	zero,-52(fp)
811041a0:	00000106 	br	811041a8 <bSdmaDmaM1Transfer+0x518>
			fprintf(fp,"-------DEBUG-------- Bloco Maior que 16 \n");
		#endif
	}

	if ((bStatus) && (bBufferEmptyFlag) && (usiTransferSizeInBlocks <= 16)) {
		if (pxDmaM1Dev == NULL) {
811041a4:	0001883a 	nop
//					uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
				}
//			}
		}
	} else { bStatus = FALSE; }
	return bStatus;
811041a8:	e0bff317 	ldw	r2,-52(fp)
}
811041ac:	e6ffff04 	addi	sp,fp,-4
811041b0:	dfc00217 	ldw	ra,8(sp)
811041b4:	df000117 	ldw	fp,4(sp)
811041b8:	dc000017 	ldw	r16,0(sp)
811041bc:	dec00304 	addi	sp,sp,12
811041c0:	f800283a 	ret

811041c4 <bSdmaDmaM2Transfer>:

bool bSdmaDmaM2Transfer(alt_u32 *uliDdrInitialAddr,
		alt_u16 usiTransferSizeInBlocks, alt_u8 ucBufferSide,
		alt_u8 ucChBufferId) {
811041c4:	deffe804 	addi	sp,sp,-96
811041c8:	de00012e 	bgeu	sp,et,811041d0 <bSdmaDmaM2Transfer+0xc>
811041cc:	003b68fa 	trap	3
811041d0:	dfc01715 	stw	ra,92(sp)
811041d4:	df001615 	stw	fp,88(sp)
811041d8:	dc001515 	stw	r16,84(sp)
811041dc:	df001604 	addi	fp,sp,88
811041e0:	e13ffb15 	stw	r4,-20(fp)
811041e4:	2809883a 	mov	r4,r5
811041e8:	3007883a 	mov	r3,r6
811041ec:	3805883a 	mov	r2,r7
811041f0:	e13ffc0d 	sth	r4,-16(fp)
811041f4:	e0fffd05 	stb	r3,-12(fp)
811041f8:	e0bffe05 	stb	r2,-8(fp)
811041fc:	defff004 	addi	sp,sp,-64
81104200:	d8800904 	addi	r2,sp,36
81104204:	108007c4 	addi	r2,r2,31
81104208:	1004d17a 	srli	r2,r2,5
8110420c:	1020917a 	slli	r16,r2,5
	bool bStatus = TRUE;
81104210:	00800044 	movi	r2,1
81104214:	e0bff315 	stw	r2,-52(fp)
	alt_u16 usiCnt = 0;
81104218:	e03ff70d 	sth	zero,-36(fp)

	alt_msgdma_extended_descriptor xDmaExtendedDescriptor;

	alt_u32 uliDestAddrLow = 0;
8110421c:	e03ff415 	stw	zero,-48(fp)
	alt_u32 uliDestAddrHigh = 0;
81104220:	e03ff515 	stw	zero,-44(fp)

	alt_u32 uliSrcAddrLow = 0;
81104224:	e03ff815 	stw	zero,-32(fp)
	alt_u32 uliSrcAddrHigh = 0;
81104228:	e03ff915 	stw	zero,-28(fp)

	alt_u32 uliControlBits = 0x00000000;
8110422c:	e03ffa15 	stw	zero,-24(fp)

	bool bBufferEmptyFlag = FALSE;
81104230:	e03ff615 	stw	zero,-40(fp)

	switch (ucChBufferId) {
81104234:	e0bffe03 	ldbu	r2,-8(fp)
81104238:	10c00228 	cmpgeui	r3,r2,8
8110423c:	1800b81e 	bne	r3,zero,81104520 <bSdmaDmaM2Transfer+0x35c>
81104240:	100690ba 	slli	r3,r2,2
81104244:	00a04434 	movhi	r2,33040
81104248:	10909604 	addi	r2,r2,16984
8110424c:	1885883a 	add	r2,r3,r2
81104250:	10800017 	ldw	r2,0(r2)
81104254:	1000683a 	jmp	r2
81104258:	81104278 	rdprs	r4,r16,16649
8110425c:	811042cc 	andi	r4,r16,16651
81104260:	81104328 	cmpgeui	r4,r16,16652
81104264:	8110437c 	xorhi	r4,r16,16653
81104268:	811043d0 	cmplti	r4,r16,16655
8110426c:	81104424 	muli	r4,r16,16656
81104270:	81104478 	rdprs	r4,r16,16657
81104274:	811044cc 	andi	r4,r16,16659
	case eSdmaCh1Buffer:
		switch (ucBufferSide) {
81104278:	e0bffd03 	ldbu	r2,-12(fp)
8110427c:	10000826 	beq	r2,zero,811042a0 <bSdmaDmaM2Transfer+0xdc>
81104280:	10800060 	cmpeqi	r2,r2,1
81104284:	10000d26 	beq	r2,zero,811042bc <bSdmaDmaM2Transfer+0xf8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_LOW;
81104288:	e03ff415 	stw	zero,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_HIGH;
8110428c:	00800044 	movi	r2,1
81104290:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh1RightBufferEmpty();
81104294:	11067b00 	call	811067b0 <bFeebGetCh1RightBufferEmpty>
81104298:	e0bff615 	stw	r2,-40(fp)
			break;
8110429c:	00000a06 	br	811042c8 <bSdmaDmaM2Transfer+0x104>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_LOW;
811042a0:	00800074 	movhi	r2,1
811042a4:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_HIGH;
811042a8:	00800044 	movi	r2,1
811042ac:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh1LeftBufferEmpty();
811042b0:	11067480 	call	81106748 <bFeebGetCh1LeftBufferEmpty>
811042b4:	e0bff615 	stw	r2,-40(fp)
			break;
811042b8:	00000306 	br	811042c8 <bSdmaDmaM2Transfer+0x104>
		default:
			bStatus = FALSE;
811042bc:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
811042c0:	e03ff615 	stw	zero,-40(fp)
			break;
811042c4:	0001883a 	nop
		}
		break;
811042c8:	00009706 	br	81104528 <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh2Buffer:
		switch (ucBufferSide) {
811042cc:	e0bffd03 	ldbu	r2,-12(fp)
811042d0:	10000926 	beq	r2,zero,811042f8 <bSdmaDmaM2Transfer+0x134>
811042d4:	10800060 	cmpeqi	r2,r2,1
811042d8:	10000f26 	beq	r2,zero,81104318 <bSdmaDmaM2Transfer+0x154>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_LOW;
811042dc:	00880004 	movi	r2,8192
811042e0:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_HIGH;
811042e4:	00800044 	movi	r2,1
811042e8:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh2RightBufferEmpty();
811042ec:	11068800 	call	81106880 <bFeebGetCh2RightBufferEmpty>
811042f0:	e0bff615 	stw	r2,-40(fp)
			break;
811042f4:	00000b06 	br	81104324 <bSdmaDmaM2Transfer+0x160>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_LOW;
811042f8:	00800074 	movhi	r2,1
811042fc:	10880004 	addi	r2,r2,8192
81104300:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_HIGH;
81104304:	00800044 	movi	r2,1
81104308:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh2LeftBufferEmpty();
8110430c:	11068180 	call	81106818 <bFeebGetCh2LeftBufferEmpty>
81104310:	e0bff615 	stw	r2,-40(fp)
			break;
81104314:	00000306 	br	81104324 <bSdmaDmaM2Transfer+0x160>
		default:
			bStatus = FALSE;
81104318:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
8110431c:	e03ff615 	stw	zero,-40(fp)
			break;
81104320:	0001883a 	nop
		}
		break;
81104324:	00008006 	br	81104528 <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh3Buffer:
		switch (ucBufferSide) {
81104328:	e0bffd03 	ldbu	r2,-12(fp)
8110432c:	10000826 	beq	r2,zero,81104350 <bSdmaDmaM2Transfer+0x18c>
81104330:	10800060 	cmpeqi	r2,r2,1
81104334:	10000d26 	beq	r2,zero,8110436c <bSdmaDmaM2Transfer+0x1a8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_LOW;
81104338:	00900004 	movi	r2,16384
8110433c:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_HIGH;
81104340:	00800044 	movi	r2,1
81104344:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81104348:	e03ff615 	stw	zero,-40(fp)
			break;
8110434c:	00000a06 	br	81104378 <bSdmaDmaM2Transfer+0x1b4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_LOW;
81104350:	00800074 	movhi	r2,1
81104354:	10900004 	addi	r2,r2,16384
81104358:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_HIGH;
8110435c:	00800044 	movi	r2,1
81104360:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81104364:	e03ff615 	stw	zero,-40(fp)
			break;
81104368:	00000306 	br	81104378 <bSdmaDmaM2Transfer+0x1b4>
		default:
			bStatus = FALSE;
8110436c:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81104370:	e03ff615 	stw	zero,-40(fp)
			break;
81104374:	0001883a 	nop
		}
		break;
81104378:	00006b06 	br	81104528 <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh4Buffer:
		switch (ucBufferSide) {
8110437c:	e0bffd03 	ldbu	r2,-12(fp)
81104380:	10000826 	beq	r2,zero,811043a4 <bSdmaDmaM2Transfer+0x1e0>
81104384:	10800060 	cmpeqi	r2,r2,1
81104388:	10000d26 	beq	r2,zero,811043c0 <bSdmaDmaM2Transfer+0x1fc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_LOW;
8110438c:	00980004 	movi	r2,24576
81104390:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_HIGH;
81104394:	00800044 	movi	r2,1
81104398:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
8110439c:	e03ff615 	stw	zero,-40(fp)
			break;
811043a0:	00000a06 	br	811043cc <bSdmaDmaM2Transfer+0x208>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_LOW;
811043a4:	00800074 	movhi	r2,1
811043a8:	10980004 	addi	r2,r2,24576
811043ac:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_HIGH;
811043b0:	00800044 	movi	r2,1
811043b4:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
811043b8:	e03ff615 	stw	zero,-40(fp)
			break;
811043bc:	00000306 	br	811043cc <bSdmaDmaM2Transfer+0x208>
		default:
			bStatus = FALSE;
811043c0:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
811043c4:	e03ff615 	stw	zero,-40(fp)
			break;
811043c8:	0001883a 	nop
		}
		break;
811043cc:	00005606 	br	81104528 <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh5Buffer:
		switch (ucBufferSide) {
811043d0:	e0bffd03 	ldbu	r2,-12(fp)
811043d4:	10000826 	beq	r2,zero,811043f8 <bSdmaDmaM2Transfer+0x234>
811043d8:	10800060 	cmpeqi	r2,r2,1
811043dc:	10000d26 	beq	r2,zero,81104414 <bSdmaDmaM2Transfer+0x250>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_LOW;
811043e0:	00a00014 	movui	r2,32768
811043e4:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_HIGH;
811043e8:	00800044 	movi	r2,1
811043ec:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
811043f0:	e03ff615 	stw	zero,-40(fp)
			break;
811043f4:	00000a06 	br	81104420 <bSdmaDmaM2Transfer+0x25c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_LOW;
811043f8:	008000b4 	movhi	r2,2
811043fc:	10a00004 	addi	r2,r2,-32768
81104400:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_HIGH;
81104404:	00800044 	movi	r2,1
81104408:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
8110440c:	e03ff615 	stw	zero,-40(fp)
			break;
81104410:	00000306 	br	81104420 <bSdmaDmaM2Transfer+0x25c>
		default:
			bStatus = FALSE;
81104414:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81104418:	e03ff615 	stw	zero,-40(fp)
			break;
8110441c:	0001883a 	nop
		}
		break;
81104420:	00004106 	br	81104528 <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh6Buffer:
		switch (ucBufferSide) {
81104424:	e0bffd03 	ldbu	r2,-12(fp)
81104428:	10000826 	beq	r2,zero,8110444c <bSdmaDmaM2Transfer+0x288>
8110442c:	10800060 	cmpeqi	r2,r2,1
81104430:	10000d26 	beq	r2,zero,81104468 <bSdmaDmaM2Transfer+0x2a4>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_LOW;
81104434:	00a80014 	movui	r2,40960
81104438:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_HIGH;
8110443c:	00800044 	movi	r2,1
81104440:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81104444:	e03ff615 	stw	zero,-40(fp)
			break;
81104448:	00000a06 	br	81104474 <bSdmaDmaM2Transfer+0x2b0>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_LOW;
8110444c:	008000b4 	movhi	r2,2
81104450:	10a80004 	addi	r2,r2,-24576
81104454:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_HIGH;
81104458:	00800044 	movi	r2,1
8110445c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81104460:	e03ff615 	stw	zero,-40(fp)
			break;
81104464:	00000306 	br	81104474 <bSdmaDmaM2Transfer+0x2b0>
		default:
			bStatus = FALSE;
81104468:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
8110446c:	e03ff615 	stw	zero,-40(fp)
			break;
81104470:	0001883a 	nop
		}
		break;
81104474:	00002c06 	br	81104528 <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh7Buffer:
		switch (ucBufferSide) {
81104478:	e0bffd03 	ldbu	r2,-12(fp)
8110447c:	10000826 	beq	r2,zero,811044a0 <bSdmaDmaM2Transfer+0x2dc>
81104480:	10800060 	cmpeqi	r2,r2,1
81104484:	10000d26 	beq	r2,zero,811044bc <bSdmaDmaM2Transfer+0x2f8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_LOW;
81104488:	00b00014 	movui	r2,49152
8110448c:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_HIGH;
81104490:	00800044 	movi	r2,1
81104494:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81104498:	e03ff615 	stw	zero,-40(fp)
			break;
8110449c:	00000a06 	br	811044c8 <bSdmaDmaM2Transfer+0x304>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_LOW;
811044a0:	008000b4 	movhi	r2,2
811044a4:	10b00004 	addi	r2,r2,-16384
811044a8:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_HIGH;
811044ac:	00800044 	movi	r2,1
811044b0:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
811044b4:	e03ff615 	stw	zero,-40(fp)
			break;
811044b8:	00000306 	br	811044c8 <bSdmaDmaM2Transfer+0x304>
		default:
			bStatus = FALSE;
811044bc:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
811044c0:	e03ff615 	stw	zero,-40(fp)
			break;
811044c4:	0001883a 	nop
		}
		break;
811044c8:	00001706 	br	81104528 <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh8Buffer:
		switch (ucBufferSide) {
811044cc:	e0bffd03 	ldbu	r2,-12(fp)
811044d0:	10000826 	beq	r2,zero,811044f4 <bSdmaDmaM2Transfer+0x330>
811044d4:	10800060 	cmpeqi	r2,r2,1
811044d8:	10000d26 	beq	r2,zero,81104510 <bSdmaDmaM2Transfer+0x34c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_LOW;
811044dc:	00b80014 	movui	r2,57344
811044e0:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_HIGH;
811044e4:	00800044 	movi	r2,1
811044e8:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
811044ec:	e03ff615 	stw	zero,-40(fp)
			break;
811044f0:	00000a06 	br	8110451c <bSdmaDmaM2Transfer+0x358>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_LOW;
811044f4:	008000b4 	movhi	r2,2
811044f8:	10b80004 	addi	r2,r2,-8192
811044fc:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_HIGH;
81104500:	00800044 	movi	r2,1
81104504:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81104508:	e03ff615 	stw	zero,-40(fp)
			break;
8110450c:	00000306 	br	8110451c <bSdmaDmaM2Transfer+0x358>
		default:
			bStatus = FALSE;
81104510:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81104514:	e03ff615 	stw	zero,-40(fp)
			break;
81104518:	0001883a 	nop
		}
		break;
8110451c:	00000206 	br	81104528 <bSdmaDmaM2Transfer+0x364>
	default:
		bStatus = FALSE;
81104520:	e03ff315 	stw	zero,-52(fp)
		break;
81104524:	0001883a 	nop
	}
	bStatus = bBufferEmptyFlag;
81104528:	e0bff617 	ldw	r2,-40(fp)
8110452c:	e0bff315 	stw	r2,-52(fp)


	if ( bBufferEmptyFlag == FALSE ) {
81104530:	e0bff617 	ldw	r2,-40(fp)
81104534:	1000071e 	bne	r2,zero,81104554 <bSdmaDmaM2Transfer+0x390>

		#ifdef DEBUG_ON
			fprintf(fp,"-------DEBUG-------- FEE Buffer FULL \n");
81104538:	d0a06217 	ldw	r2,-32376(gp)
8110453c:	100f883a 	mov	r7,r2
81104540:	01800984 	movi	r6,38
81104544:	01400044 	movi	r5,1
81104548:	01204574 	movhi	r4,33045
8110454c:	21311504 	addi	r4,r4,-15276
81104550:	1121c7c0 	call	81121c7c <fwrite>
		#endif
	}


	if ( (usiTransferSizeInBlocks > 16) ) {
81104554:	e0bffc0b 	ldhu	r2,-16(fp)
81104558:	10800470 	cmpltui	r2,r2,17
8110455c:	1000071e 	bne	r2,zero,8110457c <bSdmaDmaM2Transfer+0x3b8>
		#ifdef DEBUG_ON
			fprintf(fp,"-------DEBUG-------- Bloco Maior que 16 \n");
81104560:	d0a06217 	ldw	r2,-32376(gp)
81104564:	100f883a 	mov	r7,r2
81104568:	01800a44 	movi	r6,41
8110456c:	01400044 	movi	r5,1
81104570:	01204574 	movhi	r4,33045
81104574:	21311f04 	addi	r4,r4,-15236
81104578:	1121c7c0 	call	81121c7c <fwrite>
		#endif
	}


	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
			+ (alt_u32) uliDdrInitialAddr;
8110457c:	e0fffb17 	ldw	r3,-20(fp)
			fprintf(fp,"-------DEBUG-------- Bloco Maior que 16 \n");
		#endif
	}


	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
81104580:	00a00034 	movhi	r2,32768
81104584:	1885883a 	add	r2,r3,r2
81104588:	e0bff815 	stw	r2,-32(fp)
			+ (alt_u32) uliDdrInitialAddr;
	uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
8110458c:	e03ff915 	stw	zero,-28(fp)

	if ((bStatus) && (bBufferEmptyFlag) && (usiTransferSizeInBlocks <= 16)) {
81104590:	e0bff317 	ldw	r2,-52(fp)
81104594:	10005026 	beq	r2,zero,811046d8 <bSdmaDmaM2Transfer+0x514>
81104598:	e0bff617 	ldw	r2,-40(fp)
8110459c:	10004e26 	beq	r2,zero,811046d8 <bSdmaDmaM2Transfer+0x514>
811045a0:	e0bffc0b 	ldhu	r2,-16(fp)
811045a4:	10800468 	cmpgeui	r2,r2,17
811045a8:	10004b1e 	bne	r2,zero,811046d8 <bSdmaDmaM2Transfer+0x514>
		if (pxDmaM2Dev == NULL) {
811045ac:	d0a03a17 	ldw	r2,-32536(gp)
811045b0:	1000021e 	bne	r2,zero,811045bc <bSdmaDmaM2Transfer+0x3f8>
			bStatus = FALSE;
811045b4:	e03ff315 	stw	zero,-52(fp)
	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
			+ (alt_u32) uliDdrInitialAddr;
	uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;

	if ((bStatus) && (bBufferEmptyFlag) && (usiTransferSizeInBlocks <= 16)) {
		if (pxDmaM2Dev == NULL) {
811045b8:	00004906 	br	811046e0 <bSdmaDmaM2Transfer+0x51c>
		} else {
//			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space

				#ifdef DEBUG_ON
					fprintf(fp,"-------DEBUG-------- Antes do IORD_ALTERA_MSGDMA_CSR_STATUS \n");
811045bc:	d0a06217 	ldw	r2,-32376(gp)
811045c0:	100f883a 	mov	r7,r2
811045c4:	01800f44 	movi	r6,61
811045c8:	01400044 	movi	r5,1
811045cc:	01204574 	movhi	r4,33045
811045d0:	21312a04 	addi	r4,r4,-15192
811045d4:	1121c7c0 	call	81121c7c <fwrite>
				#endif

				while (0
811045d8:	00000206 	br	811045e4 <bSdmaDmaM2Transfer+0x420>
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
811045dc:	01000044 	movi	r4,1
811045e0:	11362a00 	call	811362a0 <alt_busy_sleep>
				#ifdef DEBUG_ON
					fprintf(fp,"-------DEBUG-------- Antes do IORD_ALTERA_MSGDMA_CSR_STATUS \n");
				#endif

				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
811045e4:	d0a03a17 	ldw	r2,-32536(gp)
811045e8:	10800317 	ldw	r2,12(r2)
811045ec:	10800037 	ldwio	r2,0(r2)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
811045f0:	1080010c 	andi	r2,r2,4

				#ifdef DEBUG_ON
					fprintf(fp,"-------DEBUG-------- Antes do IORD_ALTERA_MSGDMA_CSR_STATUS \n");
				#endif

				while (0
811045f4:	103ff91e 	bne	r2,zero,811045dc <__reset+0xfb0e45dc>
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
				}
				#ifdef DEBUG_ON
					fprintf(fp,"-------DEBUG-------- OK - Depois do IORD_ALTERA_MSGDMA_CSR_STATUS \n");
811045f8:	d0a06217 	ldw	r2,-32376(gp)
811045fc:	100f883a 	mov	r7,r2
81104600:	018010c4 	movi	r6,67
81104604:	01400044 	movi	r5,1
81104608:	01204574 	movhi	r4,33045
8110460c:	21313a04 	addi	r4,r4,-15128
81104610:	1121c7c0 	call	81121c7c <fwrite>
				#endif
				if (iMsgdmaConstructExtendedMmToMmDescriptor(pxDmaM2Dev,
81104614:	d2203a17 	ldw	r8,-32536(gp)
81104618:	e1bff817 	ldw	r6,-32(fp)
8110461c:	e1fff417 	ldw	r7,-48(fp)
81104620:	e0bffc0b 	ldhu	r2,-16(fp)
81104624:	10802224 	muli	r2,r2,136
81104628:	e0fff917 	ldw	r3,-28(fp)
8110462c:	e13ff517 	ldw	r4,-44(fp)
81104630:	01400044 	movi	r5,1
81104634:	d9400815 	stw	r5,32(sp)
81104638:	01400044 	movi	r5,1
8110463c:	d9400715 	stw	r5,28(sp)
81104640:	01400044 	movi	r5,1
81104644:	d9400615 	stw	r5,24(sp)
81104648:	01400044 	movi	r5,1
8110464c:	d9400515 	stw	r5,20(sp)
81104650:	01400044 	movi	r5,1
81104654:	d9400415 	stw	r5,16(sp)
81104658:	d9000315 	stw	r4,12(sp)
8110465c:	d8c00215 	stw	r3,8(sp)
81104660:	e0fffa17 	ldw	r3,-24(fp)
81104664:	d8c00115 	stw	r3,4(sp)
81104668:	d8800015 	stw	r2,0(sp)
8110466c:	800b883a 	mov	r5,r16
81104670:	4009883a 	mov	r4,r8
81104674:	110bd940 	call	8110bd94 <iMsgdmaConstructExtendedMmToMmDescriptor>
81104678:	10000926 	beq	r2,zero,811046a0 <bSdmaDmaM2Transfer+0x4dc>
						&xDmaExtendedDescriptor, (alt_u32 *) uliSrcAddrLow,
						(alt_u32 *) uliDestAddrLow,
						SDMA_PIXEL_BLOCK_SIZE_BYTES*usiTransferSizeInBlocks, uliControlBits,
						(alt_u32 *) uliSrcAddrHigh, (alt_u32 *) uliDestAddrHigh,
						1, 1, 1, 1, 1)) {
					bStatus = FALSE;
8110467c:	e03ff315 	stw	zero,-52(fp)
					#ifdef DEBUG_ON
						fprintf(fp,"-------DEBUG-------- FAIL - iMsgdmaConstructExtendedMmToMmDescriptor FAIL \n");
81104680:	d0a06217 	ldw	r2,-32376(gp)
81104684:	100f883a 	mov	r7,r2
81104688:	018012c4 	movi	r6,75
8110468c:	01400044 	movi	r5,1
81104690:	01204574 	movhi	r4,33045
81104694:	21314b04 	addi	r4,r4,-15060
81104698:	1121c7c0 	call	81121c7c <fwrite>
	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
			+ (alt_u32) uliDdrInitialAddr;
	uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;

	if ((bStatus) && (bBufferEmptyFlag) && (usiTransferSizeInBlocks <= 16)) {
		if (pxDmaM2Dev == NULL) {
8110469c:	00001006 	br	811046e0 <bSdmaDmaM2Transfer+0x51c>
					#ifdef DEBUG_ON
						fprintf(fp,"-------DEBUG-------- FAIL - iMsgdmaConstructExtendedMmToMmDescriptor FAIL \n");
					#endif
//					break;
				} else {
					if (iMsgdmaExtendedDescriptorSyncTransfer(pxDmaM2Dev,
811046a0:	d0a03a17 	ldw	r2,-32536(gp)
811046a4:	800b883a 	mov	r5,r16
811046a8:	1009883a 	mov	r4,r2
811046ac:	110be980 	call	8110be98 <iMsgdmaExtendedDescriptorSyncTransfer>
811046b0:	10000b26 	beq	r2,zero,811046e0 <bSdmaDmaM2Transfer+0x51c>
							&xDmaExtendedDescriptor)) {
						bStatus = FALSE;
811046b4:	e03ff315 	stw	zero,-52(fp)
						#ifdef DEBUG_ON
							fprintf(fp,"-------DEBUG-------- FAIL - iMsgdmaExtendedDescriptorAsyncTransfer FAIL \n");
811046b8:	d0a06217 	ldw	r2,-32376(gp)
811046bc:	100f883a 	mov	r7,r2
811046c0:	01801244 	movi	r6,73
811046c4:	01400044 	movi	r5,1
811046c8:	01204574 	movhi	r4,33045
811046cc:	21315e04 	addi	r4,r4,-14984
811046d0:	1121c7c0 	call	81121c7c <fwrite>
	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
			+ (alt_u32) uliDdrInitialAddr;
	uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;

	if ((bStatus) && (bBufferEmptyFlag) && (usiTransferSizeInBlocks <= 16)) {
		if (pxDmaM2Dev == NULL) {
811046d4:	00000206 	br	811046e0 <bSdmaDmaM2Transfer+0x51c>
//					uliSrcAddrLow += (alt_u32) SDMA_PIXEL_BLOCK_SIZE_BYTES;
//					uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
				}
//			}
		}
	} else { bStatus = FALSE; }
811046d8:	e03ff315 	stw	zero,-52(fp)
811046dc:	00000106 	br	811046e4 <bSdmaDmaM2Transfer+0x520>
	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
			+ (alt_u32) uliDdrInitialAddr;
	uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;

	if ((bStatus) && (bBufferEmptyFlag) && (usiTransferSizeInBlocks <= 16)) {
		if (pxDmaM2Dev == NULL) {
811046e0:	0001883a 	nop
//					uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
				}
//			}
		}
	} else { bStatus = FALSE; }
	return bStatus;
811046e4:	e0bff317 	ldw	r2,-52(fp)
}
811046e8:	e6ffff04 	addi	sp,fp,-4
811046ec:	dfc00217 	ldw	ra,8(sp)
811046f0:	df000117 	ldw	fp,4(sp)
811046f4:	dc000017 	ldw	r16,0(sp)
811046f8:	dec00304 	addi	sp,sp,12
811046fc:	f800283a 	ret

81104700 <bCommSetGlobalIrqEn>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bCommSetGlobalIrqEn(bool bGlobalIrqEnable, alt_u8 ucCommCh) {
81104700:	defff904 	addi	sp,sp,-28
81104704:	de00012e 	bgeu	sp,et,8110470c <bCommSetGlobalIrqEn+0xc>
81104708:	003b68fa 	trap	3
8110470c:	dfc00615 	stw	ra,24(sp)
81104710:	df000515 	stw	fp,20(sp)
81104714:	df000504 	addi	fp,sp,20
81104718:	e13ffe15 	stw	r4,-8(fp)
8110471c:	2805883a 	mov	r2,r5
81104720:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81104724:	00800044 	movi	r2,1
81104728:	e0bffb15 	stw	r2,-20(fp)
	alt_u32 uliReg = 0;
8110472c:	e03ffc15 	stw	zero,-16(fp)
	alt_u32 *puliCommAddr = 0;
81104730:	e03ffd15 	stw	zero,-12(fp)

	switch (ucCommCh) {
81104734:	e0bfff03 	ldbu	r2,-4(fp)
81104738:	10c00228 	cmpgeui	r3,r2,8
8110473c:	18002e1e 	bne	r3,zero,811047f8 <bCommSetGlobalIrqEn+0xf8>
81104740:	100690ba 	slli	r3,r2,2
81104744:	00a04434 	movhi	r2,33040
81104748:	1091d604 	addi	r2,r2,18264
8110474c:	1885883a 	add	r2,r3,r2
81104750:	10800017 	ldw	r2,0(r2)
81104754:	1000683a 	jmp	r2
81104758:	81104778 	rdprs	r4,r16,16669
8110475c:	81104788 	cmpgei	r4,r16,16670
81104760:	81104798 	cmpnei	r4,r16,16670
81104764:	811047a8 	cmpgeui	r4,r16,16670
81104768:	811047b8 	rdprs	r4,r16,16670
8110476c:	811047c8 	cmpgei	r4,r16,16671
81104770:	811047d8 	cmpnei	r4,r16,16671
81104774:	811047e8 	cmpgeui	r4,r16,16671
	case eCommSpwCh1:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81104778:	00a04834 	movhi	r2,33056
8110477c:	108b0004 	addi	r2,r2,11264
81104780:	e0bffd15 	stw	r2,-12(fp)
		break;
81104784:	00001e06 	br	81104800 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh2:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81104788:	00a04834 	movhi	r2,33056
8110478c:	108a0004 	addi	r2,r2,10240
81104790:	e0bffd15 	stw	r2,-12(fp)
		break;
81104794:	00001a06 	br	81104800 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh3:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81104798:	00a04834 	movhi	r2,33056
8110479c:	108b0004 	addi	r2,r2,11264
811047a0:	e0bffd15 	stw	r2,-12(fp)
		break;
811047a4:	00001606 	br	81104800 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh4:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
811047a8:	00a04834 	movhi	r2,33056
811047ac:	108a0004 	addi	r2,r2,10240
811047b0:	e0bffd15 	stw	r2,-12(fp)
		break;
811047b4:	00001206 	br	81104800 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh5:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
811047b8:	00a04834 	movhi	r2,33056
811047bc:	108b0004 	addi	r2,r2,11264
811047c0:	e0bffd15 	stw	r2,-12(fp)
		break;
811047c4:	00000e06 	br	81104800 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh6:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
811047c8:	00a04834 	movhi	r2,33056
811047cc:	108a0004 	addi	r2,r2,10240
811047d0:	e0bffd15 	stw	r2,-12(fp)
		break;
811047d4:	00000a06 	br	81104800 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh7:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
811047d8:	00a04834 	movhi	r2,33056
811047dc:	108b0004 	addi	r2,r2,11264
811047e0:	e0bffd15 	stw	r2,-12(fp)
		break;
811047e4:	00000606 	br	81104800 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh8:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
811047e8:	00a04834 	movhi	r2,33056
811047ec:	108a0004 	addi	r2,r2,10240
811047f0:	e0bffd15 	stw	r2,-12(fp)
		break;
811047f4:	00000206 	br	81104800 <bCommSetGlobalIrqEn+0x100>
	default:
		bStatus = FALSE;
811047f8:	e03ffb15 	stw	zero,-20(fp)
		break;
811047fc:	0001883a 	nop
	}

	if (bStatus) {
81104800:	e0bffb17 	ldw	r2,-20(fp)
81104804:	10001326 	beq	r2,zero,81104854 <bCommSetGlobalIrqEn+0x154>
		uliReg = uliCommReadReg(puliCommAddr,
81104808:	01400444 	movi	r5,17
8110480c:	e13ffd17 	ldw	r4,-12(fp)
81104810:	11049900 	call	81104990 <uliCommReadReg>
81104814:	e0bffc15 	stw	r2,-16(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (bGlobalIrqEnable) {
81104818:	e0bffe17 	ldw	r2,-8(fp)
8110481c:	10000426 	beq	r2,zero,81104830 <bCommSetGlobalIrqEn+0x130>
			uliReg |= COMM_IRQ_GLOBAL_EN_MSK;
81104820:	e0bffc17 	ldw	r2,-16(fp)
81104824:	10800074 	orhi	r2,r2,1
81104828:	e0bffc15 	stw	r2,-16(fp)
8110482c:	00000506 	br	81104844 <bCommSetGlobalIrqEn+0x144>
		} else {
			uliReg &= (~COMM_IRQ_GLOBAL_EN_MSK);
81104830:	e0fffc17 	ldw	r3,-16(fp)
81104834:	00bffff4 	movhi	r2,65535
81104838:	10bfffc4 	addi	r2,r2,-1
8110483c:	1884703a 	and	r2,r3,r2
81104840:	e0bffc15 	stw	r2,-16(fp)
		}

		vCommWriteReg(puliCommAddr, COMM_IRQ_CONTROL_REG_OFST, uliReg);
81104844:	e1bffc17 	ldw	r6,-16(fp)
81104848:	01400444 	movi	r5,17
8110484c:	e13ffd17 	ldw	r4,-12(fp)
81104850:	110493c0 	call	8110493c <vCommWriteReg>
	}

	return bStatus;
81104854:	e0bffb17 	ldw	r2,-20(fp)
}
81104858:	e037883a 	mov	sp,fp
8110485c:	dfc00117 	ldw	ra,4(sp)
81104860:	df000017 	ldw	fp,0(sp)
81104864:	dec00204 	addi	sp,sp,8
81104868:	f800283a 	ret

8110486c <bCommInitCh>:

bool bCommInitCh(TCommChannel *pxCommCh, alt_u8 ucCommCh) {
8110486c:	defffb04 	addi	sp,sp,-20
81104870:	de00012e 	bgeu	sp,et,81104878 <bCommInitCh+0xc>
81104874:	003b68fa 	trap	3
81104878:	dfc00415 	stw	ra,16(sp)
8110487c:	df000315 	stw	fp,12(sp)
81104880:	df000304 	addi	fp,sp,12
81104884:	e13ffe15 	stw	r4,-8(fp)
81104888:	2805883a 	mov	r2,r5
8110488c:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81104890:	00800044 	movi	r2,1
81104894:	e0bffd15 	stw	r2,-12(fp)

	if (!bSpwcInitCh(&(pxCommCh->xSpacewire), ucCommCh)) {
81104898:	e0bffe17 	ldw	r2,-8(fp)
8110489c:	10805704 	addi	r2,r2,348
811048a0:	e0ffff03 	ldbu	r3,-4(fp)
811048a4:	180b883a 	mov	r5,r3
811048a8:	1009883a 	mov	r4,r2
811048ac:	110a86c0 	call	8110a86c <bSpwcInitCh>
811048b0:	1000011e 	bne	r2,zero,811048b8 <bCommInitCh+0x4c>
		bStatus = FALSE;
811048b4:	e03ffd15 	stw	zero,-12(fp)
	}
	//vFeebInitIrq(ucCommCh);

	if (!bFeebInitCh(&(pxCommCh->xFeeBuffer), ucCommCh)) {
811048b8:	e0bffe17 	ldw	r2,-8(fp)
811048bc:	10800904 	addi	r2,r2,36
811048c0:	e0ffff03 	ldbu	r3,-4(fp)
811048c4:	180b883a 	mov	r5,r3
811048c8:	1009883a 	mov	r4,r2
811048cc:	1106c900 	call	81106c90 <bFeebInitCh>
811048d0:	1000011e 	bne	r2,zero,811048d8 <bCommInitCh+0x6c>
		bStatus = FALSE;
811048d4:	e03ffd15 	stw	zero,-12(fp)
	}
	if (!bRmapInitCh(&(pxCommCh->xRmap), ucCommCh)) {
811048d8:	e0bffe17 	ldw	r2,-8(fp)
811048dc:	10801104 	addi	r2,r2,68
811048e0:	e0ffff03 	ldbu	r3,-4(fp)
811048e4:	180b883a 	mov	r5,r3
811048e8:	1009883a 	mov	r4,r2
811048ec:	1109ec80 	call	81109ec8 <bRmapInitCh>
811048f0:	1000011e 	bne	r2,zero,811048f8 <bCommInitCh+0x8c>
		bStatus = FALSE;
811048f4:	e03ffd15 	stw	zero,-12(fp)
	}
	vRmapInitIrq(ucCommCh);
811048f8:	e0bfff03 	ldbu	r2,-4(fp)
811048fc:	1009883a 	mov	r4,r2
81104900:	11079040 	call	81107904 <vRmapInitIrq>

	if (!bDpktInitCh(&(pxCommCh->xDataPacket), ucCommCh)) {
81104904:	e0bffe17 	ldw	r2,-8(fp)
81104908:	10800104 	addi	r2,r2,4
8110490c:	e0ffff03 	ldbu	r3,-4(fp)
81104910:	180b883a 	mov	r5,r3
81104914:	1009883a 	mov	r4,r2
81104918:	11050080 	call	81105008 <bDpktInitCh>
8110491c:	1000011e 	bne	r2,zero,81104924 <bCommInitCh+0xb8>
		bStatus = FALSE;
81104920:	e03ffd15 	stw	zero,-12(fp)
	}
	return bStatus;
81104924:	e0bffd17 	ldw	r2,-12(fp)
}
81104928:	e037883a 	mov	sp,fp
8110492c:	dfc00117 	ldw	ra,4(sp)
81104930:	df000017 	ldw	fp,0(sp)
81104934:	dec00204 	addi	sp,sp,8
81104938:	f800283a 	ret

8110493c <vCommWriteReg>:
//! [public functions]

//! [private functions]
static void vCommWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
8110493c:	defffc04 	addi	sp,sp,-16
81104940:	de00012e 	bgeu	sp,et,81104948 <vCommWriteReg+0xc>
81104944:	003b68fa 	trap	3
81104948:	df000315 	stw	fp,12(sp)
8110494c:	df000304 	addi	fp,sp,12
81104950:	e13ffd15 	stw	r4,-12(fp)
81104954:	e17ffe15 	stw	r5,-8(fp)
81104958:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
8110495c:	e0bffe17 	ldw	r2,-8(fp)
81104960:	1085883a 	add	r2,r2,r2
81104964:	1085883a 	add	r2,r2,r2
81104968:	1007883a 	mov	r3,r2
8110496c:	e0bffd17 	ldw	r2,-12(fp)
81104970:	10c5883a 	add	r2,r2,r3
81104974:	e0ffff17 	ldw	r3,-4(fp)
81104978:	10c00015 	stw	r3,0(r2)
}
8110497c:	0001883a 	nop
81104980:	e037883a 	mov	sp,fp
81104984:	df000017 	ldw	fp,0(sp)
81104988:	dec00104 	addi	sp,sp,4
8110498c:	f800283a 	ret

81104990 <uliCommReadReg>:

static alt_u32 uliCommReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81104990:	defffc04 	addi	sp,sp,-16
81104994:	de00012e 	bgeu	sp,et,8110499c <uliCommReadReg+0xc>
81104998:	003b68fa 	trap	3
8110499c:	df000315 	stw	fp,12(sp)
811049a0:	df000304 	addi	fp,sp,12
811049a4:	e13ffe15 	stw	r4,-8(fp)
811049a8:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
811049ac:	e0bfff17 	ldw	r2,-4(fp)
811049b0:	1085883a 	add	r2,r2,r2
811049b4:	1085883a 	add	r2,r2,r2
811049b8:	1007883a 	mov	r3,r2
811049bc:	e0bffe17 	ldw	r2,-8(fp)
811049c0:	10c5883a 	add	r2,r2,r3
811049c4:	10800017 	ldw	r2,0(r2)
811049c8:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
811049cc:	e0bffd17 	ldw	r2,-12(fp)
}
811049d0:	e037883a 	mov	sp,fp
811049d4:	df000017 	ldw	fp,0(sp)
811049d8:	dec00104 	addi	sp,sp,4
811049dc:	f800283a 	ret

811049e0 <bDpktSetPacketConfig>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bDpktSetPacketConfig(TDpktChannel *pxDpktCh) {
811049e0:	defffb04 	addi	sp,sp,-20
811049e4:	de00012e 	bgeu	sp,et,811049ec <bDpktSetPacketConfig+0xc>
811049e8:	003b68fa 	trap	3
811049ec:	dfc00415 	stw	ra,16(sp)
811049f0:	df000315 	stw	fp,12(sp)
811049f4:	df000304 	addi	fp,sp,12
811049f8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811049fc:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104a00:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104a04:	e0bfff17 	ldw	r2,-4(fp)
81104a08:	10007a26 	beq	r2,zero,81104bf4 <bDpktSetPacketConfig+0x214>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104a0c:	e0bfff17 	ldw	r2,-4(fp)
81104a10:	10800017 	ldw	r2,0(r2)
81104a14:	01400204 	movi	r5,8
81104a18:	1009883a 	mov	r4,r2
81104a1c:	11051d00 	call	811051d0 <uliDpktReadReg>
81104a20:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
81104a24:	e0bffe17 	ldw	r2,-8(fp)
81104a28:	10bfffec 	andhi	r2,r2,65535
81104a2c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
81104a30:	e0bfff17 	ldw	r2,-4(fp)
81104a34:	1080010b 	ldhu	r2,4(r2)
81104a38:	10bfffcc 	andi	r2,r2,65535

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
81104a3c:	e0fffe17 	ldw	r3,-8(fp)
81104a40:	1884b03a 	or	r2,r3,r2
81104a44:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_Y_SIZE_MSK);
81104a48:	e0bffe17 	ldw	r2,-8(fp)
81104a4c:	10bfffcc 	andi	r2,r2,65535
81104a50:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdYSize << 16));
81104a54:	e0bfff17 	ldw	r2,-4(fp)
81104a58:	1080018b 	ldhu	r2,6(r2)
81104a5c:	10bfffcc 	andi	r2,r2,65535
81104a60:	1004943a 	slli	r2,r2,16
81104a64:	1007883a 	mov	r3,r2

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_Y_SIZE_MSK
81104a68:	e0bffe17 	ldw	r2,-8(fp)
81104a6c:	10c4b03a 	or	r2,r2,r3
81104a70:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdYSize << 16));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_1_REG_OFST,
81104a74:	e0bfff17 	ldw	r2,-4(fp)
81104a78:	10800017 	ldw	r2,0(r2)
81104a7c:	e1bffe17 	ldw	r6,-8(fp)
81104a80:	01400204 	movi	r5,8
81104a84:	1009883a 	mov	r4,r2
81104a88:	110517c0 	call	8110517c <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104a8c:	e0bfff17 	ldw	r2,-4(fp)
81104a90:	10800017 	ldw	r2,0(r2)
81104a94:	01400244 	movi	r5,9
81104a98:	1009883a 	mov	r4,r2
81104a9c:	11051d00 	call	811051d0 <uliDpktReadReg>
81104aa0:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
81104aa4:	e0bffe17 	ldw	r2,-8(fp)
81104aa8:	10bfffec 	andhi	r2,r2,65535
81104aac:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
81104ab0:	e0bfff17 	ldw	r2,-4(fp)
81104ab4:	1080020b 	ldhu	r2,8(r2)
81104ab8:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
81104abc:	e0fffe17 	ldw	r3,-8(fp)
81104ac0:	1884b03a 	or	r2,r3,r2
81104ac4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
81104ac8:	e0bffe17 	ldw	r2,-8(fp)
81104acc:	10bfffcc 	andi	r2,r2,65535
81104ad0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |=
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize
81104ad4:	e0bfff17 	ldw	r2,-4(fp)
81104ad8:	1080028b 	ldhu	r2,10(r2)
										<< 16));
81104adc:	10bfffcc 	andi	r2,r2,65535
81104ae0:	1004943a 	slli	r2,r2,16
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
		uliReg |=
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
81104ae4:	1007883a 	mov	r3,r2

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
		uliReg |=
81104ae8:	e0bffe17 	ldw	r2,-8(fp)
81104aec:	10c4b03a 	or	r2,r2,r3
81104af0:	e0bffe15 	stw	r2,-8(fp)
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize
										<< 16));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_2_REG_OFST,
81104af4:	e0bfff17 	ldw	r2,-4(fp)
81104af8:	10800017 	ldw	r2,0(r2)
81104afc:	e1bffe17 	ldw	r6,-8(fp)
81104b00:	01400244 	movi	r5,9
81104b04:	1009883a 	mov	r4,r2
81104b08:	110517c0 	call	8110517c <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104b0c:	e0bfff17 	ldw	r2,-4(fp)
81104b10:	10800017 	ldw	r2,0(r2)
81104b14:	01400284 	movi	r5,10
81104b18:	1009883a 	mov	r4,r2
81104b1c:	11051d00 	call	811051d0 <uliDpktReadReg>
81104b20:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
81104b24:	e0bffe17 	ldw	r2,-8(fp)
81104b28:	10bfffec 	andhi	r2,r2,65535
81104b2c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |=
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiPacketLength
81104b30:	e0bfff17 	ldw	r2,-4(fp)
81104b34:	1080030b 	ldhu	r2,12(r2)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
		uliReg |=
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
81104b38:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
		uliReg |=
81104b3c:	e0fffe17 	ldw	r3,-8(fp)
81104b40:	1884b03a 	or	r2,r3,r2
81104b44:	e0bffe15 	stw	r2,-8(fp)
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiPacketLength
										<< 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_3_REG_OFST,
81104b48:	e0bfff17 	ldw	r2,-4(fp)
81104b4c:	10800017 	ldw	r2,0(r2)
81104b50:	e1bffe17 	ldw	r6,-8(fp)
81104b54:	01400284 	movi	r5,10
81104b58:	1009883a 	mov	r4,r2
81104b5c:	110517c0 	call	8110517c <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104b60:	e0bfff17 	ldw	r2,-4(fp)
81104b64:	10800017 	ldw	r2,0(r2)
81104b68:	014002c4 	movi	r5,11
81104b6c:	1009883a 	mov	r4,r2
81104b70:	11051d00 	call	811051d0 <uliDpktReadReg>
81104b74:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_4_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
81104b78:	e0fffe17 	ldw	r3,-8(fp)
81104b7c:	00bfc004 	movi	r2,-256
81104b80:	1884703a 	and	r2,r3,r2
81104b84:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
81104b88:	e0bfff17 	ldw	r2,-4(fp)
81104b8c:	10800383 	ldbu	r2,14(r2)
81104b90:	10803fcc 	andi	r2,r2,255
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_4_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
81104b94:	e0fffe17 	ldw	r3,-8(fp)
81104b98:	1884b03a 	or	r2,r3,r2
81104b9c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_NUMBER_MSK);
81104ba0:	e0fffe17 	ldw	r3,-8(fp)
81104ba4:	00bffff4 	movhi	r2,65535
81104ba8:	10803fc4 	addi	r2,r2,255
81104bac:	1884703a 	and	r2,r3,r2
81104bb0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_NUMBER_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucCcdNumber << 8));
81104bb4:	e0bfff17 	ldw	r2,-4(fp)
81104bb8:	108003c3 	ldbu	r2,15(r2)
81104bbc:	10803fcc 	andi	r2,r2,255
81104bc0:	1004923a 	slli	r2,r2,8
81104bc4:	10bfffcc 	andi	r2,r2,65535

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_NUMBER_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_NUMBER_MSK
81104bc8:	e0fffe17 	ldw	r3,-8(fp)
81104bcc:	1884b03a 	or	r2,r3,r2
81104bd0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucCcdNumber << 8));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_4_REG_OFST,
81104bd4:	e0bfff17 	ldw	r2,-4(fp)
81104bd8:	10800017 	ldw	r2,0(r2)
81104bdc:	e1bffe17 	ldw	r6,-8(fp)
81104be0:	014002c4 	movi	r5,11
81104be4:	1009883a 	mov	r4,r2
81104be8:	110517c0 	call	8110517c <vDpktWriteReg>
				uliReg);

		bStatus = TRUE;
81104bec:	00800044 	movi	r2,1
81104bf0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104bf4:	e0bffd17 	ldw	r2,-12(fp)
}
81104bf8:	e037883a 	mov	sp,fp
81104bfc:	dfc00117 	ldw	ra,4(sp)
81104c00:	df000017 	ldw	fp,0(sp)
81104c04:	dec00204 	addi	sp,sp,8
81104c08:	f800283a 	ret

81104c0c <bDpktGetPacketConfig>:

bool bDpktGetPacketConfig(TDpktChannel *pxDpktCh) {
81104c0c:	defffb04 	addi	sp,sp,-20
81104c10:	de00012e 	bgeu	sp,et,81104c18 <bDpktGetPacketConfig+0xc>
81104c14:	003b68fa 	trap	3
81104c18:	dfc00415 	stw	ra,16(sp)
81104c1c:	df000315 	stw	fp,12(sp)
81104c20:	df000304 	addi	fp,sp,12
81104c24:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104c28:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104c2c:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104c30:	e0bfff17 	ldw	r2,-4(fp)
81104c34:	10003a26 	beq	r2,zero,81104d20 <bDpktGetPacketConfig+0x114>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104c38:	e0bfff17 	ldw	r2,-4(fp)
81104c3c:	10800017 	ldw	r2,0(r2)
81104c40:	01400204 	movi	r5,8
81104c44:	1009883a 	mov	r4,r2
81104c48:	11051d00 	call	811051d0 <uliDpktReadReg>
81104c4c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_1_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiCcdXSize = (alt_u16)(
81104c50:	e0bffe17 	ldw	r2,-8(fp)
81104c54:	1007883a 	mov	r3,r2
81104c58:	e0bfff17 	ldw	r2,-4(fp)
81104c5c:	10c0010d 	sth	r3,4(r2)
				(uliReg & COMM_DATA_PKT_CCD_X_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiCcdYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_CCD_Y_SIZE_MSK) >> 16);
81104c60:	e0bffe17 	ldw	r2,-8(fp)
81104c64:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_1_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiCcdXSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_CCD_X_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiCcdYSize = (alt_u16)(
81104c68:	1007883a 	mov	r3,r2
81104c6c:	e0bfff17 	ldw	r2,-4(fp)
81104c70:	10c0018d 	sth	r3,6(r2)
				(uliReg & COMM_DATA_PKT_CCD_Y_SIZE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104c74:	e0bfff17 	ldw	r2,-4(fp)
81104c78:	10800017 	ldw	r2,0(r2)
81104c7c:	01400244 	movi	r5,9
81104c80:	1009883a 	mov	r4,r2
81104c84:	11051d00 	call	811051d0 <uliDpktReadReg>
81104c88:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_2_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiDataYSize = (alt_u16)(
81104c8c:	e0bffe17 	ldw	r2,-8(fp)
81104c90:	1007883a 	mov	r3,r2
81104c94:	e0bfff17 	ldw	r2,-4(fp)
81104c98:	10c0020d 	sth	r3,8(r2)
				(uliReg & COMM_DATA_PKT_DATA_Y_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_OVER_Y_SIZE_MSK) >> 16);
81104c9c:	e0bffe17 	ldw	r2,-8(fp)
81104ca0:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_2_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiDataYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_DATA_Y_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize = (alt_u16)(
81104ca4:	1007883a 	mov	r3,r2
81104ca8:	e0bfff17 	ldw	r2,-4(fp)
81104cac:	10c0028d 	sth	r3,10(r2)
				(uliReg & COMM_DATA_PKT_OVER_Y_SIZE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104cb0:	e0bfff17 	ldw	r2,-4(fp)
81104cb4:	10800017 	ldw	r2,0(r2)
81104cb8:	01400284 	movi	r5,10
81104cbc:	1009883a 	mov	r4,r2
81104cc0:	11051d00 	call	811051d0 <uliDpktReadReg>
81104cc4:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiPacketLength = (alt_u16)(
81104cc8:	e0bffe17 	ldw	r2,-8(fp)
81104ccc:	1007883a 	mov	r3,r2
81104cd0:	e0bfff17 	ldw	r2,-4(fp)
81104cd4:	10c0030d 	sth	r3,12(r2)
				(uliReg & COMM_DATA_PKT_LENGTH_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104cd8:	e0bfff17 	ldw	r2,-4(fp)
81104cdc:	10800017 	ldw	r2,0(r2)
81104ce0:	014002c4 	movi	r5,11
81104ce4:	1009883a 	mov	r4,r2
81104ce8:	11051d00 	call	811051d0 <uliDpktReadReg>
81104cec:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_4_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.ucFeeMode= (alt_u8)(
81104cf0:	e0bffe17 	ldw	r2,-8(fp)
81104cf4:	1007883a 	mov	r3,r2
81104cf8:	e0bfff17 	ldw	r2,-4(fp)
81104cfc:	10c00385 	stb	r3,14(r2)
				(uliReg & COMM_DATA_PKT_FEE_MODE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.ucCcdNumber= (alt_u8)(
				(uliReg & COMM_DATA_PKT_CCD_NUMBER_MSK) >> 8);
81104d00:	e0bffe17 	ldw	r2,-8(fp)
81104d04:	10bfc00c 	andi	r2,r2,65280
81104d08:	1004d23a 	srli	r2,r2,8
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_4_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.ucFeeMode= (alt_u8)(
				(uliReg & COMM_DATA_PKT_FEE_MODE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.ucCcdNumber= (alt_u8)(
81104d0c:	1007883a 	mov	r3,r2
81104d10:	e0bfff17 	ldw	r2,-4(fp)
81104d14:	10c003c5 	stb	r3,15(r2)
				(uliReg & COMM_DATA_PKT_CCD_NUMBER_MSK) >> 8);

		bStatus = TRUE;
81104d18:	00800044 	movi	r2,1
81104d1c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104d20:	e0bffd17 	ldw	r2,-12(fp)
}
81104d24:	e037883a 	mov	sp,fp
81104d28:	dfc00117 	ldw	ra,4(sp)
81104d2c:	df000017 	ldw	fp,0(sp)
81104d30:	dec00204 	addi	sp,sp,8
81104d34:	f800283a 	ret

81104d38 <bDpktGetPacketHeader>:

bool bDpktGetPacketHeader(TDpktChannel *pxDpktCh) {
81104d38:	defffb04 	addi	sp,sp,-20
81104d3c:	de00012e 	bgeu	sp,et,81104d44 <bDpktGetPacketHeader+0xc>
81104d40:	003b68fa 	trap	3
81104d44:	dfc00415 	stw	ra,16(sp)
81104d48:	df000315 	stw	fp,12(sp)
81104d4c:	df000304 	addi	fp,sp,12
81104d50:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104d54:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104d58:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104d5c:	e0bfff17 	ldw	r2,-4(fp)
81104d60:	10002026 	beq	r2,zero,81104de4 <bDpktGetPacketHeader+0xac>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104d64:	e0bfff17 	ldw	r2,-4(fp)
81104d68:	10800017 	ldw	r2,0(r2)
81104d6c:	01400304 	movi	r5,12
81104d70:	1009883a 	mov	r4,r2
81104d74:	11051d00 	call	811051d0 <uliDpktReadReg>
81104d78:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_HDR_1_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiLength = (alt_u16)(
81104d7c:	e0bffe17 	ldw	r2,-8(fp)
81104d80:	1007883a 	mov	r3,r2
81104d84:	e0bfff17 	ldw	r2,-4(fp)
81104d88:	10c0040d 	sth	r3,16(r2)
				(uliReg & COMM_DATA_PKT_HDR_LENGTH_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiType = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_TYPE_MSK) >> 16);
81104d8c:	e0bffe17 	ldw	r2,-8(fp)
81104d90:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_HDR_1_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiLength = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_LENGTH_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiType = (alt_u16)(
81104d94:	1007883a 	mov	r3,r2
81104d98:	e0bfff17 	ldw	r2,-4(fp)
81104d9c:	10c0048d 	sth	r3,18(r2)
				(uliReg & COMM_DATA_PKT_HDR_TYPE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104da0:	e0bfff17 	ldw	r2,-4(fp)
81104da4:	10800017 	ldw	r2,0(r2)
81104da8:	01400344 	movi	r5,13
81104dac:	1009883a 	mov	r4,r2
81104db0:	11051d00 	call	811051d0 <uliDpktReadReg>
81104db4:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_HDR_2_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiFrameCounter = (alt_u16)(
81104db8:	e0bffe17 	ldw	r2,-8(fp)
81104dbc:	1007883a 	mov	r3,r2
81104dc0:	e0bfff17 	ldw	r2,-4(fp)
81104dc4:	10c0050d 	sth	r3,20(r2)
				(uliReg & COMM_DATA_PKT_HDR_FRAME_CNT_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiSequenceCounter = (alt_u16)(
				(uliReg & COMM_DATA_PKT_SEQ_CNT_MSK) >> 16);
81104dc8:	e0bffe17 	ldw	r2,-8(fp)
81104dcc:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_HDR_2_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiFrameCounter = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_FRAME_CNT_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiSequenceCounter = (alt_u16)(
81104dd0:	1007883a 	mov	r3,r2
81104dd4:	e0bfff17 	ldw	r2,-4(fp)
81104dd8:	10c0058d 	sth	r3,22(r2)
				(uliReg & COMM_DATA_PKT_SEQ_CNT_MSK) >> 16);

		bStatus = TRUE;
81104ddc:	00800044 	movi	r2,1
81104de0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104de4:	e0bffd17 	ldw	r2,-12(fp)
}
81104de8:	e037883a 	mov	sp,fp
81104dec:	dfc00117 	ldw	ra,4(sp)
81104df0:	df000017 	ldw	fp,0(sp)
81104df4:	dec00204 	addi	sp,sp,8
81104df8:	f800283a 	ret

81104dfc <bDpktSetPixelDelay>:

bool bDpktSetPixelDelay(TDpktChannel *pxDpktCh) {
81104dfc:	defffb04 	addi	sp,sp,-20
81104e00:	de00012e 	bgeu	sp,et,81104e08 <bDpktSetPixelDelay+0xc>
81104e04:	003b68fa 	trap	3
81104e08:	dfc00415 	stw	ra,16(sp)
81104e0c:	df000315 	stw	fp,12(sp)
81104e10:	df000304 	addi	fp,sp,12
81104e14:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104e18:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104e1c:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104e20:	e0bfff17 	ldw	r2,-4(fp)
81104e24:	10004126 	beq	r2,zero,81104f2c <bDpktSetPixelDelay+0x130>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104e28:	e0bfff17 	ldw	r2,-4(fp)
81104e2c:	10800017 	ldw	r2,0(r2)
81104e30:	01400384 	movi	r5,14
81104e34:	1009883a 	mov	r4,r2
81104e38:	11051d00 	call	811051d0 <uliDpktReadReg>
81104e3c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LINE_DLY_MSK);
81104e40:	e0bffe17 	ldw	r2,-8(fp)
81104e44:	10bfffec 	andhi	r2,r2,65535
81104e48:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_LINE_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiLineDelay << 0));
81104e4c:	e0bfff17 	ldw	r2,-4(fp)
81104e50:	1080060b 	ldhu	r2,24(r2)
81104e54:	10bfffcc 	andi	r2,r2,65535

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LINE_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_LINE_DLY_MSK
81104e58:	e0fffe17 	ldw	r3,-8(fp)
81104e5c:	1884b03a 	or	r2,r3,r2
81104e60:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiLineDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_1_REG_OFST,
81104e64:	e0bfff17 	ldw	r2,-4(fp)
81104e68:	10800017 	ldw	r2,0(r2)
81104e6c:	e1bffe17 	ldw	r6,-8(fp)
81104e70:	01400384 	movi	r5,14
81104e74:	1009883a 	mov	r4,r2
81104e78:	110517c0 	call	8110517c <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104e7c:	e0bfff17 	ldw	r2,-4(fp)
81104e80:	10800017 	ldw	r2,0(r2)
81104e84:	014003c4 	movi	r5,15
81104e88:	1009883a 	mov	r4,r2
81104e8c:	11051d00 	call	811051d0 <uliDpktReadReg>
81104e90:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_COLUMN_DLY_MSK);
81104e94:	e0bffe17 	ldw	r2,-8(fp)
81104e98:	10bfffec 	andhi	r2,r2,65535
81104e9c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_COLUMN_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiColumnDelay << 0));
81104ea0:	e0bfff17 	ldw	r2,-4(fp)
81104ea4:	1080068b 	ldhu	r2,26(r2)
81104ea8:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_COLUMN_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_COLUMN_DLY_MSK
81104eac:	e0fffe17 	ldw	r3,-8(fp)
81104eb0:	1884b03a 	or	r2,r3,r2
81104eb4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiColumnDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_2_REG_OFST,
81104eb8:	e0bfff17 	ldw	r2,-4(fp)
81104ebc:	10800017 	ldw	r2,0(r2)
81104ec0:	e1bffe17 	ldw	r6,-8(fp)
81104ec4:	014003c4 	movi	r5,15
81104ec8:	1009883a 	mov	r4,r2
81104ecc:	110517c0 	call	8110517c <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104ed0:	e0bfff17 	ldw	r2,-4(fp)
81104ed4:	10800017 	ldw	r2,0(r2)
81104ed8:	01400404 	movi	r5,16
81104edc:	1009883a 	mov	r4,r2
81104ee0:	11051d00 	call	811051d0 <uliDpktReadReg>
81104ee4:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_ADC_DLY_MSK);
81104ee8:	e0bffe17 	ldw	r2,-8(fp)
81104eec:	10bfffec 	andhi	r2,r2,65535
81104ef0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_ADC_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiAdcDelay << 0));
81104ef4:	e0bfff17 	ldw	r2,-4(fp)
81104ef8:	1080070b 	ldhu	r2,28(r2)
81104efc:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_ADC_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_ADC_DLY_MSK
81104f00:	e0fffe17 	ldw	r3,-8(fp)
81104f04:	1884b03a 	or	r2,r3,r2
81104f08:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiAdcDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_3_REG_OFST,
81104f0c:	e0bfff17 	ldw	r2,-4(fp)
81104f10:	10800017 	ldw	r2,0(r2)
81104f14:	e1bffe17 	ldw	r6,-8(fp)
81104f18:	01400404 	movi	r5,16
81104f1c:	1009883a 	mov	r4,r2
81104f20:	110517c0 	call	8110517c <vDpktWriteReg>
				uliReg);

		bStatus = TRUE;
81104f24:	00800044 	movi	r2,1
81104f28:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104f2c:	e0bffd17 	ldw	r2,-12(fp)
}
81104f30:	e037883a 	mov	sp,fp
81104f34:	dfc00117 	ldw	ra,4(sp)
81104f38:	df000017 	ldw	fp,0(sp)
81104f3c:	dec00204 	addi	sp,sp,8
81104f40:	f800283a 	ret

81104f44 <bDpktGetPixelDelay>:

bool bDpktGetPixelDelay(TDpktChannel *pxDpktCh) {
81104f44:	defffb04 	addi	sp,sp,-20
81104f48:	de00012e 	bgeu	sp,et,81104f50 <bDpktGetPixelDelay+0xc>
81104f4c:	003b68fa 	trap	3
81104f50:	dfc00415 	stw	ra,16(sp)
81104f54:	df000315 	stw	fp,12(sp)
81104f58:	df000304 	addi	fp,sp,12
81104f5c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104f60:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104f64:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104f68:	e0bfff17 	ldw	r2,-4(fp)
81104f6c:	10002026 	beq	r2,zero,81104ff0 <bDpktGetPixelDelay+0xac>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104f70:	e0bfff17 	ldw	r2,-4(fp)
81104f74:	10800017 	ldw	r2,0(r2)
81104f78:	01400384 	movi	r5,14
81104f7c:	1009883a 	mov	r4,r2
81104f80:	11051d00 	call	811051d0 <uliDpktReadReg>
81104f84:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiLineDelay = (alt_u16)(
81104f88:	e0bffe17 	ldw	r2,-8(fp)
81104f8c:	1007883a 	mov	r3,r2
81104f90:	e0bfff17 	ldw	r2,-4(fp)
81104f94:	10c0060d 	sth	r3,24(r2)
				(uliReg & COMM_DATA_PKT_LINE_DLY_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104f98:	e0bfff17 	ldw	r2,-4(fp)
81104f9c:	10800017 	ldw	r2,0(r2)
81104fa0:	014003c4 	movi	r5,15
81104fa4:	1009883a 	mov	r4,r2
81104fa8:	11051d00 	call	811051d0 <uliDpktReadReg>
81104fac:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiColumnDelay = (alt_u16)(
81104fb0:	e0bffe17 	ldw	r2,-8(fp)
81104fb4:	1007883a 	mov	r3,r2
81104fb8:	e0bfff17 	ldw	r2,-4(fp)
81104fbc:	10c0068d 	sth	r3,26(r2)
				(uliReg & COMM_DATA_PKT_COLUMN_DLY_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104fc0:	e0bfff17 	ldw	r2,-4(fp)
81104fc4:	10800017 	ldw	r2,0(r2)
81104fc8:	01400404 	movi	r5,16
81104fcc:	1009883a 	mov	r4,r2
81104fd0:	11051d00 	call	811051d0 <uliDpktReadReg>
81104fd4:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiAdcDelay = (alt_u16)(
81104fd8:	e0bffe17 	ldw	r2,-8(fp)
81104fdc:	1007883a 	mov	r3,r2
81104fe0:	e0bfff17 	ldw	r2,-4(fp)
81104fe4:	10c0070d 	sth	r3,28(r2)
				(uliReg & COMM_DATA_PKT_ADC_DLY_MSK) >> 0);

		bStatus = TRUE;
81104fe8:	00800044 	movi	r2,1
81104fec:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104ff0:	e0bffd17 	ldw	r2,-12(fp)
}
81104ff4:	e037883a 	mov	sp,fp
81104ff8:	dfc00117 	ldw	ra,4(sp)
81104ffc:	df000017 	ldw	fp,0(sp)
81105000:	dec00204 	addi	sp,sp,8
81105004:	f800283a 	ret

81105008 <bDpktInitCh>:

bool bDpktInitCh(TDpktChannel *pxDpktCh, alt_u8 ucCommCh) {
81105008:	defffb04 	addi	sp,sp,-20
8110500c:	de00012e 	bgeu	sp,et,81105014 <bDpktInitCh+0xc>
81105010:	003b68fa 	trap	3
81105014:	dfc00415 	stw	ra,16(sp)
81105018:	df000315 	stw	fp,12(sp)
8110501c:	df000304 	addi	fp,sp,12
81105020:	e13ffe15 	stw	r4,-8(fp)
81105024:	2805883a 	mov	r2,r5
81105028:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
8110502c:	e03ffd15 	stw	zero,-12(fp)

	if (pxDpktCh != NULL) {
81105030:	e0bffe17 	ldw	r2,-8(fp)
81105034:	10004b26 	beq	r2,zero,81105164 <bDpktInitCh+0x15c>
		bStatus = TRUE;
81105038:	00800044 	movi	r2,1
8110503c:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81105040:	e0bfff03 	ldbu	r2,-4(fp)
81105044:	10c00228 	cmpgeui	r3,r2,8
81105048:	1800361e 	bne	r3,zero,81105124 <bDpktInitCh+0x11c>
8110504c:	100690ba 	slli	r3,r2,2
81105050:	00a04434 	movhi	r2,33040
81105054:	10941904 	addi	r2,r2,20580
81105058:	1885883a 	add	r2,r3,r2
8110505c:	10800017 	ldw	r2,0(r2)
81105060:	1000683a 	jmp	r2
81105064:	81105084 	addi	r4,r16,16706
81105068:	81105098 	cmpnei	r4,r16,16706
8110506c:	811050ac 	andhi	r4,r16,16706
81105070:	811050c0 	call	8811050c <__reset+0x20f050c>
81105074:	811050d4 	ori	r4,r16,16707
81105078:	811050e8 	cmpgeui	r4,r16,16707
8110507c:	811050fc 	xorhi	r4,r16,16707
81105080:	81105110 	cmplti	r4,r16,16708
		case eCommSpwCh1:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81105084:	e0fffe17 	ldw	r3,-8(fp)
81105088:	00a04834 	movhi	r2,33056
8110508c:	108b0004 	addi	r2,r2,11264
81105090:	18800015 	stw	r2,0(r3)
			break;
81105094:	00002506 	br	8110512c <bDpktInitCh+0x124>
		case eCommSpwCh2:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81105098:	e0fffe17 	ldw	r3,-8(fp)
8110509c:	00a04834 	movhi	r2,33056
811050a0:	108a0004 	addi	r2,r2,10240
811050a4:	18800015 	stw	r2,0(r3)
			break;
811050a8:	00002006 	br	8110512c <bDpktInitCh+0x124>
		case eCommSpwCh3:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
811050ac:	e0fffe17 	ldw	r3,-8(fp)
811050b0:	00a04834 	movhi	r2,33056
811050b4:	108b0004 	addi	r2,r2,11264
811050b8:	18800015 	stw	r2,0(r3)
			break;
811050bc:	00001b06 	br	8110512c <bDpktInitCh+0x124>
		case eCommSpwCh4:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
811050c0:	e0fffe17 	ldw	r3,-8(fp)
811050c4:	00a04834 	movhi	r2,33056
811050c8:	108a0004 	addi	r2,r2,10240
811050cc:	18800015 	stw	r2,0(r3)
			break;
811050d0:	00001606 	br	8110512c <bDpktInitCh+0x124>
		case eCommSpwCh5:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
811050d4:	e0fffe17 	ldw	r3,-8(fp)
811050d8:	00a04834 	movhi	r2,33056
811050dc:	108b0004 	addi	r2,r2,11264
811050e0:	18800015 	stw	r2,0(r3)
			break;
811050e4:	00001106 	br	8110512c <bDpktInitCh+0x124>
		case eCommSpwCh6:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
811050e8:	e0fffe17 	ldw	r3,-8(fp)
811050ec:	00a04834 	movhi	r2,33056
811050f0:	108a0004 	addi	r2,r2,10240
811050f4:	18800015 	stw	r2,0(r3)
			break;
811050f8:	00000c06 	br	8110512c <bDpktInitCh+0x124>
		case eCommSpwCh7:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
811050fc:	e0fffe17 	ldw	r3,-8(fp)
81105100:	00a04834 	movhi	r2,33056
81105104:	108b0004 	addi	r2,r2,11264
81105108:	18800015 	stw	r2,0(r3)
			break;
8110510c:	00000706 	br	8110512c <bDpktInitCh+0x124>
		case eCommSpwCh8:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81105110:	e0fffe17 	ldw	r3,-8(fp)
81105114:	00a04834 	movhi	r2,33056
81105118:	108a0004 	addi	r2,r2,10240
8110511c:	18800015 	stw	r2,0(r3)
			break;
81105120:	00000206 	br	8110512c <bDpktInitCh+0x124>
		default:
			bStatus = FALSE;
81105124:	e03ffd15 	stw	zero,-12(fp)
			break;
81105128:	0001883a 	nop
		}

		if (bStatus) {
8110512c:	e0bffd17 	ldw	r2,-12(fp)
81105130:	10000c26 	beq	r2,zero,81105164 <bDpktInitCh+0x15c>
			if (!bDpktGetPacketConfig(pxDpktCh)) {
81105134:	e13ffe17 	ldw	r4,-8(fp)
81105138:	1104c0c0 	call	81104c0c <bDpktGetPacketConfig>
8110513c:	1000011e 	bne	r2,zero,81105144 <bDpktInitCh+0x13c>
				bStatus = FALSE;
81105140:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bDpktGetPacketHeader(pxDpktCh)) {
81105144:	e13ffe17 	ldw	r4,-8(fp)
81105148:	1104d380 	call	81104d38 <bDpktGetPacketHeader>
8110514c:	1000011e 	bne	r2,zero,81105154 <bDpktInitCh+0x14c>
				bStatus = FALSE;
81105150:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bDpktGetPixelDelay(pxDpktCh)) {
81105154:	e13ffe17 	ldw	r4,-8(fp)
81105158:	1104f440 	call	81104f44 <bDpktGetPixelDelay>
8110515c:	1000011e 	bne	r2,zero,81105164 <bDpktInitCh+0x15c>
				bStatus = FALSE;
81105160:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81105164:	e0bffd17 	ldw	r2,-12(fp)
}
81105168:	e037883a 	mov	sp,fp
8110516c:	dfc00117 	ldw	ra,4(sp)
81105170:	df000017 	ldw	fp,0(sp)
81105174:	dec00204 	addi	sp,sp,8
81105178:	f800283a 	ret

8110517c <vDpktWriteReg>:
//! [public functions]

//! [private functions]
static void vDpktWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
8110517c:	defffc04 	addi	sp,sp,-16
81105180:	de00012e 	bgeu	sp,et,81105188 <vDpktWriteReg+0xc>
81105184:	003b68fa 	trap	3
81105188:	df000315 	stw	fp,12(sp)
8110518c:	df000304 	addi	fp,sp,12
81105190:	e13ffd15 	stw	r4,-12(fp)
81105194:	e17ffe15 	stw	r5,-8(fp)
81105198:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
8110519c:	e0bffe17 	ldw	r2,-8(fp)
811051a0:	1085883a 	add	r2,r2,r2
811051a4:	1085883a 	add	r2,r2,r2
811051a8:	1007883a 	mov	r3,r2
811051ac:	e0bffd17 	ldw	r2,-12(fp)
811051b0:	10c5883a 	add	r2,r2,r3
811051b4:	e0ffff17 	ldw	r3,-4(fp)
811051b8:	10c00015 	stw	r3,0(r2)
}
811051bc:	0001883a 	nop
811051c0:	e037883a 	mov	sp,fp
811051c4:	df000017 	ldw	fp,0(sp)
811051c8:	dec00104 	addi	sp,sp,4
811051cc:	f800283a 	ret

811051d0 <uliDpktReadReg>:

static alt_u32 uliDpktReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
811051d0:	defffc04 	addi	sp,sp,-16
811051d4:	de00012e 	bgeu	sp,et,811051dc <uliDpktReadReg+0xc>
811051d8:	003b68fa 	trap	3
811051dc:	df000315 	stw	fp,12(sp)
811051e0:	df000304 	addi	fp,sp,12
811051e4:	e13ffe15 	stw	r4,-8(fp)
811051e8:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
811051ec:	e0bfff17 	ldw	r2,-4(fp)
811051f0:	1085883a 	add	r2,r2,r2
811051f4:	1085883a 	add	r2,r2,r2
811051f8:	1007883a 	mov	r3,r2
811051fc:	e0bffe17 	ldw	r2,-8(fp)
81105200:	10c5883a 	add	r2,r2,r3
81105204:	10800017 	ldw	r2,0(r2)
81105208:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8110520c:	e0bffd17 	ldw	r2,-12(fp)
}
81105210:	e037883a 	mov	sp,fp
81105214:	df000017 	ldw	fp,0(sp)
81105218:	dec00104 	addi	sp,sp,4
8110521c:	f800283a 	ret

81105220 <usiAdcPxDelayCalcPeriodNs>:

/*
 * Return the necessary delay value for a
 * ADC Pixel Delay period in uliPeriodNs ns.
 */
alt_u16 usiAdcPxDelayCalcPeriodNs(alt_u32 uliPeriodNs) {
81105220:	defffc04 	addi	sp,sp,-16
81105224:	de00012e 	bgeu	sp,et,8110522c <usiAdcPxDelayCalcPeriodNs+0xc>
81105228:	003b68fa 	trap	3
8110522c:	dfc00315 	stw	ra,12(sp)
81105230:	df000215 	stw	fp,8(sp)
81105234:	df000204 	addi	fp,sp,8
81105238:	e13fff15 	stw	r4,-4(fp)
	 * Delay[ns] / 10 = Delay[ns] * 1e-1
	 * AdcPxDelay = Delay[ns] * 1e-1
	 */

	alt_u16 usiAdcPxDelay;
	usiAdcPxDelay = (alt_u16) ((float) uliPeriodNs * 1e-1);
8110523c:	e13fff17 	ldw	r4,-4(fp)
81105240:	111fdec0 	call	8111fdec <__floatunsisf>
81105244:	1007883a 	mov	r3,r2
81105248:	1809883a 	mov	r4,r3
8110524c:	11211480 	call	81121148 <__extendsfdf2>
81105250:	1011883a 	mov	r8,r2
81105254:	1813883a 	mov	r9,r3
81105258:	01a666b4 	movhi	r6,39322
8110525c:	31a66684 	addi	r6,r6,-26214
81105260:	01cfeeb4 	movhi	r7,16314
81105264:	39e66644 	addi	r7,r7,-26215
81105268:	4009883a 	mov	r4,r8
8110526c:	480b883a 	mov	r5,r9
81105270:	111ffc00 	call	8111ffc0 <__muldf3>
81105274:	1009883a 	mov	r4,r2
81105278:	180b883a 	mov	r5,r3
8110527c:	2005883a 	mov	r2,r4
81105280:	2807883a 	mov	r3,r5
81105284:	1009883a 	mov	r4,r2
81105288:	180b883a 	mov	r5,r3
8110528c:	111f3f80 	call	8111f3f8 <__fixunsdfsi>
81105290:	e0bffe0d 	sth	r2,-8(fp)

	return usiAdcPxDelay;
81105294:	e0bffe0b 	ldhu	r2,-8(fp)
}
81105298:	e037883a 	mov	sp,fp
8110529c:	dfc00117 	ldw	ra,4(sp)
811052a0:	df000017 	ldw	fp,0(sp)
811052a4:	dec00204 	addi	sp,sp,8
811052a8:	f800283a 	ret

811052ac <usiLineTrDelayCalcPeriodNs>:

/*
 * Return the necessary delay value for a
 * Line Transfer Delay period in uliPeriodNs ns.
 */
alt_u16 usiLineTrDelayCalcPeriodNs(alt_u32 uliPeriodNs) {
811052ac:	defffc04 	addi	sp,sp,-16
811052b0:	de00012e 	bgeu	sp,et,811052b8 <usiLineTrDelayCalcPeriodNs+0xc>
811052b4:	003b68fa 	trap	3
811052b8:	dfc00315 	stw	ra,12(sp)
811052bc:	df000215 	stw	fp,8(sp)
811052c0:	df000204 	addi	fp,sp,8
811052c4:	e13fff15 	stw	r4,-4(fp)
	 * Delay[ns] / 100 = Delay[ns] * 1e-2
	 * LineTrDelay = Delay[ns] * 1e-2
	 */

	alt_u16 LineTrDelay;
	LineTrDelay = (alt_u16) ((float) uliPeriodNs * 1e-2);
811052c8:	e13fff17 	ldw	r4,-4(fp)
811052cc:	111fdec0 	call	8111fdec <__floatunsisf>
811052d0:	1007883a 	mov	r3,r2
811052d4:	1809883a 	mov	r4,r3
811052d8:	11211480 	call	81121148 <__extendsfdf2>
811052dc:	1011883a 	mov	r8,r2
811052e0:	1813883a 	mov	r9,r3
811052e4:	0191ebb4 	movhi	r6,18350
811052e8:	31851ec4 	addi	r6,r6,5243
811052ec:	01cfe134 	movhi	r7,16260
811052f0:	39deb844 	addi	r7,r7,31457
811052f4:	4009883a 	mov	r4,r8
811052f8:	480b883a 	mov	r5,r9
811052fc:	111ffc00 	call	8111ffc0 <__muldf3>
81105300:	1009883a 	mov	r4,r2
81105304:	180b883a 	mov	r5,r3
81105308:	2005883a 	mov	r2,r4
8110530c:	2807883a 	mov	r3,r5
81105310:	1009883a 	mov	r4,r2
81105314:	180b883a 	mov	r5,r3
81105318:	111f3f80 	call	8111f3f8 <__fixunsdfsi>
8110531c:	e0bffe0d 	sth	r2,-8(fp)

	return LineTrDelay;
81105320:	e0bffe0b 	ldhu	r2,-8(fp)
}
81105324:	e037883a 	mov	sp,fp
81105328:	dfc00117 	ldw	ra,4(sp)
8110532c:	df000017 	ldw	fp,0(sp)
81105330:	dec00204 	addi	sp,sp,8
81105334:	f800283a 	ret

81105338 <vFeebCh1HandleIrq>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vFeebCh1HandleIrq(void* pvContext) {
81105338:	defffb04 	addi	sp,sp,-20
8110533c:	de00012e 	bgeu	sp,et,81105344 <vFeebCh1HandleIrq+0xc>
81105340:	003b68fa 	trap	3
81105344:	dfc00415 	stw	ra,16(sp)
81105348:	df000315 	stw	fp,12(sp)
8110534c:	df000304 	addi	fp,sp,12
81105350:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105354:	e0bfff17 	ldw	r2,-4(fp)
81105358:	e0bffd15 	stw	r2,-12(fp)
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	INT8U error_codel;
	tQMask uiCmdtoSend;

	vFeebCh1IrqFlagClrBufferEmpty();
8110535c:	11056480 	call	81105648 <vFeebCh1IrqFlagClrBufferEmpty>
	/* Make one requests for the Double buffer */
	/* Address of the NFEE is hard coded */



}
81105360:	0001883a 	nop
81105364:	e037883a 	mov	sp,fp
81105368:	dfc00117 	ldw	ra,4(sp)
8110536c:	df000017 	ldw	fp,0(sp)
81105370:	dec00204 	addi	sp,sp,8
81105374:	f800283a 	ret

81105378 <vFeebCh2HandleIrq>:

void vFeebCh2HandleIrq(void* pvContext) {
81105378:	defffb04 	addi	sp,sp,-20
8110537c:	de00012e 	bgeu	sp,et,81105384 <vFeebCh2HandleIrq+0xc>
81105380:	003b68fa 	trap	3
81105384:	dfc00415 	stw	ra,16(sp)
81105388:	df000315 	stw	fp,12(sp)
8110538c:	df000304 	addi	fp,sp,12
81105390:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105394:	e0bfff17 	ldw	r2,-4(fp)
81105398:	e0bffd15 	stw	r2,-12(fp)

	INT8U error_codel;
	tQMask uiCmdtoSend;

	vFeebCh2IrqFlagClrBufferEmpty();
8110539c:	110568c0 	call	8110568c <vFeebCh2IrqFlagClrBufferEmpty>
	if ( error_codel != OS_ERR_NONE ) {
		vFailRequestDMAFromIRQ( 1 );
	}
*/

}
811053a0:	0001883a 	nop
811053a4:	e037883a 	mov	sp,fp
811053a8:	dfc00117 	ldw	ra,4(sp)
811053ac:	df000017 	ldw	fp,0(sp)
811053b0:	dec00204 	addi	sp,sp,8
811053b4:	f800283a 	ret

811053b8 <vFeebCh3HandleIrq>:

void vFeebCh3HandleIrq(void* pvContext) {
811053b8:	defffa04 	addi	sp,sp,-24
811053bc:	de00012e 	bgeu	sp,et,811053c4 <vFeebCh3HandleIrq+0xc>
811053c0:	003b68fa 	trap	3
811053c4:	dfc00515 	stw	ra,20(sp)
811053c8:	df000415 	stw	fp,16(sp)
811053cc:	df000404 	addi	fp,sp,16
811053d0:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
811053d4:	e0bfff17 	ldw	r2,-4(fp)
811053d8:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
811053dc:	00800404 	movi	r2,16
811053e0:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
811053e4:	00bfe004 	movi	r2,-128
811053e8:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
811053ec:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 2;
811053f0:	00800084 	movi	r2,2
811053f4:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
811053f8:	d0a05d17 	ldw	r2,-32396(gp)
811053fc:	e0fffe17 	ldw	r3,-8(fp)
81105400:	180b883a 	mov	r5,r3
81105404:	1009883a 	mov	r4,r2
81105408:	113e0280 	call	8113e028 <OSQPost>
8110540c:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
81105410:	e0bffd03 	ldbu	r2,-12(fp)
81105414:	10000226 	beq	r2,zero,81105420 <vFeebCh3HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 2 );
81105418:	01000084 	movi	r4,2
8110541c:	111d4580 	call	8111d458 <vFailRequestDMAFromIRQ>
	}

	vFeebCh3IrqFlagClrBufferEmpty();
81105420:	11056d00 	call	811056d0 <vFeebCh3IrqFlagClrBufferEmpty>
}
81105424:	0001883a 	nop
81105428:	e037883a 	mov	sp,fp
8110542c:	dfc00117 	ldw	ra,4(sp)
81105430:	df000017 	ldw	fp,0(sp)
81105434:	dec00204 	addi	sp,sp,8
81105438:	f800283a 	ret

8110543c <vFeebCh4HandleIrq>:

void vFeebCh4HandleIrq(void* pvContext) {
8110543c:	defffa04 	addi	sp,sp,-24
81105440:	de00012e 	bgeu	sp,et,81105448 <vFeebCh4HandleIrq+0xc>
81105444:	003b68fa 	trap	3
81105448:	dfc00515 	stw	ra,20(sp)
8110544c:	df000415 	stw	fp,16(sp)
81105450:	df000404 	addi	fp,sp,16
81105454:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105458:	e0bfff17 	ldw	r2,-4(fp)
8110545c:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81105460:	00800404 	movi	r2,16
81105464:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
81105468:	00bfe004 	movi	r2,-128
8110546c:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
81105470:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 3;
81105474:	008000c4 	movi	r2,3
81105478:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
8110547c:	d0a05d17 	ldw	r2,-32396(gp)
81105480:	e0fffe17 	ldw	r3,-8(fp)
81105484:	180b883a 	mov	r5,r3
81105488:	1009883a 	mov	r4,r2
8110548c:	113e0280 	call	8113e028 <OSQPost>
81105490:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
81105494:	e0bffd03 	ldbu	r2,-12(fp)
81105498:	10000226 	beq	r2,zero,811054a4 <vFeebCh4HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 3 );
8110549c:	010000c4 	movi	r4,3
811054a0:	111d4580 	call	8111d458 <vFailRequestDMAFromIRQ>
	}

	vFeebCh4IrqFlagClrBufferEmpty();
811054a4:	11057140 	call	81105714 <vFeebCh4IrqFlagClrBufferEmpty>
}
811054a8:	0001883a 	nop
811054ac:	e037883a 	mov	sp,fp
811054b0:	dfc00117 	ldw	ra,4(sp)
811054b4:	df000017 	ldw	fp,0(sp)
811054b8:	dec00204 	addi	sp,sp,8
811054bc:	f800283a 	ret

811054c0 <vFeebCh5HandleIrq>:

void vFeebCh5HandleIrq(void* pvContext) {
811054c0:	defffa04 	addi	sp,sp,-24
811054c4:	de00012e 	bgeu	sp,et,811054cc <vFeebCh5HandleIrq+0xc>
811054c8:	003b68fa 	trap	3
811054cc:	dfc00515 	stw	ra,20(sp)
811054d0:	df000415 	stw	fp,16(sp)
811054d4:	df000404 	addi	fp,sp,16
811054d8:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
811054dc:	e0bfff17 	ldw	r2,-4(fp)
811054e0:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
811054e4:	00800404 	movi	r2,16
811054e8:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
811054ec:	00bfe004 	movi	r2,-128
811054f0:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
811054f4:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 4;
811054f8:	00800104 	movi	r2,4
811054fc:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
81105500:	d0a05d17 	ldw	r2,-32396(gp)
81105504:	e0fffe17 	ldw	r3,-8(fp)
81105508:	180b883a 	mov	r5,r3
8110550c:	1009883a 	mov	r4,r2
81105510:	113e0280 	call	8113e028 <OSQPost>
81105514:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
81105518:	e0bffd03 	ldbu	r2,-12(fp)
8110551c:	10000226 	beq	r2,zero,81105528 <vFeebCh5HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 4 );
81105520:	01000104 	movi	r4,4
81105524:	111d4580 	call	8111d458 <vFailRequestDMAFromIRQ>
	}

	vFeebCh5IrqFlagClrBufferEmpty();
81105528:	11057580 	call	81105758 <vFeebCh5IrqFlagClrBufferEmpty>
}
8110552c:	0001883a 	nop
81105530:	e037883a 	mov	sp,fp
81105534:	dfc00117 	ldw	ra,4(sp)
81105538:	df000017 	ldw	fp,0(sp)
8110553c:	dec00204 	addi	sp,sp,8
81105540:	f800283a 	ret

81105544 <vFeebCh6HandleIrq>:

void vFeebCh6HandleIrq(void* pvContext) {
81105544:	defffa04 	addi	sp,sp,-24
81105548:	de00012e 	bgeu	sp,et,81105550 <vFeebCh6HandleIrq+0xc>
8110554c:	003b68fa 	trap	3
81105550:	dfc00515 	stw	ra,20(sp)
81105554:	df000415 	stw	fp,16(sp)
81105558:	df000404 	addi	fp,sp,16
8110555c:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105560:	e0bfff17 	ldw	r2,-4(fp)
81105564:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81105568:	00800404 	movi	r2,16
8110556c:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
81105570:	00bfe004 	movi	r2,-128
81105574:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
81105578:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 5;
8110557c:	00800144 	movi	r2,5
81105580:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
81105584:	d0a05d17 	ldw	r2,-32396(gp)
81105588:	e0fffe17 	ldw	r3,-8(fp)
8110558c:	180b883a 	mov	r5,r3
81105590:	1009883a 	mov	r4,r2
81105594:	113e0280 	call	8113e028 <OSQPost>
81105598:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
8110559c:	e0bffd03 	ldbu	r2,-12(fp)
811055a0:	10000226 	beq	r2,zero,811055ac <vFeebCh6HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 5 );
811055a4:	01000144 	movi	r4,5
811055a8:	111d4580 	call	8111d458 <vFailRequestDMAFromIRQ>
	}


	vFeebCh6IrqFlagClrBufferEmpty();
811055ac:	110579c0 	call	8110579c <vFeebCh6IrqFlagClrBufferEmpty>
}
811055b0:	0001883a 	nop
811055b4:	e037883a 	mov	sp,fp
811055b8:	dfc00117 	ldw	ra,4(sp)
811055bc:	df000017 	ldw	fp,0(sp)
811055c0:	dec00204 	addi	sp,sp,8
811055c4:	f800283a 	ret

811055c8 <vFeebCh7HandleIrq>:

void vFeebCh7HandleIrq(void* pvContext) {
811055c8:	defffc04 	addi	sp,sp,-16
811055cc:	de00012e 	bgeu	sp,et,811055d4 <vFeebCh7HandleIrq+0xc>
811055d0:	003b68fa 	trap	3
811055d4:	dfc00315 	stw	ra,12(sp)
811055d8:	df000215 	stw	fp,8(sp)
811055dc:	df000204 	addi	fp,sp,8
811055e0:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
811055e4:	e0bfff17 	ldw	r2,-4(fp)
811055e8:	e0bffe15 	stw	r2,-8(fp)


	vFeebCh7IrqFlagClrBufferEmpty();
811055ec:	11057e00 	call	811057e0 <vFeebCh7IrqFlagClrBufferEmpty>
}
811055f0:	0001883a 	nop
811055f4:	e037883a 	mov	sp,fp
811055f8:	dfc00117 	ldw	ra,4(sp)
811055fc:	df000017 	ldw	fp,0(sp)
81105600:	dec00204 	addi	sp,sp,8
81105604:	f800283a 	ret

81105608 <vFeebCh8HandleIrq>:

void vFeebCh8HandleIrq(void* pvContext) {
81105608:	defffc04 	addi	sp,sp,-16
8110560c:	de00012e 	bgeu	sp,et,81105614 <vFeebCh8HandleIrq+0xc>
81105610:	003b68fa 	trap	3
81105614:	dfc00315 	stw	ra,12(sp)
81105618:	df000215 	stw	fp,8(sp)
8110561c:	df000204 	addi	fp,sp,8
81105620:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105624:	e0bfff17 	ldw	r2,-4(fp)
81105628:	e0bffe15 	stw	r2,-8(fp)


	vFeebCh8IrqFlagClrBufferEmpty();
8110562c:	11058240 	call	81105824 <vFeebCh8IrqFlagClrBufferEmpty>
}
81105630:	0001883a 	nop
81105634:	e037883a 	mov	sp,fp
81105638:	dfc00117 	ldw	ra,4(sp)
8110563c:	df000017 	ldw	fp,0(sp)
81105640:	dec00204 	addi	sp,sp,8
81105644:	f800283a 	ret

81105648 <vFeebCh1IrqFlagClrBufferEmpty>:

void vFeebCh1IrqFlagClrBufferEmpty(void) {
81105648:	defffe04 	addi	sp,sp,-8
8110564c:	de00012e 	bgeu	sp,et,81105654 <vFeebCh1IrqFlagClrBufferEmpty+0xc>
81105650:	003b68fa 	trap	3
81105654:	dfc00115 	stw	ra,4(sp)
81105658:	df000015 	stw	fp,0(sp)
8110565c:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81105660:	01804004 	movi	r6,256
81105664:	014004c4 	movi	r5,19
81105668:	01204834 	movhi	r4,33056
8110566c:	210b0004 	addi	r4,r4,11264
81105670:	1106e140 	call	81106e14 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105674:	0001883a 	nop
81105678:	e037883a 	mov	sp,fp
8110567c:	dfc00117 	ldw	ra,4(sp)
81105680:	df000017 	ldw	fp,0(sp)
81105684:	dec00204 	addi	sp,sp,8
81105688:	f800283a 	ret

8110568c <vFeebCh2IrqFlagClrBufferEmpty>:

void vFeebCh2IrqFlagClrBufferEmpty(void) {
8110568c:	defffe04 	addi	sp,sp,-8
81105690:	de00012e 	bgeu	sp,et,81105698 <vFeebCh2IrqFlagClrBufferEmpty+0xc>
81105694:	003b68fa 	trap	3
81105698:	dfc00115 	stw	ra,4(sp)
8110569c:	df000015 	stw	fp,0(sp)
811056a0:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
811056a4:	01804004 	movi	r6,256
811056a8:	014004c4 	movi	r5,19
811056ac:	01204834 	movhi	r4,33056
811056b0:	210a0004 	addi	r4,r4,10240
811056b4:	1106e140 	call	81106e14 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811056b8:	0001883a 	nop
811056bc:	e037883a 	mov	sp,fp
811056c0:	dfc00117 	ldw	ra,4(sp)
811056c4:	df000017 	ldw	fp,0(sp)
811056c8:	dec00204 	addi	sp,sp,8
811056cc:	f800283a 	ret

811056d0 <vFeebCh3IrqFlagClrBufferEmpty>:

void vFeebCh3IrqFlagClrBufferEmpty(void) {
811056d0:	defffe04 	addi	sp,sp,-8
811056d4:	de00012e 	bgeu	sp,et,811056dc <vFeebCh3IrqFlagClrBufferEmpty+0xc>
811056d8:	003b68fa 	trap	3
811056dc:	dfc00115 	stw	ra,4(sp)
811056e0:	df000015 	stw	fp,0(sp)
811056e4:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
811056e8:	01804004 	movi	r6,256
811056ec:	014004c4 	movi	r5,19
811056f0:	01204834 	movhi	r4,33056
811056f4:	210b0004 	addi	r4,r4,11264
811056f8:	1106e140 	call	81106e14 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811056fc:	0001883a 	nop
81105700:	e037883a 	mov	sp,fp
81105704:	dfc00117 	ldw	ra,4(sp)
81105708:	df000017 	ldw	fp,0(sp)
8110570c:	dec00204 	addi	sp,sp,8
81105710:	f800283a 	ret

81105714 <vFeebCh4IrqFlagClrBufferEmpty>:

void vFeebCh4IrqFlagClrBufferEmpty(void) {
81105714:	defffe04 	addi	sp,sp,-8
81105718:	de00012e 	bgeu	sp,et,81105720 <vFeebCh4IrqFlagClrBufferEmpty+0xc>
8110571c:	003b68fa 	trap	3
81105720:	dfc00115 	stw	ra,4(sp)
81105724:	df000015 	stw	fp,0(sp)
81105728:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
8110572c:	01804004 	movi	r6,256
81105730:	014004c4 	movi	r5,19
81105734:	01204834 	movhi	r4,33056
81105738:	210a0004 	addi	r4,r4,10240
8110573c:	1106e140 	call	81106e14 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105740:	0001883a 	nop
81105744:	e037883a 	mov	sp,fp
81105748:	dfc00117 	ldw	ra,4(sp)
8110574c:	df000017 	ldw	fp,0(sp)
81105750:	dec00204 	addi	sp,sp,8
81105754:	f800283a 	ret

81105758 <vFeebCh5IrqFlagClrBufferEmpty>:

void vFeebCh5IrqFlagClrBufferEmpty(void) {
81105758:	defffe04 	addi	sp,sp,-8
8110575c:	de00012e 	bgeu	sp,et,81105764 <vFeebCh5IrqFlagClrBufferEmpty+0xc>
81105760:	003b68fa 	trap	3
81105764:	dfc00115 	stw	ra,4(sp)
81105768:	df000015 	stw	fp,0(sp)
8110576c:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105770:	01804004 	movi	r6,256
81105774:	014004c4 	movi	r5,19
81105778:	01204834 	movhi	r4,33056
8110577c:	210b0004 	addi	r4,r4,11264
81105780:	1106e140 	call	81106e14 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105784:	0001883a 	nop
81105788:	e037883a 	mov	sp,fp
8110578c:	dfc00117 	ldw	ra,4(sp)
81105790:	df000017 	ldw	fp,0(sp)
81105794:	dec00204 	addi	sp,sp,8
81105798:	f800283a 	ret

8110579c <vFeebCh6IrqFlagClrBufferEmpty>:

void vFeebCh6IrqFlagClrBufferEmpty(void) {
8110579c:	defffe04 	addi	sp,sp,-8
811057a0:	de00012e 	bgeu	sp,et,811057a8 <vFeebCh6IrqFlagClrBufferEmpty+0xc>
811057a4:	003b68fa 	trap	3
811057a8:	dfc00115 	stw	ra,4(sp)
811057ac:	df000015 	stw	fp,0(sp)
811057b0:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811057b4:	01804004 	movi	r6,256
811057b8:	014004c4 	movi	r5,19
811057bc:	01204834 	movhi	r4,33056
811057c0:	210a0004 	addi	r4,r4,10240
811057c4:	1106e140 	call	81106e14 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811057c8:	0001883a 	nop
811057cc:	e037883a 	mov	sp,fp
811057d0:	dfc00117 	ldw	ra,4(sp)
811057d4:	df000017 	ldw	fp,0(sp)
811057d8:	dec00204 	addi	sp,sp,8
811057dc:	f800283a 	ret

811057e0 <vFeebCh7IrqFlagClrBufferEmpty>:

void vFeebCh7IrqFlagClrBufferEmpty(void) {
811057e0:	defffe04 	addi	sp,sp,-8
811057e4:	de00012e 	bgeu	sp,et,811057ec <vFeebCh7IrqFlagClrBufferEmpty+0xc>
811057e8:	003b68fa 	trap	3
811057ec:	dfc00115 	stw	ra,4(sp)
811057f0:	df000015 	stw	fp,0(sp)
811057f4:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
811057f8:	01804004 	movi	r6,256
811057fc:	014004c4 	movi	r5,19
81105800:	01204834 	movhi	r4,33056
81105804:	210b0004 	addi	r4,r4,11264
81105808:	1106e140 	call	81106e14 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
8110580c:	0001883a 	nop
81105810:	e037883a 	mov	sp,fp
81105814:	dfc00117 	ldw	ra,4(sp)
81105818:	df000017 	ldw	fp,0(sp)
8110581c:	dec00204 	addi	sp,sp,8
81105820:	f800283a 	ret

81105824 <vFeebCh8IrqFlagClrBufferEmpty>:

void vFeebCh8IrqFlagClrBufferEmpty(void) {
81105824:	defffe04 	addi	sp,sp,-8
81105828:	de00012e 	bgeu	sp,et,81105830 <vFeebCh8IrqFlagClrBufferEmpty+0xc>
8110582c:	003b68fa 	trap	3
81105830:	dfc00115 	stw	ra,4(sp)
81105834:	df000015 	stw	fp,0(sp)
81105838:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
8110583c:	01804004 	movi	r6,256
81105840:	014004c4 	movi	r5,19
81105844:	01204834 	movhi	r4,33056
81105848:	210a0004 	addi	r4,r4,10240
8110584c:	1106e140 	call	81106e14 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105850:	0001883a 	nop
81105854:	e037883a 	mov	sp,fp
81105858:	dfc00117 	ldw	ra,4(sp)
8110585c:	df000017 	ldw	fp,0(sp)
81105860:	dec00204 	addi	sp,sp,8
81105864:	f800283a 	ret

81105868 <bFeebCh1IrqFlagBufferEmpty>:

bool bFeebCh1IrqFlagBufferEmpty(void) {
81105868:	defffd04 	addi	sp,sp,-12
8110586c:	de00012e 	bgeu	sp,et,81105874 <bFeebCh1IrqFlagBufferEmpty+0xc>
81105870:	003b68fa 	trap	3
81105874:	dfc00215 	stw	ra,8(sp)
81105878:	df000115 	stw	fp,4(sp)
8110587c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81105880:	01400484 	movi	r5,18
81105884:	01204834 	movhi	r4,33056
81105888:	210b0004 	addi	r4,r4,11264
8110588c:	1106e680 	call	81106e68 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105890:	1080400c 	andi	r2,r2,256
}

bool bFeebCh1IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81105894:	10000326 	beq	r2,zero,811058a4 <bFeebCh1IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105898:	00800044 	movi	r2,1
8110589c:	e0bfff15 	stw	r2,-4(fp)
811058a0:	00000106 	br	811058a8 <bFeebCh1IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811058a4:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811058a8:	e0bfff17 	ldw	r2,-4(fp)
}
811058ac:	e037883a 	mov	sp,fp
811058b0:	dfc00117 	ldw	ra,4(sp)
811058b4:	df000017 	ldw	fp,0(sp)
811058b8:	dec00204 	addi	sp,sp,8
811058bc:	f800283a 	ret

811058c0 <bFeebCh2IrqFlagBufferEmpty>:

bool bFeebCh2IrqFlagBufferEmpty(void) {
811058c0:	defffd04 	addi	sp,sp,-12
811058c4:	de00012e 	bgeu	sp,et,811058cc <bFeebCh2IrqFlagBufferEmpty+0xc>
811058c8:	003b68fa 	trap	3
811058cc:	dfc00215 	stw	ra,8(sp)
811058d0:	df000115 	stw	fp,4(sp)
811058d4:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
811058d8:	01400484 	movi	r5,18
811058dc:	01204834 	movhi	r4,33056
811058e0:	210a0004 	addi	r4,r4,10240
811058e4:	1106e680 	call	81106e68 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811058e8:	1080400c 	andi	r2,r2,256
}

bool bFeebCh2IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
811058ec:	10000326 	beq	r2,zero,811058fc <bFeebCh2IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811058f0:	00800044 	movi	r2,1
811058f4:	e0bfff15 	stw	r2,-4(fp)
811058f8:	00000106 	br	81105900 <bFeebCh2IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811058fc:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105900:	e0bfff17 	ldw	r2,-4(fp)
}
81105904:	e037883a 	mov	sp,fp
81105908:	dfc00117 	ldw	ra,4(sp)
8110590c:	df000017 	ldw	fp,0(sp)
81105910:	dec00204 	addi	sp,sp,8
81105914:	f800283a 	ret

81105918 <bFeebCh3IrqFlagBufferEmpty>:

bool bFeebCh3IrqFlagBufferEmpty(void) {
81105918:	defffd04 	addi	sp,sp,-12
8110591c:	de00012e 	bgeu	sp,et,81105924 <bFeebCh3IrqFlagBufferEmpty+0xc>
81105920:	003b68fa 	trap	3
81105924:	dfc00215 	stw	ra,8(sp)
81105928:	df000115 	stw	fp,4(sp)
8110592c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105930:	01400484 	movi	r5,18
81105934:	01204834 	movhi	r4,33056
81105938:	210b0004 	addi	r4,r4,11264
8110593c:	1106e680 	call	81106e68 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105940:	1080400c 	andi	r2,r2,256
}

bool bFeebCh3IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105944:	10000326 	beq	r2,zero,81105954 <bFeebCh3IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105948:	00800044 	movi	r2,1
8110594c:	e0bfff15 	stw	r2,-4(fp)
81105950:	00000106 	br	81105958 <bFeebCh3IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105954:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105958:	e0bfff17 	ldw	r2,-4(fp)
}
8110595c:	e037883a 	mov	sp,fp
81105960:	dfc00117 	ldw	ra,4(sp)
81105964:	df000017 	ldw	fp,0(sp)
81105968:	dec00204 	addi	sp,sp,8
8110596c:	f800283a 	ret

81105970 <bFeebCh4IrqFlagBufferEmpty>:

bool bFeebCh4IrqFlagBufferEmpty(void) {
81105970:	defffd04 	addi	sp,sp,-12
81105974:	de00012e 	bgeu	sp,et,8110597c <bFeebCh4IrqFlagBufferEmpty+0xc>
81105978:	003b68fa 	trap	3
8110597c:	dfc00215 	stw	ra,8(sp)
81105980:	df000115 	stw	fp,4(sp)
81105984:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81105988:	01400484 	movi	r5,18
8110598c:	01204834 	movhi	r4,33056
81105990:	210a0004 	addi	r4,r4,10240
81105994:	1106e680 	call	81106e68 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105998:	1080400c 	andi	r2,r2,256
}

bool bFeebCh4IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
8110599c:	10000326 	beq	r2,zero,811059ac <bFeebCh4IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811059a0:	00800044 	movi	r2,1
811059a4:	e0bfff15 	stw	r2,-4(fp)
811059a8:	00000106 	br	811059b0 <bFeebCh4IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811059ac:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811059b0:	e0bfff17 	ldw	r2,-4(fp)
}
811059b4:	e037883a 	mov	sp,fp
811059b8:	dfc00117 	ldw	ra,4(sp)
811059bc:	df000017 	ldw	fp,0(sp)
811059c0:	dec00204 	addi	sp,sp,8
811059c4:	f800283a 	ret

811059c8 <bFeebCh5IrqFlagBufferEmpty>:

bool bFeebCh5IrqFlagBufferEmpty(void) {
811059c8:	defffd04 	addi	sp,sp,-12
811059cc:	de00012e 	bgeu	sp,et,811059d4 <bFeebCh5IrqFlagBufferEmpty+0xc>
811059d0:	003b68fa 	trap	3
811059d4:	dfc00215 	stw	ra,8(sp)
811059d8:	df000115 	stw	fp,4(sp)
811059dc:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
811059e0:	01400484 	movi	r5,18
811059e4:	01204834 	movhi	r4,33056
811059e8:	210b0004 	addi	r4,r4,11264
811059ec:	1106e680 	call	81106e68 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811059f0:	1080400c 	andi	r2,r2,256
}

bool bFeebCh5IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
811059f4:	10000326 	beq	r2,zero,81105a04 <bFeebCh5IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811059f8:	00800044 	movi	r2,1
811059fc:	e0bfff15 	stw	r2,-4(fp)
81105a00:	00000106 	br	81105a08 <bFeebCh5IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105a04:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105a08:	e0bfff17 	ldw	r2,-4(fp)
}
81105a0c:	e037883a 	mov	sp,fp
81105a10:	dfc00117 	ldw	ra,4(sp)
81105a14:	df000017 	ldw	fp,0(sp)
81105a18:	dec00204 	addi	sp,sp,8
81105a1c:	f800283a 	ret

81105a20 <bFeebCh6IrqFlagBufferEmpty>:

bool bFeebCh6IrqFlagBufferEmpty(void) {
81105a20:	defffd04 	addi	sp,sp,-12
81105a24:	de00012e 	bgeu	sp,et,81105a2c <bFeebCh6IrqFlagBufferEmpty+0xc>
81105a28:	003b68fa 	trap	3
81105a2c:	dfc00215 	stw	ra,8(sp)
81105a30:	df000115 	stw	fp,4(sp)
81105a34:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105a38:	01400484 	movi	r5,18
81105a3c:	01204834 	movhi	r4,33056
81105a40:	210a0004 	addi	r4,r4,10240
81105a44:	1106e680 	call	81106e68 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105a48:	1080400c 	andi	r2,r2,256
}

bool bFeebCh6IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105a4c:	10000326 	beq	r2,zero,81105a5c <bFeebCh6IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105a50:	00800044 	movi	r2,1
81105a54:	e0bfff15 	stw	r2,-4(fp)
81105a58:	00000106 	br	81105a60 <bFeebCh6IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105a5c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105a60:	e0bfff17 	ldw	r2,-4(fp)
}
81105a64:	e037883a 	mov	sp,fp
81105a68:	dfc00117 	ldw	ra,4(sp)
81105a6c:	df000017 	ldw	fp,0(sp)
81105a70:	dec00204 	addi	sp,sp,8
81105a74:	f800283a 	ret

81105a78 <bFeebCh7IrqFlagBufferEmpty>:

bool bFeebCh7IrqFlagBufferEmpty(void) {
81105a78:	defffd04 	addi	sp,sp,-12
81105a7c:	de00012e 	bgeu	sp,et,81105a84 <bFeebCh7IrqFlagBufferEmpty+0xc>
81105a80:	003b68fa 	trap	3
81105a84:	dfc00215 	stw	ra,8(sp)
81105a88:	df000115 	stw	fp,4(sp)
81105a8c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81105a90:	01400484 	movi	r5,18
81105a94:	01204834 	movhi	r4,33056
81105a98:	210b0004 	addi	r4,r4,11264
81105a9c:	1106e680 	call	81106e68 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105aa0:	1080400c 	andi	r2,r2,256
}

bool bFeebCh7IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81105aa4:	10000326 	beq	r2,zero,81105ab4 <bFeebCh7IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105aa8:	00800044 	movi	r2,1
81105aac:	e0bfff15 	stw	r2,-4(fp)
81105ab0:	00000106 	br	81105ab8 <bFeebCh7IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105ab4:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105ab8:	e0bfff17 	ldw	r2,-4(fp)
}
81105abc:	e037883a 	mov	sp,fp
81105ac0:	dfc00117 	ldw	ra,4(sp)
81105ac4:	df000017 	ldw	fp,0(sp)
81105ac8:	dec00204 	addi	sp,sp,8
81105acc:	f800283a 	ret

81105ad0 <bFeebCh8IrqFlagBufferEmpty>:

bool bFeebCh8IrqFlagBufferEmpty(void) {
81105ad0:	defffd04 	addi	sp,sp,-12
81105ad4:	de00012e 	bgeu	sp,et,81105adc <bFeebCh8IrqFlagBufferEmpty+0xc>
81105ad8:	003b68fa 	trap	3
81105adc:	dfc00215 	stw	ra,8(sp)
81105ae0:	df000115 	stw	fp,4(sp)
81105ae4:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81105ae8:	01400484 	movi	r5,18
81105aec:	01204834 	movhi	r4,33056
81105af0:	210a0004 	addi	r4,r4,10240
81105af4:	1106e680 	call	81106e68 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105af8:	1080400c 	andi	r2,r2,256
}

bool bFeebCh8IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81105afc:	10000326 	beq	r2,zero,81105b0c <bFeebCh8IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105b00:	00800044 	movi	r2,1
81105b04:	e0bfff15 	stw	r2,-4(fp)
81105b08:	00000106 	br	81105b10 <bFeebCh8IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105b0c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105b10:	e0bfff17 	ldw	r2,-4(fp)
}
81105b14:	e037883a 	mov	sp,fp
81105b18:	dfc00117 	ldw	ra,4(sp)
81105b1c:	df000017 	ldw	fp,0(sp)
81105b20:	dec00204 	addi	sp,sp,8
81105b24:	f800283a 	ret

81105b28 <bFeebCh1SetBufferSize>:

bool bFeebCh1SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105b28:	defffa04 	addi	sp,sp,-24
81105b2c:	de00012e 	bgeu	sp,et,81105b34 <bFeebCh1SetBufferSize+0xc>
81105b30:	003b68fa 	trap	3
81105b34:	dfc00515 	stw	ra,20(sp)
81105b38:	df000415 	stw	fp,16(sp)
81105b3c:	df000404 	addi	fp,sp,16
81105b40:	2007883a 	mov	r3,r4
81105b44:	2805883a 	mov	r2,r5
81105b48:	e0fffe05 	stb	r3,-8(fp)
81105b4c:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105b50:	00800044 	movi	r2,1
81105b54:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105b58:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105b5c:	e0bffe03 	ldbu	r2,-8(fp)
81105b60:	10001f26 	beq	r2,zero,81105be0 <bFeebCh1SetBufferSize+0xb8>
81105b64:	e0bffe03 	ldbu	r2,-8(fp)
81105b68:	10800468 	cmpgeui	r2,r2,17
81105b6c:	10001c1e 	bne	r2,zero,81105be0 <bFeebCh1SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105b70:	e0bfff03 	ldbu	r2,-4(fp)
81105b74:	10000326 	beq	r2,zero,81105b84 <bFeebCh1SetBufferSize+0x5c>
81105b78:	10800060 	cmpeqi	r2,r2,1
81105b7c:	10000b1e 	bne	r2,zero,81105bac <bFeebCh1SetBufferSize+0x84>
81105b80:	00001406 	br	81105bd4 <bFeebCh1SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105b84:	e0bffe03 	ldbu	r2,-8(fp)
81105b88:	10bfffc4 	addi	r2,r2,-1
81105b8c:	108003cc 	andi	r2,r2,15
81105b90:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81105b94:	e1bffd17 	ldw	r6,-12(fp)
81105b98:	01400544 	movi	r5,21
81105b9c:	01204834 	movhi	r4,33056
81105ba0:	210b0004 	addi	r4,r4,11264
81105ba4:	1106e140 	call	81106e14 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105ba8:	00000c06 	br	81105bdc <bFeebCh1SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105bac:	e0bffe03 	ldbu	r2,-8(fp)
81105bb0:	10bfffc4 	addi	r2,r2,-1
81105bb4:	108003cc 	andi	r2,r2,15
81105bb8:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81105bbc:	e1bffd17 	ldw	r6,-12(fp)
81105bc0:	01400504 	movi	r5,20
81105bc4:	01204834 	movhi	r4,33056
81105bc8:	210b0004 	addi	r4,r4,11264
81105bcc:	1106e140 	call	81106e14 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105bd0:	00000206 	br	81105bdc <bFeebCh1SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105bd4:	e03ffc15 	stw	zero,-16(fp)
			break;
81105bd8:	0001883a 	nop
		}
	} else {
81105bdc:	00000106 	br	81105be4 <bFeebCh1SetBufferSize+0xbc>
		bStatus = FALSE;
81105be0:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105be4:	e0bffc17 	ldw	r2,-16(fp)
}
81105be8:	e037883a 	mov	sp,fp
81105bec:	dfc00117 	ldw	ra,4(sp)
81105bf0:	df000017 	ldw	fp,0(sp)
81105bf4:	dec00204 	addi	sp,sp,8
81105bf8:	f800283a 	ret

81105bfc <bFeebCh2SetBufferSize>:

bool bFeebCh2SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105bfc:	defffa04 	addi	sp,sp,-24
81105c00:	de00012e 	bgeu	sp,et,81105c08 <bFeebCh2SetBufferSize+0xc>
81105c04:	003b68fa 	trap	3
81105c08:	dfc00515 	stw	ra,20(sp)
81105c0c:	df000415 	stw	fp,16(sp)
81105c10:	df000404 	addi	fp,sp,16
81105c14:	2007883a 	mov	r3,r4
81105c18:	2805883a 	mov	r2,r5
81105c1c:	e0fffe05 	stb	r3,-8(fp)
81105c20:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105c24:	00800044 	movi	r2,1
81105c28:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105c2c:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105c30:	e0bffe03 	ldbu	r2,-8(fp)
81105c34:	10001f26 	beq	r2,zero,81105cb4 <bFeebCh2SetBufferSize+0xb8>
81105c38:	e0bffe03 	ldbu	r2,-8(fp)
81105c3c:	10800468 	cmpgeui	r2,r2,17
81105c40:	10001c1e 	bne	r2,zero,81105cb4 <bFeebCh2SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105c44:	e0bfff03 	ldbu	r2,-4(fp)
81105c48:	10000326 	beq	r2,zero,81105c58 <bFeebCh2SetBufferSize+0x5c>
81105c4c:	10800060 	cmpeqi	r2,r2,1
81105c50:	10000b1e 	bne	r2,zero,81105c80 <bFeebCh2SetBufferSize+0x84>
81105c54:	00001406 	br	81105ca8 <bFeebCh2SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105c58:	e0bffe03 	ldbu	r2,-8(fp)
81105c5c:	10bfffc4 	addi	r2,r2,-1
81105c60:	108003cc 	andi	r2,r2,15
81105c64:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81105c68:	e1bffd17 	ldw	r6,-12(fp)
81105c6c:	01400544 	movi	r5,21
81105c70:	01204834 	movhi	r4,33056
81105c74:	210a0004 	addi	r4,r4,10240
81105c78:	1106e140 	call	81106e14 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105c7c:	00000c06 	br	81105cb0 <bFeebCh2SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105c80:	e0bffe03 	ldbu	r2,-8(fp)
81105c84:	10bfffc4 	addi	r2,r2,-1
81105c88:	108003cc 	andi	r2,r2,15
81105c8c:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81105c90:	e1bffd17 	ldw	r6,-12(fp)
81105c94:	01400504 	movi	r5,20
81105c98:	01204834 	movhi	r4,33056
81105c9c:	210a0004 	addi	r4,r4,10240
81105ca0:	1106e140 	call	81106e14 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105ca4:	00000206 	br	81105cb0 <bFeebCh2SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105ca8:	e03ffc15 	stw	zero,-16(fp)
			break;
81105cac:	0001883a 	nop
		}
	} else {
81105cb0:	00000106 	br	81105cb8 <bFeebCh2SetBufferSize+0xbc>
		bStatus = FALSE;
81105cb4:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105cb8:	e0bffc17 	ldw	r2,-16(fp)
}
81105cbc:	e037883a 	mov	sp,fp
81105cc0:	dfc00117 	ldw	ra,4(sp)
81105cc4:	df000017 	ldw	fp,0(sp)
81105cc8:	dec00204 	addi	sp,sp,8
81105ccc:	f800283a 	ret

81105cd0 <bFeebCh3SetBufferSize>:

bool bFeebCh3SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105cd0:	defffa04 	addi	sp,sp,-24
81105cd4:	de00012e 	bgeu	sp,et,81105cdc <bFeebCh3SetBufferSize+0xc>
81105cd8:	003b68fa 	trap	3
81105cdc:	dfc00515 	stw	ra,20(sp)
81105ce0:	df000415 	stw	fp,16(sp)
81105ce4:	df000404 	addi	fp,sp,16
81105ce8:	2007883a 	mov	r3,r4
81105cec:	2805883a 	mov	r2,r5
81105cf0:	e0fffe05 	stb	r3,-8(fp)
81105cf4:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105cf8:	00800044 	movi	r2,1
81105cfc:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105d00:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105d04:	e0bffe03 	ldbu	r2,-8(fp)
81105d08:	10001f26 	beq	r2,zero,81105d88 <bFeebCh3SetBufferSize+0xb8>
81105d0c:	e0bffe03 	ldbu	r2,-8(fp)
81105d10:	10800468 	cmpgeui	r2,r2,17
81105d14:	10001c1e 	bne	r2,zero,81105d88 <bFeebCh3SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105d18:	e0bfff03 	ldbu	r2,-4(fp)
81105d1c:	10000326 	beq	r2,zero,81105d2c <bFeebCh3SetBufferSize+0x5c>
81105d20:	10800060 	cmpeqi	r2,r2,1
81105d24:	10000b1e 	bne	r2,zero,81105d54 <bFeebCh3SetBufferSize+0x84>
81105d28:	00001406 	br	81105d7c <bFeebCh3SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105d2c:	e0bffe03 	ldbu	r2,-8(fp)
81105d30:	10bfffc4 	addi	r2,r2,-1
81105d34:	108003cc 	andi	r2,r2,15
81105d38:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105d3c:	e1bffd17 	ldw	r6,-12(fp)
81105d40:	01400544 	movi	r5,21
81105d44:	01204834 	movhi	r4,33056
81105d48:	210b0004 	addi	r4,r4,11264
81105d4c:	1106e140 	call	81106e14 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105d50:	00000c06 	br	81105d84 <bFeebCh3SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105d54:	e0bffe03 	ldbu	r2,-8(fp)
81105d58:	10bfffc4 	addi	r2,r2,-1
81105d5c:	108003cc 	andi	r2,r2,15
81105d60:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105d64:	e1bffd17 	ldw	r6,-12(fp)
81105d68:	01400504 	movi	r5,20
81105d6c:	01204834 	movhi	r4,33056
81105d70:	210b0004 	addi	r4,r4,11264
81105d74:	1106e140 	call	81106e14 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105d78:	00000206 	br	81105d84 <bFeebCh3SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105d7c:	e03ffc15 	stw	zero,-16(fp)
			break;
81105d80:	0001883a 	nop
		}
	} else {
81105d84:	00000106 	br	81105d8c <bFeebCh3SetBufferSize+0xbc>
		bStatus = FALSE;
81105d88:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105d8c:	e0bffc17 	ldw	r2,-16(fp)
}
81105d90:	e037883a 	mov	sp,fp
81105d94:	dfc00117 	ldw	ra,4(sp)
81105d98:	df000017 	ldw	fp,0(sp)
81105d9c:	dec00204 	addi	sp,sp,8
81105da0:	f800283a 	ret

81105da4 <bFeebCh4SetBufferSize>:

bool bFeebCh4SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105da4:	defffa04 	addi	sp,sp,-24
81105da8:	de00012e 	bgeu	sp,et,81105db0 <bFeebCh4SetBufferSize+0xc>
81105dac:	003b68fa 	trap	3
81105db0:	dfc00515 	stw	ra,20(sp)
81105db4:	df000415 	stw	fp,16(sp)
81105db8:	df000404 	addi	fp,sp,16
81105dbc:	2007883a 	mov	r3,r4
81105dc0:	2805883a 	mov	r2,r5
81105dc4:	e0fffe05 	stb	r3,-8(fp)
81105dc8:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105dcc:	00800044 	movi	r2,1
81105dd0:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105dd4:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105dd8:	e0bffe03 	ldbu	r2,-8(fp)
81105ddc:	10001f26 	beq	r2,zero,81105e5c <bFeebCh4SetBufferSize+0xb8>
81105de0:	e0bffe03 	ldbu	r2,-8(fp)
81105de4:	10800468 	cmpgeui	r2,r2,17
81105de8:	10001c1e 	bne	r2,zero,81105e5c <bFeebCh4SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105dec:	e0bfff03 	ldbu	r2,-4(fp)
81105df0:	10000326 	beq	r2,zero,81105e00 <bFeebCh4SetBufferSize+0x5c>
81105df4:	10800060 	cmpeqi	r2,r2,1
81105df8:	10000b1e 	bne	r2,zero,81105e28 <bFeebCh4SetBufferSize+0x84>
81105dfc:	00001406 	br	81105e50 <bFeebCh4SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105e00:	e0bffe03 	ldbu	r2,-8(fp)
81105e04:	10bfffc4 	addi	r2,r2,-1
81105e08:	108003cc 	andi	r2,r2,15
81105e0c:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81105e10:	e1bffd17 	ldw	r6,-12(fp)
81105e14:	01400544 	movi	r5,21
81105e18:	01204834 	movhi	r4,33056
81105e1c:	210a0004 	addi	r4,r4,10240
81105e20:	1106e140 	call	81106e14 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105e24:	00000c06 	br	81105e58 <bFeebCh4SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105e28:	e0bffe03 	ldbu	r2,-8(fp)
81105e2c:	10bfffc4 	addi	r2,r2,-1
81105e30:	108003cc 	andi	r2,r2,15
81105e34:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81105e38:	e1bffd17 	ldw	r6,-12(fp)
81105e3c:	01400504 	movi	r5,20
81105e40:	01204834 	movhi	r4,33056
81105e44:	210a0004 	addi	r4,r4,10240
81105e48:	1106e140 	call	81106e14 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105e4c:	00000206 	br	81105e58 <bFeebCh4SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105e50:	e03ffc15 	stw	zero,-16(fp)
			break;
81105e54:	0001883a 	nop
		}
	} else {
81105e58:	00000106 	br	81105e60 <bFeebCh4SetBufferSize+0xbc>
		bStatus = FALSE;
81105e5c:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105e60:	e0bffc17 	ldw	r2,-16(fp)
}
81105e64:	e037883a 	mov	sp,fp
81105e68:	dfc00117 	ldw	ra,4(sp)
81105e6c:	df000017 	ldw	fp,0(sp)
81105e70:	dec00204 	addi	sp,sp,8
81105e74:	f800283a 	ret

81105e78 <bFeebCh5SetBufferSize>:

bool bFeebCh5SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105e78:	defffa04 	addi	sp,sp,-24
81105e7c:	de00012e 	bgeu	sp,et,81105e84 <bFeebCh5SetBufferSize+0xc>
81105e80:	003b68fa 	trap	3
81105e84:	dfc00515 	stw	ra,20(sp)
81105e88:	df000415 	stw	fp,16(sp)
81105e8c:	df000404 	addi	fp,sp,16
81105e90:	2007883a 	mov	r3,r4
81105e94:	2805883a 	mov	r2,r5
81105e98:	e0fffe05 	stb	r3,-8(fp)
81105e9c:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105ea0:	00800044 	movi	r2,1
81105ea4:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105ea8:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105eac:	e0bffe03 	ldbu	r2,-8(fp)
81105eb0:	10001f26 	beq	r2,zero,81105f30 <bFeebCh5SetBufferSize+0xb8>
81105eb4:	e0bffe03 	ldbu	r2,-8(fp)
81105eb8:	10800468 	cmpgeui	r2,r2,17
81105ebc:	10001c1e 	bne	r2,zero,81105f30 <bFeebCh5SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105ec0:	e0bfff03 	ldbu	r2,-4(fp)
81105ec4:	10000326 	beq	r2,zero,81105ed4 <bFeebCh5SetBufferSize+0x5c>
81105ec8:	10800060 	cmpeqi	r2,r2,1
81105ecc:	10000b1e 	bne	r2,zero,81105efc <bFeebCh5SetBufferSize+0x84>
81105ed0:	00001406 	br	81105f24 <bFeebCh5SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105ed4:	e0bffe03 	ldbu	r2,-8(fp)
81105ed8:	10bfffc4 	addi	r2,r2,-1
81105edc:	108003cc 	andi	r2,r2,15
81105ee0:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105ee4:	e1bffd17 	ldw	r6,-12(fp)
81105ee8:	01400544 	movi	r5,21
81105eec:	01204834 	movhi	r4,33056
81105ef0:	210b0004 	addi	r4,r4,11264
81105ef4:	1106e140 	call	81106e14 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105ef8:	00000c06 	br	81105f2c <bFeebCh5SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105efc:	e0bffe03 	ldbu	r2,-8(fp)
81105f00:	10bfffc4 	addi	r2,r2,-1
81105f04:	108003cc 	andi	r2,r2,15
81105f08:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105f0c:	e1bffd17 	ldw	r6,-12(fp)
81105f10:	01400504 	movi	r5,20
81105f14:	01204834 	movhi	r4,33056
81105f18:	210b0004 	addi	r4,r4,11264
81105f1c:	1106e140 	call	81106e14 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105f20:	00000206 	br	81105f2c <bFeebCh5SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105f24:	e03ffc15 	stw	zero,-16(fp)
			break;
81105f28:	0001883a 	nop
		}
	} else {
81105f2c:	00000106 	br	81105f34 <bFeebCh5SetBufferSize+0xbc>
		bStatus = FALSE;
81105f30:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105f34:	e0bffc17 	ldw	r2,-16(fp)
}
81105f38:	e037883a 	mov	sp,fp
81105f3c:	dfc00117 	ldw	ra,4(sp)
81105f40:	df000017 	ldw	fp,0(sp)
81105f44:	dec00204 	addi	sp,sp,8
81105f48:	f800283a 	ret

81105f4c <bFeebCh6SetBufferSize>:

bool bFeebCh6SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105f4c:	defffa04 	addi	sp,sp,-24
81105f50:	de00012e 	bgeu	sp,et,81105f58 <bFeebCh6SetBufferSize+0xc>
81105f54:	003b68fa 	trap	3
81105f58:	dfc00515 	stw	ra,20(sp)
81105f5c:	df000415 	stw	fp,16(sp)
81105f60:	df000404 	addi	fp,sp,16
81105f64:	2007883a 	mov	r3,r4
81105f68:	2805883a 	mov	r2,r5
81105f6c:	e0fffe05 	stb	r3,-8(fp)
81105f70:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105f74:	00800044 	movi	r2,1
81105f78:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105f7c:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105f80:	e0bffe03 	ldbu	r2,-8(fp)
81105f84:	10001f26 	beq	r2,zero,81106004 <bFeebCh6SetBufferSize+0xb8>
81105f88:	e0bffe03 	ldbu	r2,-8(fp)
81105f8c:	10800468 	cmpgeui	r2,r2,17
81105f90:	10001c1e 	bne	r2,zero,81106004 <bFeebCh6SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105f94:	e0bfff03 	ldbu	r2,-4(fp)
81105f98:	10000326 	beq	r2,zero,81105fa8 <bFeebCh6SetBufferSize+0x5c>
81105f9c:	10800060 	cmpeqi	r2,r2,1
81105fa0:	10000b1e 	bne	r2,zero,81105fd0 <bFeebCh6SetBufferSize+0x84>
81105fa4:	00001406 	br	81105ff8 <bFeebCh6SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105fa8:	e0bffe03 	ldbu	r2,-8(fp)
81105fac:	10bfffc4 	addi	r2,r2,-1
81105fb0:	108003cc 	andi	r2,r2,15
81105fb4:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105fb8:	e1bffd17 	ldw	r6,-12(fp)
81105fbc:	01400544 	movi	r5,21
81105fc0:	01204834 	movhi	r4,33056
81105fc4:	210a0004 	addi	r4,r4,10240
81105fc8:	1106e140 	call	81106e14 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105fcc:	00000c06 	br	81106000 <bFeebCh6SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105fd0:	e0bffe03 	ldbu	r2,-8(fp)
81105fd4:	10bfffc4 	addi	r2,r2,-1
81105fd8:	108003cc 	andi	r2,r2,15
81105fdc:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105fe0:	e1bffd17 	ldw	r6,-12(fp)
81105fe4:	01400504 	movi	r5,20
81105fe8:	01204834 	movhi	r4,33056
81105fec:	210a0004 	addi	r4,r4,10240
81105ff0:	1106e140 	call	81106e14 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105ff4:	00000206 	br	81106000 <bFeebCh6SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105ff8:	e03ffc15 	stw	zero,-16(fp)
			break;
81105ffc:	0001883a 	nop
		}
	} else {
81106000:	00000106 	br	81106008 <bFeebCh6SetBufferSize+0xbc>
		bStatus = FALSE;
81106004:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81106008:	e0bffc17 	ldw	r2,-16(fp)
}
8110600c:	e037883a 	mov	sp,fp
81106010:	dfc00117 	ldw	ra,4(sp)
81106014:	df000017 	ldw	fp,0(sp)
81106018:	dec00204 	addi	sp,sp,8
8110601c:	f800283a 	ret

81106020 <bFeebCh7SetBufferSize>:

bool bFeebCh7SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81106020:	defffa04 	addi	sp,sp,-24
81106024:	de00012e 	bgeu	sp,et,8110602c <bFeebCh7SetBufferSize+0xc>
81106028:	003b68fa 	trap	3
8110602c:	dfc00515 	stw	ra,20(sp)
81106030:	df000415 	stw	fp,16(sp)
81106034:	df000404 	addi	fp,sp,16
81106038:	2007883a 	mov	r3,r4
8110603c:	2805883a 	mov	r2,r5
81106040:	e0fffe05 	stb	r3,-8(fp)
81106044:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81106048:	00800044 	movi	r2,1
8110604c:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81106050:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81106054:	e0bffe03 	ldbu	r2,-8(fp)
81106058:	10001f26 	beq	r2,zero,811060d8 <bFeebCh7SetBufferSize+0xb8>
8110605c:	e0bffe03 	ldbu	r2,-8(fp)
81106060:	10800468 	cmpgeui	r2,r2,17
81106064:	10001c1e 	bne	r2,zero,811060d8 <bFeebCh7SetBufferSize+0xb8>
		switch (ucBufferSide) {
81106068:	e0bfff03 	ldbu	r2,-4(fp)
8110606c:	10000326 	beq	r2,zero,8110607c <bFeebCh7SetBufferSize+0x5c>
81106070:	10800060 	cmpeqi	r2,r2,1
81106074:	10000b1e 	bne	r2,zero,811060a4 <bFeebCh7SetBufferSize+0x84>
81106078:	00001406 	br	811060cc <bFeebCh7SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
8110607c:	e0bffe03 	ldbu	r2,-8(fp)
81106080:	10bfffc4 	addi	r2,r2,-1
81106084:	108003cc 	andi	r2,r2,15
81106088:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
8110608c:	e1bffd17 	ldw	r6,-12(fp)
81106090:	01400544 	movi	r5,21
81106094:	01204834 	movhi	r4,33056
81106098:	210b0004 	addi	r4,r4,11264
8110609c:	1106e140 	call	81106e14 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
811060a0:	00000c06 	br	811060d4 <bFeebCh7SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
811060a4:	e0bffe03 	ldbu	r2,-8(fp)
811060a8:	10bfffc4 	addi	r2,r2,-1
811060ac:	108003cc 	andi	r2,r2,15
811060b0:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
811060b4:	e1bffd17 	ldw	r6,-12(fp)
811060b8:	01400504 	movi	r5,20
811060bc:	01204834 	movhi	r4,33056
811060c0:	210b0004 	addi	r4,r4,11264
811060c4:	1106e140 	call	81106e14 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
811060c8:	00000206 	br	811060d4 <bFeebCh7SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
811060cc:	e03ffc15 	stw	zero,-16(fp)
			break;
811060d0:	0001883a 	nop
		}
	} else {
811060d4:	00000106 	br	811060dc <bFeebCh7SetBufferSize+0xbc>
		bStatus = FALSE;
811060d8:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
811060dc:	e0bffc17 	ldw	r2,-16(fp)
}
811060e0:	e037883a 	mov	sp,fp
811060e4:	dfc00117 	ldw	ra,4(sp)
811060e8:	df000017 	ldw	fp,0(sp)
811060ec:	dec00204 	addi	sp,sp,8
811060f0:	f800283a 	ret

811060f4 <bFeebCh8SetBufferSize>:

bool bFeebCh8SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
811060f4:	defffa04 	addi	sp,sp,-24
811060f8:	de00012e 	bgeu	sp,et,81106100 <bFeebCh8SetBufferSize+0xc>
811060fc:	003b68fa 	trap	3
81106100:	dfc00515 	stw	ra,20(sp)
81106104:	df000415 	stw	fp,16(sp)
81106108:	df000404 	addi	fp,sp,16
8110610c:	2007883a 	mov	r3,r4
81106110:	2805883a 	mov	r2,r5
81106114:	e0fffe05 	stb	r3,-8(fp)
81106118:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
8110611c:	00800044 	movi	r2,1
81106120:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81106124:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81106128:	e0bffe03 	ldbu	r2,-8(fp)
8110612c:	10001f26 	beq	r2,zero,811061ac <bFeebCh8SetBufferSize+0xb8>
81106130:	e0bffe03 	ldbu	r2,-8(fp)
81106134:	10800468 	cmpgeui	r2,r2,17
81106138:	10001c1e 	bne	r2,zero,811061ac <bFeebCh8SetBufferSize+0xb8>
		switch (ucBufferSide) {
8110613c:	e0bfff03 	ldbu	r2,-4(fp)
81106140:	10000326 	beq	r2,zero,81106150 <bFeebCh8SetBufferSize+0x5c>
81106144:	10800060 	cmpeqi	r2,r2,1
81106148:	10000b1e 	bne	r2,zero,81106178 <bFeebCh8SetBufferSize+0x84>
8110614c:	00001406 	br	811061a0 <bFeebCh8SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81106150:	e0bffe03 	ldbu	r2,-8(fp)
81106154:	10bfffc4 	addi	r2,r2,-1
81106158:	108003cc 	andi	r2,r2,15
8110615c:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81106160:	e1bffd17 	ldw	r6,-12(fp)
81106164:	01400544 	movi	r5,21
81106168:	01204834 	movhi	r4,33056
8110616c:	210a0004 	addi	r4,r4,10240
81106170:	1106e140 	call	81106e14 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81106174:	00000c06 	br	811061a8 <bFeebCh8SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81106178:	e0bffe03 	ldbu	r2,-8(fp)
8110617c:	10bfffc4 	addi	r2,r2,-1
81106180:	108003cc 	andi	r2,r2,15
81106184:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81106188:	e1bffd17 	ldw	r6,-12(fp)
8110618c:	01400504 	movi	r5,20
81106190:	01204834 	movhi	r4,33056
81106194:	210a0004 	addi	r4,r4,10240
81106198:	1106e140 	call	81106e14 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
8110619c:	00000206 	br	811061a8 <bFeebCh8SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
811061a0:	e03ffc15 	stw	zero,-16(fp)
			break;
811061a4:	0001883a 	nop
		}
	} else {
811061a8:	00000106 	br	811061b0 <bFeebCh8SetBufferSize+0xbc>
		bStatus = FALSE;
811061ac:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
811061b0:	e0bffc17 	ldw	r2,-16(fp)
}
811061b4:	e037883a 	mov	sp,fp
811061b8:	dfc00117 	ldw	ra,4(sp)
811061bc:	df000017 	ldw	fp,0(sp)
811061c0:	dec00204 	addi	sp,sp,8
811061c4:	f800283a 	ret

811061c8 <vFeebInitIrq>:

void vFeebInitIrq(alt_u8 ucCommCh) {
811061c8:	defffc04 	addi	sp,sp,-16
811061cc:	de00012e 	bgeu	sp,et,811061d4 <vFeebInitIrq+0xc>
811061d0:	003b68fa 	trap	3
811061d4:	dfc00315 	stw	ra,12(sp)
811061d8:	df000215 	stw	fp,8(sp)
811061dc:	df000204 	addi	fp,sp,8
811061e0:	2005883a 	mov	r2,r4
811061e4:	e0bfff05 	stb	r2,-4(fp)
	void* pvHoldContext;
	switch (ucCommCh) {
811061e8:	e0bfff03 	ldbu	r2,-4(fp)
811061ec:	10c00228 	cmpgeui	r3,r2,8
811061f0:	18004e1e 	bne	r3,zero,8110632c <vFeebInitIrq+0x164>
811061f4:	100690ba 	slli	r3,r2,2
811061f8:	00a04434 	movhi	r2,33040
811061fc:	10988304 	addi	r2,r2,25100
81106200:	1885883a 	add	r2,r3,r2
81106204:	10800017 	ldw	r2,0(r2)
81106208:	1000683a 	jmp	r2
8110620c:	8110622c 	andhi	r4,r16,16776
81106210:	8110624c 	andi	r4,r16,16777
81106214:	8110626c 	andhi	r4,r16,16777
81106218:	8110628c 	andi	r4,r16,16778
8110621c:	811062ac 	andhi	r4,r16,16778
81106220:	811062cc 	andi	r4,r16,16779
81106224:	811062ec 	andhi	r4,r16,16779
81106228:	8110630c 	andi	r4,r16,16780
	case eCommSpwCh1:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh1HoldContext;
8110622c:	d0a04004 	addi	r2,gp,-32512
81106230:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_1_BUFFERS_IRQ, pvHoldContext,
81106234:	01a04434 	movhi	r6,33040
81106238:	3194ce04 	addi	r6,r6,21304
8110623c:	e17ffe17 	ldw	r5,-8(fp)
81106240:	01000584 	movi	r4,22
81106244:	11366440 	call	81136644 <alt_irq_register>
				vFeebCh1HandleIrq);
		break;
81106248:	00003806 	br	8110632c <vFeebInitIrq+0x164>
	case eCommSpwCh2:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh2HoldContext;
8110624c:	d0a04104 	addi	r2,gp,-32508
81106250:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_2_BUFFERS_IRQ, pvHoldContext,
81106254:	01a04434 	movhi	r6,33040
81106258:	3194de04 	addi	r6,r6,21368
8110625c:	e17ffe17 	ldw	r5,-8(fp)
81106260:	01000504 	movi	r4,20
81106264:	11366440 	call	81136644 <alt_irq_register>
				vFeebCh2HandleIrq);
		break;
81106268:	00003006 	br	8110632c <vFeebInitIrq+0x164>
	case eCommSpwCh3:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh3HoldContext;
8110626c:	d0a04204 	addi	r2,gp,-32504
81106270:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_3_BUFFERS_IRQ, pvHoldContext,
81106274:	01a04434 	movhi	r6,33040
81106278:	3194ee04 	addi	r6,r6,21432
8110627c:	e17ffe17 	ldw	r5,-8(fp)
81106280:	01000484 	movi	r4,18
81106284:	11366440 	call	81136644 <alt_irq_register>
				vFeebCh3HandleIrq);
		break;
81106288:	00002806 	br	8110632c <vFeebInitIrq+0x164>
	case eCommSpwCh4:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh4HoldContext;
8110628c:	d0a04304 	addi	r2,gp,-32500
81106290:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_4_BUFFERS_IRQ, pvHoldContext,
81106294:	01a04434 	movhi	r6,33040
81106298:	31950f04 	addi	r6,r6,21564
8110629c:	e17ffe17 	ldw	r5,-8(fp)
811062a0:	01000404 	movi	r4,16
811062a4:	11366440 	call	81136644 <alt_irq_register>
				vFeebCh4HandleIrq);
		break;
811062a8:	00002006 	br	8110632c <vFeebInitIrq+0x164>
	case eCommSpwCh5:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh5HoldContext;
811062ac:	d0a04404 	addi	r2,gp,-32496
811062b0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_5_BUFFERS_IRQ, pvHoldContext,
811062b4:	01a04434 	movhi	r6,33040
811062b8:	31953004 	addi	r6,r6,21696
811062bc:	e17ffe17 	ldw	r5,-8(fp)
811062c0:	01000204 	movi	r4,8
811062c4:	11366440 	call	81136644 <alt_irq_register>
				vFeebCh5HandleIrq);
		break;
811062c8:	00001806 	br	8110632c <vFeebInitIrq+0x164>
	case eCommSpwCh6:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh6HoldContext;
811062cc:	d0a04504 	addi	r2,gp,-32492
811062d0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_6_BUFFERS_IRQ, pvHoldContext,
811062d4:	01a04434 	movhi	r6,33040
811062d8:	31955104 	addi	r6,r6,21828
811062dc:	e17ffe17 	ldw	r5,-8(fp)
811062e0:	01000184 	movi	r4,6
811062e4:	11366440 	call	81136644 <alt_irq_register>
				vFeebCh6HandleIrq);
		break;
811062e8:	00001006 	br	8110632c <vFeebInitIrq+0x164>
	case eCommSpwCh7:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh7HoldContext;
811062ec:	d0a04604 	addi	r2,gp,-32488
811062f0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_7_BUFFERS_IRQ, pvHoldContext,
811062f4:	01a04434 	movhi	r6,33040
811062f8:	31957204 	addi	r6,r6,21960
811062fc:	e17ffe17 	ldw	r5,-8(fp)
81106300:	01000144 	movi	r4,5
81106304:	11366440 	call	81136644 <alt_irq_register>
				vFeebCh7HandleIrq);
		break;
81106308:	00000806 	br	8110632c <vFeebInitIrq+0x164>
	case eCommSpwCh8:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh8HoldContext;
8110630c:	d0a04704 	addi	r2,gp,-32484
81106310:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_8_BUFFERS_IRQ, pvHoldContext,
81106314:	01a04434 	movhi	r6,33040
81106318:	31958204 	addi	r6,r6,22024
8110631c:	e17ffe17 	ldw	r5,-8(fp)
81106320:	01000084 	movi	r4,2
81106324:	11366440 	call	81136644 <alt_irq_register>
				vFeebCh8HandleIrq);
		break;
81106328:	0001883a 	nop
	}
}
8110632c:	0001883a 	nop
81106330:	e037883a 	mov	sp,fp
81106334:	dfc00117 	ldw	ra,4(sp)
81106338:	df000017 	ldw	fp,0(sp)
8110633c:	dec00204 	addi	sp,sp,8
81106340:	f800283a 	ret

81106344 <bFeebSetIrqControl>:

bool bFeebSetIrqControl(TFeebChannel *pxFeebCh) {
81106344:	defffb04 	addi	sp,sp,-20
81106348:	de00012e 	bgeu	sp,et,81106350 <bFeebSetIrqControl+0xc>
8110634c:	003b68fa 	trap	3
81106350:	dfc00415 	stw	ra,16(sp)
81106354:	df000315 	stw	fp,12(sp)
81106358:	df000304 	addi	fp,sp,12
8110635c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106360:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106364:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106368:	e0bfff17 	ldw	r2,-4(fp)
8110636c:	10002426 	beq	r2,zero,81106400 <bFeebSetIrqControl+0xbc>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106370:	e0bfff17 	ldw	r2,-4(fp)
81106374:	10800017 	ldw	r2,0(r2)
81106378:	01400444 	movi	r5,17
8110637c:	1009883a 	mov	r4,r2
81106380:	1106e680 	call	81106e68 <uliFeebReadReg>
81106384:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (pxFeebCh->xIrqControl.bLeftBufferEmptyEn) {
81106388:	e0bfff17 	ldw	r2,-4(fp)
8110638c:	10800217 	ldw	r2,8(r2)
81106390:	10000426 	beq	r2,zero,811063a4 <bFeebSetIrqControl+0x60>
			uliReg |= COMM_IRQ_LEFT_BUFF_EPY_EN_MSK;
81106394:	e0bffe17 	ldw	r2,-8(fp)
81106398:	10808014 	ori	r2,r2,512
8110639c:	e0bffe15 	stw	r2,-8(fp)
811063a0:	00000406 	br	811063b4 <bFeebSetIrqControl+0x70>
		} else {
			uliReg &= (~COMM_IRQ_LEFT_BUFF_EPY_EN_MSK);
811063a4:	e0fffe17 	ldw	r3,-8(fp)
811063a8:	00bf7fc4 	movi	r2,-513
811063ac:	1884703a 	and	r2,r3,r2
811063b0:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxFeebCh->xIrqControl.bRightBufferEmptyEn) {
811063b4:	e0bfff17 	ldw	r2,-4(fp)
811063b8:	10800317 	ldw	r2,12(r2)
811063bc:	10000426 	beq	r2,zero,811063d0 <bFeebSetIrqControl+0x8c>
			uliReg |= COMM_IRQ_RIGH_BUFF_EPY_EN_MSK;
811063c0:	e0bffe17 	ldw	r2,-8(fp)
811063c4:	10804014 	ori	r2,r2,256
811063c8:	e0bffe15 	stw	r2,-8(fp)
811063cc:	00000406 	br	811063e0 <bFeebSetIrqControl+0x9c>
		} else {
			uliReg &= (~COMM_IRQ_RIGH_BUFF_EPY_EN_MSK);
811063d0:	e0fffe17 	ldw	r3,-8(fp)
811063d4:	00bfbfc4 	movi	r2,-257
811063d8:	1884703a 	and	r2,r3,r2
811063dc:	e0bffe15 	stw	r2,-8(fp)
		}

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_IRQ_CONTROL_REG_OFST,
811063e0:	e0bfff17 	ldw	r2,-4(fp)
811063e4:	10800017 	ldw	r2,0(r2)
811063e8:	e1bffe17 	ldw	r6,-8(fp)
811063ec:	01400444 	movi	r5,17
811063f0:	1009883a 	mov	r4,r2
811063f4:	1106e140 	call	81106e14 <vFeebWriteReg>
				uliReg);
		bStatus = TRUE;
811063f8:	00800044 	movi	r2,1
811063fc:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106400:	e0bffd17 	ldw	r2,-12(fp)
}
81106404:	e037883a 	mov	sp,fp
81106408:	dfc00117 	ldw	ra,4(sp)
8110640c:	df000017 	ldw	fp,0(sp)
81106410:	dec00204 	addi	sp,sp,8
81106414:	f800283a 	ret

81106418 <bFeebGetIrqControl>:

bool bFeebGetIrqControl(TFeebChannel *pxFeebCh) {
81106418:	defffb04 	addi	sp,sp,-20
8110641c:	de00012e 	bgeu	sp,et,81106424 <bFeebGetIrqControl+0xc>
81106420:	003b68fa 	trap	3
81106424:	dfc00415 	stw	ra,16(sp)
81106428:	df000315 	stw	fp,12(sp)
8110642c:	df000304 	addi	fp,sp,12
81106430:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106434:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106438:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
8110643c:	e0bfff17 	ldw	r2,-4(fp)
81106440:	10001a26 	beq	r2,zero,811064ac <bFeebGetIrqControl+0x94>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106444:	e0bfff17 	ldw	r2,-4(fp)
81106448:	10800017 	ldw	r2,0(r2)
8110644c:	01400444 	movi	r5,17
81106450:	1009883a 	mov	r4,r2
81106454:	1106e680 	call	81106e68 <uliFeebReadReg>
81106458:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (uliReg & COMM_IRQ_LEFT_BUFF_EPY_EN_MSK) {
8110645c:	e0bffe17 	ldw	r2,-8(fp)
81106460:	1080800c 	andi	r2,r2,512
81106464:	10000426 	beq	r2,zero,81106478 <bFeebGetIrqControl+0x60>
			pxFeebCh->xIrqControl.bLeftBufferEmptyEn = TRUE;
81106468:	e0bfff17 	ldw	r2,-4(fp)
8110646c:	00c00044 	movi	r3,1
81106470:	10c00215 	stw	r3,8(r2)
81106474:	00000206 	br	81106480 <bFeebGetIrqControl+0x68>
		} else {
			pxFeebCh->xIrqControl.bLeftBufferEmptyEn = FALSE;
81106478:	e0bfff17 	ldw	r2,-4(fp)
8110647c:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_IRQ_RIGH_BUFF_EPY_EN_MSK) {
81106480:	e0bffe17 	ldw	r2,-8(fp)
81106484:	1080400c 	andi	r2,r2,256
81106488:	10000426 	beq	r2,zero,8110649c <bFeebGetIrqControl+0x84>
			pxFeebCh->xIrqControl.bRightBufferEmptyEn = TRUE;
8110648c:	e0bfff17 	ldw	r2,-4(fp)
81106490:	00c00044 	movi	r3,1
81106494:	10c00315 	stw	r3,12(r2)
81106498:	00000206 	br	811064a4 <bFeebGetIrqControl+0x8c>
		} else {
			pxFeebCh->xIrqControl.bRightBufferEmptyEn = FALSE;
8110649c:	e0bfff17 	ldw	r2,-4(fp)
811064a0:	10000315 	stw	zero,12(r2)
		}

		bStatus = TRUE;
811064a4:	00800044 	movi	r2,1
811064a8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811064ac:	e0bffd17 	ldw	r2,-12(fp)
}
811064b0:	e037883a 	mov	sp,fp
811064b4:	dfc00117 	ldw	ra,4(sp)
811064b8:	df000017 	ldw	fp,0(sp)
811064bc:	dec00204 	addi	sp,sp,8
811064c0:	f800283a 	ret

811064c4 <bFeebGetIrqFlags>:

bool bFeebGetIrqFlags(TFeebChannel *pxFeebCh) {
811064c4:	defffb04 	addi	sp,sp,-20
811064c8:	de00012e 	bgeu	sp,et,811064d0 <bFeebGetIrqFlags+0xc>
811064cc:	003b68fa 	trap	3
811064d0:	dfc00415 	stw	ra,16(sp)
811064d4:	df000315 	stw	fp,12(sp)
811064d8:	df000304 	addi	fp,sp,12
811064dc:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811064e0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811064e4:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811064e8:	e0bfff17 	ldw	r2,-4(fp)
811064ec:	10001126 	beq	r2,zero,81106534 <bFeebGetIrqFlags+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811064f0:	e0bfff17 	ldw	r2,-4(fp)
811064f4:	10800017 	ldw	r2,0(r2)
811064f8:	01400484 	movi	r5,18
811064fc:	1009883a 	mov	r4,r2
81106500:	1106e680 	call	81106e68 <uliFeebReadReg>
81106504:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_FLAGS_REG_OFST);

		if (uliReg & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81106508:	e0bffe17 	ldw	r2,-8(fp)
8110650c:	1080400c 	andi	r2,r2,256
81106510:	10000426 	beq	r2,zero,81106524 <bFeebGetIrqFlags+0x60>
			pxFeebCh->xIrqFlag.bBufferEmptyFlag = TRUE;
81106514:	e0bfff17 	ldw	r2,-4(fp)
81106518:	00c00044 	movi	r3,1
8110651c:	10c00415 	stw	r3,16(r2)
81106520:	00000206 	br	8110652c <bFeebGetIrqFlags+0x68>
		} else {
			pxFeebCh->xIrqFlag.bBufferEmptyFlag = FALSE;
81106524:	e0bfff17 	ldw	r2,-4(fp)
81106528:	10000415 	stw	zero,16(r2)
		}

		bStatus = TRUE;
8110652c:	00800044 	movi	r2,1
81106530:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106534:	e0bffd17 	ldw	r2,-12(fp)
}
81106538:	e037883a 	mov	sp,fp
8110653c:	dfc00117 	ldw	ra,4(sp)
81106540:	df000017 	ldw	fp,0(sp)
81106544:	dec00204 	addi	sp,sp,8
81106548:	f800283a 	ret

8110654c <bFeebGetBuffersStatus>:

bool bFeebGetBuffersStatus(TFeebChannel *pxFeebCh) {
8110654c:	defffb04 	addi	sp,sp,-20
81106550:	de00012e 	bgeu	sp,et,81106558 <bFeebGetBuffersStatus+0xc>
81106554:	003b68fa 	trap	3
81106558:	dfc00415 	stw	ra,16(sp)
8110655c:	df000315 	stw	fp,12(sp)
81106560:	df000304 	addi	fp,sp,12
81106564:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106568:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110656c:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106570:	e0bfff17 	ldw	r2,-4(fp)
81106574:	10003226 	beq	r2,zero,81106640 <bFeebGetBuffersStatus+0xf4>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106578:	e0bfff17 	ldw	r2,-4(fp)
8110657c:	10800017 	ldw	r2,0(r2)
81106580:	014000c4 	movi	r5,3
81106584:	1009883a 	mov	r4,r2
81106588:	1106e680 	call	81106e68 <uliFeebReadReg>
8110658c:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
81106590:	e0bffe17 	ldw	r2,-8(fp)
81106594:	1080008c 	andi	r2,r2,2
81106598:	10000426 	beq	r2,zero,811065ac <bFeebGetBuffersStatus+0x60>
			pxFeebCh->xBufferStatus.bLeftBufferEmpty = TRUE;
8110659c:	e0bfff17 	ldw	r2,-4(fp)
811065a0:	00c00044 	movi	r3,1
811065a4:	10c00515 	stw	r3,20(r2)
811065a8:	00000206 	br	811065b4 <bFeebGetBuffersStatus+0x68>
		} else {
			pxFeebCh->xBufferStatus.bLeftBufferEmpty = FALSE;
811065ac:	e0bfff17 	ldw	r2,-4(fp)
811065b0:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
811065b4:	e0bffe17 	ldw	r2,-8(fp)
811065b8:	1080004c 	andi	r2,r2,1
811065bc:	10000426 	beq	r2,zero,811065d0 <bFeebGetBuffersStatus+0x84>
			pxFeebCh->xBufferStatus.bRightBufferEmpty = TRUE;
811065c0:	e0bfff17 	ldw	r2,-4(fp)
811065c4:	00c00044 	movi	r3,1
811065c8:	10c00615 	stw	r3,24(r2)
811065cc:	00000206 	br	811065d8 <bFeebGetBuffersStatus+0x8c>
		} else {
			pxFeebCh->xBufferStatus.bRightBufferEmpty = FALSE;
811065d0:	e0bfff17 	ldw	r2,-4(fp)
811065d4:	10000615 	stw	zero,24(r2)
		}

		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811065d8:	e0bfff17 	ldw	r2,-4(fp)
811065dc:	10800017 	ldw	r2,0(r2)
811065e0:	01400504 	movi	r5,20
811065e4:	1009883a 	mov	r4,r2
811065e8:	1106e680 	call	81106e68 <uliFeebReadReg>
811065ec:	e0bffe15 	stw	r2,-8(fp)
		COMM_RIGT_FEEBUFF_SIZE_REG_OFST);
		pxFeebCh->xBufferStatus.ucRightBufferSize = (alt_u8) (uliReg
811065f0:	e0bffe17 	ldw	r2,-8(fp)
811065f4:	108003cc 	andi	r2,r2,15
811065f8:	10800044 	addi	r2,r2,1
811065fc:	1007883a 	mov	r3,r2
81106600:	e0bfff17 	ldw	r2,-4(fp)
81106604:	10c00745 	stb	r3,29(r2)
				& COMM_RIGT_FEEBUFF_SIZE_MSK) + 1;

		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106608:	e0bfff17 	ldw	r2,-4(fp)
8110660c:	10800017 	ldw	r2,0(r2)
81106610:	01400544 	movi	r5,21
81106614:	1009883a 	mov	r4,r2
81106618:	1106e680 	call	81106e68 <uliFeebReadReg>
8110661c:	e0bffe15 	stw	r2,-8(fp)
		COMM_LEFT_FEEBUFF_SIZE_REG_OFST);
		pxFeebCh->xBufferStatus.ucRightBufferSize = (alt_u8) (uliReg
81106620:	e0bffe17 	ldw	r2,-8(fp)
81106624:	108003cc 	andi	r2,r2,15
81106628:	10800044 	addi	r2,r2,1
8110662c:	1007883a 	mov	r3,r2
81106630:	e0bfff17 	ldw	r2,-4(fp)
81106634:	10c00745 	stb	r3,29(r2)
				& COMM_LEFT_FEEBUFF_SIZE_MSK) + 1;

		bStatus = TRUE;
81106638:	00800044 	movi	r2,1
8110663c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106640:	e0bffd17 	ldw	r2,-12(fp)
}
81106644:	e037883a 	mov	sp,fp
81106648:	dfc00117 	ldw	ra,4(sp)
8110664c:	df000017 	ldw	fp,0(sp)
81106650:	dec00204 	addi	sp,sp,8
81106654:	f800283a 	ret

81106658 <bFeebGetLeftBufferEmpty>:

bool bFeebGetLeftBufferEmpty(TFeebChannel *pxFeebCh){
81106658:	defffb04 	addi	sp,sp,-20
8110665c:	de00012e 	bgeu	sp,et,81106664 <bFeebGetLeftBufferEmpty+0xc>
81106660:	003b68fa 	trap	3
81106664:	dfc00415 	stw	ra,16(sp)
81106668:	df000315 	stw	fp,12(sp)
8110666c:	df000304 	addi	fp,sp,12
81106670:	e13fff15 	stw	r4,-4(fp)
	bool bFlag = FALSE;
81106674:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106678:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
8110667c:	e0bfff17 	ldw	r2,-4(fp)
81106680:	10000d26 	beq	r2,zero,811066b8 <bFeebGetLeftBufferEmpty+0x60>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106684:	e0bfff17 	ldw	r2,-4(fp)
81106688:	10800017 	ldw	r2,0(r2)
8110668c:	014000c4 	movi	r5,3
81106690:	1009883a 	mov	r4,r2
81106694:	1106e680 	call	81106e68 <uliFeebReadReg>
81106698:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
8110669c:	e0bffe17 	ldw	r2,-8(fp)
811066a0:	1080008c 	andi	r2,r2,2
811066a4:	10000326 	beq	r2,zero,811066b4 <bFeebGetLeftBufferEmpty+0x5c>
			bFlag = TRUE;
811066a8:	00800044 	movi	r2,1
811066ac:	e0bffd15 	stw	r2,-12(fp)
811066b0:	00000106 	br	811066b8 <bFeebGetLeftBufferEmpty+0x60>
		} else {
			bFlag = FALSE;
811066b4:	e03ffd15 	stw	zero,-12(fp)
		}

	}

	return bFlag;
811066b8:	e0bffd17 	ldw	r2,-12(fp)
}
811066bc:	e037883a 	mov	sp,fp
811066c0:	dfc00117 	ldw	ra,4(sp)
811066c4:	df000017 	ldw	fp,0(sp)
811066c8:	dec00204 	addi	sp,sp,8
811066cc:	f800283a 	ret

811066d0 <bFeebGetRightBufferEmpty>:

bool bFeebGetRightBufferEmpty(TFeebChannel *pxFeebCh){
811066d0:	defffb04 	addi	sp,sp,-20
811066d4:	de00012e 	bgeu	sp,et,811066dc <bFeebGetRightBufferEmpty+0xc>
811066d8:	003b68fa 	trap	3
811066dc:	dfc00415 	stw	ra,16(sp)
811066e0:	df000315 	stw	fp,12(sp)
811066e4:	df000304 	addi	fp,sp,12
811066e8:	e13fff15 	stw	r4,-4(fp)
	bool bFlag = FALSE;
811066ec:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811066f0:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811066f4:	e0bfff17 	ldw	r2,-4(fp)
811066f8:	10000d26 	beq	r2,zero,81106730 <bFeebGetRightBufferEmpty+0x60>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811066fc:	e0bfff17 	ldw	r2,-4(fp)
81106700:	10800017 	ldw	r2,0(r2)
81106704:	014000c4 	movi	r5,3
81106708:	1009883a 	mov	r4,r2
8110670c:	1106e680 	call	81106e68 <uliFeebReadReg>
81106710:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
81106714:	e0bffe17 	ldw	r2,-8(fp)
81106718:	1080004c 	andi	r2,r2,1
8110671c:	10000326 	beq	r2,zero,8110672c <bFeebGetRightBufferEmpty+0x5c>
			bFlag = TRUE;
81106720:	00800044 	movi	r2,1
81106724:	e0bffd15 	stw	r2,-12(fp)
81106728:	00000106 	br	81106730 <bFeebGetRightBufferEmpty+0x60>
		} else {
			bFlag = FALSE;
8110672c:	e03ffd15 	stw	zero,-12(fp)
		}

	}

	return bFlag;
81106730:	e0bffd17 	ldw	r2,-12(fp)
}
81106734:	e037883a 	mov	sp,fp
81106738:	dfc00117 	ldw	ra,4(sp)
8110673c:	df000017 	ldw	fp,0(sp)
81106740:	dec00204 	addi	sp,sp,8
81106744:	f800283a 	ret

81106748 <bFeebGetCh1LeftBufferEmpty>:

bool bFeebGetCh1LeftBufferEmpty(void){
81106748:	defffc04 	addi	sp,sp,-16
8110674c:	de00012e 	bgeu	sp,et,81106754 <bFeebGetCh1LeftBufferEmpty+0xc>
81106750:	003b68fa 	trap	3
81106754:	dfc00315 	stw	ra,12(sp)
81106758:	df000215 	stw	fp,8(sp)
8110675c:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
81106760:	e03ffe15 	stw	zero,-8(fp)
	alt_u32 uliReg = 0;
81106764:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_1_BASE_ADDR,
81106768:	014000c4 	movi	r5,3
8110676c:	01204834 	movhi	r4,33056
81106770:	210b0004 	addi	r4,r4,11264
81106774:	1106e680 	call	81106e68 <uliFeebReadReg>
81106778:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
8110677c:	e0bfff17 	ldw	r2,-4(fp)
81106780:	1080008c 	andi	r2,r2,2
81106784:	10000326 	beq	r2,zero,81106794 <bFeebGetCh1LeftBufferEmpty+0x4c>
			bFlag = TRUE;
81106788:	00800044 	movi	r2,1
8110678c:	e0bffe15 	stw	r2,-8(fp)
81106790:	00000106 	br	81106798 <bFeebGetCh1LeftBufferEmpty+0x50>
		} else {
			bFlag = FALSE;
81106794:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
81106798:	e0bffe17 	ldw	r2,-8(fp)
}
8110679c:	e037883a 	mov	sp,fp
811067a0:	dfc00117 	ldw	ra,4(sp)
811067a4:	df000017 	ldw	fp,0(sp)
811067a8:	dec00204 	addi	sp,sp,8
811067ac:	f800283a 	ret

811067b0 <bFeebGetCh1RightBufferEmpty>:

bool bFeebGetCh1RightBufferEmpty(void){
811067b0:	defffc04 	addi	sp,sp,-16
811067b4:	de00012e 	bgeu	sp,et,811067bc <bFeebGetCh1RightBufferEmpty+0xc>
811067b8:	003b68fa 	trap	3
811067bc:	dfc00315 	stw	ra,12(sp)
811067c0:	df000215 	stw	fp,8(sp)
811067c4:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
811067c8:	e03ffe15 	stw	zero,-8(fp)
	alt_u32 uliReg = 0;
811067cc:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_1_BASE_ADDR,
811067d0:	014000c4 	movi	r5,3
811067d4:	01204834 	movhi	r4,33056
811067d8:	210b0004 	addi	r4,r4,11264
811067dc:	1106e680 	call	81106e68 <uliFeebReadReg>
811067e0:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
811067e4:	e0bfff17 	ldw	r2,-4(fp)
811067e8:	1080004c 	andi	r2,r2,1
811067ec:	10000326 	beq	r2,zero,811067fc <bFeebGetCh1RightBufferEmpty+0x4c>
			bFlag = TRUE;
811067f0:	00800044 	movi	r2,1
811067f4:	e0bffe15 	stw	r2,-8(fp)
811067f8:	00000106 	br	81106800 <bFeebGetCh1RightBufferEmpty+0x50>
		} else {
			bFlag = FALSE;
811067fc:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
81106800:	e0bffe17 	ldw	r2,-8(fp)
}
81106804:	e037883a 	mov	sp,fp
81106808:	dfc00117 	ldw	ra,4(sp)
8110680c:	df000017 	ldw	fp,0(sp)
81106810:	dec00204 	addi	sp,sp,8
81106814:	f800283a 	ret

81106818 <bFeebGetCh2LeftBufferEmpty>:

bool bFeebGetCh2LeftBufferEmpty(void){
81106818:	defffc04 	addi	sp,sp,-16
8110681c:	de00012e 	bgeu	sp,et,81106824 <bFeebGetCh2LeftBufferEmpty+0xc>
81106820:	003b68fa 	trap	3
81106824:	dfc00315 	stw	ra,12(sp)
81106828:	df000215 	stw	fp,8(sp)
8110682c:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
81106830:	e03ffe15 	stw	zero,-8(fp)
	alt_u32 uliReg = 0;
81106834:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_2_BASE_ADDR,
81106838:	014000c4 	movi	r5,3
8110683c:	01204834 	movhi	r4,33056
81106840:	210a0004 	addi	r4,r4,10240
81106844:	1106e680 	call	81106e68 <uliFeebReadReg>
81106848:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
8110684c:	e0bfff17 	ldw	r2,-4(fp)
81106850:	1080008c 	andi	r2,r2,2
81106854:	10000326 	beq	r2,zero,81106864 <bFeebGetCh2LeftBufferEmpty+0x4c>
			bFlag = TRUE;
81106858:	00800044 	movi	r2,1
8110685c:	e0bffe15 	stw	r2,-8(fp)
81106860:	00000106 	br	81106868 <bFeebGetCh2LeftBufferEmpty+0x50>
		} else {
			bFlag = FALSE;
81106864:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
81106868:	e0bffe17 	ldw	r2,-8(fp)
}
8110686c:	e037883a 	mov	sp,fp
81106870:	dfc00117 	ldw	ra,4(sp)
81106874:	df000017 	ldw	fp,0(sp)
81106878:	dec00204 	addi	sp,sp,8
8110687c:	f800283a 	ret

81106880 <bFeebGetCh2RightBufferEmpty>:

bool bFeebGetCh2RightBufferEmpty(void){
81106880:	defffc04 	addi	sp,sp,-16
81106884:	de00012e 	bgeu	sp,et,8110688c <bFeebGetCh2RightBufferEmpty+0xc>
81106888:	003b68fa 	trap	3
8110688c:	dfc00315 	stw	ra,12(sp)
81106890:	df000215 	stw	fp,8(sp)
81106894:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
81106898:	e03ffe15 	stw	zero,-8(fp)
	alt_u32 uliReg = 0;
8110689c:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_2_BASE_ADDR,
811068a0:	014000c4 	movi	r5,3
811068a4:	01204834 	movhi	r4,33056
811068a8:	210a0004 	addi	r4,r4,10240
811068ac:	1106e680 	call	81106e68 <uliFeebReadReg>
811068b0:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
811068b4:	e0bfff17 	ldw	r2,-4(fp)
811068b8:	1080004c 	andi	r2,r2,1
811068bc:	10000326 	beq	r2,zero,811068cc <bFeebGetCh2RightBufferEmpty+0x4c>
			bFlag = TRUE;
811068c0:	00800044 	movi	r2,1
811068c4:	e0bffe15 	stw	r2,-8(fp)
811068c8:	00000106 	br	811068d0 <bFeebGetCh2RightBufferEmpty+0x50>
		} else {
			bFlag = FALSE;
811068cc:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
811068d0:	e0bffe17 	ldw	r2,-8(fp)
}
811068d4:	e037883a 	mov	sp,fp
811068d8:	dfc00117 	ldw	ra,4(sp)
811068dc:	df000017 	ldw	fp,0(sp)
811068e0:	dec00204 	addi	sp,sp,8
811068e4:	f800283a 	ret

811068e8 <bFeebSetBufferSize>:

bool bFeebSetBufferSize(TFeebChannel *pxFeebCh, alt_u8 ucBufferSizeInBlocks,
		alt_u8 ucBufferSide) {
811068e8:	defff904 	addi	sp,sp,-28
811068ec:	de00012e 	bgeu	sp,et,811068f4 <bFeebSetBufferSize+0xc>
811068f0:	003b68fa 	trap	3
811068f4:	dfc00615 	stw	ra,24(sp)
811068f8:	df000515 	stw	fp,20(sp)
811068fc:	df000504 	addi	fp,sp,20
81106900:	e13ffd15 	stw	r4,-12(fp)
81106904:	2807883a 	mov	r3,r5
81106908:	3005883a 	mov	r2,r6
8110690c:	e0fffe05 	stb	r3,-8(fp)
81106910:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81106914:	00800044 	movi	r2,1
81106918:	e0bffb15 	stw	r2,-20(fp)
	alt_u32 uliReg = 0;
8110691c:	e03ffc15 	stw	zero,-16(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81106920:	e0bffe03 	ldbu	r2,-8(fp)
81106924:	10002126 	beq	r2,zero,811069ac <bFeebSetBufferSize+0xc4>
81106928:	e0bffe03 	ldbu	r2,-8(fp)
8110692c:	10800468 	cmpgeui	r2,r2,17
81106930:	10001e1e 	bne	r2,zero,811069ac <bFeebSetBufferSize+0xc4>
		switch (ucBufferSide) {
81106934:	e0bfff03 	ldbu	r2,-4(fp)
81106938:	10000326 	beq	r2,zero,81106948 <bFeebSetBufferSize+0x60>
8110693c:	10800060 	cmpeqi	r2,r2,1
81106940:	10000c1e 	bne	r2,zero,81106974 <bFeebSetBufferSize+0x8c>
81106944:	00001606 	br	811069a0 <bFeebSetBufferSize+0xb8>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81106948:	e0bffe03 	ldbu	r2,-8(fp)
8110694c:	10bfffc4 	addi	r2,r2,-1
81106950:	108003cc 	andi	r2,r2,15
81106954:	e0bffc15 	stw	r2,-16(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg(pxFeebCh->puliFeebChAddr,
81106958:	e0bffd17 	ldw	r2,-12(fp)
8110695c:	10800017 	ldw	r2,0(r2)
81106960:	e1bffc17 	ldw	r6,-16(fp)
81106964:	01400544 	movi	r5,21
81106968:	1009883a 	mov	r4,r2
8110696c:	1106e140 	call	81106e14 <vFeebWriteReg>
					COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81106970:	00000d06 	br	811069a8 <bFeebSetBufferSize+0xc0>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81106974:	e0bffe03 	ldbu	r2,-8(fp)
81106978:	10bfffc4 	addi	r2,r2,-1
8110697c:	108003cc 	andi	r2,r2,15
81106980:	e0bffc15 	stw	r2,-16(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg(pxFeebCh->puliFeebChAddr,
81106984:	e0bffd17 	ldw	r2,-12(fp)
81106988:	10800017 	ldw	r2,0(r2)
8110698c:	e1bffc17 	ldw	r6,-16(fp)
81106990:	01400504 	movi	r5,20
81106994:	1009883a 	mov	r4,r2
81106998:	1106e140 	call	81106e14 <vFeebWriteReg>
					COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
8110699c:	00000206 	br	811069a8 <bFeebSetBufferSize+0xc0>
		default:
			bStatus = FALSE;
811069a0:	e03ffb15 	stw	zero,-20(fp)
			break;
811069a4:	0001883a 	nop
		}
	} else {
811069a8:	00000106 	br	811069b0 <bFeebSetBufferSize+0xc8>
		bStatus = FALSE;
811069ac:	e03ffb15 	stw	zero,-20(fp)
	}

	return bStatus;
811069b0:	e0bffb17 	ldw	r2,-20(fp)
}
811069b4:	e037883a 	mov	sp,fp
811069b8:	dfc00117 	ldw	ra,4(sp)
811069bc:	df000017 	ldw	fp,0(sp)
811069c0:	dec00204 	addi	sp,sp,8
811069c4:	f800283a 	ret

811069c8 <bFeebSetWindowing>:

bool bFeebSetWindowing(TFeebChannel *pxFeebCh) {
811069c8:	defffb04 	addi	sp,sp,-20
811069cc:	de00012e 	bgeu	sp,et,811069d4 <bFeebSetWindowing+0xc>
811069d0:	003b68fa 	trap	3
811069d4:	dfc00415 	stw	ra,16(sp)
811069d8:	df000315 	stw	fp,12(sp)
811069dc:	df000304 	addi	fp,sp,12
811069e0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811069e4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811069e8:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811069ec:	e0bfff17 	ldw	r2,-4(fp)
811069f0:	10001926 	beq	r2,zero,81106a58 <bFeebSetWindowing+0x90>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811069f4:	e0bfff17 	ldw	r2,-4(fp)
811069f8:	10800017 	ldw	r2,0(r2)
811069fc:	01400084 	movi	r5,2
81106a00:	1009883a 	mov	r4,r2
81106a04:	1106e680 	call	81106e68 <uliFeebReadReg>
81106a08:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		if (pxFeebCh->xWindowingConfig.bMasking) {
81106a0c:	e0bfff17 	ldw	r2,-4(fp)
81106a10:	10800117 	ldw	r2,4(r2)
81106a14:	10000426 	beq	r2,zero,81106a28 <bFeebSetWindowing+0x60>
			uliReg |= COMM_FEE_MASKING_EN_MSK;
81106a18:	e0bffe17 	ldw	r2,-8(fp)
81106a1c:	10800214 	ori	r2,r2,8
81106a20:	e0bffe15 	stw	r2,-8(fp)
81106a24:	00000406 	br	81106a38 <bFeebSetWindowing+0x70>
		} else {
			uliReg &= (~COMM_FEE_MASKING_EN_MSK);
81106a28:	e0fffe17 	ldw	r3,-8(fp)
81106a2c:	00bffdc4 	movi	r2,-9
81106a30:	1884703a 	and	r2,r3,r2
81106a34:	e0bffe15 	stw	r2,-8(fp)
		}

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81106a38:	e0bfff17 	ldw	r2,-4(fp)
81106a3c:	10800017 	ldw	r2,0(r2)
81106a40:	e1bffe17 	ldw	r6,-8(fp)
81106a44:	01400084 	movi	r5,2
81106a48:	1009883a 	mov	r4,r2
81106a4c:	1106e140 	call	81106e14 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81106a50:	00800044 	movi	r2,1
81106a54:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106a58:	e0bffd17 	ldw	r2,-12(fp)
}
81106a5c:	e037883a 	mov	sp,fp
81106a60:	dfc00117 	ldw	ra,4(sp)
81106a64:	df000017 	ldw	fp,0(sp)
81106a68:	dec00204 	addi	sp,sp,8
81106a6c:	f800283a 	ret

81106a70 <bFeebGetWindowing>:

bool bFeebGetWindowing(TFeebChannel *pxFeebCh) {
81106a70:	defffb04 	addi	sp,sp,-20
81106a74:	de00012e 	bgeu	sp,et,81106a7c <bFeebGetWindowing+0xc>
81106a78:	003b68fa 	trap	3
81106a7c:	dfc00415 	stw	ra,16(sp)
81106a80:	df000315 	stw	fp,12(sp)
81106a84:	df000304 	addi	fp,sp,12
81106a88:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106a8c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106a90:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106a94:	e0bfff17 	ldw	r2,-4(fp)
81106a98:	10001126 	beq	r2,zero,81106ae0 <bFeebGetWindowing+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106a9c:	e0bfff17 	ldw	r2,-4(fp)
81106aa0:	10800017 	ldw	r2,0(r2)
81106aa4:	01400084 	movi	r5,2
81106aa8:	1009883a 	mov	r4,r2
81106aac:	1106e680 	call	81106e68 <uliFeebReadReg>
81106ab0:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		if (uliReg & COMM_FEE_MASKING_EN_MSK) {
81106ab4:	e0bffe17 	ldw	r2,-8(fp)
81106ab8:	1080020c 	andi	r2,r2,8
81106abc:	10000426 	beq	r2,zero,81106ad0 <bFeebGetWindowing+0x60>
			pxFeebCh->xWindowingConfig.bMasking = TRUE;
81106ac0:	e0bfff17 	ldw	r2,-4(fp)
81106ac4:	00c00044 	movi	r3,1
81106ac8:	10c00115 	stw	r3,4(r2)
81106acc:	00000206 	br	81106ad8 <bFeebGetWindowing+0x68>
		} else {
			pxFeebCh->xWindowingConfig.bMasking = FALSE;
81106ad0:	e0bfff17 	ldw	r2,-4(fp)
81106ad4:	10000115 	stw	zero,4(r2)
		}

		bStatus = TRUE;
81106ad8:	00800044 	movi	r2,1
81106adc:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106ae0:	e0bffd17 	ldw	r2,-12(fp)
}
81106ae4:	e037883a 	mov	sp,fp
81106ae8:	dfc00117 	ldw	ra,4(sp)
81106aec:	df000017 	ldw	fp,0(sp)
81106af0:	dec00204 	addi	sp,sp,8
81106af4:	f800283a 	ret

81106af8 <bFeebStartCh>:

bool bFeebStartCh(TFeebChannel *pxFeebCh) {
81106af8:	defffb04 	addi	sp,sp,-20
81106afc:	de00012e 	bgeu	sp,et,81106b04 <bFeebStartCh+0xc>
81106b00:	003b68fa 	trap	3
81106b04:	dfc00415 	stw	ra,16(sp)
81106b08:	df000315 	stw	fp,12(sp)
81106b0c:	df000304 	addi	fp,sp,12
81106b10:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106b14:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106b18:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106b1c:	e0bfff17 	ldw	r2,-4(fp)
81106b20:	10001126 	beq	r2,zero,81106b68 <bFeebStartCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106b24:	e0bfff17 	ldw	r2,-4(fp)
81106b28:	10800017 	ldw	r2,0(r2)
81106b2c:	01400084 	movi	r5,2
81106b30:	1009883a 	mov	r4,r2
81106b34:	1106e680 	call	81106e68 <uliFeebReadReg>
81106b38:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_START_MSK;
81106b3c:	e0bffe17 	ldw	r2,-8(fp)
81106b40:	10800114 	ori	r2,r2,4
81106b44:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81106b48:	e0bfff17 	ldw	r2,-4(fp)
81106b4c:	10800017 	ldw	r2,0(r2)
81106b50:	e1bffe17 	ldw	r6,-8(fp)
81106b54:	01400084 	movi	r5,2
81106b58:	1009883a 	mov	r4,r2
81106b5c:	1106e140 	call	81106e14 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81106b60:	00800044 	movi	r2,1
81106b64:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106b68:	e0bffd17 	ldw	r2,-12(fp)
}
81106b6c:	e037883a 	mov	sp,fp
81106b70:	dfc00117 	ldw	ra,4(sp)
81106b74:	df000017 	ldw	fp,0(sp)
81106b78:	dec00204 	addi	sp,sp,8
81106b7c:	f800283a 	ret

81106b80 <bFeebStopCh>:

bool bFeebStopCh(TFeebChannel *pxFeebCh) {
81106b80:	defffb04 	addi	sp,sp,-20
81106b84:	de00012e 	bgeu	sp,et,81106b8c <bFeebStopCh+0xc>
81106b88:	003b68fa 	trap	3
81106b8c:	dfc00415 	stw	ra,16(sp)
81106b90:	df000315 	stw	fp,12(sp)
81106b94:	df000304 	addi	fp,sp,12
81106b98:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106b9c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106ba0:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106ba4:	e0bfff17 	ldw	r2,-4(fp)
81106ba8:	10001126 	beq	r2,zero,81106bf0 <bFeebStopCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106bac:	e0bfff17 	ldw	r2,-4(fp)
81106bb0:	10800017 	ldw	r2,0(r2)
81106bb4:	01400084 	movi	r5,2
81106bb8:	1009883a 	mov	r4,r2
81106bbc:	1106e680 	call	81106e68 <uliFeebReadReg>
81106bc0:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_STOP_MSK;
81106bc4:	e0bffe17 	ldw	r2,-8(fp)
81106bc8:	10800094 	ori	r2,r2,2
81106bcc:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81106bd0:	e0bfff17 	ldw	r2,-4(fp)
81106bd4:	10800017 	ldw	r2,0(r2)
81106bd8:	e1bffe17 	ldw	r6,-8(fp)
81106bdc:	01400084 	movi	r5,2
81106be0:	1009883a 	mov	r4,r2
81106be4:	1106e140 	call	81106e14 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81106be8:	00800044 	movi	r2,1
81106bec:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106bf0:	e0bffd17 	ldw	r2,-12(fp)
}
81106bf4:	e037883a 	mov	sp,fp
81106bf8:	dfc00117 	ldw	ra,4(sp)
81106bfc:	df000017 	ldw	fp,0(sp)
81106c00:	dec00204 	addi	sp,sp,8
81106c04:	f800283a 	ret

81106c08 <bFeebClrCh>:

bool bFeebClrCh(TFeebChannel *pxFeebCh) {
81106c08:	defffb04 	addi	sp,sp,-20
81106c0c:	de00012e 	bgeu	sp,et,81106c14 <bFeebClrCh+0xc>
81106c10:	003b68fa 	trap	3
81106c14:	dfc00415 	stw	ra,16(sp)
81106c18:	df000315 	stw	fp,12(sp)
81106c1c:	df000304 	addi	fp,sp,12
81106c20:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106c24:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106c28:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106c2c:	e0bfff17 	ldw	r2,-4(fp)
81106c30:	10001126 	beq	r2,zero,81106c78 <bFeebClrCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106c34:	e0bfff17 	ldw	r2,-4(fp)
81106c38:	10800017 	ldw	r2,0(r2)
81106c3c:	01400084 	movi	r5,2
81106c40:	1009883a 	mov	r4,r2
81106c44:	1106e680 	call	81106e68 <uliFeebReadReg>
81106c48:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_CLR_MSK;
81106c4c:	e0bffe17 	ldw	r2,-8(fp)
81106c50:	10800054 	ori	r2,r2,1
81106c54:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81106c58:	e0bfff17 	ldw	r2,-4(fp)
81106c5c:	10800017 	ldw	r2,0(r2)
81106c60:	e1bffe17 	ldw	r6,-8(fp)
81106c64:	01400084 	movi	r5,2
81106c68:	1009883a 	mov	r4,r2
81106c6c:	1106e140 	call	81106e14 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81106c70:	00800044 	movi	r2,1
81106c74:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106c78:	e0bffd17 	ldw	r2,-12(fp)
}
81106c7c:	e037883a 	mov	sp,fp
81106c80:	dfc00117 	ldw	ra,4(sp)
81106c84:	df000017 	ldw	fp,0(sp)
81106c88:	dec00204 	addi	sp,sp,8
81106c8c:	f800283a 	ret

81106c90 <bFeebInitCh>:

bool bFeebInitCh(TFeebChannel *pxFeebCh, alt_u8 ucCommCh) {
81106c90:	defffb04 	addi	sp,sp,-20
81106c94:	de00012e 	bgeu	sp,et,81106c9c <bFeebInitCh+0xc>
81106c98:	003b68fa 	trap	3
81106c9c:	dfc00415 	stw	ra,16(sp)
81106ca0:	df000315 	stw	fp,12(sp)
81106ca4:	df000304 	addi	fp,sp,12
81106ca8:	e13ffe15 	stw	r4,-8(fp)
81106cac:	2805883a 	mov	r2,r5
81106cb0:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81106cb4:	e03ffd15 	stw	zero,-12(fp)

	if (pxFeebCh != NULL) {
81106cb8:	e0bffe17 	ldw	r2,-8(fp)
81106cbc:	10004f26 	beq	r2,zero,81106dfc <bFeebInitCh+0x16c>
		bStatus = TRUE;
81106cc0:	00800044 	movi	r2,1
81106cc4:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81106cc8:	e0bfff03 	ldbu	r2,-4(fp)
81106ccc:	10c00228 	cmpgeui	r3,r2,8
81106cd0:	1800361e 	bne	r3,zero,81106dac <bFeebInitCh+0x11c>
81106cd4:	100690ba 	slli	r3,r2,2
81106cd8:	00a04434 	movhi	r2,33040
81106cdc:	109b3b04 	addi	r2,r2,27884
81106ce0:	1885883a 	add	r2,r3,r2
81106ce4:	10800017 	ldw	r2,0(r2)
81106ce8:	1000683a 	jmp	r2
81106cec:	81106d0c 	andi	r4,r16,16820
81106cf0:	81106d20 	cmpeqi	r4,r16,16820
81106cf4:	81106d34 	orhi	r4,r16,16820
81106cf8:	81106d48 	cmpgei	r4,r16,16821
81106cfc:	81106d5c 	xori	r4,r16,16821
81106d00:	81106d70 	cmpltui	r4,r16,16821
81106d04:	81106d84 	addi	r4,r16,16822
81106d08:	81106d98 	cmpnei	r4,r16,16822
		case eCommSpwCh1:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81106d0c:	e0fffe17 	ldw	r3,-8(fp)
81106d10:	00a04834 	movhi	r2,33056
81106d14:	108b0004 	addi	r2,r2,11264
81106d18:	18800015 	stw	r2,0(r3)
			break;
81106d1c:	00002506 	br	81106db4 <bFeebInitCh+0x124>
		case eCommSpwCh2:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81106d20:	e0fffe17 	ldw	r3,-8(fp)
81106d24:	00a04834 	movhi	r2,33056
81106d28:	108a0004 	addi	r2,r2,10240
81106d2c:	18800015 	stw	r2,0(r3)
			break;
81106d30:	00002006 	br	81106db4 <bFeebInitCh+0x124>
		case eCommSpwCh3:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81106d34:	e0fffe17 	ldw	r3,-8(fp)
81106d38:	00a04834 	movhi	r2,33056
81106d3c:	108b0004 	addi	r2,r2,11264
81106d40:	18800015 	stw	r2,0(r3)
			break;
81106d44:	00001b06 	br	81106db4 <bFeebInitCh+0x124>
		case eCommSpwCh4:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81106d48:	e0fffe17 	ldw	r3,-8(fp)
81106d4c:	00a04834 	movhi	r2,33056
81106d50:	108a0004 	addi	r2,r2,10240
81106d54:	18800015 	stw	r2,0(r3)
			break;
81106d58:	00001606 	br	81106db4 <bFeebInitCh+0x124>
		case eCommSpwCh5:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81106d5c:	e0fffe17 	ldw	r3,-8(fp)
81106d60:	00a04834 	movhi	r2,33056
81106d64:	108b0004 	addi	r2,r2,11264
81106d68:	18800015 	stw	r2,0(r3)
			break;
81106d6c:	00001106 	br	81106db4 <bFeebInitCh+0x124>
		case eCommSpwCh6:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81106d70:	e0fffe17 	ldw	r3,-8(fp)
81106d74:	00a04834 	movhi	r2,33056
81106d78:	108a0004 	addi	r2,r2,10240
81106d7c:	18800015 	stw	r2,0(r3)
			break;
81106d80:	00000c06 	br	81106db4 <bFeebInitCh+0x124>
		case eCommSpwCh7:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81106d84:	e0fffe17 	ldw	r3,-8(fp)
81106d88:	00a04834 	movhi	r2,33056
81106d8c:	108b0004 	addi	r2,r2,11264
81106d90:	18800015 	stw	r2,0(r3)
			break;
81106d94:	00000706 	br	81106db4 <bFeebInitCh+0x124>
		case eCommSpwCh8:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81106d98:	e0fffe17 	ldw	r3,-8(fp)
81106d9c:	00a04834 	movhi	r2,33056
81106da0:	108a0004 	addi	r2,r2,10240
81106da4:	18800015 	stw	r2,0(r3)
			break;
81106da8:	00000206 	br	81106db4 <bFeebInitCh+0x124>
		default:
			bStatus = FALSE;
81106dac:	e03ffd15 	stw	zero,-12(fp)
			break;
81106db0:	0001883a 	nop
		}

		if (bStatus) {
81106db4:	e0bffd17 	ldw	r2,-12(fp)
81106db8:	10001026 	beq	r2,zero,81106dfc <bFeebInitCh+0x16c>
			if (!bFeebGetIrqControl(pxFeebCh)) {
81106dbc:	e13ffe17 	ldw	r4,-8(fp)
81106dc0:	11064180 	call	81106418 <bFeebGetIrqControl>
81106dc4:	1000011e 	bne	r2,zero,81106dcc <bFeebInitCh+0x13c>
				bStatus = FALSE;
81106dc8:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetIrqFlags(pxFeebCh)) {
81106dcc:	e13ffe17 	ldw	r4,-8(fp)
81106dd0:	11064c40 	call	811064c4 <bFeebGetIrqFlags>
81106dd4:	1000011e 	bne	r2,zero,81106ddc <bFeebInitCh+0x14c>
				bStatus = FALSE;
81106dd8:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetBuffersStatus(pxFeebCh)) {
81106ddc:	e13ffe17 	ldw	r4,-8(fp)
81106de0:	110654c0 	call	8110654c <bFeebGetBuffersStatus>
81106de4:	1000011e 	bne	r2,zero,81106dec <bFeebInitCh+0x15c>
				bStatus = FALSE;
81106de8:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetWindowing(pxFeebCh)) {
81106dec:	e13ffe17 	ldw	r4,-8(fp)
81106df0:	1106a700 	call	81106a70 <bFeebGetWindowing>
81106df4:	1000011e 	bne	r2,zero,81106dfc <bFeebInitCh+0x16c>
				bStatus = FALSE;
81106df8:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81106dfc:	e0bffd17 	ldw	r2,-12(fp)
}
81106e00:	e037883a 	mov	sp,fp
81106e04:	dfc00117 	ldw	ra,4(sp)
81106e08:	df000017 	ldw	fp,0(sp)
81106e0c:	dec00204 	addi	sp,sp,8
81106e10:	f800283a 	ret

81106e14 <vFeebWriteReg>:

//! [public functions]

//! [private functions]
static void vFeebWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81106e14:	defffc04 	addi	sp,sp,-16
81106e18:	de00012e 	bgeu	sp,et,81106e20 <vFeebWriteReg+0xc>
81106e1c:	003b68fa 	trap	3
81106e20:	df000315 	stw	fp,12(sp)
81106e24:	df000304 	addi	fp,sp,12
81106e28:	e13ffd15 	stw	r4,-12(fp)
81106e2c:	e17ffe15 	stw	r5,-8(fp)
81106e30:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81106e34:	e0bffe17 	ldw	r2,-8(fp)
81106e38:	1085883a 	add	r2,r2,r2
81106e3c:	1085883a 	add	r2,r2,r2
81106e40:	1007883a 	mov	r3,r2
81106e44:	e0bffd17 	ldw	r2,-12(fp)
81106e48:	10c5883a 	add	r2,r2,r3
81106e4c:	e0ffff17 	ldw	r3,-4(fp)
81106e50:	10c00015 	stw	r3,0(r2)
}
81106e54:	0001883a 	nop
81106e58:	e037883a 	mov	sp,fp
81106e5c:	df000017 	ldw	fp,0(sp)
81106e60:	dec00104 	addi	sp,sp,4
81106e64:	f800283a 	ret

81106e68 <uliFeebReadReg>:

static alt_u32 uliFeebReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81106e68:	defffc04 	addi	sp,sp,-16
81106e6c:	de00012e 	bgeu	sp,et,81106e74 <uliFeebReadReg+0xc>
81106e70:	003b68fa 	trap	3
81106e74:	df000315 	stw	fp,12(sp)
81106e78:	df000304 	addi	fp,sp,12
81106e7c:	e13ffe15 	stw	r4,-8(fp)
81106e80:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81106e84:	e0bfff17 	ldw	r2,-4(fp)
81106e88:	1085883a 	add	r2,r2,r2
81106e8c:	1085883a 	add	r2,r2,r2
81106e90:	1007883a 	mov	r3,r2
81106e94:	e0bffe17 	ldw	r2,-8(fp)
81106e98:	10c5883a 	add	r2,r2,r3
81106e9c:	10800017 	ldw	r2,0(r2)
81106ea0:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81106ea4:	e0bffd17 	ldw	r2,-12(fp)
}
81106ea8:	e037883a 	mov	sp,fp
81106eac:	df000017 	ldw	fp,0(sp)
81106eb0:	dec00104 	addi	sp,sp,4
81106eb4:	f800283a 	ret

81106eb8 <vRmapCh1HandleIrq>:
//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
/* todo:Trigger not working right */
void vRmapCh1HandleIrq(void* pvContext) {
81106eb8:	defffa04 	addi	sp,sp,-24
81106ebc:	de00012e 	bgeu	sp,et,81106ec4 <vRmapCh1HandleIrq+0xc>
81106ec0:	003b68fa 	trap	3
81106ec4:	dfc00515 	stw	ra,20(sp)
81106ec8:	df000415 	stw	fp,16(sp)
81106ecc:	df000404 	addi	fp,sp,16
81106ed0:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106ed4:	e0bfff17 	ldw	r2,-4(fp)
81106ed8:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;

	/* Warnning simplification: For now all address is lower than 1 bytes  */

#ifdef DEBUG_ON
	fprintf(fp,"IRQ RMAP.\n");
81106edc:	d0a06217 	ldw	r2,-32376(gp)
81106ee0:	100f883a 	mov	r7,r2
81106ee4:	01800284 	movi	r6,10
81106ee8:	01400044 	movi	r5,1
81106eec:	01204574 	movhi	r4,33045
81106ef0:	21317104 	addi	r4,r4,-14908
81106ef4:	1121c7c0 	call	81121c7c <fwrite>
#endif

	ucADDRReg = (unsigned char)uliRmapCh1WriteCmdAddress();
81106ef8:	11076840 	call	81107684 <uliRmapCh1WriteCmdAddress>
81106efc:	e0bffd05 	stb	r2,-12(fp)

	uiCmdRmap.ucByte[3] = M_NFEE_BASE_ADDR + 0;
81106f00:	00800444 	movi	r2,17
81106f04:	e0bffec5 	stb	r2,-5(fp)
	uiCmdRmap.ucByte[2] = M_FEE_RMAP;
81106f08:	00bffc04 	movi	r2,-16
81106f0c:	e0bffe85 	stb	r2,-6(fp)
	uiCmdRmap.ucByte[1] = ucADDRReg;
81106f10:	e0bffd03 	ldbu	r2,-12(fp)
81106f14:	e0bffe45 	stb	r2,-7(fp)
	uiCmdRmap.ucByte[0] = 0;
81106f18:	e03ffe05 	stb	zero,-8(fp)

#ifdef DEBUG_ON
	fprintf(fp,"IucADDRReg: %u\n", ucADDRReg);
81106f1c:	d0a06217 	ldw	r2,-32376(gp)
81106f20:	e0fffd03 	ldbu	r3,-12(fp)
81106f24:	180d883a 	mov	r6,r3
81106f28:	01604574 	movhi	r5,33045
81106f2c:	29717404 	addi	r5,r5,-14896
81106f30:	1009883a 	mov	r4,r2
81106f34:	11215e00 	call	811215e0 <fprintf>
#endif

	error_codel = OSQPostFront(xFeeQ[0], (void *)uiCmdRmap.ulWord); /*todo: Fee number Hard Coded*/
81106f38:	d0a06a17 	ldw	r2,-32344(gp)
81106f3c:	e0fffe17 	ldw	r3,-8(fp)
81106f40:	180b883a 	mov	r5,r3
81106f44:	1009883a 	mov	r4,r2
81106f48:	113e1980 	call	8113e198 <OSQPostFront>
81106f4c:	e0bffd45 	stb	r2,-11(fp)
	if ( error_codel != OS_ERR_NONE ) {
81106f50:	e0bffd43 	ldbu	r2,-11(fp)
81106f54:	10000226 	beq	r2,zero,81106f60 <vRmapCh1HandleIrq+0xa8>
		vFailSendRMAPFromIRQ( 0 );
81106f58:	0009883a 	mov	r4,zero
81106f5c:	111d4ac0 	call	8111d4ac <vFailSendRMAPFromIRQ>
	}

	vRmapCh1IrqFlagClrWriteCmd();
81106f60:	11071a40 	call	811071a4 <vRmapCh1IrqFlagClrWriteCmd>
}
81106f64:	0001883a 	nop
81106f68:	e037883a 	mov	sp,fp
81106f6c:	dfc00117 	ldw	ra,4(sp)
81106f70:	df000017 	ldw	fp,0(sp)
81106f74:	dec00204 	addi	sp,sp,8
81106f78:	f800283a 	ret

81106f7c <vRmapCh2HandleIrq>:

void vRmapCh2HandleIrq(void* pvContext) {
81106f7c:	defffa04 	addi	sp,sp,-24
81106f80:	de00012e 	bgeu	sp,et,81106f88 <vRmapCh2HandleIrq+0xc>
81106f84:	003b68fa 	trap	3
81106f88:	dfc00515 	stw	ra,20(sp)
81106f8c:	df000415 	stw	fp,16(sp)
81106f90:	df000404 	addi	fp,sp,16
81106f94:	e13fff15 	stw	r4,-4(fp)
	INT8U ucADDRReg;
	INT32U ucValueReg;
	INT32U ucValueMasked;
	INT8U error_codel;

	volatile int* pviHoldContext = (volatile int*) pvContext;
81106f98:	e0bfff17 	ldw	r2,-4(fp)
81106f9c:	e0bffc15 	stw	r2,-16(fp)

	ucADDRReg = (unsigned char)uliRmapCh2WriteCmdAddress();
81106fa0:	11076d40 	call	811076d4 <uliRmapCh2WriteCmdAddress>
81106fa4:	e0bffd05 	stb	r2,-12(fp)

	uiCmdRmap.ucByte[3] = M_NFEE_BASE_ADDR + 0;
81106fa8:	00800444 	movi	r2,17
81106fac:	e0bffec5 	stb	r2,-5(fp)
	uiCmdRmap.ucByte[2] = M_FEE_RMAP;
81106fb0:	00bffc04 	movi	r2,-16
81106fb4:	e0bffe85 	stb	r2,-6(fp)
	uiCmdRmap.ucByte[1] = ucADDRReg;
81106fb8:	e0bffd03 	ldbu	r2,-12(fp)
81106fbc:	e0bffe45 	stb	r2,-7(fp)
	uiCmdRmap.ucByte[0] = 0;
81106fc0:	e03ffe05 	stb	zero,-8(fp)

#ifdef DEBUG_ON
	fprintf(fp,"IucADDRReg: %u\n", ucADDRReg);
81106fc4:	d0a06217 	ldw	r2,-32376(gp)
81106fc8:	e0fffd03 	ldbu	r3,-12(fp)
81106fcc:	180d883a 	mov	r6,r3
81106fd0:	01604574 	movhi	r5,33045
81106fd4:	29717404 	addi	r5,r5,-14896
81106fd8:	1009883a 	mov	r4,r2
81106fdc:	11215e00 	call	811215e0 <fprintf>
#endif

	error_codel = OSQPostFront(xFeeQ[0], (void *)uiCmdRmap.ulWord); /*todo: Fee number Hard Coded*/
81106fe0:	d0a06a17 	ldw	r2,-32344(gp)
81106fe4:	e0fffe17 	ldw	r3,-8(fp)
81106fe8:	180b883a 	mov	r5,r3
81106fec:	1009883a 	mov	r4,r2
81106ff0:	113e1980 	call	8113e198 <OSQPostFront>
81106ff4:	e0bffd45 	stb	r2,-11(fp)
	if ( error_codel != OS_ERR_NONE ) {
81106ff8:	e0bffd43 	ldbu	r2,-11(fp)
81106ffc:	10000226 	beq	r2,zero,81107008 <vRmapCh2HandleIrq+0x8c>
		vFailSendRMAPFromIRQ( 0 );
81107000:	0009883a 	mov	r4,zero
81107004:	111d4ac0 	call	8111d4ac <vFailSendRMAPFromIRQ>
	}


	vRmapCh2IrqFlagClrWriteCmd();
81107008:	11071e80 	call	811071e8 <vRmapCh2IrqFlagClrWriteCmd>
}
8110700c:	0001883a 	nop
81107010:	e037883a 	mov	sp,fp
81107014:	dfc00117 	ldw	ra,4(sp)
81107018:	df000017 	ldw	fp,0(sp)
8110701c:	dec00204 	addi	sp,sp,8
81107020:	f800283a 	ret

81107024 <vRmapCh3HandleIrq>:

void vRmapCh3HandleIrq(void* pvContext) {
81107024:	defffc04 	addi	sp,sp,-16
81107028:	de00012e 	bgeu	sp,et,81107030 <vRmapCh3HandleIrq+0xc>
8110702c:	003b68fa 	trap	3
81107030:	dfc00315 	stw	ra,12(sp)
81107034:	df000215 	stw	fp,8(sp)
81107038:	df000204 	addi	fp,sp,8
8110703c:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81107040:	e0bfff17 	ldw	r2,-4(fp)
81107044:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh3IrqFlagClrWriteCmd();
81107048:	110722c0 	call	8110722c <vRmapCh3IrqFlagClrWriteCmd>
}
8110704c:	0001883a 	nop
81107050:	e037883a 	mov	sp,fp
81107054:	dfc00117 	ldw	ra,4(sp)
81107058:	df000017 	ldw	fp,0(sp)
8110705c:	dec00204 	addi	sp,sp,8
81107060:	f800283a 	ret

81107064 <vRmapCh4HandleIrq>:

void vRmapCh4HandleIrq(void* pvContext) {
81107064:	defffc04 	addi	sp,sp,-16
81107068:	de00012e 	bgeu	sp,et,81107070 <vRmapCh4HandleIrq+0xc>
8110706c:	003b68fa 	trap	3
81107070:	dfc00315 	stw	ra,12(sp)
81107074:	df000215 	stw	fp,8(sp)
81107078:	df000204 	addi	fp,sp,8
8110707c:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81107080:	e0bfff17 	ldw	r2,-4(fp)
81107084:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh4IrqFlagClrWriteCmd();
81107088:	11072700 	call	81107270 <vRmapCh4IrqFlagClrWriteCmd>
}
8110708c:	0001883a 	nop
81107090:	e037883a 	mov	sp,fp
81107094:	dfc00117 	ldw	ra,4(sp)
81107098:	df000017 	ldw	fp,0(sp)
8110709c:	dec00204 	addi	sp,sp,8
811070a0:	f800283a 	ret

811070a4 <vRmapCh5HandleIrq>:

void vRmapCh5HandleIrq(void* pvContext) {
811070a4:	defffc04 	addi	sp,sp,-16
811070a8:	de00012e 	bgeu	sp,et,811070b0 <vRmapCh5HandleIrq+0xc>
811070ac:	003b68fa 	trap	3
811070b0:	dfc00315 	stw	ra,12(sp)
811070b4:	df000215 	stw	fp,8(sp)
811070b8:	df000204 	addi	fp,sp,8
811070bc:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
811070c0:	e0bfff17 	ldw	r2,-4(fp)
811070c4:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh5IrqFlagClrWriteCmd();
811070c8:	11072b40 	call	811072b4 <vRmapCh5IrqFlagClrWriteCmd>
}
811070cc:	0001883a 	nop
811070d0:	e037883a 	mov	sp,fp
811070d4:	dfc00117 	ldw	ra,4(sp)
811070d8:	df000017 	ldw	fp,0(sp)
811070dc:	dec00204 	addi	sp,sp,8
811070e0:	f800283a 	ret

811070e4 <vRmapCh6HandleIrq>:

void vRmapCh6HandleIrq(void* pvContext) {
811070e4:	defffc04 	addi	sp,sp,-16
811070e8:	de00012e 	bgeu	sp,et,811070f0 <vRmapCh6HandleIrq+0xc>
811070ec:	003b68fa 	trap	3
811070f0:	dfc00315 	stw	ra,12(sp)
811070f4:	df000215 	stw	fp,8(sp)
811070f8:	df000204 	addi	fp,sp,8
811070fc:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81107100:	e0bfff17 	ldw	r2,-4(fp)
81107104:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*hold_context_ptr = ...;
	// if (*hold_context_ptr == '0') {}...
	// App logic sequence...
	vRmapCh6IrqFlagClrWriteCmd();
81107108:	11072f80 	call	811072f8 <vRmapCh6IrqFlagClrWriteCmd>
}
8110710c:	0001883a 	nop
81107110:	e037883a 	mov	sp,fp
81107114:	dfc00117 	ldw	ra,4(sp)
81107118:	df000017 	ldw	fp,0(sp)
8110711c:	dec00204 	addi	sp,sp,8
81107120:	f800283a 	ret

81107124 <vRmapCh7HandleIrq>:

void vRmapCh7HandleIrq(void* pvContext) {
81107124:	defffc04 	addi	sp,sp,-16
81107128:	de00012e 	bgeu	sp,et,81107130 <vRmapCh7HandleIrq+0xc>
8110712c:	003b68fa 	trap	3
81107130:	dfc00315 	stw	ra,12(sp)
81107134:	df000215 	stw	fp,8(sp)
81107138:	df000204 	addi	fp,sp,8
8110713c:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81107140:	e0bfff17 	ldw	r2,-4(fp)
81107144:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh7IrqFlagClrWriteCmd();
81107148:	110733c0 	call	8110733c <vRmapCh7IrqFlagClrWriteCmd>
}
8110714c:	0001883a 	nop
81107150:	e037883a 	mov	sp,fp
81107154:	dfc00117 	ldw	ra,4(sp)
81107158:	df000017 	ldw	fp,0(sp)
8110715c:	dec00204 	addi	sp,sp,8
81107160:	f800283a 	ret

81107164 <vRmapCh8HandleIrq>:

void vRmapCh8HandleIrq(void* pvContext) {
81107164:	defffc04 	addi	sp,sp,-16
81107168:	de00012e 	bgeu	sp,et,81107170 <vRmapCh8HandleIrq+0xc>
8110716c:	003b68fa 	trap	3
81107170:	dfc00315 	stw	ra,12(sp)
81107174:	df000215 	stw	fp,8(sp)
81107178:	df000204 	addi	fp,sp,8
8110717c:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81107180:	e0bfff17 	ldw	r2,-4(fp)
81107184:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh8IrqFlagClrWriteCmd();
81107188:	11073800 	call	81107380 <vRmapCh8IrqFlagClrWriteCmd>
}
8110718c:	0001883a 	nop
81107190:	e037883a 	mov	sp,fp
81107194:	dfc00117 	ldw	ra,4(sp)
81107198:	df000017 	ldw	fp,0(sp)
8110719c:	dec00204 	addi	sp,sp,8
811071a0:	f800283a 	ret

811071a4 <vRmapCh1IrqFlagClrWriteCmd>:

void vRmapCh1IrqFlagClrWriteCmd(void) {
811071a4:	defffe04 	addi	sp,sp,-8
811071a8:	de00012e 	bgeu	sp,et,811071b0 <vRmapCh1IrqFlagClrWriteCmd+0xc>
811071ac:	003b68fa 	trap	3
811071b0:	dfc00115 	stw	ra,4(sp)
811071b4:	df000015 	stw	fp,0(sp)
811071b8:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811071bc:	01800044 	movi	r6,1
811071c0:	014004c4 	movi	r5,19
811071c4:	01204834 	movhi	r4,33056
811071c8:	210b0004 	addi	r4,r4,11264
811071cc:	110a06c0 	call	8110a06c <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
811071d0:	0001883a 	nop
811071d4:	e037883a 	mov	sp,fp
811071d8:	dfc00117 	ldw	ra,4(sp)
811071dc:	df000017 	ldw	fp,0(sp)
811071e0:	dec00204 	addi	sp,sp,8
811071e4:	f800283a 	ret

811071e8 <vRmapCh2IrqFlagClrWriteCmd>:

void vRmapCh2IrqFlagClrWriteCmd(void) {
811071e8:	defffe04 	addi	sp,sp,-8
811071ec:	de00012e 	bgeu	sp,et,811071f4 <vRmapCh2IrqFlagClrWriteCmd+0xc>
811071f0:	003b68fa 	trap	3
811071f4:	dfc00115 	stw	ra,4(sp)
811071f8:	df000015 	stw	fp,0(sp)
811071fc:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81107200:	01800044 	movi	r6,1
81107204:	014004c4 	movi	r5,19
81107208:	01204834 	movhi	r4,33056
8110720c:	210a0004 	addi	r4,r4,10240
81107210:	110a06c0 	call	8110a06c <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81107214:	0001883a 	nop
81107218:	e037883a 	mov	sp,fp
8110721c:	dfc00117 	ldw	ra,4(sp)
81107220:	df000017 	ldw	fp,0(sp)
81107224:	dec00204 	addi	sp,sp,8
81107228:	f800283a 	ret

8110722c <vRmapCh3IrqFlagClrWriteCmd>:

void vRmapCh3IrqFlagClrWriteCmd(void) {
8110722c:	defffe04 	addi	sp,sp,-8
81107230:	de00012e 	bgeu	sp,et,81107238 <vRmapCh3IrqFlagClrWriteCmd+0xc>
81107234:	003b68fa 	trap	3
81107238:	dfc00115 	stw	ra,4(sp)
8110723c:	df000015 	stw	fp,0(sp)
81107240:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81107244:	01800044 	movi	r6,1
81107248:	014004c4 	movi	r5,19
8110724c:	01204834 	movhi	r4,33056
81107250:	210b0004 	addi	r4,r4,11264
81107254:	110a06c0 	call	8110a06c <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81107258:	0001883a 	nop
8110725c:	e037883a 	mov	sp,fp
81107260:	dfc00117 	ldw	ra,4(sp)
81107264:	df000017 	ldw	fp,0(sp)
81107268:	dec00204 	addi	sp,sp,8
8110726c:	f800283a 	ret

81107270 <vRmapCh4IrqFlagClrWriteCmd>:

void vRmapCh4IrqFlagClrWriteCmd(void) {
81107270:	defffe04 	addi	sp,sp,-8
81107274:	de00012e 	bgeu	sp,et,8110727c <vRmapCh4IrqFlagClrWriteCmd+0xc>
81107278:	003b68fa 	trap	3
8110727c:	dfc00115 	stw	ra,4(sp)
81107280:	df000015 	stw	fp,0(sp)
81107284:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81107288:	01800044 	movi	r6,1
8110728c:	014004c4 	movi	r5,19
81107290:	01204834 	movhi	r4,33056
81107294:	210a0004 	addi	r4,r4,10240
81107298:	110a06c0 	call	8110a06c <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
8110729c:	0001883a 	nop
811072a0:	e037883a 	mov	sp,fp
811072a4:	dfc00117 	ldw	ra,4(sp)
811072a8:	df000017 	ldw	fp,0(sp)
811072ac:	dec00204 	addi	sp,sp,8
811072b0:	f800283a 	ret

811072b4 <vRmapCh5IrqFlagClrWriteCmd>:

void vRmapCh5IrqFlagClrWriteCmd(void) {
811072b4:	defffe04 	addi	sp,sp,-8
811072b8:	de00012e 	bgeu	sp,et,811072c0 <vRmapCh5IrqFlagClrWriteCmd+0xc>
811072bc:	003b68fa 	trap	3
811072c0:	dfc00115 	stw	ra,4(sp)
811072c4:	df000015 	stw	fp,0(sp)
811072c8:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
811072cc:	01800044 	movi	r6,1
811072d0:	014004c4 	movi	r5,19
811072d4:	01204834 	movhi	r4,33056
811072d8:	210b0004 	addi	r4,r4,11264
811072dc:	110a06c0 	call	8110a06c <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
811072e0:	0001883a 	nop
811072e4:	e037883a 	mov	sp,fp
811072e8:	dfc00117 	ldw	ra,4(sp)
811072ec:	df000017 	ldw	fp,0(sp)
811072f0:	dec00204 	addi	sp,sp,8
811072f4:	f800283a 	ret

811072f8 <vRmapCh6IrqFlagClrWriteCmd>:

void vRmapCh6IrqFlagClrWriteCmd(void) {
811072f8:	defffe04 	addi	sp,sp,-8
811072fc:	de00012e 	bgeu	sp,et,81107304 <vRmapCh6IrqFlagClrWriteCmd+0xc>
81107300:	003b68fa 	trap	3
81107304:	dfc00115 	stw	ra,4(sp)
81107308:	df000015 	stw	fp,0(sp)
8110730c:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81107310:	01800044 	movi	r6,1
81107314:	014004c4 	movi	r5,19
81107318:	01204834 	movhi	r4,33056
8110731c:	210a0004 	addi	r4,r4,10240
81107320:	110a06c0 	call	8110a06c <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81107324:	0001883a 	nop
81107328:	e037883a 	mov	sp,fp
8110732c:	dfc00117 	ldw	ra,4(sp)
81107330:	df000017 	ldw	fp,0(sp)
81107334:	dec00204 	addi	sp,sp,8
81107338:	f800283a 	ret

8110733c <vRmapCh7IrqFlagClrWriteCmd>:

void vRmapCh7IrqFlagClrWriteCmd(void) {
8110733c:	defffe04 	addi	sp,sp,-8
81107340:	de00012e 	bgeu	sp,et,81107348 <vRmapCh7IrqFlagClrWriteCmd+0xc>
81107344:	003b68fa 	trap	3
81107348:	dfc00115 	stw	ra,4(sp)
8110734c:	df000015 	stw	fp,0(sp)
81107350:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81107354:	01800044 	movi	r6,1
81107358:	014004c4 	movi	r5,19
8110735c:	01204834 	movhi	r4,33056
81107360:	210b0004 	addi	r4,r4,11264
81107364:	110a06c0 	call	8110a06c <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81107368:	0001883a 	nop
8110736c:	e037883a 	mov	sp,fp
81107370:	dfc00117 	ldw	ra,4(sp)
81107374:	df000017 	ldw	fp,0(sp)
81107378:	dec00204 	addi	sp,sp,8
8110737c:	f800283a 	ret

81107380 <vRmapCh8IrqFlagClrWriteCmd>:

void vRmapCh8IrqFlagClrWriteCmd(void) {
81107380:	defffe04 	addi	sp,sp,-8
81107384:	de00012e 	bgeu	sp,et,8110738c <vRmapCh8IrqFlagClrWriteCmd+0xc>
81107388:	003b68fa 	trap	3
8110738c:	dfc00115 	stw	ra,4(sp)
81107390:	df000015 	stw	fp,0(sp)
81107394:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81107398:	01800044 	movi	r6,1
8110739c:	014004c4 	movi	r5,19
811073a0:	01204834 	movhi	r4,33056
811073a4:	210a0004 	addi	r4,r4,10240
811073a8:	110a06c0 	call	8110a06c <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
811073ac:	0001883a 	nop
811073b0:	e037883a 	mov	sp,fp
811073b4:	dfc00117 	ldw	ra,4(sp)
811073b8:	df000017 	ldw	fp,0(sp)
811073bc:	dec00204 	addi	sp,sp,8
811073c0:	f800283a 	ret

811073c4 <bRmapCh1IrqFlagWriteCmd>:

bool bRmapCh1IrqFlagWriteCmd(void) {
811073c4:	defffd04 	addi	sp,sp,-12
811073c8:	de00012e 	bgeu	sp,et,811073d0 <bRmapCh1IrqFlagWriteCmd+0xc>
811073cc:	003b68fa 	trap	3
811073d0:	dfc00215 	stw	ra,8(sp)
811073d4:	df000115 	stw	fp,4(sp)
811073d8:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811073dc:	01400484 	movi	r5,18
811073e0:	01204834 	movhi	r4,33056
811073e4:	210b0004 	addi	r4,r4,11264
811073e8:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811073ec:	1080004c 	andi	r2,r2,1
}

bool bRmapCh1IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811073f0:	10000326 	beq	r2,zero,81107400 <bRmapCh1IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811073f4:	00800044 	movi	r2,1
811073f8:	e0bfff15 	stw	r2,-4(fp)
811073fc:	00000106 	br	81107404 <bRmapCh1IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81107400:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107404:	e0bfff17 	ldw	r2,-4(fp)
}
81107408:	e037883a 	mov	sp,fp
8110740c:	dfc00117 	ldw	ra,4(sp)
81107410:	df000017 	ldw	fp,0(sp)
81107414:	dec00204 	addi	sp,sp,8
81107418:	f800283a 	ret

8110741c <bRmapCh2IrqFlagWriteCmd>:

bool bRmapCh2IrqFlagWriteCmd(void) {
8110741c:	defffd04 	addi	sp,sp,-12
81107420:	de00012e 	bgeu	sp,et,81107428 <bRmapCh2IrqFlagWriteCmd+0xc>
81107424:	003b68fa 	trap	3
81107428:	dfc00215 	stw	ra,8(sp)
8110742c:	df000115 	stw	fp,4(sp)
81107430:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81107434:	01400484 	movi	r5,18
81107438:	01204834 	movhi	r4,33056
8110743c:	210a0004 	addi	r4,r4,10240
81107440:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107444:	1080004c 	andi	r2,r2,1
}

bool bRmapCh2IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81107448:	10000326 	beq	r2,zero,81107458 <bRmapCh2IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
8110744c:	00800044 	movi	r2,1
81107450:	e0bfff15 	stw	r2,-4(fp)
81107454:	00000106 	br	8110745c <bRmapCh2IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81107458:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110745c:	e0bfff17 	ldw	r2,-4(fp)
}
81107460:	e037883a 	mov	sp,fp
81107464:	dfc00117 	ldw	ra,4(sp)
81107468:	df000017 	ldw	fp,0(sp)
8110746c:	dec00204 	addi	sp,sp,8
81107470:	f800283a 	ret

81107474 <bRmapCh3IrqFlagWriteCmd>:

bool bRmapCh3IrqFlagWriteCmd(void) {
81107474:	defffd04 	addi	sp,sp,-12
81107478:	de00012e 	bgeu	sp,et,81107480 <bRmapCh3IrqFlagWriteCmd+0xc>
8110747c:	003b68fa 	trap	3
81107480:	dfc00215 	stw	ra,8(sp)
81107484:	df000115 	stw	fp,4(sp)
81107488:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
8110748c:	01400484 	movi	r5,18
81107490:	01204834 	movhi	r4,33056
81107494:	210b0004 	addi	r4,r4,11264
81107498:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
8110749c:	1080004c 	andi	r2,r2,1
}

bool bRmapCh3IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
811074a0:	10000326 	beq	r2,zero,811074b0 <bRmapCh3IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811074a4:	00800044 	movi	r2,1
811074a8:	e0bfff15 	stw	r2,-4(fp)
811074ac:	00000106 	br	811074b4 <bRmapCh3IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
811074b0:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811074b4:	e0bfff17 	ldw	r2,-4(fp)
}
811074b8:	e037883a 	mov	sp,fp
811074bc:	dfc00117 	ldw	ra,4(sp)
811074c0:	df000017 	ldw	fp,0(sp)
811074c4:	dec00204 	addi	sp,sp,8
811074c8:	f800283a 	ret

811074cc <bRmapCh4IrqFlagWriteCmd>:

bool bRmapCh4IrqFlagWriteCmd(void) {
811074cc:	defffd04 	addi	sp,sp,-12
811074d0:	de00012e 	bgeu	sp,et,811074d8 <bRmapCh4IrqFlagWriteCmd+0xc>
811074d4:	003b68fa 	trap	3
811074d8:	dfc00215 	stw	ra,8(sp)
811074dc:	df000115 	stw	fp,4(sp)
811074e0:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
811074e4:	01400484 	movi	r5,18
811074e8:	01204834 	movhi	r4,33056
811074ec:	210a0004 	addi	r4,r4,10240
811074f0:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811074f4:	1080004c 	andi	r2,r2,1
}

bool bRmapCh4IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
811074f8:	10000326 	beq	r2,zero,81107508 <bRmapCh4IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811074fc:	00800044 	movi	r2,1
81107500:	e0bfff15 	stw	r2,-4(fp)
81107504:	00000106 	br	8110750c <bRmapCh4IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81107508:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110750c:	e0bfff17 	ldw	r2,-4(fp)
}
81107510:	e037883a 	mov	sp,fp
81107514:	dfc00117 	ldw	ra,4(sp)
81107518:	df000017 	ldw	fp,0(sp)
8110751c:	dec00204 	addi	sp,sp,8
81107520:	f800283a 	ret

81107524 <bRmapCh5IrqFlagWriteCmd>:

bool bRmapCh5IrqFlagWriteCmd(void) {
81107524:	defffd04 	addi	sp,sp,-12
81107528:	de00012e 	bgeu	sp,et,81107530 <bRmapCh5IrqFlagWriteCmd+0xc>
8110752c:	003b68fa 	trap	3
81107530:	dfc00215 	stw	ra,8(sp)
81107534:	df000115 	stw	fp,4(sp)
81107538:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
8110753c:	01400484 	movi	r5,18
81107540:	01204834 	movhi	r4,33056
81107544:	210b0004 	addi	r4,r4,11264
81107548:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
8110754c:	1080004c 	andi	r2,r2,1
}

bool bRmapCh5IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81107550:	10000326 	beq	r2,zero,81107560 <bRmapCh5IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81107554:	00800044 	movi	r2,1
81107558:	e0bfff15 	stw	r2,-4(fp)
8110755c:	00000106 	br	81107564 <bRmapCh5IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81107560:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107564:	e0bfff17 	ldw	r2,-4(fp)
}
81107568:	e037883a 	mov	sp,fp
8110756c:	dfc00117 	ldw	ra,4(sp)
81107570:	df000017 	ldw	fp,0(sp)
81107574:	dec00204 	addi	sp,sp,8
81107578:	f800283a 	ret

8110757c <bRmapCh6IrqFlagWriteCmd>:

bool bRmapCh6IrqFlagWriteCmd(void) {
8110757c:	defffd04 	addi	sp,sp,-12
81107580:	de00012e 	bgeu	sp,et,81107588 <bRmapCh6IrqFlagWriteCmd+0xc>
81107584:	003b68fa 	trap	3
81107588:	dfc00215 	stw	ra,8(sp)
8110758c:	df000115 	stw	fp,4(sp)
81107590:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81107594:	01400484 	movi	r5,18
81107598:	01204834 	movhi	r4,33056
8110759c:	210a0004 	addi	r4,r4,10240
811075a0:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811075a4:	1080004c 	andi	r2,r2,1
}

bool bRmapCh6IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811075a8:	10000326 	beq	r2,zero,811075b8 <bRmapCh6IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811075ac:	00800044 	movi	r2,1
811075b0:	e0bfff15 	stw	r2,-4(fp)
811075b4:	00000106 	br	811075bc <bRmapCh6IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
811075b8:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811075bc:	e0bfff17 	ldw	r2,-4(fp)
}
811075c0:	e037883a 	mov	sp,fp
811075c4:	dfc00117 	ldw	ra,4(sp)
811075c8:	df000017 	ldw	fp,0(sp)
811075cc:	dec00204 	addi	sp,sp,8
811075d0:	f800283a 	ret

811075d4 <bRmapCh7IrqFlagWriteCmd>:

bool bRmapCh7IrqFlagWriteCmd(void) {
811075d4:	defffd04 	addi	sp,sp,-12
811075d8:	de00012e 	bgeu	sp,et,811075e0 <bRmapCh7IrqFlagWriteCmd+0xc>
811075dc:	003b68fa 	trap	3
811075e0:	dfc00215 	stw	ra,8(sp)
811075e4:	df000115 	stw	fp,4(sp)
811075e8:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
811075ec:	01400484 	movi	r5,18
811075f0:	01204834 	movhi	r4,33056
811075f4:	210b0004 	addi	r4,r4,11264
811075f8:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811075fc:	1080004c 	andi	r2,r2,1
}

bool bRmapCh7IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81107600:	10000326 	beq	r2,zero,81107610 <bRmapCh7IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81107604:	00800044 	movi	r2,1
81107608:	e0bfff15 	stw	r2,-4(fp)
8110760c:	00000106 	br	81107614 <bRmapCh7IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81107610:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107614:	e0bfff17 	ldw	r2,-4(fp)
}
81107618:	e037883a 	mov	sp,fp
8110761c:	dfc00117 	ldw	ra,4(sp)
81107620:	df000017 	ldw	fp,0(sp)
81107624:	dec00204 	addi	sp,sp,8
81107628:	f800283a 	ret

8110762c <bRmapCh8IrqFlagWriteCmd>:

bool bRmapCh8IrqFlagWriteCmd(void) {
8110762c:	defffd04 	addi	sp,sp,-12
81107630:	de00012e 	bgeu	sp,et,81107638 <bRmapCh8IrqFlagWriteCmd+0xc>
81107634:	003b68fa 	trap	3
81107638:	dfc00215 	stw	ra,8(sp)
8110763c:	df000115 	stw	fp,4(sp)
81107640:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81107644:	01400484 	movi	r5,18
81107648:	01204834 	movhi	r4,33056
8110764c:	210a0004 	addi	r4,r4,10240
81107650:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107654:	1080004c 	andi	r2,r2,1
}

bool bRmapCh8IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81107658:	10000326 	beq	r2,zero,81107668 <bRmapCh8IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
8110765c:	00800044 	movi	r2,1
81107660:	e0bfff15 	stw	r2,-4(fp)
81107664:	00000106 	br	8110766c <bRmapCh8IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81107668:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110766c:	e0bfff17 	ldw	r2,-4(fp)
}
81107670:	e037883a 	mov	sp,fp
81107674:	dfc00117 	ldw	ra,4(sp)
81107678:	df000017 	ldw	fp,0(sp)
8110767c:	dec00204 	addi	sp,sp,8
81107680:	f800283a 	ret

81107684 <uliRmapCh1WriteCmdAddress>:

alt_u32 uliRmapCh1WriteCmdAddress(void) {
81107684:	defffd04 	addi	sp,sp,-12
81107688:	de00012e 	bgeu	sp,et,81107690 <uliRmapCh1WriteCmdAddress+0xc>
8110768c:	003b68fa 	trap	3
81107690:	dfc00215 	stw	ra,8(sp)
81107694:	df000115 	stw	fp,4(sp)
81107698:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
8110769c:	01400184 	movi	r5,6
811076a0:	01204834 	movhi	r4,33056
811076a4:	210b0004 	addi	r4,r4,11264
811076a8:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
811076ac:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_1_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);


	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811076b0:	e13fff17 	ldw	r4,-4(fp)
811076b4:	110a1100 	call	8110a110 <uliConvRmapCfgAddr>
811076b8:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811076bc:	e0bfff17 	ldw	r2,-4(fp)
}
811076c0:	e037883a 	mov	sp,fp
811076c4:	dfc00117 	ldw	ra,4(sp)
811076c8:	df000017 	ldw	fp,0(sp)
811076cc:	dec00204 	addi	sp,sp,8
811076d0:	f800283a 	ret

811076d4 <uliRmapCh2WriteCmdAddress>:

alt_u32 uliRmapCh2WriteCmdAddress(void) {
811076d4:	defffd04 	addi	sp,sp,-12
811076d8:	de00012e 	bgeu	sp,et,811076e0 <uliRmapCh2WriteCmdAddress+0xc>
811076dc:	003b68fa 	trap	3
811076e0:	dfc00215 	stw	ra,8(sp)
811076e4:	df000115 	stw	fp,4(sp)
811076e8:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811076ec:	01400184 	movi	r5,6
811076f0:	01204834 	movhi	r4,33056
811076f4:	210a0004 	addi	r4,r4,10240
811076f8:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
811076fc:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_2_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81107700:	e13fff17 	ldw	r4,-4(fp)
81107704:	110a1100 	call	8110a110 <uliConvRmapCfgAddr>
81107708:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
8110770c:	e0bfff17 	ldw	r2,-4(fp)
}
81107710:	e037883a 	mov	sp,fp
81107714:	dfc00117 	ldw	ra,4(sp)
81107718:	df000017 	ldw	fp,0(sp)
8110771c:	dec00204 	addi	sp,sp,8
81107720:	f800283a 	ret

81107724 <uliRmapCh3WriteCmdAddress>:

alt_u32 uliRmapCh3WriteCmdAddress(void) {
81107724:	defffd04 	addi	sp,sp,-12
81107728:	de00012e 	bgeu	sp,et,81107730 <uliRmapCh3WriteCmdAddress+0xc>
8110772c:	003b68fa 	trap	3
81107730:	dfc00215 	stw	ra,8(sp)
81107734:	df000115 	stw	fp,4(sp)
81107738:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
8110773c:	01400184 	movi	r5,6
81107740:	01204834 	movhi	r4,33056
81107744:	210b0004 	addi	r4,r4,11264
81107748:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
8110774c:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_3_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81107750:	e13fff17 	ldw	r4,-4(fp)
81107754:	110a1100 	call	8110a110 <uliConvRmapCfgAddr>
81107758:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
8110775c:	e0bfff17 	ldw	r2,-4(fp)
}
81107760:	e037883a 	mov	sp,fp
81107764:	dfc00117 	ldw	ra,4(sp)
81107768:	df000017 	ldw	fp,0(sp)
8110776c:	dec00204 	addi	sp,sp,8
81107770:	f800283a 	ret

81107774 <uliRmapCh4WriteCmdAddress>:

alt_u32 uliRmapCh4WriteCmdAddress(void) {
81107774:	defffd04 	addi	sp,sp,-12
81107778:	de00012e 	bgeu	sp,et,81107780 <uliRmapCh4WriteCmdAddress+0xc>
8110777c:	003b68fa 	trap	3
81107780:	dfc00215 	stw	ra,8(sp)
81107784:	df000115 	stw	fp,4(sp)
81107788:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
8110778c:	01400184 	movi	r5,6
81107790:	01204834 	movhi	r4,33056
81107794:	210a0004 	addi	r4,r4,10240
81107798:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
8110779c:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_4_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811077a0:	e13fff17 	ldw	r4,-4(fp)
811077a4:	110a1100 	call	8110a110 <uliConvRmapCfgAddr>
811077a8:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811077ac:	e0bfff17 	ldw	r2,-4(fp)
}
811077b0:	e037883a 	mov	sp,fp
811077b4:	dfc00117 	ldw	ra,4(sp)
811077b8:	df000017 	ldw	fp,0(sp)
811077bc:	dec00204 	addi	sp,sp,8
811077c0:	f800283a 	ret

811077c4 <uliRmapCh5WriteCmdAddress>:

alt_u32 uliRmapCh5WriteCmdAddress(void) {
811077c4:	defffd04 	addi	sp,sp,-12
811077c8:	de00012e 	bgeu	sp,et,811077d0 <uliRmapCh5WriteCmdAddress+0xc>
811077cc:	003b68fa 	trap	3
811077d0:	dfc00215 	stw	ra,8(sp)
811077d4:	df000115 	stw	fp,4(sp)
811077d8:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811077dc:	01400184 	movi	r5,6
811077e0:	01204834 	movhi	r4,33056
811077e4:	210b0004 	addi	r4,r4,11264
811077e8:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
811077ec:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_5_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811077f0:	e13fff17 	ldw	r4,-4(fp)
811077f4:	110a1100 	call	8110a110 <uliConvRmapCfgAddr>
811077f8:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811077fc:	e0bfff17 	ldw	r2,-4(fp)
}
81107800:	e037883a 	mov	sp,fp
81107804:	dfc00117 	ldw	ra,4(sp)
81107808:	df000017 	ldw	fp,0(sp)
8110780c:	dec00204 	addi	sp,sp,8
81107810:	f800283a 	ret

81107814 <uliRmapCh6WriteCmdAddress>:

alt_u32 uliRmapCh6WriteCmdAddress(void) {
81107814:	defffd04 	addi	sp,sp,-12
81107818:	de00012e 	bgeu	sp,et,81107820 <uliRmapCh6WriteCmdAddress+0xc>
8110781c:	003b68fa 	trap	3
81107820:	dfc00215 	stw	ra,8(sp)
81107824:	df000115 	stw	fp,4(sp)
81107828:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
8110782c:	01400184 	movi	r5,6
81107830:	01204834 	movhi	r4,33056
81107834:	210a0004 	addi	r4,r4,10240
81107838:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
8110783c:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_6_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81107840:	e13fff17 	ldw	r4,-4(fp)
81107844:	110a1100 	call	8110a110 <uliConvRmapCfgAddr>
81107848:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
8110784c:	e0bfff17 	ldw	r2,-4(fp)
}
81107850:	e037883a 	mov	sp,fp
81107854:	dfc00117 	ldw	ra,4(sp)
81107858:	df000017 	ldw	fp,0(sp)
8110785c:	dec00204 	addi	sp,sp,8
81107860:	f800283a 	ret

81107864 <uliRmapCh7WriteCmdAddress>:

alt_u32 uliRmapCh7WriteCmdAddress(void) {
81107864:	defffd04 	addi	sp,sp,-12
81107868:	de00012e 	bgeu	sp,et,81107870 <uliRmapCh7WriteCmdAddress+0xc>
8110786c:	003b68fa 	trap	3
81107870:	dfc00215 	stw	ra,8(sp)
81107874:	df000115 	stw	fp,4(sp)
81107878:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
8110787c:	01400184 	movi	r5,6
81107880:	01204834 	movhi	r4,33056
81107884:	210b0004 	addi	r4,r4,11264
81107888:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
8110788c:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_7_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81107890:	e13fff17 	ldw	r4,-4(fp)
81107894:	110a1100 	call	8110a110 <uliConvRmapCfgAddr>
81107898:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
8110789c:	e0bfff17 	ldw	r2,-4(fp)
}
811078a0:	e037883a 	mov	sp,fp
811078a4:	dfc00117 	ldw	ra,4(sp)
811078a8:	df000017 	ldw	fp,0(sp)
811078ac:	dec00204 	addi	sp,sp,8
811078b0:	f800283a 	ret

811078b4 <uliRmapCh8WriteCmdAddress>:

alt_u32 uliRmapCh8WriteCmdAddress(void) {
811078b4:	defffd04 	addi	sp,sp,-12
811078b8:	de00012e 	bgeu	sp,et,811078c0 <uliRmapCh8WriteCmdAddress+0xc>
811078bc:	003b68fa 	trap	3
811078c0:	dfc00215 	stw	ra,8(sp)
811078c4:	df000115 	stw	fp,4(sp)
811078c8:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811078cc:	01400184 	movi	r5,6
811078d0:	01204834 	movhi	r4,33056
811078d4:	210a0004 	addi	r4,r4,10240
811078d8:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
811078dc:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_8_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811078e0:	e13fff17 	ldw	r4,-4(fp)
811078e4:	110a1100 	call	8110a110 <uliConvRmapCfgAddr>
811078e8:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811078ec:	e0bfff17 	ldw	r2,-4(fp)
}
811078f0:	e037883a 	mov	sp,fp
811078f4:	dfc00117 	ldw	ra,4(sp)
811078f8:	df000017 	ldw	fp,0(sp)
811078fc:	dec00204 	addi	sp,sp,8
81107900:	f800283a 	ret

81107904 <vRmapInitIrq>:

void vRmapInitIrq(alt_u8 ucCommCh) {
81107904:	defffc04 	addi	sp,sp,-16
81107908:	de00012e 	bgeu	sp,et,81107910 <vRmapInitIrq+0xc>
8110790c:	003b68fa 	trap	3
81107910:	dfc00315 	stw	ra,12(sp)
81107914:	df000215 	stw	fp,8(sp)
81107918:	df000204 	addi	fp,sp,8
8110791c:	2005883a 	mov	r2,r4
81107920:	e0bfff05 	stb	r2,-4(fp)
	void* pvHoldContext;
	switch (ucCommCh) {
81107924:	e0bfff03 	ldbu	r2,-4(fp)
81107928:	10c00228 	cmpgeui	r3,r2,8
8110792c:	18004e1e 	bne	r3,zero,81107a68 <vRmapInitIrq+0x164>
81107930:	100690ba 	slli	r3,r2,2
81107934:	00a04434 	movhi	r2,33040
81107938:	109e5204 	addi	r2,r2,31048
8110793c:	1885883a 	add	r2,r3,r2
81107940:	10800017 	ldw	r2,0(r2)
81107944:	1000683a 	jmp	r2
81107948:	81107968 	cmpgeui	r4,r16,16869
8110794c:	81107988 	cmpgei	r4,r16,16870
81107950:	811079a8 	cmpgeui	r4,r16,16870
81107954:	811079c8 	cmpgei	r4,r16,16871
81107958:	811079e8 	cmpgeui	r4,r16,16871
8110795c:	81107a08 	cmpgei	r4,r16,16872
81107960:	81107a28 	cmpgeui	r4,r16,16872
81107964:	81107a48 	cmpgei	r4,r16,16873
	case eCommSpwCh1:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh1HoldContext;
81107968:	d0a04804 	addi	r2,gp,-32480
8110796c:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_1_RMAP_IRQ, pvHoldContext, vRmapCh1HandleIrq);
81107970:	01a04434 	movhi	r6,33040
81107974:	319bae04 	addi	r6,r6,28344
81107978:	e17ffe17 	ldw	r5,-8(fp)
8110797c:	010005c4 	movi	r4,23
81107980:	11366440 	call	81136644 <alt_irq_register>
		break;
81107984:	00003806 	br	81107a68 <vRmapInitIrq+0x164>
	case eCommSpwCh2:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh2HoldContext;
81107988:	d0a04904 	addi	r2,gp,-32476
8110798c:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_2_RMAP_IRQ, pvHoldContext, vRmapCh2HandleIrq);
81107990:	01a04434 	movhi	r6,33040
81107994:	319bdf04 	addi	r6,r6,28540
81107998:	e17ffe17 	ldw	r5,-8(fp)
8110799c:	01000544 	movi	r4,21
811079a0:	11366440 	call	81136644 <alt_irq_register>
		break;
811079a4:	00003006 	br	81107a68 <vRmapInitIrq+0x164>
	case eCommSpwCh3:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh3HoldContext;
811079a8:	d0a04a04 	addi	r2,gp,-32472
811079ac:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_3_RMAP_IRQ, pvHoldContext, vRmapCh3HandleIrq);
811079b0:	01a04434 	movhi	r6,33040
811079b4:	319c0904 	addi	r6,r6,28708
811079b8:	e17ffe17 	ldw	r5,-8(fp)
811079bc:	010004c4 	movi	r4,19
811079c0:	11366440 	call	81136644 <alt_irq_register>
		break;
811079c4:	00002806 	br	81107a68 <vRmapInitIrq+0x164>
	case eCommSpwCh4:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh4HoldContext;
811079c8:	d0a04b04 	addi	r2,gp,-32468
811079cc:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_4_RMAP_IRQ, pvHoldContext, vRmapCh4HandleIrq);
811079d0:	01a04434 	movhi	r6,33040
811079d4:	319c1904 	addi	r6,r6,28772
811079d8:	e17ffe17 	ldw	r5,-8(fp)
811079dc:	01000444 	movi	r4,17
811079e0:	11366440 	call	81136644 <alt_irq_register>
		break;
811079e4:	00002006 	br	81107a68 <vRmapInitIrq+0x164>
	case eCommSpwCh5:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh5HoldContext;
811079e8:	d0a04c04 	addi	r2,gp,-32464
811079ec:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_5_RMAP_IRQ, pvHoldContext, vRmapCh5HandleIrq);
811079f0:	01a04434 	movhi	r6,33040
811079f4:	319c2904 	addi	r6,r6,28836
811079f8:	e17ffe17 	ldw	r5,-8(fp)
811079fc:	01000244 	movi	r4,9
81107a00:	11366440 	call	81136644 <alt_irq_register>
		break;
81107a04:	00001806 	br	81107a68 <vRmapInitIrq+0x164>
	case eCommSpwCh6:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh6HoldContext;
81107a08:	d0a04d04 	addi	r2,gp,-32460
81107a0c:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_6_RMAP_IRQ, pvHoldContext, vRmapCh6HandleIrq);
81107a10:	01a04434 	movhi	r6,33040
81107a14:	319c3904 	addi	r6,r6,28900
81107a18:	e17ffe17 	ldw	r5,-8(fp)
81107a1c:	010001c4 	movi	r4,7
81107a20:	11366440 	call	81136644 <alt_irq_register>
		break;
81107a24:	00001006 	br	81107a68 <vRmapInitIrq+0x164>
	case eCommSpwCh7:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh7HoldContext;
81107a28:	d0a04e04 	addi	r2,gp,-32456
81107a2c:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_7_RMAP_IRQ, pvHoldContext, vRmapCh7HandleIrq);
81107a30:	01a04434 	movhi	r6,33040
81107a34:	319c4904 	addi	r6,r6,28964
81107a38:	e17ffe17 	ldw	r5,-8(fp)
81107a3c:	01000104 	movi	r4,4
81107a40:	11366440 	call	81136644 <alt_irq_register>
		break;
81107a44:	00000806 	br	81107a68 <vRmapInitIrq+0x164>
	case eCommSpwCh8:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh8HoldContext;
81107a48:	d0a04f04 	addi	r2,gp,-32452
81107a4c:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_8_RMAP_IRQ, pvHoldContext, vRmapCh8HandleIrq);
81107a50:	01a04434 	movhi	r6,33040
81107a54:	319c5904 	addi	r6,r6,29028
81107a58:	e17ffe17 	ldw	r5,-8(fp)
81107a5c:	010000c4 	movi	r4,3
81107a60:	11366440 	call	81136644 <alt_irq_register>
		break;
81107a64:	0001883a 	nop
	}
}
81107a68:	0001883a 	nop
81107a6c:	e037883a 	mov	sp,fp
81107a70:	dfc00117 	ldw	ra,4(sp)
81107a74:	df000017 	ldw	fp,0(sp)
81107a78:	dec00204 	addi	sp,sp,8
81107a7c:	f800283a 	ret

81107a80 <bRmapSetIrqControl>:

bool bRmapSetIrqControl(TRmapChannel *pxRmapCh) {
81107a80:	defffb04 	addi	sp,sp,-20
81107a84:	de00012e 	bgeu	sp,et,81107a8c <bRmapSetIrqControl+0xc>
81107a88:	003b68fa 	trap	3
81107a8c:	dfc00415 	stw	ra,16(sp)
81107a90:	df000315 	stw	fp,12(sp)
81107a94:	df000304 	addi	fp,sp,12
81107a98:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107a9c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107aa0:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107aa4:	e0bfff17 	ldw	r2,-4(fp)
81107aa8:	10001926 	beq	r2,zero,81107b10 <bRmapSetIrqControl+0x90>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107aac:	e0bfff17 	ldw	r2,-4(fp)
81107ab0:	10800017 	ldw	r2,0(r2)
81107ab4:	01400444 	movi	r5,17
81107ab8:	1009883a 	mov	r4,r2
81107abc:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81107ac0:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (pxRmapCh->xRmapIrqControl.bWriteCmdEn) {
81107ac4:	e0bfff17 	ldw	r2,-4(fp)
81107ac8:	10801017 	ldw	r2,64(r2)
81107acc:	10000426 	beq	r2,zero,81107ae0 <bRmapSetIrqControl+0x60>
			uliReg |= COMM_IRQ_RMAP_WRCMD_EN_MSK;
81107ad0:	e0bffe17 	ldw	r2,-8(fp)
81107ad4:	10800054 	ori	r2,r2,1
81107ad8:	e0bffe15 	stw	r2,-8(fp)
81107adc:	00000406 	br	81107af0 <bRmapSetIrqControl+0x70>
		} else {
			uliReg &= (~COMM_IRQ_RMAP_WRCMD_EN_MSK);
81107ae0:	e0fffe17 	ldw	r3,-8(fp)
81107ae4:	00bfff84 	movi	r2,-2
81107ae8:	1884703a 	and	r2,r3,r2
81107aec:	e0bffe15 	stw	r2,-8(fp)
		}

		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_IRQ_CONTROL_REG_OFST,
81107af0:	e0bfff17 	ldw	r2,-4(fp)
81107af4:	10800017 	ldw	r2,0(r2)
81107af8:	e1bffe17 	ldw	r6,-8(fp)
81107afc:	01400444 	movi	r5,17
81107b00:	1009883a 	mov	r4,r2
81107b04:	110a06c0 	call	8110a06c <vRmapWriteReg>
				uliReg);
		bStatus = TRUE;
81107b08:	00800044 	movi	r2,1
81107b0c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107b10:	e0bffd17 	ldw	r2,-12(fp)
}
81107b14:	e037883a 	mov	sp,fp
81107b18:	dfc00117 	ldw	ra,4(sp)
81107b1c:	df000017 	ldw	fp,0(sp)
81107b20:	dec00204 	addi	sp,sp,8
81107b24:	f800283a 	ret

81107b28 <bRmapGetIrqControl>:

bool bRmapGetIrqControl(TRmapChannel *pxRmapCh) {
81107b28:	defffb04 	addi	sp,sp,-20
81107b2c:	de00012e 	bgeu	sp,et,81107b34 <bRmapGetIrqControl+0xc>
81107b30:	003b68fa 	trap	3
81107b34:	dfc00415 	stw	ra,16(sp)
81107b38:	df000315 	stw	fp,12(sp)
81107b3c:	df000304 	addi	fp,sp,12
81107b40:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107b44:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107b48:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107b4c:	e0bfff17 	ldw	r2,-4(fp)
81107b50:	10001126 	beq	r2,zero,81107b98 <bRmapGetIrqControl+0x70>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107b54:	e0bfff17 	ldw	r2,-4(fp)
81107b58:	10800017 	ldw	r2,0(r2)
81107b5c:	01400444 	movi	r5,17
81107b60:	1009883a 	mov	r4,r2
81107b64:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81107b68:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (uliReg & COMM_IRQ_RMAP_WRCMD_EN_MSK) {
81107b6c:	e0bffe17 	ldw	r2,-8(fp)
81107b70:	1080004c 	andi	r2,r2,1
81107b74:	10000426 	beq	r2,zero,81107b88 <bRmapGetIrqControl+0x60>
			pxRmapCh->xRmapIrqControl.bWriteCmdEn = TRUE;
81107b78:	e0bfff17 	ldw	r2,-4(fp)
81107b7c:	00c00044 	movi	r3,1
81107b80:	10c01015 	stw	r3,64(r2)
81107b84:	00000206 	br	81107b90 <bRmapGetIrqControl+0x68>
		} else {
			pxRmapCh->xRmapIrqControl.bWriteCmdEn = FALSE;
81107b88:	e0bfff17 	ldw	r2,-4(fp)
81107b8c:	10001015 	stw	zero,64(r2)
		}

		bStatus = TRUE;
81107b90:	00800044 	movi	r2,1
81107b94:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107b98:	e0bffd17 	ldw	r2,-12(fp)
}
81107b9c:	e037883a 	mov	sp,fp
81107ba0:	dfc00117 	ldw	ra,4(sp)
81107ba4:	df000017 	ldw	fp,0(sp)
81107ba8:	dec00204 	addi	sp,sp,8
81107bac:	f800283a 	ret

81107bb0 <bRmapGetIrqFlags>:

bool bRmapGetIrqFlags(TRmapChannel *pxRmapCh) {
81107bb0:	defffb04 	addi	sp,sp,-20
81107bb4:	de00012e 	bgeu	sp,et,81107bbc <bRmapGetIrqFlags+0xc>
81107bb8:	003b68fa 	trap	3
81107bbc:	dfc00415 	stw	ra,16(sp)
81107bc0:	df000315 	stw	fp,12(sp)
81107bc4:	df000304 	addi	fp,sp,12
81107bc8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107bcc:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107bd0:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107bd4:	e0bfff17 	ldw	r2,-4(fp)
81107bd8:	10001126 	beq	r2,zero,81107c20 <bRmapGetIrqFlags+0x70>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107bdc:	e0bfff17 	ldw	r2,-4(fp)
81107be0:	10800017 	ldw	r2,0(r2)
81107be4:	01400484 	movi	r5,18
81107be8:	1009883a 	mov	r4,r2
81107bec:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81107bf0:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_FLAGS_REG_OFST);

		if (uliReg & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107bf4:	e0bffe17 	ldw	r2,-8(fp)
81107bf8:	1080004c 	andi	r2,r2,1
81107bfc:	10000426 	beq	r2,zero,81107c10 <bRmapGetIrqFlags+0x60>
			pxRmapCh->xRmapIrqFlag.bWriteCmdFlag = TRUE;
81107c00:	e0bfff17 	ldw	r2,-4(fp)
81107c04:	00c00044 	movi	r3,1
81107c08:	10c01115 	stw	r3,68(r2)
81107c0c:	00000206 	br	81107c18 <bRmapGetIrqFlags+0x68>
		} else {
			pxRmapCh->xRmapIrqFlag.bWriteCmdFlag = FALSE;
81107c10:	e0bfff17 	ldw	r2,-4(fp)
81107c14:	10001115 	stw	zero,68(r2)
		}

		bStatus = TRUE;
81107c18:	00800044 	movi	r2,1
81107c1c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107c20:	e0bffd17 	ldw	r2,-12(fp)
}
81107c24:	e037883a 	mov	sp,fp
81107c28:	dfc00117 	ldw	ra,4(sp)
81107c2c:	df000017 	ldw	fp,0(sp)
81107c30:	dec00204 	addi	sp,sp,8
81107c34:	f800283a 	ret

81107c38 <bRmapSetCodecConfig>:

bool bRmapSetCodecConfig(TRmapChannel *pxRmapCh) {
81107c38:	defffb04 	addi	sp,sp,-20
81107c3c:	de00012e 	bgeu	sp,et,81107c44 <bRmapSetCodecConfig+0xc>
81107c40:	003b68fa 	trap	3
81107c44:	dfc00415 	stw	ra,16(sp)
81107c48:	df000315 	stw	fp,12(sp)
81107c4c:	df000304 	addi	fp,sp,12
81107c50:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107c54:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107c58:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107c5c:	e0bfff17 	ldw	r2,-4(fp)
81107c60:	10002526 	beq	r2,zero,81107cf8 <bRmapSetCodecConfig+0xc0>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107c64:	e0bfff17 	ldw	r2,-4(fp)
81107c68:	10800017 	ldw	r2,0(r2)
81107c6c:	01400104 	movi	r5,4
81107c70:	1009883a 	mov	r4,r2
81107c74:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81107c78:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_CFG_REG_OFST);

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
81107c7c:	e0fffe17 	ldw	r3,-8(fp)
81107c80:	00bfc004 	movi	r2,-256
81107c84:	1884703a 	and	r2,r3,r2
81107c88:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
81107c8c:	e0bfff17 	ldw	r2,-4(fp)
81107c90:	10800143 	ldbu	r2,5(r2)
81107c94:	10803fcc 	andi	r2,r2,255

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_CODEC_CFG_REG_OFST);

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
81107c98:	e0fffe17 	ldw	r3,-8(fp)
81107c9c:	1884b03a 	or	r2,r3,r2
81107ca0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
		uliReg &= (~COMM_RMAP_TARGET_KEY_MSK);
81107ca4:	e0fffe17 	ldw	r3,-8(fp)
81107ca8:	00bffff4 	movhi	r2,65535
81107cac:	10803fc4 	addi	r2,r2,255
81107cb0:	1884703a 	and	r2,r3,r2
81107cb4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_TARGET_KEY_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucKey << 8));
81107cb8:	e0bfff17 	ldw	r2,-4(fp)
81107cbc:	10800103 	ldbu	r2,4(r2)
81107cc0:	10803fcc 	andi	r2,r2,255
81107cc4:	1004923a 	slli	r2,r2,8
81107cc8:	10bfffcc 	andi	r2,r2,65535

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
		uliReg &= (~COMM_RMAP_TARGET_KEY_MSK);
		uliReg |= (COMM_RMAP_TARGET_KEY_MSK
81107ccc:	e0fffe17 	ldw	r3,-8(fp)
81107cd0:	1884b03a 	or	r2,r3,r2
81107cd4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucKey << 8));

		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CODEC_CFG_REG_OFST,
81107cd8:	e0bfff17 	ldw	r2,-4(fp)
81107cdc:	10800017 	ldw	r2,0(r2)
81107ce0:	e1bffe17 	ldw	r6,-8(fp)
81107ce4:	01400104 	movi	r5,4
81107ce8:	1009883a 	mov	r4,r2
81107cec:	110a06c0 	call	8110a06c <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
81107cf0:	00800044 	movi	r2,1
81107cf4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107cf8:	e0bffd17 	ldw	r2,-12(fp)
}
81107cfc:	e037883a 	mov	sp,fp
81107d00:	dfc00117 	ldw	ra,4(sp)
81107d04:	df000017 	ldw	fp,0(sp)
81107d08:	dec00204 	addi	sp,sp,8
81107d0c:	f800283a 	ret

81107d10 <bRmapGetCodecConfig>:

bool bRmapGetCodecConfig(TRmapChannel *pxRmapCh) {
81107d10:	defffb04 	addi	sp,sp,-20
81107d14:	de00012e 	bgeu	sp,et,81107d1c <bRmapGetCodecConfig+0xc>
81107d18:	003b68fa 	trap	3
81107d1c:	dfc00415 	stw	ra,16(sp)
81107d20:	df000315 	stw	fp,12(sp)
81107d24:	df000304 	addi	fp,sp,12
81107d28:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107d2c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107d30:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107d34:	e0bfff17 	ldw	r2,-4(fp)
81107d38:	10001226 	beq	r2,zero,81107d84 <bRmapGetCodecConfig+0x74>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107d3c:	e0bfff17 	ldw	r2,-4(fp)
81107d40:	10800017 	ldw	r2,0(r2)
81107d44:	01400104 	movi	r5,4
81107d48:	1009883a 	mov	r4,r2
81107d4c:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81107d50:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_CFG_REG_OFST);

		pxRmapCh->xRmapCodecConfig.ucLogicalAddress = (alt_u8) ((uliReg
81107d54:	e0bffe17 	ldw	r2,-8(fp)
81107d58:	1007883a 	mov	r3,r2
81107d5c:	e0bfff17 	ldw	r2,-4(fp)
81107d60:	10c00145 	stb	r3,5(r2)
				& COMM_RMAP_TARGET_LOG_ADDR_MSK) >> 0);
		pxRmapCh->xRmapCodecConfig.ucKey = (alt_u8) ((uliReg
				& COMM_RMAP_TARGET_KEY_MSK) >> 8);
81107d64:	e0bffe17 	ldw	r2,-8(fp)
81107d68:	10bfc00c 	andi	r2,r2,65280
81107d6c:	1004d23a 	srli	r2,r2,8
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_CODEC_CFG_REG_OFST);

		pxRmapCh->xRmapCodecConfig.ucLogicalAddress = (alt_u8) ((uliReg
				& COMM_RMAP_TARGET_LOG_ADDR_MSK) >> 0);
		pxRmapCh->xRmapCodecConfig.ucKey = (alt_u8) ((uliReg
81107d70:	1007883a 	mov	r3,r2
81107d74:	e0bfff17 	ldw	r2,-4(fp)
81107d78:	10c00105 	stb	r3,4(r2)
				& COMM_RMAP_TARGET_KEY_MSK) >> 8);

		bStatus = TRUE;
81107d7c:	00800044 	movi	r2,1
81107d80:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107d84:	e0bffd17 	ldw	r2,-12(fp)
}
81107d88:	e037883a 	mov	sp,fp
81107d8c:	dfc00117 	ldw	ra,4(sp)
81107d90:	df000017 	ldw	fp,0(sp)
81107d94:	dec00204 	addi	sp,sp,8
81107d98:	f800283a 	ret

81107d9c <bRmapGetCodecStatus>:

bool bRmapGetCodecStatus(TRmapChannel *pxRmapCh) {
81107d9c:	defffb04 	addi	sp,sp,-20
81107da0:	de00012e 	bgeu	sp,et,81107da8 <bRmapGetCodecStatus+0xc>
81107da4:	003b68fa 	trap	3
81107da8:	dfc00415 	stw	ra,16(sp)
81107dac:	df000315 	stw	fp,12(sp)
81107db0:	df000304 	addi	fp,sp,12
81107db4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107db8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107dbc:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107dc0:	e0bfff17 	ldw	r2,-4(fp)
81107dc4:	10004726 	beq	r2,zero,81107ee4 <bRmapGetCodecStatus+0x148>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107dc8:	e0bfff17 	ldw	r2,-4(fp)
81107dcc:	10800017 	ldw	r2,0(r2)
81107dd0:	01400144 	movi	r5,5
81107dd4:	1009883a 	mov	r4,r2
81107dd8:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81107ddc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_STAT_REG_OFST);

		if (uliReg & COMM_RMAP_STAT_CMD_RECEIVED_MSK) {
81107de0:	e0bffe17 	ldw	r2,-8(fp)
81107de4:	1080004c 	andi	r2,r2,1
81107de8:	10000426 	beq	r2,zero,81107dfc <bRmapGetCodecStatus+0x60>
			pxRmapCh->xRmapCodecStatus.bCommandReceived = TRUE;
81107dec:	e0bfff17 	ldw	r2,-4(fp)
81107df0:	00c00044 	movi	r3,1
81107df4:	10c00215 	stw	r3,8(r2)
81107df8:	00000206 	br	81107e04 <bRmapGetCodecStatus+0x68>
		} else {
			pxRmapCh->xRmapCodecStatus.bCommandReceived = FALSE;
81107dfc:	e0bfff17 	ldw	r2,-4(fp)
81107e00:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_RMAP_STAT_WR_REQ_MSK) {
81107e04:	e0bffe17 	ldw	r2,-8(fp)
81107e08:	1080008c 	andi	r2,r2,2
81107e0c:	10000426 	beq	r2,zero,81107e20 <bRmapGetCodecStatus+0x84>
			pxRmapCh->xRmapCodecStatus.bWriteRequested = TRUE;
81107e10:	e0bfff17 	ldw	r2,-4(fp)
81107e14:	00c00044 	movi	r3,1
81107e18:	10c00315 	stw	r3,12(r2)
81107e1c:	00000206 	br	81107e28 <bRmapGetCodecStatus+0x8c>
		} else {
			pxRmapCh->xRmapCodecStatus.bWriteRequested = FALSE;
81107e20:	e0bfff17 	ldw	r2,-4(fp)
81107e24:	10000315 	stw	zero,12(r2)
		}
		if (uliReg & COMM_RMAP_STAT_WR_AUTH_MSK) {
81107e28:	e0bffe17 	ldw	r2,-8(fp)
81107e2c:	1080010c 	andi	r2,r2,4
81107e30:	10000426 	beq	r2,zero,81107e44 <bRmapGetCodecStatus+0xa8>
			pxRmapCh->xRmapCodecStatus.bWriteAuthorized = TRUE;
81107e34:	e0bfff17 	ldw	r2,-4(fp)
81107e38:	00c00044 	movi	r3,1
81107e3c:	10c00415 	stw	r3,16(r2)
81107e40:	00000206 	br	81107e4c <bRmapGetCodecStatus+0xb0>
		} else {
			pxRmapCh->xRmapCodecStatus.bWriteAuthorized = FALSE;
81107e44:	e0bfff17 	ldw	r2,-4(fp)
81107e48:	10000415 	stw	zero,16(r2)
		}
		if (uliReg & COMM_RMAP_STAT_RD_REQ_MSK) {
81107e4c:	e0bffe17 	ldw	r2,-8(fp)
81107e50:	1080020c 	andi	r2,r2,8
81107e54:	10000426 	beq	r2,zero,81107e68 <bRmapGetCodecStatus+0xcc>
			pxRmapCh->xRmapCodecStatus.bReadRequested = TRUE;
81107e58:	e0bfff17 	ldw	r2,-4(fp)
81107e5c:	00c00044 	movi	r3,1
81107e60:	10c00515 	stw	r3,20(r2)
81107e64:	00000206 	br	81107e70 <bRmapGetCodecStatus+0xd4>
		} else {
			pxRmapCh->xRmapCodecStatus.bReadRequested = FALSE;
81107e68:	e0bfff17 	ldw	r2,-4(fp)
81107e6c:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_RMAP_STAT_RD_AUTH_MSK) {
81107e70:	e0bffe17 	ldw	r2,-8(fp)
81107e74:	1080040c 	andi	r2,r2,16
81107e78:	10000426 	beq	r2,zero,81107e8c <bRmapGetCodecStatus+0xf0>
			pxRmapCh->xRmapCodecStatus.bReadAuthorized = TRUE;
81107e7c:	e0bfff17 	ldw	r2,-4(fp)
81107e80:	00c00044 	movi	r3,1
81107e84:	10c00615 	stw	r3,24(r2)
81107e88:	00000206 	br	81107e94 <bRmapGetCodecStatus+0xf8>
		} else {
			pxRmapCh->xRmapCodecStatus.bReadAuthorized = FALSE;
81107e8c:	e0bfff17 	ldw	r2,-4(fp)
81107e90:	10000615 	stw	zero,24(r2)
		}
		if (uliReg & COMM_RMAP_STAT_REPLY_SEND_MSK) {
81107e94:	e0bffe17 	ldw	r2,-8(fp)
81107e98:	1080080c 	andi	r2,r2,32
81107e9c:	10000426 	beq	r2,zero,81107eb0 <bRmapGetCodecStatus+0x114>
			pxRmapCh->xRmapCodecStatus.bReplySended = TRUE;
81107ea0:	e0bfff17 	ldw	r2,-4(fp)
81107ea4:	00c00044 	movi	r3,1
81107ea8:	10c00715 	stw	r3,28(r2)
81107eac:	00000206 	br	81107eb8 <bRmapGetCodecStatus+0x11c>
		} else {
			pxRmapCh->xRmapCodecStatus.bReplySended = FALSE;
81107eb0:	e0bfff17 	ldw	r2,-4(fp)
81107eb4:	10000715 	stw	zero,28(r2)
		}
		if (uliReg & COMM_RMAP_STAT_DISCARD_PKG_MSK) {
81107eb8:	e0bffe17 	ldw	r2,-8(fp)
81107ebc:	1080100c 	andi	r2,r2,64
81107ec0:	10000426 	beq	r2,zero,81107ed4 <bRmapGetCodecStatus+0x138>
			pxRmapCh->xRmapCodecStatus.bDiscardedPackage = TRUE;
81107ec4:	e0bfff17 	ldw	r2,-4(fp)
81107ec8:	00c00044 	movi	r3,1
81107ecc:	10c00815 	stw	r3,32(r2)
81107ed0:	00000206 	br	81107edc <bRmapGetCodecStatus+0x140>
		} else {
			pxRmapCh->xRmapCodecStatus.bCommandReceived = FALSE;
81107ed4:	e0bfff17 	ldw	r2,-4(fp)
81107ed8:	10000215 	stw	zero,8(r2)
		}

		bStatus = TRUE;
81107edc:	00800044 	movi	r2,1
81107ee0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107ee4:	e0bffd17 	ldw	r2,-12(fp)
}
81107ee8:	e037883a 	mov	sp,fp
81107eec:	dfc00117 	ldw	ra,4(sp)
81107ef0:	df000017 	ldw	fp,0(sp)
81107ef4:	dec00204 	addi	sp,sp,8
81107ef8:	f800283a 	ret

81107efc <bRmapGetCodecError>:

bool bRmapGetCodecError(TRmapChannel *pxRmapCh) {
81107efc:	defffb04 	addi	sp,sp,-20
81107f00:	de00012e 	bgeu	sp,et,81107f08 <bRmapGetCodecError+0xc>
81107f04:	003b68fa 	trap	3
81107f08:	dfc00415 	stw	ra,16(sp)
81107f0c:	df000315 	stw	fp,12(sp)
81107f10:	df000304 	addi	fp,sp,12
81107f14:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107f18:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107f1c:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107f20:	e0bfff17 	ldw	r2,-4(fp)
81107f24:	10004726 	beq	r2,zero,81108044 <bRmapGetCodecError+0x148>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107f28:	e0bfff17 	ldw	r2,-4(fp)
81107f2c:	10800017 	ldw	r2,0(r2)
81107f30:	01400144 	movi	r5,5
81107f34:	1009883a 	mov	r4,r2
81107f38:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81107f3c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_STAT_REG_OFST);

		if (uliReg & COMM_RMAP_ERR_EARLY_EOP_MSK) {
81107f40:	e0bffe17 	ldw	r2,-8(fp)
81107f44:	1080006c 	andhi	r2,r2,1
81107f48:	10000426 	beq	r2,zero,81107f5c <bRmapGetCodecError+0x60>
			pxRmapCh->xRmapCodecError.bEarlyEop = TRUE;
81107f4c:	e0bfff17 	ldw	r2,-4(fp)
81107f50:	00c00044 	movi	r3,1
81107f54:	10c00915 	stw	r3,36(r2)
81107f58:	00000206 	br	81107f64 <bRmapGetCodecError+0x68>
		} else {
			pxRmapCh->xRmapCodecError.bEarlyEop = FALSE;
81107f5c:	e0bfff17 	ldw	r2,-4(fp)
81107f60:	10000915 	stw	zero,36(r2)
		}
		if (uliReg & COMM_RMAP_ERR_EEP_MSK) {
81107f64:	e0bffe17 	ldw	r2,-8(fp)
81107f68:	108000ac 	andhi	r2,r2,2
81107f6c:	10000426 	beq	r2,zero,81107f80 <bRmapGetCodecError+0x84>
			pxRmapCh->xRmapCodecError.bEep = TRUE;
81107f70:	e0bfff17 	ldw	r2,-4(fp)
81107f74:	00c00044 	movi	r3,1
81107f78:	10c00a15 	stw	r3,40(r2)
81107f7c:	00000206 	br	81107f88 <bRmapGetCodecError+0x8c>
		} else {
			pxRmapCh->xRmapCodecError.bEep = FALSE;
81107f80:	e0bfff17 	ldw	r2,-4(fp)
81107f84:	10000a15 	stw	zero,40(r2)
		}
		if (uliReg & COMM_RMAP_ERR_HEADER_CRC_MSK) {
81107f88:	e0bffe17 	ldw	r2,-8(fp)
81107f8c:	1080012c 	andhi	r2,r2,4
81107f90:	10000426 	beq	r2,zero,81107fa4 <bRmapGetCodecError+0xa8>
			pxRmapCh->xRmapCodecError.bHeaderCRC = TRUE;
81107f94:	e0bfff17 	ldw	r2,-4(fp)
81107f98:	00c00044 	movi	r3,1
81107f9c:	10c00b15 	stw	r3,44(r2)
81107fa0:	00000206 	br	81107fac <bRmapGetCodecError+0xb0>
		} else {
			pxRmapCh->xRmapCodecError.bHeaderCRC = FALSE;
81107fa4:	e0bfff17 	ldw	r2,-4(fp)
81107fa8:	10000b15 	stw	zero,44(r2)
		}
		if (uliReg & COMM_RMAP_ERR_UNUSED_PKT_MSK) {
81107fac:	e0bffe17 	ldw	r2,-8(fp)
81107fb0:	1080022c 	andhi	r2,r2,8
81107fb4:	10000426 	beq	r2,zero,81107fc8 <bRmapGetCodecError+0xcc>
			pxRmapCh->xRmapCodecError.bUnusedPacketType = TRUE;
81107fb8:	e0bfff17 	ldw	r2,-4(fp)
81107fbc:	00c00044 	movi	r3,1
81107fc0:	10c00c15 	stw	r3,48(r2)
81107fc4:	00000206 	br	81107fd0 <bRmapGetCodecError+0xd4>
		} else {
			pxRmapCh->xRmapCodecError.bUnusedPacketType = FALSE;
81107fc8:	e0bfff17 	ldw	r2,-4(fp)
81107fcc:	10000c15 	stw	zero,48(r2)
		}
		if (uliReg & COMM_RMAP_ERR_INVALID_CMD_MSK) {
81107fd0:	e0bffe17 	ldw	r2,-8(fp)
81107fd4:	1080042c 	andhi	r2,r2,16
81107fd8:	10000426 	beq	r2,zero,81107fec <bRmapGetCodecError+0xf0>
			pxRmapCh->xRmapCodecError.bInvalidCommandCode = TRUE;
81107fdc:	e0bfff17 	ldw	r2,-4(fp)
81107fe0:	00c00044 	movi	r3,1
81107fe4:	10c00d15 	stw	r3,52(r2)
81107fe8:	00000206 	br	81107ff4 <bRmapGetCodecError+0xf8>
		} else {
			pxRmapCh->xRmapCodecError.bInvalidCommandCode = FALSE;
81107fec:	e0bfff17 	ldw	r2,-4(fp)
81107ff0:	10000d15 	stw	zero,52(r2)
		}
		if (uliReg & COMM_RMAP_ERR_TOO_MUCH_DATA_MSK) {
81107ff4:	e0bffe17 	ldw	r2,-8(fp)
81107ff8:	1080082c 	andhi	r2,r2,32
81107ffc:	10000426 	beq	r2,zero,81108010 <bRmapGetCodecError+0x114>
			pxRmapCh->xRmapCodecError.bTooMuchData = TRUE;
81108000:	e0bfff17 	ldw	r2,-4(fp)
81108004:	00c00044 	movi	r3,1
81108008:	10c00e15 	stw	r3,56(r2)
8110800c:	00000206 	br	81108018 <bRmapGetCodecError+0x11c>
		} else {
			pxRmapCh->xRmapCodecError.bTooMuchData = FALSE;
81108010:	e0bfff17 	ldw	r2,-4(fp)
81108014:	10000e15 	stw	zero,56(r2)
		}
		if (uliReg & COMM_RMAP_ERR_INVALID_DCRC_MSK) {
81108018:	e0bffe17 	ldw	r2,-8(fp)
8110801c:	1080102c 	andhi	r2,r2,64
81108020:	10000426 	beq	r2,zero,81108034 <bRmapGetCodecError+0x138>
			pxRmapCh->xRmapCodecError.bInvalidDataCrc = TRUE;
81108024:	e0bfff17 	ldw	r2,-4(fp)
81108028:	00c00044 	movi	r3,1
8110802c:	10c00f15 	stw	r3,60(r2)
81108030:	00000206 	br	8110803c <bRmapGetCodecError+0x140>
		} else {
			pxRmapCh->xRmapCodecError.bInvalidDataCrc = FALSE;
81108034:	e0bfff17 	ldw	r2,-4(fp)
81108038:	10000f15 	stw	zero,60(r2)
		}

		bStatus = TRUE;
8110803c:	00800044 	movi	r2,1
81108040:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81108044:	e0bffd17 	ldw	r2,-12(fp)
}
81108048:	e037883a 	mov	sp,fp
8110804c:	dfc00117 	ldw	ra,4(sp)
81108050:	df000017 	ldw	fp,0(sp)
81108054:	dec00204 	addi	sp,sp,8
81108058:	f800283a 	ret

8110805c <bRmapSetMemConfigArea>:

bool bRmapSetMemConfigArea(TRmapChannel *pxRmapCh) {
8110805c:	defffb04 	addi	sp,sp,-20
81108060:	de00012e 	bgeu	sp,et,81108068 <bRmapSetMemConfigArea+0xc>
81108064:	003b68fa 	trap	3
81108068:	dfc00415 	stw	ra,16(sp)
8110806c:	df000315 	stw	fp,12(sp)
81108070:	df000304 	addi	fp,sp,12
81108074:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81108078:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110807c:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81108080:	e0bfff17 	ldw	r2,-4(fp)
81108084:	1000aa26 	beq	r2,zero,81108330 <bRmapSetMemConfigArea+0x2d4>

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config;
81108088:	e0bfff17 	ldw	r2,-4(fp)
8110808c:	10801217 	ldw	r2,72(r2)
81108090:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_REGCLK_DIR_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 3));
//			uliReg &= (~COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK);
//			uliReg |= (COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 4));
//			uliReg &= (~COMM_RMAP_REGCLK_TRCNT_CTRL_MSK);
//			uliReg |= (COMM_RMAP_REGCLK_TRCNT_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 20));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81108094:	e0bfff17 	ldw	r2,-4(fp)
81108098:	10800017 	ldw	r2,0(r2)
8110809c:	e1bffe17 	ldw	r6,-8(fp)
811080a0:	01401004 	movi	r5,64
811080a4:	1009883a 	mov	r4,r2
811080a8:	110a06c0 	call	8110a06c <vRmapWriteReg>
		COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config;
811080ac:	e0bfff17 	ldw	r2,-4(fp)
811080b0:	10801317 	ldw	r2,76(r2)
811080b4:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_SL_RDOUT_PAUSE_CNT_MSK);
//			uliReg |= (COMM_RMAP_SL_RDOUT_PAUSE_CNT_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
811080b8:	e0bfff17 	ldw	r2,-4(fp)
811080bc:	10800017 	ldw	r2,0(r2)
811080c0:	e1bffe17 	ldw	r6,-8(fp)
811080c4:	01401044 	movi	r5,65
811080c8:	1009883a 	mov	r4,r2
811080cc:	110a06c0 	call	8110a06c <vRmapWriteReg>
		COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SPW_PKT_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config;
811080d0:	e0bfff17 	ldw	r2,-4(fp)
811080d4:	10801417 	ldw	r2,80(r2)
811080d8:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_DIGITISE_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
//			uliReg &= (~COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK);
//			uliReg |= (COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
//			uliReg &= (~COMM_RMAP_PACKET_SIZE_CTRL_MSK);
//			uliReg |= (COMM_RMAP_PACKET_SIZE_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
811080dc:	e0bfff17 	ldw	r2,-4(fp)
811080e0:	10800017 	ldw	r2,0(r2)
811080e4:	e1bffe17 	ldw	r6,-8(fp)
811080e8:	01401084 	movi	r5,66
811080ec:	1009883a 	mov	r4,r2
811080f0:	110a06c0 	call	8110a06c <vRmapWriteReg>
		COMM_RMAP_SPW_PKT_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SPW_PKT_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSpwPacket2Config;
811080f4:	e0bfff17 	ldw	r2,-4(fp)
811080f8:	10801517 	ldw	r2,84(r2)
811080fc:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81108100:	e0bfff17 	ldw	r2,-4(fp)
81108104:	10800017 	ldw	r2,0(r2)
81108108:	e1bffe17 	ldw	r6,-8(fp)
8110810c:	014010c4 	movi	r5,67
81108110:	1009883a 	mov	r4,r2
81108114:	110a06c0 	call	8110a06c <vRmapWriteReg>
		COMM_RMAP_SPW_PKT_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_1_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
81108118:	e0bfff17 	ldw	r2,-4(fp)
8110811c:	10802217 	ldw	r2,136(r2)
81108120:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81108124:	e0bfff17 	ldw	r2,-4(fp)
81108128:	10800017 	ldw	r2,0(r2)
8110812c:	e1bffe17 	ldw	r6,-8(fp)
81108130:	01401104 	movi	r5,68
81108134:	1009883a 	mov	r4,r2
81108138:	110a06c0 	call	8110a06c <vRmapWriteReg>
		COMM_RMAP_CCD_1_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_1_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config;
8110813c:	e0bfff17 	ldw	r2,-4(fp)
81108140:	10801717 	ldw	r2,92(r2)
81108144:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81108148:	e0bfff17 	ldw	r2,-4(fp)
8110814c:	10800017 	ldw	r2,0(r2)
81108150:	e1bffe17 	ldw	r6,-8(fp)
81108154:	01401144 	movi	r5,69
81108158:	1009883a 	mov	r4,r2
8110815c:	110a06c0 	call	8110a06c <vRmapWriteReg>
		COMM_RMAP_CCD_1_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_2_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config;
81108160:	e0bfff17 	ldw	r2,-4(fp)
81108164:	10801817 	ldw	r2,96(r2)
81108168:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
8110816c:	e0bfff17 	ldw	r2,-4(fp)
81108170:	10800017 	ldw	r2,0(r2)
81108174:	e1bffe17 	ldw	r6,-8(fp)
81108178:	01401184 	movi	r5,70
8110817c:	1009883a 	mov	r4,r2
81108180:	110a06c0 	call	8110a06c <vRmapWriteReg>
		COMM_RMAP_CCD_2_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_2_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config;
81108184:	e0bfff17 	ldw	r2,-4(fp)
81108188:	10801917 	ldw	r2,100(r2)
8110818c:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81108190:	e0bfff17 	ldw	r2,-4(fp)
81108194:	10800017 	ldw	r2,0(r2)
81108198:	e1bffe17 	ldw	r6,-8(fp)
8110819c:	014011c4 	movi	r5,71
811081a0:	1009883a 	mov	r4,r2
811081a4:	110a06c0 	call	8110a06c <vRmapWriteReg>
		COMM_RMAP_CCD_2_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_3_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config;
811081a8:	e0bfff17 	ldw	r2,-4(fp)
811081ac:	10801a17 	ldw	r2,104(r2)
811081b0:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
811081b4:	e0bfff17 	ldw	r2,-4(fp)
811081b8:	10800017 	ldw	r2,0(r2)
811081bc:	e1bffe17 	ldw	r6,-8(fp)
811081c0:	01401204 	movi	r5,72
811081c4:	1009883a 	mov	r4,r2
811081c8:	110a06c0 	call	8110a06c <vRmapWriteReg>
		COMM_RMAP_CCD_3_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_3_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config;
811081cc:	e0bfff17 	ldw	r2,-4(fp)
811081d0:	10801b17 	ldw	r2,108(r2)
811081d4:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
811081d8:	e0bfff17 	ldw	r2,-4(fp)
811081dc:	10800017 	ldw	r2,0(r2)
811081e0:	e1bffe17 	ldw	r6,-8(fp)
811081e4:	01401244 	movi	r5,73
811081e8:	1009883a 	mov	r4,r2
811081ec:	110a06c0 	call	8110a06c <vRmapWriteReg>
		COMM_RMAP_CCD_3_W_2_CFG_REG_OFST, uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811081f0:	e0bfff17 	ldw	r2,-4(fp)
811081f4:	10800017 	ldw	r2,0(r2)
811081f8:	01401284 	movi	r5,74
811081fc:	1009883a 	mov	r4,r2
81108200:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81108204:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config;
81108208:	e0bfff17 	ldw	r2,-4(fp)
8110820c:	10801c17 	ldw	r2,112(r2)
81108210:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81108214:	e0bfff17 	ldw	r2,-4(fp)
81108218:	10800017 	ldw	r2,0(r2)
8110821c:	e1bffe17 	ldw	r6,-8(fp)
81108220:	01401284 	movi	r5,74
81108224:	1009883a 	mov	r4,r2
81108228:	110a06c0 	call	8110a06c <vRmapWriteReg>
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_4_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config;
8110822c:	e0bfff17 	ldw	r2,-4(fp)
81108230:	10801d17 	ldw	r2,116(r2)
81108234:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81108238:	e0bfff17 	ldw	r2,-4(fp)
8110823c:	10800017 	ldw	r2,0(r2)
81108240:	e1bffe17 	ldw	r6,-8(fp)
81108244:	014012c4 	movi	r5,75
81108248:	1009883a 	mov	r4,r2
8110824c:	110a06c0 	call	8110a06c <vRmapWriteReg>
		COMM_RMAP_CCD_4_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_OP_MODE_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig;
81108250:	e0bfff17 	ldw	r2,-4(fp)
81108254:	10801e17 	ldw	r2,120(r2)
81108258:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_MODE_SEL_CTRL_MSK);
//			uliReg |= (COMM_RMAP_MODE_SEL_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_OP_MODE_CFG_REG_OFST,
8110825c:	e0bfff17 	ldw	r2,-4(fp)
81108260:	10800017 	ldw	r2,0(r2)
81108264:	e1bffe17 	ldw	r6,-8(fp)
81108268:	01401304 	movi	r5,76
8110826c:	1009883a 	mov	r4,r2
81108270:	110a06c0 	call	8110a06c <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SYNC_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSyncConfig;
81108274:	e0bfff17 	ldw	r2,-4(fp)
81108278:	10801f17 	ldw	r2,124(r2)
8110827c:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_SYNC_CFG_MSK);
//			uliReg |= (COMM_RMAP_SYNC_CFG_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSyncConfig. << 0));
//			uliReg &= (~COMM_RMAP_SELF_TRIGGER_CTRL_MSK);
//			uliReg |= (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSyncConfig. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SYNC_CFG_REG_OFST,
81108280:	e0bfff17 	ldw	r2,-4(fp)
81108284:	10800017 	ldw	r2,0(r2)
81108288:	e1bffe17 	ldw	r6,-8(fp)
8110828c:	01401344 	movi	r5,77
81108290:	1009883a 	mov	r4,r2
81108294:	110a06c0 	call	8110a06c <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_DAC_CTRL_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliDacControl;
81108298:	e0bfff17 	ldw	r2,-4(fp)
8110829c:	10802017 	ldw	r2,128(r2)
811082a0:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_DAC_CTRL_REG_OFST,
811082a4:	e0bfff17 	ldw	r2,-4(fp)
811082a8:	10800017 	ldw	r2,0(r2)
811082ac:	e1bffe17 	ldw	r6,-8(fp)
811082b0:	01401384 	movi	r5,78
811082b4:	1009883a 	mov	r4,r2
811082b8:	110a06c0 	call	8110a06c <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CLK_SRCE_CTRL_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
811082bc:	e0bfff17 	ldw	r2,-4(fp)
811082c0:	10802217 	ldw	r2,136(r2)
811082c4:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
811082c8:	e0bfff17 	ldw	r2,-4(fp)
811082cc:	10800017 	ldw	r2,0(r2)
811082d0:	e1bffe17 	ldw	r6,-8(fp)
811082d4:	014013c4 	movi	r5,79
811082d8:	1009883a 	mov	r4,r2
811082dc:	110a06c0 	call	8110a06c <vRmapWriteReg>
		COMM_RMAP_CLK_SRCE_CTRL_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_FRAME_NUMBER_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
811082e0:	e0bfff17 	ldw	r2,-4(fp)
811082e4:	10802217 	ldw	r2,136(r2)
811082e8:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_FRAME_NUMBER_MSK);
//			uliReg |= (COMM_RMAP_FRAME_NUMBER_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliFrameNumber. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_FRAME_NUMBER_REG_OFST,
811082ec:	e0bfff17 	ldw	r2,-4(fp)
811082f0:	10800017 	ldw	r2,0(r2)
811082f4:	e1bffe17 	ldw	r6,-8(fp)
811082f8:	01401404 	movi	r5,80
811082fc:	1009883a 	mov	r4,r2
81108300:	110a06c0 	call	8110a06c <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CURRENT_MODE_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCurrentMode;
81108304:	e0bfff17 	ldw	r2,-4(fp)
81108308:	10802317 	ldw	r2,140(r2)
8110830c:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_CURRENT_MODE_MSK);
//			uliReg |= (COMM_RMAP_CURRENT_MODE_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCurrentMode. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CURRENT_MODE_REG_OFST,
81108310:	e0bfff17 	ldw	r2,-4(fp)
81108314:	10800017 	ldw	r2,0(r2)
81108318:	e1bffe17 	ldw	r6,-8(fp)
8110831c:	01401444 	movi	r5,81
81108320:	1009883a 	mov	r4,r2
81108324:	110a06c0 	call	8110a06c <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
81108328:	00800044 	movi	r2,1
8110832c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81108330:	e0bffd17 	ldw	r2,-12(fp)
}
81108334:	e037883a 	mov	sp,fp
81108338:	dfc00117 	ldw	ra,4(sp)
8110833c:	df000017 	ldw	fp,0(sp)
81108340:	dec00204 	addi	sp,sp,8
81108344:	f800283a 	ret

81108348 <bRmapGetMemConfigArea>:

bool bRmapGetMemConfigArea(TRmapChannel *pxRmapCh) {
81108348:	defffb04 	addi	sp,sp,-20
8110834c:	de00012e 	bgeu	sp,et,81108354 <bRmapGetMemConfigArea+0xc>
81108350:	003b68fa 	trap	3
81108354:	dfc00415 	stw	ra,16(sp)
81108358:	df000315 	stw	fp,12(sp)
8110835c:	df000304 	addi	fp,sp,12
81108360:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81108364:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81108368:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
8110836c:	e0bfff17 	ldw	r2,-4(fp)
81108370:	1000a426 	beq	r2,zero,81108604 <bRmapGetMemConfigArea+0x2bc>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108374:	e0bfff17 	ldw	r2,-4(fp)
81108378:	10800017 	ldw	r2,0(r2)
8110837c:	01401004 	movi	r5,64
81108380:	1009883a 	mov	r4,r2
81108384:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81108388:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config = uliReg;
8110838c:	e0bfff17 	ldw	r2,-4(fp)
81108390:	e0fffe17 	ldw	r3,-8(fp)
81108394:	10c01215 	stw	r3,72(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108398:	e0bfff17 	ldw	r2,-4(fp)
8110839c:	10800017 	ldw	r2,0(r2)
811083a0:	01401044 	movi	r5,65
811083a4:	1009883a 	mov	r4,r2
811083a8:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
811083ac:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config = uliReg;
811083b0:	e0bfff17 	ldw	r2,-4(fp)
811083b4:	e0fffe17 	ldw	r3,-8(fp)
811083b8:	10c01315 	stw	r3,76(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811083bc:	e0bfff17 	ldw	r2,-4(fp)
811083c0:	10800017 	ldw	r2,0(r2)
811083c4:	01401084 	movi	r5,66
811083c8:	1009883a 	mov	r4,r2
811083cc:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
811083d0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SPW_PKT_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config = uliReg;
811083d4:	e0bfff17 	ldw	r2,-4(fp)
811083d8:	e0fffe17 	ldw	r3,-8(fp)
811083dc:	10c01415 	stw	r3,80(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811083e0:	e0bfff17 	ldw	r2,-4(fp)
811083e4:	10800017 	ldw	r2,0(r2)
811083e8:	014010c4 	movi	r5,67
811083ec:	1009883a 	mov	r4,r2
811083f0:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
811083f4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SPW_PKT_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSpwPacket2Config = uliReg;
811083f8:	e0bfff17 	ldw	r2,-4(fp)
811083fc:	e0fffe17 	ldw	r3,-8(fp)
81108400:	10c01515 	stw	r3,84(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108404:	e0bfff17 	ldw	r2,-4(fp)
81108408:	10800017 	ldw	r2,0(r2)
8110840c:	01401104 	movi	r5,68
81108410:	1009883a 	mov	r4,r2
81108414:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81108418:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_1_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
8110841c:	e0bfff17 	ldw	r2,-4(fp)
81108420:	e0fffe17 	ldw	r3,-8(fp)
81108424:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108428:	e0bfff17 	ldw	r2,-4(fp)
8110842c:	10800017 	ldw	r2,0(r2)
81108430:	01401144 	movi	r5,69
81108434:	1009883a 	mov	r4,r2
81108438:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
8110843c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_1_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config = uliReg;
81108440:	e0bfff17 	ldw	r2,-4(fp)
81108444:	e0fffe17 	ldw	r3,-8(fp)
81108448:	10c01715 	stw	r3,92(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110844c:	e0bfff17 	ldw	r2,-4(fp)
81108450:	10800017 	ldw	r2,0(r2)
81108454:	01401184 	movi	r5,70
81108458:	1009883a 	mov	r4,r2
8110845c:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81108460:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_2_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config = uliReg;
81108464:	e0bfff17 	ldw	r2,-4(fp)
81108468:	e0fffe17 	ldw	r3,-8(fp)
8110846c:	10c01815 	stw	r3,96(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108470:	e0bfff17 	ldw	r2,-4(fp)
81108474:	10800017 	ldw	r2,0(r2)
81108478:	014011c4 	movi	r5,71
8110847c:	1009883a 	mov	r4,r2
81108480:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81108484:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_2_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config = uliReg;
81108488:	e0bfff17 	ldw	r2,-4(fp)
8110848c:	e0fffe17 	ldw	r3,-8(fp)
81108490:	10c01915 	stw	r3,100(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108494:	e0bfff17 	ldw	r2,-4(fp)
81108498:	10800017 	ldw	r2,0(r2)
8110849c:	01401204 	movi	r5,72
811084a0:	1009883a 	mov	r4,r2
811084a4:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
811084a8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_3_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config = uliReg;
811084ac:	e0bfff17 	ldw	r2,-4(fp)
811084b0:	e0fffe17 	ldw	r3,-8(fp)
811084b4:	10c01a15 	stw	r3,104(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811084b8:	e0bfff17 	ldw	r2,-4(fp)
811084bc:	10800017 	ldw	r2,0(r2)
811084c0:	01401244 	movi	r5,73
811084c4:	1009883a 	mov	r4,r2
811084c8:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
811084cc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_3_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config = uliReg;
811084d0:	e0bfff17 	ldw	r2,-4(fp)
811084d4:	e0fffe17 	ldw	r3,-8(fp)
811084d8:	10c01b15 	stw	r3,108(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811084dc:	e0bfff17 	ldw	r2,-4(fp)
811084e0:	10800017 	ldw	r2,0(r2)
811084e4:	01401284 	movi	r5,74
811084e8:	1009883a 	mov	r4,r2
811084ec:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
811084f0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config = uliReg;
811084f4:	e0bfff17 	ldw	r2,-4(fp)
811084f8:	e0fffe17 	ldw	r3,-8(fp)
811084fc:	10c01c15 	stw	r3,112(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108500:	e0bfff17 	ldw	r2,-4(fp)
81108504:	10800017 	ldw	r2,0(r2)
81108508:	014012c4 	movi	r5,75
8110850c:	1009883a 	mov	r4,r2
81108510:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81108514:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config = uliReg;
81108518:	e0bfff17 	ldw	r2,-4(fp)
8110851c:	e0fffe17 	ldw	r3,-8(fp)
81108520:	10c01d15 	stw	r3,116(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108524:	e0bfff17 	ldw	r2,-4(fp)
81108528:	10800017 	ldw	r2,0(r2)
8110852c:	01401304 	movi	r5,76
81108530:	1009883a 	mov	r4,r2
81108534:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81108538:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_OP_MODE_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig = uliReg;
8110853c:	e0bfff17 	ldw	r2,-4(fp)
81108540:	e0fffe17 	ldw	r3,-8(fp)
81108544:	10c01e15 	stw	r3,120(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108548:	e0bfff17 	ldw	r2,-4(fp)
8110854c:	10800017 	ldw	r2,0(r2)
81108550:	01401344 	movi	r5,77
81108554:	1009883a 	mov	r4,r2
81108558:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
8110855c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SYNC_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSyncConfig = uliReg;
81108560:	e0bfff17 	ldw	r2,-4(fp)
81108564:	e0fffe17 	ldw	r3,-8(fp)
81108568:	10c01f15 	stw	r3,124(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110856c:	e0bfff17 	ldw	r2,-4(fp)
81108570:	10800017 	ldw	r2,0(r2)
81108574:	01401384 	movi	r5,78
81108578:	1009883a 	mov	r4,r2
8110857c:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81108580:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_DAC_CTRL_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliDacControl = uliReg;
81108584:	e0bfff17 	ldw	r2,-4(fp)
81108588:	e0fffe17 	ldw	r3,-8(fp)
8110858c:	10c02015 	stw	r3,128(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108590:	e0bfff17 	ldw	r2,-4(fp)
81108594:	10800017 	ldw	r2,0(r2)
81108598:	014013c4 	movi	r5,79
8110859c:	1009883a 	mov	r4,r2
811085a0:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
811085a4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CLK_SRCE_CTRL_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
811085a8:	e0bfff17 	ldw	r2,-4(fp)
811085ac:	e0fffe17 	ldw	r3,-8(fp)
811085b0:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811085b4:	e0bfff17 	ldw	r2,-4(fp)
811085b8:	10800017 	ldw	r2,0(r2)
811085bc:	01401404 	movi	r5,80
811085c0:	1009883a 	mov	r4,r2
811085c4:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
811085c8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_FRAME_NUMBER_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
811085cc:	e0bfff17 	ldw	r2,-4(fp)
811085d0:	e0fffe17 	ldw	r3,-8(fp)
811085d4:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811085d8:	e0bfff17 	ldw	r2,-4(fp)
811085dc:	10800017 	ldw	r2,0(r2)
811085e0:	01401444 	movi	r5,81
811085e4:	1009883a 	mov	r4,r2
811085e8:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
811085ec:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CURRENT_MODE_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCurrentMode = uliReg;
811085f0:	e0bfff17 	ldw	r2,-4(fp)
811085f4:	e0fffe17 	ldw	r3,-8(fp)
811085f8:	10c02315 	stw	r3,140(r2)

		bStatus = TRUE;
811085fc:	00800044 	movi	r2,1
81108600:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81108604:	e0bffd17 	ldw	r2,-12(fp)
}
81108608:	e037883a 	mov	sp,fp
8110860c:	dfc00117 	ldw	ra,4(sp)
81108610:	df000017 	ldw	fp,0(sp)
81108614:	dec00204 	addi	sp,sp,8
81108618:	f800283a 	ret

8110861c <bRmapGetMemConfigStat>:

bool bRmapGetMemConfigStat(TRmapChannel *pxRmapCh) {
8110861c:	defffb04 	addi	sp,sp,-20
81108620:	de00012e 	bgeu	sp,et,81108628 <bRmapGetMemConfigStat+0xc>
81108624:	003b68fa 	trap	3
81108628:	dfc00415 	stw	ra,16(sp)
8110862c:	df000315 	stw	fp,12(sp)
81108630:	df000304 	addi	fp,sp,12
81108634:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81108638:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110863c:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81108640:	e0bfff17 	ldw	r2,-4(fp)
81108644:	10001426 	beq	r2,zero,81108698 <bRmapGetMemConfigStat+0x7c>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108648:	e0bfff17 	ldw	r2,-4(fp)
8110864c:	10800017 	ldw	r2,0(r2)
81108650:	014001c4 	movi	r5,7
81108654:	1009883a 	mov	r4,r2
81108658:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
8110865c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_LST_RD_ADDR_REG_OFST);

		pxRmapCh->xRmapMemConfigStat.uliLastReadAddress = (alt_u32) ((uliReg
81108660:	e0bfff17 	ldw	r2,-4(fp)
81108664:	e0fffe17 	ldw	r3,-8(fp)
81108668:	10c02515 	stw	r3,148(r2)
				& COMM_RMAP_LST_RD_ADDR_MSK) >> 0);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110866c:	e0bfff17 	ldw	r2,-4(fp)
81108670:	10800017 	ldw	r2,0(r2)
81108674:	01400184 	movi	r5,6
81108678:	1009883a 	mov	r4,r2
8110867c:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81108680:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_LST_WR_ADDR_REG_OFST);

		pxRmapCh->xRmapMemConfigStat.uliLastWriteAddress = (alt_u32) ((uliReg
81108684:	e0bfff17 	ldw	r2,-4(fp)
81108688:	e0fffe17 	ldw	r3,-8(fp)
8110868c:	10c02415 	stw	r3,144(r2)
				& COMM_RMAP_LST_WR_ADDR_MSK) >> 0);

		bStatus = TRUE;
81108690:	00800044 	movi	r2,1
81108694:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81108698:	e0bffd17 	ldw	r2,-12(fp)
}
8110869c:	e037883a 	mov	sp,fp
811086a0:	dfc00117 	ldw	ra,4(sp)
811086a4:	df000017 	ldw	fp,0(sp)
811086a8:	dec00204 	addi	sp,sp,8
811086ac:	f800283a 	ret

811086b0 <bRmapSetRmapMemHKArea>:

bool bRmapSetRmapMemHKArea(TRmapChannel *pxRmapCh) {
811086b0:	defffb04 	addi	sp,sp,-20
811086b4:	de00012e 	bgeu	sp,et,811086bc <bRmapSetRmapMemHKArea+0xc>
811086b8:	003b68fa 	trap	3
811086bc:	dfc00415 	stw	ra,16(sp)
811086c0:	df000315 	stw	fp,12(sp)
811086c4:	df000304 	addi	fp,sp,12
811086c8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811086cc:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811086d0:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
811086d4:	e0bfff17 	ldw	r2,-4(fp)
811086d8:	10040226 	beq	r2,zero,811096e4 <bRmapSetRmapMemHKArea+0x1034>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811086dc:	e0bfff17 	ldw	r2,-4(fp)
811086e0:	10800017 	ldw	r2,0(r2)
811086e4:	01402804 	movi	r5,160
811086e8:	1009883a 	mov	r4,r2
811086ec:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
811086f0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
811086f4:	e0bffe17 	ldw	r2,-8(fp)
811086f8:	10bfffec 	andhi	r2,r2,65535
811086fc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
81108700:	e0bfff17 	ldw	r2,-4(fp)
81108704:	1080260b 	ldhu	r2,152(r2)
81108708:	10bfffcc 	andi	r2,r2,65535
	if (pxRmapCh != NULL) {

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
8110870c:	e0fffe17 	ldw	r3,-8(fp)
81108710:	1884b03a 	or	r2,r3,r2
81108714:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_F_MSK);
81108718:	e0bffe17 	ldw	r2,-8(fp)
8110871c:	10bfffcc 	andi	r2,r2,65535
81108720:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF << 16));
81108724:	e0bfff17 	ldw	r2,-4(fp)
81108728:	1080268b 	ldhu	r2,154(r2)
8110872c:	10bfffcc 	andi	r2,r2,65535
81108730:	1004943a 	slli	r2,r2,16
81108734:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_F_MSK
81108738:	e0bffe17 	ldw	r2,-8(fp)
8110873c:	10c4b03a 	or	r2,r2,r3
81108740:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_0_REG_OFST,
81108744:	e0bfff17 	ldw	r2,-4(fp)
81108748:	10800017 	ldw	r2,0(r2)
8110874c:	e1bffe17 	ldw	r6,-8(fp)
81108750:	01402804 	movi	r5,160
81108754:	1009883a 	mov	r4,r2
81108758:	110a06c0 	call	8110a06c <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110875c:	e0bfff17 	ldw	r2,-4(fp)
81108760:	10800017 	ldw	r2,0(r2)
81108764:	01402844 	movi	r5,161
81108768:	1009883a 	mov	r4,r2
8110876c:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81108770:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
81108774:	e0bffe17 	ldw	r2,-8(fp)
81108778:	10bfffec 	andhi	r2,r2,65535
8110877c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
81108780:	e0bfff17 	ldw	r2,-4(fp)
81108784:	1080270b 	ldhu	r2,156(r2)
81108788:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
8110878c:	e0fffe17 	ldw	r3,-8(fp)
81108790:	1884b03a 	or	r2,r3,r2
81108794:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_E_MSK);
81108798:	e0bffe17 	ldw	r2,-8(fp)
8110879c:	10bfffcc 	andi	r2,r2,65535
811087a0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE << 16));
811087a4:	e0bfff17 	ldw	r2,-4(fp)
811087a8:	1080278b 	ldhu	r2,158(r2)
811087ac:	10bfffcc 	andi	r2,r2,65535
811087b0:	1004943a 	slli	r2,r2,16
811087b4:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_E_MSK
811087b8:	e0bffe17 	ldw	r2,-8(fp)
811087bc:	10c4b03a 	or	r2,r2,r3
811087c0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_1_REG_OFST,
811087c4:	e0bfff17 	ldw	r2,-4(fp)
811087c8:	10800017 	ldw	r2,0(r2)
811087cc:	e1bffe17 	ldw	r6,-8(fp)
811087d0:	01402844 	movi	r5,161
811087d4:	1009883a 	mov	r4,r2
811087d8:	110a06c0 	call	8110a06c <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811087dc:	e0bfff17 	ldw	r2,-4(fp)
811087e0:	10800017 	ldw	r2,0(r2)
811087e4:	01402884 	movi	r5,162
811087e8:	1009883a 	mov	r4,r2
811087ec:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
811087f0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
811087f4:	e0bffe17 	ldw	r2,-8(fp)
811087f8:	10bfffec 	andhi	r2,r2,65535
811087fc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
81108800:	e0bfff17 	ldw	r2,-4(fp)
81108804:	1080280b 	ldhu	r2,160(r2)
81108808:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
8110880c:	e0fffe17 	ldw	r3,-8(fp)
81108810:	1884b03a 	or	r2,r3,r2
81108814:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VRD_MON_MSK);
81108818:	e0bffe17 	ldw	r2,-8(fp)
8110881c:	10bfffcc 	andi	r2,r2,65535
81108820:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon << 16));
81108824:	e0bfff17 	ldw	r2,-4(fp)
81108828:	1080288b 	ldhu	r2,162(r2)
8110882c:	10bfffcc 	andi	r2,r2,65535
81108830:	1004943a 	slli	r2,r2,16
81108834:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VRD_MON_MSK
81108838:	e0bffe17 	ldw	r2,-8(fp)
8110883c:	10c4b03a 	or	r2,r2,r3
81108840:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_2_REG_OFST,
81108844:	e0bfff17 	ldw	r2,-4(fp)
81108848:	10800017 	ldw	r2,0(r2)
8110884c:	e1bffe17 	ldw	r6,-8(fp)
81108850:	01402884 	movi	r5,162
81108854:	1009883a 	mov	r4,r2
81108858:	110a06c0 	call	8110a06c <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110885c:	e0bfff17 	ldw	r2,-4(fp)
81108860:	10800017 	ldw	r2,0(r2)
81108864:	014028c4 	movi	r5,163
81108868:	1009883a 	mov	r4,r2
8110886c:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81108870:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
81108874:	e0bffe17 	ldw	r2,-8(fp)
81108878:	10bfffec 	andhi	r2,r2,65535
8110887c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
81108880:	e0bfff17 	ldw	r2,-4(fp)
81108884:	1080290b 	ldhu	r2,164(r2)
81108888:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
8110888c:	e0fffe17 	ldw	r3,-8(fp)
81108890:	1884b03a 	or	r2,r3,r2
81108894:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_F_MSK);
81108898:	e0bffe17 	ldw	r2,-8(fp)
8110889c:	10bfffcc 	andi	r2,r2,65535
811088a0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF << 16));
811088a4:	e0bfff17 	ldw	r2,-4(fp)
811088a8:	1080298b 	ldhu	r2,166(r2)
811088ac:	10bfffcc 	andi	r2,r2,65535
811088b0:	1004943a 	slli	r2,r2,16
811088b4:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_F_MSK
811088b8:	e0bffe17 	ldw	r2,-8(fp)
811088bc:	10c4b03a 	or	r2,r2,r3
811088c0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_3_REG_OFST,
811088c4:	e0bfff17 	ldw	r2,-4(fp)
811088c8:	10800017 	ldw	r2,0(r2)
811088cc:	e1bffe17 	ldw	r6,-8(fp)
811088d0:	014028c4 	movi	r5,163
811088d4:	1009883a 	mov	r4,r2
811088d8:	110a06c0 	call	8110a06c <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811088dc:	e0bfff17 	ldw	r2,-4(fp)
811088e0:	10800017 	ldw	r2,0(r2)
811088e4:	01402904 	movi	r5,164
811088e8:	1009883a 	mov	r4,r2
811088ec:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
811088f0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
811088f4:	e0bffe17 	ldw	r2,-8(fp)
811088f8:	10bfffec 	andhi	r2,r2,65535
811088fc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
81108900:	e0bfff17 	ldw	r2,-4(fp)
81108904:	10802a0b 	ldhu	r2,168(r2)
81108908:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
8110890c:	e0fffe17 	ldw	r3,-8(fp)
81108910:	1884b03a 	or	r2,r3,r2
81108914:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_E_MSK);
81108918:	e0bffe17 	ldw	r2,-8(fp)
8110891c:	10bfffcc 	andi	r2,r2,65535
81108920:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE << 16));
81108924:	e0bfff17 	ldw	r2,-4(fp)
81108928:	10802a8b 	ldhu	r2,170(r2)
8110892c:	10bfffcc 	andi	r2,r2,65535
81108930:	1004943a 	slli	r2,r2,16
81108934:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_E_MSK
81108938:	e0bffe17 	ldw	r2,-8(fp)
8110893c:	10c4b03a 	or	r2,r2,r3
81108940:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_4_REG_OFST,
81108944:	e0bfff17 	ldw	r2,-4(fp)
81108948:	10800017 	ldw	r2,0(r2)
8110894c:	e1bffe17 	ldw	r6,-8(fp)
81108950:	01402904 	movi	r5,164
81108954:	1009883a 	mov	r4,r2
81108958:	110a06c0 	call	8110a06c <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110895c:	e0bfff17 	ldw	r2,-4(fp)
81108960:	10800017 	ldw	r2,0(r2)
81108964:	01402944 	movi	r5,165
81108968:	1009883a 	mov	r4,r2
8110896c:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81108970:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
81108974:	e0bffe17 	ldw	r2,-8(fp)
81108978:	10bfffec 	andhi	r2,r2,65535
8110897c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
81108980:	e0bfff17 	ldw	r2,-4(fp)
81108984:	10802b0b 	ldhu	r2,172(r2)
81108988:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
8110898c:	e0fffe17 	ldw	r3,-8(fp)
81108990:	1884b03a 	or	r2,r3,r2
81108994:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VRD_MON_MSK);
81108998:	e0bffe17 	ldw	r2,-8(fp)
8110899c:	10bfffcc 	andi	r2,r2,65535
811089a0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon << 16));
811089a4:	e0bfff17 	ldw	r2,-4(fp)
811089a8:	10802b8b 	ldhu	r2,174(r2)
811089ac:	10bfffcc 	andi	r2,r2,65535
811089b0:	1004943a 	slli	r2,r2,16
811089b4:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VRD_MON_MSK
811089b8:	e0bffe17 	ldw	r2,-8(fp)
811089bc:	10c4b03a 	or	r2,r2,r3
811089c0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_5_REG_OFST,
811089c4:	e0bfff17 	ldw	r2,-4(fp)
811089c8:	10800017 	ldw	r2,0(r2)
811089cc:	e1bffe17 	ldw	r6,-8(fp)
811089d0:	01402944 	movi	r5,165
811089d4:	1009883a 	mov	r4,r2
811089d8:	110a06c0 	call	8110a06c <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811089dc:	e0bfff17 	ldw	r2,-4(fp)
811089e0:	10800017 	ldw	r2,0(r2)
811089e4:	01402984 	movi	r5,166
811089e8:	1009883a 	mov	r4,r2
811089ec:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
811089f0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
811089f4:	e0bffe17 	ldw	r2,-8(fp)
811089f8:	10bfffec 	andhi	r2,r2,65535
811089fc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
81108a00:	e0bfff17 	ldw	r2,-4(fp)
81108a04:	10802c0b 	ldhu	r2,176(r2)
81108a08:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
81108a0c:	e0fffe17 	ldw	r3,-8(fp)
81108a10:	1884b03a 	or	r2,r3,r2
81108a14:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_MSK);
81108a18:	e0bffe17 	ldw	r2,-8(fp)
81108a1c:	10bfffcc 	andi	r2,r2,65535
81108a20:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VRCLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclk << 16));
81108a24:	e0bfff17 	ldw	r2,-4(fp)
81108a28:	10802c8b 	ldhu	r2,178(r2)
81108a2c:	10bfffcc 	andi	r2,r2,65535
81108a30:	1004943a 	slli	r2,r2,16
81108a34:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_MSK);
		uliReg |= (COMM_RMAP_HK_VRCLK_MSK
81108a38:	e0bffe17 	ldw	r2,-8(fp)
81108a3c:	10c4b03a 	or	r2,r2,r3
81108a40:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclk << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_6_REG_OFST,
81108a44:	e0bfff17 	ldw	r2,-4(fp)
81108a48:	10800017 	ldw	r2,0(r2)
81108a4c:	e1bffe17 	ldw	r6,-8(fp)
81108a50:	01402984 	movi	r5,166
81108a54:	1009883a 	mov	r4,r2
81108a58:	110a06c0 	call	8110a06c <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108a5c:	e0bfff17 	ldw	r2,-4(fp)
81108a60:	10800017 	ldw	r2,0(r2)
81108a64:	014029c4 	movi	r5,167
81108a68:	1009883a 	mov	r4,r2
81108a6c:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81108a70:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
81108a74:	e0bffe17 	ldw	r2,-8(fp)
81108a78:	10bfffec 	andhi	r2,r2,65535
81108a7c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
81108a80:	e0bfff17 	ldw	r2,-4(fp)
81108a84:	10802d0b 	ldhu	r2,180(r2)
81108a88:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
81108a8c:	e0fffe17 	ldw	r3,-8(fp)
81108a90:	1884b03a 	or	r2,r3,r2
81108a94:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_LOW_MSK);
81108a98:	e0bffe17 	ldw	r2,-8(fp)
81108a9c:	10bfffcc 	andi	r2,r2,65535
81108aa0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VRCLK_LOW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclkLow << 16));
81108aa4:	e0bfff17 	ldw	r2,-4(fp)
81108aa8:	10802d8b 	ldhu	r2,182(r2)
81108aac:	10bfffcc 	andi	r2,r2,65535
81108ab0:	1004943a 	slli	r2,r2,16
81108ab4:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_LOW_MSK);
		uliReg |= (COMM_RMAP_HK_VRCLK_LOW_MSK
81108ab8:	e0bffe17 	ldw	r2,-8(fp)
81108abc:	10c4b03a 	or	r2,r2,r3
81108ac0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclkLow << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_7_REG_OFST,
81108ac4:	e0bfff17 	ldw	r2,-4(fp)
81108ac8:	10800017 	ldw	r2,0(r2)
81108acc:	e1bffe17 	ldw	r6,-8(fp)
81108ad0:	014029c4 	movi	r5,167
81108ad4:	1009883a 	mov	r4,r2
81108ad8:	110a06c0 	call	8110a06c <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108adc:	e0bfff17 	ldw	r2,-4(fp)
81108ae0:	10800017 	ldw	r2,0(r2)
81108ae4:	01402a04 	movi	r5,168
81108ae8:	1009883a 	mov	r4,r2
81108aec:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81108af0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
81108af4:	e0bffe17 	ldw	r2,-8(fp)
81108af8:	10bfffec 	andhi	r2,r2,65535
81108afc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
81108b00:	e0bfff17 	ldw	r2,-4(fp)
81108b04:	10802e0b 	ldhu	r2,184(r2)
81108b08:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
81108b0c:	e0fffe17 	ldw	r3,-8(fp)
81108b10:	1884b03a 	or	r2,r3,r2
81108b14:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VB_NEG_MSK);
81108b18:	e0bffe17 	ldw	r2,-8(fp)
81108b1c:	10bfffcc 	andi	r2,r2,65535
81108b20:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VB_NEG_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbNeg << 16));
81108b24:	e0bfff17 	ldw	r2,-4(fp)
81108b28:	10802e8b 	ldhu	r2,186(r2)
81108b2c:	10bfffcc 	andi	r2,r2,65535
81108b30:	1004943a 	slli	r2,r2,16
81108b34:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VB_NEG_MSK);
		uliReg |= (COMM_RMAP_HK_5VB_NEG_MSK
81108b38:	e0bffe17 	ldw	r2,-8(fp)
81108b3c:	10c4b03a 	or	r2,r2,r3
81108b40:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbNeg << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_8_REG_OFST,
81108b44:	e0bfff17 	ldw	r2,-4(fp)
81108b48:	10800017 	ldw	r2,0(r2)
81108b4c:	e1bffe17 	ldw	r6,-8(fp)
81108b50:	01402a04 	movi	r5,168
81108b54:	1009883a 	mov	r4,r2
81108b58:	110a06c0 	call	8110a06c <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108b5c:	e0bfff17 	ldw	r2,-4(fp)
81108b60:	10800017 	ldw	r2,0(r2)
81108b64:	01402a44 	movi	r5,169
81108b68:	1009883a 	mov	r4,r2
81108b6c:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81108b70:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
81108b74:	e0bffe17 	ldw	r2,-8(fp)
81108b78:	10bfffec 	andhi	r2,r2,65535
81108b7c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
81108b80:	e0bfff17 	ldw	r2,-4(fp)
81108b84:	10802f0b 	ldhu	r2,188(r2)
81108b88:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
81108b8c:	e0fffe17 	ldw	r3,-8(fp)
81108b90:	1884b03a 	or	r2,r3,r2
81108b94:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VA_POS_MSK);
81108b98:	e0bffe17 	ldw	r2,-8(fp)
81108b9c:	10bfffcc 	andi	r2,r2,65535
81108ba0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_2_5VA_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vaPos << 16));
81108ba4:	e0bfff17 	ldw	r2,-4(fp)
81108ba8:	10802f8b 	ldhu	r2,190(r2)
81108bac:	10bfffcc 	andi	r2,r2,65535
81108bb0:	1004943a 	slli	r2,r2,16
81108bb4:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VA_POS_MSK);
		uliReg |= (COMM_RMAP_HK_2_5VA_POS_MSK
81108bb8:	e0bffe17 	ldw	r2,-8(fp)
81108bbc:	10c4b03a 	or	r2,r2,r3
81108bc0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vaPos << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_9_REG_OFST,
81108bc4:	e0bfff17 	ldw	r2,-4(fp)
81108bc8:	10800017 	ldw	r2,0(r2)
81108bcc:	e1bffe17 	ldw	r6,-8(fp)
81108bd0:	01402a44 	movi	r5,169
81108bd4:	1009883a 	mov	r4,r2
81108bd8:	110a06c0 	call	8110a06c <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108bdc:	e0bfff17 	ldw	r2,-4(fp)
81108be0:	10800017 	ldw	r2,0(r2)
81108be4:	01402a84 	movi	r5,170
81108be8:	1009883a 	mov	r4,r2
81108bec:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81108bf0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
81108bf4:	e0bffe17 	ldw	r2,-8(fp)
81108bf8:	10bfffec 	andhi	r2,r2,65535
81108bfc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
81108c00:	e0bfff17 	ldw	r2,-4(fp)
81108c04:	1080300b 	ldhu	r2,192(r2)
81108c08:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
81108c0c:	e0fffe17 	ldw	r3,-8(fp)
81108c10:	1884b03a 	or	r2,r3,r2
81108c14:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VD_POS_MSK);
81108c18:	e0bffe17 	ldw	r2,-8(fp)
81108c1c:	10bfffcc 	andi	r2,r2,65535
81108c20:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_2_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vdPos << 16));
81108c24:	e0bfff17 	ldw	r2,-4(fp)
81108c28:	1080308b 	ldhu	r2,194(r2)
81108c2c:	10bfffcc 	andi	r2,r2,65535
81108c30:	1004943a 	slli	r2,r2,16
81108c34:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_2_5VD_POS_MSK
81108c38:	e0bffe17 	ldw	r2,-8(fp)
81108c3c:	10c4b03a 	or	r2,r2,r3
81108c40:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vdPos << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_10_REG_OFST,
81108c44:	e0bfff17 	ldw	r2,-4(fp)
81108c48:	10800017 	ldw	r2,0(r2)
81108c4c:	e1bffe17 	ldw	r6,-8(fp)
81108c50:	01402a84 	movi	r5,170
81108c54:	1009883a 	mov	r4,r2
81108c58:	110a06c0 	call	8110a06c <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108c5c:	e0bfff17 	ldw	r2,-4(fp)
81108c60:	10800017 	ldw	r2,0(r2)
81108c64:	01402ac4 	movi	r5,171
81108c68:	1009883a 	mov	r4,r2
81108c6c:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81108c70:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
81108c74:	e0bffe17 	ldw	r2,-8(fp)
81108c78:	10bfffec 	andhi	r2,r2,65535
81108c7c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
81108c80:	e0bfff17 	ldw	r2,-4(fp)
81108c84:	1080310b 	ldhu	r2,196(r2)
81108c88:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
81108c8c:	e0fffe17 	ldw	r3,-8(fp)
81108c90:	1884b03a 	or	r2,r3,r2
81108c94:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VREF_MSK);
81108c98:	e0bffe17 	ldw	r2,-8(fp)
81108c9c:	10bfffcc 	andi	r2,r2,65535
81108ca0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VREF_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vref << 16));
81108ca4:	e0bfff17 	ldw	r2,-4(fp)
81108ca8:	1080318b 	ldhu	r2,198(r2)
81108cac:	10bfffcc 	andi	r2,r2,65535
81108cb0:	1004943a 	slli	r2,r2,16
81108cb4:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VREF_MSK);
		uliReg |= (COMM_RMAP_HK_5VREF_MSK
81108cb8:	e0bffe17 	ldw	r2,-8(fp)
81108cbc:	10c4b03a 	or	r2,r2,r3
81108cc0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vref << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_11_REG_OFST,
81108cc4:	e0bfff17 	ldw	r2,-4(fp)
81108cc8:	10800017 	ldw	r2,0(r2)
81108ccc:	e1bffe17 	ldw	r6,-8(fp)
81108cd0:	01402ac4 	movi	r5,171
81108cd4:	1009883a 	mov	r4,r2
81108cd8:	110a06c0 	call	8110a06c <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108cdc:	e0bfff17 	ldw	r2,-4(fp)
81108ce0:	10800017 	ldw	r2,0(r2)
81108ce4:	01402b04 	movi	r5,172
81108ce8:	1009883a 	mov	r4,r2
81108cec:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81108cf0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
81108cf4:	e0bffe17 	ldw	r2,-8(fp)
81108cf8:	10bfffec 	andhi	r2,r2,65535
81108cfc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
81108d00:	e0bfff17 	ldw	r2,-4(fp)
81108d04:	1080320b 	ldhu	r2,200(r2)
81108d08:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
81108d0c:	e0fffe17 	ldw	r3,-8(fp)
81108d10:	1884b03a 	or	r2,r3,r2
81108d14:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VCLK_POS_RAW_MSK);
81108d18:	e0bffe17 	ldw	r2,-8(fp)
81108d1c:	10bfffcc 	andi	r2,r2,65535
81108d20:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCLK_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw << 16));
81108d24:	e0bfff17 	ldw	r2,-4(fp)
81108d28:	1080328b 	ldhu	r2,202(r2)
81108d2c:	10bfffcc 	andi	r2,r2,65535
81108d30:	1004943a 	slli	r2,r2,16
81108d34:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VCLK_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VCLK_POS_RAW_MSK
81108d38:	e0bffe17 	ldw	r2,-8(fp)
81108d3c:	10c4b03a 	or	r2,r2,r3
81108d40:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_12_REG_OFST,
81108d44:	e0bfff17 	ldw	r2,-4(fp)
81108d48:	10800017 	ldw	r2,0(r2)
81108d4c:	e1bffe17 	ldw	r6,-8(fp)
81108d50:	01402b04 	movi	r5,172
81108d54:	1009883a 	mov	r4,r2
81108d58:	110a06c0 	call	8110a06c <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108d5c:	e0bfff17 	ldw	r2,-4(fp)
81108d60:	10800017 	ldw	r2,0(r2)
81108d64:	01402b44 	movi	r5,173
81108d68:	1009883a 	mov	r4,r2
81108d6c:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81108d70:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
81108d74:	e0bffe17 	ldw	r2,-8(fp)
81108d78:	10bfffec 	andhi	r2,r2,65535
81108d7c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
81108d80:	e0bfff17 	ldw	r2,-4(fp)
81108d84:	1080330b 	ldhu	r2,204(r2)
81108d88:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
81108d8c:	e0fffe17 	ldw	r3,-8(fp)
81108d90:	1884b03a 	or	r2,r3,r2
81108d94:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VAN3_NEG_RAW_MSK);
81108d98:	e0bffe17 	ldw	r2,-8(fp)
81108d9c:	10bfffcc 	andi	r2,r2,65535
81108da0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN3_NEG_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw << 16));
81108da4:	e0bfff17 	ldw	r2,-4(fp)
81108da8:	1080338b 	ldhu	r2,206(r2)
81108dac:	10bfffcc 	andi	r2,r2,65535
81108db0:	1004943a 	slli	r2,r2,16
81108db4:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VAN3_NEG_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN3_NEG_RAW_MSK
81108db8:	e0bffe17 	ldw	r2,-8(fp)
81108dbc:	10c4b03a 	or	r2,r2,r3
81108dc0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_13_REG_OFST,
81108dc4:	e0bfff17 	ldw	r2,-4(fp)
81108dc8:	10800017 	ldw	r2,0(r2)
81108dcc:	e1bffe17 	ldw	r6,-8(fp)
81108dd0:	01402b44 	movi	r5,173
81108dd4:	1009883a 	mov	r4,r2
81108dd8:	110a06c0 	call	8110a06c <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108ddc:	e0bfff17 	ldw	r2,-4(fp)
81108de0:	10800017 	ldw	r2,0(r2)
81108de4:	01402b84 	movi	r5,174
81108de8:	1009883a 	mov	r4,r2
81108dec:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81108df0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
81108df4:	e0bffe17 	ldw	r2,-8(fp)
81108df8:	10bfffec 	andhi	r2,r2,65535
81108dfc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
81108e00:	e0bfff17 	ldw	r2,-4(fp)
81108e04:	1080340b 	ldhu	r2,208(r2)
81108e08:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
81108e0c:	e0fffe17 	ldw	r3,-8(fp)
81108e10:	1884b03a 	or	r2,r3,r2
81108e14:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VDIG_FPGA_RAW_MSK);
81108e18:	e0bffe17 	ldw	r2,-8(fp)
81108e1c:	10bfffcc 	andi	r2,r2,65535
81108e20:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VDIG_FPGA_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw << 16));
81108e24:	e0bfff17 	ldw	r2,-4(fp)
81108e28:	1080348b 	ldhu	r2,210(r2)
81108e2c:	10bfffcc 	andi	r2,r2,65535
81108e30:	1004943a 	slli	r2,r2,16
81108e34:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VDIG_FPGA_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VDIG_FPGA_RAW_MSK
81108e38:	e0bffe17 	ldw	r2,-8(fp)
81108e3c:	10c4b03a 	or	r2,r2,r3
81108e40:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_14_REG_OFST,
81108e44:	e0bfff17 	ldw	r2,-4(fp)
81108e48:	10800017 	ldw	r2,0(r2)
81108e4c:	e1bffe17 	ldw	r6,-8(fp)
81108e50:	01402b84 	movi	r5,174
81108e54:	1009883a 	mov	r4,r2
81108e58:	110a06c0 	call	8110a06c <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108e5c:	e0bfff17 	ldw	r2,-4(fp)
81108e60:	10800017 	ldw	r2,0(r2)
81108e64:	01402bc4 	movi	r5,175
81108e68:	1009883a 	mov	r4,r2
81108e6c:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81108e70:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
81108e74:	e0bffe17 	ldw	r2,-8(fp)
81108e78:	10bfffec 	andhi	r2,r2,65535
81108e7c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
81108e80:	e0bfff17 	ldw	r2,-4(fp)
81108e84:	1080350b 	ldhu	r2,212(r2)
81108e88:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
81108e8c:	e0fffe17 	ldw	r3,-8(fp)
81108e90:	1884b03a 	or	r2,r3,r2
81108e94:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VICLK_LOW_MSK);
81108e98:	e0bffe17 	ldw	r2,-8(fp)
81108e9c:	10bfffcc 	andi	r2,r2,65535
81108ea0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VICLK_LOW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclkLow << 16));
81108ea4:	e0bfff17 	ldw	r2,-4(fp)
81108ea8:	1080358b 	ldhu	r2,214(r2)
81108eac:	10bfffcc 	andi	r2,r2,65535
81108eb0:	1004943a 	slli	r2,r2,16
81108eb4:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VICLK_LOW_MSK);
		uliReg |= (COMM_RMAP_HK_VICLK_LOW_MSK
81108eb8:	e0bffe17 	ldw	r2,-8(fp)
81108ebc:	10c4b03a 	or	r2,r2,r3
81108ec0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclkLow << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_15_REG_OFST,
81108ec4:	e0bfff17 	ldw	r2,-4(fp)
81108ec8:	10800017 	ldw	r2,0(r2)
81108ecc:	e1bffe17 	ldw	r6,-8(fp)
81108ed0:	01402bc4 	movi	r5,175
81108ed4:	1009883a 	mov	r4,r2
81108ed8:	110a06c0 	call	8110a06c <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108edc:	e0bfff17 	ldw	r2,-4(fp)
81108ee0:	10800017 	ldw	r2,0(r2)
81108ee4:	01402c04 	movi	r5,176
81108ee8:	1009883a 	mov	r4,r2
81108eec:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81108ef0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
81108ef4:	e0bffe17 	ldw	r2,-8(fp)
81108ef8:	10bfffec 	andhi	r2,r2,65535
81108efc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
81108f00:	e0bfff17 	ldw	r2,-4(fp)
81108f04:	1080360b 	ldhu	r2,216(r2)
81108f08:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
81108f0c:	e0fffe17 	ldw	r3,-8(fp)
81108f10:	1884b03a 	or	r2,r3,r2
81108f14:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_F_MSK);
81108f18:	e0bffe17 	ldw	r2,-8(fp)
81108f1c:	10bfffcc 	andi	r2,r2,65535
81108f20:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF << 16));
81108f24:	e0bfff17 	ldw	r2,-4(fp)
81108f28:	1080368b 	ldhu	r2,218(r2)
81108f2c:	10bfffcc 	andi	r2,r2,65535
81108f30:	1004943a 	slli	r2,r2,16
81108f34:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_F_MSK);
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_F_MSK
81108f38:	e0bffe17 	ldw	r2,-8(fp)
81108f3c:	10c4b03a 	or	r2,r2,r3
81108f40:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_16_REG_OFST,
81108f44:	e0bfff17 	ldw	r2,-4(fp)
81108f48:	10800017 	ldw	r2,0(r2)
81108f4c:	e1bffe17 	ldw	r6,-8(fp)
81108f50:	01402c04 	movi	r5,176
81108f54:	1009883a 	mov	r4,r2
81108f58:	110a06c0 	call	8110a06c <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108f5c:	e0bfff17 	ldw	r2,-4(fp)
81108f60:	10800017 	ldw	r2,0(r2)
81108f64:	01402c44 	movi	r5,177
81108f68:	1009883a 	mov	r4,r2
81108f6c:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81108f70:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
81108f74:	e0bffe17 	ldw	r2,-8(fp)
81108f78:	10bfffec 	andhi	r2,r2,65535
81108f7c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
81108f80:	e0bfff17 	ldw	r2,-4(fp)
81108f84:	1080370b 	ldhu	r2,220(r2)
81108f88:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
81108f8c:	e0fffe17 	ldw	r3,-8(fp)
81108f90:	1884b03a 	or	r2,r3,r2
81108f94:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_TEMP_MSK);
81108f98:	e0bffe17 	ldw	r2,-8(fp)
81108f9c:	10bfffcc 	andi	r2,r2,65535
81108fa0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp << 16));
81108fa4:	e0bfff17 	ldw	r2,-4(fp)
81108fa8:	1080378b 	ldhu	r2,222(r2)
81108fac:	10bfffcc 	andi	r2,r2,65535
81108fb0:	1004943a 	slli	r2,r2,16
81108fb4:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_TEMP_MSK
81108fb8:	e0bffe17 	ldw	r2,-8(fp)
81108fbc:	10c4b03a 	or	r2,r2,r3
81108fc0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_17_REG_OFST,
81108fc4:	e0bfff17 	ldw	r2,-4(fp)
81108fc8:	10800017 	ldw	r2,0(r2)
81108fcc:	e1bffe17 	ldw	r6,-8(fp)
81108fd0:	01402c44 	movi	r5,177
81108fd4:	1009883a 	mov	r4,r2
81108fd8:	110a06c0 	call	8110a06c <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108fdc:	e0bfff17 	ldw	r2,-4(fp)
81108fe0:	10800017 	ldw	r2,0(r2)
81108fe4:	01402c84 	movi	r5,178
81108fe8:	1009883a 	mov	r4,r2
81108fec:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81108ff0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
81108ff4:	e0bffe17 	ldw	r2,-8(fp)
81108ff8:	10bfffec 	andhi	r2,r2,65535
81108ffc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
81109000:	e0bfff17 	ldw	r2,-4(fp)
81109004:	1080380b 	ldhu	r2,224(r2)
81109008:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
8110900c:	e0fffe17 	ldw	r3,-8(fp)
81109010:	1884b03a 	or	r2,r3,r2
81109014:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_TEMP_MSK);
81109018:	e0bffe17 	ldw	r2,-8(fp)
8110901c:	10bfffcc 	andi	r2,r2,65535
81109020:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp << 16));
81109024:	e0bfff17 	ldw	r2,-4(fp)
81109028:	1080388b 	ldhu	r2,226(r2)
8110902c:	10bfffcc 	andi	r2,r2,65535
81109030:	1004943a 	slli	r2,r2,16
81109034:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_TEMP_MSK
81109038:	e0bffe17 	ldw	r2,-8(fp)
8110903c:	10c4b03a 	or	r2,r2,r3
81109040:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_18_REG_OFST,
81109044:	e0bfff17 	ldw	r2,-4(fp)
81109048:	10800017 	ldw	r2,0(r2)
8110904c:	e1bffe17 	ldw	r6,-8(fp)
81109050:	01402c84 	movi	r5,178
81109054:	1009883a 	mov	r4,r2
81109058:	110a06c0 	call	8110a06c <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110905c:	e0bfff17 	ldw	r2,-4(fp)
81109060:	10800017 	ldw	r2,0(r2)
81109064:	01402cc4 	movi	r5,179
81109068:	1009883a 	mov	r4,r2
8110906c:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81109070:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
81109074:	e0bffe17 	ldw	r2,-8(fp)
81109078:	10bfffec 	andhi	r2,r2,65535
8110907c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
81109080:	e0bfff17 	ldw	r2,-4(fp)
81109084:	1080390b 	ldhu	r2,228(r2)
81109088:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
8110908c:	e0fffe17 	ldw	r3,-8(fp)
81109090:	1884b03a 	or	r2,r3,r2
81109094:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_0_MSK);
81109098:	e0bffe17 	ldw	r2,-8(fp)
8110909c:	10bfffcc 	andi	r2,r2,65535
811090a0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_0_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 << 16));
811090a4:	e0bfff17 	ldw	r2,-4(fp)
811090a8:	1080398b 	ldhu	r2,230(r2)
811090ac:	10bfffcc 	andi	r2,r2,65535
811090b0:	1004943a 	slli	r2,r2,16
811090b4:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_0_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_0_MSK
811090b8:	e0bffe17 	ldw	r2,-8(fp)
811090bc:	10c4b03a 	or	r2,r2,r3
811090c0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_19_REG_OFST,
811090c4:	e0bfff17 	ldw	r2,-4(fp)
811090c8:	10800017 	ldw	r2,0(r2)
811090cc:	e1bffe17 	ldw	r6,-8(fp)
811090d0:	01402cc4 	movi	r5,179
811090d4:	1009883a 	mov	r4,r2
811090d8:	110a06c0 	call	8110a06c <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811090dc:	e0bfff17 	ldw	r2,-4(fp)
811090e0:	10800017 	ldw	r2,0(r2)
811090e4:	01402d04 	movi	r5,180
811090e8:	1009883a 	mov	r4,r2
811090ec:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
811090f0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
811090f4:	e0bffe17 	ldw	r2,-8(fp)
811090f8:	10bfffec 	andhi	r2,r2,65535
811090fc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
81109100:	e0bfff17 	ldw	r2,-4(fp)
81109104:	10803a0b 	ldhu	r2,232(r2)
81109108:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
8110910c:	e0fffe17 	ldw	r3,-8(fp)
81109110:	1884b03a 	or	r2,r3,r2
81109114:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_2_MSK);
81109118:	e0bffe17 	ldw	r2,-8(fp)
8110911c:	10bfffcc 	andi	r2,r2,65535
81109120:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_2_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 << 16));
81109124:	e0bfff17 	ldw	r2,-4(fp)
81109128:	10803a8b 	ldhu	r2,234(r2)
8110912c:	10bfffcc 	andi	r2,r2,65535
81109130:	1004943a 	slli	r2,r2,16
81109134:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_2_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_2_MSK
81109138:	e0bffe17 	ldw	r2,-8(fp)
8110913c:	10c4b03a 	or	r2,r2,r3
81109140:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_20_REG_OFST,
81109144:	e0bfff17 	ldw	r2,-4(fp)
81109148:	10800017 	ldw	r2,0(r2)
8110914c:	e1bffe17 	ldw	r6,-8(fp)
81109150:	01402d04 	movi	r5,180
81109154:	1009883a 	mov	r4,r2
81109158:	110a06c0 	call	8110a06c <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110915c:	e0bfff17 	ldw	r2,-4(fp)
81109160:	10800017 	ldw	r2,0(r2)
81109164:	01402d44 	movi	r5,181
81109168:	1009883a 	mov	r4,r2
8110916c:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81109170:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
81109174:	e0bffe17 	ldw	r2,-8(fp)
81109178:	10bfffec 	andhi	r2,r2,65535
8110917c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
81109180:	e0bfff17 	ldw	r2,-4(fp)
81109184:	10803b0b 	ldhu	r2,236(r2)
81109188:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
8110918c:	e0fffe17 	ldw	r3,-8(fp)
81109190:	1884b03a 	or	r2,r3,r2
81109194:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_4_MSK);
81109198:	e0bffe17 	ldw	r2,-8(fp)
8110919c:	10bfffcc 	andi	r2,r2,65535
811091a0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_4_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 << 16));
811091a4:	e0bfff17 	ldw	r2,-4(fp)
811091a8:	10803b8b 	ldhu	r2,238(r2)
811091ac:	10bfffcc 	andi	r2,r2,65535
811091b0:	1004943a 	slli	r2,r2,16
811091b4:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_4_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_4_MSK
811091b8:	e0bffe17 	ldw	r2,-8(fp)
811091bc:	10c4b03a 	or	r2,r2,r3
811091c0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_21_REG_OFST,
811091c4:	e0bfff17 	ldw	r2,-4(fp)
811091c8:	10800017 	ldw	r2,0(r2)
811091cc:	e1bffe17 	ldw	r6,-8(fp)
811091d0:	01402d44 	movi	r5,181
811091d4:	1009883a 	mov	r4,r2
811091d8:	110a06c0 	call	8110a06c <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811091dc:	e0bfff17 	ldw	r2,-4(fp)
811091e0:	10800017 	ldw	r2,0(r2)
811091e4:	01402d84 	movi	r5,182
811091e8:	1009883a 	mov	r4,r2
811091ec:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
811091f0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
811091f4:	e0bffe17 	ldw	r2,-8(fp)
811091f8:	10bfffec 	andhi	r2,r2,65535
811091fc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
81109200:	e0bfff17 	ldw	r2,-4(fp)
81109204:	10803c0b 	ldhu	r2,240(r2)
81109208:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
8110920c:	e0fffe17 	ldw	r3,-8(fp)
81109210:	1884b03a 	or	r2,r3,r2
81109214:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_6_MSK);
81109218:	e0bffe17 	ldw	r2,-8(fp)
8110921c:	10bfffcc 	andi	r2,r2,65535
81109220:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_6_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 << 16));
81109224:	e0bfff17 	ldw	r2,-4(fp)
81109228:	10803c8b 	ldhu	r2,242(r2)
8110922c:	10bfffcc 	andi	r2,r2,65535
81109230:	1004943a 	slli	r2,r2,16
81109234:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_6_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_6_MSK
81109238:	e0bffe17 	ldw	r2,-8(fp)
8110923c:	10c4b03a 	or	r2,r2,r3
81109240:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_22_REG_OFST,
81109244:	e0bfff17 	ldw	r2,-4(fp)
81109248:	10800017 	ldw	r2,0(r2)
8110924c:	e1bffe17 	ldw	r6,-8(fp)
81109250:	01402d84 	movi	r5,182
81109254:	1009883a 	mov	r4,r2
81109258:	110a06c0 	call	8110a06c <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110925c:	e0bfff17 	ldw	r2,-4(fp)
81109260:	10800017 	ldw	r2,0(r2)
81109264:	01402dc4 	movi	r5,183
81109268:	1009883a 	mov	r4,r2
8110926c:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81109270:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
81109274:	e0bffe17 	ldw	r2,-8(fp)
81109278:	10bfffec 	andhi	r2,r2,65535
8110927c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
81109280:	e0bfff17 	ldw	r2,-4(fp)
81109284:	10803d0b 	ldhu	r2,244(r2)
81109288:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
8110928c:	e0fffe17 	ldw	r3,-8(fp)
81109290:	1884b03a 	or	r2,r3,r2
81109294:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_8_MSK);
81109298:	e0bffe17 	ldw	r2,-8(fp)
8110929c:	10bfffcc 	andi	r2,r2,65535
811092a0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_8_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 << 16));
811092a4:	e0bfff17 	ldw	r2,-4(fp)
811092a8:	10803d8b 	ldhu	r2,246(r2)
811092ac:	10bfffcc 	andi	r2,r2,65535
811092b0:	1004943a 	slli	r2,r2,16
811092b4:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_8_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_8_MSK
811092b8:	e0bffe17 	ldw	r2,-8(fp)
811092bc:	10c4b03a 	or	r2,r2,r3
811092c0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_23_REG_OFST,
811092c4:	e0bfff17 	ldw	r2,-4(fp)
811092c8:	10800017 	ldw	r2,0(r2)
811092cc:	e1bffe17 	ldw	r6,-8(fp)
811092d0:	01402dc4 	movi	r5,183
811092d4:	1009883a 	mov	r4,r2
811092d8:	110a06c0 	call	8110a06c <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811092dc:	e0bfff17 	ldw	r2,-4(fp)
811092e0:	10800017 	ldw	r2,0(r2)
811092e4:	01402e04 	movi	r5,184
811092e8:	1009883a 	mov	r4,r2
811092ec:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
811092f0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
811092f4:	e0bffe17 	ldw	r2,-8(fp)
811092f8:	10bfffec 	andhi	r2,r2,65535
811092fc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
81109300:	e0bfff17 	ldw	r2,-4(fp)
81109304:	10803e0b 	ldhu	r2,248(r2)
81109308:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
8110930c:	e0fffe17 	ldw	r3,-8(fp)
81109310:	1884b03a 	or	r2,r3,r2
81109314:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_10_MSK);
81109318:	e0bffe17 	ldw	r2,-8(fp)
8110931c:	10bfffcc 	andi	r2,r2,65535
81109320:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_10_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 << 16));
81109324:	e0bfff17 	ldw	r2,-4(fp)
81109328:	10803e8b 	ldhu	r2,250(r2)
8110932c:	10bfffcc 	andi	r2,r2,65535
81109330:	1004943a 	slli	r2,r2,16
81109334:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_10_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_10_MSK
81109338:	e0bffe17 	ldw	r2,-8(fp)
8110933c:	10c4b03a 	or	r2,r2,r3
81109340:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_24_REG_OFST,
81109344:	e0bfff17 	ldw	r2,-4(fp)
81109348:	10800017 	ldw	r2,0(r2)
8110934c:	e1bffe17 	ldw	r6,-8(fp)
81109350:	01402e04 	movi	r5,184
81109354:	1009883a 	mov	r4,r2
81109358:	110a06c0 	call	8110a06c <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110935c:	e0bfff17 	ldw	r2,-4(fp)
81109360:	10800017 	ldw	r2,0(r2)
81109364:	01402e44 	movi	r5,185
81109368:	1009883a 	mov	r4,r2
8110936c:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81109370:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
81109374:	e0bffe17 	ldw	r2,-8(fp)
81109378:	10bfffec 	andhi	r2,r2,65535
8110937c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
81109380:	e0bfff17 	ldw	r2,-4(fp)
81109384:	10803f0b 	ldhu	r2,252(r2)
81109388:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
8110938c:	e0fffe17 	ldw	r3,-8(fp)
81109390:	1884b03a 	or	r2,r3,r2
81109394:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_12_MSK);
81109398:	e0bffe17 	ldw	r2,-8(fp)
8110939c:	10bfffcc 	andi	r2,r2,65535
811093a0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_12_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 << 16));
811093a4:	e0bfff17 	ldw	r2,-4(fp)
811093a8:	10803f8b 	ldhu	r2,254(r2)
811093ac:	10bfffcc 	andi	r2,r2,65535
811093b0:	1004943a 	slli	r2,r2,16
811093b4:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_12_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_12_MSK
811093b8:	e0bffe17 	ldw	r2,-8(fp)
811093bc:	10c4b03a 	or	r2,r2,r3
811093c0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_25_REG_OFST,
811093c4:	e0bfff17 	ldw	r2,-4(fp)
811093c8:	10800017 	ldw	r2,0(r2)
811093cc:	e1bffe17 	ldw	r6,-8(fp)
811093d0:	01402e44 	movi	r5,185
811093d4:	1009883a 	mov	r4,r2
811093d8:	110a06c0 	call	8110a06c <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811093dc:	e0bfff17 	ldw	r2,-4(fp)
811093e0:	10800017 	ldw	r2,0(r2)
811093e4:	01402e84 	movi	r5,186
811093e8:	1009883a 	mov	r4,r2
811093ec:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
811093f0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
811093f4:	e0bffe17 	ldw	r2,-8(fp)
811093f8:	10bfffec 	andhi	r2,r2,65535
811093fc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
81109400:	e0bfff17 	ldw	r2,-4(fp)
81109404:	1080400b 	ldhu	r2,256(r2)
81109408:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
8110940c:	e0fffe17 	ldw	r3,-8(fp)
81109410:	1884b03a 	or	r2,r3,r2
81109414:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_14_MSK);
81109418:	e0bffe17 	ldw	r2,-8(fp)
8110941c:	10bfffcc 	andi	r2,r2,65535
81109420:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_14_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 << 16));
81109424:	e0bfff17 	ldw	r2,-4(fp)
81109428:	1080408b 	ldhu	r2,258(r2)
8110942c:	10bfffcc 	andi	r2,r2,65535
81109430:	1004943a 	slli	r2,r2,16
81109434:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_14_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_14_MSK
81109438:	e0bffe17 	ldw	r2,-8(fp)
8110943c:	10c4b03a 	or	r2,r2,r3
81109440:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_26_REG_OFST,
81109444:	e0bfff17 	ldw	r2,-4(fp)
81109448:	10800017 	ldw	r2,0(r2)
8110944c:	e1bffe17 	ldw	r6,-8(fp)
81109450:	01402e84 	movi	r5,186
81109454:	1009883a 	mov	r4,r2
81109458:	110a06c0 	call	8110a06c <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110945c:	e0bfff17 	ldw	r2,-4(fp)
81109460:	10800017 	ldw	r2,0(r2)
81109464:	01402ec4 	movi	r5,187
81109468:	1009883a 	mov	r4,r2
8110946c:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81109470:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
81109474:	e0bffe17 	ldw	r2,-8(fp)
81109478:	10bfffec 	andhi	r2,r2,65535
8110947c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
81109480:	e0bfff17 	ldw	r2,-4(fp)
81109484:	1080410b 	ldhu	r2,260(r2)
81109488:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
8110948c:	e0fffe17 	ldw	r3,-8(fp)
81109490:	1884b03a 	or	r2,r3,r2
81109494:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT0_MSK);
81109498:	e0bffe17 	ldw	r2,-8(fp)
8110949c:	10bfffcc 	andi	r2,r2,65535
811094a0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT0_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 << 16));
811094a4:	e0bfff17 	ldw	r2,-4(fp)
811094a8:	1080418b 	ldhu	r2,262(r2)
811094ac:	10bfffcc 	andi	r2,r2,65535
811094b0:	1004943a 	slli	r2,r2,16
811094b4:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT0_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT0_MSK
811094b8:	e0bffe17 	ldw	r2,-8(fp)
811094bc:	10c4b03a 	or	r2,r2,r3
811094c0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_27_REG_OFST,
811094c4:	e0bfff17 	ldw	r2,-4(fp)
811094c8:	10800017 	ldw	r2,0(r2)
811094cc:	e1bffe17 	ldw	r6,-8(fp)
811094d0:	01402ec4 	movi	r5,187
811094d4:	1009883a 	mov	r4,r2
811094d8:	110a06c0 	call	8110a06c <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811094dc:	e0bfff17 	ldw	r2,-4(fp)
811094e0:	10800017 	ldw	r2,0(r2)
811094e4:	01402f04 	movi	r5,188
811094e8:	1009883a 	mov	r4,r2
811094ec:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
811094f0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
811094f4:	e0bffe17 	ldw	r2,-8(fp)
811094f8:	10bfffec 	andhi	r2,r2,65535
811094fc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
81109500:	e0bfff17 	ldw	r2,-4(fp)
81109504:	1080420b 	ldhu	r2,264(r2)
81109508:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
8110950c:	e0fffe17 	ldw	r3,-8(fp)
81109510:	1884b03a 	or	r2,r3,r2
81109514:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT2_MSK);
81109518:	e0bffe17 	ldw	r2,-8(fp)
8110951c:	10bfffcc 	andi	r2,r2,65535
81109520:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT2_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 << 16));
81109524:	e0bfff17 	ldw	r2,-4(fp)
81109528:	1080428b 	ldhu	r2,266(r2)
8110952c:	10bfffcc 	andi	r2,r2,65535
81109530:	1004943a 	slli	r2,r2,16
81109534:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT2_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT2_MSK
81109538:	e0bffe17 	ldw	r2,-8(fp)
8110953c:	10c4b03a 	or	r2,r2,r3
81109540:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_28_REG_OFST,
81109544:	e0bfff17 	ldw	r2,-4(fp)
81109548:	10800017 	ldw	r2,0(r2)
8110954c:	e1bffe17 	ldw	r6,-8(fp)
81109550:	01402f04 	movi	r5,188
81109554:	1009883a 	mov	r4,r2
81109558:	110a06c0 	call	8110a06c <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110955c:	e0bfff17 	ldw	r2,-4(fp)
81109560:	10800017 	ldw	r2,0(r2)
81109564:	01402f44 	movi	r5,189
81109568:	1009883a 	mov	r4,r2
8110956c:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81109570:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
81109574:	e0bffe17 	ldw	r2,-8(fp)
81109578:	10bfffec 	andhi	r2,r2,65535
8110957c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
81109580:	e0bfff17 	ldw	r2,-4(fp)
81109584:	1080430b 	ldhu	r2,268(r2)
81109588:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
8110958c:	e0fffe17 	ldw	r3,-8(fp)
81109590:	1884b03a 	or	r2,r3,r2
81109594:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT4_MSK);
81109598:	e0bffe17 	ldw	r2,-8(fp)
8110959c:	10bfffcc 	andi	r2,r2,65535
811095a0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT4_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 << 16));
811095a4:	e0bfff17 	ldw	r2,-4(fp)
811095a8:	1080438b 	ldhu	r2,270(r2)
811095ac:	10bfffcc 	andi	r2,r2,65535
811095b0:	1004943a 	slli	r2,r2,16
811095b4:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT4_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT4_MSK
811095b8:	e0bffe17 	ldw	r2,-8(fp)
811095bc:	10c4b03a 	or	r2,r2,r3
811095c0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_29_REG_OFST,
811095c4:	e0bfff17 	ldw	r2,-4(fp)
811095c8:	10800017 	ldw	r2,0(r2)
811095cc:	e1bffe17 	ldw	r6,-8(fp)
811095d0:	01402f44 	movi	r5,189
811095d4:	1009883a 	mov	r4,r2
811095d8:	110a06c0 	call	8110a06c <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811095dc:	e0bfff17 	ldw	r2,-4(fp)
811095e0:	10800017 	ldw	r2,0(r2)
811095e4:	01402f84 	movi	r5,190
811095e8:	1009883a 	mov	r4,r2
811095ec:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
811095f0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
811095f4:	e0bffe17 	ldw	r2,-8(fp)
811095f8:	10bfffec 	andhi	r2,r2,65535
811095fc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
81109600:	e0bfff17 	ldw	r2,-4(fp)
81109604:	1080440b 	ldhu	r2,272(r2)
81109608:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
8110960c:	e0fffe17 	ldw	r3,-8(fp)
81109610:	1884b03a 	or	r2,r3,r2
81109614:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT6_MSK);
81109618:	e0bffe17 	ldw	r2,-8(fp)
8110961c:	10bfffcc 	andi	r2,r2,65535
81109620:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT6_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 << 16));
81109624:	e0bfff17 	ldw	r2,-4(fp)
81109628:	1080448b 	ldhu	r2,274(r2)
8110962c:	10bfffcc 	andi	r2,r2,65535
81109630:	1004943a 	slli	r2,r2,16
81109634:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT6_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT6_MSK
81109638:	e0bffe17 	ldw	r2,-8(fp)
8110963c:	10c4b03a 	or	r2,r2,r3
81109640:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_30_REG_OFST,
81109644:	e0bfff17 	ldw	r2,-4(fp)
81109648:	10800017 	ldw	r2,0(r2)
8110964c:	e1bffe17 	ldw	r6,-8(fp)
81109650:	01402f84 	movi	r5,190
81109654:	1009883a 	mov	r4,r2
81109658:	110a06c0 	call	8110a06c <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110965c:	e0bfff17 	ldw	r2,-4(fp)
81109660:	10800017 	ldw	r2,0(r2)
81109664:	01402fc4 	movi	r5,191
81109668:	1009883a 	mov	r4,r2
8110966c:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81109670:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
81109674:	e0bffe17 	ldw	r2,-8(fp)
81109678:	10bfffec 	andhi	r2,r2,65535
8110967c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
81109680:	e0bfff17 	ldw	r2,-4(fp)
81109684:	1080450b 	ldhu	r2,276(r2)
81109688:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
8110968c:	e0fffe17 	ldw	r3,-8(fp)
81109690:	1884b03a 	or	r2,r3,r2
81109694:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
		uliReg &= (~COMM_RMAP_ZERO_HIRES_AMP_MSK);
81109698:	e0bffe17 	ldw	r2,-8(fp)
8110969c:	10bfffcc 	andi	r2,r2,65535
811096a0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_ZERO_HIRES_AMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp << 16));
811096a4:	e0bfff17 	ldw	r2,-4(fp)
811096a8:	1080458b 	ldhu	r2,278(r2)
811096ac:	10bfffcc 	andi	r2,r2,65535
811096b0:	1004943a 	slli	r2,r2,16
811096b4:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
		uliReg &= (~COMM_RMAP_ZERO_HIRES_AMP_MSK);
		uliReg |= (COMM_RMAP_ZERO_HIRES_AMP_MSK
811096b8:	e0bffe17 	ldw	r2,-8(fp)
811096bc:	10c4b03a 	or	r2,r2,r3
811096c0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_31_REG_OFST,
811096c4:	e0bfff17 	ldw	r2,-4(fp)
811096c8:	10800017 	ldw	r2,0(r2)
811096cc:	e1bffe17 	ldw	r6,-8(fp)
811096d0:	01402fc4 	movi	r5,191
811096d4:	1009883a 	mov	r4,r2
811096d8:	110a06c0 	call	8110a06c <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
811096dc:	00800044 	movi	r2,1
811096e0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811096e4:	e0bffd17 	ldw	r2,-12(fp)
}
811096e8:	e037883a 	mov	sp,fp
811096ec:	dfc00117 	ldw	ra,4(sp)
811096f0:	df000017 	ldw	fp,0(sp)
811096f4:	dec00204 	addi	sp,sp,8
811096f8:	f800283a 	ret

811096fc <bRmapGetRmapMemHKArea>:

bool bRmapGetRmapMemHKArea(TRmapChannel *pxRmapCh) {
811096fc:	defffb04 	addi	sp,sp,-20
81109700:	de00012e 	bgeu	sp,et,81109708 <bRmapGetRmapMemHKArea+0xc>
81109704:	003b68fa 	trap	3
81109708:	dfc00415 	stw	ra,16(sp)
8110970c:	df000315 	stw	fp,12(sp)
81109710:	df000304 	addi	fp,sp,12
81109714:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81109718:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110971c:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81109720:	e0bfff17 	ldw	r2,-4(fp)
81109724:	1001e226 	beq	r2,zero,81109eb0 <bRmapGetRmapMemHKArea+0x7b4>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109728:	e0bfff17 	ldw	r2,-4(fp)
8110972c:	10800017 	ldw	r2,0(r2)
81109730:	01402804 	movi	r5,160
81109734:	1009883a 	mov	r4,r2
81109738:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
8110973c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_0_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE = (alt_u16) ((uliReg
81109740:	e0bffe17 	ldw	r2,-8(fp)
81109744:	1007883a 	mov	r3,r2
81109748:	e0bfff17 	ldw	r2,-4(fp)
8110974c:	10c0260d 	sth	r3,152(r2)
				& COMM_RMAP_HK_CCD1_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VOD_F_MSK) >> 16);
81109750:	e0bffe17 	ldw	r2,-8(fp)
81109754:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_0_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF = (alt_u16) ((uliReg
81109758:	1007883a 	mov	r3,r2
8110975c:	e0bfff17 	ldw	r2,-4(fp)
81109760:	10c0268d 	sth	r3,154(r2)
				& COMM_RMAP_HK_CCD1_VOD_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109764:	e0bfff17 	ldw	r2,-4(fp)
81109768:	10800017 	ldw	r2,0(r2)
8110976c:	01402844 	movi	r5,161
81109770:	1009883a 	mov	r4,r2
81109774:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81109778:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_1_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon = (alt_u16) ((uliReg
8110977c:	e0bffe17 	ldw	r2,-8(fp)
81109780:	1007883a 	mov	r3,r2
81109784:	e0bfff17 	ldw	r2,-4(fp)
81109788:	10c0270d 	sth	r3,156(r2)
				& COMM_RMAP_HK_CCD1_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VOD_E_MSK) >> 16);
8110978c:	e0bffe17 	ldw	r2,-8(fp)
81109790:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_1_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE = (alt_u16) ((uliReg
81109794:	1007883a 	mov	r3,r2
81109798:	e0bfff17 	ldw	r2,-4(fp)
8110979c:	10c0278d 	sth	r3,158(r2)
				& COMM_RMAP_HK_CCD2_VOD_E_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811097a0:	e0bfff17 	ldw	r2,-4(fp)
811097a4:	10800017 	ldw	r2,0(r2)
811097a8:	01402884 	movi	r5,162
811097ac:	1009883a 	mov	r4,r2
811097b0:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
811097b4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_2_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF = (alt_u16) ((uliReg
811097b8:	e0bffe17 	ldw	r2,-8(fp)
811097bc:	1007883a 	mov	r3,r2
811097c0:	e0bfff17 	ldw	r2,-4(fp)
811097c4:	10c0280d 	sth	r3,160(r2)
				& COMM_RMAP_HK_CCD2_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VRD_MON_MSK) >> 16);
811097c8:	e0bffe17 	ldw	r2,-8(fp)
811097cc:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_2_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon = (alt_u16) ((uliReg
811097d0:	1007883a 	mov	r3,r2
811097d4:	e0bfff17 	ldw	r2,-4(fp)
811097d8:	10c0288d 	sth	r3,162(r2)
				& COMM_RMAP_HK_CCD2_VRD_MON_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811097dc:	e0bfff17 	ldw	r2,-4(fp)
811097e0:	10800017 	ldw	r2,0(r2)
811097e4:	014028c4 	movi	r5,163
811097e8:	1009883a 	mov	r4,r2
811097ec:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
811097f0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_3_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE = (alt_u16) ((uliReg
811097f4:	e0bffe17 	ldw	r2,-8(fp)
811097f8:	1007883a 	mov	r3,r2
811097fc:	e0bfff17 	ldw	r2,-4(fp)
81109800:	10c0290d 	sth	r3,164(r2)
				& COMM_RMAP_HK_CCD3_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VOD_F_MSK) >> 16);
81109804:	e0bffe17 	ldw	r2,-8(fp)
81109808:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_3_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF = (alt_u16) ((uliReg
8110980c:	1007883a 	mov	r3,r2
81109810:	e0bfff17 	ldw	r2,-4(fp)
81109814:	10c0298d 	sth	r3,166(r2)
				& COMM_RMAP_HK_CCD3_VOD_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109818:	e0bfff17 	ldw	r2,-4(fp)
8110981c:	10800017 	ldw	r2,0(r2)
81109820:	01402904 	movi	r5,164
81109824:	1009883a 	mov	r4,r2
81109828:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
8110982c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_4_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon = (alt_u16) ((uliReg
81109830:	e0bffe17 	ldw	r2,-8(fp)
81109834:	1007883a 	mov	r3,r2
81109838:	e0bfff17 	ldw	r2,-4(fp)
8110983c:	10c02a0d 	sth	r3,168(r2)
				& COMM_RMAP_HK_CCD3_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VOD_E_MSK) >> 16);
81109840:	e0bffe17 	ldw	r2,-8(fp)
81109844:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_4_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE = (alt_u16) ((uliReg
81109848:	1007883a 	mov	r3,r2
8110984c:	e0bfff17 	ldw	r2,-4(fp)
81109850:	10c02a8d 	sth	r3,170(r2)
				& COMM_RMAP_HK_CCD4_VOD_E_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109854:	e0bfff17 	ldw	r2,-4(fp)
81109858:	10800017 	ldw	r2,0(r2)
8110985c:	01402944 	movi	r5,165
81109860:	1009883a 	mov	r4,r2
81109864:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81109868:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_5_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF = (alt_u16) ((uliReg
8110986c:	e0bffe17 	ldw	r2,-8(fp)
81109870:	1007883a 	mov	r3,r2
81109874:	e0bfff17 	ldw	r2,-4(fp)
81109878:	10c02b0d 	sth	r3,172(r2)
				& COMM_RMAP_HK_CCD4_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VRD_MON_MSK) >> 16);
8110987c:	e0bffe17 	ldw	r2,-8(fp)
81109880:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_5_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon = (alt_u16) ((uliReg
81109884:	1007883a 	mov	r3,r2
81109888:	e0bfff17 	ldw	r2,-4(fp)
8110988c:	10c02b8d 	sth	r3,174(r2)
				& COMM_RMAP_HK_CCD4_VRD_MON_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109890:	e0bfff17 	ldw	r2,-4(fp)
81109894:	10800017 	ldw	r2,0(r2)
81109898:	01402984 	movi	r5,166
8110989c:	1009883a 	mov	r4,r2
811098a0:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
811098a4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_6_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccd = (alt_u16) ((uliReg
811098a8:	e0bffe17 	ldw	r2,-8(fp)
811098ac:	1007883a 	mov	r3,r2
811098b0:	e0bfff17 	ldw	r2,-4(fp)
811098b4:	10c02c0d 	sth	r3,176(r2)
				& COMM_RMAP_HK_VCCD_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclk = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VRCLK_MSK) >> 16);
811098b8:	e0bffe17 	ldw	r2,-8(fp)
811098bc:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_6_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccd = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCCD_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclk = (alt_u16) ((uliReg
811098c0:	1007883a 	mov	r3,r2
811098c4:	e0bfff17 	ldw	r2,-4(fp)
811098c8:	10c02c8d 	sth	r3,178(r2)
				& COMM_RMAP_HK_VRCLK_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811098cc:	e0bfff17 	ldw	r2,-4(fp)
811098d0:	10800017 	ldw	r2,0(r2)
811098d4:	014029c4 	movi	r5,167
811098d8:	1009883a 	mov	r4,r2
811098dc:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
811098e0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_7_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkViclk = (alt_u16) ((uliReg
811098e4:	e0bffe17 	ldw	r2,-8(fp)
811098e8:	1007883a 	mov	r3,r2
811098ec:	e0bfff17 	ldw	r2,-4(fp)
811098f0:	10c02d0d 	sth	r3,180(r2)
				& COMM_RMAP_HK_VICLK_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclkLow = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VRCLK_LOW_MSK) >> 16);
811098f4:	e0bffe17 	ldw	r2,-8(fp)
811098f8:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_7_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkViclk = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VICLK_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclkLow = (alt_u16) ((uliReg
811098fc:	1007883a 	mov	r3,r2
81109900:	e0bfff17 	ldw	r2,-4(fp)
81109904:	10c02d8d 	sth	r3,182(r2)
				& COMM_RMAP_HK_VRCLK_LOW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109908:	e0bfff17 	ldw	r2,-4(fp)
8110990c:	10800017 	ldw	r2,0(r2)
81109910:	01402a04 	movi	r5,168
81109914:	1009883a 	mov	r4,r2
81109918:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
8110991c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_8_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk5vbPos = (alt_u16) ((uliReg
81109920:	e0bffe17 	ldw	r2,-8(fp)
81109924:	1007883a 	mov	r3,r2
81109928:	e0bfff17 	ldw	r2,-4(fp)
8110992c:	10c02e0d 	sth	r3,184(r2)
				& COMM_RMAP_HK_5VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vbNeg = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VB_NEG_MSK) >> 16);
81109930:	e0bffe17 	ldw	r2,-8(fp)
81109934:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_8_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk5vbPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vbNeg = (alt_u16) ((uliReg
81109938:	1007883a 	mov	r3,r2
8110993c:	e0bfff17 	ldw	r2,-4(fp)
81109940:	10c02e8d 	sth	r3,186(r2)
				& COMM_RMAP_HK_5VB_NEG_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109944:	e0bfff17 	ldw	r2,-4(fp)
81109948:	10800017 	ldw	r2,0(r2)
8110994c:	01402a44 	movi	r5,169
81109950:	1009883a 	mov	r4,r2
81109954:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81109958:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_9_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vbPos = (alt_u16) ((uliReg
8110995c:	e0bffe17 	ldw	r2,-8(fp)
81109960:	1007883a 	mov	r3,r2
81109964:	e0bfff17 	ldw	r2,-4(fp)
81109968:	10c02f0d 	sth	r3,188(r2)
				& COMM_RMAP_HK_3_3VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vaPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_2_5VA_POS_MSK) >> 16);
8110996c:	e0bffe17 	ldw	r2,-8(fp)
81109970:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_9_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vbPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_3_3VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vaPos = (alt_u16) ((uliReg
81109974:	1007883a 	mov	r3,r2
81109978:	e0bfff17 	ldw	r2,-4(fp)
8110997c:	10c02f8d 	sth	r3,190(r2)
				& COMM_RMAP_HK_2_5VA_POS_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109980:	e0bfff17 	ldw	r2,-4(fp)
81109984:	10800017 	ldw	r2,0(r2)
81109988:	01402a84 	movi	r5,170
8110998c:	1009883a 	mov	r4,r2
81109990:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81109994:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_10_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vdPos = (alt_u16) ((uliReg
81109998:	e0bffe17 	ldw	r2,-8(fp)
8110999c:	1007883a 	mov	r3,r2
811099a0:	e0bfff17 	ldw	r2,-4(fp)
811099a4:	10c0300d 	sth	r3,192(r2)
				& COMM_RMAP_HK_3_3VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_2_5VD_POS_MSK) >> 16);
811099a8:	e0bffe17 	ldw	r2,-8(fp)
811099ac:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_10_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_3_3VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vdPos = (alt_u16) ((uliReg
811099b0:	1007883a 	mov	r3,r2
811099b4:	e0bfff17 	ldw	r2,-4(fp)
811099b8:	10c0308d 	sth	r3,194(r2)
				& COMM_RMAP_HK_2_5VD_POS_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811099bc:	e0bfff17 	ldw	r2,-4(fp)
811099c0:	10800017 	ldw	r2,0(r2)
811099c4:	01402ac4 	movi	r5,171
811099c8:	1009883a 	mov	r4,r2
811099cc:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
811099d0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_11_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk15vdPos = (alt_u16) ((uliReg
811099d4:	e0bffe17 	ldw	r2,-8(fp)
811099d8:	1007883a 	mov	r3,r2
811099dc:	e0bfff17 	ldw	r2,-4(fp)
811099e0:	10c0310d 	sth	r3,196(r2)
				& COMM_RMAP_HK_1_5VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vref = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VREF_MSK) >> 16);
811099e4:	e0bffe17 	ldw	r2,-8(fp)
811099e8:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_11_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk15vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_1_5VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vref = (alt_u16) ((uliReg
811099ec:	1007883a 	mov	r3,r2
811099f0:	e0bfff17 	ldw	r2,-4(fp)
811099f4:	10c0318d 	sth	r3,198(r2)
				& COMM_RMAP_HK_5VREF_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811099f8:	e0bfff17 	ldw	r2,-4(fp)
811099fc:	10800017 	ldw	r2,0(r2)
81109a00:	01402b04 	movi	r5,172
81109a04:	1009883a 	mov	r4,r2
81109a08:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81109a0c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_12_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw = (alt_u16) ((uliReg
81109a10:	e0bffe17 	ldw	r2,-8(fp)
81109a14:	1007883a 	mov	r3,r2
81109a18:	e0bfff17 	ldw	r2,-4(fp)
81109a1c:	10c0320d 	sth	r3,200(r2)
				& COMM_RMAP_HK_VCCD_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCLK_POS_RAW_MSK) >> 16);
81109a20:	e0bffe17 	ldw	r2,-8(fp)
81109a24:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_12_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCCD_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw = (alt_u16) ((uliReg
81109a28:	1007883a 	mov	r3,r2
81109a2c:	e0bfff17 	ldw	r2,-4(fp)
81109a30:	10c0328d 	sth	r3,202(r2)
				& COMM_RMAP_HK_VCLK_POS_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109a34:	e0bfff17 	ldw	r2,-4(fp)
81109a38:	10800017 	ldw	r2,0(r2)
81109a3c:	01402b44 	movi	r5,173
81109a40:	1009883a 	mov	r4,r2
81109a44:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81109a48:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_13_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw = (alt_u16) ((uliReg
81109a4c:	e0bffe17 	ldw	r2,-8(fp)
81109a50:	1007883a 	mov	r3,r2
81109a54:	e0bfff17 	ldw	r2,-4(fp)
81109a58:	10c0330d 	sth	r3,204(r2)
				& COMM_RMAP_HK_VAN1_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN3_NEG_RAW_MSK) >> 16);
81109a5c:	e0bffe17 	ldw	r2,-8(fp)
81109a60:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_13_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN1_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw = (alt_u16) ((uliReg
81109a64:	1007883a 	mov	r3,r2
81109a68:	e0bfff17 	ldw	r2,-4(fp)
81109a6c:	10c0338d 	sth	r3,206(r2)
				& COMM_RMAP_HK_VAN3_NEG_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109a70:	e0bfff17 	ldw	r2,-4(fp)
81109a74:	10800017 	ldw	r2,0(r2)
81109a78:	01402b84 	movi	r5,174
81109a7c:	1009883a 	mov	r4,r2
81109a80:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81109a84:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_14_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw = (alt_u16) ((uliReg
81109a88:	e0bffe17 	ldw	r2,-8(fp)
81109a8c:	1007883a 	mov	r3,r2
81109a90:	e0bfff17 	ldw	r2,-4(fp)
81109a94:	10c0340d 	sth	r3,208(r2)
				& COMM_RMAP_HK_VAN2_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VDIG_FPGA_RAW_MSK) >> 16);
81109a98:	e0bffe17 	ldw	r2,-8(fp)
81109a9c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_14_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN2_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw = (alt_u16) ((uliReg
81109aa0:	1007883a 	mov	r3,r2
81109aa4:	e0bfff17 	ldw	r2,-4(fp)
81109aa8:	10c0348d 	sth	r3,210(r2)
				& COMM_RMAP_HK_VDIG_FPGA_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109aac:	e0bfff17 	ldw	r2,-4(fp)
81109ab0:	10800017 	ldw	r2,0(r2)
81109ab4:	01402bc4 	movi	r5,175
81109ab8:	1009883a 	mov	r4,r2
81109abc:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81109ac0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_15_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw = (alt_u16) ((uliReg
81109ac4:	e0bffe17 	ldw	r2,-8(fp)
81109ac8:	1007883a 	mov	r3,r2
81109acc:	e0bfff17 	ldw	r2,-4(fp)
81109ad0:	10c0350d 	sth	r3,212(r2)
				& COMM_RMAP_HK_VDIG_SPW_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkViclkLow = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VICLK_LOW_MSK) >> 16);
81109ad4:	e0bffe17 	ldw	r2,-8(fp)
81109ad8:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_15_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VDIG_SPW_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkViclkLow = (alt_u16) ((uliReg
81109adc:	1007883a 	mov	r3,r2
81109ae0:	e0bfff17 	ldw	r2,-4(fp)
81109ae4:	10c0358d 	sth	r3,214(r2)
				& COMM_RMAP_HK_VICLK_LOW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109ae8:	e0bfff17 	ldw	r2,-4(fp)
81109aec:	10800017 	ldw	r2,0(r2)
81109af0:	01402c04 	movi	r5,176
81109af4:	1009883a 	mov	r4,r2
81109af8:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81109afc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_16_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE = (alt_u16) ((uliReg
81109b00:	e0bffe17 	ldw	r2,-8(fp)
81109b04:	1007883a 	mov	r3,r2
81109b08:	e0bfff17 	ldw	r2,-4(fp)
81109b0c:	10c0360d 	sth	r3,216(r2)
				& COMM_RMAP_HK_ADC_TEMP_A_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_ADC_TEMP_A_F_MSK) >> 16);
81109b10:	e0bffe17 	ldw	r2,-8(fp)
81109b14:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_16_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_ADC_TEMP_A_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF = (alt_u16) ((uliReg
81109b18:	1007883a 	mov	r3,r2
81109b1c:	e0bfff17 	ldw	r2,-4(fp)
81109b20:	10c0368d 	sth	r3,218(r2)
				& COMM_RMAP_HK_ADC_TEMP_A_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109b24:	e0bfff17 	ldw	r2,-4(fp)
81109b28:	10800017 	ldw	r2,0(r2)
81109b2c:	01402c44 	movi	r5,177
81109b30:	1009883a 	mov	r4,r2
81109b34:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81109b38:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_17_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp = (alt_u16) ((uliReg
81109b3c:	e0bffe17 	ldw	r2,-8(fp)
81109b40:	1007883a 	mov	r3,r2
81109b44:	e0bfff17 	ldw	r2,-4(fp)
81109b48:	10c0370d 	sth	r3,220(r2)
				& COMM_RMAP_HK_CCD1_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_TEMP_MSK) >> 16);
81109b4c:	e0bffe17 	ldw	r2,-8(fp)
81109b50:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_17_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp = (alt_u16) ((uliReg
81109b54:	1007883a 	mov	r3,r2
81109b58:	e0bfff17 	ldw	r2,-4(fp)
81109b5c:	10c0378d 	sth	r3,222(r2)
				& COMM_RMAP_HK_CCD2_TEMP_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109b60:	e0bfff17 	ldw	r2,-4(fp)
81109b64:	10800017 	ldw	r2,0(r2)
81109b68:	01402c84 	movi	r5,178
81109b6c:	1009883a 	mov	r4,r2
81109b70:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81109b74:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_18_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp = (alt_u16) ((uliReg
81109b78:	e0bffe17 	ldw	r2,-8(fp)
81109b7c:	1007883a 	mov	r3,r2
81109b80:	e0bfff17 	ldw	r2,-4(fp)
81109b84:	10c0380d 	sth	r3,224(r2)
				& COMM_RMAP_HK_CCD3_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_TEMP_MSK) >> 16);
81109b88:	e0bffe17 	ldw	r2,-8(fp)
81109b8c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_18_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp = (alt_u16) ((uliReg
81109b90:	1007883a 	mov	r3,r2
81109b94:	e0bfff17 	ldw	r2,-4(fp)
81109b98:	10c0388d 	sth	r3,226(r2)
				& COMM_RMAP_HK_CCD4_TEMP_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109b9c:	e0bfff17 	ldw	r2,-4(fp)
81109ba0:	10800017 	ldw	r2,0(r2)
81109ba4:	01402cc4 	movi	r5,179
81109ba8:	1009883a 	mov	r4,r2
81109bac:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81109bb0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_19_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkWp605Spare = (alt_u16) ((uliReg
81109bb4:	e0bffe17 	ldw	r2,-8(fp)
81109bb8:	1007883a 	mov	r3,r2
81109bbc:	e0bfff17 	ldw	r2,-4(fp)
81109bc0:	10c0390d 	sth	r3,228(r2)
				& COMM_RMAP_HK_WP605_SPARE_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_0_MSK) >> 16);
81109bc4:	e0bffe17 	ldw	r2,-8(fp)
81109bc8:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_19_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkWp605Spare = (alt_u16) ((uliReg
				& COMM_RMAP_HK_WP605_SPARE_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 = (alt_u16) ((uliReg
81109bcc:	1007883a 	mov	r3,r2
81109bd0:	e0bfff17 	ldw	r2,-4(fp)
81109bd4:	10c0398d 	sth	r3,230(r2)
				& COMM_RMAP_LOWRES_PRT_A_0_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109bd8:	e0bfff17 	ldw	r2,-4(fp)
81109bdc:	10800017 	ldw	r2,0(r2)
81109be0:	01402d04 	movi	r5,180
81109be4:	1009883a 	mov	r4,r2
81109be8:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81109bec:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_20_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 = (alt_u16) ((uliReg
81109bf0:	e0bffe17 	ldw	r2,-8(fp)
81109bf4:	1007883a 	mov	r3,r2
81109bf8:	e0bfff17 	ldw	r2,-4(fp)
81109bfc:	10c03a0d 	sth	r3,232(r2)
				& COMM_RMAP_LOWRES_PRT_A_1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_2_MSK) >> 16);
81109c00:	e0bffe17 	ldw	r2,-8(fp)
81109c04:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_20_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 = (alt_u16) ((uliReg
81109c08:	1007883a 	mov	r3,r2
81109c0c:	e0bfff17 	ldw	r2,-4(fp)
81109c10:	10c03a8d 	sth	r3,234(r2)
				& COMM_RMAP_LOWRES_PRT_A_2_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109c14:	e0bfff17 	ldw	r2,-4(fp)
81109c18:	10800017 	ldw	r2,0(r2)
81109c1c:	01402d44 	movi	r5,181
81109c20:	1009883a 	mov	r4,r2
81109c24:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81109c28:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_21_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 = (alt_u16) ((uliReg
81109c2c:	e0bffe17 	ldw	r2,-8(fp)
81109c30:	1007883a 	mov	r3,r2
81109c34:	e0bfff17 	ldw	r2,-4(fp)
81109c38:	10c03b0d 	sth	r3,236(r2)
				& COMM_RMAP_LOWRES_PRT_A_3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_4_MSK) >> 16);
81109c3c:	e0bffe17 	ldw	r2,-8(fp)
81109c40:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_21_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 = (alt_u16) ((uliReg
81109c44:	1007883a 	mov	r3,r2
81109c48:	e0bfff17 	ldw	r2,-4(fp)
81109c4c:	10c03b8d 	sth	r3,238(r2)
				& COMM_RMAP_LOWRES_PRT_A_4_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109c50:	e0bfff17 	ldw	r2,-4(fp)
81109c54:	10800017 	ldw	r2,0(r2)
81109c58:	01402d84 	movi	r5,182
81109c5c:	1009883a 	mov	r4,r2
81109c60:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81109c64:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_22_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 = (alt_u16) ((uliReg
81109c68:	e0bffe17 	ldw	r2,-8(fp)
81109c6c:	1007883a 	mov	r3,r2
81109c70:	e0bfff17 	ldw	r2,-4(fp)
81109c74:	10c03c0d 	sth	r3,240(r2)
				& COMM_RMAP_LOWRES_PRT_A_5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_6_MSK) >> 16);
81109c78:	e0bffe17 	ldw	r2,-8(fp)
81109c7c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_22_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 = (alt_u16) ((uliReg
81109c80:	1007883a 	mov	r3,r2
81109c84:	e0bfff17 	ldw	r2,-4(fp)
81109c88:	10c03c8d 	sth	r3,242(r2)
				& COMM_RMAP_LOWRES_PRT_A_6_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109c8c:	e0bfff17 	ldw	r2,-4(fp)
81109c90:	10800017 	ldw	r2,0(r2)
81109c94:	01402dc4 	movi	r5,183
81109c98:	1009883a 	mov	r4,r2
81109c9c:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81109ca0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_23_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 = (alt_u16) ((uliReg
81109ca4:	e0bffe17 	ldw	r2,-8(fp)
81109ca8:	1007883a 	mov	r3,r2
81109cac:	e0bfff17 	ldw	r2,-4(fp)
81109cb0:	10c03d0d 	sth	r3,244(r2)
				& COMM_RMAP_LOWRES_PRT_A_7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_8_MSK) >> 16);
81109cb4:	e0bffe17 	ldw	r2,-8(fp)
81109cb8:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_23_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 = (alt_u16) ((uliReg
81109cbc:	1007883a 	mov	r3,r2
81109cc0:	e0bfff17 	ldw	r2,-4(fp)
81109cc4:	10c03d8d 	sth	r3,246(r2)
				& COMM_RMAP_LOWRES_PRT_A_8_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109cc8:	e0bfff17 	ldw	r2,-4(fp)
81109ccc:	10800017 	ldw	r2,0(r2)
81109cd0:	01402e04 	movi	r5,184
81109cd4:	1009883a 	mov	r4,r2
81109cd8:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81109cdc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_24_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 = (alt_u16) ((uliReg
81109ce0:	e0bffe17 	ldw	r2,-8(fp)
81109ce4:	1007883a 	mov	r3,r2
81109ce8:	e0bfff17 	ldw	r2,-4(fp)
81109cec:	10c03e0d 	sth	r3,248(r2)
				& COMM_RMAP_LOWRES_PRT_A_9_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_10_MSK) >> 16);
81109cf0:	e0bffe17 	ldw	r2,-8(fp)
81109cf4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_24_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_9_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 = (alt_u16) ((uliReg
81109cf8:	1007883a 	mov	r3,r2
81109cfc:	e0bfff17 	ldw	r2,-4(fp)
81109d00:	10c03e8d 	sth	r3,250(r2)
				& COMM_RMAP_LOWRES_PRT_A_10_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109d04:	e0bfff17 	ldw	r2,-4(fp)
81109d08:	10800017 	ldw	r2,0(r2)
81109d0c:	01402e44 	movi	r5,185
81109d10:	1009883a 	mov	r4,r2
81109d14:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81109d18:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_25_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 = (alt_u16) ((uliReg
81109d1c:	e0bffe17 	ldw	r2,-8(fp)
81109d20:	1007883a 	mov	r3,r2
81109d24:	e0bfff17 	ldw	r2,-4(fp)
81109d28:	10c03f0d 	sth	r3,252(r2)
				& COMM_RMAP_LOWRES_PRT_A_11_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_12_MSK) >> 16);
81109d2c:	e0bffe17 	ldw	r2,-8(fp)
81109d30:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_25_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_11_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 = (alt_u16) ((uliReg
81109d34:	1007883a 	mov	r3,r2
81109d38:	e0bfff17 	ldw	r2,-4(fp)
81109d3c:	10c03f8d 	sth	r3,254(r2)
				& COMM_RMAP_LOWRES_PRT_A_12_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109d40:	e0bfff17 	ldw	r2,-4(fp)
81109d44:	10800017 	ldw	r2,0(r2)
81109d48:	01402e84 	movi	r5,186
81109d4c:	1009883a 	mov	r4,r2
81109d50:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81109d54:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_26_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 = (alt_u16) ((uliReg
81109d58:	e0bffe17 	ldw	r2,-8(fp)
81109d5c:	1007883a 	mov	r3,r2
81109d60:	e0bfff17 	ldw	r2,-4(fp)
81109d64:	10c0400d 	sth	r3,256(r2)
				& COMM_RMAP_LOWRES_PRT_A_13_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_14_MSK) >> 16);
81109d68:	e0bffe17 	ldw	r2,-8(fp)
81109d6c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_26_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_13_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 = (alt_u16) ((uliReg
81109d70:	1007883a 	mov	r3,r2
81109d74:	e0bfff17 	ldw	r2,-4(fp)
81109d78:	10c0408d 	sth	r3,258(r2)
				& COMM_RMAP_LOWRES_PRT_A_14_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109d7c:	e0bfff17 	ldw	r2,-4(fp)
81109d80:	10800017 	ldw	r2,0(r2)
81109d84:	01402ec4 	movi	r5,187
81109d88:	1009883a 	mov	r4,r2
81109d8c:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81109d90:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_27_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 = (alt_u16) ((uliReg
81109d94:	e0bffe17 	ldw	r2,-8(fp)
81109d98:	1007883a 	mov	r3,r2
81109d9c:	e0bfff17 	ldw	r2,-4(fp)
81109da0:	10c0410d 	sth	r3,260(r2)
				& COMM_RMAP_LOWRES_PRT_A_15_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT0_MSK) >> 16);
81109da4:	e0bffe17 	ldw	r2,-8(fp)
81109da8:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_27_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_15_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 = (alt_u16) ((uliReg
81109dac:	1007883a 	mov	r3,r2
81109db0:	e0bfff17 	ldw	r2,-4(fp)
81109db4:	10c0418d 	sth	r3,262(r2)
				& COMM_RMAP_SEL_HIRES_PRT0_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109db8:	e0bfff17 	ldw	r2,-4(fp)
81109dbc:	10800017 	ldw	r2,0(r2)
81109dc0:	01402f04 	movi	r5,188
81109dc4:	1009883a 	mov	r4,r2
81109dc8:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81109dcc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_28_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 = (alt_u16) ((uliReg
81109dd0:	e0bffe17 	ldw	r2,-8(fp)
81109dd4:	1007883a 	mov	r3,r2
81109dd8:	e0bfff17 	ldw	r2,-4(fp)
81109ddc:	10c0420d 	sth	r3,264(r2)
				& COMM_RMAP_SEL_HIRES_PRT1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT2_MSK) >> 16);
81109de0:	e0bffe17 	ldw	r2,-8(fp)
81109de4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_28_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 = (alt_u16) ((uliReg
81109de8:	1007883a 	mov	r3,r2
81109dec:	e0bfff17 	ldw	r2,-4(fp)
81109df0:	10c0428d 	sth	r3,266(r2)
				& COMM_RMAP_SEL_HIRES_PRT2_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109df4:	e0bfff17 	ldw	r2,-4(fp)
81109df8:	10800017 	ldw	r2,0(r2)
81109dfc:	01402f44 	movi	r5,189
81109e00:	1009883a 	mov	r4,r2
81109e04:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81109e08:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_29_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 = (alt_u16) ((uliReg
81109e0c:	e0bffe17 	ldw	r2,-8(fp)
81109e10:	1007883a 	mov	r3,r2
81109e14:	e0bfff17 	ldw	r2,-4(fp)
81109e18:	10c0430d 	sth	r3,268(r2)
				& COMM_RMAP_SEL_HIRES_PRT3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT4_MSK) >> 16);
81109e1c:	e0bffe17 	ldw	r2,-8(fp)
81109e20:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_29_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 = (alt_u16) ((uliReg
81109e24:	1007883a 	mov	r3,r2
81109e28:	e0bfff17 	ldw	r2,-4(fp)
81109e2c:	10c0438d 	sth	r3,270(r2)
				& COMM_RMAP_SEL_HIRES_PRT4_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109e30:	e0bfff17 	ldw	r2,-4(fp)
81109e34:	10800017 	ldw	r2,0(r2)
81109e38:	01402f84 	movi	r5,190
81109e3c:	1009883a 	mov	r4,r2
81109e40:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81109e44:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_30_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 = (alt_u16) ((uliReg
81109e48:	e0bffe17 	ldw	r2,-8(fp)
81109e4c:	1007883a 	mov	r3,r2
81109e50:	e0bfff17 	ldw	r2,-4(fp)
81109e54:	10c0440d 	sth	r3,272(r2)
				& COMM_RMAP_SEL_HIRES_PRT5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT6_MSK) >> 16);
81109e58:	e0bffe17 	ldw	r2,-8(fp)
81109e5c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_30_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 = (alt_u16) ((uliReg
81109e60:	1007883a 	mov	r3,r2
81109e64:	e0bfff17 	ldw	r2,-4(fp)
81109e68:	10c0448d 	sth	r3,274(r2)
				& COMM_RMAP_SEL_HIRES_PRT6_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109e6c:	e0bfff17 	ldw	r2,-4(fp)
81109e70:	10800017 	ldw	r2,0(r2)
81109e74:	01402fc4 	movi	r5,191
81109e78:	1009883a 	mov	r4,r2
81109e7c:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
81109e80:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_31_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 = (alt_u16) ((uliReg
81109e84:	e0bffe17 	ldw	r2,-8(fp)
81109e88:	1007883a 	mov	r3,r2
81109e8c:	e0bfff17 	ldw	r2,-4(fp)
81109e90:	10c0450d 	sth	r3,276(r2)
				& COMM_RMAP_SEL_HIRES_PRT7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp = (alt_u16) ((uliReg
				& COMM_RMAP_ZERO_HIRES_AMP_MSK) >> 16);
81109e94:	e0bffe17 	ldw	r2,-8(fp)
81109e98:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_31_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp = (alt_u16) ((uliReg
81109e9c:	1007883a 	mov	r3,r2
81109ea0:	e0bfff17 	ldw	r2,-4(fp)
81109ea4:	10c0458d 	sth	r3,278(r2)
				& COMM_RMAP_ZERO_HIRES_AMP_MSK) >> 16);

		bStatus = TRUE;
81109ea8:	00800044 	movi	r2,1
81109eac:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81109eb0:	e0bffd17 	ldw	r2,-12(fp)
}
81109eb4:	e037883a 	mov	sp,fp
81109eb8:	dfc00117 	ldw	ra,4(sp)
81109ebc:	df000017 	ldw	fp,0(sp)
81109ec0:	dec00204 	addi	sp,sp,8
81109ec4:	f800283a 	ret

81109ec8 <bRmapInitCh>:

bool bRmapInitCh(TRmapChannel *pxRmapCh, alt_u8 ucCommCh) {
81109ec8:	defffb04 	addi	sp,sp,-20
81109ecc:	de00012e 	bgeu	sp,et,81109ed4 <bRmapInitCh+0xc>
81109ed0:	003b68fa 	trap	3
81109ed4:	dfc00415 	stw	ra,16(sp)
81109ed8:	df000315 	stw	fp,12(sp)
81109edc:	df000304 	addi	fp,sp,12
81109ee0:	e13ffe15 	stw	r4,-8(fp)
81109ee4:	2805883a 	mov	r2,r5
81109ee8:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81109eec:	e03ffd15 	stw	zero,-12(fp)

	if (pxRmapCh != NULL) {
81109ef0:	e0bffe17 	ldw	r2,-8(fp)
81109ef4:	10005726 	beq	r2,zero,8110a054 <bRmapInitCh+0x18c>
		bStatus = TRUE;
81109ef8:	00800044 	movi	r2,1
81109efc:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81109f00:	e0bfff03 	ldbu	r2,-4(fp)
81109f04:	10c00228 	cmpgeui	r3,r2,8
81109f08:	1800361e 	bne	r3,zero,81109fe4 <bRmapInitCh+0x11c>
81109f0c:	100690ba 	slli	r3,r2,2
81109f10:	00a04474 	movhi	r2,33041
81109f14:	10a7c904 	addi	r2,r2,-24796
81109f18:	1885883a 	add	r2,r3,r2
81109f1c:	10800017 	ldw	r2,0(r2)
81109f20:	1000683a 	jmp	r2
81109f24:	81109f44 	addi	r4,r16,17021
81109f28:	81109f58 	cmpnei	r4,r16,17021
81109f2c:	81109f6c 	andhi	r4,r16,17021
81109f30:	81109f80 	call	881109f8 <__reset+0x20f09f8>
81109f34:	81109f94 	ori	r4,r16,17022
81109f38:	81109fa8 	cmpgeui	r4,r16,17022
81109f3c:	81109fbc 	xorhi	r4,r16,17022
81109f40:	81109fd0 	cmplti	r4,r16,17023
		case eCommSpwCh1:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81109f44:	e0fffe17 	ldw	r3,-8(fp)
81109f48:	00a04834 	movhi	r2,33056
81109f4c:	108b0004 	addi	r2,r2,11264
81109f50:	18800015 	stw	r2,0(r3)
			break;
81109f54:	00002506 	br	81109fec <bRmapInitCh+0x124>
		case eCommSpwCh2:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81109f58:	e0fffe17 	ldw	r3,-8(fp)
81109f5c:	00a04834 	movhi	r2,33056
81109f60:	108a0004 	addi	r2,r2,10240
81109f64:	18800015 	stw	r2,0(r3)
			break;
81109f68:	00002006 	br	81109fec <bRmapInitCh+0x124>
		case eCommSpwCh3:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81109f6c:	e0fffe17 	ldw	r3,-8(fp)
81109f70:	00a04834 	movhi	r2,33056
81109f74:	108b0004 	addi	r2,r2,11264
81109f78:	18800015 	stw	r2,0(r3)
			break;
81109f7c:	00001b06 	br	81109fec <bRmapInitCh+0x124>
		case eCommSpwCh4:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81109f80:	e0fffe17 	ldw	r3,-8(fp)
81109f84:	00a04834 	movhi	r2,33056
81109f88:	108a0004 	addi	r2,r2,10240
81109f8c:	18800015 	stw	r2,0(r3)
			break;
81109f90:	00001606 	br	81109fec <bRmapInitCh+0x124>
		case eCommSpwCh5:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81109f94:	e0fffe17 	ldw	r3,-8(fp)
81109f98:	00a04834 	movhi	r2,33056
81109f9c:	108b0004 	addi	r2,r2,11264
81109fa0:	18800015 	stw	r2,0(r3)
			break;
81109fa4:	00001106 	br	81109fec <bRmapInitCh+0x124>
		case eCommSpwCh6:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81109fa8:	e0fffe17 	ldw	r3,-8(fp)
81109fac:	00a04834 	movhi	r2,33056
81109fb0:	108a0004 	addi	r2,r2,10240
81109fb4:	18800015 	stw	r2,0(r3)
			break;
81109fb8:	00000c06 	br	81109fec <bRmapInitCh+0x124>
		case eCommSpwCh7:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81109fbc:	e0fffe17 	ldw	r3,-8(fp)
81109fc0:	00a04834 	movhi	r2,33056
81109fc4:	108b0004 	addi	r2,r2,11264
81109fc8:	18800015 	stw	r2,0(r3)
			break;
81109fcc:	00000706 	br	81109fec <bRmapInitCh+0x124>
		case eCommSpwCh8:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81109fd0:	e0fffe17 	ldw	r3,-8(fp)
81109fd4:	00a04834 	movhi	r2,33056
81109fd8:	108a0004 	addi	r2,r2,10240
81109fdc:	18800015 	stw	r2,0(r3)
			break;
81109fe0:	00000206 	br	81109fec <bRmapInitCh+0x124>
		default:
			bStatus = FALSE;
81109fe4:	e03ffd15 	stw	zero,-12(fp)
			break;
81109fe8:	0001883a 	nop
		}

		if (bStatus) {
81109fec:	e0bffd17 	ldw	r2,-12(fp)
81109ff0:	10001826 	beq	r2,zero,8110a054 <bRmapInitCh+0x18c>
			if (!bRmapGetIrqControl(pxRmapCh)) {
81109ff4:	e13ffe17 	ldw	r4,-8(fp)
81109ff8:	1107b280 	call	81107b28 <bRmapGetIrqControl>
81109ffc:	1000011e 	bne	r2,zero,8110a004 <bRmapInitCh+0x13c>
				bStatus = FALSE;
8110a000:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetCodecConfig(pxRmapCh)) {
8110a004:	e13ffe17 	ldw	r4,-8(fp)
8110a008:	1107d100 	call	81107d10 <bRmapGetCodecConfig>
8110a00c:	1000011e 	bne	r2,zero,8110a014 <bRmapInitCh+0x14c>
				bStatus = FALSE;
8110a010:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetCodecStatus(pxRmapCh)) {
8110a014:	e13ffe17 	ldw	r4,-8(fp)
8110a018:	1107d9c0 	call	81107d9c <bRmapGetCodecStatus>
8110a01c:	1000011e 	bne	r2,zero,8110a024 <bRmapInitCh+0x15c>
				bStatus = FALSE;
8110a020:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetMemConfigArea(pxRmapCh)) {
8110a024:	e13ffe17 	ldw	r4,-8(fp)
8110a028:	11083480 	call	81108348 <bRmapGetMemConfigArea>
8110a02c:	1000011e 	bne	r2,zero,8110a034 <bRmapInitCh+0x16c>
				bStatus = FALSE;
8110a030:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetMemConfigStat(pxRmapCh)) {
8110a034:	e13ffe17 	ldw	r4,-8(fp)
8110a038:	110861c0 	call	8110861c <bRmapGetMemConfigStat>
8110a03c:	1000011e 	bne	r2,zero,8110a044 <bRmapInitCh+0x17c>
				bStatus = FALSE;
8110a040:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetRmapMemHKArea(pxRmapCh)) {
8110a044:	e13ffe17 	ldw	r4,-8(fp)
8110a048:	11096fc0 	call	811096fc <bRmapGetRmapMemHKArea>
8110a04c:	1000011e 	bne	r2,zero,8110a054 <bRmapInitCh+0x18c>
				bStatus = FALSE;
8110a050:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
8110a054:	e0bffd17 	ldw	r2,-12(fp)
}
8110a058:	e037883a 	mov	sp,fp
8110a05c:	dfc00117 	ldw	ra,4(sp)
8110a060:	df000017 	ldw	fp,0(sp)
8110a064:	dec00204 	addi	sp,sp,8
8110a068:	f800283a 	ret

8110a06c <vRmapWriteReg>:
//! [public functions]

//! [private functions]
static void vRmapWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
8110a06c:	defffc04 	addi	sp,sp,-16
8110a070:	de00012e 	bgeu	sp,et,8110a078 <vRmapWriteReg+0xc>
8110a074:	003b68fa 	trap	3
8110a078:	df000315 	stw	fp,12(sp)
8110a07c:	df000304 	addi	fp,sp,12
8110a080:	e13ffd15 	stw	r4,-12(fp)
8110a084:	e17ffe15 	stw	r5,-8(fp)
8110a088:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
8110a08c:	e0bffe17 	ldw	r2,-8(fp)
8110a090:	1085883a 	add	r2,r2,r2
8110a094:	1085883a 	add	r2,r2,r2
8110a098:	1007883a 	mov	r3,r2
8110a09c:	e0bffd17 	ldw	r2,-12(fp)
8110a0a0:	10c5883a 	add	r2,r2,r3
8110a0a4:	e0ffff17 	ldw	r3,-4(fp)
8110a0a8:	10c00015 	stw	r3,0(r2)
}
8110a0ac:	0001883a 	nop
8110a0b0:	e037883a 	mov	sp,fp
8110a0b4:	df000017 	ldw	fp,0(sp)
8110a0b8:	dec00104 	addi	sp,sp,4
8110a0bc:	f800283a 	ret

8110a0c0 <uliRmapReadReg>:

alt_u32 uliRmapReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8110a0c0:	defffc04 	addi	sp,sp,-16
8110a0c4:	de00012e 	bgeu	sp,et,8110a0cc <uliRmapReadReg+0xc>
8110a0c8:	003b68fa 	trap	3
8110a0cc:	df000315 	stw	fp,12(sp)
8110a0d0:	df000304 	addi	fp,sp,12
8110a0d4:	e13ffe15 	stw	r4,-8(fp)
8110a0d8:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
8110a0dc:	e0bfff17 	ldw	r2,-4(fp)
8110a0e0:	1085883a 	add	r2,r2,r2
8110a0e4:	1085883a 	add	r2,r2,r2
8110a0e8:	1007883a 	mov	r3,r2
8110a0ec:	e0bffe17 	ldw	r2,-8(fp)
8110a0f0:	10c5883a 	add	r2,r2,r3
8110a0f4:	10800017 	ldw	r2,0(r2)
8110a0f8:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8110a0fc:	e0bffd17 	ldw	r2,-12(fp)
}
8110a100:	e037883a 	mov	sp,fp
8110a104:	df000017 	ldw	fp,0(sp)
8110a108:	dec00104 	addi	sp,sp,4
8110a10c:	f800283a 	ret

8110a110 <uliConvRmapCfgAddr>:

static alt_u32 uliConvRmapCfgAddr(alt_u32 puliRmapAddr) {
8110a110:	defffd04 	addi	sp,sp,-12
8110a114:	de00012e 	bgeu	sp,et,8110a11c <uliConvRmapCfgAddr+0xc>
8110a118:	003b68fa 	trap	3
8110a11c:	df000215 	stw	fp,8(sp)
8110a120:	df000204 	addi	fp,sp,8
8110a124:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliValue;

	switch (puliRmapAddr) {
8110a128:	e0bfff17 	ldw	r2,-4(fp)
8110a12c:	10801368 	cmpgeui	r2,r2,77
8110a130:	10008a1e 	bne	r2,zero,8110a35c <uliConvRmapCfgAddr+0x24c>
8110a134:	e0bfff17 	ldw	r2,-4(fp)
8110a138:	100690ba 	slli	r3,r2,2
8110a13c:	00a04474 	movhi	r2,33041
8110a140:	10a85404 	addi	r2,r2,-24240
8110a144:	1885883a 	add	r2,r3,r2
8110a148:	10800017 	ldw	r2,0(r2)
8110a14c:	1000683a 	jmp	r2
8110a150:	8110a284 	addi	r4,r16,17034
8110a154:	8110a35c 	xori	r4,r16,17037
8110a158:	8110a35c 	xori	r4,r16,17037
8110a15c:	8110a35c 	xori	r4,r16,17037
8110a160:	8110a290 	cmplti	r4,r16,17034
8110a164:	8110a35c 	xori	r4,r16,17037
8110a168:	8110a35c 	xori	r4,r16,17037
8110a16c:	8110a35c 	xori	r4,r16,17037
8110a170:	8110a29c 	xori	r4,r16,17034
8110a174:	8110a35c 	xori	r4,r16,17037
8110a178:	8110a35c 	xori	r4,r16,17037
8110a17c:	8110a35c 	xori	r4,r16,17037
8110a180:	8110a2a8 	cmpgeui	r4,r16,17034
8110a184:	8110a35c 	xori	r4,r16,17037
8110a188:	8110a35c 	xori	r4,r16,17037
8110a18c:	8110a35c 	xori	r4,r16,17037
8110a190:	8110a2b4 	orhi	r4,r16,17034
8110a194:	8110a35c 	xori	r4,r16,17037
8110a198:	8110a35c 	xori	r4,r16,17037
8110a19c:	8110a35c 	xori	r4,r16,17037
8110a1a0:	8110a2c0 	call	88110a2c <__reset+0x20f0a2c>
8110a1a4:	8110a35c 	xori	r4,r16,17037
8110a1a8:	8110a35c 	xori	r4,r16,17037
8110a1ac:	8110a35c 	xori	r4,r16,17037
8110a1b0:	8110a2cc 	andi	r4,r16,17035
8110a1b4:	8110a35c 	xori	r4,r16,17037
8110a1b8:	8110a35c 	xori	r4,r16,17037
8110a1bc:	8110a35c 	xori	r4,r16,17037
8110a1c0:	8110a2d8 	cmpnei	r4,r16,17035
8110a1c4:	8110a35c 	xori	r4,r16,17037
8110a1c8:	8110a35c 	xori	r4,r16,17037
8110a1cc:	8110a35c 	xori	r4,r16,17037
8110a1d0:	8110a2e4 	muli	r4,r16,17035
8110a1d4:	8110a35c 	xori	r4,r16,17037
8110a1d8:	8110a35c 	xori	r4,r16,17037
8110a1dc:	8110a35c 	xori	r4,r16,17037
8110a1e0:	8110a2f0 	cmpltui	r4,r16,17035
8110a1e4:	8110a35c 	xori	r4,r16,17037
8110a1e8:	8110a35c 	xori	r4,r16,17037
8110a1ec:	8110a35c 	xori	r4,r16,17037
8110a1f0:	8110a2fc 	xorhi	r4,r16,17035
8110a1f4:	8110a35c 	xori	r4,r16,17037
8110a1f8:	8110a35c 	xori	r4,r16,17037
8110a1fc:	8110a35c 	xori	r4,r16,17037
8110a200:	8110a308 	cmpgei	r4,r16,17036
8110a204:	8110a35c 	xori	r4,r16,17037
8110a208:	8110a35c 	xori	r4,r16,17037
8110a20c:	8110a35c 	xori	r4,r16,17037
8110a210:	8110a35c 	xori	r4,r16,17037
8110a214:	8110a35c 	xori	r4,r16,17037
8110a218:	8110a35c 	xori	r4,r16,17037
8110a21c:	8110a35c 	xori	r4,r16,17037
8110a220:	8110a35c 	xori	r4,r16,17037
8110a224:	8110a35c 	xori	r4,r16,17037
8110a228:	8110a35c 	xori	r4,r16,17037
8110a22c:	8110a35c 	xori	r4,r16,17037
8110a230:	8110a314 	ori	r4,r16,17036
8110a234:	8110a35c 	xori	r4,r16,17037
8110a238:	8110a35c 	xori	r4,r16,17037
8110a23c:	8110a35c 	xori	r4,r16,17037
8110a240:	8110a320 	cmpeqi	r4,r16,17036
8110a244:	8110a35c 	xori	r4,r16,17037
8110a248:	8110a35c 	xori	r4,r16,17037
8110a24c:	8110a35c 	xori	r4,r16,17037
8110a250:	8110a32c 	andhi	r4,r16,17036
8110a254:	8110a35c 	xori	r4,r16,17037
8110a258:	8110a35c 	xori	r4,r16,17037
8110a25c:	8110a35c 	xori	r4,r16,17037
8110a260:	8110a338 	rdprs	r4,r16,17036
8110a264:	8110a35c 	xori	r4,r16,17037
8110a268:	8110a35c 	xori	r4,r16,17037
8110a26c:	8110a35c 	xori	r4,r16,17037
8110a270:	8110a344 	addi	r4,r16,17037
8110a274:	8110a35c 	xori	r4,r16,17037
8110a278:	8110a35c 	xori	r4,r16,17037
8110a27c:	8110a35c 	xori	r4,r16,17037
8110a280:	8110a350 	cmplti	r4,r16,17037
	case 0x00000000:
		uliValue = 0x00000040;
8110a284:	00801004 	movi	r2,64
8110a288:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a28c:	00003506 	br	8110a364 <uliConvRmapCfgAddr+0x254>
	case 0x00000004:
		uliValue = 0x00000041;
8110a290:	00801044 	movi	r2,65
8110a294:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a298:	00003206 	br	8110a364 <uliConvRmapCfgAddr+0x254>
	case 0x00000008:
		uliValue = 0x00000042;
8110a29c:	00801084 	movi	r2,66
8110a2a0:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a2a4:	00002f06 	br	8110a364 <uliConvRmapCfgAddr+0x254>
	case 0x0000000C:
		uliValue = 0x00000043;
8110a2a8:	008010c4 	movi	r2,67
8110a2ac:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a2b0:	00002c06 	br	8110a364 <uliConvRmapCfgAddr+0x254>
	case 0x00000010:
		uliValue = 0x00000044;
8110a2b4:	00801104 	movi	r2,68
8110a2b8:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a2bc:	00002906 	br	8110a364 <uliConvRmapCfgAddr+0x254>
	case 0x00000014:
		uliValue = 0x00000045;
8110a2c0:	00801144 	movi	r2,69
8110a2c4:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a2c8:	00002606 	br	8110a364 <uliConvRmapCfgAddr+0x254>
	case 0x00000018:
		uliValue = 0x00000046;
8110a2cc:	00801184 	movi	r2,70
8110a2d0:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a2d4:	00002306 	br	8110a364 <uliConvRmapCfgAddr+0x254>
	case 0x0000001C:
		uliValue = 0x00000047;
8110a2d8:	008011c4 	movi	r2,71
8110a2dc:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a2e0:	00002006 	br	8110a364 <uliConvRmapCfgAddr+0x254>
	case 0x00000020:
		uliValue = 0x00000048;
8110a2e4:	00801204 	movi	r2,72
8110a2e8:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a2ec:	00001d06 	br	8110a364 <uliConvRmapCfgAddr+0x254>
	case 0x00000024:
		uliValue = 0x00000049;
8110a2f0:	00801244 	movi	r2,73
8110a2f4:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a2f8:	00001a06 	br	8110a364 <uliConvRmapCfgAddr+0x254>
	case 0x00000028:
		uliValue = 0x0000004A;
8110a2fc:	00801284 	movi	r2,74
8110a300:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a304:	00001706 	br	8110a364 <uliConvRmapCfgAddr+0x254>
	case 0x0000002C:
		uliValue = 0x0000004B;
8110a308:	008012c4 	movi	r2,75
8110a30c:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a310:	00001406 	br	8110a364 <uliConvRmapCfgAddr+0x254>
	case 0x00000038:
		uliValue = 0x0000004C;
8110a314:	00801304 	movi	r2,76
8110a318:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a31c:	00001106 	br	8110a364 <uliConvRmapCfgAddr+0x254>
	case 0x0000003C:
		uliValue = 0x0000004D;
8110a320:	00801344 	movi	r2,77
8110a324:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a328:	00000e06 	br	8110a364 <uliConvRmapCfgAddr+0x254>
	case 0x00000040:
		uliValue = 0x0000004E;
8110a32c:	00801384 	movi	r2,78
8110a330:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a334:	00000b06 	br	8110a364 <uliConvRmapCfgAddr+0x254>
	case 0x00000044:
		uliValue = 0x0000004F;
8110a338:	008013c4 	movi	r2,79
8110a33c:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a340:	00000806 	br	8110a364 <uliConvRmapCfgAddr+0x254>
	case 0x00000048:
		uliValue = 0x00000050;
8110a344:	00801404 	movi	r2,80
8110a348:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a34c:	00000506 	br	8110a364 <uliConvRmapCfgAddr+0x254>
	case 0x0000004C:
		uliValue = 0x00000051;
8110a350:	00801444 	movi	r2,81
8110a354:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a358:	00000206 	br	8110a364 <uliConvRmapCfgAddr+0x254>
	default:
		uliValue = 0x00000000;
8110a35c:	e03ffe15 	stw	zero,-8(fp)
		break;
8110a360:	0001883a 	nop
	}

	return uliValue;
8110a364:	e0bffe17 	ldw	r2,-8(fp)
}
8110a368:	e037883a 	mov	sp,fp
8110a36c:	df000017 	ldw	fp,0(sp)
8110a370:	dec00104 	addi	sp,sp,4
8110a374:	f800283a 	ret

8110a378 <bSpwcSetLink>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bSpwcSetLink(TSpwcChannel *pxSpwcCh) {
8110a378:	defffb04 	addi	sp,sp,-20
8110a37c:	de00012e 	bgeu	sp,et,8110a384 <bSpwcSetLink+0xc>
8110a380:	003b68fa 	trap	3
8110a384:	dfc00415 	stw	ra,16(sp)
8110a388:	df000315 	stw	fp,12(sp)
8110a38c:	df000304 	addi	fp,sp,12
8110a390:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110a394:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110a398:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110a39c:	e0bfff17 	ldw	r2,-4(fp)
8110a3a0:	10003c26 	beq	r2,zero,8110a494 <bSpwcSetLink+0x11c>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110a3a4:	e0bfff17 	ldw	r2,-4(fp)
8110a3a8:	10800017 	ldw	r2,0(r2)
8110a3ac:	000b883a 	mov	r5,zero
8110a3b0:	1009883a 	mov	r4,r2
8110a3b4:	110aa440 	call	8110aa44 <uliSpwcReadReg>
8110a3b8:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (pxSpwcCh->xLinkConfig.bAutostart) {
8110a3bc:	e0bfff17 	ldw	r2,-4(fp)
8110a3c0:	10800117 	ldw	r2,4(r2)
8110a3c4:	10000426 	beq	r2,zero,8110a3d8 <bSpwcSetLink+0x60>
			uliReg |= COMM_SPW_LNKCFG_AUTOSTART_MSK;
8110a3c8:	e0bffe17 	ldw	r2,-8(fp)
8110a3cc:	10800114 	ori	r2,r2,4
8110a3d0:	e0bffe15 	stw	r2,-8(fp)
8110a3d4:	00000406 	br	8110a3e8 <bSpwcSetLink+0x70>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_AUTOSTART_MSK);
8110a3d8:	e0fffe17 	ldw	r3,-8(fp)
8110a3dc:	00bffec4 	movi	r2,-5
8110a3e0:	1884703a 	and	r2,r3,r2
8110a3e4:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxSpwcCh->xLinkConfig.bLinkStart) {
8110a3e8:	e0bfff17 	ldw	r2,-4(fp)
8110a3ec:	10800217 	ldw	r2,8(r2)
8110a3f0:	10000426 	beq	r2,zero,8110a404 <bSpwcSetLink+0x8c>
			uliReg |= COMM_SPW_LNKCFG_LINKSTART_MSK;
8110a3f4:	e0bffe17 	ldw	r2,-8(fp)
8110a3f8:	10800094 	ori	r2,r2,2
8110a3fc:	e0bffe15 	stw	r2,-8(fp)
8110a400:	00000406 	br	8110a414 <bSpwcSetLink+0x9c>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_LINKSTART_MSK);
8110a404:	e0fffe17 	ldw	r3,-8(fp)
8110a408:	00bfff44 	movi	r2,-3
8110a40c:	1884703a 	and	r2,r3,r2
8110a410:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxSpwcCh->xLinkConfig.bDisconnect) {
8110a414:	e0bfff17 	ldw	r2,-4(fp)
8110a418:	10800317 	ldw	r2,12(r2)
8110a41c:	10000426 	beq	r2,zero,8110a430 <bSpwcSetLink+0xb8>
			uliReg |= COMM_SPW_LNKCFG_DISCONNECT_MSK;
8110a420:	e0bffe17 	ldw	r2,-8(fp)
8110a424:	10800054 	ori	r2,r2,1
8110a428:	e0bffe15 	stw	r2,-8(fp)
8110a42c:	00000406 	br	8110a440 <bSpwcSetLink+0xc8>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_DISCONNECT_MSK);
8110a430:	e0fffe17 	ldw	r3,-8(fp)
8110a434:	00bfff84 	movi	r2,-2
8110a438:	1884703a 	and	r2,r3,r2
8110a43c:	e0bffe15 	stw	r2,-8(fp)
		}
		uliReg &= (~COMM_SPW_LNKCFG_TXDIVCNT_MSK);
8110a440:	e0fffe17 	ldw	r3,-8(fp)
8110a444:	00804034 	movhi	r2,256
8110a448:	10bfffc4 	addi	r2,r2,-1
8110a44c:	1884703a 	and	r2,r3,r2
8110a450:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_SPW_LNKCFG_TXDIVCNT_MSK
				& (alt_u32)(pxSpwcCh->xLinkConfig.ucTxDivCnt << 24));
8110a454:	e0bfff17 	ldw	r2,-4(fp)
8110a458:	10800403 	ldbu	r2,16(r2)
8110a45c:	10803fcc 	andi	r2,r2,255
8110a460:	1004963a 	slli	r2,r2,24
8110a464:	1007883a 	mov	r3,r2
			uliReg |= COMM_SPW_LNKCFG_DISCONNECT_MSK;
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_DISCONNECT_MSK);
		}
		uliReg &= (~COMM_SPW_LNKCFG_TXDIVCNT_MSK);
		uliReg |= (COMM_SPW_LNKCFG_TXDIVCNT_MSK
8110a468:	e0bffe17 	ldw	r2,-8(fp)
8110a46c:	10c4b03a 	or	r2,r2,r3
8110a470:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxSpwcCh->xLinkConfig.ucTxDivCnt << 24));

		vSpwcWriteReg(pxSpwcCh->puliSpwcChAddr, COMM_LINK_CFG_STAT_REG_OFST,
8110a474:	e0bfff17 	ldw	r2,-4(fp)
8110a478:	10800017 	ldw	r2,0(r2)
8110a47c:	e1bffe17 	ldw	r6,-8(fp)
8110a480:	000b883a 	mov	r5,zero
8110a484:	1009883a 	mov	r4,r2
8110a488:	110a9f00 	call	8110a9f0 <vSpwcWriteReg>
				uliReg);
		bStatus = TRUE;
8110a48c:	00800044 	movi	r2,1
8110a490:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a494:	e0bffd17 	ldw	r2,-12(fp)
}
8110a498:	e037883a 	mov	sp,fp
8110a49c:	dfc00117 	ldw	ra,4(sp)
8110a4a0:	df000017 	ldw	fp,0(sp)
8110a4a4:	dec00204 	addi	sp,sp,8
8110a4a8:	f800283a 	ret

8110a4ac <bSpwcGetLink>:

bool bSpwcGetLink(TSpwcChannel *pxSpwcCh) {
8110a4ac:	defffb04 	addi	sp,sp,-20
8110a4b0:	de00012e 	bgeu	sp,et,8110a4b8 <bSpwcGetLink+0xc>
8110a4b4:	003b68fa 	trap	3
8110a4b8:	dfc00415 	stw	ra,16(sp)
8110a4bc:	df000315 	stw	fp,12(sp)
8110a4c0:	df000304 	addi	fp,sp,12
8110a4c4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110a4c8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110a4cc:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110a4d0:	e0bfff17 	ldw	r2,-4(fp)
8110a4d4:	10002826 	beq	r2,zero,8110a578 <bSpwcGetLink+0xcc>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110a4d8:	e0bfff17 	ldw	r2,-4(fp)
8110a4dc:	10800017 	ldw	r2,0(r2)
8110a4e0:	000b883a 	mov	r5,zero
8110a4e4:	1009883a 	mov	r4,r2
8110a4e8:	110aa440 	call	8110aa44 <uliSpwcReadReg>
8110a4ec:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKCFG_AUTOSTART_MSK) {
8110a4f0:	e0bffe17 	ldw	r2,-8(fp)
8110a4f4:	1080010c 	andi	r2,r2,4
8110a4f8:	10000426 	beq	r2,zero,8110a50c <bSpwcGetLink+0x60>
			pxSpwcCh->xLinkConfig.bAutostart = TRUE;
8110a4fc:	e0bfff17 	ldw	r2,-4(fp)
8110a500:	00c00044 	movi	r3,1
8110a504:	10c00115 	stw	r3,4(r2)
8110a508:	00000206 	br	8110a514 <bSpwcGetLink+0x68>
		} else {
			pxSpwcCh->xLinkConfig.bAutostart = FALSE;
8110a50c:	e0bfff17 	ldw	r2,-4(fp)
8110a510:	10000115 	stw	zero,4(r2)
		}
		if (uliReg & COMM_SPW_LNKCFG_LINKSTART_MSK) {
8110a514:	e0bffe17 	ldw	r2,-8(fp)
8110a518:	1080008c 	andi	r2,r2,2
8110a51c:	10000426 	beq	r2,zero,8110a530 <bSpwcGetLink+0x84>
			pxSpwcCh->xLinkConfig.bLinkStart = TRUE;
8110a520:	e0bfff17 	ldw	r2,-4(fp)
8110a524:	00c00044 	movi	r3,1
8110a528:	10c00215 	stw	r3,8(r2)
8110a52c:	00000206 	br	8110a538 <bSpwcGetLink+0x8c>
		} else {
			pxSpwcCh->xLinkConfig.bLinkStart = FALSE;
8110a530:	e0bfff17 	ldw	r2,-4(fp)
8110a534:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_SPW_LNKCFG_DISCONNECT_MSK) {
8110a538:	e0bffe17 	ldw	r2,-8(fp)
8110a53c:	1080004c 	andi	r2,r2,1
8110a540:	10000426 	beq	r2,zero,8110a554 <bSpwcGetLink+0xa8>
			pxSpwcCh->xLinkConfig.bDisconnect = TRUE;
8110a544:	e0bfff17 	ldw	r2,-4(fp)
8110a548:	00c00044 	movi	r3,1
8110a54c:	10c00315 	stw	r3,12(r2)
8110a550:	00000206 	br	8110a55c <bSpwcGetLink+0xb0>
		} else {
			pxSpwcCh->xLinkConfig.bDisconnect = FALSE;
8110a554:	e0bfff17 	ldw	r2,-4(fp)
8110a558:	10000315 	stw	zero,12(r2)
		}
		pxSpwcCh->xLinkConfig.ucTxDivCnt= (alt_u8)(
				(uliReg & COMM_SPW_LNKCFG_TXDIVCNT_MSK) >> 24);
8110a55c:	e0bffe17 	ldw	r2,-8(fp)
8110a560:	1004d63a 	srli	r2,r2,24
		if (uliReg & COMM_SPW_LNKCFG_DISCONNECT_MSK) {
			pxSpwcCh->xLinkConfig.bDisconnect = TRUE;
		} else {
			pxSpwcCh->xLinkConfig.bDisconnect = FALSE;
		}
		pxSpwcCh->xLinkConfig.ucTxDivCnt= (alt_u8)(
8110a564:	1007883a 	mov	r3,r2
8110a568:	e0bfff17 	ldw	r2,-4(fp)
8110a56c:	10c00405 	stb	r3,16(r2)
				(uliReg & COMM_SPW_LNKCFG_TXDIVCNT_MSK) >> 24);

		bStatus = TRUE;
8110a570:	00800044 	movi	r2,1
8110a574:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a578:	e0bffd17 	ldw	r2,-12(fp)
}
8110a57c:	e037883a 	mov	sp,fp
8110a580:	dfc00117 	ldw	ra,4(sp)
8110a584:	df000017 	ldw	fp,0(sp)
8110a588:	dec00204 	addi	sp,sp,8
8110a58c:	f800283a 	ret

8110a590 <bSpwcGetLinkError>:

bool bSpwcGetLinkError(TSpwcChannel *pxSpwcCh) {
8110a590:	defffb04 	addi	sp,sp,-20
8110a594:	de00012e 	bgeu	sp,et,8110a59c <bSpwcGetLinkError+0xc>
8110a598:	003b68fa 	trap	3
8110a59c:	dfc00415 	stw	ra,16(sp)
8110a5a0:	df000315 	stw	fp,12(sp)
8110a5a4:	df000304 	addi	fp,sp,12
8110a5a8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110a5ac:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110a5b0:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110a5b4:	e0bfff17 	ldw	r2,-4(fp)
8110a5b8:	10002c26 	beq	r2,zero,8110a66c <bSpwcGetLinkError+0xdc>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110a5bc:	e0bfff17 	ldw	r2,-4(fp)
8110a5c0:	10800017 	ldw	r2,0(r2)
8110a5c4:	000b883a 	mov	r5,zero
8110a5c8:	1009883a 	mov	r4,r2
8110a5cc:	110aa440 	call	8110aa44 <uliSpwcReadReg>
8110a5d0:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKERR_DISCONNECT_MSK) {
8110a5d4:	e0bffe17 	ldw	r2,-8(fp)
8110a5d8:	1080006c 	andhi	r2,r2,1
8110a5dc:	10000426 	beq	r2,zero,8110a5f0 <bSpwcGetLinkError+0x60>
			pxSpwcCh->xLinkError.bDisconnect = TRUE;
8110a5e0:	e0bfff17 	ldw	r2,-4(fp)
8110a5e4:	00c00044 	movi	r3,1
8110a5e8:	10c00515 	stw	r3,20(r2)
8110a5ec:	00000206 	br	8110a5f8 <bSpwcGetLinkError+0x68>
		} else {
			pxSpwcCh->xLinkError.bDisconnect = FALSE;
8110a5f0:	e0bfff17 	ldw	r2,-4(fp)
8110a5f4:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_PARITY_MSK) {
8110a5f8:	e0bffe17 	ldw	r2,-8(fp)
8110a5fc:	108000ac 	andhi	r2,r2,2
8110a600:	10000426 	beq	r2,zero,8110a614 <bSpwcGetLinkError+0x84>
			pxSpwcCh->xLinkError.bParity = TRUE;
8110a604:	e0bfff17 	ldw	r2,-4(fp)
8110a608:	00c00044 	movi	r3,1
8110a60c:	10c00615 	stw	r3,24(r2)
8110a610:	00000206 	br	8110a61c <bSpwcGetLinkError+0x8c>
		} else {
			pxSpwcCh->xLinkError.bParity = FALSE;
8110a614:	e0bfff17 	ldw	r2,-4(fp)
8110a618:	10000615 	stw	zero,24(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_ESCAPE_MSK) {
8110a61c:	e0bffe17 	ldw	r2,-8(fp)
8110a620:	1080012c 	andhi	r2,r2,4
8110a624:	10000426 	beq	r2,zero,8110a638 <bSpwcGetLinkError+0xa8>
			pxSpwcCh->xLinkError.bEscape = TRUE;
8110a628:	e0bfff17 	ldw	r2,-4(fp)
8110a62c:	00c00044 	movi	r3,1
8110a630:	10c00715 	stw	r3,28(r2)
8110a634:	00000206 	br	8110a640 <bSpwcGetLinkError+0xb0>
		} else {
			pxSpwcCh->xLinkError.bEscape = FALSE;
8110a638:	e0bfff17 	ldw	r2,-4(fp)
8110a63c:	10000715 	stw	zero,28(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_CREDIT_MSK) {
8110a640:	e0bffe17 	ldw	r2,-8(fp)
8110a644:	1080022c 	andhi	r2,r2,8
8110a648:	10000426 	beq	r2,zero,8110a65c <bSpwcGetLinkError+0xcc>
			pxSpwcCh->xLinkError.bCredit = TRUE;
8110a64c:	e0bfff17 	ldw	r2,-4(fp)
8110a650:	00c00044 	movi	r3,1
8110a654:	10c00815 	stw	r3,32(r2)
8110a658:	00000206 	br	8110a664 <bSpwcGetLinkError+0xd4>
		} else {
			pxSpwcCh->xLinkError.bCredit = FALSE;
8110a65c:	e0bfff17 	ldw	r2,-4(fp)
8110a660:	10000815 	stw	zero,32(r2)
		}

		bStatus = TRUE;
8110a664:	00800044 	movi	r2,1
8110a668:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a66c:	e0bffd17 	ldw	r2,-12(fp)
}
8110a670:	e037883a 	mov	sp,fp
8110a674:	dfc00117 	ldw	ra,4(sp)
8110a678:	df000017 	ldw	fp,0(sp)
8110a67c:	dec00204 	addi	sp,sp,8
8110a680:	f800283a 	ret

8110a684 <bSpwcGetLinkStatus>:

bool bSpwcGetLinkStatus(TSpwcChannel *pxSpwcCh) {
8110a684:	defffb04 	addi	sp,sp,-20
8110a688:	de00012e 	bgeu	sp,et,8110a690 <bSpwcGetLinkStatus+0xc>
8110a68c:	003b68fa 	trap	3
8110a690:	dfc00415 	stw	ra,16(sp)
8110a694:	df000315 	stw	fp,12(sp)
8110a698:	df000304 	addi	fp,sp,12
8110a69c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110a6a0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110a6a4:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110a6a8:	e0bfff17 	ldw	r2,-4(fp)
8110a6ac:	10002326 	beq	r2,zero,8110a73c <bSpwcGetLinkStatus+0xb8>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110a6b0:	e0bfff17 	ldw	r2,-4(fp)
8110a6b4:	10800017 	ldw	r2,0(r2)
8110a6b8:	000b883a 	mov	r5,zero
8110a6bc:	1009883a 	mov	r4,r2
8110a6c0:	110aa440 	call	8110aa44 <uliSpwcReadReg>
8110a6c4:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKSTAT_STARTED_MSK) {
8110a6c8:	e0bffe17 	ldw	r2,-8(fp)
8110a6cc:	1081000c 	andi	r2,r2,1024
8110a6d0:	10000426 	beq	r2,zero,8110a6e4 <bSpwcGetLinkStatus+0x60>
			pxSpwcCh->xLinkStatus.bStarted = TRUE;
8110a6d4:	e0bfff17 	ldw	r2,-4(fp)
8110a6d8:	00c00044 	movi	r3,1
8110a6dc:	10c00915 	stw	r3,36(r2)
8110a6e0:	00000206 	br	8110a6ec <bSpwcGetLinkStatus+0x68>
		} else {
			pxSpwcCh->xLinkStatus.bStarted = FALSE;
8110a6e4:	e0bfff17 	ldw	r2,-4(fp)
8110a6e8:	10000915 	stw	zero,36(r2)
		}
		if (uliReg & COMM_SPW_LNKSTAT_CONNECTING_MSK) {
8110a6ec:	e0bffe17 	ldw	r2,-8(fp)
8110a6f0:	1080800c 	andi	r2,r2,512
8110a6f4:	10000426 	beq	r2,zero,8110a708 <bSpwcGetLinkStatus+0x84>
			pxSpwcCh->xLinkStatus.bConnecting = TRUE;
8110a6f8:	e0bfff17 	ldw	r2,-4(fp)
8110a6fc:	00c00044 	movi	r3,1
8110a700:	10c00a15 	stw	r3,40(r2)
8110a704:	00000206 	br	8110a710 <bSpwcGetLinkStatus+0x8c>
		} else {
			pxSpwcCh->xLinkStatus.bConnecting = FALSE;
8110a708:	e0bfff17 	ldw	r2,-4(fp)
8110a70c:	10000a15 	stw	zero,40(r2)
		}
		if (uliReg & COMM_SPW_LNKSTAT_RUNNING_MSK) {
8110a710:	e0bffe17 	ldw	r2,-8(fp)
8110a714:	1080400c 	andi	r2,r2,256
8110a718:	10000426 	beq	r2,zero,8110a72c <bSpwcGetLinkStatus+0xa8>
			pxSpwcCh->xLinkStatus.bRunning = TRUE;
8110a71c:	e0bfff17 	ldw	r2,-4(fp)
8110a720:	00c00044 	movi	r3,1
8110a724:	10c00b15 	stw	r3,44(r2)
8110a728:	00000206 	br	8110a734 <bSpwcGetLinkStatus+0xb0>
		} else {
			pxSpwcCh->xLinkStatus.bRunning = FALSE;
8110a72c:	e0bfff17 	ldw	r2,-4(fp)
8110a730:	10000b15 	stw	zero,44(r2)
		}

		bStatus = TRUE;
8110a734:	00800044 	movi	r2,1
8110a738:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a73c:	e0bffd17 	ldw	r2,-12(fp)
}
8110a740:	e037883a 	mov	sp,fp
8110a744:	dfc00117 	ldw	ra,4(sp)
8110a748:	df000017 	ldw	fp,0(sp)
8110a74c:	dec00204 	addi	sp,sp,8
8110a750:	f800283a 	ret

8110a754 <bSpwcGetTimecode>:

bool bSpwcGetTimecode(TSpwcChannel *pxSpwcCh) {
8110a754:	defffb04 	addi	sp,sp,-20
8110a758:	de00012e 	bgeu	sp,et,8110a760 <bSpwcGetTimecode+0xc>
8110a75c:	003b68fa 	trap	3
8110a760:	dfc00415 	stw	ra,16(sp)
8110a764:	df000315 	stw	fp,12(sp)
8110a768:	df000304 	addi	fp,sp,12
8110a76c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110a770:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110a774:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110a778:	e0bfff17 	ldw	r2,-4(fp)
8110a77c:	10001326 	beq	r2,zero,8110a7cc <bSpwcGetTimecode+0x78>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110a780:	e0bfff17 	ldw	r2,-4(fp)
8110a784:	10800017 	ldw	r2,0(r2)
8110a788:	01400044 	movi	r5,1
8110a78c:	1009883a 	mov	r4,r2
8110a790:	110aa440 	call	8110aa44 <uliSpwcReadReg>
8110a794:	e0bffe15 	stw	r2,-8(fp)
		COMM_TIMECODE_REG_OFST);

		pxSpwcCh->xTimecode.ucControl= (alt_u8)(
				(uliReg & COMM_TIMECODE_CONTROL_MSK) >> 6);
8110a798:	e0bffe17 	ldw	r2,-8(fp)
8110a79c:	1080300c 	andi	r2,r2,192
8110a7a0:	1004d1ba 	srli	r2,r2,6

	if (pxSpwcCh != NULL) {
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
		COMM_TIMECODE_REG_OFST);

		pxSpwcCh->xTimecode.ucControl= (alt_u8)(
8110a7a4:	1007883a 	mov	r3,r2
8110a7a8:	e0bfff17 	ldw	r2,-4(fp)
8110a7ac:	10c00c05 	stb	r3,48(r2)
				(uliReg & COMM_TIMECODE_CONTROL_MSK) >> 6);
		pxSpwcCh->xTimecode.ucCounter= (alt_u8)(
8110a7b0:	e0bffe17 	ldw	r2,-8(fp)
8110a7b4:	10800fcc 	andi	r2,r2,63
8110a7b8:	1007883a 	mov	r3,r2
8110a7bc:	e0bfff17 	ldw	r2,-4(fp)
8110a7c0:	10c00c45 	stb	r3,49(r2)
				(uliReg & COMM_TIMECODE_TIME_MSK) >> 0);

		bStatus = TRUE;
8110a7c4:	00800044 	movi	r2,1
8110a7c8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a7cc:	e0bffd17 	ldw	r2,-12(fp)
}
8110a7d0:	e037883a 	mov	sp,fp
8110a7d4:	dfc00117 	ldw	ra,4(sp)
8110a7d8:	df000017 	ldw	fp,0(sp)
8110a7dc:	dec00204 	addi	sp,sp,8
8110a7e0:	f800283a 	ret

8110a7e4 <bSpwcClearTimecode>:

bool bSpwcClearTimecode(TSpwcChannel *pxSpwcCh) {
8110a7e4:	defffb04 	addi	sp,sp,-20
8110a7e8:	de00012e 	bgeu	sp,et,8110a7f0 <bSpwcClearTimecode+0xc>
8110a7ec:	003b68fa 	trap	3
8110a7f0:	dfc00415 	stw	ra,16(sp)
8110a7f4:	df000315 	stw	fp,12(sp)
8110a7f8:	df000304 	addi	fp,sp,12
8110a7fc:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110a800:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110a804:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110a808:	e0bfff17 	ldw	r2,-4(fp)
8110a80c:	10001126 	beq	r2,zero,8110a854 <bSpwcClearTimecode+0x70>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110a810:	e0bfff17 	ldw	r2,-4(fp)
8110a814:	10800017 	ldw	r2,0(r2)
8110a818:	01400044 	movi	r5,1
8110a81c:	1009883a 	mov	r4,r2
8110a820:	110aa440 	call	8110aa44 <uliSpwcReadReg>
8110a824:	e0bffe15 	stw	r2,-8(fp)
		COMM_TIMECODE_REG_OFST);

		uliReg |= COMM_TIMECODE_CLR_MSK;
8110a828:	e0bffe17 	ldw	r2,-8(fp)
8110a82c:	10804014 	ori	r2,r2,256
8110a830:	e0bffe15 	stw	r2,-8(fp)

		vSpwcWriteReg(pxSpwcCh->puliSpwcChAddr, COMM_TIMECODE_REG_OFST, uliReg);
8110a834:	e0bfff17 	ldw	r2,-4(fp)
8110a838:	10800017 	ldw	r2,0(r2)
8110a83c:	e1bffe17 	ldw	r6,-8(fp)
8110a840:	01400044 	movi	r5,1
8110a844:	1009883a 	mov	r4,r2
8110a848:	110a9f00 	call	8110a9f0 <vSpwcWriteReg>
		bStatus = TRUE;
8110a84c:	00800044 	movi	r2,1
8110a850:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a854:	e0bffd17 	ldw	r2,-12(fp)
}
8110a858:	e037883a 	mov	sp,fp
8110a85c:	dfc00117 	ldw	ra,4(sp)
8110a860:	df000017 	ldw	fp,0(sp)
8110a864:	dec00204 	addi	sp,sp,8
8110a868:	f800283a 	ret

8110a86c <bSpwcInitCh>:

bool bSpwcInitCh(TSpwcChannel *pxSpwcCh, alt_u8 ucCommCh) {
8110a86c:	defffb04 	addi	sp,sp,-20
8110a870:	de00012e 	bgeu	sp,et,8110a878 <bSpwcInitCh+0xc>
8110a874:	003b68fa 	trap	3
8110a878:	dfc00415 	stw	ra,16(sp)
8110a87c:	df000315 	stw	fp,12(sp)
8110a880:	df000304 	addi	fp,sp,12
8110a884:	e13ffe15 	stw	r4,-8(fp)
8110a888:	2805883a 	mov	r2,r5
8110a88c:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
8110a890:	e03ffd15 	stw	zero,-12(fp)

	if (pxSpwcCh != NULL) {
8110a894:	e0bffe17 	ldw	r2,-8(fp)
8110a898:	10004f26 	beq	r2,zero,8110a9d8 <bSpwcInitCh+0x16c>
		bStatus = TRUE;
8110a89c:	00800044 	movi	r2,1
8110a8a0:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
8110a8a4:	e0bfff03 	ldbu	r2,-4(fp)
8110a8a8:	10c00228 	cmpgeui	r3,r2,8
8110a8ac:	1800361e 	bne	r3,zero,8110a988 <bSpwcInitCh+0x11c>
8110a8b0:	100690ba 	slli	r3,r2,2
8110a8b4:	00a04474 	movhi	r2,33041
8110a8b8:	10aa3204 	addi	r2,r2,-22328
8110a8bc:	1885883a 	add	r2,r3,r2
8110a8c0:	10800017 	ldw	r2,0(r2)
8110a8c4:	1000683a 	jmp	r2
8110a8c8:	8110a8e8 	cmpgeui	r4,r16,17059
8110a8cc:	8110a8fc 	xorhi	r4,r16,17059
8110a8d0:	8110a910 	cmplti	r4,r16,17060
8110a8d4:	8110a924 	muli	r4,r16,17060
8110a8d8:	8110a938 	rdprs	r4,r16,17060
8110a8dc:	8110a94c 	andi	r4,r16,17061
8110a8e0:	8110a960 	cmpeqi	r4,r16,17061
8110a8e4:	8110a974 	orhi	r4,r16,17061
		case eCommSpwCh1:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
8110a8e8:	e0fffe17 	ldw	r3,-8(fp)
8110a8ec:	00a04834 	movhi	r2,33056
8110a8f0:	108b0004 	addi	r2,r2,11264
8110a8f4:	18800015 	stw	r2,0(r3)
			break;
8110a8f8:	00002506 	br	8110a990 <bSpwcInitCh+0x124>
		case eCommSpwCh2:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
8110a8fc:	e0fffe17 	ldw	r3,-8(fp)
8110a900:	00a04834 	movhi	r2,33056
8110a904:	108a0004 	addi	r2,r2,10240
8110a908:	18800015 	stw	r2,0(r3)
			break;
8110a90c:	00002006 	br	8110a990 <bSpwcInitCh+0x124>
		case eCommSpwCh3:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
8110a910:	e0fffe17 	ldw	r3,-8(fp)
8110a914:	00a04834 	movhi	r2,33056
8110a918:	108b0004 	addi	r2,r2,11264
8110a91c:	18800015 	stw	r2,0(r3)
			break;
8110a920:	00001b06 	br	8110a990 <bSpwcInitCh+0x124>
		case eCommSpwCh4:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
8110a924:	e0fffe17 	ldw	r3,-8(fp)
8110a928:	00a04834 	movhi	r2,33056
8110a92c:	108a0004 	addi	r2,r2,10240
8110a930:	18800015 	stw	r2,0(r3)
			break;
8110a934:	00001606 	br	8110a990 <bSpwcInitCh+0x124>
		case eCommSpwCh5:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
8110a938:	e0fffe17 	ldw	r3,-8(fp)
8110a93c:	00a04834 	movhi	r2,33056
8110a940:	108b0004 	addi	r2,r2,11264
8110a944:	18800015 	stw	r2,0(r3)
			break;
8110a948:	00001106 	br	8110a990 <bSpwcInitCh+0x124>
		case eCommSpwCh6:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
8110a94c:	e0fffe17 	ldw	r3,-8(fp)
8110a950:	00a04834 	movhi	r2,33056
8110a954:	108a0004 	addi	r2,r2,10240
8110a958:	18800015 	stw	r2,0(r3)
			break;
8110a95c:	00000c06 	br	8110a990 <bSpwcInitCh+0x124>
		case eCommSpwCh7:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
8110a960:	e0fffe17 	ldw	r3,-8(fp)
8110a964:	00a04834 	movhi	r2,33056
8110a968:	108b0004 	addi	r2,r2,11264
8110a96c:	18800015 	stw	r2,0(r3)
			break;
8110a970:	00000706 	br	8110a990 <bSpwcInitCh+0x124>
		case eCommSpwCh8:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
8110a974:	e0fffe17 	ldw	r3,-8(fp)
8110a978:	00a04834 	movhi	r2,33056
8110a97c:	108a0004 	addi	r2,r2,10240
8110a980:	18800015 	stw	r2,0(r3)
			break;
8110a984:	00000206 	br	8110a990 <bSpwcInitCh+0x124>
		default:
			bStatus = FALSE;
8110a988:	e03ffd15 	stw	zero,-12(fp)
			break;
8110a98c:	0001883a 	nop
		}

		if (bStatus) {
8110a990:	e0bffd17 	ldw	r2,-12(fp)
8110a994:	10001026 	beq	r2,zero,8110a9d8 <bSpwcInitCh+0x16c>
			if (!bSpwcGetLink(pxSpwcCh)) {
8110a998:	e13ffe17 	ldw	r4,-8(fp)
8110a99c:	110a4ac0 	call	8110a4ac <bSpwcGetLink>
8110a9a0:	1000011e 	bne	r2,zero,8110a9a8 <bSpwcInitCh+0x13c>
				bStatus = FALSE;
8110a9a4:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetLinkError(pxSpwcCh)) {
8110a9a8:	e13ffe17 	ldw	r4,-8(fp)
8110a9ac:	110a5900 	call	8110a590 <bSpwcGetLinkError>
8110a9b0:	1000011e 	bne	r2,zero,8110a9b8 <bSpwcInitCh+0x14c>
				bStatus = FALSE;
8110a9b4:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetLinkStatus(pxSpwcCh)) {
8110a9b8:	e13ffe17 	ldw	r4,-8(fp)
8110a9bc:	110a6840 	call	8110a684 <bSpwcGetLinkStatus>
8110a9c0:	1000011e 	bne	r2,zero,8110a9c8 <bSpwcInitCh+0x15c>
				bStatus = FALSE;
8110a9c4:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetTimecode(pxSpwcCh)) {
8110a9c8:	e13ffe17 	ldw	r4,-8(fp)
8110a9cc:	110a7540 	call	8110a754 <bSpwcGetTimecode>
8110a9d0:	1000011e 	bne	r2,zero,8110a9d8 <bSpwcInitCh+0x16c>
				bStatus = FALSE;
8110a9d4:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
8110a9d8:	e0bffd17 	ldw	r2,-12(fp)
}
8110a9dc:	e037883a 	mov	sp,fp
8110a9e0:	dfc00117 	ldw	ra,4(sp)
8110a9e4:	df000017 	ldw	fp,0(sp)
8110a9e8:	dec00204 	addi	sp,sp,8
8110a9ec:	f800283a 	ret

8110a9f0 <vSpwcWriteReg>:
//! [public functions]

//! [private functions]
static void vSpwcWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
8110a9f0:	defffc04 	addi	sp,sp,-16
8110a9f4:	de00012e 	bgeu	sp,et,8110a9fc <vSpwcWriteReg+0xc>
8110a9f8:	003b68fa 	trap	3
8110a9fc:	df000315 	stw	fp,12(sp)
8110aa00:	df000304 	addi	fp,sp,12
8110aa04:	e13ffd15 	stw	r4,-12(fp)
8110aa08:	e17ffe15 	stw	r5,-8(fp)
8110aa0c:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
8110aa10:	e0bffe17 	ldw	r2,-8(fp)
8110aa14:	1085883a 	add	r2,r2,r2
8110aa18:	1085883a 	add	r2,r2,r2
8110aa1c:	1007883a 	mov	r3,r2
8110aa20:	e0bffd17 	ldw	r2,-12(fp)
8110aa24:	10c5883a 	add	r2,r2,r3
8110aa28:	e0ffff17 	ldw	r3,-4(fp)
8110aa2c:	10c00015 	stw	r3,0(r2)
}
8110aa30:	0001883a 	nop
8110aa34:	e037883a 	mov	sp,fp
8110aa38:	df000017 	ldw	fp,0(sp)
8110aa3c:	dec00104 	addi	sp,sp,4
8110aa40:	f800283a 	ret

8110aa44 <uliSpwcReadReg>:

static alt_u32 uliSpwcReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8110aa44:	defffc04 	addi	sp,sp,-16
8110aa48:	de00012e 	bgeu	sp,et,8110aa50 <uliSpwcReadReg+0xc>
8110aa4c:	003b68fa 	trap	3
8110aa50:	df000315 	stw	fp,12(sp)
8110aa54:	df000304 	addi	fp,sp,12
8110aa58:	e13ffe15 	stw	r4,-8(fp)
8110aa5c:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
8110aa60:	e0bfff17 	ldw	r2,-4(fp)
8110aa64:	1085883a 	add	r2,r2,r2
8110aa68:	1085883a 	add	r2,r2,r2
8110aa6c:	1007883a 	mov	r3,r2
8110aa70:	e0bffe17 	ldw	r2,-8(fp)
8110aa74:	10c5883a 	add	r2,r2,r3
8110aa78:	10800017 	ldw	r2,0(r2)
8110aa7c:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8110aa80:	e0bffd17 	ldw	r2,-12(fp)
}
8110aa84:	e037883a 	mov	sp,fp
8110aa88:	df000017 	ldw	fp,0(sp)
8110aa8c:	dec00104 	addi	sp,sp,4
8110aa90:	f800283a 	ret

8110aa94 <bEnableIsoDrivers>:
//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bEnableIsoDrivers(void)
{
8110aa94:	defffe04 	addi	sp,sp,-8
8110aa98:	de00012e 	bgeu	sp,et,8110aaa0 <bEnableIsoDrivers+0xc>
8110aa9c:	003b68fa 	trap	3
8110aaa0:	dfc00115 	stw	ra,4(sp)
8110aaa4:	df000015 	stw	fp,0(sp)
8110aaa8:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_EN_ISO_DRIVERS_MSK);
8110aaac:	01400204 	movi	r5,8
8110aab0:	01000044 	movi	r4,1
8110aab4:	110ac440 	call	8110ac44 <bCtrlIoLvdsDrive>
  return  TRUE;
8110aab8:	00800044 	movi	r2,1
}
8110aabc:	e037883a 	mov	sp,fp
8110aac0:	dfc00117 	ldw	ra,4(sp)
8110aac4:	df000017 	ldw	fp,0(sp)
8110aac8:	dec00204 	addi	sp,sp,8
8110aacc:	f800283a 	ret

8110aad0 <bDisableIsoDrivers>:

bool bDisableIsoDrivers(void)
{
8110aad0:	defffe04 	addi	sp,sp,-8
8110aad4:	de00012e 	bgeu	sp,et,8110aadc <bDisableIsoDrivers+0xc>
8110aad8:	003b68fa 	trap	3
8110aadc:	dfc00115 	stw	ra,4(sp)
8110aae0:	df000015 	stw	fp,0(sp)
8110aae4:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_EN_ISO_DRIVERS_MSK);
8110aae8:	01400204 	movi	r5,8
8110aaec:	0009883a 	mov	r4,zero
8110aaf0:	110ac440 	call	8110ac44 <bCtrlIoLvdsDrive>
  return  TRUE;
8110aaf4:	00800044 	movi	r2,1
}
8110aaf8:	e037883a 	mov	sp,fp
8110aafc:	dfc00117 	ldw	ra,4(sp)
8110ab00:	df000017 	ldw	fp,0(sp)
8110ab04:	dec00204 	addi	sp,sp,8
8110ab08:	f800283a 	ret

8110ab0c <bEnableLvdsBoard>:

bool bEnableLvdsBoard(void)
{
8110ab0c:	defffe04 	addi	sp,sp,-8
8110ab10:	de00012e 	bgeu	sp,et,8110ab18 <bEnableLvdsBoard+0xc>
8110ab14:	003b68fa 	trap	3
8110ab18:	dfc00115 	stw	ra,4(sp)
8110ab1c:	df000015 	stw	fp,0(sp)
8110ab20:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PWDN_MSK);
8110ab24:	01400104 	movi	r5,4
8110ab28:	01000044 	movi	r4,1
8110ab2c:	110ac440 	call	8110ac44 <bCtrlIoLvdsDrive>
  return  TRUE;
8110ab30:	00800044 	movi	r2,1
}
8110ab34:	e037883a 	mov	sp,fp
8110ab38:	dfc00117 	ldw	ra,4(sp)
8110ab3c:	df000017 	ldw	fp,0(sp)
8110ab40:	dec00204 	addi	sp,sp,8
8110ab44:	f800283a 	ret

8110ab48 <bDisableLvdsBoard>:

bool bDisableLvdsBoard(void)
{
8110ab48:	defffe04 	addi	sp,sp,-8
8110ab4c:	de00012e 	bgeu	sp,et,8110ab54 <bDisableLvdsBoard+0xc>
8110ab50:	003b68fa 	trap	3
8110ab54:	dfc00115 	stw	ra,4(sp)
8110ab58:	df000015 	stw	fp,0(sp)
8110ab5c:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PWDN_MSK);
8110ab60:	01400104 	movi	r5,4
8110ab64:	0009883a 	mov	r4,zero
8110ab68:	110ac440 	call	8110ac44 <bCtrlIoLvdsDrive>
  return  TRUE;
8110ab6c:	00800044 	movi	r2,1
}
8110ab70:	e037883a 	mov	sp,fp
8110ab74:	dfc00117 	ldw	ra,4(sp)
8110ab78:	df000017 	ldw	fp,0(sp)
8110ab7c:	dec00204 	addi	sp,sp,8
8110ab80:	f800283a 	ret

8110ab84 <bSetPreEmphasys>:

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
8110ab84:	defffd04 	addi	sp,sp,-12
8110ab88:	de00012e 	bgeu	sp,et,8110ab90 <bSetPreEmphasys+0xc>
8110ab8c:	003b68fa 	trap	3
8110ab90:	dfc00215 	stw	ra,8(sp)
8110ab94:	df000115 	stw	fp,4(sp)
8110ab98:	df000104 	addi	fp,sp,4
8110ab9c:	2005883a 	mov	r2,r4
8110aba0:	e0bfff05 	stb	r2,-4(fp)
  switch (ucPemLevel) {
8110aba4:	e0bfff03 	ldbu	r2,-4(fp)
8110aba8:	10c00060 	cmpeqi	r3,r2,1
8110abac:	18000d1e 	bne	r3,zero,8110abe4 <bSetPreEmphasys+0x60>
8110abb0:	10c00088 	cmpgei	r3,r2,2
8110abb4:	1800021e 	bne	r3,zero,8110abc0 <bSetPreEmphasys+0x3c>
8110abb8:	10000626 	beq	r2,zero,8110abd4 <bSetPreEmphasys+0x50>
      break;
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
      break;
    default:
      break;
8110abbc:	00001b06 	br	8110ac2c <bSetPreEmphasys+0xa8>
  return  TRUE;
}

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
  switch (ucPemLevel) {
8110abc0:	10c000a0 	cmpeqi	r3,r2,2
8110abc4:	18000e1e 	bne	r3,zero,8110ac00 <bSetPreEmphasys+0x7c>
8110abc8:	108000e0 	cmpeqi	r2,r2,3
8110abcc:	1000131e 	bne	r2,zero,8110ac1c <bSetPreEmphasys+0x98>
      break;
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
      break;
    default:
      break;
8110abd0:	00001606 	br	8110ac2c <bSetPreEmphasys+0xa8>

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
  switch (ucPemLevel) {
    case LVDS_PEM_OFF:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
8110abd4:	014000c4 	movi	r5,3
8110abd8:	0009883a 	mov	r4,zero
8110abdc:	110ac440 	call	8110ac44 <bCtrlIoLvdsDrive>
      break;
8110abe0:	00001206 	br	8110ac2c <bSetPreEmphasys+0xa8>
    case LVDS_PEM_LO:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM1_MSK);
8110abe4:	01400084 	movi	r5,2
8110abe8:	0009883a 	mov	r4,zero
8110abec:	110ac440 	call	8110ac44 <bCtrlIoLvdsDrive>
      bCtrlIoLvdsDrive(LVDS_IO_ON,  LVDS_PEM0_MSK);
8110abf0:	01400044 	movi	r5,1
8110abf4:	01000044 	movi	r4,1
8110abf8:	110ac440 	call	8110ac44 <bCtrlIoLvdsDrive>
      break;
8110abfc:	00000b06 	br	8110ac2c <bSetPreEmphasys+0xa8>
    case LVDS_PEM_MID:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM0_MSK);
8110ac00:	01400044 	movi	r5,1
8110ac04:	0009883a 	mov	r4,zero
8110ac08:	110ac440 	call	8110ac44 <bCtrlIoLvdsDrive>
      bCtrlIoLvdsDrive(LVDS_IO_ON,  LVDS_PEM1_MSK);
8110ac0c:	01400084 	movi	r5,2
8110ac10:	01000044 	movi	r4,1
8110ac14:	110ac440 	call	8110ac44 <bCtrlIoLvdsDrive>
      break;
8110ac18:	00000406 	br	8110ac2c <bSetPreEmphasys+0xa8>
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
8110ac1c:	014000c4 	movi	r5,3
8110ac20:	01000044 	movi	r4,1
8110ac24:	110ac440 	call	8110ac44 <bCtrlIoLvdsDrive>
      break;
8110ac28:	0001883a 	nop
    default:
      break;
  }
  return TRUE;
8110ac2c:	00800044 	movi	r2,1
}
8110ac30:	e037883a 	mov	sp,fp
8110ac34:	dfc00117 	ldw	ra,4(sp)
8110ac38:	df000017 	ldw	fp,0(sp)
8110ac3c:	dec00204 	addi	sp,sp,8
8110ac40:	f800283a 	ret

8110ac44 <bCtrlIoLvdsDrive>:
 * @param [in] ulliMask   -> mascara de i/os a serem alterados
 *
 * @retval TRUE -> sucesso
 */
static bool bCtrlIoLvdsDrive(bool bOnOff, alt_u8 ucMask)
{
8110ac44:	defffd04 	addi	sp,sp,-12
8110ac48:	de00012e 	bgeu	sp,et,8110ac50 <bCtrlIoLvdsDrive+0xc>
8110ac4c:	003b68fa 	trap	3
8110ac50:	df000215 	stw	fp,8(sp)
8110ac54:	df000204 	addi	fp,sp,8
8110ac58:	e13ffe15 	stw	r4,-8(fp)
8110ac5c:	2805883a 	mov	r2,r5
8110ac60:	e0bfff05 	stb	r2,-4(fp)
  if (bOnOff == LVDS_IO_OFF) {
8110ac64:	e0bffe17 	ldw	r2,-8(fp)
8110ac68:	1000071e 	bne	r2,zero,8110ac88 <bCtrlIoLvdsDrive+0x44>
	 ucIoValue &= (~ucMask);
8110ac6c:	e0bfff03 	ldbu	r2,-4(fp)
8110ac70:	0084303a 	nor	r2,zero,r2
8110ac74:	1007883a 	mov	r3,r2
8110ac78:	d0a00103 	ldbu	r2,-32764(gp)
8110ac7c:	1884703a 	and	r2,r3,r2
8110ac80:	d0a00105 	stb	r2,-32764(gp)
8110ac84:	00000406 	br	8110ac98 <bCtrlIoLvdsDrive+0x54>
  }
  else {
	 ucIoValue |= ucMask;
8110ac88:	d0e00103 	ldbu	r3,-32764(gp)
8110ac8c:	e0bfff03 	ldbu	r2,-4(fp)
8110ac90:	1884b03a 	or	r2,r3,r2
8110ac94:	d0a00105 	stb	r2,-32764(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LVDS_CTRL_IO_LVDS_ADDR_BASE, ucIoValue);
8110ac98:	d0a00103 	ldbu	r2,-32764(gp)
8110ac9c:	10c03fcc 	andi	r3,r2,255
8110aca0:	00a00034 	movhi	r2,32768
8110aca4:	10822804 	addi	r2,r2,2208
8110aca8:	10c00035 	stwio	r3,0(r2)
  return TRUE;
8110acac:	00800044 	movi	r2,1
}
8110acb0:	e037883a 	mov	sp,fp
8110acb4:	df000017 	ldw	fp,0(sp)
8110acb8:	dec00104 	addi	sp,sp,4
8110acbc:	f800283a 	ret

8110acc0 <I2C_TestAdress>:
void i2c_start(alt_u32 clk_base, alt_u32 data_base);
void i2c_stop(alt_u32 clk_base, alt_u32 data_base);
bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data);
void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck);

bool I2C_TestAdress(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr){
8110acc0:	defffa04 	addi	sp,sp,-24
8110acc4:	de00012e 	bgeu	sp,et,8110accc <I2C_TestAdress+0xc>
8110acc8:	003b68fa 	trap	3
8110accc:	dfc00515 	stw	ra,20(sp)
8110acd0:	df000415 	stw	fp,16(sp)
8110acd4:	df000404 	addi	fp,sp,16
8110acd8:	e13ffd15 	stw	r4,-12(fp)
8110acdc:	e17ffe15 	stw	r5,-8(fp)
8110ace0:	3005883a 	mov	r2,r6
8110ace4:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
8110ace8:	00800044 	movi	r2,1
8110acec:	e0bffc15 	stw	r2,-16(fp)
    //alt_u8 DeviceAddr;
    
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8110acf0:	e17ffe17 	ldw	r5,-8(fp)
8110acf4:	e13ffd17 	ldw	r4,-12(fp)
8110acf8:	110b0900 	call	8110b090 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8110acfc:	e0bfff03 	ldbu	r2,-4(fp)
8110ad00:	10803fcc 	andi	r2,r2,255
8110ad04:	100d883a 	mov	r6,r2
8110ad08:	e17ffe17 	ldw	r5,-8(fp)
8110ad0c:	e13ffd17 	ldw	r4,-12(fp)
8110ad10:	110b1a40 	call	8110b1a4 <i2c_write>
8110ad14:	1000011e 	bne	r2,zero,8110ad1c <I2C_TestAdress+0x5c>
        bSuccess = FALSE;
8110ad18:	e03ffc15 	stw	zero,-16(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    i2c_stop(clk_base, data_base);
8110ad1c:	e17ffe17 	ldw	r5,-8(fp)
8110ad20:	e13ffd17 	ldw	r4,-12(fp)
8110ad24:	110b1240 	call	8110b124 <i2c_stop>
    
    usleep(7*1000); // delay to wait EE2 ready (at least 5 ms delay is required)
8110ad28:	0106d604 	movi	r4,7000
8110ad2c:	1137d140 	call	81137d14 <usleep>
    
    return bSuccess;
8110ad30:	e0bffc17 	ldw	r2,-16(fp)

}
8110ad34:	e037883a 	mov	sp,fp
8110ad38:	dfc00117 	ldw	ra,4(sp)
8110ad3c:	df000017 	ldw	fp,0(sp)
8110ad40:	dec00204 	addi	sp,sp,8
8110ad44:	f800283a 	ret

8110ad48 <I2C_Write>:

bool I2C_Write(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 ControlData){
8110ad48:	defff804 	addi	sp,sp,-32
8110ad4c:	de00012e 	bgeu	sp,et,8110ad54 <I2C_Write+0xc>
8110ad50:	003b68fa 	trap	3
8110ad54:	dfc00715 	stw	ra,28(sp)
8110ad58:	df000615 	stw	fp,24(sp)
8110ad5c:	df000604 	addi	fp,sp,24
8110ad60:	e13ffb15 	stw	r4,-20(fp)
8110ad64:	e17ffc15 	stw	r5,-16(fp)
8110ad68:	3009883a 	mov	r4,r6
8110ad6c:	3807883a 	mov	r3,r7
8110ad70:	e0800217 	ldw	r2,8(fp)
8110ad74:	e13ffd05 	stb	r4,-12(fp)
8110ad78:	e0fffe05 	stb	r3,-8(fp)
8110ad7c:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
8110ad80:	00800044 	movi	r2,1
8110ad84:	e0bffa15 	stw	r2,-24(fp)
    //alt_u8 DeviceAddr;
    
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8110ad88:	e17ffc17 	ldw	r5,-16(fp)
8110ad8c:	e13ffb17 	ldw	r4,-20(fp)
8110ad90:	110b0900 	call	8110b090 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8110ad94:	e0bffd03 	ldbu	r2,-12(fp)
8110ad98:	10803fcc 	andi	r2,r2,255
8110ad9c:	100d883a 	mov	r6,r2
8110ada0:	e17ffc17 	ldw	r5,-16(fp)
8110ada4:	e13ffb17 	ldw	r4,-20(fp)
8110ada8:	110b1a40 	call	8110b1a4 <i2c_write>
8110adac:	1000011e 	bne	r2,zero,8110adb4 <I2C_Write+0x6c>
        bSuccess = FALSE;
8110adb0:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
8110adb4:	e0bffa17 	ldw	r2,-24(fp)
8110adb8:	10000726 	beq	r2,zero,8110add8 <I2C_Write+0x90>
8110adbc:	e0bffe03 	ldbu	r2,-8(fp)
8110adc0:	100d883a 	mov	r6,r2
8110adc4:	e17ffc17 	ldw	r5,-16(fp)
8110adc8:	e13ffb17 	ldw	r4,-20(fp)
8110adcc:	110b1a40 	call	8110b1a4 <i2c_write>
8110add0:	1000011e 	bne	r2,zero,8110add8 <I2C_Write+0x90>
        bSuccess = FALSE;
8110add4:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }            
    if (bSuccess && !i2c_write(clk_base, data_base, ControlData)){  
8110add8:	e0bffa17 	ldw	r2,-24(fp)
8110addc:	10000726 	beq	r2,zero,8110adfc <I2C_Write+0xb4>
8110ade0:	e0bfff03 	ldbu	r2,-4(fp)
8110ade4:	100d883a 	mov	r6,r2
8110ade8:	e17ffc17 	ldw	r5,-16(fp)
8110adec:	e13ffb17 	ldw	r4,-20(fp)
8110adf0:	110b1a40 	call	8110b1a4 <i2c_write>
8110adf4:	1000011e 	bne	r2,zero,8110adfc <I2C_Write+0xb4>
        bSuccess = FALSE;
8110adf8:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: write NACK!\n"));
    }
    i2c_stop(clk_base, data_base);
8110adfc:	e17ffc17 	ldw	r5,-16(fp)
8110ae00:	e13ffb17 	ldw	r4,-20(fp)
8110ae04:	110b1240 	call	8110b124 <i2c_stop>
    
    usleep(7*1000); // delay to wait EE2 ready (at least 5 ms delay is required)
8110ae08:	0106d604 	movi	r4,7000
8110ae0c:	1137d140 	call	81137d14 <usleep>
    
    return bSuccess;
8110ae10:	e0bffa17 	ldw	r2,-24(fp)

}
8110ae14:	e037883a 	mov	sp,fp
8110ae18:	dfc00117 	ldw	ra,4(sp)
8110ae1c:	df000017 	ldw	fp,0(sp)
8110ae20:	dec00204 	addi	sp,sp,8
8110ae24:	f800283a 	ret

8110ae28 <I2C_Read>:

bool I2C_Read(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 *pControlData){
8110ae28:	defff904 	addi	sp,sp,-28
8110ae2c:	de00012e 	bgeu	sp,et,8110ae34 <I2C_Read+0xc>
8110ae30:	003b68fa 	trap	3
8110ae34:	dfc00615 	stw	ra,24(sp)
8110ae38:	df000515 	stw	fp,20(sp)
8110ae3c:	df000504 	addi	fp,sp,20
8110ae40:	e13ffc15 	stw	r4,-16(fp)
8110ae44:	e17ffd15 	stw	r5,-12(fp)
8110ae48:	3007883a 	mov	r3,r6
8110ae4c:	3805883a 	mov	r2,r7
8110ae50:	e0fffe05 	stb	r3,-8(fp)
8110ae54:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
8110ae58:	00800044 	movi	r2,1
8110ae5c:	e0bffb15 	stw	r2,-20(fp)
    //alt_u8 DeviceAddr;
   
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8110ae60:	e17ffd17 	ldw	r5,-12(fp)
8110ae64:	e13ffc17 	ldw	r4,-16(fp)
8110ae68:	110b0900 	call	8110b090 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8110ae6c:	e0bffe03 	ldbu	r2,-8(fp)
8110ae70:	10803fcc 	andi	r2,r2,255
8110ae74:	100d883a 	mov	r6,r2
8110ae78:	e17ffd17 	ldw	r5,-12(fp)
8110ae7c:	e13ffc17 	ldw	r4,-16(fp)
8110ae80:	110b1a40 	call	8110b1a4 <i2c_write>
8110ae84:	1000011e 	bne	r2,zero,8110ae8c <I2C_Read+0x64>
        bSuccess = FALSE;
8110ae88:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
8110ae8c:	e0bffb17 	ldw	r2,-20(fp)
8110ae90:	10000726 	beq	r2,zero,8110aeb0 <I2C_Read+0x88>
8110ae94:	e0bfff03 	ldbu	r2,-4(fp)
8110ae98:	100d883a 	mov	r6,r2
8110ae9c:	e17ffd17 	ldw	r5,-12(fp)
8110aea0:	e13ffc17 	ldw	r4,-16(fp)
8110aea4:	110b1a40 	call	8110b1a4 <i2c_write>
8110aea8:	1000011e 	bne	r2,zero,8110aeb0 <I2C_Read+0x88>
        bSuccess = FALSE;
8110aeac:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }            
    i2c_start(clk_base, data_base);  // restart
8110aeb0:	e17ffd17 	ldw	r5,-12(fp)
8110aeb4:	e13ffc17 	ldw	r4,-16(fp)
8110aeb8:	110b0900 	call	8110b090 <i2c_start>
    DeviceAddr |= 1; // Read
8110aebc:	e0bffe03 	ldbu	r2,-8(fp)
8110aec0:	10800054 	ori	r2,r2,1
8110aec4:	e0bffe05 	stb	r2,-8(fp)
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
8110aec8:	e0bffb17 	ldw	r2,-20(fp)
8110aecc:	10000826 	beq	r2,zero,8110aef0 <I2C_Read+0xc8>
8110aed0:	e0bffe03 	ldbu	r2,-8(fp)
8110aed4:	10803fcc 	andi	r2,r2,255
8110aed8:	100d883a 	mov	r6,r2
8110aedc:	e17ffd17 	ldw	r5,-12(fp)
8110aee0:	e13ffc17 	ldw	r4,-16(fp)
8110aee4:	110b1a40 	call	8110b1a4 <i2c_write>
8110aee8:	1000011e 	bne	r2,zero,8110aef0 <I2C_Read+0xc8>
        bSuccess = FALSE;
8110aeec:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
8110aef0:	e0bffb17 	ldw	r2,-20(fp)
8110aef4:	10000526 	beq	r2,zero,8110af0c <I2C_Read+0xe4>
        i2c_read(clk_base, data_base, pControlData, FALSE);  // read
8110aef8:	000f883a 	mov	r7,zero
8110aefc:	e1800217 	ldw	r6,8(fp)
8110af00:	e17ffd17 	ldw	r5,-12(fp)
8110af04:	e13ffc17 	ldw	r4,-16(fp)
8110af08:	110b2dc0 	call	8110b2dc <i2c_read>
    }        
    i2c_stop(clk_base, data_base);
8110af0c:	e17ffd17 	ldw	r5,-12(fp)
8110af10:	e13ffc17 	ldw	r4,-16(fp)
8110af14:	110b1240 	call	8110b124 <i2c_stop>
    
    return bSuccess;
8110af18:	e0bffb17 	ldw	r2,-20(fp)
}
8110af1c:	e037883a 	mov	sp,fp
8110af20:	dfc00117 	ldw	ra,4(sp)
8110af24:	df000017 	ldw	fp,0(sp)
8110af28:	dec00204 	addi	sp,sp,8
8110af2c:	f800283a 	ret

8110af30 <I2C_MultipleRead>:

bool I2C_MultipleRead(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 szData[], alt_u16 len){
8110af30:	defff604 	addi	sp,sp,-40
8110af34:	de00012e 	bgeu	sp,et,8110af3c <I2C_MultipleRead+0xc>
8110af38:	003b68fa 	trap	3
8110af3c:	dfc00915 	stw	ra,36(sp)
8110af40:	df000815 	stw	fp,32(sp)
8110af44:	df000804 	addi	fp,sp,32
8110af48:	e13ffb15 	stw	r4,-20(fp)
8110af4c:	e17ffc15 	stw	r5,-16(fp)
8110af50:	3007883a 	mov	r3,r6
8110af54:	e1fffe15 	stw	r7,-8(fp)
8110af58:	e0800217 	ldw	r2,8(fp)
8110af5c:	e0fffd05 	stb	r3,-12(fp)
8110af60:	e0bfff0d 	sth	r2,-4(fp)
    int i;
    bool bSuccess = TRUE;
8110af64:	00800044 	movi	r2,1
8110af68:	e0bff915 	stw	r2,-28(fp)
    //alt_u8 DeviceAddr, 
    alt_u8 ControlAddr = 0;
8110af6c:	e03ffa05 	stb	zero,-24(fp)
    
   
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8110af70:	e17ffc17 	ldw	r5,-16(fp)
8110af74:	e13ffb17 	ldw	r4,-20(fp)
8110af78:	110b0900 	call	8110b090 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8110af7c:	e0bffd03 	ldbu	r2,-12(fp)
8110af80:	10803fcc 	andi	r2,r2,255
8110af84:	100d883a 	mov	r6,r2
8110af88:	e17ffc17 	ldw	r5,-16(fp)
8110af8c:	e13ffb17 	ldw	r4,-20(fp)
8110af90:	110b1a40 	call	8110b1a4 <i2c_write>
8110af94:	1000011e 	bne	r2,zero,8110af9c <I2C_MultipleRead+0x6c>
        bSuccess = FALSE;
8110af98:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
8110af9c:	e0bff917 	ldw	r2,-28(fp)
8110afa0:	10000726 	beq	r2,zero,8110afc0 <I2C_MultipleRead+0x90>
8110afa4:	e0bffa03 	ldbu	r2,-24(fp)
8110afa8:	100d883a 	mov	r6,r2
8110afac:	e17ffc17 	ldw	r5,-16(fp)
8110afb0:	e13ffb17 	ldw	r4,-20(fp)
8110afb4:	110b1a40 	call	8110b1a4 <i2c_write>
8110afb8:	1000011e 	bne	r2,zero,8110afc0 <I2C_MultipleRead+0x90>
        bSuccess = FALSE;
8110afbc:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }    
    if (bSuccess)        
8110afc0:	e0bff917 	ldw	r2,-28(fp)
8110afc4:	10000326 	beq	r2,zero,8110afd4 <I2C_MultipleRead+0xa4>
        i2c_start(clk_base, data_base);  // restart
8110afc8:	e17ffc17 	ldw	r5,-16(fp)
8110afcc:	e13ffb17 	ldw	r4,-20(fp)
8110afd0:	110b0900 	call	8110b090 <i2c_start>
    DeviceAddr |= 1; // Read
8110afd4:	e0bffd03 	ldbu	r2,-12(fp)
8110afd8:	10800054 	ori	r2,r2,1
8110afdc:	e0bffd05 	stb	r2,-12(fp)
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
8110afe0:	e0bff917 	ldw	r2,-28(fp)
8110afe4:	10000826 	beq	r2,zero,8110b008 <I2C_MultipleRead+0xd8>
8110afe8:	e0bffd03 	ldbu	r2,-12(fp)
8110afec:	10803fcc 	andi	r2,r2,255
8110aff0:	100d883a 	mov	r6,r2
8110aff4:	e17ffc17 	ldw	r5,-16(fp)
8110aff8:	e13ffb17 	ldw	r4,-20(fp)
8110affc:	110b1a40 	call	8110b1a4 <i2c_write>
8110b000:	1000011e 	bne	r2,zero,8110b008 <I2C_MultipleRead+0xd8>
        bSuccess = FALSE;
8110b004:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
8110b008:	e0bff917 	ldw	r2,-28(fp)
8110b00c:	10001726 	beq	r2,zero,8110b06c <I2C_MultipleRead+0x13c>
        for(i=0;i<len && bSuccess;i++){
8110b010:	e03ff815 	stw	zero,-32(fp)
8110b014:	00001006 	br	8110b058 <I2C_MultipleRead+0x128>
            i2c_read(clk_base, data_base, &szData[i], (i==(len-1))?FALSE:TRUE);  // read
8110b018:	e0bff817 	ldw	r2,-32(fp)
8110b01c:	e0fffe17 	ldw	r3,-8(fp)
8110b020:	1889883a 	add	r4,r3,r2
8110b024:	e0bfff0b 	ldhu	r2,-4(fp)
8110b028:	10ffffc4 	addi	r3,r2,-1
8110b02c:	e0bff817 	ldw	r2,-32(fp)
8110b030:	1884c03a 	cmpne	r2,r3,r2
8110b034:	10803fcc 	andi	r2,r2,255
8110b038:	100f883a 	mov	r7,r2
8110b03c:	200d883a 	mov	r6,r4
8110b040:	e17ffc17 	ldw	r5,-16(fp)
8110b044:	e13ffb17 	ldw	r4,-20(fp)
8110b048:	110b2dc0 	call	8110b2dc <i2c_read>
        bSuccess = FALSE;
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
        for(i=0;i<len && bSuccess;i++){
8110b04c:	e0bff817 	ldw	r2,-32(fp)
8110b050:	10800044 	addi	r2,r2,1
8110b054:	e0bff815 	stw	r2,-32(fp)
8110b058:	e0bfff0b 	ldhu	r2,-4(fp)
8110b05c:	e0fff817 	ldw	r3,-32(fp)
8110b060:	1880020e 	bge	r3,r2,8110b06c <I2C_MultipleRead+0x13c>
8110b064:	e0bff917 	ldw	r2,-28(fp)
8110b068:	103feb1e 	bne	r2,zero,8110b018 <__reset+0xfb0eb018>
            i2c_read(clk_base, data_base, &szData[i], (i==(len-1))?FALSE:TRUE);  // read
        }            
    }        
    i2c_stop(clk_base, data_base);
8110b06c:	e17ffc17 	ldw	r5,-16(fp)
8110b070:	e13ffb17 	ldw	r4,-20(fp)
8110b074:	110b1240 	call	8110b124 <i2c_stop>
    
    return bSuccess;    
8110b078:	e0bff917 	ldw	r2,-28(fp)
    
}
8110b07c:	e037883a 	mov	sp,fp
8110b080:	dfc00117 	ldw	ra,4(sp)
8110b084:	df000017 	ldw	fp,0(sp)
8110b088:	dec00204 	addi	sp,sp,8
8110b08c:	f800283a 	ret

8110b090 <i2c_start>:
///////////// Interncal function (i2cXXX) body //////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////


//SDA 1->0 while SCL=1
void i2c_start(alt_u32 clk_base, alt_u32 data_base){
8110b090:	defffc04 	addi	sp,sp,-16
8110b094:	de00012e 	bgeu	sp,et,8110b09c <i2c_start+0xc>
8110b098:	003b68fa 	trap	3
8110b09c:	dfc00315 	stw	ra,12(sp)
8110b0a0:	df000215 	stw	fp,8(sp)
8110b0a4:	df000204 	addi	fp,sp,8
8110b0a8:	e13ffe15 	stw	r4,-8(fp)
8110b0ac:	e17fff15 	stw	r5,-4(fp)
    
    // make sure it is in normal state
    SDA_DIR_OUT(data_base);  // data output enabled
8110b0b0:	e0bfff17 	ldw	r2,-4(fp)
8110b0b4:	10800104 	addi	r2,r2,4
8110b0b8:	1007883a 	mov	r3,r2
8110b0bc:	00800044 	movi	r2,1
8110b0c0:	18800035 	stwio	r2,0(r3)
    
    
    
    // start condition
    SDA_HIGH(data_base); // data high
8110b0c4:	e0bfff17 	ldw	r2,-4(fp)
8110b0c8:	00c00044 	movi	r3,1
8110b0cc:	10c00035 	stwio	r3,0(r2)
    SCL_HIGH(clk_base);
8110b0d0:	e0bffe17 	ldw	r2,-8(fp)
8110b0d4:	00c00044 	movi	r3,1
8110b0d8:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;
8110b0dc:	01000044 	movi	r4,1
8110b0e0:	1137d140 	call	81137d14 <usleep>
     
    SDA_LOW(data_base); // data low
8110b0e4:	e0bfff17 	ldw	r2,-4(fp)
8110b0e8:	0007883a 	mov	r3,zero
8110b0ec:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; 
8110b0f0:	01000044 	movi	r4,1
8110b0f4:	1137d140 	call	81137d14 <usleep>
    SCL_LOW(clk_base); // clock low
8110b0f8:	e0bffe17 	ldw	r2,-8(fp)
8110b0fc:	0007883a 	mov	r3,zero
8110b100:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;
8110b104:	01000044 	movi	r4,1
8110b108:	1137d140 	call	81137d14 <usleep>
}
8110b10c:	0001883a 	nop
8110b110:	e037883a 	mov	sp,fp
8110b114:	dfc00117 	ldw	ra,4(sp)
8110b118:	df000017 	ldw	fp,0(sp)
8110b11c:	dec00204 	addi	sp,sp,8
8110b120:	f800283a 	ret

8110b124 <i2c_stop>:

// SDA 0->1 while SCL=1
void i2c_stop(alt_u32 clk_base, alt_u32 data_base){
8110b124:	defffc04 	addi	sp,sp,-16
8110b128:	de00012e 	bgeu	sp,et,8110b130 <i2c_stop+0xc>
8110b12c:	003b68fa 	trap	3
8110b130:	dfc00315 	stw	ra,12(sp)
8110b134:	df000215 	stw	fp,8(sp)
8110b138:	df000204 	addi	fp,sp,8
8110b13c:	e13ffe15 	stw	r4,-8(fp)
8110b140:	e17fff15 	stw	r5,-4(fp)
    // assume SCL = 0
    
    SDA_DIR_OUT(data_base);  // data output enabled
8110b144:	e0bfff17 	ldw	r2,-4(fp)
8110b148:	10800104 	addi	r2,r2,4
8110b14c:	1007883a 	mov	r3,r2
8110b150:	00800044 	movi	r2,1
8110b154:	18800035 	stwio	r2,0(r3)
    SDA_LOW(data_base); // Data Low
8110b158:	e0bfff17 	ldw	r2,-4(fp)
8110b15c:	0007883a 	mov	r3,zero
8110b160:	10c00035 	stwio	r3,0(r2)
    //SCL_DELAY; 
    SCL_HIGH(clk_base);  // clock high
8110b164:	e0bffe17 	ldw	r2,-8(fp)
8110b168:	00c00044 	movi	r3,1
8110b16c:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock high long delay
8110b170:	01000044 	movi	r4,1
8110b174:	1137d140 	call	81137d14 <usleep>
    SDA_HIGH(data_base); // data high
8110b178:	e0bfff17 	ldw	r2,-4(fp)
8110b17c:	00c00044 	movi	r3,1
8110b180:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // data high delay
8110b184:	01000044 	movi	r4,1
8110b188:	1137d140 	call	81137d14 <usleep>
    

    
}
8110b18c:	0001883a 	nop
8110b190:	e037883a 	mov	sp,fp
8110b194:	dfc00117 	ldw	ra,4(sp)
8110b198:	df000017 	ldw	fp,0(sp)
8110b19c:	dec00204 	addi	sp,sp,8
8110b1a0:	f800283a 	ret

8110b1a4 <i2c_write>:

bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data){ // return true if device response ack
8110b1a4:	defff804 	addi	sp,sp,-32
8110b1a8:	de00012e 	bgeu	sp,et,8110b1b0 <i2c_write+0xc>
8110b1ac:	003b68fa 	trap	3
8110b1b0:	dfc00715 	stw	ra,28(sp)
8110b1b4:	df000615 	stw	fp,24(sp)
8110b1b8:	df000604 	addi	fp,sp,24
8110b1bc:	e13ffd15 	stw	r4,-12(fp)
8110b1c0:	e17ffe15 	stw	r5,-8(fp)
8110b1c4:	3005883a 	mov	r2,r6
8110b1c8:	e0bfff05 	stb	r2,-4(fp)
    alt_u8 Mask = 0x80;
8110b1cc:	00bfe004 	movi	r2,-128
8110b1d0:	e0bffa05 	stb	r2,-24(fp)
    bool bAck;
    int i;
    
    // assume, SCL = 0
    
    SDA_DIR_OUT(data_base);  // data write mode
8110b1d4:	e0bffe17 	ldw	r2,-8(fp)
8110b1d8:	10800104 	addi	r2,r2,4
8110b1dc:	1007883a 	mov	r3,r2
8110b1e0:	00800044 	movi	r2,1
8110b1e4:	18800035 	stwio	r2,0(r3)
    
    for(i=0;i<8;i++){
8110b1e8:	e03ffb15 	stw	zero,-20(fp)
8110b1ec:	00001f06 	br	8110b26c <i2c_write+0xc8>
        SCL_LOW(clk_base);  // new, make sure data change at clk low
8110b1f0:	e0bffd17 	ldw	r2,-12(fp)
8110b1f4:	0007883a 	mov	r3,zero
8110b1f8:	10c00035 	stwio	r3,0(r2)
        // output data on bus
        if (Data & Mask){ // there is a delay in this command
8110b1fc:	e0ffff03 	ldbu	r3,-4(fp)
8110b200:	e0bffa03 	ldbu	r2,-24(fp)
8110b204:	1884703a 	and	r2,r3,r2
8110b208:	10803fcc 	andi	r2,r2,255
8110b20c:	10000426 	beq	r2,zero,8110b220 <i2c_write+0x7c>
            SDA_HIGH(data_base);
8110b210:	e0bffe17 	ldw	r2,-8(fp)
8110b214:	00c00044 	movi	r3,1
8110b218:	10c00035 	stwio	r3,0(r2)
8110b21c:	00000306 	br	8110b22c <i2c_write+0x88>
        }else{    
            SDA_LOW(data_base);
8110b220:	e0bffe17 	ldw	r2,-8(fp)
8110b224:	0007883a 	mov	r3,zero
8110b228:	10c00035 	stwio	r3,0(r2)
        }
        Mask >>= 1; // there is a delay in this command
8110b22c:	e0bffa03 	ldbu	r2,-24(fp)
8110b230:	1004d07a 	srli	r2,r2,1
8110b234:	e0bffa05 	stb	r2,-24(fp)
        // clock high
        SCL_HIGH(clk_base);
8110b238:	e0bffd17 	ldw	r2,-12(fp)
8110b23c:	00c00044 	movi	r3,1
8110b240:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110b244:	01000044 	movi	r4,1
8110b248:	1137d140 	call	81137d14 <usleep>
        SCL_LOW(clk_base);
8110b24c:	e0bffd17 	ldw	r2,-12(fp)
8110b250:	0007883a 	mov	r3,zero
8110b254:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110b258:	01000044 	movi	r4,1
8110b25c:	1137d140 	call	81137d14 <usleep>
    
    // assume, SCL = 0
    
    SDA_DIR_OUT(data_base);  // data write mode
    
    for(i=0;i<8;i++){
8110b260:	e0bffb17 	ldw	r2,-20(fp)
8110b264:	10800044 	addi	r2,r2,1
8110b268:	e0bffb15 	stw	r2,-20(fp)
8110b26c:	e0bffb17 	ldw	r2,-20(fp)
8110b270:	10800210 	cmplti	r2,r2,8
8110b274:	103fde1e 	bne	r2,zero,8110b1f0 <__reset+0xfb0eb1f0>
        SCL_LOW(clk_base);
        SCL_DELAY;
    }
    
    //===== get ack
    SDA_DIR_IN(data_base);  // data read mode
8110b278:	e0bffe17 	ldw	r2,-8(fp)
8110b27c:	10800104 	addi	r2,r2,4
8110b280:	0007883a 	mov	r3,zero
8110b284:	10c00035 	stwio	r3,0(r2)
    //SCL_DELAY;
    // clock high
    SCL_HIGH(clk_base);  // clock high
8110b288:	e0bffd17 	ldw	r2,-12(fp)
8110b28c:	00c00044 	movi	r3,1
8110b290:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;  // clock high delay
8110b294:	01000044 	movi	r4,1
8110b298:	1137d140 	call	81137d14 <usleep>
    bAck = SDA_READ(data_base)?FALSE:TRUE;  // get ack
8110b29c:	e0bffe17 	ldw	r2,-8(fp)
8110b2a0:	10800037 	ldwio	r2,0(r2)
8110b2a4:	1005003a 	cmpeq	r2,r2,zero
8110b2a8:	10803fcc 	andi	r2,r2,255
8110b2ac:	e0bffc15 	stw	r2,-16(fp)
    //SCL_DELAY;
    //SDA_DIR_OUT;
    SCL_LOW(clk_base); // clock low         
8110b2b0:	e0bffd17 	ldw	r2,-12(fp)
8110b2b4:	0007883a 	mov	r3,zero
8110b2b8:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
8110b2bc:	01000044 	movi	r4,1
8110b2c0:	1137d140 	call	81137d14 <usleep>
    return bAck;
8110b2c4:	e0bffc17 	ldw	r2,-16(fp)
}    
8110b2c8:	e037883a 	mov	sp,fp
8110b2cc:	dfc00117 	ldw	ra,4(sp)
8110b2d0:	df000017 	ldw	fp,0(sp)
8110b2d4:	dec00204 	addi	sp,sp,8
8110b2d8:	f800283a 	ret

8110b2dc <i2c_read>:

void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck){ // return true if device response ack
8110b2dc:	defff804 	addi	sp,sp,-32
8110b2e0:	de00012e 	bgeu	sp,et,8110b2e8 <i2c_read+0xc>
8110b2e4:	003b68fa 	trap	3
8110b2e8:	dfc00715 	stw	ra,28(sp)
8110b2ec:	df000615 	stw	fp,24(sp)
8110b2f0:	df000604 	addi	fp,sp,24
8110b2f4:	e13ffc15 	stw	r4,-16(fp)
8110b2f8:	e17ffd15 	stw	r5,-12(fp)
8110b2fc:	e1bffe15 	stw	r6,-8(fp)
8110b300:	e1ffff15 	stw	r7,-4(fp)
    alt_u8 Data=0;
8110b304:	e03ffa05 	stb	zero,-24(fp)
    int i;
    
    // assume SCL = low
    
    SDA_DIR_IN(data_base);  // set data read mode
8110b308:	e0bffd17 	ldw	r2,-12(fp)
8110b30c:	10800104 	addi	r2,r2,4
8110b310:	0007883a 	mov	r3,zero
8110b314:	10c00035 	stwio	r3,0(r2)
    SCL_LOW(clk_base); // clock low
8110b318:	e0bffc17 	ldw	r2,-16(fp)
8110b31c:	0007883a 	mov	r3,zero
8110b320:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
8110b324:	01000044 	movi	r4,1
8110b328:	1137d140 	call	81137d14 <usleep>

    for(i=0;i<8;i++){
8110b32c:	e03ffb15 	stw	zero,-20(fp)
8110b330:	00001606 	br	8110b38c <i2c_read+0xb0>
        Data <<= 1;
8110b334:	e0bffa03 	ldbu	r2,-24(fp)
8110b338:	1085883a 	add	r2,r2,r2
8110b33c:	e0bffa05 	stb	r2,-24(fp)
        SCL_HIGH(clk_base);  // clock high
8110b340:	e0bffc17 	ldw	r2,-16(fp)
8110b344:	00c00044 	movi	r3,1
8110b348:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110b34c:	01000044 	movi	r4,1
8110b350:	1137d140 	call	81137d14 <usleep>
        if (SDA_READ(data_base))  // read data   
8110b354:	e0bffd17 	ldw	r2,-12(fp)
8110b358:	10800037 	ldwio	r2,0(r2)
8110b35c:	10000326 	beq	r2,zero,8110b36c <i2c_read+0x90>
            Data |= 0x01;
8110b360:	e0bffa03 	ldbu	r2,-24(fp)
8110b364:	10800054 	ori	r2,r2,1
8110b368:	e0bffa05 	stb	r2,-24(fp)
        SCL_LOW(clk_base);  // clock log  
8110b36c:	e0bffc17 	ldw	r2,-16(fp)
8110b370:	0007883a 	mov	r3,zero
8110b374:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110b378:	01000044 	movi	r4,1
8110b37c:	1137d140 	call	81137d14 <usleep>
    
    SDA_DIR_IN(data_base);  // set data read mode
    SCL_LOW(clk_base); // clock low
    SCL_DELAY; // clock low delay

    for(i=0;i<8;i++){
8110b380:	e0bffb17 	ldw	r2,-20(fp)
8110b384:	10800044 	addi	r2,r2,1
8110b388:	e0bffb15 	stw	r2,-20(fp)
8110b38c:	e0bffb17 	ldw	r2,-20(fp)
8110b390:	10800210 	cmplti	r2,r2,8
8110b394:	103fe71e 	bne	r2,zero,8110b334 <__reset+0xfb0eb334>
        SCL_LOW(clk_base);  // clock log  
        SCL_DELAY;
    }
    
    // send ACK
    SCL_LOW(clk_base);  // new, make sure data change at clk low
8110b398:	e0bffc17 	ldw	r2,-16(fp)
8110b39c:	0007883a 	mov	r3,zero
8110b3a0:	10c00035 	stwio	r3,0(r2)
    SDA_DIR_OUT(data_base);  // set data write mode
8110b3a4:	e0bffd17 	ldw	r2,-12(fp)
8110b3a8:	10800104 	addi	r2,r2,4
8110b3ac:	1007883a 	mov	r3,r2
8110b3b0:	00800044 	movi	r2,1
8110b3b4:	18800035 	stwio	r2,0(r3)
    if (bAck)
8110b3b8:	e0bfff17 	ldw	r2,-4(fp)
8110b3bc:	10000426 	beq	r2,zero,8110b3d0 <i2c_read+0xf4>
        SDA_LOW(data_base);
8110b3c0:	e0bffd17 	ldw	r2,-12(fp)
8110b3c4:	0007883a 	mov	r3,zero
8110b3c8:	10c00035 	stwio	r3,0(r2)
8110b3cc:	00000306 	br	8110b3dc <i2c_read+0x100>
    else
        SDA_HIGH(data_base);
8110b3d0:	e0bffd17 	ldw	r2,-12(fp)
8110b3d4:	00c00044 	movi	r3,1
8110b3d8:	10c00035 	stwio	r3,0(r2)
    SCL_HIGH(clk_base); // clock high
8110b3dc:	e0bffc17 	ldw	r2,-16(fp)
8110b3e0:	00c00044 	movi	r3,1
8110b3e4:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock high  delay
8110b3e8:	01000044 	movi	r4,1
8110b3ec:	1137d140 	call	81137d14 <usleep>
    SCL_LOW(clk_base); // clock low
8110b3f0:	e0bffc17 	ldw	r2,-16(fp)
8110b3f4:	0007883a 	mov	r3,zero
8110b3f8:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
8110b3fc:	01000044 	movi	r4,1
8110b400:	1137d140 	call	81137d14 <usleep>
    SDA_LOW(data_base);  // data low
8110b404:	e0bffd17 	ldw	r2,-12(fp)
8110b408:	0007883a 	mov	r3,zero
8110b40c:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // data low delay
8110b410:	01000044 	movi	r4,1
8110b414:	1137d140 	call	81137d14 <usleep>
//    SDA_DIR_IN;  // set data read mode
    
    *pData = Data;
8110b418:	e0bffe17 	ldw	r2,-8(fp)
8110b41c:	e0fffa03 	ldbu	r3,-24(fp)
8110b420:	10c00005 	stb	r3,0(r2)
}
8110b424:	0001883a 	nop
8110b428:	e037883a 	mov	sp,fp
8110b42c:	dfc00117 	ldw	ra,4(sp)
8110b430:	df000017 	ldw	fp,0(sp)
8110b434:	dec00204 	addi	sp,sp,8
8110b438:	f800283a 	ret

8110b43c <bSetBoardLeds>:
 * @param [in] LedsMask  Mascara de leds a serem modificados
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSetBoardLeds(bool bDRIVE, alt_u8 LedsMask){
8110b43c:	defffd04 	addi	sp,sp,-12
8110b440:	de00012e 	bgeu	sp,et,8110b448 <bSetBoardLeds+0xc>
8110b444:	003b68fa 	trap	3
8110b448:	df000215 	stw	fp,8(sp)
8110b44c:	df000204 	addi	fp,sp,8
8110b450:	e13ffe15 	stw	r4,-8(fp)
8110b454:	2805883a 	mov	r2,r5
8110b458:	e0bfff05 	stb	r2,-4(fp)

  // Board LEDs state: ON = 0; OFF = 1;

  if (bDRIVE == LEDS_ON){
8110b45c:	e0bffe17 	ldw	r2,-8(fp)
8110b460:	10800058 	cmpnei	r2,r2,1
8110b464:	1000071e 	bne	r2,zero,8110b484 <bSetBoardLeds+0x48>
	LedsBoardControl &= (~LedsMask);
8110b468:	e0bfff03 	ldbu	r2,-4(fp)
8110b46c:	0084303a 	nor	r2,zero,r2
8110b470:	1007883a 	mov	r3,r2
8110b474:	d0a05003 	ldbu	r2,-32448(gp)
8110b478:	1884703a 	and	r2,r3,r2
8110b47c:	d0a05005 	stb	r2,-32448(gp)
8110b480:	00000406 	br	8110b494 <bSetBoardLeds+0x58>
  } else {
	LedsBoardControl |= LedsMask;
8110b484:	d0e05003 	ldbu	r3,-32448(gp)
8110b488:	e0bfff03 	ldbu	r2,-4(fp)
8110b48c:	1884b03a 	or	r2,r3,r2
8110b490:	d0a05005 	stb	r2,-32448(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LEDS_BOARD_BASE, LedsBoardControl);
8110b494:	d0a05003 	ldbu	r2,-32448(gp)
8110b498:	10c03fcc 	andi	r3,r2,255
8110b49c:	00a00034 	movhi	r2,32768
8110b4a0:	10827404 	addi	r2,r2,2512
8110b4a4:	10c00035 	stwio	r3,0(r2)

  return TRUE;
8110b4a8:	00800044 	movi	r2,1
}
8110b4ac:	e037883a 	mov	sp,fp
8110b4b0:	df000017 	ldw	fp,0(sp)
8110b4b4:	dec00104 	addi	sp,sp,4
8110b4b8:	f800283a 	ret

8110b4bc <bSetPainelLeds>:
 * @param [in] LedsMask  Mascara de leds a serem modificados
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSetPainelLeds(bool bDRIVE, alt_u32 LedsMask){
8110b4bc:	defffd04 	addi	sp,sp,-12
8110b4c0:	de00012e 	bgeu	sp,et,8110b4c8 <bSetPainelLeds+0xc>
8110b4c4:	003b68fa 	trap	3
8110b4c8:	df000215 	stw	fp,8(sp)
8110b4cc:	df000204 	addi	fp,sp,8
8110b4d0:	e13ffe15 	stw	r4,-8(fp)
8110b4d4:	e17fff15 	stw	r5,-4(fp)

  // Painel LEDs state: ON = 1; OFF = 0;

  if (bDRIVE == LEDS_ON){
8110b4d8:	e0bffe17 	ldw	r2,-8(fp)
8110b4dc:	10800058 	cmpnei	r2,r2,1
8110b4e0:	1000051e 	bne	r2,zero,8110b4f8 <bSetPainelLeds+0x3c>
	LedsPainelControl |= LedsMask;
8110b4e4:	d0e00217 	ldw	r3,-32760(gp)
8110b4e8:	e0bfff17 	ldw	r2,-4(fp)
8110b4ec:	1884b03a 	or	r2,r3,r2
8110b4f0:	d0a00215 	stw	r2,-32760(gp)
8110b4f4:	00000506 	br	8110b50c <bSetPainelLeds+0x50>
  } else {
	LedsPainelControl &= (~LedsMask);
8110b4f8:	e0bfff17 	ldw	r2,-4(fp)
8110b4fc:	0086303a 	nor	r3,zero,r2
8110b500:	d0a00217 	ldw	r2,-32760(gp)
8110b504:	1884703a 	and	r2,r3,r2
8110b508:	d0a00215 	stw	r2,-32760(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LEDS_PAINEL_BASE, LedsPainelControl);
8110b50c:	d0a00217 	ldw	r2,-32760(gp)
8110b510:	1007883a 	mov	r3,r2
8110b514:	00a00034 	movhi	r2,32768
8110b518:	10824004 	addi	r2,r2,2304
8110b51c:	10c00035 	stwio	r3,0(r2)

  return TRUE;
8110b520:	00800044 	movi	r2,1
}
8110b524:	e037883a 	mov	sp,fp
8110b528:	df000017 	ldw	fp,0(sp)
8110b52c:	dec00104 	addi	sp,sp,4
8110b530:	f800283a 	ret

8110b534 <msgdma_write_extended_descriptor>:
/*
 * This function is used for writing extended descriptors to the dispatcher.  
 It handles only 32-bit descriptors.
 */
static int msgdma_write_extended_descriptor(alt_u32 *csr_base,
		alt_u32 *descriptor_base, alt_msgdma_extended_descriptor *descriptor) {
8110b534:	defffc04 	addi	sp,sp,-16
8110b538:	de00012e 	bgeu	sp,et,8110b540 <msgdma_write_extended_descriptor+0xc>
8110b53c:	003b68fa 	trap	3
8110b540:	df000315 	stw	fp,12(sp)
8110b544:	df000304 	addi	fp,sp,12
8110b548:	e13ffd15 	stw	r4,-12(fp)
8110b54c:	e17ffe15 	stw	r5,-8(fp)
8110b550:	e1bfff15 	stw	r6,-4(fp)
	if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) &
8110b554:	e0bffd17 	ldw	r2,-12(fp)
8110b558:	10800037 	ldwio	r2,0(r2)
8110b55c:	1080010c 	andi	r2,r2,4
8110b560:	10000226 	beq	r2,zero,8110b56c <msgdma_write_extended_descriptor+0x38>
	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
		/*at least one descriptor buffer is full, returning so that this function
		 is non-blocking*/
		return -ENOSPC;
8110b564:	00bff904 	movi	r2,-28
8110b568:	00003d06 	br	8110b660 <msgdma_write_extended_descriptor+0x12c>
	}

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base,
8110b56c:	e0bfff17 	ldw	r2,-4(fp)
8110b570:	10800017 	ldw	r2,0(r2)
8110b574:	1007883a 	mov	r3,r2
8110b578:	e0bffe17 	ldw	r2,-8(fp)
8110b57c:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->read_address_low);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base,
8110b580:	e0bffe17 	ldw	r2,-8(fp)
8110b584:	10800104 	addi	r2,r2,4
8110b588:	e0ffff17 	ldw	r3,-4(fp)
8110b58c:	18c00117 	ldw	r3,4(r3)
8110b590:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->write_address_low);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base,
8110b594:	e0bffe17 	ldw	r2,-8(fp)
8110b598:	10800204 	addi	r2,r2,8
8110b59c:	e0ffff17 	ldw	r3,-4(fp)
8110b5a0:	18c00217 	ldw	r3,8(r3)
8110b5a4:	10c00035 	stwio	r3,0(r2)
			descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(descriptor_base,
8110b5a8:	e0bffe17 	ldw	r2,-8(fp)
8110b5ac:	10800304 	addi	r2,r2,12
8110b5b0:	e0ffff17 	ldw	r3,-4(fp)
8110b5b4:	18c0030b 	ldhu	r3,12(r3)
8110b5b8:	18ffffcc 	andi	r3,r3,65535
8110b5bc:	10c0002d 	sthio	r3,0(r2)
			descriptor->sequence_number);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(descriptor_base,
8110b5c0:	e0bffe17 	ldw	r2,-8(fp)
8110b5c4:	10800384 	addi	r2,r2,14
8110b5c8:	e0ffff17 	ldw	r3,-4(fp)
8110b5cc:	18c00383 	ldbu	r3,14(r3)
8110b5d0:	18c03fcc 	andi	r3,r3,255
8110b5d4:	10c00025 	stbio	r3,0(r2)
			descriptor->read_burst_count);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(descriptor_base,
8110b5d8:	e0bffe17 	ldw	r2,-8(fp)
8110b5dc:	108003c4 	addi	r2,r2,15
8110b5e0:	e0ffff17 	ldw	r3,-4(fp)
8110b5e4:	18c003c3 	ldbu	r3,15(r3)
8110b5e8:	18c03fcc 	andi	r3,r3,255
8110b5ec:	10c00025 	stbio	r3,0(r2)
			descriptor->write_burst_count);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(descriptor_base,
8110b5f0:	e0bffe17 	ldw	r2,-8(fp)
8110b5f4:	10800404 	addi	r2,r2,16
8110b5f8:	e0ffff17 	ldw	r3,-4(fp)
8110b5fc:	18c0040b 	ldhu	r3,16(r3)
8110b600:	18ffffcc 	andi	r3,r3,65535
8110b604:	10c0002d 	sthio	r3,0(r2)
			descriptor->read_stride);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(descriptor_base,
8110b608:	e0bffe17 	ldw	r2,-8(fp)
8110b60c:	10800484 	addi	r2,r2,18
8110b610:	e0ffff17 	ldw	r3,-4(fp)
8110b614:	18c0048b 	ldhu	r3,18(r3)
8110b618:	18ffffcc 	andi	r3,r3,65535
8110b61c:	10c0002d 	sthio	r3,0(r2)
			descriptor->write_stride);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base,
8110b620:	e0bffe17 	ldw	r2,-8(fp)
8110b624:	10800504 	addi	r2,r2,20
8110b628:	e0ffff17 	ldw	r3,-4(fp)
8110b62c:	18c00517 	ldw	r3,20(r3)
8110b630:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->read_address_high);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base,
8110b634:	e0bffe17 	ldw	r2,-8(fp)
8110b638:	10800604 	addi	r2,r2,24
8110b63c:	e0ffff17 	ldw	r3,-4(fp)
8110b640:	18c00617 	ldw	r3,24(r3)
8110b644:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->write_address_high);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(descriptor_base,
8110b648:	e0bffe17 	ldw	r2,-8(fp)
8110b64c:	10800704 	addi	r2,r2,28
8110b650:	e0ffff17 	ldw	r3,-4(fp)
8110b654:	18c00717 	ldw	r3,28(r3)
8110b658:	10c00035 	stwio	r3,0(r2)
			descriptor->control);
	return 0;
8110b65c:	0005883a 	mov	r2,zero
}
8110b660:	e037883a 	mov	sp,fp
8110b664:	df000017 	ldw	fp,0(sp)
8110b668:	dec00104 	addi	sp,sp,4
8110b66c:	f800283a 	ret

8110b670 <msgdma_construct_extended_descriptor>:
static int msgdma_construct_extended_descriptor(alt_msgdma_dev *dev,
		alt_msgdma_extended_descriptor *descriptor, alt_u32 *read_address,
		alt_u32 *write_address, alt_u32 length, alt_u32 control,
		alt_u32 *read_address_high, alt_u32 *write_address_high,
		alt_u16 sequence_number, alt_u8 read_burst_count,
		alt_u8 write_burst_count, alt_u16 read_stride, alt_u16 write_stride) {
8110b670:	defff604 	addi	sp,sp,-40
8110b674:	de00012e 	bgeu	sp,et,8110b67c <msgdma_construct_extended_descriptor+0xc>
8110b678:	003b68fa 	trap	3
8110b67c:	df000915 	stw	fp,36(sp)
8110b680:	df000904 	addi	fp,sp,36
8110b684:	e13ff715 	stw	r4,-36(fp)
8110b688:	e17ff815 	stw	r5,-32(fp)
8110b68c:	e1bff915 	stw	r6,-28(fp)
8110b690:	e1fffa15 	stw	r7,-24(fp)
8110b694:	e1800517 	ldw	r6,20(fp)
8110b698:	e1400617 	ldw	r5,24(fp)
8110b69c:	e1000717 	ldw	r4,28(fp)
8110b6a0:	e0c00817 	ldw	r3,32(fp)
8110b6a4:	e0800917 	ldw	r2,36(fp)
8110b6a8:	e1bffb0d 	sth	r6,-20(fp)
8110b6ac:	e17ffc05 	stb	r5,-16(fp)
8110b6b0:	e13ffd05 	stb	r4,-12(fp)
8110b6b4:	e0fffe0d 	sth	r3,-8(fp)
8110b6b8:	e0bfff0d 	sth	r2,-4(fp)
	if (dev->max_byte < length || dev->max_stride < read_stride
8110b6bc:	e0bff717 	ldw	r2,-36(fp)
8110b6c0:	10c01217 	ldw	r3,72(r2)
8110b6c4:	e0800117 	ldw	r2,4(fp)
8110b6c8:	18801936 	bltu	r3,r2,8110b730 <msgdma_construct_extended_descriptor+0xc0>
8110b6cc:	e13ff717 	ldw	r4,-36(fp)
8110b6d0:	20801317 	ldw	r2,76(r4)
8110b6d4:	20c01417 	ldw	r3,80(r4)
8110b6d8:	e13ffe0b 	ldhu	r4,-8(fp)
8110b6dc:	213fffcc 	andi	r4,r4,65535
8110b6e0:	2015883a 	mov	r10,r4
8110b6e4:	0017883a 	mov	r11,zero
8110b6e8:	1ac01136 	bltu	r3,r11,8110b730 <msgdma_construct_extended_descriptor+0xc0>
8110b6ec:	58c0011e 	bne	r11,r3,8110b6f4 <msgdma_construct_extended_descriptor+0x84>
8110b6f0:	12800f36 	bltu	r2,r10,8110b730 <msgdma_construct_extended_descriptor+0xc0>
			|| dev->max_stride < write_stride || dev->enhanced_features != 1) {
8110b6f4:	e13ff717 	ldw	r4,-36(fp)
8110b6f8:	20801317 	ldw	r2,76(r4)
8110b6fc:	20c01417 	ldw	r3,80(r4)
8110b700:	e13fff0b 	ldhu	r4,-4(fp)
8110b704:	213fffcc 	andi	r4,r4,65535
8110b708:	2011883a 	mov	r8,r4
8110b70c:	0013883a 	mov	r9,zero
8110b710:	1a400736 	bltu	r3,r9,8110b730 <msgdma_construct_extended_descriptor+0xc0>
8110b714:	48c0011e 	bne	r9,r3,8110b71c <msgdma_construct_extended_descriptor+0xac>
8110b718:	12000536 	bltu	r2,r8,8110b730 <msgdma_construct_extended_descriptor+0xc0>
8110b71c:	e0bff717 	ldw	r2,-36(fp)
8110b720:	10801703 	ldbu	r2,92(r2)
8110b724:	10803fcc 	andi	r2,r2,255
8110b728:	10800060 	cmpeqi	r2,r2,1
8110b72c:	1000021e 	bne	r2,zero,8110b738 <msgdma_construct_extended_descriptor+0xc8>
		return -EINVAL;
8110b730:	00bffa84 	movi	r2,-22
8110b734:	00002306 	br	8110b7c4 <msgdma_construct_extended_descriptor+0x154>
	}

	descriptor->read_address_low = read_address;
8110b738:	e0bff817 	ldw	r2,-32(fp)
8110b73c:	e0fff917 	ldw	r3,-28(fp)
8110b740:	10c00015 	stw	r3,0(r2)
	descriptor->write_address_low = write_address;
8110b744:	e0bff817 	ldw	r2,-32(fp)
8110b748:	e0fffa17 	ldw	r3,-24(fp)
8110b74c:	10c00115 	stw	r3,4(r2)
	descriptor->transfer_length = length;
8110b750:	e0bff817 	ldw	r2,-32(fp)
8110b754:	e0c00117 	ldw	r3,4(fp)
8110b758:	10c00215 	stw	r3,8(r2)
	descriptor->sequence_number = sequence_number;
8110b75c:	e0bff817 	ldw	r2,-32(fp)
8110b760:	e0fffb0b 	ldhu	r3,-20(fp)
8110b764:	10c0030d 	sth	r3,12(r2)
	descriptor->read_burst_count = read_burst_count;
8110b768:	e0bff817 	ldw	r2,-32(fp)
8110b76c:	e0fffc03 	ldbu	r3,-16(fp)
8110b770:	10c00385 	stb	r3,14(r2)
	descriptor->write_burst_count = write_burst_count;
8110b774:	e0bff817 	ldw	r2,-32(fp)
8110b778:	e0fffd03 	ldbu	r3,-12(fp)
8110b77c:	10c003c5 	stb	r3,15(r2)
	descriptor->read_stride = read_stride;
8110b780:	e0bff817 	ldw	r2,-32(fp)
8110b784:	e0fffe0b 	ldhu	r3,-8(fp)
8110b788:	10c0040d 	sth	r3,16(r2)
	descriptor->write_stride = write_stride;
8110b78c:	e0bff817 	ldw	r2,-32(fp)
8110b790:	e0ffff0b 	ldhu	r3,-4(fp)
8110b794:	10c0048d 	sth	r3,18(r2)
	descriptor->read_address_high = read_address_high;
8110b798:	e0bff817 	ldw	r2,-32(fp)
8110b79c:	e0c00317 	ldw	r3,12(fp)
8110b7a0:	10c00515 	stw	r3,20(r2)
	descriptor->write_address_high = write_address_high;
8110b7a4:	e0bff817 	ldw	r2,-32(fp)
8110b7a8:	e0c00417 	ldw	r3,16(fp)
8110b7ac:	10c00615 	stw	r3,24(r2)
	descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
8110b7b0:	e0800217 	ldw	r2,8(fp)
8110b7b4:	10e00034 	orhi	r3,r2,32768
8110b7b8:	e0bff817 	ldw	r2,-32(fp)
8110b7bc:	10c00715 	stw	r3,28(r2)

	return 0;
8110b7c0:	0005883a 	mov	r2,zero

}
8110b7c4:	e037883a 	mov	sp,fp
8110b7c8:	df000017 	ldw	fp,0(sp)
8110b7cc:	dec00104 	addi	sp,sp,4
8110b7d0:	f800283a 	ret

8110b7d4 <msgdma_descriptor_async_transfer>:
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
static int msgdma_descriptor_async_transfer(alt_msgdma_dev *dev,
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
8110b7d4:	defff504 	addi	sp,sp,-44
8110b7d8:	de00012e 	bgeu	sp,et,8110b7e0 <msgdma_descriptor_async_transfer+0xc>
8110b7dc:	003b68fa 	trap	3
8110b7e0:	dfc00a15 	stw	ra,40(sp)
8110b7e4:	df000915 	stw	fp,36(sp)
8110b7e8:	df000904 	addi	fp,sp,36
8110b7ec:	e13ffd15 	stw	r4,-12(fp)
8110b7f0:	e17ffe15 	stw	r5,-8(fp)
8110b7f4:	e1bfff15 	stw	r6,-4(fp)
	alt_u32 control = 0;
8110b7f8:	e03ff815 	stw	zero,-32(fp)
	alt_irq_context context = 0;
8110b7fc:	e03ff915 	stw	zero,-28(fp)
	alt_u16 counter = 0;
8110b800:	e03ff70d 	sth	zero,-36(fp)
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110b804:	e0bffd17 	ldw	r2,-12(fp)
8110b808:	10800317 	ldw	r2,12(r2)
8110b80c:	10800204 	addi	r2,r2,8
8110b810:	10800037 	ldwio	r2,0(r2)
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
	alt_u32 control = 0;
	alt_irq_context context = 0;
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
8110b814:	10bfffcc 	andi	r2,r2,65535
8110b818:	e0bffa15 	stw	r2,-24(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110b81c:	e0bffd17 	ldw	r2,-12(fp)
8110b820:	10800317 	ldw	r2,12(r2)
8110b824:	10800204 	addi	r2,r2,8
8110b828:	10800037 	ldwio	r2,0(r2)
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
8110b82c:	1004d43a 	srli	r2,r2,16
8110b830:	e0bffb15 	stw	r2,-20(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110b834:	e0bffd17 	ldw	r2,-12(fp)
8110b838:	10800917 	ldw	r2,36(r2)
8110b83c:	e0fffb17 	ldw	r3,-20(fp)
8110b840:	1880042e 	bgeu	r3,r2,8110b854 <msgdma_descriptor_async_transfer+0x80>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
8110b844:	e0bffd17 	ldw	r2,-12(fp)
8110b848:	10800917 	ldw	r2,36(r2)
8110b84c:	e0fffa17 	ldw	r3,-24(fp)
8110b850:	18800236 	bltu	r3,r2,8110b85c <msgdma_descriptor_async_transfer+0x88>
		/*at least one write or read FIFO descriptor buffer is full,
		 returning so that this function is non-blocking*/
		return -ENOSPC;
8110b854:	00bff904 	movi	r2,-28
8110b858:	00006906 	br	8110ba00 <msgdma_descriptor_async_transfer+0x22c>
//	ALT_SEM_PEND(dev->regs_lock, 0);

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8110b85c:	00800804 	movi	r2,32
8110b860:	e0bff815 	stw	r2,-32(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110b864:	0005303a 	rdctl	r2,status
8110b868:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110b86c:	e0fffc17 	ldw	r3,-16(fp)
8110b870:	00bfff84 	movi	r2,-2
8110b874:	1884703a 	and	r2,r3,r2
8110b878:	1001703a 	wrctl	status,r2
  
  return context;
8110b87c:	e0bffc17 	ldw	r2,-16(fp)
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110b880:	e0bff915 	stw	r2,-28(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110b884:	e0bffd17 	ldw	r2,-12(fp)
8110b888:	10800317 	ldw	r2,12(r2)
8110b88c:	10800104 	addi	r2,r2,4
8110b890:	e0fff817 	ldw	r3,-32(fp)
8110b894:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110b898:	e0bffd17 	ldw	r2,-12(fp)
8110b89c:	10800317 	ldw	r2,12(r2)
8110b8a0:	e0fffd17 	ldw	r3,-12(fp)
8110b8a4:	18c00317 	ldw	r3,12(r3)
8110b8a8:	18c00037 	ldwio	r3,0(r3)
8110b8ac:	10c00035 	stwio	r3,0(r2)
			IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
//	alt_irq_enable_all(context);

	if (NULL != standard_desc && NULL == extended_desc) {
8110b8b0:	e0bffe17 	ldw	r2,-8(fp)
8110b8b4:	10000c26 	beq	r2,zero,8110b8e8 <msgdma_descriptor_async_transfer+0x114>
8110b8b8:	e0bfff17 	ldw	r2,-4(fp)
8110b8bc:	10000a1e 	bne	r2,zero,8110b8e8 <msgdma_descriptor_async_transfer+0x114>
		counter = 0; /* reset counter */
8110b8c0:	e03ff70d 	sth	zero,-36(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
#ifdef DEBUG_ON
		debug(fp, "invalid dma descriptor option\n");
8110b8c4:	d0a06217 	ldw	r2,-32376(gp)
8110b8c8:	100f883a 	mov	r7,r2
8110b8cc:	01800784 	movi	r6,30
8110b8d0:	01400044 	movi	r5,1
8110b8d4:	01204574 	movhi	r4,33045
8110b8d8:	21317804 	addi	r4,r4,-14880
8110b8dc:	1121c7c0 	call	81121c7c <fwrite>
		 * registers semaphore so that other threads can access the
		 * registers.
		 */
//		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
8110b8e0:	00bff084 	movi	r2,-62
8110b8e4:	00004606 	br	8110ba00 <msgdma_descriptor_async_transfer+0x22c>
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110b8e8:	e0bffe17 	ldw	r2,-8(fp)
8110b8ec:	10001f1e 	bne	r2,zero,8110b96c <msgdma_descriptor_async_transfer+0x198>
8110b8f0:	e0bfff17 	ldw	r2,-4(fp)
8110b8f4:	10001d26 	beq	r2,zero,8110b96c <msgdma_descriptor_async_transfer+0x198>
		counter = 0; /* reset counter */
8110b8f8:	e03ff70d 	sth	zero,-36(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110b8fc:	00001106 	br	8110b944 <msgdma_descriptor_async_transfer+0x170>
				!= msgdma_write_extended_descriptor(dev->csr_base,
						dev->descriptor_base, extended_desc)) {
			alt_busy_sleep(1); /* delay 1us */
8110b900:	01000044 	movi	r4,1
8110b904:	11362a00 	call	811362a0 <alt_busy_sleep>
			if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110b908:	e0bff70b 	ldhu	r2,-36(fp)
8110b90c:	1084e230 	cmpltui	r2,r2,5000
8110b910:	1000091e 	bne	r2,zero,8110b938 <msgdma_descriptor_async_transfer+0x164>
			{
#ifdef DEBUG_ON
				debug(fp,
8110b914:	d0a06217 	ldw	r2,-32376(gp)
8110b918:	100f883a 	mov	r7,r2
8110b91c:	01801544 	movi	r6,85
8110b920:	01400044 	movi	r5,1
8110b924:	01204574 	movhi	r4,33045
8110b928:	21318004 	addi	r4,r4,-14848
8110b92c:	1121c7c0 	call	81121c7c <fwrite>
				 * registers semaphore so that other threads can access the
				 * registers.
				 */
//				ALT_SEM_POST(dev->regs_lock);

				return -ETIME;
8110b930:	00bff084 	movi	r2,-62
8110b934:	00003206 	br	8110ba00 <msgdma_descriptor_async_transfer+0x22c>
			}
			counter++;
8110b938:	e0bff70b 	ldhu	r2,-36(fp)
8110b93c:	10800044 	addi	r2,r2,1
8110b940:	e0bff70d 	sth	r2,-36(fp)
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
				!= msgdma_write_extended_descriptor(dev->csr_base,
8110b944:	e0bffd17 	ldw	r2,-12(fp)
8110b948:	10c00317 	ldw	r3,12(r2)
8110b94c:	e0bffd17 	ldw	r2,-12(fp)
8110b950:	10800417 	ldw	r2,16(r2)
8110b954:	e1bfff17 	ldw	r6,-4(fp)
8110b958:	100b883a 	mov	r5,r2
8110b95c:	1809883a 	mov	r4,r3
8110b960:	110b5340 	call	8110b534 <msgdma_write_extended_descriptor>
		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110b964:	103fe61e 	bne	r2,zero,8110b900 <__reset+0xfb0eb900>
		 * registers.
		 */
//		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110b968:	00000206 	br	8110b974 <msgdma_descriptor_async_transfer+0x1a0>
		 * semaphore so that other threads can access the registers.
		 */
//		ALT_SEM_POST(dev->regs_lock);

		/* operation not permitted due to descriptor type conflict */
		return -EPERM;
8110b96c:	00bfffc4 	movi	r2,-1
8110b970:	00002306 	br	8110ba00 <msgdma_descriptor_async_transfer+0x22c>
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up controller to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if (dev->callback) {
8110b974:	e0bffd17 	ldw	r2,-12(fp)
8110b978:	10800b17 	ldw	r2,44(r2)
8110b97c:	10001026 	beq	r2,zero,8110b9c0 <msgdma_descriptor_async_transfer+0x1ec>

		control |= (dev->control |
8110b980:	e0bffd17 	ldw	r2,-12(fp)
8110b984:	10c00d17 	ldw	r3,52(r2)
8110b988:	e0bff817 	ldw	r2,-32(fp)
8110b98c:	1884b03a 	or	r2,r3,r2
8110b990:	10800514 	ori	r2,r2,20
8110b994:	e0bff815 	stw	r2,-32(fp)
		ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
		ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
8110b998:	e0fff817 	ldw	r3,-32(fp)
8110b99c:	00bff7c4 	movi	r2,-33
8110b9a0:	1884703a 	and	r2,r3,r2
8110b9a4:	e0bff815 	stw	r2,-32(fp)
		/* making sure the read-modify-write below can't be pre-empted */
//		context = alt_irq_disable_all();
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110b9a8:	e0bffd17 	ldw	r2,-12(fp)
8110b9ac:	10800317 	ldw	r2,12(r2)
8110b9b0:	10800104 	addi	r2,r2,4
8110b9b4:	e0fff817 	ldw	r3,-32(fp)
8110b9b8:	10c00035 	stwio	r3,0(r2)
8110b9bc:	00000f06 	br	8110b9fc <msgdma_descriptor_async_transfer+0x228>
	 *   - Run
	 *   - Stop on an error with any particular descriptor
	 *   - Disable interrupt generation
	 */
	else {
		control |= (dev->control |
8110b9c0:	e0bffd17 	ldw	r2,-12(fp)
8110b9c4:	10c00d17 	ldw	r3,52(r2)
8110b9c8:	e0bff817 	ldw	r2,-32(fp)
8110b9cc:	1884b03a 	or	r2,r3,r2
8110b9d0:	10800114 	ori	r2,r2,4
8110b9d4:	e0bff815 	stw	r2,-32(fp)
		ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
		control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK)
8110b9d8:	e0fff817 	ldw	r3,-32(fp)
8110b9dc:	00bff3c4 	movi	r2,-49
8110b9e0:	1884703a 	and	r2,r3,r2
8110b9e4:	e0bff815 	stw	r2,-32(fp)
				& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		/* making sure the read-modify-write below can't be pre-empted */
//		context = alt_irq_disable_all();
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110b9e8:	e0bffd17 	ldw	r2,-12(fp)
8110b9ec:	10800317 	ldw	r2,12(r2)
8110b9f0:	10800104 	addi	r2,r2,4
8110b9f4:	e0fff817 	ldw	r3,-32(fp)
8110b9f8:	10c00035 	stwio	r3,0(r2)
	 * Now that access to the registers is complete, release the registers
	 * semaphore so that other threads can access the registers.
	 */
//	ALT_SEM_POST(dev->regs_lock);

	return 0;
8110b9fc:	0005883a 	mov	r2,zero
}
8110ba00:	e037883a 	mov	sp,fp
8110ba04:	dfc00117 	ldw	ra,4(sp)
8110ba08:	df000017 	ldw	fp,0(sp)
8110ba0c:	dec00204 	addi	sp,sp,8
8110ba10:	f800283a 	ret

8110ba14 <msgdma_descriptor_sync_transfer>:
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
static int msgdma_descriptor_sync_transfer(alt_msgdma_dev *dev,
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
8110ba14:	defff104 	addi	sp,sp,-60
8110ba18:	de00012e 	bgeu	sp,et,8110ba20 <msgdma_descriptor_sync_transfer+0xc>
8110ba1c:	003b68fa 	trap	3
8110ba20:	dfc00e15 	stw	ra,56(sp)
8110ba24:	df000d15 	stw	fp,52(sp)
8110ba28:	df000d04 	addi	fp,sp,52
8110ba2c:	e13ffd15 	stw	r4,-12(fp)
8110ba30:	e17ffe15 	stw	r5,-8(fp)
8110ba34:	e1bfff15 	stw	r6,-4(fp)
	alt_u32 control = 0;
8110ba38:	e03ff715 	stw	zero,-36(fp)
	alt_irq_context context = 0;
8110ba3c:	e03ff815 	stw	zero,-32(fp)
	alt_u32 csr_status = 0;
8110ba40:	e03ff315 	stw	zero,-52(fp)
	alt_u16 counter = 0;
8110ba44:	e03ff40d 	sth	zero,-48(fp)
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110ba48:	e0bffd17 	ldw	r2,-12(fp)
8110ba4c:	10800317 	ldw	r2,12(r2)
8110ba50:	10800204 	addi	r2,r2,8
8110ba54:	10800037 	ldwio	r2,0(r2)
		alt_msgdma_extended_descriptor *extended_desc) {
	alt_u32 control = 0;
	alt_irq_context context = 0;
	alt_u32 csr_status = 0;
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
8110ba58:	10bfffcc 	andi	r2,r2,65535
8110ba5c:	e0bff515 	stw	r2,-44(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110ba60:	e0bffd17 	ldw	r2,-12(fp)
8110ba64:	10800317 	ldw	r2,12(r2)
8110ba68:	10800204 	addi	r2,r2,8
8110ba6c:	10800037 	ldwio	r2,0(r2)
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
8110ba70:	1004d43a 	srli	r2,r2,16
8110ba74:	e0bff615 	stw	r2,-40(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;
	alt_u32 error = ALTERA_MSGDMA_CSR_STOPPED_ON_ERROR_MASK |
8110ba78:	00807804 	movi	r2,480
8110ba7c:	e0bff915 	stw	r2,-28(fp)
	ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
	ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
	ALTERA_MSGDMA_CSR_RESET_STATE_MASK;

	/* Wait for available FIFO buffer to store new descriptor*/
	while ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110ba80:	00002406 	br	8110bb14 <msgdma_descriptor_sync_transfer+0x100>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
		alt_busy_sleep(1); /* delay 1us */
8110ba84:	01000044 	movi	r4,1
8110ba88:	11362a00 	call	811362a0 <alt_busy_sleep>
#ifdef DEBUG_ON
	fprintf(fp,"\n-- DMA can't write in the descriptor \n ");
8110ba8c:	d0a06217 	ldw	r2,-32376(gp)
8110ba90:	100f883a 	mov	r7,r2
8110ba94:	01800a04 	movi	r6,40
8110ba98:	01400044 	movi	r5,1
8110ba9c:	01204574 	movhi	r4,33045
8110baa0:	21319604 	addi	r4,r4,-14760
8110baa4:	1121c7c0 	call	81121c7c <fwrite>
#endif
		if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110baa8:	e0bff40b 	ldhu	r2,-48(fp)
8110baac:	1084e230 	cmpltui	r2,r2,5000
8110bab0:	1000091e 	bne	r2,zero,8110bad8 <msgdma_descriptor_sync_transfer+0xc4>
		{
#ifdef DEBUG_ON
			debug(fp,
8110bab4:	d0a06217 	ldw	r2,-32376(gp)
8110bab8:	100f883a 	mov	r7,r2
8110babc:	01801304 	movi	r6,76
8110bac0:	01400044 	movi	r5,1
8110bac4:	01204574 	movhi	r4,33045
8110bac8:	2131a104 	addi	r4,r4,-14716
8110bacc:	1121c7c0 	call	81121c7c <fwrite>
					"time out after 5 msec while waiting free FIFO buffer for storing descriptor\n");
#endif
			return -ETIME;
8110bad0:	00bff084 	movi	r2,-62
8110bad4:	0000aa06 	br	8110bd80 <msgdma_descriptor_sync_transfer+0x36c>
		}
		counter++;
8110bad8:	e0bff40b 	ldhu	r2,-48(fp)
8110badc:	10800044 	addi	r2,r2,1
8110bae0:	e0bff40d 	sth	r2,-48(fp)
		fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110bae4:	e0bffd17 	ldw	r2,-12(fp)
8110bae8:	10800317 	ldw	r2,12(r2)
8110baec:	10800204 	addi	r2,r2,8
8110baf0:	10800037 	ldwio	r2,0(r2)
					"time out after 5 msec while waiting free FIFO buffer for storing descriptor\n");
#endif
			return -ETIME;
		}
		counter++;
		fifo_read_fill_level = (
8110baf4:	10bfffcc 	andi	r2,r2,65535
8110baf8:	e0bff515 	stw	r2,-44(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110bafc:	e0bffd17 	ldw	r2,-12(fp)
8110bb00:	10800317 	ldw	r2,12(r2)
8110bb04:	10800204 	addi	r2,r2,8
8110bb08:	10800037 	ldwio	r2,0(r2)
		counter++;
		fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		fifo_write_fill_level = (
8110bb0c:	1004d43a 	srli	r2,r2,16
8110bb10:	e0bff615 	stw	r2,-40(fp)
	ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
	ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
	ALTERA_MSGDMA_CSR_RESET_STATE_MASK;

	/* Wait for available FIFO buffer to store new descriptor*/
	while ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110bb14:	e0bffd17 	ldw	r2,-12(fp)
8110bb18:	10800917 	ldw	r2,36(r2)
8110bb1c:	e0fff617 	ldw	r3,-40(fp)
8110bb20:	18bfd82e 	bgeu	r3,r2,8110ba84 <__reset+0xfb0eba84>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
8110bb24:	e0bffd17 	ldw	r2,-12(fp)
8110bb28:	10800917 	ldw	r2,36(r2)
8110bb2c:	e0fff517 	ldw	r3,-44(fp)
8110bb30:	18bfd42e 	bgeu	r3,r2,8110ba84 <__reset+0xfb0eba84>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110bb34:	0005303a 	rdctl	r2,status
8110bb38:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110bb3c:	e0fffc17 	ldw	r3,-16(fp)
8110bb40:	00bfff84 	movi	r2,-2
8110bb44:	1884703a 	and	r2,r3,r2
8110bb48:	1001703a 	wrctl	status,r2
  
  return context;
8110bb4c:	e0bffc17 	ldw	r2,-16(fp)
//	ALT_SEM_PEND(dev->regs_lock, 0);

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110bb50:	e0bff815 	stw	r2,-32(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8110bb54:	e0bffd17 	ldw	r2,-12(fp)
8110bb58:	10800317 	ldw	r2,12(r2)
8110bb5c:	10800104 	addi	r2,r2,4
8110bb60:	00c00804 	movi	r3,32
8110bb64:	10c00035 	stwio	r3,0(r2)
			ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110bb68:	e0bffd17 	ldw	r2,-12(fp)
8110bb6c:	10800317 	ldw	r2,12(r2)
8110bb70:	e0fffd17 	ldw	r3,-12(fp)
8110bb74:	18c00317 	ldw	r3,12(r3)
8110bb78:	18c00037 	ldwio	r3,0(r3)
8110bb7c:	10c00035 	stwio	r3,0(r2)
			IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

	if (NULL != standard_desc && NULL == extended_desc) {
8110bb80:	e0bffe17 	ldw	r2,-8(fp)
8110bb84:	10000c26 	beq	r2,zero,8110bbb8 <msgdma_descriptor_sync_transfer+0x1a4>
8110bb88:	e0bfff17 	ldw	r2,-4(fp)
8110bb8c:	10000a1e 	bne	r2,zero,8110bbb8 <msgdma_descriptor_sync_transfer+0x1a4>
		counter = 0; /* reset counter */
8110bb90:	e03ff40d 	sth	zero,-48(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
#ifdef DEBUG_ON
		debug(fp, "invalid dma descriptor option\n");
8110bb94:	d0a06217 	ldw	r2,-32376(gp)
8110bb98:	100f883a 	mov	r7,r2
8110bb9c:	01800784 	movi	r6,30
8110bba0:	01400044 	movi	r5,1
8110bba4:	01204574 	movhi	r4,33045
8110bba8:	21317804 	addi	r4,r4,-14880
8110bbac:	1121c7c0 	call	81121c7c <fwrite>
		 * registers semaphore so that other threads can access the
		 * registers.
		 */
//		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
8110bbb0:	00bff084 	movi	r2,-62
8110bbb4:	00007206 	br	8110bd80 <msgdma_descriptor_sync_transfer+0x36c>
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110bbb8:	e0bffe17 	ldw	r2,-8(fp)
8110bbbc:	10001f1e 	bne	r2,zero,8110bc3c <msgdma_descriptor_sync_transfer+0x228>
8110bbc0:	e0bfff17 	ldw	r2,-4(fp)
8110bbc4:	10001d26 	beq	r2,zero,8110bc3c <msgdma_descriptor_sync_transfer+0x228>
		counter = 0; /* reset counter */
8110bbc8:	e03ff40d 	sth	zero,-48(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110bbcc:	00001106 	br	8110bc14 <msgdma_descriptor_sync_transfer+0x200>
				!= msgdma_write_extended_descriptor(dev->csr_base,
						dev->descriptor_base, extended_desc)) {
			alt_busy_sleep(1); /* delay 1us */
8110bbd0:	01000044 	movi	r4,1
8110bbd4:	11362a00 	call	811362a0 <alt_busy_sleep>
			if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110bbd8:	e0bff40b 	ldhu	r2,-48(fp)
8110bbdc:	1084e230 	cmpltui	r2,r2,5000
8110bbe0:	1000091e 	bne	r2,zero,8110bc08 <msgdma_descriptor_sync_transfer+0x1f4>
			{
#ifdef DEBUG_ON
				debug(fp,
8110bbe4:	d0a06217 	ldw	r2,-32376(gp)
8110bbe8:	100f883a 	mov	r7,r2
8110bbec:	01801004 	movi	r6,64
8110bbf0:	01400044 	movi	r5,1
8110bbf4:	01204574 	movhi	r4,33045
8110bbf8:	2131b504 	addi	r4,r4,-14636
8110bbfc:	1121c7c0 	call	81121c7c <fwrite>
				 * registers semaphore so that other threads can access the
				 * registers.
				 */
//				ALT_SEM_POST(dev->regs_lock);

				return -ETIME;
8110bc00:	00bff084 	movi	r2,-62
8110bc04:	00005e06 	br	8110bd80 <msgdma_descriptor_sync_transfer+0x36c>
			}
			counter++;
8110bc08:	e0bff40b 	ldhu	r2,-48(fp)
8110bc0c:	10800044 	addi	r2,r2,1
8110bc10:	e0bff40d 	sth	r2,-48(fp)
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
				!= msgdma_write_extended_descriptor(dev->csr_base,
8110bc14:	e0bffd17 	ldw	r2,-12(fp)
8110bc18:	10c00317 	ldw	r3,12(r2)
8110bc1c:	e0bffd17 	ldw	r2,-12(fp)
8110bc20:	10800417 	ldw	r2,16(r2)
8110bc24:	e1bfff17 	ldw	r6,-4(fp)
8110bc28:	100b883a 	mov	r5,r2
8110bc2c:	1809883a 	mov	r4,r3
8110bc30:	110b5340 	call	8110b534 <msgdma_write_extended_descriptor>
		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110bc34:	103fe61e 	bne	r2,zero,8110bbd0 <__reset+0xfb0ebbd0>
		 * registers.
		 */
//		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110bc38:	00000206 	br	8110bc44 <msgdma_descriptor_sync_transfer+0x230>
		 * semaphore so that other threads can access the registers.
		 */
//		ALT_SEM_POST(dev->regs_lock);

		/* operation not permitted due to descriptor type conflict */
		return -EPERM;
8110bc3c:	00bfffc4 	movi	r2,-1
8110bc40:	00004f06 	br	8110bd80 <msgdma_descriptor_sync_transfer+0x36c>
	 * Set up msgdma controller to:
	 * - Disable interrupt generation
	 * - Run once a valid descriptor is written to controller
	 * - Stop on an error with any particular descriptor
	 */
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8110bc44:	e0bffd17 	ldw	r2,-12(fp)
8110bc48:	10800317 	ldw	r2,12(r2)
8110bc4c:	10800104 	addi	r2,r2,4
8110bc50:	e0fffd17 	ldw	r3,-12(fp)
8110bc54:	19000d17 	ldw	r4,52(r3)
8110bc58:	00fff2c4 	movi	r3,-53
8110bc5c:	20c6703a 	and	r3,r4,r3
8110bc60:	18c00114 	ori	r3,r3,4
8110bc64:	10c00035 	stwio	r3,0(r2)
			(dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK ) & (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK));

//	alt_irq_enable_all(context);

	counter = 0; /* reset counter */
8110bc68:	e03ff40d 	sth	zero,-48(fp)

	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
8110bc6c:	e0bffd17 	ldw	r2,-12(fp)
8110bc70:	10800317 	ldw	r2,12(r2)
8110bc74:	10800037 	ldwio	r2,0(r2)
8110bc78:	e0bff315 	stw	r2,-52(fp)

	/* Wait for any pending transfers to complete or checking any errors or
	 conditions causing descriptor to stop dispatching */
	while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK)) {
8110bc7c:	00001506 	br	8110bcd4 <msgdma_descriptor_sync_transfer+0x2c0>
		alt_busy_sleep(1); /* delay 1us */
8110bc80:	01000044 	movi	r4,1
8110bc84:	11362a00 	call	811362a0 <alt_busy_sleep>
		if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110bc88:	e0bff40b 	ldhu	r2,-48(fp)
8110bc8c:	1084e230 	cmpltui	r2,r2,5000
8110bc90:	1000091e 	bne	r2,zero,8110bcb8 <msgdma_descriptor_sync_transfer+0x2a4>
		{
#ifdef DEBUG_ON
			debug(fp,
8110bc94:	d0a06217 	ldw	r2,-32376(gp)
8110bc98:	100f883a 	mov	r7,r2
8110bc9c:	01801184 	movi	r6,70
8110bca0:	01400044 	movi	r5,1
8110bca4:	01204574 	movhi	r4,33045
8110bca8:	2131c604 	addi	r4,r4,-14568
8110bcac:	1121c7c0 	call	81121c7c <fwrite>
			 * Now that access to the registers is complete, release the registers
			 * semaphore so that other threads can access the registers.
			 */
//			ALT_SEM_POST(dev->regs_lock);

			return -ETIME;
8110bcb0:	00bff084 	movi	r2,-62
8110bcb4:	00003206 	br	8110bd80 <msgdma_descriptor_sync_transfer+0x36c>
		}
		counter++;
8110bcb8:	e0bff40b 	ldhu	r2,-48(fp)
8110bcbc:	10800044 	addi	r2,r2,1
8110bcc0:	e0bff40d 	sth	r2,-48(fp)
		csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
8110bcc4:	e0bffd17 	ldw	r2,-12(fp)
8110bcc8:	10800317 	ldw	r2,12(r2)
8110bccc:	10800037 	ldwio	r2,0(r2)
8110bcd0:	e0bff315 	stw	r2,-52(fp)

	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);

	/* Wait for any pending transfers to complete or checking any errors or
	 conditions causing descriptor to stop dispatching */
	while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK)) {
8110bcd4:	e0fff317 	ldw	r3,-52(fp)
8110bcd8:	e0bff917 	ldw	r2,-28(fp)
8110bcdc:	1884703a 	and	r2,r3,r2
8110bce0:	1000031e 	bne	r2,zero,8110bcf0 <msgdma_descriptor_sync_transfer+0x2dc>
8110bce4:	e0bff317 	ldw	r2,-52(fp)
8110bce8:	1080004c 	andi	r2,r2,1
8110bcec:	103fe41e 	bne	r2,zero,8110bc80 <__reset+0xfb0ebc80>
		csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	}

	/*Errors or conditions causing the dispatcher stopping issuing read/write
	 commands to masters*/
	if (0 != (csr_status & error)) {
8110bcf0:	e0fff317 	ldw	r3,-52(fp)
8110bcf4:	e0bff917 	ldw	r2,-28(fp)
8110bcf8:	1884703a 	and	r2,r3,r2
8110bcfc:	10000226 	beq	r2,zero,8110bd08 <msgdma_descriptor_sync_transfer+0x2f4>
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
//		ALT_SEM_POST(dev->regs_lock);

		return error;
8110bd00:	e0bff917 	ldw	r2,-28(fp)
8110bd04:	00001e06 	br	8110bd80 <msgdma_descriptor_sync_transfer+0x36c>
	}

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* stop issuing more descriptors */
	control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) |
8110bd08:	e0bffd17 	ldw	r2,-12(fp)
8110bd0c:	10800317 	ldw	r2,12(r2)
8110bd10:	10800104 	addi	r2,r2,4
8110bd14:	10800037 	ldwio	r2,0(r2)
8110bd18:	10800814 	ori	r2,r2,32
8110bd1c:	e0bff715 	stw	r2,-36(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110bd20:	0005303a 	rdctl	r2,status
8110bd24:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110bd28:	e0fffb17 	ldw	r3,-20(fp)
8110bd2c:	00bfff84 	movi	r2,-2
8110bd30:	1884703a 	and	r2,r3,r2
8110bd34:	1001703a 	wrctl	status,r2
  
  return context;
8110bd38:	e0bffb17 	ldw	r2,-20(fp)
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110bd3c:	e0bff815 	stw	r2,-32(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110bd40:	e0bffd17 	ldw	r2,-12(fp)
8110bd44:	10800317 	ldw	r2,12(r2)
8110bd48:	10800104 	addi	r2,r2,4
8110bd4c:	e0fff717 	ldw	r3,-36(fp)
8110bd50:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110bd54:	e0bffd17 	ldw	r2,-12(fp)
8110bd58:	10800317 	ldw	r2,12(r2)
8110bd5c:	e0fffd17 	ldw	r3,-12(fp)
8110bd60:	18c00317 	ldw	r3,12(r3)
8110bd64:	18c00037 	ldwio	r3,0(r3)
8110bd68:	10c00035 	stwio	r3,0(r2)
8110bd6c:	e0bff817 	ldw	r2,-32(fp)
8110bd70:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110bd74:	e0bffa17 	ldw	r2,-24(fp)
8110bd78:	1001703a 	wrctl	status,r2
	 * Now that access to the registers is complete, release the registers
	 * semaphore so that other threads can access the registers.
	 */
//	ALT_SEM_POST(dev->regs_lock);

	return 0;
8110bd7c:	0005883a 	mov	r2,zero

}
8110bd80:	e037883a 	mov	sp,fp
8110bd84:	dfc00117 	ldw	ra,4(sp)
8110bd88:	df000017 	ldw	fp,0(sp)
8110bd8c:	dec00204 	addi	sp,sp,8
8110bd90:	f800283a 	ret

8110bd94 <iMsgdmaConstructExtendedMmToMmDescriptor>:
int iMsgdmaConstructExtendedMmToMmDescriptor(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDescriptor, alt_u32 *puliReadAddress,
		alt_u32 *puliWriteAddress, alt_u32 uliLength, alt_u32 uliControl,
		alt_u32 *puliReadAddressHigh, alt_u32 *puliWriteAddressHigh,
		alt_u16 usiSequenceNumber, alt_u8 ucReadBurstCount,
		alt_u8 ucWriteBurstCount, alt_u16 usiReadStride, alt_u16 usiWriteStride) {
8110bd94:	deffec04 	addi	sp,sp,-80
8110bd98:	de00012e 	bgeu	sp,et,8110bda0 <iMsgdmaConstructExtendedMmToMmDescriptor+0xc>
8110bd9c:	003b68fa 	trap	3
8110bda0:	dfc01315 	stw	ra,76(sp)
8110bda4:	df001215 	stw	fp,72(sp)
8110bda8:	df001204 	addi	fp,sp,72
8110bdac:	e13ff715 	stw	r4,-36(fp)
8110bdb0:	e17ff815 	stw	r5,-32(fp)
8110bdb4:	e1bff915 	stw	r6,-28(fp)
8110bdb8:	e1fffa15 	stw	r7,-24(fp)
8110bdbc:	e1800617 	ldw	r6,24(fp)
8110bdc0:	e1400717 	ldw	r5,28(fp)
8110bdc4:	e1000817 	ldw	r4,32(fp)
8110bdc8:	e0c00917 	ldw	r3,36(fp)
8110bdcc:	e0800a17 	ldw	r2,40(fp)
8110bdd0:	e1bffb0d 	sth	r6,-20(fp)
8110bdd4:	e17ffc05 	stb	r5,-16(fp)
8110bdd8:	e13ffd05 	stb	r4,-12(fp)
8110bddc:	e0fffe0d 	sth	r3,-8(fp)
8110bde0:	e0bfff0d 	sth	r2,-4(fp)

	return msgdma_construct_extended_descriptor(pxDev, pxDescriptor,
8110bde4:	e0bffb0b 	ldhu	r2,-20(fp)
8110bde8:	e0fffc03 	ldbu	r3,-16(fp)
8110bdec:	e13ffd03 	ldbu	r4,-12(fp)
8110bdf0:	e17ffe0b 	ldhu	r5,-8(fp)
8110bdf4:	e1bfff0b 	ldhu	r6,-4(fp)
8110bdf8:	d9800815 	stw	r6,32(sp)
8110bdfc:	d9400715 	stw	r5,28(sp)
8110be00:	d9000615 	stw	r4,24(sp)
8110be04:	d8c00515 	stw	r3,20(sp)
8110be08:	d8800415 	stw	r2,16(sp)
8110be0c:	e0800517 	ldw	r2,20(fp)
8110be10:	d8800315 	stw	r2,12(sp)
8110be14:	e0800417 	ldw	r2,16(fp)
8110be18:	d8800215 	stw	r2,8(sp)
8110be1c:	e0800317 	ldw	r2,12(fp)
8110be20:	d8800115 	stw	r2,4(sp)
8110be24:	e0800217 	ldw	r2,8(fp)
8110be28:	d8800015 	stw	r2,0(sp)
8110be2c:	e1fffa17 	ldw	r7,-24(fp)
8110be30:	e1bff917 	ldw	r6,-28(fp)
8110be34:	e17ff817 	ldw	r5,-32(fp)
8110be38:	e13ff717 	ldw	r4,-36(fp)
8110be3c:	110b6700 	call	8110b670 <msgdma_construct_extended_descriptor>
			puliReadAddress, puliWriteAddress, uliLength, uliControl,
			puliReadAddressHigh, puliWriteAddressHigh, usiSequenceNumber,
			ucReadBurstCount, ucWriteBurstCount, usiReadStride, usiWriteStride);

}
8110be40:	e037883a 	mov	sp,fp
8110be44:	dfc00117 	ldw	ra,4(sp)
8110be48:	df000017 	ldw	fp,0(sp)
8110be4c:	dec00204 	addi	sp,sp,8
8110be50:	f800283a 	ret

8110be54 <iMsgdmaExtendedDescriptorAsyncTransfer>:
 * -ENOSPC -> FIFO descriptor buffer is full
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int iMsgdmaExtendedDescriptorAsyncTransfer(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDesc) {
8110be54:	defffc04 	addi	sp,sp,-16
8110be58:	de00012e 	bgeu	sp,et,8110be60 <iMsgdmaExtendedDescriptorAsyncTransfer+0xc>
8110be5c:	003b68fa 	trap	3
8110be60:	dfc00315 	stw	ra,12(sp)
8110be64:	df000215 	stw	fp,8(sp)
8110be68:	df000204 	addi	fp,sp,8
8110be6c:	e13ffe15 	stw	r4,-8(fp)
8110be70:	e17fff15 	stw	r5,-4(fp)
	/*
	 * Error detection/handling should be performed at the application
	 * or callback level as appropriate.
	 */
	return msgdma_descriptor_async_transfer(pxDev, NULL, pxDesc);
8110be74:	e1bfff17 	ldw	r6,-4(fp)
8110be78:	000b883a 	mov	r5,zero
8110be7c:	e13ffe17 	ldw	r4,-8(fp)
8110be80:	110b7d40 	call	8110b7d4 <msgdma_descriptor_async_transfer>
}
8110be84:	e037883a 	mov	sp,fp
8110be88:	dfc00117 	ldw	ra,4(sp)
8110be8c:	df000017 	ldw	fp,0(sp)
8110be90:	dec00204 	addi	sp,sp,8
8110be94:	f800283a 	ret

8110be98 <iMsgdmaExtendedDescriptorSyncTransfer>:
 *           return -EPERM (operation not permitted due to descriptor type 
 *		conflict)
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int iMsgdmaExtendedDescriptorSyncTransfer(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDesc) {
8110be98:	defffc04 	addi	sp,sp,-16
8110be9c:	de00012e 	bgeu	sp,et,8110bea4 <iMsgdmaExtendedDescriptorSyncTransfer+0xc>
8110bea0:	003b68fa 	trap	3
8110bea4:	dfc00315 	stw	ra,12(sp)
8110bea8:	df000215 	stw	fp,8(sp)
8110beac:	df000204 	addi	fp,sp,8
8110beb0:	e13ffe15 	stw	r4,-8(fp)
8110beb4:	e17fff15 	stw	r5,-4(fp)
	return msgdma_descriptor_sync_transfer(pxDev, NULL, pxDesc);
8110beb8:	e1bfff17 	ldw	r6,-4(fp)
8110bebc:	000b883a 	mov	r5,zero
8110bec0:	e13ffe17 	ldw	r4,-8(fp)
8110bec4:	110ba140 	call	8110ba14 <msgdma_descriptor_sync_transfer>
}
8110bec8:	e037883a 	mov	sp,fp
8110becc:	dfc00117 	ldw	ra,4(sp)
8110bed0:	df000017 	ldw	fp,0(sp)
8110bed4:	dec00204 	addi	sp,sp,8
8110bed8:	f800283a 	ret

8110bedc <POWER_SPI_RW>:
#define SPI_SDI(x)    IOWR_ALTERA_AVALON_PIO_DATA(CSENSE_SDI_BASE,x)
#define SPI_SDO       (IORD_ALTERA_AVALON_PIO_DATA(CSENSE_SDO_BASE) & 0x01)
#define SPI_DELAY     usleep(15)  // based on 50MHZ of CPU clock
// Note. SCK: typical 19.2KHZ (53 ms)
bool POWER_SPI_RW(alt_u8 IcIndex, alt_u8 NextChannel, bool bEN, bool bSIGN,
		bool bSGL, alt_u32 *pValue) {
8110bedc:	defff204 	addi	sp,sp,-56
8110bee0:	de00012e 	bgeu	sp,et,8110bee8 <POWER_SPI_RW+0xc>
8110bee4:	003b68fa 	trap	3
8110bee8:	dfc00d15 	stw	ra,52(sp)
8110beec:	df000c15 	stw	fp,48(sp)
8110bef0:	df000c04 	addi	fp,sp,48
8110bef4:	2007883a 	mov	r3,r4
8110bef8:	2805883a 	mov	r2,r5
8110befc:	e1bffe15 	stw	r6,-8(fp)
8110bf00:	e1ffff15 	stw	r7,-4(fp)
8110bf04:	e0fffc05 	stb	r3,-16(fp)
8110bf08:	e0bffd05 	stb	r2,-12(fp)
	bool bSuccess;
	alt_u8 Config8;
	alt_u32 Value32 = 0, Mask32;
8110bf0c:	e03ff515 	stw	zero,-44(fp)
	int i, nWait = 0, nZeroCnt;
8110bf10:	e03ff815 	stw	zero,-32(fp)
	const int nMaxWait = 1000000;
8110bf14:	008003f4 	movhi	r2,15
8110bf18:	10909004 	addi	r2,r2,16960
8110bf1c:	e0bffa15 	stw	r2,-24(fp)

	//
	Config8 = 0x80;
8110bf20:	00bfe004 	movi	r2,-128
8110bf24:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bEN) ? 0x20 : 0x00;
8110bf28:	e0bffe17 	ldw	r2,-8(fp)
8110bf2c:	10000226 	beq	r2,zero,8110bf38 <POWER_SPI_RW+0x5c>
8110bf30:	00800804 	movi	r2,32
8110bf34:	00000106 	br	8110bf3c <POWER_SPI_RW+0x60>
8110bf38:	0005883a 	mov	r2,zero
8110bf3c:	e0fff403 	ldbu	r3,-48(fp)
8110bf40:	10c4b03a 	or	r2,r2,r3
8110bf44:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bSGL) ? 0x10 : 0x00;
8110bf48:	e0800217 	ldw	r2,8(fp)
8110bf4c:	10000226 	beq	r2,zero,8110bf58 <POWER_SPI_RW+0x7c>
8110bf50:	00800404 	movi	r2,16
8110bf54:	00000106 	br	8110bf5c <POWER_SPI_RW+0x80>
8110bf58:	0005883a 	mov	r2,zero
8110bf5c:	e0fff403 	ldbu	r3,-48(fp)
8110bf60:	10c4b03a 	or	r2,r2,r3
8110bf64:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bSIGN) ? 0x08 : 0x00;
8110bf68:	e0bfff17 	ldw	r2,-4(fp)
8110bf6c:	10000226 	beq	r2,zero,8110bf78 <POWER_SPI_RW+0x9c>
8110bf70:	00800204 	movi	r2,8
8110bf74:	00000106 	br	8110bf7c <POWER_SPI_RW+0xa0>
8110bf78:	0005883a 	mov	r2,zero
8110bf7c:	e0fff403 	ldbu	r3,-48(fp)
8110bf80:	10c4b03a 	or	r2,r2,r3
8110bf84:	e0bff405 	stb	r2,-48(fp)
	Config8 |= NextChannel & 0x07; // channel
8110bf88:	e0bffd03 	ldbu	r2,-12(fp)
8110bf8c:	108001cc 	andi	r2,r2,7
8110bf90:	1007883a 	mov	r3,r2
8110bf94:	e0bff403 	ldbu	r2,-48(fp)
8110bf98:	1884b03a 	or	r2,r3,r2
8110bf9c:	e0bff405 	stb	r2,-48(fp)

	SPI_FO(0); // use internal conversion clock
8110bfa0:	0007883a 	mov	r3,zero
8110bfa4:	00a00034 	movhi	r2,32768
8110bfa8:	10824404 	addi	r2,r2,2320
8110bfac:	10c00035 	stwio	r3,0(r2)
	SPI_SCK(0);  // set low to active extenal serial clock mode.
8110bfb0:	0007883a 	mov	r3,zero
8110bfb4:	00a00034 	movhi	r2,32768
8110bfb8:	10824c04 	addi	r2,r2,2352
8110bfbc:	10c00035 	stwio	r3,0(r2)
	SPI_CS_N(IcIndex, 0);  // chip select: active
8110bfc0:	e0bffc03 	ldbu	r2,-16(fp)
8110bfc4:	1000021e 	bne	r2,zero,8110bfd0 <POWER_SPI_RW+0xf4>
8110bfc8:	00c00084 	movi	r3,2
8110bfcc:	00000106 	br	8110bfd4 <POWER_SPI_RW+0xf8>
8110bfd0:	00c00044 	movi	r3,1
8110bfd4:	00a00034 	movhi	r2,32768
8110bfd8:	10824804 	addi	r2,r2,2336
8110bfdc:	10c00035 	stwio	r3,0(r2)
	SPI_DELAY;
8110bfe0:	010003c4 	movi	r4,15
8110bfe4:	1137d140 	call	81137d14 <usleep>

	// wait for converion end (when conversion done, SPI_SDO is low)
	while (SPI_SDO && nWait < nMaxWait) {
8110bfe8:	00000306 	br	8110bff8 <POWER_SPI_RW+0x11c>
		nWait++;
8110bfec:	e0bff817 	ldw	r2,-32(fp)
8110bff0:	10800044 	addi	r2,r2,1
8110bff4:	e0bff815 	stw	r2,-32(fp)
	SPI_SCK(0);  // set low to active extenal serial clock mode.
	SPI_CS_N(IcIndex, 0);  // chip select: active
	SPI_DELAY;

	// wait for converion end (when conversion done, SPI_SDO is low)
	while (SPI_SDO && nWait < nMaxWait) {
8110bff8:	00a00034 	movhi	r2,32768
8110bffc:	10825404 	addi	r2,r2,2384
8110c000:	10800037 	ldwio	r2,0(r2)
8110c004:	1080004c 	andi	r2,r2,1
8110c008:	10000326 	beq	r2,zero,8110c018 <POWER_SPI_RW+0x13c>
8110c00c:	e0fff817 	ldw	r3,-32(fp)
8110c010:	e0bffa17 	ldw	r2,-24(fp)
8110c014:	18bff516 	blt	r3,r2,8110bfec <__reset+0xfb0ebfec>
		nWait++;
	}

	if (SPI_SDO) {
8110c018:	00a00034 	movhi	r2,32768
8110c01c:	10825404 	addi	r2,r2,2384
8110c020:	10800037 	ldwio	r2,0(r2)
8110c024:	1080004c 	andi	r2,r2,1
8110c028:	10000626 	beq	r2,zero,8110c044 <POWER_SPI_RW+0x168>
		SPI_CS_N(IcIndex, 1);  // chip select: inactive
8110c02c:	00c000c4 	movi	r3,3
8110c030:	00a00034 	movhi	r2,32768
8110c034:	10824804 	addi	r2,r2,2336
8110c038:	10c00035 	stwio	r3,0(r2)
#ifdef DEBUG_ON
//		debug(fp, "Timeout \r\n");
#endif
		return FALSE;
8110c03c:	0005883a 	mov	r2,zero
8110c040:	0000db06 	br	8110c3b0 <POWER_SPI_RW+0x4d4>
	}

	for (i = 0; i < 2; i++) // send config bits 7:6,
8110c044:	e03ff715 	stw	zero,-36(fp)
8110c048:	00002406 	br	8110c0dc <POWER_SPI_RW+0x200>
			// ignore EOC/ and DMY bits
			{
		SPI_SDI((Config8 & 0x80) ? 1 : 0);    //sdi=nextch.7; // put data on pin
8110c04c:	e0bff403 	ldbu	r2,-48(fp)
8110c050:	10803fcc 	andi	r2,r2,255
8110c054:	1004d1fa 	srli	r2,r2,7
8110c058:	10c03fcc 	andi	r3,r2,255
8110c05c:	00a00034 	movhi	r2,32768
8110c060:	10825004 	addi	r2,r2,2368
8110c064:	10c00035 	stwio	r3,0(r2)
		Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
8110c068:	e0bff403 	ldbu	r2,-48(fp)
8110c06c:	1085883a 	add	r2,r2,r2
8110c070:	e0bff405 	stb	r2,-48(fp)
		Value32 <<= 1; //result_0 = rl(result_0);// get ready to load lsb
8110c074:	e0bff517 	ldw	r2,-44(fp)
8110c078:	1085883a 	add	r2,r2,r2
8110c07c:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_0.0 = sdo; // load lsb
8110c080:	00a00034 	movhi	r2,32768
8110c084:	10825404 	addi	r2,r2,2384
8110c088:	10800037 	ldwio	r2,0(r2)
8110c08c:	1080004c 	andi	r2,r2,1
8110c090:	1007883a 	mov	r3,r2
8110c094:	e0bff517 	ldw	r2,-44(fp)
8110c098:	10c4b03a 	or	r2,r2,r3
8110c09c:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110c0a0:	00c00044 	movi	r3,1
8110c0a4:	00a00034 	movhi	r2,32768
8110c0a8:	10824c04 	addi	r2,r2,2352
8110c0ac:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c0b0:	010003c4 	movi	r4,15
8110c0b4:	1137d140 	call	81137d14 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110c0b8:	0007883a 	mov	r3,zero
8110c0bc:	00a00034 	movhi	r2,32768
8110c0c0:	10824c04 	addi	r2,r2,2352
8110c0c4:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c0c8:	010003c4 	movi	r4,15
8110c0cc:	1137d140 	call	81137d14 <usleep>
//		debug(fp, "Timeout \r\n");
#endif
		return FALSE;
	}

	for (i = 0; i < 2; i++) // send config bits 7:6,
8110c0d0:	e0bff717 	ldw	r2,-36(fp)
8110c0d4:	10800044 	addi	r2,r2,1
8110c0d8:	e0bff715 	stw	r2,-36(fp)
8110c0dc:	e0bff717 	ldw	r2,-36(fp)
8110c0e0:	10800090 	cmplti	r2,r2,2
8110c0e4:	103fd91e 	bne	r2,zero,8110c04c <__reset+0xfb0ec04c>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // send config, read byte 3
8110c0e8:	e03ff715 	stw	zero,-36(fp)
8110c0ec:	00002406 	br	8110c180 <POWER_SPI_RW+0x2a4>
			{
		SPI_SDI((Config8 & 0x80) ? 1 : 0); //sdi=nextch.7; // put data on pin
8110c0f0:	e0bff403 	ldbu	r2,-48(fp)
8110c0f4:	10803fcc 	andi	r2,r2,255
8110c0f8:	1004d1fa 	srli	r2,r2,7
8110c0fc:	10c03fcc 	andi	r3,r2,255
8110c100:	00a00034 	movhi	r2,32768
8110c104:	10825004 	addi	r2,r2,2368
8110c108:	10c00035 	stwio	r3,0(r2)
		Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
8110c10c:	e0bff403 	ldbu	r2,-48(fp)
8110c110:	1085883a 	add	r2,r2,r2
8110c114:	e0bff405 	stb	r2,-48(fp)

		Value32 <<= 1; //result_3 = rl(result_3);// get ready to load lsb
8110c118:	e0bff517 	ldw	r2,-44(fp)
8110c11c:	1085883a 	add	r2,r2,r2
8110c120:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_3.0 = sdo; // load lsb
8110c124:	00a00034 	movhi	r2,32768
8110c128:	10825404 	addi	r2,r2,2384
8110c12c:	10800037 	ldwio	r2,0(r2)
8110c130:	1080004c 	andi	r2,r2,1
8110c134:	1007883a 	mov	r3,r2
8110c138:	e0bff517 	ldw	r2,-44(fp)
8110c13c:	10c4b03a 	or	r2,r2,r3
8110c140:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110c144:	00c00044 	movi	r3,1
8110c148:	00a00034 	movhi	r2,32768
8110c14c:	10824c04 	addi	r2,r2,2352
8110c150:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c154:	010003c4 	movi	r4,15
8110c158:	1137d140 	call	81137d14 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110c15c:	0007883a 	mov	r3,zero
8110c160:	00a00034 	movhi	r2,32768
8110c164:	10824c04 	addi	r2,r2,2352
8110c168:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c16c:	010003c4 	movi	r4,15
8110c170:	1137d140 	call	81137d14 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // send config, read byte 3
8110c174:	e0bff717 	ldw	r2,-36(fp)
8110c178:	10800044 	addi	r2,r2,1
8110c17c:	e0bff715 	stw	r2,-36(fp)
8110c180:	e0bff717 	ldw	r2,-36(fp)
8110c184:	10800210 	cmplti	r2,r2,8
8110c188:	103fd91e 	bne	r2,zero,8110c0f0 <__reset+0xfb0ec0f0>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 2
8110c18c:	e03ff715 	stw	zero,-36(fp)
8110c190:	00001a06 	br	8110c1fc <POWER_SPI_RW+0x320>
			{
		Value32 <<= 1; //result_2 = rl(result_2);// get ready to load lsb
8110c194:	e0bff517 	ldw	r2,-44(fp)
8110c198:	1085883a 	add	r2,r2,r2
8110c19c:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_2.0 = sdo; // load lsb
8110c1a0:	00a00034 	movhi	r2,32768
8110c1a4:	10825404 	addi	r2,r2,2384
8110c1a8:	10800037 	ldwio	r2,0(r2)
8110c1ac:	1080004c 	andi	r2,r2,1
8110c1b0:	1007883a 	mov	r3,r2
8110c1b4:	e0bff517 	ldw	r2,-44(fp)
8110c1b8:	10c4b03a 	or	r2,r2,r3
8110c1bc:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110c1c0:	00c00044 	movi	r3,1
8110c1c4:	00a00034 	movhi	r2,32768
8110c1c8:	10824c04 	addi	r2,r2,2352
8110c1cc:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c1d0:	010003c4 	movi	r4,15
8110c1d4:	1137d140 	call	81137d14 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110c1d8:	0007883a 	mov	r3,zero
8110c1dc:	00a00034 	movhi	r2,32768
8110c1e0:	10824c04 	addi	r2,r2,2352
8110c1e4:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c1e8:	010003c4 	movi	r4,15
8110c1ec:	1137d140 	call	81137d14 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 2
8110c1f0:	e0bff717 	ldw	r2,-36(fp)
8110c1f4:	10800044 	addi	r2,r2,1
8110c1f8:	e0bff715 	stw	r2,-36(fp)
8110c1fc:	e0bff717 	ldw	r2,-36(fp)
8110c200:	10800210 	cmplti	r2,r2,8
8110c204:	103fe31e 	bne	r2,zero,8110c194 <__reset+0xfb0ec194>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 1
8110c208:	e03ff715 	stw	zero,-36(fp)
8110c20c:	00001a06 	br	8110c278 <POWER_SPI_RW+0x39c>
			{
		Value32 <<= 1; //result_1 = rl(result_1);// get ready to load lsb
8110c210:	e0bff517 	ldw	r2,-44(fp)
8110c214:	1085883a 	add	r2,r2,r2
8110c218:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_1.0 = sdo; // load lsb
8110c21c:	00a00034 	movhi	r2,32768
8110c220:	10825404 	addi	r2,r2,2384
8110c224:	10800037 	ldwio	r2,0(r2)
8110c228:	1080004c 	andi	r2,r2,1
8110c22c:	1007883a 	mov	r3,r2
8110c230:	e0bff517 	ldw	r2,-44(fp)
8110c234:	10c4b03a 	or	r2,r2,r3
8110c238:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110c23c:	00c00044 	movi	r3,1
8110c240:	00a00034 	movhi	r2,32768
8110c244:	10824c04 	addi	r2,r2,2352
8110c248:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c24c:	010003c4 	movi	r4,15
8110c250:	1137d140 	call	81137d14 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110c254:	0007883a 	mov	r3,zero
8110c258:	00a00034 	movhi	r2,32768
8110c25c:	10824c04 	addi	r2,r2,2352
8110c260:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c264:	010003c4 	movi	r4,15
8110c268:	1137d140 	call	81137d14 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 1
8110c26c:	e0bff717 	ldw	r2,-36(fp)
8110c270:	10800044 	addi	r2,r2,1
8110c274:	e0bff715 	stw	r2,-36(fp)
8110c278:	e0bff717 	ldw	r2,-36(fp)
8110c27c:	10800210 	cmplti	r2,r2,8
8110c280:	103fe31e 	bne	r2,zero,8110c210 <__reset+0xfb0ec210>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 6; i++) // read byte 0
8110c284:	e03ff715 	stw	zero,-36(fp)
8110c288:	00001a06 	br	8110c2f4 <POWER_SPI_RW+0x418>
			{
		Value32 <<= 1; //result_0 = rl(result_0);// get ready to load lsb
8110c28c:	e0bff517 	ldw	r2,-44(fp)
8110c290:	1085883a 	add	r2,r2,r2
8110c294:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_0.0 = sdo; // load lsb
8110c298:	00a00034 	movhi	r2,32768
8110c29c:	10825404 	addi	r2,r2,2384
8110c2a0:	10800037 	ldwio	r2,0(r2)
8110c2a4:	1080004c 	andi	r2,r2,1
8110c2a8:	1007883a 	mov	r3,r2
8110c2ac:	e0bff517 	ldw	r2,-44(fp)
8110c2b0:	10c4b03a 	or	r2,r2,r3
8110c2b4:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110c2b8:	00c00044 	movi	r3,1
8110c2bc:	00a00034 	movhi	r2,32768
8110c2c0:	10824c04 	addi	r2,r2,2352
8110c2c4:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c2c8:	010003c4 	movi	r4,15
8110c2cc:	1137d140 	call	81137d14 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110c2d0:	0007883a 	mov	r3,zero
8110c2d4:	00a00034 	movhi	r2,32768
8110c2d8:	10824c04 	addi	r2,r2,2352
8110c2dc:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c2e0:	010003c4 	movi	r4,15
8110c2e4:	1137d140 	call	81137d14 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 6; i++) // read byte 0
8110c2e8:	e0bff717 	ldw	r2,-36(fp)
8110c2ec:	10800044 	addi	r2,r2,1
8110c2f0:	e0bff715 	stw	r2,-36(fp)
8110c2f4:	e0bff717 	ldw	r2,-36(fp)
8110c2f8:	10800190 	cmplti	r2,r2,6
8110c2fc:	103fe31e 	bne	r2,zero,8110c28c <__reset+0xfb0ec28c>
		SPI_SCK(1); //sck=1; // clock high
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}
	SPI_SCK(1);
8110c300:	00c00044 	movi	r3,1
8110c304:	00a00034 	movhi	r2,32768
8110c308:	10824c04 	addi	r2,r2,2352
8110c30c:	10c00035 	stwio	r3,0(r2)
	SPI_DELAY;
8110c310:	010003c4 	movi	r4,15
8110c314:	1137d140 	call	81137d14 <usleep>
	SPI_CS_N(IcIndex, 1);  // chip select: inactive
8110c318:	00c000c4 	movi	r3,3
8110c31c:	00a00034 	movhi	r2,32768
8110c320:	10824804 	addi	r2,r2,2336
8110c324:	10c00035 	stwio	r3,0(r2)

	// check parity
	nZeroCnt = 0;
8110c328:	e03ff915 	stw	zero,-28(fp)
	Mask32 = 0x01;
8110c32c:	00800044 	movi	r2,1
8110c330:	e0bff615 	stw	r2,-40(fp)
	for (i = 0; i < 32; i++) {
8110c334:	e03ff715 	stw	zero,-36(fp)
8110c338:	00000d06 	br	8110c370 <POWER_SPI_RW+0x494>
		if ((Value32 & Mask32) == 0x00) {
8110c33c:	e0fff517 	ldw	r3,-44(fp)
8110c340:	e0bff617 	ldw	r2,-40(fp)
8110c344:	1884703a 	and	r2,r3,r2
8110c348:	1000031e 	bne	r2,zero,8110c358 <POWER_SPI_RW+0x47c>
			nZeroCnt++;
8110c34c:	e0bff917 	ldw	r2,-28(fp)
8110c350:	10800044 	addi	r2,r2,1
8110c354:	e0bff915 	stw	r2,-28(fp)
		}
		Mask32 <<= 1;
8110c358:	e0bff617 	ldw	r2,-40(fp)
8110c35c:	1085883a 	add	r2,r2,r2
8110c360:	e0bff615 	stw	r2,-40(fp)
	SPI_CS_N(IcIndex, 1);  // chip select: inactive

	// check parity
	nZeroCnt = 0;
	Mask32 = 0x01;
	for (i = 0; i < 32; i++) {
8110c364:	e0bff717 	ldw	r2,-36(fp)
8110c368:	10800044 	addi	r2,r2,1
8110c36c:	e0bff715 	stw	r2,-36(fp)
8110c370:	e0bff717 	ldw	r2,-36(fp)
8110c374:	10800810 	cmplti	r2,r2,32
8110c378:	103ff01e 	bne	r2,zero,8110c33c <__reset+0xfb0ec33c>
		if ((Value32 & Mask32) == 0x00) {
			nZeroCnt++;
		}
		Mask32 <<= 1;
	}
	bSuccess = (nZeroCnt & 0x01) ? FALSE : TRUE;
8110c37c:	e0bff917 	ldw	r2,-28(fp)
8110c380:	1080004c 	andi	r2,r2,1
8110c384:	1005003a 	cmpeq	r2,r2,zero
8110c388:	10803fcc 	andi	r2,r2,255
8110c38c:	e0bffb15 	stw	r2,-20(fp)
	if (!bSuccess) {
8110c390:	e0bffb17 	ldw	r2,-20(fp)
8110c394:	1000021e 	bne	r2,zero,8110c3a0 <POWER_SPI_RW+0x4c4>
#ifdef DEBUG_ON
//		debug(fp, "Parity Check Error \r\n");
#endif
		return FALSE;
8110c398:	0005883a 	mov	r2,zero
8110c39c:	00000406 	br	8110c3b0 <POWER_SPI_RW+0x4d4>
	}

	*pValue = Value32;
8110c3a0:	e0800317 	ldw	r2,12(fp)
8110c3a4:	e0fff517 	ldw	r3,-44(fp)
8110c3a8:	10c00015 	stw	r3,0(r2)

	return bSuccess;
8110c3ac:	e0bffb17 	ldw	r2,-20(fp)
}
8110c3b0:	e037883a 	mov	sp,fp
8110c3b4:	dfc00117 	ldw	ra,4(sp)
8110c3b8:	df000017 	ldw	fp,0(sp)
8110c3bc:	dec00204 	addi	sp,sp,8
8110c3c0:	f800283a 	ret

8110c3c4 <vRstcSimucamReset>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vRstcSimucamReset(alt_u16 usiRstCnt) {
8110c3c4:	defffc04 	addi	sp,sp,-16
8110c3c8:	de00012e 	bgeu	sp,et,8110c3d0 <vRstcSimucamReset+0xc>
8110c3cc:	003b68fa 	trap	3
8110c3d0:	dfc00315 	stw	ra,12(sp)
8110c3d4:	df000215 	stw	fp,8(sp)
8110c3d8:	df000204 	addi	fp,sp,8
8110c3dc:	2005883a 	mov	r2,r4
8110c3e0:	e0bfff0d 	sth	r2,-4(fp)
	alt_u32 uliReg = 0;
8110c3e4:	e03ffe15 	stw	zero,-8(fp)

	uliReg |= (alt_u32) (usiRstCnt & RSTC_SIMUCAM_RST_TMR_MSK);
8110c3e8:	e0bfff0b 	ldhu	r2,-4(fp)
8110c3ec:	e0fffe17 	ldw	r3,-8(fp)
8110c3f0:	1884b03a 	or	r2,r3,r2
8110c3f4:	e0bffe15 	stw	r2,-8(fp)
	uliReg |= (alt_u32) RSTC_SIMUCAM_RST_CTRL_MSK;
8110c3f8:	e0bffe17 	ldw	r2,-8(fp)
8110c3fc:	10800074 	orhi	r2,r2,1
8110c400:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110c404:	e1bffe17 	ldw	r6,-8(fp)
8110c408:	000b883a 	mov	r5,zero
8110c40c:	01200034 	movhi	r4,32768
8110c410:	21020004 	addi	r4,r4,2048
8110c414:	110c5140 	call	8110c514 <vRstcWriteReg>
	RSTC_SIMUCAM_RESET_REG_OFFSET, uliReg);
}
8110c418:	0001883a 	nop
8110c41c:	e037883a 	mov	sp,fp
8110c420:	dfc00117 	ldw	ra,4(sp)
8110c424:	df000017 	ldw	fp,0(sp)
8110c428:	dec00204 	addi	sp,sp,8
8110c42c:	f800283a 	ret

8110c430 <vRstcReleaseDeviceReset>:

void vRstcReleaseDeviceReset(alt_u32 usiRstMask) {
8110c430:	defffc04 	addi	sp,sp,-16
8110c434:	de00012e 	bgeu	sp,et,8110c43c <vRstcReleaseDeviceReset+0xc>
8110c438:	003b68fa 	trap	3
8110c43c:	dfc00315 	stw	ra,12(sp)
8110c440:	df000215 	stw	fp,8(sp)
8110c444:	df000204 	addi	fp,sp,8
8110c448:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliReg = 0;
8110c44c:	e03ffe15 	stw	zero,-8(fp)

	uliReg = uliRstReadReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110c450:	01400044 	movi	r5,1
8110c454:	01200034 	movhi	r4,32768
8110c458:	21020004 	addi	r4,r4,2048
8110c45c:	110c5680 	call	8110c568 <uliRstReadReg>
8110c460:	e0bffe15 	stw	r2,-8(fp)
	RSTC_DEVICE_RESET_REG_OFFSET);
	uliReg &= ~((alt_u32) usiRstMask);
8110c464:	e0bfff17 	ldw	r2,-4(fp)
8110c468:	0084303a 	nor	r2,zero,r2
8110c46c:	e0fffe17 	ldw	r3,-8(fp)
8110c470:	1884703a 	and	r2,r3,r2
8110c474:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110c478:	e1bffe17 	ldw	r6,-8(fp)
8110c47c:	01400044 	movi	r5,1
8110c480:	01200034 	movhi	r4,32768
8110c484:	21020004 	addi	r4,r4,2048
8110c488:	110c5140 	call	8110c514 <vRstcWriteReg>
	RSTC_DEVICE_RESET_REG_OFFSET, uliReg);
}
8110c48c:	0001883a 	nop
8110c490:	e037883a 	mov	sp,fp
8110c494:	dfc00117 	ldw	ra,4(sp)
8110c498:	df000017 	ldw	fp,0(sp)
8110c49c:	dec00204 	addi	sp,sp,8
8110c4a0:	f800283a 	ret

8110c4a4 <vRstcHoldDeviceReset>:

void vRstcHoldDeviceReset(alt_u32 usiRstMask) {
8110c4a4:	defffc04 	addi	sp,sp,-16
8110c4a8:	de00012e 	bgeu	sp,et,8110c4b0 <vRstcHoldDeviceReset+0xc>
8110c4ac:	003b68fa 	trap	3
8110c4b0:	dfc00315 	stw	ra,12(sp)
8110c4b4:	df000215 	stw	fp,8(sp)
8110c4b8:	df000204 	addi	fp,sp,8
8110c4bc:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliReg = 0;
8110c4c0:	e03ffe15 	stw	zero,-8(fp)

	uliReg = uliRstReadReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110c4c4:	01400044 	movi	r5,1
8110c4c8:	01200034 	movhi	r4,32768
8110c4cc:	21020004 	addi	r4,r4,2048
8110c4d0:	110c5680 	call	8110c568 <uliRstReadReg>
8110c4d4:	e0bffe15 	stw	r2,-8(fp)
	RSTC_DEVICE_RESET_REG_OFFSET);
	uliReg |= (alt_u32) usiRstMask;
8110c4d8:	e0fffe17 	ldw	r3,-8(fp)
8110c4dc:	e0bfff17 	ldw	r2,-4(fp)
8110c4e0:	1884b03a 	or	r2,r3,r2
8110c4e4:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110c4e8:	e1bffe17 	ldw	r6,-8(fp)
8110c4ec:	01400044 	movi	r5,1
8110c4f0:	01200034 	movhi	r4,32768
8110c4f4:	21020004 	addi	r4,r4,2048
8110c4f8:	110c5140 	call	8110c514 <vRstcWriteReg>
	RSTC_DEVICE_RESET_REG_OFFSET, uliReg);
}
8110c4fc:	0001883a 	nop
8110c500:	e037883a 	mov	sp,fp
8110c504:	dfc00117 	ldw	ra,4(sp)
8110c508:	df000017 	ldw	fp,0(sp)
8110c50c:	dec00204 	addi	sp,sp,8
8110c510:	f800283a 	ret

8110c514 <vRstcWriteReg>:
//! [public functions]

//! [private functions]
static void vRstcWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
8110c514:	defffc04 	addi	sp,sp,-16
8110c518:	de00012e 	bgeu	sp,et,8110c520 <vRstcWriteReg+0xc>
8110c51c:	003b68fa 	trap	3
8110c520:	df000315 	stw	fp,12(sp)
8110c524:	df000304 	addi	fp,sp,12
8110c528:	e13ffd15 	stw	r4,-12(fp)
8110c52c:	e17ffe15 	stw	r5,-8(fp)
8110c530:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
8110c534:	e0bffe17 	ldw	r2,-8(fp)
8110c538:	1085883a 	add	r2,r2,r2
8110c53c:	1085883a 	add	r2,r2,r2
8110c540:	1007883a 	mov	r3,r2
8110c544:	e0bffd17 	ldw	r2,-12(fp)
8110c548:	10c5883a 	add	r2,r2,r3
8110c54c:	e0ffff17 	ldw	r3,-4(fp)
8110c550:	10c00015 	stw	r3,0(r2)
}
8110c554:	0001883a 	nop
8110c558:	e037883a 	mov	sp,fp
8110c55c:	df000017 	ldw	fp,0(sp)
8110c560:	dec00104 	addi	sp,sp,4
8110c564:	f800283a 	ret

8110c568 <uliRstReadReg>:

static alt_u32 uliRstReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8110c568:	defffc04 	addi	sp,sp,-16
8110c56c:	de00012e 	bgeu	sp,et,8110c574 <uliRstReadReg+0xc>
8110c570:	003b68fa 	trap	3
8110c574:	df000315 	stw	fp,12(sp)
8110c578:	df000304 	addi	fp,sp,12
8110c57c:	e13ffe15 	stw	r4,-8(fp)
8110c580:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
8110c584:	e0bfff17 	ldw	r2,-4(fp)
8110c588:	1085883a 	add	r2,r2,r2
8110c58c:	1085883a 	add	r2,r2,r2
8110c590:	1007883a 	mov	r3,r2
8110c594:	e0bffe17 	ldw	r2,-8(fp)
8110c598:	10c5883a 	add	r2,r2,r3
8110c59c:	10800017 	ldw	r2,0(r2)
8110c5a0:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8110c5a4:	e0bffd17 	ldw	r2,-12(fp)
}
8110c5a8:	e037883a 	mov	sp,fp
8110c5ac:	df000017 	ldw	fp,0(sp)
8110c5b0:	dec00104 	addi	sp,sp,4
8110c5b4:	f800283a 	ret

8110c5b8 <v_spi_start>:

#ifdef DEBUG_ON
char cDebugBuffer[256];
#endif

void v_spi_start(void){
8110c5b8:	defffe04 	addi	sp,sp,-8
8110c5bc:	de00012e 	bgeu	sp,et,8110c5c4 <v_spi_start+0xc>
8110c5c0:	003b68fa 	trap	3
8110c5c4:	dfc00115 	stw	ra,4(sp)
8110c5c8:	df000015 	stw	fp,0(sp)
8110c5cc:	d839883a 	mov	fp,sp
    //Pull CS_n Low to start communication
    SPI_SCK(0);
8110c5d0:	0007883a 	mov	r3,zero
8110c5d4:	00a00034 	movhi	r2,32768
8110c5d8:	10823004 	addi	r2,r2,2240
8110c5dc:	10c00035 	stwio	r3,0(r2)
    SPI_CS_N(0);
8110c5e0:	0007883a 	mov	r3,zero
8110c5e4:	00a00034 	movhi	r2,32768
8110c5e8:	10822c04 	addi	r2,r2,2224
8110c5ec:	10c00035 	stwio	r3,0(r2)
    SPI_DELAY;
8110c5f0:	01002584 	movi	r4,150
8110c5f4:	1137d140 	call	81137d14 <usleep>
}
8110c5f8:	0001883a 	nop
8110c5fc:	e037883a 	mov	sp,fp
8110c600:	dfc00117 	ldw	ra,4(sp)
8110c604:	df000017 	ldw	fp,0(sp)
8110c608:	dec00204 	addi	sp,sp,8
8110c60c:	f800283a 	ret

8110c610 <v_spi_send_byte>:

void v_spi_send_byte(alt_u8 uc_data){
8110c610:	defffc04 	addi	sp,sp,-16
8110c614:	de00012e 	bgeu	sp,et,8110c61c <v_spi_send_byte+0xc>
8110c618:	003b68fa 	trap	3
8110c61c:	dfc00315 	stw	ra,12(sp)
8110c620:	df000215 	stw	fp,8(sp)
8110c624:	df000204 	addi	fp,sp,8
8110c628:	2005883a 	mov	r2,r4
8110c62c:	e0bfff05 	stb	r2,-4(fp)

    alt_u8 i = 0;
8110c630:	e03ffe05 	stb	zero,-8(fp)
    alt_u8 uc_data_mask = 0x80;
8110c634:	00bfe004 	movi	r2,-128
8110c638:	e0bffe45 	stb	r2,-7(fp)

    for(i=0;i<8;i++)
8110c63c:	e03ffe05 	stb	zero,-8(fp)
8110c640:	00001b06 	br	8110c6b0 <v_spi_send_byte+0xa0>
    {
        SPI_SDI((uc_data & uc_data_mask)?1:0);
8110c644:	e0ffff03 	ldbu	r3,-4(fp)
8110c648:	e0bffe43 	ldbu	r2,-7(fp)
8110c64c:	1884703a 	and	r2,r3,r2
8110c650:	10803fcc 	andi	r2,r2,255
8110c654:	1004c03a 	cmpne	r2,r2,zero
8110c658:	10c03fcc 	andi	r3,r2,255
8110c65c:	00a00034 	movhi	r2,32768
8110c660:	10823404 	addi	r2,r2,2256
8110c664:	10c00035 	stwio	r3,0(r2)
        uc_data_mask >>= 1;
8110c668:	e0bffe43 	ldbu	r2,-7(fp)
8110c66c:	1004d07a 	srli	r2,r2,1
8110c670:	e0bffe45 	stb	r2,-7(fp)

        SPI_SCK(1);//sck=1; // clock high
8110c674:	00c00044 	movi	r3,1
8110c678:	00a00034 	movhi	r2,32768
8110c67c:	10823004 	addi	r2,r2,2240
8110c680:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110c684:	01002584 	movi	r4,150
8110c688:	1137d140 	call	81137d14 <usleep>
        SPI_SCK(0);//sck=0; // clock low
8110c68c:	0007883a 	mov	r3,zero
8110c690:	00a00034 	movhi	r2,32768
8110c694:	10823004 	addi	r2,r2,2240
8110c698:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110c69c:	01002584 	movi	r4,150
8110c6a0:	1137d140 	call	81137d14 <usleep>
void v_spi_send_byte(alt_u8 uc_data){

    alt_u8 i = 0;
    alt_u8 uc_data_mask = 0x80;

    for(i=0;i<8;i++)
8110c6a4:	e0bffe03 	ldbu	r2,-8(fp)
8110c6a8:	10800044 	addi	r2,r2,1
8110c6ac:	e0bffe05 	stb	r2,-8(fp)
8110c6b0:	e0bffe03 	ldbu	r2,-8(fp)
8110c6b4:	10800230 	cmpltui	r2,r2,8
8110c6b8:	103fe21e 	bne	r2,zero,8110c644 <__reset+0xfb0ec644>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }

}
8110c6bc:	0001883a 	nop
8110c6c0:	e037883a 	mov	sp,fp
8110c6c4:	dfc00117 	ldw	ra,4(sp)
8110c6c8:	df000017 	ldw	fp,0(sp)
8110c6cc:	dec00204 	addi	sp,sp,8
8110c6d0:	f800283a 	ret

8110c6d4 <uc_spi_get_byte>:

alt_u8 uc_spi_get_byte(void){
8110c6d4:	defffd04 	addi	sp,sp,-12
8110c6d8:	de00012e 	bgeu	sp,et,8110c6e0 <uc_spi_get_byte+0xc>
8110c6dc:	003b68fa 	trap	3
8110c6e0:	dfc00215 	stw	ra,8(sp)
8110c6e4:	df000115 	stw	fp,4(sp)
8110c6e8:	df000104 	addi	fp,sp,4

    alt_u8 i = 0;
8110c6ec:	e03fff05 	stb	zero,-4(fp)
    alt_u8 uc_data = 0;
8110c6f0:	e03fff45 	stb	zero,-3(fp)

    for(i=0;i<8;i++) // read byte
8110c6f4:	e03fff05 	stb	zero,-4(fp)
8110c6f8:	00001a06 	br	8110c764 <uc_spi_get_byte+0x90>
    {
        uc_data <<= 1;
8110c6fc:	e0bfff43 	ldbu	r2,-3(fp)
8110c700:	1085883a 	add	r2,r2,r2
8110c704:	e0bfff45 	stb	r2,-3(fp)
        uc_data |= SPI_SDO;
8110c708:	00a00034 	movhi	r2,32768
8110c70c:	10823804 	addi	r2,r2,2272
8110c710:	10800037 	ldwio	r2,0(r2)
8110c714:	1080004c 	andi	r2,r2,1
8110c718:	1007883a 	mov	r3,r2
8110c71c:	e0bfff43 	ldbu	r2,-3(fp)
8110c720:	1884b03a 	or	r2,r3,r2
8110c724:	e0bfff45 	stb	r2,-3(fp)

        SPI_SCK(1);//sck=1; // clock high
8110c728:	00c00044 	movi	r3,1
8110c72c:	00a00034 	movhi	r2,32768
8110c730:	10823004 	addi	r2,r2,2240
8110c734:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110c738:	01002584 	movi	r4,150
8110c73c:	1137d140 	call	81137d14 <usleep>
        SPI_SCK(0);//sck=0; // clock low
8110c740:	0007883a 	mov	r3,zero
8110c744:	00a00034 	movhi	r2,32768
8110c748:	10823004 	addi	r2,r2,2240
8110c74c:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110c750:	01002584 	movi	r4,150
8110c754:	1137d140 	call	81137d14 <usleep>
alt_u8 uc_spi_get_byte(void){

    alt_u8 i = 0;
    alt_u8 uc_data = 0;

    for(i=0;i<8;i++) // read byte
8110c758:	e0bfff03 	ldbu	r2,-4(fp)
8110c75c:	10800044 	addi	r2,r2,1
8110c760:	e0bfff05 	stb	r2,-4(fp)
8110c764:	e0bfff03 	ldbu	r2,-4(fp)
8110c768:	10800230 	cmpltui	r2,r2,8
8110c76c:	103fe31e 	bne	r2,zero,8110c6fc <__reset+0xfb0ec6fc>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }

    return uc_data;
8110c770:	e0bfff43 	ldbu	r2,-3(fp)
}
8110c774:	e037883a 	mov	sp,fp
8110c778:	dfc00117 	ldw	ra,4(sp)
8110c77c:	df000017 	ldw	fp,0(sp)
8110c780:	dec00204 	addi	sp,sp,8
8110c784:	f800283a 	ret

8110c788 <v_spi_end>:

void v_spi_end(void){
8110c788:	defffe04 	addi	sp,sp,-8
8110c78c:	de00012e 	bgeu	sp,et,8110c794 <v_spi_end+0xc>
8110c790:	003b68fa 	trap	3
8110c794:	dfc00115 	stw	ra,4(sp)
8110c798:	df000015 	stw	fp,0(sp)
8110c79c:	d839883a 	mov	fp,sp
    //Set CS_n to end communication
    SPI_SCK(0);
8110c7a0:	0007883a 	mov	r3,zero
8110c7a4:	00a00034 	movhi	r2,32768
8110c7a8:	10823004 	addi	r2,r2,2240
8110c7ac:	10c00035 	stwio	r3,0(r2)
    SPI_DELAY;
8110c7b0:	01002584 	movi	r4,150
8110c7b4:	1137d140 	call	81137d14 <usleep>
    SPI_CS_N(1);
8110c7b8:	00c00044 	movi	r3,1
8110c7bc:	00a00034 	movhi	r2,32768
8110c7c0:	10822c04 	addi	r2,r2,2224
8110c7c4:	10c00035 	stwio	r3,0(r2)
}
8110c7c8:	0001883a 	nop
8110c7cc:	e037883a 	mov	sp,fp
8110c7d0:	dfc00117 	ldw	ra,4(sp)
8110c7d4:	df000017 	ldw	fp,0(sp)
8110c7d8:	dec00204 	addi	sp,sp,8
8110c7dc:	f800283a 	ret

8110c7e0 <RTCC_SPI_R_MAC>:

// Note. SCK: typical 19.2KHZ (53 ms)
bool RTCC_SPI_R_MAC(alt_u8 uc_EUI48_array[6])
{
8110c7e0:	defff604 	addi	sp,sp,-40
8110c7e4:	de00012e 	bgeu	sp,et,8110c7ec <RTCC_SPI_R_MAC+0xc>
8110c7e8:	003b68fa 	trap	3
8110c7ec:	dfc00915 	stw	ra,36(sp)
8110c7f0:	df000815 	stw	fp,32(sp)
8110c7f4:	df000804 	addi	fp,sp,32
8110c7f8:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8110c7fc:	e03ffc15 	stw	zero,-16(fp)

    alt_u8 uc_EUI48_B0 = 0;
8110c800:	e03ffd05 	stb	zero,-12(fp)
    alt_u8 uc_EUI48_B1 = 0;
8110c804:	e03ffd45 	stb	zero,-11(fp)
    alt_u8 uc_EUI48_B2 = 0;
8110c808:	e03ffd85 	stb	zero,-10(fp)
    alt_u8 uc_EUI48_B3 = 0;
8110c80c:	e03ffdc5 	stb	zero,-9(fp)
    alt_u8 uc_EUI48_B4 = 0;
8110c810:	e03ffe05 	stb	zero,-8(fp)
    alt_u8 uc_EUI48_B5 = 0;
8110c814:	e03ffe45 	stb	zero,-7(fp)

//    alt_u8 uc_sdi_mask;

    const alt_u8 uc_EUI48_B0_addr = 0x02;
8110c818:	00800084 	movi	r2,2
8110c81c:	e0bffe85 	stb	r2,-6(fp)
//    const alt_u8 uc_EUI48_B2_addr = 0x04;
//    const alt_u8 uc_EUI48_B3_addr = 0x05;
//    const alt_u8 uc_EUI48_B4_addr = 0x06;
//    const alt_u8 uc_EUI48_B5_addr = 0x07;

    const alt_u8 uc_IDREAD_cmd = 0x33;
8110c820:	00800cc4 	movi	r2,51
8110c824:	e0bffec5 	stb	r2,-5(fp)

//    int i = 0;
    
    // Start Communication
    v_spi_start();
8110c828:	110c5b80 	call	8110c5b8 <v_spi_start>

    //Send IDREAD (0011 0011)
    v_spi_send_byte(uc_IDREAD_cmd);
8110c82c:	e0bffec3 	ldbu	r2,-5(fp)
8110c830:	1009883a 	mov	r4,r2
8110c834:	110c6100 	call	8110c610 <v_spi_send_byte>

    //Send Address (0x02 - 0x07)
    v_spi_send_byte(uc_EUI48_B0_addr);
8110c838:	e0bffe83 	ldbu	r2,-6(fp)
8110c83c:	1009883a 	mov	r4,r2
8110c840:	110c6100 	call	8110c610 <v_spi_send_byte>

    //Read MAC (EUI-48, 6 bytes)
    uc_EUI48_B0 = uc_spi_get_byte();
8110c844:	110c6d40 	call	8110c6d4 <uc_spi_get_byte>
8110c848:	e0bffd05 	stb	r2,-12(fp)
    uc_EUI48_B1 = uc_spi_get_byte();
8110c84c:	110c6d40 	call	8110c6d4 <uc_spi_get_byte>
8110c850:	e0bffd45 	stb	r2,-11(fp)
    uc_EUI48_B2 = uc_spi_get_byte();
8110c854:	110c6d40 	call	8110c6d4 <uc_spi_get_byte>
8110c858:	e0bffd85 	stb	r2,-10(fp)
    uc_EUI48_B3 = uc_spi_get_byte();
8110c85c:	110c6d40 	call	8110c6d4 <uc_spi_get_byte>
8110c860:	e0bffdc5 	stb	r2,-9(fp)
    uc_EUI48_B4 = uc_spi_get_byte();
8110c864:	110c6d40 	call	8110c6d4 <uc_spi_get_byte>
8110c868:	e0bffe05 	stb	r2,-8(fp)
    uc_EUI48_B5 = uc_spi_get_byte();
8110c86c:	110c6d40 	call	8110c6d4 <uc_spi_get_byte>
8110c870:	e0bffe45 	stb	r2,-7(fp)

    // End communication
    v_spi_end();
8110c874:	110c7880 	call	8110c788 <v_spi_end>

    bSuccess = TRUE;
8110c878:	00800044 	movi	r2,1
8110c87c:	e0bffc15 	stw	r2,-16(fp)
    
    uc_EUI48_array[0] = uc_EUI48_B0;
8110c880:	e0bfff17 	ldw	r2,-4(fp)
8110c884:	e0fffd03 	ldbu	r3,-12(fp)
8110c888:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[1] = uc_EUI48_B1;
8110c88c:	e0bfff17 	ldw	r2,-4(fp)
8110c890:	10800044 	addi	r2,r2,1
8110c894:	e0fffd43 	ldbu	r3,-11(fp)
8110c898:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[2] = uc_EUI48_B2;
8110c89c:	e0bfff17 	ldw	r2,-4(fp)
8110c8a0:	10800084 	addi	r2,r2,2
8110c8a4:	e0fffd83 	ldbu	r3,-10(fp)
8110c8a8:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[3] = uc_EUI48_B3;
8110c8ac:	e0bfff17 	ldw	r2,-4(fp)
8110c8b0:	108000c4 	addi	r2,r2,3
8110c8b4:	e0fffdc3 	ldbu	r3,-9(fp)
8110c8b8:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[4] = uc_EUI48_B4;
8110c8bc:	e0bfff17 	ldw	r2,-4(fp)
8110c8c0:	10800104 	addi	r2,r2,4
8110c8c4:	e0fffe03 	ldbu	r3,-8(fp)
8110c8c8:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[5] = uc_EUI48_B5;
8110c8cc:	e0bfff17 	ldw	r2,-4(fp)
8110c8d0:	10800144 	addi	r2,r2,5
8110c8d4:	e0fffe43 	ldbu	r3,-7(fp)
8110c8d8:	10c00005 	stb	r3,0(r2)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "RTCC EUI-48 MAC Address: 0x%02x:%02x:%02x:%02x:%02x:%02x \n", uc_EUI48_B0, uc_EUI48_B1, uc_EUI48_B2, uc_EUI48_B3, uc_EUI48_B4, uc_EUI48_B5);
8110c8dc:	e1bffd03 	ldbu	r6,-12(fp)
8110c8e0:	e1fffd43 	ldbu	r7,-11(fp)
8110c8e4:	e0bffd83 	ldbu	r2,-10(fp)
8110c8e8:	e0fffdc3 	ldbu	r3,-9(fp)
8110c8ec:	e13ffe03 	ldbu	r4,-8(fp)
8110c8f0:	e17ffe43 	ldbu	r5,-7(fp)
8110c8f4:	d9400315 	stw	r5,12(sp)
8110c8f8:	d9000215 	stw	r4,8(sp)
8110c8fc:	d8c00115 	stw	r3,4(sp)
8110c900:	d8800015 	stw	r2,0(sp)
8110c904:	01604574 	movhi	r5,33045
8110c908:	2971d804 	addi	r5,r5,-14496
8110c90c:	01204574 	movhi	r4,33045
8110c910:	210e1c04 	addi	r4,r4,14448
8110c914:	1122f700 	call	81122f70 <sprintf>
	debug(fp, cDebugBuffer);
8110c918:	d0a06217 	ldw	r2,-32376(gp)
8110c91c:	01604574 	movhi	r5,33045
8110c920:	294e1c04 	addi	r5,r5,14448
8110c924:	1009883a 	mov	r4,r2
8110c928:	11215e00 	call	811215e0 <fprintf>
#endif

    return bSuccess;
8110c92c:	e0bffc17 	ldw	r2,-16(fp)
}
8110c930:	e037883a 	mov	sp,fp
8110c934:	dfc00117 	ldw	ra,4(sp)
8110c938:	df000017 	ldw	fp,0(sp)
8110c93c:	dec00204 	addi	sp,sp,8
8110c940:	f800283a 	ret

8110c944 <bSSDisplayConfig>:
 *
 * @retval TRUE : Sucesso
 * @retval FALSE : Configurao no especificada
 *
 */
bool bSSDisplayConfig(alt_u8 SsdpConfig){
8110c944:	defffd04 	addi	sp,sp,-12
8110c948:	de00012e 	bgeu	sp,et,8110c950 <bSSDisplayConfig+0xc>
8110c94c:	003b68fa 	trap	3
8110c950:	df000215 	stw	fp,8(sp)
8110c954:	df000204 	addi	fp,sp,8
8110c958:	2005883a 	mov	r2,r4
8110c95c:	e0bfff05 	stb	r2,-4(fp)

    switch(SsdpConfig){
8110c960:	e0bfff03 	ldbu	r2,-4(fp)
8110c964:	10c00168 	cmpgeui	r3,r2,5
8110c968:	18001c1e 	bne	r3,zero,8110c9dc <bSSDisplayConfig+0x98>
8110c96c:	100690ba 	slli	r3,r2,2
8110c970:	00a04474 	movhi	r2,33041
8110c974:	10b26104 	addi	r2,r2,-13948
8110c978:	1885883a 	add	r2,r3,r2
8110c97c:	10800017 	ldw	r2,0(r2)
8110c980:	1000683a 	jmp	r2
8110c984:	8110c998 	cmpnei	r4,r16,17190
8110c988:	8110c9a4 	muli	r4,r16,17190
8110c98c:	8110c9b0 	cmpltui	r4,r16,17190
8110c990:	8110c9c4 	addi	r4,r16,17191
8110c994:	8110c9d4 	ori	r4,r16,17191
	    case SSDP_NORMAL_MODE:
	        SspdConfigControl = (SSDP_ON_MASK | SSDP_UNLOCK_MASK);
8110c998:	00800cc4 	movi	r2,51
8110c99c:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110c9a0:	00001006 	br	8110c9e4 <bSSDisplayConfig+0xa0>
		
	    case SSDP_TEST_MODE:
	        SspdConfigControl = (SSDP_ON_MASK | SSDP_TEST_MASK);
8110c9a4:	00801544 	movi	r2,85
8110c9a8:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110c9ac:	00000d06 	br	8110c9e4 <bSSDisplayConfig+0xa0>
		
	    case SSDP_LOCK:
	        SspdConfigControl &= (~SSDP_UNLOCK_MASK);
8110c9b0:	d0e05043 	ldbu	r3,-32447(gp)
8110c9b4:	00bff744 	movi	r2,-35
8110c9b8:	1884703a 	and	r2,r3,r2
8110c9bc:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110c9c0:	00000806 	br	8110c9e4 <bSSDisplayConfig+0xa0>
		
	    case SSDP_UNLOCK:
	        SspdConfigControl |= SSDP_UNLOCK_MASK;
8110c9c4:	d0a05043 	ldbu	r2,-32447(gp)
8110c9c8:	10800894 	ori	r2,r2,34
8110c9cc:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110c9d0:	00000406 	br	8110c9e4 <bSSDisplayConfig+0xa0>
		
	    case SSDP_OFF:
	        SspdConfigControl = SSDP_OFF_MASK;
8110c9d4:	d0205045 	stb	zero,-32447(gp)
	    break;
8110c9d8:	00000206 	br	8110c9e4 <bSSDisplayConfig+0xa0>
		
		default:
		    return FALSE;
8110c9dc:	0005883a 	mov	r2,zero
8110c9e0:	00000806 	br	8110ca04 <bSSDisplayConfig+0xc0>
	}

	alt_u32 *pSsdpAddr = (alt_u32 *)SSDP_BASE;
8110c9e4:	00a00034 	movhi	r2,32768
8110c9e8:	10828404 	addi	r2,r2,2576
8110c9ec:	e0bffe15 	stw	r2,-8(fp)
	*(pSsdpAddr + SSDP_CONTROL_REG_OFFSET) = (alt_u32) SspdConfigControl;
8110c9f0:	d0a05043 	ldbu	r2,-32447(gp)
8110c9f4:	10c03fcc 	andi	r3,r2,255
8110c9f8:	e0bffe17 	ldw	r2,-8(fp)
8110c9fc:	10c00015 	stw	r3,0(r2)
	
	return TRUE;
8110ca00:	00800044 	movi	r2,1
}
8110ca04:	e037883a 	mov	sp,fp
8110ca08:	df000017 	ldw	fp,0(sp)
8110ca0c:	dec00104 	addi	sp,sp,4
8110ca10:	f800283a 	ret

8110ca14 <bSSDisplayUpdate>:
 * @param [in] SsdpData Dado a ser colocado no display de sete segmentos, do tipo unsigned char (alt_u8)
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSSDisplayUpdate(alt_u8 SsdpData){
8110ca14:	defffd04 	addi	sp,sp,-12
8110ca18:	de00012e 	bgeu	sp,et,8110ca20 <bSSDisplayUpdate+0xc>
8110ca1c:	003b68fa 	trap	3
8110ca20:	df000215 	stw	fp,8(sp)
8110ca24:	df000204 	addi	fp,sp,8
8110ca28:	2005883a 	mov	r2,r4
8110ca2c:	e0bfff05 	stb	r2,-4(fp)

	alt_u32 *pSsdpAddr = (alt_u32 *)SSDP_BASE;
8110ca30:	00a00034 	movhi	r2,32768
8110ca34:	10828404 	addi	r2,r2,2576
8110ca38:	e0bffe15 	stw	r2,-8(fp)
	*(pSsdpAddr + SSDP_DATA_REG_OFFSET) = (alt_u32) SsdpData;
8110ca3c:	e0bffe17 	ldw	r2,-8(fp)
8110ca40:	10800104 	addi	r2,r2,4
8110ca44:	e0ffff03 	ldbu	r3,-4(fp)
8110ca48:	10c00015 	stw	r3,0(r2)
	
	return TRUE;
8110ca4c:	00800044 	movi	r2,1
}
8110ca50:	e037883a 	mov	sp,fp
8110ca54:	df000017 	ldw	fp,0(sp)
8110ca58:	dec00104 	addi	sp,sp,4
8110ca5c:	f800283a 	ret

8110ca60 <vSyncHandleIrq>:
 *
 * @param [in] void* context
 *
 * @retval void
 */
void vSyncHandleIrq(void* pvContext) {
8110ca60:	defff904 	addi	sp,sp,-28
8110ca64:	de00012e 	bgeu	sp,et,8110ca6c <vSyncHandleIrq+0xc>
8110ca68:	003b68fa 	trap	3
8110ca6c:	dfc00615 	stw	ra,24(sp)
8110ca70:	df000515 	stw	fp,20(sp)
8110ca74:	df000504 	addi	fp,sp,20
8110ca78:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucIL;
	unsigned char ucSyncL;
	unsigned char error_codel;
	tQMask uiCmdtoSend;

	volatile int* pviHoldContext = (volatile int*) pvContext;
8110ca7c:	e0bfff17 	ldw	r2,-4(fp)
8110ca80:	e0bffc15 	stw	r2,-16(fp)


	uiCmdtoSend.ulWord = 0;
8110ca84:	e03ffe15 	stw	zero,-8(fp)
	/* MasterSync? */
	ucSyncL = (vucN % 4);
8110ca88:	d0a05203 	ldbu	r2,-32440(gp)
8110ca8c:	108000cc 	andi	r2,r2,3
8110ca90:	e0bffd05 	stb	r2,-12(fp)
	if ( ucSyncL == 0 )
8110ca94:	e0bffd03 	ldbu	r2,-12(fp)
8110ca98:	1000031e 	bne	r2,zero,8110caa8 <vSyncHandleIrq+0x48>
		uiCmdtoSend.ucByte[2] = M_MASTER_SYNC;
8110ca9c:	00bff804 	movi	r2,-32
8110caa0:	e0bffe85 	stb	r2,-6(fp)
8110caa4:	00000206 	br	8110cab0 <vSyncHandleIrq+0x50>
	else
		uiCmdtoSend.ucByte[2] = M_SYNC;
8110caa8:	00bff844 	movi	r2,-31
8110caac:	e0bffe85 	stb	r2,-6(fp)

	uiCmdtoSend.ucByte[3] = M_MEB_ADDR;
8110cab0:	00800044 	movi	r2,1
8110cab4:	e0bffec5 	stb	r2,-5(fp)

	/* Send Priority message to the Meb Task to indicate the Master Sync */
	error_codel = OSQPostFront(xMebQ, (void *)uiCmdtoSend.ulWord);
8110cab8:	d0a06917 	ldw	r2,-32348(gp)
8110cabc:	e0fffe17 	ldw	r3,-8(fp)
8110cac0:	180b883a 	mov	r5,r3
8110cac4:	1009883a 	mov	r4,r2
8110cac8:	113e1980 	call	8113e198 <OSQPostFront>
8110cacc:	e0bffd45 	stb	r2,-11(fp)
	if ( error_codel != OS_ERR_NONE ) {
8110cad0:	e0bffd43 	ldbu	r2,-11(fp)
8110cad4:	10000126 	beq	r2,zero,8110cadc <vSyncHandleIrq+0x7c>
		vFailSendMsgMasterSyncMeb( );
8110cad8:	111d5a80 	call	8111d5a8 <vFailSendMsgMasterSyncMeb>
	}

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
8110cadc:	e03ffb05 	stb	zero,-20(fp)
8110cae0:	00001606 	br	8110cb3c <vSyncHandleIrq+0xdc>
		uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucIL;
8110cae4:	e0bffb03 	ldbu	r2,-20(fp)
8110cae8:	10800444 	addi	r2,r2,17
8110caec:	e0bffec5 	stb	r2,-5(fp)
		error_codel = OSQPostFront(xFeeQ[ ucIL ], (void *)uiCmdtoSend.ulWord);
8110caf0:	e0bffb03 	ldbu	r2,-20(fp)
8110caf4:	1085883a 	add	r2,r2,r2
8110caf8:	1087883a 	add	r3,r2,r2
8110cafc:	d0a06a04 	addi	r2,gp,-32344
8110cb00:	1885883a 	add	r2,r3,r2
8110cb04:	10800017 	ldw	r2,0(r2)
8110cb08:	e0fffe17 	ldw	r3,-8(fp)
8110cb0c:	180b883a 	mov	r5,r3
8110cb10:	1009883a 	mov	r4,r2
8110cb14:	113e1980 	call	8113e198 <OSQPostFront>
8110cb18:	e0bffd45 	stb	r2,-11(fp)
		if ( error_codel != OS_ERR_NONE ) {
8110cb1c:	e0bffd43 	ldbu	r2,-11(fp)
8110cb20:	10000326 	beq	r2,zero,8110cb30 <vSyncHandleIrq+0xd0>
			vFailSendMsgSync( ucIL );
8110cb24:	e0bffb03 	ldbu	r2,-20(fp)
8110cb28:	1009883a 	mov	r4,r2
8110cb2c:	111d5000 	call	8111d500 <vFailSendMsgSync>
	error_codel = OSQPostFront(xMebQ, (void *)uiCmdtoSend.ulWord);
	if ( error_codel != OS_ERR_NONE ) {
		vFailSendMsgMasterSyncMeb( );
	}

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
8110cb30:	e0bffb03 	ldbu	r2,-20(fp)
8110cb34:	10800044 	addi	r2,r2,1
8110cb38:	e0bffb05 	stb	r2,-20(fp)
8110cb3c:	e0bffb03 	ldbu	r2,-20(fp)
8110cb40:	103fe826 	beq	r2,zero,8110cae4 <__reset+0xfb0ecae4>
		if ( error_codel != OS_ERR_NONE ) {
			vFailSendMsgSync( ucIL );
		}
	}

	vucN += 1;
8110cb44:	d0a05203 	ldbu	r2,-32440(gp)
8110cb48:	10800044 	addi	r2,r2,1
8110cb4c:	d0a05205 	stb	r2,-32440(gp)

	#ifdef DEBUG_ON
		fprintf(fp,"Sync %hu \n", ucSyncL);
8110cb50:	d0a06217 	ldw	r2,-32376(gp)
8110cb54:	e0fffd03 	ldbu	r3,-12(fp)
8110cb58:	180d883a 	mov	r6,r3
8110cb5c:	01604574 	movhi	r5,33045
8110cb60:	2971e704 	addi	r5,r5,-14436
8110cb64:	1009883a 	mov	r4,r2
8110cb68:	11215e00 	call	811215e0 <fprintf>
	#endif

	vSyncIrqFlagClrSync();
8110cb6c:	110cc000 	call	8110cc00 <vSyncIrqFlagClrSync>
}
8110cb70:	0001883a 	nop
8110cb74:	e037883a 	mov	sp,fp
8110cb78:	dfc00117 	ldw	ra,4(sp)
8110cb7c:	df000017 	ldw	fp,0(sp)
8110cb80:	dec00204 	addi	sp,sp,8
8110cb84:	f800283a 	ret

8110cb88 <vSyncClearCounter>:

void vSyncClearCounter(void) {
8110cb88:	deffff04 	addi	sp,sp,-4
8110cb8c:	de00012e 	bgeu	sp,et,8110cb94 <vSyncClearCounter+0xc>
8110cb90:	003b68fa 	trap	3
8110cb94:	df000015 	stw	fp,0(sp)
8110cb98:	d839883a 	mov	fp,sp
	// Recast the viHoldContext pointer to match the alt_irq_register() function
	// prototype.
	vucN = 0;
8110cb9c:	d0205205 	stb	zero,-32440(gp)
}
8110cba0:	0001883a 	nop
8110cba4:	e037883a 	mov	sp,fp
8110cba8:	df000017 	ldw	fp,0(sp)
8110cbac:	dec00104 	addi	sp,sp,4
8110cbb0:	f800283a 	ret

8110cbb4 <vSyncInitIrq>:
 *
 * @param [in] void
 *
 * @retval void
 */
void vSyncInitIrq(void) {
8110cbb4:	defffd04 	addi	sp,sp,-12
8110cbb8:	de00012e 	bgeu	sp,et,8110cbc0 <vSyncInitIrq+0xc>
8110cbbc:	003b68fa 	trap	3
8110cbc0:	dfc00215 	stw	ra,8(sp)
8110cbc4:	df000115 	stw	fp,4(sp)
8110cbc8:	df000104 	addi	fp,sp,4
	// Recast the viHoldContext pointer to match the alt_irq_register() function
	// prototype.
	void* hold_context_ptr = (void*) &viHoldContext;
8110cbcc:	d0a05104 	addi	r2,gp,-32444
8110cbd0:	e0bfff15 	stw	r2,-4(fp)
	// Register the interrupt handler
	alt_irq_register(SYNC_IRQ, hold_context_ptr, vSyncHandleIrq);
8110cbd4:	01a04474 	movhi	r6,33041
8110cbd8:	31b29804 	addi	r6,r6,-13728
8110cbdc:	e17fff17 	ldw	r5,-4(fp)
8110cbe0:	01000284 	movi	r4,10
8110cbe4:	11366440 	call	81136644 <alt_irq_register>
}
8110cbe8:	0001883a 	nop
8110cbec:	e037883a 	mov	sp,fp
8110cbf0:	dfc00117 	ldw	ra,4(sp)
8110cbf4:	df000017 	ldw	fp,0(sp)
8110cbf8:	dec00204 	addi	sp,sp,8
8110cbfc:	f800283a 	ret

8110cc00 <vSyncIrqFlagClrSync>:

void vSyncIrqFlagClrSync(void) {
8110cc00:	defffe04 	addi	sp,sp,-8
8110cc04:	de00012e 	bgeu	sp,et,8110cc0c <vSyncIrqFlagClrSync+0xc>
8110cc08:	003b68fa 	trap	3
8110cc0c:	dfc00115 	stw	ra,4(sp)
8110cc10:	df000015 	stw	fp,0(sp)
8110cc14:	d839883a 	mov	fp,sp
	bSyncWriteReg(SYNC_IRQ_FG_CLR_REG_OFFSET, (alt_u32) SYNC_IRQ_FG_CLR_MSK);
8110cc18:	01400044 	movi	r5,1
8110cc1c:	010002c4 	movi	r4,11
8110cc20:	110d9e00 	call	8110d9e0 <bSyncWriteReg>
}
8110cc24:	0001883a 	nop
8110cc28:	e037883a 	mov	sp,fp
8110cc2c:	dfc00117 	ldw	ra,4(sp)
8110cc30:	df000017 	ldw	fp,0(sp)
8110cc34:	dec00204 	addi	sp,sp,8
8110cc38:	f800283a 	ret

8110cc3c <bSyncIrqFlagSync>:

bool bSyncIrqFlagSync(void) {
8110cc3c:	defffd04 	addi	sp,sp,-12
8110cc40:	de00012e 	bgeu	sp,et,8110cc48 <bSyncIrqFlagSync+0xc>
8110cc44:	003b68fa 	trap	3
8110cc48:	dfc00215 	stw	ra,8(sp)
8110cc4c:	df000115 	stw	fp,4(sp)
8110cc50:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliSyncReadReg(SYNC_IRQ_FG_REG_OFFSET) & SYNC_IRQ_FG_MSK) {
8110cc54:	01000304 	movi	r4,12
8110cc58:	110da3c0 	call	8110da3c <uliSyncReadReg>
8110cc5c:	1080004c 	andi	r2,r2,1
8110cc60:	10000326 	beq	r2,zero,8110cc70 <bSyncIrqFlagSync+0x34>
		bFlag = TRUE;
8110cc64:	00800044 	movi	r2,1
8110cc68:	e0bfff15 	stw	r2,-4(fp)
8110cc6c:	00000106 	br	8110cc74 <bSyncIrqFlagSync+0x38>
	} else {
		bFlag = FALSE;
8110cc70:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110cc74:	e0bfff17 	ldw	r2,-4(fp)
}
8110cc78:	e037883a 	mov	sp,fp
8110cc7c:	dfc00117 	ldw	ra,4(sp)
8110cc80:	df000017 	ldw	fp,0(sp)
8110cc84:	dec00204 	addi	sp,sp,8
8110cc88:	f800283a 	ret

8110cc8c <bSyncStatusExtnIrq>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncStatusExtnIrq(void) {
8110cc8c:	defffc04 	addi	sp,sp,-16
8110cc90:	de00012e 	bgeu	sp,et,8110cc98 <bSyncStatusExtnIrq+0xc>
8110cc94:	003b68fa 	trap	3
8110cc98:	dfc00315 	stw	ra,12(sp)
8110cc9c:	df000215 	stw	fp,8(sp)
8110cca0:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110cca4:	0009883a 	mov	r4,zero
8110cca8:	110da3c0 	call	8110da3c <uliSyncReadReg>
8110ccac:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_STAT_EXTN_IRQ_MSK) {
8110ccb0:	e0bfff17 	ldw	r2,-4(fp)
8110ccb4:	1000030e 	bge	r2,zero,8110ccc4 <bSyncStatusExtnIrq+0x38>
		bResult = TRUE;
8110ccb8:	00800044 	movi	r2,1
8110ccbc:	e0bffe15 	stw	r2,-8(fp)
8110ccc0:	00000106 	br	8110ccc8 <bSyncStatusExtnIrq+0x3c>
	} else {
		bResult = FALSE;
8110ccc4:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110ccc8:	e0bffe17 	ldw	r2,-8(fp)
}
8110cccc:	e037883a 	mov	sp,fp
8110ccd0:	dfc00117 	ldw	ra,4(sp)
8110ccd4:	df000017 	ldw	fp,0(sp)
8110ccd8:	dec00204 	addi	sp,sp,8
8110ccdc:	f800283a 	ret

8110cce0 <ucSyncStatusState>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusState(void) {
8110cce0:	defffc04 	addi	sp,sp,-16
8110cce4:	de00012e 	bgeu	sp,et,8110ccec <ucSyncStatusState+0xc>
8110cce8:	003b68fa 	trap	3
8110ccec:	dfc00315 	stw	ra,12(sp)
8110ccf0:	df000215 	stw	fp,8(sp)
8110ccf4:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110ccf8:	0009883a 	mov	r4,zero
8110ccfc:	110da3c0 	call	8110da3c <uliSyncReadReg>
8110cd00:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_STATE_MSK) >> 16);
8110cd04:	e0bffe17 	ldw	r2,-8(fp)
8110cd08:	10803fec 	andhi	r2,r2,255
8110cd0c:	1004d43a 	srli	r2,r2,16
8110cd10:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110cd14:	e0bfff03 	ldbu	r2,-4(fp)
}
8110cd18:	e037883a 	mov	sp,fp
8110cd1c:	dfc00117 	ldw	ra,4(sp)
8110cd20:	df000017 	ldw	fp,0(sp)
8110cd24:	dec00204 	addi	sp,sp,8
8110cd28:	f800283a 	ret

8110cd2c <ucSyncStatusErrorCode>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusErrorCode(void) {
8110cd2c:	defffc04 	addi	sp,sp,-16
8110cd30:	de00012e 	bgeu	sp,et,8110cd38 <ucSyncStatusErrorCode+0xc>
8110cd34:	003b68fa 	trap	3
8110cd38:	dfc00315 	stw	ra,12(sp)
8110cd3c:	df000215 	stw	fp,8(sp)
8110cd40:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110cd44:	0009883a 	mov	r4,zero
8110cd48:	110da3c0 	call	8110da3c <uliSyncReadReg>
8110cd4c:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_ERROR_CODE_MSK) >> 8);
8110cd50:	e0bffe17 	ldw	r2,-8(fp)
8110cd54:	10bfc00c 	andi	r2,r2,65280
8110cd58:	1004d23a 	srli	r2,r2,8
8110cd5c:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110cd60:	e0bfff03 	ldbu	r2,-4(fp)
}
8110cd64:	e037883a 	mov	sp,fp
8110cd68:	dfc00117 	ldw	ra,4(sp)
8110cd6c:	df000017 	ldw	fp,0(sp)
8110cd70:	dec00204 	addi	sp,sp,8
8110cd74:	f800283a 	ret

8110cd78 <ucSyncStatusCycleNumber>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusCycleNumber(void) {
8110cd78:	defffc04 	addi	sp,sp,-16
8110cd7c:	de00012e 	bgeu	sp,et,8110cd84 <ucSyncStatusCycleNumber+0xc>
8110cd80:	003b68fa 	trap	3
8110cd84:	dfc00315 	stw	ra,12(sp)
8110cd88:	df000215 	stw	fp,8(sp)
8110cd8c:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110cd90:	0009883a 	mov	r4,zero
8110cd94:	110da3c0 	call	8110da3c <uliSyncReadReg>
8110cd98:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_CYCLE_NUMBER_MSK) >> 0);
8110cd9c:	e0bffe17 	ldw	r2,-8(fp)
8110cda0:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110cda4:	e0bfff03 	ldbu	r2,-4(fp)
}
8110cda8:	e037883a 	mov	sp,fp
8110cdac:	dfc00117 	ldw	ra,4(sp)
8110cdb0:	df000017 	ldw	fp,0(sp)
8110cdb4:	dec00204 	addi	sp,sp,8
8110cdb8:	f800283a 	ret

8110cdbc <bSyncSetMbt>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetMbt(alt_u32 uliValue) {
8110cdbc:	defffd04 	addi	sp,sp,-12
8110cdc0:	de00012e 	bgeu	sp,et,8110cdc8 <bSyncSetMbt+0xc>
8110cdc4:	003b68fa 	trap	3
8110cdc8:	dfc00215 	stw	ra,8(sp)
8110cdcc:	df000115 	stw	fp,4(sp)
8110cdd0:	df000104 	addi	fp,sp,4
8110cdd4:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_MBT_REG_OFFSET, uliValue);
8110cdd8:	e17fff17 	ldw	r5,-4(fp)
8110cddc:	01000104 	movi	r4,4
8110cde0:	110d9e00 	call	8110d9e0 <bSyncWriteReg>
	return TRUE;
8110cde4:	00800044 	movi	r2,1
}
8110cde8:	e037883a 	mov	sp,fp
8110cdec:	dfc00117 	ldw	ra,4(sp)
8110cdf0:	df000017 	ldw	fp,0(sp)
8110cdf4:	dec00204 	addi	sp,sp,8
8110cdf8:	f800283a 	ret

8110cdfc <bSyncSetBt>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetBt(alt_u32 uliValue) {
8110cdfc:	defffd04 	addi	sp,sp,-12
8110ce00:	de00012e 	bgeu	sp,et,8110ce08 <bSyncSetBt+0xc>
8110ce04:	003b68fa 	trap	3
8110ce08:	dfc00215 	stw	ra,8(sp)
8110ce0c:	df000115 	stw	fp,4(sp)
8110ce10:	df000104 	addi	fp,sp,4
8110ce14:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_BT_REG_OFFSET, uliValue);
8110ce18:	e17fff17 	ldw	r5,-4(fp)
8110ce1c:	01000144 	movi	r4,5
8110ce20:	110d9e00 	call	8110d9e0 <bSyncWriteReg>
	return TRUE;
8110ce24:	00800044 	movi	r2,1
}
8110ce28:	e037883a 	mov	sp,fp
8110ce2c:	dfc00117 	ldw	ra,4(sp)
8110ce30:	df000017 	ldw	fp,0(sp)
8110ce34:	dec00204 	addi	sp,sp,8
8110ce38:	f800283a 	ret

8110ce3c <bSyncSetPer>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetPer(alt_u32 uliValue) {
8110ce3c:	defffd04 	addi	sp,sp,-12
8110ce40:	de00012e 	bgeu	sp,et,8110ce48 <bSyncSetPer+0xc>
8110ce44:	003b68fa 	trap	3
8110ce48:	dfc00215 	stw	ra,8(sp)
8110ce4c:	df000115 	stw	fp,4(sp)
8110ce50:	df000104 	addi	fp,sp,4
8110ce54:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_PER_REG_OFFSET, uliValue);
8110ce58:	e17fff17 	ldw	r5,-4(fp)
8110ce5c:	01000184 	movi	r4,6
8110ce60:	110d9e00 	call	8110d9e0 <bSyncWriteReg>
	return TRUE;
8110ce64:	00800044 	movi	r2,1
}
8110ce68:	e037883a 	mov	sp,fp
8110ce6c:	dfc00117 	ldw	ra,4(sp)
8110ce70:	df000017 	ldw	fp,0(sp)
8110ce74:	dec00204 	addi	sp,sp,8
8110ce78:	f800283a 	ret

8110ce7c <bSyncSetOst>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetOst(alt_u32 uliValue) {
8110ce7c:	defffd04 	addi	sp,sp,-12
8110ce80:	de00012e 	bgeu	sp,et,8110ce88 <bSyncSetOst+0xc>
8110ce84:	003b68fa 	trap	3
8110ce88:	dfc00215 	stw	ra,8(sp)
8110ce8c:	df000115 	stw	fp,4(sp)
8110ce90:	df000104 	addi	fp,sp,4
8110ce94:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_OST_REG_OFFSET, uliValue);
8110ce98:	e17fff17 	ldw	r5,-4(fp)
8110ce9c:	010001c4 	movi	r4,7
8110cea0:	110d9e00 	call	8110d9e0 <bSyncWriteReg>
	return TRUE;
8110cea4:	00800044 	movi	r2,1
}
8110cea8:	e037883a 	mov	sp,fp
8110ceac:	dfc00117 	ldw	ra,4(sp)
8110ceb0:	df000017 	ldw	fp,0(sp)
8110ceb4:	dec00204 	addi	sp,sp,8
8110ceb8:	f800283a 	ret

8110cebc <bSyncSetPolarity>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncSetPolarity(bool bValue) {
8110cebc:	defffc04 	addi	sp,sp,-16
8110cec0:	de00012e 	bgeu	sp,et,8110cec8 <bSyncSetPolarity+0xc>
8110cec4:	003b68fa 	trap	3
8110cec8:	dfc00315 	stw	ra,12(sp)
8110cecc:	df000215 	stw	fp,8(sp)
8110ced0:	df000204 	addi	fp,sp,8
8110ced4:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110ced8:	01000204 	movi	r4,8
8110cedc:	110da3c0 	call	8110da3c <uliSyncReadReg>
8110cee0:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110cee4:	e0bfff17 	ldw	r2,-4(fp)
8110cee8:	1000051e 	bne	r2,zero,8110cf00 <bSyncSetPolarity+0x44>
		uliAux &= ~SYNC_CONFIG_GEN_POLARITY_MSK;
8110ceec:	e0fffe17 	ldw	r3,-8(fp)
8110cef0:	00bfbfc4 	movi	r2,-257
8110cef4:	1884703a 	and	r2,r3,r2
8110cef8:	e0bffe15 	stw	r2,-8(fp)
8110cefc:	00000306 	br	8110cf0c <bSyncSetPolarity+0x50>
	} else {
		uliAux |= SYNC_CONFIG_GEN_POLARITY_MSK;
8110cf00:	e0bffe17 	ldw	r2,-8(fp)
8110cf04:	10804014 	ori	r2,r2,256
8110cf08:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CONFIG_GENERAL_REG_OFFSET, uliAux);
8110cf0c:	e17ffe17 	ldw	r5,-8(fp)
8110cf10:	01000204 	movi	r4,8
8110cf14:	110d9e00 	call	8110d9e0 <bSyncWriteReg>
	return TRUE;
8110cf18:	00800044 	movi	r2,1
}
8110cf1c:	e037883a 	mov	sp,fp
8110cf20:	dfc00117 	ldw	ra,4(sp)
8110cf24:	df000017 	ldw	fp,0(sp)
8110cf28:	dec00204 	addi	sp,sp,8
8110cf2c:	f800283a 	ret

8110cf30 <bSyncSetNCycles>:
 *
 * @param [in] alt_u8 value
 *
 * @retval bool TRUE
 */
bool bSyncSetNCycles(alt_u8 ucValue) {
8110cf30:	defffc04 	addi	sp,sp,-16
8110cf34:	de00012e 	bgeu	sp,et,8110cf3c <bSyncSetNCycles+0xc>
8110cf38:	003b68fa 	trap	3
8110cf3c:	dfc00315 	stw	ra,12(sp)
8110cf40:	df000215 	stw	fp,8(sp)
8110cf44:	df000204 	addi	fp,sp,8
8110cf48:	2005883a 	mov	r2,r4
8110cf4c:	e0bfff05 	stb	r2,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110cf50:	01000204 	movi	r4,8
8110cf54:	110da3c0 	call	8110da3c <uliSyncReadReg>
8110cf58:	e0bffe15 	stw	r2,-8(fp)
	uliAux &= ~SYNC_CONFIG_GEN_N_CYCLES_MSK;
8110cf5c:	e0fffe17 	ldw	r3,-8(fp)
8110cf60:	00bfc004 	movi	r2,-256
8110cf64:	1884703a 	and	r2,r3,r2
8110cf68:	e0bffe15 	stw	r2,-8(fp)
	uliAux |= (alt_u32) ucValue;
8110cf6c:	e0bfff03 	ldbu	r2,-4(fp)
8110cf70:	e0fffe17 	ldw	r3,-8(fp)
8110cf74:	1884b03a 	or	r2,r3,r2
8110cf78:	e0bffe15 	stw	r2,-8(fp)

	bSyncWriteReg(SYNC_CONFIG_GENERAL_REG_OFFSET, uliAux);
8110cf7c:	e17ffe17 	ldw	r5,-8(fp)
8110cf80:	01000204 	movi	r4,8
8110cf84:	110d9e00 	call	8110d9e0 <bSyncWriteReg>
	return TRUE;
8110cf88:	00800044 	movi	r2,1
}
8110cf8c:	e037883a 	mov	sp,fp
8110cf90:	dfc00117 	ldw	ra,4(sp)
8110cf94:	df000017 	ldw	fp,0(sp)
8110cf98:	dec00204 	addi	sp,sp,8
8110cf9c:	f800283a 	ret

8110cfa0 <uliSyncGetMbt>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetMbt(void) {
8110cfa0:	defffd04 	addi	sp,sp,-12
8110cfa4:	de00012e 	bgeu	sp,et,8110cfac <uliSyncGetMbt+0xc>
8110cfa8:	003b68fa 	trap	3
8110cfac:	dfc00215 	stw	ra,8(sp)
8110cfb0:	df000115 	stw	fp,4(sp)
8110cfb4:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_MBT_REG_OFFSET);
8110cfb8:	01000104 	movi	r4,4
8110cfbc:	110da3c0 	call	8110da3c <uliSyncReadReg>
8110cfc0:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110cfc4:	e0bfff17 	ldw	r2,-4(fp)
}
8110cfc8:	e037883a 	mov	sp,fp
8110cfcc:	dfc00117 	ldw	ra,4(sp)
8110cfd0:	df000017 	ldw	fp,0(sp)
8110cfd4:	dec00204 	addi	sp,sp,8
8110cfd8:	f800283a 	ret

8110cfdc <uliSyncGetBt>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetBt(void) {
8110cfdc:	defffd04 	addi	sp,sp,-12
8110cfe0:	de00012e 	bgeu	sp,et,8110cfe8 <uliSyncGetBt+0xc>
8110cfe4:	003b68fa 	trap	3
8110cfe8:	dfc00215 	stw	ra,8(sp)
8110cfec:	df000115 	stw	fp,4(sp)
8110cff0:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_BT_REG_OFFSET);
8110cff4:	01000144 	movi	r4,5
8110cff8:	110da3c0 	call	8110da3c <uliSyncReadReg>
8110cffc:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110d000:	e0bfff17 	ldw	r2,-4(fp)
}
8110d004:	e037883a 	mov	sp,fp
8110d008:	dfc00117 	ldw	ra,4(sp)
8110d00c:	df000017 	ldw	fp,0(sp)
8110d010:	dec00204 	addi	sp,sp,8
8110d014:	f800283a 	ret

8110d018 <uliSyncGetPer>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetPer(void) {
8110d018:	defffd04 	addi	sp,sp,-12
8110d01c:	de00012e 	bgeu	sp,et,8110d024 <uliSyncGetPer+0xc>
8110d020:	003b68fa 	trap	3
8110d024:	dfc00215 	stw	ra,8(sp)
8110d028:	df000115 	stw	fp,4(sp)
8110d02c:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_PER_REG_OFFSET);
8110d030:	01000184 	movi	r4,6
8110d034:	110da3c0 	call	8110da3c <uliSyncReadReg>
8110d038:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110d03c:	e0bfff17 	ldw	r2,-4(fp)
}
8110d040:	e037883a 	mov	sp,fp
8110d044:	dfc00117 	ldw	ra,4(sp)
8110d048:	df000017 	ldw	fp,0(sp)
8110d04c:	dec00204 	addi	sp,sp,8
8110d050:	f800283a 	ret

8110d054 <uliSyncGetOst>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetOst(void) {
8110d054:	defffd04 	addi	sp,sp,-12
8110d058:	de00012e 	bgeu	sp,et,8110d060 <uliSyncGetOst+0xc>
8110d05c:	003b68fa 	trap	3
8110d060:	dfc00215 	stw	ra,8(sp)
8110d064:	df000115 	stw	fp,4(sp)
8110d068:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_OST_REG_OFFSET);
8110d06c:	010001c4 	movi	r4,7
8110d070:	110da3c0 	call	8110da3c <uliSyncReadReg>
8110d074:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110d078:	e0bfff17 	ldw	r2,-4(fp)
}
8110d07c:	e037883a 	mov	sp,fp
8110d080:	dfc00117 	ldw	ra,4(sp)
8110d084:	df000017 	ldw	fp,0(sp)
8110d088:	dec00204 	addi	sp,sp,8
8110d08c:	f800283a 	ret

8110d090 <uliSyncGetGeneral>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetGeneral(void) {
8110d090:	defffd04 	addi	sp,sp,-12
8110d094:	de00012e 	bgeu	sp,et,8110d09c <uliSyncGetGeneral+0xc>
8110d098:	003b68fa 	trap	3
8110d09c:	dfc00215 	stw	ra,8(sp)
8110d0a0:	df000115 	stw	fp,4(sp)
8110d0a4:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110d0a8:	01000204 	movi	r4,8
8110d0ac:	110da3c0 	call	8110da3c <uliSyncReadReg>
8110d0b0:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110d0b4:	e0bfff17 	ldw	r2,-4(fp)
}
8110d0b8:	e037883a 	mov	sp,fp
8110d0bc:	dfc00117 	ldw	ra,4(sp)
8110d0c0:	df000017 	ldw	fp,0(sp)
8110d0c4:	dec00204 	addi	sp,sp,8
8110d0c8:	f800283a 	ret

8110d0cc <bSyncErrInj>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncErrInj(alt_u32 uliValue) {
8110d0cc:	defffd04 	addi	sp,sp,-12
8110d0d0:	de00012e 	bgeu	sp,et,8110d0d8 <bSyncErrInj+0xc>
8110d0d4:	003b68fa 	trap	3
8110d0d8:	dfc00215 	stw	ra,8(sp)
8110d0dc:	df000115 	stw	fp,4(sp)
8110d0e0:	df000104 	addi	fp,sp,4
8110d0e4:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_ERR_INJ_REG_OFFSET, uliValue);
8110d0e8:	e17fff17 	ldw	r5,-4(fp)
8110d0ec:	01000244 	movi	r4,9
8110d0f0:	110d9e00 	call	8110d9e0 <bSyncWriteReg>
	return TRUE;
8110d0f4:	00800044 	movi	r2,1
}
8110d0f8:	e037883a 	mov	sp,fp
8110d0fc:	dfc00117 	ldw	ra,4(sp)
8110d100:	df000017 	ldw	fp,0(sp)
8110d104:	dec00204 	addi	sp,sp,8
8110d108:	f800283a 	ret

8110d10c <bSyncCtrExtnIrq>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrExtnIrq(bool bValue) {
8110d10c:	defffc04 	addi	sp,sp,-16
8110d110:	de00012e 	bgeu	sp,et,8110d118 <bSyncCtrExtnIrq+0xc>
8110d114:	003b68fa 	trap	3
8110d118:	dfc00315 	stw	ra,12(sp)
8110d11c:	df000215 	stw	fp,8(sp)
8110d120:	df000204 	addi	fp,sp,8
8110d124:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d128:	01000284 	movi	r4,10
8110d12c:	110da3c0 	call	8110da3c <uliSyncReadReg>
8110d130:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d134:	e0bfff17 	ldw	r2,-4(fp)
8110d138:	1000061e 	bne	r2,zero,8110d154 <bSyncCtrExtnIrq+0x48>
		uliAux &= ~SYNC_CTR_EXTN_INT_MSK;
8110d13c:	e0fffe17 	ldw	r3,-8(fp)
8110d140:	00a00034 	movhi	r2,32768
8110d144:	10bfffc4 	addi	r2,r2,-1
8110d148:	1884703a 	and	r2,r3,r2
8110d14c:	e0bffe15 	stw	r2,-8(fp)
8110d150:	00000306 	br	8110d160 <bSyncCtrExtnIrq+0x54>
	} else {
		uliAux |= SYNC_CTR_EXTN_INT_MSK;
8110d154:	e0bffe17 	ldw	r2,-8(fp)
8110d158:	10a00034 	orhi	r2,r2,32768
8110d15c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d160:	e17ffe17 	ldw	r5,-8(fp)
8110d164:	01000284 	movi	r4,10
8110d168:	110d9e00 	call	8110d9e0 <bSyncWriteReg>
	return TRUE;
8110d16c:	00800044 	movi	r2,1
}
8110d170:	e037883a 	mov	sp,fp
8110d174:	dfc00117 	ldw	ra,4(sp)
8110d178:	df000017 	ldw	fp,0(sp)
8110d17c:	dec00204 	addi	sp,sp,8
8110d180:	f800283a 	ret

8110d184 <bSyncCtrStart>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrStart(void) {
8110d184:	defffd04 	addi	sp,sp,-12
8110d188:	de00012e 	bgeu	sp,et,8110d190 <bSyncCtrStart+0xc>
8110d18c:	003b68fa 	trap	3
8110d190:	dfc00215 	stw	ra,8(sp)
8110d194:	df000115 	stw	fp,4(sp)
8110d198:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d19c:	01000284 	movi	r4,10
8110d1a0:	110da3c0 	call	8110da3c <uliSyncReadReg>
8110d1a4:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_START_MSK;
8110d1a8:	e0bfff17 	ldw	r2,-4(fp)
8110d1ac:	10800234 	orhi	r2,r2,8
8110d1b0:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d1b4:	e17fff17 	ldw	r5,-4(fp)
8110d1b8:	01000284 	movi	r4,10
8110d1bc:	110d9e00 	call	8110d9e0 <bSyncWriteReg>
	return TRUE;
8110d1c0:	00800044 	movi	r2,1
}
8110d1c4:	e037883a 	mov	sp,fp
8110d1c8:	dfc00117 	ldw	ra,4(sp)
8110d1cc:	df000017 	ldw	fp,0(sp)
8110d1d0:	dec00204 	addi	sp,sp,8
8110d1d4:	f800283a 	ret

8110d1d8 <bSyncCtrReset>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrReset(void) {
8110d1d8:	defffd04 	addi	sp,sp,-12
8110d1dc:	de00012e 	bgeu	sp,et,8110d1e4 <bSyncCtrReset+0xc>
8110d1e0:	003b68fa 	trap	3
8110d1e4:	dfc00215 	stw	ra,8(sp)
8110d1e8:	df000115 	stw	fp,4(sp)
8110d1ec:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d1f0:	01000284 	movi	r4,10
8110d1f4:	110da3c0 	call	8110da3c <uliSyncReadReg>
8110d1f8:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_RESET_MSK;
8110d1fc:	e0bfff17 	ldw	r2,-4(fp)
8110d200:	10800134 	orhi	r2,r2,4
8110d204:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d208:	e17fff17 	ldw	r5,-4(fp)
8110d20c:	01000284 	movi	r4,10
8110d210:	110d9e00 	call	8110d9e0 <bSyncWriteReg>
	return TRUE;
8110d214:	00800044 	movi	r2,1
}
8110d218:	e037883a 	mov	sp,fp
8110d21c:	dfc00117 	ldw	ra,4(sp)
8110d220:	df000017 	ldw	fp,0(sp)
8110d224:	dec00204 	addi	sp,sp,8
8110d228:	f800283a 	ret

8110d22c <bSyncCtrOneShot>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrOneShot(void) {
8110d22c:	defffd04 	addi	sp,sp,-12
8110d230:	de00012e 	bgeu	sp,et,8110d238 <bSyncCtrOneShot+0xc>
8110d234:	003b68fa 	trap	3
8110d238:	dfc00215 	stw	ra,8(sp)
8110d23c:	df000115 	stw	fp,4(sp)
8110d240:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d244:	01000284 	movi	r4,10
8110d248:	110da3c0 	call	8110da3c <uliSyncReadReg>
8110d24c:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_ONE_SHOT_MSK;
8110d250:	e0bfff17 	ldw	r2,-4(fp)
8110d254:	108000b4 	orhi	r2,r2,2
8110d258:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d25c:	e17fff17 	ldw	r5,-4(fp)
8110d260:	01000284 	movi	r4,10
8110d264:	110d9e00 	call	8110d9e0 <bSyncWriteReg>
	return TRUE;
8110d268:	00800044 	movi	r2,1
}
8110d26c:	e037883a 	mov	sp,fp
8110d270:	dfc00117 	ldw	ra,4(sp)
8110d274:	df000017 	ldw	fp,0(sp)
8110d278:	dec00204 	addi	sp,sp,8
8110d27c:	f800283a 	ret

8110d280 <bSyncCtrErrInj>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrErrInj(void) {
8110d280:	defffd04 	addi	sp,sp,-12
8110d284:	de00012e 	bgeu	sp,et,8110d28c <bSyncCtrErrInj+0xc>
8110d288:	003b68fa 	trap	3
8110d28c:	dfc00215 	stw	ra,8(sp)
8110d290:	df000115 	stw	fp,4(sp)
8110d294:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d298:	01000284 	movi	r4,10
8110d29c:	110da3c0 	call	8110da3c <uliSyncReadReg>
8110d2a0:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_ERR_INJ_MSK;
8110d2a4:	e0bfff17 	ldw	r2,-4(fp)
8110d2a8:	10800074 	orhi	r2,r2,1
8110d2ac:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d2b0:	e17fff17 	ldw	r5,-4(fp)
8110d2b4:	01000284 	movi	r4,10
8110d2b8:	110d9e00 	call	8110d9e0 <bSyncWriteReg>
	return TRUE;
8110d2bc:	00800044 	movi	r2,1
}
8110d2c0:	e037883a 	mov	sp,fp
8110d2c4:	dfc00117 	ldw	ra,4(sp)
8110d2c8:	df000017 	ldw	fp,0(sp)
8110d2cc:	dec00204 	addi	sp,sp,8
8110d2d0:	f800283a 	ret

8110d2d4 <bSyncCtrSyncOutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrSyncOutEnable(bool bValue) {
8110d2d4:	defffc04 	addi	sp,sp,-16
8110d2d8:	de00012e 	bgeu	sp,et,8110d2e0 <bSyncCtrSyncOutEnable+0xc>
8110d2dc:	003b68fa 	trap	3
8110d2e0:	dfc00315 	stw	ra,12(sp)
8110d2e4:	df000215 	stw	fp,8(sp)
8110d2e8:	df000204 	addi	fp,sp,8
8110d2ec:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d2f0:	01000284 	movi	r4,10
8110d2f4:	110da3c0 	call	8110da3c <uliSyncReadReg>
8110d2f8:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d2fc:	e0bfff17 	ldw	r2,-4(fp)
8110d300:	1000051e 	bne	r2,zero,8110d318 <bSyncCtrSyncOutEnable+0x44>
		uliAux &= ~SYNC_CTR_SYNC_OUT_EN_MSK;
8110d304:	e0fffe17 	ldw	r3,-8(fp)
8110d308:	00bfbfc4 	movi	r2,-257
8110d30c:	1884703a 	and	r2,r3,r2
8110d310:	e0bffe15 	stw	r2,-8(fp)
8110d314:	00000306 	br	8110d324 <bSyncCtrSyncOutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_SYNC_OUT_EN_MSK;
8110d318:	e0bffe17 	ldw	r2,-8(fp)
8110d31c:	10804014 	ori	r2,r2,256
8110d320:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d324:	e17ffe17 	ldw	r5,-8(fp)
8110d328:	01000284 	movi	r4,10
8110d32c:	110d9e00 	call	8110d9e0 <bSyncWriteReg>
	return TRUE;
8110d330:	00800044 	movi	r2,1
}
8110d334:	e037883a 	mov	sp,fp
8110d338:	dfc00117 	ldw	ra,4(sp)
8110d33c:	df000017 	ldw	fp,0(sp)
8110d340:	dec00204 	addi	sp,sp,8
8110d344:	f800283a 	ret

8110d348 <bSyncCtrCh1OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh1OutEnable(bool bValue) {
8110d348:	defffc04 	addi	sp,sp,-16
8110d34c:	de00012e 	bgeu	sp,et,8110d354 <bSyncCtrCh1OutEnable+0xc>
8110d350:	003b68fa 	trap	3
8110d354:	dfc00315 	stw	ra,12(sp)
8110d358:	df000215 	stw	fp,8(sp)
8110d35c:	df000204 	addi	fp,sp,8
8110d360:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d364:	01000284 	movi	r4,10
8110d368:	110da3c0 	call	8110da3c <uliSyncReadReg>
8110d36c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d370:	e0bfff17 	ldw	r2,-4(fp)
8110d374:	1000051e 	bne	r2,zero,8110d38c <bSyncCtrCh1OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHA_EN_MSK;
8110d378:	e0fffe17 	ldw	r3,-8(fp)
8110d37c:	00bfff84 	movi	r2,-2
8110d380:	1884703a 	and	r2,r3,r2
8110d384:	e0bffe15 	stw	r2,-8(fp)
8110d388:	00000306 	br	8110d398 <bSyncCtrCh1OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHA_EN_MSK;
8110d38c:	e0bffe17 	ldw	r2,-8(fp)
8110d390:	10800054 	ori	r2,r2,1
8110d394:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d398:	e17ffe17 	ldw	r5,-8(fp)
8110d39c:	01000284 	movi	r4,10
8110d3a0:	110d9e00 	call	8110d9e0 <bSyncWriteReg>
	return TRUE;
8110d3a4:	00800044 	movi	r2,1
}
8110d3a8:	e037883a 	mov	sp,fp
8110d3ac:	dfc00117 	ldw	ra,4(sp)
8110d3b0:	df000017 	ldw	fp,0(sp)
8110d3b4:	dec00204 	addi	sp,sp,8
8110d3b8:	f800283a 	ret

8110d3bc <bSyncCtrCh2OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh2OutEnable(bool bValue) {
8110d3bc:	defffc04 	addi	sp,sp,-16
8110d3c0:	de00012e 	bgeu	sp,et,8110d3c8 <bSyncCtrCh2OutEnable+0xc>
8110d3c4:	003b68fa 	trap	3
8110d3c8:	dfc00315 	stw	ra,12(sp)
8110d3cc:	df000215 	stw	fp,8(sp)
8110d3d0:	df000204 	addi	fp,sp,8
8110d3d4:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d3d8:	01000284 	movi	r4,10
8110d3dc:	110da3c0 	call	8110da3c <uliSyncReadReg>
8110d3e0:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d3e4:	e0bfff17 	ldw	r2,-4(fp)
8110d3e8:	1000051e 	bne	r2,zero,8110d400 <bSyncCtrCh2OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHB_EN_MSK;
8110d3ec:	e0fffe17 	ldw	r3,-8(fp)
8110d3f0:	00bfff44 	movi	r2,-3
8110d3f4:	1884703a 	and	r2,r3,r2
8110d3f8:	e0bffe15 	stw	r2,-8(fp)
8110d3fc:	00000306 	br	8110d40c <bSyncCtrCh2OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHB_EN_MSK;
8110d400:	e0bffe17 	ldw	r2,-8(fp)
8110d404:	10800094 	ori	r2,r2,2
8110d408:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d40c:	e17ffe17 	ldw	r5,-8(fp)
8110d410:	01000284 	movi	r4,10
8110d414:	110d9e00 	call	8110d9e0 <bSyncWriteReg>
	return TRUE;
8110d418:	00800044 	movi	r2,1
}
8110d41c:	e037883a 	mov	sp,fp
8110d420:	dfc00117 	ldw	ra,4(sp)
8110d424:	df000017 	ldw	fp,0(sp)
8110d428:	dec00204 	addi	sp,sp,8
8110d42c:	f800283a 	ret

8110d430 <bSyncCtrCh3OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh3OutEnable(bool bValue) {
8110d430:	defffc04 	addi	sp,sp,-16
8110d434:	de00012e 	bgeu	sp,et,8110d43c <bSyncCtrCh3OutEnable+0xc>
8110d438:	003b68fa 	trap	3
8110d43c:	dfc00315 	stw	ra,12(sp)
8110d440:	df000215 	stw	fp,8(sp)
8110d444:	df000204 	addi	fp,sp,8
8110d448:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d44c:	01000284 	movi	r4,10
8110d450:	110da3c0 	call	8110da3c <uliSyncReadReg>
8110d454:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d458:	e0bfff17 	ldw	r2,-4(fp)
8110d45c:	1000051e 	bne	r2,zero,8110d474 <bSyncCtrCh3OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHC_EN_MSK;
8110d460:	e0fffe17 	ldw	r3,-8(fp)
8110d464:	00bffec4 	movi	r2,-5
8110d468:	1884703a 	and	r2,r3,r2
8110d46c:	e0bffe15 	stw	r2,-8(fp)
8110d470:	00000306 	br	8110d480 <bSyncCtrCh3OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHC_EN_MSK;
8110d474:	e0bffe17 	ldw	r2,-8(fp)
8110d478:	10800114 	ori	r2,r2,4
8110d47c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d480:	e17ffe17 	ldw	r5,-8(fp)
8110d484:	01000284 	movi	r4,10
8110d488:	110d9e00 	call	8110d9e0 <bSyncWriteReg>
	return TRUE;
8110d48c:	00800044 	movi	r2,1
}
8110d490:	e037883a 	mov	sp,fp
8110d494:	dfc00117 	ldw	ra,4(sp)
8110d498:	df000017 	ldw	fp,0(sp)
8110d49c:	dec00204 	addi	sp,sp,8
8110d4a0:	f800283a 	ret

8110d4a4 <bSyncCtrCh4OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh4OutEnable(bool bValue) {
8110d4a4:	defffc04 	addi	sp,sp,-16
8110d4a8:	de00012e 	bgeu	sp,et,8110d4b0 <bSyncCtrCh4OutEnable+0xc>
8110d4ac:	003b68fa 	trap	3
8110d4b0:	dfc00315 	stw	ra,12(sp)
8110d4b4:	df000215 	stw	fp,8(sp)
8110d4b8:	df000204 	addi	fp,sp,8
8110d4bc:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d4c0:	01000284 	movi	r4,10
8110d4c4:	110da3c0 	call	8110da3c <uliSyncReadReg>
8110d4c8:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d4cc:	e0bfff17 	ldw	r2,-4(fp)
8110d4d0:	1000051e 	bne	r2,zero,8110d4e8 <bSyncCtrCh4OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHD_EN_MSK;
8110d4d4:	e0fffe17 	ldw	r3,-8(fp)
8110d4d8:	00bffdc4 	movi	r2,-9
8110d4dc:	1884703a 	and	r2,r3,r2
8110d4e0:	e0bffe15 	stw	r2,-8(fp)
8110d4e4:	00000306 	br	8110d4f4 <bSyncCtrCh4OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHD_EN_MSK;
8110d4e8:	e0bffe17 	ldw	r2,-8(fp)
8110d4ec:	10800214 	ori	r2,r2,8
8110d4f0:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d4f4:	e17ffe17 	ldw	r5,-8(fp)
8110d4f8:	01000284 	movi	r4,10
8110d4fc:	110d9e00 	call	8110d9e0 <bSyncWriteReg>
	return TRUE;
8110d500:	00800044 	movi	r2,1
}
8110d504:	e037883a 	mov	sp,fp
8110d508:	dfc00117 	ldw	ra,4(sp)
8110d50c:	df000017 	ldw	fp,0(sp)
8110d510:	dec00204 	addi	sp,sp,8
8110d514:	f800283a 	ret

8110d518 <bSyncCtrCh5OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh5OutEnable(bool bValue) {
8110d518:	defffc04 	addi	sp,sp,-16
8110d51c:	de00012e 	bgeu	sp,et,8110d524 <bSyncCtrCh5OutEnable+0xc>
8110d520:	003b68fa 	trap	3
8110d524:	dfc00315 	stw	ra,12(sp)
8110d528:	df000215 	stw	fp,8(sp)
8110d52c:	df000204 	addi	fp,sp,8
8110d530:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d534:	01000284 	movi	r4,10
8110d538:	110da3c0 	call	8110da3c <uliSyncReadReg>
8110d53c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d540:	e0bfff17 	ldw	r2,-4(fp)
8110d544:	1000051e 	bne	r2,zero,8110d55c <bSyncCtrCh5OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHE_EN_MSK;
8110d548:	e0fffe17 	ldw	r3,-8(fp)
8110d54c:	00bffbc4 	movi	r2,-17
8110d550:	1884703a 	and	r2,r3,r2
8110d554:	e0bffe15 	stw	r2,-8(fp)
8110d558:	00000306 	br	8110d568 <bSyncCtrCh5OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHE_EN_MSK;
8110d55c:	e0bffe17 	ldw	r2,-8(fp)
8110d560:	10800414 	ori	r2,r2,16
8110d564:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d568:	e17ffe17 	ldw	r5,-8(fp)
8110d56c:	01000284 	movi	r4,10
8110d570:	110d9e00 	call	8110d9e0 <bSyncWriteReg>
	return TRUE;
8110d574:	00800044 	movi	r2,1
}
8110d578:	e037883a 	mov	sp,fp
8110d57c:	dfc00117 	ldw	ra,4(sp)
8110d580:	df000017 	ldw	fp,0(sp)
8110d584:	dec00204 	addi	sp,sp,8
8110d588:	f800283a 	ret

8110d58c <bSyncCtrCh6OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh6OutEnable(bool bValue) {
8110d58c:	defffc04 	addi	sp,sp,-16
8110d590:	de00012e 	bgeu	sp,et,8110d598 <bSyncCtrCh6OutEnable+0xc>
8110d594:	003b68fa 	trap	3
8110d598:	dfc00315 	stw	ra,12(sp)
8110d59c:	df000215 	stw	fp,8(sp)
8110d5a0:	df000204 	addi	fp,sp,8
8110d5a4:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d5a8:	01000284 	movi	r4,10
8110d5ac:	110da3c0 	call	8110da3c <uliSyncReadReg>
8110d5b0:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d5b4:	e0bfff17 	ldw	r2,-4(fp)
8110d5b8:	1000051e 	bne	r2,zero,8110d5d0 <bSyncCtrCh6OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHF_EN_MSK;
8110d5bc:	e0fffe17 	ldw	r3,-8(fp)
8110d5c0:	00bff7c4 	movi	r2,-33
8110d5c4:	1884703a 	and	r2,r3,r2
8110d5c8:	e0bffe15 	stw	r2,-8(fp)
8110d5cc:	00000306 	br	8110d5dc <bSyncCtrCh6OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHF_EN_MSK;
8110d5d0:	e0bffe17 	ldw	r2,-8(fp)
8110d5d4:	10800814 	ori	r2,r2,32
8110d5d8:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d5dc:	e17ffe17 	ldw	r5,-8(fp)
8110d5e0:	01000284 	movi	r4,10
8110d5e4:	110d9e00 	call	8110d9e0 <bSyncWriteReg>
	return TRUE;
8110d5e8:	00800044 	movi	r2,1
}
8110d5ec:	e037883a 	mov	sp,fp
8110d5f0:	dfc00117 	ldw	ra,4(sp)
8110d5f4:	df000017 	ldw	fp,0(sp)
8110d5f8:	dec00204 	addi	sp,sp,8
8110d5fc:	f800283a 	ret

8110d600 <bSyncCtrCh7OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh7OutEnable(bool bValue) {
8110d600:	defffc04 	addi	sp,sp,-16
8110d604:	de00012e 	bgeu	sp,et,8110d60c <bSyncCtrCh7OutEnable+0xc>
8110d608:	003b68fa 	trap	3
8110d60c:	dfc00315 	stw	ra,12(sp)
8110d610:	df000215 	stw	fp,8(sp)
8110d614:	df000204 	addi	fp,sp,8
8110d618:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d61c:	01000284 	movi	r4,10
8110d620:	110da3c0 	call	8110da3c <uliSyncReadReg>
8110d624:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d628:	e0bfff17 	ldw	r2,-4(fp)
8110d62c:	1000051e 	bne	r2,zero,8110d644 <bSyncCtrCh7OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHG_EN_MSK;
8110d630:	e0fffe17 	ldw	r3,-8(fp)
8110d634:	00bfefc4 	movi	r2,-65
8110d638:	1884703a 	and	r2,r3,r2
8110d63c:	e0bffe15 	stw	r2,-8(fp)
8110d640:	00000306 	br	8110d650 <bSyncCtrCh7OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHG_EN_MSK;
8110d644:	e0bffe17 	ldw	r2,-8(fp)
8110d648:	10801014 	ori	r2,r2,64
8110d64c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d650:	e17ffe17 	ldw	r5,-8(fp)
8110d654:	01000284 	movi	r4,10
8110d658:	110d9e00 	call	8110d9e0 <bSyncWriteReg>
	return TRUE;
8110d65c:	00800044 	movi	r2,1
}
8110d660:	e037883a 	mov	sp,fp
8110d664:	dfc00117 	ldw	ra,4(sp)
8110d668:	df000017 	ldw	fp,0(sp)
8110d66c:	dec00204 	addi	sp,sp,8
8110d670:	f800283a 	ret

8110d674 <bSyncCtrCh8OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh8OutEnable(bool bValue) {
8110d674:	defffc04 	addi	sp,sp,-16
8110d678:	de00012e 	bgeu	sp,et,8110d680 <bSyncCtrCh8OutEnable+0xc>
8110d67c:	003b68fa 	trap	3
8110d680:	dfc00315 	stw	ra,12(sp)
8110d684:	df000215 	stw	fp,8(sp)
8110d688:	df000204 	addi	fp,sp,8
8110d68c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d690:	01000284 	movi	r4,10
8110d694:	110da3c0 	call	8110da3c <uliSyncReadReg>
8110d698:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d69c:	e0bfff17 	ldw	r2,-4(fp)
8110d6a0:	1000051e 	bne	r2,zero,8110d6b8 <bSyncCtrCh8OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHH_EN_MSK;
8110d6a4:	e0fffe17 	ldw	r3,-8(fp)
8110d6a8:	00bfdfc4 	movi	r2,-129
8110d6ac:	1884703a 	and	r2,r3,r2
8110d6b0:	e0bffe15 	stw	r2,-8(fp)
8110d6b4:	00000306 	br	8110d6c4 <bSyncCtrCh8OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHH_EN_MSK;
8110d6b8:	e0bffe17 	ldw	r2,-8(fp)
8110d6bc:	10802014 	ori	r2,r2,128
8110d6c0:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d6c4:	e17ffe17 	ldw	r5,-8(fp)
8110d6c8:	01000284 	movi	r4,10
8110d6cc:	110d9e00 	call	8110d9e0 <bSyncWriteReg>
	return TRUE;
8110d6d0:	00800044 	movi	r2,1
}
8110d6d4:	e037883a 	mov	sp,fp
8110d6d8:	dfc00117 	ldw	ra,4(sp)
8110d6dc:	df000017 	ldw	fp,0(sp)
8110d6e0:	dec00204 	addi	sp,sp,8
8110d6e4:	f800283a 	ret

8110d6e8 <bSyncIrqEnableError>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqEnableError(bool bValue) {
8110d6e8:	defffc04 	addi	sp,sp,-16
8110d6ec:	de00012e 	bgeu	sp,et,8110d6f4 <bSyncIrqEnableError+0xc>
8110d6f0:	003b68fa 	trap	3
8110d6f4:	dfc00315 	stw	ra,12(sp)
8110d6f8:	df000215 	stw	fp,8(sp)
8110d6fc:	df000204 	addi	fp,sp,8
8110d700:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_ENABLE_REG_OFFSET);
8110d704:	01000044 	movi	r4,1
8110d708:	110da3c0 	call	8110da3c <uliSyncReadReg>
8110d70c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d710:	e0bfff17 	ldw	r2,-4(fp)
8110d714:	1000051e 	bne	r2,zero,8110d72c <bSyncIrqEnableError+0x44>
		uliAux &= ~SYNC_IRQ_ENABLE_ERROR_MSK;
8110d718:	e0fffe17 	ldw	r3,-8(fp)
8110d71c:	00bfff44 	movi	r2,-3
8110d720:	1884703a 	and	r2,r3,r2
8110d724:	e0bffe15 	stw	r2,-8(fp)
8110d728:	00000306 	br	8110d738 <bSyncIrqEnableError+0x50>
	} else {
		uliAux |= SYNC_IRQ_ENABLE_ERROR_MSK;
8110d72c:	e0bffe17 	ldw	r2,-8(fp)
8110d730:	10800094 	ori	r2,r2,2
8110d734:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_ENABLE_REG_OFFSET, uliAux);
8110d738:	e17ffe17 	ldw	r5,-8(fp)
8110d73c:	01000044 	movi	r4,1
8110d740:	110d9e00 	call	8110d9e0 <bSyncWriteReg>
	return TRUE;
8110d744:	00800044 	movi	r2,1
}
8110d748:	e037883a 	mov	sp,fp
8110d74c:	dfc00117 	ldw	ra,4(sp)
8110d750:	df000017 	ldw	fp,0(sp)
8110d754:	dec00204 	addi	sp,sp,8
8110d758:	f800283a 	ret

8110d75c <bSyncIrqEnableBlank>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqEnableBlank(bool bValue) {
8110d75c:	defffc04 	addi	sp,sp,-16
8110d760:	de00012e 	bgeu	sp,et,8110d768 <bSyncIrqEnableBlank+0xc>
8110d764:	003b68fa 	trap	3
8110d768:	dfc00315 	stw	ra,12(sp)
8110d76c:	df000215 	stw	fp,8(sp)
8110d770:	df000204 	addi	fp,sp,8
8110d774:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_ENABLE_REG_OFFSET);
8110d778:	01000044 	movi	r4,1
8110d77c:	110da3c0 	call	8110da3c <uliSyncReadReg>
8110d780:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d784:	e0bfff17 	ldw	r2,-4(fp)
8110d788:	1000051e 	bne	r2,zero,8110d7a0 <bSyncIrqEnableBlank+0x44>
		uliAux &= ~SYNC_IRQ_ENABLE_BLANK_MSK;
8110d78c:	e0fffe17 	ldw	r3,-8(fp)
8110d790:	00bfff84 	movi	r2,-2
8110d794:	1884703a 	and	r2,r3,r2
8110d798:	e0bffe15 	stw	r2,-8(fp)
8110d79c:	00000306 	br	8110d7ac <bSyncIrqEnableBlank+0x50>
	} else {
		uliAux |= SYNC_IRQ_ENABLE_BLANK_MSK;
8110d7a0:	e0bffe17 	ldw	r2,-8(fp)
8110d7a4:	10800054 	ori	r2,r2,1
8110d7a8:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_ENABLE_REG_OFFSET, uliAux);
8110d7ac:	e17ffe17 	ldw	r5,-8(fp)
8110d7b0:	01000044 	movi	r4,1
8110d7b4:	110d9e00 	call	8110d9e0 <bSyncWriteReg>
	return TRUE;
8110d7b8:	00800044 	movi	r2,1
}
8110d7bc:	e037883a 	mov	sp,fp
8110d7c0:	dfc00117 	ldw	ra,4(sp)
8110d7c4:	df000017 	ldw	fp,0(sp)
8110d7c8:	dec00204 	addi	sp,sp,8
8110d7cc:	f800283a 	ret

8110d7d0 <bSyncIrqFlagClrError>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqFlagClrError(bool bValue) {
8110d7d0:	defffc04 	addi	sp,sp,-16
8110d7d4:	de00012e 	bgeu	sp,et,8110d7dc <bSyncIrqFlagClrError+0xc>
8110d7d8:	003b68fa 	trap	3
8110d7dc:	dfc00315 	stw	ra,12(sp)
8110d7e0:	df000215 	stw	fp,8(sp)
8110d7e4:	df000204 	addi	fp,sp,8
8110d7e8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET);
8110d7ec:	01000084 	movi	r4,2
8110d7f0:	110da3c0 	call	8110da3c <uliSyncReadReg>
8110d7f4:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d7f8:	e0bfff17 	ldw	r2,-4(fp)
8110d7fc:	1000051e 	bne	r2,zero,8110d814 <bSyncIrqFlagClrError+0x44>
		uliAux &= ~SYNC_IRQ_FLAG_CLR_ERROR_MSK;
8110d800:	e0fffe17 	ldw	r3,-8(fp)
8110d804:	00bfff44 	movi	r2,-3
8110d808:	1884703a 	and	r2,r3,r2
8110d80c:	e0bffe15 	stw	r2,-8(fp)
8110d810:	00000306 	br	8110d820 <bSyncIrqFlagClrError+0x50>
	} else {
		uliAux |= SYNC_IRQ_FLAG_CLR_ERROR_MSK;
8110d814:	e0bffe17 	ldw	r2,-8(fp)
8110d818:	10800094 	ori	r2,r2,2
8110d81c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET, uliAux);
8110d820:	e17ffe17 	ldw	r5,-8(fp)
8110d824:	01000084 	movi	r4,2
8110d828:	110d9e00 	call	8110d9e0 <bSyncWriteReg>
	return TRUE;
8110d82c:	00800044 	movi	r2,1
}
8110d830:	e037883a 	mov	sp,fp
8110d834:	dfc00117 	ldw	ra,4(sp)
8110d838:	df000017 	ldw	fp,0(sp)
8110d83c:	dec00204 	addi	sp,sp,8
8110d840:	f800283a 	ret

8110d844 <bSyncIrqFlagClrBlank>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqFlagClrBlank(bool bValue) {
8110d844:	defffc04 	addi	sp,sp,-16
8110d848:	de00012e 	bgeu	sp,et,8110d850 <bSyncIrqFlagClrBlank+0xc>
8110d84c:	003b68fa 	trap	3
8110d850:	dfc00315 	stw	ra,12(sp)
8110d854:	df000215 	stw	fp,8(sp)
8110d858:	df000204 	addi	fp,sp,8
8110d85c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET);
8110d860:	01000084 	movi	r4,2
8110d864:	110da3c0 	call	8110da3c <uliSyncReadReg>
8110d868:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d86c:	e0bfff17 	ldw	r2,-4(fp)
8110d870:	1000051e 	bne	r2,zero,8110d888 <bSyncIrqFlagClrBlank+0x44>
		uliAux &= ~SYNC_IRQ_FLAG_CLR_BLANK_MSK;
8110d874:	e0fffe17 	ldw	r3,-8(fp)
8110d878:	00bfff84 	movi	r2,-2
8110d87c:	1884703a 	and	r2,r3,r2
8110d880:	e0bffe15 	stw	r2,-8(fp)
8110d884:	00000306 	br	8110d894 <bSyncIrqFlagClrBlank+0x50>
	} else {
		uliAux |= SYNC_IRQ_FLAG_CLR_BLANK_MSK;
8110d888:	e0bffe17 	ldw	r2,-8(fp)
8110d88c:	10800054 	ori	r2,r2,1
8110d890:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET, uliAux);
8110d894:	e17ffe17 	ldw	r5,-8(fp)
8110d898:	01000084 	movi	r4,2
8110d89c:	110d9e00 	call	8110d9e0 <bSyncWriteReg>
	return TRUE;
8110d8a0:	00800044 	movi	r2,1
}
8110d8a4:	e037883a 	mov	sp,fp
8110d8a8:	dfc00117 	ldw	ra,4(sp)
8110d8ac:	df000017 	ldw	fp,0(sp)
8110d8b0:	dec00204 	addi	sp,sp,8
8110d8b4:	f800283a 	ret

8110d8b8 <bSyncIrqFlagError>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncIrqFlagError(void) {
8110d8b8:	defffc04 	addi	sp,sp,-16
8110d8bc:	de00012e 	bgeu	sp,et,8110d8c4 <bSyncIrqFlagError+0xc>
8110d8c0:	003b68fa 	trap	3
8110d8c4:	dfc00315 	stw	ra,12(sp)
8110d8c8:	df000215 	stw	fp,8(sp)
8110d8cc:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_REG_OFFSET);
8110d8d0:	010000c4 	movi	r4,3
8110d8d4:	110da3c0 	call	8110da3c <uliSyncReadReg>
8110d8d8:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_IRQ_FLAG_ERROR_MSK) {
8110d8dc:	e0bfff17 	ldw	r2,-4(fp)
8110d8e0:	1080008c 	andi	r2,r2,2
8110d8e4:	10000326 	beq	r2,zero,8110d8f4 <bSyncIrqFlagError+0x3c>
		bResult = TRUE;
8110d8e8:	00800044 	movi	r2,1
8110d8ec:	e0bffe15 	stw	r2,-8(fp)
8110d8f0:	00000106 	br	8110d8f8 <bSyncIrqFlagError+0x40>
	} else {
		bResult = FALSE;
8110d8f4:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110d8f8:	e0bffe17 	ldw	r2,-8(fp)
}
8110d8fc:	e037883a 	mov	sp,fp
8110d900:	dfc00117 	ldw	ra,4(sp)
8110d904:	df000017 	ldw	fp,0(sp)
8110d908:	dec00204 	addi	sp,sp,8
8110d90c:	f800283a 	ret

8110d910 <bSyncIrqFlagBlank>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncIrqFlagBlank(void) {
8110d910:	defffc04 	addi	sp,sp,-16
8110d914:	de00012e 	bgeu	sp,et,8110d91c <bSyncIrqFlagBlank+0xc>
8110d918:	003b68fa 	trap	3
8110d91c:	dfc00315 	stw	ra,12(sp)
8110d920:	df000215 	stw	fp,8(sp)
8110d924:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_REG_OFFSET);
8110d928:	010000c4 	movi	r4,3
8110d92c:	110da3c0 	call	8110da3c <uliSyncReadReg>
8110d930:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_IRQ_FLAG_BLANK_MSK) {
8110d934:	e0bfff17 	ldw	r2,-4(fp)
8110d938:	1080004c 	andi	r2,r2,1
8110d93c:	10000326 	beq	r2,zero,8110d94c <bSyncIrqFlagBlank+0x3c>
		bResult = TRUE;
8110d940:	00800044 	movi	r2,1
8110d944:	e0bffe15 	stw	r2,-8(fp)
8110d948:	00000106 	br	8110d950 <bSyncIrqFlagBlank+0x40>
	} else {
		bResult = FALSE;
8110d94c:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110d950:	e0bffe17 	ldw	r2,-8(fp)
}
8110d954:	e037883a 	mov	sp,fp
8110d958:	dfc00117 	ldw	ra,4(sp)
8110d95c:	df000017 	ldw	fp,0(sp)
8110d960:	dec00204 	addi	sp,sp,8
8110d964:	f800283a 	ret

8110d968 <uliSyncGetCtr>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetCtr(void) {
8110d968:	defffd04 	addi	sp,sp,-12
8110d96c:	de00012e 	bgeu	sp,et,8110d974 <uliSyncGetCtr+0xc>
8110d970:	003b68fa 	trap	3
8110d974:	dfc00215 	stw	ra,8(sp)
8110d978:	df000115 	stw	fp,4(sp)
8110d97c:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d980:	01000284 	movi	r4,10
8110d984:	110da3c0 	call	8110da3c <uliSyncReadReg>
8110d988:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110d98c:	e0bfff17 	ldw	r2,-4(fp)
}
8110d990:	e037883a 	mov	sp,fp
8110d994:	dfc00117 	ldw	ra,4(sp)
8110d998:	df000017 	ldw	fp,0(sp)
8110d99c:	dec00204 	addi	sp,sp,8
8110d9a0:	f800283a 	ret

8110d9a4 <uliSyncReadStatus>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncReadStatus(void) {
8110d9a4:	defffd04 	addi	sp,sp,-12
8110d9a8:	de00012e 	bgeu	sp,et,8110d9b0 <uliSyncReadStatus+0xc>
8110d9ac:	003b68fa 	trap	3
8110d9b0:	dfc00215 	stw	ra,8(sp)
8110d9b4:	df000115 	stw	fp,4(sp)
8110d9b8:	df000104 	addi	fp,sp,4
	alt_u32 aux;

	aux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110d9bc:	0009883a 	mov	r4,zero
8110d9c0:	110da3c0 	call	8110da3c <uliSyncReadReg>
8110d9c4:	e0bfff15 	stw	r2,-4(fp)
	return aux;
8110d9c8:	e0bfff17 	ldw	r2,-4(fp)
}
8110d9cc:	e037883a 	mov	sp,fp
8110d9d0:	dfc00117 	ldw	ra,4(sp)
8110d9d4:	df000017 	ldw	fp,0(sp)
8110d9d8:	dec00204 	addi	sp,sp,8
8110d9dc:	f800283a 	ret

8110d9e0 <bSyncWriteReg>:
 * @param [in] alt_u32 offset
 * @param [in] alt_u32 value
 *
 * @retval TRUE -> success
 */
bool bSyncWriteReg(alt_u32 uliOffset, alt_u32 uliValue) {
8110d9e0:	defffc04 	addi	sp,sp,-16
8110d9e4:	de00012e 	bgeu	sp,et,8110d9ec <bSyncWriteReg+0xc>
8110d9e8:	003b68fa 	trap	3
8110d9ec:	df000315 	stw	fp,12(sp)
8110d9f0:	df000304 	addi	fp,sp,12
8110d9f4:	e13ffe15 	stw	r4,-8(fp)
8110d9f8:	e17fff15 	stw	r5,-4(fp)
	alt_u32 *p_addr = (alt_u32 *) SYNC_BASE_ADDR;
8110d9fc:	00a00034 	movhi	r2,32768
8110da00:	10810004 	addi	r2,r2,1024
8110da04:	e0bffd15 	stw	r2,-12(fp)
	*(p_addr + uliOffset) = uliValue;
8110da08:	e0bffe17 	ldw	r2,-8(fp)
8110da0c:	1085883a 	add	r2,r2,r2
8110da10:	1085883a 	add	r2,r2,r2
8110da14:	1007883a 	mov	r3,r2
8110da18:	e0bffd17 	ldw	r2,-12(fp)
8110da1c:	10c5883a 	add	r2,r2,r3
8110da20:	e0ffff17 	ldw	r3,-4(fp)
8110da24:	10c00015 	stw	r3,0(r2)
	return TRUE;
8110da28:	00800044 	movi	r2,1
}
8110da2c:	e037883a 	mov	sp,fp
8110da30:	df000017 	ldw	fp,0(sp)
8110da34:	dec00104 	addi	sp,sp,4
8110da38:	f800283a 	ret

8110da3c <uliSyncReadReg>:
 *
 * @param [in] alt_u32 offset
 *
 * @retval alt_u32 value -> reg
 */
alt_u32 uliSyncReadReg(alt_u32 uliOffset) {
8110da3c:	defffc04 	addi	sp,sp,-16
8110da40:	de00012e 	bgeu	sp,et,8110da48 <uliSyncReadReg+0xc>
8110da44:	003b68fa 	trap	3
8110da48:	df000315 	stw	fp,12(sp)
8110da4c:	df000304 	addi	fp,sp,12
8110da50:	e13fff15 	stw	r4,-4(fp)
	alt_u32 value;

	alt_u32 *p_addr = (alt_u32 *) SYNC_BASE_ADDR;
8110da54:	00a00034 	movhi	r2,32768
8110da58:	10810004 	addi	r2,r2,1024
8110da5c:	e0bffd15 	stw	r2,-12(fp)
	value = *(p_addr + uliOffset);
8110da60:	e0bfff17 	ldw	r2,-4(fp)
8110da64:	1085883a 	add	r2,r2,r2
8110da68:	1085883a 	add	r2,r2,r2
8110da6c:	1007883a 	mov	r3,r2
8110da70:	e0bffd17 	ldw	r2,-12(fp)
8110da74:	10c5883a 	add	r2,r2,r3
8110da78:	10800017 	ldw	r2,0(r2)
8110da7c:	e0bffe15 	stw	r2,-8(fp)
	return value;
8110da80:	e0bffe17 	ldw	r2,-8(fp)
}
8110da84:	e037883a 	mov	sp,fp
8110da88:	df000017 	ldw	fp,0(sp)
8110da8c:	dec00104 	addi	sp,sp,4
8110da90:	f800283a 	ret

8110da94 <uliPerCalcPeriodMs>:

/*
 * Return the necessary PER value for a
 * Sync Signal period in usiPeriodMs ms.
 */
alt_u32 uliPerCalcPeriodMs(alt_u16 usiPeriodMs) {
8110da94:	defffc04 	addi	sp,sp,-16
8110da98:	de00012e 	bgeu	sp,et,8110daa0 <uliPerCalcPeriodMs+0xc>
8110da9c:	003b68fa 	trap	3
8110daa0:	dfc00315 	stw	ra,12(sp)
8110daa4:	df000215 	stw	fp,8(sp)
8110daa8:	df000204 	addi	fp,sp,8
8110daac:	2005883a 	mov	r2,r4
8110dab0:	e0bfff0d 	sth	r2,-4(fp)
	 * Period[ms] / 20e-6 = Period[ms] * 5e+4
	 * PER = Period[ms] * 5e+4
	 */

	alt_u32 uliPer;
	uliPer = usiPeriodMs * 5e+4;
8110dab4:	e0bfff0b 	ldhu	r2,-4(fp)
8110dab8:	1009883a 	mov	r4,r2
8110dabc:	11210640 	call	81121064 <__floatsidf>
8110dac0:	1011883a 	mov	r8,r2
8110dac4:	1813883a 	mov	r9,r3
8110dac8:	000d883a 	mov	r6,zero
8110dacc:	01d03a34 	movhi	r7,16616
8110dad0:	39da8004 	addi	r7,r7,27136
8110dad4:	4009883a 	mov	r4,r8
8110dad8:	480b883a 	mov	r5,r9
8110dadc:	111ffc00 	call	8111ffc0 <__muldf3>
8110dae0:	1009883a 	mov	r4,r2
8110dae4:	180b883a 	mov	r5,r3
8110dae8:	2005883a 	mov	r2,r4
8110daec:	2807883a 	mov	r3,r5
8110daf0:	1009883a 	mov	r4,r2
8110daf4:	180b883a 	mov	r5,r3
8110daf8:	111f3f80 	call	8111f3f8 <__fixunsdfsi>
8110dafc:	e0bffe15 	stw	r2,-8(fp)

	return uliPer;
8110db00:	e0bffe17 	ldw	r2,-8(fp)
}
8110db04:	e037883a 	mov	sp,fp
8110db08:	dfc00117 	ldw	ra,4(sp)
8110db0c:	df000017 	ldw	fp,0(sp)
8110db10:	dec00204 	addi	sp,sp,8
8110db14:	f800283a 	ret

8110db18 <vDataControlTask>:


#include "data_control_task.h"

/* 0% Ready! */
void vDataControlTask(void *task_data) {
8110db18:	defff804 	addi	sp,sp,-32
8110db1c:	de00012e 	bgeu	sp,et,8110db24 <vDataControlTask+0xc>
8110db20:	003b68fa 	trap	3
8110db24:	dfc00715 	stw	ra,28(sp)
8110db28:	df000615 	stw	fp,24(sp)
8110db2c:	df000604 	addi	fp,sp,24
8110db30:	e13ffd15 	stw	r4,-12(fp)
	tQMask uiCmdDTC;
	INT8U error_code;
	TNData_Control *pxDataC;


	pxDataC = (TNData_Control *) task_data;
8110db34:	e0bffd17 	ldw	r2,-12(fp)
8110db38:	e0bffa15 	stw	r2,-24(fp)

	#ifdef DEBUG_ON
        debug(fp,"Data Controller Task. (Task on)\n");
8110db3c:	d0a06217 	ldw	r2,-32376(gp)
8110db40:	100f883a 	mov	r7,r2
8110db44:	01800804 	movi	r6,32
8110db48:	01400044 	movi	r5,1
8110db4c:	01204574 	movhi	r4,33045
8110db50:	2131ea04 	addi	r4,r4,-14424
8110db54:	1121c7c0 	call	81121c7c <fwrite>
    #endif

    pxDataC->bUpdateComplete = TRUE;
8110db58:	e0bffa17 	ldw	r2,-24(fp)
8110db5c:	00c00044 	movi	r3,1
8110db60:	10c00515 	stw	r3,20(r2)

    error_code = OSQFlush(xQMaskDataCtrl);
8110db64:	d0a05f17 	ldw	r2,-32388(gp)
8110db68:	1009883a 	mov	r4,r2
8110db6c:	113db600 	call	8113db60 <OSQFlush>
8110db70:	e0bffc05 	stb	r2,-16(fp)
	if ( error_code != OS_NO_ERR ) {
8110db74:	e0bffc03 	ldbu	r2,-16(fp)
8110db78:	10803fcc 	andi	r2,r2,255
8110db7c:	10000126 	beq	r2,zero,8110db84 <vDataControlTask+0x6c>
		vFailFlushQueueData();
8110db80:	111d6d80 	call	8111d6d8 <vFailFlushQueueData>
	}

	for (;;) {

		uiCmdDTC.ulWord = (unsigned int)OSQPend(xQMaskDataCtrl, 0, &error_code); /* Blocking operation */
8110db84:	d0a05f17 	ldw	r2,-32388(gp)
8110db88:	e0fffc04 	addi	r3,fp,-16
8110db8c:	180d883a 	mov	r6,r3
8110db90:	000b883a 	mov	r5,zero
8110db94:	1009883a 	mov	r4,r2
8110db98:	113dc200 	call	8113dc20 <OSQPend>
8110db9c:	e0bffb15 	stw	r2,-20(fp)
			} else {

				/* todo: For now, do nothing */
			}
		}
		OSTimeDlyHMSM(0, 0, 5, 0); /*todo:Tirar depois do debug*/
8110dba0:	000f883a 	mov	r7,zero
8110dba4:	01800144 	movi	r6,5
8110dba8:	000b883a 	mov	r5,zero
8110dbac:	0009883a 	mov	r4,zero
8110dbb0:	1140ab00 	call	81140ab0 <OSTimeDlyHMSM>
	}
8110dbb4:	003ff306 	br	8110db84 <__reset+0xfb0edb84>

8110dbb8 <vFeeTask>:

const char *cTemp[64];
unsigned char ucIterationSide;


void vFeeTask(void *task_data) {
8110dbb8:	deffef04 	addi	sp,sp,-68
8110dbbc:	de00012e 	bgeu	sp,et,8110dbc4 <vFeeTask+0xc>
8110dbc0:	003b68fa 	trap	3
8110dbc4:	dfc01015 	stw	ra,64(sp)
8110dbc8:	df000f15 	stw	fp,60(sp)
8110dbcc:	df000f04 	addi	fp,sp,60
8110dbd0:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess = FALSE;
8110dbd4:	e03ffb15 	stw	zero,-20(fp)
	alt_u16 *pusiHK;
	alt_u32 *pusiHK32;
	unsigned char ucIL;


	pxNFee = ( TNFee * ) task_data;
8110dbd8:	e0bfff17 	ldw	r2,-4(fp)
8110dbdc:	d0a05315 	stw	r2,-32436(gp)

	#ifdef DEBUG_ON
		fprintf(fp,"NFEE %hhu Task. (Task on)\n", pxNFee->ucId);
8110dbe0:	d0e06217 	ldw	r3,-32376(gp)
8110dbe4:	d0a05317 	ldw	r2,-32436(gp)
8110dbe8:	10800003 	ldbu	r2,0(r2)
8110dbec:	10803fcc 	andi	r2,r2,255
8110dbf0:	100d883a 	mov	r6,r2
8110dbf4:	01604574 	movhi	r5,33045
8110dbf8:	2971f304 	addi	r5,r5,-14388
8110dbfc:	1809883a 	mov	r4,r3
8110dc00:	11215e00 	call	811215e0 <fprintf>
	#endif

	#ifdef DEBUG_ON
		vPrintConsoleNFee( pxNFee );
8110dc04:	d0a05317 	ldw	r2,-32436(gp)
8110dc08:	1009883a 	mov	r4,r2
8110dc0c:	1110b680 	call	81110b68 <vPrintConsoleNFee>
	#endif


	for(;;){

		switch ( pxNFee->xControl.eMode ) {
8110dc10:	d0a05317 	ldw	r2,-32436(gp)
8110dc14:	10802c17 	ldw	r2,176(r2)
8110dc18:	10c00368 	cmpgeui	r3,r2,13
8110dc1c:	1805791e 	bne	r3,zero,8110f204 <vFeeTask+0x164c>
8110dc20:	100690ba 	slli	r3,r2,2
8110dc24:	00a04474 	movhi	r2,33041
8110dc28:	10b70e04 	addi	r2,r2,-9160
8110dc2c:	1885883a 	add	r2,r3,r2
8110dc30:	10800017 	ldw	r2,0(r2)
8110dc34:	1000683a 	jmp	r2
8110dc38:	8110dc6c 	andhi	r4,r16,17265
8110dc3c:	8110e3ec 	andhi	r4,r16,17295
8110dc40:	8110e470 	cmpltui	r4,r16,17297
8110dc44:	8110e5d0 	cmplti	r4,r16,17303
8110dc48:	8110ece8 	cmpgeui	r4,r16,17331
8110dc4c:	8110e224 	muli	r4,r16,17288
8110dc50:	8110e480 	call	88110e48 <__reset+0x20f0e48>
8110dc54:	8110ebd8 	cmpnei	r4,r16,17327
8110dc58:	8110f204 	addi	r4,r16,17352
8110dc5c:	8110f204 	addi	r4,r16,17352
8110dc60:	8110e654 	ori	r4,r16,17305
8110dc64:	8110f0e8 	cmpgeui	r4,r16,17347
8110dc68:	8110f15c 	xori	r4,r16,17349
			case sFeeInit:

				error_code = OSQFlush( xFeeQ[ pxNFee->ucId ] );
8110dc6c:	d0a05317 	ldw	r2,-32436(gp)
8110dc70:	10800003 	ldbu	r2,0(r2)
8110dc74:	10803fcc 	andi	r2,r2,255
8110dc78:	1085883a 	add	r2,r2,r2
8110dc7c:	1087883a 	add	r3,r2,r2
8110dc80:	d0a06a04 	addi	r2,gp,-32344
8110dc84:	1885883a 	add	r2,r3,r2
8110dc88:	10800017 	ldw	r2,0(r2)
8110dc8c:	1009883a 	mov	r4,r2
8110dc90:	113db600 	call	8113db60 <OSQFlush>
8110dc94:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110dc98:	e0bffd03 	ldbu	r2,-12(fp)
8110dc9c:	10803fcc 	andi	r2,r2,255
8110dca0:	10000126 	beq	r2,zero,8110dca8 <vFeeTask+0xf0>
					vFailFlushNFEEQueue();
8110dca4:	111d7700 	call	8111d770 <vFailFlushNFEEQueue>
				}

				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110dca8:	d0a05317 	ldw	r2,-32436(gp)
8110dcac:	10800003 	ldbu	r2,0(r2)
8110dcb0:	10803fcc 	andi	r2,r2,255
8110dcb4:	1085883a 	add	r2,r2,r2
8110dcb8:	1087883a 	add	r3,r2,r2
8110dcbc:	d0a05c04 	addi	r2,gp,-32400
8110dcc0:	1885883a 	add	r2,r3,r2
8110dcc4:	10800017 	ldw	r2,0(r2)
8110dcc8:	1009883a 	mov	r4,r2
8110dccc:	113db600 	call	8113db60 <OSQFlush>
8110dcd0:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110dcd4:	e0bffd03 	ldbu	r2,-12(fp)
8110dcd8:	10803fcc 	andi	r2,r2,255
8110dcdc:	10000126 	beq	r2,zero,8110dce4 <vFeeTask+0x12c>
					vFailFlushNFEEQueue();
8110dce0:	111d7700 	call	8111d770 <vFailFlushNFEEQueue>
				}				

				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110dce4:	d0a05317 	ldw	r2,-32436(gp)
8110dce8:	10803304 	addi	r2,r2,204
8110dcec:	1009883a 	mov	r4,r2
8110dcf0:	1104c0c0 	call	81104c0c <bDpktGetPacketConfig>
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdXSize = pxNFee->xCcdInfo.usiHalfWidth + pxNFee->xCcdInfo.usiSPrescanN + pxNFee->xCcdInfo.usiSOverscanN;
8110dcf4:	d0a05317 	ldw	r2,-32436(gp)
8110dcf8:	d0e05317 	ldw	r3,-32436(gp)
8110dcfc:	1900308b 	ldhu	r4,194(r3)
8110dd00:	d0e05317 	ldw	r3,-32436(gp)
8110dd04:	18c02f0b 	ldhu	r3,188(r3)
8110dd08:	20c7883a 	add	r3,r4,r3
8110dd0c:	1809883a 	mov	r4,r3
8110dd10:	d0e05317 	ldw	r3,-32436(gp)
8110dd14:	18c02f8b 	ldhu	r3,190(r3)
8110dd18:	20c7883a 	add	r3,r4,r3
8110dd1c:	10c0340d 	sth	r3,208(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdYSize = pxNFee->xCcdInfo.usiHeight + pxNFee->xCcdInfo.usiOLN;
8110dd20:	d0a05317 	ldw	r2,-32436(gp)
8110dd24:	d0e05317 	ldw	r3,-32436(gp)
8110dd28:	1900310b 	ldhu	r4,196(r3)
8110dd2c:	d0e05317 	ldw	r3,-32436(gp)
8110dd30:	18c0300b 	ldhu	r3,192(r3)
8110dd34:	20c7883a 	add	r3,r4,r3
8110dd38:	10c0348d 	sth	r3,210(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiDataYSize = pxNFee->xCcdInfo.usiHeight;
8110dd3c:	d0a05317 	ldw	r2,-32436(gp)
8110dd40:	d0e05317 	ldw	r3,-32436(gp)
8110dd44:	18c0310b 	ldhu	r3,196(r3)
8110dd48:	10c0350d 	sth	r3,212(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiOverscanYSize = pxNFee->xCcdInfo.usiOLN;
8110dd4c:	d0a05317 	ldw	r2,-32436(gp)
8110dd50:	d0e05317 	ldw	r3,-32436(gp)
8110dd54:	18c0300b 	ldhu	r3,192(r3)
8110dd58:	10c0358d 	sth	r3,214(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiPacketLength = 32768;
8110dd5c:	d0a05317 	ldw	r2,-32436(gp)
8110dd60:	00e00004 	movi	r3,-32768
8110dd64:	10c0360d 	sth	r3,216(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber = 0; /* 32 KB */
8110dd68:	d0a05317 	ldw	r2,-32436(gp)
8110dd6c:	100036c5 	stb	zero,219(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktFullImagePattern; /* todo:No esquecer de atualizar para o ENUM  */
8110dd70:	d0a05317 	ldw	r2,-32436(gp)
8110dd74:	00c00044 	movi	r3,1
8110dd78:	10c03685 	stb	r3,218(r2)
				bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110dd7c:	d0a05317 	ldw	r2,-32436(gp)
8110dd80:	10803304 	addi	r2,r2,204
8110dd84:	1009883a 	mov	r4,r2
8110dd88:	11049e00 	call	811049e0 <bDpktSetPacketConfig>

				bRmapGetRmapMemHKArea(&pxNFee->xChannel.xRmap);
8110dd8c:	d0a05317 	ldw	r2,-32436(gp)
8110dd90:	10804304 	addi	r2,r2,268
8110dd94:	1009883a 	mov	r4,r2
8110dd98:	11096fc0 	call	811096fc <bRmapGetRmapMemHKArea>
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodE = 0xFF00;
8110dd9c:	d0a05317 	ldw	r2,-32436(gp)
8110dda0:	00ffc004 	movi	r3,-256
8110dda4:	10c0690d 	sth	r3,420(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodF = 0xFF01;
8110dda8:	d0a05317 	ldw	r2,-32436(gp)
8110ddac:	00ffc044 	movi	r3,-255
8110ddb0:	10c0698d 	sth	r3,422(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VrdMon = 0xFF02;
8110ddb4:	d0a05317 	ldw	r2,-32436(gp)
8110ddb8:	00ffc084 	movi	r3,-254
8110ddbc:	10c06a0d 	sth	r3,424(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2VodE = 0xFF03;
8110ddc0:	d0a05317 	ldw	r2,-32436(gp)
8110ddc4:	00ffc0c4 	movi	r3,-253
8110ddc8:	10c06a8d 	sth	r3,426(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2VodF = 0xFF04;
8110ddcc:	d0a05317 	ldw	r2,-32436(gp)
8110ddd0:	00ffc104 	movi	r3,-252
8110ddd4:	10c06b0d 	sth	r3,428(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2VrdMon = 0xFF05;
8110ddd8:	d0a05317 	ldw	r2,-32436(gp)
8110dddc:	00ffc144 	movi	r3,-251
8110dde0:	10c06b8d 	sth	r3,430(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3VodE = 0xFF06;
8110dde4:	d0a05317 	ldw	r2,-32436(gp)
8110dde8:	00ffc184 	movi	r3,-250
8110ddec:	10c06c0d 	sth	r3,432(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3VodF = 0xFF07;
8110ddf0:	d0a05317 	ldw	r2,-32436(gp)
8110ddf4:	00ffc1c4 	movi	r3,-249
8110ddf8:	10c06c8d 	sth	r3,434(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3VrdMon = 0xFF08;
8110ddfc:	d0a05317 	ldw	r2,-32436(gp)
8110de00:	00ffc204 	movi	r3,-248
8110de04:	10c06d0d 	sth	r3,436(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4VodE  = 0xFF09;
8110de08:	d0a05317 	ldw	r2,-32436(gp)
8110de0c:	00ffc244 	movi	r3,-247
8110de10:	10c06d8d 	sth	r3,438(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4VodF = 0xFF0A;
8110de14:	d0a05317 	ldw	r2,-32436(gp)
8110de18:	00ffc284 	movi	r3,-246
8110de1c:	10c06e0d 	sth	r3,440(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4VrdMon = 0xFF0B;
8110de20:	d0a05317 	ldw	r2,-32436(gp)
8110de24:	00ffc2c4 	movi	r3,-245
8110de28:	10c06e8d 	sth	r3,442(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVccd = 0xFF0C;
8110de2c:	d0a05317 	ldw	r2,-32436(gp)
8110de30:	00ffc304 	movi	r3,-244
8110de34:	10c06f0d 	sth	r3,444(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVrclk = 0xFF0D;
8110de38:	d0a05317 	ldw	r2,-32436(gp)
8110de3c:	00ffc344 	movi	r3,-243
8110de40:	10c06f8d 	sth	r3,446(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkViclk = 0xFF0E;
8110de44:	d0a05317 	ldw	r2,-32436(gp)
8110de48:	00ffc384 	movi	r3,-242
8110de4c:	10c0700d 	sth	r3,448(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVrclkLow = 0xFF0F;
8110de50:	d0a05317 	ldw	r2,-32436(gp)
8110de54:	00ffc3c4 	movi	r3,-241
8110de58:	10c0708d 	sth	r3,450(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk5vbPos = 0xFF10;
8110de5c:	d0a05317 	ldw	r2,-32436(gp)
8110de60:	00ffc404 	movi	r3,-240
8110de64:	10c0710d 	sth	r3,452(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk5vbNeg = 0xFF11;
8110de68:	d0a05317 	ldw	r2,-32436(gp)
8110de6c:	00ffc444 	movi	r3,-239
8110de70:	10c0718d 	sth	r3,454(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk33vbPos = 0xFF12;
8110de74:	d0a05317 	ldw	r2,-32436(gp)
8110de78:	00ffc484 	movi	r3,-238
8110de7c:	10c0720d 	sth	r3,456(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk25vaPos = 0xFF13;
8110de80:	d0a05317 	ldw	r2,-32436(gp)
8110de84:	00ffc4c4 	movi	r3,-237
8110de88:	10c0728d 	sth	r3,458(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk33vdPos = 0xFF14;
8110de8c:	d0a05317 	ldw	r2,-32436(gp)
8110de90:	00ffc504 	movi	r3,-236
8110de94:	10c0730d 	sth	r3,460(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk25vdPos = 0xFF15;
8110de98:	d0a05317 	ldw	r2,-32436(gp)
8110de9c:	00ffc544 	movi	r3,-235
8110dea0:	10c0738d 	sth	r3,462(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk15vdPos = 0xFF16;
8110dea4:	d0a05317 	ldw	r2,-32436(gp)
8110dea8:	00ffc584 	movi	r3,-234
8110deac:	10c0740d 	sth	r3,464(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk5vref = 0xFF17;
8110deb0:	d0a05317 	ldw	r2,-32436(gp)
8110deb4:	00ffc5c4 	movi	r3,-233
8110deb8:	10c0748d 	sth	r3,466(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVccdPosRaw = 0xFF18;
8110debc:	d0a05317 	ldw	r2,-32436(gp)
8110dec0:	00ffc604 	movi	r3,-232
8110dec4:	10c0750d 	sth	r3,468(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVclkPosRaw = 0xFF19;
8110dec8:	d0a05317 	ldw	r2,-32436(gp)
8110decc:	00ffc644 	movi	r3,-231
8110ded0:	10c0758d 	sth	r3,470(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVan1PosRaw = 0xFF1A;
8110ded4:	d0a05317 	ldw	r2,-32436(gp)
8110ded8:	00ffc684 	movi	r3,-230
8110dedc:	10c0760d 	sth	r3,472(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVan3NegRaw = 0xFF1B;
8110dee0:	d0a05317 	ldw	r2,-32436(gp)
8110dee4:	00ffc6c4 	movi	r3,-229
8110dee8:	10c0768d 	sth	r3,474(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVan2PosRaw = 0xFF1C;
8110deec:	d0a05317 	ldw	r2,-32436(gp)
8110def0:	00ffc704 	movi	r3,-228
8110def4:	10c0770d 	sth	r3,476(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVdigFpgaRaw = 0xFF1D;
8110def8:	d0a05317 	ldw	r2,-32436(gp)
8110defc:	00ffc744 	movi	r3,-227
8110df00:	10c0778d 	sth	r3,478(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVdigSpwRaw = 0xFF1E;
8110df04:	d0a05317 	ldw	r2,-32436(gp)
8110df08:	00ffc784 	movi	r3,-226
8110df0c:	10c0780d 	sth	r3,480(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkViclkLow = 0xFF1F;
8110df10:	d0a05317 	ldw	r2,-32436(gp)
8110df14:	00ffc7c4 	movi	r3,-225
8110df18:	10c0788d 	sth	r3,482(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkAdcTempAE = 0xFF20;
8110df1c:	d0a05317 	ldw	r2,-32436(gp)
8110df20:	00ffc804 	movi	r3,-224
8110df24:	10c0790d 	sth	r3,484(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkAdcTempAF = 0xFF21;
8110df28:	d0a05317 	ldw	r2,-32436(gp)
8110df2c:	00ffc844 	movi	r3,-223
8110df30:	10c0798d 	sth	r3,486(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1Temp = 0xFF22;
8110df34:	d0a05317 	ldw	r2,-32436(gp)
8110df38:	00ffc884 	movi	r3,-222
8110df3c:	10c07a0d 	sth	r3,488(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2Temp = 0xFF23;
8110df40:	d0a05317 	ldw	r2,-32436(gp)
8110df44:	00ffc8c4 	movi	r3,-221
8110df48:	10c07a8d 	sth	r3,490(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3Temp = 0xFF24;
8110df4c:	d0a05317 	ldw	r2,-32436(gp)
8110df50:	00ffc904 	movi	r3,-220
8110df54:	10c07b0d 	sth	r3,492(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4Temp = 0xFF25;
8110df58:	d0a05317 	ldw	r2,-32436(gp)
8110df5c:	00ffc944 	movi	r3,-219
8110df60:	10c07b8d 	sth	r3,494(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkWp605Spare = 0xFF26;
8110df64:	d0a05317 	ldw	r2,-32436(gp)
8110df68:	00ffc984 	movi	r3,-218
8110df6c:	10c07c0d 	sth	r3,496(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA0 = 0xFF27;
8110df70:	d0a05317 	ldw	r2,-32436(gp)
8110df74:	00ffc9c4 	movi	r3,-217
8110df78:	10c07c8d 	sth	r3,498(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA1 = 0xFF28;
8110df7c:	d0a05317 	ldw	r2,-32436(gp)
8110df80:	00ffca04 	movi	r3,-216
8110df84:	10c07d0d 	sth	r3,500(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA2 = 0xFF29;
8110df88:	d0a05317 	ldw	r2,-32436(gp)
8110df8c:	00ffca44 	movi	r3,-215
8110df90:	10c07d8d 	sth	r3,502(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA3 = 0xFF2A;
8110df94:	d0a05317 	ldw	r2,-32436(gp)
8110df98:	00ffca84 	movi	r3,-214
8110df9c:	10c07e0d 	sth	r3,504(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA4 = 0xFF2B;
8110dfa0:	d0a05317 	ldw	r2,-32436(gp)
8110dfa4:	00ffcac4 	movi	r3,-213
8110dfa8:	10c07e8d 	sth	r3,506(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA5 = 0xFF2C;
8110dfac:	d0a05317 	ldw	r2,-32436(gp)
8110dfb0:	00ffcb04 	movi	r3,-212
8110dfb4:	10c07f0d 	sth	r3,508(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA6 = 0xFF2D;
8110dfb8:	d0a05317 	ldw	r2,-32436(gp)
8110dfbc:	00ffcb44 	movi	r3,-211
8110dfc0:	10c07f8d 	sth	r3,510(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA7 = 0xFF2E;
8110dfc4:	d0a05317 	ldw	r2,-32436(gp)
8110dfc8:	00ffcb84 	movi	r3,-210
8110dfcc:	10c0800d 	sth	r3,512(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA8 = 0xFF2F;
8110dfd0:	d0a05317 	ldw	r2,-32436(gp)
8110dfd4:	00ffcbc4 	movi	r3,-209
8110dfd8:	10c0808d 	sth	r3,514(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA9 = 0xFF30;
8110dfdc:	d0a05317 	ldw	r2,-32436(gp)
8110dfe0:	00ffcc04 	movi	r3,-208
8110dfe4:	10c0810d 	sth	r3,516(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA10 = 0xFF31;
8110dfe8:	d0a05317 	ldw	r2,-32436(gp)
8110dfec:	00ffcc44 	movi	r3,-207
8110dff0:	10c0818d 	sth	r3,518(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA11 = 0xFF32;
8110dff4:	d0a05317 	ldw	r2,-32436(gp)
8110dff8:	00ffcc84 	movi	r3,-206
8110dffc:	10c0820d 	sth	r3,520(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA12 = 0xFF33;
8110e000:	d0a05317 	ldw	r2,-32436(gp)
8110e004:	00ffccc4 	movi	r3,-205
8110e008:	10c0828d 	sth	r3,522(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA13 = 0xFF34;
8110e00c:	d0a05317 	ldw	r2,-32436(gp)
8110e010:	00ffcd04 	movi	r3,-204
8110e014:	10c0830d 	sth	r3,524(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA14 = 0xFF35;
8110e018:	d0a05317 	ldw	r2,-32436(gp)
8110e01c:	00ffcd44 	movi	r3,-203
8110e020:	10c0838d 	sth	r3,526(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA15 = 0xFF36;
8110e024:	d0a05317 	ldw	r2,-32436(gp)
8110e028:	00ffcd84 	movi	r3,-202
8110e02c:	10c0840d 	sth	r3,528(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt0 = 0xFF37;
8110e030:	d0a05317 	ldw	r2,-32436(gp)
8110e034:	00ffcdc4 	movi	r3,-201
8110e038:	10c0848d 	sth	r3,530(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt1 = 0xFF38;
8110e03c:	d0a05317 	ldw	r2,-32436(gp)
8110e040:	00ffce04 	movi	r3,-200
8110e044:	10c0850d 	sth	r3,532(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt2 = 0xFF39;
8110e048:	d0a05317 	ldw	r2,-32436(gp)
8110e04c:	00ffce44 	movi	r3,-199
8110e050:	10c0858d 	sth	r3,534(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt3 = 0xFF3A;
8110e054:	d0a05317 	ldw	r2,-32436(gp)
8110e058:	00ffce84 	movi	r3,-198
8110e05c:	10c0860d 	sth	r3,536(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt4 = 0xFF3B;
8110e060:	d0a05317 	ldw	r2,-32436(gp)
8110e064:	00ffcec4 	movi	r3,-197
8110e068:	10c0868d 	sth	r3,538(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt5 = 0xFF3C;
8110e06c:	d0a05317 	ldw	r2,-32436(gp)
8110e070:	00ffcf04 	movi	r3,-196
8110e074:	10c0870d 	sth	r3,540(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt6 = 0xFF3D;
8110e078:	d0a05317 	ldw	r2,-32436(gp)
8110e07c:	00ffcf44 	movi	r3,-195
8110e080:	10c0878d 	sth	r3,542(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt7 = 0xFF3E;
8110e084:	d0a05317 	ldw	r2,-32436(gp)
8110e088:	00ffcf84 	movi	r3,-194
8110e08c:	10c0880d 	sth	r3,544(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiZeroHiresAmp = 0xFF3F;
8110e090:	d0a05317 	ldw	r2,-32436(gp)
8110e094:	00ffcfc4 	movi	r3,-193
8110e098:	10c0888d 	sth	r3,546(r2)
				bRmapSetRmapMemHKArea(&pxNFee->xChannel.xRmap);
8110e09c:	d0a05317 	ldw	r2,-32436(gp)
8110e0a0:	10804304 	addi	r2,r2,268
8110e0a4:	1009883a 	mov	r4,r2
8110e0a8:	11086b00 	call	811086b0 <bRmapSetRmapMemHKArea>


				vLoadCtemp();
8110e0ac:	11118bc0 	call	811118bc <vLoadCtemp>

				bRmapGetRmapMemHKArea(&pxNFee->xChannel.xRmap);
8110e0b0:	d0a05317 	ldw	r2,-32436(gp)
8110e0b4:	10804304 	addi	r2,r2,268
8110e0b8:	1009883a 	mov	r4,r2
8110e0bc:	11096fc0 	call	811096fc <bRmapGetRmapMemHKArea>
				pusiHK = &pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodE;
8110e0c0:	d0a05317 	ldw	r2,-32436(gp)
8110e0c4:	10806904 	addi	r2,r2,420
8110e0c8:	e0bff915 	stw	r2,-28(fp)

				#ifdef DEBUG_ON
					fprintf(fp,"\n\n================= H  K ==================\n");
8110e0cc:	d0a06217 	ldw	r2,-32376(gp)
8110e0d0:	100f883a 	mov	r7,r2
8110e0d4:	01800b04 	movi	r6,44
8110e0d8:	01400044 	movi	r5,1
8110e0dc:	01204574 	movhi	r4,33045
8110e0e0:	2131fa04 	addi	r4,r4,-14360
8110e0e4:	1121c7c0 	call	81121c7c <fwrite>

					for (ucIL = 0; ucIL < 64; ++ucIL) {
8110e0e8:	e03ffa05 	stb	zero,-24(fp)
8110e0ec:	00001606 	br	8110e148 <vFeeTask+0x590>
						fprintf(fp,"   - %s = %04x \n", cTemp[ucIL] , *pusiHK);
8110e0f0:	d1206217 	ldw	r4,-32376(gp)
8110e0f4:	e0fffa03 	ldbu	r3,-24(fp)
8110e0f8:	00a04574 	movhi	r2,33045
8110e0fc:	108fa204 	addi	r2,r2,16008
8110e100:	18c7883a 	add	r3,r3,r3
8110e104:	18c7883a 	add	r3,r3,r3
8110e108:	10c5883a 	add	r2,r2,r3
8110e10c:	10c00017 	ldw	r3,0(r2)
8110e110:	e0bff917 	ldw	r2,-28(fp)
8110e114:	1080000b 	ldhu	r2,0(r2)
8110e118:	10bfffcc 	andi	r2,r2,65535
8110e11c:	100f883a 	mov	r7,r2
8110e120:	180d883a 	mov	r6,r3
8110e124:	01604574 	movhi	r5,33045
8110e128:	29720604 	addi	r5,r5,-14312
8110e12c:	11215e00 	call	811215e0 <fprintf>
						pusiHK++;
8110e130:	e0bff917 	ldw	r2,-28(fp)
8110e134:	10800084 	addi	r2,r2,2
8110e138:	e0bff915 	stw	r2,-28(fp)
				pusiHK = &pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodE;

				#ifdef DEBUG_ON
					fprintf(fp,"\n\n================= H  K ==================\n");

					for (ucIL = 0; ucIL < 64; ++ucIL) {
8110e13c:	e0bffa03 	ldbu	r2,-24(fp)
8110e140:	10800044 	addi	r2,r2,1
8110e144:	e0bffa05 	stb	r2,-24(fp)
8110e148:	e0bffa03 	ldbu	r2,-24(fp)
8110e14c:	10801030 	cmpltui	r2,r2,64
8110e150:	103fe71e 	bne	r2,zero,8110e0f0 <__reset+0xfb0ee0f0>
						fprintf(fp,"   - %s = %04x \n", cTemp[ucIL] , *pusiHK);
						pusiHK++;
					}
					fprintf(fp,"\n================= H  K ==================\n\n");
8110e154:	d0a06217 	ldw	r2,-32376(gp)
8110e158:	100f883a 	mov	r7,r2
8110e15c:	01800b04 	movi	r6,44
8110e160:	01400044 	movi	r5,1
8110e164:	01204574 	movhi	r4,33045
8110e168:	21320b04 	addi	r4,r4,-14292
8110e16c:	1121c7c0 	call	81121c7c <fwrite>
				#endif

				/* Change the configuration */
				bRmapGetCodecConfig( &pxNFee->xChannel.xRmap );
8110e170:	d0a05317 	ldw	r2,-32436(gp)
8110e174:	10804304 	addi	r2,r2,268
8110e178:	1009883a 	mov	r4,r2
8110e17c:	1107d100 	call	81107d10 <bRmapGetCodecConfig>
				pxNFee->xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char) xDefaults.ucRmapKey ;
8110e180:	d0e05317 	ldw	r3,-32436(gp)
8110e184:	00a045b4 	movhi	r2,33046
8110e188:	109c0004 	addi	r2,r2,28672
8110e18c:	10800c0b 	ldhu	r2,48(r2)
8110e190:	18804405 	stb	r2,272(r3)
				pxNFee->xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char) xDefaults.ucLogicalAddr;
8110e194:	d0e05317 	ldw	r3,-32436(gp)
8110e198:	00a045b4 	movhi	r2,33046
8110e19c:	109c0004 	addi	r2,r2,28672
8110e1a0:	10800c8b 	ldhu	r2,50(r2)
8110e1a4:	18804445 	stb	r2,273(r3)
				bRmapSetCodecConfig( &pxNFee->xChannel.xRmap );
8110e1a8:	d0a05317 	ldw	r2,-32436(gp)
8110e1ac:	10804304 	addi	r2,r2,268
8110e1b0:	1009883a 	mov	r4,r2
8110e1b4:	1107c380 	call	81107c38 <bRmapSetCodecConfig>

				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task. RMAP KEY = %hu\n", xDefaults.ucRmapKey );
8110e1b8:	d0e06217 	ldw	r3,-32376(gp)
8110e1bc:	00a045b4 	movhi	r2,33046
8110e1c0:	109c0004 	addi	r2,r2,28672
8110e1c4:	10800c0b 	ldhu	r2,48(r2)
8110e1c8:	10bfffcc 	andi	r2,r2,65535
8110e1cc:	100d883a 	mov	r6,r2
8110e1d0:	01604574 	movhi	r5,33045
8110e1d4:	29721704 	addi	r5,r5,-14244
8110e1d8:	1809883a 	mov	r4,r3
8110e1dc:	11215e00 	call	811215e0 <fprintf>
					fprintf(fp,"NFEE %hhu Task. Log. Addr. = %hu \n", xDefaults.ucLogicalAddr);
8110e1e0:	d0e06217 	ldw	r3,-32376(gp)
8110e1e4:	00a045b4 	movhi	r2,33046
8110e1e8:	109c0004 	addi	r2,r2,28672
8110e1ec:	10800c8b 	ldhu	r2,50(r2)
8110e1f0:	10bfffcc 	andi	r2,r2,65535
8110e1f4:	100d883a 	mov	r6,r2
8110e1f8:	01604574 	movhi	r5,33045
8110e1fc:	29721f04 	addi	r5,r5,-14212
8110e200:	1809883a 	mov	r4,r3
8110e204:	11215e00 	call	811215e0 <fprintf>
				#endif

				pxNFee->xControl.eMode = sToFeeConfig;
8110e208:	d0a05317 	ldw	r2,-32436(gp)
8110e20c:	00c00144 	movi	r3,5
8110e210:	10c02c15 	stw	r3,176(r2)
				ucIterationSide = pxNFee->xControl.eSide;
8110e214:	d0a05317 	ldw	r2,-32436(gp)
8110e218:	10802e17 	ldw	r2,184(r2)
8110e21c:	d0a05605 	stb	r2,-32424(gp)

				break;
8110e220:	00040606 	br	8110f23c <vFeeTask+0x1684>
			case sToFeeConfig: /* Transition */

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8110e224:	d0a05317 	ldw	r2,-32436(gp)
8110e228:	10804304 	addi	r2,r2,268
8110e22c:	1009883a 	mov	r4,r2
8110e230:	11083480 	call	81108348 <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x06; /*Off*/
8110e234:	d0a05317 	ldw	r2,-32436(gp)
8110e238:	00c00184 	movi	r3,6
8110e23c:	10c06615 	stw	r3,408(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8110e240:	d0a05317 	ldw	r2,-32436(gp)
8110e244:	10804304 	addi	r2,r2,268
8110e248:	1009883a 	mov	r4,r2
8110e24c:	110805c0 	call	8110805c <bRmapSetMemConfigArea>

				/* Disable the link SPW */
				bDisableSPWChannel( &pxNFee->xChannel.xSpacewire );
8110e250:	d0a05317 	ldw	r2,-32436(gp)
8110e254:	10808904 	addi	r2,r2,548
8110e258:	1009883a 	mov	r4,r2
8110e25c:	111085c0 	call	8111085c <bDisableSPWChannel>
				pxNFee->xControl.bChannelEnable = FALSE;
8110e260:	d0a05317 	ldw	r2,-32436(gp)
8110e264:	10002615 	stw	zero,152(r2)

				/* Disable RMAP interrupts */
				bDisableRmapIRQ(&pxNFee->xChannel.xRmap, pxNFee->ucSPWId);
8110e268:	d0a05317 	ldw	r2,-32436(gp)
8110e26c:	10c04304 	addi	r3,r2,268
8110e270:	d0a05317 	ldw	r2,-32436(gp)
8110e274:	10800043 	ldbu	r2,1(r2)
8110e278:	10803fcc 	andi	r2,r2,255
8110e27c:	100b883a 	mov	r5,r2
8110e280:	1809883a 	mov	r4,r3
8110e284:	11107b00 	call	811107b0 <bDisableRmapIRQ>

				/* Disable IRQ and clear the Double Buffer */
				bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110e288:	d0a05317 	ldw	r2,-32436(gp)
8110e28c:	10803b04 	addi	r2,r2,236
8110e290:	1009883a 	mov	r4,r2
8110e294:	11109b40 	call	811109b4 <bDisAndClrDbBuffer>

				#ifdef DEBUG_ON
					fprintf(fp,"NFEE-%hu Task: Config Mode\n", pxNFee->ucId);
8110e298:	d0e06217 	ldw	r3,-32376(gp)
8110e29c:	d0a05317 	ldw	r2,-32436(gp)
8110e2a0:	10800003 	ldbu	r2,0(r2)
8110e2a4:	10803fcc 	andi	r2,r2,255
8110e2a8:	100d883a 	mov	r6,r2
8110e2ac:	01604574 	movhi	r5,33045
8110e2b0:	29722804 	addi	r5,r5,-14176
8110e2b4:	1809883a 	mov	r4,r3
8110e2b8:	11215e00 	call	811215e0 <fprintf>
				#endif

				/* Complete when MUTEX were created */
				if ( pxNFee->xControl.bDMALocked == TRUE ) {
8110e2bc:	d0a05317 	ldw	r2,-32436(gp)
8110e2c0:	10802217 	ldw	r2,136(r2)
8110e2c4:	10800058 	cmpnei	r2,r2,1
8110e2c8:	10000a1e 	bne	r2,zero,8110e2f4 <vFeeTask+0x73c>
					/* If is with the Mutex, should release */
					OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110e2cc:	e0fff303 	ldbu	r3,-52(fp)
8110e2d0:	00a045b4 	movhi	r2,33046
8110e2d4:	108f4404 	addi	r2,r2,15632
8110e2d8:	180690fa 	slli	r3,r3,3
8110e2dc:	10c5883a 	add	r2,r2,r3
8110e2e0:	10800017 	ldw	r2,0(r2)
8110e2e4:	1009883a 	mov	r4,r2
8110e2e8:	113d0b00 	call	8113d0b0 <OSMutexPost>
					pxNFee->xControl.bDMALocked = FALSE;
8110e2ec:	d0a05317 	ldw	r2,-32436(gp)
8110e2f0:	10002215 	stw	zero,136(r2)
				}

				/* Cleaning other syncs that maybe in the queue */
				pxNFee->xControl.bWatingSync = FALSE;
8110e2f4:	d0a05317 	ldw	r2,-32436(gp)
8110e2f8:	10002815 	stw	zero,160(r2)
				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110e2fc:	d0a05317 	ldw	r2,-32436(gp)
8110e300:	10800003 	ldbu	r2,0(r2)
8110e304:	10803fcc 	andi	r2,r2,255
8110e308:	1085883a 	add	r2,r2,r2
8110e30c:	1087883a 	add	r3,r2,r2
8110e310:	d0a05c04 	addi	r2,gp,-32400
8110e314:	1885883a 	add	r2,r3,r2
8110e318:	10800017 	ldw	r2,0(r2)
8110e31c:	1009883a 	mov	r4,r2
8110e320:	113db600 	call	8113db60 <OSQFlush>
8110e324:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110e328:	e0bffd03 	ldbu	r2,-12(fp)
8110e32c:	10803fcc 	andi	r2,r2,255
8110e330:	10000126 	beq	r2,zero,8110e338 <vFeeTask+0x780>
					vFailFlushNFEEQueue();
8110e334:	111d7700 	call	8111d770 <vFailFlushNFEEQueue>
				}

				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
8110e338:	d0a05317 	ldw	r2,-32436(gp)
8110e33c:	10800003 	ldbu	r2,0(r2)
8110e340:	10803fcc 	andi	r2,r2,255
8110e344:	100d883a 	mov	r6,r2
8110e348:	000b883a 	mov	r5,zero
8110e34c:	01002044 	movi	r4,129
8110e350:	1110ac40 	call	81110ac4 <bSendGiveBackNFeeCtrl>

				/* End of simulation! Clear everything that is possible */
				pxNFee->xControl.bWatingSync = FALSE;
8110e354:	d0a05317 	ldw	r2,-32436(gp)
8110e358:	10002815 	stw	zero,160(r2)
				pxNFee->xControl.bSimulating = FALSE;
8110e35c:	d0a05317 	ldw	r2,-32436(gp)
8110e360:	10002715 	stw	zero,156(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110e364:	d0a05317 	ldw	r2,-32436(gp)
8110e368:	10002315 	stw	zero,140(r2)
				pxNFee->xControl.bEnabled = TRUE;
8110e36c:	d0a05317 	ldw	r2,-32436(gp)
8110e370:	00c00044 	movi	r3,1
8110e374:	10c02115 	stw	r3,132(r2)

				vResetMemCCDFEE(pxNFee);
8110e378:	d0a05317 	ldw	r2,-32436(gp)
8110e37c:	1009883a 	mov	r4,r2
8110e380:	111de000 	call	8111de00 <vResetMemCCDFEE>

				error_code = OSQFlush( xFeeQ[ pxNFee->ucId ] );
8110e384:	d0a05317 	ldw	r2,-32436(gp)
8110e388:	10800003 	ldbu	r2,0(r2)
8110e38c:	10803fcc 	andi	r2,r2,255
8110e390:	1085883a 	add	r2,r2,r2
8110e394:	1087883a 	add	r3,r2,r2
8110e398:	d0a06a04 	addi	r2,gp,-32344
8110e39c:	1885883a 	add	r2,r3,r2
8110e3a0:	10800017 	ldw	r2,0(r2)
8110e3a4:	1009883a 	mov	r4,r2
8110e3a8:	113db600 	call	8113db60 <OSQFlush>
8110e3ac:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110e3b0:	e0bffd03 	ldbu	r2,-12(fp)
8110e3b4:	10803fcc 	andi	r2,r2,255
8110e3b8:	10000126 	beq	r2,zero,8110e3c0 <vFeeTask+0x808>
					vFailFlushNFEEQueue();
8110e3bc:	111d7700 	call	8111d770 <vFailFlushNFEEQueue>
				}

				pxNFee->xControl.bWatingSync = TRUE;
8110e3c0:	d0a05317 	ldw	r2,-32436(gp)
8110e3c4:	00c00044 	movi	r3,1
8110e3c8:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.eMode = sFeeConfig;
8110e3cc:	d0a05317 	ldw	r2,-32436(gp)
8110e3d0:	00c00044 	movi	r3,1
8110e3d4:	10c02c15 	stw	r3,176(r2)
				ucIterationSide = pxNFee->xControl.eSide;
8110e3d8:	d0a05317 	ldw	r2,-32436(gp)
8110e3dc:	10802e17 	ldw	r2,184(r2)
8110e3e0:	d0a05605 	stb	r2,-32424(gp)
				bFinal = FALSE;
8110e3e4:	e03ff815 	stw	zero,-32(fp)
				break;
8110e3e8:	00039406 	br	8110f23c <vFeeTask+0x1684>


			case sFeeConfig: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110e3ec:	d0a05317 	ldw	r2,-32436(gp)
8110e3f0:	10800003 	ldbu	r2,0(r2)
8110e3f4:	10803fcc 	andi	r2,r2,255
8110e3f8:	1085883a 	add	r2,r2,r2
8110e3fc:	1087883a 	add	r3,r2,r2
8110e400:	d0a06a04 	addi	r2,gp,-32344
8110e404:	1885883a 	add	r2,r3,r2
8110e408:	10800017 	ldw	r2,0(r2)
8110e40c:	e0fffd04 	addi	r3,fp,-12
8110e410:	180d883a 	mov	r6,r3
8110e414:	000b883a 	mov	r5,zero
8110e418:	1009883a 	mov	r4,r2
8110e41c:	113dc200 	call	8113dc20 <OSQPend>
8110e420:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110e424:	e0bffd03 	ldbu	r2,-12(fp)
8110e428:	10803fcc 	andi	r2,r2,255
8110e42c:	1000061e 	bne	r2,zero,8110e448 <vFeeTask+0x890>
					vQCmdFEEinConfig( pxNFee, uiCmdFEE.ulWord );
8110e430:	d0a05317 	ldw	r2,-32436(gp)
8110e434:	e0fffe17 	ldw	r3,-8(fp)
8110e438:	180b883a 	mov	r5,r3
8110e43c:	1009883a 	mov	r4,r2
8110e440:	110f4280 	call	8110f428 <vQCmdFEEinConfig>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110e444:	00037d06 	br	8110f23c <vFeeTask+0x1684>
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
				if ( error_code == OS_ERR_NONE ) {
					vQCmdFEEinConfig( pxNFee, uiCmdFEE.ulWord );
				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110e448:	d0e06217 	ldw	r3,-32376(gp)
8110e44c:	d0a05317 	ldw	r2,-32436(gp)
8110e450:	10800003 	ldbu	r2,0(r2)
8110e454:	10803fcc 	andi	r2,r2,255
8110e458:	100d883a 	mov	r6,r2
8110e45c:	01604574 	movhi	r5,33045
8110e460:	29722f04 	addi	r5,r5,-14148
8110e464:	1809883a 	mov	r4,r3
8110e468:	11215e00 	call	811215e0 <fprintf>
					#endif
				}

				break;
8110e46c:	00037306 	br	8110f23c <vFeeTask+0x1684>
			case sFeeOn: /* Not implemented yet */

				pxNFee->xControl.eMode = sToFeeStandBy;
8110e470:	d0a05317 	ldw	r2,-32436(gp)
8110e474:	00c00184 	movi	r3,6
8110e478:	10c02c15 	stw	r3,176(r2)
				break;
8110e47c:	00036f06 	br	8110f23c <vFeeTask+0x1684>
			case sToFeeStandBy: /* Transition */

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8110e480:	d0a05317 	ldw	r2,-32436(gp)
8110e484:	10804304 	addi	r2,r2,268
8110e488:	1009883a 	mov	r4,r2
8110e48c:	11083480 	call	81108348 <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x00; /*sToFeeStandBy*/
8110e490:	d0a05317 	ldw	r2,-32436(gp)
8110e494:	10006615 	stw	zero,408(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8110e498:	d0a05317 	ldw	r2,-32436(gp)
8110e49c:	10804304 	addi	r2,r2,268
8110e4a0:	1009883a 	mov	r4,r2
8110e4a4:	110805c0 	call	8110805c <bRmapSetMemConfigArea>

				/* Disable IRQ and clear the Double Buffer */
				bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110e4a8:	d0a05317 	ldw	r2,-32436(gp)
8110e4ac:	10803b04 	addi	r2,r2,236
8110e4b0:	1009883a 	mov	r4,r2
8110e4b4:	11109b40 	call	811109b4 <bDisAndClrDbBuffer>

				/* Disable RMAP interrupts */
				bEnableRmapIRQ(&pxNFee->xChannel.xRmap, pxNFee->ucId);
8110e4b8:	d0a05317 	ldw	r2,-32436(gp)
8110e4bc:	10c04304 	addi	r3,r2,268
8110e4c0:	d0a05317 	ldw	r2,-32436(gp)
8110e4c4:	10800003 	ldbu	r2,0(r2)
8110e4c8:	10803fcc 	andi	r2,r2,255
8110e4cc:	100b883a 	mov	r5,r2
8110e4d0:	1809883a 	mov	r4,r3
8110e4d4:	11108040 	call	81110804 <bEnableRmapIRQ>

				/* Disable the link SPW */
				bEnableSPWChannel( &pxNFee->xChannel.xSpacewire );
8110e4d8:	d0a05317 	ldw	r2,-32436(gp)
8110e4dc:	10808904 	addi	r2,r2,548
8110e4e0:	1009883a 	mov	r4,r2
8110e4e4:	11108bc0 	call	811108bc <bEnableSPWChannel>
				pxNFee->xControl.bChannelEnable = TRUE;
8110e4e8:	d0a05317 	ldw	r2,-32436(gp)
8110e4ec:	00c00044 	movi	r3,1
8110e4f0:	10c02615 	stw	r3,152(r2)

				pxNFee->xControl.bSimulating = TRUE;
8110e4f4:	d0a05317 	ldw	r2,-32436(gp)
8110e4f8:	00c00044 	movi	r3,1
8110e4fc:	10c02715 	stw	r3,156(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110e500:	d0a05317 	ldw	r2,-32436(gp)
8110e504:	10002315 	stw	zero,140(r2)
				pxNFee->xControl.bEnabled = TRUE;
8110e508:	d0a05317 	ldw	r2,-32436(gp)
8110e50c:	00c00044 	movi	r3,1
8110e510:	10c02115 	stw	r3,132(r2)

				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
8110e514:	d0a05317 	ldw	r2,-32436(gp)
8110e518:	10800003 	ldbu	r2,0(r2)
8110e51c:	10803fcc 	andi	r2,r2,255
8110e520:	100d883a 	mov	r6,r2
8110e524:	000b883a 	mov	r5,zero
8110e528:	01002044 	movi	r4,129
8110e52c:	1110ac40 	call	81110ac4 <bSendGiveBackNFeeCtrl>

				/* Cleaning other syncs that maybe in the queue */
				pxNFee->xControl.bWatingSync = FALSE;
8110e530:	d0a05317 	ldw	r2,-32436(gp)
8110e534:	10002815 	stw	zero,160(r2)
				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110e538:	d0a05317 	ldw	r2,-32436(gp)
8110e53c:	10800003 	ldbu	r2,0(r2)
8110e540:	10803fcc 	andi	r2,r2,255
8110e544:	1085883a 	add	r2,r2,r2
8110e548:	1087883a 	add	r3,r2,r2
8110e54c:	d0a05c04 	addi	r2,gp,-32400
8110e550:	1885883a 	add	r2,r3,r2
8110e554:	10800017 	ldw	r2,0(r2)
8110e558:	1009883a 	mov	r4,r2
8110e55c:	113db600 	call	8113db60 <OSQFlush>
8110e560:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110e564:	e0bffd03 	ldbu	r2,-12(fp)
8110e568:	10803fcc 	andi	r2,r2,255
8110e56c:	10000126 	beq	r2,zero,8110e574 <vFeeTask+0x9bc>
					vFailFlushNFEEQueue();
8110e570:	111d7700 	call	8111d770 <vFailFlushNFEEQueue>
				}

				#ifdef DEBUG_ON
					fprintf(fp,"NFEE-%hu Task: Standby Mode\n", pxNFee->ucId);
8110e574:	d0e06217 	ldw	r3,-32376(gp)
8110e578:	d0a05317 	ldw	r2,-32436(gp)
8110e57c:	10800003 	ldbu	r2,0(r2)
8110e580:	10803fcc 	andi	r2,r2,255
8110e584:	100d883a 	mov	r6,r2
8110e588:	01604574 	movhi	r5,33045
8110e58c:	29723b04 	addi	r5,r5,-14100
8110e590:	1809883a 	mov	r4,r3
8110e594:	11215e00 	call	811215e0 <fprintf>
				#endif

				/* Reset the memory addr variables thats is used in the transmission*/
				vResetMemCCDFEE(pxNFee);
8110e598:	d0a05317 	ldw	r2,-32436(gp)
8110e59c:	1009883a 	mov	r4,r2
8110e5a0:	111de000 	call	8111de00 <vResetMemCCDFEE>

				incrementador = 0;
8110e5a4:	d0205415 	stw	zero,-32432(gp)

				pxNFee->xControl.bWatingSync = TRUE;
8110e5a8:	d0a05317 	ldw	r2,-32436(gp)
8110e5ac:	00c00044 	movi	r3,1
8110e5b0:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.eMode = sFeeStandBy;
8110e5b4:	d0a05317 	ldw	r2,-32436(gp)
8110e5b8:	00c000c4 	movi	r3,3
8110e5bc:	10c02c15 	stw	r3,176(r2)
				ucIterationSide = pxNFee->xControl.eSide;
8110e5c0:	d0a05317 	ldw	r2,-32436(gp)
8110e5c4:	10802e17 	ldw	r2,184(r2)
8110e5c8:	d0a05605 	stb	r2,-32424(gp)
				break;
8110e5cc:	00031b06 	br	8110f23c <vFeeTask+0x1684>


			case sFeeStandBy: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110e5d0:	d0a05317 	ldw	r2,-32436(gp)
8110e5d4:	10800003 	ldbu	r2,0(r2)
8110e5d8:	10803fcc 	andi	r2,r2,255
8110e5dc:	1085883a 	add	r2,r2,r2
8110e5e0:	1087883a 	add	r3,r2,r2
8110e5e4:	d0a06a04 	addi	r2,gp,-32344
8110e5e8:	1885883a 	add	r2,r3,r2
8110e5ec:	10800017 	ldw	r2,0(r2)
8110e5f0:	e0fffd04 	addi	r3,fp,-12
8110e5f4:	180d883a 	mov	r6,r3
8110e5f8:	000b883a 	mov	r5,zero
8110e5fc:	1009883a 	mov	r4,r2
8110e600:	113dc200 	call	8113dc20 <OSQPend>
8110e604:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110e608:	e0bffd03 	ldbu	r2,-12(fp)
8110e60c:	10803fcc 	andi	r2,r2,255
8110e610:	1000061e 	bne	r2,zero,8110e62c <vFeeTask+0xa74>
					vQCmdFEEinStandBy( pxNFee, uiCmdFEE.ulWord );
8110e614:	d0a05317 	ldw	r2,-32436(gp)
8110e618:	e0fffe17 	ldw	r3,-8(fp)
8110e61c:	180b883a 	mov	r5,r3
8110e620:	1009883a 	mov	r4,r2
8110e624:	110f5ec0 	call	8110f5ec <vQCmdFEEinStandBy>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110e628:	00030406 	br	8110f23c <vFeeTask+0x1684>
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
				if ( error_code == OS_ERR_NONE ) {
					vQCmdFEEinStandBy( pxNFee, uiCmdFEE.ulWord );
				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110e62c:	d0e06217 	ldw	r3,-32376(gp)
8110e630:	d0a05317 	ldw	r2,-32436(gp)
8110e634:	10800003 	ldbu	r2,0(r2)
8110e638:	10803fcc 	andi	r2,r2,255
8110e63c:	100d883a 	mov	r6,r2
8110e640:	01604574 	movhi	r5,33045
8110e644:	29722f04 	addi	r5,r5,-14148
8110e648:	1809883a 	mov	r4,r3
8110e64c:	11215e00 	call	811215e0 <fprintf>
					#endif
				}

				break;
8110e650:	0002fa06 	br	8110f23c <vFeeTask+0x1684>


			case sNextPatternIteration:


				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110e654:	d0a05317 	ldw	r2,-32436(gp)
8110e658:	10800003 	ldbu	r2,0(r2)
8110e65c:	10803fcc 	andi	r2,r2,255
8110e660:	1085883a 	add	r2,r2,r2
8110e664:	1087883a 	add	r3,r2,r2
8110e668:	d0a05c04 	addi	r2,gp,-32400
8110e66c:	1885883a 	add	r2,r3,r2
8110e670:	10800017 	ldw	r2,0(r2)
8110e674:	1009883a 	mov	r4,r2
8110e678:	113db600 	call	8113db60 <OSQFlush>
8110e67c:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110e680:	e0bffd03 	ldbu	r2,-12(fp)
8110e684:	10803fcc 	andi	r2,r2,255
8110e688:	10000126 	beq	r2,zero,8110e690 <vFeeTask+0xad8>
					vFailFlushNFEEQueue();
8110e68c:	111d7700 	call	8111d770 <vFailFlushNFEEQueue>
				}

				pxNFee->xControl.bUsingDMA = TRUE;
8110e690:	d0a05317 	ldw	r2,-32436(gp)
8110e694:	00c00044 	movi	r3,1
8110e698:	10c02315 	stw	r3,140(r2)
				pxNFee->xControl.bSimulating = TRUE;
8110e69c:	d0a05317 	ldw	r2,-32436(gp)
8110e6a0:	00c00044 	movi	r3,1
8110e6a4:	10c02715 	stw	r3,156(r2)

				vResetMemCCDFEE(pxNFee);
8110e6a8:	d0a05317 	ldw	r2,-32436(gp)
8110e6ac:	1009883a 	mov	r4,r2
8110e6b0:	111de000 	call	8111de00 <vResetMemCCDFEE>

				//bFeebSetBufferSize(&pxNFee->xChannel.xFeeBuffer,SDMA_MAX_BLOCKS,0);
				//bFeebSetBufferSize(&pxNFee->xChannel.xFeeBuffer,SDMA_MAX_BLOCKS,1);


				while ( (bFeebGetCh1LeftBufferEmpty()== FALSE) || (bFeebGetCh1RightBufferEmpty()== FALSE)  ) {}
8110e6b4:	0001883a 	nop
8110e6b8:	11067480 	call	81106748 <bFeebGetCh1LeftBufferEmpty>
8110e6bc:	103ffe26 	beq	r2,zero,8110e6b8 <__reset+0xfb0ee6b8>
8110e6c0:	11067b00 	call	811067b0 <bFeebGetCh1RightBufferEmpty>
8110e6c4:	103ffc26 	beq	r2,zero,8110e6b8 <__reset+0xfb0ee6b8>

				OSTimeDlyHMSM(0,0,0,xDefaults.usiDelay);
8110e6c8:	00a045b4 	movhi	r2,33046
8110e6cc:	109c0004 	addi	r2,r2,28672
8110e6d0:	1080070b 	ldhu	r2,28(r2)
8110e6d4:	10bfffcc 	andi	r2,r2,65535
8110e6d8:	100f883a 	mov	r7,r2
8110e6dc:	000d883a 	mov	r6,zero
8110e6e0:	000b883a 	mov	r5,zero
8110e6e4:	0009883a 	mov	r4,zero
8110e6e8:	1140ab00 	call	81140ab0 <OSTimeDlyHMSM>

				#ifdef DEBUG_ON
					//fprintf(fp,"\n    i: %u ",incrementador);
					fprintf(fp,"\n\n=========Delay=============\n");
8110e6ec:	d0a06217 	ldw	r2,-32376(gp)
8110e6f0:	100f883a 	mov	r7,r2
8110e6f4:	01800784 	movi	r6,30
8110e6f8:	01400044 	movi	r5,1
8110e6fc:	01204574 	movhi	r4,33045
8110e700:	21324304 	addi	r4,r4,-14068
8110e704:	1121c7c0 	call	81121c7c <fwrite>
					fprintf(fp,"usiCcdXSize %hu\n", xDefaults.usiDelay);
8110e708:	d0e06217 	ldw	r3,-32376(gp)
8110e70c:	00a045b4 	movhi	r2,33046
8110e710:	109c0004 	addi	r2,r2,28672
8110e714:	1080070b 	ldhu	r2,28(r2)
8110e718:	10bfffcc 	andi	r2,r2,65535
8110e71c:	100d883a 	mov	r6,r2
8110e720:	01604574 	movhi	r5,33045
8110e724:	29724b04 	addi	r5,r5,-14036
8110e728:	1809883a 	mov	r4,r3
8110e72c:	11215e00 	call	811215e0 <fprintf>
					fprintf(fp,"=========DATA PACKET=============\n");
8110e730:	d0a06217 	ldw	r2,-32376(gp)
8110e734:	100f883a 	mov	r7,r2
8110e738:	01800884 	movi	r6,34
8110e73c:	01400044 	movi	r5,1
8110e740:	01204574 	movhi	r4,33045
8110e744:	21325004 	addi	r4,r4,-14016
8110e748:	1121c7c0 	call	81121c7c <fwrite>

				//bFeebCh2SetBufferSize(SDMA_MAX_BLOCKS,0);
				//bFeebCh2SetBufferSize(SDMA_MAX_BLOCKS,1);
				//bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
				//bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
				if (xDefaults.usiLinkNFEE0 == 0) {
8110e74c:	00a045b4 	movhi	r2,33046
8110e750:	109c0004 	addi	r2,r2,28672
8110e754:	1080100b 	ldhu	r2,64(r2)
8110e758:	10bfffcc 	andi	r2,r2,65535
8110e75c:	1000071e 	bne	r2,zero,8110e77c <vFeeTask+0xbc4>
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
8110e760:	000b883a 	mov	r5,zero
8110e764:	01000404 	movi	r4,16
8110e768:	1105b280 	call	81105b28 <bFeebCh1SetBufferSize>
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
8110e76c:	01400044 	movi	r5,1
8110e770:	01000404 	movi	r4,16
8110e774:	1105b280 	call	81105b28 <bFeebCh1SetBufferSize>
8110e778:	00000606 	br	8110e794 <vFeeTask+0xbdc>
				} else {
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
8110e77c:	000b883a 	mov	r5,zero
8110e780:	01000404 	movi	r4,16
8110e784:	1105bfc0 	call	81105bfc <bFeebCh2SetBufferSize>
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
8110e788:	01400044 	movi	r5,1
8110e78c:	01000404 	movi	r4,16
8110e790:	1105bfc0 	call	81105bfc <bFeebCh2SetBufferSize>
				}


				/* Enable IRQ and clear the Double Buffer */
				bEnableDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110e794:	d0a05317 	ldw	r2,-32436(gp)
8110e798:	10803b04 	addi	r2,r2,236
8110e79c:	1009883a 	mov	r4,r2
8110e7a0:	111091c0 	call	8111091c <bEnableDbBuffer>


				bSpwcGetTimecode(&pxNFee->xChannel.xSpacewire);
8110e7a4:	d0a05317 	ldw	r2,-32436(gp)
8110e7a8:	10808904 	addi	r2,r2,548
8110e7ac:	1009883a 	mov	r4,r2
8110e7b0:	110a7540 	call	8110a754 <bSpwcGetTimecode>
				tCodFeeTask = pxNFee->xChannel.xSpacewire.xTimecode.ucCounter;
8110e7b4:	d0a05317 	ldw	r2,-32436(gp)
8110e7b8:	10809543 	ldbu	r2,597(r2)
8110e7bc:	10803fcc 	andi	r2,r2,255
8110e7c0:	d0a05515 	stw	r2,-32428(gp)
				tCodeNext = ( tCodFeeTask + 1) % 4;
8110e7c4:	d0a05517 	ldw	r2,-32428(gp)
8110e7c8:	10800044 	addi	r2,r2,1
8110e7cc:	108000cc 	andi	r2,r2,3
8110e7d0:	e0bffc15 	stw	r2,-16(fp)
				if ( tCodeNext == 0 ) {
8110e7d4:	e0bffc17 	ldw	r2,-16(fp)
8110e7d8:	10000e1e 	bne	r2,zero,8110e814 <vFeeTask+0xc5c>
					/* Should get Data from the another memory, because is a cicle start */
					ucMemUsing = (unsigned char) (( *pxNFee->xControl.pActualMem + 1 ) % 2) ; /* Select the other memory*/
8110e7dc:	d0a05317 	ldw	r2,-32436(gp)
8110e7e0:	10802917 	ldw	r2,164(r2)
8110e7e4:	10800003 	ldbu	r2,0(r2)
8110e7e8:	10803fcc 	andi	r2,r2,255
8110e7ec:	10c00044 	addi	r3,r2,1
8110e7f0:	00a00034 	movhi	r2,32768
8110e7f4:	10800044 	addi	r2,r2,1
8110e7f8:	1884703a 	and	r2,r3,r2
8110e7fc:	1000040e 	bge	r2,zero,8110e810 <vFeeTask+0xc58>
8110e800:	10bfffc4 	addi	r2,r2,-1
8110e804:	00ffff84 	movi	r3,-2
8110e808:	10c4b03a 	or	r2,r2,r3
8110e80c:	10800044 	addi	r2,r2,1
8110e810:	e0bff305 	stb	r2,-52(fp)
				}

				ucReadout = pxNFee->xControl.ucROutOrder[tCodeNext];
8110e814:	d0e05317 	ldw	r3,-32436(gp)
8110e818:	e0bffc17 	ldw	r2,-16(fp)
8110e81c:	1885883a 	add	r2,r3,r2
8110e820:	10802a44 	addi	r2,r2,169
8110e824:	10800003 	ldbu	r2,0(r2)
8110e828:	e0bff505 	stb	r2,-44(fp)

				if ( pxNFee->xControl.eSide == sLeft )
8110e82c:	d0a05317 	ldw	r2,-32436(gp)
8110e830:	10802e17 	ldw	r2,184(r2)
8110e834:	1000071e 	bne	r2,zero,8110e854 <vFeeTask+0xc9c>
					xCcdMapLocal = &pxNFee->xMemMap.xCcd[ucReadout].xLeft;
8110e838:	d0e05317 	ldw	r3,-32436(gp)
8110e83c:	e0bff503 	ldbu	r2,-44(fp)
8110e840:	10800624 	muli	r2,r2,24
8110e844:	10800904 	addi	r2,r2,36
8110e848:	1885883a 	add	r2,r3,r2
8110e84c:	e0bff415 	stw	r2,-48(fp)
8110e850:	00000606 	br	8110e86c <vFeeTask+0xcb4>
				else
					xCcdMapLocal = &pxNFee->xMemMap.xCcd[ucReadout].xRight;
8110e854:	d0e05317 	ldw	r3,-32436(gp)
8110e858:	e0bff503 	ldbu	r2,-44(fp)
8110e85c:	10800624 	muli	r2,r2,24
8110e860:	10800c04 	addi	r2,r2,48
8110e864:	1885883a 	add	r2,r3,r2
8110e868:	e0bff415 	stw	r2,-48(fp)

				ucIterationSide = pxNFee->xControl.eSide;
8110e86c:	d0a05317 	ldw	r2,-32436(gp)
8110e870:	10802e17 	ldw	r2,184(r2)
8110e874:	d0a05605 	stb	r2,-32424(gp)


				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110e878:	d0a05317 	ldw	r2,-32436(gp)
8110e87c:	10803304 	addi	r2,r2,204
8110e880:	1009883a 	mov	r4,r2
8110e884:	1104c0c0 	call	81104c0c <bDpktGetPacketConfig>
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber = ucReadout;
8110e888:	d0a05317 	ldw	r2,-32436(gp)
8110e88c:	e0fff503 	ldbu	r3,-44(fp)
8110e890:	10c036c5 	stb	r3,219(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktFullImagePattern; /* todo:No esquecer de atualizar para o ENUM  */
8110e894:	d0a05317 	ldw	r2,-32436(gp)
8110e898:	00c00044 	movi	r3,1
8110e89c:	10c03685 	stb	r3,218(r2)
				bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110e8a0:	d0a05317 	ldw	r2,-32436(gp)
8110e8a4:	10803304 	addi	r2,r2,204
8110e8a8:	1009883a 	mov	r4,r2
8110e8ac:	11049e00 	call	811049e0 <bDpktSetPacketConfig>


				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110e8b0:	d0a05317 	ldw	r2,-32436(gp)
8110e8b4:	10803304 	addi	r2,r2,204
8110e8b8:	1009883a 	mov	r4,r2
8110e8bc:	1104c0c0 	call	81104c0c <bDpktGetPacketConfig>
				#ifdef DEBUG_ON
					//fprintf(fp,"\n    i: %u ",incrementador);
					fprintf(fp,"\n\n=========DATA PACKET=============\n");
8110e8c0:	d0a06217 	ldw	r2,-32376(gp)
8110e8c4:	100f883a 	mov	r7,r2
8110e8c8:	01800904 	movi	r6,36
8110e8cc:	01400044 	movi	r5,1
8110e8d0:	01204574 	movhi	r4,33045
8110e8d4:	21325904 	addi	r4,r4,-13980
8110e8d8:	1121c7c0 	call	81121c7c <fwrite>
					fprintf(fp,"usiCcdXSize %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdXSize);
8110e8dc:	d0e06217 	ldw	r3,-32376(gp)
8110e8e0:	d0a05317 	ldw	r2,-32436(gp)
8110e8e4:	1080340b 	ldhu	r2,208(r2)
8110e8e8:	10bfffcc 	andi	r2,r2,65535
8110e8ec:	100d883a 	mov	r6,r2
8110e8f0:	01604574 	movhi	r5,33045
8110e8f4:	29724b04 	addi	r5,r5,-14036
8110e8f8:	1809883a 	mov	r4,r3
8110e8fc:	11215e00 	call	811215e0 <fprintf>
					fprintf(fp,"usiCcdYSize %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdYSize);
8110e900:	d0e06217 	ldw	r3,-32376(gp)
8110e904:	d0a05317 	ldw	r2,-32436(gp)
8110e908:	1080348b 	ldhu	r2,210(r2)
8110e90c:	10bfffcc 	andi	r2,r2,65535
8110e910:	100d883a 	mov	r6,r2
8110e914:	01604574 	movhi	r5,33045
8110e918:	29726304 	addi	r5,r5,-13940
8110e91c:	1809883a 	mov	r4,r3
8110e920:	11215e00 	call	811215e0 <fprintf>
					fprintf(fp,"usiDataYSize %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiDataYSize);
8110e924:	d0e06217 	ldw	r3,-32376(gp)
8110e928:	d0a05317 	ldw	r2,-32436(gp)
8110e92c:	1080350b 	ldhu	r2,212(r2)
8110e930:	10bfffcc 	andi	r2,r2,65535
8110e934:	100d883a 	mov	r6,r2
8110e938:	01604574 	movhi	r5,33045
8110e93c:	29726804 	addi	r5,r5,-13920
8110e940:	1809883a 	mov	r4,r3
8110e944:	11215e00 	call	811215e0 <fprintf>
					fprintf(fp,"usiOverscanYSize %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiOverscanYSize);
8110e948:	d0e06217 	ldw	r3,-32376(gp)
8110e94c:	d0a05317 	ldw	r2,-32436(gp)
8110e950:	1080358b 	ldhu	r2,214(r2)
8110e954:	10bfffcc 	andi	r2,r2,65535
8110e958:	100d883a 	mov	r6,r2
8110e95c:	01604574 	movhi	r5,33045
8110e960:	29726d04 	addi	r5,r5,-13900
8110e964:	1809883a 	mov	r4,r3
8110e968:	11215e00 	call	811215e0 <fprintf>
					fprintf(fp,"usiPacketLength %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiPacketLength);
8110e96c:	d0e06217 	ldw	r3,-32376(gp)
8110e970:	d0a05317 	ldw	r2,-32436(gp)
8110e974:	1080360b 	ldhu	r2,216(r2)
8110e978:	10bfffcc 	andi	r2,r2,65535
8110e97c:	100d883a 	mov	r6,r2
8110e980:	01604574 	movhi	r5,33045
8110e984:	29727304 	addi	r5,r5,-13876
8110e988:	1809883a 	mov	r4,r3
8110e98c:	11215e00 	call	811215e0 <fprintf>
					fprintf(fp,"ucCcdNumber %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber);
8110e990:	d0e06217 	ldw	r3,-32376(gp)
8110e994:	d0a05317 	ldw	r2,-32436(gp)
8110e998:	108036c3 	ldbu	r2,219(r2)
8110e99c:	10803fcc 	andi	r2,r2,255
8110e9a0:	100d883a 	mov	r6,r2
8110e9a4:	01604574 	movhi	r5,33045
8110e9a8:	29727904 	addi	r5,r5,-13852
8110e9ac:	1809883a 	mov	r4,r3
8110e9b0:	11215e00 	call	811215e0 <fprintf>
					fprintf(fp,"ucFeeMode %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode);
8110e9b4:	d0e06217 	ldw	r3,-32376(gp)
8110e9b8:	d0a05317 	ldw	r2,-32436(gp)
8110e9bc:	10803683 	ldbu	r2,218(r2)
8110e9c0:	10803fcc 	andi	r2,r2,255
8110e9c4:	100d883a 	mov	r6,r2
8110e9c8:	01604574 	movhi	r5,33045
8110e9cc:	29727e04 	addi	r5,r5,-13832
8110e9d0:	1809883a 	mov	r4,r3
8110e9d4:	11215e00 	call	811215e0 <fprintf>
					fprintf(fp,"=========DATA PACKET=============\n");
8110e9d8:	d0a06217 	ldw	r2,-32376(gp)
8110e9dc:	100f883a 	mov	r7,r2
8110e9e0:	01800884 	movi	r6,34
8110e9e4:	01400044 	movi	r5,1
8110e9e8:	01204574 	movhi	r4,33045
8110e9ec:	21325004 	addi	r4,r4,-14016
8110e9f0:	1121c7c0 	call	81121c7c <fwrite>
				#endif

				/* Make one requests for the Double buffer */
				bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId);
8110e9f4:	d0a05317 	ldw	r2,-32436(gp)
8110e9f8:	10800003 	ldbu	r2,0(r2)
8110e9fc:	10803fcc 	andi	r2,r2,255
8110ea00:	100d883a 	mov	r6,r2
8110ea04:	000b883a 	mov	r5,zero
8110ea08:	01002004 	movi	r4,128
8110ea0c:	1110a200 	call	81110a20 <bSendRequestNFeeCtrl>
				bDmaReturn = FALSE;
8110ea10:	e03ff715 	stw	zero,-36(fp)
				/* When get the mutex, perform two DMA writes in order to fill the "double" part of the double buffer */
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110ea14:	d0a05317 	ldw	r2,-32436(gp)
8110ea18:	10800003 	ldbu	r2,0(r2)
8110ea1c:	10803fcc 	andi	r2,r2,255
8110ea20:	1085883a 	add	r2,r2,r2
8110ea24:	1087883a 	add	r3,r2,r2
8110ea28:	d0a06a04 	addi	r2,gp,-32344
8110ea2c:	1885883a 	add	r2,r3,r2
8110ea30:	10800017 	ldw	r2,0(r2)
8110ea34:	e0fffd04 	addi	r3,fp,-12
8110ea38:	180d883a 	mov	r6,r3
8110ea3c:	000b883a 	mov	r5,zero
8110ea40:	1009883a 	mov	r4,r2
8110ea44:	113dc200 	call	8113dc20 <OSQPend>
8110ea48:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110ea4c:	e0bffd03 	ldbu	r2,-12(fp)
8110ea50:	10803fcc 	andi	r2,r2,255
8110ea54:	1000561e 	bne	r2,zero,8110ebb0 <vFeeTask+0xff8>

					/* First Check if is access to the DMA (priority) */
					if ( uiCmdFEE.ucByte[2] == M_FEE_DMA_ACCESS ) {
8110ea58:	e0bffe83 	ldbu	r2,-6(fp)
8110ea5c:	10803fcc 	andi	r2,r2,255
8110ea60:	108023d8 	cmpnei	r2,r2,143
8110ea64:	10004c1e 	bne	r2,zero,8110eb98 <vFeeTask+0xfe0>

						/* Try to get the Mutex */
	                    OSMutexPend(xDma[ucMemUsing].xMutexDMA, 0, &error_code); /* Blocking way */
8110ea68:	e0fff303 	ldbu	r3,-52(fp)
8110ea6c:	00a045b4 	movhi	r2,33046
8110ea70:	108f4404 	addi	r2,r2,15632
8110ea74:	180690fa 	slli	r3,r3,3
8110ea78:	10c5883a 	add	r2,r2,r3
8110ea7c:	10800017 	ldw	r2,0(r2)
8110ea80:	e0fffd04 	addi	r3,fp,-12
8110ea84:	180d883a 	mov	r6,r3
8110ea88:	000b883a 	mov	r5,zero
8110ea8c:	1009883a 	mov	r4,r2
8110ea90:	113cb0c0 	call	8113cb0c <OSMutexPend>
	                    if ( error_code == OS_ERR_NONE ) {
8110ea94:	e0bffd03 	ldbu	r2,-12(fp)
8110ea98:	10803fcc 	andi	r2,r2,255
8110ea9c:	1000181e 	bne	r2,zero,8110eb00 <vFeeTask+0xf48>
	                    	pxNFee->xControl.bDMALocked = TRUE;
8110eaa0:	d0a05317 	ldw	r2,-32436(gp)
8110eaa4:	00c00044 	movi	r3,1
8110eaa8:	10c02215 	stw	r3,136(r2)

							bDmaReturn = bPrepareDoubleBuffer( xCcdMapLocal, ucMemUsing, pxNFee->ucId, pxNFee );
8110eaac:	e0fff303 	ldbu	r3,-52(fp)
8110eab0:	d0a05317 	ldw	r2,-32436(gp)
8110eab4:	10800003 	ldbu	r2,0(r2)
8110eab8:	10803fcc 	andi	r2,r2,255
8110eabc:	d1205317 	ldw	r4,-32436(gp)
8110eac0:	200f883a 	mov	r7,r4
8110eac4:	100d883a 	mov	r6,r2
8110eac8:	180b883a 	mov	r5,r3
8110eacc:	e13ff417 	ldw	r4,-48(fp)
8110ead0:	11114d00 	call	811114d0 <bPrepareDoubleBuffer>
8110ead4:	e0bff715 	stw	r2,-36(fp)
							OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110ead8:	e0fff303 	ldbu	r3,-52(fp)
8110eadc:	00a045b4 	movhi	r2,33046
8110eae0:	108f4404 	addi	r2,r2,15632
8110eae4:	180690fa 	slli	r3,r3,3
8110eae8:	10c5883a 	add	r2,r2,r3
8110eaec:	10800017 	ldw	r2,0(r2)
8110eaf0:	1009883a 	mov	r4,r2
8110eaf4:	113d0b00 	call	8113d0b0 <OSMutexPost>
							pxNFee->xControl.bDMALocked = FALSE;
8110eaf8:	d0a05317 	ldw	r2,-32436(gp)
8110eafc:	10002215 	stw	zero,136(r2)
		
						}
						/* Send message telling to controller that is not using the DMA any more */
						bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);							
8110eb00:	d0a05317 	ldw	r2,-32436(gp)
8110eb04:	10800003 	ldbu	r2,0(r2)
8110eb08:	10803fcc 	andi	r2,r2,255
8110eb0c:	100d883a 	mov	r6,r2
8110eb10:	000b883a 	mov	r5,zero
8110eb14:	01002044 	movi	r4,129
8110eb18:	1110ac40 	call	81110ac4 <bSendGiveBackNFeeCtrl>

						if ( bDmaReturn == TRUE ) {
8110eb1c:	e0bff717 	ldw	r2,-36(fp)
8110eb20:	10800058 	cmpnei	r2,r2,1
8110eb24:	1000141e 	bne	r2,zero,8110eb78 <vFeeTask+0xfc0>
							if (pxNFee->xControl.bWatingSync==TRUE) {
8110eb28:	d0a05317 	ldw	r2,-32436(gp)
8110eb2c:	10802817 	ldw	r2,160(r2)
8110eb30:	10800058 	cmpnei	r2,r2,1
8110eb34:	1000071e 	bne	r2,zero,8110eb54 <vFeeTask+0xf9c>
								pxNFee->xControl.eNextMode = sToTestFullPattern;
8110eb38:	d0a05317 	ldw	r2,-32436(gp)
8110eb3c:	00c001c4 	movi	r3,7
8110eb40:	10c02d15 	stw	r3,180(r2)
								pxNFee->xControl.eMode = sFeeWaitingSync;
8110eb44:	d0a05317 	ldw	r2,-32436(gp)
8110eb48:	00c00304 	movi	r3,12
8110eb4c:	10c02c15 	stw	r3,176(r2)
8110eb50:	00000606 	br	8110eb6c <vFeeTask+0xfb4>
							} else {
								pxNFee->xControl.eNextMode = sToTestFullPattern;
8110eb54:	d0a05317 	ldw	r2,-32436(gp)
8110eb58:	00c001c4 	movi	r3,7
8110eb5c:	10c02d15 	stw	r3,180(r2)
								pxNFee->xControl.eMode = sToTestFullPattern;
8110eb60:	d0a05317 	ldw	r2,-32436(gp)
8110eb64:	00c001c4 	movi	r3,7
8110eb68:	10c02c15 	stw	r3,176(r2)
							}
							incrementador++;
8110eb6c:	d0a05417 	ldw	r2,-32432(gp)
8110eb70:	10800044 	addi	r2,r2,1
8110eb74:	d0a05415 	stw	r2,-32432(gp)
						}


							#ifdef DEBUG_ON
								fprintf(fp,"\nFEE TASK:  Double buffer prepared\n ");
8110eb78:	d0a06217 	ldw	r2,-32376(gp)
8110eb7c:	100f883a 	mov	r7,r2
8110eb80:	01800904 	movi	r6,36
8110eb84:	01400044 	movi	r5,1
8110eb88:	01204574 	movhi	r4,33045
8110eb8c:	21328204 	addi	r4,r4,-13816
8110eb90:	1121c7c0 	call	81121c7c <fwrite>
				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}	
				break;
8110eb94:	0001a906 	br	8110f23c <vFeeTask+0x1684>
							#ifdef DEBUG_ON
								fprintf(fp,"\nFEE TASK:  Double buffer prepared\n ");
							#endif							
					} else {

						vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
8110eb98:	d0a05317 	ldw	r2,-32436(gp)
8110eb9c:	e0fffe17 	ldw	r3,-8(fp)
8110eba0:	180b883a 	mov	r5,r3
8110eba4:	1009883a 	mov	r4,r2
8110eba8:	110f7e80 	call	8110f7e8 <vQCmdFEEinFullPattern>
				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}	
				break;
8110ebac:	0001a306 	br	8110f23c <vFeeTask+0x1684>

						vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
					}
				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110ebb0:	d0e06217 	ldw	r3,-32376(gp)
8110ebb4:	d0a05317 	ldw	r2,-32436(gp)
8110ebb8:	10800003 	ldbu	r2,0(r2)
8110ebbc:	10803fcc 	andi	r2,r2,255
8110ebc0:	100d883a 	mov	r6,r2
8110ebc4:	01604574 	movhi	r5,33045
8110ebc8:	29722f04 	addi	r5,r5,-14148
8110ebcc:	1809883a 	mov	r4,r3
8110ebd0:	11215e00 	call	811215e0 <fprintf>
					#endif
				}	
				break;
8110ebd4:	00019906 	br	8110f23c <vFeeTask+0x1684>


			case sToTestFullPattern: /* Transition */
				bFinal = FALSE;
8110ebd8:	e03ff815 	stw	zero,-32(fp)

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8110ebdc:	d0a05317 	ldw	r2,-32436(gp)
8110ebe0:	10804304 	addi	r2,r2,268
8110ebe4:	1009883a 	mov	r4,r2
8110ebe8:	11083480 	call	81108348 <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x02; /*Pattern Full Image*/
8110ebec:	d0a05317 	ldw	r2,-32436(gp)
8110ebf0:	00c00084 	movi	r3,2
8110ebf4:	10c06615 	stw	r3,408(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8110ebf8:	d0a05317 	ldw	r2,-32436(gp)
8110ebfc:	10804304 	addi	r2,r2,268
8110ec00:	1009883a 	mov	r4,r2
8110ec04:	110805c0 	call	8110805c <bRmapSetMemConfigArea>

				#ifdef DEBUG_ON
					fprintf(fp,"NFEE-%hu Task: Full Image Pattern Mode\n", pxNFee->ucId);
8110ec08:	d0e06217 	ldw	r3,-32376(gp)
8110ec0c:	d0a05317 	ldw	r2,-32436(gp)
8110ec10:	10800003 	ldbu	r2,0(r2)
8110ec14:	10803fcc 	andi	r2,r2,255
8110ec18:	100d883a 	mov	r6,r2
8110ec1c:	01604574 	movhi	r5,33045
8110ec20:	29728c04 	addi	r5,r5,-13776
8110ec24:	1809883a 	mov	r4,r3
8110ec28:	11215e00 	call	811215e0 <fprintf>
				#endif

				ucIterationSide = pxNFee->xControl.eSide;
8110ec2c:	d0a05317 	ldw	r2,-32436(gp)
8110ec30:	10802e17 	ldw	r2,184(r2)
8110ec34:	d0a05605 	stb	r2,-32424(gp)

				pxNFee->xControl.bUsingDMA = TRUE;
8110ec38:	d0a05317 	ldw	r2,-32436(gp)
8110ec3c:	00c00044 	movi	r3,1
8110ec40:	10c02315 	stw	r3,140(r2)
				pxNFee->xControl.eMode = sFeeTestFullPattern;
8110ec44:	d0a05317 	ldw	r2,-32436(gp)
8110ec48:	00c00104 	movi	r3,4
8110ec4c:	10c02c15 	stw	r3,176(r2)
				pxNFee->xControl.eNextMode = sFeeTestFullPattern;
8110ec50:	d0a05317 	ldw	r2,-32436(gp)
8110ec54:	00c00104 	movi	r3,4
8110ec58:	10c02d15 	stw	r3,180(r2)
				pxNFee->xControl.bWatingSync = TRUE;
8110ec5c:	d0a05317 	ldw	r2,-32436(gp)
8110ec60:	00c00044 	movi	r3,1
8110ec64:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.bSimulating = TRUE;
8110ec68:	d0a05317 	ldw	r2,-32436(gp)
8110ec6c:	00c00044 	movi	r3,1
8110ec70:	10c02715 	stw	r3,156(r2)
				pxNFee->xControl.bEnabled = TRUE;
8110ec74:	d0a05317 	ldw	r2,-32436(gp)
8110ec78:	00c00044 	movi	r3,1
8110ec7c:	10c02115 	stw	r3,132(r2)
				bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
8110ec80:	d0a05317 	ldw	r2,-32436(gp)
8110ec84:	10800003 	ldbu	r2,0(r2)
8110ec88:	10803fcc 	andi	r2,r2,255
8110ec8c:	100d883a 	mov	r6,r2
8110ec90:	000b883a 	mov	r5,zero
8110ec94:	01002004 	movi	r4,128
8110ec98:	1110a200 	call	81110a20 <bSendRequestNFeeCtrl>



				if (xDefaults.usiLinkNFEE0 == 0) {
8110ec9c:	00a045b4 	movhi	r2,33046
8110eca0:	109c0004 	addi	r2,r2,28672
8110eca4:	1080100b 	ldhu	r2,64(r2)
8110eca8:	10bfffcc 	andi	r2,r2,65535
8110ecac:	1000071e 	bne	r2,zero,8110eccc <vFeeTask+0x1114>
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
8110ecb0:	000b883a 	mov	r5,zero
8110ecb4:	01000404 	movi	r4,16
8110ecb8:	1105b280 	call	81105b28 <bFeebCh1SetBufferSize>
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
8110ecbc:	01400044 	movi	r5,1
8110ecc0:	01000404 	movi	r4,16
8110ecc4:	1105b280 	call	81105b28 <bFeebCh1SetBufferSize>
				//bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
				//bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
				//bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);


				break;
8110ecc8:	00015c06 	br	8110f23c <vFeeTask+0x1684>

				if (xDefaults.usiLinkNFEE0 == 0) {
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
				} else {
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
8110eccc:	000b883a 	mov	r5,zero
8110ecd0:	01000404 	movi	r4,16
8110ecd4:	1105bfc0 	call	81105bfc <bFeebCh2SetBufferSize>
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
8110ecd8:	01400044 	movi	r5,1
8110ecdc:	01000404 	movi	r4,16
8110ece0:	1105bfc0 	call	81105bfc <bFeebCh2SetBufferSize>
				//bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
				//bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
				//bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);


				break;
8110ece4:	00015506 	br	8110f23c <vFeeTask+0x1684>


			case sFeeTestFullPattern: /* Real mode */
				bFinal = FALSE;
8110ece8:	e03ff815 	stw	zero,-32(fp)

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110ecec:	d0a05317 	ldw	r2,-32436(gp)
8110ecf0:	10800003 	ldbu	r2,0(r2)
8110ecf4:	10803fcc 	andi	r2,r2,255
8110ecf8:	1085883a 	add	r2,r2,r2
8110ecfc:	1087883a 	add	r3,r2,r2
8110ed00:	d0a06a04 	addi	r2,gp,-32344
8110ed04:	1885883a 	add	r2,r3,r2
8110ed08:	10800017 	ldw	r2,0(r2)
8110ed0c:	e0fffd04 	addi	r3,fp,-12
8110ed10:	180d883a 	mov	r6,r3
8110ed14:	000b883a 	mov	r5,zero
8110ed18:	1009883a 	mov	r4,r2
8110ed1c:	113dc200 	call	8113dc20 <OSQPend>
8110ed20:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110ed24:	e0bffd03 	ldbu	r2,-12(fp)
8110ed28:	10803fcc 	andi	r2,r2,255
8110ed2c:	1000e41e 	bne	r2,zero,8110f0c0 <vFeeTask+0x1508>

					/* First Check if is access to the DMA (priority) */
						if ( uiCmdFEE.ucByte[2] == M_FEE_DMA_ACCESS ) {
8110ed30:	e0bffe83 	ldbu	r2,-6(fp)
8110ed34:	10803fcc 	andi	r2,r2,255
8110ed38:	108023d8 	cmpnei	r2,r2,143
8110ed3c:	1000d31e 	bne	r2,zero,8110f08c <vFeeTask+0x14d4>

							/* Try to get the Mutex */
		                    OSMutexPend(xDma[ucMemUsing].xMutexDMA, 0, &error_code); /* Blocking way */
8110ed40:	e0fff303 	ldbu	r3,-52(fp)
8110ed44:	00a045b4 	movhi	r2,33046
8110ed48:	108f4404 	addi	r2,r2,15632
8110ed4c:	180690fa 	slli	r3,r3,3
8110ed50:	10c5883a 	add	r2,r2,r3
8110ed54:	10800017 	ldw	r2,0(r2)
8110ed58:	e0fffd04 	addi	r3,fp,-12
8110ed5c:	180d883a 	mov	r6,r3
8110ed60:	000b883a 	mov	r5,zero
8110ed64:	1009883a 	mov	r4,r2
8110ed68:	113cb0c0 	call	8113cb0c <OSMutexPend>
		                    if ( error_code == OS_ERR_NONE ) {
8110ed6c:	e0bffd03 	ldbu	r2,-12(fp)
8110ed70:	10803fcc 	andi	r2,r2,255
8110ed74:	1001301e 	bne	r2,zero,8110f238 <vFeeTask+0x1680>
		                    	pxNFee->xControl.bDMALocked = TRUE;
8110ed78:	d0a05317 	ldw	r2,-32436(gp)
8110ed7c:	00c00044 	movi	r3,1
8110ed80:	10c02215 	stw	r3,136(r2)

		                    	/* Is this the last block? */
		                    	if ( (xCcdMapLocal->ulBlockI + SDMA_MAX_BLOCKS) >= pxNFee->xMemMap.xCommon.usiNTotalBlocks ) {
8110ed84:	e0bff417 	ldw	r2,-48(fp)
8110ed88:	10800117 	ldw	r2,4(r2)
8110ed8c:	10c00404 	addi	r3,r2,16
8110ed90:	d0a05317 	ldw	r2,-32436(gp)
8110ed94:	10800417 	ldw	r2,16(r2)
8110ed98:	18804036 	bltu	r3,r2,8110ee9c <vFeeTask+0x12e4>


									#ifdef DEBUG_ON
										//fprintf(fp,"\n    i: %u ",incrementador);
										fprintf(fp,"\nEnd of transmission NFEE-%hhu -> CCD %hhu  -> Time Code Ref. used -> %hu   total = %lu\n", pxNFee->ucId, ucReadout, tCodFeeTask, incrementador);
8110ed9c:	d1206217 	ldw	r4,-32376(gp)
8110eda0:	d0a05317 	ldw	r2,-32436(gp)
8110eda4:	10800003 	ldbu	r2,0(r2)
8110eda8:	11403fcc 	andi	r5,r2,255
8110edac:	e1bff503 	ldbu	r6,-44(fp)
8110edb0:	d0a05517 	ldw	r2,-32428(gp)
8110edb4:	d0e05417 	ldw	r3,-32432(gp)
8110edb8:	d8c00115 	stw	r3,4(sp)
8110edbc:	d8800015 	stw	r2,0(sp)
8110edc0:	300f883a 	mov	r7,r6
8110edc4:	280d883a 	mov	r6,r5
8110edc8:	01604574 	movhi	r5,33045
8110edcc:	29729604 	addi	r5,r5,-13736
8110edd0:	11215e00 	call	811215e0 <fprintf>
										fprintf(fp,"\nMemory used: %u ", ucMemUsing);
8110edd4:	d0a06217 	ldw	r2,-32376(gp)
8110edd8:	e0fff303 	ldbu	r3,-52(fp)
8110eddc:	180d883a 	mov	r6,r3
8110ede0:	01604574 	movhi	r5,33045
8110ede4:	2972ad04 	addi	r5,r5,-13644
8110ede8:	1009883a 	mov	r4,r2
8110edec:	11215e00 	call	811215e0 <fprintf>
										fprintf(fp,"\nTotal blocks transmitted: %lu ",xCcdMapLocal->ulBlockI);
8110edf0:	d0e06217 	ldw	r3,-32376(gp)
8110edf4:	e0bff417 	ldw	r2,-48(fp)
8110edf8:	10800117 	ldw	r2,4(r2)
8110edfc:	100d883a 	mov	r6,r2
8110ee00:	01604574 	movhi	r5,33045
8110ee04:	2972b204 	addi	r5,r5,-13624
8110ee08:	1809883a 	mov	r4,r3
8110ee0c:	11215e00 	call	811215e0 <fprintf>
									#endif

		                    		/*Define the size of the data in the double buffer (need this to create the interrupt riht)*/

									usiLengthBlocks = pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI;
8110ee10:	d0a05317 	ldw	r2,-32436(gp)
8110ee14:	10c00417 	ldw	r3,16(r2)
8110ee18:	e0bff417 	ldw	r2,-48(fp)
8110ee1c:	10800117 	ldw	r2,4(r2)
8110ee20:	1885c83a 	sub	r2,r3,r2
8110ee24:	e0bff615 	stw	r2,-40(fp)

		                    		bFinal = TRUE;
8110ee28:	00800044 	movi	r2,1
8110ee2c:	e0bff815 	stw	r2,-32(fp)

		            				if (xDefaults.usiLinkNFEE0 == 0) {
8110ee30:	00a045b4 	movhi	r2,33046
8110ee34:	109c0004 	addi	r2,r2,28672
8110ee38:	1080100b 	ldhu	r2,64(r2)
8110ee3c:	10bfffcc 	andi	r2,r2,65535
8110ee40:	10000b1e 	bne	r2,zero,8110ee70 <vFeeTask+0x12b8>
		            					bFeebCh1SetBufferSize((unsigned char)usiLengthBlocks,0);
8110ee44:	e0bff617 	ldw	r2,-40(fp)
8110ee48:	10803fcc 	andi	r2,r2,255
8110ee4c:	000b883a 	mov	r5,zero
8110ee50:	1009883a 	mov	r4,r2
8110ee54:	1105b280 	call	81105b28 <bFeebCh1SetBufferSize>
		            					bFeebCh1SetBufferSize((unsigned char)usiLengthBlocks,1);
8110ee58:	e0bff617 	ldw	r2,-40(fp)
8110ee5c:	10803fcc 	andi	r2,r2,255
8110ee60:	01400044 	movi	r5,1
8110ee64:	1009883a 	mov	r4,r2
8110ee68:	1105b280 	call	81105b28 <bFeebCh1SetBufferSize>
8110ee6c:	00000e06 	br	8110eea8 <vFeeTask+0x12f0>
		            				} else {
		            					bFeebCh2SetBufferSize((unsigned char)usiLengthBlocks,0);
8110ee70:	e0bff617 	ldw	r2,-40(fp)
8110ee74:	10803fcc 	andi	r2,r2,255
8110ee78:	000b883a 	mov	r5,zero
8110ee7c:	1009883a 	mov	r4,r2
8110ee80:	1105bfc0 	call	81105bfc <bFeebCh2SetBufferSize>
		            					bFeebCh2SetBufferSize((unsigned char)usiLengthBlocks,1);
8110ee84:	e0bff617 	ldw	r2,-40(fp)
8110ee88:	10803fcc 	andi	r2,r2,255
8110ee8c:	01400044 	movi	r5,1
8110ee90:	1009883a 	mov	r4,r2
8110ee94:	1105bfc0 	call	81105bfc <bFeebCh2SetBufferSize>
8110ee98:	00000306 	br	8110eea8 <vFeeTask+0x12f0>
									//bFeebCh2SetBufferSize((unsigned char)usiLengthBlocks,1);
									//bFeebCh1SetBufferSize((unsigned char)usiLengthBlocks,0);
									//bFeebCh1SetBufferSize((unsigned char)usiLengthBlocks,1);
		                    	} else {

		                    		bFinal = FALSE;
8110ee9c:	e03ff815 	stw	zero,-32(fp)
		                    		usiLengthBlocks = SDMA_MAX_BLOCKS;
8110eea0:	00800404 	movi	r2,16
8110eea4:	e0bff615 	stw	r2,-40(fp)
		                    	}



		                    	if ( ucMemUsing == 0  ) {
8110eea8:	e0bff303 	ldbu	r2,-52(fp)
8110eeac:	1000181e 	bne	r2,zero,8110ef10 <vFeeTask+0x1358>
		                    		//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
									#ifdef DEBUG_ON
										fprintf(fp,"\n-- bSdmaDmaM1Transfer \n ");
8110eeb0:	d0a06217 	ldw	r2,-32376(gp)
8110eeb4:	100f883a 	mov	r7,r2
8110eeb8:	01800644 	movi	r6,25
8110eebc:	01400044 	movi	r5,1
8110eec0:	01204574 	movhi	r4,33045
8110eec4:	2132ba04 	addi	r4,r4,-13592
8110eec8:	1121c7c0 	call	81121c7c <fwrite>
									#endif
		                    		bDmaReturn = bSdmaDmaM1Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)usiLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
8110eecc:	e0bff417 	ldw	r2,-48(fp)
8110eed0:	10800217 	ldw	r2,8(r2)
8110eed4:	1011883a 	mov	r8,r2
8110eed8:	e0bff617 	ldw	r2,-40(fp)
8110eedc:	10ffffcc 	andi	r3,r2,65535
8110eee0:	d0a05603 	ldbu	r2,-32424(gp)
8110eee4:	11003fcc 	andi	r4,r2,255
8110eee8:	d0a05317 	ldw	r2,-32436(gp)
8110eeec:	10800043 	ldbu	r2,1(r2)
8110eef0:	10803fcc 	andi	r2,r2,255
8110eef4:	100f883a 	mov	r7,r2
8110eef8:	200d883a 	mov	r6,r4
8110eefc:	180b883a 	mov	r5,r3
8110ef00:	4009883a 	mov	r4,r8
8110ef04:	1103c900 	call	81103c90 <bSdmaDmaM1Transfer>
8110ef08:	e0bff715 	stw	r2,-36(fp)
8110ef0c:	00001706 	br	8110ef6c <vFeeTask+0x13b4>

		                    	} else {
									#ifdef DEBUG_ON
										fprintf(fp,"\n-- bSdmaDmaM2Transfer \n ");
8110ef10:	d0a06217 	ldw	r2,-32376(gp)
8110ef14:	100f883a 	mov	r7,r2
8110ef18:	01800644 	movi	r6,25
8110ef1c:	01400044 	movi	r5,1
8110ef20:	01204574 	movhi	r4,33045
8110ef24:	2132c104 	addi	r4,r4,-13564
8110ef28:	1121c7c0 	call	81121c7c <fwrite>
									#endif
		                    		//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
		                    		bDmaReturn = bSdmaDmaM2Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)usiLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
8110ef2c:	e0bff417 	ldw	r2,-48(fp)
8110ef30:	10800217 	ldw	r2,8(r2)
8110ef34:	1011883a 	mov	r8,r2
8110ef38:	e0bff617 	ldw	r2,-40(fp)
8110ef3c:	10ffffcc 	andi	r3,r2,65535
8110ef40:	d0a05603 	ldbu	r2,-32424(gp)
8110ef44:	11003fcc 	andi	r4,r2,255
8110ef48:	d0a05317 	ldw	r2,-32436(gp)
8110ef4c:	10800043 	ldbu	r2,1(r2)
8110ef50:	10803fcc 	andi	r2,r2,255
8110ef54:	100f883a 	mov	r7,r2
8110ef58:	200d883a 	mov	r6,r4
8110ef5c:	180b883a 	mov	r5,r3
8110ef60:	4009883a 	mov	r4,r8
8110ef64:	11041c40 	call	811041c4 <bSdmaDmaM2Transfer>
8110ef68:	e0bff715 	stw	r2,-36(fp)
		                    	}

		                    	OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110ef6c:	e0fff303 	ldbu	r3,-52(fp)
8110ef70:	00a045b4 	movhi	r2,33046
8110ef74:	108f4404 	addi	r2,r2,15632
8110ef78:	180690fa 	slli	r3,r3,3
8110ef7c:	10c5883a 	add	r2,r2,r3
8110ef80:	10800017 	ldw	r2,0(r2)
8110ef84:	1009883a 	mov	r4,r2
8110ef88:	113d0b00 	call	8113d0b0 <OSMutexPost>
		                    	pxNFee->xControl.bDMALocked = FALSE;
8110ef8c:	d0a05317 	ldw	r2,-32436(gp)
8110ef90:	10002215 	stw	zero,136(r2)

								#ifdef DEBUG_ON
									fprintf(fp,"\n-- verificacao bDmaReturn \n ");
8110ef94:	d0a06217 	ldw	r2,-32376(gp)
8110ef98:	100f883a 	mov	r7,r2
8110ef9c:	01800744 	movi	r6,29
8110efa0:	01400044 	movi	r5,1
8110efa4:	01204574 	movhi	r4,33045
8110efa8:	2132c804 	addi	r4,r4,-13536
8110efac:	1121c7c0 	call	81121c7c <fwrite>
								#endif
		                    	if ( bDmaReturn == TRUE ) {
8110efb0:	e0bff717 	ldw	r2,-36(fp)
8110efb4:	10800058 	cmpnei	r2,r2,1
8110efb8:	1000161e 	bne	r2,zero,8110f014 <vFeeTask+0x145c>

									#ifdef DEBUG_ON
										fprintf(fp,"\n-- xCcdMapLocal->ulBlockI = %lu \n ", xCcdMapLocal->ulBlockI);
8110efbc:	d0e06217 	ldw	r3,-32376(gp)
8110efc0:	e0bff417 	ldw	r2,-48(fp)
8110efc4:	10800117 	ldw	r2,4(r2)
8110efc8:	100d883a 	mov	r6,r2
8110efcc:	01604574 	movhi	r5,33045
8110efd0:	2972d004 	addi	r5,r5,-13504
8110efd4:	1809883a 	mov	r4,r3
8110efd8:	11215e00 	call	811215e0 <fprintf>
									#endif

									/* Value of xCcdMapLocal->ulAddrI already set in the last iteration */
									xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*usiLengthBlocks;
8110efdc:	e0bff417 	ldw	r2,-48(fp)
8110efe0:	10c00217 	ldw	r3,8(r2)
8110efe4:	e0bff617 	ldw	r2,-40(fp)
8110efe8:	10802224 	muli	r2,r2,136
8110efec:	1887883a 	add	r3,r3,r2
8110eff0:	e0bff417 	ldw	r2,-48(fp)
8110eff4:	10c00215 	stw	r3,8(r2)
									xCcdMapLocal->ulBlockI += usiLengthBlocks;
8110eff8:	e0bff417 	ldw	r2,-48(fp)
8110effc:	10c00117 	ldw	r3,4(r2)
8110f000:	e0bff617 	ldw	r2,-40(fp)
8110f004:	1887883a 	add	r3,r3,r2
8110f008:	e0bff417 	ldw	r2,-48(fp)
8110f00c:	10c00115 	stw	r3,4(r2)
8110f010:	00000806 	br	8110f034 <vFeeTask+0x147c>
									//bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);


		                    	} else {
									#ifdef DEBUG_ON
										fprintf(fp,"\n-- Can't write in the DMA \n ");
8110f014:	d0a06217 	ldw	r2,-32376(gp)
8110f018:	100f883a 	mov	r7,r2
8110f01c:	01800744 	movi	r6,29
8110f020:	01400044 	movi	r5,1
8110f024:	01204574 	movhi	r4,33045
8110f028:	2132d904 	addi	r4,r4,-13468
8110f02c:	1121c7c0 	call	81121c7c <fwrite>
									#endif
									bFinal = FALSE;
8110f030:	e03ff815 	stw	zero,-32(fp)
		                    	}


		                        /* Send message telling to controller that is not using the DMA any more */
								bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
8110f034:	d0a05317 	ldw	r2,-32436(gp)
8110f038:	10800003 	ldbu	r2,0(r2)
8110f03c:	10803fcc 	andi	r2,r2,255
8110f040:	100d883a 	mov	r6,r2
8110f044:	000b883a 	mov	r5,zero
8110f048:	01002044 	movi	r4,129
8110f04c:	1110ac40 	call	81110ac4 <bSendGiveBackNFeeCtrl>
										fprintf(fp,"\nblock: %lu ", xCcdMapLocal->ulBlockI);
									#endif
								}
*/

								if ( bFinal == TRUE ) {
8110f050:	e0bff817 	ldw	r2,-32(fp)
8110f054:	10800058 	cmpnei	r2,r2,1
8110f058:	1000041e 	bne	r2,zero,8110f06c <vFeeTask+0x14b4>
									pxNFee->xControl.eMode = sEndTransmission;
8110f05c:	d0a05317 	ldw	r2,-32436(gp)
8110f060:	00c002c4 	movi	r3,11
8110f064:	10c02c15 	stw	r3,176(r2)
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110f068:	00007306 	br	8110f238 <vFeeTask+0x1680>
*/

								if ( bFinal == TRUE ) {
									pxNFee->xControl.eMode = sEndTransmission;
								} else {
									bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
8110f06c:	d0a05317 	ldw	r2,-32436(gp)
8110f070:	10800003 	ldbu	r2,0(r2)
8110f074:	10803fcc 	andi	r2,r2,255
8110f078:	100d883a 	mov	r6,r2
8110f07c:	000b883a 	mov	r5,zero
8110f080:	01002004 	movi	r4,128
8110f084:	1110a200 	call	81110a20 <bSendRequestNFeeCtrl>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110f088:	00006b06 	br	8110f238 <vFeeTask+0x1680>
									bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
								}

		                    }
						} else {
							vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
8110f08c:	d0a05317 	ldw	r2,-32436(gp)
8110f090:	e0fffe17 	ldw	r3,-8(fp)
8110f094:	180b883a 	mov	r5,r3
8110f098:	1009883a 	mov	r4,r2
8110f09c:	110f7e80 	call	8110f7e8 <vQCmdFEEinFullPattern>

							if ( pxNFee->xControl.bWatingSync == FALSE ) {
8110f0a0:	d0a05317 	ldw	r2,-32436(gp)
8110f0a4:	10802817 	ldw	r2,160(r2)
8110f0a8:	1000631e 	bne	r2,zero,8110f238 <vFeeTask+0x1680>
								pxNFee->xControl.eMode = pxNFee->xControl.eNextMode;
8110f0ac:	d0a05317 	ldw	r2,-32436(gp)
8110f0b0:	d0e05317 	ldw	r3,-32436(gp)
8110f0b4:	18c02d17 	ldw	r3,180(r3)
8110f0b8:	10c02c15 	stw	r3,176(r2)
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110f0bc:	00005e06 	br	8110f238 <vFeeTask+0x1680>
							}
						}

				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110f0c0:	d0e06217 	ldw	r3,-32376(gp)
8110f0c4:	d0a05317 	ldw	r2,-32436(gp)
8110f0c8:	10800003 	ldbu	r2,0(r2)
8110f0cc:	10803fcc 	andi	r2,r2,255
8110f0d0:	100d883a 	mov	r6,r2
8110f0d4:	01604574 	movhi	r5,33045
8110f0d8:	29722f04 	addi	r5,r5,-14148
8110f0dc:	1809883a 	mov	r4,r3
8110f0e0:	11215e00 	call	811215e0 <fprintf>
					#endif
				}

				break;
8110f0e4:	00005406 	br	8110f238 <vFeeTask+0x1680>

			case sEndTransmission:

				pxNFee->xControl.bWatingSync = TRUE;
8110f0e8:	d0a05317 	ldw	r2,-32436(gp)
8110f0ec:	00c00044 	movi	r3,1
8110f0f0:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110f0f4:	d0a05317 	ldw	r2,-32436(gp)
8110f0f8:	10002315 	stw	zero,140(r2)

				if ( xDefaults.bDataPacket == TRUE ) {
8110f0fc:	00a045b4 	movhi	r2,33046
8110f100:	109c0004 	addi	r2,r2,28672
8110f104:	10800817 	ldw	r2,32(r2)
8110f108:	10800058 	cmpnei	r2,r2,1
8110f10c:	1000111e 	bne	r2,zero,8110f154 <vFeeTask+0x159c>

					if ( pxNFee->xControl.eNextMode == sToFeeStandBy ) {
8110f110:	d0a05317 	ldw	r2,-32436(gp)
8110f114:	10802d17 	ldw	r2,180(r2)
8110f118:	10800198 	cmpnei	r2,r2,6
8110f11c:	1000071e 	bne	r2,zero,8110f13c <vFeeTask+0x1584>
						pxNFee->xControl.eMode =  sFeeWaitingSync;
8110f120:	d0a05317 	ldw	r2,-32436(gp)
8110f124:	00c00304 	movi	r3,12
8110f128:	10c02c15 	stw	r3,176(r2)
						pxNFee->xControl.eNextMode =  sToFeeStandBy;
8110f12c:	d0a05317 	ldw	r2,-32436(gp)
8110f130:	00c00184 	movi	r3,6
8110f134:	10c02d15 	stw	r3,180(r2)
8110f138:	00000606 	br	8110f154 <vFeeTask+0x159c>
					} else {
						pxNFee->xControl.eMode =  sNextPatternIteration;
8110f13c:	d0a05317 	ldw	r2,-32436(gp)
8110f140:	00c00284 	movi	r3,10
8110f144:	10c02c15 	stw	r3,176(r2)
						pxNFee->xControl.eNextMode =  sFeeWaitingSync;
8110f148:	d0a05317 	ldw	r2,-32436(gp)
8110f14c:	00c00304 	movi	r3,12
8110f150:	10c02d15 	stw	r3,180(r2)

				//pxNFee->xControl.eMode =  sFeeWaitingSync;
				//pxNFee->xControl.eNextMode =  sToFeeStandBy;


				bFinal = FALSE;
8110f154:	e03ff815 	stw	zero,-32(fp)
				break;
8110f158:	00003806 	br	8110f23c <vFeeTask+0x1684>

			case sFeeWaitingSync:

				#ifdef DEBUG_ON
					fprintf(fp,"NFEE-%hu Task: (sFeeWaitingSync)\n", pxNFee->ucId);
8110f15c:	d0e06217 	ldw	r3,-32376(gp)
8110f160:	d0a05317 	ldw	r2,-32436(gp)
8110f164:	10800003 	ldbu	r2,0(r2)
8110f168:	10803fcc 	andi	r2,r2,255
8110f16c:	100d883a 	mov	r6,r2
8110f170:	01604574 	movhi	r5,33045
8110f174:	2972e104 	addi	r5,r5,-13436
8110f178:	1809883a 	mov	r4,r3
8110f17c:	11215e00 	call	811215e0 <fprintf>
				#endif

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110f180:	d0a05317 	ldw	r2,-32436(gp)
8110f184:	10800003 	ldbu	r2,0(r2)
8110f188:	10803fcc 	andi	r2,r2,255
8110f18c:	1085883a 	add	r2,r2,r2
8110f190:	1087883a 	add	r3,r2,r2
8110f194:	d0a06a04 	addi	r2,gp,-32344
8110f198:	1885883a 	add	r2,r3,r2
8110f19c:	10800017 	ldw	r2,0(r2)
8110f1a0:	e0fffd04 	addi	r3,fp,-12
8110f1a4:	180d883a 	mov	r6,r3
8110f1a8:	000b883a 	mov	r5,zero
8110f1ac:	1009883a 	mov	r4,r2
8110f1b0:	113dc200 	call	8113dc20 <OSQPend>
8110f1b4:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code != OS_ERR_NONE ) {
8110f1b8:	e0bffd03 	ldbu	r2,-12(fp)
8110f1bc:	10803fcc 	andi	r2,r2,255
8110f1c0:	10000a26 	beq	r2,zero,8110f1ec <vFeeTask+0x1634>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ (sFeeWaitingSync)\n", pxNFee->ucId);
8110f1c4:	d0e06217 	ldw	r3,-32376(gp)
8110f1c8:	d0a05317 	ldw	r2,-32436(gp)
8110f1cc:	10800003 	ldbu	r2,0(r2)
8110f1d0:	10803fcc 	andi	r2,r2,255
8110f1d4:	100d883a 	mov	r6,r2
8110f1d8:	01604574 	movhi	r5,33045
8110f1dc:	2972ea04 	addi	r5,r5,-13400
8110f1e0:	1809883a 	mov	r4,r3
8110f1e4:	11215e00 	call	811215e0 <fprintf>
					#endif
				} else {
					vQCmdFEEinWaitingSync( pxNFee, uiCmdFEE.ulWord  );
				}

				break;
8110f1e8:	00001406 	br	8110f23c <vFeeTask+0x1684>
				if ( error_code != OS_ERR_NONE ) {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ (sFeeWaitingSync)\n", pxNFee->ucId);
					#endif
				} else {
					vQCmdFEEinWaitingSync( pxNFee, uiCmdFEE.ulWord  );
8110f1ec:	d0a05317 	ldw	r2,-32436(gp)
8110f1f0:	e0fffe17 	ldw	r3,-8(fp)
8110f1f4:	180b883a 	mov	r5,r3
8110f1f8:	1009883a 	mov	r4,r2
8110f1fc:	110f2400 	call	8110f240 <vQCmdFEEinWaitingSync>
				}

				break;
8110f200:	00000e06 	br	8110f23c <vFeeTask+0x1684>


			default:
				pxNFee->xControl.eMode = sToFeeConfig;
8110f204:	d0a05317 	ldw	r2,-32436(gp)
8110f208:	00c00144 	movi	r3,5
8110f20c:	10c02c15 	stw	r3,176(r2)
				#ifdef DEBUG_ON
					fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
8110f210:	d0e06217 	ldw	r3,-32376(gp)
8110f214:	d0a05317 	ldw	r2,-32436(gp)
8110f218:	10800003 	ldbu	r2,0(r2)
8110f21c:	10803fcc 	andi	r2,r2,255
8110f220:	100d883a 	mov	r6,r2
8110f224:	01604574 	movhi	r5,33045
8110f228:	2972fb04 	addi	r5,r5,-13332
8110f22c:	1809883a 	mov	r4,r3
8110f230:	11215e00 	call	811215e0 <fprintf>
				#endif
				break;
8110f234:	00000106 	br	8110f23c <vFeeTask+0x1684>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110f238:	0001883a 	nop
					fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
				#endif
				break;
		}

	}
8110f23c:	003a7406 	br	8110dc10 <__reset+0xfb0edc10>

8110f240 <vQCmdFEEinWaitingSync>:

}

void vQCmdFEEinWaitingSync( TNFee *pxNFeeP, unsigned int cmd ) {
8110f240:	defffb04 	addi	sp,sp,-20
8110f244:	de00012e 	bgeu	sp,et,8110f24c <vQCmdFEEinWaitingSync+0xc>
8110f248:	003b68fa 	trap	3
8110f24c:	dfc00415 	stw	ra,16(sp)
8110f250:	df000315 	stw	fp,12(sp)
8110f254:	df000304 	addi	fp,sp,12
8110f258:	e13ffe15 	stw	r4,-8(fp)
8110f25c:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110f260:	e0bfff17 	ldw	r2,-4(fp)
8110f264:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110f268:	e0bffdc3 	ldbu	r2,-9(fp)
8110f26c:	10c03fcc 	andi	r3,r2,255
8110f270:	e0bffe17 	ldw	r2,-8(fp)
8110f274:	10800003 	ldbu	r2,0(r2)
8110f278:	10803fcc 	andi	r2,r2,255
8110f27c:	10800444 	addi	r2,r2,17
8110f280:	1880631e 	bne	r3,r2,8110f410 <vQCmdFEEinWaitingSync+0x1d0>

		switch (uiCmdFEEL.ucByte[2]) {
8110f284:	e0bffd83 	ldbu	r2,-10(fp)
8110f288:	10803fcc 	andi	r2,r2,255
8110f28c:	10c02860 	cmpeqi	r3,r2,161
8110f290:	18001a1e 	bne	r3,zero,8110f2fc <vQCmdFEEinWaitingSync+0xbc>
8110f294:	10c02888 	cmpgei	r3,r2,162
8110f298:	18000c1e 	bne	r3,zero,8110f2cc <vQCmdFEEinWaitingSync+0x8c>
8110f29c:	10c00120 	cmpeqi	r3,r2,4
8110f2a0:	18001f1e 	bne	r3,zero,8110f320 <vQCmdFEEinWaitingSync+0xe0>
8110f2a4:	10c00148 	cmpgei	r3,r2,5
8110f2a8:	1800031e 	bne	r3,zero,8110f2b8 <vQCmdFEEinWaitingSync+0x78>
8110f2ac:	10800060 	cmpeqi	r2,r2,1
8110f2b0:	1000121e 	bne	r2,zero,8110f2fc <vQCmdFEEinWaitingSync+0xbc>
8110f2b4:	00004c06 	br	8110f3e8 <vQCmdFEEinWaitingSync+0x1a8>
8110f2b8:	10c00220 	cmpeqi	r3,r2,8
8110f2bc:	1800221e 	bne	r3,zero,8110f348 <vQCmdFEEinWaitingSync+0x108>
8110f2c0:	108023e0 	cmpeqi	r2,r2,143
8110f2c4:	10003e1e 	bne	r2,zero,8110f3c0 <vQCmdFEEinWaitingSync+0x180>
8110f2c8:	00004706 	br	8110f3e8 <vQCmdFEEinWaitingSync+0x1a8>
8110f2cc:	10c03888 	cmpgei	r3,r2,226
8110f2d0:	1800071e 	bne	r3,zero,8110f2f0 <vQCmdFEEinWaitingSync+0xb0>
8110f2d4:	10c03808 	cmpgei	r3,r2,224
8110f2d8:	1800321e 	bne	r3,zero,8110f3a4 <vQCmdFEEinWaitingSync+0x164>
8110f2dc:	10c02920 	cmpeqi	r3,r2,164
8110f2e0:	18000f1e 	bne	r3,zero,8110f320 <vQCmdFEEinWaitingSync+0xe0>
8110f2e4:	10802a20 	cmpeqi	r2,r2,168
8110f2e8:	1000171e 	bne	r2,zero,8110f348 <vQCmdFEEinWaitingSync+0x108>
8110f2ec:	00003e06 	br	8110f3e8 <vQCmdFEEinWaitingSync+0x1a8>
8110f2f0:	10803c20 	cmpeqi	r2,r2,240
8110f2f4:	10001e1e 	bne	r2,zero,8110f370 <vQCmdFEEinWaitingSync+0x130>
8110f2f8:	00003b06 	br	8110f3e8 <vQCmdFEEinWaitingSync+0x1a8>
			case M_FEE_CONFIG:
			case M_FEE_CONFIG_FORCED: /* Standby to Config is always forced mode */
				pxNFeeP->xControl.bWatingSync = FALSE;
8110f2fc:	e0bffe17 	ldw	r2,-8(fp)
8110f300:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8110f304:	e0bffe17 	ldw	r2,-8(fp)
8110f308:	00c00144 	movi	r3,5
8110f30c:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
8110f310:	e0bffe17 	ldw	r2,-8(fp)
8110f314:	00c00144 	movi	r3,5
8110f318:	10c02d15 	stw	r3,180(r2)
				break;
8110f31c:	00003c06 	br	8110f410 <vQCmdFEEinWaitingSync+0x1d0>
			case M_FEE_STANDBY_FORCED:
			case M_FEE_STANDBY:
				pxNFeeP->xControl.bWatingSync = TRUE;
8110f320:	e0bffe17 	ldw	r2,-8(fp)
8110f324:	00c00044 	movi	r3,1
8110f328:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync; /*sSIMTestFullPattern*/
8110f32c:	e0bffe17 	ldw	r2,-8(fp)
8110f330:	00c00304 	movi	r3,12
8110f334:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110f338:	e0bffe17 	ldw	r2,-8(fp)
8110f33c:	00c00184 	movi	r3,6
8110f340:	10c02d15 	stw	r3,180(r2)
				break;
8110f344:	00003206 	br	8110f410 <vQCmdFEEinWaitingSync+0x1d0>
			case M_FEE_FULL_PATTERN:
			case M_FEE_FULL_PATTERN_FORCED: /* There are no forced mode to go to the Pattern Mode */
				pxNFeeP->xControl.bWatingSync = TRUE;
8110f348:	e0bffe17 	ldw	r2,-8(fp)
8110f34c:	00c00044 	movi	r3,1
8110f350:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
8110f354:	e0bffe17 	ldw	r2,-8(fp)
8110f358:	00c00284 	movi	r3,10
8110f35c:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
8110f360:	e0bffe17 	ldw	r2,-8(fp)
8110f364:	00c00304 	movi	r3,12
8110f368:	10c02d15 	stw	r3,180(r2)
				break;
8110f36c:	00002806 	br	8110f410 <vQCmdFEEinWaitingSync+0x1d0>
			case M_FEE_RMAP:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: RMAP Message Received\n", pxNFeeP->ucId);
8110f370:	d0e06217 	ldw	r3,-32376(gp)
8110f374:	e0bffe17 	ldw	r2,-8(fp)
8110f378:	10800003 	ldbu	r2,0(r2)
8110f37c:	10803fcc 	andi	r2,r2,255
8110f380:	100d883a 	mov	r6,r2
8110f384:	01604574 	movhi	r5,33045
8110f388:	29730604 	addi	r5,r5,-13288
8110f38c:	1809883a 	mov	r4,r3
8110f390:	11215e00 	call	811215e0 <fprintf>
				#endif
				/* Perform some actions, check if is a valid command for this mode of operation  */
				vQCmdFeeRMAPWaitingSync( pxNFeeP, cmd );
8110f394:	e17fff17 	ldw	r5,-4(fp)
8110f398:	e13ffe17 	ldw	r4,-8(fp)
8110f39c:	111038c0 	call	8111038c <vQCmdFeeRMAPWaitingSync>
				break;
8110f3a0:	00001b06 	br	8110f410 <vQCmdFEEinWaitingSync+0x1d0>
			case M_SYNC:
			case M_MASTER_SYNC:
				/* Warning */
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
8110f3a4:	e0bffe17 	ldw	r2,-8(fp)
8110f3a8:	10c02d17 	ldw	r3,180(r2)
8110f3ac:	e0bffe17 	ldw	r2,-8(fp)
8110f3b0:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.bWatingSync = FALSE;
8110f3b4:	e0bffe17 	ldw	r2,-8(fp)
8110f3b8:	10002815 	stw	zero,160(r2)

				break;
8110f3bc:	00001406 	br	8110f410 <vQCmdFEEinWaitingSync+0x1d0>
			case M_FEE_DMA_ACCESS:
				pxNFeeP->xControl.bUsingDMA = FALSE;
8110f3c0:	e0bffe17 	ldw	r2,-8(fp)
8110f3c4:	10002315 	stw	zero,140(r2)
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
8110f3c8:	e0bffe17 	ldw	r2,-8(fp)
8110f3cc:	10800003 	ldbu	r2,0(r2)
8110f3d0:	10803fcc 	andi	r2,r2,255
8110f3d4:	100d883a 	mov	r6,r2
8110f3d8:	000b883a 	mov	r5,zero
8110f3dc:	01002044 	movi	r4,129
8110f3e0:	1110ac40 	call	81110ac4 <bSendGiveBackNFeeCtrl>
				break;
8110f3e4:	00000a06 	br	8110f410 <vQCmdFEEinWaitingSync+0x1d0>
			default:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
8110f3e8:	d0e06217 	ldw	r3,-32376(gp)
8110f3ec:	e0bffe17 	ldw	r2,-8(fp)
8110f3f0:	10800003 	ldbu	r2,0(r2)
8110f3f4:	10803fcc 	andi	r2,r2,255
8110f3f8:	100d883a 	mov	r6,r2
8110f3fc:	01604574 	movhi	r5,33045
8110f400:	29731004 	addi	r5,r5,-13248
8110f404:	1809883a 	mov	r4,r3
8110f408:	11215e00 	call	811215e0 <fprintf>
				#endif
				break;
8110f40c:	0001883a 	nop
		}
	}
}
8110f410:	0001883a 	nop
8110f414:	e037883a 	mov	sp,fp
8110f418:	dfc00117 	ldw	ra,4(sp)
8110f41c:	df000017 	ldw	fp,0(sp)
8110f420:	dec00204 	addi	sp,sp,8
8110f424:	f800283a 	ret

8110f428 <vQCmdFEEinConfig>:


void vQCmdFEEinConfig( TNFee *pxNFeeP, unsigned int cmd ) {
8110f428:	defffb04 	addi	sp,sp,-20
8110f42c:	de00012e 	bgeu	sp,et,8110f434 <vQCmdFEEinConfig+0xc>
8110f430:	003b68fa 	trap	3
8110f434:	dfc00415 	stw	ra,16(sp)
8110f438:	df000315 	stw	fp,12(sp)
8110f43c:	df000304 	addi	fp,sp,12
8110f440:	e13ffe15 	stw	r4,-8(fp)
8110f444:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110f448:	e0bfff17 	ldw	r2,-4(fp)
8110f44c:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110f450:	e0bffdc3 	ldbu	r2,-9(fp)
8110f454:	10c03fcc 	andi	r3,r2,255
8110f458:	e0bffe17 	ldw	r2,-8(fp)
8110f45c:	10800003 	ldbu	r2,0(r2)
8110f460:	10803fcc 	andi	r2,r2,255
8110f464:	10800444 	addi	r2,r2,17
8110f468:	18805a1e 	bne	r3,r2,8110f5d4 <vQCmdFEEinConfig+0x1ac>

		switch (uiCmdFEEL.ucByte[2]) {
8110f46c:	e0bffd83 	ldbu	r2,-10(fp)
8110f470:	10803fcc 	andi	r2,r2,255
8110f474:	10c02860 	cmpeqi	r3,r2,161
8110f478:	18001a1e 	bne	r3,zero,8110f4e4 <vQCmdFEEinConfig+0xbc>
8110f47c:	10c02888 	cmpgei	r3,r2,162
8110f480:	18000c1e 	bne	r3,zero,8110f4b4 <vQCmdFEEinConfig+0x8c>
8110f484:	10c00120 	cmpeqi	r3,r2,4
8110f488:	1800201e 	bne	r3,zero,8110f50c <vQCmdFEEinConfig+0xe4>
8110f48c:	10c00148 	cmpgei	r3,r2,5
8110f490:	1800031e 	bne	r3,zero,8110f4a0 <vQCmdFEEinConfig+0x78>
8110f494:	10800060 	cmpeqi	r2,r2,1
8110f498:	1000121e 	bne	r2,zero,8110f4e4 <vQCmdFEEinConfig+0xbc>
8110f49c:	00004206 	br	8110f5a8 <vQCmdFEEinConfig+0x180>
8110f4a0:	10c00220 	cmpeqi	r3,r2,8
8110f4a4:	1800221e 	bne	r3,zero,8110f530 <vQCmdFEEinConfig+0x108>
8110f4a8:	108023e0 	cmpeqi	r2,r2,143
8110f4ac:	1000341e 	bne	r2,zero,8110f580 <vQCmdFEEinConfig+0x158>
8110f4b0:	00003d06 	br	8110f5a8 <vQCmdFEEinConfig+0x180>
8110f4b4:	10c03888 	cmpgei	r3,r2,226
8110f4b8:	1800071e 	bne	r3,zero,8110f4d8 <vQCmdFEEinConfig+0xb0>
8110f4bc:	10c03808 	cmpgei	r3,r2,224
8110f4c0:	1800431e 	bne	r3,zero,8110f5d0 <vQCmdFEEinConfig+0x1a8>
8110f4c4:	10c02920 	cmpeqi	r3,r2,164
8110f4c8:	1800101e 	bne	r3,zero,8110f50c <vQCmdFEEinConfig+0xe4>
8110f4cc:	10802a20 	cmpeqi	r2,r2,168
8110f4d0:	1000171e 	bne	r2,zero,8110f530 <vQCmdFEEinConfig+0x108>
8110f4d4:	00003406 	br	8110f5a8 <vQCmdFEEinConfig+0x180>
8110f4d8:	10803c20 	cmpeqi	r2,r2,240
8110f4dc:	10001e1e 	bne	r2,zero,8110f558 <vQCmdFEEinConfig+0x130>
8110f4e0:	00003106 	br	8110f5a8 <vQCmdFEEinConfig+0x180>
			case M_FEE_CONFIG_FORCED:
			case M_FEE_CONFIG:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Already in Config mode\n", pxNFeeP->ucId);
8110f4e4:	d0e06217 	ldw	r3,-32376(gp)
8110f4e8:	e0bffe17 	ldw	r2,-8(fp)
8110f4ec:	10800003 	ldbu	r2,0(r2)
8110f4f0:	10803fcc 	andi	r2,r2,255
8110f4f4:	100d883a 	mov	r6,r2
8110f4f8:	01604574 	movhi	r5,33045
8110f4fc:	29732104 	addi	r5,r5,-13180
8110f500:	1809883a 	mov	r4,r3
8110f504:	11215e00 	call	811215e0 <fprintf>
				#endif
				break;
8110f508:	00003206 	br	8110f5d4 <vQCmdFEEinConfig+0x1ac>
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
				break;*/
			case M_FEE_STANDBY: /* Config -> StandBy is always forced mode (don't need sync) */
			case M_FEE_STANDBY_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110f50c:	e0bffe17 	ldw	r2,-8(fp)
8110f510:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeStandBy;
8110f514:	e0bffe17 	ldw	r2,-8(fp)
8110f518:	00c00184 	movi	r3,6
8110f51c:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110f520:	e0bffe17 	ldw	r2,-8(fp)
8110f524:	00c00184 	movi	r3,6
8110f528:	10c02d15 	stw	r3,180(r2)
				break;				
8110f52c:	00002906 	br	8110f5d4 <vQCmdFEEinConfig+0x1ac>
			case M_FEE_FULL_PATTERN_FORCED:
			case M_FEE_FULL_PATTERN:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: Can't go to Full Image Pattern from Config mode\n", pxNFeeP->ucId);
8110f530:	d0e06217 	ldw	r3,-32376(gp)
8110f534:	e0bffe17 	ldw	r2,-8(fp)
8110f538:	10800003 	ldbu	r2,0(r2)
8110f53c:	10803fcc 	andi	r2,r2,255
8110f540:	100d883a 	mov	r6,r2
8110f544:	01604574 	movhi	r5,33045
8110f548:	29732c04 	addi	r5,r5,-13136
8110f54c:	1809883a 	mov	r4,r3
8110f550:	11215e00 	call	811215e0 <fprintf>
				#endif
				break;
8110f554:	00001f06 	br	8110f5d4 <vQCmdFEEinConfig+0x1ac>
			case M_FEE_RMAP:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: Shouldn't receive RMAP Messages in this mode (Config Mode)\n", pxNFeeP->ucId);
8110f558:	d0e06217 	ldw	r3,-32376(gp)
8110f55c:	e0bffe17 	ldw	r2,-8(fp)
8110f560:	10800003 	ldbu	r2,0(r2)
8110f564:	10803fcc 	andi	r2,r2,255
8110f568:	100d883a 	mov	r6,r2
8110f56c:	01604574 	movhi	r5,33045
8110f570:	29733d04 	addi	r5,r5,-13068
8110f574:	1809883a 	mov	r4,r3
8110f578:	11215e00 	call	811215e0 <fprintf>
				#endif
				break;
8110f57c:	00001506 	br	8110f5d4 <vQCmdFEEinConfig+0x1ac>
			case M_FEE_DMA_ACCESS:
				pxNFeeP->xControl.bUsingDMA = FALSE;
8110f580:	e0bffe17 	ldw	r2,-8(fp)
8110f584:	10002315 	stw	zero,140(r2)
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
8110f588:	e0bffe17 	ldw	r2,-8(fp)
8110f58c:	10800003 	ldbu	r2,0(r2)
8110f590:	10803fcc 	andi	r2,r2,255
8110f594:	100d883a 	mov	r6,r2
8110f598:	000b883a 	mov	r5,zero
8110f59c:	01002044 	movi	r4,129
8110f5a0:	1110ac40 	call	81110ac4 <bSendGiveBackNFeeCtrl>
				break;
8110f5a4:	00000b06 	br	8110f5d4 <vQCmdFEEinConfig+0x1ac>
			case M_SYNC:
			case M_MASTER_SYNC:
				break;
			default:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
8110f5a8:	d0e06217 	ldw	r3,-32376(gp)
8110f5ac:	e0bffe17 	ldw	r2,-8(fp)
8110f5b0:	10800003 	ldbu	r2,0(r2)
8110f5b4:	10803fcc 	andi	r2,r2,255
8110f5b8:	100d883a 	mov	r6,r2
8110f5bc:	01604574 	movhi	r5,33045
8110f5c0:	29735004 	addi	r5,r5,-12992
8110f5c4:	1809883a 	mov	r4,r3
8110f5c8:	11215e00 	call	811215e0 <fprintf>
				#endif
				break;
8110f5cc:	00000106 	br	8110f5d4 <vQCmdFEEinConfig+0x1ac>
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
				break;
			case M_SYNC:
			case M_MASTER_SYNC:
				break;
8110f5d0:	0001883a 	nop
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				#endif
				break;
		}
	}
}
8110f5d4:	0001883a 	nop
8110f5d8:	e037883a 	mov	sp,fp
8110f5dc:	dfc00117 	ldw	ra,4(sp)
8110f5e0:	df000017 	ldw	fp,0(sp)
8110f5e4:	dec00204 	addi	sp,sp,8
8110f5e8:	f800283a 	ret

8110f5ec <vQCmdFEEinStandBy>:

void vQCmdFEEinStandBy( TNFee *pxNFeeP, unsigned int cmd ) {
8110f5ec:	defffb04 	addi	sp,sp,-20
8110f5f0:	de00012e 	bgeu	sp,et,8110f5f8 <vQCmdFEEinStandBy+0xc>
8110f5f4:	003b68fa 	trap	3
8110f5f8:	dfc00415 	stw	ra,16(sp)
8110f5fc:	df000315 	stw	fp,12(sp)
8110f600:	df000304 	addi	fp,sp,12
8110f604:	e13ffe15 	stw	r4,-8(fp)
8110f608:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110f60c:	e0bfff17 	ldw	r2,-4(fp)
8110f610:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110f614:	e0bffdc3 	ldbu	r2,-9(fp)
8110f618:	10c03fcc 	andi	r3,r2,255
8110f61c:	e0bffe17 	ldw	r2,-8(fp)
8110f620:	10800003 	ldbu	r2,0(r2)
8110f624:	10803fcc 	andi	r2,r2,255
8110f628:	10800444 	addi	r2,r2,17
8110f62c:	1880681e 	bne	r3,r2,8110f7d0 <vQCmdFEEinStandBy+0x1e4>

		switch (uiCmdFEEL.ucByte[2]) {
8110f630:	e0bffd83 	ldbu	r2,-10(fp)
8110f634:	10803fcc 	andi	r2,r2,255
8110f638:	10c02860 	cmpeqi	r3,r2,161
8110f63c:	18001a1e 	bne	r3,zero,8110f6a8 <vQCmdFEEinStandBy+0xbc>
8110f640:	10c02888 	cmpgei	r3,r2,162
8110f644:	18000c1e 	bne	r3,zero,8110f678 <vQCmdFEEinStandBy+0x8c>
8110f648:	10c00120 	cmpeqi	r3,r2,4
8110f64c:	18001f1e 	bne	r3,zero,8110f6cc <vQCmdFEEinStandBy+0xe0>
8110f650:	10c00148 	cmpgei	r3,r2,5
8110f654:	1800031e 	bne	r3,zero,8110f664 <vQCmdFEEinStandBy+0x78>
8110f658:	10800060 	cmpeqi	r2,r2,1
8110f65c:	1000121e 	bne	r2,zero,8110f6a8 <vQCmdFEEinStandBy+0xbc>
8110f660:	00005006 	br	8110f7a4 <vQCmdFEEinStandBy+0x1b8>
8110f664:	10c00220 	cmpeqi	r3,r2,8
8110f668:	1800221e 	bne	r3,zero,8110f6f4 <vQCmdFEEinStandBy+0x108>
8110f66c:	108023e0 	cmpeqi	r2,r2,143
8110f670:	1000421e 	bne	r2,zero,8110f77c <vQCmdFEEinStandBy+0x190>
8110f674:	00004b06 	br	8110f7a4 <vQCmdFEEinStandBy+0x1b8>
8110f678:	10c03888 	cmpgei	r3,r2,226
8110f67c:	1800071e 	bne	r3,zero,8110f69c <vQCmdFEEinStandBy+0xb0>
8110f680:	10c03808 	cmpgei	r3,r2,224
8110f684:	1800321e 	bne	r3,zero,8110f750 <vQCmdFEEinStandBy+0x164>
8110f688:	10c02920 	cmpeqi	r3,r2,164
8110f68c:	18000f1e 	bne	r3,zero,8110f6cc <vQCmdFEEinStandBy+0xe0>
8110f690:	10802a20 	cmpeqi	r2,r2,168
8110f694:	1000171e 	bne	r2,zero,8110f6f4 <vQCmdFEEinStandBy+0x108>
8110f698:	00004206 	br	8110f7a4 <vQCmdFEEinStandBy+0x1b8>
8110f69c:	10803c20 	cmpeqi	r2,r2,240
8110f6a0:	10001e1e 	bne	r2,zero,8110f71c <vQCmdFEEinStandBy+0x130>
8110f6a4:	00003f06 	br	8110f7a4 <vQCmdFEEinStandBy+0x1b8>
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
				break;*/
			case M_FEE_CONFIG:
			case M_FEE_CONFIG_FORCED: /* Standby to Config is always forced mode */
				pxNFeeP->xControl.bWatingSync = FALSE;
8110f6a8:	e0bffe17 	ldw	r2,-8(fp)
8110f6ac:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8110f6b0:	e0bffe17 	ldw	r2,-8(fp)
8110f6b4:	00c00144 	movi	r3,5
8110f6b8:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
8110f6bc:	e0bffe17 	ldw	r2,-8(fp)
8110f6c0:	00c00144 	movi	r3,5
8110f6c4:	10c02d15 	stw	r3,180(r2)
				break;				
8110f6c8:	00004106 	br	8110f7d0 <vQCmdFEEinStandBy+0x1e4>
			case M_FEE_STANDBY_FORCED:
			case M_FEE_STANDBY:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Already in Stand by mode\n", pxNFeeP->ucId);
8110f6cc:	d0e06217 	ldw	r3,-32376(gp)
8110f6d0:	e0bffe17 	ldw	r2,-8(fp)
8110f6d4:	10800003 	ldbu	r2,0(r2)
8110f6d8:	10803fcc 	andi	r2,r2,255
8110f6dc:	100d883a 	mov	r6,r2
8110f6e0:	01604574 	movhi	r5,33045
8110f6e4:	29736104 	addi	r5,r5,-12924
8110f6e8:	1809883a 	mov	r4,r3
8110f6ec:	11215e00 	call	811215e0 <fprintf>
				#endif
				break;
8110f6f0:	00003706 	br	8110f7d0 <vQCmdFEEinStandBy+0x1e4>
			case M_FEE_FULL_PATTERN:
			case M_FEE_FULL_PATTERN_FORCED: /* There are no forced mode to go to the Pattern Mode */
				pxNFeeP->xControl.bWatingSync = TRUE;
8110f6f4:	e0bffe17 	ldw	r2,-8(fp)
8110f6f8:	00c00044 	movi	r3,1
8110f6fc:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
8110f700:	e0bffe17 	ldw	r2,-8(fp)
8110f704:	00c00284 	movi	r3,10
8110f708:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
8110f70c:	e0bffe17 	ldw	r2,-8(fp)
8110f710:	00c00304 	movi	r3,12
8110f714:	10c02d15 	stw	r3,180(r2)
				break;
8110f718:	00002d06 	br	8110f7d0 <vQCmdFEEinStandBy+0x1e4>

			case M_FEE_RMAP:
				vQCmdFeeRMAPinStandBy( pxNFeeP, cmd );
8110f71c:	e17fff17 	ldw	r5,-4(fp)
8110f720:	e13ffe17 	ldw	r4,-8(fp)
8110f724:	110fa180 	call	8110fa18 <vQCmdFeeRMAPinStandBy>

				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: RMAP Message Received\n", pxNFeeP->ucId);
8110f728:	d0e06217 	ldw	r3,-32376(gp)
8110f72c:	e0bffe17 	ldw	r2,-8(fp)
8110f730:	10800003 	ldbu	r2,0(r2)
8110f734:	10803fcc 	andi	r2,r2,255
8110f738:	100d883a 	mov	r6,r2
8110f73c:	01604574 	movhi	r5,33045
8110f740:	29730604 	addi	r5,r5,-13288
8110f744:	1809883a 	mov	r4,r3
8110f748:	11215e00 	call	811215e0 <fprintf>
				#endif
				/* Perform some actions, check if is a valid command for this mode of operation  */

				break;
8110f74c:	00002006 	br	8110f7d0 <vQCmdFEEinStandBy+0x1e4>


			case M_SYNC:
			case M_MASTER_SYNC:
				/* Warning */
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
8110f750:	e0bffe17 	ldw	r2,-8(fp)
8110f754:	10802c17 	ldw	r2,176(r2)
8110f758:	10800318 	cmpnei	r2,r2,12
8110f75c:	10001b1e 	bne	r2,zero,8110f7cc <vQCmdFEEinStandBy+0x1e0>
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
8110f760:	e0bffe17 	ldw	r2,-8(fp)
8110f764:	10c02d17 	ldw	r3,180(r2)
8110f768:	e0bffe17 	ldw	r2,-8(fp)
8110f76c:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.bWatingSync = FALSE;
8110f770:	e0bffe17 	ldw	r2,-8(fp)
8110f774:	10002815 	stw	zero,160(r2)
				}
				break;
8110f778:	00001406 	br	8110f7cc <vQCmdFEEinStandBy+0x1e0>
			case M_FEE_DMA_ACCESS:
				pxNFeeP->xControl.bUsingDMA = FALSE;
8110f77c:	e0bffe17 	ldw	r2,-8(fp)
8110f780:	10002315 	stw	zero,140(r2)
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
8110f784:	e0bffe17 	ldw	r2,-8(fp)
8110f788:	10800003 	ldbu	r2,0(r2)
8110f78c:	10803fcc 	andi	r2,r2,255
8110f790:	100d883a 	mov	r6,r2
8110f794:	000b883a 	mov	r5,zero
8110f798:	01002044 	movi	r4,129
8110f79c:	1110ac40 	call	81110ac4 <bSendGiveBackNFeeCtrl>
				break;
8110f7a0:	00000b06 	br	8110f7d0 <vQCmdFEEinStandBy+0x1e4>
			default:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
8110f7a4:	d0e06217 	ldw	r3,-32376(gp)
8110f7a8:	e0bffe17 	ldw	r2,-8(fp)
8110f7ac:	10800003 	ldbu	r2,0(r2)
8110f7b0:	10803fcc 	andi	r2,r2,255
8110f7b4:	100d883a 	mov	r6,r2
8110f7b8:	01604574 	movhi	r5,33045
8110f7bc:	29731004 	addi	r5,r5,-13248
8110f7c0:	1809883a 	mov	r4,r3
8110f7c4:	11215e00 	call	811215e0 <fprintf>
				#endif
				break;
8110f7c8:	00000106 	br	8110f7d0 <vQCmdFEEinStandBy+0x1e4>
				/* Warning */
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
					pxNFeeP->xControl.bWatingSync = FALSE;
				}
				break;
8110f7cc:	0001883a 	nop
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
				#endif
				break;
		}
	}
}
8110f7d0:	0001883a 	nop
8110f7d4:	e037883a 	mov	sp,fp
8110f7d8:	dfc00117 	ldw	ra,4(sp)
8110f7dc:	df000017 	ldw	fp,0(sp)
8110f7e0:	dec00204 	addi	sp,sp,8
8110f7e4:	f800283a 	ret

8110f7e8 <vQCmdFEEinFullPattern>:



void vQCmdFEEinFullPattern( TNFee *pxNFeeP, unsigned int cmd ){
8110f7e8:	defffb04 	addi	sp,sp,-20
8110f7ec:	de00012e 	bgeu	sp,et,8110f7f4 <vQCmdFEEinFullPattern+0xc>
8110f7f0:	003b68fa 	trap	3
8110f7f4:	dfc00415 	stw	ra,16(sp)
8110f7f8:	df000315 	stw	fp,12(sp)
8110f7fc:	df000304 	addi	fp,sp,12
8110f800:	e13ffe15 	stw	r4,-8(fp)
8110f804:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110f808:	e0bfff17 	ldw	r2,-4(fp)
8110f80c:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110f810:	e0bffdc3 	ldbu	r2,-9(fp)
8110f814:	10c03fcc 	andi	r3,r2,255
8110f818:	e0bffe17 	ldw	r2,-8(fp)
8110f81c:	10800003 	ldbu	r2,0(r2)
8110f820:	10803fcc 	andi	r2,r2,255
8110f824:	10800444 	addi	r2,r2,17
8110f828:	1880751e 	bne	r3,r2,8110fa00 <vQCmdFEEinFullPattern+0x218>

		switch (uiCmdFEEL.ucByte[2]) {
8110f82c:	e0bffd83 	ldbu	r2,-10(fp)
8110f830:	10803fcc 	andi	r2,r2,255
8110f834:	10c02860 	cmpeqi	r3,r2,161
8110f838:	1800181e 	bne	r3,zero,8110f89c <vQCmdFEEinFullPattern+0xb4>
8110f83c:	10c02888 	cmpgei	r3,r2,162
8110f840:	18000c1e 	bne	r3,zero,8110f874 <vQCmdFEEinFullPattern+0x8c>
8110f844:	10c000a0 	cmpeqi	r3,r2,2
8110f848:	18006a1e 	bne	r3,zero,8110f9f4 <vQCmdFEEinFullPattern+0x20c>
8110f84c:	10c000c8 	cmpgei	r3,r2,3
8110f850:	1800031e 	bne	r3,zero,8110f860 <vQCmdFEEinFullPattern+0x78>
8110f854:	10800060 	cmpeqi	r2,r2,1
8110f858:	1000101e 	bne	r2,zero,8110f89c <vQCmdFEEinFullPattern+0xb4>
8110f85c:	00005b06 	br	8110f9cc <vQCmdFEEinFullPattern+0x1e4>
8110f860:	10c00120 	cmpeqi	r3,r2,4
8110f864:	1800161e 	bne	r3,zero,8110f8c0 <vQCmdFEEinFullPattern+0xd8>
8110f868:	10800220 	cmpeqi	r2,r2,8
8110f86c:	1000351e 	bne	r2,zero,8110f944 <vQCmdFEEinFullPattern+0x15c>
8110f870:	00005606 	br	8110f9cc <vQCmdFEEinFullPattern+0x1e4>
8110f874:	10c03888 	cmpgei	r3,r2,226
8110f878:	1800051e 	bne	r3,zero,8110f890 <vQCmdFEEinFullPattern+0xa8>
8110f87c:	10c03808 	cmpgei	r3,r2,224
8110f880:	1800471e 	bne	r3,zero,8110f9a0 <vQCmdFEEinFullPattern+0x1b8>
8110f884:	10802920 	cmpeqi	r2,r2,164
8110f888:	1000251e 	bne	r2,zero,8110f920 <vQCmdFEEinFullPattern+0x138>
8110f88c:	00004f06 	br	8110f9cc <vQCmdFEEinFullPattern+0x1e4>
8110f890:	10803c20 	cmpeqi	r2,r2,240
8110f894:	1000351e 	bne	r2,zero,8110f96c <vQCmdFEEinFullPattern+0x184>
8110f898:	00004c06 	br	8110f9cc <vQCmdFEEinFullPattern+0x1e4>
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
				break;*/
			case M_FEE_CONFIG:
			case M_FEE_CONFIG_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110f89c:	e0bffe17 	ldw	r2,-8(fp)
8110f8a0:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8110f8a4:	e0bffe17 	ldw	r2,-8(fp)
8110f8a8:	00c00144 	movi	r3,5
8110f8ac:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
8110f8b0:	e0bffe17 	ldw	r2,-8(fp)
8110f8b4:	00c00144 	movi	r3,5
8110f8b8:	10c02d15 	stw	r3,180(r2)
				break;				
8110f8bc:	00005006 	br	8110fa00 <vQCmdFEEinFullPattern+0x218>
				break;
			case M_FEE_STANDBY:
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;*/ /* To finish the actual transfer only when sync comes */
				if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
8110f8c0:	e0bffe17 	ldw	r2,-8(fp)
8110f8c4:	10802c17 	ldw	r2,176(r2)
8110f8c8:	10800298 	cmpnei	r2,r2,10
8110f8cc:	10000a1e 	bne	r2,zero,8110f8f8 <vQCmdFEEinFullPattern+0x110>
					pxNFeeP->xControl.bWatingSync = TRUE;
8110f8d0:	e0bffe17 	ldw	r2,-8(fp)
8110f8d4:	00c00044 	movi	r3,1
8110f8d8:	10c02815 	stw	r3,160(r2)
					pxNFeeP->xControl.eMode = sFeeWaitingSync;
8110f8dc:	e0bffe17 	ldw	r2,-8(fp)
8110f8e0:	00c00304 	movi	r3,12
8110f8e4:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110f8e8:	e0bffe17 	ldw	r2,-8(fp)
8110f8ec:	00c00184 	movi	r3,6
8110f8f0:	10c02d15 	stw	r3,180(r2)
					pxNFeeP->xControl.bWatingSync = TRUE;
					pxNFeeP->xControl.eMode = sFeeTestFullPattern;
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
				}

				break;
8110f8f4:	00004206 	br	8110fa00 <vQCmdFEEinFullPattern+0x218>
				if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
					pxNFeeP->xControl.bWatingSync = TRUE;
					pxNFeeP->xControl.eMode = sFeeWaitingSync;
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
				} else {
					pxNFeeP->xControl.bWatingSync = TRUE;
8110f8f8:	e0bffe17 	ldw	r2,-8(fp)
8110f8fc:	00c00044 	movi	r3,1
8110f900:	10c02815 	stw	r3,160(r2)
					pxNFeeP->xControl.eMode = sFeeTestFullPattern;
8110f904:	e0bffe17 	ldw	r2,-8(fp)
8110f908:	00c00104 	movi	r3,4
8110f90c:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110f910:	e0bffe17 	ldw	r2,-8(fp)
8110f914:	00c00184 	movi	r3,6
8110f918:	10c02d15 	stw	r3,180(r2)
				}

				break;
8110f91c:	00003806 	br	8110fa00 <vQCmdFEEinFullPattern+0x218>
			case M_FEE_STANDBY_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110f920:	e0bffe17 	ldw	r2,-8(fp)
8110f924:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeStandBy;
8110f928:	e0bffe17 	ldw	r2,-8(fp)
8110f92c:	00c00184 	movi	r3,6
8110f930:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */
8110f934:	e0bffe17 	ldw	r2,-8(fp)
8110f938:	00c00184 	movi	r3,6
8110f93c:	10c02d15 	stw	r3,180(r2)
				break;				
8110f940:	00002f06 	br	8110fa00 <vQCmdFEEinFullPattern+0x218>
			case M_FEE_FULL_PATTERN:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
8110f944:	d0e06217 	ldw	r3,-32376(gp)
8110f948:	e0bffe17 	ldw	r2,-8(fp)
8110f94c:	10800003 	ldbu	r2,0(r2)
8110f950:	10803fcc 	andi	r2,r2,255
8110f954:	100d883a 	mov	r6,r2
8110f958:	01604574 	movhi	r5,33045
8110f95c:	29736c04 	addi	r5,r5,-12880
8110f960:	1809883a 	mov	r4,r3
8110f964:	11215e00 	call	811215e0 <fprintf>
				#endif
				break;
8110f968:	00002506 	br	8110fa00 <vQCmdFEEinFullPattern+0x218>
			case M_FEE_RMAP:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: RMAP Message Received\n", pxNFeeP->ucId);
8110f96c:	d0e06217 	ldw	r3,-32376(gp)
8110f970:	e0bffe17 	ldw	r2,-8(fp)
8110f974:	10800003 	ldbu	r2,0(r2)
8110f978:	10803fcc 	andi	r2,r2,255
8110f97c:	100d883a 	mov	r6,r2
8110f980:	01604574 	movhi	r5,33045
8110f984:	29730604 	addi	r5,r5,-13288
8110f988:	1809883a 	mov	r4,r3
8110f98c:	11215e00 	call	811215e0 <fprintf>
				#endif

				/* Perform some actions, check if is a valid command for this mode of operation  */
				vQCmdFeeRMAPinFullPattern( pxNFeeP, cmd );
8110f990:	e17fff17 	ldw	r5,-4(fp)
8110f994:	e13ffe17 	ldw	r4,-8(fp)
8110f998:	110ff300 	call	8110ff30 <vQCmdFeeRMAPinFullPattern>

				break;
8110f99c:	00001806 	br	8110fa00 <vQCmdFEEinFullPattern+0x218>

			case M_SYNC:
			case M_MASTER_SYNC:
				/* Warning */
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
8110f9a0:	e0bffe17 	ldw	r2,-8(fp)
8110f9a4:	10802c17 	ldw	r2,176(r2)
8110f9a8:	10800318 	cmpnei	r2,r2,12
8110f9ac:	1000131e 	bne	r2,zero,8110f9fc <vQCmdFEEinFullPattern+0x214>
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
8110f9b0:	e0bffe17 	ldw	r2,-8(fp)
8110f9b4:	10c02d17 	ldw	r3,180(r2)
8110f9b8:	e0bffe17 	ldw	r2,-8(fp)
8110f9bc:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.bWatingSync = FALSE;
8110f9c0:	e0bffe17 	ldw	r2,-8(fp)
8110f9c4:	10002815 	stw	zero,160(r2)
				}

				break;
8110f9c8:	00000c06 	br	8110f9fc <vQCmdFEEinFullPattern+0x214>
			default:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
8110f9cc:	d0e06217 	ldw	r3,-32376(gp)
8110f9d0:	e0bffe17 	ldw	r2,-8(fp)
8110f9d4:	10800003 	ldbu	r2,0(r2)
8110f9d8:	10803fcc 	andi	r2,r2,255
8110f9dc:	100d883a 	mov	r6,r2
8110f9e0:	01604574 	movhi	r5,33045
8110f9e4:	29735004 	addi	r5,r5,-12992
8110f9e8:	1809883a 	mov	r4,r3
8110f9ec:	11215e00 	call	811215e0 <fprintf>
				#endif
				break;
8110f9f0:	00000306 	br	8110fa00 <vQCmdFEEinFullPattern+0x218>
				break;				
			case M_FEE_RUN:
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
8110f9f4:	0001883a 	nop
8110f9f8:	00000106 	br	8110fa00 <vQCmdFEEinFullPattern+0x218>
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
					pxNFeeP->xControl.bWatingSync = FALSE;
				}

				break;
8110f9fc:	0001883a 	nop
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				#endif
				break;
		}
	}
}
8110fa00:	0001883a 	nop
8110fa04:	e037883a 	mov	sp,fp
8110fa08:	dfc00117 	ldw	ra,4(sp)
8110fa0c:	df000017 	ldw	fp,0(sp)
8110fa10:	dec00204 	addi	sp,sp,8
8110fa14:	f800283a 	ret

8110fa18 <vQCmdFeeRMAPinStandBy>:



void vQCmdFeeRMAPinStandBy( TNFee *pxNFeeP, unsigned int cmd ){
8110fa18:	defff704 	addi	sp,sp,-36
8110fa1c:	de00012e 	bgeu	sp,et,8110fa24 <vQCmdFeeRMAPinStandBy+0xc>
8110fa20:	003b68fa 	trap	3
8110fa24:	dfc00815 	stw	ra,32(sp)
8110fa28:	df000715 	stw	fp,28(sp)
8110fa2c:	df000704 	addi	fp,sp,28
8110fa30:	e13ffe15 	stw	r4,-8(fp)
8110fa34:	e17fff15 	stw	r5,-4(fp)
	INT32U ucValueMasked;
	INT32U ucValueMasked2;


#ifdef DEBUG_ON
	fprintf(fp,"\nNFEE %hhu Task: RMAP msg received (StandBy)\n", pxNFeeP->ucId);
8110fa38:	d0e06217 	ldw	r3,-32376(gp)
8110fa3c:	e0bffe17 	ldw	r2,-8(fp)
8110fa40:	10800003 	ldbu	r2,0(r2)
8110fa44:	10803fcc 	andi	r2,r2,255
8110fa48:	100d883a 	mov	r6,r2
8110fa4c:	01604574 	movhi	r5,33045
8110fa50:	29737a04 	addi	r5,r5,-12824
8110fa54:	1809883a 	mov	r4,r3
8110fa58:	11215e00 	call	811215e0 <fprintf>
#endif


	uiCmdFEEL.ulWord = cmd;
8110fa5c:	e0bfff17 	ldw	r2,-4(fp)
8110fa60:	e0bffd15 	stw	r2,-12(fp)

	ucADDRReg = uiCmdFEEL.ucByte[1];
8110fa64:	e0bffd43 	ldbu	r2,-11(fp)
8110fa68:	e0bff905 	stb	r2,-28(fp)
	ucValueReg = uliRmapReadReg(pxNFeeP->xChannel.xRmap.puliRmapChAddr,  ucADDRReg);
8110fa6c:	e0bffe17 	ldw	r2,-8(fp)
8110fa70:	10804317 	ldw	r2,268(r2)
8110fa74:	e0fff903 	ldbu	r3,-28(fp)
8110fa78:	180b883a 	mov	r5,r3
8110fa7c:	1009883a 	mov	r4,r2
8110fa80:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
8110fa84:	e0bffa15 	stw	r2,-24(fp)

	switch (ucADDRReg) {
8110fa88:	e0bff903 	ldbu	r2,-28(fp)
8110fa8c:	10bff004 	addi	r2,r2,-64
8110fa90:	10c003a8 	cmpgeui	r3,r2,14
8110fa94:	1801151e 	bne	r3,zero,8110feec <vQCmdFeeRMAPinStandBy+0x4d4>
8110fa98:	100690ba 	slli	r3,r2,2
8110fa9c:	00a04474 	movhi	r2,33041
8110faa0:	10beac04 	addi	r2,r2,-1360
8110faa4:	1885883a 	add	r2,r3,r2
8110faa8:	10800017 	ldw	r2,0(r2)
8110faac:	1000683a 	jmp	r2
8110fab0:	8110fae8 	cmpgeui	r4,r16,17387
8110fab4:	8110ff0c 	andi	r4,r16,17404
8110fab8:	8110fbf0 	cmpltui	r4,r16,17391
8110fabc:	8110fd88 	cmpgei	r4,r16,17398
8110fac0:	8110fd88 	cmpgei	r4,r16,17398
8110fac4:	8110fd88 	cmpgei	r4,r16,17398
8110fac8:	8110fd88 	cmpgei	r4,r16,17398
8110facc:	8110fd88 	cmpgei	r4,r16,17398
8110fad0:	8110fd88 	cmpgei	r4,r16,17398
8110fad4:	8110fd88 	cmpgei	r4,r16,17398
8110fad8:	8110fd88 	cmpgei	r4,r16,17398
8110fadc:	8110fd88 	cmpgei	r4,r16,17398
8110fae0:	8110fda8 	cmpgeui	r4,r16,17398
8110fae4:	8110fe7c 	xorhi	r4,r16,17401
		case 0x40://0x00000000: ccd_seq_1_config
			ucValueMasked = (COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK & ucValueReg) >> 4; /* Number of rows */
8110fae8:	e0fffa17 	ldw	r3,-24(fp)
8110faec:	00800434 	movhi	r2,16
8110faf0:	10bffc04 	addi	r2,r2,-16
8110faf4:	1884703a 	and	r2,r3,r2
8110faf8:	1004d13a 	srli	r2,r2,4
8110fafc:	e0bffb15 	stw	r2,-20(fp)
			ucValueMasked2 = (COMM_RMAP_REGCLK_TRCNT_CTRL_MSK & ucValueReg) >> 20; /* Number of columns */
8110fb00:	e0bffa17 	ldw	r2,-24(fp)
8110fb04:	1004d53a 	srli	r2,r2,20
8110fb08:	e0bffc15 	stw	r2,-16(fp)


			pxNFeeP->xCcdInfo.usiHeight = ucValueMasked - pxNFeeP->xCcdInfo.usiOLN;
8110fb0c:	e0bffb17 	ldw	r2,-20(fp)
8110fb10:	1007883a 	mov	r3,r2
8110fb14:	e0bffe17 	ldw	r2,-8(fp)
8110fb18:	1080300b 	ldhu	r2,192(r2)
8110fb1c:	1885c83a 	sub	r2,r3,r2
8110fb20:	1007883a 	mov	r3,r2
8110fb24:	e0bffe17 	ldw	r2,-8(fp)
8110fb28:	10c0310d 	sth	r3,196(r2)
			pxNFeeP->xCcdInfo.usiHalfWidth = ucValueMasked2 - (pxNFeeP->xCcdInfo.usiSOverscanN + pxNFeeP->xCcdInfo.usiSPrescanN);
8110fb2c:	e0bffc17 	ldw	r2,-16(fp)
8110fb30:	1009883a 	mov	r4,r2
8110fb34:	e0bffe17 	ldw	r2,-8(fp)
8110fb38:	10c02f8b 	ldhu	r3,190(r2)
8110fb3c:	e0bffe17 	ldw	r2,-8(fp)
8110fb40:	10802f0b 	ldhu	r2,188(r2)
8110fb44:	1885883a 	add	r2,r3,r2
8110fb48:	2085c83a 	sub	r2,r4,r2
8110fb4c:	1007883a 	mov	r3,r2
8110fb50:	e0bffe17 	ldw	r2,-8(fp)
8110fb54:	10c0308d 	sth	r3,194(r2)
			vUpdateMemMapFEE(pxNFeeP);
8110fb58:	e13ffe17 	ldw	r4,-8(fp)
8110fb5c:	111dac00 	call	8111dac0 <vUpdateMemMapFEE>

			bDpktGetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8110fb60:	e0bffe17 	ldw	r2,-8(fp)
8110fb64:	10803304 	addi	r2,r2,204
8110fb68:	1009883a 	mov	r4,r2
8110fb6c:	1104c0c0 	call	81104c0c <bDpktGetPacketConfig>
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiOverscanYSize = pxNFeeP->xCcdInfo.usiOLN;
8110fb70:	e0bffe17 	ldw	r2,-8(fp)
8110fb74:	10c0300b 	ldhu	r3,192(r2)
8110fb78:	e0bffe17 	ldw	r2,-8(fp)
8110fb7c:	10c0358d 	sth	r3,214(r2)
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdXSize = ucValueMasked2 ;
8110fb80:	e0bffc17 	ldw	r2,-16(fp)
8110fb84:	1007883a 	mov	r3,r2
8110fb88:	e0bffe17 	ldw	r2,-8(fp)
8110fb8c:	10c0340d 	sth	r3,208(r2)
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdYSize = ucValueMasked;
8110fb90:	e0bffb17 	ldw	r2,-20(fp)
8110fb94:	1007883a 	mov	r3,r2
8110fb98:	e0bffe17 	ldw	r2,-8(fp)
8110fb9c:	10c0348d 	sth	r3,210(r2)
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiDataYSize = ucValueMasked - pxNFeeP->xCcdInfo.usiOLN;
8110fba0:	e0bffb17 	ldw	r2,-20(fp)
8110fba4:	1007883a 	mov	r3,r2
8110fba8:	e0bffe17 	ldw	r2,-8(fp)
8110fbac:	1080300b 	ldhu	r2,192(r2)
8110fbb0:	1885c83a 	sub	r2,r3,r2
8110fbb4:	1007883a 	mov	r3,r2
8110fbb8:	e0bffe17 	ldw	r2,-8(fp)
8110fbbc:	10c0350d 	sth	r3,212(r2)
		
			bDpktSetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8110fbc0:	e0bffe17 	ldw	r2,-8(fp)
8110fbc4:	10803304 	addi	r2,r2,204
8110fbc8:	1009883a 	mov	r4,r2
8110fbcc:	11049e00 	call	811049e0 <bDpktSetPacketConfig>

			#ifdef DEBUG_ON
				fprintf(fp,"- Rows: %u\n - Columns: %u\n", ucValueMasked, ucValueMasked2);
8110fbd0:	d0a06217 	ldw	r2,-32376(gp)
8110fbd4:	e1fffc17 	ldw	r7,-16(fp)
8110fbd8:	e1bffb17 	ldw	r6,-20(fp)
8110fbdc:	01604574 	movhi	r5,33045
8110fbe0:	29738604 	addi	r5,r5,-12776
8110fbe4:	1009883a 	mov	r4,r2
8110fbe8:	11215e00 	call	811215e0 <fprintf>
			#endif

			break;
8110fbec:	0000ca06 	br	8110ff18 <vQCmdFeeRMAPinStandBy+0x500>
		case 0x041://0x00000004:ccd_seq_2_config
			break;
		case 0x042://0x00000008:spw_packet_1_config

			ucValueMasked = (ucValueReg & COMM_RMAP_PACKET_SIZE_CTRL_MSK) >> 4;
8110fbf0:	e0fffa17 	ldw	r3,-24(fp)
8110fbf4:	00800434 	movhi	r2,16
8110fbf8:	10bffc04 	addi	r2,r2,-16
8110fbfc:	1884703a 	and	r2,r3,r2
8110fc00:	1004d13a 	srli	r2,r2,4
8110fc04:	e0bffb15 	stw	r2,-20(fp)
			bDpktGetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8110fc08:	e0bffe17 	ldw	r2,-8(fp)
8110fc0c:	10803304 	addi	r2,r2,204
8110fc10:	1009883a 	mov	r4,r2
8110fc14:	1104c0c0 	call	81104c0c <bDpktGetPacketConfig>
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiPacketLength = ucValueMasked;
8110fc18:	e0bffb17 	ldw	r2,-20(fp)
8110fc1c:	1007883a 	mov	r3,r2
8110fc20:	e0bffe17 	ldw	r2,-8(fp)
8110fc24:	10c0360d 	sth	r3,216(r2)
			bDpktSetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8110fc28:	e0bffe17 	ldw	r2,-8(fp)
8110fc2c:	10803304 	addi	r2,r2,204
8110fc30:	1009883a 	mov	r4,r2
8110fc34:	11049e00 	call	811049e0 <bDpktSetPacketConfig>

			#ifdef DEBUG_ON
				fprintf(fp,"- Pckt Length: %u\n", ucValueMasked);
8110fc38:	d0a06217 	ldw	r2,-32376(gp)
8110fc3c:	e1bffb17 	ldw	r6,-20(fp)
8110fc40:	01604574 	movhi	r5,33045
8110fc44:	29738d04 	addi	r5,r5,-12748
8110fc48:	1009883a 	mov	r4,r2
8110fc4c:	11215e00 	call	811215e0 <fprintf>
			#endif

			ucValueMasked2 = (ucValueReg & COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK) >> 2;
8110fc50:	e0bffa17 	ldw	r2,-24(fp)
8110fc54:	1080030c 	andi	r2,r2,12
8110fc58:	1004d0ba 	srli	r2,r2,2
8110fc5c:	e0bffc15 	stw	r2,-16(fp)

			switch (ucValueMasked2) {
8110fc60:	e0bffc17 	ldw	r2,-16(fp)
8110fc64:	10c000a0 	cmpeqi	r3,r2,2
8110fc68:	18000e1e 	bne	r3,zero,8110fca4 <vQCmdFeeRMAPinStandBy+0x28c>
8110fc6c:	10c000e0 	cmpeqi	r3,r2,3
8110fc70:	1800171e 	bne	r3,zero,8110fcd0 <vQCmdFeeRMAPinStandBy+0x2b8>
8110fc74:	10800060 	cmpeqi	r2,r2,1
8110fc78:	10001e26 	beq	r2,zero,8110fcf4 <vQCmdFeeRMAPinStandBy+0x2dc>
				case 0b01:
					pxNFeeP->xControl.eSide = sLeft;
8110fc7c:	e0bffe17 	ldw	r2,-8(fp)
8110fc80:	10002e15 	stw	zero,184(r2)
					#ifdef DEBUG_ON
						fprintf(fp," - Left side\n");
8110fc84:	d0a06217 	ldw	r2,-32376(gp)
8110fc88:	100f883a 	mov	r7,r2
8110fc8c:	01800344 	movi	r6,13
8110fc90:	01400044 	movi	r5,1
8110fc94:	01204574 	movhi	r4,33045
8110fc98:	21339204 	addi	r4,r4,-12728
8110fc9c:	1121c7c0 	call	81121c7c <fwrite>
					#endif
					break;
8110fca0:	00002c06 	br	8110fd54 <vQCmdFeeRMAPinStandBy+0x33c>
				case 0b10:
					pxNFeeP->xControl.eSide = sRight;
8110fca4:	e0bffe17 	ldw	r2,-8(fp)
8110fca8:	00c00044 	movi	r3,1
8110fcac:	10c02e15 	stw	r3,184(r2)
					#ifdef DEBUG_ON
						fprintf(fp," - Right side\n");
8110fcb0:	d0a06217 	ldw	r2,-32376(gp)
8110fcb4:	100f883a 	mov	r7,r2
8110fcb8:	01800384 	movi	r6,14
8110fcbc:	01400044 	movi	r5,1
8110fcc0:	01204574 	movhi	r4,33045
8110fcc4:	21339604 	addi	r4,r4,-12712
8110fcc8:	1121c7c0 	call	81121c7c <fwrite>
					#endif
					break;
8110fccc:	00002106 	br	8110fd54 <vQCmdFeeRMAPinStandBy+0x33c>
				case 0b11:
					pxNFeeP->xControl.eSide = sLeft;
8110fcd0:	e0bffe17 	ldw	r2,-8(fp)
8110fcd4:	10002e15 	stw	zero,184(r2)
					#ifdef DEBUG_ON
						fprintf(fp," - Both sides, but not supported yet. Switching to Left side\n");
8110fcd8:	d0a06217 	ldw	r2,-32376(gp)
8110fcdc:	100f883a 	mov	r7,r2
8110fce0:	01800f44 	movi	r6,61
8110fce4:	01400044 	movi	r5,1
8110fce8:	01204574 	movhi	r4,33045
8110fcec:	21339a04 	addi	r4,r4,-12696
8110fcf0:	1121c7c0 	call	81121c7c <fwrite>
					#endif
				default:
					pxNFeeP->xControl.eSide = sLeft;
8110fcf4:	e0bffe17 	ldw	r2,-8(fp)
8110fcf8:	10002e15 	stw	zero,184(r2)

					bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110fcfc:	e0bffe17 	ldw	r2,-8(fp)
8110fd00:	10804304 	addi	r2,r2,268
8110fd04:	1009883a 	mov	r4,r2
8110fd08:	11083480 	call	81108348 <bRmapGetMemConfigArea>
					pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config & 0xFFFFFFF7);
8110fd0c:	e0bffe17 	ldw	r2,-8(fp)
8110fd10:	10c05717 	ldw	r3,348(r2)
8110fd14:	00bffdc4 	movi	r2,-9
8110fd18:	1886703a 	and	r3,r3,r2
8110fd1c:	e0bffe17 	ldw	r2,-8(fp)
8110fd20:	10c05715 	stw	r3,348(r2)
					bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110fd24:	e0bffe17 	ldw	r2,-8(fp)
8110fd28:	10804304 	addi	r2,r2,268
8110fd2c:	1009883a 	mov	r4,r2
8110fd30:	110805c0 	call	8110805c <bRmapSetMemConfigArea>
					#ifdef DEBUG_ON
						fprintf(fp," - Switching to Left side\n");
8110fd34:	d0a06217 	ldw	r2,-32376(gp)
8110fd38:	100f883a 	mov	r7,r2
8110fd3c:	01800684 	movi	r6,26
8110fd40:	01400044 	movi	r5,1
8110fd44:	01204574 	movhi	r4,33045
8110fd48:	2133aa04 	addi	r4,r4,-12632
8110fd4c:	1121c7c0 	call	81121c7c <fwrite>
					#endif
					break;
8110fd50:	0001883a 	nop
				}
			#ifdef DEBUG_ON
				fprintf(fp,"\nNFEE %hhu Task: Side changed (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
8110fd54:	d0e06217 	ldw	r3,-32376(gp)
8110fd58:	e0bffe17 	ldw	r2,-8(fp)
8110fd5c:	10800003 	ldbu	r2,0(r2)
8110fd60:	11003fcc 	andi	r4,r2,255
8110fd64:	e0bffe17 	ldw	r2,-8(fp)
8110fd68:	10802e17 	ldw	r2,184(r2)
8110fd6c:	100f883a 	mov	r7,r2
8110fd70:	200d883a 	mov	r6,r4
8110fd74:	01604574 	movhi	r5,33045
8110fd78:	2973b104 	addi	r5,r5,-12604
8110fd7c:	1809883a 	mov	r4,r3
8110fd80:	11215e00 	call	811215e0 <fprintf>
			#endif
			break;
8110fd84:	00006406 	br	8110ff18 <vQCmdFeeRMAPinStandBy+0x500>
		case 0x48://0x00000020:CCD_3_windowing_1_config
		case 0x49://0x00000024:CCD_3_windowing_2_config
		case 0x4A://0x00000028:CCD_4_windowing_1_config
		case 0x4B://0x0000002C:CCD_4_windowing_2_config
			#ifdef DEBUG_ON
				fprintf(fp,"Command not allowed yet ( %hhu )\n", ucADDRReg);
8110fd88:	d0a06217 	ldw	r2,-32376(gp)
8110fd8c:	e0fff903 	ldbu	r3,-28(fp)
8110fd90:	180d883a 	mov	r6,r3
8110fd94:	01604574 	movhi	r5,33045
8110fd98:	2973bf04 	addi	r5,r5,-12548
8110fd9c:	1009883a 	mov	r4,r2
8110fda0:	11215e00 	call	811215e0 <fprintf>
			#endif
				break;
8110fda4:	00005c06 	br	8110ff18 <vQCmdFeeRMAPinStandBy+0x500>
		case 0x0000004C://0x00000038:operation_mode_config
			/* Mode Selection */
			ucValueMasked = (COMM_RMAP_MODE_SEL_CTRL_MSK & ucValueReg) >>4;
8110fda8:	e0bffa17 	ldw	r2,-24(fp)
8110fdac:	10803c0c 	andi	r2,r2,240
8110fdb0:	1004d13a 	srli	r2,r2,4
8110fdb4:	e0bffb15 	stw	r2,-20(fp)

			switch (ucValueMasked) {
8110fdb8:	e0bffb17 	ldw	r2,-20(fp)
8110fdbc:	10c000a0 	cmpeqi	r3,r2,2
8110fdc0:	18000d1e 	bne	r3,zero,8110fdf8 <vQCmdFeeRMAPinStandBy+0x3e0>
8110fdc4:	10c001a0 	cmpeqi	r3,r2,6
8110fdc8:	18001c1e 	bne	r3,zero,8110fe3c <vQCmdFeeRMAPinStandBy+0x424>
8110fdcc:	1000231e 	bne	r2,zero,8110fe5c <vQCmdFeeRMAPinStandBy+0x444>
				case 0: /* Standby */

				#ifdef DEBUG_ON
					fprintf(fp,"- already in Stand by mode\n", pxNFeeP->ucId);
8110fdd0:	d0e06217 	ldw	r3,-32376(gp)
8110fdd4:	e0bffe17 	ldw	r2,-8(fp)
8110fdd8:	10800003 	ldbu	r2,0(r2)
8110fddc:	10803fcc 	andi	r2,r2,255
8110fde0:	100d883a 	mov	r6,r2
8110fde4:	01604574 	movhi	r5,33045
8110fde8:	2973c804 	addi	r5,r5,-12512
8110fdec:	1809883a 	mov	r4,r3
8110fdf0:	11215e00 	call	811215e0 <fprintf>
				#endif

					break;
8110fdf4:	00002006 	br	8110fe78 <vQCmdFeeRMAPinStandBy+0x460>
				case 2: /* PAttern Full image */
				#ifdef DEBUG_ON
					fprintf(fp,"- to Full-Image-Pattern\n");
8110fdf8:	d0a06217 	ldw	r2,-32376(gp)
8110fdfc:	100f883a 	mov	r7,r2
8110fe00:	01800604 	movi	r6,24
8110fe04:	01400044 	movi	r5,1
8110fe08:	01204574 	movhi	r4,33045
8110fe0c:	2133cf04 	addi	r4,r4,-12484
8110fe10:	1121c7c0 	call	81121c7c <fwrite>
				#endif

					pxNFeeP->xControl.bWatingSync = TRUE;
8110fe14:	e0bffe17 	ldw	r2,-8(fp)
8110fe18:	00c00044 	movi	r3,1
8110fe1c:	10c02815 	stw	r3,160(r2)
					pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
8110fe20:	e0bffe17 	ldw	r2,-8(fp)
8110fe24:	00c00284 	movi	r3,10
8110fe28:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
8110fe2c:	e0bffe17 	ldw	r2,-8(fp)
8110fe30:	00c00304 	movi	r3,12
8110fe34:	10c02d15 	stw	r3,180(r2)

					break;
8110fe38:	00000f06 	br	8110fe78 <vQCmdFeeRMAPinStandBy+0x460>
				case 6:
				#ifdef DEBUG_ON
					fprintf(fp,"- Off-Mode not allowed.\n");
8110fe3c:	d0a06217 	ldw	r2,-32376(gp)
8110fe40:	100f883a 	mov	r7,r2
8110fe44:	01800604 	movi	r6,24
8110fe48:	01400044 	movi	r5,1
8110fe4c:	01204574 	movhi	r4,33045
8110fe50:	2133d604 	addi	r4,r4,-12456
8110fe54:	1121c7c0 	call	81121c7c <fwrite>
				#endif
					break;
8110fe58:	00000706 	br	8110fe78 <vQCmdFeeRMAPinStandBy+0x460>
				case 3:
				case 4:
				case 5:
				default:
					#ifdef DEBUG_ON
						fprintf(fp,"- mode not allowed yet ( %hhu )\n", ucValueMasked);
8110fe5c:	d0a06217 	ldw	r2,-32376(gp)
8110fe60:	e1bffb17 	ldw	r6,-20(fp)
8110fe64:	01604574 	movhi	r5,33045
8110fe68:	2973dd04 	addi	r5,r5,-12428
8110fe6c:	1009883a 	mov	r4,r2
8110fe70:	11215e00 	call	811215e0 <fprintf>
					#endif
					break;
8110fe74:	0001883a 	nop
			}

			break;
8110fe78:	00002706 	br	8110ff18 <vQCmdFeeRMAPinStandBy+0x500>
		case 0x0000004D://0x0000003C:sync_config

			ucValueMasked = (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & ucValueReg) >> 2; /* Number of rows */
8110fe7c:	e0bffa17 	ldw	r2,-24(fp)
8110fe80:	1080010c 	andi	r2,r2,4
8110fe84:	1004d0ba 	srli	r2,r2,2
8110fe88:	e0bffb15 	stw	r2,-20(fp)

			/* Cannot perform this operation */
			if ( ucValueMasked ) {
8110fe8c:	e0bffb17 	ldw	r2,-20(fp)
8110fe90:	10002026 	beq	r2,zero,8110ff14 <vQCmdFeeRMAPinStandBy+0x4fc>
				#ifdef DEBUG_ON
					fprintf(fp," - operation not allowed (StandBy-Mode)\n");
8110fe94:	d0a06217 	ldw	r2,-32376(gp)
8110fe98:	100f883a 	mov	r7,r2
8110fe9c:	01800a04 	movi	r6,40
8110fea0:	01400044 	movi	r5,1
8110fea4:	01204574 	movhi	r4,33045
8110fea8:	2133e604 	addi	r4,r4,-12392
8110feac:	1121c7c0 	call	81121c7c <fwrite>
				#endif
				/* Clear the trigger */
				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110feb0:	e0bffe17 	ldw	r2,-8(fp)
8110feb4:	10804304 	addi	r2,r2,268
8110feb8:	1009883a 	mov	r4,r2
8110febc:	11083480 	call	81108348 <bRmapGetMemConfigArea>
				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
8110fec0:	e0bffe17 	ldw	r2,-8(fp)
8110fec4:	10c06217 	ldw	r3,392(r2)
8110fec8:	00bffec4 	movi	r2,-5
8110fecc:	1886703a 	and	r3,r3,r2
8110fed0:	e0bffe17 	ldw	r2,-8(fp)
8110fed4:	10c06215 	stw	r3,392(r2)
				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110fed8:	e0bffe17 	ldw	r2,-8(fp)
8110fedc:	10804304 	addi	r2,r2,268
8110fee0:	1009883a 	mov	r4,r2
8110fee4:	110805c0 	call	8110805c <bRmapSetMemConfigArea>
			}

			break;
8110fee8:	00000a06 	br	8110ff14 <vQCmdFeeRMAPinStandBy+0x4fc>
		case 0x0000004F://0x00000044:clock_source_control
		case 0x00000050://0x00000048:frame_number
		case 0x00000051://0x0000004C:current_mode
		default:
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
8110feec:	d0a06217 	ldw	r2,-32376(gp)
8110fef0:	e0fff903 	ldbu	r3,-28(fp)
8110fef4:	180d883a 	mov	r6,r3
8110fef8:	01604574 	movhi	r5,33045
8110fefc:	2973f104 	addi	r5,r5,-12348
8110ff00:	1009883a 	mov	r4,r2
8110ff04:	11215e00 	call	811215e0 <fprintf>
			#endif
			break;
8110ff08:	00000306 	br	8110ff18 <vQCmdFeeRMAPinStandBy+0x500>
				fprintf(fp,"- Rows: %u\n - Columns: %u\n", ucValueMasked, ucValueMasked2);
			#endif

			break;
		case 0x041://0x00000004:ccd_seq_2_config
			break;
8110ff0c:	0001883a 	nop
8110ff10:	00000106 	br	8110ff18 <vQCmdFeeRMAPinStandBy+0x500>
				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
			}

			break;
8110ff14:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			#endif
			break;
		}
}
8110ff18:	0001883a 	nop
8110ff1c:	e037883a 	mov	sp,fp
8110ff20:	dfc00117 	ldw	ra,4(sp)
8110ff24:	df000017 	ldw	fp,0(sp)
8110ff28:	dec00204 	addi	sp,sp,8
8110ff2c:	f800283a 	ret

8110ff30 <vQCmdFeeRMAPinFullPattern>:

void vQCmdFeeRMAPinFullPattern( TNFee *pxNFeeP, unsigned int cmd ) {
8110ff30:	defff804 	addi	sp,sp,-32
8110ff34:	de00012e 	bgeu	sp,et,8110ff3c <vQCmdFeeRMAPinFullPattern+0xc>
8110ff38:	003b68fa 	trap	3
8110ff3c:	dfc00715 	stw	ra,28(sp)
8110ff40:	df000615 	stw	fp,24(sp)
8110ff44:	df000604 	addi	fp,sp,24
8110ff48:	e13ffe15 	stw	r4,-8(fp)
8110ff4c:	e17fff15 	stw	r5,-4(fp)
	INT8U ucValueReg;
	INT32U ucValueMasked;
	INT32U ucValueMasked2;

	#ifdef DEBUG_ON
		fprintf(fp,"\nNFEE %hhu Task: RMAP msg received (FullPattern)\n", pxNFeeP->ucId);
8110ff50:	d0e06217 	ldw	r3,-32376(gp)
8110ff54:	e0bffe17 	ldw	r2,-8(fp)
8110ff58:	10800003 	ldbu	r2,0(r2)
8110ff5c:	10803fcc 	andi	r2,r2,255
8110ff60:	100d883a 	mov	r6,r2
8110ff64:	01604574 	movhi	r5,33045
8110ff68:	2973fa04 	addi	r5,r5,-12312
8110ff6c:	1809883a 	mov	r4,r3
8110ff70:	11215e00 	call	811215e0 <fprintf>
	#endif

	uiCmdFEEL.ulWord = cmd;
8110ff74:	e0bfff17 	ldw	r2,-4(fp)
8110ff78:	e0bffd15 	stw	r2,-12(fp)

	ucADDRReg = uiCmdFEEL.ucByte[1];
8110ff7c:	e0bffd43 	ldbu	r2,-11(fp)
8110ff80:	e0bffa05 	stb	r2,-24(fp)
	ucValueReg = uliRmapReadReg(pxNFeeP->xChannel.xRmap.puliRmapChAddr,  ucADDRReg);
8110ff84:	e0bffe17 	ldw	r2,-8(fp)
8110ff88:	10804317 	ldw	r2,268(r2)
8110ff8c:	e0fffa03 	ldbu	r3,-24(fp)
8110ff90:	180b883a 	mov	r5,r3
8110ff94:	1009883a 	mov	r4,r2
8110ff98:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
8110ff9c:	e0bffa45 	stb	r2,-23(fp)


	switch (ucADDRReg) {
8110ffa0:	e0bffa03 	ldbu	r2,-24(fp)
8110ffa4:	10bff004 	addi	r2,r2,-64
8110ffa8:	10c003a8 	cmpgeui	r3,r2,14
8110ffac:	1800e61e 	bne	r3,zero,81110348 <vQCmdFeeRMAPinFullPattern+0x418>
8110ffb0:	100690ba 	slli	r3,r2,2
8110ffb4:	00a04474 	movhi	r2,33041
8110ffb8:	10bff204 	addi	r2,r2,-56
8110ffbc:	1885883a 	add	r2,r3,r2
8110ffc0:	10800017 	ldw	r2,0(r2)
8110ffc4:	1000683a 	jmp	r2
8110ffc8:	81110000 	call	88111000 <__reset+0x20f1000>
8110ffcc:	81110000 	call	88111000 <__reset+0x20f1000>
8110ffd0:	81110000 	call	88111000 <__reset+0x20f1000>
8110ffd4:	811101b4 	orhi	r4,r16,17414
8110ffd8:	811101b4 	orhi	r4,r16,17414
8110ffdc:	811101b4 	orhi	r4,r16,17414
8110ffe0:	811101b4 	orhi	r4,r16,17414
8110ffe4:	811101b4 	orhi	r4,r16,17414
8110ffe8:	811101b4 	orhi	r4,r16,17414
8110ffec:	811101b4 	orhi	r4,r16,17414
8110fff0:	811101b4 	orhi	r4,r16,17414
8110fff4:	811101b4 	orhi	r4,r16,17414
8110fff8:	811101d4 	ori	r4,r16,17415
8110fffc:	811102e0 	cmpeqi	r4,r16,17419
		case 0x40://0x00000000: ccd_seq_1_config
		case 0x041://0x00000004:ccd_seq_2_config
		case 0x042://0x00000008:spw_packet_1_config
			if ( (pxNFeeP->xControl.eNextMode == sToTestFullPattern) || (pxNFeeP->xControl.eNextMode == sFeeWaitingSync) )
81110000:	e0bffe17 	ldw	r2,-8(fp)
81110004:	10802d17 	ldw	r2,180(r2)
81110008:	108001e0 	cmpeqi	r2,r2,7
8111000c:	1000041e 	bne	r2,zero,81110020 <vQCmdFeeRMAPinFullPattern+0xf0>
81110010:	e0bffe17 	ldw	r2,-8(fp)
81110014:	10802d17 	ldw	r2,180(r2)
81110018:	10800318 	cmpnei	r2,r2,12
8111001c:	1000541e 	bne	r2,zero,81110170 <vQCmdFeeRMAPinFullPattern+0x240>
			{

				ucValueMasked2 = (ucValueReg & COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK) >> 2;
81110020:	e0bffa43 	ldbu	r2,-23(fp)
81110024:	1080030c 	andi	r2,r2,12
81110028:	1005d0ba 	srai	r2,r2,2
8111002c:	e0bffb15 	stw	r2,-20(fp)

				switch (ucValueMasked2) {
81110030:	e0bffb17 	ldw	r2,-20(fp)
81110034:	10c000a0 	cmpeqi	r3,r2,2
81110038:	18000e1e 	bne	r3,zero,81110074 <vQCmdFeeRMAPinFullPattern+0x144>
8111003c:	10c000e0 	cmpeqi	r3,r2,3
81110040:	1800171e 	bne	r3,zero,811100a0 <vQCmdFeeRMAPinFullPattern+0x170>
81110044:	10800060 	cmpeqi	r2,r2,1
81110048:	10001e26 	beq	r2,zero,811100c4 <vQCmdFeeRMAPinFullPattern+0x194>
					case 0b01:
						pxNFeeP->xControl.eSide = sLeft;
8111004c:	e0bffe17 	ldw	r2,-8(fp)
81110050:	10002e15 	stw	zero,184(r2)
						#ifdef DEBUG_ON
							fprintf(fp," - Left side\n");
81110054:	d0a06217 	ldw	r2,-32376(gp)
81110058:	100f883a 	mov	r7,r2
8111005c:	01800344 	movi	r6,13
81110060:	01400044 	movi	r5,1
81110064:	01204574 	movhi	r4,33045
81110068:	21339204 	addi	r4,r4,-12728
8111006c:	1121c7c0 	call	81121c7c <fwrite>
						#endif
						break;
81110070:	00002c06 	br	81110124 <vQCmdFeeRMAPinFullPattern+0x1f4>
					case 0b10:
						pxNFeeP->xControl.eSide = sRight;
81110074:	e0bffe17 	ldw	r2,-8(fp)
81110078:	00c00044 	movi	r3,1
8111007c:	10c02e15 	stw	r3,184(r2)
						#ifdef DEBUG_ON
							fprintf(fp," - Right side\n");
81110080:	d0a06217 	ldw	r2,-32376(gp)
81110084:	100f883a 	mov	r7,r2
81110088:	01800384 	movi	r6,14
8111008c:	01400044 	movi	r5,1
81110090:	01204574 	movhi	r4,33045
81110094:	21339604 	addi	r4,r4,-12712
81110098:	1121c7c0 	call	81121c7c <fwrite>
						#endif
						break;
8111009c:	00002106 	br	81110124 <vQCmdFeeRMAPinFullPattern+0x1f4>
					case 0b11:
						pxNFeeP->xControl.eSide = sLeft;
811100a0:	e0bffe17 	ldw	r2,-8(fp)
811100a4:	10002e15 	stw	zero,184(r2)
						#ifdef DEBUG_ON
							fprintf(fp," - Both sides, but not supported yet. Switching to Left side\n");
811100a8:	d0a06217 	ldw	r2,-32376(gp)
811100ac:	100f883a 	mov	r7,r2
811100b0:	01800f44 	movi	r6,61
811100b4:	01400044 	movi	r5,1
811100b8:	01204574 	movhi	r4,33045
811100bc:	21339a04 	addi	r4,r4,-12696
811100c0:	1121c7c0 	call	81121c7c <fwrite>
						#endif
					default:
						pxNFeeP->xControl.eSide = sLeft;
811100c4:	e0bffe17 	ldw	r2,-8(fp)
811100c8:	10002e15 	stw	zero,184(r2)

						bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
811100cc:	e0bffe17 	ldw	r2,-8(fp)
811100d0:	10804304 	addi	r2,r2,268
811100d4:	1009883a 	mov	r4,r2
811100d8:	11083480 	call	81108348 <bRmapGetMemConfigArea>
						pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config & 0xFFFFFFF7);
811100dc:	e0bffe17 	ldw	r2,-8(fp)
811100e0:	10c05717 	ldw	r3,348(r2)
811100e4:	00bffdc4 	movi	r2,-9
811100e8:	1886703a 	and	r3,r3,r2
811100ec:	e0bffe17 	ldw	r2,-8(fp)
811100f0:	10c05715 	stw	r3,348(r2)
						bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
811100f4:	e0bffe17 	ldw	r2,-8(fp)
811100f8:	10804304 	addi	r2,r2,268
811100fc:	1009883a 	mov	r4,r2
81110100:	110805c0 	call	8110805c <bRmapSetMemConfigArea>
						#ifdef DEBUG_ON
							fprintf(fp," - Switching to Left side\n");
81110104:	d0a06217 	ldw	r2,-32376(gp)
81110108:	100f883a 	mov	r7,r2
8111010c:	01800684 	movi	r6,26
81110110:	01400044 	movi	r5,1
81110114:	01204574 	movhi	r4,33045
81110118:	2133aa04 	addi	r4,r4,-12632
8111011c:	1121c7c0 	call	81121c7c <fwrite>
						#endif
					break;
81110120:	0001883a 	nop
				}
				#ifdef DEBUG_ON
					fprintf(fp,"\nNFEE %hhu Task: Side changed (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
81110124:	d0e06217 	ldw	r3,-32376(gp)
81110128:	e0bffe17 	ldw	r2,-8(fp)
8111012c:	10800003 	ldbu	r2,0(r2)
81110130:	11003fcc 	andi	r4,r2,255
81110134:	e0bffe17 	ldw	r2,-8(fp)
81110138:	10802e17 	ldw	r2,184(r2)
8111013c:	100f883a 	mov	r7,r2
81110140:	200d883a 	mov	r6,r4
81110144:	01604574 	movhi	r5,33045
81110148:	2973b104 	addi	r5,r5,-12604
8111014c:	1809883a 	mov	r4,r3
81110150:	11215e00 	call	811215e0 <fprintf>
				#endif


				pxNFeeP->xControl.eMode =  sNextPatternIteration;
81110154:	e0bffe17 	ldw	r2,-8(fp)
81110158:	00c00284 	movi	r3,10
8111015c:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode =  sFeeWaitingSync;
81110160:	e0bffe17 	ldw	r2,-8(fp)
81110164:	00c00304 	movi	r3,12
81110168:	10c02d15 	stw	r3,180(r2)
				}
			}



			break;
8111016c:	00007e06 	br	81110368 <vQCmdFeeRMAPinFullPattern+0x438>


				pxNFeeP->xControl.eMode =  sNextPatternIteration;
				pxNFeeP->xControl.eNextMode =  sFeeWaitingSync;
			} else {
				if (pxNFeeP->xControl.eNextMode == sFeeTestFullPattern) {
81110170:	e0bffe17 	ldw	r2,-8(fp)
81110174:	10802d17 	ldw	r2,180(r2)
81110178:	10800118 	cmpnei	r2,r2,4
8111017c:	10007a1e 	bne	r2,zero,81110368 <vQCmdFeeRMAPinFullPattern+0x438>
					#ifdef DEBUG_ON
						fprintf(fp,"\nNFEE %hhu Task: Can't change the CCD side while in transmission (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
81110180:	d0e06217 	ldw	r3,-32376(gp)
81110184:	e0bffe17 	ldw	r2,-8(fp)
81110188:	10800003 	ldbu	r2,0(r2)
8111018c:	11003fcc 	andi	r4,r2,255
81110190:	e0bffe17 	ldw	r2,-8(fp)
81110194:	10802e17 	ldw	r2,184(r2)
81110198:	100f883a 	mov	r7,r2
8111019c:	200d883a 	mov	r6,r4
811101a0:	01604574 	movhi	r5,33045
811101a4:	29740704 	addi	r5,r5,-12260
811101a8:	1809883a 	mov	r4,r3
811101ac:	11215e00 	call	811215e0 <fprintf>
				}
			}



			break;
811101b0:	00006d06 	br	81110368 <vQCmdFeeRMAPinFullPattern+0x438>
		case 0x48://0x00000020:CCD_3_windowing_1_config
		case 0x49://0x00000024:CCD_3_windowing_2_config
		case 0x4A://0x00000028:CCD_4_windowing_1_config
		case 0x4B://0x0000002C:CCD_4_windowing_2_config
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
811101b4:	d0a06217 	ldw	r2,-32376(gp)
811101b8:	e0fffa03 	ldbu	r3,-24(fp)
811101bc:	180d883a 	mov	r6,r3
811101c0:	01604574 	movhi	r5,33045
811101c4:	2973f104 	addi	r5,r5,-12348
811101c8:	1009883a 	mov	r4,r2
811101cc:	11215e00 	call	811215e0 <fprintf>
			#endif
				break;
811101d0:	00006806 	br	81110374 <vQCmdFeeRMAPinFullPattern+0x444>

		case 0x0000004C://0x00000038:operation_mode_config
			/* Mode Selection */
			ucValueMasked = (COMM_RMAP_MODE_SEL_CTRL_MSK & ucValueReg) >>4;
811101d4:	e0bffa43 	ldbu	r2,-23(fp)
811101d8:	1004d13a 	srli	r2,r2,4
811101dc:	10803fcc 	andi	r2,r2,255
811101e0:	e0bffc15 	stw	r2,-16(fp)

			switch (ucValueMasked) {
811101e4:	e0bffc17 	ldw	r2,-16(fp)
811101e8:	10c000a0 	cmpeqi	r3,r2,2
811101ec:	1800221e 	bne	r3,zero,81110278 <vQCmdFeeRMAPinFullPattern+0x348>
811101f0:	10c001a0 	cmpeqi	r3,r2,6
811101f4:	18002a1e 	bne	r3,zero,811102a0 <vQCmdFeeRMAPinFullPattern+0x370>
811101f8:	1000311e 	bne	r2,zero,811102c0 <vQCmdFeeRMAPinFullPattern+0x390>
				case 0: /* Standby */
				#ifdef DEBUG_ON
					fprintf(fp,"- to Stand-By\n");
811101fc:	d0a06217 	ldw	r2,-32376(gp)
81110200:	100f883a 	mov	r7,r2
81110204:	01800384 	movi	r6,14
81110208:	01400044 	movi	r5,1
8111020c:	01204574 	movhi	r4,33045
81110210:	21341e04 	addi	r4,r4,-12168
81110214:	1121c7c0 	call	81121c7c <fwrite>
				#endif

					if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
81110218:	e0bffe17 	ldw	r2,-8(fp)
8111021c:	10802c17 	ldw	r2,176(r2)
81110220:	10800298 	cmpnei	r2,r2,10
81110224:	10000a1e 	bne	r2,zero,81110250 <vQCmdFeeRMAPinFullPattern+0x320>
						pxNFeeP->xControl.bWatingSync = TRUE;
81110228:	e0bffe17 	ldw	r2,-8(fp)
8111022c:	00c00044 	movi	r3,1
81110230:	10c02815 	stw	r3,160(r2)
						pxNFeeP->xControl.eMode = sFeeWaitingSync;
81110234:	e0bffe17 	ldw	r2,-8(fp)
81110238:	00c00304 	movi	r3,12
8111023c:	10c02c15 	stw	r3,176(r2)
						pxNFeeP->xControl.eNextMode = sToFeeStandBy;
81110240:	e0bffe17 	ldw	r2,-8(fp)
81110244:	00c00184 	movi	r3,6
81110248:	10c02d15 	stw	r3,180(r2)

					//pxNFeeP->xControl.bWatingSync = TRUE;
					//pxNFeeP->xControl.eMode = sFeeTestFullPattern;
					//pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */

					break;
8111024c:	00002306 	br	811102dc <vQCmdFeeRMAPinFullPattern+0x3ac>
					if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
						pxNFeeP->xControl.bWatingSync = TRUE;
						pxNFeeP->xControl.eMode = sFeeWaitingSync;
						pxNFeeP->xControl.eNextMode = sToFeeStandBy;
					} else {
						pxNFeeP->xControl.bWatingSync = TRUE;
81110250:	e0bffe17 	ldw	r2,-8(fp)
81110254:	00c00044 	movi	r3,1
81110258:	10c02815 	stw	r3,160(r2)
						pxNFeeP->xControl.eMode = sFeeTestFullPattern;
8111025c:	e0bffe17 	ldw	r2,-8(fp)
81110260:	00c00104 	movi	r3,4
81110264:	10c02c15 	stw	r3,176(r2)
						pxNFeeP->xControl.eNextMode = sToFeeStandBy;
81110268:	e0bffe17 	ldw	r2,-8(fp)
8111026c:	00c00184 	movi	r3,6
81110270:	10c02d15 	stw	r3,180(r2)

					//pxNFeeP->xControl.bWatingSync = TRUE;
					//pxNFeeP->xControl.eMode = sFeeTestFullPattern;
					//pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */

					break;
81110274:	00001906 	br	811102dc <vQCmdFeeRMAPinFullPattern+0x3ac>
				case 2: /* PAttern Full image */
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
81110278:	d0e06217 	ldw	r3,-32376(gp)
8111027c:	e0bffe17 	ldw	r2,-8(fp)
81110280:	10800003 	ldbu	r2,0(r2)
81110284:	10803fcc 	andi	r2,r2,255
81110288:	100d883a 	mov	r6,r2
8111028c:	01604574 	movhi	r5,33045
81110290:	29736c04 	addi	r5,r5,-12880
81110294:	1809883a 	mov	r4,r3
81110298:	11215e00 	call	811215e0 <fprintf>
					#endif

					break;
8111029c:	00000f06 	br	811102dc <vQCmdFeeRMAPinFullPattern+0x3ac>
				case 6:
				#ifdef DEBUG_ON
					fprintf(fp," Off-Mode not allowed.\n");
811102a0:	d0a06217 	ldw	r2,-32376(gp)
811102a4:	100f883a 	mov	r7,r2
811102a8:	018005c4 	movi	r6,23
811102ac:	01400044 	movi	r5,1
811102b0:	01204574 	movhi	r4,33045
811102b4:	21342204 	addi	r4,r4,-12152
811102b8:	1121c7c0 	call	81121c7c <fwrite>
				#endif
					break;
811102bc:	00000706 	br	811102dc <vQCmdFeeRMAPinFullPattern+0x3ac>
				case 3:
				case 4:
				case 5:
				default:
					#ifdef DEBUG_ON
						fprintf(fp," mode not allowed yet ( %hhu )\n", ucValueMasked);
811102c0:	d0a06217 	ldw	r2,-32376(gp)
811102c4:	e1bffc17 	ldw	r6,-16(fp)
811102c8:	01604574 	movhi	r5,33045
811102cc:	29742804 	addi	r5,r5,-12128
811102d0:	1009883a 	mov	r4,r2
811102d4:	11215e00 	call	811215e0 <fprintf>
					#endif
					break;
811102d8:	0001883a 	nop
			}

			break;
811102dc:	00002506 	br	81110374 <vQCmdFeeRMAPinFullPattern+0x444>
		case 0x0000004D://0x0000003C:sync_config

			ucValueMasked = (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & ucValueReg) >> 2; /* Number of rows */
811102e0:	e0bffa43 	ldbu	r2,-23(fp)
811102e4:	1080010c 	andi	r2,r2,4
811102e8:	10803fcc 	andi	r2,r2,255
811102ec:	1004d0ba 	srli	r2,r2,2
811102f0:	10803fcc 	andi	r2,r2,255
811102f4:	e0bffc15 	stw	r2,-16(fp)

			if ( ucValueMasked ) {
811102f8:	e0bffc17 	ldw	r2,-16(fp)
811102fc:	10001c26 	beq	r2,zero,81110370 <vQCmdFeeRMAPinFullPattern+0x440>

				if ( pxNFeeP->xControl.eNextMode == sToFeeStandBy ) {
81110300:	e0bffe17 	ldw	r2,-8(fp)
81110304:	10802d17 	ldw	r2,180(r2)
81110308:	10800198 	cmpnei	r2,r2,6
8111030c:	1000181e 	bne	r2,zero,81110370 <vQCmdFeeRMAPinFullPattern+0x440>
					pxNFeeP->xControl.bWatingSync = FALSE;
81110310:	e0bffe17 	ldw	r2,-8(fp)
81110314:	10002815 	stw	zero,160(r2)
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
81110318:	e0bffe17 	ldw	r2,-8(fp)
8111031c:	10c02d17 	ldw	r3,180(r2)
81110320:	e0bffe17 	ldw	r2,-8(fp)
81110324:	10c02c15 	stw	r3,176(r2)
					#ifdef DEBUG_ON
						fprintf(fp," - Mode Forced.\n");
81110328:	d0a06217 	ldw	r2,-32376(gp)
8111032c:	100f883a 	mov	r7,r2
81110330:	01800404 	movi	r6,16
81110334:	01400044 	movi	r5,1
81110338:	01204574 	movhi	r4,33045
8111033c:	21343004 	addi	r4,r4,-12096
81110340:	1121c7c0 	call	81121c7c <fwrite>
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);

			}

			break;
81110344:	00000a06 	br	81110370 <vQCmdFeeRMAPinFullPattern+0x440>
		case 0x0000004F://0x00000044:clock_source_control
		case 0x00000050://0x00000048:frame_number
		case 0x00000051://0x0000004C:current_mode
		default:
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
81110348:	d0a06217 	ldw	r2,-32376(gp)
8111034c:	e0fffa03 	ldbu	r3,-24(fp)
81110350:	180d883a 	mov	r6,r3
81110354:	01604574 	movhi	r5,33045
81110358:	2973f104 	addi	r5,r5,-12348
8111035c:	1009883a 	mov	r4,r2
81110360:	11215e00 	call	811215e0 <fprintf>
			#endif
			break;
81110364:	00000306 	br	81110374 <vQCmdFeeRMAPinFullPattern+0x444>
				}
			}



			break;
81110368:	0001883a 	nop
8111036c:	00000106 	br	81110374 <vQCmdFeeRMAPinFullPattern+0x444>
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);

			}

			break;
81110370:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			#endif
			break;
		}
}
81110374:	0001883a 	nop
81110378:	e037883a 	mov	sp,fp
8111037c:	dfc00117 	ldw	ra,4(sp)
81110380:	df000017 	ldw	fp,0(sp)
81110384:	dec00204 	addi	sp,sp,8
81110388:	f800283a 	ret

8111038c <vQCmdFeeRMAPWaitingSync>:


void vQCmdFeeRMAPWaitingSync( TNFee *pxNFeeP, unsigned int cmd ){
8111038c:	defff804 	addi	sp,sp,-32
81110390:	de00012e 	bgeu	sp,et,81110398 <vQCmdFeeRMAPWaitingSync+0xc>
81110394:	003b68fa 	trap	3
81110398:	dfc00715 	stw	ra,28(sp)
8111039c:	df000615 	stw	fp,24(sp)
811103a0:	df000604 	addi	fp,sp,24
811103a4:	e13ffe15 	stw	r4,-8(fp)
811103a8:	e17fff15 	stw	r5,-4(fp)
	INT8U ucValueReg;
	INT32U ucValueMasked;
	INT32U ucValueMasked2;

	#ifdef DEBUG_ON
		fprintf(fp,"\nNFEE %hhu Task: RMAP msg received (WaitingSync)\n", pxNFeeP->ucId);
811103ac:	d0e06217 	ldw	r3,-32376(gp)
811103b0:	e0bffe17 	ldw	r2,-8(fp)
811103b4:	10800003 	ldbu	r2,0(r2)
811103b8:	10803fcc 	andi	r2,r2,255
811103bc:	100d883a 	mov	r6,r2
811103c0:	01604574 	movhi	r5,33045
811103c4:	29743504 	addi	r5,r5,-12076
811103c8:	1809883a 	mov	r4,r3
811103cc:	11215e00 	call	811215e0 <fprintf>
	#endif

	uiCmdFEEL.ulWord = cmd;
811103d0:	e0bfff17 	ldw	r2,-4(fp)
811103d4:	e0bffd15 	stw	r2,-12(fp)

	ucADDRReg = uiCmdFEEL.ucByte[1];
811103d8:	e0bffd43 	ldbu	r2,-11(fp)
811103dc:	e0bffa05 	stb	r2,-24(fp)
	ucValueReg = uliRmapReadReg(pxNFeeP->xChannel.xRmap.puliRmapChAddr,  ucADDRReg);
811103e0:	e0bffe17 	ldw	r2,-8(fp)
811103e4:	10804317 	ldw	r2,268(r2)
811103e8:	e0fffa03 	ldbu	r3,-24(fp)
811103ec:	180b883a 	mov	r5,r3
811103f0:	1009883a 	mov	r4,r2
811103f4:	110a0c00 	call	8110a0c0 <uliRmapReadReg>
811103f8:	e0bffa45 	stb	r2,-23(fp)


	switch (ucADDRReg) {
811103fc:	e0bffa03 	ldbu	r2,-24(fp)
81110400:	10c010c8 	cmpgei	r3,r2,67
81110404:	1800051e 	bne	r3,zero,8111041c <vQCmdFeeRMAPWaitingSync+0x90>
81110408:	10c01008 	cmpgei	r3,r2,64
8111040c:	1800081e 	bne	r3,zero,81110430 <vQCmdFeeRMAPWaitingSync+0xa4>
81110410:	108000a0 	cmpeqi	r2,r2,2
81110414:	1000a81e 	bne	r2,zero,811106b8 <vQCmdFeeRMAPWaitingSync+0x32c>
81110418:	0000d406 	br	8111076c <vQCmdFeeRMAPWaitingSync+0x3e0>
8111041c:	10c01350 	cmplti	r3,r2,77
81110420:	1800701e 	bne	r3,zero,811105e4 <vQCmdFeeRMAPWaitingSync+0x258>
81110424:	10801360 	cmpeqi	r2,r2,77
81110428:	1000b61e 	bne	r2,zero,81110704 <vQCmdFeeRMAPWaitingSync+0x378>
8111042c:	0000cf06 	br	8111076c <vQCmdFeeRMAPWaitingSync+0x3e0>
		case 0x40://0x00000000: ccd_seq_1_config
		case 0x041://0x00000004:ccd_seq_2_config
		case 0x042://0x00000008:spw_packet_1_config

			if ( (pxNFeeP->xControl.eNextMode == sToTestFullPattern) || (pxNFeeP->xControl.eNextMode == sFeeWaitingSync) )
81110430:	e0bffe17 	ldw	r2,-8(fp)
81110434:	10802d17 	ldw	r2,180(r2)
81110438:	108001e0 	cmpeqi	r2,r2,7
8111043c:	1000041e 	bne	r2,zero,81110450 <vQCmdFeeRMAPWaitingSync+0xc4>
81110440:	e0bffe17 	ldw	r2,-8(fp)
81110444:	10802d17 	ldw	r2,180(r2)
81110448:	10800318 	cmpnei	r2,r2,12
8111044c:	1000541e 	bne	r2,zero,811105a0 <vQCmdFeeRMAPWaitingSync+0x214>
			{

				ucValueMasked2 = (ucValueReg & COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK) >> 2;
81110450:	e0bffa43 	ldbu	r2,-23(fp)
81110454:	1080030c 	andi	r2,r2,12
81110458:	1005d0ba 	srai	r2,r2,2
8111045c:	e0bffb15 	stw	r2,-20(fp)

				switch (ucValueMasked2) {
81110460:	e0bffb17 	ldw	r2,-20(fp)
81110464:	10c000a0 	cmpeqi	r3,r2,2
81110468:	18000e1e 	bne	r3,zero,811104a4 <vQCmdFeeRMAPWaitingSync+0x118>
8111046c:	10c000e0 	cmpeqi	r3,r2,3
81110470:	1800171e 	bne	r3,zero,811104d0 <vQCmdFeeRMAPWaitingSync+0x144>
81110474:	10800060 	cmpeqi	r2,r2,1
81110478:	10001e26 	beq	r2,zero,811104f4 <vQCmdFeeRMAPWaitingSync+0x168>
					case 0b01:
						pxNFeeP->xControl.eSide = sLeft;
8111047c:	e0bffe17 	ldw	r2,-8(fp)
81110480:	10002e15 	stw	zero,184(r2)
						#ifdef DEBUG_ON
							fprintf(fp," - Left side\n");
81110484:	d0a06217 	ldw	r2,-32376(gp)
81110488:	100f883a 	mov	r7,r2
8111048c:	01800344 	movi	r6,13
81110490:	01400044 	movi	r5,1
81110494:	01204574 	movhi	r4,33045
81110498:	21339204 	addi	r4,r4,-12728
8111049c:	1121c7c0 	call	81121c7c <fwrite>
						#endif
						break;
811104a0:	00002c06 	br	81110554 <vQCmdFeeRMAPWaitingSync+0x1c8>
					case 0b10:
						pxNFeeP->xControl.eSide = sRight;
811104a4:	e0bffe17 	ldw	r2,-8(fp)
811104a8:	00c00044 	movi	r3,1
811104ac:	10c02e15 	stw	r3,184(r2)
						#ifdef DEBUG_ON
							fprintf(fp," - Right side\n");
811104b0:	d0a06217 	ldw	r2,-32376(gp)
811104b4:	100f883a 	mov	r7,r2
811104b8:	01800384 	movi	r6,14
811104bc:	01400044 	movi	r5,1
811104c0:	01204574 	movhi	r4,33045
811104c4:	21339604 	addi	r4,r4,-12712
811104c8:	1121c7c0 	call	81121c7c <fwrite>
						#endif
						break;
811104cc:	00002106 	br	81110554 <vQCmdFeeRMAPWaitingSync+0x1c8>
					case 0b11:
						pxNFeeP->xControl.eSide = sLeft;
811104d0:	e0bffe17 	ldw	r2,-8(fp)
811104d4:	10002e15 	stw	zero,184(r2)
						#ifdef DEBUG_ON
							fprintf(fp," - Both sides, but not supported yet. Switching to Left side\n");
811104d8:	d0a06217 	ldw	r2,-32376(gp)
811104dc:	100f883a 	mov	r7,r2
811104e0:	01800f44 	movi	r6,61
811104e4:	01400044 	movi	r5,1
811104e8:	01204574 	movhi	r4,33045
811104ec:	21339a04 	addi	r4,r4,-12696
811104f0:	1121c7c0 	call	81121c7c <fwrite>
						#endif
					default:
						pxNFeeP->xControl.eSide = sLeft;
811104f4:	e0bffe17 	ldw	r2,-8(fp)
811104f8:	10002e15 	stw	zero,184(r2)

						bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
811104fc:	e0bffe17 	ldw	r2,-8(fp)
81110500:	10804304 	addi	r2,r2,268
81110504:	1009883a 	mov	r4,r2
81110508:	11083480 	call	81108348 <bRmapGetMemConfigArea>
						pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config & 0xFFFFFFF7);
8111050c:	e0bffe17 	ldw	r2,-8(fp)
81110510:	10c05717 	ldw	r3,348(r2)
81110514:	00bffdc4 	movi	r2,-9
81110518:	1886703a 	and	r3,r3,r2
8111051c:	e0bffe17 	ldw	r2,-8(fp)
81110520:	10c05715 	stw	r3,348(r2)
						bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
81110524:	e0bffe17 	ldw	r2,-8(fp)
81110528:	10804304 	addi	r2,r2,268
8111052c:	1009883a 	mov	r4,r2
81110530:	110805c0 	call	8110805c <bRmapSetMemConfigArea>
						#ifdef DEBUG_ON
							fprintf(fp," - Switching to Left side\n");
81110534:	d0a06217 	ldw	r2,-32376(gp)
81110538:	100f883a 	mov	r7,r2
8111053c:	01800684 	movi	r6,26
81110540:	01400044 	movi	r5,1
81110544:	01204574 	movhi	r4,33045
81110548:	2133aa04 	addi	r4,r4,-12632
8111054c:	1121c7c0 	call	81121c7c <fwrite>
						#endif
					break;
81110550:	0001883a 	nop
				}
				#ifdef DEBUG_ON
					fprintf(fp,"\nNFEE %hhu Task: Side changed (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
81110554:	d0e06217 	ldw	r3,-32376(gp)
81110558:	e0bffe17 	ldw	r2,-8(fp)
8111055c:	10800003 	ldbu	r2,0(r2)
81110560:	11003fcc 	andi	r4,r2,255
81110564:	e0bffe17 	ldw	r2,-8(fp)
81110568:	10802e17 	ldw	r2,184(r2)
8111056c:	100f883a 	mov	r7,r2
81110570:	200d883a 	mov	r6,r4
81110574:	01604574 	movhi	r5,33045
81110578:	2973b104 	addi	r5,r5,-12604
8111057c:	1809883a 	mov	r4,r3
81110580:	11215e00 	call	811215e0 <fprintf>
				#endif


				pxNFeeP->xControl.eMode =  sNextPatternIteration;
81110584:	e0bffe17 	ldw	r2,-8(fp)
81110588:	00c00284 	movi	r3,10
8111058c:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode =  sFeeWaitingSync;
81110590:	e0bffe17 	ldw	r2,-8(fp)
81110594:	00c00304 	movi	r3,12
81110598:	10c02d15 	stw	r3,180(r2)
					#ifdef DEBUG_ON
						fprintf(fp,"\nNFEE %hhu Task: Can't change the CCD side while in transmission (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
					#endif
				}
			}
			break;
8111059c:	00007b06 	br	8111078c <vQCmdFeeRMAPWaitingSync+0x400>


				pxNFeeP->xControl.eMode =  sNextPatternIteration;
				pxNFeeP->xControl.eNextMode =  sFeeWaitingSync;
			} else {
				if (pxNFeeP->xControl.eNextMode == sFeeTestFullPattern) {
811105a0:	e0bffe17 	ldw	r2,-8(fp)
811105a4:	10802d17 	ldw	r2,180(r2)
811105a8:	10800118 	cmpnei	r2,r2,4
811105ac:	1000771e 	bne	r2,zero,8111078c <vQCmdFeeRMAPWaitingSync+0x400>
					#ifdef DEBUG_ON
						fprintf(fp,"\nNFEE %hhu Task: Can't change the CCD side while in transmission (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
811105b0:	d0e06217 	ldw	r3,-32376(gp)
811105b4:	e0bffe17 	ldw	r2,-8(fp)
811105b8:	10800003 	ldbu	r2,0(r2)
811105bc:	11003fcc 	andi	r4,r2,255
811105c0:	e0bffe17 	ldw	r2,-8(fp)
811105c4:	10802e17 	ldw	r2,184(r2)
811105c8:	100f883a 	mov	r7,r2
811105cc:	200d883a 	mov	r6,r4
811105d0:	01604574 	movhi	r5,33045
811105d4:	29740704 	addi	r5,r5,-12260
811105d8:	1809883a 	mov	r4,r3
811105dc:	11215e00 	call	811215e0 <fprintf>
					#endif
				}
			}
			break;
811105e0:	00006a06 	br	8111078c <vQCmdFeeRMAPWaitingSync+0x400>
		case 0x49://0x00000024:CCD_3_windowing_2_config
		case 0x4A://0x00000028:CCD_4_windowing_1_config
		case 0x4B://0x0000002C:CCD_4_windowing_2_config
		case 0x0000004C://0x00000038:operation_mode_config

		ucValueMasked = (COMM_RMAP_MODE_SEL_CTRL_MSK & ucValueReg) >>4;
811105e4:	e0bffa43 	ldbu	r2,-23(fp)
811105e8:	1004d13a 	srli	r2,r2,4
811105ec:	10803fcc 	andi	r2,r2,255
811105f0:	e0bffc15 	stw	r2,-16(fp)

		switch (ucValueMasked) {
811105f4:	e0bffc17 	ldw	r2,-16(fp)
811105f8:	10c000a0 	cmpeqi	r3,r2,2
811105fc:	1800141e 	bne	r3,zero,81110650 <vQCmdFeeRMAPWaitingSync+0x2c4>
81110600:	10c001a0 	cmpeqi	r3,r2,6
81110604:	18001c1e 	bne	r3,zero,81110678 <vQCmdFeeRMAPWaitingSync+0x2ec>
81110608:	1000231e 	bne	r2,zero,81110698 <vQCmdFeeRMAPWaitingSync+0x30c>
			case 0: /* Standby */
			#ifdef DEBUG_ON
				fprintf(fp,"- to Stand-By\n");
8111060c:	d0a06217 	ldw	r2,-32376(gp)
81110610:	100f883a 	mov	r7,r2
81110614:	01800384 	movi	r6,14
81110618:	01400044 	movi	r5,1
8111061c:	01204574 	movhi	r4,33045
81110620:	21341e04 	addi	r4,r4,-12168
81110624:	1121c7c0 	call	81121c7c <fwrite>
			#endif

				pxNFeeP->xControl.bWatingSync = TRUE;
81110628:	e0bffe17 	ldw	r2,-8(fp)
8111062c:	00c00044 	movi	r3,1
81110630:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
81110634:	e0bffe17 	ldw	r2,-8(fp)
81110638:	00c00304 	movi	r3,12
8111063c:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
81110640:	e0bffe17 	ldw	r2,-8(fp)
81110644:	00c00184 	movi	r3,6
81110648:	10c02d15 	stw	r3,180(r2)


				break;
8111064c:	00001906 	br	811106b4 <vQCmdFeeRMAPWaitingSync+0x328>
			case 2: /* PAttern Full image */

				pxNFeeP->xControl.bWatingSync = TRUE;
81110650:	e0bffe17 	ldw	r2,-8(fp)
81110654:	00c00044 	movi	r3,1
81110658:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync; /*sSIMTestFullPattern*/
8111065c:	e0bffe17 	ldw	r2,-8(fp)
81110660:	00c00304 	movi	r3,12
81110664:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sNextPatternIteration;
81110668:	e0bffe17 	ldw	r2,-8(fp)
8111066c:	00c00284 	movi	r3,10
81110670:	10c02d15 	stw	r3,180(r2)

				break;
81110674:	00000f06 	br	811106b4 <vQCmdFeeRMAPWaitingSync+0x328>
			case 6:
			#ifdef DEBUG_ON
				fprintf(fp," Off-Mode not allowed.\n");
81110678:	d0a06217 	ldw	r2,-32376(gp)
8111067c:	100f883a 	mov	r7,r2
81110680:	018005c4 	movi	r6,23
81110684:	01400044 	movi	r5,1
81110688:	01204574 	movhi	r4,33045
8111068c:	21342204 	addi	r4,r4,-12152
81110690:	1121c7c0 	call	81121c7c <fwrite>
			#endif
				break;
81110694:	00000706 	br	811106b4 <vQCmdFeeRMAPWaitingSync+0x328>
			case 3:
			case 4:
			case 5:
			default:
				#ifdef DEBUG_ON
					fprintf(fp," mode not allowed yet ( %hhu )\n", ucValueMasked);
81110698:	d0a06217 	ldw	r2,-32376(gp)
8111069c:	e1bffc17 	ldw	r6,-16(fp)
811106a0:	01604574 	movhi	r5,33045
811106a4:	29742804 	addi	r5,r5,-12128
811106a8:	1009883a 	mov	r4,r2
811106ac:	11215e00 	call	811215e0 <fprintf>
				#endif
				break;
811106b0:	0001883a 	nop
		}

			break;
811106b4:	00003806 	br	81110798 <vQCmdFeeRMAPWaitingSync+0x40c>
		case 2: /* PAttern Full image */
			#ifdef DEBUG_ON
				fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
811106b8:	d0e06217 	ldw	r3,-32376(gp)
811106bc:	e0bffe17 	ldw	r2,-8(fp)
811106c0:	10800003 	ldbu	r2,0(r2)
811106c4:	10803fcc 	andi	r2,r2,255
811106c8:	100d883a 	mov	r6,r2
811106cc:	01604574 	movhi	r5,33045
811106d0:	29736c04 	addi	r5,r5,-12880
811106d4:	1809883a 	mov	r4,r3
811106d8:	11215e00 	call	811215e0 <fprintf>
			#endif

			pxNFeeP->xControl.bWatingSync = TRUE;
811106dc:	e0bffe17 	ldw	r2,-8(fp)
811106e0:	00c00044 	movi	r3,1
811106e4:	10c02815 	stw	r3,160(r2)
			pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
811106e8:	e0bffe17 	ldw	r2,-8(fp)
811106ec:	00c00284 	movi	r3,10
811106f0:	10c02c15 	stw	r3,176(r2)
			pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
811106f4:	e0bffe17 	ldw	r2,-8(fp)
811106f8:	00c00304 	movi	r3,12
811106fc:	10c02d15 	stw	r3,180(r2)

			break;
81110700:	00002506 	br	81110798 <vQCmdFeeRMAPWaitingSync+0x40c>
		case 0x0000004D://0x0000003C:sync_config

			ucValueMasked = (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & ucValueReg) >> 2; /* Number of rows */
81110704:	e0bffa43 	ldbu	r2,-23(fp)
81110708:	1080010c 	andi	r2,r2,4
8111070c:	10803fcc 	andi	r2,r2,255
81110710:	1004d0ba 	srli	r2,r2,2
81110714:	10803fcc 	andi	r2,r2,255
81110718:	e0bffc15 	stw	r2,-16(fp)

			if ( ucValueMasked ) {
8111071c:	e0bffc17 	ldw	r2,-16(fp)
81110720:	10001c26 	beq	r2,zero,81110794 <vQCmdFeeRMAPWaitingSync+0x408>

				if ( pxNFeeP->xControl.eNextMode == sToFeeStandBy ) {
81110724:	e0bffe17 	ldw	r2,-8(fp)
81110728:	10802d17 	ldw	r2,180(r2)
8111072c:	10800198 	cmpnei	r2,r2,6
81110730:	1000181e 	bne	r2,zero,81110794 <vQCmdFeeRMAPWaitingSync+0x408>
					pxNFeeP->xControl.bWatingSync = FALSE;
81110734:	e0bffe17 	ldw	r2,-8(fp)
81110738:	10002815 	stw	zero,160(r2)
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
8111073c:	e0bffe17 	ldw	r2,-8(fp)
81110740:	10c02d17 	ldw	r3,180(r2)
81110744:	e0bffe17 	ldw	r2,-8(fp)
81110748:	10c02c15 	stw	r3,176(r2)
					#ifdef DEBUG_ON
						fprintf(fp," - Mode Forced.\n");
8111074c:	d0a06217 	ldw	r2,-32376(gp)
81110750:	100f883a 	mov	r7,r2
81110754:	01800404 	movi	r6,16
81110758:	01400044 	movi	r5,1
8111075c:	01204574 	movhi	r4,33045
81110760:	21343004 	addi	r4,r4,-12096
81110764:	1121c7c0 	call	81121c7c <fwrite>
//				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
			}

			break;
81110768:	00000a06 	br	81110794 <vQCmdFeeRMAPWaitingSync+0x408>
		case 0x0000004F://0x00000044:clock_source_control
		case 0x00000050://0x00000048:frame_number
		case 0x00000051://0x0000004C:current_mode
		default:
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
8111076c:	d0a06217 	ldw	r2,-32376(gp)
81110770:	e0fffa03 	ldbu	r3,-24(fp)
81110774:	180d883a 	mov	r6,r3
81110778:	01604574 	movhi	r5,33045
8111077c:	2973f104 	addi	r5,r5,-12348
81110780:	1009883a 	mov	r4,r2
81110784:	11215e00 	call	811215e0 <fprintf>
			#endif
			break;
81110788:	00000306 	br	81110798 <vQCmdFeeRMAPWaitingSync+0x40c>
					#ifdef DEBUG_ON
						fprintf(fp,"\nNFEE %hhu Task: Can't change the CCD side while in transmission (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
					#endif
				}
			}
			break;
8111078c:	0001883a 	nop
81110790:	00000106 	br	81110798 <vQCmdFeeRMAPWaitingSync+0x40c>
//				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
			}

			break;
81110794:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			#endif
			break;
		}
}
81110798:	0001883a 	nop
8111079c:	e037883a 	mov	sp,fp
811107a0:	dfc00117 	ldw	ra,4(sp)
811107a4:	df000017 	ldw	fp,0(sp)
811107a8:	dec00204 	addi	sp,sp,8
811107ac:	f800283a 	ret

811107b0 <bDisableRmapIRQ>:


bool bDisableRmapIRQ( TRmapChannel *pxRmapCh, unsigned char ucId ) {
811107b0:	defffc04 	addi	sp,sp,-16
811107b4:	de00012e 	bgeu	sp,et,811107bc <bDisableRmapIRQ+0xc>
811107b8:	003b68fa 	trap	3
811107bc:	dfc00315 	stw	ra,12(sp)
811107c0:	df000215 	stw	fp,8(sp)
811107c4:	df000204 	addi	fp,sp,8
811107c8:	e13ffe15 	stw	r4,-8(fp)
811107cc:	2805883a 	mov	r2,r5
811107d0:	e0bfff05 	stb	r2,-4(fp)
	/* Disable RMAP channel */
	bRmapGetIrqControl(pxRmapCh);
811107d4:	e13ffe17 	ldw	r4,-8(fp)
811107d8:	1107b280 	call	81107b28 <bRmapGetIrqControl>
	pxRmapCh->xRmapIrqControl.bWriteCmdEn = FALSE;
811107dc:	e0bffe17 	ldw	r2,-8(fp)
811107e0:	10001015 	stw	zero,64(r2)
	bRmapSetIrqControl(pxRmapCh);
811107e4:	e13ffe17 	ldw	r4,-8(fp)
811107e8:	1107a800 	call	81107a80 <bRmapSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
811107ec:	00800044 	movi	r2,1
}
811107f0:	e037883a 	mov	sp,fp
811107f4:	dfc00117 	ldw	ra,4(sp)
811107f8:	df000017 	ldw	fp,0(sp)
811107fc:	dec00204 	addi	sp,sp,8
81110800:	f800283a 	ret

81110804 <bEnableRmapIRQ>:

bool bEnableRmapIRQ( TRmapChannel *pxRmapCh, unsigned char ucId ) {
81110804:	defffc04 	addi	sp,sp,-16
81110808:	de00012e 	bgeu	sp,et,81110810 <bEnableRmapIRQ+0xc>
8111080c:	003b68fa 	trap	3
81110810:	dfc00315 	stw	ra,12(sp)
81110814:	df000215 	stw	fp,8(sp)
81110818:	df000204 	addi	fp,sp,8
8111081c:	e13ffe15 	stw	r4,-8(fp)
81110820:	2805883a 	mov	r2,r5
81110824:	e0bfff05 	stb	r2,-4(fp)
	/* Enable RMAP */
	/* Before Enable the IRQ for Rmap, make a copy for compare when some command arrive */
	//bRmapGetMemConfigArea(&xRmap[ucId]);

	bRmapGetIrqControl(pxRmapCh);
81110828:	e13ffe17 	ldw	r4,-8(fp)
8111082c:	1107b280 	call	81107b28 <bRmapGetIrqControl>
	pxRmapCh->xRmapIrqControl.bWriteCmdEn = TRUE;
81110830:	e0bffe17 	ldw	r2,-8(fp)
81110834:	00c00044 	movi	r3,1
81110838:	10c01015 	stw	r3,64(r2)
	bRmapSetIrqControl(pxRmapCh);
8111083c:	e13ffe17 	ldw	r4,-8(fp)
81110840:	1107a800 	call	81107a80 <bRmapSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
81110844:	00800044 	movi	r2,1
}
81110848:	e037883a 	mov	sp,fp
8111084c:	dfc00117 	ldw	ra,4(sp)
81110850:	df000017 	ldw	fp,0(sp)
81110854:	dec00204 	addi	sp,sp,8
81110858:	f800283a 	ret

8111085c <bDisableSPWChannel>:

bool bDisableSPWChannel( TSpwcChannel *xSPW ) {
8111085c:	defffd04 	addi	sp,sp,-12
81110860:	de00012e 	bgeu	sp,et,81110868 <bDisableSPWChannel+0xc>
81110864:	003b68fa 	trap	3
81110868:	dfc00215 	stw	ra,8(sp)
8111086c:	df000115 	stw	fp,4(sp)
81110870:	df000104 	addi	fp,sp,4
81110874:	e13fff15 	stw	r4,-4(fp)
	/* Disable SPW channel */
	bSpwcGetLink(xSPW);
81110878:	e13fff17 	ldw	r4,-4(fp)
8111087c:	110a4ac0 	call	8110a4ac <bSpwcGetLink>
	xSPW->xLinkConfig.bLinkStart = FALSE;
81110880:	e0bfff17 	ldw	r2,-4(fp)
81110884:	10000215 	stw	zero,8(r2)
	xSPW->xLinkConfig.bAutostart = FALSE;
81110888:	e0bfff17 	ldw	r2,-4(fp)
8111088c:	10000115 	stw	zero,4(r2)
	xSPW->xLinkConfig.bDisconnect = TRUE;
81110890:	e0bfff17 	ldw	r2,-4(fp)
81110894:	00c00044 	movi	r3,1
81110898:	10c00315 	stw	r3,12(r2)
	bSpwcSetLink(xSPW);
8111089c:	e13fff17 	ldw	r4,-4(fp)
811108a0:	110a3780 	call	8110a378 <bSpwcSetLink>

	/*todo: No treatment for now  */
	return TRUE;
811108a4:	00800044 	movi	r2,1
}
811108a8:	e037883a 	mov	sp,fp
811108ac:	dfc00117 	ldw	ra,4(sp)
811108b0:	df000017 	ldw	fp,0(sp)
811108b4:	dec00204 	addi	sp,sp,8
811108b8:	f800283a 	ret

811108bc <bEnableSPWChannel>:

bool bEnableSPWChannel( TSpwcChannel *xSPW ) {
811108bc:	defffd04 	addi	sp,sp,-12
811108c0:	de00012e 	bgeu	sp,et,811108c8 <bEnableSPWChannel+0xc>
811108c4:	003b68fa 	trap	3
811108c8:	dfc00215 	stw	ra,8(sp)
811108cc:	df000115 	stw	fp,4(sp)
811108d0:	df000104 	addi	fp,sp,4
811108d4:	e13fff15 	stw	r4,-4(fp)
	/* Enable SPW channel */
	bSpwcGetLink(xSPW);
811108d8:	e13fff17 	ldw	r4,-4(fp)
811108dc:	110a4ac0 	call	8110a4ac <bSpwcGetLink>
	xSPW->xLinkConfig.bLinkStart = FALSE;
811108e0:	e0bfff17 	ldw	r2,-4(fp)
811108e4:	10000215 	stw	zero,8(r2)
	xSPW->xLinkConfig.bAutostart = TRUE;
811108e8:	e0bfff17 	ldw	r2,-4(fp)
811108ec:	00c00044 	movi	r3,1
811108f0:	10c00115 	stw	r3,4(r2)
	xSPW->xLinkConfig.bDisconnect = FALSE;
811108f4:	e0bfff17 	ldw	r2,-4(fp)
811108f8:	10000315 	stw	zero,12(r2)
	bSpwcSetLink(xSPW);
811108fc:	e13fff17 	ldw	r4,-4(fp)
81110900:	110a3780 	call	8110a378 <bSpwcSetLink>

	/*todo: No treatment for now  */
	return TRUE;
81110904:	00800044 	movi	r2,1
}
81110908:	e037883a 	mov	sp,fp
8111090c:	dfc00117 	ldw	ra,4(sp)
81110910:	df000017 	ldw	fp,0(sp)
81110914:	dec00204 	addi	sp,sp,8
81110918:	f800283a 	ret

8111091c <bEnableDbBuffer>:

bool bEnableDbBuffer( TFeebChannel *pxFeebCh ) {
8111091c:	defffd04 	addi	sp,sp,-12
81110920:	de00012e 	bgeu	sp,et,81110928 <bEnableDbBuffer+0xc>
81110924:	003b68fa 	trap	3
81110928:	dfc00215 	stw	ra,8(sp)
8111092c:	df000115 	stw	fp,4(sp)
81110930:	df000104 	addi	fp,sp,4
81110934:	e13fff15 	stw	r4,-4(fp)
	// TODO: mudar [rfranca]
	/* Stop the module Double Buffer */
	bFeebStopCh(pxFeebCh);
81110938:	e13fff17 	ldw	r4,-4(fp)
8111093c:	1106b800 	call	81106b80 <bFeebStopCh>
	// TODO: mudar [rfranca]
	/* Clear all buffer form the Double Buffer */
	bFeebClrCh(pxFeebCh);
81110940:	e13fff17 	ldw	r4,-4(fp)
81110944:	1106c080 	call	81106c08 <bFeebClrCh>
	// TODO: mudar [rfranca]
	/* Start the module Double Buffer */
	bFeebStartCh(pxFeebCh);
81110948:	e13fff17 	ldw	r4,-4(fp)
8111094c:	1106af80 	call	81106af8 <bFeebStartCh>

	/*Enable IRQ of FEE Buffer*/
	bFeebGetWindowing(pxFeebCh);
81110950:	e13fff17 	ldw	r4,-4(fp)
81110954:	1106a700 	call	81106a70 <bFeebGetWindowing>
	//pxFeebCh->xWindowingConfig.bMasking = DATA_PACKET;/* True= data packet;    FALSE= Transparent mode */
	pxFeebCh->xWindowingConfig.bMasking = xDefaults.bDataPacket;
81110958:	00a045b4 	movhi	r2,33046
8111095c:	109c0004 	addi	r2,r2,28672
81110960:	10c00817 	ldw	r3,32(r2)
81110964:	e0bfff17 	ldw	r2,-4(fp)
81110968:	10c00115 	stw	r3,4(r2)
	bFeebSetWindowing(pxFeebCh);
8111096c:	e13fff17 	ldw	r4,-4(fp)
81110970:	11069c80 	call	811069c8 <bFeebSetWindowing>

	/*Enable IRQ of FEE Buffer*/
	bFeebGetIrqControl(pxFeebCh);
81110974:	e13fff17 	ldw	r4,-4(fp)
81110978:	11064180 	call	81106418 <bFeebGetIrqControl>
	pxFeebCh->xIrqControl.bLeftBufferEmptyEn = TRUE;
8111097c:	e0bfff17 	ldw	r2,-4(fp)
81110980:	00c00044 	movi	r3,1
81110984:	10c00215 	stw	r3,8(r2)
	pxFeebCh->xIrqControl.bRightBufferEmptyEn = TRUE;
81110988:	e0bfff17 	ldw	r2,-4(fp)
8111098c:	00c00044 	movi	r3,1
81110990:	10c00315 	stw	r3,12(r2)
	bFeebSetIrqControl(pxFeebCh);
81110994:	e13fff17 	ldw	r4,-4(fp)
81110998:	11063440 	call	81106344 <bFeebSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
8111099c:	00800044 	movi	r2,1
}
811109a0:	e037883a 	mov	sp,fp
811109a4:	dfc00117 	ldw	ra,4(sp)
811109a8:	df000017 	ldw	fp,0(sp)
811109ac:	dec00204 	addi	sp,sp,8
811109b0:	f800283a 	ret

811109b4 <bDisAndClrDbBuffer>:


bool bDisAndClrDbBuffer( TFeebChannel *pxFeebCh ) {
811109b4:	defffd04 	addi	sp,sp,-12
811109b8:	de00012e 	bgeu	sp,et,811109c0 <bDisAndClrDbBuffer+0xc>
811109bc:	003b68fa 	trap	3
811109c0:	dfc00215 	stw	ra,8(sp)
811109c4:	df000115 	stw	fp,4(sp)
811109c8:	df000104 	addi	fp,sp,4
811109cc:	e13fff15 	stw	r4,-4(fp)

	/*Disable IRQ of FEE Buffer*/
	bFeebGetIrqControl(pxFeebCh);
811109d0:	e13fff17 	ldw	r4,-4(fp)
811109d4:	11064180 	call	81106418 <bFeebGetIrqControl>
	pxFeebCh->xIrqControl.bLeftBufferEmptyEn = FALSE;
811109d8:	e0bfff17 	ldw	r2,-4(fp)
811109dc:	10000215 	stw	zero,8(r2)
	pxFeebCh->xIrqControl.bRightBufferEmptyEn = FALSE;
811109e0:	e0bfff17 	ldw	r2,-4(fp)
811109e4:	10000315 	stw	zero,12(r2)
	bFeebSetIrqControl(pxFeebCh);
811109e8:	e13fff17 	ldw	r4,-4(fp)
811109ec:	11063440 	call	81106344 <bFeebSetIrqControl>

	/* Stop the module Double Buffer */
	bFeebStopCh(pxFeebCh);
811109f0:	e13fff17 	ldw	r4,-4(fp)
811109f4:	1106b800 	call	81106b80 <bFeebStopCh>

	/* Clear all buffer form the Double Buffer */
	bFeebClrCh(pxFeebCh);
811109f8:	e13fff17 	ldw	r4,-4(fp)
811109fc:	1106c080 	call	81106c08 <bFeebClrCh>
	// TODO: remover [rfranca]
	bFeebStartCh(pxFeebCh);
81110a00:	e13fff17 	ldw	r4,-4(fp)
81110a04:	1106af80 	call	81106af8 <bFeebStartCh>

	/*todo: No treatment for now  */
	return TRUE;
81110a08:	00800044 	movi	r2,1
}
81110a0c:	e037883a 	mov	sp,fp
81110a10:	dfc00117 	ldw	ra,4(sp)
81110a14:	df000017 	ldw	fp,0(sp)
81110a18:	dec00204 	addi	sp,sp,8
81110a1c:	f800283a 	ret

81110a20 <bSendRequestNFeeCtrl>:

bool bSendRequestNFeeCtrl( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81110a20:	defff804 	addi	sp,sp,-32
81110a24:	de00012e 	bgeu	sp,et,81110a2c <bSendRequestNFeeCtrl+0xc>
81110a28:	003b68fa 	trap	3
81110a2c:	dfc00715 	stw	ra,28(sp)
81110a30:	df000615 	stw	fp,24(sp)
81110a34:	df000604 	addi	fp,sp,24
81110a38:	2807883a 	mov	r3,r5
81110a3c:	3005883a 	mov	r2,r6
81110a40:	e13ffd05 	stb	r4,-12(fp)
81110a44:	e0fffe05 	stb	r3,-8(fp)
81110a48:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81110a4c:	00800404 	movi	r2,16
81110a50:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81110a54:	e0bffd03 	ldbu	r2,-12(fp)
81110a58:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81110a5c:	e0bffe03 	ldbu	r2,-8(fp)
81110a60:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81110a64:	e0bfff03 	ldbu	r2,-4(fp)
81110a68:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
81110a6c:	e03ffa15 	stw	zero,-24(fp)
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
81110a70:	d0a05d17 	ldw	r2,-32396(gp)
81110a74:	e0fffc17 	ldw	r3,-16(fp)
81110a78:	180b883a 	mov	r5,r3
81110a7c:	1009883a 	mov	r4,r2
81110a80:	113e0280 	call	8113e028 <OSQPost>
81110a84:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81110a88:	e0bffb03 	ldbu	r2,-20(fp)
81110a8c:	10000526 	beq	r2,zero,81110aa4 <bSendRequestNFeeCtrl+0x84>
		vFailRequestDMA( ucValue );
81110a90:	e0bfff03 	ldbu	r2,-4(fp)
81110a94:	1009883a 	mov	r4,r2
81110a98:	111d4040 	call	8111d404 <vFailRequestDMA>
		bSuccesL = FALSE;
81110a9c:	e03ffa15 	stw	zero,-24(fp)
81110aa0:	00000206 	br	81110aac <bSendRequestNFeeCtrl+0x8c>
	} else {
		bSuccesL =  TRUE;
81110aa4:	00800044 	movi	r2,1
81110aa8:	e0bffa15 	stw	r2,-24(fp)
	}

	return bSuccesL;
81110aac:	e0bffa17 	ldw	r2,-24(fp)
}
81110ab0:	e037883a 	mov	sp,fp
81110ab4:	dfc00117 	ldw	ra,4(sp)
81110ab8:	df000017 	ldw	fp,0(sp)
81110abc:	dec00204 	addi	sp,sp,8
81110ac0:	f800283a 	ret

81110ac4 <bSendGiveBackNFeeCtrl>:


bool bSendGiveBackNFeeCtrl( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81110ac4:	defff804 	addi	sp,sp,-32
81110ac8:	de00012e 	bgeu	sp,et,81110ad0 <bSendGiveBackNFeeCtrl+0xc>
81110acc:	003b68fa 	trap	3
81110ad0:	dfc00715 	stw	ra,28(sp)
81110ad4:	df000615 	stw	fp,24(sp)
81110ad8:	df000604 	addi	fp,sp,24
81110adc:	2807883a 	mov	r3,r5
81110ae0:	3005883a 	mov	r2,r6
81110ae4:	e13ffd05 	stb	r4,-12(fp)
81110ae8:	e0fffe05 	stb	r3,-8(fp)
81110aec:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81110af0:	00800404 	movi	r2,16
81110af4:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81110af8:	e0bffd03 	ldbu	r2,-12(fp)
81110afc:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81110b00:	e0bffe03 	ldbu	r2,-8(fp)
81110b04:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81110b08:	e0bfff03 	ldbu	r2,-4(fp)
81110b0c:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
81110b10:	e03ffa15 	stw	zero,-24(fp)
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
81110b14:	d0a07017 	ldw	r2,-32320(gp)
81110b18:	e0fffc17 	ldw	r3,-16(fp)
81110b1c:	180b883a 	mov	r5,r3
81110b20:	1009883a 	mov	r4,r2
81110b24:	113e0280 	call	8113e028 <OSQPost>
81110b28:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81110b2c:	e0bffb03 	ldbu	r2,-20(fp)
81110b30:	10000526 	beq	r2,zero,81110b48 <bSendGiveBackNFeeCtrl+0x84>
		vFailRequestDMA( ucValue );
81110b34:	e0bfff03 	ldbu	r2,-4(fp)
81110b38:	1009883a 	mov	r4,r2
81110b3c:	111d4040 	call	8111d404 <vFailRequestDMA>
		bSuccesL = FALSE;
81110b40:	e03ffa15 	stw	zero,-24(fp)
81110b44:	00000206 	br	81110b50 <bSendGiveBackNFeeCtrl+0x8c>
	} else {
		bSuccesL =  TRUE;
81110b48:	00800044 	movi	r2,1
81110b4c:	e0bffa15 	stw	r2,-24(fp)
	}

	return bSuccesL;
81110b50:	e0bffa17 	ldw	r2,-24(fp)
}
81110b54:	e037883a 	mov	sp,fp
81110b58:	dfc00117 	ldw	ra,4(sp)
81110b5c:	df000017 	ldw	fp,0(sp)
81110b60:	dec00204 	addi	sp,sp,8
81110b64:	f800283a 	ret

81110b68 <vPrintConsoleNFee>:




#ifdef DEBUG_ON
	void vPrintConsoleNFee( TNFee *pxNFeeI ) {
81110b68:	defffa04 	addi	sp,sp,-24
81110b6c:	de00012e 	bgeu	sp,et,81110b74 <vPrintConsoleNFee+0xc>
81110b70:	003b68fa 	trap	3
81110b74:	dfc00515 	stw	ra,20(sp)
81110b78:	df000415 	stw	fp,16(sp)
81110b7c:	df000404 	addi	fp,sp,16
81110b80:	e13fff15 	stw	r4,-4(fp)
		TNFee *pxNFee;

		pxNFee = pxNFeeI;
81110b84:	e0bfff17 	ldw	r2,-4(fp)
81110b88:	e0bffe15 	stw	r2,-8(fp)

		fprintf(fp,"=================================NFEE %hhu=====================================\n", pxNFee->ucId);
81110b8c:	d0e06217 	ldw	r3,-32376(gp)
81110b90:	e0bffe17 	ldw	r2,-8(fp)
81110b94:	10800003 	ldbu	r2,0(r2)
81110b98:	10803fcc 	andi	r2,r2,255
81110b9c:	100d883a 	mov	r6,r2
81110ba0:	01604574 	movhi	r5,33045
81110ba4:	29744204 	addi	r5,r5,-12024
81110ba8:	1809883a 	mov	r4,r3
81110bac:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"\n");
81110bb0:	d0a06217 	ldw	r2,-32376(gp)
81110bb4:	100b883a 	mov	r5,r2
81110bb8:	01000284 	movi	r4,10
81110bbc:	11216580 	call	81121658 <fputc>
		fprintf(fp,"NFEE %hhu CCD infos: \n", pxNFee->ucId);
81110bc0:	d0e06217 	ldw	r3,-32376(gp)
81110bc4:	e0bffe17 	ldw	r2,-8(fp)
81110bc8:	10800003 	ldbu	r2,0(r2)
81110bcc:	10803fcc 	andi	r2,r2,255
81110bd0:	100d883a 	mov	r6,r2
81110bd4:	01604574 	movhi	r5,33045
81110bd8:	29745704 	addi	r5,r5,-11940
81110bdc:	1809883a 	mov	r4,r3
81110be0:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"    PreScan = %hu \n", pxNFee->xCcdInfo.usiSPrescanN);
81110be4:	d0e06217 	ldw	r3,-32376(gp)
81110be8:	e0bffe17 	ldw	r2,-8(fp)
81110bec:	10802f0b 	ldhu	r2,188(r2)
81110bf0:	10bfffcc 	andi	r2,r2,65535
81110bf4:	100d883a 	mov	r6,r2
81110bf8:	01604574 	movhi	r5,33045
81110bfc:	29745d04 	addi	r5,r5,-11916
81110c00:	1809883a 	mov	r4,r3
81110c04:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"    OverScan = %hu \n", pxNFee->xCcdInfo.usiSOverscanN);
81110c08:	d0e06217 	ldw	r3,-32376(gp)
81110c0c:	e0bffe17 	ldw	r2,-8(fp)
81110c10:	10802f8b 	ldhu	r2,190(r2)
81110c14:	10bfffcc 	andi	r2,r2,65535
81110c18:	100d883a 	mov	r6,r2
81110c1c:	01604574 	movhi	r5,33045
81110c20:	29746204 	addi	r5,r5,-11896
81110c24:	1809883a 	mov	r4,r3
81110c28:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"    OLN = %hu \n", pxNFee->xCcdInfo.usiOLN);
81110c2c:	d0e06217 	ldw	r3,-32376(gp)
81110c30:	e0bffe17 	ldw	r2,-8(fp)
81110c34:	1080300b 	ldhu	r2,192(r2)
81110c38:	10bfffcc 	andi	r2,r2,65535
81110c3c:	100d883a 	mov	r6,r2
81110c40:	01604574 	movhi	r5,33045
81110c44:	29746804 	addi	r5,r5,-11872
81110c48:	1809883a 	mov	r4,r3
81110c4c:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"    Half Width = %hu \n", pxNFee->xCcdInfo.usiHalfWidth);
81110c50:	d0e06217 	ldw	r3,-32376(gp)
81110c54:	e0bffe17 	ldw	r2,-8(fp)
81110c58:	1080308b 	ldhu	r2,194(r2)
81110c5c:	10bfffcc 	andi	r2,r2,65535
81110c60:	100d883a 	mov	r6,r2
81110c64:	01604574 	movhi	r5,33045
81110c68:	29746c04 	addi	r5,r5,-11856
81110c6c:	1809883a 	mov	r4,r3
81110c70:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"    Height = %hu \n", pxNFee->xCcdInfo.usiHeight);
81110c74:	d0e06217 	ldw	r3,-32376(gp)
81110c78:	e0bffe17 	ldw	r2,-8(fp)
81110c7c:	1080310b 	ldhu	r2,196(r2)
81110c80:	10bfffcc 	andi	r2,r2,65535
81110c84:	100d883a 	mov	r6,r2
81110c88:	01604574 	movhi	r5,33045
81110c8c:	29747204 	addi	r5,r5,-11832
81110c90:	1809883a 	mov	r4,r3
81110c94:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"\n");
81110c98:	d0a06217 	ldw	r2,-32376(gp)
81110c9c:	100b883a 	mov	r5,r2
81110ca0:	01000284 	movi	r4,10
81110ca4:	11216580 	call	81121658 <fputc>
		fprintf(fp,"NFEE %hhu Control: \n", pxNFee->ucId);
81110ca8:	d0e06217 	ldw	r3,-32376(gp)
81110cac:	e0bffe17 	ldw	r2,-8(fp)
81110cb0:	10800003 	ldbu	r2,0(r2)
81110cb4:	10803fcc 	andi	r2,r2,255
81110cb8:	100d883a 	mov	r6,r2
81110cbc:	01604574 	movhi	r5,33045
81110cc0:	29747704 	addi	r5,r5,-11812
81110cc4:	1809883a 	mov	r4,r3
81110cc8:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"    NFEE State 	= %hu \n", pxNFee->xControl.eMode);
81110ccc:	d0e06217 	ldw	r3,-32376(gp)
81110cd0:	e0bffe17 	ldw	r2,-8(fp)
81110cd4:	10802c17 	ldw	r2,176(r2)
81110cd8:	100d883a 	mov	r6,r2
81110cdc:	01604574 	movhi	r5,33045
81110ce0:	29747d04 	addi	r5,r5,-11788
81110ce4:	1809883a 	mov	r4,r3
81110ce8:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"    NFEE Enable? = %hu \n", pxNFee->xControl.bEnabled);
81110cec:	d0e06217 	ldw	r3,-32376(gp)
81110cf0:	e0bffe17 	ldw	r2,-8(fp)
81110cf4:	10802117 	ldw	r2,132(r2)
81110cf8:	100d883a 	mov	r6,r2
81110cfc:	01604574 	movhi	r5,33045
81110d00:	29748304 	addi	r5,r5,-11764
81110d04:	1809883a 	mov	r4,r3
81110d08:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"    Using DMA?   = %hu \n", pxNFee->xControl.bUsingDMA);
81110d0c:	d0e06217 	ldw	r3,-32376(gp)
81110d10:	e0bffe17 	ldw	r2,-8(fp)
81110d14:	10802317 	ldw	r2,140(r2)
81110d18:	100d883a 	mov	r6,r2
81110d1c:	01604574 	movhi	r5,33045
81110d20:	29748a04 	addi	r5,r5,-11736
81110d24:	1809883a 	mov	r4,r3
81110d28:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"    Logging?     = %hu \n", pxNFee->xControl.bLogging);
81110d2c:	d0e06217 	ldw	r3,-32376(gp)
81110d30:	e0bffe17 	ldw	r2,-8(fp)
81110d34:	10802417 	ldw	r2,144(r2)
81110d38:	100d883a 	mov	r6,r2
81110d3c:	01604574 	movhi	r5,33045
81110d40:	29749104 	addi	r5,r5,-11708
81110d44:	1809883a 	mov	r4,r3
81110d48:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"    Echoing?     = %hu \n", pxNFee->xControl.bEchoing);
81110d4c:	d0e06217 	ldw	r3,-32376(gp)
81110d50:	e0bffe17 	ldw	r2,-8(fp)
81110d54:	10802517 	ldw	r2,148(r2)
81110d58:	100d883a 	mov	r6,r2
81110d5c:	01604574 	movhi	r5,33045
81110d60:	29749804 	addi	r5,r5,-11680
81110d64:	1809883a 	mov	r4,r3
81110d68:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"    Channel Enable? = %hu \n", pxNFee->xControl.bChannelEnable);
81110d6c:	d0e06217 	ldw	r3,-32376(gp)
81110d70:	e0bffe17 	ldw	r2,-8(fp)
81110d74:	10802617 	ldw	r2,152(r2)
81110d78:	100d883a 	mov	r6,r2
81110d7c:	01604574 	movhi	r5,33045
81110d80:	29749f04 	addi	r5,r5,-11652
81110d84:	1809883a 	mov	r4,r3
81110d88:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"    Readout order = [ %hhu , %hhu , %hhu , %hhu ] \n", pxNFee->xControl.ucROutOrder[0], pxNFee->xControl.ucROutOrder[1], pxNFee->xControl.ucROutOrder[2], pxNFee->xControl.ucROutOrder[3]);
81110d8c:	d1206217 	ldw	r4,-32376(gp)
81110d90:	e0bffe17 	ldw	r2,-8(fp)
81110d94:	10802a43 	ldbu	r2,169(r2)
81110d98:	11403fcc 	andi	r5,r2,255
81110d9c:	e0bffe17 	ldw	r2,-8(fp)
81110da0:	10802a83 	ldbu	r2,170(r2)
81110da4:	11803fcc 	andi	r6,r2,255
81110da8:	e0bffe17 	ldw	r2,-8(fp)
81110dac:	10802ac3 	ldbu	r2,171(r2)
81110db0:	10803fcc 	andi	r2,r2,255
81110db4:	e0fffe17 	ldw	r3,-8(fp)
81110db8:	18c02b03 	ldbu	r3,172(r3)
81110dbc:	18c03fcc 	andi	r3,r3,255
81110dc0:	d8c00115 	stw	r3,4(sp)
81110dc4:	d8800015 	stw	r2,0(sp)
81110dc8:	300f883a 	mov	r7,r6
81110dcc:	280d883a 	mov	r6,r5
81110dd0:	01604574 	movhi	r5,33045
81110dd4:	2974a604 	addi	r5,r5,-11624
81110dd8:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"    CCD Side = = %hu \n", pxNFee->xControl.eSide);
81110ddc:	d0e06217 	ldw	r3,-32376(gp)
81110de0:	e0bffe17 	ldw	r2,-8(fp)
81110de4:	10802e17 	ldw	r2,184(r2)
81110de8:	100d883a 	mov	r6,r2
81110dec:	01604574 	movhi	r5,33045
81110df0:	2974b304 	addi	r5,r5,-11572
81110df4:	1809883a 	mov	r4,r3
81110df8:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"\n\n");
81110dfc:	d0a06217 	ldw	r2,-32376(gp)
81110e00:	100f883a 	mov	r7,r2
81110e04:	01800084 	movi	r6,2
81110e08:	01400044 	movi	r5,1
81110e0c:	01204574 	movhi	r4,33045
81110e10:	2134b904 	addi	r4,r4,-11548
81110e14:	1121c7c0 	call	81121c7c <fwrite>
		fprintf(fp,"NFEE %hhu MEMORY MAP: \n", pxNFee->ucId);
81110e18:	d0e06217 	ldw	r3,-32376(gp)
81110e1c:	e0bffe17 	ldw	r2,-8(fp)
81110e20:	10800003 	ldbu	r2,0(r2)
81110e24:	10803fcc 	andi	r2,r2,255
81110e28:	100d883a 	mov	r6,r2
81110e2c:	01604574 	movhi	r5,33045
81110e30:	2974ba04 	addi	r5,r5,-11544
81110e34:	1809883a 	mov	r4,r3
81110e38:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"    General Info: \n");
81110e3c:	d0a06217 	ldw	r2,-32376(gp)
81110e40:	100f883a 	mov	r7,r2
81110e44:	018004c4 	movi	r6,19
81110e48:	01400044 	movi	r5,1
81110e4c:	01204574 	movhi	r4,33045
81110e50:	2134c004 	addi	r4,r4,-11520
81110e54:	1121c7c0 	call	81121c7c <fwrite>
		fprintf(fp,"        Offset root 	= %lu \n", pxNFee->xMemMap.ulOffsetRoot);
81110e58:	d0e06217 	ldw	r3,-32376(gp)
81110e5c:	e0bffe17 	ldw	r2,-8(fp)
81110e60:	10800117 	ldw	r2,4(r2)
81110e64:	100d883a 	mov	r6,r2
81110e68:	01604574 	movhi	r5,33045
81110e6c:	2974c504 	addi	r5,r5,-11500
81110e70:	1809883a 	mov	r4,r3
81110e74:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"        Total Bytes 	= %lu \n", pxNFee->xMemMap.ulTotalBytes);
81110e78:	d0e06217 	ldw	r3,-32376(gp)
81110e7c:	e0bffe17 	ldw	r2,-8(fp)
81110e80:	10800217 	ldw	r2,8(r2)
81110e84:	100d883a 	mov	r6,r2
81110e88:	01604574 	movhi	r5,33045
81110e8c:	2974cd04 	addi	r5,r5,-11468
81110e90:	1809883a 	mov	r4,r3
81110e94:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"        LUT ADDR 	= %lu \n", pxNFee->xMemMap.ulLUTAddr);
81110e98:	d0e06217 	ldw	r3,-32376(gp)
81110e9c:	e0bffe17 	ldw	r2,-8(fp)
81110ea0:	10800317 	ldw	r2,12(r2)
81110ea4:	100d883a 	mov	r6,r2
81110ea8:	01604574 	movhi	r5,33045
81110eac:	2974d504 	addi	r5,r5,-11436
81110eb0:	1809883a 	mov	r4,r3
81110eb4:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"    Common to all CCDs: \n");
81110eb8:	d0a06217 	ldw	r2,-32376(gp)
81110ebc:	100f883a 	mov	r7,r2
81110ec0:	01800644 	movi	r6,25
81110ec4:	01400044 	movi	r5,1
81110ec8:	01204574 	movhi	r4,33045
81110ecc:	2134dc04 	addi	r4,r4,-11408
81110ed0:	1121c7c0 	call	81121c7c <fwrite>
		fprintf(fp,"        Total Bytes 	= %hu \n", pxNFee->xMemMap.xCommon.usiTotalBytes);
81110ed4:	d0e06217 	ldw	r3,-32376(gp)
81110ed8:	e0bffe17 	ldw	r2,-8(fp)
81110edc:	10800517 	ldw	r2,20(r2)
81110ee0:	100d883a 	mov	r6,r2
81110ee4:	01604574 	movhi	r5,33045
81110ee8:	2974e304 	addi	r5,r5,-11380
81110eec:	1809883a 	mov	r4,r3
81110ef0:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"        Total of Blocks = %hu \n", pxNFee->xMemMap.xCommon.usiNTotalBlocks);
81110ef4:	d0e06217 	ldw	r3,-32376(gp)
81110ef8:	e0bffe17 	ldw	r2,-8(fp)
81110efc:	10800417 	ldw	r2,16(r2)
81110f00:	100d883a 	mov	r6,r2
81110f04:	01604574 	movhi	r5,33045
81110f08:	2974eb04 	addi	r5,r5,-11348
81110f0c:	1809883a 	mov	r4,r3
81110f10:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"        Padding Bytes 	= %hhu\n", pxNFee->xMemMap.xCommon.ucPaddingBytes);
81110f14:	d0e06217 	ldw	r3,-32376(gp)
81110f18:	e0bffe17 	ldw	r2,-8(fp)
81110f1c:	10800603 	ldbu	r2,24(r2)
81110f20:	10803fcc 	andi	r2,r2,255
81110f24:	100d883a 	mov	r6,r2
81110f28:	01604574 	movhi	r5,33045
81110f2c:	2974f304 	addi	r5,r5,-11316
81110f30:	1809883a 	mov	r4,r3
81110f34:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"        Padding MASK 	= %llu\n", pxNFee->xMemMap.xCommon.ucPaddingMask.ullWord);
81110f38:	d2206217 	ldw	r8,-32376(gp)
81110f3c:	e13ffe17 	ldw	r4,-8(fp)
81110f40:	20800717 	ldw	r2,28(r4)
81110f44:	20c00817 	ldw	r3,32(r4)
81110f48:	100d883a 	mov	r6,r2
81110f4c:	180f883a 	mov	r7,r3
81110f50:	01604574 	movhi	r5,33045
81110f54:	2974fb04 	addi	r5,r5,-11284
81110f58:	4009883a 	mov	r4,r8
81110f5c:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"\n");
81110f60:	d0a06217 	ldw	r2,-32376(gp)
81110f64:	100b883a 	mov	r5,r2
81110f68:	01000284 	movi	r4,10
81110f6c:	11216580 	call	81121658 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 0 , pxNFee->ucId);
81110f70:	d0e06217 	ldw	r3,-32376(gp)
81110f74:	e0bffe17 	ldw	r2,-8(fp)
81110f78:	10800003 	ldbu	r2,0(r2)
81110f7c:	10803fcc 	andi	r2,r2,255
81110f80:	100f883a 	mov	r7,r2
81110f84:	000d883a 	mov	r6,zero
81110f88:	01604574 	movhi	r5,33045
81110f8c:	29750304 	addi	r5,r5,-11252
81110f90:	1809883a 	mov	r4,r3
81110f94:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"        Left side \n");
81110f98:	d0a06217 	ldw	r2,-32376(gp)
81110f9c:	100f883a 	mov	r7,r2
81110fa0:	018004c4 	movi	r6,19
81110fa4:	01400044 	movi	r5,1
81110fa8:	01204574 	movhi	r4,33045
81110fac:	21350d04 	addi	r4,r4,-11212
81110fb0:	1121c7c0 	call	81121c7c <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulOffsetAddr);
81110fb4:	d0e06217 	ldw	r3,-32376(gp)
81110fb8:	e0bffe17 	ldw	r2,-8(fp)
81110fbc:	10800917 	ldw	r2,36(r2)
81110fc0:	100d883a 	mov	r6,r2
81110fc4:	01604574 	movhi	r5,33045
81110fc8:	29751204 	addi	r5,r5,-11192
81110fcc:	1809883a 	mov	r4,r3
81110fd0:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulBlockI);
81110fd4:	d0e06217 	ldw	r3,-32376(gp)
81110fd8:	e0bffe17 	ldw	r2,-8(fp)
81110fdc:	10800a17 	ldw	r2,40(r2)
81110fe0:	100d883a 	mov	r6,r2
81110fe4:	01604574 	movhi	r5,33045
81110fe8:	29751b04 	addi	r5,r5,-11156
81110fec:	1809883a 	mov	r4,r3
81110ff0:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulAddrI);
81110ff4:	d0e06217 	ldw	r3,-32376(gp)
81110ff8:	e0bffe17 	ldw	r2,-8(fp)
81110ffc:	10800b17 	ldw	r2,44(r2)
81111000:	100d883a 	mov	r6,r2
81111004:	01604574 	movhi	r5,33045
81111008:	29752604 	addi	r5,r5,-11112
8111100c:	1809883a 	mov	r4,r3
81111010:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"        Right side \n");
81111014:	d0a06217 	ldw	r2,-32376(gp)
81111018:	100f883a 	mov	r7,r2
8111101c:	01800504 	movi	r6,20
81111020:	01400044 	movi	r5,1
81111024:	01204574 	movhi	r4,33045
81111028:	21353204 	addi	r4,r4,-11064
8111102c:	1121c7c0 	call	81121c7c <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulOffsetAddr);
81111030:	d0e06217 	ldw	r3,-32376(gp)
81111034:	e0bffe17 	ldw	r2,-8(fp)
81111038:	10800c17 	ldw	r2,48(r2)
8111103c:	100d883a 	mov	r6,r2
81111040:	01604574 	movhi	r5,33045
81111044:	29751204 	addi	r5,r5,-11192
81111048:	1809883a 	mov	r4,r3
8111104c:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulBlockI);
81111050:	d0e06217 	ldw	r3,-32376(gp)
81111054:	e0bffe17 	ldw	r2,-8(fp)
81111058:	10800d17 	ldw	r2,52(r2)
8111105c:	100d883a 	mov	r6,r2
81111060:	01604574 	movhi	r5,33045
81111064:	29751b04 	addi	r5,r5,-11156
81111068:	1809883a 	mov	r4,r3
8111106c:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulAddrI);
81111070:	d0e06217 	ldw	r3,-32376(gp)
81111074:	e0bffe17 	ldw	r2,-8(fp)
81111078:	10800e17 	ldw	r2,56(r2)
8111107c:	100d883a 	mov	r6,r2
81111080:	01604574 	movhi	r5,33045
81111084:	29752604 	addi	r5,r5,-11112
81111088:	1809883a 	mov	r4,r3
8111108c:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"\n");
81111090:	d0a06217 	ldw	r2,-32376(gp)
81111094:	100b883a 	mov	r5,r2
81111098:	01000284 	movi	r4,10
8111109c:	11216580 	call	81121658 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 1 , pxNFee->ucId);
811110a0:	d0e06217 	ldw	r3,-32376(gp)
811110a4:	e0bffe17 	ldw	r2,-8(fp)
811110a8:	10800003 	ldbu	r2,0(r2)
811110ac:	10803fcc 	andi	r2,r2,255
811110b0:	100f883a 	mov	r7,r2
811110b4:	01800044 	movi	r6,1
811110b8:	01604574 	movhi	r5,33045
811110bc:	29750304 	addi	r5,r5,-11252
811110c0:	1809883a 	mov	r4,r3
811110c4:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"        Left side \n");
811110c8:	d0a06217 	ldw	r2,-32376(gp)
811110cc:	100f883a 	mov	r7,r2
811110d0:	018004c4 	movi	r6,19
811110d4:	01400044 	movi	r5,1
811110d8:	01204574 	movhi	r4,33045
811110dc:	21350d04 	addi	r4,r4,-11212
811110e0:	1121c7c0 	call	81121c7c <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulOffsetAddr);
811110e4:	d0e06217 	ldw	r3,-32376(gp)
811110e8:	e0bffe17 	ldw	r2,-8(fp)
811110ec:	10800f17 	ldw	r2,60(r2)
811110f0:	100d883a 	mov	r6,r2
811110f4:	01604574 	movhi	r5,33045
811110f8:	29751204 	addi	r5,r5,-11192
811110fc:	1809883a 	mov	r4,r3
81111100:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulBlockI);
81111104:	d0e06217 	ldw	r3,-32376(gp)
81111108:	e0bffe17 	ldw	r2,-8(fp)
8111110c:	10801017 	ldw	r2,64(r2)
81111110:	100d883a 	mov	r6,r2
81111114:	01604574 	movhi	r5,33045
81111118:	29751b04 	addi	r5,r5,-11156
8111111c:	1809883a 	mov	r4,r3
81111120:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulAddrI);
81111124:	d0e06217 	ldw	r3,-32376(gp)
81111128:	e0bffe17 	ldw	r2,-8(fp)
8111112c:	10801117 	ldw	r2,68(r2)
81111130:	100d883a 	mov	r6,r2
81111134:	01604574 	movhi	r5,33045
81111138:	29752604 	addi	r5,r5,-11112
8111113c:	1809883a 	mov	r4,r3
81111140:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"        Right side \n");
81111144:	d0a06217 	ldw	r2,-32376(gp)
81111148:	100f883a 	mov	r7,r2
8111114c:	01800504 	movi	r6,20
81111150:	01400044 	movi	r5,1
81111154:	01204574 	movhi	r4,33045
81111158:	21353204 	addi	r4,r4,-11064
8111115c:	1121c7c0 	call	81121c7c <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulOffsetAddr);
81111160:	d0e06217 	ldw	r3,-32376(gp)
81111164:	e0bffe17 	ldw	r2,-8(fp)
81111168:	10801217 	ldw	r2,72(r2)
8111116c:	100d883a 	mov	r6,r2
81111170:	01604574 	movhi	r5,33045
81111174:	29751204 	addi	r5,r5,-11192
81111178:	1809883a 	mov	r4,r3
8111117c:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulBlockI);
81111180:	d0e06217 	ldw	r3,-32376(gp)
81111184:	e0bffe17 	ldw	r2,-8(fp)
81111188:	10801317 	ldw	r2,76(r2)
8111118c:	100d883a 	mov	r6,r2
81111190:	01604574 	movhi	r5,33045
81111194:	29751b04 	addi	r5,r5,-11156
81111198:	1809883a 	mov	r4,r3
8111119c:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulAddrI);
811111a0:	d0e06217 	ldw	r3,-32376(gp)
811111a4:	e0bffe17 	ldw	r2,-8(fp)
811111a8:	10801417 	ldw	r2,80(r2)
811111ac:	100d883a 	mov	r6,r2
811111b0:	01604574 	movhi	r5,33045
811111b4:	29752604 	addi	r5,r5,-11112
811111b8:	1809883a 	mov	r4,r3
811111bc:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"\n");
811111c0:	d0a06217 	ldw	r2,-32376(gp)
811111c4:	100b883a 	mov	r5,r2
811111c8:	01000284 	movi	r4,10
811111cc:	11216580 	call	81121658 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 2 , pxNFee->ucId);
811111d0:	d0e06217 	ldw	r3,-32376(gp)
811111d4:	e0bffe17 	ldw	r2,-8(fp)
811111d8:	10800003 	ldbu	r2,0(r2)
811111dc:	10803fcc 	andi	r2,r2,255
811111e0:	100f883a 	mov	r7,r2
811111e4:	01800084 	movi	r6,2
811111e8:	01604574 	movhi	r5,33045
811111ec:	29750304 	addi	r5,r5,-11252
811111f0:	1809883a 	mov	r4,r3
811111f4:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"        Left side \n");
811111f8:	d0a06217 	ldw	r2,-32376(gp)
811111fc:	100f883a 	mov	r7,r2
81111200:	018004c4 	movi	r6,19
81111204:	01400044 	movi	r5,1
81111208:	01204574 	movhi	r4,33045
8111120c:	21350d04 	addi	r4,r4,-11212
81111210:	1121c7c0 	call	81121c7c <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulOffsetAddr);
81111214:	d0e06217 	ldw	r3,-32376(gp)
81111218:	e0bffe17 	ldw	r2,-8(fp)
8111121c:	10801517 	ldw	r2,84(r2)
81111220:	100d883a 	mov	r6,r2
81111224:	01604574 	movhi	r5,33045
81111228:	29751204 	addi	r5,r5,-11192
8111122c:	1809883a 	mov	r4,r3
81111230:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulBlockI);
81111234:	d0e06217 	ldw	r3,-32376(gp)
81111238:	e0bffe17 	ldw	r2,-8(fp)
8111123c:	10801617 	ldw	r2,88(r2)
81111240:	100d883a 	mov	r6,r2
81111244:	01604574 	movhi	r5,33045
81111248:	29751b04 	addi	r5,r5,-11156
8111124c:	1809883a 	mov	r4,r3
81111250:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulAddrI);
81111254:	d0e06217 	ldw	r3,-32376(gp)
81111258:	e0bffe17 	ldw	r2,-8(fp)
8111125c:	10801717 	ldw	r2,92(r2)
81111260:	100d883a 	mov	r6,r2
81111264:	01604574 	movhi	r5,33045
81111268:	29752604 	addi	r5,r5,-11112
8111126c:	1809883a 	mov	r4,r3
81111270:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"        Right side \n");
81111274:	d0a06217 	ldw	r2,-32376(gp)
81111278:	100f883a 	mov	r7,r2
8111127c:	01800504 	movi	r6,20
81111280:	01400044 	movi	r5,1
81111284:	01204574 	movhi	r4,33045
81111288:	21353204 	addi	r4,r4,-11064
8111128c:	1121c7c0 	call	81121c7c <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulOffsetAddr);
81111290:	d0e06217 	ldw	r3,-32376(gp)
81111294:	e0bffe17 	ldw	r2,-8(fp)
81111298:	10801817 	ldw	r2,96(r2)
8111129c:	100d883a 	mov	r6,r2
811112a0:	01604574 	movhi	r5,33045
811112a4:	29751204 	addi	r5,r5,-11192
811112a8:	1809883a 	mov	r4,r3
811112ac:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulBlockI);
811112b0:	d0e06217 	ldw	r3,-32376(gp)
811112b4:	e0bffe17 	ldw	r2,-8(fp)
811112b8:	10801917 	ldw	r2,100(r2)
811112bc:	100d883a 	mov	r6,r2
811112c0:	01604574 	movhi	r5,33045
811112c4:	29751b04 	addi	r5,r5,-11156
811112c8:	1809883a 	mov	r4,r3
811112cc:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulAddrI);
811112d0:	d0e06217 	ldw	r3,-32376(gp)
811112d4:	e0bffe17 	ldw	r2,-8(fp)
811112d8:	10801a17 	ldw	r2,104(r2)
811112dc:	100d883a 	mov	r6,r2
811112e0:	01604574 	movhi	r5,33045
811112e4:	29752604 	addi	r5,r5,-11112
811112e8:	1809883a 	mov	r4,r3
811112ec:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"\n");
811112f0:	d0a06217 	ldw	r2,-32376(gp)
811112f4:	100b883a 	mov	r5,r2
811112f8:	01000284 	movi	r4,10
811112fc:	11216580 	call	81121658 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 3 , pxNFee->ucId);
81111300:	d0e06217 	ldw	r3,-32376(gp)
81111304:	e0bffe17 	ldw	r2,-8(fp)
81111308:	10800003 	ldbu	r2,0(r2)
8111130c:	10803fcc 	andi	r2,r2,255
81111310:	100f883a 	mov	r7,r2
81111314:	018000c4 	movi	r6,3
81111318:	01604574 	movhi	r5,33045
8111131c:	29750304 	addi	r5,r5,-11252
81111320:	1809883a 	mov	r4,r3
81111324:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"        Left side \n");
81111328:	d0a06217 	ldw	r2,-32376(gp)
8111132c:	100f883a 	mov	r7,r2
81111330:	018004c4 	movi	r6,19
81111334:	01400044 	movi	r5,1
81111338:	01204574 	movhi	r4,33045
8111133c:	21350d04 	addi	r4,r4,-11212
81111340:	1121c7c0 	call	81121c7c <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulOffsetAddr);
81111344:	d0e06217 	ldw	r3,-32376(gp)
81111348:	e0bffe17 	ldw	r2,-8(fp)
8111134c:	10801b17 	ldw	r2,108(r2)
81111350:	100d883a 	mov	r6,r2
81111354:	01604574 	movhi	r5,33045
81111358:	29751204 	addi	r5,r5,-11192
8111135c:	1809883a 	mov	r4,r3
81111360:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulBlockI);
81111364:	d0e06217 	ldw	r3,-32376(gp)
81111368:	e0bffe17 	ldw	r2,-8(fp)
8111136c:	10801c17 	ldw	r2,112(r2)
81111370:	100d883a 	mov	r6,r2
81111374:	01604574 	movhi	r5,33045
81111378:	29751b04 	addi	r5,r5,-11156
8111137c:	1809883a 	mov	r4,r3
81111380:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulAddrI);
81111384:	d0e06217 	ldw	r3,-32376(gp)
81111388:	e0bffe17 	ldw	r2,-8(fp)
8111138c:	10801d17 	ldw	r2,116(r2)
81111390:	100d883a 	mov	r6,r2
81111394:	01604574 	movhi	r5,33045
81111398:	29752604 	addi	r5,r5,-11112
8111139c:	1809883a 	mov	r4,r3
811113a0:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"        Right side \n");
811113a4:	d0a06217 	ldw	r2,-32376(gp)
811113a8:	100f883a 	mov	r7,r2
811113ac:	01800504 	movi	r6,20
811113b0:	01400044 	movi	r5,1
811113b4:	01204574 	movhi	r4,33045
811113b8:	21353204 	addi	r4,r4,-11064
811113bc:	1121c7c0 	call	81121c7c <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulOffsetAddr);
811113c0:	d0e06217 	ldw	r3,-32376(gp)
811113c4:	e0bffe17 	ldw	r2,-8(fp)
811113c8:	10801e17 	ldw	r2,120(r2)
811113cc:	100d883a 	mov	r6,r2
811113d0:	01604574 	movhi	r5,33045
811113d4:	29751204 	addi	r5,r5,-11192
811113d8:	1809883a 	mov	r4,r3
811113dc:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulBlockI);
811113e0:	d0e06217 	ldw	r3,-32376(gp)
811113e4:	e0bffe17 	ldw	r2,-8(fp)
811113e8:	10801f17 	ldw	r2,124(r2)
811113ec:	100d883a 	mov	r6,r2
811113f0:	01604574 	movhi	r5,33045
811113f4:	29751b04 	addi	r5,r5,-11156
811113f8:	1809883a 	mov	r4,r3
811113fc:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulAddrI);
81111400:	d0e06217 	ldw	r3,-32376(gp)
81111404:	e0bffe17 	ldw	r2,-8(fp)
81111408:	10802017 	ldw	r2,128(r2)
8111140c:	100d883a 	mov	r6,r2
81111410:	01604574 	movhi	r5,33045
81111414:	29752604 	addi	r5,r5,-11112
81111418:	1809883a 	mov	r4,r3
8111141c:	11215e00 	call	811215e0 <fprintf>
		fprintf(fp,"\n");
81111420:	d0a06217 	ldw	r2,-32376(gp)
81111424:	100b883a 	mov	r5,r2
81111428:	01000284 	movi	r4,10
8111142c:	11216580 	call	81121658 <fputc>
		fprintf(fp,"==============================================================================\n");
81111430:	d0a06217 	ldw	r2,-32376(gp)
81111434:	100f883a 	mov	r7,r2
81111438:	018013c4 	movi	r6,79
8111143c:	01400044 	movi	r5,1
81111440:	01204574 	movhi	r4,33045
81111444:	21353804 	addi	r4,r4,-11040
81111448:	1121c7c0 	call	81121c7c <fwrite>
		fprintf(fp,"==============================================================================\n");
8111144c:	d0a06217 	ldw	r2,-32376(gp)
81111450:	100f883a 	mov	r7,r2
81111454:	018013c4 	movi	r6,79
81111458:	01400044 	movi	r5,1
8111145c:	01204574 	movhi	r4,33045
81111460:	21353804 	addi	r4,r4,-11040
81111464:	1121c7c0 	call	81121c7c <fwrite>
		fprintf(fp,"\n");
81111468:	d0a06217 	ldw	r2,-32376(gp)
8111146c:	100b883a 	mov	r5,r2
81111470:	01000284 	movi	r4,10
81111474:	11216580 	call	81121658 <fputc>
		fprintf(fp,"\n");
81111478:	d0a06217 	ldw	r2,-32376(gp)
8111147c:	100b883a 	mov	r5,r2
81111480:	01000284 	movi	r4,10
81111484:	11216580 	call	81121658 <fputc>
		fprintf(fp,"\n");
81111488:	d0a06217 	ldw	r2,-32376(gp)
8111148c:	100b883a 	mov	r5,r2
81111490:	01000284 	movi	r4,10
81111494:	11216580 	call	81121658 <fputc>
		fprintf(fp,"\n");
81111498:	d0a06217 	ldw	r2,-32376(gp)
8111149c:	100b883a 	mov	r5,r2
811114a0:	01000284 	movi	r4,10
811114a4:	11216580 	call	81121658 <fputc>
		fprintf(fp,"\n");
811114a8:	d0a06217 	ldw	r2,-32376(gp)
811114ac:	100b883a 	mov	r5,r2
811114b0:	01000284 	movi	r4,10
811114b4:	11216580 	call	81121658 <fputc>
	}
811114b8:	0001883a 	nop
811114bc:	e037883a 	mov	sp,fp
811114c0:	dfc00117 	ldw	ra,4(sp)
811114c4:	df000017 	ldw	fp,0(sp)
811114c8:	dec00204 	addi	sp,sp,8
811114cc:	f800283a 	ret

811114d0 <bPrepareDoubleBuffer>:

*/



bool bPrepareDoubleBuffer( TCcdMemMap *xCcdMapLocal, unsigned char ucMem, unsigned char ucID, TNFee *pxNFee ) {
811114d0:	defff804 	addi	sp,sp,-32
811114d4:	de00012e 	bgeu	sp,et,811114dc <bPrepareDoubleBuffer+0xc>
811114d8:	003b68fa 	trap	3
811114dc:	dfc00715 	stw	ra,28(sp)
811114e0:	df000615 	stw	fp,24(sp)
811114e4:	df000604 	addi	fp,sp,24
811114e8:	e13ffc15 	stw	r4,-16(fp)
811114ec:	2807883a 	mov	r3,r5
811114f0:	3005883a 	mov	r2,r6
811114f4:	e1ffff15 	stw	r7,-4(fp)
811114f8:	e0fffd05 	stb	r3,-12(fp)
811114fc:	e0bffe05 	stb	r2,-8(fp)
	bool  bDmaReturn;
	unsigned long ulLengthBlocks;

	bDmaReturn = FALSE;
81111500:	e03ffa15 	stw	zero,-24(fp)
	xCcdMapLocal->ulBlockI = 0;
81111504:	e0bffc17 	ldw	r2,-16(fp)
81111508:	10000115 	stw	zero,4(r2)
	xCcdMapLocal->ulAddrI = xCcdMapLocal->ulOffsetAddr;
8111150c:	e0bffc17 	ldw	r2,-16(fp)
81111510:	10c00017 	ldw	r3,0(r2)
81111514:	e0bffc17 	ldw	r2,-16(fp)
81111518:	10c00215 	stw	r3,8(r2)


	if ( (xCcdMapLocal->ulBlockI + SDMA_MAX_BLOCKS) >= pxNFee->xMemMap.xCommon.usiNTotalBlocks ) {
8111151c:	e0bffc17 	ldw	r2,-16(fp)
81111520:	10800117 	ldw	r2,4(r2)
81111524:	10c00404 	addi	r3,r2,16
81111528:	e0bfff17 	ldw	r2,-4(fp)
8111152c:	10800417 	ldw	r2,16(r2)
81111530:	18800736 	bltu	r3,r2,81111550 <bPrepareDoubleBuffer+0x80>
		ulLengthBlocks = pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI;
81111534:	e0bfff17 	ldw	r2,-4(fp)
81111538:	10c00417 	ldw	r3,16(r2)
8111153c:	e0bffc17 	ldw	r2,-16(fp)
81111540:	10800117 	ldw	r2,4(r2)
81111544:	1885c83a 	sub	r2,r3,r2
81111548:	e0bffb15 	stw	r2,-20(fp)
8111154c:	00000206 	br	81111558 <bPrepareDoubleBuffer+0x88>

	} else {
		ulLengthBlocks = SDMA_MAX_BLOCKS;
81111550:	00800404 	movi	r2,16
81111554:	e0bffb15 	stw	r2,-20(fp)
	}

	if (xDefaults.usiLinkNFEE0 == 0) {
81111558:	00a045b4 	movhi	r2,33046
8111155c:	109c0004 	addi	r2,r2,28672
81111560:	1080100b 	ldhu	r2,64(r2)
81111564:	10bfffcc 	andi	r2,r2,65535
81111568:	10000b1e 	bne	r2,zero,81111598 <bPrepareDoubleBuffer+0xc8>
		bFeebCh1SetBufferSize((unsigned char)ulLengthBlocks,0);
8111156c:	e0bffb17 	ldw	r2,-20(fp)
81111570:	10803fcc 	andi	r2,r2,255
81111574:	000b883a 	mov	r5,zero
81111578:	1009883a 	mov	r4,r2
8111157c:	1105b280 	call	81105b28 <bFeebCh1SetBufferSize>
		bFeebCh1SetBufferSize((unsigned char)ulLengthBlocks,1);
81111580:	e0bffb17 	ldw	r2,-20(fp)
81111584:	10803fcc 	andi	r2,r2,255
81111588:	01400044 	movi	r5,1
8111158c:	1009883a 	mov	r4,r2
81111590:	1105b280 	call	81105b28 <bFeebCh1SetBufferSize>
81111594:	00000a06 	br	811115c0 <bPrepareDoubleBuffer+0xf0>
	} else {
		bFeebCh2SetBufferSize((unsigned char)ulLengthBlocks,0);
81111598:	e0bffb17 	ldw	r2,-20(fp)
8111159c:	10803fcc 	andi	r2,r2,255
811115a0:	000b883a 	mov	r5,zero
811115a4:	1009883a 	mov	r4,r2
811115a8:	1105bfc0 	call	81105bfc <bFeebCh2SetBufferSize>
		bFeebCh2SetBufferSize((unsigned char)ulLengthBlocks,1);
811115ac:	e0bffb17 	ldw	r2,-20(fp)
811115b0:	10803fcc 	andi	r2,r2,255
811115b4:	01400044 	movi	r5,1
811115b8:	1009883a 	mov	r4,r2
811115bc:	1105bfc0 	call	81105bfc <bFeebCh2SetBufferSize>


	//bFeebSetBufferSize(&pxNFee->xChannel.xFeeBuffer,ulLengthBlocks,0);
	//bFeebSetBufferSize(&pxNFee->xChannel.xFeeBuffer,ulLengthBlocks,1);

	if (  ucMem == 0  ) {
811115c0:	e0bffd03 	ldbu	r2,-12(fp)
811115c4:	1000231e 	bne	r2,zero,81111654 <bPrepareDoubleBuffer+0x184>
		bDmaReturn = bSdmaDmaM1Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)ulLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
811115c8:	e0bffc17 	ldw	r2,-16(fp)
811115cc:	10800217 	ldw	r2,8(r2)
811115d0:	1011883a 	mov	r8,r2
811115d4:	e0bffb17 	ldw	r2,-20(fp)
811115d8:	10ffffcc 	andi	r3,r2,65535
811115dc:	d0a05603 	ldbu	r2,-32424(gp)
811115e0:	11003fcc 	andi	r4,r2,255
811115e4:	e0bfff17 	ldw	r2,-4(fp)
811115e8:	10800043 	ldbu	r2,1(r2)
811115ec:	10803fcc 	andi	r2,r2,255
811115f0:	100f883a 	mov	r7,r2
811115f4:	200d883a 	mov	r6,r4
811115f8:	180b883a 	mov	r5,r3
811115fc:	4009883a 	mov	r4,r8
81111600:	1103c900 	call	81103c90 <bSdmaDmaM1Transfer>
81111604:	e0bffa15 	stw	r2,-24(fp)
		if ( bDmaReturn == TRUE ) {
81111608:	e0bffa17 	ldw	r2,-24(fp)
8111160c:	10800058 	cmpnei	r2,r2,1
81111610:	10000e1e 	bne	r2,zero,8111164c <bPrepareDoubleBuffer+0x17c>
			xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*ulLengthBlocks;
81111614:	e0bffc17 	ldw	r2,-16(fp)
81111618:	10c00217 	ldw	r3,8(r2)
8111161c:	e0bffb17 	ldw	r2,-20(fp)
81111620:	10802224 	muli	r2,r2,136
81111624:	1887883a 	add	r3,r3,r2
81111628:	e0bffc17 	ldw	r2,-16(fp)
8111162c:	10c00215 	stw	r3,8(r2)
			xCcdMapLocal->ulBlockI += ulLengthBlocks;
81111630:	e0bffc17 	ldw	r2,-16(fp)
81111634:	10c00117 	ldw	r3,4(r2)
81111638:	e0bffb17 	ldw	r2,-20(fp)
8111163c:	1887883a 	add	r3,r3,r2
81111640:	e0bffc17 	ldw	r2,-16(fp)
81111644:	10c00115 	stw	r3,4(r2)
81111648:	00002506 	br	811116e0 <bPrepareDoubleBuffer+0x210>
		} else
			return bDmaReturn;
8111164c:	e0bffa17 	ldw	r2,-24(fp)
81111650:	00009506 	br	811118a8 <bPrepareDoubleBuffer+0x3d8>
	} else {
		bDmaReturn = bSdmaDmaM2Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)ulLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
81111654:	e0bffc17 	ldw	r2,-16(fp)
81111658:	10800217 	ldw	r2,8(r2)
8111165c:	1011883a 	mov	r8,r2
81111660:	e0bffb17 	ldw	r2,-20(fp)
81111664:	10ffffcc 	andi	r3,r2,65535
81111668:	d0a05603 	ldbu	r2,-32424(gp)
8111166c:	11003fcc 	andi	r4,r2,255
81111670:	e0bfff17 	ldw	r2,-4(fp)
81111674:	10800043 	ldbu	r2,1(r2)
81111678:	10803fcc 	andi	r2,r2,255
8111167c:	100f883a 	mov	r7,r2
81111680:	200d883a 	mov	r6,r4
81111684:	180b883a 	mov	r5,r3
81111688:	4009883a 	mov	r4,r8
8111168c:	11041c40 	call	811041c4 <bSdmaDmaM2Transfer>
81111690:	e0bffa15 	stw	r2,-24(fp)
		if ( bDmaReturn == TRUE ) {
81111694:	e0bffa17 	ldw	r2,-24(fp)
81111698:	10800058 	cmpnei	r2,r2,1
8111169c:	10000e1e 	bne	r2,zero,811116d8 <bPrepareDoubleBuffer+0x208>
			xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*ulLengthBlocks;
811116a0:	e0bffc17 	ldw	r2,-16(fp)
811116a4:	10c00217 	ldw	r3,8(r2)
811116a8:	e0bffb17 	ldw	r2,-20(fp)
811116ac:	10802224 	muli	r2,r2,136
811116b0:	1887883a 	add	r3,r3,r2
811116b4:	e0bffc17 	ldw	r2,-16(fp)
811116b8:	10c00215 	stw	r3,8(r2)
			xCcdMapLocal->ulBlockI += ulLengthBlocks;
811116bc:	e0bffc17 	ldw	r2,-16(fp)
811116c0:	10c00117 	ldw	r3,4(r2)
811116c4:	e0bffb17 	ldw	r2,-20(fp)
811116c8:	1887883a 	add	r3,r3,r2
811116cc:	e0bffc17 	ldw	r2,-16(fp)
811116d0:	10c00115 	stw	r3,4(r2)
811116d4:	00000206 	br	811116e0 <bPrepareDoubleBuffer+0x210>
		} else
			return bDmaReturn;
811116d8:	e0bffa17 	ldw	r2,-24(fp)
811116dc:	00007206 	br	811118a8 <bPrepareDoubleBuffer+0x3d8>
	}


	if ( (xCcdMapLocal->ulBlockI + SDMA_MAX_BLOCKS) >= pxNFee->xMemMap.xCommon.usiNTotalBlocks ) {
811116e0:	e0bffc17 	ldw	r2,-16(fp)
811116e4:	10800117 	ldw	r2,4(r2)
811116e8:	10c00404 	addi	r3,r2,16
811116ec:	e0bfff17 	ldw	r2,-4(fp)
811116f0:	10800417 	ldw	r2,16(r2)
811116f4:	18800736 	bltu	r3,r2,81111714 <bPrepareDoubleBuffer+0x244>
		ulLengthBlocks = pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI;
811116f8:	e0bfff17 	ldw	r2,-4(fp)
811116fc:	10c00417 	ldw	r3,16(r2)
81111700:	e0bffc17 	ldw	r2,-16(fp)
81111704:	10800117 	ldw	r2,4(r2)
81111708:	1885c83a 	sub	r2,r3,r2
8111170c:	e0bffb15 	stw	r2,-20(fp)
81111710:	00000206 	br	8111171c <bPrepareDoubleBuffer+0x24c>
	} else {
		ulLengthBlocks = SDMA_MAX_BLOCKS;
81111714:	00800404 	movi	r2,16
81111718:	e0bffb15 	stw	r2,-20(fp)
	}

	if (xDefaults.usiLinkNFEE0 == 0) {
8111171c:	00a045b4 	movhi	r2,33046
81111720:	109c0004 	addi	r2,r2,28672
81111724:	1080100b 	ldhu	r2,64(r2)
81111728:	10bfffcc 	andi	r2,r2,65535
8111172c:	10000b1e 	bne	r2,zero,8111175c <bPrepareDoubleBuffer+0x28c>
		bFeebCh1SetBufferSize((unsigned char)ulLengthBlocks,0);
81111730:	e0bffb17 	ldw	r2,-20(fp)
81111734:	10803fcc 	andi	r2,r2,255
81111738:	000b883a 	mov	r5,zero
8111173c:	1009883a 	mov	r4,r2
81111740:	1105b280 	call	81105b28 <bFeebCh1SetBufferSize>
		bFeebCh1SetBufferSize((unsigned char)ulLengthBlocks,1);
81111744:	e0bffb17 	ldw	r2,-20(fp)
81111748:	10803fcc 	andi	r2,r2,255
8111174c:	01400044 	movi	r5,1
81111750:	1009883a 	mov	r4,r2
81111754:	1105b280 	call	81105b28 <bFeebCh1SetBufferSize>
81111758:	00000a06 	br	81111784 <bPrepareDoubleBuffer+0x2b4>
	} else {
		bFeebCh2SetBufferSize((unsigned char)ulLengthBlocks,0);
8111175c:	e0bffb17 	ldw	r2,-20(fp)
81111760:	10803fcc 	andi	r2,r2,255
81111764:	000b883a 	mov	r5,zero
81111768:	1009883a 	mov	r4,r2
8111176c:	1105bfc0 	call	81105bfc <bFeebCh2SetBufferSize>
		bFeebCh2SetBufferSize((unsigned char)ulLengthBlocks,1);
81111770:	e0bffb17 	ldw	r2,-20(fp)
81111774:	10803fcc 	andi	r2,r2,255
81111778:	01400044 	movi	r5,1
8111177c:	1009883a 	mov	r4,r2
81111780:	1105bfc0 	call	81105bfc <bFeebCh2SetBufferSize>

	//bFeebSetBufferSize(&pxNFee->xChannel.xFeeBuffer,ulLengthBlocks,0);
	//bFeebSetBufferSize(&pxNFee->xChannel.xFeeBuffer,ulLengthBlocks,1);


	if (  ucMem == 0  ) {
81111784:	e0bffd03 	ldbu	r2,-12(fp)
81111788:	1000231e 	bne	r2,zero,81111818 <bPrepareDoubleBuffer+0x348>
		bDmaReturn = bSdmaDmaM1Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)ulLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
8111178c:	e0bffc17 	ldw	r2,-16(fp)
81111790:	10800217 	ldw	r2,8(r2)
81111794:	1011883a 	mov	r8,r2
81111798:	e0bffb17 	ldw	r2,-20(fp)
8111179c:	10ffffcc 	andi	r3,r2,65535
811117a0:	d0a05603 	ldbu	r2,-32424(gp)
811117a4:	11003fcc 	andi	r4,r2,255
811117a8:	e0bfff17 	ldw	r2,-4(fp)
811117ac:	10800043 	ldbu	r2,1(r2)
811117b0:	10803fcc 	andi	r2,r2,255
811117b4:	100f883a 	mov	r7,r2
811117b8:	200d883a 	mov	r6,r4
811117bc:	180b883a 	mov	r5,r3
811117c0:	4009883a 	mov	r4,r8
811117c4:	1103c900 	call	81103c90 <bSdmaDmaM1Transfer>
811117c8:	e0bffa15 	stw	r2,-24(fp)
		if ( bDmaReturn == TRUE ) {
811117cc:	e0bffa17 	ldw	r2,-24(fp)
811117d0:	10800058 	cmpnei	r2,r2,1
811117d4:	10000e1e 	bne	r2,zero,81111810 <bPrepareDoubleBuffer+0x340>
			xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*ulLengthBlocks;
811117d8:	e0bffc17 	ldw	r2,-16(fp)
811117dc:	10c00217 	ldw	r3,8(r2)
811117e0:	e0bffb17 	ldw	r2,-20(fp)
811117e4:	10802224 	muli	r2,r2,136
811117e8:	1887883a 	add	r3,r3,r2
811117ec:	e0bffc17 	ldw	r2,-16(fp)
811117f0:	10c00215 	stw	r3,8(r2)
			xCcdMapLocal->ulBlockI += ulLengthBlocks;
811117f4:	e0bffc17 	ldw	r2,-16(fp)
811117f8:	10c00117 	ldw	r3,4(r2)
811117fc:	e0bffb17 	ldw	r2,-20(fp)
81111800:	1887883a 	add	r3,r3,r2
81111804:	e0bffc17 	ldw	r2,-16(fp)
81111808:	10c00115 	stw	r3,4(r2)
8111180c:	00002506 	br	811118a4 <bPrepareDoubleBuffer+0x3d4>
		} else
			return bDmaReturn;
81111810:	e0bffa17 	ldw	r2,-24(fp)
81111814:	00002406 	br	811118a8 <bPrepareDoubleBuffer+0x3d8>
	} else {
		bDmaReturn = bSdmaDmaM2Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)ulLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
81111818:	e0bffc17 	ldw	r2,-16(fp)
8111181c:	10800217 	ldw	r2,8(r2)
81111820:	1011883a 	mov	r8,r2
81111824:	e0bffb17 	ldw	r2,-20(fp)
81111828:	10ffffcc 	andi	r3,r2,65535
8111182c:	d0a05603 	ldbu	r2,-32424(gp)
81111830:	11003fcc 	andi	r4,r2,255
81111834:	e0bfff17 	ldw	r2,-4(fp)
81111838:	10800043 	ldbu	r2,1(r2)
8111183c:	10803fcc 	andi	r2,r2,255
81111840:	100f883a 	mov	r7,r2
81111844:	200d883a 	mov	r6,r4
81111848:	180b883a 	mov	r5,r3
8111184c:	4009883a 	mov	r4,r8
81111850:	11041c40 	call	811041c4 <bSdmaDmaM2Transfer>
81111854:	e0bffa15 	stw	r2,-24(fp)
		if ( bDmaReturn == TRUE ) {
81111858:	e0bffa17 	ldw	r2,-24(fp)
8111185c:	10800058 	cmpnei	r2,r2,1
81111860:	10000e1e 	bne	r2,zero,8111189c <bPrepareDoubleBuffer+0x3cc>
			xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*ulLengthBlocks;
81111864:	e0bffc17 	ldw	r2,-16(fp)
81111868:	10c00217 	ldw	r3,8(r2)
8111186c:	e0bffb17 	ldw	r2,-20(fp)
81111870:	10802224 	muli	r2,r2,136
81111874:	1887883a 	add	r3,r3,r2
81111878:	e0bffc17 	ldw	r2,-16(fp)
8111187c:	10c00215 	stw	r3,8(r2)
			xCcdMapLocal->ulBlockI += ulLengthBlocks;
81111880:	e0bffc17 	ldw	r2,-16(fp)
81111884:	10c00117 	ldw	r3,4(r2)
81111888:	e0bffb17 	ldw	r2,-20(fp)
8111188c:	1887883a 	add	r3,r3,r2
81111890:	e0bffc17 	ldw	r2,-16(fp)
81111894:	10c00115 	stw	r3,4(r2)
81111898:	00000206 	br	811118a4 <bPrepareDoubleBuffer+0x3d4>
		} else
			return bDmaReturn;
8111189c:	e0bffa17 	ldw	r2,-24(fp)
811118a0:	00000106 	br	811118a8 <bPrepareDoubleBuffer+0x3d8>
	}

	return bDmaReturn;
811118a4:	e0bffa17 	ldw	r2,-24(fp)

}
811118a8:	e037883a 	mov	sp,fp
811118ac:	dfc00117 	ldw	ra,4(sp)
811118b0:	df000017 	ldw	fp,0(sp)
811118b4:	dec00204 	addi	sp,sp,8
811118b8:	f800283a 	ret

811118bc <vLoadCtemp>:


void vLoadCtemp(void) {
811118bc:	deffff04 	addi	sp,sp,-4
811118c0:	de00012e 	bgeu	sp,et,811118c8 <vLoadCtemp+0xc>
811118c4:	003b68fa 	trap	3
811118c8:	df000015 	stw	fp,0(sp)
811118cc:	d839883a 	mov	fp,sp
	cTemp[0]="usiHkCcd1VodE";
811118d0:	00a04574 	movhi	r2,33045
811118d4:	108fa204 	addi	r2,r2,16008
811118d8:	00e04574 	movhi	r3,33045
811118dc:	18f54c04 	addi	r3,r3,-10960
811118e0:	10c00015 	stw	r3,0(r2)
	cTemp[1]="usiHkCcd1VodF";
811118e4:	00a04574 	movhi	r2,33045
811118e8:	108fa204 	addi	r2,r2,16008
811118ec:	00e04574 	movhi	r3,33045
811118f0:	18f55004 	addi	r3,r3,-10944
811118f4:	10c00115 	stw	r3,4(r2)
	cTemp[2]="usiHkCcd1VrdMon";
811118f8:	00a04574 	movhi	r2,33045
811118fc:	108fa204 	addi	r2,r2,16008
81111900:	00e04574 	movhi	r3,33045
81111904:	18f55404 	addi	r3,r3,-10928
81111908:	10c00215 	stw	r3,8(r2)
	cTemp[3]="usiHkCcd2VodE";
8111190c:	00a04574 	movhi	r2,33045
81111910:	108fa204 	addi	r2,r2,16008
81111914:	00e04574 	movhi	r3,33045
81111918:	18f55804 	addi	r3,r3,-10912
8111191c:	10c00315 	stw	r3,12(r2)
	cTemp[4]="usiHkCcd2VodF";
81111920:	00a04574 	movhi	r2,33045
81111924:	108fa204 	addi	r2,r2,16008
81111928:	00e04574 	movhi	r3,33045
8111192c:	18f55c04 	addi	r3,r3,-10896
81111930:	10c00415 	stw	r3,16(r2)
	cTemp[5]="usiHkCcd2VrdMon";
81111934:	00a04574 	movhi	r2,33045
81111938:	108fa204 	addi	r2,r2,16008
8111193c:	00e04574 	movhi	r3,33045
81111940:	18f56004 	addi	r3,r3,-10880
81111944:	10c00515 	stw	r3,20(r2)
	cTemp[6]="usiHkCcd3VodE";
81111948:	00a04574 	movhi	r2,33045
8111194c:	108fa204 	addi	r2,r2,16008
81111950:	00e04574 	movhi	r3,33045
81111954:	18f56404 	addi	r3,r3,-10864
81111958:	10c00615 	stw	r3,24(r2)
	cTemp[7]="usiHkCcd3VodF";
8111195c:	00a04574 	movhi	r2,33045
81111960:	108fa204 	addi	r2,r2,16008
81111964:	00e04574 	movhi	r3,33045
81111968:	18f56804 	addi	r3,r3,-10848
8111196c:	10c00715 	stw	r3,28(r2)
	cTemp[8]="usiHkCcd3VrdMon";
81111970:	00a04574 	movhi	r2,33045
81111974:	108fa204 	addi	r2,r2,16008
81111978:	00e04574 	movhi	r3,33045
8111197c:	18f56c04 	addi	r3,r3,-10832
81111980:	10c00815 	stw	r3,32(r2)
	cTemp[9]="usiHkCcd4VodE";
81111984:	00a04574 	movhi	r2,33045
81111988:	108fa204 	addi	r2,r2,16008
8111198c:	00e04574 	movhi	r3,33045
81111990:	18f57004 	addi	r3,r3,-10816
81111994:	10c00915 	stw	r3,36(r2)
	cTemp[10]="usiHkCcd4VodF";
81111998:	00a04574 	movhi	r2,33045
8111199c:	108fa204 	addi	r2,r2,16008
811119a0:	00e04574 	movhi	r3,33045
811119a4:	18f57404 	addi	r3,r3,-10800
811119a8:	10c00a15 	stw	r3,40(r2)
	cTemp[11]="usiHkCcd4VrdMon";
811119ac:	00a04574 	movhi	r2,33045
811119b0:	108fa204 	addi	r2,r2,16008
811119b4:	00e04574 	movhi	r3,33045
811119b8:	18f57804 	addi	r3,r3,-10784
811119bc:	10c00b15 	stw	r3,44(r2)
	cTemp[12]="usiHkVccd";
811119c0:	00a04574 	movhi	r2,33045
811119c4:	108fa204 	addi	r2,r2,16008
811119c8:	00e04574 	movhi	r3,33045
811119cc:	18f57c04 	addi	r3,r3,-10768
811119d0:	10c00c15 	stw	r3,48(r2)
	cTemp[13]="usiHkVrclk";
811119d4:	00a04574 	movhi	r2,33045
811119d8:	108fa204 	addi	r2,r2,16008
811119dc:	00e04574 	movhi	r3,33045
811119e0:	18f57f04 	addi	r3,r3,-10756
811119e4:	10c00d15 	stw	r3,52(r2)
	cTemp[14]="usiHkViclk";
811119e8:	00a04574 	movhi	r2,33045
811119ec:	108fa204 	addi	r2,r2,16008
811119f0:	00e04574 	movhi	r3,33045
811119f4:	18f58204 	addi	r3,r3,-10744
811119f8:	10c00e15 	stw	r3,56(r2)
	cTemp[15]="usiHkVrclkLow";
811119fc:	00a04574 	movhi	r2,33045
81111a00:	108fa204 	addi	r2,r2,16008
81111a04:	00e04574 	movhi	r3,33045
81111a08:	18f58504 	addi	r3,r3,-10732
81111a0c:	10c00f15 	stw	r3,60(r2)
	cTemp[16]="usiHk5vbPos";
81111a10:	00a04574 	movhi	r2,33045
81111a14:	108fa204 	addi	r2,r2,16008
81111a18:	00e04574 	movhi	r3,33045
81111a1c:	18f58904 	addi	r3,r3,-10716
81111a20:	10c01015 	stw	r3,64(r2)
	cTemp[17]="usiHk5vbNeg";
81111a24:	00a04574 	movhi	r2,33045
81111a28:	108fa204 	addi	r2,r2,16008
81111a2c:	00e04574 	movhi	r3,33045
81111a30:	18f58c04 	addi	r3,r3,-10704
81111a34:	10c01115 	stw	r3,68(r2)
	cTemp[18]="usiHk33vbPos";
81111a38:	00a04574 	movhi	r2,33045
81111a3c:	108fa204 	addi	r2,r2,16008
81111a40:	00e04574 	movhi	r3,33045
81111a44:	18f58f04 	addi	r3,r3,-10692
81111a48:	10c01215 	stw	r3,72(r2)
	cTemp[19]="usiHk25vaPos";
81111a4c:	00a04574 	movhi	r2,33045
81111a50:	108fa204 	addi	r2,r2,16008
81111a54:	00e04574 	movhi	r3,33045
81111a58:	18f59304 	addi	r3,r3,-10676
81111a5c:	10c01315 	stw	r3,76(r2)
	cTemp[20]="usiHk33vdPos";
81111a60:	00a04574 	movhi	r2,33045
81111a64:	108fa204 	addi	r2,r2,16008
81111a68:	00e04574 	movhi	r3,33045
81111a6c:	18f59704 	addi	r3,r3,-10660
81111a70:	10c01415 	stw	r3,80(r2)
	cTemp[21]="usiHk25vdPos";
81111a74:	00a04574 	movhi	r2,33045
81111a78:	108fa204 	addi	r2,r2,16008
81111a7c:	00e04574 	movhi	r3,33045
81111a80:	18f59b04 	addi	r3,r3,-10644
81111a84:	10c01515 	stw	r3,84(r2)
	cTemp[22]="usiHk15vdPos";
81111a88:	00a04574 	movhi	r2,33045
81111a8c:	108fa204 	addi	r2,r2,16008
81111a90:	00e04574 	movhi	r3,33045
81111a94:	18f59f04 	addi	r3,r3,-10628
81111a98:	10c01615 	stw	r3,88(r2)
	cTemp[23]="usiHk5vref";
81111a9c:	00a04574 	movhi	r2,33045
81111aa0:	108fa204 	addi	r2,r2,16008
81111aa4:	00e04574 	movhi	r3,33045
81111aa8:	18f5a304 	addi	r3,r3,-10612
81111aac:	10c01715 	stw	r3,92(r2)
	cTemp[24]="usiHkVccdPosRaw";
81111ab0:	00a04574 	movhi	r2,33045
81111ab4:	108fa204 	addi	r2,r2,16008
81111ab8:	00e04574 	movhi	r3,33045
81111abc:	18f5a604 	addi	r3,r3,-10600
81111ac0:	10c01815 	stw	r3,96(r2)
	cTemp[25]="usiHkVclkPosRaw";
81111ac4:	00a04574 	movhi	r2,33045
81111ac8:	108fa204 	addi	r2,r2,16008
81111acc:	00e04574 	movhi	r3,33045
81111ad0:	18f5aa04 	addi	r3,r3,-10584
81111ad4:	10c01915 	stw	r3,100(r2)
	cTemp[26]="usiHkVan1PosRaw";
81111ad8:	00a04574 	movhi	r2,33045
81111adc:	108fa204 	addi	r2,r2,16008
81111ae0:	00e04574 	movhi	r3,33045
81111ae4:	18f5ae04 	addi	r3,r3,-10568
81111ae8:	10c01a15 	stw	r3,104(r2)
	cTemp[27]="usiHkVan3NegRaw";
81111aec:	00a04574 	movhi	r2,33045
81111af0:	108fa204 	addi	r2,r2,16008
81111af4:	00e04574 	movhi	r3,33045
81111af8:	18f5b204 	addi	r3,r3,-10552
81111afc:	10c01b15 	stw	r3,108(r2)
	cTemp[28]="usiHkVan2PosRaw";
81111b00:	00a04574 	movhi	r2,33045
81111b04:	108fa204 	addi	r2,r2,16008
81111b08:	00e04574 	movhi	r3,33045
81111b0c:	18f5b604 	addi	r3,r3,-10536
81111b10:	10c01c15 	stw	r3,112(r2)
	cTemp[29]="usiHkVdigFpgaRaw";
81111b14:	00a04574 	movhi	r2,33045
81111b18:	108fa204 	addi	r2,r2,16008
81111b1c:	00e04574 	movhi	r3,33045
81111b20:	18f5ba04 	addi	r3,r3,-10520
81111b24:	10c01d15 	stw	r3,116(r2)
	cTemp[30]="usiHkVdigSpwRaw";
81111b28:	00a04574 	movhi	r2,33045
81111b2c:	108fa204 	addi	r2,r2,16008
81111b30:	00e04574 	movhi	r3,33045
81111b34:	18f5bf04 	addi	r3,r3,-10500
81111b38:	10c01e15 	stw	r3,120(r2)
	cTemp[31]="usiHkViclkLow";
81111b3c:	00a04574 	movhi	r2,33045
81111b40:	108fa204 	addi	r2,r2,16008
81111b44:	00e04574 	movhi	r3,33045
81111b48:	18f5c304 	addi	r3,r3,-10484
81111b4c:	10c01f15 	stw	r3,124(r2)
	cTemp[32]="usiHkAdcTempAE";
81111b50:	00a04574 	movhi	r2,33045
81111b54:	108fa204 	addi	r2,r2,16008
81111b58:	00e04574 	movhi	r3,33045
81111b5c:	18f5c704 	addi	r3,r3,-10468
81111b60:	10c02015 	stw	r3,128(r2)
	cTemp[33]="usiHkAdcTempAF";
81111b64:	00a04574 	movhi	r2,33045
81111b68:	108fa204 	addi	r2,r2,16008
81111b6c:	00e04574 	movhi	r3,33045
81111b70:	18f5cb04 	addi	r3,r3,-10452
81111b74:	10c02115 	stw	r3,132(r2)
	cTemp[34]="usiHkCcd1Temp";
81111b78:	00a04574 	movhi	r2,33045
81111b7c:	108fa204 	addi	r2,r2,16008
81111b80:	00e04574 	movhi	r3,33045
81111b84:	18f5cf04 	addi	r3,r3,-10436
81111b88:	10c02215 	stw	r3,136(r2)
	cTemp[35]="usiHkCcd2Temp";
81111b8c:	00a04574 	movhi	r2,33045
81111b90:	108fa204 	addi	r2,r2,16008
81111b94:	00e04574 	movhi	r3,33045
81111b98:	18f5d304 	addi	r3,r3,-10420
81111b9c:	10c02315 	stw	r3,140(r2)
	cTemp[36]="usiHkCcd3Temp";
81111ba0:	00a04574 	movhi	r2,33045
81111ba4:	108fa204 	addi	r2,r2,16008
81111ba8:	00e04574 	movhi	r3,33045
81111bac:	18f5d704 	addi	r3,r3,-10404
81111bb0:	10c02415 	stw	r3,144(r2)
	cTemp[37]="usiHkCcd4Temp";
81111bb4:	00a04574 	movhi	r2,33045
81111bb8:	108fa204 	addi	r2,r2,16008
81111bbc:	00e04574 	movhi	r3,33045
81111bc0:	18f5db04 	addi	r3,r3,-10388
81111bc4:	10c02515 	stw	r3,148(r2)
	cTemp[38]="usiHkWp605Spare";
81111bc8:	00a04574 	movhi	r2,33045
81111bcc:	108fa204 	addi	r2,r2,16008
81111bd0:	00e04574 	movhi	r3,33045
81111bd4:	18f5df04 	addi	r3,r3,-10372
81111bd8:	10c02615 	stw	r3,152(r2)
	cTemp[39]="usiLowresPrtA0";
81111bdc:	00a04574 	movhi	r2,33045
81111be0:	108fa204 	addi	r2,r2,16008
81111be4:	00e04574 	movhi	r3,33045
81111be8:	18f5e304 	addi	r3,r3,-10356
81111bec:	10c02715 	stw	r3,156(r2)
	cTemp[40]="usiLowresPrtA1";
81111bf0:	00a04574 	movhi	r2,33045
81111bf4:	108fa204 	addi	r2,r2,16008
81111bf8:	00e04574 	movhi	r3,33045
81111bfc:	18f5e704 	addi	r3,r3,-10340
81111c00:	10c02815 	stw	r3,160(r2)
	cTemp[41]="usiLowresPrtA2";
81111c04:	00a04574 	movhi	r2,33045
81111c08:	108fa204 	addi	r2,r2,16008
81111c0c:	00e04574 	movhi	r3,33045
81111c10:	18f5eb04 	addi	r3,r3,-10324
81111c14:	10c02915 	stw	r3,164(r2)
	cTemp[42]="usiLowresPrtA3";
81111c18:	00a04574 	movhi	r2,33045
81111c1c:	108fa204 	addi	r2,r2,16008
81111c20:	00e04574 	movhi	r3,33045
81111c24:	18f5ef04 	addi	r3,r3,-10308
81111c28:	10c02a15 	stw	r3,168(r2)
	cTemp[43]="usiLowresPrtA4";
81111c2c:	00a04574 	movhi	r2,33045
81111c30:	108fa204 	addi	r2,r2,16008
81111c34:	00e04574 	movhi	r3,33045
81111c38:	18f5f304 	addi	r3,r3,-10292
81111c3c:	10c02b15 	stw	r3,172(r2)
	cTemp[44]="usiLowresPrtA5";
81111c40:	00a04574 	movhi	r2,33045
81111c44:	108fa204 	addi	r2,r2,16008
81111c48:	00e04574 	movhi	r3,33045
81111c4c:	18f5f704 	addi	r3,r3,-10276
81111c50:	10c02c15 	stw	r3,176(r2)
	cTemp[45]="usiLowresPrtA6";
81111c54:	00a04574 	movhi	r2,33045
81111c58:	108fa204 	addi	r2,r2,16008
81111c5c:	00e04574 	movhi	r3,33045
81111c60:	18f5fb04 	addi	r3,r3,-10260
81111c64:	10c02d15 	stw	r3,180(r2)
	cTemp[46]="usiLowresPrtA7";
81111c68:	00a04574 	movhi	r2,33045
81111c6c:	108fa204 	addi	r2,r2,16008
81111c70:	00e04574 	movhi	r3,33045
81111c74:	18f5ff04 	addi	r3,r3,-10244
81111c78:	10c02e15 	stw	r3,184(r2)
	cTemp[47]="usiLowresPrtA8";
81111c7c:	00a04574 	movhi	r2,33045
81111c80:	108fa204 	addi	r2,r2,16008
81111c84:	00e04574 	movhi	r3,33045
81111c88:	18f60304 	addi	r3,r3,-10228
81111c8c:	10c02f15 	stw	r3,188(r2)
	cTemp[48]="usiLowresPrtA9";
81111c90:	00a04574 	movhi	r2,33045
81111c94:	108fa204 	addi	r2,r2,16008
81111c98:	00e04574 	movhi	r3,33045
81111c9c:	18f60704 	addi	r3,r3,-10212
81111ca0:	10c03015 	stw	r3,192(r2)
	cTemp[49]="usiLowresPrtA10";
81111ca4:	00a04574 	movhi	r2,33045
81111ca8:	108fa204 	addi	r2,r2,16008
81111cac:	00e04574 	movhi	r3,33045
81111cb0:	18f60b04 	addi	r3,r3,-10196
81111cb4:	10c03115 	stw	r3,196(r2)
	cTemp[50]="usiLowresPrtA11";
81111cb8:	00a04574 	movhi	r2,33045
81111cbc:	108fa204 	addi	r2,r2,16008
81111cc0:	00e04574 	movhi	r3,33045
81111cc4:	18f60f04 	addi	r3,r3,-10180
81111cc8:	10c03215 	stw	r3,200(r2)
	cTemp[51]="usiLowresPrtA12";
81111ccc:	00a04574 	movhi	r2,33045
81111cd0:	108fa204 	addi	r2,r2,16008
81111cd4:	00e04574 	movhi	r3,33045
81111cd8:	18f61304 	addi	r3,r3,-10164
81111cdc:	10c03315 	stw	r3,204(r2)
	cTemp[52]="usiLowresPrtA13";
81111ce0:	00a04574 	movhi	r2,33045
81111ce4:	108fa204 	addi	r2,r2,16008
81111ce8:	00e04574 	movhi	r3,33045
81111cec:	18f61704 	addi	r3,r3,-10148
81111cf0:	10c03415 	stw	r3,208(r2)
	cTemp[53]="usiLowresPrtA14";
81111cf4:	00a04574 	movhi	r2,33045
81111cf8:	108fa204 	addi	r2,r2,16008
81111cfc:	00e04574 	movhi	r3,33045
81111d00:	18f61b04 	addi	r3,r3,-10132
81111d04:	10c03515 	stw	r3,212(r2)
	cTemp[54]="usiLowresPrtA15";
81111d08:	00a04574 	movhi	r2,33045
81111d0c:	108fa204 	addi	r2,r2,16008
81111d10:	00e04574 	movhi	r3,33045
81111d14:	18f61f04 	addi	r3,r3,-10116
81111d18:	10c03615 	stw	r3,216(r2)
	cTemp[55]="usiSelHiresPrt0";
81111d1c:	00a04574 	movhi	r2,33045
81111d20:	108fa204 	addi	r2,r2,16008
81111d24:	00e04574 	movhi	r3,33045
81111d28:	18f62304 	addi	r3,r3,-10100
81111d2c:	10c03715 	stw	r3,220(r2)
	cTemp[56]="usiSelHiresPrt1";
81111d30:	00a04574 	movhi	r2,33045
81111d34:	108fa204 	addi	r2,r2,16008
81111d38:	00e04574 	movhi	r3,33045
81111d3c:	18f62704 	addi	r3,r3,-10084
81111d40:	10c03815 	stw	r3,224(r2)
	cTemp[57]="usiSelHiresPrt2";
81111d44:	00a04574 	movhi	r2,33045
81111d48:	108fa204 	addi	r2,r2,16008
81111d4c:	00e04574 	movhi	r3,33045
81111d50:	18f62b04 	addi	r3,r3,-10068
81111d54:	10c03915 	stw	r3,228(r2)
	cTemp[58]="usiSelHiresPrt3";
81111d58:	00a04574 	movhi	r2,33045
81111d5c:	108fa204 	addi	r2,r2,16008
81111d60:	00e04574 	movhi	r3,33045
81111d64:	18f62f04 	addi	r3,r3,-10052
81111d68:	10c03a15 	stw	r3,232(r2)
	cTemp[59]="usiSelHiresPrt4";
81111d6c:	00a04574 	movhi	r2,33045
81111d70:	108fa204 	addi	r2,r2,16008
81111d74:	00e04574 	movhi	r3,33045
81111d78:	18f63304 	addi	r3,r3,-10036
81111d7c:	10c03b15 	stw	r3,236(r2)
	cTemp[60]="usiSelHiresPrt5";
81111d80:	00a04574 	movhi	r2,33045
81111d84:	108fa204 	addi	r2,r2,16008
81111d88:	00e04574 	movhi	r3,33045
81111d8c:	18f63704 	addi	r3,r3,-10020
81111d90:	10c03c15 	stw	r3,240(r2)
	cTemp[61]="usiSelHiresPrt6";
81111d94:	00a04574 	movhi	r2,33045
81111d98:	108fa204 	addi	r2,r2,16008
81111d9c:	00e04574 	movhi	r3,33045
81111da0:	18f63b04 	addi	r3,r3,-10004
81111da4:	10c03d15 	stw	r3,244(r2)
	cTemp[62]="usiSelHiresPrt7";
81111da8:	00a04574 	movhi	r2,33045
81111dac:	108fa204 	addi	r2,r2,16008
81111db0:	00e04574 	movhi	r3,33045
81111db4:	18f63f04 	addi	r3,r3,-9988
81111db8:	10c03e15 	stw	r3,248(r2)
	cTemp[63]="usiZeroHiresAmp";
81111dbc:	00a04574 	movhi	r2,33045
81111dc0:	108fa204 	addi	r2,r2,16008
81111dc4:	00e04574 	movhi	r3,33045
81111dc8:	18f64304 	addi	r3,r3,-9972
81111dcc:	10c03f15 	stw	r3,252(r2)
}
81111dd0:	0001883a 	nop
81111dd4:	e037883a 	mov	sp,fp
81111dd8:	df000017 	ldw	fp,0(sp)
81111ddc:	dec00104 	addi	sp,sp,4
81111de0:	f800283a 	ret

81111de4 <vInAckHandlerTaskV2>:


#include "in_ack_handler_task.h"


void vInAckHandlerTaskV2(void *task_data) {
81111de4:	defff604 	addi	sp,sp,-40
81111de8:	de00012e 	bgeu	sp,et,81111df0 <vInAckHandlerTaskV2+0xc>
81111dec:	003b68fa 	trap	3
81111df0:	dfc00915 	stw	ra,36(sp)
81111df4:	df000815 	stw	fp,32(sp)
81111df8:	df000804 	addi	fp,sp,32
81111dfc:	e13fff15 	stw	r4,-4(fp)

	bool bFound = FALSE;
81111e00:	e03ff815 	stw	zero,-32(fp)
    bool bFinished32 = FALSE;
81111e04:	e03ffb15 	stw	zero,-20(fp)
    bool bFinished64 = FALSE;
81111e08:	e03ffc15 	stw	zero,-16(fp)
    bool bFinished128 = FALSE;
81111e0c:	e03ffd15 	stw	zero,-12(fp)
	INT8U error_code;
	tReceiverACKState eReceiverAckState;
	static txReceivedACK xRAckLocal;
    unsigned char ucHashVerification = 0;
81111e10:	e03ffa85 	stb	zero,-22(fp)
    unsigned char ucCountRetries = 0;
81111e14:	e03ffa05 	stb	zero,-24(fp)
    unsigned char i = 0;
81111e18:	e03ffa45 	stb	zero,-23(fp)

    #ifdef DEBUG_ON
        debug(fp,"In Ack Handler Task. (Task on)\n");
81111e1c:	d0a06217 	ldw	r2,-32376(gp)
81111e20:	100f883a 	mov	r7,r2
81111e24:	018007c4 	movi	r6,31
81111e28:	01400044 	movi	r5,1
81111e2c:	01204574 	movhi	r4,33045
81111e30:	21364704 	addi	r4,r4,-9956
81111e34:	1121c7c0 	call	81121c7c <fwrite>
    #endif

	eReceiverAckState = sRAConfiguring;
81111e38:	e03ff915 	stw	zero,-28(fp)

	for(;;){

		switch (eReceiverAckState) {
81111e3c:	e0bff917 	ldw	r2,-28(fp)
81111e40:	10c00060 	cmpeqi	r3,r2,1
81111e44:	1800071e 	bne	r3,zero,81111e64 <vInAckHandlerTaskV2+0x80>
81111e48:	0080032e 	bgeu	zero,r2,81111e58 <vInAckHandlerTaskV2+0x74>
81111e4c:	108000a0 	cmpeqi	r2,r2,2
81111e50:	10004a1e 	bne	r2,zero,81111f7c <vInAckHandlerTaskV2+0x198>
81111e54:	0000ac06 	br	81112108 <vInAckHandlerTaskV2+0x324>
			case sRAConfiguring:
                /*For future implementations*/
                eReceiverAckState = sRAGettingACK;
81111e58:	00800044 	movi	r2,1
81111e5c:	e0bff915 	stw	r2,-28(fp)
				break;
81111e60:	0000b306 	br	81112130 <vInAckHandlerTaskV2+0x34c>
            case sRAGettingACK:
                eReceiverAckState = sRAGettingACK;
81111e64:	00800044 	movi	r2,1
81111e68:	e0bff915 	stw	r2,-28(fp)
                /* Waits the semaphore that indicates there are some ack message was received*/
                OSSemPend(xSemCountReceivedACK, 0, &error_code);
81111e6c:	d0a06617 	ldw	r2,-32360(gp)
81111e70:	e0fffe04 	addi	r3,fp,-8
81111e74:	180d883a 	mov	r6,r3
81111e78:	000b883a 	mov	r5,zero
81111e7c:	1009883a 	mov	r4,r2
81111e80:	113eb180 	call	8113eb18 <OSSemPend>
                if ( error_code == OS_ERR_NONE ) {
81111e84:	e0bffe03 	ldbu	r2,-8(fp)
81111e88:	10803fcc 	andi	r2,r2,255
81111e8c:	1000391e 	bne	r2,zero,81111f74 <vInAckHandlerTaskV2+0x190>

                    OSMutexPend(xMutexReceivedACK, 0, &error_code);
81111e90:	d0a06517 	ldw	r2,-32364(gp)
81111e94:	e0fffe04 	addi	r3,fp,-8
81111e98:	180d883a 	mov	r6,r3
81111e9c:	000b883a 	mov	r5,zero
81111ea0:	1009883a 	mov	r4,r2
81111ea4:	113cb0c0 	call	8113cb0c <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
81111ea8:	e0bffe03 	ldbu	r2,-8(fp)
81111eac:	10803fcc 	andi	r2,r2,255
81111eb0:	10002b1e 	bne	r2,zero,81111f60 <vInAckHandlerTaskV2+0x17c>

                        /*Search for the ack*/
                        for(i = 0; i < N_ACKS_RECEIVED; i++)
81111eb4:	e03ffa45 	stb	zero,-23(fp)
81111eb8:	00002206 	br	81111f44 <vInAckHandlerTaskV2+0x160>
                        {
                            if ( xReceivedACK[i].cType != 0 ) {
81111ebc:	e0fffa43 	ldbu	r3,-23(fp)
81111ec0:	00a045b4 	movhi	r2,33046
81111ec4:	10853e04 	addi	r2,r2,5368
81111ec8:	18c7883a 	add	r3,r3,r3
81111ecc:	18c7883a 	add	r3,r3,r3
81111ed0:	10c5883a 	add	r2,r2,r3
81111ed4:	10800003 	ldbu	r2,0(r2)
81111ed8:	10803fcc 	andi	r2,r2,255
81111edc:	1080201c 	xori	r2,r2,128
81111ee0:	10bfe004 	addi	r2,r2,-128
81111ee4:	10001426 	beq	r2,zero,81111f38 <vInAckHandlerTaskV2+0x154>

                                /*  Nack don't get here */
                                xRAckLocal = xReceivedACK[i];
81111ee8:	e0fffa43 	ldbu	r3,-23(fp)
81111eec:	00a045b4 	movhi	r2,33046
81111ef0:	10853e04 	addi	r2,r2,5368
81111ef4:	18c7883a 	add	r3,r3,r3
81111ef8:	18c7883a 	add	r3,r3,r3
81111efc:	10c5883a 	add	r2,r2,r3
81111f00:	10c0000b 	ldhu	r3,0(r2)
81111f04:	d0e0568d 	sth	r3,-32422(gp)
81111f08:	1080008b 	ldhu	r2,2(r2)
81111f0c:	d0a0570d 	sth	r2,-32420(gp)
                                xReceivedACK[i].cType = 0; /* indicates that this position now can be used by other message*/
81111f10:	e0fffa43 	ldbu	r3,-23(fp)
81111f14:	00a045b4 	movhi	r2,33046
81111f18:	10853e04 	addi	r2,r2,5368
81111f1c:	18c7883a 	add	r3,r3,r3
81111f20:	18c7883a 	add	r3,r3,r3
81111f24:	10c5883a 	add	r2,r2,r3
81111f28:	10000005 	stb	zero,0(r2)
                                eReceiverAckState = sRACleanningBuffer;
81111f2c:	00800084 	movi	r2,2
81111f30:	e0bff915 	stw	r2,-28(fp)
                                break;                                
81111f34:	00000606 	br	81111f50 <vInAckHandlerTaskV2+0x16c>

                    OSMutexPend(xMutexReceivedACK, 0, &error_code);
                    if ( error_code == OS_ERR_NONE ) {

                        /*Search for the ack*/
                        for(i = 0; i < N_ACKS_RECEIVED; i++)
81111f38:	e0bffa43 	ldbu	r2,-23(fp)
81111f3c:	10800044 	addi	r2,r2,1
81111f40:	e0bffa45 	stb	r2,-23(fp)
81111f44:	e0bffa43 	ldbu	r2,-23(fp)
81111f48:	108001b0 	cmpltui	r2,r2,6
81111f4c:	103fdb1e 	bne	r2,zero,81111ebc <__reset+0xfb0f1ebc>
                                xReceivedACK[i].cType = 0; /* indicates that this position now can be used by other message*/
                                eReceiverAckState = sRACleanningBuffer;
                                break;                                
                            }
                        }
                        OSMutexPost(xMutexReceivedACK);
81111f50:	d0a06517 	ldw	r2,-32364(gp)
81111f54:	1009883a 	mov	r4,r2
81111f58:	113d0b00 	call	8113d0b0 <OSMutexPost>
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
                }
                break;
81111f5c:	00007406 	br	81112130 <vInAckHandlerTaskV2+0x34c>
                        OSMutexPost(xMutexReceivedACK);

                    } else {
                        /*  Should never get here, will wait without timeout for the semaphore.
                            But if some error accours we will do nothing but print in the console */
                    	OSSemPost(xSemCountReceivedACK);
81111f60:	d0a06617 	ldw	r2,-32360(gp)
81111f64:	1009883a 	mov	r4,r2
81111f68:	113eea00 	call	8113eea0 <OSSemPost>
                    	vFailGetMutexReceiverTask();
81111f6c:	111bc940 	call	8111bc94 <vFailGetMutexReceiverTask>
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
                }
                break;
81111f70:	00006f06 	br	81112130 <vInAckHandlerTaskV2+0x34c>
                    	vFailGetMutexReceiverTask();
                    }
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
81111f74:	111bc2c0 	call	8111bc2c <vFailGetCountSemaphoreReceiverTask>
                }
                break;
81111f78:	00006d06 	br	81112130 <vInAckHandlerTaskV2+0x34c>
			case sRACleanningBuffer:
                /* Now a search will be performed in the three output buffer in order to find
                   the (re)transmission buffer identified by the id and erase it. */
                
                ucHashVerification = 0;
81111f7c:	e03ffa85 	stb	zero,-22(fp)
                ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);
81111f80:	d0a06883 	ldbu	r2,-32350(gp)
81111f84:	10803fcc 	andi	r2,r2,255
81111f88:	10800218 	cmpnei	r2,r2,8
81111f8c:	1000021e 	bne	r2,zero,81111f98 <vInAckHandlerTaskV2+0x1b4>
81111f90:	00c00104 	movi	r3,4
81111f94:	00000106 	br	81111f9c <vInAckHandlerTaskV2+0x1b8>
81111f98:	0007883a 	mov	r3,zero
81111f9c:	d0a07503 	ldbu	r2,-32300(gp)
81111fa0:	10803fcc 	andi	r2,r2,255
81111fa4:	10800218 	cmpnei	r2,r2,8
81111fa8:	1000021e 	bne	r2,zero,81111fb4 <vInAckHandlerTaskV2+0x1d0>
81111fac:	00800084 	movi	r2,2
81111fb0:	00000106 	br	81111fb8 <vInAckHandlerTaskV2+0x1d4>
81111fb4:	0005883a 	mov	r2,zero
81111fb8:	1884b03a 	or	r2,r3,r2
81111fbc:	1007883a 	mov	r3,r2
81111fc0:	d0a07543 	ldbu	r2,-32299(gp)
81111fc4:	10803fcc 	andi	r2,r2,255
81111fc8:	108001a0 	cmpeqi	r2,r2,6
81111fcc:	1884b03a 	or	r2,r3,r2
81111fd0:	1007883a 	mov	r3,r2
81111fd4:	e0bffa83 	ldbu	r2,-22(fp)
81111fd8:	1884b03a 	or	r2,r3,r2
81111fdc:	e0bffa85 	stb	r2,-22(fp)

                bFound = FALSE;
81111fe0:	e03ff815 	stw	zero,-32(fp)
                bFinished32=FALSE;
81111fe4:	e03ffb15 	stw	zero,-20(fp)
                bFinished64=FALSE;
81111fe8:	e03ffc15 	stw	zero,-16(fp)
                bFinished128=FALSE;
81111fec:	e03ffd15 	stw	zero,-12(fp)
                ucCountRetries = 0;
81111ff0:	e03ffa05 	stb	zero,-24(fp)
                do
                {
                    ucCountRetries++;
81111ff4:	e0bffa03 	ldbu	r2,-24(fp)
81111ff8:	10800044 	addi	r2,r2,1
81111ffc:	e0bffa05 	stb	r2,-24(fp)

                    /* There are any spot used in the xBuffer128? */
                    if ( 0b00000001 != (0b00000001 & ucHashVerification ) )
81112000:	e0bffa83 	ldbu	r2,-22(fp)
81112004:	1080004c 	andi	r2,r2,1
81112008:	10803fcc 	andi	r2,r2,255
8111200c:	1000061e 	bne	r2,zero,81112028 <vInAckHandlerTaskV2+0x244>
                        bFound = bCheckInAck128( &xRAckLocal, &bFinished128  );
81112010:	e0bffd04 	addi	r2,fp,-12
81112014:	100b883a 	mov	r5,r2
81112018:	d1205684 	addi	r4,gp,-32422
8111201c:	11121340 	call	81112134 <bCheckInAck128>
81112020:	e0bff815 	stw	r2,-32(fp)
81112024:	00000206 	br	81112030 <vInAckHandlerTaskV2+0x24c>
                    else
                        bFinished128 = TRUE;
81112028:	00800044 	movi	r2,1
8111202c:	e0bffd15 	stw	r2,-12(fp)

                    /* There are any spot used in the xBuffer64? */
                    if ( (0b00000010 != (0b00000010 & ucHashVerification )) && (bFound ==FALSE ) )
81112030:	e0bffa83 	ldbu	r2,-22(fp)
81112034:	1080008c 	andi	r2,r2,2
81112038:	10803fcc 	andi	r2,r2,255
8111203c:	1000081e 	bne	r2,zero,81112060 <vInAckHandlerTaskV2+0x27c>
81112040:	e0bff817 	ldw	r2,-32(fp)
81112044:	1000061e 	bne	r2,zero,81112060 <vInAckHandlerTaskV2+0x27c>
                        bFound = bCheckInAck64( &xRAckLocal, &bFinished64 );
81112048:	e0bffc04 	addi	r2,fp,-16
8111204c:	100b883a 	mov	r5,r2
81112050:	d1205684 	addi	r4,gp,-32422
81112054:	111227c0 	call	8111227c <bCheckInAck64>
81112058:	e0bff815 	stw	r2,-32(fp)
8111205c:	00000206 	br	81112068 <vInAckHandlerTaskV2+0x284>
                    else
                        bFinished64 = TRUE;
81112060:	00800044 	movi	r2,1
81112064:	e0bffc15 	stw	r2,-16(fp)

                    /* There are any spot used in the xBuffer32? */
                    if ( (0b00000100 != (0b00000100 & ucHashVerification ) ) && (bFound ==FALSE ) )
81112068:	e0bffa83 	ldbu	r2,-22(fp)
8111206c:	1080010c 	andi	r2,r2,4
81112070:	10803fcc 	andi	r2,r2,255
81112074:	1000081e 	bne	r2,zero,81112098 <vInAckHandlerTaskV2+0x2b4>
81112078:	e0bff817 	ldw	r2,-32(fp)
8111207c:	1000061e 	bne	r2,zero,81112098 <vInAckHandlerTaskV2+0x2b4>
                        bFound = bCheckInAck32( &xRAckLocal, &bFinished32  );
81112080:	e0bffb04 	addi	r2,fp,-20
81112084:	100b883a 	mov	r5,r2
81112088:	d1205684 	addi	r4,gp,-32422
8111208c:	11123c80 	call	811123c8 <bCheckInAck32>
81112090:	e0bff815 	stw	r2,-32(fp)
81112094:	00000206 	br	811120a0 <vInAckHandlerTaskV2+0x2bc>
                    else
                        bFinished32 = TRUE;
81112098:	00800044 	movi	r2,1
8111209c:	e0bffb15 	stw	r2,-20(fp)

                } while ( ((ucCountRetries++ < MAX_RETRIES_ACK_IN) && (bFound == FALSE) && ((bFinished32 == FALSE) | (bFinished64 == FALSE) | (bFinished128 == FALSE))) );
811120a0:	e0bffa03 	ldbu	r2,-24(fp)
811120a4:	10c00044 	addi	r3,r2,1
811120a8:	e0fffa05 	stb	r3,-24(fp)
811120ac:	10803fcc 	andi	r2,r2,255
811120b0:	10800ca8 	cmpgeui	r2,r2,50
811120b4:	10000e1e 	bne	r2,zero,811120f0 <vInAckHandlerTaskV2+0x30c>
811120b8:	e0bff817 	ldw	r2,-32(fp)
811120bc:	10000c1e 	bne	r2,zero,811120f0 <vInAckHandlerTaskV2+0x30c>
811120c0:	e0bffb17 	ldw	r2,-20(fp)
811120c4:	1005003a 	cmpeq	r2,r2,zero
811120c8:	1007883a 	mov	r3,r2
811120cc:	e0bffc17 	ldw	r2,-16(fp)
811120d0:	1005003a 	cmpeq	r2,r2,zero
811120d4:	1884b03a 	or	r2,r3,r2
811120d8:	10c03fcc 	andi	r3,r2,255
811120dc:	e0bffd17 	ldw	r2,-12(fp)
811120e0:	1005003a 	cmpeq	r2,r2,zero
811120e4:	10803fcc 	andi	r2,r2,255
811120e8:	1884b03a 	or	r2,r3,r2
811120ec:	103fc11e 	bne	r2,zero,81111ff4 <__reset+0xfb0f1ff4>
                
                if (bFound == FALSE) {
811120f0:	e0bff817 	ldw	r2,-32(fp)
811120f4:	1000011e 	bne	r2,zero,811120fc <vInAckHandlerTaskV2+0x318>
                    /* Could not found the buffer with the id received in the ack packet*/
                    vFailFoundBufferRetransmission();
811120f8:	111c1500 	call	8111c150 <vFailFoundBufferRetransmission>
                }

                eReceiverAckState = sRAGettingACK;
811120fc:	00800044 	movi	r2,1
81112100:	e0bff915 	stw	r2,-28(fp)
				break;
81112104:	00000a06 	br	81112130 <vInAckHandlerTaskV2+0x34c>
			default:
                #ifdef DEBUG_ON
		            debug(fp,"Critical: Default State. Should never get here.(vInAckHandlerTaskV2)\n");
81112108:	d0a06217 	ldw	r2,-32376(gp)
8111210c:	100f883a 	mov	r7,r2
81112110:	01801144 	movi	r6,69
81112114:	01400044 	movi	r5,1
81112118:	01204574 	movhi	r4,33045
8111211c:	21364f04 	addi	r4,r4,-9924
81112120:	1121c7c0 	call	81121c7c <fwrite>
	            #endif
                eReceiverAckState = sRAGettingACK;
81112124:	00800044 	movi	r2,1
81112128:	e0bff915 	stw	r2,-28(fp)
				break;
8111212c:	0001883a 	nop
		}
	}
81112130:	003f4206 	br	81111e3c <__reset+0xfb0f1e3c>

81112134 <bCheckInAck128>:
}


bool bCheckInAck128( txReceivedACK *xRecAckL , bool *bFinished ) {
81112134:	defffa04 	addi	sp,sp,-24
81112138:	de00012e 	bgeu	sp,et,81112140 <bCheckInAck128+0xc>
8111213c:	003b68fa 	trap	3
81112140:	dfc00515 	stw	ra,20(sp)
81112144:	df000415 	stw	fp,16(sp)
81112148:	df000404 	addi	fp,sp,16
8111214c:	e13ffe15 	stw	r4,-8(fp)
81112150:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
81112154:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
81112158:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
8111215c:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
81112160:	e0bfff17 	ldw	r2,-4(fp)
81112164:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer128, 5, &error_code); /* Mas wait 1 tick = 1 ms */
81112168:	d0a06e17 	ldw	r2,-32328(gp)
8111216c:	e0fffd44 	addi	r3,fp,-11
81112170:	180d883a 	mov	r6,r3
81112174:	01400144 	movi	r5,5
81112178:	1009883a 	mov	r4,r2
8111217c:	113cb0c0 	call	8113cb0c <OSMutexPend>
    if ( error_code != OS_NO_ERR )
81112180:	e0bffd43 	ldbu	r2,-11(fp)
81112184:	10803fcc 	andi	r2,r2,255
81112188:	10000226 	beq	r2,zero,81112194 <bCheckInAck128+0x60>
        return bFound;
8111218c:	e0bffc17 	ldw	r2,-16(fp)
81112190:	00003506 	br	81112268 <bCheckInAck128+0x134>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_128; ucIL++)
81112194:	e03ffd05 	stb	zero,-12(fp)
81112198:	00002706 	br	81112238 <bCheckInAck128+0x104>
    {
        if ( xBuffer128[ucIL].usiId == xRecAckL->usiId ) {
8111219c:	e0fffd03 	ldbu	r3,-12(fp)
811121a0:	00a045b4 	movhi	r2,33046
811121a4:	10bc3c04 	addi	r2,r2,-3856
811121a8:	18c02324 	muli	r3,r3,140
811121ac:	10c5883a 	add	r2,r2,r3
811121b0:	10802104 	addi	r2,r2,132
811121b4:	10c0000b 	ldhu	r3,0(r2)
811121b8:	e0bffe17 	ldw	r2,-8(fp)
811121bc:	1080008b 	ldhu	r2,2(r2)
811121c0:	18ffffcc 	andi	r3,r3,65535
811121c4:	10bfffcc 	andi	r2,r2,65535
811121c8:	1880181e 	bne	r3,r2,8111222c <bCheckInAck128+0xf8>
            bFound = TRUE;
811121cc:	00800044 	movi	r2,1
811121d0:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b128[ucIL] = FALSE;
811121d4:	e0fffd03 	ldbu	r3,-12(fp)
811121d8:	00a045b4 	movhi	r2,33046
811121dc:	10bc1e04 	addi	r2,r2,-3976
811121e0:	18c7883a 	add	r3,r3,r3
811121e4:	18c7883a 	add	r3,r3,r3
811121e8:	10c5883a 	add	r2,r2,r3
811121ec:	10000015 	stw	zero,0(r2)
            SemCount128++;
811121f0:	d0a07543 	ldbu	r2,-32299(gp)
811121f4:	10800044 	addi	r2,r2,1
811121f8:	d0a07545 	stb	r2,-32299(gp)
            error_code = OSSemPost(xSemCountBuffer128);
811121fc:	d0a06317 	ldw	r2,-32372(gp)
81112200:	1009883a 	mov	r4,r2
81112204:	113eea00 	call	8113eea0 <OSSemPost>
81112208:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
8111220c:	e0bffd43 	ldbu	r2,-11(fp)
81112210:	10803fcc 	andi	r2,r2,255
81112214:	10000c26 	beq	r2,zero,81112248 <bCheckInAck128+0x114>
                SemCount128--;
81112218:	d0a07543 	ldbu	r2,-32299(gp)
8111221c:	10bfffc4 	addi	r2,r2,-1
81112220:	d0a07545 	stb	r2,-32299(gp)
                vFailSetCountSemaphorexBuffer128();
81112224:	111bfb00 	call	8111bfb0 <vFailSetCountSemaphorexBuffer128>
            }
            break;
81112228:	00000706 	br	81112248 <bCheckInAck128+0x114>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_128; ucIL++)
8111222c:	e0bffd03 	ldbu	r2,-12(fp)
81112230:	10800044 	addi	r2,r2,1
81112234:	e0bffd05 	stb	r2,-12(fp)
81112238:	e0bffd03 	ldbu	r2,-12(fp)
8111223c:	108001b0 	cmpltui	r2,r2,6
81112240:	103fd61e 	bne	r2,zero,8111219c <__reset+0xfb0f219c>
81112244:	00000106 	br	8111224c <bCheckInAck128+0x118>
            error_code = OSSemPost(xSemCountBuffer128);
            if ( error_code != OS_ERR_NONE ) {
                SemCount128--;
                vFailSetCountSemaphorexBuffer128();
            }
            break;
81112248:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer128); /* Free the Mutex after use the xBuffer128*/
8111224c:	d0a06e17 	ldw	r2,-32328(gp)
81112250:	1009883a 	mov	r4,r2
81112254:	113d0b00 	call	8113d0b0 <OSMutexPost>
    (*bFinished) = TRUE;
81112258:	e0bfff17 	ldw	r2,-4(fp)
8111225c:	00c00044 	movi	r3,1
81112260:	10c00015 	stw	r3,0(r2)

    return bFound;
81112264:	e0bffc17 	ldw	r2,-16(fp)
}
81112268:	e037883a 	mov	sp,fp
8111226c:	dfc00117 	ldw	ra,4(sp)
81112270:	df000017 	ldw	fp,0(sp)
81112274:	dec00204 	addi	sp,sp,8
81112278:	f800283a 	ret

8111227c <bCheckInAck64>:


bool bCheckInAck64( txReceivedACK *xRecAckL , bool *bFinished ) {
8111227c:	defffa04 	addi	sp,sp,-24
81112280:	de00012e 	bgeu	sp,et,81112288 <bCheckInAck64+0xc>
81112284:	003b68fa 	trap	3
81112288:	dfc00515 	stw	ra,20(sp)
8111228c:	df000415 	stw	fp,16(sp)
81112290:	df000404 	addi	fp,sp,16
81112294:	e13ffe15 	stw	r4,-8(fp)
81112298:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
8111229c:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
811122a0:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
811122a4:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
811122a8:	e0bfff17 	ldw	r2,-4(fp)
811122ac:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer64, 1, &error_code); /* Mas wait 1 tick = 1 ms */
811122b0:	d0a07117 	ldw	r2,-32316(gp)
811122b4:	e0fffd44 	addi	r3,fp,-11
811122b8:	180d883a 	mov	r6,r3
811122bc:	01400044 	movi	r5,1
811122c0:	1009883a 	mov	r4,r2
811122c4:	113cb0c0 	call	8113cb0c <OSMutexPend>
    if ( error_code != OS_NO_ERR )
811122c8:	e0bffd43 	ldbu	r2,-11(fp)
811122cc:	10803fcc 	andi	r2,r2,255
811122d0:	10000226 	beq	r2,zero,811122dc <bCheckInAck64+0x60>
        return bFound;
811122d4:	e0bffc17 	ldw	r2,-16(fp)
811122d8:	00003606 	br	811123b4 <bCheckInAck64+0x138>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_64; ucIL++)
811122dc:	e03ffd05 	stb	zero,-12(fp)
811122e0:	00002806 	br	81112384 <bCheckInAck64+0x108>
    {
        if ( xBuffer64[ucIL].usiId == xRecAckL->usiId ) {
811122e4:	e0fffd03 	ldbu	r3,-12(fp)
811122e8:	00a04574 	movhi	r2,33045
811122ec:	1097e204 	addi	r2,r2,24456
811122f0:	18c01324 	muli	r3,r3,76
811122f4:	10c5883a 	add	r2,r2,r3
811122f8:	10801104 	addi	r2,r2,68
811122fc:	10c0000b 	ldhu	r3,0(r2)
81112300:	e0bffe17 	ldw	r2,-8(fp)
81112304:	1080008b 	ldhu	r2,2(r2)
81112308:	18ffffcc 	andi	r3,r3,65535
8111230c:	10bfffcc 	andi	r2,r2,65535
81112310:	1880191e 	bne	r3,r2,81112378 <bCheckInAck64+0xfc>
            bFound = TRUE;
81112314:	00800044 	movi	r2,1
81112318:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b64[ucIL] = FALSE;
8111231c:	e0fffd03 	ldbu	r3,-12(fp)
81112320:	00a045b4 	movhi	r2,33046
81112324:	10bc1e04 	addi	r2,r2,-3976
81112328:	18c00184 	addi	r3,r3,6
8111232c:	18c7883a 	add	r3,r3,r3
81112330:	18c7883a 	add	r3,r3,r3
81112334:	10c5883a 	add	r2,r2,r3
81112338:	10000015 	stw	zero,0(r2)
            SemCount64++;
8111233c:	d0a07503 	ldbu	r2,-32300(gp)
81112340:	10800044 	addi	r2,r2,1
81112344:	d0a07505 	stb	r2,-32300(gp)
            error_code = OSSemPost(xSemCountBuffer64);
81112348:	d0a05e17 	ldw	r2,-32392(gp)
8111234c:	1009883a 	mov	r4,r2
81112350:	113eea00 	call	8113eea0 <OSSemPost>
81112354:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
81112358:	e0bffd43 	ldbu	r2,-11(fp)
8111235c:	10803fcc 	andi	r2,r2,255
81112360:	10000c26 	beq	r2,zero,81112394 <bCheckInAck64+0x118>
                SemCount64--;
81112364:	d0a07503 	ldbu	r2,-32300(gp)
81112368:	10bfffc4 	addi	r2,r2,-1
8111236c:	d0a07505 	stb	r2,-32300(gp)
                vFailSetCountSemaphorexBuffer64();
81112370:	111bf480 	call	8111bf48 <vFailSetCountSemaphorexBuffer64>
            }
            break;
81112374:	00000706 	br	81112394 <bCheckInAck64+0x118>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_64; ucIL++)
81112378:	e0bffd03 	ldbu	r2,-12(fp)
8111237c:	10800044 	addi	r2,r2,1
81112380:	e0bffd05 	stb	r2,-12(fp)
81112384:	e0bffd03 	ldbu	r2,-12(fp)
81112388:	10800230 	cmpltui	r2,r2,8
8111238c:	103fd51e 	bne	r2,zero,811122e4 <__reset+0xfb0f22e4>
81112390:	00000106 	br	81112398 <bCheckInAck64+0x11c>
            error_code = OSSemPost(xSemCountBuffer64);
            if ( error_code != OS_ERR_NONE ) {
                SemCount64--;
                vFailSetCountSemaphorexBuffer64();
            }
            break;
81112394:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer64); /* Free the Mutex after use the xBuffer128*/
81112398:	d0a07117 	ldw	r2,-32316(gp)
8111239c:	1009883a 	mov	r4,r2
811123a0:	113d0b00 	call	8113d0b0 <OSMutexPost>
    (*bFinished) = TRUE;
811123a4:	e0bfff17 	ldw	r2,-4(fp)
811123a8:	00c00044 	movi	r3,1
811123ac:	10c00015 	stw	r3,0(r2)

    return bFound;
811123b0:	e0bffc17 	ldw	r2,-16(fp)
}
811123b4:	e037883a 	mov	sp,fp
811123b8:	dfc00117 	ldw	ra,4(sp)
811123bc:	df000017 	ldw	fp,0(sp)
811123c0:	dec00204 	addi	sp,sp,8
811123c4:	f800283a 	ret

811123c8 <bCheckInAck32>:



bool bCheckInAck32( txReceivedACK *xRecAckL , bool *bFinished ) {
811123c8:	defffa04 	addi	sp,sp,-24
811123cc:	de00012e 	bgeu	sp,et,811123d4 <bCheckInAck32+0xc>
811123d0:	003b68fa 	trap	3
811123d4:	dfc00515 	stw	ra,20(sp)
811123d8:	df000415 	stw	fp,16(sp)
811123dc:	df000404 	addi	fp,sp,16
811123e0:	e13ffe15 	stw	r4,-8(fp)
811123e4:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
811123e8:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
811123ec:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
811123f0:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
811123f4:	e0bfff17 	ldw	r2,-4(fp)
811123f8:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer32, 1, &error_code); /* Mas wait 1 tick = 1 ms */
811123fc:	d0a06c17 	ldw	r2,-32336(gp)
81112400:	e0fffd44 	addi	r3,fp,-11
81112404:	180d883a 	mov	r6,r3
81112408:	01400044 	movi	r5,1
8111240c:	1009883a 	mov	r4,r2
81112410:	113cb0c0 	call	8113cb0c <OSMutexPend>
    if ( error_code != OS_NO_ERR )
81112414:	e0bffd43 	ldbu	r2,-11(fp)
81112418:	10803fcc 	andi	r2,r2,255
8111241c:	10000226 	beq	r2,zero,81112428 <bCheckInAck32+0x60>
        return bFound;
81112420:	e0bffc17 	ldw	r2,-16(fp)
81112424:	00003606 	br	81112500 <bCheckInAck32+0x138>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_32; ucIL++)
81112428:	e03ffd05 	stb	zero,-12(fp)
8111242c:	00002806 	br	811124d0 <bCheckInAck32+0x108>
    {
        if ( xBuffer32[ucIL].usiId == xRecAckL->usiId ) {
81112430:	e0fffd03 	ldbu	r3,-12(fp)
81112434:	00a045b4 	movhi	r2,33046
81112438:	10a99e04 	addi	r2,r2,-22920
8111243c:	18c00b24 	muli	r3,r3,44
81112440:	10c5883a 	add	r2,r2,r3
81112444:	10800904 	addi	r2,r2,36
81112448:	10c0000b 	ldhu	r3,0(r2)
8111244c:	e0bffe17 	ldw	r2,-8(fp)
81112450:	1080008b 	ldhu	r2,2(r2)
81112454:	18ffffcc 	andi	r3,r3,65535
81112458:	10bfffcc 	andi	r2,r2,65535
8111245c:	1880191e 	bne	r3,r2,811124c4 <bCheckInAck32+0xfc>
            bFound = TRUE;
81112460:	00800044 	movi	r2,1
81112464:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b32[ucIL] = FALSE;
81112468:	e0fffd03 	ldbu	r3,-12(fp)
8111246c:	00a045b4 	movhi	r2,33046
81112470:	10bc1e04 	addi	r2,r2,-3976
81112474:	18c00384 	addi	r3,r3,14
81112478:	18c7883a 	add	r3,r3,r3
8111247c:	18c7883a 	add	r3,r3,r3
81112480:	10c5883a 	add	r2,r2,r3
81112484:	10000015 	stw	zero,0(r2)
            SemCount32++;
81112488:	d0a06883 	ldbu	r2,-32350(gp)
8111248c:	10800044 	addi	r2,r2,1
81112490:	d0a06885 	stb	r2,-32350(gp)
            error_code = OSSemPost(xSemCountBuffer32);
81112494:	d0a06f17 	ldw	r2,-32324(gp)
81112498:	1009883a 	mov	r4,r2
8111249c:	113eea00 	call	8113eea0 <OSSemPost>
811124a0:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
811124a4:	e0bffd43 	ldbu	r2,-11(fp)
811124a8:	10803fcc 	andi	r2,r2,255
811124ac:	10000c26 	beq	r2,zero,811124e0 <bCheckInAck32+0x118>
                SemCount32--;
811124b0:	d0a06883 	ldbu	r2,-32350(gp)
811124b4:	10bfffc4 	addi	r2,r2,-1
811124b8:	d0a06885 	stb	r2,-32350(gp)
                vFailSetCountSemaphorexBuffer32();
811124bc:	111bee00 	call	8111bee0 <vFailSetCountSemaphorexBuffer32>
            }
            break;
811124c0:	00000706 	br	811124e0 <bCheckInAck32+0x118>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_32; ucIL++)
811124c4:	e0bffd03 	ldbu	r2,-12(fp)
811124c8:	10800044 	addi	r2,r2,1
811124cc:	e0bffd05 	stb	r2,-12(fp)
811124d0:	e0bffd03 	ldbu	r2,-12(fp)
811124d4:	10800230 	cmpltui	r2,r2,8
811124d8:	103fd51e 	bne	r2,zero,81112430 <__reset+0xfb0f2430>
811124dc:	00000106 	br	811124e4 <bCheckInAck32+0x11c>
            error_code = OSSemPost(xSemCountBuffer32);
            if ( error_code != OS_ERR_NONE ) {
                SemCount32--;
                vFailSetCountSemaphorexBuffer32();
            }
            break;
811124e0:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer32); /* Free the Mutex after use the xMutexBuffer32*/
811124e4:	d0a06c17 	ldw	r2,-32336(gp)
811124e8:	1009883a 	mov	r4,r2
811124ec:	113d0b00 	call	8113d0b0 <OSMutexPost>
    (*bFinished) = TRUE;
811124f0:	e0bfff17 	ldw	r2,-4(fp)
811124f4:	00c00044 	movi	r3,1
811124f8:	10c00015 	stw	r3,0(r2)

    return bFound;
811124fc:	e0bffc17 	ldw	r2,-16(fp)
}
81112500:	e037883a 	mov	sp,fp
81112504:	dfc00117 	ldw	ra,4(sp)
81112508:	df000017 	ldw	fp,0(sp)
8111250c:	dec00204 	addi	sp,sp,8
81112510:	f800283a 	ret

81112514 <vInitialTask>:

#include "initialization_task.h"


void vInitialTask(void *task_data)
{
81112514:	defff704 	addi	sp,sp,-36
81112518:	de00012e 	bgeu	sp,et,81112520 <vInitialTask+0xc>
8111251c:	003b68fa 	trap	3
81112520:	dfc00815 	stw	ra,32(sp)
81112524:	df000715 	stw	fp,28(sp)
81112528:	df000704 	addi	fp,sp,28
8111252c:	e13fff15 	stw	r4,-4(fp)
  INT8U error_code = OS_ERR_NONE;
81112530:	e03ffe05 	stb	zero,-8(fp)

	#if ( STACK_MONITOR == 1)
		OSStatInit();
81112534:	1138e7c0 	call	81138e7c <OSStatInit>

/* ================== All the task that need syncronization should be started first ========================= */

	/* Create the first NFEE 0 Task */
	#if ( STACK_MONITOR == 1)
		error_code = OSTaskCreateExt(vFeeTask,
81112538:	008000c4 	movi	r2,3
8111253c:	d8800415 	stw	r2,16(sp)
81112540:	d8000315 	stw	zero,12(sp)
81112544:	00810004 	movi	r2,1024
81112548:	d8800215 	stw	r2,8(sp)
8111254c:	00a04574 	movhi	r2,33045
81112550:	108fe204 	addi	r2,r2,16264
81112554:	d8800115 	stw	r2,4(sp)
81112558:	008002c4 	movi	r2,11
8111255c:	d8800015 	stw	r2,0(sp)
81112560:	01c002c4 	movi	r7,11
81112564:	01a04574 	movhi	r6,33045
81112568:	3193e104 	addi	r6,r6,20356
8111256c:	016045b4 	movhi	r5,33046
81112570:	29650204 	addi	r5,r5,-27640
81112574:	01204474 	movhi	r4,33041
81112578:	2136ee04 	addi	r4,r4,-9288
8111257c:	113f8840 	call	8113f884 <OSTaskCreateExt>
81112580:	e0bffe05 	stb	r2,-8(fp)
									FEES_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81112584:	e0bffe03 	ldbu	r2,-8(fp)
81112588:	10803fcc 	andi	r2,r2,255
8111258c:	10000526 	beq	r2,zero,811125a4 <vInitialTask+0x90>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81112590:	e0bffe03 	ldbu	r2,-8(fp)
81112594:	10803fcc 	andi	r2,r2,255
81112598:	1009883a 	mov	r4,r2
8111259c:	111b85c0 	call	8111b85c <printErrorTask>
		#endif
			vCoudlNotCreateNFee0Task();
811125a0:	111cd080 	call	8111cd08 <vCoudlNotCreateNFee0Task>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
811125a4:	01c17704 	movi	r7,1500
811125a8:	000d883a 	mov	r6,zero
811125ac:	000b883a 	mov	r5,zero
811125b0:	0009883a 	mov	r4,zero
811125b4:	1140ab00 	call	81140ab0 <OSTimeDlyHMSM>
//	OSTimeDlyHMSM(0, 0, 0, 1500);

	
	/* Create the first Data Controller Task */
	#if ( STACK_MONITOR == 1)
		error_code = OSTaskCreateExt(vDataControlTask,
811125b8:	008000c4 	movi	r2,3
811125bc:	d8800415 	stw	r2,16(sp)
811125c0:	d8000315 	stw	zero,12(sp)
811125c4:	00810004 	movi	r2,1024
811125c8:	d8800215 	stw	r2,8(sp)
811125cc:	00a045b4 	movhi	r2,33046
811125d0:	10a0f004 	addi	r2,r2,-31808
811125d4:	d8800115 	stw	r2,4(sp)
811125d8:	00800284 	movi	r2,10
811125dc:	d8800015 	stw	r2,0(sp)
811125e0:	01c00284 	movi	r7,10
811125e4:	01a045b4 	movhi	r6,33046
811125e8:	31a4ef04 	addi	r6,r6,-27716
811125ec:	016045b4 	movhi	r5,33046
811125f0:	2964fa04 	addi	r5,r5,-27672
811125f4:	01204474 	movhi	r4,33041
811125f8:	2136c604 	addi	r4,r4,-9448
811125fc:	113f8840 	call	8113f884 <OSTaskCreateExt>
81112600:	e0bffe05 	stb	r2,-8(fp)
									DATA_CONTROL_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81112604:	e0bffe03 	ldbu	r2,-8(fp)
81112608:	10803fcc 	andi	r2,r2,255
8111260c:	10000526 	beq	r2,zero,81112624 <vInitialTask+0x110>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81112610:	e0bffe03 	ldbu	r2,-8(fp)
81112614:	10803fcc 	andi	r2,r2,255
81112618:	1009883a 	mov	r4,r2
8111261c:	111b85c0 	call	8111b85c <printErrorTask>
		#endif
			vCoudlNotCreateDataControllerTask();
81112620:	111cfe00 	call	8111cfe0 <vCoudlNotCreateDataControllerTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
81112624:	01c17704 	movi	r7,1500
81112628:	000d883a 	mov	r6,zero
8111262c:	000b883a 	mov	r5,zero
81112630:	0009883a 	mov	r4,zero
81112634:	1140ab00 	call	81140ab0 <OSTimeDlyHMSM>



	/* Create the first NFee Controller Task */
	#if ( STACK_MONITOR == 1)
		error_code = OSTaskCreateExt(vNFeeControlTask,
81112638:	008000c4 	movi	r2,3
8111263c:	d8800415 	stw	r2,16(sp)
81112640:	d8000315 	stw	zero,12(sp)
81112644:	00810004 	movi	r2,1024
81112648:	d8800215 	stw	r2,8(sp)
8111264c:	00a045b4 	movhi	r2,33046
81112650:	10bd2604 	addi	r2,r2,-2920
81112654:	d8800115 	stw	r2,4(sp)
81112658:	00800244 	movi	r2,9
8111265c:	d8800015 	stw	r2,0(sp)
81112660:	01c00244 	movi	r7,9
81112664:	01a045b4 	movhi	r6,33046
81112668:	31812504 	addi	r6,r6,1172
8111266c:	016045b4 	movhi	r5,33046
81112670:	29650204 	addi	r5,r5,-27640
81112674:	01204474 	movhi	r4,33041
81112678:	210ac304 	addi	r4,r4,11020
8111267c:	113f8840 	call	8113f884 <OSTaskCreateExt>
81112680:	e0bffe05 	stb	r2,-8(fp)
									FEE_CONTROL_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81112684:	e0bffe03 	ldbu	r2,-8(fp)
81112688:	10803fcc 	andi	r2,r2,255
8111268c:	10000526 	beq	r2,zero,811126a4 <vInitialTask+0x190>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81112690:	e0bffe03 	ldbu	r2,-8(fp)
81112694:	10803fcc 	andi	r2,r2,255
81112698:	1009883a 	mov	r4,r2
8111269c:	111b85c0 	call	8111b85c <printErrorTask>
		#endif
			vCoudlNotCreateNFeeControllerTask();
811126a0:	111cf780 	call	8111cf78 <vCoudlNotCreateNFeeControllerTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
811126a4:	01c17704 	movi	r7,1500
811126a8:	000d883a 	mov	r6,zero
811126ac:	000b883a 	mov	r5,zero
811126b0:	0009883a 	mov	r4,zero
811126b4:	1140ab00 	call	81140ab0 <OSTimeDlyHMSM>



	/* Create the first Meb Controller Task */
	#if ( STACK_MONITOR == 1)
		error_code = OSTaskCreateExt(vSimMebTask,
811126b8:	008000c4 	movi	r2,3
811126bc:	d8800415 	stw	r2,16(sp)
811126c0:	d8000315 	stw	zero,12(sp)
811126c4:	00810004 	movi	r2,1024
811126c8:	d8800215 	stw	r2,8(sp)
811126cc:	00a045b4 	movhi	r2,33046
811126d0:	108f4804 	addi	r2,r2,15648
811126d4:	d8800115 	stw	r2,4(sp)
811126d8:	00800204 	movi	r2,8
811126dc:	d8800015 	stw	r2,0(sp)
811126e0:	01c00204 	movi	r7,8
811126e4:	01a045b4 	movhi	r6,33046
811126e8:	31934704 	addi	r6,r6,19740
811126ec:	016045b4 	movhi	r5,33046
811126f0:	2964f004 	addi	r5,r5,-27712
811126f4:	01204474 	movhi	r4,33041
811126f8:	21145804 	addi	r4,r4,20832
811126fc:	113f8840 	call	8113f884 <OSTaskCreateExt>
81112700:	e0bffe05 	stb	r2,-8(fp)
									MEB_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81112704:	e0bffe03 	ldbu	r2,-8(fp)
81112708:	10803fcc 	andi	r2,r2,255
8111270c:	10000526 	beq	r2,zero,81112724 <vInitialTask+0x210>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81112710:	e0bffe03 	ldbu	r2,-8(fp)
81112714:	10803fcc 	andi	r2,r2,255
81112718:	1009883a 	mov	r4,r2
8111271c:	111b85c0 	call	8111b85c <printErrorTask>
		#endif
			vCoudlNotCreateMebTask();
81112720:	111d0480 	call	8111d048 <vCoudlNotCreateMebTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
81112724:	01c17704 	movi	r7,1500
81112728:	000d883a 	mov	r6,zero
8111272c:	000b883a 	mov	r5,zero
81112730:	0009883a 	mov	r4,zero
81112734:	1140ab00 	call	81140ab0 <OSTimeDlyHMSM>



	/* Create the task that is responsible to send the ack to NUC of the incomming messages */
	#if ( STACK_MONITOR == 1)
		error_code = OSTaskCreateExt(vTimeoutCheckerTaskv2,
81112738:	008000c4 	movi	r2,3
8111273c:	d8800415 	stw	r2,16(sp)
81112740:	d8000315 	stw	zero,12(sp)
81112744:	00810004 	movi	r2,1024
81112748:	d8800215 	stw	r2,8(sp)
8111274c:	00a04574 	movhi	r2,33045
81112750:	109cf004 	addi	r2,r2,29632
81112754:	d8800115 	stw	r2,4(sp)
81112758:	00800784 	movi	r2,30
8111275c:	d8800015 	stw	r2,0(sp)
81112760:	01c00784 	movi	r7,30
81112764:	01a045b4 	movhi	r6,33046
81112768:	31a0ef04 	addi	r6,r6,-31812
8111276c:	000b883a 	mov	r5,zero
81112770:	01204474 	movhi	r4,33041
81112774:	211b2404 	addi	r4,r4,27792
81112778:	113f8840 	call	8113f884 <OSTaskCreateExt>
8111277c:	e0bffe05 	stb	r2,-8(fp)
									TIMEOUT_CHECKER_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81112780:	e0bffe03 	ldbu	r2,-8(fp)
81112784:	10803fcc 	andi	r2,r2,255
81112788:	10000526 	beq	r2,zero,811127a0 <vInitialTask+0x28c>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8111278c:	e0bffe03 	ldbu	r2,-8(fp)
81112790:	10803fcc 	andi	r2,r2,255
81112794:	1009883a 	mov	r4,r2
81112798:	111b85c0 	call	8111b85c <printErrorTask>
		#endif
		vFailTimeoutCheckerTaskCreate();
8111279c:	111c6740 	call	8111c674 <vFailTimeoutCheckerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
811127a0:	01c03204 	movi	r7,200
811127a4:	000d883a 	mov	r6,zero
811127a8:	000b883a 	mov	r5,zero
811127ac:	0009883a 	mov	r4,zero
811127b0:	1140ab00 	call	81140ab0 <OSTimeDlyHMSM>


	/* Create the task that is responsible to send the ack to NUC of the incomming messages */
	#if ( STACK_MONITOR == 1)
		error_code = OSTaskCreateExt(vOutAckHandlerTask,
811127b4:	008000c4 	movi	r2,3
811127b8:	d8800415 	stw	r2,16(sp)
811127bc:	d8000315 	stw	zero,12(sp)
811127c0:	00810004 	movi	r2,1024
811127c4:	d8800215 	stw	r2,8(sp)
811127c8:	00a045b4 	movhi	r2,33046
811127cc:	10b00604 	addi	r2,r2,-16360
811127d0:	d8800115 	stw	r2,4(sp)
811127d4:	008006c4 	movi	r2,27
811127d8:	d8800015 	stw	r2,0(sp)
811127dc:	01c006c4 	movi	r7,27
811127e0:	01a045b4 	movhi	r6,33046
811127e4:	31b40504 	addi	r6,r6,-12268
811127e8:	000b883a 	mov	r5,zero
811127ec:	01204474 	movhi	r4,33041
811127f0:	210c9e04 	addi	r4,r4,12920
811127f4:	113f8840 	call	8113f884 <OSTaskCreateExt>
811127f8:	e0bffe05 	stb	r2,-8(fp)
									OUT_ACK_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
811127fc:	e0bffe03 	ldbu	r2,-8(fp)
81112800:	10803fcc 	andi	r2,r2,255
81112804:	10000526 	beq	r2,zero,8111281c <vInitialTask+0x308>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81112808:	e0bffe03 	ldbu	r2,-8(fp)
8111280c:	10803fcc 	andi	r2,r2,255
81112810:	1009883a 	mov	r4,r2
81112814:	111b85c0 	call	8111b85c <printErrorTask>
		#endif
		vFailOutAckHandlerTaskCreate();
81112818:	111c5900 	call	8111c590 <vFailOutAckHandlerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
8111281c:	01c03204 	movi	r7,200
81112820:	000d883a 	mov	r6,zero
81112824:	000b883a 	mov	r5,zero
81112828:	0009883a 	mov	r4,zero
8111282c:	1140ab00 	call	81140ab0 <OSTimeDlyHMSM>


	/* Create the task that is responsible to handle incomming ack packet */
	#if ( STACK_MONITOR == 1)
		error_code = OSTaskCreateExt(vInAckHandlerTaskV2,
81112830:	008000c4 	movi	r2,3
81112834:	d8800415 	stw	r2,16(sp)
81112838:	d8000315 	stw	zero,12(sp)
8111283c:	00810004 	movi	r2,1024
81112840:	d8800215 	stw	r2,8(sp)
81112844:	00a04574 	movhi	r2,33045
81112848:	1093e204 	addi	r2,r2,20360
8111284c:	d8800115 	stw	r2,4(sp)
81112850:	00800644 	movi	r2,25
81112854:	d8800015 	stw	r2,0(sp)
81112858:	01c00644 	movi	r7,25
8111285c:	01a04574 	movhi	r6,33045
81112860:	3197e104 	addi	r6,r6,24452
81112864:	000b883a 	mov	r5,zero
81112868:	01204474 	movhi	r4,33041
8111286c:	21077904 	addi	r4,r4,7652
81112870:	113f8840 	call	8113f884 <OSTaskCreateExt>
81112874:	e0bffe05 	stb	r2,-8(fp)
									IN_ACK_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81112878:	e0bffe03 	ldbu	r2,-8(fp)
8111287c:	10803fcc 	andi	r2,r2,255
81112880:	10000526 	beq	r2,zero,81112898 <vInitialTask+0x384>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81112884:	e0bffe03 	ldbu	r2,-8(fp)
81112888:	10803fcc 	andi	r2,r2,255
8111288c:	1009883a 	mov	r4,r2
81112890:	111b85c0 	call	8111b85c <printErrorTask>
		#endif
		vFailInAckHandlerTaskCreate();
81112894:	111c5440 	call	8111c544 <vFailInAckHandlerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
81112898:	01c03204 	movi	r7,200
8111289c:	000d883a 	mov	r6,zero
811128a0:	000b883a 	mov	r5,zero
811128a4:	0009883a 	mov	r4,zero
811128a8:	1140ab00 	call	81140ab0 <OSTimeDlyHMSM>


	/* Create the task that is responsible to parse all received messages */
	#if ( STACK_MONITOR == 1)
		error_code = OSTaskCreateExt(vParserCommTask,
811128ac:	008000c4 	movi	r2,3
811128b0:	d8800415 	stw	r2,16(sp)
811128b4:	d8000315 	stw	zero,12(sp)
811128b8:	00818004 	movi	r2,1536
811128bc:	d8800215 	stw	r2,8(sp)
811128c0:	00a045b4 	movhi	r2,33046
811128c4:	10894404 	addi	r2,r2,9488
811128c8:	d8800115 	stw	r2,4(sp)
811128cc:	00800704 	movi	r2,28
811128d0:	d8800015 	stw	r2,0(sp)
811128d4:	01c00704 	movi	r7,28
811128d8:	01a045b4 	movhi	r6,33046
811128dc:	318f4304 	addi	r6,r6,15628
811128e0:	000b883a 	mov	r5,zero
811128e4:	01204474 	movhi	r4,33041
811128e8:	210d5c04 	addi	r4,r4,13680
811128ec:	113f8840 	call	8113f884 <OSTaskCreateExt>
811128f0:	e0bffe05 	stb	r2,-8(fp)
									PARSER_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
811128f4:	e0bffe03 	ldbu	r2,-8(fp)
811128f8:	10803fcc 	andi	r2,r2,255
811128fc:	10000526 	beq	r2,zero,81112914 <vInitialTask+0x400>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81112900:	e0bffe03 	ldbu	r2,-8(fp)
81112904:	10803fcc 	andi	r2,r2,255
81112908:	1009883a 	mov	r4,r2
8111290c:	111b85c0 	call	8111b85c <printErrorTask>
		#endif
		vFailParserCommTaskCreate();
81112910:	111c4f80 	call	8111c4f8 <vFailParserCommTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
81112914:	01c03204 	movi	r7,200
81112918:	000d883a 	mov	r6,zero
8111291c:	000b883a 	mov	r5,zero
81112920:	0009883a 	mov	r4,zero
81112924:	1140ab00 	call	81140ab0 <OSTimeDlyHMSM>


	/* READ: Create the task that is responsible to READ UART buffer */
	#if ( STACK_MONITOR == 1)
		error_code = OSTaskCreateExt(vReceiverUartTask,
81112928:	008000c4 	movi	r2,3
8111292c:	d8800415 	stw	r2,16(sp)
81112930:	d8000315 	stw	zero,12(sp)
81112934:	00818004 	movi	r2,1536
81112938:	d8800215 	stw	r2,8(sp)
8111293c:	00a045b4 	movhi	r2,33046
81112940:	10a9f604 	addi	r2,r2,-22568
81112944:	d8800115 	stw	r2,4(sp)
81112948:	00800804 	movi	r2,32
8111294c:	d8800015 	stw	r2,0(sp)
81112950:	01c00804 	movi	r7,32
81112954:	01a045b4 	movhi	r6,33046
81112958:	31aff504 	addi	r6,r6,-16428
8111295c:	000b883a 	mov	r5,zero
81112960:	01204474 	movhi	r4,33041
81112964:	21117804 	addi	r4,r4,17888
81112968:	113f8840 	call	8113f884 <OSTaskCreateExt>
8111296c:	e0bffe05 	stb	r2,-8(fp)
									RECEIVER_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81112970:	e0bffe03 	ldbu	r2,-8(fp)
81112974:	10803fcc 	andi	r2,r2,255
81112978:	10000526 	beq	r2,zero,81112990 <vInitialTask+0x47c>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
8111297c:	e0bffe03 	ldbu	r2,-8(fp)
81112980:	10803fcc 	andi	r2,r2,255
81112984:	1009883a 	mov	r4,r2
81112988:	111b85c0 	call	8111b85c <printErrorTask>
		#endif
		vFailReceiverCreate();
8111298c:	111bdfc0 	call	8111bdfc <vFailReceiverCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
81112990:	01c03204 	movi	r7,200
81112994:	000d883a 	mov	r6,zero
81112998:	000b883a 	mov	r5,zero
8111299c:	0009883a 	mov	r4,zero
811129a0:	1140ab00 	call	81140ab0 <OSTimeDlyHMSM>


	/* SEND: Create the task that is responsible to SEND UART packets */
	#if ( STACK_MONITOR == 1)
		error_code = OSTaskCreateExt(vSenderComTask,
811129a4:	008000c4 	movi	r2,3
811129a8:	d8800415 	stw	r2,16(sp)
811129ac:	d8000315 	stw	zero,12(sp)
811129b0:	00810004 	movi	r2,1024
811129b4:	d8800215 	stw	r2,8(sp)
811129b8:	00a04574 	movhi	r2,33045
811129bc:	1098de04 	addi	r2,r2,25464
811129c0:	d8800115 	stw	r2,4(sp)
811129c4:	00800684 	movi	r2,26
811129c8:	d8800015 	stw	r2,0(sp)
811129cc:	01c00684 	movi	r7,26
811129d0:	01a04574 	movhi	r6,33045
811129d4:	319cdd04 	addi	r6,r6,29556
811129d8:	000b883a 	mov	r5,zero
811129dc:	01204474 	movhi	r4,33041
811129e0:	2113fa04 	addi	r4,r4,20456
811129e4:	113f8840 	call	8113f884 <OSTaskCreateExt>
811129e8:	e0bffe05 	stb	r2,-8(fp)
									0);
	#endif



	OSTimeDlyHMSM(0, 0, 0, 200);
811129ec:	01c03204 	movi	r7,200
811129f0:	000d883a 	mov	r6,zero
811129f4:	000b883a 	mov	r5,zero
811129f8:	0009883a 	mov	r4,zero
811129fc:	1140ab00 	call	81140ab0 <OSTimeDlyHMSM>



	#if ( STACK_MONITOR == 1)
		error_code = OSTaskCreateExt(vStackMonitor,
81112a00:	008000c4 	movi	r2,3
81112a04:	d8800415 	stw	r2,16(sp)
81112a08:	d8000315 	stw	zero,12(sp)
81112a0c:	00810004 	movi	r2,1024
81112a10:	d8800215 	stw	r2,8(sp)
81112a14:	00a045b4 	movhi	r2,33046
81112a18:	10b81e04 	addi	r2,r2,-8072
81112a1c:	d8800115 	stw	r2,4(sp)
81112a20:	00800404 	movi	r2,16
81112a24:	d8800015 	stw	r2,0(sp)
81112a28:	01c00404 	movi	r7,16
81112a2c:	01a045b4 	movhi	r6,33046
81112a30:	31bc1d04 	addi	r6,r6,-3980
81112a34:	000b883a 	mov	r5,zero
81112a38:	01204474 	movhi	r4,33041
81112a3c:	21192d04 	addi	r4,r4,25780
81112a40:	113f8840 	call	8113f884 <OSTaskCreateExt>
81112a44:	e0bffe05 	stb	r2,-8(fp)
									OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK);
	#endif



	if ( error_code != OS_ERR_NONE) {
81112a48:	e0bffe03 	ldbu	r2,-8(fp)
81112a4c:	10803fcc 	andi	r2,r2,255
81112a50:	10000526 	beq	r2,zero,81112a68 <vInitialTask+0x554>
		/* Can't create Task for sender comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
81112a54:	e0bffe03 	ldbu	r2,-8(fp)
81112a58:	10803fcc 	andi	r2,r2,255
81112a5c:	1009883a 	mov	r4,r2
81112a60:	111b85c0 	call	8111b85c <printErrorTask>
		#endif
		vFailSenderCreate();
81112a64:	111be480 	call	8111be48 <vFailSenderCreate>
	}

	/*	This is the timer that's trigger the task that implements the timeout/retransmission logic*/
	OSTmrStart ((OS_TMR *)xTimerRetransmission, (INT8U  *)&error_code);
81112a68:	d0a06d17 	ldw	r2,-32332(gp)
81112a6c:	e17ffe04 	addi	r5,fp,-8
81112a70:	1009883a 	mov	r4,r2
81112a74:	11415a40 	call	811415a4 <OSTmrStart>
	if ( error_code != OS_ERR_NONE) {
81112a78:	e0bffe03 	ldbu	r2,-8(fp)
81112a7c:	10803fcc 	andi	r2,r2,255
81112a80:	10000126 	beq	r2,zero,81112a88 <vInitialTask+0x574>
		/*	Could not create the timer that syncs the task that is responsible to retransmit the packets*/
		vFailStartTimerRetransmission();
81112a84:	111c9300 	call	8111c930 <vFailStartTimerRetransmission>
	}


	OSTimeDlyHMSM(0, 0, 30, 2); /* todo:debug REMOVER*/
81112a88:	01c00084 	movi	r7,2
81112a8c:	01800784 	movi	r6,30
81112a90:	000b883a 	mov	r5,zero
81112a94:	0009883a 	mov	r4,zero
81112a98:	1140ab00 	call	81140ab0 <OSTimeDlyHMSM>


	/* Delete the Initialization Task  */
	error_code = OSTaskDel(OS_PRIO_SELF); /* OS_PRIO_SELF = Means task self priority */
81112a9c:	01003fc4 	movi	r4,255
81112aa0:	113fa700 	call	8113fa70 <OSTaskDel>
81112aa4:	e0bffe05 	stb	r2,-8(fp)
	if ( error_code != OS_ERR_NONE) {
81112aa8:	e0bffe03 	ldbu	r2,-8(fp)
81112aac:	10803fcc 	andi	r2,r2,255
81112ab0:	10001026 	beq	r2,zero,81112af4 <vInitialTask+0x5e0>
		/*	Can't delete the initialization task, the problem is that the priority of this
			is that the PRIO is so high that will cause starvation if not deleted */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
81112ab4:	e0bffe03 	ldbu	r2,-8(fp)
81112ab8:	10803fcc 	andi	r2,r2,255
81112abc:	1009883a 	mov	r4,r2
81112ac0:	111b85c0 	call	8111b85c <printErrorTask>
		#endif
		vFailDeleteInitialization();
81112ac4:	111be940 	call	8111be94 <vFailDeleteInitialization>
		/*	To not exit the intire application, the PRIO of this task will be lowered*/
		OSTaskChangePrio( INITIALIZATION_TASK_PRIO , INITIALIZATION_TASK_PRIO_FAIL );
81112ac8:	014009c4 	movi	r5,39
81112acc:	01000044 	movi	r4,1
81112ad0:	113f1d80 	call	8113f1d8 <OSTaskChangePrio>

		for(;;) { /* Correct Program Flow should never get here */
			OSTaskDel(OS_PRIO_SELF); /* Try to delete it self */
81112ad4:	01003fc4 	movi	r4,255
81112ad8:	113fa700 	call	8113fa70 <OSTaskDel>
			OSTimeDlyHMSM(0,0,10,0); /* 1 sec */
81112adc:	000f883a 	mov	r7,zero
81112ae0:	01800284 	movi	r6,10
81112ae4:	000b883a 	mov	r5,zero
81112ae8:	0009883a 	mov	r4,zero
81112aec:	1140ab00 	call	81140ab0 <OSTimeDlyHMSM>
		}
81112af0:	003ff806 	br	81112ad4 <__reset+0xfb0f2ad4>
	}

}
81112af4:	0001883a 	nop
81112af8:	e037883a 	mov	sp,fp
81112afc:	dfc00117 	ldw	ra,4(sp)
81112b00:	df000017 	ldw	fp,0(sp)
81112b04:	dec00204 	addi	sp,sp,8
81112b08:	f800283a 	ret

81112b0c <vNFeeControlTask>:


#include "nfee_control_task.h"


void vNFeeControlTask(void *task_data) {
81112b0c:	defff804 	addi	sp,sp,-32
81112b10:	de00012e 	bgeu	sp,et,81112b18 <vNFeeControlTask+0xc>
81112b14:	003b68fa 	trap	3
81112b18:	dfc00715 	stw	ra,28(sp)
81112b1c:	df000615 	stw	fp,24(sp)
81112b20:	df000604 	addi	fp,sp,24
81112b24:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucFeeInstL;
	static bool bDmaBack;
	static unsigned char ucWhoGetDMA;
	unsigned char ucIL;

	pxFeeC = (TNFee_Control *) task_data;
81112b28:	e0bfff17 	ldw	r2,-4(fp)
81112b2c:	e0bffb15 	stw	r2,-20(fp)

	#ifdef DEBUG_ON
        debug(fp,"NFee Controller Task. (Task on)\n");
81112b30:	d0a06217 	ldw	r2,-32376(gp)
81112b34:	100f883a 	mov	r7,r2
81112b38:	01800804 	movi	r6,32
81112b3c:	01400044 	movi	r5,1
81112b40:	01204574 	movhi	r4,33045
81112b44:	21366104 	addi	r4,r4,-9852
81112b48:	1121c7c0 	call	81121c7c <fwrite>
    #endif

	for (;;) {

		switch (pxFeeC->sMode)
81112b4c:	e0bffb17 	ldw	r2,-20(fp)
81112b50:	10809a17 	ldw	r2,616(r2)
81112b54:	10c00168 	cmpgeui	r3,r2,5
81112b58:	1800da1e 	bne	r3,zero,81112ec4 <vNFeeControlTask+0x3b8>
81112b5c:	100690ba 	slli	r3,r2,2
81112b60:	00a04474 	movhi	r2,33041
81112b64:	108add04 	addi	r2,r2,11124
81112b68:	1885883a 	add	r2,r3,r2
81112b6c:	10800017 	ldw	r2,0(r2)
81112b70:	1000683a 	jmp	r2
81112b74:	81112b88 	cmpgei	r4,r16,17582
81112b78:	81112bb8 	rdprs	r4,r16,17582
81112b7c:	81112c18 	cmpnei	r4,r16,17584
81112b80:	81112ccc 	andi	r4,r16,17587
81112b84:	81112d2c 	andhi	r4,r16,17588
		{
			case sMebInit:
				/* Starting the NFEE Controller */

				/* Clear in CMD Queue  */
				error_codeCtrl = OSQFlush(xQMaskFeeCtrl);
81112b88:	d0a07017 	ldw	r2,-32320(gp)
81112b8c:	1009883a 	mov	r4,r2
81112b90:	113db600 	call	8113db60 <OSQFlush>
81112b94:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
81112b98:	e0bffe03 	ldbu	r2,-8(fp)
81112b9c:	10803fcc 	andi	r2,r2,255
81112ba0:	10000126 	beq	r2,zero,81112ba8 <vNFeeControlTask+0x9c>
					vFailFlushQueue();
81112ba4:	111d68c0 	call	8111d68c <vFailFlushQueue>
				}

				pxFeeC->sMode = sMebToConfig;
81112ba8:	e0bffb17 	ldw	r2,-20(fp)
81112bac:	00c00044 	movi	r3,1
81112bb0:	10c09a15 	stw	r3,616(r2)
				break;
81112bb4:	0000cf06 	br	81112ef4 <vNFeeControlTask+0x3e8>


			case sMebToConfig:
				/* Transition state */
				#ifdef DEBUG_ON
					debug(fp,"NFEE Controller Task:: Config Mode\n");
81112bb8:	d0a06217 	ldw	r2,-32376(gp)
81112bbc:	100f883a 	mov	r7,r2
81112bc0:	018008c4 	movi	r6,35
81112bc4:	01400044 	movi	r5,1
81112bc8:	01204574 	movhi	r4,33045
81112bcc:	21366a04 	addi	r4,r4,-9816
81112bd0:	1121c7c0 	call	81121c7c <fwrite>
				#endif

				/* Clear Queue that is responsible to schedule the DMA access */
				error_codeCtrl = OSQFlush(xNfeeSchedule);
81112bd4:	d0a05d17 	ldw	r2,-32396(gp)
81112bd8:	1009883a 	mov	r4,r2
81112bdc:	113db600 	call	8113db60 <OSQFlush>
81112be0:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
81112be4:	e0bffe03 	ldbu	r2,-8(fp)
81112be8:	10803fcc 	andi	r2,r2,255
81112bec:	10000126 	beq	r2,zero,81112bf4 <vNFeeControlTask+0xe8>
					vFailFlushQueue();
81112bf0:	111d68c0 	call	8111d68c <vFailFlushQueue>
				}

				bCmdSent = FALSE;
81112bf4:	e03ffc15 	stw	zero,-16(fp)
				bDmaBack = TRUE;
81112bf8:	00800044 	movi	r2,1
81112bfc:	d0a05815 	stw	r2,-32416(gp)
				ucWhoGetDMA = 255;
81112c00:	00bfffc4 	movi	r2,-1
81112c04:	d0a05905 	stb	r2,-32412(gp)
				pxFeeC->sMode = sMebConfig;
81112c08:	e0bffb17 	ldw	r2,-20(fp)
81112c0c:	00c000c4 	movi	r3,3
81112c10:	10c09a15 	stw	r3,616(r2)
				break;
81112c14:	0000b706 	br	81112ef4 <vNFeeControlTask+0x3e8>


			case sMebToRun:
				/* Transition state */
				vEvtChangeFeeControllerMode();
81112c18:	111d7e40 	call	8111d7e4 <vEvtChangeFeeControllerMode>
				#ifdef DEBUG_ON
					debug(fp,"NFEE Controller Task:: RUN Mode\n");
81112c1c:	d0a06217 	ldw	r2,-32376(gp)
81112c20:	100f883a 	mov	r7,r2
81112c24:	01800804 	movi	r6,32
81112c28:	01400044 	movi	r5,1
81112c2c:	01204574 	movhi	r4,33045
81112c30:	21367304 	addi	r4,r4,-9780
81112c34:	1121c7c0 	call	81121c7c <fwrite>
				#endif

				/* Clear Queue that is responsible to schedule the DMA access */
				error_codeCtrl = OSQFlush(xNfeeSchedule);
81112c38:	d0a05d17 	ldw	r2,-32396(gp)
81112c3c:	1009883a 	mov	r4,r2
81112c40:	113db600 	call	8113db60 <OSQFlush>
81112c44:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
81112c48:	e0bffe03 	ldbu	r2,-8(fp)
81112c4c:	10803fcc 	andi	r2,r2,255
81112c50:	10000126 	beq	r2,zero,81112c58 <vNFeeControlTask+0x14c>
					vFailFlushQueue();
81112c54:	111d68c0 	call	8111d68c <vFailFlushQueue>
				}

				/* Clear message that maybe is in the FEEs Queues */
				for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++)
81112c58:	e03ffa45 	stb	zero,-23(fp)
81112c5c:	00001006 	br	81112ca0 <vNFeeControlTask+0x194>
				{
					error_codeCtrl = OSQFlush( xFeeQ[ ucIL ] );
81112c60:	e0bffa43 	ldbu	r2,-23(fp)
81112c64:	1085883a 	add	r2,r2,r2
81112c68:	1087883a 	add	r3,r2,r2
81112c6c:	d0a06a04 	addi	r2,gp,-32344
81112c70:	1885883a 	add	r2,r3,r2
81112c74:	10800017 	ldw	r2,0(r2)
81112c78:	1009883a 	mov	r4,r2
81112c7c:	113db600 	call	8113db60 <OSQFlush>
81112c80:	e0bffe05 	stb	r2,-8(fp)
					if ( error_codeCtrl != OS_NO_ERR ) {
81112c84:	e0bffe03 	ldbu	r2,-8(fp)
81112c88:	10803fcc 	andi	r2,r2,255
81112c8c:	10000126 	beq	r2,zero,81112c94 <vNFeeControlTask+0x188>
						vFailFlushQueue();
81112c90:	111d68c0 	call	8111d68c <vFailFlushQueue>
				if ( error_codeCtrl != OS_NO_ERR ) {
					vFailFlushQueue();
				}

				/* Clear message that maybe is in the FEEs Queues */
				for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++)
81112c94:	e0bffa43 	ldbu	r2,-23(fp)
81112c98:	10800044 	addi	r2,r2,1
81112c9c:	e0bffa45 	stb	r2,-23(fp)
81112ca0:	e0bffa43 	ldbu	r2,-23(fp)
81112ca4:	103fee26 	beq	r2,zero,81112c60 <__reset+0xfb0f2c60>
					if ( error_codeCtrl != OS_NO_ERR ) {
						vFailFlushQueue();
					}
				}

				bCmdSent = FALSE;
81112ca8:	e03ffc15 	stw	zero,-16(fp)
				bDmaBack = TRUE;
81112cac:	00800044 	movi	r2,1
81112cb0:	d0a05815 	stw	r2,-32416(gp)
				ucWhoGetDMA = 255;
81112cb4:	00bfffc4 	movi	r2,-1
81112cb8:	d0a05905 	stb	r2,-32412(gp)
				pxFeeC->sMode = sMebRun;
81112cbc:	e0bffb17 	ldw	r2,-20(fp)
81112cc0:	00c00104 	movi	r3,4
81112cc4:	10c09a15 	stw	r3,616(r2)
				break;
81112cc8:	00008a06 	br	81112ef4 <vNFeeControlTask+0x3e8>


			case sMebConfig:
				
				uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 0, &error_codeCtrl); /* Blocking operation */
81112ccc:	d0a07017 	ldw	r2,-32320(gp)
81112cd0:	e0fffe04 	addi	r3,fp,-8
81112cd4:	180d883a 	mov	r6,r3
81112cd8:	000b883a 	mov	r5,zero
81112cdc:	1009883a 	mov	r4,r2
81112ce0:	113dc200 	call	8113dc20 <OSQPend>
81112ce4:	e0bffd15 	stw	r2,-12(fp)
				if ( error_codeCtrl == OS_ERR_NONE ) {
81112ce8:	e0bffe03 	ldbu	r2,-8(fp)
81112cec:	10803fcc 	andi	r2,r2,255
81112cf0:	10000c1e 	bne	r2,zero,81112d24 <vNFeeControlTask+0x218>

					/* Check if the command is for NFEE Controller */
					if ( uiCmdNFC.ucByte[3] == M_FEE_CTRL_ADDR ) {
81112cf4:	e0bffdc3 	ldbu	r2,-9(fp)
81112cf8:	10803fcc 	andi	r2,r2,255
81112cfc:	10800418 	cmpnei	r2,r2,16
81112d00:	1000041e 	bne	r2,zero,81112d14 <vNFeeControlTask+0x208>
						
						vPerformActionNFCConfig(uiCmdNFC.ulWord, pxFeeC);
81112d04:	e0bffd17 	ldw	r2,-12(fp)
81112d08:	e17ffb17 	ldw	r5,-20(fp)
81112d0c:	1009883a 	mov	r4,r2
81112d10:	1112ef80 	call	81112ef8 <vPerformActionNFCConfig>

					};
					bCmdSent = FALSE;
81112d14:	e03ffc15 	stw	zero,-16(fp)
					bDmaBack = TRUE;
81112d18:	00800044 	movi	r2,1
81112d1c:	d0a05815 	stw	r2,-32416(gp)
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetQueueMaskNfeeCtrl();
				}
				break;
81112d20:	00007406 	br	81112ef4 <vNFeeControlTask+0x3e8>
					};
					bCmdSent = FALSE;
					bDmaBack = TRUE;
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetQueueMaskNfeeCtrl();
81112d24:	111d2e00 	call	8111d2e0 <vCouldNotGetQueueMaskNfeeCtrl>
				}
				break;
81112d28:	00007206 	br	81112ef4 <vNFeeControlTask+0x3e8>
					xQMaskFeeCtrl is How NFEE Controller receive Commands in a fat way and 
					xNfeeSchedule that has the schedule of access to the DMA (this has priority)*/
				

				/* Get the id of the FEE that wants DMA access */
				if ( bDmaBack == TRUE ) {
81112d2c:	d0a05817 	ldw	r2,-32416(gp)
81112d30:	10800058 	cmpnei	r2,r2,1
81112d34:	1000221e 	bne	r2,zero,81112dc0 <vNFeeControlTask+0x2b4>

					uiCmdNFC.ulWord = (unsigned int)OSQPend(xNfeeSchedule, 4, &error_codeCtrl);
81112d38:	d0a05d17 	ldw	r2,-32396(gp)
81112d3c:	e0fffe04 	addi	r3,fp,-8
81112d40:	180d883a 	mov	r6,r3
81112d44:	01400104 	movi	r5,4
81112d48:	1009883a 	mov	r4,r2
81112d4c:	113dc200 	call	8113dc20 <OSQPend>
81112d50:	e0bffd15 	stw	r2,-12(fp)
					if ( error_codeCtrl == OS_ERR_NONE ) {
81112d54:	e0bffe03 	ldbu	r2,-8(fp)
81112d58:	10803fcc 	andi	r2,r2,255
81112d5c:	1000181e 	bne	r2,zero,81112dc0 <vNFeeControlTask+0x2b4>
						ucFeeInstL = uiCmdNFC.ucByte[0];
81112d60:	e0bffd03 	ldbu	r2,-12(fp)
81112d64:	e0bffa05 	stb	r2,-24(fp)


						if (  pxFeeC->xNfee[ucFeeInstL].xControl.bUsingDMA == TRUE ) {
81112d68:	e0bffa03 	ldbu	r2,-24(fp)
81112d6c:	e0fffb17 	ldw	r3,-20(fp)
81112d70:	10809624 	muli	r2,r2,600
81112d74:	1885883a 	add	r2,r3,r2
81112d78:	10802304 	addi	r2,r2,140
81112d7c:	10800017 	ldw	r2,0(r2)
81112d80:	10800058 	cmpnei	r2,r2,1
81112d84:	10000e1e 	bne	r2,zero,81112dc0 <vNFeeControlTask+0x2b4>
							bCmdSent = bSendCmdQToNFeeInst( ucFeeInstL, M_FEE_DMA_ACCESS, 0, ucFeeInstL );
81112d88:	e0bffa03 	ldbu	r2,-24(fp)
81112d8c:	e0fffa03 	ldbu	r3,-24(fp)
81112d90:	180f883a 	mov	r7,r3
81112d94:	000d883a 	mov	r6,zero
81112d98:	014023c4 	movi	r5,143
81112d9c:	1009883a 	mov	r4,r2
81112da0:	11130e80 	call	811130e8 <bSendCmdQToNFeeInst>
81112da4:	e0bffc15 	stw	r2,-16(fp)
							if ( bCmdSent == TRUE ) {
81112da8:	e0bffc17 	ldw	r2,-16(fp)
81112dac:	10800058 	cmpnei	r2,r2,1
81112db0:	1000031e 	bne	r2,zero,81112dc0 <vNFeeControlTask+0x2b4>
								bDmaBack = FALSE;
81112db4:	d0205815 	stw	zero,-32416(gp)
								ucWhoGetDMA = ucFeeInstL;
81112db8:	e0bffa03 	ldbu	r2,-24(fp)
81112dbc:	d0a05905 	stb	r2,-32412(gp)
							}
						}
					}
				} 

				if ( bDmaBack == FALSE ) {
81112dc0:	d0a05817 	ldw	r2,-32416(gp)
81112dc4:	1000081e 	bne	r2,zero,81112de8 <vNFeeControlTask+0x2dc>

					/* DMA with some NFEE instance */
					uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 0, &error_codeCtrl);
81112dc8:	d0a07017 	ldw	r2,-32320(gp)
81112dcc:	e0fffe04 	addi	r3,fp,-8
81112dd0:	180d883a 	mov	r6,r3
81112dd4:	000b883a 	mov	r5,zero
81112dd8:	1009883a 	mov	r4,r2
81112ddc:	113dc200 	call	8113dc20 <OSQPend>
81112de0:	e0bffd15 	stw	r2,-12(fp)
81112de4:	00000706 	br	81112e04 <vNFeeControlTask+0x2f8>
				} else {
					/* If No FEE has the DMA */

					uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 4, &error_codeCtrl);
81112de8:	d0a07017 	ldw	r2,-32320(gp)
81112dec:	e0fffe04 	addi	r3,fp,-8
81112df0:	180d883a 	mov	r6,r3
81112df4:	01400104 	movi	r5,4
81112df8:	1009883a 	mov	r4,r2
81112dfc:	113dc200 	call	8113dc20 <OSQPend>
81112e00:	e0bffd15 	stw	r2,-12(fp)
				}

				if ( error_codeCtrl == OS_ERR_NONE ){
81112e04:	e0bffe03 	ldbu	r2,-8(fp)
81112e08:	10803fcc 	andi	r2,r2,255
81112e0c:	1000381e 	bne	r2,zero,81112ef0 <vNFeeControlTask+0x3e4>
					/* Check if is some FEE giving the DMA back */
					if ( uiCmdNFC.ucByte[2] == M_NFC_DMA_GIVEBACK ) {
81112e10:	e0bffd83 	ldbu	r2,-10(fp)
81112e14:	10803fcc 	andi	r2,r2,255
81112e18:	10802058 	cmpnei	r2,r2,129
81112e1c:	1000091e 	bne	r2,zero,81112e44 <vNFeeControlTask+0x338>
						if ( uiCmdNFC.ucByte[0] == ucFeeInstL ){
81112e20:	e0bffd03 	ldbu	r2,-12(fp)
81112e24:	10c03fcc 	andi	r3,r2,255
81112e28:	e0bffa03 	ldbu	r2,-24(fp)
81112e2c:	1880301e 	bne	r3,r2,81112ef0 <vNFeeControlTask+0x3e4>
							bDmaBack = TRUE;
81112e30:	00800044 	movi	r2,1
81112e34:	d0a05815 	stw	r2,-32416(gp)
							ucFeeInstL = 255;
81112e38:	00bfffc4 	movi	r2,-1
81112e3c:	e0bffa05 	stb	r2,-24(fp)
				}
				//if ( xDefaults.usiDelay == 0 ) {
				//	OSTimeDlyHMSM(0,0,0,xDefaults.usiDelay); /*remover depois dos testes !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
				//}
				
				break;		
81112e40:	00002b06 	br	81112ef0 <vNFeeControlTask+0x3e4>
						}

					} else {

						/* Check if the command is for NFEE Controller */
						if ( uiCmdNFC.ucByte[3] == M_FEE_CTRL_ADDR ) {
81112e44:	e0bffdc3 	ldbu	r2,-9(fp)
81112e48:	10803fcc 	andi	r2,r2,255
81112e4c:	10800418 	cmpnei	r2,r2,16
81112e50:	1000051e 	bne	r2,zero,81112e68 <vNFeeControlTask+0x35c>
							
							vPerformActionNFCRunning(uiCmdNFC.ulWord, pxFeeC);
81112e54:	e0bffd17 	ldw	r2,-12(fp)
81112e58:	e17ffb17 	ldw	r5,-20(fp)
81112e5c:	1009883a 	mov	r4,r2
81112e60:	1112fc00 	call	81112fc0 <vPerformActionNFCRunning>
				}
				//if ( xDefaults.usiDelay == 0 ) {
				//	OSTimeDlyHMSM(0,0,0,xDefaults.usiDelay); /*remover depois dos testes !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
				//}
				
				break;		
81112e64:	00002206 	br	81112ef0 <vNFeeControlTask+0x3e4>
							
							vPerformActionNFCRunning(uiCmdNFC.ulWord, pxFeeC);

						} else {
							/* Check if the message if for any one of the instances of NFEE */
							if ( (uiCmdNFC.ucByte[3] >= M_NFEE_BASE_ADDR) && ( uiCmdNFC.ucByte[3] <= (M_NFEE_BASE_ADDR+N_OF_NFEE) ) ) {
81112e68:	e0bffdc3 	ldbu	r2,-9(fp)
81112e6c:	10803fcc 	andi	r2,r2,255
81112e70:	10800470 	cmpltui	r2,r2,17
81112e74:	10001e1e 	bne	r2,zero,81112ef0 <vNFeeControlTask+0x3e4>
81112e78:	e0bffdc3 	ldbu	r2,-9(fp)
81112e7c:	10803fcc 	andi	r2,r2,255
81112e80:	108004e8 	cmpgeui	r2,r2,19
81112e84:	10001a1e 	bne	r2,zero,81112ef0 <vNFeeControlTask+0x3e4>

								//todo: tratar retorno
								bSendCmdQToNFeeInst( (uiCmdNFC.ucByte[3]-M_NFEE_BASE_ADDR), uiCmdNFC.ucByte[2], uiCmdNFC.ucByte[1], uiCmdNFC.ucByte[0] );
81112e88:	e0bffdc3 	ldbu	r2,-9(fp)
81112e8c:	10bffbc4 	addi	r2,r2,-17
81112e90:	10803fcc 	andi	r2,r2,255
81112e94:	e0fffd83 	ldbu	r3,-10(fp)
81112e98:	18c03fcc 	andi	r3,r3,255
81112e9c:	e13ffd43 	ldbu	r4,-11(fp)
81112ea0:	21003fcc 	andi	r4,r4,255
81112ea4:	e17ffd03 	ldbu	r5,-12(fp)
81112ea8:	29403fcc 	andi	r5,r5,255
81112eac:	280f883a 	mov	r7,r5
81112eb0:	200d883a 	mov	r6,r4
81112eb4:	180b883a 	mov	r5,r3
81112eb8:	1009883a 	mov	r4,r2
81112ebc:	11130e80 	call	811130e8 <bSendCmdQToNFeeInst>
				}
				//if ( xDefaults.usiDelay == 0 ) {
				//	OSTimeDlyHMSM(0,0,0,xDefaults.usiDelay); /*remover depois dos testes !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
				//}
				
				break;		
81112ec0:	00000b06 	br	81112ef0 <vNFeeControlTask+0x3e4>
			default:
				#ifdef DEBUG_ON
					debug(fp,"NFEE Controller Task: Unknown state, backing to Config Mode.\n");
81112ec4:	d0a06217 	ldw	r2,-32376(gp)
81112ec8:	100f883a 	mov	r7,r2
81112ecc:	01800f44 	movi	r6,61
81112ed0:	01400044 	movi	r5,1
81112ed4:	01204574 	movhi	r4,33045
81112ed8:	21367c04 	addi	r4,r4,-9744
81112edc:	1121c7c0 	call	81121c7c <fwrite>
				#endif
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxFeeC->sMode = sMebConfig;
81112ee0:	e0bffb17 	ldw	r2,-20(fp)
81112ee4:	00c000c4 	movi	r3,3
81112ee8:	10c09a15 	stw	r3,616(r2)
				break;
81112eec:	00000106 	br	81112ef4 <vNFeeControlTask+0x3e8>
				}
				//if ( xDefaults.usiDelay == 0 ) {
				//	OSTimeDlyHMSM(0,0,0,xDefaults.usiDelay); /*remover depois dos testes !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
				//}
				
				break;		
81112ef0:	0001883a 	nop
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxFeeC->sMode = sMebConfig;
				break;
		}
	}
81112ef4:	003f1506 	br	81112b4c <__reset+0xfb0f2b4c>

81112ef8 <vPerformActionNFCConfig>:
}


void vPerformActionNFCConfig( unsigned int uiCmdParam, TNFee_Control *pxFeeCP ) {
81112ef8:	defffb04 	addi	sp,sp,-20
81112efc:	de00012e 	bgeu	sp,et,81112f04 <vPerformActionNFCConfig+0xc>
81112f00:	003b68fa 	trap	3
81112f04:	dfc00415 	stw	ra,16(sp)
81112f08:	df000315 	stw	fp,12(sp)
81112f0c:	df000304 	addi	fp,sp,12
81112f10:	e13ffe15 	stw	r4,-8(fp)
81112f14:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdLocal;
	INT8U errorCodeL;
	unsigned char i;

	uiCmdLocal.ulWord = uiCmdParam;
81112f18:	e0bffe17 	ldw	r2,-8(fp)
81112f1c:	e0bffd15 	stw	r2,-12(fp)

	switch (uiCmdLocal.ucByte[2]) {
81112f20:	e0bffd83 	ldbu	r2,-10(fp)
81112f24:	10803fcc 	andi	r2,r2,255
81112f28:	10c000a0 	cmpeqi	r3,r2,2
81112f2c:	1800121e 	bne	r3,zero,81112f78 <vPerformActionNFCConfig+0x80>
81112f30:	10c000c8 	cmpgei	r3,r2,3
81112f34:	1800031e 	bne	r3,zero,81112f44 <vPerformActionNFCConfig+0x4c>
81112f38:	10800060 	cmpeqi	r2,r2,1
81112f3c:	1000061e 	bne	r2,zero,81112f58 <vPerformActionNFCConfig+0x60>
81112f40:	00001106 	br	81112f88 <vPerformActionNFCConfig+0x90>
81112f44:	10c02860 	cmpeqi	r3,r2,161
81112f48:	1800031e 	bne	r3,zero,81112f58 <vPerformActionNFCConfig+0x60>
81112f4c:	108028a0 	cmpeqi	r2,r2,162
81112f50:	1000091e 	bne	r2,zero,81112f78 <vPerformActionNFCConfig+0x80>
81112f54:	00000c06 	br	81112f88 <vPerformActionNFCConfig+0x90>
		case M_NFC_CONFIG_FORCED:
		case M_NFC_CONFIG:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: NFC already in the Config Mode\n");
81112f58:	d0a06217 	ldw	r2,-32376(gp)
81112f5c:	100f883a 	mov	r7,r2
81112f60:	01800d44 	movi	r6,53
81112f64:	01400044 	movi	r5,1
81112f68:	01204574 	movhi	r4,33045
81112f6c:	21368c04 	addi	r4,r4,-9680
81112f70:	1121c7c0 	call	81121c7c <fwrite>
			#endif
			/* Do nothing for now */
			break;
81112f74:	00000c06 	br	81112fa8 <vPerformActionNFCConfig+0xb0>

		case M_NFC_RUN_FORCED:
		case M_NFC_RUN:
			pxFeeCP->sMode = sMebToRun;
81112f78:	e0bfff17 	ldw	r2,-4(fp)
81112f7c:	00c00084 	movi	r3,2
81112f80:	10c09a15 	stw	r3,616(r2)
			break;
81112f84:	00000806 	br	81112fa8 <vPerformActionNFCConfig+0xb0>
		case M_NFC_DMA_GIVEBACK:
		case M_NFC_DMA_REQUEST:

		default:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
81112f88:	d0a06217 	ldw	r2,-32376(gp)
81112f8c:	100f883a 	mov	r7,r2
81112f90:	018009c4 	movi	r6,39
81112f94:	01400044 	movi	r5,1
81112f98:	01204574 	movhi	r4,33045
81112f9c:	21369a04 	addi	r4,r4,-9624
81112fa0:	1121c7c0 	call	81121c7c <fwrite>
			#endif	
			break;
81112fa4:	0001883a 	nop
	}

}
81112fa8:	0001883a 	nop
81112fac:	e037883a 	mov	sp,fp
81112fb0:	dfc00117 	ldw	ra,4(sp)
81112fb4:	df000017 	ldw	fp,0(sp)
81112fb8:	dec00204 	addi	sp,sp,8
81112fbc:	f800283a 	ret

81112fc0 <vPerformActionNFCRunning>:

void vPerformActionNFCRunning( unsigned int uiCmdParam, TNFee_Control *pxFeeCP ) {
81112fc0:	defffa04 	addi	sp,sp,-24
81112fc4:	de00012e 	bgeu	sp,et,81112fcc <vPerformActionNFCRunning+0xc>
81112fc8:	003b68fa 	trap	3
81112fcc:	dfc00515 	stw	ra,20(sp)
81112fd0:	df000415 	stw	fp,16(sp)
81112fd4:	df000404 	addi	fp,sp,16
81112fd8:	e13ffe15 	stw	r4,-8(fp)
81112fdc:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdLocal;
	unsigned char i;

	uiCmdLocal.ulWord = uiCmdParam;
81112fe0:	e0bffe17 	ldw	r2,-8(fp)
81112fe4:	e0bffd15 	stw	r2,-12(fp)

	switch (uiCmdLocal.ucByte[2]) {
81112fe8:	e0bffd83 	ldbu	r2,-10(fp)
81112fec:	10803fcc 	andi	r2,r2,255
81112ff0:	10c02088 	cmpgei	r3,r2,130
81112ff4:	1800071e 	bne	r3,zero,81113014 <vPerformActionNFCRunning+0x54>
81112ff8:	10c02008 	cmpgei	r3,r2,128
81112ffc:	1800331e 	bne	r3,zero,811130cc <vPerformActionNFCRunning+0x10c>
81113000:	10c00060 	cmpeqi	r3,r2,1
81113004:	1800051e 	bne	r3,zero,8111301c <vPerformActionNFCRunning+0x5c>
81113008:	108000a0 	cmpeqi	r2,r2,2
8111300c:	10001f1e 	bne	r2,zero,8111308c <vPerformActionNFCRunning+0xcc>
81113010:	00002606 	br	811130ac <vPerformActionNFCRunning+0xec>
81113014:	10802860 	cmpeqi	r2,r2,161
81113018:	10002426 	beq	r2,zero,811130ac <vPerformActionNFCRunning+0xec>
		case M_NFC_CONFIG:
		case M_NFC_CONFIG_FORCED:

			pxFeeCP->sMode = sMebToConfig;
8111301c:	e0bfff17 	ldw	r2,-4(fp)
81113020:	00c00044 	movi	r3,1
81113024:	10c09a15 	stw	r3,616(r2)

			/* Change all NFEEs to Config mode */
			for( i = 0; i < N_OF_NFEE; i++)
81113028:	e03ffc05 	stb	zero,-16(fp)
8111302c:	00001406 	br	81113080 <vPerformActionNFCRunning+0xc0>
			{
				if ( (*pxFeeCP->pbEnabledNFEEs[i]) == TRUE ) {
81113030:	e0bffc03 	ldbu	r2,-16(fp)
81113034:	e0ffff17 	ldw	r3,-4(fp)
81113038:	108025c4 	addi	r2,r2,151
8111303c:	1085883a 	add	r2,r2,r2
81113040:	1085883a 	add	r2,r2,r2
81113044:	1885883a 	add	r2,r3,r2
81113048:	10800017 	ldw	r2,0(r2)
8111304c:	10800017 	ldw	r2,0(r2)
81113050:	10800058 	cmpnei	r2,r2,1
81113054:	1000071e 	bne	r2,zero,81113074 <vPerformActionNFCRunning+0xb4>
					bSendCmdQToNFeeInst_Prio( i, M_FEE_CONFIG_FORCED, 0, i  );
81113058:	e0bffc03 	ldbu	r2,-16(fp)
8111305c:	e0fffc03 	ldbu	r3,-16(fp)
81113060:	180f883a 	mov	r7,r3
81113064:	000d883a 	mov	r6,zero
81113068:	01402844 	movi	r5,161
8111306c:	1009883a 	mov	r4,r2
81113070:	11131b00 	call	811131b0 <bSendCmdQToNFeeInst_Prio>
		case M_NFC_CONFIG_FORCED:

			pxFeeCP->sMode = sMebToConfig;

			/* Change all NFEEs to Config mode */
			for( i = 0; i < N_OF_NFEE; i++)
81113074:	e0bffc03 	ldbu	r2,-16(fp)
81113078:	10800044 	addi	r2,r2,1
8111307c:	e0bffc05 	stb	r2,-16(fp)
81113080:	e0bffc03 	ldbu	r2,-16(fp)
81113084:	103fea26 	beq	r2,zero,81113030 <__reset+0xfb0f3030>
				if ( (*pxFeeCP->pbEnabledNFEEs[i]) == TRUE ) {
					bSendCmdQToNFeeInst_Prio( i, M_FEE_CONFIG_FORCED, 0, i  );
				}
			}

			break;
81113088:	00001106 	br	811130d0 <vPerformActionNFCRunning+0x110>
		case M_NFC_RUN:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: NFC already in the Running Mode\n");
8111308c:	d0a06217 	ldw	r2,-32376(gp)
81113090:	100f883a 	mov	r7,r2
81113094:	01800d84 	movi	r6,54
81113098:	01400044 	movi	r5,1
8111309c:	01204574 	movhi	r4,33045
811130a0:	2136a404 	addi	r4,r4,-9584
811130a4:	1121c7c0 	call	81121c7c <fwrite>
			#endif		
			/* Do nothing for now */

			break;
811130a8:	00000906 	br	811130d0 <vPerformActionNFCRunning+0x110>
		case M_NFC_DMA_GIVEBACK:
		case M_NFC_DMA_REQUEST:
			break;
		default:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
811130ac:	d0a06217 	ldw	r2,-32376(gp)
811130b0:	100f883a 	mov	r7,r2
811130b4:	018009c4 	movi	r6,39
811130b8:	01400044 	movi	r5,1
811130bc:	01204574 	movhi	r4,33045
811130c0:	21369a04 	addi	r4,r4,-9624
811130c4:	1121c7c0 	call	81121c7c <fwrite>
			#endif	
			break;
811130c8:	00000106 	br	811130d0 <vPerformActionNFCRunning+0x110>
			/* Do nothing for now */

			break;
		case M_NFC_DMA_GIVEBACK:
		case M_NFC_DMA_REQUEST:
			break;
811130cc:	0001883a 	nop
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
			#endif	
			break;
	}
}
811130d0:	0001883a 	nop
811130d4:	e037883a 	mov	sp,fp
811130d8:	dfc00117 	ldw	ra,4(sp)
811130dc:	df000017 	ldw	fp,0(sp)
811130e0:	dec00204 	addi	sp,sp,8
811130e4:	f800283a 	ret

811130e8 <bSendCmdQToNFeeInst>:


bool bSendCmdQToNFeeInst( unsigned char ucFeeInstP, unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
811130e8:	defff704 	addi	sp,sp,-36
811130ec:	de00012e 	bgeu	sp,et,811130f4 <bSendCmdQToNFeeInst+0xc>
811130f0:	003b68fa 	trap	3
811130f4:	dfc00815 	stw	ra,32(sp)
811130f8:	df000715 	stw	fp,28(sp)
811130fc:	df000704 	addi	fp,sp,28
81113100:	2011883a 	mov	r8,r4
81113104:	2809883a 	mov	r4,r5
81113108:	3007883a 	mov	r3,r6
8111310c:	3805883a 	mov	r2,r7
81113110:	e23ffc05 	stb	r8,-16(fp)
81113114:	e13ffd05 	stb	r4,-12(fp)
81113118:	e0fffe05 	stb	r3,-8(fp)
8111311c:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucFeeInstP;
81113120:	e0bffc03 	ldbu	r2,-16(fp)
81113124:	10800444 	addi	r2,r2,17
81113128:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
8111312c:	e0bffd03 	ldbu	r2,-12(fp)
81113130:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81113134:	e0bffe03 	ldbu	r2,-8(fp)
81113138:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
8111313c:	e0bfff03 	ldbu	r2,-4(fp)
81113140:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
81113144:	e03ff915 	stw	zero,-28(fp)
	error_codel = OSQPost(xFeeQ[ ucFeeInstP ], (void *)uiCmdtoSend.ulWord);
81113148:	e0bffc03 	ldbu	r2,-16(fp)
8111314c:	1085883a 	add	r2,r2,r2
81113150:	1087883a 	add	r3,r2,r2
81113154:	d0a06a04 	addi	r2,gp,-32344
81113158:	1885883a 	add	r2,r3,r2
8111315c:	10800017 	ldw	r2,0(r2)
81113160:	e0fffb17 	ldw	r3,-20(fp)
81113164:	180b883a 	mov	r5,r3
81113168:	1009883a 	mov	r4,r2
8111316c:	113e0280 	call	8113e028 <OSQPost>
81113170:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
81113174:	e0bffa03 	ldbu	r2,-24(fp)
81113178:	10000526 	beq	r2,zero,81113190 <bSendCmdQToNFeeInst+0xa8>
		vFailSendMsgAccessDMA( ucFeeInstP );
8111317c:	e0bffc03 	ldbu	r2,-16(fp)
81113180:	1009883a 	mov	r4,r2
81113184:	111d3b00 	call	8111d3b0 <vFailSendMsgAccessDMA>
		bSuccesL = FALSE;
81113188:	e03ff915 	stw	zero,-28(fp)
8111318c:	00000206 	br	81113198 <bSendCmdQToNFeeInst+0xb0>
	} else {
		bSuccesL =  TRUE;
81113190:	00800044 	movi	r2,1
81113194:	e0bff915 	stw	r2,-28(fp)
	}

	return bSuccesL;
81113198:	e0bff917 	ldw	r2,-28(fp)
}
8111319c:	e037883a 	mov	sp,fp
811131a0:	dfc00117 	ldw	ra,4(sp)
811131a4:	df000017 	ldw	fp,0(sp)
811131a8:	dec00204 	addi	sp,sp,8
811131ac:	f800283a 	ret

811131b0 <bSendCmdQToNFeeInst_Prio>:


bool bSendCmdQToNFeeInst_Prio( unsigned char ucFeeInstP, unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
811131b0:	defff704 	addi	sp,sp,-36
811131b4:	de00012e 	bgeu	sp,et,811131bc <bSendCmdQToNFeeInst_Prio+0xc>
811131b8:	003b68fa 	trap	3
811131bc:	dfc00815 	stw	ra,32(sp)
811131c0:	df000715 	stw	fp,28(sp)
811131c4:	df000704 	addi	fp,sp,28
811131c8:	2011883a 	mov	r8,r4
811131cc:	2809883a 	mov	r4,r5
811131d0:	3007883a 	mov	r3,r6
811131d4:	3805883a 	mov	r2,r7
811131d8:	e23ffc05 	stb	r8,-16(fp)
811131dc:	e13ffd05 	stb	r4,-12(fp)
811131e0:	e0fffe05 	stb	r3,-8(fp)
811131e4:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucFeeInstP;
811131e8:	e0bffc03 	ldbu	r2,-16(fp)
811131ec:	10800444 	addi	r2,r2,17
811131f0:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
811131f4:	e0bffd03 	ldbu	r2,-12(fp)
811131f8:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
811131fc:	e0bffe03 	ldbu	r2,-8(fp)
81113200:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81113204:	e0bfff03 	ldbu	r2,-4(fp)
81113208:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
8111320c:	e03ff915 	stw	zero,-28(fp)
	error_codel = OSQPostFront(xFeeQ[ ucFeeInstP ], (void *)uiCmdtoSend.ulWord);
81113210:	e0bffc03 	ldbu	r2,-16(fp)
81113214:	1085883a 	add	r2,r2,r2
81113218:	1087883a 	add	r3,r2,r2
8111321c:	d0a06a04 	addi	r2,gp,-32344
81113220:	1885883a 	add	r2,r3,r2
81113224:	10800017 	ldw	r2,0(r2)
81113228:	e0fffb17 	ldw	r3,-20(fp)
8111322c:	180b883a 	mov	r5,r3
81113230:	1009883a 	mov	r4,r2
81113234:	113e1980 	call	8113e198 <OSQPostFront>
81113238:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
8111323c:	e0bffa03 	ldbu	r2,-24(fp)
81113240:	10000526 	beq	r2,zero,81113258 <bSendCmdQToNFeeInst_Prio+0xa8>
		vFailSendMsgAccessDMA( ucFeeInstP );
81113244:	e0bffc03 	ldbu	r2,-16(fp)
81113248:	1009883a 	mov	r4,r2
8111324c:	111d3b00 	call	8111d3b0 <vFailSendMsgAccessDMA>
		bSuccesL = FALSE;
81113250:	e03ff915 	stw	zero,-28(fp)
81113254:	00000206 	br	81113260 <bSendCmdQToNFeeInst_Prio+0xb0>
	} else {
		bSuccesL =  TRUE;
81113258:	00800044 	movi	r2,1
8111325c:	e0bff915 	stw	r2,-28(fp)
	}

	return bSuccesL;
81113260:	e0bff917 	ldw	r2,-28(fp)
}
81113264:	e037883a 	mov	sp,fp
81113268:	dfc00117 	ldw	ra,4(sp)
8111326c:	df000017 	ldw	fp,0(sp)
81113270:	dec00204 	addi	sp,sp,8
81113274:	f800283a 	ret

81113278 <vOutAckHandlerTask>:
 */

#include "out_ack_handler_task.h"


void vOutAckHandlerTask(void *task_data) {
81113278:	defff704 	addi	sp,sp,-36
8111327c:	de00012e 	bgeu	sp,et,81113284 <vOutAckHandlerTask+0xc>
81113280:	003b68fa 	trap	3
81113284:	dfc00815 	stw	ra,32(sp)
81113288:	df000715 	stw	fp,28(sp)
8111328c:	df000704 	addi	fp,sp,28
81113290:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;
	tSerderACKState eSenderAckState;
	static txSenderACKs xSAckLocal;
    char cBufferAck[16] = "";
81113294:	e03ffac5 	stb	zero,-21(fp)
81113298:	e03ffb05 	stb	zero,-20(fp)
8111329c:	e03ffb45 	stb	zero,-19(fp)
811132a0:	e03ffb85 	stb	zero,-18(fp)
811132a4:	e03ffbc5 	stb	zero,-17(fp)
811132a8:	e03ffc05 	stb	zero,-16(fp)
811132ac:	e03ffc45 	stb	zero,-15(fp)
811132b0:	e03ffc85 	stb	zero,-14(fp)
811132b4:	e03ffcc5 	stb	zero,-13(fp)
811132b8:	e03ffd05 	stb	zero,-12(fp)
811132bc:	e03ffd45 	stb	zero,-11(fp)
811132c0:	e03ffd85 	stb	zero,-10(fp)
811132c4:	e03ffdc5 	stb	zero,-9(fp)
811132c8:	e03ffe05 	stb	zero,-8(fp)
811132cc:	e03ffe45 	stb	zero,-7(fp)
811132d0:	e03ffe85 	stb	zero,-6(fp)
    unsigned char crc = 0;
811132d4:	e03ffa45 	stb	zero,-23(fp)

	#ifdef DEBUG_ON
		debug(fp,"Out Ack Handler Task. (Task on)\n");
811132d8:	d0a06217 	ldw	r2,-32376(gp)
811132dc:	100f883a 	mov	r7,r2
811132e0:	01800804 	movi	r6,32
811132e4:	01400044 	movi	r5,1
811132e8:	01204574 	movhi	r4,33045
811132ec:	2136b204 	addi	r4,r4,-9528
811132f0:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	eSenderAckState = sSAConfiguring;
811132f4:	e03ff915 	stw	zero,-28(fp)

	for(;;){

		switch (eSenderAckState) {
811132f8:	e0bff917 	ldw	r2,-28(fp)
811132fc:	10c00060 	cmpeqi	r3,r2,1
81113300:	1800071e 	bne	r3,zero,81113320 <vOutAckHandlerTask+0xa8>
81113304:	0080032e 	bgeu	zero,r2,81113314 <vOutAckHandlerTask+0x9c>
81113308:	108000a0 	cmpeqi	r2,r2,2
8111330c:	1000471e 	bne	r2,zero,8111342c <vOutAckHandlerTask+0x1b4>
81113310:	00008c06 	br	81113544 <vOutAckHandlerTask+0x2cc>
			case sSAConfiguring:
                /*For future implementations*/
                eSenderAckState = sSAGettingACK;
81113314:	00800044 	movi	r2,1
81113318:	e0bff915 	stw	r2,-28(fp)
				break;
8111331c:	00009306 	br	8111356c <vOutAckHandlerTask+0x2f4>
            case sSAGettingACK:
                /* Waits the semaphore that indicates there are some ack message to send*/
                eSenderAckState = sSAGettingACK;
81113320:	00800044 	movi	r2,1
81113324:	e0bff915 	stw	r2,-28(fp)
                OSSemPend(xSemCountSenderACK, 0, &error_code);
81113328:	d0a06117 	ldw	r2,-32380(gp)
8111332c:	e0fffa84 	addi	r3,fp,-22
81113330:	180d883a 	mov	r6,r3
81113334:	000b883a 	mov	r5,zero
81113338:	1009883a 	mov	r4,r2
8111333c:	113eb180 	call	8113eb18 <OSSemPend>
                if ( error_code == OS_ERR_NONE ) {
81113340:	e0bffa83 	ldbu	r2,-22(fp)
81113344:	10803fcc 	andi	r2,r2,255
81113348:	1000361e 	bne	r2,zero,81113424 <vOutAckHandlerTask+0x1ac>

                    OSMutexPend(xMutexSenderACK, 0, &error_code);
8111334c:	d0a07217 	ldw	r2,-32312(gp)
81113350:	e0fffa84 	addi	r3,fp,-22
81113354:	180d883a 	mov	r6,r3
81113358:	000b883a 	mov	r5,zero
8111335c:	1009883a 	mov	r4,r2
81113360:	113cb0c0 	call	8113cb0c <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
81113364:	e0bffa83 	ldbu	r2,-22(fp)
81113368:	10803fcc 	andi	r2,r2,255
8111336c:	10002b1e 	bne	r2,zero,8111341c <vOutAckHandlerTask+0x1a4>
                        /*Search for the ack*/
                        for(unsigned char i = 0; i < N_ACKS_SENDER; i++)
81113370:	e03ffa05 	stb	zero,-24(fp)
81113374:	00002206 	br	81113400 <vOutAckHandlerTask+0x188>
                        {
                            if ( xSenderACK[i].cType != 0 ) {
81113378:	e0fffa03 	ldbu	r3,-24(fp)
8111337c:	00a045b4 	movhi	r2,33046
81113380:	109b5004 	addi	r2,r2,27968
81113384:	18c7883a 	add	r3,r3,r3
81113388:	18c7883a 	add	r3,r3,r3
8111338c:	10c5883a 	add	r2,r2,r3
81113390:	10800003 	ldbu	r2,0(r2)
81113394:	10803fcc 	andi	r2,r2,255
81113398:	1080201c 	xori	r2,r2,128
8111339c:	10bfe004 	addi	r2,r2,-128
811133a0:	10001426 	beq	r2,zero,811133f4 <vOutAckHandlerTask+0x17c>
                                /* Locate the message, copy for the local variable in order to free the mutex. */
                                xSAckLocal = xSenderACK[i];
811133a4:	e0fffa03 	ldbu	r3,-24(fp)
811133a8:	00a045b4 	movhi	r2,33046
811133ac:	109b5004 	addi	r2,r2,27968
811133b0:	18c7883a 	add	r3,r3,r3
811133b4:	18c7883a 	add	r3,r3,r3
811133b8:	10c5883a 	add	r2,r2,r3
811133bc:	10c0000b 	ldhu	r3,0(r2)
811133c0:	d0e0598d 	sth	r3,-32410(gp)
811133c4:	1080008b 	ldhu	r2,2(r2)
811133c8:	d0a05a0d 	sth	r2,-32408(gp)
                                eSenderAckState = sSASending;
811133cc:	00800084 	movi	r2,2
811133d0:	e0bff915 	stw	r2,-28(fp)
                                xSenderACK[i].cType = 0; /* indicates that this position now can be used by other message*/
811133d4:	e0fffa03 	ldbu	r3,-24(fp)
811133d8:	00a045b4 	movhi	r2,33046
811133dc:	109b5004 	addi	r2,r2,27968
811133e0:	18c7883a 	add	r3,r3,r3
811133e4:	18c7883a 	add	r3,r3,r3
811133e8:	10c5883a 	add	r2,r2,r3
811133ec:	10000005 	stb	zero,0(r2)
                                break;
811133f0:	00000606 	br	8111340c <vOutAckHandlerTask+0x194>
                if ( error_code == OS_ERR_NONE ) {

                    OSMutexPend(xMutexSenderACK, 0, &error_code);
                    if ( error_code == OS_ERR_NONE ) {
                        /*Search for the ack*/
                        for(unsigned char i = 0; i < N_ACKS_SENDER; i++)
811133f4:	e0bffa03 	ldbu	r2,-24(fp)
811133f8:	10800044 	addi	r2,r2,1
811133fc:	e0bffa05 	stb	r2,-24(fp)
81113400:	e0bffa03 	ldbu	r2,-24(fp)
81113404:	10800230 	cmpltui	r2,r2,8
81113408:	103fdb1e 	bne	r2,zero,81113378 <__reset+0xfb0f3378>
                                eSenderAckState = sSASending;
                                xSenderACK[i].cType = 0; /* indicates that this position now can be used by other message*/
                                break;
                            }
                        }
                        OSMutexPost(xMutexSenderACK);
8111340c:	d0a07217 	ldw	r2,-32312(gp)
81113410:	1009883a 	mov	r4,r2
81113414:	113d0b00 	call	8113d0b0 <OSMutexPost>
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
                }

                break;
81113418:	00005406 	br	8111356c <vOutAckHandlerTask+0x2f4>
                        }
                        OSMutexPost(xMutexSenderACK);
                    } else {
                        /*  Should never get here, will wait without timeout for the semaphore.
                            But if some error accours we will do nothing but print in the console */
                        vFailGetMutexSenderTask();
8111341c:	111bbc40 	call	8111bbc4 <vFailGetMutexSenderTask>
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
                }

                break;
81113420:	00005206 	br	8111356c <vOutAckHandlerTask+0x2f4>
                    }

                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
81113424:	111bb5c0 	call	8111bb5c <vFailGetCountSemaphoreSenderTask>
                }

                break;
81113428:	00005006 	br	8111356c <vOutAckHandlerTask+0x2f4>
			case sSASending:
                
                /* First check if is an NACK packet that should be sent */
                if ( xSAckLocal.cType != '#' ) {
8111342c:	d0a05983 	ldbu	r2,-32410(gp)
81113430:	10803fcc 	andi	r2,r2,255
81113434:	1080201c 	xori	r2,r2,128
81113438:	10bfe004 	addi	r2,r2,-128
8111343c:	108008e0 	cmpeqi	r2,r2,35
81113440:	1000201e 	bne	r2,zero,811134c4 <vOutAckHandlerTask+0x24c>
                    /* In this state has a parsed ack packet in the variable xSAckLocal
                    we just need to calc the crc8 and create the uart packet to send. */
                    sprintf(cBufferAck, ACK_SPRINTF, xSAckLocal.cCommand, xSAckLocal.usiId);
81113444:	d0a059c3 	ldbu	r2,-32409(gp)
81113448:	10c03fcc 	andi	r3,r2,255
8111344c:	18c0201c 	xori	r3,r3,128
81113450:	18ffe004 	addi	r3,r3,-128
81113454:	d0a05a0b 	ldhu	r2,-32408(gp)
81113458:	113fffcc 	andi	r4,r2,65535
8111345c:	e0bffac4 	addi	r2,fp,-21
81113460:	200f883a 	mov	r7,r4
81113464:	180d883a 	mov	r6,r3
81113468:	01604574 	movhi	r5,33045
8111346c:	2976bb04 	addi	r5,r5,-9492
81113470:	1009883a 	mov	r4,r2
81113474:	1122f700 	call	81122f70 <sprintf>
                    crc = ucCrc8wInit( cBufferAck , strlen(cBufferAck));
81113478:	e0bffac4 	addi	r2,fp,-21
8111347c:	1009883a 	mov	r4,r2
81113480:	11231840 	call	81123184 <strlen>
81113484:	1007883a 	mov	r3,r2
81113488:	e0bffac4 	addi	r2,fp,-21
8111348c:	180b883a 	mov	r5,r3
81113490:	1009883a 	mov	r4,r2
81113494:	111b7200 	call	8111b720 <ucCrc8wInit>
81113498:	e0bffa45 	stb	r2,-23(fp)
                    sprintf(cBufferAck, "%s|%hhu;", cBufferAck, crc);
8111349c:	e13ffa43 	ldbu	r4,-23(fp)
811134a0:	e0fffac4 	addi	r3,fp,-21
811134a4:	e0bffac4 	addi	r2,fp,-21
811134a8:	200f883a 	mov	r7,r4
811134ac:	180d883a 	mov	r6,r3
811134b0:	01604574 	movhi	r5,33045
811134b4:	2976bd04 	addi	r5,r5,-9484
811134b8:	1009883a 	mov	r4,r2
811134bc:	1122f700 	call	81122f70 <sprintf>
811134c0:	00000c06 	br	811134f4 <vOutAckHandlerTask+0x27c>
                } else {
                    /* Nack */
                    sprintf(cBufferAck, "%s", NACK_SEQUENCE);
811134c4:	e0bffac4 	addi	r2,fp,-21
811134c8:	00c008c4 	movi	r3,35
811134cc:	10c00005 	stb	r3,0(r2)
811134d0:	00c01f04 	movi	r3,124
811134d4:	10c00045 	stb	r3,1(r2)
811134d8:	00c00d44 	movi	r3,53
811134dc:	10c00085 	stb	r3,2(r2)
811134e0:	00c00d04 	movi	r3,52
811134e4:	10c000c5 	stb	r3,3(r2)
811134e8:	00c00ec4 	movi	r3,59
811134ec:	10c00105 	stb	r3,4(r2)
811134f0:	10000145 	stb	zero,5(r2)
                }


                OSMutexPend(xTxUARTMutex, 100, &error_code); /* Wait max 100 ticks = 100 ms */
811134f4:	d0a07417 	ldw	r2,-32304(gp)
811134f8:	e0fffa84 	addi	r3,fp,-22
811134fc:	180d883a 	mov	r6,r3
81113500:	01401904 	movi	r5,100
81113504:	1009883a 	mov	r4,r2
81113508:	113cb0c0 	call	8113cb0c <OSMutexPend>
                if ( error_code == OS_NO_ERR ) {
8111350c:	e0bffa83 	ldbu	r2,-22(fp)
81113510:	10803fcc 	andi	r2,r2,255
81113514:	1000071e 	bne	r2,zero,81113534 <vOutAckHandlerTask+0x2bc>
                    puts(cBufferAck);
81113518:	e0bffac4 	addi	r2,fp,-21
8111351c:	1009883a 	mov	r4,r2
81113520:	1122c2c0 	call	81122c2c <puts>
                    OSMutexPost(xTxUARTMutex);
81113524:	d0a07417 	ldw	r2,-32304(gp)
81113528:	1009883a 	mov	r4,r2
8111352c:	113d0b00 	call	8113d0b0 <OSMutexPost>
81113530:	00000106 	br	81113538 <vOutAckHandlerTask+0x2c0>
                } else
                    vFailGetMutexTxUARTSenderTask(); /* Could not use the uart tx buffer to send the ack*/
81113534:	111bcfc0 	call	8111bcfc <vFailGetMutexTxUARTSenderTask>

                eSenderAckState = sSAGettingACK;
81113538:	00800044 	movi	r2,1
8111353c:	e0bff915 	stw	r2,-28(fp)
                
				break;
81113540:	00000a06 	br	8111356c <vOutAckHandlerTask+0x2f4>
			default:
            	#ifdef DEBUG_ON
		            debug(fp,"Critical: Default State. Should never get here.(vOutAckHandlerTask)\n");
81113544:	d0a06217 	ldw	r2,-32376(gp)
81113548:	100f883a 	mov	r7,r2
8111354c:	01801104 	movi	r6,68
81113550:	01400044 	movi	r5,1
81113554:	01204574 	movhi	r4,33045
81113558:	2136c004 	addi	r4,r4,-9472
8111355c:	1121c7c0 	call	81121c7c <fwrite>
	            #endif
                eSenderAckState = sSAGettingACK;
81113560:	00800044 	movi	r2,1
81113564:	e0bff915 	stw	r2,-28(fp)
				break;
81113568:	0001883a 	nop
		}
	}
8111356c:	003f6206 	br	811132f8 <__reset+0xfb0f32f8>

81113570 <vParserCommTask>:


#include "parser_comm_task.h"


void vParserCommTask(void *task_data) {
81113570:	deffd704 	addi	sp,sp,-164
81113574:	de00012e 	bgeu	sp,et,8111357c <vParserCommTask+0xc>
81113578:	003b68fa 	trap	3
8111357c:	dfc02815 	stw	ra,160(sp)
81113580:	df002715 	stw	fp,156(sp)
81113584:	df002704 	addi	fp,sp,156
81113588:	e13fff15 	stw	r4,-4(fp)
	unsigned short int usiFeeInstL;
	bool bSuccess = FALSE;
8111358c:	e03fdd15 	stw	zero,-140(fp)
	#ifdef DEBUG_ON
		char cPUSDebug[128];
	#endif

    #ifdef DEBUG_ON
        debug(fp,"Parser Comm Task. (Task on)\n");
81113590:	d0a06217 	ldw	r2,-32376(gp)
81113594:	100f883a 	mov	r7,r2
81113598:	01800704 	movi	r6,28
8111359c:	01400044 	movi	r5,1
811135a0:	01204574 	movhi	r4,33045
811135a4:	2136d204 	addi	r4,r4,-9400
811135a8:	1121c7c0 	call	81121c7c <fwrite>
    #endif

	eParserMode = sConfiguring;
811135ac:	e03fdc15 	stw	zero,-144(fp)

	for(;;){

		switch (eParserMode) {
811135b0:	e0bfdc17 	ldw	r2,-144(fp)
811135b4:	10800168 	cmpgeui	r2,r2,5
811135b8:	1003651e 	bne	r2,zero,81114350 <vParserCommTask+0xde0>
811135bc:	e0bfdc17 	ldw	r2,-144(fp)
811135c0:	100690ba 	slli	r3,r2,2
811135c4:	00a04474 	movhi	r2,33041
811135c8:	108d7604 	addi	r2,r2,13784
811135cc:	1885883a 	add	r2,r3,r2
811135d0:	10800017 	ldw	r2,0(r2)
811135d4:	1000683a 	jmp	r2
811135d8:	811135ec 	andhi	r4,r16,17623
811135dc:	811135f8 	rdprs	r4,r16,17623
811135e0:	8111368c 	andi	r4,r16,17626
811135e4:	811137f0 	cmpltui	r4,r16,17631
811135e8:	81113834 	orhi	r4,r16,17632
			case sConfiguring:
				/*For future implementations*/
				eParserMode = sWaitingMessage;
811135ec:	00800044 	movi	r2,1
811135f0:	e0bfdc15 	stw	r2,-144(fp)
				break;
811135f4:	00035906 	br	8111435c <vParserCommTask+0xdec>
			case sWaitingMessage:

				bSuccess = FALSE;
811135f8:	e03fdd15 	stw	zero,-140(fp)
				eParserMode = sWaitingMessage;
811135fc:	00800044 	movi	r2,1
81113600:	e0bfdc15 	stw	r2,-144(fp)

				OSSemPend(xSemCountPreParsed, 0, &error_code); /*Blocking*/
81113604:	d0a06417 	ldw	r2,-32368(gp)
81113608:	e0ffde84 	addi	r3,fp,-134
8111360c:	180d883a 	mov	r6,r3
81113610:	000b883a 	mov	r5,zero
81113614:	1009883a 	mov	r4,r2
81113618:	113eb180 	call	8113eb18 <OSSemPend>
				if ( error_code == OS_ERR_NONE ) {
8111361c:	e0bfde83 	ldbu	r2,-134(fp)
81113620:	10803fcc 	andi	r2,r2,255
81113624:	1000171e 	bne	r2,zero,81113684 <vParserCommTask+0x114>
					/* There's command waiting to be threat */

					bSuccess = getPreParsedPacket(&PreParsedLocal); /*Blocking*/
81113628:	01204574 	movhi	r4,33045
8111362c:	210dc204 	addi	r4,r4,14088
81113630:	11143600 	call	81114360 <getPreParsedPacket>
81113634:	e0bfdd15 	stw	r2,-140(fp)
					if (bSuccess == TRUE) {
81113638:	e0bfdd17 	ldw	r2,-140(fp)
8111363c:	10800058 	cmpnei	r2,r2,1
81113640:	10000e1e 	bne	r2,zero,8111367c <vParserCommTask+0x10c>
						/* PreParsed Content copied to the local variable */
						if ( PreParsedLocal.cType == START_REPLY_CHAR )
81113644:	00a04574 	movhi	r2,33045
81113648:	108dc204 	addi	r2,r2,14088
8111364c:	10800103 	ldbu	r2,4(r2)
81113650:	10803fcc 	andi	r2,r2,255
81113654:	1080201c 	xori	r2,r2,128
81113658:	10bfe004 	addi	r2,r2,-128
8111365c:	10800858 	cmpnei	r2,r2,33
81113660:	1000031e 	bne	r2,zero,81113670 <vParserCommTask+0x100>
							eParserMode = sReplyParsing;
81113664:	008000c4 	movi	r2,3
81113668:	e0bfdc15 	stw	r2,-144(fp)
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
8111366c:	00033b06 	br	8111435c <vParserCommTask+0xdec>
					if (bSuccess == TRUE) {
						/* PreParsed Content copied to the local variable */
						if ( PreParsedLocal.cType == START_REPLY_CHAR )
							eParserMode = sReplyParsing;
						else
							eParserMode = sRequestParsing;
81113670:	00800084 	movi	r2,2
81113674:	e0bfdc15 	stw	r2,-144(fp)
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
81113678:	00033806 	br	8111435c <vParserCommTask+0xdec>
							eParserMode = sReplyParsing;
						else
							eParserMode = sRequestParsing;
					} else {
						/* Semaphore was post by some task but has no message in the PreParsedBuffer*/
						vNoContentInPreParsedBuffer();
8111367c:	111c2880 	call	8111c288 <vNoContentInPreParsedBuffer>
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
81113680:	00033606 	br	8111435c <vParserCommTask+0xdec>
						/* Semaphore was post by some task but has no message in the PreParsedBuffer*/
						vNoContentInPreParsedBuffer();
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
81113684:	111c1b80 	call	8111c1b8 <vFailGetCountSemaphorePreParsedBuffer>
				}
				break;
81113688:	00033406 	br	8111435c <vParserCommTask+0xdec>
			case sRequestParsing:
				/* Final parssing after identify that is a request packet */
				/* ATTENTION: In order to avoid overhead of process the response to NUC of simple Requests
				   will be threat here, and send from here the parser_rx.*/
			   	switch (PreParsedLocal.cCommand)
8111368c:	00a04574 	movhi	r2,33045
81113690:	108dc204 	addi	r2,r2,14088
81113694:	10800143 	ldbu	r2,5(r2)
81113698:	10803fcc 	andi	r2,r2,255
8111369c:	1080201c 	xori	r2,r2,128
811136a0:	10bfe004 	addi	r2,r2,-128
811136a4:	10c010e0 	cmpeqi	r3,r2,67
811136a8:	1800031e 	bne	r3,zero,811136b8 <vParserCommTask+0x148>
811136ac:	10801420 	cmpeqi	r2,r2,80
811136b0:	1000051e 	bne	r2,zero,811136c8 <vParserCommTask+0x158>
811136b4:	00004a06 	br	811137e0 <vParserCommTask+0x270>
				{
					case ETH_CMD: /*NUC requested the ETH Configuration*/
						vSendEthConf();
811136b8:	1118f1c0 	call	81118f1c <vSendEthConf>
						eParserMode = sWaitingMessage;
811136bc:	00800044 	movi	r2,1
811136c0:	e0bfdc15 	stw	r2,-144(fp)
						break;
811136c4:	00004906 	br	811137ec <vParserCommTask+0x27c>
                    case PUS_CMD: /*PUS command to MEB - TC*/

						#ifdef DEBUG_ON
							memset(cPUSDebug,0,128);
811136c8:	e0bfdec4 	addi	r2,fp,-133
811136cc:	01802004 	movi	r6,128
811136d0:	000b883a 	mov	r5,zero
811136d4:	1009883a 	mov	r4,r2
811136d8:	11227e00 	call	811227e0 <memset>
							sprintf(cPUSDebug, "\nParser Task: TC-> pid: %hu; pcat: %hu; srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", PreParsedLocal.usiValues[1], PreParsedLocal.usiValues[2], PreParsedLocal.usiValues[3], PreParsedLocal.usiValues[4], PreParsedLocal.usiValues[5]);
811136dc:	00a04574 	movhi	r2,33045
811136e0:	108dc204 	addi	r2,r2,14088
811136e4:	1080028b 	ldhu	r2,10(r2)
811136e8:	117fffcc 	andi	r5,r2,65535
811136ec:	00a04574 	movhi	r2,33045
811136f0:	108dc204 	addi	r2,r2,14088
811136f4:	1080030b 	ldhu	r2,12(r2)
811136f8:	11bfffcc 	andi	r6,r2,65535
811136fc:	00a04574 	movhi	r2,33045
81113700:	108dc204 	addi	r2,r2,14088
81113704:	1080038b 	ldhu	r2,14(r2)
81113708:	10ffffcc 	andi	r3,r2,65535
8111370c:	00a04574 	movhi	r2,33045
81113710:	108dc204 	addi	r2,r2,14088
81113714:	1080040b 	ldhu	r2,16(r2)
81113718:	113fffcc 	andi	r4,r2,65535
8111371c:	00a04574 	movhi	r2,33045
81113720:	108dc204 	addi	r2,r2,14088
81113724:	1080048b 	ldhu	r2,18(r2)
81113728:	10bfffcc 	andi	r2,r2,65535
8111372c:	e23fdec4 	addi	r8,fp,-133
81113730:	d8800215 	stw	r2,8(sp)
81113734:	d9000115 	stw	r4,4(sp)
81113738:	d8c00015 	stw	r3,0(sp)
8111373c:	300f883a 	mov	r7,r6
81113740:	280d883a 	mov	r6,r5
81113744:	01604574 	movhi	r5,33045
81113748:	2976da04 	addi	r5,r5,-9368
8111374c:	4009883a 	mov	r4,r8
81113750:	1122f700 	call	81122f70 <sprintf>
							debug(fp, cPUSDebug );
81113754:	d0a06217 	ldw	r2,-32376(gp)
81113758:	e0ffdec4 	addi	r3,fp,-133
8111375c:	180b883a 	mov	r5,r3
81113760:	1009883a 	mov	r4,r2
81113764:	11215e00 	call	811215e0 <fprintf>
						#endif
	
						xTcPusL.usiCat	= PreParsedLocal.usiValues[2];
81113768:	00a04574 	movhi	r2,33045
8111376c:	108dc204 	addi	r2,r2,14088
81113770:	10c0030b 	ldhu	r3,12(r2)
81113774:	00a04574 	movhi	r2,33045
81113778:	108dd504 	addi	r2,r2,14164
8111377c:	10c0028d 	sth	r3,10(r2)
						xTcPusL.usiType = PreParsedLocal.usiValues[3];
81113780:	00a04574 	movhi	r2,33045
81113784:	108dc204 	addi	r2,r2,14088
81113788:	10c0038b 	ldhu	r3,14(r2)
8111378c:	00a04574 	movhi	r2,33045
81113790:	108dd504 	addi	r2,r2,14164
81113794:	10c0030d 	sth	r3,12(r2)
						xTcPusL.usiSubType = PreParsedLocal.usiValues[4];
81113798:	00a04574 	movhi	r2,33045
8111379c:	108dc204 	addi	r2,r2,14088
811137a0:	10c0040b 	ldhu	r3,16(r2)
811137a4:	00a04574 	movhi	r2,33045
811137a8:	108dd504 	addi	r2,r2,14164
811137ac:	10c0038d 	sth	r3,14(r2)
						xTcPusL.usiPusId = PreParsedLocal.usiValues[5];
811137b0:	00a04574 	movhi	r2,33045
811137b4:	108dc204 	addi	r2,r2,14088
811137b8:	10c0048b 	ldhu	r3,18(r2)
811137bc:	00a04574 	movhi	r2,33045
811137c0:	108dd504 	addi	r2,r2,14164
811137c4:	10c0040d 	sth	r3,16(r2)
						xTcPusL.ucNofValues = 0; /* Don't assume that has values */
811137c8:	00a04574 	movhi	r2,33045
811137cc:	108dd504 	addi	r2,r2,14164
811137d0:	10000485 	stb	zero,18(r2)

						eParserMode = sPusHandling;
811137d4:	00800104 	movi	r2,4
811137d8:	e0bfdc15 	stw	r2,-144(fp)
                        break;						
811137dc:	00000306 	br	811137ec <vParserCommTask+0x27c>
					default:
						eParserMode = sWaitingMessage;
811137e0:	00800044 	movi	r2,1
811137e4:	e0bfdc15 	stw	r2,-144(fp)
						break;
811137e8:	0001883a 	nop
				}
				break;
811137ec:	0002db06 	br	8111435c <vParserCommTask+0xdec>
			case sReplyParsing:
				eParserMode = sWaitingMessage;
811137f0:	00800044 	movi	r2,1
811137f4:	e0bfdc15 	stw	r2,-144(fp)
                switch ( xTcPusL.usiType )
811137f8:	00a04574 	movhi	r2,33045
811137fc:	108dd504 	addi	r2,r2,14164
81113800:	1080030b 	ldhu	r2,12(r2)
81113804:	10bfffcc 	andi	r2,r2,65535
81113808:	10c01220 	cmpeqi	r3,r2,72
8111380c:	1800051e 	bne	r3,zero,81113824 <vParserCommTask+0x2b4>
81113810:	108014e0 	cmpeqi	r2,r2,83
81113814:	1000051e 	bne	r2,zero,8111382c <vParserCommTask+0x2bc>
                    case HEART_BEAT_CMD: /*Heart beating (NUC are you there?)*/

						
                        break;
                    default:
						eParserMode = sWaitingMessage;
81113818:	00800044 	movi	r2,1
8111381c:	e0bfdc15 	stw	r2,-144(fp)
                        break;
81113820:	00000306 	br	81113830 <vParserCommTask+0x2c0>
						
                        break;
                    case HEART_BEAT_CMD: /*Heart beating (NUC are you there?)*/

						
                        break;
81113824:	0001883a 	nop
81113828:	0002cc06 	br	8111435c <vParserCommTask+0xdec>
                switch ( xTcPusL.usiType )
                {
                    case NUC_STATUS_CMD: /*Status from NUC*/

						
                        break;
8111382c:	0001883a 	nop
                        break;
                    default:
						eParserMode = sWaitingMessage;
                        break;
                }
				break;
81113830:	0002ca06 	br	8111435c <vParserCommTask+0xdec>
			case sPusHandling:
				eParserMode = sWaitingMessage;
81113834:	00800044 	movi	r2,1
81113838:	e0bfdc15 	stw	r2,-144(fp)
				
                switch ( xTcPusL.usiType )
8111383c:	00a04574 	movhi	r2,33045
81113840:	108dd504 	addi	r2,r2,14164
81113844:	1080030b 	ldhu	r2,12(r2)
81113848:	10bfffcc 	andi	r2,r2,65535
8111384c:	10c03ea0 	cmpeqi	r3,r2,250
81113850:	1800401e 	bne	r3,zero,81113954 <vParserCommTask+0x3e4>
81113854:	10c03ec8 	cmpgei	r3,r2,251
81113858:	1800031e 	bne	r3,zero,81113868 <vParserCommTask+0x2f8>
8111385c:	10800460 	cmpeqi	r2,r2,17
81113860:	1000061e 	bne	r2,zero,8111387c <vParserCommTask+0x30c>
81113864:	0002b606 	br	81114340 <vParserCommTask+0xdd0>
81113868:	10c03ee0 	cmpeqi	r3,r2,251
8111386c:	18009d1e 	bne	r3,zero,81113ae4 <vParserCommTask+0x574>
81113870:	10803f20 	cmpeqi	r2,r2,252
81113874:	1001321e 	bne	r2,zero,81113d40 <vParserCommTask+0x7d0>
81113878:	0002b106 	br	81114340 <vParserCommTask+0xdd0>
                {
                    case 17: /* srv-Type = 17 */
						switch ( xTcPusL.usiSubType )
8111387c:	00a04574 	movhi	r2,33045
81113880:	108dd504 	addi	r2,r2,14164
81113884:	1080038b 	ldhu	r2,14(r2)
81113888:	10bfffcc 	andi	r2,r2,65535
8111388c:	10800060 	cmpeqi	r2,r2,1
81113890:	10000e26 	beq	r2,zero,811138cc <vParserCommTask+0x35c>
						{
							case 1: /* TC_SCAM_TEST_CONNECTION */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_TEST_CONNECTION\n");
81113894:	d0a06217 	ldw	r2,-32376(gp)
81113898:	100f883a 	mov	r7,r2
8111389c:	01800944 	movi	r6,37
811138a0:	01400044 	movi	r5,1
811138a4:	01204574 	movhi	r4,33045
811138a8:	2136f004 	addi	r4,r4,-9280
811138ac:	1121c7c0 	call	81121c7c <fwrite>
								#endif

								/* Reply with the TM os connection */
								vTMPusTestConnection( xTcPusL.usiPusId );
811138b0:	00a04574 	movhi	r2,33045
811138b4:	108dd504 	addi	r2,r2,14164
811138b8:	1080040b 	ldhu	r2,16(r2)
811138bc:	10bfffcc 	andi	r2,r2,65535
811138c0:	1009883a 	mov	r4,r2
811138c4:	111991c0 	call	8111991c <vTMPusTestConnection>

								break;
811138c8:	00002106 	br	81113950 <vParserCommTask+0x3e0>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
811138cc:	e0bfdec4 	addi	r2,fp,-133
811138d0:	01802004 	movi	r6,128
811138d4:	000b883a 	mov	r5,zero
811138d8:	1009883a 	mov	r4,r2
811138dc:	11227e00 	call	811227e0 <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
811138e0:	00a04574 	movhi	r2,33045
811138e4:	108dd504 	addi	r2,r2,14164
811138e8:	1080030b 	ldhu	r2,12(r2)
811138ec:	113fffcc 	andi	r4,r2,65535
811138f0:	00a04574 	movhi	r2,33045
811138f4:	108dd504 	addi	r2,r2,14164
811138f8:	1080038b 	ldhu	r2,14(r2)
811138fc:	117fffcc 	andi	r5,r2,65535
81113900:	00a04574 	movhi	r2,33045
81113904:	108dd504 	addi	r2,r2,14164
81113908:	1080040b 	ldhu	r2,16(r2)
8111390c:	10bfffcc 	andi	r2,r2,65535
81113910:	e0ffdec4 	addi	r3,fp,-133
81113914:	d8800015 	stw	r2,0(sp)
81113918:	280f883a 	mov	r7,r5
8111391c:	200d883a 	mov	r6,r4
81113920:	01604574 	movhi	r5,33045
81113924:	2976fa04 	addi	r5,r5,-9240
81113928:	1809883a 	mov	r4,r3
8111392c:	1122f700 	call	81122f70 <sprintf>
									debug(fp, cPUSDebug );
81113930:	d0a06217 	ldw	r2,-32376(gp)
81113934:	e0ffdec4 	addi	r3,fp,-133
81113938:	180b883a 	mov	r5,r3
8111393c:	1009883a 	mov	r4,r2
81113940:	11215e00 	call	811215e0 <fprintf>
								#endif
								eParserMode = sWaitingMessage;
81113944:	00800044 	movi	r2,1
81113948:	e0bfdc15 	stw	r2,-144(fp)
								break;
8111394c:	0001883a 	nop
						}
                        break;
81113950:	00027e06 	br	8111434c <vParserCommTask+0xddc>


                    case 250: /* srv-Type = 250 */
						switch ( xTcPusL.usiSubType )
81113954:	00a04574 	movhi	r2,33045
81113958:	108dd504 	addi	r2,r2,14164
8111395c:	1080038b 	ldhu	r2,14(r2)
81113960:	10bfffcc 	andi	r2,r2,65535
81113964:	10c00f20 	cmpeqi	r3,r2,60
81113968:	18001a1e 	bne	r3,zero,811139d4 <vParserCommTask+0x464>
8111396c:	10c00f48 	cmpgei	r3,r2,61
81113970:	1800031e 	bne	r3,zero,81113980 <vParserCommTask+0x410>
81113974:	10800ee0 	cmpeqi	r2,r2,59
81113978:	1000061e 	bne	r2,zero,81113994 <vParserCommTask+0x424>
8111397c:	00003706 	br	81113a5c <vParserCommTask+0x4ec>
81113980:	10c00f60 	cmpeqi	r3,r2,61
81113984:	18001e1e 	bne	r3,zero,81113a00 <vParserCommTask+0x490>
81113988:	10800fa0 	cmpeqi	r2,r2,62
8111398c:	1000271e 	bne	r2,zero,81113a2c <vParserCommTask+0x4bc>
81113990:	00003206 	br	81113a5c <vParserCommTask+0x4ec>
						{
							case 59: /* TC_SCAM_RESET */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_RESET\n");
81113994:	d0a06217 	ldw	r2,-32376(gp)
81113998:	100f883a 	mov	r7,r2
8111399c:	018006c4 	movi	r6,27
811139a0:	01400044 	movi	r5,1
811139a4:	01204574 	movhi	r4,33045
811139a8:	21370d04 	addi	r4,r4,-9164
811139ac:	1121c7c0 	call	81121c7c <fwrite>
								#endif
								vSendReset();
811139b0:	11192c40 	call	811192c4 <vSendReset>
								/*Just Reset the Simucam, what do with the NUC?*/
								OSTimeDlyHMSM(0,0,3,0);
811139b4:	000f883a 	mov	r7,zero
811139b8:	018000c4 	movi	r6,3
811139bc:	000b883a 	mov	r5,zero
811139c0:	0009883a 	mov	r4,zero
811139c4:	1140ab00 	call	81140ab0 <OSTimeDlyHMSM>
								vRstcSimucamReset( 5000 );
811139c8:	0104e204 	movi	r4,5000
811139cc:	110c3c40 	call	8110c3c4 <vRstcSimucamReset>

								break;
811139d0:	00004306 	br	81113ae0 <vParserCommTask+0x570>
							case 60: /* TC_SCAM_CONFIG */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_CONFIG\n");
811139d4:	d0a06217 	ldw	r2,-32376(gp)
811139d8:	100f883a 	mov	r7,r2
811139dc:	01800704 	movi	r6,28
811139e0:	01400044 	movi	r5,1
811139e4:	01204574 	movhi	r4,33045
811139e8:	21371404 	addi	r4,r4,-9136
811139ec:	1121c7c0 	call	81121c7c <fwrite>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
811139f0:	01204574 	movhi	r4,33045
811139f4:	210dd504 	addi	r4,r4,14164
811139f8:	11144780 	call	81114478 <bSendMessagePUStoMebTask>

								break;
811139fc:	00003806 	br	81113ae0 <vParserCommTask+0x570>
							case 61: /* TC_SCAM_RUN */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_RUN\n");
81113a00:	d0a06217 	ldw	r2,-32376(gp)
81113a04:	100f883a 	mov	r7,r2
81113a08:	01800644 	movi	r6,25
81113a0c:	01400044 	movi	r5,1
81113a10:	01204574 	movhi	r4,33045
81113a14:	21371c04 	addi	r4,r4,-9104
81113a18:	1121c7c0 	call	81121c7c <fwrite>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
81113a1c:	01204574 	movhi	r4,33045
81113a20:	210dd504 	addi	r4,r4,14164
81113a24:	11144780 	call	81114478 <bSendMessagePUStoMebTask>

								break;
81113a28:	00002d06 	br	81113ae0 <vParserCommTask+0x570>
							case 62: /* TC_SCAM_TURNOFF */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_TURNOFF\n");
81113a2c:	d0a06217 	ldw	r2,-32376(gp)
81113a30:	100f883a 	mov	r7,r2
81113a34:	01800744 	movi	r6,29
81113a38:	01400044 	movi	r5,1
81113a3c:	01204574 	movhi	r4,33045
81113a40:	21372304 	addi	r4,r4,-9076
81113a44:	1121c7c0 	call	81121c7c <fwrite>
								#endif
								vSendTurnOff();
81113a48:	11191ac0 	call	811191ac <vSendTurnOff>

								/* Send to Meb the shutdown command */
								bSendMessagePUStoMebTask(&xTcPusL);
81113a4c:	01204574 	movhi	r4,33045
81113a50:	210dd504 	addi	r4,r4,14164
81113a54:	11144780 	call	81114478 <bSendMessagePUStoMebTask>

								break;
81113a58:	00002106 	br	81113ae0 <vParserCommTask+0x570>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81113a5c:	e0bfdec4 	addi	r2,fp,-133
81113a60:	01802004 	movi	r6,128
81113a64:	000b883a 	mov	r5,zero
81113a68:	1009883a 	mov	r4,r2
81113a6c:	11227e00 	call	811227e0 <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
81113a70:	00a04574 	movhi	r2,33045
81113a74:	108dd504 	addi	r2,r2,14164
81113a78:	1080030b 	ldhu	r2,12(r2)
81113a7c:	113fffcc 	andi	r4,r2,65535
81113a80:	00a04574 	movhi	r2,33045
81113a84:	108dd504 	addi	r2,r2,14164
81113a88:	1080038b 	ldhu	r2,14(r2)
81113a8c:	117fffcc 	andi	r5,r2,65535
81113a90:	00a04574 	movhi	r2,33045
81113a94:	108dd504 	addi	r2,r2,14164
81113a98:	1080040b 	ldhu	r2,16(r2)
81113a9c:	10bfffcc 	andi	r2,r2,65535
81113aa0:	e0ffdec4 	addi	r3,fp,-133
81113aa4:	d8800015 	stw	r2,0(sp)
81113aa8:	280f883a 	mov	r7,r5
81113aac:	200d883a 	mov	r6,r4
81113ab0:	01604574 	movhi	r5,33045
81113ab4:	2976fa04 	addi	r5,r5,-9240
81113ab8:	1809883a 	mov	r4,r3
81113abc:	1122f700 	call	81122f70 <sprintf>
									debug(fp, cPUSDebug );
81113ac0:	d0a06217 	ldw	r2,-32376(gp)
81113ac4:	e0ffdec4 	addi	r3,fp,-133
81113ac8:	180b883a 	mov	r5,r3
81113acc:	1009883a 	mov	r4,r2
81113ad0:	11215e00 	call	811215e0 <fprintf>
								#endif							
								eParserMode = sWaitingMessage;
81113ad4:	00800044 	movi	r2,1
81113ad8:	e0bfdc15 	stw	r2,-144(fp)
								break;
81113adc:	0001883a 	nop
						}
                        break;
81113ae0:	00021a06 	br	8111434c <vParserCommTask+0xddc>


                    case 251: /* srv-Type = 251 */
						usiFeeInstL = PreParsedLocal.usiValues[6];
81113ae4:	00a04574 	movhi	r2,33045
81113ae8:	108dc204 	addi	r2,r2,14088
81113aec:	1080050b 	ldhu	r2,20(r2)
81113af0:	e0bfde0d 	sth	r2,-136(fp)

						if ( usiFeeInstL > N_OF_NFEE ) {
81113af4:	e0bfde0b 	ldhu	r2,-136(fp)
81113af8:	108000b0 	cmpltui	r2,r2,2
81113afc:	1000121e 	bne	r2,zero,81113b48 <vParserCommTask+0x5d8>
							#ifdef DEBUG_ON
								memset(cPUSDebug,0,128);
81113b00:	e0bfdec4 	addi	r2,fp,-133
81113b04:	01802004 	movi	r6,128
81113b08:	000b883a 	mov	r5,zero
81113b0c:	1009883a 	mov	r4,r2
81113b10:	11227e00 	call	811227e0 <memset>
								sprintf(cPUSDebug, "Parser Task: Doesn't exist the Fee Instance number: %hu;\n", usiFeeInstL );
81113b14:	e0ffde0b 	ldhu	r3,-136(fp)
81113b18:	e0bfdec4 	addi	r2,fp,-133
81113b1c:	180d883a 	mov	r6,r3
81113b20:	01604574 	movhi	r5,33045
81113b24:	29772b04 	addi	r5,r5,-9044
81113b28:	1009883a 	mov	r4,r2
81113b2c:	1122f700 	call	81122f70 <sprintf>
								debug(fp, cPUSDebug );
81113b30:	d0a06217 	ldw	r2,-32376(gp)
81113b34:	e0ffdec4 	addi	r3,fp,-133
81113b38:	180b883a 	mov	r5,r3
81113b3c:	1009883a 	mov	r4,r2
81113b40:	11215e00 	call	811215e0 <fprintf>
									#endif							
									eParserMode = sWaitingMessage;
									break;
							}
						}
                        break;
81113b44:	00020106 	br	8111434c <vParserCommTask+0xddc>
								sprintf(cPUSDebug, "Parser Task: Doesn't exist the Fee Instance number: %hu;\n", usiFeeInstL );
								debug(fp, cPUSDebug );
							#endif
							/* todo: Enviar mensagem de erro se aplicavel */
						} else {
							xTcPusL.usiValues[xTcPusL.ucNofValues] = usiFeeInstL;
81113b48:	00a04574 	movhi	r2,33045
81113b4c:	108dd504 	addi	r2,r2,14164
81113b50:	10800483 	ldbu	r2,18(r2)
81113b54:	10c03fcc 	andi	r3,r2,255
81113b58:	00a04574 	movhi	r2,33045
81113b5c:	108dd504 	addi	r2,r2,14164
81113b60:	18c00284 	addi	r3,r3,10
81113b64:	18c7883a 	add	r3,r3,r3
81113b68:	10c5883a 	add	r2,r2,r3
81113b6c:	e0ffde0b 	ldhu	r3,-136(fp)
81113b70:	10c0000d 	sth	r3,0(r2)
							xTcPusL.ucNofValues++;
81113b74:	00a04574 	movhi	r2,33045
81113b78:	108dd504 	addi	r2,r2,14164
81113b7c:	10800483 	ldbu	r2,18(r2)
81113b80:	10800044 	addi	r2,r2,1
81113b84:	1007883a 	mov	r3,r2
81113b88:	00a04574 	movhi	r2,33045
81113b8c:	108dd504 	addi	r2,r2,14164
81113b90:	10c00485 	stb	r3,18(r2)

							switch ( xTcPusL.usiSubType )
81113b94:	00a04574 	movhi	r2,33045
81113b98:	108dd504 	addi	r2,r2,14164
81113b9c:	1080038b 	ldhu	r2,14(r2)
81113ba0:	10bfffcc 	andi	r2,r2,65535
81113ba4:	10c000a0 	cmpeqi	r3,r2,2
81113ba8:	1800191e 	bne	r3,zero,81113c10 <vParserCommTask+0x6a0>
81113bac:	10c00160 	cmpeqi	r3,r2,5
81113bb0:	18002c1e 	bne	r3,zero,81113c64 <vParserCommTask+0x6f4>
81113bb4:	10800060 	cmpeqi	r2,r2,1
81113bb8:	10003f26 	beq	r2,zero,81113cb8 <vParserCommTask+0x748>
							{
								case 1: /* TC_SCAM_FEE_CONFIG_ENTER */
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
81113bbc:	e0bfdec4 	addi	r2,fp,-133
81113bc0:	01802004 	movi	r6,128
81113bc4:	000b883a 	mov	r5,zero
81113bc8:	1009883a 	mov	r4,r2
81113bcc:	11227e00 	call	811227e0 <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_CONFIG_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81113bd0:	e0ffde0b 	ldhu	r3,-136(fp)
81113bd4:	e0bfdec4 	addi	r2,fp,-133
81113bd8:	180d883a 	mov	r6,r3
81113bdc:	01604574 	movhi	r5,33045
81113be0:	29773a04 	addi	r5,r5,-8984
81113be4:	1009883a 	mov	r4,r2
81113be8:	1122f700 	call	81122f70 <sprintf>
										debug(fp, cPUSDebug );
81113bec:	d0a06217 	ldw	r2,-32376(gp)
81113bf0:	e0ffdec4 	addi	r3,fp,-133
81113bf4:	180b883a 	mov	r5,r3
81113bf8:	1009883a 	mov	r4,r2
81113bfc:	11215e00 	call	811215e0 <fprintf>
									#endif							
									bSendMessagePUStoMebTask(&xTcPusL);
81113c00:	01204574 	movhi	r4,33045
81113c04:	210dd504 	addi	r4,r4,14164
81113c08:	11144780 	call	81114478 <bSendMessagePUStoMebTask>

									break;
81113c0c:	00004b06 	br	81113d3c <vParserCommTask+0x7cc>
								case 2: /* TC_SCAM_FEE_STANDBY_ENTER */
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
81113c10:	e0bfdec4 	addi	r2,fp,-133
81113c14:	01802004 	movi	r6,128
81113c18:	000b883a 	mov	r5,zero
81113c1c:	1009883a 	mov	r4,r2
81113c20:	11227e00 	call	811227e0 <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_STANDBY_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81113c24:	e0ffde0b 	ldhu	r3,-136(fp)
81113c28:	e0bfdec4 	addi	r2,fp,-133
81113c2c:	180d883a 	mov	r6,r3
81113c30:	01604574 	movhi	r5,33045
81113c34:	29774a04 	addi	r5,r5,-8920
81113c38:	1009883a 	mov	r4,r2
81113c3c:	1122f700 	call	81122f70 <sprintf>
										debug(fp, cPUSDebug );
81113c40:	d0a06217 	ldw	r2,-32376(gp)
81113c44:	e0ffdec4 	addi	r3,fp,-133
81113c48:	180b883a 	mov	r5,r3
81113c4c:	1009883a 	mov	r4,r2
81113c50:	11215e00 	call	811215e0 <fprintf>
									#endif
									bSendMessagePUStoMebTask(&xTcPusL);
81113c54:	01204574 	movhi	r4,33045
81113c58:	210dd504 	addi	r4,r4,14164
81113c5c:	11144780 	call	81114478 <bSendMessagePUStoMebTask>

									break;
81113c60:	00003606 	br	81113d3c <vParserCommTask+0x7cc>
								case 5: /* TC_SCAM_FEE_CALIBRATION_TEST_ENTER */
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
81113c64:	e0bfdec4 	addi	r2,fp,-133
81113c68:	01802004 	movi	r6,128
81113c6c:	000b883a 	mov	r5,zero
81113c70:	1009883a 	mov	r4,r2
81113c74:	11227e00 	call	811227e0 <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_CALIBRATION_TEST_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81113c78:	e0ffde0b 	ldhu	r3,-136(fp)
81113c7c:	e0bfdec4 	addi	r2,fp,-133
81113c80:	180d883a 	mov	r6,r3
81113c84:	01604574 	movhi	r5,33045
81113c88:	29775a04 	addi	r5,r5,-8856
81113c8c:	1009883a 	mov	r4,r2
81113c90:	1122f700 	call	81122f70 <sprintf>
										debug(fp, cPUSDebug );
81113c94:	d0a06217 	ldw	r2,-32376(gp)
81113c98:	e0ffdec4 	addi	r3,fp,-133
81113c9c:	180b883a 	mov	r5,r3
81113ca0:	1009883a 	mov	r4,r2
81113ca4:	11215e00 	call	811215e0 <fprintf>
									#endif
									bSendMessagePUStoMebTask(&xTcPusL);
81113ca8:	01204574 	movhi	r4,33045
81113cac:	210dd504 	addi	r4,r4,14164
81113cb0:	11144780 	call	81114478 <bSendMessagePUStoMebTask>

									break;
81113cb4:	00002106 	br	81113d3c <vParserCommTask+0x7cc>
								default:
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
81113cb8:	e0bfdec4 	addi	r2,fp,-133
81113cbc:	01802004 	movi	r6,128
81113cc0:	000b883a 	mov	r5,zero
81113cc4:	1009883a 	mov	r4,r2
81113cc8:	11227e00 	call	811227e0 <memset>
										sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
81113ccc:	00a04574 	movhi	r2,33045
81113cd0:	108dd504 	addi	r2,r2,14164
81113cd4:	1080030b 	ldhu	r2,12(r2)
81113cd8:	113fffcc 	andi	r4,r2,65535
81113cdc:	00a04574 	movhi	r2,33045
81113ce0:	108dd504 	addi	r2,r2,14164
81113ce4:	1080038b 	ldhu	r2,14(r2)
81113ce8:	117fffcc 	andi	r5,r2,65535
81113cec:	00a04574 	movhi	r2,33045
81113cf0:	108dd504 	addi	r2,r2,14164
81113cf4:	1080040b 	ldhu	r2,16(r2)
81113cf8:	10bfffcc 	andi	r2,r2,65535
81113cfc:	e0ffdec4 	addi	r3,fp,-133
81113d00:	d8800015 	stw	r2,0(sp)
81113d04:	280f883a 	mov	r7,r5
81113d08:	200d883a 	mov	r6,r4
81113d0c:	01604574 	movhi	r5,33045
81113d10:	2976fa04 	addi	r5,r5,-9240
81113d14:	1809883a 	mov	r4,r3
81113d18:	1122f700 	call	81122f70 <sprintf>
										debug(fp, cPUSDebug );
81113d1c:	d0a06217 	ldw	r2,-32376(gp)
81113d20:	e0ffdec4 	addi	r3,fp,-133
81113d24:	180b883a 	mov	r5,r3
81113d28:	1009883a 	mov	r4,r2
81113d2c:	11215e00 	call	811215e0 <fprintf>
									#endif							
									eParserMode = sWaitingMessage;
81113d30:	00800044 	movi	r2,1
81113d34:	e0bfdc15 	stw	r2,-144(fp)
									break;
81113d38:	0001883a 	nop
							}
						}
                        break;
81113d3c:	00018306 	br	8111434c <vParserCommTask+0xddc>


					case 252: /* srv-Type = 252 */
						usiFeeInstL = PreParsedLocal.usiValues[6];
81113d40:	00a04574 	movhi	r2,33045
81113d44:	108dc204 	addi	r2,r2,14088
81113d48:	1080050b 	ldhu	r2,20(r2)
81113d4c:	e0bfde0d 	sth	r2,-136(fp)
						xTcPusL.usiValues[xTcPusL.ucNofValues] = usiFeeInstL;
81113d50:	00a04574 	movhi	r2,33045
81113d54:	108dd504 	addi	r2,r2,14164
81113d58:	10800483 	ldbu	r2,18(r2)
81113d5c:	10c03fcc 	andi	r3,r2,255
81113d60:	00a04574 	movhi	r2,33045
81113d64:	108dd504 	addi	r2,r2,14164
81113d68:	18c00284 	addi	r3,r3,10
81113d6c:	18c7883a 	add	r3,r3,r3
81113d70:	10c5883a 	add	r2,r2,r3
81113d74:	e0ffde0b 	ldhu	r3,-136(fp)
81113d78:	10c0000d 	sth	r3,0(r2)
						xTcPusL.ucNofValues++;
81113d7c:	00a04574 	movhi	r2,33045
81113d80:	108dd504 	addi	r2,r2,14164
81113d84:	10800483 	ldbu	r2,18(r2)
81113d88:	10800044 	addi	r2,r2,1
81113d8c:	1007883a 	mov	r3,r2
81113d90:	00a04574 	movhi	r2,33045
81113d94:	108dd504 	addi	r2,r2,14164
81113d98:	10c00485 	stb	r3,18(r2)

						switch ( xTcPusL.usiSubType )
81113d9c:	00a04574 	movhi	r2,33045
81113da0:	108dd504 	addi	r2,r2,14164
81113da4:	1080038b 	ldhu	r2,14(r2)
81113da8:	10bfffcc 	andi	r2,r2,65535
81113dac:	10c000e0 	cmpeqi	r3,r2,3
81113db0:	18000a1e 	bne	r3,zero,81113ddc <vParserCommTask+0x86c>
81113db4:	10c00108 	cmpgei	r3,r2,4
81113db8:	1800031e 	bne	r3,zero,81113dc8 <vParserCommTask+0x858>
81113dbc:	108000a0 	cmpeqi	r2,r2,2
81113dc0:	1000451e 	bne	r2,zero,81113ed8 <vParserCommTask+0x968>
81113dc4:	00013c06 	br	811142b8 <vParserCommTask+0xd48>
81113dc8:	10c00120 	cmpeqi	r3,r2,4
81113dcc:	1800181e 	bne	r3,zero,81113e30 <vParserCommTask+0x8c0>
81113dd0:	10800160 	cmpeqi	r2,r2,5
81113dd4:	10002b1e 	bne	r2,zero,81113e84 <vParserCommTask+0x914>
81113dd8:	00013706 	br	811142b8 <vParserCommTask+0xd48>
						{					
							case 3: /* TC_SCAM_SPW_LINK_ENABLE */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81113ddc:	e0bfdec4 	addi	r2,fp,-133
81113de0:	01802004 	movi	r6,128
81113de4:	000b883a 	mov	r5,zero
81113de8:	1009883a 	mov	r4,r2
81113dec:	11227e00 	call	811227e0 <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_ENABLE (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81113df0:	e0ffde0b 	ldhu	r3,-136(fp)
81113df4:	e0bfdec4 	addi	r2,fp,-133
81113df8:	180d883a 	mov	r6,r3
81113dfc:	01604574 	movhi	r5,33045
81113e00:	29776c04 	addi	r5,r5,-8784
81113e04:	1009883a 	mov	r4,r2
81113e08:	1122f700 	call	81122f70 <sprintf>
									debug(fp, cPUSDebug );
81113e0c:	d0a06217 	ldw	r2,-32376(gp)
81113e10:	e0ffdec4 	addi	r3,fp,-133
81113e14:	180b883a 	mov	r5,r3
81113e18:	1009883a 	mov	r4,r2
81113e1c:	11215e00 	call	811215e0 <fprintf>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
81113e20:	01204574 	movhi	r4,33045
81113e24:	210dd504 	addi	r4,r4,14164
81113e28:	11144780 	call	81114478 <bSendMessagePUStoMebTask>

								break;
81113e2c:	00014306 	br	8111433c <vParserCommTask+0xdcc>
							case 4: /* TC_SCAM_SPW_LINK_DISABLE */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81113e30:	e0bfdec4 	addi	r2,fp,-133
81113e34:	01802004 	movi	r6,128
81113e38:	000b883a 	mov	r5,zero
81113e3c:	1009883a 	mov	r4,r2
81113e40:	11227e00 	call	811227e0 <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_DISABLE (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81113e44:	e0ffde0b 	ldhu	r3,-136(fp)
81113e48:	e0bfdec4 	addi	r2,fp,-133
81113e4c:	180d883a 	mov	r6,r3
81113e50:	01604574 	movhi	r5,33045
81113e54:	29777c04 	addi	r5,r5,-8720
81113e58:	1009883a 	mov	r4,r2
81113e5c:	1122f700 	call	81122f70 <sprintf>
									debug(fp, cPUSDebug );
81113e60:	d0a06217 	ldw	r2,-32376(gp)
81113e64:	e0ffdec4 	addi	r3,fp,-133
81113e68:	180b883a 	mov	r5,r3
81113e6c:	1009883a 	mov	r4,r2
81113e70:	11215e00 	call	811215e0 <fprintf>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
81113e74:	01204574 	movhi	r4,33045
81113e78:	210dd504 	addi	r4,r4,14164
81113e7c:	11144780 	call	81114478 <bSendMessagePUStoMebTask>

								break;
81113e80:	00012e06 	br	8111433c <vParserCommTask+0xdcc>
							case 5: /* TC_SCAM_SPW_LINK_RESET */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81113e84:	e0bfdec4 	addi	r2,fp,-133
81113e88:	01802004 	movi	r6,128
81113e8c:	000b883a 	mov	r5,zero
81113e90:	1009883a 	mov	r4,r2
81113e94:	11227e00 	call	811227e0 <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_RESET (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81113e98:	e0ffde0b 	ldhu	r3,-136(fp)
81113e9c:	e0bfdec4 	addi	r2,fp,-133
81113ea0:	180d883a 	mov	r6,r3
81113ea4:	01604574 	movhi	r5,33045
81113ea8:	29778c04 	addi	r5,r5,-8656
81113eac:	1009883a 	mov	r4,r2
81113eb0:	1122f700 	call	81122f70 <sprintf>
									debug(fp, cPUSDebug );
81113eb4:	d0a06217 	ldw	r2,-32376(gp)
81113eb8:	e0ffdec4 	addi	r3,fp,-133
81113ebc:	180b883a 	mov	r5,r3
81113ec0:	1009883a 	mov	r4,r2
81113ec4:	11215e00 	call	811215e0 <fprintf>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
81113ec8:	01204574 	movhi	r4,33045
81113ecc:	210dd504 	addi	r4,r4,14164
81113ed0:	11144780 	call	81114478 <bSendMessagePUStoMebTask>

								break;
81113ed4:	00011906 	br	8111433c <vParserCommTask+0xdcc>
							case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[7];
81113ed8:	00a04574 	movhi	r2,33045
81113edc:	108dd504 	addi	r2,r2,14164
81113ee0:	10800483 	ldbu	r2,18(r2)
81113ee4:	10c03fcc 	andi	r3,r2,255
81113ee8:	00a04574 	movhi	r2,33045
81113eec:	108dc204 	addi	r2,r2,14088
81113ef0:	1100058b 	ldhu	r4,22(r2)
81113ef4:	00a04574 	movhi	r2,33045
81113ef8:	108dd504 	addi	r2,r2,14164
81113efc:	18c00284 	addi	r3,r3,10
81113f00:	18c7883a 	add	r3,r3,r3
81113f04:	10c5883a 	add	r2,r2,r3
81113f08:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81113f0c:	00a04574 	movhi	r2,33045
81113f10:	108dd504 	addi	r2,r2,14164
81113f14:	10800483 	ldbu	r2,18(r2)
81113f18:	10800044 	addi	r2,r2,1
81113f1c:	1007883a 	mov	r3,r2
81113f20:	00a04574 	movhi	r2,33045
81113f24:	108dd504 	addi	r2,r2,14164
81113f28:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[8];
81113f2c:	00a04574 	movhi	r2,33045
81113f30:	108dd504 	addi	r2,r2,14164
81113f34:	10800483 	ldbu	r2,18(r2)
81113f38:	10c03fcc 	andi	r3,r2,255
81113f3c:	00a04574 	movhi	r2,33045
81113f40:	108dc204 	addi	r2,r2,14088
81113f44:	1100060b 	ldhu	r4,24(r2)
81113f48:	00a04574 	movhi	r2,33045
81113f4c:	108dd504 	addi	r2,r2,14164
81113f50:	18c00284 	addi	r3,r3,10
81113f54:	18c7883a 	add	r3,r3,r3
81113f58:	10c5883a 	add	r2,r2,r3
81113f5c:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81113f60:	00a04574 	movhi	r2,33045
81113f64:	108dd504 	addi	r2,r2,14164
81113f68:	10800483 	ldbu	r2,18(r2)
81113f6c:	10800044 	addi	r2,r2,1
81113f70:	1007883a 	mov	r3,r2
81113f74:	00a04574 	movhi	r2,33045
81113f78:	108dd504 	addi	r2,r2,14164
81113f7c:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[9];
81113f80:	00a04574 	movhi	r2,33045
81113f84:	108dd504 	addi	r2,r2,14164
81113f88:	10800483 	ldbu	r2,18(r2)
81113f8c:	10c03fcc 	andi	r3,r2,255
81113f90:	00a04574 	movhi	r2,33045
81113f94:	108dc204 	addi	r2,r2,14088
81113f98:	1100068b 	ldhu	r4,26(r2)
81113f9c:	00a04574 	movhi	r2,33045
81113fa0:	108dd504 	addi	r2,r2,14164
81113fa4:	18c00284 	addi	r3,r3,10
81113fa8:	18c7883a 	add	r3,r3,r3
81113fac:	10c5883a 	add	r2,r2,r3
81113fb0:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81113fb4:	00a04574 	movhi	r2,33045
81113fb8:	108dd504 	addi	r2,r2,14164
81113fbc:	10800483 	ldbu	r2,18(r2)
81113fc0:	10800044 	addi	r2,r2,1
81113fc4:	1007883a 	mov	r3,r2
81113fc8:	00a04574 	movhi	r2,33045
81113fcc:	108dd504 	addi	r2,r2,14164
81113fd0:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[10];
81113fd4:	00a04574 	movhi	r2,33045
81113fd8:	108dd504 	addi	r2,r2,14164
81113fdc:	10800483 	ldbu	r2,18(r2)
81113fe0:	10c03fcc 	andi	r3,r2,255
81113fe4:	00a04574 	movhi	r2,33045
81113fe8:	108dc204 	addi	r2,r2,14088
81113fec:	1100070b 	ldhu	r4,28(r2)
81113ff0:	00a04574 	movhi	r2,33045
81113ff4:	108dd504 	addi	r2,r2,14164
81113ff8:	18c00284 	addi	r3,r3,10
81113ffc:	18c7883a 	add	r3,r3,r3
81114000:	10c5883a 	add	r2,r2,r3
81114004:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81114008:	00a04574 	movhi	r2,33045
8111400c:	108dd504 	addi	r2,r2,14164
81114010:	10800483 	ldbu	r2,18(r2)
81114014:	10800044 	addi	r2,r2,1
81114018:	1007883a 	mov	r3,r2
8111401c:	00a04574 	movhi	r2,33045
81114020:	108dd504 	addi	r2,r2,14164
81114024:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[11];
81114028:	00a04574 	movhi	r2,33045
8111402c:	108dd504 	addi	r2,r2,14164
81114030:	10800483 	ldbu	r2,18(r2)
81114034:	10c03fcc 	andi	r3,r2,255
81114038:	00a04574 	movhi	r2,33045
8111403c:	108dc204 	addi	r2,r2,14088
81114040:	1100078b 	ldhu	r4,30(r2)
81114044:	00a04574 	movhi	r2,33045
81114048:	108dd504 	addi	r2,r2,14164
8111404c:	18c00284 	addi	r3,r3,10
81114050:	18c7883a 	add	r3,r3,r3
81114054:	10c5883a 	add	r2,r2,r3
81114058:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
8111405c:	00a04574 	movhi	r2,33045
81114060:	108dd504 	addi	r2,r2,14164
81114064:	10800483 	ldbu	r2,18(r2)
81114068:	10800044 	addi	r2,r2,1
8111406c:	1007883a 	mov	r3,r2
81114070:	00a04574 	movhi	r2,33045
81114074:	108dd504 	addi	r2,r2,14164
81114078:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[12];
8111407c:	00a04574 	movhi	r2,33045
81114080:	108dd504 	addi	r2,r2,14164
81114084:	10800483 	ldbu	r2,18(r2)
81114088:	10c03fcc 	andi	r3,r2,255
8111408c:	00a04574 	movhi	r2,33045
81114090:	108dc204 	addi	r2,r2,14088
81114094:	1100080b 	ldhu	r4,32(r2)
81114098:	00a04574 	movhi	r2,33045
8111409c:	108dd504 	addi	r2,r2,14164
811140a0:	18c00284 	addi	r3,r3,10
811140a4:	18c7883a 	add	r3,r3,r3
811140a8:	10c5883a 	add	r2,r2,r3
811140ac:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
811140b0:	00a04574 	movhi	r2,33045
811140b4:	108dd504 	addi	r2,r2,14164
811140b8:	10800483 	ldbu	r2,18(r2)
811140bc:	10800044 	addi	r2,r2,1
811140c0:	1007883a 	mov	r3,r2
811140c4:	00a04574 	movhi	r2,33045
811140c8:	108dd504 	addi	r2,r2,14164
811140cc:	10c00485 	stb	r3,18(r2)


								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
811140d0:	e0bfdec4 	addi	r2,fp,-133
811140d4:	01802004 	movi	r6,128
811140d8:	000b883a 	mov	r5,zero
811140dc:	1009883a 	mov	r4,r2
811140e0:	11227e00 	call	811227e0 <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_RMAP_CONFIG_UPDATE:\n");
811140e4:	e0ffdec4 	addi	r3,fp,-133
811140e8:	00a04574 	movhi	r2,33045
811140ec:	10b79b04 	addi	r2,r2,-8596
811140f0:	1009883a 	mov	r4,r2
811140f4:	00800b84 	movi	r2,46
811140f8:	100d883a 	mov	r6,r2
811140fc:	200b883a 	mov	r5,r4
81114100:	1809883a 	mov	r4,r3
81114104:	11226900 	call	81122690 <memcpy>
									debug(fp, cPUSDebug );
81114108:	d0a06217 	ldw	r2,-32376(gp)
8111410c:	e0ffdec4 	addi	r3,fp,-133
81114110:	180b883a 	mov	r5,r3
81114114:	1009883a 	mov	r4,r2
81114118:	11215e00 	call	811215e0 <fprintf>
									sprintf(cPUSDebug, "- FEESIM_INSTANCE: %hu;\n", usiFeeInstL );
8111411c:	e0ffde0b 	ldhu	r3,-136(fp)
81114120:	e0bfdec4 	addi	r2,fp,-133
81114124:	180d883a 	mov	r6,r3
81114128:	01604574 	movhi	r5,33045
8111412c:	2977a704 	addi	r5,r5,-8548
81114130:	1009883a 	mov	r4,r2
81114134:	1122f700 	call	81122f70 <sprintf>
									debug(fp, cPUSDebug );
81114138:	d0a06217 	ldw	r2,-32376(gp)
8111413c:	e0ffdec4 	addi	r3,fp,-133
81114140:	180b883a 	mov	r5,r3
81114144:	1009883a 	mov	r4,r2
81114148:	11215e00 	call	811215e0 <fprintf>
									sprintf(cPUSDebug, "- MODE: %hu;\n", PreParsedLocal.usiValues[7] );
8111414c:	00a04574 	movhi	r2,33045
81114150:	108dc204 	addi	r2,r2,14088
81114154:	1080058b 	ldhu	r2,22(r2)
81114158:	10ffffcc 	andi	r3,r2,65535
8111415c:	e0bfdec4 	addi	r2,fp,-133
81114160:	180d883a 	mov	r6,r3
81114164:	01604574 	movhi	r5,33045
81114168:	2977ae04 	addi	r5,r5,-8520
8111416c:	1009883a 	mov	r4,r2
81114170:	1122f700 	call	81122f70 <sprintf>
									debug(fp, cPUSDebug );
81114174:	d0a06217 	ldw	r2,-32376(gp)
81114178:	e0ffdec4 	addi	r3,fp,-133
8111417c:	180b883a 	mov	r5,r3
81114180:	1009883a 	mov	r4,r2
81114184:	11215e00 	call	811215e0 <fprintf>
									sprintf(cPUSDebug, "- LINK_SPEED: %hu;\n", PreParsedLocal.usiValues[8] );
81114188:	00a04574 	movhi	r2,33045
8111418c:	108dc204 	addi	r2,r2,14088
81114190:	1080060b 	ldhu	r2,24(r2)
81114194:	10ffffcc 	andi	r3,r2,65535
81114198:	e0bfdec4 	addi	r2,fp,-133
8111419c:	180d883a 	mov	r6,r3
811141a0:	01604574 	movhi	r5,33045
811141a4:	2977b204 	addi	r5,r5,-8504
811141a8:	1009883a 	mov	r4,r2
811141ac:	1122f700 	call	81122f70 <sprintf>
									debug(fp, cPUSDebug );
811141b0:	d0a06217 	ldw	r2,-32376(gp)
811141b4:	e0ffdec4 	addi	r3,fp,-133
811141b8:	180b883a 	mov	r5,r3
811141bc:	1009883a 	mov	r4,r2
811141c0:	11215e00 	call	811215e0 <fprintf>
									sprintf(cPUSDebug, "- LOGICAL_ADDR: 0x%02X;\n", PreParsedLocal.usiValues[9] );
811141c4:	00a04574 	movhi	r2,33045
811141c8:	108dc204 	addi	r2,r2,14088
811141cc:	1080068b 	ldhu	r2,26(r2)
811141d0:	10ffffcc 	andi	r3,r2,65535
811141d4:	e0bfdec4 	addi	r2,fp,-133
811141d8:	180d883a 	mov	r6,r3
811141dc:	01604574 	movhi	r5,33045
811141e0:	2977b704 	addi	r5,r5,-8484
811141e4:	1009883a 	mov	r4,r2
811141e8:	1122f700 	call	81122f70 <sprintf>
									debug(fp, cPUSDebug );
811141ec:	d0a06217 	ldw	r2,-32376(gp)
811141f0:	e0ffdec4 	addi	r3,fp,-133
811141f4:	180b883a 	mov	r5,r3
811141f8:	1009883a 	mov	r4,r2
811141fc:	11215e00 	call	811215e0 <fprintf>
									sprintf(cPUSDebug, "- DEST_NODE_ADDR: 0x%02X;\n", PreParsedLocal.usiValues[10] );
81114200:	00a04574 	movhi	r2,33045
81114204:	108dc204 	addi	r2,r2,14088
81114208:	1080070b 	ldhu	r2,28(r2)
8111420c:	10ffffcc 	andi	r3,r2,65535
81114210:	e0bfdec4 	addi	r2,fp,-133
81114214:	180d883a 	mov	r6,r3
81114218:	01604574 	movhi	r5,33045
8111421c:	2977be04 	addi	r5,r5,-8456
81114220:	1009883a 	mov	r4,r2
81114224:	1122f700 	call	81122f70 <sprintf>
									debug(fp, cPUSDebug );
81114228:	d0a06217 	ldw	r2,-32376(gp)
8111422c:	e0ffdec4 	addi	r3,fp,-133
81114230:	180b883a 	mov	r5,r3
81114234:	1009883a 	mov	r4,r2
81114238:	11215e00 	call	811215e0 <fprintf>
									sprintf(cPUSDebug, "- TIME_CODE_GEN: %hu;\n", PreParsedLocal.usiValues[11] );
8111423c:	00a04574 	movhi	r2,33045
81114240:	108dc204 	addi	r2,r2,14088
81114244:	1080078b 	ldhu	r2,30(r2)
81114248:	10ffffcc 	andi	r3,r2,65535
8111424c:	e0bfdec4 	addi	r2,fp,-133
81114250:	180d883a 	mov	r6,r3
81114254:	01604574 	movhi	r5,33045
81114258:	2977c504 	addi	r5,r5,-8428
8111425c:	1009883a 	mov	r4,r2
81114260:	1122f700 	call	81122f70 <sprintf>
									debug(fp, cPUSDebug );
81114264:	d0a06217 	ldw	r2,-32376(gp)
81114268:	e0ffdec4 	addi	r3,fp,-133
8111426c:	180b883a 	mov	r5,r3
81114270:	1009883a 	mov	r4,r2
81114274:	11215e00 	call	811215e0 <fprintf>
									sprintf(cPUSDebug, "- RMAP_KEY: 0x%02X;\n", PreParsedLocal.usiValues[12] );
81114278:	00a04574 	movhi	r2,33045
8111427c:	108dc204 	addi	r2,r2,14088
81114280:	1080080b 	ldhu	r2,32(r2)
81114284:	10ffffcc 	andi	r3,r2,65535
81114288:	e0bfdec4 	addi	r2,fp,-133
8111428c:	180d883a 	mov	r6,r3
81114290:	01604574 	movhi	r5,33045
81114294:	2977cb04 	addi	r5,r5,-8404
81114298:	1009883a 	mov	r4,r2
8111429c:	1122f700 	call	81122f70 <sprintf>
									debug(fp, cPUSDebug );
811142a0:	d0a06217 	ldw	r2,-32376(gp)
811142a4:	e0ffdec4 	addi	r3,fp,-133
811142a8:	180b883a 	mov	r5,r3
811142ac:	1009883a 	mov	r4,r2
811142b0:	11215e00 	call	811215e0 <fprintf>
								#endif

								break;
811142b4:	00002106 	br	8111433c <vParserCommTask+0xdcc>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
811142b8:	e0bfdec4 	addi	r2,fp,-133
811142bc:	01802004 	movi	r6,128
811142c0:	000b883a 	mov	r5,zero
811142c4:	1009883a 	mov	r4,r2
811142c8:	11227e00 	call	811227e0 <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
811142cc:	00a04574 	movhi	r2,33045
811142d0:	108dd504 	addi	r2,r2,14164
811142d4:	1080030b 	ldhu	r2,12(r2)
811142d8:	113fffcc 	andi	r4,r2,65535
811142dc:	00a04574 	movhi	r2,33045
811142e0:	108dd504 	addi	r2,r2,14164
811142e4:	1080038b 	ldhu	r2,14(r2)
811142e8:	117fffcc 	andi	r5,r2,65535
811142ec:	00a04574 	movhi	r2,33045
811142f0:	108dd504 	addi	r2,r2,14164
811142f4:	1080040b 	ldhu	r2,16(r2)
811142f8:	10bfffcc 	andi	r2,r2,65535
811142fc:	e0ffdec4 	addi	r3,fp,-133
81114300:	d8800015 	stw	r2,0(sp)
81114304:	280f883a 	mov	r7,r5
81114308:	200d883a 	mov	r6,r4
8111430c:	01604574 	movhi	r5,33045
81114310:	2976fa04 	addi	r5,r5,-9240
81114314:	1809883a 	mov	r4,r3
81114318:	1122f700 	call	81122f70 <sprintf>
									debug(fp, cPUSDebug );
8111431c:	d0a06217 	ldw	r2,-32376(gp)
81114320:	e0ffdec4 	addi	r3,fp,-133
81114324:	180b883a 	mov	r5,r3
81114328:	1009883a 	mov	r4,r2
8111432c:	11215e00 	call	811215e0 <fprintf>
								#endif							
								eParserMode = sWaitingMessage;
81114330:	00800044 	movi	r2,1
81114334:	e0bfdc15 	stw	r2,-144(fp)
								break;
81114338:	0001883a 	nop
						}
                        break;
8111433c:	00000306 	br	8111434c <vParserCommTask+0xddc>
                    default:
						eParserMode = sWaitingMessage;
81114340:	00800044 	movi	r2,1
81114344:	e0bfdc15 	stw	r2,-144(fp)
                        break;
81114348:	0001883a 	nop
                }
				break;				
8111434c:	00000306 	br	8111435c <vParserCommTask+0xdec>
			default:
				eParserMode = sWaitingMessage;
81114350:	00800044 	movi	r2,1
81114354:	e0bfdc15 	stw	r2,-144(fp)
				break;
81114358:	0001883a 	nop
		}
	}
8111435c:	003c9406 	br	811135b0 <__reset+0xfb0f35b0>

81114360 <getPreParsedPacket>:
}

bool getPreParsedPacket( tPreParsed *xPreParsedParser ) {
81114360:	defffb04 	addi	sp,sp,-20
81114364:	de00012e 	bgeu	sp,et,8111436c <getPreParsedPacket+0xc>
81114368:	003b68fa 	trap	3
8111436c:	dfc00415 	stw	ra,16(sp)
81114370:	df000315 	stw	fp,12(sp)
81114374:	df000304 	addi	fp,sp,12
81114378:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8111437c:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i;

	OSMutexPend(xMutexPreParsed, 0, &error_code); /*Blocking*/
81114380:	d0a06b17 	ldw	r2,-32340(gp)
81114384:	e0fffe44 	addi	r3,fp,-7
81114388:	180d883a 	mov	r6,r3
8111438c:	000b883a 	mov	r5,zero
81114390:	1009883a 	mov	r4,r2
81114394:	113cb0c0 	call	8113cb0c <OSMutexPend>
	if (error_code == OS_ERR_NONE) {
81114398:	e0bffe43 	ldbu	r2,-7(fp)
8111439c:	10803fcc 	andi	r2,r2,255
811143a0:	10002e1e 	bne	r2,zero,8111445c <getPreParsedPacket+0xfc>
		/* Got the Mutex */
		/*For now, will only get the first, not the packet that is waiting for longer time*/
		for( i = 0; i < N_PREPARSED_ENTRIES; i++)
811143a4:	e03ffe05 	stb	zero,-8(fp)
811143a8:	00002506 	br	81114440 <getPreParsedPacket+0xe0>
		{

            if ( xPreParsed[i].cType != 0 ) {
811143ac:	e0fffe03 	ldbu	r3,-8(fp)
811143b0:	00a045b4 	movhi	r2,33046
811143b4:	109b5804 	addi	r2,r2,28000
811143b8:	18c01324 	muli	r3,r3,76
811143bc:	10c5883a 	add	r2,r2,r3
811143c0:	10800104 	addi	r2,r2,4
811143c4:	10800003 	ldbu	r2,0(r2)
811143c8:	10803fcc 	andi	r2,r2,255
811143cc:	1080201c 	xori	r2,r2,128
811143d0:	10bfe004 	addi	r2,r2,-128
811143d4:	10001726 	beq	r2,zero,81114434 <getPreParsedPacket+0xd4>
                /* Locate a filled PreParsed variable in the array*/
            	/* Perform a copy to a local variable */
            	(*xPreParsedParser) = xPreParsed[i];
811143d8:	e0fffe03 	ldbu	r3,-8(fp)
811143dc:	e13fff17 	ldw	r4,-4(fp)
811143e0:	00a045b4 	movhi	r2,33046
811143e4:	109b5804 	addi	r2,r2,28000
811143e8:	18c01324 	muli	r3,r3,76
811143ec:	10c5883a 	add	r2,r2,r3
811143f0:	2007883a 	mov	r3,r4
811143f4:	1009883a 	mov	r4,r2
811143f8:	00801304 	movi	r2,76
811143fc:	100d883a 	mov	r6,r2
81114400:	200b883a 	mov	r5,r4
81114404:	1809883a 	mov	r4,r3
81114408:	11226900 	call	81122690 <memcpy>
                bSuccess = TRUE;
8111440c:	00800044 	movi	r2,1
81114410:	e0bffd15 	stw	r2,-12(fp)
                xPreParsed[i].cType = 0;
81114414:	e0fffe03 	ldbu	r3,-8(fp)
81114418:	00a045b4 	movhi	r2,33046
8111441c:	109b5804 	addi	r2,r2,28000
81114420:	18c01324 	muli	r3,r3,76
81114424:	10c5883a 	add	r2,r2,r3
81114428:	10800104 	addi	r2,r2,4
8111442c:	10000005 	stb	zero,0(r2)
                break;
81114430:	00000606 	br	8111444c <getPreParsedPacket+0xec>

	OSMutexPend(xMutexPreParsed, 0, &error_code); /*Blocking*/
	if (error_code == OS_ERR_NONE) {
		/* Got the Mutex */
		/*For now, will only get the first, not the packet that is waiting for longer time*/
		for( i = 0; i < N_PREPARSED_ENTRIES; i++)
81114434:	e0bffe03 	ldbu	r2,-8(fp)
81114438:	10800044 	addi	r2,r2,1
8111443c:	e0bffe05 	stb	r2,-8(fp)
81114440:	e0bffe03 	ldbu	r2,-8(fp)
81114444:	10800230 	cmpltui	r2,r2,8
81114448:	103fd81e 	bne	r2,zero,811143ac <__reset+0xfb0f43ac>
                bSuccess = TRUE;
                xPreParsed[i].cType = 0;
                break;
            }
		}
		OSMutexPost(xMutexPreParsed);
8111444c:	d0a06b17 	ldw	r2,-32340(gp)
81114450:	1009883a 	mov	r4,r2
81114454:	113d0b00 	call	8113d0b0 <OSMutexPost>
81114458:	00000106 	br	81114460 <getPreParsedPacket+0x100>
	} else {
		/* Couldn't get Mutex. (Should not get here since is a blocking call without timeout)*/
		vFailGetxMutexPreParsedParserRxTask();
8111445c:	111c2200 	call	8111c220 <vFailGetxMutexPreParsedParserRxTask>
	}
	return bSuccess;
81114460:	e0bffd17 	ldw	r2,-12(fp)
}
81114464:	e037883a 	mov	sp,fp
81114468:	dfc00117 	ldw	ra,4(sp)
8111446c:	df000017 	ldw	fp,0(sp)
81114470:	dec00204 	addi	sp,sp,8
81114474:	f800283a 	ret

81114478 <bSendMessagePUStoMebTask>:

/* Search for some free location in the xPus array to put the full command to send to the meb task */
bool bSendMessagePUStoMebTask( tTMPus *xPusL ) {
81114478:	defffa04 	addi	sp,sp,-24
8111447c:	de00012e 	bgeu	sp,et,81114484 <bSendMessagePUStoMebTask+0xc>
81114480:	003b68fa 	trap	3
81114484:	dfc00515 	stw	ra,20(sp)
81114488:	df000415 	stw	fp,16(sp)
8111448c:	df000404 	addi	fp,sp,16
81114490:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81114494:	e03ffc15 	stw	zero,-16(fp)
    INT8U error_code;
    tQMask xCdmLocal;
    unsigned char i = 0;
81114498:	e03ffd05 	stb	zero,-12(fp)

    bSuccess = FALSE;
8111449c:	e03ffc15 	stw	zero,-16(fp)
    xCdmLocal.ulWord = 0;
811144a0:	e03ffe15 	stw	zero,-8(fp)
    OSMutexPend(xMutexPus, 10, &error_code); /* Try to get mutex that protects the xPus buffer. Wait max 10 ticks = 10 ms */
811144a4:	d0a07317 	ldw	r2,-32308(gp)
811144a8:	e0fffd44 	addi	r3,fp,-11
811144ac:	180d883a 	mov	r6,r3
811144b0:	01400284 	movi	r5,10
811144b4:	1009883a 	mov	r4,r2
811144b8:	113cb0c0 	call	8113cb0c <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
811144bc:	e0bffd43 	ldbu	r2,-11(fp)
811144c0:	10803fcc 	andi	r2,r2,255
811144c4:	1000401e 	bne	r2,zero,811145c8 <bSendMessagePUStoMebTask+0x150>

        for(i = 0; i < N_PUS_PIPE; i++)
811144c8:	e03ffd05 	stb	zero,-12(fp)
811144cc:	00003806 	br	811145b0 <bSendMessagePUStoMebTask+0x138>
        {
            if ( xPus[i].bInUse == FALSE ) {
811144d0:	e0fffd03 	ldbu	r3,-12(fp)
811144d4:	00a04574 	movhi	r2,33045
811144d8:	10987a04 	addi	r2,r2,25064
811144dc:	18c01524 	muli	r3,r3,84
811144e0:	10c5883a 	add	r2,r2,r3
811144e4:	10800104 	addi	r2,r2,4
811144e8:	10800017 	ldw	r2,0(r2)
811144ec:	10002d1e 	bne	r2,zero,811145a4 <bSendMessagePUStoMebTask+0x12c>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
            	xPus[i] = (*xPusL);
811144f0:	e0fffd03 	ldbu	r3,-12(fp)
811144f4:	00a04574 	movhi	r2,33045
811144f8:	10987a04 	addi	r2,r2,25064
811144fc:	18c01524 	muli	r3,r3,84
81114500:	10c7883a 	add	r3,r2,r3
81114504:	e0bfff17 	ldw	r2,-4(fp)
81114508:	1009883a 	mov	r4,r2
8111450c:	00801504 	movi	r2,84
81114510:	100d883a 	mov	r6,r2
81114514:	200b883a 	mov	r5,r4
81114518:	1809883a 	mov	r4,r3
8111451c:	11226900 	call	81122690 <memcpy>
            	xPus[i].bInUse = TRUE;
81114520:	e0fffd03 	ldbu	r3,-12(fp)
81114524:	00a04574 	movhi	r2,33045
81114528:	10987a04 	addi	r2,r2,25064
8111452c:	18c01524 	muli	r3,r3,84
81114530:	10c5883a 	add	r2,r2,r3
81114534:	10800104 	addi	r2,r2,4
81114538:	00c00044 	movi	r3,1
8111453c:	10c00015 	stw	r3,0(r2)

            	/* Build the command to Meb using the Mask Queue */
            	xCdmLocal.ucByte[3] = M_MEB_ADDR;
81114540:	00800044 	movi	r2,1
81114544:	e0bffec5 	stb	r2,-5(fp)
            	xCdmLocal.ucByte[2] = Q_MEB_PUS;
81114548:	00800044 	movi	r2,1
8111454c:	e0bffe85 	stb	r2,-6(fp)

            	/* Sync the Meb task and tell that has a PUS command waiting */
            	error_code = OSQPost(xMebQ, (void *)xCdmLocal.ulWord);
81114550:	d0a06917 	ldw	r2,-32348(gp)
81114554:	e0fffe17 	ldw	r3,-8(fp)
81114558:	180b883a 	mov	r5,r3
8111455c:	1009883a 	mov	r4,r2
81114560:	113e0280 	call	8113e028 <OSQPost>
81114564:	e0bffd45 	stb	r2,-11(fp)
                if ( error_code != OS_ERR_NONE ) {
81114568:	e0bffd43 	ldbu	r2,-11(fp)
8111456c:	10803fcc 	andi	r2,r2,255
81114570:	10000926 	beq	r2,zero,81114598 <bSendMessagePUStoMebTask+0x120>
                	vFailSendPUStoMebTask();
81114574:	111d1100 	call	8111d110 <vFailSendPUStoMebTask>
                	xPus[i].bInUse = FALSE;
81114578:	e0fffd03 	ldbu	r3,-12(fp)
8111457c:	00a04574 	movhi	r2,33045
81114580:	10987a04 	addi	r2,r2,25064
81114584:	18c01524 	muli	r3,r3,84
81114588:	10c5883a 	add	r2,r2,r3
8111458c:	10800104 	addi	r2,r2,4
81114590:	10000015 	stw	zero,0(r2)
                } else
                    bSuccess = TRUE;
                break;
81114594:	00000906 	br	811145bc <bSendMessagePUStoMebTask+0x144>
            	error_code = OSQPost(xMebQ, (void *)xCdmLocal.ulWord);
                if ( error_code != OS_ERR_NONE ) {
                	vFailSendPUStoMebTask();
                	xPus[i].bInUse = FALSE;
                } else
                    bSuccess = TRUE;
81114598:	00800044 	movi	r2,1
8111459c:	e0bffc15 	stw	r2,-16(fp)
                break;
811145a0:	00000606 	br	811145bc <bSendMessagePUStoMebTask+0x144>
    bSuccess = FALSE;
    xCdmLocal.ulWord = 0;
    OSMutexPend(xMutexPus, 10, &error_code); /* Try to get mutex that protects the xPus buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {

        for(i = 0; i < N_PUS_PIPE; i++)
811145a4:	e0bffd03 	ldbu	r2,-12(fp)
811145a8:	10800044 	addi	r2,r2,1
811145ac:	e0bffd05 	stb	r2,-12(fp)
811145b0:	e0bffd03 	ldbu	r2,-12(fp)
811145b4:	10800130 	cmpltui	r2,r2,4
811145b8:	103fc51e 	bne	r2,zero,811144d0 <__reset+0xfb0f44d0>
                } else
                    bSuccess = TRUE;
                break;
            }
        }
        OSMutexPost(xMutexPus);
811145bc:	d0a07317 	ldw	r2,-32308(gp)
811145c0:	1009883a 	mov	r4,r2
811145c4:	113d0b00 	call	8113d0b0 <OSMutexPost>
    }

    return bSuccess;
811145c8:	e0bffc17 	ldw	r2,-16(fp)
}
811145cc:	e037883a 	mov	sp,fp
811145d0:	dfc00117 	ldw	ra,4(sp)
811145d4:	df000017 	ldw	fp,0(sp)
811145d8:	dec00204 	addi	sp,sp,8
811145dc:	f800283a 	ret

811145e0 <vReceiverUartTask>:


#include "receiver_uart_task.h"


void vReceiverUartTask(void *task_data) {
811145e0:	deffab04 	addi	sp,sp,-340
811145e4:	de00012e 	bgeu	sp,et,811145ec <vReceiverUartTask+0xc>
811145e8:	003b68fa 	trap	3
811145ec:	dfc05415 	stw	ra,336(sp)
811145f0:	df005315 	stw	fp,332(sp)
811145f4:	df005304 	addi	fp,sp,332
811145f8:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
811145fc:	e03fae15 	stw	zero,-328(fp)
    char cReceive[SIZE_RCV_BUFFER+64];
    tReaderStates eReaderRXMode;
    static tPreParsed xPreParsedReader;

    #ifdef DEBUG_ON
        debug(fp,"Receiver UART Task. (Task on)\n");
81114600:	d0a06217 	ldw	r2,-32376(gp)
81114604:	100f883a 	mov	r7,r2
81114608:	01800784 	movi	r6,30
8111460c:	01400044 	movi	r5,1
81114610:	01204574 	movhi	r4,33045
81114614:	2137d104 	addi	r4,r4,-8380
81114618:	1121c7c0 	call	81121c7c <fwrite>
    #endif

    eReaderRXMode = sRConfiguring;
8111461c:	e03fad15 	stw	zero,-332(fp)

    for(;;) {

        switch (eReaderRXMode)
81114620:	e0bfad17 	ldw	r2,-332(fp)
81114624:	10c00060 	cmpeqi	r3,r2,1
81114628:	1800091e 	bne	r3,zero,81114650 <vReceiverUartTask+0x70>
8111462c:	0080052e 	bgeu	zero,r2,81114644 <vReceiverUartTask+0x64>
81114630:	10c000a0 	cmpeqi	r3,r2,2
81114634:	18005d1e 	bne	r3,zero,811147ac <vReceiverUartTask+0x1cc>
81114638:	108000e0 	cmpeqi	r2,r2,3
8111463c:	10006e1e 	bne	r2,zero,811147f8 <vReceiverUartTask+0x218>
81114640:	00007706 	br	81114820 <vReceiverUartTask+0x240>
        {
            case sRConfiguring:
                /* For future implementations */
                eReaderRXMode = sGetRxUart;
81114644:	00800044 	movi	r2,1
81114648:	e0bfad15 	stw	r2,-332(fp)
                break;
8111464c:	00007706 	br	8111482c <vReceiverUartTask+0x24c>
            case sGetRxUart:

                memset(cReceiveBuffer, 0, SIZE_RCV_BUFFER);
81114650:	e0bfaf04 	addi	r2,fp,-324
81114654:	01802004 	movi	r6,128
81114658:	000b883a 	mov	r5,zero
8111465c:	1009883a 	mov	r4,r2
81114660:	11227e00 	call	811227e0 <memset>
                scanf("%s", cReceive);
81114664:	e0bfcf04 	addi	r2,fp,-196
81114668:	100b883a 	mov	r5,r2
8111466c:	01204574 	movhi	r4,33045
81114670:	2137d904 	addi	r4,r4,-8348
81114674:	1122e940 	call	81122e94 <scanf>
                memcpy(cReceiveBuffer, cReceive, (SIZE_RCV_BUFFER -1) ); /* Make that there's a zero terminator */
81114678:	e0ffcf04 	addi	r3,fp,-196
8111467c:	e0bfaf04 	addi	r2,fp,-324
81114680:	01801fc4 	movi	r6,127
81114684:	180b883a 	mov	r5,r3
81114688:	1009883a 	mov	r4,r2
8111468c:	11226900 	call	81122690 <memcpy>
                bSuccess = bPreParserV2( cReceiveBuffer , &xPreParsedReader );
81114690:	e0bfaf04 	addi	r2,fp,-324
81114694:	01604574 	movhi	r5,33045
81114698:	294dea04 	addi	r5,r5,14248
8111469c:	1009883a 	mov	r4,r2
811146a0:	1114c840 	call	81114c84 <bPreParserV2>
811146a4:	e0bfae15 	stw	r2,-328(fp)

                if ( bSuccess == TRUE ) {
811146a8:	e0bfae17 	ldw	r2,-328(fp)
811146ac:	10800058 	cmpnei	r2,r2,1
811146b0:	1000281e 	bne	r2,zero,81114754 <vReceiverUartTask+0x174>

                    if ( (xPreParsedReader.cType == START_REQUEST_CHAR) || (xPreParsedReader.cType == START_REPLY_CHAR) ) {
811146b4:	00a04574 	movhi	r2,33045
811146b8:	108dea04 	addi	r2,r2,14248
811146bc:	10800103 	ldbu	r2,4(r2)
811146c0:	10803fcc 	andi	r2,r2,255
811146c4:	1080201c 	xori	r2,r2,128
811146c8:	10bfe004 	addi	r2,r2,-128
811146cc:	10800fe0 	cmpeqi	r2,r2,63
811146d0:	1000081e 	bne	r2,zero,811146f4 <vReceiverUartTask+0x114>
811146d4:	00a04574 	movhi	r2,33045
811146d8:	108dea04 	addi	r2,r2,14248
811146dc:	10800103 	ldbu	r2,4(r2)
811146e0:	10803fcc 	andi	r2,r2,255
811146e4:	1080201c 	xori	r2,r2,128
811146e8:	10bfe004 	addi	r2,r2,-128
811146ec:	10800858 	cmpnei	r2,r2,33
811146f0:	1000031e 	bne	r2,zero,81114700 <vReceiverUartTask+0x120>
                        /* The packet is a request or reply sent by the NUC*/
                        eReaderRXMode = sSendToParser;
811146f4:	00800084 	movi	r2,2
811146f8:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
811146fc:	00004b06 	br	8111482c <vReceiverUartTask+0x24c>
                        /* The packet is a request or reply sent by the NUC*/
                        eReaderRXMode = sSendToParser;
                    } else {
                        /* The packet is an ACK or NACK sent by the NUC*/
                        /* If is a Nack, do nothing. The packet will be retransmited by the timeout checker. */
                        if ( xPreParsedReader.cType == NACK_CHAR ) {
81114700:	00a04574 	movhi	r2,33045
81114704:	108dea04 	addi	r2,r2,14248
81114708:	10800103 	ldbu	r2,4(r2)
8111470c:	10803fcc 	andi	r2,r2,255
81114710:	1080201c 	xori	r2,r2,128
81114714:	10bfe004 	addi	r2,r2,-128
81114718:	108008d8 	cmpnei	r2,r2,35
8111471c:	10000a1e 	bne	r2,zero,81114748 <vReceiverUartTask+0x168>
                            eReaderRXMode = sGetRxUart;
81114720:	00800044 	movi	r2,1
81114724:	e0bfad15 	stw	r2,-332(fp)
                            #ifdef DEBUG_ON
                                debug(fp,"Nack Received. Do nothing!\n");
81114728:	d0a06217 	ldw	r2,-32376(gp)
8111472c:	100f883a 	mov	r7,r2
81114730:	018006c4 	movi	r6,27
81114734:	01400044 	movi	r5,1
81114738:	01204574 	movhi	r4,33045
8111473c:	2137da04 	addi	r4,r4,-8344
81114740:	1121c7c0 	call	81121c7c <fwrite>
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
81114744:	00003906 	br	8111482c <vReceiverUartTask+0x24c>
                            eReaderRXMode = sGetRxUart;
                            #ifdef DEBUG_ON
                                debug(fp,"Nack Received. Do nothing!\n");
                            #endif
                        } else
                            eReaderRXMode = sSendToACKReceiver;
81114748:	008000c4 	movi	r2,3
8111474c:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
81114750:	00003606 	br	8111482c <vReceiverUartTask+0x24c>

                    }

                } else {
                    /*Should Send NACK - Mocking value the only parte that metters is the "cType = '#'" part */
                    xPreParsedReader.cType = '#';
81114754:	00a04574 	movhi	r2,33045
81114758:	108dea04 	addi	r2,r2,14248
8111475c:	00c008c4 	movi	r3,35
81114760:	10c00105 	stb	r3,4(r2)
                    xPreParsedReader.cCommand = '.';
81114764:	00a04574 	movhi	r2,33045
81114768:	108dea04 	addi	r2,r2,14248
8111476c:	00c00b84 	movi	r3,46
81114770:	10c00145 	stb	r3,5(r2)
                    xPreParsedReader.usiValues[0] = 1;
81114774:	00a04574 	movhi	r2,33045
81114778:	108dea04 	addi	r2,r2,14248
8111477c:	00c00044 	movi	r3,1
81114780:	10c0020d 	sth	r3,8(r2)

                    /*Try to send ack to the Ack Sender Task*/
                    bSuccess = setPreAckSenderFreePos( &xPreParsedReader );
81114784:	01204574 	movhi	r4,33045
81114788:	210dea04 	addi	r4,r4,14248
8111478c:	111496c0 	call	8111496c <setPreAckSenderFreePos>
81114790:	e0bfae15 	stw	r2,-328(fp)
                    if ( bSuccess == FALSE ) {
81114794:	e0bfae17 	ldw	r2,-328(fp)
81114798:	1000011e 	bne	r2,zero,811147a0 <vReceiverUartTask+0x1c0>
                        vFailSendNack();
8111479c:	111c3580 	call	8111c358 <vFailSendNack>
                    }
                    eReaderRXMode = sGetRxUart;
811147a0:	00800044 	movi	r2,1
811147a4:	e0bfad15 	stw	r2,-332(fp)
                }

                break;
811147a8:	00002006 	br	8111482c <vReceiverUartTask+0x24c>
            case sSendToParser:

                /* Try to send ack to the Ack Sender Task*/
                bSuccess = setPreAckSenderFreePos( &xPreParsedReader );
811147ac:	01204574 	movhi	r4,33045
811147b0:	210dea04 	addi	r4,r4,14248
811147b4:	111496c0 	call	8111496c <setPreAckSenderFreePos>
811147b8:	e0bfae15 	stw	r2,-328(fp)
                if ( bSuccess == TRUE ) {
811147bc:	e0bfae17 	ldw	r2,-328(fp)
811147c0:	10800058 	cmpnei	r2,r2,1
811147c4:	1000081e 	bne	r2,zero,811147e8 <vReceiverUartTask+0x208>
                    /* If was possible to send ack, then try to send the command to the Parser Task*/
                    bSuccess = setPreParsedFreePos( &xPreParsedReader );
811147c8:	01204574 	movhi	r4,33045
811147cc:	210dea04 	addi	r4,r4,14248
811147d0:	11148300 	call	81114830 <setPreParsedFreePos>
811147d4:	e0bfae15 	stw	r2,-328(fp)
                    if ( bSuccess == FALSE ) {
811147d8:	e0bfae17 	ldw	r2,-328(fp)
811147dc:	1000031e 	bne	r2,zero,811147ec <vReceiverUartTask+0x20c>
                        //TODO
                        /* At this point ack was sent but the command was not sent to the Parser task
                           should sent an error message for the NUC and maye to the SGSE*/
                        vFailSetPreParsedBuffer();
811147e0:	111c4280 	call	8111c428 <vFailSetPreParsedBuffer>
811147e4:	00000106 	br	811147ec <vReceiverUartTask+0x20c>
                    }
                } else {
                    vFailSetPreAckSenderBuffer();
811147e8:	111c3c00 	call	8111c3c0 <vFailSetPreAckSenderBuffer>
                }
                /* If is not possible to send the ACK for this command then we don't process the command,
                   because it will be sent again by the NUC and we won't wast processing performing the command twice.*/
                eReaderRXMode = sGetRxUart;
811147ec:	00800044 	movi	r2,1
811147f0:	e0bfad15 	stw	r2,-332(fp)
                break;
811147f4:	00000d06 	br	8111482c <vReceiverUartTask+0x24c>
            case sSendToACKReceiver:

                bSuccess = setPreAckReceiverFreePos( &xPreParsedReader );
811147f8:	01204574 	movhi	r4,33045
811147fc:	210dea04 	addi	r4,r4,14248
81114800:	1114ae80 	call	81114ae8 <setPreAckReceiverFreePos>
81114804:	e0bfae15 	stw	r2,-328(fp)
                if ( bSuccess == FALSE ) {
81114808:	e0bfae17 	ldw	r2,-328(fp)
8111480c:	1000011e 	bne	r2,zero,81114814 <vReceiverUartTask+0x234>
                    /*If was not possible to receive the ack do nothing.*/
                    vFailSetPreAckReceiverBuffer();
81114810:	111c4900 	call	8111c490 <vFailSetPreAckReceiverBuffer>
                }
                eReaderRXMode = sGetRxUart;
81114814:	00800044 	movi	r2,1
81114818:	e0bfad15 	stw	r2,-332(fp)
                break;
8111481c:	00000306 	br	8111482c <vReceiverUartTask+0x24c>
            default:
                eReaderRXMode = sGetRxUart;
81114820:	00800044 	movi	r2,1
81114824:	e0bfad15 	stw	r2,-332(fp)
                break;
81114828:	0001883a 	nop
        }

    }
8111482c:	003f7c06 	br	81114620 <__reset+0xfb0f4620>

81114830 <setPreParsedFreePos>:
}


/* Search for a Free location to put the pre parsed packet in the pipe for the ParserTask */
bool setPreParsedFreePos( tPreParsed *xPrePReader ) {
81114830:	defffb04 	addi	sp,sp,-20
81114834:	de00012e 	bgeu	sp,et,8111483c <setPreParsedFreePos+0xc>
81114838:	003b68fa 	trap	3
8111483c:	dfc00415 	stw	ra,16(sp)
81114840:	df000315 	stw	fp,12(sp)
81114844:	df000304 	addi	fp,sp,12
81114848:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8111484c:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
81114850:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
81114854:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexPreParsed, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
81114858:	d0a06b17 	ldw	r2,-32340(gp)
8111485c:	e0fffe44 	addi	r3,fp,-7
81114860:	180d883a 	mov	r6,r3
81114864:	01400284 	movi	r5,10
81114868:	1009883a 	mov	r4,r2
8111486c:	113cb0c0 	call	8113cb0c <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
81114870:	e0bffe43 	ldbu	r2,-7(fp)
81114874:	10803fcc 	andi	r2,r2,255
81114878:	1000361e 	bne	r2,zero,81114954 <setPreParsedFreePos+0x124>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_PREPARSED_ENTRIES; i++ )
8111487c:	e03ffe05 	stb	zero,-8(fp)
81114880:	00002e06 	br	8111493c <setPreParsedFreePos+0x10c>
        {
            if ( xPreParsed[i].cType == 0 ) {
81114884:	e0fffe03 	ldbu	r3,-8(fp)
81114888:	00a045b4 	movhi	r2,33046
8111488c:	109b5804 	addi	r2,r2,28000
81114890:	18c01324 	muli	r3,r3,76
81114894:	10c5883a 	add	r2,r2,r3
81114898:	10800104 	addi	r2,r2,4
8111489c:	10800003 	ldbu	r2,0(r2)
811148a0:	10803fcc 	andi	r2,r2,255
811148a4:	1080201c 	xori	r2,r2,128
811148a8:	10bfe004 	addi	r2,r2,-128
811148ac:	1000201e 	bne	r2,zero,81114930 <setPreParsedFreePos+0x100>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xPreParsed[i] = (*xPrePReader);
811148b0:	e0fffe03 	ldbu	r3,-8(fp)
811148b4:	00a045b4 	movhi	r2,33046
811148b8:	109b5804 	addi	r2,r2,28000
811148bc:	18c01324 	muli	r3,r3,76
811148c0:	10c7883a 	add	r3,r2,r3
811148c4:	e0bfff17 	ldw	r2,-4(fp)
811148c8:	1009883a 	mov	r4,r2
811148cc:	00801304 	movi	r2,76
811148d0:	100d883a 	mov	r6,r2
811148d4:	200b883a 	mov	r5,r4
811148d8:	1809883a 	mov	r4,r3
811148dc:	11226900 	call	81122690 <memcpy>
                error_code = OSSemPost(xSemCountPreParsed);
811148e0:	d0a06417 	ldw	r2,-32368(gp)
811148e4:	1009883a 	mov	r4,r2
811148e8:	113eea00 	call	8113eea0 <OSSemPost>
811148ec:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code == OS_ERR_NONE ) {
811148f0:	e0bffe43 	ldbu	r2,-7(fp)
811148f4:	10803fcc 	andi	r2,r2,255
811148f8:	1000031e 	bne	r2,zero,81114908 <setPreParsedFreePos+0xd8>
                    bSuccess = TRUE;
811148fc:	00800044 	movi	r2,1
81114900:	e0bffd15 	stw	r2,-12(fp)
                } else {
                    vFailSendPreParsedSemaphore();
                    xPreParsed[i].cType = 0;
                    bSuccess = FALSE;
                }
                break;
81114904:	00001006 	br	81114948 <setPreParsedFreePos+0x118>
                xPreParsed[i] = (*xPrePReader);
                error_code = OSSemPost(xSemCountPreParsed);
                if ( error_code == OS_ERR_NONE ) {
                    bSuccess = TRUE;
                } else {
                    vFailSendPreParsedSemaphore();
81114908:	111ba780 	call	8111ba78 <vFailSendPreParsedSemaphore>
                    xPreParsed[i].cType = 0;
8111490c:	e0fffe03 	ldbu	r3,-8(fp)
81114910:	00a045b4 	movhi	r2,33046
81114914:	109b5804 	addi	r2,r2,28000
81114918:	18c01324 	muli	r3,r3,76
8111491c:	10c5883a 	add	r2,r2,r3
81114920:	10800104 	addi	r2,r2,4
81114924:	10000005 	stb	zero,0(r2)
                    bSuccess = FALSE;
81114928:	e03ffd15 	stw	zero,-12(fp)
                }
                break;
8111492c:	00000606 	br	81114948 <setPreParsedFreePos+0x118>
    bSuccess = FALSE;
    OSMutexPend(xMutexPreParsed, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_PREPARSED_ENTRIES; i++ )
81114930:	e0bffe03 	ldbu	r2,-8(fp)
81114934:	10800044 	addi	r2,r2,1
81114938:	e0bffe05 	stb	r2,-8(fp)
8111493c:	e0bffe03 	ldbu	r2,-8(fp)
81114940:	10800230 	cmpltui	r2,r2,8
81114944:	103fcf1e 	bne	r2,zero,81114884 <__reset+0xfb0f4884>
                    bSuccess = FALSE;
                }
                break;
            }
        }
        OSMutexPost(xMutexPreParsed);
81114948:	d0a06b17 	ldw	r2,-32340(gp)
8111494c:	1009883a 	mov	r4,r2
81114950:	113d0b00 	call	8113d0b0 <OSMutexPost>
    }
    return bSuccess;
81114954:	e0bffd17 	ldw	r2,-12(fp)
}
81114958:	e037883a 	mov	sp,fp
8111495c:	dfc00117 	ldw	ra,4(sp)
81114960:	df000017 	ldw	fp,0(sp)
81114964:	dec00204 	addi	sp,sp,8
81114968:	f800283a 	ret

8111496c <setPreAckSenderFreePos>:



/* Search for some free location in the xSenderACK array, that comunicates with the AckSenderTask */
bool setPreAckSenderFreePos( tPreParsed *xPrePReader ) {
8111496c:	defffb04 	addi	sp,sp,-20
81114970:	de00012e 	bgeu	sp,et,81114978 <setPreAckSenderFreePos+0xc>
81114974:	003b68fa 	trap	3
81114978:	dfc00415 	stw	ra,16(sp)
8111497c:	df000315 	stw	fp,12(sp)
81114980:	df000304 	addi	fp,sp,12
81114984:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81114988:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
8111498c:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
81114990:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexSenderACK, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
81114994:	d0a07217 	ldw	r2,-32312(gp)
81114998:	e0fffe44 	addi	r3,fp,-7
8111499c:	180d883a 	mov	r6,r3
811149a0:	01400284 	movi	r5,10
811149a4:	1009883a 	mov	r4,r2
811149a8:	113cb0c0 	call	8113cb0c <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
811149ac:	e0bffe43 	ldbu	r2,-7(fp)
811149b0:	10803fcc 	andi	r2,r2,255
811149b4:	1000461e 	bne	r2,zero,81114ad0 <setPreAckSenderFreePos+0x164>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for(i = 0; i < N_ACKS_SENDER; i++)
811149b8:	e03ffe05 	stb	zero,-8(fp)
811149bc:	00003e06 	br	81114ab8 <setPreAckSenderFreePos+0x14c>
        {
            if ( xSenderACK[i].cType == 0 ) {
811149c0:	e0fffe03 	ldbu	r3,-8(fp)
811149c4:	00a045b4 	movhi	r2,33046
811149c8:	109b5004 	addi	r2,r2,27968
811149cc:	18c7883a 	add	r3,r3,r3
811149d0:	18c7883a 	add	r3,r3,r3
811149d4:	10c5883a 	add	r2,r2,r3
811149d8:	10800003 	ldbu	r2,0(r2)
811149dc:	10803fcc 	andi	r2,r2,255
811149e0:	1080201c 	xori	r2,r2,128
811149e4:	10bfe004 	addi	r2,r2,-128
811149e8:	1000301e 	bne	r2,zero,81114aac <setPreAckSenderFreePos+0x140>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xSenderACK[i].cType = xPrePReader->cType;
811149ec:	e0fffe03 	ldbu	r3,-8(fp)
811149f0:	e0bfff17 	ldw	r2,-4(fp)
811149f4:	11000103 	ldbu	r4,4(r2)
811149f8:	00a045b4 	movhi	r2,33046
811149fc:	109b5004 	addi	r2,r2,27968
81114a00:	18c7883a 	add	r3,r3,r3
81114a04:	18c7883a 	add	r3,r3,r3
81114a08:	10c5883a 	add	r2,r2,r3
81114a0c:	11000005 	stb	r4,0(r2)
                xSenderACK[i].cCommand = xPrePReader->cCommand;
81114a10:	e0fffe03 	ldbu	r3,-8(fp)
81114a14:	e0bfff17 	ldw	r2,-4(fp)
81114a18:	11000143 	ldbu	r4,5(r2)
81114a1c:	00a045b4 	movhi	r2,33046
81114a20:	109b5004 	addi	r2,r2,27968
81114a24:	18c7883a 	add	r3,r3,r3
81114a28:	18c7883a 	add	r3,r3,r3
81114a2c:	10c5883a 	add	r2,r2,r3
81114a30:	10800044 	addi	r2,r2,1
81114a34:	11000005 	stb	r4,0(r2)
                xSenderACK[i].usiId = xPrePReader->usiValues[0]; /*The first value is always the command id*/
81114a38:	e0fffe03 	ldbu	r3,-8(fp)
81114a3c:	e0bfff17 	ldw	r2,-4(fp)
81114a40:	1100020b 	ldhu	r4,8(r2)
81114a44:	00a045b4 	movhi	r2,33046
81114a48:	109b5004 	addi	r2,r2,27968
81114a4c:	18c7883a 	add	r3,r3,r3
81114a50:	18c7883a 	add	r3,r3,r3
81114a54:	10c5883a 	add	r2,r2,r3
81114a58:	10800084 	addi	r2,r2,2
81114a5c:	1100000d 	sth	r4,0(r2)

                error_code = OSSemPost(xSemCountSenderACK);
81114a60:	d0a06117 	ldw	r2,-32380(gp)
81114a64:	1009883a 	mov	r4,r2
81114a68:	113eea00 	call	8113eea0 <OSSemPost>
81114a6c:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code != OS_ERR_NONE ) {
81114a70:	e0bffe43 	ldbu	r2,-7(fp)
81114a74:	10803fcc 	andi	r2,r2,255
81114a78:	10000926 	beq	r2,zero,81114aa0 <setPreAckSenderFreePos+0x134>
                    vFailSendPreAckSenderSemaphore();
81114a7c:	111bb100 	call	8111bb10 <vFailSendPreAckSenderSemaphore>
                    xSenderACK[i].cType = 0;
81114a80:	e0fffe03 	ldbu	r3,-8(fp)
81114a84:	00a045b4 	movhi	r2,33046
81114a88:	109b5004 	addi	r2,r2,27968
81114a8c:	18c7883a 	add	r3,r3,r3
81114a90:	18c7883a 	add	r3,r3,r3
81114a94:	10c5883a 	add	r2,r2,r3
81114a98:	10000005 	stb	zero,0(r2)
                } else
                    bSuccess = TRUE;
                break;
81114a9c:	00000906 	br	81114ac4 <setPreAckSenderFreePos+0x158>
                error_code = OSSemPost(xSemCountSenderACK);
                if ( error_code != OS_ERR_NONE ) {
                    vFailSendPreAckSenderSemaphore();
                    xSenderACK[i].cType = 0;
                } else
                    bSuccess = TRUE;
81114aa0:	00800044 	movi	r2,1
81114aa4:	e0bffd15 	stw	r2,-12(fp)
                break;
81114aa8:	00000606 	br	81114ac4 <setPreAckSenderFreePos+0x158>
    bSuccess = FALSE;
    OSMutexPend(xMutexSenderACK, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for(i = 0; i < N_ACKS_SENDER; i++)
81114aac:	e0bffe03 	ldbu	r2,-8(fp)
81114ab0:	10800044 	addi	r2,r2,1
81114ab4:	e0bffe05 	stb	r2,-8(fp)
81114ab8:	e0bffe03 	ldbu	r2,-8(fp)
81114abc:	10800230 	cmpltui	r2,r2,8
81114ac0:	103fbf1e 	bne	r2,zero,811149c0 <__reset+0xfb0f49c0>
                } else
                    bSuccess = TRUE;
                break;
            }
        }
        OSMutexPost(xMutexSenderACK);
81114ac4:	d0a07217 	ldw	r2,-32312(gp)
81114ac8:	1009883a 	mov	r4,r2
81114acc:	113d0b00 	call	8113d0b0 <OSMutexPost>
    }

    return bSuccess;
81114ad0:	e0bffd17 	ldw	r2,-12(fp)
}
81114ad4:	e037883a 	mov	sp,fp
81114ad8:	dfc00117 	ldw	ra,4(sp)
81114adc:	df000017 	ldw	fp,0(sp)
81114ae0:	dec00204 	addi	sp,sp,8
81114ae4:	f800283a 	ret

81114ae8 <setPreAckReceiverFreePos>:

/* Search for some free location in the xSenderACK array, that comunicates with the AckSenderTask */
bool setPreAckReceiverFreePos( tPreParsed *xPrePReader ) {
81114ae8:	defffb04 	addi	sp,sp,-20
81114aec:	de00012e 	bgeu	sp,et,81114af4 <setPreAckReceiverFreePos+0xc>
81114af0:	003b68fa 	trap	3
81114af4:	dfc00415 	stw	ra,16(sp)
81114af8:	df000315 	stw	fp,12(sp)
81114afc:	df000304 	addi	fp,sp,12
81114b00:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81114b04:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
81114b08:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
81114b0c:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexReceivedACK, 20, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait 20 ticks = 20 ms */
81114b10:	d0a06517 	ldw	r2,-32364(gp)
81114b14:	e0fffe44 	addi	r3,fp,-7
81114b18:	180d883a 	mov	r6,r3
81114b1c:	01400504 	movi	r5,20
81114b20:	1009883a 	mov	r4,r2
81114b24:	113cb0c0 	call	8113cb0c <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
81114b28:	e0bffe43 	ldbu	r2,-7(fp)
81114b2c:	10803fcc 	andi	r2,r2,255
81114b30:	1000471e 	bne	r2,zero,81114c50 <setPreAckReceiverFreePos+0x168>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_ACKS_RECEIVED; i++ )
81114b34:	e03ffe05 	stb	zero,-8(fp)
81114b38:	00003e06 	br	81114c34 <setPreAckReceiverFreePos+0x14c>
        {
            if ( xReceivedACK[i].cType == 0 ) {
81114b3c:	e0fffe03 	ldbu	r3,-8(fp)
81114b40:	00a045b4 	movhi	r2,33046
81114b44:	10853e04 	addi	r2,r2,5368
81114b48:	18c7883a 	add	r3,r3,r3
81114b4c:	18c7883a 	add	r3,r3,r3
81114b50:	10c5883a 	add	r2,r2,r3
81114b54:	10800003 	ldbu	r2,0(r2)
81114b58:	10803fcc 	andi	r2,r2,255
81114b5c:	1080201c 	xori	r2,r2,128
81114b60:	10bfe004 	addi	r2,r2,-128
81114b64:	1000301e 	bne	r2,zero,81114c28 <setPreAckReceiverFreePos+0x140>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xReceivedACK[i].cType = xPrePReader->cType;
81114b68:	e0fffe03 	ldbu	r3,-8(fp)
81114b6c:	e0bfff17 	ldw	r2,-4(fp)
81114b70:	11000103 	ldbu	r4,4(r2)
81114b74:	00a045b4 	movhi	r2,33046
81114b78:	10853e04 	addi	r2,r2,5368
81114b7c:	18c7883a 	add	r3,r3,r3
81114b80:	18c7883a 	add	r3,r3,r3
81114b84:	10c5883a 	add	r2,r2,r3
81114b88:	11000005 	stb	r4,0(r2)
                xReceivedACK[i].cCommand = xPrePReader->cCommand;
81114b8c:	e0fffe03 	ldbu	r3,-8(fp)
81114b90:	e0bfff17 	ldw	r2,-4(fp)
81114b94:	11000143 	ldbu	r4,5(r2)
81114b98:	00a045b4 	movhi	r2,33046
81114b9c:	10853e04 	addi	r2,r2,5368
81114ba0:	18c7883a 	add	r3,r3,r3
81114ba4:	18c7883a 	add	r3,r3,r3
81114ba8:	10c5883a 	add	r2,r2,r3
81114bac:	10800044 	addi	r2,r2,1
81114bb0:	11000005 	stb	r4,0(r2)
                xReceivedACK[i].usiId = xPrePReader->usiValues[0];
81114bb4:	e0fffe03 	ldbu	r3,-8(fp)
81114bb8:	e0bfff17 	ldw	r2,-4(fp)
81114bbc:	1100020b 	ldhu	r4,8(r2)
81114bc0:	00a045b4 	movhi	r2,33046
81114bc4:	10853e04 	addi	r2,r2,5368
81114bc8:	18c7883a 	add	r3,r3,r3
81114bcc:	18c7883a 	add	r3,r3,r3
81114bd0:	10c5883a 	add	r2,r2,r3
81114bd4:	10800084 	addi	r2,r2,2
81114bd8:	1100000d 	sth	r4,0(r2)

                error_code = OSSemPost(xSemCountReceivedACK);
81114bdc:	d0a06617 	ldw	r2,-32360(gp)
81114be0:	1009883a 	mov	r4,r2
81114be4:	113eea00 	call	8113eea0 <OSSemPost>
81114be8:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code == OS_ERR_NONE ) {
81114bec:	e0bffe43 	ldbu	r2,-7(fp)
81114bf0:	10803fcc 	andi	r2,r2,255
81114bf4:	1000031e 	bne	r2,zero,81114c04 <setPreAckReceiverFreePos+0x11c>
                    bSuccess = TRUE;
81114bf8:	00800044 	movi	r2,1
81114bfc:	e0bffd15 	stw	r2,-12(fp)
                } else {
                    vFailSendPreAckReceiverSemaphore();
                    xReceivedACK[i].cType = 0;
                }
                break;
81114c00:	00000f06 	br	81114c40 <setPreAckReceiverFreePos+0x158>

                error_code = OSSemPost(xSemCountReceivedACK);
                if ( error_code == OS_ERR_NONE ) {
                    bSuccess = TRUE;
                } else {
                    vFailSendPreAckReceiverSemaphore();
81114c04:	111bac40 	call	8111bac4 <vFailSendPreAckReceiverSemaphore>
                    xReceivedACK[i].cType = 0;
81114c08:	e0fffe03 	ldbu	r3,-8(fp)
81114c0c:	00a045b4 	movhi	r2,33046
81114c10:	10853e04 	addi	r2,r2,5368
81114c14:	18c7883a 	add	r3,r3,r3
81114c18:	18c7883a 	add	r3,r3,r3
81114c1c:	10c5883a 	add	r2,r2,r3
81114c20:	10000005 	stb	zero,0(r2)
                }
                break;
81114c24:	00000606 	br	81114c40 <setPreAckReceiverFreePos+0x158>
    bSuccess = FALSE;
    OSMutexPend(xMutexReceivedACK, 20, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait 20 ticks = 20 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_ACKS_RECEIVED; i++ )
81114c28:	e0bffe03 	ldbu	r2,-8(fp)
81114c2c:	10800044 	addi	r2,r2,1
81114c30:	e0bffe05 	stb	r2,-8(fp)
81114c34:	e0bffe03 	ldbu	r2,-8(fp)
81114c38:	108001b0 	cmpltui	r2,r2,6
81114c3c:	103fbf1e 	bne	r2,zero,81114b3c <__reset+0xfb0f4b3c>
                    xReceivedACK[i].cType = 0;
                }
                break;
            }
        }
        OSMutexPost(xMutexReceivedACK);
81114c40:	d0a06517 	ldw	r2,-32364(gp)
81114c44:	1009883a 	mov	r4,r2
81114c48:	113d0b00 	call	8113d0b0 <OSMutexPost>
81114c4c:	00000706 	br	81114c6c <setPreAckReceiverFreePos+0x184>
    } else {
        /* Could not  */
        #ifdef DEBUG_ON
            debug(fp,"Could not put the ack packet receiveid in the queue. (setPreAckReceiverFreePos)\n");
81114c50:	d0a06217 	ldw	r2,-32376(gp)
81114c54:	100f883a 	mov	r7,r2
81114c58:	01801404 	movi	r6,80
81114c5c:	01400044 	movi	r5,1
81114c60:	01204574 	movhi	r4,33045
81114c64:	2137e104 	addi	r4,r4,-8316
81114c68:	1121c7c0 	call	81121c7c <fwrite>
        #endif
    }

    return bSuccess;
81114c6c:	e0bffd17 	ldw	r2,-12(fp)
}
81114c70:	e037883a 	mov	sp,fp
81114c74:	dfc00117 	ldw	ra,4(sp)
81114c78:	df000017 	ldw	fp,0(sp)
81114c7c:	dec00204 	addi	sp,sp,8
81114c80:	f800283a 	ret

81114c84 <bPreParserV2>:
/*  This function will parse the buffer into a command, will identify if is an request or reply
    also will separate all the values separated by ':'. If the command isn't complete (';' in the final)
    it will return false. */
    /* Max size of parsed value is 6 digits, for now*/
bool bPreParserV2( char *buffer, tPreParsed *xPerParcedBuffer )
{
81114c84:	defff404 	addi	sp,sp,-48
81114c88:	de00012e 	bgeu	sp,et,81114c90 <bPreParserV2+0xc>
81114c8c:	003b68fa 	trap	3
81114c90:	dfc00b15 	stw	ra,44(sp)
81114c94:	df000a15 	stw	fp,40(sp)
81114c98:	dc000915 	stw	r16,36(sp)
81114c9c:	df000a04 	addi	fp,sp,40
81114ca0:	e13ffd15 	stw	r4,-12(fp)
81114ca4:	e17ffe15 	stw	r5,-8(fp)
    bool bSuccess = FALSE;
81114ca8:	e03ff615 	stw	zero,-40(fp)
    unsigned char i;
	char c, *p_inteiro;
	char inteiro[6]; /* Max size of parsed value is 6 digits, for now */


    bSuccess = FALSE;
81114cac:	e03ff615 	stw	zero,-40(fp)

    siStrLen = strnlen(buffer, SIZE_RCV_BUFFER);
81114cb0:	01402004 	movi	r5,128
81114cb4:	e13ffd17 	ldw	r4,-12(fp)
81114cb8:	112321c0 	call	8112321c <strnlen>
81114cbc:	e0bff90d 	sth	r2,-28(fp)
    siTeminador = siPosStr(buffer, FINAL_CHAR);
81114cc0:	01400ec4 	movi	r5,59
81114cc4:	e13ffd17 	ldw	r4,-12(fp)
81114cc8:	111952c0 	call	8111952c <siPosStr>
81114ccc:	e0bff98d 	sth	r2,-26(fp)

    /* Check the protocol terminator char ';' */
    if ( (siTeminador != (siStrLen-1)) )
81114cd0:	e0fff98f 	ldh	r3,-26(fp)
81114cd4:	e0bff90f 	ldh	r2,-28(fp)
81114cd8:	10bfffc4 	addi	r2,r2,-1
81114cdc:	18800226 	beq	r3,r2,81114ce8 <bPreParserV2+0x64>
        return bSuccess;
81114ce0:	e0bff617 	ldw	r2,-40(fp)
81114ce4:	0000ba06 	br	81114fd0 <bPreParserV2+0x34c>

    siCRC = siPosStr(buffer, SEPARATOR_CRC);
81114ce8:	01401f04 	movi	r5,124
81114cec:	e13ffd17 	ldw	r4,-12(fp)
81114cf0:	111952c0 	call	8111952c <siPosStr>
81114cf4:	e0bffa0d 	sth	r2,-24(fp)

    /* Check if there's an CRC char */
    if ( siCRC > siTeminador )
81114cf8:	e0bffa0f 	ldh	r2,-24(fp)
81114cfc:	e0fff98f 	ldh	r3,-26(fp)
81114d00:	1880020e 	bge	r3,r2,81114d0c <bPreParserV2+0x88>
        return bSuccess;
81114d04:	e0bff617 	ldw	r2,-40(fp)
81114d08:	0000b106 	br	81114fd0 <bPreParserV2+0x34c>

    siIni = strcspn( buffer , ALL_INI_CHAR ); /* Verify if there's any one of the initial characters */
81114d0c:	01604574 	movhi	r5,33045
81114d10:	2977f604 	addi	r5,r5,-8232
81114d14:	e13ffd17 	ldw	r4,-12(fp)
81114d18:	11231380 	call	81123138 <strcspn>
81114d1c:	e0bffa8d 	sth	r2,-22(fp)

    /* Check if there's any initial char protocol and if is before the crc char */
    if ( siIni > siCRC)
81114d20:	e0bffa8f 	ldh	r2,-22(fp)
81114d24:	e0fffa0f 	ldh	r3,-24(fp)
81114d28:	1880020e 	bge	r3,r2,81114d34 <bPreParserV2+0xb0>
        return bSuccess;
81114d2c:	e0bff617 	ldw	r2,-40(fp)
81114d30:	0000a706 	br	81114fd0 <bPreParserV2+0x34c>

    
    /*" ---> At this point we validate the existence and position of all characters in for the protocol in the message "*/


    xPerParcedBuffer->cType = buffer[siIni];
81114d34:	e0bffa8f 	ldh	r2,-22(fp)
81114d38:	e0fffd17 	ldw	r3,-12(fp)
81114d3c:	1885883a 	add	r2,r3,r2
81114d40:	10c00003 	ldbu	r3,0(r2)
81114d44:	e0bffe17 	ldw	r2,-8(fp)
81114d48:	10c00105 	stb	r3,4(r2)
    if (xPerParcedBuffer->cType == NACK_CHAR ) {
81114d4c:	e0bffe17 	ldw	r2,-8(fp)
81114d50:	10800103 	ldbu	r2,4(r2)
81114d54:	10803fcc 	andi	r2,r2,255
81114d58:	1080201c 	xori	r2,r2,128
81114d5c:	10bfe004 	addi	r2,r2,-128
81114d60:	108008d8 	cmpnei	r2,r2,35
81114d64:	1000041e 	bne	r2,zero,81114d78 <bPreParserV2+0xf4>
        bSuccess = TRUE;
81114d68:	00800044 	movi	r2,1
81114d6c:	e0bff615 	stw	r2,-40(fp)
        return bSuccess;
81114d70:	e0bff617 	ldw	r2,-40(fp)
81114d74:	00009606 	br	81114fd0 <bPreParserV2+0x34c>


    /*" ---> At this point the packet is a Resquest, Reply or ACK packet"*/


    xPerParcedBuffer->ucCalculatedCRC8 = ucCrc8wInit( &buffer[siIni] , (siCRC - siIni) );
81114d78:	e0bffa8f 	ldh	r2,-22(fp)
81114d7c:	e0fffd17 	ldw	r3,-12(fp)
81114d80:	1889883a 	add	r4,r3,r2
81114d84:	e0fffa0f 	ldh	r3,-24(fp)
81114d88:	e0bffa8f 	ldh	r2,-22(fp)
81114d8c:	1885c83a 	sub	r2,r3,r2
81114d90:	100b883a 	mov	r5,r2
81114d94:	111b7200 	call	8111b720 <ucCrc8wInit>
81114d98:	1007883a 	mov	r3,r2
81114d9c:	e0bffe17 	ldw	r2,-8(fp)
81114da0:	10c01205 	stb	r3,72(r2)

    xPerParcedBuffer->cCommand = buffer[siIni+1];
81114da4:	e0bffa8f 	ldh	r2,-22(fp)
81114da8:	10800044 	addi	r2,r2,1
81114dac:	e0fffd17 	ldw	r3,-12(fp)
81114db0:	1885883a 	add	r2,r3,r2
81114db4:	10c00003 	ldbu	r3,0(r2)
81114db8:	e0bffe17 	ldw	r2,-8(fp)
81114dbc:	10c00145 	stb	r3,5(r2)
    xPerParcedBuffer->ucNofBytes = 0;
81114dc0:	e0bffe17 	ldw	r2,-8(fp)
81114dc4:	10000185 	stb	zero,6(r2)

    memset( xPerParcedBuffer->usiValues , 0x00 , sizeof(xPerParcedBuffer->usiValues) );
81114dc8:	e0bffe17 	ldw	r2,-8(fp)
81114dcc:	10800204 	addi	r2,r2,8
81114dd0:	01801004 	movi	r6,64
81114dd4:	000b883a 	mov	r5,zero
81114dd8:	1009883a 	mov	r4,r2
81114ddc:	11227e00 	call	811227e0 <memset>

    i = siIni + 3; /* "?C:i..." */
81114de0:	e0bffa8b 	ldhu	r2,-22(fp)
81114de4:	108000c4 	addi	r2,r2,3
81114de8:	e0bff705 	stb	r2,-36(fp)
    do {
        p_inteiro = inteiro;
81114dec:	e0bffb44 	addi	r2,fp,-19
81114df0:	e0bff815 	stw	r2,-32(fp)
        memset( &(inteiro) , 0 , sizeof( inteiro ) );
81114df4:	e0bffb44 	addi	r2,fp,-19
81114df8:	01800184 	movi	r6,6
81114dfc:	000b883a 	mov	r5,zero
81114e00:	1009883a 	mov	r4,r2
81114e04:	11227e00 	call	811227e0 <memset>
        do {
            c = buffer[i];
81114e08:	e0bff703 	ldbu	r2,-36(fp)
81114e0c:	e0fffd17 	ldw	r3,-12(fp)
81114e10:	1885883a 	add	r2,r3,r2
81114e14:	10800003 	ldbu	r2,0(r2)
81114e18:	e0bffb05 	stb	r2,-20(fp)
            if ( isdigit( c ) ) {
81114e1c:	d0e00317 	ldw	r3,-32756(gp)
81114e20:	e0bffb07 	ldb	r2,-20(fp)
81114e24:	10800044 	addi	r2,r2,1
81114e28:	1885883a 	add	r2,r3,r2
81114e2c:	10800003 	ldbu	r2,0(r2)
81114e30:	10803fcc 	andi	r2,r2,255
81114e34:	1080010c 	andi	r2,r2,4
81114e38:	10000626 	beq	r2,zero,81114e54 <bPreParserV2+0x1d0>
                (*p_inteiro) = c;
81114e3c:	e0bff817 	ldw	r2,-32(fp)
81114e40:	e0fffb03 	ldbu	r3,-20(fp)
81114e44:	10c00005 	stb	r3,0(r2)
                p_inteiro++;
81114e48:	e0bff817 	ldw	r2,-32(fp)
81114e4c:	10800044 	addi	r2,r2,1
81114e50:	e0bff815 	stw	r2,-32(fp)
            }
            i++;
81114e54:	e0bff703 	ldbu	r2,-36(fp)
81114e58:	10800044 	addi	r2,r2,1
81114e5c:	e0bff705 	stb	r2,-36(fp)
        } while ( (siStrLen>i) && ( ( c != SEPARATOR_CHAR ) && ( c != FINAL_CHAR ) && ( c != SEPARATOR_CRC )) ); //ASCII: 58 = ':' 59 = ';' and '|'
81114e60:	e0bff90f 	ldh	r2,-28(fp)
81114e64:	e0fff703 	ldbu	r3,-36(fp)
81114e68:	1880090e 	bge	r3,r2,81114e90 <bPreParserV2+0x20c>
81114e6c:	e0bffb07 	ldb	r2,-20(fp)
81114e70:	10800ea0 	cmpeqi	r2,r2,58
81114e74:	1000061e 	bne	r2,zero,81114e90 <bPreParserV2+0x20c>
81114e78:	e0bffb07 	ldb	r2,-20(fp)
81114e7c:	10800ee0 	cmpeqi	r2,r2,59
81114e80:	1000031e 	bne	r2,zero,81114e90 <bPreParserV2+0x20c>
81114e84:	e0bffb07 	ldb	r2,-20(fp)
81114e88:	10801f18 	cmpnei	r2,r2,124
81114e8c:	103fde1e 	bne	r2,zero,81114e08 <__reset+0xfb0f4e08>
        (*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81114e90:	e0bff817 	ldw	r2,-32(fp)
81114e94:	00c00284 	movi	r3,10
81114e98:	10c00005 	stb	r3,0(r2)

        if ( ( c == SEPARATOR_CHAR ) || ( c == SEPARATOR_CRC ) ) {
81114e9c:	e0bffb07 	ldb	r2,-20(fp)
81114ea0:	10800ea0 	cmpeqi	r2,r2,58
81114ea4:	1000031e 	bne	r2,zero,81114eb4 <bPreParserV2+0x230>
81114ea8:	e0bffb07 	ldb	r2,-20(fp)
81114eac:	10801f18 	cmpnei	r2,r2,124
81114eb0:	10001a1e 	bne	r2,zero,81114f1c <bPreParserV2+0x298>
            xPerParcedBuffer->usiValues[min_sim(xPerParcedBuffer->ucNofBytes,SIZE_UCVALUES)] = (unsigned short int)atoi( inteiro );
81114eb4:	e0bffe17 	ldw	r2,-8(fp)
81114eb8:	10800183 	ldbu	r2,6(r2)
81114ebc:	10803fcc 	andi	r2,r2,255
81114ec0:	10800828 	cmpgeui	r2,r2,32
81114ec4:	1000041e 	bne	r2,zero,81114ed8 <bPreParserV2+0x254>
81114ec8:	e0bffe17 	ldw	r2,-8(fp)
81114ecc:	10800183 	ldbu	r2,6(r2)
81114ed0:	14003fcc 	andi	r16,r2,255
81114ed4:	00000106 	br	81114edc <bPreParserV2+0x258>
81114ed8:	04000804 	movi	r16,32
81114edc:	e0bffb44 	addi	r2,fp,-19
81114ee0:	1009883a 	mov	r4,r2
81114ee4:	112146c0 	call	8112146c <atoi>
81114ee8:	1009883a 	mov	r4,r2
81114eec:	e0fffe17 	ldw	r3,-8(fp)
81114ef0:	80800104 	addi	r2,r16,4
81114ef4:	1085883a 	add	r2,r2,r2
81114ef8:	1885883a 	add	r2,r3,r2
81114efc:	1100000d 	sth	r4,0(r2)
            xPerParcedBuffer->ucNofBytes++;
81114f00:	e0bffe17 	ldw	r2,-8(fp)
81114f04:	10800183 	ldbu	r2,6(r2)
81114f08:	10800044 	addi	r2,r2,1
81114f0c:	1007883a 	mov	r3,r2
81114f10:	e0bffe17 	ldw	r2,-8(fp)
81114f14:	10c00185 	stb	r3,6(r2)
81114f18:	00000906 	br	81114f40 <bPreParserV2+0x2bc>
        }
        else if ( c == FINAL_CHAR )
81114f1c:	e0bffb07 	ldb	r2,-20(fp)
81114f20:	10800ed8 	cmpnei	r2,r2,59
81114f24:	1000061e 	bne	r2,zero,81114f40 <bPreParserV2+0x2bc>
        {
            xPerParcedBuffer->ucMessageCRC8 = (unsigned char)atoi( inteiro );
81114f28:	e0bffb44 	addi	r2,fp,-19
81114f2c:	1009883a 	mov	r4,r2
81114f30:	112146c0 	call	8112146c <atoi>
81114f34:	1007883a 	mov	r3,r2
81114f38:	e0bffe17 	ldw	r2,-8(fp)
81114f3c:	10c01245 	stb	r3,73(r2)
        }

    } while ( (c != FINAL_CHAR) && (siStrLen>i) );
81114f40:	e0bffb07 	ldb	r2,-20(fp)
81114f44:	10800ee0 	cmpeqi	r2,r2,59
81114f48:	1000031e 	bne	r2,zero,81114f58 <bPreParserV2+0x2d4>
81114f4c:	e0bff90f 	ldh	r2,-28(fp)
81114f50:	e0fff703 	ldbu	r3,-36(fp)
81114f54:	18bfa516 	blt	r3,r2,81114dec <__reset+0xfb0f4dec>


    if ( c == FINAL_CHAR )
81114f58:	e0bffb07 	ldb	r2,-20(fp)
81114f5c:	10800ed8 	cmpnei	r2,r2,59
81114f60:	1000191e 	bne	r2,zero,81114fc8 <bPreParserV2+0x344>
        if ( xPerParcedBuffer->ucMessageCRC8 == xPerParcedBuffer->ucCalculatedCRC8 ){
81114f64:	e0bffe17 	ldw	r2,-8(fp)
81114f68:	10c01243 	ldbu	r3,73(r2)
81114f6c:	e0bffe17 	ldw	r2,-8(fp)
81114f70:	10801203 	ldbu	r2,72(r2)
81114f74:	18c03fcc 	andi	r3,r3,255
81114f78:	10803fcc 	andi	r2,r2,255
81114f7c:	1880031e 	bne	r3,r2,81114f8c <bPreParserV2+0x308>
            bSuccess = TRUE;
81114f80:	00800044 	movi	r2,1
81114f84:	e0bff615 	stw	r2,-40(fp)
81114f88:	00001006 	br	81114fcc <bPreParserV2+0x348>
        } else {
            /* Wrong CRC */
            #ifdef DEBUG_ON
                fprintf(fp,"Wrong CRC. Expected = %hhu, received = %hhu\n", xPerParcedBuffer->ucCalculatedCRC8, xPerParcedBuffer->ucMessageCRC8 );
81114f8c:	d0e06217 	ldw	r3,-32376(gp)
81114f90:	e0bffe17 	ldw	r2,-8(fp)
81114f94:	10801203 	ldbu	r2,72(r2)
81114f98:	11003fcc 	andi	r4,r2,255
81114f9c:	e0bffe17 	ldw	r2,-8(fp)
81114fa0:	10801243 	ldbu	r2,73(r2)
81114fa4:	10803fcc 	andi	r2,r2,255
81114fa8:	100f883a 	mov	r7,r2
81114fac:	200d883a 	mov	r6,r4
81114fb0:	01604574 	movhi	r5,33045
81114fb4:	2977f804 	addi	r5,r5,-8224
81114fb8:	1809883a 	mov	r4,r3
81114fbc:	11215e00 	call	811215e0 <fprintf>
            #endif
            bSuccess = FALSE;
81114fc0:	e03ff615 	stw	zero,-40(fp)
81114fc4:	00000106 	br	81114fcc <bPreParserV2+0x348>
        }
    else
        bSuccess = FALSE; /* Index overflow in the buffer */
81114fc8:	e03ff615 	stw	zero,-40(fp)


    return bSuccess;
81114fcc:	e0bff617 	ldw	r2,-40(fp)
}
81114fd0:	e6ffff04 	addi	sp,fp,-4
81114fd4:	dfc00217 	ldw	ra,8(sp)
81114fd8:	df000117 	ldw	fp,4(sp)
81114fdc:	dc000017 	ldw	r16,0(sp)
81114fe0:	dec00304 	addi	sp,sp,12
81114fe4:	f800283a 	ret

81114fe8 <vSenderComTask>:


OS_STK_DATA *pdata;

void vSenderComTask(void *task_data)
{
81114fe8:	defffb04 	addi	sp,sp,-20
81114fec:	de00012e 	bgeu	sp,et,81114ff4 <vSenderComTask+0xc>
81114ff0:	003b68fa 	trap	3
81114ff4:	dfc00415 	stw	ra,16(sp)
81114ff8:	df000315 	stw	fp,12(sp)
81114ffc:	df000304 	addi	fp,sp,12
81115000:	e13fff15 	stw	r4,-4(fp)
    tSenderStates eSenderMode;
    bool bSuccess;

    eSenderMode = sConfiguringSender;
81115004:	e03ffd15 	stw	zero,-12(fp)

    #ifdef DEBUG_ON
        debug(fp,"Sender Comm Task. (Task on)\n");
81115008:	d0a06217 	ldw	r2,-32376(gp)
8111500c:	100f883a 	mov	r7,r2
81115010:	01800704 	movi	r6,28
81115014:	01400044 	movi	r5,1
81115018:	01204574 	movhi	r4,33045
8111501c:	21380404 	addi	r4,r4,-8176
81115020:	1121c7c0 	call	81121c7c <fwrite>
    #endif

    for (;;){
        
        switch (eSenderMode)
81115024:	e0bffd17 	ldw	r2,-12(fp)
81115028:	10c00060 	cmpeqi	r3,r2,1
8111502c:	1800091e 	bne	r3,zero,81115054 <vSenderComTask+0x6c>
81115030:	0080052e 	bgeu	zero,r2,81115048 <vSenderComTask+0x60>
81115034:	10c000a0 	cmpeqi	r3,r2,2
81115038:	1800471e 	bne	r3,zero,81115158 <vSenderComTask+0x170>
8111503c:	10800160 	cmpeqi	r2,r2,5
81115040:	10002c1e 	bne	r2,zero,811150f4 <vSenderComTask+0x10c>
81115044:	00003a06 	br	81115130 <vSenderComTask+0x148>
        {
            case sConfiguringSender:
                /* For future implementations. */
                eSenderMode = sStartingConnSender;
81115048:	00800044 	movi	r2,1
8111504c:	e0bffd15 	stw	r2,-12(fp)
                break;
81115050:	00004206 	br	8111515c <vSenderComTask+0x174>
                /*  This semaphore will return a non-zero value if the NUC communicate with the MEB 
                    vReceiverComTask is responsible to send this semaphore.
                    OSSemAccept -> Non blocking Pend*/

                #ifdef DEBUG_ON
                    debug(fp,"Preparing the Start Sequence.\n");
81115054:	d0a06217 	ldw	r2,-32376(gp)
81115058:	100f883a 	mov	r7,r2
8111505c:	01800784 	movi	r6,30
81115060:	01400044 	movi	r5,1
81115064:	01204574 	movhi	r4,33045
81115068:	21380c04 	addi	r4,r4,-8144
8111506c:	1121c7c0 	call	81121c7c <fwrite>
                #endif

                /* id of the first message will be 1 */
                bSuccess = bSendUART32v2(START_STATUS_SEQUENCE, 1);
81115070:	01400044 	movi	r5,1
81115074:	01204574 	movhi	r4,33045
81115078:	21381404 	addi	r4,r4,-8112
8111507c:	1118c240 	call	81118c24 <bSendUART32v2>
81115080:	e0bffe15 	stw	r2,-8(fp)
                if ( bSuccess == TRUE ) {
81115084:	e0bffe17 	ldw	r2,-8(fp)
81115088:	10800058 	cmpnei	r2,r2,1
8111508c:	10000a1e 	bne	r2,zero,811150b8 <vSenderComTask+0xd0>
                    eSenderMode = sDummySender;
81115090:	00800144 	movi	r2,5
81115094:	e0bffd15 	stw	r2,-12(fp)
                    #ifdef DEBUG_ON
                        debug(fp,"Success, start message in the retransmission buffer.\n");
81115098:	d0a06217 	ldw	r2,-32376(gp)
8111509c:	100f883a 	mov	r7,r2
811150a0:	01800d44 	movi	r6,53
811150a4:	01400044 	movi	r5,1
811150a8:	01204574 	movhi	r4,33045
811150ac:	21381704 	addi	r4,r4,-8100
811150b0:	1121c7c0 	call	81121c7c <fwrite>
                        debug(fp,"Fail, try again in 5 seconds.\n");
                    #endif 
                    eSenderMode = sStartingConnSender;
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
                }
                break;
811150b4:	00002906 	br	8111515c <vSenderComTask+0x174>
                    #ifdef DEBUG_ON
                        debug(fp,"Success, start message in the retransmission buffer.\n");
                    #endif                    
                } else {
                    #ifdef DEBUG_ON
                        debug(fp,"Fail, try again in 5 seconds.\n");
811150b8:	d0a06217 	ldw	r2,-32376(gp)
811150bc:	100f883a 	mov	r7,r2
811150c0:	01800784 	movi	r6,30
811150c4:	01400044 	movi	r5,1
811150c8:	01204574 	movhi	r4,33045
811150cc:	21382504 	addi	r4,r4,-8044
811150d0:	1121c7c0 	call	81121c7c <fwrite>
                    #endif 
                    eSenderMode = sStartingConnSender;
811150d4:	00800044 	movi	r2,1
811150d8:	e0bffd15 	stw	r2,-12(fp)
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
811150dc:	000f883a 	mov	r7,zero
811150e0:	01800144 	movi	r6,5
811150e4:	000b883a 	mov	r5,zero
811150e8:	0009883a 	mov	r4,zero
811150ec:	1140ab00 	call	81140ab0 <OSTimeDlyHMSM>
                }
                break;
811150f0:	00001a06 	br	8111515c <vSenderComTask+0x174>
                

                break;
            case sDummySender:
                /* code */
                eSenderMode = sDummySender;
811150f4:	00800144 	movi	r2,5
811150f8:	e0bffd15 	stw	r2,-12(fp)

                #ifdef DEBUG_ON
                    debug(fp,"Working...\n");
811150fc:	d0a06217 	ldw	r2,-32376(gp)
81115100:	100f883a 	mov	r7,r2
81115104:	018002c4 	movi	r6,11
81115108:	01400044 	movi	r5,1
8111510c:	01204574 	movhi	r4,33045
81115110:	21382d04 	addi	r4,r4,-8012
81115114:	1121c7c0 	call	81121c7c <fwrite>
                #endif

				OSTimeDlyHMSM(0, 0, 25, 0); /*Sleeps for 3 second*/
81115118:	000f883a 	mov	r7,zero
8111511c:	01800644 	movi	r6,25
81115120:	000b883a 	mov	r5,zero
81115124:	0009883a 	mov	r4,zero
81115128:	1140ab00 	call	81140ab0 <OSTimeDlyHMSM>

                break;
8111512c:	00000b06 	br	8111515c <vSenderComTask+0x174>
            default:
                #ifdef DEBUG_ON
                    debug(fp,"Sender default\n");
81115130:	d0a06217 	ldw	r2,-32376(gp)
81115134:	100f883a 	mov	r7,r2
81115138:	018003c4 	movi	r6,15
8111513c:	01400044 	movi	r5,1
81115140:	01204574 	movhi	r4,33045
81115144:	21383004 	addi	r4,r4,-8000
81115148:	1121c7c0 	call	81121c7c <fwrite>
                #endif
                eSenderMode = sDummySender;
8111514c:	00800144 	movi	r2,5
81115150:	e0bffd15 	stw	r2,-12(fp)
                break;
81115154:	00000106 	br	8111515c <vSenderComTask+0x174>

                //pPointer = OSQPend(xQSenderTask, 0, &error_code);

                

                break;
81115158:	0001883a 	nop
                #endif
                eSenderMode = sDummySender;
                break;
        }

    }
8111515c:	003fb106 	br	81115024 <__reset+0xfb0f5024>

81115160 <vSimMebTask>:

#include "sim_meb_task.h"

/* All commands should pass through the MEB, it is the instance that hould know everything, and also know the self state and what is allowed to be performed or not */

void vSimMebTask(void *task_data) {
81115160:	defff804 	addi	sp,sp,-32
81115164:	de00012e 	bgeu	sp,et,8111516c <vSimMebTask+0xc>
81115168:	003b68fa 	trap	3
8111516c:	dfc00715 	stw	ra,28(sp)
81115170:	df000615 	stw	fp,24(sp)
81115174:	df000604 	addi	fp,sp,24
81115178:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucIL;
	tQMask uiCmdMeb;
	INT8U error_code;
	INT8U ucFrameNumber;

	pxMebC = (TSimucam_MEB *) task_data;
8111517c:	e0bfff17 	ldw	r2,-4(fp)
81115180:	e0bffb15 	stw	r2,-20(fp)

	#ifdef DEBUG_ON
        debug(fp,"Sim-Meb Controller Task. (Task on)\n");
81115184:	d0a06217 	ldw	r2,-32376(gp)
81115188:	100f883a 	mov	r7,r2
8111518c:	018008c4 	movi	r6,35
81115190:	01400044 	movi	r5,1
81115194:	01204574 	movhi	r4,33045
81115198:	21383404 	addi	r4,r4,-7984
8111519c:	1121c7c0 	call	81121c7c <fwrite>
    #endif


	for (;;) {
		switch ( pxMebC->eMode ) {
811151a0:	e0bffb17 	ldw	r2,-20(fp)
811151a4:	10800117 	ldw	r2,4(r2)
811151a8:	10c00168 	cmpgeui	r3,r2,5
811151ac:	1800ed1e 	bne	r3,zero,81115564 <vSimMebTask+0x404>
811151b0:	100690ba 	slli	r3,r2,2
811151b4:	00a04474 	movhi	r2,33041
811151b8:	10947204 	addi	r2,r2,20936
811151bc:	1885883a 	add	r2,r3,r2
811151c0:	10800017 	ldw	r2,0(r2)
811151c4:	1000683a 	jmp	r2
811151c8:	811151dc 	xori	r4,r16,17735
811151cc:	811151f4 	orhi	r4,r16,17735
811151d0:	81115274 	orhi	r4,r16,17737
811151d4:	81115340 	call	88111534 <__reset+0x20f1534>
811151d8:	81115418 	cmpnei	r4,r16,17744
			case sMebInit:
				/* Turn on Meb */
				vMebInit( pxMebC );
811151dc:	e13ffb17 	ldw	r4,-20(fp)
811151e0:	11163080 	call	81116308 <vMebInit>
				pxMebC->eMode = sMebToConfig;
811151e4:	e0bffb17 	ldw	r2,-20(fp)
811151e8:	00c00044 	movi	r3,1
811151ec:	10c00115 	stw	r3,4(r2)
				break;
811151f0:	0000e706 	br	81115590 <vSimMebTask+0x430>


			case sMebToConfig:
				#ifdef DEBUG_ON
					debug(fp,"MEB Task: Config Mode\n");
811151f4:	d0a06217 	ldw	r2,-32376(gp)
811151f8:	100f883a 	mov	r7,r2
811151fc:	01800584 	movi	r6,22
81115200:	01400044 	movi	r5,1
81115204:	01204574 	movhi	r4,33045
81115208:	21383d04 	addi	r4,r4,-7948
8111520c:	1121c7c0 	call	81121c7c <fwrite>
				#endif

				/* Stop the Sync (Stopping the simulation) */
				bStopSync();
81115210:	111eed80 	call	8111eed8 <bStopSync>
				vSyncClearCounter();
81115214:	110cb880 	call	8110cb88 <vSyncClearCounter>

				/* If any Task is locked waiting Sync, should be released */
				vReleaseSyncMessages();
81115218:	11164100 	call	81116410 <vReleaseSyncMessages>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, 10);
8111521c:	01c00284 	movi	r7,10
81115220:	000d883a 	mov	r6,zero
81115224:	000b883a 	mov	r5,zero
81115228:	0009883a 	mov	r4,zero
8111522c:	1140ab00 	call	81140ab0 <OSTimeDlyHMSM>

				/* Transition to Config Mode (Ending the simulation) */
				/* Send a message to the NFEE Controller forcing the mode */
				vSendCmdQToNFeeCTRL_PRIO( M_NFC_CONFIG_FORCED, 0, 0 );
81115230:	000d883a 	mov	r6,zero
81115234:	000b883a 	mov	r5,zero
81115238:	01002844 	movi	r4,161
8111523c:	11160dc0 	call	811160dc <vSendCmdQToNFeeCTRL_PRIO>
				vSendCmdQToDataCTRL_PRIO( M_DATA_CONFIG_FORCED, 0, 0 );
81115240:	000d883a 	mov	r6,zero
81115244:	000b883a 	mov	r5,zero
81115248:	01002844 	movi	r4,161
8111524c:	11162800 	call	81116280 <vSendCmdQToDataCTRL_PRIO>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, 250);
81115250:	01c03e84 	movi	r7,250
81115254:	000d883a 	mov	r6,zero
81115258:	000b883a 	mov	r5,zero
8111525c:	0009883a 	mov	r4,zero
81115260:	1140ab00 	call	81140ab0 <OSTimeDlyHMSM>

				pxMebC->eMode = sMebConfig;
81115264:	e0bffb17 	ldw	r2,-20(fp)
81115268:	00c000c4 	movi	r3,3
8111526c:	10c00115 	stw	r3,4(r2)
				break;
81115270:	0000c706 	br	81115590 <vSimMebTask+0x430>


			case sMebToRun:
				#ifdef DEBUG_ON
					debug(fp,"MEB Task: Run Mode\n");
81115274:	d0a06217 	ldw	r2,-32376(gp)
81115278:	100f883a 	mov	r7,r2
8111527c:	018004c4 	movi	r6,19
81115280:	01400044 	movi	r5,1
81115284:	01204574 	movhi	r4,33045
81115288:	21384304 	addi	r4,r4,-7924
8111528c:	1121c7c0 	call	81121c7c <fwrite>
				#endif
				/* Transition to Run Mode (Starting the Simulation) */
				vSendCmdQToNFeeCTRL_PRIO( M_NFC_RUN_FORCED, 0, 0 );
81115290:	000d883a 	mov	r6,zero
81115294:	000b883a 	mov	r5,zero
81115298:	01002884 	movi	r4,162
8111529c:	11160dc0 	call	811160dc <vSendCmdQToNFeeCTRL_PRIO>
				vSendCmdQToDataCTRL_PRIO( M_DATA_RUN_FORCED, 0, 0 );
811152a0:	000d883a 	mov	r6,zero
811152a4:	000b883a 	mov	r5,zero
811152a8:	01002884 	movi	r4,162
811152ac:	11162800 	call	81116280 <vSendCmdQToDataCTRL_PRIO>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, pxMebC->usiDelaySyncReset);
811152b0:	e0bffb17 	ldw	r2,-20(fp)
811152b4:	1080050b 	ldhu	r2,20(r2)
811152b8:	10bfffcc 	andi	r2,r2,65535
811152bc:	100f883a 	mov	r7,r2
811152c0:	000d883a 	mov	r6,zero
811152c4:	000b883a 	mov	r5,zero
811152c8:	0009883a 	mov	r4,zero
811152cc:	1140ab00 	call	81140ab0 <OSTimeDlyHMSM>


				/* Clear the timecode of the channel SPW (for now is for spw channel) */
				for (ucIL = 0; ucIL < N_OF_NFEE; ++ucIL) {
811152d0:	e03ffa05 	stb	zero,-24(fp)
811152d4:	00001006 	br	81115318 <vSimMebTask+0x1b8>
					bSpwcClearTimecode(&pxMebC->xFeeControl.xNfee[ucIL].xChannel.xSpacewire);
811152d8:	e0bffa03 	ldbu	r2,-24(fp)
811152dc:	10809624 	muli	r2,r2,600
811152e0:	10809b04 	addi	r2,r2,620
811152e4:	e0fffb17 	ldw	r3,-20(fp)
811152e8:	1885883a 	add	r2,r3,r2
811152ec:	1009883a 	mov	r4,r2
811152f0:	110a7e40 	call	8110a7e4 <bSpwcClearTimecode>
					pxMebC->xFeeControl.xNfee[ucIL].xControl.ucTimeCode = 0;
811152f4:	e0bffa03 	ldbu	r2,-24(fp)
811152f8:	e0fffb17 	ldw	r3,-20(fp)
811152fc:	10809624 	muli	r2,r2,600
81115300:	1885883a 	add	r2,r3,r2
81115304:	10803c04 	addi	r2,r2,240
81115308:	10000005 	stb	zero,0(r2)
				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, pxMebC->usiDelaySyncReset);


				/* Clear the timecode of the channel SPW (for now is for spw channel) */
				for (ucIL = 0; ucIL < N_OF_NFEE; ++ucIL) {
8111530c:	e0bffa03 	ldbu	r2,-24(fp)
81115310:	10800044 	addi	r2,r2,1
81115314:	e0bffa05 	stb	r2,-24(fp)
81115318:	e0bffa03 	ldbu	r2,-24(fp)
8111531c:	103fee26 	beq	r2,zero,811152d8 <__reset+0xfb0f52d8>
					bSpwcClearTimecode(&pxMebC->xFeeControl.xNfee[ucIL].xChannel.xSpacewire);
					pxMebC->xFeeControl.xNfee[ucIL].xControl.ucTimeCode = 0;
				}

				bSyncCtrReset();
81115320:	110d1d80 	call	8110d1d8 <bSyncCtrReset>
				vSyncClearCounter();
81115324:	110cb880 	call	8110cb88 <vSyncClearCounter>
				bStartSync();
81115328:	111ee9c0 	call	8111ee9c <bStartSync>

				vEvtChangeMebMode();
8111532c:	111d7bc0 	call	8111d7bc <vEvtChangeMebMode>
				pxMebC->eMode = sMebRun;
81115330:	e0bffb17 	ldw	r2,-20(fp)
81115334:	00c00104 	movi	r3,4
81115338:	10c00115 	stw	r3,4(r2)
				break;
8111533c:	00009406 	br	81115590 <vSimMebTask+0x430>


			case sMebConfig:

				uiCmdMeb.ulWord = (unsigned int)OSQPend(xMebQ, 0, &error_code); /* Blocking operation */
81115340:	d0a06917 	ldw	r2,-32348(gp)
81115344:	e0fffe04 	addi	r3,fp,-8
81115348:	180d883a 	mov	r6,r3
8111534c:	000b883a 	mov	r5,zero
81115350:	1009883a 	mov	r4,r2
81115354:	113dc200 	call	8113dc20 <OSQPend>
81115358:	e0bffd15 	stw	r2,-12(fp)
				if ( error_code == OS_ERR_NONE ) {
8111535c:	e0bffe03 	ldbu	r2,-8(fp)
81115360:	10803fcc 	andi	r2,r2,255
81115364:	1000291e 	bne	r2,zero,8111540c <vSimMebTask+0x2ac>

					/* Check if the command is for MEB */
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
81115368:	e0bffdc3 	ldbu	r2,-9(fp)
8111536c:	10803fcc 	andi	r2,r2,255
81115370:	10800058 	cmpnei	r2,r2,1
81115374:	10001c1e 	bne	r2,zero,811153e8 <vSimMebTask+0x288>
						/* Parse the cmd that comes in the Queue */
						switch ( uiCmdMeb.ucByte[2] ) {
81115378:	e0bffd83 	ldbu	r2,-10(fp)
8111537c:	10803fcc 	andi	r2,r2,255
81115380:	10c00060 	cmpeqi	r3,r2,1
81115384:	1800031e 	bne	r3,zero,81115394 <vSimMebTask+0x234>
81115388:	10803820 	cmpeqi	r2,r2,224
8111538c:	1000041e 	bne	r2,zero,811153a0 <vSimMebTask+0x240>
81115390:	00000b06 	br	811153c0 <vSimMebTask+0x260>
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebTask( pxMebC );
81115394:	e13ffb17 	ldw	r4,-20(fp)
81115398:	11155940 	call	81115594 <vPusMebTask>
								break;
8111539c:	00001d06 	br	81115414 <vSimMebTask+0x2b4>
							case M_MASTER_SYNC:
								#ifdef DEBUG_ON
									fprintf(fp,"MEB Task: WARNING Should not have sync in Meb Config Mode (Check it please)");
811153a0:	d0a06217 	ldw	r2,-32376(gp)
811153a4:	100f883a 	mov	r7,r2
811153a8:	018012c4 	movi	r6,75
811153ac:	01400044 	movi	r5,1
811153b0:	01204574 	movhi	r4,33045
811153b4:	21384804 	addi	r4,r4,-7904
811153b8:	1121c7c0 	call	81121c7c <fwrite>
								#endif
								break;
811153bc:	00001506 	br	81115414 <vSimMebTask+0x2b4>
							default:
								#ifdef DEBUG_ON
									fprintf(fp,"MEB Task: Unknown command for the Config Mode (Queue xMebQ, cmd= %hhu)\n", uiCmdMeb.ucByte[2]);
811153c0:	d0a06217 	ldw	r2,-32376(gp)
811153c4:	e0fffd83 	ldbu	r3,-10(fp)
811153c8:	18c03fcc 	andi	r3,r3,255
811153cc:	180d883a 	mov	r6,r3
811153d0:	01604574 	movhi	r5,33045
811153d4:	29785b04 	addi	r5,r5,-7828
811153d8:	1009883a 	mov	r4,r2
811153dc:	11215e00 	call	811215e0 <fprintf>
								#endif
								break;
811153e0:	0001883a 	nop
811153e4:	00000b06 	br	81115414 <vSimMebTask+0x2b4>
						}
					} else {
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: Command Ignored wrong address (ADDR= %hhu)\n", uiCmdMeb.ucByte[3]);
811153e8:	d0a06217 	ldw	r2,-32376(gp)
811153ec:	e0fffdc3 	ldbu	r3,-9(fp)
811153f0:	18c03fcc 	andi	r3,r3,255
811153f4:	180d883a 	mov	r6,r3
811153f8:	01604574 	movhi	r5,33045
811153fc:	29786d04 	addi	r5,r5,-7756
81115400:	1009883a 	mov	r4,r2
81115404:	11215e00 	call	811215e0 <fprintf>
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}

				break;
81115408:	00006106 	br	81115590 <vSimMebTask+0x430>
							fprintf(fp,"MEB Task: Command Ignored wrong address (ADDR= %hhu)\n", uiCmdMeb.ucByte[3]);
						#endif
					}
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
8111540c:	111d15c0 	call	8111d15c <vCouldNotGetCmdQueueMeb>
				}

				break;
81115410:	00005f06 	br	81115590 <vSimMebTask+0x430>
81115414:	00005e06 	br	81115590 <vSimMebTask+0x430>

			case sMebRun:
				uiCmdMeb.ulWord = (unsigned int)OSQPend(xMebQ, 0, &error_code); /* Blocking operation */
81115418:	d0a06917 	ldw	r2,-32348(gp)
8111541c:	e0fffe04 	addi	r3,fp,-8
81115420:	180d883a 	mov	r6,r3
81115424:	000b883a 	mov	r5,zero
81115428:	1009883a 	mov	r4,r2
8111542c:	113dc200 	call	8113dc20 <OSQPend>
81115430:	e0bffd15 	stw	r2,-12(fp)
				if ( error_code == OS_ERR_NONE ) {
81115434:	e0bffe03 	ldbu	r2,-8(fp)
81115438:	10803fcc 	andi	r2,r2,255
8111543c:	1000461e 	bne	r2,zero,81115558 <vSimMebTask+0x3f8>

					/* Check if the command is for MEB */
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
81115440:	e0bffdc3 	ldbu	r2,-9(fp)
81115444:	10803fcc 	andi	r2,r2,255
81115448:	10800058 	cmpnei	r2,r2,1
8111544c:	1000391e 	bne	r2,zero,81115534 <vSimMebTask+0x3d4>
						/* Parse the cmd that comes in the Queue */
						switch (uiCmdMeb.ucByte[2]) {
81115450:	e0bffd83 	ldbu	r2,-10(fp)
81115454:	10803fcc 	andi	r2,r2,255
81115458:	10c03820 	cmpeqi	r3,r2,224
8111545c:	1800071e 	bne	r3,zero,8111547c <vSimMebTask+0x31c>
81115460:	10c03860 	cmpeqi	r3,r2,225
81115464:	1800071e 	bne	r3,zero,81115484 <vSimMebTask+0x324>
81115468:	10800060 	cmpeqi	r2,r2,1
8111546c:	10002726 	beq	r2,zero,8111550c <vSimMebTask+0x3ac>
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebTask( pxMebC );
81115470:	e13ffb17 	ldw	r4,-20(fp)
81115474:	11155940 	call	81115594 <vPusMebTask>
								break;
81115478:	00003906 	br	81115560 <vSimMebTask+0x400>
							case M_MASTER_SYNC:
								/* Perform memory SWAP */
								vSwapMemmory(pxMebC);
8111547c:	e13ffb17 	ldw	r4,-20(fp)
81115480:	111636c0 	call	8111636c <vSwapMemmory>
							case M_SYNC:
								#ifdef DEBUG_ON
									bSpwcGetTimecode(&pxMebC->xFeeControl.xNfee[0].xChannel.xSpacewire);
81115484:	e0bffb17 	ldw	r2,-20(fp)
81115488:	10809b04 	addi	r2,r2,620
8111548c:	1009883a 	mov	r4,r2
81115490:	110a7540 	call	8110a754 <bSpwcGetTimecode>
									tCode = ( pxMebC->xFeeControl.xNfee[0].xChannel.xSpacewire.xTimecode.ucCounter);
81115494:	e0bffb17 	ldw	r2,-20(fp)
81115498:	1080a743 	ldbu	r2,669(r2)
8111549c:	e0bffc05 	stb	r2,-16(fp)
									tCodeNext = ( tCode ) % 4;
811154a0:	e0bffc03 	ldbu	r2,-16(fp)
811154a4:	108000cc 	andi	r2,r2,3
811154a8:	e0bffc45 	stb	r2,-15(fp)

									fprintf(fp,"\n\nMEB TASK:  TC: %hhu ( %hhu )\n ", tCode, tCodeNext);
811154ac:	d0a06217 	ldw	r2,-32376(gp)
811154b0:	e0fffc03 	ldbu	r3,-16(fp)
811154b4:	e13ffc43 	ldbu	r4,-15(fp)
811154b8:	200f883a 	mov	r7,r4
811154bc:	180d883a 	mov	r6,r3
811154c0:	01604574 	movhi	r5,33045
811154c4:	29787b04 	addi	r5,r5,-7700
811154c8:	1009883a 	mov	r4,r2
811154cc:	11215e00 	call	811215e0 <fprintf>


									bRmapGetMemConfigArea(&pxMebC->xFeeControl.xNfee[0].xChannel.xRmap);
811154d0:	e0bffb17 	ldw	r2,-20(fp)
811154d4:	10805504 	addi	r2,r2,340
811154d8:	1009883a 	mov	r4,r2
811154dc:	11083480 	call	81108348 <bRmapGetMemConfigArea>
									ucFrameNumber = pxMebC->xFeeControl.xNfee[0].xChannel.xRmap.xRmapMemConfigArea.uliFrameNumber;
811154e0:	e0bffb17 	ldw	r2,-20(fp)
811154e4:	10807717 	ldw	r2,476(r2)
811154e8:	e0bffc85 	stb	r2,-14(fp)

									//bRmapSetMemConfigArea(&pxMebC->xFeeControl.xNfee[0].xChannel.xRmap);

									fprintf(fp,"MEB TASK:  Frame Number: %hhu \n ", ucFrameNumber);
811154ec:	d0a06217 	ldw	r2,-32376(gp)
811154f0:	e0fffc83 	ldbu	r3,-14(fp)
811154f4:	180d883a 	mov	r6,r3
811154f8:	01604574 	movhi	r5,33045
811154fc:	29788404 	addi	r5,r5,-7664
81115500:	1009883a 	mov	r4,r2
81115504:	11215e00 	call	811215e0 <fprintf>

								#endif

								break;
81115508:	00001506 	br	81115560 <vSimMebTask+0x400>
							default:
								#ifdef DEBUG_ON
									fprintf(fp,"MEB Task: Unknown command (%hhu)\n", uiCmdMeb.ucByte[2]);
8111550c:	d0a06217 	ldw	r2,-32376(gp)
81115510:	e0fffd83 	ldbu	r3,-10(fp)
81115514:	18c03fcc 	andi	r3,r3,255
81115518:	180d883a 	mov	r6,r3
8111551c:	01604574 	movhi	r5,33045
81115520:	29788d04 	addi	r5,r5,-7628
81115524:	1009883a 	mov	r4,r2
81115528:	11215e00 	call	811215e0 <fprintf>
								#endif
								break;
8111552c:	0001883a 	nop
81115530:	00000b06 	br	81115560 <vSimMebTask+0x400>
						}
					} else {
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: Command Ignored wrong address (ADDR= %hhu)\n", uiCmdMeb.ucByte[3]);
81115534:	d0a06217 	ldw	r2,-32376(gp)
81115538:	e0fffdc3 	ldbu	r3,-9(fp)
8111553c:	18c03fcc 	andi	r3,r3,255
81115540:	180d883a 	mov	r6,r3
81115544:	01604574 	movhi	r5,33045
81115548:	29786d04 	addi	r5,r5,-7756
8111554c:	1009883a 	mov	r4,r2
81115550:	11215e00 	call	811215e0 <fprintf>

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}			
				break;
81115554:	00000e06 	br	81115590 <vSimMebTask+0x430>
						#endif
					}

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
81115558:	111d15c0 	call	8111d15c <vCouldNotGetCmdQueueMeb>
				}			
				break;
8111555c:	00000c06 	br	81115590 <vSimMebTask+0x430>
81115560:	00000b06 	br	81115590 <vSimMebTask+0x430>

			default:
				#ifdef DEBUG_ON
					debug(fp,"MEB Task: Unknow state, backing to Config Mode\n");
81115564:	d0a06217 	ldw	r2,-32376(gp)
81115568:	100f883a 	mov	r7,r2
8111556c:	01800bc4 	movi	r6,47
81115570:	01400044 	movi	r5,1
81115574:	01204574 	movhi	r4,33045
81115578:	21389604 	addi	r4,r4,-7592
8111557c:	1121c7c0 	call	81121c7c <fwrite>
				#endif
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxMebC->eMode = sMebToConfig;
81115580:	e0bffb17 	ldw	r2,-20(fp)
81115584:	00c00044 	movi	r3,1
81115588:	10c00115 	stw	r3,4(r2)
				break;
8111558c:	0001883a 	nop
		}
	}
81115590:	003f0306 	br	811151a0 <__reset+0xfb0f51a0>

81115594 <vPusMebTask>:
}

void vPusMebTask( TSimucam_MEB *pxMebCLocal ) {
81115594:	defffb04 	addi	sp,sp,-20
81115598:	de00012e 	bgeu	sp,et,811155a0 <vPusMebTask+0xc>
8111559c:	003b68fa 	trap	3
811155a0:	dfc00415 	stw	ra,16(sp)
811155a4:	df000315 	stw	fp,12(sp)
811155a8:	df000304 	addi	fp,sp,12
811155ac:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess;
	INT8U error_code;
	unsigned char ucIL;
	static tTMPus xPusLocal;

	bSuccess = FALSE;
811155b0:	e03ffd15 	stw	zero,-12(fp)
	OSMutexPend(xMutexPus, 2, &error_code);
811155b4:	d0a07317 	ldw	r2,-32308(gp)
811155b8:	e0fffe44 	addi	r3,fp,-7
811155bc:	180d883a 	mov	r6,r3
811155c0:	01400084 	movi	r5,2
811155c4:	1009883a 	mov	r4,r2
811155c8:	113cb0c0 	call	8113cb0c <OSMutexPend>
	if ( error_code == OS_ERR_NONE ) {
811155cc:	e0bffe43 	ldbu	r2,-7(fp)
811155d0:	10803fcc 	andi	r2,r2,255
811155d4:	10002c1e 	bne	r2,zero,81115688 <vPusMebTask+0xf4>

	    /*Search for the PUS command*/
	    for(ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
811155d8:	e03ffe05 	stb	zero,-8(fp)
811155dc:	00002306 	br	8111566c <vPusMebTask+0xd8>
	    {
            if ( xPus[ucIL].bInUse == TRUE ) {
811155e0:	e0fffe03 	ldbu	r3,-8(fp)
811155e4:	00a04574 	movhi	r2,33045
811155e8:	10987a04 	addi	r2,r2,25064
811155ec:	18c01524 	muli	r3,r3,84
811155f0:	10c5883a 	add	r2,r2,r3
811155f4:	10800104 	addi	r2,r2,4
811155f8:	10800017 	ldw	r2,0(r2)
811155fc:	10800058 	cmpnei	r2,r2,1
81115600:	1000171e 	bne	r2,zero,81115660 <vPusMebTask+0xcc>
                /* Need to check if the performance is the same as memcpy*/
            	xPusLocal = xPus[ucIL];
81115604:	e13ffe03 	ldbu	r4,-8(fp)
81115608:	00e04574 	movhi	r3,33045
8111560c:	18cdfd04 	addi	r3,r3,14324
81115610:	00a04574 	movhi	r2,33045
81115614:	10987a04 	addi	r2,r2,25064
81115618:	21001524 	muli	r4,r4,84
8111561c:	1105883a 	add	r2,r2,r4
81115620:	1009883a 	mov	r4,r2
81115624:	00801504 	movi	r2,84
81115628:	100d883a 	mov	r6,r2
8111562c:	200b883a 	mov	r5,r4
81115630:	1809883a 	mov	r4,r3
81115634:	11226900 	call	81122690 <memcpy>
            	xPus[ucIL].bInUse = FALSE;
81115638:	e0fffe03 	ldbu	r3,-8(fp)
8111563c:	00a04574 	movhi	r2,33045
81115640:	10987a04 	addi	r2,r2,25064
81115644:	18c01524 	muli	r3,r3,84
81115648:	10c5883a 	add	r2,r2,r3
8111564c:	10800104 	addi	r2,r2,4
81115650:	10000015 	stw	zero,0(r2)
            	bSuccess = TRUE;
81115654:	00800044 	movi	r2,1
81115658:	e0bffd15 	stw	r2,-12(fp)
                break;
8111565c:	00000606 	br	81115678 <vPusMebTask+0xe4>
	bSuccess = FALSE;
	OSMutexPend(xMutexPus, 2, &error_code);
	if ( error_code == OS_ERR_NONE ) {

	    /*Search for the PUS command*/
	    for(ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
81115660:	e0bffe03 	ldbu	r2,-8(fp)
81115664:	10800044 	addi	r2,r2,1
81115668:	e0bffe05 	stb	r2,-8(fp)
8111566c:	e0bffe03 	ldbu	r2,-8(fp)
81115670:	10800130 	cmpltui	r2,r2,4
81115674:	103fda1e 	bne	r2,zero,811155e0 <__reset+0xfb0f55e0>
            	xPus[ucIL].bInUse = FALSE;
            	bSuccess = TRUE;
                break;
            }
	    }
	    OSMutexPost(xMutexPus);
81115678:	d0a07317 	ldw	r2,-32308(gp)
8111567c:	1009883a 	mov	r4,r2
81115680:	113d0b00 	call	8113d0b0 <OSMutexPost>
81115684:	00000106 	br	8111568c <vPusMebTask+0xf8>
	} else {
		vCouldNotGetMutexMebPus();
81115688:	111d1c40 	call	8111d1c4 <vCouldNotGetMutexMebPus>
	}

	if ( bSuccess ) {
8111568c:	e0bffd17 	ldw	r2,-12(fp)
81115690:	10001126 	beq	r2,zero,811156d8 <vPusMebTask+0x144>

		switch (pxMebCLocal->eMode) {
81115694:	e0bfff17 	ldw	r2,-4(fp)
81115698:	10800117 	ldw	r2,4(r2)
8111569c:	10c000e0 	cmpeqi	r3,r2,3
811156a0:	1800031e 	bne	r3,zero,811156b0 <vPusMebTask+0x11c>
811156a4:	10800120 	cmpeqi	r2,r2,4
811156a8:	1000061e 	bne	r2,zero,811156c4 <vPusMebTask+0x130>
				break;
			case sMebRun:
				vPusMebInTaskRunningMode(pxMebCLocal, &xPusLocal);
				break;
			default:
				break;
811156ac:	00000a06 	br	811156d8 <vPusMebTask+0x144>

	if ( bSuccess ) {

		switch (pxMebCLocal->eMode) {
			case sMebConfig:
				vPusMebInTaskConfigMode(pxMebCLocal, &xPusLocal);
811156b0:	01604574 	movhi	r5,33045
811156b4:	294dfd04 	addi	r5,r5,14324
811156b8:	e13fff17 	ldw	r4,-4(fp)
811156bc:	11156f00 	call	811156f0 <vPusMebInTaskConfigMode>
				break;
811156c0:	00000506 	br	811156d8 <vPusMebTask+0x144>
			case sMebRun:
				vPusMebInTaskRunningMode(pxMebCLocal, &xPusLocal);
811156c4:	01604574 	movhi	r5,33045
811156c8:	294dfd04 	addi	r5,r5,14324
811156cc:	e13fff17 	ldw	r4,-4(fp)
811156d0:	1115a800 	call	81115a80 <vPusMebInTaskRunningMode>
				break;
811156d4:	0001883a 	nop
			default:
				break;
		}
	}
}
811156d8:	0001883a 	nop
811156dc:	e037883a 	mov	sp,fp
811156e0:	dfc00117 	ldw	ra,4(sp)
811156e4:	df000017 	ldw	fp,0(sp)
811156e8:	dec00204 	addi	sp,sp,8
811156ec:	f800283a 	ret

811156f0 <vPusMebInTaskConfigMode>:


/* This function should treat the PUS command in the Config Mode, need check all the things that is possible to update in this mode */
/* In the Config Mode the MEb takes control and change all values freely */
void vPusMebInTaskConfigMode( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
811156f0:	defffc04 	addi	sp,sp,-16
811156f4:	de00012e 	bgeu	sp,et,811156fc <vPusMebInTaskConfigMode+0xc>
811156f8:	003b68fa 	trap	3
811156fc:	dfc00315 	stw	ra,12(sp)
81115700:	df000215 	stw	fp,8(sp)
81115704:	df000204 	addi	fp,sp,8
81115708:	e13ffe15 	stw	r4,-8(fp)
8111570c:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiType) {
81115710:	e0bfff17 	ldw	r2,-4(fp)
81115714:	1080030b 	ldhu	r2,12(r2)
81115718:	10bfffcc 	andi	r2,r2,65535
8111571c:	10c03ee0 	cmpeqi	r3,r2,251
81115720:	1800081e 	bne	r3,zero,81115744 <vPusMebInTaskConfigMode+0x54>
81115724:	10c03f20 	cmpeqi	r3,r2,252
81115728:	18000a1e 	bne	r3,zero,81115754 <vPusMebInTaskConfigMode+0x64>
8111572c:	10803ea0 	cmpeqi	r2,r2,250
81115730:	10000c26 	beq	r2,zero,81115764 <vPusMebInTaskConfigMode+0x74>
		/* srv-Type = 250 */
		case 250:
			vPusType250conf(pxMebCLocal, xPusL);
81115734:	e17fff17 	ldw	r5,-4(fp)
81115738:	e13ffe17 	ldw	r4,-8(fp)
8111573c:	111579c0 	call	8111579c <vPusType250conf>
			break;
81115740:	00001006 	br	81115784 <vPusMebInTaskConfigMode+0x94>
		/* srv-Type = 251 */
		case 251:
			vPusType251conf(pxMebCLocal, xPusL);
81115744:	e17fff17 	ldw	r5,-4(fp)
81115748:	e13ffe17 	ldw	r4,-8(fp)
8111574c:	11158280 	call	81115828 <vPusType251conf>
			break;
81115750:	00000c06 	br	81115784 <vPusMebInTaskConfigMode+0x94>
		/* srv-Type = 252 */
		case 252:
			vPusType252conf(pxMebCLocal, xPusL);
81115754:	e17fff17 	ldw	r5,-4(fp)
81115758:	e13ffe17 	ldw	r4,-8(fp)
8111575c:	111587c0 	call	8111587c <vPusType252conf>
			break;
81115760:	00000806 	br	81115784 <vPusMebInTaskConfigMode+0x94>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Srv-Type not allowed in this mode (CONFIG)\n\n" );
81115764:	d0a06217 	ldw	r2,-32376(gp)
81115768:	100f883a 	mov	r7,r2
8111576c:	01800d84 	movi	r6,54
81115770:	01400044 	movi	r5,1
81115774:	01204574 	movhi	r4,33045
81115778:	2138a204 	addi	r4,r4,-7544
8111577c:	1121c7c0 	call	81121c7c <fwrite>
			#endif
			break;
81115780:	0001883a 	nop
	}
}
81115784:	0001883a 	nop
81115788:	e037883a 	mov	sp,fp
8111578c:	dfc00117 	ldw	ra,4(sp)
81115790:	df000017 	ldw	fp,0(sp)
81115794:	dec00204 	addi	sp,sp,8
81115798:	f800283a 	ret

8111579c <vPusType250conf>:

void vPusType250conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
8111579c:	defffc04 	addi	sp,sp,-16
811157a0:	de00012e 	bgeu	sp,et,811157a8 <vPusType250conf+0xc>
811157a4:	003b68fa 	trap	3
811157a8:	dfc00315 	stw	ra,12(sp)
811157ac:	df000215 	stw	fp,8(sp)
811157b0:	df000204 	addi	fp,sp,8
811157b4:	e13ffe15 	stw	r4,-8(fp)
811157b8:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiSubType) {
811157bc:	e0bfff17 	ldw	r2,-4(fp)
811157c0:	1080038b 	ldhu	r2,14(r2)
811157c4:	10bfffcc 	andi	r2,r2,65535
811157c8:	10c00f60 	cmpeqi	r3,r2,61
811157cc:	1800031e 	bne	r3,zero,811157dc <vPusType250conf+0x40>
811157d0:	10800fa0 	cmpeqi	r2,r2,62
811157d4:	10000d1e 	bne	r2,zero,8111580c <vPusType250conf+0x70>
811157d8:	00000406 	br	811157ec <vPusType250conf+0x50>
		/* TC_SCAM_RUN */
		case 61:
			pxMebCLocal->eMode = sMebToRun;
811157dc:	e0bffe17 	ldw	r2,-8(fp)
811157e0:	00c00084 	movi	r3,2
811157e4:	10c00115 	stw	r3,4(r2)
			break;
811157e8:	00000906 	br	81115810 <vPusType250conf+0x74>
			break;
		/* TC_SCAM_CONFIG */
		case 60:
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
811157ec:	d0a06217 	ldw	r2,-32376(gp)
811157f0:	100f883a 	mov	r7,r2
811157f4:	01800b04 	movi	r6,44
811157f8:	01400044 	movi	r5,1
811157fc:	01204574 	movhi	r4,33045
81115800:	2138b004 	addi	r4,r4,-7488
81115804:	1121c7c0 	call	81121c7c <fwrite>
			#endif
			break;
81115808:	00000106 	br	81115810 <vPusType250conf+0x74>
			pxMebCLocal->eMode = sMebToRun;
			break;
		/* TC_SCAM_TURNOFF */
		case 62:
			/*todo: Do nothing for now */
			break;
8111580c:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
			#endif
			break;
	}
}
81115810:	0001883a 	nop
81115814:	e037883a 	mov	sp,fp
81115818:	dfc00117 	ldw	ra,4(sp)
8111581c:	df000017 	ldw	fp,0(sp)
81115820:	dec00204 	addi	sp,sp,8
81115824:	f800283a 	ret

81115828 <vPusType251conf>:

void vPusType251conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81115828:	defffc04 	addi	sp,sp,-16
8111582c:	de00012e 	bgeu	sp,et,81115834 <vPusType251conf+0xc>
81115830:	003b68fa 	trap	3
81115834:	dfc00315 	stw	ra,12(sp)
81115838:	df000215 	stw	fp,8(sp)
8111583c:	df000204 	addi	fp,sp,8
81115840:	e13ffe15 	stw	r4,-8(fp)
81115844:	e17fff15 	stw	r5,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp, "MEB Task: Can't change the mode of the NFEE while MEB is Config mode\n\n" );
81115848:	d0a06217 	ldw	r2,-32376(gp)
8111584c:	100f883a 	mov	r7,r2
81115850:	01801184 	movi	r6,70
81115854:	01400044 	movi	r5,1
81115858:	01204574 	movhi	r4,33045
8111585c:	2138bc04 	addi	r4,r4,-7440
81115860:	1121c7c0 	call	81121c7c <fwrite>
	#endif
}
81115864:	0001883a 	nop
81115868:	e037883a 	mov	sp,fp
8111586c:	dfc00117 	ldw	ra,4(sp)
81115870:	df000017 	ldw	fp,0(sp)
81115874:	dec00204 	addi	sp,sp,8
81115878:	f800283a 	ret

8111587c <vPusType252conf>:

void vPusType252conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
8111587c:	defffb04 	addi	sp,sp,-20
81115880:	de00012e 	bgeu	sp,et,81115888 <vPusType252conf+0xc>
81115884:	003b68fa 	trap	3
81115888:	dfc00415 	stw	ra,16(sp)
8111588c:	df000315 	stw	fp,12(sp)
81115890:	df000304 	addi	fp,sp,12
81115894:	e13ffe15 	stw	r4,-8(fp)
81115898:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
8111589c:	e0bfff17 	ldw	r2,-4(fp)
811158a0:	1080050b 	ldhu	r2,20(r2)
811158a4:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
811158a8:	e0bfff17 	ldw	r2,-4(fp)
811158ac:	1080038b 	ldhu	r2,14(r2)
811158b0:	10bfffcc 	andi	r2,r2,65535
811158b4:	10c000a0 	cmpeqi	r3,r2,2
811158b8:	18000c1e 	bne	r3,zero,811158ec <vPusType252conf+0x70>
811158bc:	10c00090 	cmplti	r3,r2,2
811158c0:	1800611e 	bne	r3,zero,81115a48 <vPusType252conf+0x1cc>
811158c4:	10800188 	cmpgei	r2,r2,6
811158c8:	10005f1e 	bne	r2,zero,81115a48 <vPusType252conf+0x1cc>
		case 3: /* TC_SCAM_SPW_LINK_ENABLE */
		case 4: /* TC_SCAM_SPW_LINK_DISABLE */
		case 5: /* TC_SCAM_SPW_LINK_RESET */
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: Can't perform this operation in the Link while Meb is Config mode \n\n");
811158cc:	d0a06217 	ldw	r2,-32376(gp)
811158d0:	100f883a 	mov	r7,r2
811158d4:	01801384 	movi	r6,78
811158d8:	01400044 	movi	r5,1
811158dc:	01204574 	movhi	r4,33045
811158e0:	2138ce04 	addi	r4,r4,-7368
811158e4:	1121c7c0 	call	81121c7c <fwrite>
			#endif
			break;
811158e8:	00005f06 	br	81115a68 <vPusType252conf+0x1ec>
		case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */

			/* todo: For now we can only update the Logical Address and the RAMP Key */

			/* Disable the RMAP interrupt */
			bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
811158ec:	e0bffd0b 	ldhu	r2,-12(fp)
811158f0:	10809624 	muli	r2,r2,600
811158f4:	10805504 	addi	r2,r2,340
811158f8:	e0fffe17 	ldw	r3,-8(fp)
811158fc:	1885883a 	add	r2,r3,r2
81115900:	1009883a 	mov	r4,r2
81115904:	1107b280 	call	81107b28 <bRmapGetIrqControl>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = FALSE;
81115908:	e0bffd0b 	ldhu	r2,-12(fp)
8111590c:	e0fffe17 	ldw	r3,-8(fp)
81115910:	10809624 	muli	r2,r2,600
81115914:	1885883a 	add	r2,r3,r2
81115918:	10806504 	addi	r2,r2,404
8111591c:	10000015 	stw	zero,0(r2)
			bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81115920:	e0bffd0b 	ldhu	r2,-12(fp)
81115924:	10809624 	muli	r2,r2,600
81115928:	10805504 	addi	r2,r2,340
8111592c:	e0fffe17 	ldw	r3,-8(fp)
81115930:	1885883a 	add	r2,r3,r2
81115934:	1009883a 	mov	r4,r2
81115938:	1107a800 	call	81107a80 <bRmapSetIrqControl>

			/* Change the configuration */
			bRmapGetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
8111593c:	e0bffd0b 	ldhu	r2,-12(fp)
81115940:	10809624 	muli	r2,r2,600
81115944:	10805504 	addi	r2,r2,340
81115948:	e0fffe17 	ldw	r3,-8(fp)
8111594c:	1885883a 	add	r2,r3,r2
81115950:	1009883a 	mov	r4,r2
81115954:	1107d100 	call	81107d10 <bRmapGetCodecConfig>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char)xPusL->usiValues[12];
81115958:	e0bffd0b 	ldhu	r2,-12(fp)
8111595c:	e0ffff17 	ldw	r3,-4(fp)
81115960:	18c00b0b 	ldhu	r3,44(r3)
81115964:	1809883a 	mov	r4,r3
81115968:	e0fffe17 	ldw	r3,-8(fp)
8111596c:	10809624 	muli	r2,r2,600
81115970:	1885883a 	add	r2,r3,r2
81115974:	10805604 	addi	r2,r2,344
81115978:	11000005 	stb	r4,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char)xPusL->usiValues[9];
8111597c:	e0bffd0b 	ldhu	r2,-12(fp)
81115980:	e0ffff17 	ldw	r3,-4(fp)
81115984:	18c0098b 	ldhu	r3,38(r3)
81115988:	1809883a 	mov	r4,r3
8111598c:	e0fffe17 	ldw	r3,-8(fp)
81115990:	10809624 	muli	r2,r2,600
81115994:	1885883a 	add	r2,r3,r2
81115998:	10805644 	addi	r2,r2,345
8111599c:	11000005 	stb	r4,0(r2)
			bRmapSetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
811159a0:	e0bffd0b 	ldhu	r2,-12(fp)
811159a4:	10809624 	muli	r2,r2,600
811159a8:	10805504 	addi	r2,r2,340
811159ac:	e0fffe17 	ldw	r3,-8(fp)
811159b0:	1885883a 	add	r2,r3,r2
811159b4:	1009883a 	mov	r4,r2
811159b8:	1107c380 	call	81107c38 <bRmapSetCodecConfig>


			/* Enable the RMAP interrupt */
			bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
811159bc:	e0bffd0b 	ldhu	r2,-12(fp)
811159c0:	10809624 	muli	r2,r2,600
811159c4:	10805504 	addi	r2,r2,340
811159c8:	e0fffe17 	ldw	r3,-8(fp)
811159cc:	1885883a 	add	r2,r3,r2
811159d0:	1009883a 	mov	r4,r2
811159d4:	1107b280 	call	81107b28 <bRmapGetIrqControl>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = TRUE;
811159d8:	e0bffd0b 	ldhu	r2,-12(fp)
811159dc:	e0fffe17 	ldw	r3,-8(fp)
811159e0:	10809624 	muli	r2,r2,600
811159e4:	1885883a 	add	r2,r3,r2
811159e8:	10806504 	addi	r2,r2,404
811159ec:	00c00044 	movi	r3,1
811159f0:	10c00015 	stw	r3,0(r2)
			bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
811159f4:	e0bffd0b 	ldhu	r2,-12(fp)
811159f8:	10809624 	muli	r2,r2,600
811159fc:	10805504 	addi	r2,r2,340
81115a00:	e0fffe17 	ldw	r3,-8(fp)
81115a04:	1885883a 	add	r2,r3,r2
81115a08:	1009883a 	mov	r4,r2
81115a0c:	1107a800 	call	81107a80 <bRmapSetIrqControl>

			/* todo: Need to treat all the returns */
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
81115a10:	d0e06217 	ldw	r3,-32376(gp)
81115a14:	e0bfff17 	ldw	r2,-4(fp)
81115a18:	10800b0b 	ldhu	r2,44(r2)
81115a1c:	113fffcc 	andi	r4,r2,65535
81115a20:	e0bfff17 	ldw	r2,-4(fp)
81115a24:	1080098b 	ldhu	r2,38(r2)
81115a28:	10bfffcc 	andi	r2,r2,65535
81115a2c:	100f883a 	mov	r7,r2
81115a30:	200d883a 	mov	r6,r4
81115a34:	01604574 	movhi	r5,33045
81115a38:	2978e204 	addi	r5,r5,-7288
81115a3c:	1809883a 	mov	r4,r3
81115a40:	11215e00 	call	811215e0 <fprintf>
			#endif

			break;
81115a44:	00000806 	br	81115a68 <vPusType252conf+0x1ec>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
81115a48:	d0a06217 	ldw	r2,-32376(gp)
81115a4c:	100f883a 	mov	r7,r2
81115a50:	01800b04 	movi	r6,44
81115a54:	01400044 	movi	r5,1
81115a58:	01204574 	movhi	r4,33045
81115a5c:	2138b004 	addi	r4,r4,-7488
81115a60:	1121c7c0 	call	81121c7c <fwrite>
			#endif
			break;
81115a64:	0001883a 	nop
	}
}
81115a68:	0001883a 	nop
81115a6c:	e037883a 	mov	sp,fp
81115a70:	dfc00117 	ldw	ra,4(sp)
81115a74:	df000017 	ldw	fp,0(sp)
81115a78:	dec00204 	addi	sp,sp,8
81115a7c:	f800283a 	ret

81115a80 <vPusMebInTaskRunningMode>:




/* This function should treat the PUS command in the Running Mode, need check all the things that is possible to update in this mode */
void vPusMebInTaskRunningMode( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81115a80:	defffc04 	addi	sp,sp,-16
81115a84:	de00012e 	bgeu	sp,et,81115a8c <vPusMebInTaskRunningMode+0xc>
81115a88:	003b68fa 	trap	3
81115a8c:	dfc00315 	stw	ra,12(sp)
81115a90:	df000215 	stw	fp,8(sp)
81115a94:	df000204 	addi	fp,sp,8
81115a98:	e13ffe15 	stw	r4,-8(fp)
81115a9c:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiType) {
81115aa0:	e0bfff17 	ldw	r2,-4(fp)
81115aa4:	1080030b 	ldhu	r2,12(r2)
81115aa8:	10bfffcc 	andi	r2,r2,65535
81115aac:	10c03ee0 	cmpeqi	r3,r2,251
81115ab0:	1800081e 	bne	r3,zero,81115ad4 <vPusMebInTaskRunningMode+0x54>
81115ab4:	10c03f20 	cmpeqi	r3,r2,252
81115ab8:	18000a1e 	bne	r3,zero,81115ae4 <vPusMebInTaskRunningMode+0x64>
81115abc:	10803ea0 	cmpeqi	r2,r2,250
81115ac0:	10000c26 	beq	r2,zero,81115af4 <vPusMebInTaskRunningMode+0x74>
		/* srv-Type = 250 */
		case 250:
			vPusType250run(pxMebCLocal, xPusL);
81115ac4:	e17fff17 	ldw	r5,-4(fp)
81115ac8:	e13ffe17 	ldw	r4,-8(fp)
81115acc:	1115b2c0 	call	81115b2c <vPusType250run>
			break;
81115ad0:	00001006 	br	81115b14 <vPusMebInTaskRunningMode+0x94>
		/* srv-Type = 251 */
		case 251:
			vPusType251run(pxMebCLocal, xPusL);
81115ad4:	e17fff17 	ldw	r5,-4(fp)
81115ad8:	e13ffe17 	ldw	r4,-8(fp)
81115adc:	1115bb80 	call	81115bb8 <vPusType251run>
			break;
81115ae0:	00000c06 	br	81115b14 <vPusMebInTaskRunningMode+0x94>
		/* srv-Type = 252 */
		case 252:
			vPusType252run(pxMebCLocal, xPusL);
81115ae4:	e17fff17 	ldw	r5,-4(fp)
81115ae8:	e13ffe17 	ldw	r4,-8(fp)
81115aec:	1115ccc0 	call	81115ccc <vPusType252run>
			break;
81115af0:	00000806 	br	81115b14 <vPusMebInTaskRunningMode+0x94>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Srv-Type not allowed in this mode (RUN)\n\n" );
81115af4:	d0a06217 	ldw	r2,-32376(gp)
81115af8:	100f883a 	mov	r7,r2
81115afc:	01800cc4 	movi	r6,51
81115b00:	01400044 	movi	r5,1
81115b04:	01204574 	movhi	r4,33045
81115b08:	2138f204 	addi	r4,r4,-7224
81115b0c:	1121c7c0 	call	81121c7c <fwrite>
			#endif
			break;
81115b10:	0001883a 	nop
	}
}
81115b14:	0001883a 	nop
81115b18:	e037883a 	mov	sp,fp
81115b1c:	dfc00117 	ldw	ra,4(sp)
81115b20:	df000017 	ldw	fp,0(sp)
81115b24:	dec00204 	addi	sp,sp,8
81115b28:	f800283a 	ret

81115b2c <vPusType250run>:


void vPusType250run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81115b2c:	defffc04 	addi	sp,sp,-16
81115b30:	de00012e 	bgeu	sp,et,81115b38 <vPusType250run+0xc>
81115b34:	003b68fa 	trap	3
81115b38:	dfc00315 	stw	ra,12(sp)
81115b3c:	df000215 	stw	fp,8(sp)
81115b40:	df000204 	addi	fp,sp,8
81115b44:	e13ffe15 	stw	r4,-8(fp)
81115b48:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiSubType) {
81115b4c:	e0bfff17 	ldw	r2,-4(fp)
81115b50:	1080038b 	ldhu	r2,14(r2)
81115b54:	10bfffcc 	andi	r2,r2,65535
81115b58:	10c00f20 	cmpeqi	r3,r2,60
81115b5c:	1800031e 	bne	r3,zero,81115b6c <vPusType250run+0x40>
81115b60:	10800fa0 	cmpeqi	r2,r2,62
81115b64:	10000d1e 	bne	r2,zero,81115b9c <vPusType250run+0x70>
81115b68:	00000406 	br	81115b7c <vPusType250run+0x50>
		/* TC_SCAM_CONFIG */
		case 60:
			pxMebCLocal->eMode = sMebToConfig;
81115b6c:	e0bffe17 	ldw	r2,-8(fp)
81115b70:	00c00044 	movi	r3,1
81115b74:	10c00115 	stw	r3,4(r2)
			break;
81115b78:	00000906 	br	81115ba0 <vPusType250run+0x74>
			break;
		/* TC_SCAM_RUN */
		case 61:
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
81115b7c:	d0a06217 	ldw	r2,-32376(gp)
81115b80:	100f883a 	mov	r7,r2
81115b84:	01800c84 	movi	r6,50
81115b88:	01400044 	movi	r5,1
81115b8c:	01204574 	movhi	r4,33045
81115b90:	2138ff04 	addi	r4,r4,-7172
81115b94:	1121c7c0 	call	81121c7c <fwrite>
			#endif
			break;
81115b98:	00000106 	br	81115ba0 <vPusType250run+0x74>
			pxMebCLocal->eMode = sMebToConfig;
			break;
		/* TC_SCAM_TURNOFF */
		case 62:
			/*todo: Do nothing for now */
			break;
81115b9c:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
			#endif
			break;
	}
}
81115ba0:	0001883a 	nop
81115ba4:	e037883a 	mov	sp,fp
81115ba8:	dfc00117 	ldw	ra,4(sp)
81115bac:	df000017 	ldw	fp,0(sp)
81115bb0:	dec00204 	addi	sp,sp,8
81115bb4:	f800283a 	ret

81115bb8 <vPusType251run>:

void vPusType251run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81115bb8:	defffb04 	addi	sp,sp,-20
81115bbc:	de00012e 	bgeu	sp,et,81115bc4 <vPusType251run+0xc>
81115bc0:	003b68fa 	trap	3
81115bc4:	dfc00415 	stw	ra,16(sp)
81115bc8:	df000315 	stw	fp,12(sp)
81115bcc:	df000304 	addi	fp,sp,12
81115bd0:	e13ffe15 	stw	r4,-8(fp)
81115bd4:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
81115bd8:	e0bfff17 	ldw	r2,-4(fp)
81115bdc:	1080050b 	ldhu	r2,20(r2)
81115be0:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
81115be4:	e0bfff17 	ldw	r2,-4(fp)
81115be8:	1080038b 	ldhu	r2,14(r2)
81115bec:	10bfffcc 	andi	r2,r2,65535
81115bf0:	10c000a0 	cmpeqi	r3,r2,2
81115bf4:	18000f1e 	bne	r3,zero,81115c34 <vPusType251run+0x7c>
81115bf8:	10c00160 	cmpeqi	r3,r2,5
81115bfc:	1800181e 	bne	r3,zero,81115c60 <vPusType251run+0xa8>
81115c00:	10800060 	cmpeqi	r2,r2,1
81115c04:	10002126 	beq	r2,zero,81115c8c <vPusType251run+0xd4>
		/* TC_SCAM_FEE_CONFIG_ENTER */
		case 1:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_CONFIG, 0, usiFeeInstL );
81115c08:	e0bffd0b 	ldhu	r2,-12(fp)
81115c0c:	10800444 	addi	r2,r2,17
81115c10:	10803fcc 	andi	r2,r2,255
81115c14:	e0fffd0b 	ldhu	r3,-12(fp)
81115c18:	18c03fcc 	andi	r3,r3,255
81115c1c:	180f883a 	mov	r7,r3
81115c20:	000d883a 	mov	r6,zero
81115c24:	01400044 	movi	r5,1
81115c28:	1009883a 	mov	r4,r2
81115c2c:	11161640 	call	81116164 <vSendCmdQToNFeeCTRL_GEN>
			break;
81115c30:	00002006 	br	81115cb4 <vPusType251run+0xfc>
		/* TC_SCAM_FEE_STANDBY_ENTER */
		case 2:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_STANDBY, 0, usiFeeInstL );
81115c34:	e0bffd0b 	ldhu	r2,-12(fp)
81115c38:	10800444 	addi	r2,r2,17
81115c3c:	10803fcc 	andi	r2,r2,255
81115c40:	e0fffd0b 	ldhu	r3,-12(fp)
81115c44:	18c03fcc 	andi	r3,r3,255
81115c48:	180f883a 	mov	r7,r3
81115c4c:	000d883a 	mov	r6,zero
81115c50:	01400104 	movi	r5,4
81115c54:	1009883a 	mov	r4,r2
81115c58:	11161640 	call	81116164 <vSendCmdQToNFeeCTRL_GEN>
			break;
81115c5c:	00001506 	br	81115cb4 <vPusType251run+0xfc>
		/* TC_SCAM_FEE_CALIBRATION_TEST_ENTER */
		case 5:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_FULL_PATTERN, 0, usiFeeInstL );
81115c60:	e0bffd0b 	ldhu	r2,-12(fp)
81115c64:	10800444 	addi	r2,r2,17
81115c68:	10803fcc 	andi	r2,r2,255
81115c6c:	e0fffd0b 	ldhu	r3,-12(fp)
81115c70:	18c03fcc 	andi	r3,r3,255
81115c74:	180f883a 	mov	r7,r3
81115c78:	000d883a 	mov	r6,zero
81115c7c:	01400204 	movi	r5,8
81115c80:	1009883a 	mov	r4,r2
81115c84:	11161640 	call	81116164 <vSendCmdQToNFeeCTRL_GEN>
			break;
81115c88:	00000a06 	br	81115cb4 <vPusType251run+0xfc>
		case 3:
		case 4:
		case 6:
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not implemented yet (SubType:%hu)\n\n",xPusL->usiSubType );
81115c8c:	d0e06217 	ldw	r3,-32376(gp)
81115c90:	e0bfff17 	ldw	r2,-4(fp)
81115c94:	1080038b 	ldhu	r2,14(r2)
81115c98:	10bfffcc 	andi	r2,r2,65535
81115c9c:	100d883a 	mov	r6,r2
81115ca0:	01604574 	movhi	r5,33045
81115ca4:	29790c04 	addi	r5,r5,-7120
81115ca8:	1809883a 	mov	r4,r3
81115cac:	11215e00 	call	811215e0 <fprintf>
			#endif
			break;
81115cb0:	0001883a 	nop
	}
}
81115cb4:	0001883a 	nop
81115cb8:	e037883a 	mov	sp,fp
81115cbc:	dfc00117 	ldw	ra,4(sp)
81115cc0:	df000017 	ldw	fp,0(sp)
81115cc4:	dec00204 	addi	sp,sp,8
81115cc8:	f800283a 	ret

81115ccc <vPusType252run>:

void vPusType252run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81115ccc:	defffb04 	addi	sp,sp,-20
81115cd0:	de00012e 	bgeu	sp,et,81115cd8 <vPusType252run+0xc>
81115cd4:	003b68fa 	trap	3
81115cd8:	dfc00415 	stw	ra,16(sp)
81115cdc:	df000315 	stw	fp,12(sp)
81115ce0:	df000304 	addi	fp,sp,12
81115ce4:	e13ffe15 	stw	r4,-8(fp)
81115ce8:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
81115cec:	e0bfff17 	ldw	r2,-4(fp)
81115cf0:	1080050b 	ldhu	r2,20(r2)
81115cf4:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
81115cf8:	e0bfff17 	ldw	r2,-4(fp)
81115cfc:	1080038b 	ldhu	r2,14(r2)
81115d00:	10bfffcc 	andi	r2,r2,65535
81115d04:	10c000e0 	cmpeqi	r3,r2,3
81115d08:	18000a1e 	bne	r3,zero,81115d34 <vPusType252run+0x68>
81115d0c:	10c00108 	cmpgei	r3,r2,4
81115d10:	1800031e 	bne	r3,zero,81115d20 <vPusType252run+0x54>
81115d14:	108000a0 	cmpeqi	r2,r2,2
81115d18:	1000581e 	bne	r2,zero,81115e7c <vPusType252run+0x1b0>
81115d1c:	0000be06 	br	81116018 <vPusType252run+0x34c>
81115d20:	10c00120 	cmpeqi	r3,r2,4
81115d24:	18002c1e 	bne	r3,zero,81115dd8 <vPusType252run+0x10c>
81115d28:	10800160 	cmpeqi	r2,r2,5
81115d2c:	1000c21e 	bne	r2,zero,81116038 <vPusType252run+0x36c>
81115d30:	0000b906 	br	81116018 <vPusType252run+0x34c>
		case 3: /* TC_SCAM_SPW_LINK_ENABLE */
			bSpwcGetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81115d34:	e0bffd0b 	ldhu	r2,-12(fp)
81115d38:	10809624 	muli	r2,r2,600
81115d3c:	10809b04 	addi	r2,r2,620
81115d40:	e0fffe17 	ldw	r3,-8(fp)
81115d44:	1885883a 	add	r2,r3,r2
81115d48:	1009883a 	mov	r4,r2
81115d4c:	110a4ac0 	call	8110a4ac <bSpwcGetLink>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bLinkStart = FALSE;
81115d50:	e0bffd0b 	ldhu	r2,-12(fp)
81115d54:	e0fffe17 	ldw	r3,-8(fp)
81115d58:	10809624 	muli	r2,r2,600
81115d5c:	1885883a 	add	r2,r3,r2
81115d60:	10809d04 	addi	r2,r2,628
81115d64:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bAutostart = TRUE;
81115d68:	e0bffd0b 	ldhu	r2,-12(fp)
81115d6c:	e0fffe17 	ldw	r3,-8(fp)
81115d70:	10809624 	muli	r2,r2,600
81115d74:	1885883a 	add	r2,r3,r2
81115d78:	10809c04 	addi	r2,r2,624
81115d7c:	00c00044 	movi	r3,1
81115d80:	10c00015 	stw	r3,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bDisconnect = FALSE;
81115d84:	e0bffd0b 	ldhu	r2,-12(fp)
81115d88:	e0fffe17 	ldw	r3,-8(fp)
81115d8c:	10809624 	muli	r2,r2,600
81115d90:	1885883a 	add	r2,r3,r2
81115d94:	10809e04 	addi	r2,r2,632
81115d98:	10000015 	stw	zero,0(r2)
			bSpwcSetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81115d9c:	e0bffd0b 	ldhu	r2,-12(fp)
81115da0:	10809624 	muli	r2,r2,600
81115da4:	10809b04 	addi	r2,r2,620
81115da8:	e0fffe17 	ldw	r3,-8(fp)
81115dac:	1885883a 	add	r2,r3,r2
81115db0:	1009883a 	mov	r4,r2
81115db4:	110a3780 	call	8110a378 <bSpwcSetLink>
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: Link enable (NFEE-%hu)\n\n", usiFeeInstL);
81115db8:	d0a06217 	ldw	r2,-32376(gp)
81115dbc:	e0fffd0b 	ldhu	r3,-12(fp)
81115dc0:	180d883a 	mov	r6,r3
81115dc4:	01604574 	movhi	r5,33045
81115dc8:	29791a04 	addi	r5,r5,-7064
81115dcc:	1009883a 	mov	r4,r2
81115dd0:	11215e00 	call	811215e0 <fprintf>
			#endif

			break;
81115dd4:	00009906 	br	8111603c <vPusType252run+0x370>

		case 4: /* TC_SCAM_SPW_LINK_DISABLE */
			bSpwcGetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81115dd8:	e0bffd0b 	ldhu	r2,-12(fp)
81115ddc:	10809624 	muli	r2,r2,600
81115de0:	10809b04 	addi	r2,r2,620
81115de4:	e0fffe17 	ldw	r3,-8(fp)
81115de8:	1885883a 	add	r2,r3,r2
81115dec:	1009883a 	mov	r4,r2
81115df0:	110a4ac0 	call	8110a4ac <bSpwcGetLink>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bLinkStart = FALSE;
81115df4:	e0bffd0b 	ldhu	r2,-12(fp)
81115df8:	e0fffe17 	ldw	r3,-8(fp)
81115dfc:	10809624 	muli	r2,r2,600
81115e00:	1885883a 	add	r2,r3,r2
81115e04:	10809d04 	addi	r2,r2,628
81115e08:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bAutostart = FALSE;
81115e0c:	e0bffd0b 	ldhu	r2,-12(fp)
81115e10:	e0fffe17 	ldw	r3,-8(fp)
81115e14:	10809624 	muli	r2,r2,600
81115e18:	1885883a 	add	r2,r3,r2
81115e1c:	10809c04 	addi	r2,r2,624
81115e20:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bDisconnect = TRUE;
81115e24:	e0bffd0b 	ldhu	r2,-12(fp)
81115e28:	e0fffe17 	ldw	r3,-8(fp)
81115e2c:	10809624 	muli	r2,r2,600
81115e30:	1885883a 	add	r2,r3,r2
81115e34:	10809e04 	addi	r2,r2,632
81115e38:	00c00044 	movi	r3,1
81115e3c:	10c00015 	stw	r3,0(r2)
			bSpwcSetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81115e40:	e0bffd0b 	ldhu	r2,-12(fp)
81115e44:	10809624 	muli	r2,r2,600
81115e48:	10809b04 	addi	r2,r2,620
81115e4c:	e0fffe17 	ldw	r3,-8(fp)
81115e50:	1885883a 	add	r2,r3,r2
81115e54:	1009883a 	mov	r4,r2
81115e58:	110a3780 	call	8110a378 <bSpwcSetLink>
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: Link disable (NFEE-%hu)\n\n", usiFeeInstL);
81115e5c:	d0a06217 	ldw	r2,-32376(gp)
81115e60:	e0fffd0b 	ldhu	r3,-12(fp)
81115e64:	180d883a 	mov	r6,r3
81115e68:	01604574 	movhi	r5,33045
81115e6c:	29792304 	addi	r5,r5,-7028
81115e70:	1009883a 	mov	r4,r2
81115e74:	11215e00 	call	811215e0 <fprintf>
			#endif

			break;
81115e78:	00007006 	br	8111603c <vPusType252run+0x370>
			break;

		case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */

			/* todo: For now we can only update the Logical Address and the RAMP Key */
			if ( pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xControl.eMode == sFeeConfig ) {
81115e7c:	e0bffd0b 	ldhu	r2,-12(fp)
81115e80:	e0fffe17 	ldw	r3,-8(fp)
81115e84:	10809624 	muli	r2,r2,600
81115e88:	1885883a 	add	r2,r3,r2
81115e8c:	10803e04 	addi	r2,r2,248
81115e90:	10800017 	ldw	r2,0(r2)
81115e94:	10800058 	cmpnei	r2,r2,1
81115e98:	10004a1e 	bne	r2,zero,81115fc4 <vPusType252run+0x2f8>
				/* Disable the RMAP interrupt */
				bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81115e9c:	e0bffd0b 	ldhu	r2,-12(fp)
81115ea0:	10809624 	muli	r2,r2,600
81115ea4:	10805504 	addi	r2,r2,340
81115ea8:	e0fffe17 	ldw	r3,-8(fp)
81115eac:	1885883a 	add	r2,r3,r2
81115eb0:	1009883a 	mov	r4,r2
81115eb4:	1107b280 	call	81107b28 <bRmapGetIrqControl>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = FALSE;
81115eb8:	e0bffd0b 	ldhu	r2,-12(fp)
81115ebc:	e0fffe17 	ldw	r3,-8(fp)
81115ec0:	10809624 	muli	r2,r2,600
81115ec4:	1885883a 	add	r2,r3,r2
81115ec8:	10806504 	addi	r2,r2,404
81115ecc:	10000015 	stw	zero,0(r2)
				bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81115ed0:	e0bffd0b 	ldhu	r2,-12(fp)
81115ed4:	10809624 	muli	r2,r2,600
81115ed8:	10805504 	addi	r2,r2,340
81115edc:	e0fffe17 	ldw	r3,-8(fp)
81115ee0:	1885883a 	add	r2,r3,r2
81115ee4:	1009883a 	mov	r4,r2
81115ee8:	1107a800 	call	81107a80 <bRmapSetIrqControl>

				/* Change the configuration */
				bRmapGetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
81115eec:	e0bffd0b 	ldhu	r2,-12(fp)
81115ef0:	10809624 	muli	r2,r2,600
81115ef4:	10805504 	addi	r2,r2,340
81115ef8:	e0fffe17 	ldw	r3,-8(fp)
81115efc:	1885883a 	add	r2,r3,r2
81115f00:	1009883a 	mov	r4,r2
81115f04:	1107d100 	call	81107d10 <bRmapGetCodecConfig>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char)xPusL->usiValues[12];
81115f08:	e0bffd0b 	ldhu	r2,-12(fp)
81115f0c:	e0ffff17 	ldw	r3,-4(fp)
81115f10:	18c00b0b 	ldhu	r3,44(r3)
81115f14:	1809883a 	mov	r4,r3
81115f18:	e0fffe17 	ldw	r3,-8(fp)
81115f1c:	10809624 	muli	r2,r2,600
81115f20:	1885883a 	add	r2,r3,r2
81115f24:	10805604 	addi	r2,r2,344
81115f28:	11000005 	stb	r4,0(r2)
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char)xPusL->usiValues[9];
81115f2c:	e0bffd0b 	ldhu	r2,-12(fp)
81115f30:	e0ffff17 	ldw	r3,-4(fp)
81115f34:	18c0098b 	ldhu	r3,38(r3)
81115f38:	1809883a 	mov	r4,r3
81115f3c:	e0fffe17 	ldw	r3,-8(fp)
81115f40:	10809624 	muli	r2,r2,600
81115f44:	1885883a 	add	r2,r3,r2
81115f48:	10805644 	addi	r2,r2,345
81115f4c:	11000005 	stb	r4,0(r2)
				bRmapSetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
81115f50:	e0bffd0b 	ldhu	r2,-12(fp)
81115f54:	10809624 	muli	r2,r2,600
81115f58:	10805504 	addi	r2,r2,340
81115f5c:	e0fffe17 	ldw	r3,-8(fp)
81115f60:	1885883a 	add	r2,r3,r2
81115f64:	1009883a 	mov	r4,r2
81115f68:	1107c380 	call	81107c38 <bRmapSetCodecConfig>


				/* Enable the RMAP interrupt */
				bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81115f6c:	e0bffd0b 	ldhu	r2,-12(fp)
81115f70:	10809624 	muli	r2,r2,600
81115f74:	10805504 	addi	r2,r2,340
81115f78:	e0fffe17 	ldw	r3,-8(fp)
81115f7c:	1885883a 	add	r2,r3,r2
81115f80:	1009883a 	mov	r4,r2
81115f84:	1107b280 	call	81107b28 <bRmapGetIrqControl>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = TRUE;
81115f88:	e0bffd0b 	ldhu	r2,-12(fp)
81115f8c:	e0fffe17 	ldw	r3,-8(fp)
81115f90:	10809624 	muli	r2,r2,600
81115f94:	1885883a 	add	r2,r3,r2
81115f98:	10806504 	addi	r2,r2,404
81115f9c:	00c00044 	movi	r3,1
81115fa0:	10c00015 	stw	r3,0(r2)
				bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81115fa4:	e0bffd0b 	ldhu	r2,-12(fp)
81115fa8:	10809624 	muli	r2,r2,600
81115fac:	10805504 	addi	r2,r2,340
81115fb0:	e0fffe17 	ldw	r3,-8(fp)
81115fb4:	1885883a 	add	r2,r3,r2
81115fb8:	1009883a 	mov	r4,r2
81115fbc:	1107a800 	call	81107a80 <bRmapSetIrqControl>
81115fc0:	00000706 	br	81115fe0 <vPusType252run+0x314>
			} else {
				#ifdef DEBUG_ON
					fprintf(fp,"MEB Task: NFEE-%hu is not in the Config Mode ( Changes not performed )\n\n", usiFeeInstL);
81115fc4:	d0a06217 	ldw	r2,-32376(gp)
81115fc8:	e0fffd0b 	ldhu	r3,-12(fp)
81115fcc:	180d883a 	mov	r6,r3
81115fd0:	01604574 	movhi	r5,33045
81115fd4:	29792c04 	addi	r5,r5,-6992
81115fd8:	1009883a 	mov	r4,r2
81115fdc:	11215e00 	call	811215e0 <fprintf>
				#endif
			}

			/* todo: Need to treat all the returns */
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
81115fe0:	d0e06217 	ldw	r3,-32376(gp)
81115fe4:	e0bfff17 	ldw	r2,-4(fp)
81115fe8:	10800b0b 	ldhu	r2,44(r2)
81115fec:	113fffcc 	andi	r4,r2,65535
81115ff0:	e0bfff17 	ldw	r2,-4(fp)
81115ff4:	1080098b 	ldhu	r2,38(r2)
81115ff8:	10bfffcc 	andi	r2,r2,65535
81115ffc:	100f883a 	mov	r7,r2
81116000:	200d883a 	mov	r6,r4
81116004:	01604574 	movhi	r5,33045
81116008:	2978e204 	addi	r5,r5,-7288
8111600c:	1809883a 	mov	r4,r3
81116010:	11215e00 	call	811215e0 <fprintf>
			#endif
			break;
81116014:	00000906 	br	8111603c <vPusType252run+0x370>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
81116018:	d0a06217 	ldw	r2,-32376(gp)
8111601c:	100f883a 	mov	r7,r2
81116020:	01800c84 	movi	r6,50
81116024:	01400044 	movi	r5,1
81116028:	01204574 	movhi	r4,33045
8111602c:	2138ff04 	addi	r4,r4,-7172
81116030:	1121c7c0 	call	81121c7c <fwrite>
			#endif
			break;
81116034:	00000106 	br	8111603c <vPusType252run+0x370>

			break;

		case 5: /* TC_SCAM_SPW_LINK_RESET */
			/* todo:Do nothing, don't know what is reset spw link */
			break;
81116038:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
			#endif
			break;
	}
}
8111603c:	0001883a 	nop
81116040:	e037883a 	mov	sp,fp
81116044:	dfc00117 	ldw	ra,4(sp)
81116048:	df000017 	ldw	fp,0(sp)
8111604c:	dec00204 	addi	sp,sp,8
81116050:	f800283a 	ret

81116054 <vSendCmdQToNFeeCTRL>:



void vSendCmdQToNFeeCTRL( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81116054:	defff904 	addi	sp,sp,-28
81116058:	de00012e 	bgeu	sp,et,81116060 <vSendCmdQToNFeeCTRL+0xc>
8111605c:	003b68fa 	trap	3
81116060:	dfc00615 	stw	ra,24(sp)
81116064:	df000515 	stw	fp,20(sp)
81116068:	df000504 	addi	fp,sp,20
8111606c:	2807883a 	mov	r3,r5
81116070:	3005883a 	mov	r2,r6
81116074:	e13ffd05 	stb	r4,-12(fp)
81116078:	e0fffe05 	stb	r3,-8(fp)
8111607c:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81116080:	00800404 	movi	r2,16
81116084:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81116088:	e0bffd03 	ldbu	r2,-12(fp)
8111608c:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81116090:	e0bffe03 	ldbu	r2,-8(fp)
81116094:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81116098:	e0bfff03 	ldbu	r2,-4(fp)
8111609c:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
811160a0:	d0a07017 	ldw	r2,-32320(gp)
811160a4:	e0fffc17 	ldw	r3,-16(fp)
811160a8:	180b883a 	mov	r5,r3
811160ac:	1009883a 	mov	r4,r2
811160b0:	113e0280 	call	8113e028 <OSQPost>
811160b4:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
811160b8:	e0bffb03 	ldbu	r2,-20(fp)
811160bc:	10000126 	beq	r2,zero,811160c4 <vSendCmdQToNFeeCTRL+0x70>
		vFailSendMsgFeeCTRL();
811160c0:	111d5f40 	call	8111d5f4 <vFailSendMsgFeeCTRL>
	}
}
811160c4:	0001883a 	nop
811160c8:	e037883a 	mov	sp,fp
811160cc:	dfc00117 	ldw	ra,4(sp)
811160d0:	df000017 	ldw	fp,0(sp)
811160d4:	dec00204 	addi	sp,sp,8
811160d8:	f800283a 	ret

811160dc <vSendCmdQToNFeeCTRL_PRIO>:

void vSendCmdQToNFeeCTRL_PRIO( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
811160dc:	defff904 	addi	sp,sp,-28
811160e0:	de00012e 	bgeu	sp,et,811160e8 <vSendCmdQToNFeeCTRL_PRIO+0xc>
811160e4:	003b68fa 	trap	3
811160e8:	dfc00615 	stw	ra,24(sp)
811160ec:	df000515 	stw	fp,20(sp)
811160f0:	df000504 	addi	fp,sp,20
811160f4:	2807883a 	mov	r3,r5
811160f8:	3005883a 	mov	r2,r6
811160fc:	e13ffd05 	stb	r4,-12(fp)
81116100:	e0fffe05 	stb	r3,-8(fp)
81116104:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81116108:	00800404 	movi	r2,16
8111610c:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81116110:	e0bffd03 	ldbu	r2,-12(fp)
81116114:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81116118:	e0bffe03 	ldbu	r2,-8(fp)
8111611c:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81116120:	e0bfff03 	ldbu	r2,-4(fp)
81116124:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPostFront(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
81116128:	d0a07017 	ldw	r2,-32320(gp)
8111612c:	e0fffc17 	ldw	r3,-16(fp)
81116130:	180b883a 	mov	r5,r3
81116134:	1009883a 	mov	r4,r2
81116138:	113e1980 	call	8113e198 <OSQPostFront>
8111613c:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81116140:	e0bffb03 	ldbu	r2,-20(fp)
81116144:	10000126 	beq	r2,zero,8111614c <vSendCmdQToNFeeCTRL_PRIO+0x70>
		vFailSendMsgFeeCTRL();
81116148:	111d5f40 	call	8111d5f4 <vFailSendMsgFeeCTRL>
	}
}
8111614c:	0001883a 	nop
81116150:	e037883a 	mov	sp,fp
81116154:	dfc00117 	ldw	ra,4(sp)
81116158:	df000017 	ldw	fp,0(sp)
8111615c:	dec00204 	addi	sp,sp,8
81116160:	f800283a 	ret

81116164 <vSendCmdQToNFeeCTRL_GEN>:


/* Send to FEEs using the NFEE Controller */
void vSendCmdQToNFeeCTRL_GEN( unsigned char ADDR,unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81116164:	defff804 	addi	sp,sp,-32
81116168:	de00012e 	bgeu	sp,et,81116170 <vSendCmdQToNFeeCTRL_GEN+0xc>
8111616c:	003b68fa 	trap	3
81116170:	dfc00715 	stw	ra,28(sp)
81116174:	df000615 	stw	fp,24(sp)
81116178:	df000604 	addi	fp,sp,24
8111617c:	2011883a 	mov	r8,r4
81116180:	2809883a 	mov	r4,r5
81116184:	3007883a 	mov	r3,r6
81116188:	3805883a 	mov	r2,r7
8111618c:	e23ffc05 	stb	r8,-16(fp)
81116190:	e13ffd05 	stb	r4,-12(fp)
81116194:	e0fffe05 	stb	r3,-8(fp)
81116198:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = ADDR;
8111619c:	e0bffc03 	ldbu	r2,-16(fp)
811161a0:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
811161a4:	e0bffd03 	ldbu	r2,-12(fp)
811161a8:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
811161ac:	e0bffe03 	ldbu	r2,-8(fp)
811161b0:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
811161b4:	e0bfff03 	ldbu	r2,-4(fp)
811161b8:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
811161bc:	d0a07017 	ldw	r2,-32320(gp)
811161c0:	e0fffb17 	ldw	r3,-20(fp)
811161c4:	180b883a 	mov	r5,r3
811161c8:	1009883a 	mov	r4,r2
811161cc:	113e0280 	call	8113e028 <OSQPost>
811161d0:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
811161d4:	e0bffa03 	ldbu	r2,-24(fp)
811161d8:	10000126 	beq	r2,zero,811161e0 <vSendCmdQToNFeeCTRL_GEN+0x7c>
		vFailSendMsgFeeCTRL();
811161dc:	111d5f40 	call	8111d5f4 <vFailSendMsgFeeCTRL>
	}
}
811161e0:	0001883a 	nop
811161e4:	e037883a 	mov	sp,fp
811161e8:	dfc00117 	ldw	ra,4(sp)
811161ec:	df000017 	ldw	fp,0(sp)
811161f0:	dec00204 	addi	sp,sp,8
811161f4:	f800283a 	ret

811161f8 <vSendCmdQToDataCTRL>:


void vSendCmdQToDataCTRL( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
811161f8:	defff904 	addi	sp,sp,-28
811161fc:	de00012e 	bgeu	sp,et,81116204 <vSendCmdQToDataCTRL+0xc>
81116200:	003b68fa 	trap	3
81116204:	dfc00615 	stw	ra,24(sp)
81116208:	df000515 	stw	fp,20(sp)
8111620c:	df000504 	addi	fp,sp,20
81116210:	2807883a 	mov	r3,r5
81116214:	3005883a 	mov	r2,r6
81116218:	e13ffd05 	stb	r4,-12(fp)
8111621c:	e0fffe05 	stb	r3,-8(fp)
81116220:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_DATA_CTRL_ADDR;
81116224:	00800804 	movi	r2,32
81116228:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
8111622c:	e0bffd03 	ldbu	r2,-12(fp)
81116230:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81116234:	e0bffe03 	ldbu	r2,-8(fp)
81116238:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
8111623c:	e0bfff03 	ldbu	r2,-4(fp)
81116240:	e0bffc05 	stb	r2,-16(fp)

	/*Send a command to other entities (Data Controller) */
	error_codel = OSQPost(xQMaskDataCtrl, (void *)uiCmdtoSend.ulWord);
81116244:	d0a05f17 	ldw	r2,-32388(gp)
81116248:	e0fffc17 	ldw	r3,-16(fp)
8111624c:	180b883a 	mov	r5,r3
81116250:	1009883a 	mov	r4,r2
81116254:	113e0280 	call	8113e028 <OSQPost>
81116258:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
8111625c:	e0bffb03 	ldbu	r2,-20(fp)
81116260:	10000126 	beq	r2,zero,81116268 <vSendCmdQToDataCTRL+0x70>
		vFailSendMsgDataCTRL();
81116264:	111d6400 	call	8111d640 <vFailSendMsgDataCTRL>
	}
}
81116268:	0001883a 	nop
8111626c:	e037883a 	mov	sp,fp
81116270:	dfc00117 	ldw	ra,4(sp)
81116274:	df000017 	ldw	fp,0(sp)
81116278:	dec00204 	addi	sp,sp,8
8111627c:	f800283a 	ret

81116280 <vSendCmdQToDataCTRL_PRIO>:

void vSendCmdQToDataCTRL_PRIO( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81116280:	defff904 	addi	sp,sp,-28
81116284:	de00012e 	bgeu	sp,et,8111628c <vSendCmdQToDataCTRL_PRIO+0xc>
81116288:	003b68fa 	trap	3
8111628c:	dfc00615 	stw	ra,24(sp)
81116290:	df000515 	stw	fp,20(sp)
81116294:	df000504 	addi	fp,sp,20
81116298:	2807883a 	mov	r3,r5
8111629c:	3005883a 	mov	r2,r6
811162a0:	e13ffd05 	stb	r4,-12(fp)
811162a4:	e0fffe05 	stb	r3,-8(fp)
811162a8:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
811162ac:	00800404 	movi	r2,16
811162b0:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
811162b4:	e0bffd03 	ldbu	r2,-12(fp)
811162b8:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
811162bc:	e0bffe03 	ldbu	r2,-8(fp)
811162c0:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
811162c4:	e0bfff03 	ldbu	r2,-4(fp)
811162c8:	e0bffc05 	stb	r2,-16(fp)

	/*Send a command to other entities (Data Controller) */
	error_codel = OSQPostFront(xQMaskDataCtrl, (void *)uiCmdtoSend.ulWord);
811162cc:	d0a05f17 	ldw	r2,-32388(gp)
811162d0:	e0fffc17 	ldw	r3,-16(fp)
811162d4:	180b883a 	mov	r5,r3
811162d8:	1009883a 	mov	r4,r2
811162dc:	113e1980 	call	8113e198 <OSQPostFront>
811162e0:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
811162e4:	e0bffb03 	ldbu	r2,-20(fp)
811162e8:	10000126 	beq	r2,zero,811162f0 <vSendCmdQToDataCTRL_PRIO+0x70>
		vFailSendMsgFeeCTRL();
811162ec:	111d5f40 	call	8111d5f4 <vFailSendMsgFeeCTRL>
	}
}
811162f0:	0001883a 	nop
811162f4:	e037883a 	mov	sp,fp
811162f8:	dfc00117 	ldw	ra,4(sp)
811162fc:	df000017 	ldw	fp,0(sp)
81116300:	dec00204 	addi	sp,sp,8
81116304:	f800283a 	ret

81116308 <vMebInit>:


void vMebInit(TSimucam_MEB *pxMebCLocal) {
81116308:	defffc04 	addi	sp,sp,-16
8111630c:	de00012e 	bgeu	sp,et,81116314 <vMebInit+0xc>
81116310:	003b68fa 	trap	3
81116314:	dfc00315 	stw	ra,12(sp)
81116318:	df000215 	stw	fp,8(sp)
8111631c:	df000204 	addi	fp,sp,8
81116320:	e13fff15 	stw	r4,-4(fp)
	INT8U errorCodeL;

	pxMebCLocal->ucActualDDR = 0;
81116324:	e0bfff17 	ldw	r2,-4(fp)
81116328:	10000205 	stb	zero,8(r2)
	pxMebCLocal->ucNextDDR = 1;
8111632c:	e0bfff17 	ldw	r2,-4(fp)
81116330:	00c00044 	movi	r3,1
81116334:	10c00245 	stb	r3,9(r2)
	/* Flush all communication Queues */
	errorCodeL = OSQFlush(xMebQ);
81116338:	d0a06917 	ldw	r2,-32348(gp)
8111633c:	1009883a 	mov	r4,r2
81116340:	113db600 	call	8113db60 <OSQFlush>
81116344:	e0bffe05 	stb	r2,-8(fp)
	if ( errorCodeL != OS_NO_ERR ) {
81116348:	e0bffe03 	ldbu	r2,-8(fp)
8111634c:	10000126 	beq	r2,zero,81116354 <vMebInit+0x4c>
		vFailFlushMEBQueue();
81116350:	111d7240 	call	8111d724 <vFailFlushMEBQueue>
	}
}
81116354:	0001883a 	nop
81116358:	e037883a 	mov	sp,fp
8111635c:	dfc00117 	ldw	ra,4(sp)
81116360:	df000017 	ldw	fp,0(sp)
81116364:	dec00204 	addi	sp,sp,8
81116368:	f800283a 	ret

8111636c <vSwapMemmory>:

/* Swap memory reference */
void vSwapMemmory(TSimucam_MEB *pxMebCLocal) {
8111636c:	defffe04 	addi	sp,sp,-8
81116370:	de00012e 	bgeu	sp,et,81116378 <vSwapMemmory+0xc>
81116374:	003b68fa 	trap	3
81116378:	df000115 	stw	fp,4(sp)
8111637c:	df000104 	addi	fp,sp,4
81116380:	e13fff15 	stw	r4,-4(fp)

	pxMebCLocal->ucActualDDR = (pxMebCLocal->ucActualDDR + 1) % 2 ;
81116384:	e0bfff17 	ldw	r2,-4(fp)
81116388:	10800203 	ldbu	r2,8(r2)
8111638c:	10803fcc 	andi	r2,r2,255
81116390:	10c00044 	addi	r3,r2,1
81116394:	00a00034 	movhi	r2,32768
81116398:	10800044 	addi	r2,r2,1
8111639c:	1884703a 	and	r2,r3,r2
811163a0:	1000040e 	bge	r2,zero,811163b4 <vSwapMemmory+0x48>
811163a4:	10bfffc4 	addi	r2,r2,-1
811163a8:	00ffff84 	movi	r3,-2
811163ac:	10c4b03a 	or	r2,r2,r3
811163b0:	10800044 	addi	r2,r2,1
811163b4:	1007883a 	mov	r3,r2
811163b8:	e0bfff17 	ldw	r2,-4(fp)
811163bc:	10c00205 	stb	r3,8(r2)
	pxMebCLocal->ucNextDDR = (pxMebCLocal->ucNextDDR + 1) % 2 ;
811163c0:	e0bfff17 	ldw	r2,-4(fp)
811163c4:	10800243 	ldbu	r2,9(r2)
811163c8:	10803fcc 	andi	r2,r2,255
811163cc:	10c00044 	addi	r3,r2,1
811163d0:	00a00034 	movhi	r2,32768
811163d4:	10800044 	addi	r2,r2,1
811163d8:	1884703a 	and	r2,r3,r2
811163dc:	1000040e 	bge	r2,zero,811163f0 <vSwapMemmory+0x84>
811163e0:	10bfffc4 	addi	r2,r2,-1
811163e4:	00ffff84 	movi	r3,-2
811163e8:	10c4b03a 	or	r2,r2,r3
811163ec:	10800044 	addi	r2,r2,1
811163f0:	1007883a 	mov	r3,r2
811163f4:	e0bfff17 	ldw	r2,-4(fp)
811163f8:	10c00245 	stb	r3,9(r2)

}
811163fc:	0001883a 	nop
81116400:	e037883a 	mov	sp,fp
81116404:	df000017 	ldw	fp,0(sp)
81116408:	dec00104 	addi	sp,sp,4
8111640c:	f800283a 	ret

81116410 <vReleaseSyncMessages>:

/* After stop the Sync signal generation, maybe some FEE task could be locked waiting for this signal. So we send to everyone, and after that they will flush the queue */
void vReleaseSyncMessages(void) {
81116410:	defffc04 	addi	sp,sp,-16
81116414:	de00012e 	bgeu	sp,et,8111641c <vReleaseSyncMessages+0xc>
81116418:	003b68fa 	trap	3
8111641c:	dfc00315 	stw	ra,12(sp)
81116420:	df000215 	stw	fp,8(sp)
81116424:	df000204 	addi	fp,sp,8
	unsigned char ucIL;
	unsigned char error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ulWord = 0;
81116428:	e03fff15 	stw	zero,-4(fp)
	uiCmdtoSend.ucByte[2] = M_SYNC;
8111642c:	00bff844 	movi	r2,-31
81116430:	e0bfff85 	stb	r2,-2(fp)
	/* MasterSync? */

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
81116434:	e03ffe05 	stb	zero,-8(fp)
81116438:	00001606 	br	81116494 <vReleaseSyncMessages+0x84>
		uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucIL;
8111643c:	e0bffe03 	ldbu	r2,-8(fp)
81116440:	10800444 	addi	r2,r2,17
81116444:	e0bfffc5 	stb	r2,-1(fp)
		error_codel = OSQPost(xWaitSyncQFee[ ucIL ], (void *)uiCmdtoSend.ulWord);
81116448:	e0bffe03 	ldbu	r2,-8(fp)
8111644c:	1085883a 	add	r2,r2,r2
81116450:	1087883a 	add	r3,r2,r2
81116454:	d0a05c04 	addi	r2,gp,-32400
81116458:	1885883a 	add	r2,r3,r2
8111645c:	10800017 	ldw	r2,0(r2)
81116460:	e0ffff17 	ldw	r3,-4(fp)
81116464:	180b883a 	mov	r5,r3
81116468:	1009883a 	mov	r4,r2
8111646c:	113e0280 	call	8113e028 <OSQPost>
81116470:	e0bffe45 	stb	r2,-7(fp)
		if ( error_codel != OS_ERR_NONE ) {
81116474:	e0bffe43 	ldbu	r2,-7(fp)
81116478:	10000326 	beq	r2,zero,81116488 <vReleaseSyncMessages+0x78>
			vFailSendMsgSync( ucIL );
8111647c:	e0bffe03 	ldbu	r2,-8(fp)
81116480:	1009883a 	mov	r4,r2
81116484:	111d5000 	call	8111d500 <vFailSendMsgSync>

	uiCmdtoSend.ulWord = 0;
	uiCmdtoSend.ucByte[2] = M_SYNC;
	/* MasterSync? */

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
81116488:	e0bffe03 	ldbu	r2,-8(fp)
8111648c:	10800044 	addi	r2,r2,1
81116490:	e0bffe05 	stb	r2,-8(fp)
81116494:	e0bffe03 	ldbu	r2,-8(fp)
81116498:	103fe826 	beq	r2,zero,8111643c <__reset+0xfb0f643c>
		error_codel = OSQPost(xWaitSyncQFee[ ucIL ], (void *)uiCmdtoSend.ulWord);
		if ( error_codel != OS_ERR_NONE ) {
			vFailSendMsgSync( ucIL );
		}
	}
}
8111649c:	0001883a 	nop
811164a0:	e037883a 	mov	sp,fp
811164a4:	dfc00117 	ldw	ra,4(sp)
811164a8:	df000017 	ldw	fp,0(sp)
811164ac:	dec00204 	addi	sp,sp,8
811164b0:	f800283a 	ret

811164b4 <vStackMonitor>:
    }
}

#else
#ifdef DEBUG_ON
void vStackMonitor(void *task_data) {
811164b4:	defff804 	addi	sp,sp,-32
811164b8:	de00012e 	bgeu	sp,et,811164c0 <vStackMonitor+0xc>
811164bc:	003b68fa 	trap	3
811164c0:	dfc00715 	stw	ra,28(sp)
811164c4:	df000615 	stw	fp,24(sp)
811164c8:	df000604 	addi	fp,sp,24
811164cc:	e13fff15 	stw	r4,-4(fp)
	INT8U ucErrorCode = 0;
811164d0:	e03ffc05 	stb	zero,-16(fp)
	OS_STK_DATA data;


        debug(fp,"vStackMonitor, enter task.\n");
811164d4:	d0a06217 	ldw	r2,-32376(gp)
811164d8:	100f883a 	mov	r7,r2
811164dc:	018006c4 	movi	r6,27
811164e0:	01400044 	movi	r5,1
811164e4:	01204574 	movhi	r4,33045
811164e8:	21393f04 	addi	r4,r4,-6916
811164ec:	1121c7c0 	call	81121c7c <fwrite>


    for (;;) {

    	fprintf(fp, "=========== STACK MONITOR =================\n" );
811164f0:	d0a06217 	ldw	r2,-32376(gp)
811164f4:	100f883a 	mov	r7,r2
811164f8:	01800b04 	movi	r6,44
811164fc:	01400044 	movi	r5,1
81116500:	01204574 	movhi	r4,33045
81116504:	21394604 	addi	r4,r4,-6888
81116508:	1121c7c0 	call	81121c7c <fwrite>
    	fprintf(fp, " Task           Total               Free             In use  \n" );
8111650c:	d0a06217 	ldw	r2,-32376(gp)
81116510:	100f883a 	mov	r7,r2
81116514:	01800f84 	movi	r6,62
81116518:	01400044 	movi	r5,1
8111651c:	01204574 	movhi	r4,33045
81116520:	21395204 	addi	r4,r4,-6840
81116524:	1121c7c0 	call	81121c7c <fwrite>

    	ucErrorCode = OSTaskStkChk( RECEIVER_TASK_PRIO , &data);
81116528:	e0bffd04 	addi	r2,fp,-12
8111652c:	100b883a 	mov	r5,r2
81116530:	01000804 	movi	r4,32
81116534:	114044c0 	call	8114044c <OSTaskStkChk>
81116538:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE ) {
8111653c:	e0bffc03 	ldbu	r2,-16(fp)
81116540:	10000f1e 	bne	r2,zero,81116580 <vStackMonitor+0xcc>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116544:	d1206217 	ldw	r4,-32376(gp)
    				"RECEIVER_TASK",
    				data.OSFree + data.OSUsed,
81116548:	e0fffd17 	ldw	r3,-12(fp)
8111654c:	e0bffe17 	ldw	r2,-8(fp)
    	fprintf(fp, " Task           Total               Free             In use  \n" );

    	ucErrorCode = OSTaskStkChk( RECEIVER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116550:	188b883a 	add	r5,r3,r2
81116554:	e0bffd17 	ldw	r2,-12(fp)
81116558:	e0fffe17 	ldw	r3,-8(fp)
8111655c:	d8c00115 	stw	r3,4(sp)
81116560:	d8800015 	stw	r2,0(sp)
81116564:	280f883a 	mov	r7,r5
81116568:	01a04574 	movhi	r6,33045
8111656c:	31b96204 	addi	r6,r6,-6776
81116570:	01604574 	movhi	r5,33045
81116574:	29796604 	addi	r5,r5,-6760
81116578:	11215e00 	call	811215e0 <fprintf>
8111657c:	00000706 	br	8111659c <vStackMonitor+0xe8>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get RECEIVER_TASK stack \n" );
81116580:	d0a06217 	ldw	r2,-32376(gp)
81116584:	100f883a 	mov	r7,r2
81116588:	01800904 	movi	r6,36
8111658c:	01400044 	movi	r5,1
81116590:	01204574 	movhi	r4,33045
81116594:	21397504 	addi	r4,r4,-6700
81116598:	1121c7c0 	call	81121c7c <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( TIMEOUT_CHECKER_PRIO , &data);
8111659c:	e0bffd04 	addi	r2,fp,-12
811165a0:	100b883a 	mov	r5,r2
811165a4:	01000784 	movi	r4,30
811165a8:	114044c0 	call	8114044c <OSTaskStkChk>
811165ac:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811165b0:	e0bffc03 	ldbu	r2,-16(fp)
811165b4:	10000f1e 	bne	r2,zero,811165f4 <vStackMonitor+0x140>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811165b8:	d1206217 	ldw	r4,-32376(gp)
    				"TIMEOUT_CHECKER",
    				data.OSFree + data.OSUsed,
811165bc:	e0fffd17 	ldw	r3,-12(fp)
811165c0:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( TIMEOUT_CHECKER_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811165c4:	188b883a 	add	r5,r3,r2
811165c8:	e0bffd17 	ldw	r2,-12(fp)
811165cc:	e0fffe17 	ldw	r3,-8(fp)
811165d0:	d8c00115 	stw	r3,4(sp)
811165d4:	d8800015 	stw	r2,0(sp)
811165d8:	280f883a 	mov	r7,r5
811165dc:	01a04574 	movhi	r6,33045
811165e0:	31b97f04 	addi	r6,r6,-6660
811165e4:	01604574 	movhi	r5,33045
811165e8:	29796604 	addi	r5,r5,-6760
811165ec:	11215e00 	call	811215e0 <fprintf>
811165f0:	00000706 	br	81116610 <vStackMonitor+0x15c>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get TIMEOUT_CHECKER stack \n" );
811165f4:	d0a06217 	ldw	r2,-32376(gp)
811165f8:	100f883a 	mov	r7,r2
811165fc:	01800984 	movi	r6,38
81116600:	01400044 	movi	r5,1
81116604:	01204574 	movhi	r4,33045
81116608:	21398304 	addi	r4,r4,-6644
8111660c:	1121c7c0 	call	81121c7c <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( PARSER_TASK_PRIO , &data);
81116610:	e0bffd04 	addi	r2,fp,-12
81116614:	100b883a 	mov	r5,r2
81116618:	01000704 	movi	r4,28
8111661c:	114044c0 	call	8114044c <OSTaskStkChk>
81116620:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81116624:	e0bffc03 	ldbu	r2,-16(fp)
81116628:	10000f1e 	bne	r2,zero,81116668 <vStackMonitor+0x1b4>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111662c:	d1206217 	ldw	r4,-32376(gp)
    				"PARSER_TASK",
    				data.OSFree + data.OSUsed,
81116630:	e0fffd17 	ldw	r3,-12(fp)
81116634:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( PARSER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116638:	188b883a 	add	r5,r3,r2
8111663c:	e0bffd17 	ldw	r2,-12(fp)
81116640:	e0fffe17 	ldw	r3,-8(fp)
81116644:	d8c00115 	stw	r3,4(sp)
81116648:	d8800015 	stw	r2,0(sp)
8111664c:	280f883a 	mov	r7,r5
81116650:	01a04574 	movhi	r6,33045
81116654:	31b98d04 	addi	r6,r6,-6604
81116658:	01604574 	movhi	r5,33045
8111665c:	29796604 	addi	r5,r5,-6760
81116660:	11215e00 	call	811215e0 <fprintf>
81116664:	00000706 	br	81116684 <vStackMonitor+0x1d0>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get PARSER_TASK stack \n" );
81116668:	d0a06217 	ldw	r2,-32376(gp)
8111666c:	100f883a 	mov	r7,r2
81116670:	01800884 	movi	r6,34
81116674:	01400044 	movi	r5,1
81116678:	01204574 	movhi	r4,33045
8111667c:	21399004 	addi	r4,r4,-6592
81116680:	1121c7c0 	call	81121c7c <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( OUT_ACK_TASK_PRIO , &data);
81116684:	e0bffd04 	addi	r2,fp,-12
81116688:	100b883a 	mov	r5,r2
8111668c:	010006c4 	movi	r4,27
81116690:	114044c0 	call	8114044c <OSTaskStkChk>
81116694:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81116698:	e0bffc03 	ldbu	r2,-16(fp)
8111669c:	10000f1e 	bne	r2,zero,811166dc <vStackMonitor+0x228>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811166a0:	d1206217 	ldw	r4,-32376(gp)
    				"OUT_ACK_TASK",
    				data.OSFree + data.OSUsed,
811166a4:	e0fffd17 	ldw	r3,-12(fp)
811166a8:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( OUT_ACK_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811166ac:	188b883a 	add	r5,r3,r2
811166b0:	e0bffd17 	ldw	r2,-12(fp)
811166b4:	e0fffe17 	ldw	r3,-8(fp)
811166b8:	d8c00115 	stw	r3,4(sp)
811166bc:	d8800015 	stw	r2,0(sp)
811166c0:	280f883a 	mov	r7,r5
811166c4:	01a04574 	movhi	r6,33045
811166c8:	31b99904 	addi	r6,r6,-6556
811166cc:	01604574 	movhi	r5,33045
811166d0:	29796604 	addi	r5,r5,-6760
811166d4:	11215e00 	call	811215e0 <fprintf>
811166d8:	00000706 	br	811166f8 <vStackMonitor+0x244>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get OUT_ACK_TASK stack \n" );
811166dc:	d0a06217 	ldw	r2,-32376(gp)
811166e0:	100f883a 	mov	r7,r2
811166e4:	018008c4 	movi	r6,35
811166e8:	01400044 	movi	r5,1
811166ec:	01204574 	movhi	r4,33045
811166f0:	21399d04 	addi	r4,r4,-6540
811166f4:	1121c7c0 	call	81121c7c <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( SENDER_TASK_PRIO , &data);
811166f8:	e0bffd04 	addi	r2,fp,-12
811166fc:	100b883a 	mov	r5,r2
81116700:	01000684 	movi	r4,26
81116704:	114044c0 	call	8114044c <OSTaskStkChk>
81116708:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8111670c:	e0bffc03 	ldbu	r2,-16(fp)
81116710:	10000f1e 	bne	r2,zero,81116750 <vStackMonitor+0x29c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116714:	d1206217 	ldw	r4,-32376(gp)
    				"SENDER_TASK",
    				data.OSFree + data.OSUsed,
81116718:	e0fffd17 	ldw	r3,-12(fp)
8111671c:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( SENDER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116720:	188b883a 	add	r5,r3,r2
81116724:	e0bffd17 	ldw	r2,-12(fp)
81116728:	e0fffe17 	ldw	r3,-8(fp)
8111672c:	d8c00115 	stw	r3,4(sp)
81116730:	d8800015 	stw	r2,0(sp)
81116734:	280f883a 	mov	r7,r5
81116738:	01a04574 	movhi	r6,33045
8111673c:	31b9a604 	addi	r6,r6,-6504
81116740:	01604574 	movhi	r5,33045
81116744:	29796604 	addi	r5,r5,-6760
81116748:	11215e00 	call	811215e0 <fprintf>
8111674c:	00000706 	br	8111676c <vStackMonitor+0x2b8>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get SENDER_TASK stack \n" );
81116750:	d0a06217 	ldw	r2,-32376(gp)
81116754:	100f883a 	mov	r7,r2
81116758:	01800884 	movi	r6,34
8111675c:	01400044 	movi	r5,1
81116760:	01204574 	movhi	r4,33045
81116764:	2139a904 	addi	r4,r4,-6492
81116768:	1121c7c0 	call	81121c7c <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( IN_ACK_TASK_PRIO , &data);
8111676c:	e0bffd04 	addi	r2,fp,-12
81116770:	100b883a 	mov	r5,r2
81116774:	01000644 	movi	r4,25
81116778:	114044c0 	call	8114044c <OSTaskStkChk>
8111677c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81116780:	e0bffc03 	ldbu	r2,-16(fp)
81116784:	10000f1e 	bne	r2,zero,811167c4 <vStackMonitor+0x310>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116788:	d1206217 	ldw	r4,-32376(gp)
    				"IN_ACK_TASK",
    				data.OSFree + data.OSUsed,
8111678c:	e0fffd17 	ldw	r3,-12(fp)
81116790:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( IN_ACK_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116794:	188b883a 	add	r5,r3,r2
81116798:	e0bffd17 	ldw	r2,-12(fp)
8111679c:	e0fffe17 	ldw	r3,-8(fp)
811167a0:	d8c00115 	stw	r3,4(sp)
811167a4:	d8800015 	stw	r2,0(sp)
811167a8:	280f883a 	mov	r7,r5
811167ac:	01a04574 	movhi	r6,33045
811167b0:	31b9b204 	addi	r6,r6,-6456
811167b4:	01604574 	movhi	r5,33045
811167b8:	29796604 	addi	r5,r5,-6760
811167bc:	11215e00 	call	811215e0 <fprintf>
811167c0:	00000706 	br	811167e0 <vStackMonitor+0x32c>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get IN_ACK_TASK stack \n" );
811167c4:	d0a06217 	ldw	r2,-32376(gp)
811167c8:	100f883a 	mov	r7,r2
811167cc:	01800884 	movi	r6,34
811167d0:	01400044 	movi	r5,1
811167d4:	01204574 	movhi	r4,33045
811167d8:	2139b504 	addi	r4,r4,-6444
811167dc:	1121c7c0 	call	81121c7c <fwrite>
    	}

 
    	ucErrorCode = OSTaskStkChk( INITIALIZATION_TASK_PRIO , &data);
811167e0:	e0bffd04 	addi	r2,fp,-12
811167e4:	100b883a 	mov	r5,r2
811167e8:	01000044 	movi	r4,1
811167ec:	114044c0 	call	8114044c <OSTaskStkChk>
811167f0:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811167f4:	e0bffc03 	ldbu	r2,-16(fp)
811167f8:	10000f1e 	bne	r2,zero,81116838 <vStackMonitor+0x384>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811167fc:	d1206217 	ldw	r4,-32376(gp)
    				"INITI_TASK",
    				data.OSFree + data.OSUsed,
81116800:	e0fffd17 	ldw	r3,-12(fp)
81116804:	e0bffe17 	ldw	r2,-8(fp)

 
    	ucErrorCode = OSTaskStkChk( INITIALIZATION_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116808:	188b883a 	add	r5,r3,r2
8111680c:	e0bffd17 	ldw	r2,-12(fp)
81116810:	e0fffe17 	ldw	r3,-8(fp)
81116814:	d8c00115 	stw	r3,4(sp)
81116818:	d8800015 	stw	r2,0(sp)
8111681c:	280f883a 	mov	r7,r5
81116820:	01a04574 	movhi	r6,33045
81116824:	31b9be04 	addi	r6,r6,-6408
81116828:	01604574 	movhi	r5,33045
8111682c:	29796604 	addi	r5,r5,-6760
81116830:	11215e00 	call	811215e0 <fprintf>
81116834:	00000706 	br	81116854 <vStackMonitor+0x3a0>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get INIT_TASK stack \n" );
81116838:	d0a06217 	ldw	r2,-32376(gp)
8111683c:	100f883a 	mov	r7,r2
81116840:	01800804 	movi	r6,32
81116844:	01400044 	movi	r5,1
81116848:	01204574 	movhi	r4,33045
8111684c:	2139c104 	addi	r4,r4,-6396
81116850:	1121c7c0 	call	81121c7c <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO , &data);
81116854:	e0bffd04 	addi	r2,fp,-12
81116858:	100b883a 	mov	r5,r2
8111685c:	010002c4 	movi	r4,11
81116860:	114044c0 	call	8114044c <OSTaskStkChk>
81116864:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81116868:	e0bffc03 	ldbu	r2,-16(fp)
8111686c:	10000f1e 	bne	r2,zero,811168ac <vStackMonitor+0x3f8>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116870:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-0",
    				data.OSFree + data.OSUsed,
81116874:	e0fffd17 	ldw	r3,-12(fp)
81116878:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111687c:	188b883a 	add	r5,r3,r2
81116880:	e0bffd17 	ldw	r2,-12(fp)
81116884:	e0fffe17 	ldw	r3,-8(fp)
81116888:	d8c00115 	stw	r3,4(sp)
8111688c:	d8800015 	stw	r2,0(sp)
81116890:	280f883a 	mov	r7,r5
81116894:	01a04574 	movhi	r6,33045
81116898:	31b9ca04 	addi	r6,r6,-6360
8111689c:	01604574 	movhi	r5,33045
811168a0:	29796604 	addi	r5,r5,-6760
811168a4:	11215e00 	call	811215e0 <fprintf>
811168a8:	00000706 	br	811168c8 <vStackMonitor+0x414>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 0 stack \n" );
811168ac:	d0a06217 	ldw	r2,-32376(gp)
811168b0:	100f883a 	mov	r7,r2
811168b4:	018008c4 	movi	r6,35
811168b8:	01400044 	movi	r5,1
811168bc:	01204574 	movhi	r4,33045
811168c0:	2139cd04 	addi	r4,r4,-6348
811168c4:	1121c7c0 	call	81121c7c <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+1 , &data);
811168c8:	e0bffd04 	addi	r2,fp,-12
811168cc:	100b883a 	mov	r5,r2
811168d0:	01000304 	movi	r4,12
811168d4:	114044c0 	call	8114044c <OSTaskStkChk>
811168d8:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811168dc:	e0bffc03 	ldbu	r2,-16(fp)
811168e0:	10000f1e 	bne	r2,zero,81116920 <vStackMonitor+0x46c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811168e4:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-1",
    				data.OSFree + data.OSUsed,
811168e8:	e0fffd17 	ldw	r3,-12(fp)
811168ec:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+1 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811168f0:	188b883a 	add	r5,r3,r2
811168f4:	e0bffd17 	ldw	r2,-12(fp)
811168f8:	e0fffe17 	ldw	r3,-8(fp)
811168fc:	d8c00115 	stw	r3,4(sp)
81116900:	d8800015 	stw	r2,0(sp)
81116904:	280f883a 	mov	r7,r5
81116908:	01a04574 	movhi	r6,33045
8111690c:	31b9d604 	addi	r6,r6,-6312
81116910:	01604574 	movhi	r5,33045
81116914:	29796604 	addi	r5,r5,-6760
81116918:	11215e00 	call	811215e0 <fprintf>
8111691c:	00000706 	br	8111693c <vStackMonitor+0x488>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 1 stack \n" );
81116920:	d0a06217 	ldw	r2,-32376(gp)
81116924:	100f883a 	mov	r7,r2
81116928:	018008c4 	movi	r6,35
8111692c:	01400044 	movi	r5,1
81116930:	01204574 	movhi	r4,33045
81116934:	2139d904 	addi	r4,r4,-6300
81116938:	1121c7c0 	call	81121c7c <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+2 , &data);
8111693c:	e0bffd04 	addi	r2,fp,-12
81116940:	100b883a 	mov	r5,r2
81116944:	01000344 	movi	r4,13
81116948:	114044c0 	call	8114044c <OSTaskStkChk>
8111694c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81116950:	e0bffc03 	ldbu	r2,-16(fp)
81116954:	10000f1e 	bne	r2,zero,81116994 <vStackMonitor+0x4e0>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116958:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-2",
    				data.OSFree + data.OSUsed,
8111695c:	e0fffd17 	ldw	r3,-12(fp)
81116960:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+2 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116964:	188b883a 	add	r5,r3,r2
81116968:	e0bffd17 	ldw	r2,-12(fp)
8111696c:	e0fffe17 	ldw	r3,-8(fp)
81116970:	d8c00115 	stw	r3,4(sp)
81116974:	d8800015 	stw	r2,0(sp)
81116978:	280f883a 	mov	r7,r5
8111697c:	01a04574 	movhi	r6,33045
81116980:	31b9e204 	addi	r6,r6,-6264
81116984:	01604574 	movhi	r5,33045
81116988:	29796604 	addi	r5,r5,-6760
8111698c:	11215e00 	call	811215e0 <fprintf>
81116990:	00000706 	br	811169b0 <vStackMonitor+0x4fc>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 2 stack \n" );
81116994:	d0a06217 	ldw	r2,-32376(gp)
81116998:	100f883a 	mov	r7,r2
8111699c:	018008c4 	movi	r6,35
811169a0:	01400044 	movi	r5,1
811169a4:	01204574 	movhi	r4,33045
811169a8:	2139e504 	addi	r4,r4,-6252
811169ac:	1121c7c0 	call	81121c7c <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+3 , &data);
811169b0:	e0bffd04 	addi	r2,fp,-12
811169b4:	100b883a 	mov	r5,r2
811169b8:	01000384 	movi	r4,14
811169bc:	114044c0 	call	8114044c <OSTaskStkChk>
811169c0:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811169c4:	e0bffc03 	ldbu	r2,-16(fp)
811169c8:	10000f1e 	bne	r2,zero,81116a08 <vStackMonitor+0x554>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811169cc:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-3",
    				data.OSFree + data.OSUsed,
811169d0:	e0fffd17 	ldw	r3,-12(fp)
811169d4:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+3 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811169d8:	188b883a 	add	r5,r3,r2
811169dc:	e0bffd17 	ldw	r2,-12(fp)
811169e0:	e0fffe17 	ldw	r3,-8(fp)
811169e4:	d8c00115 	stw	r3,4(sp)
811169e8:	d8800015 	stw	r2,0(sp)
811169ec:	280f883a 	mov	r7,r5
811169f0:	01a04574 	movhi	r6,33045
811169f4:	31b9ee04 	addi	r6,r6,-6216
811169f8:	01604574 	movhi	r5,33045
811169fc:	29796604 	addi	r5,r5,-6760
81116a00:	11215e00 	call	811215e0 <fprintf>
81116a04:	00000706 	br	81116a24 <vStackMonitor+0x570>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 3 stack \n" );
81116a08:	d0a06217 	ldw	r2,-32376(gp)
81116a0c:	100f883a 	mov	r7,r2
81116a10:	018008c4 	movi	r6,35
81116a14:	01400044 	movi	r5,1
81116a18:	01204574 	movhi	r4,33045
81116a1c:	2139f104 	addi	r4,r4,-6204
81116a20:	1121c7c0 	call	81121c7c <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+4 , &data);
81116a24:	e0bffd04 	addi	r2,fp,-12
81116a28:	100b883a 	mov	r5,r2
81116a2c:	010003c4 	movi	r4,15
81116a30:	114044c0 	call	8114044c <OSTaskStkChk>
81116a34:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81116a38:	e0bffc03 	ldbu	r2,-16(fp)
81116a3c:	10000f1e 	bne	r2,zero,81116a7c <vStackMonitor+0x5c8>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116a40:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-4",
    				data.OSFree + data.OSUsed,
81116a44:	e0fffd17 	ldw	r3,-12(fp)
81116a48:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+4 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116a4c:	188b883a 	add	r5,r3,r2
81116a50:	e0bffd17 	ldw	r2,-12(fp)
81116a54:	e0fffe17 	ldw	r3,-8(fp)
81116a58:	d8c00115 	stw	r3,4(sp)
81116a5c:	d8800015 	stw	r2,0(sp)
81116a60:	280f883a 	mov	r7,r5
81116a64:	01a04574 	movhi	r6,33045
81116a68:	31b9fa04 	addi	r6,r6,-6168
81116a6c:	01604574 	movhi	r5,33045
81116a70:	29796604 	addi	r5,r5,-6760
81116a74:	11215e00 	call	811215e0 <fprintf>
81116a78:	00000706 	br	81116a98 <vStackMonitor+0x5e4>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 4 stack \n" );
81116a7c:	d0a06217 	ldw	r2,-32376(gp)
81116a80:	100f883a 	mov	r7,r2
81116a84:	018008c4 	movi	r6,35
81116a88:	01400044 	movi	r5,1
81116a8c:	01204574 	movhi	r4,33045
81116a90:	2139fd04 	addi	r4,r4,-6156
81116a94:	1121c7c0 	call	81121c7c <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+5 , &data);
81116a98:	e0bffd04 	addi	r2,fp,-12
81116a9c:	100b883a 	mov	r5,r2
81116aa0:	01000404 	movi	r4,16
81116aa4:	114044c0 	call	8114044c <OSTaskStkChk>
81116aa8:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81116aac:	e0bffc03 	ldbu	r2,-16(fp)
81116ab0:	10000f1e 	bne	r2,zero,81116af0 <vStackMonitor+0x63c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116ab4:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-5",
    				data.OSFree + data.OSUsed,
81116ab8:	e0fffd17 	ldw	r3,-12(fp)
81116abc:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+5 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116ac0:	188b883a 	add	r5,r3,r2
81116ac4:	e0bffd17 	ldw	r2,-12(fp)
81116ac8:	e0fffe17 	ldw	r3,-8(fp)
81116acc:	d8c00115 	stw	r3,4(sp)
81116ad0:	d8800015 	stw	r2,0(sp)
81116ad4:	280f883a 	mov	r7,r5
81116ad8:	01a04574 	movhi	r6,33045
81116adc:	31ba0604 	addi	r6,r6,-6120
81116ae0:	01604574 	movhi	r5,33045
81116ae4:	29796604 	addi	r5,r5,-6760
81116ae8:	11215e00 	call	811215e0 <fprintf>
81116aec:	00000706 	br	81116b0c <vStackMonitor+0x658>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 5 stack \n" );
81116af0:	d0a06217 	ldw	r2,-32376(gp)
81116af4:	100f883a 	mov	r7,r2
81116af8:	018008c4 	movi	r6,35
81116afc:	01400044 	movi	r5,1
81116b00:	01204574 	movhi	r4,33045
81116b04:	213a0904 	addi	r4,r4,-6108
81116b08:	1121c7c0 	call	81121c7c <fwrite>
    	}

    	ucErrorCode = OSTaskStkChk( DATA_COTROL_TASK_PRIO , &data);
81116b0c:	e0bffd04 	addi	r2,fp,-12
81116b10:	100b883a 	mov	r5,r2
81116b14:	01000284 	movi	r4,10
81116b18:	114044c0 	call	8114044c <OSTaskStkChk>
81116b1c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81116b20:	e0bffc03 	ldbu	r2,-16(fp)
81116b24:	10000f1e 	bne	r2,zero,81116b64 <vStackMonitor+0x6b0>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116b28:	d1206217 	ldw	r4,-32376(gp)
    				"DATA_COTROL",
    				data.OSFree + data.OSUsed,
81116b2c:	e0fffd17 	ldw	r3,-12(fp)
81116b30:	e0bffe17 	ldw	r2,-8(fp)
    	}

    	ucErrorCode = OSTaskStkChk( DATA_COTROL_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116b34:	188b883a 	add	r5,r3,r2
81116b38:	e0bffd17 	ldw	r2,-12(fp)
81116b3c:	e0fffe17 	ldw	r3,-8(fp)
81116b40:	d8c00115 	stw	r3,4(sp)
81116b44:	d8800015 	stw	r2,0(sp)
81116b48:	280f883a 	mov	r7,r5
81116b4c:	01a04574 	movhi	r6,33045
81116b50:	31ba1204 	addi	r6,r6,-6072
81116b54:	01604574 	movhi	r5,33045
81116b58:	29796604 	addi	r5,r5,-6760
81116b5c:	11215e00 	call	811215e0 <fprintf>
81116b60:	00000706 	br	81116b80 <vStackMonitor+0x6cc>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get DATA_COTROL stack \n" );
81116b64:	d0a06217 	ldw	r2,-32376(gp)
81116b68:	100f883a 	mov	r7,r2
81116b6c:	01800884 	movi	r6,34
81116b70:	01400044 	movi	r5,1
81116b74:	01204574 	movhi	r4,33045
81116b78:	213a1504 	addi	r4,r4,-6060
81116b7c:	1121c7c0 	call	81121c7c <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( FEE_COTROL_TASK_PRIO , &data);
81116b80:	e0bffd04 	addi	r2,fp,-12
81116b84:	100b883a 	mov	r5,r2
81116b88:	01000244 	movi	r4,9
81116b8c:	114044c0 	call	8114044c <OSTaskStkChk>
81116b90:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81116b94:	e0bffc03 	ldbu	r2,-16(fp)
81116b98:	10000f1e 	bne	r2,zero,81116bd8 <vStackMonitor+0x724>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116b9c:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_COTROL",
    				data.OSFree + data.OSUsed,
81116ba0:	e0fffd17 	ldw	r3,-12(fp)
81116ba4:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( FEE_COTROL_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116ba8:	188b883a 	add	r5,r3,r2
81116bac:	e0bffd17 	ldw	r2,-12(fp)
81116bb0:	e0fffe17 	ldw	r3,-8(fp)
81116bb4:	d8c00115 	stw	r3,4(sp)
81116bb8:	d8800015 	stw	r2,0(sp)
81116bbc:	280f883a 	mov	r7,r5
81116bc0:	01a04574 	movhi	r6,33045
81116bc4:	31ba1e04 	addi	r6,r6,-6024
81116bc8:	01604574 	movhi	r5,33045
81116bcc:	29796604 	addi	r5,r5,-6760
81116bd0:	11215e00 	call	811215e0 <fprintf>
81116bd4:	00000706 	br	81116bf4 <vStackMonitor+0x740>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_COTROL stack \n" );
81116bd8:	d0a06217 	ldw	r2,-32376(gp)
81116bdc:	100f883a 	mov	r7,r2
81116be0:	01800844 	movi	r6,33
81116be4:	01400044 	movi	r5,1
81116be8:	01204574 	movhi	r4,33045
81116bec:	213a2104 	addi	r4,r4,-6012
81116bf0:	1121c7c0 	call	81121c7c <fwrite>
    	}

    	ucErrorCode = OSTaskStkChk( MEB_TASK_PRIO , &data);
81116bf4:	e0bffd04 	addi	r2,fp,-12
81116bf8:	100b883a 	mov	r5,r2
81116bfc:	01000204 	movi	r4,8
81116c00:	114044c0 	call	8114044c <OSTaskStkChk>
81116c04:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81116c08:	e0bffc03 	ldbu	r2,-16(fp)
81116c0c:	10000f1e 	bne	r2,zero,81116c4c <vStackMonitor+0x798>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116c10:	d1206217 	ldw	r4,-32376(gp)
    				"MEB_TASK",
    				data.OSFree + data.OSUsed,
81116c14:	e0fffd17 	ldw	r3,-12(fp)
81116c18:	e0bffe17 	ldw	r2,-8(fp)
    	}

    	ucErrorCode = OSTaskStkChk( MEB_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116c1c:	188b883a 	add	r5,r3,r2
81116c20:	e0bffd17 	ldw	r2,-12(fp)
81116c24:	e0fffe17 	ldw	r3,-8(fp)
81116c28:	d8c00115 	stw	r3,4(sp)
81116c2c:	d8800015 	stw	r2,0(sp)
81116c30:	280f883a 	mov	r7,r5
81116c34:	01a04574 	movhi	r6,33045
81116c38:	31ba2a04 	addi	r6,r6,-5976
81116c3c:	01604574 	movhi	r5,33045
81116c40:	29796604 	addi	r5,r5,-6760
81116c44:	11215e00 	call	811215e0 <fprintf>
81116c48:	00000706 	br	81116c68 <vStackMonitor+0x7b4>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get MEB_TASK stack \n" );
81116c4c:	d0a06217 	ldw	r2,-32376(gp)
81116c50:	100f883a 	mov	r7,r2
81116c54:	018007c4 	movi	r6,31
81116c58:	01400044 	movi	r5,1
81116c5c:	01204574 	movhi	r4,33045
81116c60:	213a2d04 	addi	r4,r4,-5964
81116c64:	1121c7c0 	call	81121c7c <fwrite>
    	}		


    	fprintf(fp, "\n" );
81116c68:	d0a06217 	ldw	r2,-32376(gp)
81116c6c:	100b883a 	mov	r5,r2
81116c70:	01000284 	movi	r4,10
81116c74:	11216580 	call	81121658 <fputc>

    	OSTimeDlyHMSM(0, 0, 10, 0);
81116c78:	000f883a 	mov	r7,zero
81116c7c:	01800284 	movi	r6,10
81116c80:	000b883a 	mov	r5,zero
81116c84:	0009883a 	mov	r4,zero
81116c88:	1140ab00 	call	81140ab0 <OSTimeDlyHMSM>
    }
81116c8c:	003e1806 	br	811164f0 <__reset+0xfb0f64f0>

81116c90 <vTimeoutCheckerTaskv2>:

#include "timeout_checker_ack_task.h"



void vTimeoutCheckerTaskv2(void *task_data) {
81116c90:	defffc04 	addi	sp,sp,-16
81116c94:	de00012e 	bgeu	sp,et,81116c9c <vTimeoutCheckerTaskv2+0xc>
81116c98:	003b68fa 	trap	3
81116c9c:	dfc00315 	stw	ra,12(sp)
81116ca0:	df000215 	stw	fp,8(sp)
81116ca4:	df000204 	addi	fp,sp,8
81116ca8:	e13fff15 	stw	r4,-4(fp)
	INT8U ucErrorCode = 0;
81116cac:	e03ffe05 	stb	zero,-8(fp)

    #ifdef DEBUG_ON
        debug(fp,"vTimeoutCheckerTask, enter task.\n");
81116cb0:	d0a06217 	ldw	r2,-32376(gp)
81116cb4:	100f883a 	mov	r7,r2
81116cb8:	01800844 	movi	r6,33
81116cbc:	01400044 	movi	r5,1
81116cc0:	01204574 	movhi	r4,33045
81116cc4:	213a3504 	addi	r4,r4,-5932
81116cc8:	1121c7c0 	call	81121c7c <fwrite>
    #endif   

    for (;;) {
        OSSemPend(xSemTimeoutChecker, 0, &ucErrorCode);
81116ccc:	d0a06717 	ldw	r2,-32356(gp)
81116cd0:	e1bffe04 	addi	r6,fp,-8
81116cd4:	000b883a 	mov	r5,zero
81116cd8:	1009883a 	mov	r4,r2
81116cdc:	113eb180 	call	8113eb18 <OSSemPend>
        if ( ucErrorCode == OS_NO_ERR ) {
81116ce0:	e0bffe03 	ldbu	r2,-8(fp)
81116ce4:	10803fcc 	andi	r2,r2,255
81116ce8:	1000021e 	bne	r2,zero,81116cf4 <vTimeoutCheckerTaskv2+0x64>
            /* Just check the restransmission buffer */
            vCheck();
81116cec:	1116cfc0 	call	81116cfc <vCheck>
81116cf0:	003ff606 	br	81116ccc <__reset+0xfb0f6ccc>
        } else {
            /* Should not get here, is a blocking semaphore for sync.*/
            vFailGetBlockingSemTimeoutTask();
81116cf4:	111c6c00 	call	8111c6c0 <vFailGetBlockingSemTimeoutTask>
        }
    }
81116cf8:	003ff406 	br	81116ccc <__reset+0xfb0f6ccc>

81116cfc <vCheck>:
}


void vCheck( void ) {
81116cfc:	defffd04 	addi	sp,sp,-12
81116d00:	de00012e 	bgeu	sp,et,81116d08 <vCheck+0xc>
81116d04:	003b68fa 	trap	3
81116d08:	dfc00215 	stw	ra,8(sp)
81116d0c:	df000115 	stw	fp,4(sp)
81116d10:	df000104 	addi	fp,sp,4
	INT8U ucErrorCode = 0;
81116d14:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucHashVerification = 0;
81116d18:	e03fff05 	stb	zero,-4(fp)

    ucHashVerification = 0;
81116d1c:	e03fff05 	stb	zero,-4(fp)
    ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);
81116d20:	d0a06883 	ldbu	r2,-32350(gp)
81116d24:	10803fcc 	andi	r2,r2,255
81116d28:	10800218 	cmpnei	r2,r2,8
81116d2c:	1000021e 	bne	r2,zero,81116d38 <vCheck+0x3c>
81116d30:	00c00104 	movi	r3,4
81116d34:	00000106 	br	81116d3c <vCheck+0x40>
81116d38:	0007883a 	mov	r3,zero
81116d3c:	d0a07503 	ldbu	r2,-32300(gp)
81116d40:	10803fcc 	andi	r2,r2,255
81116d44:	10800218 	cmpnei	r2,r2,8
81116d48:	1000021e 	bne	r2,zero,81116d54 <vCheck+0x58>
81116d4c:	00800084 	movi	r2,2
81116d50:	00000106 	br	81116d58 <vCheck+0x5c>
81116d54:	0005883a 	mov	r2,zero
81116d58:	1884b03a 	or	r2,r3,r2
81116d5c:	1007883a 	mov	r3,r2
81116d60:	d0a07543 	ldbu	r2,-32299(gp)
81116d64:	10803fcc 	andi	r2,r2,255
81116d68:	108001a0 	cmpeqi	r2,r2,6
81116d6c:	1884b03a 	or	r2,r3,r2
81116d70:	1007883a 	mov	r3,r2
81116d74:	e0bfff03 	ldbu	r2,-4(fp)
81116d78:	1884b03a 	or	r2,r3,r2
81116d7c:	e0bfff05 	stb	r2,-4(fp)

    /* Nothing in the (re)transmission buffer */
    if ( ucHashVerification == 0b00000111 )
81116d80:	e0bfff03 	ldbu	r2,-4(fp)
81116d84:	108001d8 	cmpnei	r2,r2,7
81116d88:	10003726 	beq	r2,zero,81116e68 <vCheck+0x16c>
        return;

    /* Try to get the Mutex of the UART */
	OSMutexPend(xTxUARTMutex, 0, &ucErrorCode); /* Blocking */
81116d8c:	d0a07417 	ldw	r2,-32304(gp)
81116d90:	e0ffff44 	addi	r3,fp,-3
81116d94:	180d883a 	mov	r6,r3
81116d98:	000b883a 	mov	r5,zero
81116d9c:	1009883a 	mov	r4,r2
81116da0:	113cb0c0 	call	8113cb0c <OSMutexPend>
    if ( ucErrorCode != OS_NO_ERR ) {
81116da4:	e0bfff43 	ldbu	r2,-3(fp)
81116da8:	10803fcc 	andi	r2,r2,255
81116dac:	10000826 	beq	r2,zero,81116dd0 <vCheck+0xd4>
        /* Should never get here, is a blocking operation */
		#ifdef DEBUG_ON
			debug(fp,"Should never get here. Trying to get xTxUARTMutex. (vCheck)\n");
81116db0:	d0a06217 	ldw	r2,-32376(gp)
81116db4:	100f883a 	mov	r7,r2
81116db8:	01800f04 	movi	r6,60
81116dbc:	01400044 	movi	r5,1
81116dc0:	01204574 	movhi	r4,33045
81116dc4:	213a3e04 	addi	r4,r4,-5896
81116dc8:	1121c7c0 	call	81121c7c <fwrite>
		#endif
        return;
81116dcc:	00002706 	br	81116e6c <vCheck+0x170>

    /* ---> At this point we have the Mutex of TX UART, let's try to get the mutex of all retransmission buffer. */


    /* There are any spot used in the xBuffer128? */
    if ( 0b00000001 != (0b00000001 & ucHashVerification ) )
81116dd0:	e0bfff03 	ldbu	r2,-4(fp)
81116dd4:	1080004c 	andi	r2,r2,1
81116dd8:	10803fcc 	andi	r2,r2,255
81116ddc:	1000021e 	bne	r2,zero,81116de8 <vCheck+0xec>
        vCheckRetransmission128();
81116de0:	1116e800 	call	81116e80 <vCheckRetransmission128>
81116de4:	00000506 	br	81116dfc <vCheck+0x100>
    else
    	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128)); /* For consistency with SemCount128 */
81116de8:	01800604 	movi	r6,24
81116dec:	000b883a 	mov	r5,zero
81116df0:	012045b4 	movhi	r4,33046
81116df4:	213c1e04 	addi	r4,r4,-3976
81116df8:	11227e00 	call	811227e0 <memset>


        /* There are any spot used in the xBuffer64? */
    if ( 0b00000010 != (0b00000010 & ucHashVerification ) )
81116dfc:	e0bfff03 	ldbu	r2,-4(fp)
81116e00:	1080008c 	andi	r2,r2,2
81116e04:	10803fcc 	andi	r2,r2,255
81116e08:	1000021e 	bne	r2,zero,81116e14 <vCheck+0x118>
        vCheckRetransmission64();
81116e0c:	11171040 	call	81117104 <vCheckRetransmission64>
81116e10:	00000506 	br	81116e28 <vCheck+0x12c>
    else
        memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64)); /* For consistency with SemCount64 */
81116e14:	01800804 	movi	r6,32
81116e18:	000b883a 	mov	r5,zero
81116e1c:	012045b4 	movhi	r4,33046
81116e20:	213c2404 	addi	r4,r4,-3952
81116e24:	11227e00 	call	811227e0 <memset>

    /* There are any spot used in the xBuffer32? */
    if ( 0b00000100 != (0b00000100 & ucHashVerification ) )
81116e28:	e0bfff03 	ldbu	r2,-4(fp)
81116e2c:	1080010c 	andi	r2,r2,4
81116e30:	10803fcc 	andi	r2,r2,255
81116e34:	1000021e 	bne	r2,zero,81116e40 <vCheck+0x144>
        vCheckRetransmission32();
81116e38:	11173900 	call	81117390 <vCheckRetransmission32>
81116e3c:	00000506 	br	81116e54 <vCheck+0x158>
    else
    	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32)); /* For consistency with SemCount32 */
81116e40:	01800804 	movi	r6,32
81116e44:	000b883a 	mov	r5,zero
81116e48:	012045b4 	movhi	r4,33046
81116e4c:	213c2c04 	addi	r4,r4,-3920
81116e50:	11227e00 	call	811227e0 <memset>


    OSMutexPost(xTxUARTMutex);
81116e54:	d0a07417 	ldw	r2,-32304(gp)
81116e58:	1009883a 	mov	r4,r2
81116e5c:	113d0b00 	call	8113d0b0 <OSMutexPost>

    return;
81116e60:	0001883a 	nop
81116e64:	00000106 	br	81116e6c <vCheck+0x170>
    ucHashVerification = 0;
    ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);

    /* Nothing in the (re)transmission buffer */
    if ( ucHashVerification == 0b00000111 )
        return;
81116e68:	0001883a 	nop


    OSMutexPost(xTxUARTMutex);

    return;
}
81116e6c:	e037883a 	mov	sp,fp
81116e70:	dfc00117 	ldw	ra,4(sp)
81116e74:	df000017 	ldw	fp,0(sp)
81116e78:	dec00204 	addi	sp,sp,8
81116e7c:	f800283a 	ret

81116e80 <vCheckRetransmission128>:

inline void vCheckRetransmission128( void ) {
81116e80:	defffd04 	addi	sp,sp,-12
81116e84:	de00012e 	bgeu	sp,et,81116e8c <vCheckRetransmission128+0xc>
81116e88:	003b68fa 	trap	3
81116e8c:	dfc00215 	stw	ra,8(sp)
81116e90:	df000115 	stw	fp,4(sp)
81116e94:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
81116e98:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucIL = 0;
81116e9c:	e03fff05 	stb	zero,-4(fp)

    OSMutexAccept(xMutexBuffer128, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
81116ea0:	d0a06e17 	ldw	r2,-32328(gp)
81116ea4:	e0ffff44 	addi	r3,fp,-3
81116ea8:	180b883a 	mov	r5,r3
81116eac:	1009883a 	mov	r4,r2
81116eb0:	113c48c0 	call	8113c48c <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
81116eb4:	e0bfff43 	ldbu	r2,-3(fp)
81116eb8:	10803fcc 	andi	r2,r2,255
81116ebc:	10008b1e 	bne	r2,zero,811170ec <vCheckRetransmission128+0x26c>
    

    /* ---> At this point we have access to the xBuffer128*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_128; ucIL++) {
81116ec0:	e03fff05 	stb	zero,-4(fp)
81116ec4:	00008106 	br	811170cc <vCheckRetransmission128+0x24c>
        /* Check if in use */
        if ( xInUseRetrans.b128[ucIL] == TRUE ) {
81116ec8:	e0ffff03 	ldbu	r3,-4(fp)
81116ecc:	00a045b4 	movhi	r2,33046
81116ed0:	10bc1e04 	addi	r2,r2,-3976
81116ed4:	18c7883a 	add	r3,r3,r3
81116ed8:	18c7883a 	add	r3,r3,r3
81116edc:	10c5883a 	add	r2,r2,r3
81116ee0:	10800017 	ldw	r2,0(r2)
81116ee4:	10800058 	cmpnei	r2,r2,1
81116ee8:	1000751e 	bne	r2,zero,811170c0 <vCheckRetransmission128+0x240>

            if ( xBuffer128[ucIL].bSent == TRUE )
81116eec:	e0ffff03 	ldbu	r3,-4(fp)
81116ef0:	00a045b4 	movhi	r2,33046
81116ef4:	10bc3c04 	addi	r2,r2,-3856
81116ef8:	18c02324 	muli	r3,r3,140
81116efc:	10c5883a 	add	r2,r2,r3
81116f00:	10802004 	addi	r2,r2,128
81116f04:	10800017 	ldw	r2,0(r2)
81116f08:	10800058 	cmpnei	r2,r2,1
81116f0c:	1000211e 	bne	r2,zero,81116f94 <vCheckRetransmission128+0x114>
                if ( ++xBuffer128[ucIL].usiTimeOut > TIMEOUT_COUNT )
81116f10:	e0ffff03 	ldbu	r3,-4(fp)
81116f14:	00a045b4 	movhi	r2,33046
81116f18:	10bc3c04 	addi	r2,r2,-3856
81116f1c:	19002324 	muli	r4,r3,140
81116f20:	1105883a 	add	r2,r2,r4
81116f24:	10802184 	addi	r2,r2,134
81116f28:	1080000b 	ldhu	r2,0(r2)
81116f2c:	10800044 	addi	r2,r2,1
81116f30:	100b883a 	mov	r5,r2
81116f34:	00a045b4 	movhi	r2,33046
81116f38:	10bc3c04 	addi	r2,r2,-3856
81116f3c:	19002324 	muli	r4,r3,140
81116f40:	1105883a 	add	r2,r2,r4
81116f44:	10802184 	addi	r2,r2,134
81116f48:	1140000d 	sth	r5,0(r2)
81116f4c:	00a045b4 	movhi	r2,33046
81116f50:	10bc3c04 	addi	r2,r2,-3856
81116f54:	18c02324 	muli	r3,r3,140
81116f58:	10c5883a 	add	r2,r2,r3
81116f5c:	10802184 	addi	r2,r2,134
81116f60:	1080000b 	ldhu	r2,0(r2)
81116f64:	10bfffcc 	andi	r2,r2,65535
81116f68:	10a0001c 	xori	r2,r2,32768
81116f6c:	10a00004 	addi	r2,r2,-32768
81116f70:	10800090 	cmplti	r2,r2,2
81116f74:	1000071e 	bne	r2,zero,81116f94 <vCheckRetransmission128+0x114>
                    xBuffer128[ucIL].bSent = FALSE;
81116f78:	e0ffff03 	ldbu	r3,-4(fp)
81116f7c:	00a045b4 	movhi	r2,33046
81116f80:	10bc3c04 	addi	r2,r2,-3856
81116f84:	18c02324 	muli	r3,r3,140
81116f88:	10c5883a 	add	r2,r2,r3
81116f8c:	10802004 	addi	r2,r2,128
81116f90:	10000015 	stw	zero,0(r2)

            if ( xBuffer128[ucIL].bSent == FALSE ) {
81116f94:	e0ffff03 	ldbu	r3,-4(fp)
81116f98:	00a045b4 	movhi	r2,33046
81116f9c:	10bc3c04 	addi	r2,r2,-3856
81116fa0:	18c02324 	muli	r3,r3,140
81116fa4:	10c5883a 	add	r2,r2,r3
81116fa8:	10802004 	addi	r2,r2,128
81116fac:	10800017 	ldw	r2,0(r2)
81116fb0:	1000431e 	bne	r2,zero,811170c0 <vCheckRetransmission128+0x240>
                puts(xBuffer128[ucIL].buffer);
81116fb4:	e0bfff03 	ldbu	r2,-4(fp)
81116fb8:	10c02324 	muli	r3,r2,140
81116fbc:	00a045b4 	movhi	r2,33046
81116fc0:	10bc3c04 	addi	r2,r2,-3856
81116fc4:	1885883a 	add	r2,r3,r2
81116fc8:	1009883a 	mov	r4,r2
81116fcc:	1122c2c0 	call	81122c2c <puts>
                xBuffer128[ucIL].bSent = TRUE;
81116fd0:	e0ffff03 	ldbu	r3,-4(fp)
81116fd4:	00a045b4 	movhi	r2,33046
81116fd8:	10bc3c04 	addi	r2,r2,-3856
81116fdc:	18c02324 	muli	r3,r3,140
81116fe0:	10c5883a 	add	r2,r2,r3
81116fe4:	10802004 	addi	r2,r2,128
81116fe8:	00c00044 	movi	r3,1
81116fec:	10c00015 	stw	r3,0(r2)
                xBuffer128[ucIL].usiTimeOut = 0;
81116ff0:	e0ffff03 	ldbu	r3,-4(fp)
81116ff4:	00a045b4 	movhi	r2,33046
81116ff8:	10bc3c04 	addi	r2,r2,-3856
81116ffc:	18c02324 	muli	r3,r3,140
81117000:	10c5883a 	add	r2,r2,r3
81117004:	10802184 	addi	r2,r2,134
81117008:	1000000d 	sth	zero,0(r2)

                /* Check if already tried all the times */
                if ( ++xBuffer128[ucIL].ucNofRetries > N_RETRIES_COMM ) {
8111700c:	e0ffff03 	ldbu	r3,-4(fp)
81117010:	00a045b4 	movhi	r2,33046
81117014:	10bc3c04 	addi	r2,r2,-3856
81117018:	19002324 	muli	r4,r3,140
8111701c:	1105883a 	add	r2,r2,r4
81117020:	10802204 	addi	r2,r2,136
81117024:	10800003 	ldbu	r2,0(r2)
81117028:	10800044 	addi	r2,r2,1
8111702c:	100b883a 	mov	r5,r2
81117030:	00a045b4 	movhi	r2,33046
81117034:	10bc3c04 	addi	r2,r2,-3856
81117038:	19002324 	muli	r4,r3,140
8111703c:	1105883a 	add	r2,r2,r4
81117040:	10802204 	addi	r2,r2,136
81117044:	11400005 	stb	r5,0(r2)
81117048:	00a045b4 	movhi	r2,33046
8111704c:	10bc3c04 	addi	r2,r2,-3856
81117050:	18c02324 	muli	r3,r3,140
81117054:	10c5883a 	add	r2,r2,r3
81117058:	10802204 	addi	r2,r2,136
8111705c:	10800003 	ldbu	r2,0(r2)
81117060:	10803fcc 	andi	r2,r2,255
81117064:	108000b0 	cmpltui	r2,r2,2
81117068:	1000151e 	bne	r2,zero,811170c0 <vCheckRetransmission128+0x240>
                    /* Now it is a Free place */
                    xInUseRetrans.b128[ucIL] = FALSE;
8111706c:	e0ffff03 	ldbu	r3,-4(fp)
81117070:	00a045b4 	movhi	r2,33046
81117074:	10bc1e04 	addi	r2,r2,-3976
81117078:	18c7883a 	add	r3,r3,r3
8111707c:	18c7883a 	add	r3,r3,r3
81117080:	10c5883a 	add	r2,r2,r3
81117084:	10000015 	stw	zero,0(r2)
                    SemCount128++;
81117088:	d0a07543 	ldbu	r2,-32299(gp)
8111708c:	10800044 	addi	r2,r2,1
81117090:	d0a07545 	stb	r2,-32299(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer128);
81117094:	d0a06317 	ldw	r2,-32372(gp)
81117098:	1009883a 	mov	r4,r2
8111709c:	113eea00 	call	8113eea0 <OSSemPost>
811170a0:	e0bfff45 	stb	r2,-3(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
811170a4:	e0bfff43 	ldbu	r2,-3(fp)
811170a8:	10803fcc 	andi	r2,r2,255
811170ac:	10000426 	beq	r2,zero,811170c0 <vCheckRetransmission128+0x240>
                        SemCount128--;
811170b0:	d0a07543 	ldbu	r2,-32299(gp)
811170b4:	10bfffc4 	addi	r2,r2,-1
811170b8:	d0a07545 	stb	r2,-32299(gp)
                        vFailSetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
811170bc:	111bfb00 	call	8111bfb0 <vFailSetCountSemaphorexBuffer128>
    

    /* ---> At this point we have access to the xBuffer128*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_128; ucIL++) {
811170c0:	e0bfff03 	ldbu	r2,-4(fp)
811170c4:	10800044 	addi	r2,r2,1
811170c8:	e0bfff05 	stb	r2,-4(fp)
811170cc:	e0bfff03 	ldbu	r2,-4(fp)
811170d0:	108001b0 	cmpltui	r2,r2,6
811170d4:	103f7c1e 	bne	r2,zero,81116ec8 <__reset+0xfb0f6ec8>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer128);
811170d8:	d0a06e17 	ldw	r2,-32328(gp)
811170dc:	1009883a 	mov	r4,r2
811170e0:	113d0b00 	call	8113d0b0 <OSMutexPost>

    return;
811170e4:	0001883a 	nop
811170e8:	00000106 	br	811170f0 <vCheckRetransmission128+0x270>
    unsigned char ucIL = 0;

    OSMutexAccept(xMutexBuffer128, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
811170ec:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer128);

    return;
}
811170f0:	e037883a 	mov	sp,fp
811170f4:	dfc00117 	ldw	ra,4(sp)
811170f8:	df000017 	ldw	fp,0(sp)
811170fc:	dec00204 	addi	sp,sp,8
81117100:	f800283a 	ret

81117104 <vCheckRetransmission64>:

inline void vCheckRetransmission64( void ) {
81117104:	defffd04 	addi	sp,sp,-12
81117108:	de00012e 	bgeu	sp,et,81117110 <vCheckRetransmission64+0xc>
8111710c:	003b68fa 	trap	3
81117110:	dfc00215 	stw	ra,8(sp)
81117114:	df000115 	stw	fp,4(sp)
81117118:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
8111711c:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucIL = 0;
81117120:	e03fff05 	stb	zero,-4(fp)

    OSMutexAccept(xMutexBuffer64, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
81117124:	d0a07117 	ldw	r2,-32316(gp)
81117128:	e0ffff44 	addi	r3,fp,-3
8111712c:	180b883a 	mov	r5,r3
81117130:	1009883a 	mov	r4,r2
81117134:	113c48c0 	call	8113c48c <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
81117138:	e0bfff43 	ldbu	r2,-3(fp)
8111713c:	10803fcc 	andi	r2,r2,255
81117140:	10008d1e 	bne	r2,zero,81117378 <vCheckRetransmission64+0x274>
    

    /* ---> At this point we have access to the xBuffer64*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_64; ucIL++) {
81117144:	e03fff05 	stb	zero,-4(fp)
81117148:	00008306 	br	81117358 <vCheckRetransmission64+0x254>
        /* Check if in use */
        if ( xInUseRetrans.b64[ucIL] == TRUE ) {
8111714c:	e0ffff03 	ldbu	r3,-4(fp)
81117150:	00a045b4 	movhi	r2,33046
81117154:	10bc1e04 	addi	r2,r2,-3976
81117158:	18c00184 	addi	r3,r3,6
8111715c:	18c7883a 	add	r3,r3,r3
81117160:	18c7883a 	add	r3,r3,r3
81117164:	10c5883a 	add	r2,r2,r3
81117168:	10800017 	ldw	r2,0(r2)
8111716c:	10800058 	cmpnei	r2,r2,1
81117170:	1000761e 	bne	r2,zero,8111734c <vCheckRetransmission64+0x248>

            if ( xBuffer64[ucIL].bSent == TRUE )
81117174:	e0ffff03 	ldbu	r3,-4(fp)
81117178:	00a04574 	movhi	r2,33045
8111717c:	1097e204 	addi	r2,r2,24456
81117180:	18c01324 	muli	r3,r3,76
81117184:	10c5883a 	add	r2,r2,r3
81117188:	10801004 	addi	r2,r2,64
8111718c:	10800017 	ldw	r2,0(r2)
81117190:	10800058 	cmpnei	r2,r2,1
81117194:	1000211e 	bne	r2,zero,8111721c <vCheckRetransmission64+0x118>
                if ( ++xBuffer64[ucIL].usiTimeOut > TIMEOUT_COUNT )
81117198:	e0ffff03 	ldbu	r3,-4(fp)
8111719c:	00a04574 	movhi	r2,33045
811171a0:	1097e204 	addi	r2,r2,24456
811171a4:	19001324 	muli	r4,r3,76
811171a8:	1105883a 	add	r2,r2,r4
811171ac:	10801184 	addi	r2,r2,70
811171b0:	1080000b 	ldhu	r2,0(r2)
811171b4:	10800044 	addi	r2,r2,1
811171b8:	100b883a 	mov	r5,r2
811171bc:	00a04574 	movhi	r2,33045
811171c0:	1097e204 	addi	r2,r2,24456
811171c4:	19001324 	muli	r4,r3,76
811171c8:	1105883a 	add	r2,r2,r4
811171cc:	10801184 	addi	r2,r2,70
811171d0:	1140000d 	sth	r5,0(r2)
811171d4:	00a04574 	movhi	r2,33045
811171d8:	1097e204 	addi	r2,r2,24456
811171dc:	18c01324 	muli	r3,r3,76
811171e0:	10c5883a 	add	r2,r2,r3
811171e4:	10801184 	addi	r2,r2,70
811171e8:	1080000b 	ldhu	r2,0(r2)
811171ec:	10bfffcc 	andi	r2,r2,65535
811171f0:	10a0001c 	xori	r2,r2,32768
811171f4:	10a00004 	addi	r2,r2,-32768
811171f8:	10800090 	cmplti	r2,r2,2
811171fc:	1000071e 	bne	r2,zero,8111721c <vCheckRetransmission64+0x118>
                    xBuffer64[ucIL].bSent = FALSE;
81117200:	e0ffff03 	ldbu	r3,-4(fp)
81117204:	00a04574 	movhi	r2,33045
81117208:	1097e204 	addi	r2,r2,24456
8111720c:	18c01324 	muli	r3,r3,76
81117210:	10c5883a 	add	r2,r2,r3
81117214:	10801004 	addi	r2,r2,64
81117218:	10000015 	stw	zero,0(r2)

            if ( xBuffer64[ucIL].bSent == FALSE ) {
8111721c:	e0ffff03 	ldbu	r3,-4(fp)
81117220:	00a04574 	movhi	r2,33045
81117224:	1097e204 	addi	r2,r2,24456
81117228:	18c01324 	muli	r3,r3,76
8111722c:	10c5883a 	add	r2,r2,r3
81117230:	10801004 	addi	r2,r2,64
81117234:	10800017 	ldw	r2,0(r2)
81117238:	1000441e 	bne	r2,zero,8111734c <vCheckRetransmission64+0x248>
                puts(xBuffer64[ucIL].buffer);
8111723c:	e0bfff03 	ldbu	r2,-4(fp)
81117240:	10c01324 	muli	r3,r2,76
81117244:	00a04574 	movhi	r2,33045
81117248:	1097e204 	addi	r2,r2,24456
8111724c:	1885883a 	add	r2,r3,r2
81117250:	1009883a 	mov	r4,r2
81117254:	1122c2c0 	call	81122c2c <puts>
                xBuffer64[ucIL].bSent = TRUE;
81117258:	e0ffff03 	ldbu	r3,-4(fp)
8111725c:	00a04574 	movhi	r2,33045
81117260:	1097e204 	addi	r2,r2,24456
81117264:	18c01324 	muli	r3,r3,76
81117268:	10c5883a 	add	r2,r2,r3
8111726c:	10801004 	addi	r2,r2,64
81117270:	00c00044 	movi	r3,1
81117274:	10c00015 	stw	r3,0(r2)
                xBuffer64[ucIL].usiTimeOut = 0;
81117278:	e0ffff03 	ldbu	r3,-4(fp)
8111727c:	00a04574 	movhi	r2,33045
81117280:	1097e204 	addi	r2,r2,24456
81117284:	18c01324 	muli	r3,r3,76
81117288:	10c5883a 	add	r2,r2,r3
8111728c:	10801184 	addi	r2,r2,70
81117290:	1000000d 	sth	zero,0(r2)
                /* Check if already tried all the times */
                if ( ++xBuffer64[ucIL].ucNofRetries > N_RETRIES_COMM ) {
81117294:	e0ffff03 	ldbu	r3,-4(fp)
81117298:	00a04574 	movhi	r2,33045
8111729c:	1097e204 	addi	r2,r2,24456
811172a0:	19001324 	muli	r4,r3,76
811172a4:	1105883a 	add	r2,r2,r4
811172a8:	10801204 	addi	r2,r2,72
811172ac:	10800003 	ldbu	r2,0(r2)
811172b0:	10800044 	addi	r2,r2,1
811172b4:	100b883a 	mov	r5,r2
811172b8:	00a04574 	movhi	r2,33045
811172bc:	1097e204 	addi	r2,r2,24456
811172c0:	19001324 	muli	r4,r3,76
811172c4:	1105883a 	add	r2,r2,r4
811172c8:	10801204 	addi	r2,r2,72
811172cc:	11400005 	stb	r5,0(r2)
811172d0:	00a04574 	movhi	r2,33045
811172d4:	1097e204 	addi	r2,r2,24456
811172d8:	18c01324 	muli	r3,r3,76
811172dc:	10c5883a 	add	r2,r2,r3
811172e0:	10801204 	addi	r2,r2,72
811172e4:	10800003 	ldbu	r2,0(r2)
811172e8:	10803fcc 	andi	r2,r2,255
811172ec:	108000b0 	cmpltui	r2,r2,2
811172f0:	1000161e 	bne	r2,zero,8111734c <vCheckRetransmission64+0x248>
                    /* Now it is a Free place */
                    xInUseRetrans.b64[ucIL] = FALSE;
811172f4:	e0ffff03 	ldbu	r3,-4(fp)
811172f8:	00a045b4 	movhi	r2,33046
811172fc:	10bc1e04 	addi	r2,r2,-3976
81117300:	18c00184 	addi	r3,r3,6
81117304:	18c7883a 	add	r3,r3,r3
81117308:	18c7883a 	add	r3,r3,r3
8111730c:	10c5883a 	add	r2,r2,r3
81117310:	10000015 	stw	zero,0(r2)
                    SemCount64++;
81117314:	d0a07503 	ldbu	r2,-32300(gp)
81117318:	10800044 	addi	r2,r2,1
8111731c:	d0a07505 	stb	r2,-32300(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer64);
81117320:	d0a05e17 	ldw	r2,-32392(gp)
81117324:	1009883a 	mov	r4,r2
81117328:	113eea00 	call	8113eea0 <OSSemPost>
8111732c:	e0bfff45 	stb	r2,-3(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
81117330:	e0bfff43 	ldbu	r2,-3(fp)
81117334:	10803fcc 	andi	r2,r2,255
81117338:	10000426 	beq	r2,zero,8111734c <vCheckRetransmission64+0x248>
                        SemCount64--;
8111733c:	d0a07503 	ldbu	r2,-32300(gp)
81117340:	10bfffc4 	addi	r2,r2,-1
81117344:	d0a07505 	stb	r2,-32300(gp)
                        vFailSetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
81117348:	111bf480 	call	8111bf48 <vFailSetCountSemaphorexBuffer64>
    

    /* ---> At this point we have access to the xBuffer64*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_64; ucIL++) {
8111734c:	e0bfff03 	ldbu	r2,-4(fp)
81117350:	10800044 	addi	r2,r2,1
81117354:	e0bfff05 	stb	r2,-4(fp)
81117358:	e0bfff03 	ldbu	r2,-4(fp)
8111735c:	10800230 	cmpltui	r2,r2,8
81117360:	103f7a1e 	bne	r2,zero,8111714c <__reset+0xfb0f714c>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer64);
81117364:	d0a07117 	ldw	r2,-32316(gp)
81117368:	1009883a 	mov	r4,r2
8111736c:	113d0b00 	call	8113d0b0 <OSMutexPost>

    return;
81117370:	0001883a 	nop
81117374:	00000106 	br	8111737c <vCheckRetransmission64+0x278>
    unsigned char ucIL = 0;

    OSMutexAccept(xMutexBuffer64, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
81117378:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer64);

    return;
}
8111737c:	e037883a 	mov	sp,fp
81117380:	dfc00117 	ldw	ra,4(sp)
81117384:	df000017 	ldw	fp,0(sp)
81117388:	dec00204 	addi	sp,sp,8
8111738c:	f800283a 	ret

81117390 <vCheckRetransmission32>:


inline void vCheckRetransmission32( void ) {
81117390:	defffd04 	addi	sp,sp,-12
81117394:	de00012e 	bgeu	sp,et,8111739c <vCheckRetransmission32+0xc>
81117398:	003b68fa 	trap	3
8111739c:	dfc00215 	stw	ra,8(sp)
811173a0:	df000115 	stw	fp,4(sp)
811173a4:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
811173a8:	e03fff85 	stb	zero,-2(fp)
    unsigned char ucIL = 0;
811173ac:	e03fff05 	stb	zero,-4(fp)
    unsigned char ucMax = 0;
811173b0:	e03fff45 	stb	zero,-3(fp)

    OSMutexAccept(xMutexBuffer32, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
811173b4:	d0a06c17 	ldw	r2,-32336(gp)
811173b8:	e0ffff84 	addi	r3,fp,-2
811173bc:	180b883a 	mov	r5,r3
811173c0:	1009883a 	mov	r4,r2
811173c4:	113c48c0 	call	8113c48c <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
811173c8:	e0bfff83 	ldbu	r2,-2(fp)
811173cc:	10803fcc 	andi	r2,r2,255
811173d0:	10009b1e 	bne	r2,zero,81117640 <vCheckRetransmission32+0x2b0>
    

    /* ---> At this point we have access to the xBuffer32*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_32; ucIL++) {
811173d4:	e03fff05 	stb	zero,-4(fp)
811173d8:	00009106 	br	81117620 <vCheckRetransmission32+0x290>
        /* Check if in use */
        if ( xInUseRetrans.b32[ucIL] == TRUE ) {
811173dc:	e0ffff03 	ldbu	r3,-4(fp)
811173e0:	00a045b4 	movhi	r2,33046
811173e4:	10bc1e04 	addi	r2,r2,-3976
811173e8:	18c00384 	addi	r3,r3,14
811173ec:	18c7883a 	add	r3,r3,r3
811173f0:	18c7883a 	add	r3,r3,r3
811173f4:	10c5883a 	add	r2,r2,r3
811173f8:	10800017 	ldw	r2,0(r2)
811173fc:	10800058 	cmpnei	r2,r2,1
81117400:	1000841e 	bne	r2,zero,81117614 <vCheckRetransmission32+0x284>

            if ( xBuffer32[ucIL].bSent == TRUE )
81117404:	e0ffff03 	ldbu	r3,-4(fp)
81117408:	00a045b4 	movhi	r2,33046
8111740c:	10a99e04 	addi	r2,r2,-22920
81117410:	18c00b24 	muli	r3,r3,44
81117414:	10c5883a 	add	r2,r2,r3
81117418:	10800804 	addi	r2,r2,32
8111741c:	10800017 	ldw	r2,0(r2)
81117420:	10800058 	cmpnei	r2,r2,1
81117424:	1000211e 	bne	r2,zero,811174ac <vCheckRetransmission32+0x11c>
                if ( ++xBuffer32[ucIL].usiTimeOut > TIMEOUT_COUNT )
81117428:	e0ffff03 	ldbu	r3,-4(fp)
8111742c:	00a045b4 	movhi	r2,33046
81117430:	10a99e04 	addi	r2,r2,-22920
81117434:	19000b24 	muli	r4,r3,44
81117438:	1105883a 	add	r2,r2,r4
8111743c:	10800984 	addi	r2,r2,38
81117440:	1080000b 	ldhu	r2,0(r2)
81117444:	10800044 	addi	r2,r2,1
81117448:	100b883a 	mov	r5,r2
8111744c:	00a045b4 	movhi	r2,33046
81117450:	10a99e04 	addi	r2,r2,-22920
81117454:	19000b24 	muli	r4,r3,44
81117458:	1105883a 	add	r2,r2,r4
8111745c:	10800984 	addi	r2,r2,38
81117460:	1140000d 	sth	r5,0(r2)
81117464:	00a045b4 	movhi	r2,33046
81117468:	10a99e04 	addi	r2,r2,-22920
8111746c:	18c00b24 	muli	r3,r3,44
81117470:	10c5883a 	add	r2,r2,r3
81117474:	10800984 	addi	r2,r2,38
81117478:	1080000b 	ldhu	r2,0(r2)
8111747c:	10bfffcc 	andi	r2,r2,65535
81117480:	10a0001c 	xori	r2,r2,32768
81117484:	10a00004 	addi	r2,r2,-32768
81117488:	10800090 	cmplti	r2,r2,2
8111748c:	1000071e 	bne	r2,zero,811174ac <vCheckRetransmission32+0x11c>
                    xBuffer32[ucIL].bSent = FALSE;
81117490:	e0ffff03 	ldbu	r3,-4(fp)
81117494:	00a045b4 	movhi	r2,33046
81117498:	10a99e04 	addi	r2,r2,-22920
8111749c:	18c00b24 	muli	r3,r3,44
811174a0:	10c5883a 	add	r2,r2,r3
811174a4:	10800804 	addi	r2,r2,32
811174a8:	10000015 	stw	zero,0(r2)

            if ( xBuffer32[ucIL].bSent == FALSE ) {
811174ac:	e0ffff03 	ldbu	r3,-4(fp)
811174b0:	00a045b4 	movhi	r2,33046
811174b4:	10a99e04 	addi	r2,r2,-22920
811174b8:	18c00b24 	muli	r3,r3,44
811174bc:	10c5883a 	add	r2,r2,r3
811174c0:	10800804 	addi	r2,r2,32
811174c4:	10800017 	ldw	r2,0(r2)
811174c8:	1000521e 	bne	r2,zero,81117614 <vCheckRetransmission32+0x284>
                puts(xBuffer32[ucIL].buffer);
811174cc:	e0bfff03 	ldbu	r2,-4(fp)
811174d0:	10c00b24 	muli	r3,r2,44
811174d4:	00a045b4 	movhi	r2,33046
811174d8:	10a99e04 	addi	r2,r2,-22920
811174dc:	1885883a 	add	r2,r3,r2
811174e0:	1009883a 	mov	r4,r2
811174e4:	1122c2c0 	call	81122c2c <puts>
                xBuffer32[ucIL].bSent = TRUE;
811174e8:	e0ffff03 	ldbu	r3,-4(fp)
811174ec:	00a045b4 	movhi	r2,33046
811174f0:	10a99e04 	addi	r2,r2,-22920
811174f4:	18c00b24 	muli	r3,r3,44
811174f8:	10c5883a 	add	r2,r2,r3
811174fc:	10800804 	addi	r2,r2,32
81117500:	00c00044 	movi	r3,1
81117504:	10c00015 	stw	r3,0(r2)
                xBuffer32[ucIL].usiTimeOut = 0;
81117508:	e0ffff03 	ldbu	r3,-4(fp)
8111750c:	00a045b4 	movhi	r2,33046
81117510:	10a99e04 	addi	r2,r2,-22920
81117514:	18c00b24 	muli	r3,r3,44
81117518:	10c5883a 	add	r2,r2,r3
8111751c:	10800984 	addi	r2,r2,38
81117520:	1000000d 	sth	zero,0(r2)
                /* Check if already tried all the times */

                ucMax = ( xBuffer32[ucIL].usiId == 1 ) ? N_RETRIES_INI_INF : N_RETRIES_COMM;
81117524:	e0ffff03 	ldbu	r3,-4(fp)
81117528:	00a045b4 	movhi	r2,33046
8111752c:	10a99e04 	addi	r2,r2,-22920
81117530:	18c00b24 	muli	r3,r3,44
81117534:	10c5883a 	add	r2,r2,r3
81117538:	10800904 	addi	r2,r2,36
8111753c:	1080000b 	ldhu	r2,0(r2)
81117540:	10bfffcc 	andi	r2,r2,65535
81117544:	10800058 	cmpnei	r2,r2,1
81117548:	1000021e 	bne	r2,zero,81117554 <vCheckRetransmission32+0x1c4>
8111754c:	00bffe84 	movi	r2,-6
81117550:	00000106 	br	81117558 <vCheckRetransmission32+0x1c8>
81117554:	00800044 	movi	r2,1
81117558:	e0bfff45 	stb	r2,-3(fp)

                if ( ++xBuffer32[ucIL].ucNofRetries > ucMax ) {
8111755c:	e0ffff03 	ldbu	r3,-4(fp)
81117560:	00a045b4 	movhi	r2,33046
81117564:	10a99e04 	addi	r2,r2,-22920
81117568:	19000b24 	muli	r4,r3,44
8111756c:	1105883a 	add	r2,r2,r4
81117570:	10800a04 	addi	r2,r2,40
81117574:	10800003 	ldbu	r2,0(r2)
81117578:	10800044 	addi	r2,r2,1
8111757c:	100b883a 	mov	r5,r2
81117580:	00a045b4 	movhi	r2,33046
81117584:	10a99e04 	addi	r2,r2,-22920
81117588:	19000b24 	muli	r4,r3,44
8111758c:	1105883a 	add	r2,r2,r4
81117590:	10800a04 	addi	r2,r2,40
81117594:	11400005 	stb	r5,0(r2)
81117598:	00a045b4 	movhi	r2,33046
8111759c:	10a99e04 	addi	r2,r2,-22920
811175a0:	18c00b24 	muli	r3,r3,44
811175a4:	10c5883a 	add	r2,r2,r3
811175a8:	10800a04 	addi	r2,r2,40
811175ac:	10800003 	ldbu	r2,0(r2)
811175b0:	10803fcc 	andi	r2,r2,255
811175b4:	e0ffff43 	ldbu	r3,-3(fp)
811175b8:	1880162e 	bgeu	r3,r2,81117614 <vCheckRetransmission32+0x284>
                    /* Now it is a Free place */
                    xInUseRetrans.b32[ucIL] = FALSE;
811175bc:	e0ffff03 	ldbu	r3,-4(fp)
811175c0:	00a045b4 	movhi	r2,33046
811175c4:	10bc1e04 	addi	r2,r2,-3976
811175c8:	18c00384 	addi	r3,r3,14
811175cc:	18c7883a 	add	r3,r3,r3
811175d0:	18c7883a 	add	r3,r3,r3
811175d4:	10c5883a 	add	r2,r2,r3
811175d8:	10000015 	stw	zero,0(r2)
                    SemCount32++;
811175dc:	d0a06883 	ldbu	r2,-32350(gp)
811175e0:	10800044 	addi	r2,r2,1
811175e4:	d0a06885 	stb	r2,-32350(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer32);
811175e8:	d0a06f17 	ldw	r2,-32324(gp)
811175ec:	1009883a 	mov	r4,r2
811175f0:	113eea00 	call	8113eea0 <OSSemPost>
811175f4:	e0bfff85 	stb	r2,-2(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
811175f8:	e0bfff83 	ldbu	r2,-2(fp)
811175fc:	10803fcc 	andi	r2,r2,255
81117600:	10000426 	beq	r2,zero,81117614 <vCheckRetransmission32+0x284>
                        SemCount32--;
81117604:	d0a06883 	ldbu	r2,-32350(gp)
81117608:	10bfffc4 	addi	r2,r2,-1
8111760c:	d0a06885 	stb	r2,-32350(gp)
                        vFailSetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
81117610:	111bee00 	call	8111bee0 <vFailSetCountSemaphorexBuffer32>
    

    /* ---> At this point we have access to the xBuffer32*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_32; ucIL++) {
81117614:	e0bfff03 	ldbu	r2,-4(fp)
81117618:	10800044 	addi	r2,r2,1
8111761c:	e0bfff05 	stb	r2,-4(fp)
81117620:	e0bfff03 	ldbu	r2,-4(fp)
81117624:	10800230 	cmpltui	r2,r2,8
81117628:	103f6c1e 	bne	r2,zero,811173dc <__reset+0xfb0f73dc>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer32);
8111762c:	d0a06c17 	ldw	r2,-32336(gp)
81117630:	1009883a 	mov	r4,r2
81117634:	113d0b00 	call	8113d0b0 <OSMutexPost>

    return;
81117638:	0001883a 	nop
8111763c:	00000106 	br	81117644 <vCheckRetransmission32+0x2b4>
    unsigned char ucMax = 0;

    OSMutexAccept(xMutexBuffer32, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
81117640:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer32);

    return;
}
81117644:	e037883a 	mov	sp,fp
81117648:	dfc00117 	ldw	ra,4(sp)
8111764c:	df000017 	ldw	fp,0(sp)
81117650:	dec00204 	addi	sp,sp,8
81117654:	f800283a 	ret

81117658 <bResourcesInitRTOS>:
 */
TSimucam_MEB xSimMeb; /* Struct */
tDmaSim xDma[2];		  /* Control of the DMA */

/* Instanceatin and Initialization of the resources for the RTOS */
bool bResourcesInitRTOS( void ) {
81117658:	defff904 	addi	sp,sp,-28
8111765c:	de00012e 	bgeu	sp,et,81117664 <bResourcesInitRTOS+0xc>
81117660:	003b68fa 	trap	3
81117664:	dfc00615 	stw	ra,24(sp)
81117668:	df000515 	stw	fp,20(sp)
8111766c:	df000504 	addi	fp,sp,20
	bool bSuccess = TRUE;
81117670:	00800044 	movi	r2,1
81117674:	e0bffe15 	stw	r2,-8(fp)
	INT8U err;

	/* This semaphore in the sincronization of the task receiver_com_task with sender_com_task*/
	xSemCommInit = OSSemCreate(0);
81117678:	0009883a 	mov	r4,zero
8111767c:	113e7f00 	call	8113e7f0 <OSSemCreate>
81117680:	d0a06015 	stw	r2,-32384(gp)
	if (!xSemCommInit) {
81117684:	d0a06017 	ldw	r2,-32384(gp)
81117688:	1000021e 	bne	r2,zero,81117694 <bResourcesInitRTOS+0x3c>
		vFailCreateSemaphoreResources();
8111768c:	111b9780 	call	8111b978 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81117690:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of tx buffer, between SenderTask and Acks from ReceiverTask*/
	xTxUARTMutex = OSMutexCreate(PCP_MUTEX_TX_UART_PRIO, &err);
81117694:	e0bfff04 	addi	r2,fp,-4
81117698:	100b883a 	mov	r5,r2
8111769c:	01000444 	movi	r4,17
811176a0:	113c6380 	call	8113c638 <OSMutexCreate>
811176a4:	d0a07415 	stw	r2,-32304(gp)
	if ( err != OS_ERR_NONE ) {
811176a8:	e0bfff03 	ldbu	r2,-4(fp)
811176ac:	10803fcc 	andi	r2,r2,255
811176b0:	10000526 	beq	r2,zero,811176c8 <bResourcesInitRTOS+0x70>
		vFailCreateMutexSResources(err);
811176b4:	e0bfff03 	ldbu	r2,-4(fp)
811176b8:	10803fcc 	andi	r2,r2,255
811176bc:	1009883a 	mov	r4,r2
811176c0:	111b8cc0 	call	8111b8cc <vFailCreateMutexSResources>
		bSuccess = FALSE;
811176c4:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "big" buffer of 128 characters*/
	xMutexBuffer128 = OSMutexCreate(PCP_MUTEX_B128_PRIO, &err);
811176c8:	e0bfff04 	addi	r2,fp,-4
811176cc:	100b883a 	mov	r5,r2
811176d0:	01000504 	movi	r4,20
811176d4:	113c6380 	call	8113c638 <OSMutexCreate>
811176d8:	d0a06e15 	stw	r2,-32328(gp)
	if ( err != OS_ERR_NONE ) {
811176dc:	e0bfff03 	ldbu	r2,-4(fp)
811176e0:	10803fcc 	andi	r2,r2,255
811176e4:	10000526 	beq	r2,zero,811176fc <bResourcesInitRTOS+0xa4>
		vFailCreateMutexSResources(err);
811176e8:	e0bfff03 	ldbu	r2,-4(fp)
811176ec:	10803fcc 	andi	r2,r2,255
811176f0:	1009883a 	mov	r4,r2
811176f4:	111b8cc0 	call	8111b8cc <vFailCreateMutexSResources>
		bSuccess = FALSE;
811176f8:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "medium" buffer of 64 characters*/
	xMutexBuffer64 = OSMutexCreate(PCP_MUTEX_B64_PRIO, &err);
811176fc:	e0bfff04 	addi	r2,fp,-4
81117700:	100b883a 	mov	r5,r2
81117704:	01000544 	movi	r4,21
81117708:	113c6380 	call	8113c638 <OSMutexCreate>
8111770c:	d0a07115 	stw	r2,-32316(gp)
	if ( err != OS_ERR_NONE ) {
81117710:	e0bfff03 	ldbu	r2,-4(fp)
81117714:	10803fcc 	andi	r2,r2,255
81117718:	10000526 	beq	r2,zero,81117730 <bResourcesInitRTOS+0xd8>
		vFailCreateMutexSResources(err);
8111771c:	e0bfff03 	ldbu	r2,-4(fp)
81117720:	10803fcc 	andi	r2,r2,255
81117724:	1009883a 	mov	r4,r2
81117728:	111b8cc0 	call	8111b8cc <vFailCreateMutexSResources>
		bSuccess = FALSE;
8111772c:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "small" buffer of 32 characters*/
	xMutexBuffer32 = OSMutexCreate(PCP_MUTEX_B32_PRIO, &err);
81117730:	e0bfff04 	addi	r2,fp,-4
81117734:	100b883a 	mov	r5,r2
81117738:	01000584 	movi	r4,22
8111773c:	113c6380 	call	8113c638 <OSMutexCreate>
81117740:	d0a06c15 	stw	r2,-32336(gp)
	if ( err != OS_ERR_NONE ) {
81117744:	e0bfff03 	ldbu	r2,-4(fp)
81117748:	10803fcc 	andi	r2,r2,255
8111774c:	10000526 	beq	r2,zero,81117764 <bResourcesInitRTOS+0x10c>
		vFailCreateMutexSResources(err);
81117750:	e0bfff03 	ldbu	r2,-4(fp)
81117754:	10803fcc 	andi	r2,r2,255
81117758:	1009883a 	mov	r4,r2
8111775c:	111b8cc0 	call	8111b8cc <vFailCreateMutexSResources>
		bSuccess = FALSE;
81117760:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "big" buffer of 128 characters*/
	SemCount128 = N_128;
81117764:	00800184 	movi	r2,6
81117768:	d0a07545 	stb	r2,-32299(gp)
	xSemCountBuffer128 = OSSemCreate(N_128);
8111776c:	01000184 	movi	r4,6
81117770:	113e7f00 	call	8113e7f0 <OSSemCreate>
81117774:	d0a06315 	stw	r2,-32372(gp)
	if (!xSemCountBuffer128) {
81117778:	d0a06317 	ldw	r2,-32372(gp)
8111777c:	1000031e 	bne	r2,zero,8111778c <bResourcesInitRTOS+0x134>
		SemCount128 = 0;
81117780:	d0207545 	stb	zero,-32299(gp)
		vFailCreateSemaphoreResources();
81117784:	111b9780 	call	8111b978 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81117788:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "medium" buffer of 64 characters*/
	SemCount64 = N_64;
8111778c:	00800204 	movi	r2,8
81117790:	d0a07505 	stb	r2,-32300(gp)
	xSemCountBuffer64 = OSSemCreate(N_64);
81117794:	01000204 	movi	r4,8
81117798:	113e7f00 	call	8113e7f0 <OSSemCreate>
8111779c:	d0a05e15 	stw	r2,-32392(gp)
	if (!xSemCountBuffer64) {
811177a0:	d0a05e17 	ldw	r2,-32392(gp)
811177a4:	1000031e 	bne	r2,zero,811177b4 <bResourcesInitRTOS+0x15c>
		SemCount64 = 0;
811177a8:	d0207505 	stb	zero,-32300(gp)
		vFailCreateSemaphoreResources();
811177ac:	111b9780 	call	8111b978 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
811177b0:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "small" buffer of 32 characters*/
	SemCount32 = N_32;
811177b4:	00800204 	movi	r2,8
811177b8:	d0a06885 	stb	r2,-32350(gp)
	xSemCountBuffer32 = OSSemCreate(N_32);
811177bc:	01000204 	movi	r4,8
811177c0:	113e7f00 	call	8113e7f0 <OSSemCreate>
811177c4:	d0a06f15 	stw	r2,-32324(gp)
	if (!xSemCountBuffer32) {
811177c8:	d0a06f17 	ldw	r2,-32324(gp)
811177cc:	1000031e 	bne	r2,zero,811177dc <bResourcesInitRTOS+0x184>
		SemCount32 = 0;
811177d0:	d0206885 	stb	zero,-32350(gp)
		vFailCreateSemaphoreResources();
811177d4:	111b9780 	call	8111b978 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
811177d8:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Mutex and Semaphores to control the communication of FastReaderTask */
	xMutexReceivedACK = OSMutexCreate(PCP_MUTEX_RECEIVER_ACK, &err);
811177dc:	e0bfff04 	addi	r2,fp,-4
811177e0:	100b883a 	mov	r5,r2
811177e4:	010004c4 	movi	r4,19
811177e8:	113c6380 	call	8113c638 <OSMutexCreate>
811177ec:	d0a06515 	stw	r2,-32364(gp)
	if ( err != OS_ERR_NONE ) {
811177f0:	e0bfff03 	ldbu	r2,-4(fp)
811177f4:	10803fcc 	andi	r2,r2,255
811177f8:	10000526 	beq	r2,zero,81117810 <bResourcesInitRTOS+0x1b8>
		vFailCreateMutexSResources(err);
811177fc:	e0bfff03 	ldbu	r2,-4(fp)
81117800:	10803fcc 	andi	r2,r2,255
81117804:	1009883a 	mov	r4,r2
81117808:	111b8cc0 	call	8111b8cc <vFailCreateMutexSResources>
		bSuccess = FALSE;
8111780c:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex for Reader -> Parser*/
	xMutexPreParsed = OSMutexCreate(PCP_MUTEX_PrePareseds, &err);
81117810:	e0bfff04 	addi	r2,fp,-4
81117814:	100b883a 	mov	r5,r2
81117818:	010005c4 	movi	r4,23
8111781c:	113c6380 	call	8113c638 <OSMutexCreate>
81117820:	d0a06b15 	stw	r2,-32340(gp)
	if ( err != OS_ERR_NONE ) {
81117824:	e0bfff03 	ldbu	r2,-4(fp)
81117828:	10803fcc 	andi	r2,r2,255
8111782c:	10000526 	beq	r2,zero,81117844 <bResourcesInitRTOS+0x1ec>
		vFailCreateMutexSResources(err);
81117830:	e0bfff03 	ldbu	r2,-4(fp)
81117834:	10803fcc 	andi	r2,r2,255
81117838:	1009883a 	mov	r4,r2
8111783c:	111b8cc0 	call	8111b8cc <vFailCreateMutexSResources>
		bSuccess = FALSE;
81117840:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemCountReceivedACK = OSSemCreate(0);
81117844:	0009883a 	mov	r4,zero
81117848:	113e7f00 	call	8113e7f0 <OSSemCreate>
8111784c:	d0a06615 	stw	r2,-32360(gp)
	if (!xSemCountReceivedACK) {
81117850:	d0a06617 	ldw	r2,-32360(gp)
81117854:	1000021e 	bne	r2,zero,81117860 <bResourcesInitRTOS+0x208>
		vFailCreateSemaphoreResources();
81117858:	111b9780 	call	8111b978 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
8111785c:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemCountPreParsed = OSSemCreate(0);
81117860:	0009883a 	mov	r4,zero
81117864:	113e7f00 	call	8113e7f0 <OSSemCreate>
81117868:	d0a06415 	stw	r2,-32368(gp)
	if (!xSemCountPreParsed) {
8111786c:	d0a06417 	ldw	r2,-32368(gp)
81117870:	1000021e 	bne	r2,zero,8111787c <bResourcesInitRTOS+0x224>
		vFailCreateSemaphoreResources();
81117874:	111b9780 	call	8111b978 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81117878:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex and Semaphore to AckSenderTask*/
	xSemCountSenderACK = OSSemCreate(0);
8111787c:	0009883a 	mov	r4,zero
81117880:	113e7f00 	call	8113e7f0 <OSSemCreate>
81117884:	d0a06115 	stw	r2,-32380(gp)
	if (!xSemCountSenderACK) {
81117888:	d0a06117 	ldw	r2,-32380(gp)
8111788c:	1000021e 	bne	r2,zero,81117898 <bResourcesInitRTOS+0x240>
		vFailCreateSemaphoreResources();
81117890:	111b9780 	call	8111b978 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81117894:	e03ffe15 	stw	zero,-8(fp)
	}

	xMutexSenderACK = OSMutexCreate(PCP_MUTEX_SENDER_ACK, &err);
81117898:	e0bfff04 	addi	r2,fp,-4
8111789c:	100b883a 	mov	r5,r2
811178a0:	01000484 	movi	r4,18
811178a4:	113c6380 	call	8113c638 <OSMutexCreate>
811178a8:	d0a07215 	stw	r2,-32312(gp)
	if ( err != OS_ERR_NONE ) {
811178ac:	e0bfff03 	ldbu	r2,-4(fp)
811178b0:	10803fcc 	andi	r2,r2,255
811178b4:	10000526 	beq	r2,zero,811178cc <bResourcesInitRTOS+0x274>
		vFailCreateMutexSResources(err);
811178b8:	e0bfff03 	ldbu	r2,-4(fp)
811178bc:	10803fcc 	andi	r2,r2,255
811178c0:	1009883a 	mov	r4,r2
811178c4:	111b8cc0 	call	8111b8cc <vFailCreateMutexSResources>
		bSuccess = FALSE;
811178c8:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemTimeoutChecker = OSSemCreate(0);
811178cc:	0009883a 	mov	r4,zero
811178d0:	113e7f00 	call	8113e7f0 <OSSemCreate>
811178d4:	d0a06715 	stw	r2,-32356(gp)
	if (!xSemTimeoutChecker) {
811178d8:	d0a06717 	ldw	r2,-32356(gp)
811178dc:	1000021e 	bne	r2,zero,811178e8 <bResourcesInitRTOS+0x290>
		vFailCreateSemaphoreResources();
811178e0:	111b9780 	call	8111b978 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
811178e4:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Create the timer that will be used to count the timeout for the retransmission*/
	xTimerRetransmission = OSTmrCreate(	(INT32U         )DLY_TIMER,  /* 200 ticks = 200 millisec */
811178e8:	e0bfff04 	addi	r2,fp,-4
811178ec:	d8800215 	stw	r2,8(sp)
811178f0:	00a04574 	movhi	r2,33045
811178f4:	10ba4e04 	addi	r2,r2,-5832
811178f8:	d8800115 	stw	r2,4(sp)
811178fc:	d8000015 	stw	zero,0(sp)
81117900:	01e044b4 	movhi	r7,33042
81117904:	39e55f04 	addi	r7,r7,-27268
81117908:	01800084 	movi	r6,2
8111790c:	01400104 	movi	r5,4
81117910:	01000284 	movi	r4,10
81117914:	1140ebc0 	call	81140ebc <OSTmrCreate>
81117918:	d0a06d15 	stw	r2,-32332(gp)
										(INT8U          )OS_TMR_OPT_PERIODIC,
										(OS_TMR_CALLBACK)vTimeoutCheck,
										(void          *)0,
										(INT8U         *)"timer timeout",
										(INT8U         *)&err);	
	if ( err != OS_ERR_NONE ) {
8111791c:	e0bfff03 	ldbu	r2,-4(fp)
81117920:	10803fcc 	andi	r2,r2,255
81117924:	10000226 	beq	r2,zero,81117930 <bResourcesInitRTOS+0x2d8>
		vFailCreateTimerRetransmisison();
81117928:	111c5dc0 	call	8111c5dc <vFailCreateTimerRetransmisison>
		bSuccess = FALSE;
8111792c:	e03ffe15 	stw	zero,-8(fp)
	}

	xNfeeSchedule = OSQCreate(&xNfeeScheduleTBL[0], N_OF_MSG_QUEUE);
81117930:	01400484 	movi	r5,18
81117934:	01204574 	movhi	r4,33045
81117938:	211cde04 	addi	r4,r4,29560
8111793c:	113d7240 	call	8113d724 <OSQCreate>
81117940:	d0a05d15 	stw	r2,-32396(gp)
	if ( xNfeeSchedule == NULL ) {
81117944:	d0a05d17 	ldw	r2,-32396(gp)
81117948:	1000021e 	bne	r2,zero,81117954 <bResourcesInitRTOS+0x2fc>
		vFailCreateScheduleQueue();
8111794c:	111cbc00 	call	8111cbc0 <vFailCreateScheduleQueue>
		bSuccess = FALSE;		
81117950:	e03ffe15 	stw	zero,-8(fp)
	}

	xFeeQ[0] = OSQCreate(&xFeeQueueTBL0[0], N_MSG_FEE);
81117954:	01400204 	movi	r5,8
81117958:	012045b4 	movhi	r4,33046
8111795c:	211bf004 	addi	r4,r4,28608
81117960:	113d7240 	call	8113d724 <OSQCreate>
81117964:	d0a06a15 	stw	r2,-32344(gp)
	if ( xFeeQ[0] == NULL ) {
81117968:	d0a06a17 	ldw	r2,-32344(gp)
8111796c:	1000031e 	bne	r2,zero,8111797c <bResourcesInitRTOS+0x324>
		vFailCreateNFEEQueue( 0 );
81117970:	0009883a 	mov	r4,zero
81117974:	111cc280 	call	8111cc28 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
81117978:	e03ffe15 	stw	zero,-8(fp)
		bSuccess = FALSE;		
	}
*/


	xWaitSyncQFee[0] = OSQCreate(&SyncTBL0[0], N_MSG_SYNC);
8111797c:	01400204 	movi	r5,8
81117980:	012045b4 	movhi	r4,33046
81117984:	21013604 	addi	r4,r4,1240
81117988:	113d7240 	call	8113d724 <OSQCreate>
8111798c:	d0a05c15 	stw	r2,-32400(gp)
	if ( xWaitSyncQFee[0] == NULL ) {
81117990:	d0a05c17 	ldw	r2,-32400(gp)
81117994:	1000031e 	bne	r2,zero,811179a4 <bResourcesInitRTOS+0x34c>
		vFailCreateNFEESyncQueue( 0 );
81117998:	0009883a 	mov	r4,zero
8111799c:	111cc980 	call	8111cc98 <vFailCreateNFEESyncQueue>
		bSuccess = FALSE;
811179a0:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Syncronization (no THE sync) of the meb and signalization that has to wakeup */
	xMebQ = OSQCreate(&xMebQTBL[0], N_OF_MEB_MSG_QUEUE);
811179a4:	01400204 	movi	r5,8
811179a8:	012045b4 	movhi	r4,33046
811179ac:	213c3404 	addi	r4,r4,-3888
811179b0:	113d7240 	call	8113d724 <OSQCreate>
811179b4:	d0a06915 	stw	r2,-32348(gp)
	if ( xMebQ == NULL ) {
811179b8:	d0a06917 	ldw	r2,-32348(gp)
811179bc:	1000031e 	bne	r2,zero,811179cc <bResourcesInitRTOS+0x374>
		vFailCreateNFEEQueue( 5 );
811179c0:	01000144 	movi	r4,5
811179c4:	111cc280 	call	8111cc28 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
811179c8:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex and Semaphores to control the communication of FastReaderTask */
	xMutexPus = OSMutexCreate(PCP_MUTEX_PUS_QUEUE, &err);
811179cc:	e0bfff04 	addi	r2,fp,-4
811179d0:	100b883a 	mov	r5,r2
811179d4:	010001c4 	movi	r4,7
811179d8:	113c6380 	call	8113c638 <OSMutexCreate>
811179dc:	d0a07315 	stw	r2,-32308(gp)
	if ( err != OS_ERR_NONE ) {
811179e0:	e0bfff03 	ldbu	r2,-4(fp)
811179e4:	10803fcc 	andi	r2,r2,255
811179e8:	10000526 	beq	r2,zero,81117a00 <bResourcesInitRTOS+0x3a8>
		vFailCreateMutexSPUSQueueMeb(err);
811179ec:	e0bfff03 	ldbu	r2,-4(fp)
811179f0:	10803fcc 	andi	r2,r2,255
811179f4:	1009883a 	mov	r4,r2
811179f8:	111d0b00 	call	8111d0b0 <vFailCreateMutexSPUSQueueMeb>
		bSuccess = FALSE;
811179fc:	e03ffe15 	stw	zero,-8(fp)
	}


	/* This Queue is the fast way to comunicate with NFEE Controller task, the communication will be done by sending ints using MASKs*/
	xQMaskFeeCtrl = OSQCreate(&xQMaskCMDNFeeCtrlTBL[0], N_OF_MSG_QUEUE_MASK);
81117a00:	01400404 	movi	r5,16
81117a04:	012045b4 	movhi	r4,33046
81117a08:	213d0e04 	addi	r4,r4,-3016
81117a0c:	113d7240 	call	8113d724 <OSQCreate>
81117a10:	d0a07015 	stw	r2,-32320(gp)
	if ( xQMaskFeeCtrl == NULL ) {
81117a14:	d0a07017 	ldw	r2,-32320(gp)
81117a18:	1000021e 	bne	r2,zero,81117a24 <bResourcesInitRTOS+0x3cc>
		vCouldNotCreateQueueMaskNfeeCtrl( );
81117a1c:	111d2100 	call	8111d210 <vCouldNotCreateQueueMaskNfeeCtrl>
		bSuccess = FALSE;		
81117a20:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This Queue is the fast way to comunicate with NFEE Controller task, the communication will be done by sending ints using MASKs*/
	xQMaskDataCtrl = OSQCreate(&xQMaskCMDNDataCtrlTBL[0], N_OF_MSG_QUEUE_MASK);
81117a24:	01400404 	movi	r5,16
81117a28:	012045b4 	movhi	r4,33046
81117a2c:	212ff604 	addi	r4,r4,-16424
81117a30:	113d7240 	call	8113d724 <OSQCreate>
81117a34:	d0a05f15 	stw	r2,-32388(gp)
	if ( xQMaskDataCtrl == NULL ) {
81117a38:	d0a05f17 	ldw	r2,-32388(gp)
81117a3c:	1000021e 	bne	r2,zero,81117a48 <bResourcesInitRTOS+0x3f0>
		vCouldNotCreateQueueMaskDataCtrl( );
81117a40:	111d2780 	call	8111d278 <vCouldNotCreateQueueMaskDataCtrl>
		bSuccess = FALSE;		
81117a44:	e03ffe15 	stw	zero,-8(fp)
	}

	xDma[0].xMutexDMA = OSMutexCreate(PCP_MUTEX_DMA_0, &err);
81117a48:	e0bfff04 	addi	r2,fp,-4
81117a4c:	100b883a 	mov	r5,r2
81117a50:	01000104 	movi	r4,4
81117a54:	113c6380 	call	8113c638 <OSMutexCreate>
81117a58:	1007883a 	mov	r3,r2
81117a5c:	00a045b4 	movhi	r2,33046
81117a60:	108f4404 	addi	r2,r2,15632
81117a64:	10c00015 	stw	r3,0(r2)
	if ( err != OS_ERR_NONE ) {
81117a68:	e0bfff03 	ldbu	r2,-4(fp)
81117a6c:	10803fcc 	andi	r2,r2,255
81117a70:	10000226 	beq	r2,zero,81117a7c <bResourcesInitRTOS+0x424>
		vFailCreateMutexDMA();
81117a74:	111b92c0 	call	8111b92c <vFailCreateMutexDMA>
		bSuccess = FALSE;
81117a78:	e03ffe15 	stw	zero,-8(fp)
	}

	xDma[1].xMutexDMA = OSMutexCreate(PCP_MUTEX_DMA_1, &err);
81117a7c:	e0bfff04 	addi	r2,fp,-4
81117a80:	100b883a 	mov	r5,r2
81117a84:	01000184 	movi	r4,6
81117a88:	113c6380 	call	8113c638 <OSMutexCreate>
81117a8c:	1007883a 	mov	r3,r2
81117a90:	00a045b4 	movhi	r2,33046
81117a94:	108f4404 	addi	r2,r2,15632
81117a98:	10c00215 	stw	r3,8(r2)
	if ( err != OS_ERR_NONE ) {
81117a9c:	e0bfff03 	ldbu	r2,-4(fp)
81117aa0:	10803fcc 	andi	r2,r2,255
81117aa4:	10000226 	beq	r2,zero,81117ab0 <bResourcesInitRTOS+0x458>
		vFailCreateMutexDMA();
81117aa8:	111b92c0 	call	8111b92c <vFailCreateMutexDMA>
		bSuccess = FALSE;
81117aac:	e03ffe15 	stw	zero,-8(fp)
	}	

	return bSuccess;
81117ab0:	e0bffe17 	ldw	r2,-8(fp)
}
81117ab4:	e037883a 	mov	sp,fp
81117ab8:	dfc00117 	ldw	ra,4(sp)
81117abc:	df000017 	ldw	fp,0(sp)
81117ac0:	dec00204 	addi	sp,sp,8
81117ac4:	f800283a 	ret

81117ac8 <vVariablesInitialization>:

/* Global variables already initialized with zero. But better safe than I'm sorry. */
void vVariablesInitialization ( void ) {
81117ac8:	defffd04 	addi	sp,sp,-12
81117acc:	de00012e 	bgeu	sp,et,81117ad4 <vVariablesInitialization+0xc>
81117ad0:	003b68fa 	trap	3
81117ad4:	dfc00215 	stw	ra,8(sp)
81117ad8:	df000115 	stw	fp,4(sp)
81117adc:	df000104 	addi	fp,sp,4
	unsigned char ucIL = 0;
81117ae0:	e03fff05 	stb	zero,-4(fp)

	usiIdCMD = 2;
81117ae4:	00800084 	movi	r2,2
81117ae8:	d0a0680d 	sth	r2,-32352(gp)

	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128));
81117aec:	01800604 	movi	r6,24
81117af0:	000b883a 	mov	r5,zero
81117af4:	012045b4 	movhi	r4,33046
81117af8:	213c1e04 	addi	r4,r4,-3976
81117afc:	11227e00 	call	811227e0 <memset>
	memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64));
81117b00:	01800804 	movi	r6,32
81117b04:	000b883a 	mov	r5,zero
81117b08:	012045b4 	movhi	r4,33046
81117b0c:	213c2404 	addi	r4,r4,-3952
81117b10:	11227e00 	call	811227e0 <memset>
	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32));
81117b14:	01800804 	movi	r6,32
81117b18:	000b883a 	mov	r5,zero
81117b1c:	012045b4 	movhi	r4,33046
81117b20:	213c2c04 	addi	r4,r4,-3920
81117b24:	11227e00 	call	811227e0 <memset>
	
	for( ucIL = 0; ucIL < N_128; ucIL++)
81117b28:	e03fff05 	stb	zero,-4(fp)
81117b2c:	00002806 	br	81117bd0 <vVariablesInitialization+0x108>
	{
		memset( xBuffer128[ucIL].buffer, 0, 128);
81117b30:	e0bfff03 	ldbu	r2,-4(fp)
81117b34:	10c02324 	muli	r3,r2,140
81117b38:	00a045b4 	movhi	r2,33046
81117b3c:	10bc3c04 	addi	r2,r2,-3856
81117b40:	1885883a 	add	r2,r3,r2
81117b44:	01802004 	movi	r6,128
81117b48:	000b883a 	mov	r5,zero
81117b4c:	1009883a 	mov	r4,r2
81117b50:	11227e00 	call	811227e0 <memset>
		xBuffer128[ucIL].bSent = FALSE;
81117b54:	e0ffff03 	ldbu	r3,-4(fp)
81117b58:	00a045b4 	movhi	r2,33046
81117b5c:	10bc3c04 	addi	r2,r2,-3856
81117b60:	18c02324 	muli	r3,r3,140
81117b64:	10c5883a 	add	r2,r2,r3
81117b68:	10802004 	addi	r2,r2,128
81117b6c:	10000015 	stw	zero,0(r2)
		xBuffer128[ucIL].usiId = 0;
81117b70:	e0ffff03 	ldbu	r3,-4(fp)
81117b74:	00a045b4 	movhi	r2,33046
81117b78:	10bc3c04 	addi	r2,r2,-3856
81117b7c:	18c02324 	muli	r3,r3,140
81117b80:	10c5883a 	add	r2,r2,r3
81117b84:	10802104 	addi	r2,r2,132
81117b88:	1000000d 	sth	zero,0(r2)
		xBuffer128[ucIL].usiTimeOut = 0;
81117b8c:	e0ffff03 	ldbu	r3,-4(fp)
81117b90:	00a045b4 	movhi	r2,33046
81117b94:	10bc3c04 	addi	r2,r2,-3856
81117b98:	18c02324 	muli	r3,r3,140
81117b9c:	10c5883a 	add	r2,r2,r3
81117ba0:	10802184 	addi	r2,r2,134
81117ba4:	1000000d 	sth	zero,0(r2)
		xBuffer128[ucIL].ucNofRetries = 0;
81117ba8:	e0ffff03 	ldbu	r3,-4(fp)
81117bac:	00a045b4 	movhi	r2,33046
81117bb0:	10bc3c04 	addi	r2,r2,-3856
81117bb4:	18c02324 	muli	r3,r3,140
81117bb8:	10c5883a 	add	r2,r2,r3
81117bbc:	10802204 	addi	r2,r2,136
81117bc0:	10000005 	stb	zero,0(r2)

	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128));
	memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64));
	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32));
	
	for( ucIL = 0; ucIL < N_128; ucIL++)
81117bc4:	e0bfff03 	ldbu	r2,-4(fp)
81117bc8:	10800044 	addi	r2,r2,1
81117bcc:	e0bfff05 	stb	r2,-4(fp)
81117bd0:	e0bfff03 	ldbu	r2,-4(fp)
81117bd4:	108001b0 	cmpltui	r2,r2,6
81117bd8:	103fd51e 	bne	r2,zero,81117b30 <__reset+0xfb0f7b30>
		xBuffer128[ucIL].usiId = 0;
		xBuffer128[ucIL].usiTimeOut = 0;
		xBuffer128[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_64; ucIL++)
81117bdc:	e03fff05 	stb	zero,-4(fp)
81117be0:	00002806 	br	81117c84 <vVariablesInitialization+0x1bc>
	{
		memset( xBuffer64[ucIL].buffer, 0, 64);
81117be4:	e0bfff03 	ldbu	r2,-4(fp)
81117be8:	10c01324 	muli	r3,r2,76
81117bec:	00a04574 	movhi	r2,33045
81117bf0:	1097e204 	addi	r2,r2,24456
81117bf4:	1885883a 	add	r2,r3,r2
81117bf8:	01801004 	movi	r6,64
81117bfc:	000b883a 	mov	r5,zero
81117c00:	1009883a 	mov	r4,r2
81117c04:	11227e00 	call	811227e0 <memset>
		xBuffer64[ucIL].bSent = FALSE;
81117c08:	e0ffff03 	ldbu	r3,-4(fp)
81117c0c:	00a04574 	movhi	r2,33045
81117c10:	1097e204 	addi	r2,r2,24456
81117c14:	18c01324 	muli	r3,r3,76
81117c18:	10c5883a 	add	r2,r2,r3
81117c1c:	10801004 	addi	r2,r2,64
81117c20:	10000015 	stw	zero,0(r2)
		xBuffer64[ucIL].usiId = 0;
81117c24:	e0ffff03 	ldbu	r3,-4(fp)
81117c28:	00a04574 	movhi	r2,33045
81117c2c:	1097e204 	addi	r2,r2,24456
81117c30:	18c01324 	muli	r3,r3,76
81117c34:	10c5883a 	add	r2,r2,r3
81117c38:	10801104 	addi	r2,r2,68
81117c3c:	1000000d 	sth	zero,0(r2)
		xBuffer64[ucIL].usiTimeOut = 0;
81117c40:	e0ffff03 	ldbu	r3,-4(fp)
81117c44:	00a04574 	movhi	r2,33045
81117c48:	1097e204 	addi	r2,r2,24456
81117c4c:	18c01324 	muli	r3,r3,76
81117c50:	10c5883a 	add	r2,r2,r3
81117c54:	10801184 	addi	r2,r2,70
81117c58:	1000000d 	sth	zero,0(r2)
		xBuffer64[ucIL].ucNofRetries = 0;
81117c5c:	e0ffff03 	ldbu	r3,-4(fp)
81117c60:	00a04574 	movhi	r2,33045
81117c64:	1097e204 	addi	r2,r2,24456
81117c68:	18c01324 	muli	r3,r3,76
81117c6c:	10c5883a 	add	r2,r2,r3
81117c70:	10801204 	addi	r2,r2,72
81117c74:	10000005 	stb	zero,0(r2)
		xBuffer128[ucIL].usiId = 0;
		xBuffer128[ucIL].usiTimeOut = 0;
		xBuffer128[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_64; ucIL++)
81117c78:	e0bfff03 	ldbu	r2,-4(fp)
81117c7c:	10800044 	addi	r2,r2,1
81117c80:	e0bfff05 	stb	r2,-4(fp)
81117c84:	e0bfff03 	ldbu	r2,-4(fp)
81117c88:	10800230 	cmpltui	r2,r2,8
81117c8c:	103fd51e 	bne	r2,zero,81117be4 <__reset+0xfb0f7be4>
		xBuffer64[ucIL].usiId = 0;
		xBuffer64[ucIL].usiTimeOut = 0;
		xBuffer64[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_32; ucIL++)
81117c90:	e03fff05 	stb	zero,-4(fp)
81117c94:	00002806 	br	81117d38 <vVariablesInitialization+0x270>
	{
		memset( xBuffer32[ucIL].buffer, 0, 32);
81117c98:	e0bfff03 	ldbu	r2,-4(fp)
81117c9c:	10c00b24 	muli	r3,r2,44
81117ca0:	00a045b4 	movhi	r2,33046
81117ca4:	10a99e04 	addi	r2,r2,-22920
81117ca8:	1885883a 	add	r2,r3,r2
81117cac:	01800804 	movi	r6,32
81117cb0:	000b883a 	mov	r5,zero
81117cb4:	1009883a 	mov	r4,r2
81117cb8:	11227e00 	call	811227e0 <memset>
		xBuffer32[ucIL].bSent = FALSE;
81117cbc:	e0ffff03 	ldbu	r3,-4(fp)
81117cc0:	00a045b4 	movhi	r2,33046
81117cc4:	10a99e04 	addi	r2,r2,-22920
81117cc8:	18c00b24 	muli	r3,r3,44
81117ccc:	10c5883a 	add	r2,r2,r3
81117cd0:	10800804 	addi	r2,r2,32
81117cd4:	10000015 	stw	zero,0(r2)
		xBuffer32[ucIL].usiId = 0;
81117cd8:	e0ffff03 	ldbu	r3,-4(fp)
81117cdc:	00a045b4 	movhi	r2,33046
81117ce0:	10a99e04 	addi	r2,r2,-22920
81117ce4:	18c00b24 	muli	r3,r3,44
81117ce8:	10c5883a 	add	r2,r2,r3
81117cec:	10800904 	addi	r2,r2,36
81117cf0:	1000000d 	sth	zero,0(r2)
		xBuffer32[ucIL].usiTimeOut = 0;
81117cf4:	e0ffff03 	ldbu	r3,-4(fp)
81117cf8:	00a045b4 	movhi	r2,33046
81117cfc:	10a99e04 	addi	r2,r2,-22920
81117d00:	18c00b24 	muli	r3,r3,44
81117d04:	10c5883a 	add	r2,r2,r3
81117d08:	10800984 	addi	r2,r2,38
81117d0c:	1000000d 	sth	zero,0(r2)
		xBuffer32[ucIL].ucNofRetries = 0;
81117d10:	e0ffff03 	ldbu	r3,-4(fp)
81117d14:	00a045b4 	movhi	r2,33046
81117d18:	10a99e04 	addi	r2,r2,-22920
81117d1c:	18c00b24 	muli	r3,r3,44
81117d20:	10c5883a 	add	r2,r2,r3
81117d24:	10800a04 	addi	r2,r2,40
81117d28:	10000005 	stb	zero,0(r2)
		xBuffer64[ucIL].usiId = 0;
		xBuffer64[ucIL].usiTimeOut = 0;
		xBuffer64[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_32; ucIL++)
81117d2c:	e0bfff03 	ldbu	r2,-4(fp)
81117d30:	10800044 	addi	r2,r2,1
81117d34:	e0bfff05 	stb	r2,-4(fp)
81117d38:	e0bfff03 	ldbu	r2,-4(fp)
81117d3c:	10800230 	cmpltui	r2,r2,8
81117d40:	103fd51e 	bne	r2,zero,81117c98 <__reset+0xfb0f7c98>
		xBuffer32[ucIL].usiTimeOut = 0;
		xBuffer32[ucIL].ucNofRetries = 0;
	}


	for( ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
81117d44:	e03fff05 	stb	zero,-4(fp)
81117d48:	00001b06 	br	81117db8 <vVariablesInitialization+0x2f0>
	{
		xPus[ucIL].bInUse = FALSE;
81117d4c:	e0ffff03 	ldbu	r3,-4(fp)
81117d50:	00a04574 	movhi	r2,33045
81117d54:	10987a04 	addi	r2,r2,25064
81117d58:	18c01524 	muli	r3,r3,84
81117d5c:	10c5883a 	add	r2,r2,r3
81117d60:	10800104 	addi	r2,r2,4
81117d64:	10000015 	stw	zero,0(r2)
		xPus[ucIL].ucNofValues = 0;
81117d68:	e0ffff03 	ldbu	r3,-4(fp)
81117d6c:	00a04574 	movhi	r2,33045
81117d70:	10987a04 	addi	r2,r2,25064
81117d74:	18c01524 	muli	r3,r3,84
81117d78:	10c5883a 	add	r2,r2,r3
81117d7c:	10800484 	addi	r2,r2,18
81117d80:	10000005 	stb	zero,0(r2)
		memset( xPus[ucIL].usiValues, 0, sizeof(xPus[ucIL].usiValues));
81117d84:	e0bfff03 	ldbu	r2,-4(fp)
81117d88:	10801524 	muli	r2,r2,84
81117d8c:	10c00504 	addi	r3,r2,20
81117d90:	00a04574 	movhi	r2,33045
81117d94:	10987a04 	addi	r2,r2,25064
81117d98:	1885883a 	add	r2,r3,r2
81117d9c:	01801004 	movi	r6,64
81117da0:	000b883a 	mov	r5,zero
81117da4:	1009883a 	mov	r4,r2
81117da8:	11227e00 	call	811227e0 <memset>
		xBuffer32[ucIL].usiTimeOut = 0;
		xBuffer32[ucIL].ucNofRetries = 0;
	}


	for( ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
81117dac:	e0bfff03 	ldbu	r2,-4(fp)
81117db0:	10800044 	addi	r2,r2,1
81117db4:	e0bfff05 	stb	r2,-4(fp)
81117db8:	e0bfff03 	ldbu	r2,-4(fp)
81117dbc:	10800130 	cmpltui	r2,r2,4
81117dc0:	103fe21e 	bne	r2,zero,81117d4c <__reset+0xfb0f7d4c>

txSenderACKs xSenderACK[N_ACKS_SENDER];

*/

}
81117dc4:	0001883a 	nop
81117dc8:	e037883a 	mov	sp,fp
81117dcc:	dfc00117 	ldw	ra,4(sp)
81117dd0:	df000017 	ldw	fp,0(sp)
81117dd4:	dec00204 	addi	sp,sp,8
81117dd8:	f800283a 	ret

81117ddc <main>:
void vPrintMemmoryPattern( TSimucam_MEB *xSimMebL );


/* Entry point */
int main(void)
{
81117ddc:	defff704 	addi	sp,sp,-36
81117de0:	de00012e 	bgeu	sp,et,81117de8 <main+0xc>
81117de4:	003b68fa 	trap	3
81117de8:	dfc00815 	stw	ra,32(sp)
81117dec:	df000715 	stw	fp,28(sp)
81117df0:	df000704 	addi	fp,sp,28
	INT8U error_code;
	bool bIniSimucamStatus = FALSE;
81117df4:	e03ffe15 	stw	zero,-8(fp)
	
	OSInit();
81117df8:	1138ad40 	call	81138ad4 <OSInit>

	/* Debug device initialization - JTAG USB */
	#ifdef DEBUG_ON
		fp = fopen(JTAG_UART_0_NAME, "r+");
81117dfc:	01604574 	movhi	r5,33045
81117e00:	297a5204 	addi	r5,r5,-5816
81117e04:	01204574 	movhi	r4,33045
81117e08:	213a5304 	addi	r4,r4,-5812
81117e0c:	11215980 	call	81121598 <fopen>
81117e10:	d0a06215 	stw	r2,-32376(gp)
	#endif	

	#ifdef DEBUG_ON
		debug(fp, "Main entry point.\n");
81117e14:	d0a06217 	ldw	r2,-32376(gp)
81117e18:	100f883a 	mov	r7,r2
81117e1c:	01800484 	movi	r6,18
81117e20:	01400044 	movi	r5,1
81117e24:	01204574 	movhi	r4,33045
81117e28:	213a5804 	addi	r4,r4,-5792
81117e2c:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	/* Initialization of basic HW */
	vInitSimucamBasicHW();
81117e30:	111e2b80 	call	8111e2b8 <vInitSimucamBasicHW>

	/* Test of some critical IPCores HW interfaces in the Simucam */
	bIniSimucamStatus = bTestSimucamCriticalHW();
81117e34:	111ef3c0 	call	8111ef3c <bTestSimucamCriticalHW>
81117e38:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81117e3c:	e0bffe17 	ldw	r2,-8(fp)
81117e40:	1000031e 	bne	r2,zero,81117e50 <main+0x74>
		vFailTestCriticasParts();
81117e44:	111b9c40 	call	8111b9c4 <vFailTestCriticasParts>
		return -1;
81117e48:	00bfffc4 	movi	r2,-1
81117e4c:	00004f06 	br	81117f8c <main+0x1b0>
	}


	/* Log file Initialization in the SDCard */
	bIniSimucamStatus = bInitializeSDCard();
81117e50:	111ea2c0 	call	8111ea2c <bInitializeSDCard>
81117e54:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81117e58:	e0bffe17 	ldw	r2,-8(fp)
81117e5c:	1000031e 	bne	r2,zero,81117e6c <main+0x90>
		vFailTestCriticasParts();
81117e60:	111b9c40 	call	8111b9c4 <vFailTestCriticasParts>
		return -1;
81117e64:	00bfffc4 	movi	r2,-1
81117e68:	00004806 	br	81117f8c <main+0x1b0>
	}

	bIniSimucamStatus = vLoadDefaultETHConf();
81117e6c:	11199a40 	call	811199a4 <vLoadDefaultETHConf>
81117e70:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81117e74:	e0bffe17 	ldw	r2,-8(fp)
81117e78:	1000091e 	bne	r2,zero,81117ea0 <main+0xc4>
		/* Default configuration for eth connection loaded */
		#ifdef DEBUG_ON
			debug(fp, "Didn't load ETH configuration from SDCard. Default configuration will be loaded. \n");
81117e7c:	d0a06217 	ldw	r2,-32376(gp)
81117e80:	100f883a 	mov	r7,r2
81117e84:	01801484 	movi	r6,82
81117e88:	01400044 	movi	r5,1
81117e8c:	01204574 	movhi	r4,33045
81117e90:	213a5d04 	addi	r4,r4,-5772
81117e94:	1121c7c0 	call	81121c7c <fwrite>
		#endif
		return -1;
81117e98:	00bfffc4 	movi	r2,-1
81117e9c:	00003b06 	br	81117f8c <main+0x1b0>
	}

	bIniSimucamStatus = vLoadDebugConfs();
81117ea0:	111a6ac0 	call	8111a6ac <vLoadDebugConfs>
81117ea4:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81117ea8:	e0bffe17 	ldw	r2,-8(fp)
81117eac:	1000091e 	bne	r2,zero,81117ed4 <main+0xf8>
		/* Default configuration for eth connection loaded */
		#ifdef DEBUG_ON
			debug(fp, "Didn't load DEBUG configuration from SDCard. Default configuration will be loaded. \n");
81117eb0:	d0a06217 	ldw	r2,-32376(gp)
81117eb4:	100f883a 	mov	r7,r2
81117eb8:	01801504 	movi	r6,84
81117ebc:	01400044 	movi	r5,1
81117ec0:	01204574 	movhi	r4,33045
81117ec4:	213a7204 	addi	r4,r4,-5688
81117ec8:	1121c7c0 	call	81121c7c <fwrite>
		#endif
		return -1;
81117ecc:	00bfffc4 	movi	r2,-1
81117ed0:	00002e06 	br	81117f8c <main+0x1b0>



	/* If debug is enable, will print the eth configuration in the*/
	#ifdef DEBUG_ON
		vShowEthConfig();
81117ed4:	111a37c0 	call	8111a37c <vShowEthConfig>
	#endif


	/* This function creates all resources needed by the RTOS*/
	bIniSimucamStatus = bResourcesInitRTOS();
81117ed8:	11176580 	call	81117658 <bResourcesInitRTOS>
81117edc:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81117ee0:	e0bffe17 	ldw	r2,-8(fp)
81117ee4:	1000091e 	bne	r2,zero,81117f0c <main+0x130>
		/* Default configuration for eth connection loaded */
		debug(fp, "Can't allocate resources for RTOS. (exit) \n");
81117ee8:	d0a06217 	ldw	r2,-32376(gp)
81117eec:	100f883a 	mov	r7,r2
81117ef0:	01800ac4 	movi	r6,43
81117ef4:	01400044 	movi	r5,1
81117ef8:	01204574 	movhi	r4,33045
81117efc:	213a8804 	addi	r4,r4,-5600
81117f00:	1121c7c0 	call	81121c7c <fwrite>
		return -1;
81117f04:	00bfffc4 	movi	r2,-1
81117f08:	00002006 	br	81117f8c <main+0x1b0>
	}

	/* Start the structure of control of the Simucam Application, including all FEEs instances */
	vSimucamStructureInit( &xSimMeb );
81117f0c:	012045b4 	movhi	r4,33046
81117f10:	2124f004 	addi	r4,r4,-27712
81117f14:	111e3f80 	call	8111e3f8 <vSimucamStructureInit>

	vVariablesInitialization();
81117f18:	1117ac80 	call	81117ac8 <vVariablesInitialization>

	bInitSync();
81117f1c:	111ebe00 	call	8111ebe0 <bInitSync>

	vFillMemmoryPattern( &xSimMeb );
81117f20:	012045b4 	movhi	r4,33046
81117f24:	2124f004 	addi	r4,r4,-27712
81117f28:	1117fa00 	call	81117fa0 <vFillMemmoryPattern>



	/* Creating the initialization task*/
	#if STACK_MONITOR
		error_code = OSTaskCreateExt(vInitialTask,
81117f2c:	008000c4 	movi	r2,3
81117f30:	d8800415 	stw	r2,16(sp)
81117f34:	d8000315 	stw	zero,12(sp)
81117f38:	00810004 	movi	r2,1024
81117f3c:	d8800215 	stw	r2,8(sp)
81117f40:	00a045b4 	movhi	r2,33046
81117f44:	10b41604 	addi	r2,r2,-12200
81117f48:	d8800115 	stw	r2,4(sp)
81117f4c:	00800044 	movi	r2,1
81117f50:	d8800015 	stw	r2,0(sp)
81117f54:	01c00044 	movi	r7,1
81117f58:	01a045b4 	movhi	r6,33046
81117f5c:	31b81504 	addi	r6,r6,-8108
81117f60:	000b883a 	mov	r5,zero
81117f64:	01204474 	movhi	r4,33041
81117f68:	21094504 	addi	r4,r4,9492
81117f6c:	113f8840 	call	8113f884 <OSTaskCreateExt>
81117f70:	e0bfff05 	stb	r2,-4(fp)
									NULL,
									0);
	#endif


	if ( error_code == OS_ERR_NONE ) {
81117f74:	e0bfff03 	ldbu	r2,-4(fp)
81117f78:	1000021e 	bne	r2,zero,81117f84 <main+0x1a8>
		/* Start the scheduler (start the Real Time Application) */
		OSStart();
81117f7c:	1138e040 	call	81138e04 <OSStart>
81117f80:	00000106 	br	81117f88 <main+0x1ac>
	} else {
		/* Some error occurs in the creation of the Initialization Task */
		vFailInitialization();
81117f84:	111bdb00 	call	8111bdb0 <vFailInitialization>
	}
  
	return 0;
81117f88:	0005883a 	mov	r2,zero
}
81117f8c:	e037883a 	mov	sp,fp
81117f90:	dfc00117 	ldw	ra,4(sp)
81117f94:	df000017 	ldw	fp,0(sp)
81117f98:	dec00204 	addi	sp,sp,8
81117f9c:	f800283a 	ret

81117fa0 <vFillMemmoryPattern>:


void vFillMemmoryPattern( TSimucam_MEB *xSimMebL ) {
81117fa0:	defff604 	addi	sp,sp,-40
81117fa4:	de00012e 	bgeu	sp,et,81117fac <vFillMemmoryPattern+0xc>
81117fa8:	003b68fa 	trap	3
81117fac:	dfc00915 	stw	ra,36(sp)
81117fb0:	df000815 	stw	fp,32(sp)
81117fb4:	df000804 	addi	fp,sp,32
81117fb8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 width_cols;
	alt_u32 height_rows;
	alt_u8 n_of_NFEE_in_mem;
	alt_u8 NFee_i;

	n_of_NFEE_in_mem = 1;
81117fbc:	00800044 	movi	r2,1
81117fc0:	e0bffcc5 	stb	r2,-13(fp)

#ifdef DEBUG_ON
	debug(fp, "Start to fill the memory with Pattern.\n");
81117fc4:	d0a06217 	ldw	r2,-32376(gp)
81117fc8:	100f883a 	mov	r7,r2
81117fcc:	018009c4 	movi	r6,39
81117fd0:	01400044 	movi	r5,1
81117fd4:	01204574 	movhi	r4,33045
81117fd8:	213a9304 	addi	r4,r4,-5556
81117fdc:	1121c7c0 	call	81121c7c <fwrite>
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
81117fe0:	e03ffa05 	stb	zero,-24(fp)
81117fe4:	00007606 	br	811181c0 <vFillMemmoryPattern+0x220>
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
81117fe8:	e03ffc85 	stb	zero,-14(fp)
81117fec:	00006706 	br	8111818c <vFillMemmoryPattern+0x1ec>
			/* 4 CCDs */
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
81117ff0:	e0bffc83 	ldbu	r2,-14(fp)
81117ff4:	e0ffff17 	ldw	r3,-4(fp)
81117ff8:	10809624 	muli	r2,r2,600
81117ffc:	1885883a 	add	r2,r3,r2
81118000:	10804304 	addi	r2,r2,268
81118004:	1080000b 	ldhu	r2,0(r2)
81118008:	10ffffcc 	andi	r3,r2,65535
8111800c:	e0bffc83 	ldbu	r2,-14(fp)
81118010:	e13fff17 	ldw	r4,-4(fp)
81118014:	10809624 	muli	r2,r2,600
81118018:	2085883a 	add	r2,r4,r2
8111801c:	10804204 	addi	r2,r2,264
81118020:	1080000b 	ldhu	r2,0(r2)
81118024:	10bfffcc 	andi	r2,r2,65535
81118028:	1885883a 	add	r2,r3,r2
8111802c:	e0bffd15 	stw	r2,-12(fp)
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
81118030:	e0bffc83 	ldbu	r2,-14(fp)
81118034:	e0ffff17 	ldw	r3,-4(fp)
81118038:	10809624 	muli	r2,r2,600
8111803c:	1885883a 	add	r2,r3,r2
81118040:	10804284 	addi	r2,r2,266
81118044:	1080000b 	ldhu	r2,0(r2)
81118048:	10ffffcc 	andi	r3,r2,65535
8111804c:	e0bffc83 	ldbu	r2,-14(fp)
81118050:	e13fff17 	ldw	r4,-4(fp)
81118054:	10809624 	muli	r2,r2,600
81118058:	2085883a 	add	r2,r4,r2
8111805c:	10804184 	addi	r2,r2,262
81118060:	1080000b 	ldhu	r2,0(r2)
81118064:	10bfffcc 	andi	r2,r2,65535
81118068:	1887883a 	add	r3,r3,r2
8111806c:	e0bffc83 	ldbu	r2,-14(fp)
81118070:	e13fff17 	ldw	r4,-4(fp)
81118074:	10809624 	muli	r2,r2,600
81118078:	2085883a 	add	r2,r4,r2
8111807c:	10804104 	addi	r2,r2,260
81118080:	1080000b 	ldhu	r2,0(r2)
81118084:	10bfffcc 	andi	r2,r2,65535
81118088:	1885883a 	add	r2,r3,r2
8111808c:	e0bffe15 	stw	r2,-8(fp)
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
81118090:	e03ffc05 	stb	zero,-16(fp)
81118094:	00003706 	br	81118174 <vFillMemmoryPattern+0x1d4>

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
81118098:	e03ffc45 	stb	zero,-15(fp)
8111809c:	00002606 	br	81118138 <vFillMemmoryPattern+0x198>
					if (ccd_side == 0){
811180a0:	e0bffc43 	ldbu	r2,-15(fp)
811180a4:	10000b1e 	bne	r2,zero,811180d4 <vFillMemmoryPattern+0x134>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xLeft.ulOffsetAddr;
811180a8:	e0bffc83 	ldbu	r2,-14(fp)
811180ac:	e13ffc03 	ldbu	r4,-16(fp)
811180b0:	e0ffff17 	ldw	r3,-4(fp)
811180b4:	21000624 	muli	r4,r4,24
811180b8:	10809624 	muli	r2,r2,600
811180bc:	2085883a 	add	r2,r4,r2
811180c0:	1885883a 	add	r2,r3,r2
811180c4:	10801b04 	addi	r2,r2,108
811180c8:	10800017 	ldw	r2,0(r2)
811180cc:	e0bffb15 	stw	r2,-20(fp)
811180d0:	00000a06 	br	811180fc <vFillMemmoryPattern+0x15c>
					} else {
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
811180d4:	e0bffc83 	ldbu	r2,-14(fp)
811180d8:	e13ffc03 	ldbu	r4,-16(fp)
811180dc:	e0ffff17 	ldw	r3,-4(fp)
811180e0:	21000624 	muli	r4,r4,24
811180e4:	10809624 	muli	r2,r2,600
811180e8:	2085883a 	add	r2,r4,r2
811180ec:	1885883a 	add	r2,r3,r2
811180f0:	10801e04 	addi	r2,r2,120
811180f4:	10800017 	ldw	r2,0(r2)
811180f8:	e0bffb15 	stw	r2,-20(fp)
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
811180fc:	e0fffa03 	ldbu	r3,-24(fp)
81118100:	e13ffc03 	ldbu	r4,-16(fp)
81118104:	e17ffc43 	ldbu	r5,-15(fp)
81118108:	e0bffd17 	ldw	r2,-12(fp)
8111810c:	d8800115 	stw	r2,4(sp)
81118110:	e0bffe17 	ldw	r2,-8(fp)
81118114:	d8800015 	stw	r2,0(sp)
81118118:	280f883a 	mov	r7,r5
8111811c:	200d883a 	mov	r6,r4
81118120:	e17ffb17 	ldw	r5,-20(fp)
81118124:	1809883a 	mov	r4,r3
81118128:	111e7bc0 	call	8111e7bc <pattern_createPattern>
			/* 4 CCDs */
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
8111812c:	e0bffc43 	ldbu	r2,-15(fp)
81118130:	10800044 	addi	r2,r2,1
81118134:	e0bffc45 	stb	r2,-15(fp)
81118138:	e0bffc43 	ldbu	r2,-15(fp)
8111813c:	108000b0 	cmpltui	r2,r2,2
81118140:	103fd71e 	bne	r2,zero,811180a0 <__reset+0xfb0f80a0>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
				}
				#ifdef DEBUG_ON
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
81118144:	d0a06217 	ldw	r2,-32376(gp)
81118148:	e0fffc83 	ldbu	r3,-14(fp)
8111814c:	e13ffc03 	ldbu	r4,-16(fp)
81118150:	200f883a 	mov	r7,r4
81118154:	180d883a 	mov	r6,r3
81118158:	01604574 	movhi	r5,33045
8111815c:	297a9d04 	addi	r5,r5,-5516
81118160:	1009883a 	mov	r4,r2
81118164:	11215e00 	call	811215e0 <fprintf>

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
			/* 4 CCDs */
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
81118168:	e0bffc03 	ldbu	r2,-16(fp)
8111816c:	10800044 	addi	r2,r2,1
81118170:	e0bffc05 	stb	r2,-16(fp)
81118174:	e0bffc03 	ldbu	r2,-16(fp)
81118178:	10800130 	cmpltui	r2,r2,4
8111817c:	103fc61e 	bne	r2,zero,81118098 <__reset+0xfb0f8098>

	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
81118180:	e0bffc83 	ldbu	r2,-14(fp)
81118184:	10800044 	addi	r2,r2,1
81118188:	e0bffc85 	stb	r2,-14(fp)
8111818c:	e0fffc83 	ldbu	r3,-14(fp)
81118190:	e0bffcc3 	ldbu	r2,-13(fp)
81118194:	18bf9636 	bltu	r3,r2,81117ff0 <__reset+0xfb0f7ff0>
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
				#endif
			}
		}
		#ifdef DEBUG_ON
			fprintf(fp, "Memory %i. \n",mem_number);
81118198:	d0a06217 	ldw	r2,-32376(gp)
8111819c:	e0fffa03 	ldbu	r3,-24(fp)
811181a0:	180d883a 	mov	r6,r3
811181a4:	01604574 	movhi	r5,33045
811181a8:	297aa204 	addi	r5,r5,-5496
811181ac:	1009883a 	mov	r4,r2
811181b0:	11215e00 	call	811215e0 <fprintf>
	debug(fp, "Start to fill the memory with Pattern.\n");
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
811181b4:	e0bffa03 	ldbu	r2,-24(fp)
811181b8:	10800044 	addi	r2,r2,1
811181bc:	e0bffa05 	stb	r2,-24(fp)
811181c0:	e0bffa03 	ldbu	r2,-24(fp)
811181c4:	108000b0 	cmpltui	r2,r2,2
811181c8:	103f871e 	bne	r2,zero,81117fe8 <__reset+0xfb0f7fe8>
			fprintf(fp, "Memory %i. \n",mem_number);
		#endif
	}

#ifdef DEBUG_ON
	debug(fp, "Memory Filled. \n");
811181cc:	d0a06217 	ldw	r2,-32376(gp)
811181d0:	100f883a 	mov	r7,r2
811181d4:	01800404 	movi	r6,16
811181d8:	01400044 	movi	r5,1
811181dc:	01204574 	movhi	r4,33045
811181e0:	213aa604 	addi	r4,r4,-5480
811181e4:	1121c7c0 	call	81121c7c <fwrite>
#endif


}
811181e8:	0001883a 	nop
811181ec:	e037883a 	mov	sp,fp
811181f0:	dfc00117 	ldw	ra,4(sp)
811181f4:	df000017 	ldw	fp,0(sp)
811181f8:	dec00204 	addi	sp,sp,8
811181fc:	f800283a 	ret

81118200 <vPrintMemmoryPattern>:

void vPrintMemmoryPattern( TSimucam_MEB *xSimMebL ) {
81118200:	defff604 	addi	sp,sp,-40
81118204:	de00012e 	bgeu	sp,et,8111820c <vPrintMemmoryPattern+0xc>
81118208:	003b68fa 	trap	3
8111820c:	dfc00915 	stw	ra,36(sp)
81118210:	df000815 	stw	fp,32(sp)
81118214:	df000804 	addi	fp,sp,32
81118218:	e13fff15 	stw	r4,-4(fp)
	alt_u32 width_cols;
	alt_u32 height_rows;
	alt_u8 n_of_NFEE_in_mem;
	alt_u8 NFee_i;

	n_of_NFEE_in_mem = 1;
8111821c:	00800044 	movi	r2,1
81118220:	e0bffcc5 	stb	r2,-13(fp)

#ifdef DEBUG_ON
	debug(fp, "Start to fill the memory with Pattern.\n");
81118224:	d0a06217 	ldw	r2,-32376(gp)
81118228:	100f883a 	mov	r7,r2
8111822c:	018009c4 	movi	r6,39
81118230:	01400044 	movi	r5,1
81118234:	01204574 	movhi	r4,33045
81118238:	213a9304 	addi	r4,r4,-5556
8111823c:	1121c7c0 	call	81121c7c <fwrite>
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
81118240:	e03ffa05 	stb	zero,-24(fp)
81118244:	00007606 	br	81118420 <vPrintMemmoryPattern+0x220>
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
81118248:	e03ffc85 	stb	zero,-14(fp)
8111824c:	00006706 	br	811183ec <vPrintMemmoryPattern+0x1ec>
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
81118250:	e0bffc83 	ldbu	r2,-14(fp)
81118254:	e0ffff17 	ldw	r3,-4(fp)
81118258:	10809624 	muli	r2,r2,600
8111825c:	1885883a 	add	r2,r3,r2
81118260:	10804304 	addi	r2,r2,268
81118264:	1080000b 	ldhu	r2,0(r2)
81118268:	10ffffcc 	andi	r3,r2,65535
8111826c:	e0bffc83 	ldbu	r2,-14(fp)
81118270:	e13fff17 	ldw	r4,-4(fp)
81118274:	10809624 	muli	r2,r2,600
81118278:	2085883a 	add	r2,r4,r2
8111827c:	10804204 	addi	r2,r2,264
81118280:	1080000b 	ldhu	r2,0(r2)
81118284:	10bfffcc 	andi	r2,r2,65535
81118288:	1885883a 	add	r2,r3,r2
8111828c:	e0bffd15 	stw	r2,-12(fp)
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
81118290:	e0bffc83 	ldbu	r2,-14(fp)
81118294:	e0ffff17 	ldw	r3,-4(fp)
81118298:	10809624 	muli	r2,r2,600
8111829c:	1885883a 	add	r2,r3,r2
811182a0:	10804284 	addi	r2,r2,266
811182a4:	1080000b 	ldhu	r2,0(r2)
811182a8:	10ffffcc 	andi	r3,r2,65535
811182ac:	e0bffc83 	ldbu	r2,-14(fp)
811182b0:	e13fff17 	ldw	r4,-4(fp)
811182b4:	10809624 	muli	r2,r2,600
811182b8:	2085883a 	add	r2,r4,r2
811182bc:	10804184 	addi	r2,r2,262
811182c0:	1080000b 	ldhu	r2,0(r2)
811182c4:	10bfffcc 	andi	r2,r2,65535
811182c8:	1887883a 	add	r3,r3,r2
811182cc:	e0bffc83 	ldbu	r2,-14(fp)
811182d0:	e13fff17 	ldw	r4,-4(fp)
811182d4:	10809624 	muli	r2,r2,600
811182d8:	2085883a 	add	r2,r4,r2
811182dc:	10804104 	addi	r2,r2,260
811182e0:	1080000b 	ldhu	r2,0(r2)
811182e4:	10bfffcc 	andi	r2,r2,65535
811182e8:	1885883a 	add	r2,r3,r2
811182ec:	e0bffe15 	stw	r2,-8(fp)
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
811182f0:	e03ffc05 	stb	zero,-16(fp)
811182f4:	00003706 	br	811183d4 <vPrintMemmoryPattern+0x1d4>

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
811182f8:	e03ffc45 	stb	zero,-15(fp)
811182fc:	00002606 	br	81118398 <vPrintMemmoryPattern+0x198>
					if (ccd_side == 0){
81118300:	e0bffc43 	ldbu	r2,-15(fp)
81118304:	10000b1e 	bne	r2,zero,81118334 <vPrintMemmoryPattern+0x134>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xLeft.ulOffsetAddr;
81118308:	e0bffc83 	ldbu	r2,-14(fp)
8111830c:	e13ffc03 	ldbu	r4,-16(fp)
81118310:	e0ffff17 	ldw	r3,-4(fp)
81118314:	21000624 	muli	r4,r4,24
81118318:	10809624 	muli	r2,r2,600
8111831c:	2085883a 	add	r2,r4,r2
81118320:	1885883a 	add	r2,r3,r2
81118324:	10801b04 	addi	r2,r2,108
81118328:	10800017 	ldw	r2,0(r2)
8111832c:	e0bffb15 	stw	r2,-20(fp)
81118330:	00000a06 	br	8111835c <vPrintMemmoryPattern+0x15c>
					} else {
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
81118334:	e0bffc83 	ldbu	r2,-14(fp)
81118338:	e13ffc03 	ldbu	r4,-16(fp)
8111833c:	e0ffff17 	ldw	r3,-4(fp)
81118340:	21000624 	muli	r4,r4,24
81118344:	10809624 	muli	r2,r2,600
81118348:	2085883a 	add	r2,r4,r2
8111834c:	1885883a 	add	r2,r3,r2
81118350:	10801e04 	addi	r2,r2,120
81118354:	10800017 	ldw	r2,0(r2)
81118358:	e0bffb15 	stw	r2,-20(fp)
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
8111835c:	e0fffa03 	ldbu	r3,-24(fp)
81118360:	e13ffc03 	ldbu	r4,-16(fp)
81118364:	e17ffc43 	ldbu	r5,-15(fp)
81118368:	e0bffe17 	ldw	r2,-8(fp)
8111836c:	d8800115 	stw	r2,4(sp)
81118370:	e0bffd17 	ldw	r2,-12(fp)
81118374:	d8800015 	stw	r2,0(sp)
81118378:	280f883a 	mov	r7,r5
8111837c:	200d883a 	mov	r6,r4
81118380:	e17ffb17 	ldw	r5,-20(fp)
81118384:	1809883a 	mov	r4,r3
81118388:	111e7bc0 	call	8111e7bc <pattern_createPattern>
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
8111838c:	e0bffc43 	ldbu	r2,-15(fp)
81118390:	10800044 	addi	r2,r2,1
81118394:	e0bffc45 	stb	r2,-15(fp)
81118398:	e0bffc43 	ldbu	r2,-15(fp)
8111839c:	108000b0 	cmpltui	r2,r2,2
811183a0:	103fd71e 	bne	r2,zero,81118300 <__reset+0xfb0f8300>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
				}
				#ifdef DEBUG_ON
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
811183a4:	d0a06217 	ldw	r2,-32376(gp)
811183a8:	e0fffc83 	ldbu	r3,-14(fp)
811183ac:	e13ffc03 	ldbu	r4,-16(fp)
811183b0:	200f883a 	mov	r7,r4
811183b4:	180d883a 	mov	r6,r3
811183b8:	01604574 	movhi	r5,33045
811183bc:	297a9d04 	addi	r5,r5,-5516
811183c0:	1009883a 	mov	r4,r2
811183c4:	11215e00 	call	811215e0 <fprintf>

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
811183c8:	e0bffc03 	ldbu	r2,-16(fp)
811183cc:	10800044 	addi	r2,r2,1
811183d0:	e0bffc05 	stb	r2,-16(fp)
811183d4:	e0bffc03 	ldbu	r2,-16(fp)
811183d8:	10800130 	cmpltui	r2,r2,4
811183dc:	103fc61e 	bne	r2,zero,811182f8 <__reset+0xfb0f82f8>

	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
811183e0:	e0bffc83 	ldbu	r2,-14(fp)
811183e4:	10800044 	addi	r2,r2,1
811183e8:	e0bffc85 	stb	r2,-14(fp)
811183ec:	e0fffc83 	ldbu	r3,-14(fp)
811183f0:	e0bffcc3 	ldbu	r2,-13(fp)
811183f4:	18bf9636 	bltu	r3,r2,81118250 <__reset+0xfb0f8250>
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
				#endif
			}
		}
		#ifdef DEBUG_ON
			fprintf(fp, "Memory %i. \n",mem_number);
811183f8:	d0a06217 	ldw	r2,-32376(gp)
811183fc:	e0fffa03 	ldbu	r3,-24(fp)
81118400:	180d883a 	mov	r6,r3
81118404:	01604574 	movhi	r5,33045
81118408:	297aa204 	addi	r5,r5,-5496
8111840c:	1009883a 	mov	r4,r2
81118410:	11215e00 	call	811215e0 <fprintf>
	debug(fp, "Start to fill the memory with Pattern.\n");
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
81118414:	e0bffa03 	ldbu	r2,-24(fp)
81118418:	10800044 	addi	r2,r2,1
8111841c:	e0bffa05 	stb	r2,-24(fp)
81118420:	e0bffa03 	ldbu	r2,-24(fp)
81118424:	108000b0 	cmpltui	r2,r2,2
81118428:	103f871e 	bne	r2,zero,81118248 <__reset+0xfb0f8248>
			fprintf(fp, "Memory %i. \n",mem_number);
		#endif
	}

#ifdef DEBUG_ON
	debug(fp, "Memory Filled. \n");
8111842c:	d0a06217 	ldw	r2,-32376(gp)
81118430:	100f883a 	mov	r7,r2
81118434:	01800404 	movi	r6,16
81118438:	01400044 	movi	r5,1
8111843c:	01204574 	movhi	r4,33045
81118440:	213aa604 	addi	r4,r4,-5480
81118444:	1121c7c0 	call	81121c7c <fwrite>
#endif


}
81118448:	0001883a 	nop
8111844c:	e037883a 	mov	sp,fp
81118450:	dfc00117 	ldw	ra,4(sp)
81118454:	df000017 	ldw	fp,0(sp)
81118458:	dec00204 	addi	sp,sp,8
8111845c:	f800283a 	ret

81118460 <vCCDLoadDefaultValues>:
 */

#include "ccd.h"


void vCCDLoadDefaultValues( TCcdInfos *ccdDef ) {
81118460:	defffd04 	addi	sp,sp,-12
81118464:	de00012e 	bgeu	sp,et,8111846c <vCCDLoadDefaultValues+0xc>
81118468:	003b68fa 	trap	3
8111846c:	dfc00215 	stw	ra,8(sp)
81118470:	df000115 	stw	fp,4(sp)
81118474:	df000104 	addi	fp,sp,4
81118478:	e13fff15 	stw	r4,-4(fp)
	ccdDef->usiOLN = 30;
	ccdDef->usiHalfWidth = 2255;
	ccdDef->usiSOverscanN = 15;
	ccdDef->usiSPrescanN = 25;
*/
	ccdDef->usiHeight = xDefaults.usiRows;
8111847c:	00a045b4 	movhi	r2,33046
81118480:	109c0004 	addi	r2,r2,28672
81118484:	10c0060b 	ldhu	r3,24(r2)
81118488:	e0bfff17 	ldw	r2,-4(fp)
8111848c:	10c0020d 	sth	r3,8(r2)
	ccdDef->usiOLN = xDefaults.usiOLN;
81118490:	00a045b4 	movhi	r2,33046
81118494:	109c0004 	addi	r2,r2,28672
81118498:	10c0050b 	ldhu	r3,20(r2)
8111849c:	e0bfff17 	ldw	r2,-4(fp)
811184a0:	10c0010d 	sth	r3,4(r2)
	ccdDef->usiHalfWidth = xDefaults.usiCols;
811184a4:	00a045b4 	movhi	r2,33046
811184a8:	109c0004 	addi	r2,r2,28672
811184ac:	10c0058b 	ldhu	r3,22(r2)
811184b0:	e0bfff17 	ldw	r2,-4(fp)
811184b4:	10c0018d 	sth	r3,6(r2)
	ccdDef->usiSOverscanN = xDefaults.usiOverScanSerial;
811184b8:	00a045b4 	movhi	r2,33046
811184bc:	109c0004 	addi	r2,r2,28672
811184c0:	10c0040b 	ldhu	r3,16(r2)
811184c4:	e0bfff17 	ldw	r2,-4(fp)
811184c8:	10c0008d 	sth	r3,2(r2)
	ccdDef->usiSPrescanN = xDefaults.usiPreScanSerial;
811184cc:	00a045b4 	movhi	r2,33046
811184d0:	109c0004 	addi	r2,r2,28672
811184d4:	10c0048b 	ldhu	r3,18(r2)
811184d8:	e0bfff17 	ldw	r2,-4(fp)
811184dc:	10c0000d 	sth	r3,0(r2)

#ifdef DEBUG_ON
	//fprintf(fp,"\n    i: %u ",incrementador);
	fprintf(fp,"\nusiHeight %hu\n", ccdDef->usiHeight);
811184e0:	d0e06217 	ldw	r3,-32376(gp)
811184e4:	e0bfff17 	ldw	r2,-4(fp)
811184e8:	1080020b 	ldhu	r2,8(r2)
811184ec:	10bfffcc 	andi	r2,r2,65535
811184f0:	100d883a 	mov	r6,r2
811184f4:	01604574 	movhi	r5,33045
811184f8:	297aab04 	addi	r5,r5,-5460
811184fc:	1809883a 	mov	r4,r3
81118500:	11215e00 	call	811215e0 <fprintf>
	fprintf(fp,"usiOLN %hu\n", ccdDef->usiOLN);
81118504:	d0e06217 	ldw	r3,-32376(gp)
81118508:	e0bfff17 	ldw	r2,-4(fp)
8111850c:	1080010b 	ldhu	r2,4(r2)
81118510:	10bfffcc 	andi	r2,r2,65535
81118514:	100d883a 	mov	r6,r2
81118518:	01604574 	movhi	r5,33045
8111851c:	297aaf04 	addi	r5,r5,-5444
81118520:	1809883a 	mov	r4,r3
81118524:	11215e00 	call	811215e0 <fprintf>
	fprintf(fp,"usiHalfWidth %hu\n", ccdDef->usiHalfWidth);
81118528:	d0e06217 	ldw	r3,-32376(gp)
8111852c:	e0bfff17 	ldw	r2,-4(fp)
81118530:	1080018b 	ldhu	r2,6(r2)
81118534:	10bfffcc 	andi	r2,r2,65535
81118538:	100d883a 	mov	r6,r2
8111853c:	01604574 	movhi	r5,33045
81118540:	297ab204 	addi	r5,r5,-5432
81118544:	1809883a 	mov	r4,r3
81118548:	11215e00 	call	811215e0 <fprintf>
	fprintf(fp,"usiSOverscanN %hu\n", ccdDef->usiSOverscanN);
8111854c:	d0e06217 	ldw	r3,-32376(gp)
81118550:	e0bfff17 	ldw	r2,-4(fp)
81118554:	1080008b 	ldhu	r2,2(r2)
81118558:	10bfffcc 	andi	r2,r2,65535
8111855c:	100d883a 	mov	r6,r2
81118560:	01604574 	movhi	r5,33045
81118564:	297ab704 	addi	r5,r5,-5412
81118568:	1809883a 	mov	r4,r3
8111856c:	11215e00 	call	811215e0 <fprintf>
	fprintf(fp,"usiSPrescanN %hu\n",  ccdDef->usiSPrescanN);
81118570:	d0e06217 	ldw	r3,-32376(gp)
81118574:	e0bfff17 	ldw	r2,-4(fp)
81118578:	1080000b 	ldhu	r2,0(r2)
8111857c:	10bfffcc 	andi	r2,r2,65535
81118580:	100d883a 	mov	r6,r2
81118584:	01604574 	movhi	r5,33045
81118588:	297abc04 	addi	r5,r5,-5392
8111858c:	1809883a 	mov	r4,r3
81118590:	11215e00 	call	811215e0 <fprintf>
#endif

}
81118594:	0001883a 	nop
81118598:	e037883a 	mov	sp,fp
8111859c:	dfc00117 	ldw	ra,4(sp)
811185a0:	df000017 	ldw	fp,0(sp)
811185a4:	dec00204 	addi	sp,sp,8
811185a8:	f800283a 	ret

811185ac <vCCDChangeValues>:

/* Only in NFEE_CONFIG of NFEE_STAND_BY */
/* Used to change de values of the CCD definitions from any source */
void vCCDChangeValues( TCcdInfos *ccdDef, unsigned short int usiHeight, unsigned short int usiOLN, unsigned short int usiHalfWidth,
                                unsigned short int usiSOverscanN, unsigned short int usiSPrescanN  ) {
811185ac:	defff904 	addi	sp,sp,-28
811185b0:	de00012e 	bgeu	sp,et,811185b8 <vCCDChangeValues+0xc>
811185b4:	003b68fa 	trap	3
811185b8:	df000615 	stw	fp,24(sp)
811185bc:	df000604 	addi	fp,sp,24
811185c0:	e13ffa15 	stw	r4,-24(fp)
811185c4:	2811883a 	mov	r8,r5
811185c8:	300b883a 	mov	r5,r6
811185cc:	3809883a 	mov	r4,r7
811185d0:	e0c00117 	ldw	r3,4(fp)
811185d4:	e0800217 	ldw	r2,8(fp)
811185d8:	e23ffb0d 	sth	r8,-20(fp)
811185dc:	e17ffc0d 	sth	r5,-16(fp)
811185e0:	e13ffd0d 	sth	r4,-12(fp)
811185e4:	e0fffe0d 	sth	r3,-8(fp)
811185e8:	e0bfff0d 	sth	r2,-4(fp)

	ccdDef->usiHeight = usiHeight;
811185ec:	e0bffa17 	ldw	r2,-24(fp)
811185f0:	e0fffb0b 	ldhu	r3,-20(fp)
811185f4:	10c0020d 	sth	r3,8(r2)
	ccdDef->usiOLN = usiOLN;
811185f8:	e0bffa17 	ldw	r2,-24(fp)
811185fc:	e0fffc0b 	ldhu	r3,-16(fp)
81118600:	10c0010d 	sth	r3,4(r2)
	ccdDef->usiHalfWidth = usiHalfWidth;
81118604:	e0bffa17 	ldw	r2,-24(fp)
81118608:	e0fffd0b 	ldhu	r3,-12(fp)
8111860c:	10c0018d 	sth	r3,6(r2)
	ccdDef->usiSOverscanN = usiSOverscanN;
81118610:	e0bffa17 	ldw	r2,-24(fp)
81118614:	e0fffe0b 	ldhu	r3,-8(fp)
81118618:	10c0008d 	sth	r3,2(r2)
	ccdDef->usiSPrescanN = usiSPrescanN;
8111861c:	e0bffa17 	ldw	r2,-24(fp)
81118620:	e0ffff0b 	ldhu	r3,-4(fp)
81118624:	10c0000d 	sth	r3,0(r2)
}
81118628:	0001883a 	nop
8111862c:	e037883a 	mov	sp,fp
81118630:	df000017 	ldw	fp,0(sp)
81118634:	dec00104 	addi	sp,sp,4
81118638:	f800283a 	ret

8111863c <bSendUART128v2>:
#include "communication_utils.h"


/* Make sure that there is only 127 characters to send */
/* Always, ALWAYS send only an char[128] that you first did a memset(cBuffer,0,128), before put some string on it. */
bool bSendUART128v2 ( char *cBuffer, short int siIdMessage ) {
8111863c:	defff904 	addi	sp,sp,-28
81118640:	de00012e 	bgeu	sp,et,81118648 <bSendUART128v2+0xc>
81118644:	003b68fa 	trap	3
81118648:	dfc00615 	stw	ra,24(sp)
8111864c:	df000515 	stw	fp,20(sp)
81118650:	df000504 	addi	fp,sp,20
81118654:	e13ffe15 	stw	r4,-8(fp)
81118658:	2805883a 	mov	r2,r5
8111865c:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;;
81118660:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
81118664:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
81118668:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
8111866c:	e03ffc15 	stw	zero,-16(fp)

	OSSemPend(xSemCountBuffer128, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
81118670:	d0a06317 	ldw	r2,-32372(gp)
81118674:	e0fffd04 	addi	r3,fp,-12
81118678:	180d883a 	mov	r6,r3
8111867c:	01400504 	movi	r5,20
81118680:	1009883a 	mov	r4,r2
81118684:	113eb180 	call	8113eb18 <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
81118688:	e0bffd03 	ldbu	r2,-12(fp)
8111868c:	10803fcc 	andi	r2,r2,255
81118690:	10000326 	beq	r2,zero,811186a0 <bSendUART128v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
81118694:	111c0180 	call	8111c018 <vFailGetCountSemaphorexBuffer128>
		return bSuccessL;
81118698:	e0bffc17 	ldw	r2,-16(fp)
8111869c:	00009e06 	br	81118918 <bSendUART128v2+0x2dc>

	/* ---> At this point we know that there is some space in the buffer */


	/* Need to get the Mutex that protects xBuffer128 */
	OSMutexPend(xMutexBuffer128, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
811186a0:	d0a06e17 	ldw	r2,-32328(gp)
811186a4:	e0fffd04 	addi	r3,fp,-12
811186a8:	180d883a 	mov	r6,r3
811186ac:	01400104 	movi	r5,4
811186b0:	1009883a 	mov	r4,r2
811186b4:	113cb0c0 	call	8113cb0c <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
811186b8:	e0bffd03 	ldbu	r2,-12(fp)
811186bc:	10803fcc 	andi	r2,r2,255
811186c0:	10001126 	beq	r2,zero,81118708 <bSendUART128v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer128 that protect xBuffer128. (bSendUART128v2)\n");
811186c4:	d0a06217 	ldw	r2,-32376(gp)
811186c8:	100f883a 	mov	r7,r2
811186cc:	01801484 	movi	r6,82
811186d0:	01400044 	movi	r5,1
811186d4:	01204574 	movhi	r4,33045
811186d8:	213ac104 	addi	r4,r4,-5372
811186dc:	1121c7c0 	call	81121c7c <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer128);
811186e0:	d0a06317 	ldw	r2,-32372(gp)
811186e4:	1009883a 	mov	r4,r2
811186e8:	113eea00 	call	8113eea0 <OSSemPost>
811186ec:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
811186f0:	e0bffd03 	ldbu	r2,-12(fp)
811186f4:	10803fcc 	andi	r2,r2,255
811186f8:	10000126 	beq	r2,zero,81118700 <bSendUART128v2+0xc4>
			vFailSetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
811186fc:	111bfb00 	call	8111bfb0 <vFailSetCountSemaphorexBuffer128>
		}

		return bSuccessL;
81118700:	e0bffc17 	ldw	r2,-16(fp)
81118704:	00008406 	br	81118918 <bSendUART128v2+0x2dc>
	/* ---> At this point we Have the mutex of the xBuffer128, and we can use it freely */


	
	/* Search for space */
	for( ucIL = 0; ucIL < N_128; ucIL++)
81118708:	e03ffb05 	stb	zero,-20(fp)
8111870c:	00004306 	br	8111881c <bSendUART128v2+0x1e0>
	{
		if ( xInUseRetrans.b128[ucIL] == FALSE ) {
81118710:	e0fffb03 	ldbu	r3,-20(fp)
81118714:	00a045b4 	movhi	r2,33046
81118718:	10bc1e04 	addi	r2,r2,-3976
8111871c:	18c7883a 	add	r3,r3,r3
81118720:	18c7883a 	add	r3,r3,r3
81118724:	10c5883a 	add	r2,r2,r3
81118728:	10800017 	ldw	r2,0(r2)
8111872c:	1000381e 	bne	r2,zero,81118810 <bSendUART128v2+0x1d4>
			/* Clear the buffer */
			memset(xBuffer128[ucIL].buffer, 0, 128);
81118730:	e0bffb03 	ldbu	r2,-20(fp)
81118734:	10c02324 	muli	r3,r2,140
81118738:	00a045b4 	movhi	r2,33046
8111873c:	10bc3c04 	addi	r2,r2,-3856
81118740:	1885883a 	add	r2,r3,r2
81118744:	01802004 	movi	r6,128
81118748:	000b883a 	mov	r5,zero
8111874c:	1009883a 	mov	r4,r2
81118750:	11227e00 	call	811227e0 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer128[ucIL].buffer, cBuffer, 127);
81118754:	e0bffb03 	ldbu	r2,-20(fp)
81118758:	10c02324 	muli	r3,r2,140
8111875c:	00a045b4 	movhi	r2,33046
81118760:	10bc3c04 	addi	r2,r2,-3856
81118764:	1885883a 	add	r2,r3,r2
81118768:	01801fc4 	movi	r6,127
8111876c:	e17ffe17 	ldw	r5,-8(fp)
81118770:	1009883a 	mov	r4,r2
81118774:	11226900 	call	81122690 <memcpy>
			xBuffer128[ucIL].usiId = siIdMessage;
81118778:	e13ffb03 	ldbu	r4,-20(fp)
8111877c:	e0ffff0b 	ldhu	r3,-4(fp)
81118780:	00a045b4 	movhi	r2,33046
81118784:	10bc3c04 	addi	r2,r2,-3856
81118788:	21002324 	muli	r4,r4,140
8111878c:	1105883a 	add	r2,r2,r4
81118790:	10802104 	addi	r2,r2,132
81118794:	10c0000d 	sth	r3,0(r2)
			xBuffer128[ucIL].ucNofRetries = 0;
81118798:	e0fffb03 	ldbu	r3,-20(fp)
8111879c:	00a045b4 	movhi	r2,33046
811187a0:	10bc3c04 	addi	r2,r2,-3856
811187a4:	18c02324 	muli	r3,r3,140
811187a8:	10c5883a 	add	r2,r2,r3
811187ac:	10802204 	addi	r2,r2,136
811187b0:	10000005 	stb	zero,0(r2)
			xBuffer128[ucIL].usiTimeOut = 0;
811187b4:	e0fffb03 	ldbu	r3,-20(fp)
811187b8:	00a045b4 	movhi	r2,33046
811187bc:	10bc3c04 	addi	r2,r2,-3856
811187c0:	18c02324 	muli	r3,r3,140
811187c4:	10c5883a 	add	r2,r2,r3
811187c8:	10802184 	addi	r2,r2,134
811187cc:	1000000d 	sth	zero,0(r2)
			xBuffer128[ucIL].bSent = FALSE;
811187d0:	e0fffb03 	ldbu	r3,-20(fp)
811187d4:	00a045b4 	movhi	r2,33046
811187d8:	10bc3c04 	addi	r2,r2,-3856
811187dc:	18c02324 	muli	r3,r3,140
811187e0:	10c5883a 	add	r2,r2,r3
811187e4:	10802004 	addi	r2,r2,128
811187e8:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b128[ucIL] = TRUE;
811187ec:	e0fffb03 	ldbu	r3,-20(fp)
811187f0:	00a045b4 	movhi	r2,33046
811187f4:	10bc1e04 	addi	r2,r2,-3976
811187f8:	18c7883a 	add	r3,r3,r3
811187fc:	18c7883a 	add	r3,r3,r3
81118800:	10c5883a 	add	r2,r2,r3
81118804:	00c00044 	movi	r3,1
81118808:	10c00015 	stw	r3,0(r2)
			break;
8111880c:	00000606 	br	81118828 <bSendUART128v2+0x1ec>
	/* ---> At this point we Have the mutex of the xBuffer128, and we can use it freely */


	
	/* Search for space */
	for( ucIL = 0; ucIL < N_128; ucIL++)
81118810:	e0bffb03 	ldbu	r2,-20(fp)
81118814:	10800044 	addi	r2,r2,1
81118818:	e0bffb05 	stb	r2,-20(fp)
8111881c:	e0bffb03 	ldbu	r2,-20(fp)
81118820:	108001b0 	cmpltui	r2,r2,6
81118824:	103fba1e 	bne	r2,zero,81118710 <__reset+0xfb0f8710>
			xInUseRetrans.b128[ucIL] = TRUE;
			break;
		}
	}

	if ( ucIL >= N_128 ) {
81118828:	e0bffb03 	ldbu	r2,-20(fp)
8111882c:	108001b0 	cmpltui	r2,r2,6
81118830:	1000091e 	bne	r2,zero,81118858 <bSendUART128v2+0x21c>
		ucErrorCode = OSSemPost(xSemCountBuffer128);
81118834:	d0a06317 	ldw	r2,-32372(gp)
81118838:	1009883a 	mov	r4,r2
8111883c:	113eea00 	call	8113eea0 <OSSemPost>
81118840:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer128);
81118844:	d0a06e17 	ldw	r2,-32328(gp)
81118848:	1009883a 	mov	r4,r2
8111884c:	113d0b00 	call	8113d0b0 <OSMutexPost>
		return bSuccessL;
81118850:	e0bffc17 	ldw	r2,-16(fp)
81118854:	00003006 	br	81118918 <bSendUART128v2+0x2dc>
	}

	bSuccessL = TRUE;
81118858:	00800044 	movi	r2,1
8111885c:	e0bffc15 	stw	r2,-16(fp)
	SemCount128--; /* Sure that you get the semaphore */
81118860:	d0a07543 	ldbu	r2,-32299(gp)
81118864:	10bfffc4 	addi	r2,r2,-1
81118868:	d0a07545 	stb	r2,-32299(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
8111886c:	d0a07417 	ldw	r2,-32304(gp)
81118870:	e0fffd04 	addi	r3,fp,-12
81118874:	180d883a 	mov	r6,r3
81118878:	01400084 	movi	r5,2
8111887c:	1009883a 	mov	r4,r2
81118880:	113cb0c0 	call	8113cb0c <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81118884:	e0bffd03 	ldbu	r2,-12(fp)
81118888:	10803fcc 	andi	r2,r2,255
8111888c:	10000c26 	beq	r2,zero,811188c0 <bSendUART128v2+0x284>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART128v2)\n");
81118890:	d0a06217 	ldw	r2,-32376(gp)
81118894:	100f883a 	mov	r7,r2
81118898:	01801c04 	movi	r6,112
8111889c:	01400044 	movi	r5,1
811188a0:	01204574 	movhi	r4,33045
811188a4:	213ad604 	addi	r4,r4,-5288
811188a8:	1121c7c0 	call	81121c7c <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer128 */
		OSMutexPost(xMutexBuffer128); /* Free the Mutex after use the xBuffer128*/
811188ac:	d0a06e17 	ldw	r2,-32328(gp)
811188b0:	1009883a 	mov	r4,r2
811188b4:	113d0b00 	call	8113d0b0 <OSMutexPost>
		return bSuccessL;
811188b8:	e0bffc17 	ldw	r2,-16(fp)
811188bc:	00001606 	br	81118918 <bSendUART128v2+0x2dc>


	/* ---> At this point we have all resources to send the message */


	puts(xBuffer128[ucIL].buffer);
811188c0:	e0bffb03 	ldbu	r2,-20(fp)
811188c4:	10c02324 	muli	r3,r2,140
811188c8:	00a045b4 	movhi	r2,33046
811188cc:	10bc3c04 	addi	r2,r2,-3856
811188d0:	1885883a 	add	r2,r3,r2
811188d4:	1009883a 	mov	r4,r2
811188d8:	1122c2c0 	call	81122c2c <puts>
	xBuffer128[ucIL].bSent = TRUE;
811188dc:	e0fffb03 	ldbu	r3,-20(fp)
811188e0:	00a045b4 	movhi	r2,33046
811188e4:	10bc3c04 	addi	r2,r2,-3856
811188e8:	18c02324 	muli	r3,r3,140
811188ec:	10c5883a 	add	r2,r2,r3
811188f0:	10802004 	addi	r2,r2,128
811188f4:	00c00044 	movi	r3,1
811188f8:	10c00015 	stw	r3,0(r2)


	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */

	OSMutexPost(xTxUARTMutex);
811188fc:	d0a07417 	ldw	r2,-32304(gp)
81118900:	1009883a 	mov	r4,r2
81118904:	113d0b00 	call	8113d0b0 <OSMutexPost>
	OSMutexPost(xMutexBuffer128);
81118908:	d0a06e17 	ldw	r2,-32328(gp)
8111890c:	1009883a 	mov	r4,r2
81118910:	113d0b00 	call	8113d0b0 <OSMutexPost>

	return bSuccessL;
81118914:	e0bffc17 	ldw	r2,-16(fp)
}
81118918:	e037883a 	mov	sp,fp
8111891c:	dfc00117 	ldw	ra,4(sp)
81118920:	df000017 	ldw	fp,0(sp)
81118924:	dec00204 	addi	sp,sp,8
81118928:	f800283a 	ret

8111892c <bSendUART64v2>:



/* Make sure that there is only 63 characters to send */
/* Always, ALWAYS send only an char[64] that you first did a memset(cBuffer,0,64), before put some string on it. */
bool bSendUART64v2 ( char *cBuffer, short int siIdMessage ) {
8111892c:	defff904 	addi	sp,sp,-28
81118930:	de00012e 	bgeu	sp,et,81118938 <bSendUART64v2+0xc>
81118934:	003b68fa 	trap	3
81118938:	dfc00615 	stw	ra,24(sp)
8111893c:	df000515 	stw	fp,20(sp)
81118940:	df000504 	addi	fp,sp,20
81118944:	e13ffe15 	stw	r4,-8(fp)
81118948:	2805883a 	mov	r2,r5
8111894c:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;
81118950:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
81118954:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
81118958:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
8111895c:	e03ffc15 	stw	zero,-16(fp)

	OSSemPend(xSemCountBuffer64, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
81118960:	d0a05e17 	ldw	r2,-32392(gp)
81118964:	e0fffd04 	addi	r3,fp,-12
81118968:	180d883a 	mov	r6,r3
8111896c:	01400504 	movi	r5,20
81118970:	1009883a 	mov	r4,r2
81118974:	113eb180 	call	8113eb18 <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
81118978:	e0bffd03 	ldbu	r2,-12(fp)
8111897c:	10803fcc 	andi	r2,r2,255
81118980:	10000326 	beq	r2,zero,81118990 <bSendUART64v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
81118984:	111c0800 	call	8111c080 <vFailGetCountSemaphorexBuffer64>
		return bSuccessL;
81118988:	e0bffc17 	ldw	r2,-16(fp)
8111898c:	0000a006 	br	81118c10 <bSendUART64v2+0x2e4>
	/* ---> At this point we know that there is some space in the buffer */

	
	
	/* Need to get the Mutex that protects xBuffer64 */
	OSMutexPend(xMutexBuffer64, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
81118990:	d0a07117 	ldw	r2,-32316(gp)
81118994:	e0fffd04 	addi	r3,fp,-12
81118998:	180d883a 	mov	r6,r3
8111899c:	01400104 	movi	r5,4
811189a0:	1009883a 	mov	r4,r2
811189a4:	113cb0c0 	call	8113cb0c <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
811189a8:	e0bffd03 	ldbu	r2,-12(fp)
811189ac:	10803fcc 	andi	r2,r2,255
811189b0:	10001126 	beq	r2,zero,811189f8 <bSendUART64v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer64 that protect xBuffer64. (bSendUART64v2)\n");
811189b4:	d0a06217 	ldw	r2,-32376(gp)
811189b8:	100f883a 	mov	r7,r2
811189bc:	018013c4 	movi	r6,79
811189c0:	01400044 	movi	r5,1
811189c4:	01204574 	movhi	r4,33045
811189c8:	213af304 	addi	r4,r4,-5172
811189cc:	1121c7c0 	call	81121c7c <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer64);
811189d0:	d0a05e17 	ldw	r2,-32392(gp)
811189d4:	1009883a 	mov	r4,r2
811189d8:	113eea00 	call	8113eea0 <OSSemPost>
811189dc:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
811189e0:	e0bffd03 	ldbu	r2,-12(fp)
811189e4:	10803fcc 	andi	r2,r2,255
811189e8:	10000126 	beq	r2,zero,811189f0 <bSendUART64v2+0xc4>
			vFailSetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
811189ec:	111bf480 	call	8111bf48 <vFailSetCountSemaphorexBuffer64>
		}

		return bSuccessL;
811189f0:	e0bffc17 	ldw	r2,-16(fp)
811189f4:	00008606 	br	81118c10 <bSendUART64v2+0x2e4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_64; ucIL++)
811189f8:	e03ffb05 	stb	zero,-20(fp)
811189fc:	00004506 	br	81118b14 <bSendUART64v2+0x1e8>
	{
		if ( xInUseRetrans.b64[ucIL] == FALSE ) {
81118a00:	e0fffb03 	ldbu	r3,-20(fp)
81118a04:	00a045b4 	movhi	r2,33046
81118a08:	10bc1e04 	addi	r2,r2,-3976
81118a0c:	18c00184 	addi	r3,r3,6
81118a10:	18c7883a 	add	r3,r3,r3
81118a14:	18c7883a 	add	r3,r3,r3
81118a18:	10c5883a 	add	r2,r2,r3
81118a1c:	10800017 	ldw	r2,0(r2)
81118a20:	1000391e 	bne	r2,zero,81118b08 <bSendUART64v2+0x1dc>
			/* Clear the buffer */
			memset(xBuffer64[ucIL].buffer, 0, 64);
81118a24:	e0bffb03 	ldbu	r2,-20(fp)
81118a28:	10c01324 	muli	r3,r2,76
81118a2c:	00a04574 	movhi	r2,33045
81118a30:	1097e204 	addi	r2,r2,24456
81118a34:	1885883a 	add	r2,r3,r2
81118a38:	01801004 	movi	r6,64
81118a3c:	000b883a 	mov	r5,zero
81118a40:	1009883a 	mov	r4,r2
81118a44:	11227e00 	call	811227e0 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer64[ucIL].buffer, cBuffer, 63);
81118a48:	e0bffb03 	ldbu	r2,-20(fp)
81118a4c:	10c01324 	muli	r3,r2,76
81118a50:	00a04574 	movhi	r2,33045
81118a54:	1097e204 	addi	r2,r2,24456
81118a58:	1885883a 	add	r2,r3,r2
81118a5c:	01800fc4 	movi	r6,63
81118a60:	e17ffe17 	ldw	r5,-8(fp)
81118a64:	1009883a 	mov	r4,r2
81118a68:	11226900 	call	81122690 <memcpy>
			xBuffer64[ucIL].usiId = siIdMessage;
81118a6c:	e13ffb03 	ldbu	r4,-20(fp)
81118a70:	e0ffff0b 	ldhu	r3,-4(fp)
81118a74:	00a04574 	movhi	r2,33045
81118a78:	1097e204 	addi	r2,r2,24456
81118a7c:	21001324 	muli	r4,r4,76
81118a80:	1105883a 	add	r2,r2,r4
81118a84:	10801104 	addi	r2,r2,68
81118a88:	10c0000d 	sth	r3,0(r2)
			xBuffer64[ucIL].ucNofRetries = 0;
81118a8c:	e0fffb03 	ldbu	r3,-20(fp)
81118a90:	00a04574 	movhi	r2,33045
81118a94:	1097e204 	addi	r2,r2,24456
81118a98:	18c01324 	muli	r3,r3,76
81118a9c:	10c5883a 	add	r2,r2,r3
81118aa0:	10801204 	addi	r2,r2,72
81118aa4:	10000005 	stb	zero,0(r2)
			xBuffer64[ucIL].usiTimeOut = 0;
81118aa8:	e0fffb03 	ldbu	r3,-20(fp)
81118aac:	00a04574 	movhi	r2,33045
81118ab0:	1097e204 	addi	r2,r2,24456
81118ab4:	18c01324 	muli	r3,r3,76
81118ab8:	10c5883a 	add	r2,r2,r3
81118abc:	10801184 	addi	r2,r2,70
81118ac0:	1000000d 	sth	zero,0(r2)
			xBuffer64[ucIL].bSent = FALSE;
81118ac4:	e0fffb03 	ldbu	r3,-20(fp)
81118ac8:	00a04574 	movhi	r2,33045
81118acc:	1097e204 	addi	r2,r2,24456
81118ad0:	18c01324 	muli	r3,r3,76
81118ad4:	10c5883a 	add	r2,r2,r3
81118ad8:	10801004 	addi	r2,r2,64
81118adc:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b64[ucIL] = TRUE;
81118ae0:	e0fffb03 	ldbu	r3,-20(fp)
81118ae4:	00a045b4 	movhi	r2,33046
81118ae8:	10bc1e04 	addi	r2,r2,-3976
81118aec:	18c00184 	addi	r3,r3,6
81118af0:	18c7883a 	add	r3,r3,r3
81118af4:	18c7883a 	add	r3,r3,r3
81118af8:	10c5883a 	add	r2,r2,r3
81118afc:	00c00044 	movi	r3,1
81118b00:	10c00015 	stw	r3,0(r2)
			break;
81118b04:	00000606 	br	81118b20 <bSendUART64v2+0x1f4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_64; ucIL++)
81118b08:	e0bffb03 	ldbu	r2,-20(fp)
81118b0c:	10800044 	addi	r2,r2,1
81118b10:	e0bffb05 	stb	r2,-20(fp)
81118b14:	e0bffb03 	ldbu	r2,-20(fp)
81118b18:	10800230 	cmpltui	r2,r2,8
81118b1c:	103fb81e 	bne	r2,zero,81118a00 <__reset+0xfb0f8a00>
			break;
		}
	}


	if ( ucIL >= N_64 ) {
81118b20:	e0bffb03 	ldbu	r2,-20(fp)
81118b24:	10800230 	cmpltui	r2,r2,8
81118b28:	1000091e 	bne	r2,zero,81118b50 <bSendUART64v2+0x224>
		ucErrorCode = OSSemPost(xSemCountBuffer64);
81118b2c:	d0a05e17 	ldw	r2,-32392(gp)
81118b30:	1009883a 	mov	r4,r2
81118b34:	113eea00 	call	8113eea0 <OSSemPost>
81118b38:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer64);
81118b3c:	d0a07117 	ldw	r2,-32316(gp)
81118b40:	1009883a 	mov	r4,r2
81118b44:	113d0b00 	call	8113d0b0 <OSMutexPost>
		return bSuccessL;
81118b48:	e0bffc17 	ldw	r2,-16(fp)
81118b4c:	00003006 	br	81118c10 <bSendUART64v2+0x2e4>
	}

	bSuccessL = TRUE;
81118b50:	00800044 	movi	r2,1
81118b54:	e0bffc15 	stw	r2,-16(fp)
	SemCount64--; /* Sure that you get the semaphore */
81118b58:	d0a07503 	ldbu	r2,-32300(gp)
81118b5c:	10bfffc4 	addi	r2,r2,-1
81118b60:	d0a07505 	stb	r2,-32300(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
81118b64:	d0a07417 	ldw	r2,-32304(gp)
81118b68:	e0fffd04 	addi	r3,fp,-12
81118b6c:	180d883a 	mov	r6,r3
81118b70:	01400084 	movi	r5,2
81118b74:	1009883a 	mov	r4,r2
81118b78:	113cb0c0 	call	8113cb0c <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81118b7c:	e0bffd03 	ldbu	r2,-12(fp)
81118b80:	10803fcc 	andi	r2,r2,255
81118b84:	10000c26 	beq	r2,zero,81118bb8 <bSendUART64v2+0x28c>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART64v2)\n");
81118b88:	d0a06217 	ldw	r2,-32376(gp)
81118b8c:	100f883a 	mov	r7,r2
81118b90:	01801bc4 	movi	r6,111
81118b94:	01400044 	movi	r5,1
81118b98:	01204574 	movhi	r4,33045
81118b9c:	213b0704 	addi	r4,r4,-5092
81118ba0:	1121c7c0 	call	81121c7c <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer64 */
		OSMutexPost(xMutexBuffer64); /* Free the Mutex after use the xBuffer64 */
81118ba4:	d0a07117 	ldw	r2,-32316(gp)
81118ba8:	1009883a 	mov	r4,r2
81118bac:	113d0b00 	call	8113d0b0 <OSMutexPost>
		return bSuccessL;
81118bb0:	e0bffc17 	ldw	r2,-16(fp)
81118bb4:	00001606 	br	81118c10 <bSendUART64v2+0x2e4>


	/* ---> At this point we have all resources to send the message */


	puts(xBuffer64[ucIL].buffer);
81118bb8:	e0bffb03 	ldbu	r2,-20(fp)
81118bbc:	10c01324 	muli	r3,r2,76
81118bc0:	00a04574 	movhi	r2,33045
81118bc4:	1097e204 	addi	r2,r2,24456
81118bc8:	1885883a 	add	r2,r3,r2
81118bcc:	1009883a 	mov	r4,r2
81118bd0:	1122c2c0 	call	81122c2c <puts>
	xBuffer64[ucIL].bSent = TRUE;
81118bd4:	e0fffb03 	ldbu	r3,-20(fp)
81118bd8:	00a04574 	movhi	r2,33045
81118bdc:	1097e204 	addi	r2,r2,24456
81118be0:	18c01324 	muli	r3,r3,76
81118be4:	10c5883a 	add	r2,r2,r3
81118be8:	10801004 	addi	r2,r2,64
81118bec:	00c00044 	movi	r3,1
81118bf0:	10c00015 	stw	r3,0(r2)


	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */
	OSMutexPost(xTxUARTMutex);
81118bf4:	d0a07417 	ldw	r2,-32304(gp)
81118bf8:	1009883a 	mov	r4,r2
81118bfc:	113d0b00 	call	8113d0b0 <OSMutexPost>
	OSMutexPost(xMutexBuffer64);
81118c00:	d0a07117 	ldw	r2,-32316(gp)
81118c04:	1009883a 	mov	r4,r2
81118c08:	113d0b00 	call	8113d0b0 <OSMutexPost>

	return bSuccessL;
81118c0c:	e0bffc17 	ldw	r2,-16(fp)
}
81118c10:	e037883a 	mov	sp,fp
81118c14:	dfc00117 	ldw	ra,4(sp)
81118c18:	df000017 	ldw	fp,0(sp)
81118c1c:	dec00204 	addi	sp,sp,8
81118c20:	f800283a 	ret

81118c24 <bSendUART32v2>:



/* Make sure that there is only 31 characters to send */
/* Always, ALWAYS send only an char[32] that you first did a memset(cBuffer,0,32), before put some string on it. */
bool bSendUART32v2 ( char *cBuffer, short int siIdMessage ) {
81118c24:	defff904 	addi	sp,sp,-28
81118c28:	de00012e 	bgeu	sp,et,81118c30 <bSendUART32v2+0xc>
81118c2c:	003b68fa 	trap	3
81118c30:	dfc00615 	stw	ra,24(sp)
81118c34:	df000515 	stw	fp,20(sp)
81118c38:	df000504 	addi	fp,sp,20
81118c3c:	e13ffe15 	stw	r4,-8(fp)
81118c40:	2805883a 	mov	r2,r5
81118c44:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;
81118c48:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
81118c4c:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
81118c50:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
81118c54:	e03ffc15 	stw	zero,-16(fp)
	
	OSSemPend(xSemCountBuffer32, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
81118c58:	d0a06f17 	ldw	r2,-32324(gp)
81118c5c:	e0fffd04 	addi	r3,fp,-12
81118c60:	180d883a 	mov	r6,r3
81118c64:	01400504 	movi	r5,20
81118c68:	1009883a 	mov	r4,r2
81118c6c:	113eb180 	call	8113eb18 <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
81118c70:	e0bffd03 	ldbu	r2,-12(fp)
81118c74:	10803fcc 	andi	r2,r2,255
81118c78:	10000326 	beq	r2,zero,81118c88 <bSendUART32v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
81118c7c:	111c0e80 	call	8111c0e8 <vFailGetCountSemaphorexBuffer32>
		return bSuccessL;
81118c80:	e0bffc17 	ldw	r2,-16(fp)
81118c84:	0000a006 	br	81118f08 <bSendUART32v2+0x2e4>

	/* ---> At this point we know that there is some space in the buffer */


	/* Need to get the Mutex that protects xBuffer32 */
	OSMutexPend(xMutexBuffer32, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
81118c88:	d0a06c17 	ldw	r2,-32336(gp)
81118c8c:	e0fffd04 	addi	r3,fp,-12
81118c90:	180d883a 	mov	r6,r3
81118c94:	01400104 	movi	r5,4
81118c98:	1009883a 	mov	r4,r2
81118c9c:	113cb0c0 	call	8113cb0c <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81118ca0:	e0bffd03 	ldbu	r2,-12(fp)
81118ca4:	10803fcc 	andi	r2,r2,255
81118ca8:	10001126 	beq	r2,zero,81118cf0 <bSendUART32v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer32 that protect xBuffer32. (bSendUART32v2)\n");
81118cac:	d0a06217 	ldw	r2,-32376(gp)
81118cb0:	100f883a 	mov	r7,r2
81118cb4:	018013c4 	movi	r6,79
81118cb8:	01400044 	movi	r5,1
81118cbc:	01204574 	movhi	r4,33045
81118cc0:	213b2304 	addi	r4,r4,-4980
81118cc4:	1121c7c0 	call	81121c7c <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer32);
81118cc8:	d0a06f17 	ldw	r2,-32324(gp)
81118ccc:	1009883a 	mov	r4,r2
81118cd0:	113eea00 	call	8113eea0 <OSSemPost>
81118cd4:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
81118cd8:	e0bffd03 	ldbu	r2,-12(fp)
81118cdc:	10803fcc 	andi	r2,r2,255
81118ce0:	10000126 	beq	r2,zero,81118ce8 <bSendUART32v2+0xc4>
			vFailSetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
81118ce4:	111bee00 	call	8111bee0 <vFailSetCountSemaphorexBuffer32>
		}

		return bSuccessL;
81118ce8:	e0bffc17 	ldw	r2,-16(fp)
81118cec:	00008606 	br	81118f08 <bSendUART32v2+0x2e4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_32; ucIL++)
81118cf0:	e03ffb05 	stb	zero,-20(fp)
81118cf4:	00004506 	br	81118e0c <bSendUART32v2+0x1e8>
	{
		if ( xInUseRetrans.b32[ucIL] == FALSE ) {
81118cf8:	e0fffb03 	ldbu	r3,-20(fp)
81118cfc:	00a045b4 	movhi	r2,33046
81118d00:	10bc1e04 	addi	r2,r2,-3976
81118d04:	18c00384 	addi	r3,r3,14
81118d08:	18c7883a 	add	r3,r3,r3
81118d0c:	18c7883a 	add	r3,r3,r3
81118d10:	10c5883a 	add	r2,r2,r3
81118d14:	10800017 	ldw	r2,0(r2)
81118d18:	1000391e 	bne	r2,zero,81118e00 <bSendUART32v2+0x1dc>
			/* Clear the buffer */
			memset(xBuffer32[ucIL].buffer, 0, 32);
81118d1c:	e0bffb03 	ldbu	r2,-20(fp)
81118d20:	10c00b24 	muli	r3,r2,44
81118d24:	00a045b4 	movhi	r2,33046
81118d28:	10a99e04 	addi	r2,r2,-22920
81118d2c:	1885883a 	add	r2,r3,r2
81118d30:	01800804 	movi	r6,32
81118d34:	000b883a 	mov	r5,zero
81118d38:	1009883a 	mov	r4,r2
81118d3c:	11227e00 	call	811227e0 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer32[ucIL].buffer, cBuffer, 31);
81118d40:	e0bffb03 	ldbu	r2,-20(fp)
81118d44:	10c00b24 	muli	r3,r2,44
81118d48:	00a045b4 	movhi	r2,33046
81118d4c:	10a99e04 	addi	r2,r2,-22920
81118d50:	1885883a 	add	r2,r3,r2
81118d54:	018007c4 	movi	r6,31
81118d58:	e17ffe17 	ldw	r5,-8(fp)
81118d5c:	1009883a 	mov	r4,r2
81118d60:	11226900 	call	81122690 <memcpy>
			xBuffer32[ucIL].usiId = siIdMessage;
81118d64:	e13ffb03 	ldbu	r4,-20(fp)
81118d68:	e0ffff0b 	ldhu	r3,-4(fp)
81118d6c:	00a045b4 	movhi	r2,33046
81118d70:	10a99e04 	addi	r2,r2,-22920
81118d74:	21000b24 	muli	r4,r4,44
81118d78:	1105883a 	add	r2,r2,r4
81118d7c:	10800904 	addi	r2,r2,36
81118d80:	10c0000d 	sth	r3,0(r2)
			xBuffer32[ucIL].ucNofRetries = 0;
81118d84:	e0fffb03 	ldbu	r3,-20(fp)
81118d88:	00a045b4 	movhi	r2,33046
81118d8c:	10a99e04 	addi	r2,r2,-22920
81118d90:	18c00b24 	muli	r3,r3,44
81118d94:	10c5883a 	add	r2,r2,r3
81118d98:	10800a04 	addi	r2,r2,40
81118d9c:	10000005 	stb	zero,0(r2)
			xBuffer32[ucIL].usiTimeOut = 0;
81118da0:	e0fffb03 	ldbu	r3,-20(fp)
81118da4:	00a045b4 	movhi	r2,33046
81118da8:	10a99e04 	addi	r2,r2,-22920
81118dac:	18c00b24 	muli	r3,r3,44
81118db0:	10c5883a 	add	r2,r2,r3
81118db4:	10800984 	addi	r2,r2,38
81118db8:	1000000d 	sth	zero,0(r2)
			xBuffer32[ucIL].bSent = FALSE;
81118dbc:	e0fffb03 	ldbu	r3,-20(fp)
81118dc0:	00a045b4 	movhi	r2,33046
81118dc4:	10a99e04 	addi	r2,r2,-22920
81118dc8:	18c00b24 	muli	r3,r3,44
81118dcc:	10c5883a 	add	r2,r2,r3
81118dd0:	10800804 	addi	r2,r2,32
81118dd4:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b32[ucIL] = TRUE;
81118dd8:	e0fffb03 	ldbu	r3,-20(fp)
81118ddc:	00a045b4 	movhi	r2,33046
81118de0:	10bc1e04 	addi	r2,r2,-3976
81118de4:	18c00384 	addi	r3,r3,14
81118de8:	18c7883a 	add	r3,r3,r3
81118dec:	18c7883a 	add	r3,r3,r3
81118df0:	10c5883a 	add	r2,r2,r3
81118df4:	00c00044 	movi	r3,1
81118df8:	10c00015 	stw	r3,0(r2)
			break;
81118dfc:	00000606 	br	81118e18 <bSendUART32v2+0x1f4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_32; ucIL++)
81118e00:	e0bffb03 	ldbu	r2,-20(fp)
81118e04:	10800044 	addi	r2,r2,1
81118e08:	e0bffb05 	stb	r2,-20(fp)
81118e0c:	e0bffb03 	ldbu	r2,-20(fp)
81118e10:	10800230 	cmpltui	r2,r2,8
81118e14:	103fb81e 	bne	r2,zero,81118cf8 <__reset+0xfb0f8cf8>
			xInUseRetrans.b32[ucIL] = TRUE;
			break;
		}
	}	

	if ( ucIL >= N_32 ) {
81118e18:	e0bffb03 	ldbu	r2,-20(fp)
81118e1c:	10800230 	cmpltui	r2,r2,8
81118e20:	1000091e 	bne	r2,zero,81118e48 <bSendUART32v2+0x224>
		ucErrorCode = OSSemPost(xSemCountBuffer32);
81118e24:	d0a06f17 	ldw	r2,-32324(gp)
81118e28:	1009883a 	mov	r4,r2
81118e2c:	113eea00 	call	8113eea0 <OSSemPost>
81118e30:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer32);
81118e34:	d0a06c17 	ldw	r2,-32336(gp)
81118e38:	1009883a 	mov	r4,r2
81118e3c:	113d0b00 	call	8113d0b0 <OSMutexPost>
		return bSuccessL;
81118e40:	e0bffc17 	ldw	r2,-16(fp)
81118e44:	00003006 	br	81118f08 <bSendUART32v2+0x2e4>
	}
	
	bSuccessL = TRUE;
81118e48:	00800044 	movi	r2,1
81118e4c:	e0bffc15 	stw	r2,-16(fp)
	SemCount32--; /* Sure that you get the semaphore */
81118e50:	d0a06883 	ldbu	r2,-32350(gp)
81118e54:	10bfffc4 	addi	r2,r2,-1
81118e58:	d0a06885 	stb	r2,-32350(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
81118e5c:	d0a07417 	ldw	r2,-32304(gp)
81118e60:	e0fffd04 	addi	r3,fp,-12
81118e64:	180d883a 	mov	r6,r3
81118e68:	01400084 	movi	r5,2
81118e6c:	1009883a 	mov	r4,r2
81118e70:	113cb0c0 	call	8113cb0c <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81118e74:	e0bffd03 	ldbu	r2,-12(fp)
81118e78:	10803fcc 	andi	r2,r2,255
81118e7c:	10000c26 	beq	r2,zero,81118eb0 <bSendUART32v2+0x28c>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART32v2)\n");
81118e80:	d0a06217 	ldw	r2,-32376(gp)
81118e84:	100f883a 	mov	r7,r2
81118e88:	01801bc4 	movi	r6,111
81118e8c:	01400044 	movi	r5,1
81118e90:	01204574 	movhi	r4,33045
81118e94:	213b3704 	addi	r4,r4,-4900
81118e98:	1121c7c0 	call	81121c7c <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer64 */
		OSMutexPost(xMutexBuffer32); /* Free the Mutex after use the xMutexBuffer32 */
81118e9c:	d0a06c17 	ldw	r2,-32336(gp)
81118ea0:	1009883a 	mov	r4,r2
81118ea4:	113d0b00 	call	8113d0b0 <OSMutexPost>
		return bSuccessL;
81118ea8:	e0bffc17 	ldw	r2,-16(fp)
81118eac:	00001606 	br	81118f08 <bSendUART32v2+0x2e4>
	}


	/* ---> At this point we have all resources to send the message */

	puts(xBuffer32[ucIL].buffer);
81118eb0:	e0bffb03 	ldbu	r2,-20(fp)
81118eb4:	10c00b24 	muli	r3,r2,44
81118eb8:	00a045b4 	movhi	r2,33046
81118ebc:	10a99e04 	addi	r2,r2,-22920
81118ec0:	1885883a 	add	r2,r3,r2
81118ec4:	1009883a 	mov	r4,r2
81118ec8:	1122c2c0 	call	81122c2c <puts>
	xBuffer32[ucIL].bSent = TRUE;
81118ecc:	e0fffb03 	ldbu	r3,-20(fp)
81118ed0:	00a045b4 	movhi	r2,33046
81118ed4:	10a99e04 	addi	r2,r2,-22920
81118ed8:	18c00b24 	muli	r3,r3,44
81118edc:	10c5883a 	add	r2,r2,r3
81118ee0:	10800804 	addi	r2,r2,32
81118ee4:	00c00044 	movi	r3,1
81118ee8:	10c00015 	stw	r3,0(r2)

	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */


	OSMutexPost(xTxUARTMutex);
81118eec:	d0a07417 	ldw	r2,-32304(gp)
81118ef0:	1009883a 	mov	r4,r2
81118ef4:	113d0b00 	call	8113d0b0 <OSMutexPost>
	OSMutexPost(xMutexBuffer32);
81118ef8:	d0a06c17 	ldw	r2,-32336(gp)
81118efc:	1009883a 	mov	r4,r2
81118f00:	113d0b00 	call	8113d0b0 <OSMutexPost>

	return bSuccessL;
81118f04:	e0bffc17 	ldw	r2,-16(fp)
}
81118f08:	e037883a 	mov	sp,fp
81118f0c:	dfc00117 	ldw	ra,4(sp)
81118f10:	df000017 	ldw	fp,0(sp)
81118f14:	dec00204 	addi	sp,sp,8
81118f18:	f800283a 	ret

81118f1c <vSendEthConf>:


void vSendEthConf ( void ) {
81118f1c:	deffc304 	addi	sp,sp,-244
81118f20:	de00012e 	bgeu	sp,et,81118f28 <vSendEthConf+0xc>
81118f24:	003b68fa 	trap	3
81118f28:	dfc03c15 	stw	ra,240(sp)
81118f2c:	df003b15 	stw	fp,236(sp)
81118f30:	dd403a15 	stw	r21,232(sp)
81118f34:	dd003915 	stw	r20,228(sp)
81118f38:	dcc03815 	stw	r19,224(sp)
81118f3c:	dc803715 	stw	r18,220(sp)
81118f40:	dc403615 	stw	r17,216(sp)
81118f44:	dc003515 	stw	r16,212(sp)
81118f48:	df003b04 	addi	fp,sp,236
    char cBufferETH[128] = "";
81118f4c:	e03fd98d 	sth	zero,-154(fp)
81118f50:	e03fda0d 	sth	zero,-152(fp)
81118f54:	e0bfda84 	addi	r2,fp,-150
81118f58:	00c01f04 	movi	r3,124
81118f5c:	180d883a 	mov	r6,r3
81118f60:	000b883a 	mov	r5,zero
81118f64:	1009883a 	mov	r4,r2
81118f68:	11227e00 	call	811227e0 <memset>
    unsigned char crc = 0;
81118f6c:	e03fd705 	stb	zero,-164(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81118f70:	e03fd815 	stw	zero,-160(fp)

    usiIdCMDLocal = usiGetIdCMD();
81118f74:	11194dc0 	call	811194dc <usiGetIdCMD>
81118f78:	e0bfd90d 	sth	r2,-156(fp)

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118f7c:	e57fd90b 	ldhu	r21,-156(fp)
81118f80:	00a045b4 	movhi	r2,33046
81118f84:	109c1104 	addi	r2,r2,28740
81118f88:	10c00617 	ldw	r3,24(r2)
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81118f8c:	00a045b4 	movhi	r2,33046
81118f90:	109c1104 	addi	r2,r2,28740
81118f94:	10800003 	ldbu	r2,0(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118f98:	11003fcc 	andi	r4,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81118f9c:	00a045b4 	movhi	r2,33046
81118fa0:	109c1104 	addi	r2,r2,28740
81118fa4:	10800043 	ldbu	r2,1(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118fa8:	11403fcc 	andi	r5,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81118fac:	00a045b4 	movhi	r2,33046
81118fb0:	109c1104 	addi	r2,r2,28740
81118fb4:	10800083 	ldbu	r2,2(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118fb8:	11803fcc 	andi	r6,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81118fbc:	00a045b4 	movhi	r2,33046
81118fc0:	109c1104 	addi	r2,r2,28740
81118fc4:	108000c3 	ldbu	r2,3(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118fc8:	11c03fcc 	andi	r7,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81118fcc:	00a045b4 	movhi	r2,33046
81118fd0:	109c1104 	addi	r2,r2,28740
81118fd4:	10800203 	ldbu	r2,8(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118fd8:	12003fcc 	andi	r8,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81118fdc:	00a045b4 	movhi	r2,33046
81118fe0:	109c1104 	addi	r2,r2,28740
81118fe4:	10800243 	ldbu	r2,9(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118fe8:	12403fcc 	andi	r9,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81118fec:	00a045b4 	movhi	r2,33046
81118ff0:	109c1104 	addi	r2,r2,28740
81118ff4:	10800283 	ldbu	r2,10(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118ff8:	12803fcc 	andi	r10,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81118ffc:	00a045b4 	movhi	r2,33046
81119000:	109c1104 	addi	r2,r2,28740
81119004:	108002c3 	ldbu	r2,11(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119008:	12c03fcc 	andi	r11,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
8111900c:	00a045b4 	movhi	r2,33046
81119010:	109c1104 	addi	r2,r2,28740
81119014:	10800103 	ldbu	r2,4(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119018:	13003fcc 	andi	r12,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
8111901c:	00a045b4 	movhi	r2,33046
81119020:	109c1104 	addi	r2,r2,28740
81119024:	10800143 	ldbu	r2,5(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119028:	13403fcc 	andi	r13,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
8111902c:	00a045b4 	movhi	r2,33046
81119030:	109c1104 	addi	r2,r2,28740
81119034:	10800183 	ldbu	r2,6(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119038:	13803fcc 	andi	r14,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
8111903c:	00a045b4 	movhi	r2,33046
81119040:	109c1104 	addi	r2,r2,28740
81119044:	108001c3 	ldbu	r2,7(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119048:	13c03fcc 	andi	r15,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
8111904c:	00a045b4 	movhi	r2,33046
81119050:	109c1104 	addi	r2,r2,28740
81119054:	10800303 	ldbu	r2,12(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119058:	14003fcc 	andi	r16,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
8111905c:	00a045b4 	movhi	r2,33046
81119060:	109c1104 	addi	r2,r2,28740
81119064:	10800343 	ldbu	r2,13(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119068:	14403fcc 	andi	r17,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
8111906c:	00a045b4 	movhi	r2,33046
81119070:	109c1104 	addi	r2,r2,28740
81119074:	10800383 	ldbu	r2,14(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119078:	14803fcc 	andi	r18,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
8111907c:	00a045b4 	movhi	r2,33046
81119080:	109c1104 	addi	r2,r2,28740
81119084:	108003c3 	ldbu	r2,15(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119088:	14c03fcc 	andi	r19,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
                        xConfEth.siPortPUS);
8111908c:	00a045b4 	movhi	r2,33046
81119090:	109c1104 	addi	r2,r2,28740
81119094:	1080058b 	ldhu	r2,22(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119098:	10bfffcc 	andi	r2,r2,65535
8111909c:	e53fd984 	addi	r20,fp,-154
811190a0:	d8801115 	stw	r2,68(sp)
811190a4:	dcc01015 	stw	r19,64(sp)
811190a8:	dc800f15 	stw	r18,60(sp)
811190ac:	dc400e15 	stw	r17,56(sp)
811190b0:	dc000d15 	stw	r16,52(sp)
811190b4:	dbc00c15 	stw	r15,48(sp)
811190b8:	db800b15 	stw	r14,44(sp)
811190bc:	db400a15 	stw	r13,40(sp)
811190c0:	db000915 	stw	r12,36(sp)
811190c4:	dac00815 	stw	r11,32(sp)
811190c8:	da800715 	stw	r10,28(sp)
811190cc:	da400615 	stw	r9,24(sp)
811190d0:	da000515 	stw	r8,20(sp)
811190d4:	d9c00415 	stw	r7,16(sp)
811190d8:	d9800315 	stw	r6,12(sp)
811190dc:	d9400215 	stw	r5,8(sp)
811190e0:	d9000115 	stw	r4,4(sp)
811190e4:	d8c00015 	stw	r3,0(sp)
811190e8:	a80f883a 	mov	r7,r21
811190ec:	018010c4 	movi	r6,67
811190f0:	01604574 	movhi	r5,33045
811190f4:	297b5304 	addi	r5,r5,-4788
811190f8:	a009883a 	mov	r4,r20
811190fc:	1122f700 	call	81122f70 <sprintf>
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
                        xConfEth.siPortPUS);
    crc = ucCrc8wInit( cBufferETH , strlen(cBufferETH));
81119100:	e0bfd984 	addi	r2,fp,-154
81119104:	1009883a 	mov	r4,r2
81119108:	11231840 	call	81123184 <strlen>
8111910c:	1007883a 	mov	r3,r2
81119110:	e0bfd984 	addi	r2,fp,-154
81119114:	180b883a 	mov	r5,r3
81119118:	1009883a 	mov	r4,r2
8111911c:	111b7200 	call	8111b720 <ucCrc8wInit>
81119120:	e0bfd705 	stb	r2,-164(fp)
    sprintf(cBufferETH, "%s|%hhu;", cBufferETH, crc );
81119124:	e13fd703 	ldbu	r4,-164(fp)
81119128:	e0ffd984 	addi	r3,fp,-154
8111912c:	e0bfd984 	addi	r2,fp,-154
81119130:	200f883a 	mov	r7,r4
81119134:	180d883a 	mov	r6,r3
81119138:	01604574 	movhi	r5,33045
8111913c:	297b6b04 	addi	r5,r5,-4692
81119140:	1009883a 	mov	r4,r2
81119144:	1122f700 	call	81122f70 <sprintf>

	bSuccees = bSendUART128v2(cBufferETH, usiIdCMDLocal);
81119148:	e0bfd90b 	ldhu	r2,-156(fp)
8111914c:	10ffffcc 	andi	r3,r2,65535
81119150:	18e0001c 	xori	r3,r3,32768
81119154:	18e00004 	addi	r3,r3,-32768
81119158:	e0bfd984 	addi	r2,fp,-154
8111915c:	180b883a 	mov	r5,r3
81119160:	1009883a 	mov	r4,r2
81119164:	111863c0 	call	8111863c <bSendUART128v2>
81119168:	e0bfd815 	stw	r2,-160(fp)

	if ( bSuccees != TRUE ) {
8111916c:	e0bfd817 	ldw	r2,-160(fp)
81119170:	10800060 	cmpeqi	r2,r2,1
81119174:	1000011e 	bne	r2,zero,8111917c <vSendEthConf+0x260>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendEthConfUART();
81119178:	111c2f00 	call	8111c2f0 <vCouldNotSendEthConfUART>
	}
}
8111917c:	0001883a 	nop
81119180:	e6fffa04 	addi	sp,fp,-24
81119184:	dfc00717 	ldw	ra,28(sp)
81119188:	df000617 	ldw	fp,24(sp)
8111918c:	dd400517 	ldw	r21,20(sp)
81119190:	dd000417 	ldw	r20,16(sp)
81119194:	dcc00317 	ldw	r19,12(sp)
81119198:	dc800217 	ldw	r18,8(sp)
8111919c:	dc400117 	ldw	r17,4(sp)
811191a0:	dc000017 	ldw	r16,0(sp)
811191a4:	dec00804 	addi	sp,sp,32
811191a8:	f800283a 	ret

811191ac <vSendTurnOff>:


void vSendTurnOff ( void ) {
811191ac:	defff304 	addi	sp,sp,-52
811191b0:	de00012e 	bgeu	sp,et,811191b8 <vSendTurnOff+0xc>
811191b4:	003b68fa 	trap	3
811191b8:	dfc00c15 	stw	ra,48(sp)
811191bc:	df000b15 	stw	fp,44(sp)
811191c0:	df000b04 	addi	fp,sp,44
    char cBufferTurnOff[32] = "";
811191c4:	e03ff78d 	sth	zero,-34(fp)
811191c8:	e03ff80d 	sth	zero,-32(fp)
811191cc:	e03ff88d 	sth	zero,-30(fp)
811191d0:	e03ff90d 	sth	zero,-28(fp)
811191d4:	e03ff98d 	sth	zero,-26(fp)
811191d8:	e03ffa0d 	sth	zero,-24(fp)
811191dc:	e03ffa8d 	sth	zero,-22(fp)
811191e0:	e03ffb0d 	sth	zero,-20(fp)
811191e4:	e03ffb8d 	sth	zero,-18(fp)
811191e8:	e03ffc0d 	sth	zero,-16(fp)
811191ec:	e03ffc8d 	sth	zero,-14(fp)
811191f0:	e03ffd0d 	sth	zero,-12(fp)
811191f4:	e03ffd8d 	sth	zero,-10(fp)
811191f8:	e03ffe0d 	sth	zero,-8(fp)
811191fc:	e03ffe8d 	sth	zero,-6(fp)
81119200:	e03fff0d 	sth	zero,-4(fp)
    unsigned char crc = 0;
81119204:	e03ff505 	stb	zero,-44(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81119208:	e03ff615 	stw	zero,-40(fp)

    usiIdCMDLocal = usiGetIdCMD();
8111920c:	11194dc0 	call	811194dc <usiGetIdCMD>
81119210:	e0bff70d 	sth	r2,-36(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferTurnOff, TURNOFF_SPRINTF, usiIdCMDLocal);
81119214:	e0fff70b 	ldhu	r3,-36(fp)
81119218:	e0bff784 	addi	r2,fp,-34
8111921c:	180d883a 	mov	r6,r3
81119220:	01604574 	movhi	r5,33045
81119224:	297b6e04 	addi	r5,r5,-4680
81119228:	1009883a 	mov	r4,r2
8111922c:	1122f700 	call	81122f70 <sprintf>
    crc = ucCrc8wInit( cBufferTurnOff , strlen(cBufferTurnOff));
81119230:	e0bff784 	addi	r2,fp,-34
81119234:	1009883a 	mov	r4,r2
81119238:	11231840 	call	81123184 <strlen>
8111923c:	1007883a 	mov	r3,r2
81119240:	e0bff784 	addi	r2,fp,-34
81119244:	180b883a 	mov	r5,r3
81119248:	1009883a 	mov	r4,r2
8111924c:	111b7200 	call	8111b720 <ucCrc8wInit>
81119250:	e0bff505 	stb	r2,-44(fp)
    sprintf(cBufferTurnOff, "%s|%hhu;", cBufferTurnOff, crc );
81119254:	e13ff503 	ldbu	r4,-44(fp)
81119258:	e0fff784 	addi	r3,fp,-34
8111925c:	e0bff784 	addi	r2,fp,-34
81119260:	200f883a 	mov	r7,r4
81119264:	180d883a 	mov	r6,r3
81119268:	01604574 	movhi	r5,33045
8111926c:	297b6b04 	addi	r5,r5,-4692
81119270:	1009883a 	mov	r4,r2
81119274:	1122f700 	call	81122f70 <sprintf>

	bSuccees = bSendUART32v2(cBufferTurnOff, usiIdCMDLocal);
81119278:	e0bff70b 	ldhu	r2,-36(fp)
8111927c:	10ffffcc 	andi	r3,r2,65535
81119280:	18e0001c 	xori	r3,r3,32768
81119284:	18e00004 	addi	r3,r3,-32768
81119288:	e0bff784 	addi	r2,fp,-34
8111928c:	180b883a 	mov	r5,r3
81119290:	1009883a 	mov	r4,r2
81119294:	1118c240 	call	81118c24 <bSendUART32v2>
81119298:	e0bff615 	stw	r2,-40(fp)

	if ( bSuccees != TRUE ) {
8111929c:	e0bff617 	ldw	r2,-40(fp)
811192a0:	10800060 	cmpeqi	r2,r2,1
811192a4:	1000011e 	bne	r2,zero,811192ac <vSendTurnOff+0x100>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTurnOff();
811192a8:	111c9980 	call	8111c998 <vCouldNotSendTurnOff>
	}
}
811192ac:	0001883a 	nop
811192b0:	e037883a 	mov	sp,fp
811192b4:	dfc00117 	ldw	ra,4(sp)
811192b8:	df000017 	ldw	fp,0(sp)
811192bc:	dec00204 	addi	sp,sp,8
811192c0:	f800283a 	ret

811192c4 <vSendReset>:

void vSendReset ( void ) {
811192c4:	defff304 	addi	sp,sp,-52
811192c8:	de00012e 	bgeu	sp,et,811192d0 <vSendReset+0xc>
811192cc:	003b68fa 	trap	3
811192d0:	dfc00c15 	stw	ra,48(sp)
811192d4:	df000b15 	stw	fp,44(sp)
811192d8:	df000b04 	addi	fp,sp,44
    char cBufferTurnOff[32] = "";
811192dc:	e03ff78d 	sth	zero,-34(fp)
811192e0:	e03ff80d 	sth	zero,-32(fp)
811192e4:	e03ff88d 	sth	zero,-30(fp)
811192e8:	e03ff90d 	sth	zero,-28(fp)
811192ec:	e03ff98d 	sth	zero,-26(fp)
811192f0:	e03ffa0d 	sth	zero,-24(fp)
811192f4:	e03ffa8d 	sth	zero,-22(fp)
811192f8:	e03ffb0d 	sth	zero,-20(fp)
811192fc:	e03ffb8d 	sth	zero,-18(fp)
81119300:	e03ffc0d 	sth	zero,-16(fp)
81119304:	e03ffc8d 	sth	zero,-14(fp)
81119308:	e03ffd0d 	sth	zero,-12(fp)
8111930c:	e03ffd8d 	sth	zero,-10(fp)
81119310:	e03ffe0d 	sth	zero,-8(fp)
81119314:	e03ffe8d 	sth	zero,-6(fp)
81119318:	e03fff0d 	sth	zero,-4(fp)
    unsigned char crc = 0;
8111931c:	e03ff505 	stb	zero,-44(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81119320:	e03ff615 	stw	zero,-40(fp)

    usiIdCMDLocal = usiGetIdCMD();
81119324:	11194dc0 	call	811194dc <usiGetIdCMD>
81119328:	e0bff70d 	sth	r2,-36(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferTurnOff, RESET_SPRINTF, usiIdCMDLocal);
8111932c:	e0fff70b 	ldhu	r3,-36(fp)
81119330:	e0bff784 	addi	r2,fp,-34
81119334:	180d883a 	mov	r6,r3
81119338:	01604574 	movhi	r5,33045
8111933c:	297b7004 	addi	r5,r5,-4672
81119340:	1009883a 	mov	r4,r2
81119344:	1122f700 	call	81122f70 <sprintf>
    crc = ucCrc8wInit( cBufferTurnOff , strlen(cBufferTurnOff));
81119348:	e0bff784 	addi	r2,fp,-34
8111934c:	1009883a 	mov	r4,r2
81119350:	11231840 	call	81123184 <strlen>
81119354:	1007883a 	mov	r3,r2
81119358:	e0bff784 	addi	r2,fp,-34
8111935c:	180b883a 	mov	r5,r3
81119360:	1009883a 	mov	r4,r2
81119364:	111b7200 	call	8111b720 <ucCrc8wInit>
81119368:	e0bff505 	stb	r2,-44(fp)
    sprintf(cBufferTurnOff, "%s|%hhu;", cBufferTurnOff, crc );
8111936c:	e13ff503 	ldbu	r4,-44(fp)
81119370:	e0fff784 	addi	r3,fp,-34
81119374:	e0bff784 	addi	r2,fp,-34
81119378:	200f883a 	mov	r7,r4
8111937c:	180d883a 	mov	r6,r3
81119380:	01604574 	movhi	r5,33045
81119384:	297b6b04 	addi	r5,r5,-4692
81119388:	1009883a 	mov	r4,r2
8111938c:	1122f700 	call	81122f70 <sprintf>

	bSuccees = bSendUART32v2(cBufferTurnOff, usiIdCMDLocal);
81119390:	e0bff70b 	ldhu	r2,-36(fp)
81119394:	10ffffcc 	andi	r3,r2,65535
81119398:	18e0001c 	xori	r3,r3,32768
8111939c:	18e00004 	addi	r3,r3,-32768
811193a0:	e0bff784 	addi	r2,fp,-34
811193a4:	180b883a 	mov	r5,r3
811193a8:	1009883a 	mov	r4,r2
811193ac:	1118c240 	call	81118c24 <bSendUART32v2>
811193b0:	e0bff615 	stw	r2,-40(fp)

	if ( bSuccees != TRUE ) {
811193b4:	e0bff617 	ldw	r2,-40(fp)
811193b8:	10800060 	cmpeqi	r2,r2,1
811193bc:	1000011e 	bne	r2,zero,811193c4 <vSendReset+0x100>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTurnOff();
811193c0:	111c9980 	call	8111c998 <vCouldNotSendTurnOff>
	}
}
811193c4:	0001883a 	nop
811193c8:	e037883a 	mov	sp,fp
811193cc:	dfc00117 	ldw	ra,4(sp)
811193d0:	df000017 	ldw	fp,0(sp)
811193d4:	dec00204 	addi	sp,sp,8
811193d8:	f800283a 	ret

811193dc <vSendLog>:

void vSendLog ( const char * cDataIn ) {
811193dc:	deffda04 	addi	sp,sp,-152
811193e0:	de00012e 	bgeu	sp,et,811193e8 <vSendLog+0xc>
811193e4:	003b68fa 	trap	3
811193e8:	dfc02515 	stw	ra,148(sp)
811193ec:	df002415 	stw	fp,144(sp)
811193f0:	df002404 	addi	fp,sp,144
811193f4:	e13fff15 	stw	r4,-4(fp)
    char cBufferLog[128] = "";
811193f8:	e03fde8d 	sth	zero,-134(fp)
811193fc:	e03fdf0d 	sth	zero,-132(fp)
81119400:	e0bfdf84 	addi	r2,fp,-130
81119404:	00c01f04 	movi	r3,124
81119408:	180d883a 	mov	r6,r3
8111940c:	000b883a 	mov	r5,zero
81119410:	1009883a 	mov	r4,r2
81119414:	11227e00 	call	811227e0 <memset>
    unsigned char crc = 0;
81119418:	e03fdc05 	stb	zero,-144(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
8111941c:	e03fdd15 	stw	zero,-140(fp)

    usiIdCMDLocal = usiGetIdCMD();
81119420:	11194dc0 	call	811194dc <usiGetIdCMD>
81119424:	e0bfde0d 	sth	r2,-136(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferLog, LOG_SPRINTF, usiIdCMDLocal, cDataIn);
81119428:	e0ffde0b 	ldhu	r3,-136(fp)
8111942c:	e0bfde84 	addi	r2,fp,-134
81119430:	e1ffff17 	ldw	r7,-4(fp)
81119434:	180d883a 	mov	r6,r3
81119438:	01604574 	movhi	r5,33045
8111943c:	297b7204 	addi	r5,r5,-4664
81119440:	1009883a 	mov	r4,r2
81119444:	1122f700 	call	81122f70 <sprintf>
    crc = ucCrc8wInit( cBufferLog , strlen(cBufferLog));
81119448:	e0bfde84 	addi	r2,fp,-134
8111944c:	1009883a 	mov	r4,r2
81119450:	11231840 	call	81123184 <strlen>
81119454:	1007883a 	mov	r3,r2
81119458:	e0bfde84 	addi	r2,fp,-134
8111945c:	180b883a 	mov	r5,r3
81119460:	1009883a 	mov	r4,r2
81119464:	111b7200 	call	8111b720 <ucCrc8wInit>
81119468:	e0bfdc05 	stb	r2,-144(fp)
    sprintf(cBufferLog, "%s|%hhu;", cBufferLog, crc );
8111946c:	e13fdc03 	ldbu	r4,-144(fp)
81119470:	e0ffde84 	addi	r3,fp,-134
81119474:	e0bfde84 	addi	r2,fp,-134
81119478:	200f883a 	mov	r7,r4
8111947c:	180d883a 	mov	r6,r3
81119480:	01604574 	movhi	r5,33045
81119484:	297b6b04 	addi	r5,r5,-4692
81119488:	1009883a 	mov	r4,r2
8111948c:	1122f700 	call	81122f70 <sprintf>

	bSuccees = bSendUART128v2(cBufferLog, usiIdCMDLocal);
81119490:	e0bfde0b 	ldhu	r2,-136(fp)
81119494:	10ffffcc 	andi	r3,r2,65535
81119498:	18e0001c 	xori	r3,r3,32768
8111949c:	18e00004 	addi	r3,r3,-32768
811194a0:	e0bfde84 	addi	r2,fp,-134
811194a4:	180b883a 	mov	r5,r3
811194a8:	1009883a 	mov	r4,r2
811194ac:	111863c0 	call	8111863c <bSendUART128v2>
811194b0:	e0bfdd15 	stw	r2,-140(fp)

	if ( bSuccees != TRUE ) {
811194b4:	e0bfdd17 	ldw	r2,-140(fp)
811194b8:	10800060 	cmpeqi	r2,r2,1
811194bc:	1000011e 	bne	r2,zero,811194c4 <vSendLog+0xe8>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendLog();
811194c0:	111ca680 	call	8111ca68 <vCouldNotSendLog>
	}
}
811194c4:	0001883a 	nop
811194c8:	e037883a 	mov	sp,fp
811194cc:	dfc00117 	ldw	ra,4(sp)
811194d0:	df000017 	ldw	fp,0(sp)
811194d4:	dec00204 	addi	sp,sp,8
811194d8:	f800283a 	ret

811194dc <usiGetIdCMD>:

unsigned short int usiGetIdCMD ( void ) {
811194dc:	deffff04 	addi	sp,sp,-4
811194e0:	de00012e 	bgeu	sp,et,811194e8 <usiGetIdCMD+0xc>
811194e4:	003b68fa 	trap	3
811194e8:	df000015 	stw	fp,0(sp)
811194ec:	d839883a 	mov	fp,sp
    if ( usiIdCMD > 65534 )
811194f0:	d0a0680b 	ldhu	r2,-32352(gp)
811194f4:	10ffffcc 	andi	r3,r2,65535
811194f8:	00bfffd4 	movui	r2,65535
811194fc:	1880031e 	bne	r3,r2,8111950c <usiGetIdCMD+0x30>
        usiIdCMD = 2;
81119500:	00800084 	movi	r2,2
81119504:	d0a0680d 	sth	r2,-32352(gp)
81119508:	00000306 	br	81119518 <usiGetIdCMD+0x3c>
    else
        usiIdCMD++;
8111950c:	d0a0680b 	ldhu	r2,-32352(gp)
81119510:	10800044 	addi	r2,r2,1
81119514:	d0a0680d 	sth	r2,-32352(gp)

    return usiIdCMD;
81119518:	d0a0680b 	ldhu	r2,-32352(gp)
}
8111951c:	e037883a 	mov	sp,fp
81119520:	df000017 	ldw	fp,0(sp)
81119524:	dec00104 	addi	sp,sp,4
81119528:	f800283a 	ret

8111952c <siPosStr>:

inline short int siPosStr( char *buffer, char cValue) {
8111952c:	defffb04 	addi	sp,sp,-20
81119530:	de00012e 	bgeu	sp,et,81119538 <siPosStr+0xc>
81119534:	003b68fa 	trap	3
81119538:	dfc00415 	stw	ra,16(sp)
8111953c:	df000315 	stw	fp,12(sp)
81119540:	df000304 	addi	fp,sp,12
81119544:	e13ffe15 	stw	r4,-8(fp)
81119548:	2805883a 	mov	r2,r5
8111954c:	e0bfff05 	stb	r2,-4(fp)
    char cTempChar[2] = "";
81119550:	e03ffd0d 	sth	zero,-12(fp)
    cTempChar[0] = cValue; /* This step was add for performance. The command strcspn needs "" (const char *) */
81119554:	e0bfff03 	ldbu	r2,-4(fp)
81119558:	e0bffd05 	stb	r2,-12(fp)
    return strcspn(buffer, cTempChar);
8111955c:	e17ffd04 	addi	r5,fp,-12
81119560:	e13ffe17 	ldw	r4,-8(fp)
81119564:	11231380 	call	81123138 <strcspn>
}
81119568:	e037883a 	mov	sp,fp
8111956c:	dfc00117 	ldw	ra,4(sp)
81119570:	df000017 	ldw	fp,0(sp)
81119574:	dec00204 	addi	sp,sp,8
81119578:	f800283a 	ret

8111957c <vTimeoutCheck>:


void vTimeoutCheck (void *p_arg)
{
8111957c:	defffc04 	addi	sp,sp,-16
81119580:	de00012e 	bgeu	sp,et,81119588 <vTimeoutCheck+0xc>
81119584:	003b68fa 	trap	3
81119588:	dfc00315 	stw	ra,12(sp)
8111958c:	df000215 	stw	fp,8(sp)
81119590:	df000204 	addi	fp,sp,8
81119594:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;

	/* Time to check the (re)transmission buffers, posting a semaphore to sync the task that will threat timeout logic (vTimeoutCheckerTask) */
	error_code = OSSemPost(xSemTimeoutChecker);
81119598:	d0a06717 	ldw	r2,-32356(gp)
8111959c:	1009883a 	mov	r4,r2
811195a0:	113eea00 	call	8113eea0 <OSSemPost>
811195a4:	e0bffe05 	stb	r2,-8(fp)
	if ( error_code != OS_ERR_NONE ) {
811195a8:	e0bffe03 	ldbu	r2,-8(fp)
811195ac:	10000126 	beq	r2,zero,811195b4 <vTimeoutCheck+0x38>
		vFailPostBlockingSemTimeoutTask();
811195b0:	111c7280 	call	8111c728 <vFailPostBlockingSemTimeoutTask>
	}
}
811195b4:	0001883a 	nop
811195b8:	e037883a 	mov	sp,fp
811195bc:	dfc00117 	ldw	ra,4(sp)
811195c0:	df000017 	ldw	fp,0(sp)
811195c4:	dec00204 	addi	sp,sp,8
811195c8:	f800283a 	ret

811195cc <vSendPusTM64>:


/* Send through a medium buffer */
void vSendPusTM64 ( tTMPus xPcktPus ) {
811195cc:	deffe304 	addi	sp,sp,-116
811195d0:	de00012e 	bgeu	sp,et,811195d8 <vSendPusTM64+0xc>
811195d4:	003b68fa 	trap	3
811195d8:	dfc01815 	stw	ra,96(sp)
811195dc:	df001715 	stw	fp,92(sp)
811195e0:	df001704 	addi	fp,sp,92
811195e4:	e1000215 	stw	r4,8(fp)
811195e8:	e1400315 	stw	r5,12(fp)
811195ec:	e1800415 	stw	r6,16(fp)
811195f0:	e1c00515 	stw	r7,20(fp)
    char cBufferPus[64] = "";
811195f4:	e03fef8d 	sth	zero,-66(fp)
811195f8:	e03ff00d 	sth	zero,-64(fp)
811195fc:	e0bff084 	addi	r2,fp,-62
81119600:	00c00f04 	movi	r3,60
81119604:	180d883a 	mov	r6,r3
81119608:	000b883a 	mov	r5,zero
8111960c:	1009883a 	mov	r4,r2
81119610:	11227e00 	call	811227e0 <memset>
    unsigned char crc = 0;
81119614:	e03fed45 	stb	zero,-75(fp)
	unsigned char ucIL = 0;
81119618:	e03fed05 	stb	zero,-76(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
8111961c:	e03fee15 	stw	zero,-72(fp)

    usiIdCMDLocal = usiGetIdCMD();
81119620:	11194dc0 	call	811194dc <usiGetIdCMD>
81119624:	e0bfef0d 	sth	r2,-68(fp)

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
81119628:	e1bfef0b 	ldhu	r6,-68(fp)
8111962c:	e080040b 	ldhu	r2,16(fp)
81119630:	11ffffcc 	andi	r7,r2,65535
81119634:	e080048b 	ldhu	r2,18(fp)
81119638:	10bfffcc 	andi	r2,r2,65535
8111963c:	e0c0050b 	ldhu	r3,20(fp)
81119640:	18ffffcc 	andi	r3,r3,65535
81119644:	e100058b 	ldhu	r4,22(fp)
81119648:	213fffcc 	andi	r4,r4,65535
8111964c:	e140060b 	ldhu	r5,24(fp)
81119650:	297fffcc 	andi	r5,r5,65535
81119654:	e23fef84 	addi	r8,fp,-66
81119658:	d9400315 	stw	r5,12(sp)
8111965c:	d9000215 	stw	r4,8(sp)
81119660:	d8c00115 	stw	r3,4(sp)
81119664:	d8800015 	stw	r2,0(sp)
81119668:	01604574 	movhi	r5,33045
8111966c:	297b7504 	addi	r5,r5,-4652
81119670:	4009883a 	mov	r4,r8
81119674:	1122f700 	call	81122f70 <sprintf>
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
81119678:	e03fed05 	stb	zero,-76(fp)
8111967c:	00001206 	br	811196c8 <vSendPusTM64+0xfc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
81119680:	e0bfed03 	ldbu	r2,-76(fp)
81119684:	10800284 	addi	r2,r2,10
81119688:	1085883a 	add	r2,r2,r2
8111968c:	e0c00204 	addi	r3,fp,8
81119690:	1885883a 	add	r2,r3,r2
81119694:	1080000b 	ldhu	r2,0(r2)
81119698:	113fffcc 	andi	r4,r2,65535
8111969c:	e0ffef84 	addi	r3,fp,-66
811196a0:	e0bfef84 	addi	r2,fp,-66
811196a4:	200f883a 	mov	r7,r4
811196a8:	180d883a 	mov	r6,r3
811196ac:	01604574 	movhi	r5,33045
811196b0:	297b7c04 	addi	r5,r5,-4624
811196b4:	1009883a 	mov	r4,r2
811196b8:	1122f700 	call	81122f70 <sprintf>
    usiIdCMDLocal = usiGetIdCMD();

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
811196bc:	e0bfed03 	ldbu	r2,-76(fp)
811196c0:	10800044 	addi	r2,r2,1
811196c4:	e0bfed05 	stb	r2,-76(fp)
811196c8:	e0800683 	ldbu	r2,26(fp)
811196cc:	10803fcc 	andi	r2,r2,255
811196d0:	e0ffed03 	ldbu	r3,-76(fp)
811196d4:	18bfea36 	bltu	r3,r2,81119680 <__reset+0xfb0f9680>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
	}
	/* Calculate the crc, append it and finish the string with ";" character */
    crc = ucCrc8wInit( cBufferPus , strlen(cBufferPus));
811196d8:	e0bfef84 	addi	r2,fp,-66
811196dc:	1009883a 	mov	r4,r2
811196e0:	11231840 	call	81123184 <strlen>
811196e4:	1007883a 	mov	r3,r2
811196e8:	e0bfef84 	addi	r2,fp,-66
811196ec:	180b883a 	mov	r5,r3
811196f0:	1009883a 	mov	r4,r2
811196f4:	111b7200 	call	8111b720 <ucCrc8wInit>
811196f8:	e0bfed45 	stb	r2,-75(fp)
    sprintf(cBufferPus, "%s|%hhu;", cBufferPus, crc );
811196fc:	e13fed43 	ldbu	r4,-75(fp)
81119700:	e0ffef84 	addi	r3,fp,-66
81119704:	e0bfef84 	addi	r2,fp,-66
81119708:	200f883a 	mov	r7,r4
8111970c:	180d883a 	mov	r6,r3
81119710:	01604574 	movhi	r5,33045
81119714:	297b6b04 	addi	r5,r5,-4692
81119718:	1009883a 	mov	r4,r2
8111971c:	1122f700 	call	81122f70 <sprintf>

	bSuccees = bSendUART64v2(cBufferPus, usiIdCMDLocal);
81119720:	e0bfef0b 	ldhu	r2,-68(fp)
81119724:	10ffffcc 	andi	r3,r2,65535
81119728:	18e0001c 	xori	r3,r3,32768
8111972c:	18e00004 	addi	r3,r3,-32768
81119730:	e0bfef84 	addi	r2,fp,-66
81119734:	180b883a 	mov	r5,r3
81119738:	1009883a 	mov	r4,r2
8111973c:	111892c0 	call	8111892c <bSendUART64v2>
81119740:	e0bfee15 	stw	r2,-72(fp)

	if ( bSuccees != TRUE ) {
81119744:	e0bfee17 	ldw	r2,-72(fp)
81119748:	10800060 	cmpeqi	r2,r2,1
8111974c:	1000031e 	bne	r2,zero,8111975c <vSendPusTM64+0x190>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTMPusCommand( cBufferPus );
81119750:	e0bfef84 	addi	r2,fp,-66
81119754:	1009883a 	mov	r4,r2
81119758:	111cad00 	call	8111cad0 <vCouldNotSendTMPusCommand>
	}
}
8111975c:	0001883a 	nop
81119760:	e037883a 	mov	sp,fp
81119764:	dfc00117 	ldw	ra,4(sp)
81119768:	df000017 	ldw	fp,0(sp)
8111976c:	dec00604 	addi	sp,sp,24
81119770:	f800283a 	ret

81119774 <vSendPusTM128>:

/* Send through a big buffer */
void vSendPusTM128 ( tTMPus xPcktPus ) {
81119774:	deffd304 	addi	sp,sp,-180
81119778:	de00012e 	bgeu	sp,et,81119780 <vSendPusTM128+0xc>
8111977c:	003b68fa 	trap	3
81119780:	dfc02815 	stw	ra,160(sp)
81119784:	df002715 	stw	fp,156(sp)
81119788:	df002704 	addi	fp,sp,156
8111978c:	e1000215 	stw	r4,8(fp)
81119790:	e1400315 	stw	r5,12(fp)
81119794:	e1800415 	stw	r6,16(fp)
81119798:	e1c00515 	stw	r7,20(fp)
    char cBufferPus[128] = "";
8111979c:	e03fdf8d 	sth	zero,-130(fp)
811197a0:	e03fe00d 	sth	zero,-128(fp)
811197a4:	e0bfe084 	addi	r2,fp,-126
811197a8:	00c01f04 	movi	r3,124
811197ac:	180d883a 	mov	r6,r3
811197b0:	000b883a 	mov	r5,zero
811197b4:	1009883a 	mov	r4,r2
811197b8:	11227e00 	call	811227e0 <memset>
    unsigned char crc = 0;
811197bc:	e03fdd45 	stb	zero,-139(fp)
	unsigned char ucIL = 0;
811197c0:	e03fdd05 	stb	zero,-140(fp)
    unsigned short int usiIdCMDLocal;
	bool bSuccees = FALSE;
811197c4:	e03fde15 	stw	zero,-136(fp)

    usiIdCMDLocal = usiGetIdCMD();
811197c8:	11194dc0 	call	811194dc <usiGetIdCMD>
811197cc:	e0bfdf0d 	sth	r2,-132(fp)

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
811197d0:	e1bfdf0b 	ldhu	r6,-132(fp)
811197d4:	e080040b 	ldhu	r2,16(fp)
811197d8:	11ffffcc 	andi	r7,r2,65535
811197dc:	e080048b 	ldhu	r2,18(fp)
811197e0:	10bfffcc 	andi	r2,r2,65535
811197e4:	e0c0050b 	ldhu	r3,20(fp)
811197e8:	18ffffcc 	andi	r3,r3,65535
811197ec:	e100058b 	ldhu	r4,22(fp)
811197f0:	213fffcc 	andi	r4,r4,65535
811197f4:	e140060b 	ldhu	r5,24(fp)
811197f8:	297fffcc 	andi	r5,r5,65535
811197fc:	e23fdf84 	addi	r8,fp,-130
81119800:	d9400315 	stw	r5,12(sp)
81119804:	d9000215 	stw	r4,8(sp)
81119808:	d8c00115 	stw	r3,4(sp)
8111980c:	d8800015 	stw	r2,0(sp)
81119810:	01604574 	movhi	r5,33045
81119814:	297b7504 	addi	r5,r5,-4652
81119818:	4009883a 	mov	r4,r8
8111981c:	1122f700 	call	81122f70 <sprintf>
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
81119820:	e03fdd05 	stb	zero,-140(fp)
81119824:	00001206 	br	81119870 <vSendPusTM128+0xfc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
81119828:	e0bfdd03 	ldbu	r2,-140(fp)
8111982c:	10800284 	addi	r2,r2,10
81119830:	1085883a 	add	r2,r2,r2
81119834:	e0c00204 	addi	r3,fp,8
81119838:	1885883a 	add	r2,r3,r2
8111983c:	1080000b 	ldhu	r2,0(r2)
81119840:	113fffcc 	andi	r4,r2,65535
81119844:	e0ffdf84 	addi	r3,fp,-130
81119848:	e0bfdf84 	addi	r2,fp,-130
8111984c:	200f883a 	mov	r7,r4
81119850:	180d883a 	mov	r6,r3
81119854:	01604574 	movhi	r5,33045
81119858:	297b7c04 	addi	r5,r5,-4624
8111985c:	1009883a 	mov	r4,r2
81119860:	1122f700 	call	81122f70 <sprintf>
    usiIdCMDLocal = usiGetIdCMD();

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
81119864:	e0bfdd03 	ldbu	r2,-140(fp)
81119868:	10800044 	addi	r2,r2,1
8111986c:	e0bfdd05 	stb	r2,-140(fp)
81119870:	e0800683 	ldbu	r2,26(fp)
81119874:	10803fcc 	andi	r2,r2,255
81119878:	e0ffdd03 	ldbu	r3,-140(fp)
8111987c:	18bfea36 	bltu	r3,r2,81119828 <__reset+0xfb0f9828>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
	}
	/* Calculate the crc, append it and finish the string with ";" character */
    crc = ucCrc8wInit( cBufferPus , strlen(cBufferPus));
81119880:	e0bfdf84 	addi	r2,fp,-130
81119884:	1009883a 	mov	r4,r2
81119888:	11231840 	call	81123184 <strlen>
8111988c:	1007883a 	mov	r3,r2
81119890:	e0bfdf84 	addi	r2,fp,-130
81119894:	180b883a 	mov	r5,r3
81119898:	1009883a 	mov	r4,r2
8111989c:	111b7200 	call	8111b720 <ucCrc8wInit>
811198a0:	e0bfdd45 	stb	r2,-139(fp)
    sprintf(cBufferPus, "%s|%hhu;", cBufferPus, crc );
811198a4:	e13fdd43 	ldbu	r4,-139(fp)
811198a8:	e0ffdf84 	addi	r3,fp,-130
811198ac:	e0bfdf84 	addi	r2,fp,-130
811198b0:	200f883a 	mov	r7,r4
811198b4:	180d883a 	mov	r6,r3
811198b8:	01604574 	movhi	r5,33045
811198bc:	297b6b04 	addi	r5,r5,-4692
811198c0:	1009883a 	mov	r4,r2
811198c4:	1122f700 	call	81122f70 <sprintf>

	bSuccees = bSendUART128v2(cBufferPus, usiIdCMDLocal);
811198c8:	e0bfdf0b 	ldhu	r2,-132(fp)
811198cc:	10ffffcc 	andi	r3,r2,65535
811198d0:	18e0001c 	xori	r3,r3,32768
811198d4:	18e00004 	addi	r3,r3,-32768
811198d8:	e0bfdf84 	addi	r2,fp,-130
811198dc:	180b883a 	mov	r5,r3
811198e0:	1009883a 	mov	r4,r2
811198e4:	111863c0 	call	8111863c <bSendUART128v2>
811198e8:	e0bfde15 	stw	r2,-136(fp)

	if ( bSuccees != TRUE ) {
811198ec:	e0bfde17 	ldw	r2,-136(fp)
811198f0:	10800060 	cmpeqi	r2,r2,1
811198f4:	1000031e 	bne	r2,zero,81119904 <vSendPusTM128+0x190>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTMPusCommand( cBufferPus );
811198f8:	e0bfdf84 	addi	r2,fp,-130
811198fc:	1009883a 	mov	r4,r2
81119900:	111cad00 	call	8111cad0 <vCouldNotSendTMPusCommand>
	}
}
81119904:	0001883a 	nop
81119908:	e037883a 	mov	sp,fp
8111990c:	dfc00117 	ldw	ra,4(sp)
81119910:	df000017 	ldw	fp,0(sp)
81119914:	dec00604 	addi	sp,sp,24
81119918:	f800283a 	ret

8111991c <vTMPusTestConnection>:
/* TM_SCAM_TEST_CONNECTION */
/* 
hp-pck-type		hp-pid		hp-pcat		hp-srv-type		hp-srv-subtype
0				112			0			17				2
*/
void vTMPusTestConnection( unsigned short int usiPusId ) {
8111991c:	deffd704 	addi	sp,sp,-164
81119920:	de00012e 	bgeu	sp,et,81119928 <vTMPusTestConnection+0xc>
81119924:	003b68fa 	trap	3
81119928:	dfc02815 	stw	ra,160(sp)
8111992c:	df002715 	stw	fp,156(sp)
81119930:	df002704 	addi	fp,sp,156
81119934:	2005883a 	mov	r2,r4
81119938:	e0bfff0d 	sth	r2,-4(fp)
	tTMPus xTmPusL;

	/* For now is hardcoded after full release of the pus I will create defines */
	xTmPusL.usiPusId = usiPusId;
8111993c:	e0bfff0b 	ldhu	r2,-4(fp)
81119940:	e0bfee0d 	sth	r2,-72(fp)
	xTmPusL.usiPid = 112;
81119944:	00801c04 	movi	r2,112
81119948:	e0bfec0d 	sth	r2,-80(fp)
	xTmPusL.usiCat = 0;
8111994c:	e03fec8d 	sth	zero,-78(fp)
	xTmPusL.usiType = 17;
81119950:	00800444 	movi	r2,17
81119954:	e0bfed0d 	sth	r2,-76(fp)
	xTmPusL.usiSubType = 2;
81119958:	00800084 	movi	r2,2
8111995c:	e0bfed8d 	sth	r2,-74(fp)

	vSendPusTM64( xTmPusL );
81119960:	d809883a 	mov	r4,sp
81119964:	e0bfee04 	addi	r2,fp,-72
81119968:	00c01104 	movi	r3,68
8111996c:	180d883a 	mov	r6,r3
81119970:	100b883a 	mov	r5,r2
81119974:	11226900 	call	81122690 <memcpy>
81119978:	e13fea17 	ldw	r4,-88(fp)
8111997c:	e17feb17 	ldw	r5,-84(fp)
81119980:	e1bfec17 	ldw	r6,-80(fp)
81119984:	e1ffed17 	ldw	r7,-76(fp)
81119988:	11195cc0 	call	811195cc <vSendPusTM64>
}
8111998c:	0001883a 	nop
81119990:	e037883a 	mov	sp,fp
81119994:	dfc00117 	ldw	ra,4(sp)
81119998:	df000017 	ldw	fp,0(sp)
8111999c:	dec00204 	addi	sp,sp,8
811199a0:	f800283a 	ret

811199a4 <vLoadDefaultETHConf>:
/*Configuration related to the eth connection*/
TConfEth xConfEth;
TDefaults xDefaults;


bool vLoadDefaultETHConf( void ){
811199a4:	defff504 	addi	sp,sp,-44
811199a8:	de00012e 	bgeu	sp,et,811199b0 <vLoadDefaultETHConf+0xc>
811199ac:	003b68fa 	trap	3
811199b0:	dfc00a15 	stw	ra,40(sp)
811199b4:	df000915 	stw	fp,36(sp)
811199b8:	dc000815 	stw	r16,32(sp)
811199bc:	df000904 	addi	fp,sp,36
	short int siFile, sidhcpTemp;
	bool bSuccess = FALSE;
811199c0:	e03ff715 	stw	zero,-36(fp)
	bool bEOF = FALSE;
811199c4:	e03ff815 	stw	zero,-32(fp)
	bool close = FALSE;
811199c8:	e03ffb15 	stw	zero,-20(fp)
	unsigned char ucParser;
	char c, *p_inteiro;
	char inteiro[8];


	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){
811199cc:	d0a07617 	ldw	r2,-32296(gp)
811199d0:	10800058 	cmpnei	r2,r2,1
811199d4:	1002051e 	bne	r2,zero,8111a1ec <vLoadDefaultETHConf+0x848>
811199d8:	111e9cc0 	call	8111e9cc <bSDcardIsPresent>
811199dc:	10020326 	beq	r2,zero,8111a1ec <vLoadDefaultETHConf+0x848>
811199e0:	111e9fc0 	call	8111e9fc <bSDcardFAT16Check>
811199e4:	10020126 	beq	r2,zero,8111a1ec <vLoadDefaultETHConf+0x848>

		siFile = siOpenFile( ETH_FILE_NAME );
811199e8:	01204574 	movhi	r4,33045
811199ec:	213b7e04 	addi	r4,r4,-4616
811199f0:	111eb240 	call	8111eb24 <siOpenFile>
811199f4:	e0bffc0d 	sth	r2,-16(fp)

		if ( siFile >= 0 ){
811199f8:	e0bffc0f 	ldh	r2,-16(fp)
811199fc:	1001f316 	blt	r2,zero,8111a1cc <vLoadDefaultETHConf+0x828>

			memset( &(inteiro) , 10 , sizeof( inteiro ) );
81119a00:	e0bffd04 	addi	r2,fp,-12
81119a04:	01800204 	movi	r6,8
81119a08:	01400284 	movi	r5,10
81119a0c:	1009883a 	mov	r4,r2
81119a10:	11227e00 	call	811227e0 <memset>
			p_inteiro = inteiro;
81119a14:	e0bffd04 	addi	r2,fp,-12
81119a18:	e0bffa15 	stw	r2,-24(fp)

			do {
				c = cGetNextChar(siFile);
81119a1c:	e0bffc0f 	ldh	r2,-16(fp)
81119a20:	1009883a 	mov	r4,r2
81119a24:	111eba00 	call	8111eba0 <cGetNextChar>
81119a28:	e0bff945 	stb	r2,-27(fp)
				//printf("%c \n", c);
				switch (c) {
81119a2c:	e0bff947 	ldb	r2,-27(fp)
81119a30:	10800084 	addi	r2,r2,2
81119a34:	10c015a8 	cmpgeui	r3,r2,86
81119a38:	1801d81e 	bne	r3,zero,8111a19c <vLoadDefaultETHConf+0x7f8>
81119a3c:	100690ba 	slli	r3,r2,2
81119a40:	00a044b4 	movhi	r2,33042
81119a44:	10a69504 	addi	r2,r2,-26028
81119a48:	1885883a 	add	r2,r3,r2
81119a4c:	10800017 	ldw	r2,0(r2)
81119a50:	1000683a 	jmp	r2
81119a54:	81119bec 	andhi	r4,r16,18031
81119a58:	81119be0 	cmpeqi	r4,r16,18031
81119a5c:	8111a19c 	xori	r4,r16,18054
81119a60:	8111a19c 	xori	r4,r16,18054
81119a64:	8111a19c 	xori	r4,r16,18054
81119a68:	8111a19c 	xori	r4,r16,18054
81119a6c:	8111a19c 	xori	r4,r16,18054
81119a70:	8111a19c 	xori	r4,r16,18054
81119a74:	8111a19c 	xori	r4,r16,18054
81119a78:	8111a19c 	xori	r4,r16,18054
81119a7c:	8111a19c 	xori	r4,r16,18054
81119a80:	8111a19c 	xori	r4,r16,18054
81119a84:	8111a1bc 	xorhi	r4,r16,18054
81119a88:	8111a19c 	xori	r4,r16,18054
81119a8c:	8111a19c 	xori	r4,r16,18054
81119a90:	8111a1bc 	xorhi	r4,r16,18054
81119a94:	8111a19c 	xori	r4,r16,18054
81119a98:	8111a19c 	xori	r4,r16,18054
81119a9c:	8111a19c 	xori	r4,r16,18054
81119aa0:	8111a19c 	xori	r4,r16,18054
81119aa4:	8111a19c 	xori	r4,r16,18054
81119aa8:	8111a19c 	xori	r4,r16,18054
81119aac:	8111a19c 	xori	r4,r16,18054
81119ab0:	8111a19c 	xori	r4,r16,18054
81119ab4:	8111a19c 	xori	r4,r16,18054
81119ab8:	8111a19c 	xori	r4,r16,18054
81119abc:	8111a19c 	xori	r4,r16,18054
81119ac0:	8111a19c 	xori	r4,r16,18054
81119ac4:	8111a19c 	xori	r4,r16,18054
81119ac8:	8111a19c 	xori	r4,r16,18054
81119acc:	8111a19c 	xori	r4,r16,18054
81119ad0:	8111a19c 	xori	r4,r16,18054
81119ad4:	8111a19c 	xori	r4,r16,18054
81119ad8:	8111a19c 	xori	r4,r16,18054
81119adc:	8111a1bc 	xorhi	r4,r16,18054
81119ae0:	8111a19c 	xori	r4,r16,18054
81119ae4:	8111a19c 	xori	r4,r16,18054
81119ae8:	8111a19c 	xori	r4,r16,18054
81119aec:	8111a19c 	xori	r4,r16,18054
81119af0:	8111a19c 	xori	r4,r16,18054
81119af4:	8111a19c 	xori	r4,r16,18054
81119af8:	81119bac 	andhi	r4,r16,18030
81119afc:	8111a19c 	xori	r4,r16,18054
81119b00:	8111a19c 	xori	r4,r16,18054
81119b04:	8111a19c 	xori	r4,r16,18054
81119b08:	8111a19c 	xori	r4,r16,18054
81119b0c:	8111a19c 	xori	r4,r16,18054
81119b10:	8111a19c 	xori	r4,r16,18054
81119b14:	8111a19c 	xori	r4,r16,18054
81119b18:	8111a19c 	xori	r4,r16,18054
81119b1c:	8111a19c 	xori	r4,r16,18054
81119b20:	8111a19c 	xori	r4,r16,18054
81119b24:	8111a19c 	xori	r4,r16,18054
81119b28:	8111a19c 	xori	r4,r16,18054
81119b2c:	8111a19c 	xori	r4,r16,18054
81119b30:	8111a19c 	xori	r4,r16,18054
81119b34:	8111a19c 	xori	r4,r16,18054
81119b38:	8111a19c 	xori	r4,r16,18054
81119b3c:	8111a19c 	xori	r4,r16,18054
81119b40:	8111a19c 	xori	r4,r16,18054
81119b44:	8111a19c 	xori	r4,r16,18054
81119b48:	8111a19c 	xori	r4,r16,18054
81119b4c:	8111a154 	ori	r4,r16,18053
81119b50:	8111a19c 	xori	r4,r16,18054
81119b54:	8111a19c 	xori	r4,r16,18054
81119b58:	8111a19c 	xori	r4,r16,18054
81119b5c:	8111a19c 	xori	r4,r16,18054
81119b60:	8111a19c 	xori	r4,r16,18054
81119b64:	8111a19c 	xori	r4,r16,18054
81119b68:	8111a19c 	xori	r4,r16,18054
81119b6c:	8111a084 	addi	r4,r16,18050
81119b70:	8111a19c 	xori	r4,r16,18054
81119b74:	8111a19c 	xori	r4,r16,18054
81119b78:	81119db0 	cmpltui	r4,r16,18038
81119b7c:	81119f0c 	andi	r4,r16,18044
81119b80:	81119ce4 	muli	r4,r16,18035
81119b84:	8111a19c 	xori	r4,r16,18054
81119b88:	8111a19c 	xori	r4,r16,18054
81119b8c:	8111a19c 	xori	r4,r16,18054
81119b90:	81119c14 	ori	r4,r16,18032
81119b94:	8111a19c 	xori	r4,r16,18054
81119b98:	8111a19c 	xori	r4,r16,18054
81119b9c:	81119e80 	call	881119e8 <__reset+0x20f19e8>
81119ba0:	8111a19c 	xori	r4,r16,18054
81119ba4:	8111a19c 	xori	r4,r16,18054
81119ba8:	81119fb4 	orhi	r4,r16,18046
					case 39:// single quote '
						c = cGetNextChar(siFile);
81119bac:	e0bffc0f 	ldh	r2,-16(fp)
81119bb0:	1009883a 	mov	r4,r2
81119bb4:	111eba00 	call	8111eba0 <cGetNextChar>
81119bb8:	e0bff945 	stb	r2,-27(fp)
						while ( c != 39 ){
81119bbc:	00000406 	br	81119bd0 <vLoadDefaultETHConf+0x22c>
							c = cGetNextChar(siFile);
81119bc0:	e0bffc0f 	ldh	r2,-16(fp)
81119bc4:	1009883a 	mov	r4,r2
81119bc8:	111eba00 	call	8111eba0 <cGetNextChar>
81119bcc:	e0bff945 	stb	r2,-27(fp)
				c = cGetNextChar(siFile);
				//printf("%c \n", c);
				switch (c) {
					case 39:// single quote '
						c = cGetNextChar(siFile);
						while ( c != 39 ){
81119bd0:	e0bff947 	ldb	r2,-27(fp)
81119bd4:	108009d8 	cmpnei	r2,r2,39
81119bd8:	103ff91e 	bne	r2,zero,81119bc0 <__reset+0xfb0f9bc0>
							c = cGetNextChar(siFile);
						}
						break;
81119bdc:	00017806 	br	8111a1c0 <vLoadDefaultETHConf+0x81c>
					case -1: 	//EOF
						bEOF = TRUE;
81119be0:	00800044 	movi	r2,1
81119be4:	e0bff815 	stw	r2,-32(fp)
						break;
81119be8:	00017506 	br	8111a1c0 <vLoadDefaultETHConf+0x81c>
					case -2: 	//EOF
						#ifdef DEBUG_ON
							debug(fp,"SDCard: Problem with SDCard");
81119bec:	d0a06217 	ldw	r2,-32376(gp)
81119bf0:	100f883a 	mov	r7,r2
81119bf4:	018006c4 	movi	r6,27
81119bf8:	01400044 	movi	r5,1
81119bfc:	01204574 	movhi	r4,33045
81119c00:	213b8004 	addi	r4,r4,-4608
81119c04:	1121c7c0 	call	81121c7c <fwrite>
						#endif
						bEOF = TRUE;
81119c08:	00800044 	movi	r2,1
81119c0c:	e0bff815 	stw	r2,-32(fp)
						break;
81119c10:	00016b06 	br	8111a1c0 <vLoadDefaultETHConf+0x81c>
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
					case 'M':

						ucParser = 0;
81119c14:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81119c18:	e0bffc0f 	ldh	r2,-16(fp)
81119c1c:	1009883a 	mov	r4,r2
81119c20:	111eba00 	call	8111eba0 <cGetNextChar>
81119c24:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81119c28:	d0e00317 	ldw	r3,-32756(gp)
81119c2c:	e0bff947 	ldb	r2,-27(fp)
81119c30:	10800044 	addi	r2,r2,1
81119c34:	1885883a 	add	r2,r3,r2
81119c38:	10800003 	ldbu	r2,0(r2)
81119c3c:	10803fcc 	andi	r2,r2,255
81119c40:	1080010c 	andi	r2,r2,4
81119c44:	10000626 	beq	r2,zero,81119c60 <vLoadDefaultETHConf+0x2bc>
									(*p_inteiro) = c;
81119c48:	e0bffa17 	ldw	r2,-24(fp)
81119c4c:	e0fff943 	ldbu	r3,-27(fp)
81119c50:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81119c54:	e0bffa17 	ldw	r2,-24(fp)
81119c58:	10800044 	addi	r2,r2,1
81119c5c:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=58) && (c !=59) ); //ASCII: 58 = ':' 59 = ';'
81119c60:	e0bff947 	ldb	r2,-27(fp)
81119c64:	10800ea0 	cmpeqi	r2,r2,58
81119c68:	1000031e 	bne	r2,zero,81119c78 <vLoadDefaultETHConf+0x2d4>
81119c6c:	e0bff947 	ldb	r2,-27(fp)
81119c70:	10800ed8 	cmpnei	r2,r2,59
81119c74:	103fe81e 	bne	r2,zero,81119c18 <__reset+0xfb0f9c18>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81119c78:	e0bffa17 	ldw	r2,-24(fp)
81119c7c:	00c00284 	movi	r3,10
81119c80:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucMAC[min_sim(ucParser,5)] = atoi( inteiro );
81119c84:	e0bff903 	ldbu	r2,-28(fp)
81119c88:	10800168 	cmpgeui	r2,r2,5
81119c8c:	1000021e 	bne	r2,zero,81119c98 <vLoadDefaultETHConf+0x2f4>
81119c90:	e43ff903 	ldbu	r16,-28(fp)
81119c94:	00000106 	br	81119c9c <vLoadDefaultETHConf+0x2f8>
81119c98:	04000144 	movi	r16,5
81119c9c:	e0bffd04 	addi	r2,fp,-12
81119ca0:	1009883a 	mov	r4,r2
81119ca4:	112146c0 	call	8112146c <atoi>
81119ca8:	1007883a 	mov	r3,r2
81119cac:	00a045b4 	movhi	r2,33046
81119cb0:	109c1104 	addi	r2,r2,28740
81119cb4:	1405883a 	add	r2,r2,r16
81119cb8:	10800404 	addi	r2,r2,16
81119cbc:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81119cc0:	e0bffd04 	addi	r2,fp,-12
81119cc4:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81119cc8:	e0bff903 	ldbu	r2,-28(fp)
81119ccc:	10800044 	addi	r2,r2,1
81119cd0:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81119cd4:	e0bff947 	ldb	r2,-27(fp)
81119cd8:	10800ed8 	cmpnei	r2,r2,59
81119cdc:	103fce1e 	bne	r2,zero,81119c18 <__reset+0xfb0f9c18>

						break;
81119ce0:	00013706 	br	8111a1c0 <vLoadDefaultETHConf+0x81c>
					case 'I':

						ucParser = 0;
81119ce4:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81119ce8:	e0bffc0f 	ldh	r2,-16(fp)
81119cec:	1009883a 	mov	r4,r2
81119cf0:	111eba00 	call	8111eba0 <cGetNextChar>
81119cf4:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81119cf8:	d0e00317 	ldw	r3,-32756(gp)
81119cfc:	e0bff947 	ldb	r2,-27(fp)
81119d00:	10800044 	addi	r2,r2,1
81119d04:	1885883a 	add	r2,r3,r2
81119d08:	10800003 	ldbu	r2,0(r2)
81119d0c:	10803fcc 	andi	r2,r2,255
81119d10:	1080010c 	andi	r2,r2,4
81119d14:	10000626 	beq	r2,zero,81119d30 <vLoadDefaultETHConf+0x38c>
									(*p_inteiro) = c;
81119d18:	e0bffa17 	ldw	r2,-24(fp)
81119d1c:	e0fff943 	ldbu	r3,-27(fp)
81119d20:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81119d24:	e0bffa17 	ldw	r2,-24(fp)
81119d28:	10800044 	addi	r2,r2,1
81119d2c:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81119d30:	e0bff947 	ldb	r2,-27(fp)
81119d34:	10800ba0 	cmpeqi	r2,r2,46
81119d38:	1000031e 	bne	r2,zero,81119d48 <vLoadDefaultETHConf+0x3a4>
81119d3c:	e0bff947 	ldb	r2,-27(fp)
81119d40:	10800ed8 	cmpnei	r2,r2,59
81119d44:	103fe81e 	bne	r2,zero,81119ce8 <__reset+0xfb0f9ce8>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81119d48:	e0bffa17 	ldw	r2,-24(fp)
81119d4c:	00c00284 	movi	r3,10
81119d50:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucIP[min_sim(ucParser,3)] = atoi( inteiro );
81119d54:	e0bff903 	ldbu	r2,-28(fp)
81119d58:	108000e8 	cmpgeui	r2,r2,3
81119d5c:	1000021e 	bne	r2,zero,81119d68 <vLoadDefaultETHConf+0x3c4>
81119d60:	e43ff903 	ldbu	r16,-28(fp)
81119d64:	00000106 	br	81119d6c <vLoadDefaultETHConf+0x3c8>
81119d68:	040000c4 	movi	r16,3
81119d6c:	e0bffd04 	addi	r2,fp,-12
81119d70:	1009883a 	mov	r4,r2
81119d74:	112146c0 	call	8112146c <atoi>
81119d78:	1007883a 	mov	r3,r2
81119d7c:	00a045b4 	movhi	r2,33046
81119d80:	109c1104 	addi	r2,r2,28740
81119d84:	1405883a 	add	r2,r2,r16
81119d88:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81119d8c:	e0bffd04 	addi	r2,fp,-12
81119d90:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81119d94:	e0bff903 	ldbu	r2,-28(fp)
81119d98:	10800044 	addi	r2,r2,1
81119d9c:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81119da0:	e0bff947 	ldb	r2,-27(fp)
81119da4:	10800ed8 	cmpnei	r2,r2,59
81119da8:	103fcf1e 	bne	r2,zero,81119ce8 <__reset+0xfb0f9ce8>

						break;
81119dac:	00010406 	br	8111a1c0 <vLoadDefaultETHConf+0x81c>
					case 'G':

						ucParser = 0;
81119db0:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81119db4:	e0bffc0f 	ldh	r2,-16(fp)
81119db8:	1009883a 	mov	r4,r2
81119dbc:	111eba00 	call	8111eba0 <cGetNextChar>
81119dc0:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81119dc4:	d0e00317 	ldw	r3,-32756(gp)
81119dc8:	e0bff947 	ldb	r2,-27(fp)
81119dcc:	10800044 	addi	r2,r2,1
81119dd0:	1885883a 	add	r2,r3,r2
81119dd4:	10800003 	ldbu	r2,0(r2)
81119dd8:	10803fcc 	andi	r2,r2,255
81119ddc:	1080010c 	andi	r2,r2,4
81119de0:	10000626 	beq	r2,zero,81119dfc <vLoadDefaultETHConf+0x458>
									(*p_inteiro) = c;
81119de4:	e0bffa17 	ldw	r2,-24(fp)
81119de8:	e0fff943 	ldbu	r3,-27(fp)
81119dec:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81119df0:	e0bffa17 	ldw	r2,-24(fp)
81119df4:	10800044 	addi	r2,r2,1
81119df8:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81119dfc:	e0bff947 	ldb	r2,-27(fp)
81119e00:	10800ba0 	cmpeqi	r2,r2,46
81119e04:	1000031e 	bne	r2,zero,81119e14 <vLoadDefaultETHConf+0x470>
81119e08:	e0bff947 	ldb	r2,-27(fp)
81119e0c:	10800ed8 	cmpnei	r2,r2,59
81119e10:	103fe81e 	bne	r2,zero,81119db4 <__reset+0xfb0f9db4>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81119e14:	e0bffa17 	ldw	r2,-24(fp)
81119e18:	00c00284 	movi	r3,10
81119e1c:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucGTW[min_sim(ucParser,3)] = atoi( inteiro );
81119e20:	e0bff903 	ldbu	r2,-28(fp)
81119e24:	108000e8 	cmpgeui	r2,r2,3
81119e28:	1000021e 	bne	r2,zero,81119e34 <vLoadDefaultETHConf+0x490>
81119e2c:	e43ff903 	ldbu	r16,-28(fp)
81119e30:	00000106 	br	81119e38 <vLoadDefaultETHConf+0x494>
81119e34:	040000c4 	movi	r16,3
81119e38:	e0bffd04 	addi	r2,fp,-12
81119e3c:	1009883a 	mov	r4,r2
81119e40:	112146c0 	call	8112146c <atoi>
81119e44:	1007883a 	mov	r3,r2
81119e48:	00a045b4 	movhi	r2,33046
81119e4c:	109c1104 	addi	r2,r2,28740
81119e50:	1405883a 	add	r2,r2,r16
81119e54:	10800104 	addi	r2,r2,4
81119e58:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81119e5c:	e0bffd04 	addi	r2,fp,-12
81119e60:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81119e64:	e0bff903 	ldbu	r2,-28(fp)
81119e68:	10800044 	addi	r2,r2,1
81119e6c:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81119e70:	e0bff947 	ldb	r2,-27(fp)
81119e74:	10800ed8 	cmpnei	r2,r2,59
81119e78:	103fce1e 	bne	r2,zero,81119db4 <__reset+0xfb0f9db4>

						break;
81119e7c:	0000d006 	br	8111a1c0 <vLoadDefaultETHConf+0x81c>
					case 'P':
						ucParser = 0;
81119e80:	e03ff905 	stb	zero,-28(fp)
						do {
							c = cGetNextChar(siFile);
81119e84:	e0bffc0f 	ldh	r2,-16(fp)
81119e88:	1009883a 	mov	r4,r2
81119e8c:	111eba00 	call	8111eba0 <cGetNextChar>
81119e90:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
81119e94:	d0e00317 	ldw	r3,-32756(gp)
81119e98:	e0bff947 	ldb	r2,-27(fp)
81119e9c:	10800044 	addi	r2,r2,1
81119ea0:	1885883a 	add	r2,r3,r2
81119ea4:	10800003 	ldbu	r2,0(r2)
81119ea8:	10803fcc 	andi	r2,r2,255
81119eac:	1080010c 	andi	r2,r2,4
81119eb0:	10000626 	beq	r2,zero,81119ecc <vLoadDefaultETHConf+0x528>
								(*p_inteiro) = c;
81119eb4:	e0bffa17 	ldw	r2,-24(fp)
81119eb8:	e0fff943 	ldbu	r3,-27(fp)
81119ebc:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
81119ec0:	e0bffa17 	ldw	r2,-24(fp)
81119ec4:	10800044 	addi	r2,r2,1
81119ec8:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
81119ecc:	e0bff947 	ldb	r2,-27(fp)
81119ed0:	10800ed8 	cmpnei	r2,r2,59
81119ed4:	103feb1e 	bne	r2,zero,81119e84 <__reset+0xfb0f9e84>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81119ed8:	e0bffa17 	ldw	r2,-24(fp)
81119edc:	00c00284 	movi	r3,10
81119ee0:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xConfEth.siPortPUS = atoi( inteiro );
81119ee4:	e0bffd04 	addi	r2,fp,-12
81119ee8:	1009883a 	mov	r4,r2
81119eec:	112146c0 	call	8112146c <atoi>
81119ef0:	1007883a 	mov	r3,r2
81119ef4:	00a045b4 	movhi	r2,33046
81119ef8:	109c1104 	addi	r2,r2,28740
81119efc:	10c0058d 	sth	r3,22(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
81119f00:	e0bffd04 	addi	r2,fp,-12
81119f04:	e0bffa15 	stw	r2,-24(fp)

						break;
81119f08:	0000ad06 	br	8111a1c0 <vLoadDefaultETHConf+0x81c>
					case 'H':

						do {
							c = cGetNextChar(siFile);
81119f0c:	e0bffc0f 	ldh	r2,-16(fp)
81119f10:	1009883a 	mov	r4,r2
81119f14:	111eba00 	call	8111eba0 <cGetNextChar>
81119f18:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
81119f1c:	d0e00317 	ldw	r3,-32756(gp)
81119f20:	e0bff947 	ldb	r2,-27(fp)
81119f24:	10800044 	addi	r2,r2,1
81119f28:	1885883a 	add	r2,r3,r2
81119f2c:	10800003 	ldbu	r2,0(r2)
81119f30:	10803fcc 	andi	r2,r2,255
81119f34:	1080010c 	andi	r2,r2,4
81119f38:	10000626 	beq	r2,zero,81119f54 <vLoadDefaultETHConf+0x5b0>
								(*p_inteiro) = c;
81119f3c:	e0bffa17 	ldw	r2,-24(fp)
81119f40:	e0fff943 	ldbu	r3,-27(fp)
81119f44:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
81119f48:	e0bffa17 	ldw	r2,-24(fp)
81119f4c:	10800044 	addi	r2,r2,1
81119f50:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
81119f54:	e0bff947 	ldb	r2,-27(fp)
81119f58:	10800ed8 	cmpnei	r2,r2,59
81119f5c:	103feb1e 	bne	r2,zero,81119f0c <__reset+0xfb0f9f0c>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81119f60:	e0bffa17 	ldw	r2,-24(fp)
81119f64:	00c00284 	movi	r3,10
81119f68:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						sidhcpTemp = atoi( inteiro );
81119f6c:	e0bffd04 	addi	r2,fp,-12
81119f70:	1009883a 	mov	r4,r2
81119f74:	112146c0 	call	8112146c <atoi>
81119f78:	e0bffc8d 	sth	r2,-14(fp)
						if (sidhcpTemp == 1)
81119f7c:	e0bffc8f 	ldh	r2,-14(fp)
81119f80:	10800058 	cmpnei	r2,r2,1
81119f84:	1000051e 	bne	r2,zero,81119f9c <vLoadDefaultETHConf+0x5f8>
							xConfEth.bDHCP = TRUE;
81119f88:	00a045b4 	movhi	r2,33046
81119f8c:	109c1104 	addi	r2,r2,28740
81119f90:	00c00044 	movi	r3,1
81119f94:	10c00615 	stw	r3,24(r2)
81119f98:	00000306 	br	81119fa8 <vLoadDefaultETHConf+0x604>
						else
							xConfEth.bDHCP = FALSE;
81119f9c:	00a045b4 	movhi	r2,33046
81119fa0:	109c1104 	addi	r2,r2,28740
81119fa4:	10000615 	stw	zero,24(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
81119fa8:	e0bffd04 	addi	r2,fp,-12
81119fac:	e0bffa15 	stw	r2,-24(fp)

						break;
81119fb0:	00008306 	br	8111a1c0 <vLoadDefaultETHConf+0x81c>

					case 'S':

						ucParser = 0;
81119fb4:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81119fb8:	e0bffc0f 	ldh	r2,-16(fp)
81119fbc:	1009883a 	mov	r4,r2
81119fc0:	111eba00 	call	8111eba0 <cGetNextChar>
81119fc4:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81119fc8:	d0e00317 	ldw	r3,-32756(gp)
81119fcc:	e0bff947 	ldb	r2,-27(fp)
81119fd0:	10800044 	addi	r2,r2,1
81119fd4:	1885883a 	add	r2,r3,r2
81119fd8:	10800003 	ldbu	r2,0(r2)
81119fdc:	10803fcc 	andi	r2,r2,255
81119fe0:	1080010c 	andi	r2,r2,4
81119fe4:	10000626 	beq	r2,zero,8111a000 <vLoadDefaultETHConf+0x65c>
									(*p_inteiro) = c;
81119fe8:	e0bffa17 	ldw	r2,-24(fp)
81119fec:	e0fff943 	ldbu	r3,-27(fp)
81119ff0:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81119ff4:	e0bffa17 	ldw	r2,-24(fp)
81119ff8:	10800044 	addi	r2,r2,1
81119ffc:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111a000:	e0bff947 	ldb	r2,-27(fp)
8111a004:	10800ba0 	cmpeqi	r2,r2,46
8111a008:	1000031e 	bne	r2,zero,8111a018 <vLoadDefaultETHConf+0x674>
8111a00c:	e0bff947 	ldb	r2,-27(fp)
8111a010:	10800ed8 	cmpnei	r2,r2,59
8111a014:	103fe81e 	bne	r2,zero,81119fb8 <__reset+0xfb0f9fb8>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111a018:	e0bffa17 	ldw	r2,-24(fp)
8111a01c:	00c00284 	movi	r3,10
8111a020:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucSubNet[min_sim(ucParser,3)] = atoi( inteiro );
8111a024:	e0bff903 	ldbu	r2,-28(fp)
8111a028:	108000e8 	cmpgeui	r2,r2,3
8111a02c:	1000021e 	bne	r2,zero,8111a038 <vLoadDefaultETHConf+0x694>
8111a030:	e43ff903 	ldbu	r16,-28(fp)
8111a034:	00000106 	br	8111a03c <vLoadDefaultETHConf+0x698>
8111a038:	040000c4 	movi	r16,3
8111a03c:	e0bffd04 	addi	r2,fp,-12
8111a040:	1009883a 	mov	r4,r2
8111a044:	112146c0 	call	8112146c <atoi>
8111a048:	1007883a 	mov	r3,r2
8111a04c:	00a045b4 	movhi	r2,33046
8111a050:	109c1104 	addi	r2,r2,28740
8111a054:	1405883a 	add	r2,r2,r16
8111a058:	10800204 	addi	r2,r2,8
8111a05c:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111a060:	e0bffd04 	addi	r2,fp,-12
8111a064:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111a068:	e0bff903 	ldbu	r2,-28(fp)
8111a06c:	10800044 	addi	r2,r2,1
8111a070:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111a074:	e0bff947 	ldb	r2,-27(fp)
8111a078:	10800ed8 	cmpnei	r2,r2,59
8111a07c:	103fce1e 	bne	r2,zero,81119fb8 <__reset+0xfb0f9fb8>

						break;
8111a080:	00004f06 	br	8111a1c0 <vLoadDefaultETHConf+0x81c>
					case 'D':

						ucParser = 0;
8111a084:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111a088:	e0bffc0f 	ldh	r2,-16(fp)
8111a08c:	1009883a 	mov	r4,r2
8111a090:	111eba00 	call	8111eba0 <cGetNextChar>
8111a094:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8111a098:	d0e00317 	ldw	r3,-32756(gp)
8111a09c:	e0bff947 	ldb	r2,-27(fp)
8111a0a0:	10800044 	addi	r2,r2,1
8111a0a4:	1885883a 	add	r2,r3,r2
8111a0a8:	10800003 	ldbu	r2,0(r2)
8111a0ac:	10803fcc 	andi	r2,r2,255
8111a0b0:	1080010c 	andi	r2,r2,4
8111a0b4:	10000626 	beq	r2,zero,8111a0d0 <vLoadDefaultETHConf+0x72c>
									(*p_inteiro) = c;
8111a0b8:	e0bffa17 	ldw	r2,-24(fp)
8111a0bc:	e0fff943 	ldbu	r3,-27(fp)
8111a0c0:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111a0c4:	e0bffa17 	ldw	r2,-24(fp)
8111a0c8:	10800044 	addi	r2,r2,1
8111a0cc:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111a0d0:	e0bff947 	ldb	r2,-27(fp)
8111a0d4:	10800ba0 	cmpeqi	r2,r2,46
8111a0d8:	1000031e 	bne	r2,zero,8111a0e8 <vLoadDefaultETHConf+0x744>
8111a0dc:	e0bff947 	ldb	r2,-27(fp)
8111a0e0:	10800ed8 	cmpnei	r2,r2,59
8111a0e4:	103fe81e 	bne	r2,zero,8111a088 <__reset+0xfb0fa088>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111a0e8:	e0bffa17 	ldw	r2,-24(fp)
8111a0ec:	00c00284 	movi	r3,10
8111a0f0:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucDNS[min_sim(ucParser,3)] = atoi( inteiro );
8111a0f4:	e0bff903 	ldbu	r2,-28(fp)
8111a0f8:	108000e8 	cmpgeui	r2,r2,3
8111a0fc:	1000021e 	bne	r2,zero,8111a108 <vLoadDefaultETHConf+0x764>
8111a100:	e43ff903 	ldbu	r16,-28(fp)
8111a104:	00000106 	br	8111a10c <vLoadDefaultETHConf+0x768>
8111a108:	040000c4 	movi	r16,3
8111a10c:	e0bffd04 	addi	r2,fp,-12
8111a110:	1009883a 	mov	r4,r2
8111a114:	112146c0 	call	8112146c <atoi>
8111a118:	1007883a 	mov	r3,r2
8111a11c:	00a045b4 	movhi	r2,33046
8111a120:	109c1104 	addi	r2,r2,28740
8111a124:	1405883a 	add	r2,r2,r16
8111a128:	10800304 	addi	r2,r2,12
8111a12c:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111a130:	e0bffd04 	addi	r2,fp,-12
8111a134:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111a138:	e0bff903 	ldbu	r2,-28(fp)
8111a13c:	10800044 	addi	r2,r2,1
8111a140:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111a144:	e0bff947 	ldb	r2,-27(fp)
8111a148:	10800ed8 	cmpnei	r2,r2,59
8111a14c:	103fce1e 	bne	r2,zero,8111a088 <__reset+0xfb0fa088>

						break;						
8111a150:	00001b06 	br	8111a1c0 <vLoadDefaultETHConf+0x81c>
					case 0x3C: //"<"
						close = siCloseFile(siFile);
8111a154:	e0bffc0f 	ldh	r2,-16(fp)
8111a158:	1009883a 	mov	r4,r2
8111a15c:	111eb600 	call	8111eb60 <siCloseFile>
8111a160:	e0bffb15 	stw	r2,-20(fp)
						if (close == FALSE){
8111a164:	e0bffb17 	ldw	r2,-20(fp)
8111a168:	1000071e 	bne	r2,zero,8111a188 <vLoadDefaultETHConf+0x7e4>
							#ifdef DEBUG_ON
								debug(fp,"SDCard: Can't close the file.\n");
8111a16c:	d0a06217 	ldw	r2,-32376(gp)
8111a170:	100f883a 	mov	r7,r2
8111a174:	01800784 	movi	r6,30
8111a178:	01400044 	movi	r5,1
8111a17c:	01204574 	movhi	r4,33045
8111a180:	213b8704 	addi	r4,r4,-4580
8111a184:	1121c7c0 	call	81121c7c <fwrite>
							#endif
						}
						/* End of Parser File */
						bEOF = TRUE;
8111a188:	00800044 	movi	r2,1
8111a18c:	e0bff815 	stw	r2,-32(fp)
						bSuccess = TRUE; //pensar melhor
8111a190:	00800044 	movi	r2,1
8111a194:	e0bff715 	stw	r2,-36(fp)
						break;
8111a198:	00000906 	br	8111a1c0 <vLoadDefaultETHConf+0x81c>
					default:
						#ifdef DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
8111a19c:	d0a06217 	ldw	r2,-32376(gp)
8111a1a0:	100f883a 	mov	r7,r2
8111a1a4:	01800844 	movi	r6,33
8111a1a8:	01400044 	movi	r5,1
8111a1ac:	01204574 	movhi	r4,33045
8111a1b0:	213b8f04 	addi	r4,r4,-4548
8111a1b4:	1121c7c0 	call	81121c7c <fwrite>
						#endif
						break;
8111a1b8:	00000106 	br	8111a1c0 <vLoadDefaultETHConf+0x81c>
						bEOF = TRUE;
						break;
					case 0x20: 	//ASCII: 0x20 = space
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
8111a1bc:	0001883a 	nop
						#ifdef DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
						#endif
						break;
				}
			} while ( bEOF == FALSE );
8111a1c0:	e0bff817 	ldw	r2,-32(fp)
8111a1c4:	103e1526 	beq	r2,zero,81119a1c <__reset+0xfb0f9a1c>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( ETH_FILE_NAME );

		if ( siFile >= 0 ){
8111a1c8:	00000f06 	br	8111a208 <vLoadDefaultETHConf+0x864>
						break;
				}
			} while ( bEOF == FALSE );
		} else {
			#ifdef DEBUG_ON
				fprintf(fp,"SDCard: File not found.\n");
8111a1cc:	d0a06217 	ldw	r2,-32376(gp)
8111a1d0:	100f883a 	mov	r7,r2
8111a1d4:	01800604 	movi	r6,24
8111a1d8:	01400044 	movi	r5,1
8111a1dc:	01204574 	movhi	r4,33045
8111a1e0:	213b9804 	addi	r4,r4,-4512
8111a1e4:	1121c7c0 	call	81121c7c <fwrite>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( ETH_FILE_NAME );

		if ( siFile >= 0 ){
8111a1e8:	00000706 	br	8111a208 <vLoadDefaultETHConf+0x864>
				fprintf(fp,"SDCard: File not found.\n");
			#endif
		}
	} else {
		#ifdef DEBUG_ON
			fprintf(fp,"SDCard: No SDCard.\n");
8111a1ec:	d0a06217 	ldw	r2,-32376(gp)
8111a1f0:	100f883a 	mov	r7,r2
8111a1f4:	018004c4 	movi	r6,19
8111a1f8:	01400044 	movi	r5,1
8111a1fc:	01204574 	movhi	r4,33045
8111a200:	213b9f04 	addi	r4,r4,-4484
8111a204:	1121c7c0 	call	81121c7c <fwrite>
		#endif
	}
	/* Load the default configuration if not successful in read the SDCard */
	if ( bSuccess == FALSE ) {
8111a208:	e0bff717 	ldw	r2,-36(fp)
8111a20c:	1000541e 	bne	r2,zero,8111a360 <vLoadDefaultETHConf+0x9bc>
		/*Enviar mensagem que e gravar log que no encontrou o arquivo e comeara a utilizar o padrao*/
		printf("Ateno: Arquivo de conexo no foi encontrado. Carregando conf padrao\n");
8111a210:	01204574 	movhi	r4,33045
8111a214:	213ba404 	addi	r4,r4,-4464
8111a218:	1122c2c0 	call	81122c2c <puts>
		printf("No encontrou:'%s'.\n", ETH_FILE_NAME);
8111a21c:	01604574 	movhi	r5,33045
8111a220:	297b7e04 	addi	r5,r5,-4616
8111a224:	01204574 	movhi	r4,33045
8111a228:	213bb804 	addi	r4,r4,-4384
8111a22c:	11229a80 	call	811229a8 <printf>


		xConfEth.siPortPUS = 17000;
8111a230:	00a045b4 	movhi	r2,33046
8111a234:	109c1104 	addi	r2,r2,28740
8111a238:	00d09a04 	movi	r3,17000
8111a23c:	10c0058d 	sth	r3,22(r2)
		/*ucIP[0].ucIP[1].ucIP[2].ucIP[3]
		 *192.168.0.5*/
		xConfEth.ucIP[0] = 192;
8111a240:	00a045b4 	movhi	r2,33046
8111a244:	109c1104 	addi	r2,r2,28740
8111a248:	00fff004 	movi	r3,-64
8111a24c:	10c00005 	stb	r3,0(r2)
		xConfEth.ucIP[1] = 168;
8111a250:	00a045b4 	movhi	r2,33046
8111a254:	109c1104 	addi	r2,r2,28740
8111a258:	00ffea04 	movi	r3,-88
8111a25c:	10c00045 	stb	r3,1(r2)
		xConfEth.ucIP[2] = 0;
8111a260:	00a045b4 	movhi	r2,33046
8111a264:	109c1104 	addi	r2,r2,28740
8111a268:	10000085 	stb	zero,2(r2)
		xConfEth.ucIP[3] = 5;
8111a26c:	00a045b4 	movhi	r2,33046
8111a270:	109c1104 	addi	r2,r2,28740
8111a274:	00c00144 	movi	r3,5
8111a278:	10c000c5 	stb	r3,3(r2)

		/*ucGTW[0].ucGTW[1].ucGTW[2].ucGTW[3]
		 *192.168.0.1*/
		xConfEth.ucGTW[0] = 192;
8111a27c:	00a045b4 	movhi	r2,33046
8111a280:	109c1104 	addi	r2,r2,28740
8111a284:	00fff004 	movi	r3,-64
8111a288:	10c00105 	stb	r3,4(r2)
		xConfEth.ucGTW[1] = 168;
8111a28c:	00a045b4 	movhi	r2,33046
8111a290:	109c1104 	addi	r2,r2,28740
8111a294:	00ffea04 	movi	r3,-88
8111a298:	10c00145 	stb	r3,5(r2)
		xConfEth.ucGTW[2] = 0;
8111a29c:	00a045b4 	movhi	r2,33046
8111a2a0:	109c1104 	addi	r2,r2,28740
8111a2a4:	10000185 	stb	zero,6(r2)
		xConfEth.ucGTW[3] = 1;
8111a2a8:	00a045b4 	movhi	r2,33046
8111a2ac:	109c1104 	addi	r2,r2,28740
8111a2b0:	00c00044 	movi	r3,1
8111a2b4:	10c001c5 	stb	r3,7(r2)

		/*ucSubNet[0].ucSubNet[1].ucSubNet[2].ucSubNet[3]
		 *192.168.0.5*/
		xConfEth.ucSubNet[0] = 255;
8111a2b8:	00a045b4 	movhi	r2,33046
8111a2bc:	109c1104 	addi	r2,r2,28740
8111a2c0:	00ffffc4 	movi	r3,-1
8111a2c4:	10c00205 	stb	r3,8(r2)
		xConfEth.ucSubNet[1] = 255;
8111a2c8:	00a045b4 	movhi	r2,33046
8111a2cc:	109c1104 	addi	r2,r2,28740
8111a2d0:	00ffffc4 	movi	r3,-1
8111a2d4:	10c00245 	stb	r3,9(r2)
		xConfEth.ucSubNet[2] = 255;
8111a2d8:	00a045b4 	movhi	r2,33046
8111a2dc:	109c1104 	addi	r2,r2,28740
8111a2e0:	00ffffc4 	movi	r3,-1
8111a2e4:	10c00285 	stb	r3,10(r2)
		xConfEth.ucSubNet[3] = 0;
8111a2e8:	00a045b4 	movhi	r2,33046
8111a2ec:	109c1104 	addi	r2,r2,28740
8111a2f0:	100002c5 	stb	zero,11(r2)


		/*ucMAC[0]:ucMAC[1]:ucMAC[2]:ucMAC[3]:ucMAC[4]:ucMAC[5]
		 *fc:f7:63:4d:1f:42*/
		xConfEth.ucMAC[0] = 0xFC;
8111a2f4:	00a045b4 	movhi	r2,33046
8111a2f8:	109c1104 	addi	r2,r2,28740
8111a2fc:	00ffff04 	movi	r3,-4
8111a300:	10c00405 	stb	r3,16(r2)
		xConfEth.ucMAC[1] = 0xF7;
8111a304:	00a045b4 	movhi	r2,33046
8111a308:	109c1104 	addi	r2,r2,28740
8111a30c:	00fffdc4 	movi	r3,-9
8111a310:	10c00445 	stb	r3,17(r2)
		xConfEth.ucMAC[2] = 0x63;
8111a314:	00a045b4 	movhi	r2,33046
8111a318:	109c1104 	addi	r2,r2,28740
8111a31c:	00c018c4 	movi	r3,99
8111a320:	10c00485 	stb	r3,18(r2)
		xConfEth.ucMAC[3] = 0x4D;
8111a324:	00a045b4 	movhi	r2,33046
8111a328:	109c1104 	addi	r2,r2,28740
8111a32c:	00c01344 	movi	r3,77
8111a330:	10c004c5 	stb	r3,19(r2)
		xConfEth.ucMAC[4] = 0x1F;
8111a334:	00a045b4 	movhi	r2,33046
8111a338:	109c1104 	addi	r2,r2,28740
8111a33c:	00c007c4 	movi	r3,31
8111a340:	10c00505 	stb	r3,20(r2)
		xConfEth.ucMAC[5] = 0x42;
8111a344:	00a045b4 	movhi	r2,33046
8111a348:	109c1104 	addi	r2,r2,28740
8111a34c:	00c01084 	movi	r3,66
8111a350:	10c00545 	stb	r3,21(r2)

		xConfEth.bDHCP = FALSE;
8111a354:	00a045b4 	movhi	r2,33046
8111a358:	109c1104 	addi	r2,r2,28740
8111a35c:	10000615 	stw	zero,24(r2)

	}

	return bSuccess;
8111a360:	e0bff717 	ldw	r2,-36(fp)
}
8111a364:	e6ffff04 	addi	sp,fp,-4
8111a368:	dfc00217 	ldw	ra,8(sp)
8111a36c:	df000117 	ldw	fp,4(sp)
8111a370:	dc000017 	ldw	r16,0(sp)
8111a374:	dec00304 	addi	sp,sp,12
8111a378:	f800283a 	ret

8111a37c <vShowEthConfig>:

#ifdef DEBUG_ON
	void vShowEthConfig( void ) {
8111a37c:	defff004 	addi	sp,sp,-64
8111a380:	de00012e 	bgeu	sp,et,8111a388 <vShowEthConfig+0xc>
8111a384:	003b68fa 	trap	3
8111a388:	dfc00f15 	stw	ra,60(sp)
8111a38c:	df000e15 	stw	fp,56(sp)
8111a390:	df000e04 	addi	fp,sp,56
		char buffer[40];

		debug(fp, "Ethernet loaded configuration.\n");
8111a394:	d0a06217 	ldw	r2,-32376(gp)
8111a398:	100f883a 	mov	r7,r2
8111a39c:	018007c4 	movi	r6,31
8111a3a0:	01400044 	movi	r5,1
8111a3a4:	01204574 	movhi	r4,33045
8111a3a8:	213bbe04 	addi	r4,r4,-4360
8111a3ac:	1121c7c0 	call	81121c7c <fwrite>

		memset(buffer,0,40);
8111a3b0:	01800a04 	movi	r6,40
8111a3b4:	000b883a 	mov	r5,zero
8111a3b8:	e13ff604 	addi	r4,fp,-40
8111a3bc:	11227e00 	call	811227e0 <memset>
		sprintf(buffer, "MAC: %x : %x : %x : %x : %x : %x \n", xConfEth.ucMAC[0], xConfEth.ucMAC[1], xConfEth.ucMAC[2], xConfEth.ucMAC[3], xConfEth.ucMAC[4], xConfEth.ucMAC[5]);
8111a3c0:	00a045b4 	movhi	r2,33046
8111a3c4:	109c1104 	addi	r2,r2,28740
8111a3c8:	10800403 	ldbu	r2,16(r2)
8111a3cc:	11803fcc 	andi	r6,r2,255
8111a3d0:	00a045b4 	movhi	r2,33046
8111a3d4:	109c1104 	addi	r2,r2,28740
8111a3d8:	10800443 	ldbu	r2,17(r2)
8111a3dc:	11c03fcc 	andi	r7,r2,255
8111a3e0:	00a045b4 	movhi	r2,33046
8111a3e4:	109c1104 	addi	r2,r2,28740
8111a3e8:	10800483 	ldbu	r2,18(r2)
8111a3ec:	10c03fcc 	andi	r3,r2,255
8111a3f0:	00a045b4 	movhi	r2,33046
8111a3f4:	109c1104 	addi	r2,r2,28740
8111a3f8:	108004c3 	ldbu	r2,19(r2)
8111a3fc:	11003fcc 	andi	r4,r2,255
8111a400:	00a045b4 	movhi	r2,33046
8111a404:	109c1104 	addi	r2,r2,28740
8111a408:	10800503 	ldbu	r2,20(r2)
8111a40c:	11403fcc 	andi	r5,r2,255
8111a410:	00a045b4 	movhi	r2,33046
8111a414:	109c1104 	addi	r2,r2,28740
8111a418:	10800543 	ldbu	r2,21(r2)
8111a41c:	10803fcc 	andi	r2,r2,255
8111a420:	d8800315 	stw	r2,12(sp)
8111a424:	d9400215 	stw	r5,8(sp)
8111a428:	d9000115 	stw	r4,4(sp)
8111a42c:	d8c00015 	stw	r3,0(sp)
8111a430:	01604574 	movhi	r5,33045
8111a434:	297bc604 	addi	r5,r5,-4328
8111a438:	e13ff604 	addi	r4,fp,-40
8111a43c:	1122f700 	call	81122f70 <sprintf>
		debug(fp, buffer );
8111a440:	d0a06217 	ldw	r2,-32376(gp)
8111a444:	e17ff604 	addi	r5,fp,-40
8111a448:	1009883a 	mov	r4,r2
8111a44c:	11215e00 	call	811215e0 <fprintf>

		memset(buffer,0,40);
8111a450:	01800a04 	movi	r6,40
8111a454:	000b883a 	mov	r5,zero
8111a458:	e13ff604 	addi	r4,fp,-40
8111a45c:	11227e00 	call	811227e0 <memset>
		sprintf(buffer, "IP: %i . %i . %i . %i \n",xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3] );
8111a460:	00a045b4 	movhi	r2,33046
8111a464:	109c1104 	addi	r2,r2,28740
8111a468:	10800003 	ldbu	r2,0(r2)
8111a46c:	11003fcc 	andi	r4,r2,255
8111a470:	00a045b4 	movhi	r2,33046
8111a474:	109c1104 	addi	r2,r2,28740
8111a478:	10800043 	ldbu	r2,1(r2)
8111a47c:	11403fcc 	andi	r5,r2,255
8111a480:	00a045b4 	movhi	r2,33046
8111a484:	109c1104 	addi	r2,r2,28740
8111a488:	10800083 	ldbu	r2,2(r2)
8111a48c:	10c03fcc 	andi	r3,r2,255
8111a490:	00a045b4 	movhi	r2,33046
8111a494:	109c1104 	addi	r2,r2,28740
8111a498:	108000c3 	ldbu	r2,3(r2)
8111a49c:	10803fcc 	andi	r2,r2,255
8111a4a0:	d8800115 	stw	r2,4(sp)
8111a4a4:	d8c00015 	stw	r3,0(sp)
8111a4a8:	280f883a 	mov	r7,r5
8111a4ac:	200d883a 	mov	r6,r4
8111a4b0:	01604574 	movhi	r5,33045
8111a4b4:	297bcf04 	addi	r5,r5,-4292
8111a4b8:	e13ff604 	addi	r4,fp,-40
8111a4bc:	1122f700 	call	81122f70 <sprintf>
		debug(fp, buffer );
8111a4c0:	d0a06217 	ldw	r2,-32376(gp)
8111a4c4:	e17ff604 	addi	r5,fp,-40
8111a4c8:	1009883a 	mov	r4,r2
8111a4cc:	11215e00 	call	811215e0 <fprintf>

		memset(buffer,0,40);
8111a4d0:	01800a04 	movi	r6,40
8111a4d4:	000b883a 	mov	r5,zero
8111a4d8:	e13ff604 	addi	r4,fp,-40
8111a4dc:	11227e00 	call	811227e0 <memset>
		sprintf(buffer, "GTW: %i . %i . %i . %i \n",xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3] );
8111a4e0:	00a045b4 	movhi	r2,33046
8111a4e4:	109c1104 	addi	r2,r2,28740
8111a4e8:	10800103 	ldbu	r2,4(r2)
8111a4ec:	11003fcc 	andi	r4,r2,255
8111a4f0:	00a045b4 	movhi	r2,33046
8111a4f4:	109c1104 	addi	r2,r2,28740
8111a4f8:	10800143 	ldbu	r2,5(r2)
8111a4fc:	11403fcc 	andi	r5,r2,255
8111a500:	00a045b4 	movhi	r2,33046
8111a504:	109c1104 	addi	r2,r2,28740
8111a508:	10800183 	ldbu	r2,6(r2)
8111a50c:	10c03fcc 	andi	r3,r2,255
8111a510:	00a045b4 	movhi	r2,33046
8111a514:	109c1104 	addi	r2,r2,28740
8111a518:	108001c3 	ldbu	r2,7(r2)
8111a51c:	10803fcc 	andi	r2,r2,255
8111a520:	d8800115 	stw	r2,4(sp)
8111a524:	d8c00015 	stw	r3,0(sp)
8111a528:	280f883a 	mov	r7,r5
8111a52c:	200d883a 	mov	r6,r4
8111a530:	01604574 	movhi	r5,33045
8111a534:	297bd504 	addi	r5,r5,-4268
8111a538:	e13ff604 	addi	r4,fp,-40
8111a53c:	1122f700 	call	81122f70 <sprintf>
		debug(fp, buffer );
8111a540:	d0a06217 	ldw	r2,-32376(gp)
8111a544:	e17ff604 	addi	r5,fp,-40
8111a548:	1009883a 	mov	r4,r2
8111a54c:	11215e00 	call	811215e0 <fprintf>

		memset(buffer,0,40);
8111a550:	01800a04 	movi	r6,40
8111a554:	000b883a 	mov	r5,zero
8111a558:	e13ff604 	addi	r4,fp,-40
8111a55c:	11227e00 	call	811227e0 <memset>
		sprintf(buffer, "Sub: %i . %i . %i . %i \n",xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3] );
8111a560:	00a045b4 	movhi	r2,33046
8111a564:	109c1104 	addi	r2,r2,28740
8111a568:	10800203 	ldbu	r2,8(r2)
8111a56c:	11003fcc 	andi	r4,r2,255
8111a570:	00a045b4 	movhi	r2,33046
8111a574:	109c1104 	addi	r2,r2,28740
8111a578:	10800243 	ldbu	r2,9(r2)
8111a57c:	11403fcc 	andi	r5,r2,255
8111a580:	00a045b4 	movhi	r2,33046
8111a584:	109c1104 	addi	r2,r2,28740
8111a588:	10800283 	ldbu	r2,10(r2)
8111a58c:	10c03fcc 	andi	r3,r2,255
8111a590:	00a045b4 	movhi	r2,33046
8111a594:	109c1104 	addi	r2,r2,28740
8111a598:	108002c3 	ldbu	r2,11(r2)
8111a59c:	10803fcc 	andi	r2,r2,255
8111a5a0:	d8800115 	stw	r2,4(sp)
8111a5a4:	d8c00015 	stw	r3,0(sp)
8111a5a8:	280f883a 	mov	r7,r5
8111a5ac:	200d883a 	mov	r6,r4
8111a5b0:	01604574 	movhi	r5,33045
8111a5b4:	297bdc04 	addi	r5,r5,-4240
8111a5b8:	e13ff604 	addi	r4,fp,-40
8111a5bc:	1122f700 	call	81122f70 <sprintf>
		debug(fp, buffer );
8111a5c0:	d0a06217 	ldw	r2,-32376(gp)
8111a5c4:	e17ff604 	addi	r5,fp,-40
8111a5c8:	1009883a 	mov	r4,r2
8111a5cc:	11215e00 	call	811215e0 <fprintf>

		memset(buffer,0,40);
8111a5d0:	01800a04 	movi	r6,40
8111a5d4:	000b883a 	mov	r5,zero
8111a5d8:	e13ff604 	addi	r4,fp,-40
8111a5dc:	11227e00 	call	811227e0 <memset>
		sprintf(buffer, "DNS: %i . %i . %i . %i \n",xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3] );
8111a5e0:	00a045b4 	movhi	r2,33046
8111a5e4:	109c1104 	addi	r2,r2,28740
8111a5e8:	10800303 	ldbu	r2,12(r2)
8111a5ec:	11003fcc 	andi	r4,r2,255
8111a5f0:	00a045b4 	movhi	r2,33046
8111a5f4:	109c1104 	addi	r2,r2,28740
8111a5f8:	10800343 	ldbu	r2,13(r2)
8111a5fc:	11403fcc 	andi	r5,r2,255
8111a600:	00a045b4 	movhi	r2,33046
8111a604:	109c1104 	addi	r2,r2,28740
8111a608:	10800383 	ldbu	r2,14(r2)
8111a60c:	10c03fcc 	andi	r3,r2,255
8111a610:	00a045b4 	movhi	r2,33046
8111a614:	109c1104 	addi	r2,r2,28740
8111a618:	108003c3 	ldbu	r2,15(r2)
8111a61c:	10803fcc 	andi	r2,r2,255
8111a620:	d8800115 	stw	r2,4(sp)
8111a624:	d8c00015 	stw	r3,0(sp)
8111a628:	280f883a 	mov	r7,r5
8111a62c:	200d883a 	mov	r6,r4
8111a630:	01604574 	movhi	r5,33045
8111a634:	297be304 	addi	r5,r5,-4212
8111a638:	e13ff604 	addi	r4,fp,-40
8111a63c:	1122f700 	call	81122f70 <sprintf>
		debug(fp, buffer );
8111a640:	d0a06217 	ldw	r2,-32376(gp)
8111a644:	e17ff604 	addi	r5,fp,-40
8111a648:	1009883a 	mov	r4,r2
8111a64c:	11215e00 	call	811215e0 <fprintf>

		memset(buffer,0,40);
8111a650:	01800a04 	movi	r6,40
8111a654:	000b883a 	mov	r5,zero
8111a658:	e13ff604 	addi	r4,fp,-40
8111a65c:	11227e00 	call	811227e0 <memset>
		sprintf(buffer, "Porta PUS: %i\n", xConfEth.siPortPUS );
8111a660:	00a045b4 	movhi	r2,33046
8111a664:	109c1104 	addi	r2,r2,28740
8111a668:	1080058b 	ldhu	r2,22(r2)
8111a66c:	10bfffcc 	andi	r2,r2,65535
8111a670:	100d883a 	mov	r6,r2
8111a674:	01604574 	movhi	r5,33045
8111a678:	297bea04 	addi	r5,r5,-4184
8111a67c:	e13ff604 	addi	r4,fp,-40
8111a680:	1122f700 	call	81122f70 <sprintf>
		debug(fp, buffer );
8111a684:	d0a06217 	ldw	r2,-32376(gp)
8111a688:	e17ff604 	addi	r5,fp,-40
8111a68c:	1009883a 	mov	r4,r2
8111a690:	11215e00 	call	811215e0 <fprintf>

	}
8111a694:	0001883a 	nop
8111a698:	e037883a 	mov	sp,fp
8111a69c:	dfc00117 	ldw	ra,4(sp)
8111a6a0:	df000017 	ldw	fp,0(sp)
8111a6a4:	dec00204 	addi	sp,sp,8
8111a6a8:	f800283a 	ret

8111a6ac <vLoadDebugConfs>:
#endif




bool vLoadDebugConfs( void ){
8111a6ac:	deffef04 	addi	sp,sp,-68
8111a6b0:	de00012e 	bgeu	sp,et,8111a6b8 <vLoadDebugConfs+0xc>
8111a6b4:	003b68fa 	trap	3
8111a6b8:	dfc01015 	stw	ra,64(sp)
8111a6bc:	df000f15 	stw	fp,60(sp)
8111a6c0:	dc000e15 	stw	r16,56(sp)
8111a6c4:	df000f04 	addi	fp,sp,60
	short int siFile, sidhcpTemp;
	bool bSuccess = FALSE;
8111a6c8:	e03ff115 	stw	zero,-60(fp)
	bool bEOF = FALSE;
8111a6cc:	e03ff215 	stw	zero,-56(fp)
	bool close = FALSE;
8111a6d0:	e03ff515 	stw	zero,-44(fp)
	char c, *p_inteiro;
	char inteiro[8];
	char inteiroll[24];


	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){
8111a6d4:	d0a07617 	ldw	r2,-32296(gp)
8111a6d8:	10800058 	cmpnei	r2,r2,1
8111a6dc:	10039e1e 	bne	r2,zero,8111b558 <vLoadDebugConfs+0xeac>
8111a6e0:	111e9cc0 	call	8111e9cc <bSDcardIsPresent>
8111a6e4:	10039c26 	beq	r2,zero,8111b558 <vLoadDebugConfs+0xeac>
8111a6e8:	111e9fc0 	call	8111e9fc <bSDcardFAT16Check>
8111a6ec:	10039a26 	beq	r2,zero,8111b558 <vLoadDebugConfs+0xeac>

		siFile = siOpenFile( DEBUG_FILE_NAME );
8111a6f0:	01204574 	movhi	r4,33045
8111a6f4:	213bee04 	addi	r4,r4,-4168
8111a6f8:	111eb240 	call	8111eb24 <siOpenFile>
8111a6fc:	e0bff60d 	sth	r2,-40(fp)

		if ( siFile >= 0 ){
8111a700:	e0bff60f 	ldh	r2,-40(fp)
8111a704:	10038c16 	blt	r2,zero,8111b538 <vLoadDebugConfs+0xe8c>

			memset( &(inteiro) , 10 , sizeof( inteiro ) );
8111a708:	e0bff704 	addi	r2,fp,-36
8111a70c:	01800204 	movi	r6,8
8111a710:	01400284 	movi	r5,10
8111a714:	1009883a 	mov	r4,r2
8111a718:	11227e00 	call	811227e0 <memset>
			memset( &(inteiroll) , 10 , sizeof( inteiroll ) );
8111a71c:	e0bff904 	addi	r2,fp,-28
8111a720:	01800604 	movi	r6,24
8111a724:	01400284 	movi	r5,10
8111a728:	1009883a 	mov	r4,r2
8111a72c:	11227e00 	call	811227e0 <memset>
			p_inteiro = inteiro;
8111a730:	e0bff704 	addi	r2,fp,-36
8111a734:	e0bff415 	stw	r2,-48(fp)

			do {
				c = cGetNextChar(siFile);
8111a738:	e0bff60f 	ldh	r2,-40(fp)
8111a73c:	1009883a 	mov	r4,r2
8111a740:	111eba00 	call	8111eba0 <cGetNextChar>
8111a744:	e0bff345 	stb	r2,-51(fp)
				//printf("%c \n", c);
				switch (c) {
8111a748:	e0bff347 	ldb	r2,-51(fp)
8111a74c:	10800084 	addi	r2,r2,2
8111a750:	10c01768 	cmpgeui	r3,r2,93
8111a754:	18036c1e 	bne	r3,zero,8111b508 <vLoadDebugConfs+0xe5c>
8111a758:	100690ba 	slli	r3,r2,2
8111a75c:	00a044b4 	movhi	r2,33042
8111a760:	10a9dc04 	addi	r2,r2,-22672
8111a764:	1885883a 	add	r2,r3,r2
8111a768:	10800017 	ldw	r2,0(r2)
8111a76c:	1000683a 	jmp	r2
8111a770:	8111a924 	muli	r4,r16,18084
8111a774:	8111a918 	cmpnei	r4,r16,18084
8111a778:	8111b508 	cmpgei	r4,r16,18132
8111a77c:	8111b508 	cmpgei	r4,r16,18132
8111a780:	8111b508 	cmpgei	r4,r16,18132
8111a784:	8111b508 	cmpgei	r4,r16,18132
8111a788:	8111b508 	cmpgei	r4,r16,18132
8111a78c:	8111b508 	cmpgei	r4,r16,18132
8111a790:	8111b508 	cmpgei	r4,r16,18132
8111a794:	8111b508 	cmpgei	r4,r16,18132
8111a798:	8111b508 	cmpgei	r4,r16,18132
8111a79c:	8111b508 	cmpgei	r4,r16,18132
8111a7a0:	8111b528 	cmpgeui	r4,r16,18132
8111a7a4:	8111b508 	cmpgei	r4,r16,18132
8111a7a8:	8111b508 	cmpgei	r4,r16,18132
8111a7ac:	8111b528 	cmpgeui	r4,r16,18132
8111a7b0:	8111b508 	cmpgei	r4,r16,18132
8111a7b4:	8111b508 	cmpgei	r4,r16,18132
8111a7b8:	8111b508 	cmpgei	r4,r16,18132
8111a7bc:	8111b508 	cmpgei	r4,r16,18132
8111a7c0:	8111b508 	cmpgei	r4,r16,18132
8111a7c4:	8111b508 	cmpgei	r4,r16,18132
8111a7c8:	8111b508 	cmpgei	r4,r16,18132
8111a7cc:	8111b508 	cmpgei	r4,r16,18132
8111a7d0:	8111b508 	cmpgei	r4,r16,18132
8111a7d4:	8111b508 	cmpgei	r4,r16,18132
8111a7d8:	8111b508 	cmpgei	r4,r16,18132
8111a7dc:	8111b508 	cmpgei	r4,r16,18132
8111a7e0:	8111b508 	cmpgei	r4,r16,18132
8111a7e4:	8111b508 	cmpgei	r4,r16,18132
8111a7e8:	8111b508 	cmpgei	r4,r16,18132
8111a7ec:	8111b508 	cmpgei	r4,r16,18132
8111a7f0:	8111b508 	cmpgei	r4,r16,18132
8111a7f4:	8111b508 	cmpgei	r4,r16,18132
8111a7f8:	8111b528 	cmpgeui	r4,r16,18132
8111a7fc:	8111b508 	cmpgei	r4,r16,18132
8111a800:	8111b508 	cmpgei	r4,r16,18132
8111a804:	8111b508 	cmpgei	r4,r16,18132
8111a808:	8111b508 	cmpgei	r4,r16,18132
8111a80c:	8111b508 	cmpgei	r4,r16,18132
8111a810:	8111b508 	cmpgei	r4,r16,18132
8111a814:	8111a8e4 	muli	r4,r16,18083
8111a818:	8111b508 	cmpgei	r4,r16,18132
8111a81c:	8111b508 	cmpgei	r4,r16,18132
8111a820:	8111b508 	cmpgei	r4,r16,18132
8111a824:	8111b508 	cmpgei	r4,r16,18132
8111a828:	8111b508 	cmpgei	r4,r16,18132
8111a82c:	8111b508 	cmpgei	r4,r16,18132
8111a830:	8111b508 	cmpgei	r4,r16,18132
8111a834:	8111b508 	cmpgei	r4,r16,18132
8111a838:	8111b508 	cmpgei	r4,r16,18132
8111a83c:	8111b508 	cmpgei	r4,r16,18132
8111a840:	8111b508 	cmpgei	r4,r16,18132
8111a844:	8111b508 	cmpgei	r4,r16,18132
8111a848:	8111b508 	cmpgei	r4,r16,18132
8111a84c:	8111b508 	cmpgei	r4,r16,18132
8111a850:	8111b508 	cmpgei	r4,r16,18132
8111a854:	8111b508 	cmpgei	r4,r16,18132
8111a858:	8111b508 	cmpgei	r4,r16,18132
8111a85c:	8111b508 	cmpgei	r4,r16,18132
8111a860:	8111b508 	cmpgei	r4,r16,18132
8111a864:	8111b508 	cmpgei	r4,r16,18132
8111a868:	8111b4c0 	call	88111b4c <__reset+0x20f1b4c>
8111a86c:	8111b508 	cmpgei	r4,r16,18132
8111a870:	8111b508 	cmpgei	r4,r16,18132
8111a874:	8111b508 	cmpgei	r4,r16,18132
8111a878:	8111b508 	cmpgei	r4,r16,18132
8111a87c:	8111ac0c 	andi	r4,r16,18096
8111a880:	8111b1b8 	rdprs	r4,r16,18118
8111a884:	8111ae1c 	xori	r4,r16,18104
8111a888:	8111af98 	cmpnei	r4,r16,18110
8111a88c:	8111b508 	cmpgei	r4,r16,18132
8111a890:	8111b508 	cmpgei	r4,r16,18132
8111a894:	8111b508 	cmpgei	r4,r16,18132
8111a898:	8111aecc 	andi	r4,r16,18107
8111a89c:	8111b508 	cmpgei	r4,r16,18132
8111a8a0:	8111b130 	cmpltui	r4,r16,18116
8111a8a4:	8111b020 	cmpeqi	r4,r16,18112
8111a8a8:	8111acbc 	xorhi	r4,r16,18098
8111a8ac:	8111b0a8 	cmpgeui	r4,r16,18114
8111a8b0:	8111aaac 	andhi	r4,r16,18090
8111a8b4:	8111ad6c 	andhi	r4,r16,18101
8111a8b8:	8111a9fc 	xorhi	r4,r16,18087
8111a8bc:	8111b508 	cmpgei	r4,r16,18132
8111a8c0:	8111ab5c 	xori	r4,r16,18093
8111a8c4:	8111a94c 	andi	r4,r16,18085
8111a8c8:	8111b370 	cmpltui	r4,r16,18125
8111a8cc:	8111b2d8 	cmpnei	r4,r16,18123
8111a8d0:	8111b508 	cmpgei	r4,r16,18132
8111a8d4:	8111b240 	call	88111b24 <__reset+0x20f1b24>
8111a8d8:	8111b508 	cmpgei	r4,r16,18132
8111a8dc:	8111b508 	cmpgei	r4,r16,18132
8111a8e0:	8111b418 	cmpnei	r4,r16,18128
					case 39:// single quote '
						c = cGetNextChar(siFile);
8111a8e4:	e0bff60f 	ldh	r2,-40(fp)
8111a8e8:	1009883a 	mov	r4,r2
8111a8ec:	111eba00 	call	8111eba0 <cGetNextChar>
8111a8f0:	e0bff345 	stb	r2,-51(fp)
						while ( c != 39 ){
8111a8f4:	00000406 	br	8111a908 <vLoadDebugConfs+0x25c>
							c = cGetNextChar(siFile);
8111a8f8:	e0bff60f 	ldh	r2,-40(fp)
8111a8fc:	1009883a 	mov	r4,r2
8111a900:	111eba00 	call	8111eba0 <cGetNextChar>
8111a904:	e0bff345 	stb	r2,-51(fp)
				c = cGetNextChar(siFile);
				//printf("%c \n", c);
				switch (c) {
					case 39:// single quote '
						c = cGetNextChar(siFile);
						while ( c != 39 ){
8111a908:	e0bff347 	ldb	r2,-51(fp)
8111a90c:	108009d8 	cmpnei	r2,r2,39
8111a910:	103ff91e 	bne	r2,zero,8111a8f8 <__reset+0xfb0fa8f8>
							c = cGetNextChar(siFile);
						}
						break;
8111a914:	00030506 	br	8111b52c <vLoadDebugConfs+0xe80>
					case -1: 	//EOF
						bEOF = TRUE;
8111a918:	00800044 	movi	r2,1
8111a91c:	e0bff215 	stw	r2,-56(fp)
						break;
8111a920:	00030206 	br	8111b52c <vLoadDebugConfs+0xe80>
					case -2: 	//EOF
						#ifdef DEBUG_ON
							debug(fp,"SDCard: Problem with SDCard");
8111a924:	d0a06217 	ldw	r2,-32376(gp)
8111a928:	100f883a 	mov	r7,r2
8111a92c:	018006c4 	movi	r6,27
8111a930:	01400044 	movi	r5,1
8111a934:	01204574 	movhi	r4,33045
8111a938:	213b8004 	addi	r4,r4,-4608
8111a93c:	1121c7c0 	call	81121c7c <fwrite>
						#endif
						bEOF = TRUE;
8111a940:	00800044 	movi	r2,1
8111a944:	e0bff215 	stw	r2,-56(fp)
						break;
8111a948:	0002f806 	br	8111b52c <vLoadDebugConfs+0xe80>
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;

					case 'S':
						ucParser = 0;
8111a94c:	e03ff305 	stb	zero,-52(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111a950:	e0bff60f 	ldh	r2,-40(fp)
8111a954:	1009883a 	mov	r4,r2
8111a958:	111eba00 	call	8111eba0 <cGetNextChar>
8111a95c:	e0bff345 	stb	r2,-51(fp)
								if ( isdigit( c ) ) {
8111a960:	d0e00317 	ldw	r3,-32756(gp)
8111a964:	e0bff347 	ldb	r2,-51(fp)
8111a968:	10800044 	addi	r2,r2,1
8111a96c:	1885883a 	add	r2,r3,r2
8111a970:	10800003 	ldbu	r2,0(r2)
8111a974:	10803fcc 	andi	r2,r2,255
8111a978:	1080010c 	andi	r2,r2,4
8111a97c:	10000626 	beq	r2,zero,8111a998 <vLoadDebugConfs+0x2ec>
									(*p_inteiro) = c;
8111a980:	e0bff417 	ldw	r2,-48(fp)
8111a984:	e0fff343 	ldbu	r3,-51(fp)
8111a988:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111a98c:	e0bff417 	ldw	r2,-48(fp)
8111a990:	10800044 	addi	r2,r2,1
8111a994:	e0bff415 	stw	r2,-48(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111a998:	e0bff347 	ldb	r2,-51(fp)
8111a99c:	10800ba0 	cmpeqi	r2,r2,46
8111a9a0:	1000031e 	bne	r2,zero,8111a9b0 <vLoadDebugConfs+0x304>
8111a9a4:	e0bff347 	ldb	r2,-51(fp)
8111a9a8:	10800ed8 	cmpnei	r2,r2,59
8111a9ac:	103fe81e 	bne	r2,zero,8111a950 <__reset+0xfb0fa950>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111a9b0:	e0bff417 	ldw	r2,-48(fp)
8111a9b4:	00c00284 	movi	r3,10
8111a9b8:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiSyncPeriod = atoi( inteiro );
8111a9bc:	e0bff704 	addi	r2,fp,-36
8111a9c0:	1009883a 	mov	r4,r2
8111a9c4:	112146c0 	call	8112146c <atoi>
8111a9c8:	1007883a 	mov	r3,r2
8111a9cc:	00a045b4 	movhi	r2,33046
8111a9d0:	109c0004 	addi	r2,r2,28672
8111a9d4:	10c0068d 	sth	r3,26(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111a9d8:	e0bff704 	addi	r2,fp,-36
8111a9dc:	e0bff415 	stw	r2,-48(fp)
							ucParser++;
8111a9e0:	e0bff303 	ldbu	r2,-52(fp)
8111a9e4:	10800044 	addi	r2,r2,1
8111a9e8:	e0bff305 	stb	r2,-52(fp)
						} while ( (c !=59) );
8111a9ec:	e0bff347 	ldb	r2,-51(fp)
8111a9f0:	10800ed8 	cmpnei	r2,r2,59
8111a9f4:	103fd61e 	bne	r2,zero,8111a950 <__reset+0xfb0fa950>

						break;
8111a9f8:	0002cc06 	br	8111b52c <vLoadDebugConfs+0xe80>
					case 'P':
						ucParser = 0;
8111a9fc:	e03ff305 	stb	zero,-52(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111aa00:	e0bff60f 	ldh	r2,-40(fp)
8111aa04:	1009883a 	mov	r4,r2
8111aa08:	111eba00 	call	8111eba0 <cGetNextChar>
8111aa0c:	e0bff345 	stb	r2,-51(fp)
								if ( isdigit( c ) ) {
8111aa10:	d0e00317 	ldw	r3,-32756(gp)
8111aa14:	e0bff347 	ldb	r2,-51(fp)
8111aa18:	10800044 	addi	r2,r2,1
8111aa1c:	1885883a 	add	r2,r3,r2
8111aa20:	10800003 	ldbu	r2,0(r2)
8111aa24:	10803fcc 	andi	r2,r2,255
8111aa28:	1080010c 	andi	r2,r2,4
8111aa2c:	10000626 	beq	r2,zero,8111aa48 <vLoadDebugConfs+0x39c>
									(*p_inteiro) = c;
8111aa30:	e0bff417 	ldw	r2,-48(fp)
8111aa34:	e0fff343 	ldbu	r3,-51(fp)
8111aa38:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111aa3c:	e0bff417 	ldw	r2,-48(fp)
8111aa40:	10800044 	addi	r2,r2,1
8111aa44:	e0bff415 	stw	r2,-48(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111aa48:	e0bff347 	ldb	r2,-51(fp)
8111aa4c:	10800ba0 	cmpeqi	r2,r2,46
8111aa50:	1000031e 	bne	r2,zero,8111aa60 <vLoadDebugConfs+0x3b4>
8111aa54:	e0bff347 	ldb	r2,-51(fp)
8111aa58:	10800ed8 	cmpnei	r2,r2,59
8111aa5c:	103fe81e 	bne	r2,zero,8111aa00 <__reset+0xfb0faa00>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111aa60:	e0bff417 	ldw	r2,-48(fp)
8111aa64:	00c00284 	movi	r3,10
8111aa68:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiPreScanSerial = atoi( inteiro );
8111aa6c:	e0bff704 	addi	r2,fp,-36
8111aa70:	1009883a 	mov	r4,r2
8111aa74:	112146c0 	call	8112146c <atoi>
8111aa78:	1007883a 	mov	r3,r2
8111aa7c:	00a045b4 	movhi	r2,33046
8111aa80:	109c0004 	addi	r2,r2,28672
8111aa84:	10c0048d 	sth	r3,18(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111aa88:	e0bff704 	addi	r2,fp,-36
8111aa8c:	e0bff415 	stw	r2,-48(fp)
							ucParser++;
8111aa90:	e0bff303 	ldbu	r2,-52(fp)
8111aa94:	10800044 	addi	r2,r2,1
8111aa98:	e0bff305 	stb	r2,-52(fp)
						} while ( (c !=59) );
8111aa9c:	e0bff347 	ldb	r2,-51(fp)
8111aaa0:	10800ed8 	cmpnei	r2,r2,59
8111aaa4:	103fd61e 	bne	r2,zero,8111aa00 <__reset+0xfb0faa00>

						break;
8111aaa8:	0002a006 	br	8111b52c <vLoadDebugConfs+0xe80>
					case 'N':
						ucParser = 0;
8111aaac:	e03ff305 	stb	zero,-52(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111aab0:	e0bff60f 	ldh	r2,-40(fp)
8111aab4:	1009883a 	mov	r4,r2
8111aab8:	111eba00 	call	8111eba0 <cGetNextChar>
8111aabc:	e0bff345 	stb	r2,-51(fp)
								if ( isdigit( c ) ) {
8111aac0:	d0e00317 	ldw	r3,-32756(gp)
8111aac4:	e0bff347 	ldb	r2,-51(fp)
8111aac8:	10800044 	addi	r2,r2,1
8111aacc:	1885883a 	add	r2,r3,r2
8111aad0:	10800003 	ldbu	r2,0(r2)
8111aad4:	10803fcc 	andi	r2,r2,255
8111aad8:	1080010c 	andi	r2,r2,4
8111aadc:	10000626 	beq	r2,zero,8111aaf8 <vLoadDebugConfs+0x44c>
									(*p_inteiro) = c;
8111aae0:	e0bff417 	ldw	r2,-48(fp)
8111aae4:	e0fff343 	ldbu	r3,-51(fp)
8111aae8:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111aaec:	e0bff417 	ldw	r2,-48(fp)
8111aaf0:	10800044 	addi	r2,r2,1
8111aaf4:	e0bff415 	stw	r2,-48(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111aaf8:	e0bff347 	ldb	r2,-51(fp)
8111aafc:	10800ba0 	cmpeqi	r2,r2,46
8111ab00:	1000031e 	bne	r2,zero,8111ab10 <vLoadDebugConfs+0x464>
8111ab04:	e0bff347 	ldb	r2,-51(fp)
8111ab08:	10800ed8 	cmpnei	r2,r2,59
8111ab0c:	103fe81e 	bne	r2,zero,8111aab0 <__reset+0xfb0faab0>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111ab10:	e0bff417 	ldw	r2,-48(fp)
8111ab14:	00c00284 	movi	r3,10
8111ab18:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiOverScanSerial = atoi( inteiro );
8111ab1c:	e0bff704 	addi	r2,fp,-36
8111ab20:	1009883a 	mov	r4,r2
8111ab24:	112146c0 	call	8112146c <atoi>
8111ab28:	1007883a 	mov	r3,r2
8111ab2c:	00a045b4 	movhi	r2,33046
8111ab30:	109c0004 	addi	r2,r2,28672
8111ab34:	10c0040d 	sth	r3,16(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111ab38:	e0bff704 	addi	r2,fp,-36
8111ab3c:	e0bff415 	stw	r2,-48(fp)
							ucParser++;
8111ab40:	e0bff303 	ldbu	r2,-52(fp)
8111ab44:	10800044 	addi	r2,r2,1
8111ab48:	e0bff305 	stb	r2,-52(fp)
						} while ( (c !=59) );
8111ab4c:	e0bff347 	ldb	r2,-51(fp)
8111ab50:	10800ed8 	cmpnei	r2,r2,59
8111ab54:	103fd61e 	bne	r2,zero,8111aab0 <__reset+0xfb0faab0>

						break;
8111ab58:	00027406 	br	8111b52c <vLoadDebugConfs+0xe80>
					case 'R':
						ucParser = 0;
8111ab5c:	e03ff305 	stb	zero,-52(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111ab60:	e0bff60f 	ldh	r2,-40(fp)
8111ab64:	1009883a 	mov	r4,r2
8111ab68:	111eba00 	call	8111eba0 <cGetNextChar>
8111ab6c:	e0bff345 	stb	r2,-51(fp)
								if ( isdigit( c ) ) {
8111ab70:	d0e00317 	ldw	r3,-32756(gp)
8111ab74:	e0bff347 	ldb	r2,-51(fp)
8111ab78:	10800044 	addi	r2,r2,1
8111ab7c:	1885883a 	add	r2,r3,r2
8111ab80:	10800003 	ldbu	r2,0(r2)
8111ab84:	10803fcc 	andi	r2,r2,255
8111ab88:	1080010c 	andi	r2,r2,4
8111ab8c:	10000626 	beq	r2,zero,8111aba8 <vLoadDebugConfs+0x4fc>
									(*p_inteiro) = c;
8111ab90:	e0bff417 	ldw	r2,-48(fp)
8111ab94:	e0fff343 	ldbu	r3,-51(fp)
8111ab98:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111ab9c:	e0bff417 	ldw	r2,-48(fp)
8111aba0:	10800044 	addi	r2,r2,1
8111aba4:	e0bff415 	stw	r2,-48(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111aba8:	e0bff347 	ldb	r2,-51(fp)
8111abac:	10800ba0 	cmpeqi	r2,r2,46
8111abb0:	1000031e 	bne	r2,zero,8111abc0 <vLoadDebugConfs+0x514>
8111abb4:	e0bff347 	ldb	r2,-51(fp)
8111abb8:	10800ed8 	cmpnei	r2,r2,59
8111abbc:	103fe81e 	bne	r2,zero,8111ab60 <__reset+0xfb0fab60>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111abc0:	e0bff417 	ldw	r2,-48(fp)
8111abc4:	00c00284 	movi	r3,10
8111abc8:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.ucRmapKey = atoi( inteiro );
8111abcc:	e0bff704 	addi	r2,fp,-36
8111abd0:	1009883a 	mov	r4,r2
8111abd4:	112146c0 	call	8112146c <atoi>
8111abd8:	1007883a 	mov	r3,r2
8111abdc:	00a045b4 	movhi	r2,33046
8111abe0:	109c0004 	addi	r2,r2,28672
8111abe4:	10c00c0d 	sth	r3,48(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111abe8:	e0bff704 	addi	r2,fp,-36
8111abec:	e0bff415 	stw	r2,-48(fp)
							ucParser++;
8111abf0:	e0bff303 	ldbu	r2,-52(fp)
8111abf4:	10800044 	addi	r2,r2,1
8111abf8:	e0bff305 	stb	r2,-52(fp)
						} while ( (c !=59) );
8111abfc:	e0bff347 	ldb	r2,-51(fp)
8111ac00:	10800ed8 	cmpnei	r2,r2,59
8111ac04:	103fd61e 	bne	r2,zero,8111ab60 <__reset+0xfb0fab60>

						break;
8111ac08:	00024806 	br	8111b52c <vLoadDebugConfs+0xe80>
					case 'A':
						ucParser = 0;
8111ac0c:	e03ff305 	stb	zero,-52(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111ac10:	e0bff60f 	ldh	r2,-40(fp)
8111ac14:	1009883a 	mov	r4,r2
8111ac18:	111eba00 	call	8111eba0 <cGetNextChar>
8111ac1c:	e0bff345 	stb	r2,-51(fp)
								if ( isdigit( c ) ) {
8111ac20:	d0e00317 	ldw	r3,-32756(gp)
8111ac24:	e0bff347 	ldb	r2,-51(fp)
8111ac28:	10800044 	addi	r2,r2,1
8111ac2c:	1885883a 	add	r2,r3,r2
8111ac30:	10800003 	ldbu	r2,0(r2)
8111ac34:	10803fcc 	andi	r2,r2,255
8111ac38:	1080010c 	andi	r2,r2,4
8111ac3c:	10000626 	beq	r2,zero,8111ac58 <vLoadDebugConfs+0x5ac>
									(*p_inteiro) = c;
8111ac40:	e0bff417 	ldw	r2,-48(fp)
8111ac44:	e0fff343 	ldbu	r3,-51(fp)
8111ac48:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111ac4c:	e0bff417 	ldw	r2,-48(fp)
8111ac50:	10800044 	addi	r2,r2,1
8111ac54:	e0bff415 	stw	r2,-48(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111ac58:	e0bff347 	ldb	r2,-51(fp)
8111ac5c:	10800ba0 	cmpeqi	r2,r2,46
8111ac60:	1000031e 	bne	r2,zero,8111ac70 <vLoadDebugConfs+0x5c4>
8111ac64:	e0bff347 	ldb	r2,-51(fp)
8111ac68:	10800ed8 	cmpnei	r2,r2,59
8111ac6c:	103fe81e 	bne	r2,zero,8111ac10 <__reset+0xfb0fac10>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111ac70:	e0bff417 	ldw	r2,-48(fp)
8111ac74:	00c00284 	movi	r3,10
8111ac78:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.ucLogicalAddr = atoi( inteiro );
8111ac7c:	e0bff704 	addi	r2,fp,-36
8111ac80:	1009883a 	mov	r4,r2
8111ac84:	112146c0 	call	8112146c <atoi>
8111ac88:	1007883a 	mov	r3,r2
8111ac8c:	00a045b4 	movhi	r2,33046
8111ac90:	109c0004 	addi	r2,r2,28672
8111ac94:	10c00c8d 	sth	r3,50(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111ac98:	e0bff704 	addi	r2,fp,-36
8111ac9c:	e0bff415 	stw	r2,-48(fp)
							ucParser++;
8111aca0:	e0bff303 	ldbu	r2,-52(fp)
8111aca4:	10800044 	addi	r2,r2,1
8111aca8:	e0bff305 	stb	r2,-52(fp)
						} while ( (c !=59) );
8111acac:	e0bff347 	ldb	r2,-51(fp)
8111acb0:	10800ed8 	cmpnei	r2,r2,59
8111acb4:	103fd61e 	bne	r2,zero,8111ac10 <__reset+0xfb0fac10>

						break;
8111acb8:	00021c06 	br	8111b52c <vLoadDebugConfs+0xe80>
					case 'L':
						ucParser = 0;
8111acbc:	e03ff305 	stb	zero,-52(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111acc0:	e0bff60f 	ldh	r2,-40(fp)
8111acc4:	1009883a 	mov	r4,r2
8111acc8:	111eba00 	call	8111eba0 <cGetNextChar>
8111accc:	e0bff345 	stb	r2,-51(fp)
								if ( isdigit( c ) ) {
8111acd0:	d0e00317 	ldw	r3,-32756(gp)
8111acd4:	e0bff347 	ldb	r2,-51(fp)
8111acd8:	10800044 	addi	r2,r2,1
8111acdc:	1885883a 	add	r2,r3,r2
8111ace0:	10800003 	ldbu	r2,0(r2)
8111ace4:	10803fcc 	andi	r2,r2,255
8111ace8:	1080010c 	andi	r2,r2,4
8111acec:	10000626 	beq	r2,zero,8111ad08 <vLoadDebugConfs+0x65c>
									(*p_inteiro) = c;
8111acf0:	e0bff417 	ldw	r2,-48(fp)
8111acf4:	e0fff343 	ldbu	r3,-51(fp)
8111acf8:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111acfc:	e0bff417 	ldw	r2,-48(fp)
8111ad00:	10800044 	addi	r2,r2,1
8111ad04:	e0bff415 	stw	r2,-48(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111ad08:	e0bff347 	ldb	r2,-51(fp)
8111ad0c:	10800ba0 	cmpeqi	r2,r2,46
8111ad10:	1000031e 	bne	r2,zero,8111ad20 <vLoadDebugConfs+0x674>
8111ad14:	e0bff347 	ldb	r2,-51(fp)
8111ad18:	10800ed8 	cmpnei	r2,r2,59
8111ad1c:	103fe81e 	bne	r2,zero,8111acc0 <__reset+0xfb0facc0>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111ad20:	e0bff417 	ldw	r2,-48(fp)
8111ad24:	00c00284 	movi	r3,10
8111ad28:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiRows = atoi( inteiro );
8111ad2c:	e0bff704 	addi	r2,fp,-36
8111ad30:	1009883a 	mov	r4,r2
8111ad34:	112146c0 	call	8112146c <atoi>
8111ad38:	1007883a 	mov	r3,r2
8111ad3c:	00a045b4 	movhi	r2,33046
8111ad40:	109c0004 	addi	r2,r2,28672
8111ad44:	10c0060d 	sth	r3,24(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111ad48:	e0bff704 	addi	r2,fp,-36
8111ad4c:	e0bff415 	stw	r2,-48(fp)
							ucParser++;
8111ad50:	e0bff303 	ldbu	r2,-52(fp)
8111ad54:	10800044 	addi	r2,r2,1
8111ad58:	e0bff305 	stb	r2,-52(fp)
						} while ( (c !=59) );
8111ad5c:	e0bff347 	ldb	r2,-51(fp)
8111ad60:	10800ed8 	cmpnei	r2,r2,59
8111ad64:	103fd61e 	bne	r2,zero,8111acc0 <__reset+0xfb0facc0>

						break;
8111ad68:	0001f006 	br	8111b52c <vLoadDebugConfs+0xe80>

					case 'O':
						ucParser = 0;
8111ad6c:	e03ff305 	stb	zero,-52(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111ad70:	e0bff60f 	ldh	r2,-40(fp)
8111ad74:	1009883a 	mov	r4,r2
8111ad78:	111eba00 	call	8111eba0 <cGetNextChar>
8111ad7c:	e0bff345 	stb	r2,-51(fp)
								if ( isdigit( c ) ) {
8111ad80:	d0e00317 	ldw	r3,-32756(gp)
8111ad84:	e0bff347 	ldb	r2,-51(fp)
8111ad88:	10800044 	addi	r2,r2,1
8111ad8c:	1885883a 	add	r2,r3,r2
8111ad90:	10800003 	ldbu	r2,0(r2)
8111ad94:	10803fcc 	andi	r2,r2,255
8111ad98:	1080010c 	andi	r2,r2,4
8111ad9c:	10000626 	beq	r2,zero,8111adb8 <vLoadDebugConfs+0x70c>
									(*p_inteiro) = c;
8111ada0:	e0bff417 	ldw	r2,-48(fp)
8111ada4:	e0fff343 	ldbu	r3,-51(fp)
8111ada8:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111adac:	e0bff417 	ldw	r2,-48(fp)
8111adb0:	10800044 	addi	r2,r2,1
8111adb4:	e0bff415 	stw	r2,-48(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111adb8:	e0bff347 	ldb	r2,-51(fp)
8111adbc:	10800ba0 	cmpeqi	r2,r2,46
8111adc0:	1000031e 	bne	r2,zero,8111add0 <vLoadDebugConfs+0x724>
8111adc4:	e0bff347 	ldb	r2,-51(fp)
8111adc8:	10800ed8 	cmpnei	r2,r2,59
8111adcc:	103fe81e 	bne	r2,zero,8111ad70 <__reset+0xfb0fad70>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111add0:	e0bff417 	ldw	r2,-48(fp)
8111add4:	00c00284 	movi	r3,10
8111add8:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiOLN = atoi( inteiro );
8111addc:	e0bff704 	addi	r2,fp,-36
8111ade0:	1009883a 	mov	r4,r2
8111ade4:	112146c0 	call	8112146c <atoi>
8111ade8:	1007883a 	mov	r3,r2
8111adec:	00a045b4 	movhi	r2,33046
8111adf0:	109c0004 	addi	r2,r2,28672
8111adf4:	10c0050d 	sth	r3,20(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111adf8:	e0bff704 	addi	r2,fp,-36
8111adfc:	e0bff415 	stw	r2,-48(fp)
							ucParser++;
8111ae00:	e0bff303 	ldbu	r2,-52(fp)
8111ae04:	10800044 	addi	r2,r2,1
8111ae08:	e0bff305 	stb	r2,-52(fp)
						} while ( (c !=59) );
8111ae0c:	e0bff347 	ldb	r2,-51(fp)
8111ae10:	10800ed8 	cmpnei	r2,r2,59
8111ae14:	103fd61e 	bne	r2,zero,8111ad70 <__reset+0xfb0fad70>

						break;
8111ae18:	0001c406 	br	8111b52c <vLoadDebugConfs+0xe80>
					case 'C':
						ucParser = 0;
8111ae1c:	e03ff305 	stb	zero,-52(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111ae20:	e0bff60f 	ldh	r2,-40(fp)
8111ae24:	1009883a 	mov	r4,r2
8111ae28:	111eba00 	call	8111eba0 <cGetNextChar>
8111ae2c:	e0bff345 	stb	r2,-51(fp)
								if ( isdigit( c ) ) {
8111ae30:	d0e00317 	ldw	r3,-32756(gp)
8111ae34:	e0bff347 	ldb	r2,-51(fp)
8111ae38:	10800044 	addi	r2,r2,1
8111ae3c:	1885883a 	add	r2,r3,r2
8111ae40:	10800003 	ldbu	r2,0(r2)
8111ae44:	10803fcc 	andi	r2,r2,255
8111ae48:	1080010c 	andi	r2,r2,4
8111ae4c:	10000626 	beq	r2,zero,8111ae68 <vLoadDebugConfs+0x7bc>
									(*p_inteiro) = c;
8111ae50:	e0bff417 	ldw	r2,-48(fp)
8111ae54:	e0fff343 	ldbu	r3,-51(fp)
8111ae58:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111ae5c:	e0bff417 	ldw	r2,-48(fp)
8111ae60:	10800044 	addi	r2,r2,1
8111ae64:	e0bff415 	stw	r2,-48(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111ae68:	e0bff347 	ldb	r2,-51(fp)
8111ae6c:	10800ba0 	cmpeqi	r2,r2,46
8111ae70:	1000031e 	bne	r2,zero,8111ae80 <vLoadDebugConfs+0x7d4>
8111ae74:	e0bff347 	ldb	r2,-51(fp)
8111ae78:	10800ed8 	cmpnei	r2,r2,59
8111ae7c:	103fe81e 	bne	r2,zero,8111ae20 <__reset+0xfb0fae20>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111ae80:	e0bff417 	ldw	r2,-48(fp)
8111ae84:	00c00284 	movi	r3,10
8111ae88:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiCols = atoi( inteiro );
8111ae8c:	e0bff704 	addi	r2,fp,-36
8111ae90:	1009883a 	mov	r4,r2
8111ae94:	112146c0 	call	8112146c <atoi>
8111ae98:	1007883a 	mov	r3,r2
8111ae9c:	00a045b4 	movhi	r2,33046
8111aea0:	109c0004 	addi	r2,r2,28672
8111aea4:	10c0058d 	sth	r3,22(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111aea8:	e0bff704 	addi	r2,fp,-36
8111aeac:	e0bff415 	stw	r2,-48(fp)
							ucParser++;
8111aeb0:	e0bff303 	ldbu	r2,-52(fp)
8111aeb4:	10800044 	addi	r2,r2,1
8111aeb8:	e0bff305 	stb	r2,-52(fp)
						} while ( (c !=59) );
8111aebc:	e0bff347 	ldb	r2,-51(fp)
8111aec0:	10800ed8 	cmpnei	r2,r2,59
8111aec4:	103fd61e 	bne	r2,zero,8111ae20 <__reset+0xfb0fae20>

						break;
8111aec8:	00019806 	br	8111b52c <vLoadDebugConfs+0xe80>
					case 'H':

						ucParser = 0;
8111aecc:	e03ff305 	stb	zero,-52(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111aed0:	e0bff60f 	ldh	r2,-40(fp)
8111aed4:	1009883a 	mov	r4,r2
8111aed8:	111eba00 	call	8111eba0 <cGetNextChar>
8111aedc:	e0bff345 	stb	r2,-51(fp)
								if ( isdigit( c ) ) {
8111aee0:	d0e00317 	ldw	r3,-32756(gp)
8111aee4:	e0bff347 	ldb	r2,-51(fp)
8111aee8:	10800044 	addi	r2,r2,1
8111aeec:	1885883a 	add	r2,r3,r2
8111aef0:	10800003 	ldbu	r2,0(r2)
8111aef4:	10803fcc 	andi	r2,r2,255
8111aef8:	1080010c 	andi	r2,r2,4
8111aefc:	10000626 	beq	r2,zero,8111af18 <vLoadDebugConfs+0x86c>
									(*p_inteiro) = c;
8111af00:	e0bff417 	ldw	r2,-48(fp)
8111af04:	e0fff343 	ldbu	r3,-51(fp)
8111af08:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111af0c:	e0bff417 	ldw	r2,-48(fp)
8111af10:	10800044 	addi	r2,r2,1
8111af14:	e0bff415 	stw	r2,-48(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111af18:	e0bff347 	ldb	r2,-51(fp)
8111af1c:	10800ba0 	cmpeqi	r2,r2,46
8111af20:	1000031e 	bne	r2,zero,8111af30 <vLoadDebugConfs+0x884>
8111af24:	e0bff347 	ldb	r2,-51(fp)
8111af28:	10800ed8 	cmpnei	r2,r2,59
8111af2c:	103fe81e 	bne	r2,zero,8111aed0 <__reset+0xfb0faed0>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111af30:	e0bff417 	ldw	r2,-48(fp)
8111af34:	00c00284 	movi	r3,10
8111af38:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.HK[min_sim(ucParser,15)] = atoi( inteiro );
8111af3c:	e0bff303 	ldbu	r2,-52(fp)
8111af40:	108003e8 	cmpgeui	r2,r2,15
8111af44:	1000021e 	bne	r2,zero,8111af50 <vLoadDebugConfs+0x8a4>
8111af48:	e43ff303 	ldbu	r16,-52(fp)
8111af4c:	00000106 	br	8111af54 <vLoadDebugConfs+0x8a8>
8111af50:	040003c4 	movi	r16,15
8111af54:	e0bff704 	addi	r2,fp,-36
8111af58:	1009883a 	mov	r4,r2
8111af5c:	112146c0 	call	8112146c <atoi>
8111af60:	1007883a 	mov	r3,r2
8111af64:	00a045b4 	movhi	r2,33046
8111af68:	109c0004 	addi	r2,r2,28672
8111af6c:	1405883a 	add	r2,r2,r16
8111af70:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111af74:	e0bff704 	addi	r2,fp,-36
8111af78:	e0bff415 	stw	r2,-48(fp)
							ucParser++;
8111af7c:	e0bff303 	ldbu	r2,-52(fp)
8111af80:	10800044 	addi	r2,r2,1
8111af84:	e0bff305 	stb	r2,-52(fp)
						} while ( (c !=59) );
8111af88:	e0bff347 	ldb	r2,-51(fp)
8111af8c:	10800ed8 	cmpnei	r2,r2,59
8111af90:	103fcf1e 	bne	r2,zero,8111aed0 <__reset+0xfb0faed0>

						break;
8111af94:	00016506 	br	8111b52c <vLoadDebugConfs+0xe80>
					case 'D':

						do {
							c = cGetNextChar(siFile);
8111af98:	e0bff60f 	ldh	r2,-40(fp)
8111af9c:	1009883a 	mov	r4,r2
8111afa0:	111eba00 	call	8111eba0 <cGetNextChar>
8111afa4:	e0bff345 	stb	r2,-51(fp)
							if ( isdigit( c ) ) {
8111afa8:	d0e00317 	ldw	r3,-32756(gp)
8111afac:	e0bff347 	ldb	r2,-51(fp)
8111afb0:	10800044 	addi	r2,r2,1
8111afb4:	1885883a 	add	r2,r3,r2
8111afb8:	10800003 	ldbu	r2,0(r2)
8111afbc:	10803fcc 	andi	r2,r2,255
8111afc0:	1080010c 	andi	r2,r2,4
8111afc4:	10000626 	beq	r2,zero,8111afe0 <vLoadDebugConfs+0x934>
								(*p_inteiro) = c;
8111afc8:	e0bff417 	ldw	r2,-48(fp)
8111afcc:	e0fff343 	ldbu	r3,-51(fp)
8111afd0:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111afd4:	e0bff417 	ldw	r2,-48(fp)
8111afd8:	10800044 	addi	r2,r2,1
8111afdc:	e0bff415 	stw	r2,-48(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111afe0:	e0bff347 	ldb	r2,-51(fp)
8111afe4:	10800ed8 	cmpnei	r2,r2,59
8111afe8:	103feb1e 	bne	r2,zero,8111af98 <__reset+0xfb0faf98>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111afec:	e0bff417 	ldw	r2,-48(fp)
8111aff0:	00c00284 	movi	r3,10
8111aff4:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.usiDelay = atoi( inteiro );
8111aff8:	e0bff704 	addi	r2,fp,-36
8111affc:	1009883a 	mov	r4,r2
8111b000:	112146c0 	call	8112146c <atoi>
8111b004:	1007883a 	mov	r3,r2
8111b008:	00a045b4 	movhi	r2,33046
8111b00c:	109c0004 	addi	r2,r2,28672
8111b010:	10c0070d 	sth	r3,28(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111b014:	e0bff704 	addi	r2,fp,-36
8111b018:	e0bff415 	stw	r2,-48(fp)

						break;
8111b01c:	00014306 	br	8111b52c <vLoadDebugConfs+0xe80>
					case 'K':

						do {
							c = cGetNextChar(siFile);
8111b020:	e0bff60f 	ldh	r2,-40(fp)
8111b024:	1009883a 	mov	r4,r2
8111b028:	111eba00 	call	8111eba0 <cGetNextChar>
8111b02c:	e0bff345 	stb	r2,-51(fp)
							if ( isdigit( c ) ) {
8111b030:	d0e00317 	ldw	r3,-32756(gp)
8111b034:	e0bff347 	ldb	r2,-51(fp)
8111b038:	10800044 	addi	r2,r2,1
8111b03c:	1885883a 	add	r2,r3,r2
8111b040:	10800003 	ldbu	r2,0(r2)
8111b044:	10803fcc 	andi	r2,r2,255
8111b048:	1080010c 	andi	r2,r2,4
8111b04c:	10000626 	beq	r2,zero,8111b068 <vLoadDebugConfs+0x9bc>
								(*p_inteiro) = c;
8111b050:	e0bff417 	ldw	r2,-48(fp)
8111b054:	e0fff343 	ldbu	r3,-51(fp)
8111b058:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111b05c:	e0bff417 	ldw	r2,-48(fp)
8111b060:	10800044 	addi	r2,r2,1
8111b064:	e0bff415 	stw	r2,-48(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111b068:	e0bff347 	ldb	r2,-51(fp)
8111b06c:	10800ed8 	cmpnei	r2,r2,59
8111b070:	103feb1e 	bne	r2,zero,8111b020 <__reset+0xfb0fb020>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111b074:	e0bff417 	ldw	r2,-48(fp)
8111b078:	00c00284 	movi	r3,10
8111b07c:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.ulColDelay = atoi( inteiro );
8111b080:	e0bff704 	addi	r2,fp,-36
8111b084:	1009883a 	mov	r4,r2
8111b088:	112146c0 	call	8112146c <atoi>
8111b08c:	1007883a 	mov	r3,r2
8111b090:	00a045b4 	movhi	r2,33046
8111b094:	109c0004 	addi	r2,r2,28672
8111b098:	10c00a15 	stw	r3,40(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111b09c:	e0bff704 	addi	r2,fp,-36
8111b0a0:	e0bff415 	stw	r2,-48(fp)

						break;
8111b0a4:	00012106 	br	8111b52c <vLoadDebugConfs+0xe80>
					case 'M':

						do {
							c = cGetNextChar(siFile);
8111b0a8:	e0bff60f 	ldh	r2,-40(fp)
8111b0ac:	1009883a 	mov	r4,r2
8111b0b0:	111eba00 	call	8111eba0 <cGetNextChar>
8111b0b4:	e0bff345 	stb	r2,-51(fp)
							if ( isdigit( c ) ) {
8111b0b8:	d0e00317 	ldw	r3,-32756(gp)
8111b0bc:	e0bff347 	ldb	r2,-51(fp)
8111b0c0:	10800044 	addi	r2,r2,1
8111b0c4:	1885883a 	add	r2,r3,r2
8111b0c8:	10800003 	ldbu	r2,0(r2)
8111b0cc:	10803fcc 	andi	r2,r2,255
8111b0d0:	1080010c 	andi	r2,r2,4
8111b0d4:	10000626 	beq	r2,zero,8111b0f0 <vLoadDebugConfs+0xa44>
								(*p_inteiro) = c;
8111b0d8:	e0bff417 	ldw	r2,-48(fp)
8111b0dc:	e0fff343 	ldbu	r3,-51(fp)
8111b0e0:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111b0e4:	e0bff417 	ldw	r2,-48(fp)
8111b0e8:	10800044 	addi	r2,r2,1
8111b0ec:	e0bff415 	stw	r2,-48(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111b0f0:	e0bff347 	ldb	r2,-51(fp)
8111b0f4:	10800ed8 	cmpnei	r2,r2,59
8111b0f8:	103feb1e 	bne	r2,zero,8111b0a8 <__reset+0xfb0fb0a8>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111b0fc:	e0bff417 	ldw	r2,-48(fp)
8111b100:	00c00284 	movi	r3,10
8111b104:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.ulADCPixelDelay = atoi( inteiro );
8111b108:	e0bff704 	addi	r2,fp,-36
8111b10c:	1009883a 	mov	r4,r2
8111b110:	112146c0 	call	8112146c <atoi>
8111b114:	1007883a 	mov	r3,r2
8111b118:	00a045b4 	movhi	r2,33046
8111b11c:	109c0004 	addi	r2,r2,28672
8111b120:	10c00b15 	stw	r3,44(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111b124:	e0bff704 	addi	r2,fp,-36
8111b128:	e0bff415 	stw	r2,-48(fp)

						break;
8111b12c:	0000ff06 	br	8111b52c <vLoadDebugConfs+0xe80>
					case 'J':

						do {
							c = cGetNextChar(siFile);
8111b130:	e0bff60f 	ldh	r2,-40(fp)
8111b134:	1009883a 	mov	r4,r2
8111b138:	111eba00 	call	8111eba0 <cGetNextChar>
8111b13c:	e0bff345 	stb	r2,-51(fp)
							if ( isdigit( c ) ) {
8111b140:	d0e00317 	ldw	r3,-32756(gp)
8111b144:	e0bff347 	ldb	r2,-51(fp)
8111b148:	10800044 	addi	r2,r2,1
8111b14c:	1885883a 	add	r2,r3,r2
8111b150:	10800003 	ldbu	r2,0(r2)
8111b154:	10803fcc 	andi	r2,r2,255
8111b158:	1080010c 	andi	r2,r2,4
8111b15c:	10000626 	beq	r2,zero,8111b178 <vLoadDebugConfs+0xacc>
								(*p_inteiro) = c;
8111b160:	e0bff417 	ldw	r2,-48(fp)
8111b164:	e0fff343 	ldbu	r3,-51(fp)
8111b168:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111b16c:	e0bff417 	ldw	r2,-48(fp)
8111b170:	10800044 	addi	r2,r2,1
8111b174:	e0bff415 	stw	r2,-48(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111b178:	e0bff347 	ldb	r2,-51(fp)
8111b17c:	10800ed8 	cmpnei	r2,r2,59
8111b180:	103feb1e 	bne	r2,zero,8111b130 <__reset+0xfb0fb130>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111b184:	e0bff417 	ldw	r2,-48(fp)
8111b188:	00c00284 	movi	r3,10
8111b18c:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.ulLineDelay = atoi( inteiro );
8111b190:	e0bff704 	addi	r2,fp,-36
8111b194:	1009883a 	mov	r4,r2
8111b198:	112146c0 	call	8112146c <atoi>
8111b19c:	1007883a 	mov	r3,r2
8111b1a0:	00a045b4 	movhi	r2,33046
8111b1a4:	109c0004 	addi	r2,r2,28672
8111b1a8:	10c00915 	stw	r3,36(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111b1ac:	e0bff704 	addi	r2,fp,-36
8111b1b0:	e0bff415 	stw	r2,-48(fp)

						break;
8111b1b4:	0000dd06 	br	8111b52c <vLoadDebugConfs+0xe80>
					case 'B':

						do {
							c = cGetNextChar(siFile);
8111b1b8:	e0bff60f 	ldh	r2,-40(fp)
8111b1bc:	1009883a 	mov	r4,r2
8111b1c0:	111eba00 	call	8111eba0 <cGetNextChar>
8111b1c4:	e0bff345 	stb	r2,-51(fp)
							if ( isdigit( c ) ) {
8111b1c8:	d0e00317 	ldw	r3,-32756(gp)
8111b1cc:	e0bff347 	ldb	r2,-51(fp)
8111b1d0:	10800044 	addi	r2,r2,1
8111b1d4:	1885883a 	add	r2,r3,r2
8111b1d8:	10800003 	ldbu	r2,0(r2)
8111b1dc:	10803fcc 	andi	r2,r2,255
8111b1e0:	1080010c 	andi	r2,r2,4
8111b1e4:	10000626 	beq	r2,zero,8111b200 <vLoadDebugConfs+0xb54>
								(*p_inteiro) = c;
8111b1e8:	e0bff417 	ldw	r2,-48(fp)
8111b1ec:	e0fff343 	ldbu	r3,-51(fp)
8111b1f0:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111b1f4:	e0bff417 	ldw	r2,-48(fp)
8111b1f8:	10800044 	addi	r2,r2,1
8111b1fc:	e0bff415 	stw	r2,-48(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111b200:	e0bff347 	ldb	r2,-51(fp)
8111b204:	10800ed8 	cmpnei	r2,r2,59
8111b208:	103feb1e 	bne	r2,zero,8111b1b8 <__reset+0xfb0fb1b8>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111b20c:	e0bff417 	ldw	r2,-48(fp)
8111b210:	00c00284 	movi	r3,10
8111b214:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.usiLinkNFEE0 = atoi( inteiro );
8111b218:	e0bff704 	addi	r2,fp,-36
8111b21c:	1009883a 	mov	r4,r2
8111b220:	112146c0 	call	8112146c <atoi>
8111b224:	1007883a 	mov	r3,r2
8111b228:	00a045b4 	movhi	r2,33046
8111b22c:	109c0004 	addi	r2,r2,28672
8111b230:	10c0100d 	sth	r3,64(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111b234:	e0bff704 	addi	r2,fp,-36
8111b238:	e0bff415 	stw	r2,-48(fp)

						break;
8111b23c:	0000bb06 	br	8111b52c <vLoadDebugConfs+0xe80>
					case 'W':

						p_inteiro = inteiroll;
8111b240:	e0bff904 	addi	r2,fp,-28
8111b244:	e0bff415 	stw	r2,-48(fp)
						do {
							c = cGetNextChar(siFile);
8111b248:	e0bff60f 	ldh	r2,-40(fp)
8111b24c:	1009883a 	mov	r4,r2
8111b250:	111eba00 	call	8111eba0 <cGetNextChar>
8111b254:	e0bff345 	stb	r2,-51(fp)
							if ( isdigit( c ) ) {
8111b258:	d0e00317 	ldw	r3,-32756(gp)
8111b25c:	e0bff347 	ldb	r2,-51(fp)
8111b260:	10800044 	addi	r2,r2,1
8111b264:	1885883a 	add	r2,r3,r2
8111b268:	10800003 	ldbu	r2,0(r2)
8111b26c:	10803fcc 	andi	r2,r2,255
8111b270:	1080010c 	andi	r2,r2,4
8111b274:	10000626 	beq	r2,zero,8111b290 <vLoadDebugConfs+0xbe4>
								(*p_inteiro) = c;
8111b278:	e0bff417 	ldw	r2,-48(fp)
8111b27c:	e0fff343 	ldbu	r3,-51(fp)
8111b280:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111b284:	e0bff417 	ldw	r2,-48(fp)
8111b288:	10800044 	addi	r2,r2,1
8111b28c:	e0bff415 	stw	r2,-48(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111b290:	e0bff347 	ldb	r2,-51(fp)
8111b294:	10800ed8 	cmpnei	r2,r2,59
8111b298:	103feb1e 	bne	r2,zero,8111b248 <__reset+0xfb0fb248>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111b29c:	e0bff417 	ldw	r2,-48(fp)
8111b2a0:	00c00284 	movi	r3,10
8111b2a4:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.ullMaskMSB = (unsigned long)atoll( inteiroll );
8111b2a8:	e0bff904 	addi	r2,fp,-28
8111b2ac:	1009883a 	mov	r4,r2
8111b2b0:	11214840 	call	81121484 <atoll>
8111b2b4:	1009883a 	mov	r4,r2
8111b2b8:	180b883a 	mov	r5,r3
8111b2bc:	2007883a 	mov	r3,r4
8111b2c0:	00a045b4 	movhi	r2,33046
8111b2c4:	109c0004 	addi	r2,r2,28672
8111b2c8:	10c00e15 	stw	r3,56(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111b2cc:	e0bff704 	addi	r2,fp,-36
8111b2d0:	e0bff415 	stw	r2,-48(fp)

						break;
8111b2d4:	00009506 	br	8111b52c <vLoadDebugConfs+0xe80>
					case 'U':

						p_inteiro = inteiroll;
8111b2d8:	e0bff904 	addi	r2,fp,-28
8111b2dc:	e0bff415 	stw	r2,-48(fp)
						do {
							c = cGetNextChar(siFile);
8111b2e0:	e0bff60f 	ldh	r2,-40(fp)
8111b2e4:	1009883a 	mov	r4,r2
8111b2e8:	111eba00 	call	8111eba0 <cGetNextChar>
8111b2ec:	e0bff345 	stb	r2,-51(fp)
							if ( isdigit( c ) ) {
8111b2f0:	d0e00317 	ldw	r3,-32756(gp)
8111b2f4:	e0bff347 	ldb	r2,-51(fp)
8111b2f8:	10800044 	addi	r2,r2,1
8111b2fc:	1885883a 	add	r2,r3,r2
8111b300:	10800003 	ldbu	r2,0(r2)
8111b304:	10803fcc 	andi	r2,r2,255
8111b308:	1080010c 	andi	r2,r2,4
8111b30c:	10000626 	beq	r2,zero,8111b328 <vLoadDebugConfs+0xc7c>
								(*p_inteiro) = c;
8111b310:	e0bff417 	ldw	r2,-48(fp)
8111b314:	e0fff343 	ldbu	r3,-51(fp)
8111b318:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111b31c:	e0bff417 	ldw	r2,-48(fp)
8111b320:	10800044 	addi	r2,r2,1
8111b324:	e0bff415 	stw	r2,-48(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111b328:	e0bff347 	ldb	r2,-51(fp)
8111b32c:	10800ed8 	cmpnei	r2,r2,59
8111b330:	103feb1e 	bne	r2,zero,8111b2e0 <__reset+0xfb0fb2e0>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111b334:	e0bff417 	ldw	r2,-48(fp)
8111b338:	00c00284 	movi	r3,10
8111b33c:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.ullMaskLSB = (unsigned long)atoll( inteiroll );
8111b340:	e0bff904 	addi	r2,fp,-28
8111b344:	1009883a 	mov	r4,r2
8111b348:	11214840 	call	81121484 <atoll>
8111b34c:	1009883a 	mov	r4,r2
8111b350:	180b883a 	mov	r5,r3
8111b354:	2007883a 	mov	r3,r4
8111b358:	00a045b4 	movhi	r2,33046
8111b35c:	109c0004 	addi	r2,r2,28672
8111b360:	10c00d15 	stw	r3,52(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111b364:	e0bff704 	addi	r2,fp,-36
8111b368:	e0bff415 	stw	r2,-48(fp)

						break;
8111b36c:	00006f06 	br	8111b52c <vLoadDebugConfs+0xe80>
					case 'T':

						do {
							c = cGetNextChar(siFile);
8111b370:	e0bff60f 	ldh	r2,-40(fp)
8111b374:	1009883a 	mov	r4,r2
8111b378:	111eba00 	call	8111eba0 <cGetNextChar>
8111b37c:	e0bff345 	stb	r2,-51(fp)
							if ( isdigit( c ) ) {
8111b380:	d0e00317 	ldw	r3,-32756(gp)
8111b384:	e0bff347 	ldb	r2,-51(fp)
8111b388:	10800044 	addi	r2,r2,1
8111b38c:	1885883a 	add	r2,r3,r2
8111b390:	10800003 	ldbu	r2,0(r2)
8111b394:	10803fcc 	andi	r2,r2,255
8111b398:	1080010c 	andi	r2,r2,4
8111b39c:	10000626 	beq	r2,zero,8111b3b8 <vLoadDebugConfs+0xd0c>
								(*p_inteiro) = c;
8111b3a0:	e0bff417 	ldw	r2,-48(fp)
8111b3a4:	e0fff343 	ldbu	r3,-51(fp)
8111b3a8:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111b3ac:	e0bff417 	ldw	r2,-48(fp)
8111b3b0:	10800044 	addi	r2,r2,1
8111b3b4:	e0bff415 	stw	r2,-48(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111b3b8:	e0bff347 	ldb	r2,-51(fp)
8111b3bc:	10800ed8 	cmpnei	r2,r2,59
8111b3c0:	103feb1e 	bne	r2,zero,8111b370 <__reset+0xfb0fb370>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111b3c4:	e0bff417 	ldw	r2,-48(fp)
8111b3c8:	00c00284 	movi	r3,10
8111b3cc:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						sidhcpTemp = atoi( inteiro );
8111b3d0:	e0bff704 	addi	r2,fp,-36
8111b3d4:	1009883a 	mov	r4,r2
8111b3d8:	112146c0 	call	8112146c <atoi>
8111b3dc:	e0bff68d 	sth	r2,-38(fp)
						if (sidhcpTemp == 1)
8111b3e0:	e0bff68f 	ldh	r2,-38(fp)
8111b3e4:	10800058 	cmpnei	r2,r2,1
8111b3e8:	1000051e 	bne	r2,zero,8111b400 <vLoadDebugConfs+0xd54>
							xDefaults.bDataPacket = TRUE;
8111b3ec:	00a045b4 	movhi	r2,33046
8111b3f0:	109c0004 	addi	r2,r2,28672
8111b3f4:	00c00044 	movi	r3,1
8111b3f8:	10c00815 	stw	r3,32(r2)
8111b3fc:	00000306 	br	8111b40c <vLoadDebugConfs+0xd60>
						else
							xDefaults.bDataPacket = FALSE;
8111b400:	00a045b4 	movhi	r2,33046
8111b404:	109c0004 	addi	r2,r2,28672
8111b408:	10000815 	stw	zero,32(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111b40c:	e0bff704 	addi	r2,fp,-36
8111b410:	e0bff415 	stw	r2,-48(fp)

						break;
8111b414:	00004506 	br	8111b52c <vLoadDebugConfs+0xe80>
					case 'Z':

						do {
							c = cGetNextChar(siFile);
8111b418:	e0bff60f 	ldh	r2,-40(fp)
8111b41c:	1009883a 	mov	r4,r2
8111b420:	111eba00 	call	8111eba0 <cGetNextChar>
8111b424:	e0bff345 	stb	r2,-51(fp)
							if ( isdigit( c ) ) {
8111b428:	d0e00317 	ldw	r3,-32756(gp)
8111b42c:	e0bff347 	ldb	r2,-51(fp)
8111b430:	10800044 	addi	r2,r2,1
8111b434:	1885883a 	add	r2,r3,r2
8111b438:	10800003 	ldbu	r2,0(r2)
8111b43c:	10803fcc 	andi	r2,r2,255
8111b440:	1080010c 	andi	r2,r2,4
8111b444:	10000626 	beq	r2,zero,8111b460 <vLoadDebugConfs+0xdb4>
								(*p_inteiro) = c;
8111b448:	e0bff417 	ldw	r2,-48(fp)
8111b44c:	e0fff343 	ldbu	r3,-51(fp)
8111b450:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111b454:	e0bff417 	ldw	r2,-48(fp)
8111b458:	10800044 	addi	r2,r2,1
8111b45c:	e0bff415 	stw	r2,-48(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111b460:	e0bff347 	ldb	r2,-51(fp)
8111b464:	10800ed8 	cmpnei	r2,r2,59
8111b468:	103feb1e 	bne	r2,zero,8111b418 <__reset+0xfb0fb418>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111b46c:	e0bff417 	ldw	r2,-48(fp)
8111b470:	00c00284 	movi	r3,10
8111b474:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						sidhcpTemp = atoi( inteiro );
8111b478:	e0bff704 	addi	r2,fp,-36
8111b47c:	1009883a 	mov	r4,r2
8111b480:	112146c0 	call	8112146c <atoi>
8111b484:	e0bff68d 	sth	r2,-38(fp)
						if (sidhcpTemp == 1)
8111b488:	e0bff68f 	ldh	r2,-38(fp)
8111b48c:	10800058 	cmpnei	r2,r2,1
8111b490:	1000051e 	bne	r2,zero,8111b4a8 <vLoadDebugConfs+0xdfc>
							xDefaults.bMaskSD = TRUE;
8111b494:	00a045b4 	movhi	r2,33046
8111b498:	109c0004 	addi	r2,r2,28672
8111b49c:	00c00044 	movi	r3,1
8111b4a0:	10c00f15 	stw	r3,60(r2)
8111b4a4:	00000306 	br	8111b4b4 <vLoadDebugConfs+0xe08>
						else
							xDefaults.bMaskSD = FALSE;
8111b4a8:	00a045b4 	movhi	r2,33046
8111b4ac:	109c0004 	addi	r2,r2,28672
8111b4b0:	10000f15 	stw	zero,60(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111b4b4:	e0bff704 	addi	r2,fp,-36
8111b4b8:	e0bff415 	stw	r2,-48(fp)

						break;
8111b4bc:	00001b06 	br	8111b52c <vLoadDebugConfs+0xe80>
					case 0x3C: //"<"
						close = siCloseFile(siFile);
8111b4c0:	e0bff60f 	ldh	r2,-40(fp)
8111b4c4:	1009883a 	mov	r4,r2
8111b4c8:	111eb600 	call	8111eb60 <siCloseFile>
8111b4cc:	e0bff515 	stw	r2,-44(fp)
						if (close == FALSE){
8111b4d0:	e0bff517 	ldw	r2,-44(fp)
8111b4d4:	1000071e 	bne	r2,zero,8111b4f4 <vLoadDebugConfs+0xe48>
							#ifdef DEBUG_ON
								debug(fp,"SDCard: Can't close the file.\n");
8111b4d8:	d0a06217 	ldw	r2,-32376(gp)
8111b4dc:	100f883a 	mov	r7,r2
8111b4e0:	01800784 	movi	r6,30
8111b4e4:	01400044 	movi	r5,1
8111b4e8:	01204574 	movhi	r4,33045
8111b4ec:	213b8704 	addi	r4,r4,-4580
8111b4f0:	1121c7c0 	call	81121c7c <fwrite>
							#endif
						}
						/* End of Parser File */
						bEOF = TRUE;
8111b4f4:	00800044 	movi	r2,1
8111b4f8:	e0bff215 	stw	r2,-56(fp)
						bSuccess = TRUE; //pensar melhor
8111b4fc:	00800044 	movi	r2,1
8111b500:	e0bff115 	stw	r2,-60(fp)
						break;
8111b504:	00000906 	br	8111b52c <vLoadDebugConfs+0xe80>
					default:
						#ifdef DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
8111b508:	d0a06217 	ldw	r2,-32376(gp)
8111b50c:	100f883a 	mov	r7,r2
8111b510:	01800844 	movi	r6,33
8111b514:	01400044 	movi	r5,1
8111b518:	01204574 	movhi	r4,33045
8111b51c:	213b8f04 	addi	r4,r4,-4548
8111b520:	1121c7c0 	call	81121c7c <fwrite>
						#endif
						break;
8111b524:	00000106 	br	8111b52c <vLoadDebugConfs+0xe80>
						bEOF = TRUE;
						break;
					case 0x20: 	//ASCII: 0x20 = space
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
8111b528:	0001883a 	nop
						#ifdef DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
						#endif
						break;
				}
			} while ( bEOF == FALSE );
8111b52c:	e0bff217 	ldw	r2,-56(fp)
8111b530:	103c8126 	beq	r2,zero,8111a738 <__reset+0xfb0fa738>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( DEBUG_FILE_NAME );

		if ( siFile >= 0 ){
8111b534:	00000f06 	br	8111b574 <vLoadDebugConfs+0xec8>
						break;
				}
			} while ( bEOF == FALSE );
		} else {
			#ifdef DEBUG_ON
				fprintf(fp,"SDCard: File not found.\n");
8111b538:	d0a06217 	ldw	r2,-32376(gp)
8111b53c:	100f883a 	mov	r7,r2
8111b540:	01800604 	movi	r6,24
8111b544:	01400044 	movi	r5,1
8111b548:	01204574 	movhi	r4,33045
8111b54c:	213b9804 	addi	r4,r4,-4512
8111b550:	1121c7c0 	call	81121c7c <fwrite>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( DEBUG_FILE_NAME );

		if ( siFile >= 0 ){
8111b554:	00000706 	br	8111b574 <vLoadDebugConfs+0xec8>
				fprintf(fp,"SDCard: File not found.\n");
			#endif
		}
	} else {
		#ifdef DEBUG_ON
			fprintf(fp,"SDCard: No SDCard.\n");
8111b558:	d0a06217 	ldw	r2,-32376(gp)
8111b55c:	100f883a 	mov	r7,r2
8111b560:	018004c4 	movi	r6,19
8111b564:	01400044 	movi	r5,1
8111b568:	01204574 	movhi	r4,33045
8111b56c:	213b9f04 	addi	r4,r4,-4484
8111b570:	1121c7c0 	call	81121c7c <fwrite>
		#endif
	}
	/* Load the default configuration if not successful in read the SDCard */
	if ( bSuccess == FALSE ) {
8111b574:	e0bff117 	ldw	r2,-60(fp)
8111b578:	1000391e 	bne	r2,zero,8111b660 <vLoadDebugConfs+0xfb4>
		/*Enviar mensagem que e gravar log que no encontrou o arquivo e comeara a utilizar o padrao*/
		printf("Debug Configs: Could not load the default values from SDCard\n");
8111b57c:	01204574 	movhi	r4,33045
8111b580:	213bf104 	addi	r4,r4,-4156
8111b584:	1122c2c0 	call	81122c2c <puts>
		printf("Can't find the file:'%s'.\n", ETH_FILE_NAME);
8111b588:	01604574 	movhi	r5,33045
8111b58c:	297b7e04 	addi	r5,r5,-4616
8111b590:	01204574 	movhi	r4,33045
8111b594:	213c0104 	addi	r4,r4,-4092
8111b598:	11229a80 	call	811229a8 <printf>



		xDefaults.usiRows = 4510;
8111b59c:	00a045b4 	movhi	r2,33046
8111b5a0:	109c0004 	addi	r2,r2,28672
8111b5a4:	00c46784 	movi	r3,4510
8111b5a8:	10c0060d 	sth	r3,24(r2)
		xDefaults.usiCols = 2255;
8111b5ac:	00a045b4 	movhi	r2,33046
8111b5b0:	109c0004 	addi	r2,r2,28672
8111b5b4:	00c233c4 	movi	r3,2255
8111b5b8:	10c0058d 	sth	r3,22(r2)
		xDefaults.usiOLN = 30;
8111b5bc:	00a045b4 	movhi	r2,33046
8111b5c0:	109c0004 	addi	r2,r2,28672
8111b5c4:	00c00784 	movi	r3,30
8111b5c8:	10c0050d 	sth	r3,20(r2)
		xDefaults.usiPreScanSerial = 25;
8111b5cc:	00a045b4 	movhi	r2,33046
8111b5d0:	109c0004 	addi	r2,r2,28672
8111b5d4:	00c00644 	movi	r3,25
8111b5d8:	10c0048d 	sth	r3,18(r2)
		xDefaults.usiOverScanSerial = 15;
8111b5dc:	00a045b4 	movhi	r2,33046
8111b5e0:	109c0004 	addi	r2,r2,28672
8111b5e4:	00c003c4 	movi	r3,15
8111b5e8:	10c0040d 	sth	r3,16(r2)
		xDefaults.usiSyncPeriod = 6250;
8111b5ec:	00a045b4 	movhi	r2,33046
8111b5f0:	109c0004 	addi	r2,r2,28672
8111b5f4:	00c61a84 	movi	r3,6250
8111b5f8:	10c0068d 	sth	r3,26(r2)
		xDefaults.usiDelay = 20;
8111b5fc:	00a045b4 	movhi	r2,33046
8111b600:	109c0004 	addi	r2,r2,28672
8111b604:	00c00504 	movi	r3,20
8111b608:	10c0070d 	sth	r3,28(r2)
		xDefaults.bDataPacket = TRUE;
8111b60c:	00a045b4 	movhi	r2,33046
8111b610:	109c0004 	addi	r2,r2,28672
8111b614:	00c00044 	movi	r3,1
8111b618:	10c00815 	stw	r3,32(r2)
		xDefaults.ulLineDelay = 0;
8111b61c:	00a045b4 	movhi	r2,33046
8111b620:	109c0004 	addi	r2,r2,28672
8111b624:	10000915 	stw	zero,36(r2)
		xDefaults.ulColDelay = 0;
8111b628:	00a045b4 	movhi	r2,33046
8111b62c:	109c0004 	addi	r2,r2,28672
8111b630:	10000a15 	stw	zero,40(r2)
		xDefaults.ulADCPixelDelay = 0;
8111b634:	00a045b4 	movhi	r2,33046
8111b638:	109c0004 	addi	r2,r2,28672
8111b63c:	10000b15 	stw	zero,44(r2)
		xDefaults.ucLogicalAddr = 0x51;
8111b640:	00a045b4 	movhi	r2,33046
8111b644:	109c0004 	addi	r2,r2,28672
8111b648:	00c01444 	movi	r3,81
8111b64c:	10c00c8d 	sth	r3,50(r2)
		xDefaults.ucRmapKey = 0xD1;
8111b650:	00a045b4 	movhi	r2,33046
8111b654:	109c0004 	addi	r2,r2,28672
8111b658:	00c03444 	movi	r3,209
8111b65c:	10c00c0d 	sth	r3,48(r2)

	}

	return bSuccess;
8111b660:	e0bff117 	ldw	r2,-60(fp)
}
8111b664:	e6ffff04 	addi	sp,fp,-4
8111b668:	dfc00217 	ldw	ra,8(sp)
8111b66c:	df000117 	ldw	fp,4(sp)
8111b670:	dc000017 	ldw	r16,0(sp)
8111b674:	dec00304 	addi	sp,sp,12
8111b678:	f800283a 	ret

8111b67c <ucCrc8>:

#include "crc8.h"


unsigned char ucCrc8(unsigned crc, unsigned char const *data, size_t len)
{
8111b67c:	defffb04 	addi	sp,sp,-20
8111b680:	de00012e 	bgeu	sp,et,8111b688 <ucCrc8+0xc>
8111b684:	003b68fa 	trap	3
8111b688:	df000415 	stw	fp,16(sp)
8111b68c:	df000404 	addi	fp,sp,16
8111b690:	e13ffd15 	stw	r4,-12(fp)
8111b694:	e17ffe15 	stw	r5,-8(fp)
8111b698:	e1bfff15 	stw	r6,-4(fp)
    if (data == NULL)
8111b69c:	e0bffe17 	ldw	r2,-8(fp)
8111b6a0:	1000021e 	bne	r2,zero,8111b6ac <ucCrc8+0x30>
        return 0;
8111b6a4:	0005883a 	mov	r2,zero
8111b6a8:	00001906 	br	8111b710 <ucCrc8+0x94>
    crc &= 0xff;
8111b6ac:	e0bffd17 	ldw	r2,-12(fp)
8111b6b0:	10803fcc 	andi	r2,r2,255
8111b6b4:	e0bffd15 	stw	r2,-12(fp)
    unsigned char const *end = data + len;
8111b6b8:	e0fffe17 	ldw	r3,-8(fp)
8111b6bc:	e0bfff17 	ldw	r2,-4(fp)
8111b6c0:	1885883a 	add	r2,r3,r2
8111b6c4:	e0bffc15 	stw	r2,-16(fp)
    while (data < end)
8111b6c8:	00000d06 	br	8111b700 <ucCrc8+0x84>
        crc = crc8_table[crc ^ *data++];
8111b6cc:	e0bffe17 	ldw	r2,-8(fp)
8111b6d0:	10c00044 	addi	r3,r2,1
8111b6d4:	e0fffe15 	stw	r3,-8(fp)
8111b6d8:	10800003 	ldbu	r2,0(r2)
8111b6dc:	10c03fcc 	andi	r3,r2,255
8111b6e0:	e0bffd17 	ldw	r2,-12(fp)
8111b6e4:	1886f03a 	xor	r3,r3,r2
8111b6e8:	00a04574 	movhi	r2,33045
8111b6ec:	10bc07c4 	addi	r2,r2,-4065
8111b6f0:	10c5883a 	add	r2,r2,r3
8111b6f4:	10800003 	ldbu	r2,0(r2)
8111b6f8:	10803fcc 	andi	r2,r2,255
8111b6fc:	e0bffd15 	stw	r2,-12(fp)
{
    if (data == NULL)
        return 0;
    crc &= 0xff;
    unsigned char const *end = data + len;
    while (data < end)
8111b700:	e0fffe17 	ldw	r3,-8(fp)
8111b704:	e0bffc17 	ldw	r2,-16(fp)
8111b708:	18bff036 	bltu	r3,r2,8111b6cc <__reset+0xfb0fb6cc>
        crc = crc8_table[crc ^ *data++];
    return crc;
8111b70c:	e0bffd17 	ldw	r2,-12(fp)
}
8111b710:	e037883a 	mov	sp,fp
8111b714:	df000017 	ldw	fp,0(sp)
8111b718:	dec00104 	addi	sp,sp,4
8111b71c:	f800283a 	ret

8111b720 <ucCrc8wInit>:

unsigned char ucCrc8wInit(char const *data, size_t len)
{
8111b720:	defffb04 	addi	sp,sp,-20
8111b724:	de00012e 	bgeu	sp,et,8111b72c <ucCrc8wInit+0xc>
8111b728:	003b68fa 	trap	3
8111b72c:	dfc00415 	stw	ra,16(sp)
8111b730:	df000315 	stw	fp,12(sp)
8111b734:	df000304 	addi	fp,sp,12
8111b738:	e13ffe15 	stw	r4,-8(fp)
8111b73c:	e17fff15 	stw	r5,-4(fp)
	unsigned char crc;

	crc = ucCrc8(0, NULL, 0);
8111b740:	000d883a 	mov	r6,zero
8111b744:	000b883a 	mov	r5,zero
8111b748:	0009883a 	mov	r4,zero
8111b74c:	111b67c0 	call	8111b67c <ucCrc8>
8111b750:	e0bffd05 	stb	r2,-12(fp)
	return ucCrc8(crc, (unsigned char const *)data, len);
8111b754:	e0bffd03 	ldbu	r2,-12(fp)
8111b758:	e1bfff17 	ldw	r6,-4(fp)
8111b75c:	e17ffe17 	ldw	r5,-8(fp)
8111b760:	1009883a 	mov	r4,r2
8111b764:	111b67c0 	call	8111b67c <ucCrc8>
}
8111b768:	e037883a 	mov	sp,fp
8111b76c:	dfc00117 	ldw	ra,4(sp)
8111b770:	df000017 	ldw	fp,0(sp)
8111b774:	dec00204 	addi	sp,sp,8
8111b778:	f800283a 	ret

8111b77c <vDataControllerInit>:


#include "data_controller.h"


void vDataControllerInit( TNData_Control *xDataControlL, TNFee_Control *xNfeeCOntrolL ) {
8111b77c:	defffc04 	addi	sp,sp,-16
8111b780:	de00012e 	bgeu	sp,et,8111b788 <vDataControllerInit+0xc>
8111b784:	003b68fa 	trap	3
8111b788:	df000315 	stw	fp,12(sp)
8111b78c:	df000304 	addi	fp,sp,12
8111b790:	e13ffe15 	stw	r4,-8(fp)
8111b794:	e17fff15 	stw	r5,-4(fp)
	unsigned char ucIL;

	xDataControlL->sMode = sMebInit;
8111b798:	e0bffe17 	ldw	r2,-8(fp)
8111b79c:	10000615 	stw	zero,24(r2)

	for ( ucIL = 0 ; ucIL < N_OF_NFEE; ucIL++ ) {
8111b7a0:	e03ffd05 	stb	zero,-12(fp)
8111b7a4:	00001c06 	br	8111b818 <vDataControllerInit+0x9c>
		xDataControlL->xReadOnlyFeeControl.xNfee[ucIL] = &xNfeeCOntrolL->xNfee[ucIL];
8111b7a8:	e0bffd03 	ldbu	r2,-12(fp)
8111b7ac:	e0fffd03 	ldbu	r3,-12(fp)
8111b7b0:	18c09624 	muli	r3,r3,600
8111b7b4:	e13fff17 	ldw	r4,-4(fp)
8111b7b8:	20c7883a 	add	r3,r4,r3
8111b7bc:	e13ffe17 	ldw	r4,-8(fp)
8111b7c0:	10800084 	addi	r2,r2,2
8111b7c4:	1085883a 	add	r2,r2,r2
8111b7c8:	1085883a 	add	r2,r2,r2
8111b7cc:	2085883a 	add	r2,r4,r2
8111b7d0:	10c00015 	stw	r3,0(r2)
		xDataControlL->xReadOnlyFeeControl.pbEnabledNFEEs[ucIL] = xNfeeCOntrolL->pbEnabledNFEEs[ucIL];
8111b7d4:	e17ffd03 	ldbu	r5,-12(fp)
8111b7d8:	e0bffd03 	ldbu	r2,-12(fp)
8111b7dc:	e0ffff17 	ldw	r3,-4(fp)
8111b7e0:	108025c4 	addi	r2,r2,151
8111b7e4:	1085883a 	add	r2,r2,r2
8111b7e8:	1085883a 	add	r2,r2,r2
8111b7ec:	1885883a 	add	r2,r3,r2
8111b7f0:	10c00017 	ldw	r3,0(r2)
8111b7f4:	e13ffe17 	ldw	r4,-8(fp)
8111b7f8:	288000c4 	addi	r2,r5,3
8111b7fc:	1085883a 	add	r2,r2,r2
8111b800:	1085883a 	add	r2,r2,r2
8111b804:	2085883a 	add	r2,r4,r2
8111b808:	10c00015 	stw	r3,0(r2)
void vDataControllerInit( TNData_Control *xDataControlL, TNFee_Control *xNfeeCOntrolL ) {
	unsigned char ucIL;

	xDataControlL->sMode = sMebInit;

	for ( ucIL = 0 ; ucIL < N_OF_NFEE; ucIL++ ) {
8111b80c:	e0bffd03 	ldbu	r2,-12(fp)
8111b810:	10800044 	addi	r2,r2,1
8111b814:	e0bffd05 	stb	r2,-12(fp)
8111b818:	e0bffd03 	ldbu	r2,-12(fp)
8111b81c:	103fe226 	beq	r2,zero,8111b7a8 <__reset+0xfb0fb7a8>
		xDataControlL->xReadOnlyFeeControl.xNfee[ucIL] = &xNfeeCOntrolL->xNfee[ucIL];
		xDataControlL->xReadOnlyFeeControl.pbEnabledNFEEs[ucIL] = xNfeeCOntrolL->pbEnabledNFEEs[ucIL];
	}
	
	xDataControlL->xReadOnlyFeeControl.ucTimeCode = &xNfeeCOntrolL->ucTimeCode;
8111b820:	e0bfff17 	ldw	r2,-4(fp)
8111b824:	10c09904 	addi	r3,r2,612
8111b828:	e0bffe17 	ldw	r2,-8(fp)
8111b82c:	10c00415 	stw	r3,16(r2)
	xDataControlL->bUpdateComplete = FALSE;
8111b830:	e0bffe17 	ldw	r2,-8(fp)
8111b834:	10000515 	stw	zero,20(r2)


	/* The only inverse attribution */
	/* This variable indicates when the DataControl finishs to use the RAM, then FeeControl can start fill the buffer to the next MasterSync */
	xNfeeCOntrolL->pbUpdateCReadOnly = &xDataControlL->bUpdateComplete;
8111b838:	e0bffe17 	ldw	r2,-8(fp)
8111b83c:	10c00504 	addi	r3,r2,20
8111b840:	e0bfff17 	ldw	r2,-4(fp)
8111b844:	10c09b15 	stw	r3,620(r2)
}
8111b848:	0001883a 	nop
8111b84c:	e037883a 	mov	sp,fp
8111b850:	df000017 	ldw	fp,0(sp)
8111b854:	dec00104 	addi	sp,sp,4
8111b858:	f800283a 	ret

8111b85c <printErrorTask>:

#include "error_handler_simucam.h"


#ifdef DEBUG_ON
    void printErrorTask( INT8U error_code ) {
8111b85c:	defff904 	addi	sp,sp,-28
8111b860:	de00012e 	bgeu	sp,et,8111b868 <printErrorTask+0xc>
8111b864:	003b68fa 	trap	3
8111b868:	dfc00615 	stw	ra,24(sp)
8111b86c:	df000515 	stw	fp,20(sp)
8111b870:	df000504 	addi	fp,sp,20
8111b874:	2005883a 	mov	r2,r4
8111b878:	e0bfff05 	stb	r2,-4(fp)
		char buffer[16] = "";
8111b87c:	e03ffb15 	stw	zero,-20(fp)
8111b880:	e03ffc15 	stw	zero,-16(fp)
8111b884:	e03ffd15 	stw	zero,-12(fp)
8111b888:	e03ffe15 	stw	zero,-8(fp)
		
		sprintf(buffer, "Err: %d\n", error_code);
8111b88c:	e0bfff03 	ldbu	r2,-4(fp)
8111b890:	100d883a 	mov	r6,r2
8111b894:	01604574 	movhi	r5,33045
8111b898:	297c4804 	addi	r5,r5,-3808
8111b89c:	e13ffb04 	addi	r4,fp,-20
8111b8a0:	1122f700 	call	81122f70 <sprintf>
		debug(fp, buffer);
8111b8a4:	d0a06217 	ldw	r2,-32376(gp)
8111b8a8:	e17ffb04 	addi	r5,fp,-20
8111b8ac:	1009883a 	mov	r4,r2
8111b8b0:	11215e00 	call	811215e0 <fprintf>
	}
8111b8b4:	0001883a 	nop
8111b8b8:	e037883a 	mov	sp,fp
8111b8bc:	dfc00117 	ldw	ra,4(sp)
8111b8c0:	df000017 	ldw	fp,0(sp)
8111b8c4:	dec00204 	addi	sp,sp,8
8111b8c8:	f800283a 	ret

8111b8cc <vFailCreateMutexSResources>:
#endif

void vFailCreateMutexSResources( INT8U error_code )
{
8111b8cc:	defffd04 	addi	sp,sp,-12
8111b8d0:	de00012e 	bgeu	sp,et,8111b8d8 <vFailCreateMutexSResources+0xc>
8111b8d4:	003b68fa 	trap	3
8111b8d8:	dfc00215 	stw	ra,8(sp)
8111b8dc:	df000115 	stw	fp,4(sp)
8111b8e0:	df000104 	addi	fp,sp,4
8111b8e4:	2005883a 	mov	r2,r4
8111b8e8:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateMutexSResources. (exit)\n");
8111b8ec:	d0a06217 	ldw	r2,-32376(gp)
8111b8f0:	100f883a 	mov	r7,r2
8111b8f4:	018008c4 	movi	r6,35
8111b8f8:	01400044 	movi	r5,1
8111b8fc:	01204574 	movhi	r4,33045
8111b900:	213c4b04 	addi	r4,r4,-3796
8111b904:	1121c7c0 	call	81121c7c <fwrite>
	#endif
	#ifdef DEBUG_ON
		printErrorTask(error_code);
8111b908:	e0bfff03 	ldbu	r2,-4(fp)
8111b90c:	1009883a 	mov	r4,r2
8111b910:	111b85c0 	call	8111b85c <printErrorTask>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b914:	0001883a 	nop
8111b918:	e037883a 	mov	sp,fp
8111b91c:	dfc00117 	ldw	ra,4(sp)
8111b920:	df000017 	ldw	fp,0(sp)
8111b924:	dec00204 	addi	sp,sp,8
8111b928:	f800283a 	ret

8111b92c <vFailCreateMutexDMA>:

void vFailCreateMutexDMA( void )
{
8111b92c:	defffe04 	addi	sp,sp,-8
8111b930:	de00012e 	bgeu	sp,et,8111b938 <vFailCreateMutexDMA+0xc>
8111b934:	003b68fa 	trap	3
8111b938:	dfc00115 	stw	ra,4(sp)
8111b93c:	df000015 	stw	fp,0(sp)
8111b940:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp," CRITICAL: vFailCreateMutexDMA. (exit)\n");
8111b944:	d0a06217 	ldw	r2,-32376(gp)
8111b948:	100f883a 	mov	r7,r2
8111b94c:	018009c4 	movi	r6,39
8111b950:	01400044 	movi	r5,1
8111b954:	01204574 	movhi	r4,33045
8111b958:	213c5404 	addi	r4,r4,-3760
8111b95c:	1121c7c0 	call	81121c7c <fwrite>

	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b960:	0001883a 	nop
8111b964:	e037883a 	mov	sp,fp
8111b968:	dfc00117 	ldw	ra,4(sp)
8111b96c:	df000017 	ldw	fp,0(sp)
8111b970:	dec00204 	addi	sp,sp,8
8111b974:	f800283a 	ret

8111b978 <vFailCreateSemaphoreResources>:

void vFailCreateSemaphoreResources( void )
{
8111b978:	defffe04 	addi	sp,sp,-8
8111b97c:	de00012e 	bgeu	sp,et,8111b984 <vFailCreateSemaphoreResources+0xc>
8111b980:	003b68fa 	trap	3
8111b984:	dfc00115 	stw	ra,4(sp)
8111b988:	df000015 	stw	fp,0(sp)
8111b98c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateSemaphoreResources. (exit)\n");
8111b990:	d0a06217 	ldw	r2,-32376(gp)
8111b994:	100f883a 	mov	r7,r2
8111b998:	01800984 	movi	r6,38
8111b99c:	01400044 	movi	r5,1
8111b9a0:	01204574 	movhi	r4,33045
8111b9a4:	213c5e04 	addi	r4,r4,-3720
8111b9a8:	1121c7c0 	call	81121c7c <fwrite>

	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b9ac:	0001883a 	nop
8111b9b0:	e037883a 	mov	sp,fp
8111b9b4:	dfc00117 	ldw	ra,4(sp)
8111b9b8:	df000017 	ldw	fp,0(sp)
8111b9bc:	dec00204 	addi	sp,sp,8
8111b9c0:	f800283a 	ret

8111b9c4 <vFailTestCriticasParts>:


void vFailTestCriticasParts( void )
{
8111b9c4:	defffe04 	addi	sp,sp,-8
8111b9c8:	de00012e 	bgeu	sp,et,8111b9d0 <vFailTestCriticasParts+0xc>
8111b9cc:	003b68fa 	trap	3
8111b9d0:	dfc00115 	stw	ra,4(sp)
8111b9d4:	df000015 	stw	fp,0(sp)
8111b9d8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailTestCriticasParts. (exit)\n");
8111b9dc:	d0a06217 	ldw	r2,-32376(gp)
8111b9e0:	100f883a 	mov	r7,r2
8111b9e4:	018007c4 	movi	r6,31
8111b9e8:	01400044 	movi	r5,1
8111b9ec:	01204574 	movhi	r4,33045
8111b9f0:	213c6804 	addi	r4,r4,-3680
8111b9f4:	1121c7c0 	call	81121c7c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b9f8:	0001883a 	nop
8111b9fc:	e037883a 	mov	sp,fp
8111ba00:	dfc00117 	ldw	ra,4(sp)
8111ba04:	df000017 	ldw	fp,0(sp)
8111ba08:	dec00204 	addi	sp,sp,8
8111ba0c:	f800283a 	ret

8111ba10 <vFailSendxSemCommInit>:


void vFailSendxSemCommInit( void )
{
8111ba10:	defffe04 	addi	sp,sp,-8
8111ba14:	de00012e 	bgeu	sp,et,8111ba1c <vFailSendxSemCommInit+0xc>
8111ba18:	003b68fa 	trap	3
8111ba1c:	dfc00115 	stw	ra,4(sp)
8111ba20:	df000015 	stw	fp,0(sp)
8111ba24:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendxSemCommInit. (exit)");
8111ba28:	d0a06217 	ldw	r2,-32376(gp)
8111ba2c:	100f883a 	mov	r7,r2
8111ba30:	01800744 	movi	r6,29
8111ba34:	01400044 	movi	r5,1
8111ba38:	01204574 	movhi	r4,33045
8111ba3c:	213c7004 	addi	r4,r4,-3648
8111ba40:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the vParserRXTask. (exit)\n");
8111ba44:	d0a06217 	ldw	r2,-32376(gp)
8111ba48:	100f883a 	mov	r7,r2
8111ba4c:	01800a44 	movi	r6,41
8111ba50:	01400044 	movi	r5,1
8111ba54:	01204574 	movhi	r4,33045
8111ba58:	213c7804 	addi	r4,r4,-3616
8111ba5c:	1121c7c0 	call	81121c7c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ba60:	0001883a 	nop
8111ba64:	e037883a 	mov	sp,fp
8111ba68:	dfc00117 	ldw	ra,4(sp)
8111ba6c:	df000017 	ldw	fp,0(sp)
8111ba70:	dec00204 	addi	sp,sp,8
8111ba74:	f800283a 	ret

8111ba78 <vFailSendPreParsedSemaphore>:

void vFailSendPreParsedSemaphore( void )
{
8111ba78:	defffe04 	addi	sp,sp,-8
8111ba7c:	de00012e 	bgeu	sp,et,8111ba84 <vFailSendPreParsedSemaphore+0xc>
8111ba80:	003b68fa 	trap	3
8111ba84:	dfc00115 	stw	ra,4(sp)
8111ba88:	df000015 	stw	fp,0(sp)
8111ba8c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreParsedSemaphore. (exit)\n");
8111ba90:	d0a06217 	ldw	r2,-32376(gp)
8111ba94:	100f883a 	mov	r7,r2
8111ba98:	01800904 	movi	r6,36
8111ba9c:	01400044 	movi	r5,1
8111baa0:	01204574 	movhi	r4,33045
8111baa4:	213c8304 	addi	r4,r4,-3572
8111baa8:	1121c7c0 	call	81121c7c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111baac:	0001883a 	nop
8111bab0:	e037883a 	mov	sp,fp
8111bab4:	dfc00117 	ldw	ra,4(sp)
8111bab8:	df000017 	ldw	fp,0(sp)
8111babc:	dec00204 	addi	sp,sp,8
8111bac0:	f800283a 	ret

8111bac4 <vFailSendPreAckReceiverSemaphore>:

void vFailSendPreAckReceiverSemaphore( void )
{
8111bac4:	defffe04 	addi	sp,sp,-8
8111bac8:	de00012e 	bgeu	sp,et,8111bad0 <vFailSendPreAckReceiverSemaphore+0xc>
8111bacc:	003b68fa 	trap	3
8111bad0:	dfc00115 	stw	ra,4(sp)
8111bad4:	df000015 	stw	fp,0(sp)
8111bad8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreAckReceiverSemaphore. (exit)\n");
8111badc:	d0a06217 	ldw	r2,-32376(gp)
8111bae0:	100f883a 	mov	r7,r2
8111bae4:	01800a44 	movi	r6,41
8111bae8:	01400044 	movi	r5,1
8111baec:	01204574 	movhi	r4,33045
8111baf0:	213c8d04 	addi	r4,r4,-3532
8111baf4:	1121c7c0 	call	81121c7c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111baf8:	0001883a 	nop
8111bafc:	e037883a 	mov	sp,fp
8111bb00:	dfc00117 	ldw	ra,4(sp)
8111bb04:	df000017 	ldw	fp,0(sp)
8111bb08:	dec00204 	addi	sp,sp,8
8111bb0c:	f800283a 	ret

8111bb10 <vFailSendPreAckSenderSemaphore>:


void vFailSendPreAckSenderSemaphore( void )
{
8111bb10:	defffe04 	addi	sp,sp,-8
8111bb14:	de00012e 	bgeu	sp,et,8111bb1c <vFailSendPreAckSenderSemaphore+0xc>
8111bb18:	003b68fa 	trap	3
8111bb1c:	dfc00115 	stw	ra,4(sp)
8111bb20:	df000015 	stw	fp,0(sp)
8111bb24:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreAckSenderSemaphore. (exit)\n");
8111bb28:	d0a06217 	ldw	r2,-32376(gp)
8111bb2c:	100f883a 	mov	r7,r2
8111bb30:	018009c4 	movi	r6,39
8111bb34:	01400044 	movi	r5,1
8111bb38:	01204574 	movhi	r4,33045
8111bb3c:	213c9804 	addi	r4,r4,-3488
8111bb40:	1121c7c0 	call	81121c7c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bb44:	0001883a 	nop
8111bb48:	e037883a 	mov	sp,fp
8111bb4c:	dfc00117 	ldw	ra,4(sp)
8111bb50:	df000017 	ldw	fp,0(sp)
8111bb54:	dec00204 	addi	sp,sp,8
8111bb58:	f800283a 	ret

8111bb5c <vFailGetCountSemaphoreSenderTask>:


void vFailGetCountSemaphoreSenderTask( void )
{
8111bb5c:	defffe04 	addi	sp,sp,-8
8111bb60:	de00012e 	bgeu	sp,et,8111bb68 <vFailGetCountSemaphoreSenderTask+0xc>
8111bb64:	003b68fa 	trap	3
8111bb68:	dfc00115 	stw	ra,4(sp)
8111bb6c:	df000015 	stw	fp,0(sp)
8111bb70:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphoreSenderTask. (exit)\n");
8111bb74:	d0a06217 	ldw	r2,-32376(gp)
8111bb78:	100f883a 	mov	r7,r2
8111bb7c:	01800a44 	movi	r6,41
8111bb80:	01400044 	movi	r5,1
8111bb84:	01204574 	movhi	r4,33045
8111bb88:	213ca204 	addi	r4,r4,-3448
8111bb8c:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vSenderAckTask)\n");
8111bb90:	d0a06217 	ldw	r2,-32376(gp)
8111bb94:	100f883a 	mov	r7,r2
8111bb98:	01801104 	movi	r6,68
8111bb9c:	01400044 	movi	r5,1
8111bba0:	01204574 	movhi	r4,33045
8111bba4:	213cad04 	addi	r4,r4,-3404
8111bba8:	1121c7c0 	call	81121c7c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bbac:	0001883a 	nop
8111bbb0:	e037883a 	mov	sp,fp
8111bbb4:	dfc00117 	ldw	ra,4(sp)
8111bbb8:	df000017 	ldw	fp,0(sp)
8111bbbc:	dec00204 	addi	sp,sp,8
8111bbc0:	f800283a 	ret

8111bbc4 <vFailGetMutexSenderTask>:

void vFailGetMutexSenderTask( void )
{
8111bbc4:	defffe04 	addi	sp,sp,-8
8111bbc8:	de00012e 	bgeu	sp,et,8111bbd0 <vFailGetMutexSenderTask+0xc>
8111bbcc:	003b68fa 	trap	3
8111bbd0:	dfc00115 	stw	ra,4(sp)
8111bbd4:	df000015 	stw	fp,0(sp)
8111bbd8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexSenderTask. (exit)\n");
8111bbdc:	d0a06217 	ldw	r2,-32376(gp)
8111bbe0:	100f883a 	mov	r7,r2
8111bbe4:	01800804 	movi	r6,32
8111bbe8:	01400044 	movi	r5,1
8111bbec:	01204574 	movhi	r4,33045
8111bbf0:	213cbf04 	addi	r4,r4,-3332
8111bbf4:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the xSenderACK.(vSenderAckTask)\n");
8111bbf8:	d0a06217 	ldw	r2,-32376(gp)
8111bbfc:	100f883a 	mov	r7,r2
8111bc00:	01801084 	movi	r6,66
8111bc04:	01400044 	movi	r5,1
8111bc08:	01204574 	movhi	r4,33045
8111bc0c:	213cc804 	addi	r4,r4,-3296
8111bc10:	1121c7c0 	call	81121c7c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bc14:	0001883a 	nop
8111bc18:	e037883a 	mov	sp,fp
8111bc1c:	dfc00117 	ldw	ra,4(sp)
8111bc20:	df000017 	ldw	fp,0(sp)
8111bc24:	dec00204 	addi	sp,sp,8
8111bc28:	f800283a 	ret

8111bc2c <vFailGetCountSemaphoreReceiverTask>:


void vFailGetCountSemaphoreReceiverTask( void )
{
8111bc2c:	defffe04 	addi	sp,sp,-8
8111bc30:	de00012e 	bgeu	sp,et,8111bc38 <vFailGetCountSemaphoreReceiverTask+0xc>
8111bc34:	003b68fa 	trap	3
8111bc38:	dfc00115 	stw	ra,4(sp)
8111bc3c:	df000015 	stw	fp,0(sp)
8111bc40:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphoreReceiverTask. (exit)\n");
8111bc44:	d0a06217 	ldw	r2,-32376(gp)
8111bc48:	100f883a 	mov	r7,r2
8111bc4c:	01800ac4 	movi	r6,43
8111bc50:	01400044 	movi	r5,1
8111bc54:	01204574 	movhi	r4,33045
8111bc58:	213cd904 	addi	r4,r4,-3228
8111bc5c:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vReceiverAckTask)\n");
8111bc60:	d0a06217 	ldw	r2,-32376(gp)
8111bc64:	100f883a 	mov	r7,r2
8111bc68:	01801184 	movi	r6,70
8111bc6c:	01400044 	movi	r5,1
8111bc70:	01204574 	movhi	r4,33045
8111bc74:	213ce404 	addi	r4,r4,-3184
8111bc78:	1121c7c0 	call	81121c7c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bc7c:	0001883a 	nop
8111bc80:	e037883a 	mov	sp,fp
8111bc84:	dfc00117 	ldw	ra,4(sp)
8111bc88:	df000017 	ldw	fp,0(sp)
8111bc8c:	dec00204 	addi	sp,sp,8
8111bc90:	f800283a 	ret

8111bc94 <vFailGetMutexReceiverTask>:

void vFailGetMutexReceiverTask( void )
{
8111bc94:	defffe04 	addi	sp,sp,-8
8111bc98:	de00012e 	bgeu	sp,et,8111bca0 <vFailGetMutexReceiverTask+0xc>
8111bc9c:	003b68fa 	trap	3
8111bca0:	dfc00115 	stw	ra,4(sp)
8111bca4:	df000015 	stw	fp,0(sp)
8111bca8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexReceiverTask. (exit)\n");
8111bcac:	d0a06217 	ldw	r2,-32376(gp)
8111bcb0:	100f883a 	mov	r7,r2
8111bcb4:	01800884 	movi	r6,34
8111bcb8:	01400044 	movi	r5,1
8111bcbc:	01204574 	movhi	r4,33045
8111bcc0:	213cf604 	addi	r4,r4,-3112
8111bcc4:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the xSenderACK.(vReceiverAckTask)\n");
8111bcc8:	d0a06217 	ldw	r2,-32376(gp)
8111bccc:	100f883a 	mov	r7,r2
8111bcd0:	01801104 	movi	r6,68
8111bcd4:	01400044 	movi	r5,1
8111bcd8:	01204574 	movhi	r4,33045
8111bcdc:	213cff04 	addi	r4,r4,-3076
8111bce0:	1121c7c0 	call	81121c7c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bce4:	0001883a 	nop
8111bce8:	e037883a 	mov	sp,fp
8111bcec:	dfc00117 	ldw	ra,4(sp)
8111bcf0:	df000017 	ldw	fp,0(sp)
8111bcf4:	dec00204 	addi	sp,sp,8
8111bcf8:	f800283a 	ret

8111bcfc <vFailGetMutexTxUARTSenderTask>:


void vFailGetMutexTxUARTSenderTask( void )
{
8111bcfc:	defffe04 	addi	sp,sp,-8
8111bd00:	de00012e 	bgeu	sp,et,8111bd08 <vFailGetMutexTxUARTSenderTask+0xc>
8111bd04:	003b68fa 	trap	3
8111bd08:	dfc00115 	stw	ra,4(sp)
8111bd0c:	df000015 	stw	fp,0(sp)
8111bd10:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexTxUARTSenderTask. (exit)\n");
8111bd14:	d0a06217 	ldw	r2,-32376(gp)
8111bd18:	100f883a 	mov	r7,r2
8111bd1c:	01800984 	movi	r6,38
8111bd20:	01400044 	movi	r5,1
8111bd24:	01204574 	movhi	r4,33045
8111bd28:	213d1104 	addi	r4,r4,-3004
8111bd2c:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the tx buffer.(vSenderAckTask)\n");
8111bd30:	d0a06217 	ldw	r2,-32376(gp)
8111bd34:	100f883a 	mov	r7,r2
8111bd38:	01801044 	movi	r6,65
8111bd3c:	01400044 	movi	r5,1
8111bd40:	01204574 	movhi	r4,33045
8111bd44:	213d1b04 	addi	r4,r4,-2964
8111bd48:	1121c7c0 	call	81121c7c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bd4c:	0001883a 	nop
8111bd50:	e037883a 	mov	sp,fp
8111bd54:	dfc00117 	ldw	ra,4(sp)
8111bd58:	df000017 	ldw	fp,0(sp)
8111bd5c:	dec00204 	addi	sp,sp,8
8111bd60:	f800283a 	ret

8111bd64 <vFailGetMacRTC>:


void vFailGetMacRTC( void )
{
8111bd64:	defffe04 	addi	sp,sp,-8
8111bd68:	de00012e 	bgeu	sp,et,8111bd70 <vFailGetMacRTC+0xc>
8111bd6c:	003b68fa 	trap	3
8111bd70:	dfc00115 	stw	ra,4(sp)
8111bd74:	df000015 	stw	fp,0(sp)
8111bd78:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMacRTC\n");
8111bd7c:	d0a06217 	ldw	r2,-32376(gp)
8111bd80:	100f883a 	mov	r7,r2
8111bd84:	018003c4 	movi	r6,15
8111bd88:	01400044 	movi	r5,1
8111bd8c:	01204574 	movhi	r4,33045
8111bd90:	213d2c04 	addi	r4,r4,-2896
8111bd94:	1121c7c0 	call	81121c7c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bd98:	0001883a 	nop
8111bd9c:	e037883a 	mov	sp,fp
8111bda0:	dfc00117 	ldw	ra,4(sp)
8111bda4:	df000017 	ldw	fp,0(sp)
8111bda8:	dec00204 	addi	sp,sp,8
8111bdac:	f800283a 	ret

8111bdb0 <vFailInitialization>:


void vFailInitialization( void )
{
8111bdb0:	defffe04 	addi	sp,sp,-8
8111bdb4:	de00012e 	bgeu	sp,et,8111bdbc <vFailInitialization+0xc>
8111bdb8:	003b68fa 	trap	3
8111bdbc:	dfc00115 	stw	ra,4(sp)
8111bdc0:	df000015 	stw	fp,0(sp)
8111bdc4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInitialization\n");
8111bdc8:	d0a06217 	ldw	r2,-32376(gp)
8111bdcc:	100f883a 	mov	r7,r2
8111bdd0:	01800504 	movi	r6,20
8111bdd4:	01400044 	movi	r5,1
8111bdd8:	01204574 	movhi	r4,33045
8111bddc:	213d3004 	addi	r4,r4,-2880
8111bde0:	1121c7c0 	call	81121c7c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bde4:	0001883a 	nop
8111bde8:	e037883a 	mov	sp,fp
8111bdec:	dfc00117 	ldw	ra,4(sp)
8111bdf0:	df000017 	ldw	fp,0(sp)
8111bdf4:	dec00204 	addi	sp,sp,8
8111bdf8:	f800283a 	ret

8111bdfc <vFailReceiverCreate>:


void vFailReceiverCreate( void )
{
8111bdfc:	defffe04 	addi	sp,sp,-8
8111be00:	de00012e 	bgeu	sp,et,8111be08 <vFailReceiverCreate+0xc>
8111be04:	003b68fa 	trap	3
8111be08:	dfc00115 	stw	ra,4(sp)
8111be0c:	df000015 	stw	fp,0(sp)
8111be10:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vReceiverUartTask\n");
8111be14:	d0a06217 	ldw	r2,-32376(gp)
8111be18:	100f883a 	mov	r7,r2
8111be1c:	01800484 	movi	r6,18
8111be20:	01400044 	movi	r5,1
8111be24:	01204574 	movhi	r4,33045
8111be28:	213d3604 	addi	r4,r4,-2856
8111be2c:	1121c7c0 	call	81121c7c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111be30:	0001883a 	nop
8111be34:	e037883a 	mov	sp,fp
8111be38:	dfc00117 	ldw	ra,4(sp)
8111be3c:	df000017 	ldw	fp,0(sp)
8111be40:	dec00204 	addi	sp,sp,8
8111be44:	f800283a 	ret

8111be48 <vFailSenderCreate>:


void vFailSenderCreate( void )
{
8111be48:	defffe04 	addi	sp,sp,-8
8111be4c:	de00012e 	bgeu	sp,et,8111be54 <vFailSenderCreate+0xc>
8111be50:	003b68fa 	trap	3
8111be54:	dfc00115 	stw	ra,4(sp)
8111be58:	df000015 	stw	fp,0(sp)
8111be5c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSenderCreate\n");
8111be60:	d0a06217 	ldw	r2,-32376(gp)
8111be64:	100f883a 	mov	r7,r2
8111be68:	01800484 	movi	r6,18
8111be6c:	01400044 	movi	r5,1
8111be70:	01204574 	movhi	r4,33045
8111be74:	213d3b04 	addi	r4,r4,-2836
8111be78:	1121c7c0 	call	81121c7c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111be7c:	0001883a 	nop
8111be80:	e037883a 	mov	sp,fp
8111be84:	dfc00117 	ldw	ra,4(sp)
8111be88:	df000017 	ldw	fp,0(sp)
8111be8c:	dec00204 	addi	sp,sp,8
8111be90:	f800283a 	ret

8111be94 <vFailDeleteInitialization>:


void vFailDeleteInitialization( void )
{
8111be94:	defffe04 	addi	sp,sp,-8
8111be98:	de00012e 	bgeu	sp,et,8111bea0 <vFailDeleteInitialization+0xc>
8111be9c:	003b68fa 	trap	3
8111bea0:	dfc00115 	stw	ra,4(sp)
8111bea4:	df000015 	stw	fp,0(sp)
8111bea8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailDeleteInitialization\n");
8111beac:	d0a06217 	ldw	r2,-32376(gp)
8111beb0:	100f883a 	mov	r7,r2
8111beb4:	01800684 	movi	r6,26
8111beb8:	01400044 	movi	r5,1
8111bebc:	01204574 	movhi	r4,33045
8111bec0:	213d4004 	addi	r4,r4,-2816
8111bec4:	1121c7c0 	call	81121c7c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bec8:	0001883a 	nop
8111becc:	e037883a 	mov	sp,fp
8111bed0:	dfc00117 	ldw	ra,4(sp)
8111bed4:	df000017 	ldw	fp,0(sp)
8111bed8:	dec00204 	addi	sp,sp,8
8111bedc:	f800283a 	ret

8111bee0 <vFailSetCountSemaphorexBuffer32>:


void vFailSetCountSemaphorexBuffer32( void )
{
8111bee0:	defffe04 	addi	sp,sp,-8
8111bee4:	de00012e 	bgeu	sp,et,8111beec <vFailSetCountSemaphorexBuffer32+0xc>
8111bee8:	003b68fa 	trap	3
8111beec:	dfc00115 	stw	ra,4(sp)
8111bef0:	df000015 	stw	fp,0(sp)
8111bef4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer32. (exit)\n");
8111bef8:	d0a06217 	ldw	r2,-32376(gp)
8111befc:	100f883a 	mov	r7,r2
8111bf00:	01800a04 	movi	r6,40
8111bf04:	01400044 	movi	r5,1
8111bf08:	01204574 	movhi	r4,33045
8111bf0c:	213d4704 	addi	r4,r4,-2788
8111bf10:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
8111bf14:	d0a06217 	ldw	r2,-32376(gp)
8111bf18:	100f883a 	mov	r7,r2
8111bf1c:	018008c4 	movi	r6,35
8111bf20:	01400044 	movi	r5,1
8111bf24:	01204574 	movhi	r4,33045
8111bf28:	213d5204 	addi	r4,r4,-2744
8111bf2c:	1121c7c0 	call	81121c7c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bf30:	0001883a 	nop
8111bf34:	e037883a 	mov	sp,fp
8111bf38:	dfc00117 	ldw	ra,4(sp)
8111bf3c:	df000017 	ldw	fp,0(sp)
8111bf40:	dec00204 	addi	sp,sp,8
8111bf44:	f800283a 	ret

8111bf48 <vFailSetCountSemaphorexBuffer64>:

void vFailSetCountSemaphorexBuffer64( void )
{
8111bf48:	defffe04 	addi	sp,sp,-8
8111bf4c:	de00012e 	bgeu	sp,et,8111bf54 <vFailSetCountSemaphorexBuffer64+0xc>
8111bf50:	003b68fa 	trap	3
8111bf54:	dfc00115 	stw	ra,4(sp)
8111bf58:	df000015 	stw	fp,0(sp)
8111bf5c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer64. (exit)\n");
8111bf60:	d0a06217 	ldw	r2,-32376(gp)
8111bf64:	100f883a 	mov	r7,r2
8111bf68:	01800a04 	movi	r6,40
8111bf6c:	01400044 	movi	r5,1
8111bf70:	01204574 	movhi	r4,33045
8111bf74:	213d5b04 	addi	r4,r4,-2708
8111bf78:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
8111bf7c:	d0a06217 	ldw	r2,-32376(gp)
8111bf80:	100f883a 	mov	r7,r2
8111bf84:	018008c4 	movi	r6,35
8111bf88:	01400044 	movi	r5,1
8111bf8c:	01204574 	movhi	r4,33045
8111bf90:	213d5204 	addi	r4,r4,-2744
8111bf94:	1121c7c0 	call	81121c7c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bf98:	0001883a 	nop
8111bf9c:	e037883a 	mov	sp,fp
8111bfa0:	dfc00117 	ldw	ra,4(sp)
8111bfa4:	df000017 	ldw	fp,0(sp)
8111bfa8:	dec00204 	addi	sp,sp,8
8111bfac:	f800283a 	ret

8111bfb0 <vFailSetCountSemaphorexBuffer128>:

/*CRITICAL*/
void vFailSetCountSemaphorexBuffer128( void )
{
8111bfb0:	defffe04 	addi	sp,sp,-8
8111bfb4:	de00012e 	bgeu	sp,et,8111bfbc <vFailSetCountSemaphorexBuffer128+0xc>
8111bfb8:	003b68fa 	trap	3
8111bfbc:	dfc00115 	stw	ra,4(sp)
8111bfc0:	df000015 	stw	fp,0(sp)
8111bfc4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer128. (exit)\n");
8111bfc8:	d0a06217 	ldw	r2,-32376(gp)
8111bfcc:	100f883a 	mov	r7,r2
8111bfd0:	01800a44 	movi	r6,41
8111bfd4:	01400044 	movi	r5,1
8111bfd8:	01204574 	movhi	r4,33045
8111bfdc:	213d6604 	addi	r4,r4,-2664
8111bfe0:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
8111bfe4:	d0a06217 	ldw	r2,-32376(gp)
8111bfe8:	100f883a 	mov	r7,r2
8111bfec:	018008c4 	movi	r6,35
8111bff0:	01400044 	movi	r5,1
8111bff4:	01204574 	movhi	r4,33045
8111bff8:	213d5204 	addi	r4,r4,-2744
8111bffc:	1121c7c0 	call	81121c7c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c000:	0001883a 	nop
8111c004:	e037883a 	mov	sp,fp
8111c008:	dfc00117 	ldw	ra,4(sp)
8111c00c:	df000017 	ldw	fp,0(sp)
8111c010:	dec00204 	addi	sp,sp,8
8111c014:	f800283a 	ret

8111c018 <vFailGetCountSemaphorexBuffer128>:

void vFailGetCountSemaphorexBuffer128( void )
{
8111c018:	defffe04 	addi	sp,sp,-8
8111c01c:	de00012e 	bgeu	sp,et,8111c024 <vFailGetCountSemaphorexBuffer128+0xc>
8111c020:	003b68fa 	trap	3
8111c024:	dfc00115 	stw	ra,4(sp)
8111c028:	df000015 	stw	fp,0(sp)
8111c02c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer128. (exit)\n");
8111c030:	d0a06217 	ldw	r2,-32376(gp)
8111c034:	100f883a 	mov	r7,r2
8111c038:	01800a44 	movi	r6,41
8111c03c:	01400044 	movi	r5,1
8111c040:	01204574 	movhi	r4,33045
8111c044:	213d7104 	addi	r4,r4,-2620
8111c048:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
8111c04c:	d0a06217 	ldw	r2,-32376(gp)
8111c050:	100f883a 	mov	r7,r2
8111c054:	01800884 	movi	r6,34
8111c058:	01400044 	movi	r5,1
8111c05c:	01204574 	movhi	r4,33045
8111c060:	213d7c04 	addi	r4,r4,-2576
8111c064:	1121c7c0 	call	81121c7c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c068:	0001883a 	nop
8111c06c:	e037883a 	mov	sp,fp
8111c070:	dfc00117 	ldw	ra,4(sp)
8111c074:	df000017 	ldw	fp,0(sp)
8111c078:	dec00204 	addi	sp,sp,8
8111c07c:	f800283a 	ret

8111c080 <vFailGetCountSemaphorexBuffer64>:

void vFailGetCountSemaphorexBuffer64( void )
{
8111c080:	defffe04 	addi	sp,sp,-8
8111c084:	de00012e 	bgeu	sp,et,8111c08c <vFailGetCountSemaphorexBuffer64+0xc>
8111c088:	003b68fa 	trap	3
8111c08c:	dfc00115 	stw	ra,4(sp)
8111c090:	df000015 	stw	fp,0(sp)
8111c094:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer64. (exit)\n");
8111c098:	d0a06217 	ldw	r2,-32376(gp)
8111c09c:	100f883a 	mov	r7,r2
8111c0a0:	01800a04 	movi	r6,40
8111c0a4:	01400044 	movi	r5,1
8111c0a8:	01204574 	movhi	r4,33045
8111c0ac:	213d8504 	addi	r4,r4,-2540
8111c0b0:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
8111c0b4:	d0a06217 	ldw	r2,-32376(gp)
8111c0b8:	100f883a 	mov	r7,r2
8111c0bc:	01800884 	movi	r6,34
8111c0c0:	01400044 	movi	r5,1
8111c0c4:	01204574 	movhi	r4,33045
8111c0c8:	213d7c04 	addi	r4,r4,-2576
8111c0cc:	1121c7c0 	call	81121c7c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c0d0:	0001883a 	nop
8111c0d4:	e037883a 	mov	sp,fp
8111c0d8:	dfc00117 	ldw	ra,4(sp)
8111c0dc:	df000017 	ldw	fp,0(sp)
8111c0e0:	dec00204 	addi	sp,sp,8
8111c0e4:	f800283a 	ret

8111c0e8 <vFailGetCountSemaphorexBuffer32>:

void vFailGetCountSemaphorexBuffer32( void )
{
8111c0e8:	defffe04 	addi	sp,sp,-8
8111c0ec:	de00012e 	bgeu	sp,et,8111c0f4 <vFailGetCountSemaphorexBuffer32+0xc>
8111c0f0:	003b68fa 	trap	3
8111c0f4:	dfc00115 	stw	ra,4(sp)
8111c0f8:	df000015 	stw	fp,0(sp)
8111c0fc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer32. (exit)\n");
8111c100:	d0a06217 	ldw	r2,-32376(gp)
8111c104:	100f883a 	mov	r7,r2
8111c108:	01800a04 	movi	r6,40
8111c10c:	01400044 	movi	r5,1
8111c110:	01204574 	movhi	r4,33045
8111c114:	213d9004 	addi	r4,r4,-2496
8111c118:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
8111c11c:	d0a06217 	ldw	r2,-32376(gp)
8111c120:	100f883a 	mov	r7,r2
8111c124:	01800884 	movi	r6,34
8111c128:	01400044 	movi	r5,1
8111c12c:	01204574 	movhi	r4,33045
8111c130:	213d7c04 	addi	r4,r4,-2576
8111c134:	1121c7c0 	call	81121c7c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c138:	0001883a 	nop
8111c13c:	e037883a 	mov	sp,fp
8111c140:	dfc00117 	ldw	ra,4(sp)
8111c144:	df000017 	ldw	fp,0(sp)
8111c148:	dec00204 	addi	sp,sp,8
8111c14c:	f800283a 	ret

8111c150 <vFailFoundBufferRetransmission>:

void vFailFoundBufferRetransmission( void )
{
8111c150:	defffe04 	addi	sp,sp,-8
8111c154:	de00012e 	bgeu	sp,et,8111c15c <vFailFoundBufferRetransmission+0xc>
8111c158:	003b68fa 	trap	3
8111c15c:	dfc00115 	stw	ra,4(sp)
8111c160:	df000015 	stw	fp,0(sp)
8111c164:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"Warning: Incomming Ack id doesn't exists.\n");
8111c168:	d0a06217 	ldw	r2,-32376(gp)
8111c16c:	100f883a 	mov	r7,r2
8111c170:	01800a84 	movi	r6,42
8111c174:	01400044 	movi	r5,1
8111c178:	01204574 	movhi	r4,33045
8111c17c:	213d9b04 	addi	r4,r4,-2452
8111c180:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not found the id in the (re)transmission buffers.(In Ack Handler)\n");
8111c184:	d0a06217 	ldw	r2,-32376(gp)
8111c188:	100f883a 	mov	r7,r2
8111c18c:	01801204 	movi	r6,72
8111c190:	01400044 	movi	r5,1
8111c194:	01204574 	movhi	r4,33045
8111c198:	213da604 	addi	r4,r4,-2408
8111c19c:	1121c7c0 	call	81121c7c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c1a0:	0001883a 	nop
8111c1a4:	e037883a 	mov	sp,fp
8111c1a8:	dfc00117 	ldw	ra,4(sp)
8111c1ac:	df000017 	ldw	fp,0(sp)
8111c1b0:	dec00204 	addi	sp,sp,8
8111c1b4:	f800283a 	ret

8111c1b8 <vFailGetCountSemaphorePreParsedBuffer>:


void vFailGetCountSemaphorePreParsedBuffer( void )
{
8111c1b8:	defffe04 	addi	sp,sp,-8
8111c1bc:	de00012e 	bgeu	sp,et,8111c1c4 <vFailGetCountSemaphorePreParsedBuffer+0xc>
8111c1c0:	003b68fa 	trap	3
8111c1c4:	dfc00115 	stw	ra,4(sp)
8111c1c8:	df000015 	stw	fp,0(sp)
8111c1cc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorePreParsedBuffer. (exit)\n");
8111c1d0:	d0a06217 	ldw	r2,-32376(gp)
8111c1d4:	100f883a 	mov	r7,r2
8111c1d8:	01800b84 	movi	r6,46
8111c1dc:	01400044 	movi	r5,1
8111c1e0:	01204574 	movhi	r4,33045
8111c1e4:	213db904 	addi	r4,r4,-2332
8111c1e8:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vParserRXTask)\n");
8111c1ec:	d0a06217 	ldw	r2,-32376(gp)
8111c1f0:	100f883a 	mov	r7,r2
8111c1f4:	018010c4 	movi	r6,67
8111c1f8:	01400044 	movi	r5,1
8111c1fc:	01204574 	movhi	r4,33045
8111c200:	213dc504 	addi	r4,r4,-2284
8111c204:	1121c7c0 	call	81121c7c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c208:	0001883a 	nop
8111c20c:	e037883a 	mov	sp,fp
8111c210:	dfc00117 	ldw	ra,4(sp)
8111c214:	df000017 	ldw	fp,0(sp)
8111c218:	dec00204 	addi	sp,sp,8
8111c21c:	f800283a 	ret

8111c220 <vFailGetxMutexPreParsedParserRxTask>:


void vFailGetxMutexPreParsedParserRxTask( void )
{
8111c220:	defffe04 	addi	sp,sp,-8
8111c224:	de00012e 	bgeu	sp,et,8111c22c <vFailGetxMutexPreParsedParserRxTask+0xc>
8111c228:	003b68fa 	trap	3
8111c22c:	dfc00115 	stw	ra,4(sp)
8111c230:	df000015 	stw	fp,0(sp)
8111c234:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetxMutexPreParsedParserRxTask. (exit)\n");
8111c238:	d0a06217 	ldw	r2,-32376(gp)
8111c23c:	100f883a 	mov	r7,r2
8111c240:	01800b04 	movi	r6,44
8111c244:	01400044 	movi	r5,1
8111c248:	01204574 	movhi	r4,33045
8111c24c:	213dd604 	addi	r4,r4,-2216
8111c250:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the mutex and some error happens.(vParserRXTask)\n");
8111c254:	d0a06217 	ldw	r2,-32376(gp)
8111c258:	100f883a 	mov	r7,r2
8111c25c:	01800fc4 	movi	r6,63
8111c260:	01400044 	movi	r5,1
8111c264:	01204574 	movhi	r4,33045
8111c268:	213de204 	addi	r4,r4,-2168
8111c26c:	1121c7c0 	call	81121c7c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c270:	0001883a 	nop
8111c274:	e037883a 	mov	sp,fp
8111c278:	dfc00117 	ldw	ra,4(sp)
8111c27c:	df000017 	ldw	fp,0(sp)
8111c280:	dec00204 	addi	sp,sp,8
8111c284:	f800283a 	ret

8111c288 <vNoContentInPreParsedBuffer>:


void vNoContentInPreParsedBuffer( void )
{
8111c288:	defffe04 	addi	sp,sp,-8
8111c28c:	de00012e 	bgeu	sp,et,8111c294 <vNoContentInPreParsedBuffer+0xc>
8111c290:	003b68fa 	trap	3
8111c294:	dfc00115 	stw	ra,4(sp)
8111c298:	df000015 	stw	fp,0(sp)
8111c29c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vNoContentInPreParsedBuffer. (exit)\n");
8111c2a0:	d0a06217 	ldw	r2,-32376(gp)
8111c2a4:	100f883a 	mov	r7,r2
8111c2a8:	01800904 	movi	r6,36
8111c2ac:	01400044 	movi	r5,1
8111c2b0:	01204574 	movhi	r4,33045
8111c2b4:	213df204 	addi	r4,r4,-2104
8111c2b8:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Semaphore was post by some task but has no message in the PreParsedBuffer.(vParserRXTask)\n");
8111c2bc:	d0a06217 	ldw	r2,-32376(gp)
8111c2c0:	100f883a 	mov	r7,r2
8111c2c4:	01801684 	movi	r6,90
8111c2c8:	01400044 	movi	r5,1
8111c2cc:	01204574 	movhi	r4,33045
8111c2d0:	213dfc04 	addi	r4,r4,-2064
8111c2d4:	1121c7c0 	call	81121c7c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c2d8:	0001883a 	nop
8111c2dc:	e037883a 	mov	sp,fp
8111c2e0:	dfc00117 	ldw	ra,4(sp)
8111c2e4:	df000017 	ldw	fp,0(sp)
8111c2e8:	dec00204 	addi	sp,sp,8
8111c2ec:	f800283a 	ret

8111c2f0 <vCouldNotSendEthConfUART>:


void vCouldNotSendEthConfUART( void )
{
8111c2f0:	defffe04 	addi	sp,sp,-8
8111c2f4:	de00012e 	bgeu	sp,et,8111c2fc <vCouldNotSendEthConfUART+0xc>
8111c2f8:	003b68fa 	trap	3
8111c2fc:	dfc00115 	stw	ra,4(sp)
8111c300:	df000015 	stw	fp,0(sp)
8111c304:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendEthConfUART. (exit)\n");
8111c308:	d0a06217 	ldw	r2,-32376(gp)
8111c30c:	100f883a 	mov	r7,r2
8111c310:	01800844 	movi	r6,33
8111c314:	01400044 	movi	r5,1
8111c318:	01204574 	movhi	r4,33045
8111c31c:	213e1304 	addi	r4,r4,-1972
8111c320:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send or not write ETH conf of the NUC in the (re)transmission buffer.(vSendEthConf)\n");
8111c324:	d0a06217 	ldw	r2,-32376(gp)
8111c328:	100f883a 	mov	r7,r2
8111c32c:	01801784 	movi	r6,94
8111c330:	01400044 	movi	r5,1
8111c334:	01204574 	movhi	r4,33045
8111c338:	213e1c04 	addi	r4,r4,-1936
8111c33c:	1121c7c0 	call	81121c7c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c340:	0001883a 	nop
8111c344:	e037883a 	mov	sp,fp
8111c348:	dfc00117 	ldw	ra,4(sp)
8111c34c:	df000017 	ldw	fp,0(sp)
8111c350:	dec00204 	addi	sp,sp,8
8111c354:	f800283a 	ret

8111c358 <vFailSendNack>:

void vFailSendNack( void )
{
8111c358:	defffe04 	addi	sp,sp,-8
8111c35c:	de00012e 	bgeu	sp,et,8111c364 <vFailSendNack+0xc>
8111c360:	003b68fa 	trap	3
8111c364:	dfc00115 	stw	ra,4(sp)
8111c368:	df000015 	stw	fp,0(sp)
8111c36c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendNack. (exit)\n");
8111c370:	d0a06217 	ldw	r2,-32376(gp)
8111c374:	100f883a 	mov	r7,r2
8111c378:	01800584 	movi	r6,22
8111c37c:	01400044 	movi	r5,1
8111c380:	01204574 	movhi	r4,33045
8111c384:	213e3404 	addi	r4,r4,-1840
8111c388:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Send Nack using the PreAckSender buffer. \n");
8111c38c:	d0a06217 	ldw	r2,-32376(gp)
8111c390:	100f883a 	mov	r7,r2
8111c394:	01800a84 	movi	r6,42
8111c398:	01400044 	movi	r5,1
8111c39c:	01204574 	movhi	r4,33045
8111c3a0:	213e3a04 	addi	r4,r4,-1816
8111c3a4:	1121c7c0 	call	81121c7c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c3a8:	0001883a 	nop
8111c3ac:	e037883a 	mov	sp,fp
8111c3b0:	dfc00117 	ldw	ra,4(sp)
8111c3b4:	df000017 	ldw	fp,0(sp)
8111c3b8:	dec00204 	addi	sp,sp,8
8111c3bc:	f800283a 	ret

8111c3c0 <vFailSetPreAckSenderBuffer>:

void vFailSetPreAckSenderBuffer( void )
{
8111c3c0:	defffe04 	addi	sp,sp,-8
8111c3c4:	de00012e 	bgeu	sp,et,8111c3cc <vFailSetPreAckSenderBuffer+0xc>
8111c3c8:	003b68fa 	trap	3
8111c3cc:	dfc00115 	stw	ra,4(sp)
8111c3d0:	df000015 	stw	fp,0(sp)
8111c3d4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreAckSenderBuffer. (exit)\n");
8111c3d8:	d0a06217 	ldw	r2,-32376(gp)
8111c3dc:	100f883a 	mov	r7,r2
8111c3e0:	018008c4 	movi	r6,35
8111c3e4:	01400044 	movi	r5,1
8111c3e8:	01204574 	movhi	r4,33045
8111c3ec:	213e4504 	addi	r4,r4,-1772
8111c3f0:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task out_ack_handler using the PreAckSender buffer.\n");
8111c3f4:	d0a06217 	ldw	r2,-32376(gp)
8111c3f8:	100f883a 	mov	r7,r2
8111c3fc:	01801584 	movi	r6,86
8111c400:	01400044 	movi	r5,1
8111c404:	01204574 	movhi	r4,33045
8111c408:	213e4e04 	addi	r4,r4,-1736
8111c40c:	1121c7c0 	call	81121c7c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c410:	0001883a 	nop
8111c414:	e037883a 	mov	sp,fp
8111c418:	dfc00117 	ldw	ra,4(sp)
8111c41c:	df000017 	ldw	fp,0(sp)
8111c420:	dec00204 	addi	sp,sp,8
8111c424:	f800283a 	ret

8111c428 <vFailSetPreParsedBuffer>:

void vFailSetPreParsedBuffer( void )
{
8111c428:	defffe04 	addi	sp,sp,-8
8111c42c:	de00012e 	bgeu	sp,et,8111c434 <vFailSetPreParsedBuffer+0xc>
8111c430:	003b68fa 	trap	3
8111c434:	dfc00115 	stw	ra,4(sp)
8111c438:	df000015 	stw	fp,0(sp)
8111c43c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreParsedBuffer. (exit)\n");
8111c440:	d0a06217 	ldw	r2,-32376(gp)
8111c444:	100f883a 	mov	r7,r2
8111c448:	01800804 	movi	r6,32
8111c44c:	01400044 	movi	r5,1
8111c450:	01204574 	movhi	r4,33045
8111c454:	213e6404 	addi	r4,r4,-1648
8111c458:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task parser_comm using the PreParsed buffer.\n");
8111c45c:	d0a06217 	ldw	r2,-32376(gp)
8111c460:	100f883a 	mov	r7,r2
8111c464:	018013c4 	movi	r6,79
8111c468:	01400044 	movi	r5,1
8111c46c:	01204574 	movhi	r4,33045
8111c470:	213e6d04 	addi	r4,r4,-1612
8111c474:	1121c7c0 	call	81121c7c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c478:	0001883a 	nop
8111c47c:	e037883a 	mov	sp,fp
8111c480:	dfc00117 	ldw	ra,4(sp)
8111c484:	df000017 	ldw	fp,0(sp)
8111c488:	dec00204 	addi	sp,sp,8
8111c48c:	f800283a 	ret

8111c490 <vFailSetPreAckReceiverBuffer>:


void vFailSetPreAckReceiverBuffer( void )
{
8111c490:	defffe04 	addi	sp,sp,-8
8111c494:	de00012e 	bgeu	sp,et,8111c49c <vFailSetPreAckReceiverBuffer+0xc>
8111c498:	003b68fa 	trap	3
8111c49c:	dfc00115 	stw	ra,4(sp)
8111c4a0:	df000015 	stw	fp,0(sp)
8111c4a4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreAckReceiverBuffer. (exit)\n");
8111c4a8:	d0a06217 	ldw	r2,-32376(gp)
8111c4ac:	100f883a 	mov	r7,r2
8111c4b0:	01800944 	movi	r6,37
8111c4b4:	01400044 	movi	r5,1
8111c4b8:	01204574 	movhi	r4,33045
8111c4bc:	213e8104 	addi	r4,r4,-1532
8111c4c0:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task in_out_handler using the PreAckReceiver buffer.\n");
8111c4c4:	d0a06217 	ldw	r2,-32376(gp)
8111c4c8:	100f883a 	mov	r7,r2
8111c4cc:	018015c4 	movi	r6,87
8111c4d0:	01400044 	movi	r5,1
8111c4d4:	01204574 	movhi	r4,33045
8111c4d8:	213e8b04 	addi	r4,r4,-1492
8111c4dc:	1121c7c0 	call	81121c7c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c4e0:	0001883a 	nop
8111c4e4:	e037883a 	mov	sp,fp
8111c4e8:	dfc00117 	ldw	ra,4(sp)
8111c4ec:	df000017 	ldw	fp,0(sp)
8111c4f0:	dec00204 	addi	sp,sp,8
8111c4f4:	f800283a 	ret

8111c4f8 <vFailParserCommTaskCreate>:


void vFailParserCommTaskCreate( void )
{
8111c4f8:	defffe04 	addi	sp,sp,-8
8111c4fc:	de00012e 	bgeu	sp,et,8111c504 <vFailParserCommTaskCreate+0xc>
8111c500:	003b68fa 	trap	3
8111c504:	dfc00115 	stw	ra,4(sp)
8111c508:	df000015 	stw	fp,0(sp)
8111c50c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailParserCommTaskCreate\n");
8111c510:	d0a06217 	ldw	r2,-32376(gp)
8111c514:	100f883a 	mov	r7,r2
8111c518:	01800684 	movi	r6,26
8111c51c:	01400044 	movi	r5,1
8111c520:	01204574 	movhi	r4,33045
8111c524:	213ea104 	addi	r4,r4,-1404
8111c528:	1121c7c0 	call	81121c7c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c52c:	0001883a 	nop
8111c530:	e037883a 	mov	sp,fp
8111c534:	dfc00117 	ldw	ra,4(sp)
8111c538:	df000017 	ldw	fp,0(sp)
8111c53c:	dec00204 	addi	sp,sp,8
8111c540:	f800283a 	ret

8111c544 <vFailInAckHandlerTaskCreate>:

void vFailInAckHandlerTaskCreate( void )
{
8111c544:	defffe04 	addi	sp,sp,-8
8111c548:	de00012e 	bgeu	sp,et,8111c550 <vFailInAckHandlerTaskCreate+0xc>
8111c54c:	003b68fa 	trap	3
8111c550:	dfc00115 	stw	ra,4(sp)
8111c554:	df000015 	stw	fp,0(sp)
8111c558:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInAckHandlerTaskCreate\n");
8111c55c:	d0a06217 	ldw	r2,-32376(gp)
8111c560:	100f883a 	mov	r7,r2
8111c564:	01800704 	movi	r6,28
8111c568:	01400044 	movi	r5,1
8111c56c:	01204574 	movhi	r4,33045
8111c570:	213ea804 	addi	r4,r4,-1376
8111c574:	1121c7c0 	call	81121c7c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c578:	0001883a 	nop
8111c57c:	e037883a 	mov	sp,fp
8111c580:	dfc00117 	ldw	ra,4(sp)
8111c584:	df000017 	ldw	fp,0(sp)
8111c588:	dec00204 	addi	sp,sp,8
8111c58c:	f800283a 	ret

8111c590 <vFailOutAckHandlerTaskCreate>:

void vFailOutAckHandlerTaskCreate( void )
{
8111c590:	defffe04 	addi	sp,sp,-8
8111c594:	de00012e 	bgeu	sp,et,8111c59c <vFailOutAckHandlerTaskCreate+0xc>
8111c598:	003b68fa 	trap	3
8111c59c:	dfc00115 	stw	ra,4(sp)
8111c5a0:	df000015 	stw	fp,0(sp)
8111c5a4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInAckHandlerTaskCreate\n");
8111c5a8:	d0a06217 	ldw	r2,-32376(gp)
8111c5ac:	100f883a 	mov	r7,r2
8111c5b0:	01800704 	movi	r6,28
8111c5b4:	01400044 	movi	r5,1
8111c5b8:	01204574 	movhi	r4,33045
8111c5bc:	213ea804 	addi	r4,r4,-1376
8111c5c0:	1121c7c0 	call	81121c7c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c5c4:	0001883a 	nop
8111c5c8:	e037883a 	mov	sp,fp
8111c5cc:	dfc00117 	ldw	ra,4(sp)
8111c5d0:	df000017 	ldw	fp,0(sp)
8111c5d4:	dec00204 	addi	sp,sp,8
8111c5d8:	f800283a 	ret

8111c5dc <vFailCreateTimerRetransmisison>:


void vFailCreateTimerRetransmisison( void )
{
8111c5dc:	defffe04 	addi	sp,sp,-8
8111c5e0:	de00012e 	bgeu	sp,et,8111c5e8 <vFailCreateTimerRetransmisison+0xc>
8111c5e4:	003b68fa 	trap	3
8111c5e8:	dfc00115 	stw	ra,4(sp)
8111c5ec:	df000015 	stw	fp,0(sp)
8111c5f0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateTimerRetransmisison\n");
8111c5f4:	d0a06217 	ldw	r2,-32376(gp)
8111c5f8:	100f883a 	mov	r7,r2
8111c5fc:	018007c4 	movi	r6,31
8111c600:	01400044 	movi	r5,1
8111c604:	01204574 	movhi	r4,33045
8111c608:	213eb004 	addi	r4,r4,-1344
8111c60c:	1121c7c0 	call	81121c7c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c610:	0001883a 	nop
8111c614:	e037883a 	mov	sp,fp
8111c618:	dfc00117 	ldw	ra,4(sp)
8111c61c:	df000017 	ldw	fp,0(sp)
8111c620:	dec00204 	addi	sp,sp,8
8111c624:	f800283a 	ret

8111c628 <vCouldNotCheckBufferTimeOutFunction>:


void vCouldNotCheckBufferTimeOutFunction( void )
{
8111c628:	defffe04 	addi	sp,sp,-8
8111c62c:	de00012e 	bgeu	sp,et,8111c634 <vCouldNotCheckBufferTimeOutFunction+0xc>
8111c630:	003b68fa 	trap	3
8111c634:	dfc00115 	stw	ra,4(sp)
8111c638:	df000015 	stw	fp,0(sp)
8111c63c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotCheckBufferTimeOutFunction\n");
8111c640:	d0a06217 	ldw	r2,-32376(gp)
8111c644:	100f883a 	mov	r7,r2
8111c648:	01800904 	movi	r6,36
8111c64c:	01400044 	movi	r5,1
8111c650:	01204574 	movhi	r4,33045
8111c654:	213eb804 	addi	r4,r4,-1312
8111c658:	1121c7c0 	call	81121c7c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c65c:	0001883a 	nop
8111c660:	e037883a 	mov	sp,fp
8111c664:	dfc00117 	ldw	ra,4(sp)
8111c668:	df000017 	ldw	fp,0(sp)
8111c66c:	dec00204 	addi	sp,sp,8
8111c670:	f800283a 	ret

8111c674 <vFailTimeoutCheckerTaskCreate>:

/* Critico */
void vFailTimeoutCheckerTaskCreate( void )
{
8111c674:	defffe04 	addi	sp,sp,-8
8111c678:	de00012e 	bgeu	sp,et,8111c680 <vFailTimeoutCheckerTaskCreate+0xc>
8111c67c:	003b68fa 	trap	3
8111c680:	dfc00115 	stw	ra,4(sp)
8111c684:	df000015 	stw	fp,0(sp)
8111c688:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailTimeoutCheckerTaskCreate (Critico)\n");
8111c68c:	d0a06217 	ldw	r2,-32376(gp)
8111c690:	100f883a 	mov	r7,r2
8111c694:	01800a04 	movi	r6,40
8111c698:	01400044 	movi	r5,1
8111c69c:	01204574 	movhi	r4,33045
8111c6a0:	213ec204 	addi	r4,r4,-1272
8111c6a4:	1121c7c0 	call	81121c7c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c6a8:	0001883a 	nop
8111c6ac:	e037883a 	mov	sp,fp
8111c6b0:	dfc00117 	ldw	ra,4(sp)
8111c6b4:	df000017 	ldw	fp,0(sp)
8111c6b8:	dec00204 	addi	sp,sp,8
8111c6bc:	f800283a 	ret

8111c6c0 <vFailGetBlockingSemTimeoutTask>:


void vFailGetBlockingSemTimeoutTask( void )
{
8111c6c0:	defffe04 	addi	sp,sp,-8
8111c6c4:	de00012e 	bgeu	sp,et,8111c6cc <vFailGetBlockingSemTimeoutTask+0xc>
8111c6c8:	003b68fa 	trap	3
8111c6cc:	dfc00115 	stw	ra,4(sp)
8111c6d0:	df000015 	stw	fp,0(sp)
8111c6d4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetBlockingSemTimeoutTask. (exit)\n");
8111c6d8:	d0a06217 	ldw	r2,-32376(gp)
8111c6dc:	100f883a 	mov	r7,r2
8111c6e0:	018009c4 	movi	r6,39
8111c6e4:	01400044 	movi	r5,1
8111c6e8:	01204574 	movhi	r4,33045
8111c6ec:	213ecd04 	addi	r4,r4,-1228
8111c6f0:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Retrun from a blocking (0) OSSemPend with a error.\n");
8111c6f4:	d0a06217 	ldw	r2,-32376(gp)
8111c6f8:	100f883a 	mov	r7,r2
8111c6fc:	01800cc4 	movi	r6,51
8111c700:	01400044 	movi	r5,1
8111c704:	01204574 	movhi	r4,33045
8111c708:	213ed704 	addi	r4,r4,-1188
8111c70c:	1121c7c0 	call	81121c7c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c710:	0001883a 	nop
8111c714:	e037883a 	mov	sp,fp
8111c718:	dfc00117 	ldw	ra,4(sp)
8111c71c:	df000017 	ldw	fp,0(sp)
8111c720:	dec00204 	addi	sp,sp,8
8111c724:	f800283a 	ret

8111c728 <vFailPostBlockingSemTimeoutTask>:

void vFailPostBlockingSemTimeoutTask( void )
{
8111c728:	defffe04 	addi	sp,sp,-8
8111c72c:	de00012e 	bgeu	sp,et,8111c734 <vFailPostBlockingSemTimeoutTask+0xc>
8111c730:	003b68fa 	trap	3
8111c734:	dfc00115 	stw	ra,4(sp)
8111c738:	df000015 	stw	fp,0(sp)
8111c73c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailPostBlockingSemTimeoutTask. (exit)\n");
8111c740:	d0a06217 	ldw	r2,-32376(gp)
8111c744:	100f883a 	mov	r7,r2
8111c748:	01800a04 	movi	r6,40
8111c74c:	01400044 	movi	r5,1
8111c750:	01204574 	movhi	r4,33045
8111c754:	213ee404 	addi	r4,r4,-1136
8111c758:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not Post the semaphore for the TimeoutTask.\n");
8111c75c:	d0a06217 	ldw	r2,-32376(gp)
8111c760:	100f883a 	mov	r7,r2
8111c764:	01800c84 	movi	r6,50
8111c768:	01400044 	movi	r5,1
8111c76c:	01204574 	movhi	r4,33045
8111c770:	213eef04 	addi	r4,r4,-1092
8111c774:	1121c7c0 	call	81121c7c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c778:	0001883a 	nop
8111c77c:	e037883a 	mov	sp,fp
8111c780:	dfc00117 	ldw	ra,4(sp)
8111c784:	df000017 	ldw	fp,0(sp)
8111c788:	dec00204 	addi	sp,sp,8
8111c78c:	f800283a 	ret

8111c790 <vFailCouldNotRetransmitTimeoutTask>:


void vFailCouldNotRetransmitTimeoutTask( void )
{
8111c790:	defffe04 	addi	sp,sp,-8
8111c794:	de00012e 	bgeu	sp,et,8111c79c <vFailCouldNotRetransmitTimeoutTask+0xc>
8111c798:	003b68fa 	trap	3
8111c79c:	dfc00115 	stw	ra,4(sp)
8111c7a0:	df000015 	stw	fp,0(sp)
8111c7a4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCouldNotRetransmitTimeoutTask. (exit)\n");
8111c7a8:	d0a06217 	ldw	r2,-32376(gp)
8111c7ac:	100f883a 	mov	r7,r2
8111c7b0:	01800ac4 	movi	r6,43
8111c7b4:	01400044 	movi	r5,1
8111c7b8:	01204574 	movhi	r4,33045
8111c7bc:	213efc04 	addi	r4,r4,-1040
8111c7c0:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"After sleep for 50 ticks, could not get access to the tx uart. No retransmission occurs.\n");
8111c7c4:	d0a06217 	ldw	r2,-32376(gp)
8111c7c8:	100f883a 	mov	r7,r2
8111c7cc:	01801644 	movi	r6,89
8111c7d0:	01400044 	movi	r5,1
8111c7d4:	01204574 	movhi	r4,33045
8111c7d8:	213f0704 	addi	r4,r4,-996
8111c7dc:	1121c7c0 	call	81121c7c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c7e0:	0001883a 	nop
8111c7e4:	e037883a 	mov	sp,fp
8111c7e8:	dfc00117 	ldw	ra,4(sp)
8111c7ec:	df000017 	ldw	fp,0(sp)
8111c7f0:	dec00204 	addi	sp,sp,8
8111c7f4:	f800283a 	ret

8111c7f8 <vCouldNotRetransmitB32TimeoutTask>:


void vCouldNotRetransmitB32TimeoutTask( void )
{
8111c7f8:	defffe04 	addi	sp,sp,-8
8111c7fc:	de00012e 	bgeu	sp,et,8111c804 <vCouldNotRetransmitB32TimeoutTask+0xc>
8111c800:	003b68fa 	trap	3
8111c804:	dfc00115 	stw	ra,4(sp)
8111c808:	df000015 	stw	fp,0(sp)
8111c80c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB32TimeoutTask. (exit)\n");
8111c810:	d0a06217 	ldw	r2,-32376(gp)
8111c814:	100f883a 	mov	r7,r2
8111c818:	01800a84 	movi	r6,42
8111c81c:	01400044 	movi	r5,1
8111c820:	01204574 	movhi	r4,33045
8111c824:	213f1e04 	addi	r4,r4,-904
8111c828:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (32).\n");
8111c82c:	d0a06217 	ldw	r2,-32376(gp)
8111c830:	100f883a 	mov	r7,r2
8111c834:	01801444 	movi	r6,81
8111c838:	01400044 	movi	r5,1
8111c83c:	01204574 	movhi	r4,33045
8111c840:	213f2904 	addi	r4,r4,-860
8111c844:	1121c7c0 	call	81121c7c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c848:	0001883a 	nop
8111c84c:	e037883a 	mov	sp,fp
8111c850:	dfc00117 	ldw	ra,4(sp)
8111c854:	df000017 	ldw	fp,0(sp)
8111c858:	dec00204 	addi	sp,sp,8
8111c85c:	f800283a 	ret

8111c860 <vCouldNotRetransmitB64TimeoutTask>:

void vCouldNotRetransmitB64TimeoutTask( void )
{
8111c860:	defffe04 	addi	sp,sp,-8
8111c864:	de00012e 	bgeu	sp,et,8111c86c <vCouldNotRetransmitB64TimeoutTask+0xc>
8111c868:	003b68fa 	trap	3
8111c86c:	dfc00115 	stw	ra,4(sp)
8111c870:	df000015 	stw	fp,0(sp)
8111c874:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB64TimeoutTask. (exit)\n");
8111c878:	d0a06217 	ldw	r2,-32376(gp)
8111c87c:	100f883a 	mov	r7,r2
8111c880:	01800a84 	movi	r6,42
8111c884:	01400044 	movi	r5,1
8111c888:	01204574 	movhi	r4,33045
8111c88c:	213f3e04 	addi	r4,r4,-776
8111c890:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (64).\n");
8111c894:	d0a06217 	ldw	r2,-32376(gp)
8111c898:	100f883a 	mov	r7,r2
8111c89c:	01801444 	movi	r6,81
8111c8a0:	01400044 	movi	r5,1
8111c8a4:	01204574 	movhi	r4,33045
8111c8a8:	213f4904 	addi	r4,r4,-732
8111c8ac:	1121c7c0 	call	81121c7c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c8b0:	0001883a 	nop
8111c8b4:	e037883a 	mov	sp,fp
8111c8b8:	dfc00117 	ldw	ra,4(sp)
8111c8bc:	df000017 	ldw	fp,0(sp)
8111c8c0:	dec00204 	addi	sp,sp,8
8111c8c4:	f800283a 	ret

8111c8c8 <vCouldNotRetransmitB128TimeoutTask>:

void vCouldNotRetransmitB128TimeoutTask( void )
{
8111c8c8:	defffe04 	addi	sp,sp,-8
8111c8cc:	de00012e 	bgeu	sp,et,8111c8d4 <vCouldNotRetransmitB128TimeoutTask+0xc>
8111c8d0:	003b68fa 	trap	3
8111c8d4:	dfc00115 	stw	ra,4(sp)
8111c8d8:	df000015 	stw	fp,0(sp)
8111c8dc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB128TimeoutTask. (exit)\n");
8111c8e0:	d0a06217 	ldw	r2,-32376(gp)
8111c8e4:	100f883a 	mov	r7,r2
8111c8e8:	01800ac4 	movi	r6,43
8111c8ec:	01400044 	movi	r5,1
8111c8f0:	01204574 	movhi	r4,33045
8111c8f4:	213f5e04 	addi	r4,r4,-648
8111c8f8:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (128).\n");
8111c8fc:	d0a06217 	ldw	r2,-32376(gp)
8111c900:	100f883a 	mov	r7,r2
8111c904:	01801484 	movi	r6,82
8111c908:	01400044 	movi	r5,1
8111c90c:	01204574 	movhi	r4,33045
8111c910:	213f6904 	addi	r4,r4,-604
8111c914:	1121c7c0 	call	81121c7c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c918:	0001883a 	nop
8111c91c:	e037883a 	mov	sp,fp
8111c920:	dfc00117 	ldw	ra,4(sp)
8111c924:	df000017 	ldw	fp,0(sp)
8111c928:	dec00204 	addi	sp,sp,8
8111c92c:	f800283a 	ret

8111c930 <vFailStartTimerRetransmission>:


void vFailStartTimerRetransmission( void )
{
8111c930:	defffe04 	addi	sp,sp,-8
8111c934:	de00012e 	bgeu	sp,et,8111c93c <vFailStartTimerRetransmission+0xc>
8111c938:	003b68fa 	trap	3
8111c93c:	dfc00115 	stw	ra,4(sp)
8111c940:	df000015 	stw	fp,0(sp)
8111c944:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailStartTimerRetransmission. (exit)\n");
8111c948:	d0a06217 	ldw	r2,-32376(gp)
8111c94c:	100f883a 	mov	r7,r2
8111c950:	01800984 	movi	r6,38
8111c954:	01400044 	movi	r5,1
8111c958:	01204574 	movhi	r4,33045
8111c95c:	213f7e04 	addi	r4,r4,-520
8111c960:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Fail trying to start the timer xTimerRetransmission.\n");
8111c964:	d0a06217 	ldw	r2,-32376(gp)
8111c968:	100f883a 	mov	r7,r2
8111c96c:	01800d44 	movi	r6,53
8111c970:	01400044 	movi	r5,1
8111c974:	01204574 	movhi	r4,33045
8111c978:	213f8804 	addi	r4,r4,-480
8111c97c:	1121c7c0 	call	81121c7c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c980:	0001883a 	nop
8111c984:	e037883a 	mov	sp,fp
8111c988:	dfc00117 	ldw	ra,4(sp)
8111c98c:	df000017 	ldw	fp,0(sp)
8111c990:	dec00204 	addi	sp,sp,8
8111c994:	f800283a 	ret

8111c998 <vCouldNotSendTurnOff>:


void vCouldNotSendTurnOff( void )
{
8111c998:	defffe04 	addi	sp,sp,-8
8111c99c:	de00012e 	bgeu	sp,et,8111c9a4 <vCouldNotSendTurnOff+0xc>
8111c9a0:	003b68fa 	trap	3
8111c9a4:	dfc00115 	stw	ra,4(sp)
8111c9a8:	df000015 	stw	fp,0(sp)
8111c9ac:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendTurnOff. (exit)\n");
8111c9b0:	d0a06217 	ldw	r2,-32376(gp)
8111c9b4:	100f883a 	mov	r7,r2
8111c9b8:	01800744 	movi	r6,29
8111c9bc:	01400044 	movi	r5,1
8111c9c0:	01204574 	movhi	r4,33045
8111c9c4:	213f9604 	addi	r4,r4,-424
8111c9c8:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the turn off command. \n");
8111c9cc:	d0a06217 	ldw	r2,-32376(gp)
8111c9d0:	100f883a 	mov	r7,r2
8111c9d4:	01800984 	movi	r6,38
8111c9d8:	01400044 	movi	r5,1
8111c9dc:	01204574 	movhi	r4,33045
8111c9e0:	213f9e04 	addi	r4,r4,-392
8111c9e4:	1121c7c0 	call	81121c7c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c9e8:	0001883a 	nop
8111c9ec:	e037883a 	mov	sp,fp
8111c9f0:	dfc00117 	ldw	ra,4(sp)
8111c9f4:	df000017 	ldw	fp,0(sp)
8111c9f8:	dec00204 	addi	sp,sp,8
8111c9fc:	f800283a 	ret

8111ca00 <vCouldNotSendReset>:

void vCouldNotSendReset( void )
{
8111ca00:	defffe04 	addi	sp,sp,-8
8111ca04:	de00012e 	bgeu	sp,et,8111ca0c <vCouldNotSendReset+0xc>
8111ca08:	003b68fa 	trap	3
8111ca0c:	dfc00115 	stw	ra,4(sp)
8111ca10:	df000015 	stw	fp,0(sp)
8111ca14:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendReset. (exit)\n");
8111ca18:	d0a06217 	ldw	r2,-32376(gp)
8111ca1c:	100f883a 	mov	r7,r2
8111ca20:	018006c4 	movi	r6,27
8111ca24:	01400044 	movi	r5,1
8111ca28:	01204574 	movhi	r4,33045
8111ca2c:	213fa804 	addi	r4,r4,-352
8111ca30:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the reset command. \n");
8111ca34:	d0a06217 	ldw	r2,-32376(gp)
8111ca38:	100f883a 	mov	r7,r2
8111ca3c:	018008c4 	movi	r6,35
8111ca40:	01400044 	movi	r5,1
8111ca44:	01204574 	movhi	r4,33045
8111ca48:	213faf04 	addi	r4,r4,-324
8111ca4c:	1121c7c0 	call	81121c7c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ca50:	0001883a 	nop
8111ca54:	e037883a 	mov	sp,fp
8111ca58:	dfc00117 	ldw	ra,4(sp)
8111ca5c:	df000017 	ldw	fp,0(sp)
8111ca60:	dec00204 	addi	sp,sp,8
8111ca64:	f800283a 	ret

8111ca68 <vCouldNotSendLog>:

void vCouldNotSendLog( void )
{
8111ca68:	defffe04 	addi	sp,sp,-8
8111ca6c:	de00012e 	bgeu	sp,et,8111ca74 <vCouldNotSendLog+0xc>
8111ca70:	003b68fa 	trap	3
8111ca74:	dfc00115 	stw	ra,4(sp)
8111ca78:	df000015 	stw	fp,0(sp)
8111ca7c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendLog. (exit)\n");
8111ca80:	d0a06217 	ldw	r2,-32376(gp)
8111ca84:	100f883a 	mov	r7,r2
8111ca88:	01800644 	movi	r6,25
8111ca8c:	01400044 	movi	r5,1
8111ca90:	01204574 	movhi	r4,33045
8111ca94:	213fb804 	addi	r4,r4,-288
8111ca98:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send log packet to NUC. \n");
8111ca9c:	d0a06217 	ldw	r2,-32376(gp)
8111caa0:	100f883a 	mov	r7,r2
8111caa4:	018008c4 	movi	r6,35
8111caa8:	01400044 	movi	r5,1
8111caac:	01204574 	movhi	r4,33045
8111cab0:	213fbf04 	addi	r4,r4,-260
8111cab4:	1121c7c0 	call	81121c7c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cab8:	0001883a 	nop
8111cabc:	e037883a 	mov	sp,fp
8111cac0:	dfc00117 	ldw	ra,4(sp)
8111cac4:	df000017 	ldw	fp,0(sp)
8111cac8:	dec00204 	addi	sp,sp,8
8111cacc:	f800283a 	ret

8111cad0 <vCouldNotSendTMPusCommand>:


void vCouldNotSendTMPusCommand( const char *cData )
{
8111cad0:	defffd04 	addi	sp,sp,-12
8111cad4:	de00012e 	bgeu	sp,et,8111cadc <vCouldNotSendTMPusCommand+0xc>
8111cad8:	003b68fa 	trap	3
8111cadc:	dfc00215 	stw	ra,8(sp)
8111cae0:	df000115 	stw	fp,4(sp)
8111cae4:	df000104 	addi	fp,sp,4
8111cae8:	e13fff15 	stw	r4,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendTMPusCommand. (exit)\n");
8111caec:	d0a06217 	ldw	r2,-32376(gp)
8111caf0:	100f883a 	mov	r7,r2
8111caf4:	01800884 	movi	r6,34
8111caf8:	01400044 	movi	r5,1
8111cafc:	01204574 	movhi	r4,33045
8111cb00:	213fc804 	addi	r4,r4,-224
8111cb04:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the TM PUS command to NUC. \n");
8111cb08:	d0a06217 	ldw	r2,-32376(gp)
8111cb0c:	100f883a 	mov	r7,r2
8111cb10:	01800ac4 	movi	r6,43
8111cb14:	01400044 	movi	r5,1
8111cb18:	01204574 	movhi	r4,33045
8111cb1c:	213fd104 	addi	r4,r4,-188
8111cb20:	1121c7c0 	call	81121c7c <fwrite>
		debug(fp,"cData");
8111cb24:	d0a06217 	ldw	r2,-32376(gp)
8111cb28:	100f883a 	mov	r7,r2
8111cb2c:	01800144 	movi	r6,5
8111cb30:	01400044 	movi	r5,1
8111cb34:	01204574 	movhi	r4,33045
8111cb38:	213fdc04 	addi	r4,r4,-144
8111cb3c:	1121c7c0 	call	81121c7c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cb40:	0001883a 	nop
8111cb44:	e037883a 	mov	sp,fp
8111cb48:	dfc00117 	ldw	ra,4(sp)
8111cb4c:	df000017 	ldw	fp,0(sp)
8111cb50:	dec00204 	addi	sp,sp,8
8111cb54:	f800283a 	ret

8111cb58 <vWarnCouldNotgetMutexRetrans128>:

/* Not send message is bad but the Simucam will continue to work. */
void vWarnCouldNotgetMutexRetrans128( void )
{
8111cb58:	defffe04 	addi	sp,sp,-8
8111cb5c:	de00012e 	bgeu	sp,et,8111cb64 <vWarnCouldNotgetMutexRetrans128+0xc>
8111cb60:	003b68fa 	trap	3
8111cb64:	dfc00115 	stw	ra,4(sp)
8111cb68:	df000015 	stw	fp,0(sp)
8111cb6c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vWarnCouldNotgetMutexRetrans128. (exit)\n");
8111cb70:	d0a06217 	ldw	r2,-32376(gp)
8111cb74:	100f883a 	mov	r7,r2
8111cb78:	01800a04 	movi	r6,40
8111cb7c:	01400044 	movi	r5,1
8111cb80:	01204574 	movhi	r4,33045
8111cb84:	213fde04 	addi	r4,r4,-136
8111cb88:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Warning: Could not get the mutex for the retransmission. The message will be lost.\n");
8111cb8c:	d0a06217 	ldw	r2,-32376(gp)
8111cb90:	100f883a 	mov	r7,r2
8111cb94:	018014c4 	movi	r6,83
8111cb98:	01400044 	movi	r5,1
8111cb9c:	01204574 	movhi	r4,33045
8111cba0:	213fe904 	addi	r4,r4,-92
8111cba4:	1121c7c0 	call	81121c7c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cba8:	0001883a 	nop
8111cbac:	e037883a 	mov	sp,fp
8111cbb0:	dfc00117 	ldw	ra,4(sp)
8111cbb4:	df000017 	ldw	fp,0(sp)
8111cbb8:	dec00204 	addi	sp,sp,8
8111cbbc:	f800283a 	ret

8111cbc0 <vFailCreateScheduleQueue>:


/* CRITICAL. */
void vFailCreateScheduleQueue( void )
{
8111cbc0:	defffe04 	addi	sp,sp,-8
8111cbc4:	de00012e 	bgeu	sp,et,8111cbcc <vFailCreateScheduleQueue+0xc>
8111cbc8:	003b68fa 	trap	3
8111cbcc:	dfc00115 	stw	ra,4(sp)
8111cbd0:	df000015 	stw	fp,0(sp)
8111cbd4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateScheduleQueue. (exit)\n");
8111cbd8:	d0a06217 	ldw	r2,-32376(gp)
8111cbdc:	100f883a 	mov	r7,r2
8111cbe0:	01800844 	movi	r6,33
8111cbe4:	01400044 	movi	r5,1
8111cbe8:	01204574 	movhi	r4,33045
8111cbec:	213ffe04 	addi	r4,r4,-8
8111cbf0:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: Could not create the Queue to shcedule the access to the DMA.\n");
8111cbf4:	d0a06217 	ldw	r2,-32376(gp)
8111cbf8:	100f883a 	mov	r7,r2
8111cbfc:	01801204 	movi	r6,72
8111cc00:	01400044 	movi	r5,1
8111cc04:	01204574 	movhi	r4,33045
8111cc08:	21000704 	addi	r4,r4,28
8111cc0c:	1121c7c0 	call	81121c7c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cc10:	0001883a 	nop
8111cc14:	e037883a 	mov	sp,fp
8111cc18:	dfc00117 	ldw	ra,4(sp)
8111cc1c:	df000017 	ldw	fp,0(sp)
8111cc20:	dec00204 	addi	sp,sp,8
8111cc24:	f800283a 	ret

8111cc28 <vFailCreateNFEEQueue>:

/* CRITICAL. */
void vFailCreateNFEEQueue( unsigned char ucID )
{
8111cc28:	defffd04 	addi	sp,sp,-12
8111cc2c:	de00012e 	bgeu	sp,et,8111cc34 <vFailCreateNFEEQueue+0xc>
8111cc30:	003b68fa 	trap	3
8111cc34:	dfc00215 	stw	ra,8(sp)
8111cc38:	df000115 	stw	fp,4(sp)
8111cc3c:	df000104 	addi	fp,sp,4
8111cc40:	2005883a 	mov	r2,r4
8111cc44:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateNFEEQueue. (exit)\n");
8111cc48:	d0a06217 	ldw	r2,-32376(gp)
8111cc4c:	100f883a 	mov	r7,r2
8111cc50:	01800744 	movi	r6,29
8111cc54:	01400044 	movi	r5,1
8111cc58:	01204574 	movhi	r4,33045
8111cc5c:	21001a04 	addi	r4,r4,104
8111cc60:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		fprintf(fp,"CRITICAL: Could not create the Queue to the NSEE %hhu.\n",ucID);
8111cc64:	d0a06217 	ldw	r2,-32376(gp)
8111cc68:	e0ffff03 	ldbu	r3,-4(fp)
8111cc6c:	180d883a 	mov	r6,r3
8111cc70:	01604574 	movhi	r5,33045
8111cc74:	29402204 	addi	r5,r5,136
8111cc78:	1009883a 	mov	r4,r2
8111cc7c:	11215e00 	call	811215e0 <fprintf>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cc80:	0001883a 	nop
8111cc84:	e037883a 	mov	sp,fp
8111cc88:	dfc00117 	ldw	ra,4(sp)
8111cc8c:	df000017 	ldw	fp,0(sp)
8111cc90:	dec00204 	addi	sp,sp,8
8111cc94:	f800283a 	ret

8111cc98 <vFailCreateNFEESyncQueue>:

/* CRITICAL. */
void vFailCreateNFEESyncQueue( unsigned char ucID )
{
8111cc98:	defffd04 	addi	sp,sp,-12
8111cc9c:	de00012e 	bgeu	sp,et,8111cca4 <vFailCreateNFEESyncQueue+0xc>
8111cca0:	003b68fa 	trap	3
8111cca4:	dfc00215 	stw	ra,8(sp)
8111cca8:	df000115 	stw	fp,4(sp)
8111ccac:	df000104 	addi	fp,sp,4
8111ccb0:	2005883a 	mov	r2,r4
8111ccb4:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateNFEESyncQueue. (exit)\n");
8111ccb8:	d0a06217 	ldw	r2,-32376(gp)
8111ccbc:	100f883a 	mov	r7,r2
8111ccc0:	01800844 	movi	r6,33
8111ccc4:	01400044 	movi	r5,1
8111ccc8:	01204574 	movhi	r4,33045
8111cccc:	21003004 	addi	r4,r4,192
8111ccd0:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		fprintf(fp,"CRITICAL: Could not create the Queue to the NFEE %hhu.\n",ucID);
8111ccd4:	d0a06217 	ldw	r2,-32376(gp)
8111ccd8:	e0ffff03 	ldbu	r3,-4(fp)
8111ccdc:	180d883a 	mov	r6,r3
8111cce0:	01604574 	movhi	r5,33045
8111cce4:	29403904 	addi	r5,r5,228
8111cce8:	1009883a 	mov	r4,r2
8111ccec:	11215e00 	call	811215e0 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ccf0:	0001883a 	nop
8111ccf4:	e037883a 	mov	sp,fp
8111ccf8:	dfc00117 	ldw	ra,4(sp)
8111ccfc:	df000017 	ldw	fp,0(sp)
8111cd00:	dec00204 	addi	sp,sp,8
8111cd04:	f800283a 	ret

8111cd08 <vCoudlNotCreateNFee0Task>:

void vCoudlNotCreateNFee0Task( void )
{
8111cd08:	defffe04 	addi	sp,sp,-8
8111cd0c:	de00012e 	bgeu	sp,et,8111cd14 <vCoudlNotCreateNFee0Task+0xc>
8111cd10:	003b68fa 	trap	3
8111cd14:	dfc00115 	stw	ra,4(sp)
8111cd18:	df000015 	stw	fp,0(sp)
8111cd1c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee0Task. (exit)\n");
8111cd20:	d0a06217 	ldw	r2,-32376(gp)
8111cd24:	100f883a 	mov	r7,r2
8111cd28:	01800844 	movi	r6,33
8111cd2c:	01400044 	movi	r5,1
8111cd30:	01204574 	movhi	r4,33045
8111cd34:	21004704 	addi	r4,r4,284
8111cd38:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 0 Task.\n");
8111cd3c:	d0a06217 	ldw	r2,-32376(gp)
8111cd40:	100f883a 	mov	r7,r2
8111cd44:	01800784 	movi	r6,30
8111cd48:	01400044 	movi	r5,1
8111cd4c:	01204574 	movhi	r4,33045
8111cd50:	21005004 	addi	r4,r4,320
8111cd54:	1121c7c0 	call	81121c7c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cd58:	0001883a 	nop
8111cd5c:	e037883a 	mov	sp,fp
8111cd60:	dfc00117 	ldw	ra,4(sp)
8111cd64:	df000017 	ldw	fp,0(sp)
8111cd68:	dec00204 	addi	sp,sp,8
8111cd6c:	f800283a 	ret

8111cd70 <vCoudlNotCreateNFee1Task>:


void vCoudlNotCreateNFee1Task( void )
{
8111cd70:	defffe04 	addi	sp,sp,-8
8111cd74:	de00012e 	bgeu	sp,et,8111cd7c <vCoudlNotCreateNFee1Task+0xc>
8111cd78:	003b68fa 	trap	3
8111cd7c:	dfc00115 	stw	ra,4(sp)
8111cd80:	df000015 	stw	fp,0(sp)
8111cd84:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee1Task. (exit)\n");
8111cd88:	d0a06217 	ldw	r2,-32376(gp)
8111cd8c:	100f883a 	mov	r7,r2
8111cd90:	01800844 	movi	r6,33
8111cd94:	01400044 	movi	r5,1
8111cd98:	01204574 	movhi	r4,33045
8111cd9c:	21005804 	addi	r4,r4,352
8111cda0:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 1 Task.\n");
8111cda4:	d0a06217 	ldw	r2,-32376(gp)
8111cda8:	100f883a 	mov	r7,r2
8111cdac:	01800784 	movi	r6,30
8111cdb0:	01400044 	movi	r5,1
8111cdb4:	01204574 	movhi	r4,33045
8111cdb8:	21006104 	addi	r4,r4,388
8111cdbc:	1121c7c0 	call	81121c7c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cdc0:	0001883a 	nop
8111cdc4:	e037883a 	mov	sp,fp
8111cdc8:	dfc00117 	ldw	ra,4(sp)
8111cdcc:	df000017 	ldw	fp,0(sp)
8111cdd0:	dec00204 	addi	sp,sp,8
8111cdd4:	f800283a 	ret

8111cdd8 <vCoudlNotCreateNFee2Task>:

void vCoudlNotCreateNFee2Task( void )
{
8111cdd8:	defffe04 	addi	sp,sp,-8
8111cddc:	de00012e 	bgeu	sp,et,8111cde4 <vCoudlNotCreateNFee2Task+0xc>
8111cde0:	003b68fa 	trap	3
8111cde4:	dfc00115 	stw	ra,4(sp)
8111cde8:	df000015 	stw	fp,0(sp)
8111cdec:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee2Task. (exit)\n");
8111cdf0:	d0a06217 	ldw	r2,-32376(gp)
8111cdf4:	100f883a 	mov	r7,r2
8111cdf8:	01800844 	movi	r6,33
8111cdfc:	01400044 	movi	r5,1
8111ce00:	01204574 	movhi	r4,33045
8111ce04:	21006904 	addi	r4,r4,420
8111ce08:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 2 Task.\n");
8111ce0c:	d0a06217 	ldw	r2,-32376(gp)
8111ce10:	100f883a 	mov	r7,r2
8111ce14:	01800784 	movi	r6,30
8111ce18:	01400044 	movi	r5,1
8111ce1c:	01204574 	movhi	r4,33045
8111ce20:	21007204 	addi	r4,r4,456
8111ce24:	1121c7c0 	call	81121c7c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ce28:	0001883a 	nop
8111ce2c:	e037883a 	mov	sp,fp
8111ce30:	dfc00117 	ldw	ra,4(sp)
8111ce34:	df000017 	ldw	fp,0(sp)
8111ce38:	dec00204 	addi	sp,sp,8
8111ce3c:	f800283a 	ret

8111ce40 <vCoudlNotCreateNFee3Task>:

void vCoudlNotCreateNFee3Task( void )
{
8111ce40:	defffe04 	addi	sp,sp,-8
8111ce44:	de00012e 	bgeu	sp,et,8111ce4c <vCoudlNotCreateNFee3Task+0xc>
8111ce48:	003b68fa 	trap	3
8111ce4c:	dfc00115 	stw	ra,4(sp)
8111ce50:	df000015 	stw	fp,0(sp)
8111ce54:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee3Task. (exit)\n");
8111ce58:	d0a06217 	ldw	r2,-32376(gp)
8111ce5c:	100f883a 	mov	r7,r2
8111ce60:	01800844 	movi	r6,33
8111ce64:	01400044 	movi	r5,1
8111ce68:	01204574 	movhi	r4,33045
8111ce6c:	21007a04 	addi	r4,r4,488
8111ce70:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 3 Task.\n");
8111ce74:	d0a06217 	ldw	r2,-32376(gp)
8111ce78:	100f883a 	mov	r7,r2
8111ce7c:	01800784 	movi	r6,30
8111ce80:	01400044 	movi	r5,1
8111ce84:	01204574 	movhi	r4,33045
8111ce88:	21008304 	addi	r4,r4,524
8111ce8c:	1121c7c0 	call	81121c7c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ce90:	0001883a 	nop
8111ce94:	e037883a 	mov	sp,fp
8111ce98:	dfc00117 	ldw	ra,4(sp)
8111ce9c:	df000017 	ldw	fp,0(sp)
8111cea0:	dec00204 	addi	sp,sp,8
8111cea4:	f800283a 	ret

8111cea8 <vCoudlNotCreateNFee4Task>:

void vCoudlNotCreateNFee4Task( void )
{
8111cea8:	defffe04 	addi	sp,sp,-8
8111ceac:	de00012e 	bgeu	sp,et,8111ceb4 <vCoudlNotCreateNFee4Task+0xc>
8111ceb0:	003b68fa 	trap	3
8111ceb4:	dfc00115 	stw	ra,4(sp)
8111ceb8:	df000015 	stw	fp,0(sp)
8111cebc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee4Task. (exit)\n");
8111cec0:	d0a06217 	ldw	r2,-32376(gp)
8111cec4:	100f883a 	mov	r7,r2
8111cec8:	01800844 	movi	r6,33
8111cecc:	01400044 	movi	r5,1
8111ced0:	01204574 	movhi	r4,33045
8111ced4:	21008b04 	addi	r4,r4,556
8111ced8:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 4 Task.\n");
8111cedc:	d0a06217 	ldw	r2,-32376(gp)
8111cee0:	100f883a 	mov	r7,r2
8111cee4:	01800784 	movi	r6,30
8111cee8:	01400044 	movi	r5,1
8111ceec:	01204574 	movhi	r4,33045
8111cef0:	21009404 	addi	r4,r4,592
8111cef4:	1121c7c0 	call	81121c7c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cef8:	0001883a 	nop
8111cefc:	e037883a 	mov	sp,fp
8111cf00:	dfc00117 	ldw	ra,4(sp)
8111cf04:	df000017 	ldw	fp,0(sp)
8111cf08:	dec00204 	addi	sp,sp,8
8111cf0c:	f800283a 	ret

8111cf10 <vCoudlNotCreateNFee5Task>:

void vCoudlNotCreateNFee5Task( void )
{
8111cf10:	defffe04 	addi	sp,sp,-8
8111cf14:	de00012e 	bgeu	sp,et,8111cf1c <vCoudlNotCreateNFee5Task+0xc>
8111cf18:	003b68fa 	trap	3
8111cf1c:	dfc00115 	stw	ra,4(sp)
8111cf20:	df000015 	stw	fp,0(sp)
8111cf24:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee5Task. (exit)\n");
8111cf28:	d0a06217 	ldw	r2,-32376(gp)
8111cf2c:	100f883a 	mov	r7,r2
8111cf30:	01800844 	movi	r6,33
8111cf34:	01400044 	movi	r5,1
8111cf38:	01204574 	movhi	r4,33045
8111cf3c:	21009c04 	addi	r4,r4,624
8111cf40:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 5 Task.\n");
8111cf44:	d0a06217 	ldw	r2,-32376(gp)
8111cf48:	100f883a 	mov	r7,r2
8111cf4c:	01800784 	movi	r6,30
8111cf50:	01400044 	movi	r5,1
8111cf54:	01204574 	movhi	r4,33045
8111cf58:	2100a504 	addi	r4,r4,660
8111cf5c:	1121c7c0 	call	81121c7c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cf60:	0001883a 	nop
8111cf64:	e037883a 	mov	sp,fp
8111cf68:	dfc00117 	ldw	ra,4(sp)
8111cf6c:	df000017 	ldw	fp,0(sp)
8111cf70:	dec00204 	addi	sp,sp,8
8111cf74:	f800283a 	ret

8111cf78 <vCoudlNotCreateNFeeControllerTask>:


void vCoudlNotCreateNFeeControllerTask( void )
{
8111cf78:	defffe04 	addi	sp,sp,-8
8111cf7c:	de00012e 	bgeu	sp,et,8111cf84 <vCoudlNotCreateNFeeControllerTask+0xc>
8111cf80:	003b68fa 	trap	3
8111cf84:	dfc00115 	stw	ra,4(sp)
8111cf88:	df000015 	stw	fp,0(sp)
8111cf8c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFeeControllerTask. (exit)\n");
8111cf90:	d0a06217 	ldw	r2,-32376(gp)
8111cf94:	100f883a 	mov	r7,r2
8111cf98:	01800a84 	movi	r6,42
8111cf9c:	01400044 	movi	r5,1
8111cfa0:	01204574 	movhi	r4,33045
8111cfa4:	2100ad04 	addi	r4,r4,692
8111cfa8:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE Controller Task.\n");
8111cfac:	d0a06217 	ldw	r2,-32376(gp)
8111cfb0:	100f883a 	mov	r7,r2
8111cfb4:	018009c4 	movi	r6,39
8111cfb8:	01400044 	movi	r5,1
8111cfbc:	01204574 	movhi	r4,33045
8111cfc0:	2100b804 	addi	r4,r4,736
8111cfc4:	1121c7c0 	call	81121c7c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cfc8:	0001883a 	nop
8111cfcc:	e037883a 	mov	sp,fp
8111cfd0:	dfc00117 	ldw	ra,4(sp)
8111cfd4:	df000017 	ldw	fp,0(sp)
8111cfd8:	dec00204 	addi	sp,sp,8
8111cfdc:	f800283a 	ret

8111cfe0 <vCoudlNotCreateDataControllerTask>:


void vCoudlNotCreateDataControllerTask( void )
{
8111cfe0:	defffe04 	addi	sp,sp,-8
8111cfe4:	de00012e 	bgeu	sp,et,8111cfec <vCoudlNotCreateDataControllerTask+0xc>
8111cfe8:	003b68fa 	trap	3
8111cfec:	dfc00115 	stw	ra,4(sp)
8111cff0:	df000015 	stw	fp,0(sp)
8111cff4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateDataControllerTask. (exit)\n");
8111cff8:	d0a06217 	ldw	r2,-32376(gp)
8111cffc:	100f883a 	mov	r7,r2
8111d000:	01800a84 	movi	r6,42
8111d004:	01400044 	movi	r5,1
8111d008:	01204574 	movhi	r4,33045
8111d00c:	2100c204 	addi	r4,r4,776
8111d010:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create Data Controller Task.\n");
8111d014:	d0a06217 	ldw	r2,-32376(gp)
8111d018:	100f883a 	mov	r7,r2
8111d01c:	018009c4 	movi	r6,39
8111d020:	01400044 	movi	r5,1
8111d024:	01204574 	movhi	r4,33045
8111d028:	2100cd04 	addi	r4,r4,820
8111d02c:	1121c7c0 	call	81121c7c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d030:	0001883a 	nop
8111d034:	e037883a 	mov	sp,fp
8111d038:	dfc00117 	ldw	ra,4(sp)
8111d03c:	df000017 	ldw	fp,0(sp)
8111d040:	dec00204 	addi	sp,sp,8
8111d044:	f800283a 	ret

8111d048 <vCoudlNotCreateMebTask>:


void vCoudlNotCreateMebTask( void )
{
8111d048:	defffe04 	addi	sp,sp,-8
8111d04c:	de00012e 	bgeu	sp,et,8111d054 <vCoudlNotCreateMebTask+0xc>
8111d050:	003b68fa 	trap	3
8111d054:	dfc00115 	stw	ra,4(sp)
8111d058:	df000015 	stw	fp,0(sp)
8111d05c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateMebTask. (exit)\n");
8111d060:	d0a06217 	ldw	r2,-32376(gp)
8111d064:	100f883a 	mov	r7,r2
8111d068:	018007c4 	movi	r6,31
8111d06c:	01400044 	movi	r5,1
8111d070:	01204574 	movhi	r4,33045
8111d074:	2100d704 	addi	r4,r4,860
8111d078:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create Meb Task.\n");
8111d07c:	d0a06217 	ldw	r2,-32376(gp)
8111d080:	100f883a 	mov	r7,r2
8111d084:	018006c4 	movi	r6,27
8111d088:	01400044 	movi	r5,1
8111d08c:	01204574 	movhi	r4,33045
8111d090:	2100df04 	addi	r4,r4,892
8111d094:	1121c7c0 	call	81121c7c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d098:	0001883a 	nop
8111d09c:	e037883a 	mov	sp,fp
8111d0a0:	dfc00117 	ldw	ra,4(sp)
8111d0a4:	df000017 	ldw	fp,0(sp)
8111d0a8:	dec00204 	addi	sp,sp,8
8111d0ac:	f800283a 	ret

8111d0b0 <vFailCreateMutexSPUSQueueMeb>:


void vFailCreateMutexSPUSQueueMeb( INT8U error_code )
{
8111d0b0:	defffd04 	addi	sp,sp,-12
8111d0b4:	de00012e 	bgeu	sp,et,8111d0bc <vFailCreateMutexSPUSQueueMeb+0xc>
8111d0b8:	003b68fa 	trap	3
8111d0bc:	dfc00215 	stw	ra,8(sp)
8111d0c0:	df000115 	stw	fp,4(sp)
8111d0c4:	df000104 	addi	fp,sp,4
8111d0c8:	2005883a 	mov	r2,r4
8111d0cc:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateMutexSPUSQueueMeb. (exit)\n");
8111d0d0:	d0a06217 	ldw	r2,-32376(gp)
8111d0d4:	100f883a 	mov	r7,r2
8111d0d8:	01800944 	movi	r6,37
8111d0dc:	01400044 	movi	r5,1
8111d0e0:	01204574 	movhi	r4,33045
8111d0e4:	2100e604 	addi	r4,r4,920
8111d0e8:	1121c7c0 	call	81121c7c <fwrite>
	#endif
	#ifdef DEBUG_ON
		printErrorTask(error_code);
8111d0ec:	e0bfff03 	ldbu	r2,-4(fp)
8111d0f0:	1009883a 	mov	r4,r2
8111d0f4:	111b85c0 	call	8111b85c <printErrorTask>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d0f8:	0001883a 	nop
8111d0fc:	e037883a 	mov	sp,fp
8111d100:	dfc00117 	ldw	ra,4(sp)
8111d104:	df000017 	ldw	fp,0(sp)
8111d108:	dec00204 	addi	sp,sp,8
8111d10c:	f800283a 	ret

8111d110 <vFailSendPUStoMebTask>:

void vFailSendPUStoMebTask( void )
{
8111d110:	defffe04 	addi	sp,sp,-8
8111d114:	de00012e 	bgeu	sp,et,8111d11c <vFailSendPUStoMebTask+0xc>
8111d118:	003b68fa 	trap	3
8111d11c:	dfc00115 	stw	ra,4(sp)
8111d120:	df000015 	stw	fp,0(sp)
8111d124:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPUStoMebTask. (exit)\n");
8111d128:	d0a06217 	ldw	r2,-32376(gp)
8111d12c:	100f883a 	mov	r7,r2
8111d130:	01800784 	movi	r6,30
8111d134:	01400044 	movi	r5,1
8111d138:	01204574 	movhi	r4,33045
8111d13c:	2100f004 	addi	r4,r4,960
8111d140:	1121c7c0 	call	81121c7c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d144:	0001883a 	nop
8111d148:	e037883a 	mov	sp,fp
8111d14c:	dfc00117 	ldw	ra,4(sp)
8111d150:	df000017 	ldw	fp,0(sp)
8111d154:	dec00204 	addi	sp,sp,8
8111d158:	f800283a 	ret

8111d15c <vCouldNotGetCmdQueueMeb>:

void vCouldNotGetCmdQueueMeb( void )
{
8111d15c:	defffe04 	addi	sp,sp,-8
8111d160:	de00012e 	bgeu	sp,et,8111d168 <vCouldNotGetCmdQueueMeb+0xc>
8111d164:	003b68fa 	trap	3
8111d168:	dfc00115 	stw	ra,4(sp)
8111d16c:	df000015 	stw	fp,0(sp)
8111d170:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vCouldNotGetCmdQueueMeb. (exit)\n");
8111d174:	d0a06217 	ldw	r2,-32376(gp)
8111d178:	100f883a 	mov	r7,r2
8111d17c:	01800a84 	movi	r6,42
8111d180:	01400044 	movi	r5,1
8111d184:	01204574 	movhi	r4,33045
8111d188:	2100f804 	addi	r4,r4,992
8111d18c:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get COmmand from Queue in the Meb Task. \n");
8111d190:	d0a06217 	ldw	r2,-32376(gp)
8111d194:	100f883a 	mov	r7,r2
8111d198:	01800cc4 	movi	r6,51
8111d19c:	01400044 	movi	r5,1
8111d1a0:	01204574 	movhi	r4,33045
8111d1a4:	21010304 	addi	r4,r4,1036
8111d1a8:	1121c7c0 	call	81121c7c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d1ac:	0001883a 	nop
8111d1b0:	e037883a 	mov	sp,fp
8111d1b4:	dfc00117 	ldw	ra,4(sp)
8111d1b8:	df000017 	ldw	fp,0(sp)
8111d1bc:	dec00204 	addi	sp,sp,8
8111d1c0:	f800283a 	ret

8111d1c4 <vCouldNotGetMutexMebPus>:


void vCouldNotGetMutexMebPus( void )
{
8111d1c4:	defffe04 	addi	sp,sp,-8
8111d1c8:	de00012e 	bgeu	sp,et,8111d1d0 <vCouldNotGetMutexMebPus+0xc>
8111d1cc:	003b68fa 	trap	3
8111d1d0:	dfc00115 	stw	ra,4(sp)
8111d1d4:	df000015 	stw	fp,0(sp)
8111d1d8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetMutexMebPus. (exit)\n");
8111d1dc:	d0a06217 	ldw	r2,-32376(gp)
8111d1e0:	100f883a 	mov	r7,r2
8111d1e4:	01800804 	movi	r6,32
8111d1e8:	01400044 	movi	r5,1
8111d1ec:	01204574 	movhi	r4,33045
8111d1f0:	21011004 	addi	r4,r4,1088
8111d1f4:	1121c7c0 	call	81121c7c <fwrite>
	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d1f8:	0001883a 	nop
8111d1fc:	e037883a 	mov	sp,fp
8111d200:	dfc00117 	ldw	ra,4(sp)
8111d204:	df000017 	ldw	fp,0(sp)
8111d208:	dec00204 	addi	sp,sp,8
8111d20c:	f800283a 	ret

8111d210 <vCouldNotCreateQueueMaskNfeeCtrl>:

void vCouldNotCreateQueueMaskNfeeCtrl( void )
{
8111d210:	defffe04 	addi	sp,sp,-8
8111d214:	de00012e 	bgeu	sp,et,8111d21c <vCouldNotCreateQueueMaskNfeeCtrl+0xc>
8111d218:	003b68fa 	trap	3
8111d21c:	dfc00115 	stw	ra,4(sp)
8111d220:	df000015 	stw	fp,0(sp)
8111d224:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotCreateQueueMaskNfeeCtrl. (exit)\n");
8111d228:	d0a06217 	ldw	r2,-32376(gp)
8111d22c:	100f883a 	mov	r7,r2
8111d230:	01800a44 	movi	r6,41
8111d234:	01400044 	movi	r5,1
8111d238:	01204574 	movhi	r4,33045
8111d23c:	21011904 	addi	r4,r4,1124
8111d240:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not Create Queue Mask for NFEE Controller. \n");
8111d244:	d0a06217 	ldw	r2,-32376(gp)
8111d248:	100f883a 	mov	r7,r2
8111d24c:	01800c84 	movi	r6,50
8111d250:	01400044 	movi	r5,1
8111d254:	01204574 	movhi	r4,33045
8111d258:	21012404 	addi	r4,r4,1168
8111d25c:	1121c7c0 	call	81121c7c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d260:	0001883a 	nop
8111d264:	e037883a 	mov	sp,fp
8111d268:	dfc00117 	ldw	ra,4(sp)
8111d26c:	df000017 	ldw	fp,0(sp)
8111d270:	dec00204 	addi	sp,sp,8
8111d274:	f800283a 	ret

8111d278 <vCouldNotCreateQueueMaskDataCtrl>:

void vCouldNotCreateQueueMaskDataCtrl( void )
{
8111d278:	defffe04 	addi	sp,sp,-8
8111d27c:	de00012e 	bgeu	sp,et,8111d284 <vCouldNotCreateQueueMaskDataCtrl+0xc>
8111d280:	003b68fa 	trap	3
8111d284:	dfc00115 	stw	ra,4(sp)
8111d288:	df000015 	stw	fp,0(sp)
8111d28c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotCreateQueueMaskDataCtrl. (exit)\n");
8111d290:	d0a06217 	ldw	r2,-32376(gp)
8111d294:	100f883a 	mov	r7,r2
8111d298:	01800a44 	movi	r6,41
8111d29c:	01400044 	movi	r5,1
8111d2a0:	01204574 	movhi	r4,33045
8111d2a4:	21013104 	addi	r4,r4,1220
8111d2a8:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not Create Queue Mask for Data Controller. \n");
8111d2ac:	d0a06217 	ldw	r2,-32376(gp)
8111d2b0:	100f883a 	mov	r7,r2
8111d2b4:	01800c84 	movi	r6,50
8111d2b8:	01400044 	movi	r5,1
8111d2bc:	01204574 	movhi	r4,33045
8111d2c0:	21013c04 	addi	r4,r4,1264
8111d2c4:	1121c7c0 	call	81121c7c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d2c8:	0001883a 	nop
8111d2cc:	e037883a 	mov	sp,fp
8111d2d0:	dfc00117 	ldw	ra,4(sp)
8111d2d4:	df000017 	ldw	fp,0(sp)
8111d2d8:	dec00204 	addi	sp,sp,8
8111d2dc:	f800283a 	ret

8111d2e0 <vCouldNotGetQueueMaskNfeeCtrl>:

void vCouldNotGetQueueMaskNfeeCtrl( void )
{
8111d2e0:	defffe04 	addi	sp,sp,-8
8111d2e4:	de00012e 	bgeu	sp,et,8111d2ec <vCouldNotGetQueueMaskNfeeCtrl+0xc>
8111d2e8:	003b68fa 	trap	3
8111d2ec:	dfc00115 	stw	ra,4(sp)
8111d2f0:	df000015 	stw	fp,0(sp)
8111d2f4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetQueueMaskNfeeCtrl. (exit)\n");
8111d2f8:	d0a06217 	ldw	r2,-32376(gp)
8111d2fc:	100f883a 	mov	r7,r2
8111d300:	01800984 	movi	r6,38
8111d304:	01400044 	movi	r5,1
8111d308:	01204574 	movhi	r4,33045
8111d30c:	21014904 	addi	r4,r4,1316
8111d310:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get Queue Mask for NFEE Controller. \n");
8111d314:	d0a06217 	ldw	r2,-32376(gp)
8111d318:	100f883a 	mov	r7,r2
8111d31c:	01800bc4 	movi	r6,47
8111d320:	01400044 	movi	r5,1
8111d324:	01204574 	movhi	r4,33045
8111d328:	21015304 	addi	r4,r4,1356
8111d32c:	1121c7c0 	call	81121c7c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d330:	0001883a 	nop
8111d334:	e037883a 	mov	sp,fp
8111d338:	dfc00117 	ldw	ra,4(sp)
8111d33c:	df000017 	ldw	fp,0(sp)
8111d340:	dec00204 	addi	sp,sp,8
8111d344:	f800283a 	ret

8111d348 <vCouldNotGetQueueMaskDataCtrl>:

void vCouldNotGetQueueMaskDataCtrl( void )
{
8111d348:	defffe04 	addi	sp,sp,-8
8111d34c:	de00012e 	bgeu	sp,et,8111d354 <vCouldNotGetQueueMaskDataCtrl+0xc>
8111d350:	003b68fa 	trap	3
8111d354:	dfc00115 	stw	ra,4(sp)
8111d358:	df000015 	stw	fp,0(sp)
8111d35c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetQueueMaskDataCtrl. (exit)\n");
8111d360:	d0a06217 	ldw	r2,-32376(gp)
8111d364:	100f883a 	mov	r7,r2
8111d368:	01800984 	movi	r6,38
8111d36c:	01400044 	movi	r5,1
8111d370:	01204574 	movhi	r4,33045
8111d374:	21015f04 	addi	r4,r4,1404
8111d378:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get Queue Mask for Data Controller. \n");
8111d37c:	d0a06217 	ldw	r2,-32376(gp)
8111d380:	100f883a 	mov	r7,r2
8111d384:	01800bc4 	movi	r6,47
8111d388:	01400044 	movi	r5,1
8111d38c:	01204574 	movhi	r4,33045
8111d390:	21016904 	addi	r4,r4,1444
8111d394:	1121c7c0 	call	81121c7c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d398:	0001883a 	nop
8111d39c:	e037883a 	mov	sp,fp
8111d3a0:	dfc00117 	ldw	ra,4(sp)
8111d3a4:	df000017 	ldw	fp,0(sp)
8111d3a8:	dec00204 	addi	sp,sp,8
8111d3ac:	f800283a 	ret

8111d3b0 <vFailSendMsgAccessDMA>:


void vFailSendMsgAccessDMA( unsigned char ucTemp)
{
8111d3b0:	defffd04 	addi	sp,sp,-12
8111d3b4:	de00012e 	bgeu	sp,et,8111d3bc <vFailSendMsgAccessDMA+0xc>
8111d3b8:	003b68fa 	trap	3
8111d3bc:	dfc00215 	stw	ra,8(sp)
8111d3c0:	df000115 	stw	fp,4(sp)
8111d3c4:	df000104 	addi	fp,sp,4
8111d3c8:	2005883a 	mov	r2,r4
8111d3cc:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendMsgAccessDMA. FEE n: \n", ucTemp);
8111d3d0:	d0a06217 	ldw	r2,-32376(gp)
8111d3d4:	e0ffff03 	ldbu	r3,-4(fp)
8111d3d8:	180d883a 	mov	r6,r3
8111d3dc:	01604574 	movhi	r5,33045
8111d3e0:	29417504 	addi	r5,r5,1492
8111d3e4:	1009883a 	mov	r4,r2
8111d3e8:	11215e00 	call	811215e0 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d3ec:	0001883a 	nop
8111d3f0:	e037883a 	mov	sp,fp
8111d3f4:	dfc00117 	ldw	ra,4(sp)
8111d3f8:	df000017 	ldw	fp,0(sp)
8111d3fc:	dec00204 	addi	sp,sp,8
8111d400:	f800283a 	ret

8111d404 <vFailRequestDMA>:

void vFailRequestDMA( unsigned char ucTemp)
{
8111d404:	defffd04 	addi	sp,sp,-12
8111d408:	de00012e 	bgeu	sp,et,8111d410 <vFailRequestDMA+0xc>
8111d40c:	003b68fa 	trap	3
8111d410:	dfc00215 	stw	ra,8(sp)
8111d414:	df000115 	stw	fp,4(sp)
8111d418:	df000104 	addi	fp,sp,4
8111d41c:	2005883a 	mov	r2,r4
8111d420:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailRequestDMA. FEE n: \n", ucTemp);
8111d424:	d0a06217 	ldw	r2,-32376(gp)
8111d428:	e0ffff03 	ldbu	r3,-4(fp)
8111d42c:	180d883a 	mov	r6,r3
8111d430:	01604574 	movhi	r5,33045
8111d434:	29417d04 	addi	r5,r5,1524
8111d438:	1009883a 	mov	r4,r2
8111d43c:	11215e00 	call	811215e0 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d440:	0001883a 	nop
8111d444:	e037883a 	mov	sp,fp
8111d448:	dfc00117 	ldw	ra,4(sp)
8111d44c:	df000017 	ldw	fp,0(sp)
8111d450:	dec00204 	addi	sp,sp,8
8111d454:	f800283a 	ret

8111d458 <vFailRequestDMAFromIRQ>:

void vFailRequestDMAFromIRQ( unsigned char ucTemp)
{
8111d458:	defffd04 	addi	sp,sp,-12
8111d45c:	de00012e 	bgeu	sp,et,8111d464 <vFailRequestDMAFromIRQ+0xc>
8111d460:	003b68fa 	trap	3
8111d464:	dfc00215 	stw	ra,8(sp)
8111d468:	df000115 	stw	fp,4(sp)
8111d46c:	df000104 	addi	fp,sp,4
8111d470:	2005883a 	mov	r2,r4
8111d474:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailRequestDMA. FEE n: \n", ucTemp);
8111d478:	d0a06217 	ldw	r2,-32376(gp)
8111d47c:	e0ffff03 	ldbu	r3,-4(fp)
8111d480:	180d883a 	mov	r6,r3
8111d484:	01604574 	movhi	r5,33045
8111d488:	29417d04 	addi	r5,r5,1524
8111d48c:	1009883a 	mov	r4,r2
8111d490:	11215e00 	call	811215e0 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d494:	0001883a 	nop
8111d498:	e037883a 	mov	sp,fp
8111d49c:	dfc00117 	ldw	ra,4(sp)
8111d4a0:	df000017 	ldw	fp,0(sp)
8111d4a4:	dec00204 	addi	sp,sp,8
8111d4a8:	f800283a 	ret

8111d4ac <vFailSendRMAPFromIRQ>:


void vFailSendRMAPFromIRQ( unsigned char ucTemp)
{
8111d4ac:	defffd04 	addi	sp,sp,-12
8111d4b0:	de00012e 	bgeu	sp,et,8111d4b8 <vFailSendRMAPFromIRQ+0xc>
8111d4b4:	003b68fa 	trap	3
8111d4b8:	dfc00215 	stw	ra,8(sp)
8111d4bc:	df000115 	stw	fp,4(sp)
8111d4c0:	df000104 	addi	fp,sp,4
8111d4c4:	2005883a 	mov	r2,r4
8111d4c8:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendRMAPFromIRQ. FEE n: \n", ucTemp);
8111d4cc:	d0a06217 	ldw	r2,-32376(gp)
8111d4d0:	e0ffff03 	ldbu	r3,-4(fp)
8111d4d4:	180d883a 	mov	r6,r3
8111d4d8:	01604574 	movhi	r5,33045
8111d4dc:	29418404 	addi	r5,r5,1552
8111d4e0:	1009883a 	mov	r4,r2
8111d4e4:	11215e00 	call	811215e0 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d4e8:	0001883a 	nop
8111d4ec:	e037883a 	mov	sp,fp
8111d4f0:	dfc00117 	ldw	ra,4(sp)
8111d4f4:	df000017 	ldw	fp,0(sp)
8111d4f8:	dec00204 	addi	sp,sp,8
8111d4fc:	f800283a 	ret

8111d500 <vFailSendMsgSync>:


void vFailSendMsgSync( unsigned char ucTemp)
{
8111d500:	defffd04 	addi	sp,sp,-12
8111d504:	de00012e 	bgeu	sp,et,8111d50c <vFailSendMsgSync+0xc>
8111d508:	003b68fa 	trap	3
8111d50c:	dfc00215 	stw	ra,8(sp)
8111d510:	df000115 	stw	fp,4(sp)
8111d514:	df000104 	addi	fp,sp,4
8111d518:	2005883a 	mov	r2,r4
8111d51c:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendMsgSync. FEE n: \n", ucTemp);
8111d520:	d0a06217 	ldw	r2,-32376(gp)
8111d524:	e0ffff03 	ldbu	r3,-4(fp)
8111d528:	180d883a 	mov	r6,r3
8111d52c:	01604574 	movhi	r5,33045
8111d530:	29418c04 	addi	r5,r5,1584
8111d534:	1009883a 	mov	r4,r2
8111d538:	11215e00 	call	811215e0 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d53c:	0001883a 	nop
8111d540:	e037883a 	mov	sp,fp
8111d544:	dfc00117 	ldw	ra,4(sp)
8111d548:	df000017 	ldw	fp,0(sp)
8111d54c:	dec00204 	addi	sp,sp,8
8111d550:	f800283a 	ret

8111d554 <vFailSendMsgSyncRMAPTRIGGER>:

void vFailSendMsgSyncRMAPTRIGGER( unsigned char ucTemp)
{
8111d554:	defffd04 	addi	sp,sp,-12
8111d558:	de00012e 	bgeu	sp,et,8111d560 <vFailSendMsgSyncRMAPTRIGGER+0xc>
8111d55c:	003b68fa 	trap	3
8111d560:	dfc00215 	stw	ra,8(sp)
8111d564:	df000115 	stw	fp,4(sp)
8111d568:	df000104 	addi	fp,sp,4
8111d56c:	2005883a 	mov	r2,r4
8111d570:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendMsgSyncRMAPTRIGGER (FORCED MODE). FEE n: \n", ucTemp);
8111d574:	d0a06217 	ldw	r2,-32376(gp)
8111d578:	e0ffff03 	ldbu	r3,-4(fp)
8111d57c:	180d883a 	mov	r6,r3
8111d580:	01604574 	movhi	r5,33045
8111d584:	29419304 	addi	r5,r5,1612
8111d588:	1009883a 	mov	r4,r2
8111d58c:	11215e00 	call	811215e0 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d590:	0001883a 	nop
8111d594:	e037883a 	mov	sp,fp
8111d598:	dfc00117 	ldw	ra,4(sp)
8111d59c:	df000017 	ldw	fp,0(sp)
8111d5a0:	dec00204 	addi	sp,sp,8
8111d5a4:	f800283a 	ret

8111d5a8 <vFailSendMsgMasterSyncMeb>:

void vFailSendMsgMasterSyncMeb( void )
{
8111d5a8:	defffe04 	addi	sp,sp,-8
8111d5ac:	de00012e 	bgeu	sp,et,8111d5b4 <vFailSendMsgMasterSyncMeb+0xc>
8111d5b0:	003b68fa 	trap	3
8111d5b4:	dfc00115 	stw	ra,4(sp)
8111d5b8:	df000015 	stw	fp,0(sp)
8111d5bc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendMsgMasterSyncMeb \n");
8111d5c0:	d0a06217 	ldw	r2,-32376(gp)
8111d5c4:	100f883a 	mov	r7,r2
8111d5c8:	018006c4 	movi	r6,27
8111d5cc:	01400044 	movi	r5,1
8111d5d0:	01204574 	movhi	r4,33045
8111d5d4:	2101a004 	addi	r4,r4,1664
8111d5d8:	1121c7c0 	call	81121c7c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d5dc:	0001883a 	nop
8111d5e0:	e037883a 	mov	sp,fp
8111d5e4:	dfc00117 	ldw	ra,4(sp)
8111d5e8:	df000017 	ldw	fp,0(sp)
8111d5ec:	dec00204 	addi	sp,sp,8
8111d5f0:	f800283a 	ret

8111d5f4 <vFailSendMsgFeeCTRL>:

void vFailSendMsgFeeCTRL( void )
{
8111d5f4:	defffe04 	addi	sp,sp,-8
8111d5f8:	de00012e 	bgeu	sp,et,8111d600 <vFailSendMsgFeeCTRL+0xc>
8111d5fc:	003b68fa 	trap	3
8111d600:	dfc00115 	stw	ra,4(sp)
8111d604:	df000015 	stw	fp,0(sp)
8111d608:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendMsgFeeCTRL.  \n");
8111d60c:	d0a06217 	ldw	r2,-32376(gp)
8111d610:	100f883a 	mov	r7,r2
8111d614:	018005c4 	movi	r6,23
8111d618:	01400044 	movi	r5,1
8111d61c:	01204574 	movhi	r4,33045
8111d620:	2101a704 	addi	r4,r4,1692
8111d624:	1121c7c0 	call	81121c7c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d628:	0001883a 	nop
8111d62c:	e037883a 	mov	sp,fp
8111d630:	dfc00117 	ldw	ra,4(sp)
8111d634:	df000017 	ldw	fp,0(sp)
8111d638:	dec00204 	addi	sp,sp,8
8111d63c:	f800283a 	ret

8111d640 <vFailSendMsgDataCTRL>:

void vFailSendMsgDataCTRL( void )
{
8111d640:	defffe04 	addi	sp,sp,-8
8111d644:	de00012e 	bgeu	sp,et,8111d64c <vFailSendMsgDataCTRL+0xc>
8111d648:	003b68fa 	trap	3
8111d64c:	dfc00115 	stw	ra,4(sp)
8111d650:	df000015 	stw	fp,0(sp)
8111d654:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendMsgDataCTRL.  \n");
8111d658:	d0a06217 	ldw	r2,-32376(gp)
8111d65c:	100f883a 	mov	r7,r2
8111d660:	01800604 	movi	r6,24
8111d664:	01400044 	movi	r5,1
8111d668:	01204574 	movhi	r4,33045
8111d66c:	2101ad04 	addi	r4,r4,1716
8111d670:	1121c7c0 	call	81121c7c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d674:	0001883a 	nop
8111d678:	e037883a 	mov	sp,fp
8111d67c:	dfc00117 	ldw	ra,4(sp)
8111d680:	df000017 	ldw	fp,0(sp)
8111d684:	dec00204 	addi	sp,sp,8
8111d688:	f800283a 	ret

8111d68c <vFailFlushQueue>:

void vFailFlushQueue( void )
{
8111d68c:	defffe04 	addi	sp,sp,-8
8111d690:	de00012e 	bgeu	sp,et,8111d698 <vFailFlushQueue+0xc>
8111d694:	003b68fa 	trap	3
8111d698:	dfc00115 	stw	ra,4(sp)
8111d69c:	df000015 	stw	fp,0(sp)
8111d6a0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushQueue.  \n");
8111d6a4:	d0a06217 	ldw	r2,-32376(gp)
8111d6a8:	100f883a 	mov	r7,r2
8111d6ac:	01800744 	movi	r6,29
8111d6b0:	01400044 	movi	r5,1
8111d6b4:	01204574 	movhi	r4,33045
8111d6b8:	2101b404 	addi	r4,r4,1744
8111d6bc:	1121c7c0 	call	81121c7c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d6c0:	0001883a 	nop
8111d6c4:	e037883a 	mov	sp,fp
8111d6c8:	dfc00117 	ldw	ra,4(sp)
8111d6cc:	df000017 	ldw	fp,0(sp)
8111d6d0:	dec00204 	addi	sp,sp,8
8111d6d4:	f800283a 	ret

8111d6d8 <vFailFlushQueueData>:

void vFailFlushQueueData( void )
{
8111d6d8:	defffe04 	addi	sp,sp,-8
8111d6dc:	de00012e 	bgeu	sp,et,8111d6e4 <vFailFlushQueueData+0xc>
8111d6e0:	003b68fa 	trap	3
8111d6e4:	dfc00115 	stw	ra,4(sp)
8111d6e8:	df000015 	stw	fp,0(sp)
8111d6ec:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushQueueData.  \n");
8111d6f0:	d0a06217 	ldw	r2,-32376(gp)
8111d6f4:	100f883a 	mov	r7,r2
8111d6f8:	01800844 	movi	r6,33
8111d6fc:	01400044 	movi	r5,1
8111d700:	01204574 	movhi	r4,33045
8111d704:	2101bc04 	addi	r4,r4,1776
8111d708:	1121c7c0 	call	81121c7c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d70c:	0001883a 	nop
8111d710:	e037883a 	mov	sp,fp
8111d714:	dfc00117 	ldw	ra,4(sp)
8111d718:	df000017 	ldw	fp,0(sp)
8111d71c:	dec00204 	addi	sp,sp,8
8111d720:	f800283a 	ret

8111d724 <vFailFlushMEBQueue>:


void vFailFlushMEBQueue( void )
{
8111d724:	defffe04 	addi	sp,sp,-8
8111d728:	de00012e 	bgeu	sp,et,8111d730 <vFailFlushMEBQueue+0xc>
8111d72c:	003b68fa 	trap	3
8111d730:	dfc00115 	stw	ra,4(sp)
8111d734:	df000015 	stw	fp,0(sp)
8111d738:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushMEBQueue.  \n");
8111d73c:	d0a06217 	ldw	r2,-32376(gp)
8111d740:	100f883a 	mov	r7,r2
8111d744:	01800804 	movi	r6,32
8111d748:	01400044 	movi	r5,1
8111d74c:	01204574 	movhi	r4,33045
8111d750:	2101c504 	addi	r4,r4,1812
8111d754:	1121c7c0 	call	81121c7c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d758:	0001883a 	nop
8111d75c:	e037883a 	mov	sp,fp
8111d760:	dfc00117 	ldw	ra,4(sp)
8111d764:	df000017 	ldw	fp,0(sp)
8111d768:	dec00204 	addi	sp,sp,8
8111d76c:	f800283a 	ret

8111d770 <vFailFlushNFEEQueue>:

void vFailFlushNFEEQueue( void )
{
8111d770:	defffe04 	addi	sp,sp,-8
8111d774:	de00012e 	bgeu	sp,et,8111d77c <vFailFlushNFEEQueue+0xc>
8111d778:	003b68fa 	trap	3
8111d77c:	dfc00115 	stw	ra,4(sp)
8111d780:	df000015 	stw	fp,0(sp)
8111d784:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushNFEEQueue.  \n");
8111d788:	d0a06217 	ldw	r2,-32376(gp)
8111d78c:	100f883a 	mov	r7,r2
8111d790:	01800844 	movi	r6,33
8111d794:	01400044 	movi	r5,1
8111d798:	01204574 	movhi	r4,33045
8111d79c:	2101ce04 	addi	r4,r4,1848
8111d7a0:	1121c7c0 	call	81121c7c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d7a4:	0001883a 	nop
8111d7a8:	e037883a 	mov	sp,fp
8111d7ac:	dfc00117 	ldw	ra,4(sp)
8111d7b0:	df000017 	ldw	fp,0(sp)
8111d7b4:	dec00204 	addi	sp,sp,8
8111d7b8:	f800283a 	ret

8111d7bc <vEvtChangeMebMode>:


#include "events_handler.h"


void vEvtChangeMebMode( void ) {
8111d7bc:	deffff04 	addi	sp,sp,-4
8111d7c0:	de00012e 	bgeu	sp,et,8111d7c8 <vEvtChangeMebMode+0xc>
8111d7c4:	003b68fa 	trap	3
8111d7c8:	df000015 	stw	fp,0(sp)
8111d7cc:	d839883a 	mov	fp,sp

	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
8111d7d0:	0001883a 	nop
8111d7d4:	e037883a 	mov	sp,fp
8111d7d8:	df000017 	ldw	fp,0(sp)
8111d7dc:	dec00104 	addi	sp,sp,4
8111d7e0:	f800283a 	ret

8111d7e4 <vEvtChangeFeeControllerMode>:


void vEvtChangeFeeControllerMode( void ) {
8111d7e4:	deffff04 	addi	sp,sp,-4
8111d7e8:	de00012e 	bgeu	sp,et,8111d7f0 <vEvtChangeFeeControllerMode+0xc>
8111d7ec:	003b68fa 	trap	3
8111d7f0:	df000015 	stw	fp,0(sp)
8111d7f4:	d839883a 	mov	fp,sp


	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
8111d7f8:	0001883a 	nop
8111d7fc:	e037883a 	mov	sp,fp
8111d800:	df000017 	ldw	fp,0(sp)
8111d804:	dec00104 	addi	sp,sp,4
8111d808:	f800283a 	ret

8111d80c <vEvtChangeDataControllerMode>:


void vEvtChangeDataControllerMode( void ) {
8111d80c:	deffff04 	addi	sp,sp,-4
8111d810:	de00012e 	bgeu	sp,et,8111d818 <vEvtChangeDataControllerMode+0xc>
8111d814:	003b68fa 	trap	3
8111d818:	df000015 	stw	fp,0(sp)
8111d81c:	d839883a 	mov	fp,sp


	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
8111d820:	0001883a 	nop
8111d824:	e037883a 	mov	sp,fp
8111d828:	df000017 	ldw	fp,0(sp)
8111d82c:	dec00104 	addi	sp,sp,4
8111d830:	f800283a 	ret

8111d834 <vNFeeNotInUse>:
 *      Author: Tiago-Low
 */

#include "fee.h"

void vNFeeNotInUse( TNFee *pxNfeeL, unsigned char ucIdNFEE ) {
8111d834:	defffd04 	addi	sp,sp,-12
8111d838:	de00012e 	bgeu	sp,et,8111d840 <vNFeeNotInUse+0xc>
8111d83c:	003b68fa 	trap	3
8111d840:	df000215 	stw	fp,8(sp)
8111d844:	df000204 	addi	fp,sp,8
8111d848:	e13ffe15 	stw	r4,-8(fp)
8111d84c:	2805883a 	mov	r2,r5
8111d850:	e0bfff05 	stb	r2,-4(fp)

    /* NFEE id [0..7] */
    pxNfeeL->ucId = ucIdNFEE;
8111d854:	e0bffe17 	ldw	r2,-8(fp)
8111d858:	e0ffff03 	ldbu	r3,-4(fp)
8111d85c:	10c00005 	stb	r3,0(r2)
    pxNfeeL->xControl.bEnabled = FALSE;
8111d860:	e0bffe17 	ldw	r2,-8(fp)
8111d864:	10002115 	stw	zero,132(r2)
    pxNfeeL->xControl.bUsingDMA = FALSE;
8111d868:	e0bffe17 	ldw	r2,-8(fp)
8111d86c:	10002315 	stw	zero,140(r2)
}
8111d870:	0001883a 	nop
8111d874:	e037883a 	mov	sp,fp
8111d878:	df000017 	ldw	fp,0(sp)
8111d87c:	dec00104 	addi	sp,sp,4
8111d880:	f800283a 	ret

8111d884 <vNFeeStructureInit>:


/* Initialize the structure of control of NFEE with the default Configurations */
void vNFeeStructureInit( TNFee *pxNfeeL, unsigned char ucIdNFEE ) {
8111d884:	defffb04 	addi	sp,sp,-20
8111d888:	de00012e 	bgeu	sp,et,8111d890 <vNFeeStructureInit+0xc>
8111d88c:	003b68fa 	trap	3
8111d890:	dfc00415 	stw	ra,16(sp)
8111d894:	df000315 	stw	fp,12(sp)
8111d898:	df000304 	addi	fp,sp,12
8111d89c:	e13ffe15 	stw	r4,-8(fp)
8111d8a0:	2805883a 	mov	r2,r5
8111d8a4:	e0bfff05 	stb	r2,-4(fp)
    unsigned char ucIL = 0;
8111d8a8:	e03ffd05 	stb	zero,-12(fp)

    /* NFEE id [0..5] */
    pxNfeeL->ucId = ucIdNFEE;
8111d8ac:	e0bffe17 	ldw	r2,-8(fp)
8111d8b0:	e0ffff03 	ldbu	r3,-4(fp)
8111d8b4:	10c00005 	stb	r3,0(r2)

    /* Load the default values of the CCDs regarding pixels configuration */
    vCCDLoadDefaultValues(&pxNfeeL->xCcdInfo);
8111d8b8:	e0bffe17 	ldw	r2,-8(fp)
8111d8bc:	10802f04 	addi	r2,r2,188
8111d8c0:	1009883a 	mov	r4,r2
8111d8c4:	11184600 	call	81118460 <vCCDLoadDefaultValues>

    /* Update the values of memory mapping for this FEE */
    vUpdateMemMapFEE(pxNfeeL);
8111d8c8:	e13ffe17 	ldw	r4,-8(fp)
8111d8cc:	111dac00 	call	8111dac0 <vUpdateMemMapFEE>

    /* Initilizing control variables */
    pxNfeeL->xControl.bEnabled = TRUE;
8111d8d0:	e0bffe17 	ldw	r2,-8(fp)
8111d8d4:	00c00044 	movi	r3,1
8111d8d8:	10c02115 	stw	r3,132(r2)
    pxNfeeL->xControl.bUsingDMA = FALSE;
8111d8dc:	e0bffe17 	ldw	r2,-8(fp)
8111d8e0:	10002315 	stw	zero,140(r2)
    pxNfeeL->xControl.bChannelEnable = FALSE;
8111d8e4:	e0bffe17 	ldw	r2,-8(fp)
8111d8e8:	10002615 	stw	zero,152(r2)
    pxNfeeL->xControl.bSimulating = FALSE;
8111d8ec:	e0bffe17 	ldw	r2,-8(fp)
8111d8f0:	10002715 	stw	zero,156(r2)
    pxNfeeL->xControl.bWatingSync = FALSE;
8111d8f4:	e0bffe17 	ldw	r2,-8(fp)
8111d8f8:	10002815 	stw	zero,160(r2)
    pxNfeeL->xControl.bEchoing = FALSE;
8111d8fc:	e0bffe17 	ldw	r2,-8(fp)
8111d900:	10002515 	stw	zero,148(r2)
    pxNfeeL->xControl.bLogging = FALSE;
8111d904:	e0bffe17 	ldw	r2,-8(fp)
8111d908:	10002415 	stw	zero,144(r2)
    pxNfeeL->xControl.bDMALocked = FALSE;
8111d90c:	e0bffe17 	ldw	r2,-8(fp)
8111d910:	10002215 	stw	zero,136(r2)
    /* The default side is left */
    pxNfeeL->xControl.eSide = sLeft;
8111d914:	e0bffe17 	ldw	r2,-8(fp)
8111d918:	10002e15 	stw	zero,184(r2)
    pxNfeeL->xControl.ucTimeCode = 0;
8111d91c:	e0bffe17 	ldw	r2,-8(fp)
8111d920:	10002a05 	stb	zero,168(r2)
    

    /* The NFEE initialize in the Config mode by default */
    pxNfeeL->xControl.eMode = sFeeInit;
8111d924:	e0bffe17 	ldw	r2,-8(fp)
8111d928:	10002c15 	stw	zero,176(r2)
    pxNfeeL->xControl.eNextMode = sFeeInit;
8111d92c:	e0bffe17 	ldw	r2,-8(fp)
8111d930:	10002d15 	stw	zero,180(r2)

    switch (ucIdNFEE) {
8111d934:	e0bfff03 	ldbu	r2,-4(fp)
8111d938:	1000071e 	bne	r2,zero,8111d958 <vNFeeStructureInit+0xd4>
		case 0:
			pxNfeeL->ucSPWId = (unsigned char)xDefaults.usiLinkNFEE0;
8111d93c:	00a045b4 	movhi	r2,33046
8111d940:	109c0004 	addi	r2,r2,28672
8111d944:	1080100b 	ldhu	r2,64(r2)
8111d948:	1007883a 	mov	r3,r2
8111d94c:	e0bffe17 	ldw	r2,-8(fp)
8111d950:	10c00045 	stb	r3,1(r2)
			break;
8111d954:	00000a06 	br	8111d980 <vNFeeStructureInit+0xfc>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "\n CRITICAL! Can't bind the SPQ channel with the NFEE %i \n", pxNfeeL->ucId);
8111d958:	d0e06217 	ldw	r3,-32376(gp)
8111d95c:	e0bffe17 	ldw	r2,-8(fp)
8111d960:	10800003 	ldbu	r2,0(r2)
8111d964:	10803fcc 	andi	r2,r2,255
8111d968:	100d883a 	mov	r6,r2
8111d96c:	01604574 	movhi	r5,33045
8111d970:	2941d704 	addi	r5,r5,1884
8111d974:	1809883a 	mov	r4,r3
8111d978:	11215e00 	call	811215e0 <fprintf>
			#endif
			break;
8111d97c:	0001883a 	nop

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadNFEEDefsSDCard(); !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* Set the default redout order [ 0, 1, 2, 3 ] */
    for ( ucIL = 0; ucIL < 4; ucIL++) 
8111d980:	e03ffd05 	stb	zero,-12(fp)
8111d984:	00000906 	br	8111d9ac <vNFeeStructureInit+0x128>
        pxNfeeL->xControl.ucROutOrder[ucIL] = ucIL;
8111d988:	e0bffd03 	ldbu	r2,-12(fp)
8111d98c:	e0fffe17 	ldw	r3,-8(fp)
8111d990:	1885883a 	add	r2,r3,r2
8111d994:	10802a44 	addi	r2,r2,169
8111d998:	e0fffd03 	ldbu	r3,-12(fp)
8111d99c:	10c00005 	stb	r3,0(r2)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadNFEEDefsSDCard(); !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* Set the default redout order [ 0, 1, 2, 3 ] */
    for ( ucIL = 0; ucIL < 4; ucIL++) 
8111d9a0:	e0bffd03 	ldbu	r2,-12(fp)
8111d9a4:	10800044 	addi	r2,r2,1
8111d9a8:	e0bffd05 	stb	r2,-12(fp)
8111d9ac:	e0bffd03 	ldbu	r2,-12(fp)
8111d9b0:	10800130 	cmpltui	r2,r2,4
8111d9b4:	103ff41e 	bne	r2,zero,8111d988 <__reset+0xfb0fd988>
        pxNfeeL->xControl.ucROutOrder[ucIL] = ucIL;

    /* Initialize the structs of the Channel, Double Buffer, RMAP and Data packet */
    if ( bCommInitCh(&pxNfeeL->xChannel, pxNfeeL->ucSPWId ) == FALSE ) {
8111d9b8:	e0bffe17 	ldw	r2,-8(fp)
8111d9bc:	10c03204 	addi	r3,r2,200
8111d9c0:	e0bffe17 	ldw	r2,-8(fp)
8111d9c4:	10800043 	ldbu	r2,1(r2)
8111d9c8:	10803fcc 	andi	r2,r2,255
8111d9cc:	100b883a 	mov	r5,r2
8111d9d0:	1809883a 	mov	r4,r3
8111d9d4:	110486c0 	call	8110486c <bCommInitCh>
8111d9d8:	1000091e 	bne	r2,zero,8111da00 <vNFeeStructureInit+0x17c>
		#ifdef DEBUG_ON
			fprintf(fp, "\n CRITICAL! Can't Initialized SPW Channel %i \n", pxNfeeL->ucId);
8111d9dc:	d0e06217 	ldw	r3,-32376(gp)
8111d9e0:	e0bffe17 	ldw	r2,-8(fp)
8111d9e4:	10800003 	ldbu	r2,0(r2)
8111d9e8:	10803fcc 	andi	r2,r2,255
8111d9ec:	100d883a 	mov	r6,r2
8111d9f0:	01604574 	movhi	r5,33045
8111d9f4:	2941e604 	addi	r5,r5,1944
8111d9f8:	1809883a 	mov	r4,r3
8111d9fc:	11215e00 	call	811215e0 <fprintf>
		#endif
    }

    if ( bCommSetGlobalIrqEn( TRUE, pxNfeeL->ucSPWId ) == FALSE ) {
8111da00:	e0bffe17 	ldw	r2,-8(fp)
8111da04:	10800043 	ldbu	r2,1(r2)
8111da08:	10803fcc 	andi	r2,r2,255
8111da0c:	100b883a 	mov	r5,r2
8111da10:	01000044 	movi	r4,1
8111da14:	11047000 	call	81104700 <bCommSetGlobalIrqEn>
8111da18:	1000091e 	bne	r2,zero,8111da40 <vNFeeStructureInit+0x1bc>
		#ifdef DEBUG_ON
			fprintf(fp, "\n CRITICAL! Can't Enable global interrupt for the channel %i \n", pxNfeeL->ucId);
8111da1c:	d0e06217 	ldw	r3,-32376(gp)
8111da20:	e0bffe17 	ldw	r2,-8(fp)
8111da24:	10800003 	ldbu	r2,0(r2)
8111da28:	10803fcc 	andi	r2,r2,255
8111da2c:	100d883a 	mov	r6,r2
8111da30:	01604574 	movhi	r5,33045
8111da34:	2941f204 	addi	r5,r5,1992
8111da38:	1809883a 	mov	r4,r3
8111da3c:	11215e00 	call	811215e0 <fprintf>
		#endif
    }

    bDpktGetPixelDelay(&pxNfeeL->xChannel.xDataPacket);
8111da40:	e0bffe17 	ldw	r2,-8(fp)
8111da44:	10803304 	addi	r2,r2,204
8111da48:	1009883a 	mov	r4,r2
8111da4c:	1104f440 	call	81104f44 <bDpktGetPixelDelay>
    pxNfeeL->xChannel.xDataPacket.xDpktPixelDelay.usiAdcDelay = usiAdcPxDelayCalcPeriodNs(xDefaults.ulADCPixelDelay);
8111da50:	00a045b4 	movhi	r2,33046
8111da54:	109c0004 	addi	r2,r2,28672
8111da58:	10800b17 	ldw	r2,44(r2)
8111da5c:	1009883a 	mov	r4,r2
8111da60:	11052200 	call	81105220 <usiAdcPxDelayCalcPeriodNs>
8111da64:	1007883a 	mov	r3,r2
8111da68:	e0bffe17 	ldw	r2,-8(fp)
8111da6c:	10c03a0d 	sth	r3,232(r2)
    pxNfeeL->xChannel.xDataPacket.xDpktPixelDelay.usiColumnDelay = 0 ;
8111da70:	e0bffe17 	ldw	r2,-8(fp)
8111da74:	1000398d 	sth	zero,230(r2)
    pxNfeeL->xChannel.xDataPacket.xDpktPixelDelay.usiLineDelay = usiLineTrDelayCalcPeriodNs(xDefaults.ulLineDelay);
8111da78:	00a045b4 	movhi	r2,33046
8111da7c:	109c0004 	addi	r2,r2,28672
8111da80:	10800917 	ldw	r2,36(r2)
8111da84:	1009883a 	mov	r4,r2
8111da88:	11052ac0 	call	811052ac <usiLineTrDelayCalcPeriodNs>
8111da8c:	1007883a 	mov	r3,r2
8111da90:	e0bffe17 	ldw	r2,-8(fp)
8111da94:	10c0390d 	sth	r3,228(r2)
    bDpktSetPixelDelay(&pxNfeeL->xChannel.xDataPacket);
8111da98:	e0bffe17 	ldw	r2,-8(fp)
8111da9c:	10803304 	addi	r2,r2,204
8111daa0:	1009883a 	mov	r4,r2
8111daa4:	1104dfc0 	call	81104dfc <bDpktSetPixelDelay>


}
8111daa8:	0001883a 	nop
8111daac:	e037883a 	mov	sp,fp
8111dab0:	dfc00117 	ldw	ra,4(sp)
8111dab4:	df000017 	ldw	fp,0(sp)
8111dab8:	dec00204 	addi	sp,sp,8
8111dabc:	f800283a 	ret

8111dac0 <vUpdateMemMapFEE>:

/* Update the memory mapping for the FEE due to the CCD informations */
void vUpdateMemMapFEE( TNFee *pxNfeeL ) {
8111dac0:	defff404 	addi	sp,sp,-48
8111dac4:	de00012e 	bgeu	sp,et,8111dacc <vUpdateMemMapFEE+0xc>
8111dac8:	003b68fa 	trap	3
8111dacc:	df000b15 	stw	fp,44(sp)
8111dad0:	df000b04 	addi	fp,sp,44
8111dad4:	e13fff15 	stw	r4,-4(fp)
    unsigned long ulTotalSizeL = 0; /* pixels */
8111dad8:	e03ffa15 	stw	zero,-24(fp)
    unsigned long ulMemLinesL = 0; /* mem lines */
8111dadc:	e03ff515 	stw	zero,-44(fp)
    unsigned long ulTotalMemLinesL = 0;
8111dae0:	e03ff615 	stw	zero,-40(fp)
    unsigned long ulMemLeftBytesL = 0; /* bytes */
8111dae4:	e03ffb15 	stw	zero,-20(fp)
    unsigned long ulMemLeftLinesL = 0; /* mem lines */
8111dae8:	e03ffc15 	stw	zero,-16(fp)
    unsigned long ulMaskMemLinesL = 0; /* mem lines */
8111daec:	e03ff715 	stw	zero,-36(fp)
    unsigned char ucPixelsInLastBlockL = 0;
8111daf0:	e03ff805 	stb	zero,-32(fp)
    unsigned char ucShiftsL = 0;
8111daf4:	e03ffd05 	stb	zero,-12(fp)
    unsigned char ucIL = 0;
8111daf8:	e03ff845 	stb	zero,-31(fp)
    unsigned long ulLastOffset = 0;
8111dafc:	e03ff915 	stw	zero,-28(fp)
    unsigned long ulStepHalfCCD = 0;
8111db00:	e03ffe15 	stw	zero,-8(fp)


    /* Size of the footprint of the CCD in the DDR memory */
    pxNfeeL->xMemMap.ulTotalBytes = ( OFFSET_STEP_FEE );
8111db04:	e17fff17 	ldw	r5,-4(fp)
8111db08:	01035a34 	movhi	r4,3432
8111db0c:	21348c04 	addi	r4,r4,-11728
8111db10:	29000215 	stw	r4,8(r5)

    /* Offset of the FEE in the DDR memory */
    pxNfeeL->xMemMap.ulOffsetRoot = OFFSET_STEP_FEE * pxNfeeL->ucId;
8111db14:	e13fff17 	ldw	r4,-4(fp)
8111db18:	21000003 	ldbu	r4,0(r4)
8111db1c:	21403fcc 	andi	r5,r4,255
8111db20:	01035a34 	movhi	r4,3432
8111db24:	21348c04 	addi	r4,r4,-11728
8111db28:	2909383a 	mul	r4,r5,r4
8111db2c:	200b883a 	mov	r5,r4
8111db30:	e13fff17 	ldw	r4,-4(fp)
8111db34:	21400115 	stw	r5,4(r4)

    /* LUT Addrs */
    pxNfeeL->xMemMap.ulLUTAddr = LUT_INITIAL_ADDR + pxNfeeL->xMemMap.ulOffsetRoot;
8111db38:	e13fff17 	ldw	r4,-4(fp)
8111db3c:	21400117 	ldw	r5,4(r4)
8111db40:	01033234 	movhi	r4,3272
8111db44:	21348c04 	addi	r4,r4,-11728
8111db48:	290b883a 	add	r5,r5,r4
8111db4c:	e13fff17 	ldw	r4,-4(fp)
8111db50:	21400315 	stw	r5,12(r4)

    /* (HEIGHT + usiOLN)*(usiSPrescanN + usiSOverscanN + usiHalfWidth) */
    ulTotalSizeL =  ( pxNfeeL->xCcdInfo.usiHeight + pxNfeeL->xCcdInfo.usiOLN ) *
8111db54:	e13fff17 	ldw	r4,-4(fp)
8111db58:	2100310b 	ldhu	r4,196(r4)
8111db5c:	217fffcc 	andi	r5,r4,65535
8111db60:	e13fff17 	ldw	r4,-4(fp)
8111db64:	2100300b 	ldhu	r4,192(r4)
8111db68:	213fffcc 	andi	r4,r4,65535
8111db6c:	290b883a 	add	r5,r5,r4
                    ( pxNfeeL->xCcdInfo.usiHalfWidth + pxNfeeL->xCcdInfo.usiSOverscanN + pxNfeeL->xCcdInfo.usiSPrescanN );
8111db70:	e13fff17 	ldw	r4,-4(fp)
8111db74:	2100308b 	ldhu	r4,194(r4)
8111db78:	21bfffcc 	andi	r6,r4,65535
8111db7c:	e13fff17 	ldw	r4,-4(fp)
8111db80:	21002f8b 	ldhu	r4,190(r4)
8111db84:	213fffcc 	andi	r4,r4,65535
8111db88:	310d883a 	add	r6,r6,r4
8111db8c:	e13fff17 	ldw	r4,-4(fp)
8111db90:	21002f0b 	ldhu	r4,188(r4)
8111db94:	213fffcc 	andi	r4,r4,65535
8111db98:	3109883a 	add	r4,r6,r4

    /* LUT Addrs */
    pxNfeeL->xMemMap.ulLUTAddr = LUT_INITIAL_ADDR + pxNfeeL->xMemMap.ulOffsetRoot;

    /* (HEIGHT + usiOLN)*(usiSPrescanN + usiSOverscanN + usiHalfWidth) */
    ulTotalSizeL =  ( pxNfeeL->xCcdInfo.usiHeight + pxNfeeL->xCcdInfo.usiOLN ) *
8111db9c:	2909383a 	mul	r4,r5,r4
8111dba0:	e13ffa15 	stw	r4,-24(fp)
                    ( pxNfeeL->xCcdInfo.usiHalfWidth + pxNfeeL->xCcdInfo.usiSOverscanN + pxNfeeL->xCcdInfo.usiSPrescanN );

    /* Total size in Bytes of a half CCD */
    pxNfeeL->xMemMap.xCommon.usiTotalBytes = ulTotalSizeL * BYTES_PER_PIXEL;
8111dba4:	e13ffa17 	ldw	r4,-24(fp)
8111dba8:	2109883a 	add	r4,r4,r4
8111dbac:	200b883a 	mov	r5,r4
8111dbb0:	e13fff17 	ldw	r4,-4(fp)
8111dbb4:	21400515 	stw	r5,20(r4)

    /* Total of Memory lines (64 bits memory) */
    ulMemLinesL = (unsigned long) pxNfeeL->xMemMap.xCommon.usiTotalBytes / BYTES_PER_MEM_LINE;
8111dbb8:	e13fff17 	ldw	r4,-4(fp)
8111dbbc:	21000517 	ldw	r4,20(r4)
8111dbc0:	2008d0fa 	srli	r4,r4,3
8111dbc4:	e13ff515 	stw	r4,-44(fp)
    ulMemLeftBytesL = pxNfeeL->xMemMap.xCommon.usiTotalBytes % BYTES_PER_MEM_LINE;   /* Word memory Alignment check: how much bytes left not align in the last word of the memory */
8111dbc8:	e13fff17 	ldw	r4,-4(fp)
8111dbcc:	21000517 	ldw	r4,20(r4)
8111dbd0:	210001cc 	andi	r4,r4,7
8111dbd4:	e13ffb15 	stw	r4,-20(fp)
    if ( ulMemLeftBytesL > 0 ) {
8111dbd8:	e13ffb17 	ldw	r4,-20(fp)
8111dbdc:	20001226 	beq	r4,zero,8111dc28 <vUpdateMemMapFEE+0x168>
        ulMemLinesL = ulMemLinesL + 1;
8111dbe0:	e13ff517 	ldw	r4,-44(fp)
8111dbe4:	21000044 	addi	r4,r4,1
8111dbe8:	e13ff515 	stw	r4,-44(fp)
        pxNfeeL->xMemMap.xCommon.usiTotalBytes = pxNfeeL->xMemMap.xCommon.usiTotalBytes - ulMemLeftBytesL + BYTES_PER_MEM_LINE; /* Add a full line, after will be filled with zero padding */
8111dbec:	e13fff17 	ldw	r4,-4(fp)
8111dbf0:	21400517 	ldw	r5,20(r4)
8111dbf4:	e13ffb17 	ldw	r4,-20(fp)
8111dbf8:	2909c83a 	sub	r4,r5,r4
8111dbfc:	21400204 	addi	r5,r4,8
8111dc00:	e13fff17 	ldw	r4,-4(fp)
8111dc04:	21400515 	stw	r5,20(r4)
        pxNfeeL->xMemMap.xCommon.ucPaddingBytes = BYTES_PER_MEM_LINE - ulMemLeftBytesL;
8111dc08:	e13ffb17 	ldw	r4,-20(fp)
8111dc0c:	200b883a 	mov	r5,r4
8111dc10:	01000204 	movi	r4,8
8111dc14:	2149c83a 	sub	r4,r4,r5
8111dc18:	200b883a 	mov	r5,r4
8111dc1c:	e13fff17 	ldw	r4,-4(fp)
8111dc20:	21400605 	stb	r5,24(r4)
8111dc24:	00000206 	br	8111dc30 <vUpdateMemMapFEE+0x170>
    } else {
        pxNfeeL->xMemMap.xCommon.ucPaddingBytes = 0;
8111dc28:	e13fff17 	ldw	r4,-4(fp)
8111dc2c:	20000605 	stb	zero,24(r4)
    }

    /* At this point we have mapping the pixel in the CCD and calculate the zero padding for the last WORD of the line memory of the half ccd */

    /* For every 16 mem line will be 1 mask mem line */
    ulMaskMemLinesL = (unsigned long) ulMemLinesL / BLOCK_MEM_SIZE;
8111dc30:	e13ff517 	ldw	r4,-44(fp)
8111dc34:	2008d13a 	srli	r4,r4,4
8111dc38:	e13ff715 	stw	r4,-36(fp)
    ulMemLeftLinesL = ulMemLinesL % BLOCK_MEM_SIZE;
8111dc3c:	e13ff517 	ldw	r4,-44(fp)
8111dc40:	210003cc 	andi	r4,r4,15
8111dc44:	e13ffc15 	stw	r4,-16(fp)
    if ( ulMemLeftLinesL >= 1 ) {
8111dc48:	e13ffc17 	ldw	r4,-16(fp)
8111dc4c:	20000b26 	beq	r4,zero,8111dc7c <vUpdateMemMapFEE+0x1bc>
        ulMaskMemLinesL = ulMaskMemLinesL + 1;
8111dc50:	e13ff717 	ldw	r4,-36(fp)
8111dc54:	21000044 	addi	r4,r4,1
8111dc58:	e13ff715 	stw	r4,-36(fp)
        ulTotalMemLinesL = ( ulMemLinesL - ulMemLeftLinesL + BLOCK_MEM_SIZE ) + ulMaskMemLinesL; /* One extra 16 sized block, will be filled with zero padding the ret os spare lines */
8111dc5c:	e17ff517 	ldw	r5,-44(fp)
8111dc60:	e13ffc17 	ldw	r4,-16(fp)
8111dc64:	290bc83a 	sub	r5,r5,r4
8111dc68:	e13ff717 	ldw	r4,-36(fp)
8111dc6c:	2909883a 	add	r4,r5,r4
8111dc70:	21000404 	addi	r4,r4,16
8111dc74:	e13ff615 	stw	r4,-40(fp)
8111dc78:	00000406 	br	8111dc8c <vUpdateMemMapFEE+0x1cc>
    } else {
        ulTotalMemLinesL = ulMemLinesL + ulMaskMemLinesL;
8111dc7c:	e17ff517 	ldw	r5,-44(fp)
8111dc80:	e13ff717 	ldw	r4,-36(fp)
8111dc84:	2909883a 	add	r4,r5,r4
8111dc88:	e13ff615 	stw	r4,-40(fp)
    }

    pxNfeeL->xMemMap.xCommon.usiTotalBytes = ulTotalMemLinesL * BYTES_PER_MEM_LINE;
8111dc8c:	e13ff617 	ldw	r4,-40(fp)
8111dc90:	200a90fa 	slli	r5,r4,3
8111dc94:	e13fff17 	ldw	r4,-4(fp)
8111dc98:	21400515 	stw	r5,20(r4)


    /* Calculating how is the final mask with zero padding */
    if ( ulMemLeftBytesL >= 1 ) {
8111dc9c:	e13ffb17 	ldw	r4,-20(fp)
8111dca0:	20000926 	beq	r4,zero,8111dcc8 <vUpdateMemMapFEE+0x208>
        ucPixelsInLastBlockL = (unsigned char) (( ulMemLeftLinesL * PIXEL_PER_MEM_LINE ) + (unsigned int) ( ulMemLeftBytesL / BYTES_PER_PIXEL ));
8111dca4:	e13ffc17 	ldw	r4,-16(fp)
8111dca8:	2109883a 	add	r4,r4,r4
8111dcac:	2109883a 	add	r4,r4,r4
8111dcb0:	200b883a 	mov	r5,r4
8111dcb4:	e13ffb17 	ldw	r4,-20(fp)
8111dcb8:	2008d07a 	srli	r4,r4,1
8111dcbc:	2909883a 	add	r4,r5,r4
8111dcc0:	e13ff805 	stb	r4,-32(fp)
8111dcc4:	00000406 	br	8111dcd8 <vUpdateMemMapFEE+0x218>
    } else {
        ucPixelsInLastBlockL = (unsigned char) ( ulMemLeftLinesL * PIXEL_PER_MEM_LINE );
8111dcc8:	e13ffc17 	ldw	r4,-16(fp)
8111dccc:	2109883a 	add	r4,r4,r4
8111dcd0:	2109883a 	add	r4,r4,r4
8111dcd4:	e13ff805 	stb	r4,-32(fp)
    }

    /* 16 * 4 = 64 - (number of pixels in the last block)) */
    ucShiftsL = ( BLOCK_MEM_SIZE * PIXEL_PER_MEM_LINE ) - ucPixelsInLastBlockL;
8111dcd8:	e13ff803 	ldbu	r4,-32(fp)
8111dcdc:	01401004 	movi	r5,64
8111dce0:	2909c83a 	sub	r4,r5,r4
8111dce4:	e13ffd05 	stb	r4,-12(fp)

    /* WARNING: Verify the memory alocation (endianess) */
    //pxNfeeL->xMemMap.xCommon.ucPaddingMask.ullWord = (unsigned long long)(0xFFFFFFFFFFFFFFFF >> ucShiftsL);
    pxNfeeL->xMemMap.xCommon.ucPaddingMask.ullWord = (unsigned long long)(0xFFFFFFFFFFFFFFFF << ucShiftsL);
8111dce8:	e13ffd03 	ldbu	r4,-12(fp)
8111dcec:	217ff804 	addi	r5,r4,-32
8111dcf0:	28000416 	blt	r5,zero,8111dd04 <vUpdateMemMapFEE+0x244>
8111dcf4:	013fffc4 	movi	r4,-1
8111dcf8:	2146983a 	sll	r3,r4,r5
8111dcfc:	0005883a 	mov	r2,zero
8111dd00:	00000a06 	br	8111dd2c <vUpdateMemMapFEE+0x26c>
8111dd04:	017fffc4 	movi	r5,-1
8111dd08:	280cd07a 	srli	r6,r5,1
8111dd0c:	014007c4 	movi	r5,31
8111dd10:	290bc83a 	sub	r5,r5,r4
8111dd14:	314ad83a 	srl	r5,r6,r5
8111dd18:	01bfffc4 	movi	r6,-1
8111dd1c:	3106983a 	sll	r3,r6,r4
8111dd20:	28c6b03a 	or	r3,r5,r3
8111dd24:	017fffc4 	movi	r5,-1
8111dd28:	2904983a 	sll	r2,r5,r4
8111dd2c:	e13fff17 	ldw	r4,-4(fp)
8111dd30:	20800715 	stw	r2,28(r4)
8111dd34:	20c00815 	stw	r3,32(r4)
    //pxNfeeL->xMemMap.xCommon.ucPaddingMask.ullWord = (unsigned long long)(0xFFFFFFFFFFFFFFFF);


    /* Number of block is te same as the number of line masks in the memory */
    pxNfeeL->xMemMap.xCommon.usiNTotalBlocks = ulMaskMemLinesL;
8111dd38:	e0bfff17 	ldw	r2,-4(fp)
8111dd3c:	e0fff717 	ldw	r3,-36(fp)
8111dd40:	10c00415 	stw	r3,16(r2)

    /* Set the addr for every CCD of the FEE, left and right sides */
    ulLastOffset = pxNfeeL->xMemMap.ulOffsetRoot + RESERVED_FEE_X + RESERVED_HALF_CCD_X;
8111dd44:	e0bfff17 	ldw	r2,-4(fp)
8111dd48:	10c00117 	ldw	r3,4(r2)
8111dd4c:	008004b4 	movhi	r2,18
8111dd50:	10a40004 	addi	r2,r2,-28672
8111dd54:	1885883a 	add	r2,r3,r2
8111dd58:	e0bff915 	stw	r2,-28(fp)
    ulStepHalfCCD = RESERVED_HALF_CCD_X + pxNfeeL->xMemMap.xCommon.usiTotalBytes;
8111dd5c:	e0bfff17 	ldw	r2,-4(fp)
8111dd60:	10c00517 	ldw	r3,20(r2)
8111dd64:	008000b4 	movhi	r2,2
8111dd68:	10a40004 	addi	r2,r2,-28672
8111dd6c:	1885883a 	add	r2,r3,r2
8111dd70:	e0bffe15 	stw	r2,-8(fp)
    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8111dd74:	e03ff845 	stb	zero,-31(fp)
8111dd78:	00001906 	br	8111dde0 <vUpdateMemMapFEE+0x320>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulOffsetAddr = ulLastOffset;
8111dd7c:	e0bff843 	ldbu	r2,-31(fp)
8111dd80:	e0ffff17 	ldw	r3,-4(fp)
8111dd84:	10800624 	muli	r2,r2,24
8111dd88:	1885883a 	add	r2,r3,r2
8111dd8c:	10800904 	addi	r2,r2,36
8111dd90:	e0fff917 	ldw	r3,-28(fp)
8111dd94:	10c00015 	stw	r3,0(r2)
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
8111dd98:	e0fff917 	ldw	r3,-28(fp)
8111dd9c:	e0bffe17 	ldw	r2,-8(fp)
8111dda0:	1885883a 	add	r2,r3,r2
8111dda4:	e0bff915 	stw	r2,-28(fp)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulOffsetAddr = ulLastOffset; 
8111dda8:	e0bff843 	ldbu	r2,-31(fp)
8111ddac:	e0ffff17 	ldw	r3,-4(fp)
8111ddb0:	10800624 	muli	r2,r2,24
8111ddb4:	1885883a 	add	r2,r3,r2
8111ddb8:	10800c04 	addi	r2,r2,48
8111ddbc:	e0fff917 	ldw	r3,-28(fp)
8111ddc0:	10c00015 	stw	r3,0(r2)
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
8111ddc4:	e0fff917 	ldw	r3,-28(fp)
8111ddc8:	e0bffe17 	ldw	r2,-8(fp)
8111ddcc:	1885883a 	add	r2,r3,r2
8111ddd0:	e0bff915 	stw	r2,-28(fp)
    pxNfeeL->xMemMap.xCommon.usiNTotalBlocks = ulMaskMemLinesL;

    /* Set the addr for every CCD of the FEE, left and right sides */
    ulLastOffset = pxNfeeL->xMemMap.ulOffsetRoot + RESERVED_FEE_X + RESERVED_HALF_CCD_X;
    ulStepHalfCCD = RESERVED_HALF_CCD_X + pxNfeeL->xMemMap.xCommon.usiTotalBytes;
    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8111ddd4:	e0bff843 	ldbu	r2,-31(fp)
8111ddd8:	10800044 	addi	r2,r2,1
8111dddc:	e0bff845 	stb	r2,-31(fp)
8111dde0:	e0bff843 	ldbu	r2,-31(fp)
8111dde4:	10800130 	cmpltui	r2,r2,4
8111dde8:	103fe41e 	bne	r2,zero,8111dd7c <__reset+0xfb0fdd7c>
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulOffsetAddr = ulLastOffset; 
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
    }

}
8111ddec:	0001883a 	nop
8111ddf0:	e037883a 	mov	sp,fp
8111ddf4:	df000017 	ldw	fp,0(sp)
8111ddf8:	dec00104 	addi	sp,sp,4
8111ddfc:	f800283a 	ret

8111de00 <vResetMemCCDFEE>:

/* Update the memory mapping for the FEE due to the CCD informations */
void vResetMemCCDFEE( TNFee *pxNfeeL ) {
8111de00:	defffd04 	addi	sp,sp,-12
8111de04:	de00012e 	bgeu	sp,et,8111de0c <vResetMemCCDFEE+0xc>
8111de08:	003b68fa 	trap	3
8111de0c:	df000215 	stw	fp,8(sp)
8111de10:	df000204 	addi	fp,sp,8
8111de14:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucIL = 0;
8111de18:	e03ffe05 	stb	zero,-8(fp)

    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8111de1c:	e03ffe05 	stb	zero,-8(fp)
8111de20:	00001b06 	br	8111de90 <vResetMemCCDFEE+0x90>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulAddrI = 0;
8111de24:	e0bffe03 	ldbu	r2,-8(fp)
8111de28:	e0ffff17 	ldw	r3,-4(fp)
8111de2c:	10800624 	muli	r2,r2,24
8111de30:	1885883a 	add	r2,r3,r2
8111de34:	10800b04 	addi	r2,r2,44
8111de38:	10000015 	stw	zero,0(r2)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulBlockI = 0;
8111de3c:	e0bffe03 	ldbu	r2,-8(fp)
8111de40:	e0ffff17 	ldw	r3,-4(fp)
8111de44:	10800624 	muli	r2,r2,24
8111de48:	1885883a 	add	r2,r3,r2
8111de4c:	10800a04 	addi	r2,r2,40
8111de50:	10000015 	stw	zero,0(r2)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulAddrI = 0;
8111de54:	e0bffe03 	ldbu	r2,-8(fp)
8111de58:	e0ffff17 	ldw	r3,-4(fp)
8111de5c:	10800624 	muli	r2,r2,24
8111de60:	1885883a 	add	r2,r3,r2
8111de64:	10800e04 	addi	r2,r2,56
8111de68:	10000015 	stw	zero,0(r2)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulBlockI = 0;
8111de6c:	e0bffe03 	ldbu	r2,-8(fp)
8111de70:	e0ffff17 	ldw	r3,-4(fp)
8111de74:	10800624 	muli	r2,r2,24
8111de78:	1885883a 	add	r2,r3,r2
8111de7c:	10800d04 	addi	r2,r2,52
8111de80:	10000015 	stw	zero,0(r2)

/* Update the memory mapping for the FEE due to the CCD informations */
void vResetMemCCDFEE( TNFee *pxNfeeL ) {
	unsigned char ucIL = 0;

    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8111de84:	e0bffe03 	ldbu	r2,-8(fp)
8111de88:	10800044 	addi	r2,r2,1
8111de8c:	e0bffe05 	stb	r2,-8(fp)
8111de90:	e0bffe03 	ldbu	r2,-8(fp)
8111de94:	10800130 	cmpltui	r2,r2,4
8111de98:	103fe21e 	bne	r2,zero,8111de24 <__reset+0xfb0fde24>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulAddrI = 0;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulBlockI = 0;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulAddrI = 0;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulBlockI = 0;
    }
}
8111de9c:	0001883a 	nop
8111dea0:	e037883a 	mov	sp,fp
8111dea4:	df000017 	ldw	fp,0(sp)
8111dea8:	dec00104 	addi	sp,sp,4
8111deac:	f800283a 	ret

8111deb0 <vFeeSpwRMAPLoadDefault>:



/* Load the default configuration of the SPW/RMAP */
void vFeeSpwRMAPLoadDefault( TNFee *pxNfeeL ) {
8111deb0:	defffe04 	addi	sp,sp,-8
8111deb4:	de00012e 	bgeu	sp,et,8111debc <vFeeSpwRMAPLoadDefault+0xc>
8111deb8:	003b68fa 	trap	3
8111debc:	df000115 	stw	fp,4(sp)
8111dec0:	df000104 	addi	fp,sp,4
8111dec4:	e13fff15 	stw	r4,-4(fp)
    //bGetSpwRmapSDCard();
    //todo: For now is hardcoded
    //todo: Verificar qual a estrutura usar para as configuraes
}
8111dec8:	0001883a 	nop
8111decc:	e037883a 	mov	sp,fp
8111ded0:	df000017 	ldw	fp,0(sp)
8111ded4:	dec00104 	addi	sp,sp,4
8111ded8:	f800283a 	ret

8111dedc <vFeeSpwRMAPChangeConfig>:

/* Only in NFEE_CONFIG */
/* Change the active configuration of the SPW/RMAP */
void vFeeSpwRMAPChangeConfig( TNFee *pxNfeeL ) {
8111dedc:	defffe04 	addi	sp,sp,-8
8111dee0:	de00012e 	bgeu	sp,et,8111dee8 <vFeeSpwRMAPChangeConfig+0xc>
8111dee4:	003b68fa 	trap	3
8111dee8:	df000115 	stw	fp,4(sp)
8111deec:	df000104 	addi	fp,sp,4
8111def0:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar qual a estrutura usar para as configuraes
}
8111def4:	0001883a 	nop
8111def8:	e037883a 	mov	sp,fp
8111defc:	df000017 	ldw	fp,0(sp)
8111df00:	dec00104 	addi	sp,sp,4
8111df04:	f800283a 	ret

8111df08 <vFeeSpwRMAPChangeDefault>:

/* Only in NFEE_CONFIG */
/* Change the default configuration of the SPW/RMAP */
void vFeeSpwRMAPChangeDefault( TNFee *pxNfeeL ) {
8111df08:	defffe04 	addi	sp,sp,-8
8111df0c:	de00012e 	bgeu	sp,et,8111df14 <vFeeSpwRMAPChangeDefault+0xc>
8111df10:	003b68fa 	trap	3
8111df14:	df000115 	stw	fp,4(sp)
8111df18:	df000104 	addi	fp,sp,4
8111df1c:	e13fff15 	stw	r4,-4(fp)
    //bSaveSpwRmapSDCard();
    //todo: Verificar qual a estrutura usar para as configuraes, enviar o numero do FEE tbm
}
8111df20:	0001883a 	nop
8111df24:	e037883a 	mov	sp,fp
8111df28:	df000017 	ldw	fp,0(sp)
8111df2c:	dec00104 	addi	sp,sp,4
8111df30:	f800283a 	ret

8111df34 <cFeeSpwChannelEnable>:

/* Any mode */
/* Enable SPW channel for the FEE */
void cFeeSpwChannelEnable( TNFee *pxNfeeL ) {
8111df34:	defffe04 	addi	sp,sp,-8
8111df38:	de00012e 	bgeu	sp,et,8111df40 <cFeeSpwChannelEnable+0xc>
8111df3c:	003b68fa 	trap	3
8111df40:	df000115 	stw	fp,4(sp)
8111df44:	df000104 	addi	fp,sp,4
8111df48:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar com o Frana
}
8111df4c:	0001883a 	nop
8111df50:	e037883a 	mov	sp,fp
8111df54:	df000017 	ldw	fp,0(sp)
8111df58:	dec00104 	addi	sp,sp,4
8111df5c:	f800283a 	ret

8111df60 <cFeeSpwChannelDisable>:

/* Any mode */
/* Disable SPW channel for the FEE */
void cFeeSpwChannelDisable( TNFee *pxNfeeL ) {
8111df60:	defffe04 	addi	sp,sp,-8
8111df64:	de00012e 	bgeu	sp,et,8111df6c <cFeeSpwChannelDisable+0xc>
8111df68:	003b68fa 	trap	3
8111df6c:	df000115 	stw	fp,4(sp)
8111df70:	df000104 	addi	fp,sp,4
8111df74:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar com o Frana
}
8111df78:	0001883a 	nop
8111df7c:	e037883a 	mov	sp,fp
8111df80:	df000017 	ldw	fp,0(sp)
8111df84:	dec00104 	addi	sp,sp,4
8111df88:	f800283a 	ret

8111df8c <cFeeRMAPDump>:

/* Any mode */
/* Dump and send using PUS the RMAP Configuration areas [NFEESIM-UR-699] */
void cFeeRMAPDump( TNFee *pxNfeeL ) {
8111df8c:	defffe04 	addi	sp,sp,-8
8111df90:	de00012e 	bgeu	sp,et,8111df98 <cFeeRMAPDump+0xc>
8111df94:	003b68fa 	trap	3
8111df98:	df000115 	stw	fp,4(sp)
8111df9c:	df000104 	addi	fp,sp,4
8111dfa0:	e13fff15 	stw	r4,-4(fp)

    //todo: ler as areas de memoria do RMAP e enviar via ethernet

}
8111dfa4:	0001883a 	nop
8111dfa8:	e037883a 	mov	sp,fp
8111dfac:	df000017 	ldw	fp,0(sp)
8111dfb0:	dec00104 	addi	sp,sp,4
8111dfb4:	f800283a 	ret

8111dfb8 <cFeeRMAPEchoingEnable>:

/* Any mode */
/* Allow the user to activate the echo mode for RMAP [NFEESIM-UR-588]  */
void cFeeRMAPEchoingEnable( TNFee *pxNfeeL ) {
8111dfb8:	defffe04 	addi	sp,sp,-8
8111dfbc:	de00012e 	bgeu	sp,et,8111dfc4 <cFeeRMAPEchoingEnable+0xc>
8111dfc0:	003b68fa 	trap	3
8111dfc4:	df000115 	stw	fp,4(sp)
8111dfc8:	df000104 	addi	fp,sp,4
8111dfcc:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bEchoing = TRUE;
8111dfd0:	e0bfff17 	ldw	r2,-4(fp)
8111dfd4:	00c00044 	movi	r3,1
8111dfd8:	10c02515 	stw	r3,148(r2)
}
8111dfdc:	0001883a 	nop
8111dfe0:	e037883a 	mov	sp,fp
8111dfe4:	df000017 	ldw	fp,0(sp)
8111dfe8:	dec00104 	addi	sp,sp,4
8111dfec:	f800283a 	ret

8111dff0 <cFeeRMAPEchoingDisable>:

/* Any mode */
/* Allow the user to disable the echo mode for RMAP [NFEESIM-UR-589]  */
void cFeeRMAPEchoingDisable( TNFee *pxNfeeL ) {
8111dff0:	defffe04 	addi	sp,sp,-8
8111dff4:	de00012e 	bgeu	sp,et,8111dffc <cFeeRMAPEchoingDisable+0xc>
8111dff8:	003b68fa 	trap	3
8111dffc:	df000115 	stw	fp,4(sp)
8111e000:	df000104 	addi	fp,sp,4
8111e004:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bEchoing = FALSE;
8111e008:	e0bfff17 	ldw	r2,-4(fp)
8111e00c:	10002515 	stw	zero,148(r2)
}
8111e010:	0001883a 	nop
8111e014:	e037883a 	mov	sp,fp
8111e018:	df000017 	ldw	fp,0(sp)
8111e01c:	dec00104 	addi	sp,sp,4
8111e020:	f800283a 	ret

8111e024 <cFeeRMAPLogEnable>:

/* Any mode */
/* Allow the user to activate the log of RMAP [NFEESIM-UR-588]  */
void cFeeRMAPLogEnable( TNFee *pxNfeeL ) {
8111e024:	defffe04 	addi	sp,sp,-8
8111e028:	de00012e 	bgeu	sp,et,8111e030 <cFeeRMAPLogEnable+0xc>
8111e02c:	003b68fa 	trap	3
8111e030:	df000115 	stw	fp,4(sp)
8111e034:	df000104 	addi	fp,sp,4
8111e038:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bLogging = TRUE;
8111e03c:	e0bfff17 	ldw	r2,-4(fp)
8111e040:	00c00044 	movi	r3,1
8111e044:	10c02415 	stw	r3,144(r2)
}
8111e048:	0001883a 	nop
8111e04c:	e037883a 	mov	sp,fp
8111e050:	df000017 	ldw	fp,0(sp)
8111e054:	dec00104 	addi	sp,sp,4
8111e058:	f800283a 	ret

8111e05c <cFeeRMAPLogDisable>:

/* Any mode */
/* Allow the user to disable the log of RMAP [NFEESIM-UR-589]  */
void cFeeRMAPLogDisable( TNFee *pxNfeeL ) {
8111e05c:	defffe04 	addi	sp,sp,-8
8111e060:	de00012e 	bgeu	sp,et,8111e068 <cFeeRMAPLogDisable+0xc>
8111e064:	003b68fa 	trap	3
8111e068:	df000115 	stw	fp,4(sp)
8111e06c:	df000104 	addi	fp,sp,4
8111e070:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bLogging = FALSE;
8111e074:	e0bfff17 	ldw	r2,-4(fp)
8111e078:	10002415 	stw	zero,144(r2)
}
8111e07c:	0001883a 	nop
8111e080:	e037883a 	mov	sp,fp
8111e084:	df000017 	ldw	fp,0(sp)
8111e088:	dec00104 	addi	sp,sp,4
8111e08c:	f800283a 	ret

8111e090 <vNFeeControlInit>:
 */


#include "fee_controller.h"

void vNFeeControlInit( TNFee_Control *xFeeControlL ) {
8111e090:	defffc04 	addi	sp,sp,-16
8111e094:	de00012e 	bgeu	sp,et,8111e09c <vNFeeControlInit+0xc>
8111e098:	003b68fa 	trap	3
8111e09c:	dfc00315 	stw	ra,12(sp)
8111e0a0:	df000215 	stw	fp,8(sp)
8111e0a4:	df000204 	addi	fp,sp,8
8111e0a8:	e13fff15 	stw	r4,-4(fp)
    unsigned char ucIL = 0;
8111e0ac:	e03ffe05 	stb	zero,-8(fp)
    
    /* Reset TimeCode */
    vResetTimeCode( xFeeControlL );
8111e0b0:	e13fff17 	ldw	r4,-4(fp)
8111e0b4:	111e1dc0 	call	8111e1dc <vResetTimeCode>
    /* Load Default Id for NFEE master */
    vLoadDefaultIdNFEEMaster( xFeeControlL );
8111e0b8:	e13fff17 	ldw	r4,-4(fp)
8111e0bc:	111e2100 	call	8111e210 <vLoadDefaultIdNFEEMaster>

    xFeeControlL->sMode = sMebInit;
8111e0c0:	e0bfff17 	ldw	r2,-4(fp)
8111e0c4:	10009a15 	stw	zero,616(r2)

    /* Calculate the */
    for ( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ) {
8111e0c8:	e03ffe05 	stb	zero,-8(fp)
8111e0cc:	00002b06 	br	8111e17c <vNFeeControlInit+0xec>
        vNFeeStructureInit( &xFeeControlL->xNfee[ ucIL ], ucIL);
8111e0d0:	e0bffe03 	ldbu	r2,-8(fp)
8111e0d4:	10809624 	muli	r2,r2,600
8111e0d8:	e0ffff17 	ldw	r3,-4(fp)
8111e0dc:	1885883a 	add	r2,r3,r2
8111e0e0:	e0fffe03 	ldbu	r3,-8(fp)
8111e0e4:	180b883a 	mov	r5,r3
8111e0e8:	1009883a 	mov	r4,r2
8111e0ec:	111d8840 	call	8111d884 <vNFeeStructureInit>
        xFeeControlL->pbEnabledNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bEnabled;
8111e0f0:	e0bffe03 	ldbu	r2,-8(fp)
8111e0f4:	e0fffe03 	ldbu	r3,-8(fp)
8111e0f8:	18c09624 	muli	r3,r3,600
8111e0fc:	18c02104 	addi	r3,r3,132
8111e100:	e13fff17 	ldw	r4,-4(fp)
8111e104:	20c7883a 	add	r3,r4,r3
8111e108:	e13fff17 	ldw	r4,-4(fp)
8111e10c:	108025c4 	addi	r2,r2,151
8111e110:	1085883a 	add	r2,r2,r2
8111e114:	1085883a 	add	r2,r2,r2
8111e118:	2085883a 	add	r2,r4,r2
8111e11c:	10c00015 	stw	r3,0(r2)
        xFeeControlL->pbSimulatingNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bSimulating;
8111e120:	e0bffe03 	ldbu	r2,-8(fp)
8111e124:	e0fffe03 	ldbu	r3,-8(fp)
8111e128:	18c09624 	muli	r3,r3,600
8111e12c:	18c02704 	addi	r3,r3,156
8111e130:	e13fff17 	ldw	r4,-4(fp)
8111e134:	20c7883a 	add	r3,r4,r3
8111e138:	e13fff17 	ldw	r4,-4(fp)
8111e13c:	10802604 	addi	r2,r2,152
8111e140:	1085883a 	add	r2,r2,r2
8111e144:	1085883a 	add	r2,r2,r2
8111e148:	2085883a 	add	r2,r4,r2
8111e14c:	10c00015 	stw	r3,0(r2)
        xFeeControlL->xNfee[ ucIL ].xControl.pActualMem = xFeeControlL->pActualMem;
8111e150:	e0bffe03 	ldbu	r2,-8(fp)
8111e154:	e0ffff17 	ldw	r3,-4(fp)
8111e158:	18c09617 	ldw	r3,600(r3)
8111e15c:	e13fff17 	ldw	r4,-4(fp)
8111e160:	10809624 	muli	r2,r2,600
8111e164:	2085883a 	add	r2,r4,r2
8111e168:	10802904 	addi	r2,r2,164
8111e16c:	10c00015 	stw	r3,0(r2)
    vLoadDefaultIdNFEEMaster( xFeeControlL );

    xFeeControlL->sMode = sMebInit;

    /* Calculate the */
    for ( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ) {
8111e170:	e0bffe03 	ldbu	r2,-8(fp)
8111e174:	10800044 	addi	r2,r2,1
8111e178:	e0bffe05 	stb	r2,-8(fp)
8111e17c:	e0bffe03 	ldbu	r2,-8(fp)
8111e180:	103fd326 	beq	r2,zero,8111e0d0 <__reset+0xfb0fe0d0>
        xFeeControlL->pbEnabledNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bEnabled;
        xFeeControlL->pbSimulatingNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bSimulating;
        xFeeControlL->xNfee[ ucIL ].xControl.pActualMem = xFeeControlL->pActualMem;
    }

}
8111e184:	0001883a 	nop
8111e188:	e037883a 	mov	sp,fp
8111e18c:	dfc00117 	ldw	ra,4(sp)
8111e190:	df000017 	ldw	fp,0(sp)
8111e194:	dec00204 	addi	sp,sp,8
8111e198:	f800283a 	ret

8111e19c <vSetTimeCode>:

/* Any mode */
/* Set the time code of the Simucam */
void vSetTimeCode( TNFee_Control *xFeeControlL, unsigned char ucTime ) {
8111e19c:	defffd04 	addi	sp,sp,-12
8111e1a0:	de00012e 	bgeu	sp,et,8111e1a8 <vSetTimeCode+0xc>
8111e1a4:	003b68fa 	trap	3
8111e1a8:	df000215 	stw	fp,8(sp)
8111e1ac:	df000204 	addi	fp,sp,8
8111e1b0:	e13ffe15 	stw	r4,-8(fp)
8111e1b4:	2805883a 	mov	r2,r5
8111e1b8:	e0bfff05 	stb	r2,-4(fp)
    xFeeControlL->ucTimeCode = ucTime;
8111e1bc:	e0bffe17 	ldw	r2,-8(fp)
8111e1c0:	e0ffff03 	ldbu	r3,-4(fp)
8111e1c4:	10c09905 	stb	r3,612(r2)
}
8111e1c8:	0001883a 	nop
8111e1cc:	e037883a 	mov	sp,fp
8111e1d0:	df000017 	ldw	fp,0(sp)
8111e1d4:	dec00104 	addi	sp,sp,4
8111e1d8:	f800283a 	ret

8111e1dc <vResetTimeCode>:

/* Reset the time code of the Simucam */
void vResetTimeCode( TNFee_Control *xFeeControlL ) {
8111e1dc:	defffe04 	addi	sp,sp,-8
8111e1e0:	de00012e 	bgeu	sp,et,8111e1e8 <vResetTimeCode+0xc>
8111e1e4:	003b68fa 	trap	3
8111e1e8:	df000115 	stw	fp,4(sp)
8111e1ec:	df000104 	addi	fp,sp,4
8111e1f0:	e13fff15 	stw	r4,-4(fp)
    xFeeControlL->ucTimeCode = 0;
8111e1f4:	e0bfff17 	ldw	r2,-4(fp)
8111e1f8:	10009905 	stb	zero,612(r2)
}
8111e1fc:	0001883a 	nop
8111e200:	e037883a 	mov	sp,fp
8111e204:	df000017 	ldw	fp,0(sp)
8111e208:	dec00104 	addi	sp,sp,4
8111e20c:	f800283a 	ret

8111e210 <vLoadDefaultIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Load Default Config for IdNFEEMaster */
void vLoadDefaultIdNFEEMaster( TNFee_Control *xFeeControlL ) {
8111e210:	defffe04 	addi	sp,sp,-8
8111e214:	de00012e 	bgeu	sp,et,8111e21c <vLoadDefaultIdNFEEMaster+0xc>
8111e218:	003b68fa 	trap	3
8111e21c:	df000115 	stw	fp,4(sp)
8111e220:	df000104 	addi	fp,sp,4
8111e224:	e13fff15 	stw	r4,-4(fp)
    //bGetIdNFEEMasterSDCard();
    //todo: For now is hardcoded
    xFeeControlL->ucIdNFEEMaster = 0;
8111e228:	e0bfff17 	ldw	r2,-4(fp)
8111e22c:	10009945 	stb	zero,613(r2)
}
8111e230:	0001883a 	nop
8111e234:	e037883a 	mov	sp,fp
8111e238:	df000017 	ldw	fp,0(sp)
8111e23c:	dec00104 	addi	sp,sp,4
8111e240:	f800283a 	ret

8111e244 <vChangeIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Change the Config for IdNFEEMaster*/
void vChangeIdNFEEMaster( TNFee_Control *xFeeControlL, unsigned char ucIdMaster ) {
8111e244:	defffd04 	addi	sp,sp,-12
8111e248:	de00012e 	bgeu	sp,et,8111e250 <vChangeIdNFEEMaster+0xc>
8111e24c:	003b68fa 	trap	3
8111e250:	df000215 	stw	fp,8(sp)
8111e254:	df000204 	addi	fp,sp,8
8111e258:	e13ffe15 	stw	r4,-8(fp)
8111e25c:	2805883a 	mov	r2,r5
8111e260:	e0bfff05 	stb	r2,-4(fp)
    xFeeControlL->ucIdNFEEMaster = ucIdMaster;
8111e264:	e0bffe17 	ldw	r2,-8(fp)
8111e268:	e0ffff03 	ldbu	r3,-4(fp)
8111e26c:	10c09945 	stb	r3,613(r2)
}
8111e270:	0001883a 	nop
8111e274:	e037883a 	mov	sp,fp
8111e278:	df000017 	ldw	fp,0(sp)
8111e27c:	dec00104 	addi	sp,sp,4
8111e280:	f800283a 	ret

8111e284 <vChangeDefaultIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Change the Default Config for IdNFEEMaster */
void vChangeDefaultIdNFEEMaster( TNFee_Control *xFeeControlL, unsigned char ucIdMaster ) {
8111e284:	defffd04 	addi	sp,sp,-12
8111e288:	de00012e 	bgeu	sp,et,8111e290 <vChangeDefaultIdNFEEMaster+0xc>
8111e28c:	003b68fa 	trap	3
8111e290:	df000215 	stw	fp,8(sp)
8111e294:	df000204 	addi	fp,sp,8
8111e298:	e13ffe15 	stw	r4,-8(fp)
8111e29c:	2805883a 	mov	r2,r5
8111e2a0:	e0bfff05 	stb	r2,-4(fp)
    //bSaveIdNFEEMasterSDCard(ucIdMaster);
}
8111e2a4:	0001883a 	nop
8111e2a8:	e037883a 	mov	sp,fp
8111e2ac:	df000017 	ldw	fp,0(sp)
8111e2b0:	dec00104 	addi	sp,sp,4
8111e2b4:	f800283a 	ret

8111e2b8 <vInitSimucamBasicHW>:

#include "initialization_simucam.h"


void vInitSimucamBasicHW(void)
{
8111e2b8:	defffe04 	addi	sp,sp,-8
8111e2bc:	de00012e 	bgeu	sp,et,8111e2c4 <vInitSimucamBasicHW+0xc>
8111e2c0:	003b68fa 	trap	3
8111e2c4:	dfc00115 	stw	ra,4(sp)
8111e2c8:	df000015 	stw	fp,0(sp)
8111e2cc:	d839883a 	mov	fp,sp

	/* Turn Off all LEDs */
	bSetBoardLeds(LEDS_OFF, LEDS_BOARD_ALL_MASK);
8111e2d0:	01403fc4 	movi	r5,255
8111e2d4:	0009883a 	mov	r4,zero
8111e2d8:	110b43c0 	call	8110b43c <bSetBoardLeds>
	bSetPainelLeds(LEDS_OFF, LEDS_PAINEL_ALL_MASK);
8111e2dc:	01400834 	movhi	r5,32
8111e2e0:	297fffc4 	addi	r5,r5,-1
8111e2e4:	0009883a 	mov	r4,zero
8111e2e8:	110b4bc0 	call	8110b4bc <bSetPainelLeds>

	/* Turn On Power LED */
	bSetPainelLeds(LEDS_ON, LEDS_POWER_MASK);
8111e2ec:	01400074 	movhi	r5,1
8111e2f0:	01000044 	movi	r4,1
8111e2f4:	110b4bc0 	call	8110b4bc <bSetPainelLeds>

	/* Configure Seven Segments Display */
	bSSDisplayConfig(SSDP_NORMAL_MODE);
8111e2f8:	0009883a 	mov	r4,zero
8111e2fc:	110c9440 	call	8110c944 <bSSDisplayConfig>
	bSSDisplayUpdate(0);
8111e300:	0009883a 	mov	r4,zero
8111e304:	110ca140 	call	8110ca14 <bSSDisplayUpdate>

	vRstcHoldDeviceReset(RSTC_DEV_RS232_RST_CTRL_MSK);
8111e308:	01008004 	movi	r4,512
8111e30c:	110c4a40 	call	8110c4a4 <vRstcHoldDeviceReset>
	vRstcReleaseDeviceReset(RSTC_DEV_RS232_RST_CTRL_MSK);
8111e310:	01008004 	movi	r4,512
8111e314:	110c4300 	call	8110c430 <vRstcReleaseDeviceReset>

}
8111e318:	0001883a 	nop
8111e31c:	e037883a 	mov	sp,fp
8111e320:	dfc00117 	ldw	ra,4(sp)
8111e324:	df000017 	ldw	fp,0(sp)
8111e328:	dec00204 	addi	sp,sp,8
8111e32c:	f800283a 	ret

8111e330 <bLogWriteSDCard>:

#include "log_manager_simucam.h"


bool bLogWriteSDCard ( const char * cDataIn, const char * cFilename )
{
8111e330:	defffd04 	addi	sp,sp,-12
8111e334:	de00012e 	bgeu	sp,et,8111e33c <bLogWriteSDCard+0xc>
8111e338:	003b68fa 	trap	3
8111e33c:	df000215 	stw	fp,8(sp)
8111e340:	df000204 	addi	fp,sp,8
8111e344:	e13ffe15 	stw	r4,-8(fp)
8111e348:	e17fff15 	stw	r5,-4(fp)

	return TRUE;
8111e34c:	00800044 	movi	r2,1
}
8111e350:	e037883a 	mov	sp,fp
8111e354:	df000017 	ldw	fp,0(sp)
8111e358:	dec00104 	addi	sp,sp,4
8111e35c:	f800283a 	ret

8111e360 <vLogWriteNUC>:

/* Prefer to use directly vSendLog, if there's any error use this function */
void vLogWriteNUC ( const char * cDataIn )
{
8111e360:	deffe004 	addi	sp,sp,-128
8111e364:	de00012e 	bgeu	sp,et,8111e36c <vLogWriteNUC+0xc>
8111e368:	003b68fa 	trap	3
8111e36c:	dfc01f15 	stw	ra,124(sp)
8111e370:	df001e15 	stw	fp,120(sp)
8111e374:	df001e04 	addi	fp,sp,120
8111e378:	e13fff15 	stw	r4,-4(fp)
	char cTemp[114] = "";
8111e37c:	e03fe215 	stw	zero,-120(fp)
8111e380:	e0bfe304 	addi	r2,fp,-116
8111e384:	00c01b84 	movi	r3,110
8111e388:	180d883a 	mov	r6,r3
8111e38c:	000b883a 	mov	r5,zero
8111e390:	1009883a 	mov	r4,r2
8111e394:	11227e00 	call	811227e0 <memset>
	memset(cTemp,0,114);
8111e398:	01801c84 	movi	r6,114
8111e39c:	000b883a 	mov	r5,zero
8111e3a0:	e13fe204 	addi	r4,fp,-120
8111e3a4:	11227e00 	call	811227e0 <memset>
	memcpy(cTemp,cDataIn, min_sim( strlen(cDataIn), 113 ) ); /* 113 to let a zero terminator in the worst case (truc the message) */
8111e3a8:	e13fff17 	ldw	r4,-4(fp)
8111e3ac:	11231840 	call	81123184 <strlen>
8111e3b0:	10801c68 	cmpgeui	r2,r2,113
8111e3b4:	1000031e 	bne	r2,zero,8111e3c4 <vLogWriteNUC+0x64>
8111e3b8:	e13fff17 	ldw	r4,-4(fp)
8111e3bc:	11231840 	call	81123184 <strlen>
8111e3c0:	00000106 	br	8111e3c8 <vLogWriteNUC+0x68>
8111e3c4:	00801c44 	movi	r2,113
8111e3c8:	100d883a 	mov	r6,r2
8111e3cc:	e17fff17 	ldw	r5,-4(fp)
8111e3d0:	e13fe204 	addi	r4,fp,-120
8111e3d4:	11226900 	call	81122690 <memcpy>
	vSendLog ( cDataIn );
8111e3d8:	e13fff17 	ldw	r4,-4(fp)
8111e3dc:	11193dc0 	call	811193dc <vSendLog>
}
8111e3e0:	0001883a 	nop
8111e3e4:	e037883a 	mov	sp,fp
8111e3e8:	dfc00117 	ldw	ra,4(sp)
8111e3ec:	df000017 	ldw	fp,0(sp)
8111e3f0:	dec00204 	addi	sp,sp,8
8111e3f4:	f800283a 	ret

8111e3f8 <vSimucamStructureInit>:
 */


#include "meb.h"

void vSimucamStructureInit( TSimucam_MEB *xMeb ) {
8111e3f8:	defffd04 	addi	sp,sp,-12
8111e3fc:	de00012e 	bgeu	sp,et,8111e404 <vSimucamStructureInit+0xc>
8111e400:	003b68fa 	trap	3
8111e404:	dfc00215 	stw	ra,8(sp)
8111e408:	df000115 	stw	fp,4(sp)
8111e40c:	df000104 	addi	fp,sp,4
8111e410:	e13fff15 	stw	r4,-4(fp)
    // LoadTypeOfFeeSDCard();
    // todo: Load from SDCard for now is Hardcoded to Normal FEE
    xMeb->eType = sNormalFEE;
8111e414:	e0bfff17 	ldw	r2,-4(fp)
8111e418:	10000015 	stw	zero,0(r2)
    
    /* Simucam start in the Meb Config Mode */
    xMeb->eMode = sMebInit;
8111e41c:	e0bfff17 	ldw	r2,-4(fp)
8111e420:	10000115 	stw	zero,4(r2)

    /* Load EP */
    vLoadDefaultEPValue( xMeb );
8111e424:	e13fff17 	ldw	r4,-4(fp)
8111e428:	111e4e40 	call	8111e4e4 <vLoadDefaultEPValue>
    /* Load RT */
    vLoadDefaultRTValue( xMeb );
8111e42c:	e13fff17 	ldw	r4,-4(fp)
8111e430:	111e5880 	call	8111e588 <vLoadDefaultRTValue>
    /* Load SyncSource */
    vLoadDefaultSyncSource( xMeb );
8111e434:	e13fff17 	ldw	r4,-4(fp)
8111e438:	111e6300 	call	8111e630 <vLoadDefaultSyncSource>
    /* Load Default Config for Auto Reset Mode */
    vLoadDefaultAutoResetSync( xMeb );
8111e43c:	e13fff17 	ldw	r4,-4(fp)
8111e440:	111e6d00 	call	8111e6d0 <vLoadDefaultAutoResetSync>

    /* todo: Change for change functions */
    xMeb->fLineTransferTime = 0;
8111e444:	e0bfff17 	ldw	r2,-4(fp)
8111e448:	10000615 	stw	zero,24(r2)
    xMeb->fPixelTransferTime = 0;
8111e44c:	e0bfff17 	ldw	r2,-4(fp)
8111e450:	10000715 	stw	zero,28(r2)
    xMeb->usiDelaySyncReset = 500; /* milliseconds */
8111e454:	e0bfff17 	ldw	r2,-4(fp)
8111e458:	00c07d04 	movi	r3,500
8111e45c:	10c0050d 	sth	r3,20(r2)

    /* Reseting swap memory mechanism */
    xMeb->ucActualDDR = 0;
8111e460:	e0bfff17 	ldw	r2,-4(fp)
8111e464:	10000205 	stb	zero,8(r2)
    xMeb->ucNextDDR = 1;
8111e468:	e0bfff17 	ldw	r2,-4(fp)
8111e46c:	00c00044 	movi	r3,1
8111e470:	10c00245 	stb	r3,9(r2)

    xMeb->xFeeControl.pActualMem = &xMeb->ucActualDDR;
8111e474:	e0bfff17 	ldw	r2,-4(fp)
8111e478:	10c00204 	addi	r3,r2,8
8111e47c:	e0bfff17 	ldw	r2,-4(fp)
8111e480:	10c0a815 	stw	r3,672(r2)
    xMeb->xDataControl.pNextMem = &xMeb->ucNextDDR;
8111e484:	e0bfff17 	ldw	r2,-4(fp)
8111e488:	10c00244 	addi	r3,r2,9
8111e48c:	e0bfff17 	ldw	r2,-4(fp)
8111e490:	10c01115 	stw	r3,68(r2)

    /* Verify if if a Fast or Normal */
    if ( xMeb->eType == sNormalFEE ) {
8111e494:	e0bfff17 	ldw	r2,-4(fp)
8111e498:	10800017 	ldw	r2,0(r2)
8111e49c:	10000b1e 	bne	r2,zero,8111e4cc <vSimucamStructureInit+0xd4>
        /* Are Normal Fee instances */
    	vNFeeControlInit( &xMeb->xFeeControl );
8111e4a0:	e0bfff17 	ldw	r2,-4(fp)
8111e4a4:	10801204 	addi	r2,r2,72
8111e4a8:	1009883a 	mov	r4,r2
8111e4ac:	111e0900 	call	8111e090 <vNFeeControlInit>
        vDataControllerInit( &xMeb->xDataControl, &xMeb->xFeeControl );
8111e4b0:	e0bfff17 	ldw	r2,-4(fp)
8111e4b4:	10c00a04 	addi	r3,r2,40
8111e4b8:	e0bfff17 	ldw	r2,-4(fp)
8111e4bc:	10801204 	addi	r2,r2,72
8111e4c0:	100b883a 	mov	r5,r2
8111e4c4:	1809883a 	mov	r4,r3
8111e4c8:	111b77c0 	call	8111b77c <vDataControllerInit>


    /* At this point all structures that manage the aplication of Simucam and FEE are initialized, the tasks could start now */


}
8111e4cc:	0001883a 	nop
8111e4d0:	e037883a 	mov	sp,fp
8111e4d4:	dfc00117 	ldw	ra,4(sp)
8111e4d8:	df000017 	ldw	fp,0(sp)
8111e4dc:	dec00204 	addi	sp,sp,8
8111e4e0:	f800283a 	ret

8111e4e4 <vLoadDefaultEPValue>:

/* Only in MEB_CONFIG */
/* Load Default value of EP - Exposure period [NFEESIM-UR-447] */
void vLoadDefaultEPValue( TSimucam_MEB *xMeb ) {
8111e4e4:	defffe04 	addi	sp,sp,-8
8111e4e8:	de00012e 	bgeu	sp,et,8111e4f0 <vLoadDefaultEPValue+0xc>
8111e4ec:	003b68fa 	trap	3
8111e4f0:	df000115 	stw	fp,4(sp)
8111e4f4:	df000104 	addi	fp,sp,4
8111e4f8:	e13fff15 	stw	r4,-4(fp)
    //bGetEPSDCard();
    //todo: For now is hardcoded
    xMeb->ucEP = 25;
8111e4fc:	e0bfff17 	ldw	r2,-4(fp)
8111e500:	00d07234 	movhi	r3,16840
8111e504:	10c00315 	stw	r3,12(r2)
}
8111e508:	0001883a 	nop
8111e50c:	e037883a 	mov	sp,fp
8111e510:	df000017 	ldw	fp,0(sp)
8111e514:	dec00104 	addi	sp,sp,4
8111e518:	f800283a 	ret

8111e51c <vChangeEPValue>:

/* Only in MEB_CONFIG */
/* Change the active value of EP - Exposure period [NFEESIM-UR-447] */
void vChangeEPValue( TSimucam_MEB *xMeb, float ucValue ) {
8111e51c:	defffd04 	addi	sp,sp,-12
8111e520:	de00012e 	bgeu	sp,et,8111e528 <vChangeEPValue+0xc>
8111e524:	003b68fa 	trap	3
8111e528:	df000215 	stw	fp,8(sp)
8111e52c:	df000204 	addi	fp,sp,8
8111e530:	e13ffe15 	stw	r4,-8(fp)
8111e534:	e17fff15 	stw	r5,-4(fp)
    xMeb->ucEP = ucValue;
8111e538:	e0bffe17 	ldw	r2,-8(fp)
8111e53c:	e0ffff17 	ldw	r3,-4(fp)
8111e540:	10c00315 	stw	r3,12(r2)
}
8111e544:	0001883a 	nop
8111e548:	e037883a 	mov	sp,fp
8111e54c:	df000017 	ldw	fp,0(sp)
8111e550:	dec00104 	addi	sp,sp,4
8111e554:	f800283a 	ret

8111e558 <vChangeDefaultEPValue>:

/* Only in MEB_CONFIG */
/* Change the default value of EP - Exposure period [NFEESIM-UR-447] */
void vChangeDefaultEPValue( TSimucam_MEB *xMeb, float ucValue ) {
8111e558:	defffd04 	addi	sp,sp,-12
8111e55c:	de00012e 	bgeu	sp,et,8111e564 <vChangeDefaultEPValue+0xc>
8111e560:	003b68fa 	trap	3
8111e564:	df000215 	stw	fp,8(sp)
8111e568:	df000204 	addi	fp,sp,8
8111e56c:	e13ffe15 	stw	r4,-8(fp)
8111e570:	e17fff15 	stw	r5,-4(fp)
    //bSaveEPSDCard(ucValue);
}
8111e574:	0001883a 	nop
8111e578:	e037883a 	mov	sp,fp
8111e57c:	df000017 	ldw	fp,0(sp)
8111e580:	dec00104 	addi	sp,sp,4
8111e584:	f800283a 	ret

8111e588 <vLoadDefaultRTValue>:

/* Only in MEB_CONFIG */
/* Load Default value of EP - Exposure period [NFEESIM-UR-447] */
void vLoadDefaultRTValue( TSimucam_MEB *xMeb ) {
8111e588:	defffe04 	addi	sp,sp,-8
8111e58c:	de00012e 	bgeu	sp,et,8111e594 <vLoadDefaultRTValue+0xc>
8111e590:	003b68fa 	trap	3
8111e594:	df000115 	stw	fp,4(sp)
8111e598:	df000104 	addi	fp,sp,4
8111e59c:	e13fff15 	stw	r4,-4(fp)
    //bGetEPSDCard();
    //todo: For now is hardcoded
    xMeb->ucRT = 3.9;
8111e5a0:	e0ffff17 	ldw	r3,-4(fp)
8111e5a4:	00901eb4 	movhi	r2,16506
8111e5a8:	10a66684 	addi	r2,r2,-26214
8111e5ac:	18800415 	stw	r2,16(r3)
}
8111e5b0:	0001883a 	nop
8111e5b4:	e037883a 	mov	sp,fp
8111e5b8:	df000017 	ldw	fp,0(sp)
8111e5bc:	dec00104 	addi	sp,sp,4
8111e5c0:	f800283a 	ret

8111e5c4 <vChangeRTValue>:

/* Only in MEB_CONFIG */
/* Change the active value of RT - CCD readout time [NFEESIM-UR-447] */
void vChangeRTValue( TSimucam_MEB *xMeb, float ucValue ) {
8111e5c4:	defffd04 	addi	sp,sp,-12
8111e5c8:	de00012e 	bgeu	sp,et,8111e5d0 <vChangeRTValue+0xc>
8111e5cc:	003b68fa 	trap	3
8111e5d0:	df000215 	stw	fp,8(sp)
8111e5d4:	df000204 	addi	fp,sp,8
8111e5d8:	e13ffe15 	stw	r4,-8(fp)
8111e5dc:	e17fff15 	stw	r5,-4(fp)
    xMeb->ucRT = ucValue;
8111e5e0:	e0bffe17 	ldw	r2,-8(fp)
8111e5e4:	e0ffff17 	ldw	r3,-4(fp)
8111e5e8:	10c00415 	stw	r3,16(r2)
}
8111e5ec:	0001883a 	nop
8111e5f0:	e037883a 	mov	sp,fp
8111e5f4:	df000017 	ldw	fp,0(sp)
8111e5f8:	dec00104 	addi	sp,sp,4
8111e5fc:	f800283a 	ret

8111e600 <vChangeDefaultRTValue>:

/* Only in MEB_CONFIG */
/* Change the default value of RT - CCD readout time [NFEESIM-UR-447] */
void vChangeDefaultRTValue( TSimucam_MEB *xMeb, float ucValue ) {
8111e600:	defffd04 	addi	sp,sp,-12
8111e604:	de00012e 	bgeu	sp,et,8111e60c <vChangeDefaultRTValue+0xc>
8111e608:	003b68fa 	trap	3
8111e60c:	df000215 	stw	fp,8(sp)
8111e610:	df000204 	addi	fp,sp,8
8111e614:	e13ffe15 	stw	r4,-8(fp)
8111e618:	e17fff15 	stw	r5,-4(fp)
    //bSaveRTSDCard(ucValue);
}
8111e61c:	0001883a 	nop
8111e620:	e037883a 	mov	sp,fp
8111e624:	df000017 	ldw	fp,0(sp)
8111e628:	dec00104 	addi	sp,sp,4
8111e62c:	f800283a 	ret

8111e630 <vLoadDefaultSyncSource>:

/* Only in MEB_CONFIG */
/* Load Default Config Sync - Internal or external */
void vLoadDefaultSyncSource( TSimucam_MEB *xMeb ) {
8111e630:	defffe04 	addi	sp,sp,-8
8111e634:	de00012e 	bgeu	sp,et,8111e63c <vLoadDefaultSyncSource+0xc>
8111e638:	003b68fa 	trap	3
8111e63c:	df000115 	stw	fp,4(sp)
8111e640:	df000104 	addi	fp,sp,4
8111e644:	e13fff15 	stw	r4,-4(fp)
    //bGetSyncSourceSDCard();
    //todo: For now is hardcoded
    xMeb->eSync = sInternal;
8111e648:	e0bfff17 	ldw	r2,-4(fp)
8111e64c:	10000815 	stw	zero,32(r2)
}
8111e650:	0001883a 	nop
8111e654:	e037883a 	mov	sp,fp
8111e658:	df000017 	ldw	fp,0(sp)
8111e65c:	dec00104 	addi	sp,sp,4
8111e660:	f800283a 	ret

8111e664 <vChangeSyncSource>:

/* Only in MEB_CONFIG */
/* Change the Active Config Sync - Internal or external */
void vChangeSyncSource( TSimucam_MEB *xMeb, tSimucamSync eSource ) {
8111e664:	defffd04 	addi	sp,sp,-12
8111e668:	de00012e 	bgeu	sp,et,8111e670 <vChangeSyncSource+0xc>
8111e66c:	003b68fa 	trap	3
8111e670:	df000215 	stw	fp,8(sp)
8111e674:	df000204 	addi	fp,sp,8
8111e678:	e13ffe15 	stw	r4,-8(fp)
8111e67c:	e17fff15 	stw	r5,-4(fp)
    xMeb->eSync = eSource;
8111e680:	e0bffe17 	ldw	r2,-8(fp)
8111e684:	e0ffff17 	ldw	r3,-4(fp)
8111e688:	10c00815 	stw	r3,32(r2)
}
8111e68c:	0001883a 	nop
8111e690:	e037883a 	mov	sp,fp
8111e694:	df000017 	ldw	fp,0(sp)
8111e698:	dec00104 	addi	sp,sp,4
8111e69c:	f800283a 	ret

8111e6a0 <vChangeDefaultSyncSource>:

/* Only in MEB_CONFIG */
/* Change the Default Config Sync - Internal or external */
void vChangeDefaultSyncSource( TSimucam_MEB *xMeb, tSimucamSync eSource ) {
8111e6a0:	defffd04 	addi	sp,sp,-12
8111e6a4:	de00012e 	bgeu	sp,et,8111e6ac <vChangeDefaultSyncSource+0xc>
8111e6a8:	003b68fa 	trap	3
8111e6ac:	df000215 	stw	fp,8(sp)
8111e6b0:	df000204 	addi	fp,sp,8
8111e6b4:	e13ffe15 	stw	r4,-8(fp)
8111e6b8:	e17fff15 	stw	r5,-4(fp)
    //bSaveSyncSourceSDCard(eSource);
}
8111e6bc:	0001883a 	nop
8111e6c0:	e037883a 	mov	sp,fp
8111e6c4:	df000017 	ldw	fp,0(sp)
8111e6c8:	dec00104 	addi	sp,sp,4
8111e6cc:	f800283a 	ret

8111e6d0 <vLoadDefaultAutoResetSync>:


/* Only in MEB_CONFIG */
/* Load Default Config for AutoResetSync */
void vLoadDefaultAutoResetSync( TSimucam_MEB *xMeb ) {
8111e6d0:	defffe04 	addi	sp,sp,-8
8111e6d4:	de00012e 	bgeu	sp,et,8111e6dc <vLoadDefaultAutoResetSync+0xc>
8111e6d8:	003b68fa 	trap	3
8111e6dc:	df000115 	stw	fp,4(sp)
8111e6e0:	df000104 	addi	fp,sp,4
8111e6e4:	e13fff15 	stw	r4,-4(fp)
    //bGetAutoResetSyncSDCard();
    //todo: For now is hardcoded
    xMeb->bAutoResetSyncMode = TRUE;
8111e6e8:	e0bfff17 	ldw	r2,-4(fp)
8111e6ec:	00c00044 	movi	r3,1
8111e6f0:	10c00915 	stw	r3,36(r2)
}
8111e6f4:	0001883a 	nop
8111e6f8:	e037883a 	mov	sp,fp
8111e6fc:	df000017 	ldw	fp,0(sp)
8111e700:	dec00104 	addi	sp,sp,4
8111e704:	f800283a 	ret

8111e708 <vChangeAutoResetSync>:

/* Only in MEB_CONFIG */
/* Change the Config for AutoResetSync*/
void vChangeAutoResetSync( TSimucam_MEB *xMeb, bool bAutoReset ) {
8111e708:	defffd04 	addi	sp,sp,-12
8111e70c:	de00012e 	bgeu	sp,et,8111e714 <vChangeAutoResetSync+0xc>
8111e710:	003b68fa 	trap	3
8111e714:	df000215 	stw	fp,8(sp)
8111e718:	df000204 	addi	fp,sp,8
8111e71c:	e13ffe15 	stw	r4,-8(fp)
8111e720:	e17fff15 	stw	r5,-4(fp)
    xMeb->bAutoResetSyncMode = bAutoReset;
8111e724:	e0bffe17 	ldw	r2,-8(fp)
8111e728:	e0ffff17 	ldw	r3,-4(fp)
8111e72c:	10c00915 	stw	r3,36(r2)
}
8111e730:	0001883a 	nop
8111e734:	e037883a 	mov	sp,fp
8111e738:	df000017 	ldw	fp,0(sp)
8111e73c:	dec00104 	addi	sp,sp,4
8111e740:	f800283a 	ret

8111e744 <vChangeDefaultAutoResetSync>:

/* Only in MEB_CONFIG */
/* Change the Default Config for AutoResetSync */
void vChangeDefaultAutoResetSync( TSimucam_MEB *xMeb, bool bAutoReset ) {
8111e744:	defffd04 	addi	sp,sp,-12
8111e748:	de00012e 	bgeu	sp,et,8111e750 <vChangeDefaultAutoResetSync+0xc>
8111e74c:	003b68fa 	trap	3
8111e750:	df000215 	stw	fp,8(sp)
8111e754:	df000204 	addi	fp,sp,8
8111e758:	e13ffe15 	stw	r4,-8(fp)
8111e75c:	e17fff15 	stw	r5,-4(fp)
    //bSaveAutoResetSyncSDCard(bAutoReset);
}
8111e760:	0001883a 	nop
8111e764:	e037883a 	mov	sp,fp
8111e768:	df000017 	ldw	fp,0(sp)
8111e76c:	dec00104 	addi	sp,sp,4
8111e770:	f800283a 	ret

8111e774 <vSyncReset>:


/* Any mode */
/* Synchronization Reset */
void vSyncReset( TSimucam_MEB *xMeb, float ufSynchDelay ) {
8111e774:	defffc04 	addi	sp,sp,-16
8111e778:	de00012e 	bgeu	sp,et,8111e780 <vSyncReset+0xc>
8111e77c:	003b68fa 	trap	3
8111e780:	dfc00315 	stw	ra,12(sp)
8111e784:	df000215 	stw	fp,8(sp)
8111e788:	df000204 	addi	fp,sp,8
8111e78c:	e13ffe15 	stw	r4,-8(fp)
8111e790:	e17fff15 	stw	r5,-4(fp)
    // Stop all transmission

    // Put all NFEE in Stand-by mode, if not in Config mode

    // Reset the time code
    vResetTimeCode(&xMeb->xFeeControl);
8111e794:	e0bffe17 	ldw	r2,-8(fp)
8111e798:	10801204 	addi	r2,r2,72
8111e79c:	1009883a 	mov	r4,r2
8111e7a0:	111e1dc0 	call	8111e1dc <vResetTimeCode>

    // Release a synchronization signal

    // Start new cycle

}
8111e7a4:	0001883a 	nop
8111e7a8:	e037883a 	mov	sp,fp
8111e7ac:	dfc00117 	ldw	ra,4(sp)
8111e7b0:	df000017 	ldw	fp,0(sp)
8111e7b4:	dec00204 	addi	sp,sp,8
8111e7b8:	f800283a 	ret

8111e7bc <pattern_createPattern>:
#include "pattern.h"

alt_u32 pattern_createPattern(alt_u8 mem_number, alt_u32 mem_offset, alt_u8 ccd_number, alt_u8 ccd_side, alt_u32 width_cols, alt_u32 height_rows)
{
8111e7bc:	defff004 	addi	sp,sp,-64
8111e7c0:	de00012e 	bgeu	sp,et,8111e7c8 <pattern_createPattern+0xc>
8111e7c4:	003b68fa 	trap	3
8111e7c8:	dfc00f15 	stw	ra,60(sp)
8111e7cc:	df000e15 	stw	fp,56(sp)
8111e7d0:	dcc00d15 	stw	r19,52(sp)
8111e7d4:	dc800c15 	stw	r18,48(sp)
8111e7d8:	dc400b15 	stw	r17,44(sp)
8111e7dc:	dc000a15 	stw	r16,40(sp)
8111e7e0:	df000e04 	addi	fp,sp,56
8111e7e4:	e17ff915 	stw	r5,-28(fp)
8111e7e8:	3007883a 	mov	r3,r6
8111e7ec:	3805883a 	mov	r2,r7
8111e7f0:	e13ff805 	stb	r4,-32(fp)
8111e7f4:	e0fffa05 	stb	r3,-24(fp)
8111e7f8:	e0bffb05 	stb	r2,-20(fp)
	unsigned long long a0;
	unsigned long long a1;

	bDdr2SwitchMemory(mem_number); // Switch to the desired memory
8111e7fc:	e0bff803 	ldbu	r2,-32(fp)
8111e800:	1009883a 	mov	r4,r2
8111e804:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
	alt_u32 offset = mem_offset;
8111e808:	e0bff917 	ldw	r2,-28(fp)
8111e80c:	e0bff215 	stw	r2,-56(fp)
	alt_u8 i = 0;
8111e810:	e03ff305 	stb	zero,-52(fp)
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
8111e814:	e0bff217 	ldw	r2,-56(fp)
8111e818:	e0bff415 	stw	r2,-48(fp)
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
8111e81c:	e03ff515 	stw	zero,-44(fp)
8111e820:	00003606 	br	8111e8fc <pattern_createPattern+0x140>
	{
		for (alt_u32 col = 0; col < width_cols; col++) // column sweep
8111e824:	e03ff615 	stw	zero,-40(fp)
8111e828:	00002e06 	br	8111e8e4 <pattern_createPattern+0x128>
		{
			if (i == 64) // filled one block of memory, time to save full pattern and readress the structure
8111e82c:	e0bff303 	ldbu	r2,-52(fp)
8111e830:	10801018 	cmpnei	r2,r2,64
8111e834:	10000b1e 	bne	r2,zero,8111e864 <pattern_createPattern+0xa8>
			{
				pxPixelData->ulliMask = PATTERN_MEMORY_FULLMASK;
8111e838:	e0bff417 	ldw	r2,-48(fp)
8111e83c:	00ffffc4 	movi	r3,-1
8111e840:	10c02015 	stw	r3,128(r2)
8111e844:	00ffffc4 	movi	r3,-1
8111e848:	10c02115 	stw	r3,132(r2)
				offset += sizeof(TSdmaPixelDataBlock);
8111e84c:	e0bff217 	ldw	r2,-56(fp)
8111e850:	10802204 	addi	r2,r2,136
8111e854:	e0bff215 	stw	r2,-56(fp)
				pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset);
8111e858:	e0bff217 	ldw	r2,-56(fp)
8111e85c:	e0bff415 	stw	r2,-48(fp)
				i = 0;
8111e860:	e03ff305 	stb	zero,-52(fp)
			}
			// Generate pattern pixel (16-bits)
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
8111e864:	e0bff303 	ldbu	r2,-52(fp)
8111e868:	10c00044 	addi	r3,r2,1
8111e86c:	e0fff305 	stb	r3,-52(fp)
8111e870:	10803fcc 	andi	r2,r2,255
8111e874:	e0fffa03 	ldbu	r3,-24(fp)
8111e878:	18c000cc 	andi	r3,r3,3
8111e87c:	180692fa 	slli	r3,r3,11
8111e880:	1809883a 	mov	r4,r3
8111e884:	00f80004 	movi	r3,-8192
8111e888:	20c6b03a 	or	r3,r4,r3
8111e88c:	1809883a 	mov	r4,r3
8111e890:	e0fffb03 	ldbu	r3,-20(fp)
8111e894:	18c0004c 	andi	r3,r3,1
8111e898:	180692ba 	slli	r3,r3,10
8111e89c:	20c6b03a 	or	r3,r4,r3
8111e8a0:	1809883a 	mov	r4,r3
8111e8a4:	e0fff517 	ldw	r3,-44(fp)
8111e8a8:	18c007cc 	andi	r3,r3,31
8111e8ac:	1806917a 	slli	r3,r3,5
8111e8b0:	20c6b03a 	or	r3,r4,r3
8111e8b4:	1809883a 	mov	r4,r3
8111e8b8:	e0fff617 	ldw	r3,-40(fp)
8111e8bc:	18c007cc 	andi	r3,r3,31
8111e8c0:	20c6b03a 	or	r3,r4,r3
8111e8c4:	1809883a 	mov	r4,r3
8111e8c8:	e0fff417 	ldw	r3,-48(fp)
8111e8cc:	1085883a 	add	r2,r2,r2
8111e8d0:	1885883a 	add	r2,r3,r2
8111e8d4:	1100000d 	sth	r4,0(r2)
	alt_u32 offset = mem_offset;
	alt_u8 i = 0;
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
	{
		for (alt_u32 col = 0; col < width_cols; col++) // column sweep
8111e8d8:	e0bff617 	ldw	r2,-40(fp)
8111e8dc:	10800044 	addi	r2,r2,1
8111e8e0:	e0bff615 	stw	r2,-40(fp)
8111e8e4:	e0fff617 	ldw	r3,-40(fp)
8111e8e8:	e0800217 	ldw	r2,8(fp)
8111e8ec:	18bfcf36 	bltu	r3,r2,8111e82c <__reset+0xfb0fe82c>

	bDdr2SwitchMemory(mem_number); // Switch to the desired memory
	alt_u32 offset = mem_offset;
	alt_u8 i = 0;
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
8111e8f0:	e0bff517 	ldw	r2,-44(fp)
8111e8f4:	10800044 	addi	r2,r2,1
8111e8f8:	e0bff515 	stw	r2,-44(fp)
8111e8fc:	e0fff517 	ldw	r3,-44(fp)
8111e900:	e0800317 	ldw	r2,12(fp)
8111e904:	18bfc736 	bltu	r3,r2,8111e824 <__reset+0xfb0fe824>
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
			//pxPixelData->usiPixel[i++] = 0xFFFF;
		}
	}
	//pxPixelData->ulliMask = xSimMeb.xFeeControl.xNfee[0].xMemMap.xCommon.ucPaddingMask.ullWord;
	pxPixelData->ulliMask = 0;
8111e908:	e0bff417 	ldw	r2,-48(fp)
8111e90c:	10002015 	stw	zero,128(r2)
8111e910:	10002115 	stw	zero,132(r2)
	for (alt_u8 j = 0; j < i; j++) // create the mask (i.e.: if i stops at block 3 , the mask will be 0b00...0111)
8111e914:	e03ff705 	stb	zero,-36(fp)
8111e918:	00001c06 	br	8111e98c <pattern_createPattern+0x1d0>
	{
		pxPixelData->ulliMask |= 0x8000000000000000 >> j;
8111e91c:	e13ff417 	ldw	r4,-48(fp)
8111e920:	20802017 	ldw	r2,128(r4)
8111e924:	20c02117 	ldw	r3,132(r4)
8111e928:	e13ff703 	ldbu	r4,-36(fp)
8111e92c:	217ff804 	addi	r5,r4,-32
8111e930:	28000416 	blt	r5,zero,8111e944 <pattern_createPattern+0x188>
8111e934:	01200034 	movhi	r4,32768
8111e938:	2160d83a 	srl	r16,r4,r5
8111e93c:	0023883a 	mov	r17,zero
8111e940:	00000a06 	br	8111e96c <pattern_createPattern+0x1b0>
8111e944:	01600034 	movhi	r5,32768
8111e948:	280c907a 	slli	r6,r5,1
8111e94c:	014007c4 	movi	r5,31
8111e950:	290bc83a 	sub	r5,r5,r4
8111e954:	314a983a 	sll	r5,r6,r5
8111e958:	000d883a 	mov	r6,zero
8111e95c:	3120d83a 	srl	r16,r6,r4
8111e960:	2c20b03a 	or	r16,r5,r16
8111e964:	01600034 	movhi	r5,32768
8111e968:	2922d83a 	srl	r17,r5,r4
8111e96c:	1424b03a 	or	r18,r2,r16
8111e970:	1c66b03a 	or	r19,r3,r17
8111e974:	e0bff417 	ldw	r2,-48(fp)
8111e978:	14802015 	stw	r18,128(r2)
8111e97c:	14c02115 	stw	r19,132(r2)
			//pxPixelData->usiPixel[i++] = 0xFFFF;
		}
	}
	//pxPixelData->ulliMask = xSimMeb.xFeeControl.xNfee[0].xMemMap.xCommon.ucPaddingMask.ullWord;
	pxPixelData->ulliMask = 0;
	for (alt_u8 j = 0; j < i; j++) // create the mask (i.e.: if i stops at block 3 , the mask will be 0b00...0111)
8111e980:	e0bff703 	ldbu	r2,-36(fp)
8111e984:	10800044 	addi	r2,r2,1
8111e988:	e0bff705 	stb	r2,-36(fp)
8111e98c:	e0fff703 	ldbu	r3,-36(fp)
8111e990:	e0bff303 	ldbu	r2,-52(fp)
8111e994:	18bfe136 	bltu	r3,r2,8111e91c <__reset+0xfb0fe91c>
		pxPixelData->ulliMask |= 0x8000000000000000 >> j;
	}



	offset += sizeof(TSdmaPixelDataBlock); // increment offset so we return the next available memory block
8111e998:	e0bff217 	ldw	r2,-56(fp)
8111e99c:	10802204 	addi	r2,r2,136
8111e9a0:	e0bff215 	stw	r2,-56(fp)
	return offset;
8111e9a4:	e0bff217 	ldw	r2,-56(fp)
}
8111e9a8:	e6fffc04 	addi	sp,fp,-16
8111e9ac:	dfc00517 	ldw	ra,20(sp)
8111e9b0:	df000417 	ldw	fp,16(sp)
8111e9b4:	dcc00317 	ldw	r19,12(sp)
8111e9b8:	dc800217 	ldw	r18,8(sp)
8111e9bc:	dc400117 	ldw	r17,4(sp)
8111e9c0:	dc000017 	ldw	r16,0(sp)
8111e9c4:	dec00604 	addi	sp,sp,24
8111e9c8:	f800283a 	ret

8111e9cc <bSDcardIsPresent>:
#include "sdcard_file_manager.h"


TSDHandle xSdHandle;

bool bSDcardIsPresent( void ){
8111e9cc:	defffe04 	addi	sp,sp,-8
8111e9d0:	de00012e 	bgeu	sp,et,8111e9d8 <bSDcardIsPresent+0xc>
8111e9d4:	003b68fa 	trap	3
8111e9d8:	dfc00115 	stw	ra,4(sp)
8111e9dc:	df000015 	stw	fp,0(sp)
8111e9e0:	d839883a 	mov	fp,sp
	return alt_up_sd_card_is_Present();
8111e9e4:	1144f580 	call	81144f58 <alt_up_sd_card_is_Present>
}
8111e9e8:	e037883a 	mov	sp,fp
8111e9ec:	dfc00117 	ldw	ra,4(sp)
8111e9f0:	df000017 	ldw	fp,0(sp)
8111e9f4:	dec00204 	addi	sp,sp,8
8111e9f8:	f800283a 	ret

8111e9fc <bSDcardFAT16Check>:

bool bSDcardFAT16Check( void ){
8111e9fc:	defffe04 	addi	sp,sp,-8
8111ea00:	de00012e 	bgeu	sp,et,8111ea08 <bSDcardFAT16Check+0xc>
8111ea04:	003b68fa 	trap	3
8111ea08:	dfc00115 	stw	ra,4(sp)
8111ea0c:	df000015 	stw	fp,0(sp)
8111ea10:	d839883a 	mov	fp,sp
	return alt_up_sd_card_is_FAT16();
8111ea14:	11450240 	call	81145024 <alt_up_sd_card_is_FAT16>
}
8111ea18:	e037883a 	mov	sp,fp
8111ea1c:	dfc00117 	ldw	ra,4(sp)
8111ea20:	df000017 	ldw	fp,0(sp)
8111ea24:	dec00204 	addi	sp,sp,8
8111ea28:	f800283a 	ret

8111ea2c <bInitializeSDCard>:

bool bInitializeSDCard( void ){
8111ea2c:	defffd04 	addi	sp,sp,-12
8111ea30:	de00012e 	bgeu	sp,et,8111ea38 <bInitializeSDCard+0xc>
8111ea34:	003b68fa 	trap	3
8111ea38:	dfc00215 	stw	ra,8(sp)
8111ea3c:	df000115 	stw	fp,4(sp)
8111ea40:	df000104 	addi	fp,sp,4
	bool bSucess = FALSE;
8111ea44:	e03fff15 	stw	zero,-4(fp)
	xSdHandle.deviceHandle = NULL;
8111ea48:	d0207715 	stw	zero,-32292(gp)

	xSdHandle.deviceHandle = alt_up_sd_card_open_dev(ALTERA_UP_SD_CARD_AVALON_INTERFACE_0_NAME);
8111ea4c:	01204574 	movhi	r4,33045
8111ea50:	21020204 	addi	r4,r4,2056
8111ea54:	1144e940 	call	81144e94 <alt_up_sd_card_open_dev>
8111ea58:	d0a07715 	stw	r2,-32292(gp)
	if ( xSdHandle.deviceHandle != NULL ) {
8111ea5c:	d0a07717 	ldw	r2,-32292(gp)
8111ea60:	10002226 	beq	r2,zero,8111eaec <bInitializeSDCard+0xc0>

		bSucess = bSDcardIsPresent();
8111ea64:	111e9cc0 	call	8111e9cc <bSDcardIsPresent>
8111ea68:	e0bfff15 	stw	r2,-4(fp)
		if ( bSucess ) {
8111ea6c:	e0bfff17 	ldw	r2,-4(fp)
8111ea70:	10001626 	beq	r2,zero,8111eacc <bInitializeSDCard+0xa0>
			bSucess = bSDcardFAT16Check();
8111ea74:	111e9fc0 	call	8111e9fc <bSDcardFAT16Check>
8111ea78:	e0bfff15 	stw	r2,-4(fp)
			if ( bSucess ) {
8111ea7c:	e0bfff17 	ldw	r2,-4(fp)
8111ea80:	10000a26 	beq	r2,zero,8111eaac <bInitializeSDCard+0x80>
				xSdHandle.connected = TRUE;
8111ea84:	00800044 	movi	r2,1
8111ea88:	d0a07615 	stw	r2,-32296(gp)
				debug(fp, "SD is up.\r\n");
8111ea8c:	d0a06217 	ldw	r2,-32376(gp)
8111ea90:	100f883a 	mov	r7,r2
8111ea94:	018002c4 	movi	r6,11
8111ea98:	01400044 	movi	r5,1
8111ea9c:	01204574 	movhi	r4,33045
8111eaa0:	21020d04 	addi	r4,r4,2100
8111eaa4:	1121c7c0 	call	81121c7c <fwrite>
8111eaa8:	00001806 	br	8111eb0c <bInitializeSDCard+0xe0>
			} else {
				/* SD isn't in FAT16 format*/
				debug(fp, "SD Card should be formated in FAT16.\r\n");
8111eaac:	d0a06217 	ldw	r2,-32376(gp)
8111eab0:	100f883a 	mov	r7,r2
8111eab4:	01800984 	movi	r6,38
8111eab8:	01400044 	movi	r5,1
8111eabc:	01204574 	movhi	r4,33045
8111eac0:	21021004 	addi	r4,r4,2112
8111eac4:	1121c7c0 	call	81121c7c <fwrite>
8111eac8:	00001006 	br	8111eb0c <bInitializeSDCard+0xe0>
			}
		} else {
			/* There's no SDCard in the slot */
			debug(fp, "There is no SD in the slot.\r\n");
8111eacc:	d0a06217 	ldw	r2,-32376(gp)
8111ead0:	100f883a 	mov	r7,r2
8111ead4:	01800744 	movi	r6,29
8111ead8:	01400044 	movi	r5,1
8111eadc:	01204574 	movhi	r4,33045
8111eae0:	21021a04 	addi	r4,r4,2152
8111eae4:	1121c7c0 	call	81121c7c <fwrite>
8111eae8:	00000806 	br	8111eb0c <bInitializeSDCard+0xe0>
		}

	} else {
		/* Unable to open the SDCard device. */
		bSucess = FALSE;
8111eaec:	e03fff15 	stw	zero,-4(fp)
		debug(fp, "Unable to open the SDCard device.\r\n");
8111eaf0:	d0a06217 	ldw	r2,-32376(gp)
8111eaf4:	100f883a 	mov	r7,r2
8111eaf8:	018008c4 	movi	r6,35
8111eafc:	01400044 	movi	r5,1
8111eb00:	01204574 	movhi	r4,33045
8111eb04:	21022204 	addi	r4,r4,2184
8111eb08:	1121c7c0 	call	81121c7c <fwrite>
	}

	return bSucess;
8111eb0c:	e0bfff17 	ldw	r2,-4(fp)
}
8111eb10:	e037883a 	mov	sp,fp
8111eb14:	dfc00117 	ldw	ra,4(sp)
8111eb18:	df000017 	ldw	fp,0(sp)
8111eb1c:	dec00204 	addi	sp,sp,8
8111eb20:	f800283a 	ret

8111eb24 <siOpenFile>:
	}
	return (char)readCharacter;
}
*/

short int siOpenFile( char *filename ) {
8111eb24:	defffd04 	addi	sp,sp,-12
8111eb28:	de00012e 	bgeu	sp,et,8111eb30 <siOpenFile+0xc>
8111eb2c:	003b68fa 	trap	3
8111eb30:	dfc00215 	stw	ra,8(sp)
8111eb34:	df000115 	stw	fp,4(sp)
8111eb38:	df000104 	addi	fp,sp,4
8111eb3c:	e13fff15 	stw	r4,-4(fp)
	return alt_up_sd_card_fopen( filename, FALSE );
8111eb40:	000b883a 	mov	r5,zero
8111eb44:	e13fff17 	ldw	r4,-4(fp)
8111eb48:	11455300 	call	81145530 <alt_up_sd_card_fopen>
}
8111eb4c:	e037883a 	mov	sp,fp
8111eb50:	dfc00117 	ldw	ra,4(sp)
8111eb54:	df000017 	ldw	fp,0(sp)
8111eb58:	dec00204 	addi	sp,sp,8
8111eb5c:	f800283a 	ret

8111eb60 <siCloseFile>:

bool siCloseFile( short int file_handle ) {
8111eb60:	defffd04 	addi	sp,sp,-12
8111eb64:	de00012e 	bgeu	sp,et,8111eb6c <siCloseFile+0xc>
8111eb68:	003b68fa 	trap	3
8111eb6c:	dfc00215 	stw	ra,8(sp)
8111eb70:	df000115 	stw	fp,4(sp)
8111eb74:	df000104 	addi	fp,sp,4
8111eb78:	2005883a 	mov	r2,r4
8111eb7c:	e0bfff0d 	sth	r2,-4(fp)
	return alt_up_sd_card_fclose( file_handle );
8111eb80:	e0bfff0f 	ldh	r2,-4(fp)
8111eb84:	1009883a 	mov	r4,r2
8111eb88:	114637c0 	call	8114637c <alt_up_sd_card_fclose>
}
8111eb8c:	e037883a 	mov	sp,fp
8111eb90:	dfc00117 	ldw	ra,4(sp)
8111eb94:	df000017 	ldw	fp,0(sp)
8111eb98:	dec00204 	addi	sp,sp,8
8111eb9c:	f800283a 	ret

8111eba0 <cGetNextChar>:

char cGetNextChar( short int file_handle ) {
8111eba0:	defffd04 	addi	sp,sp,-12
8111eba4:	de00012e 	bgeu	sp,et,8111ebac <cGetNextChar+0xc>
8111eba8:	003b68fa 	trap	3
8111ebac:	dfc00215 	stw	ra,8(sp)
8111ebb0:	df000115 	stw	fp,4(sp)
8111ebb4:	df000104 	addi	fp,sp,4
8111ebb8:	2005883a 	mov	r2,r4
8111ebbc:	e0bfff0d 	sth	r2,-4(fp)
	return (char)alt_up_sd_card_read( file_handle );
8111ebc0:	e0bfff0f 	ldh	r2,-4(fp)
8111ebc4:	1009883a 	mov	r4,r2
8111ebc8:	11459d40 	call	811459d4 <alt_up_sd_card_read>
}
8111ebcc:	e037883a 	mov	sp,fp
8111ebd0:	dfc00117 	ldw	ra,4(sp)
8111ebd4:	df000017 	ldw	fp,0(sp)
8111ebd8:	dec00204 	addi	sp,sp,8
8111ebdc:	f800283a 	ret

8111ebe0 <bInitSync>:

#include "sync_handler.h"

/* todo: Create a struct that will contain all config, and pass as parameter to the functions */

bool bInitSync( void ) {
8111ebe0:	defffc04 	addi	sp,sp,-16
8111ebe4:	de00012e 	bgeu	sp,et,8111ebec <bInitSync+0xc>
8111ebe8:	003b68fa 	trap	3
8111ebec:	dfc00315 	stw	ra,12(sp)
8111ebf0:	df000215 	stw	fp,8(sp)
8111ebf4:	df000204 	addi	fp,sp,8
	bool	bSuccess;
	alt_u32	aux_32;

	vSyncInitIrq();
8111ebf8:	110cbb40 	call	8110cbb4 <vSyncInitIrq>

	#ifdef DEBUG_ON
		debug(fp, "Initializing Sync Module.\n");
8111ebfc:	d0a06217 	ldw	r2,-32376(gp)
8111ec00:	100f883a 	mov	r7,r2
8111ec04:	01800684 	movi	r6,26
8111ec08:	01400044 	movi	r5,1
8111ec0c:	01204574 	movhi	r4,33045
8111ec10:	21022b04 	addi	r4,r4,2220
8111ec14:	1121c7c0 	call	81121c7c <fwrite>
	#endif

	// Configura um padro de sync interno
	// MBT => 400 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetMbt(MBT);
8111ec18:	01004c74 	movhi	r4,305
8111ec1c:	210b4004 	addi	r4,r4,11520
8111ec20:	110cdbc0 	call	8110cdbc <bSyncSetMbt>
8111ec24:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111ec28:	e0bffe17 	ldw	r2,-8(fp)
8111ec2c:	1000091e 	bne	r2,zero,8111ec54 <bInitSync+0x74>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111ec30:	d0a06217 	ldw	r2,-32376(gp)
8111ec34:	100f883a 	mov	r7,r2
8111ec38:	018005c4 	movi	r6,23
8111ec3c:	01400044 	movi	r5,1
8111ec40:	01204574 	movhi	r4,33045
8111ec44:	21023204 	addi	r4,r4,2248
8111ec48:	1121c7c0 	call	81121c7c <fwrite>
		#endif
		return bSuccess;
8111ec4c:	e0bffe17 	ldw	r2,-8(fp)
8111ec50:	00008d06 	br	8111ee88 <bInitSync+0x2a8>
	}

	// BT => 200 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetBt(BT);
8111ec54:	01002674 	movhi	r4,153
8111ec58:	2125a004 	addi	r4,r4,-27008
8111ec5c:	110cdfc0 	call	8110cdfc <bSyncSetBt>
8111ec60:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111ec64:	e0bffe17 	ldw	r2,-8(fp)
8111ec68:	1000091e 	bne	r2,zero,8111ec90 <bInitSync+0xb0>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111ec6c:	d0a06217 	ldw	r2,-32376(gp)
8111ec70:	100f883a 	mov	r7,r2
8111ec74:	018005c4 	movi	r6,23
8111ec78:	01400044 	movi	r5,1
8111ec7c:	01204574 	movhi	r4,33045
8111ec80:	21023204 	addi	r4,r4,2248
8111ec84:	1121c7c0 	call	81121c7c <fwrite>
		#endif
		return bSuccess;
8111ec88:	e0bffe17 	ldw	r2,-8(fp)
8111ec8c:	00007e06 	br	8111ee88 <bInitSync+0x2a8>
	}

	// PER => 6,25s @ 20 ns (50 MHz)
	bSuccess = bSyncSetPer(  uliPerCalcPeriodMs( xDefaults.usiSyncPeriod ) );
8111ec90:	00a045b4 	movhi	r2,33046
8111ec94:	109c0004 	addi	r2,r2,28672
8111ec98:	1080068b 	ldhu	r2,26(r2)
8111ec9c:	10bfffcc 	andi	r2,r2,65535
8111eca0:	1009883a 	mov	r4,r2
8111eca4:	110da940 	call	8110da94 <uliPerCalcPeriodMs>
8111eca8:	1009883a 	mov	r4,r2
8111ecac:	110ce3c0 	call	8110ce3c <bSyncSetPer>
8111ecb0:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111ecb4:	e0bffe17 	ldw	r2,-8(fp)
8111ecb8:	1000091e 	bne	r2,zero,8111ece0 <bInitSync+0x100>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111ecbc:	d0a06217 	ldw	r2,-32376(gp)
8111ecc0:	100f883a 	mov	r7,r2
8111ecc4:	018005c4 	movi	r6,23
8111ecc8:	01400044 	movi	r5,1
8111eccc:	01204574 	movhi	r4,33045
8111ecd0:	21023204 	addi	r4,r4,2248
8111ecd4:	1121c7c0 	call	81121c7c <fwrite>
		#endif
		return bSuccess;
8111ecd8:	e0bffe17 	ldw	r2,-8(fp)
8111ecdc:	00006a06 	br	8111ee88 <bInitSync+0x2a8>
	}

	// OST => 500 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetOst(OST);
8111ece0:	01005f74 	movhi	r4,381
8111ece4:	211e1004 	addi	r4,r4,30784
8111ece8:	110ce7c0 	call	8110ce7c <bSyncSetOst>
8111ecec:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111ecf0:	e0bffe17 	ldw	r2,-8(fp)
8111ecf4:	1000091e 	bne	r2,zero,8111ed1c <bInitSync+0x13c>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111ecf8:	d0a06217 	ldw	r2,-32376(gp)
8111ecfc:	100f883a 	mov	r7,r2
8111ed00:	018005c4 	movi	r6,23
8111ed04:	01400044 	movi	r5,1
8111ed08:	01204574 	movhi	r4,33045
8111ed0c:	21023204 	addi	r4,r4,2248
8111ed10:	1121c7c0 	call	81121c7c <fwrite>
		#endif
		return bSuccess;
8111ed14:	e0bffe17 	ldw	r2,-8(fp)
8111ed18:	00005b06 	br	8111ee88 <bInitSync+0x2a8>
	}


	// Polaridade
	bSuccess = bSyncSetPolarity(POL);
8111ed1c:	0009883a 	mov	r4,zero
8111ed20:	110cebc0 	call	8110cebc <bSyncSetPolarity>
8111ed24:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111ed28:	e0bffe17 	ldw	r2,-8(fp)
8111ed2c:	1000091e 	bne	r2,zero,8111ed54 <bInitSync+0x174>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111ed30:	d0a06217 	ldw	r2,-32376(gp)
8111ed34:	100f883a 	mov	r7,r2
8111ed38:	018005c4 	movi	r6,23
8111ed3c:	01400044 	movi	r5,1
8111ed40:	01204574 	movhi	r4,33045
8111ed44:	21023204 	addi	r4,r4,2248
8111ed48:	1121c7c0 	call	81121c7c <fwrite>
		#endif
		return bSuccess;
8111ed4c:	e0bffe17 	ldw	r2,-8(fp)
8111ed50:	00004d06 	br	8111ee88 <bInitSync+0x2a8>
	}

	// N. de ciclos
	bSuccess = bSyncSetNCycles(N_CICLOS);
8111ed54:	01000104 	movi	r4,4
8111ed58:	110cf300 	call	8110cf30 <bSyncSetNCycles>
8111ed5c:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111ed60:	e0bffe17 	ldw	r2,-8(fp)
8111ed64:	1000091e 	bne	r2,zero,8111ed8c <bInitSync+0x1ac>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111ed68:	d0a06217 	ldw	r2,-32376(gp)
8111ed6c:	100f883a 	mov	r7,r2
8111ed70:	018005c4 	movi	r6,23
8111ed74:	01400044 	movi	r5,1
8111ed78:	01204574 	movhi	r4,33045
8111ed7c:	21023204 	addi	r4,r4,2248
8111ed80:	1121c7c0 	call	81121c7c <fwrite>
		#endif
		return bSuccess;
8111ed84:	e0bffe17 	ldw	r2,-8(fp)
8111ed88:	00003f06 	br	8111ee88 <bInitSync+0x2a8>
	}

	// Altera mux para sync interno
	bSuccess = bSyncCtrExtnIrq(TRUE);
8111ed8c:	01000044 	movi	r4,1
8111ed90:	110d10c0 	call	8110d10c <bSyncCtrExtnIrq>
8111ed94:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111ed98:	e0bffe17 	ldw	r2,-8(fp)
8111ed9c:	1000091e 	bne	r2,zero,8111edc4 <bInitSync+0x1e4>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111eda0:	d0a06217 	ldw	r2,-32376(gp)
8111eda4:	100f883a 	mov	r7,r2
8111eda8:	018005c4 	movi	r6,23
8111edac:	01400044 	movi	r5,1
8111edb0:	01204574 	movhi	r4,33045
8111edb4:	21023204 	addi	r4,r4,2248
8111edb8:	1121c7c0 	call	81121c7c <fwrite>
		#endif
		return bSuccess;
8111edbc:	e0bffe17 	ldw	r2,-8(fp)
8111edc0:	00003106 	br	8111ee88 <bInitSync+0x2a8>
	}

	// Habilita sync_out enable (deve aparecer na sada o sync int.)
	bSuccess = bSyncCtrSyncOutEnable(TRUE);
8111edc4:	01000044 	movi	r4,1
8111edc8:	110d2d40 	call	8110d2d4 <bSyncCtrSyncOutEnable>
8111edcc:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111edd0:	e0bffe17 	ldw	r2,-8(fp)
8111edd4:	1000091e 	bne	r2,zero,8111edfc <bInitSync+0x21c>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111edd8:	d0a06217 	ldw	r2,-32376(gp)
8111eddc:	100f883a 	mov	r7,r2
8111ede0:	018005c4 	movi	r6,23
8111ede4:	01400044 	movi	r5,1
8111ede8:	01204574 	movhi	r4,33045
8111edec:	21023204 	addi	r4,r4,2248
8111edf0:	1121c7c0 	call	81121c7c <fwrite>
		#endif
		return bSuccess;
8111edf4:	e0bffe17 	ldw	r2,-8(fp)
8111edf8:	00002306 	br	8111ee88 <bInitSync+0x2a8>
	}


	// Habilita sync_out_ch1 enable (libera sync para o Ch 1)
	bSuccess = bSyncCtrCh1OutEnable(TRUE);
8111edfc:	01000044 	movi	r4,1
8111ee00:	110d3480 	call	8110d348 <bSyncCtrCh1OutEnable>
8111ee04:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111ee08:	e0bffe17 	ldw	r2,-8(fp)
8111ee0c:	1000091e 	bne	r2,zero,8111ee34 <bInitSync+0x254>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111ee10:	d0a06217 	ldw	r2,-32376(gp)
8111ee14:	100f883a 	mov	r7,r2
8111ee18:	018005c4 	movi	r6,23
8111ee1c:	01400044 	movi	r5,1
8111ee20:	01204574 	movhi	r4,33045
8111ee24:	21023204 	addi	r4,r4,2248
8111ee28:	1121c7c0 	call	81121c7c <fwrite>
		#endif
		return bSuccess;
8111ee2c:	e0bffe17 	ldw	r2,-8(fp)
8111ee30:	00001506 	br	8111ee88 <bInitSync+0x2a8>
	}

	// Habilita sync_out_ch1 enable (libera sync para o Ch 1)
	bSuccess = bSyncCtrCh2OutEnable(TRUE);
8111ee34:	01000044 	movi	r4,1
8111ee38:	110d3bc0 	call	8110d3bc <bSyncCtrCh2OutEnable>
8111ee3c:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111ee40:	e0bffe17 	ldw	r2,-8(fp)
8111ee44:	1000091e 	bne	r2,zero,8111ee6c <bInitSync+0x28c>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111ee48:	d0a06217 	ldw	r2,-32376(gp)
8111ee4c:	100f883a 	mov	r7,r2
8111ee50:	018005c4 	movi	r6,23
8111ee54:	01400044 	movi	r5,1
8111ee58:	01204574 	movhi	r4,33045
8111ee5c:	21023204 	addi	r4,r4,2248
8111ee60:	1121c7c0 	call	81121c7c <fwrite>
		#endif
		return bSuccess;
8111ee64:	e0bffe17 	ldw	r2,-8(fp)
8111ee68:	00000706 	br	8111ee88 <bInitSync+0x2a8>
	}

	bSuccess = bSyncCtrStart();
8111ee6c:	110d1840 	call	8110d184 <bSyncCtrStart>
8111ee70:	e0bffe15 	stw	r2,-8(fp)
	bSyncCtrReset();
8111ee74:	110d1d80 	call	8110d1d8 <bSyncCtrReset>
	aux_32 = bSyncIrqEnableBlank(TRUE);
8111ee78:	01000044 	movi	r4,1
8111ee7c:	110d75c0 	call	8110d75c <bSyncIrqEnableBlank>
8111ee80:	e0bfff15 	stw	r2,-4(fp)


	return bSuccess;
8111ee84:	e0bffe17 	ldw	r2,-8(fp)
}
8111ee88:	e037883a 	mov	sp,fp
8111ee8c:	dfc00117 	ldw	ra,4(sp)
8111ee90:	df000017 	ldw	fp,0(sp)
8111ee94:	dec00204 	addi	sp,sp,8
8111ee98:	f800283a 	ret

8111ee9c <bStartSync>:


bool bStartSync(void) {
8111ee9c:	defffd04 	addi	sp,sp,-12
8111eea0:	de00012e 	bgeu	sp,et,8111eea8 <bStartSync+0xc>
8111eea4:	003b68fa 	trap	3
8111eea8:	dfc00215 	stw	ra,8(sp)
8111eeac:	df000115 	stw	fp,4(sp)
8111eeb0:	df000104 	addi	fp,sp,4

	bool bSuccess;
	bSyncCtrReset();
8111eeb4:	110d1d80 	call	8110d1d8 <bSyncCtrReset>
	bSuccess = bSyncCtrStart();
8111eeb8:	110d1840 	call	8110d184 <bSyncCtrStart>
8111eebc:	e0bfff15 	stw	r2,-4(fp)

	return bSuccess;
8111eec0:	e0bfff17 	ldw	r2,-4(fp)
}
8111eec4:	e037883a 	mov	sp,fp
8111eec8:	dfc00117 	ldw	ra,4(sp)
8111eecc:	df000017 	ldw	fp,0(sp)
8111eed0:	dec00204 	addi	sp,sp,8
8111eed4:	f800283a 	ret

8111eed8 <bStopSync>:

bool bStopSync(void) {
8111eed8:	defffe04 	addi	sp,sp,-8
8111eedc:	de00012e 	bgeu	sp,et,8111eee4 <bStopSync+0xc>
8111eee0:	003b68fa 	trap	3
8111eee4:	dfc00115 	stw	ra,4(sp)
8111eee8:	df000015 	stw	fp,0(sp)
8111eeec:	d839883a 	mov	fp,sp
	return bSyncCtrReset();
8111eef0:	110d1d80 	call	8110d1d8 <bSyncCtrReset>
}
8111eef4:	e037883a 	mov	sp,fp
8111eef8:	dfc00117 	ldw	ra,4(sp)
8111eefc:	df000017 	ldw	fp,0(sp)
8111ef00:	dec00204 	addi	sp,sp,8
8111ef04:	f800283a 	ret

8111ef08 <bClearCounterSync>:

void bClearCounterSync(void) {
8111ef08:	defffe04 	addi	sp,sp,-8
8111ef0c:	de00012e 	bgeu	sp,et,8111ef14 <bClearCounterSync+0xc>
8111ef10:	003b68fa 	trap	3
8111ef14:	dfc00115 	stw	ra,4(sp)
8111ef18:	df000015 	stw	fp,0(sp)
8111ef1c:	d839883a 	mov	fp,sp

	vSyncClearCounter();
8111ef20:	110cb880 	call	8110cb88 <vSyncClearCounter>
}
8111ef24:	0001883a 	nop
8111ef28:	e037883a 	mov	sp,fp
8111ef2c:	dfc00117 	ldw	ra,4(sp)
8111ef30:	df000017 	ldw	fp,0(sp)
8111ef34:	dec00204 	addi	sp,sp,8
8111ef38:	f800283a 	ret

8111ef3c <bTestSimucamCriticalHW>:
 */


#include "test_module_simucam.h"

bool bTestSimucamCriticalHW( void ) {
8111ef3c:	defffd04 	addi	sp,sp,-12
8111ef40:	de00012e 	bgeu	sp,et,8111ef48 <bTestSimucamCriticalHW+0xc>
8111ef44:	003b68fa 	trap	3
8111ef48:	dfc00215 	stw	ra,8(sp)
8111ef4c:	df000115 	stw	fp,4(sp)
8111ef50:	df000104 	addi	fp,sp,4
	/*
	 * Verificar com Frana quais testes podemos realizar aqui
	 * SDcard para criar logs e pegar defaults
	 */

	bSuccess = bSdmaInitM1Dma();
8111ef54:	1103b300 	call	81103b30 <bSdmaInitM1Dma>
8111ef58:	e0bfff15 	stw	r2,-4(fp)
	if (bSuccess==FALSE) {
8111ef5c:	e0bfff17 	ldw	r2,-4(fp)
8111ef60:	1000021e 	bne	r2,zero,8111ef6c <bTestSimucamCriticalHW+0x30>
		return bSuccess;
8111ef64:	e0bfff17 	ldw	r2,-4(fp)
8111ef68:	00000706 	br	8111ef88 <bTestSimucamCriticalHW+0x4c>
	}

	bSuccess = bSdmaInitM2Dma();
8111ef6c:	1103be00 	call	81103be0 <bSdmaInitM2Dma>
8111ef70:	e0bfff15 	stw	r2,-4(fp)
	if (bSuccess==FALSE) {
8111ef74:	e0bfff17 	ldw	r2,-4(fp)
8111ef78:	1000021e 	bne	r2,zero,8111ef84 <bTestSimucamCriticalHW+0x48>
		return bSuccess;
8111ef7c:	e0bfff17 	ldw	r2,-4(fp)
8111ef80:	00000106 	br	8111ef88 <bTestSimucamCriticalHW+0x4c>

	//xDma[0].pDmaTranfer = bSdmaDmaM1Transfer;
	//xDma[0].pDmaTranfer = bSdmaDmaM2Transfer;


	return TRUE;
8111ef84:	00800044 	movi	r2,1
}
8111ef88:	e037883a 	mov	sp,fp
8111ef8c:	dfc00117 	ldw	ra,4(sp)
8111ef90:	df000017 	ldw	fp,0(sp)
8111ef94:	dec00204 	addi	sp,sp,8
8111ef98:	f800283a 	ret

8111ef9c <_reg_write>:
 *
 * @retval 1 : Sucesso 
 *
 */

alt_32 _reg_write(int BASE_ADD, alt_32 REG_ADD, alt_32 REG_Dado) {
8111ef9c:	defffc04 	addi	sp,sp,-16
8111efa0:	de00012e 	bgeu	sp,et,8111efa8 <_reg_write+0xc>
8111efa4:	003b68fa 	trap	3
8111efa8:	df000315 	stw	fp,12(sp)
8111efac:	df000304 	addi	fp,sp,12
8111efb0:	e13ffd15 	stw	r4,-12(fp)
8111efb4:	e17ffe15 	stw	r5,-8(fp)
8111efb8:	e1bfff15 	stw	r6,-4(fp)

	IOWR_32DIRECT(BASE_ADD, REG_ADD << 2, REG_Dado);
8111efbc:	e0bffe17 	ldw	r2,-8(fp)
8111efc0:	1085883a 	add	r2,r2,r2
8111efc4:	1085883a 	add	r2,r2,r2
8111efc8:	1007883a 	mov	r3,r2
8111efcc:	e0bffd17 	ldw	r2,-12(fp)
8111efd0:	1885883a 	add	r2,r3,r2
8111efd4:	1007883a 	mov	r3,r2
8111efd8:	e0bfff17 	ldw	r2,-4(fp)
8111efdc:	18800035 	stwio	r2,0(r3)
	return 1;
8111efe0:	00800044 	movi	r2,1

}
8111efe4:	e037883a 	mov	sp,fp
8111efe8:	df000017 	ldw	fp,0(sp)
8111efec:	dec00104 	addi	sp,sp,4
8111eff0:	f800283a 	ret

8111eff4 <_reg_read>:
 *
 * @retval 1 : Sucesso 
 *
 */

alt_32 _reg_read(int BASE_ADD, alt_32 REG_ADD, alt_32 *REG_Dado) {
8111eff4:	defffc04 	addi	sp,sp,-16
8111eff8:	de00012e 	bgeu	sp,et,8111f000 <_reg_read+0xc>
8111effc:	003b68fa 	trap	3
8111f000:	df000315 	stw	fp,12(sp)
8111f004:	df000304 	addi	fp,sp,12
8111f008:	e13ffd15 	stw	r4,-12(fp)
8111f00c:	e17ffe15 	stw	r5,-8(fp)
8111f010:	e1bfff15 	stw	r6,-4(fp)

	*REG_Dado = IORD_32DIRECT(BASE_ADD, REG_ADD << 2);
8111f014:	e0bffe17 	ldw	r2,-8(fp)
8111f018:	1085883a 	add	r2,r2,r2
8111f01c:	1085883a 	add	r2,r2,r2
8111f020:	1007883a 	mov	r3,r2
8111f024:	e0bffd17 	ldw	r2,-12(fp)
8111f028:	1885883a 	add	r2,r3,r2
8111f02c:	10c00037 	ldwio	r3,0(r2)
8111f030:	e0bfff17 	ldw	r2,-4(fp)
8111f034:	10c00015 	stw	r3,0(r2)
	return 1;
8111f038:	00800044 	movi	r2,1

}
8111f03c:	e037883a 	mov	sp,fp
8111f040:	df000017 	ldw	fp,0(sp)
8111f044:	dec00104 	addi	sp,sp,4
8111f048:	f800283a 	ret

8111f04c <_print_codec_status>:
 * @param [in] codec_status
 * *
 * @retval 1 : Sucesso
 *
 */
void _print_codec_status(int codec_status) {
8111f04c:	defffa04 	addi	sp,sp,-24
8111f050:	de00012e 	bgeu	sp,et,8111f058 <_print_codec_status+0xc>
8111f054:	003b68fa 	trap	3
8111f058:	dfc00515 	stw	ra,20(sp)
8111f05c:	df000415 	stw	fp,16(sp)
8111f060:	df000404 	addi	fp,sp,16
8111f064:	e13fff15 	stw	r4,-4(fp)
	int started = (int) ((codec_status >> 6) & 1);
8111f068:	e0bfff17 	ldw	r2,-4(fp)
8111f06c:	1005d1ba 	srai	r2,r2,6
8111f070:	1080004c 	andi	r2,r2,1
8111f074:	e0bffc15 	stw	r2,-16(fp)
	int connecting = (int) ((codec_status >> 5) & 1);
8111f078:	e0bfff17 	ldw	r2,-4(fp)
8111f07c:	1005d17a 	srai	r2,r2,5
8111f080:	1080004c 	andi	r2,r2,1
8111f084:	e0bffd15 	stw	r2,-12(fp)
	int running = (int) ((codec_status >> 4) & 1);
8111f088:	e0bfff17 	ldw	r2,-4(fp)
8111f08c:	1005d13a 	srai	r2,r2,4
8111f090:	1080004c 	andi	r2,r2,1
8111f094:	e0bffe15 	stw	r2,-8(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "-------- link status \n");
8111f098:	00e04574 	movhi	r3,33045
8111f09c:	18ce1c04 	addi	r3,r3,14448
8111f0a0:	00a04574 	movhi	r2,33045
8111f0a4:	10823804 	addi	r2,r2,2272
8111f0a8:	1009883a 	mov	r4,r2
8111f0ac:	008005c4 	movi	r2,23
8111f0b0:	100d883a 	mov	r6,r2
8111f0b4:	200b883a 	mov	r5,r4
8111f0b8:	1809883a 	mov	r4,r3
8111f0bc:	11226900 	call	81122690 <memcpy>
	debug(fp, cDebugBuffer);
8111f0c0:	d0a06217 	ldw	r2,-32376(gp)
8111f0c4:	01604574 	movhi	r5,33045
8111f0c8:	294e1c04 	addi	r5,r5,14448
8111f0cc:	1009883a 	mov	r4,r2
8111f0d0:	11215e00 	call	811215e0 <fprintf>
	sprintf(cDebugBuffer, "Link started    : %s \n", (started == 1) ? "S" : "N");
8111f0d4:	e0bffc17 	ldw	r2,-16(fp)
8111f0d8:	10800058 	cmpnei	r2,r2,1
8111f0dc:	1000031e 	bne	r2,zero,8111f0ec <_print_codec_status+0xa0>
8111f0e0:	00a04574 	movhi	r2,33045
8111f0e4:	10823e04 	addi	r2,r2,2296
8111f0e8:	00000206 	br	8111f0f4 <_print_codec_status+0xa8>
8111f0ec:	00a04574 	movhi	r2,33045
8111f0f0:	10823f04 	addi	r2,r2,2300
8111f0f4:	100d883a 	mov	r6,r2
8111f0f8:	01604574 	movhi	r5,33045
8111f0fc:	29424004 	addi	r5,r5,2304
8111f100:	01204574 	movhi	r4,33045
8111f104:	210e1c04 	addi	r4,r4,14448
8111f108:	1122f700 	call	81122f70 <sprintf>
	debug(fp, cDebugBuffer);
8111f10c:	d0a06217 	ldw	r2,-32376(gp)
8111f110:	01604574 	movhi	r5,33045
8111f114:	294e1c04 	addi	r5,r5,14448
8111f118:	1009883a 	mov	r4,r2
8111f11c:	11215e00 	call	811215e0 <fprintf>
	sprintf(cDebugBuffer, "Link connecting : %s \n", (connecting == 1) ? "S" : "N");
8111f120:	e0bffd17 	ldw	r2,-12(fp)
8111f124:	10800058 	cmpnei	r2,r2,1
8111f128:	1000031e 	bne	r2,zero,8111f138 <_print_codec_status+0xec>
8111f12c:	00a04574 	movhi	r2,33045
8111f130:	10823e04 	addi	r2,r2,2296
8111f134:	00000206 	br	8111f140 <_print_codec_status+0xf4>
8111f138:	00a04574 	movhi	r2,33045
8111f13c:	10823f04 	addi	r2,r2,2300
8111f140:	100d883a 	mov	r6,r2
8111f144:	01604574 	movhi	r5,33045
8111f148:	29424604 	addi	r5,r5,2328
8111f14c:	01204574 	movhi	r4,33045
8111f150:	210e1c04 	addi	r4,r4,14448
8111f154:	1122f700 	call	81122f70 <sprintf>
	debug(fp, cDebugBuffer);
8111f158:	d0a06217 	ldw	r2,-32376(gp)
8111f15c:	01604574 	movhi	r5,33045
8111f160:	294e1c04 	addi	r5,r5,14448
8111f164:	1009883a 	mov	r4,r2
8111f168:	11215e00 	call	811215e0 <fprintf>
	sprintf(cDebugBuffer, "Link running    : %s \n", (running == 1) ? "S" : "N");
8111f16c:	e0bffe17 	ldw	r2,-8(fp)
8111f170:	10800058 	cmpnei	r2,r2,1
8111f174:	1000031e 	bne	r2,zero,8111f184 <_print_codec_status+0x138>
8111f178:	00a04574 	movhi	r2,33045
8111f17c:	10823e04 	addi	r2,r2,2296
8111f180:	00000206 	br	8111f18c <_print_codec_status+0x140>
8111f184:	00a04574 	movhi	r2,33045
8111f188:	10823f04 	addi	r2,r2,2300
8111f18c:	100d883a 	mov	r6,r2
8111f190:	01604574 	movhi	r5,33045
8111f194:	29424c04 	addi	r5,r5,2352
8111f198:	01204574 	movhi	r4,33045
8111f19c:	210e1c04 	addi	r4,r4,14448
8111f1a0:	1122f700 	call	81122f70 <sprintf>
	debug(fp, cDebugBuffer);
8111f1a4:	d0a06217 	ldw	r2,-32376(gp)
8111f1a8:	01604574 	movhi	r5,33045
8111f1ac:	294e1c04 	addi	r5,r5,14448
8111f1b0:	1009883a 	mov	r4,r2
8111f1b4:	11215e00 	call	811215e0 <fprintf>
	sprintf(cDebugBuffer, "--------  \n");
8111f1b8:	00a04574 	movhi	r2,33045
8111f1bc:	108e1c04 	addi	r2,r2,14448
8111f1c0:	00c00b44 	movi	r3,45
8111f1c4:	10c00005 	stb	r3,0(r2)
8111f1c8:	00c00b44 	movi	r3,45
8111f1cc:	10c00045 	stb	r3,1(r2)
8111f1d0:	00c00b44 	movi	r3,45
8111f1d4:	10c00085 	stb	r3,2(r2)
8111f1d8:	00c00b44 	movi	r3,45
8111f1dc:	10c000c5 	stb	r3,3(r2)
8111f1e0:	00c00b44 	movi	r3,45
8111f1e4:	10c00105 	stb	r3,4(r2)
8111f1e8:	00c00b44 	movi	r3,45
8111f1ec:	10c00145 	stb	r3,5(r2)
8111f1f0:	00c00b44 	movi	r3,45
8111f1f4:	10c00185 	stb	r3,6(r2)
8111f1f8:	00c00b44 	movi	r3,45
8111f1fc:	10c001c5 	stb	r3,7(r2)
8111f200:	00c00804 	movi	r3,32
8111f204:	10c00205 	stb	r3,8(r2)
8111f208:	00c00804 	movi	r3,32
8111f20c:	10c00245 	stb	r3,9(r2)
8111f210:	00c00284 	movi	r3,10
8111f214:	10c00285 	stb	r3,10(r2)
8111f218:	100002c5 	stb	zero,11(r2)
	debug(fp, cDebugBuffer);
8111f21c:	d0a06217 	ldw	r2,-32376(gp)
8111f220:	01604574 	movhi	r5,33045
8111f224:	294e1c04 	addi	r5,r5,14448
8111f228:	1009883a 	mov	r4,r2
8111f22c:	11215e00 	call	811215e0 <fprintf>
#endif
}
8111f230:	0001883a 	nop
8111f234:	e037883a 	mov	sp,fp
8111f238:	dfc00117 	ldw	ra,4(sp)
8111f23c:	df000017 	ldw	fp,0(sp)
8111f240:	dec00204 	addi	sp,sp,8
8111f244:	f800283a 	ret

8111f248 <_split_codec_status>:
 * *
 * @retval 1 : Sucesso
 *
 */
void _split_codec_status(int codec_status, int *started, int *connecting,
		int *running) {
8111f248:	defffb04 	addi	sp,sp,-20
8111f24c:	de00012e 	bgeu	sp,et,8111f254 <_split_codec_status+0xc>
8111f250:	003b68fa 	trap	3
8111f254:	df000415 	stw	fp,16(sp)
8111f258:	df000404 	addi	fp,sp,16
8111f25c:	e13ffc15 	stw	r4,-16(fp)
8111f260:	e17ffd15 	stw	r5,-12(fp)
8111f264:	e1bffe15 	stw	r6,-8(fp)
8111f268:	e1ffff15 	stw	r7,-4(fp)
	*started = (int) ((codec_status >> 6) & 1);
8111f26c:	e0bffc17 	ldw	r2,-16(fp)
8111f270:	1005d1ba 	srai	r2,r2,6
8111f274:	10c0004c 	andi	r3,r2,1
8111f278:	e0bffd17 	ldw	r2,-12(fp)
8111f27c:	10c00015 	stw	r3,0(r2)
	*connecting = (int) ((codec_status >> 5) & 1);
8111f280:	e0bffc17 	ldw	r2,-16(fp)
8111f284:	1005d17a 	srai	r2,r2,5
8111f288:	10c0004c 	andi	r3,r2,1
8111f28c:	e0bffe17 	ldw	r2,-8(fp)
8111f290:	10c00015 	stw	r3,0(r2)
	*running = (int) ((codec_status >> 4) & 1);
8111f294:	e0bffc17 	ldw	r2,-16(fp)
8111f298:	1005d13a 	srai	r2,r2,4
8111f29c:	10c0004c 	andi	r3,r2,1
8111f2a0:	e0bfff17 	ldw	r2,-4(fp)
8111f2a4:	10c00015 	stw	r3,0(r2)
}
8111f2a8:	0001883a 	nop
8111f2ac:	e037883a 	mov	sp,fp
8111f2b0:	df000017 	ldw	fp,0(sp)
8111f2b4:	dec00104 	addi	sp,sp,4
8111f2b8:	f800283a 	ret

8111f2bc <aatoh>:
 * @param [in] &char[n]
 * *
 * @retval INT8U of hecadecimal value
 *
 */
alt_u8 aatoh(alt_u8 *buffer) {
8111f2bc:	defffc04 	addi	sp,sp,-16
8111f2c0:	de00012e 	bgeu	sp,et,8111f2c8 <aatoh+0xc>
8111f2c4:	003b68fa 	trap	3
8111f2c8:	df000315 	stw	fp,12(sp)
8111f2cc:	df000304 	addi	fp,sp,12
8111f2d0:	e13fff15 	stw	r4,-4(fp)
	alt_u8* a;
	alt_u8 v;
	a = buffer;
8111f2d4:	e0bfff17 	ldw	r2,-4(fp)
8111f2d8:	e0bffd15 	stw	r2,-12(fp)
	v = ((a[0] - (48 + 7 * (a[0] > 57))) << 4)
8111f2dc:	e0bffd17 	ldw	r2,-12(fp)
8111f2e0:	10c00003 	ldbu	r3,0(r2)
8111f2e4:	e0bffd17 	ldw	r2,-12(fp)
8111f2e8:	10800003 	ldbu	r2,0(r2)
8111f2ec:	10803fcc 	andi	r2,r2,255
8111f2f0:	10800eb0 	cmpltui	r2,r2,58
8111f2f4:	1000021e 	bne	r2,zero,8111f300 <aatoh+0x44>
8111f2f8:	00800dc4 	movi	r2,55
8111f2fc:	00000106 	br	8111f304 <aatoh+0x48>
8111f300:	00800c04 	movi	r2,48
8111f304:	1885c83a 	sub	r2,r3,r2
8111f308:	1004913a 	slli	r2,r2,4
8111f30c:	1009883a 	mov	r4,r2
			+ (a[1] - (48 + 7 * (a[1] > 57)));
8111f310:	e0bffd17 	ldw	r2,-12(fp)
8111f314:	10800044 	addi	r2,r2,1
8111f318:	10c00003 	ldbu	r3,0(r2)
8111f31c:	e0bffd17 	ldw	r2,-12(fp)
8111f320:	10800044 	addi	r2,r2,1
8111f324:	10800003 	ldbu	r2,0(r2)
 */
alt_u8 aatoh(alt_u8 *buffer) {
	alt_u8* a;
	alt_u8 v;
	a = buffer;
	v = ((a[0] - (48 + 7 * (a[0] > 57))) << 4)
8111f328:	10803fcc 	andi	r2,r2,255
8111f32c:	10800eb0 	cmpltui	r2,r2,58
8111f330:	1000021e 	bne	r2,zero,8111f33c <aatoh+0x80>
8111f334:	00800dc4 	movi	r2,55
8111f338:	00000106 	br	8111f340 <aatoh+0x84>
8111f33c:	00800c04 	movi	r2,48
8111f340:	1885c83a 	sub	r2,r3,r2
8111f344:	2085883a 	add	r2,r4,r2
8111f348:	e0bffe05 	stb	r2,-8(fp)
			+ (a[1] - (48 + 7 * (a[1] > 57)));
	return v;
8111f34c:	e0bffe03 	ldbu	r2,-8(fp)
}
8111f350:	e037883a 	mov	sp,fp
8111f354:	df000017 	ldw	fp,0(sp)
8111f358:	dec00104 	addi	sp,sp,4
8111f35c:	f800283a 	ret

8111f360 <Verif_Error>:
 * *
 * @retval int
 *
 */

alt_u8 Verif_Error(alt_u8 error_code) {
8111f360:	defffd04 	addi	sp,sp,-12
8111f364:	de00012e 	bgeu	sp,et,8111f36c <Verif_Error+0xc>
8111f368:	003b68fa 	trap	3
8111f36c:	dfc00215 	stw	ra,8(sp)
8111f370:	df000115 	stw	fp,4(sp)
8111f374:	df000104 	addi	fp,sp,4
8111f378:	2005883a 	mov	r2,r4
8111f37c:	e0bfff05 	stb	r2,-4(fp)
	if (!error_code) {
8111f380:	e0bfff03 	ldbu	r2,-4(fp)
8111f384:	1000091e 	bne	r2,zero,8111f3ac <Verif_Error+0x4c>
#ifdef DEBUG_ON
	debug(fp, "ERROR\n\r");
8111f388:	d0a06217 	ldw	r2,-32376(gp)
8111f38c:	100f883a 	mov	r7,r2
8111f390:	018001c4 	movi	r6,7
8111f394:	01400044 	movi	r5,1
8111f398:	01204574 	movhi	r4,33045
8111f39c:	21025204 	addi	r4,r4,2376
8111f3a0:	1121c7c0 	call	81121c7c <fwrite>
#endif
		return 0;
8111f3a4:	0005883a 	mov	r2,zero
8111f3a8:	00000106 	br	8111f3b0 <Verif_Error+0x50>
	} else
		return 1;
8111f3ac:	00800044 	movi	r2,1
}
8111f3b0:	e037883a 	mov	sp,fp
8111f3b4:	dfc00117 	ldw	ra,4(sp)
8111f3b8:	df000017 	ldw	fp,0(sp)
8111f3bc:	dec00204 	addi	sp,sp,8
8111f3c0:	f800283a 	ret

8111f3c4 <toInt>:
 * *
 * @retval int
 *
 */

alt_u8 toInt(alt_u8 ascii) {
8111f3c4:	defffe04 	addi	sp,sp,-8
8111f3c8:	de00012e 	bgeu	sp,et,8111f3d0 <toInt+0xc>
8111f3cc:	003b68fa 	trap	3
8111f3d0:	df000115 	stw	fp,4(sp)
8111f3d4:	df000104 	addi	fp,sp,4
8111f3d8:	2005883a 	mov	r2,r4
8111f3dc:	e0bfff05 	stb	r2,-4(fp)
	return (int) ascii - 48;
8111f3e0:	e0bfff03 	ldbu	r2,-4(fp)
8111f3e4:	10bff404 	addi	r2,r2,-48
}
8111f3e8:	e037883a 	mov	sp,fp
8111f3ec:	df000017 	ldw	fp,0(sp)
8111f3f0:	dec00104 	addi	sp,sp,4
8111f3f4:	f800283a 	ret

8111f3f8 <__fixunsdfsi>:
8111f3f8:	defffd04 	addi	sp,sp,-12
8111f3fc:	000d883a 	mov	r6,zero
8111f400:	01d07834 	movhi	r7,16864
8111f404:	de00012e 	bgeu	sp,et,8111f40c <__fixunsdfsi+0x14>
8111f408:	003b68fa 	trap	3
8111f40c:	dc400115 	stw	r17,4(sp)
8111f410:	dc000015 	stw	r16,0(sp)
8111f414:	dfc00215 	stw	ra,8(sp)
8111f418:	2023883a 	mov	r17,r4
8111f41c:	2821883a 	mov	r16,r5
8111f420:	111fee40 	call	8111fee4 <__gedf2>
8111f424:	1000080e 	bge	r2,zero,8111f448 <__fixunsdfsi+0x50>
8111f428:	8809883a 	mov	r4,r17
8111f42c:	800b883a 	mov	r5,r16
8111f430:	1120fe40 	call	81120fe4 <__fixdfsi>
8111f434:	dfc00217 	ldw	ra,8(sp)
8111f438:	dc400117 	ldw	r17,4(sp)
8111f43c:	dc000017 	ldw	r16,0(sp)
8111f440:	dec00304 	addi	sp,sp,12
8111f444:	f800283a 	ret
8111f448:	000d883a 	mov	r6,zero
8111f44c:	01d07834 	movhi	r7,16864
8111f450:	8809883a 	mov	r4,r17
8111f454:	800b883a 	mov	r5,r16
8111f458:	11206e00 	call	811206e0 <__subdf3>
8111f45c:	180b883a 	mov	r5,r3
8111f460:	1009883a 	mov	r4,r2
8111f464:	1120fe40 	call	81120fe4 <__fixdfsi>
8111f468:	00e00034 	movhi	r3,32768
8111f46c:	10c5883a 	add	r2,r2,r3
8111f470:	003ff006 	br	8111f434 <__reset+0xfb0ff434>

8111f474 <__divsf3>:
8111f474:	defff504 	addi	sp,sp,-44
8111f478:	200cd5fa 	srli	r6,r4,23
8111f47c:	de00012e 	bgeu	sp,et,8111f484 <__divsf3+0x10>
8111f480:	003b68fa 	trap	3
8111f484:	dcc00415 	stw	r19,16(sp)
8111f488:	2026d7fa 	srli	r19,r4,31
8111f48c:	00c02034 	movhi	r3,128
8111f490:	dd800715 	stw	r22,28(sp)
8111f494:	dd000515 	stw	r20,20(sp)
8111f498:	dc800315 	stw	r18,12(sp)
8111f49c:	18ffffc4 	addi	r3,r3,-1
8111f4a0:	dfc00a15 	stw	ra,40(sp)
8111f4a4:	df000915 	stw	fp,36(sp)
8111f4a8:	ddc00815 	stw	r23,32(sp)
8111f4ac:	dd400615 	stw	r21,24(sp)
8111f4b0:	dc400215 	stw	r17,8(sp)
8111f4b4:	dc000115 	stw	r16,4(sp)
8111f4b8:	35003fcc 	andi	r20,r6,255
8111f4bc:	1924703a 	and	r18,r3,r4
8111f4c0:	9d803fcc 	andi	r22,r19,255
8111f4c4:	a0005226 	beq	r20,zero,8111f610 <__divsf3+0x19c>
8111f4c8:	00803fc4 	movi	r2,255
8111f4cc:	a0802e26 	beq	r20,r2,8111f588 <__divsf3+0x114>
8111f4d0:	91002034 	orhi	r4,r18,128
8111f4d4:	202490fa 	slli	r18,r4,3
8111f4d8:	a53fe044 	addi	r20,r20,-127
8111f4dc:	0021883a 	mov	r16,zero
8111f4e0:	002f883a 	mov	r23,zero
8111f4e4:	280cd5fa 	srli	r6,r5,23
8111f4e8:	282ad7fa 	srli	r21,r5,31
8111f4ec:	00c02034 	movhi	r3,128
8111f4f0:	18ffffc4 	addi	r3,r3,-1
8111f4f4:	31803fcc 	andi	r6,r6,255
8111f4f8:	1962703a 	and	r17,r3,r5
8111f4fc:	af003fcc 	andi	fp,r21,255
8111f500:	30004a26 	beq	r6,zero,8111f62c <__divsf3+0x1b8>
8111f504:	00803fc4 	movi	r2,255
8111f508:	30804526 	beq	r6,r2,8111f620 <__divsf3+0x1ac>
8111f50c:	89402034 	orhi	r5,r17,128
8111f510:	282290fa 	slli	r17,r5,3
8111f514:	31bfe044 	addi	r6,r6,-127
8111f518:	000b883a 	mov	r5,zero
8111f51c:	2c20b03a 	or	r16,r5,r16
8111f520:	802090ba 	slli	r16,r16,2
8111f524:	00a044b4 	movhi	r2,33042
8111f528:	10bd5204 	addi	r2,r2,-2744
8111f52c:	80a1883a 	add	r16,r16,r2
8111f530:	81000017 	ldw	r4,0(r16)
8111f534:	9d46f03a 	xor	r3,r19,r21
8111f538:	180f883a 	mov	r7,r3
8111f53c:	18803fcc 	andi	r2,r3,255
8111f540:	a18dc83a 	sub	r6,r20,r6
8111f544:	2000683a 	jmp	r4
8111f548:	8111f72c 	andhi	r4,r16,18396
8111f54c:	8111f5b0 	cmpltui	r4,r16,18390
8111f550:	8111f720 	cmpeqi	r4,r16,18396
8111f554:	8111f59c 	xori	r4,r16,18390
8111f558:	8111f720 	cmpeqi	r4,r16,18396
8111f55c:	8111f6f8 	rdprs	r4,r16,18395
8111f560:	8111f720 	cmpeqi	r4,r16,18396
8111f564:	8111f59c 	xori	r4,r16,18390
8111f568:	8111f5b0 	cmpltui	r4,r16,18390
8111f56c:	8111f5b0 	cmpltui	r4,r16,18390
8111f570:	8111f6f8 	rdprs	r4,r16,18395
8111f574:	8111f59c 	xori	r4,r16,18390
8111f578:	8111f80c 	andi	r4,r16,18400
8111f57c:	8111f80c 	andi	r4,r16,18400
8111f580:	8111f80c 	andi	r4,r16,18400
8111f584:	8111f7c0 	call	88111f7c <__reset+0x20f1f7c>
8111f588:	9000581e 	bne	r18,zero,8111f6ec <__divsf3+0x278>
8111f58c:	04000204 	movi	r16,8
8111f590:	05c00084 	movi	r23,2
8111f594:	003fd306 	br	8111f4e4 <__reset+0xfb0ff4e4>
8111f598:	0023883a 	mov	r17,zero
8111f59c:	e02d883a 	mov	r22,fp
8111f5a0:	282f883a 	mov	r23,r5
8111f5a4:	00800084 	movi	r2,2
8111f5a8:	b8808f1e 	bne	r23,r2,8111f7e8 <__divsf3+0x374>
8111f5ac:	b005883a 	mov	r2,r22
8111f5b0:	11c0004c 	andi	r7,r2,1
8111f5b4:	013fffc4 	movi	r4,-1
8111f5b8:	000d883a 	mov	r6,zero
8111f5bc:	21003fcc 	andi	r4,r4,255
8111f5c0:	200895fa 	slli	r4,r4,23
8111f5c4:	38803fcc 	andi	r2,r7,255
8111f5c8:	00c02034 	movhi	r3,128
8111f5cc:	100497fa 	slli	r2,r2,31
8111f5d0:	18ffffc4 	addi	r3,r3,-1
8111f5d4:	30c6703a 	and	r3,r6,r3
8111f5d8:	1906b03a 	or	r3,r3,r4
8111f5dc:	1884b03a 	or	r2,r3,r2
8111f5e0:	dfc00a17 	ldw	ra,40(sp)
8111f5e4:	df000917 	ldw	fp,36(sp)
8111f5e8:	ddc00817 	ldw	r23,32(sp)
8111f5ec:	dd800717 	ldw	r22,28(sp)
8111f5f0:	dd400617 	ldw	r21,24(sp)
8111f5f4:	dd000517 	ldw	r20,20(sp)
8111f5f8:	dcc00417 	ldw	r19,16(sp)
8111f5fc:	dc800317 	ldw	r18,12(sp)
8111f600:	dc400217 	ldw	r17,8(sp)
8111f604:	dc000117 	ldw	r16,4(sp)
8111f608:	dec00b04 	addi	sp,sp,44
8111f60c:	f800283a 	ret
8111f610:	90002b1e 	bne	r18,zero,8111f6c0 <__divsf3+0x24c>
8111f614:	04000104 	movi	r16,4
8111f618:	05c00044 	movi	r23,1
8111f61c:	003fb106 	br	8111f4e4 <__reset+0xfb0ff4e4>
8111f620:	8800251e 	bne	r17,zero,8111f6b8 <__divsf3+0x244>
8111f624:	01400084 	movi	r5,2
8111f628:	00000206 	br	8111f634 <__divsf3+0x1c0>
8111f62c:	88001a1e 	bne	r17,zero,8111f698 <__divsf3+0x224>
8111f630:	01400044 	movi	r5,1
8111f634:	8160b03a 	or	r16,r16,r5
8111f638:	802090ba 	slli	r16,r16,2
8111f63c:	00e044b4 	movhi	r3,33042
8111f640:	18fd9604 	addi	r3,r3,-2472
8111f644:	80e1883a 	add	r16,r16,r3
8111f648:	80c00017 	ldw	r3,0(r16)
8111f64c:	9d44f03a 	xor	r2,r19,r21
8111f650:	a18dc83a 	sub	r6,r20,r6
8111f654:	1800683a 	jmp	r3
8111f658:	8111f5b0 	cmpltui	r4,r16,18390
8111f65c:	8111f5b0 	cmpltui	r4,r16,18390
8111f660:	8111f7fc 	xorhi	r4,r16,18399
8111f664:	8111f598 	cmpnei	r4,r16,18390
8111f668:	8111f7fc 	xorhi	r4,r16,18399
8111f66c:	8111f6f8 	rdprs	r4,r16,18395
8111f670:	8111f7fc 	xorhi	r4,r16,18399
8111f674:	8111f598 	cmpnei	r4,r16,18390
8111f678:	8111f5b0 	cmpltui	r4,r16,18390
8111f67c:	8111f5b0 	cmpltui	r4,r16,18390
8111f680:	8111f6f8 	rdprs	r4,r16,18395
8111f684:	8111f598 	cmpnei	r4,r16,18390
8111f688:	8111f80c 	andi	r4,r16,18400
8111f68c:	8111f80c 	andi	r4,r16,18400
8111f690:	8111f80c 	andi	r4,r16,18400
8111f694:	8111f824 	muli	r4,r16,18400
8111f698:	8809883a 	mov	r4,r17
8111f69c:	11214080 	call	81121408 <__clzsi2>
8111f6a0:	10fffec4 	addi	r3,r2,-5
8111f6a4:	10801d84 	addi	r2,r2,118
8111f6a8:	88e2983a 	sll	r17,r17,r3
8111f6ac:	008dc83a 	sub	r6,zero,r2
8111f6b0:	000b883a 	mov	r5,zero
8111f6b4:	003f9906 	br	8111f51c <__reset+0xfb0ff51c>
8111f6b8:	014000c4 	movi	r5,3
8111f6bc:	003f9706 	br	8111f51c <__reset+0xfb0ff51c>
8111f6c0:	9009883a 	mov	r4,r18
8111f6c4:	d9400015 	stw	r5,0(sp)
8111f6c8:	11214080 	call	81121408 <__clzsi2>
8111f6cc:	10fffec4 	addi	r3,r2,-5
8111f6d0:	11801d84 	addi	r6,r2,118
8111f6d4:	90e4983a 	sll	r18,r18,r3
8111f6d8:	01a9c83a 	sub	r20,zero,r6
8111f6dc:	0021883a 	mov	r16,zero
8111f6e0:	002f883a 	mov	r23,zero
8111f6e4:	d9400017 	ldw	r5,0(sp)
8111f6e8:	003f7e06 	br	8111f4e4 <__reset+0xfb0ff4e4>
8111f6ec:	04000304 	movi	r16,12
8111f6f0:	05c000c4 	movi	r23,3
8111f6f4:	003f7b06 	br	8111f4e4 <__reset+0xfb0ff4e4>
8111f6f8:	01802034 	movhi	r6,128
8111f6fc:	000f883a 	mov	r7,zero
8111f700:	31bfffc4 	addi	r6,r6,-1
8111f704:	013fffc4 	movi	r4,-1
8111f708:	003fac06 	br	8111f5bc <__reset+0xfb0ff5bc>
8111f70c:	01400044 	movi	r5,1
8111f710:	2909c83a 	sub	r4,r5,r4
8111f714:	00c006c4 	movi	r3,27
8111f718:	19004b0e 	bge	r3,r4,8111f848 <__divsf3+0x3d4>
8111f71c:	114e703a 	and	r7,r2,r5
8111f720:	0009883a 	mov	r4,zero
8111f724:	000d883a 	mov	r6,zero
8111f728:	003fa406 	br	8111f5bc <__reset+0xfb0ff5bc>
8111f72c:	9006917a 	slli	r3,r18,5
8111f730:	8822917a 	slli	r17,r17,5
8111f734:	1c40372e 	bgeu	r3,r17,8111f814 <__divsf3+0x3a0>
8111f738:	31bfffc4 	addi	r6,r6,-1
8111f73c:	010006c4 	movi	r4,27
8111f740:	000b883a 	mov	r5,zero
8111f744:	180f883a 	mov	r7,r3
8111f748:	294b883a 	add	r5,r5,r5
8111f74c:	18c7883a 	add	r3,r3,r3
8111f750:	38000116 	blt	r7,zero,8111f758 <__divsf3+0x2e4>
8111f754:	1c400236 	bltu	r3,r17,8111f760 <__divsf3+0x2ec>
8111f758:	1c47c83a 	sub	r3,r3,r17
8111f75c:	29400054 	ori	r5,r5,1
8111f760:	213fffc4 	addi	r4,r4,-1
8111f764:	203ff71e 	bne	r4,zero,8111f744 <__reset+0xfb0ff744>
8111f768:	1806c03a 	cmpne	r3,r3,zero
8111f76c:	1962b03a 	or	r17,r3,r5
8111f770:	31001fc4 	addi	r4,r6,127
8111f774:	013fe50e 	bge	zero,r4,8111f70c <__reset+0xfb0ff70c>
8111f778:	88c001cc 	andi	r3,r17,7
8111f77c:	18000426 	beq	r3,zero,8111f790 <__divsf3+0x31c>
8111f780:	88c003cc 	andi	r3,r17,15
8111f784:	01400104 	movi	r5,4
8111f788:	19400126 	beq	r3,r5,8111f790 <__divsf3+0x31c>
8111f78c:	8963883a 	add	r17,r17,r5
8111f790:	88c2002c 	andhi	r3,r17,2048
8111f794:	18000426 	beq	r3,zero,8111f7a8 <__divsf3+0x334>
8111f798:	00fe0034 	movhi	r3,63488
8111f79c:	18ffffc4 	addi	r3,r3,-1
8111f7a0:	31002004 	addi	r4,r6,128
8111f7a4:	88e2703a 	and	r17,r17,r3
8111f7a8:	00c03f84 	movi	r3,254
8111f7ac:	193f8016 	blt	r3,r4,8111f5b0 <__reset+0xfb0ff5b0>
8111f7b0:	880c91ba 	slli	r6,r17,6
8111f7b4:	11c0004c 	andi	r7,r2,1
8111f7b8:	300cd27a 	srli	r6,r6,9
8111f7bc:	003f7f06 	br	8111f5bc <__reset+0xfb0ff5bc>
8111f7c0:	9080102c 	andhi	r2,r18,64
8111f7c4:	10000226 	beq	r2,zero,8111f7d0 <__divsf3+0x35c>
8111f7c8:	8880102c 	andhi	r2,r17,64
8111f7cc:	10001826 	beq	r2,zero,8111f830 <__divsf3+0x3bc>
8111f7d0:	00802034 	movhi	r2,128
8111f7d4:	91801034 	orhi	r6,r18,64
8111f7d8:	10bfffc4 	addi	r2,r2,-1
8111f7dc:	980f883a 	mov	r7,r19
8111f7e0:	308c703a 	and	r6,r6,r2
8111f7e4:	003fc706 	br	8111f704 <__reset+0xfb0ff704>
8111f7e8:	008000c4 	movi	r2,3
8111f7ec:	b8802d26 	beq	r23,r2,8111f8a4 <__divsf3+0x430>
8111f7f0:	00c00044 	movi	r3,1
8111f7f4:	b005883a 	mov	r2,r22
8111f7f8:	b8ffdd1e 	bne	r23,r3,8111f770 <__reset+0xfb0ff770>
8111f7fc:	11c0004c 	andi	r7,r2,1
8111f800:	0009883a 	mov	r4,zero
8111f804:	000d883a 	mov	r6,zero
8111f808:	003f6c06 	br	8111f5bc <__reset+0xfb0ff5bc>
8111f80c:	9023883a 	mov	r17,r18
8111f810:	003f6406 	br	8111f5a4 <__reset+0xfb0ff5a4>
8111f814:	1c47c83a 	sub	r3,r3,r17
8111f818:	01000684 	movi	r4,26
8111f81c:	01400044 	movi	r5,1
8111f820:	003fc806 	br	8111f744 <__reset+0xfb0ff744>
8111f824:	9080102c 	andhi	r2,r18,64
8111f828:	103fe926 	beq	r2,zero,8111f7d0 <__reset+0xfb0ff7d0>
8111f82c:	0023883a 	mov	r17,zero
8111f830:	00802034 	movhi	r2,128
8111f834:	89801034 	orhi	r6,r17,64
8111f838:	10bfffc4 	addi	r2,r2,-1
8111f83c:	a80f883a 	mov	r7,r21
8111f840:	308c703a 	and	r6,r6,r2
8111f844:	003faf06 	br	8111f704 <__reset+0xfb0ff704>
8111f848:	01c00804 	movi	r7,32
8111f84c:	390fc83a 	sub	r7,r7,r4
8111f850:	89ce983a 	sll	r7,r17,r7
8111f854:	890ad83a 	srl	r5,r17,r4
8111f858:	380ec03a 	cmpne	r7,r7,zero
8111f85c:	29cab03a 	or	r5,r5,r7
8111f860:	28c001cc 	andi	r3,r5,7
8111f864:	18000426 	beq	r3,zero,8111f878 <__divsf3+0x404>
8111f868:	28c003cc 	andi	r3,r5,15
8111f86c:	01000104 	movi	r4,4
8111f870:	19000126 	beq	r3,r4,8111f878 <__divsf3+0x404>
8111f874:	290b883a 	add	r5,r5,r4
8111f878:	28c1002c 	andhi	r3,r5,1024
8111f87c:	18000426 	beq	r3,zero,8111f890 <__divsf3+0x41c>
8111f880:	11c0004c 	andi	r7,r2,1
8111f884:	01000044 	movi	r4,1
8111f888:	000d883a 	mov	r6,zero
8111f88c:	003f4b06 	br	8111f5bc <__reset+0xfb0ff5bc>
8111f890:	280a91ba 	slli	r5,r5,6
8111f894:	11c0004c 	andi	r7,r2,1
8111f898:	0009883a 	mov	r4,zero
8111f89c:	280cd27a 	srli	r6,r5,9
8111f8a0:	003f4606 	br	8111f5bc <__reset+0xfb0ff5bc>
8111f8a4:	00802034 	movhi	r2,128
8111f8a8:	89801034 	orhi	r6,r17,64
8111f8ac:	10bfffc4 	addi	r2,r2,-1
8111f8b0:	b00f883a 	mov	r7,r22
8111f8b4:	308c703a 	and	r6,r6,r2
8111f8b8:	003f9206 	br	8111f704 <__reset+0xfb0ff704>

8111f8bc <__mulsf3>:
8111f8bc:	defff504 	addi	sp,sp,-44
8111f8c0:	de00012e 	bgeu	sp,et,8111f8c8 <__mulsf3+0xc>
8111f8c4:	003b68fa 	trap	3
8111f8c8:	dc000115 	stw	r16,4(sp)
8111f8cc:	2020d5fa 	srli	r16,r4,23
8111f8d0:	dd400615 	stw	r21,24(sp)
8111f8d4:	202ad7fa 	srli	r21,r4,31
8111f8d8:	dc800315 	stw	r18,12(sp)
8111f8dc:	04802034 	movhi	r18,128
8111f8e0:	df000915 	stw	fp,36(sp)
8111f8e4:	dd000515 	stw	r20,20(sp)
8111f8e8:	94bfffc4 	addi	r18,r18,-1
8111f8ec:	dfc00a15 	stw	ra,40(sp)
8111f8f0:	ddc00815 	stw	r23,32(sp)
8111f8f4:	dd800715 	stw	r22,28(sp)
8111f8f8:	dcc00415 	stw	r19,16(sp)
8111f8fc:	dc400215 	stw	r17,8(sp)
8111f900:	84003fcc 	andi	r16,r16,255
8111f904:	9124703a 	and	r18,r18,r4
8111f908:	a829883a 	mov	r20,r21
8111f90c:	af003fcc 	andi	fp,r21,255
8111f910:	80005426 	beq	r16,zero,8111fa64 <__mulsf3+0x1a8>
8111f914:	00803fc4 	movi	r2,255
8111f918:	80802f26 	beq	r16,r2,8111f9d8 <__mulsf3+0x11c>
8111f91c:	91002034 	orhi	r4,r18,128
8111f920:	202490fa 	slli	r18,r4,3
8111f924:	843fe044 	addi	r16,r16,-127
8111f928:	0023883a 	mov	r17,zero
8111f92c:	002f883a 	mov	r23,zero
8111f930:	2804d5fa 	srli	r2,r5,23
8111f934:	282cd7fa 	srli	r22,r5,31
8111f938:	01002034 	movhi	r4,128
8111f93c:	213fffc4 	addi	r4,r4,-1
8111f940:	10803fcc 	andi	r2,r2,255
8111f944:	2166703a 	and	r19,r4,r5
8111f948:	b1803fcc 	andi	r6,r22,255
8111f94c:	10004c26 	beq	r2,zero,8111fa80 <__mulsf3+0x1c4>
8111f950:	00c03fc4 	movi	r3,255
8111f954:	10c04726 	beq	r2,r3,8111fa74 <__mulsf3+0x1b8>
8111f958:	99002034 	orhi	r4,r19,128
8111f95c:	202690fa 	slli	r19,r4,3
8111f960:	10bfe044 	addi	r2,r2,-127
8111f964:	0007883a 	mov	r3,zero
8111f968:	80a1883a 	add	r16,r16,r2
8111f96c:	010003c4 	movi	r4,15
8111f970:	1c44b03a 	or	r2,r3,r17
8111f974:	b56af03a 	xor	r21,r22,r21
8111f978:	81c00044 	addi	r7,r16,1
8111f97c:	20806b36 	bltu	r4,r2,8111fb2c <__mulsf3+0x270>
8111f980:	100490ba 	slli	r2,r2,2
8111f984:	012044b4 	movhi	r4,33042
8111f988:	213e6604 	addi	r4,r4,-1640
8111f98c:	1105883a 	add	r2,r2,r4
8111f990:	10800017 	ldw	r2,0(r2)
8111f994:	1000683a 	jmp	r2
8111f998:	8111fb2c 	andhi	r4,r16,18412
8111f99c:	8111f9ec 	andhi	r4,r16,18407
8111f9a0:	8111f9ec 	andhi	r4,r16,18407
8111f9a4:	8111f9e8 	cmpgeui	r4,r16,18407
8111f9a8:	8111fb10 	cmplti	r4,r16,18412
8111f9ac:	8111fb10 	cmplti	r4,r16,18412
8111f9b0:	8111fafc 	xorhi	r4,r16,18411
8111f9b4:	8111f9e8 	cmpgeui	r4,r16,18407
8111f9b8:	8111fb10 	cmplti	r4,r16,18412
8111f9bc:	8111fafc 	xorhi	r4,r16,18411
8111f9c0:	8111fb10 	cmplti	r4,r16,18412
8111f9c4:	8111f9e8 	cmpgeui	r4,r16,18407
8111f9c8:	8111fb1c 	xori	r4,r16,18412
8111f9cc:	8111fb1c 	xori	r4,r16,18412
8111f9d0:	8111fb1c 	xori	r4,r16,18412
8111f9d4:	8111fbf8 	rdprs	r4,r16,18415
8111f9d8:	90003b1e 	bne	r18,zero,8111fac8 <__mulsf3+0x20c>
8111f9dc:	04400204 	movi	r17,8
8111f9e0:	05c00084 	movi	r23,2
8111f9e4:	003fd206 	br	8111f930 <__reset+0xfb0ff930>
8111f9e8:	302b883a 	mov	r21,r6
8111f9ec:	00800084 	movi	r2,2
8111f9f0:	18802626 	beq	r3,r2,8111fa8c <__mulsf3+0x1d0>
8111f9f4:	008000c4 	movi	r2,3
8111f9f8:	1880ab26 	beq	r3,r2,8111fca8 <__mulsf3+0x3ec>
8111f9fc:	00800044 	movi	r2,1
8111fa00:	1880a21e 	bne	r3,r2,8111fc8c <__mulsf3+0x3d0>
8111fa04:	a829883a 	mov	r20,r21
8111fa08:	0007883a 	mov	r3,zero
8111fa0c:	0009883a 	mov	r4,zero
8111fa10:	18803fcc 	andi	r2,r3,255
8111fa14:	100695fa 	slli	r3,r2,23
8111fa18:	a0803fcc 	andi	r2,r20,255
8111fa1c:	100a97fa 	slli	r5,r2,31
8111fa20:	00802034 	movhi	r2,128
8111fa24:	10bfffc4 	addi	r2,r2,-1
8111fa28:	2084703a 	and	r2,r4,r2
8111fa2c:	10c4b03a 	or	r2,r2,r3
8111fa30:	1144b03a 	or	r2,r2,r5
8111fa34:	dfc00a17 	ldw	ra,40(sp)
8111fa38:	df000917 	ldw	fp,36(sp)
8111fa3c:	ddc00817 	ldw	r23,32(sp)
8111fa40:	dd800717 	ldw	r22,28(sp)
8111fa44:	dd400617 	ldw	r21,24(sp)
8111fa48:	dd000517 	ldw	r20,20(sp)
8111fa4c:	dcc00417 	ldw	r19,16(sp)
8111fa50:	dc800317 	ldw	r18,12(sp)
8111fa54:	dc400217 	ldw	r17,8(sp)
8111fa58:	dc000117 	ldw	r16,4(sp)
8111fa5c:	dec00b04 	addi	sp,sp,44
8111fa60:	f800283a 	ret
8111fa64:	90000d1e 	bne	r18,zero,8111fa9c <__mulsf3+0x1e0>
8111fa68:	04400104 	movi	r17,4
8111fa6c:	05c00044 	movi	r23,1
8111fa70:	003faf06 	br	8111f930 <__reset+0xfb0ff930>
8111fa74:	9806c03a 	cmpne	r3,r19,zero
8111fa78:	18c00084 	addi	r3,r3,2
8111fa7c:	003fba06 	br	8111f968 <__reset+0xfb0ff968>
8111fa80:	9800141e 	bne	r19,zero,8111fad4 <__mulsf3+0x218>
8111fa84:	00c00044 	movi	r3,1
8111fa88:	003fb706 	br	8111f968 <__reset+0xfb0ff968>
8111fa8c:	a829883a 	mov	r20,r21
8111fa90:	00ffffc4 	movi	r3,-1
8111fa94:	0009883a 	mov	r4,zero
8111fa98:	003fdd06 	br	8111fa10 <__reset+0xfb0ffa10>
8111fa9c:	9009883a 	mov	r4,r18
8111faa0:	d9400015 	stw	r5,0(sp)
8111faa4:	11214080 	call	81121408 <__clzsi2>
8111faa8:	10fffec4 	addi	r3,r2,-5
8111faac:	10801d84 	addi	r2,r2,118
8111fab0:	90e4983a 	sll	r18,r18,r3
8111fab4:	00a1c83a 	sub	r16,zero,r2
8111fab8:	0023883a 	mov	r17,zero
8111fabc:	002f883a 	mov	r23,zero
8111fac0:	d9400017 	ldw	r5,0(sp)
8111fac4:	003f9a06 	br	8111f930 <__reset+0xfb0ff930>
8111fac8:	04400304 	movi	r17,12
8111facc:	05c000c4 	movi	r23,3
8111fad0:	003f9706 	br	8111f930 <__reset+0xfb0ff930>
8111fad4:	9809883a 	mov	r4,r19
8111fad8:	d9800015 	stw	r6,0(sp)
8111fadc:	11214080 	call	81121408 <__clzsi2>
8111fae0:	10fffec4 	addi	r3,r2,-5
8111fae4:	10801d84 	addi	r2,r2,118
8111fae8:	98e6983a 	sll	r19,r19,r3
8111faec:	0085c83a 	sub	r2,zero,r2
8111faf0:	0007883a 	mov	r3,zero
8111faf4:	d9800017 	ldw	r6,0(sp)
8111faf8:	003f9b06 	br	8111f968 <__reset+0xfb0ff968>
8111fafc:	01002034 	movhi	r4,128
8111fb00:	0029883a 	mov	r20,zero
8111fb04:	213fffc4 	addi	r4,r4,-1
8111fb08:	00ffffc4 	movi	r3,-1
8111fb0c:	003fc006 	br	8111fa10 <__reset+0xfb0ffa10>
8111fb10:	9027883a 	mov	r19,r18
8111fb14:	b807883a 	mov	r3,r23
8111fb18:	003fb406 	br	8111f9ec <__reset+0xfb0ff9ec>
8111fb1c:	9027883a 	mov	r19,r18
8111fb20:	e02b883a 	mov	r21,fp
8111fb24:	b807883a 	mov	r3,r23
8111fb28:	003fb006 	br	8111f9ec <__reset+0xfb0ff9ec>
8111fb2c:	9004d43a 	srli	r2,r18,16
8111fb30:	9810d43a 	srli	r8,r19,16
8111fb34:	94bfffcc 	andi	r18,r18,65535
8111fb38:	993fffcc 	andi	r4,r19,65535
8111fb3c:	910d383a 	mul	r6,r18,r4
8111fb40:	20a7383a 	mul	r19,r4,r2
8111fb44:	9225383a 	mul	r18,r18,r8
8111fb48:	3006d43a 	srli	r3,r6,16
8111fb4c:	1211383a 	mul	r8,r2,r8
8111fb50:	94e5883a 	add	r18,r18,r19
8111fb54:	1c87883a 	add	r3,r3,r18
8111fb58:	1cc0022e 	bgeu	r3,r19,8111fb64 <__mulsf3+0x2a8>
8111fb5c:	00800074 	movhi	r2,1
8111fb60:	4091883a 	add	r8,r8,r2
8111fb64:	1804943a 	slli	r2,r3,16
8111fb68:	31bfffcc 	andi	r6,r6,65535
8111fb6c:	1806d43a 	srli	r3,r3,16
8111fb70:	1185883a 	add	r2,r2,r6
8111fb74:	102691ba 	slli	r19,r2,6
8111fb78:	1a07883a 	add	r3,r3,r8
8111fb7c:	1004d6ba 	srli	r2,r2,26
8111fb80:	180891ba 	slli	r4,r3,6
8111fb84:	9826c03a 	cmpne	r19,r19,zero
8111fb88:	9884b03a 	or	r2,r19,r2
8111fb8c:	1126b03a 	or	r19,r2,r4
8111fb90:	9882002c 	andhi	r2,r19,2048
8111fb94:	10000426 	beq	r2,zero,8111fba8 <__mulsf3+0x2ec>
8111fb98:	9804d07a 	srli	r2,r19,1
8111fb9c:	9900004c 	andi	r4,r19,1
8111fba0:	3821883a 	mov	r16,r7
8111fba4:	1126b03a 	or	r19,r2,r4
8111fba8:	80c01fc4 	addi	r3,r16,127
8111fbac:	00c0210e 	bge	zero,r3,8111fc34 <__mulsf3+0x378>
8111fbb0:	988001cc 	andi	r2,r19,7
8111fbb4:	10000426 	beq	r2,zero,8111fbc8 <__mulsf3+0x30c>
8111fbb8:	988003cc 	andi	r2,r19,15
8111fbbc:	01000104 	movi	r4,4
8111fbc0:	11000126 	beq	r2,r4,8111fbc8 <__mulsf3+0x30c>
8111fbc4:	9927883a 	add	r19,r19,r4
8111fbc8:	9882002c 	andhi	r2,r19,2048
8111fbcc:	10000426 	beq	r2,zero,8111fbe0 <__mulsf3+0x324>
8111fbd0:	00be0034 	movhi	r2,63488
8111fbd4:	10bfffc4 	addi	r2,r2,-1
8111fbd8:	80c02004 	addi	r3,r16,128
8111fbdc:	98a6703a 	and	r19,r19,r2
8111fbe0:	00803f84 	movi	r2,254
8111fbe4:	10ffa916 	blt	r2,r3,8111fa8c <__reset+0xfb0ffa8c>
8111fbe8:	980891ba 	slli	r4,r19,6
8111fbec:	a829883a 	mov	r20,r21
8111fbf0:	2008d27a 	srli	r4,r4,9
8111fbf4:	003f8606 	br	8111fa10 <__reset+0xfb0ffa10>
8111fbf8:	9080102c 	andhi	r2,r18,64
8111fbfc:	10000826 	beq	r2,zero,8111fc20 <__mulsf3+0x364>
8111fc00:	9880102c 	andhi	r2,r19,64
8111fc04:	1000061e 	bne	r2,zero,8111fc20 <__mulsf3+0x364>
8111fc08:	00802034 	movhi	r2,128
8111fc0c:	99001034 	orhi	r4,r19,64
8111fc10:	10bfffc4 	addi	r2,r2,-1
8111fc14:	b029883a 	mov	r20,r22
8111fc18:	2088703a 	and	r4,r4,r2
8111fc1c:	003fba06 	br	8111fb08 <__reset+0xfb0ffb08>
8111fc20:	00802034 	movhi	r2,128
8111fc24:	91001034 	orhi	r4,r18,64
8111fc28:	10bfffc4 	addi	r2,r2,-1
8111fc2c:	2088703a 	and	r4,r4,r2
8111fc30:	003fb506 	br	8111fb08 <__reset+0xfb0ffb08>
8111fc34:	00800044 	movi	r2,1
8111fc38:	10c7c83a 	sub	r3,r2,r3
8111fc3c:	008006c4 	movi	r2,27
8111fc40:	10ff7016 	blt	r2,r3,8111fa04 <__reset+0xfb0ffa04>
8111fc44:	00800804 	movi	r2,32
8111fc48:	10c5c83a 	sub	r2,r2,r3
8111fc4c:	9884983a 	sll	r2,r19,r2
8111fc50:	98c6d83a 	srl	r3,r19,r3
8111fc54:	1004c03a 	cmpne	r2,r2,zero
8111fc58:	1884b03a 	or	r2,r3,r2
8111fc5c:	10c001cc 	andi	r3,r2,7
8111fc60:	18000426 	beq	r3,zero,8111fc74 <__mulsf3+0x3b8>
8111fc64:	10c003cc 	andi	r3,r2,15
8111fc68:	01000104 	movi	r4,4
8111fc6c:	19000126 	beq	r3,r4,8111fc74 <__mulsf3+0x3b8>
8111fc70:	1105883a 	add	r2,r2,r4
8111fc74:	10c1002c 	andhi	r3,r2,1024
8111fc78:	18000626 	beq	r3,zero,8111fc94 <__mulsf3+0x3d8>
8111fc7c:	a829883a 	mov	r20,r21
8111fc80:	00c00044 	movi	r3,1
8111fc84:	0009883a 	mov	r4,zero
8111fc88:	003f6106 	br	8111fa10 <__reset+0xfb0ffa10>
8111fc8c:	3821883a 	mov	r16,r7
8111fc90:	003fc506 	br	8111fba8 <__reset+0xfb0ffba8>
8111fc94:	100491ba 	slli	r2,r2,6
8111fc98:	a829883a 	mov	r20,r21
8111fc9c:	0007883a 	mov	r3,zero
8111fca0:	1008d27a 	srli	r4,r2,9
8111fca4:	003f5a06 	br	8111fa10 <__reset+0xfb0ffa10>
8111fca8:	00802034 	movhi	r2,128
8111fcac:	99001034 	orhi	r4,r19,64
8111fcb0:	10bfffc4 	addi	r2,r2,-1
8111fcb4:	a829883a 	mov	r20,r21
8111fcb8:	2088703a 	and	r4,r4,r2
8111fcbc:	003f9206 	br	8111fb08 <__reset+0xfb0ffb08>

8111fcc0 <__floatsisf>:
8111fcc0:	defffd04 	addi	sp,sp,-12
8111fcc4:	de00012e 	bgeu	sp,et,8111fccc <__floatsisf+0xc>
8111fcc8:	003b68fa 	trap	3
8111fccc:	dfc00215 	stw	ra,8(sp)
8111fcd0:	dc400115 	stw	r17,4(sp)
8111fcd4:	dc000015 	stw	r16,0(sp)
8111fcd8:	20003526 	beq	r4,zero,8111fdb0 <__floatsisf+0xf0>
8111fcdc:	2021883a 	mov	r16,r4
8111fce0:	2022d7fa 	srli	r17,r4,31
8111fce4:	20003616 	blt	r4,zero,8111fdc0 <__floatsisf+0x100>
8111fce8:	8009883a 	mov	r4,r16
8111fcec:	11214080 	call	81121408 <__clzsi2>
8111fcf0:	00c02784 	movi	r3,158
8111fcf4:	1887c83a 	sub	r3,r3,r2
8111fcf8:	01002584 	movi	r4,150
8111fcfc:	20c01416 	blt	r4,r3,8111fd50 <__floatsisf+0x90>
8111fd00:	20c9c83a 	sub	r4,r4,r3
8111fd04:	8120983a 	sll	r16,r16,r4
8111fd08:	00802034 	movhi	r2,128
8111fd0c:	10bfffc4 	addi	r2,r2,-1
8111fd10:	8809883a 	mov	r4,r17
8111fd14:	80a0703a 	and	r16,r16,r2
8111fd18:	18803fcc 	andi	r2,r3,255
8111fd1c:	100695fa 	slli	r3,r2,23
8111fd20:	20803fcc 	andi	r2,r4,255
8111fd24:	100897fa 	slli	r4,r2,31
8111fd28:	00802034 	movhi	r2,128
8111fd2c:	10bfffc4 	addi	r2,r2,-1
8111fd30:	8084703a 	and	r2,r16,r2
8111fd34:	10c4b03a 	or	r2,r2,r3
8111fd38:	1104b03a 	or	r2,r2,r4
8111fd3c:	dfc00217 	ldw	ra,8(sp)
8111fd40:	dc400117 	ldw	r17,4(sp)
8111fd44:	dc000017 	ldw	r16,0(sp)
8111fd48:	dec00304 	addi	sp,sp,12
8111fd4c:	f800283a 	ret
8111fd50:	01002644 	movi	r4,153
8111fd54:	20c01c16 	blt	r4,r3,8111fdc8 <__floatsisf+0x108>
8111fd58:	20c9c83a 	sub	r4,r4,r3
8111fd5c:	8120983a 	sll	r16,r16,r4
8111fd60:	013f0034 	movhi	r4,64512
8111fd64:	213fffc4 	addi	r4,r4,-1
8111fd68:	814001cc 	andi	r5,r16,7
8111fd6c:	8108703a 	and	r4,r16,r4
8111fd70:	28000426 	beq	r5,zero,8111fd84 <__floatsisf+0xc4>
8111fd74:	840003cc 	andi	r16,r16,15
8111fd78:	01400104 	movi	r5,4
8111fd7c:	81400126 	beq	r16,r5,8111fd84 <__floatsisf+0xc4>
8111fd80:	2149883a 	add	r4,r4,r5
8111fd84:	2141002c 	andhi	r5,r4,1024
8111fd88:	28000526 	beq	r5,zero,8111fda0 <__floatsisf+0xe0>
8111fd8c:	00c027c4 	movi	r3,159
8111fd90:	1887c83a 	sub	r3,r3,r2
8111fd94:	00bf0034 	movhi	r2,64512
8111fd98:	10bfffc4 	addi	r2,r2,-1
8111fd9c:	2088703a 	and	r4,r4,r2
8111fda0:	202091ba 	slli	r16,r4,6
8111fda4:	8809883a 	mov	r4,r17
8111fda8:	8020d27a 	srli	r16,r16,9
8111fdac:	003fda06 	br	8111fd18 <__reset+0xfb0ffd18>
8111fdb0:	0009883a 	mov	r4,zero
8111fdb4:	0007883a 	mov	r3,zero
8111fdb8:	0021883a 	mov	r16,zero
8111fdbc:	003fd606 	br	8111fd18 <__reset+0xfb0ffd18>
8111fdc0:	0121c83a 	sub	r16,zero,r4
8111fdc4:	003fc806 	br	8111fce8 <__reset+0xfb0ffce8>
8111fdc8:	01002e44 	movi	r4,185
8111fdcc:	20c9c83a 	sub	r4,r4,r3
8111fdd0:	01400144 	movi	r5,5
8111fdd4:	8108983a 	sll	r4,r16,r4
8111fdd8:	288bc83a 	sub	r5,r5,r2
8111fddc:	8160d83a 	srl	r16,r16,r5
8111fde0:	2008c03a 	cmpne	r4,r4,zero
8111fde4:	8120b03a 	or	r16,r16,r4
8111fde8:	003fdd06 	br	8111fd60 <__reset+0xfb0ffd60>

8111fdec <__floatunsisf>:
8111fdec:	defffe04 	addi	sp,sp,-8
8111fdf0:	de00012e 	bgeu	sp,et,8111fdf8 <__floatunsisf+0xc>
8111fdf4:	003b68fa 	trap	3
8111fdf8:	dfc00115 	stw	ra,4(sp)
8111fdfc:	dc000015 	stw	r16,0(sp)
8111fe00:	20002c26 	beq	r4,zero,8111feb4 <__floatunsisf+0xc8>
8111fe04:	2021883a 	mov	r16,r4
8111fe08:	11214080 	call	81121408 <__clzsi2>
8111fe0c:	00c02784 	movi	r3,158
8111fe10:	1887c83a 	sub	r3,r3,r2
8111fe14:	01002584 	movi	r4,150
8111fe18:	20c00f16 	blt	r4,r3,8111fe58 <__floatunsisf+0x6c>
8111fe1c:	20c9c83a 	sub	r4,r4,r3
8111fe20:	8108983a 	sll	r4,r16,r4
8111fe24:	00802034 	movhi	r2,128
8111fe28:	10bfffc4 	addi	r2,r2,-1
8111fe2c:	2088703a 	and	r4,r4,r2
8111fe30:	18803fcc 	andi	r2,r3,255
8111fe34:	100695fa 	slli	r3,r2,23
8111fe38:	00802034 	movhi	r2,128
8111fe3c:	10bfffc4 	addi	r2,r2,-1
8111fe40:	2084703a 	and	r2,r4,r2
8111fe44:	10c4b03a 	or	r2,r2,r3
8111fe48:	dfc00117 	ldw	ra,4(sp)
8111fe4c:	dc000017 	ldw	r16,0(sp)
8111fe50:	dec00204 	addi	sp,sp,8
8111fe54:	f800283a 	ret
8111fe58:	01002644 	movi	r4,153
8111fe5c:	20c01816 	blt	r4,r3,8111fec0 <__floatunsisf+0xd4>
8111fe60:	20c9c83a 	sub	r4,r4,r3
8111fe64:	8108983a 	sll	r4,r16,r4
8111fe68:	017f0034 	movhi	r5,64512
8111fe6c:	297fffc4 	addi	r5,r5,-1
8111fe70:	218001cc 	andi	r6,r4,7
8111fe74:	214a703a 	and	r5,r4,r5
8111fe78:	30000426 	beq	r6,zero,8111fe8c <__floatunsisf+0xa0>
8111fe7c:	210003cc 	andi	r4,r4,15
8111fe80:	01800104 	movi	r6,4
8111fe84:	21800126 	beq	r4,r6,8111fe8c <__floatunsisf+0xa0>
8111fe88:	298b883a 	add	r5,r5,r6
8111fe8c:	2901002c 	andhi	r4,r5,1024
8111fe90:	20000526 	beq	r4,zero,8111fea8 <__floatunsisf+0xbc>
8111fe94:	00c027c4 	movi	r3,159
8111fe98:	1887c83a 	sub	r3,r3,r2
8111fe9c:	00bf0034 	movhi	r2,64512
8111fea0:	10bfffc4 	addi	r2,r2,-1
8111fea4:	288a703a 	and	r5,r5,r2
8111fea8:	280891ba 	slli	r4,r5,6
8111feac:	2008d27a 	srli	r4,r4,9
8111feb0:	003fdf06 	br	8111fe30 <__reset+0xfb0ffe30>
8111feb4:	0007883a 	mov	r3,zero
8111feb8:	0009883a 	mov	r4,zero
8111febc:	003fdc06 	br	8111fe30 <__reset+0xfb0ffe30>
8111fec0:	01402e44 	movi	r5,185
8111fec4:	28cbc83a 	sub	r5,r5,r3
8111fec8:	01000144 	movi	r4,5
8111fecc:	2089c83a 	sub	r4,r4,r2
8111fed0:	814a983a 	sll	r5,r16,r5
8111fed4:	8108d83a 	srl	r4,r16,r4
8111fed8:	2820c03a 	cmpne	r16,r5,zero
8111fedc:	2408b03a 	or	r4,r4,r16
8111fee0:	003fe106 	br	8111fe68 <__reset+0xfb0ffe68>

8111fee4 <__gedf2>:
8111fee4:	2804d53a 	srli	r2,r5,20
8111fee8:	3806d53a 	srli	r3,r7,20
8111feec:	02000434 	movhi	r8,16
8111fef0:	423fffc4 	addi	r8,r8,-1
8111fef4:	1081ffcc 	andi	r2,r2,2047
8111fef8:	0241ffc4 	movi	r9,2047
8111fefc:	2a14703a 	and	r10,r5,r8
8111ff00:	18c1ffcc 	andi	r3,r3,2047
8111ff04:	3a10703a 	and	r8,r7,r8
8111ff08:	280ad7fa 	srli	r5,r5,31
8111ff0c:	380ed7fa 	srli	r7,r7,31
8111ff10:	12401d26 	beq	r2,r9,8111ff88 <__gedf2+0xa4>
8111ff14:	0241ffc4 	movi	r9,2047
8111ff18:	1a401226 	beq	r3,r9,8111ff64 <__gedf2+0x80>
8111ff1c:	1000081e 	bne	r2,zero,8111ff40 <__gedf2+0x5c>
8111ff20:	2296b03a 	or	r11,r4,r10
8111ff24:	5813003a 	cmpeq	r9,r11,zero
8111ff28:	1800091e 	bne	r3,zero,8111ff50 <__gedf2+0x6c>
8111ff2c:	3218b03a 	or	r12,r6,r8
8111ff30:	6000071e 	bne	r12,zero,8111ff50 <__gedf2+0x6c>
8111ff34:	0005883a 	mov	r2,zero
8111ff38:	5800101e 	bne	r11,zero,8111ff7c <__gedf2+0x98>
8111ff3c:	f800283a 	ret
8111ff40:	18000c1e 	bne	r3,zero,8111ff74 <__gedf2+0x90>
8111ff44:	3212b03a 	or	r9,r6,r8
8111ff48:	48000c26 	beq	r9,zero,8111ff7c <__gedf2+0x98>
8111ff4c:	0013883a 	mov	r9,zero
8111ff50:	39c03fcc 	andi	r7,r7,255
8111ff54:	48000826 	beq	r9,zero,8111ff78 <__gedf2+0x94>
8111ff58:	38000926 	beq	r7,zero,8111ff80 <__gedf2+0x9c>
8111ff5c:	00800044 	movi	r2,1
8111ff60:	f800283a 	ret
8111ff64:	3212b03a 	or	r9,r6,r8
8111ff68:	483fec26 	beq	r9,zero,8111ff1c <__reset+0xfb0fff1c>
8111ff6c:	00bfff84 	movi	r2,-2
8111ff70:	f800283a 	ret
8111ff74:	39c03fcc 	andi	r7,r7,255
8111ff78:	29c00626 	beq	r5,r7,8111ff94 <__gedf2+0xb0>
8111ff7c:	283ff726 	beq	r5,zero,8111ff5c <__reset+0xfb0fff5c>
8111ff80:	00bfffc4 	movi	r2,-1
8111ff84:	f800283a 	ret
8111ff88:	2292b03a 	or	r9,r4,r10
8111ff8c:	483fe126 	beq	r9,zero,8111ff14 <__reset+0xfb0fff14>
8111ff90:	003ff606 	br	8111ff6c <__reset+0xfb0fff6c>
8111ff94:	18bff916 	blt	r3,r2,8111ff7c <__reset+0xfb0fff7c>
8111ff98:	10c00316 	blt	r2,r3,8111ffa8 <__gedf2+0xc4>
8111ff9c:	42bff736 	bltu	r8,r10,8111ff7c <__reset+0xfb0fff7c>
8111ffa0:	52000326 	beq	r10,r8,8111ffb0 <__gedf2+0xcc>
8111ffa4:	5200042e 	bgeu	r10,r8,8111ffb8 <__gedf2+0xd4>
8111ffa8:	283fec1e 	bne	r5,zero,8111ff5c <__reset+0xfb0fff5c>
8111ffac:	003ff406 	br	8111ff80 <__reset+0xfb0fff80>
8111ffb0:	313ff236 	bltu	r6,r4,8111ff7c <__reset+0xfb0fff7c>
8111ffb4:	21bffc36 	bltu	r4,r6,8111ffa8 <__reset+0xfb0fffa8>
8111ffb8:	0005883a 	mov	r2,zero
8111ffbc:	f800283a 	ret

8111ffc0 <__muldf3>:
8111ffc0:	defff304 	addi	sp,sp,-52
8111ffc4:	2804d53a 	srli	r2,r5,20
8111ffc8:	de00012e 	bgeu	sp,et,8111ffd0 <__muldf3+0x10>
8111ffcc:	003b68fa 	trap	3
8111ffd0:	dd800915 	stw	r22,36(sp)
8111ffd4:	282cd7fa 	srli	r22,r5,31
8111ffd8:	dc000315 	stw	r16,12(sp)
8111ffdc:	04000434 	movhi	r16,16
8111ffe0:	dd400815 	stw	r21,32(sp)
8111ffe4:	dc800515 	stw	r18,20(sp)
8111ffe8:	843fffc4 	addi	r16,r16,-1
8111ffec:	dfc00c15 	stw	ra,48(sp)
8111fff0:	df000b15 	stw	fp,44(sp)
8111fff4:	ddc00a15 	stw	r23,40(sp)
8111fff8:	dd000715 	stw	r20,28(sp)
8111fffc:	dcc00615 	stw	r19,24(sp)
81120000:	dc400415 	stw	r17,16(sp)
81120004:	1481ffcc 	andi	r18,r2,2047
81120008:	2c20703a 	and	r16,r5,r16
8112000c:	b02b883a 	mov	r21,r22
81120010:	b2403fcc 	andi	r9,r22,255
81120014:	90006026 	beq	r18,zero,81120198 <__muldf3+0x1d8>
81120018:	0081ffc4 	movi	r2,2047
8112001c:	2029883a 	mov	r20,r4
81120020:	90803626 	beq	r18,r2,811200fc <__muldf3+0x13c>
81120024:	80800434 	orhi	r2,r16,16
81120028:	100490fa 	slli	r2,r2,3
8112002c:	2020d77a 	srli	r16,r4,29
81120030:	202890fa 	slli	r20,r4,3
81120034:	94bf0044 	addi	r18,r18,-1023
81120038:	80a0b03a 	or	r16,r16,r2
8112003c:	0027883a 	mov	r19,zero
81120040:	0039883a 	mov	fp,zero
81120044:	3804d53a 	srli	r2,r7,20
81120048:	382ed7fa 	srli	r23,r7,31
8112004c:	04400434 	movhi	r17,16
81120050:	8c7fffc4 	addi	r17,r17,-1
81120054:	1081ffcc 	andi	r2,r2,2047
81120058:	3011883a 	mov	r8,r6
8112005c:	3c62703a 	and	r17,r7,r17
81120060:	ba803fcc 	andi	r10,r23,255
81120064:	10006d26 	beq	r2,zero,8112021c <__muldf3+0x25c>
81120068:	00c1ffc4 	movi	r3,2047
8112006c:	10c06526 	beq	r2,r3,81120204 <__muldf3+0x244>
81120070:	88c00434 	orhi	r3,r17,16
81120074:	180690fa 	slli	r3,r3,3
81120078:	3022d77a 	srli	r17,r6,29
8112007c:	301090fa 	slli	r8,r6,3
81120080:	10bf0044 	addi	r2,r2,-1023
81120084:	88e2b03a 	or	r17,r17,r3
81120088:	000b883a 	mov	r5,zero
8112008c:	9085883a 	add	r2,r18,r2
81120090:	2cc8b03a 	or	r4,r5,r19
81120094:	00c003c4 	movi	r3,15
81120098:	bdacf03a 	xor	r22,r23,r22
8112009c:	12c00044 	addi	r11,r2,1
811200a0:	19009936 	bltu	r3,r4,81120308 <__muldf3+0x348>
811200a4:	200890ba 	slli	r4,r4,2
811200a8:	00e044b4 	movhi	r3,33042
811200ac:	18c02f04 	addi	r3,r3,188
811200b0:	20c9883a 	add	r4,r4,r3
811200b4:	20c00017 	ldw	r3,0(r4)
811200b8:	1800683a 	jmp	r3
811200bc:	81120308 	cmpgei	r4,r16,18444
811200c0:	8112011c 	xori	r4,r16,18436
811200c4:	8112011c 	xori	r4,r16,18436
811200c8:	81120118 	cmpnei	r4,r16,18436
811200cc:	811202e4 	muli	r4,r16,18443
811200d0:	811202e4 	muli	r4,r16,18443
811200d4:	811202cc 	andi	r4,r16,18443
811200d8:	81120118 	cmpnei	r4,r16,18436
811200dc:	811202e4 	muli	r4,r16,18443
811200e0:	811202cc 	andi	r4,r16,18443
811200e4:	811202e4 	muli	r4,r16,18443
811200e8:	81120118 	cmpnei	r4,r16,18436
811200ec:	811202f4 	orhi	r4,r16,18443
811200f0:	811202f4 	orhi	r4,r16,18443
811200f4:	811202f4 	orhi	r4,r16,18443
811200f8:	81120510 	cmplti	r4,r16,18452
811200fc:	2404b03a 	or	r2,r4,r16
81120100:	10006f1e 	bne	r2,zero,811202c0 <__muldf3+0x300>
81120104:	04c00204 	movi	r19,8
81120108:	0021883a 	mov	r16,zero
8112010c:	0029883a 	mov	r20,zero
81120110:	07000084 	movi	fp,2
81120114:	003fcb06 	br	81120044 <__reset+0xfb100044>
81120118:	502d883a 	mov	r22,r10
8112011c:	00800084 	movi	r2,2
81120120:	28805726 	beq	r5,r2,81120280 <__muldf3+0x2c0>
81120124:	008000c4 	movi	r2,3
81120128:	28816626 	beq	r5,r2,811206c4 <__muldf3+0x704>
8112012c:	00800044 	movi	r2,1
81120130:	2881411e 	bne	r5,r2,81120638 <__muldf3+0x678>
81120134:	b02b883a 	mov	r21,r22
81120138:	0005883a 	mov	r2,zero
8112013c:	000b883a 	mov	r5,zero
81120140:	0029883a 	mov	r20,zero
81120144:	1004953a 	slli	r2,r2,20
81120148:	a8c03fcc 	andi	r3,r21,255
8112014c:	04400434 	movhi	r17,16
81120150:	8c7fffc4 	addi	r17,r17,-1
81120154:	180697fa 	slli	r3,r3,31
81120158:	2c4a703a 	and	r5,r5,r17
8112015c:	288ab03a 	or	r5,r5,r2
81120160:	28c6b03a 	or	r3,r5,r3
81120164:	a005883a 	mov	r2,r20
81120168:	dfc00c17 	ldw	ra,48(sp)
8112016c:	df000b17 	ldw	fp,44(sp)
81120170:	ddc00a17 	ldw	r23,40(sp)
81120174:	dd800917 	ldw	r22,36(sp)
81120178:	dd400817 	ldw	r21,32(sp)
8112017c:	dd000717 	ldw	r20,28(sp)
81120180:	dcc00617 	ldw	r19,24(sp)
81120184:	dc800517 	ldw	r18,20(sp)
81120188:	dc400417 	ldw	r17,16(sp)
8112018c:	dc000317 	ldw	r16,12(sp)
81120190:	dec00d04 	addi	sp,sp,52
81120194:	f800283a 	ret
81120198:	2404b03a 	or	r2,r4,r16
8112019c:	2027883a 	mov	r19,r4
811201a0:	10004226 	beq	r2,zero,811202ac <__muldf3+0x2ec>
811201a4:	8000fc26 	beq	r16,zero,81120598 <__muldf3+0x5d8>
811201a8:	8009883a 	mov	r4,r16
811201ac:	d9800215 	stw	r6,8(sp)
811201b0:	d9c00015 	stw	r7,0(sp)
811201b4:	da400115 	stw	r9,4(sp)
811201b8:	11214080 	call	81121408 <__clzsi2>
811201bc:	d9800217 	ldw	r6,8(sp)
811201c0:	d9c00017 	ldw	r7,0(sp)
811201c4:	da400117 	ldw	r9,4(sp)
811201c8:	113ffd44 	addi	r4,r2,-11
811201cc:	00c00704 	movi	r3,28
811201d0:	1900ed16 	blt	r3,r4,81120588 <__muldf3+0x5c8>
811201d4:	00c00744 	movi	r3,29
811201d8:	147ffe04 	addi	r17,r2,-8
811201dc:	1907c83a 	sub	r3,r3,r4
811201e0:	8460983a 	sll	r16,r16,r17
811201e4:	98c6d83a 	srl	r3,r19,r3
811201e8:	9c68983a 	sll	r20,r19,r17
811201ec:	1c20b03a 	or	r16,r3,r16
811201f0:	1080fcc4 	addi	r2,r2,1011
811201f4:	00a5c83a 	sub	r18,zero,r2
811201f8:	0027883a 	mov	r19,zero
811201fc:	0039883a 	mov	fp,zero
81120200:	003f9006 	br	81120044 <__reset+0xfb100044>
81120204:	3446b03a 	or	r3,r6,r17
81120208:	1800261e 	bne	r3,zero,811202a4 <__muldf3+0x2e4>
8112020c:	0023883a 	mov	r17,zero
81120210:	0011883a 	mov	r8,zero
81120214:	01400084 	movi	r5,2
81120218:	003f9c06 	br	8112008c <__reset+0xfb10008c>
8112021c:	3446b03a 	or	r3,r6,r17
81120220:	18001c26 	beq	r3,zero,81120294 <__muldf3+0x2d4>
81120224:	8800ce26 	beq	r17,zero,81120560 <__muldf3+0x5a0>
81120228:	8809883a 	mov	r4,r17
8112022c:	d9800215 	stw	r6,8(sp)
81120230:	da400115 	stw	r9,4(sp)
81120234:	da800015 	stw	r10,0(sp)
81120238:	11214080 	call	81121408 <__clzsi2>
8112023c:	d9800217 	ldw	r6,8(sp)
81120240:	da400117 	ldw	r9,4(sp)
81120244:	da800017 	ldw	r10,0(sp)
81120248:	113ffd44 	addi	r4,r2,-11
8112024c:	00c00704 	movi	r3,28
81120250:	1900bf16 	blt	r3,r4,81120550 <__muldf3+0x590>
81120254:	00c00744 	movi	r3,29
81120258:	123ffe04 	addi	r8,r2,-8
8112025c:	1907c83a 	sub	r3,r3,r4
81120260:	8a22983a 	sll	r17,r17,r8
81120264:	30c6d83a 	srl	r3,r6,r3
81120268:	3210983a 	sll	r8,r6,r8
8112026c:	1c62b03a 	or	r17,r3,r17
81120270:	1080fcc4 	addi	r2,r2,1011
81120274:	0085c83a 	sub	r2,zero,r2
81120278:	000b883a 	mov	r5,zero
8112027c:	003f8306 	br	8112008c <__reset+0xfb10008c>
81120280:	b02b883a 	mov	r21,r22
81120284:	0081ffc4 	movi	r2,2047
81120288:	000b883a 	mov	r5,zero
8112028c:	0029883a 	mov	r20,zero
81120290:	003fac06 	br	81120144 <__reset+0xfb100144>
81120294:	0023883a 	mov	r17,zero
81120298:	0011883a 	mov	r8,zero
8112029c:	01400044 	movi	r5,1
811202a0:	003f7a06 	br	8112008c <__reset+0xfb10008c>
811202a4:	014000c4 	movi	r5,3
811202a8:	003f7806 	br	8112008c <__reset+0xfb10008c>
811202ac:	04c00104 	movi	r19,4
811202b0:	0021883a 	mov	r16,zero
811202b4:	0029883a 	mov	r20,zero
811202b8:	07000044 	movi	fp,1
811202bc:	003f6106 	br	81120044 <__reset+0xfb100044>
811202c0:	04c00304 	movi	r19,12
811202c4:	070000c4 	movi	fp,3
811202c8:	003f5e06 	br	81120044 <__reset+0xfb100044>
811202cc:	01400434 	movhi	r5,16
811202d0:	002b883a 	mov	r21,zero
811202d4:	297fffc4 	addi	r5,r5,-1
811202d8:	053fffc4 	movi	r20,-1
811202dc:	0081ffc4 	movi	r2,2047
811202e0:	003f9806 	br	81120144 <__reset+0xfb100144>
811202e4:	8023883a 	mov	r17,r16
811202e8:	a011883a 	mov	r8,r20
811202ec:	e00b883a 	mov	r5,fp
811202f0:	003f8a06 	br	8112011c <__reset+0xfb10011c>
811202f4:	8023883a 	mov	r17,r16
811202f8:	a011883a 	mov	r8,r20
811202fc:	482d883a 	mov	r22,r9
81120300:	e00b883a 	mov	r5,fp
81120304:	003f8506 	br	8112011c <__reset+0xfb10011c>
81120308:	a00ad43a 	srli	r5,r20,16
8112030c:	401ad43a 	srli	r13,r8,16
81120310:	a53fffcc 	andi	r20,r20,65535
81120314:	423fffcc 	andi	r8,r8,65535
81120318:	4519383a 	mul	r12,r8,r20
8112031c:	4147383a 	mul	r3,r8,r5
81120320:	6d09383a 	mul	r4,r13,r20
81120324:	600cd43a 	srli	r6,r12,16
81120328:	2b5d383a 	mul	r14,r5,r13
8112032c:	20c9883a 	add	r4,r4,r3
81120330:	310d883a 	add	r6,r6,r4
81120334:	30c0022e 	bgeu	r6,r3,81120340 <__muldf3+0x380>
81120338:	00c00074 	movhi	r3,1
8112033c:	70dd883a 	add	r14,r14,r3
81120340:	8826d43a 	srli	r19,r17,16
81120344:	8bffffcc 	andi	r15,r17,65535
81120348:	7d23383a 	mul	r17,r15,r20
8112034c:	7949383a 	mul	r4,r15,r5
81120350:	9d29383a 	mul	r20,r19,r20
81120354:	8814d43a 	srli	r10,r17,16
81120358:	3012943a 	slli	r9,r6,16
8112035c:	a129883a 	add	r20,r20,r4
81120360:	633fffcc 	andi	r12,r12,65535
81120364:	5515883a 	add	r10,r10,r20
81120368:	3006d43a 	srli	r3,r6,16
8112036c:	4b13883a 	add	r9,r9,r12
81120370:	2ccb383a 	mul	r5,r5,r19
81120374:	5100022e 	bgeu	r10,r4,81120380 <__muldf3+0x3c0>
81120378:	01000074 	movhi	r4,1
8112037c:	290b883a 	add	r5,r5,r4
81120380:	802ad43a 	srli	r21,r16,16
81120384:	843fffcc 	andi	r16,r16,65535
81120388:	440d383a 	mul	r6,r8,r16
8112038c:	4565383a 	mul	r18,r8,r21
81120390:	8349383a 	mul	r4,r16,r13
81120394:	500e943a 	slli	r7,r10,16
81120398:	3010d43a 	srli	r8,r6,16
8112039c:	5028d43a 	srli	r20,r10,16
811203a0:	2489883a 	add	r4,r4,r18
811203a4:	8abfffcc 	andi	r10,r17,65535
811203a8:	3a95883a 	add	r10,r7,r10
811203ac:	4119883a 	add	r12,r8,r4
811203b0:	a169883a 	add	r20,r20,r5
811203b4:	1a87883a 	add	r3,r3,r10
811203b8:	6d5b383a 	mul	r13,r13,r21
811203bc:	6480022e 	bgeu	r12,r18,811203c8 <__muldf3+0x408>
811203c0:	01000074 	movhi	r4,1
811203c4:	691b883a 	add	r13,r13,r4
811203c8:	7c25383a 	mul	r18,r15,r16
811203cc:	7d4b383a 	mul	r5,r15,r21
811203d0:	84cf383a 	mul	r7,r16,r19
811203d4:	901ed43a 	srli	r15,r18,16
811203d8:	6008d43a 	srli	r4,r12,16
811203dc:	6010943a 	slli	r8,r12,16
811203e0:	394f883a 	add	r7,r7,r5
811203e4:	333fffcc 	andi	r12,r6,65535
811203e8:	79df883a 	add	r15,r15,r7
811203ec:	235b883a 	add	r13,r4,r13
811203f0:	9d63383a 	mul	r17,r19,r21
811203f4:	4309883a 	add	r4,r8,r12
811203f8:	7940022e 	bgeu	r15,r5,81120404 <__muldf3+0x444>
811203fc:	01400074 	movhi	r5,1
81120400:	8963883a 	add	r17,r17,r5
81120404:	780a943a 	slli	r5,r15,16
81120408:	91bfffcc 	andi	r6,r18,65535
8112040c:	70c7883a 	add	r3,r14,r3
81120410:	298d883a 	add	r6,r5,r6
81120414:	1a8f803a 	cmpltu	r7,r3,r10
81120418:	350b883a 	add	r5,r6,r20
8112041c:	20c7883a 	add	r3,r4,r3
81120420:	3955883a 	add	r10,r7,r5
81120424:	1909803a 	cmpltu	r4,r3,r4
81120428:	6a91883a 	add	r8,r13,r10
8112042c:	780cd43a 	srli	r6,r15,16
81120430:	2219883a 	add	r12,r4,r8
81120434:	2d0b803a 	cmpltu	r5,r5,r20
81120438:	51cf803a 	cmpltu	r7,r10,r7
8112043c:	29ceb03a 	or	r7,r5,r7
81120440:	4351803a 	cmpltu	r8,r8,r13
81120444:	610b803a 	cmpltu	r5,r12,r4
81120448:	4148b03a 	or	r4,r8,r5
8112044c:	398f883a 	add	r7,r7,r6
81120450:	3909883a 	add	r4,r7,r4
81120454:	1810927a 	slli	r8,r3,9
81120458:	2449883a 	add	r4,r4,r17
8112045c:	2008927a 	slli	r4,r4,9
81120460:	6022d5fa 	srli	r17,r12,23
81120464:	1806d5fa 	srli	r3,r3,23
81120468:	4252b03a 	or	r9,r8,r9
8112046c:	600a927a 	slli	r5,r12,9
81120470:	4810c03a 	cmpne	r8,r9,zero
81120474:	2462b03a 	or	r17,r4,r17
81120478:	40c6b03a 	or	r3,r8,r3
8112047c:	8900402c 	andhi	r4,r17,256
81120480:	1950b03a 	or	r8,r3,r5
81120484:	20000726 	beq	r4,zero,811204a4 <__muldf3+0x4e4>
81120488:	4006d07a 	srli	r3,r8,1
8112048c:	880497fa 	slli	r2,r17,31
81120490:	4200004c 	andi	r8,r8,1
81120494:	8822d07a 	srli	r17,r17,1
81120498:	1a10b03a 	or	r8,r3,r8
8112049c:	1210b03a 	or	r8,r2,r8
811204a0:	5805883a 	mov	r2,r11
811204a4:	1140ffc4 	addi	r5,r2,1023
811204a8:	0140440e 	bge	zero,r5,811205bc <__muldf3+0x5fc>
811204ac:	40c001cc 	andi	r3,r8,7
811204b0:	18000726 	beq	r3,zero,811204d0 <__muldf3+0x510>
811204b4:	40c003cc 	andi	r3,r8,15
811204b8:	01000104 	movi	r4,4
811204bc:	19000426 	beq	r3,r4,811204d0 <__muldf3+0x510>
811204c0:	4107883a 	add	r3,r8,r4
811204c4:	1a11803a 	cmpltu	r8,r3,r8
811204c8:	8a23883a 	add	r17,r17,r8
811204cc:	1811883a 	mov	r8,r3
811204d0:	88c0402c 	andhi	r3,r17,256
811204d4:	18000426 	beq	r3,zero,811204e8 <__muldf3+0x528>
811204d8:	11410004 	addi	r5,r2,1024
811204dc:	00bfc034 	movhi	r2,65280
811204e0:	10bfffc4 	addi	r2,r2,-1
811204e4:	88a2703a 	and	r17,r17,r2
811204e8:	0081ff84 	movi	r2,2046
811204ec:	117f6416 	blt	r2,r5,81120280 <__reset+0xfb100280>
811204f0:	8828977a 	slli	r20,r17,29
811204f4:	4010d0fa 	srli	r8,r8,3
811204f8:	8822927a 	slli	r17,r17,9
811204fc:	2881ffcc 	andi	r2,r5,2047
81120500:	a228b03a 	or	r20,r20,r8
81120504:	880ad33a 	srli	r5,r17,12
81120508:	b02b883a 	mov	r21,r22
8112050c:	003f0d06 	br	81120144 <__reset+0xfb100144>
81120510:	8080022c 	andhi	r2,r16,8
81120514:	10000926 	beq	r2,zero,8112053c <__muldf3+0x57c>
81120518:	8880022c 	andhi	r2,r17,8
8112051c:	1000071e 	bne	r2,zero,8112053c <__muldf3+0x57c>
81120520:	00800434 	movhi	r2,16
81120524:	89400234 	orhi	r5,r17,8
81120528:	10bfffc4 	addi	r2,r2,-1
8112052c:	b82b883a 	mov	r21,r23
81120530:	288a703a 	and	r5,r5,r2
81120534:	4029883a 	mov	r20,r8
81120538:	003f6806 	br	811202dc <__reset+0xfb1002dc>
8112053c:	00800434 	movhi	r2,16
81120540:	81400234 	orhi	r5,r16,8
81120544:	10bfffc4 	addi	r2,r2,-1
81120548:	288a703a 	and	r5,r5,r2
8112054c:	003f6306 	br	811202dc <__reset+0xfb1002dc>
81120550:	147ff604 	addi	r17,r2,-40
81120554:	3462983a 	sll	r17,r6,r17
81120558:	0011883a 	mov	r8,zero
8112055c:	003f4406 	br	81120270 <__reset+0xfb100270>
81120560:	3009883a 	mov	r4,r6
81120564:	d9800215 	stw	r6,8(sp)
81120568:	da400115 	stw	r9,4(sp)
8112056c:	da800015 	stw	r10,0(sp)
81120570:	11214080 	call	81121408 <__clzsi2>
81120574:	10800804 	addi	r2,r2,32
81120578:	da800017 	ldw	r10,0(sp)
8112057c:	da400117 	ldw	r9,4(sp)
81120580:	d9800217 	ldw	r6,8(sp)
81120584:	003f3006 	br	81120248 <__reset+0xfb100248>
81120588:	143ff604 	addi	r16,r2,-40
8112058c:	9c20983a 	sll	r16,r19,r16
81120590:	0029883a 	mov	r20,zero
81120594:	003f1606 	br	811201f0 <__reset+0xfb1001f0>
81120598:	d9800215 	stw	r6,8(sp)
8112059c:	d9c00015 	stw	r7,0(sp)
811205a0:	da400115 	stw	r9,4(sp)
811205a4:	11214080 	call	81121408 <__clzsi2>
811205a8:	10800804 	addi	r2,r2,32
811205ac:	da400117 	ldw	r9,4(sp)
811205b0:	d9c00017 	ldw	r7,0(sp)
811205b4:	d9800217 	ldw	r6,8(sp)
811205b8:	003f0306 	br	811201c8 <__reset+0xfb1001c8>
811205bc:	00c00044 	movi	r3,1
811205c0:	1947c83a 	sub	r3,r3,r5
811205c4:	00800e04 	movi	r2,56
811205c8:	10feda16 	blt	r2,r3,81120134 <__reset+0xfb100134>
811205cc:	008007c4 	movi	r2,31
811205d0:	10c01b16 	blt	r2,r3,81120640 <__muldf3+0x680>
811205d4:	00800804 	movi	r2,32
811205d8:	10c5c83a 	sub	r2,r2,r3
811205dc:	888a983a 	sll	r5,r17,r2
811205e0:	40c8d83a 	srl	r4,r8,r3
811205e4:	4084983a 	sll	r2,r8,r2
811205e8:	88e2d83a 	srl	r17,r17,r3
811205ec:	2906b03a 	or	r3,r5,r4
811205f0:	1004c03a 	cmpne	r2,r2,zero
811205f4:	1886b03a 	or	r3,r3,r2
811205f8:	188001cc 	andi	r2,r3,7
811205fc:	10000726 	beq	r2,zero,8112061c <__muldf3+0x65c>
81120600:	188003cc 	andi	r2,r3,15
81120604:	01000104 	movi	r4,4
81120608:	11000426 	beq	r2,r4,8112061c <__muldf3+0x65c>
8112060c:	1805883a 	mov	r2,r3
81120610:	10c00104 	addi	r3,r2,4
81120614:	1885803a 	cmpltu	r2,r3,r2
81120618:	88a3883a 	add	r17,r17,r2
8112061c:	8880202c 	andhi	r2,r17,128
81120620:	10001c26 	beq	r2,zero,81120694 <__muldf3+0x6d4>
81120624:	b02b883a 	mov	r21,r22
81120628:	00800044 	movi	r2,1
8112062c:	000b883a 	mov	r5,zero
81120630:	0029883a 	mov	r20,zero
81120634:	003ec306 	br	81120144 <__reset+0xfb100144>
81120638:	5805883a 	mov	r2,r11
8112063c:	003f9906 	br	811204a4 <__reset+0xfb1004a4>
81120640:	00bff844 	movi	r2,-31
81120644:	1145c83a 	sub	r2,r2,r5
81120648:	8888d83a 	srl	r4,r17,r2
8112064c:	00800804 	movi	r2,32
81120650:	18801a26 	beq	r3,r2,811206bc <__muldf3+0x6fc>
81120654:	00801004 	movi	r2,64
81120658:	10c5c83a 	sub	r2,r2,r3
8112065c:	8884983a 	sll	r2,r17,r2
81120660:	1204b03a 	or	r2,r2,r8
81120664:	1004c03a 	cmpne	r2,r2,zero
81120668:	2084b03a 	or	r2,r4,r2
8112066c:	144001cc 	andi	r17,r2,7
81120670:	88000d1e 	bne	r17,zero,811206a8 <__muldf3+0x6e8>
81120674:	000b883a 	mov	r5,zero
81120678:	1028d0fa 	srli	r20,r2,3
8112067c:	b02b883a 	mov	r21,r22
81120680:	0005883a 	mov	r2,zero
81120684:	a468b03a 	or	r20,r20,r17
81120688:	003eae06 	br	81120144 <__reset+0xfb100144>
8112068c:	1007883a 	mov	r3,r2
81120690:	0023883a 	mov	r17,zero
81120694:	880a927a 	slli	r5,r17,9
81120698:	1805883a 	mov	r2,r3
8112069c:	8822977a 	slli	r17,r17,29
811206a0:	280ad33a 	srli	r5,r5,12
811206a4:	003ff406 	br	81120678 <__reset+0xfb100678>
811206a8:	10c003cc 	andi	r3,r2,15
811206ac:	01000104 	movi	r4,4
811206b0:	193ff626 	beq	r3,r4,8112068c <__reset+0xfb10068c>
811206b4:	0023883a 	mov	r17,zero
811206b8:	003fd506 	br	81120610 <__reset+0xfb100610>
811206bc:	0005883a 	mov	r2,zero
811206c0:	003fe706 	br	81120660 <__reset+0xfb100660>
811206c4:	00800434 	movhi	r2,16
811206c8:	89400234 	orhi	r5,r17,8
811206cc:	10bfffc4 	addi	r2,r2,-1
811206d0:	b02b883a 	mov	r21,r22
811206d4:	288a703a 	and	r5,r5,r2
811206d8:	4029883a 	mov	r20,r8
811206dc:	003eff06 	br	811202dc <__reset+0xfb1002dc>

811206e0 <__subdf3>:
811206e0:	02000434 	movhi	r8,16
811206e4:	423fffc4 	addi	r8,r8,-1
811206e8:	defffb04 	addi	sp,sp,-20
811206ec:	2a14703a 	and	r10,r5,r8
811206f0:	3812d53a 	srli	r9,r7,20
811206f4:	3a10703a 	and	r8,r7,r8
811206f8:	de00012e 	bgeu	sp,et,81120700 <__subdf3+0x20>
811206fc:	003b68fa 	trap	3
81120700:	2006d77a 	srli	r3,r4,29
81120704:	3004d77a 	srli	r2,r6,29
81120708:	dc000015 	stw	r16,0(sp)
8112070c:	501490fa 	slli	r10,r10,3
81120710:	2820d53a 	srli	r16,r5,20
81120714:	401090fa 	slli	r8,r8,3
81120718:	dc800215 	stw	r18,8(sp)
8112071c:	dc400115 	stw	r17,4(sp)
81120720:	dfc00415 	stw	ra,16(sp)
81120724:	202290fa 	slli	r17,r4,3
81120728:	dcc00315 	stw	r19,12(sp)
8112072c:	4a41ffcc 	andi	r9,r9,2047
81120730:	0101ffc4 	movi	r4,2047
81120734:	2824d7fa 	srli	r18,r5,31
81120738:	8401ffcc 	andi	r16,r16,2047
8112073c:	50c6b03a 	or	r3,r10,r3
81120740:	380ed7fa 	srli	r7,r7,31
81120744:	408ab03a 	or	r5,r8,r2
81120748:	300c90fa 	slli	r6,r6,3
8112074c:	49009626 	beq	r9,r4,811209a8 <__subdf3+0x2c8>
81120750:	39c0005c 	xori	r7,r7,1
81120754:	8245c83a 	sub	r2,r16,r9
81120758:	3c807426 	beq	r7,r18,8112092c <__subdf3+0x24c>
8112075c:	0080af0e 	bge	zero,r2,81120a1c <__subdf3+0x33c>
81120760:	48002a1e 	bne	r9,zero,8112080c <__subdf3+0x12c>
81120764:	2988b03a 	or	r4,r5,r6
81120768:	20009a1e 	bne	r4,zero,811209d4 <__subdf3+0x2f4>
8112076c:	888001cc 	andi	r2,r17,7
81120770:	10000726 	beq	r2,zero,81120790 <__subdf3+0xb0>
81120774:	888003cc 	andi	r2,r17,15
81120778:	01000104 	movi	r4,4
8112077c:	11000426 	beq	r2,r4,81120790 <__subdf3+0xb0>
81120780:	890b883a 	add	r5,r17,r4
81120784:	2c63803a 	cmpltu	r17,r5,r17
81120788:	1c47883a 	add	r3,r3,r17
8112078c:	2823883a 	mov	r17,r5
81120790:	1880202c 	andhi	r2,r3,128
81120794:	10005926 	beq	r2,zero,811208fc <__subdf3+0x21c>
81120798:	84000044 	addi	r16,r16,1
8112079c:	0081ffc4 	movi	r2,2047
811207a0:	8080be26 	beq	r16,r2,81120a9c <__subdf3+0x3bc>
811207a4:	017fe034 	movhi	r5,65408
811207a8:	297fffc4 	addi	r5,r5,-1
811207ac:	1946703a 	and	r3,r3,r5
811207b0:	1804977a 	slli	r2,r3,29
811207b4:	1806927a 	slli	r3,r3,9
811207b8:	8822d0fa 	srli	r17,r17,3
811207bc:	8401ffcc 	andi	r16,r16,2047
811207c0:	180ad33a 	srli	r5,r3,12
811207c4:	9100004c 	andi	r4,r18,1
811207c8:	1444b03a 	or	r2,r2,r17
811207cc:	80c1ffcc 	andi	r3,r16,2047
811207d0:	1820953a 	slli	r16,r3,20
811207d4:	20c03fcc 	andi	r3,r4,255
811207d8:	180897fa 	slli	r4,r3,31
811207dc:	00c00434 	movhi	r3,16
811207e0:	18ffffc4 	addi	r3,r3,-1
811207e4:	28c6703a 	and	r3,r5,r3
811207e8:	1c06b03a 	or	r3,r3,r16
811207ec:	1906b03a 	or	r3,r3,r4
811207f0:	dfc00417 	ldw	ra,16(sp)
811207f4:	dcc00317 	ldw	r19,12(sp)
811207f8:	dc800217 	ldw	r18,8(sp)
811207fc:	dc400117 	ldw	r17,4(sp)
81120800:	dc000017 	ldw	r16,0(sp)
81120804:	dec00504 	addi	sp,sp,20
81120808:	f800283a 	ret
8112080c:	0101ffc4 	movi	r4,2047
81120810:	813fd626 	beq	r16,r4,8112076c <__reset+0xfb10076c>
81120814:	29402034 	orhi	r5,r5,128
81120818:	01000e04 	movi	r4,56
8112081c:	2080a316 	blt	r4,r2,81120aac <__subdf3+0x3cc>
81120820:	010007c4 	movi	r4,31
81120824:	2080c616 	blt	r4,r2,81120b40 <__subdf3+0x460>
81120828:	01000804 	movi	r4,32
8112082c:	2089c83a 	sub	r4,r4,r2
81120830:	2910983a 	sll	r8,r5,r4
81120834:	308ed83a 	srl	r7,r6,r2
81120838:	3108983a 	sll	r4,r6,r4
8112083c:	2884d83a 	srl	r2,r5,r2
81120840:	41ccb03a 	or	r6,r8,r7
81120844:	2008c03a 	cmpne	r4,r4,zero
81120848:	310cb03a 	or	r6,r6,r4
8112084c:	898dc83a 	sub	r6,r17,r6
81120850:	89a3803a 	cmpltu	r17,r17,r6
81120854:	1887c83a 	sub	r3,r3,r2
81120858:	1c47c83a 	sub	r3,r3,r17
8112085c:	3023883a 	mov	r17,r6
81120860:	1880202c 	andhi	r2,r3,128
81120864:	10002326 	beq	r2,zero,811208f4 <__subdf3+0x214>
81120868:	04c02034 	movhi	r19,128
8112086c:	9cffffc4 	addi	r19,r19,-1
81120870:	1ce6703a 	and	r19,r3,r19
81120874:	98007a26 	beq	r19,zero,81120a60 <__subdf3+0x380>
81120878:	9809883a 	mov	r4,r19
8112087c:	11214080 	call	81121408 <__clzsi2>
81120880:	113ffe04 	addi	r4,r2,-8
81120884:	00c007c4 	movi	r3,31
81120888:	19007b16 	blt	r3,r4,81120a78 <__subdf3+0x398>
8112088c:	00800804 	movi	r2,32
81120890:	1105c83a 	sub	r2,r2,r4
81120894:	8884d83a 	srl	r2,r17,r2
81120898:	9906983a 	sll	r3,r19,r4
8112089c:	8922983a 	sll	r17,r17,r4
811208a0:	10c4b03a 	or	r2,r2,r3
811208a4:	24007816 	blt	r4,r16,81120a88 <__subdf3+0x3a8>
811208a8:	2421c83a 	sub	r16,r4,r16
811208ac:	80c00044 	addi	r3,r16,1
811208b0:	010007c4 	movi	r4,31
811208b4:	20c09516 	blt	r4,r3,81120b0c <__subdf3+0x42c>
811208b8:	01400804 	movi	r5,32
811208bc:	28cbc83a 	sub	r5,r5,r3
811208c0:	88c8d83a 	srl	r4,r17,r3
811208c4:	8962983a 	sll	r17,r17,r5
811208c8:	114a983a 	sll	r5,r2,r5
811208cc:	10c6d83a 	srl	r3,r2,r3
811208d0:	8804c03a 	cmpne	r2,r17,zero
811208d4:	290ab03a 	or	r5,r5,r4
811208d8:	28a2b03a 	or	r17,r5,r2
811208dc:	0021883a 	mov	r16,zero
811208e0:	003fa206 	br	8112076c <__reset+0xfb10076c>
811208e4:	2090b03a 	or	r8,r4,r2
811208e8:	40018e26 	beq	r8,zero,81120f24 <__subdf3+0x844>
811208ec:	1007883a 	mov	r3,r2
811208f0:	2023883a 	mov	r17,r4
811208f4:	888001cc 	andi	r2,r17,7
811208f8:	103f9e1e 	bne	r2,zero,81120774 <__reset+0xfb100774>
811208fc:	1804977a 	slli	r2,r3,29
81120900:	8822d0fa 	srli	r17,r17,3
81120904:	1810d0fa 	srli	r8,r3,3
81120908:	9100004c 	andi	r4,r18,1
8112090c:	1444b03a 	or	r2,r2,r17
81120910:	00c1ffc4 	movi	r3,2047
81120914:	80c02826 	beq	r16,r3,811209b8 <__subdf3+0x2d8>
81120918:	01400434 	movhi	r5,16
8112091c:	297fffc4 	addi	r5,r5,-1
81120920:	80e0703a 	and	r16,r16,r3
81120924:	414a703a 	and	r5,r8,r5
81120928:	003fa806 	br	811207cc <__reset+0xfb1007cc>
8112092c:	0080630e 	bge	zero,r2,81120abc <__subdf3+0x3dc>
81120930:	48003026 	beq	r9,zero,811209f4 <__subdf3+0x314>
81120934:	0101ffc4 	movi	r4,2047
81120938:	813f8c26 	beq	r16,r4,8112076c <__reset+0xfb10076c>
8112093c:	29402034 	orhi	r5,r5,128
81120940:	01000e04 	movi	r4,56
81120944:	2080a90e 	bge	r4,r2,81120bec <__subdf3+0x50c>
81120948:	298cb03a 	or	r6,r5,r6
8112094c:	3012c03a 	cmpne	r9,r6,zero
81120950:	0005883a 	mov	r2,zero
81120954:	4c53883a 	add	r9,r9,r17
81120958:	4c63803a 	cmpltu	r17,r9,r17
8112095c:	10c7883a 	add	r3,r2,r3
81120960:	88c7883a 	add	r3,r17,r3
81120964:	4823883a 	mov	r17,r9
81120968:	1880202c 	andhi	r2,r3,128
8112096c:	1000d026 	beq	r2,zero,81120cb0 <__subdf3+0x5d0>
81120970:	84000044 	addi	r16,r16,1
81120974:	0081ffc4 	movi	r2,2047
81120978:	8080fe26 	beq	r16,r2,81120d74 <__subdf3+0x694>
8112097c:	00bfe034 	movhi	r2,65408
81120980:	10bfffc4 	addi	r2,r2,-1
81120984:	1886703a 	and	r3,r3,r2
81120988:	880ad07a 	srli	r5,r17,1
8112098c:	180497fa 	slli	r2,r3,31
81120990:	8900004c 	andi	r4,r17,1
81120994:	2922b03a 	or	r17,r5,r4
81120998:	1806d07a 	srli	r3,r3,1
8112099c:	1462b03a 	or	r17,r2,r17
811209a0:	3825883a 	mov	r18,r7
811209a4:	003f7106 	br	8112076c <__reset+0xfb10076c>
811209a8:	2984b03a 	or	r2,r5,r6
811209ac:	103f6826 	beq	r2,zero,81120750 <__reset+0xfb100750>
811209b0:	39c03fcc 	andi	r7,r7,255
811209b4:	003f6706 	br	81120754 <__reset+0xfb100754>
811209b8:	4086b03a 	or	r3,r8,r2
811209bc:	18015226 	beq	r3,zero,81120f08 <__subdf3+0x828>
811209c0:	00c00434 	movhi	r3,16
811209c4:	41400234 	orhi	r5,r8,8
811209c8:	18ffffc4 	addi	r3,r3,-1
811209cc:	28ca703a 	and	r5,r5,r3
811209d0:	003f7e06 	br	811207cc <__reset+0xfb1007cc>
811209d4:	10bfffc4 	addi	r2,r2,-1
811209d8:	1000491e 	bne	r2,zero,81120b00 <__subdf3+0x420>
811209dc:	898fc83a 	sub	r7,r17,r6
811209e0:	89e3803a 	cmpltu	r17,r17,r7
811209e4:	1947c83a 	sub	r3,r3,r5
811209e8:	1c47c83a 	sub	r3,r3,r17
811209ec:	3823883a 	mov	r17,r7
811209f0:	003f9b06 	br	81120860 <__reset+0xfb100860>
811209f4:	2988b03a 	or	r4,r5,r6
811209f8:	203f5c26 	beq	r4,zero,8112076c <__reset+0xfb10076c>
811209fc:	10bfffc4 	addi	r2,r2,-1
81120a00:	1000931e 	bne	r2,zero,81120c50 <__subdf3+0x570>
81120a04:	898d883a 	add	r6,r17,r6
81120a08:	3463803a 	cmpltu	r17,r6,r17
81120a0c:	1947883a 	add	r3,r3,r5
81120a10:	88c7883a 	add	r3,r17,r3
81120a14:	3023883a 	mov	r17,r6
81120a18:	003fd306 	br	81120968 <__reset+0xfb100968>
81120a1c:	1000541e 	bne	r2,zero,81120b70 <__subdf3+0x490>
81120a20:	80800044 	addi	r2,r16,1
81120a24:	1081ffcc 	andi	r2,r2,2047
81120a28:	01000044 	movi	r4,1
81120a2c:	2080a20e 	bge	r4,r2,81120cb8 <__subdf3+0x5d8>
81120a30:	8989c83a 	sub	r4,r17,r6
81120a34:	8905803a 	cmpltu	r2,r17,r4
81120a38:	1967c83a 	sub	r19,r3,r5
81120a3c:	98a7c83a 	sub	r19,r19,r2
81120a40:	9880202c 	andhi	r2,r19,128
81120a44:	10006326 	beq	r2,zero,81120bd4 <__subdf3+0x4f4>
81120a48:	3463c83a 	sub	r17,r6,r17
81120a4c:	28c7c83a 	sub	r3,r5,r3
81120a50:	344d803a 	cmpltu	r6,r6,r17
81120a54:	19a7c83a 	sub	r19,r3,r6
81120a58:	3825883a 	mov	r18,r7
81120a5c:	983f861e 	bne	r19,zero,81120878 <__reset+0xfb100878>
81120a60:	8809883a 	mov	r4,r17
81120a64:	11214080 	call	81121408 <__clzsi2>
81120a68:	10800804 	addi	r2,r2,32
81120a6c:	113ffe04 	addi	r4,r2,-8
81120a70:	00c007c4 	movi	r3,31
81120a74:	193f850e 	bge	r3,r4,8112088c <__reset+0xfb10088c>
81120a78:	10bff604 	addi	r2,r2,-40
81120a7c:	8884983a 	sll	r2,r17,r2
81120a80:	0023883a 	mov	r17,zero
81120a84:	243f880e 	bge	r4,r16,811208a8 <__reset+0xfb1008a8>
81120a88:	00ffe034 	movhi	r3,65408
81120a8c:	18ffffc4 	addi	r3,r3,-1
81120a90:	8121c83a 	sub	r16,r16,r4
81120a94:	10c6703a 	and	r3,r2,r3
81120a98:	003f3406 	br	8112076c <__reset+0xfb10076c>
81120a9c:	9100004c 	andi	r4,r18,1
81120aa0:	000b883a 	mov	r5,zero
81120aa4:	0005883a 	mov	r2,zero
81120aa8:	003f4806 	br	811207cc <__reset+0xfb1007cc>
81120aac:	298cb03a 	or	r6,r5,r6
81120ab0:	300cc03a 	cmpne	r6,r6,zero
81120ab4:	0005883a 	mov	r2,zero
81120ab8:	003f6406 	br	8112084c <__reset+0xfb10084c>
81120abc:	10009a1e 	bne	r2,zero,81120d28 <__subdf3+0x648>
81120ac0:	82400044 	addi	r9,r16,1
81120ac4:	4881ffcc 	andi	r2,r9,2047
81120ac8:	02800044 	movi	r10,1
81120acc:	5080670e 	bge	r10,r2,81120c6c <__subdf3+0x58c>
81120ad0:	0081ffc4 	movi	r2,2047
81120ad4:	4880af26 	beq	r9,r2,81120d94 <__subdf3+0x6b4>
81120ad8:	898d883a 	add	r6,r17,r6
81120adc:	1945883a 	add	r2,r3,r5
81120ae0:	3447803a 	cmpltu	r3,r6,r17
81120ae4:	1887883a 	add	r3,r3,r2
81120ae8:	182297fa 	slli	r17,r3,31
81120aec:	300cd07a 	srli	r6,r6,1
81120af0:	1806d07a 	srli	r3,r3,1
81120af4:	4821883a 	mov	r16,r9
81120af8:	89a2b03a 	or	r17,r17,r6
81120afc:	003f1b06 	br	8112076c <__reset+0xfb10076c>
81120b00:	0101ffc4 	movi	r4,2047
81120b04:	813f441e 	bne	r16,r4,81120818 <__reset+0xfb100818>
81120b08:	003f1806 	br	8112076c <__reset+0xfb10076c>
81120b0c:	843ff844 	addi	r16,r16,-31
81120b10:	01400804 	movi	r5,32
81120b14:	1408d83a 	srl	r4,r2,r16
81120b18:	19405026 	beq	r3,r5,81120c5c <__subdf3+0x57c>
81120b1c:	01401004 	movi	r5,64
81120b20:	28c7c83a 	sub	r3,r5,r3
81120b24:	10c4983a 	sll	r2,r2,r3
81120b28:	88a2b03a 	or	r17,r17,r2
81120b2c:	8822c03a 	cmpne	r17,r17,zero
81120b30:	2462b03a 	or	r17,r4,r17
81120b34:	0007883a 	mov	r3,zero
81120b38:	0021883a 	mov	r16,zero
81120b3c:	003f6d06 	br	811208f4 <__reset+0xfb1008f4>
81120b40:	11fff804 	addi	r7,r2,-32
81120b44:	01000804 	movi	r4,32
81120b48:	29ced83a 	srl	r7,r5,r7
81120b4c:	11004526 	beq	r2,r4,81120c64 <__subdf3+0x584>
81120b50:	01001004 	movi	r4,64
81120b54:	2089c83a 	sub	r4,r4,r2
81120b58:	2904983a 	sll	r2,r5,r4
81120b5c:	118cb03a 	or	r6,r2,r6
81120b60:	300cc03a 	cmpne	r6,r6,zero
81120b64:	398cb03a 	or	r6,r7,r6
81120b68:	0005883a 	mov	r2,zero
81120b6c:	003f3706 	br	8112084c <__reset+0xfb10084c>
81120b70:	80002a26 	beq	r16,zero,81120c1c <__subdf3+0x53c>
81120b74:	0101ffc4 	movi	r4,2047
81120b78:	49006626 	beq	r9,r4,81120d14 <__subdf3+0x634>
81120b7c:	0085c83a 	sub	r2,zero,r2
81120b80:	18c02034 	orhi	r3,r3,128
81120b84:	01000e04 	movi	r4,56
81120b88:	20807e16 	blt	r4,r2,81120d84 <__subdf3+0x6a4>
81120b8c:	010007c4 	movi	r4,31
81120b90:	2080e716 	blt	r4,r2,81120f30 <__subdf3+0x850>
81120b94:	01000804 	movi	r4,32
81120b98:	2089c83a 	sub	r4,r4,r2
81120b9c:	1914983a 	sll	r10,r3,r4
81120ba0:	8890d83a 	srl	r8,r17,r2
81120ba4:	8908983a 	sll	r4,r17,r4
81120ba8:	1884d83a 	srl	r2,r3,r2
81120bac:	5222b03a 	or	r17,r10,r8
81120bb0:	2006c03a 	cmpne	r3,r4,zero
81120bb4:	88e2b03a 	or	r17,r17,r3
81120bb8:	3463c83a 	sub	r17,r6,r17
81120bbc:	2885c83a 	sub	r2,r5,r2
81120bc0:	344d803a 	cmpltu	r6,r6,r17
81120bc4:	1187c83a 	sub	r3,r2,r6
81120bc8:	4821883a 	mov	r16,r9
81120bcc:	3825883a 	mov	r18,r7
81120bd0:	003f2306 	br	81120860 <__reset+0xfb100860>
81120bd4:	24d0b03a 	or	r8,r4,r19
81120bd8:	40001b1e 	bne	r8,zero,81120c48 <__subdf3+0x568>
81120bdc:	0005883a 	mov	r2,zero
81120be0:	0009883a 	mov	r4,zero
81120be4:	0021883a 	mov	r16,zero
81120be8:	003f4906 	br	81120910 <__reset+0xfb100910>
81120bec:	010007c4 	movi	r4,31
81120bf0:	20803a16 	blt	r4,r2,81120cdc <__subdf3+0x5fc>
81120bf4:	01000804 	movi	r4,32
81120bf8:	2089c83a 	sub	r4,r4,r2
81120bfc:	2912983a 	sll	r9,r5,r4
81120c00:	3090d83a 	srl	r8,r6,r2
81120c04:	3108983a 	sll	r4,r6,r4
81120c08:	2884d83a 	srl	r2,r5,r2
81120c0c:	4a12b03a 	or	r9,r9,r8
81120c10:	2008c03a 	cmpne	r4,r4,zero
81120c14:	4912b03a 	or	r9,r9,r4
81120c18:	003f4e06 	br	81120954 <__reset+0xfb100954>
81120c1c:	1c48b03a 	or	r4,r3,r17
81120c20:	20003c26 	beq	r4,zero,81120d14 <__subdf3+0x634>
81120c24:	0084303a 	nor	r2,zero,r2
81120c28:	1000381e 	bne	r2,zero,81120d0c <__subdf3+0x62c>
81120c2c:	3463c83a 	sub	r17,r6,r17
81120c30:	28c5c83a 	sub	r2,r5,r3
81120c34:	344d803a 	cmpltu	r6,r6,r17
81120c38:	1187c83a 	sub	r3,r2,r6
81120c3c:	4821883a 	mov	r16,r9
81120c40:	3825883a 	mov	r18,r7
81120c44:	003f0606 	br	81120860 <__reset+0xfb100860>
81120c48:	2023883a 	mov	r17,r4
81120c4c:	003f0906 	br	81120874 <__reset+0xfb100874>
81120c50:	0101ffc4 	movi	r4,2047
81120c54:	813f3a1e 	bne	r16,r4,81120940 <__reset+0xfb100940>
81120c58:	003ec406 	br	8112076c <__reset+0xfb10076c>
81120c5c:	0005883a 	mov	r2,zero
81120c60:	003fb106 	br	81120b28 <__reset+0xfb100b28>
81120c64:	0005883a 	mov	r2,zero
81120c68:	003fbc06 	br	81120b5c <__reset+0xfb100b5c>
81120c6c:	1c44b03a 	or	r2,r3,r17
81120c70:	80008e1e 	bne	r16,zero,81120eac <__subdf3+0x7cc>
81120c74:	1000c826 	beq	r2,zero,81120f98 <__subdf3+0x8b8>
81120c78:	2984b03a 	or	r2,r5,r6
81120c7c:	103ebb26 	beq	r2,zero,8112076c <__reset+0xfb10076c>
81120c80:	8989883a 	add	r4,r17,r6
81120c84:	1945883a 	add	r2,r3,r5
81120c88:	2447803a 	cmpltu	r3,r4,r17
81120c8c:	1887883a 	add	r3,r3,r2
81120c90:	1880202c 	andhi	r2,r3,128
81120c94:	2023883a 	mov	r17,r4
81120c98:	103f1626 	beq	r2,zero,811208f4 <__reset+0xfb1008f4>
81120c9c:	00bfe034 	movhi	r2,65408
81120ca0:	10bfffc4 	addi	r2,r2,-1
81120ca4:	5021883a 	mov	r16,r10
81120ca8:	1886703a 	and	r3,r3,r2
81120cac:	003eaf06 	br	8112076c <__reset+0xfb10076c>
81120cb0:	3825883a 	mov	r18,r7
81120cb4:	003f0f06 	br	811208f4 <__reset+0xfb1008f4>
81120cb8:	1c44b03a 	or	r2,r3,r17
81120cbc:	8000251e 	bne	r16,zero,81120d54 <__subdf3+0x674>
81120cc0:	1000661e 	bne	r2,zero,81120e5c <__subdf3+0x77c>
81120cc4:	2990b03a 	or	r8,r5,r6
81120cc8:	40009626 	beq	r8,zero,81120f24 <__subdf3+0x844>
81120ccc:	2807883a 	mov	r3,r5
81120cd0:	3023883a 	mov	r17,r6
81120cd4:	3825883a 	mov	r18,r7
81120cd8:	003ea406 	br	8112076c <__reset+0xfb10076c>
81120cdc:	127ff804 	addi	r9,r2,-32
81120ce0:	01000804 	movi	r4,32
81120ce4:	2a52d83a 	srl	r9,r5,r9
81120ce8:	11008c26 	beq	r2,r4,81120f1c <__subdf3+0x83c>
81120cec:	01001004 	movi	r4,64
81120cf0:	2085c83a 	sub	r2,r4,r2
81120cf4:	2884983a 	sll	r2,r5,r2
81120cf8:	118cb03a 	or	r6,r2,r6
81120cfc:	300cc03a 	cmpne	r6,r6,zero
81120d00:	4992b03a 	or	r9,r9,r6
81120d04:	0005883a 	mov	r2,zero
81120d08:	003f1206 	br	81120954 <__reset+0xfb100954>
81120d0c:	0101ffc4 	movi	r4,2047
81120d10:	493f9c1e 	bne	r9,r4,81120b84 <__reset+0xfb100b84>
81120d14:	2807883a 	mov	r3,r5
81120d18:	3023883a 	mov	r17,r6
81120d1c:	4821883a 	mov	r16,r9
81120d20:	3825883a 	mov	r18,r7
81120d24:	003e9106 	br	8112076c <__reset+0xfb10076c>
81120d28:	80001f1e 	bne	r16,zero,81120da8 <__subdf3+0x6c8>
81120d2c:	1c48b03a 	or	r4,r3,r17
81120d30:	20005a26 	beq	r4,zero,81120e9c <__subdf3+0x7bc>
81120d34:	0084303a 	nor	r2,zero,r2
81120d38:	1000561e 	bne	r2,zero,81120e94 <__subdf3+0x7b4>
81120d3c:	89a3883a 	add	r17,r17,r6
81120d40:	1945883a 	add	r2,r3,r5
81120d44:	898d803a 	cmpltu	r6,r17,r6
81120d48:	3087883a 	add	r3,r6,r2
81120d4c:	4821883a 	mov	r16,r9
81120d50:	003f0506 	br	81120968 <__reset+0xfb100968>
81120d54:	10002b1e 	bne	r2,zero,81120e04 <__subdf3+0x724>
81120d58:	2984b03a 	or	r2,r5,r6
81120d5c:	10008026 	beq	r2,zero,81120f60 <__subdf3+0x880>
81120d60:	2807883a 	mov	r3,r5
81120d64:	3023883a 	mov	r17,r6
81120d68:	3825883a 	mov	r18,r7
81120d6c:	0401ffc4 	movi	r16,2047
81120d70:	003e7e06 	br	8112076c <__reset+0xfb10076c>
81120d74:	3809883a 	mov	r4,r7
81120d78:	0011883a 	mov	r8,zero
81120d7c:	0005883a 	mov	r2,zero
81120d80:	003ee306 	br	81120910 <__reset+0xfb100910>
81120d84:	1c62b03a 	or	r17,r3,r17
81120d88:	8822c03a 	cmpne	r17,r17,zero
81120d8c:	0005883a 	mov	r2,zero
81120d90:	003f8906 	br	81120bb8 <__reset+0xfb100bb8>
81120d94:	3809883a 	mov	r4,r7
81120d98:	4821883a 	mov	r16,r9
81120d9c:	0011883a 	mov	r8,zero
81120da0:	0005883a 	mov	r2,zero
81120da4:	003eda06 	br	81120910 <__reset+0xfb100910>
81120da8:	0101ffc4 	movi	r4,2047
81120dac:	49003b26 	beq	r9,r4,81120e9c <__subdf3+0x7bc>
81120db0:	0085c83a 	sub	r2,zero,r2
81120db4:	18c02034 	orhi	r3,r3,128
81120db8:	01000e04 	movi	r4,56
81120dbc:	20806e16 	blt	r4,r2,81120f78 <__subdf3+0x898>
81120dc0:	010007c4 	movi	r4,31
81120dc4:	20807716 	blt	r4,r2,81120fa4 <__subdf3+0x8c4>
81120dc8:	01000804 	movi	r4,32
81120dcc:	2089c83a 	sub	r4,r4,r2
81120dd0:	1914983a 	sll	r10,r3,r4
81120dd4:	8890d83a 	srl	r8,r17,r2
81120dd8:	8908983a 	sll	r4,r17,r4
81120ddc:	1884d83a 	srl	r2,r3,r2
81120de0:	5222b03a 	or	r17,r10,r8
81120de4:	2006c03a 	cmpne	r3,r4,zero
81120de8:	88e2b03a 	or	r17,r17,r3
81120dec:	89a3883a 	add	r17,r17,r6
81120df0:	1145883a 	add	r2,r2,r5
81120df4:	898d803a 	cmpltu	r6,r17,r6
81120df8:	3087883a 	add	r3,r6,r2
81120dfc:	4821883a 	mov	r16,r9
81120e00:	003ed906 	br	81120968 <__reset+0xfb100968>
81120e04:	2984b03a 	or	r2,r5,r6
81120e08:	10004226 	beq	r2,zero,81120f14 <__subdf3+0x834>
81120e0c:	1808d0fa 	srli	r4,r3,3
81120e10:	8822d0fa 	srli	r17,r17,3
81120e14:	1806977a 	slli	r3,r3,29
81120e18:	2080022c 	andhi	r2,r4,8
81120e1c:	1c62b03a 	or	r17,r3,r17
81120e20:	10000826 	beq	r2,zero,81120e44 <__subdf3+0x764>
81120e24:	2812d0fa 	srli	r9,r5,3
81120e28:	4880022c 	andhi	r2,r9,8
81120e2c:	1000051e 	bne	r2,zero,81120e44 <__subdf3+0x764>
81120e30:	300cd0fa 	srli	r6,r6,3
81120e34:	2804977a 	slli	r2,r5,29
81120e38:	4809883a 	mov	r4,r9
81120e3c:	3825883a 	mov	r18,r7
81120e40:	11a2b03a 	or	r17,r2,r6
81120e44:	8806d77a 	srli	r3,r17,29
81120e48:	200890fa 	slli	r4,r4,3
81120e4c:	882290fa 	slli	r17,r17,3
81120e50:	0401ffc4 	movi	r16,2047
81120e54:	1906b03a 	or	r3,r3,r4
81120e58:	003e4406 	br	8112076c <__reset+0xfb10076c>
81120e5c:	2984b03a 	or	r2,r5,r6
81120e60:	103e4226 	beq	r2,zero,8112076c <__reset+0xfb10076c>
81120e64:	8989c83a 	sub	r4,r17,r6
81120e68:	8911803a 	cmpltu	r8,r17,r4
81120e6c:	1945c83a 	sub	r2,r3,r5
81120e70:	1205c83a 	sub	r2,r2,r8
81120e74:	1200202c 	andhi	r8,r2,128
81120e78:	403e9a26 	beq	r8,zero,811208e4 <__reset+0xfb1008e4>
81120e7c:	3463c83a 	sub	r17,r6,r17
81120e80:	28c5c83a 	sub	r2,r5,r3
81120e84:	344d803a 	cmpltu	r6,r6,r17
81120e88:	1187c83a 	sub	r3,r2,r6
81120e8c:	3825883a 	mov	r18,r7
81120e90:	003e3606 	br	8112076c <__reset+0xfb10076c>
81120e94:	0101ffc4 	movi	r4,2047
81120e98:	493fc71e 	bne	r9,r4,81120db8 <__reset+0xfb100db8>
81120e9c:	2807883a 	mov	r3,r5
81120ea0:	3023883a 	mov	r17,r6
81120ea4:	4821883a 	mov	r16,r9
81120ea8:	003e3006 	br	8112076c <__reset+0xfb10076c>
81120eac:	10003626 	beq	r2,zero,81120f88 <__subdf3+0x8a8>
81120eb0:	2984b03a 	or	r2,r5,r6
81120eb4:	10001726 	beq	r2,zero,81120f14 <__subdf3+0x834>
81120eb8:	1808d0fa 	srli	r4,r3,3
81120ebc:	8822d0fa 	srli	r17,r17,3
81120ec0:	1806977a 	slli	r3,r3,29
81120ec4:	2080022c 	andhi	r2,r4,8
81120ec8:	1c62b03a 	or	r17,r3,r17
81120ecc:	10000726 	beq	r2,zero,81120eec <__subdf3+0x80c>
81120ed0:	2812d0fa 	srli	r9,r5,3
81120ed4:	4880022c 	andhi	r2,r9,8
81120ed8:	1000041e 	bne	r2,zero,81120eec <__subdf3+0x80c>
81120edc:	300cd0fa 	srli	r6,r6,3
81120ee0:	2804977a 	slli	r2,r5,29
81120ee4:	4809883a 	mov	r4,r9
81120ee8:	11a2b03a 	or	r17,r2,r6
81120eec:	8806d77a 	srli	r3,r17,29
81120ef0:	200890fa 	slli	r4,r4,3
81120ef4:	882290fa 	slli	r17,r17,3
81120ef8:	3825883a 	mov	r18,r7
81120efc:	1906b03a 	or	r3,r3,r4
81120f00:	0401ffc4 	movi	r16,2047
81120f04:	003e1906 	br	8112076c <__reset+0xfb10076c>
81120f08:	000b883a 	mov	r5,zero
81120f0c:	0005883a 	mov	r2,zero
81120f10:	003e2e06 	br	811207cc <__reset+0xfb1007cc>
81120f14:	0401ffc4 	movi	r16,2047
81120f18:	003e1406 	br	8112076c <__reset+0xfb10076c>
81120f1c:	0005883a 	mov	r2,zero
81120f20:	003f7506 	br	81120cf8 <__reset+0xfb100cf8>
81120f24:	0005883a 	mov	r2,zero
81120f28:	0009883a 	mov	r4,zero
81120f2c:	003e7806 	br	81120910 <__reset+0xfb100910>
81120f30:	123ff804 	addi	r8,r2,-32
81120f34:	01000804 	movi	r4,32
81120f38:	1a10d83a 	srl	r8,r3,r8
81120f3c:	11002526 	beq	r2,r4,81120fd4 <__subdf3+0x8f4>
81120f40:	01001004 	movi	r4,64
81120f44:	2085c83a 	sub	r2,r4,r2
81120f48:	1884983a 	sll	r2,r3,r2
81120f4c:	1444b03a 	or	r2,r2,r17
81120f50:	1004c03a 	cmpne	r2,r2,zero
81120f54:	40a2b03a 	or	r17,r8,r2
81120f58:	0005883a 	mov	r2,zero
81120f5c:	003f1606 	br	81120bb8 <__reset+0xfb100bb8>
81120f60:	02000434 	movhi	r8,16
81120f64:	0009883a 	mov	r4,zero
81120f68:	423fffc4 	addi	r8,r8,-1
81120f6c:	00bfffc4 	movi	r2,-1
81120f70:	0401ffc4 	movi	r16,2047
81120f74:	003e6606 	br	81120910 <__reset+0xfb100910>
81120f78:	1c62b03a 	or	r17,r3,r17
81120f7c:	8822c03a 	cmpne	r17,r17,zero
81120f80:	0005883a 	mov	r2,zero
81120f84:	003f9906 	br	81120dec <__reset+0xfb100dec>
81120f88:	2807883a 	mov	r3,r5
81120f8c:	3023883a 	mov	r17,r6
81120f90:	0401ffc4 	movi	r16,2047
81120f94:	003df506 	br	8112076c <__reset+0xfb10076c>
81120f98:	2807883a 	mov	r3,r5
81120f9c:	3023883a 	mov	r17,r6
81120fa0:	003df206 	br	8112076c <__reset+0xfb10076c>
81120fa4:	123ff804 	addi	r8,r2,-32
81120fa8:	01000804 	movi	r4,32
81120fac:	1a10d83a 	srl	r8,r3,r8
81120fb0:	11000a26 	beq	r2,r4,81120fdc <__subdf3+0x8fc>
81120fb4:	01001004 	movi	r4,64
81120fb8:	2085c83a 	sub	r2,r4,r2
81120fbc:	1884983a 	sll	r2,r3,r2
81120fc0:	1444b03a 	or	r2,r2,r17
81120fc4:	1004c03a 	cmpne	r2,r2,zero
81120fc8:	40a2b03a 	or	r17,r8,r2
81120fcc:	0005883a 	mov	r2,zero
81120fd0:	003f8606 	br	81120dec <__reset+0xfb100dec>
81120fd4:	0005883a 	mov	r2,zero
81120fd8:	003fdc06 	br	81120f4c <__reset+0xfb100f4c>
81120fdc:	0005883a 	mov	r2,zero
81120fe0:	003ff706 	br	81120fc0 <__reset+0xfb100fc0>

81120fe4 <__fixdfsi>:
81120fe4:	280cd53a 	srli	r6,r5,20
81120fe8:	00c00434 	movhi	r3,16
81120fec:	18ffffc4 	addi	r3,r3,-1
81120ff0:	3181ffcc 	andi	r6,r6,2047
81120ff4:	01c0ff84 	movi	r7,1022
81120ff8:	28c6703a 	and	r3,r5,r3
81120ffc:	280ad7fa 	srli	r5,r5,31
81121000:	3980120e 	bge	r7,r6,8112104c <__fixdfsi+0x68>
81121004:	00810744 	movi	r2,1053
81121008:	11800c16 	blt	r2,r6,8112103c <__fixdfsi+0x58>
8112100c:	00810cc4 	movi	r2,1075
81121010:	1185c83a 	sub	r2,r2,r6
81121014:	01c007c4 	movi	r7,31
81121018:	18c00434 	orhi	r3,r3,16
8112101c:	38800d16 	blt	r7,r2,81121054 <__fixdfsi+0x70>
81121020:	31befb44 	addi	r6,r6,-1043
81121024:	2084d83a 	srl	r2,r4,r2
81121028:	1986983a 	sll	r3,r3,r6
8112102c:	1884b03a 	or	r2,r3,r2
81121030:	28000726 	beq	r5,zero,81121050 <__fixdfsi+0x6c>
81121034:	0085c83a 	sub	r2,zero,r2
81121038:	f800283a 	ret
8112103c:	00a00034 	movhi	r2,32768
81121040:	10bfffc4 	addi	r2,r2,-1
81121044:	2885883a 	add	r2,r5,r2
81121048:	f800283a 	ret
8112104c:	0005883a 	mov	r2,zero
81121050:	f800283a 	ret
81121054:	008104c4 	movi	r2,1043
81121058:	1185c83a 	sub	r2,r2,r6
8112105c:	1884d83a 	srl	r2,r3,r2
81121060:	003ff306 	br	81121030 <__reset+0xfb101030>

81121064 <__floatsidf>:
81121064:	defffd04 	addi	sp,sp,-12
81121068:	de00012e 	bgeu	sp,et,81121070 <__floatsidf+0xc>
8112106c:	003b68fa 	trap	3
81121070:	dfc00215 	stw	ra,8(sp)
81121074:	dc400115 	stw	r17,4(sp)
81121078:	dc000015 	stw	r16,0(sp)
8112107c:	20002b26 	beq	r4,zero,8112112c <__floatsidf+0xc8>
81121080:	2023883a 	mov	r17,r4
81121084:	2020d7fa 	srli	r16,r4,31
81121088:	20002d16 	blt	r4,zero,81121140 <__floatsidf+0xdc>
8112108c:	8809883a 	mov	r4,r17
81121090:	11214080 	call	81121408 <__clzsi2>
81121094:	01410784 	movi	r5,1054
81121098:	288bc83a 	sub	r5,r5,r2
8112109c:	01010cc4 	movi	r4,1075
811210a0:	2149c83a 	sub	r4,r4,r5
811210a4:	00c007c4 	movi	r3,31
811210a8:	1900160e 	bge	r3,r4,81121104 <__floatsidf+0xa0>
811210ac:	00c104c4 	movi	r3,1043
811210b0:	1947c83a 	sub	r3,r3,r5
811210b4:	88c6983a 	sll	r3,r17,r3
811210b8:	00800434 	movhi	r2,16
811210bc:	10bfffc4 	addi	r2,r2,-1
811210c0:	1886703a 	and	r3,r3,r2
811210c4:	2941ffcc 	andi	r5,r5,2047
811210c8:	800d883a 	mov	r6,r16
811210cc:	0005883a 	mov	r2,zero
811210d0:	280a953a 	slli	r5,r5,20
811210d4:	31803fcc 	andi	r6,r6,255
811210d8:	01000434 	movhi	r4,16
811210dc:	300c97fa 	slli	r6,r6,31
811210e0:	213fffc4 	addi	r4,r4,-1
811210e4:	1906703a 	and	r3,r3,r4
811210e8:	1946b03a 	or	r3,r3,r5
811210ec:	1986b03a 	or	r3,r3,r6
811210f0:	dfc00217 	ldw	ra,8(sp)
811210f4:	dc400117 	ldw	r17,4(sp)
811210f8:	dc000017 	ldw	r16,0(sp)
811210fc:	dec00304 	addi	sp,sp,12
81121100:	f800283a 	ret
81121104:	00c002c4 	movi	r3,11
81121108:	1887c83a 	sub	r3,r3,r2
8112110c:	88c6d83a 	srl	r3,r17,r3
81121110:	8904983a 	sll	r2,r17,r4
81121114:	01000434 	movhi	r4,16
81121118:	213fffc4 	addi	r4,r4,-1
8112111c:	2941ffcc 	andi	r5,r5,2047
81121120:	1906703a 	and	r3,r3,r4
81121124:	800d883a 	mov	r6,r16
81121128:	003fe906 	br	811210d0 <__reset+0xfb1010d0>
8112112c:	000d883a 	mov	r6,zero
81121130:	000b883a 	mov	r5,zero
81121134:	0007883a 	mov	r3,zero
81121138:	0005883a 	mov	r2,zero
8112113c:	003fe406 	br	811210d0 <__reset+0xfb1010d0>
81121140:	0123c83a 	sub	r17,zero,r4
81121144:	003fd106 	br	8112108c <__reset+0xfb10108c>

81121148 <__extendsfdf2>:
81121148:	200ad5fa 	srli	r5,r4,23
8112114c:	defffd04 	addi	sp,sp,-12
81121150:	de00012e 	bgeu	sp,et,81121158 <__extendsfdf2+0x10>
81121154:	003b68fa 	trap	3
81121158:	29403fcc 	andi	r5,r5,255
8112115c:	dc400115 	stw	r17,4(sp)
81121160:	29800044 	addi	r6,r5,1
81121164:	04402034 	movhi	r17,128
81121168:	dc000015 	stw	r16,0(sp)
8112116c:	8c7fffc4 	addi	r17,r17,-1
81121170:	dfc00215 	stw	ra,8(sp)
81121174:	31803fcc 	andi	r6,r6,255
81121178:	00800044 	movi	r2,1
8112117c:	8922703a 	and	r17,r17,r4
81121180:	2020d7fa 	srli	r16,r4,31
81121184:	1180110e 	bge	r2,r6,811211cc <__extendsfdf2+0x84>
81121188:	880cd0fa 	srli	r6,r17,3
8112118c:	8822977a 	slli	r17,r17,29
81121190:	2940e004 	addi	r5,r5,896
81121194:	2941ffcc 	andi	r5,r5,2047
81121198:	2804953a 	slli	r2,r5,20
8112119c:	01400434 	movhi	r5,16
811211a0:	800697fa 	slli	r3,r16,31
811211a4:	297fffc4 	addi	r5,r5,-1
811211a8:	314a703a 	and	r5,r6,r5
811211ac:	288ab03a 	or	r5,r5,r2
811211b0:	28c6b03a 	or	r3,r5,r3
811211b4:	8805883a 	mov	r2,r17
811211b8:	dfc00217 	ldw	ra,8(sp)
811211bc:	dc400117 	ldw	r17,4(sp)
811211c0:	dc000017 	ldw	r16,0(sp)
811211c4:	dec00304 	addi	sp,sp,12
811211c8:	f800283a 	ret
811211cc:	2800111e 	bne	r5,zero,81121214 <__extendsfdf2+0xcc>
811211d0:	88001c26 	beq	r17,zero,81121244 <__extendsfdf2+0xfc>
811211d4:	8809883a 	mov	r4,r17
811211d8:	11214080 	call	81121408 <__clzsi2>
811211dc:	00c00284 	movi	r3,10
811211e0:	18801b16 	blt	r3,r2,81121250 <__extendsfdf2+0x108>
811211e4:	018002c4 	movi	r6,11
811211e8:	308dc83a 	sub	r6,r6,r2
811211ec:	11000544 	addi	r4,r2,21
811211f0:	8986d83a 	srl	r3,r17,r6
811211f4:	8922983a 	sll	r17,r17,r4
811211f8:	0180e244 	movi	r6,905
811211fc:	01400434 	movhi	r5,16
81121200:	3085c83a 	sub	r2,r6,r2
81121204:	297fffc4 	addi	r5,r5,-1
81121208:	194c703a 	and	r6,r3,r5
8112120c:	1141ffcc 	andi	r5,r2,2047
81121210:	003fe006 	br	81121194 <__reset+0xfb101194>
81121214:	88000826 	beq	r17,zero,81121238 <__extendsfdf2+0xf0>
81121218:	880cd0fa 	srli	r6,r17,3
8112121c:	00800434 	movhi	r2,16
81121220:	10bfffc4 	addi	r2,r2,-1
81121224:	31800234 	orhi	r6,r6,8
81121228:	8822977a 	slli	r17,r17,29
8112122c:	308c703a 	and	r6,r6,r2
81121230:	0141ffc4 	movi	r5,2047
81121234:	003fd706 	br	81121194 <__reset+0xfb101194>
81121238:	0141ffc4 	movi	r5,2047
8112123c:	000d883a 	mov	r6,zero
81121240:	003fd406 	br	81121194 <__reset+0xfb101194>
81121244:	000b883a 	mov	r5,zero
81121248:	000d883a 	mov	r6,zero
8112124c:	003fd106 	br	81121194 <__reset+0xfb101194>
81121250:	11bffd44 	addi	r6,r2,-11
81121254:	8986983a 	sll	r3,r17,r6
81121258:	0023883a 	mov	r17,zero
8112125c:	003fe606 	br	811211f8 <__reset+0xfb1011f8>

81121260 <__truncdfsf2>:
81121260:	2810d53a 	srli	r8,r5,20
81121264:	01c00434 	movhi	r7,16
81121268:	39ffffc4 	addi	r7,r7,-1
8112126c:	29ce703a 	and	r7,r5,r7
81121270:	4201ffcc 	andi	r8,r8,2047
81121274:	380e90fa 	slli	r7,r7,3
81121278:	200cd77a 	srli	r6,r4,29
8112127c:	42400044 	addi	r9,r8,1
81121280:	4a41ffcc 	andi	r9,r9,2047
81121284:	00c00044 	movi	r3,1
81121288:	280ad7fa 	srli	r5,r5,31
8112128c:	31ceb03a 	or	r7,r6,r7
81121290:	200490fa 	slli	r2,r4,3
81121294:	1a40230e 	bge	r3,r9,81121324 <__truncdfsf2+0xc4>
81121298:	40ff2004 	addi	r3,r8,-896
8112129c:	01803f84 	movi	r6,254
811212a0:	30c01516 	blt	r6,r3,811212f8 <__truncdfsf2+0x98>
811212a4:	00c0380e 	bge	zero,r3,81121388 <__truncdfsf2+0x128>
811212a8:	200c91ba 	slli	r6,r4,6
811212ac:	380e90fa 	slli	r7,r7,3
811212b0:	1004d77a 	srli	r2,r2,29
811212b4:	300cc03a 	cmpne	r6,r6,zero
811212b8:	31ccb03a 	or	r6,r6,r7
811212bc:	308cb03a 	or	r6,r6,r2
811212c0:	308001cc 	andi	r2,r6,7
811212c4:	10000426 	beq	r2,zero,811212d8 <__truncdfsf2+0x78>
811212c8:	308003cc 	andi	r2,r6,15
811212cc:	01000104 	movi	r4,4
811212d0:	11000126 	beq	r2,r4,811212d8 <__truncdfsf2+0x78>
811212d4:	31800104 	addi	r6,r6,4
811212d8:	3081002c 	andhi	r2,r6,1024
811212dc:	10001626 	beq	r2,zero,81121338 <__truncdfsf2+0xd8>
811212e0:	18c00044 	addi	r3,r3,1
811212e4:	00803fc4 	movi	r2,255
811212e8:	18800326 	beq	r3,r2,811212f8 <__truncdfsf2+0x98>
811212ec:	300c91ba 	slli	r6,r6,6
811212f0:	300cd27a 	srli	r6,r6,9
811212f4:	00000206 	br	81121300 <__truncdfsf2+0xa0>
811212f8:	00ffffc4 	movi	r3,-1
811212fc:	000d883a 	mov	r6,zero
81121300:	18c03fcc 	andi	r3,r3,255
81121304:	180895fa 	slli	r4,r3,23
81121308:	00c02034 	movhi	r3,128
8112130c:	280a97fa 	slli	r5,r5,31
81121310:	18ffffc4 	addi	r3,r3,-1
81121314:	30c6703a 	and	r3,r6,r3
81121318:	1906b03a 	or	r3,r3,r4
8112131c:	1944b03a 	or	r2,r3,r5
81121320:	f800283a 	ret
81121324:	40000b1e 	bne	r8,zero,81121354 <__truncdfsf2+0xf4>
81121328:	388cb03a 	or	r6,r7,r2
8112132c:	0007883a 	mov	r3,zero
81121330:	30000426 	beq	r6,zero,81121344 <__truncdfsf2+0xe4>
81121334:	01800144 	movi	r6,5
81121338:	00803fc4 	movi	r2,255
8112133c:	300cd0fa 	srli	r6,r6,3
81121340:	18800a26 	beq	r3,r2,8112136c <__truncdfsf2+0x10c>
81121344:	00802034 	movhi	r2,128
81121348:	10bfffc4 	addi	r2,r2,-1
8112134c:	308c703a 	and	r6,r6,r2
81121350:	003feb06 	br	81121300 <__reset+0xfb101300>
81121354:	3888b03a 	or	r4,r7,r2
81121358:	203fe726 	beq	r4,zero,811212f8 <__reset+0xfb1012f8>
8112135c:	380c90fa 	slli	r6,r7,3
81121360:	00c03fc4 	movi	r3,255
81121364:	31808034 	orhi	r6,r6,512
81121368:	003fd506 	br	811212c0 <__reset+0xfb1012c0>
8112136c:	303fe226 	beq	r6,zero,811212f8 <__reset+0xfb1012f8>
81121370:	00802034 	movhi	r2,128
81121374:	31801034 	orhi	r6,r6,64
81121378:	10bfffc4 	addi	r2,r2,-1
8112137c:	00ffffc4 	movi	r3,-1
81121380:	308c703a 	and	r6,r6,r2
81121384:	003fde06 	br	81121300 <__reset+0xfb101300>
81121388:	013ffa44 	movi	r4,-23
8112138c:	19000e16 	blt	r3,r4,811213c8 <__truncdfsf2+0x168>
81121390:	01000784 	movi	r4,30
81121394:	20c9c83a 	sub	r4,r4,r3
81121398:	018007c4 	movi	r6,31
8112139c:	39c02034 	orhi	r7,r7,128
811213a0:	31000b16 	blt	r6,r4,811213d0 <__truncdfsf2+0x170>
811213a4:	423f2084 	addi	r8,r8,-894
811213a8:	120c983a 	sll	r6,r2,r8
811213ac:	3a0e983a 	sll	r7,r7,r8
811213b0:	1104d83a 	srl	r2,r2,r4
811213b4:	300cc03a 	cmpne	r6,r6,zero
811213b8:	31ceb03a 	or	r7,r6,r7
811213bc:	388cb03a 	or	r6,r7,r2
811213c0:	0007883a 	mov	r3,zero
811213c4:	003fbe06 	br	811212c0 <__reset+0xfb1012c0>
811213c8:	0007883a 	mov	r3,zero
811213cc:	003fd906 	br	81121334 <__reset+0xfb101334>
811213d0:	01bfff84 	movi	r6,-2
811213d4:	30cdc83a 	sub	r6,r6,r3
811213d8:	00c00804 	movi	r3,32
811213dc:	398cd83a 	srl	r6,r7,r6
811213e0:	20c00726 	beq	r4,r3,81121400 <__truncdfsf2+0x1a0>
811213e4:	423f2884 	addi	r8,r8,-862
811213e8:	3a0e983a 	sll	r7,r7,r8
811213ec:	3884b03a 	or	r2,r7,r2
811213f0:	1004c03a 	cmpne	r2,r2,zero
811213f4:	118cb03a 	or	r6,r2,r6
811213f8:	0007883a 	mov	r3,zero
811213fc:	003fb006 	br	811212c0 <__reset+0xfb1012c0>
81121400:	000f883a 	mov	r7,zero
81121404:	003ff906 	br	811213ec <__reset+0xfb1013ec>

81121408 <__clzsi2>:
81121408:	00bfffd4 	movui	r2,65535
8112140c:	11000536 	bltu	r2,r4,81121424 <__clzsi2+0x1c>
81121410:	00803fc4 	movi	r2,255
81121414:	11000f36 	bltu	r2,r4,81121454 <__clzsi2+0x4c>
81121418:	00800804 	movi	r2,32
8112141c:	0007883a 	mov	r3,zero
81121420:	00000506 	br	81121438 <__clzsi2+0x30>
81121424:	00804034 	movhi	r2,256
81121428:	10bfffc4 	addi	r2,r2,-1
8112142c:	11000c2e 	bgeu	r2,r4,81121460 <__clzsi2+0x58>
81121430:	00800204 	movi	r2,8
81121434:	00c00604 	movi	r3,24
81121438:	20c8d83a 	srl	r4,r4,r3
8112143c:	00e04574 	movhi	r3,33045
81121440:	18c25404 	addi	r3,r3,2384
81121444:	1909883a 	add	r4,r3,r4
81121448:	20c00003 	ldbu	r3,0(r4)
8112144c:	10c5c83a 	sub	r2,r2,r3
81121450:	f800283a 	ret
81121454:	00800604 	movi	r2,24
81121458:	00c00204 	movi	r3,8
8112145c:	003ff606 	br	81121438 <__reset+0xfb101438>
81121460:	00800404 	movi	r2,16
81121464:	1007883a 	mov	r3,r2
81121468:	003ff306 	br	81121438 <__reset+0xfb101438>

8112146c <atoi>:
8112146c:	01800284 	movi	r6,10
81121470:	000b883a 	mov	r5,zero
81121474:	11234a01 	jmpi	811234a0 <strtol>

81121478 <_atoi_r>:
81121478:	01c00284 	movi	r7,10
8112147c:	000d883a 	mov	r6,zero
81121480:	11232601 	jmpi	81123260 <_strtol_r>

81121484 <atoll>:
81121484:	01800284 	movi	r6,10
81121488:	000b883a 	mov	r5,zero
8112148c:	11234bc1 	jmpi	811234bc <strtoll>

81121490 <_atoll_r>:
81121490:	01c00284 	movi	r7,10
81121494:	000d883a 	mov	r6,zero
81121498:	11234d81 	jmpi	811234d8 <_strtoll_r>

8112149c <_fopen_r>:
8112149c:	defffa04 	addi	sp,sp,-24
811214a0:	3005883a 	mov	r2,r6
811214a4:	de00012e 	bgeu	sp,et,811214ac <_fopen_r+0x10>
811214a8:	003b68fa 	trap	3
811214ac:	d80d883a 	mov	r6,sp
811214b0:	dcc00415 	stw	r19,16(sp)
811214b4:	2827883a 	mov	r19,r5
811214b8:	100b883a 	mov	r5,r2
811214bc:	dc800315 	stw	r18,12(sp)
811214c0:	dfc00515 	stw	ra,20(sp)
811214c4:	dc400215 	stw	r17,8(sp)
811214c8:	dc000115 	stw	r16,4(sp)
811214cc:	2025883a 	mov	r18,r4
811214d0:	112b7ac0 	call	8112b7ac <__sflags>
811214d4:	10002726 	beq	r2,zero,81121574 <_fopen_r+0xd8>
811214d8:	9009883a 	mov	r4,r18
811214dc:	1023883a 	mov	r17,r2
811214e0:	112b6240 	call	8112b624 <__sfp>
811214e4:	1021883a 	mov	r16,r2
811214e8:	10002226 	beq	r2,zero,81121574 <_fopen_r+0xd8>
811214ec:	d9800017 	ldw	r6,0(sp)
811214f0:	01c06d84 	movi	r7,438
811214f4:	980b883a 	mov	r5,r19
811214f8:	9009883a 	mov	r4,r18
811214fc:	11229080 	call	81122908 <_open_r>
81121500:	10001916 	blt	r2,zero,81121568 <_fopen_r+0xcc>
81121504:	8080038d 	sth	r2,14(r16)
81121508:	00a044b4 	movhi	r2,33042
8112150c:	108bf904 	addi	r2,r2,12260
81121510:	80800815 	stw	r2,32(r16)
81121514:	00a044b4 	movhi	r2,33042
81121518:	108c1204 	addi	r2,r2,12360
8112151c:	80800915 	stw	r2,36(r16)
81121520:	00a044b4 	movhi	r2,33042
81121524:	108c3304 	addi	r2,r2,12492
81121528:	80800a15 	stw	r2,40(r16)
8112152c:	00a044b4 	movhi	r2,33042
81121530:	108c4c04 	addi	r2,r2,12592
81121534:	8440030d 	sth	r17,12(r16)
81121538:	84000715 	stw	r16,28(r16)
8112153c:	80800b15 	stw	r2,44(r16)
81121540:	8c40400c 	andi	r17,r17,256
81121544:	88000d1e 	bne	r17,zero,8112157c <_fopen_r+0xe0>
81121548:	8005883a 	mov	r2,r16
8112154c:	dfc00517 	ldw	ra,20(sp)
81121550:	dcc00417 	ldw	r19,16(sp)
81121554:	dc800317 	ldw	r18,12(sp)
81121558:	dc400217 	ldw	r17,8(sp)
8112155c:	dc000117 	ldw	r16,4(sp)
81121560:	dec00604 	addi	sp,sp,24
81121564:	f800283a 	ret
81121568:	112b76c0 	call	8112b76c <__sfp_lock_acquire>
8112156c:	8000030d 	sth	zero,12(r16)
81121570:	112b7700 	call	8112b770 <__sfp_lock_release>
81121574:	0005883a 	mov	r2,zero
81121578:	003ff406 	br	8112154c <__reset+0xfb10154c>
8112157c:	01c00084 	movi	r7,2
81121580:	000d883a 	mov	r6,zero
81121584:	800b883a 	mov	r5,r16
81121588:	9009883a 	mov	r4,r18
8112158c:	11216bc0 	call	811216bc <_fseek_r>
81121590:	8005883a 	mov	r2,r16
81121594:	003fed06 	br	8112154c <__reset+0xfb10154c>

81121598 <fopen>:
81121598:	00a04574 	movhi	r2,33045
8112159c:	108d0f04 	addi	r2,r2,13372
811215a0:	280d883a 	mov	r6,r5
811215a4:	200b883a 	mov	r5,r4
811215a8:	11000017 	ldw	r4,0(r2)
811215ac:	112149c1 	jmpi	8112149c <_fopen_r>

811215b0 <_fprintf_r>:
811215b0:	defffe04 	addi	sp,sp,-8
811215b4:	2809883a 	mov	r4,r5
811215b8:	300b883a 	mov	r5,r6
811215bc:	de00012e 	bgeu	sp,et,811215c4 <_fprintf_r+0x14>
811215c0:	003b68fa 	trap	3
811215c4:	dfc00015 	stw	ra,0(sp)
811215c8:	d9c00115 	stw	r7,4(sp)
811215cc:	d9800104 	addi	r6,sp,4
811215d0:	1127ba00 	call	81127ba0 <__vfprintf_internal>
811215d4:	dfc00017 	ldw	ra,0(sp)
811215d8:	dec00204 	addi	sp,sp,8
811215dc:	f800283a 	ret

811215e0 <fprintf>:
811215e0:	defffd04 	addi	sp,sp,-12
811215e4:	de00012e 	bgeu	sp,et,811215ec <fprintf+0xc>
811215e8:	003b68fa 	trap	3
811215ec:	dfc00015 	stw	ra,0(sp)
811215f0:	d9800115 	stw	r6,4(sp)
811215f4:	d9c00215 	stw	r7,8(sp)
811215f8:	d9800104 	addi	r6,sp,4
811215fc:	1127ba00 	call	81127ba0 <__vfprintf_internal>
81121600:	dfc00017 	ldw	ra,0(sp)
81121604:	dec00304 	addi	sp,sp,12
81121608:	f800283a 	ret

8112160c <_fputc_r>:
8112160c:	defffc04 	addi	sp,sp,-16
81121610:	de00012e 	bgeu	sp,et,81121618 <_fputc_r+0xc>
81121614:	003b68fa 	trap	3
81121618:	dc000215 	stw	r16,8(sp)
8112161c:	dfc00315 	stw	ra,12(sp)
81121620:	2021883a 	mov	r16,r4
81121624:	20000726 	beq	r4,zero,81121644 <_fputc_r+0x38>
81121628:	20800e17 	ldw	r2,56(r4)
8112162c:	1000051e 	bne	r2,zero,81121644 <_fputc_r+0x38>
81121630:	d9400015 	stw	r5,0(sp)
81121634:	d9800115 	stw	r6,4(sp)
81121638:	112b75c0 	call	8112b75c <__sinit>
8112163c:	d9800117 	ldw	r6,4(sp)
81121640:	d9400017 	ldw	r5,0(sp)
81121644:	8009883a 	mov	r4,r16
81121648:	dfc00317 	ldw	ra,12(sp)
8112164c:	dc000217 	ldw	r16,8(sp)
81121650:	dec00404 	addi	sp,sp,16
81121654:	11229ec1 	jmpi	811229ec <_putc_r>

81121658 <fputc>:
81121658:	00a04574 	movhi	r2,33045
8112165c:	defffc04 	addi	sp,sp,-16
81121660:	108d0f04 	addi	r2,r2,13372
81121664:	de00012e 	bgeu	sp,et,8112166c <fputc+0x14>
81121668:	003b68fa 	trap	3
8112166c:	dc000115 	stw	r16,4(sp)
81121670:	14000017 	ldw	r16,0(r2)
81121674:	dc400215 	stw	r17,8(sp)
81121678:	dfc00315 	stw	ra,12(sp)
8112167c:	2023883a 	mov	r17,r4
81121680:	80000626 	beq	r16,zero,8112169c <fputc+0x44>
81121684:	80800e17 	ldw	r2,56(r16)
81121688:	1000041e 	bne	r2,zero,8112169c <fputc+0x44>
8112168c:	8009883a 	mov	r4,r16
81121690:	d9400015 	stw	r5,0(sp)
81121694:	112b75c0 	call	8112b75c <__sinit>
81121698:	d9400017 	ldw	r5,0(sp)
8112169c:	280d883a 	mov	r6,r5
811216a0:	8009883a 	mov	r4,r16
811216a4:	880b883a 	mov	r5,r17
811216a8:	dfc00317 	ldw	ra,12(sp)
811216ac:	dc400217 	ldw	r17,8(sp)
811216b0:	dc000117 	ldw	r16,4(sp)
811216b4:	dec00404 	addi	sp,sp,16
811216b8:	11229ec1 	jmpi	811229ec <_putc_r>

811216bc <_fseek_r>:
811216bc:	11216dc1 	jmpi	811216dc <_fseeko_r>

811216c0 <fseek>:
811216c0:	00a04574 	movhi	r2,33045
811216c4:	108d0f04 	addi	r2,r2,13372
811216c8:	300f883a 	mov	r7,r6
811216cc:	280d883a 	mov	r6,r5
811216d0:	200b883a 	mov	r5,r4
811216d4:	11000017 	ldw	r4,0(r2)
811216d8:	11216dc1 	jmpi	811216dc <_fseeko_r>

811216dc <_fseeko_r>:
811216dc:	deffe804 	addi	sp,sp,-96
811216e0:	de00012e 	bgeu	sp,et,811216e8 <_fseeko_r+0xc>
811216e4:	003b68fa 	trap	3
811216e8:	dd401415 	stw	r21,80(sp)
811216ec:	dc801115 	stw	r18,68(sp)
811216f0:	dc401015 	stw	r17,64(sp)
811216f4:	dc000f15 	stw	r16,60(sp)
811216f8:	dfc01715 	stw	ra,92(sp)
811216fc:	ddc01615 	stw	r23,88(sp)
81121700:	dd801515 	stw	r22,84(sp)
81121704:	dd001315 	stw	r20,76(sp)
81121708:	dcc01215 	stw	r19,72(sp)
8112170c:	2023883a 	mov	r17,r4
81121710:	2821883a 	mov	r16,r5
81121714:	302b883a 	mov	r21,r6
81121718:	3825883a 	mov	r18,r7
8112171c:	20000226 	beq	r4,zero,81121728 <_fseeko_r+0x4c>
81121720:	20800e17 	ldw	r2,56(r4)
81121724:	10005a26 	beq	r2,zero,81121890 <_fseeko_r+0x1b4>
81121728:	8080030b 	ldhu	r2,12(r16)
8112172c:	00c04204 	movi	r3,264
81121730:	1080420c 	andi	r2,r2,264
81121734:	10c05b26 	beq	r2,r3,811218a4 <_fseeko_r+0x1c8>
81121738:	85000a17 	ldw	r20,40(r16)
8112173c:	a000f626 	beq	r20,zero,81121b18 <_fseeko_r+0x43c>
81121740:	00800044 	movi	r2,1
81121744:	90803e26 	beq	r18,r2,81121840 <_fseeko_r+0x164>
81121748:	00800084 	movi	r2,2
8112174c:	90801026 	beq	r18,r2,81121790 <_fseeko_r+0xb4>
81121750:	90000f26 	beq	r18,zero,81121790 <_fseeko_r+0xb4>
81121754:	00800584 	movi	r2,22
81121758:	88800015 	stw	r2,0(r17)
8112175c:	04ffffc4 	movi	r19,-1
81121760:	9805883a 	mov	r2,r19
81121764:	dfc01717 	ldw	ra,92(sp)
81121768:	ddc01617 	ldw	r23,88(sp)
8112176c:	dd801517 	ldw	r22,84(sp)
81121770:	dd401417 	ldw	r21,80(sp)
81121774:	dd001317 	ldw	r20,76(sp)
81121778:	dcc01217 	ldw	r19,72(sp)
8112177c:	dc801117 	ldw	r18,68(sp)
81121780:	dc401017 	ldw	r17,64(sp)
81121784:	dc000f17 	ldw	r16,60(sp)
81121788:	dec01804 	addi	sp,sp,96
8112178c:	f800283a 	ret
81121790:	80800417 	ldw	r2,16(r16)
81121794:	002f883a 	mov	r23,zero
81121798:	0027883a 	mov	r19,zero
8112179c:	1000cb26 	beq	r2,zero,81121acc <_fseeko_r+0x3f0>
811217a0:	8080030b 	ldhu	r2,12(r16)
811217a4:	10c2068c 	andi	r3,r2,2074
811217a8:	1800071e 	bne	r3,zero,811217c8 <_fseeko_r+0xec>
811217ac:	10c1000c 	andi	r3,r2,1024
811217b0:	1800451e 	bne	r3,zero,811218c8 <_fseeko_r+0x1ec>
811217b4:	00e044b4 	movhi	r3,33042
811217b8:	18cc3304 	addi	r3,r3,12492
811217bc:	a0c0b726 	beq	r20,r3,81121a9c <_fseeko_r+0x3c0>
811217c0:	10820014 	ori	r2,r2,2048
811217c4:	8080030d 	sth	r2,12(r16)
811217c8:	800b883a 	mov	r5,r16
811217cc:	8809883a 	mov	r4,r17
811217d0:	112b3600 	call	8112b360 <_fflush_r>
811217d4:	1027883a 	mov	r19,r2
811217d8:	103fe01e 	bne	r2,zero,8112175c <__reset+0xfb10175c>
811217dc:	81400717 	ldw	r5,28(r16)
811217e0:	900f883a 	mov	r7,r18
811217e4:	a80d883a 	mov	r6,r21
811217e8:	8809883a 	mov	r4,r17
811217ec:	a03ee83a 	callr	r20
811217f0:	00ffffc4 	movi	r3,-1
811217f4:	10ffd926 	beq	r2,r3,8112175c <__reset+0xfb10175c>
811217f8:	81400c17 	ldw	r5,48(r16)
811217fc:	28000526 	beq	r5,zero,81121814 <_fseeko_r+0x138>
81121800:	80801004 	addi	r2,r16,64
81121804:	28800226 	beq	r5,r2,81121810 <_fseeko_r+0x134>
81121808:	8809883a 	mov	r4,r17
8112180c:	112bbf40 	call	8112bbf4 <_free_r>
81121810:	80000c15 	stw	zero,48(r16)
81121814:	8080030b 	ldhu	r2,12(r16)
81121818:	80c00417 	ldw	r3,16(r16)
8112181c:	80000115 	stw	zero,4(r16)
81121820:	10bdf7cc 	andi	r2,r2,63455
81121824:	80c00015 	stw	r3,0(r16)
81121828:	8080030d 	sth	r2,12(r16)
8112182c:	01800204 	movi	r6,8
81121830:	000b883a 	mov	r5,zero
81121834:	81001704 	addi	r4,r16,92
81121838:	11227e00 	call	811227e0 <memset>
8112183c:	003fc806 	br	81121760 <__reset+0xfb101760>
81121840:	800b883a 	mov	r5,r16
81121844:	8809883a 	mov	r4,r17
81121848:	112b3600 	call	8112b360 <_fflush_r>
8112184c:	8080030b 	ldhu	r2,12(r16)
81121850:	10c4000c 	andi	r3,r2,4096
81121854:	18008726 	beq	r3,zero,81121a74 <_fseeko_r+0x398>
81121858:	84c01417 	ldw	r19,80(r16)
8112185c:	10c0010c 	andi	r3,r2,4
81121860:	1800431e 	bne	r3,zero,81121970 <_fseeko_r+0x294>
81121864:	1080020c 	andi	r2,r2,8
81121868:	10008026 	beq	r2,zero,81121a6c <_fseeko_r+0x390>
8112186c:	80c00017 	ldw	r3,0(r16)
81121870:	80800417 	ldw	r2,16(r16)
81121874:	18000226 	beq	r3,zero,81121880 <_fseeko_r+0x1a4>
81121878:	1887c83a 	sub	r3,r3,r2
8112187c:	98e7883a 	add	r19,r19,r3
81121880:	aceb883a 	add	r21,r21,r19
81121884:	05c00044 	movi	r23,1
81121888:	0025883a 	mov	r18,zero
8112188c:	003fc306 	br	8112179c <__reset+0xfb10179c>
81121890:	112b75c0 	call	8112b75c <__sinit>
81121894:	8080030b 	ldhu	r2,12(r16)
81121898:	00c04204 	movi	r3,264
8112189c:	1080420c 	andi	r2,r2,264
811218a0:	10ffa51e 	bne	r2,r3,81121738 <__reset+0xfb101738>
811218a4:	800b883a 	mov	r5,r16
811218a8:	8809883a 	mov	r4,r17
811218ac:	112b3600 	call	8112b360 <_fflush_r>
811218b0:	003fa106 	br	81121738 <__reset+0xfb101738>
811218b4:	8080030b 	ldhu	r2,12(r16)
811218b8:	00c10004 	movi	r3,1024
811218bc:	80c01315 	stw	r3,76(r16)
811218c0:	10c4b03a 	or	r2,r2,r3
811218c4:	8080030d 	sth	r2,12(r16)
811218c8:	9000311e 	bne	r18,zero,81121990 <_fseeko_r+0x2b4>
811218cc:	a82d883a 	mov	r22,r21
811218d0:	b800371e 	bne	r23,zero,811219b0 <_fseeko_r+0x2d4>
811218d4:	8080030b 	ldhu	r2,12(r16)
811218d8:	1084000c 	andi	r2,r2,4096
811218dc:	10007f26 	beq	r2,zero,81121adc <_fseeko_r+0x400>
811218e0:	80801417 	ldw	r2,80(r16)
811218e4:	81800117 	ldw	r6,4(r16)
811218e8:	81400c17 	ldw	r5,48(r16)
811218ec:	11a7c83a 	sub	r19,r2,r6
811218f0:	28008226 	beq	r5,zero,81121afc <_fseeko_r+0x420>
811218f4:	81c00f17 	ldw	r7,60(r16)
811218f8:	99e7c83a 	sub	r19,r19,r7
811218fc:	81000e17 	ldw	r4,56(r16)
81121900:	80800417 	ldw	r2,16(r16)
81121904:	99a7883a 	add	r19,r19,r6
81121908:	2087c83a 	sub	r3,r4,r2
8112190c:	98e7c83a 	sub	r19,r19,r3
81121910:	38c7883a 	add	r3,r7,r3
81121914:	b4c02b16 	blt	r22,r19,811219c4 <_fseeko_r+0x2e8>
81121918:	98c9883a 	add	r4,r19,r3
8112191c:	b100292e 	bgeu	r22,r4,811219c4 <_fseeko_r+0x2e8>
81121920:	b4e7c83a 	sub	r19,r22,r19
81121924:	14c5883a 	add	r2,r2,r19
81121928:	1ce7c83a 	sub	r19,r3,r19
8112192c:	80800015 	stw	r2,0(r16)
81121930:	84c00115 	stw	r19,4(r16)
81121934:	28000526 	beq	r5,zero,8112194c <_fseeko_r+0x270>
81121938:	80801004 	addi	r2,r16,64
8112193c:	28800226 	beq	r5,r2,81121948 <_fseeko_r+0x26c>
81121940:	8809883a 	mov	r4,r17
81121944:	112bbf40 	call	8112bbf4 <_free_r>
81121948:	80000c15 	stw	zero,48(r16)
8112194c:	8080030b 	ldhu	r2,12(r16)
81121950:	01800204 	movi	r6,8
81121954:	000b883a 	mov	r5,zero
81121958:	10bff7cc 	andi	r2,r2,65503
8112195c:	8080030d 	sth	r2,12(r16)
81121960:	81001704 	addi	r4,r16,92
81121964:	11227e00 	call	811227e0 <memset>
81121968:	0027883a 	mov	r19,zero
8112196c:	003f7c06 	br	81121760 <__reset+0xfb101760>
81121970:	80c00117 	ldw	r3,4(r16)
81121974:	80800c17 	ldw	r2,48(r16)
81121978:	98e7c83a 	sub	r19,r19,r3
8112197c:	10003b26 	beq	r2,zero,81121a6c <_fseeko_r+0x390>
81121980:	80c00f17 	ldw	r3,60(r16)
81121984:	80800417 	ldw	r2,16(r16)
81121988:	98e7c83a 	sub	r19,r19,r3
8112198c:	003fbc06 	br	81121880 <__reset+0xfb101880>
81121990:	8140038f 	ldh	r5,14(r16)
81121994:	d80d883a 	mov	r6,sp
81121998:	8809883a 	mov	r4,r17
8112199c:	1121b440 	call	81121b44 <_fstat_r>
811219a0:	103f891e 	bne	r2,zero,811217c8 <__reset+0xfb1017c8>
811219a4:	dd800417 	ldw	r22,16(sp)
811219a8:	adad883a 	add	r22,r21,r22
811219ac:	b83fc926 	beq	r23,zero,811218d4 <__reset+0xfb1018d4>
811219b0:	81400c17 	ldw	r5,48(r16)
811219b4:	81800117 	ldw	r6,4(r16)
811219b8:	28005026 	beq	r5,zero,81121afc <_fseeko_r+0x420>
811219bc:	81c00f17 	ldw	r7,60(r16)
811219c0:	003fce06 	br	811218fc <__reset+0xfb1018fc>
811219c4:	84c01317 	ldw	r19,76(r16)
811219c8:	81400717 	ldw	r5,28(r16)
811219cc:	000f883a 	mov	r7,zero
811219d0:	04e7c83a 	sub	r19,zero,r19
811219d4:	9da6703a 	and	r19,r19,r22
811219d8:	980d883a 	mov	r6,r19
811219dc:	8809883a 	mov	r4,r17
811219e0:	a03ee83a 	callr	r20
811219e4:	00ffffc4 	movi	r3,-1
811219e8:	10ff7726 	beq	r2,r3,811217c8 <__reset+0xfb1017c8>
811219ec:	80800417 	ldw	r2,16(r16)
811219f0:	81400c17 	ldw	r5,48(r16)
811219f4:	80000115 	stw	zero,4(r16)
811219f8:	80800015 	stw	r2,0(r16)
811219fc:	28000526 	beq	r5,zero,81121a14 <_fseeko_r+0x338>
81121a00:	80801004 	addi	r2,r16,64
81121a04:	28800226 	beq	r5,r2,81121a10 <_fseeko_r+0x334>
81121a08:	8809883a 	mov	r4,r17
81121a0c:	112bbf40 	call	8112bbf4 <_free_r>
81121a10:	80000c15 	stw	zero,48(r16)
81121a14:	8080030b 	ldhu	r2,12(r16)
81121a18:	b4e7c83a 	sub	r19,r22,r19
81121a1c:	10bff7cc 	andi	r2,r2,65503
81121a20:	8080030d 	sth	r2,12(r16)
81121a24:	98000b26 	beq	r19,zero,81121a54 <_fseeko_r+0x378>
81121a28:	800b883a 	mov	r5,r16
81121a2c:	8809883a 	mov	r4,r17
81121a30:	1122c5c0 	call	81122c5c <__srefill_r>
81121a34:	103f641e 	bne	r2,zero,811217c8 <__reset+0xfb1017c8>
81121a38:	80800117 	ldw	r2,4(r16)
81121a3c:	14ff6236 	bltu	r2,r19,811217c8 <__reset+0xfb1017c8>
81121a40:	80c00017 	ldw	r3,0(r16)
81121a44:	14c5c83a 	sub	r2,r2,r19
81121a48:	80800115 	stw	r2,4(r16)
81121a4c:	1ce7883a 	add	r19,r3,r19
81121a50:	84c00015 	stw	r19,0(r16)
81121a54:	01800204 	movi	r6,8
81121a58:	000b883a 	mov	r5,zero
81121a5c:	81001704 	addi	r4,r16,92
81121a60:	11227e00 	call	811227e0 <memset>
81121a64:	0027883a 	mov	r19,zero
81121a68:	003f3d06 	br	81121760 <__reset+0xfb101760>
81121a6c:	80800417 	ldw	r2,16(r16)
81121a70:	003f8306 	br	81121880 <__reset+0xfb101880>
81121a74:	81400717 	ldw	r5,28(r16)
81121a78:	900f883a 	mov	r7,r18
81121a7c:	000d883a 	mov	r6,zero
81121a80:	8809883a 	mov	r4,r17
81121a84:	a03ee83a 	callr	r20
81121a88:	1027883a 	mov	r19,r2
81121a8c:	00bfffc4 	movi	r2,-1
81121a90:	98bf3226 	beq	r19,r2,8112175c <__reset+0xfb10175c>
81121a94:	8080030b 	ldhu	r2,12(r16)
81121a98:	003f7006 	br	8112185c <__reset+0xfb10185c>
81121a9c:	8140038f 	ldh	r5,14(r16)
81121aa0:	283f4716 	blt	r5,zero,811217c0 <__reset+0xfb1017c0>
81121aa4:	d80d883a 	mov	r6,sp
81121aa8:	8809883a 	mov	r4,r17
81121aac:	1121b440 	call	81121b44 <_fstat_r>
81121ab0:	1000041e 	bne	r2,zero,81121ac4 <_fseeko_r+0x3e8>
81121ab4:	d8800117 	ldw	r2,4(sp)
81121ab8:	00e00014 	movui	r3,32768
81121abc:	10bc000c 	andi	r2,r2,61440
81121ac0:	10ff7c26 	beq	r2,r3,811218b4 <__reset+0xfb1018b4>
81121ac4:	8080030b 	ldhu	r2,12(r16)
81121ac8:	003f3d06 	br	811217c0 <__reset+0xfb1017c0>
81121acc:	800b883a 	mov	r5,r16
81121ad0:	8809883a 	mov	r4,r17
81121ad4:	1121cb80 	call	81121cb8 <__smakebuf_r>
81121ad8:	003f3106 	br	811217a0 <__reset+0xfb1017a0>
81121adc:	81400717 	ldw	r5,28(r16)
81121ae0:	01c00044 	movi	r7,1
81121ae4:	000d883a 	mov	r6,zero
81121ae8:	8809883a 	mov	r4,r17
81121aec:	a03ee83a 	callr	r20
81121af0:	00ffffc4 	movi	r3,-1
81121af4:	10ff7b1e 	bne	r2,r3,811218e4 <__reset+0xfb1018e4>
81121af8:	003f3306 	br	811217c8 <__reset+0xfb1017c8>
81121afc:	80c00017 	ldw	r3,0(r16)
81121b00:	80800417 	ldw	r2,16(r16)
81121b04:	000b883a 	mov	r5,zero
81121b08:	1887c83a 	sub	r3,r3,r2
81121b0c:	98e7c83a 	sub	r19,r19,r3
81121b10:	30c7883a 	add	r3,r6,r3
81121b14:	003f7f06 	br	81121914 <__reset+0xfb101914>
81121b18:	00800744 	movi	r2,29
81121b1c:	88800015 	stw	r2,0(r17)
81121b20:	04ffffc4 	movi	r19,-1
81121b24:	003f0e06 	br	81121760 <__reset+0xfb101760>

81121b28 <fseeko>:
81121b28:	00a04574 	movhi	r2,33045
81121b2c:	108d0f04 	addi	r2,r2,13372
81121b30:	300f883a 	mov	r7,r6
81121b34:	280d883a 	mov	r6,r5
81121b38:	200b883a 	mov	r5,r4
81121b3c:	11000017 	ldw	r4,0(r2)
81121b40:	11216dc1 	jmpi	811216dc <_fseeko_r>

81121b44 <_fstat_r>:
81121b44:	defffd04 	addi	sp,sp,-12
81121b48:	de00012e 	bgeu	sp,et,81121b50 <_fstat_r+0xc>
81121b4c:	003b68fa 	trap	3
81121b50:	2805883a 	mov	r2,r5
81121b54:	dc000015 	stw	r16,0(sp)
81121b58:	04204574 	movhi	r16,33045
81121b5c:	dc400115 	stw	r17,4(sp)
81121b60:	840d8204 	addi	r16,r16,13832
81121b64:	2023883a 	mov	r17,r4
81121b68:	300b883a 	mov	r5,r6
81121b6c:	1009883a 	mov	r4,r2
81121b70:	dfc00215 	stw	ra,8(sp)
81121b74:	80000015 	stw	zero,0(r16)
81121b78:	113658c0 	call	8113658c <fstat>
81121b7c:	00ffffc4 	movi	r3,-1
81121b80:	10c00526 	beq	r2,r3,81121b98 <_fstat_r+0x54>
81121b84:	dfc00217 	ldw	ra,8(sp)
81121b88:	dc400117 	ldw	r17,4(sp)
81121b8c:	dc000017 	ldw	r16,0(sp)
81121b90:	dec00304 	addi	sp,sp,12
81121b94:	f800283a 	ret
81121b98:	80c00017 	ldw	r3,0(r16)
81121b9c:	183ff926 	beq	r3,zero,81121b84 <__reset+0xfb101b84>
81121ba0:	88c00015 	stw	r3,0(r17)
81121ba4:	003ff706 	br	81121b84 <__reset+0xfb101b84>

81121ba8 <_fwrite_r>:
81121ba8:	defff504 	addi	sp,sp,-44
81121bac:	de00012e 	bgeu	sp,et,81121bb4 <_fwrite_r+0xc>
81121bb0:	003b68fa 	trap	3
81121bb4:	dc800815 	stw	r18,32(sp)
81121bb8:	39a5383a 	mul	r18,r7,r6
81121bbc:	d8800304 	addi	r2,sp,12
81121bc0:	d8800015 	stw	r2,0(sp)
81121bc4:	00800044 	movi	r2,1
81121bc8:	dcc00915 	stw	r19,36(sp)
81121bcc:	dc400715 	stw	r17,28(sp)
81121bd0:	dc000615 	stw	r16,24(sp)
81121bd4:	d9400315 	stw	r5,12(sp)
81121bd8:	dfc00a15 	stw	ra,40(sp)
81121bdc:	dc800415 	stw	r18,16(sp)
81121be0:	dc800215 	stw	r18,8(sp)
81121be4:	d8800115 	stw	r2,4(sp)
81121be8:	3027883a 	mov	r19,r6
81121bec:	3821883a 	mov	r16,r7
81121bf0:	2023883a 	mov	r17,r4
81121bf4:	d9400b17 	ldw	r5,44(sp)
81121bf8:	20000226 	beq	r4,zero,81121c04 <_fwrite_r+0x5c>
81121bfc:	20800e17 	ldw	r2,56(r4)
81121c00:	10001a26 	beq	r2,zero,81121c6c <_fwrite_r+0xc4>
81121c04:	2880030b 	ldhu	r2,12(r5)
81121c08:	10c8000c 	andi	r3,r2,8192
81121c0c:	1800061e 	bne	r3,zero,81121c28 <_fwrite_r+0x80>
81121c10:	29001917 	ldw	r4,100(r5)
81121c14:	00f7ffc4 	movi	r3,-8193
81121c18:	10880014 	ori	r2,r2,8192
81121c1c:	20c6703a 	and	r3,r4,r3
81121c20:	2880030d 	sth	r2,12(r5)
81121c24:	28c01915 	stw	r3,100(r5)
81121c28:	d80d883a 	mov	r6,sp
81121c2c:	8809883a 	mov	r4,r17
81121c30:	112bf0c0 	call	8112bf0c <__sfvwrite_r>
81121c34:	10000b26 	beq	r2,zero,81121c64 <_fwrite_r+0xbc>
81121c38:	d9000217 	ldw	r4,8(sp)
81121c3c:	980b883a 	mov	r5,r19
81121c40:	9109c83a 	sub	r4,r18,r4
81121c44:	1134c180 	call	81134c18 <__udivsi3>
81121c48:	dfc00a17 	ldw	ra,40(sp)
81121c4c:	dcc00917 	ldw	r19,36(sp)
81121c50:	dc800817 	ldw	r18,32(sp)
81121c54:	dc400717 	ldw	r17,28(sp)
81121c58:	dc000617 	ldw	r16,24(sp)
81121c5c:	dec00b04 	addi	sp,sp,44
81121c60:	f800283a 	ret
81121c64:	8005883a 	mov	r2,r16
81121c68:	003ff706 	br	81121c48 <__reset+0xfb101c48>
81121c6c:	d9400515 	stw	r5,20(sp)
81121c70:	112b75c0 	call	8112b75c <__sinit>
81121c74:	d9400517 	ldw	r5,20(sp)
81121c78:	003fe206 	br	81121c04 <__reset+0xfb101c04>

81121c7c <fwrite>:
81121c7c:	defffe04 	addi	sp,sp,-8
81121c80:	00a04574 	movhi	r2,33045
81121c84:	de00012e 	bgeu	sp,et,81121c8c <fwrite+0x10>
81121c88:	003b68fa 	trap	3
81121c8c:	108d0f04 	addi	r2,r2,13372
81121c90:	d9c00015 	stw	r7,0(sp)
81121c94:	300f883a 	mov	r7,r6
81121c98:	280d883a 	mov	r6,r5
81121c9c:	200b883a 	mov	r5,r4
81121ca0:	11000017 	ldw	r4,0(r2)
81121ca4:	dfc00115 	stw	ra,4(sp)
81121ca8:	1121ba80 	call	81121ba8 <_fwrite_r>
81121cac:	dfc00117 	ldw	ra,4(sp)
81121cb0:	dec00204 	addi	sp,sp,8
81121cb4:	f800283a 	ret

81121cb8 <__smakebuf_r>:
81121cb8:	2880030b 	ldhu	r2,12(r5)
81121cbc:	10c0008c 	andi	r3,r2,2
81121cc0:	1800431e 	bne	r3,zero,81121dd0 <__smakebuf_r+0x118>
81121cc4:	deffec04 	addi	sp,sp,-80
81121cc8:	de00012e 	bgeu	sp,et,81121cd0 <__smakebuf_r+0x18>
81121ccc:	003b68fa 	trap	3
81121cd0:	dc000f15 	stw	r16,60(sp)
81121cd4:	2821883a 	mov	r16,r5
81121cd8:	2940038f 	ldh	r5,14(r5)
81121cdc:	dc401015 	stw	r17,64(sp)
81121ce0:	dfc01315 	stw	ra,76(sp)
81121ce4:	dcc01215 	stw	r19,72(sp)
81121ce8:	dc801115 	stw	r18,68(sp)
81121cec:	2023883a 	mov	r17,r4
81121cf0:	28001c16 	blt	r5,zero,81121d64 <__smakebuf_r+0xac>
81121cf4:	d80d883a 	mov	r6,sp
81121cf8:	1121b440 	call	81121b44 <_fstat_r>
81121cfc:	10001816 	blt	r2,zero,81121d60 <__smakebuf_r+0xa8>
81121d00:	d8800117 	ldw	r2,4(sp)
81121d04:	00e00014 	movui	r3,32768
81121d08:	10bc000c 	andi	r2,r2,61440
81121d0c:	14c80020 	cmpeqi	r19,r2,8192
81121d10:	10c03726 	beq	r2,r3,81121df0 <__smakebuf_r+0x138>
81121d14:	80c0030b 	ldhu	r3,12(r16)
81121d18:	18c20014 	ori	r3,r3,2048
81121d1c:	80c0030d 	sth	r3,12(r16)
81121d20:	00c80004 	movi	r3,8192
81121d24:	10c0521e 	bne	r2,r3,81121e70 <__smakebuf_r+0x1b8>
81121d28:	8140038f 	ldh	r5,14(r16)
81121d2c:	8809883a 	mov	r4,r17
81121d30:	112c5680 	call	8112c568 <_isatty_r>
81121d34:	10004c26 	beq	r2,zero,81121e68 <__smakebuf_r+0x1b0>
81121d38:	8080030b 	ldhu	r2,12(r16)
81121d3c:	80c010c4 	addi	r3,r16,67
81121d40:	80c00015 	stw	r3,0(r16)
81121d44:	10800054 	ori	r2,r2,1
81121d48:	8080030d 	sth	r2,12(r16)
81121d4c:	00800044 	movi	r2,1
81121d50:	80c00415 	stw	r3,16(r16)
81121d54:	80800515 	stw	r2,20(r16)
81121d58:	04810004 	movi	r18,1024
81121d5c:	00000706 	br	81121d7c <__smakebuf_r+0xc4>
81121d60:	8080030b 	ldhu	r2,12(r16)
81121d64:	10c0200c 	andi	r3,r2,128
81121d68:	18001f1e 	bne	r3,zero,81121de8 <__smakebuf_r+0x130>
81121d6c:	04810004 	movi	r18,1024
81121d70:	10820014 	ori	r2,r2,2048
81121d74:	8080030d 	sth	r2,12(r16)
81121d78:	0027883a 	mov	r19,zero
81121d7c:	900b883a 	mov	r5,r18
81121d80:	8809883a 	mov	r4,r17
81121d84:	1121e7c0 	call	81121e7c <_malloc_r>
81121d88:	10002c26 	beq	r2,zero,81121e3c <__smakebuf_r+0x184>
81121d8c:	80c0030b 	ldhu	r3,12(r16)
81121d90:	012044f4 	movhi	r4,33043
81121d94:	212cff04 	addi	r4,r4,-19460
81121d98:	89000f15 	stw	r4,60(r17)
81121d9c:	18c02014 	ori	r3,r3,128
81121da0:	80c0030d 	sth	r3,12(r16)
81121da4:	80800015 	stw	r2,0(r16)
81121da8:	80800415 	stw	r2,16(r16)
81121dac:	84800515 	stw	r18,20(r16)
81121db0:	98001a1e 	bne	r19,zero,81121e1c <__smakebuf_r+0x164>
81121db4:	dfc01317 	ldw	ra,76(sp)
81121db8:	dcc01217 	ldw	r19,72(sp)
81121dbc:	dc801117 	ldw	r18,68(sp)
81121dc0:	dc401017 	ldw	r17,64(sp)
81121dc4:	dc000f17 	ldw	r16,60(sp)
81121dc8:	dec01404 	addi	sp,sp,80
81121dcc:	f800283a 	ret
81121dd0:	288010c4 	addi	r2,r5,67
81121dd4:	28800015 	stw	r2,0(r5)
81121dd8:	28800415 	stw	r2,16(r5)
81121ddc:	00800044 	movi	r2,1
81121de0:	28800515 	stw	r2,20(r5)
81121de4:	f800283a 	ret
81121de8:	04801004 	movi	r18,64
81121dec:	003fe006 	br	81121d70 <__reset+0xfb101d70>
81121df0:	81000a17 	ldw	r4,40(r16)
81121df4:	00e044b4 	movhi	r3,33042
81121df8:	18cc3304 	addi	r3,r3,12492
81121dfc:	20ffc51e 	bne	r4,r3,81121d14 <__reset+0xfb101d14>
81121e00:	8080030b 	ldhu	r2,12(r16)
81121e04:	04810004 	movi	r18,1024
81121e08:	84801315 	stw	r18,76(r16)
81121e0c:	1484b03a 	or	r2,r2,r18
81121e10:	8080030d 	sth	r2,12(r16)
81121e14:	0027883a 	mov	r19,zero
81121e18:	003fd806 	br	81121d7c <__reset+0xfb101d7c>
81121e1c:	8140038f 	ldh	r5,14(r16)
81121e20:	8809883a 	mov	r4,r17
81121e24:	112c5680 	call	8112c568 <_isatty_r>
81121e28:	103fe226 	beq	r2,zero,81121db4 <__reset+0xfb101db4>
81121e2c:	8080030b 	ldhu	r2,12(r16)
81121e30:	10800054 	ori	r2,r2,1
81121e34:	8080030d 	sth	r2,12(r16)
81121e38:	003fde06 	br	81121db4 <__reset+0xfb101db4>
81121e3c:	8080030b 	ldhu	r2,12(r16)
81121e40:	10c0800c 	andi	r3,r2,512
81121e44:	183fdb1e 	bne	r3,zero,81121db4 <__reset+0xfb101db4>
81121e48:	10800094 	ori	r2,r2,2
81121e4c:	80c010c4 	addi	r3,r16,67
81121e50:	8080030d 	sth	r2,12(r16)
81121e54:	00800044 	movi	r2,1
81121e58:	80c00015 	stw	r3,0(r16)
81121e5c:	80c00415 	stw	r3,16(r16)
81121e60:	80800515 	stw	r2,20(r16)
81121e64:	003fd306 	br	81121db4 <__reset+0xfb101db4>
81121e68:	04810004 	movi	r18,1024
81121e6c:	003fc306 	br	81121d7c <__reset+0xfb101d7c>
81121e70:	0027883a 	mov	r19,zero
81121e74:	04810004 	movi	r18,1024
81121e78:	003fc006 	br	81121d7c <__reset+0xfb101d7c>

81121e7c <_malloc_r>:
81121e7c:	defff504 	addi	sp,sp,-44
81121e80:	de00012e 	bgeu	sp,et,81121e88 <_malloc_r+0xc>
81121e84:	003b68fa 	trap	3
81121e88:	288002c4 	addi	r2,r5,11
81121e8c:	dc800315 	stw	r18,12(sp)
81121e90:	dfc00a15 	stw	ra,40(sp)
81121e94:	df000915 	stw	fp,36(sp)
81121e98:	ddc00815 	stw	r23,32(sp)
81121e9c:	dd800715 	stw	r22,28(sp)
81121ea0:	dd400615 	stw	r21,24(sp)
81121ea4:	dd000515 	stw	r20,20(sp)
81121ea8:	dcc00415 	stw	r19,16(sp)
81121eac:	dc400215 	stw	r17,8(sp)
81121eb0:	dc000115 	stw	r16,4(sp)
81121eb4:	00c00584 	movi	r3,22
81121eb8:	2025883a 	mov	r18,r4
81121ebc:	18807f2e 	bgeu	r3,r2,811220bc <_malloc_r+0x240>
81121ec0:	047ffe04 	movi	r17,-8
81121ec4:	1462703a 	and	r17,r2,r17
81121ec8:	8800a316 	blt	r17,zero,81122158 <_malloc_r+0x2dc>
81121ecc:	8940a236 	bltu	r17,r5,81122158 <_malloc_r+0x2dc>
81121ed0:	11380d40 	call	811380d4 <__malloc_lock>
81121ed4:	00807dc4 	movi	r2,503
81121ed8:	1441e92e 	bgeu	r2,r17,81122680 <_malloc_r+0x804>
81121edc:	8804d27a 	srli	r2,r17,9
81121ee0:	1000a126 	beq	r2,zero,81122168 <_malloc_r+0x2ec>
81121ee4:	00c00104 	movi	r3,4
81121ee8:	18811e36 	bltu	r3,r2,81122364 <_malloc_r+0x4e8>
81121eec:	8804d1ba 	srli	r2,r17,6
81121ef0:	12000e44 	addi	r8,r2,57
81121ef4:	11c00e04 	addi	r7,r2,56
81121ef8:	4209883a 	add	r4,r8,r8
81121efc:	04e04574 	movhi	r19,33045
81121f00:	2109883a 	add	r4,r4,r4
81121f04:	9cc6cd04 	addi	r19,r19,6964
81121f08:	2109883a 	add	r4,r4,r4
81121f0c:	9909883a 	add	r4,r19,r4
81121f10:	24000117 	ldw	r16,4(r4)
81121f14:	213ffe04 	addi	r4,r4,-8
81121f18:	24009726 	beq	r4,r16,81122178 <_malloc_r+0x2fc>
81121f1c:	80800117 	ldw	r2,4(r16)
81121f20:	01bfff04 	movi	r6,-4
81121f24:	014003c4 	movi	r5,15
81121f28:	1184703a 	and	r2,r2,r6
81121f2c:	1447c83a 	sub	r3,r2,r17
81121f30:	28c00716 	blt	r5,r3,81121f50 <_malloc_r+0xd4>
81121f34:	1800920e 	bge	r3,zero,81122180 <_malloc_r+0x304>
81121f38:	84000317 	ldw	r16,12(r16)
81121f3c:	24008e26 	beq	r4,r16,81122178 <_malloc_r+0x2fc>
81121f40:	80800117 	ldw	r2,4(r16)
81121f44:	1184703a 	and	r2,r2,r6
81121f48:	1447c83a 	sub	r3,r2,r17
81121f4c:	28fff90e 	bge	r5,r3,81121f34 <__reset+0xfb101f34>
81121f50:	3809883a 	mov	r4,r7
81121f54:	01a04574 	movhi	r6,33045
81121f58:	9c000417 	ldw	r16,16(r19)
81121f5c:	3186cd04 	addi	r6,r6,6964
81121f60:	32000204 	addi	r8,r6,8
81121f64:	82013426 	beq	r16,r8,81122438 <_malloc_r+0x5bc>
81121f68:	80c00117 	ldw	r3,4(r16)
81121f6c:	00bfff04 	movi	r2,-4
81121f70:	188e703a 	and	r7,r3,r2
81121f74:	3c45c83a 	sub	r2,r7,r17
81121f78:	00c003c4 	movi	r3,15
81121f7c:	18811f16 	blt	r3,r2,811223fc <_malloc_r+0x580>
81121f80:	32000515 	stw	r8,20(r6)
81121f84:	32000415 	stw	r8,16(r6)
81121f88:	10007f0e 	bge	r2,zero,81122188 <_malloc_r+0x30c>
81121f8c:	00807fc4 	movi	r2,511
81121f90:	11c0fd36 	bltu	r2,r7,81122388 <_malloc_r+0x50c>
81121f94:	3806d0fa 	srli	r3,r7,3
81121f98:	01c00044 	movi	r7,1
81121f9c:	30800117 	ldw	r2,4(r6)
81121fa0:	19400044 	addi	r5,r3,1
81121fa4:	294b883a 	add	r5,r5,r5
81121fa8:	1807d0ba 	srai	r3,r3,2
81121fac:	294b883a 	add	r5,r5,r5
81121fb0:	294b883a 	add	r5,r5,r5
81121fb4:	298b883a 	add	r5,r5,r6
81121fb8:	38c6983a 	sll	r3,r7,r3
81121fbc:	29c00017 	ldw	r7,0(r5)
81121fc0:	2a7ffe04 	addi	r9,r5,-8
81121fc4:	1886b03a 	or	r3,r3,r2
81121fc8:	82400315 	stw	r9,12(r16)
81121fcc:	81c00215 	stw	r7,8(r16)
81121fd0:	30c00115 	stw	r3,4(r6)
81121fd4:	2c000015 	stw	r16,0(r5)
81121fd8:	3c000315 	stw	r16,12(r7)
81121fdc:	2005d0ba 	srai	r2,r4,2
81121fe0:	01400044 	movi	r5,1
81121fe4:	288a983a 	sll	r5,r5,r2
81121fe8:	19406f36 	bltu	r3,r5,811221a8 <_malloc_r+0x32c>
81121fec:	28c4703a 	and	r2,r5,r3
81121ff0:	10000a1e 	bne	r2,zero,8112201c <_malloc_r+0x1a0>
81121ff4:	00bfff04 	movi	r2,-4
81121ff8:	294b883a 	add	r5,r5,r5
81121ffc:	2088703a 	and	r4,r4,r2
81122000:	28c4703a 	and	r2,r5,r3
81122004:	21000104 	addi	r4,r4,4
81122008:	1000041e 	bne	r2,zero,8112201c <_malloc_r+0x1a0>
8112200c:	294b883a 	add	r5,r5,r5
81122010:	28c4703a 	and	r2,r5,r3
81122014:	21000104 	addi	r4,r4,4
81122018:	103ffc26 	beq	r2,zero,8112200c <__reset+0xfb10200c>
8112201c:	02bfff04 	movi	r10,-4
81122020:	024003c4 	movi	r9,15
81122024:	21800044 	addi	r6,r4,1
81122028:	318d883a 	add	r6,r6,r6
8112202c:	318d883a 	add	r6,r6,r6
81122030:	318d883a 	add	r6,r6,r6
81122034:	998d883a 	add	r6,r19,r6
81122038:	333ffe04 	addi	r12,r6,-8
8112203c:	2017883a 	mov	r11,r4
81122040:	31800104 	addi	r6,r6,4
81122044:	34000017 	ldw	r16,0(r6)
81122048:	31fffd04 	addi	r7,r6,-12
8112204c:	81c0041e 	bne	r16,r7,81122060 <_malloc_r+0x1e4>
81122050:	0000fb06 	br	81122440 <_malloc_r+0x5c4>
81122054:	1801030e 	bge	r3,zero,81122464 <_malloc_r+0x5e8>
81122058:	84000317 	ldw	r16,12(r16)
8112205c:	81c0f826 	beq	r16,r7,81122440 <_malloc_r+0x5c4>
81122060:	80800117 	ldw	r2,4(r16)
81122064:	1284703a 	and	r2,r2,r10
81122068:	1447c83a 	sub	r3,r2,r17
8112206c:	48fff90e 	bge	r9,r3,81122054 <__reset+0xfb102054>
81122070:	80800317 	ldw	r2,12(r16)
81122074:	81000217 	ldw	r4,8(r16)
81122078:	89400054 	ori	r5,r17,1
8112207c:	81400115 	stw	r5,4(r16)
81122080:	20800315 	stw	r2,12(r4)
81122084:	11000215 	stw	r4,8(r2)
81122088:	8463883a 	add	r17,r16,r17
8112208c:	9c400515 	stw	r17,20(r19)
81122090:	9c400415 	stw	r17,16(r19)
81122094:	18800054 	ori	r2,r3,1
81122098:	88800115 	stw	r2,4(r17)
8112209c:	8a000315 	stw	r8,12(r17)
811220a0:	8a000215 	stw	r8,8(r17)
811220a4:	88e3883a 	add	r17,r17,r3
811220a8:	88c00015 	stw	r3,0(r17)
811220ac:	9009883a 	mov	r4,r18
811220b0:	11381fc0 	call	811381fc <__malloc_unlock>
811220b4:	80800204 	addi	r2,r16,8
811220b8:	00001b06 	br	81122128 <_malloc_r+0x2ac>
811220bc:	04400404 	movi	r17,16
811220c0:	89402536 	bltu	r17,r5,81122158 <_malloc_r+0x2dc>
811220c4:	11380d40 	call	811380d4 <__malloc_lock>
811220c8:	00800184 	movi	r2,6
811220cc:	01000084 	movi	r4,2
811220d0:	04e04574 	movhi	r19,33045
811220d4:	1085883a 	add	r2,r2,r2
811220d8:	9cc6cd04 	addi	r19,r19,6964
811220dc:	1085883a 	add	r2,r2,r2
811220e0:	9885883a 	add	r2,r19,r2
811220e4:	14000117 	ldw	r16,4(r2)
811220e8:	10fffe04 	addi	r3,r2,-8
811220ec:	80c0d926 	beq	r16,r3,81122454 <_malloc_r+0x5d8>
811220f0:	80c00117 	ldw	r3,4(r16)
811220f4:	81000317 	ldw	r4,12(r16)
811220f8:	00bfff04 	movi	r2,-4
811220fc:	1884703a 	and	r2,r3,r2
81122100:	81400217 	ldw	r5,8(r16)
81122104:	8085883a 	add	r2,r16,r2
81122108:	10c00117 	ldw	r3,4(r2)
8112210c:	29000315 	stw	r4,12(r5)
81122110:	21400215 	stw	r5,8(r4)
81122114:	18c00054 	ori	r3,r3,1
81122118:	10c00115 	stw	r3,4(r2)
8112211c:	9009883a 	mov	r4,r18
81122120:	11381fc0 	call	811381fc <__malloc_unlock>
81122124:	80800204 	addi	r2,r16,8
81122128:	dfc00a17 	ldw	ra,40(sp)
8112212c:	df000917 	ldw	fp,36(sp)
81122130:	ddc00817 	ldw	r23,32(sp)
81122134:	dd800717 	ldw	r22,28(sp)
81122138:	dd400617 	ldw	r21,24(sp)
8112213c:	dd000517 	ldw	r20,20(sp)
81122140:	dcc00417 	ldw	r19,16(sp)
81122144:	dc800317 	ldw	r18,12(sp)
81122148:	dc400217 	ldw	r17,8(sp)
8112214c:	dc000117 	ldw	r16,4(sp)
81122150:	dec00b04 	addi	sp,sp,44
81122154:	f800283a 	ret
81122158:	00800304 	movi	r2,12
8112215c:	90800015 	stw	r2,0(r18)
81122160:	0005883a 	mov	r2,zero
81122164:	003ff006 	br	81122128 <__reset+0xfb102128>
81122168:	01002004 	movi	r4,128
8112216c:	02001004 	movi	r8,64
81122170:	01c00fc4 	movi	r7,63
81122174:	003f6106 	br	81121efc <__reset+0xfb101efc>
81122178:	4009883a 	mov	r4,r8
8112217c:	003f7506 	br	81121f54 <__reset+0xfb101f54>
81122180:	81000317 	ldw	r4,12(r16)
81122184:	003fde06 	br	81122100 <__reset+0xfb102100>
81122188:	81c5883a 	add	r2,r16,r7
8112218c:	11400117 	ldw	r5,4(r2)
81122190:	9009883a 	mov	r4,r18
81122194:	29400054 	ori	r5,r5,1
81122198:	11400115 	stw	r5,4(r2)
8112219c:	11381fc0 	call	811381fc <__malloc_unlock>
811221a0:	80800204 	addi	r2,r16,8
811221a4:	003fe006 	br	81122128 <__reset+0xfb102128>
811221a8:	9c000217 	ldw	r16,8(r19)
811221ac:	00bfff04 	movi	r2,-4
811221b0:	85800117 	ldw	r22,4(r16)
811221b4:	b0ac703a 	and	r22,r22,r2
811221b8:	b4400336 	bltu	r22,r17,811221c8 <_malloc_r+0x34c>
811221bc:	b445c83a 	sub	r2,r22,r17
811221c0:	00c003c4 	movi	r3,15
811221c4:	18805d16 	blt	r3,r2,8112233c <_malloc_r+0x4c0>
811221c8:	05e04574 	movhi	r23,33045
811221cc:	00a04574 	movhi	r2,33045
811221d0:	108d8504 	addi	r2,r2,13844
811221d4:	bdcd1004 	addi	r23,r23,13376
811221d8:	15400017 	ldw	r21,0(r2)
811221dc:	b8c00017 	ldw	r3,0(r23)
811221e0:	00bfffc4 	movi	r2,-1
811221e4:	858d883a 	add	r6,r16,r22
811221e8:	8d6b883a 	add	r21,r17,r21
811221ec:	1880ea26 	beq	r3,r2,81122598 <_malloc_r+0x71c>
811221f0:	ad4403c4 	addi	r21,r21,4111
811221f4:	00bc0004 	movi	r2,-4096
811221f8:	a8aa703a 	and	r21,r21,r2
811221fc:	a80b883a 	mov	r5,r21
81122200:	9009883a 	mov	r4,r18
81122204:	d9800015 	stw	r6,0(sp)
81122208:	1122e380 	call	81122e38 <_sbrk_r>
8112220c:	1029883a 	mov	r20,r2
81122210:	00bfffc4 	movi	r2,-1
81122214:	d9800017 	ldw	r6,0(sp)
81122218:	a080e826 	beq	r20,r2,811225bc <_malloc_r+0x740>
8112221c:	a180a636 	bltu	r20,r6,811224b8 <_malloc_r+0x63c>
81122220:	07204574 	movhi	fp,33045
81122224:	e70e1204 	addi	fp,fp,14408
81122228:	e0800017 	ldw	r2,0(fp)
8112222c:	a887883a 	add	r3,r21,r2
81122230:	e0c00015 	stw	r3,0(fp)
81122234:	3500e626 	beq	r6,r20,811225d0 <_malloc_r+0x754>
81122238:	b9000017 	ldw	r4,0(r23)
8112223c:	00bfffc4 	movi	r2,-1
81122240:	2080ee26 	beq	r4,r2,811225fc <_malloc_r+0x780>
81122244:	a185c83a 	sub	r2,r20,r6
81122248:	10c5883a 	add	r2,r2,r3
8112224c:	e0800015 	stw	r2,0(fp)
81122250:	a0c001cc 	andi	r3,r20,7
81122254:	1800bc26 	beq	r3,zero,81122548 <_malloc_r+0x6cc>
81122258:	a0e9c83a 	sub	r20,r20,r3
8112225c:	00840204 	movi	r2,4104
81122260:	a5000204 	addi	r20,r20,8
81122264:	10c7c83a 	sub	r3,r2,r3
81122268:	a545883a 	add	r2,r20,r21
8112226c:	1083ffcc 	andi	r2,r2,4095
81122270:	18abc83a 	sub	r21,r3,r2
81122274:	a80b883a 	mov	r5,r21
81122278:	9009883a 	mov	r4,r18
8112227c:	1122e380 	call	81122e38 <_sbrk_r>
81122280:	00ffffc4 	movi	r3,-1
81122284:	10c0e126 	beq	r2,r3,8112260c <_malloc_r+0x790>
81122288:	1505c83a 	sub	r2,r2,r20
8112228c:	1545883a 	add	r2,r2,r21
81122290:	10800054 	ori	r2,r2,1
81122294:	e0c00017 	ldw	r3,0(fp)
81122298:	9d000215 	stw	r20,8(r19)
8112229c:	a0800115 	stw	r2,4(r20)
811222a0:	a8c7883a 	add	r3,r21,r3
811222a4:	e0c00015 	stw	r3,0(fp)
811222a8:	84c00e26 	beq	r16,r19,811222e4 <_malloc_r+0x468>
811222ac:	018003c4 	movi	r6,15
811222b0:	3580a72e 	bgeu	r6,r22,81122550 <_malloc_r+0x6d4>
811222b4:	81400117 	ldw	r5,4(r16)
811222b8:	013ffe04 	movi	r4,-8
811222bc:	b0bffd04 	addi	r2,r22,-12
811222c0:	1104703a 	and	r2,r2,r4
811222c4:	2900004c 	andi	r4,r5,1
811222c8:	2088b03a 	or	r4,r4,r2
811222cc:	81000115 	stw	r4,4(r16)
811222d0:	01400144 	movi	r5,5
811222d4:	8089883a 	add	r4,r16,r2
811222d8:	21400115 	stw	r5,4(r4)
811222dc:	21400215 	stw	r5,8(r4)
811222e0:	3080cd36 	bltu	r6,r2,81122618 <_malloc_r+0x79c>
811222e4:	00a04574 	movhi	r2,33045
811222e8:	108d8404 	addi	r2,r2,13840
811222ec:	11000017 	ldw	r4,0(r2)
811222f0:	20c0012e 	bgeu	r4,r3,811222f8 <_malloc_r+0x47c>
811222f4:	10c00015 	stw	r3,0(r2)
811222f8:	00a04574 	movhi	r2,33045
811222fc:	108d8304 	addi	r2,r2,13836
81122300:	11000017 	ldw	r4,0(r2)
81122304:	9c000217 	ldw	r16,8(r19)
81122308:	20c0012e 	bgeu	r4,r3,81122310 <_malloc_r+0x494>
8112230c:	10c00015 	stw	r3,0(r2)
81122310:	80c00117 	ldw	r3,4(r16)
81122314:	00bfff04 	movi	r2,-4
81122318:	1886703a 	and	r3,r3,r2
8112231c:	1c45c83a 	sub	r2,r3,r17
81122320:	1c400236 	bltu	r3,r17,8112232c <_malloc_r+0x4b0>
81122324:	00c003c4 	movi	r3,15
81122328:	18800416 	blt	r3,r2,8112233c <_malloc_r+0x4c0>
8112232c:	9009883a 	mov	r4,r18
81122330:	11381fc0 	call	811381fc <__malloc_unlock>
81122334:	0005883a 	mov	r2,zero
81122338:	003f7b06 	br	81122128 <__reset+0xfb102128>
8112233c:	88c00054 	ori	r3,r17,1
81122340:	80c00115 	stw	r3,4(r16)
81122344:	8463883a 	add	r17,r16,r17
81122348:	10800054 	ori	r2,r2,1
8112234c:	9c400215 	stw	r17,8(r19)
81122350:	88800115 	stw	r2,4(r17)
81122354:	9009883a 	mov	r4,r18
81122358:	11381fc0 	call	811381fc <__malloc_unlock>
8112235c:	80800204 	addi	r2,r16,8
81122360:	003f7106 	br	81122128 <__reset+0xfb102128>
81122364:	00c00504 	movi	r3,20
81122368:	18804a2e 	bgeu	r3,r2,81122494 <_malloc_r+0x618>
8112236c:	00c01504 	movi	r3,84
81122370:	18806e36 	bltu	r3,r2,8112252c <_malloc_r+0x6b0>
81122374:	8804d33a 	srli	r2,r17,12
81122378:	12001bc4 	addi	r8,r2,111
8112237c:	11c01b84 	addi	r7,r2,110
81122380:	4209883a 	add	r4,r8,r8
81122384:	003edd06 	br	81121efc <__reset+0xfb101efc>
81122388:	3804d27a 	srli	r2,r7,9
8112238c:	00c00104 	movi	r3,4
81122390:	1880442e 	bgeu	r3,r2,811224a4 <_malloc_r+0x628>
81122394:	00c00504 	movi	r3,20
81122398:	18808136 	bltu	r3,r2,811225a0 <_malloc_r+0x724>
8112239c:	11401704 	addi	r5,r2,92
811223a0:	10c016c4 	addi	r3,r2,91
811223a4:	294b883a 	add	r5,r5,r5
811223a8:	294b883a 	add	r5,r5,r5
811223ac:	294b883a 	add	r5,r5,r5
811223b0:	994b883a 	add	r5,r19,r5
811223b4:	28800017 	ldw	r2,0(r5)
811223b8:	01a04574 	movhi	r6,33045
811223bc:	297ffe04 	addi	r5,r5,-8
811223c0:	3186cd04 	addi	r6,r6,6964
811223c4:	28806526 	beq	r5,r2,8112255c <_malloc_r+0x6e0>
811223c8:	01bfff04 	movi	r6,-4
811223cc:	10c00117 	ldw	r3,4(r2)
811223d0:	1986703a 	and	r3,r3,r6
811223d4:	38c0022e 	bgeu	r7,r3,811223e0 <_malloc_r+0x564>
811223d8:	10800217 	ldw	r2,8(r2)
811223dc:	28bffb1e 	bne	r5,r2,811223cc <__reset+0xfb1023cc>
811223e0:	11400317 	ldw	r5,12(r2)
811223e4:	98c00117 	ldw	r3,4(r19)
811223e8:	81400315 	stw	r5,12(r16)
811223ec:	80800215 	stw	r2,8(r16)
811223f0:	2c000215 	stw	r16,8(r5)
811223f4:	14000315 	stw	r16,12(r2)
811223f8:	003ef806 	br	81121fdc <__reset+0xfb101fdc>
811223fc:	88c00054 	ori	r3,r17,1
81122400:	80c00115 	stw	r3,4(r16)
81122404:	8463883a 	add	r17,r16,r17
81122408:	34400515 	stw	r17,20(r6)
8112240c:	34400415 	stw	r17,16(r6)
81122410:	10c00054 	ori	r3,r2,1
81122414:	8a000315 	stw	r8,12(r17)
81122418:	8a000215 	stw	r8,8(r17)
8112241c:	88c00115 	stw	r3,4(r17)
81122420:	88a3883a 	add	r17,r17,r2
81122424:	88800015 	stw	r2,0(r17)
81122428:	9009883a 	mov	r4,r18
8112242c:	11381fc0 	call	811381fc <__malloc_unlock>
81122430:	80800204 	addi	r2,r16,8
81122434:	003f3c06 	br	81122128 <__reset+0xfb102128>
81122438:	30c00117 	ldw	r3,4(r6)
8112243c:	003ee706 	br	81121fdc <__reset+0xfb101fdc>
81122440:	5ac00044 	addi	r11,r11,1
81122444:	588000cc 	andi	r2,r11,3
81122448:	31800204 	addi	r6,r6,8
8112244c:	103efd1e 	bne	r2,zero,81122044 <__reset+0xfb102044>
81122450:	00002406 	br	811224e4 <_malloc_r+0x668>
81122454:	14000317 	ldw	r16,12(r2)
81122458:	143f251e 	bne	r2,r16,811220f0 <__reset+0xfb1020f0>
8112245c:	21000084 	addi	r4,r4,2
81122460:	003ebc06 	br	81121f54 <__reset+0xfb101f54>
81122464:	8085883a 	add	r2,r16,r2
81122468:	10c00117 	ldw	r3,4(r2)
8112246c:	81000317 	ldw	r4,12(r16)
81122470:	81400217 	ldw	r5,8(r16)
81122474:	18c00054 	ori	r3,r3,1
81122478:	10c00115 	stw	r3,4(r2)
8112247c:	29000315 	stw	r4,12(r5)
81122480:	21400215 	stw	r5,8(r4)
81122484:	9009883a 	mov	r4,r18
81122488:	11381fc0 	call	811381fc <__malloc_unlock>
8112248c:	80800204 	addi	r2,r16,8
81122490:	003f2506 	br	81122128 <__reset+0xfb102128>
81122494:	12001704 	addi	r8,r2,92
81122498:	11c016c4 	addi	r7,r2,91
8112249c:	4209883a 	add	r4,r8,r8
811224a0:	003e9606 	br	81121efc <__reset+0xfb101efc>
811224a4:	3804d1ba 	srli	r2,r7,6
811224a8:	11400e44 	addi	r5,r2,57
811224ac:	10c00e04 	addi	r3,r2,56
811224b0:	294b883a 	add	r5,r5,r5
811224b4:	003fbc06 	br	811223a8 <__reset+0xfb1023a8>
811224b8:	84ff5926 	beq	r16,r19,81122220 <__reset+0xfb102220>
811224bc:	00a04574 	movhi	r2,33045
811224c0:	1086cd04 	addi	r2,r2,6964
811224c4:	14000217 	ldw	r16,8(r2)
811224c8:	00bfff04 	movi	r2,-4
811224cc:	80c00117 	ldw	r3,4(r16)
811224d0:	1886703a 	and	r3,r3,r2
811224d4:	003f9106 	br	8112231c <__reset+0xfb10231c>
811224d8:	60800217 	ldw	r2,8(r12)
811224dc:	213fffc4 	addi	r4,r4,-1
811224e0:	1300651e 	bne	r2,r12,81122678 <_malloc_r+0x7fc>
811224e4:	208000cc 	andi	r2,r4,3
811224e8:	633ffe04 	addi	r12,r12,-8
811224ec:	103ffa1e 	bne	r2,zero,811224d8 <__reset+0xfb1024d8>
811224f0:	98800117 	ldw	r2,4(r19)
811224f4:	0146303a 	nor	r3,zero,r5
811224f8:	1884703a 	and	r2,r3,r2
811224fc:	98800115 	stw	r2,4(r19)
81122500:	294b883a 	add	r5,r5,r5
81122504:	117f2836 	bltu	r2,r5,811221a8 <__reset+0xfb1021a8>
81122508:	283f2726 	beq	r5,zero,811221a8 <__reset+0xfb1021a8>
8112250c:	2886703a 	and	r3,r5,r2
81122510:	5809883a 	mov	r4,r11
81122514:	183ec31e 	bne	r3,zero,81122024 <__reset+0xfb102024>
81122518:	294b883a 	add	r5,r5,r5
8112251c:	2886703a 	and	r3,r5,r2
81122520:	21000104 	addi	r4,r4,4
81122524:	183ffc26 	beq	r3,zero,81122518 <__reset+0xfb102518>
81122528:	003ebe06 	br	81122024 <__reset+0xfb102024>
8112252c:	00c05504 	movi	r3,340
81122530:	18801236 	bltu	r3,r2,8112257c <_malloc_r+0x700>
81122534:	8804d3fa 	srli	r2,r17,15
81122538:	12001e04 	addi	r8,r2,120
8112253c:	11c01dc4 	addi	r7,r2,119
81122540:	4209883a 	add	r4,r8,r8
81122544:	003e6d06 	br	81121efc <__reset+0xfb101efc>
81122548:	00c40004 	movi	r3,4096
8112254c:	003f4606 	br	81122268 <__reset+0xfb102268>
81122550:	00800044 	movi	r2,1
81122554:	a0800115 	stw	r2,4(r20)
81122558:	003f7406 	br	8112232c <__reset+0xfb10232c>
8112255c:	1805d0ba 	srai	r2,r3,2
81122560:	01c00044 	movi	r7,1
81122564:	30c00117 	ldw	r3,4(r6)
81122568:	388e983a 	sll	r7,r7,r2
8112256c:	2805883a 	mov	r2,r5
81122570:	38c6b03a 	or	r3,r7,r3
81122574:	30c00115 	stw	r3,4(r6)
81122578:	003f9b06 	br	811223e8 <__reset+0xfb1023e8>
8112257c:	00c15504 	movi	r3,1364
81122580:	18801a36 	bltu	r3,r2,811225ec <_malloc_r+0x770>
81122584:	8804d4ba 	srli	r2,r17,18
81122588:	12001f44 	addi	r8,r2,125
8112258c:	11c01f04 	addi	r7,r2,124
81122590:	4209883a 	add	r4,r8,r8
81122594:	003e5906 	br	81121efc <__reset+0xfb101efc>
81122598:	ad400404 	addi	r21,r21,16
8112259c:	003f1706 	br	811221fc <__reset+0xfb1021fc>
811225a0:	00c01504 	movi	r3,84
811225a4:	18802336 	bltu	r3,r2,81122634 <_malloc_r+0x7b8>
811225a8:	3804d33a 	srli	r2,r7,12
811225ac:	11401bc4 	addi	r5,r2,111
811225b0:	10c01b84 	addi	r3,r2,110
811225b4:	294b883a 	add	r5,r5,r5
811225b8:	003f7b06 	br	811223a8 <__reset+0xfb1023a8>
811225bc:	9c000217 	ldw	r16,8(r19)
811225c0:	00bfff04 	movi	r2,-4
811225c4:	80c00117 	ldw	r3,4(r16)
811225c8:	1886703a 	and	r3,r3,r2
811225cc:	003f5306 	br	8112231c <__reset+0xfb10231c>
811225d0:	3083ffcc 	andi	r2,r6,4095
811225d4:	103f181e 	bne	r2,zero,81122238 <__reset+0xfb102238>
811225d8:	99000217 	ldw	r4,8(r19)
811225dc:	b545883a 	add	r2,r22,r21
811225e0:	10800054 	ori	r2,r2,1
811225e4:	20800115 	stw	r2,4(r4)
811225e8:	003f3e06 	br	811222e4 <__reset+0xfb1022e4>
811225ec:	01003f84 	movi	r4,254
811225f0:	02001fc4 	movi	r8,127
811225f4:	01c01f84 	movi	r7,126
811225f8:	003e4006 	br	81121efc <__reset+0xfb101efc>
811225fc:	00a04574 	movhi	r2,33045
81122600:	108d1004 	addi	r2,r2,13376
81122604:	15000015 	stw	r20,0(r2)
81122608:	003f1106 	br	81122250 <__reset+0xfb102250>
8112260c:	00800044 	movi	r2,1
81122610:	002b883a 	mov	r21,zero
81122614:	003f1f06 	br	81122294 <__reset+0xfb102294>
81122618:	81400204 	addi	r5,r16,8
8112261c:	9009883a 	mov	r4,r18
81122620:	112bbf40 	call	8112bbf4 <_free_r>
81122624:	00a04574 	movhi	r2,33045
81122628:	108e1204 	addi	r2,r2,14408
8112262c:	10c00017 	ldw	r3,0(r2)
81122630:	003f2c06 	br	811222e4 <__reset+0xfb1022e4>
81122634:	00c05504 	movi	r3,340
81122638:	18800536 	bltu	r3,r2,81122650 <_malloc_r+0x7d4>
8112263c:	3804d3fa 	srli	r2,r7,15
81122640:	11401e04 	addi	r5,r2,120
81122644:	10c01dc4 	addi	r3,r2,119
81122648:	294b883a 	add	r5,r5,r5
8112264c:	003f5606 	br	811223a8 <__reset+0xfb1023a8>
81122650:	00c15504 	movi	r3,1364
81122654:	18800536 	bltu	r3,r2,8112266c <_malloc_r+0x7f0>
81122658:	3804d4ba 	srli	r2,r7,18
8112265c:	11401f44 	addi	r5,r2,125
81122660:	10c01f04 	addi	r3,r2,124
81122664:	294b883a 	add	r5,r5,r5
81122668:	003f4f06 	br	811223a8 <__reset+0xfb1023a8>
8112266c:	01403f84 	movi	r5,254
81122670:	00c01f84 	movi	r3,126
81122674:	003f4c06 	br	811223a8 <__reset+0xfb1023a8>
81122678:	98800117 	ldw	r2,4(r19)
8112267c:	003fa006 	br	81122500 <__reset+0xfb102500>
81122680:	8808d0fa 	srli	r4,r17,3
81122684:	20800044 	addi	r2,r4,1
81122688:	1085883a 	add	r2,r2,r2
8112268c:	003e9006 	br	811220d0 <__reset+0xfb1020d0>

81122690 <memcpy>:
81122690:	defffd04 	addi	sp,sp,-12
81122694:	de00012e 	bgeu	sp,et,8112269c <memcpy+0xc>
81122698:	003b68fa 	trap	3
8112269c:	00c003c4 	movi	r3,15
811226a0:	dfc00215 	stw	ra,8(sp)
811226a4:	dc400115 	stw	r17,4(sp)
811226a8:	dc000015 	stw	r16,0(sp)
811226ac:	2005883a 	mov	r2,r4
811226b0:	1980452e 	bgeu	r3,r6,811227c8 <memcpy+0x138>
811226b4:	2906b03a 	or	r3,r5,r4
811226b8:	18c000cc 	andi	r3,r3,3
811226bc:	1800441e 	bne	r3,zero,811227d0 <memcpy+0x140>
811226c0:	347ffc04 	addi	r17,r6,-16
811226c4:	8822d13a 	srli	r17,r17,4
811226c8:	28c00104 	addi	r3,r5,4
811226cc:	23400104 	addi	r13,r4,4
811226d0:	8820913a 	slli	r16,r17,4
811226d4:	2b000204 	addi	r12,r5,8
811226d8:	22c00204 	addi	r11,r4,8
811226dc:	84000504 	addi	r16,r16,20
811226e0:	2a800304 	addi	r10,r5,12
811226e4:	22400304 	addi	r9,r4,12
811226e8:	2c21883a 	add	r16,r5,r16
811226ec:	2811883a 	mov	r8,r5
811226f0:	200f883a 	mov	r7,r4
811226f4:	41000017 	ldw	r4,0(r8)
811226f8:	1fc00017 	ldw	ra,0(r3)
811226fc:	63c00017 	ldw	r15,0(r12)
81122700:	39000015 	stw	r4,0(r7)
81122704:	53800017 	ldw	r14,0(r10)
81122708:	6fc00015 	stw	ra,0(r13)
8112270c:	5bc00015 	stw	r15,0(r11)
81122710:	4b800015 	stw	r14,0(r9)
81122714:	18c00404 	addi	r3,r3,16
81122718:	39c00404 	addi	r7,r7,16
8112271c:	42000404 	addi	r8,r8,16
81122720:	6b400404 	addi	r13,r13,16
81122724:	63000404 	addi	r12,r12,16
81122728:	5ac00404 	addi	r11,r11,16
8112272c:	52800404 	addi	r10,r10,16
81122730:	4a400404 	addi	r9,r9,16
81122734:	1c3fef1e 	bne	r3,r16,811226f4 <__reset+0xfb1026f4>
81122738:	89c00044 	addi	r7,r17,1
8112273c:	380e913a 	slli	r7,r7,4
81122740:	310003cc 	andi	r4,r6,15
81122744:	02c000c4 	movi	r11,3
81122748:	11c7883a 	add	r3,r2,r7
8112274c:	29cb883a 	add	r5,r5,r7
81122750:	5900212e 	bgeu	r11,r4,811227d8 <memcpy+0x148>
81122754:	1813883a 	mov	r9,r3
81122758:	2811883a 	mov	r8,r5
8112275c:	200f883a 	mov	r7,r4
81122760:	42800017 	ldw	r10,0(r8)
81122764:	4a400104 	addi	r9,r9,4
81122768:	39ffff04 	addi	r7,r7,-4
8112276c:	4abfff15 	stw	r10,-4(r9)
81122770:	42000104 	addi	r8,r8,4
81122774:	59fffa36 	bltu	r11,r7,81122760 <__reset+0xfb102760>
81122778:	213fff04 	addi	r4,r4,-4
8112277c:	2008d0ba 	srli	r4,r4,2
81122780:	318000cc 	andi	r6,r6,3
81122784:	21000044 	addi	r4,r4,1
81122788:	2109883a 	add	r4,r4,r4
8112278c:	2109883a 	add	r4,r4,r4
81122790:	1907883a 	add	r3,r3,r4
81122794:	290b883a 	add	r5,r5,r4
81122798:	30000626 	beq	r6,zero,811227b4 <memcpy+0x124>
8112279c:	198d883a 	add	r6,r3,r6
811227a0:	29c00003 	ldbu	r7,0(r5)
811227a4:	18c00044 	addi	r3,r3,1
811227a8:	29400044 	addi	r5,r5,1
811227ac:	19ffffc5 	stb	r7,-1(r3)
811227b0:	19bffb1e 	bne	r3,r6,811227a0 <__reset+0xfb1027a0>
811227b4:	dfc00217 	ldw	ra,8(sp)
811227b8:	dc400117 	ldw	r17,4(sp)
811227bc:	dc000017 	ldw	r16,0(sp)
811227c0:	dec00304 	addi	sp,sp,12
811227c4:	f800283a 	ret
811227c8:	2007883a 	mov	r3,r4
811227cc:	003ff206 	br	81122798 <__reset+0xfb102798>
811227d0:	2007883a 	mov	r3,r4
811227d4:	003ff106 	br	8112279c <__reset+0xfb10279c>
811227d8:	200d883a 	mov	r6,r4
811227dc:	003fee06 	br	81122798 <__reset+0xfb102798>

811227e0 <memset>:
811227e0:	20c000cc 	andi	r3,r4,3
811227e4:	2005883a 	mov	r2,r4
811227e8:	18004426 	beq	r3,zero,811228fc <memset+0x11c>
811227ec:	31ffffc4 	addi	r7,r6,-1
811227f0:	30004026 	beq	r6,zero,811228f4 <memset+0x114>
811227f4:	2813883a 	mov	r9,r5
811227f8:	200d883a 	mov	r6,r4
811227fc:	2007883a 	mov	r3,r4
81122800:	00000406 	br	81122814 <memset+0x34>
81122804:	3a3fffc4 	addi	r8,r7,-1
81122808:	31800044 	addi	r6,r6,1
8112280c:	38003926 	beq	r7,zero,811228f4 <memset+0x114>
81122810:	400f883a 	mov	r7,r8
81122814:	18c00044 	addi	r3,r3,1
81122818:	32400005 	stb	r9,0(r6)
8112281c:	1a0000cc 	andi	r8,r3,3
81122820:	403ff81e 	bne	r8,zero,81122804 <__reset+0xfb102804>
81122824:	010000c4 	movi	r4,3
81122828:	21c02d2e 	bgeu	r4,r7,811228e0 <memset+0x100>
8112282c:	29003fcc 	andi	r4,r5,255
81122830:	200c923a 	slli	r6,r4,8
81122834:	3108b03a 	or	r4,r6,r4
81122838:	200c943a 	slli	r6,r4,16
8112283c:	218cb03a 	or	r6,r4,r6
81122840:	010003c4 	movi	r4,15
81122844:	21c0182e 	bgeu	r4,r7,811228a8 <memset+0xc8>
81122848:	3b3ffc04 	addi	r12,r7,-16
8112284c:	6018d13a 	srli	r12,r12,4
81122850:	1a000104 	addi	r8,r3,4
81122854:	1ac00204 	addi	r11,r3,8
81122858:	6008913a 	slli	r4,r12,4
8112285c:	1a800304 	addi	r10,r3,12
81122860:	1813883a 	mov	r9,r3
81122864:	21000504 	addi	r4,r4,20
81122868:	1909883a 	add	r4,r3,r4
8112286c:	49800015 	stw	r6,0(r9)
81122870:	41800015 	stw	r6,0(r8)
81122874:	59800015 	stw	r6,0(r11)
81122878:	51800015 	stw	r6,0(r10)
8112287c:	42000404 	addi	r8,r8,16
81122880:	4a400404 	addi	r9,r9,16
81122884:	5ac00404 	addi	r11,r11,16
81122888:	52800404 	addi	r10,r10,16
8112288c:	413ff71e 	bne	r8,r4,8112286c <__reset+0xfb10286c>
81122890:	63000044 	addi	r12,r12,1
81122894:	6018913a 	slli	r12,r12,4
81122898:	39c003cc 	andi	r7,r7,15
8112289c:	010000c4 	movi	r4,3
811228a0:	1b07883a 	add	r3,r3,r12
811228a4:	21c00e2e 	bgeu	r4,r7,811228e0 <memset+0x100>
811228a8:	1813883a 	mov	r9,r3
811228ac:	3811883a 	mov	r8,r7
811228b0:	010000c4 	movi	r4,3
811228b4:	49800015 	stw	r6,0(r9)
811228b8:	423fff04 	addi	r8,r8,-4
811228bc:	4a400104 	addi	r9,r9,4
811228c0:	223ffc36 	bltu	r4,r8,811228b4 <__reset+0xfb1028b4>
811228c4:	393fff04 	addi	r4,r7,-4
811228c8:	2008d0ba 	srli	r4,r4,2
811228cc:	39c000cc 	andi	r7,r7,3
811228d0:	21000044 	addi	r4,r4,1
811228d4:	2109883a 	add	r4,r4,r4
811228d8:	2109883a 	add	r4,r4,r4
811228dc:	1907883a 	add	r3,r3,r4
811228e0:	38000526 	beq	r7,zero,811228f8 <memset+0x118>
811228e4:	19cf883a 	add	r7,r3,r7
811228e8:	19400005 	stb	r5,0(r3)
811228ec:	18c00044 	addi	r3,r3,1
811228f0:	38fffd1e 	bne	r7,r3,811228e8 <__reset+0xfb1028e8>
811228f4:	f800283a 	ret
811228f8:	f800283a 	ret
811228fc:	2007883a 	mov	r3,r4
81122900:	300f883a 	mov	r7,r6
81122904:	003fc706 	br	81122824 <__reset+0xfb102824>

81122908 <_open_r>:
81122908:	defffd04 	addi	sp,sp,-12
8112290c:	de00012e 	bgeu	sp,et,81122914 <_open_r+0xc>
81122910:	003b68fa 	trap	3
81122914:	2805883a 	mov	r2,r5
81122918:	dc000015 	stw	r16,0(sp)
8112291c:	04204574 	movhi	r16,33045
81122920:	dc400115 	stw	r17,4(sp)
81122924:	300b883a 	mov	r5,r6
81122928:	840d8204 	addi	r16,r16,13832
8112292c:	2023883a 	mov	r17,r4
81122930:	380d883a 	mov	r6,r7
81122934:	1009883a 	mov	r4,r2
81122938:	dfc00215 	stw	ra,8(sp)
8112293c:	80000015 	stw	zero,0(r16)
81122940:	11377540 	call	81137754 <open>
81122944:	00ffffc4 	movi	r3,-1
81122948:	10c00526 	beq	r2,r3,81122960 <_open_r+0x58>
8112294c:	dfc00217 	ldw	ra,8(sp)
81122950:	dc400117 	ldw	r17,4(sp)
81122954:	dc000017 	ldw	r16,0(sp)
81122958:	dec00304 	addi	sp,sp,12
8112295c:	f800283a 	ret
81122960:	80c00017 	ldw	r3,0(r16)
81122964:	183ff926 	beq	r3,zero,8112294c <__reset+0xfb10294c>
81122968:	88c00015 	stw	r3,0(r17)
8112296c:	003ff706 	br	8112294c <__reset+0xfb10294c>

81122970 <_printf_r>:
81122970:	defffd04 	addi	sp,sp,-12
81122974:	2805883a 	mov	r2,r5
81122978:	de00012e 	bgeu	sp,et,81122980 <_printf_r+0x10>
8112297c:	003b68fa 	trap	3
81122980:	dfc00015 	stw	ra,0(sp)
81122984:	d9800115 	stw	r6,4(sp)
81122988:	d9c00215 	stw	r7,8(sp)
8112298c:	21400217 	ldw	r5,8(r4)
81122990:	d9c00104 	addi	r7,sp,4
81122994:	100d883a 	mov	r6,r2
81122998:	11259a00 	call	811259a0 <___vfprintf_internal_r>
8112299c:	dfc00017 	ldw	ra,0(sp)
811229a0:	dec00304 	addi	sp,sp,12
811229a4:	f800283a 	ret

811229a8 <printf>:
811229a8:	defffc04 	addi	sp,sp,-16
811229ac:	de00012e 	bgeu	sp,et,811229b4 <printf+0xc>
811229b0:	003b68fa 	trap	3
811229b4:	dfc00015 	stw	ra,0(sp)
811229b8:	d9400115 	stw	r5,4(sp)
811229bc:	d9800215 	stw	r6,8(sp)
811229c0:	d9c00315 	stw	r7,12(sp)
811229c4:	00a04574 	movhi	r2,33045
811229c8:	108d0f04 	addi	r2,r2,13372
811229cc:	10800017 	ldw	r2,0(r2)
811229d0:	200b883a 	mov	r5,r4
811229d4:	d9800104 	addi	r6,sp,4
811229d8:	11000217 	ldw	r4,8(r2)
811229dc:	1127ba00 	call	81127ba0 <__vfprintf_internal>
811229e0:	dfc00017 	ldw	ra,0(sp)
811229e4:	dec00404 	addi	sp,sp,16
811229e8:	f800283a 	ret

811229ec <_putc_r>:
811229ec:	defffc04 	addi	sp,sp,-16
811229f0:	de00012e 	bgeu	sp,et,811229f8 <_putc_r+0xc>
811229f4:	003b68fa 	trap	3
811229f8:	dc000215 	stw	r16,8(sp)
811229fc:	dfc00315 	stw	ra,12(sp)
81122a00:	2021883a 	mov	r16,r4
81122a04:	20000226 	beq	r4,zero,81122a10 <_putc_r+0x24>
81122a08:	20800e17 	ldw	r2,56(r4)
81122a0c:	10001b26 	beq	r2,zero,81122a7c <_putc_r+0x90>
81122a10:	30800217 	ldw	r2,8(r6)
81122a14:	10bfffc4 	addi	r2,r2,-1
81122a18:	30800215 	stw	r2,8(r6)
81122a1c:	10000a16 	blt	r2,zero,81122a48 <_putc_r+0x5c>
81122a20:	30800017 	ldw	r2,0(r6)
81122a24:	11400005 	stb	r5,0(r2)
81122a28:	30800017 	ldw	r2,0(r6)
81122a2c:	10c00044 	addi	r3,r2,1
81122a30:	30c00015 	stw	r3,0(r6)
81122a34:	10800003 	ldbu	r2,0(r2)
81122a38:	dfc00317 	ldw	ra,12(sp)
81122a3c:	dc000217 	ldw	r16,8(sp)
81122a40:	dec00404 	addi	sp,sp,16
81122a44:	f800283a 	ret
81122a48:	30c00617 	ldw	r3,24(r6)
81122a4c:	10c00616 	blt	r2,r3,81122a68 <_putc_r+0x7c>
81122a50:	30800017 	ldw	r2,0(r6)
81122a54:	00c00284 	movi	r3,10
81122a58:	11400005 	stb	r5,0(r2)
81122a5c:	30800017 	ldw	r2,0(r6)
81122a60:	11400003 	ldbu	r5,0(r2)
81122a64:	28fff11e 	bne	r5,r3,81122a2c <__reset+0xfb102a2c>
81122a68:	8009883a 	mov	r4,r16
81122a6c:	dfc00317 	ldw	ra,12(sp)
81122a70:	dc000217 	ldw	r16,8(sp)
81122a74:	dec00404 	addi	sp,sp,16
81122a78:	11295241 	jmpi	81129524 <__swbuf_r>
81122a7c:	d9400015 	stw	r5,0(sp)
81122a80:	d9800115 	stw	r6,4(sp)
81122a84:	112b75c0 	call	8112b75c <__sinit>
81122a88:	d9800117 	ldw	r6,4(sp)
81122a8c:	d9400017 	ldw	r5,0(sp)
81122a90:	003fdf06 	br	81122a10 <__reset+0xfb102a10>

81122a94 <putc>:
81122a94:	00a04574 	movhi	r2,33045
81122a98:	defffc04 	addi	sp,sp,-16
81122a9c:	108d0f04 	addi	r2,r2,13372
81122aa0:	de00012e 	bgeu	sp,et,81122aa8 <putc+0x14>
81122aa4:	003b68fa 	trap	3
81122aa8:	dc000115 	stw	r16,4(sp)
81122aac:	14000017 	ldw	r16,0(r2)
81122ab0:	dc400215 	stw	r17,8(sp)
81122ab4:	dfc00315 	stw	ra,12(sp)
81122ab8:	2023883a 	mov	r17,r4
81122abc:	80000226 	beq	r16,zero,81122ac8 <putc+0x34>
81122ac0:	80800e17 	ldw	r2,56(r16)
81122ac4:	10001a26 	beq	r2,zero,81122b30 <putc+0x9c>
81122ac8:	28800217 	ldw	r2,8(r5)
81122acc:	10bfffc4 	addi	r2,r2,-1
81122ad0:	28800215 	stw	r2,8(r5)
81122ad4:	10000b16 	blt	r2,zero,81122b04 <putc+0x70>
81122ad8:	28800017 	ldw	r2,0(r5)
81122adc:	14400005 	stb	r17,0(r2)
81122ae0:	28800017 	ldw	r2,0(r5)
81122ae4:	10c00044 	addi	r3,r2,1
81122ae8:	28c00015 	stw	r3,0(r5)
81122aec:	10800003 	ldbu	r2,0(r2)
81122af0:	dfc00317 	ldw	ra,12(sp)
81122af4:	dc400217 	ldw	r17,8(sp)
81122af8:	dc000117 	ldw	r16,4(sp)
81122afc:	dec00404 	addi	sp,sp,16
81122b00:	f800283a 	ret
81122b04:	28c00617 	ldw	r3,24(r5)
81122b08:	10c00e16 	blt	r2,r3,81122b44 <putc+0xb0>
81122b0c:	28800017 	ldw	r2,0(r5)
81122b10:	01000284 	movi	r4,10
81122b14:	14400005 	stb	r17,0(r2)
81122b18:	28800017 	ldw	r2,0(r5)
81122b1c:	10c00003 	ldbu	r3,0(r2)
81122b20:	193ff01e 	bne	r3,r4,81122ae4 <__reset+0xfb102ae4>
81122b24:	280d883a 	mov	r6,r5
81122b28:	180b883a 	mov	r5,r3
81122b2c:	00000706 	br	81122b4c <putc+0xb8>
81122b30:	8009883a 	mov	r4,r16
81122b34:	d9400015 	stw	r5,0(sp)
81122b38:	112b75c0 	call	8112b75c <__sinit>
81122b3c:	d9400017 	ldw	r5,0(sp)
81122b40:	003fe106 	br	81122ac8 <__reset+0xfb102ac8>
81122b44:	280d883a 	mov	r6,r5
81122b48:	880b883a 	mov	r5,r17
81122b4c:	8009883a 	mov	r4,r16
81122b50:	dfc00317 	ldw	ra,12(sp)
81122b54:	dc400217 	ldw	r17,8(sp)
81122b58:	dc000117 	ldw	r16,4(sp)
81122b5c:	dec00404 	addi	sp,sp,16
81122b60:	11295241 	jmpi	81129524 <__swbuf_r>

81122b64 <_puts_r>:
81122b64:	defff604 	addi	sp,sp,-40
81122b68:	de00012e 	bgeu	sp,et,81122b70 <_puts_r+0xc>
81122b6c:	003b68fa 	trap	3
81122b70:	dc000715 	stw	r16,28(sp)
81122b74:	2021883a 	mov	r16,r4
81122b78:	2809883a 	mov	r4,r5
81122b7c:	dc400815 	stw	r17,32(sp)
81122b80:	dfc00915 	stw	ra,36(sp)
81122b84:	2823883a 	mov	r17,r5
81122b88:	11231840 	call	81123184 <strlen>
81122b8c:	10c00044 	addi	r3,r2,1
81122b90:	d8800115 	stw	r2,4(sp)
81122b94:	00a04574 	movhi	r2,33045
81122b98:	10833604 	addi	r2,r2,3288
81122b9c:	d8800215 	stw	r2,8(sp)
81122ba0:	00800044 	movi	r2,1
81122ba4:	d8800315 	stw	r2,12(sp)
81122ba8:	00800084 	movi	r2,2
81122bac:	dc400015 	stw	r17,0(sp)
81122bb0:	d8c00615 	stw	r3,24(sp)
81122bb4:	dec00415 	stw	sp,16(sp)
81122bb8:	d8800515 	stw	r2,20(sp)
81122bbc:	80000226 	beq	r16,zero,81122bc8 <_puts_r+0x64>
81122bc0:	80800e17 	ldw	r2,56(r16)
81122bc4:	10001426 	beq	r2,zero,81122c18 <_puts_r+0xb4>
81122bc8:	81400217 	ldw	r5,8(r16)
81122bcc:	2880030b 	ldhu	r2,12(r5)
81122bd0:	10c8000c 	andi	r3,r2,8192
81122bd4:	1800061e 	bne	r3,zero,81122bf0 <_puts_r+0x8c>
81122bd8:	29001917 	ldw	r4,100(r5)
81122bdc:	00f7ffc4 	movi	r3,-8193
81122be0:	10880014 	ori	r2,r2,8192
81122be4:	20c6703a 	and	r3,r4,r3
81122be8:	2880030d 	sth	r2,12(r5)
81122bec:	28c01915 	stw	r3,100(r5)
81122bf0:	d9800404 	addi	r6,sp,16
81122bf4:	8009883a 	mov	r4,r16
81122bf8:	112bf0c0 	call	8112bf0c <__sfvwrite_r>
81122bfc:	1000091e 	bne	r2,zero,81122c24 <_puts_r+0xc0>
81122c00:	00800284 	movi	r2,10
81122c04:	dfc00917 	ldw	ra,36(sp)
81122c08:	dc400817 	ldw	r17,32(sp)
81122c0c:	dc000717 	ldw	r16,28(sp)
81122c10:	dec00a04 	addi	sp,sp,40
81122c14:	f800283a 	ret
81122c18:	8009883a 	mov	r4,r16
81122c1c:	112b75c0 	call	8112b75c <__sinit>
81122c20:	003fe906 	br	81122bc8 <__reset+0xfb102bc8>
81122c24:	00bfffc4 	movi	r2,-1
81122c28:	003ff606 	br	81122c04 <__reset+0xfb102c04>

81122c2c <puts>:
81122c2c:	00a04574 	movhi	r2,33045
81122c30:	108d0f04 	addi	r2,r2,13372
81122c34:	200b883a 	mov	r5,r4
81122c38:	11000017 	ldw	r4,0(r2)
81122c3c:	1122b641 	jmpi	81122b64 <_puts_r>

81122c40 <lflush>:
81122c40:	2080030b 	ldhu	r2,12(r4)
81122c44:	00c00244 	movi	r3,9
81122c48:	1080024c 	andi	r2,r2,9
81122c4c:	10c00226 	beq	r2,r3,81122c58 <lflush+0x18>
81122c50:	0005883a 	mov	r2,zero
81122c54:	f800283a 	ret
81122c58:	112b3c41 	jmpi	8112b3c4 <fflush>

81122c5c <__srefill_r>:
81122c5c:	defffc04 	addi	sp,sp,-16
81122c60:	de00012e 	bgeu	sp,et,81122c68 <__srefill_r+0xc>
81122c64:	003b68fa 	trap	3
81122c68:	dc400115 	stw	r17,4(sp)
81122c6c:	dc000015 	stw	r16,0(sp)
81122c70:	dfc00315 	stw	ra,12(sp)
81122c74:	dc800215 	stw	r18,8(sp)
81122c78:	2023883a 	mov	r17,r4
81122c7c:	2821883a 	mov	r16,r5
81122c80:	20000226 	beq	r4,zero,81122c8c <__srefill_r+0x30>
81122c84:	20800e17 	ldw	r2,56(r4)
81122c88:	10003c26 	beq	r2,zero,81122d7c <__srefill_r+0x120>
81122c8c:	80c0030b 	ldhu	r3,12(r16)
81122c90:	1908000c 	andi	r4,r3,8192
81122c94:	1805883a 	mov	r2,r3
81122c98:	2000071e 	bne	r4,zero,81122cb8 <__srefill_r+0x5c>
81122c9c:	81001917 	ldw	r4,100(r16)
81122ca0:	18880014 	ori	r2,r3,8192
81122ca4:	00f7ffc4 	movi	r3,-8193
81122ca8:	20c8703a 	and	r4,r4,r3
81122cac:	8080030d 	sth	r2,12(r16)
81122cb0:	1007883a 	mov	r3,r2
81122cb4:	81001915 	stw	r4,100(r16)
81122cb8:	80000115 	stw	zero,4(r16)
81122cbc:	1100080c 	andi	r4,r2,32
81122cc0:	2000571e 	bne	r4,zero,81122e20 <__srefill_r+0x1c4>
81122cc4:	1100010c 	andi	r4,r2,4
81122cc8:	20001f26 	beq	r4,zero,81122d48 <__srefill_r+0xec>
81122ccc:	81400c17 	ldw	r5,48(r16)
81122cd0:	28000826 	beq	r5,zero,81122cf4 <__srefill_r+0x98>
81122cd4:	80801004 	addi	r2,r16,64
81122cd8:	28800226 	beq	r5,r2,81122ce4 <__srefill_r+0x88>
81122cdc:	8809883a 	mov	r4,r17
81122ce0:	112bbf40 	call	8112bbf4 <_free_r>
81122ce4:	80800f17 	ldw	r2,60(r16)
81122ce8:	80000c15 	stw	zero,48(r16)
81122cec:	80800115 	stw	r2,4(r16)
81122cf0:	1000391e 	bne	r2,zero,81122dd8 <__srefill_r+0x17c>
81122cf4:	80800417 	ldw	r2,16(r16)
81122cf8:	10004b26 	beq	r2,zero,81122e28 <__srefill_r+0x1cc>
81122cfc:	8480030b 	ldhu	r18,12(r16)
81122d00:	908000cc 	andi	r2,r18,3
81122d04:	10001f1e 	bne	r2,zero,81122d84 <__srefill_r+0x128>
81122d08:	81800417 	ldw	r6,16(r16)
81122d0c:	80800817 	ldw	r2,32(r16)
81122d10:	81c00517 	ldw	r7,20(r16)
81122d14:	81400717 	ldw	r5,28(r16)
81122d18:	81800015 	stw	r6,0(r16)
81122d1c:	8809883a 	mov	r4,r17
81122d20:	103ee83a 	callr	r2
81122d24:	80800115 	stw	r2,4(r16)
81122d28:	00800e0e 	bge	zero,r2,81122d64 <__srefill_r+0x108>
81122d2c:	0005883a 	mov	r2,zero
81122d30:	dfc00317 	ldw	ra,12(sp)
81122d34:	dc800217 	ldw	r18,8(sp)
81122d38:	dc400117 	ldw	r17,4(sp)
81122d3c:	dc000017 	ldw	r16,0(sp)
81122d40:	dec00404 	addi	sp,sp,16
81122d44:	f800283a 	ret
81122d48:	1100040c 	andi	r4,r2,16
81122d4c:	20003026 	beq	r4,zero,81122e10 <__srefill_r+0x1b4>
81122d50:	1080020c 	andi	r2,r2,8
81122d54:	1000241e 	bne	r2,zero,81122de8 <__srefill_r+0x18c>
81122d58:	18c00114 	ori	r3,r3,4
81122d5c:	80c0030d 	sth	r3,12(r16)
81122d60:	003fe406 	br	81122cf4 <__reset+0xfb102cf4>
81122d64:	80c0030b 	ldhu	r3,12(r16)
81122d68:	1000161e 	bne	r2,zero,81122dc4 <__srefill_r+0x168>
81122d6c:	18c00814 	ori	r3,r3,32
81122d70:	00bfffc4 	movi	r2,-1
81122d74:	80c0030d 	sth	r3,12(r16)
81122d78:	003fed06 	br	81122d30 <__reset+0xfb102d30>
81122d7c:	112b75c0 	call	8112b75c <__sinit>
81122d80:	003fc206 	br	81122c8c <__reset+0xfb102c8c>
81122d84:	00a04574 	movhi	r2,33045
81122d88:	108d0e04 	addi	r2,r2,13368
81122d8c:	11000017 	ldw	r4,0(r2)
81122d90:	016044b4 	movhi	r5,33042
81122d94:	00800044 	movi	r2,1
81122d98:	294b1004 	addi	r5,r5,11328
81122d9c:	8080030d 	sth	r2,12(r16)
81122da0:	112c3d00 	call	8112c3d0 <_fwalk>
81122da4:	00800244 	movi	r2,9
81122da8:	8480030d 	sth	r18,12(r16)
81122dac:	9480024c 	andi	r18,r18,9
81122db0:	90bfd51e 	bne	r18,r2,81122d08 <__reset+0xfb102d08>
81122db4:	800b883a 	mov	r5,r16
81122db8:	8809883a 	mov	r4,r17
81122dbc:	112b13c0 	call	8112b13c <__sflush_r>
81122dc0:	003fd106 	br	81122d08 <__reset+0xfb102d08>
81122dc4:	18c01014 	ori	r3,r3,64
81122dc8:	80000115 	stw	zero,4(r16)
81122dcc:	00bfffc4 	movi	r2,-1
81122dd0:	80c0030d 	sth	r3,12(r16)
81122dd4:	003fd606 	br	81122d30 <__reset+0xfb102d30>
81122dd8:	80c00e17 	ldw	r3,56(r16)
81122ddc:	0005883a 	mov	r2,zero
81122de0:	80c00015 	stw	r3,0(r16)
81122de4:	003fd206 	br	81122d30 <__reset+0xfb102d30>
81122de8:	800b883a 	mov	r5,r16
81122dec:	8809883a 	mov	r4,r17
81122df0:	112b3600 	call	8112b360 <_fflush_r>
81122df4:	10000a1e 	bne	r2,zero,81122e20 <__srefill_r+0x1c4>
81122df8:	8080030b 	ldhu	r2,12(r16)
81122dfc:	00fffdc4 	movi	r3,-9
81122e00:	80000215 	stw	zero,8(r16)
81122e04:	1886703a 	and	r3,r3,r2
81122e08:	80000615 	stw	zero,24(r16)
81122e0c:	003fd206 	br	81122d58 <__reset+0xfb102d58>
81122e10:	00800244 	movi	r2,9
81122e14:	88800015 	stw	r2,0(r17)
81122e18:	18c01014 	ori	r3,r3,64
81122e1c:	80c0030d 	sth	r3,12(r16)
81122e20:	00bfffc4 	movi	r2,-1
81122e24:	003fc206 	br	81122d30 <__reset+0xfb102d30>
81122e28:	800b883a 	mov	r5,r16
81122e2c:	8809883a 	mov	r4,r17
81122e30:	1121cb80 	call	81121cb8 <__smakebuf_r>
81122e34:	003fb106 	br	81122cfc <__reset+0xfb102cfc>

81122e38 <_sbrk_r>:
81122e38:	defffd04 	addi	sp,sp,-12
81122e3c:	de00012e 	bgeu	sp,et,81122e44 <_sbrk_r+0xc>
81122e40:	003b68fa 	trap	3
81122e44:	dc000015 	stw	r16,0(sp)
81122e48:	04204574 	movhi	r16,33045
81122e4c:	dc400115 	stw	r17,4(sp)
81122e50:	840d8204 	addi	r16,r16,13832
81122e54:	2023883a 	mov	r17,r4
81122e58:	2809883a 	mov	r4,r5
81122e5c:	dfc00215 	stw	ra,8(sp)
81122e60:	80000015 	stw	zero,0(r16)
81122e64:	1137a640 	call	81137a64 <sbrk>
81122e68:	00ffffc4 	movi	r3,-1
81122e6c:	10c00526 	beq	r2,r3,81122e84 <_sbrk_r+0x4c>
81122e70:	dfc00217 	ldw	ra,8(sp)
81122e74:	dc400117 	ldw	r17,4(sp)
81122e78:	dc000017 	ldw	r16,0(sp)
81122e7c:	dec00304 	addi	sp,sp,12
81122e80:	f800283a 	ret
81122e84:	80c00017 	ldw	r3,0(r16)
81122e88:	183ff926 	beq	r3,zero,81122e70 <__reset+0xfb102e70>
81122e8c:	88c00015 	stw	r3,0(r17)
81122e90:	003ff706 	br	81122e70 <__reset+0xfb102e70>

81122e94 <scanf>:
81122e94:	defffc04 	addi	sp,sp,-16
81122e98:	de00012e 	bgeu	sp,et,81122ea0 <scanf+0xc>
81122e9c:	003b68fa 	trap	3
81122ea0:	dfc00015 	stw	ra,0(sp)
81122ea4:	d9400115 	stw	r5,4(sp)
81122ea8:	d9800215 	stw	r6,8(sp)
81122eac:	d9c00315 	stw	r7,12(sp)
81122eb0:	00a04574 	movhi	r2,33045
81122eb4:	108d0f04 	addi	r2,r2,13372
81122eb8:	200d883a 	mov	r6,r4
81122ebc:	11000017 	ldw	r4,0(r2)
81122ec0:	d9c00104 	addi	r7,sp,4
81122ec4:	21400117 	ldw	r5,4(r4)
81122ec8:	11294d00 	call	811294d0 <_vfscanf_r>
81122ecc:	dfc00017 	ldw	ra,0(sp)
81122ed0:	dec00404 	addi	sp,sp,16
81122ed4:	f800283a 	ret

81122ed8 <_scanf_r>:
81122ed8:	defffd04 	addi	sp,sp,-12
81122edc:	2805883a 	mov	r2,r5
81122ee0:	de00012e 	bgeu	sp,et,81122ee8 <_scanf_r+0x10>
81122ee4:	003b68fa 	trap	3
81122ee8:	dfc00015 	stw	ra,0(sp)
81122eec:	d9800115 	stw	r6,4(sp)
81122ef0:	d9c00215 	stw	r7,8(sp)
81122ef4:	21400117 	ldw	r5,4(r4)
81122ef8:	d9c00104 	addi	r7,sp,4
81122efc:	100d883a 	mov	r6,r2
81122f00:	11294d00 	call	811294d0 <_vfscanf_r>
81122f04:	dfc00017 	ldw	ra,0(sp)
81122f08:	dec00304 	addi	sp,sp,12
81122f0c:	f800283a 	ret

81122f10 <_sprintf_r>:
81122f10:	deffe404 	addi	sp,sp,-112
81122f14:	2807883a 	mov	r3,r5
81122f18:	de00012e 	bgeu	sp,et,81122f20 <_sprintf_r+0x10>
81122f1c:	003b68fa 	trap	3
81122f20:	dfc01a15 	stw	ra,104(sp)
81122f24:	d9c01b15 	stw	r7,108(sp)
81122f28:	00a00034 	movhi	r2,32768
81122f2c:	10bfffc4 	addi	r2,r2,-1
81122f30:	02008204 	movi	r8,520
81122f34:	d8800215 	stw	r2,8(sp)
81122f38:	d8800515 	stw	r2,20(sp)
81122f3c:	d9c01b04 	addi	r7,sp,108
81122f40:	d80b883a 	mov	r5,sp
81122f44:	00bfffc4 	movi	r2,-1
81122f48:	d8c00015 	stw	r3,0(sp)
81122f4c:	d8c00415 	stw	r3,16(sp)
81122f50:	da00030d 	sth	r8,12(sp)
81122f54:	d880038d 	sth	r2,14(sp)
81122f58:	11237c00 	call	811237c0 <___svfprintf_internal_r>
81122f5c:	d8c00017 	ldw	r3,0(sp)
81122f60:	18000005 	stb	zero,0(r3)
81122f64:	dfc01a17 	ldw	ra,104(sp)
81122f68:	dec01c04 	addi	sp,sp,112
81122f6c:	f800283a 	ret

81122f70 <sprintf>:
81122f70:	deffe304 	addi	sp,sp,-116
81122f74:	2007883a 	mov	r3,r4
81122f78:	de00012e 	bgeu	sp,et,81122f80 <sprintf+0x10>
81122f7c:	003b68fa 	trap	3
81122f80:	dfc01a15 	stw	ra,104(sp)
81122f84:	d9801b15 	stw	r6,108(sp)
81122f88:	d9c01c15 	stw	r7,112(sp)
81122f8c:	01204574 	movhi	r4,33045
81122f90:	210d0f04 	addi	r4,r4,13372
81122f94:	21000017 	ldw	r4,0(r4)
81122f98:	00a00034 	movhi	r2,32768
81122f9c:	10bfffc4 	addi	r2,r2,-1
81122fa0:	280d883a 	mov	r6,r5
81122fa4:	02008204 	movi	r8,520
81122fa8:	d8800215 	stw	r2,8(sp)
81122fac:	d8800515 	stw	r2,20(sp)
81122fb0:	d9c01b04 	addi	r7,sp,108
81122fb4:	d80b883a 	mov	r5,sp
81122fb8:	00bfffc4 	movi	r2,-1
81122fbc:	d8c00015 	stw	r3,0(sp)
81122fc0:	d8c00415 	stw	r3,16(sp)
81122fc4:	da00030d 	sth	r8,12(sp)
81122fc8:	d880038d 	sth	r2,14(sp)
81122fcc:	11237c00 	call	811237c0 <___svfprintf_internal_r>
81122fd0:	d8c00017 	ldw	r3,0(sp)
81122fd4:	18000005 	stb	zero,0(r3)
81122fd8:	dfc01a17 	ldw	ra,104(sp)
81122fdc:	dec01d04 	addi	sp,sp,116
81122fe0:	f800283a 	ret

81122fe4 <__sread>:
81122fe4:	defffe04 	addi	sp,sp,-8
81122fe8:	de00012e 	bgeu	sp,et,81122ff0 <__sread+0xc>
81122fec:	003b68fa 	trap	3
81122ff0:	dc000015 	stw	r16,0(sp)
81122ff4:	2821883a 	mov	r16,r5
81122ff8:	2940038f 	ldh	r5,14(r5)
81122ffc:	dfc00115 	stw	ra,4(sp)
81123000:	112dc200 	call	8112dc20 <_read_r>
81123004:	10000716 	blt	r2,zero,81123024 <__sread+0x40>
81123008:	80c01417 	ldw	r3,80(r16)
8112300c:	1887883a 	add	r3,r3,r2
81123010:	80c01415 	stw	r3,80(r16)
81123014:	dfc00117 	ldw	ra,4(sp)
81123018:	dc000017 	ldw	r16,0(sp)
8112301c:	dec00204 	addi	sp,sp,8
81123020:	f800283a 	ret
81123024:	80c0030b 	ldhu	r3,12(r16)
81123028:	18fbffcc 	andi	r3,r3,61439
8112302c:	80c0030d 	sth	r3,12(r16)
81123030:	dfc00117 	ldw	ra,4(sp)
81123034:	dc000017 	ldw	r16,0(sp)
81123038:	dec00204 	addi	sp,sp,8
8112303c:	f800283a 	ret

81123040 <__seofread>:
81123040:	0005883a 	mov	r2,zero
81123044:	f800283a 	ret

81123048 <__swrite>:
81123048:	defffb04 	addi	sp,sp,-20
8112304c:	de00012e 	bgeu	sp,et,81123054 <__swrite+0xc>
81123050:	003b68fa 	trap	3
81123054:	2880030b 	ldhu	r2,12(r5)
81123058:	dcc00315 	stw	r19,12(sp)
8112305c:	dc800215 	stw	r18,8(sp)
81123060:	dc400115 	stw	r17,4(sp)
81123064:	dc000015 	stw	r16,0(sp)
81123068:	dfc00415 	stw	ra,16(sp)
8112306c:	10c0400c 	andi	r3,r2,256
81123070:	2821883a 	mov	r16,r5
81123074:	2023883a 	mov	r17,r4
81123078:	3025883a 	mov	r18,r6
8112307c:	3827883a 	mov	r19,r7
81123080:	18000526 	beq	r3,zero,81123098 <__swrite+0x50>
81123084:	2940038f 	ldh	r5,14(r5)
81123088:	01c00084 	movi	r7,2
8112308c:	000d883a 	mov	r6,zero
81123090:	112c6d80 	call	8112c6d8 <_lseek_r>
81123094:	8080030b 	ldhu	r2,12(r16)
81123098:	8140038f 	ldh	r5,14(r16)
8112309c:	10bbffcc 	andi	r2,r2,61439
811230a0:	980f883a 	mov	r7,r19
811230a4:	900d883a 	mov	r6,r18
811230a8:	8809883a 	mov	r4,r17
811230ac:	8080030d 	sth	r2,12(r16)
811230b0:	dfc00417 	ldw	ra,16(sp)
811230b4:	dcc00317 	ldw	r19,12(sp)
811230b8:	dc800217 	ldw	r18,8(sp)
811230bc:	dc400117 	ldw	r17,4(sp)
811230c0:	dc000017 	ldw	r16,0(sp)
811230c4:	dec00504 	addi	sp,sp,20
811230c8:	11296841 	jmpi	81129684 <_write_r>

811230cc <__sseek>:
811230cc:	defffe04 	addi	sp,sp,-8
811230d0:	de00012e 	bgeu	sp,et,811230d8 <__sseek+0xc>
811230d4:	003b68fa 	trap	3
811230d8:	dc000015 	stw	r16,0(sp)
811230dc:	2821883a 	mov	r16,r5
811230e0:	2940038f 	ldh	r5,14(r5)
811230e4:	dfc00115 	stw	ra,4(sp)
811230e8:	112c6d80 	call	8112c6d8 <_lseek_r>
811230ec:	00ffffc4 	movi	r3,-1
811230f0:	10c00826 	beq	r2,r3,81123114 <__sseek+0x48>
811230f4:	80c0030b 	ldhu	r3,12(r16)
811230f8:	80801415 	stw	r2,80(r16)
811230fc:	18c40014 	ori	r3,r3,4096
81123100:	80c0030d 	sth	r3,12(r16)
81123104:	dfc00117 	ldw	ra,4(sp)
81123108:	dc000017 	ldw	r16,0(sp)
8112310c:	dec00204 	addi	sp,sp,8
81123110:	f800283a 	ret
81123114:	80c0030b 	ldhu	r3,12(r16)
81123118:	18fbffcc 	andi	r3,r3,61439
8112311c:	80c0030d 	sth	r3,12(r16)
81123120:	dfc00117 	ldw	ra,4(sp)
81123124:	dc000017 	ldw	r16,0(sp)
81123128:	dec00204 	addi	sp,sp,8
8112312c:	f800283a 	ret

81123130 <__sclose>:
81123130:	2940038f 	ldh	r5,14(r5)
81123134:	11298481 	jmpi	81129848 <_close_r>

81123138 <strcspn>:
81123138:	21c00007 	ldb	r7,0(r4)
8112313c:	38000f26 	beq	r7,zero,8112317c <strcspn+0x44>
81123140:	2a000007 	ldb	r8,0(r5)
81123144:	2005883a 	mov	r2,r4
81123148:	40000726 	beq	r8,zero,81123168 <strcspn+0x30>
8112314c:	3a000926 	beq	r7,r8,81123174 <strcspn+0x3c>
81123150:	2807883a 	mov	r3,r5
81123154:	00000106 	br	8112315c <strcspn+0x24>
81123158:	31c00626 	beq	r6,r7,81123174 <strcspn+0x3c>
8112315c:	18c00044 	addi	r3,r3,1
81123160:	19800007 	ldb	r6,0(r3)
81123164:	303ffc1e 	bne	r6,zero,81123158 <__reset+0xfb103158>
81123168:	10800044 	addi	r2,r2,1
8112316c:	11c00007 	ldb	r7,0(r2)
81123170:	383ff51e 	bne	r7,zero,81123148 <__reset+0xfb103148>
81123174:	1105c83a 	sub	r2,r2,r4
81123178:	f800283a 	ret
8112317c:	0005883a 	mov	r2,zero
81123180:	f800283a 	ret

81123184 <strlen>:
81123184:	208000cc 	andi	r2,r4,3
81123188:	10002026 	beq	r2,zero,8112320c <strlen+0x88>
8112318c:	20800007 	ldb	r2,0(r4)
81123190:	10002026 	beq	r2,zero,81123214 <strlen+0x90>
81123194:	2005883a 	mov	r2,r4
81123198:	00000206 	br	811231a4 <strlen+0x20>
8112319c:	10c00007 	ldb	r3,0(r2)
811231a0:	18001826 	beq	r3,zero,81123204 <strlen+0x80>
811231a4:	10800044 	addi	r2,r2,1
811231a8:	10c000cc 	andi	r3,r2,3
811231ac:	183ffb1e 	bne	r3,zero,8112319c <__reset+0xfb10319c>
811231b0:	10c00017 	ldw	r3,0(r2)
811231b4:	01ffbff4 	movhi	r7,65279
811231b8:	39ffbfc4 	addi	r7,r7,-257
811231bc:	00ca303a 	nor	r5,zero,r3
811231c0:	01a02074 	movhi	r6,32897
811231c4:	19c7883a 	add	r3,r3,r7
811231c8:	31a02004 	addi	r6,r6,-32640
811231cc:	1946703a 	and	r3,r3,r5
811231d0:	1986703a 	and	r3,r3,r6
811231d4:	1800091e 	bne	r3,zero,811231fc <strlen+0x78>
811231d8:	10800104 	addi	r2,r2,4
811231dc:	10c00017 	ldw	r3,0(r2)
811231e0:	19cb883a 	add	r5,r3,r7
811231e4:	00c6303a 	nor	r3,zero,r3
811231e8:	28c6703a 	and	r3,r5,r3
811231ec:	1986703a 	and	r3,r3,r6
811231f0:	183ff926 	beq	r3,zero,811231d8 <__reset+0xfb1031d8>
811231f4:	00000106 	br	811231fc <strlen+0x78>
811231f8:	10800044 	addi	r2,r2,1
811231fc:	10c00007 	ldb	r3,0(r2)
81123200:	183ffd1e 	bne	r3,zero,811231f8 <__reset+0xfb1031f8>
81123204:	1105c83a 	sub	r2,r2,r4
81123208:	f800283a 	ret
8112320c:	2005883a 	mov	r2,r4
81123210:	003fe706 	br	811231b0 <__reset+0xfb1031b0>
81123214:	0005883a 	mov	r2,zero
81123218:	f800283a 	ret

8112321c <strnlen>:
8112321c:	28000e26 	beq	r5,zero,81123258 <strnlen+0x3c>
81123220:	20800007 	ldb	r2,0(r4)
81123224:	10000c26 	beq	r2,zero,81123258 <strnlen+0x3c>
81123228:	20c00044 	addi	r3,r4,1
8112322c:	214b883a 	add	r5,r4,r5
81123230:	28c00526 	beq	r5,r3,81123248 <strnlen+0x2c>
81123234:	19800007 	ldb	r6,0(r3)
81123238:	19c00044 	addi	r7,r3,1
8112323c:	30000426 	beq	r6,zero,81123250 <strnlen+0x34>
81123240:	3807883a 	mov	r3,r7
81123244:	28fffb1e 	bne	r5,r3,81123234 <__reset+0xfb103234>
81123248:	2905c83a 	sub	r2,r5,r4
8112324c:	f800283a 	ret
81123250:	1905c83a 	sub	r2,r3,r4
81123254:	f800283a 	ret
81123258:	0005883a 	mov	r2,zero
8112325c:	f800283a 	ret

81123260 <_strtol_r>:
81123260:	00a04574 	movhi	r2,33045
81123264:	defff404 	addi	sp,sp,-48
81123268:	108d0d04 	addi	r2,r2,13364
8112326c:	de00012e 	bgeu	sp,et,81123274 <_strtol_r+0x14>
81123270:	003b68fa 	trap	3
81123274:	dd400715 	stw	r21,28(sp)
81123278:	15400017 	ldw	r21,0(r2)
8112327c:	dd800815 	stw	r22,32(sp)
81123280:	dd000615 	stw	r20,24(sp)
81123284:	dcc00515 	stw	r19,20(sp)
81123288:	d9000015 	stw	r4,0(sp)
8112328c:	dfc00b15 	stw	ra,44(sp)
81123290:	df000a15 	stw	fp,40(sp)
81123294:	ddc00915 	stw	r23,36(sp)
81123298:	dc800415 	stw	r18,16(sp)
8112329c:	dc400315 	stw	r17,12(sp)
811232a0:	dc000215 	stw	r16,8(sp)
811232a4:	2829883a 	mov	r20,r5
811232a8:	3027883a 	mov	r19,r6
811232ac:	382d883a 	mov	r22,r7
811232b0:	2809883a 	mov	r4,r5
811232b4:	24000003 	ldbu	r16,0(r4)
811232b8:	24400044 	addi	r17,r4,1
811232bc:	2007883a 	mov	r3,r4
811232c0:	ac05883a 	add	r2,r21,r16
811232c4:	10800043 	ldbu	r2,1(r2)
811232c8:	8809883a 	mov	r4,r17
811232cc:	1080020c 	andi	r2,r2,8
811232d0:	103ff81e 	bne	r2,zero,811232b4 <__reset+0xfb1032b4>
811232d4:	00800b44 	movi	r2,45
811232d8:	80805826 	beq	r16,r2,8112343c <_strtol_r+0x1dc>
811232dc:	00800ac4 	movi	r2,43
811232e0:	80805a26 	beq	r16,r2,8112344c <_strtol_r+0x1ec>
811232e4:	0039883a 	mov	fp,zero
811232e8:	b0004426 	beq	r22,zero,811233fc <_strtol_r+0x19c>
811232ec:	00800404 	movi	r2,16
811232f0:	b0806026 	beq	r22,r2,81123474 <_strtol_r+0x214>
811232f4:	b02f883a 	mov	r23,r22
811232f8:	00a00034 	movhi	r2,32768
811232fc:	e025003a 	cmpeq	r18,fp,zero
81123300:	14a5c83a 	sub	r18,r2,r18
81123304:	b80b883a 	mov	r5,r23
81123308:	9009883a 	mov	r4,r18
8112330c:	1134c7c0 	call	81134c7c <__umodsi3>
81123310:	b80b883a 	mov	r5,r23
81123314:	9009883a 	mov	r4,r18
81123318:	d8800115 	stw	r2,4(sp)
8112331c:	1134c180 	call	81134c18 <__udivsi3>
81123320:	ac07883a 	add	r3,r21,r16
81123324:	18c00043 	ldbu	r3,1(r3)
81123328:	880b883a 	mov	r5,r17
8112332c:	000d883a 	mov	r6,zero
81123330:	1a00010c 	andi	r8,r3,4
81123334:	0009883a 	mov	r4,zero
81123338:	02800044 	movi	r10,1
8112333c:	027fffc4 	movi	r9,-1
81123340:	d9c00117 	ldw	r7,4(sp)
81123344:	40000e26 	beq	r8,zero,81123380 <_strtol_r+0x120>
81123348:	843ff404 	addi	r16,r16,-48
8112334c:	8580120e 	bge	r16,r22,81123398 <_strtol_r+0x138>
81123350:	32400526 	beq	r6,r9,81123368 <_strtol_r+0x108>
81123354:	11002536 	bltu	r2,r4,811233ec <_strtol_r+0x18c>
81123358:	20802326 	beq	r4,r2,811233e8 <_strtol_r+0x188>
8112335c:	25c9383a 	mul	r4,r4,r23
81123360:	01800044 	movi	r6,1
81123364:	8109883a 	add	r4,r16,r4
81123368:	2c000003 	ldbu	r16,0(r5)
8112336c:	29400044 	addi	r5,r5,1
81123370:	ac07883a 	add	r3,r21,r16
81123374:	18c00043 	ldbu	r3,1(r3)
81123378:	1a00010c 	andi	r8,r3,4
8112337c:	403ff21e 	bne	r8,zero,81123348 <__reset+0xfb103348>
81123380:	18c000cc 	andi	r3,r3,3
81123384:	18000426 	beq	r3,zero,81123398 <_strtol_r+0x138>
81123388:	1a801a26 	beq	r3,r10,811233f4 <_strtol_r+0x194>
8112338c:	00c015c4 	movi	r3,87
81123390:	80e1c83a 	sub	r16,r16,r3
81123394:	85bfee16 	blt	r16,r22,81123350 <__reset+0xfb103350>
81123398:	00bfffc4 	movi	r2,-1
8112339c:	30801e26 	beq	r6,r2,81123418 <_strtol_r+0x1b8>
811233a0:	e0001b1e 	bne	fp,zero,81123410 <_strtol_r+0x1b0>
811233a4:	2005883a 	mov	r2,r4
811233a8:	98000326 	beq	r19,zero,811233b8 <_strtol_r+0x158>
811233ac:	3000211e 	bne	r6,zero,81123434 <_strtol_r+0x1d4>
811233b0:	a00b883a 	mov	r5,r20
811233b4:	99400015 	stw	r5,0(r19)
811233b8:	dfc00b17 	ldw	ra,44(sp)
811233bc:	df000a17 	ldw	fp,40(sp)
811233c0:	ddc00917 	ldw	r23,36(sp)
811233c4:	dd800817 	ldw	r22,32(sp)
811233c8:	dd400717 	ldw	r21,28(sp)
811233cc:	dd000617 	ldw	r20,24(sp)
811233d0:	dcc00517 	ldw	r19,20(sp)
811233d4:	dc800417 	ldw	r18,16(sp)
811233d8:	dc400317 	ldw	r17,12(sp)
811233dc:	dc000217 	ldw	r16,8(sp)
811233e0:	dec00c04 	addi	sp,sp,48
811233e4:	f800283a 	ret
811233e8:	3c3fdc0e 	bge	r7,r16,8112335c <__reset+0xfb10335c>
811233ec:	01bfffc4 	movi	r6,-1
811233f0:	003fdd06 	br	81123368 <__reset+0xfb103368>
811233f4:	00c00dc4 	movi	r3,55
811233f8:	003fe506 	br	81123390 <__reset+0xfb103390>
811233fc:	00800c04 	movi	r2,48
81123400:	80801626 	beq	r16,r2,8112345c <_strtol_r+0x1fc>
81123404:	05800284 	movi	r22,10
81123408:	b02f883a 	mov	r23,r22
8112340c:	003fba06 	br	811232f8 <__reset+0xfb1032f8>
81123410:	0109c83a 	sub	r4,zero,r4
81123414:	003fe306 	br	811233a4 <__reset+0xfb1033a4>
81123418:	d9000017 	ldw	r4,0(sp)
8112341c:	00c00884 	movi	r3,34
81123420:	e005003a 	cmpeq	r2,fp,zero
81123424:	20c00015 	stw	r3,0(r4)
81123428:	00e00034 	movhi	r3,32768
8112342c:	1885c83a 	sub	r2,r3,r2
81123430:	983fe126 	beq	r19,zero,811233b8 <__reset+0xfb1033b8>
81123434:	297fffc4 	addi	r5,r5,-1
81123438:	003fde06 	br	811233b4 <__reset+0xfb1033b4>
8112343c:	1c400084 	addi	r17,r3,2
81123440:	1c000043 	ldbu	r16,1(r3)
81123444:	07000044 	movi	fp,1
81123448:	003fa706 	br	811232e8 <__reset+0xfb1032e8>
8112344c:	1c400084 	addi	r17,r3,2
81123450:	1c000043 	ldbu	r16,1(r3)
81123454:	0039883a 	mov	fp,zero
81123458:	003fa306 	br	811232e8 <__reset+0xfb1032e8>
8112345c:	88800003 	ldbu	r2,0(r17)
81123460:	00c01604 	movi	r3,88
81123464:	108037cc 	andi	r2,r2,223
81123468:	10c00826 	beq	r2,r3,8112348c <_strtol_r+0x22c>
8112346c:	05800204 	movi	r22,8
81123470:	003fa006 	br	811232f4 <__reset+0xfb1032f4>
81123474:	00800c04 	movi	r2,48
81123478:	80bf9e1e 	bne	r16,r2,811232f4 <__reset+0xfb1032f4>
8112347c:	88800003 	ldbu	r2,0(r17)
81123480:	00c01604 	movi	r3,88
81123484:	108037cc 	andi	r2,r2,223
81123488:	10ff9a1e 	bne	r2,r3,811232f4 <__reset+0xfb1032f4>
8112348c:	05c00404 	movi	r23,16
81123490:	8c000043 	ldbu	r16,1(r17)
81123494:	b82d883a 	mov	r22,r23
81123498:	8c400084 	addi	r17,r17,2
8112349c:	003f9606 	br	811232f8 <__reset+0xfb1032f8>

811234a0 <strtol>:
811234a0:	00a04574 	movhi	r2,33045
811234a4:	108d0f04 	addi	r2,r2,13372
811234a8:	300f883a 	mov	r7,r6
811234ac:	280d883a 	mov	r6,r5
811234b0:	200b883a 	mov	r5,r4
811234b4:	11000017 	ldw	r4,0(r2)
811234b8:	11232601 	jmpi	81123260 <_strtol_r>

811234bc <strtoll>:
811234bc:	00a04574 	movhi	r2,33045
811234c0:	108d0f04 	addi	r2,r2,13372
811234c4:	300f883a 	mov	r7,r6
811234c8:	280d883a 	mov	r6,r5
811234cc:	200b883a 	mov	r5,r4
811234d0:	11000017 	ldw	r4,0(r2)
811234d4:	11234d81 	jmpi	811234d8 <_strtoll_r>

811234d8 <_strtoll_r>:
811234d8:	00a04574 	movhi	r2,33045
811234dc:	defff304 	addi	sp,sp,-52
811234e0:	108d0d04 	addi	r2,r2,13364
811234e4:	de00012e 	bgeu	sp,et,811234ec <_strtoll_r+0x14>
811234e8:	003b68fa 	trap	3
811234ec:	dc800515 	stw	r18,20(sp)
811234f0:	14800017 	ldw	r18,0(r2)
811234f4:	dd800915 	stw	r22,36(sp)
811234f8:	dd400815 	stw	r21,32(sp)
811234fc:	dcc00615 	stw	r19,24(sp)
81123500:	d9000015 	stw	r4,0(sp)
81123504:	dfc00c15 	stw	ra,48(sp)
81123508:	df000b15 	stw	fp,44(sp)
8112350c:	ddc00a15 	stw	r23,40(sp)
81123510:	dd000715 	stw	r20,28(sp)
81123514:	dc400415 	stw	r17,16(sp)
81123518:	dc000315 	stw	r16,12(sp)
8112351c:	282d883a 	mov	r22,r5
81123520:	302b883a 	mov	r21,r6
81123524:	3827883a 	mov	r19,r7
81123528:	2809883a 	mov	r4,r5
8112352c:	24000003 	ldbu	r16,0(r4)
81123530:	24400044 	addi	r17,r4,1
81123534:	2007883a 	mov	r3,r4
81123538:	9405883a 	add	r2,r18,r16
8112353c:	10800043 	ldbu	r2,1(r2)
81123540:	8809883a 	mov	r4,r17
81123544:	1080020c 	andi	r2,r2,8
81123548:	103ff81e 	bne	r2,zero,8112352c <__reset+0xfb10352c>
8112354c:	00800b44 	movi	r2,45
81123550:	80807826 	beq	r16,r2,81123734 <_strtoll_r+0x25c>
81123554:	00800ac4 	movi	r2,43
81123558:	80807a26 	beq	r16,r2,81123744 <_strtoll_r+0x26c>
8112355c:	0039883a 	mov	fp,zero
81123560:	98004e26 	beq	r19,zero,8112369c <_strtoll_r+0x1c4>
81123564:	00800404 	movi	r2,16
81123568:	98808226 	beq	r19,r2,81123774 <_strtoll_r+0x29c>
8112356c:	982fd7fa 	srai	r23,r19,31
81123570:	9829883a 	mov	r20,r19
81123574:	e0004f26 	beq	fp,zero,811236b4 <_strtoll_r+0x1dc>
81123578:	0017883a 	mov	r11,zero
8112357c:	02a00034 	movhi	r10,32768
81123580:	5809883a 	mov	r4,r11
81123584:	500b883a 	mov	r5,r10
81123588:	a00d883a 	mov	r6,r20
8112358c:	b80f883a 	mov	r7,r23
81123590:	da800215 	stw	r10,8(sp)
81123594:	dac00115 	stw	r11,4(sp)
81123598:	11345e00 	call	811345e0 <__umoddi3>
8112359c:	dac00117 	ldw	r11,4(sp)
811235a0:	da800217 	ldw	r10,8(sp)
811235a4:	a00d883a 	mov	r6,r20
811235a8:	5809883a 	mov	r4,r11
811235ac:	500b883a 	mov	r5,r10
811235b0:	b80f883a 	mov	r7,r23
811235b4:	d8800115 	stw	r2,4(sp)
811235b8:	11340600 	call	81134060 <__udivdi3>
811235bc:	9409883a 	add	r4,r18,r16
811235c0:	21000043 	ldbu	r4,1(r4)
811235c4:	1019883a 	mov	r12,r2
811235c8:	880b883a 	mov	r5,r17
811235cc:	2240010c 	andi	r9,r4,4
811235d0:	0015883a 	mov	r10,zero
811235d4:	000d883a 	mov	r6,zero
811235d8:	000f883a 	mov	r7,zero
811235dc:	03400044 	movi	r13,1
811235e0:	02ffffc4 	movi	r11,-1
811235e4:	da000117 	ldw	r8,4(sp)
811235e8:	48000d26 	beq	r9,zero,81123620 <_strtoll_r+0x148>
811235ec:	843ff404 	addi	r16,r16,-48
811235f0:	84c0110e 	bge	r16,r19,81123638 <_strtoll_r+0x160>
811235f4:	52c00426 	beq	r10,r11,81123608 <_strtoll_r+0x130>
811235f8:	19c00236 	bltu	r3,r7,81123604 <_strtoll_r+0x12c>
811235fc:	38c0311e 	bne	r7,r3,811236c4 <_strtoll_r+0x1ec>
81123600:	6180302e 	bgeu	r12,r6,811236c4 <_strtoll_r+0x1ec>
81123604:	02bfffc4 	movi	r10,-1
81123608:	2c000003 	ldbu	r16,0(r5)
8112360c:	29400044 	addi	r5,r5,1
81123610:	9409883a 	add	r4,r18,r16
81123614:	21000043 	ldbu	r4,1(r4)
81123618:	2240010c 	andi	r9,r4,4
8112361c:	483ff31e 	bne	r9,zero,811235ec <__reset+0xfb1035ec>
81123620:	210000cc 	andi	r4,r4,3
81123624:	20000426 	beq	r4,zero,81123638 <_strtoll_r+0x160>
81123628:	23403426 	beq	r4,r13,811236fc <_strtoll_r+0x224>
8112362c:	008015c4 	movi	r2,87
81123630:	80a1c83a 	sub	r16,r16,r2
81123634:	84ffef16 	blt	r16,r19,811235f4 <__reset+0xfb1035f4>
81123638:	00bfffc4 	movi	r2,-1
8112363c:	50803426 	beq	r10,r2,81123710 <_strtoll_r+0x238>
81123640:	e0000426 	beq	fp,zero,81123654 <_strtoll_r+0x17c>
81123644:	018dc83a 	sub	r6,zero,r6
81123648:	3004c03a 	cmpne	r2,r6,zero
8112364c:	01e1c83a 	sub	r16,zero,r7
81123650:	808fc83a 	sub	r7,r16,r2
81123654:	3005883a 	mov	r2,r6
81123658:	3807883a 	mov	r3,r7
8112365c:	a8000326 	beq	r21,zero,8112366c <_strtoll_r+0x194>
81123660:	5000321e 	bne	r10,zero,8112372c <_strtoll_r+0x254>
81123664:	b00b883a 	mov	r5,r22
81123668:	a9400015 	stw	r5,0(r21)
8112366c:	dfc00c17 	ldw	ra,48(sp)
81123670:	df000b17 	ldw	fp,44(sp)
81123674:	ddc00a17 	ldw	r23,40(sp)
81123678:	dd800917 	ldw	r22,36(sp)
8112367c:	dd400817 	ldw	r21,32(sp)
81123680:	dd000717 	ldw	r20,28(sp)
81123684:	dcc00617 	ldw	r19,24(sp)
81123688:	dc800517 	ldw	r18,20(sp)
8112368c:	dc400417 	ldw	r17,16(sp)
81123690:	dc000317 	ldw	r16,12(sp)
81123694:	dec00d04 	addi	sp,sp,52
81123698:	f800283a 	ret
8112369c:	00800c04 	movi	r2,48
811236a0:	80802c26 	beq	r16,r2,81123754 <_strtoll_r+0x27c>
811236a4:	05000284 	movi	r20,10
811236a8:	002f883a 	mov	r23,zero
811236ac:	a027883a 	mov	r19,r20
811236b0:	e03fb11e 	bne	fp,zero,81123578 <__reset+0xfb103578>
811236b4:	02a00034 	movhi	r10,32768
811236b8:	52bfffc4 	addi	r10,r10,-1
811236bc:	02ffffc4 	movi	r11,-1
811236c0:	003faf06 	br	81123580 <__reset+0xfb103580>
811236c4:	33000f26 	beq	r6,r12,81123704 <_strtoll_r+0x22c>
811236c8:	b985383a 	mul	r2,r23,r6
811236cc:	3d0f383a 	mul	r7,r7,r20
811236d0:	3508383a 	mulxuu	r4,r6,r20
811236d4:	350d383a 	mul	r6,r6,r20
811236d8:	8013d7fa 	srai	r9,r16,31
811236dc:	388f883a 	add	r7,r7,r2
811236e0:	818d883a 	add	r6,r16,r6
811236e4:	390f883a 	add	r7,r7,r4
811236e8:	3421803a 	cmpltu	r16,r6,r16
811236ec:	49cf883a 	add	r7,r9,r7
811236f0:	81cf883a 	add	r7,r16,r7
811236f4:	02800044 	movi	r10,1
811236f8:	003fc306 	br	81123608 <__reset+0xfb103608>
811236fc:	00800dc4 	movi	r2,55
81123700:	003fcb06 	br	81123630 <__reset+0xfb103630>
81123704:	38fff01e 	bne	r7,r3,811236c8 <__reset+0xfb1036c8>
81123708:	443fbe16 	blt	r8,r16,81123604 <__reset+0xfb103604>
8112370c:	003fee06 	br	811236c8 <__reset+0xfb1036c8>
81123710:	e0002426 	beq	fp,zero,811237a4 <_strtoll_r+0x2cc>
81123714:	0005883a 	mov	r2,zero
81123718:	00e00034 	movhi	r3,32768
8112371c:	d9800017 	ldw	r6,0(sp)
81123720:	01000884 	movi	r4,34
81123724:	31000015 	stw	r4,0(r6)
81123728:	a83fd026 	beq	r21,zero,8112366c <__reset+0xfb10366c>
8112372c:	297fffc4 	addi	r5,r5,-1
81123730:	003fcd06 	br	81123668 <__reset+0xfb103668>
81123734:	1c400084 	addi	r17,r3,2
81123738:	1c000043 	ldbu	r16,1(r3)
8112373c:	07000044 	movi	fp,1
81123740:	003f8706 	br	81123560 <__reset+0xfb103560>
81123744:	1c400084 	addi	r17,r3,2
81123748:	1c000043 	ldbu	r16,1(r3)
8112374c:	0039883a 	mov	fp,zero
81123750:	003f8306 	br	81123560 <__reset+0xfb103560>
81123754:	88800003 	ldbu	r2,0(r17)
81123758:	00c01604 	movi	r3,88
8112375c:	108037cc 	andi	r2,r2,223
81123760:	10c00a26 	beq	r2,r3,8112378c <_strtoll_r+0x2b4>
81123764:	05000204 	movi	r20,8
81123768:	002f883a 	mov	r23,zero
8112376c:	a027883a 	mov	r19,r20
81123770:	003f8006 	br	81123574 <__reset+0xfb103574>
81123774:	00800c04 	movi	r2,48
81123778:	80800e1e 	bne	r16,r2,811237b4 <_strtoll_r+0x2dc>
8112377c:	88800003 	ldbu	r2,0(r17)
81123780:	00c01604 	movi	r3,88
81123784:	108037cc 	andi	r2,r2,223
81123788:	10c00a1e 	bne	r2,r3,811237b4 <_strtoll_r+0x2dc>
8112378c:	05000404 	movi	r20,16
81123790:	8c000043 	ldbu	r16,1(r17)
81123794:	002f883a 	mov	r23,zero
81123798:	8c400084 	addi	r17,r17,2
8112379c:	a027883a 	mov	r19,r20
811237a0:	003f7406 	br	81123574 <__reset+0xfb103574>
811237a4:	00e00034 	movhi	r3,32768
811237a8:	18ffffc4 	addi	r3,r3,-1
811237ac:	5005883a 	mov	r2,r10
811237b0:	003fda06 	br	8112371c <__reset+0xfb10371c>
811237b4:	9829883a 	mov	r20,r19
811237b8:	002f883a 	mov	r23,zero
811237bc:	003f6d06 	br	81123574 <__reset+0xfb103574>

811237c0 <___svfprintf_internal_r>:
811237c0:	deffb704 	addi	sp,sp,-292
811237c4:	de00012e 	bgeu	sp,et,811237cc <___svfprintf_internal_r+0xc>
811237c8:	003b68fa 	trap	3
811237cc:	dfc04815 	stw	ra,288(sp)
811237d0:	ddc04615 	stw	r23,280(sp)
811237d4:	d9402c15 	stw	r5,176(sp)
811237d8:	d9003915 	stw	r4,228(sp)
811237dc:	302f883a 	mov	r23,r6
811237e0:	d9c02d15 	stw	r7,180(sp)
811237e4:	df004715 	stw	fp,284(sp)
811237e8:	dd804515 	stw	r22,276(sp)
811237ec:	dd404415 	stw	r21,272(sp)
811237f0:	dd004315 	stw	r20,268(sp)
811237f4:	dcc04215 	stw	r19,264(sp)
811237f8:	dc804115 	stw	r18,260(sp)
811237fc:	dc404015 	stw	r17,256(sp)
81123800:	dc003f15 	stw	r16,252(sp)
81123804:	112c6a80 	call	8112c6a8 <_localeconv_r>
81123808:	10800017 	ldw	r2,0(r2)
8112380c:	1009883a 	mov	r4,r2
81123810:	d8803415 	stw	r2,208(sp)
81123814:	11231840 	call	81123184 <strlen>
81123818:	d8c02c17 	ldw	r3,176(sp)
8112381c:	d8803815 	stw	r2,224(sp)
81123820:	1880030b 	ldhu	r2,12(r3)
81123824:	1080200c 	andi	r2,r2,128
81123828:	10000226 	beq	r2,zero,81123834 <___svfprintf_internal_r+0x74>
8112382c:	18800417 	ldw	r2,16(r3)
81123830:	10067f26 	beq	r2,zero,81125230 <___svfprintf_internal_r+0x1a70>
81123834:	dcc03917 	ldw	r19,228(sp)
81123838:	d8c00404 	addi	r3,sp,16
8112383c:	05604574 	movhi	r21,33045
81123840:	d9001e04 	addi	r4,sp,120
81123844:	ad434784 	addi	r21,r21,3358
81123848:	d8c01e15 	stw	r3,120(sp)
8112384c:	d8002015 	stw	zero,128(sp)
81123850:	d8001f15 	stw	zero,124(sp)
81123854:	d8003315 	stw	zero,204(sp)
81123858:	d8003615 	stw	zero,216(sp)
8112385c:	d8003715 	stw	zero,220(sp)
81123860:	1811883a 	mov	r8,r3
81123864:	d8003a15 	stw	zero,232(sp)
81123868:	d8003b15 	stw	zero,236(sp)
8112386c:	d8002f15 	stw	zero,188(sp)
81123870:	d9002815 	stw	r4,160(sp)
81123874:	b8800007 	ldb	r2,0(r23)
81123878:	10026726 	beq	r2,zero,81124218 <___svfprintf_internal_r+0xa58>
8112387c:	00c00944 	movi	r3,37
81123880:	b821883a 	mov	r16,r23
81123884:	10c0021e 	bne	r2,r3,81123890 <___svfprintf_internal_r+0xd0>
81123888:	00001406 	br	811238dc <___svfprintf_internal_r+0x11c>
8112388c:	10c00326 	beq	r2,r3,8112389c <___svfprintf_internal_r+0xdc>
81123890:	84000044 	addi	r16,r16,1
81123894:	80800007 	ldb	r2,0(r16)
81123898:	103ffc1e 	bne	r2,zero,8112388c <__reset+0xfb10388c>
8112389c:	85e3c83a 	sub	r17,r16,r23
811238a0:	88000e26 	beq	r17,zero,811238dc <___svfprintf_internal_r+0x11c>
811238a4:	d8c02017 	ldw	r3,128(sp)
811238a8:	d8801f17 	ldw	r2,124(sp)
811238ac:	45c00015 	stw	r23,0(r8)
811238b0:	1c47883a 	add	r3,r3,r17
811238b4:	10800044 	addi	r2,r2,1
811238b8:	d8c02015 	stw	r3,128(sp)
811238bc:	44400115 	stw	r17,4(r8)
811238c0:	d8801f15 	stw	r2,124(sp)
811238c4:	00c001c4 	movi	r3,7
811238c8:	18809716 	blt	r3,r2,81123b28 <___svfprintf_internal_r+0x368>
811238cc:	42000204 	addi	r8,r8,8
811238d0:	d9402f17 	ldw	r5,188(sp)
811238d4:	2c4b883a 	add	r5,r5,r17
811238d8:	d9402f15 	stw	r5,188(sp)
811238dc:	80800007 	ldb	r2,0(r16)
811238e0:	10009826 	beq	r2,zero,81123b44 <___svfprintf_internal_r+0x384>
811238e4:	84400047 	ldb	r17,1(r16)
811238e8:	00bfffc4 	movi	r2,-1
811238ec:	85c00044 	addi	r23,r16,1
811238f0:	d8002785 	stb	zero,158(sp)
811238f4:	0007883a 	mov	r3,zero
811238f8:	000f883a 	mov	r7,zero
811238fc:	d8802915 	stw	r2,164(sp)
81123900:	d8003115 	stw	zero,196(sp)
81123904:	0025883a 	mov	r18,zero
81123908:	01401604 	movi	r5,88
8112390c:	01800244 	movi	r6,9
81123910:	02800a84 	movi	r10,42
81123914:	02401b04 	movi	r9,108
81123918:	bdc00044 	addi	r23,r23,1
8112391c:	88bff804 	addi	r2,r17,-32
81123920:	2882f036 	bltu	r5,r2,811244e4 <___svfprintf_internal_r+0xd24>
81123924:	100490ba 	slli	r2,r2,2
81123928:	012044b4 	movhi	r4,33042
8112392c:	210e4f04 	addi	r4,r4,14652
81123930:	1105883a 	add	r2,r2,r4
81123934:	10800017 	ldw	r2,0(r2)
81123938:	1000683a 	jmp	r2
8112393c:	8112444c 	andi	r4,r16,18705
81123940:	811244e4 	muli	r4,r16,18707
81123944:	811244e4 	muli	r4,r16,18707
81123948:	81124440 	call	88112444 <__reset+0x20f2444>
8112394c:	811244e4 	muli	r4,r16,18707
81123950:	811244e4 	muli	r4,r16,18707
81123954:	811244e4 	muli	r4,r16,18707
81123958:	811244e4 	muli	r4,r16,18707
8112395c:	811244e4 	muli	r4,r16,18707
81123960:	811244e4 	muli	r4,r16,18707
81123964:	81123ba0 	cmpeqi	r4,r16,18670
81123968:	8112437c 	xorhi	r4,r16,18701
8112396c:	811244e4 	muli	r4,r16,18707
81123970:	81123ab0 	cmpltui	r4,r16,18666
81123974:	81123bc8 	cmpgei	r4,r16,18671
81123978:	811244e4 	muli	r4,r16,18707
8112397c:	81123c3c 	xorhi	r4,r16,18672
81123980:	81123c08 	cmpgei	r4,r16,18672
81123984:	81123c08 	cmpgei	r4,r16,18672
81123988:	81123c08 	cmpgei	r4,r16,18672
8112398c:	81123c08 	cmpgei	r4,r16,18672
81123990:	81123c08 	cmpgei	r4,r16,18672
81123994:	81123c08 	cmpgei	r4,r16,18672
81123998:	81123c08 	cmpgei	r4,r16,18672
8112399c:	81123c08 	cmpgei	r4,r16,18672
811239a0:	81123c08 	cmpgei	r4,r16,18672
811239a4:	811244e4 	muli	r4,r16,18707
811239a8:	811244e4 	muli	r4,r16,18707
811239ac:	811244e4 	muli	r4,r16,18707
811239b0:	811244e4 	muli	r4,r16,18707
811239b4:	811244e4 	muli	r4,r16,18707
811239b8:	811244e4 	muli	r4,r16,18707
811239bc:	811244e4 	muli	r4,r16,18707
811239c0:	811244e4 	muli	r4,r16,18707
811239c4:	811244e4 	muli	r4,r16,18707
811239c8:	811244e4 	muli	r4,r16,18707
811239cc:	81123cf4 	orhi	r4,r16,18675
811239d0:	81123c48 	cmpgei	r4,r16,18673
811239d4:	811244e4 	muli	r4,r16,18707
811239d8:	81123c48 	cmpgei	r4,r16,18673
811239dc:	811244e4 	muli	r4,r16,18707
811239e0:	811244e4 	muli	r4,r16,18707
811239e4:	811244e4 	muli	r4,r16,18707
811239e8:	811244e4 	muli	r4,r16,18707
811239ec:	81123ce8 	cmpgeui	r4,r16,18675
811239f0:	811244e4 	muli	r4,r16,18707
811239f4:	811244e4 	muli	r4,r16,18707
811239f8:	81123db0 	cmpltui	r4,r16,18678
811239fc:	811244e4 	muli	r4,r16,18707
81123a00:	811244e4 	muli	r4,r16,18707
81123a04:	811244e4 	muli	r4,r16,18707
81123a08:	811244e4 	muli	r4,r16,18707
81123a0c:	811244e4 	muli	r4,r16,18707
81123a10:	81124220 	cmpeqi	r4,r16,18696
81123a14:	811244e4 	muli	r4,r16,18707
81123a18:	811244e4 	muli	r4,r16,18707
81123a1c:	81124280 	call	88112428 <__reset+0x20f2428>
81123a20:	811244e4 	muli	r4,r16,18707
81123a24:	811244e4 	muli	r4,r16,18707
81123a28:	811244e4 	muli	r4,r16,18707
81123a2c:	811244e4 	muli	r4,r16,18707
81123a30:	811244e4 	muli	r4,r16,18707
81123a34:	811244e4 	muli	r4,r16,18707
81123a38:	811244e4 	muli	r4,r16,18707
81123a3c:	811244e4 	muli	r4,r16,18707
81123a40:	811244e4 	muli	r4,r16,18707
81123a44:	811244e4 	muli	r4,r16,18707
81123a48:	81124330 	cmpltui	r4,r16,18700
81123a4c:	8112446c 	andhi	r4,r16,18705
81123a50:	81123c48 	cmpgei	r4,r16,18673
81123a54:	81123c48 	cmpgei	r4,r16,18673
81123a58:	81123c48 	cmpgei	r4,r16,18673
81123a5c:	811244c0 	call	8811244c <__reset+0x20f244c>
81123a60:	8112446c 	andhi	r4,r16,18705
81123a64:	811244e4 	muli	r4,r16,18707
81123a68:	811244e4 	muli	r4,r16,18707
81123a6c:	8112447c 	xorhi	r4,r16,18705
81123a70:	811244e4 	muli	r4,r16,18707
81123a74:	8112448c 	andi	r4,r16,18706
81123a78:	8112436c 	andhi	r4,r16,18701
81123a7c:	81123abc 	xorhi	r4,r16,18666
81123a80:	8112438c 	andi	r4,r16,18702
81123a84:	811244e4 	muli	r4,r16,18707
81123a88:	81124398 	cmpnei	r4,r16,18702
81123a8c:	811244e4 	muli	r4,r16,18707
81123a90:	811243f4 	orhi	r4,r16,18703
81123a94:	811244e4 	muli	r4,r16,18707
81123a98:	811244e4 	muli	r4,r16,18707
81123a9c:	81124404 	addi	r4,r16,18704
81123aa0:	d9003117 	ldw	r4,196(sp)
81123aa4:	d8802d15 	stw	r2,180(sp)
81123aa8:	0109c83a 	sub	r4,zero,r4
81123aac:	d9003115 	stw	r4,196(sp)
81123ab0:	94800114 	ori	r18,r18,4
81123ab4:	bc400007 	ldb	r17,0(r23)
81123ab8:	003f9706 	br	81123918 <__reset+0xfb103918>
81123abc:	00800c04 	movi	r2,48
81123ac0:	d9002d17 	ldw	r4,180(sp)
81123ac4:	d9402917 	ldw	r5,164(sp)
81123ac8:	d8802705 	stb	r2,156(sp)
81123acc:	00801e04 	movi	r2,120
81123ad0:	d8802745 	stb	r2,157(sp)
81123ad4:	d8002785 	stb	zero,158(sp)
81123ad8:	20c00104 	addi	r3,r4,4
81123adc:	25000017 	ldw	r20,0(r4)
81123ae0:	002d883a 	mov	r22,zero
81123ae4:	90800094 	ori	r2,r18,2
81123ae8:	28028616 	blt	r5,zero,81124504 <___svfprintf_internal_r+0xd44>
81123aec:	00bfdfc4 	movi	r2,-129
81123af0:	90a4703a 	and	r18,r18,r2
81123af4:	d8c02d15 	stw	r3,180(sp)
81123af8:	94800094 	ori	r18,r18,2
81123afc:	a002731e 	bne	r20,zero,811244cc <___svfprintf_internal_r+0xd0c>
81123b00:	00a04574 	movhi	r2,33045
81123b04:	10834004 	addi	r2,r2,3328
81123b08:	d8803a15 	stw	r2,232(sp)
81123b0c:	04401e04 	movi	r17,120
81123b10:	d8c02917 	ldw	r3,164(sp)
81123b14:	0039883a 	mov	fp,zero
81123b18:	1801d526 	beq	r3,zero,81124270 <___svfprintf_internal_r+0xab0>
81123b1c:	0029883a 	mov	r20,zero
81123b20:	002d883a 	mov	r22,zero
81123b24:	0001f106 	br	811242ec <___svfprintf_internal_r+0xb2c>
81123b28:	d9402c17 	ldw	r5,176(sp)
81123b2c:	d9801e04 	addi	r6,sp,120
81123b30:	9809883a 	mov	r4,r19
81123b34:	11300f80 	call	811300f8 <__ssprint_r>
81123b38:	1000081e 	bne	r2,zero,81123b5c <___svfprintf_internal_r+0x39c>
81123b3c:	da000404 	addi	r8,sp,16
81123b40:	003f6306 	br	811238d0 <__reset+0xfb1038d0>
81123b44:	d8802017 	ldw	r2,128(sp)
81123b48:	10000426 	beq	r2,zero,81123b5c <___svfprintf_internal_r+0x39c>
81123b4c:	d9402c17 	ldw	r5,176(sp)
81123b50:	d9003917 	ldw	r4,228(sp)
81123b54:	d9801e04 	addi	r6,sp,120
81123b58:	11300f80 	call	811300f8 <__ssprint_r>
81123b5c:	d8802c17 	ldw	r2,176(sp)
81123b60:	10c0030b 	ldhu	r3,12(r2)
81123b64:	d8802f17 	ldw	r2,188(sp)
81123b68:	18c0100c 	andi	r3,r3,64
81123b6c:	1805f51e 	bne	r3,zero,81125344 <___svfprintf_internal_r+0x1b84>
81123b70:	dfc04817 	ldw	ra,288(sp)
81123b74:	df004717 	ldw	fp,284(sp)
81123b78:	ddc04617 	ldw	r23,280(sp)
81123b7c:	dd804517 	ldw	r22,276(sp)
81123b80:	dd404417 	ldw	r21,272(sp)
81123b84:	dd004317 	ldw	r20,268(sp)
81123b88:	dcc04217 	ldw	r19,264(sp)
81123b8c:	dc804117 	ldw	r18,260(sp)
81123b90:	dc404017 	ldw	r17,256(sp)
81123b94:	dc003f17 	ldw	r16,252(sp)
81123b98:	dec04904 	addi	sp,sp,292
81123b9c:	f800283a 	ret
81123ba0:	d8802d17 	ldw	r2,180(sp)
81123ba4:	d9002d17 	ldw	r4,180(sp)
81123ba8:	10800017 	ldw	r2,0(r2)
81123bac:	d8803115 	stw	r2,196(sp)
81123bb0:	20800104 	addi	r2,r4,4
81123bb4:	d9003117 	ldw	r4,196(sp)
81123bb8:	203fb916 	blt	r4,zero,81123aa0 <__reset+0xfb103aa0>
81123bbc:	d8802d15 	stw	r2,180(sp)
81123bc0:	bc400007 	ldb	r17,0(r23)
81123bc4:	003f5406 	br	81123918 <__reset+0xfb103918>
81123bc8:	bc400007 	ldb	r17,0(r23)
81123bcc:	bac00044 	addi	r11,r23,1
81123bd0:	8a873926 	beq	r17,r10,811258b8 <___svfprintf_internal_r+0x20f8>
81123bd4:	88bff404 	addi	r2,r17,-48
81123bd8:	0009883a 	mov	r4,zero
81123bdc:	30868836 	bltu	r6,r2,81125600 <___svfprintf_internal_r+0x1e40>
81123be0:	5c400007 	ldb	r17,0(r11)
81123be4:	210002a4 	muli	r4,r4,10
81123be8:	5dc00044 	addi	r23,r11,1
81123bec:	b817883a 	mov	r11,r23
81123bf0:	2089883a 	add	r4,r4,r2
81123bf4:	88bff404 	addi	r2,r17,-48
81123bf8:	30bff92e 	bgeu	r6,r2,81123be0 <__reset+0xfb103be0>
81123bfc:	2005d716 	blt	r4,zero,8112535c <___svfprintf_internal_r+0x1b9c>
81123c00:	d9002915 	stw	r4,164(sp)
81123c04:	003f4506 	br	8112391c <__reset+0xfb10391c>
81123c08:	b809883a 	mov	r4,r23
81123c0c:	d8003115 	stw	zero,196(sp)
81123c10:	88bff404 	addi	r2,r17,-48
81123c14:	0017883a 	mov	r11,zero
81123c18:	24400007 	ldb	r17,0(r4)
81123c1c:	5ac002a4 	muli	r11,r11,10
81123c20:	bdc00044 	addi	r23,r23,1
81123c24:	b809883a 	mov	r4,r23
81123c28:	12d7883a 	add	r11,r2,r11
81123c2c:	88bff404 	addi	r2,r17,-48
81123c30:	30bff92e 	bgeu	r6,r2,81123c18 <__reset+0xfb103c18>
81123c34:	dac03115 	stw	r11,196(sp)
81123c38:	003f3806 	br	8112391c <__reset+0xfb10391c>
81123c3c:	94802014 	ori	r18,r18,128
81123c40:	bc400007 	ldb	r17,0(r23)
81123c44:	003f3406 	br	81123918 <__reset+0xfb103918>
81123c48:	18c03fcc 	andi	r3,r3,255
81123c4c:	1807471e 	bne	r3,zero,8112596c <___svfprintf_internal_r+0x21ac>
81123c50:	9080020c 	andi	r2,r18,8
81123c54:	10047d26 	beq	r2,zero,81124e4c <___svfprintf_internal_r+0x168c>
81123c58:	d8c02d17 	ldw	r3,180(sp)
81123c5c:	d9002d17 	ldw	r4,180(sp)
81123c60:	d9402d17 	ldw	r5,180(sp)
81123c64:	18c00017 	ldw	r3,0(r3)
81123c68:	21000117 	ldw	r4,4(r4)
81123c6c:	29400204 	addi	r5,r5,8
81123c70:	d8c03615 	stw	r3,216(sp)
81123c74:	d9003715 	stw	r4,220(sp)
81123c78:	d9402d15 	stw	r5,180(sp)
81123c7c:	d9003617 	ldw	r4,216(sp)
81123c80:	d9403717 	ldw	r5,220(sp)
81123c84:	da003e15 	stw	r8,248(sp)
81123c88:	04000044 	movi	r16,1
81123c8c:	112e1f40 	call	8112e1f4 <__fpclassifyd>
81123c90:	da003e17 	ldw	r8,248(sp)
81123c94:	14044b1e 	bne	r2,r16,81124dc4 <___svfprintf_internal_r+0x1604>
81123c98:	d9003617 	ldw	r4,216(sp)
81123c9c:	d9403717 	ldw	r5,220(sp)
81123ca0:	000d883a 	mov	r6,zero
81123ca4:	000f883a 	mov	r7,zero
81123ca8:	11360fc0 	call	811360fc <__ledf2>
81123cac:	da003e17 	ldw	r8,248(sp)
81123cb0:	1005f316 	blt	r2,zero,81125480 <___svfprintf_internal_r+0x1cc0>
81123cb4:	df002783 	ldbu	fp,158(sp)
81123cb8:	008011c4 	movi	r2,71
81123cbc:	1445590e 	bge	r2,r17,81125224 <___svfprintf_internal_r+0x1a64>
81123cc0:	04204574 	movhi	r16,33045
81123cc4:	84033804 	addi	r16,r16,3296
81123cc8:	00c000c4 	movi	r3,3
81123ccc:	00bfdfc4 	movi	r2,-129
81123cd0:	d8c02a15 	stw	r3,168(sp)
81123cd4:	90a4703a 	and	r18,r18,r2
81123cd8:	d8c02e15 	stw	r3,184(sp)
81123cdc:	d8002915 	stw	zero,164(sp)
81123ce0:	d8003215 	stw	zero,200(sp)
81123ce4:	00006606 	br	81123e80 <___svfprintf_internal_r+0x6c0>
81123ce8:	94800214 	ori	r18,r18,8
81123cec:	bc400007 	ldb	r17,0(r23)
81123cf0:	003f0906 	br	81123918 <__reset+0xfb103918>
81123cf4:	18c03fcc 	andi	r3,r3,255
81123cf8:	1807181e 	bne	r3,zero,8112595c <___svfprintf_internal_r+0x219c>
81123cfc:	94800414 	ori	r18,r18,16
81123d00:	9080080c 	andi	r2,r18,32
81123d04:	10039626 	beq	r2,zero,81124b60 <___svfprintf_internal_r+0x13a0>
81123d08:	d9402d17 	ldw	r5,180(sp)
81123d0c:	28800117 	ldw	r2,4(r5)
81123d10:	2d000017 	ldw	r20,0(r5)
81123d14:	29400204 	addi	r5,r5,8
81123d18:	d9402d15 	stw	r5,180(sp)
81123d1c:	102d883a 	mov	r22,r2
81123d20:	10039816 	blt	r2,zero,81124b84 <___svfprintf_internal_r+0x13c4>
81123d24:	d9402917 	ldw	r5,164(sp)
81123d28:	df002783 	ldbu	fp,158(sp)
81123d2c:	2803ab16 	blt	r5,zero,81124bdc <___svfprintf_internal_r+0x141c>
81123d30:	00ffdfc4 	movi	r3,-129
81123d34:	a584b03a 	or	r2,r20,r22
81123d38:	90e4703a 	and	r18,r18,r3
81123d3c:	10014a26 	beq	r2,zero,81124268 <___svfprintf_internal_r+0xaa8>
81123d40:	b0034b26 	beq	r22,zero,81124a70 <___svfprintf_internal_r+0x12b0>
81123d44:	dc402a15 	stw	r17,168(sp)
81123d48:	dc001e04 	addi	r16,sp,120
81123d4c:	b023883a 	mov	r17,r22
81123d50:	402d883a 	mov	r22,r8
81123d54:	a009883a 	mov	r4,r20
81123d58:	880b883a 	mov	r5,r17
81123d5c:	01800284 	movi	r6,10
81123d60:	000f883a 	mov	r7,zero
81123d64:	11345e00 	call	811345e0 <__umoddi3>
81123d68:	10800c04 	addi	r2,r2,48
81123d6c:	843fffc4 	addi	r16,r16,-1
81123d70:	a009883a 	mov	r4,r20
81123d74:	880b883a 	mov	r5,r17
81123d78:	80800005 	stb	r2,0(r16)
81123d7c:	01800284 	movi	r6,10
81123d80:	000f883a 	mov	r7,zero
81123d84:	11340600 	call	81134060 <__udivdi3>
81123d88:	1029883a 	mov	r20,r2
81123d8c:	10c4b03a 	or	r2,r2,r3
81123d90:	1823883a 	mov	r17,r3
81123d94:	103fef1e 	bne	r2,zero,81123d54 <__reset+0xfb103d54>
81123d98:	d8c02817 	ldw	r3,160(sp)
81123d9c:	dc402a17 	ldw	r17,168(sp)
81123da0:	b011883a 	mov	r8,r22
81123da4:	1c07c83a 	sub	r3,r3,r16
81123da8:	d8c02e15 	stw	r3,184(sp)
81123dac:	00002e06 	br	81123e68 <___svfprintf_internal_r+0x6a8>
81123db0:	18c03fcc 	andi	r3,r3,255
81123db4:	1806e71e 	bne	r3,zero,81125954 <___svfprintf_internal_r+0x2194>
81123db8:	94800414 	ori	r18,r18,16
81123dbc:	9080080c 	andi	r2,r18,32
81123dc0:	1002d426 	beq	r2,zero,81124914 <___svfprintf_internal_r+0x1154>
81123dc4:	d9402d17 	ldw	r5,180(sp)
81123dc8:	d8c02917 	ldw	r3,164(sp)
81123dcc:	d8002785 	stb	zero,158(sp)
81123dd0:	28800204 	addi	r2,r5,8
81123dd4:	2d000017 	ldw	r20,0(r5)
81123dd8:	2d800117 	ldw	r22,4(r5)
81123ddc:	18041516 	blt	r3,zero,81124e34 <___svfprintf_internal_r+0x1674>
81123de0:	013fdfc4 	movi	r4,-129
81123de4:	a586b03a 	or	r3,r20,r22
81123de8:	d8802d15 	stw	r2,180(sp)
81123dec:	9124703a 	and	r18,r18,r4
81123df0:	1802d51e 	bne	r3,zero,81124948 <___svfprintf_internal_r+0x1188>
81123df4:	d9402917 	ldw	r5,164(sp)
81123df8:	0039883a 	mov	fp,zero
81123dfc:	2806be26 	beq	r5,zero,811258f8 <___svfprintf_internal_r+0x2138>
81123e00:	0029883a 	mov	r20,zero
81123e04:	002d883a 	mov	r22,zero
81123e08:	dc001e04 	addi	r16,sp,120
81123e0c:	a006d0fa 	srli	r3,r20,3
81123e10:	b008977a 	slli	r4,r22,29
81123e14:	b02cd0fa 	srli	r22,r22,3
81123e18:	a50001cc 	andi	r20,r20,7
81123e1c:	a0800c04 	addi	r2,r20,48
81123e20:	843fffc4 	addi	r16,r16,-1
81123e24:	20e8b03a 	or	r20,r4,r3
81123e28:	80800005 	stb	r2,0(r16)
81123e2c:	a586b03a 	or	r3,r20,r22
81123e30:	183ff61e 	bne	r3,zero,81123e0c <__reset+0xfb103e0c>
81123e34:	90c0004c 	andi	r3,r18,1
81123e38:	18013926 	beq	r3,zero,81124320 <___svfprintf_internal_r+0xb60>
81123e3c:	10803fcc 	andi	r2,r2,255
81123e40:	1080201c 	xori	r2,r2,128
81123e44:	10bfe004 	addi	r2,r2,-128
81123e48:	00c00c04 	movi	r3,48
81123e4c:	10c13426 	beq	r2,r3,81124320 <___svfprintf_internal_r+0xb60>
81123e50:	80ffffc5 	stb	r3,-1(r16)
81123e54:	d8c02817 	ldw	r3,160(sp)
81123e58:	80bfffc4 	addi	r2,r16,-1
81123e5c:	1021883a 	mov	r16,r2
81123e60:	1887c83a 	sub	r3,r3,r2
81123e64:	d8c02e15 	stw	r3,184(sp)
81123e68:	d8802e17 	ldw	r2,184(sp)
81123e6c:	d9002917 	ldw	r4,164(sp)
81123e70:	1100010e 	bge	r2,r4,81123e78 <___svfprintf_internal_r+0x6b8>
81123e74:	2005883a 	mov	r2,r4
81123e78:	d8802a15 	stw	r2,168(sp)
81123e7c:	d8003215 	stw	zero,200(sp)
81123e80:	e7003fcc 	andi	fp,fp,255
81123e84:	e700201c 	xori	fp,fp,128
81123e88:	e73fe004 	addi	fp,fp,-128
81123e8c:	e0000326 	beq	fp,zero,81123e9c <___svfprintf_internal_r+0x6dc>
81123e90:	d8c02a17 	ldw	r3,168(sp)
81123e94:	18c00044 	addi	r3,r3,1
81123e98:	d8c02a15 	stw	r3,168(sp)
81123e9c:	90c0008c 	andi	r3,r18,2
81123ea0:	d8c02b15 	stw	r3,172(sp)
81123ea4:	18000326 	beq	r3,zero,81123eb4 <___svfprintf_internal_r+0x6f4>
81123ea8:	d8c02a17 	ldw	r3,168(sp)
81123eac:	18c00084 	addi	r3,r3,2
81123eb0:	d8c02a15 	stw	r3,168(sp)
81123eb4:	90c0210c 	andi	r3,r18,132
81123eb8:	d8c03015 	stw	r3,192(sp)
81123ebc:	1801a11e 	bne	r3,zero,81124544 <___svfprintf_internal_r+0xd84>
81123ec0:	d9003117 	ldw	r4,196(sp)
81123ec4:	d8c02a17 	ldw	r3,168(sp)
81123ec8:	20e9c83a 	sub	r20,r4,r3
81123ecc:	05019d0e 	bge	zero,r20,81124544 <___svfprintf_internal_r+0xd84>
81123ed0:	02400404 	movi	r9,16
81123ed4:	d8c02017 	ldw	r3,128(sp)
81123ed8:	d8801f17 	ldw	r2,124(sp)
81123edc:	4d051b0e 	bge	r9,r20,8112534c <___svfprintf_internal_r+0x1b8c>
81123ee0:	01604574 	movhi	r5,33045
81123ee4:	29434b84 	addi	r5,r5,3374
81123ee8:	dc403c15 	stw	r17,240(sp)
81123eec:	d9403515 	stw	r5,212(sp)
81123ef0:	a023883a 	mov	r17,r20
81123ef4:	482d883a 	mov	r22,r9
81123ef8:	9029883a 	mov	r20,r18
81123efc:	070001c4 	movi	fp,7
81123f00:	8025883a 	mov	r18,r16
81123f04:	dc002c17 	ldw	r16,176(sp)
81123f08:	00000306 	br	81123f18 <___svfprintf_internal_r+0x758>
81123f0c:	8c7ffc04 	addi	r17,r17,-16
81123f10:	42000204 	addi	r8,r8,8
81123f14:	b440130e 	bge	r22,r17,81123f64 <___svfprintf_internal_r+0x7a4>
81123f18:	01204574 	movhi	r4,33045
81123f1c:	18c00404 	addi	r3,r3,16
81123f20:	10800044 	addi	r2,r2,1
81123f24:	21034b84 	addi	r4,r4,3374
81123f28:	41000015 	stw	r4,0(r8)
81123f2c:	45800115 	stw	r22,4(r8)
81123f30:	d8c02015 	stw	r3,128(sp)
81123f34:	d8801f15 	stw	r2,124(sp)
81123f38:	e0bff40e 	bge	fp,r2,81123f0c <__reset+0xfb103f0c>
81123f3c:	d9801e04 	addi	r6,sp,120
81123f40:	800b883a 	mov	r5,r16
81123f44:	9809883a 	mov	r4,r19
81123f48:	11300f80 	call	811300f8 <__ssprint_r>
81123f4c:	103f031e 	bne	r2,zero,81123b5c <__reset+0xfb103b5c>
81123f50:	8c7ffc04 	addi	r17,r17,-16
81123f54:	d8c02017 	ldw	r3,128(sp)
81123f58:	d8801f17 	ldw	r2,124(sp)
81123f5c:	da000404 	addi	r8,sp,16
81123f60:	b47fed16 	blt	r22,r17,81123f18 <__reset+0xfb103f18>
81123f64:	9021883a 	mov	r16,r18
81123f68:	a025883a 	mov	r18,r20
81123f6c:	8829883a 	mov	r20,r17
81123f70:	dc403c17 	ldw	r17,240(sp)
81123f74:	d9403517 	ldw	r5,212(sp)
81123f78:	a0c7883a 	add	r3,r20,r3
81123f7c:	10800044 	addi	r2,r2,1
81123f80:	41400015 	stw	r5,0(r8)
81123f84:	45000115 	stw	r20,4(r8)
81123f88:	d8c02015 	stw	r3,128(sp)
81123f8c:	d8801f15 	stw	r2,124(sp)
81123f90:	010001c4 	movi	r4,7
81123f94:	20829f16 	blt	r4,r2,81124a14 <___svfprintf_internal_r+0x1254>
81123f98:	df002787 	ldb	fp,158(sp)
81123f9c:	42000204 	addi	r8,r8,8
81123fa0:	e0000c26 	beq	fp,zero,81123fd4 <___svfprintf_internal_r+0x814>
81123fa4:	d8801f17 	ldw	r2,124(sp)
81123fa8:	d9002784 	addi	r4,sp,158
81123fac:	18c00044 	addi	r3,r3,1
81123fb0:	10800044 	addi	r2,r2,1
81123fb4:	41000015 	stw	r4,0(r8)
81123fb8:	01000044 	movi	r4,1
81123fbc:	41000115 	stw	r4,4(r8)
81123fc0:	d8c02015 	stw	r3,128(sp)
81123fc4:	d8801f15 	stw	r2,124(sp)
81123fc8:	010001c4 	movi	r4,7
81123fcc:	20823816 	blt	r4,r2,811248b0 <___svfprintf_internal_r+0x10f0>
81123fd0:	42000204 	addi	r8,r8,8
81123fd4:	d8802b17 	ldw	r2,172(sp)
81123fd8:	10000c26 	beq	r2,zero,8112400c <___svfprintf_internal_r+0x84c>
81123fdc:	d8801f17 	ldw	r2,124(sp)
81123fe0:	d9002704 	addi	r4,sp,156
81123fe4:	18c00084 	addi	r3,r3,2
81123fe8:	10800044 	addi	r2,r2,1
81123fec:	41000015 	stw	r4,0(r8)
81123ff0:	01000084 	movi	r4,2
81123ff4:	41000115 	stw	r4,4(r8)
81123ff8:	d8c02015 	stw	r3,128(sp)
81123ffc:	d8801f15 	stw	r2,124(sp)
81124000:	010001c4 	movi	r4,7
81124004:	20823216 	blt	r4,r2,811248d0 <___svfprintf_internal_r+0x1110>
81124008:	42000204 	addi	r8,r8,8
8112400c:	d9003017 	ldw	r4,192(sp)
81124010:	00802004 	movi	r2,128
81124014:	20819726 	beq	r4,r2,81124674 <___svfprintf_internal_r+0xeb4>
81124018:	d9402917 	ldw	r5,164(sp)
8112401c:	d8802e17 	ldw	r2,184(sp)
81124020:	28adc83a 	sub	r22,r5,r2
81124024:	05802f0e 	bge	zero,r22,811240e4 <___svfprintf_internal_r+0x924>
81124028:	07000404 	movi	fp,16
8112402c:	d8801f17 	ldw	r2,124(sp)
81124030:	e583c00e 	bge	fp,r22,81124f34 <___svfprintf_internal_r+0x1774>
81124034:	01604574 	movhi	r5,33045
81124038:	29434784 	addi	r5,r5,3358
8112403c:	dc402915 	stw	r17,164(sp)
81124040:	d9402b15 	stw	r5,172(sp)
81124044:	b023883a 	mov	r17,r22
81124048:	050001c4 	movi	r20,7
8112404c:	902d883a 	mov	r22,r18
81124050:	8025883a 	mov	r18,r16
81124054:	dc002c17 	ldw	r16,176(sp)
81124058:	00000306 	br	81124068 <___svfprintf_internal_r+0x8a8>
8112405c:	8c7ffc04 	addi	r17,r17,-16
81124060:	42000204 	addi	r8,r8,8
81124064:	e440110e 	bge	fp,r17,811240ac <___svfprintf_internal_r+0x8ec>
81124068:	18c00404 	addi	r3,r3,16
8112406c:	10800044 	addi	r2,r2,1
81124070:	45400015 	stw	r21,0(r8)
81124074:	47000115 	stw	fp,4(r8)
81124078:	d8c02015 	stw	r3,128(sp)
8112407c:	d8801f15 	stw	r2,124(sp)
81124080:	a0bff60e 	bge	r20,r2,8112405c <__reset+0xfb10405c>
81124084:	d9801e04 	addi	r6,sp,120
81124088:	800b883a 	mov	r5,r16
8112408c:	9809883a 	mov	r4,r19
81124090:	11300f80 	call	811300f8 <__ssprint_r>
81124094:	103eb11e 	bne	r2,zero,81123b5c <__reset+0xfb103b5c>
81124098:	8c7ffc04 	addi	r17,r17,-16
8112409c:	d8c02017 	ldw	r3,128(sp)
811240a0:	d8801f17 	ldw	r2,124(sp)
811240a4:	da000404 	addi	r8,sp,16
811240a8:	e47fef16 	blt	fp,r17,81124068 <__reset+0xfb104068>
811240ac:	9021883a 	mov	r16,r18
811240b0:	b025883a 	mov	r18,r22
811240b4:	882d883a 	mov	r22,r17
811240b8:	dc402917 	ldw	r17,164(sp)
811240bc:	d9002b17 	ldw	r4,172(sp)
811240c0:	1d87883a 	add	r3,r3,r22
811240c4:	10800044 	addi	r2,r2,1
811240c8:	41000015 	stw	r4,0(r8)
811240cc:	45800115 	stw	r22,4(r8)
811240d0:	d8c02015 	stw	r3,128(sp)
811240d4:	d8801f15 	stw	r2,124(sp)
811240d8:	010001c4 	movi	r4,7
811240dc:	2081ec16 	blt	r4,r2,81124890 <___svfprintf_internal_r+0x10d0>
811240e0:	42000204 	addi	r8,r8,8
811240e4:	9080400c 	andi	r2,r18,256
811240e8:	1001181e 	bne	r2,zero,8112454c <___svfprintf_internal_r+0xd8c>
811240ec:	d9402e17 	ldw	r5,184(sp)
811240f0:	d8801f17 	ldw	r2,124(sp)
811240f4:	44000015 	stw	r16,0(r8)
811240f8:	1947883a 	add	r3,r3,r5
811240fc:	10800044 	addi	r2,r2,1
81124100:	41400115 	stw	r5,4(r8)
81124104:	d8c02015 	stw	r3,128(sp)
81124108:	d8801f15 	stw	r2,124(sp)
8112410c:	010001c4 	movi	r4,7
81124110:	2081d116 	blt	r4,r2,81124858 <___svfprintf_internal_r+0x1098>
81124114:	42000204 	addi	r8,r8,8
81124118:	9480010c 	andi	r18,r18,4
8112411c:	90003226 	beq	r18,zero,811241e8 <___svfprintf_internal_r+0xa28>
81124120:	d9403117 	ldw	r5,196(sp)
81124124:	d8802a17 	ldw	r2,168(sp)
81124128:	28a1c83a 	sub	r16,r5,r2
8112412c:	04002e0e 	bge	zero,r16,811241e8 <___svfprintf_internal_r+0xa28>
81124130:	04400404 	movi	r17,16
81124134:	d8801f17 	ldw	r2,124(sp)
81124138:	8c04b90e 	bge	r17,r16,81125420 <___svfprintf_internal_r+0x1c60>
8112413c:	01604574 	movhi	r5,33045
81124140:	29434b84 	addi	r5,r5,3374
81124144:	d9403515 	stw	r5,212(sp)
81124148:	048001c4 	movi	r18,7
8112414c:	dd002c17 	ldw	r20,176(sp)
81124150:	00000306 	br	81124160 <___svfprintf_internal_r+0x9a0>
81124154:	843ffc04 	addi	r16,r16,-16
81124158:	42000204 	addi	r8,r8,8
8112415c:	8c00130e 	bge	r17,r16,811241ac <___svfprintf_internal_r+0x9ec>
81124160:	01204574 	movhi	r4,33045
81124164:	18c00404 	addi	r3,r3,16
81124168:	10800044 	addi	r2,r2,1
8112416c:	21034b84 	addi	r4,r4,3374
81124170:	41000015 	stw	r4,0(r8)
81124174:	44400115 	stw	r17,4(r8)
81124178:	d8c02015 	stw	r3,128(sp)
8112417c:	d8801f15 	stw	r2,124(sp)
81124180:	90bff40e 	bge	r18,r2,81124154 <__reset+0xfb104154>
81124184:	d9801e04 	addi	r6,sp,120
81124188:	a00b883a 	mov	r5,r20
8112418c:	9809883a 	mov	r4,r19
81124190:	11300f80 	call	811300f8 <__ssprint_r>
81124194:	103e711e 	bne	r2,zero,81123b5c <__reset+0xfb103b5c>
81124198:	843ffc04 	addi	r16,r16,-16
8112419c:	d8c02017 	ldw	r3,128(sp)
811241a0:	d8801f17 	ldw	r2,124(sp)
811241a4:	da000404 	addi	r8,sp,16
811241a8:	8c3fed16 	blt	r17,r16,81124160 <__reset+0xfb104160>
811241ac:	d9403517 	ldw	r5,212(sp)
811241b0:	1c07883a 	add	r3,r3,r16
811241b4:	10800044 	addi	r2,r2,1
811241b8:	41400015 	stw	r5,0(r8)
811241bc:	44000115 	stw	r16,4(r8)
811241c0:	d8c02015 	stw	r3,128(sp)
811241c4:	d8801f15 	stw	r2,124(sp)
811241c8:	010001c4 	movi	r4,7
811241cc:	2080060e 	bge	r4,r2,811241e8 <___svfprintf_internal_r+0xa28>
811241d0:	d9402c17 	ldw	r5,176(sp)
811241d4:	d9801e04 	addi	r6,sp,120
811241d8:	9809883a 	mov	r4,r19
811241dc:	11300f80 	call	811300f8 <__ssprint_r>
811241e0:	103e5e1e 	bne	r2,zero,81123b5c <__reset+0xfb103b5c>
811241e4:	d8c02017 	ldw	r3,128(sp)
811241e8:	d8803117 	ldw	r2,196(sp)
811241ec:	d9002a17 	ldw	r4,168(sp)
811241f0:	1100010e 	bge	r2,r4,811241f8 <___svfprintf_internal_r+0xa38>
811241f4:	2005883a 	mov	r2,r4
811241f8:	d9402f17 	ldw	r5,188(sp)
811241fc:	288b883a 	add	r5,r5,r2
81124200:	d9402f15 	stw	r5,188(sp)
81124204:	18019c1e 	bne	r3,zero,81124878 <___svfprintf_internal_r+0x10b8>
81124208:	b8800007 	ldb	r2,0(r23)
8112420c:	d8001f15 	stw	zero,124(sp)
81124210:	da000404 	addi	r8,sp,16
81124214:	103d991e 	bne	r2,zero,8112387c <__reset+0xfb10387c>
81124218:	b821883a 	mov	r16,r23
8112421c:	003daf06 	br	811238dc <__reset+0xfb1038dc>
81124220:	18c03fcc 	andi	r3,r3,255
81124224:	1805c71e 	bne	r3,zero,81125944 <___svfprintf_internal_r+0x2184>
81124228:	94800414 	ori	r18,r18,16
8112422c:	9080080c 	andi	r2,r18,32
81124230:	10020126 	beq	r2,zero,81124a38 <___svfprintf_internal_r+0x1278>
81124234:	d8802d17 	ldw	r2,180(sp)
81124238:	d9002917 	ldw	r4,164(sp)
8112423c:	d8002785 	stb	zero,158(sp)
81124240:	10c00204 	addi	r3,r2,8
81124244:	15000017 	ldw	r20,0(r2)
81124248:	15800117 	ldw	r22,4(r2)
8112424c:	20038e16 	blt	r4,zero,81125088 <___svfprintf_internal_r+0x18c8>
81124250:	013fdfc4 	movi	r4,-129
81124254:	a584b03a 	or	r2,r20,r22
81124258:	d8c02d15 	stw	r3,180(sp)
8112425c:	9124703a 	and	r18,r18,r4
81124260:	0039883a 	mov	fp,zero
81124264:	103eb61e 	bne	r2,zero,81123d40 <__reset+0xfb103d40>
81124268:	d8802917 	ldw	r2,164(sp)
8112426c:	1002c81e 	bne	r2,zero,81124d90 <___svfprintf_internal_r+0x15d0>
81124270:	d8002915 	stw	zero,164(sp)
81124274:	d8002e15 	stw	zero,184(sp)
81124278:	dc001e04 	addi	r16,sp,120
8112427c:	003efa06 	br	81123e68 <__reset+0xfb103e68>
81124280:	18c03fcc 	andi	r3,r3,255
81124284:	1805ad1e 	bne	r3,zero,8112593c <___svfprintf_internal_r+0x217c>
81124288:	01604574 	movhi	r5,33045
8112428c:	29433b04 	addi	r5,r5,3308
81124290:	d9403a15 	stw	r5,232(sp)
81124294:	9080080c 	andi	r2,r18,32
81124298:	10006126 	beq	r2,zero,81124420 <___svfprintf_internal_r+0xc60>
8112429c:	d8802d17 	ldw	r2,180(sp)
811242a0:	15000017 	ldw	r20,0(r2)
811242a4:	15800117 	ldw	r22,4(r2)
811242a8:	10800204 	addi	r2,r2,8
811242ac:	d8802d15 	stw	r2,180(sp)
811242b0:	9080004c 	andi	r2,r18,1
811242b4:	10018e26 	beq	r2,zero,811248f0 <___svfprintf_internal_r+0x1130>
811242b8:	a584b03a 	or	r2,r20,r22
811242bc:	10030926 	beq	r2,zero,81124ee4 <___svfprintf_internal_r+0x1724>
811242c0:	d8c02917 	ldw	r3,164(sp)
811242c4:	00800c04 	movi	r2,48
811242c8:	d8802705 	stb	r2,156(sp)
811242cc:	dc402745 	stb	r17,157(sp)
811242d0:	d8002785 	stb	zero,158(sp)
811242d4:	90800094 	ori	r2,r18,2
811242d8:	18048716 	blt	r3,zero,811254f8 <___svfprintf_internal_r+0x1d38>
811242dc:	00bfdfc4 	movi	r2,-129
811242e0:	90a4703a 	and	r18,r18,r2
811242e4:	94800094 	ori	r18,r18,2
811242e8:	0039883a 	mov	fp,zero
811242ec:	d9003a17 	ldw	r4,232(sp)
811242f0:	dc001e04 	addi	r16,sp,120
811242f4:	a08003cc 	andi	r2,r20,15
811242f8:	b006973a 	slli	r3,r22,28
811242fc:	2085883a 	add	r2,r4,r2
81124300:	a028d13a 	srli	r20,r20,4
81124304:	10800003 	ldbu	r2,0(r2)
81124308:	b02cd13a 	srli	r22,r22,4
8112430c:	843fffc4 	addi	r16,r16,-1
81124310:	1d28b03a 	or	r20,r3,r20
81124314:	80800005 	stb	r2,0(r16)
81124318:	a584b03a 	or	r2,r20,r22
8112431c:	103ff51e 	bne	r2,zero,811242f4 <__reset+0xfb1042f4>
81124320:	d8c02817 	ldw	r3,160(sp)
81124324:	1c07c83a 	sub	r3,r3,r16
81124328:	d8c02e15 	stw	r3,184(sp)
8112432c:	003ece06 	br	81123e68 <__reset+0xfb103e68>
81124330:	d8c02d17 	ldw	r3,180(sp)
81124334:	d9002d17 	ldw	r4,180(sp)
81124338:	d8002785 	stb	zero,158(sp)
8112433c:	18800017 	ldw	r2,0(r3)
81124340:	21000104 	addi	r4,r4,4
81124344:	00c00044 	movi	r3,1
81124348:	d8c02a15 	stw	r3,168(sp)
8112434c:	d8801405 	stb	r2,80(sp)
81124350:	d9002d15 	stw	r4,180(sp)
81124354:	d8c02e15 	stw	r3,184(sp)
81124358:	d8002915 	stw	zero,164(sp)
8112435c:	d8003215 	stw	zero,200(sp)
81124360:	dc001404 	addi	r16,sp,80
81124364:	0039883a 	mov	fp,zero
81124368:	003ecc06 	br	81123e9c <__reset+0xfb103e9c>
8112436c:	18c03fcc 	andi	r3,r3,255
81124370:	183e9226 	beq	r3,zero,81123dbc <__reset+0xfb103dbc>
81124374:	d9c02785 	stb	r7,158(sp)
81124378:	003e9006 	br	81123dbc <__reset+0xfb103dbc>
8112437c:	00c00044 	movi	r3,1
81124380:	01c00ac4 	movi	r7,43
81124384:	bc400007 	ldb	r17,0(r23)
81124388:	003d6306 	br	81123918 <__reset+0xfb103918>
8112438c:	94800814 	ori	r18,r18,32
81124390:	bc400007 	ldb	r17,0(r23)
81124394:	003d6006 	br	81123918 <__reset+0xfb103918>
81124398:	d8c02d17 	ldw	r3,180(sp)
8112439c:	d8002785 	stb	zero,158(sp)
811243a0:	1c000017 	ldw	r16,0(r3)
811243a4:	1d000104 	addi	r20,r3,4
811243a8:	80040f26 	beq	r16,zero,811253e8 <___svfprintf_internal_r+0x1c28>
811243ac:	d9002917 	ldw	r4,164(sp)
811243b0:	2003dc16 	blt	r4,zero,81125324 <___svfprintf_internal_r+0x1b64>
811243b4:	200d883a 	mov	r6,r4
811243b8:	000b883a 	mov	r5,zero
811243bc:	8009883a 	mov	r4,r16
811243c0:	da003e15 	stw	r8,248(sp)
811243c4:	112c9840 	call	8112c984 <memchr>
811243c8:	da003e17 	ldw	r8,248(sp)
811243cc:	10045826 	beq	r2,zero,81125530 <___svfprintf_internal_r+0x1d70>
811243d0:	1405c83a 	sub	r2,r2,r16
811243d4:	d8802e15 	stw	r2,184(sp)
811243d8:	1003d816 	blt	r2,zero,8112533c <___svfprintf_internal_r+0x1b7c>
811243dc:	df002783 	ldbu	fp,158(sp)
811243e0:	d8802a15 	stw	r2,168(sp)
811243e4:	dd002d15 	stw	r20,180(sp)
811243e8:	d8002915 	stw	zero,164(sp)
811243ec:	d8003215 	stw	zero,200(sp)
811243f0:	003ea306 	br	81123e80 <__reset+0xfb103e80>
811243f4:	18c03fcc 	andi	r3,r3,255
811243f8:	183f8c26 	beq	r3,zero,8112422c <__reset+0xfb10422c>
811243fc:	d9c02785 	stb	r7,158(sp)
81124400:	003f8a06 	br	8112422c <__reset+0xfb10422c>
81124404:	18c03fcc 	andi	r3,r3,255
81124408:	1805631e 	bne	r3,zero,81125998 <___svfprintf_internal_r+0x21d8>
8112440c:	01604574 	movhi	r5,33045
81124410:	29434004 	addi	r5,r5,3328
81124414:	d9403a15 	stw	r5,232(sp)
81124418:	9080080c 	andi	r2,r18,32
8112441c:	103f9f1e 	bne	r2,zero,8112429c <__reset+0xfb10429c>
81124420:	9080040c 	andi	r2,r18,16
81124424:	10029c26 	beq	r2,zero,81124e98 <___svfprintf_internal_r+0x16d8>
81124428:	d8c02d17 	ldw	r3,180(sp)
8112442c:	002d883a 	mov	r22,zero
81124430:	1d000017 	ldw	r20,0(r3)
81124434:	18c00104 	addi	r3,r3,4
81124438:	d8c02d15 	stw	r3,180(sp)
8112443c:	003f9c06 	br	811242b0 <__reset+0xfb1042b0>
81124440:	94800054 	ori	r18,r18,1
81124444:	bc400007 	ldb	r17,0(r23)
81124448:	003d3306 	br	81123918 <__reset+0xfb103918>
8112444c:	38803fcc 	andi	r2,r7,255
81124450:	1080201c 	xori	r2,r2,128
81124454:	10bfe004 	addi	r2,r2,-128
81124458:	1002971e 	bne	r2,zero,81124eb8 <___svfprintf_internal_r+0x16f8>
8112445c:	00c00044 	movi	r3,1
81124460:	01c00804 	movi	r7,32
81124464:	bc400007 	ldb	r17,0(r23)
81124468:	003d2b06 	br	81123918 <__reset+0xfb103918>
8112446c:	18c03fcc 	andi	r3,r3,255
81124470:	183e2326 	beq	r3,zero,81123d00 <__reset+0xfb103d00>
81124474:	d9c02785 	stb	r7,158(sp)
81124478:	003e2106 	br	81123d00 <__reset+0xfb103d00>
8112447c:	bc400007 	ldb	r17,0(r23)
81124480:	8a430426 	beq	r17,r9,81125094 <___svfprintf_internal_r+0x18d4>
81124484:	94800414 	ori	r18,r18,16
81124488:	003d2306 	br	81123918 <__reset+0xfb103918>
8112448c:	18c03fcc 	andi	r3,r3,255
81124490:	18053f1e 	bne	r3,zero,81125990 <___svfprintf_internal_r+0x21d0>
81124494:	9080080c 	andi	r2,r18,32
81124498:	10028926 	beq	r2,zero,81124ec0 <___svfprintf_internal_r+0x1700>
8112449c:	d9402d17 	ldw	r5,180(sp)
811244a0:	d9002f17 	ldw	r4,188(sp)
811244a4:	28800017 	ldw	r2,0(r5)
811244a8:	2007d7fa 	srai	r3,r4,31
811244ac:	29400104 	addi	r5,r5,4
811244b0:	d9402d15 	stw	r5,180(sp)
811244b4:	11000015 	stw	r4,0(r2)
811244b8:	10c00115 	stw	r3,4(r2)
811244bc:	003ced06 	br	81123874 <__reset+0xfb103874>
811244c0:	94801014 	ori	r18,r18,64
811244c4:	bc400007 	ldb	r17,0(r23)
811244c8:	003d1306 	br	81123918 <__reset+0xfb103918>
811244cc:	01204574 	movhi	r4,33045
811244d0:	21034004 	addi	r4,r4,3328
811244d4:	0039883a 	mov	fp,zero
811244d8:	d9003a15 	stw	r4,232(sp)
811244dc:	04401e04 	movi	r17,120
811244e0:	003f8206 	br	811242ec <__reset+0xfb1042ec>
811244e4:	18c03fcc 	andi	r3,r3,255
811244e8:	1805221e 	bne	r3,zero,81125974 <___svfprintf_internal_r+0x21b4>
811244ec:	883d9526 	beq	r17,zero,81123b44 <__reset+0xfb103b44>
811244f0:	00c00044 	movi	r3,1
811244f4:	d8c02a15 	stw	r3,168(sp)
811244f8:	dc401405 	stb	r17,80(sp)
811244fc:	d8002785 	stb	zero,158(sp)
81124500:	003f9406 	br	81124354 <__reset+0xfb104354>
81124504:	01204574 	movhi	r4,33045
81124508:	21034004 	addi	r4,r4,3328
8112450c:	d9003a15 	stw	r4,232(sp)
81124510:	d8c02d15 	stw	r3,180(sp)
81124514:	1025883a 	mov	r18,r2
81124518:	04401e04 	movi	r17,120
8112451c:	a584b03a 	or	r2,r20,r22
81124520:	1000fa1e 	bne	r2,zero,8112490c <___svfprintf_internal_r+0x114c>
81124524:	0039883a 	mov	fp,zero
81124528:	00800084 	movi	r2,2
8112452c:	10803fcc 	andi	r2,r2,255
81124530:	00c00044 	movi	r3,1
81124534:	10c21626 	beq	r2,r3,81124d90 <___svfprintf_internal_r+0x15d0>
81124538:	00c00084 	movi	r3,2
8112453c:	10fe301e 	bne	r2,r3,81123e00 <__reset+0xfb103e00>
81124540:	003d7606 	br	81123b1c <__reset+0xfb103b1c>
81124544:	d8c02017 	ldw	r3,128(sp)
81124548:	003e9506 	br	81123fa0 <__reset+0xfb103fa0>
8112454c:	00801944 	movi	r2,101
81124550:	14407c0e 	bge	r2,r17,81124744 <___svfprintf_internal_r+0xf84>
81124554:	d9003617 	ldw	r4,216(sp)
81124558:	d9403717 	ldw	r5,220(sp)
8112455c:	000d883a 	mov	r6,zero
81124560:	000f883a 	mov	r7,zero
81124564:	d8c03d15 	stw	r3,244(sp)
81124568:	da003e15 	stw	r8,248(sp)
8112456c:	11360740 	call	81136074 <__eqdf2>
81124570:	d8c03d17 	ldw	r3,244(sp)
81124574:	da003e17 	ldw	r8,248(sp)
81124578:	1000f51e 	bne	r2,zero,81124950 <___svfprintf_internal_r+0x1190>
8112457c:	d8801f17 	ldw	r2,124(sp)
81124580:	01204574 	movhi	r4,33045
81124584:	21034704 	addi	r4,r4,3356
81124588:	18c00044 	addi	r3,r3,1
8112458c:	10800044 	addi	r2,r2,1
81124590:	41000015 	stw	r4,0(r8)
81124594:	01000044 	movi	r4,1
81124598:	41000115 	stw	r4,4(r8)
8112459c:	d8c02015 	stw	r3,128(sp)
811245a0:	d8801f15 	stw	r2,124(sp)
811245a4:	010001c4 	movi	r4,7
811245a8:	20826616 	blt	r4,r2,81124f44 <___svfprintf_internal_r+0x1784>
811245ac:	42000204 	addi	r8,r8,8
811245b0:	d8802617 	ldw	r2,152(sp)
811245b4:	d9403317 	ldw	r5,204(sp)
811245b8:	11400216 	blt	r2,r5,811245c4 <___svfprintf_internal_r+0xe04>
811245bc:	9080004c 	andi	r2,r18,1
811245c0:	103ed526 	beq	r2,zero,81124118 <__reset+0xfb104118>
811245c4:	d8803817 	ldw	r2,224(sp)
811245c8:	d9003417 	ldw	r4,208(sp)
811245cc:	d9403817 	ldw	r5,224(sp)
811245d0:	1887883a 	add	r3,r3,r2
811245d4:	d8801f17 	ldw	r2,124(sp)
811245d8:	41000015 	stw	r4,0(r8)
811245dc:	41400115 	stw	r5,4(r8)
811245e0:	10800044 	addi	r2,r2,1
811245e4:	d8c02015 	stw	r3,128(sp)
811245e8:	d8801f15 	stw	r2,124(sp)
811245ec:	010001c4 	movi	r4,7
811245f0:	2082af16 	blt	r4,r2,811250b0 <___svfprintf_internal_r+0x18f0>
811245f4:	42000204 	addi	r8,r8,8
811245f8:	d8803317 	ldw	r2,204(sp)
811245fc:	143fffc4 	addi	r16,r2,-1
81124600:	043ec50e 	bge	zero,r16,81124118 <__reset+0xfb104118>
81124604:	04400404 	movi	r17,16
81124608:	d8801f17 	ldw	r2,124(sp)
8112460c:	8c00860e 	bge	r17,r16,81124828 <___svfprintf_internal_r+0x1068>
81124610:	01604574 	movhi	r5,33045
81124614:	29434784 	addi	r5,r5,3358
81124618:	d9402b15 	stw	r5,172(sp)
8112461c:	058001c4 	movi	r22,7
81124620:	dd002c17 	ldw	r20,176(sp)
81124624:	00000306 	br	81124634 <___svfprintf_internal_r+0xe74>
81124628:	42000204 	addi	r8,r8,8
8112462c:	843ffc04 	addi	r16,r16,-16
81124630:	8c00800e 	bge	r17,r16,81124834 <___svfprintf_internal_r+0x1074>
81124634:	18c00404 	addi	r3,r3,16
81124638:	10800044 	addi	r2,r2,1
8112463c:	45400015 	stw	r21,0(r8)
81124640:	44400115 	stw	r17,4(r8)
81124644:	d8c02015 	stw	r3,128(sp)
81124648:	d8801f15 	stw	r2,124(sp)
8112464c:	b0bff60e 	bge	r22,r2,81124628 <__reset+0xfb104628>
81124650:	d9801e04 	addi	r6,sp,120
81124654:	a00b883a 	mov	r5,r20
81124658:	9809883a 	mov	r4,r19
8112465c:	11300f80 	call	811300f8 <__ssprint_r>
81124660:	103d3e1e 	bne	r2,zero,81123b5c <__reset+0xfb103b5c>
81124664:	d8c02017 	ldw	r3,128(sp)
81124668:	d8801f17 	ldw	r2,124(sp)
8112466c:	da000404 	addi	r8,sp,16
81124670:	003fee06 	br	8112462c <__reset+0xfb10462c>
81124674:	d9403117 	ldw	r5,196(sp)
81124678:	d8802a17 	ldw	r2,168(sp)
8112467c:	28adc83a 	sub	r22,r5,r2
81124680:	05be650e 	bge	zero,r22,81124018 <__reset+0xfb104018>
81124684:	07000404 	movi	fp,16
81124688:	d8801f17 	ldw	r2,124(sp)
8112468c:	e583a20e 	bge	fp,r22,81125518 <___svfprintf_internal_r+0x1d58>
81124690:	01604574 	movhi	r5,33045
81124694:	29434784 	addi	r5,r5,3358
81124698:	dc403015 	stw	r17,192(sp)
8112469c:	d9402b15 	stw	r5,172(sp)
811246a0:	b023883a 	mov	r17,r22
811246a4:	050001c4 	movi	r20,7
811246a8:	902d883a 	mov	r22,r18
811246ac:	8025883a 	mov	r18,r16
811246b0:	dc002c17 	ldw	r16,176(sp)
811246b4:	00000306 	br	811246c4 <___svfprintf_internal_r+0xf04>
811246b8:	8c7ffc04 	addi	r17,r17,-16
811246bc:	42000204 	addi	r8,r8,8
811246c0:	e440110e 	bge	fp,r17,81124708 <___svfprintf_internal_r+0xf48>
811246c4:	18c00404 	addi	r3,r3,16
811246c8:	10800044 	addi	r2,r2,1
811246cc:	45400015 	stw	r21,0(r8)
811246d0:	47000115 	stw	fp,4(r8)
811246d4:	d8c02015 	stw	r3,128(sp)
811246d8:	d8801f15 	stw	r2,124(sp)
811246dc:	a0bff60e 	bge	r20,r2,811246b8 <__reset+0xfb1046b8>
811246e0:	d9801e04 	addi	r6,sp,120
811246e4:	800b883a 	mov	r5,r16
811246e8:	9809883a 	mov	r4,r19
811246ec:	11300f80 	call	811300f8 <__ssprint_r>
811246f0:	103d1a1e 	bne	r2,zero,81123b5c <__reset+0xfb103b5c>
811246f4:	8c7ffc04 	addi	r17,r17,-16
811246f8:	d8c02017 	ldw	r3,128(sp)
811246fc:	d8801f17 	ldw	r2,124(sp)
81124700:	da000404 	addi	r8,sp,16
81124704:	e47fef16 	blt	fp,r17,811246c4 <__reset+0xfb1046c4>
81124708:	9021883a 	mov	r16,r18
8112470c:	b025883a 	mov	r18,r22
81124710:	882d883a 	mov	r22,r17
81124714:	dc403017 	ldw	r17,192(sp)
81124718:	d9002b17 	ldw	r4,172(sp)
8112471c:	1d87883a 	add	r3,r3,r22
81124720:	10800044 	addi	r2,r2,1
81124724:	41000015 	stw	r4,0(r8)
81124728:	45800115 	stw	r22,4(r8)
8112472c:	d8c02015 	stw	r3,128(sp)
81124730:	d8801f15 	stw	r2,124(sp)
81124734:	010001c4 	movi	r4,7
81124738:	20819a16 	blt	r4,r2,81124da4 <___svfprintf_internal_r+0x15e4>
8112473c:	42000204 	addi	r8,r8,8
81124740:	003e3506 	br	81124018 <__reset+0xfb104018>
81124744:	d9403317 	ldw	r5,204(sp)
81124748:	00800044 	movi	r2,1
8112474c:	18c00044 	addi	r3,r3,1
81124750:	1141710e 	bge	r2,r5,81124d18 <___svfprintf_internal_r+0x1558>
81124754:	dc401f17 	ldw	r17,124(sp)
81124758:	00800044 	movi	r2,1
8112475c:	40800115 	stw	r2,4(r8)
81124760:	8c400044 	addi	r17,r17,1
81124764:	44000015 	stw	r16,0(r8)
81124768:	d8c02015 	stw	r3,128(sp)
8112476c:	dc401f15 	stw	r17,124(sp)
81124770:	008001c4 	movi	r2,7
81124774:	14417416 	blt	r2,r17,81124d48 <___svfprintf_internal_r+0x1588>
81124778:	42000204 	addi	r8,r8,8
8112477c:	d8803817 	ldw	r2,224(sp)
81124780:	d9003417 	ldw	r4,208(sp)
81124784:	8c400044 	addi	r17,r17,1
81124788:	10c7883a 	add	r3,r2,r3
8112478c:	40800115 	stw	r2,4(r8)
81124790:	41000015 	stw	r4,0(r8)
81124794:	d8c02015 	stw	r3,128(sp)
81124798:	dc401f15 	stw	r17,124(sp)
8112479c:	008001c4 	movi	r2,7
811247a0:	14417216 	blt	r2,r17,81124d6c <___svfprintf_internal_r+0x15ac>
811247a4:	45800204 	addi	r22,r8,8
811247a8:	d9003617 	ldw	r4,216(sp)
811247ac:	d9403717 	ldw	r5,220(sp)
811247b0:	000d883a 	mov	r6,zero
811247b4:	000f883a 	mov	r7,zero
811247b8:	d8c03d15 	stw	r3,244(sp)
811247bc:	11360740 	call	81136074 <__eqdf2>
811247c0:	d8c03d17 	ldw	r3,244(sp)
811247c4:	1000b326 	beq	r2,zero,81124a94 <___svfprintf_internal_r+0x12d4>
811247c8:	d9403317 	ldw	r5,204(sp)
811247cc:	84000044 	addi	r16,r16,1
811247d0:	8c400044 	addi	r17,r17,1
811247d4:	28bfffc4 	addi	r2,r5,-1
811247d8:	1887883a 	add	r3,r3,r2
811247dc:	b0800115 	stw	r2,4(r22)
811247e0:	b4000015 	stw	r16,0(r22)
811247e4:	d8c02015 	stw	r3,128(sp)
811247e8:	dc401f15 	stw	r17,124(sp)
811247ec:	008001c4 	movi	r2,7
811247f0:	1440d216 	blt	r2,r17,81124b3c <___svfprintf_internal_r+0x137c>
811247f4:	b5800204 	addi	r22,r22,8
811247f8:	d9003b17 	ldw	r4,236(sp)
811247fc:	df0022c4 	addi	fp,sp,139
81124800:	8c400044 	addi	r17,r17,1
81124804:	20c7883a 	add	r3,r4,r3
81124808:	b7000015 	stw	fp,0(r22)
8112480c:	b1000115 	stw	r4,4(r22)
81124810:	d8c02015 	stw	r3,128(sp)
81124814:	dc401f15 	stw	r17,124(sp)
81124818:	008001c4 	movi	r2,7
8112481c:	14400e16 	blt	r2,r17,81124858 <___svfprintf_internal_r+0x1098>
81124820:	b2000204 	addi	r8,r22,8
81124824:	003e3c06 	br	81124118 <__reset+0xfb104118>
81124828:	01204574 	movhi	r4,33045
8112482c:	21034784 	addi	r4,r4,3358
81124830:	d9002b15 	stw	r4,172(sp)
81124834:	d9002b17 	ldw	r4,172(sp)
81124838:	1c07883a 	add	r3,r3,r16
8112483c:	44000115 	stw	r16,4(r8)
81124840:	41000015 	stw	r4,0(r8)
81124844:	10800044 	addi	r2,r2,1
81124848:	d8c02015 	stw	r3,128(sp)
8112484c:	d8801f15 	stw	r2,124(sp)
81124850:	010001c4 	movi	r4,7
81124854:	20be2f0e 	bge	r4,r2,81124114 <__reset+0xfb104114>
81124858:	d9402c17 	ldw	r5,176(sp)
8112485c:	d9801e04 	addi	r6,sp,120
81124860:	9809883a 	mov	r4,r19
81124864:	11300f80 	call	811300f8 <__ssprint_r>
81124868:	103cbc1e 	bne	r2,zero,81123b5c <__reset+0xfb103b5c>
8112486c:	d8c02017 	ldw	r3,128(sp)
81124870:	da000404 	addi	r8,sp,16
81124874:	003e2806 	br	81124118 <__reset+0xfb104118>
81124878:	d9402c17 	ldw	r5,176(sp)
8112487c:	d9801e04 	addi	r6,sp,120
81124880:	9809883a 	mov	r4,r19
81124884:	11300f80 	call	811300f8 <__ssprint_r>
81124888:	103e5f26 	beq	r2,zero,81124208 <__reset+0xfb104208>
8112488c:	003cb306 	br	81123b5c <__reset+0xfb103b5c>
81124890:	d9402c17 	ldw	r5,176(sp)
81124894:	d9801e04 	addi	r6,sp,120
81124898:	9809883a 	mov	r4,r19
8112489c:	11300f80 	call	811300f8 <__ssprint_r>
811248a0:	103cae1e 	bne	r2,zero,81123b5c <__reset+0xfb103b5c>
811248a4:	d8c02017 	ldw	r3,128(sp)
811248a8:	da000404 	addi	r8,sp,16
811248ac:	003e0d06 	br	811240e4 <__reset+0xfb1040e4>
811248b0:	d9402c17 	ldw	r5,176(sp)
811248b4:	d9801e04 	addi	r6,sp,120
811248b8:	9809883a 	mov	r4,r19
811248bc:	11300f80 	call	811300f8 <__ssprint_r>
811248c0:	103ca61e 	bne	r2,zero,81123b5c <__reset+0xfb103b5c>
811248c4:	d8c02017 	ldw	r3,128(sp)
811248c8:	da000404 	addi	r8,sp,16
811248cc:	003dc106 	br	81123fd4 <__reset+0xfb103fd4>
811248d0:	d9402c17 	ldw	r5,176(sp)
811248d4:	d9801e04 	addi	r6,sp,120
811248d8:	9809883a 	mov	r4,r19
811248dc:	11300f80 	call	811300f8 <__ssprint_r>
811248e0:	103c9e1e 	bne	r2,zero,81123b5c <__reset+0xfb103b5c>
811248e4:	d8c02017 	ldw	r3,128(sp)
811248e8:	da000404 	addi	r8,sp,16
811248ec:	003dc706 	br	8112400c <__reset+0xfb10400c>
811248f0:	d8802917 	ldw	r2,164(sp)
811248f4:	d8002785 	stb	zero,158(sp)
811248f8:	103f0816 	blt	r2,zero,8112451c <__reset+0xfb10451c>
811248fc:	00ffdfc4 	movi	r3,-129
81124900:	a584b03a 	or	r2,r20,r22
81124904:	90e4703a 	and	r18,r18,r3
81124908:	103c8126 	beq	r2,zero,81123b10 <__reset+0xfb103b10>
8112490c:	0039883a 	mov	fp,zero
81124910:	003e7606 	br	811242ec <__reset+0xfb1042ec>
81124914:	9080040c 	andi	r2,r18,16
81124918:	10013d26 	beq	r2,zero,81124e10 <___svfprintf_internal_r+0x1650>
8112491c:	d9002d17 	ldw	r4,180(sp)
81124920:	d9402917 	ldw	r5,164(sp)
81124924:	d8002785 	stb	zero,158(sp)
81124928:	20800104 	addi	r2,r4,4
8112492c:	25000017 	ldw	r20,0(r4)
81124930:	002d883a 	mov	r22,zero
81124934:	28013f16 	blt	r5,zero,81124e34 <___svfprintf_internal_r+0x1674>
81124938:	00ffdfc4 	movi	r3,-129
8112493c:	d8802d15 	stw	r2,180(sp)
81124940:	90e4703a 	and	r18,r18,r3
81124944:	a03d2b26 	beq	r20,zero,81123df4 <__reset+0xfb103df4>
81124948:	0039883a 	mov	fp,zero
8112494c:	003d2e06 	br	81123e08 <__reset+0xfb103e08>
81124950:	dc402617 	ldw	r17,152(sp)
81124954:	0441830e 	bge	zero,r17,81124f64 <___svfprintf_internal_r+0x17a4>
81124958:	dc403217 	ldw	r17,200(sp)
8112495c:	d8803317 	ldw	r2,204(sp)
81124960:	1440010e 	bge	r2,r17,81124968 <___svfprintf_internal_r+0x11a8>
81124964:	1023883a 	mov	r17,r2
81124968:	04400a0e 	bge	zero,r17,81124994 <___svfprintf_internal_r+0x11d4>
8112496c:	d8801f17 	ldw	r2,124(sp)
81124970:	1c47883a 	add	r3,r3,r17
81124974:	44000015 	stw	r16,0(r8)
81124978:	10800044 	addi	r2,r2,1
8112497c:	44400115 	stw	r17,4(r8)
81124980:	d8c02015 	stw	r3,128(sp)
81124984:	d8801f15 	stw	r2,124(sp)
81124988:	010001c4 	movi	r4,7
8112498c:	20827516 	blt	r4,r2,81125364 <___svfprintf_internal_r+0x1ba4>
81124990:	42000204 	addi	r8,r8,8
81124994:	88027b16 	blt	r17,zero,81125384 <___svfprintf_internal_r+0x1bc4>
81124998:	d9003217 	ldw	r4,200(sp)
8112499c:	2463c83a 	sub	r17,r4,r17
811249a0:	0440990e 	bge	zero,r17,81124c08 <___svfprintf_internal_r+0x1448>
811249a4:	05800404 	movi	r22,16
811249a8:	d8801f17 	ldw	r2,124(sp)
811249ac:	b441530e 	bge	r22,r17,81124efc <___svfprintf_internal_r+0x173c>
811249b0:	01204574 	movhi	r4,33045
811249b4:	21034784 	addi	r4,r4,3358
811249b8:	d9002b15 	stw	r4,172(sp)
811249bc:	070001c4 	movi	fp,7
811249c0:	dd002c17 	ldw	r20,176(sp)
811249c4:	00000306 	br	811249d4 <___svfprintf_internal_r+0x1214>
811249c8:	42000204 	addi	r8,r8,8
811249cc:	8c7ffc04 	addi	r17,r17,-16
811249d0:	b4414d0e 	bge	r22,r17,81124f08 <___svfprintf_internal_r+0x1748>
811249d4:	18c00404 	addi	r3,r3,16
811249d8:	10800044 	addi	r2,r2,1
811249dc:	45400015 	stw	r21,0(r8)
811249e0:	45800115 	stw	r22,4(r8)
811249e4:	d8c02015 	stw	r3,128(sp)
811249e8:	d8801f15 	stw	r2,124(sp)
811249ec:	e0bff60e 	bge	fp,r2,811249c8 <__reset+0xfb1049c8>
811249f0:	d9801e04 	addi	r6,sp,120
811249f4:	a00b883a 	mov	r5,r20
811249f8:	9809883a 	mov	r4,r19
811249fc:	11300f80 	call	811300f8 <__ssprint_r>
81124a00:	103c561e 	bne	r2,zero,81123b5c <__reset+0xfb103b5c>
81124a04:	d8c02017 	ldw	r3,128(sp)
81124a08:	d8801f17 	ldw	r2,124(sp)
81124a0c:	da000404 	addi	r8,sp,16
81124a10:	003fee06 	br	811249cc <__reset+0xfb1049cc>
81124a14:	d9402c17 	ldw	r5,176(sp)
81124a18:	d9801e04 	addi	r6,sp,120
81124a1c:	9809883a 	mov	r4,r19
81124a20:	11300f80 	call	811300f8 <__ssprint_r>
81124a24:	103c4d1e 	bne	r2,zero,81123b5c <__reset+0xfb103b5c>
81124a28:	d8c02017 	ldw	r3,128(sp)
81124a2c:	df002787 	ldb	fp,158(sp)
81124a30:	da000404 	addi	r8,sp,16
81124a34:	003d5a06 	br	81123fa0 <__reset+0xfb103fa0>
81124a38:	9080040c 	andi	r2,r18,16
81124a3c:	10005c26 	beq	r2,zero,81124bb0 <___svfprintf_internal_r+0x13f0>
81124a40:	d9402d17 	ldw	r5,180(sp)
81124a44:	d8c02917 	ldw	r3,164(sp)
81124a48:	d8002785 	stb	zero,158(sp)
81124a4c:	28800104 	addi	r2,r5,4
81124a50:	2d000017 	ldw	r20,0(r5)
81124a54:	002d883a 	mov	r22,zero
81124a58:	18005e16 	blt	r3,zero,81124bd4 <___svfprintf_internal_r+0x1414>
81124a5c:	00ffdfc4 	movi	r3,-129
81124a60:	d8802d15 	stw	r2,180(sp)
81124a64:	90e4703a 	and	r18,r18,r3
81124a68:	0039883a 	mov	fp,zero
81124a6c:	a03dfe26 	beq	r20,zero,81124268 <__reset+0xfb104268>
81124a70:	00800244 	movi	r2,9
81124a74:	153cb336 	bltu	r2,r20,81123d44 <__reset+0xfb103d44>
81124a78:	a5000c04 	addi	r20,r20,48
81124a7c:	dc001dc4 	addi	r16,sp,119
81124a80:	dd001dc5 	stb	r20,119(sp)
81124a84:	d8c02817 	ldw	r3,160(sp)
81124a88:	1c07c83a 	sub	r3,r3,r16
81124a8c:	d8c02e15 	stw	r3,184(sp)
81124a90:	003cf506 	br	81123e68 <__reset+0xfb103e68>
81124a94:	d8803317 	ldw	r2,204(sp)
81124a98:	143fffc4 	addi	r16,r2,-1
81124a9c:	043f560e 	bge	zero,r16,811247f8 <__reset+0xfb1047f8>
81124aa0:	07000404 	movi	fp,16
81124aa4:	e403530e 	bge	fp,r16,811257f4 <___svfprintf_internal_r+0x2034>
81124aa8:	01604574 	movhi	r5,33045
81124aac:	29434784 	addi	r5,r5,3358
81124ab0:	d9402b15 	stw	r5,172(sp)
81124ab4:	01c001c4 	movi	r7,7
81124ab8:	dd002c17 	ldw	r20,176(sp)
81124abc:	00000306 	br	81124acc <___svfprintf_internal_r+0x130c>
81124ac0:	843ffc04 	addi	r16,r16,-16
81124ac4:	b5800204 	addi	r22,r22,8
81124ac8:	e400130e 	bge	fp,r16,81124b18 <___svfprintf_internal_r+0x1358>
81124acc:	18c00404 	addi	r3,r3,16
81124ad0:	8c400044 	addi	r17,r17,1
81124ad4:	b5400015 	stw	r21,0(r22)
81124ad8:	b7000115 	stw	fp,4(r22)
81124adc:	d8c02015 	stw	r3,128(sp)
81124ae0:	dc401f15 	stw	r17,124(sp)
81124ae4:	3c7ff60e 	bge	r7,r17,81124ac0 <__reset+0xfb104ac0>
81124ae8:	d9801e04 	addi	r6,sp,120
81124aec:	a00b883a 	mov	r5,r20
81124af0:	9809883a 	mov	r4,r19
81124af4:	d9c03d15 	stw	r7,244(sp)
81124af8:	11300f80 	call	811300f8 <__ssprint_r>
81124afc:	d9c03d17 	ldw	r7,244(sp)
81124b00:	103c161e 	bne	r2,zero,81123b5c <__reset+0xfb103b5c>
81124b04:	843ffc04 	addi	r16,r16,-16
81124b08:	d8c02017 	ldw	r3,128(sp)
81124b0c:	dc401f17 	ldw	r17,124(sp)
81124b10:	dd800404 	addi	r22,sp,16
81124b14:	e43fed16 	blt	fp,r16,81124acc <__reset+0xfb104acc>
81124b18:	d8802b17 	ldw	r2,172(sp)
81124b1c:	1c07883a 	add	r3,r3,r16
81124b20:	8c400044 	addi	r17,r17,1
81124b24:	b0800015 	stw	r2,0(r22)
81124b28:	b4000115 	stw	r16,4(r22)
81124b2c:	d8c02015 	stw	r3,128(sp)
81124b30:	dc401f15 	stw	r17,124(sp)
81124b34:	008001c4 	movi	r2,7
81124b38:	147f2e0e 	bge	r2,r17,811247f4 <__reset+0xfb1047f4>
81124b3c:	d9402c17 	ldw	r5,176(sp)
81124b40:	d9801e04 	addi	r6,sp,120
81124b44:	9809883a 	mov	r4,r19
81124b48:	11300f80 	call	811300f8 <__ssprint_r>
81124b4c:	103c031e 	bne	r2,zero,81123b5c <__reset+0xfb103b5c>
81124b50:	d8c02017 	ldw	r3,128(sp)
81124b54:	dc401f17 	ldw	r17,124(sp)
81124b58:	dd800404 	addi	r22,sp,16
81124b5c:	003f2606 	br	811247f8 <__reset+0xfb1047f8>
81124b60:	9080040c 	andi	r2,r18,16
81124b64:	1000c326 	beq	r2,zero,81124e74 <___svfprintf_internal_r+0x16b4>
81124b68:	d8802d17 	ldw	r2,180(sp)
81124b6c:	15000017 	ldw	r20,0(r2)
81124b70:	10800104 	addi	r2,r2,4
81124b74:	d8802d15 	stw	r2,180(sp)
81124b78:	a02dd7fa 	srai	r22,r20,31
81124b7c:	b005883a 	mov	r2,r22
81124b80:	103c680e 	bge	r2,zero,81123d24 <__reset+0xfb103d24>
81124b84:	0529c83a 	sub	r20,zero,r20
81124b88:	a004c03a 	cmpne	r2,r20,zero
81124b8c:	05adc83a 	sub	r22,zero,r22
81124b90:	b0adc83a 	sub	r22,r22,r2
81124b94:	d8802917 	ldw	r2,164(sp)
81124b98:	07000b44 	movi	fp,45
81124b9c:	df002785 	stb	fp,158(sp)
81124ba0:	10022e16 	blt	r2,zero,8112545c <___svfprintf_internal_r+0x1c9c>
81124ba4:	00bfdfc4 	movi	r2,-129
81124ba8:	90a4703a 	and	r18,r18,r2
81124bac:	003c6406 	br	81123d40 <__reset+0xfb103d40>
81124bb0:	9080100c 	andi	r2,r18,64
81124bb4:	d8002785 	stb	zero,158(sp)
81124bb8:	10012526 	beq	r2,zero,81125050 <___svfprintf_internal_r+0x1890>
81124bbc:	d9002d17 	ldw	r4,180(sp)
81124bc0:	d9402917 	ldw	r5,164(sp)
81124bc4:	002d883a 	mov	r22,zero
81124bc8:	20800104 	addi	r2,r4,4
81124bcc:	2500000b 	ldhu	r20,0(r4)
81124bd0:	283fa20e 	bge	r5,zero,81124a5c <__reset+0xfb104a5c>
81124bd4:	d8802d15 	stw	r2,180(sp)
81124bd8:	0039883a 	mov	fp,zero
81124bdc:	a584b03a 	or	r2,r20,r22
81124be0:	103c571e 	bne	r2,zero,81123d40 <__reset+0xfb103d40>
81124be4:	00800044 	movi	r2,1
81124be8:	003e5006 	br	8112452c <__reset+0xfb10452c>
81124bec:	d9402c17 	ldw	r5,176(sp)
81124bf0:	d9801e04 	addi	r6,sp,120
81124bf4:	9809883a 	mov	r4,r19
81124bf8:	11300f80 	call	811300f8 <__ssprint_r>
81124bfc:	103bd71e 	bne	r2,zero,81123b5c <__reset+0xfb103b5c>
81124c00:	d8c02017 	ldw	r3,128(sp)
81124c04:	da000404 	addi	r8,sp,16
81124c08:	d9003217 	ldw	r4,200(sp)
81124c0c:	d8802617 	ldw	r2,152(sp)
81124c10:	d9403317 	ldw	r5,204(sp)
81124c14:	8123883a 	add	r17,r16,r4
81124c18:	11400216 	blt	r2,r5,81124c24 <___svfprintf_internal_r+0x1464>
81124c1c:	9100004c 	andi	r4,r18,1
81124c20:	20000d26 	beq	r4,zero,81124c58 <___svfprintf_internal_r+0x1498>
81124c24:	d9003817 	ldw	r4,224(sp)
81124c28:	d9403417 	ldw	r5,208(sp)
81124c2c:	1907883a 	add	r3,r3,r4
81124c30:	d9001f17 	ldw	r4,124(sp)
81124c34:	41400015 	stw	r5,0(r8)
81124c38:	d9403817 	ldw	r5,224(sp)
81124c3c:	21000044 	addi	r4,r4,1
81124c40:	d8c02015 	stw	r3,128(sp)
81124c44:	41400115 	stw	r5,4(r8)
81124c48:	d9001f15 	stw	r4,124(sp)
81124c4c:	014001c4 	movi	r5,7
81124c50:	2901dc16 	blt	r5,r4,811253c4 <___svfprintf_internal_r+0x1c04>
81124c54:	42000204 	addi	r8,r8,8
81124c58:	d9003317 	ldw	r4,204(sp)
81124c5c:	8121883a 	add	r16,r16,r4
81124c60:	2085c83a 	sub	r2,r4,r2
81124c64:	8461c83a 	sub	r16,r16,r17
81124c68:	1400010e 	bge	r2,r16,81124c70 <___svfprintf_internal_r+0x14b0>
81124c6c:	1021883a 	mov	r16,r2
81124c70:	04000a0e 	bge	zero,r16,81124c9c <___svfprintf_internal_r+0x14dc>
81124c74:	d9001f17 	ldw	r4,124(sp)
81124c78:	1c07883a 	add	r3,r3,r16
81124c7c:	44400015 	stw	r17,0(r8)
81124c80:	21000044 	addi	r4,r4,1
81124c84:	44000115 	stw	r16,4(r8)
81124c88:	d8c02015 	stw	r3,128(sp)
81124c8c:	d9001f15 	stw	r4,124(sp)
81124c90:	014001c4 	movi	r5,7
81124c94:	2901e616 	blt	r5,r4,81125430 <___svfprintf_internal_r+0x1c70>
81124c98:	42000204 	addi	r8,r8,8
81124c9c:	8001f616 	blt	r16,zero,81125478 <___svfprintf_internal_r+0x1cb8>
81124ca0:	1421c83a 	sub	r16,r2,r16
81124ca4:	043d1c0e 	bge	zero,r16,81124118 <__reset+0xfb104118>
81124ca8:	04400404 	movi	r17,16
81124cac:	d8801f17 	ldw	r2,124(sp)
81124cb0:	8c3edd0e 	bge	r17,r16,81124828 <__reset+0xfb104828>
81124cb4:	01604574 	movhi	r5,33045
81124cb8:	29434784 	addi	r5,r5,3358
81124cbc:	d9402b15 	stw	r5,172(sp)
81124cc0:	058001c4 	movi	r22,7
81124cc4:	dd002c17 	ldw	r20,176(sp)
81124cc8:	00000306 	br	81124cd8 <___svfprintf_internal_r+0x1518>
81124ccc:	42000204 	addi	r8,r8,8
81124cd0:	843ffc04 	addi	r16,r16,-16
81124cd4:	8c3ed70e 	bge	r17,r16,81124834 <__reset+0xfb104834>
81124cd8:	18c00404 	addi	r3,r3,16
81124cdc:	10800044 	addi	r2,r2,1
81124ce0:	45400015 	stw	r21,0(r8)
81124ce4:	44400115 	stw	r17,4(r8)
81124ce8:	d8c02015 	stw	r3,128(sp)
81124cec:	d8801f15 	stw	r2,124(sp)
81124cf0:	b0bff60e 	bge	r22,r2,81124ccc <__reset+0xfb104ccc>
81124cf4:	d9801e04 	addi	r6,sp,120
81124cf8:	a00b883a 	mov	r5,r20
81124cfc:	9809883a 	mov	r4,r19
81124d00:	11300f80 	call	811300f8 <__ssprint_r>
81124d04:	103b951e 	bne	r2,zero,81123b5c <__reset+0xfb103b5c>
81124d08:	d8c02017 	ldw	r3,128(sp)
81124d0c:	d8801f17 	ldw	r2,124(sp)
81124d10:	da000404 	addi	r8,sp,16
81124d14:	003fee06 	br	81124cd0 <__reset+0xfb104cd0>
81124d18:	9088703a 	and	r4,r18,r2
81124d1c:	203e8d1e 	bne	r4,zero,81124754 <__reset+0xfb104754>
81124d20:	dc401f17 	ldw	r17,124(sp)
81124d24:	40800115 	stw	r2,4(r8)
81124d28:	44000015 	stw	r16,0(r8)
81124d2c:	8c400044 	addi	r17,r17,1
81124d30:	d8c02015 	stw	r3,128(sp)
81124d34:	dc401f15 	stw	r17,124(sp)
81124d38:	008001c4 	movi	r2,7
81124d3c:	147f7f16 	blt	r2,r17,81124b3c <__reset+0xfb104b3c>
81124d40:	45800204 	addi	r22,r8,8
81124d44:	003eac06 	br	811247f8 <__reset+0xfb1047f8>
81124d48:	d9402c17 	ldw	r5,176(sp)
81124d4c:	d9801e04 	addi	r6,sp,120
81124d50:	9809883a 	mov	r4,r19
81124d54:	11300f80 	call	811300f8 <__ssprint_r>
81124d58:	103b801e 	bne	r2,zero,81123b5c <__reset+0xfb103b5c>
81124d5c:	d8c02017 	ldw	r3,128(sp)
81124d60:	dc401f17 	ldw	r17,124(sp)
81124d64:	da000404 	addi	r8,sp,16
81124d68:	003e8406 	br	8112477c <__reset+0xfb10477c>
81124d6c:	d9402c17 	ldw	r5,176(sp)
81124d70:	d9801e04 	addi	r6,sp,120
81124d74:	9809883a 	mov	r4,r19
81124d78:	11300f80 	call	811300f8 <__ssprint_r>
81124d7c:	103b771e 	bne	r2,zero,81123b5c <__reset+0xfb103b5c>
81124d80:	d8c02017 	ldw	r3,128(sp)
81124d84:	dc401f17 	ldw	r17,124(sp)
81124d88:	dd800404 	addi	r22,sp,16
81124d8c:	003e8606 	br	811247a8 <__reset+0xfb1047a8>
81124d90:	0029883a 	mov	r20,zero
81124d94:	a5000c04 	addi	r20,r20,48
81124d98:	dc001dc4 	addi	r16,sp,119
81124d9c:	dd001dc5 	stb	r20,119(sp)
81124da0:	003f3806 	br	81124a84 <__reset+0xfb104a84>
81124da4:	d9402c17 	ldw	r5,176(sp)
81124da8:	d9801e04 	addi	r6,sp,120
81124dac:	9809883a 	mov	r4,r19
81124db0:	11300f80 	call	811300f8 <__ssprint_r>
81124db4:	103b691e 	bne	r2,zero,81123b5c <__reset+0xfb103b5c>
81124db8:	d8c02017 	ldw	r3,128(sp)
81124dbc:	da000404 	addi	r8,sp,16
81124dc0:	003c9506 	br	81124018 <__reset+0xfb104018>
81124dc4:	d9003617 	ldw	r4,216(sp)
81124dc8:	d9403717 	ldw	r5,220(sp)
81124dcc:	da003e15 	stw	r8,248(sp)
81124dd0:	112e1f40 	call	8112e1f4 <__fpclassifyd>
81124dd4:	da003e17 	ldw	r8,248(sp)
81124dd8:	1000bd1e 	bne	r2,zero,811250d0 <___svfprintf_internal_r+0x1910>
81124ddc:	008011c4 	movi	r2,71
81124de0:	14411e0e 	bge	r2,r17,8112525c <___svfprintf_internal_r+0x1a9c>
81124de4:	04204574 	movhi	r16,33045
81124de8:	84033a04 	addi	r16,r16,3304
81124dec:	00c000c4 	movi	r3,3
81124df0:	00bfdfc4 	movi	r2,-129
81124df4:	d8c02a15 	stw	r3,168(sp)
81124df8:	90a4703a 	and	r18,r18,r2
81124dfc:	df002783 	ldbu	fp,158(sp)
81124e00:	d8c02e15 	stw	r3,184(sp)
81124e04:	d8002915 	stw	zero,164(sp)
81124e08:	d8003215 	stw	zero,200(sp)
81124e0c:	003c1c06 	br	81123e80 <__reset+0xfb103e80>
81124e10:	9080100c 	andi	r2,r18,64
81124e14:	d8002785 	stb	zero,158(sp)
81124e18:	10009426 	beq	r2,zero,8112506c <___svfprintf_internal_r+0x18ac>
81124e1c:	d8c02d17 	ldw	r3,180(sp)
81124e20:	d9002917 	ldw	r4,164(sp)
81124e24:	002d883a 	mov	r22,zero
81124e28:	18800104 	addi	r2,r3,4
81124e2c:	1d00000b 	ldhu	r20,0(r3)
81124e30:	203ec10e 	bge	r4,zero,81124938 <__reset+0xfb104938>
81124e34:	a586b03a 	or	r3,r20,r22
81124e38:	d8802d15 	stw	r2,180(sp)
81124e3c:	183ec21e 	bne	r3,zero,81124948 <__reset+0xfb104948>
81124e40:	0039883a 	mov	fp,zero
81124e44:	0005883a 	mov	r2,zero
81124e48:	003db806 	br	8112452c <__reset+0xfb10452c>
81124e4c:	d8802d17 	ldw	r2,180(sp)
81124e50:	d8c02d17 	ldw	r3,180(sp)
81124e54:	d9002d17 	ldw	r4,180(sp)
81124e58:	10800017 	ldw	r2,0(r2)
81124e5c:	18c00117 	ldw	r3,4(r3)
81124e60:	21000204 	addi	r4,r4,8
81124e64:	d8803615 	stw	r2,216(sp)
81124e68:	d8c03715 	stw	r3,220(sp)
81124e6c:	d9002d15 	stw	r4,180(sp)
81124e70:	003b8206 	br	81123c7c <__reset+0xfb103c7c>
81124e74:	9080100c 	andi	r2,r18,64
81124e78:	10010726 	beq	r2,zero,81125298 <___svfprintf_internal_r+0x1ad8>
81124e7c:	d8c02d17 	ldw	r3,180(sp)
81124e80:	1d00000f 	ldh	r20,0(r3)
81124e84:	18c00104 	addi	r3,r3,4
81124e88:	d8c02d15 	stw	r3,180(sp)
81124e8c:	a02dd7fa 	srai	r22,r20,31
81124e90:	b005883a 	mov	r2,r22
81124e94:	003ba206 	br	81123d20 <__reset+0xfb103d20>
81124e98:	9080100c 	andi	r2,r18,64
81124e9c:	10010526 	beq	r2,zero,811252b4 <___svfprintf_internal_r+0x1af4>
81124ea0:	d9002d17 	ldw	r4,180(sp)
81124ea4:	002d883a 	mov	r22,zero
81124ea8:	2500000b 	ldhu	r20,0(r4)
81124eac:	21000104 	addi	r4,r4,4
81124eb0:	d9002d15 	stw	r4,180(sp)
81124eb4:	003cfe06 	br	811242b0 <__reset+0xfb1042b0>
81124eb8:	bc400007 	ldb	r17,0(r23)
81124ebc:	003a9606 	br	81123918 <__reset+0xfb103918>
81124ec0:	9080040c 	andi	r2,r18,16
81124ec4:	10010126 	beq	r2,zero,811252cc <___svfprintf_internal_r+0x1b0c>
81124ec8:	d9402d17 	ldw	r5,180(sp)
81124ecc:	d8c02f17 	ldw	r3,188(sp)
81124ed0:	28800017 	ldw	r2,0(r5)
81124ed4:	29400104 	addi	r5,r5,4
81124ed8:	d9402d15 	stw	r5,180(sp)
81124edc:	10c00015 	stw	r3,0(r2)
81124ee0:	003a6406 	br	81123874 <__reset+0xfb103874>
81124ee4:	d9002917 	ldw	r4,164(sp)
81124ee8:	d8002785 	stb	zero,158(sp)
81124eec:	203d8d16 	blt	r4,zero,81124524 <__reset+0xfb104524>
81124ef0:	00bfdfc4 	movi	r2,-129
81124ef4:	90a4703a 	and	r18,r18,r2
81124ef8:	003b0506 	br	81123b10 <__reset+0xfb103b10>
81124efc:	01604574 	movhi	r5,33045
81124f00:	29434784 	addi	r5,r5,3358
81124f04:	d9402b15 	stw	r5,172(sp)
81124f08:	d9402b17 	ldw	r5,172(sp)
81124f0c:	1c47883a 	add	r3,r3,r17
81124f10:	10800044 	addi	r2,r2,1
81124f14:	41400015 	stw	r5,0(r8)
81124f18:	44400115 	stw	r17,4(r8)
81124f1c:	d8c02015 	stw	r3,128(sp)
81124f20:	d8801f15 	stw	r2,124(sp)
81124f24:	010001c4 	movi	r4,7
81124f28:	20bf3016 	blt	r4,r2,81124bec <__reset+0xfb104bec>
81124f2c:	42000204 	addi	r8,r8,8
81124f30:	003f3506 	br	81124c08 <__reset+0xfb104c08>
81124f34:	01204574 	movhi	r4,33045
81124f38:	21034784 	addi	r4,r4,3358
81124f3c:	d9002b15 	stw	r4,172(sp)
81124f40:	003c5e06 	br	811240bc <__reset+0xfb1040bc>
81124f44:	d9402c17 	ldw	r5,176(sp)
81124f48:	d9801e04 	addi	r6,sp,120
81124f4c:	9809883a 	mov	r4,r19
81124f50:	11300f80 	call	811300f8 <__ssprint_r>
81124f54:	103b011e 	bne	r2,zero,81123b5c <__reset+0xfb103b5c>
81124f58:	d8c02017 	ldw	r3,128(sp)
81124f5c:	da000404 	addi	r8,sp,16
81124f60:	003d9306 	br	811245b0 <__reset+0xfb1045b0>
81124f64:	d8801f17 	ldw	r2,124(sp)
81124f68:	01604574 	movhi	r5,33045
81124f6c:	01000044 	movi	r4,1
81124f70:	18c00044 	addi	r3,r3,1
81124f74:	10800044 	addi	r2,r2,1
81124f78:	29434704 	addi	r5,r5,3356
81124f7c:	41000115 	stw	r4,4(r8)
81124f80:	41400015 	stw	r5,0(r8)
81124f84:	d8c02015 	stw	r3,128(sp)
81124f88:	d8801f15 	stw	r2,124(sp)
81124f8c:	010001c4 	movi	r4,7
81124f90:	2080b516 	blt	r4,r2,81125268 <___svfprintf_internal_r+0x1aa8>
81124f94:	42000204 	addi	r8,r8,8
81124f98:	8800041e 	bne	r17,zero,81124fac <___svfprintf_internal_r+0x17ec>
81124f9c:	d8803317 	ldw	r2,204(sp)
81124fa0:	1000021e 	bne	r2,zero,81124fac <___svfprintf_internal_r+0x17ec>
81124fa4:	9080004c 	andi	r2,r18,1
81124fa8:	103c5b26 	beq	r2,zero,81124118 <__reset+0xfb104118>
81124fac:	d9003817 	ldw	r4,224(sp)
81124fb0:	d8801f17 	ldw	r2,124(sp)
81124fb4:	d9403417 	ldw	r5,208(sp)
81124fb8:	20c7883a 	add	r3,r4,r3
81124fbc:	10800044 	addi	r2,r2,1
81124fc0:	41000115 	stw	r4,4(r8)
81124fc4:	41400015 	stw	r5,0(r8)
81124fc8:	d8c02015 	stw	r3,128(sp)
81124fcc:	d8801f15 	stw	r2,124(sp)
81124fd0:	010001c4 	movi	r4,7
81124fd4:	20818016 	blt	r4,r2,811255d8 <___svfprintf_internal_r+0x1e18>
81124fd8:	42000204 	addi	r8,r8,8
81124fdc:	0463c83a 	sub	r17,zero,r17
81124fe0:	0440cb0e 	bge	zero,r17,81125310 <___svfprintf_internal_r+0x1b50>
81124fe4:	05800404 	movi	r22,16
81124fe8:	b440e80e 	bge	r22,r17,8112538c <___svfprintf_internal_r+0x1bcc>
81124fec:	01604574 	movhi	r5,33045
81124ff0:	29434784 	addi	r5,r5,3358
81124ff4:	d9402b15 	stw	r5,172(sp)
81124ff8:	070001c4 	movi	fp,7
81124ffc:	dd002c17 	ldw	r20,176(sp)
81125000:	00000306 	br	81125010 <___svfprintf_internal_r+0x1850>
81125004:	42000204 	addi	r8,r8,8
81125008:	8c7ffc04 	addi	r17,r17,-16
8112500c:	b440e20e 	bge	r22,r17,81125398 <___svfprintf_internal_r+0x1bd8>
81125010:	18c00404 	addi	r3,r3,16
81125014:	10800044 	addi	r2,r2,1
81125018:	45400015 	stw	r21,0(r8)
8112501c:	45800115 	stw	r22,4(r8)
81125020:	d8c02015 	stw	r3,128(sp)
81125024:	d8801f15 	stw	r2,124(sp)
81125028:	e0bff60e 	bge	fp,r2,81125004 <__reset+0xfb105004>
8112502c:	d9801e04 	addi	r6,sp,120
81125030:	a00b883a 	mov	r5,r20
81125034:	9809883a 	mov	r4,r19
81125038:	11300f80 	call	811300f8 <__ssprint_r>
8112503c:	103ac71e 	bne	r2,zero,81123b5c <__reset+0xfb103b5c>
81125040:	d8c02017 	ldw	r3,128(sp)
81125044:	d8801f17 	ldw	r2,124(sp)
81125048:	da000404 	addi	r8,sp,16
8112504c:	003fee06 	br	81125008 <__reset+0xfb105008>
81125050:	d8c02d17 	ldw	r3,180(sp)
81125054:	d9002917 	ldw	r4,164(sp)
81125058:	002d883a 	mov	r22,zero
8112505c:	18800104 	addi	r2,r3,4
81125060:	1d000017 	ldw	r20,0(r3)
81125064:	203e7d0e 	bge	r4,zero,81124a5c <__reset+0xfb104a5c>
81125068:	003eda06 	br	81124bd4 <__reset+0xfb104bd4>
8112506c:	d9402d17 	ldw	r5,180(sp)
81125070:	d8c02917 	ldw	r3,164(sp)
81125074:	002d883a 	mov	r22,zero
81125078:	28800104 	addi	r2,r5,4
8112507c:	2d000017 	ldw	r20,0(r5)
81125080:	183e2d0e 	bge	r3,zero,81124938 <__reset+0xfb104938>
81125084:	003f6b06 	br	81124e34 <__reset+0xfb104e34>
81125088:	d8c02d15 	stw	r3,180(sp)
8112508c:	0039883a 	mov	fp,zero
81125090:	003ed206 	br	81124bdc <__reset+0xfb104bdc>
81125094:	bc400043 	ldbu	r17,1(r23)
81125098:	94800814 	ori	r18,r18,32
8112509c:	bdc00044 	addi	r23,r23,1
811250a0:	8c403fcc 	andi	r17,r17,255
811250a4:	8c40201c 	xori	r17,r17,128
811250a8:	8c7fe004 	addi	r17,r17,-128
811250ac:	003a1a06 	br	81123918 <__reset+0xfb103918>
811250b0:	d9402c17 	ldw	r5,176(sp)
811250b4:	d9801e04 	addi	r6,sp,120
811250b8:	9809883a 	mov	r4,r19
811250bc:	11300f80 	call	811300f8 <__ssprint_r>
811250c0:	103aa61e 	bne	r2,zero,81123b5c <__reset+0xfb103b5c>
811250c4:	d8c02017 	ldw	r3,128(sp)
811250c8:	da000404 	addi	r8,sp,16
811250cc:	003d4a06 	br	811245f8 <__reset+0xfb1045f8>
811250d0:	d9002917 	ldw	r4,164(sp)
811250d4:	05bff7c4 	movi	r22,-33
811250d8:	00bfffc4 	movi	r2,-1
811250dc:	8dac703a 	and	r22,r17,r22
811250e0:	20806a26 	beq	r4,r2,8112528c <___svfprintf_internal_r+0x1acc>
811250e4:	008011c4 	movi	r2,71
811250e8:	b0813726 	beq	r22,r2,811255c8 <___svfprintf_internal_r+0x1e08>
811250ec:	d9003717 	ldw	r4,220(sp)
811250f0:	90c04014 	ori	r3,r18,256
811250f4:	d8c02b15 	stw	r3,172(sp)
811250f8:	20015d16 	blt	r4,zero,81125670 <___svfprintf_internal_r+0x1eb0>
811250fc:	dd003717 	ldw	r20,220(sp)
81125100:	d8002a05 	stb	zero,168(sp)
81125104:	00801984 	movi	r2,102
81125108:	88814026 	beq	r17,r2,8112560c <___svfprintf_internal_r+0x1e4c>
8112510c:	00801184 	movi	r2,70
81125110:	88817126 	beq	r17,r2,811256d8 <___svfprintf_internal_r+0x1f18>
81125114:	00801144 	movi	r2,69
81125118:	b0816226 	beq	r22,r2,811256a4 <___svfprintf_internal_r+0x1ee4>
8112511c:	d8c02917 	ldw	r3,164(sp)
81125120:	d8802104 	addi	r2,sp,132
81125124:	d8800315 	stw	r2,12(sp)
81125128:	d9403617 	ldw	r5,216(sp)
8112512c:	d8802504 	addi	r2,sp,148
81125130:	d8800215 	stw	r2,8(sp)
81125134:	d8802604 	addi	r2,sp,152
81125138:	d8c00015 	stw	r3,0(sp)
8112513c:	d8800115 	stw	r2,4(sp)
81125140:	01c00084 	movi	r7,2
81125144:	a00d883a 	mov	r6,r20
81125148:	9809883a 	mov	r4,r19
8112514c:	d8c03d15 	stw	r3,244(sp)
81125150:	da003e15 	stw	r8,248(sp)
81125154:	1129aac0 	call	81129aac <_dtoa_r>
81125158:	1021883a 	mov	r16,r2
8112515c:	008019c4 	movi	r2,103
81125160:	d8c03d17 	ldw	r3,244(sp)
81125164:	da003e17 	ldw	r8,248(sp)
81125168:	8880e726 	beq	r17,r2,81125508 <___svfprintf_internal_r+0x1d48>
8112516c:	008011c4 	movi	r2,71
81125170:	8880d426 	beq	r17,r2,811254c4 <___svfprintf_internal_r+0x1d04>
81125174:	80f9883a 	add	fp,r16,r3
81125178:	d9003617 	ldw	r4,216(sp)
8112517c:	000d883a 	mov	r6,zero
81125180:	000f883a 	mov	r7,zero
81125184:	a00b883a 	mov	r5,r20
81125188:	da003e15 	stw	r8,248(sp)
8112518c:	11360740 	call	81136074 <__eqdf2>
81125190:	da003e17 	ldw	r8,248(sp)
81125194:	1000e426 	beq	r2,zero,81125528 <___svfprintf_internal_r+0x1d68>
81125198:	d8802117 	ldw	r2,132(sp)
8112519c:	1700062e 	bgeu	r2,fp,811251b8 <___svfprintf_internal_r+0x19f8>
811251a0:	01000c04 	movi	r4,48
811251a4:	10c00044 	addi	r3,r2,1
811251a8:	d8c02115 	stw	r3,132(sp)
811251ac:	11000005 	stb	r4,0(r2)
811251b0:	d8802117 	ldw	r2,132(sp)
811251b4:	173ffb36 	bltu	r2,fp,811251a4 <__reset+0xfb1051a4>
811251b8:	1405c83a 	sub	r2,r2,r16
811251bc:	d8803315 	stw	r2,204(sp)
811251c0:	008011c4 	movi	r2,71
811251c4:	b080c526 	beq	r22,r2,811254dc <___svfprintf_internal_r+0x1d1c>
811251c8:	00801944 	movi	r2,101
811251cc:	1441d90e 	bge	r2,r17,81125934 <___svfprintf_internal_r+0x2174>
811251d0:	d8c02617 	ldw	r3,152(sp)
811251d4:	00801984 	movi	r2,102
811251d8:	d8c03215 	stw	r3,200(sp)
811251dc:	88813426 	beq	r17,r2,811256b0 <___svfprintf_internal_r+0x1ef0>
811251e0:	d8c03217 	ldw	r3,200(sp)
811251e4:	d9003317 	ldw	r4,204(sp)
811251e8:	19012516 	blt	r3,r4,81125680 <___svfprintf_internal_r+0x1ec0>
811251ec:	9480004c 	andi	r18,r18,1
811251f0:	9001841e 	bne	r18,zero,81125804 <___svfprintf_internal_r+0x2044>
811251f4:	1805883a 	mov	r2,r3
811251f8:	1801cc16 	blt	r3,zero,8112592c <___svfprintf_internal_r+0x216c>
811251fc:	d8c03217 	ldw	r3,200(sp)
81125200:	044019c4 	movi	r17,103
81125204:	d8c02e15 	stw	r3,184(sp)
81125208:	df002a07 	ldb	fp,168(sp)
8112520c:	e000a61e 	bne	fp,zero,811254a8 <___svfprintf_internal_r+0x1ce8>
81125210:	df002783 	ldbu	fp,158(sp)
81125214:	d8802a15 	stw	r2,168(sp)
81125218:	dc802b17 	ldw	r18,172(sp)
8112521c:	d8002915 	stw	zero,164(sp)
81125220:	003b1706 	br	81123e80 <__reset+0xfb103e80>
81125224:	04204574 	movhi	r16,33045
81125228:	84033704 	addi	r16,r16,3292
8112522c:	003aa606 	br	81123cc8 <__reset+0xfb103cc8>
81125230:	d9003917 	ldw	r4,228(sp)
81125234:	04001004 	movi	r16,64
81125238:	800b883a 	mov	r5,r16
8112523c:	1121e7c0 	call	81121e7c <_malloc_r>
81125240:	d9002c17 	ldw	r4,176(sp)
81125244:	20800015 	stw	r2,0(r4)
81125248:	20800415 	stw	r2,16(r4)
8112524c:	1001cb26 	beq	r2,zero,8112597c <___svfprintf_internal_r+0x21bc>
81125250:	d8802c17 	ldw	r2,176(sp)
81125254:	14000515 	stw	r16,20(r2)
81125258:	00397606 	br	81123834 <__reset+0xfb103834>
8112525c:	04204574 	movhi	r16,33045
81125260:	84033904 	addi	r16,r16,3300
81125264:	003ee106 	br	81124dec <__reset+0xfb104dec>
81125268:	d9402c17 	ldw	r5,176(sp)
8112526c:	d9801e04 	addi	r6,sp,120
81125270:	9809883a 	mov	r4,r19
81125274:	11300f80 	call	811300f8 <__ssprint_r>
81125278:	103a381e 	bne	r2,zero,81123b5c <__reset+0xfb103b5c>
8112527c:	dc402617 	ldw	r17,152(sp)
81125280:	d8c02017 	ldw	r3,128(sp)
81125284:	da000404 	addi	r8,sp,16
81125288:	003f4306 	br	81124f98 <__reset+0xfb104f98>
8112528c:	01400184 	movi	r5,6
81125290:	d9402915 	stw	r5,164(sp)
81125294:	003f9506 	br	811250ec <__reset+0xfb1050ec>
81125298:	d9002d17 	ldw	r4,180(sp)
8112529c:	25000017 	ldw	r20,0(r4)
811252a0:	21000104 	addi	r4,r4,4
811252a4:	d9002d15 	stw	r4,180(sp)
811252a8:	a02dd7fa 	srai	r22,r20,31
811252ac:	b005883a 	mov	r2,r22
811252b0:	003a9b06 	br	81123d20 <__reset+0xfb103d20>
811252b4:	d9402d17 	ldw	r5,180(sp)
811252b8:	002d883a 	mov	r22,zero
811252bc:	2d000017 	ldw	r20,0(r5)
811252c0:	29400104 	addi	r5,r5,4
811252c4:	d9402d15 	stw	r5,180(sp)
811252c8:	003bf906 	br	811242b0 <__reset+0xfb1042b0>
811252cc:	9480100c 	andi	r18,r18,64
811252d0:	90006e26 	beq	r18,zero,8112548c <___svfprintf_internal_r+0x1ccc>
811252d4:	d9002d17 	ldw	r4,180(sp)
811252d8:	d9402f17 	ldw	r5,188(sp)
811252dc:	20800017 	ldw	r2,0(r4)
811252e0:	21000104 	addi	r4,r4,4
811252e4:	d9002d15 	stw	r4,180(sp)
811252e8:	1140000d 	sth	r5,0(r2)
811252ec:	00396106 	br	81123874 <__reset+0xfb103874>
811252f0:	d9402c17 	ldw	r5,176(sp)
811252f4:	d9801e04 	addi	r6,sp,120
811252f8:	9809883a 	mov	r4,r19
811252fc:	11300f80 	call	811300f8 <__ssprint_r>
81125300:	103a161e 	bne	r2,zero,81123b5c <__reset+0xfb103b5c>
81125304:	d8c02017 	ldw	r3,128(sp)
81125308:	d8801f17 	ldw	r2,124(sp)
8112530c:	da000404 	addi	r8,sp,16
81125310:	d9403317 	ldw	r5,204(sp)
81125314:	10800044 	addi	r2,r2,1
81125318:	44000015 	stw	r16,0(r8)
8112531c:	28c7883a 	add	r3,r5,r3
81125320:	003b7706 	br	81124100 <__reset+0xfb104100>
81125324:	8009883a 	mov	r4,r16
81125328:	da003e15 	stw	r8,248(sp)
8112532c:	11231840 	call	81123184 <strlen>
81125330:	d8802e15 	stw	r2,184(sp)
81125334:	da003e17 	ldw	r8,248(sp)
81125338:	103c280e 	bge	r2,zero,811243dc <__reset+0xfb1043dc>
8112533c:	0005883a 	mov	r2,zero
81125340:	003c2606 	br	811243dc <__reset+0xfb1043dc>
81125344:	00bfffc4 	movi	r2,-1
81125348:	003a0906 	br	81123b70 <__reset+0xfb103b70>
8112534c:	01204574 	movhi	r4,33045
81125350:	21034b84 	addi	r4,r4,3374
81125354:	d9003515 	stw	r4,212(sp)
81125358:	003b0606 	br	81123f74 <__reset+0xfb103f74>
8112535c:	013fffc4 	movi	r4,-1
81125360:	003a2706 	br	81123c00 <__reset+0xfb103c00>
81125364:	d9402c17 	ldw	r5,176(sp)
81125368:	d9801e04 	addi	r6,sp,120
8112536c:	9809883a 	mov	r4,r19
81125370:	11300f80 	call	811300f8 <__ssprint_r>
81125374:	1039f91e 	bne	r2,zero,81123b5c <__reset+0xfb103b5c>
81125378:	d8c02017 	ldw	r3,128(sp)
8112537c:	da000404 	addi	r8,sp,16
81125380:	003d8406 	br	81124994 <__reset+0xfb104994>
81125384:	0023883a 	mov	r17,zero
81125388:	003d8306 	br	81124998 <__reset+0xfb104998>
8112538c:	01204574 	movhi	r4,33045
81125390:	21034784 	addi	r4,r4,3358
81125394:	d9002b15 	stw	r4,172(sp)
81125398:	d9002b17 	ldw	r4,172(sp)
8112539c:	1c47883a 	add	r3,r3,r17
811253a0:	10800044 	addi	r2,r2,1
811253a4:	41000015 	stw	r4,0(r8)
811253a8:	44400115 	stw	r17,4(r8)
811253ac:	d8c02015 	stw	r3,128(sp)
811253b0:	d8801f15 	stw	r2,124(sp)
811253b4:	010001c4 	movi	r4,7
811253b8:	20bfcd16 	blt	r4,r2,811252f0 <__reset+0xfb1052f0>
811253bc:	42000204 	addi	r8,r8,8
811253c0:	003fd306 	br	81125310 <__reset+0xfb105310>
811253c4:	d9402c17 	ldw	r5,176(sp)
811253c8:	d9801e04 	addi	r6,sp,120
811253cc:	9809883a 	mov	r4,r19
811253d0:	11300f80 	call	811300f8 <__ssprint_r>
811253d4:	1039e11e 	bne	r2,zero,81123b5c <__reset+0xfb103b5c>
811253d8:	d8802617 	ldw	r2,152(sp)
811253dc:	d8c02017 	ldw	r3,128(sp)
811253e0:	da000404 	addi	r8,sp,16
811253e4:	003e1c06 	br	81124c58 <__reset+0xfb104c58>
811253e8:	d8802917 	ldw	r2,164(sp)
811253ec:	00c00184 	movi	r3,6
811253f0:	1880012e 	bgeu	r3,r2,811253f8 <___svfprintf_internal_r+0x1c38>
811253f4:	1805883a 	mov	r2,r3
811253f8:	d8802e15 	stw	r2,184(sp)
811253fc:	1000f316 	blt	r2,zero,811257cc <___svfprintf_internal_r+0x200c>
81125400:	04204574 	movhi	r16,33045
81125404:	d8802a15 	stw	r2,168(sp)
81125408:	dd002d15 	stw	r20,180(sp)
8112540c:	d8002915 	stw	zero,164(sp)
81125410:	d8003215 	stw	zero,200(sp)
81125414:	84034504 	addi	r16,r16,3348
81125418:	0039883a 	mov	fp,zero
8112541c:	003a9f06 	br	81123e9c <__reset+0xfb103e9c>
81125420:	01204574 	movhi	r4,33045
81125424:	21034b84 	addi	r4,r4,3374
81125428:	d9003515 	stw	r4,212(sp)
8112542c:	003b5f06 	br	811241ac <__reset+0xfb1041ac>
81125430:	d9402c17 	ldw	r5,176(sp)
81125434:	d9801e04 	addi	r6,sp,120
81125438:	9809883a 	mov	r4,r19
8112543c:	11300f80 	call	811300f8 <__ssprint_r>
81125440:	1039c61e 	bne	r2,zero,81123b5c <__reset+0xfb103b5c>
81125444:	d8802617 	ldw	r2,152(sp)
81125448:	d9403317 	ldw	r5,204(sp)
8112544c:	d8c02017 	ldw	r3,128(sp)
81125450:	da000404 	addi	r8,sp,16
81125454:	2885c83a 	sub	r2,r5,r2
81125458:	003e1006 	br	81124c9c <__reset+0xfb104c9c>
8112545c:	00800044 	movi	r2,1
81125460:	10803fcc 	andi	r2,r2,255
81125464:	00c00044 	movi	r3,1
81125468:	10fa3526 	beq	r2,r3,81123d40 <__reset+0xfb103d40>
8112546c:	00c00084 	movi	r3,2
81125470:	10fb9e26 	beq	r2,r3,811242ec <__reset+0xfb1042ec>
81125474:	003a6406 	br	81123e08 <__reset+0xfb103e08>
81125478:	0021883a 	mov	r16,zero
8112547c:	003e0806 	br	81124ca0 <__reset+0xfb104ca0>
81125480:	07000b44 	movi	fp,45
81125484:	df002785 	stb	fp,158(sp)
81125488:	003a0b06 	br	81123cb8 <__reset+0xfb103cb8>
8112548c:	d8c02d17 	ldw	r3,180(sp)
81125490:	d9002f17 	ldw	r4,188(sp)
81125494:	18800017 	ldw	r2,0(r3)
81125498:	18c00104 	addi	r3,r3,4
8112549c:	d8c02d15 	stw	r3,180(sp)
811254a0:	11000015 	stw	r4,0(r2)
811254a4:	0038f306 	br	81123874 <__reset+0xfb103874>
811254a8:	00c00b44 	movi	r3,45
811254ac:	d8c02785 	stb	r3,158(sp)
811254b0:	d8802a15 	stw	r2,168(sp)
811254b4:	dc802b17 	ldw	r18,172(sp)
811254b8:	d8002915 	stw	zero,164(sp)
811254bc:	07000b44 	movi	fp,45
811254c0:	003a7306 	br	81123e90 <__reset+0xfb103e90>
811254c4:	9080004c 	andi	r2,r18,1
811254c8:	1000941e 	bne	r2,zero,8112571c <___svfprintf_internal_r+0x1f5c>
811254cc:	d8802117 	ldw	r2,132(sp)
811254d0:	1405c83a 	sub	r2,r2,r16
811254d4:	d8803315 	stw	r2,204(sp)
811254d8:	b441161e 	bne	r22,r17,81125934 <___svfprintf_internal_r+0x2174>
811254dc:	dd802617 	ldw	r22,152(sp)
811254e0:	00bfff44 	movi	r2,-3
811254e4:	b0801a16 	blt	r22,r2,81125550 <___svfprintf_internal_r+0x1d90>
811254e8:	d9402917 	ldw	r5,164(sp)
811254ec:	2d801816 	blt	r5,r22,81125550 <___svfprintf_internal_r+0x1d90>
811254f0:	dd803215 	stw	r22,200(sp)
811254f4:	003f3a06 	br	811251e0 <__reset+0xfb1051e0>
811254f8:	1025883a 	mov	r18,r2
811254fc:	0039883a 	mov	fp,zero
81125500:	00800084 	movi	r2,2
81125504:	003fd606 	br	81125460 <__reset+0xfb105460>
81125508:	9080004c 	andi	r2,r18,1
8112550c:	103f191e 	bne	r2,zero,81125174 <__reset+0xfb105174>
81125510:	d8802117 	ldw	r2,132(sp)
81125514:	003f2806 	br	811251b8 <__reset+0xfb1051b8>
81125518:	01204574 	movhi	r4,33045
8112551c:	21034784 	addi	r4,r4,3358
81125520:	d9002b15 	stw	r4,172(sp)
81125524:	003c7c06 	br	81124718 <__reset+0xfb104718>
81125528:	e005883a 	mov	r2,fp
8112552c:	003f2206 	br	811251b8 <__reset+0xfb1051b8>
81125530:	d9402917 	ldw	r5,164(sp)
81125534:	df002783 	ldbu	fp,158(sp)
81125538:	dd002d15 	stw	r20,180(sp)
8112553c:	d9402a15 	stw	r5,168(sp)
81125540:	d9402e15 	stw	r5,184(sp)
81125544:	d8002915 	stw	zero,164(sp)
81125548:	d8003215 	stw	zero,200(sp)
8112554c:	003a4c06 	br	81123e80 <__reset+0xfb103e80>
81125550:	8c7fff84 	addi	r17,r17,-2
81125554:	b5bfffc4 	addi	r22,r22,-1
81125558:	dd802615 	stw	r22,152(sp)
8112555c:	dc4022c5 	stb	r17,139(sp)
81125560:	b000c316 	blt	r22,zero,81125870 <___svfprintf_internal_r+0x20b0>
81125564:	00800ac4 	movi	r2,43
81125568:	d8802305 	stb	r2,140(sp)
8112556c:	00800244 	movi	r2,9
81125570:	15806e16 	blt	r2,r22,8112572c <___svfprintf_internal_r+0x1f6c>
81125574:	00800c04 	movi	r2,48
81125578:	b5800c04 	addi	r22,r22,48
8112557c:	d8802345 	stb	r2,141(sp)
81125580:	dd802385 	stb	r22,142(sp)
81125584:	d88023c4 	addi	r2,sp,143
81125588:	df0022c4 	addi	fp,sp,139
8112558c:	d8c03317 	ldw	r3,204(sp)
81125590:	1739c83a 	sub	fp,r2,fp
81125594:	d9003317 	ldw	r4,204(sp)
81125598:	e0c7883a 	add	r3,fp,r3
8112559c:	df003b15 	stw	fp,236(sp)
811255a0:	d8c02e15 	stw	r3,184(sp)
811255a4:	00800044 	movi	r2,1
811255a8:	1100b70e 	bge	r2,r4,81125888 <___svfprintf_internal_r+0x20c8>
811255ac:	d8c02e17 	ldw	r3,184(sp)
811255b0:	18c00044 	addi	r3,r3,1
811255b4:	d8c02e15 	stw	r3,184(sp)
811255b8:	1805883a 	mov	r2,r3
811255bc:	1800b016 	blt	r3,zero,81125880 <___svfprintf_internal_r+0x20c0>
811255c0:	d8003215 	stw	zero,200(sp)
811255c4:	003f1006 	br	81125208 <__reset+0xfb105208>
811255c8:	d8802917 	ldw	r2,164(sp)
811255cc:	103ec71e 	bne	r2,zero,811250ec <__reset+0xfb1050ec>
811255d0:	dc002915 	stw	r16,164(sp)
811255d4:	003ec506 	br	811250ec <__reset+0xfb1050ec>
811255d8:	d9402c17 	ldw	r5,176(sp)
811255dc:	d9801e04 	addi	r6,sp,120
811255e0:	9809883a 	mov	r4,r19
811255e4:	11300f80 	call	811300f8 <__ssprint_r>
811255e8:	10395c1e 	bne	r2,zero,81123b5c <__reset+0xfb103b5c>
811255ec:	dc402617 	ldw	r17,152(sp)
811255f0:	d8c02017 	ldw	r3,128(sp)
811255f4:	d8801f17 	ldw	r2,124(sp)
811255f8:	da000404 	addi	r8,sp,16
811255fc:	003e7706 	br	81124fdc <__reset+0xfb104fdc>
81125600:	582f883a 	mov	r23,r11
81125604:	d8002915 	stw	zero,164(sp)
81125608:	0038c406 	br	8112391c <__reset+0xfb10391c>
8112560c:	d8c02917 	ldw	r3,164(sp)
81125610:	d8802104 	addi	r2,sp,132
81125614:	d8800315 	stw	r2,12(sp)
81125618:	d9403617 	ldw	r5,216(sp)
8112561c:	d8802504 	addi	r2,sp,148
81125620:	d8800215 	stw	r2,8(sp)
81125624:	d8802604 	addi	r2,sp,152
81125628:	d8c00015 	stw	r3,0(sp)
8112562c:	9809883a 	mov	r4,r19
81125630:	d8800115 	stw	r2,4(sp)
81125634:	01c000c4 	movi	r7,3
81125638:	a00d883a 	mov	r6,r20
8112563c:	da003e15 	stw	r8,248(sp)
81125640:	1129aac0 	call	81129aac <_dtoa_r>
81125644:	d9002917 	ldw	r4,164(sp)
81125648:	da003e17 	ldw	r8,248(sp)
8112564c:	1021883a 	mov	r16,r2
81125650:	1139883a 	add	fp,r2,r4
81125654:	2007883a 	mov	r3,r4
81125658:	81000007 	ldb	r4,0(r16)
8112565c:	00800c04 	movi	r2,48
81125660:	20806f26 	beq	r4,r2,81125820 <___svfprintf_internal_r+0x2060>
81125664:	d8c02617 	ldw	r3,152(sp)
81125668:	e0f9883a 	add	fp,fp,r3
8112566c:	003ec206 	br	81125178 <__reset+0xfb105178>
81125670:	00c00b44 	movi	r3,45
81125674:	2520003c 	xorhi	r20,r4,32768
81125678:	d8c02a05 	stb	r3,168(sp)
8112567c:	003ea106 	br	81125104 <__reset+0xfb105104>
81125680:	d8c03217 	ldw	r3,200(sp)
81125684:	00c0890e 	bge	zero,r3,811258ac <___svfprintf_internal_r+0x20ec>
81125688:	00800044 	movi	r2,1
8112568c:	d9003317 	ldw	r4,204(sp)
81125690:	1105883a 	add	r2,r2,r4
81125694:	d8802e15 	stw	r2,184(sp)
81125698:	10005f16 	blt	r2,zero,81125818 <___svfprintf_internal_r+0x2058>
8112569c:	044019c4 	movi	r17,103
811256a0:	003ed906 	br	81125208 <__reset+0xfb105208>
811256a4:	d9002917 	ldw	r4,164(sp)
811256a8:	20c00044 	addi	r3,r4,1
811256ac:	003e9c06 	br	81125120 <__reset+0xfb105120>
811256b0:	d9002917 	ldw	r4,164(sp)
811256b4:	00c0680e 	bge	zero,r3,81125858 <___svfprintf_internal_r+0x2098>
811256b8:	2000461e 	bne	r4,zero,811257d4 <___svfprintf_internal_r+0x2014>
811256bc:	9480004c 	andi	r18,r18,1
811256c0:	9000441e 	bne	r18,zero,811257d4 <___svfprintf_internal_r+0x2014>
811256c4:	1805883a 	mov	r2,r3
811256c8:	1800a016 	blt	r3,zero,8112594c <___svfprintf_internal_r+0x218c>
811256cc:	d8c03217 	ldw	r3,200(sp)
811256d0:	d8c02e15 	stw	r3,184(sp)
811256d4:	003ecc06 	br	81125208 <__reset+0xfb105208>
811256d8:	d9402917 	ldw	r5,164(sp)
811256dc:	d8802104 	addi	r2,sp,132
811256e0:	d8800315 	stw	r2,12(sp)
811256e4:	d9400015 	stw	r5,0(sp)
811256e8:	d8802504 	addi	r2,sp,148
811256ec:	d9403617 	ldw	r5,216(sp)
811256f0:	d8800215 	stw	r2,8(sp)
811256f4:	d8802604 	addi	r2,sp,152
811256f8:	d8800115 	stw	r2,4(sp)
811256fc:	01c000c4 	movi	r7,3
81125700:	a00d883a 	mov	r6,r20
81125704:	9809883a 	mov	r4,r19
81125708:	da003e15 	stw	r8,248(sp)
8112570c:	1129aac0 	call	81129aac <_dtoa_r>
81125710:	d8c02917 	ldw	r3,164(sp)
81125714:	da003e17 	ldw	r8,248(sp)
81125718:	1021883a 	mov	r16,r2
8112571c:	00801184 	movi	r2,70
81125720:	80f9883a 	add	fp,r16,r3
81125724:	88bfcc26 	beq	r17,r2,81125658 <__reset+0xfb105658>
81125728:	003e9306 	br	81125178 <__reset+0xfb105178>
8112572c:	df0022c4 	addi	fp,sp,139
81125730:	dc002915 	stw	r16,164(sp)
81125734:	9829883a 	mov	r20,r19
81125738:	e021883a 	mov	r16,fp
8112573c:	4027883a 	mov	r19,r8
81125740:	b009883a 	mov	r4,r22
81125744:	01400284 	movi	r5,10
81125748:	1134ba40 	call	81134ba4 <__modsi3>
8112574c:	10800c04 	addi	r2,r2,48
81125750:	843fffc4 	addi	r16,r16,-1
81125754:	b009883a 	mov	r4,r22
81125758:	01400284 	movi	r5,10
8112575c:	80800005 	stb	r2,0(r16)
81125760:	1134b200 	call	81134b20 <__divsi3>
81125764:	102d883a 	mov	r22,r2
81125768:	00800244 	movi	r2,9
8112576c:	15bff416 	blt	r2,r22,81125740 <__reset+0xfb105740>
81125770:	9811883a 	mov	r8,r19
81125774:	b0800c04 	addi	r2,r22,48
81125778:	a027883a 	mov	r19,r20
8112577c:	8029883a 	mov	r20,r16
81125780:	a17fffc4 	addi	r5,r20,-1
81125784:	a0bfffc5 	stb	r2,-1(r20)
81125788:	dc002917 	ldw	r16,164(sp)
8112578c:	2f00752e 	bgeu	r5,fp,81125964 <___svfprintf_internal_r+0x21a4>
81125790:	d9c02384 	addi	r7,sp,142
81125794:	3d0fc83a 	sub	r7,r7,r20
81125798:	d9002344 	addi	r4,sp,141
8112579c:	e1cf883a 	add	r7,fp,r7
811257a0:	00000106 	br	811257a8 <___svfprintf_internal_r+0x1fe8>
811257a4:	28800003 	ldbu	r2,0(r5)
811257a8:	20800005 	stb	r2,0(r4)
811257ac:	21000044 	addi	r4,r4,1
811257b0:	29400044 	addi	r5,r5,1
811257b4:	21fffb1e 	bne	r4,r7,811257a4 <__reset+0xfb1057a4>
811257b8:	d8802304 	addi	r2,sp,140
811257bc:	1505c83a 	sub	r2,r2,r20
811257c0:	d8c02344 	addi	r3,sp,141
811257c4:	1885883a 	add	r2,r3,r2
811257c8:	003f7006 	br	8112558c <__reset+0xfb10558c>
811257cc:	0005883a 	mov	r2,zero
811257d0:	003f0b06 	br	81125400 <__reset+0xfb105400>
811257d4:	d9002917 	ldw	r4,164(sp)
811257d8:	d8c03217 	ldw	r3,200(sp)
811257dc:	20800044 	addi	r2,r4,1
811257e0:	1885883a 	add	r2,r3,r2
811257e4:	d8802e15 	stw	r2,184(sp)
811257e8:	103e870e 	bge	r2,zero,81125208 <__reset+0xfb105208>
811257ec:	0005883a 	mov	r2,zero
811257f0:	003e8506 	br	81125208 <__reset+0xfb105208>
811257f4:	01204574 	movhi	r4,33045
811257f8:	21034784 	addi	r4,r4,3358
811257fc:	d9002b15 	stw	r4,172(sp)
81125800:	003cc506 	br	81124b18 <__reset+0xfb104b18>
81125804:	d8c03217 	ldw	r3,200(sp)
81125808:	18c00044 	addi	r3,r3,1
8112580c:	d8c02e15 	stw	r3,184(sp)
81125810:	1805883a 	mov	r2,r3
81125814:	183fa10e 	bge	r3,zero,8112569c <__reset+0xfb10569c>
81125818:	0005883a 	mov	r2,zero
8112581c:	003f9f06 	br	8112569c <__reset+0xfb10569c>
81125820:	d9003617 	ldw	r4,216(sp)
81125824:	000d883a 	mov	r6,zero
81125828:	000f883a 	mov	r7,zero
8112582c:	a00b883a 	mov	r5,r20
81125830:	d8c03d15 	stw	r3,244(sp)
81125834:	da003e15 	stw	r8,248(sp)
81125838:	11360740 	call	81136074 <__eqdf2>
8112583c:	d8c03d17 	ldw	r3,244(sp)
81125840:	da003e17 	ldw	r8,248(sp)
81125844:	103f8726 	beq	r2,zero,81125664 <__reset+0xfb105664>
81125848:	00800044 	movi	r2,1
8112584c:	10c7c83a 	sub	r3,r2,r3
81125850:	d8c02615 	stw	r3,152(sp)
81125854:	003f8406 	br	81125668 <__reset+0xfb105668>
81125858:	20000e1e 	bne	r4,zero,81125894 <___svfprintf_internal_r+0x20d4>
8112585c:	9480004c 	andi	r18,r18,1
81125860:	90000c1e 	bne	r18,zero,81125894 <___svfprintf_internal_r+0x20d4>
81125864:	00800044 	movi	r2,1
81125868:	d8802e15 	stw	r2,184(sp)
8112586c:	003e6606 	br	81125208 <__reset+0xfb105208>
81125870:	00800b44 	movi	r2,45
81125874:	05adc83a 	sub	r22,zero,r22
81125878:	d8802305 	stb	r2,140(sp)
8112587c:	003f3b06 	br	8112556c <__reset+0xfb10556c>
81125880:	0005883a 	mov	r2,zero
81125884:	003f4e06 	br	811255c0 <__reset+0xfb1055c0>
81125888:	90a4703a 	and	r18,r18,r2
8112588c:	903f4a26 	beq	r18,zero,811255b8 <__reset+0xfb1055b8>
81125890:	003f4606 	br	811255ac <__reset+0xfb1055ac>
81125894:	d8c02917 	ldw	r3,164(sp)
81125898:	18c00084 	addi	r3,r3,2
8112589c:	d8c02e15 	stw	r3,184(sp)
811258a0:	1805883a 	mov	r2,r3
811258a4:	183e580e 	bge	r3,zero,81125208 <__reset+0xfb105208>
811258a8:	003fd006 	br	811257ec <__reset+0xfb1057ec>
811258ac:	00800084 	movi	r2,2
811258b0:	10c5c83a 	sub	r2,r2,r3
811258b4:	003f7506 	br	8112568c <__reset+0xfb10568c>
811258b8:	d8802d17 	ldw	r2,180(sp)
811258bc:	d9002d17 	ldw	r4,180(sp)
811258c0:	bc400043 	ldbu	r17,1(r23)
811258c4:	10800017 	ldw	r2,0(r2)
811258c8:	582f883a 	mov	r23,r11
811258cc:	d8802915 	stw	r2,164(sp)
811258d0:	20800104 	addi	r2,r4,4
811258d4:	d9002917 	ldw	r4,164(sp)
811258d8:	d8802d15 	stw	r2,180(sp)
811258dc:	203df00e 	bge	r4,zero,811250a0 <__reset+0xfb1050a0>
811258e0:	8c403fcc 	andi	r17,r17,255
811258e4:	00bfffc4 	movi	r2,-1
811258e8:	8c40201c 	xori	r17,r17,128
811258ec:	d8802915 	stw	r2,164(sp)
811258f0:	8c7fe004 	addi	r17,r17,-128
811258f4:	00380806 	br	81123918 <__reset+0xfb103918>
811258f8:	9080004c 	andi	r2,r18,1
811258fc:	0039883a 	mov	fp,zero
81125900:	10000726 	beq	r2,zero,81125920 <___svfprintf_internal_r+0x2160>
81125904:	d8c02817 	ldw	r3,160(sp)
81125908:	dc001dc4 	addi	r16,sp,119
8112590c:	00800c04 	movi	r2,48
81125910:	1c07c83a 	sub	r3,r3,r16
81125914:	d8801dc5 	stb	r2,119(sp)
81125918:	d8c02e15 	stw	r3,184(sp)
8112591c:	00395206 	br	81123e68 <__reset+0xfb103e68>
81125920:	d8002e15 	stw	zero,184(sp)
81125924:	dc001e04 	addi	r16,sp,120
81125928:	00394f06 	br	81123e68 <__reset+0xfb103e68>
8112592c:	0005883a 	mov	r2,zero
81125930:	003e3206 	br	811251fc <__reset+0xfb1051fc>
81125934:	dd802617 	ldw	r22,152(sp)
81125938:	003f0606 	br	81125554 <__reset+0xfb105554>
8112593c:	d9c02785 	stb	r7,158(sp)
81125940:	003a5106 	br	81124288 <__reset+0xfb104288>
81125944:	d9c02785 	stb	r7,158(sp)
81125948:	003a3706 	br	81124228 <__reset+0xfb104228>
8112594c:	0005883a 	mov	r2,zero
81125950:	003f5e06 	br	811256cc <__reset+0xfb1056cc>
81125954:	d9c02785 	stb	r7,158(sp)
81125958:	00391706 	br	81123db8 <__reset+0xfb103db8>
8112595c:	d9c02785 	stb	r7,158(sp)
81125960:	0038e606 	br	81123cfc <__reset+0xfb103cfc>
81125964:	d8802344 	addi	r2,sp,141
81125968:	003f0806 	br	8112558c <__reset+0xfb10558c>
8112596c:	d9c02785 	stb	r7,158(sp)
81125970:	0038b706 	br	81123c50 <__reset+0xfb103c50>
81125974:	d9c02785 	stb	r7,158(sp)
81125978:	003adc06 	br	811244ec <__reset+0xfb1044ec>
8112597c:	d9403917 	ldw	r5,228(sp)
81125980:	00800304 	movi	r2,12
81125984:	28800015 	stw	r2,0(r5)
81125988:	00bfffc4 	movi	r2,-1
8112598c:	00387806 	br	81123b70 <__reset+0xfb103b70>
81125990:	d9c02785 	stb	r7,158(sp)
81125994:	003abf06 	br	81124494 <__reset+0xfb104494>
81125998:	d9c02785 	stb	r7,158(sp)
8112599c:	003a9b06 	br	8112440c <__reset+0xfb10440c>

811259a0 <___vfprintf_internal_r>:
811259a0:	deffb804 	addi	sp,sp,-288
811259a4:	de00012e 	bgeu	sp,et,811259ac <___vfprintf_internal_r+0xc>
811259a8:	003b68fa 	trap	3
811259ac:	dfc04715 	stw	ra,284(sp)
811259b0:	ddc04515 	stw	r23,276(sp)
811259b4:	dd404315 	stw	r21,268(sp)
811259b8:	d9002c15 	stw	r4,176(sp)
811259bc:	282f883a 	mov	r23,r5
811259c0:	302b883a 	mov	r21,r6
811259c4:	d9c02d15 	stw	r7,180(sp)
811259c8:	df004615 	stw	fp,280(sp)
811259cc:	dd804415 	stw	r22,272(sp)
811259d0:	dd004215 	stw	r20,264(sp)
811259d4:	dcc04115 	stw	r19,260(sp)
811259d8:	dc804015 	stw	r18,256(sp)
811259dc:	dc403f15 	stw	r17,252(sp)
811259e0:	dc003e15 	stw	r16,248(sp)
811259e4:	112c6a80 	call	8112c6a8 <_localeconv_r>
811259e8:	10800017 	ldw	r2,0(r2)
811259ec:	1009883a 	mov	r4,r2
811259f0:	d8803415 	stw	r2,208(sp)
811259f4:	11231840 	call	81123184 <strlen>
811259f8:	d8803715 	stw	r2,220(sp)
811259fc:	d8802c17 	ldw	r2,176(sp)
81125a00:	10000226 	beq	r2,zero,81125a0c <___vfprintf_internal_r+0x6c>
81125a04:	10800e17 	ldw	r2,56(r2)
81125a08:	1000f926 	beq	r2,zero,81125df0 <___vfprintf_internal_r+0x450>
81125a0c:	b880030b 	ldhu	r2,12(r23)
81125a10:	10c8000c 	andi	r3,r2,8192
81125a14:	1800061e 	bne	r3,zero,81125a30 <___vfprintf_internal_r+0x90>
81125a18:	b9001917 	ldw	r4,100(r23)
81125a1c:	00f7ffc4 	movi	r3,-8193
81125a20:	10880014 	ori	r2,r2,8192
81125a24:	20c6703a 	and	r3,r4,r3
81125a28:	b880030d 	sth	r2,12(r23)
81125a2c:	b8c01915 	stw	r3,100(r23)
81125a30:	10c0020c 	andi	r3,r2,8
81125a34:	1800c126 	beq	r3,zero,81125d3c <___vfprintf_internal_r+0x39c>
81125a38:	b8c00417 	ldw	r3,16(r23)
81125a3c:	1800bf26 	beq	r3,zero,81125d3c <___vfprintf_internal_r+0x39c>
81125a40:	1080068c 	andi	r2,r2,26
81125a44:	00c00284 	movi	r3,10
81125a48:	10c0c426 	beq	r2,r3,81125d5c <___vfprintf_internal_r+0x3bc>
81125a4c:	d8c00404 	addi	r3,sp,16
81125a50:	05204574 	movhi	r20,33045
81125a54:	d9001e04 	addi	r4,sp,120
81125a58:	a5034f84 	addi	r20,r20,3390
81125a5c:	d8c01e15 	stw	r3,120(sp)
81125a60:	d8002015 	stw	zero,128(sp)
81125a64:	d8001f15 	stw	zero,124(sp)
81125a68:	d8003315 	stw	zero,204(sp)
81125a6c:	d8003615 	stw	zero,216(sp)
81125a70:	d8003815 	stw	zero,224(sp)
81125a74:	1811883a 	mov	r8,r3
81125a78:	d8003915 	stw	zero,228(sp)
81125a7c:	d8003a15 	stw	zero,232(sp)
81125a80:	d8002f15 	stw	zero,188(sp)
81125a84:	d9002815 	stw	r4,160(sp)
81125a88:	a8800007 	ldb	r2,0(r21)
81125a8c:	10027b26 	beq	r2,zero,8112647c <___vfprintf_internal_r+0xadc>
81125a90:	00c00944 	movi	r3,37
81125a94:	a821883a 	mov	r16,r21
81125a98:	10c0021e 	bne	r2,r3,81125aa4 <___vfprintf_internal_r+0x104>
81125a9c:	00001406 	br	81125af0 <___vfprintf_internal_r+0x150>
81125aa0:	10c00326 	beq	r2,r3,81125ab0 <___vfprintf_internal_r+0x110>
81125aa4:	84000044 	addi	r16,r16,1
81125aa8:	80800007 	ldb	r2,0(r16)
81125aac:	103ffc1e 	bne	r2,zero,81125aa0 <__reset+0xfb105aa0>
81125ab0:	8563c83a 	sub	r17,r16,r21
81125ab4:	88000e26 	beq	r17,zero,81125af0 <___vfprintf_internal_r+0x150>
81125ab8:	d8c02017 	ldw	r3,128(sp)
81125abc:	d8801f17 	ldw	r2,124(sp)
81125ac0:	45400015 	stw	r21,0(r8)
81125ac4:	1c47883a 	add	r3,r3,r17
81125ac8:	10800044 	addi	r2,r2,1
81125acc:	d8c02015 	stw	r3,128(sp)
81125ad0:	44400115 	stw	r17,4(r8)
81125ad4:	d8801f15 	stw	r2,124(sp)
81125ad8:	00c001c4 	movi	r3,7
81125adc:	1880a716 	blt	r3,r2,81125d7c <___vfprintf_internal_r+0x3dc>
81125ae0:	42000204 	addi	r8,r8,8
81125ae4:	d9402f17 	ldw	r5,188(sp)
81125ae8:	2c4b883a 	add	r5,r5,r17
81125aec:	d9402f15 	stw	r5,188(sp)
81125af0:	80800007 	ldb	r2,0(r16)
81125af4:	1000a826 	beq	r2,zero,81125d98 <___vfprintf_internal_r+0x3f8>
81125af8:	84400047 	ldb	r17,1(r16)
81125afc:	00bfffc4 	movi	r2,-1
81125b00:	85400044 	addi	r21,r16,1
81125b04:	d8002785 	stb	zero,158(sp)
81125b08:	0007883a 	mov	r3,zero
81125b0c:	000f883a 	mov	r7,zero
81125b10:	d8802915 	stw	r2,164(sp)
81125b14:	d8003115 	stw	zero,196(sp)
81125b18:	0025883a 	mov	r18,zero
81125b1c:	01401604 	movi	r5,88
81125b20:	01800244 	movi	r6,9
81125b24:	02800a84 	movi	r10,42
81125b28:	02401b04 	movi	r9,108
81125b2c:	ad400044 	addi	r21,r21,1
81125b30:	88bff804 	addi	r2,r17,-32
81125b34:	28830436 	bltu	r5,r2,81126748 <___vfprintf_internal_r+0xda8>
81125b38:	100490ba 	slli	r2,r2,2
81125b3c:	012044b4 	movhi	r4,33042
81125b40:	2116d404 	addi	r4,r4,23376
81125b44:	1105883a 	add	r2,r2,r4
81125b48:	10800017 	ldw	r2,0(r2)
81125b4c:	1000683a 	jmp	r2
81125b50:	81126668 	cmpgeui	r4,r16,18841
81125b54:	81126748 	cmpgei	r4,r16,18845
81125b58:	81126748 	cmpgei	r4,r16,18845
81125b5c:	81126688 	cmpgei	r4,r16,18842
81125b60:	81126748 	cmpgei	r4,r16,18845
81125b64:	81126748 	cmpgei	r4,r16,18845
81125b68:	81126748 	cmpgei	r4,r16,18845
81125b6c:	81126748 	cmpgei	r4,r16,18845
81125b70:	81126748 	cmpgei	r4,r16,18845
81125b74:	81126748 	cmpgei	r4,r16,18845
81125b78:	81125dfc 	xorhi	r4,r16,18807
81125b7c:	811265a4 	muli	r4,r16,18838
81125b80:	81126748 	cmpgei	r4,r16,18845
81125b84:	81125cc4 	addi	r4,r16,18803
81125b88:	81125e24 	muli	r4,r16,18808
81125b8c:	81126748 	cmpgei	r4,r16,18845
81125b90:	81125e64 	muli	r4,r16,18809
81125b94:	81125e70 	cmpltui	r4,r16,18809
81125b98:	81125e70 	cmpltui	r4,r16,18809
81125b9c:	81125e70 	cmpltui	r4,r16,18809
81125ba0:	81125e70 	cmpltui	r4,r16,18809
81125ba4:	81125e70 	cmpltui	r4,r16,18809
81125ba8:	81125e70 	cmpltui	r4,r16,18809
81125bac:	81125e70 	cmpltui	r4,r16,18809
81125bb0:	81125e70 	cmpltui	r4,r16,18809
81125bb4:	81125e70 	cmpltui	r4,r16,18809
81125bb8:	81126748 	cmpgei	r4,r16,18845
81125bbc:	81126748 	cmpgei	r4,r16,18845
81125bc0:	81126748 	cmpgei	r4,r16,18845
81125bc4:	81126748 	cmpgei	r4,r16,18845
81125bc8:	81126748 	cmpgei	r4,r16,18845
81125bcc:	81126748 	cmpgei	r4,r16,18845
81125bd0:	81126748 	cmpgei	r4,r16,18845
81125bd4:	81126748 	cmpgei	r4,r16,18845
81125bd8:	81126748 	cmpgei	r4,r16,18845
81125bdc:	81126748 	cmpgei	r4,r16,18845
81125be0:	81125ea4 	muli	r4,r16,18810
81125be4:	81125f60 	cmpeqi	r4,r16,18813
81125be8:	81126748 	cmpgei	r4,r16,18845
81125bec:	81125f60 	cmpeqi	r4,r16,18813
81125bf0:	81126748 	cmpgei	r4,r16,18845
81125bf4:	81126748 	cmpgei	r4,r16,18845
81125bf8:	81126748 	cmpgei	r4,r16,18845
81125bfc:	81126748 	cmpgei	r4,r16,18845
81125c00:	81126000 	call	88112600 <__reset+0x20f2600>
81125c04:	81126748 	cmpgei	r4,r16,18845
81125c08:	81126748 	cmpgei	r4,r16,18845
81125c0c:	8112600c 	andi	r4,r16,18816
81125c10:	81126748 	cmpgei	r4,r16,18845
81125c14:	81126748 	cmpgei	r4,r16,18845
81125c18:	81126748 	cmpgei	r4,r16,18845
81125c1c:	81126748 	cmpgei	r4,r16,18845
81125c20:	81126748 	cmpgei	r4,r16,18845
81125c24:	81126484 	addi	r4,r16,18834
81125c28:	81126748 	cmpgei	r4,r16,18845
81125c2c:	81126748 	cmpgei	r4,r16,18845
81125c30:	811264e4 	muli	r4,r16,18835
81125c34:	81126748 	cmpgei	r4,r16,18845
81125c38:	81126748 	cmpgei	r4,r16,18845
81125c3c:	81126748 	cmpgei	r4,r16,18845
81125c40:	81126748 	cmpgei	r4,r16,18845
81125c44:	81126748 	cmpgei	r4,r16,18845
81125c48:	81126748 	cmpgei	r4,r16,18845
81125c4c:	81126748 	cmpgei	r4,r16,18845
81125c50:	81126748 	cmpgei	r4,r16,18845
81125c54:	81126748 	cmpgei	r4,r16,18845
81125c58:	81126748 	cmpgei	r4,r16,18845
81125c5c:	811266f4 	orhi	r4,r16,18843
81125c60:	81126694 	ori	r4,r16,18842
81125c64:	81125f60 	cmpeqi	r4,r16,18813
81125c68:	81125f60 	cmpeqi	r4,r16,18813
81125c6c:	81125f60 	cmpeqi	r4,r16,18813
81125c70:	811266a4 	muli	r4,r16,18842
81125c74:	81126694 	ori	r4,r16,18842
81125c78:	81126748 	cmpgei	r4,r16,18845
81125c7c:	81126748 	cmpgei	r4,r16,18845
81125c80:	811266b0 	cmpltui	r4,r16,18842
81125c84:	81126748 	cmpgei	r4,r16,18845
81125c88:	811266c0 	call	8811266c <__reset+0x20f266c>
81125c8c:	81126594 	ori	r4,r16,18838
81125c90:	81125cd0 	cmplti	r4,r16,18803
81125c94:	811265b4 	orhi	r4,r16,18838
81125c98:	81126748 	cmpgei	r4,r16,18845
81125c9c:	811265c0 	call	8811265c <__reset+0x20f265c>
81125ca0:	81126748 	cmpgei	r4,r16,18845
81125ca4:	8112661c 	xori	r4,r16,18840
81125ca8:	81126748 	cmpgei	r4,r16,18845
81125cac:	81126748 	cmpgei	r4,r16,18845
81125cb0:	8112662c 	andhi	r4,r16,18840
81125cb4:	d9003117 	ldw	r4,196(sp)
81125cb8:	d8802d15 	stw	r2,180(sp)
81125cbc:	0109c83a 	sub	r4,zero,r4
81125cc0:	d9003115 	stw	r4,196(sp)
81125cc4:	94800114 	ori	r18,r18,4
81125cc8:	ac400007 	ldb	r17,0(r21)
81125ccc:	003f9706 	br	81125b2c <__reset+0xfb105b2c>
81125cd0:	00800c04 	movi	r2,48
81125cd4:	d9002d17 	ldw	r4,180(sp)
81125cd8:	d9402917 	ldw	r5,164(sp)
81125cdc:	d8802705 	stb	r2,156(sp)
81125ce0:	00801e04 	movi	r2,120
81125ce4:	d8802745 	stb	r2,157(sp)
81125ce8:	d8002785 	stb	zero,158(sp)
81125cec:	20c00104 	addi	r3,r4,4
81125cf0:	24c00017 	ldw	r19,0(r4)
81125cf4:	002d883a 	mov	r22,zero
81125cf8:	90800094 	ori	r2,r18,2
81125cfc:	28029a16 	blt	r5,zero,81126768 <___vfprintf_internal_r+0xdc8>
81125d00:	00bfdfc4 	movi	r2,-129
81125d04:	90a4703a 	and	r18,r18,r2
81125d08:	d8c02d15 	stw	r3,180(sp)
81125d0c:	94800094 	ori	r18,r18,2
81125d10:	9802871e 	bne	r19,zero,81126730 <___vfprintf_internal_r+0xd90>
81125d14:	00a04574 	movhi	r2,33045
81125d18:	10834004 	addi	r2,r2,3328
81125d1c:	d8803915 	stw	r2,228(sp)
81125d20:	04401e04 	movi	r17,120
81125d24:	d8802917 	ldw	r2,164(sp)
81125d28:	0039883a 	mov	fp,zero
81125d2c:	1001e926 	beq	r2,zero,811264d4 <___vfprintf_internal_r+0xb34>
81125d30:	0027883a 	mov	r19,zero
81125d34:	002d883a 	mov	r22,zero
81125d38:	00020506 	br	81126550 <___vfprintf_internal_r+0xbb0>
81125d3c:	d9002c17 	ldw	r4,176(sp)
81125d40:	b80b883a 	mov	r5,r23
81125d44:	11296ec0 	call	811296ec <__swsetup_r>
81125d48:	1005ac1e 	bne	r2,zero,811273fc <___vfprintf_internal_r+0x1a5c>
81125d4c:	b880030b 	ldhu	r2,12(r23)
81125d50:	00c00284 	movi	r3,10
81125d54:	1080068c 	andi	r2,r2,26
81125d58:	10ff3c1e 	bne	r2,r3,81125a4c <__reset+0xfb105a4c>
81125d5c:	b880038f 	ldh	r2,14(r23)
81125d60:	103f3a16 	blt	r2,zero,81125a4c <__reset+0xfb105a4c>
81125d64:	d9c02d17 	ldw	r7,180(sp)
81125d68:	d9002c17 	ldw	r4,176(sp)
81125d6c:	a80d883a 	mov	r6,r21
81125d70:	b80b883a 	mov	r5,r23
81125d74:	1127bbc0 	call	81127bbc <__sbprintf>
81125d78:	00001106 	br	81125dc0 <___vfprintf_internal_r+0x420>
81125d7c:	d9002c17 	ldw	r4,176(sp)
81125d80:	d9801e04 	addi	r6,sp,120
81125d84:	b80b883a 	mov	r5,r23
81125d88:	11318a80 	call	811318a8 <__sprint_r>
81125d8c:	1000081e 	bne	r2,zero,81125db0 <___vfprintf_internal_r+0x410>
81125d90:	da000404 	addi	r8,sp,16
81125d94:	003f5306 	br	81125ae4 <__reset+0xfb105ae4>
81125d98:	d8802017 	ldw	r2,128(sp)
81125d9c:	10000426 	beq	r2,zero,81125db0 <___vfprintf_internal_r+0x410>
81125da0:	d9002c17 	ldw	r4,176(sp)
81125da4:	d9801e04 	addi	r6,sp,120
81125da8:	b80b883a 	mov	r5,r23
81125dac:	11318a80 	call	811318a8 <__sprint_r>
81125db0:	b880030b 	ldhu	r2,12(r23)
81125db4:	1080100c 	andi	r2,r2,64
81125db8:	1005901e 	bne	r2,zero,811273fc <___vfprintf_internal_r+0x1a5c>
81125dbc:	d8802f17 	ldw	r2,188(sp)
81125dc0:	dfc04717 	ldw	ra,284(sp)
81125dc4:	df004617 	ldw	fp,280(sp)
81125dc8:	ddc04517 	ldw	r23,276(sp)
81125dcc:	dd804417 	ldw	r22,272(sp)
81125dd0:	dd404317 	ldw	r21,268(sp)
81125dd4:	dd004217 	ldw	r20,264(sp)
81125dd8:	dcc04117 	ldw	r19,260(sp)
81125ddc:	dc804017 	ldw	r18,256(sp)
81125de0:	dc403f17 	ldw	r17,252(sp)
81125de4:	dc003e17 	ldw	r16,248(sp)
81125de8:	dec04804 	addi	sp,sp,288
81125dec:	f800283a 	ret
81125df0:	d9002c17 	ldw	r4,176(sp)
81125df4:	112b75c0 	call	8112b75c <__sinit>
81125df8:	003f0406 	br	81125a0c <__reset+0xfb105a0c>
81125dfc:	d8802d17 	ldw	r2,180(sp)
81125e00:	d9002d17 	ldw	r4,180(sp)
81125e04:	10800017 	ldw	r2,0(r2)
81125e08:	d8803115 	stw	r2,196(sp)
81125e0c:	20800104 	addi	r2,r4,4
81125e10:	d9003117 	ldw	r4,196(sp)
81125e14:	203fa716 	blt	r4,zero,81125cb4 <__reset+0xfb105cb4>
81125e18:	d8802d15 	stw	r2,180(sp)
81125e1c:	ac400007 	ldb	r17,0(r21)
81125e20:	003f4206 	br	81125b2c <__reset+0xfb105b2c>
81125e24:	ac400007 	ldb	r17,0(r21)
81125e28:	aac00044 	addi	r11,r21,1
81125e2c:	8a872826 	beq	r17,r10,81127ad0 <___vfprintf_internal_r+0x2130>
81125e30:	88bff404 	addi	r2,r17,-48
81125e34:	0009883a 	mov	r4,zero
81125e38:	30867d36 	bltu	r6,r2,81127830 <___vfprintf_internal_r+0x1e90>
81125e3c:	5c400007 	ldb	r17,0(r11)
81125e40:	210002a4 	muli	r4,r4,10
81125e44:	5d400044 	addi	r21,r11,1
81125e48:	a817883a 	mov	r11,r21
81125e4c:	2089883a 	add	r4,r4,r2
81125e50:	88bff404 	addi	r2,r17,-48
81125e54:	30bff92e 	bgeu	r6,r2,81125e3c <__reset+0xfb105e3c>
81125e58:	2005c916 	blt	r4,zero,81127580 <___vfprintf_internal_r+0x1be0>
81125e5c:	d9002915 	stw	r4,164(sp)
81125e60:	003f3306 	br	81125b30 <__reset+0xfb105b30>
81125e64:	94802014 	ori	r18,r18,128
81125e68:	ac400007 	ldb	r17,0(r21)
81125e6c:	003f2f06 	br	81125b2c <__reset+0xfb105b2c>
81125e70:	a809883a 	mov	r4,r21
81125e74:	d8003115 	stw	zero,196(sp)
81125e78:	88bff404 	addi	r2,r17,-48
81125e7c:	0017883a 	mov	r11,zero
81125e80:	24400007 	ldb	r17,0(r4)
81125e84:	5ac002a4 	muli	r11,r11,10
81125e88:	ad400044 	addi	r21,r21,1
81125e8c:	a809883a 	mov	r4,r21
81125e90:	12d7883a 	add	r11,r2,r11
81125e94:	88bff404 	addi	r2,r17,-48
81125e98:	30bff92e 	bgeu	r6,r2,81125e80 <__reset+0xfb105e80>
81125e9c:	dac03115 	stw	r11,196(sp)
81125ea0:	003f2306 	br	81125b30 <__reset+0xfb105b30>
81125ea4:	18c03fcc 	andi	r3,r3,255
81125ea8:	18072b1e 	bne	r3,zero,81127b58 <___vfprintf_internal_r+0x21b8>
81125eac:	94800414 	ori	r18,r18,16
81125eb0:	9080080c 	andi	r2,r18,32
81125eb4:	10037b26 	beq	r2,zero,81126ca4 <___vfprintf_internal_r+0x1304>
81125eb8:	d9402d17 	ldw	r5,180(sp)
81125ebc:	28800117 	ldw	r2,4(r5)
81125ec0:	2cc00017 	ldw	r19,0(r5)
81125ec4:	29400204 	addi	r5,r5,8
81125ec8:	d9402d15 	stw	r5,180(sp)
81125ecc:	102d883a 	mov	r22,r2
81125ed0:	10044b16 	blt	r2,zero,81127000 <___vfprintf_internal_r+0x1660>
81125ed4:	d9402917 	ldw	r5,164(sp)
81125ed8:	df002783 	ldbu	fp,158(sp)
81125edc:	2803bc16 	blt	r5,zero,81126dd0 <___vfprintf_internal_r+0x1430>
81125ee0:	00ffdfc4 	movi	r3,-129
81125ee4:	9d84b03a 	or	r2,r19,r22
81125ee8:	90e4703a 	and	r18,r18,r3
81125eec:	10017726 	beq	r2,zero,811264cc <___vfprintf_internal_r+0xb2c>
81125ef0:	b0038326 	beq	r22,zero,81126d00 <___vfprintf_internal_r+0x1360>
81125ef4:	dc402a15 	stw	r17,168(sp)
81125ef8:	dc001e04 	addi	r16,sp,120
81125efc:	b023883a 	mov	r17,r22
81125f00:	402d883a 	mov	r22,r8
81125f04:	9809883a 	mov	r4,r19
81125f08:	880b883a 	mov	r5,r17
81125f0c:	01800284 	movi	r6,10
81125f10:	000f883a 	mov	r7,zero
81125f14:	11345e00 	call	811345e0 <__umoddi3>
81125f18:	10800c04 	addi	r2,r2,48
81125f1c:	843fffc4 	addi	r16,r16,-1
81125f20:	9809883a 	mov	r4,r19
81125f24:	880b883a 	mov	r5,r17
81125f28:	80800005 	stb	r2,0(r16)
81125f2c:	01800284 	movi	r6,10
81125f30:	000f883a 	mov	r7,zero
81125f34:	11340600 	call	81134060 <__udivdi3>
81125f38:	1027883a 	mov	r19,r2
81125f3c:	10c4b03a 	or	r2,r2,r3
81125f40:	1823883a 	mov	r17,r3
81125f44:	103fef1e 	bne	r2,zero,81125f04 <__reset+0xfb105f04>
81125f48:	d8c02817 	ldw	r3,160(sp)
81125f4c:	dc402a17 	ldw	r17,168(sp)
81125f50:	b011883a 	mov	r8,r22
81125f54:	1c07c83a 	sub	r3,r3,r16
81125f58:	d8c02e15 	stw	r3,184(sp)
81125f5c:	00005906 	br	811260c4 <___vfprintf_internal_r+0x724>
81125f60:	18c03fcc 	andi	r3,r3,255
81125f64:	1806fa1e 	bne	r3,zero,81127b50 <___vfprintf_internal_r+0x21b0>
81125f68:	9080020c 	andi	r2,r18,8
81125f6c:	10048a26 	beq	r2,zero,81127198 <___vfprintf_internal_r+0x17f8>
81125f70:	d8c02d17 	ldw	r3,180(sp)
81125f74:	d9002d17 	ldw	r4,180(sp)
81125f78:	d9402d17 	ldw	r5,180(sp)
81125f7c:	18c00017 	ldw	r3,0(r3)
81125f80:	21000117 	ldw	r4,4(r4)
81125f84:	29400204 	addi	r5,r5,8
81125f88:	d8c03615 	stw	r3,216(sp)
81125f8c:	d9003815 	stw	r4,224(sp)
81125f90:	d9402d15 	stw	r5,180(sp)
81125f94:	d9003617 	ldw	r4,216(sp)
81125f98:	d9403817 	ldw	r5,224(sp)
81125f9c:	da003d15 	stw	r8,244(sp)
81125fa0:	04000044 	movi	r16,1
81125fa4:	112e1f40 	call	8112e1f4 <__fpclassifyd>
81125fa8:	da003d17 	ldw	r8,244(sp)
81125fac:	14041f1e 	bne	r2,r16,8112702c <___vfprintf_internal_r+0x168c>
81125fb0:	d9003617 	ldw	r4,216(sp)
81125fb4:	d9403817 	ldw	r5,224(sp)
81125fb8:	000d883a 	mov	r6,zero
81125fbc:	000f883a 	mov	r7,zero
81125fc0:	11360fc0 	call	811360fc <__ledf2>
81125fc4:	da003d17 	ldw	r8,244(sp)
81125fc8:	1005be16 	blt	r2,zero,811276c4 <___vfprintf_internal_r+0x1d24>
81125fcc:	df002783 	ldbu	fp,158(sp)
81125fd0:	008011c4 	movi	r2,71
81125fd4:	1445330e 	bge	r2,r17,811274a4 <___vfprintf_internal_r+0x1b04>
81125fd8:	04204574 	movhi	r16,33045
81125fdc:	84033804 	addi	r16,r16,3296
81125fe0:	00c000c4 	movi	r3,3
81125fe4:	00bfdfc4 	movi	r2,-129
81125fe8:	d8c02a15 	stw	r3,168(sp)
81125fec:	90a4703a 	and	r18,r18,r2
81125ff0:	d8c02e15 	stw	r3,184(sp)
81125ff4:	d8002915 	stw	zero,164(sp)
81125ff8:	d8003215 	stw	zero,200(sp)
81125ffc:	00003706 	br	811260dc <___vfprintf_internal_r+0x73c>
81126000:	94800214 	ori	r18,r18,8
81126004:	ac400007 	ldb	r17,0(r21)
81126008:	003ec806 	br	81125b2c <__reset+0xfb105b2c>
8112600c:	18c03fcc 	andi	r3,r3,255
81126010:	1806db1e 	bne	r3,zero,81127b80 <___vfprintf_internal_r+0x21e0>
81126014:	94800414 	ori	r18,r18,16
81126018:	9080080c 	andi	r2,r18,32
8112601c:	1002d826 	beq	r2,zero,81126b80 <___vfprintf_internal_r+0x11e0>
81126020:	d9402d17 	ldw	r5,180(sp)
81126024:	d8c02917 	ldw	r3,164(sp)
81126028:	d8002785 	stb	zero,158(sp)
8112602c:	28800204 	addi	r2,r5,8
81126030:	2cc00017 	ldw	r19,0(r5)
81126034:	2d800117 	ldw	r22,4(r5)
81126038:	18048f16 	blt	r3,zero,81127278 <___vfprintf_internal_r+0x18d8>
8112603c:	013fdfc4 	movi	r4,-129
81126040:	9d86b03a 	or	r3,r19,r22
81126044:	d8802d15 	stw	r2,180(sp)
81126048:	9124703a 	and	r18,r18,r4
8112604c:	1802d91e 	bne	r3,zero,81126bb4 <___vfprintf_internal_r+0x1214>
81126050:	d8c02917 	ldw	r3,164(sp)
81126054:	0039883a 	mov	fp,zero
81126058:	1805c326 	beq	r3,zero,81127768 <___vfprintf_internal_r+0x1dc8>
8112605c:	0027883a 	mov	r19,zero
81126060:	002d883a 	mov	r22,zero
81126064:	dc001e04 	addi	r16,sp,120
81126068:	9806d0fa 	srli	r3,r19,3
8112606c:	b008977a 	slli	r4,r22,29
81126070:	b02cd0fa 	srli	r22,r22,3
81126074:	9cc001cc 	andi	r19,r19,7
81126078:	98800c04 	addi	r2,r19,48
8112607c:	843fffc4 	addi	r16,r16,-1
81126080:	20e6b03a 	or	r19,r4,r3
81126084:	80800005 	stb	r2,0(r16)
81126088:	9d86b03a 	or	r3,r19,r22
8112608c:	183ff61e 	bne	r3,zero,81126068 <__reset+0xfb106068>
81126090:	90c0004c 	andi	r3,r18,1
81126094:	18013b26 	beq	r3,zero,81126584 <___vfprintf_internal_r+0xbe4>
81126098:	10803fcc 	andi	r2,r2,255
8112609c:	1080201c 	xori	r2,r2,128
811260a0:	10bfe004 	addi	r2,r2,-128
811260a4:	00c00c04 	movi	r3,48
811260a8:	10c13626 	beq	r2,r3,81126584 <___vfprintf_internal_r+0xbe4>
811260ac:	80ffffc5 	stb	r3,-1(r16)
811260b0:	d8c02817 	ldw	r3,160(sp)
811260b4:	80bfffc4 	addi	r2,r16,-1
811260b8:	1021883a 	mov	r16,r2
811260bc:	1887c83a 	sub	r3,r3,r2
811260c0:	d8c02e15 	stw	r3,184(sp)
811260c4:	d8802e17 	ldw	r2,184(sp)
811260c8:	d9002917 	ldw	r4,164(sp)
811260cc:	1100010e 	bge	r2,r4,811260d4 <___vfprintf_internal_r+0x734>
811260d0:	2005883a 	mov	r2,r4
811260d4:	d8802a15 	stw	r2,168(sp)
811260d8:	d8003215 	stw	zero,200(sp)
811260dc:	e7003fcc 	andi	fp,fp,255
811260e0:	e700201c 	xori	fp,fp,128
811260e4:	e73fe004 	addi	fp,fp,-128
811260e8:	e0000326 	beq	fp,zero,811260f8 <___vfprintf_internal_r+0x758>
811260ec:	d8c02a17 	ldw	r3,168(sp)
811260f0:	18c00044 	addi	r3,r3,1
811260f4:	d8c02a15 	stw	r3,168(sp)
811260f8:	90c0008c 	andi	r3,r18,2
811260fc:	d8c02b15 	stw	r3,172(sp)
81126100:	18000326 	beq	r3,zero,81126110 <___vfprintf_internal_r+0x770>
81126104:	d8c02a17 	ldw	r3,168(sp)
81126108:	18c00084 	addi	r3,r3,2
8112610c:	d8c02a15 	stw	r3,168(sp)
81126110:	90c0210c 	andi	r3,r18,132
81126114:	d8c03015 	stw	r3,192(sp)
81126118:	1801a31e 	bne	r3,zero,811267a8 <___vfprintf_internal_r+0xe08>
8112611c:	d9003117 	ldw	r4,196(sp)
81126120:	d8c02a17 	ldw	r3,168(sp)
81126124:	20e7c83a 	sub	r19,r4,r3
81126128:	04c19f0e 	bge	zero,r19,811267a8 <___vfprintf_internal_r+0xe08>
8112612c:	02400404 	movi	r9,16
81126130:	d8c02017 	ldw	r3,128(sp)
81126134:	d8801f17 	ldw	r2,124(sp)
81126138:	4cc50d0e 	bge	r9,r19,81127570 <___vfprintf_internal_r+0x1bd0>
8112613c:	01604574 	movhi	r5,33045
81126140:	29435384 	addi	r5,r5,3406
81126144:	dc403b15 	stw	r17,236(sp)
81126148:	d9403515 	stw	r5,212(sp)
8112614c:	9823883a 	mov	r17,r19
81126150:	482d883a 	mov	r22,r9
81126154:	9027883a 	mov	r19,r18
81126158:	070001c4 	movi	fp,7
8112615c:	8025883a 	mov	r18,r16
81126160:	dc002c17 	ldw	r16,176(sp)
81126164:	00000306 	br	81126174 <___vfprintf_internal_r+0x7d4>
81126168:	8c7ffc04 	addi	r17,r17,-16
8112616c:	42000204 	addi	r8,r8,8
81126170:	b440130e 	bge	r22,r17,811261c0 <___vfprintf_internal_r+0x820>
81126174:	01204574 	movhi	r4,33045
81126178:	18c00404 	addi	r3,r3,16
8112617c:	10800044 	addi	r2,r2,1
81126180:	21035384 	addi	r4,r4,3406
81126184:	41000015 	stw	r4,0(r8)
81126188:	45800115 	stw	r22,4(r8)
8112618c:	d8c02015 	stw	r3,128(sp)
81126190:	d8801f15 	stw	r2,124(sp)
81126194:	e0bff40e 	bge	fp,r2,81126168 <__reset+0xfb106168>
81126198:	d9801e04 	addi	r6,sp,120
8112619c:	b80b883a 	mov	r5,r23
811261a0:	8009883a 	mov	r4,r16
811261a4:	11318a80 	call	811318a8 <__sprint_r>
811261a8:	103f011e 	bne	r2,zero,81125db0 <__reset+0xfb105db0>
811261ac:	8c7ffc04 	addi	r17,r17,-16
811261b0:	d8c02017 	ldw	r3,128(sp)
811261b4:	d8801f17 	ldw	r2,124(sp)
811261b8:	da000404 	addi	r8,sp,16
811261bc:	b47fed16 	blt	r22,r17,81126174 <__reset+0xfb106174>
811261c0:	9021883a 	mov	r16,r18
811261c4:	9825883a 	mov	r18,r19
811261c8:	8827883a 	mov	r19,r17
811261cc:	dc403b17 	ldw	r17,236(sp)
811261d0:	d9403517 	ldw	r5,212(sp)
811261d4:	98c7883a 	add	r3,r19,r3
811261d8:	10800044 	addi	r2,r2,1
811261dc:	41400015 	stw	r5,0(r8)
811261e0:	44c00115 	stw	r19,4(r8)
811261e4:	d8c02015 	stw	r3,128(sp)
811261e8:	d8801f15 	stw	r2,124(sp)
811261ec:	010001c4 	movi	r4,7
811261f0:	2082a316 	blt	r4,r2,81126c80 <___vfprintf_internal_r+0x12e0>
811261f4:	df002787 	ldb	fp,158(sp)
811261f8:	42000204 	addi	r8,r8,8
811261fc:	e0000c26 	beq	fp,zero,81126230 <___vfprintf_internal_r+0x890>
81126200:	d8801f17 	ldw	r2,124(sp)
81126204:	d9002784 	addi	r4,sp,158
81126208:	18c00044 	addi	r3,r3,1
8112620c:	10800044 	addi	r2,r2,1
81126210:	41000015 	stw	r4,0(r8)
81126214:	01000044 	movi	r4,1
81126218:	41000115 	stw	r4,4(r8)
8112621c:	d8c02015 	stw	r3,128(sp)
81126220:	d8801f15 	stw	r2,124(sp)
81126224:	010001c4 	movi	r4,7
81126228:	20823c16 	blt	r4,r2,81126b1c <___vfprintf_internal_r+0x117c>
8112622c:	42000204 	addi	r8,r8,8
81126230:	d8802b17 	ldw	r2,172(sp)
81126234:	10000c26 	beq	r2,zero,81126268 <___vfprintf_internal_r+0x8c8>
81126238:	d8801f17 	ldw	r2,124(sp)
8112623c:	d9002704 	addi	r4,sp,156
81126240:	18c00084 	addi	r3,r3,2
81126244:	10800044 	addi	r2,r2,1
81126248:	41000015 	stw	r4,0(r8)
8112624c:	01000084 	movi	r4,2
81126250:	41000115 	stw	r4,4(r8)
81126254:	d8c02015 	stw	r3,128(sp)
81126258:	d8801f15 	stw	r2,124(sp)
8112625c:	010001c4 	movi	r4,7
81126260:	20823616 	blt	r4,r2,81126b3c <___vfprintf_internal_r+0x119c>
81126264:	42000204 	addi	r8,r8,8
81126268:	d9003017 	ldw	r4,192(sp)
8112626c:	00802004 	movi	r2,128
81126270:	20819926 	beq	r4,r2,811268d8 <___vfprintf_internal_r+0xf38>
81126274:	d9402917 	ldw	r5,164(sp)
81126278:	d8802e17 	ldw	r2,184(sp)
8112627c:	28adc83a 	sub	r22,r5,r2
81126280:	0580310e 	bge	zero,r22,81126348 <___vfprintf_internal_r+0x9a8>
81126284:	07000404 	movi	fp,16
81126288:	d8801f17 	ldw	r2,124(sp)
8112628c:	e584140e 	bge	fp,r22,811272e0 <___vfprintf_internal_r+0x1940>
81126290:	01604574 	movhi	r5,33045
81126294:	29434f84 	addi	r5,r5,3390
81126298:	dc402915 	stw	r17,164(sp)
8112629c:	d9402b15 	stw	r5,172(sp)
811262a0:	b023883a 	mov	r17,r22
811262a4:	04c001c4 	movi	r19,7
811262a8:	a82d883a 	mov	r22,r21
811262ac:	902b883a 	mov	r21,r18
811262b0:	8025883a 	mov	r18,r16
811262b4:	dc002c17 	ldw	r16,176(sp)
811262b8:	00000306 	br	811262c8 <___vfprintf_internal_r+0x928>
811262bc:	8c7ffc04 	addi	r17,r17,-16
811262c0:	42000204 	addi	r8,r8,8
811262c4:	e440110e 	bge	fp,r17,8112630c <___vfprintf_internal_r+0x96c>
811262c8:	18c00404 	addi	r3,r3,16
811262cc:	10800044 	addi	r2,r2,1
811262d0:	45000015 	stw	r20,0(r8)
811262d4:	47000115 	stw	fp,4(r8)
811262d8:	d8c02015 	stw	r3,128(sp)
811262dc:	d8801f15 	stw	r2,124(sp)
811262e0:	98bff60e 	bge	r19,r2,811262bc <__reset+0xfb1062bc>
811262e4:	d9801e04 	addi	r6,sp,120
811262e8:	b80b883a 	mov	r5,r23
811262ec:	8009883a 	mov	r4,r16
811262f0:	11318a80 	call	811318a8 <__sprint_r>
811262f4:	103eae1e 	bne	r2,zero,81125db0 <__reset+0xfb105db0>
811262f8:	8c7ffc04 	addi	r17,r17,-16
811262fc:	d8c02017 	ldw	r3,128(sp)
81126300:	d8801f17 	ldw	r2,124(sp)
81126304:	da000404 	addi	r8,sp,16
81126308:	e47fef16 	blt	fp,r17,811262c8 <__reset+0xfb1062c8>
8112630c:	9021883a 	mov	r16,r18
81126310:	a825883a 	mov	r18,r21
81126314:	b02b883a 	mov	r21,r22
81126318:	882d883a 	mov	r22,r17
8112631c:	dc402917 	ldw	r17,164(sp)
81126320:	d9002b17 	ldw	r4,172(sp)
81126324:	1d87883a 	add	r3,r3,r22
81126328:	10800044 	addi	r2,r2,1
8112632c:	41000015 	stw	r4,0(r8)
81126330:	45800115 	stw	r22,4(r8)
81126334:	d8c02015 	stw	r3,128(sp)
81126338:	d8801f15 	stw	r2,124(sp)
8112633c:	010001c4 	movi	r4,7
81126340:	2081ee16 	blt	r4,r2,81126afc <___vfprintf_internal_r+0x115c>
81126344:	42000204 	addi	r8,r8,8
81126348:	9080400c 	andi	r2,r18,256
8112634c:	1001181e 	bne	r2,zero,811267b0 <___vfprintf_internal_r+0xe10>
81126350:	d9402e17 	ldw	r5,184(sp)
81126354:	d8801f17 	ldw	r2,124(sp)
81126358:	44000015 	stw	r16,0(r8)
8112635c:	1947883a 	add	r3,r3,r5
81126360:	10800044 	addi	r2,r2,1
81126364:	41400115 	stw	r5,4(r8)
81126368:	d8c02015 	stw	r3,128(sp)
8112636c:	d8801f15 	stw	r2,124(sp)
81126370:	010001c4 	movi	r4,7
81126374:	2081d316 	blt	r4,r2,81126ac4 <___vfprintf_internal_r+0x1124>
81126378:	42000204 	addi	r8,r8,8
8112637c:	9480010c 	andi	r18,r18,4
81126380:	90003226 	beq	r18,zero,8112644c <___vfprintf_internal_r+0xaac>
81126384:	d9403117 	ldw	r5,196(sp)
81126388:	d8802a17 	ldw	r2,168(sp)
8112638c:	28a1c83a 	sub	r16,r5,r2
81126390:	04002e0e 	bge	zero,r16,8112644c <___vfprintf_internal_r+0xaac>
81126394:	04400404 	movi	r17,16
81126398:	d8801f17 	ldw	r2,124(sp)
8112639c:	8c04a20e 	bge	r17,r16,81127628 <___vfprintf_internal_r+0x1c88>
811263a0:	01604574 	movhi	r5,33045
811263a4:	29435384 	addi	r5,r5,3406
811263a8:	d9403515 	stw	r5,212(sp)
811263ac:	048001c4 	movi	r18,7
811263b0:	dcc02c17 	ldw	r19,176(sp)
811263b4:	00000306 	br	811263c4 <___vfprintf_internal_r+0xa24>
811263b8:	843ffc04 	addi	r16,r16,-16
811263bc:	42000204 	addi	r8,r8,8
811263c0:	8c00130e 	bge	r17,r16,81126410 <___vfprintf_internal_r+0xa70>
811263c4:	01204574 	movhi	r4,33045
811263c8:	18c00404 	addi	r3,r3,16
811263cc:	10800044 	addi	r2,r2,1
811263d0:	21035384 	addi	r4,r4,3406
811263d4:	41000015 	stw	r4,0(r8)
811263d8:	44400115 	stw	r17,4(r8)
811263dc:	d8c02015 	stw	r3,128(sp)
811263e0:	d8801f15 	stw	r2,124(sp)
811263e4:	90bff40e 	bge	r18,r2,811263b8 <__reset+0xfb1063b8>
811263e8:	d9801e04 	addi	r6,sp,120
811263ec:	b80b883a 	mov	r5,r23
811263f0:	9809883a 	mov	r4,r19
811263f4:	11318a80 	call	811318a8 <__sprint_r>
811263f8:	103e6d1e 	bne	r2,zero,81125db0 <__reset+0xfb105db0>
811263fc:	843ffc04 	addi	r16,r16,-16
81126400:	d8c02017 	ldw	r3,128(sp)
81126404:	d8801f17 	ldw	r2,124(sp)
81126408:	da000404 	addi	r8,sp,16
8112640c:	8c3fed16 	blt	r17,r16,811263c4 <__reset+0xfb1063c4>
81126410:	d9403517 	ldw	r5,212(sp)
81126414:	1c07883a 	add	r3,r3,r16
81126418:	10800044 	addi	r2,r2,1
8112641c:	41400015 	stw	r5,0(r8)
81126420:	44000115 	stw	r16,4(r8)
81126424:	d8c02015 	stw	r3,128(sp)
81126428:	d8801f15 	stw	r2,124(sp)
8112642c:	010001c4 	movi	r4,7
81126430:	2080060e 	bge	r4,r2,8112644c <___vfprintf_internal_r+0xaac>
81126434:	d9002c17 	ldw	r4,176(sp)
81126438:	d9801e04 	addi	r6,sp,120
8112643c:	b80b883a 	mov	r5,r23
81126440:	11318a80 	call	811318a8 <__sprint_r>
81126444:	103e5a1e 	bne	r2,zero,81125db0 <__reset+0xfb105db0>
81126448:	d8c02017 	ldw	r3,128(sp)
8112644c:	d8803117 	ldw	r2,196(sp)
81126450:	d9002a17 	ldw	r4,168(sp)
81126454:	1100010e 	bge	r2,r4,8112645c <___vfprintf_internal_r+0xabc>
81126458:	2005883a 	mov	r2,r4
8112645c:	d9402f17 	ldw	r5,188(sp)
81126460:	288b883a 	add	r5,r5,r2
81126464:	d9402f15 	stw	r5,188(sp)
81126468:	18019e1e 	bne	r3,zero,81126ae4 <___vfprintf_internal_r+0x1144>
8112646c:	a8800007 	ldb	r2,0(r21)
81126470:	d8001f15 	stw	zero,124(sp)
81126474:	da000404 	addi	r8,sp,16
81126478:	103d851e 	bne	r2,zero,81125a90 <__reset+0xfb105a90>
8112647c:	a821883a 	mov	r16,r21
81126480:	003d9b06 	br	81125af0 <__reset+0xfb105af0>
81126484:	18c03fcc 	andi	r3,r3,255
81126488:	1805c11e 	bne	r3,zero,81127b90 <___vfprintf_internal_r+0x21f0>
8112648c:	94800414 	ori	r18,r18,16
81126490:	9080080c 	andi	r2,r18,32
81126494:	10020c26 	beq	r2,zero,81126cc8 <___vfprintf_internal_r+0x1328>
81126498:	d8802d17 	ldw	r2,180(sp)
8112649c:	d9002917 	ldw	r4,164(sp)
811264a0:	d8002785 	stb	zero,158(sp)
811264a4:	10c00204 	addi	r3,r2,8
811264a8:	14c00017 	ldw	r19,0(r2)
811264ac:	15800117 	ldw	r22,4(r2)
811264b0:	20040f16 	blt	r4,zero,811274f0 <___vfprintf_internal_r+0x1b50>
811264b4:	013fdfc4 	movi	r4,-129
811264b8:	9d84b03a 	or	r2,r19,r22
811264bc:	d8c02d15 	stw	r3,180(sp)
811264c0:	9124703a 	and	r18,r18,r4
811264c4:	0039883a 	mov	fp,zero
811264c8:	103e891e 	bne	r2,zero,81125ef0 <__reset+0xfb105ef0>
811264cc:	d9002917 	ldw	r4,164(sp)
811264d0:	2002c11e 	bne	r4,zero,81126fd8 <___vfprintf_internal_r+0x1638>
811264d4:	d8002915 	stw	zero,164(sp)
811264d8:	d8002e15 	stw	zero,184(sp)
811264dc:	dc001e04 	addi	r16,sp,120
811264e0:	003ef806 	br	811260c4 <__reset+0xfb1060c4>
811264e4:	18c03fcc 	andi	r3,r3,255
811264e8:	18059d1e 	bne	r3,zero,81127b60 <___vfprintf_internal_r+0x21c0>
811264ec:	01604574 	movhi	r5,33045
811264f0:	29433b04 	addi	r5,r5,3308
811264f4:	d9403915 	stw	r5,228(sp)
811264f8:	9080080c 	andi	r2,r18,32
811264fc:	10005226 	beq	r2,zero,81126648 <___vfprintf_internal_r+0xca8>
81126500:	d8802d17 	ldw	r2,180(sp)
81126504:	14c00017 	ldw	r19,0(r2)
81126508:	15800117 	ldw	r22,4(r2)
8112650c:	10800204 	addi	r2,r2,8
81126510:	d8802d15 	stw	r2,180(sp)
81126514:	9080004c 	andi	r2,r18,1
81126518:	10019026 	beq	r2,zero,81126b5c <___vfprintf_internal_r+0x11bc>
8112651c:	9d84b03a 	or	r2,r19,r22
81126520:	10036926 	beq	r2,zero,811272c8 <___vfprintf_internal_r+0x1928>
81126524:	d8c02917 	ldw	r3,164(sp)
81126528:	00800c04 	movi	r2,48
8112652c:	d8802705 	stb	r2,156(sp)
81126530:	dc402745 	stb	r17,157(sp)
81126534:	d8002785 	stb	zero,158(sp)
81126538:	90800094 	ori	r2,r18,2
8112653c:	18045d16 	blt	r3,zero,811276b4 <___vfprintf_internal_r+0x1d14>
81126540:	00bfdfc4 	movi	r2,-129
81126544:	90a4703a 	and	r18,r18,r2
81126548:	94800094 	ori	r18,r18,2
8112654c:	0039883a 	mov	fp,zero
81126550:	d9003917 	ldw	r4,228(sp)
81126554:	dc001e04 	addi	r16,sp,120
81126558:	988003cc 	andi	r2,r19,15
8112655c:	b006973a 	slli	r3,r22,28
81126560:	2085883a 	add	r2,r4,r2
81126564:	9826d13a 	srli	r19,r19,4
81126568:	10800003 	ldbu	r2,0(r2)
8112656c:	b02cd13a 	srli	r22,r22,4
81126570:	843fffc4 	addi	r16,r16,-1
81126574:	1ce6b03a 	or	r19,r3,r19
81126578:	80800005 	stb	r2,0(r16)
8112657c:	9d84b03a 	or	r2,r19,r22
81126580:	103ff51e 	bne	r2,zero,81126558 <__reset+0xfb106558>
81126584:	d8c02817 	ldw	r3,160(sp)
81126588:	1c07c83a 	sub	r3,r3,r16
8112658c:	d8c02e15 	stw	r3,184(sp)
81126590:	003ecc06 	br	811260c4 <__reset+0xfb1060c4>
81126594:	18c03fcc 	andi	r3,r3,255
81126598:	183e9f26 	beq	r3,zero,81126018 <__reset+0xfb106018>
8112659c:	d9c02785 	stb	r7,158(sp)
811265a0:	003e9d06 	br	81126018 <__reset+0xfb106018>
811265a4:	00c00044 	movi	r3,1
811265a8:	01c00ac4 	movi	r7,43
811265ac:	ac400007 	ldb	r17,0(r21)
811265b0:	003d5e06 	br	81125b2c <__reset+0xfb105b2c>
811265b4:	94800814 	ori	r18,r18,32
811265b8:	ac400007 	ldb	r17,0(r21)
811265bc:	003d5b06 	br	81125b2c <__reset+0xfb105b2c>
811265c0:	d8c02d17 	ldw	r3,180(sp)
811265c4:	d8002785 	stb	zero,158(sp)
811265c8:	1c000017 	ldw	r16,0(r3)
811265cc:	1cc00104 	addi	r19,r3,4
811265d0:	80041926 	beq	r16,zero,81127638 <___vfprintf_internal_r+0x1c98>
811265d4:	d9002917 	ldw	r4,164(sp)
811265d8:	2003d016 	blt	r4,zero,8112751c <___vfprintf_internal_r+0x1b7c>
811265dc:	200d883a 	mov	r6,r4
811265e0:	000b883a 	mov	r5,zero
811265e4:	8009883a 	mov	r4,r16
811265e8:	da003d15 	stw	r8,244(sp)
811265ec:	112c9840 	call	8112c984 <memchr>
811265f0:	da003d17 	ldw	r8,244(sp)
811265f4:	10045426 	beq	r2,zero,81127748 <___vfprintf_internal_r+0x1da8>
811265f8:	1405c83a 	sub	r2,r2,r16
811265fc:	d8802e15 	stw	r2,184(sp)
81126600:	1003cc16 	blt	r2,zero,81127534 <___vfprintf_internal_r+0x1b94>
81126604:	df002783 	ldbu	fp,158(sp)
81126608:	d8802a15 	stw	r2,168(sp)
8112660c:	dcc02d15 	stw	r19,180(sp)
81126610:	d8002915 	stw	zero,164(sp)
81126614:	d8003215 	stw	zero,200(sp)
81126618:	003eb006 	br	811260dc <__reset+0xfb1060dc>
8112661c:	18c03fcc 	andi	r3,r3,255
81126620:	183f9b26 	beq	r3,zero,81126490 <__reset+0xfb106490>
81126624:	d9c02785 	stb	r7,158(sp)
81126628:	003f9906 	br	81126490 <__reset+0xfb106490>
8112662c:	18c03fcc 	andi	r3,r3,255
81126630:	1805551e 	bne	r3,zero,81127b88 <___vfprintf_internal_r+0x21e8>
81126634:	01604574 	movhi	r5,33045
81126638:	29434004 	addi	r5,r5,3328
8112663c:	d9403915 	stw	r5,228(sp)
81126640:	9080080c 	andi	r2,r18,32
81126644:	103fae1e 	bne	r2,zero,81126500 <__reset+0xfb106500>
81126648:	9080040c 	andi	r2,r18,16
8112664c:	1002de26 	beq	r2,zero,811271c8 <___vfprintf_internal_r+0x1828>
81126650:	d8c02d17 	ldw	r3,180(sp)
81126654:	002d883a 	mov	r22,zero
81126658:	1cc00017 	ldw	r19,0(r3)
8112665c:	18c00104 	addi	r3,r3,4
81126660:	d8c02d15 	stw	r3,180(sp)
81126664:	003fab06 	br	81126514 <__reset+0xfb106514>
81126668:	38803fcc 	andi	r2,r7,255
8112666c:	1080201c 	xori	r2,r2,128
81126670:	10bfe004 	addi	r2,r2,-128
81126674:	1002d21e 	bne	r2,zero,811271c0 <___vfprintf_internal_r+0x1820>
81126678:	00c00044 	movi	r3,1
8112667c:	01c00804 	movi	r7,32
81126680:	ac400007 	ldb	r17,0(r21)
81126684:	003d2906 	br	81125b2c <__reset+0xfb105b2c>
81126688:	94800054 	ori	r18,r18,1
8112668c:	ac400007 	ldb	r17,0(r21)
81126690:	003d2606 	br	81125b2c <__reset+0xfb105b2c>
81126694:	18c03fcc 	andi	r3,r3,255
81126698:	183e0526 	beq	r3,zero,81125eb0 <__reset+0xfb105eb0>
8112669c:	d9c02785 	stb	r7,158(sp)
811266a0:	003e0306 	br	81125eb0 <__reset+0xfb105eb0>
811266a4:	94801014 	ori	r18,r18,64
811266a8:	ac400007 	ldb	r17,0(r21)
811266ac:	003d1f06 	br	81125b2c <__reset+0xfb105b2c>
811266b0:	ac400007 	ldb	r17,0(r21)
811266b4:	8a438726 	beq	r17,r9,811274d4 <___vfprintf_internal_r+0x1b34>
811266b8:	94800414 	ori	r18,r18,16
811266bc:	003d1b06 	br	81125b2c <__reset+0xfb105b2c>
811266c0:	18c03fcc 	andi	r3,r3,255
811266c4:	1805341e 	bne	r3,zero,81127b98 <___vfprintf_internal_r+0x21f8>
811266c8:	9080080c 	andi	r2,r18,32
811266cc:	1002cd26 	beq	r2,zero,81127204 <___vfprintf_internal_r+0x1864>
811266d0:	d9402d17 	ldw	r5,180(sp)
811266d4:	d9002f17 	ldw	r4,188(sp)
811266d8:	28800017 	ldw	r2,0(r5)
811266dc:	2007d7fa 	srai	r3,r4,31
811266e0:	29400104 	addi	r5,r5,4
811266e4:	d9402d15 	stw	r5,180(sp)
811266e8:	11000015 	stw	r4,0(r2)
811266ec:	10c00115 	stw	r3,4(r2)
811266f0:	003ce506 	br	81125a88 <__reset+0xfb105a88>
811266f4:	d8c02d17 	ldw	r3,180(sp)
811266f8:	d9002d17 	ldw	r4,180(sp)
811266fc:	d8002785 	stb	zero,158(sp)
81126700:	18800017 	ldw	r2,0(r3)
81126704:	21000104 	addi	r4,r4,4
81126708:	00c00044 	movi	r3,1
8112670c:	d8c02a15 	stw	r3,168(sp)
81126710:	d8801405 	stb	r2,80(sp)
81126714:	d9002d15 	stw	r4,180(sp)
81126718:	d8c02e15 	stw	r3,184(sp)
8112671c:	d8002915 	stw	zero,164(sp)
81126720:	d8003215 	stw	zero,200(sp)
81126724:	dc001404 	addi	r16,sp,80
81126728:	0039883a 	mov	fp,zero
8112672c:	003e7206 	br	811260f8 <__reset+0xfb1060f8>
81126730:	01204574 	movhi	r4,33045
81126734:	21034004 	addi	r4,r4,3328
81126738:	0039883a 	mov	fp,zero
8112673c:	d9003915 	stw	r4,228(sp)
81126740:	04401e04 	movi	r17,120
81126744:	003f8206 	br	81126550 <__reset+0xfb106550>
81126748:	18c03fcc 	andi	r3,r3,255
8112674c:	1805061e 	bne	r3,zero,81127b68 <___vfprintf_internal_r+0x21c8>
81126750:	883d9126 	beq	r17,zero,81125d98 <__reset+0xfb105d98>
81126754:	00c00044 	movi	r3,1
81126758:	d8c02a15 	stw	r3,168(sp)
8112675c:	dc401405 	stb	r17,80(sp)
81126760:	d8002785 	stb	zero,158(sp)
81126764:	003fec06 	br	81126718 <__reset+0xfb106718>
81126768:	01604574 	movhi	r5,33045
8112676c:	29434004 	addi	r5,r5,3328
81126770:	d9403915 	stw	r5,228(sp)
81126774:	d8c02d15 	stw	r3,180(sp)
81126778:	1025883a 	mov	r18,r2
8112677c:	04401e04 	movi	r17,120
81126780:	9d84b03a 	or	r2,r19,r22
81126784:	1000fc1e 	bne	r2,zero,81126b78 <___vfprintf_internal_r+0x11d8>
81126788:	0039883a 	mov	fp,zero
8112678c:	00800084 	movi	r2,2
81126790:	10803fcc 	andi	r2,r2,255
81126794:	00c00044 	movi	r3,1
81126798:	10c20f26 	beq	r2,r3,81126fd8 <___vfprintf_internal_r+0x1638>
8112679c:	00c00084 	movi	r3,2
811267a0:	10fd6326 	beq	r2,r3,81125d30 <__reset+0xfb105d30>
811267a4:	003e2d06 	br	8112605c <__reset+0xfb10605c>
811267a8:	d8c02017 	ldw	r3,128(sp)
811267ac:	003e9306 	br	811261fc <__reset+0xfb1061fc>
811267b0:	00801944 	movi	r2,101
811267b4:	14407e0e 	bge	r2,r17,811269b0 <___vfprintf_internal_r+0x1010>
811267b8:	d9003617 	ldw	r4,216(sp)
811267bc:	d9403817 	ldw	r5,224(sp)
811267c0:	000d883a 	mov	r6,zero
811267c4:	000f883a 	mov	r7,zero
811267c8:	d8c03c15 	stw	r3,240(sp)
811267cc:	da003d15 	stw	r8,244(sp)
811267d0:	11360740 	call	81136074 <__eqdf2>
811267d4:	d8c03c17 	ldw	r3,240(sp)
811267d8:	da003d17 	ldw	r8,244(sp)
811267dc:	1000f71e 	bne	r2,zero,81126bbc <___vfprintf_internal_r+0x121c>
811267e0:	d8801f17 	ldw	r2,124(sp)
811267e4:	01204574 	movhi	r4,33045
811267e8:	21034704 	addi	r4,r4,3356
811267ec:	18c00044 	addi	r3,r3,1
811267f0:	10800044 	addi	r2,r2,1
811267f4:	41000015 	stw	r4,0(r8)
811267f8:	01000044 	movi	r4,1
811267fc:	41000115 	stw	r4,4(r8)
81126800:	d8c02015 	stw	r3,128(sp)
81126804:	d8801f15 	stw	r2,124(sp)
81126808:	010001c4 	movi	r4,7
8112680c:	2082b816 	blt	r4,r2,811272f0 <___vfprintf_internal_r+0x1950>
81126810:	42000204 	addi	r8,r8,8
81126814:	d8802617 	ldw	r2,152(sp)
81126818:	d9403317 	ldw	r5,204(sp)
8112681c:	11400216 	blt	r2,r5,81126828 <___vfprintf_internal_r+0xe88>
81126820:	9080004c 	andi	r2,r18,1
81126824:	103ed526 	beq	r2,zero,8112637c <__reset+0xfb10637c>
81126828:	d8803717 	ldw	r2,220(sp)
8112682c:	d9003417 	ldw	r4,208(sp)
81126830:	d9403717 	ldw	r5,220(sp)
81126834:	1887883a 	add	r3,r3,r2
81126838:	d8801f17 	ldw	r2,124(sp)
8112683c:	41000015 	stw	r4,0(r8)
81126840:	41400115 	stw	r5,4(r8)
81126844:	10800044 	addi	r2,r2,1
81126848:	d8c02015 	stw	r3,128(sp)
8112684c:	d8801f15 	stw	r2,124(sp)
81126850:	010001c4 	movi	r4,7
81126854:	20832916 	blt	r4,r2,811274fc <___vfprintf_internal_r+0x1b5c>
81126858:	42000204 	addi	r8,r8,8
8112685c:	d8803317 	ldw	r2,204(sp)
81126860:	143fffc4 	addi	r16,r2,-1
81126864:	043ec50e 	bge	zero,r16,8112637c <__reset+0xfb10637c>
81126868:	04400404 	movi	r17,16
8112686c:	d8801f17 	ldw	r2,124(sp)
81126870:	8c00880e 	bge	r17,r16,81126a94 <___vfprintf_internal_r+0x10f4>
81126874:	01604574 	movhi	r5,33045
81126878:	29434f84 	addi	r5,r5,3390
8112687c:	d9402b15 	stw	r5,172(sp)
81126880:	058001c4 	movi	r22,7
81126884:	dcc02c17 	ldw	r19,176(sp)
81126888:	00000306 	br	81126898 <___vfprintf_internal_r+0xef8>
8112688c:	42000204 	addi	r8,r8,8
81126890:	843ffc04 	addi	r16,r16,-16
81126894:	8c00820e 	bge	r17,r16,81126aa0 <___vfprintf_internal_r+0x1100>
81126898:	18c00404 	addi	r3,r3,16
8112689c:	10800044 	addi	r2,r2,1
811268a0:	45000015 	stw	r20,0(r8)
811268a4:	44400115 	stw	r17,4(r8)
811268a8:	d8c02015 	stw	r3,128(sp)
811268ac:	d8801f15 	stw	r2,124(sp)
811268b0:	b0bff60e 	bge	r22,r2,8112688c <__reset+0xfb10688c>
811268b4:	d9801e04 	addi	r6,sp,120
811268b8:	b80b883a 	mov	r5,r23
811268bc:	9809883a 	mov	r4,r19
811268c0:	11318a80 	call	811318a8 <__sprint_r>
811268c4:	103d3a1e 	bne	r2,zero,81125db0 <__reset+0xfb105db0>
811268c8:	d8c02017 	ldw	r3,128(sp)
811268cc:	d8801f17 	ldw	r2,124(sp)
811268d0:	da000404 	addi	r8,sp,16
811268d4:	003fee06 	br	81126890 <__reset+0xfb106890>
811268d8:	d9403117 	ldw	r5,196(sp)
811268dc:	d8802a17 	ldw	r2,168(sp)
811268e0:	28adc83a 	sub	r22,r5,r2
811268e4:	05be630e 	bge	zero,r22,81126274 <__reset+0xfb106274>
811268e8:	07000404 	movi	fp,16
811268ec:	d8801f17 	ldw	r2,124(sp)
811268f0:	e5838f0e 	bge	fp,r22,81127730 <___vfprintf_internal_r+0x1d90>
811268f4:	01604574 	movhi	r5,33045
811268f8:	29434f84 	addi	r5,r5,3390
811268fc:	dc403015 	stw	r17,192(sp)
81126900:	d9402b15 	stw	r5,172(sp)
81126904:	b023883a 	mov	r17,r22
81126908:	04c001c4 	movi	r19,7
8112690c:	a82d883a 	mov	r22,r21
81126910:	902b883a 	mov	r21,r18
81126914:	8025883a 	mov	r18,r16
81126918:	dc002c17 	ldw	r16,176(sp)
8112691c:	00000306 	br	8112692c <___vfprintf_internal_r+0xf8c>
81126920:	8c7ffc04 	addi	r17,r17,-16
81126924:	42000204 	addi	r8,r8,8
81126928:	e440110e 	bge	fp,r17,81126970 <___vfprintf_internal_r+0xfd0>
8112692c:	18c00404 	addi	r3,r3,16
81126930:	10800044 	addi	r2,r2,1
81126934:	45000015 	stw	r20,0(r8)
81126938:	47000115 	stw	fp,4(r8)
8112693c:	d8c02015 	stw	r3,128(sp)
81126940:	d8801f15 	stw	r2,124(sp)
81126944:	98bff60e 	bge	r19,r2,81126920 <__reset+0xfb106920>
81126948:	d9801e04 	addi	r6,sp,120
8112694c:	b80b883a 	mov	r5,r23
81126950:	8009883a 	mov	r4,r16
81126954:	11318a80 	call	811318a8 <__sprint_r>
81126958:	103d151e 	bne	r2,zero,81125db0 <__reset+0xfb105db0>
8112695c:	8c7ffc04 	addi	r17,r17,-16
81126960:	d8c02017 	ldw	r3,128(sp)
81126964:	d8801f17 	ldw	r2,124(sp)
81126968:	da000404 	addi	r8,sp,16
8112696c:	e47fef16 	blt	fp,r17,8112692c <__reset+0xfb10692c>
81126970:	9021883a 	mov	r16,r18
81126974:	a825883a 	mov	r18,r21
81126978:	b02b883a 	mov	r21,r22
8112697c:	882d883a 	mov	r22,r17
81126980:	dc403017 	ldw	r17,192(sp)
81126984:	d9002b17 	ldw	r4,172(sp)
81126988:	1d87883a 	add	r3,r3,r22
8112698c:	10800044 	addi	r2,r2,1
81126990:	41000015 	stw	r4,0(r8)
81126994:	45800115 	stw	r22,4(r8)
81126998:	d8c02015 	stw	r3,128(sp)
8112699c:	d8801f15 	stw	r2,124(sp)
811269a0:	010001c4 	movi	r4,7
811269a4:	20818e16 	blt	r4,r2,81126fe0 <___vfprintf_internal_r+0x1640>
811269a8:	42000204 	addi	r8,r8,8
811269ac:	003e3106 	br	81126274 <__reset+0xfb106274>
811269b0:	d9403317 	ldw	r5,204(sp)
811269b4:	00800044 	movi	r2,1
811269b8:	18c00044 	addi	r3,r3,1
811269bc:	1141530e 	bge	r2,r5,81126f0c <___vfprintf_internal_r+0x156c>
811269c0:	dc401f17 	ldw	r17,124(sp)
811269c4:	00800044 	movi	r2,1
811269c8:	40800115 	stw	r2,4(r8)
811269cc:	8c400044 	addi	r17,r17,1
811269d0:	44000015 	stw	r16,0(r8)
811269d4:	d8c02015 	stw	r3,128(sp)
811269d8:	dc401f15 	stw	r17,124(sp)
811269dc:	008001c4 	movi	r2,7
811269e0:	14416b16 	blt	r2,r17,81126f90 <___vfprintf_internal_r+0x15f0>
811269e4:	42000204 	addi	r8,r8,8
811269e8:	d8803717 	ldw	r2,220(sp)
811269ec:	d9003417 	ldw	r4,208(sp)
811269f0:	8c400044 	addi	r17,r17,1
811269f4:	10c7883a 	add	r3,r2,r3
811269f8:	40800115 	stw	r2,4(r8)
811269fc:	41000015 	stw	r4,0(r8)
81126a00:	d8c02015 	stw	r3,128(sp)
81126a04:	dc401f15 	stw	r17,124(sp)
81126a08:	008001c4 	movi	r2,7
81126a0c:	14416916 	blt	r2,r17,81126fb4 <___vfprintf_internal_r+0x1614>
81126a10:	45800204 	addi	r22,r8,8
81126a14:	d9003617 	ldw	r4,216(sp)
81126a18:	d9403817 	ldw	r5,224(sp)
81126a1c:	000d883a 	mov	r6,zero
81126a20:	000f883a 	mov	r7,zero
81126a24:	d8c03c15 	stw	r3,240(sp)
81126a28:	11360740 	call	81136074 <__eqdf2>
81126a2c:	d8c03c17 	ldw	r3,240(sp)
81126a30:	1000bc26 	beq	r2,zero,81126d24 <___vfprintf_internal_r+0x1384>
81126a34:	d9403317 	ldw	r5,204(sp)
81126a38:	84000044 	addi	r16,r16,1
81126a3c:	8c400044 	addi	r17,r17,1
81126a40:	28bfffc4 	addi	r2,r5,-1
81126a44:	1887883a 	add	r3,r3,r2
81126a48:	b0800115 	stw	r2,4(r22)
81126a4c:	b4000015 	stw	r16,0(r22)
81126a50:	d8c02015 	stw	r3,128(sp)
81126a54:	dc401f15 	stw	r17,124(sp)
81126a58:	008001c4 	movi	r2,7
81126a5c:	14414316 	blt	r2,r17,81126f6c <___vfprintf_internal_r+0x15cc>
81126a60:	b5800204 	addi	r22,r22,8
81126a64:	d9003a17 	ldw	r4,232(sp)
81126a68:	df0022c4 	addi	fp,sp,139
81126a6c:	8c400044 	addi	r17,r17,1
81126a70:	20c7883a 	add	r3,r4,r3
81126a74:	b7000015 	stw	fp,0(r22)
81126a78:	b1000115 	stw	r4,4(r22)
81126a7c:	d8c02015 	stw	r3,128(sp)
81126a80:	dc401f15 	stw	r17,124(sp)
81126a84:	008001c4 	movi	r2,7
81126a88:	14400e16 	blt	r2,r17,81126ac4 <___vfprintf_internal_r+0x1124>
81126a8c:	b2000204 	addi	r8,r22,8
81126a90:	003e3a06 	br	8112637c <__reset+0xfb10637c>
81126a94:	01204574 	movhi	r4,33045
81126a98:	21034f84 	addi	r4,r4,3390
81126a9c:	d9002b15 	stw	r4,172(sp)
81126aa0:	d9002b17 	ldw	r4,172(sp)
81126aa4:	1c07883a 	add	r3,r3,r16
81126aa8:	44000115 	stw	r16,4(r8)
81126aac:	41000015 	stw	r4,0(r8)
81126ab0:	10800044 	addi	r2,r2,1
81126ab4:	d8c02015 	stw	r3,128(sp)
81126ab8:	d8801f15 	stw	r2,124(sp)
81126abc:	010001c4 	movi	r4,7
81126ac0:	20be2d0e 	bge	r4,r2,81126378 <__reset+0xfb106378>
81126ac4:	d9002c17 	ldw	r4,176(sp)
81126ac8:	d9801e04 	addi	r6,sp,120
81126acc:	b80b883a 	mov	r5,r23
81126ad0:	11318a80 	call	811318a8 <__sprint_r>
81126ad4:	103cb61e 	bne	r2,zero,81125db0 <__reset+0xfb105db0>
81126ad8:	d8c02017 	ldw	r3,128(sp)
81126adc:	da000404 	addi	r8,sp,16
81126ae0:	003e2606 	br	8112637c <__reset+0xfb10637c>
81126ae4:	d9002c17 	ldw	r4,176(sp)
81126ae8:	d9801e04 	addi	r6,sp,120
81126aec:	b80b883a 	mov	r5,r23
81126af0:	11318a80 	call	811318a8 <__sprint_r>
81126af4:	103e5d26 	beq	r2,zero,8112646c <__reset+0xfb10646c>
81126af8:	003cad06 	br	81125db0 <__reset+0xfb105db0>
81126afc:	d9002c17 	ldw	r4,176(sp)
81126b00:	d9801e04 	addi	r6,sp,120
81126b04:	b80b883a 	mov	r5,r23
81126b08:	11318a80 	call	811318a8 <__sprint_r>
81126b0c:	103ca81e 	bne	r2,zero,81125db0 <__reset+0xfb105db0>
81126b10:	d8c02017 	ldw	r3,128(sp)
81126b14:	da000404 	addi	r8,sp,16
81126b18:	003e0b06 	br	81126348 <__reset+0xfb106348>
81126b1c:	d9002c17 	ldw	r4,176(sp)
81126b20:	d9801e04 	addi	r6,sp,120
81126b24:	b80b883a 	mov	r5,r23
81126b28:	11318a80 	call	811318a8 <__sprint_r>
81126b2c:	103ca01e 	bne	r2,zero,81125db0 <__reset+0xfb105db0>
81126b30:	d8c02017 	ldw	r3,128(sp)
81126b34:	da000404 	addi	r8,sp,16
81126b38:	003dbd06 	br	81126230 <__reset+0xfb106230>
81126b3c:	d9002c17 	ldw	r4,176(sp)
81126b40:	d9801e04 	addi	r6,sp,120
81126b44:	b80b883a 	mov	r5,r23
81126b48:	11318a80 	call	811318a8 <__sprint_r>
81126b4c:	103c981e 	bne	r2,zero,81125db0 <__reset+0xfb105db0>
81126b50:	d8c02017 	ldw	r3,128(sp)
81126b54:	da000404 	addi	r8,sp,16
81126b58:	003dc306 	br	81126268 <__reset+0xfb106268>
81126b5c:	d8802917 	ldw	r2,164(sp)
81126b60:	d8002785 	stb	zero,158(sp)
81126b64:	103f0616 	blt	r2,zero,81126780 <__reset+0xfb106780>
81126b68:	00ffdfc4 	movi	r3,-129
81126b6c:	9d84b03a 	or	r2,r19,r22
81126b70:	90e4703a 	and	r18,r18,r3
81126b74:	103c6b26 	beq	r2,zero,81125d24 <__reset+0xfb105d24>
81126b78:	0039883a 	mov	fp,zero
81126b7c:	003e7406 	br	81126550 <__reset+0xfb106550>
81126b80:	9080040c 	andi	r2,r18,16
81126b84:	1001b326 	beq	r2,zero,81127254 <___vfprintf_internal_r+0x18b4>
81126b88:	d9002d17 	ldw	r4,180(sp)
81126b8c:	d9402917 	ldw	r5,164(sp)
81126b90:	d8002785 	stb	zero,158(sp)
81126b94:	20800104 	addi	r2,r4,4
81126b98:	24c00017 	ldw	r19,0(r4)
81126b9c:	002d883a 	mov	r22,zero
81126ba0:	2801b516 	blt	r5,zero,81127278 <___vfprintf_internal_r+0x18d8>
81126ba4:	00ffdfc4 	movi	r3,-129
81126ba8:	d8802d15 	stw	r2,180(sp)
81126bac:	90e4703a 	and	r18,r18,r3
81126bb0:	983d2726 	beq	r19,zero,81126050 <__reset+0xfb106050>
81126bb4:	0039883a 	mov	fp,zero
81126bb8:	003d2a06 	br	81126064 <__reset+0xfb106064>
81126bbc:	dc402617 	ldw	r17,152(sp)
81126bc0:	0441d30e 	bge	zero,r17,81127310 <___vfprintf_internal_r+0x1970>
81126bc4:	dc403217 	ldw	r17,200(sp)
81126bc8:	d8803317 	ldw	r2,204(sp)
81126bcc:	1440010e 	bge	r2,r17,81126bd4 <___vfprintf_internal_r+0x1234>
81126bd0:	1023883a 	mov	r17,r2
81126bd4:	04400a0e 	bge	zero,r17,81126c00 <___vfprintf_internal_r+0x1260>
81126bd8:	d8801f17 	ldw	r2,124(sp)
81126bdc:	1c47883a 	add	r3,r3,r17
81126be0:	44000015 	stw	r16,0(r8)
81126be4:	10800044 	addi	r2,r2,1
81126be8:	44400115 	stw	r17,4(r8)
81126bec:	d8c02015 	stw	r3,128(sp)
81126bf0:	d8801f15 	stw	r2,124(sp)
81126bf4:	010001c4 	movi	r4,7
81126bf8:	20826516 	blt	r4,r2,81127590 <___vfprintf_internal_r+0x1bf0>
81126bfc:	42000204 	addi	r8,r8,8
81126c00:	88026116 	blt	r17,zero,81127588 <___vfprintf_internal_r+0x1be8>
81126c04:	d9003217 	ldw	r4,200(sp)
81126c08:	2463c83a 	sub	r17,r4,r17
81126c0c:	04407b0e 	bge	zero,r17,81126dfc <___vfprintf_internal_r+0x145c>
81126c10:	05800404 	movi	r22,16
81126c14:	d8801f17 	ldw	r2,124(sp)
81126c18:	b4419d0e 	bge	r22,r17,81127290 <___vfprintf_internal_r+0x18f0>
81126c1c:	01204574 	movhi	r4,33045
81126c20:	21034f84 	addi	r4,r4,3390
81126c24:	d9002b15 	stw	r4,172(sp)
81126c28:	070001c4 	movi	fp,7
81126c2c:	dcc02c17 	ldw	r19,176(sp)
81126c30:	00000306 	br	81126c40 <___vfprintf_internal_r+0x12a0>
81126c34:	42000204 	addi	r8,r8,8
81126c38:	8c7ffc04 	addi	r17,r17,-16
81126c3c:	b441970e 	bge	r22,r17,8112729c <___vfprintf_internal_r+0x18fc>
81126c40:	18c00404 	addi	r3,r3,16
81126c44:	10800044 	addi	r2,r2,1
81126c48:	45000015 	stw	r20,0(r8)
81126c4c:	45800115 	stw	r22,4(r8)
81126c50:	d8c02015 	stw	r3,128(sp)
81126c54:	d8801f15 	stw	r2,124(sp)
81126c58:	e0bff60e 	bge	fp,r2,81126c34 <__reset+0xfb106c34>
81126c5c:	d9801e04 	addi	r6,sp,120
81126c60:	b80b883a 	mov	r5,r23
81126c64:	9809883a 	mov	r4,r19
81126c68:	11318a80 	call	811318a8 <__sprint_r>
81126c6c:	103c501e 	bne	r2,zero,81125db0 <__reset+0xfb105db0>
81126c70:	d8c02017 	ldw	r3,128(sp)
81126c74:	d8801f17 	ldw	r2,124(sp)
81126c78:	da000404 	addi	r8,sp,16
81126c7c:	003fee06 	br	81126c38 <__reset+0xfb106c38>
81126c80:	d9002c17 	ldw	r4,176(sp)
81126c84:	d9801e04 	addi	r6,sp,120
81126c88:	b80b883a 	mov	r5,r23
81126c8c:	11318a80 	call	811318a8 <__sprint_r>
81126c90:	103c471e 	bne	r2,zero,81125db0 <__reset+0xfb105db0>
81126c94:	d8c02017 	ldw	r3,128(sp)
81126c98:	df002787 	ldb	fp,158(sp)
81126c9c:	da000404 	addi	r8,sp,16
81126ca0:	003d5606 	br	811261fc <__reset+0xfb1061fc>
81126ca4:	9080040c 	andi	r2,r18,16
81126ca8:	10016126 	beq	r2,zero,81127230 <___vfprintf_internal_r+0x1890>
81126cac:	d8802d17 	ldw	r2,180(sp)
81126cb0:	14c00017 	ldw	r19,0(r2)
81126cb4:	10800104 	addi	r2,r2,4
81126cb8:	d8802d15 	stw	r2,180(sp)
81126cbc:	982dd7fa 	srai	r22,r19,31
81126cc0:	b005883a 	mov	r2,r22
81126cc4:	003c8206 	br	81125ed0 <__reset+0xfb105ed0>
81126cc8:	9080040c 	andi	r2,r18,16
81126ccc:	10003526 	beq	r2,zero,81126da4 <___vfprintf_internal_r+0x1404>
81126cd0:	d9402d17 	ldw	r5,180(sp)
81126cd4:	d8c02917 	ldw	r3,164(sp)
81126cd8:	d8002785 	stb	zero,158(sp)
81126cdc:	28800104 	addi	r2,r5,4
81126ce0:	2cc00017 	ldw	r19,0(r5)
81126ce4:	002d883a 	mov	r22,zero
81126ce8:	18003716 	blt	r3,zero,81126dc8 <___vfprintf_internal_r+0x1428>
81126cec:	00ffdfc4 	movi	r3,-129
81126cf0:	d8802d15 	stw	r2,180(sp)
81126cf4:	90e4703a 	and	r18,r18,r3
81126cf8:	0039883a 	mov	fp,zero
81126cfc:	983df326 	beq	r19,zero,811264cc <__reset+0xfb1064cc>
81126d00:	00800244 	movi	r2,9
81126d04:	14fc7b36 	bltu	r2,r19,81125ef4 <__reset+0xfb105ef4>
81126d08:	d8c02817 	ldw	r3,160(sp)
81126d0c:	dc001dc4 	addi	r16,sp,119
81126d10:	9cc00c04 	addi	r19,r19,48
81126d14:	1c07c83a 	sub	r3,r3,r16
81126d18:	dcc01dc5 	stb	r19,119(sp)
81126d1c:	d8c02e15 	stw	r3,184(sp)
81126d20:	003ce806 	br	811260c4 <__reset+0xfb1060c4>
81126d24:	d8803317 	ldw	r2,204(sp)
81126d28:	143fffc4 	addi	r16,r2,-1
81126d2c:	043f4d0e 	bge	zero,r16,81126a64 <__reset+0xfb106a64>
81126d30:	07000404 	movi	fp,16
81126d34:	e400810e 	bge	fp,r16,81126f3c <___vfprintf_internal_r+0x159c>
81126d38:	01604574 	movhi	r5,33045
81126d3c:	29434f84 	addi	r5,r5,3390
81126d40:	d9402b15 	stw	r5,172(sp)
81126d44:	01c001c4 	movi	r7,7
81126d48:	dcc02c17 	ldw	r19,176(sp)
81126d4c:	00000306 	br	81126d5c <___vfprintf_internal_r+0x13bc>
81126d50:	b5800204 	addi	r22,r22,8
81126d54:	843ffc04 	addi	r16,r16,-16
81126d58:	e4007b0e 	bge	fp,r16,81126f48 <___vfprintf_internal_r+0x15a8>
81126d5c:	18c00404 	addi	r3,r3,16
81126d60:	8c400044 	addi	r17,r17,1
81126d64:	b5000015 	stw	r20,0(r22)
81126d68:	b7000115 	stw	fp,4(r22)
81126d6c:	d8c02015 	stw	r3,128(sp)
81126d70:	dc401f15 	stw	r17,124(sp)
81126d74:	3c7ff60e 	bge	r7,r17,81126d50 <__reset+0xfb106d50>
81126d78:	d9801e04 	addi	r6,sp,120
81126d7c:	b80b883a 	mov	r5,r23
81126d80:	9809883a 	mov	r4,r19
81126d84:	d9c03c15 	stw	r7,240(sp)
81126d88:	11318a80 	call	811318a8 <__sprint_r>
81126d8c:	d9c03c17 	ldw	r7,240(sp)
81126d90:	103c071e 	bne	r2,zero,81125db0 <__reset+0xfb105db0>
81126d94:	d8c02017 	ldw	r3,128(sp)
81126d98:	dc401f17 	ldw	r17,124(sp)
81126d9c:	dd800404 	addi	r22,sp,16
81126da0:	003fec06 	br	81126d54 <__reset+0xfb106d54>
81126da4:	9080100c 	andi	r2,r18,64
81126da8:	d8002785 	stb	zero,158(sp)
81126dac:	10010e26 	beq	r2,zero,811271e8 <___vfprintf_internal_r+0x1848>
81126db0:	d9002d17 	ldw	r4,180(sp)
81126db4:	d9402917 	ldw	r5,164(sp)
81126db8:	002d883a 	mov	r22,zero
81126dbc:	20800104 	addi	r2,r4,4
81126dc0:	24c0000b 	ldhu	r19,0(r4)
81126dc4:	283fc90e 	bge	r5,zero,81126cec <__reset+0xfb106cec>
81126dc8:	d8802d15 	stw	r2,180(sp)
81126dcc:	0039883a 	mov	fp,zero
81126dd0:	9d84b03a 	or	r2,r19,r22
81126dd4:	103c461e 	bne	r2,zero,81125ef0 <__reset+0xfb105ef0>
81126dd8:	00800044 	movi	r2,1
81126ddc:	003e6c06 	br	81126790 <__reset+0xfb106790>
81126de0:	d9002c17 	ldw	r4,176(sp)
81126de4:	d9801e04 	addi	r6,sp,120
81126de8:	b80b883a 	mov	r5,r23
81126dec:	11318a80 	call	811318a8 <__sprint_r>
81126df0:	103bef1e 	bne	r2,zero,81125db0 <__reset+0xfb105db0>
81126df4:	d8c02017 	ldw	r3,128(sp)
81126df8:	da000404 	addi	r8,sp,16
81126dfc:	d9003217 	ldw	r4,200(sp)
81126e00:	d8802617 	ldw	r2,152(sp)
81126e04:	d9403317 	ldw	r5,204(sp)
81126e08:	8123883a 	add	r17,r16,r4
81126e0c:	11400216 	blt	r2,r5,81126e18 <___vfprintf_internal_r+0x1478>
81126e10:	9100004c 	andi	r4,r18,1
81126e14:	20000d26 	beq	r4,zero,81126e4c <___vfprintf_internal_r+0x14ac>
81126e18:	d9003717 	ldw	r4,220(sp)
81126e1c:	d9403417 	ldw	r5,208(sp)
81126e20:	1907883a 	add	r3,r3,r4
81126e24:	d9001f17 	ldw	r4,124(sp)
81126e28:	41400015 	stw	r5,0(r8)
81126e2c:	d9403717 	ldw	r5,220(sp)
81126e30:	21000044 	addi	r4,r4,1
81126e34:	d8c02015 	stw	r3,128(sp)
81126e38:	41400115 	stw	r5,4(r8)
81126e3c:	d9001f15 	stw	r4,124(sp)
81126e40:	014001c4 	movi	r5,7
81126e44:	2901e816 	blt	r5,r4,811275e8 <___vfprintf_internal_r+0x1c48>
81126e48:	42000204 	addi	r8,r8,8
81126e4c:	d9003317 	ldw	r4,204(sp)
81126e50:	8121883a 	add	r16,r16,r4
81126e54:	2085c83a 	sub	r2,r4,r2
81126e58:	8461c83a 	sub	r16,r16,r17
81126e5c:	1400010e 	bge	r2,r16,81126e64 <___vfprintf_internal_r+0x14c4>
81126e60:	1021883a 	mov	r16,r2
81126e64:	04000a0e 	bge	zero,r16,81126e90 <___vfprintf_internal_r+0x14f0>
81126e68:	d9001f17 	ldw	r4,124(sp)
81126e6c:	1c07883a 	add	r3,r3,r16
81126e70:	44400015 	stw	r17,0(r8)
81126e74:	21000044 	addi	r4,r4,1
81126e78:	44000115 	stw	r16,4(r8)
81126e7c:	d8c02015 	stw	r3,128(sp)
81126e80:	d9001f15 	stw	r4,124(sp)
81126e84:	014001c4 	movi	r5,7
81126e88:	2901fb16 	blt	r5,r4,81127678 <___vfprintf_internal_r+0x1cd8>
81126e8c:	42000204 	addi	r8,r8,8
81126e90:	8001f716 	blt	r16,zero,81127670 <___vfprintf_internal_r+0x1cd0>
81126e94:	1421c83a 	sub	r16,r2,r16
81126e98:	043d380e 	bge	zero,r16,8112637c <__reset+0xfb10637c>
81126e9c:	04400404 	movi	r17,16
81126ea0:	d8801f17 	ldw	r2,124(sp)
81126ea4:	8c3efb0e 	bge	r17,r16,81126a94 <__reset+0xfb106a94>
81126ea8:	01604574 	movhi	r5,33045
81126eac:	29434f84 	addi	r5,r5,3390
81126eb0:	d9402b15 	stw	r5,172(sp)
81126eb4:	058001c4 	movi	r22,7
81126eb8:	dcc02c17 	ldw	r19,176(sp)
81126ebc:	00000306 	br	81126ecc <___vfprintf_internal_r+0x152c>
81126ec0:	42000204 	addi	r8,r8,8
81126ec4:	843ffc04 	addi	r16,r16,-16
81126ec8:	8c3ef50e 	bge	r17,r16,81126aa0 <__reset+0xfb106aa0>
81126ecc:	18c00404 	addi	r3,r3,16
81126ed0:	10800044 	addi	r2,r2,1
81126ed4:	45000015 	stw	r20,0(r8)
81126ed8:	44400115 	stw	r17,4(r8)
81126edc:	d8c02015 	stw	r3,128(sp)
81126ee0:	d8801f15 	stw	r2,124(sp)
81126ee4:	b0bff60e 	bge	r22,r2,81126ec0 <__reset+0xfb106ec0>
81126ee8:	d9801e04 	addi	r6,sp,120
81126eec:	b80b883a 	mov	r5,r23
81126ef0:	9809883a 	mov	r4,r19
81126ef4:	11318a80 	call	811318a8 <__sprint_r>
81126ef8:	103bad1e 	bne	r2,zero,81125db0 <__reset+0xfb105db0>
81126efc:	d8c02017 	ldw	r3,128(sp)
81126f00:	d8801f17 	ldw	r2,124(sp)
81126f04:	da000404 	addi	r8,sp,16
81126f08:	003fee06 	br	81126ec4 <__reset+0xfb106ec4>
81126f0c:	9088703a 	and	r4,r18,r2
81126f10:	203eab1e 	bne	r4,zero,811269c0 <__reset+0xfb1069c0>
81126f14:	dc401f17 	ldw	r17,124(sp)
81126f18:	40800115 	stw	r2,4(r8)
81126f1c:	44000015 	stw	r16,0(r8)
81126f20:	8c400044 	addi	r17,r17,1
81126f24:	d8c02015 	stw	r3,128(sp)
81126f28:	dc401f15 	stw	r17,124(sp)
81126f2c:	008001c4 	movi	r2,7
81126f30:	14400e16 	blt	r2,r17,81126f6c <___vfprintf_internal_r+0x15cc>
81126f34:	45800204 	addi	r22,r8,8
81126f38:	003eca06 	br	81126a64 <__reset+0xfb106a64>
81126f3c:	01204574 	movhi	r4,33045
81126f40:	21034f84 	addi	r4,r4,3390
81126f44:	d9002b15 	stw	r4,172(sp)
81126f48:	d8802b17 	ldw	r2,172(sp)
81126f4c:	1c07883a 	add	r3,r3,r16
81126f50:	8c400044 	addi	r17,r17,1
81126f54:	b0800015 	stw	r2,0(r22)
81126f58:	b4000115 	stw	r16,4(r22)
81126f5c:	d8c02015 	stw	r3,128(sp)
81126f60:	dc401f15 	stw	r17,124(sp)
81126f64:	008001c4 	movi	r2,7
81126f68:	147ebd0e 	bge	r2,r17,81126a60 <__reset+0xfb106a60>
81126f6c:	d9002c17 	ldw	r4,176(sp)
81126f70:	d9801e04 	addi	r6,sp,120
81126f74:	b80b883a 	mov	r5,r23
81126f78:	11318a80 	call	811318a8 <__sprint_r>
81126f7c:	103b8c1e 	bne	r2,zero,81125db0 <__reset+0xfb105db0>
81126f80:	d8c02017 	ldw	r3,128(sp)
81126f84:	dc401f17 	ldw	r17,124(sp)
81126f88:	dd800404 	addi	r22,sp,16
81126f8c:	003eb506 	br	81126a64 <__reset+0xfb106a64>
81126f90:	d9002c17 	ldw	r4,176(sp)
81126f94:	d9801e04 	addi	r6,sp,120
81126f98:	b80b883a 	mov	r5,r23
81126f9c:	11318a80 	call	811318a8 <__sprint_r>
81126fa0:	103b831e 	bne	r2,zero,81125db0 <__reset+0xfb105db0>
81126fa4:	d8c02017 	ldw	r3,128(sp)
81126fa8:	dc401f17 	ldw	r17,124(sp)
81126fac:	da000404 	addi	r8,sp,16
81126fb0:	003e8d06 	br	811269e8 <__reset+0xfb1069e8>
81126fb4:	d9002c17 	ldw	r4,176(sp)
81126fb8:	d9801e04 	addi	r6,sp,120
81126fbc:	b80b883a 	mov	r5,r23
81126fc0:	11318a80 	call	811318a8 <__sprint_r>
81126fc4:	103b7a1e 	bne	r2,zero,81125db0 <__reset+0xfb105db0>
81126fc8:	d8c02017 	ldw	r3,128(sp)
81126fcc:	dc401f17 	ldw	r17,124(sp)
81126fd0:	dd800404 	addi	r22,sp,16
81126fd4:	003e8f06 	br	81126a14 <__reset+0xfb106a14>
81126fd8:	0027883a 	mov	r19,zero
81126fdc:	003f4a06 	br	81126d08 <__reset+0xfb106d08>
81126fe0:	d9002c17 	ldw	r4,176(sp)
81126fe4:	d9801e04 	addi	r6,sp,120
81126fe8:	b80b883a 	mov	r5,r23
81126fec:	11318a80 	call	811318a8 <__sprint_r>
81126ff0:	103b6f1e 	bne	r2,zero,81125db0 <__reset+0xfb105db0>
81126ff4:	d8c02017 	ldw	r3,128(sp)
81126ff8:	da000404 	addi	r8,sp,16
81126ffc:	003c9d06 	br	81126274 <__reset+0xfb106274>
81127000:	04e7c83a 	sub	r19,zero,r19
81127004:	9804c03a 	cmpne	r2,r19,zero
81127008:	05adc83a 	sub	r22,zero,r22
8112700c:	b0adc83a 	sub	r22,r22,r2
81127010:	d8802917 	ldw	r2,164(sp)
81127014:	07000b44 	movi	fp,45
81127018:	df002785 	stb	fp,158(sp)
8112701c:	10017b16 	blt	r2,zero,8112760c <___vfprintf_internal_r+0x1c6c>
81127020:	00bfdfc4 	movi	r2,-129
81127024:	90a4703a 	and	r18,r18,r2
81127028:	003bb106 	br	81125ef0 <__reset+0xfb105ef0>
8112702c:	d9003617 	ldw	r4,216(sp)
81127030:	d9403817 	ldw	r5,224(sp)
81127034:	da003d15 	stw	r8,244(sp)
81127038:	112e1f40 	call	8112e1f4 <__fpclassifyd>
8112703c:	da003d17 	ldw	r8,244(sp)
81127040:	1000f026 	beq	r2,zero,81127404 <___vfprintf_internal_r+0x1a64>
81127044:	d9002917 	ldw	r4,164(sp)
81127048:	05bff7c4 	movi	r22,-33
8112704c:	00bfffc4 	movi	r2,-1
81127050:	8dac703a 	and	r22,r17,r22
81127054:	20820026 	beq	r4,r2,81127858 <___vfprintf_internal_r+0x1eb8>
81127058:	008011c4 	movi	r2,71
8112705c:	b081f726 	beq	r22,r2,8112783c <___vfprintf_internal_r+0x1e9c>
81127060:	d9003817 	ldw	r4,224(sp)
81127064:	90c04014 	ori	r3,r18,256
81127068:	d8c02b15 	stw	r3,172(sp)
8112706c:	20021516 	blt	r4,zero,811278c4 <___vfprintf_internal_r+0x1f24>
81127070:	dcc03817 	ldw	r19,224(sp)
81127074:	d8002a05 	stb	zero,168(sp)
81127078:	00801984 	movi	r2,102
8112707c:	8881f926 	beq	r17,r2,81127864 <___vfprintf_internal_r+0x1ec4>
81127080:	00801184 	movi	r2,70
81127084:	88821c26 	beq	r17,r2,811278f8 <___vfprintf_internal_r+0x1f58>
81127088:	00801144 	movi	r2,69
8112708c:	b081ef26 	beq	r22,r2,8112784c <___vfprintf_internal_r+0x1eac>
81127090:	d8c02917 	ldw	r3,164(sp)
81127094:	d8802104 	addi	r2,sp,132
81127098:	d8800315 	stw	r2,12(sp)
8112709c:	d9403617 	ldw	r5,216(sp)
811270a0:	d8802504 	addi	r2,sp,148
811270a4:	d9002c17 	ldw	r4,176(sp)
811270a8:	d8800215 	stw	r2,8(sp)
811270ac:	d8802604 	addi	r2,sp,152
811270b0:	d8c00015 	stw	r3,0(sp)
811270b4:	d8800115 	stw	r2,4(sp)
811270b8:	01c00084 	movi	r7,2
811270bc:	980d883a 	mov	r6,r19
811270c0:	d8c03c15 	stw	r3,240(sp)
811270c4:	da003d15 	stw	r8,244(sp)
811270c8:	1129aac0 	call	81129aac <_dtoa_r>
811270cc:	1021883a 	mov	r16,r2
811270d0:	008019c4 	movi	r2,103
811270d4:	d8c03c17 	ldw	r3,240(sp)
811270d8:	da003d17 	ldw	r8,244(sp)
811270dc:	88817126 	beq	r17,r2,811276a4 <___vfprintf_internal_r+0x1d04>
811270e0:	008011c4 	movi	r2,71
811270e4:	88829226 	beq	r17,r2,81127b30 <___vfprintf_internal_r+0x2190>
811270e8:	80f9883a 	add	fp,r16,r3
811270ec:	d9003617 	ldw	r4,216(sp)
811270f0:	000d883a 	mov	r6,zero
811270f4:	000f883a 	mov	r7,zero
811270f8:	980b883a 	mov	r5,r19
811270fc:	da003d15 	stw	r8,244(sp)
81127100:	11360740 	call	81136074 <__eqdf2>
81127104:	da003d17 	ldw	r8,244(sp)
81127108:	10018d26 	beq	r2,zero,81127740 <___vfprintf_internal_r+0x1da0>
8112710c:	d8802117 	ldw	r2,132(sp)
81127110:	1700062e 	bgeu	r2,fp,8112712c <___vfprintf_internal_r+0x178c>
81127114:	01000c04 	movi	r4,48
81127118:	10c00044 	addi	r3,r2,1
8112711c:	d8c02115 	stw	r3,132(sp)
81127120:	11000005 	stb	r4,0(r2)
81127124:	d8802117 	ldw	r2,132(sp)
81127128:	173ffb36 	bltu	r2,fp,81127118 <__reset+0xfb107118>
8112712c:	1405c83a 	sub	r2,r2,r16
81127130:	d8803315 	stw	r2,204(sp)
81127134:	008011c4 	movi	r2,71
81127138:	b0817626 	beq	r22,r2,81127714 <___vfprintf_internal_r+0x1d74>
8112713c:	00801944 	movi	r2,101
81127140:	1442810e 	bge	r2,r17,81127b48 <___vfprintf_internal_r+0x21a8>
81127144:	d8c02617 	ldw	r3,152(sp)
81127148:	00801984 	movi	r2,102
8112714c:	d8c03215 	stw	r3,200(sp)
81127150:	8881fe26 	beq	r17,r2,8112794c <___vfprintf_internal_r+0x1fac>
81127154:	d8c03217 	ldw	r3,200(sp)
81127158:	d9003317 	ldw	r4,204(sp)
8112715c:	1901dd16 	blt	r3,r4,811278d4 <___vfprintf_internal_r+0x1f34>
81127160:	9480004c 	andi	r18,r18,1
81127164:	90022b1e 	bne	r18,zero,81127a14 <___vfprintf_internal_r+0x2074>
81127168:	1805883a 	mov	r2,r3
8112716c:	18028016 	blt	r3,zero,81127b70 <___vfprintf_internal_r+0x21d0>
81127170:	d8c03217 	ldw	r3,200(sp)
81127174:	044019c4 	movi	r17,103
81127178:	d8c02e15 	stw	r3,184(sp)
8112717c:	df002a07 	ldb	fp,168(sp)
81127180:	e001531e 	bne	fp,zero,811276d0 <___vfprintf_internal_r+0x1d30>
81127184:	df002783 	ldbu	fp,158(sp)
81127188:	d8802a15 	stw	r2,168(sp)
8112718c:	dc802b17 	ldw	r18,172(sp)
81127190:	d8002915 	stw	zero,164(sp)
81127194:	003bd106 	br	811260dc <__reset+0xfb1060dc>
81127198:	d8802d17 	ldw	r2,180(sp)
8112719c:	d8c02d17 	ldw	r3,180(sp)
811271a0:	d9002d17 	ldw	r4,180(sp)
811271a4:	10800017 	ldw	r2,0(r2)
811271a8:	18c00117 	ldw	r3,4(r3)
811271ac:	21000204 	addi	r4,r4,8
811271b0:	d8803615 	stw	r2,216(sp)
811271b4:	d8c03815 	stw	r3,224(sp)
811271b8:	d9002d15 	stw	r4,180(sp)
811271bc:	003b7506 	br	81125f94 <__reset+0xfb105f94>
811271c0:	ac400007 	ldb	r17,0(r21)
811271c4:	003a5906 	br	81125b2c <__reset+0xfb105b2c>
811271c8:	9080100c 	andi	r2,r18,64
811271cc:	1000a826 	beq	r2,zero,81127470 <___vfprintf_internal_r+0x1ad0>
811271d0:	d9002d17 	ldw	r4,180(sp)
811271d4:	002d883a 	mov	r22,zero
811271d8:	24c0000b 	ldhu	r19,0(r4)
811271dc:	21000104 	addi	r4,r4,4
811271e0:	d9002d15 	stw	r4,180(sp)
811271e4:	003ccb06 	br	81126514 <__reset+0xfb106514>
811271e8:	d8c02d17 	ldw	r3,180(sp)
811271ec:	d9002917 	ldw	r4,164(sp)
811271f0:	002d883a 	mov	r22,zero
811271f4:	18800104 	addi	r2,r3,4
811271f8:	1cc00017 	ldw	r19,0(r3)
811271fc:	203ebb0e 	bge	r4,zero,81126cec <__reset+0xfb106cec>
81127200:	003ef106 	br	81126dc8 <__reset+0xfb106dc8>
81127204:	9080040c 	andi	r2,r18,16
81127208:	1000921e 	bne	r2,zero,81127454 <___vfprintf_internal_r+0x1ab4>
8112720c:	9480100c 	andi	r18,r18,64
81127210:	90013926 	beq	r18,zero,811276f8 <___vfprintf_internal_r+0x1d58>
81127214:	d9002d17 	ldw	r4,180(sp)
81127218:	d9402f17 	ldw	r5,188(sp)
8112721c:	20800017 	ldw	r2,0(r4)
81127220:	21000104 	addi	r4,r4,4
81127224:	d9002d15 	stw	r4,180(sp)
81127228:	1140000d 	sth	r5,0(r2)
8112722c:	003a1606 	br	81125a88 <__reset+0xfb105a88>
81127230:	9080100c 	andi	r2,r18,64
81127234:	10008026 	beq	r2,zero,81127438 <___vfprintf_internal_r+0x1a98>
81127238:	d8c02d17 	ldw	r3,180(sp)
8112723c:	1cc0000f 	ldh	r19,0(r3)
81127240:	18c00104 	addi	r3,r3,4
81127244:	d8c02d15 	stw	r3,180(sp)
81127248:	982dd7fa 	srai	r22,r19,31
8112724c:	b005883a 	mov	r2,r22
81127250:	003b1f06 	br	81125ed0 <__reset+0xfb105ed0>
81127254:	9080100c 	andi	r2,r18,64
81127258:	d8002785 	stb	zero,158(sp)
8112725c:	10008a1e 	bne	r2,zero,81127488 <___vfprintf_internal_r+0x1ae8>
81127260:	d9402d17 	ldw	r5,180(sp)
81127264:	d8c02917 	ldw	r3,164(sp)
81127268:	002d883a 	mov	r22,zero
8112726c:	28800104 	addi	r2,r5,4
81127270:	2cc00017 	ldw	r19,0(r5)
81127274:	183e4b0e 	bge	r3,zero,81126ba4 <__reset+0xfb106ba4>
81127278:	9d86b03a 	or	r3,r19,r22
8112727c:	d8802d15 	stw	r2,180(sp)
81127280:	183e4c1e 	bne	r3,zero,81126bb4 <__reset+0xfb106bb4>
81127284:	0039883a 	mov	fp,zero
81127288:	0005883a 	mov	r2,zero
8112728c:	003d4006 	br	81126790 <__reset+0xfb106790>
81127290:	01604574 	movhi	r5,33045
81127294:	29434f84 	addi	r5,r5,3390
81127298:	d9402b15 	stw	r5,172(sp)
8112729c:	d9402b17 	ldw	r5,172(sp)
811272a0:	1c47883a 	add	r3,r3,r17
811272a4:	10800044 	addi	r2,r2,1
811272a8:	41400015 	stw	r5,0(r8)
811272ac:	44400115 	stw	r17,4(r8)
811272b0:	d8c02015 	stw	r3,128(sp)
811272b4:	d8801f15 	stw	r2,124(sp)
811272b8:	010001c4 	movi	r4,7
811272bc:	20bec816 	blt	r4,r2,81126de0 <__reset+0xfb106de0>
811272c0:	42000204 	addi	r8,r8,8
811272c4:	003ecd06 	br	81126dfc <__reset+0xfb106dfc>
811272c8:	d9002917 	ldw	r4,164(sp)
811272cc:	d8002785 	stb	zero,158(sp)
811272d0:	203d2d16 	blt	r4,zero,81126788 <__reset+0xfb106788>
811272d4:	00bfdfc4 	movi	r2,-129
811272d8:	90a4703a 	and	r18,r18,r2
811272dc:	003a9106 	br	81125d24 <__reset+0xfb105d24>
811272e0:	01204574 	movhi	r4,33045
811272e4:	21034f84 	addi	r4,r4,3390
811272e8:	d9002b15 	stw	r4,172(sp)
811272ec:	003c0c06 	br	81126320 <__reset+0xfb106320>
811272f0:	d9002c17 	ldw	r4,176(sp)
811272f4:	d9801e04 	addi	r6,sp,120
811272f8:	b80b883a 	mov	r5,r23
811272fc:	11318a80 	call	811318a8 <__sprint_r>
81127300:	103aab1e 	bne	r2,zero,81125db0 <__reset+0xfb105db0>
81127304:	d8c02017 	ldw	r3,128(sp)
81127308:	da000404 	addi	r8,sp,16
8112730c:	003d4106 	br	81126814 <__reset+0xfb106814>
81127310:	d8801f17 	ldw	r2,124(sp)
81127314:	01604574 	movhi	r5,33045
81127318:	01000044 	movi	r4,1
8112731c:	18c00044 	addi	r3,r3,1
81127320:	10800044 	addi	r2,r2,1
81127324:	29434704 	addi	r5,r5,3356
81127328:	41000115 	stw	r4,4(r8)
8112732c:	41400015 	stw	r5,0(r8)
81127330:	d8c02015 	stw	r3,128(sp)
81127334:	d8801f15 	stw	r2,124(sp)
81127338:	010001c4 	movi	r4,7
8112733c:	20805c16 	blt	r4,r2,811274b0 <___vfprintf_internal_r+0x1b10>
81127340:	42000204 	addi	r8,r8,8
81127344:	8800041e 	bne	r17,zero,81127358 <___vfprintf_internal_r+0x19b8>
81127348:	d8803317 	ldw	r2,204(sp)
8112734c:	1000021e 	bne	r2,zero,81127358 <___vfprintf_internal_r+0x19b8>
81127350:	9080004c 	andi	r2,r18,1
81127354:	103c0926 	beq	r2,zero,8112637c <__reset+0xfb10637c>
81127358:	d9003717 	ldw	r4,220(sp)
8112735c:	d8801f17 	ldw	r2,124(sp)
81127360:	d9403417 	ldw	r5,208(sp)
81127364:	20c7883a 	add	r3,r4,r3
81127368:	10800044 	addi	r2,r2,1
8112736c:	41000115 	stw	r4,4(r8)
81127370:	41400015 	stw	r5,0(r8)
81127374:	d8c02015 	stw	r3,128(sp)
81127378:	d8801f15 	stw	r2,124(sp)
8112737c:	010001c4 	movi	r4,7
81127380:	20812116 	blt	r4,r2,81127808 <___vfprintf_internal_r+0x1e68>
81127384:	42000204 	addi	r8,r8,8
81127388:	0463c83a 	sub	r17,zero,r17
8112738c:	0440730e 	bge	zero,r17,8112755c <___vfprintf_internal_r+0x1bbc>
81127390:	05800404 	movi	r22,16
81127394:	b440860e 	bge	r22,r17,811275b0 <___vfprintf_internal_r+0x1c10>
81127398:	01604574 	movhi	r5,33045
8112739c:	29434f84 	addi	r5,r5,3390
811273a0:	d9402b15 	stw	r5,172(sp)
811273a4:	070001c4 	movi	fp,7
811273a8:	dcc02c17 	ldw	r19,176(sp)
811273ac:	00000306 	br	811273bc <___vfprintf_internal_r+0x1a1c>
811273b0:	42000204 	addi	r8,r8,8
811273b4:	8c7ffc04 	addi	r17,r17,-16
811273b8:	b440800e 	bge	r22,r17,811275bc <___vfprintf_internal_r+0x1c1c>
811273bc:	18c00404 	addi	r3,r3,16
811273c0:	10800044 	addi	r2,r2,1
811273c4:	45000015 	stw	r20,0(r8)
811273c8:	45800115 	stw	r22,4(r8)
811273cc:	d8c02015 	stw	r3,128(sp)
811273d0:	d8801f15 	stw	r2,124(sp)
811273d4:	e0bff60e 	bge	fp,r2,811273b0 <__reset+0xfb1073b0>
811273d8:	d9801e04 	addi	r6,sp,120
811273dc:	b80b883a 	mov	r5,r23
811273e0:	9809883a 	mov	r4,r19
811273e4:	11318a80 	call	811318a8 <__sprint_r>
811273e8:	103a711e 	bne	r2,zero,81125db0 <__reset+0xfb105db0>
811273ec:	d8c02017 	ldw	r3,128(sp)
811273f0:	d8801f17 	ldw	r2,124(sp)
811273f4:	da000404 	addi	r8,sp,16
811273f8:	003fee06 	br	811273b4 <__reset+0xfb1073b4>
811273fc:	00bfffc4 	movi	r2,-1
81127400:	003a6f06 	br	81125dc0 <__reset+0xfb105dc0>
81127404:	008011c4 	movi	r2,71
81127408:	1440b816 	blt	r2,r17,811276ec <___vfprintf_internal_r+0x1d4c>
8112740c:	04204574 	movhi	r16,33045
81127410:	84033904 	addi	r16,r16,3300
81127414:	00c000c4 	movi	r3,3
81127418:	00bfdfc4 	movi	r2,-129
8112741c:	d8c02a15 	stw	r3,168(sp)
81127420:	90a4703a 	and	r18,r18,r2
81127424:	df002783 	ldbu	fp,158(sp)
81127428:	d8c02e15 	stw	r3,184(sp)
8112742c:	d8002915 	stw	zero,164(sp)
81127430:	d8003215 	stw	zero,200(sp)
81127434:	003b2906 	br	811260dc <__reset+0xfb1060dc>
81127438:	d9002d17 	ldw	r4,180(sp)
8112743c:	24c00017 	ldw	r19,0(r4)
81127440:	21000104 	addi	r4,r4,4
81127444:	d9002d15 	stw	r4,180(sp)
81127448:	982dd7fa 	srai	r22,r19,31
8112744c:	b005883a 	mov	r2,r22
81127450:	003a9f06 	br	81125ed0 <__reset+0xfb105ed0>
81127454:	d9402d17 	ldw	r5,180(sp)
81127458:	d8c02f17 	ldw	r3,188(sp)
8112745c:	28800017 	ldw	r2,0(r5)
81127460:	29400104 	addi	r5,r5,4
81127464:	d9402d15 	stw	r5,180(sp)
81127468:	10c00015 	stw	r3,0(r2)
8112746c:	00398606 	br	81125a88 <__reset+0xfb105a88>
81127470:	d9402d17 	ldw	r5,180(sp)
81127474:	002d883a 	mov	r22,zero
81127478:	2cc00017 	ldw	r19,0(r5)
8112747c:	29400104 	addi	r5,r5,4
81127480:	d9402d15 	stw	r5,180(sp)
81127484:	003c2306 	br	81126514 <__reset+0xfb106514>
81127488:	d8c02d17 	ldw	r3,180(sp)
8112748c:	d9002917 	ldw	r4,164(sp)
81127490:	002d883a 	mov	r22,zero
81127494:	18800104 	addi	r2,r3,4
81127498:	1cc0000b 	ldhu	r19,0(r3)
8112749c:	203dc10e 	bge	r4,zero,81126ba4 <__reset+0xfb106ba4>
811274a0:	003f7506 	br	81127278 <__reset+0xfb107278>
811274a4:	04204574 	movhi	r16,33045
811274a8:	84033704 	addi	r16,r16,3292
811274ac:	003acc06 	br	81125fe0 <__reset+0xfb105fe0>
811274b0:	d9002c17 	ldw	r4,176(sp)
811274b4:	d9801e04 	addi	r6,sp,120
811274b8:	b80b883a 	mov	r5,r23
811274bc:	11318a80 	call	811318a8 <__sprint_r>
811274c0:	103a3b1e 	bne	r2,zero,81125db0 <__reset+0xfb105db0>
811274c4:	dc402617 	ldw	r17,152(sp)
811274c8:	d8c02017 	ldw	r3,128(sp)
811274cc:	da000404 	addi	r8,sp,16
811274d0:	003f9c06 	br	81127344 <__reset+0xfb107344>
811274d4:	ac400043 	ldbu	r17,1(r21)
811274d8:	94800814 	ori	r18,r18,32
811274dc:	ad400044 	addi	r21,r21,1
811274e0:	8c403fcc 	andi	r17,r17,255
811274e4:	8c40201c 	xori	r17,r17,128
811274e8:	8c7fe004 	addi	r17,r17,-128
811274ec:	00398f06 	br	81125b2c <__reset+0xfb105b2c>
811274f0:	d8c02d15 	stw	r3,180(sp)
811274f4:	0039883a 	mov	fp,zero
811274f8:	003e3506 	br	81126dd0 <__reset+0xfb106dd0>
811274fc:	d9002c17 	ldw	r4,176(sp)
81127500:	d9801e04 	addi	r6,sp,120
81127504:	b80b883a 	mov	r5,r23
81127508:	11318a80 	call	811318a8 <__sprint_r>
8112750c:	103a281e 	bne	r2,zero,81125db0 <__reset+0xfb105db0>
81127510:	d8c02017 	ldw	r3,128(sp)
81127514:	da000404 	addi	r8,sp,16
81127518:	003cd006 	br	8112685c <__reset+0xfb10685c>
8112751c:	8009883a 	mov	r4,r16
81127520:	da003d15 	stw	r8,244(sp)
81127524:	11231840 	call	81123184 <strlen>
81127528:	d8802e15 	stw	r2,184(sp)
8112752c:	da003d17 	ldw	r8,244(sp)
81127530:	103c340e 	bge	r2,zero,81126604 <__reset+0xfb106604>
81127534:	0005883a 	mov	r2,zero
81127538:	003c3206 	br	81126604 <__reset+0xfb106604>
8112753c:	d9002c17 	ldw	r4,176(sp)
81127540:	d9801e04 	addi	r6,sp,120
81127544:	b80b883a 	mov	r5,r23
81127548:	11318a80 	call	811318a8 <__sprint_r>
8112754c:	103a181e 	bne	r2,zero,81125db0 <__reset+0xfb105db0>
81127550:	d8c02017 	ldw	r3,128(sp)
81127554:	d8801f17 	ldw	r2,124(sp)
81127558:	da000404 	addi	r8,sp,16
8112755c:	d9403317 	ldw	r5,204(sp)
81127560:	10800044 	addi	r2,r2,1
81127564:	44000015 	stw	r16,0(r8)
81127568:	28c7883a 	add	r3,r5,r3
8112756c:	003b7d06 	br	81126364 <__reset+0xfb106364>
81127570:	01204574 	movhi	r4,33045
81127574:	21035384 	addi	r4,r4,3406
81127578:	d9003515 	stw	r4,212(sp)
8112757c:	003b1406 	br	811261d0 <__reset+0xfb1061d0>
81127580:	013fffc4 	movi	r4,-1
81127584:	003a3506 	br	81125e5c <__reset+0xfb105e5c>
81127588:	0023883a 	mov	r17,zero
8112758c:	003d9d06 	br	81126c04 <__reset+0xfb106c04>
81127590:	d9002c17 	ldw	r4,176(sp)
81127594:	d9801e04 	addi	r6,sp,120
81127598:	b80b883a 	mov	r5,r23
8112759c:	11318a80 	call	811318a8 <__sprint_r>
811275a0:	103a031e 	bne	r2,zero,81125db0 <__reset+0xfb105db0>
811275a4:	d8c02017 	ldw	r3,128(sp)
811275a8:	da000404 	addi	r8,sp,16
811275ac:	003d9406 	br	81126c00 <__reset+0xfb106c00>
811275b0:	01204574 	movhi	r4,33045
811275b4:	21034f84 	addi	r4,r4,3390
811275b8:	d9002b15 	stw	r4,172(sp)
811275bc:	d9002b17 	ldw	r4,172(sp)
811275c0:	1c47883a 	add	r3,r3,r17
811275c4:	10800044 	addi	r2,r2,1
811275c8:	41000015 	stw	r4,0(r8)
811275cc:	44400115 	stw	r17,4(r8)
811275d0:	d8c02015 	stw	r3,128(sp)
811275d4:	d8801f15 	stw	r2,124(sp)
811275d8:	010001c4 	movi	r4,7
811275dc:	20bfd716 	blt	r4,r2,8112753c <__reset+0xfb10753c>
811275e0:	42000204 	addi	r8,r8,8
811275e4:	003fdd06 	br	8112755c <__reset+0xfb10755c>
811275e8:	d9002c17 	ldw	r4,176(sp)
811275ec:	d9801e04 	addi	r6,sp,120
811275f0:	b80b883a 	mov	r5,r23
811275f4:	11318a80 	call	811318a8 <__sprint_r>
811275f8:	1039ed1e 	bne	r2,zero,81125db0 <__reset+0xfb105db0>
811275fc:	d8802617 	ldw	r2,152(sp)
81127600:	d8c02017 	ldw	r3,128(sp)
81127604:	da000404 	addi	r8,sp,16
81127608:	003e1006 	br	81126e4c <__reset+0xfb106e4c>
8112760c:	00800044 	movi	r2,1
81127610:	10803fcc 	andi	r2,r2,255
81127614:	00c00044 	movi	r3,1
81127618:	10fa3526 	beq	r2,r3,81125ef0 <__reset+0xfb105ef0>
8112761c:	00c00084 	movi	r3,2
81127620:	10fbcb26 	beq	r2,r3,81126550 <__reset+0xfb106550>
81127624:	003a8f06 	br	81126064 <__reset+0xfb106064>
81127628:	01204574 	movhi	r4,33045
8112762c:	21035384 	addi	r4,r4,3406
81127630:	d9003515 	stw	r4,212(sp)
81127634:	003b7606 	br	81126410 <__reset+0xfb106410>
81127638:	d8802917 	ldw	r2,164(sp)
8112763c:	00c00184 	movi	r3,6
81127640:	1880012e 	bgeu	r3,r2,81127648 <___vfprintf_internal_r+0x1ca8>
81127644:	1805883a 	mov	r2,r3
81127648:	d8802e15 	stw	r2,184(sp)
8112764c:	1000ef16 	blt	r2,zero,81127a0c <___vfprintf_internal_r+0x206c>
81127650:	04204574 	movhi	r16,33045
81127654:	d8802a15 	stw	r2,168(sp)
81127658:	dcc02d15 	stw	r19,180(sp)
8112765c:	d8002915 	stw	zero,164(sp)
81127660:	d8003215 	stw	zero,200(sp)
81127664:	84034504 	addi	r16,r16,3348
81127668:	0039883a 	mov	fp,zero
8112766c:	003aa206 	br	811260f8 <__reset+0xfb1060f8>
81127670:	0021883a 	mov	r16,zero
81127674:	003e0706 	br	81126e94 <__reset+0xfb106e94>
81127678:	d9002c17 	ldw	r4,176(sp)
8112767c:	d9801e04 	addi	r6,sp,120
81127680:	b80b883a 	mov	r5,r23
81127684:	11318a80 	call	811318a8 <__sprint_r>
81127688:	1039c91e 	bne	r2,zero,81125db0 <__reset+0xfb105db0>
8112768c:	d8802617 	ldw	r2,152(sp)
81127690:	d9403317 	ldw	r5,204(sp)
81127694:	d8c02017 	ldw	r3,128(sp)
81127698:	da000404 	addi	r8,sp,16
8112769c:	2885c83a 	sub	r2,r5,r2
811276a0:	003dfb06 	br	81126e90 <__reset+0xfb106e90>
811276a4:	9080004c 	andi	r2,r18,1
811276a8:	103e8f1e 	bne	r2,zero,811270e8 <__reset+0xfb1070e8>
811276ac:	d8802117 	ldw	r2,132(sp)
811276b0:	003e9e06 	br	8112712c <__reset+0xfb10712c>
811276b4:	1025883a 	mov	r18,r2
811276b8:	0039883a 	mov	fp,zero
811276bc:	00800084 	movi	r2,2
811276c0:	003fd306 	br	81127610 <__reset+0xfb107610>
811276c4:	07000b44 	movi	fp,45
811276c8:	df002785 	stb	fp,158(sp)
811276cc:	003a4006 	br	81125fd0 <__reset+0xfb105fd0>
811276d0:	00c00b44 	movi	r3,45
811276d4:	d8c02785 	stb	r3,158(sp)
811276d8:	d8802a15 	stw	r2,168(sp)
811276dc:	dc802b17 	ldw	r18,172(sp)
811276e0:	d8002915 	stw	zero,164(sp)
811276e4:	07000b44 	movi	fp,45
811276e8:	003a8006 	br	811260ec <__reset+0xfb1060ec>
811276ec:	04204574 	movhi	r16,33045
811276f0:	84033a04 	addi	r16,r16,3304
811276f4:	003f4706 	br	81127414 <__reset+0xfb107414>
811276f8:	d8c02d17 	ldw	r3,180(sp)
811276fc:	d9002f17 	ldw	r4,188(sp)
81127700:	18800017 	ldw	r2,0(r3)
81127704:	18c00104 	addi	r3,r3,4
81127708:	d8c02d15 	stw	r3,180(sp)
8112770c:	11000015 	stw	r4,0(r2)
81127710:	0038dd06 	br	81125a88 <__reset+0xfb105a88>
81127714:	dd802617 	ldw	r22,152(sp)
81127718:	00bfff44 	movi	r2,-3
8112771c:	b0801c16 	blt	r22,r2,81127790 <___vfprintf_internal_r+0x1df0>
81127720:	d9402917 	ldw	r5,164(sp)
81127724:	2d801a16 	blt	r5,r22,81127790 <___vfprintf_internal_r+0x1df0>
81127728:	dd803215 	stw	r22,200(sp)
8112772c:	003e8906 	br	81127154 <__reset+0xfb107154>
81127730:	01204574 	movhi	r4,33045
81127734:	21034f84 	addi	r4,r4,3390
81127738:	d9002b15 	stw	r4,172(sp)
8112773c:	003c9106 	br	81126984 <__reset+0xfb106984>
81127740:	e005883a 	mov	r2,fp
81127744:	003e7906 	br	8112712c <__reset+0xfb10712c>
81127748:	d9402917 	ldw	r5,164(sp)
8112774c:	df002783 	ldbu	fp,158(sp)
81127750:	dcc02d15 	stw	r19,180(sp)
81127754:	d9402a15 	stw	r5,168(sp)
81127758:	d9402e15 	stw	r5,184(sp)
8112775c:	d8002915 	stw	zero,164(sp)
81127760:	d8003215 	stw	zero,200(sp)
81127764:	003a5d06 	br	811260dc <__reset+0xfb1060dc>
81127768:	9080004c 	andi	r2,r18,1
8112776c:	0039883a 	mov	fp,zero
81127770:	10000426 	beq	r2,zero,81127784 <___vfprintf_internal_r+0x1de4>
81127774:	00800c04 	movi	r2,48
81127778:	dc001dc4 	addi	r16,sp,119
8112777c:	d8801dc5 	stb	r2,119(sp)
81127780:	003b8006 	br	81126584 <__reset+0xfb106584>
81127784:	d8002e15 	stw	zero,184(sp)
81127788:	dc001e04 	addi	r16,sp,120
8112778c:	003a4d06 	br	811260c4 <__reset+0xfb1060c4>
81127790:	8c7fff84 	addi	r17,r17,-2
81127794:	b5bfffc4 	addi	r22,r22,-1
81127798:	dd802615 	stw	r22,152(sp)
8112779c:	dc4022c5 	stb	r17,139(sp)
811277a0:	b000bf16 	blt	r22,zero,81127aa0 <___vfprintf_internal_r+0x2100>
811277a4:	00800ac4 	movi	r2,43
811277a8:	d8802305 	stb	r2,140(sp)
811277ac:	00800244 	movi	r2,9
811277b0:	15807016 	blt	r2,r22,81127974 <___vfprintf_internal_r+0x1fd4>
811277b4:	00800c04 	movi	r2,48
811277b8:	b5800c04 	addi	r22,r22,48
811277bc:	d8802345 	stb	r2,141(sp)
811277c0:	dd802385 	stb	r22,142(sp)
811277c4:	d88023c4 	addi	r2,sp,143
811277c8:	df0022c4 	addi	fp,sp,139
811277cc:	d8c03317 	ldw	r3,204(sp)
811277d0:	1739c83a 	sub	fp,r2,fp
811277d4:	d9003317 	ldw	r4,204(sp)
811277d8:	e0c7883a 	add	r3,fp,r3
811277dc:	df003a15 	stw	fp,232(sp)
811277e0:	d8c02e15 	stw	r3,184(sp)
811277e4:	00800044 	movi	r2,1
811277e8:	1100b30e 	bge	r2,r4,81127ab8 <___vfprintf_internal_r+0x2118>
811277ec:	d8c02e17 	ldw	r3,184(sp)
811277f0:	18c00044 	addi	r3,r3,1
811277f4:	d8c02e15 	stw	r3,184(sp)
811277f8:	1805883a 	mov	r2,r3
811277fc:	1800ac16 	blt	r3,zero,81127ab0 <___vfprintf_internal_r+0x2110>
81127800:	d8003215 	stw	zero,200(sp)
81127804:	003e5d06 	br	8112717c <__reset+0xfb10717c>
81127808:	d9002c17 	ldw	r4,176(sp)
8112780c:	d9801e04 	addi	r6,sp,120
81127810:	b80b883a 	mov	r5,r23
81127814:	11318a80 	call	811318a8 <__sprint_r>
81127818:	1039651e 	bne	r2,zero,81125db0 <__reset+0xfb105db0>
8112781c:	dc402617 	ldw	r17,152(sp)
81127820:	d8c02017 	ldw	r3,128(sp)
81127824:	d8801f17 	ldw	r2,124(sp)
81127828:	da000404 	addi	r8,sp,16
8112782c:	003ed606 	br	81127388 <__reset+0xfb107388>
81127830:	582b883a 	mov	r21,r11
81127834:	d8002915 	stw	zero,164(sp)
81127838:	0038bd06 	br	81125b30 <__reset+0xfb105b30>
8112783c:	d8802917 	ldw	r2,164(sp)
81127840:	103e071e 	bne	r2,zero,81127060 <__reset+0xfb107060>
81127844:	dc002915 	stw	r16,164(sp)
81127848:	003e0506 	br	81127060 <__reset+0xfb107060>
8112784c:	d9002917 	ldw	r4,164(sp)
81127850:	20c00044 	addi	r3,r4,1
81127854:	003e0f06 	br	81127094 <__reset+0xfb107094>
81127858:	01400184 	movi	r5,6
8112785c:	d9402915 	stw	r5,164(sp)
81127860:	003dff06 	br	81127060 <__reset+0xfb107060>
81127864:	d8802104 	addi	r2,sp,132
81127868:	d8800315 	stw	r2,12(sp)
8112786c:	d8802504 	addi	r2,sp,148
81127870:	d8800215 	stw	r2,8(sp)
81127874:	d8802604 	addi	r2,sp,152
81127878:	d8800115 	stw	r2,4(sp)
8112787c:	d8802917 	ldw	r2,164(sp)
81127880:	d9403617 	ldw	r5,216(sp)
81127884:	d9002c17 	ldw	r4,176(sp)
81127888:	d8800015 	stw	r2,0(sp)
8112788c:	01c000c4 	movi	r7,3
81127890:	980d883a 	mov	r6,r19
81127894:	da003d15 	stw	r8,244(sp)
81127898:	1129aac0 	call	81129aac <_dtoa_r>
8112789c:	d8c02917 	ldw	r3,164(sp)
811278a0:	da003d17 	ldw	r8,244(sp)
811278a4:	1021883a 	mov	r16,r2
811278a8:	10f9883a 	add	fp,r2,r3
811278ac:	81000007 	ldb	r4,0(r16)
811278b0:	00800c04 	movi	r2,48
811278b4:	20805e26 	beq	r4,r2,81127a30 <___vfprintf_internal_r+0x2090>
811278b8:	d8c02617 	ldw	r3,152(sp)
811278bc:	e0f9883a 	add	fp,fp,r3
811278c0:	003e0a06 	br	811270ec <__reset+0xfb1070ec>
811278c4:	00c00b44 	movi	r3,45
811278c8:	24e0003c 	xorhi	r19,r4,32768
811278cc:	d8c02a05 	stb	r3,168(sp)
811278d0:	003de906 	br	81127078 <__reset+0xfb107078>
811278d4:	d8c03217 	ldw	r3,200(sp)
811278d8:	00c07a0e 	bge	zero,r3,81127ac4 <___vfprintf_internal_r+0x2124>
811278dc:	00800044 	movi	r2,1
811278e0:	d9003317 	ldw	r4,204(sp)
811278e4:	1105883a 	add	r2,r2,r4
811278e8:	d8802e15 	stw	r2,184(sp)
811278ec:	10004e16 	blt	r2,zero,81127a28 <___vfprintf_internal_r+0x2088>
811278f0:	044019c4 	movi	r17,103
811278f4:	003e2106 	br	8112717c <__reset+0xfb10717c>
811278f8:	d9002917 	ldw	r4,164(sp)
811278fc:	d8802104 	addi	r2,sp,132
81127900:	d8800315 	stw	r2,12(sp)
81127904:	d9000015 	stw	r4,0(sp)
81127908:	d8802504 	addi	r2,sp,148
8112790c:	d9403617 	ldw	r5,216(sp)
81127910:	d9002c17 	ldw	r4,176(sp)
81127914:	d8800215 	stw	r2,8(sp)
81127918:	d8802604 	addi	r2,sp,152
8112791c:	d8800115 	stw	r2,4(sp)
81127920:	01c000c4 	movi	r7,3
81127924:	980d883a 	mov	r6,r19
81127928:	da003d15 	stw	r8,244(sp)
8112792c:	1129aac0 	call	81129aac <_dtoa_r>
81127930:	d8c02917 	ldw	r3,164(sp)
81127934:	da003d17 	ldw	r8,244(sp)
81127938:	1021883a 	mov	r16,r2
8112793c:	00801184 	movi	r2,70
81127940:	80f9883a 	add	fp,r16,r3
81127944:	88bfd926 	beq	r17,r2,811278ac <__reset+0xfb1078ac>
81127948:	003de806 	br	811270ec <__reset+0xfb1070ec>
8112794c:	d9002917 	ldw	r4,164(sp)
81127950:	00c04d0e 	bge	zero,r3,81127a88 <___vfprintf_internal_r+0x20e8>
81127954:	2000441e 	bne	r4,zero,81127a68 <___vfprintf_internal_r+0x20c8>
81127958:	9480004c 	andi	r18,r18,1
8112795c:	9000421e 	bne	r18,zero,81127a68 <___vfprintf_internal_r+0x20c8>
81127960:	1805883a 	mov	r2,r3
81127964:	18007016 	blt	r3,zero,81127b28 <___vfprintf_internal_r+0x2188>
81127968:	d8c03217 	ldw	r3,200(sp)
8112796c:	d8c02e15 	stw	r3,184(sp)
81127970:	003e0206 	br	8112717c <__reset+0xfb10717c>
81127974:	df0022c4 	addi	fp,sp,139
81127978:	dc002915 	stw	r16,164(sp)
8112797c:	4027883a 	mov	r19,r8
81127980:	e021883a 	mov	r16,fp
81127984:	b009883a 	mov	r4,r22
81127988:	01400284 	movi	r5,10
8112798c:	1134ba40 	call	81134ba4 <__modsi3>
81127990:	10800c04 	addi	r2,r2,48
81127994:	843fffc4 	addi	r16,r16,-1
81127998:	b009883a 	mov	r4,r22
8112799c:	01400284 	movi	r5,10
811279a0:	80800005 	stb	r2,0(r16)
811279a4:	1134b200 	call	81134b20 <__divsi3>
811279a8:	102d883a 	mov	r22,r2
811279ac:	00800244 	movi	r2,9
811279b0:	15bff416 	blt	r2,r22,81127984 <__reset+0xfb107984>
811279b4:	9811883a 	mov	r8,r19
811279b8:	b0800c04 	addi	r2,r22,48
811279bc:	8027883a 	mov	r19,r16
811279c0:	997fffc4 	addi	r5,r19,-1
811279c4:	98bfffc5 	stb	r2,-1(r19)
811279c8:	dc002917 	ldw	r16,164(sp)
811279cc:	2f006a2e 	bgeu	r5,fp,81127b78 <___vfprintf_internal_r+0x21d8>
811279d0:	d9c02384 	addi	r7,sp,142
811279d4:	3ccfc83a 	sub	r7,r7,r19
811279d8:	d9002344 	addi	r4,sp,141
811279dc:	e1cf883a 	add	r7,fp,r7
811279e0:	00000106 	br	811279e8 <___vfprintf_internal_r+0x2048>
811279e4:	28800003 	ldbu	r2,0(r5)
811279e8:	20800005 	stb	r2,0(r4)
811279ec:	21000044 	addi	r4,r4,1
811279f0:	29400044 	addi	r5,r5,1
811279f4:	393ffb1e 	bne	r7,r4,811279e4 <__reset+0xfb1079e4>
811279f8:	d8802304 	addi	r2,sp,140
811279fc:	14c5c83a 	sub	r2,r2,r19
81127a00:	d8c02344 	addi	r3,sp,141
81127a04:	1885883a 	add	r2,r3,r2
81127a08:	003f7006 	br	811277cc <__reset+0xfb1077cc>
81127a0c:	0005883a 	mov	r2,zero
81127a10:	003f0f06 	br	81127650 <__reset+0xfb107650>
81127a14:	d8c03217 	ldw	r3,200(sp)
81127a18:	18c00044 	addi	r3,r3,1
81127a1c:	d8c02e15 	stw	r3,184(sp)
81127a20:	1805883a 	mov	r2,r3
81127a24:	183fb20e 	bge	r3,zero,811278f0 <__reset+0xfb1078f0>
81127a28:	0005883a 	mov	r2,zero
81127a2c:	003fb006 	br	811278f0 <__reset+0xfb1078f0>
81127a30:	d9003617 	ldw	r4,216(sp)
81127a34:	000d883a 	mov	r6,zero
81127a38:	000f883a 	mov	r7,zero
81127a3c:	980b883a 	mov	r5,r19
81127a40:	d8c03c15 	stw	r3,240(sp)
81127a44:	da003d15 	stw	r8,244(sp)
81127a48:	11360740 	call	81136074 <__eqdf2>
81127a4c:	d8c03c17 	ldw	r3,240(sp)
81127a50:	da003d17 	ldw	r8,244(sp)
81127a54:	103f9826 	beq	r2,zero,811278b8 <__reset+0xfb1078b8>
81127a58:	00800044 	movi	r2,1
81127a5c:	10c7c83a 	sub	r3,r2,r3
81127a60:	d8c02615 	stw	r3,152(sp)
81127a64:	003f9506 	br	811278bc <__reset+0xfb1078bc>
81127a68:	d9002917 	ldw	r4,164(sp)
81127a6c:	d8c03217 	ldw	r3,200(sp)
81127a70:	20800044 	addi	r2,r4,1
81127a74:	1885883a 	add	r2,r3,r2
81127a78:	d8802e15 	stw	r2,184(sp)
81127a7c:	103dbf0e 	bge	r2,zero,8112717c <__reset+0xfb10717c>
81127a80:	0005883a 	mov	r2,zero
81127a84:	003dbd06 	br	8112717c <__reset+0xfb10717c>
81127a88:	2000211e 	bne	r4,zero,81127b10 <___vfprintf_internal_r+0x2170>
81127a8c:	9480004c 	andi	r18,r18,1
81127a90:	90001f1e 	bne	r18,zero,81127b10 <___vfprintf_internal_r+0x2170>
81127a94:	00800044 	movi	r2,1
81127a98:	d8802e15 	stw	r2,184(sp)
81127a9c:	003db706 	br	8112717c <__reset+0xfb10717c>
81127aa0:	00800b44 	movi	r2,45
81127aa4:	05adc83a 	sub	r22,zero,r22
81127aa8:	d8802305 	stb	r2,140(sp)
81127aac:	003f3f06 	br	811277ac <__reset+0xfb1077ac>
81127ab0:	0005883a 	mov	r2,zero
81127ab4:	003f5206 	br	81127800 <__reset+0xfb107800>
81127ab8:	90a4703a 	and	r18,r18,r2
81127abc:	903f4e26 	beq	r18,zero,811277f8 <__reset+0xfb1077f8>
81127ac0:	003f4a06 	br	811277ec <__reset+0xfb1077ec>
81127ac4:	00800084 	movi	r2,2
81127ac8:	10c5c83a 	sub	r2,r2,r3
81127acc:	003f8406 	br	811278e0 <__reset+0xfb1078e0>
81127ad0:	d8802d17 	ldw	r2,180(sp)
81127ad4:	d9002d17 	ldw	r4,180(sp)
81127ad8:	ac400043 	ldbu	r17,1(r21)
81127adc:	10800017 	ldw	r2,0(r2)
81127ae0:	582b883a 	mov	r21,r11
81127ae4:	d8802915 	stw	r2,164(sp)
81127ae8:	20800104 	addi	r2,r4,4
81127aec:	d9002917 	ldw	r4,164(sp)
81127af0:	d8802d15 	stw	r2,180(sp)
81127af4:	203e7a0e 	bge	r4,zero,811274e0 <__reset+0xfb1074e0>
81127af8:	8c403fcc 	andi	r17,r17,255
81127afc:	00bfffc4 	movi	r2,-1
81127b00:	8c40201c 	xori	r17,r17,128
81127b04:	d8802915 	stw	r2,164(sp)
81127b08:	8c7fe004 	addi	r17,r17,-128
81127b0c:	00380706 	br	81125b2c <__reset+0xfb105b2c>
81127b10:	d8c02917 	ldw	r3,164(sp)
81127b14:	18c00084 	addi	r3,r3,2
81127b18:	d8c02e15 	stw	r3,184(sp)
81127b1c:	1805883a 	mov	r2,r3
81127b20:	183d960e 	bge	r3,zero,8112717c <__reset+0xfb10717c>
81127b24:	003fd606 	br	81127a80 <__reset+0xfb107a80>
81127b28:	0005883a 	mov	r2,zero
81127b2c:	003f8e06 	br	81127968 <__reset+0xfb107968>
81127b30:	9080004c 	andi	r2,r18,1
81127b34:	103f811e 	bne	r2,zero,8112793c <__reset+0xfb10793c>
81127b38:	d8802117 	ldw	r2,132(sp)
81127b3c:	1405c83a 	sub	r2,r2,r16
81127b40:	d8803315 	stw	r2,204(sp)
81127b44:	b47ef326 	beq	r22,r17,81127714 <__reset+0xfb107714>
81127b48:	dd802617 	ldw	r22,152(sp)
81127b4c:	003f1106 	br	81127794 <__reset+0xfb107794>
81127b50:	d9c02785 	stb	r7,158(sp)
81127b54:	00390406 	br	81125f68 <__reset+0xfb105f68>
81127b58:	d9c02785 	stb	r7,158(sp)
81127b5c:	0038d306 	br	81125eac <__reset+0xfb105eac>
81127b60:	d9c02785 	stb	r7,158(sp)
81127b64:	003a6106 	br	811264ec <__reset+0xfb1064ec>
81127b68:	d9c02785 	stb	r7,158(sp)
81127b6c:	003af806 	br	81126750 <__reset+0xfb106750>
81127b70:	0005883a 	mov	r2,zero
81127b74:	003d7e06 	br	81127170 <__reset+0xfb107170>
81127b78:	d8802344 	addi	r2,sp,141
81127b7c:	003f1306 	br	811277cc <__reset+0xfb1077cc>
81127b80:	d9c02785 	stb	r7,158(sp)
81127b84:	00392306 	br	81126014 <__reset+0xfb106014>
81127b88:	d9c02785 	stb	r7,158(sp)
81127b8c:	003aa906 	br	81126634 <__reset+0xfb106634>
81127b90:	d9c02785 	stb	r7,158(sp)
81127b94:	003a3d06 	br	8112648c <__reset+0xfb10648c>
81127b98:	d9c02785 	stb	r7,158(sp)
81127b9c:	003aca06 	br	811266c8 <__reset+0xfb1066c8>

81127ba0 <__vfprintf_internal>:
81127ba0:	00a04574 	movhi	r2,33045
81127ba4:	108d0f04 	addi	r2,r2,13372
81127ba8:	300f883a 	mov	r7,r6
81127bac:	280d883a 	mov	r6,r5
81127bb0:	200b883a 	mov	r5,r4
81127bb4:	11000017 	ldw	r4,0(r2)
81127bb8:	11259a01 	jmpi	811259a0 <___vfprintf_internal_r>

81127bbc <__sbprintf>:
81127bbc:	defee204 	addi	sp,sp,-1144
81127bc0:	de00012e 	bgeu	sp,et,81127bc8 <__sbprintf+0xc>
81127bc4:	003b68fa 	trap	3
81127bc8:	2880030b 	ldhu	r2,12(r5)
81127bcc:	2ac01917 	ldw	r11,100(r5)
81127bd0:	2a80038b 	ldhu	r10,14(r5)
81127bd4:	2a400717 	ldw	r9,28(r5)
81127bd8:	2a000917 	ldw	r8,36(r5)
81127bdc:	00c10004 	movi	r3,1024
81127be0:	dc011a15 	stw	r16,1128(sp)
81127be4:	10bfff4c 	andi	r2,r2,65533
81127be8:	2821883a 	mov	r16,r5
81127bec:	d8cb883a 	add	r5,sp,r3
81127bf0:	dc811c15 	stw	r18,1136(sp)
81127bf4:	dc411b15 	stw	r17,1132(sp)
81127bf8:	dfc11d15 	stw	ra,1140(sp)
81127bfc:	2025883a 	mov	r18,r4
81127c00:	d881030d 	sth	r2,1036(sp)
81127c04:	dac11915 	stw	r11,1124(sp)
81127c08:	da81038d 	sth	r10,1038(sp)
81127c0c:	da410715 	stw	r9,1052(sp)
81127c10:	da010915 	stw	r8,1060(sp)
81127c14:	dec10015 	stw	sp,1024(sp)
81127c18:	dec10415 	stw	sp,1040(sp)
81127c1c:	d8c10215 	stw	r3,1032(sp)
81127c20:	d8c10515 	stw	r3,1044(sp)
81127c24:	d8010615 	stw	zero,1048(sp)
81127c28:	11259a00 	call	811259a0 <___vfprintf_internal_r>
81127c2c:	1023883a 	mov	r17,r2
81127c30:	10000416 	blt	r2,zero,81127c44 <__sbprintf+0x88>
81127c34:	d9410004 	addi	r5,sp,1024
81127c38:	9009883a 	mov	r4,r18
81127c3c:	112b3600 	call	8112b360 <_fflush_r>
81127c40:	10000d1e 	bne	r2,zero,81127c78 <__sbprintf+0xbc>
81127c44:	d881030b 	ldhu	r2,1036(sp)
81127c48:	1080100c 	andi	r2,r2,64
81127c4c:	10000326 	beq	r2,zero,81127c5c <__sbprintf+0xa0>
81127c50:	8080030b 	ldhu	r2,12(r16)
81127c54:	10801014 	ori	r2,r2,64
81127c58:	8080030d 	sth	r2,12(r16)
81127c5c:	8805883a 	mov	r2,r17
81127c60:	dfc11d17 	ldw	ra,1140(sp)
81127c64:	dc811c17 	ldw	r18,1136(sp)
81127c68:	dc411b17 	ldw	r17,1132(sp)
81127c6c:	dc011a17 	ldw	r16,1128(sp)
81127c70:	dec11e04 	addi	sp,sp,1144
81127c74:	f800283a 	ret
81127c78:	047fffc4 	movi	r17,-1
81127c7c:	003ff106 	br	81127c44 <__reset+0xfb107c44>

81127c80 <__svfscanf_r>:
81127c80:	deff4b04 	addi	sp,sp,-724
81127c84:	de00012e 	bgeu	sp,et,81127c8c <__svfscanf_r+0xc>
81127c88:	003b68fa 	trap	3
81127c8c:	2880030b 	ldhu	r2,12(r5)
81127c90:	df00b315 	stw	fp,716(sp)
81127c94:	dd80b115 	stw	r22,708(sp)
81127c98:	dfc0b415 	stw	ra,720(sp)
81127c9c:	ddc0b215 	stw	r23,712(sp)
81127ca0:	dd40b015 	stw	r21,704(sp)
81127ca4:	dd00af15 	stw	r20,700(sp)
81127ca8:	dcc0ae15 	stw	r19,696(sp)
81127cac:	dc80ad15 	stw	r18,692(sp)
81127cb0:	dc40ac15 	stw	r17,688(sp)
81127cb4:	dc00ab15 	stw	r16,684(sp)
81127cb8:	10c8000c 	andi	r3,r2,8192
81127cbc:	d9c09c15 	stw	r7,624(sp)
81127cc0:	2839883a 	mov	fp,r5
81127cc4:	202d883a 	mov	r22,r4
81127cc8:	1800061e 	bne	r3,zero,81127ce4 <__svfscanf_r+0x64>
81127ccc:	29001917 	ldw	r4,100(r5)
81127cd0:	00f7ffc4 	movi	r3,-8193
81127cd4:	10880014 	ori	r2,r2,8192
81127cd8:	20c6703a 	and	r3,r4,r3
81127cdc:	2880030d 	sth	r2,12(r5)
81127ce0:	28c01915 	stw	r3,100(r5)
81127ce4:	30800003 	ldbu	r2,0(r6)
81127ce8:	0021883a 	mov	r16,zero
81127cec:	05e04574 	movhi	r23,33045
81127cf0:	d800a115 	stw	zero,644(sp)
81127cf4:	d8009e15 	stw	zero,632(sp)
81127cf8:	d800a015 	stw	zero,640(sp)
81127cfc:	d8809b15 	stw	r2,620(sp)
81127d00:	bdcd0d04 	addi	r23,r23,13364
81127d04:	8025883a 	mov	r18,r16
81127d08:	35000044 	addi	r20,r6,1
81127d0c:	10001e26 	beq	r2,zero,81127d88 <__svfscanf_r+0x108>
81127d10:	b9c00017 	ldw	r7,0(r23)
81127d14:	3887883a 	add	r3,r7,r2
81127d18:	18c00043 	ldbu	r3,1(r3)
81127d1c:	18c0020c 	andi	r3,r3,8
81127d20:	18001b26 	beq	r3,zero,81127d90 <__svfscanf_r+0x110>
81127d24:	e0800117 	ldw	r2,4(fp)
81127d28:	00800e0e 	bge	zero,r2,81127d64 <__svfscanf_r+0xe4>
81127d2c:	e0c00017 	ldw	r3,0(fp)
81127d30:	b9000017 	ldw	r4,0(r23)
81127d34:	18800003 	ldbu	r2,0(r3)
81127d38:	2085883a 	add	r2,r4,r2
81127d3c:	10800043 	ldbu	r2,1(r2)
81127d40:	1080020c 	andi	r2,r2,8
81127d44:	10000b26 	beq	r2,zero,81127d74 <__svfscanf_r+0xf4>
81127d48:	e0800117 	ldw	r2,4(fp)
81127d4c:	18c00044 	addi	r3,r3,1
81127d50:	e0c00015 	stw	r3,0(fp)
81127d54:	10bfffc4 	addi	r2,r2,-1
81127d58:	e0800115 	stw	r2,4(fp)
81127d5c:	94800044 	addi	r18,r18,1
81127d60:	00bff216 	blt	zero,r2,81127d2c <__reset+0xfb107d2c>
81127d64:	e00b883a 	mov	r5,fp
81127d68:	b009883a 	mov	r4,r22
81127d6c:	1122c5c0 	call	81122c5c <__srefill_r>
81127d70:	103fee26 	beq	r2,zero,81127d2c <__reset+0xfb107d2c>
81127d74:	a00d883a 	mov	r6,r20
81127d78:	30800003 	ldbu	r2,0(r6)
81127d7c:	35000044 	addi	r20,r6,1
81127d80:	d8809b15 	stw	r2,620(sp)
81127d84:	103fe21e 	bne	r2,zero,81127d10 <__reset+0xfb107d10>
81127d88:	d880a017 	ldw	r2,640(sp)
81127d8c:	00009906 	br	81127ff4 <__svfscanf_r+0x374>
81127d90:	00c00944 	movi	r3,37
81127d94:	10c0881e 	bne	r2,r3,81127fb8 <__svfscanf_r+0x338>
81127d98:	30c00043 	ldbu	r3,1(r6)
81127d9c:	0023883a 	mov	r17,zero
81127da0:	0027883a 	mov	r19,zero
81127da4:	01001e04 	movi	r4,120
81127da8:	01401b04 	movi	r5,108
81127dac:	a1800044 	addi	r6,r20,1
81127db0:	20c0a236 	bltu	r4,r3,8112803c <__svfscanf_r+0x3bc>
81127db4:	180490ba 	slli	r2,r3,2
81127db8:	022044b4 	movhi	r8,33042
81127dbc:	421f7304 	addi	r8,r8,32204
81127dc0:	1205883a 	add	r2,r2,r8
81127dc4:	10800017 	ldw	r2,0(r2)
81127dc8:	1000683a 	jmp	r2
81127dcc:	81127ff0 	cmpltui	r4,r16,18943
81127dd0:	8112803c 	xorhi	r4,r16,18944
81127dd4:	8112803c 	xorhi	r4,r16,18944
81127dd8:	8112803c 	xorhi	r4,r16,18944
81127ddc:	8112803c 	xorhi	r4,r16,18944
81127de0:	8112803c 	xorhi	r4,r16,18944
81127de4:	8112803c 	xorhi	r4,r16,18944
81127de8:	8112803c 	xorhi	r4,r16,18944
81127dec:	8112803c 	xorhi	r4,r16,18944
81127df0:	8112803c 	xorhi	r4,r16,18944
81127df4:	8112803c 	xorhi	r4,r16,18944
81127df8:	8112803c 	xorhi	r4,r16,18944
81127dfc:	8112803c 	xorhi	r4,r16,18944
81127e00:	8112803c 	xorhi	r4,r16,18944
81127e04:	8112803c 	xorhi	r4,r16,18944
81127e08:	8112803c 	xorhi	r4,r16,18944
81127e0c:	8112803c 	xorhi	r4,r16,18944
81127e10:	8112803c 	xorhi	r4,r16,18944
81127e14:	8112803c 	xorhi	r4,r16,18944
81127e18:	8112803c 	xorhi	r4,r16,18944
81127e1c:	8112803c 	xorhi	r4,r16,18944
81127e20:	8112803c 	xorhi	r4,r16,18944
81127e24:	8112803c 	xorhi	r4,r16,18944
81127e28:	8112803c 	xorhi	r4,r16,18944
81127e2c:	8112803c 	xorhi	r4,r16,18944
81127e30:	8112803c 	xorhi	r4,r16,18944
81127e34:	8112803c 	xorhi	r4,r16,18944
81127e38:	8112803c 	xorhi	r4,r16,18944
81127e3c:	8112803c 	xorhi	r4,r16,18944
81127e40:	8112803c 	xorhi	r4,r16,18944
81127e44:	8112803c 	xorhi	r4,r16,18944
81127e48:	8112803c 	xorhi	r4,r16,18944
81127e4c:	8112803c 	xorhi	r4,r16,18944
81127e50:	8112803c 	xorhi	r4,r16,18944
81127e54:	8112803c 	xorhi	r4,r16,18944
81127e58:	8112803c 	xorhi	r4,r16,18944
81127e5c:	8112803c 	xorhi	r4,r16,18944
81127e60:	81127fb0 	cmpltui	r4,r16,18942
81127e64:	8112803c 	xorhi	r4,r16,18944
81127e68:	8112803c 	xorhi	r4,r16,18944
81127e6c:	8112803c 	xorhi	r4,r16,18944
81127e70:	8112803c 	xorhi	r4,r16,18944
81127e74:	81128024 	muli	r4,r16,18944
81127e78:	8112803c 	xorhi	r4,r16,18944
81127e7c:	8112803c 	xorhi	r4,r16,18944
81127e80:	8112803c 	xorhi	r4,r16,18944
81127e84:	8112803c 	xorhi	r4,r16,18944
81127e88:	8112803c 	xorhi	r4,r16,18944
81127e8c:	81128158 	cmpnei	r4,r16,18949
81127e90:	81128158 	cmpnei	r4,r16,18949
81127e94:	81128158 	cmpnei	r4,r16,18949
81127e98:	81128158 	cmpnei	r4,r16,18949
81127e9c:	81128158 	cmpnei	r4,r16,18949
81127ea0:	81128158 	cmpnei	r4,r16,18949
81127ea4:	81128158 	cmpnei	r4,r16,18949
81127ea8:	81128158 	cmpnei	r4,r16,18949
81127eac:	81128158 	cmpnei	r4,r16,18949
81127eb0:	81128158 	cmpnei	r4,r16,18949
81127eb4:	8112803c 	xorhi	r4,r16,18944
81127eb8:	8112803c 	xorhi	r4,r16,18944
81127ebc:	8112803c 	xorhi	r4,r16,18944
81127ec0:	8112803c 	xorhi	r4,r16,18944
81127ec4:	8112803c 	xorhi	r4,r16,18944
81127ec8:	8112803c 	xorhi	r4,r16,18944
81127ecc:	8112803c 	xorhi	r4,r16,18944
81127ed0:	8112803c 	xorhi	r4,r16,18944
81127ed4:	8112803c 	xorhi	r4,r16,18944
81127ed8:	8112803c 	xorhi	r4,r16,18944
81127edc:	8112812c 	andhi	r4,r16,18948
81127ee0:	811281dc 	xori	r4,r16,18951
81127ee4:	8112803c 	xorhi	r4,r16,18944
81127ee8:	811281dc 	xori	r4,r16,18951
81127eec:	8112803c 	xorhi	r4,r16,18944
81127ef0:	8112803c 	xorhi	r4,r16,18944
81127ef4:	8112803c 	xorhi	r4,r16,18944
81127ef8:	8112803c 	xorhi	r4,r16,18944
81127efc:	811281c8 	cmpgei	r4,r16,18951
81127f00:	8112803c 	xorhi	r4,r16,18944
81127f04:	8112803c 	xorhi	r4,r16,18944
81127f08:	8112819c 	xori	r4,r16,18950
81127f0c:	8112803c 	xorhi	r4,r16,18944
81127f10:	8112803c 	xorhi	r4,r16,18944
81127f14:	8112803c 	xorhi	r4,r16,18944
81127f18:	8112803c 	xorhi	r4,r16,18944
81127f1c:	8112803c 	xorhi	r4,r16,18944
81127f20:	8112803c 	xorhi	r4,r16,18944
81127f24:	8112803c 	xorhi	r4,r16,18944
81127f28:	8112803c 	xorhi	r4,r16,18944
81127f2c:	81128174 	orhi	r4,r16,18949
81127f30:	8112803c 	xorhi	r4,r16,18944
81127f34:	8112803c 	xorhi	r4,r16,18944
81127f38:	81128310 	cmplti	r4,r16,18956
81127f3c:	8112803c 	xorhi	r4,r16,18944
81127f40:	8112803c 	xorhi	r4,r16,18944
81127f44:	8112803c 	xorhi	r4,r16,18944
81127f48:	8112803c 	xorhi	r4,r16,18944
81127f4c:	8112803c 	xorhi	r4,r16,18944
81127f50:	8112803c 	xorhi	r4,r16,18944
81127f54:	8112803c 	xorhi	r4,r16,18944
81127f58:	81128294 	ori	r4,r16,18954
81127f5c:	8112826c 	andhi	r4,r16,18953
81127f60:	811281dc 	xori	r4,r16,18951
81127f64:	811281dc 	xori	r4,r16,18951
81127f68:	811281dc 	xori	r4,r16,18951
81127f6c:	81128258 	cmpnei	r4,r16,18953
81127f70:	8112839c 	xori	r4,r16,18958
81127f74:	8112803c 	xorhi	r4,r16,18944
81127f78:	8112803c 	xorhi	r4,r16,18944
81127f7c:	81128244 	addi	r4,r16,18953
81127f80:	8112803c 	xorhi	r4,r16,18944
81127f84:	81128214 	ori	r4,r16,18952
81127f88:	811281f0 	cmpltui	r4,r16,18951
81127f8c:	81128100 	call	88112810 <__reset+0x20f2810>
81127f90:	8112803c 	xorhi	r4,r16,18944
81127f94:	8112803c 	xorhi	r4,r16,18944
81127f98:	811280ec 	andhi	r4,r16,18947
81127f9c:	8112803c 	xorhi	r4,r16,18944
81127fa0:	81128074 	orhi	r4,r16,18945
81127fa4:	8112803c 	xorhi	r4,r16,18944
81127fa8:	8112803c 	xorhi	r4,r16,18944
81127fac:	81128174 	orhi	r4,r16,18949
81127fb0:	d9809d15 	stw	r6,628(sp)
81127fb4:	3029883a 	mov	r20,r6
81127fb8:	e0800117 	ldw	r2,4(fp)
81127fbc:	0081aa0e 	bge	zero,r2,81128668 <__svfscanf_r+0x9e8>
81127fc0:	e0800017 	ldw	r2,0(fp)
81127fc4:	a0ffffc3 	ldbu	r3,-1(r20)
81127fc8:	11000003 	ldbu	r4,0(r2)
81127fcc:	20ff6e1e 	bne	r4,r3,81127d88 <__reset+0xfb107d88>
81127fd0:	e0c00117 	ldw	r3,4(fp)
81127fd4:	10800044 	addi	r2,r2,1
81127fd8:	e0800015 	stw	r2,0(fp)
81127fdc:	18bfffc4 	addi	r2,r3,-1
81127fe0:	e0800115 	stw	r2,4(fp)
81127fe4:	94800044 	addi	r18,r18,1
81127fe8:	a00d883a 	mov	r6,r20
81127fec:	003f6206 	br	81127d78 <__reset+0xfb107d78>
81127ff0:	00bfffc4 	movi	r2,-1
81127ff4:	dfc0b417 	ldw	ra,720(sp)
81127ff8:	df00b317 	ldw	fp,716(sp)
81127ffc:	ddc0b217 	ldw	r23,712(sp)
81128000:	dd80b117 	ldw	r22,708(sp)
81128004:	dd40b017 	ldw	r21,704(sp)
81128008:	dd00af17 	ldw	r20,700(sp)
8112800c:	dcc0ae17 	ldw	r19,696(sp)
81128010:	dc80ad17 	ldw	r18,692(sp)
81128014:	dc40ac17 	ldw	r17,688(sp)
81128018:	dc00ab17 	ldw	r16,684(sp)
8112801c:	dec0b504 	addi	sp,sp,724
81128020:	f800283a 	ret
81128024:	a0800043 	ldbu	r2,1(r20)
81128028:	3029883a 	mov	r20,r6
8112802c:	8c400414 	ori	r17,r17,16
81128030:	10c03fcc 	andi	r3,r2,255
81128034:	a1800044 	addi	r6,r20,1
81128038:	20ff5e2e 	bgeu	r4,r3,81127db4 <__reset+0xfb107db4>
8112803c:	38c7883a 	add	r3,r7,r3
81128040:	18800043 	ldbu	r2,1(r3)
81128044:	d9809d15 	stw	r6,628(sp)
81128048:	00c00044 	movi	r3,1
8112804c:	108000cc 	andi	r2,r2,3
81128050:	10c18f26 	beq	r2,r3,81128690 <__svfscanf_r+0xa10>
81128054:	e0800117 	ldw	r2,4(fp)
81128058:	00808716 	blt	zero,r2,81128278 <__svfscanf_r+0x5f8>
8112805c:	e00b883a 	mov	r5,fp
81128060:	b009883a 	mov	r4,r22
81128064:	1122c5c0 	call	81122c5c <__srefill_r>
81128068:	1001431e 	bne	r2,zero,81128578 <__svfscanf_r+0x8f8>
8112806c:	b9c00017 	ldw	r7,0(r23)
81128070:	00008106 	br	81128278 <__svfscanf_r+0x5f8>
81128074:	e0800117 	ldw	r2,4(fp)
81128078:	d9809d15 	stw	r6,628(sp)
8112807c:	0081a30e 	bge	zero,r2,8112870c <__svfscanf_r+0xa8c>
81128080:	00a044f4 	movhi	r2,33043
81128084:	10beea04 	addi	r2,r2,-1112
81128088:	02000284 	movi	r8,10
8112808c:	d880a115 	stw	r2,644(sp)
81128090:	da009e15 	stw	r8,632(sp)
81128094:	050000c4 	movi	r20,3
81128098:	e0c00017 	ldw	r3,0(fp)
8112809c:	00000206 	br	811280a8 <__svfscanf_r+0x428>
811280a0:	18c00044 	addi	r3,r3,1
811280a4:	e0c00015 	stw	r3,0(fp)
811280a8:	19000003 	ldbu	r4,0(r3)
811280ac:	20803fcc 	andi	r2,r4,255
811280b0:	3885883a 	add	r2,r7,r2
811280b4:	10800043 	ldbu	r2,1(r2)
811280b8:	1140020c 	andi	r5,r2,8
811280bc:	2801ab26 	beq	r5,zero,8112876c <__svfscanf_r+0xaec>
811280c0:	e0800117 	ldw	r2,4(fp)
811280c4:	94800044 	addi	r18,r18,1
811280c8:	10bfffc4 	addi	r2,r2,-1
811280cc:	e0800115 	stw	r2,4(fp)
811280d0:	00bff316 	blt	zero,r2,811280a0 <__reset+0xfb1080a0>
811280d4:	e00b883a 	mov	r5,fp
811280d8:	b009883a 	mov	r4,r22
811280dc:	1122c5c0 	call	81122c5c <__srefill_r>
811280e0:	1001251e 	bne	r2,zero,81128578 <__svfscanf_r+0x8f8>
811280e4:	b9c00017 	ldw	r7,0(r23)
811280e8:	003feb06 	br	81128098 <__reset+0xfb108098>
811280ec:	e0800117 	ldw	r2,4(fp)
811280f0:	d9809d15 	stw	r6,628(sp)
811280f4:	00818b0e 	bge	zero,r2,81128724 <__svfscanf_r+0xaa4>
811280f8:	05000084 	movi	r20,2
811280fc:	003fe606 	br	81128098 <__reset+0xfb108098>
81128100:	e0800117 	ldw	r2,4(fp)
81128104:	d9809d15 	stw	r6,628(sp)
81128108:	8c408814 	ori	r17,r17,544
8112810c:	00801d0e 	bge	zero,r2,81128184 <__svfscanf_r+0x504>
81128110:	00a044f4 	movhi	r2,33043
81128114:	10beea04 	addi	r2,r2,-1112
81128118:	02000404 	movi	r8,16
8112811c:	d880a115 	stw	r2,644(sp)
81128120:	da009e15 	stw	r8,632(sp)
81128124:	050000c4 	movi	r20,3
81128128:	003fdb06 	br	81128098 <__reset+0xfb108098>
8112812c:	e0800117 	ldw	r2,4(fp)
81128130:	d9809d15 	stw	r6,628(sp)
81128134:	8c400054 	ori	r17,r17,1
81128138:	00bfc80e 	bge	zero,r2,8112805c <__reset+0xfb10805c>
8112813c:	00e044b4 	movhi	r3,33042
81128140:	18cc9804 	addi	r3,r3,12896
81128144:	02000284 	movi	r8,10
81128148:	d8c0a115 	stw	r3,644(sp)
8112814c:	da009e15 	stw	r8,632(sp)
81128150:	050000c4 	movi	r20,3
81128154:	003fd006 	br	81128098 <__reset+0xfb108098>
81128158:	9cc002a4 	muli	r19,r19,10
8112815c:	a0800043 	ldbu	r2,1(r20)
81128160:	3029883a 	mov	r20,r6
81128164:	98e7883a 	add	r19,r19,r3
81128168:	9cfff404 	addi	r19,r19,-48
8112816c:	10c03fcc 	andi	r3,r2,255
81128170:	003f0e06 	br	81127dac <__reset+0xfb107dac>
81128174:	e0800117 	ldw	r2,4(fp)
81128178:	d9809d15 	stw	r6,628(sp)
8112817c:	8c408014 	ori	r17,r17,512
81128180:	00bfe316 	blt	zero,r2,81128110 <__reset+0xfb108110>
81128184:	e00b883a 	mov	r5,fp
81128188:	b009883a 	mov	r4,r22
8112818c:	1122c5c0 	call	81122c5c <__srefill_r>
81128190:	1000f91e 	bne	r2,zero,81128578 <__svfscanf_r+0x8f8>
81128194:	b9c00017 	ldw	r7,0(r23)
81128198:	003fdd06 	br	81128110 <__reset+0xfb108110>
8112819c:	e0800117 	ldw	r2,4(fp)
811281a0:	d9809d15 	stw	r6,628(sp)
811281a4:	8c400054 	ori	r17,r17,1
811281a8:	0080140e 	bge	zero,r2,811281fc <__svfscanf_r+0x57c>
811281ac:	00a044f4 	movhi	r2,33043
811281b0:	10beea04 	addi	r2,r2,-1112
811281b4:	02000204 	movi	r8,8
811281b8:	d880a115 	stw	r2,644(sp)
811281bc:	da009e15 	stw	r8,632(sp)
811281c0:	050000c4 	movi	r20,3
811281c4:	003fb406 	br	81128098 <__reset+0xfb108098>
811281c8:	a0800043 	ldbu	r2,1(r20)
811281cc:	8c400094 	ori	r17,r17,2
811281d0:	3029883a 	mov	r20,r6
811281d4:	10c03fcc 	andi	r3,r2,255
811281d8:	003ef406 	br	81127dac <__reset+0xfb107dac>
811281dc:	e0800117 	ldw	r2,4(fp)
811281e0:	d9809d15 	stw	r6,628(sp)
811281e4:	0081420e 	bge	zero,r2,811286f0 <__svfscanf_r+0xa70>
811281e8:	05000104 	movi	r20,4
811281ec:	003faa06 	br	81128098 <__reset+0xfb108098>
811281f0:	e0800117 	ldw	r2,4(fp)
811281f4:	d9809d15 	stw	r6,628(sp)
811281f8:	00bfec16 	blt	zero,r2,811281ac <__reset+0xfb1081ac>
811281fc:	e00b883a 	mov	r5,fp
81128200:	b009883a 	mov	r4,r22
81128204:	1122c5c0 	call	81122c5c <__srefill_r>
81128208:	1000db1e 	bne	r2,zero,81128578 <__svfscanf_r+0x8f8>
8112820c:	b9c00017 	ldw	r7,0(r23)
81128210:	003fe606 	br	811281ac <__reset+0xfb1081ac>
81128214:	d9809d15 	stw	r6,628(sp)
81128218:	8880040c 	andi	r2,r17,16
8112821c:	10009c1e 	bne	r2,zero,81128490 <__svfscanf_r+0x810>
81128220:	8880010c 	andi	r2,r17,4
81128224:	10011e26 	beq	r2,zero,811286a0 <__svfscanf_r+0xa20>
81128228:	da009c17 	ldw	r8,624(sp)
8112822c:	3029883a 	mov	r20,r6
81128230:	40800017 	ldw	r2,0(r8)
81128234:	42000104 	addi	r8,r8,4
81128238:	da009c15 	stw	r8,624(sp)
8112823c:	1480000d 	sth	r18,0(r2)
81128240:	003ecc06 	br	81127d74 <__reset+0xfb107d74>
81128244:	a0c00043 	ldbu	r3,1(r20)
81128248:	19410c26 	beq	r3,r5,8112867c <__svfscanf_r+0x9fc>
8112824c:	8c400054 	ori	r17,r17,1
81128250:	3029883a 	mov	r20,r6
81128254:	003ed506 	br	81127dac <__reset+0xfb107dac>
81128258:	a0800043 	ldbu	r2,1(r20)
8112825c:	8c400114 	ori	r17,r17,4
81128260:	3029883a 	mov	r20,r6
81128264:	10c03fcc 	andi	r3,r2,255
81128268:	003ed006 	br	81127dac <__reset+0xfb107dac>
8112826c:	e0800117 	ldw	r2,4(fp)
81128270:	d9809d15 	stw	r6,628(sp)
81128274:	00bf790e 	bge	zero,r2,8112805c <__reset+0xfb10805c>
81128278:	00a044b4 	movhi	r2,33042
8112827c:	108c9804 	addi	r2,r2,12896
81128280:	02000284 	movi	r8,10
81128284:	d880a115 	stw	r2,644(sp)
81128288:	da009e15 	stw	r8,632(sp)
8112828c:	050000c4 	movi	r20,3
81128290:	003f8106 	br	81128098 <__reset+0xfb108098>
81128294:	e0800117 	ldw	r2,4(fp)
81128298:	d9809d15 	stw	r6,628(sp)
8112829c:	0080c40e 	bge	zero,r2,811285b0 <__svfscanf_r+0x930>
811282a0:	9800011e 	bne	r19,zero,811282a8 <__svfscanf_r+0x628>
811282a4:	04c00044 	movi	r19,1
811282a8:	8880004c 	andi	r2,r17,1
811282ac:	1000441e 	bne	r2,zero,811283c0 <__svfscanf_r+0x740>
811282b0:	8c40040c 	andi	r17,r17,16
811282b4:	8800da26 	beq	r17,zero,81128620 <__svfscanf_r+0x9a0>
811282b8:	0021883a 	mov	r16,zero
811282bc:	00000806 	br	811282e0 <__svfscanf_r+0x660>
811282c0:	1887883a 	add	r3,r3,r2
811282c4:	e00b883a 	mov	r5,fp
811282c8:	b009883a 	mov	r4,r22
811282cc:	e0c00015 	stw	r3,0(fp)
811282d0:	80a1883a 	add	r16,r16,r2
811282d4:	98a7c83a 	sub	r19,r19,r2
811282d8:	1122c5c0 	call	81122c5c <__srefill_r>
811282dc:	1000ca1e 	bne	r2,zero,81128608 <__svfscanf_r+0x988>
811282e0:	e0800117 	ldw	r2,4(fp)
811282e4:	e0c00017 	ldw	r3,0(fp)
811282e8:	14fff516 	blt	r2,r19,811282c0 <__reset+0xfb1082c0>
811282ec:	14c5c83a 	sub	r2,r2,r19
811282f0:	1cd5883a 	add	r10,r3,r19
811282f4:	84e1883a 	add	r16,r16,r19
811282f8:	e0800115 	stw	r2,4(fp)
811282fc:	e2800015 	stw	r10,0(fp)
81128300:	dd009d17 	ldw	r20,628(sp)
81128304:	9425883a 	add	r18,r18,r16
81128308:	a00d883a 	mov	r6,r20
8112830c:	003e9a06 	br	81127d78 <__reset+0xfb107d78>
81128310:	300b883a 	mov	r5,r6
81128314:	d9005884 	addi	r4,sp,354
81128318:	d9809d15 	stw	r6,628(sp)
8112831c:	112e2680 	call	8112e268 <__sccl>
81128320:	1029883a 	mov	r20,r2
81128324:	e0800117 	ldw	r2,4(fp)
81128328:	0081050e 	bge	zero,r2,81128740 <__svfscanf_r+0xac0>
8112832c:	e1000017 	ldw	r4,0(fp)
81128330:	20800003 	ldbu	r2,0(r4)
81128334:	98005926 	beq	r19,zero,8112849c <__svfscanf_r+0x81c>
81128338:	8c40040c 	andi	r17,r17,16
8112833c:	88005a26 	beq	r17,zero,811284a8 <__svfscanf_r+0x828>
81128340:	9823883a 	mov	r17,r19
81128344:	0021883a 	mov	r16,zero
81128348:	00000106 	br	81128350 <__svfscanf_r+0x6d0>
8112834c:	20800003 	ldbu	r2,0(r4)
81128350:	10803fcc 	andi	r2,r2,255
81128354:	d8c05884 	addi	r3,sp,354
81128358:	1885883a 	add	r2,r3,r2
8112835c:	10800007 	ldb	r2,0(r2)
81128360:	1000ad26 	beq	r2,zero,81128618 <__svfscanf_r+0x998>
81128364:	e0800117 	ldw	r2,4(fp)
81128368:	21000044 	addi	r4,r4,1
8112836c:	84000044 	addi	r16,r16,1
81128370:	10bfffc4 	addi	r2,r2,-1
81128374:	e0800115 	stw	r2,4(fp)
81128378:	e1000015 	stw	r4,0(fp)
8112837c:	84c0a026 	beq	r16,r19,81128600 <__svfscanf_r+0x980>
81128380:	00bff216 	blt	zero,r2,8112834c <__reset+0xfb10834c>
81128384:	e00b883a 	mov	r5,fp
81128388:	b009883a 	mov	r4,r22
8112838c:	1122c5c0 	call	81122c5c <__srefill_r>
81128390:	10009a1e 	bne	r2,zero,811285fc <__svfscanf_r+0x97c>
81128394:	e1000017 	ldw	r4,0(fp)
81128398:	003fec06 	br	8112834c <__reset+0xfb10834c>
8112839c:	e0800117 	ldw	r2,4(fp)
811283a0:	d9809d15 	stw	r6,628(sp)
811283a4:	0080eb0e 	bge	zero,r2,81128754 <__svfscanf_r+0xad4>
811283a8:	00a044b4 	movhi	r2,33042
811283ac:	108c9804 	addi	r2,r2,12896
811283b0:	d880a115 	stw	r2,644(sp)
811283b4:	d8009e15 	stw	zero,632(sp)
811283b8:	050000c4 	movi	r20,3
811283bc:	003f3606 	br	81128098 <__reset+0xfb108098>
811283c0:	dd409904 	addi	r21,sp,612
811283c4:	8c40040c 	andi	r17,r17,16
811283c8:	01800204 	movi	r6,8
811283cc:	000b883a 	mov	r5,zero
811283d0:	a809883a 	mov	r4,r21
811283d4:	dc409f15 	stw	r17,636(sp)
811283d8:	11227e00 	call	811227e0 <memset>
811283dc:	dc409f17 	ldw	r17,636(sp)
811283e0:	88006e26 	beq	r17,zero,8112859c <__svfscanf_r+0x91c>
811283e4:	0029883a 	mov	r20,zero
811283e8:	0023883a 	mov	r17,zero
811283ec:	112c6840 	call	8112c684 <__locale_mb_cur_max>
811283f0:	14406126 	beq	r2,r17,81128578 <__svfscanf_r+0x8f8>
811283f4:	e0800017 	ldw	r2,0(fp)
811283f8:	e0c00117 	ldw	r3,4(fp)
811283fc:	d9000104 	addi	r4,sp,4
81128400:	12000003 	ldbu	r8,0(r2)
81128404:	18ffffc4 	addi	r3,r3,-1
81128408:	10800044 	addi	r2,r2,1
8112840c:	e0c00115 	stw	r3,4(fp)
81128410:	e0800015 	stw	r2,0(fp)
81128414:	8c000044 	addi	r16,r17,1
81128418:	dd400015 	stw	r21,0(sp)
8112841c:	2463883a 	add	r17,r4,r17
81128420:	200d883a 	mov	r6,r4
81128424:	a00b883a 	mov	r5,r20
81128428:	800f883a 	mov	r7,r16
8112842c:	b009883a 	mov	r4,r22
81128430:	8a000005 	stb	r8,0(r17)
81128434:	112c7400 	call	8112c740 <_mbrtowc_r>
81128438:	017fffc4 	movi	r5,-1
8112843c:	11404e26 	beq	r2,r5,81128578 <__svfscanf_r+0x8f8>
81128440:	1000601e 	bne	r2,zero,811285c4 <__svfscanf_r+0x944>
81128444:	da009f17 	ldw	r8,636(sp)
81128448:	4000641e 	bne	r8,zero,811285dc <__svfscanf_r+0x95c>
8112844c:	a0000015 	stw	zero,0(r20)
81128450:	9425883a 	add	r18,r18,r16
81128454:	9967883a 	add	r19,r19,r5
81128458:	a5000104 	addi	r20,r20,4
8112845c:	e0800117 	ldw	r2,4(fp)
81128460:	0023883a 	mov	r17,zero
81128464:	00804b16 	blt	zero,r2,81128594 <__svfscanf_r+0x914>
81128468:	e00b883a 	mov	r5,fp
8112846c:	b009883a 	mov	r4,r22
81128470:	1122c5c0 	call	81122c5c <__srefill_r>
81128474:	10004726 	beq	r2,zero,81128594 <__svfscanf_r+0x914>
81128478:	88003f1e 	bne	r17,zero,81128578 <__svfscanf_r+0x8f8>
8112847c:	d8c09f17 	ldw	r3,636(sp)
81128480:	1800031e 	bne	r3,zero,81128490 <__svfscanf_r+0x810>
81128484:	da00a017 	ldw	r8,640(sp)
81128488:	42000044 	addi	r8,r8,1
8112848c:	da00a015 	stw	r8,640(sp)
81128490:	dd009d17 	ldw	r20,628(sp)
81128494:	a00d883a 	mov	r6,r20
81128498:	003e3706 	br	81127d78 <__reset+0xfb107d78>
8112849c:	8c40040c 	andi	r17,r17,16
811284a0:	04ffffc4 	movi	r19,-1
811284a4:	883fa61e 	bne	r17,zero,81128340 <__reset+0xfb108340>
811284a8:	da009c17 	ldw	r8,624(sp)
811284ac:	9abfffc4 	addi	r10,r19,-1
811284b0:	44000017 	ldw	r16,0(r8)
811284b4:	44400104 	addi	r17,r8,4
811284b8:	8007883a 	mov	r3,r16
811284bc:	82ab883a 	add	r21,r16,r10
811284c0:	00000306 	br	811284d0 <__svfscanf_r+0x850>
811284c4:	e1000017 	ldw	r4,0(fp)
811284c8:	9807883a 	mov	r3,r19
811284cc:	20800003 	ldbu	r2,0(r4)
811284d0:	10803fcc 	andi	r2,r2,255
811284d4:	d9405884 	addi	r5,sp,354
811284d8:	2885883a 	add	r2,r5,r2
811284dc:	10800007 	ldb	r2,0(r2)
811284e0:	10004b26 	beq	r2,zero,81128610 <__svfscanf_r+0x990>
811284e4:	e0800117 	ldw	r2,4(fp)
811284e8:	21400044 	addi	r5,r4,1
811284ec:	e1400015 	stw	r5,0(fp)
811284f0:	10bfffc4 	addi	r2,r2,-1
811284f4:	e0800115 	stw	r2,4(fp)
811284f8:	20800003 	ldbu	r2,0(r4)
811284fc:	1cc00044 	addi	r19,r3,1
81128500:	18800005 	stb	r2,0(r3)
81128504:	1d400726 	beq	r3,r21,81128524 <__svfscanf_r+0x8a4>
81128508:	e0800117 	ldw	r2,4(fp)
8112850c:	00bfed16 	blt	zero,r2,811284c4 <__reset+0xfb1084c4>
81128510:	e00b883a 	mov	r5,fp
81128514:	b009883a 	mov	r4,r22
81128518:	1122c5c0 	call	81122c5c <__srefill_r>
8112851c:	103fe926 	beq	r2,zero,811284c4 <__reset+0xfb1084c4>
81128520:	84c01526 	beq	r16,r19,81128578 <__svfscanf_r+0x8f8>
81128524:	9c21c83a 	sub	r16,r19,r16
81128528:	803e1726 	beq	r16,zero,81127d88 <__reset+0xfb107d88>
8112852c:	da00a017 	ldw	r8,640(sp)
81128530:	98000005 	stb	zero,0(r19)
81128534:	dc409c15 	stw	r17,624(sp)
81128538:	42000044 	addi	r8,r8,1
8112853c:	da00a015 	stw	r8,640(sp)
81128540:	9425883a 	add	r18,r18,r16
81128544:	a00d883a 	mov	r6,r20
81128548:	003e0b06 	br	81127d78 <__reset+0xfb107d78>
8112854c:	017fff84 	movi	r5,-2
81128550:	11439b1e 	bne	r2,r5,811293c0 <__svfscanf_r+0x1740>
81128554:	8821883a 	mov	r16,r17
81128558:	e0800117 	ldw	r2,4(fp)
8112855c:	0082e516 	blt	zero,r2,811290f4 <__svfscanf_r+0x1474>
81128560:	e00b883a 	mov	r5,fp
81128564:	b009883a 	mov	r4,r22
81128568:	1122c5c0 	call	81122c5c <__srefill_r>
8112856c:	1002e126 	beq	r2,zero,811290f4 <__svfscanf_r+0x1474>
81128570:	dc409f17 	ldw	r17,636(sp)
81128574:	8002e826 	beq	r16,zero,81129118 <__svfscanf_r+0x1498>
81128578:	da00a017 	ldw	r8,640(sp)
8112857c:	403e9c26 	beq	r8,zero,81127ff0 <__reset+0xfb107ff0>
81128580:	e080030b 	ldhu	r2,12(fp)
81128584:	1080100c 	andi	r2,r2,64
81128588:	103e991e 	bne	r2,zero,81127ff0 <__reset+0xfb107ff0>
8112858c:	4005883a 	mov	r2,r8
81128590:	003e9806 	br	81127ff4 <__reset+0xfb107ff4>
81128594:	983f951e 	bne	r19,zero,811283ec <__reset+0xfb1083ec>
81128598:	003fb806 	br	8112847c <__reset+0xfb10847c>
8112859c:	da009c17 	ldw	r8,624(sp)
811285a0:	45000017 	ldw	r20,0(r8)
811285a4:	42000104 	addi	r8,r8,4
811285a8:	da009c15 	stw	r8,624(sp)
811285ac:	003f8e06 	br	811283e8 <__reset+0xfb1083e8>
811285b0:	e00b883a 	mov	r5,fp
811285b4:	b009883a 	mov	r4,r22
811285b8:	1122c5c0 	call	81122c5c <__srefill_r>
811285bc:	103f3826 	beq	r2,zero,811282a0 <__reset+0xfb1082a0>
811285c0:	003fed06 	br	81128578 <__reset+0xfb108578>
811285c4:	00ffff84 	movi	r3,-2
811285c8:	10c0071e 	bne	r2,r3,811285e8 <__svfscanf_r+0x968>
811285cc:	e0800117 	ldw	r2,4(fp)
811285d0:	8023883a 	mov	r17,r16
811285d4:	00bf8516 	blt	zero,r2,811283ec <__reset+0xfb1083ec>
811285d8:	003fa306 	br	81128468 <__reset+0xfb108468>
811285dc:	9425883a 	add	r18,r18,r16
811285e0:	9cffffc4 	addi	r19,r19,-1
811285e4:	003f9d06 	br	8112845c <__reset+0xfb10845c>
811285e8:	da009f17 	ldw	r8,636(sp)
811285ec:	9425883a 	add	r18,r18,r16
811285f0:	9cffffc4 	addi	r19,r19,-1
811285f4:	403f9826 	beq	r8,zero,81128458 <__reset+0xfb108458>
811285f8:	003f9806 	br	8112845c <__reset+0xfb10845c>
811285fc:	8023883a 	mov	r17,r16
81128600:	8821883a 	mov	r16,r17
81128604:	003fce06 	br	81128540 <__reset+0xfb108540>
81128608:	803f3d1e 	bne	r16,zero,81128300 <__reset+0xfb108300>
8112860c:	003fda06 	br	81128578 <__reset+0xfb108578>
81128610:	1827883a 	mov	r19,r3
81128614:	003fc306 	br	81128524 <__reset+0xfb108524>
81128618:	803fc91e 	bne	r16,zero,81128540 <__reset+0xfb108540>
8112861c:	003dda06 	br	81127d88 <__reset+0xfb107d88>
81128620:	da009c17 	ldw	r8,624(sp)
81128624:	df000015 	stw	fp,0(sp)
81128628:	980f883a 	mov	r7,r19
8112862c:	41400017 	ldw	r5,0(r8)
81128630:	01800044 	movi	r6,1
81128634:	b009883a 	mov	r4,r22
81128638:	112b8580 	call	8112b858 <_fread_r>
8112863c:	da009c17 	ldw	r8,624(sp)
81128640:	40c00104 	addi	r3,r8,4
81128644:	103fcc26 	beq	r2,zero,81128578 <__reset+0xfb108578>
81128648:	da00a017 	ldw	r8,640(sp)
8112864c:	dd009d17 	ldw	r20,628(sp)
81128650:	90a5883a 	add	r18,r18,r2
81128654:	42000044 	addi	r8,r8,1
81128658:	da00a015 	stw	r8,640(sp)
8112865c:	d8c09c15 	stw	r3,624(sp)
81128660:	a00d883a 	mov	r6,r20
81128664:	003dc406 	br	81127d78 <__reset+0xfb107d78>
81128668:	e00b883a 	mov	r5,fp
8112866c:	b009883a 	mov	r4,r22
81128670:	1122c5c0 	call	81122c5c <__srefill_r>
81128674:	103e5226 	beq	r2,zero,81127fc0 <__reset+0xfb107fc0>
81128678:	003fbf06 	br	81128578 <__reset+0xfb108578>
8112867c:	a0800083 	ldbu	r2,2(r20)
81128680:	8c400094 	ori	r17,r17,2
81128684:	a5000084 	addi	r20,r20,2
81128688:	10c03fcc 	andi	r3,r2,255
8112868c:	003dc706 	br	81127dac <__reset+0xfb107dac>
81128690:	e0800117 	ldw	r2,4(fp)
81128694:	88e2b03a 	or	r17,r17,r3
81128698:	00bef716 	blt	zero,r2,81128278 <__reset+0xfb108278>
8112869c:	003e6f06 	br	8112805c <__reset+0xfb10805c>
811286a0:	8880004c 	andi	r2,r17,1
811286a4:	10000b1e 	bne	r2,zero,811286d4 <__svfscanf_r+0xa54>
811286a8:	8c40008c 	andi	r17,r17,2
811286ac:	88000926 	beq	r17,zero,811286d4 <__svfscanf_r+0xa54>
811286b0:	da009c17 	ldw	r8,624(sp)
811286b4:	9007d7fa 	srai	r3,r18,31
811286b8:	dd009d17 	ldw	r20,628(sp)
811286bc:	40800017 	ldw	r2,0(r8)
811286c0:	42000104 	addi	r8,r8,4
811286c4:	da009c15 	stw	r8,624(sp)
811286c8:	14800015 	stw	r18,0(r2)
811286cc:	10c00115 	stw	r3,4(r2)
811286d0:	003da806 	br	81127d74 <__reset+0xfb107d74>
811286d4:	da009c17 	ldw	r8,624(sp)
811286d8:	dd009d17 	ldw	r20,628(sp)
811286dc:	40800017 	ldw	r2,0(r8)
811286e0:	42000104 	addi	r8,r8,4
811286e4:	da009c15 	stw	r8,624(sp)
811286e8:	14800015 	stw	r18,0(r2)
811286ec:	003da106 	br	81127d74 <__reset+0xfb107d74>
811286f0:	e00b883a 	mov	r5,fp
811286f4:	b009883a 	mov	r4,r22
811286f8:	1122c5c0 	call	81122c5c <__srefill_r>
811286fc:	103f9e1e 	bne	r2,zero,81128578 <__reset+0xfb108578>
81128700:	b9c00017 	ldw	r7,0(r23)
81128704:	05000104 	movi	r20,4
81128708:	003e6306 	br	81128098 <__reset+0xfb108098>
8112870c:	e00b883a 	mov	r5,fp
81128710:	b009883a 	mov	r4,r22
81128714:	1122c5c0 	call	81122c5c <__srefill_r>
81128718:	103f971e 	bne	r2,zero,81128578 <__reset+0xfb108578>
8112871c:	b9c00017 	ldw	r7,0(r23)
81128720:	003e5706 	br	81128080 <__reset+0xfb108080>
81128724:	e00b883a 	mov	r5,fp
81128728:	b009883a 	mov	r4,r22
8112872c:	1122c5c0 	call	81122c5c <__srefill_r>
81128730:	103f911e 	bne	r2,zero,81128578 <__reset+0xfb108578>
81128734:	b9c00017 	ldw	r7,0(r23)
81128738:	05000084 	movi	r20,2
8112873c:	003e5606 	br	81128098 <__reset+0xfb108098>
81128740:	e00b883a 	mov	r5,fp
81128744:	b009883a 	mov	r4,r22
81128748:	1122c5c0 	call	81122c5c <__srefill_r>
8112874c:	103ef726 	beq	r2,zero,8112832c <__reset+0xfb10832c>
81128750:	003f8906 	br	81128578 <__reset+0xfb108578>
81128754:	e00b883a 	mov	r5,fp
81128758:	b009883a 	mov	r4,r22
8112875c:	1122c5c0 	call	81122c5c <__srefill_r>
81128760:	103f851e 	bne	r2,zero,81128578 <__reset+0xfb108578>
81128764:	b9c00017 	ldw	r7,0(r23)
81128768:	003f0f06 	br	811283a8 <__reset+0xfb1083a8>
8112876c:	014000c4 	movi	r5,3
81128770:	a1414a26 	beq	r20,r5,81128c9c <__svfscanf_r+0x101c>
81128774:	01000104 	movi	r4,4
81128778:	a101f11e 	bne	r20,r4,81128f40 <__svfscanf_r+0x12c0>
8112877c:	b009883a 	mov	r4,r22
81128780:	112c6a80 	call	8112c6a8 <_localeconv_r>
81128784:	10800017 	ldw	r2,0(r2)
81128788:	98ffffc4 	addi	r3,r19,-1
8112878c:	d880a315 	stw	r2,652(sp)
81128790:	00805704 	movi	r2,348
81128794:	10c21e2e 	bgeu	r2,r3,81129010 <__svfscanf_r+0x1390>
81128798:	9cffa8c4 	addi	r19,r19,-349
8112879c:	dcc0a215 	stw	r19,648(sp)
811287a0:	04c05744 	movi	r19,349
811287a4:	8d01e014 	ori	r20,r17,1920
811287a8:	0023883a 	mov	r17,zero
811287ac:	dc000104 	addi	r16,sp,4
811287b0:	8805883a 	mov	r2,r17
811287b4:	0019883a 	mov	r12,zero
811287b8:	8023883a 	mov	r17,r16
811287bc:	b007883a 	mov	r3,r22
811287c0:	9821883a 	mov	r16,r19
811287c4:	002b883a 	mov	r21,zero
811287c8:	d800a515 	stw	zero,660(sp)
811287cc:	d800a415 	stw	zero,656(sp)
811287d0:	d8009f15 	stw	zero,636(sp)
811287d4:	01c01384 	movi	r7,78
811287d8:	602d883a 	mov	r22,r12
811287dc:	1027883a 	mov	r19,r2
811287e0:	e1000017 	ldw	r4,0(fp)
811287e4:	21400003 	ldbu	r5,0(r4)
811287e8:	28bff544 	addi	r2,r5,-43
811287ec:	10803fcc 	andi	r2,r2,255
811287f0:	38810e36 	bltu	r7,r2,81128c2c <__svfscanf_r+0xfac>
811287f4:	100490ba 	slli	r2,r2,2
811287f8:	01a044f4 	movhi	r6,33043
811287fc:	31a20304 	addi	r6,r6,-30708
81128800:	1185883a 	add	r2,r2,r6
81128804:	10800017 	ldw	r2,0(r2)
81128808:	1000683a 	jmp	r2
8112880c:	81128b04 	addi	r4,r16,18988
81128810:	81128c2c 	andhi	r4,r16,18992
81128814:	81128b04 	addi	r4,r16,18988
81128818:	81128c2c 	andhi	r4,r16,18992
8112881c:	81128c2c 	andhi	r4,r16,18992
81128820:	81128ad8 	cmpnei	r4,r16,18987
81128824:	81128948 	cmpgei	r4,r16,18981
81128828:	81128948 	cmpgei	r4,r16,18981
8112882c:	81128948 	cmpgei	r4,r16,18981
81128830:	81128948 	cmpgei	r4,r16,18981
81128834:	81128948 	cmpgei	r4,r16,18981
81128838:	81128948 	cmpgei	r4,r16,18981
8112883c:	81128948 	cmpgei	r4,r16,18981
81128840:	81128948 	cmpgei	r4,r16,18981
81128844:	81128948 	cmpgei	r4,r16,18981
81128848:	81128c2c 	andhi	r4,r16,18992
8112884c:	81128c2c 	andhi	r4,r16,18992
81128850:	81128c2c 	andhi	r4,r16,18992
81128854:	81128c2c 	andhi	r4,r16,18992
81128858:	81128c2c 	andhi	r4,r16,18992
8112885c:	81128c2c 	andhi	r4,r16,18992
81128860:	81128c2c 	andhi	r4,r16,18992
81128864:	81128c1c 	xori	r4,r16,18992
81128868:	81128c2c 	andhi	r4,r16,18992
8112886c:	81128c2c 	andhi	r4,r16,18992
81128870:	81128c2c 	andhi	r4,r16,18992
81128874:	81128bd8 	cmpnei	r4,r16,18991
81128878:	81128bbc 	xorhi	r4,r16,18990
8112887c:	81128c2c 	andhi	r4,r16,18992
81128880:	81128c2c 	andhi	r4,r16,18992
81128884:	81128b88 	cmpgei	r4,r16,18990
81128888:	81128c2c 	andhi	r4,r16,18992
8112888c:	81128c2c 	andhi	r4,r16,18992
81128890:	81128c2c 	andhi	r4,r16,18992
81128894:	81128c2c 	andhi	r4,r16,18992
81128898:	81128b50 	cmplti	r4,r16,18989
8112889c:	81128c2c 	andhi	r4,r16,18992
811288a0:	81128c2c 	andhi	r4,r16,18992
811288a4:	81128c2c 	andhi	r4,r16,18992
811288a8:	81128c2c 	andhi	r4,r16,18992
811288ac:	81128c2c 	andhi	r4,r16,18992
811288b0:	81128b34 	orhi	r4,r16,18988
811288b4:	81128c2c 	andhi	r4,r16,18992
811288b8:	81128c2c 	andhi	r4,r16,18992
811288bc:	81128c2c 	andhi	r4,r16,18992
811288c0:	81128c2c 	andhi	r4,r16,18992
811288c4:	81128b18 	cmpnei	r4,r16,18988
811288c8:	81128c2c 	andhi	r4,r16,18992
811288cc:	81128c2c 	andhi	r4,r16,18992
811288d0:	81128c2c 	andhi	r4,r16,18992
811288d4:	81128c2c 	andhi	r4,r16,18992
811288d8:	81128c2c 	andhi	r4,r16,18992
811288dc:	81128c2c 	andhi	r4,r16,18992
811288e0:	81128c2c 	andhi	r4,r16,18992
811288e4:	81128c1c 	xori	r4,r16,18992
811288e8:	81128c2c 	andhi	r4,r16,18992
811288ec:	81128c2c 	andhi	r4,r16,18992
811288f0:	81128c2c 	andhi	r4,r16,18992
811288f4:	81128bd8 	cmpnei	r4,r16,18991
811288f8:	81128bbc 	xorhi	r4,r16,18990
811288fc:	81128c2c 	andhi	r4,r16,18992
81128900:	81128c2c 	andhi	r4,r16,18992
81128904:	81128b88 	cmpgei	r4,r16,18990
81128908:	81128c2c 	andhi	r4,r16,18992
8112890c:	81128c2c 	andhi	r4,r16,18992
81128910:	81128c2c 	andhi	r4,r16,18992
81128914:	81128c2c 	andhi	r4,r16,18992
81128918:	81128b50 	cmplti	r4,r16,18989
8112891c:	81128c2c 	andhi	r4,r16,18992
81128920:	81128c2c 	andhi	r4,r16,18992
81128924:	81128c2c 	andhi	r4,r16,18992
81128928:	81128c2c 	andhi	r4,r16,18992
8112892c:	81128c2c 	andhi	r4,r16,18992
81128930:	81128b34 	orhi	r4,r16,18988
81128934:	81128c2c 	andhi	r4,r16,18992
81128938:	81128c2c 	andhi	r4,r16,18992
8112893c:	81128c2c 	andhi	r4,r16,18992
81128940:	81128c2c 	andhi	r4,r16,18992
81128944:	81128b18 	cmpnei	r4,r16,18988
81128948:	a8803fcc 	andi	r2,r21,255
8112894c:	1080201c 	xori	r2,r2,128
81128950:	10bfe004 	addi	r2,r2,-128
81128954:	b085883a 	add	r2,r22,r2
81128958:	10000d1e 	bne	r2,zero,81128990 <__svfscanf_r+0xd10>
8112895c:	00bf9fc4 	movi	r2,-385
81128960:	a0a8703a 	and	r20,r20,r2
81128964:	89400005 	stb	r5,0(r17)
81128968:	8c400044 	addi	r17,r17,1
8112896c:	e0800117 	ldw	r2,4(fp)
81128970:	843fffc4 	addi	r16,r16,-1
81128974:	94800044 	addi	r18,r18,1
81128978:	10bfffc4 	addi	r2,r2,-1
8112897c:	e0800115 	stw	r2,4(fp)
81128980:	0080b40e 	bge	zero,r2,81128c54 <__svfscanf_r+0xfd4>
81128984:	21000044 	addi	r4,r4,1
81128988:	e1000015 	stw	r4,0(fp)
8112898c:	803f941e 	bne	r16,zero,811287e0 <__reset+0xfb1087e0>
81128990:	8821883a 	mov	r16,r17
81128994:	b019883a 	mov	r12,r22
81128998:	9823883a 	mov	r17,r19
8112899c:	182d883a 	mov	r22,r3
811289a0:	9801961e 	bne	r19,zero,81128ffc <__svfscanf_r+0x137c>
811289a4:	633fffc4 	addi	r12,r12,-1
811289a8:	00800044 	movi	r2,1
811289ac:	1302882e 	bgeu	r2,r12,811293d0 <__svfscanf_r+0x1750>
811289b0:	a8803fcc 	andi	r2,r21,255
811289b4:	1080201c 	xori	r2,r2,128
811289b8:	10bfe004 	addi	r2,r2,-128
811289bc:	113fffc4 	addi	r4,r2,-1
811289c0:	01400184 	movi	r5,6
811289c4:	29001136 	bltu	r5,r4,81128a0c <__svfscanf_r+0xd8c>
811289c8:	01000084 	movi	r4,2
811289cc:	2082900e 	bge	r4,r2,81129410 <__svfscanf_r+0x1790>
811289d0:	00c000c4 	movi	r3,3
811289d4:	10c00d26 	beq	r2,r3,81128a0c <__svfscanf_r+0xd8c>
811289d8:	9425c83a 	sub	r18,r18,r16
811289dc:	1827883a 	mov	r19,r3
811289e0:	843fffc4 	addi	r16,r16,-1
811289e4:	81400007 	ldb	r5,0(r16)
811289e8:	e00d883a 	mov	r6,fp
811289ec:	b009883a 	mov	r4,r22
811289f0:	11315f00 	call	811315f0 <_ungetc_r>
811289f4:	a8bfffc4 	addi	r2,r21,-1
811289f8:	10c03fcc 	andi	r3,r2,255
811289fc:	8493883a 	add	r9,r16,r18
81128a00:	102b883a 	mov	r21,r2
81128a04:	98fff636 	bltu	r19,r3,811289e0 <__reset+0xfb1089e0>
81128a08:	4825883a 	mov	r18,r9
81128a0c:	a080400c 	andi	r2,r20,256
81128a10:	10001426 	beq	r2,zero,81128a64 <__svfscanf_r+0xde4>
81128a14:	a081000c 	andi	r2,r20,1024
81128a18:	1002571e 	bne	r2,zero,81129378 <__svfscanf_r+0x16f8>
81128a1c:	817fffc7 	ldb	r5,-1(r16)
81128a20:	00801944 	movi	r2,101
81128a24:	84ffffc4 	addi	r19,r16,-1
81128a28:	957fffc4 	addi	r21,r18,-1
81128a2c:	28800826 	beq	r5,r2,81128a50 <__svfscanf_r+0xdd0>
81128a30:	00801144 	movi	r2,69
81128a34:	28800626 	beq	r5,r2,81128a50 <__svfscanf_r+0xdd0>
81128a38:	e00d883a 	mov	r6,fp
81128a3c:	b009883a 	mov	r4,r22
81128a40:	11315f00 	call	811315f0 <_ungetc_r>
81128a44:	817fff87 	ldb	r5,-2(r16)
81128a48:	84ffff84 	addi	r19,r16,-2
81128a4c:	957fff84 	addi	r21,r18,-2
81128a50:	e00d883a 	mov	r6,fp
81128a54:	b009883a 	mov	r4,r22
81128a58:	11315f00 	call	811315f0 <_ungetc_r>
81128a5c:	a825883a 	mov	r18,r21
81128a60:	9821883a 	mov	r16,r19
81128a64:	a080040c 	andi	r2,r20,16
81128a68:	103e891e 	bne	r2,zero,81128490 <__reset+0xfb108490>
81128a6c:	80000005 	stb	zero,0(r16)
81128a70:	a081800c 	andi	r2,r20,1536
81128a74:	01010004 	movi	r4,1024
81128a78:	1101dd26 	beq	r2,r4,811291f0 <__svfscanf_r+0x1570>
81128a7c:	da00a417 	ldw	r8,656(sp)
81128a80:	4001e71e 	bne	r8,zero,81129220 <__svfscanf_r+0x15a0>
81128a84:	000d883a 	mov	r6,zero
81128a88:	d9400104 	addi	r5,sp,4
81128a8c:	b009883a 	mov	r4,r22
81128a90:	112e4880 	call	8112e488 <_strtod_r>
81128a94:	1021883a 	mov	r16,r2
81128a98:	a080004c 	andi	r2,r20,1
81128a9c:	1000021e 	bne	r2,zero,81128aa8 <__svfscanf_r+0xe28>
81128aa0:	a2c0008c 	andi	r11,r20,2
81128aa4:	5801e826 	beq	r11,zero,81129248 <__svfscanf_r+0x15c8>
81128aa8:	da009c17 	ldw	r8,624(sp)
81128aac:	40800017 	ldw	r2,0(r8)
81128ab0:	42000104 	addi	r8,r8,4
81128ab4:	da009c15 	stw	r8,624(sp)
81128ab8:	14000015 	stw	r16,0(r2)
81128abc:	10c00115 	stw	r3,4(r2)
81128ac0:	da00a017 	ldw	r8,640(sp)
81128ac4:	dd009d17 	ldw	r20,628(sp)
81128ac8:	42000044 	addi	r8,r8,1
81128acc:	da00a015 	stw	r8,640(sp)
81128ad0:	a00d883a 	mov	r6,r20
81128ad4:	003ca806 	br	81127d78 <__reset+0xfb107d78>
81128ad8:	a080400c 	andi	r2,r20,256
81128adc:	103f9a26 	beq	r2,zero,81128948 <__reset+0xfb108948>
81128ae0:	da00a217 	ldw	r8,648(sp)
81128ae4:	00bfdfc4 	movi	r2,-129
81128ae8:	a0a8703a 	and	r20,r20,r2
81128aec:	9cc00044 	addi	r19,r19,1
81128af0:	403f9e26 	beq	r8,zero,8112896c <__reset+0xfb10896c>
81128af4:	423fffc4 	addi	r8,r8,-1
81128af8:	da00a215 	stw	r8,648(sp)
81128afc:	84000044 	addi	r16,r16,1
81128b00:	003f9a06 	br	8112896c <__reset+0xfb10896c>
81128b04:	a080200c 	andi	r2,r20,128
81128b08:	103fa126 	beq	r2,zero,81128990 <__reset+0xfb108990>
81128b0c:	00bfdfc4 	movi	r2,-129
81128b10:	a0a8703a 	and	r20,r20,r2
81128b14:	003f9306 	br	81128964 <__reset+0xfb108964>
81128b18:	a8803fcc 	andi	r2,r21,255
81128b1c:	1080201c 	xori	r2,r2,128
81128b20:	10bfe004 	addi	r2,r2,-128
81128b24:	020001c4 	movi	r8,7
81128b28:	123f991e 	bne	r2,r8,81128990 <__reset+0xfb108990>
81128b2c:	05400204 	movi	r21,8
81128b30:	003f8c06 	br	81128964 <__reset+0xfb108964>
81128b34:	a8803fcc 	andi	r2,r21,255
81128b38:	1080201c 	xori	r2,r2,128
81128b3c:	10bfe004 	addi	r2,r2,-128
81128b40:	01800184 	movi	r6,6
81128b44:	11bf921e 	bne	r2,r6,81128990 <__reset+0xfb108990>
81128b48:	054001c4 	movi	r21,7
81128b4c:	003f8506 	br	81128964 <__reset+0xfb108964>
81128b50:	b000491e 	bne	r22,zero,81128c78 <__svfscanf_r+0xff8>
81128b54:	9800031e 	bne	r19,zero,81128b64 <__svfscanf_r+0xee4>
81128b58:	a081c00c 	andi	r2,r20,1792
81128b5c:	0181c004 	movi	r6,1792
81128b60:	11819f26 	beq	r2,r6,811291e0 <__svfscanf_r+0x1560>
81128b64:	a8803fcc 	andi	r2,r21,255
81128b68:	1080201c 	xori	r2,r2,128
81128b6c:	10bfe004 	addi	r2,r2,-128
81128b70:	01800044 	movi	r6,1
81128b74:	11800226 	beq	r2,r6,81128b80 <__svfscanf_r+0xf00>
81128b78:	01800104 	movi	r6,4
81128b7c:	11bf841e 	bne	r2,r6,81128990 <__reset+0xfb108990>
81128b80:	ad400044 	addi	r21,r21,1
81128b84:	003f7706 	br	81128964 <__reset+0xfb108964>
81128b88:	a8803fcc 	andi	r2,r21,255
81128b8c:	1080201c 	xori	r2,r2,128
81128b90:	10bfe004 	addi	r2,r2,-128
81128b94:	10003c1e 	bne	r2,zero,81128c88 <__svfscanf_r+0x1008>
81128b98:	9801141e 	bne	r19,zero,81128fec <__svfscanf_r+0x136c>
81128b9c:	a081c00c 	andi	r2,r20,1792
81128ba0:	0181c004 	movi	r6,1792
81128ba4:	11818226 	beq	r2,r6,811291b0 <__svfscanf_r+0x1530>
81128ba8:	8821883a 	mov	r16,r17
81128bac:	b019883a 	mov	r12,r22
81128bb0:	9823883a 	mov	r17,r19
81128bb4:	182d883a 	mov	r22,r3
81128bb8:	003f7a06 	br	811289a4 <__reset+0xfb1089a4>
81128bbc:	a8803fcc 	andi	r2,r21,255
81128bc0:	1080201c 	xori	r2,r2,128
81128bc4:	10bfe004 	addi	r2,r2,-128
81128bc8:	01800084 	movi	r6,2
81128bcc:	11bf701e 	bne	r2,r6,81128990 <__reset+0xfb108990>
81128bd0:	054000c4 	movi	r21,3
81128bd4:	003f6306 	br	81128964 <__reset+0xfb108964>
81128bd8:	a081400c 	andi	r2,r20,1280
81128bdc:	01810004 	movi	r6,1024
81128be0:	11800326 	beq	r2,r6,81128bf0 <__svfscanf_r+0xf70>
81128be4:	a184703a 	and	r2,r20,r6
81128be8:	103f6926 	beq	r2,zero,81128990 <__reset+0xfb108990>
81128bec:	983fee26 	beq	r19,zero,81128ba8 <__reset+0xfb108ba8>
81128bf0:	a080800c 	andi	r2,r20,512
81128bf4:	1000041e 	bne	r2,zero,81128c08 <__svfscanf_r+0xf88>
81128bf8:	da009f17 	ldw	r8,636(sp)
81128bfc:	dc40a515 	stw	r17,660(sp)
81128c00:	9a27c83a 	sub	r19,r19,r8
81128c04:	dcc0a415 	stw	r19,656(sp)
81128c08:	00be1fc4 	movi	r2,-1921
81128c0c:	a0a8703a 	and	r20,r20,r2
81128c10:	a5006014 	ori	r20,r20,384
81128c14:	0027883a 	mov	r19,zero
81128c18:	003f5206 	br	81128964 <__reset+0xfb108964>
81128c1c:	00800044 	movi	r2,1
81128c20:	b0bf5b1e 	bne	r22,r2,81128990 <__reset+0xfb108990>
81128c24:	05800084 	movi	r22,2
81128c28:	003f4e06 	br	81128964 <__reset+0xfb108964>
81128c2c:	d980a317 	ldw	r6,652(sp)
81128c30:	30800003 	ldbu	r2,0(r6)
81128c34:	29803fcc 	andi	r6,r5,255
81128c38:	30bf551e 	bne	r6,r2,81128990 <__reset+0xfb108990>
81128c3c:	a080800c 	andi	r2,r20,512
81128c40:	103f5326 	beq	r2,zero,81128990 <__reset+0xfb108990>
81128c44:	023f5fc4 	movi	r8,-641
81128c48:	a228703a 	and	r20,r20,r8
81128c4c:	dcc09f15 	stw	r19,636(sp)
81128c50:	003f4406 	br	81128964 <__reset+0xfb108964>
81128c54:	1809883a 	mov	r4,r3
81128c58:	e00b883a 	mov	r5,fp
81128c5c:	d8c0a615 	stw	r3,664(sp)
81128c60:	d9c0aa15 	stw	r7,680(sp)
81128c64:	1122c5c0 	call	81122c5c <__srefill_r>
81128c68:	d8c0a617 	ldw	r3,664(sp)
81128c6c:	d9c0aa17 	ldw	r7,680(sp)
81128c70:	103f4626 	beq	r2,zero,8112898c <__reset+0xfb10898c>
81128c74:	003f4606 	br	81128990 <__reset+0xfb108990>
81128c78:	00800084 	movi	r2,2
81128c7c:	b0bfb91e 	bne	r22,r2,81128b64 <__reset+0xfb108b64>
81128c80:	058000c4 	movi	r22,3
81128c84:	003f3706 	br	81128964 <__reset+0xfb108964>
81128c88:	018000c4 	movi	r6,3
81128c8c:	11bfbc26 	beq	r2,r6,81128b80 <__reset+0xfb108b80>
81128c90:	01800144 	movi	r6,5
81128c94:	11bfba26 	beq	r2,r6,81128b80 <__reset+0xfb108b80>
81128c98:	003f3d06 	br	81128990 <__reset+0xfb108990>
81128c9c:	98bfffc4 	addi	r2,r19,-1
81128ca0:	01405704 	movi	r5,348
81128ca4:	2880d82e 	bgeu	r5,r2,81129008 <__svfscanf_r+0x1388>
81128ca8:	99ffa8c4 	addi	r7,r19,-349
81128cac:	04c05744 	movi	r19,349
81128cb0:	8c436014 	ori	r17,r17,3456
81128cb4:	9013883a 	mov	r9,r18
81128cb8:	8825883a 	mov	r18,r17
81128cbc:	dc409e17 	ldw	r17,632(sp)
81128cc0:	0029883a 	mov	r20,zero
81128cc4:	dc000104 	addi	r16,sp,4
81128cc8:	05401344 	movi	r21,77
81128ccc:	02c08004 	movi	r11,512
81128cd0:	01bf7fc4 	movi	r6,-513
81128cd4:	023fdfc4 	movi	r8,-129
81128cd8:	20bff544 	addi	r2,r4,-43
81128cdc:	10803fcc 	andi	r2,r2,255
81128ce0:	a8807236 	bltu	r21,r2,81128eac <__svfscanf_r+0x122c>
81128ce4:	100490ba 	slli	r2,r2,2
81128ce8:	016044f4 	movhi	r5,33043
81128cec:	29633f04 	addi	r5,r5,-29444
81128cf0:	1145883a 	add	r2,r2,r5
81128cf4:	10800017 	ldw	r2,0(r2)
81128cf8:	1000683a 	jmp	r2
81128cfc:	81128f30 	cmpltui	r4,r16,19004
81128d00:	81128eac 	andhi	r4,r16,19002
81128d04:	81128f30 	cmpltui	r4,r16,19004
81128d08:	81128eac 	andhi	r4,r16,19002
81128d0c:	81128eac 	andhi	r4,r16,19002
81128d10:	81128f08 	cmpgei	r4,r16,19004
81128d14:	81128ee8 	cmpgeui	r4,r16,19003
81128d18:	81128ee8 	cmpgeui	r4,r16,19003
81128d1c:	81128ee8 	cmpgeui	r4,r16,19003
81128d20:	81128ee8 	cmpgeui	r4,r16,19003
81128d24:	81128ee8 	cmpgeui	r4,r16,19003
81128d28:	81128ee8 	cmpgeui	r4,r16,19003
81128d2c:	81128ee8 	cmpgeui	r4,r16,19003
81128d30:	81128e90 	cmplti	r4,r16,19002
81128d34:	81128e90 	cmplti	r4,r16,19002
81128d38:	81128eac 	andhi	r4,r16,19002
81128d3c:	81128eac 	andhi	r4,r16,19002
81128d40:	81128eac 	andhi	r4,r16,19002
81128d44:	81128eac 	andhi	r4,r16,19002
81128d48:	81128eac 	andhi	r4,r16,19002
81128d4c:	81128eac 	andhi	r4,r16,19002
81128d50:	81128eac 	andhi	r4,r16,19002
81128d54:	81128e7c 	xorhi	r4,r16,19001
81128d58:	81128e7c 	xorhi	r4,r16,19001
81128d5c:	81128e7c 	xorhi	r4,r16,19001
81128d60:	81128e7c 	xorhi	r4,r16,19001
81128d64:	81128e7c 	xorhi	r4,r16,19001
81128d68:	81128e7c 	xorhi	r4,r16,19001
81128d6c:	81128eac 	andhi	r4,r16,19002
81128d70:	81128eac 	andhi	r4,r16,19002
81128d74:	81128eac 	andhi	r4,r16,19002
81128d78:	81128eac 	andhi	r4,r16,19002
81128d7c:	81128eac 	andhi	r4,r16,19002
81128d80:	81128eac 	andhi	r4,r16,19002
81128d84:	81128eac 	andhi	r4,r16,19002
81128d88:	81128eac 	andhi	r4,r16,19002
81128d8c:	81128eac 	andhi	r4,r16,19002
81128d90:	81128eac 	andhi	r4,r16,19002
81128d94:	81128eac 	andhi	r4,r16,19002
81128d98:	81128eac 	andhi	r4,r16,19002
81128d9c:	81128eac 	andhi	r4,r16,19002
81128da0:	81128eac 	andhi	r4,r16,19002
81128da4:	81128eac 	andhi	r4,r16,19002
81128da8:	81128eac 	andhi	r4,r16,19002
81128dac:	81128eac 	andhi	r4,r16,19002
81128db0:	81128e34 	orhi	r4,r16,19000
81128db4:	81128eac 	andhi	r4,r16,19002
81128db8:	81128eac 	andhi	r4,r16,19002
81128dbc:	81128eac 	andhi	r4,r16,19002
81128dc0:	81128eac 	andhi	r4,r16,19002
81128dc4:	81128eac 	andhi	r4,r16,19002
81128dc8:	81128eac 	andhi	r4,r16,19002
81128dcc:	81128eac 	andhi	r4,r16,19002
81128dd0:	81128eac 	andhi	r4,r16,19002
81128dd4:	81128e7c 	xorhi	r4,r16,19001
81128dd8:	81128e7c 	xorhi	r4,r16,19001
81128ddc:	81128e7c 	xorhi	r4,r16,19001
81128de0:	81128e7c 	xorhi	r4,r16,19001
81128de4:	81128e7c 	xorhi	r4,r16,19001
81128de8:	81128e7c 	xorhi	r4,r16,19001
81128dec:	81128eac 	andhi	r4,r16,19002
81128df0:	81128eac 	andhi	r4,r16,19002
81128df4:	81128eac 	andhi	r4,r16,19002
81128df8:	81128eac 	andhi	r4,r16,19002
81128dfc:	81128eac 	andhi	r4,r16,19002
81128e00:	81128eac 	andhi	r4,r16,19002
81128e04:	81128eac 	andhi	r4,r16,19002
81128e08:	81128eac 	andhi	r4,r16,19002
81128e0c:	81128eac 	andhi	r4,r16,19002
81128e10:	81128eac 	andhi	r4,r16,19002
81128e14:	81128eac 	andhi	r4,r16,19002
81128e18:	81128eac 	andhi	r4,r16,19002
81128e1c:	81128eac 	andhi	r4,r16,19002
81128e20:	81128eac 	andhi	r4,r16,19002
81128e24:	81128eac 	andhi	r4,r16,19002
81128e28:	81128eac 	andhi	r4,r16,19002
81128e2c:	81128eac 	andhi	r4,r16,19002
81128e30:	81128e34 	orhi	r4,r16,19000
81128e34:	9081800c 	andi	r2,r18,1536
81128e38:	12c01c1e 	bne	r2,r11,81128eac <__svfscanf_r+0x122c>
81128e3c:	91a4703a 	and	r18,r18,r6
81128e40:	94814014 	ori	r18,r18,1280
81128e44:	04400404 	movi	r17,16
81128e48:	81000005 	stb	r4,0(r16)
81128e4c:	84000044 	addi	r16,r16,1
81128e50:	e0800117 	ldw	r2,4(fp)
81128e54:	10bfffc4 	addi	r2,r2,-1
81128e58:	e0800115 	stw	r2,4(fp)
81128e5c:	0080540e 	bge	zero,r2,81128fb0 <__svfscanf_r+0x1330>
81128e60:	18c00044 	addi	r3,r3,1
81128e64:	e0c00015 	stw	r3,0(fp)
81128e68:	9cffffc4 	addi	r19,r19,-1
81128e6c:	98000f26 	beq	r19,zero,81128eac <__svfscanf_r+0x122c>
81128e70:	e0c00017 	ldw	r3,0(fp)
81128e74:	19000003 	ldbu	r4,0(r3)
81128e78:	003f9706 	br	81128cd8 <__reset+0xfb108cd8>
81128e7c:	00800284 	movi	r2,10
81128e80:	14400a0e 	bge	r2,r17,81128eac <__svfscanf_r+0x122c>
81128e84:	00bd1fc4 	movi	r2,-2945
81128e88:	90a4703a 	and	r18,r18,r2
81128e8c:	003fee06 	br	81128e48 <__reset+0xfb108e48>
81128e90:	01604574 	movhi	r5,33045
81128e94:	8c63883a 	add	r17,r17,r17
81128e98:	29435984 	addi	r5,r5,3430
81128e9c:	2c45883a 	add	r2,r5,r17
81128ea0:	1440000f 	ldh	r17,0(r2)
81128ea4:	00800204 	movi	r2,8
81128ea8:	147ff616 	blt	r2,r17,81128e84 <__reset+0xfb108e84>
81128eac:	dc409e15 	stw	r17,632(sp)
81128eb0:	9023883a 	mov	r17,r18
81128eb4:	8880400c 	andi	r2,r17,256
81128eb8:	4825883a 	mov	r18,r9
81128ebc:	10000426 	beq	r2,zero,81128ed0 <__svfscanf_r+0x1250>
81128ec0:	d9800104 	addi	r6,sp,4
81128ec4:	3400be36 	bltu	r6,r16,811291c0 <__svfscanf_r+0x1540>
81128ec8:	da000104 	addi	r8,sp,4
81128ecc:	443bae26 	beq	r8,r16,81127d88 <__reset+0xfb107d88>
81128ed0:	8880040c 	andi	r2,r17,16
81128ed4:	10009326 	beq	r2,zero,81129124 <__svfscanf_r+0x14a4>
81128ed8:	d8800104 	addi	r2,sp,4
81128edc:	80a1c83a 	sub	r16,r16,r2
81128ee0:	8521883a 	add	r16,r16,r20
81128ee4:	003d0606 	br	81128300 <__reset+0xfb108300>
81128ee8:	01604574 	movhi	r5,33045
81128eec:	8c63883a 	add	r17,r17,r17
81128ef0:	29435984 	addi	r5,r5,3430
81128ef4:	2c45883a 	add	r2,r5,r17
81128ef8:	1440000f 	ldh	r17,0(r2)
81128efc:	00bd1fc4 	movi	r2,-2945
81128f00:	90a4703a 	and	r18,r18,r2
81128f04:	003fd006 	br	81128e48 <__reset+0xfb108e48>
81128f08:	9082000c 	andi	r2,r18,2048
81128f0c:	103fce26 	beq	r2,zero,81128e48 <__reset+0xfb108e48>
81128f10:	8800021e 	bne	r17,zero,81128f1c <__svfscanf_r+0x129c>
81128f14:	94808014 	ori	r18,r18,512
81128f18:	04400204 	movi	r17,8
81128f1c:	9081000c 	andi	r2,r18,1024
81128f20:	10009426 	beq	r2,zero,81129174 <__svfscanf_r+0x14f4>
81128f24:	00be9fc4 	movi	r2,-1409
81128f28:	90a4703a 	and	r18,r18,r2
81128f2c:	003fc606 	br	81128e48 <__reset+0xfb108e48>
81128f30:	9080200c 	andi	r2,r18,128
81128f34:	103fdd26 	beq	r2,zero,81128eac <__reset+0xfb108eac>
81128f38:	9224703a 	and	r18,r18,r8
81128f3c:	003fc206 	br	81128e48 <__reset+0xfb108e48>
81128f40:	9800011e 	bne	r19,zero,81128f48 <__svfscanf_r+0x12c8>
81128f44:	04ffffc4 	movi	r19,-1
81128f48:	8900004c 	andi	r4,r17,1
81128f4c:	20005b1e 	bne	r4,zero,811290bc <__svfscanf_r+0x143c>
81128f50:	8c40040c 	andi	r17,r17,16
81128f54:	88003026 	beq	r17,zero,81129018 <__svfscanf_r+0x1398>
81128f58:	0021883a 	mov	r16,zero
81128f5c:	00000306 	br	81128f6c <__svfscanf_r+0x12ec>
81128f60:	18800003 	ldbu	r2,0(r3)
81128f64:	3885883a 	add	r2,r7,r2
81128f68:	10800043 	ldbu	r2,1(r2)
81128f6c:	1080020c 	andi	r2,r2,8
81128f70:	103ce31e 	bne	r2,zero,81128300 <__reset+0xfb108300>
81128f74:	e0800117 	ldw	r2,4(fp)
81128f78:	18c00044 	addi	r3,r3,1
81128f7c:	84000044 	addi	r16,r16,1
81128f80:	10bfffc4 	addi	r2,r2,-1
81128f84:	e0800115 	stw	r2,4(fp)
81128f88:	e0c00015 	stw	r3,0(fp)
81128f8c:	84fcdc26 	beq	r16,r19,81128300 <__reset+0xfb108300>
81128f90:	00bff316 	blt	zero,r2,81128f60 <__reset+0xfb108f60>
81128f94:	e00b883a 	mov	r5,fp
81128f98:	b009883a 	mov	r4,r22
81128f9c:	1122c5c0 	call	81122c5c <__srefill_r>
81128fa0:	103cd71e 	bne	r2,zero,81128300 <__reset+0xfb108300>
81128fa4:	b9c00017 	ldw	r7,0(r23)
81128fa8:	e0c00017 	ldw	r3,0(fp)
81128fac:	003fec06 	br	81128f60 <__reset+0xfb108f60>
81128fb0:	e00b883a 	mov	r5,fp
81128fb4:	b009883a 	mov	r4,r22
81128fb8:	d980a715 	stw	r6,668(sp)
81128fbc:	d9c0aa15 	stw	r7,680(sp)
81128fc0:	da00a815 	stw	r8,672(sp)
81128fc4:	da40a915 	stw	r9,676(sp)
81128fc8:	dac0a615 	stw	r11,664(sp)
81128fcc:	1122c5c0 	call	81122c5c <__srefill_r>
81128fd0:	d980a717 	ldw	r6,668(sp)
81128fd4:	d9c0aa17 	ldw	r7,680(sp)
81128fd8:	da00a817 	ldw	r8,672(sp)
81128fdc:	da40a917 	ldw	r9,676(sp)
81128fe0:	dac0a617 	ldw	r11,664(sp)
81128fe4:	103fa026 	beq	r2,zero,81128e68 <__reset+0xfb108e68>
81128fe8:	003fb006 	br	81128eac <__reset+0xfb108eac>
81128fec:	8821883a 	mov	r16,r17
81128ff0:	b019883a 	mov	r12,r22
81128ff4:	9823883a 	mov	r17,r19
81128ff8:	182d883a 	mov	r22,r3
81128ffc:	00bfbfc4 	movi	r2,-257
81129000:	a0a8703a 	and	r20,r20,r2
81129004:	003e6706 	br	811289a4 <__reset+0xfb1089a4>
81129008:	000f883a 	mov	r7,zero
8112900c:	003f2806 	br	81128cb0 <__reset+0xfb108cb0>
81129010:	d800a215 	stw	zero,648(sp)
81129014:	003de306 	br	811287a4 <__reset+0xfb1087a4>
81129018:	da009c17 	ldw	r8,624(sp)
8112901c:	9abfffc4 	addi	r10,r19,-1
81129020:	44400017 	ldw	r17,0(r8)
81129024:	44000104 	addi	r16,r8,4
81129028:	880b883a 	mov	r5,r17
8112902c:	8aa9883a 	add	r20,r17,r10
81129030:	00000606 	br	8112904c <__svfscanf_r+0x13cc>
81129034:	e0c00017 	ldw	r3,0(fp)
81129038:	b9000017 	ldw	r4,0(r23)
8112903c:	a80b883a 	mov	r5,r21
81129040:	18800003 	ldbu	r2,0(r3)
81129044:	2085883a 	add	r2,r4,r2
81129048:	10800043 	ldbu	r2,1(r2)
8112904c:	1080020c 	andi	r2,r2,8
81129050:	1000551e 	bne	r2,zero,811291a8 <__svfscanf_r+0x1528>
81129054:	e0800117 	ldw	r2,4(fp)
81129058:	19000044 	addi	r4,r3,1
8112905c:	e1000015 	stw	r4,0(fp)
81129060:	10bfffc4 	addi	r2,r2,-1
81129064:	e0800115 	stw	r2,4(fp)
81129068:	18800003 	ldbu	r2,0(r3)
8112906c:	2d400044 	addi	r21,r5,1
81129070:	a827883a 	mov	r19,r21
81129074:	28800005 	stb	r2,0(r5)
81129078:	2d000626 	beq	r5,r20,81129094 <__svfscanf_r+0x1414>
8112907c:	e0800117 	ldw	r2,4(fp)
81129080:	00bfec16 	blt	zero,r2,81129034 <__reset+0xfb109034>
81129084:	e00b883a 	mov	r5,fp
81129088:	b009883a 	mov	r4,r22
8112908c:	1122c5c0 	call	81122c5c <__srefill_r>
81129090:	103fe826 	beq	r2,zero,81129034 <__reset+0xfb109034>
81129094:	da00a017 	ldw	r8,640(sp)
81129098:	dd009d17 	ldw	r20,628(sp)
8112909c:	9c63c83a 	sub	r17,r19,r17
811290a0:	42000044 	addi	r8,r8,1
811290a4:	98000005 	stb	zero,0(r19)
811290a8:	9465883a 	add	r18,r18,r17
811290ac:	da00a015 	stw	r8,640(sp)
811290b0:	dc009c15 	stw	r16,624(sp)
811290b4:	a00d883a 	mov	r6,r20
811290b8:	003b2f06 	br	81127d78 <__reset+0xfb107d78>
811290bc:	dd409904 	addi	r21,sp,612
811290c0:	8c40040c 	andi	r17,r17,16
811290c4:	01800204 	movi	r6,8
811290c8:	000b883a 	mov	r5,zero
811290cc:	a809883a 	mov	r4,r21
811290d0:	11227e00 	call	811227e0 <memset>
811290d4:	8800401e 	bne	r17,zero,811291d8 <__svfscanf_r+0x1558>
811290d8:	da009c17 	ldw	r8,624(sp)
811290dc:	45000017 	ldw	r20,0(r8)
811290e0:	42000104 	addi	r8,r8,4
811290e4:	da009c15 	stw	r8,624(sp)
811290e8:	000d883a 	mov	r6,zero
811290ec:	3021883a 	mov	r16,r6
811290f0:	dc409f15 	stw	r17,636(sp)
811290f4:	e0800017 	ldw	r2,0(fp)
811290f8:	b8c00017 	ldw	r3,0(r23)
811290fc:	10800003 	ldbu	r2,0(r2)
81129100:	1885883a 	add	r2,r3,r2
81129104:	10800043 	ldbu	r2,1(r2)
81129108:	1080020c 	andi	r2,r2,8
8112910c:	1000011e 	bne	r2,zero,81129114 <__svfscanf_r+0x1494>
81129110:	9800701e 	bne	r19,zero,811292d4 <__svfscanf_r+0x1654>
81129114:	dc409f17 	ldw	r17,636(sp)
81129118:	883cdd1e 	bne	r17,zero,81128490 <__reset+0xfb108490>
8112911c:	a0000015 	stw	zero,0(r20)
81129120:	003cd806 	br	81128484 <__reset+0xfb108484>
81129124:	d9c09e17 	ldw	r7,632(sp)
81129128:	da00a117 	ldw	r8,644(sp)
8112912c:	000d883a 	mov	r6,zero
81129130:	d9400104 	addi	r5,sp,4
81129134:	b009883a 	mov	r4,r22
81129138:	80000005 	stb	zero,0(r16)
8112913c:	403ee83a 	callr	r8
81129140:	88c0080c 	andi	r3,r17,32
81129144:	1800121e 	bne	r3,zero,81129190 <__svfscanf_r+0x1510>
81129148:	88c0010c 	andi	r3,r17,4
8112914c:	18004d26 	beq	r3,zero,81129284 <__svfscanf_r+0x1604>
81129150:	da009c17 	ldw	r8,624(sp)
81129154:	40c00017 	ldw	r3,0(r8)
81129158:	42000104 	addi	r8,r8,4
8112915c:	da009c15 	stw	r8,624(sp)
81129160:	1880000d 	sth	r2,0(r3)
81129164:	da00a017 	ldw	r8,640(sp)
81129168:	42000044 	addi	r8,r8,1
8112916c:	da00a015 	stw	r8,640(sp)
81129170:	003f5906 	br	81128ed8 <__reset+0xfb108ed8>
81129174:	00bf1fc4 	movi	r2,-897
81129178:	90a4703a 	and	r18,r18,r2
8112917c:	38000226 	beq	r7,zero,81129188 <__svfscanf_r+0x1508>
81129180:	39ffffc4 	addi	r7,r7,-1
81129184:	9cc00044 	addi	r19,r19,1
81129188:	a5000044 	addi	r20,r20,1
8112918c:	003f3006 	br	81128e50 <__reset+0xfb108e50>
81129190:	da009c17 	ldw	r8,624(sp)
81129194:	40c00017 	ldw	r3,0(r8)
81129198:	42000104 	addi	r8,r8,4
8112919c:	da009c15 	stw	r8,624(sp)
811291a0:	18800015 	stw	r2,0(r3)
811291a4:	003fef06 	br	81129164 <__reset+0xfb109164>
811291a8:	2827883a 	mov	r19,r5
811291ac:	003fb906 	br	81129094 <__reset+0xfb109094>
811291b0:	01be1fc4 	movi	r6,-1921
811291b4:	a1a8703a 	and	r20,r20,r6
811291b8:	05400044 	movi	r21,1
811291bc:	003de906 	br	81128964 <__reset+0xfb108964>
811291c0:	817fffc7 	ldb	r5,-1(r16)
811291c4:	e00d883a 	mov	r6,fp
811291c8:	b009883a 	mov	r4,r22
811291cc:	843fffc4 	addi	r16,r16,-1
811291d0:	11315f00 	call	811315f0 <_ungetc_r>
811291d4:	003f3c06 	br	81128ec8 <__reset+0xfb108ec8>
811291d8:	dd009b04 	addi	r20,sp,620
811291dc:	003fc206 	br	811290e8 <__reset+0xfb1090e8>
811291e0:	00be1fc4 	movi	r2,-1921
811291e4:	a0a8703a 	and	r20,r20,r2
811291e8:	05800044 	movi	r22,1
811291ec:	003ddd06 	br	81128964 <__reset+0xfb108964>
811291f0:	d8c09f17 	ldw	r3,636(sp)
811291f4:	88e3c83a 	sub	r17,r17,r3
811291f8:	044dc83a 	sub	r6,zero,r17
811291fc:	883e2126 	beq	r17,zero,81128a84 <__reset+0xfb108a84>
81129200:	d88055c4 	addi	r2,sp,343
81129204:	80800136 	bltu	r16,r2,8112920c <__svfscanf_r+0x158c>
81129208:	dc005584 	addi	r16,sp,342
8112920c:	01604574 	movhi	r5,33045
81129210:	29435804 	addi	r5,r5,3424
81129214:	8009883a 	mov	r4,r16
81129218:	1122f700 	call	81122f70 <sprintf>
8112921c:	003e1906 	br	81128a84 <__reset+0xfb108a84>
81129220:	d8c0a517 	ldw	r3,660(sp)
81129224:	000d883a 	mov	r6,zero
81129228:	01c00284 	movi	r7,10
8112922c:	19400044 	addi	r5,r3,1
81129230:	b009883a 	mov	r4,r22
81129234:	11232600 	call	81123260 <_strtol_r>
81129238:	da00a417 	ldw	r8,656(sp)
8112923c:	dc00a517 	ldw	r16,660(sp)
81129240:	120dc83a 	sub	r6,r2,r8
81129244:	003fee06 	br	81129200 <__reset+0xfb109200>
81129248:	da009c17 	ldw	r8,624(sp)
8112924c:	180b883a 	mov	r5,r3
81129250:	8009883a 	mov	r4,r16
81129254:	45000017 	ldw	r20,0(r8)
81129258:	44400104 	addi	r17,r8,4
8112925c:	d8c0a615 	stw	r3,664(sp)
81129260:	112e1f40 	call	8112e1f4 <__fpclassifyd>
81129264:	d8c0a617 	ldw	r3,664(sp)
81129268:	10006426 	beq	r2,zero,811293fc <__svfscanf_r+0x177c>
8112926c:	8009883a 	mov	r4,r16
81129270:	180b883a 	mov	r5,r3
81129274:	11212600 	call	81121260 <__truncdfsf2>
81129278:	a0800015 	stw	r2,0(r20)
8112927c:	dc409c15 	stw	r17,624(sp)
81129280:	003e0f06 	br	81128ac0 <__reset+0xfb108ac0>
81129284:	88c0004c 	andi	r3,r17,1
81129288:	183fc11e 	bne	r3,zero,81129190 <__reset+0xfb109190>
8112928c:	8c40008c 	andi	r17,r17,2
81129290:	883fbf26 	beq	r17,zero,81129190 <__reset+0xfb109190>
81129294:	da00a117 	ldw	r8,644(sp)
81129298:	00a044f4 	movhi	r2,33043
8112929c:	10beea04 	addi	r2,r2,-1112
811292a0:	d9c09e17 	ldw	r7,632(sp)
811292a4:	000d883a 	mov	r6,zero
811292a8:	d9400104 	addi	r5,sp,4
811292ac:	b009883a 	mov	r4,r22
811292b0:	40806226 	beq	r8,r2,8112943c <__svfscanf_r+0x17bc>
811292b4:	11234d80 	call	811234d8 <_strtoll_r>
811292b8:	da009c17 	ldw	r8,624(sp)
811292bc:	41000017 	ldw	r4,0(r8)
811292c0:	42000104 	addi	r8,r8,4
811292c4:	da009c15 	stw	r8,624(sp)
811292c8:	20800015 	stw	r2,0(r4)
811292cc:	20c00115 	stw	r3,4(r4)
811292d0:	003fa406 	br	81129164 <__reset+0xfb109164>
811292d4:	112c6840 	call	8112c684 <__locale_mb_cur_max>
811292d8:	80bca726 	beq	r16,r2,81128578 <__reset+0xfb108578>
811292dc:	e0800017 	ldw	r2,0(fp)
811292e0:	e1000117 	ldw	r4,4(fp)
811292e4:	d8c00104 	addi	r3,sp,4
811292e8:	12000003 	ldbu	r8,0(r2)
811292ec:	213fffc4 	addi	r4,r4,-1
811292f0:	10800044 	addi	r2,r2,1
811292f4:	e1000115 	stw	r4,4(fp)
811292f8:	e0800015 	stw	r2,0(fp)
811292fc:	84400044 	addi	r17,r16,1
81129300:	dd400015 	stw	r21,0(sp)
81129304:	1c21883a 	add	r16,r3,r16
81129308:	b009883a 	mov	r4,r22
8112930c:	880f883a 	mov	r7,r17
81129310:	180d883a 	mov	r6,r3
81129314:	a00b883a 	mov	r5,r20
81129318:	82000005 	stb	r8,0(r16)
8112931c:	112c7400 	call	8112c740 <_mbrtowc_r>
81129320:	013fffc4 	movi	r4,-1
81129324:	113c9426 	beq	r2,r4,81128578 <__reset+0xfb108578>
81129328:	103c881e 	bne	r2,zero,8112854c <__reset+0xfb10854c>
8112932c:	a0000015 	stw	zero,0(r20)
81129330:	0009883a 	mov	r4,zero
81129334:	112c5c40 	call	8112c5c4 <iswspace>
81129338:	10001a26 	beq	r2,zero,811293a4 <__svfscanf_r+0x1724>
8112933c:	8821883a 	mov	r16,r17
81129340:	dc409f17 	ldw	r17,636(sp)
81129344:	803f7426 	beq	r16,zero,81129118 <__reset+0xfb109118>
81129348:	843fffc4 	addi	r16,r16,-1
8112934c:	d9800104 	addi	r6,sp,4
81129350:	342b883a 	add	r21,r6,r16
81129354:	00000106 	br	8112935c <__svfscanf_r+0x16dc>
81129358:	843fffc4 	addi	r16,r16,-1
8112935c:	a9400003 	ldbu	r5,0(r21)
81129360:	e00d883a 	mov	r6,fp
81129364:	b009883a 	mov	r4,r22
81129368:	11315f00 	call	811315f0 <_ungetc_r>
8112936c:	ad7fffc4 	addi	r21,r21,-1
81129370:	803ff91e 	bne	r16,zero,81129358 <__reset+0xfb109358>
81129374:	003f6806 	br	81129118 <__reset+0xfb109118>
81129378:	d9800104 	addi	r6,sp,4
8112937c:	802b883a 	mov	r21,r16
81129380:	343a812e 	bgeu	r6,r16,81127d88 <__reset+0xfb107d88>
81129384:	ad7fffc4 	addi	r21,r21,-1
81129388:	a9400007 	ldb	r5,0(r21)
8112938c:	e00d883a 	mov	r6,fp
81129390:	b009883a 	mov	r4,r22
81129394:	11315f00 	call	811315f0 <_ungetc_r>
81129398:	da000104 	addi	r8,sp,4
8112939c:	457ff91e 	bne	r8,r21,81129384 <__reset+0xfb109384>
811293a0:	003a7906 	br	81127d88 <__reset+0xfb107d88>
811293a4:	da009f17 	ldw	r8,636(sp)
811293a8:	9465883a 	add	r18,r18,r17
811293ac:	9cffffc4 	addi	r19,r19,-1
811293b0:	4000051e 	bne	r8,zero,811293c8 <__svfscanf_r+0x1748>
811293b4:	a5000104 	addi	r20,r20,4
811293b8:	0021883a 	mov	r16,zero
811293bc:	003c6606 	br	81128558 <__reset+0xfb108558>
811293c0:	a1000017 	ldw	r4,0(r20)
811293c4:	003fdb06 	br	81129334 <__reset+0xfb109334>
811293c8:	0021883a 	mov	r16,zero
811293cc:	003c6206 	br	81128558 <__reset+0xfb108558>
811293d0:	d8800104 	addi	r2,sp,4
811293d4:	802b883a 	mov	r21,r16
811293d8:	143a6b2e 	bgeu	r2,r16,81127d88 <__reset+0xfb107d88>
811293dc:	ad7fffc4 	addi	r21,r21,-1
811293e0:	a9400007 	ldb	r5,0(r21)
811293e4:	e00d883a 	mov	r6,fp
811293e8:	b009883a 	mov	r4,r22
811293ec:	11315f00 	call	811315f0 <_ungetc_r>
811293f0:	d8c00104 	addi	r3,sp,4
811293f4:	1d7ff91e 	bne	r3,r21,811293dc <__reset+0xfb1093dc>
811293f8:	003a6306 	br	81127d88 <__reset+0xfb107d88>
811293fc:	0009883a 	mov	r4,zero
81129400:	112e3380 	call	8112e338 <nanf>
81129404:	a0800015 	stw	r2,0(r20)
81129408:	dc409c15 	stw	r17,624(sp)
8112940c:	003dac06 	br	81128ac0 <__reset+0xfb108ac0>
81129410:	d9000104 	addi	r4,sp,4
81129414:	802b883a 	mov	r21,r16
81129418:	243a5b2e 	bgeu	r4,r16,81127d88 <__reset+0xfb107d88>
8112941c:	ad7fffc4 	addi	r21,r21,-1
81129420:	a9400007 	ldb	r5,0(r21)
81129424:	e00d883a 	mov	r6,fp
81129428:	b009883a 	mov	r4,r22
8112942c:	11315f00 	call	811315f0 <_ungetc_r>
81129430:	d9400104 	addi	r5,sp,4
81129434:	2d7ff91e 	bne	r5,r21,8112941c <__reset+0xfb10941c>
81129438:	003a5306 	br	81127d88 <__reset+0xfb107d88>
8112943c:	112fe180 	call	8112fe18 <_strtoull_r>
81129440:	003f9d06 	br	811292b8 <__reset+0xfb1092b8>

81129444 <vfscanf>:
81129444:	00a04574 	movhi	r2,33045
81129448:	defffb04 	addi	sp,sp,-20
8112944c:	108d0f04 	addi	r2,r2,13372
81129450:	de00012e 	bgeu	sp,et,81129458 <vfscanf+0x14>
81129454:	003b68fa 	trap	3
81129458:	dc000215 	stw	r16,8(sp)
8112945c:	14000017 	ldw	r16,0(r2)
81129460:	dc400315 	stw	r17,12(sp)
81129464:	dfc00415 	stw	ra,16(sp)
81129468:	2023883a 	mov	r17,r4
8112946c:	80000826 	beq	r16,zero,81129490 <vfscanf+0x4c>
81129470:	80800e17 	ldw	r2,56(r16)
81129474:	1000061e 	bne	r2,zero,81129490 <vfscanf+0x4c>
81129478:	8009883a 	mov	r4,r16
8112947c:	d9400015 	stw	r5,0(sp)
81129480:	d9800115 	stw	r6,4(sp)
81129484:	112b75c0 	call	8112b75c <__sinit>
81129488:	d9800117 	ldw	r6,4(sp)
8112948c:	d9400017 	ldw	r5,0(sp)
81129490:	300f883a 	mov	r7,r6
81129494:	8009883a 	mov	r4,r16
81129498:	280d883a 	mov	r6,r5
8112949c:	880b883a 	mov	r5,r17
811294a0:	dfc00417 	ldw	ra,16(sp)
811294a4:	dc400317 	ldw	r17,12(sp)
811294a8:	dc000217 	ldw	r16,8(sp)
811294ac:	dec00504 	addi	sp,sp,20
811294b0:	1127c801 	jmpi	81127c80 <__svfscanf_r>

811294b4 <__svfscanf>:
811294b4:	00a04574 	movhi	r2,33045
811294b8:	108d0f04 	addi	r2,r2,13372
811294bc:	300f883a 	mov	r7,r6
811294c0:	280d883a 	mov	r6,r5
811294c4:	200b883a 	mov	r5,r4
811294c8:	11000017 	ldw	r4,0(r2)
811294cc:	1127c801 	jmpi	81127c80 <__svfscanf_r>

811294d0 <_vfscanf_r>:
811294d0:	defffb04 	addi	sp,sp,-20
811294d4:	de00012e 	bgeu	sp,et,811294dc <_vfscanf_r+0xc>
811294d8:	003b68fa 	trap	3
811294dc:	dc000315 	stw	r16,12(sp)
811294e0:	dfc00415 	stw	ra,16(sp)
811294e4:	2021883a 	mov	r16,r4
811294e8:	20000926 	beq	r4,zero,81129510 <_vfscanf_r+0x40>
811294ec:	20800e17 	ldw	r2,56(r4)
811294f0:	1000071e 	bne	r2,zero,81129510 <_vfscanf_r+0x40>
811294f4:	d9400015 	stw	r5,0(sp)
811294f8:	d9800115 	stw	r6,4(sp)
811294fc:	d9c00215 	stw	r7,8(sp)
81129500:	112b75c0 	call	8112b75c <__sinit>
81129504:	d9c00217 	ldw	r7,8(sp)
81129508:	d9800117 	ldw	r6,4(sp)
8112950c:	d9400017 	ldw	r5,0(sp)
81129510:	8009883a 	mov	r4,r16
81129514:	dfc00417 	ldw	ra,16(sp)
81129518:	dc000317 	ldw	r16,12(sp)
8112951c:	dec00504 	addi	sp,sp,20
81129520:	1127c801 	jmpi	81127c80 <__svfscanf_r>

81129524 <__swbuf_r>:
81129524:	defffb04 	addi	sp,sp,-20
81129528:	de00012e 	bgeu	sp,et,81129530 <__swbuf_r+0xc>
8112952c:	003b68fa 	trap	3
81129530:	dcc00315 	stw	r19,12(sp)
81129534:	dc800215 	stw	r18,8(sp)
81129538:	dc000015 	stw	r16,0(sp)
8112953c:	dfc00415 	stw	ra,16(sp)
81129540:	dc400115 	stw	r17,4(sp)
81129544:	2025883a 	mov	r18,r4
81129548:	2827883a 	mov	r19,r5
8112954c:	3021883a 	mov	r16,r6
81129550:	20000226 	beq	r4,zero,8112955c <__swbuf_r+0x38>
81129554:	20800e17 	ldw	r2,56(r4)
81129558:	10004226 	beq	r2,zero,81129664 <__swbuf_r+0x140>
8112955c:	80800617 	ldw	r2,24(r16)
81129560:	8100030b 	ldhu	r4,12(r16)
81129564:	80800215 	stw	r2,8(r16)
81129568:	2080020c 	andi	r2,r4,8
8112956c:	10003626 	beq	r2,zero,81129648 <__swbuf_r+0x124>
81129570:	80c00417 	ldw	r3,16(r16)
81129574:	18003426 	beq	r3,zero,81129648 <__swbuf_r+0x124>
81129578:	2088000c 	andi	r2,r4,8192
8112957c:	9c403fcc 	andi	r17,r19,255
81129580:	10001a26 	beq	r2,zero,811295ec <__swbuf_r+0xc8>
81129584:	80800017 	ldw	r2,0(r16)
81129588:	81000517 	ldw	r4,20(r16)
8112958c:	10c7c83a 	sub	r3,r2,r3
81129590:	1900200e 	bge	r3,r4,81129614 <__swbuf_r+0xf0>
81129594:	18c00044 	addi	r3,r3,1
81129598:	81000217 	ldw	r4,8(r16)
8112959c:	11400044 	addi	r5,r2,1
811295a0:	81400015 	stw	r5,0(r16)
811295a4:	213fffc4 	addi	r4,r4,-1
811295a8:	81000215 	stw	r4,8(r16)
811295ac:	14c00005 	stb	r19,0(r2)
811295b0:	80800517 	ldw	r2,20(r16)
811295b4:	10c01e26 	beq	r2,r3,81129630 <__swbuf_r+0x10c>
811295b8:	8080030b 	ldhu	r2,12(r16)
811295bc:	1080004c 	andi	r2,r2,1
811295c0:	10000226 	beq	r2,zero,811295cc <__swbuf_r+0xa8>
811295c4:	00800284 	movi	r2,10
811295c8:	88801926 	beq	r17,r2,81129630 <__swbuf_r+0x10c>
811295cc:	8805883a 	mov	r2,r17
811295d0:	dfc00417 	ldw	ra,16(sp)
811295d4:	dcc00317 	ldw	r19,12(sp)
811295d8:	dc800217 	ldw	r18,8(sp)
811295dc:	dc400117 	ldw	r17,4(sp)
811295e0:	dc000017 	ldw	r16,0(sp)
811295e4:	dec00504 	addi	sp,sp,20
811295e8:	f800283a 	ret
811295ec:	81401917 	ldw	r5,100(r16)
811295f0:	00b7ffc4 	movi	r2,-8193
811295f4:	21080014 	ori	r4,r4,8192
811295f8:	2884703a 	and	r2,r5,r2
811295fc:	80801915 	stw	r2,100(r16)
81129600:	80800017 	ldw	r2,0(r16)
81129604:	8100030d 	sth	r4,12(r16)
81129608:	81000517 	ldw	r4,20(r16)
8112960c:	10c7c83a 	sub	r3,r2,r3
81129610:	193fe016 	blt	r3,r4,81129594 <__reset+0xfb109594>
81129614:	800b883a 	mov	r5,r16
81129618:	9009883a 	mov	r4,r18
8112961c:	112b3600 	call	8112b360 <_fflush_r>
81129620:	1000071e 	bne	r2,zero,81129640 <__swbuf_r+0x11c>
81129624:	80800017 	ldw	r2,0(r16)
81129628:	00c00044 	movi	r3,1
8112962c:	003fda06 	br	81129598 <__reset+0xfb109598>
81129630:	800b883a 	mov	r5,r16
81129634:	9009883a 	mov	r4,r18
81129638:	112b3600 	call	8112b360 <_fflush_r>
8112963c:	103fe326 	beq	r2,zero,811295cc <__reset+0xfb1095cc>
81129640:	00bfffc4 	movi	r2,-1
81129644:	003fe206 	br	811295d0 <__reset+0xfb1095d0>
81129648:	800b883a 	mov	r5,r16
8112964c:	9009883a 	mov	r4,r18
81129650:	11296ec0 	call	811296ec <__swsetup_r>
81129654:	103ffa1e 	bne	r2,zero,81129640 <__reset+0xfb109640>
81129658:	8100030b 	ldhu	r4,12(r16)
8112965c:	80c00417 	ldw	r3,16(r16)
81129660:	003fc506 	br	81129578 <__reset+0xfb109578>
81129664:	112b75c0 	call	8112b75c <__sinit>
81129668:	003fbc06 	br	8112955c <__reset+0xfb10955c>

8112966c <__swbuf>:
8112966c:	00a04574 	movhi	r2,33045
81129670:	108d0f04 	addi	r2,r2,13372
81129674:	280d883a 	mov	r6,r5
81129678:	200b883a 	mov	r5,r4
8112967c:	11000017 	ldw	r4,0(r2)
81129680:	11295241 	jmpi	81129524 <__swbuf_r>

81129684 <_write_r>:
81129684:	defffd04 	addi	sp,sp,-12
81129688:	de00012e 	bgeu	sp,et,81129690 <_write_r+0xc>
8112968c:	003b68fa 	trap	3
81129690:	2805883a 	mov	r2,r5
81129694:	dc000015 	stw	r16,0(sp)
81129698:	04204574 	movhi	r16,33045
8112969c:	dc400115 	stw	r17,4(sp)
811296a0:	300b883a 	mov	r5,r6
811296a4:	840d8204 	addi	r16,r16,13832
811296a8:	2023883a 	mov	r17,r4
811296ac:	380d883a 	mov	r6,r7
811296b0:	1009883a 	mov	r4,r2
811296b4:	dfc00215 	stw	ra,8(sp)
811296b8:	80000015 	stw	zero,0(r16)
811296bc:	1137e940 	call	81137e94 <write>
811296c0:	00ffffc4 	movi	r3,-1
811296c4:	10c00526 	beq	r2,r3,811296dc <_write_r+0x58>
811296c8:	dfc00217 	ldw	ra,8(sp)
811296cc:	dc400117 	ldw	r17,4(sp)
811296d0:	dc000017 	ldw	r16,0(sp)
811296d4:	dec00304 	addi	sp,sp,12
811296d8:	f800283a 	ret
811296dc:	80c00017 	ldw	r3,0(r16)
811296e0:	183ff926 	beq	r3,zero,811296c8 <__reset+0xfb1096c8>
811296e4:	88c00015 	stw	r3,0(r17)
811296e8:	003ff706 	br	811296c8 <__reset+0xfb1096c8>

811296ec <__swsetup_r>:
811296ec:	00a04574 	movhi	r2,33045
811296f0:	defffd04 	addi	sp,sp,-12
811296f4:	108d0f04 	addi	r2,r2,13372
811296f8:	de00012e 	bgeu	sp,et,81129700 <__swsetup_r+0x14>
811296fc:	003b68fa 	trap	3
81129700:	dc400115 	stw	r17,4(sp)
81129704:	2023883a 	mov	r17,r4
81129708:	11000017 	ldw	r4,0(r2)
8112970c:	dc000015 	stw	r16,0(sp)
81129710:	dfc00215 	stw	ra,8(sp)
81129714:	2821883a 	mov	r16,r5
81129718:	20000226 	beq	r4,zero,81129724 <__swsetup_r+0x38>
8112971c:	20800e17 	ldw	r2,56(r4)
81129720:	10003126 	beq	r2,zero,811297e8 <__swsetup_r+0xfc>
81129724:	8080030b 	ldhu	r2,12(r16)
81129728:	10c0020c 	andi	r3,r2,8
8112972c:	1009883a 	mov	r4,r2
81129730:	18000f26 	beq	r3,zero,81129770 <__swsetup_r+0x84>
81129734:	80c00417 	ldw	r3,16(r16)
81129738:	18001526 	beq	r3,zero,81129790 <__swsetup_r+0xa4>
8112973c:	1100004c 	andi	r4,r2,1
81129740:	20001c1e 	bne	r4,zero,811297b4 <__swsetup_r+0xc8>
81129744:	1080008c 	andi	r2,r2,2
81129748:	1000291e 	bne	r2,zero,811297f0 <__swsetup_r+0x104>
8112974c:	80800517 	ldw	r2,20(r16)
81129750:	80800215 	stw	r2,8(r16)
81129754:	18001c26 	beq	r3,zero,811297c8 <__swsetup_r+0xdc>
81129758:	0005883a 	mov	r2,zero
8112975c:	dfc00217 	ldw	ra,8(sp)
81129760:	dc400117 	ldw	r17,4(sp)
81129764:	dc000017 	ldw	r16,0(sp)
81129768:	dec00304 	addi	sp,sp,12
8112976c:	f800283a 	ret
81129770:	2080040c 	andi	r2,r4,16
81129774:	10002e26 	beq	r2,zero,81129830 <__swsetup_r+0x144>
81129778:	2080010c 	andi	r2,r4,4
8112977c:	10001e1e 	bne	r2,zero,811297f8 <__swsetup_r+0x10c>
81129780:	80c00417 	ldw	r3,16(r16)
81129784:	20800214 	ori	r2,r4,8
81129788:	8080030d 	sth	r2,12(r16)
8112978c:	183feb1e 	bne	r3,zero,8112973c <__reset+0xfb10973c>
81129790:	1100a00c 	andi	r4,r2,640
81129794:	01408004 	movi	r5,512
81129798:	217fe826 	beq	r4,r5,8112973c <__reset+0xfb10973c>
8112979c:	800b883a 	mov	r5,r16
811297a0:	8809883a 	mov	r4,r17
811297a4:	1121cb80 	call	81121cb8 <__smakebuf_r>
811297a8:	8080030b 	ldhu	r2,12(r16)
811297ac:	80c00417 	ldw	r3,16(r16)
811297b0:	003fe206 	br	8112973c <__reset+0xfb10973c>
811297b4:	80800517 	ldw	r2,20(r16)
811297b8:	80000215 	stw	zero,8(r16)
811297bc:	0085c83a 	sub	r2,zero,r2
811297c0:	80800615 	stw	r2,24(r16)
811297c4:	183fe41e 	bne	r3,zero,81129758 <__reset+0xfb109758>
811297c8:	80c0030b 	ldhu	r3,12(r16)
811297cc:	0005883a 	mov	r2,zero
811297d0:	1900200c 	andi	r4,r3,128
811297d4:	203fe126 	beq	r4,zero,8112975c <__reset+0xfb10975c>
811297d8:	18c01014 	ori	r3,r3,64
811297dc:	80c0030d 	sth	r3,12(r16)
811297e0:	00bfffc4 	movi	r2,-1
811297e4:	003fdd06 	br	8112975c <__reset+0xfb10975c>
811297e8:	112b75c0 	call	8112b75c <__sinit>
811297ec:	003fcd06 	br	81129724 <__reset+0xfb109724>
811297f0:	0005883a 	mov	r2,zero
811297f4:	003fd606 	br	81129750 <__reset+0xfb109750>
811297f8:	81400c17 	ldw	r5,48(r16)
811297fc:	28000626 	beq	r5,zero,81129818 <__swsetup_r+0x12c>
81129800:	80801004 	addi	r2,r16,64
81129804:	28800326 	beq	r5,r2,81129814 <__swsetup_r+0x128>
81129808:	8809883a 	mov	r4,r17
8112980c:	112bbf40 	call	8112bbf4 <_free_r>
81129810:	8100030b 	ldhu	r4,12(r16)
81129814:	80000c15 	stw	zero,48(r16)
81129818:	80c00417 	ldw	r3,16(r16)
8112981c:	00bff6c4 	movi	r2,-37
81129820:	1108703a 	and	r4,r2,r4
81129824:	80000115 	stw	zero,4(r16)
81129828:	80c00015 	stw	r3,0(r16)
8112982c:	003fd506 	br	81129784 <__reset+0xfb109784>
81129830:	00800244 	movi	r2,9
81129834:	88800015 	stw	r2,0(r17)
81129838:	20801014 	ori	r2,r4,64
8112983c:	8080030d 	sth	r2,12(r16)
81129840:	00bfffc4 	movi	r2,-1
81129844:	003fc506 	br	8112975c <__reset+0xfb10975c>

81129848 <_close_r>:
81129848:	defffd04 	addi	sp,sp,-12
8112984c:	de00012e 	bgeu	sp,et,81129854 <_close_r+0xc>
81129850:	003b68fa 	trap	3
81129854:	dc000015 	stw	r16,0(sp)
81129858:	04204574 	movhi	r16,33045
8112985c:	dc400115 	stw	r17,4(sp)
81129860:	840d8204 	addi	r16,r16,13832
81129864:	2023883a 	mov	r17,r4
81129868:	2809883a 	mov	r4,r5
8112986c:	dfc00215 	stw	ra,8(sp)
81129870:	80000015 	stw	zero,0(r16)
81129874:	11364140 	call	81136414 <close>
81129878:	00ffffc4 	movi	r3,-1
8112987c:	10c00526 	beq	r2,r3,81129894 <_close_r+0x4c>
81129880:	dfc00217 	ldw	ra,8(sp)
81129884:	dc400117 	ldw	r17,4(sp)
81129888:	dc000017 	ldw	r16,0(sp)
8112988c:	dec00304 	addi	sp,sp,12
81129890:	f800283a 	ret
81129894:	80c00017 	ldw	r3,0(r16)
81129898:	183ff926 	beq	r3,zero,81129880 <__reset+0xfb109880>
8112989c:	88c00015 	stw	r3,0(r17)
811298a0:	003ff706 	br	81129880 <__reset+0xfb109880>

811298a4 <quorem>:
811298a4:	defff704 	addi	sp,sp,-36
811298a8:	de00012e 	bgeu	sp,et,811298b0 <quorem+0xc>
811298ac:	003b68fa 	trap	3
811298b0:	dc800215 	stw	r18,8(sp)
811298b4:	20800417 	ldw	r2,16(r4)
811298b8:	2c800417 	ldw	r18,16(r5)
811298bc:	dfc00815 	stw	ra,32(sp)
811298c0:	ddc00715 	stw	r23,28(sp)
811298c4:	dd800615 	stw	r22,24(sp)
811298c8:	dd400515 	stw	r21,20(sp)
811298cc:	dd000415 	stw	r20,16(sp)
811298d0:	dcc00315 	stw	r19,12(sp)
811298d4:	dc400115 	stw	r17,4(sp)
811298d8:	dc000015 	stw	r16,0(sp)
811298dc:	14807116 	blt	r2,r18,81129aa4 <quorem+0x200>
811298e0:	94bfffc4 	addi	r18,r18,-1
811298e4:	94ad883a 	add	r22,r18,r18
811298e8:	b5ad883a 	add	r22,r22,r22
811298ec:	2c400504 	addi	r17,r5,20
811298f0:	8da9883a 	add	r20,r17,r22
811298f4:	25400504 	addi	r21,r4,20
811298f8:	282f883a 	mov	r23,r5
811298fc:	adad883a 	add	r22,r21,r22
81129900:	a1400017 	ldw	r5,0(r20)
81129904:	2021883a 	mov	r16,r4
81129908:	b1000017 	ldw	r4,0(r22)
8112990c:	29400044 	addi	r5,r5,1
81129910:	1134c180 	call	81134c18 <__udivsi3>
81129914:	1027883a 	mov	r19,r2
81129918:	10002c26 	beq	r2,zero,811299cc <quorem+0x128>
8112991c:	a813883a 	mov	r9,r21
81129920:	880b883a 	mov	r5,r17
81129924:	0009883a 	mov	r4,zero
81129928:	000d883a 	mov	r6,zero
8112992c:	2a000017 	ldw	r8,0(r5)
81129930:	49c00017 	ldw	r7,0(r9)
81129934:	29400104 	addi	r5,r5,4
81129938:	40bfffcc 	andi	r2,r8,65535
8112993c:	14c5383a 	mul	r2,r2,r19
81129940:	4010d43a 	srli	r8,r8,16
81129944:	38ffffcc 	andi	r3,r7,65535
81129948:	1105883a 	add	r2,r2,r4
8112994c:	1008d43a 	srli	r4,r2,16
81129950:	44d1383a 	mul	r8,r8,r19
81129954:	198d883a 	add	r6,r3,r6
81129958:	10ffffcc 	andi	r3,r2,65535
8112995c:	30c7c83a 	sub	r3,r6,r3
81129960:	380ed43a 	srli	r7,r7,16
81129964:	4105883a 	add	r2,r8,r4
81129968:	180dd43a 	srai	r6,r3,16
8112996c:	113fffcc 	andi	r4,r2,65535
81129970:	390fc83a 	sub	r7,r7,r4
81129974:	398d883a 	add	r6,r7,r6
81129978:	300e943a 	slli	r7,r6,16
8112997c:	18ffffcc 	andi	r3,r3,65535
81129980:	1008d43a 	srli	r4,r2,16
81129984:	38ceb03a 	or	r7,r7,r3
81129988:	49c00015 	stw	r7,0(r9)
8112998c:	300dd43a 	srai	r6,r6,16
81129990:	4a400104 	addi	r9,r9,4
81129994:	a17fe52e 	bgeu	r20,r5,8112992c <__reset+0xfb10992c>
81129998:	b0800017 	ldw	r2,0(r22)
8112999c:	10000b1e 	bne	r2,zero,811299cc <quorem+0x128>
811299a0:	b0bfff04 	addi	r2,r22,-4
811299a4:	a880082e 	bgeu	r21,r2,811299c8 <quorem+0x124>
811299a8:	b0ffff17 	ldw	r3,-4(r22)
811299ac:	18000326 	beq	r3,zero,811299bc <quorem+0x118>
811299b0:	00000506 	br	811299c8 <quorem+0x124>
811299b4:	10c00017 	ldw	r3,0(r2)
811299b8:	1800031e 	bne	r3,zero,811299c8 <quorem+0x124>
811299bc:	10bfff04 	addi	r2,r2,-4
811299c0:	94bfffc4 	addi	r18,r18,-1
811299c4:	a8bffb36 	bltu	r21,r2,811299b4 <__reset+0xfb1099b4>
811299c8:	84800415 	stw	r18,16(r16)
811299cc:	b80b883a 	mov	r5,r23
811299d0:	8009883a 	mov	r4,r16
811299d4:	112d4c40 	call	8112d4c4 <__mcmp>
811299d8:	10002616 	blt	r2,zero,81129a74 <quorem+0x1d0>
811299dc:	9cc00044 	addi	r19,r19,1
811299e0:	a805883a 	mov	r2,r21
811299e4:	000b883a 	mov	r5,zero
811299e8:	11000017 	ldw	r4,0(r2)
811299ec:	89800017 	ldw	r6,0(r17)
811299f0:	10800104 	addi	r2,r2,4
811299f4:	20ffffcc 	andi	r3,r4,65535
811299f8:	194b883a 	add	r5,r3,r5
811299fc:	30ffffcc 	andi	r3,r6,65535
81129a00:	28c7c83a 	sub	r3,r5,r3
81129a04:	300cd43a 	srli	r6,r6,16
81129a08:	2008d43a 	srli	r4,r4,16
81129a0c:	180bd43a 	srai	r5,r3,16
81129a10:	18ffffcc 	andi	r3,r3,65535
81129a14:	2189c83a 	sub	r4,r4,r6
81129a18:	2149883a 	add	r4,r4,r5
81129a1c:	200c943a 	slli	r6,r4,16
81129a20:	8c400104 	addi	r17,r17,4
81129a24:	200bd43a 	srai	r5,r4,16
81129a28:	30c6b03a 	or	r3,r6,r3
81129a2c:	10ffff15 	stw	r3,-4(r2)
81129a30:	a47fed2e 	bgeu	r20,r17,811299e8 <__reset+0xfb1099e8>
81129a34:	9485883a 	add	r2,r18,r18
81129a38:	1085883a 	add	r2,r2,r2
81129a3c:	a887883a 	add	r3,r21,r2
81129a40:	18800017 	ldw	r2,0(r3)
81129a44:	10000b1e 	bne	r2,zero,81129a74 <quorem+0x1d0>
81129a48:	18bfff04 	addi	r2,r3,-4
81129a4c:	a880082e 	bgeu	r21,r2,81129a70 <quorem+0x1cc>
81129a50:	18ffff17 	ldw	r3,-4(r3)
81129a54:	18000326 	beq	r3,zero,81129a64 <quorem+0x1c0>
81129a58:	00000506 	br	81129a70 <quorem+0x1cc>
81129a5c:	10c00017 	ldw	r3,0(r2)
81129a60:	1800031e 	bne	r3,zero,81129a70 <quorem+0x1cc>
81129a64:	10bfff04 	addi	r2,r2,-4
81129a68:	94bfffc4 	addi	r18,r18,-1
81129a6c:	a8bffb36 	bltu	r21,r2,81129a5c <__reset+0xfb109a5c>
81129a70:	84800415 	stw	r18,16(r16)
81129a74:	9805883a 	mov	r2,r19
81129a78:	dfc00817 	ldw	ra,32(sp)
81129a7c:	ddc00717 	ldw	r23,28(sp)
81129a80:	dd800617 	ldw	r22,24(sp)
81129a84:	dd400517 	ldw	r21,20(sp)
81129a88:	dd000417 	ldw	r20,16(sp)
81129a8c:	dcc00317 	ldw	r19,12(sp)
81129a90:	dc800217 	ldw	r18,8(sp)
81129a94:	dc400117 	ldw	r17,4(sp)
81129a98:	dc000017 	ldw	r16,0(sp)
81129a9c:	dec00904 	addi	sp,sp,36
81129aa0:	f800283a 	ret
81129aa4:	0005883a 	mov	r2,zero
81129aa8:	003ff306 	br	81129a78 <__reset+0xfb109a78>

81129aac <_dtoa_r>:
81129aac:	deffde04 	addi	sp,sp,-136
81129ab0:	de00012e 	bgeu	sp,et,81129ab8 <_dtoa_r+0xc>
81129ab4:	003b68fa 	trap	3
81129ab8:	20801017 	ldw	r2,64(r4)
81129abc:	df002015 	stw	fp,128(sp)
81129ac0:	dcc01b15 	stw	r19,108(sp)
81129ac4:	dc801a15 	stw	r18,104(sp)
81129ac8:	dc401915 	stw	r17,100(sp)
81129acc:	dc001815 	stw	r16,96(sp)
81129ad0:	dfc02115 	stw	ra,132(sp)
81129ad4:	ddc01f15 	stw	r23,124(sp)
81129ad8:	dd801e15 	stw	r22,120(sp)
81129adc:	dd401d15 	stw	r21,116(sp)
81129ae0:	dd001c15 	stw	r20,112(sp)
81129ae4:	d9c00315 	stw	r7,12(sp)
81129ae8:	2039883a 	mov	fp,r4
81129aec:	3023883a 	mov	r17,r6
81129af0:	2825883a 	mov	r18,r5
81129af4:	dc002417 	ldw	r16,144(sp)
81129af8:	3027883a 	mov	r19,r6
81129afc:	10000826 	beq	r2,zero,81129b20 <_dtoa_r+0x74>
81129b00:	21801117 	ldw	r6,68(r4)
81129b04:	00c00044 	movi	r3,1
81129b08:	100b883a 	mov	r5,r2
81129b0c:	1986983a 	sll	r3,r3,r6
81129b10:	11800115 	stw	r6,4(r2)
81129b14:	10c00215 	stw	r3,8(r2)
81129b18:	112cc740 	call	8112cc74 <_Bfree>
81129b1c:	e0001015 	stw	zero,64(fp)
81129b20:	88002e16 	blt	r17,zero,81129bdc <_dtoa_r+0x130>
81129b24:	80000015 	stw	zero,0(r16)
81129b28:	889ffc2c 	andhi	r2,r17,32752
81129b2c:	00dffc34 	movhi	r3,32752
81129b30:	10c01c26 	beq	r2,r3,81129ba4 <_dtoa_r+0xf8>
81129b34:	000d883a 	mov	r6,zero
81129b38:	000f883a 	mov	r7,zero
81129b3c:	9009883a 	mov	r4,r18
81129b40:	980b883a 	mov	r5,r19
81129b44:	11360740 	call	81136074 <__eqdf2>
81129b48:	10002b1e 	bne	r2,zero,81129bf8 <_dtoa_r+0x14c>
81129b4c:	d9c02317 	ldw	r7,140(sp)
81129b50:	00800044 	movi	r2,1
81129b54:	38800015 	stw	r2,0(r7)
81129b58:	d8802517 	ldw	r2,148(sp)
81129b5c:	10019e26 	beq	r2,zero,8112a1d8 <_dtoa_r+0x72c>
81129b60:	d8c02517 	ldw	r3,148(sp)
81129b64:	00a04574 	movhi	r2,33045
81129b68:	10834744 	addi	r2,r2,3357
81129b6c:	18800015 	stw	r2,0(r3)
81129b70:	10bfffc4 	addi	r2,r2,-1
81129b74:	dfc02117 	ldw	ra,132(sp)
81129b78:	df002017 	ldw	fp,128(sp)
81129b7c:	ddc01f17 	ldw	r23,124(sp)
81129b80:	dd801e17 	ldw	r22,120(sp)
81129b84:	dd401d17 	ldw	r21,116(sp)
81129b88:	dd001c17 	ldw	r20,112(sp)
81129b8c:	dcc01b17 	ldw	r19,108(sp)
81129b90:	dc801a17 	ldw	r18,104(sp)
81129b94:	dc401917 	ldw	r17,100(sp)
81129b98:	dc001817 	ldw	r16,96(sp)
81129b9c:	dec02204 	addi	sp,sp,136
81129ba0:	f800283a 	ret
81129ba4:	d8c02317 	ldw	r3,140(sp)
81129ba8:	0089c3c4 	movi	r2,9999
81129bac:	18800015 	stw	r2,0(r3)
81129bb0:	90017726 	beq	r18,zero,8112a190 <_dtoa_r+0x6e4>
81129bb4:	00a04574 	movhi	r2,33045
81129bb8:	10836504 	addi	r2,r2,3476
81129bbc:	d9002517 	ldw	r4,148(sp)
81129bc0:	203fec26 	beq	r4,zero,81129b74 <__reset+0xfb109b74>
81129bc4:	10c000c7 	ldb	r3,3(r2)
81129bc8:	1801781e 	bne	r3,zero,8112a1ac <_dtoa_r+0x700>
81129bcc:	10c000c4 	addi	r3,r2,3
81129bd0:	d9802517 	ldw	r6,148(sp)
81129bd4:	30c00015 	stw	r3,0(r6)
81129bd8:	003fe606 	br	81129b74 <__reset+0xfb109b74>
81129bdc:	04e00034 	movhi	r19,32768
81129be0:	9cffffc4 	addi	r19,r19,-1
81129be4:	00800044 	movi	r2,1
81129be8:	8ce6703a 	and	r19,r17,r19
81129bec:	80800015 	stw	r2,0(r16)
81129bf0:	9823883a 	mov	r17,r19
81129bf4:	003fcc06 	br	81129b28 <__reset+0xfb109b28>
81129bf8:	d8800204 	addi	r2,sp,8
81129bfc:	d8800015 	stw	r2,0(sp)
81129c00:	d9c00104 	addi	r7,sp,4
81129c04:	900b883a 	mov	r5,r18
81129c08:	980d883a 	mov	r6,r19
81129c0c:	e009883a 	mov	r4,fp
81129c10:	8820d53a 	srli	r16,r17,20
81129c14:	112d8a00 	call	8112d8a0 <__d2b>
81129c18:	d8800915 	stw	r2,36(sp)
81129c1c:	8001651e 	bne	r16,zero,8112a1b4 <_dtoa_r+0x708>
81129c20:	dd800217 	ldw	r22,8(sp)
81129c24:	dc000117 	ldw	r16,4(sp)
81129c28:	00800804 	movi	r2,32
81129c2c:	b421883a 	add	r16,r22,r16
81129c30:	80c10c84 	addi	r3,r16,1074
81129c34:	10c2d10e 	bge	r2,r3,8112a77c <_dtoa_r+0xcd0>
81129c38:	00801004 	movi	r2,64
81129c3c:	81010484 	addi	r4,r16,1042
81129c40:	10c7c83a 	sub	r3,r2,r3
81129c44:	9108d83a 	srl	r4,r18,r4
81129c48:	88e2983a 	sll	r17,r17,r3
81129c4c:	2448b03a 	or	r4,r4,r17
81129c50:	11361f00 	call	811361f0 <__floatunsidf>
81129c54:	017f8434 	movhi	r5,65040
81129c58:	01800044 	movi	r6,1
81129c5c:	1009883a 	mov	r4,r2
81129c60:	194b883a 	add	r5,r3,r5
81129c64:	843fffc4 	addi	r16,r16,-1
81129c68:	d9801115 	stw	r6,68(sp)
81129c6c:	000d883a 	mov	r6,zero
81129c70:	01cffe34 	movhi	r7,16376
81129c74:	11206e00 	call	811206e0 <__subdf3>
81129c78:	0198dbf4 	movhi	r6,25455
81129c7c:	01cff4f4 	movhi	r7,16339
81129c80:	3190d844 	addi	r6,r6,17249
81129c84:	39e1e9c4 	addi	r7,r7,-30809
81129c88:	1009883a 	mov	r4,r2
81129c8c:	180b883a 	mov	r5,r3
81129c90:	111ffc00 	call	8111ffc0 <__muldf3>
81129c94:	01a2d874 	movhi	r6,35681
81129c98:	01cff1f4 	movhi	r7,16327
81129c9c:	31b22cc4 	addi	r6,r6,-14157
81129ca0:	39e28a04 	addi	r7,r7,-30168
81129ca4:	180b883a 	mov	r5,r3
81129ca8:	1009883a 	mov	r4,r2
81129cac:	1134ed00 	call	81134ed0 <__adddf3>
81129cb0:	8009883a 	mov	r4,r16
81129cb4:	1029883a 	mov	r20,r2
81129cb8:	1823883a 	mov	r17,r3
81129cbc:	11210640 	call	81121064 <__floatsidf>
81129cc0:	019427f4 	movhi	r6,20639
81129cc4:	01cff4f4 	movhi	r7,16339
81129cc8:	319e7ec4 	addi	r6,r6,31227
81129ccc:	39d104c4 	addi	r7,r7,17427
81129cd0:	1009883a 	mov	r4,r2
81129cd4:	180b883a 	mov	r5,r3
81129cd8:	111ffc00 	call	8111ffc0 <__muldf3>
81129cdc:	100d883a 	mov	r6,r2
81129ce0:	180f883a 	mov	r7,r3
81129ce4:	a009883a 	mov	r4,r20
81129ce8:	880b883a 	mov	r5,r17
81129cec:	1134ed00 	call	81134ed0 <__adddf3>
81129cf0:	1009883a 	mov	r4,r2
81129cf4:	180b883a 	mov	r5,r3
81129cf8:	1029883a 	mov	r20,r2
81129cfc:	1823883a 	mov	r17,r3
81129d00:	1120fe40 	call	81120fe4 <__fixdfsi>
81129d04:	000d883a 	mov	r6,zero
81129d08:	000f883a 	mov	r7,zero
81129d0c:	a009883a 	mov	r4,r20
81129d10:	880b883a 	mov	r5,r17
81129d14:	d8800515 	stw	r2,20(sp)
81129d18:	11360fc0 	call	811360fc <__ledf2>
81129d1c:	10028716 	blt	r2,zero,8112a73c <_dtoa_r+0xc90>
81129d20:	d8c00517 	ldw	r3,20(sp)
81129d24:	00800584 	movi	r2,22
81129d28:	10c27536 	bltu	r2,r3,8112a700 <_dtoa_r+0xc54>
81129d2c:	180490fa 	slli	r2,r3,3
81129d30:	00e04574 	movhi	r3,33045
81129d34:	18c38004 	addi	r3,r3,3584
81129d38:	1885883a 	add	r2,r3,r2
81129d3c:	11000017 	ldw	r4,0(r2)
81129d40:	11400117 	ldw	r5,4(r2)
81129d44:	900d883a 	mov	r6,r18
81129d48:	980f883a 	mov	r7,r19
81129d4c:	111fee40 	call	8111fee4 <__gedf2>
81129d50:	00828d0e 	bge	zero,r2,8112a788 <_dtoa_r+0xcdc>
81129d54:	d9000517 	ldw	r4,20(sp)
81129d58:	d8000e15 	stw	zero,56(sp)
81129d5c:	213fffc4 	addi	r4,r4,-1
81129d60:	d9000515 	stw	r4,20(sp)
81129d64:	b42dc83a 	sub	r22,r22,r16
81129d68:	b5bfffc4 	addi	r22,r22,-1
81129d6c:	b0026f16 	blt	r22,zero,8112a72c <_dtoa_r+0xc80>
81129d70:	d8000815 	stw	zero,32(sp)
81129d74:	d9c00517 	ldw	r7,20(sp)
81129d78:	38026416 	blt	r7,zero,8112a70c <_dtoa_r+0xc60>
81129d7c:	b1ed883a 	add	r22,r22,r7
81129d80:	d9c00d15 	stw	r7,52(sp)
81129d84:	d8000a15 	stw	zero,40(sp)
81129d88:	d9800317 	ldw	r6,12(sp)
81129d8c:	00800244 	movi	r2,9
81129d90:	11811436 	bltu	r2,r6,8112a1e4 <_dtoa_r+0x738>
81129d94:	00800144 	movi	r2,5
81129d98:	1184e10e 	bge	r2,r6,8112b120 <_dtoa_r+0x1674>
81129d9c:	31bfff04 	addi	r6,r6,-4
81129da0:	d9800315 	stw	r6,12(sp)
81129da4:	0023883a 	mov	r17,zero
81129da8:	d9800317 	ldw	r6,12(sp)
81129dac:	008000c4 	movi	r2,3
81129db0:	30836726 	beq	r6,r2,8112ab50 <_dtoa_r+0x10a4>
81129db4:	1183410e 	bge	r2,r6,8112aabc <_dtoa_r+0x1010>
81129db8:	d9c00317 	ldw	r7,12(sp)
81129dbc:	00800104 	movi	r2,4
81129dc0:	38827c26 	beq	r7,r2,8112a7b4 <_dtoa_r+0xd08>
81129dc4:	00800144 	movi	r2,5
81129dc8:	3884c41e 	bne	r7,r2,8112b0dc <_dtoa_r+0x1630>
81129dcc:	00800044 	movi	r2,1
81129dd0:	d8800b15 	stw	r2,44(sp)
81129dd4:	d8c00517 	ldw	r3,20(sp)
81129dd8:	d9002217 	ldw	r4,136(sp)
81129ddc:	1907883a 	add	r3,r3,r4
81129de0:	19800044 	addi	r6,r3,1
81129de4:	d8c00c15 	stw	r3,48(sp)
81129de8:	d9800615 	stw	r6,24(sp)
81129dec:	0183a40e 	bge	zero,r6,8112ac80 <_dtoa_r+0x11d4>
81129df0:	d9800617 	ldw	r6,24(sp)
81129df4:	3021883a 	mov	r16,r6
81129df8:	e0001115 	stw	zero,68(fp)
81129dfc:	008005c4 	movi	r2,23
81129e00:	1184c92e 	bgeu	r2,r6,8112b128 <_dtoa_r+0x167c>
81129e04:	00c00044 	movi	r3,1
81129e08:	00800104 	movi	r2,4
81129e0c:	1085883a 	add	r2,r2,r2
81129e10:	11000504 	addi	r4,r2,20
81129e14:	180b883a 	mov	r5,r3
81129e18:	18c00044 	addi	r3,r3,1
81129e1c:	313ffb2e 	bgeu	r6,r4,81129e0c <__reset+0xfb109e0c>
81129e20:	e1401115 	stw	r5,68(fp)
81129e24:	e009883a 	mov	r4,fp
81129e28:	112cbc40 	call	8112cbc4 <_Balloc>
81129e2c:	d8800715 	stw	r2,28(sp)
81129e30:	e0801015 	stw	r2,64(fp)
81129e34:	00800384 	movi	r2,14
81129e38:	1400f736 	bltu	r2,r16,8112a218 <_dtoa_r+0x76c>
81129e3c:	8800f626 	beq	r17,zero,8112a218 <_dtoa_r+0x76c>
81129e40:	d9c00517 	ldw	r7,20(sp)
81129e44:	01c39a0e 	bge	zero,r7,8112acb0 <_dtoa_r+0x1204>
81129e48:	388003cc 	andi	r2,r7,15
81129e4c:	100490fa 	slli	r2,r2,3
81129e50:	382bd13a 	srai	r21,r7,4
81129e54:	00e04574 	movhi	r3,33045
81129e58:	18c38004 	addi	r3,r3,3584
81129e5c:	1885883a 	add	r2,r3,r2
81129e60:	a8c0040c 	andi	r3,r21,16
81129e64:	12400017 	ldw	r9,0(r2)
81129e68:	12000117 	ldw	r8,4(r2)
81129e6c:	18037926 	beq	r3,zero,8112ac54 <_dtoa_r+0x11a8>
81129e70:	00a04574 	movhi	r2,33045
81129e74:	10837604 	addi	r2,r2,3544
81129e78:	11800817 	ldw	r6,32(r2)
81129e7c:	11c00917 	ldw	r7,36(r2)
81129e80:	9009883a 	mov	r4,r18
81129e84:	980b883a 	mov	r5,r19
81129e88:	da001715 	stw	r8,92(sp)
81129e8c:	da401615 	stw	r9,88(sp)
81129e90:	11357840 	call	81135784 <__divdf3>
81129e94:	da001717 	ldw	r8,92(sp)
81129e98:	da401617 	ldw	r9,88(sp)
81129e9c:	ad4003cc 	andi	r21,r21,15
81129ea0:	040000c4 	movi	r16,3
81129ea4:	1023883a 	mov	r17,r2
81129ea8:	1829883a 	mov	r20,r3
81129eac:	a8001126 	beq	r21,zero,81129ef4 <_dtoa_r+0x448>
81129eb0:	05e04574 	movhi	r23,33045
81129eb4:	bdc37604 	addi	r23,r23,3544
81129eb8:	4805883a 	mov	r2,r9
81129ebc:	4007883a 	mov	r3,r8
81129ec0:	a980004c 	andi	r6,r21,1
81129ec4:	1009883a 	mov	r4,r2
81129ec8:	a82bd07a 	srai	r21,r21,1
81129ecc:	180b883a 	mov	r5,r3
81129ed0:	30000426 	beq	r6,zero,81129ee4 <_dtoa_r+0x438>
81129ed4:	b9800017 	ldw	r6,0(r23)
81129ed8:	b9c00117 	ldw	r7,4(r23)
81129edc:	84000044 	addi	r16,r16,1
81129ee0:	111ffc00 	call	8111ffc0 <__muldf3>
81129ee4:	bdc00204 	addi	r23,r23,8
81129ee8:	a83ff51e 	bne	r21,zero,81129ec0 <__reset+0xfb109ec0>
81129eec:	1013883a 	mov	r9,r2
81129ef0:	1811883a 	mov	r8,r3
81129ef4:	480d883a 	mov	r6,r9
81129ef8:	400f883a 	mov	r7,r8
81129efc:	8809883a 	mov	r4,r17
81129f00:	a00b883a 	mov	r5,r20
81129f04:	11357840 	call	81135784 <__divdf3>
81129f08:	d8800f15 	stw	r2,60(sp)
81129f0c:	d8c01015 	stw	r3,64(sp)
81129f10:	d8c00e17 	ldw	r3,56(sp)
81129f14:	18000626 	beq	r3,zero,81129f30 <_dtoa_r+0x484>
81129f18:	d9000f17 	ldw	r4,60(sp)
81129f1c:	d9401017 	ldw	r5,64(sp)
81129f20:	000d883a 	mov	r6,zero
81129f24:	01cffc34 	movhi	r7,16368
81129f28:	11360fc0 	call	811360fc <__ledf2>
81129f2c:	10040b16 	blt	r2,zero,8112af5c <_dtoa_r+0x14b0>
81129f30:	8009883a 	mov	r4,r16
81129f34:	11210640 	call	81121064 <__floatsidf>
81129f38:	d9800f17 	ldw	r6,60(sp)
81129f3c:	d9c01017 	ldw	r7,64(sp)
81129f40:	1009883a 	mov	r4,r2
81129f44:	180b883a 	mov	r5,r3
81129f48:	111ffc00 	call	8111ffc0 <__muldf3>
81129f4c:	000d883a 	mov	r6,zero
81129f50:	01d00734 	movhi	r7,16412
81129f54:	1009883a 	mov	r4,r2
81129f58:	180b883a 	mov	r5,r3
81129f5c:	1134ed00 	call	81134ed0 <__adddf3>
81129f60:	1021883a 	mov	r16,r2
81129f64:	d8800617 	ldw	r2,24(sp)
81129f68:	047f3034 	movhi	r17,64704
81129f6c:	1c63883a 	add	r17,r3,r17
81129f70:	10031826 	beq	r2,zero,8112abd4 <_dtoa_r+0x1128>
81129f74:	d8c00517 	ldw	r3,20(sp)
81129f78:	db000617 	ldw	r12,24(sp)
81129f7c:	d8c01315 	stw	r3,76(sp)
81129f80:	d9000b17 	ldw	r4,44(sp)
81129f84:	20038f26 	beq	r4,zero,8112adc4 <_dtoa_r+0x1318>
81129f88:	60bfffc4 	addi	r2,r12,-1
81129f8c:	100490fa 	slli	r2,r2,3
81129f90:	00e04574 	movhi	r3,33045
81129f94:	18c38004 	addi	r3,r3,3584
81129f98:	1885883a 	add	r2,r3,r2
81129f9c:	11800017 	ldw	r6,0(r2)
81129fa0:	11c00117 	ldw	r7,4(r2)
81129fa4:	d8800717 	ldw	r2,28(sp)
81129fa8:	0009883a 	mov	r4,zero
81129fac:	014ff834 	movhi	r5,16352
81129fb0:	db001615 	stw	r12,88(sp)
81129fb4:	15c00044 	addi	r23,r2,1
81129fb8:	11357840 	call	81135784 <__divdf3>
81129fbc:	800d883a 	mov	r6,r16
81129fc0:	880f883a 	mov	r7,r17
81129fc4:	1009883a 	mov	r4,r2
81129fc8:	180b883a 	mov	r5,r3
81129fcc:	11206e00 	call	811206e0 <__subdf3>
81129fd0:	d9401017 	ldw	r5,64(sp)
81129fd4:	d9000f17 	ldw	r4,60(sp)
81129fd8:	102b883a 	mov	r21,r2
81129fdc:	d8c01215 	stw	r3,72(sp)
81129fe0:	1120fe40 	call	81120fe4 <__fixdfsi>
81129fe4:	1009883a 	mov	r4,r2
81129fe8:	1029883a 	mov	r20,r2
81129fec:	11210640 	call	81121064 <__floatsidf>
81129ff0:	d9000f17 	ldw	r4,60(sp)
81129ff4:	d9401017 	ldw	r5,64(sp)
81129ff8:	100d883a 	mov	r6,r2
81129ffc:	180f883a 	mov	r7,r3
8112a000:	11206e00 	call	811206e0 <__subdf3>
8112a004:	1823883a 	mov	r17,r3
8112a008:	d8c00717 	ldw	r3,28(sp)
8112a00c:	d9401217 	ldw	r5,72(sp)
8112a010:	a2000c04 	addi	r8,r20,48
8112a014:	1021883a 	mov	r16,r2
8112a018:	1a000005 	stb	r8,0(r3)
8112a01c:	800d883a 	mov	r6,r16
8112a020:	880f883a 	mov	r7,r17
8112a024:	a809883a 	mov	r4,r21
8112a028:	4029883a 	mov	r20,r8
8112a02c:	111fee40 	call	8111fee4 <__gedf2>
8112a030:	00841d16 	blt	zero,r2,8112b0a8 <_dtoa_r+0x15fc>
8112a034:	800d883a 	mov	r6,r16
8112a038:	880f883a 	mov	r7,r17
8112a03c:	0009883a 	mov	r4,zero
8112a040:	014ffc34 	movhi	r5,16368
8112a044:	11206e00 	call	811206e0 <__subdf3>
8112a048:	d9401217 	ldw	r5,72(sp)
8112a04c:	100d883a 	mov	r6,r2
8112a050:	180f883a 	mov	r7,r3
8112a054:	a809883a 	mov	r4,r21
8112a058:	111fee40 	call	8111fee4 <__gedf2>
8112a05c:	db001617 	ldw	r12,88(sp)
8112a060:	00840e16 	blt	zero,r2,8112b09c <_dtoa_r+0x15f0>
8112a064:	00800044 	movi	r2,1
8112a068:	13006b0e 	bge	r2,r12,8112a218 <_dtoa_r+0x76c>
8112a06c:	d9000717 	ldw	r4,28(sp)
8112a070:	dd800f15 	stw	r22,60(sp)
8112a074:	dcc01015 	stw	r19,64(sp)
8112a078:	2319883a 	add	r12,r4,r12
8112a07c:	dcc01217 	ldw	r19,72(sp)
8112a080:	602d883a 	mov	r22,r12
8112a084:	dc801215 	stw	r18,72(sp)
8112a088:	b825883a 	mov	r18,r23
8112a08c:	00000906 	br	8112a0b4 <_dtoa_r+0x608>
8112a090:	11206e00 	call	811206e0 <__subdf3>
8112a094:	a80d883a 	mov	r6,r21
8112a098:	980f883a 	mov	r7,r19
8112a09c:	1009883a 	mov	r4,r2
8112a0a0:	180b883a 	mov	r5,r3
8112a0a4:	11360fc0 	call	811360fc <__ledf2>
8112a0a8:	1003e816 	blt	r2,zero,8112b04c <_dtoa_r+0x15a0>
8112a0ac:	b825883a 	mov	r18,r23
8112a0b0:	bd83e926 	beq	r23,r22,8112b058 <_dtoa_r+0x15ac>
8112a0b4:	a809883a 	mov	r4,r21
8112a0b8:	980b883a 	mov	r5,r19
8112a0bc:	000d883a 	mov	r6,zero
8112a0c0:	01d00934 	movhi	r7,16420
8112a0c4:	111ffc00 	call	8111ffc0 <__muldf3>
8112a0c8:	000d883a 	mov	r6,zero
8112a0cc:	01d00934 	movhi	r7,16420
8112a0d0:	8009883a 	mov	r4,r16
8112a0d4:	880b883a 	mov	r5,r17
8112a0d8:	102b883a 	mov	r21,r2
8112a0dc:	1827883a 	mov	r19,r3
8112a0e0:	111ffc00 	call	8111ffc0 <__muldf3>
8112a0e4:	180b883a 	mov	r5,r3
8112a0e8:	1009883a 	mov	r4,r2
8112a0ec:	1821883a 	mov	r16,r3
8112a0f0:	1023883a 	mov	r17,r2
8112a0f4:	1120fe40 	call	81120fe4 <__fixdfsi>
8112a0f8:	1009883a 	mov	r4,r2
8112a0fc:	1029883a 	mov	r20,r2
8112a100:	11210640 	call	81121064 <__floatsidf>
8112a104:	8809883a 	mov	r4,r17
8112a108:	800b883a 	mov	r5,r16
8112a10c:	100d883a 	mov	r6,r2
8112a110:	180f883a 	mov	r7,r3
8112a114:	11206e00 	call	811206e0 <__subdf3>
8112a118:	a5000c04 	addi	r20,r20,48
8112a11c:	a80d883a 	mov	r6,r21
8112a120:	980f883a 	mov	r7,r19
8112a124:	1009883a 	mov	r4,r2
8112a128:	180b883a 	mov	r5,r3
8112a12c:	95000005 	stb	r20,0(r18)
8112a130:	1021883a 	mov	r16,r2
8112a134:	1823883a 	mov	r17,r3
8112a138:	11360fc0 	call	811360fc <__ledf2>
8112a13c:	bdc00044 	addi	r23,r23,1
8112a140:	800d883a 	mov	r6,r16
8112a144:	880f883a 	mov	r7,r17
8112a148:	0009883a 	mov	r4,zero
8112a14c:	014ffc34 	movhi	r5,16368
8112a150:	103fcf0e 	bge	r2,zero,8112a090 <__reset+0xfb10a090>
8112a154:	d8c01317 	ldw	r3,76(sp)
8112a158:	d8c00515 	stw	r3,20(sp)
8112a15c:	d9400917 	ldw	r5,36(sp)
8112a160:	e009883a 	mov	r4,fp
8112a164:	112cc740 	call	8112cc74 <_Bfree>
8112a168:	d9000517 	ldw	r4,20(sp)
8112a16c:	d9802317 	ldw	r6,140(sp)
8112a170:	d9c02517 	ldw	r7,148(sp)
8112a174:	b8000005 	stb	zero,0(r23)
8112a178:	20800044 	addi	r2,r4,1
8112a17c:	30800015 	stw	r2,0(r6)
8112a180:	3802aa26 	beq	r7,zero,8112ac2c <_dtoa_r+0x1180>
8112a184:	3dc00015 	stw	r23,0(r7)
8112a188:	d8800717 	ldw	r2,28(sp)
8112a18c:	003e7906 	br	81129b74 <__reset+0xfb109b74>
8112a190:	00800434 	movhi	r2,16
8112a194:	10bfffc4 	addi	r2,r2,-1
8112a198:	88a2703a 	and	r17,r17,r2
8112a19c:	883e851e 	bne	r17,zero,81129bb4 <__reset+0xfb109bb4>
8112a1a0:	00a04574 	movhi	r2,33045
8112a1a4:	10836204 	addi	r2,r2,3464
8112a1a8:	003e8406 	br	81129bbc <__reset+0xfb109bbc>
8112a1ac:	10c00204 	addi	r3,r2,8
8112a1b0:	003e8706 	br	81129bd0 <__reset+0xfb109bd0>
8112a1b4:	01400434 	movhi	r5,16
8112a1b8:	297fffc4 	addi	r5,r5,-1
8112a1bc:	994a703a 	and	r5,r19,r5
8112a1c0:	9009883a 	mov	r4,r18
8112a1c4:	843f0044 	addi	r16,r16,-1023
8112a1c8:	294ffc34 	orhi	r5,r5,16368
8112a1cc:	dd800217 	ldw	r22,8(sp)
8112a1d0:	d8001115 	stw	zero,68(sp)
8112a1d4:	003ea506 	br	81129c6c <__reset+0xfb109c6c>
8112a1d8:	00a04574 	movhi	r2,33045
8112a1dc:	10834704 	addi	r2,r2,3356
8112a1e0:	003e6406 	br	81129b74 <__reset+0xfb109b74>
8112a1e4:	e0001115 	stw	zero,68(fp)
8112a1e8:	000b883a 	mov	r5,zero
8112a1ec:	e009883a 	mov	r4,fp
8112a1f0:	112cbc40 	call	8112cbc4 <_Balloc>
8112a1f4:	01bfffc4 	movi	r6,-1
8112a1f8:	01c00044 	movi	r7,1
8112a1fc:	d8800715 	stw	r2,28(sp)
8112a200:	d9800c15 	stw	r6,48(sp)
8112a204:	e0801015 	stw	r2,64(fp)
8112a208:	d8000315 	stw	zero,12(sp)
8112a20c:	d9c00b15 	stw	r7,44(sp)
8112a210:	d9800615 	stw	r6,24(sp)
8112a214:	d8002215 	stw	zero,136(sp)
8112a218:	d8800117 	ldw	r2,4(sp)
8112a21c:	10008916 	blt	r2,zero,8112a444 <_dtoa_r+0x998>
8112a220:	d9000517 	ldw	r4,20(sp)
8112a224:	00c00384 	movi	r3,14
8112a228:	19008616 	blt	r3,r4,8112a444 <_dtoa_r+0x998>
8112a22c:	200490fa 	slli	r2,r4,3
8112a230:	00e04574 	movhi	r3,33045
8112a234:	d9802217 	ldw	r6,136(sp)
8112a238:	18c38004 	addi	r3,r3,3584
8112a23c:	1885883a 	add	r2,r3,r2
8112a240:	14000017 	ldw	r16,0(r2)
8112a244:	14400117 	ldw	r17,4(r2)
8112a248:	30016316 	blt	r6,zero,8112a7d8 <_dtoa_r+0xd2c>
8112a24c:	800d883a 	mov	r6,r16
8112a250:	880f883a 	mov	r7,r17
8112a254:	9009883a 	mov	r4,r18
8112a258:	980b883a 	mov	r5,r19
8112a25c:	11357840 	call	81135784 <__divdf3>
8112a260:	180b883a 	mov	r5,r3
8112a264:	1009883a 	mov	r4,r2
8112a268:	1120fe40 	call	81120fe4 <__fixdfsi>
8112a26c:	1009883a 	mov	r4,r2
8112a270:	102b883a 	mov	r21,r2
8112a274:	11210640 	call	81121064 <__floatsidf>
8112a278:	800d883a 	mov	r6,r16
8112a27c:	880f883a 	mov	r7,r17
8112a280:	1009883a 	mov	r4,r2
8112a284:	180b883a 	mov	r5,r3
8112a288:	111ffc00 	call	8111ffc0 <__muldf3>
8112a28c:	100d883a 	mov	r6,r2
8112a290:	180f883a 	mov	r7,r3
8112a294:	9009883a 	mov	r4,r18
8112a298:	980b883a 	mov	r5,r19
8112a29c:	11206e00 	call	811206e0 <__subdf3>
8112a2a0:	d9c00717 	ldw	r7,28(sp)
8112a2a4:	1009883a 	mov	r4,r2
8112a2a8:	a8800c04 	addi	r2,r21,48
8112a2ac:	38800005 	stb	r2,0(r7)
8112a2b0:	3dc00044 	addi	r23,r7,1
8112a2b4:	d9c00617 	ldw	r7,24(sp)
8112a2b8:	01800044 	movi	r6,1
8112a2bc:	180b883a 	mov	r5,r3
8112a2c0:	2005883a 	mov	r2,r4
8112a2c4:	39803826 	beq	r7,r6,8112a3a8 <_dtoa_r+0x8fc>
8112a2c8:	000d883a 	mov	r6,zero
8112a2cc:	01d00934 	movhi	r7,16420
8112a2d0:	111ffc00 	call	8111ffc0 <__muldf3>
8112a2d4:	000d883a 	mov	r6,zero
8112a2d8:	000f883a 	mov	r7,zero
8112a2dc:	1009883a 	mov	r4,r2
8112a2e0:	180b883a 	mov	r5,r3
8112a2e4:	1025883a 	mov	r18,r2
8112a2e8:	1827883a 	mov	r19,r3
8112a2ec:	11360740 	call	81136074 <__eqdf2>
8112a2f0:	103f9a26 	beq	r2,zero,8112a15c <__reset+0xfb10a15c>
8112a2f4:	d9c00617 	ldw	r7,24(sp)
8112a2f8:	d8c00717 	ldw	r3,28(sp)
8112a2fc:	b829883a 	mov	r20,r23
8112a300:	38bfffc4 	addi	r2,r7,-1
8112a304:	18ad883a 	add	r22,r3,r2
8112a308:	00000a06 	br	8112a334 <_dtoa_r+0x888>
8112a30c:	111ffc00 	call	8111ffc0 <__muldf3>
8112a310:	000d883a 	mov	r6,zero
8112a314:	000f883a 	mov	r7,zero
8112a318:	1009883a 	mov	r4,r2
8112a31c:	180b883a 	mov	r5,r3
8112a320:	1025883a 	mov	r18,r2
8112a324:	1827883a 	mov	r19,r3
8112a328:	b829883a 	mov	r20,r23
8112a32c:	11360740 	call	81136074 <__eqdf2>
8112a330:	103f8a26 	beq	r2,zero,8112a15c <__reset+0xfb10a15c>
8112a334:	800d883a 	mov	r6,r16
8112a338:	880f883a 	mov	r7,r17
8112a33c:	9009883a 	mov	r4,r18
8112a340:	980b883a 	mov	r5,r19
8112a344:	11357840 	call	81135784 <__divdf3>
8112a348:	180b883a 	mov	r5,r3
8112a34c:	1009883a 	mov	r4,r2
8112a350:	1120fe40 	call	81120fe4 <__fixdfsi>
8112a354:	1009883a 	mov	r4,r2
8112a358:	102b883a 	mov	r21,r2
8112a35c:	11210640 	call	81121064 <__floatsidf>
8112a360:	800d883a 	mov	r6,r16
8112a364:	880f883a 	mov	r7,r17
8112a368:	1009883a 	mov	r4,r2
8112a36c:	180b883a 	mov	r5,r3
8112a370:	111ffc00 	call	8111ffc0 <__muldf3>
8112a374:	100d883a 	mov	r6,r2
8112a378:	180f883a 	mov	r7,r3
8112a37c:	9009883a 	mov	r4,r18
8112a380:	980b883a 	mov	r5,r19
8112a384:	11206e00 	call	811206e0 <__subdf3>
8112a388:	aa000c04 	addi	r8,r21,48
8112a38c:	a2000005 	stb	r8,0(r20)
8112a390:	000d883a 	mov	r6,zero
8112a394:	01d00934 	movhi	r7,16420
8112a398:	1009883a 	mov	r4,r2
8112a39c:	180b883a 	mov	r5,r3
8112a3a0:	a5c00044 	addi	r23,r20,1
8112a3a4:	b53fd91e 	bne	r22,r20,8112a30c <__reset+0xfb10a30c>
8112a3a8:	100d883a 	mov	r6,r2
8112a3ac:	180f883a 	mov	r7,r3
8112a3b0:	1009883a 	mov	r4,r2
8112a3b4:	180b883a 	mov	r5,r3
8112a3b8:	1134ed00 	call	81134ed0 <__adddf3>
8112a3bc:	100d883a 	mov	r6,r2
8112a3c0:	180f883a 	mov	r7,r3
8112a3c4:	8009883a 	mov	r4,r16
8112a3c8:	880b883a 	mov	r5,r17
8112a3cc:	1027883a 	mov	r19,r2
8112a3d0:	1825883a 	mov	r18,r3
8112a3d4:	11360fc0 	call	811360fc <__ledf2>
8112a3d8:	10000816 	blt	r2,zero,8112a3fc <_dtoa_r+0x950>
8112a3dc:	980d883a 	mov	r6,r19
8112a3e0:	900f883a 	mov	r7,r18
8112a3e4:	8009883a 	mov	r4,r16
8112a3e8:	880b883a 	mov	r5,r17
8112a3ec:	11360740 	call	81136074 <__eqdf2>
8112a3f0:	103f5a1e 	bne	r2,zero,8112a15c <__reset+0xfb10a15c>
8112a3f4:	ad40004c 	andi	r21,r21,1
8112a3f8:	a83f5826 	beq	r21,zero,8112a15c <__reset+0xfb10a15c>
8112a3fc:	bd3fffc3 	ldbu	r20,-1(r23)
8112a400:	b8bfffc4 	addi	r2,r23,-1
8112a404:	1007883a 	mov	r3,r2
8112a408:	01400e44 	movi	r5,57
8112a40c:	d9800717 	ldw	r6,28(sp)
8112a410:	00000506 	br	8112a428 <_dtoa_r+0x97c>
8112a414:	18ffffc4 	addi	r3,r3,-1
8112a418:	11824726 	beq	r2,r6,8112ad38 <_dtoa_r+0x128c>
8112a41c:	1d000003 	ldbu	r20,0(r3)
8112a420:	102f883a 	mov	r23,r2
8112a424:	10bfffc4 	addi	r2,r2,-1
8112a428:	a1003fcc 	andi	r4,r20,255
8112a42c:	2100201c 	xori	r4,r4,128
8112a430:	213fe004 	addi	r4,r4,-128
8112a434:	217ff726 	beq	r4,r5,8112a414 <__reset+0xfb10a414>
8112a438:	a2000044 	addi	r8,r20,1
8112a43c:	12000005 	stb	r8,0(r2)
8112a440:	003f4606 	br	8112a15c <__reset+0xfb10a15c>
8112a444:	d9000b17 	ldw	r4,44(sp)
8112a448:	2000c826 	beq	r4,zero,8112a76c <_dtoa_r+0xcc0>
8112a44c:	d9800317 	ldw	r6,12(sp)
8112a450:	00c00044 	movi	r3,1
8112a454:	1980f90e 	bge	r3,r6,8112a83c <_dtoa_r+0xd90>
8112a458:	d8800617 	ldw	r2,24(sp)
8112a45c:	d8c00a17 	ldw	r3,40(sp)
8112a460:	157fffc4 	addi	r21,r2,-1
8112a464:	1d41f316 	blt	r3,r21,8112ac34 <_dtoa_r+0x1188>
8112a468:	1d6bc83a 	sub	r21,r3,r21
8112a46c:	d9c00617 	ldw	r7,24(sp)
8112a470:	3802aa16 	blt	r7,zero,8112af1c <_dtoa_r+0x1470>
8112a474:	dd000817 	ldw	r20,32(sp)
8112a478:	d8800617 	ldw	r2,24(sp)
8112a47c:	d8c00817 	ldw	r3,32(sp)
8112a480:	01400044 	movi	r5,1
8112a484:	e009883a 	mov	r4,fp
8112a488:	1887883a 	add	r3,r3,r2
8112a48c:	d8c00815 	stw	r3,32(sp)
8112a490:	b0ad883a 	add	r22,r22,r2
8112a494:	112cfe80 	call	8112cfe8 <__i2b>
8112a498:	1023883a 	mov	r17,r2
8112a49c:	a0000826 	beq	r20,zero,8112a4c0 <_dtoa_r+0xa14>
8112a4a0:	0580070e 	bge	zero,r22,8112a4c0 <_dtoa_r+0xa14>
8112a4a4:	a005883a 	mov	r2,r20
8112a4a8:	b500b916 	blt	r22,r20,8112a790 <_dtoa_r+0xce4>
8112a4ac:	d9000817 	ldw	r4,32(sp)
8112a4b0:	a0a9c83a 	sub	r20,r20,r2
8112a4b4:	b0adc83a 	sub	r22,r22,r2
8112a4b8:	2089c83a 	sub	r4,r4,r2
8112a4bc:	d9000815 	stw	r4,32(sp)
8112a4c0:	d9800a17 	ldw	r6,40(sp)
8112a4c4:	0181810e 	bge	zero,r6,8112aacc <_dtoa_r+0x1020>
8112a4c8:	d9c00b17 	ldw	r7,44(sp)
8112a4cc:	3800b326 	beq	r7,zero,8112a79c <_dtoa_r+0xcf0>
8112a4d0:	a800b226 	beq	r21,zero,8112a79c <_dtoa_r+0xcf0>
8112a4d4:	880b883a 	mov	r5,r17
8112a4d8:	a80d883a 	mov	r6,r21
8112a4dc:	e009883a 	mov	r4,fp
8112a4e0:	112d22c0 	call	8112d22c <__pow5mult>
8112a4e4:	d9800917 	ldw	r6,36(sp)
8112a4e8:	100b883a 	mov	r5,r2
8112a4ec:	e009883a 	mov	r4,fp
8112a4f0:	1023883a 	mov	r17,r2
8112a4f4:	112d02c0 	call	8112d02c <__multiply>
8112a4f8:	1021883a 	mov	r16,r2
8112a4fc:	d8800a17 	ldw	r2,40(sp)
8112a500:	d9400917 	ldw	r5,36(sp)
8112a504:	e009883a 	mov	r4,fp
8112a508:	1545c83a 	sub	r2,r2,r21
8112a50c:	d8800a15 	stw	r2,40(sp)
8112a510:	112cc740 	call	8112cc74 <_Bfree>
8112a514:	d8c00a17 	ldw	r3,40(sp)
8112a518:	18009f1e 	bne	r3,zero,8112a798 <_dtoa_r+0xcec>
8112a51c:	05c00044 	movi	r23,1
8112a520:	e009883a 	mov	r4,fp
8112a524:	b80b883a 	mov	r5,r23
8112a528:	112cfe80 	call	8112cfe8 <__i2b>
8112a52c:	d9000d17 	ldw	r4,52(sp)
8112a530:	102b883a 	mov	r21,r2
8112a534:	2000ce26 	beq	r4,zero,8112a870 <_dtoa_r+0xdc4>
8112a538:	200d883a 	mov	r6,r4
8112a53c:	100b883a 	mov	r5,r2
8112a540:	e009883a 	mov	r4,fp
8112a544:	112d22c0 	call	8112d22c <__pow5mult>
8112a548:	d9800317 	ldw	r6,12(sp)
8112a54c:	102b883a 	mov	r21,r2
8112a550:	b981810e 	bge	r23,r6,8112ab58 <_dtoa_r+0x10ac>
8112a554:	0027883a 	mov	r19,zero
8112a558:	a8800417 	ldw	r2,16(r21)
8112a55c:	05c00804 	movi	r23,32
8112a560:	10800104 	addi	r2,r2,4
8112a564:	1085883a 	add	r2,r2,r2
8112a568:	1085883a 	add	r2,r2,r2
8112a56c:	a885883a 	add	r2,r21,r2
8112a570:	11000017 	ldw	r4,0(r2)
8112a574:	112ced00 	call	8112ced0 <__hi0bits>
8112a578:	b885c83a 	sub	r2,r23,r2
8112a57c:	1585883a 	add	r2,r2,r22
8112a580:	108007cc 	andi	r2,r2,31
8112a584:	1000b326 	beq	r2,zero,8112a854 <_dtoa_r+0xda8>
8112a588:	00c00804 	movi	r3,32
8112a58c:	1887c83a 	sub	r3,r3,r2
8112a590:	01000104 	movi	r4,4
8112a594:	20c2cd0e 	bge	r4,r3,8112b0cc <_dtoa_r+0x1620>
8112a598:	00c00704 	movi	r3,28
8112a59c:	1885c83a 	sub	r2,r3,r2
8112a5a0:	d8c00817 	ldw	r3,32(sp)
8112a5a4:	a0a9883a 	add	r20,r20,r2
8112a5a8:	b0ad883a 	add	r22,r22,r2
8112a5ac:	1887883a 	add	r3,r3,r2
8112a5b0:	d8c00815 	stw	r3,32(sp)
8112a5b4:	d9800817 	ldw	r6,32(sp)
8112a5b8:	0180040e 	bge	zero,r6,8112a5cc <_dtoa_r+0xb20>
8112a5bc:	800b883a 	mov	r5,r16
8112a5c0:	e009883a 	mov	r4,fp
8112a5c4:	112d3740 	call	8112d374 <__lshift>
8112a5c8:	1021883a 	mov	r16,r2
8112a5cc:	0580050e 	bge	zero,r22,8112a5e4 <_dtoa_r+0xb38>
8112a5d0:	a80b883a 	mov	r5,r21
8112a5d4:	b00d883a 	mov	r6,r22
8112a5d8:	e009883a 	mov	r4,fp
8112a5dc:	112d3740 	call	8112d374 <__lshift>
8112a5e0:	102b883a 	mov	r21,r2
8112a5e4:	d9c00e17 	ldw	r7,56(sp)
8112a5e8:	3801211e 	bne	r7,zero,8112aa70 <_dtoa_r+0xfc4>
8112a5ec:	d9800617 	ldw	r6,24(sp)
8112a5f0:	0181380e 	bge	zero,r6,8112aad4 <_dtoa_r+0x1028>
8112a5f4:	d8c00b17 	ldw	r3,44(sp)
8112a5f8:	1800ab1e 	bne	r3,zero,8112a8a8 <_dtoa_r+0xdfc>
8112a5fc:	dc800717 	ldw	r18,28(sp)
8112a600:	dcc00617 	ldw	r19,24(sp)
8112a604:	9029883a 	mov	r20,r18
8112a608:	00000206 	br	8112a614 <_dtoa_r+0xb68>
8112a60c:	112cc9c0 	call	8112cc9c <__multadd>
8112a610:	1021883a 	mov	r16,r2
8112a614:	a80b883a 	mov	r5,r21
8112a618:	8009883a 	mov	r4,r16
8112a61c:	11298a40 	call	811298a4 <quorem>
8112a620:	10800c04 	addi	r2,r2,48
8112a624:	90800005 	stb	r2,0(r18)
8112a628:	94800044 	addi	r18,r18,1
8112a62c:	9507c83a 	sub	r3,r18,r20
8112a630:	000f883a 	mov	r7,zero
8112a634:	01800284 	movi	r6,10
8112a638:	800b883a 	mov	r5,r16
8112a63c:	e009883a 	mov	r4,fp
8112a640:	1cfff216 	blt	r3,r19,8112a60c <__reset+0xfb10a60c>
8112a644:	1011883a 	mov	r8,r2
8112a648:	d8800617 	ldw	r2,24(sp)
8112a64c:	0082370e 	bge	zero,r2,8112af2c <_dtoa_r+0x1480>
8112a650:	d9000717 	ldw	r4,28(sp)
8112a654:	0025883a 	mov	r18,zero
8112a658:	20af883a 	add	r23,r4,r2
8112a65c:	01800044 	movi	r6,1
8112a660:	800b883a 	mov	r5,r16
8112a664:	e009883a 	mov	r4,fp
8112a668:	da001715 	stw	r8,92(sp)
8112a66c:	112d3740 	call	8112d374 <__lshift>
8112a670:	a80b883a 	mov	r5,r21
8112a674:	1009883a 	mov	r4,r2
8112a678:	d8800915 	stw	r2,36(sp)
8112a67c:	112d4c40 	call	8112d4c4 <__mcmp>
8112a680:	da001717 	ldw	r8,92(sp)
8112a684:	0081800e 	bge	zero,r2,8112ac88 <_dtoa_r+0x11dc>
8112a688:	b93fffc3 	ldbu	r4,-1(r23)
8112a68c:	b8bfffc4 	addi	r2,r23,-1
8112a690:	1007883a 	mov	r3,r2
8112a694:	01800e44 	movi	r6,57
8112a698:	d9c00717 	ldw	r7,28(sp)
8112a69c:	00000506 	br	8112a6b4 <_dtoa_r+0xc08>
8112a6a0:	18ffffc4 	addi	r3,r3,-1
8112a6a4:	11c12326 	beq	r2,r7,8112ab34 <_dtoa_r+0x1088>
8112a6a8:	19000003 	ldbu	r4,0(r3)
8112a6ac:	102f883a 	mov	r23,r2
8112a6b0:	10bfffc4 	addi	r2,r2,-1
8112a6b4:	21403fcc 	andi	r5,r4,255
8112a6b8:	2940201c 	xori	r5,r5,128
8112a6bc:	297fe004 	addi	r5,r5,-128
8112a6c0:	29bff726 	beq	r5,r6,8112a6a0 <__reset+0xfb10a6a0>
8112a6c4:	21000044 	addi	r4,r4,1
8112a6c8:	11000005 	stb	r4,0(r2)
8112a6cc:	a80b883a 	mov	r5,r21
8112a6d0:	e009883a 	mov	r4,fp
8112a6d4:	112cc740 	call	8112cc74 <_Bfree>
8112a6d8:	883ea026 	beq	r17,zero,8112a15c <__reset+0xfb10a15c>
8112a6dc:	90000426 	beq	r18,zero,8112a6f0 <_dtoa_r+0xc44>
8112a6e0:	94400326 	beq	r18,r17,8112a6f0 <_dtoa_r+0xc44>
8112a6e4:	900b883a 	mov	r5,r18
8112a6e8:	e009883a 	mov	r4,fp
8112a6ec:	112cc740 	call	8112cc74 <_Bfree>
8112a6f0:	880b883a 	mov	r5,r17
8112a6f4:	e009883a 	mov	r4,fp
8112a6f8:	112cc740 	call	8112cc74 <_Bfree>
8112a6fc:	003e9706 	br	8112a15c <__reset+0xfb10a15c>
8112a700:	01800044 	movi	r6,1
8112a704:	d9800e15 	stw	r6,56(sp)
8112a708:	003d9606 	br	81129d64 <__reset+0xfb109d64>
8112a70c:	d8800817 	ldw	r2,32(sp)
8112a710:	d8c00517 	ldw	r3,20(sp)
8112a714:	d8000d15 	stw	zero,52(sp)
8112a718:	10c5c83a 	sub	r2,r2,r3
8112a71c:	00c9c83a 	sub	r4,zero,r3
8112a720:	d8800815 	stw	r2,32(sp)
8112a724:	d9000a15 	stw	r4,40(sp)
8112a728:	003d9706 	br	81129d88 <__reset+0xfb109d88>
8112a72c:	05adc83a 	sub	r22,zero,r22
8112a730:	dd800815 	stw	r22,32(sp)
8112a734:	002d883a 	mov	r22,zero
8112a738:	003d8e06 	br	81129d74 <__reset+0xfb109d74>
8112a73c:	d9000517 	ldw	r4,20(sp)
8112a740:	11210640 	call	81121064 <__floatsidf>
8112a744:	100d883a 	mov	r6,r2
8112a748:	180f883a 	mov	r7,r3
8112a74c:	a009883a 	mov	r4,r20
8112a750:	880b883a 	mov	r5,r17
8112a754:	11360740 	call	81136074 <__eqdf2>
8112a758:	103d7126 	beq	r2,zero,81129d20 <__reset+0xfb109d20>
8112a75c:	d9c00517 	ldw	r7,20(sp)
8112a760:	39ffffc4 	addi	r7,r7,-1
8112a764:	d9c00515 	stw	r7,20(sp)
8112a768:	003d6d06 	br	81129d20 <__reset+0xfb109d20>
8112a76c:	dd400a17 	ldw	r21,40(sp)
8112a770:	dd000817 	ldw	r20,32(sp)
8112a774:	0023883a 	mov	r17,zero
8112a778:	003f4806 	br	8112a49c <__reset+0xfb10a49c>
8112a77c:	10e3c83a 	sub	r17,r2,r3
8112a780:	9448983a 	sll	r4,r18,r17
8112a784:	003d3206 	br	81129c50 <__reset+0xfb109c50>
8112a788:	d8000e15 	stw	zero,56(sp)
8112a78c:	003d7506 	br	81129d64 <__reset+0xfb109d64>
8112a790:	b005883a 	mov	r2,r22
8112a794:	003f4506 	br	8112a4ac <__reset+0xfb10a4ac>
8112a798:	dc000915 	stw	r16,36(sp)
8112a79c:	d9800a17 	ldw	r6,40(sp)
8112a7a0:	d9400917 	ldw	r5,36(sp)
8112a7a4:	e009883a 	mov	r4,fp
8112a7a8:	112d22c0 	call	8112d22c <__pow5mult>
8112a7ac:	1021883a 	mov	r16,r2
8112a7b0:	003f5a06 	br	8112a51c <__reset+0xfb10a51c>
8112a7b4:	01c00044 	movi	r7,1
8112a7b8:	d9c00b15 	stw	r7,44(sp)
8112a7bc:	d8802217 	ldw	r2,136(sp)
8112a7c0:	0081280e 	bge	zero,r2,8112ac64 <_dtoa_r+0x11b8>
8112a7c4:	100d883a 	mov	r6,r2
8112a7c8:	1021883a 	mov	r16,r2
8112a7cc:	d8800c15 	stw	r2,48(sp)
8112a7d0:	d8800615 	stw	r2,24(sp)
8112a7d4:	003d8806 	br	81129df8 <__reset+0xfb109df8>
8112a7d8:	d8800617 	ldw	r2,24(sp)
8112a7dc:	00be9b16 	blt	zero,r2,8112a24c <__reset+0xfb10a24c>
8112a7e0:	10010f1e 	bne	r2,zero,8112ac20 <_dtoa_r+0x1174>
8112a7e4:	880b883a 	mov	r5,r17
8112a7e8:	000d883a 	mov	r6,zero
8112a7ec:	01d00534 	movhi	r7,16404
8112a7f0:	8009883a 	mov	r4,r16
8112a7f4:	111ffc00 	call	8111ffc0 <__muldf3>
8112a7f8:	900d883a 	mov	r6,r18
8112a7fc:	980f883a 	mov	r7,r19
8112a800:	1009883a 	mov	r4,r2
8112a804:	180b883a 	mov	r5,r3
8112a808:	111fee40 	call	8111fee4 <__gedf2>
8112a80c:	002b883a 	mov	r21,zero
8112a810:	0023883a 	mov	r17,zero
8112a814:	1000bf16 	blt	r2,zero,8112ab14 <_dtoa_r+0x1068>
8112a818:	d9802217 	ldw	r6,136(sp)
8112a81c:	ddc00717 	ldw	r23,28(sp)
8112a820:	018c303a 	nor	r6,zero,r6
8112a824:	d9800515 	stw	r6,20(sp)
8112a828:	a80b883a 	mov	r5,r21
8112a82c:	e009883a 	mov	r4,fp
8112a830:	112cc740 	call	8112cc74 <_Bfree>
8112a834:	883e4926 	beq	r17,zero,8112a15c <__reset+0xfb10a15c>
8112a838:	003fad06 	br	8112a6f0 <__reset+0xfb10a6f0>
8112a83c:	d9c01117 	ldw	r7,68(sp)
8112a840:	3801bc26 	beq	r7,zero,8112af34 <_dtoa_r+0x1488>
8112a844:	10810cc4 	addi	r2,r2,1075
8112a848:	dd400a17 	ldw	r21,40(sp)
8112a84c:	dd000817 	ldw	r20,32(sp)
8112a850:	003f0a06 	br	8112a47c <__reset+0xfb10a47c>
8112a854:	00800704 	movi	r2,28
8112a858:	d9000817 	ldw	r4,32(sp)
8112a85c:	a0a9883a 	add	r20,r20,r2
8112a860:	b0ad883a 	add	r22,r22,r2
8112a864:	2089883a 	add	r4,r4,r2
8112a868:	d9000815 	stw	r4,32(sp)
8112a86c:	003f5106 	br	8112a5b4 <__reset+0xfb10a5b4>
8112a870:	d8c00317 	ldw	r3,12(sp)
8112a874:	b8c1fc0e 	bge	r23,r3,8112b068 <_dtoa_r+0x15bc>
8112a878:	0027883a 	mov	r19,zero
8112a87c:	b805883a 	mov	r2,r23
8112a880:	003f3e06 	br	8112a57c <__reset+0xfb10a57c>
8112a884:	880b883a 	mov	r5,r17
8112a888:	e009883a 	mov	r4,fp
8112a88c:	000f883a 	mov	r7,zero
8112a890:	01800284 	movi	r6,10
8112a894:	112cc9c0 	call	8112cc9c <__multadd>
8112a898:	d9000c17 	ldw	r4,48(sp)
8112a89c:	1023883a 	mov	r17,r2
8112a8a0:	0102040e 	bge	zero,r4,8112b0b4 <_dtoa_r+0x1608>
8112a8a4:	d9000615 	stw	r4,24(sp)
8112a8a8:	0500050e 	bge	zero,r20,8112a8c0 <_dtoa_r+0xe14>
8112a8ac:	880b883a 	mov	r5,r17
8112a8b0:	a00d883a 	mov	r6,r20
8112a8b4:	e009883a 	mov	r4,fp
8112a8b8:	112d3740 	call	8112d374 <__lshift>
8112a8bc:	1023883a 	mov	r17,r2
8112a8c0:	9801241e 	bne	r19,zero,8112ad54 <_dtoa_r+0x12a8>
8112a8c4:	8829883a 	mov	r20,r17
8112a8c8:	d9000617 	ldw	r4,24(sp)
8112a8cc:	dcc00717 	ldw	r19,28(sp)
8112a8d0:	9480004c 	andi	r18,r18,1
8112a8d4:	20bfffc4 	addi	r2,r4,-1
8112a8d8:	9885883a 	add	r2,r19,r2
8112a8dc:	d8800415 	stw	r2,16(sp)
8112a8e0:	dc800615 	stw	r18,24(sp)
8112a8e4:	a80b883a 	mov	r5,r21
8112a8e8:	8009883a 	mov	r4,r16
8112a8ec:	11298a40 	call	811298a4 <quorem>
8112a8f0:	880b883a 	mov	r5,r17
8112a8f4:	8009883a 	mov	r4,r16
8112a8f8:	102f883a 	mov	r23,r2
8112a8fc:	112d4c40 	call	8112d4c4 <__mcmp>
8112a900:	a80b883a 	mov	r5,r21
8112a904:	a00d883a 	mov	r6,r20
8112a908:	e009883a 	mov	r4,fp
8112a90c:	102d883a 	mov	r22,r2
8112a910:	112d5240 	call	8112d524 <__mdiff>
8112a914:	1007883a 	mov	r3,r2
8112a918:	10800317 	ldw	r2,12(r2)
8112a91c:	bc800c04 	addi	r18,r23,48
8112a920:	180b883a 	mov	r5,r3
8112a924:	10004e1e 	bne	r2,zero,8112aa60 <_dtoa_r+0xfb4>
8112a928:	8009883a 	mov	r4,r16
8112a92c:	d8c01615 	stw	r3,88(sp)
8112a930:	112d4c40 	call	8112d4c4 <__mcmp>
8112a934:	d8c01617 	ldw	r3,88(sp)
8112a938:	e009883a 	mov	r4,fp
8112a93c:	d8801615 	stw	r2,88(sp)
8112a940:	180b883a 	mov	r5,r3
8112a944:	112cc740 	call	8112cc74 <_Bfree>
8112a948:	d8801617 	ldw	r2,88(sp)
8112a94c:	1000041e 	bne	r2,zero,8112a960 <_dtoa_r+0xeb4>
8112a950:	d9800317 	ldw	r6,12(sp)
8112a954:	3000021e 	bne	r6,zero,8112a960 <_dtoa_r+0xeb4>
8112a958:	d8c00617 	ldw	r3,24(sp)
8112a95c:	18003726 	beq	r3,zero,8112aa3c <_dtoa_r+0xf90>
8112a960:	b0002016 	blt	r22,zero,8112a9e4 <_dtoa_r+0xf38>
8112a964:	b000041e 	bne	r22,zero,8112a978 <_dtoa_r+0xecc>
8112a968:	d9000317 	ldw	r4,12(sp)
8112a96c:	2000021e 	bne	r4,zero,8112a978 <_dtoa_r+0xecc>
8112a970:	d8c00617 	ldw	r3,24(sp)
8112a974:	18001b26 	beq	r3,zero,8112a9e4 <_dtoa_r+0xf38>
8112a978:	00810716 	blt	zero,r2,8112ad98 <_dtoa_r+0x12ec>
8112a97c:	d8c00417 	ldw	r3,16(sp)
8112a980:	9d800044 	addi	r22,r19,1
8112a984:	9c800005 	stb	r18,0(r19)
8112a988:	b02f883a 	mov	r23,r22
8112a98c:	98c10626 	beq	r19,r3,8112ada8 <_dtoa_r+0x12fc>
8112a990:	800b883a 	mov	r5,r16
8112a994:	000f883a 	mov	r7,zero
8112a998:	01800284 	movi	r6,10
8112a99c:	e009883a 	mov	r4,fp
8112a9a0:	112cc9c0 	call	8112cc9c <__multadd>
8112a9a4:	1021883a 	mov	r16,r2
8112a9a8:	000f883a 	mov	r7,zero
8112a9ac:	01800284 	movi	r6,10
8112a9b0:	880b883a 	mov	r5,r17
8112a9b4:	e009883a 	mov	r4,fp
8112a9b8:	8d002526 	beq	r17,r20,8112aa50 <_dtoa_r+0xfa4>
8112a9bc:	112cc9c0 	call	8112cc9c <__multadd>
8112a9c0:	a00b883a 	mov	r5,r20
8112a9c4:	000f883a 	mov	r7,zero
8112a9c8:	01800284 	movi	r6,10
8112a9cc:	e009883a 	mov	r4,fp
8112a9d0:	1023883a 	mov	r17,r2
8112a9d4:	112cc9c0 	call	8112cc9c <__multadd>
8112a9d8:	1029883a 	mov	r20,r2
8112a9dc:	b027883a 	mov	r19,r22
8112a9e0:	003fc006 	br	8112a8e4 <__reset+0xfb10a8e4>
8112a9e4:	9011883a 	mov	r8,r18
8112a9e8:	00800e0e 	bge	zero,r2,8112aa24 <_dtoa_r+0xf78>
8112a9ec:	800b883a 	mov	r5,r16
8112a9f0:	01800044 	movi	r6,1
8112a9f4:	e009883a 	mov	r4,fp
8112a9f8:	da001715 	stw	r8,92(sp)
8112a9fc:	112d3740 	call	8112d374 <__lshift>
8112aa00:	a80b883a 	mov	r5,r21
8112aa04:	1009883a 	mov	r4,r2
8112aa08:	1021883a 	mov	r16,r2
8112aa0c:	112d4c40 	call	8112d4c4 <__mcmp>
8112aa10:	da001717 	ldw	r8,92(sp)
8112aa14:	0081960e 	bge	zero,r2,8112b070 <_dtoa_r+0x15c4>
8112aa18:	00800e44 	movi	r2,57
8112aa1c:	40817026 	beq	r8,r2,8112afe0 <_dtoa_r+0x1534>
8112aa20:	ba000c44 	addi	r8,r23,49
8112aa24:	8825883a 	mov	r18,r17
8112aa28:	9dc00044 	addi	r23,r19,1
8112aa2c:	9a000005 	stb	r8,0(r19)
8112aa30:	a023883a 	mov	r17,r20
8112aa34:	dc000915 	stw	r16,36(sp)
8112aa38:	003f2406 	br	8112a6cc <__reset+0xfb10a6cc>
8112aa3c:	00800e44 	movi	r2,57
8112aa40:	9011883a 	mov	r8,r18
8112aa44:	90816626 	beq	r18,r2,8112afe0 <_dtoa_r+0x1534>
8112aa48:	05bff516 	blt	zero,r22,8112aa20 <__reset+0xfb10aa20>
8112aa4c:	003ff506 	br	8112aa24 <__reset+0xfb10aa24>
8112aa50:	112cc9c0 	call	8112cc9c <__multadd>
8112aa54:	1023883a 	mov	r17,r2
8112aa58:	1029883a 	mov	r20,r2
8112aa5c:	003fdf06 	br	8112a9dc <__reset+0xfb10a9dc>
8112aa60:	e009883a 	mov	r4,fp
8112aa64:	112cc740 	call	8112cc74 <_Bfree>
8112aa68:	00800044 	movi	r2,1
8112aa6c:	003fbc06 	br	8112a960 <__reset+0xfb10a960>
8112aa70:	a80b883a 	mov	r5,r21
8112aa74:	8009883a 	mov	r4,r16
8112aa78:	112d4c40 	call	8112d4c4 <__mcmp>
8112aa7c:	103edb0e 	bge	r2,zero,8112a5ec <__reset+0xfb10a5ec>
8112aa80:	800b883a 	mov	r5,r16
8112aa84:	000f883a 	mov	r7,zero
8112aa88:	01800284 	movi	r6,10
8112aa8c:	e009883a 	mov	r4,fp
8112aa90:	112cc9c0 	call	8112cc9c <__multadd>
8112aa94:	1021883a 	mov	r16,r2
8112aa98:	d8800517 	ldw	r2,20(sp)
8112aa9c:	d8c00b17 	ldw	r3,44(sp)
8112aaa0:	10bfffc4 	addi	r2,r2,-1
8112aaa4:	d8800515 	stw	r2,20(sp)
8112aaa8:	183f761e 	bne	r3,zero,8112a884 <__reset+0xfb10a884>
8112aaac:	d9000c17 	ldw	r4,48(sp)
8112aab0:	0101730e 	bge	zero,r4,8112b080 <_dtoa_r+0x15d4>
8112aab4:	d9000615 	stw	r4,24(sp)
8112aab8:	003ed006 	br	8112a5fc <__reset+0xfb10a5fc>
8112aabc:	00800084 	movi	r2,2
8112aac0:	3081861e 	bne	r6,r2,8112b0dc <_dtoa_r+0x1630>
8112aac4:	d8000b15 	stw	zero,44(sp)
8112aac8:	003f3c06 	br	8112a7bc <__reset+0xfb10a7bc>
8112aacc:	dc000917 	ldw	r16,36(sp)
8112aad0:	003e9206 	br	8112a51c <__reset+0xfb10a51c>
8112aad4:	d9c00317 	ldw	r7,12(sp)
8112aad8:	00800084 	movi	r2,2
8112aadc:	11fec50e 	bge	r2,r7,8112a5f4 <__reset+0xfb10a5f4>
8112aae0:	d9000617 	ldw	r4,24(sp)
8112aae4:	20013c1e 	bne	r4,zero,8112afd8 <_dtoa_r+0x152c>
8112aae8:	a80b883a 	mov	r5,r21
8112aaec:	000f883a 	mov	r7,zero
8112aaf0:	01800144 	movi	r6,5
8112aaf4:	e009883a 	mov	r4,fp
8112aaf8:	112cc9c0 	call	8112cc9c <__multadd>
8112aafc:	100b883a 	mov	r5,r2
8112ab00:	8009883a 	mov	r4,r16
8112ab04:	102b883a 	mov	r21,r2
8112ab08:	112d4c40 	call	8112d4c4 <__mcmp>
8112ab0c:	dc000915 	stw	r16,36(sp)
8112ab10:	00bf410e 	bge	zero,r2,8112a818 <__reset+0xfb10a818>
8112ab14:	d9c00717 	ldw	r7,28(sp)
8112ab18:	00800c44 	movi	r2,49
8112ab1c:	38800005 	stb	r2,0(r7)
8112ab20:	d8800517 	ldw	r2,20(sp)
8112ab24:	3dc00044 	addi	r23,r7,1
8112ab28:	10800044 	addi	r2,r2,1
8112ab2c:	d8800515 	stw	r2,20(sp)
8112ab30:	003f3d06 	br	8112a828 <__reset+0xfb10a828>
8112ab34:	d9800517 	ldw	r6,20(sp)
8112ab38:	d9c00717 	ldw	r7,28(sp)
8112ab3c:	00800c44 	movi	r2,49
8112ab40:	31800044 	addi	r6,r6,1
8112ab44:	d9800515 	stw	r6,20(sp)
8112ab48:	38800005 	stb	r2,0(r7)
8112ab4c:	003edf06 	br	8112a6cc <__reset+0xfb10a6cc>
8112ab50:	d8000b15 	stw	zero,44(sp)
8112ab54:	003c9f06 	br	81129dd4 <__reset+0xfb109dd4>
8112ab58:	903e7e1e 	bne	r18,zero,8112a554 <__reset+0xfb10a554>
8112ab5c:	00800434 	movhi	r2,16
8112ab60:	10bfffc4 	addi	r2,r2,-1
8112ab64:	9884703a 	and	r2,r19,r2
8112ab68:	1000ea1e 	bne	r2,zero,8112af14 <_dtoa_r+0x1468>
8112ab6c:	9cdffc2c 	andhi	r19,r19,32752
8112ab70:	9800e826 	beq	r19,zero,8112af14 <_dtoa_r+0x1468>
8112ab74:	d9c00817 	ldw	r7,32(sp)
8112ab78:	b5800044 	addi	r22,r22,1
8112ab7c:	04c00044 	movi	r19,1
8112ab80:	39c00044 	addi	r7,r7,1
8112ab84:	d9c00815 	stw	r7,32(sp)
8112ab88:	d8800d17 	ldw	r2,52(sp)
8112ab8c:	103e721e 	bne	r2,zero,8112a558 <__reset+0xfb10a558>
8112ab90:	00800044 	movi	r2,1
8112ab94:	003e7906 	br	8112a57c <__reset+0xfb10a57c>
8112ab98:	8009883a 	mov	r4,r16
8112ab9c:	11210640 	call	81121064 <__floatsidf>
8112aba0:	d9800f17 	ldw	r6,60(sp)
8112aba4:	d9c01017 	ldw	r7,64(sp)
8112aba8:	1009883a 	mov	r4,r2
8112abac:	180b883a 	mov	r5,r3
8112abb0:	111ffc00 	call	8111ffc0 <__muldf3>
8112abb4:	000d883a 	mov	r6,zero
8112abb8:	01d00734 	movhi	r7,16412
8112abbc:	1009883a 	mov	r4,r2
8112abc0:	180b883a 	mov	r5,r3
8112abc4:	1134ed00 	call	81134ed0 <__adddf3>
8112abc8:	047f3034 	movhi	r17,64704
8112abcc:	1021883a 	mov	r16,r2
8112abd0:	1c63883a 	add	r17,r3,r17
8112abd4:	d9000f17 	ldw	r4,60(sp)
8112abd8:	d9401017 	ldw	r5,64(sp)
8112abdc:	000d883a 	mov	r6,zero
8112abe0:	01d00534 	movhi	r7,16404
8112abe4:	11206e00 	call	811206e0 <__subdf3>
8112abe8:	800d883a 	mov	r6,r16
8112abec:	880f883a 	mov	r7,r17
8112abf0:	1009883a 	mov	r4,r2
8112abf4:	180b883a 	mov	r5,r3
8112abf8:	102b883a 	mov	r21,r2
8112abfc:	1829883a 	mov	r20,r3
8112ac00:	111fee40 	call	8111fee4 <__gedf2>
8112ac04:	00806c16 	blt	zero,r2,8112adb8 <_dtoa_r+0x130c>
8112ac08:	89e0003c 	xorhi	r7,r17,32768
8112ac0c:	800d883a 	mov	r6,r16
8112ac10:	a809883a 	mov	r4,r21
8112ac14:	a00b883a 	mov	r5,r20
8112ac18:	11360fc0 	call	811360fc <__ledf2>
8112ac1c:	103d7e0e 	bge	r2,zero,8112a218 <__reset+0xfb10a218>
8112ac20:	002b883a 	mov	r21,zero
8112ac24:	0023883a 	mov	r17,zero
8112ac28:	003efb06 	br	8112a818 <__reset+0xfb10a818>
8112ac2c:	d8800717 	ldw	r2,28(sp)
8112ac30:	003bd006 	br	81129b74 <__reset+0xfb109b74>
8112ac34:	d9000a17 	ldw	r4,40(sp)
8112ac38:	d9800d17 	ldw	r6,52(sp)
8112ac3c:	dd400a15 	stw	r21,40(sp)
8112ac40:	a905c83a 	sub	r2,r21,r4
8112ac44:	308d883a 	add	r6,r6,r2
8112ac48:	d9800d15 	stw	r6,52(sp)
8112ac4c:	002b883a 	mov	r21,zero
8112ac50:	003e0606 	br	8112a46c <__reset+0xfb10a46c>
8112ac54:	9023883a 	mov	r17,r18
8112ac58:	9829883a 	mov	r20,r19
8112ac5c:	04000084 	movi	r16,2
8112ac60:	003c9206 	br	81129eac <__reset+0xfb109eac>
8112ac64:	04000044 	movi	r16,1
8112ac68:	dc000c15 	stw	r16,48(sp)
8112ac6c:	dc000615 	stw	r16,24(sp)
8112ac70:	dc002215 	stw	r16,136(sp)
8112ac74:	e0001115 	stw	zero,68(fp)
8112ac78:	000b883a 	mov	r5,zero
8112ac7c:	003c6906 	br	81129e24 <__reset+0xfb109e24>
8112ac80:	3021883a 	mov	r16,r6
8112ac84:	003ffb06 	br	8112ac74 <__reset+0xfb10ac74>
8112ac88:	1000021e 	bne	r2,zero,8112ac94 <_dtoa_r+0x11e8>
8112ac8c:	4200004c 	andi	r8,r8,1
8112ac90:	403e7d1e 	bne	r8,zero,8112a688 <__reset+0xfb10a688>
8112ac94:	01000c04 	movi	r4,48
8112ac98:	00000106 	br	8112aca0 <_dtoa_r+0x11f4>
8112ac9c:	102f883a 	mov	r23,r2
8112aca0:	b8bfffc4 	addi	r2,r23,-1
8112aca4:	10c00007 	ldb	r3,0(r2)
8112aca8:	193ffc26 	beq	r3,r4,8112ac9c <__reset+0xfb10ac9c>
8112acac:	003e8706 	br	8112a6cc <__reset+0xfb10a6cc>
8112acb0:	d8800517 	ldw	r2,20(sp)
8112acb4:	00a3c83a 	sub	r17,zero,r2
8112acb8:	8800a426 	beq	r17,zero,8112af4c <_dtoa_r+0x14a0>
8112acbc:	888003cc 	andi	r2,r17,15
8112acc0:	100490fa 	slli	r2,r2,3
8112acc4:	00e04574 	movhi	r3,33045
8112acc8:	18c38004 	addi	r3,r3,3584
8112accc:	1885883a 	add	r2,r3,r2
8112acd0:	11800017 	ldw	r6,0(r2)
8112acd4:	11c00117 	ldw	r7,4(r2)
8112acd8:	9009883a 	mov	r4,r18
8112acdc:	980b883a 	mov	r5,r19
8112ace0:	8823d13a 	srai	r17,r17,4
8112ace4:	111ffc00 	call	8111ffc0 <__muldf3>
8112ace8:	d8800f15 	stw	r2,60(sp)
8112acec:	d8c01015 	stw	r3,64(sp)
8112acf0:	8800e826 	beq	r17,zero,8112b094 <_dtoa_r+0x15e8>
8112acf4:	05204574 	movhi	r20,33045
8112acf8:	a5037604 	addi	r20,r20,3544
8112acfc:	04000084 	movi	r16,2
8112ad00:	8980004c 	andi	r6,r17,1
8112ad04:	1009883a 	mov	r4,r2
8112ad08:	8823d07a 	srai	r17,r17,1
8112ad0c:	180b883a 	mov	r5,r3
8112ad10:	30000426 	beq	r6,zero,8112ad24 <_dtoa_r+0x1278>
8112ad14:	a1800017 	ldw	r6,0(r20)
8112ad18:	a1c00117 	ldw	r7,4(r20)
8112ad1c:	84000044 	addi	r16,r16,1
8112ad20:	111ffc00 	call	8111ffc0 <__muldf3>
8112ad24:	a5000204 	addi	r20,r20,8
8112ad28:	883ff51e 	bne	r17,zero,8112ad00 <__reset+0xfb10ad00>
8112ad2c:	d8800f15 	stw	r2,60(sp)
8112ad30:	d8c01015 	stw	r3,64(sp)
8112ad34:	003c7606 	br	81129f10 <__reset+0xfb109f10>
8112ad38:	00c00c04 	movi	r3,48
8112ad3c:	10c00005 	stb	r3,0(r2)
8112ad40:	d8c00517 	ldw	r3,20(sp)
8112ad44:	bd3fffc3 	ldbu	r20,-1(r23)
8112ad48:	18c00044 	addi	r3,r3,1
8112ad4c:	d8c00515 	stw	r3,20(sp)
8112ad50:	003db906 	br	8112a438 <__reset+0xfb10a438>
8112ad54:	89400117 	ldw	r5,4(r17)
8112ad58:	e009883a 	mov	r4,fp
8112ad5c:	112cbc40 	call	8112cbc4 <_Balloc>
8112ad60:	89800417 	ldw	r6,16(r17)
8112ad64:	89400304 	addi	r5,r17,12
8112ad68:	11000304 	addi	r4,r2,12
8112ad6c:	31800084 	addi	r6,r6,2
8112ad70:	318d883a 	add	r6,r6,r6
8112ad74:	318d883a 	add	r6,r6,r6
8112ad78:	1027883a 	mov	r19,r2
8112ad7c:	11226900 	call	81122690 <memcpy>
8112ad80:	01800044 	movi	r6,1
8112ad84:	980b883a 	mov	r5,r19
8112ad88:	e009883a 	mov	r4,fp
8112ad8c:	112d3740 	call	8112d374 <__lshift>
8112ad90:	1029883a 	mov	r20,r2
8112ad94:	003ecc06 	br	8112a8c8 <__reset+0xfb10a8c8>
8112ad98:	00800e44 	movi	r2,57
8112ad9c:	90809026 	beq	r18,r2,8112afe0 <_dtoa_r+0x1534>
8112ada0:	92000044 	addi	r8,r18,1
8112ada4:	003f1f06 	br	8112aa24 <__reset+0xfb10aa24>
8112ada8:	9011883a 	mov	r8,r18
8112adac:	8825883a 	mov	r18,r17
8112adb0:	a023883a 	mov	r17,r20
8112adb4:	003e2906 	br	8112a65c <__reset+0xfb10a65c>
8112adb8:	002b883a 	mov	r21,zero
8112adbc:	0023883a 	mov	r17,zero
8112adc0:	003f5406 	br	8112ab14 <__reset+0xfb10ab14>
8112adc4:	61bfffc4 	addi	r6,r12,-1
8112adc8:	300490fa 	slli	r2,r6,3
8112adcc:	00e04574 	movhi	r3,33045
8112add0:	18c38004 	addi	r3,r3,3584
8112add4:	1885883a 	add	r2,r3,r2
8112add8:	11000017 	ldw	r4,0(r2)
8112addc:	11400117 	ldw	r5,4(r2)
8112ade0:	d8800717 	ldw	r2,28(sp)
8112ade4:	880f883a 	mov	r7,r17
8112ade8:	d9801215 	stw	r6,72(sp)
8112adec:	800d883a 	mov	r6,r16
8112adf0:	db001615 	stw	r12,88(sp)
8112adf4:	15c00044 	addi	r23,r2,1
8112adf8:	111ffc00 	call	8111ffc0 <__muldf3>
8112adfc:	d9401017 	ldw	r5,64(sp)
8112ae00:	d9000f17 	ldw	r4,60(sp)
8112ae04:	d8c01515 	stw	r3,84(sp)
8112ae08:	d8801415 	stw	r2,80(sp)
8112ae0c:	1120fe40 	call	81120fe4 <__fixdfsi>
8112ae10:	1009883a 	mov	r4,r2
8112ae14:	1021883a 	mov	r16,r2
8112ae18:	11210640 	call	81121064 <__floatsidf>
8112ae1c:	d9000f17 	ldw	r4,60(sp)
8112ae20:	d9401017 	ldw	r5,64(sp)
8112ae24:	100d883a 	mov	r6,r2
8112ae28:	180f883a 	mov	r7,r3
8112ae2c:	11206e00 	call	811206e0 <__subdf3>
8112ae30:	1829883a 	mov	r20,r3
8112ae34:	d8c00717 	ldw	r3,28(sp)
8112ae38:	84000c04 	addi	r16,r16,48
8112ae3c:	1023883a 	mov	r17,r2
8112ae40:	1c000005 	stb	r16,0(r3)
8112ae44:	db001617 	ldw	r12,88(sp)
8112ae48:	00800044 	movi	r2,1
8112ae4c:	60802226 	beq	r12,r2,8112aed8 <_dtoa_r+0x142c>
8112ae50:	d9c00717 	ldw	r7,28(sp)
8112ae54:	8805883a 	mov	r2,r17
8112ae58:	b82b883a 	mov	r21,r23
8112ae5c:	3b19883a 	add	r12,r7,r12
8112ae60:	6023883a 	mov	r17,r12
8112ae64:	a007883a 	mov	r3,r20
8112ae68:	dc800f15 	stw	r18,60(sp)
8112ae6c:	000d883a 	mov	r6,zero
8112ae70:	01d00934 	movhi	r7,16420
8112ae74:	1009883a 	mov	r4,r2
8112ae78:	180b883a 	mov	r5,r3
8112ae7c:	111ffc00 	call	8111ffc0 <__muldf3>
8112ae80:	180b883a 	mov	r5,r3
8112ae84:	1009883a 	mov	r4,r2
8112ae88:	1829883a 	mov	r20,r3
8112ae8c:	1025883a 	mov	r18,r2
8112ae90:	1120fe40 	call	81120fe4 <__fixdfsi>
8112ae94:	1009883a 	mov	r4,r2
8112ae98:	1021883a 	mov	r16,r2
8112ae9c:	11210640 	call	81121064 <__floatsidf>
8112aea0:	100d883a 	mov	r6,r2
8112aea4:	180f883a 	mov	r7,r3
8112aea8:	9009883a 	mov	r4,r18
8112aeac:	a00b883a 	mov	r5,r20
8112aeb0:	84000c04 	addi	r16,r16,48
8112aeb4:	11206e00 	call	811206e0 <__subdf3>
8112aeb8:	ad400044 	addi	r21,r21,1
8112aebc:	ac3fffc5 	stb	r16,-1(r21)
8112aec0:	ac7fea1e 	bne	r21,r17,8112ae6c <__reset+0xfb10ae6c>
8112aec4:	1023883a 	mov	r17,r2
8112aec8:	d8801217 	ldw	r2,72(sp)
8112aecc:	dc800f17 	ldw	r18,60(sp)
8112aed0:	1829883a 	mov	r20,r3
8112aed4:	b8af883a 	add	r23,r23,r2
8112aed8:	d9001417 	ldw	r4,80(sp)
8112aedc:	d9401517 	ldw	r5,84(sp)
8112aee0:	000d883a 	mov	r6,zero
8112aee4:	01cff834 	movhi	r7,16352
8112aee8:	1134ed00 	call	81134ed0 <__adddf3>
8112aeec:	880d883a 	mov	r6,r17
8112aef0:	a00f883a 	mov	r7,r20
8112aef4:	1009883a 	mov	r4,r2
8112aef8:	180b883a 	mov	r5,r3
8112aefc:	11360fc0 	call	811360fc <__ledf2>
8112af00:	10003e0e 	bge	r2,zero,8112affc <_dtoa_r+0x1550>
8112af04:	d9001317 	ldw	r4,76(sp)
8112af08:	bd3fffc3 	ldbu	r20,-1(r23)
8112af0c:	d9000515 	stw	r4,20(sp)
8112af10:	003d3b06 	br	8112a400 <__reset+0xfb10a400>
8112af14:	0027883a 	mov	r19,zero
8112af18:	003f1b06 	br	8112ab88 <__reset+0xfb10ab88>
8112af1c:	d8800817 	ldw	r2,32(sp)
8112af20:	11e9c83a 	sub	r20,r2,r7
8112af24:	0005883a 	mov	r2,zero
8112af28:	003d5406 	br	8112a47c <__reset+0xfb10a47c>
8112af2c:	00800044 	movi	r2,1
8112af30:	003dc706 	br	8112a650 <__reset+0xfb10a650>
8112af34:	d8c00217 	ldw	r3,8(sp)
8112af38:	00800d84 	movi	r2,54
8112af3c:	dd400a17 	ldw	r21,40(sp)
8112af40:	10c5c83a 	sub	r2,r2,r3
8112af44:	dd000817 	ldw	r20,32(sp)
8112af48:	003d4c06 	br	8112a47c <__reset+0xfb10a47c>
8112af4c:	dc800f15 	stw	r18,60(sp)
8112af50:	dcc01015 	stw	r19,64(sp)
8112af54:	04000084 	movi	r16,2
8112af58:	003bed06 	br	81129f10 <__reset+0xfb109f10>
8112af5c:	d9000617 	ldw	r4,24(sp)
8112af60:	203f0d26 	beq	r4,zero,8112ab98 <__reset+0xfb10ab98>
8112af64:	d9800c17 	ldw	r6,48(sp)
8112af68:	01bcab0e 	bge	zero,r6,8112a218 <__reset+0xfb10a218>
8112af6c:	d9401017 	ldw	r5,64(sp)
8112af70:	d9000f17 	ldw	r4,60(sp)
8112af74:	000d883a 	mov	r6,zero
8112af78:	01d00934 	movhi	r7,16420
8112af7c:	111ffc00 	call	8111ffc0 <__muldf3>
8112af80:	81000044 	addi	r4,r16,1
8112af84:	d8800f15 	stw	r2,60(sp)
8112af88:	d8c01015 	stw	r3,64(sp)
8112af8c:	11210640 	call	81121064 <__floatsidf>
8112af90:	d9800f17 	ldw	r6,60(sp)
8112af94:	d9c01017 	ldw	r7,64(sp)
8112af98:	1009883a 	mov	r4,r2
8112af9c:	180b883a 	mov	r5,r3
8112afa0:	111ffc00 	call	8111ffc0 <__muldf3>
8112afa4:	01d00734 	movhi	r7,16412
8112afa8:	000d883a 	mov	r6,zero
8112afac:	1009883a 	mov	r4,r2
8112afb0:	180b883a 	mov	r5,r3
8112afb4:	1134ed00 	call	81134ed0 <__adddf3>
8112afb8:	d9c00517 	ldw	r7,20(sp)
8112afbc:	047f3034 	movhi	r17,64704
8112afc0:	1021883a 	mov	r16,r2
8112afc4:	39ffffc4 	addi	r7,r7,-1
8112afc8:	d9c01315 	stw	r7,76(sp)
8112afcc:	1c63883a 	add	r17,r3,r17
8112afd0:	db000c17 	ldw	r12,48(sp)
8112afd4:	003bea06 	br	81129f80 <__reset+0xfb109f80>
8112afd8:	dc000915 	stw	r16,36(sp)
8112afdc:	003e0e06 	br	8112a818 <__reset+0xfb10a818>
8112afe0:	01000e44 	movi	r4,57
8112afe4:	8825883a 	mov	r18,r17
8112afe8:	9dc00044 	addi	r23,r19,1
8112afec:	99000005 	stb	r4,0(r19)
8112aff0:	a023883a 	mov	r17,r20
8112aff4:	dc000915 	stw	r16,36(sp)
8112aff8:	003da406 	br	8112a68c <__reset+0xfb10a68c>
8112affc:	d9801417 	ldw	r6,80(sp)
8112b000:	d9c01517 	ldw	r7,84(sp)
8112b004:	0009883a 	mov	r4,zero
8112b008:	014ff834 	movhi	r5,16352
8112b00c:	11206e00 	call	811206e0 <__subdf3>
8112b010:	880d883a 	mov	r6,r17
8112b014:	a00f883a 	mov	r7,r20
8112b018:	1009883a 	mov	r4,r2
8112b01c:	180b883a 	mov	r5,r3
8112b020:	111fee40 	call	8111fee4 <__gedf2>
8112b024:	00bc7c0e 	bge	zero,r2,8112a218 <__reset+0xfb10a218>
8112b028:	01000c04 	movi	r4,48
8112b02c:	00000106 	br	8112b034 <_dtoa_r+0x1588>
8112b030:	102f883a 	mov	r23,r2
8112b034:	b8bfffc4 	addi	r2,r23,-1
8112b038:	10c00007 	ldb	r3,0(r2)
8112b03c:	193ffc26 	beq	r3,r4,8112b030 <__reset+0xfb10b030>
8112b040:	d9801317 	ldw	r6,76(sp)
8112b044:	d9800515 	stw	r6,20(sp)
8112b048:	003c4406 	br	8112a15c <__reset+0xfb10a15c>
8112b04c:	d9801317 	ldw	r6,76(sp)
8112b050:	d9800515 	stw	r6,20(sp)
8112b054:	003cea06 	br	8112a400 <__reset+0xfb10a400>
8112b058:	dd800f17 	ldw	r22,60(sp)
8112b05c:	dcc01017 	ldw	r19,64(sp)
8112b060:	dc801217 	ldw	r18,72(sp)
8112b064:	003c6c06 	br	8112a218 <__reset+0xfb10a218>
8112b068:	903e031e 	bne	r18,zero,8112a878 <__reset+0xfb10a878>
8112b06c:	003ebb06 	br	8112ab5c <__reset+0xfb10ab5c>
8112b070:	103e6c1e 	bne	r2,zero,8112aa24 <__reset+0xfb10aa24>
8112b074:	4080004c 	andi	r2,r8,1
8112b078:	103e6a26 	beq	r2,zero,8112aa24 <__reset+0xfb10aa24>
8112b07c:	003e6606 	br	8112aa18 <__reset+0xfb10aa18>
8112b080:	d8c00317 	ldw	r3,12(sp)
8112b084:	00800084 	movi	r2,2
8112b088:	10c02916 	blt	r2,r3,8112b130 <_dtoa_r+0x1684>
8112b08c:	d9000c17 	ldw	r4,48(sp)
8112b090:	003e8806 	br	8112aab4 <__reset+0xfb10aab4>
8112b094:	04000084 	movi	r16,2
8112b098:	003b9d06 	br	81129f10 <__reset+0xfb109f10>
8112b09c:	d9001317 	ldw	r4,76(sp)
8112b0a0:	d9000515 	stw	r4,20(sp)
8112b0a4:	003cd606 	br	8112a400 <__reset+0xfb10a400>
8112b0a8:	d8801317 	ldw	r2,76(sp)
8112b0ac:	d8800515 	stw	r2,20(sp)
8112b0b0:	003c2a06 	br	8112a15c <__reset+0xfb10a15c>
8112b0b4:	d9800317 	ldw	r6,12(sp)
8112b0b8:	00800084 	movi	r2,2
8112b0bc:	11801516 	blt	r2,r6,8112b114 <_dtoa_r+0x1668>
8112b0c0:	d9c00c17 	ldw	r7,48(sp)
8112b0c4:	d9c00615 	stw	r7,24(sp)
8112b0c8:	003df706 	br	8112a8a8 <__reset+0xfb10a8a8>
8112b0cc:	193d3926 	beq	r3,r4,8112a5b4 <__reset+0xfb10a5b4>
8112b0d0:	00c00f04 	movi	r3,60
8112b0d4:	1885c83a 	sub	r2,r3,r2
8112b0d8:	003ddf06 	br	8112a858 <__reset+0xfb10a858>
8112b0dc:	e009883a 	mov	r4,fp
8112b0e0:	e0001115 	stw	zero,68(fp)
8112b0e4:	000b883a 	mov	r5,zero
8112b0e8:	112cbc40 	call	8112cbc4 <_Balloc>
8112b0ec:	d8800715 	stw	r2,28(sp)
8112b0f0:	d8c00717 	ldw	r3,28(sp)
8112b0f4:	00bfffc4 	movi	r2,-1
8112b0f8:	01000044 	movi	r4,1
8112b0fc:	d8800c15 	stw	r2,48(sp)
8112b100:	e0c01015 	stw	r3,64(fp)
8112b104:	d9000b15 	stw	r4,44(sp)
8112b108:	d8800615 	stw	r2,24(sp)
8112b10c:	d8002215 	stw	zero,136(sp)
8112b110:	003c4106 	br	8112a218 <__reset+0xfb10a218>
8112b114:	d8c00c17 	ldw	r3,48(sp)
8112b118:	d8c00615 	stw	r3,24(sp)
8112b11c:	003e7006 	br	8112aae0 <__reset+0xfb10aae0>
8112b120:	04400044 	movi	r17,1
8112b124:	003b2006 	br	81129da8 <__reset+0xfb109da8>
8112b128:	000b883a 	mov	r5,zero
8112b12c:	003b3d06 	br	81129e24 <__reset+0xfb109e24>
8112b130:	d8800c17 	ldw	r2,48(sp)
8112b134:	d8800615 	stw	r2,24(sp)
8112b138:	003e6906 	br	8112aae0 <__reset+0xfb10aae0>

8112b13c <__sflush_r>:
8112b13c:	defffb04 	addi	sp,sp,-20
8112b140:	de00012e 	bgeu	sp,et,8112b148 <__sflush_r+0xc>
8112b144:	003b68fa 	trap	3
8112b148:	2880030b 	ldhu	r2,12(r5)
8112b14c:	dcc00315 	stw	r19,12(sp)
8112b150:	dc400115 	stw	r17,4(sp)
8112b154:	dfc00415 	stw	ra,16(sp)
8112b158:	dc800215 	stw	r18,8(sp)
8112b15c:	dc000015 	stw	r16,0(sp)
8112b160:	10c0020c 	andi	r3,r2,8
8112b164:	2823883a 	mov	r17,r5
8112b168:	2027883a 	mov	r19,r4
8112b16c:	1800311e 	bne	r3,zero,8112b234 <__sflush_r+0xf8>
8112b170:	28c00117 	ldw	r3,4(r5)
8112b174:	10820014 	ori	r2,r2,2048
8112b178:	2880030d 	sth	r2,12(r5)
8112b17c:	00c04b0e 	bge	zero,r3,8112b2ac <__sflush_r+0x170>
8112b180:	8a000a17 	ldw	r8,40(r17)
8112b184:	40002326 	beq	r8,zero,8112b214 <__sflush_r+0xd8>
8112b188:	9c000017 	ldw	r16,0(r19)
8112b18c:	10c4000c 	andi	r3,r2,4096
8112b190:	98000015 	stw	zero,0(r19)
8112b194:	18004826 	beq	r3,zero,8112b2b8 <__sflush_r+0x17c>
8112b198:	89801417 	ldw	r6,80(r17)
8112b19c:	10c0010c 	andi	r3,r2,4
8112b1a0:	18000626 	beq	r3,zero,8112b1bc <__sflush_r+0x80>
8112b1a4:	88c00117 	ldw	r3,4(r17)
8112b1a8:	88800c17 	ldw	r2,48(r17)
8112b1ac:	30cdc83a 	sub	r6,r6,r3
8112b1b0:	10000226 	beq	r2,zero,8112b1bc <__sflush_r+0x80>
8112b1b4:	88800f17 	ldw	r2,60(r17)
8112b1b8:	308dc83a 	sub	r6,r6,r2
8112b1bc:	89400717 	ldw	r5,28(r17)
8112b1c0:	000f883a 	mov	r7,zero
8112b1c4:	9809883a 	mov	r4,r19
8112b1c8:	403ee83a 	callr	r8
8112b1cc:	00ffffc4 	movi	r3,-1
8112b1d0:	10c04426 	beq	r2,r3,8112b2e4 <__sflush_r+0x1a8>
8112b1d4:	88c0030b 	ldhu	r3,12(r17)
8112b1d8:	89000417 	ldw	r4,16(r17)
8112b1dc:	88000115 	stw	zero,4(r17)
8112b1e0:	197dffcc 	andi	r5,r3,63487
8112b1e4:	8940030d 	sth	r5,12(r17)
8112b1e8:	89000015 	stw	r4,0(r17)
8112b1ec:	18c4000c 	andi	r3,r3,4096
8112b1f0:	18002c1e 	bne	r3,zero,8112b2a4 <__sflush_r+0x168>
8112b1f4:	89400c17 	ldw	r5,48(r17)
8112b1f8:	9c000015 	stw	r16,0(r19)
8112b1fc:	28000526 	beq	r5,zero,8112b214 <__sflush_r+0xd8>
8112b200:	88801004 	addi	r2,r17,64
8112b204:	28800226 	beq	r5,r2,8112b210 <__sflush_r+0xd4>
8112b208:	9809883a 	mov	r4,r19
8112b20c:	112bbf40 	call	8112bbf4 <_free_r>
8112b210:	88000c15 	stw	zero,48(r17)
8112b214:	0005883a 	mov	r2,zero
8112b218:	dfc00417 	ldw	ra,16(sp)
8112b21c:	dcc00317 	ldw	r19,12(sp)
8112b220:	dc800217 	ldw	r18,8(sp)
8112b224:	dc400117 	ldw	r17,4(sp)
8112b228:	dc000017 	ldw	r16,0(sp)
8112b22c:	dec00504 	addi	sp,sp,20
8112b230:	f800283a 	ret
8112b234:	2c800417 	ldw	r18,16(r5)
8112b238:	903ff626 	beq	r18,zero,8112b214 <__reset+0xfb10b214>
8112b23c:	2c000017 	ldw	r16,0(r5)
8112b240:	108000cc 	andi	r2,r2,3
8112b244:	2c800015 	stw	r18,0(r5)
8112b248:	84a1c83a 	sub	r16,r16,r18
8112b24c:	1000131e 	bne	r2,zero,8112b29c <__sflush_r+0x160>
8112b250:	28800517 	ldw	r2,20(r5)
8112b254:	88800215 	stw	r2,8(r17)
8112b258:	04000316 	blt	zero,r16,8112b268 <__sflush_r+0x12c>
8112b25c:	003fed06 	br	8112b214 <__reset+0xfb10b214>
8112b260:	90a5883a 	add	r18,r18,r2
8112b264:	043feb0e 	bge	zero,r16,8112b214 <__reset+0xfb10b214>
8112b268:	88800917 	ldw	r2,36(r17)
8112b26c:	89400717 	ldw	r5,28(r17)
8112b270:	800f883a 	mov	r7,r16
8112b274:	900d883a 	mov	r6,r18
8112b278:	9809883a 	mov	r4,r19
8112b27c:	103ee83a 	callr	r2
8112b280:	80a1c83a 	sub	r16,r16,r2
8112b284:	00bff616 	blt	zero,r2,8112b260 <__reset+0xfb10b260>
8112b288:	88c0030b 	ldhu	r3,12(r17)
8112b28c:	00bfffc4 	movi	r2,-1
8112b290:	18c01014 	ori	r3,r3,64
8112b294:	88c0030d 	sth	r3,12(r17)
8112b298:	003fdf06 	br	8112b218 <__reset+0xfb10b218>
8112b29c:	0005883a 	mov	r2,zero
8112b2a0:	003fec06 	br	8112b254 <__reset+0xfb10b254>
8112b2a4:	88801415 	stw	r2,80(r17)
8112b2a8:	003fd206 	br	8112b1f4 <__reset+0xfb10b1f4>
8112b2ac:	28c00f17 	ldw	r3,60(r5)
8112b2b0:	00ffb316 	blt	zero,r3,8112b180 <__reset+0xfb10b180>
8112b2b4:	003fd706 	br	8112b214 <__reset+0xfb10b214>
8112b2b8:	89400717 	ldw	r5,28(r17)
8112b2bc:	000d883a 	mov	r6,zero
8112b2c0:	01c00044 	movi	r7,1
8112b2c4:	9809883a 	mov	r4,r19
8112b2c8:	403ee83a 	callr	r8
8112b2cc:	100d883a 	mov	r6,r2
8112b2d0:	00bfffc4 	movi	r2,-1
8112b2d4:	30801426 	beq	r6,r2,8112b328 <__sflush_r+0x1ec>
8112b2d8:	8880030b 	ldhu	r2,12(r17)
8112b2dc:	8a000a17 	ldw	r8,40(r17)
8112b2e0:	003fae06 	br	8112b19c <__reset+0xfb10b19c>
8112b2e4:	98c00017 	ldw	r3,0(r19)
8112b2e8:	183fba26 	beq	r3,zero,8112b1d4 <__reset+0xfb10b1d4>
8112b2ec:	01000744 	movi	r4,29
8112b2f0:	19000626 	beq	r3,r4,8112b30c <__sflush_r+0x1d0>
8112b2f4:	01000584 	movi	r4,22
8112b2f8:	19000426 	beq	r3,r4,8112b30c <__sflush_r+0x1d0>
8112b2fc:	88c0030b 	ldhu	r3,12(r17)
8112b300:	18c01014 	ori	r3,r3,64
8112b304:	88c0030d 	sth	r3,12(r17)
8112b308:	003fc306 	br	8112b218 <__reset+0xfb10b218>
8112b30c:	8880030b 	ldhu	r2,12(r17)
8112b310:	88c00417 	ldw	r3,16(r17)
8112b314:	88000115 	stw	zero,4(r17)
8112b318:	10bdffcc 	andi	r2,r2,63487
8112b31c:	8880030d 	sth	r2,12(r17)
8112b320:	88c00015 	stw	r3,0(r17)
8112b324:	003fb306 	br	8112b1f4 <__reset+0xfb10b1f4>
8112b328:	98800017 	ldw	r2,0(r19)
8112b32c:	103fea26 	beq	r2,zero,8112b2d8 <__reset+0xfb10b2d8>
8112b330:	00c00744 	movi	r3,29
8112b334:	10c00226 	beq	r2,r3,8112b340 <__sflush_r+0x204>
8112b338:	00c00584 	movi	r3,22
8112b33c:	10c0031e 	bne	r2,r3,8112b34c <__sflush_r+0x210>
8112b340:	9c000015 	stw	r16,0(r19)
8112b344:	0005883a 	mov	r2,zero
8112b348:	003fb306 	br	8112b218 <__reset+0xfb10b218>
8112b34c:	88c0030b 	ldhu	r3,12(r17)
8112b350:	3005883a 	mov	r2,r6
8112b354:	18c01014 	ori	r3,r3,64
8112b358:	88c0030d 	sth	r3,12(r17)
8112b35c:	003fae06 	br	8112b218 <__reset+0xfb10b218>

8112b360 <_fflush_r>:
8112b360:	defffd04 	addi	sp,sp,-12
8112b364:	de00012e 	bgeu	sp,et,8112b36c <_fflush_r+0xc>
8112b368:	003b68fa 	trap	3
8112b36c:	dc000115 	stw	r16,4(sp)
8112b370:	dfc00215 	stw	ra,8(sp)
8112b374:	2021883a 	mov	r16,r4
8112b378:	20000226 	beq	r4,zero,8112b384 <_fflush_r+0x24>
8112b37c:	20800e17 	ldw	r2,56(r4)
8112b380:	10000c26 	beq	r2,zero,8112b3b4 <_fflush_r+0x54>
8112b384:	2880030f 	ldh	r2,12(r5)
8112b388:	1000051e 	bne	r2,zero,8112b3a0 <_fflush_r+0x40>
8112b38c:	0005883a 	mov	r2,zero
8112b390:	dfc00217 	ldw	ra,8(sp)
8112b394:	dc000117 	ldw	r16,4(sp)
8112b398:	dec00304 	addi	sp,sp,12
8112b39c:	f800283a 	ret
8112b3a0:	8009883a 	mov	r4,r16
8112b3a4:	dfc00217 	ldw	ra,8(sp)
8112b3a8:	dc000117 	ldw	r16,4(sp)
8112b3ac:	dec00304 	addi	sp,sp,12
8112b3b0:	112b13c1 	jmpi	8112b13c <__sflush_r>
8112b3b4:	d9400015 	stw	r5,0(sp)
8112b3b8:	112b75c0 	call	8112b75c <__sinit>
8112b3bc:	d9400017 	ldw	r5,0(sp)
8112b3c0:	003ff006 	br	8112b384 <__reset+0xfb10b384>

8112b3c4 <fflush>:
8112b3c4:	20000526 	beq	r4,zero,8112b3dc <fflush+0x18>
8112b3c8:	00a04574 	movhi	r2,33045
8112b3cc:	108d0f04 	addi	r2,r2,13372
8112b3d0:	200b883a 	mov	r5,r4
8112b3d4:	11000017 	ldw	r4,0(r2)
8112b3d8:	112b3601 	jmpi	8112b360 <_fflush_r>
8112b3dc:	00a04574 	movhi	r2,33045
8112b3e0:	108d0e04 	addi	r2,r2,13368
8112b3e4:	11000017 	ldw	r4,0(r2)
8112b3e8:	016044f4 	movhi	r5,33043
8112b3ec:	296cd804 	addi	r5,r5,-19616
8112b3f0:	112c49c1 	jmpi	8112c49c <_fwalk_reent>

8112b3f4 <__fp_unlock>:
8112b3f4:	0005883a 	mov	r2,zero
8112b3f8:	f800283a 	ret

8112b3fc <_cleanup_r>:
8112b3fc:	016044f4 	movhi	r5,33043
8112b400:	294bb404 	addi	r5,r5,11984
8112b404:	112c49c1 	jmpi	8112c49c <_fwalk_reent>

8112b408 <__sinit.part.1>:
8112b408:	defff704 	addi	sp,sp,-36
8112b40c:	00e044f4 	movhi	r3,33043
8112b410:	de00012e 	bgeu	sp,et,8112b418 <__sinit.part.1+0x10>
8112b414:	003b68fa 	trap	3
8112b418:	18ecff04 	addi	r3,r3,-19460
8112b41c:	dfc00815 	stw	ra,32(sp)
8112b420:	ddc00715 	stw	r23,28(sp)
8112b424:	dd800615 	stw	r22,24(sp)
8112b428:	dd400515 	stw	r21,20(sp)
8112b42c:	dd000415 	stw	r20,16(sp)
8112b430:	dcc00315 	stw	r19,12(sp)
8112b434:	dc800215 	stw	r18,8(sp)
8112b438:	dc400115 	stw	r17,4(sp)
8112b43c:	dc000015 	stw	r16,0(sp)
8112b440:	24000117 	ldw	r16,4(r4)
8112b444:	20c00f15 	stw	r3,60(r4)
8112b448:	2080bb04 	addi	r2,r4,748
8112b44c:	00c000c4 	movi	r3,3
8112b450:	20c0b915 	stw	r3,740(r4)
8112b454:	2080ba15 	stw	r2,744(r4)
8112b458:	2000b815 	stw	zero,736(r4)
8112b45c:	05c00204 	movi	r23,8
8112b460:	00800104 	movi	r2,4
8112b464:	2025883a 	mov	r18,r4
8112b468:	b80d883a 	mov	r6,r23
8112b46c:	81001704 	addi	r4,r16,92
8112b470:	000b883a 	mov	r5,zero
8112b474:	80000015 	stw	zero,0(r16)
8112b478:	80000115 	stw	zero,4(r16)
8112b47c:	80000215 	stw	zero,8(r16)
8112b480:	8080030d 	sth	r2,12(r16)
8112b484:	80001915 	stw	zero,100(r16)
8112b488:	8000038d 	sth	zero,14(r16)
8112b48c:	80000415 	stw	zero,16(r16)
8112b490:	80000515 	stw	zero,20(r16)
8112b494:	80000615 	stw	zero,24(r16)
8112b498:	11227e00 	call	811227e0 <memset>
8112b49c:	05a044b4 	movhi	r22,33042
8112b4a0:	94400217 	ldw	r17,8(r18)
8112b4a4:	056044b4 	movhi	r21,33042
8112b4a8:	052044b4 	movhi	r20,33042
8112b4ac:	04e044b4 	movhi	r19,33042
8112b4b0:	b58bf904 	addi	r22,r22,12260
8112b4b4:	ad4c1204 	addi	r21,r21,12360
8112b4b8:	a50c3304 	addi	r20,r20,12492
8112b4bc:	9ccc4c04 	addi	r19,r19,12592
8112b4c0:	85800815 	stw	r22,32(r16)
8112b4c4:	85400915 	stw	r21,36(r16)
8112b4c8:	85000a15 	stw	r20,40(r16)
8112b4cc:	84c00b15 	stw	r19,44(r16)
8112b4d0:	84000715 	stw	r16,28(r16)
8112b4d4:	00800284 	movi	r2,10
8112b4d8:	8880030d 	sth	r2,12(r17)
8112b4dc:	00800044 	movi	r2,1
8112b4e0:	b80d883a 	mov	r6,r23
8112b4e4:	89001704 	addi	r4,r17,92
8112b4e8:	000b883a 	mov	r5,zero
8112b4ec:	88000015 	stw	zero,0(r17)
8112b4f0:	88000115 	stw	zero,4(r17)
8112b4f4:	88000215 	stw	zero,8(r17)
8112b4f8:	88001915 	stw	zero,100(r17)
8112b4fc:	8880038d 	sth	r2,14(r17)
8112b500:	88000415 	stw	zero,16(r17)
8112b504:	88000515 	stw	zero,20(r17)
8112b508:	88000615 	stw	zero,24(r17)
8112b50c:	11227e00 	call	811227e0 <memset>
8112b510:	94000317 	ldw	r16,12(r18)
8112b514:	00800484 	movi	r2,18
8112b518:	8c400715 	stw	r17,28(r17)
8112b51c:	8d800815 	stw	r22,32(r17)
8112b520:	8d400915 	stw	r21,36(r17)
8112b524:	8d000a15 	stw	r20,40(r17)
8112b528:	8cc00b15 	stw	r19,44(r17)
8112b52c:	8080030d 	sth	r2,12(r16)
8112b530:	00800084 	movi	r2,2
8112b534:	80000015 	stw	zero,0(r16)
8112b538:	80000115 	stw	zero,4(r16)
8112b53c:	80000215 	stw	zero,8(r16)
8112b540:	80001915 	stw	zero,100(r16)
8112b544:	8080038d 	sth	r2,14(r16)
8112b548:	80000415 	stw	zero,16(r16)
8112b54c:	80000515 	stw	zero,20(r16)
8112b550:	80000615 	stw	zero,24(r16)
8112b554:	b80d883a 	mov	r6,r23
8112b558:	000b883a 	mov	r5,zero
8112b55c:	81001704 	addi	r4,r16,92
8112b560:	11227e00 	call	811227e0 <memset>
8112b564:	00800044 	movi	r2,1
8112b568:	84000715 	stw	r16,28(r16)
8112b56c:	85800815 	stw	r22,32(r16)
8112b570:	85400915 	stw	r21,36(r16)
8112b574:	85000a15 	stw	r20,40(r16)
8112b578:	84c00b15 	stw	r19,44(r16)
8112b57c:	90800e15 	stw	r2,56(r18)
8112b580:	dfc00817 	ldw	ra,32(sp)
8112b584:	ddc00717 	ldw	r23,28(sp)
8112b588:	dd800617 	ldw	r22,24(sp)
8112b58c:	dd400517 	ldw	r21,20(sp)
8112b590:	dd000417 	ldw	r20,16(sp)
8112b594:	dcc00317 	ldw	r19,12(sp)
8112b598:	dc800217 	ldw	r18,8(sp)
8112b59c:	dc400117 	ldw	r17,4(sp)
8112b5a0:	dc000017 	ldw	r16,0(sp)
8112b5a4:	dec00904 	addi	sp,sp,36
8112b5a8:	f800283a 	ret

8112b5ac <__fp_lock>:
8112b5ac:	0005883a 	mov	r2,zero
8112b5b0:	f800283a 	ret

8112b5b4 <__sfmoreglue>:
8112b5b4:	defffc04 	addi	sp,sp,-16
8112b5b8:	de00012e 	bgeu	sp,et,8112b5c0 <__sfmoreglue+0xc>
8112b5bc:	003b68fa 	trap	3
8112b5c0:	dc400115 	stw	r17,4(sp)
8112b5c4:	2c7fffc4 	addi	r17,r5,-1
8112b5c8:	8c401a24 	muli	r17,r17,104
8112b5cc:	dc800215 	stw	r18,8(sp)
8112b5d0:	2825883a 	mov	r18,r5
8112b5d4:	89401d04 	addi	r5,r17,116
8112b5d8:	dc000015 	stw	r16,0(sp)
8112b5dc:	dfc00315 	stw	ra,12(sp)
8112b5e0:	1121e7c0 	call	81121e7c <_malloc_r>
8112b5e4:	1021883a 	mov	r16,r2
8112b5e8:	10000726 	beq	r2,zero,8112b608 <__sfmoreglue+0x54>
8112b5ec:	11000304 	addi	r4,r2,12
8112b5f0:	10000015 	stw	zero,0(r2)
8112b5f4:	14800115 	stw	r18,4(r2)
8112b5f8:	11000215 	stw	r4,8(r2)
8112b5fc:	89801a04 	addi	r6,r17,104
8112b600:	000b883a 	mov	r5,zero
8112b604:	11227e00 	call	811227e0 <memset>
8112b608:	8005883a 	mov	r2,r16
8112b60c:	dfc00317 	ldw	ra,12(sp)
8112b610:	dc800217 	ldw	r18,8(sp)
8112b614:	dc400117 	ldw	r17,4(sp)
8112b618:	dc000017 	ldw	r16,0(sp)
8112b61c:	dec00404 	addi	sp,sp,16
8112b620:	f800283a 	ret

8112b624 <__sfp>:
8112b624:	defffb04 	addi	sp,sp,-20
8112b628:	de00012e 	bgeu	sp,et,8112b630 <__sfp+0xc>
8112b62c:	003b68fa 	trap	3
8112b630:	dc000015 	stw	r16,0(sp)
8112b634:	04204574 	movhi	r16,33045
8112b638:	840d0e04 	addi	r16,r16,13368
8112b63c:	dcc00315 	stw	r19,12(sp)
8112b640:	2027883a 	mov	r19,r4
8112b644:	81000017 	ldw	r4,0(r16)
8112b648:	dfc00415 	stw	ra,16(sp)
8112b64c:	dc800215 	stw	r18,8(sp)
8112b650:	20800e17 	ldw	r2,56(r4)
8112b654:	dc400115 	stw	r17,4(sp)
8112b658:	1000021e 	bne	r2,zero,8112b664 <__sfp+0x40>
8112b65c:	112b4080 	call	8112b408 <__sinit.part.1>
8112b660:	81000017 	ldw	r4,0(r16)
8112b664:	2480b804 	addi	r18,r4,736
8112b668:	047fffc4 	movi	r17,-1
8112b66c:	91000117 	ldw	r4,4(r18)
8112b670:	94000217 	ldw	r16,8(r18)
8112b674:	213fffc4 	addi	r4,r4,-1
8112b678:	20000a16 	blt	r4,zero,8112b6a4 <__sfp+0x80>
8112b67c:	8080030f 	ldh	r2,12(r16)
8112b680:	10000c26 	beq	r2,zero,8112b6b4 <__sfp+0x90>
8112b684:	80c01d04 	addi	r3,r16,116
8112b688:	00000206 	br	8112b694 <__sfp+0x70>
8112b68c:	18bfe60f 	ldh	r2,-104(r3)
8112b690:	10000826 	beq	r2,zero,8112b6b4 <__sfp+0x90>
8112b694:	213fffc4 	addi	r4,r4,-1
8112b698:	1c3ffd04 	addi	r16,r3,-12
8112b69c:	18c01a04 	addi	r3,r3,104
8112b6a0:	247ffa1e 	bne	r4,r17,8112b68c <__reset+0xfb10b68c>
8112b6a4:	90800017 	ldw	r2,0(r18)
8112b6a8:	10001d26 	beq	r2,zero,8112b720 <__sfp+0xfc>
8112b6ac:	1025883a 	mov	r18,r2
8112b6b0:	003fee06 	br	8112b66c <__reset+0xfb10b66c>
8112b6b4:	00bfffc4 	movi	r2,-1
8112b6b8:	8080038d 	sth	r2,14(r16)
8112b6bc:	00800044 	movi	r2,1
8112b6c0:	8080030d 	sth	r2,12(r16)
8112b6c4:	80001915 	stw	zero,100(r16)
8112b6c8:	80000015 	stw	zero,0(r16)
8112b6cc:	80000215 	stw	zero,8(r16)
8112b6d0:	80000115 	stw	zero,4(r16)
8112b6d4:	80000415 	stw	zero,16(r16)
8112b6d8:	80000515 	stw	zero,20(r16)
8112b6dc:	80000615 	stw	zero,24(r16)
8112b6e0:	01800204 	movi	r6,8
8112b6e4:	000b883a 	mov	r5,zero
8112b6e8:	81001704 	addi	r4,r16,92
8112b6ec:	11227e00 	call	811227e0 <memset>
8112b6f0:	8005883a 	mov	r2,r16
8112b6f4:	80000c15 	stw	zero,48(r16)
8112b6f8:	80000d15 	stw	zero,52(r16)
8112b6fc:	80001115 	stw	zero,68(r16)
8112b700:	80001215 	stw	zero,72(r16)
8112b704:	dfc00417 	ldw	ra,16(sp)
8112b708:	dcc00317 	ldw	r19,12(sp)
8112b70c:	dc800217 	ldw	r18,8(sp)
8112b710:	dc400117 	ldw	r17,4(sp)
8112b714:	dc000017 	ldw	r16,0(sp)
8112b718:	dec00504 	addi	sp,sp,20
8112b71c:	f800283a 	ret
8112b720:	01400104 	movi	r5,4
8112b724:	9809883a 	mov	r4,r19
8112b728:	112b5b40 	call	8112b5b4 <__sfmoreglue>
8112b72c:	90800015 	stw	r2,0(r18)
8112b730:	103fde1e 	bne	r2,zero,8112b6ac <__reset+0xfb10b6ac>
8112b734:	00800304 	movi	r2,12
8112b738:	98800015 	stw	r2,0(r19)
8112b73c:	0005883a 	mov	r2,zero
8112b740:	003ff006 	br	8112b704 <__reset+0xfb10b704>

8112b744 <_cleanup>:
8112b744:	00a04574 	movhi	r2,33045
8112b748:	108d0e04 	addi	r2,r2,13368
8112b74c:	11000017 	ldw	r4,0(r2)
8112b750:	016044f4 	movhi	r5,33043
8112b754:	294bb404 	addi	r5,r5,11984
8112b758:	112c49c1 	jmpi	8112c49c <_fwalk_reent>

8112b75c <__sinit>:
8112b75c:	20800e17 	ldw	r2,56(r4)
8112b760:	10000126 	beq	r2,zero,8112b768 <__sinit+0xc>
8112b764:	f800283a 	ret
8112b768:	112b4081 	jmpi	8112b408 <__sinit.part.1>

8112b76c <__sfp_lock_acquire>:
8112b76c:	f800283a 	ret

8112b770 <__sfp_lock_release>:
8112b770:	f800283a 	ret

8112b774 <__sinit_lock_acquire>:
8112b774:	f800283a 	ret

8112b778 <__sinit_lock_release>:
8112b778:	f800283a 	ret

8112b77c <__fp_lock_all>:
8112b77c:	00a04574 	movhi	r2,33045
8112b780:	108d0f04 	addi	r2,r2,13372
8112b784:	11000017 	ldw	r4,0(r2)
8112b788:	016044f4 	movhi	r5,33043
8112b78c:	296d6b04 	addi	r5,r5,-19028
8112b790:	112c3d01 	jmpi	8112c3d0 <_fwalk>

8112b794 <__fp_unlock_all>:
8112b794:	00a04574 	movhi	r2,33045
8112b798:	108d0f04 	addi	r2,r2,13372
8112b79c:	11000017 	ldw	r4,0(r2)
8112b7a0:	016044f4 	movhi	r5,33043
8112b7a4:	296cfd04 	addi	r5,r5,-19468
8112b7a8:	112c3d01 	jmpi	8112c3d0 <_fwalk>

8112b7ac <__sflags>:
8112b7ac:	28800007 	ldb	r2,0(r5)
8112b7b0:	00c01c84 	movi	r3,114
8112b7b4:	10c02426 	beq	r2,r3,8112b848 <__sflags+0x9c>
8112b7b8:	00c01dc4 	movi	r3,119
8112b7bc:	10c01e26 	beq	r2,r3,8112b838 <__sflags+0x8c>
8112b7c0:	00c01844 	movi	r3,97
8112b7c4:	10c00426 	beq	r2,r3,8112b7d8 <__sflags+0x2c>
8112b7c8:	00800584 	movi	r2,22
8112b7cc:	20800015 	stw	r2,0(r4)
8112b7d0:	0005883a 	mov	r2,zero
8112b7d4:	f800283a 	ret
8112b7d8:	02c08204 	movi	r11,520
8112b7dc:	01000044 	movi	r4,1
8112b7e0:	00804204 	movi	r2,264
8112b7e4:	01c00ac4 	movi	r7,43
8112b7e8:	02bff8c4 	movi	r10,-29
8112b7ec:	027fff04 	movi	r9,-4
8112b7f0:	02001e04 	movi	r8,120
8112b7f4:	29400044 	addi	r5,r5,1
8112b7f8:	28c00007 	ldb	r3,0(r5)
8112b7fc:	18000626 	beq	r3,zero,8112b818 <__sflags+0x6c>
8112b800:	19c00826 	beq	r3,r7,8112b824 <__sflags+0x78>
8112b804:	1a3ffb1e 	bne	r3,r8,8112b7f4 <__reset+0xfb10b7f4>
8112b808:	29400044 	addi	r5,r5,1
8112b80c:	28c00007 	ldb	r3,0(r5)
8112b810:	21020014 	ori	r4,r4,2048
8112b814:	183ffa1e 	bne	r3,zero,8112b800 <__reset+0xfb10b800>
8112b818:	22c8b03a 	or	r4,r4,r11
8112b81c:	31000015 	stw	r4,0(r6)
8112b820:	f800283a 	ret
8112b824:	1284703a 	and	r2,r2,r10
8112b828:	2248703a 	and	r4,r4,r9
8112b82c:	10800414 	ori	r2,r2,16
8112b830:	21000094 	ori	r4,r4,2
8112b834:	003fef06 	br	8112b7f4 <__reset+0xfb10b7f4>
8112b838:	02c18004 	movi	r11,1536
8112b83c:	01000044 	movi	r4,1
8112b840:	00800204 	movi	r2,8
8112b844:	003fe706 	br	8112b7e4 <__reset+0xfb10b7e4>
8112b848:	0017883a 	mov	r11,zero
8112b84c:	0009883a 	mov	r4,zero
8112b850:	00800104 	movi	r2,4
8112b854:	003fe306 	br	8112b7e4 <__reset+0xfb10b7e4>

8112b858 <_fread_r>:
8112b858:	defff404 	addi	sp,sp,-48
8112b85c:	de00012e 	bgeu	sp,et,8112b864 <_fread_r+0xc>
8112b860:	003b68fa 	trap	3
8112b864:	dd800815 	stw	r22,32(sp)
8112b868:	39ad383a 	mul	r22,r7,r6
8112b86c:	dc000215 	stw	r16,8(sp)
8112b870:	dfc00b15 	stw	ra,44(sp)
8112b874:	df000a15 	stw	fp,40(sp)
8112b878:	ddc00915 	stw	r23,36(sp)
8112b87c:	dd400715 	stw	r21,28(sp)
8112b880:	dd000615 	stw	r20,24(sp)
8112b884:	dcc00515 	stw	r19,20(sp)
8112b888:	dc800415 	stw	r18,16(sp)
8112b88c:	dc400315 	stw	r17,12(sp)
8112b890:	dc000c17 	ldw	r16,48(sp)
8112b894:	b0003b26 	beq	r22,zero,8112b984 <_fread_r+0x12c>
8112b898:	302f883a 	mov	r23,r6
8112b89c:	382b883a 	mov	r21,r7
8112b8a0:	2029883a 	mov	r20,r4
8112b8a4:	2827883a 	mov	r19,r5
8112b8a8:	20000226 	beq	r4,zero,8112b8b4 <_fread_r+0x5c>
8112b8ac:	20800e17 	ldw	r2,56(r4)
8112b8b0:	10006e26 	beq	r2,zero,8112ba6c <_fread_r+0x214>
8112b8b4:	8080030b 	ldhu	r2,12(r16)
8112b8b8:	10c8000c 	andi	r3,r2,8192
8112b8bc:	1800061e 	bne	r3,zero,8112b8d8 <_fread_r+0x80>
8112b8c0:	81001917 	ldw	r4,100(r16)
8112b8c4:	00f7ffc4 	movi	r3,-8193
8112b8c8:	10880014 	ori	r2,r2,8192
8112b8cc:	20c6703a 	and	r3,r4,r3
8112b8d0:	8080030d 	sth	r2,12(r16)
8112b8d4:	80c01915 	stw	r3,100(r16)
8112b8d8:	84400117 	ldw	r17,4(r16)
8112b8dc:	88005f16 	blt	r17,zero,8112ba5c <_fread_r+0x204>
8112b8e0:	8809883a 	mov	r4,r17
8112b8e4:	1080008c 	andi	r2,r2,2
8112b8e8:	1000281e 	bne	r2,zero,8112b98c <_fread_r+0x134>
8112b8ec:	b025883a 	mov	r18,r22
8112b8f0:	00000b06 	br	8112b920 <_fread_r+0xc8>
8112b8f4:	11226900 	call	81122690 <memcpy>
8112b8f8:	80800017 	ldw	r2,0(r16)
8112b8fc:	9c67883a 	add	r19,r19,r17
8112b900:	9465c83a 	sub	r18,r18,r17
8112b904:	1463883a 	add	r17,r2,r17
8112b908:	800b883a 	mov	r5,r16
8112b90c:	a009883a 	mov	r4,r20
8112b910:	84400015 	stw	r17,0(r16)
8112b914:	1122c5c0 	call	81122c5c <__srefill_r>
8112b918:	10004c1e 	bne	r2,zero,8112ba4c <_fread_r+0x1f4>
8112b91c:	84400117 	ldw	r17,4(r16)
8112b920:	880d883a 	mov	r6,r17
8112b924:	9809883a 	mov	r4,r19
8112b928:	81400017 	ldw	r5,0(r16)
8112b92c:	8cbff136 	bltu	r17,r18,8112b8f4 <__reset+0xfb10b8f4>
8112b930:	900d883a 	mov	r6,r18
8112b934:	11226900 	call	81122690 <memcpy>
8112b938:	80c00117 	ldw	r3,4(r16)
8112b93c:	81000017 	ldw	r4,0(r16)
8112b940:	a805883a 	mov	r2,r21
8112b944:	1c87c83a 	sub	r3,r3,r18
8112b948:	24a5883a 	add	r18,r4,r18
8112b94c:	80c00115 	stw	r3,4(r16)
8112b950:	84800015 	stw	r18,0(r16)
8112b954:	dfc00b17 	ldw	ra,44(sp)
8112b958:	df000a17 	ldw	fp,40(sp)
8112b95c:	ddc00917 	ldw	r23,36(sp)
8112b960:	dd800817 	ldw	r22,32(sp)
8112b964:	dd400717 	ldw	r21,28(sp)
8112b968:	dd000617 	ldw	r20,24(sp)
8112b96c:	dcc00517 	ldw	r19,20(sp)
8112b970:	dc800417 	ldw	r18,16(sp)
8112b974:	dc400317 	ldw	r17,12(sp)
8112b978:	dc000217 	ldw	r16,8(sp)
8112b97c:	dec00c04 	addi	sp,sp,48
8112b980:	f800283a 	ret
8112b984:	0005883a 	mov	r2,zero
8112b988:	003ff206 	br	8112b954 <__reset+0xfb10b954>
8112b98c:	b007883a 	mov	r3,r22
8112b990:	2580012e 	bgeu	r4,r22,8112b998 <_fread_r+0x140>
8112b994:	2007883a 	mov	r3,r4
8112b998:	81400017 	ldw	r5,0(r16)
8112b99c:	180d883a 	mov	r6,r3
8112b9a0:	9809883a 	mov	r4,r19
8112b9a4:	d8c00115 	stw	r3,4(sp)
8112b9a8:	11226900 	call	81122690 <memcpy>
8112b9ac:	d8c00117 	ldw	r3,4(sp)
8112b9b0:	84400017 	ldw	r17,0(r16)
8112b9b4:	80800117 	ldw	r2,4(r16)
8112b9b8:	81400c17 	ldw	r5,48(r16)
8112b9bc:	88e3883a 	add	r17,r17,r3
8112b9c0:	10c5c83a 	sub	r2,r2,r3
8112b9c4:	84400015 	stw	r17,0(r16)
8112b9c8:	80800115 	stw	r2,4(r16)
8112b9cc:	b0e5c83a 	sub	r18,r22,r3
8112b9d0:	28002b26 	beq	r5,zero,8112ba80 <_fread_r+0x228>
8112b9d4:	90002b26 	beq	r18,zero,8112ba84 <_fread_r+0x22c>
8112b9d8:	80801004 	addi	r2,r16,64
8112b9dc:	28800526 	beq	r5,r2,8112b9f4 <_fread_r+0x19c>
8112b9e0:	a009883a 	mov	r4,r20
8112b9e4:	d8c00115 	stw	r3,4(sp)
8112b9e8:	112bbf40 	call	8112bbf4 <_free_r>
8112b9ec:	d8c00117 	ldw	r3,4(sp)
8112b9f0:	84400017 	ldw	r17,0(r16)
8112b9f4:	80000c15 	stw	zero,48(r16)
8112b9f8:	80800517 	ldw	r2,20(r16)
8112b9fc:	87000417 	ldw	fp,16(r16)
8112ba00:	98e7883a 	add	r19,r19,r3
8112ba04:	d8800015 	stw	r2,0(sp)
8112ba08:	00000106 	br	8112ba10 <_fread_r+0x1b8>
8112ba0c:	90001d26 	beq	r18,zero,8112ba84 <_fread_r+0x22c>
8112ba10:	84c00415 	stw	r19,16(r16)
8112ba14:	84800515 	stw	r18,20(r16)
8112ba18:	84c00015 	stw	r19,0(r16)
8112ba1c:	a009883a 	mov	r4,r20
8112ba20:	800b883a 	mov	r5,r16
8112ba24:	1122c5c0 	call	81122c5c <__srefill_r>
8112ba28:	d9000017 	ldw	r4,0(sp)
8112ba2c:	80c00117 	ldw	r3,4(r16)
8112ba30:	87000415 	stw	fp,16(r16)
8112ba34:	81000515 	stw	r4,20(r16)
8112ba38:	84400015 	stw	r17,0(r16)
8112ba3c:	80000115 	stw	zero,4(r16)
8112ba40:	90e5c83a 	sub	r18,r18,r3
8112ba44:	98e7883a 	add	r19,r19,r3
8112ba48:	103ff026 	beq	r2,zero,8112ba0c <__reset+0xfb10ba0c>
8112ba4c:	b80b883a 	mov	r5,r23
8112ba50:	b489c83a 	sub	r4,r22,r18
8112ba54:	1134c180 	call	81134c18 <__udivsi3>
8112ba58:	003fbe06 	br	8112b954 <__reset+0xfb10b954>
8112ba5c:	80000115 	stw	zero,4(r16)
8112ba60:	0009883a 	mov	r4,zero
8112ba64:	0023883a 	mov	r17,zero
8112ba68:	003f9e06 	br	8112b8e4 <__reset+0xfb10b8e4>
8112ba6c:	112b75c0 	call	8112b75c <__sinit>
8112ba70:	8080030b 	ldhu	r2,12(r16)
8112ba74:	10c8000c 	andi	r3,r2,8192
8112ba78:	183f971e 	bne	r3,zero,8112b8d8 <__reset+0xfb10b8d8>
8112ba7c:	003f9006 	br	8112b8c0 <__reset+0xfb10b8c0>
8112ba80:	903fdd1e 	bne	r18,zero,8112b9f8 <__reset+0xfb10b9f8>
8112ba84:	a805883a 	mov	r2,r21
8112ba88:	003fb206 	br	8112b954 <__reset+0xfb10b954>

8112ba8c <fread>:
8112ba8c:	defffe04 	addi	sp,sp,-8
8112ba90:	00a04574 	movhi	r2,33045
8112ba94:	de00012e 	bgeu	sp,et,8112ba9c <fread+0x10>
8112ba98:	003b68fa 	trap	3
8112ba9c:	108d0f04 	addi	r2,r2,13372
8112baa0:	d9c00015 	stw	r7,0(sp)
8112baa4:	300f883a 	mov	r7,r6
8112baa8:	280d883a 	mov	r6,r5
8112baac:	200b883a 	mov	r5,r4
8112bab0:	11000017 	ldw	r4,0(r2)
8112bab4:	dfc00115 	stw	ra,4(sp)
8112bab8:	112b8580 	call	8112b858 <_fread_r>
8112babc:	dfc00117 	ldw	ra,4(sp)
8112bac0:	dec00204 	addi	sp,sp,8
8112bac4:	f800283a 	ret

8112bac8 <_malloc_trim_r>:
8112bac8:	defffb04 	addi	sp,sp,-20
8112bacc:	de00012e 	bgeu	sp,et,8112bad4 <_malloc_trim_r+0xc>
8112bad0:	003b68fa 	trap	3
8112bad4:	dcc00315 	stw	r19,12(sp)
8112bad8:	04e04574 	movhi	r19,33045
8112badc:	dc800215 	stw	r18,8(sp)
8112bae0:	dc400115 	stw	r17,4(sp)
8112bae4:	dc000015 	stw	r16,0(sp)
8112bae8:	dfc00415 	stw	ra,16(sp)
8112baec:	2821883a 	mov	r16,r5
8112baf0:	9cc6cd04 	addi	r19,r19,6964
8112baf4:	2025883a 	mov	r18,r4
8112baf8:	11380d40 	call	811380d4 <__malloc_lock>
8112bafc:	98800217 	ldw	r2,8(r19)
8112bb00:	14400117 	ldw	r17,4(r2)
8112bb04:	00bfff04 	movi	r2,-4
8112bb08:	88a2703a 	and	r17,r17,r2
8112bb0c:	8c21c83a 	sub	r16,r17,r16
8112bb10:	8403fbc4 	addi	r16,r16,4079
8112bb14:	8020d33a 	srli	r16,r16,12
8112bb18:	0083ffc4 	movi	r2,4095
8112bb1c:	843fffc4 	addi	r16,r16,-1
8112bb20:	8020933a 	slli	r16,r16,12
8112bb24:	1400060e 	bge	r2,r16,8112bb40 <_malloc_trim_r+0x78>
8112bb28:	000b883a 	mov	r5,zero
8112bb2c:	9009883a 	mov	r4,r18
8112bb30:	1122e380 	call	81122e38 <_sbrk_r>
8112bb34:	98c00217 	ldw	r3,8(r19)
8112bb38:	1c47883a 	add	r3,r3,r17
8112bb3c:	10c00a26 	beq	r2,r3,8112bb68 <_malloc_trim_r+0xa0>
8112bb40:	9009883a 	mov	r4,r18
8112bb44:	11381fc0 	call	811381fc <__malloc_unlock>
8112bb48:	0005883a 	mov	r2,zero
8112bb4c:	dfc00417 	ldw	ra,16(sp)
8112bb50:	dcc00317 	ldw	r19,12(sp)
8112bb54:	dc800217 	ldw	r18,8(sp)
8112bb58:	dc400117 	ldw	r17,4(sp)
8112bb5c:	dc000017 	ldw	r16,0(sp)
8112bb60:	dec00504 	addi	sp,sp,20
8112bb64:	f800283a 	ret
8112bb68:	040bc83a 	sub	r5,zero,r16
8112bb6c:	9009883a 	mov	r4,r18
8112bb70:	1122e380 	call	81122e38 <_sbrk_r>
8112bb74:	00ffffc4 	movi	r3,-1
8112bb78:	10c00d26 	beq	r2,r3,8112bbb0 <_malloc_trim_r+0xe8>
8112bb7c:	00e04574 	movhi	r3,33045
8112bb80:	18ce1204 	addi	r3,r3,14408
8112bb84:	18800017 	ldw	r2,0(r3)
8112bb88:	99000217 	ldw	r4,8(r19)
8112bb8c:	8c23c83a 	sub	r17,r17,r16
8112bb90:	8c400054 	ori	r17,r17,1
8112bb94:	1421c83a 	sub	r16,r2,r16
8112bb98:	24400115 	stw	r17,4(r4)
8112bb9c:	9009883a 	mov	r4,r18
8112bba0:	1c000015 	stw	r16,0(r3)
8112bba4:	11381fc0 	call	811381fc <__malloc_unlock>
8112bba8:	00800044 	movi	r2,1
8112bbac:	003fe706 	br	8112bb4c <__reset+0xfb10bb4c>
8112bbb0:	000b883a 	mov	r5,zero
8112bbb4:	9009883a 	mov	r4,r18
8112bbb8:	1122e380 	call	81122e38 <_sbrk_r>
8112bbbc:	99000217 	ldw	r4,8(r19)
8112bbc0:	014003c4 	movi	r5,15
8112bbc4:	1107c83a 	sub	r3,r2,r4
8112bbc8:	28ffdd0e 	bge	r5,r3,8112bb40 <__reset+0xfb10bb40>
8112bbcc:	01604574 	movhi	r5,33045
8112bbd0:	294d1004 	addi	r5,r5,13376
8112bbd4:	29400017 	ldw	r5,0(r5)
8112bbd8:	18c00054 	ori	r3,r3,1
8112bbdc:	20c00115 	stw	r3,4(r4)
8112bbe0:	00e04574 	movhi	r3,33045
8112bbe4:	1145c83a 	sub	r2,r2,r5
8112bbe8:	18ce1204 	addi	r3,r3,14408
8112bbec:	18800015 	stw	r2,0(r3)
8112bbf0:	003fd306 	br	8112bb40 <__reset+0xfb10bb40>

8112bbf4 <_free_r>:
8112bbf4:	28004326 	beq	r5,zero,8112bd04 <_free_r+0x110>
8112bbf8:	defffd04 	addi	sp,sp,-12
8112bbfc:	de00012e 	bgeu	sp,et,8112bc04 <_free_r+0x10>
8112bc00:	003b68fa 	trap	3
8112bc04:	dc400115 	stw	r17,4(sp)
8112bc08:	dc000015 	stw	r16,0(sp)
8112bc0c:	2023883a 	mov	r17,r4
8112bc10:	2821883a 	mov	r16,r5
8112bc14:	dfc00215 	stw	ra,8(sp)
8112bc18:	11380d40 	call	811380d4 <__malloc_lock>
8112bc1c:	81ffff17 	ldw	r7,-4(r16)
8112bc20:	00bfff84 	movi	r2,-2
8112bc24:	01204574 	movhi	r4,33045
8112bc28:	81bffe04 	addi	r6,r16,-8
8112bc2c:	3884703a 	and	r2,r7,r2
8112bc30:	2106cd04 	addi	r4,r4,6964
8112bc34:	308b883a 	add	r5,r6,r2
8112bc38:	2a400117 	ldw	r9,4(r5)
8112bc3c:	22000217 	ldw	r8,8(r4)
8112bc40:	00ffff04 	movi	r3,-4
8112bc44:	48c6703a 	and	r3,r9,r3
8112bc48:	2a005726 	beq	r5,r8,8112bda8 <_free_r+0x1b4>
8112bc4c:	28c00115 	stw	r3,4(r5)
8112bc50:	39c0004c 	andi	r7,r7,1
8112bc54:	3800091e 	bne	r7,zero,8112bc7c <_free_r+0x88>
8112bc58:	823ffe17 	ldw	r8,-8(r16)
8112bc5c:	22400204 	addi	r9,r4,8
8112bc60:	320dc83a 	sub	r6,r6,r8
8112bc64:	31c00217 	ldw	r7,8(r6)
8112bc68:	1205883a 	add	r2,r2,r8
8112bc6c:	3a406526 	beq	r7,r9,8112be04 <_free_r+0x210>
8112bc70:	32000317 	ldw	r8,12(r6)
8112bc74:	3a000315 	stw	r8,12(r7)
8112bc78:	41c00215 	stw	r7,8(r8)
8112bc7c:	28cf883a 	add	r7,r5,r3
8112bc80:	39c00117 	ldw	r7,4(r7)
8112bc84:	39c0004c 	andi	r7,r7,1
8112bc88:	38003a26 	beq	r7,zero,8112bd74 <_free_r+0x180>
8112bc8c:	10c00054 	ori	r3,r2,1
8112bc90:	30c00115 	stw	r3,4(r6)
8112bc94:	3087883a 	add	r3,r6,r2
8112bc98:	18800015 	stw	r2,0(r3)
8112bc9c:	00c07fc4 	movi	r3,511
8112bca0:	18801936 	bltu	r3,r2,8112bd08 <_free_r+0x114>
8112bca4:	1004d0fa 	srli	r2,r2,3
8112bca8:	01c00044 	movi	r7,1
8112bcac:	21400117 	ldw	r5,4(r4)
8112bcb0:	10c00044 	addi	r3,r2,1
8112bcb4:	18c7883a 	add	r3,r3,r3
8112bcb8:	1005d0ba 	srai	r2,r2,2
8112bcbc:	18c7883a 	add	r3,r3,r3
8112bcc0:	18c7883a 	add	r3,r3,r3
8112bcc4:	1907883a 	add	r3,r3,r4
8112bcc8:	3884983a 	sll	r2,r7,r2
8112bccc:	19c00017 	ldw	r7,0(r3)
8112bcd0:	1a3ffe04 	addi	r8,r3,-8
8112bcd4:	1144b03a 	or	r2,r2,r5
8112bcd8:	32000315 	stw	r8,12(r6)
8112bcdc:	31c00215 	stw	r7,8(r6)
8112bce0:	20800115 	stw	r2,4(r4)
8112bce4:	19800015 	stw	r6,0(r3)
8112bce8:	39800315 	stw	r6,12(r7)
8112bcec:	8809883a 	mov	r4,r17
8112bcf0:	dfc00217 	ldw	ra,8(sp)
8112bcf4:	dc400117 	ldw	r17,4(sp)
8112bcf8:	dc000017 	ldw	r16,0(sp)
8112bcfc:	dec00304 	addi	sp,sp,12
8112bd00:	11381fc1 	jmpi	811381fc <__malloc_unlock>
8112bd04:	f800283a 	ret
8112bd08:	100ad27a 	srli	r5,r2,9
8112bd0c:	00c00104 	movi	r3,4
8112bd10:	19404a36 	bltu	r3,r5,8112be3c <_free_r+0x248>
8112bd14:	100ad1ba 	srli	r5,r2,6
8112bd18:	28c00e44 	addi	r3,r5,57
8112bd1c:	18c7883a 	add	r3,r3,r3
8112bd20:	29400e04 	addi	r5,r5,56
8112bd24:	18c7883a 	add	r3,r3,r3
8112bd28:	18c7883a 	add	r3,r3,r3
8112bd2c:	1909883a 	add	r4,r3,r4
8112bd30:	20c00017 	ldw	r3,0(r4)
8112bd34:	01e04574 	movhi	r7,33045
8112bd38:	213ffe04 	addi	r4,r4,-8
8112bd3c:	39c6cd04 	addi	r7,r7,6964
8112bd40:	20c04426 	beq	r4,r3,8112be54 <_free_r+0x260>
8112bd44:	01ffff04 	movi	r7,-4
8112bd48:	19400117 	ldw	r5,4(r3)
8112bd4c:	29ca703a 	and	r5,r5,r7
8112bd50:	1140022e 	bgeu	r2,r5,8112bd5c <_free_r+0x168>
8112bd54:	18c00217 	ldw	r3,8(r3)
8112bd58:	20fffb1e 	bne	r4,r3,8112bd48 <__reset+0xfb10bd48>
8112bd5c:	19000317 	ldw	r4,12(r3)
8112bd60:	31000315 	stw	r4,12(r6)
8112bd64:	30c00215 	stw	r3,8(r6)
8112bd68:	21800215 	stw	r6,8(r4)
8112bd6c:	19800315 	stw	r6,12(r3)
8112bd70:	003fde06 	br	8112bcec <__reset+0xfb10bcec>
8112bd74:	29c00217 	ldw	r7,8(r5)
8112bd78:	10c5883a 	add	r2,r2,r3
8112bd7c:	00e04574 	movhi	r3,33045
8112bd80:	18c6cf04 	addi	r3,r3,6972
8112bd84:	38c03b26 	beq	r7,r3,8112be74 <_free_r+0x280>
8112bd88:	2a000317 	ldw	r8,12(r5)
8112bd8c:	11400054 	ori	r5,r2,1
8112bd90:	3087883a 	add	r3,r6,r2
8112bd94:	3a000315 	stw	r8,12(r7)
8112bd98:	41c00215 	stw	r7,8(r8)
8112bd9c:	31400115 	stw	r5,4(r6)
8112bda0:	18800015 	stw	r2,0(r3)
8112bda4:	003fbd06 	br	8112bc9c <__reset+0xfb10bc9c>
8112bda8:	39c0004c 	andi	r7,r7,1
8112bdac:	10c5883a 	add	r2,r2,r3
8112bdb0:	3800071e 	bne	r7,zero,8112bdd0 <_free_r+0x1dc>
8112bdb4:	81fffe17 	ldw	r7,-8(r16)
8112bdb8:	31cdc83a 	sub	r6,r6,r7
8112bdbc:	30c00317 	ldw	r3,12(r6)
8112bdc0:	31400217 	ldw	r5,8(r6)
8112bdc4:	11c5883a 	add	r2,r2,r7
8112bdc8:	28c00315 	stw	r3,12(r5)
8112bdcc:	19400215 	stw	r5,8(r3)
8112bdd0:	10c00054 	ori	r3,r2,1
8112bdd4:	30c00115 	stw	r3,4(r6)
8112bdd8:	00e04574 	movhi	r3,33045
8112bddc:	18cd1104 	addi	r3,r3,13380
8112bde0:	18c00017 	ldw	r3,0(r3)
8112bde4:	21800215 	stw	r6,8(r4)
8112bde8:	10ffc036 	bltu	r2,r3,8112bcec <__reset+0xfb10bcec>
8112bdec:	00a04574 	movhi	r2,33045
8112bdf0:	108d8504 	addi	r2,r2,13844
8112bdf4:	11400017 	ldw	r5,0(r2)
8112bdf8:	8809883a 	mov	r4,r17
8112bdfc:	112bac80 	call	8112bac8 <_malloc_trim_r>
8112be00:	003fba06 	br	8112bcec <__reset+0xfb10bcec>
8112be04:	28c9883a 	add	r4,r5,r3
8112be08:	21000117 	ldw	r4,4(r4)
8112be0c:	2100004c 	andi	r4,r4,1
8112be10:	2000391e 	bne	r4,zero,8112bef8 <_free_r+0x304>
8112be14:	29c00217 	ldw	r7,8(r5)
8112be18:	29000317 	ldw	r4,12(r5)
8112be1c:	1885883a 	add	r2,r3,r2
8112be20:	10c00054 	ori	r3,r2,1
8112be24:	39000315 	stw	r4,12(r7)
8112be28:	21c00215 	stw	r7,8(r4)
8112be2c:	30c00115 	stw	r3,4(r6)
8112be30:	308d883a 	add	r6,r6,r2
8112be34:	30800015 	stw	r2,0(r6)
8112be38:	003fac06 	br	8112bcec <__reset+0xfb10bcec>
8112be3c:	00c00504 	movi	r3,20
8112be40:	19401536 	bltu	r3,r5,8112be98 <_free_r+0x2a4>
8112be44:	28c01704 	addi	r3,r5,92
8112be48:	18c7883a 	add	r3,r3,r3
8112be4c:	294016c4 	addi	r5,r5,91
8112be50:	003fb406 	br	8112bd24 <__reset+0xfb10bd24>
8112be54:	280bd0ba 	srai	r5,r5,2
8112be58:	00c00044 	movi	r3,1
8112be5c:	38800117 	ldw	r2,4(r7)
8112be60:	194a983a 	sll	r5,r3,r5
8112be64:	2007883a 	mov	r3,r4
8112be68:	2884b03a 	or	r2,r5,r2
8112be6c:	38800115 	stw	r2,4(r7)
8112be70:	003fbb06 	br	8112bd60 <__reset+0xfb10bd60>
8112be74:	21800515 	stw	r6,20(r4)
8112be78:	21800415 	stw	r6,16(r4)
8112be7c:	10c00054 	ori	r3,r2,1
8112be80:	31c00315 	stw	r7,12(r6)
8112be84:	31c00215 	stw	r7,8(r6)
8112be88:	30c00115 	stw	r3,4(r6)
8112be8c:	308d883a 	add	r6,r6,r2
8112be90:	30800015 	stw	r2,0(r6)
8112be94:	003f9506 	br	8112bcec <__reset+0xfb10bcec>
8112be98:	00c01504 	movi	r3,84
8112be9c:	19400536 	bltu	r3,r5,8112beb4 <_free_r+0x2c0>
8112bea0:	100ad33a 	srli	r5,r2,12
8112bea4:	28c01bc4 	addi	r3,r5,111
8112bea8:	18c7883a 	add	r3,r3,r3
8112beac:	29401b84 	addi	r5,r5,110
8112beb0:	003f9c06 	br	8112bd24 <__reset+0xfb10bd24>
8112beb4:	00c05504 	movi	r3,340
8112beb8:	19400536 	bltu	r3,r5,8112bed0 <_free_r+0x2dc>
8112bebc:	100ad3fa 	srli	r5,r2,15
8112bec0:	28c01e04 	addi	r3,r5,120
8112bec4:	18c7883a 	add	r3,r3,r3
8112bec8:	29401dc4 	addi	r5,r5,119
8112becc:	003f9506 	br	8112bd24 <__reset+0xfb10bd24>
8112bed0:	00c15504 	movi	r3,1364
8112bed4:	19400536 	bltu	r3,r5,8112beec <_free_r+0x2f8>
8112bed8:	100ad4ba 	srli	r5,r2,18
8112bedc:	28c01f44 	addi	r3,r5,125
8112bee0:	18c7883a 	add	r3,r3,r3
8112bee4:	29401f04 	addi	r5,r5,124
8112bee8:	003f8e06 	br	8112bd24 <__reset+0xfb10bd24>
8112beec:	00c03f84 	movi	r3,254
8112bef0:	01401f84 	movi	r5,126
8112bef4:	003f8b06 	br	8112bd24 <__reset+0xfb10bd24>
8112bef8:	10c00054 	ori	r3,r2,1
8112befc:	30c00115 	stw	r3,4(r6)
8112bf00:	308d883a 	add	r6,r6,r2
8112bf04:	30800015 	stw	r2,0(r6)
8112bf08:	003f7806 	br	8112bcec <__reset+0xfb10bcec>

8112bf0c <__sfvwrite_r>:
8112bf0c:	30800217 	ldw	r2,8(r6)
8112bf10:	10006926 	beq	r2,zero,8112c0b8 <__sfvwrite_r+0x1ac>
8112bf14:	defff404 	addi	sp,sp,-48
8112bf18:	de00012e 	bgeu	sp,et,8112bf20 <__sfvwrite_r+0x14>
8112bf1c:	003b68fa 	trap	3
8112bf20:	28c0030b 	ldhu	r3,12(r5)
8112bf24:	dd400715 	stw	r21,28(sp)
8112bf28:	dd000615 	stw	r20,24(sp)
8112bf2c:	dc000215 	stw	r16,8(sp)
8112bf30:	dfc00b15 	stw	ra,44(sp)
8112bf34:	df000a15 	stw	fp,40(sp)
8112bf38:	ddc00915 	stw	r23,36(sp)
8112bf3c:	dd800815 	stw	r22,32(sp)
8112bf40:	dcc00515 	stw	r19,20(sp)
8112bf44:	dc800415 	stw	r18,16(sp)
8112bf48:	dc400315 	stw	r17,12(sp)
8112bf4c:	1880020c 	andi	r2,r3,8
8112bf50:	2821883a 	mov	r16,r5
8112bf54:	202b883a 	mov	r21,r4
8112bf58:	3029883a 	mov	r20,r6
8112bf5c:	10002726 	beq	r2,zero,8112bffc <__sfvwrite_r+0xf0>
8112bf60:	28800417 	ldw	r2,16(r5)
8112bf64:	10002526 	beq	r2,zero,8112bffc <__sfvwrite_r+0xf0>
8112bf68:	1880008c 	andi	r2,r3,2
8112bf6c:	a4400017 	ldw	r17,0(r20)
8112bf70:	10002a26 	beq	r2,zero,8112c01c <__sfvwrite_r+0x110>
8112bf74:	05a00034 	movhi	r22,32768
8112bf78:	0027883a 	mov	r19,zero
8112bf7c:	0025883a 	mov	r18,zero
8112bf80:	b5bf0004 	addi	r22,r22,-1024
8112bf84:	980d883a 	mov	r6,r19
8112bf88:	a809883a 	mov	r4,r21
8112bf8c:	90004626 	beq	r18,zero,8112c0a8 <__sfvwrite_r+0x19c>
8112bf90:	900f883a 	mov	r7,r18
8112bf94:	b480022e 	bgeu	r22,r18,8112bfa0 <__sfvwrite_r+0x94>
8112bf98:	01e00034 	movhi	r7,32768
8112bf9c:	39ff0004 	addi	r7,r7,-1024
8112bfa0:	80800917 	ldw	r2,36(r16)
8112bfa4:	81400717 	ldw	r5,28(r16)
8112bfa8:	103ee83a 	callr	r2
8112bfac:	0080570e 	bge	zero,r2,8112c10c <__sfvwrite_r+0x200>
8112bfb0:	a0c00217 	ldw	r3,8(r20)
8112bfb4:	98a7883a 	add	r19,r19,r2
8112bfb8:	90a5c83a 	sub	r18,r18,r2
8112bfbc:	1885c83a 	sub	r2,r3,r2
8112bfc0:	a0800215 	stw	r2,8(r20)
8112bfc4:	103fef1e 	bne	r2,zero,8112bf84 <__reset+0xfb10bf84>
8112bfc8:	0005883a 	mov	r2,zero
8112bfcc:	dfc00b17 	ldw	ra,44(sp)
8112bfd0:	df000a17 	ldw	fp,40(sp)
8112bfd4:	ddc00917 	ldw	r23,36(sp)
8112bfd8:	dd800817 	ldw	r22,32(sp)
8112bfdc:	dd400717 	ldw	r21,28(sp)
8112bfe0:	dd000617 	ldw	r20,24(sp)
8112bfe4:	dcc00517 	ldw	r19,20(sp)
8112bfe8:	dc800417 	ldw	r18,16(sp)
8112bfec:	dc400317 	ldw	r17,12(sp)
8112bff0:	dc000217 	ldw	r16,8(sp)
8112bff4:	dec00c04 	addi	sp,sp,48
8112bff8:	f800283a 	ret
8112bffc:	800b883a 	mov	r5,r16
8112c000:	a809883a 	mov	r4,r21
8112c004:	11296ec0 	call	811296ec <__swsetup_r>
8112c008:	1000eb1e 	bne	r2,zero,8112c3b8 <__sfvwrite_r+0x4ac>
8112c00c:	80c0030b 	ldhu	r3,12(r16)
8112c010:	a4400017 	ldw	r17,0(r20)
8112c014:	1880008c 	andi	r2,r3,2
8112c018:	103fd61e 	bne	r2,zero,8112bf74 <__reset+0xfb10bf74>
8112c01c:	1880004c 	andi	r2,r3,1
8112c020:	10003f1e 	bne	r2,zero,8112c120 <__sfvwrite_r+0x214>
8112c024:	0039883a 	mov	fp,zero
8112c028:	0025883a 	mov	r18,zero
8112c02c:	90001a26 	beq	r18,zero,8112c098 <__sfvwrite_r+0x18c>
8112c030:	1880800c 	andi	r2,r3,512
8112c034:	84c00217 	ldw	r19,8(r16)
8112c038:	10002126 	beq	r2,zero,8112c0c0 <__sfvwrite_r+0x1b4>
8112c03c:	982f883a 	mov	r23,r19
8112c040:	94c09336 	bltu	r18,r19,8112c290 <__sfvwrite_r+0x384>
8112c044:	1881200c 	andi	r2,r3,1152
8112c048:	10009e1e 	bne	r2,zero,8112c2c4 <__sfvwrite_r+0x3b8>
8112c04c:	81000017 	ldw	r4,0(r16)
8112c050:	b80d883a 	mov	r6,r23
8112c054:	e00b883a 	mov	r5,fp
8112c058:	112ca680 	call	8112ca68 <memmove>
8112c05c:	80c00217 	ldw	r3,8(r16)
8112c060:	81000017 	ldw	r4,0(r16)
8112c064:	9005883a 	mov	r2,r18
8112c068:	1ce7c83a 	sub	r19,r3,r19
8112c06c:	25cf883a 	add	r7,r4,r23
8112c070:	84c00215 	stw	r19,8(r16)
8112c074:	81c00015 	stw	r7,0(r16)
8112c078:	a0c00217 	ldw	r3,8(r20)
8112c07c:	e0b9883a 	add	fp,fp,r2
8112c080:	90a5c83a 	sub	r18,r18,r2
8112c084:	18a7c83a 	sub	r19,r3,r2
8112c088:	a4c00215 	stw	r19,8(r20)
8112c08c:	983fce26 	beq	r19,zero,8112bfc8 <__reset+0xfb10bfc8>
8112c090:	80c0030b 	ldhu	r3,12(r16)
8112c094:	903fe61e 	bne	r18,zero,8112c030 <__reset+0xfb10c030>
8112c098:	8f000017 	ldw	fp,0(r17)
8112c09c:	8c800117 	ldw	r18,4(r17)
8112c0a0:	8c400204 	addi	r17,r17,8
8112c0a4:	003fe106 	br	8112c02c <__reset+0xfb10c02c>
8112c0a8:	8cc00017 	ldw	r19,0(r17)
8112c0ac:	8c800117 	ldw	r18,4(r17)
8112c0b0:	8c400204 	addi	r17,r17,8
8112c0b4:	003fb306 	br	8112bf84 <__reset+0xfb10bf84>
8112c0b8:	0005883a 	mov	r2,zero
8112c0bc:	f800283a 	ret
8112c0c0:	81000017 	ldw	r4,0(r16)
8112c0c4:	80800417 	ldw	r2,16(r16)
8112c0c8:	11005736 	bltu	r2,r4,8112c228 <__sfvwrite_r+0x31c>
8112c0cc:	85c00517 	ldw	r23,20(r16)
8112c0d0:	95c05536 	bltu	r18,r23,8112c228 <__sfvwrite_r+0x31c>
8112c0d4:	00a00034 	movhi	r2,32768
8112c0d8:	10bfffc4 	addi	r2,r2,-1
8112c0dc:	9009883a 	mov	r4,r18
8112c0e0:	1480012e 	bgeu	r2,r18,8112c0e8 <__sfvwrite_r+0x1dc>
8112c0e4:	1009883a 	mov	r4,r2
8112c0e8:	b80b883a 	mov	r5,r23
8112c0ec:	1134b200 	call	81134b20 <__divsi3>
8112c0f0:	15cf383a 	mul	r7,r2,r23
8112c0f4:	81400717 	ldw	r5,28(r16)
8112c0f8:	80800917 	ldw	r2,36(r16)
8112c0fc:	e00d883a 	mov	r6,fp
8112c100:	a809883a 	mov	r4,r21
8112c104:	103ee83a 	callr	r2
8112c108:	00bfdb16 	blt	zero,r2,8112c078 <__reset+0xfb10c078>
8112c10c:	8080030b 	ldhu	r2,12(r16)
8112c110:	10801014 	ori	r2,r2,64
8112c114:	8080030d 	sth	r2,12(r16)
8112c118:	00bfffc4 	movi	r2,-1
8112c11c:	003fab06 	br	8112bfcc <__reset+0xfb10bfcc>
8112c120:	0027883a 	mov	r19,zero
8112c124:	0011883a 	mov	r8,zero
8112c128:	0039883a 	mov	fp,zero
8112c12c:	0025883a 	mov	r18,zero
8112c130:	90001f26 	beq	r18,zero,8112c1b0 <__sfvwrite_r+0x2a4>
8112c134:	40005a26 	beq	r8,zero,8112c2a0 <__sfvwrite_r+0x394>
8112c138:	982d883a 	mov	r22,r19
8112c13c:	94c0012e 	bgeu	r18,r19,8112c144 <__sfvwrite_r+0x238>
8112c140:	902d883a 	mov	r22,r18
8112c144:	81000017 	ldw	r4,0(r16)
8112c148:	80800417 	ldw	r2,16(r16)
8112c14c:	b02f883a 	mov	r23,r22
8112c150:	81c00517 	ldw	r7,20(r16)
8112c154:	1100032e 	bgeu	r2,r4,8112c164 <__sfvwrite_r+0x258>
8112c158:	80c00217 	ldw	r3,8(r16)
8112c15c:	38c7883a 	add	r3,r7,r3
8112c160:	1d801816 	blt	r3,r22,8112c1c4 <__sfvwrite_r+0x2b8>
8112c164:	b1c03e16 	blt	r22,r7,8112c260 <__sfvwrite_r+0x354>
8112c168:	80800917 	ldw	r2,36(r16)
8112c16c:	81400717 	ldw	r5,28(r16)
8112c170:	e00d883a 	mov	r6,fp
8112c174:	da000115 	stw	r8,4(sp)
8112c178:	a809883a 	mov	r4,r21
8112c17c:	103ee83a 	callr	r2
8112c180:	102f883a 	mov	r23,r2
8112c184:	da000117 	ldw	r8,4(sp)
8112c188:	00bfe00e 	bge	zero,r2,8112c10c <__reset+0xfb10c10c>
8112c18c:	9de7c83a 	sub	r19,r19,r23
8112c190:	98001f26 	beq	r19,zero,8112c210 <__sfvwrite_r+0x304>
8112c194:	a0800217 	ldw	r2,8(r20)
8112c198:	e5f9883a 	add	fp,fp,r23
8112c19c:	95e5c83a 	sub	r18,r18,r23
8112c1a0:	15efc83a 	sub	r23,r2,r23
8112c1a4:	a5c00215 	stw	r23,8(r20)
8112c1a8:	b83f8726 	beq	r23,zero,8112bfc8 <__reset+0xfb10bfc8>
8112c1ac:	903fe11e 	bne	r18,zero,8112c134 <__reset+0xfb10c134>
8112c1b0:	8f000017 	ldw	fp,0(r17)
8112c1b4:	8c800117 	ldw	r18,4(r17)
8112c1b8:	0011883a 	mov	r8,zero
8112c1bc:	8c400204 	addi	r17,r17,8
8112c1c0:	003fdb06 	br	8112c130 <__reset+0xfb10c130>
8112c1c4:	180d883a 	mov	r6,r3
8112c1c8:	e00b883a 	mov	r5,fp
8112c1cc:	da000115 	stw	r8,4(sp)
8112c1d0:	d8c00015 	stw	r3,0(sp)
8112c1d4:	112ca680 	call	8112ca68 <memmove>
8112c1d8:	d8c00017 	ldw	r3,0(sp)
8112c1dc:	80800017 	ldw	r2,0(r16)
8112c1e0:	800b883a 	mov	r5,r16
8112c1e4:	a809883a 	mov	r4,r21
8112c1e8:	10c5883a 	add	r2,r2,r3
8112c1ec:	80800015 	stw	r2,0(r16)
8112c1f0:	d8c00015 	stw	r3,0(sp)
8112c1f4:	112b3600 	call	8112b360 <_fflush_r>
8112c1f8:	d8c00017 	ldw	r3,0(sp)
8112c1fc:	da000117 	ldw	r8,4(sp)
8112c200:	103fc21e 	bne	r2,zero,8112c10c <__reset+0xfb10c10c>
8112c204:	182f883a 	mov	r23,r3
8112c208:	9de7c83a 	sub	r19,r19,r23
8112c20c:	983fe11e 	bne	r19,zero,8112c194 <__reset+0xfb10c194>
8112c210:	800b883a 	mov	r5,r16
8112c214:	a809883a 	mov	r4,r21
8112c218:	112b3600 	call	8112b360 <_fflush_r>
8112c21c:	103fbb1e 	bne	r2,zero,8112c10c <__reset+0xfb10c10c>
8112c220:	0011883a 	mov	r8,zero
8112c224:	003fdb06 	br	8112c194 <__reset+0xfb10c194>
8112c228:	94c0012e 	bgeu	r18,r19,8112c230 <__sfvwrite_r+0x324>
8112c22c:	9027883a 	mov	r19,r18
8112c230:	980d883a 	mov	r6,r19
8112c234:	e00b883a 	mov	r5,fp
8112c238:	112ca680 	call	8112ca68 <memmove>
8112c23c:	80800217 	ldw	r2,8(r16)
8112c240:	80c00017 	ldw	r3,0(r16)
8112c244:	14c5c83a 	sub	r2,r2,r19
8112c248:	1cc7883a 	add	r3,r3,r19
8112c24c:	80800215 	stw	r2,8(r16)
8112c250:	80c00015 	stw	r3,0(r16)
8112c254:	10004326 	beq	r2,zero,8112c364 <__sfvwrite_r+0x458>
8112c258:	9805883a 	mov	r2,r19
8112c25c:	003f8606 	br	8112c078 <__reset+0xfb10c078>
8112c260:	b00d883a 	mov	r6,r22
8112c264:	e00b883a 	mov	r5,fp
8112c268:	da000115 	stw	r8,4(sp)
8112c26c:	112ca680 	call	8112ca68 <memmove>
8112c270:	80800217 	ldw	r2,8(r16)
8112c274:	80c00017 	ldw	r3,0(r16)
8112c278:	da000117 	ldw	r8,4(sp)
8112c27c:	1585c83a 	sub	r2,r2,r22
8112c280:	1dad883a 	add	r22,r3,r22
8112c284:	80800215 	stw	r2,8(r16)
8112c288:	85800015 	stw	r22,0(r16)
8112c28c:	003fbf06 	br	8112c18c <__reset+0xfb10c18c>
8112c290:	81000017 	ldw	r4,0(r16)
8112c294:	9027883a 	mov	r19,r18
8112c298:	902f883a 	mov	r23,r18
8112c29c:	003f6c06 	br	8112c050 <__reset+0xfb10c050>
8112c2a0:	900d883a 	mov	r6,r18
8112c2a4:	01400284 	movi	r5,10
8112c2a8:	e009883a 	mov	r4,fp
8112c2ac:	112c9840 	call	8112c984 <memchr>
8112c2b0:	10003e26 	beq	r2,zero,8112c3ac <__sfvwrite_r+0x4a0>
8112c2b4:	10800044 	addi	r2,r2,1
8112c2b8:	1727c83a 	sub	r19,r2,fp
8112c2bc:	02000044 	movi	r8,1
8112c2c0:	003f9d06 	br	8112c138 <__reset+0xfb10c138>
8112c2c4:	80800517 	ldw	r2,20(r16)
8112c2c8:	81400417 	ldw	r5,16(r16)
8112c2cc:	81c00017 	ldw	r7,0(r16)
8112c2d0:	10a7883a 	add	r19,r2,r2
8112c2d4:	9885883a 	add	r2,r19,r2
8112c2d8:	1026d7fa 	srli	r19,r2,31
8112c2dc:	396dc83a 	sub	r22,r7,r5
8112c2e0:	b1000044 	addi	r4,r22,1
8112c2e4:	9885883a 	add	r2,r19,r2
8112c2e8:	1027d07a 	srai	r19,r2,1
8112c2ec:	2485883a 	add	r2,r4,r18
8112c2f0:	980d883a 	mov	r6,r19
8112c2f4:	9880022e 	bgeu	r19,r2,8112c300 <__sfvwrite_r+0x3f4>
8112c2f8:	1027883a 	mov	r19,r2
8112c2fc:	100d883a 	mov	r6,r2
8112c300:	18c1000c 	andi	r3,r3,1024
8112c304:	18001c26 	beq	r3,zero,8112c378 <__sfvwrite_r+0x46c>
8112c308:	300b883a 	mov	r5,r6
8112c30c:	a809883a 	mov	r4,r21
8112c310:	1121e7c0 	call	81121e7c <_malloc_r>
8112c314:	102f883a 	mov	r23,r2
8112c318:	10002926 	beq	r2,zero,8112c3c0 <__sfvwrite_r+0x4b4>
8112c31c:	81400417 	ldw	r5,16(r16)
8112c320:	b00d883a 	mov	r6,r22
8112c324:	1009883a 	mov	r4,r2
8112c328:	11226900 	call	81122690 <memcpy>
8112c32c:	8080030b 	ldhu	r2,12(r16)
8112c330:	00fedfc4 	movi	r3,-1153
8112c334:	10c4703a 	and	r2,r2,r3
8112c338:	10802014 	ori	r2,r2,128
8112c33c:	8080030d 	sth	r2,12(r16)
8112c340:	bd89883a 	add	r4,r23,r22
8112c344:	9d8fc83a 	sub	r7,r19,r22
8112c348:	85c00415 	stw	r23,16(r16)
8112c34c:	84c00515 	stw	r19,20(r16)
8112c350:	81000015 	stw	r4,0(r16)
8112c354:	9027883a 	mov	r19,r18
8112c358:	81c00215 	stw	r7,8(r16)
8112c35c:	902f883a 	mov	r23,r18
8112c360:	003f3b06 	br	8112c050 <__reset+0xfb10c050>
8112c364:	800b883a 	mov	r5,r16
8112c368:	a809883a 	mov	r4,r21
8112c36c:	112b3600 	call	8112b360 <_fflush_r>
8112c370:	103fb926 	beq	r2,zero,8112c258 <__reset+0xfb10c258>
8112c374:	003f6506 	br	8112c10c <__reset+0xfb10c10c>
8112c378:	a809883a 	mov	r4,r21
8112c37c:	112dc880 	call	8112dc88 <_realloc_r>
8112c380:	102f883a 	mov	r23,r2
8112c384:	103fee1e 	bne	r2,zero,8112c340 <__reset+0xfb10c340>
8112c388:	81400417 	ldw	r5,16(r16)
8112c38c:	a809883a 	mov	r4,r21
8112c390:	112bbf40 	call	8112bbf4 <_free_r>
8112c394:	8080030b 	ldhu	r2,12(r16)
8112c398:	00ffdfc4 	movi	r3,-129
8112c39c:	1884703a 	and	r2,r3,r2
8112c3a0:	00c00304 	movi	r3,12
8112c3a4:	a8c00015 	stw	r3,0(r21)
8112c3a8:	003f5906 	br	8112c110 <__reset+0xfb10c110>
8112c3ac:	94c00044 	addi	r19,r18,1
8112c3b0:	02000044 	movi	r8,1
8112c3b4:	003f6006 	br	8112c138 <__reset+0xfb10c138>
8112c3b8:	00bfffc4 	movi	r2,-1
8112c3bc:	003f0306 	br	8112bfcc <__reset+0xfb10bfcc>
8112c3c0:	00800304 	movi	r2,12
8112c3c4:	a8800015 	stw	r2,0(r21)
8112c3c8:	8080030b 	ldhu	r2,12(r16)
8112c3cc:	003f5006 	br	8112c110 <__reset+0xfb10c110>

8112c3d0 <_fwalk>:
8112c3d0:	defff704 	addi	sp,sp,-36
8112c3d4:	de00012e 	bgeu	sp,et,8112c3dc <_fwalk+0xc>
8112c3d8:	003b68fa 	trap	3
8112c3dc:	dd000415 	stw	r20,16(sp)
8112c3e0:	dfc00815 	stw	ra,32(sp)
8112c3e4:	ddc00715 	stw	r23,28(sp)
8112c3e8:	dd800615 	stw	r22,24(sp)
8112c3ec:	dd400515 	stw	r21,20(sp)
8112c3f0:	dcc00315 	stw	r19,12(sp)
8112c3f4:	dc800215 	stw	r18,8(sp)
8112c3f8:	dc400115 	stw	r17,4(sp)
8112c3fc:	dc000015 	stw	r16,0(sp)
8112c400:	2500b804 	addi	r20,r4,736
8112c404:	a0002326 	beq	r20,zero,8112c494 <_fwalk+0xc4>
8112c408:	282b883a 	mov	r21,r5
8112c40c:	002f883a 	mov	r23,zero
8112c410:	05800044 	movi	r22,1
8112c414:	04ffffc4 	movi	r19,-1
8112c418:	a4400117 	ldw	r17,4(r20)
8112c41c:	a4800217 	ldw	r18,8(r20)
8112c420:	8c7fffc4 	addi	r17,r17,-1
8112c424:	88000d16 	blt	r17,zero,8112c45c <_fwalk+0x8c>
8112c428:	94000304 	addi	r16,r18,12
8112c42c:	94800384 	addi	r18,r18,14
8112c430:	8080000b 	ldhu	r2,0(r16)
8112c434:	8c7fffc4 	addi	r17,r17,-1
8112c438:	813ffd04 	addi	r4,r16,-12
8112c43c:	b080042e 	bgeu	r22,r2,8112c450 <_fwalk+0x80>
8112c440:	9080000f 	ldh	r2,0(r18)
8112c444:	14c00226 	beq	r2,r19,8112c450 <_fwalk+0x80>
8112c448:	a83ee83a 	callr	r21
8112c44c:	b8aeb03a 	or	r23,r23,r2
8112c450:	84001a04 	addi	r16,r16,104
8112c454:	94801a04 	addi	r18,r18,104
8112c458:	8cfff51e 	bne	r17,r19,8112c430 <__reset+0xfb10c430>
8112c45c:	a5000017 	ldw	r20,0(r20)
8112c460:	a03fed1e 	bne	r20,zero,8112c418 <__reset+0xfb10c418>
8112c464:	b805883a 	mov	r2,r23
8112c468:	dfc00817 	ldw	ra,32(sp)
8112c46c:	ddc00717 	ldw	r23,28(sp)
8112c470:	dd800617 	ldw	r22,24(sp)
8112c474:	dd400517 	ldw	r21,20(sp)
8112c478:	dd000417 	ldw	r20,16(sp)
8112c47c:	dcc00317 	ldw	r19,12(sp)
8112c480:	dc800217 	ldw	r18,8(sp)
8112c484:	dc400117 	ldw	r17,4(sp)
8112c488:	dc000017 	ldw	r16,0(sp)
8112c48c:	dec00904 	addi	sp,sp,36
8112c490:	f800283a 	ret
8112c494:	002f883a 	mov	r23,zero
8112c498:	003ff206 	br	8112c464 <__reset+0xfb10c464>

8112c49c <_fwalk_reent>:
8112c49c:	defff704 	addi	sp,sp,-36
8112c4a0:	de00012e 	bgeu	sp,et,8112c4a8 <_fwalk_reent+0xc>
8112c4a4:	003b68fa 	trap	3
8112c4a8:	dd000415 	stw	r20,16(sp)
8112c4ac:	dfc00815 	stw	ra,32(sp)
8112c4b0:	ddc00715 	stw	r23,28(sp)
8112c4b4:	dd800615 	stw	r22,24(sp)
8112c4b8:	dd400515 	stw	r21,20(sp)
8112c4bc:	dcc00315 	stw	r19,12(sp)
8112c4c0:	dc800215 	stw	r18,8(sp)
8112c4c4:	dc400115 	stw	r17,4(sp)
8112c4c8:	dc000015 	stw	r16,0(sp)
8112c4cc:	2500b804 	addi	r20,r4,736
8112c4d0:	a0002326 	beq	r20,zero,8112c560 <_fwalk_reent+0xc4>
8112c4d4:	282b883a 	mov	r21,r5
8112c4d8:	2027883a 	mov	r19,r4
8112c4dc:	002f883a 	mov	r23,zero
8112c4e0:	05800044 	movi	r22,1
8112c4e4:	04bfffc4 	movi	r18,-1
8112c4e8:	a4400117 	ldw	r17,4(r20)
8112c4ec:	a4000217 	ldw	r16,8(r20)
8112c4f0:	8c7fffc4 	addi	r17,r17,-1
8112c4f4:	88000c16 	blt	r17,zero,8112c528 <_fwalk_reent+0x8c>
8112c4f8:	84000304 	addi	r16,r16,12
8112c4fc:	8080000b 	ldhu	r2,0(r16)
8112c500:	8c7fffc4 	addi	r17,r17,-1
8112c504:	817ffd04 	addi	r5,r16,-12
8112c508:	b080052e 	bgeu	r22,r2,8112c520 <_fwalk_reent+0x84>
8112c50c:	8080008f 	ldh	r2,2(r16)
8112c510:	9809883a 	mov	r4,r19
8112c514:	14800226 	beq	r2,r18,8112c520 <_fwalk_reent+0x84>
8112c518:	a83ee83a 	callr	r21
8112c51c:	b8aeb03a 	or	r23,r23,r2
8112c520:	84001a04 	addi	r16,r16,104
8112c524:	8cbff51e 	bne	r17,r18,8112c4fc <__reset+0xfb10c4fc>
8112c528:	a5000017 	ldw	r20,0(r20)
8112c52c:	a03fee1e 	bne	r20,zero,8112c4e8 <__reset+0xfb10c4e8>
8112c530:	b805883a 	mov	r2,r23
8112c534:	dfc00817 	ldw	ra,32(sp)
8112c538:	ddc00717 	ldw	r23,28(sp)
8112c53c:	dd800617 	ldw	r22,24(sp)
8112c540:	dd400517 	ldw	r21,20(sp)
8112c544:	dd000417 	ldw	r20,16(sp)
8112c548:	dcc00317 	ldw	r19,12(sp)
8112c54c:	dc800217 	ldw	r18,8(sp)
8112c550:	dc400117 	ldw	r17,4(sp)
8112c554:	dc000017 	ldw	r16,0(sp)
8112c558:	dec00904 	addi	sp,sp,36
8112c55c:	f800283a 	ret
8112c560:	002f883a 	mov	r23,zero
8112c564:	003ff206 	br	8112c530 <__reset+0xfb10c530>

8112c568 <_isatty_r>:
8112c568:	defffd04 	addi	sp,sp,-12
8112c56c:	de00012e 	bgeu	sp,et,8112c574 <_isatty_r+0xc>
8112c570:	003b68fa 	trap	3
8112c574:	dc000015 	stw	r16,0(sp)
8112c578:	04204574 	movhi	r16,33045
8112c57c:	dc400115 	stw	r17,4(sp)
8112c580:	840d8204 	addi	r16,r16,13832
8112c584:	2023883a 	mov	r17,r4
8112c588:	2809883a 	mov	r4,r5
8112c58c:	dfc00215 	stw	ra,8(sp)
8112c590:	80000015 	stw	zero,0(r16)
8112c594:	11368100 	call	81136810 <isatty>
8112c598:	00ffffc4 	movi	r3,-1
8112c59c:	10c00526 	beq	r2,r3,8112c5b4 <_isatty_r+0x4c>
8112c5a0:	dfc00217 	ldw	ra,8(sp)
8112c5a4:	dc400117 	ldw	r17,4(sp)
8112c5a8:	dc000017 	ldw	r16,0(sp)
8112c5ac:	dec00304 	addi	sp,sp,12
8112c5b0:	f800283a 	ret
8112c5b4:	80c00017 	ldw	r3,0(r16)
8112c5b8:	183ff926 	beq	r3,zero,8112c5a0 <__reset+0xfb10c5a0>
8112c5bc:	88c00015 	stw	r3,0(r17)
8112c5c0:	003ff706 	br	8112c5a0 <__reset+0xfb10c5a0>

8112c5c4 <iswspace>:
8112c5c4:	00803fc4 	movi	r2,255
8112c5c8:	11000836 	bltu	r2,r4,8112c5ec <iswspace+0x28>
8112c5cc:	00a04574 	movhi	r2,33045
8112c5d0:	108d0d04 	addi	r2,r2,13364
8112c5d4:	10800017 	ldw	r2,0(r2)
8112c5d8:	1109883a 	add	r4,r2,r4
8112c5dc:	20800043 	ldbu	r2,1(r4)
8112c5e0:	1080020c 	andi	r2,r2,8
8112c5e4:	10803fcc 	andi	r2,r2,255
8112c5e8:	f800283a 	ret
8112c5ec:	0005883a 	mov	r2,zero
8112c5f0:	f800283a 	ret

8112c5f4 <_setlocale_r>:
8112c5f4:	30001d26 	beq	r6,zero,8112c66c <_setlocale_r+0x78>
8112c5f8:	01604574 	movhi	r5,33045
8112c5fc:	defffe04 	addi	sp,sp,-8
8112c600:	29436604 	addi	r5,r5,3480
8112c604:	3009883a 	mov	r4,r6
8112c608:	de00012e 	bgeu	sp,et,8112c610 <_setlocale_r+0x1c>
8112c60c:	003b68fa 	trap	3
8112c610:	dc000015 	stw	r16,0(sp)
8112c614:	dfc00115 	stw	ra,4(sp)
8112c618:	3021883a 	mov	r16,r6
8112c61c:	112e3400 	call	8112e340 <strcmp>
8112c620:	1000061e 	bne	r2,zero,8112c63c <_setlocale_r+0x48>
8112c624:	00a04574 	movhi	r2,33045
8112c628:	10833504 	addi	r2,r2,3284
8112c62c:	dfc00117 	ldw	ra,4(sp)
8112c630:	dc000017 	ldw	r16,0(sp)
8112c634:	dec00204 	addi	sp,sp,8
8112c638:	f800283a 	ret
8112c63c:	01604574 	movhi	r5,33045
8112c640:	29433504 	addi	r5,r5,3284
8112c644:	8009883a 	mov	r4,r16
8112c648:	112e3400 	call	8112e340 <strcmp>
8112c64c:	103ff526 	beq	r2,zero,8112c624 <__reset+0xfb10c624>
8112c650:	01604574 	movhi	r5,33045
8112c654:	29433f04 	addi	r5,r5,3324
8112c658:	8009883a 	mov	r4,r16
8112c65c:	112e3400 	call	8112e340 <strcmp>
8112c660:	103ff026 	beq	r2,zero,8112c624 <__reset+0xfb10c624>
8112c664:	0005883a 	mov	r2,zero
8112c668:	003ff006 	br	8112c62c <__reset+0xfb10c62c>
8112c66c:	00a04574 	movhi	r2,33045
8112c670:	10833504 	addi	r2,r2,3284
8112c674:	f800283a 	ret

8112c678 <__locale_charset>:
8112c678:	00a04574 	movhi	r2,33045
8112c67c:	1087d704 	addi	r2,r2,8028
8112c680:	f800283a 	ret

8112c684 <__locale_mb_cur_max>:
8112c684:	00a04574 	movhi	r2,33045
8112c688:	108d1204 	addi	r2,r2,13384
8112c68c:	10800017 	ldw	r2,0(r2)
8112c690:	f800283a 	ret

8112c694 <__locale_msgcharset>:
8112c694:	00a04574 	movhi	r2,33045
8112c698:	1087cf04 	addi	r2,r2,7996
8112c69c:	f800283a 	ret

8112c6a0 <__locale_cjk_lang>:
8112c6a0:	0005883a 	mov	r2,zero
8112c6a4:	f800283a 	ret

8112c6a8 <_localeconv_r>:
8112c6a8:	00a04574 	movhi	r2,33045
8112c6ac:	1087df04 	addi	r2,r2,8060
8112c6b0:	f800283a 	ret

8112c6b4 <setlocale>:
8112c6b4:	00a04574 	movhi	r2,33045
8112c6b8:	108d0f04 	addi	r2,r2,13372
8112c6bc:	280d883a 	mov	r6,r5
8112c6c0:	200b883a 	mov	r5,r4
8112c6c4:	11000017 	ldw	r4,0(r2)
8112c6c8:	112c5f41 	jmpi	8112c5f4 <_setlocale_r>

8112c6cc <localeconv>:
8112c6cc:	00a04574 	movhi	r2,33045
8112c6d0:	1087df04 	addi	r2,r2,8060
8112c6d4:	f800283a 	ret

8112c6d8 <_lseek_r>:
8112c6d8:	defffd04 	addi	sp,sp,-12
8112c6dc:	de00012e 	bgeu	sp,et,8112c6e4 <_lseek_r+0xc>
8112c6e0:	003b68fa 	trap	3
8112c6e4:	2805883a 	mov	r2,r5
8112c6e8:	dc000015 	stw	r16,0(sp)
8112c6ec:	04204574 	movhi	r16,33045
8112c6f0:	dc400115 	stw	r17,4(sp)
8112c6f4:	300b883a 	mov	r5,r6
8112c6f8:	840d8204 	addi	r16,r16,13832
8112c6fc:	2023883a 	mov	r17,r4
8112c700:	380d883a 	mov	r6,r7
8112c704:	1009883a 	mov	r4,r2
8112c708:	dfc00215 	stw	ra,8(sp)
8112c70c:	80000015 	stw	zero,0(r16)
8112c710:	113740c0 	call	8113740c <lseek>
8112c714:	00ffffc4 	movi	r3,-1
8112c718:	10c00526 	beq	r2,r3,8112c730 <_lseek_r+0x58>
8112c71c:	dfc00217 	ldw	ra,8(sp)
8112c720:	dc400117 	ldw	r17,4(sp)
8112c724:	dc000017 	ldw	r16,0(sp)
8112c728:	dec00304 	addi	sp,sp,12
8112c72c:	f800283a 	ret
8112c730:	80c00017 	ldw	r3,0(r16)
8112c734:	183ff926 	beq	r3,zero,8112c71c <__reset+0xfb10c71c>
8112c738:	88c00015 	stw	r3,0(r17)
8112c73c:	003ff706 	br	8112c71c <__reset+0xfb10c71c>

8112c740 <_mbrtowc_r>:
8112c740:	defff704 	addi	sp,sp,-36
8112c744:	00a04574 	movhi	r2,33045
8112c748:	de00012e 	bgeu	sp,et,8112c750 <_mbrtowc_r+0x10>
8112c74c:	003b68fa 	trap	3
8112c750:	108d1304 	addi	r2,r2,13388
8112c754:	dc800715 	stw	r18,28(sp)
8112c758:	dc400615 	stw	r17,24(sp)
8112c75c:	dc000515 	stw	r16,20(sp)
8112c760:	dfc00815 	stw	ra,32(sp)
8112c764:	2021883a 	mov	r16,r4
8112c768:	dc400917 	ldw	r17,36(sp)
8112c76c:	14800017 	ldw	r18,0(r2)
8112c770:	30001626 	beq	r6,zero,8112c7cc <_mbrtowc_r+0x8c>
8112c774:	d9400215 	stw	r5,8(sp)
8112c778:	d9800315 	stw	r6,12(sp)
8112c77c:	d9c00415 	stw	r7,16(sp)
8112c780:	112c6780 	call	8112c678 <__locale_charset>
8112c784:	d9c00417 	ldw	r7,16(sp)
8112c788:	d9800317 	ldw	r6,12(sp)
8112c78c:	d9400217 	ldw	r5,8(sp)
8112c790:	d8800015 	stw	r2,0(sp)
8112c794:	dc400115 	stw	r17,4(sp)
8112c798:	8009883a 	mov	r4,r16
8112c79c:	903ee83a 	callr	r18
8112c7a0:	00ffffc4 	movi	r3,-1
8112c7a4:	10c0031e 	bne	r2,r3,8112c7b4 <_mbrtowc_r+0x74>
8112c7a8:	88000015 	stw	zero,0(r17)
8112c7ac:	00c02284 	movi	r3,138
8112c7b0:	80c00015 	stw	r3,0(r16)
8112c7b4:	dfc00817 	ldw	ra,32(sp)
8112c7b8:	dc800717 	ldw	r18,28(sp)
8112c7bc:	dc400617 	ldw	r17,24(sp)
8112c7c0:	dc000517 	ldw	r16,20(sp)
8112c7c4:	dec00904 	addi	sp,sp,36
8112c7c8:	f800283a 	ret
8112c7cc:	112c6780 	call	8112c678 <__locale_charset>
8112c7d0:	01a04574 	movhi	r6,33045
8112c7d4:	31833f04 	addi	r6,r6,3324
8112c7d8:	dc400115 	stw	r17,4(sp)
8112c7dc:	d8800015 	stw	r2,0(sp)
8112c7e0:	01c00044 	movi	r7,1
8112c7e4:	000b883a 	mov	r5,zero
8112c7e8:	8009883a 	mov	r4,r16
8112c7ec:	903ee83a 	callr	r18
8112c7f0:	003feb06 	br	8112c7a0 <__reset+0xfb10c7a0>

8112c7f4 <mbrtowc>:
8112c7f4:	defff704 	addi	sp,sp,-36
8112c7f8:	00a04574 	movhi	r2,33045
8112c7fc:	de00012e 	bgeu	sp,et,8112c804 <mbrtowc+0x10>
8112c800:	003b68fa 	trap	3
8112c804:	108d0f04 	addi	r2,r2,13372
8112c808:	dc800415 	stw	r18,16(sp)
8112c80c:	dc400315 	stw	r17,12(sp)
8112c810:	dfc00815 	stw	ra,32(sp)
8112c814:	dd400715 	stw	r21,28(sp)
8112c818:	dd000615 	stw	r20,24(sp)
8112c81c:	dcc00515 	stw	r19,20(sp)
8112c820:	dc000215 	stw	r16,8(sp)
8112c824:	3825883a 	mov	r18,r7
8112c828:	14400017 	ldw	r17,0(r2)
8112c82c:	28001c26 	beq	r5,zero,8112c8a0 <mbrtowc+0xac>
8112c830:	00a04574 	movhi	r2,33045
8112c834:	108d1304 	addi	r2,r2,13388
8112c838:	15400017 	ldw	r21,0(r2)
8112c83c:	2821883a 	mov	r16,r5
8112c840:	2027883a 	mov	r19,r4
8112c844:	3029883a 	mov	r20,r6
8112c848:	112c6780 	call	8112c678 <__locale_charset>
8112c84c:	d8800015 	stw	r2,0(sp)
8112c850:	dc800115 	stw	r18,4(sp)
8112c854:	a00f883a 	mov	r7,r20
8112c858:	800d883a 	mov	r6,r16
8112c85c:	980b883a 	mov	r5,r19
8112c860:	8809883a 	mov	r4,r17
8112c864:	a83ee83a 	callr	r21
8112c868:	00ffffc4 	movi	r3,-1
8112c86c:	10c0031e 	bne	r2,r3,8112c87c <mbrtowc+0x88>
8112c870:	90000015 	stw	zero,0(r18)
8112c874:	00c02284 	movi	r3,138
8112c878:	88c00015 	stw	r3,0(r17)
8112c87c:	dfc00817 	ldw	ra,32(sp)
8112c880:	dd400717 	ldw	r21,28(sp)
8112c884:	dd000617 	ldw	r20,24(sp)
8112c888:	dcc00517 	ldw	r19,20(sp)
8112c88c:	dc800417 	ldw	r18,16(sp)
8112c890:	dc400317 	ldw	r17,12(sp)
8112c894:	dc000217 	ldw	r16,8(sp)
8112c898:	dec00904 	addi	sp,sp,36
8112c89c:	f800283a 	ret
8112c8a0:	00a04574 	movhi	r2,33045
8112c8a4:	108d1304 	addi	r2,r2,13388
8112c8a8:	14000017 	ldw	r16,0(r2)
8112c8ac:	112c6780 	call	8112c678 <__locale_charset>
8112c8b0:	01a04574 	movhi	r6,33045
8112c8b4:	31833f04 	addi	r6,r6,3324
8112c8b8:	dc800115 	stw	r18,4(sp)
8112c8bc:	d8800015 	stw	r2,0(sp)
8112c8c0:	01c00044 	movi	r7,1
8112c8c4:	000b883a 	mov	r5,zero
8112c8c8:	8809883a 	mov	r4,r17
8112c8cc:	803ee83a 	callr	r16
8112c8d0:	003fe506 	br	8112c868 <__reset+0xfb10c868>

8112c8d4 <__ascii_mbtowc>:
8112c8d4:	deffff04 	addi	sp,sp,-4
8112c8d8:	de00012e 	bgeu	sp,et,8112c8e0 <__ascii_mbtowc+0xc>
8112c8dc:	003b68fa 	trap	3
8112c8e0:	28000826 	beq	r5,zero,8112c904 <__ascii_mbtowc+0x30>
8112c8e4:	30000926 	beq	r6,zero,8112c90c <__ascii_mbtowc+0x38>
8112c8e8:	38000b26 	beq	r7,zero,8112c918 <__ascii_mbtowc+0x44>
8112c8ec:	30800003 	ldbu	r2,0(r6)
8112c8f0:	28800015 	stw	r2,0(r5)
8112c8f4:	30800003 	ldbu	r2,0(r6)
8112c8f8:	1004c03a 	cmpne	r2,r2,zero
8112c8fc:	dec00104 	addi	sp,sp,4
8112c900:	f800283a 	ret
8112c904:	d80b883a 	mov	r5,sp
8112c908:	303ff71e 	bne	r6,zero,8112c8e8 <__reset+0xfb10c8e8>
8112c90c:	0005883a 	mov	r2,zero
8112c910:	dec00104 	addi	sp,sp,4
8112c914:	f800283a 	ret
8112c918:	00bfff84 	movi	r2,-2
8112c91c:	003ff706 	br	8112c8fc <__reset+0xfb10c8fc>

8112c920 <_mbtowc_r>:
8112c920:	00a04574 	movhi	r2,33045
8112c924:	defff804 	addi	sp,sp,-32
8112c928:	108d1304 	addi	r2,r2,13388
8112c92c:	de00012e 	bgeu	sp,et,8112c934 <_mbtowc_r+0x14>
8112c930:	003b68fa 	trap	3
8112c934:	dfc00715 	stw	ra,28(sp)
8112c938:	dc000615 	stw	r16,24(sp)
8112c93c:	14000017 	ldw	r16,0(r2)
8112c940:	d9000215 	stw	r4,8(sp)
8112c944:	d9400315 	stw	r5,12(sp)
8112c948:	d9800415 	stw	r6,16(sp)
8112c94c:	d9c00515 	stw	r7,20(sp)
8112c950:	112c6780 	call	8112c678 <__locale_charset>
8112c954:	d8800015 	stw	r2,0(sp)
8112c958:	d8800817 	ldw	r2,32(sp)
8112c95c:	d9c00517 	ldw	r7,20(sp)
8112c960:	d9800417 	ldw	r6,16(sp)
8112c964:	d9400317 	ldw	r5,12(sp)
8112c968:	d9000217 	ldw	r4,8(sp)
8112c96c:	d8800115 	stw	r2,4(sp)
8112c970:	803ee83a 	callr	r16
8112c974:	dfc00717 	ldw	ra,28(sp)
8112c978:	dc000617 	ldw	r16,24(sp)
8112c97c:	dec00804 	addi	sp,sp,32
8112c980:	f800283a 	ret

8112c984 <memchr>:
8112c984:	208000cc 	andi	r2,r4,3
8112c988:	280f883a 	mov	r7,r5
8112c98c:	10003426 	beq	r2,zero,8112ca60 <memchr+0xdc>
8112c990:	30bfffc4 	addi	r2,r6,-1
8112c994:	30001a26 	beq	r6,zero,8112ca00 <memchr+0x7c>
8112c998:	20c00003 	ldbu	r3,0(r4)
8112c99c:	29803fcc 	andi	r6,r5,255
8112c9a0:	30c0051e 	bne	r6,r3,8112c9b8 <memchr+0x34>
8112c9a4:	00001806 	br	8112ca08 <memchr+0x84>
8112c9a8:	10001526 	beq	r2,zero,8112ca00 <memchr+0x7c>
8112c9ac:	20c00003 	ldbu	r3,0(r4)
8112c9b0:	10bfffc4 	addi	r2,r2,-1
8112c9b4:	30c01426 	beq	r6,r3,8112ca08 <memchr+0x84>
8112c9b8:	21000044 	addi	r4,r4,1
8112c9bc:	20c000cc 	andi	r3,r4,3
8112c9c0:	183ff91e 	bne	r3,zero,8112c9a8 <__reset+0xfb10c9a8>
8112c9c4:	020000c4 	movi	r8,3
8112c9c8:	40801136 	bltu	r8,r2,8112ca10 <memchr+0x8c>
8112c9cc:	10000c26 	beq	r2,zero,8112ca00 <memchr+0x7c>
8112c9d0:	20c00003 	ldbu	r3,0(r4)
8112c9d4:	29403fcc 	andi	r5,r5,255
8112c9d8:	28c00b26 	beq	r5,r3,8112ca08 <memchr+0x84>
8112c9dc:	20c00044 	addi	r3,r4,1
8112c9e0:	39803fcc 	andi	r6,r7,255
8112c9e4:	2089883a 	add	r4,r4,r2
8112c9e8:	00000306 	br	8112c9f8 <memchr+0x74>
8112c9ec:	18c00044 	addi	r3,r3,1
8112c9f0:	197fffc3 	ldbu	r5,-1(r3)
8112c9f4:	31400526 	beq	r6,r5,8112ca0c <memchr+0x88>
8112c9f8:	1805883a 	mov	r2,r3
8112c9fc:	20fffb1e 	bne	r4,r3,8112c9ec <__reset+0xfb10c9ec>
8112ca00:	0005883a 	mov	r2,zero
8112ca04:	f800283a 	ret
8112ca08:	2005883a 	mov	r2,r4
8112ca0c:	f800283a 	ret
8112ca10:	28c03fcc 	andi	r3,r5,255
8112ca14:	1812923a 	slli	r9,r3,8
8112ca18:	02ffbff4 	movhi	r11,65279
8112ca1c:	02a02074 	movhi	r10,32897
8112ca20:	48d2b03a 	or	r9,r9,r3
8112ca24:	4806943a 	slli	r3,r9,16
8112ca28:	5affbfc4 	addi	r11,r11,-257
8112ca2c:	52a02004 	addi	r10,r10,-32640
8112ca30:	48d2b03a 	or	r9,r9,r3
8112ca34:	20c00017 	ldw	r3,0(r4)
8112ca38:	48c6f03a 	xor	r3,r9,r3
8112ca3c:	1acd883a 	add	r6,r3,r11
8112ca40:	00c6303a 	nor	r3,zero,r3
8112ca44:	30c6703a 	and	r3,r6,r3
8112ca48:	1a86703a 	and	r3,r3,r10
8112ca4c:	183fe01e 	bne	r3,zero,8112c9d0 <__reset+0xfb10c9d0>
8112ca50:	10bfff04 	addi	r2,r2,-4
8112ca54:	21000104 	addi	r4,r4,4
8112ca58:	40bff636 	bltu	r8,r2,8112ca34 <__reset+0xfb10ca34>
8112ca5c:	003fdb06 	br	8112c9cc <__reset+0xfb10c9cc>
8112ca60:	3005883a 	mov	r2,r6
8112ca64:	003fd706 	br	8112c9c4 <__reset+0xfb10c9c4>

8112ca68 <memmove>:
8112ca68:	2005883a 	mov	r2,r4
8112ca6c:	29000b2e 	bgeu	r5,r4,8112ca9c <memmove+0x34>
8112ca70:	298f883a 	add	r7,r5,r6
8112ca74:	21c0092e 	bgeu	r4,r7,8112ca9c <memmove+0x34>
8112ca78:	2187883a 	add	r3,r4,r6
8112ca7c:	198bc83a 	sub	r5,r3,r6
8112ca80:	30004826 	beq	r6,zero,8112cba4 <memmove+0x13c>
8112ca84:	39ffffc4 	addi	r7,r7,-1
8112ca88:	39000003 	ldbu	r4,0(r7)
8112ca8c:	18ffffc4 	addi	r3,r3,-1
8112ca90:	19000005 	stb	r4,0(r3)
8112ca94:	28fffb1e 	bne	r5,r3,8112ca84 <__reset+0xfb10ca84>
8112ca98:	f800283a 	ret
8112ca9c:	00c003c4 	movi	r3,15
8112caa0:	1980412e 	bgeu	r3,r6,8112cba8 <memmove+0x140>
8112caa4:	2886b03a 	or	r3,r5,r2
8112caa8:	18c000cc 	andi	r3,r3,3
8112caac:	1800401e 	bne	r3,zero,8112cbb0 <memmove+0x148>
8112cab0:	33fffc04 	addi	r15,r6,-16
8112cab4:	781ed13a 	srli	r15,r15,4
8112cab8:	28c00104 	addi	r3,r5,4
8112cabc:	13400104 	addi	r13,r2,4
8112cac0:	781c913a 	slli	r14,r15,4
8112cac4:	2b000204 	addi	r12,r5,8
8112cac8:	12c00204 	addi	r11,r2,8
8112cacc:	73800504 	addi	r14,r14,20
8112cad0:	2a800304 	addi	r10,r5,12
8112cad4:	12400304 	addi	r9,r2,12
8112cad8:	2b9d883a 	add	r14,r5,r14
8112cadc:	2811883a 	mov	r8,r5
8112cae0:	100f883a 	mov	r7,r2
8112cae4:	41000017 	ldw	r4,0(r8)
8112cae8:	39c00404 	addi	r7,r7,16
8112caec:	18c00404 	addi	r3,r3,16
8112caf0:	393ffc15 	stw	r4,-16(r7)
8112caf4:	193ffc17 	ldw	r4,-16(r3)
8112caf8:	6b400404 	addi	r13,r13,16
8112cafc:	5ac00404 	addi	r11,r11,16
8112cb00:	693ffc15 	stw	r4,-16(r13)
8112cb04:	61000017 	ldw	r4,0(r12)
8112cb08:	4a400404 	addi	r9,r9,16
8112cb0c:	42000404 	addi	r8,r8,16
8112cb10:	593ffc15 	stw	r4,-16(r11)
8112cb14:	51000017 	ldw	r4,0(r10)
8112cb18:	63000404 	addi	r12,r12,16
8112cb1c:	52800404 	addi	r10,r10,16
8112cb20:	493ffc15 	stw	r4,-16(r9)
8112cb24:	1bbfef1e 	bne	r3,r14,8112cae4 <__reset+0xfb10cae4>
8112cb28:	79000044 	addi	r4,r15,1
8112cb2c:	2008913a 	slli	r4,r4,4
8112cb30:	328003cc 	andi	r10,r6,15
8112cb34:	02c000c4 	movi	r11,3
8112cb38:	1107883a 	add	r3,r2,r4
8112cb3c:	290b883a 	add	r5,r5,r4
8112cb40:	5a801e2e 	bgeu	r11,r10,8112cbbc <memmove+0x154>
8112cb44:	1813883a 	mov	r9,r3
8112cb48:	2811883a 	mov	r8,r5
8112cb4c:	500f883a 	mov	r7,r10
8112cb50:	41000017 	ldw	r4,0(r8)
8112cb54:	4a400104 	addi	r9,r9,4
8112cb58:	39ffff04 	addi	r7,r7,-4
8112cb5c:	493fff15 	stw	r4,-4(r9)
8112cb60:	42000104 	addi	r8,r8,4
8112cb64:	59fffa36 	bltu	r11,r7,8112cb50 <__reset+0xfb10cb50>
8112cb68:	513fff04 	addi	r4,r10,-4
8112cb6c:	2008d0ba 	srli	r4,r4,2
8112cb70:	318000cc 	andi	r6,r6,3
8112cb74:	21000044 	addi	r4,r4,1
8112cb78:	2109883a 	add	r4,r4,r4
8112cb7c:	2109883a 	add	r4,r4,r4
8112cb80:	1907883a 	add	r3,r3,r4
8112cb84:	290b883a 	add	r5,r5,r4
8112cb88:	30000b26 	beq	r6,zero,8112cbb8 <memmove+0x150>
8112cb8c:	198d883a 	add	r6,r3,r6
8112cb90:	29c00003 	ldbu	r7,0(r5)
8112cb94:	18c00044 	addi	r3,r3,1
8112cb98:	29400044 	addi	r5,r5,1
8112cb9c:	19ffffc5 	stb	r7,-1(r3)
8112cba0:	19bffb1e 	bne	r3,r6,8112cb90 <__reset+0xfb10cb90>
8112cba4:	f800283a 	ret
8112cba8:	1007883a 	mov	r3,r2
8112cbac:	003ff606 	br	8112cb88 <__reset+0xfb10cb88>
8112cbb0:	1007883a 	mov	r3,r2
8112cbb4:	003ff506 	br	8112cb8c <__reset+0xfb10cb8c>
8112cbb8:	f800283a 	ret
8112cbbc:	500d883a 	mov	r6,r10
8112cbc0:	003ff106 	br	8112cb88 <__reset+0xfb10cb88>

8112cbc4 <_Balloc>:
8112cbc4:	defffc04 	addi	sp,sp,-16
8112cbc8:	de00012e 	bgeu	sp,et,8112cbd0 <_Balloc+0xc>
8112cbcc:	003b68fa 	trap	3
8112cbd0:	20801317 	ldw	r2,76(r4)
8112cbd4:	dc400115 	stw	r17,4(sp)
8112cbd8:	dc000015 	stw	r16,0(sp)
8112cbdc:	dfc00315 	stw	ra,12(sp)
8112cbe0:	dc800215 	stw	r18,8(sp)
8112cbe4:	2023883a 	mov	r17,r4
8112cbe8:	2821883a 	mov	r16,r5
8112cbec:	10000f26 	beq	r2,zero,8112cc2c <_Balloc+0x68>
8112cbf0:	8407883a 	add	r3,r16,r16
8112cbf4:	18c7883a 	add	r3,r3,r3
8112cbf8:	10c7883a 	add	r3,r2,r3
8112cbfc:	18800017 	ldw	r2,0(r3)
8112cc00:	10001126 	beq	r2,zero,8112cc48 <_Balloc+0x84>
8112cc04:	11000017 	ldw	r4,0(r2)
8112cc08:	19000015 	stw	r4,0(r3)
8112cc0c:	10000415 	stw	zero,16(r2)
8112cc10:	10000315 	stw	zero,12(r2)
8112cc14:	dfc00317 	ldw	ra,12(sp)
8112cc18:	dc800217 	ldw	r18,8(sp)
8112cc1c:	dc400117 	ldw	r17,4(sp)
8112cc20:	dc000017 	ldw	r16,0(sp)
8112cc24:	dec00404 	addi	sp,sp,16
8112cc28:	f800283a 	ret
8112cc2c:	01800844 	movi	r6,33
8112cc30:	01400104 	movi	r5,4
8112cc34:	1132e040 	call	81132e04 <_calloc_r>
8112cc38:	88801315 	stw	r2,76(r17)
8112cc3c:	103fec1e 	bne	r2,zero,8112cbf0 <__reset+0xfb10cbf0>
8112cc40:	0005883a 	mov	r2,zero
8112cc44:	003ff306 	br	8112cc14 <__reset+0xfb10cc14>
8112cc48:	01400044 	movi	r5,1
8112cc4c:	2c24983a 	sll	r18,r5,r16
8112cc50:	8809883a 	mov	r4,r17
8112cc54:	91800144 	addi	r6,r18,5
8112cc58:	318d883a 	add	r6,r6,r6
8112cc5c:	318d883a 	add	r6,r6,r6
8112cc60:	1132e040 	call	81132e04 <_calloc_r>
8112cc64:	103ff626 	beq	r2,zero,8112cc40 <__reset+0xfb10cc40>
8112cc68:	14000115 	stw	r16,4(r2)
8112cc6c:	14800215 	stw	r18,8(r2)
8112cc70:	003fe606 	br	8112cc0c <__reset+0xfb10cc0c>

8112cc74 <_Bfree>:
8112cc74:	28000826 	beq	r5,zero,8112cc98 <_Bfree+0x24>
8112cc78:	28c00117 	ldw	r3,4(r5)
8112cc7c:	20801317 	ldw	r2,76(r4)
8112cc80:	18c7883a 	add	r3,r3,r3
8112cc84:	18c7883a 	add	r3,r3,r3
8112cc88:	10c5883a 	add	r2,r2,r3
8112cc8c:	10c00017 	ldw	r3,0(r2)
8112cc90:	28c00015 	stw	r3,0(r5)
8112cc94:	11400015 	stw	r5,0(r2)
8112cc98:	f800283a 	ret

8112cc9c <__multadd>:
8112cc9c:	defffa04 	addi	sp,sp,-24
8112cca0:	de00012e 	bgeu	sp,et,8112cca8 <__multadd+0xc>
8112cca4:	003b68fa 	trap	3
8112cca8:	0011883a 	mov	r8,zero
8112ccac:	dc800315 	stw	r18,12(sp)
8112ccb0:	dc400215 	stw	r17,8(sp)
8112ccb4:	dc000115 	stw	r16,4(sp)
8112ccb8:	2823883a 	mov	r17,r5
8112ccbc:	2c000417 	ldw	r16,16(r5)
8112ccc0:	dfc00515 	stw	ra,20(sp)
8112ccc4:	dcc00415 	stw	r19,16(sp)
8112ccc8:	2025883a 	mov	r18,r4
8112cccc:	29400504 	addi	r5,r5,20
8112ccd0:	28c00017 	ldw	r3,0(r5)
8112ccd4:	29400104 	addi	r5,r5,4
8112ccd8:	42000044 	addi	r8,r8,1
8112ccdc:	18bfffcc 	andi	r2,r3,65535
8112cce0:	1185383a 	mul	r2,r2,r6
8112cce4:	1806d43a 	srli	r3,r3,16
8112cce8:	11cf883a 	add	r7,r2,r7
8112ccec:	3808d43a 	srli	r4,r7,16
8112ccf0:	1987383a 	mul	r3,r3,r6
8112ccf4:	38bfffcc 	andi	r2,r7,65535
8112ccf8:	1907883a 	add	r3,r3,r4
8112ccfc:	1808943a 	slli	r4,r3,16
8112cd00:	180ed43a 	srli	r7,r3,16
8112cd04:	2085883a 	add	r2,r4,r2
8112cd08:	28bfff15 	stw	r2,-4(r5)
8112cd0c:	443ff016 	blt	r8,r16,8112ccd0 <__reset+0xfb10ccd0>
8112cd10:	38000926 	beq	r7,zero,8112cd38 <__multadd+0x9c>
8112cd14:	88800217 	ldw	r2,8(r17)
8112cd18:	80800f0e 	bge	r16,r2,8112cd58 <__multadd+0xbc>
8112cd1c:	80800144 	addi	r2,r16,5
8112cd20:	1085883a 	add	r2,r2,r2
8112cd24:	1085883a 	add	r2,r2,r2
8112cd28:	8885883a 	add	r2,r17,r2
8112cd2c:	11c00015 	stw	r7,0(r2)
8112cd30:	84000044 	addi	r16,r16,1
8112cd34:	8c000415 	stw	r16,16(r17)
8112cd38:	8805883a 	mov	r2,r17
8112cd3c:	dfc00517 	ldw	ra,20(sp)
8112cd40:	dcc00417 	ldw	r19,16(sp)
8112cd44:	dc800317 	ldw	r18,12(sp)
8112cd48:	dc400217 	ldw	r17,8(sp)
8112cd4c:	dc000117 	ldw	r16,4(sp)
8112cd50:	dec00604 	addi	sp,sp,24
8112cd54:	f800283a 	ret
8112cd58:	89400117 	ldw	r5,4(r17)
8112cd5c:	9009883a 	mov	r4,r18
8112cd60:	d9c00015 	stw	r7,0(sp)
8112cd64:	29400044 	addi	r5,r5,1
8112cd68:	112cbc40 	call	8112cbc4 <_Balloc>
8112cd6c:	89800417 	ldw	r6,16(r17)
8112cd70:	89400304 	addi	r5,r17,12
8112cd74:	11000304 	addi	r4,r2,12
8112cd78:	31800084 	addi	r6,r6,2
8112cd7c:	318d883a 	add	r6,r6,r6
8112cd80:	318d883a 	add	r6,r6,r6
8112cd84:	1027883a 	mov	r19,r2
8112cd88:	11226900 	call	81122690 <memcpy>
8112cd8c:	d9c00017 	ldw	r7,0(sp)
8112cd90:	88000a26 	beq	r17,zero,8112cdbc <__multadd+0x120>
8112cd94:	88c00117 	ldw	r3,4(r17)
8112cd98:	90801317 	ldw	r2,76(r18)
8112cd9c:	18c7883a 	add	r3,r3,r3
8112cda0:	18c7883a 	add	r3,r3,r3
8112cda4:	10c5883a 	add	r2,r2,r3
8112cda8:	10c00017 	ldw	r3,0(r2)
8112cdac:	88c00015 	stw	r3,0(r17)
8112cdb0:	14400015 	stw	r17,0(r2)
8112cdb4:	9823883a 	mov	r17,r19
8112cdb8:	003fd806 	br	8112cd1c <__reset+0xfb10cd1c>
8112cdbc:	9823883a 	mov	r17,r19
8112cdc0:	003fd606 	br	8112cd1c <__reset+0xfb10cd1c>

8112cdc4 <__s2b>:
8112cdc4:	defff904 	addi	sp,sp,-28
8112cdc8:	de00012e 	bgeu	sp,et,8112cdd0 <__s2b+0xc>
8112cdcc:	003b68fa 	trap	3
8112cdd0:	dc400115 	stw	r17,4(sp)
8112cdd4:	dc000015 	stw	r16,0(sp)
8112cdd8:	2023883a 	mov	r17,r4
8112cddc:	2821883a 	mov	r16,r5
8112cde0:	39000204 	addi	r4,r7,8
8112cde4:	01400244 	movi	r5,9
8112cde8:	dcc00315 	stw	r19,12(sp)
8112cdec:	dc800215 	stw	r18,8(sp)
8112cdf0:	dfc00615 	stw	ra,24(sp)
8112cdf4:	dd400515 	stw	r21,20(sp)
8112cdf8:	dd000415 	stw	r20,16(sp)
8112cdfc:	3825883a 	mov	r18,r7
8112ce00:	3027883a 	mov	r19,r6
8112ce04:	1134b200 	call	81134b20 <__divsi3>
8112ce08:	00c00044 	movi	r3,1
8112ce0c:	000b883a 	mov	r5,zero
8112ce10:	1880030e 	bge	r3,r2,8112ce20 <__s2b+0x5c>
8112ce14:	18c7883a 	add	r3,r3,r3
8112ce18:	29400044 	addi	r5,r5,1
8112ce1c:	18bffd16 	blt	r3,r2,8112ce14 <__reset+0xfb10ce14>
8112ce20:	8809883a 	mov	r4,r17
8112ce24:	112cbc40 	call	8112cbc4 <_Balloc>
8112ce28:	d8c00717 	ldw	r3,28(sp)
8112ce2c:	10c00515 	stw	r3,20(r2)
8112ce30:	00c00044 	movi	r3,1
8112ce34:	10c00415 	stw	r3,16(r2)
8112ce38:	00c00244 	movi	r3,9
8112ce3c:	1cc0210e 	bge	r3,r19,8112cec4 <__s2b+0x100>
8112ce40:	80eb883a 	add	r21,r16,r3
8112ce44:	a829883a 	mov	r20,r21
8112ce48:	84e1883a 	add	r16,r16,r19
8112ce4c:	a1c00007 	ldb	r7,0(r20)
8112ce50:	01800284 	movi	r6,10
8112ce54:	a5000044 	addi	r20,r20,1
8112ce58:	100b883a 	mov	r5,r2
8112ce5c:	39fff404 	addi	r7,r7,-48
8112ce60:	8809883a 	mov	r4,r17
8112ce64:	112cc9c0 	call	8112cc9c <__multadd>
8112ce68:	a43ff81e 	bne	r20,r16,8112ce4c <__reset+0xfb10ce4c>
8112ce6c:	ace1883a 	add	r16,r21,r19
8112ce70:	843ffe04 	addi	r16,r16,-8
8112ce74:	9c800a0e 	bge	r19,r18,8112cea0 <__s2b+0xdc>
8112ce78:	94e5c83a 	sub	r18,r18,r19
8112ce7c:	84a5883a 	add	r18,r16,r18
8112ce80:	81c00007 	ldb	r7,0(r16)
8112ce84:	01800284 	movi	r6,10
8112ce88:	84000044 	addi	r16,r16,1
8112ce8c:	100b883a 	mov	r5,r2
8112ce90:	39fff404 	addi	r7,r7,-48
8112ce94:	8809883a 	mov	r4,r17
8112ce98:	112cc9c0 	call	8112cc9c <__multadd>
8112ce9c:	84bff81e 	bne	r16,r18,8112ce80 <__reset+0xfb10ce80>
8112cea0:	dfc00617 	ldw	ra,24(sp)
8112cea4:	dd400517 	ldw	r21,20(sp)
8112cea8:	dd000417 	ldw	r20,16(sp)
8112ceac:	dcc00317 	ldw	r19,12(sp)
8112ceb0:	dc800217 	ldw	r18,8(sp)
8112ceb4:	dc400117 	ldw	r17,4(sp)
8112ceb8:	dc000017 	ldw	r16,0(sp)
8112cebc:	dec00704 	addi	sp,sp,28
8112cec0:	f800283a 	ret
8112cec4:	84000284 	addi	r16,r16,10
8112cec8:	1827883a 	mov	r19,r3
8112cecc:	003fe906 	br	8112ce74 <__reset+0xfb10ce74>

8112ced0 <__hi0bits>:
8112ced0:	20bfffec 	andhi	r2,r4,65535
8112ced4:	1000141e 	bne	r2,zero,8112cf28 <__hi0bits+0x58>
8112ced8:	2008943a 	slli	r4,r4,16
8112cedc:	00800404 	movi	r2,16
8112cee0:	20ffc02c 	andhi	r3,r4,65280
8112cee4:	1800021e 	bne	r3,zero,8112cef0 <__hi0bits+0x20>
8112cee8:	2008923a 	slli	r4,r4,8
8112ceec:	10800204 	addi	r2,r2,8
8112cef0:	20fc002c 	andhi	r3,r4,61440
8112cef4:	1800021e 	bne	r3,zero,8112cf00 <__hi0bits+0x30>
8112cef8:	2008913a 	slli	r4,r4,4
8112cefc:	10800104 	addi	r2,r2,4
8112cf00:	20f0002c 	andhi	r3,r4,49152
8112cf04:	1800031e 	bne	r3,zero,8112cf14 <__hi0bits+0x44>
8112cf08:	2109883a 	add	r4,r4,r4
8112cf0c:	10800084 	addi	r2,r2,2
8112cf10:	2109883a 	add	r4,r4,r4
8112cf14:	20000316 	blt	r4,zero,8112cf24 <__hi0bits+0x54>
8112cf18:	2110002c 	andhi	r4,r4,16384
8112cf1c:	2000041e 	bne	r4,zero,8112cf30 <__hi0bits+0x60>
8112cf20:	00800804 	movi	r2,32
8112cf24:	f800283a 	ret
8112cf28:	0005883a 	mov	r2,zero
8112cf2c:	003fec06 	br	8112cee0 <__reset+0xfb10cee0>
8112cf30:	10800044 	addi	r2,r2,1
8112cf34:	f800283a 	ret

8112cf38 <__lo0bits>:
8112cf38:	20c00017 	ldw	r3,0(r4)
8112cf3c:	188001cc 	andi	r2,r3,7
8112cf40:	10000826 	beq	r2,zero,8112cf64 <__lo0bits+0x2c>
8112cf44:	1880004c 	andi	r2,r3,1
8112cf48:	1000211e 	bne	r2,zero,8112cfd0 <__lo0bits+0x98>
8112cf4c:	1880008c 	andi	r2,r3,2
8112cf50:	1000211e 	bne	r2,zero,8112cfd8 <__lo0bits+0xa0>
8112cf54:	1806d0ba 	srli	r3,r3,2
8112cf58:	00800084 	movi	r2,2
8112cf5c:	20c00015 	stw	r3,0(r4)
8112cf60:	f800283a 	ret
8112cf64:	18bfffcc 	andi	r2,r3,65535
8112cf68:	10001326 	beq	r2,zero,8112cfb8 <__lo0bits+0x80>
8112cf6c:	0005883a 	mov	r2,zero
8112cf70:	19403fcc 	andi	r5,r3,255
8112cf74:	2800021e 	bne	r5,zero,8112cf80 <__lo0bits+0x48>
8112cf78:	1806d23a 	srli	r3,r3,8
8112cf7c:	10800204 	addi	r2,r2,8
8112cf80:	194003cc 	andi	r5,r3,15
8112cf84:	2800021e 	bne	r5,zero,8112cf90 <__lo0bits+0x58>
8112cf88:	1806d13a 	srli	r3,r3,4
8112cf8c:	10800104 	addi	r2,r2,4
8112cf90:	194000cc 	andi	r5,r3,3
8112cf94:	2800021e 	bne	r5,zero,8112cfa0 <__lo0bits+0x68>
8112cf98:	1806d0ba 	srli	r3,r3,2
8112cf9c:	10800084 	addi	r2,r2,2
8112cfa0:	1940004c 	andi	r5,r3,1
8112cfa4:	2800081e 	bne	r5,zero,8112cfc8 <__lo0bits+0x90>
8112cfa8:	1806d07a 	srli	r3,r3,1
8112cfac:	1800051e 	bne	r3,zero,8112cfc4 <__lo0bits+0x8c>
8112cfb0:	00800804 	movi	r2,32
8112cfb4:	f800283a 	ret
8112cfb8:	1806d43a 	srli	r3,r3,16
8112cfbc:	00800404 	movi	r2,16
8112cfc0:	003feb06 	br	8112cf70 <__reset+0xfb10cf70>
8112cfc4:	10800044 	addi	r2,r2,1
8112cfc8:	20c00015 	stw	r3,0(r4)
8112cfcc:	f800283a 	ret
8112cfd0:	0005883a 	mov	r2,zero
8112cfd4:	f800283a 	ret
8112cfd8:	1806d07a 	srli	r3,r3,1
8112cfdc:	00800044 	movi	r2,1
8112cfe0:	20c00015 	stw	r3,0(r4)
8112cfe4:	f800283a 	ret

8112cfe8 <__i2b>:
8112cfe8:	defffd04 	addi	sp,sp,-12
8112cfec:	de00012e 	bgeu	sp,et,8112cff4 <__i2b+0xc>
8112cff0:	003b68fa 	trap	3
8112cff4:	dc000015 	stw	r16,0(sp)
8112cff8:	04000044 	movi	r16,1
8112cffc:	dc400115 	stw	r17,4(sp)
8112d000:	2823883a 	mov	r17,r5
8112d004:	800b883a 	mov	r5,r16
8112d008:	dfc00215 	stw	ra,8(sp)
8112d00c:	112cbc40 	call	8112cbc4 <_Balloc>
8112d010:	14400515 	stw	r17,20(r2)
8112d014:	14000415 	stw	r16,16(r2)
8112d018:	dfc00217 	ldw	ra,8(sp)
8112d01c:	dc400117 	ldw	r17,4(sp)
8112d020:	dc000017 	ldw	r16,0(sp)
8112d024:	dec00304 	addi	sp,sp,12
8112d028:	f800283a 	ret

8112d02c <__multiply>:
8112d02c:	defffa04 	addi	sp,sp,-24
8112d030:	de00012e 	bgeu	sp,et,8112d038 <__multiply+0xc>
8112d034:	003b68fa 	trap	3
8112d038:	dcc00315 	stw	r19,12(sp)
8112d03c:	dc800215 	stw	r18,8(sp)
8112d040:	34c00417 	ldw	r19,16(r6)
8112d044:	2c800417 	ldw	r18,16(r5)
8112d048:	dd000415 	stw	r20,16(sp)
8112d04c:	dc400115 	stw	r17,4(sp)
8112d050:	dfc00515 	stw	ra,20(sp)
8112d054:	dc000015 	stw	r16,0(sp)
8112d058:	2829883a 	mov	r20,r5
8112d05c:	3023883a 	mov	r17,r6
8112d060:	94c0050e 	bge	r18,r19,8112d078 <__multiply+0x4c>
8112d064:	9007883a 	mov	r3,r18
8112d068:	3029883a 	mov	r20,r6
8112d06c:	9825883a 	mov	r18,r19
8112d070:	2823883a 	mov	r17,r5
8112d074:	1827883a 	mov	r19,r3
8112d078:	a0800217 	ldw	r2,8(r20)
8112d07c:	94e1883a 	add	r16,r18,r19
8112d080:	a1400117 	ldw	r5,4(r20)
8112d084:	1400010e 	bge	r2,r16,8112d08c <__multiply+0x60>
8112d088:	29400044 	addi	r5,r5,1
8112d08c:	112cbc40 	call	8112cbc4 <_Balloc>
8112d090:	8415883a 	add	r10,r16,r16
8112d094:	12c00504 	addi	r11,r2,20
8112d098:	5295883a 	add	r10,r10,r10
8112d09c:	5a95883a 	add	r10,r11,r10
8112d0a0:	5807883a 	mov	r3,r11
8112d0a4:	5a80032e 	bgeu	r11,r10,8112d0b4 <__multiply+0x88>
8112d0a8:	18000015 	stw	zero,0(r3)
8112d0ac:	18c00104 	addi	r3,r3,4
8112d0b0:	1abffd36 	bltu	r3,r10,8112d0a8 <__reset+0xfb10d0a8>
8112d0b4:	9ce7883a 	add	r19,r19,r19
8112d0b8:	94a5883a 	add	r18,r18,r18
8112d0bc:	89800504 	addi	r6,r17,20
8112d0c0:	9ce7883a 	add	r19,r19,r19
8112d0c4:	a3400504 	addi	r13,r20,20
8112d0c8:	94a5883a 	add	r18,r18,r18
8112d0cc:	34d9883a 	add	r12,r6,r19
8112d0d0:	6c93883a 	add	r9,r13,r18
8112d0d4:	3300422e 	bgeu	r6,r12,8112d1e0 <__multiply+0x1b4>
8112d0d8:	37c00017 	ldw	ra,0(r6)
8112d0dc:	fbffffcc 	andi	r15,ra,65535
8112d0e0:	78001b26 	beq	r15,zero,8112d150 <__multiply+0x124>
8112d0e4:	5811883a 	mov	r8,r11
8112d0e8:	681d883a 	mov	r14,r13
8112d0ec:	000f883a 	mov	r7,zero
8112d0f0:	71000017 	ldw	r4,0(r14)
8112d0f4:	40c00017 	ldw	r3,0(r8)
8112d0f8:	73800104 	addi	r14,r14,4
8112d0fc:	217fffcc 	andi	r5,r4,65535
8112d100:	2bcb383a 	mul	r5,r5,r15
8112d104:	2008d43a 	srli	r4,r4,16
8112d108:	1c7fffcc 	andi	r17,r3,65535
8112d10c:	2c4b883a 	add	r5,r5,r17
8112d110:	29cb883a 	add	r5,r5,r7
8112d114:	23c9383a 	mul	r4,r4,r15
8112d118:	1806d43a 	srli	r3,r3,16
8112d11c:	280ed43a 	srli	r7,r5,16
8112d120:	297fffcc 	andi	r5,r5,65535
8112d124:	20c7883a 	add	r3,r4,r3
8112d128:	19c7883a 	add	r3,r3,r7
8112d12c:	1808943a 	slli	r4,r3,16
8112d130:	4023883a 	mov	r17,r8
8112d134:	180ed43a 	srli	r7,r3,16
8112d138:	214ab03a 	or	r5,r4,r5
8112d13c:	41400015 	stw	r5,0(r8)
8112d140:	42000104 	addi	r8,r8,4
8112d144:	727fea36 	bltu	r14,r9,8112d0f0 <__reset+0xfb10d0f0>
8112d148:	89c00115 	stw	r7,4(r17)
8112d14c:	37c00017 	ldw	ra,0(r6)
8112d150:	f83ed43a 	srli	ra,ra,16
8112d154:	f8001f26 	beq	ra,zero,8112d1d4 <__multiply+0x1a8>
8112d158:	58c00017 	ldw	r3,0(r11)
8112d15c:	681d883a 	mov	r14,r13
8112d160:	581f883a 	mov	r15,r11
8112d164:	1811883a 	mov	r8,r3
8112d168:	5825883a 	mov	r18,r11
8112d16c:	000f883a 	mov	r7,zero
8112d170:	00000106 	br	8112d178 <__multiply+0x14c>
8112d174:	8825883a 	mov	r18,r17
8112d178:	7140000b 	ldhu	r5,0(r14)
8112d17c:	4010d43a 	srli	r8,r8,16
8112d180:	193fffcc 	andi	r4,r3,65535
8112d184:	2fcb383a 	mul	r5,r5,ra
8112d188:	7bc00104 	addi	r15,r15,4
8112d18c:	73800104 	addi	r14,r14,4
8112d190:	2a0b883a 	add	r5,r5,r8
8112d194:	29cb883a 	add	r5,r5,r7
8112d198:	2806943a 	slli	r3,r5,16
8112d19c:	94400104 	addi	r17,r18,4
8112d1a0:	280ad43a 	srli	r5,r5,16
8112d1a4:	1908b03a 	or	r4,r3,r4
8112d1a8:	793fff15 	stw	r4,-4(r15)
8112d1ac:	70ffff17 	ldw	r3,-4(r14)
8112d1b0:	8a000017 	ldw	r8,0(r17)
8112d1b4:	1806d43a 	srli	r3,r3,16
8112d1b8:	413fffcc 	andi	r4,r8,65535
8112d1bc:	1fc7383a 	mul	r3,r3,ra
8112d1c0:	1907883a 	add	r3,r3,r4
8112d1c4:	1947883a 	add	r3,r3,r5
8112d1c8:	180ed43a 	srli	r7,r3,16
8112d1cc:	727fe936 	bltu	r14,r9,8112d174 <__reset+0xfb10d174>
8112d1d0:	90c00115 	stw	r3,4(r18)
8112d1d4:	31800104 	addi	r6,r6,4
8112d1d8:	5ac00104 	addi	r11,r11,4
8112d1dc:	333fbe36 	bltu	r6,r12,8112d0d8 <__reset+0xfb10d0d8>
8112d1e0:	0400090e 	bge	zero,r16,8112d208 <__multiply+0x1dc>
8112d1e4:	50ffff17 	ldw	r3,-4(r10)
8112d1e8:	52bfff04 	addi	r10,r10,-4
8112d1ec:	18000326 	beq	r3,zero,8112d1fc <__multiply+0x1d0>
8112d1f0:	00000506 	br	8112d208 <__multiply+0x1dc>
8112d1f4:	50c00017 	ldw	r3,0(r10)
8112d1f8:	1800031e 	bne	r3,zero,8112d208 <__multiply+0x1dc>
8112d1fc:	843fffc4 	addi	r16,r16,-1
8112d200:	52bfff04 	addi	r10,r10,-4
8112d204:	803ffb1e 	bne	r16,zero,8112d1f4 <__reset+0xfb10d1f4>
8112d208:	14000415 	stw	r16,16(r2)
8112d20c:	dfc00517 	ldw	ra,20(sp)
8112d210:	dd000417 	ldw	r20,16(sp)
8112d214:	dcc00317 	ldw	r19,12(sp)
8112d218:	dc800217 	ldw	r18,8(sp)
8112d21c:	dc400117 	ldw	r17,4(sp)
8112d220:	dc000017 	ldw	r16,0(sp)
8112d224:	dec00604 	addi	sp,sp,24
8112d228:	f800283a 	ret

8112d22c <__pow5mult>:
8112d22c:	defffa04 	addi	sp,sp,-24
8112d230:	de00012e 	bgeu	sp,et,8112d238 <__pow5mult+0xc>
8112d234:	003b68fa 	trap	3
8112d238:	308000cc 	andi	r2,r6,3
8112d23c:	dcc00315 	stw	r19,12(sp)
8112d240:	dc000015 	stw	r16,0(sp)
8112d244:	dfc00515 	stw	ra,20(sp)
8112d248:	dd000415 	stw	r20,16(sp)
8112d24c:	dc800215 	stw	r18,8(sp)
8112d250:	dc400115 	stw	r17,4(sp)
8112d254:	3021883a 	mov	r16,r6
8112d258:	2027883a 	mov	r19,r4
8112d25c:	10002f1e 	bne	r2,zero,8112d31c <__pow5mult+0xf0>
8112d260:	2825883a 	mov	r18,r5
8112d264:	8021d0ba 	srai	r16,r16,2
8112d268:	80001a26 	beq	r16,zero,8112d2d4 <__pow5mult+0xa8>
8112d26c:	9c401217 	ldw	r17,72(r19)
8112d270:	8800061e 	bne	r17,zero,8112d28c <__pow5mult+0x60>
8112d274:	00003406 	br	8112d348 <__pow5mult+0x11c>
8112d278:	8021d07a 	srai	r16,r16,1
8112d27c:	80001526 	beq	r16,zero,8112d2d4 <__pow5mult+0xa8>
8112d280:	88800017 	ldw	r2,0(r17)
8112d284:	10001c26 	beq	r2,zero,8112d2f8 <__pow5mult+0xcc>
8112d288:	1023883a 	mov	r17,r2
8112d28c:	8080004c 	andi	r2,r16,1
8112d290:	103ff926 	beq	r2,zero,8112d278 <__reset+0xfb10d278>
8112d294:	880d883a 	mov	r6,r17
8112d298:	900b883a 	mov	r5,r18
8112d29c:	9809883a 	mov	r4,r19
8112d2a0:	112d02c0 	call	8112d02c <__multiply>
8112d2a4:	90001b26 	beq	r18,zero,8112d314 <__pow5mult+0xe8>
8112d2a8:	91000117 	ldw	r4,4(r18)
8112d2ac:	98c01317 	ldw	r3,76(r19)
8112d2b0:	8021d07a 	srai	r16,r16,1
8112d2b4:	2109883a 	add	r4,r4,r4
8112d2b8:	2109883a 	add	r4,r4,r4
8112d2bc:	1907883a 	add	r3,r3,r4
8112d2c0:	19000017 	ldw	r4,0(r3)
8112d2c4:	91000015 	stw	r4,0(r18)
8112d2c8:	1c800015 	stw	r18,0(r3)
8112d2cc:	1025883a 	mov	r18,r2
8112d2d0:	803feb1e 	bne	r16,zero,8112d280 <__reset+0xfb10d280>
8112d2d4:	9005883a 	mov	r2,r18
8112d2d8:	dfc00517 	ldw	ra,20(sp)
8112d2dc:	dd000417 	ldw	r20,16(sp)
8112d2e0:	dcc00317 	ldw	r19,12(sp)
8112d2e4:	dc800217 	ldw	r18,8(sp)
8112d2e8:	dc400117 	ldw	r17,4(sp)
8112d2ec:	dc000017 	ldw	r16,0(sp)
8112d2f0:	dec00604 	addi	sp,sp,24
8112d2f4:	f800283a 	ret
8112d2f8:	880d883a 	mov	r6,r17
8112d2fc:	880b883a 	mov	r5,r17
8112d300:	9809883a 	mov	r4,r19
8112d304:	112d02c0 	call	8112d02c <__multiply>
8112d308:	88800015 	stw	r2,0(r17)
8112d30c:	10000015 	stw	zero,0(r2)
8112d310:	003fdd06 	br	8112d288 <__reset+0xfb10d288>
8112d314:	1025883a 	mov	r18,r2
8112d318:	003fd706 	br	8112d278 <__reset+0xfb10d278>
8112d31c:	10bfffc4 	addi	r2,r2,-1
8112d320:	1085883a 	add	r2,r2,r2
8112d324:	00e04574 	movhi	r3,33045
8112d328:	18c36904 	addi	r3,r3,3492
8112d32c:	1085883a 	add	r2,r2,r2
8112d330:	1885883a 	add	r2,r3,r2
8112d334:	11800017 	ldw	r6,0(r2)
8112d338:	000f883a 	mov	r7,zero
8112d33c:	112cc9c0 	call	8112cc9c <__multadd>
8112d340:	1025883a 	mov	r18,r2
8112d344:	003fc706 	br	8112d264 <__reset+0xfb10d264>
8112d348:	05000044 	movi	r20,1
8112d34c:	a00b883a 	mov	r5,r20
8112d350:	9809883a 	mov	r4,r19
8112d354:	112cbc40 	call	8112cbc4 <_Balloc>
8112d358:	1023883a 	mov	r17,r2
8112d35c:	00809c44 	movi	r2,625
8112d360:	88800515 	stw	r2,20(r17)
8112d364:	8d000415 	stw	r20,16(r17)
8112d368:	9c401215 	stw	r17,72(r19)
8112d36c:	88000015 	stw	zero,0(r17)
8112d370:	003fc606 	br	8112d28c <__reset+0xfb10d28c>

8112d374 <__lshift>:
8112d374:	defff904 	addi	sp,sp,-28
8112d378:	de00012e 	bgeu	sp,et,8112d380 <__lshift+0xc>
8112d37c:	003b68fa 	trap	3
8112d380:	dd400515 	stw	r21,20(sp)
8112d384:	dcc00315 	stw	r19,12(sp)
8112d388:	302bd17a 	srai	r21,r6,5
8112d38c:	2cc00417 	ldw	r19,16(r5)
8112d390:	28800217 	ldw	r2,8(r5)
8112d394:	dd000415 	stw	r20,16(sp)
8112d398:	ace7883a 	add	r19,r21,r19
8112d39c:	dc800215 	stw	r18,8(sp)
8112d3a0:	dc400115 	stw	r17,4(sp)
8112d3a4:	dc000015 	stw	r16,0(sp)
8112d3a8:	dfc00615 	stw	ra,24(sp)
8112d3ac:	9c000044 	addi	r16,r19,1
8112d3b0:	2823883a 	mov	r17,r5
8112d3b4:	3029883a 	mov	r20,r6
8112d3b8:	2025883a 	mov	r18,r4
8112d3bc:	29400117 	ldw	r5,4(r5)
8112d3c0:	1400030e 	bge	r2,r16,8112d3d0 <__lshift+0x5c>
8112d3c4:	1085883a 	add	r2,r2,r2
8112d3c8:	29400044 	addi	r5,r5,1
8112d3cc:	143ffd16 	blt	r2,r16,8112d3c4 <__reset+0xfb10d3c4>
8112d3d0:	9009883a 	mov	r4,r18
8112d3d4:	112cbc40 	call	8112cbc4 <_Balloc>
8112d3d8:	10c00504 	addi	r3,r2,20
8112d3dc:	0540070e 	bge	zero,r21,8112d3fc <__lshift+0x88>
8112d3e0:	ad6b883a 	add	r21,r21,r21
8112d3e4:	ad6b883a 	add	r21,r21,r21
8112d3e8:	1809883a 	mov	r4,r3
8112d3ec:	1d47883a 	add	r3,r3,r21
8112d3f0:	20000015 	stw	zero,0(r4)
8112d3f4:	21000104 	addi	r4,r4,4
8112d3f8:	193ffd1e 	bne	r3,r4,8112d3f0 <__reset+0xfb10d3f0>
8112d3fc:	8a000417 	ldw	r8,16(r17)
8112d400:	89000504 	addi	r4,r17,20
8112d404:	a18007cc 	andi	r6,r20,31
8112d408:	4211883a 	add	r8,r8,r8
8112d40c:	4211883a 	add	r8,r8,r8
8112d410:	2211883a 	add	r8,r4,r8
8112d414:	30002326 	beq	r6,zero,8112d4a4 <__lshift+0x130>
8112d418:	02400804 	movi	r9,32
8112d41c:	4993c83a 	sub	r9,r9,r6
8112d420:	000b883a 	mov	r5,zero
8112d424:	21c00017 	ldw	r7,0(r4)
8112d428:	1815883a 	mov	r10,r3
8112d42c:	18c00104 	addi	r3,r3,4
8112d430:	398e983a 	sll	r7,r7,r6
8112d434:	21000104 	addi	r4,r4,4
8112d438:	394ab03a 	or	r5,r7,r5
8112d43c:	197fff15 	stw	r5,-4(r3)
8112d440:	217fff17 	ldw	r5,-4(r4)
8112d444:	2a4ad83a 	srl	r5,r5,r9
8112d448:	223ff636 	bltu	r4,r8,8112d424 <__reset+0xfb10d424>
8112d44c:	51400115 	stw	r5,4(r10)
8112d450:	28001a1e 	bne	r5,zero,8112d4bc <__lshift+0x148>
8112d454:	843fffc4 	addi	r16,r16,-1
8112d458:	14000415 	stw	r16,16(r2)
8112d45c:	88000826 	beq	r17,zero,8112d480 <__lshift+0x10c>
8112d460:	89000117 	ldw	r4,4(r17)
8112d464:	90c01317 	ldw	r3,76(r18)
8112d468:	2109883a 	add	r4,r4,r4
8112d46c:	2109883a 	add	r4,r4,r4
8112d470:	1907883a 	add	r3,r3,r4
8112d474:	19000017 	ldw	r4,0(r3)
8112d478:	89000015 	stw	r4,0(r17)
8112d47c:	1c400015 	stw	r17,0(r3)
8112d480:	dfc00617 	ldw	ra,24(sp)
8112d484:	dd400517 	ldw	r21,20(sp)
8112d488:	dd000417 	ldw	r20,16(sp)
8112d48c:	dcc00317 	ldw	r19,12(sp)
8112d490:	dc800217 	ldw	r18,8(sp)
8112d494:	dc400117 	ldw	r17,4(sp)
8112d498:	dc000017 	ldw	r16,0(sp)
8112d49c:	dec00704 	addi	sp,sp,28
8112d4a0:	f800283a 	ret
8112d4a4:	21400017 	ldw	r5,0(r4)
8112d4a8:	18c00104 	addi	r3,r3,4
8112d4ac:	21000104 	addi	r4,r4,4
8112d4b0:	197fff15 	stw	r5,-4(r3)
8112d4b4:	223ffb36 	bltu	r4,r8,8112d4a4 <__reset+0xfb10d4a4>
8112d4b8:	003fe606 	br	8112d454 <__reset+0xfb10d454>
8112d4bc:	9c000084 	addi	r16,r19,2
8112d4c0:	003fe406 	br	8112d454 <__reset+0xfb10d454>

8112d4c4 <__mcmp>:
8112d4c4:	20800417 	ldw	r2,16(r4)
8112d4c8:	28c00417 	ldw	r3,16(r5)
8112d4cc:	10c5c83a 	sub	r2,r2,r3
8112d4d0:	1000111e 	bne	r2,zero,8112d518 <__mcmp+0x54>
8112d4d4:	18c7883a 	add	r3,r3,r3
8112d4d8:	18c7883a 	add	r3,r3,r3
8112d4dc:	21000504 	addi	r4,r4,20
8112d4e0:	29400504 	addi	r5,r5,20
8112d4e4:	20c5883a 	add	r2,r4,r3
8112d4e8:	28cb883a 	add	r5,r5,r3
8112d4ec:	00000106 	br	8112d4f4 <__mcmp+0x30>
8112d4f0:	20800a2e 	bgeu	r4,r2,8112d51c <__mcmp+0x58>
8112d4f4:	10bfff04 	addi	r2,r2,-4
8112d4f8:	297fff04 	addi	r5,r5,-4
8112d4fc:	11800017 	ldw	r6,0(r2)
8112d500:	28c00017 	ldw	r3,0(r5)
8112d504:	30fffa26 	beq	r6,r3,8112d4f0 <__reset+0xfb10d4f0>
8112d508:	30c00236 	bltu	r6,r3,8112d514 <__mcmp+0x50>
8112d50c:	00800044 	movi	r2,1
8112d510:	f800283a 	ret
8112d514:	00bfffc4 	movi	r2,-1
8112d518:	f800283a 	ret
8112d51c:	0005883a 	mov	r2,zero
8112d520:	f800283a 	ret

8112d524 <__mdiff>:
8112d524:	defffa04 	addi	sp,sp,-24
8112d528:	de00012e 	bgeu	sp,et,8112d530 <__mdiff+0xc>
8112d52c:	003b68fa 	trap	3
8112d530:	28c00417 	ldw	r3,16(r5)
8112d534:	30800417 	ldw	r2,16(r6)
8112d538:	dcc00315 	stw	r19,12(sp)
8112d53c:	dc800215 	stw	r18,8(sp)
8112d540:	dfc00515 	stw	ra,20(sp)
8112d544:	dd000415 	stw	r20,16(sp)
8112d548:	dc400115 	stw	r17,4(sp)
8112d54c:	dc000015 	stw	r16,0(sp)
8112d550:	1887c83a 	sub	r3,r3,r2
8112d554:	2825883a 	mov	r18,r5
8112d558:	3027883a 	mov	r19,r6
8112d55c:	1800141e 	bne	r3,zero,8112d5b0 <__mdiff+0x8c>
8112d560:	1085883a 	add	r2,r2,r2
8112d564:	1085883a 	add	r2,r2,r2
8112d568:	2a000504 	addi	r8,r5,20
8112d56c:	34000504 	addi	r16,r6,20
8112d570:	4087883a 	add	r3,r8,r2
8112d574:	8085883a 	add	r2,r16,r2
8112d578:	00000106 	br	8112d580 <__mdiff+0x5c>
8112d57c:	40c0592e 	bgeu	r8,r3,8112d6e4 <__mdiff+0x1c0>
8112d580:	18ffff04 	addi	r3,r3,-4
8112d584:	10bfff04 	addi	r2,r2,-4
8112d588:	19c00017 	ldw	r7,0(r3)
8112d58c:	11400017 	ldw	r5,0(r2)
8112d590:	397ffa26 	beq	r7,r5,8112d57c <__reset+0xfb10d57c>
8112d594:	3940592e 	bgeu	r7,r5,8112d6fc <__mdiff+0x1d8>
8112d598:	9005883a 	mov	r2,r18
8112d59c:	4023883a 	mov	r17,r8
8112d5a0:	9825883a 	mov	r18,r19
8112d5a4:	05000044 	movi	r20,1
8112d5a8:	1027883a 	mov	r19,r2
8112d5ac:	00000406 	br	8112d5c0 <__mdiff+0x9c>
8112d5b0:	18005616 	blt	r3,zero,8112d70c <__mdiff+0x1e8>
8112d5b4:	34400504 	addi	r17,r6,20
8112d5b8:	2c000504 	addi	r16,r5,20
8112d5bc:	0029883a 	mov	r20,zero
8112d5c0:	91400117 	ldw	r5,4(r18)
8112d5c4:	112cbc40 	call	8112cbc4 <_Balloc>
8112d5c8:	92400417 	ldw	r9,16(r18)
8112d5cc:	9b000417 	ldw	r12,16(r19)
8112d5d0:	12c00504 	addi	r11,r2,20
8112d5d4:	4a51883a 	add	r8,r9,r9
8112d5d8:	6319883a 	add	r12,r12,r12
8112d5dc:	4211883a 	add	r8,r8,r8
8112d5e0:	6319883a 	add	r12,r12,r12
8112d5e4:	15000315 	stw	r20,12(r2)
8112d5e8:	8211883a 	add	r8,r16,r8
8112d5ec:	8b19883a 	add	r12,r17,r12
8112d5f0:	0007883a 	mov	r3,zero
8112d5f4:	81400017 	ldw	r5,0(r16)
8112d5f8:	89c00017 	ldw	r7,0(r17)
8112d5fc:	59800104 	addi	r6,r11,4
8112d600:	293fffcc 	andi	r4,r5,65535
8112d604:	20c7883a 	add	r3,r4,r3
8112d608:	393fffcc 	andi	r4,r7,65535
8112d60c:	1909c83a 	sub	r4,r3,r4
8112d610:	280ad43a 	srli	r5,r5,16
8112d614:	380ed43a 	srli	r7,r7,16
8112d618:	2007d43a 	srai	r3,r4,16
8112d61c:	213fffcc 	andi	r4,r4,65535
8112d620:	29cbc83a 	sub	r5,r5,r7
8112d624:	28c7883a 	add	r3,r5,r3
8112d628:	180a943a 	slli	r5,r3,16
8112d62c:	8c400104 	addi	r17,r17,4
8112d630:	84000104 	addi	r16,r16,4
8112d634:	2908b03a 	or	r4,r5,r4
8112d638:	59000015 	stw	r4,0(r11)
8112d63c:	1807d43a 	srai	r3,r3,16
8112d640:	3015883a 	mov	r10,r6
8112d644:	3017883a 	mov	r11,r6
8112d648:	8b3fea36 	bltu	r17,r12,8112d5f4 <__reset+0xfb10d5f4>
8112d64c:	8200162e 	bgeu	r16,r8,8112d6a8 <__mdiff+0x184>
8112d650:	8017883a 	mov	r11,r16
8112d654:	59400017 	ldw	r5,0(r11)
8112d658:	31800104 	addi	r6,r6,4
8112d65c:	5ac00104 	addi	r11,r11,4
8112d660:	293fffcc 	andi	r4,r5,65535
8112d664:	20c7883a 	add	r3,r4,r3
8112d668:	280ed43a 	srli	r7,r5,16
8112d66c:	180bd43a 	srai	r5,r3,16
8112d670:	193fffcc 	andi	r4,r3,65535
8112d674:	3947883a 	add	r3,r7,r5
8112d678:	180a943a 	slli	r5,r3,16
8112d67c:	1807d43a 	srai	r3,r3,16
8112d680:	2908b03a 	or	r4,r5,r4
8112d684:	313fff15 	stw	r4,-4(r6)
8112d688:	5a3ff236 	bltu	r11,r8,8112d654 <__reset+0xfb10d654>
8112d68c:	0406303a 	nor	r3,zero,r16
8112d690:	1a07883a 	add	r3,r3,r8
8112d694:	1806d0ba 	srli	r3,r3,2
8112d698:	18c00044 	addi	r3,r3,1
8112d69c:	18c7883a 	add	r3,r3,r3
8112d6a0:	18c7883a 	add	r3,r3,r3
8112d6a4:	50d5883a 	add	r10,r10,r3
8112d6a8:	50ffff04 	addi	r3,r10,-4
8112d6ac:	2000041e 	bne	r4,zero,8112d6c0 <__mdiff+0x19c>
8112d6b0:	18ffff04 	addi	r3,r3,-4
8112d6b4:	19000017 	ldw	r4,0(r3)
8112d6b8:	4a7fffc4 	addi	r9,r9,-1
8112d6bc:	203ffc26 	beq	r4,zero,8112d6b0 <__reset+0xfb10d6b0>
8112d6c0:	12400415 	stw	r9,16(r2)
8112d6c4:	dfc00517 	ldw	ra,20(sp)
8112d6c8:	dd000417 	ldw	r20,16(sp)
8112d6cc:	dcc00317 	ldw	r19,12(sp)
8112d6d0:	dc800217 	ldw	r18,8(sp)
8112d6d4:	dc400117 	ldw	r17,4(sp)
8112d6d8:	dc000017 	ldw	r16,0(sp)
8112d6dc:	dec00604 	addi	sp,sp,24
8112d6e0:	f800283a 	ret
8112d6e4:	000b883a 	mov	r5,zero
8112d6e8:	112cbc40 	call	8112cbc4 <_Balloc>
8112d6ec:	00c00044 	movi	r3,1
8112d6f0:	10c00415 	stw	r3,16(r2)
8112d6f4:	10000515 	stw	zero,20(r2)
8112d6f8:	003ff206 	br	8112d6c4 <__reset+0xfb10d6c4>
8112d6fc:	8023883a 	mov	r17,r16
8112d700:	0029883a 	mov	r20,zero
8112d704:	4021883a 	mov	r16,r8
8112d708:	003fad06 	br	8112d5c0 <__reset+0xfb10d5c0>
8112d70c:	9005883a 	mov	r2,r18
8112d710:	94400504 	addi	r17,r18,20
8112d714:	9c000504 	addi	r16,r19,20
8112d718:	9825883a 	mov	r18,r19
8112d71c:	05000044 	movi	r20,1
8112d720:	1027883a 	mov	r19,r2
8112d724:	003fa606 	br	8112d5c0 <__reset+0xfb10d5c0>

8112d728 <__ulp>:
8112d728:	295ffc2c 	andhi	r5,r5,32752
8112d72c:	00bf3034 	movhi	r2,64704
8112d730:	2887883a 	add	r3,r5,r2
8112d734:	00c0020e 	bge	zero,r3,8112d740 <__ulp+0x18>
8112d738:	0005883a 	mov	r2,zero
8112d73c:	f800283a 	ret
8112d740:	00c7c83a 	sub	r3,zero,r3
8112d744:	1807d53a 	srai	r3,r3,20
8112d748:	008004c4 	movi	r2,19
8112d74c:	10c00b0e 	bge	r2,r3,8112d77c <__ulp+0x54>
8112d750:	18bffb04 	addi	r2,r3,-20
8112d754:	01000784 	movi	r4,30
8112d758:	0007883a 	mov	r3,zero
8112d75c:	20800516 	blt	r4,r2,8112d774 <__ulp+0x4c>
8112d760:	010007c4 	movi	r4,31
8112d764:	2089c83a 	sub	r4,r4,r2
8112d768:	00800044 	movi	r2,1
8112d76c:	1104983a 	sll	r2,r2,r4
8112d770:	f800283a 	ret
8112d774:	00800044 	movi	r2,1
8112d778:	f800283a 	ret
8112d77c:	01400234 	movhi	r5,8
8112d780:	28c7d83a 	sra	r3,r5,r3
8112d784:	0005883a 	mov	r2,zero
8112d788:	f800283a 	ret

8112d78c <__b2d>:
8112d78c:	defffa04 	addi	sp,sp,-24
8112d790:	de00012e 	bgeu	sp,et,8112d798 <__b2d+0xc>
8112d794:	003b68fa 	trap	3
8112d798:	dc000015 	stw	r16,0(sp)
8112d79c:	24000417 	ldw	r16,16(r4)
8112d7a0:	dc400115 	stw	r17,4(sp)
8112d7a4:	24400504 	addi	r17,r4,20
8112d7a8:	8421883a 	add	r16,r16,r16
8112d7ac:	8421883a 	add	r16,r16,r16
8112d7b0:	8c21883a 	add	r16,r17,r16
8112d7b4:	dc800215 	stw	r18,8(sp)
8112d7b8:	84bfff17 	ldw	r18,-4(r16)
8112d7bc:	dd000415 	stw	r20,16(sp)
8112d7c0:	dcc00315 	stw	r19,12(sp)
8112d7c4:	9009883a 	mov	r4,r18
8112d7c8:	2829883a 	mov	r20,r5
8112d7cc:	dfc00515 	stw	ra,20(sp)
8112d7d0:	112ced00 	call	8112ced0 <__hi0bits>
8112d7d4:	00c00804 	movi	r3,32
8112d7d8:	1889c83a 	sub	r4,r3,r2
8112d7dc:	a1000015 	stw	r4,0(r20)
8112d7e0:	01000284 	movi	r4,10
8112d7e4:	84ffff04 	addi	r19,r16,-4
8112d7e8:	20801216 	blt	r4,r2,8112d834 <__b2d+0xa8>
8112d7ec:	018002c4 	movi	r6,11
8112d7f0:	308dc83a 	sub	r6,r6,r2
8112d7f4:	9186d83a 	srl	r3,r18,r6
8112d7f8:	18cffc34 	orhi	r3,r3,16368
8112d7fc:	8cc0212e 	bgeu	r17,r19,8112d884 <__b2d+0xf8>
8112d800:	813ffe17 	ldw	r4,-8(r16)
8112d804:	218cd83a 	srl	r6,r4,r6
8112d808:	10800544 	addi	r2,r2,21
8112d80c:	9084983a 	sll	r2,r18,r2
8112d810:	1184b03a 	or	r2,r2,r6
8112d814:	dfc00517 	ldw	ra,20(sp)
8112d818:	dd000417 	ldw	r20,16(sp)
8112d81c:	dcc00317 	ldw	r19,12(sp)
8112d820:	dc800217 	ldw	r18,8(sp)
8112d824:	dc400117 	ldw	r17,4(sp)
8112d828:	dc000017 	ldw	r16,0(sp)
8112d82c:	dec00604 	addi	sp,sp,24
8112d830:	f800283a 	ret
8112d834:	8cc00f2e 	bgeu	r17,r19,8112d874 <__b2d+0xe8>
8112d838:	117ffd44 	addi	r5,r2,-11
8112d83c:	80bffe17 	ldw	r2,-8(r16)
8112d840:	28000e26 	beq	r5,zero,8112d87c <__b2d+0xf0>
8112d844:	1949c83a 	sub	r4,r3,r5
8112d848:	9164983a 	sll	r18,r18,r5
8112d84c:	1106d83a 	srl	r3,r2,r4
8112d850:	81bffe04 	addi	r6,r16,-8
8112d854:	948ffc34 	orhi	r18,r18,16368
8112d858:	90c6b03a 	or	r3,r18,r3
8112d85c:	89800e2e 	bgeu	r17,r6,8112d898 <__b2d+0x10c>
8112d860:	81bffd17 	ldw	r6,-12(r16)
8112d864:	1144983a 	sll	r2,r2,r5
8112d868:	310ad83a 	srl	r5,r6,r4
8112d86c:	2884b03a 	or	r2,r5,r2
8112d870:	003fe806 	br	8112d814 <__reset+0xfb10d814>
8112d874:	10bffd44 	addi	r2,r2,-11
8112d878:	1000041e 	bne	r2,zero,8112d88c <__b2d+0x100>
8112d87c:	90cffc34 	orhi	r3,r18,16368
8112d880:	003fe406 	br	8112d814 <__reset+0xfb10d814>
8112d884:	000d883a 	mov	r6,zero
8112d888:	003fdf06 	br	8112d808 <__reset+0xfb10d808>
8112d88c:	90a4983a 	sll	r18,r18,r2
8112d890:	0005883a 	mov	r2,zero
8112d894:	003ff906 	br	8112d87c <__reset+0xfb10d87c>
8112d898:	1144983a 	sll	r2,r2,r5
8112d89c:	003fdd06 	br	8112d814 <__reset+0xfb10d814>

8112d8a0 <__d2b>:
8112d8a0:	defff804 	addi	sp,sp,-32
8112d8a4:	de00012e 	bgeu	sp,et,8112d8ac <__d2b+0xc>
8112d8a8:	003b68fa 	trap	3
8112d8ac:	dc000215 	stw	r16,8(sp)
8112d8b0:	3021883a 	mov	r16,r6
8112d8b4:	dc400315 	stw	r17,12(sp)
8112d8b8:	8022907a 	slli	r17,r16,1
8112d8bc:	dd000615 	stw	r20,24(sp)
8112d8c0:	2829883a 	mov	r20,r5
8112d8c4:	01400044 	movi	r5,1
8112d8c8:	dcc00515 	stw	r19,20(sp)
8112d8cc:	dc800415 	stw	r18,16(sp)
8112d8d0:	dfc00715 	stw	ra,28(sp)
8112d8d4:	3825883a 	mov	r18,r7
8112d8d8:	8822d57a 	srli	r17,r17,21
8112d8dc:	112cbc40 	call	8112cbc4 <_Balloc>
8112d8e0:	1027883a 	mov	r19,r2
8112d8e4:	00800434 	movhi	r2,16
8112d8e8:	10bfffc4 	addi	r2,r2,-1
8112d8ec:	808c703a 	and	r6,r16,r2
8112d8f0:	88000126 	beq	r17,zero,8112d8f8 <__d2b+0x58>
8112d8f4:	31800434 	orhi	r6,r6,16
8112d8f8:	d9800015 	stw	r6,0(sp)
8112d8fc:	a0002426 	beq	r20,zero,8112d990 <__d2b+0xf0>
8112d900:	d9000104 	addi	r4,sp,4
8112d904:	dd000115 	stw	r20,4(sp)
8112d908:	112cf380 	call	8112cf38 <__lo0bits>
8112d90c:	d8c00017 	ldw	r3,0(sp)
8112d910:	10002f1e 	bne	r2,zero,8112d9d0 <__d2b+0x130>
8112d914:	d9000117 	ldw	r4,4(sp)
8112d918:	99000515 	stw	r4,20(r19)
8112d91c:	1821003a 	cmpeq	r16,r3,zero
8112d920:	01000084 	movi	r4,2
8112d924:	2421c83a 	sub	r16,r4,r16
8112d928:	98c00615 	stw	r3,24(r19)
8112d92c:	9c000415 	stw	r16,16(r19)
8112d930:	88001f1e 	bne	r17,zero,8112d9b0 <__d2b+0x110>
8112d934:	10bef384 	addi	r2,r2,-1074
8112d938:	90800015 	stw	r2,0(r18)
8112d93c:	00900034 	movhi	r2,16384
8112d940:	10bfffc4 	addi	r2,r2,-1
8112d944:	8085883a 	add	r2,r16,r2
8112d948:	1085883a 	add	r2,r2,r2
8112d94c:	1085883a 	add	r2,r2,r2
8112d950:	9885883a 	add	r2,r19,r2
8112d954:	11000517 	ldw	r4,20(r2)
8112d958:	8020917a 	slli	r16,r16,5
8112d95c:	112ced00 	call	8112ced0 <__hi0bits>
8112d960:	d8c00817 	ldw	r3,32(sp)
8112d964:	8085c83a 	sub	r2,r16,r2
8112d968:	18800015 	stw	r2,0(r3)
8112d96c:	9805883a 	mov	r2,r19
8112d970:	dfc00717 	ldw	ra,28(sp)
8112d974:	dd000617 	ldw	r20,24(sp)
8112d978:	dcc00517 	ldw	r19,20(sp)
8112d97c:	dc800417 	ldw	r18,16(sp)
8112d980:	dc400317 	ldw	r17,12(sp)
8112d984:	dc000217 	ldw	r16,8(sp)
8112d988:	dec00804 	addi	sp,sp,32
8112d98c:	f800283a 	ret
8112d990:	d809883a 	mov	r4,sp
8112d994:	112cf380 	call	8112cf38 <__lo0bits>
8112d998:	d8c00017 	ldw	r3,0(sp)
8112d99c:	04000044 	movi	r16,1
8112d9a0:	9c000415 	stw	r16,16(r19)
8112d9a4:	98c00515 	stw	r3,20(r19)
8112d9a8:	10800804 	addi	r2,r2,32
8112d9ac:	883fe126 	beq	r17,zero,8112d934 <__reset+0xfb10d934>
8112d9b0:	00c00d44 	movi	r3,53
8112d9b4:	8c7ef344 	addi	r17,r17,-1075
8112d9b8:	88a3883a 	add	r17,r17,r2
8112d9bc:	1885c83a 	sub	r2,r3,r2
8112d9c0:	d8c00817 	ldw	r3,32(sp)
8112d9c4:	94400015 	stw	r17,0(r18)
8112d9c8:	18800015 	stw	r2,0(r3)
8112d9cc:	003fe706 	br	8112d96c <__reset+0xfb10d96c>
8112d9d0:	01000804 	movi	r4,32
8112d9d4:	2089c83a 	sub	r4,r4,r2
8112d9d8:	1908983a 	sll	r4,r3,r4
8112d9dc:	d9400117 	ldw	r5,4(sp)
8112d9e0:	1886d83a 	srl	r3,r3,r2
8112d9e4:	2148b03a 	or	r4,r4,r5
8112d9e8:	99000515 	stw	r4,20(r19)
8112d9ec:	d8c00015 	stw	r3,0(sp)
8112d9f0:	003fca06 	br	8112d91c <__reset+0xfb10d91c>

8112d9f4 <__ratio>:
8112d9f4:	defff904 	addi	sp,sp,-28
8112d9f8:	de00012e 	bgeu	sp,et,8112da00 <__ratio+0xc>
8112d9fc:	003b68fa 	trap	3
8112da00:	dc400315 	stw	r17,12(sp)
8112da04:	2823883a 	mov	r17,r5
8112da08:	d9400104 	addi	r5,sp,4
8112da0c:	dfc00615 	stw	ra,24(sp)
8112da10:	dcc00515 	stw	r19,20(sp)
8112da14:	dc800415 	stw	r18,16(sp)
8112da18:	2027883a 	mov	r19,r4
8112da1c:	dc000215 	stw	r16,8(sp)
8112da20:	112d78c0 	call	8112d78c <__b2d>
8112da24:	d80b883a 	mov	r5,sp
8112da28:	8809883a 	mov	r4,r17
8112da2c:	1025883a 	mov	r18,r2
8112da30:	1821883a 	mov	r16,r3
8112da34:	112d78c0 	call	8112d78c <__b2d>
8112da38:	8a000417 	ldw	r8,16(r17)
8112da3c:	99000417 	ldw	r4,16(r19)
8112da40:	d9400117 	ldw	r5,4(sp)
8112da44:	2209c83a 	sub	r4,r4,r8
8112da48:	2010917a 	slli	r8,r4,5
8112da4c:	d9000017 	ldw	r4,0(sp)
8112da50:	2909c83a 	sub	r4,r5,r4
8112da54:	4109883a 	add	r4,r8,r4
8112da58:	01000e0e 	bge	zero,r4,8112da94 <__ratio+0xa0>
8112da5c:	2008953a 	slli	r4,r4,20
8112da60:	2421883a 	add	r16,r4,r16
8112da64:	100d883a 	mov	r6,r2
8112da68:	180f883a 	mov	r7,r3
8112da6c:	9009883a 	mov	r4,r18
8112da70:	800b883a 	mov	r5,r16
8112da74:	11357840 	call	81135784 <__divdf3>
8112da78:	dfc00617 	ldw	ra,24(sp)
8112da7c:	dcc00517 	ldw	r19,20(sp)
8112da80:	dc800417 	ldw	r18,16(sp)
8112da84:	dc400317 	ldw	r17,12(sp)
8112da88:	dc000217 	ldw	r16,8(sp)
8112da8c:	dec00704 	addi	sp,sp,28
8112da90:	f800283a 	ret
8112da94:	2008953a 	slli	r4,r4,20
8112da98:	1907c83a 	sub	r3,r3,r4
8112da9c:	003ff106 	br	8112da64 <__reset+0xfb10da64>

8112daa0 <_mprec_log10>:
8112daa0:	defffe04 	addi	sp,sp,-8
8112daa4:	de00012e 	bgeu	sp,et,8112daac <_mprec_log10+0xc>
8112daa8:	003b68fa 	trap	3
8112daac:	008005c4 	movi	r2,23
8112dab0:	dc000015 	stw	r16,0(sp)
8112dab4:	dfc00115 	stw	ra,4(sp)
8112dab8:	2021883a 	mov	r16,r4
8112dabc:	11000d0e 	bge	r2,r4,8112daf4 <_mprec_log10+0x54>
8112dac0:	0005883a 	mov	r2,zero
8112dac4:	00cffc34 	movhi	r3,16368
8112dac8:	843fffc4 	addi	r16,r16,-1
8112dacc:	000d883a 	mov	r6,zero
8112dad0:	01d00934 	movhi	r7,16420
8112dad4:	1009883a 	mov	r4,r2
8112dad8:	180b883a 	mov	r5,r3
8112dadc:	111ffc00 	call	8111ffc0 <__muldf3>
8112dae0:	803ff91e 	bne	r16,zero,8112dac8 <__reset+0xfb10dac8>
8112dae4:	dfc00117 	ldw	ra,4(sp)
8112dae8:	dc000017 	ldw	r16,0(sp)
8112daec:	dec00204 	addi	sp,sp,8
8112daf0:	f800283a 	ret
8112daf4:	202090fa 	slli	r16,r4,3
8112daf8:	00a04574 	movhi	r2,33045
8112dafc:	10838004 	addi	r2,r2,3584
8112db00:	1421883a 	add	r16,r2,r16
8112db04:	80800017 	ldw	r2,0(r16)
8112db08:	80c00117 	ldw	r3,4(r16)
8112db0c:	dfc00117 	ldw	ra,4(sp)
8112db10:	dc000017 	ldw	r16,0(sp)
8112db14:	dec00204 	addi	sp,sp,8
8112db18:	f800283a 	ret

8112db1c <__copybits>:
8112db1c:	297fffc4 	addi	r5,r5,-1
8112db20:	280fd17a 	srai	r7,r5,5
8112db24:	30c00417 	ldw	r3,16(r6)
8112db28:	30800504 	addi	r2,r6,20
8112db2c:	39c00044 	addi	r7,r7,1
8112db30:	18c7883a 	add	r3,r3,r3
8112db34:	39cf883a 	add	r7,r7,r7
8112db38:	18c7883a 	add	r3,r3,r3
8112db3c:	39cf883a 	add	r7,r7,r7
8112db40:	10c7883a 	add	r3,r2,r3
8112db44:	21cf883a 	add	r7,r4,r7
8112db48:	10c00d2e 	bgeu	r2,r3,8112db80 <__copybits+0x64>
8112db4c:	200b883a 	mov	r5,r4
8112db50:	12000017 	ldw	r8,0(r2)
8112db54:	29400104 	addi	r5,r5,4
8112db58:	10800104 	addi	r2,r2,4
8112db5c:	2a3fff15 	stw	r8,-4(r5)
8112db60:	10fffb36 	bltu	r2,r3,8112db50 <__reset+0xfb10db50>
8112db64:	1985c83a 	sub	r2,r3,r6
8112db68:	10bffac4 	addi	r2,r2,-21
8112db6c:	1004d0ba 	srli	r2,r2,2
8112db70:	10800044 	addi	r2,r2,1
8112db74:	1085883a 	add	r2,r2,r2
8112db78:	1085883a 	add	r2,r2,r2
8112db7c:	2089883a 	add	r4,r4,r2
8112db80:	21c0032e 	bgeu	r4,r7,8112db90 <__copybits+0x74>
8112db84:	20000015 	stw	zero,0(r4)
8112db88:	21000104 	addi	r4,r4,4
8112db8c:	21fffd36 	bltu	r4,r7,8112db84 <__reset+0xfb10db84>
8112db90:	f800283a 	ret

8112db94 <__any_on>:
8112db94:	20c00417 	ldw	r3,16(r4)
8112db98:	2805d17a 	srai	r2,r5,5
8112db9c:	21000504 	addi	r4,r4,20
8112dba0:	18800d0e 	bge	r3,r2,8112dbd8 <__any_on+0x44>
8112dba4:	18c7883a 	add	r3,r3,r3
8112dba8:	18c7883a 	add	r3,r3,r3
8112dbac:	20c7883a 	add	r3,r4,r3
8112dbb0:	20c0192e 	bgeu	r4,r3,8112dc18 <__any_on+0x84>
8112dbb4:	18bfff17 	ldw	r2,-4(r3)
8112dbb8:	18ffff04 	addi	r3,r3,-4
8112dbbc:	1000041e 	bne	r2,zero,8112dbd0 <__any_on+0x3c>
8112dbc0:	20c0142e 	bgeu	r4,r3,8112dc14 <__any_on+0x80>
8112dbc4:	18ffff04 	addi	r3,r3,-4
8112dbc8:	19400017 	ldw	r5,0(r3)
8112dbcc:	283ffc26 	beq	r5,zero,8112dbc0 <__reset+0xfb10dbc0>
8112dbd0:	00800044 	movi	r2,1
8112dbd4:	f800283a 	ret
8112dbd8:	10c00a0e 	bge	r2,r3,8112dc04 <__any_on+0x70>
8112dbdc:	1085883a 	add	r2,r2,r2
8112dbe0:	1085883a 	add	r2,r2,r2
8112dbe4:	294007cc 	andi	r5,r5,31
8112dbe8:	2087883a 	add	r3,r4,r2
8112dbec:	283ff026 	beq	r5,zero,8112dbb0 <__reset+0xfb10dbb0>
8112dbf0:	19800017 	ldw	r6,0(r3)
8112dbf4:	3144d83a 	srl	r2,r6,r5
8112dbf8:	114a983a 	sll	r5,r2,r5
8112dbfc:	317ff41e 	bne	r6,r5,8112dbd0 <__reset+0xfb10dbd0>
8112dc00:	003feb06 	br	8112dbb0 <__reset+0xfb10dbb0>
8112dc04:	1085883a 	add	r2,r2,r2
8112dc08:	1085883a 	add	r2,r2,r2
8112dc0c:	2087883a 	add	r3,r4,r2
8112dc10:	003fe706 	br	8112dbb0 <__reset+0xfb10dbb0>
8112dc14:	f800283a 	ret
8112dc18:	0005883a 	mov	r2,zero
8112dc1c:	f800283a 	ret

8112dc20 <_read_r>:
8112dc20:	defffd04 	addi	sp,sp,-12
8112dc24:	de00012e 	bgeu	sp,et,8112dc2c <_read_r+0xc>
8112dc28:	003b68fa 	trap	3
8112dc2c:	2805883a 	mov	r2,r5
8112dc30:	dc000015 	stw	r16,0(sp)
8112dc34:	04204574 	movhi	r16,33045
8112dc38:	dc400115 	stw	r17,4(sp)
8112dc3c:	300b883a 	mov	r5,r6
8112dc40:	840d8204 	addi	r16,r16,13832
8112dc44:	2023883a 	mov	r17,r4
8112dc48:	380d883a 	mov	r6,r7
8112dc4c:	1009883a 	mov	r4,r2
8112dc50:	dfc00215 	stw	ra,8(sp)
8112dc54:	80000015 	stw	zero,0(r16)
8112dc58:	11378f40 	call	811378f4 <read>
8112dc5c:	00ffffc4 	movi	r3,-1
8112dc60:	10c00526 	beq	r2,r3,8112dc78 <_read_r+0x58>
8112dc64:	dfc00217 	ldw	ra,8(sp)
8112dc68:	dc400117 	ldw	r17,4(sp)
8112dc6c:	dc000017 	ldw	r16,0(sp)
8112dc70:	dec00304 	addi	sp,sp,12
8112dc74:	f800283a 	ret
8112dc78:	80c00017 	ldw	r3,0(r16)
8112dc7c:	183ff926 	beq	r3,zero,8112dc64 <__reset+0xfb10dc64>
8112dc80:	88c00015 	stw	r3,0(r17)
8112dc84:	003ff706 	br	8112dc64 <__reset+0xfb10dc64>

8112dc88 <_realloc_r>:
8112dc88:	defff604 	addi	sp,sp,-40
8112dc8c:	de00012e 	bgeu	sp,et,8112dc94 <_realloc_r+0xc>
8112dc90:	003b68fa 	trap	3
8112dc94:	dc800215 	stw	r18,8(sp)
8112dc98:	dfc00915 	stw	ra,36(sp)
8112dc9c:	df000815 	stw	fp,32(sp)
8112dca0:	ddc00715 	stw	r23,28(sp)
8112dca4:	dd800615 	stw	r22,24(sp)
8112dca8:	dd400515 	stw	r21,20(sp)
8112dcac:	dd000415 	stw	r20,16(sp)
8112dcb0:	dcc00315 	stw	r19,12(sp)
8112dcb4:	dc400115 	stw	r17,4(sp)
8112dcb8:	dc000015 	stw	r16,0(sp)
8112dcbc:	3025883a 	mov	r18,r6
8112dcc0:	2800b726 	beq	r5,zero,8112dfa0 <_realloc_r+0x318>
8112dcc4:	282b883a 	mov	r21,r5
8112dcc8:	2029883a 	mov	r20,r4
8112dccc:	11380d40 	call	811380d4 <__malloc_lock>
8112dcd0:	a8bfff17 	ldw	r2,-4(r21)
8112dcd4:	043fff04 	movi	r16,-4
8112dcd8:	90c002c4 	addi	r3,r18,11
8112dcdc:	01000584 	movi	r4,22
8112dce0:	acfffe04 	addi	r19,r21,-8
8112dce4:	1420703a 	and	r16,r2,r16
8112dce8:	20c0332e 	bgeu	r4,r3,8112ddb8 <_realloc_r+0x130>
8112dcec:	047ffe04 	movi	r17,-8
8112dcf0:	1c62703a 	and	r17,r3,r17
8112dcf4:	8807883a 	mov	r3,r17
8112dcf8:	88005816 	blt	r17,zero,8112de5c <_realloc_r+0x1d4>
8112dcfc:	8c805736 	bltu	r17,r18,8112de5c <_realloc_r+0x1d4>
8112dd00:	80c0300e 	bge	r16,r3,8112ddc4 <_realloc_r+0x13c>
8112dd04:	07204574 	movhi	fp,33045
8112dd08:	e706cd04 	addi	fp,fp,6964
8112dd0c:	e1c00217 	ldw	r7,8(fp)
8112dd10:	9c09883a 	add	r4,r19,r16
8112dd14:	22000117 	ldw	r8,4(r4)
8112dd18:	21c06326 	beq	r4,r7,8112dea8 <_realloc_r+0x220>
8112dd1c:	017fff84 	movi	r5,-2
8112dd20:	414a703a 	and	r5,r8,r5
8112dd24:	214b883a 	add	r5,r4,r5
8112dd28:	29800117 	ldw	r6,4(r5)
8112dd2c:	3180004c 	andi	r6,r6,1
8112dd30:	30003f26 	beq	r6,zero,8112de30 <_realloc_r+0x1a8>
8112dd34:	1080004c 	andi	r2,r2,1
8112dd38:	10008326 	beq	r2,zero,8112df48 <_realloc_r+0x2c0>
8112dd3c:	900b883a 	mov	r5,r18
8112dd40:	a009883a 	mov	r4,r20
8112dd44:	1121e7c0 	call	81121e7c <_malloc_r>
8112dd48:	1025883a 	mov	r18,r2
8112dd4c:	10011e26 	beq	r2,zero,8112e1c8 <_realloc_r+0x540>
8112dd50:	a93fff17 	ldw	r4,-4(r21)
8112dd54:	10fffe04 	addi	r3,r2,-8
8112dd58:	00bfff84 	movi	r2,-2
8112dd5c:	2084703a 	and	r2,r4,r2
8112dd60:	9885883a 	add	r2,r19,r2
8112dd64:	1880ee26 	beq	r3,r2,8112e120 <_realloc_r+0x498>
8112dd68:	81bfff04 	addi	r6,r16,-4
8112dd6c:	00800904 	movi	r2,36
8112dd70:	1180b836 	bltu	r2,r6,8112e054 <_realloc_r+0x3cc>
8112dd74:	00c004c4 	movi	r3,19
8112dd78:	19809636 	bltu	r3,r6,8112dfd4 <_realloc_r+0x34c>
8112dd7c:	9005883a 	mov	r2,r18
8112dd80:	a807883a 	mov	r3,r21
8112dd84:	19000017 	ldw	r4,0(r3)
8112dd88:	11000015 	stw	r4,0(r2)
8112dd8c:	19000117 	ldw	r4,4(r3)
8112dd90:	11000115 	stw	r4,4(r2)
8112dd94:	18c00217 	ldw	r3,8(r3)
8112dd98:	10c00215 	stw	r3,8(r2)
8112dd9c:	a80b883a 	mov	r5,r21
8112dda0:	a009883a 	mov	r4,r20
8112dda4:	112bbf40 	call	8112bbf4 <_free_r>
8112dda8:	a009883a 	mov	r4,r20
8112ddac:	11381fc0 	call	811381fc <__malloc_unlock>
8112ddb0:	9005883a 	mov	r2,r18
8112ddb4:	00001206 	br	8112de00 <_realloc_r+0x178>
8112ddb8:	00c00404 	movi	r3,16
8112ddbc:	1823883a 	mov	r17,r3
8112ddc0:	003fce06 	br	8112dcfc <__reset+0xfb10dcfc>
8112ddc4:	a825883a 	mov	r18,r21
8112ddc8:	8445c83a 	sub	r2,r16,r17
8112ddcc:	00c003c4 	movi	r3,15
8112ddd0:	18802636 	bltu	r3,r2,8112de6c <_realloc_r+0x1e4>
8112ddd4:	99800117 	ldw	r6,4(r19)
8112ddd8:	9c07883a 	add	r3,r19,r16
8112dddc:	3180004c 	andi	r6,r6,1
8112dde0:	3420b03a 	or	r16,r6,r16
8112dde4:	9c000115 	stw	r16,4(r19)
8112dde8:	18800117 	ldw	r2,4(r3)
8112ddec:	10800054 	ori	r2,r2,1
8112ddf0:	18800115 	stw	r2,4(r3)
8112ddf4:	a009883a 	mov	r4,r20
8112ddf8:	11381fc0 	call	811381fc <__malloc_unlock>
8112ddfc:	9005883a 	mov	r2,r18
8112de00:	dfc00917 	ldw	ra,36(sp)
8112de04:	df000817 	ldw	fp,32(sp)
8112de08:	ddc00717 	ldw	r23,28(sp)
8112de0c:	dd800617 	ldw	r22,24(sp)
8112de10:	dd400517 	ldw	r21,20(sp)
8112de14:	dd000417 	ldw	r20,16(sp)
8112de18:	dcc00317 	ldw	r19,12(sp)
8112de1c:	dc800217 	ldw	r18,8(sp)
8112de20:	dc400117 	ldw	r17,4(sp)
8112de24:	dc000017 	ldw	r16,0(sp)
8112de28:	dec00a04 	addi	sp,sp,40
8112de2c:	f800283a 	ret
8112de30:	017fff04 	movi	r5,-4
8112de34:	414a703a 	and	r5,r8,r5
8112de38:	814d883a 	add	r6,r16,r5
8112de3c:	30c01f16 	blt	r6,r3,8112debc <_realloc_r+0x234>
8112de40:	20800317 	ldw	r2,12(r4)
8112de44:	20c00217 	ldw	r3,8(r4)
8112de48:	a825883a 	mov	r18,r21
8112de4c:	3021883a 	mov	r16,r6
8112de50:	18800315 	stw	r2,12(r3)
8112de54:	10c00215 	stw	r3,8(r2)
8112de58:	003fdb06 	br	8112ddc8 <__reset+0xfb10ddc8>
8112de5c:	00800304 	movi	r2,12
8112de60:	a0800015 	stw	r2,0(r20)
8112de64:	0005883a 	mov	r2,zero
8112de68:	003fe506 	br	8112de00 <__reset+0xfb10de00>
8112de6c:	98c00117 	ldw	r3,4(r19)
8112de70:	9c4b883a 	add	r5,r19,r17
8112de74:	11000054 	ori	r4,r2,1
8112de78:	18c0004c 	andi	r3,r3,1
8112de7c:	1c62b03a 	or	r17,r3,r17
8112de80:	9c400115 	stw	r17,4(r19)
8112de84:	29000115 	stw	r4,4(r5)
8112de88:	2885883a 	add	r2,r5,r2
8112de8c:	10c00117 	ldw	r3,4(r2)
8112de90:	29400204 	addi	r5,r5,8
8112de94:	a009883a 	mov	r4,r20
8112de98:	18c00054 	ori	r3,r3,1
8112de9c:	10c00115 	stw	r3,4(r2)
8112dea0:	112bbf40 	call	8112bbf4 <_free_r>
8112dea4:	003fd306 	br	8112ddf4 <__reset+0xfb10ddf4>
8112dea8:	017fff04 	movi	r5,-4
8112deac:	414a703a 	and	r5,r8,r5
8112deb0:	89800404 	addi	r6,r17,16
8112deb4:	8151883a 	add	r8,r16,r5
8112deb8:	4180590e 	bge	r8,r6,8112e020 <_realloc_r+0x398>
8112debc:	1080004c 	andi	r2,r2,1
8112dec0:	103f9e1e 	bne	r2,zero,8112dd3c <__reset+0xfb10dd3c>
8112dec4:	adbffe17 	ldw	r22,-8(r21)
8112dec8:	00bfff04 	movi	r2,-4
8112decc:	9dadc83a 	sub	r22,r19,r22
8112ded0:	b1800117 	ldw	r6,4(r22)
8112ded4:	3084703a 	and	r2,r6,r2
8112ded8:	20002026 	beq	r4,zero,8112df5c <_realloc_r+0x2d4>
8112dedc:	80af883a 	add	r23,r16,r2
8112dee0:	b96f883a 	add	r23,r23,r5
8112dee4:	21c05f26 	beq	r4,r7,8112e064 <_realloc_r+0x3dc>
8112dee8:	b8c01c16 	blt	r23,r3,8112df5c <_realloc_r+0x2d4>
8112deec:	20800317 	ldw	r2,12(r4)
8112def0:	20c00217 	ldw	r3,8(r4)
8112def4:	81bfff04 	addi	r6,r16,-4
8112def8:	01000904 	movi	r4,36
8112defc:	18800315 	stw	r2,12(r3)
8112df00:	10c00215 	stw	r3,8(r2)
8112df04:	b0c00217 	ldw	r3,8(r22)
8112df08:	b0800317 	ldw	r2,12(r22)
8112df0c:	b4800204 	addi	r18,r22,8
8112df10:	18800315 	stw	r2,12(r3)
8112df14:	10c00215 	stw	r3,8(r2)
8112df18:	21801b36 	bltu	r4,r6,8112df88 <_realloc_r+0x300>
8112df1c:	008004c4 	movi	r2,19
8112df20:	1180352e 	bgeu	r2,r6,8112dff8 <_realloc_r+0x370>
8112df24:	a8800017 	ldw	r2,0(r21)
8112df28:	b0800215 	stw	r2,8(r22)
8112df2c:	a8800117 	ldw	r2,4(r21)
8112df30:	b0800315 	stw	r2,12(r22)
8112df34:	008006c4 	movi	r2,27
8112df38:	11807f36 	bltu	r2,r6,8112e138 <_realloc_r+0x4b0>
8112df3c:	b0800404 	addi	r2,r22,16
8112df40:	ad400204 	addi	r21,r21,8
8112df44:	00002d06 	br	8112dffc <_realloc_r+0x374>
8112df48:	adbffe17 	ldw	r22,-8(r21)
8112df4c:	00bfff04 	movi	r2,-4
8112df50:	9dadc83a 	sub	r22,r19,r22
8112df54:	b1000117 	ldw	r4,4(r22)
8112df58:	2084703a 	and	r2,r4,r2
8112df5c:	b03f7726 	beq	r22,zero,8112dd3c <__reset+0xfb10dd3c>
8112df60:	80af883a 	add	r23,r16,r2
8112df64:	b8ff7516 	blt	r23,r3,8112dd3c <__reset+0xfb10dd3c>
8112df68:	b0800317 	ldw	r2,12(r22)
8112df6c:	b0c00217 	ldw	r3,8(r22)
8112df70:	81bfff04 	addi	r6,r16,-4
8112df74:	01000904 	movi	r4,36
8112df78:	18800315 	stw	r2,12(r3)
8112df7c:	10c00215 	stw	r3,8(r2)
8112df80:	b4800204 	addi	r18,r22,8
8112df84:	21bfe52e 	bgeu	r4,r6,8112df1c <__reset+0xfb10df1c>
8112df88:	a80b883a 	mov	r5,r21
8112df8c:	9009883a 	mov	r4,r18
8112df90:	112ca680 	call	8112ca68 <memmove>
8112df94:	b821883a 	mov	r16,r23
8112df98:	b027883a 	mov	r19,r22
8112df9c:	003f8a06 	br	8112ddc8 <__reset+0xfb10ddc8>
8112dfa0:	300b883a 	mov	r5,r6
8112dfa4:	dfc00917 	ldw	ra,36(sp)
8112dfa8:	df000817 	ldw	fp,32(sp)
8112dfac:	ddc00717 	ldw	r23,28(sp)
8112dfb0:	dd800617 	ldw	r22,24(sp)
8112dfb4:	dd400517 	ldw	r21,20(sp)
8112dfb8:	dd000417 	ldw	r20,16(sp)
8112dfbc:	dcc00317 	ldw	r19,12(sp)
8112dfc0:	dc800217 	ldw	r18,8(sp)
8112dfc4:	dc400117 	ldw	r17,4(sp)
8112dfc8:	dc000017 	ldw	r16,0(sp)
8112dfcc:	dec00a04 	addi	sp,sp,40
8112dfd0:	1121e7c1 	jmpi	81121e7c <_malloc_r>
8112dfd4:	a8c00017 	ldw	r3,0(r21)
8112dfd8:	90c00015 	stw	r3,0(r18)
8112dfdc:	a8c00117 	ldw	r3,4(r21)
8112dfe0:	90c00115 	stw	r3,4(r18)
8112dfe4:	00c006c4 	movi	r3,27
8112dfe8:	19804536 	bltu	r3,r6,8112e100 <_realloc_r+0x478>
8112dfec:	90800204 	addi	r2,r18,8
8112dff0:	a8c00204 	addi	r3,r21,8
8112dff4:	003f6306 	br	8112dd84 <__reset+0xfb10dd84>
8112dff8:	9005883a 	mov	r2,r18
8112dffc:	a8c00017 	ldw	r3,0(r21)
8112e000:	b821883a 	mov	r16,r23
8112e004:	b027883a 	mov	r19,r22
8112e008:	10c00015 	stw	r3,0(r2)
8112e00c:	a8c00117 	ldw	r3,4(r21)
8112e010:	10c00115 	stw	r3,4(r2)
8112e014:	a8c00217 	ldw	r3,8(r21)
8112e018:	10c00215 	stw	r3,8(r2)
8112e01c:	003f6a06 	br	8112ddc8 <__reset+0xfb10ddc8>
8112e020:	9c67883a 	add	r19,r19,r17
8112e024:	4445c83a 	sub	r2,r8,r17
8112e028:	e4c00215 	stw	r19,8(fp)
8112e02c:	10800054 	ori	r2,r2,1
8112e030:	98800115 	stw	r2,4(r19)
8112e034:	a8bfff17 	ldw	r2,-4(r21)
8112e038:	a009883a 	mov	r4,r20
8112e03c:	1080004c 	andi	r2,r2,1
8112e040:	1462b03a 	or	r17,r2,r17
8112e044:	ac7fff15 	stw	r17,-4(r21)
8112e048:	11381fc0 	call	811381fc <__malloc_unlock>
8112e04c:	a805883a 	mov	r2,r21
8112e050:	003f6b06 	br	8112de00 <__reset+0xfb10de00>
8112e054:	a80b883a 	mov	r5,r21
8112e058:	9009883a 	mov	r4,r18
8112e05c:	112ca680 	call	8112ca68 <memmove>
8112e060:	003f4e06 	br	8112dd9c <__reset+0xfb10dd9c>
8112e064:	89000404 	addi	r4,r17,16
8112e068:	b93fbc16 	blt	r23,r4,8112df5c <__reset+0xfb10df5c>
8112e06c:	b0800317 	ldw	r2,12(r22)
8112e070:	b0c00217 	ldw	r3,8(r22)
8112e074:	81bfff04 	addi	r6,r16,-4
8112e078:	01000904 	movi	r4,36
8112e07c:	18800315 	stw	r2,12(r3)
8112e080:	10c00215 	stw	r3,8(r2)
8112e084:	b4800204 	addi	r18,r22,8
8112e088:	21804336 	bltu	r4,r6,8112e198 <_realloc_r+0x510>
8112e08c:	008004c4 	movi	r2,19
8112e090:	11803f2e 	bgeu	r2,r6,8112e190 <_realloc_r+0x508>
8112e094:	a8800017 	ldw	r2,0(r21)
8112e098:	b0800215 	stw	r2,8(r22)
8112e09c:	a8800117 	ldw	r2,4(r21)
8112e0a0:	b0800315 	stw	r2,12(r22)
8112e0a4:	008006c4 	movi	r2,27
8112e0a8:	11803f36 	bltu	r2,r6,8112e1a8 <_realloc_r+0x520>
8112e0ac:	b0800404 	addi	r2,r22,16
8112e0b0:	ad400204 	addi	r21,r21,8
8112e0b4:	a8c00017 	ldw	r3,0(r21)
8112e0b8:	10c00015 	stw	r3,0(r2)
8112e0bc:	a8c00117 	ldw	r3,4(r21)
8112e0c0:	10c00115 	stw	r3,4(r2)
8112e0c4:	a8c00217 	ldw	r3,8(r21)
8112e0c8:	10c00215 	stw	r3,8(r2)
8112e0cc:	b447883a 	add	r3,r22,r17
8112e0d0:	bc45c83a 	sub	r2,r23,r17
8112e0d4:	e0c00215 	stw	r3,8(fp)
8112e0d8:	10800054 	ori	r2,r2,1
8112e0dc:	18800115 	stw	r2,4(r3)
8112e0e0:	b0800117 	ldw	r2,4(r22)
8112e0e4:	a009883a 	mov	r4,r20
8112e0e8:	1080004c 	andi	r2,r2,1
8112e0ec:	1462b03a 	or	r17,r2,r17
8112e0f0:	b4400115 	stw	r17,4(r22)
8112e0f4:	11381fc0 	call	811381fc <__malloc_unlock>
8112e0f8:	9005883a 	mov	r2,r18
8112e0fc:	003f4006 	br	8112de00 <__reset+0xfb10de00>
8112e100:	a8c00217 	ldw	r3,8(r21)
8112e104:	90c00215 	stw	r3,8(r18)
8112e108:	a8c00317 	ldw	r3,12(r21)
8112e10c:	90c00315 	stw	r3,12(r18)
8112e110:	30801126 	beq	r6,r2,8112e158 <_realloc_r+0x4d0>
8112e114:	90800404 	addi	r2,r18,16
8112e118:	a8c00404 	addi	r3,r21,16
8112e11c:	003f1906 	br	8112dd84 <__reset+0xfb10dd84>
8112e120:	90ffff17 	ldw	r3,-4(r18)
8112e124:	00bfff04 	movi	r2,-4
8112e128:	a825883a 	mov	r18,r21
8112e12c:	1884703a 	and	r2,r3,r2
8112e130:	80a1883a 	add	r16,r16,r2
8112e134:	003f2406 	br	8112ddc8 <__reset+0xfb10ddc8>
8112e138:	a8800217 	ldw	r2,8(r21)
8112e13c:	b0800415 	stw	r2,16(r22)
8112e140:	a8800317 	ldw	r2,12(r21)
8112e144:	b0800515 	stw	r2,20(r22)
8112e148:	31000a26 	beq	r6,r4,8112e174 <_realloc_r+0x4ec>
8112e14c:	b0800604 	addi	r2,r22,24
8112e150:	ad400404 	addi	r21,r21,16
8112e154:	003fa906 	br	8112dffc <__reset+0xfb10dffc>
8112e158:	a9000417 	ldw	r4,16(r21)
8112e15c:	90800604 	addi	r2,r18,24
8112e160:	a8c00604 	addi	r3,r21,24
8112e164:	91000415 	stw	r4,16(r18)
8112e168:	a9000517 	ldw	r4,20(r21)
8112e16c:	91000515 	stw	r4,20(r18)
8112e170:	003f0406 	br	8112dd84 <__reset+0xfb10dd84>
8112e174:	a8c00417 	ldw	r3,16(r21)
8112e178:	ad400604 	addi	r21,r21,24
8112e17c:	b0800804 	addi	r2,r22,32
8112e180:	b0c00615 	stw	r3,24(r22)
8112e184:	a8ffff17 	ldw	r3,-4(r21)
8112e188:	b0c00715 	stw	r3,28(r22)
8112e18c:	003f9b06 	br	8112dffc <__reset+0xfb10dffc>
8112e190:	9005883a 	mov	r2,r18
8112e194:	003fc706 	br	8112e0b4 <__reset+0xfb10e0b4>
8112e198:	a80b883a 	mov	r5,r21
8112e19c:	9009883a 	mov	r4,r18
8112e1a0:	112ca680 	call	8112ca68 <memmove>
8112e1a4:	003fc906 	br	8112e0cc <__reset+0xfb10e0cc>
8112e1a8:	a8800217 	ldw	r2,8(r21)
8112e1ac:	b0800415 	stw	r2,16(r22)
8112e1b0:	a8800317 	ldw	r2,12(r21)
8112e1b4:	b0800515 	stw	r2,20(r22)
8112e1b8:	31000726 	beq	r6,r4,8112e1d8 <_realloc_r+0x550>
8112e1bc:	b0800604 	addi	r2,r22,24
8112e1c0:	ad400404 	addi	r21,r21,16
8112e1c4:	003fbb06 	br	8112e0b4 <__reset+0xfb10e0b4>
8112e1c8:	a009883a 	mov	r4,r20
8112e1cc:	11381fc0 	call	811381fc <__malloc_unlock>
8112e1d0:	0005883a 	mov	r2,zero
8112e1d4:	003f0a06 	br	8112de00 <__reset+0xfb10de00>
8112e1d8:	a8c00417 	ldw	r3,16(r21)
8112e1dc:	ad400604 	addi	r21,r21,24
8112e1e0:	b0800804 	addi	r2,r22,32
8112e1e4:	b0c00615 	stw	r3,24(r22)
8112e1e8:	a8ffff17 	ldw	r3,-4(r21)
8112e1ec:	b0c00715 	stw	r3,28(r22)
8112e1f0:	003fb006 	br	8112e0b4 <__reset+0xfb10e0b4>

8112e1f4 <__fpclassifyd>:
8112e1f4:	00a00034 	movhi	r2,32768
8112e1f8:	10bfffc4 	addi	r2,r2,-1
8112e1fc:	2884703a 	and	r2,r5,r2
8112e200:	10000726 	beq	r2,zero,8112e220 <__fpclassifyd+0x2c>
8112e204:	00fffc34 	movhi	r3,65520
8112e208:	019ff834 	movhi	r6,32736
8112e20c:	28c7883a 	add	r3,r5,r3
8112e210:	31bfffc4 	addi	r6,r6,-1
8112e214:	30c00536 	bltu	r6,r3,8112e22c <__fpclassifyd+0x38>
8112e218:	00800104 	movi	r2,4
8112e21c:	f800283a 	ret
8112e220:	2000021e 	bne	r4,zero,8112e22c <__fpclassifyd+0x38>
8112e224:	00800084 	movi	r2,2
8112e228:	f800283a 	ret
8112e22c:	00dffc34 	movhi	r3,32752
8112e230:	019ff834 	movhi	r6,32736
8112e234:	28cb883a 	add	r5,r5,r3
8112e238:	31bfffc4 	addi	r6,r6,-1
8112e23c:	317ff62e 	bgeu	r6,r5,8112e218 <__reset+0xfb10e218>
8112e240:	01400434 	movhi	r5,16
8112e244:	297fffc4 	addi	r5,r5,-1
8112e248:	28800236 	bltu	r5,r2,8112e254 <__fpclassifyd+0x60>
8112e24c:	008000c4 	movi	r2,3
8112e250:	f800283a 	ret
8112e254:	10c00226 	beq	r2,r3,8112e260 <__fpclassifyd+0x6c>
8112e258:	0005883a 	mov	r2,zero
8112e25c:	f800283a 	ret
8112e260:	2005003a 	cmpeq	r2,r4,zero
8112e264:	f800283a 	ret

8112e268 <__sccl>:
8112e268:	2a000003 	ldbu	r8,0(r5)
8112e26c:	00801784 	movi	r2,94
8112e270:	40802a26 	beq	r8,r2,8112e31c <__sccl+0xb4>
8112e274:	29400044 	addi	r5,r5,1
8112e278:	000f883a 	mov	r7,zero
8112e27c:	0013883a 	mov	r9,zero
8112e280:	2007883a 	mov	r3,r4
8112e284:	21804004 	addi	r6,r4,256
8112e288:	19c00005 	stb	r7,0(r3)
8112e28c:	18c00044 	addi	r3,r3,1
8112e290:	19bffd1e 	bne	r3,r6,8112e288 <__reset+0xfb10e288>
8112e294:	40001126 	beq	r8,zero,8112e2dc <__sccl+0x74>
8112e298:	00800044 	movi	r2,1
8112e29c:	124fc83a 	sub	r7,r2,r9
8112e2a0:	02800b44 	movi	r10,45
8112e2a4:	02c01744 	movi	r11,93
8112e2a8:	2205883a 	add	r2,r4,r8
8112e2ac:	11c00005 	stb	r7,0(r2)
8112e2b0:	28800044 	addi	r2,r5,1
8112e2b4:	28c00003 	ldbu	r3,0(r5)
8112e2b8:	1a800a26 	beq	r3,r10,8112e2e4 <__sccl+0x7c>
8112e2bc:	1ac00426 	beq	r3,r11,8112e2d0 <__sccl+0x68>
8112e2c0:	18000426 	beq	r3,zero,8112e2d4 <__sccl+0x6c>
8112e2c4:	1811883a 	mov	r8,r3
8112e2c8:	100b883a 	mov	r5,r2
8112e2cc:	003ff606 	br	8112e2a8 <__reset+0xfb10e2a8>
8112e2d0:	f800283a 	ret
8112e2d4:	2805883a 	mov	r2,r5
8112e2d8:	f800283a 	ret
8112e2dc:	28bfffc4 	addi	r2,r5,-1
8112e2e0:	f800283a 	ret
8112e2e4:	12400003 	ldbu	r9,0(r2)
8112e2e8:	4ac01126 	beq	r9,r11,8112e330 <__sccl+0xc8>
8112e2ec:	4a001016 	blt	r9,r8,8112e330 <__sccl+0xc8>
8112e2f0:	41800044 	addi	r6,r8,1
8112e2f4:	29400084 	addi	r5,r5,2
8112e2f8:	2187883a 	add	r3,r4,r6
8112e2fc:	00000106 	br	8112e304 <__sccl+0x9c>
8112e300:	31800044 	addi	r6,r6,1
8112e304:	19c00005 	stb	r7,0(r3)
8112e308:	3011883a 	mov	r8,r6
8112e30c:	18c00044 	addi	r3,r3,1
8112e310:	327ffb16 	blt	r6,r9,8112e300 <__reset+0xfb10e300>
8112e314:	10800084 	addi	r2,r2,2
8112e318:	003fe606 	br	8112e2b4 <__reset+0xfb10e2b4>
8112e31c:	2a000043 	ldbu	r8,1(r5)
8112e320:	01c00044 	movi	r7,1
8112e324:	29400084 	addi	r5,r5,2
8112e328:	02400044 	movi	r9,1
8112e32c:	003fd406 	br	8112e280 <__reset+0xfb10e280>
8112e330:	5011883a 	mov	r8,r10
8112e334:	003fe406 	br	8112e2c8 <__reset+0xfb10e2c8>

8112e338 <nanf>:
8112e338:	009ff034 	movhi	r2,32704
8112e33c:	f800283a 	ret

8112e340 <strcmp>:
8112e340:	2144b03a 	or	r2,r4,r5
8112e344:	108000cc 	andi	r2,r2,3
8112e348:	1000171e 	bne	r2,zero,8112e3a8 <strcmp+0x68>
8112e34c:	20800017 	ldw	r2,0(r4)
8112e350:	28c00017 	ldw	r3,0(r5)
8112e354:	10c0141e 	bne	r2,r3,8112e3a8 <strcmp+0x68>
8112e358:	027fbff4 	movhi	r9,65279
8112e35c:	4a7fbfc4 	addi	r9,r9,-257
8112e360:	0086303a 	nor	r3,zero,r2
8112e364:	02202074 	movhi	r8,32897
8112e368:	1245883a 	add	r2,r2,r9
8112e36c:	42202004 	addi	r8,r8,-32640
8112e370:	10c4703a 	and	r2,r2,r3
8112e374:	1204703a 	and	r2,r2,r8
8112e378:	10000226 	beq	r2,zero,8112e384 <strcmp+0x44>
8112e37c:	00002306 	br	8112e40c <strcmp+0xcc>
8112e380:	1000221e 	bne	r2,zero,8112e40c <strcmp+0xcc>
8112e384:	21000104 	addi	r4,r4,4
8112e388:	20c00017 	ldw	r3,0(r4)
8112e38c:	29400104 	addi	r5,r5,4
8112e390:	29800017 	ldw	r6,0(r5)
8112e394:	1a4f883a 	add	r7,r3,r9
8112e398:	00c4303a 	nor	r2,zero,r3
8112e39c:	3884703a 	and	r2,r7,r2
8112e3a0:	1204703a 	and	r2,r2,r8
8112e3a4:	19bff626 	beq	r3,r6,8112e380 <__reset+0xfb10e380>
8112e3a8:	20800003 	ldbu	r2,0(r4)
8112e3ac:	10c03fcc 	andi	r3,r2,255
8112e3b0:	18c0201c 	xori	r3,r3,128
8112e3b4:	18ffe004 	addi	r3,r3,-128
8112e3b8:	18000c26 	beq	r3,zero,8112e3ec <strcmp+0xac>
8112e3bc:	29800007 	ldb	r6,0(r5)
8112e3c0:	19800326 	beq	r3,r6,8112e3d0 <strcmp+0x90>
8112e3c4:	00001306 	br	8112e414 <strcmp+0xd4>
8112e3c8:	29800007 	ldb	r6,0(r5)
8112e3cc:	11800b1e 	bne	r2,r6,8112e3fc <strcmp+0xbc>
8112e3d0:	21000044 	addi	r4,r4,1
8112e3d4:	20c00003 	ldbu	r3,0(r4)
8112e3d8:	29400044 	addi	r5,r5,1
8112e3dc:	18803fcc 	andi	r2,r3,255
8112e3e0:	1080201c 	xori	r2,r2,128
8112e3e4:	10bfe004 	addi	r2,r2,-128
8112e3e8:	103ff71e 	bne	r2,zero,8112e3c8 <__reset+0xfb10e3c8>
8112e3ec:	0007883a 	mov	r3,zero
8112e3f0:	28800003 	ldbu	r2,0(r5)
8112e3f4:	1885c83a 	sub	r2,r3,r2
8112e3f8:	f800283a 	ret
8112e3fc:	28800003 	ldbu	r2,0(r5)
8112e400:	18c03fcc 	andi	r3,r3,255
8112e404:	1885c83a 	sub	r2,r3,r2
8112e408:	f800283a 	ret
8112e40c:	0005883a 	mov	r2,zero
8112e410:	f800283a 	ret
8112e414:	10c03fcc 	andi	r3,r2,255
8112e418:	003ff506 	br	8112e3f0 <__reset+0xfb10e3f0>

8112e41c <sulp>:
8112e41c:	defffd04 	addi	sp,sp,-12
8112e420:	de00012e 	bgeu	sp,et,8112e428 <sulp+0xc>
8112e424:	003b68fa 	trap	3
8112e428:	dc400115 	stw	r17,4(sp)
8112e42c:	3023883a 	mov	r17,r6
8112e430:	dc000015 	stw	r16,0(sp)
8112e434:	dfc00215 	stw	ra,8(sp)
8112e438:	2821883a 	mov	r16,r5
8112e43c:	112d7280 	call	8112d728 <__ulp>
8112e440:	88000c26 	beq	r17,zero,8112e474 <sulp+0x58>
8112e444:	841ffc2c 	andhi	r16,r16,32752
8112e448:	8020d53a 	srli	r16,r16,20
8112e44c:	01c01ac4 	movi	r7,107
8112e450:	3c21c83a 	sub	r16,r7,r16
8112e454:	0400070e 	bge	zero,r16,8112e474 <sulp+0x58>
8112e458:	8020953a 	slli	r16,r16,20
8112e45c:	01cffc34 	movhi	r7,16368
8112e460:	000d883a 	mov	r6,zero
8112e464:	81cf883a 	add	r7,r16,r7
8112e468:	1009883a 	mov	r4,r2
8112e46c:	180b883a 	mov	r5,r3
8112e470:	111ffc00 	call	8111ffc0 <__muldf3>
8112e474:	dfc00217 	ldw	ra,8(sp)
8112e478:	dc400117 	ldw	r17,4(sp)
8112e47c:	dc000017 	ldw	r16,0(sp)
8112e480:	dec00304 	addi	sp,sp,12
8112e484:	f800283a 	ret

8112e488 <_strtod_r>:
8112e488:	deffe204 	addi	sp,sp,-120
8112e48c:	de00012e 	bgeu	sp,et,8112e494 <_strtod_r+0xc>
8112e490:	003b68fa 	trap	3
8112e494:	ddc01b15 	stw	r23,108(sp)
8112e498:	dd001815 	stw	r20,96(sp)
8112e49c:	dc801615 	stw	r18,88(sp)
8112e4a0:	dc401515 	stw	r17,84(sp)
8112e4a4:	dc001415 	stw	r16,80(sp)
8112e4a8:	d9400615 	stw	r5,24(sp)
8112e4ac:	dfc01d15 	stw	ra,116(sp)
8112e4b0:	df001c15 	stw	fp,112(sp)
8112e4b4:	dd801a15 	stw	r22,104(sp)
8112e4b8:	dd401915 	stw	r21,100(sp)
8112e4bc:	dcc01715 	stw	r19,92(sp)
8112e4c0:	2021883a 	mov	r16,r4
8112e4c4:	d8000515 	stw	zero,20(sp)
8112e4c8:	2809883a 	mov	r4,r5
8112e4cc:	20800003 	ldbu	r2,0(r4)
8112e4d0:	01e044f4 	movhi	r7,33043
8112e4d4:	282f883a 	mov	r23,r5
8112e4d8:	10c03fcc 	andi	r3,r2,255
8112e4dc:	01400b44 	movi	r5,45
8112e4e0:	39f94104 	addi	r7,r7,-6908
8112e4e4:	3029883a 	mov	r20,r6
8112e4e8:	0025883a 	mov	r18,zero
8112e4ec:	0023883a 	mov	r17,zero
8112e4f0:	28c0ba36 	bltu	r5,r3,8112e7dc <_strtod_r+0x354>
8112e4f4:	180690ba 	slli	r3,r3,2
8112e4f8:	19c7883a 	add	r3,r3,r7
8112e4fc:	18c00017 	ldw	r3,0(r3)
8112e500:	1800683a 	jmp	r3
8112e504:	8112e5c4 	addi	r4,r16,19351
8112e508:	8112e7dc 	xori	r4,r16,19359
8112e50c:	8112e7dc 	xori	r4,r16,19359
8112e510:	8112e7dc 	xori	r4,r16,19359
8112e514:	8112e7dc 	xori	r4,r16,19359
8112e518:	8112e7dc 	xori	r4,r16,19359
8112e51c:	8112e7dc 	xori	r4,r16,19359
8112e520:	8112e7dc 	xori	r4,r16,19359
8112e524:	8112e7dc 	xori	r4,r16,19359
8112e528:	8112e7c8 	cmpgei	r4,r16,19359
8112e52c:	8112e7c8 	cmpgei	r4,r16,19359
8112e530:	8112e7c8 	cmpgei	r4,r16,19359
8112e534:	8112e7c8 	cmpgei	r4,r16,19359
8112e538:	8112e7c8 	cmpgei	r4,r16,19359
8112e53c:	8112e7dc 	xori	r4,r16,19359
8112e540:	8112e7dc 	xori	r4,r16,19359
8112e544:	8112e7dc 	xori	r4,r16,19359
8112e548:	8112e7dc 	xori	r4,r16,19359
8112e54c:	8112e7dc 	xori	r4,r16,19359
8112e550:	8112e7dc 	xori	r4,r16,19359
8112e554:	8112e7dc 	xori	r4,r16,19359
8112e558:	8112e7dc 	xori	r4,r16,19359
8112e55c:	8112e7dc 	xori	r4,r16,19359
8112e560:	8112e7dc 	xori	r4,r16,19359
8112e564:	8112e7dc 	xori	r4,r16,19359
8112e568:	8112e7dc 	xori	r4,r16,19359
8112e56c:	8112e7dc 	xori	r4,r16,19359
8112e570:	8112e7dc 	xori	r4,r16,19359
8112e574:	8112e7dc 	xori	r4,r16,19359
8112e578:	8112e7dc 	xori	r4,r16,19359
8112e57c:	8112e7dc 	xori	r4,r16,19359
8112e580:	8112e7dc 	xori	r4,r16,19359
8112e584:	8112e7c8 	cmpgei	r4,r16,19359
8112e588:	8112e7dc 	xori	r4,r16,19359
8112e58c:	8112e7dc 	xori	r4,r16,19359
8112e590:	8112e7dc 	xori	r4,r16,19359
8112e594:	8112e7dc 	xori	r4,r16,19359
8112e598:	8112e7dc 	xori	r4,r16,19359
8112e59c:	8112e7dc 	xori	r4,r16,19359
8112e5a0:	8112e7dc 	xori	r4,r16,19359
8112e5a4:	8112e7dc 	xori	r4,r16,19359
8112e5a8:	8112e7dc 	xori	r4,r16,19359
8112e5ac:	8112e7dc 	xori	r4,r16,19359
8112e5b0:	8112e61c 	xori	r4,r16,19352
8112e5b4:	8112e7dc 	xori	r4,r16,19359
8112e5b8:	8112e7bc 	xorhi	r4,r16,19358
8112e5bc:	00801244 	movi	r2,73
8112e5c0:	88843526 	beq	r17,r2,8112f698 <_strtod_r+0x1210>
8112e5c4:	002b883a 	mov	r21,zero
8112e5c8:	002d883a 	mov	r22,zero
8112e5cc:	a0000526 	beq	r20,zero,8112e5e4 <_strtod_r+0x15c>
8112e5d0:	d8000715 	stw	zero,28(sp)
8112e5d4:	a5c00015 	stw	r23,0(r20)
8112e5d8:	d9000717 	ldw	r4,28(sp)
8112e5dc:	20000126 	beq	r4,zero,8112e5e4 <_strtod_r+0x15c>
8112e5e0:	b5a0003c 	xorhi	r22,r22,32768
8112e5e4:	a805883a 	mov	r2,r21
8112e5e8:	b007883a 	mov	r3,r22
8112e5ec:	dfc01d17 	ldw	ra,116(sp)
8112e5f0:	df001c17 	ldw	fp,112(sp)
8112e5f4:	ddc01b17 	ldw	r23,108(sp)
8112e5f8:	dd801a17 	ldw	r22,104(sp)
8112e5fc:	dd401917 	ldw	r21,100(sp)
8112e600:	dd001817 	ldw	r20,96(sp)
8112e604:	dcc01717 	ldw	r19,92(sp)
8112e608:	dc801617 	ldw	r18,88(sp)
8112e60c:	dc401517 	ldw	r17,84(sp)
8112e610:	dc001417 	ldw	r16,80(sp)
8112e614:	dec01e04 	addi	sp,sp,120
8112e618:	f800283a 	ret
8112e61c:	d8000715 	stw	zero,28(sp)
8112e620:	24c00044 	addi	r19,r4,1
8112e624:	dcc00615 	stw	r19,24(sp)
8112e628:	20800043 	ldbu	r2,1(r4)
8112e62c:	10c03fcc 	andi	r3,r2,255
8112e630:	18c0201c 	xori	r3,r3,128
8112e634:	18ffe004 	addi	r3,r3,-128
8112e638:	183fe226 	beq	r3,zero,8112e5c4 <__reset+0xfb10e5c4>
8112e63c:	11403fcc 	andi	r5,r2,255
8112e640:	2940201c 	xori	r5,r5,128
8112e644:	297fe004 	addi	r5,r5,-128
8112e648:	00c00c04 	movi	r3,48
8112e64c:	28c0e526 	beq	r5,r3,8112e9e4 <_strtod_r+0x55c>
8112e650:	dcc00815 	stw	r19,32(sp)
8112e654:	0025883a 	mov	r18,zero
8112e658:	10fff404 	addi	r3,r2,-48
8112e65c:	18c03fcc 	andi	r3,r3,255
8112e660:	01000244 	movi	r4,9
8112e664:	20c37536 	bltu	r4,r3,8112f43c <_strtod_r+0xfb4>
8112e668:	dd400817 	ldw	r21,32(sp)
8112e66c:	0027883a 	mov	r19,zero
8112e670:	0039883a 	mov	fp,zero
8112e674:	002d883a 	mov	r22,zero
8112e678:	01400204 	movi	r5,8
8112e67c:	2d805a16 	blt	r5,r22,8112e7e8 <_strtod_r+0x360>
8112e680:	e70002a4 	muli	fp,fp,10
8112e684:	10c03fcc 	andi	r3,r2,255
8112e688:	18c0201c 	xori	r3,r3,128
8112e68c:	18ffe004 	addi	r3,r3,-128
8112e690:	e0f9883a 	add	fp,fp,r3
8112e694:	e73ff404 	addi	fp,fp,-48
8112e698:	ad400044 	addi	r21,r21,1
8112e69c:	dd400615 	stw	r21,24(sp)
8112e6a0:	a8800003 	ldbu	r2,0(r21)
8112e6a4:	b5800044 	addi	r22,r22,1
8112e6a8:	10fff404 	addi	r3,r2,-48
8112e6ac:	18c03fcc 	andi	r3,r3,255
8112e6b0:	20fff22e 	bgeu	r4,r3,8112e67c <__reset+0xfb10e67c>
8112e6b4:	14403fcc 	andi	r17,r2,255
8112e6b8:	8c40201c 	xori	r17,r17,128
8112e6bc:	8c7fe004 	addi	r17,r17,-128
8112e6c0:	8009883a 	mov	r4,r16
8112e6c4:	112c6a80 	call	8112c6a8 <_localeconv_r>
8112e6c8:	11400017 	ldw	r5,0(r2)
8112e6cc:	8009883a 	mov	r4,r16
8112e6d0:	d9401315 	stw	r5,76(sp)
8112e6d4:	112c6a80 	call	8112c6a8 <_localeconv_r>
8112e6d8:	11000017 	ldw	r4,0(r2)
8112e6dc:	11231840 	call	81123184 <strlen>
8112e6e0:	d9401317 	ldw	r5,76(sp)
8112e6e4:	100d883a 	mov	r6,r2
8112e6e8:	a809883a 	mov	r4,r21
8112e6ec:	1133d900 	call	81133d90 <strncmp>
8112e6f0:	1000ce26 	beq	r2,zero,8112ea2c <_strtod_r+0x5a4>
8112e6f4:	b013883a 	mov	r9,r22
8112e6f8:	000b883a 	mov	r5,zero
8112e6fc:	0015883a 	mov	r10,zero
8112e700:	0017883a 	mov	r11,zero
8112e704:	00801944 	movi	r2,101
8112e708:	88807826 	beq	r17,r2,8112e8ec <_strtod_r+0x464>
8112e70c:	00801144 	movi	r2,69
8112e710:	88807626 	beq	r17,r2,8112e8ec <_strtod_r+0x464>
8112e714:	002b883a 	mov	r21,zero
8112e718:	48003d1e 	bne	r9,zero,8112e810 <_strtod_r+0x388>
8112e71c:	2800391e 	bne	r5,zero,8112e804 <_strtod_r+0x37c>
8112e720:	9000381e 	bne	r18,zero,8112e804 <_strtod_r+0x37c>
8112e724:	583fa71e 	bne	r11,zero,8112e5c4 <__reset+0xfb10e5c4>
8112e728:	00801384 	movi	r2,78
8112e72c:	88800526 	beq	r17,r2,8112e744 <_strtod_r+0x2bc>
8112e730:	147fa20e 	bge	r2,r17,8112e5bc <__reset+0xfb10e5bc>
8112e734:	00801a44 	movi	r2,105
8112e738:	8883d726 	beq	r17,r2,8112f698 <_strtod_r+0x1210>
8112e73c:	00801b84 	movi	r2,110
8112e740:	88bfa01e 	bne	r17,r2,8112e5c4 <__reset+0xfb10e5c4>
8112e744:	01604574 	movhi	r5,33045
8112e748:	d9000617 	ldw	r4,24(sp)
8112e74c:	2943b504 	addi	r5,r5,3796
8112e750:	01c00644 	movi	r7,25
8112e754:	00000b06 	br	8112e784 <_strtod_r+0x2fc>
8112e758:	21000044 	addi	r4,r4,1
8112e75c:	20800003 	ldbu	r2,0(r4)
8112e760:	10ffefc4 	addi	r3,r2,-65
8112e764:	10803fcc 	andi	r2,r2,255
8112e768:	1080201c 	xori	r2,r2,128
8112e76c:	18c03fcc 	andi	r3,r3,255
8112e770:	10bfe004 	addi	r2,r2,-128
8112e774:	38c00136 	bltu	r7,r3,8112e77c <_strtod_r+0x2f4>
8112e778:	10800804 	addi	r2,r2,32
8112e77c:	29400044 	addi	r5,r5,1
8112e780:	11bf901e 	bne	r2,r6,8112e5c4 <__reset+0xfb10e5c4>
8112e784:	29800007 	ldb	r6,0(r5)
8112e788:	303ff31e 	bne	r6,zero,8112e758 <__reset+0xfb10e758>
8112e78c:	20800044 	addi	r2,r4,1
8112e790:	d8800615 	stw	r2,24(sp)
8112e794:	20c00047 	ldb	r3,1(r4)
8112e798:	00800a04 	movi	r2,40
8112e79c:	18849d26 	beq	r3,r2,8112fa14 <_strtod_r+0x158c>
8112e7a0:	047ffe34 	movhi	r17,65528
8112e7a4:	0025883a 	mov	r18,zero
8112e7a8:	902b883a 	mov	r21,r18
8112e7ac:	882d883a 	mov	r22,r17
8112e7b0:	a03f8926 	beq	r20,zero,8112e5d8 <__reset+0xfb10e5d8>
8112e7b4:	ddc00617 	ldw	r23,24(sp)
8112e7b8:	003f8606 	br	8112e5d4 <__reset+0xfb10e5d4>
8112e7bc:	00800044 	movi	r2,1
8112e7c0:	d8800715 	stw	r2,28(sp)
8112e7c4:	003f9606 	br	8112e620 <__reset+0xfb10e620>
8112e7c8:	21000044 	addi	r4,r4,1
8112e7cc:	d9000615 	stw	r4,24(sp)
8112e7d0:	20800003 	ldbu	r2,0(r4)
8112e7d4:	10c03fcc 	andi	r3,r2,255
8112e7d8:	28ff462e 	bgeu	r5,r3,8112e4f4 <__reset+0xfb10e4f4>
8112e7dc:	2027883a 	mov	r19,r4
8112e7e0:	d8000715 	stw	zero,28(sp)
8112e7e4:	003f9506 	br	8112e63c <__reset+0xfb10e63c>
8112e7e8:	9cc002a4 	muli	r19,r19,10
8112e7ec:	10803fcc 	andi	r2,r2,255
8112e7f0:	1080201c 	xori	r2,r2,128
8112e7f4:	10bfe004 	addi	r2,r2,-128
8112e7f8:	9885883a 	add	r2,r19,r2
8112e7fc:	14fff404 	addi	r19,r2,-48
8112e800:	003fa506 	br	8112e698 <__reset+0xfb10e698>
8112e804:	002b883a 	mov	r21,zero
8112e808:	002d883a 	mov	r22,zero
8112e80c:	003fe806 	br	8112e7b0 <__reset+0xfb10e7b0>
8112e810:	aaabc83a 	sub	r21,r21,r10
8112e814:	b000011e 	bne	r22,zero,8112e81c <_strtod_r+0x394>
8112e818:	482d883a 	mov	r22,r9
8112e81c:	00800404 	movi	r2,16
8112e820:	482f883a 	mov	r23,r9
8112e824:	1240010e 	bge	r2,r9,8112e82c <_strtod_r+0x3a4>
8112e828:	102f883a 	mov	r23,r2
8112e82c:	e009883a 	mov	r4,fp
8112e830:	da401315 	stw	r9,76(sp)
8112e834:	11361f00 	call	811361f0 <__floatunsidf>
8112e838:	1025883a 	mov	r18,r2
8112e83c:	00800244 	movi	r2,9
8112e840:	1823883a 	mov	r17,r3
8112e844:	da401317 	ldw	r9,76(sp)
8112e848:	15c0160e 	bge	r2,r23,8112e8a4 <_strtod_r+0x41c>
8112e84c:	b8bffdc4 	addi	r2,r23,-9
8112e850:	100490fa 	slli	r2,r2,3
8112e854:	180b883a 	mov	r5,r3
8112e858:	00e04574 	movhi	r3,33045
8112e85c:	18c38004 	addi	r3,r3,3584
8112e860:	1885883a 	add	r2,r3,r2
8112e864:	11800017 	ldw	r6,0(r2)
8112e868:	11c00117 	ldw	r7,4(r2)
8112e86c:	9009883a 	mov	r4,r18
8112e870:	111ffc00 	call	8111ffc0 <__muldf3>
8112e874:	9809883a 	mov	r4,r19
8112e878:	1025883a 	mov	r18,r2
8112e87c:	1823883a 	mov	r17,r3
8112e880:	11361f00 	call	811361f0 <__floatunsidf>
8112e884:	9009883a 	mov	r4,r18
8112e888:	880b883a 	mov	r5,r17
8112e88c:	100d883a 	mov	r6,r2
8112e890:	180f883a 	mov	r7,r3
8112e894:	1134ed00 	call	81134ed0 <__adddf3>
8112e898:	da401317 	ldw	r9,76(sp)
8112e89c:	1025883a 	mov	r18,r2
8112e8a0:	1823883a 	mov	r17,r3
8112e8a4:	008003c4 	movi	r2,15
8112e8a8:	12407b16 	blt	r2,r9,8112ea98 <_strtod_r+0x610>
8112e8ac:	a83fbe26 	beq	r21,zero,8112e7a8 <__reset+0xfb10e7a8>
8112e8b0:	0543670e 	bge	zero,r21,8112f650 <_strtod_r+0x11c8>
8112e8b4:	00c00584 	movi	r3,22
8112e8b8:	1d42e816 	blt	r3,r21,8112f45c <_strtod_r+0xfd4>
8112e8bc:	a82a90fa 	slli	r21,r21,3
8112e8c0:	00a04574 	movhi	r2,33045
8112e8c4:	10838004 	addi	r2,r2,3584
8112e8c8:	1545883a 	add	r2,r2,r21
8112e8cc:	11000017 	ldw	r4,0(r2)
8112e8d0:	11400117 	ldw	r5,4(r2)
8112e8d4:	900d883a 	mov	r6,r18
8112e8d8:	880f883a 	mov	r7,r17
8112e8dc:	111ffc00 	call	8111ffc0 <__muldf3>
8112e8e0:	102b883a 	mov	r21,r2
8112e8e4:	182d883a 	mov	r22,r3
8112e8e8:	003fb106 	br	8112e7b0 <__reset+0xfb10e7b0>
8112e8ec:	4801b526 	beq	r9,zero,8112efc4 <_strtod_r+0xb3c>
8112e8f0:	ddc00617 	ldw	r23,24(sp)
8112e8f4:	00c00ac4 	movi	r3,43
8112e8f8:	b8800044 	addi	r2,r23,1
8112e8fc:	d8800615 	stw	r2,24(sp)
8112e900:	b8800047 	ldb	r2,1(r23)
8112e904:	10c1e926 	beq	r2,r3,8112f0ac <_strtod_r+0xc24>
8112e908:	00c00b44 	movi	r3,45
8112e90c:	10c1ec26 	beq	r2,r3,8112f0c0 <_strtod_r+0xc38>
8112e910:	1023883a 	mov	r17,r2
8112e914:	0019883a 	mov	r12,zero
8112e918:	88bff404 	addi	r2,r17,-48
8112e91c:	00c00244 	movi	r3,9
8112e920:	1881b736 	bltu	r3,r2,8112f000 <_strtod_r+0xb78>
8112e924:	00800c04 	movi	r2,48
8112e928:	8880071e 	bne	r17,r2,8112e948 <_strtod_r+0x4c0>
8112e92c:	d8800617 	ldw	r2,24(sp)
8112e930:	8807883a 	mov	r3,r17
8112e934:	10800044 	addi	r2,r2,1
8112e938:	d8800615 	stw	r2,24(sp)
8112e93c:	14400007 	ldb	r17,0(r2)
8112e940:	10800044 	addi	r2,r2,1
8112e944:	88fffc26 	beq	r17,r3,8112e938 <__reset+0xfb10e938>
8112e948:	88bff3c4 	addi	r2,r17,-49
8112e94c:	00c00204 	movi	r3,8
8112e950:	18bf7036 	bltu	r3,r2,8112e714 <__reset+0xfb10e714>
8112e954:	db800617 	ldw	r14,24(sp)
8112e958:	88bff404 	addi	r2,r17,-48
8112e95c:	03400244 	movi	r13,9
8112e960:	71c00044 	addi	r7,r14,1
8112e964:	d9c00615 	stw	r7,24(sp)
8112e968:	74400043 	ldbu	r17,1(r14)
8112e96c:	88fff404 	addi	r3,r17,-48
8112e970:	8c403fcc 	andi	r17,r17,255
8112e974:	8c40201c 	xori	r17,r17,128
8112e978:	18c03fcc 	andi	r3,r3,255
8112e97c:	8c7fe004 	addi	r17,r17,-128
8112e980:	68c00e36 	bltu	r13,r3,8112e9bc <_strtod_r+0x534>
8112e984:	71000084 	addi	r4,r14,2
8112e988:	d9000615 	stw	r4,24(sp)
8112e98c:	108002a4 	muli	r2,r2,10
8112e990:	21800003 	ldbu	r6,0(r4)
8112e994:	200f883a 	mov	r7,r4
8112e998:	1463883a 	add	r17,r2,r17
8112e99c:	30fff404 	addi	r3,r6,-48
8112e9a0:	88bff404 	addi	r2,r17,-48
8112e9a4:	34403fcc 	andi	r17,r6,255
8112e9a8:	8c40201c 	xori	r17,r17,128
8112e9ac:	18c03fcc 	andi	r3,r3,255
8112e9b0:	8c7fe004 	addi	r17,r17,-128
8112e9b4:	21000044 	addi	r4,r4,1
8112e9b8:	68fff32e 	bgeu	r13,r3,8112e988 <__reset+0xfb10e988>
8112e9bc:	3b8fc83a 	sub	r7,r7,r14
8112e9c0:	00c00204 	movi	r3,8
8112e9c4:	19c29716 	blt	r3,r7,8112f424 <_strtod_r+0xf9c>
8112e9c8:	102b883a 	mov	r21,r2
8112e9cc:	009387c4 	movi	r2,19999
8112e9d0:	1540010e 	bge	r2,r21,8112e9d8 <_strtod_r+0x550>
8112e9d4:	102b883a 	mov	r21,r2
8112e9d8:	603f4f26 	beq	r12,zero,8112e718 <__reset+0xfb10e718>
8112e9dc:	056bc83a 	sub	r21,zero,r21
8112e9e0:	003f4d06 	br	8112e718 <__reset+0xfb10e718>
8112e9e4:	98800047 	ldb	r2,1(r19)
8112e9e8:	00c01604 	movi	r3,88
8112e9ec:	10c1de26 	beq	r2,r3,8112f168 <_strtod_r+0xce0>
8112e9f0:	00c01e04 	movi	r3,120
8112e9f4:	10c1dc26 	beq	r2,r3,8112f168 <_strtod_r+0xce0>
8112e9f8:	98c00044 	addi	r3,r19,1
8112e9fc:	1827883a 	mov	r19,r3
8112ea00:	d8c00615 	stw	r3,24(sp)
8112ea04:	18c00044 	addi	r3,r3,1
8112ea08:	18bfffc3 	ldbu	r2,-1(r3)
8112ea0c:	11003fcc 	andi	r4,r2,255
8112ea10:	2100201c 	xori	r4,r4,128
8112ea14:	213fe004 	addi	r4,r4,-128
8112ea18:	217ff826 	beq	r4,r5,8112e9fc <__reset+0xfb10e9fc>
8112ea1c:	203f7926 	beq	r4,zero,8112e804 <__reset+0xfb10e804>
8112ea20:	dcc00815 	stw	r19,32(sp)
8112ea24:	04800044 	movi	r18,1
8112ea28:	003f0b06 	br	8112e658 <__reset+0xfb10e658>
8112ea2c:	8009883a 	mov	r4,r16
8112ea30:	112c6a80 	call	8112c6a8 <_localeconv_r>
8112ea34:	11000017 	ldw	r4,0(r2)
8112ea38:	11231840 	call	81123184 <strlen>
8112ea3c:	d8c00617 	ldw	r3,24(sp)
8112ea40:	1885883a 	add	r2,r3,r2
8112ea44:	d8800615 	stw	r2,24(sp)
8112ea48:	14400007 	ldb	r17,0(r2)
8112ea4c:	b001881e 	bne	r22,zero,8112f070 <_strtod_r+0xbe8>
8112ea50:	00c00c04 	movi	r3,48
8112ea54:	88c3391e 	bne	r17,r3,8112f73c <_strtod_r+0x12b4>
8112ea58:	10c00044 	addi	r3,r2,1
8112ea5c:	8809883a 	mov	r4,r17
8112ea60:	d8c00615 	stw	r3,24(sp)
8112ea64:	1c400007 	ldb	r17,0(r3)
8112ea68:	188bc83a 	sub	r5,r3,r2
8112ea6c:	18c00044 	addi	r3,r3,1
8112ea70:	893ffb26 	beq	r17,r4,8112ea60 <__reset+0xfb10ea60>
8112ea74:	88bff3c4 	addi	r2,r17,-49
8112ea78:	00c00204 	movi	r3,8
8112ea7c:	1882e72e 	bgeu	r3,r2,8112f61c <_strtod_r+0x1194>
8112ea80:	00801944 	movi	r2,101
8112ea84:	88814d26 	beq	r17,r2,8112efbc <_strtod_r+0xb34>
8112ea88:	0013883a 	mov	r9,zero
8112ea8c:	0015883a 	mov	r10,zero
8112ea90:	02c00044 	movi	r11,1
8112ea94:	003f1d06 	br	8112e70c <__reset+0xfb10e70c>
8112ea98:	4defc83a 	sub	r23,r9,r23
8112ea9c:	bd6f883a 	add	r23,r23,r21
8112eaa0:	05c21e0e 	bge	zero,r23,8112f31c <_strtod_r+0xe94>
8112eaa4:	b88003cc 	andi	r2,r23,15
8112eaa8:	10000d26 	beq	r2,zero,8112eae0 <_strtod_r+0x658>
8112eaac:	100490fa 	slli	r2,r2,3
8112eab0:	00e04574 	movhi	r3,33045
8112eab4:	18c38004 	addi	r3,r3,3584
8112eab8:	1885883a 	add	r2,r3,r2
8112eabc:	11000017 	ldw	r4,0(r2)
8112eac0:	11400117 	ldw	r5,4(r2)
8112eac4:	900d883a 	mov	r6,r18
8112eac8:	880f883a 	mov	r7,r17
8112eacc:	da401315 	stw	r9,76(sp)
8112ead0:	111ffc00 	call	8111ffc0 <__muldf3>
8112ead4:	da401317 	ldw	r9,76(sp)
8112ead8:	1025883a 	mov	r18,r2
8112eadc:	1823883a 	mov	r17,r3
8112eae0:	023ffc04 	movi	r8,-16
8112eae4:	ba10703a 	and	r8,r23,r8
8112eae8:	40003c26 	beq	r8,zero,8112ebdc <_strtod_r+0x754>
8112eaec:	00804d04 	movi	r2,308
8112eaf0:	1201cd16 	blt	r2,r8,8112f228 <_strtod_r+0xda0>
8112eaf4:	4011d13a 	srai	r8,r8,4
8112eaf8:	03000044 	movi	r12,1
8112eafc:	62037c0e 	bge	r12,r8,8112f8f0 <_strtod_r+0x1468>
8112eb00:	01204574 	movhi	r4,33045
8112eb04:	21037604 	addi	r4,r4,3544
8112eb08:	2015883a 	mov	r10,r4
8112eb0c:	0027883a 	mov	r19,zero
8112eb10:	d9000915 	stw	r4,36(sp)
8112eb14:	9005883a 	mov	r2,r18
8112eb18:	8807883a 	mov	r3,r17
8112eb1c:	dc000c15 	stw	r16,48(sp)
8112eb20:	dc800e15 	stw	r18,56(sp)
8112eb24:	9821883a 	mov	r16,r19
8112eb28:	0009883a 	mov	r4,zero
8112eb2c:	8827883a 	mov	r19,r17
8112eb30:	602f883a 	mov	r23,r12
8112eb34:	da400a15 	stw	r9,40(sp)
8112eb38:	5025883a 	mov	r18,r10
8112eb3c:	4023883a 	mov	r17,r8
8112eb40:	8980004c 	andi	r6,r17,1
8112eb44:	30000626 	beq	r6,zero,8112eb60 <_strtod_r+0x6d8>
8112eb48:	91800017 	ldw	r6,0(r18)
8112eb4c:	91c00117 	ldw	r7,4(r18)
8112eb50:	1009883a 	mov	r4,r2
8112eb54:	180b883a 	mov	r5,r3
8112eb58:	111ffc00 	call	8111ffc0 <__muldf3>
8112eb5c:	01000044 	movi	r4,1
8112eb60:	8823d07a 	srai	r17,r17,1
8112eb64:	84000044 	addi	r16,r16,1
8112eb68:	94800204 	addi	r18,r18,8
8112eb6c:	8dfff41e 	bne	r17,r23,8112eb40 <__reset+0xfb10eb40>
8112eb70:	21003fcc 	andi	r4,r4,255
8112eb74:	9823883a 	mov	r17,r19
8112eb78:	da400a17 	ldw	r9,40(sp)
8112eb7c:	8027883a 	mov	r19,r16
8112eb80:	dc800e17 	ldw	r18,56(sp)
8112eb84:	dc000c17 	ldw	r16,48(sp)
8112eb88:	2003b11e 	bne	r4,zero,8112fa50 <_strtod_r+0x15c8>
8112eb8c:	981690fa 	slli	r11,r19,3
8112eb90:	d8800917 	ldw	r2,36(sp)
8112eb94:	01ff2c34 	movhi	r7,64688
8112eb98:	900d883a 	mov	r6,r18
8112eb9c:	12ef883a 	add	r23,r2,r11
8112eba0:	b9000017 	ldw	r4,0(r23)
8112eba4:	b9400117 	ldw	r5,4(r23)
8112eba8:	89cf883a 	add	r7,r17,r7
8112ebac:	da401315 	stw	r9,76(sp)
8112ebb0:	111ffc00 	call	8111ffc0 <__muldf3>
8112ebb4:	1025883a 	mov	r18,r2
8112ebb8:	011f2834 	movhi	r4,31904
8112ebbc:	189ffc2c 	andhi	r2,r3,32752
8112ebc0:	da401317 	ldw	r9,76(sp)
8112ebc4:	20819836 	bltu	r4,r2,8112f228 <_strtod_r+0xda0>
8112ebc8:	011f2434 	movhi	r4,31888
8112ebcc:	2083382e 	bgeu	r4,r2,8112f8b0 <_strtod_r+0x1428>
8112ebd0:	045ffc34 	movhi	r17,32752
8112ebd4:	8c7fffc4 	addi	r17,r17,-1
8112ebd8:	04bfffc4 	movi	r18,-1
8112ebdc:	d8000915 	stw	zero,36(sp)
8112ebe0:	d9400817 	ldw	r5,32(sp)
8112ebe4:	df000015 	stw	fp,0(sp)
8112ebe8:	480f883a 	mov	r7,r9
8112ebec:	b00d883a 	mov	r6,r22
8112ebf0:	8009883a 	mov	r4,r16
8112ebf4:	112cdc40 	call	8112cdc4 <__s2b>
8112ebf8:	d8800815 	stw	r2,32(sp)
8112ebfc:	10018a26 	beq	r2,zero,8112f228 <_strtod_r+0xda0>
8112ec00:	a807d7fa 	srai	r3,r21,31
8112ec04:	0545c83a 	sub	r2,zero,r21
8112ec08:	dd400a15 	stw	r21,40(sp)
8112ec0c:	1886703a 	and	r3,r3,r2
8112ec10:	d8c00c15 	stw	r3,48(sp)
8112ec14:	a8013516 	blt	r21,zero,8112f0ec <_strtod_r+0xc64>
8112ec18:	d9400817 	ldw	r5,32(sp)
8112ec1c:	0011883a 	mov	r8,zero
8112ec20:	0027883a 	mov	r19,zero
8112ec24:	29400304 	addi	r5,r5,12
8112ec28:	d9400f15 	stw	r5,60(sp)
8112ec2c:	402b883a 	mov	r21,r8
8112ec30:	dd001215 	stw	r20,72(sp)
8112ec34:	d8800817 	ldw	r2,32(sp)
8112ec38:	8009883a 	mov	r4,r16
8112ec3c:	11400117 	ldw	r5,4(r2)
8112ec40:	112cbc40 	call	8112cbc4 <_Balloc>
8112ec44:	1029883a 	mov	r20,r2
8112ec48:	10012d26 	beq	r2,zero,8112f100 <_strtod_r+0xc78>
8112ec4c:	d8c00817 	ldw	r3,32(sp)
8112ec50:	d9400f17 	ldw	r5,60(sp)
8112ec54:	11000304 	addi	r4,r2,12
8112ec58:	19800417 	ldw	r6,16(r3)
8112ec5c:	31800084 	addi	r6,r6,2
8112ec60:	318d883a 	add	r6,r6,r6
8112ec64:	318d883a 	add	r6,r6,r6
8112ec68:	11226900 	call	81122690 <memcpy>
8112ec6c:	d9000204 	addi	r4,sp,8
8112ec70:	d9000015 	stw	r4,0(sp)
8112ec74:	d9c00404 	addi	r7,sp,16
8112ec78:	900b883a 	mov	r5,r18
8112ec7c:	880d883a 	mov	r6,r17
8112ec80:	8009883a 	mov	r4,r16
8112ec84:	112d8a00 	call	8112d8a0 <__d2b>
8112ec88:	d8800515 	stw	r2,20(sp)
8112ec8c:	dc801115 	stw	r18,68(sp)
8112ec90:	dc401015 	stw	r17,64(sp)
8112ec94:	10027c26 	beq	r2,zero,8112f688 <_strtod_r+0x1200>
8112ec98:	01400044 	movi	r5,1
8112ec9c:	8009883a 	mov	r4,r16
8112eca0:	112cfe80 	call	8112cfe8 <__i2b>
8112eca4:	1027883a 	mov	r19,r2
8112eca8:	10011526 	beq	r2,zero,8112f100 <_strtod_r+0xc78>
8112ecac:	d8800417 	ldw	r2,16(sp)
8112ecb0:	1000c816 	blt	r2,zero,8112efd4 <_strtod_r+0xb4c>
8112ecb4:	d9400c17 	ldw	r5,48(sp)
8112ecb8:	d9000a17 	ldw	r4,40(sp)
8112ecbc:	28ad883a 	add	r22,r5,r2
8112ecc0:	d9400917 	ldw	r5,36(sp)
8112ecc4:	df000217 	ldw	fp,8(sp)
8112ecc8:	05ff0084 	movi	r23,-1022
8112eccc:	1147c83a 	sub	r3,r2,r5
8112ecd0:	1f07883a 	add	r3,r3,fp
8112ecd4:	00800d84 	movi	r2,54
8112ecd8:	18ffffc4 	addi	r3,r3,-1
8112ecdc:	1739c83a 	sub	fp,r2,fp
8112ece0:	1dc0a50e 	bge	r3,r23,8112ef78 <_strtod_r+0xaf0>
8112ece4:	b8efc83a 	sub	r23,r23,r3
8112ece8:	008007c4 	movi	r2,31
8112ecec:	e5f9c83a 	sub	fp,fp,r23
8112ecf0:	15c0bc16 	blt	r2,r23,8112efe4 <_strtod_r+0xb5c>
8112ecf4:	00800044 	movi	r2,1
8112ecf8:	15c4983a 	sll	r2,r2,r23
8112ecfc:	d8000b15 	stw	zero,44(sp)
8112ed00:	d8800d15 	stw	r2,52(sp)
8112ed04:	2707883a 	add	r3,r4,fp
8112ed08:	d9000917 	ldw	r4,36(sp)
8112ed0c:	b739883a 	add	fp,r22,fp
8112ed10:	20ef883a 	add	r23,r4,r3
8112ed14:	b009883a 	mov	r4,r22
8112ed18:	e580010e 	bge	fp,r22,8112ed20 <_strtod_r+0x898>
8112ed1c:	e009883a 	mov	r4,fp
8112ed20:	b805883a 	mov	r2,r23
8112ed24:	25c0010e 	bge	r4,r23,8112ed2c <_strtod_r+0x8a4>
8112ed28:	2005883a 	mov	r2,r4
8112ed2c:	0080030e 	bge	zero,r2,8112ed3c <_strtod_r+0x8b4>
8112ed30:	e0b9c83a 	sub	fp,fp,r2
8112ed34:	b8afc83a 	sub	r23,r23,r2
8112ed38:	b0adc83a 	sub	r22,r22,r2
8112ed3c:	d9400c17 	ldw	r5,48(sp)
8112ed40:	28001126 	beq	r5,zero,8112ed88 <_strtod_r+0x900>
8112ed44:	280d883a 	mov	r6,r5
8112ed48:	8009883a 	mov	r4,r16
8112ed4c:	980b883a 	mov	r5,r19
8112ed50:	112d22c0 	call	8112d22c <__pow5mult>
8112ed54:	1027883a 	mov	r19,r2
8112ed58:	1000e926 	beq	r2,zero,8112f100 <_strtod_r+0xc78>
8112ed5c:	d9800517 	ldw	r6,20(sp)
8112ed60:	100b883a 	mov	r5,r2
8112ed64:	8009883a 	mov	r4,r16
8112ed68:	112d02c0 	call	8112d02c <__multiply>
8112ed6c:	1000e426 	beq	r2,zero,8112f100 <_strtod_r+0xc78>
8112ed70:	d9400517 	ldw	r5,20(sp)
8112ed74:	8009883a 	mov	r4,r16
8112ed78:	d8801315 	stw	r2,76(sp)
8112ed7c:	112cc740 	call	8112cc74 <_Bfree>
8112ed80:	d8801317 	ldw	r2,76(sp)
8112ed84:	d8800515 	stw	r2,20(sp)
8112ed88:	0700060e 	bge	zero,fp,8112eda4 <_strtod_r+0x91c>
8112ed8c:	d9400517 	ldw	r5,20(sp)
8112ed90:	e00d883a 	mov	r6,fp
8112ed94:	8009883a 	mov	r4,r16
8112ed98:	112d3740 	call	8112d374 <__lshift>
8112ed9c:	d8800515 	stw	r2,20(sp)
8112eda0:	10023926 	beq	r2,zero,8112f688 <_strtod_r+0x1200>
8112eda4:	d8800a17 	ldw	r2,40(sp)
8112eda8:	10000626 	beq	r2,zero,8112edc4 <_strtod_r+0x93c>
8112edac:	d9800a17 	ldw	r6,40(sp)
8112edb0:	a00b883a 	mov	r5,r20
8112edb4:	8009883a 	mov	r4,r16
8112edb8:	112d22c0 	call	8112d22c <__pow5mult>
8112edbc:	1029883a 	mov	r20,r2
8112edc0:	1000cf26 	beq	r2,zero,8112f100 <_strtod_r+0xc78>
8112edc4:	05c0060e 	bge	zero,r23,8112ede0 <_strtod_r+0x958>
8112edc8:	a00b883a 	mov	r5,r20
8112edcc:	b80d883a 	mov	r6,r23
8112edd0:	8009883a 	mov	r4,r16
8112edd4:	112d3740 	call	8112d374 <__lshift>
8112edd8:	1029883a 	mov	r20,r2
8112eddc:	1000c826 	beq	r2,zero,8112f100 <_strtod_r+0xc78>
8112ede0:	0580060e 	bge	zero,r22,8112edfc <_strtod_r+0x974>
8112ede4:	980b883a 	mov	r5,r19
8112ede8:	b00d883a 	mov	r6,r22
8112edec:	8009883a 	mov	r4,r16
8112edf0:	112d3740 	call	8112d374 <__lshift>
8112edf4:	1027883a 	mov	r19,r2
8112edf8:	1000c126 	beq	r2,zero,8112f100 <_strtod_r+0xc78>
8112edfc:	d9400517 	ldw	r5,20(sp)
8112ee00:	a00d883a 	mov	r6,r20
8112ee04:	8009883a 	mov	r4,r16
8112ee08:	112d5240 	call	8112d524 <__mdiff>
8112ee0c:	102b883a 	mov	r21,r2
8112ee10:	1000bb26 	beq	r2,zero,8112f100 <_strtod_r+0xc78>
8112ee14:	10c00317 	ldw	r3,12(r2)
8112ee18:	980b883a 	mov	r5,r19
8112ee1c:	10000315 	stw	zero,12(r2)
8112ee20:	1009883a 	mov	r4,r2
8112ee24:	d8c00e15 	stw	r3,56(sp)
8112ee28:	112d4c40 	call	8112d4c4 <__mcmp>
8112ee2c:	10027616 	blt	r2,zero,8112f808 <_strtod_r+0x1380>
8112ee30:	10024426 	beq	r2,zero,8112f744 <_strtod_r+0x12bc>
8112ee34:	980b883a 	mov	r5,r19
8112ee38:	a809883a 	mov	r4,r21
8112ee3c:	112d9f40 	call	8112d9f4 <__ratio>
8112ee40:	000d883a 	mov	r6,zero
8112ee44:	01d00034 	movhi	r7,16384
8112ee48:	1009883a 	mov	r4,r2
8112ee4c:	180b883a 	mov	r5,r3
8112ee50:	102f883a 	mov	r23,r2
8112ee54:	182d883a 	mov	r22,r3
8112ee58:	11360fc0 	call	811360fc <__ledf2>
8112ee5c:	00804a16 	blt	zero,r2,8112ef88 <_strtod_r+0xb00>
8112ee60:	d9400e17 	ldw	r5,56(sp)
8112ee64:	28006b26 	beq	r5,zero,8112f014 <_strtod_r+0xb8c>
8112ee68:	058ffc34 	movhi	r22,16368
8112ee6c:	d8000b15 	stw	zero,44(sp)
8112ee70:	d8000d15 	stw	zero,52(sp)
8112ee74:	b02f883a 	mov	r23,r22
8112ee78:	8f1ffc2c 	andhi	fp,r17,32752
8112ee7c:	009ff834 	movhi	r2,32736
8112ee80:	e080cd26 	beq	fp,r2,8112f1b8 <_strtod_r+0xd30>
8112ee84:	d9400917 	ldw	r5,36(sp)
8112ee88:	28001a26 	beq	r5,zero,8112eef4 <_strtod_r+0xa6c>
8112ee8c:	0081a834 	movhi	r2,1696
8112ee90:	17001836 	bltu	r2,fp,8112eef4 <_strtod_r+0xa6c>
8112ee94:	d9000d17 	ldw	r4,52(sp)
8112ee98:	01d07834 	movhi	r7,16864
8112ee9c:	39ffffc4 	addi	r7,r7,-1
8112eea0:	01bff034 	movhi	r6,65472
8112eea4:	b80b883a 	mov	r5,r23
8112eea8:	11360fc0 	call	811360fc <__ledf2>
8112eeac:	00800e16 	blt	zero,r2,8112eee8 <_strtod_r+0xa60>
8112eeb0:	d9000d17 	ldw	r4,52(sp)
8112eeb4:	b80b883a 	mov	r5,r23
8112eeb8:	111f3f80 	call	8111f3f8 <__fixunsdfsi>
8112eebc:	10018126 	beq	r2,zero,8112f4c4 <_strtod_r+0x103c>
8112eec0:	1009883a 	mov	r4,r2
8112eec4:	11361f00 	call	811361f0 <__floatunsidf>
8112eec8:	d8800d15 	stw	r2,52(sp)
8112eecc:	182f883a 	mov	r23,r3
8112eed0:	d8800e17 	ldw	r2,56(sp)
8112eed4:	1001791e 	bne	r2,zero,8112f4bc <_strtod_r+0x1034>
8112eed8:	ba20003c 	xorhi	r8,r23,32768
8112eedc:	d8c00d17 	ldw	r3,52(sp)
8112eee0:	402d883a 	mov	r22,r8
8112eee4:	d8c00b15 	stw	r3,44(sp)
8112eee8:	0081ac34 	movhi	r2,1712
8112eeec:	b091883a 	add	r8,r22,r2
8112eef0:	472dc83a 	sub	r22,r8,fp
8112eef4:	9009883a 	mov	r4,r18
8112eef8:	880b883a 	mov	r5,r17
8112eefc:	112d7280 	call	8112d728 <__ulp>
8112ef00:	d9000b17 	ldw	r4,44(sp)
8112ef04:	b00b883a 	mov	r5,r22
8112ef08:	100d883a 	mov	r6,r2
8112ef0c:	180f883a 	mov	r7,r3
8112ef10:	111ffc00 	call	8111ffc0 <__muldf3>
8112ef14:	900d883a 	mov	r6,r18
8112ef18:	880f883a 	mov	r7,r17
8112ef1c:	1009883a 	mov	r4,r2
8112ef20:	180b883a 	mov	r5,r3
8112ef24:	1134ed00 	call	81134ed0 <__adddf3>
8112ef28:	1025883a 	mov	r18,r2
8112ef2c:	1823883a 	mov	r17,r3
8112ef30:	182d883a 	mov	r22,r3
8112ef34:	d9000917 	ldw	r4,36(sp)
8112ef38:	2000021e 	bne	r4,zero,8112ef44 <_strtod_r+0xabc>
8112ef3c:	b09ffc2c 	andhi	r2,r22,32752
8112ef40:	e080be26 	beq	fp,r2,8112f23c <_strtod_r+0xdb4>
8112ef44:	d9400517 	ldw	r5,20(sp)
8112ef48:	8009883a 	mov	r4,r16
8112ef4c:	112cc740 	call	8112cc74 <_Bfree>
8112ef50:	a00b883a 	mov	r5,r20
8112ef54:	8009883a 	mov	r4,r16
8112ef58:	112cc740 	call	8112cc74 <_Bfree>
8112ef5c:	980b883a 	mov	r5,r19
8112ef60:	8009883a 	mov	r4,r16
8112ef64:	112cc740 	call	8112cc74 <_Bfree>
8112ef68:	a80b883a 	mov	r5,r21
8112ef6c:	8009883a 	mov	r4,r16
8112ef70:	112cc740 	call	8112cc74 <_Bfree>
8112ef74:	003f2f06 	br	8112ec34 <__reset+0xfb10ec34>
8112ef78:	00c00044 	movi	r3,1
8112ef7c:	d8000b15 	stw	zero,44(sp)
8112ef80:	d8c00d15 	stw	r3,52(sp)
8112ef84:	003f5f06 	br	8112ed04 <__reset+0xfb10ed04>
8112ef88:	b809883a 	mov	r4,r23
8112ef8c:	000d883a 	mov	r6,zero
8112ef90:	01cff834 	movhi	r7,16352
8112ef94:	b00b883a 	mov	r5,r22
8112ef98:	111ffc00 	call	8111ffc0 <__muldf3>
8112ef9c:	d9000e17 	ldw	r4,56(sp)
8112efa0:	d8800d15 	stw	r2,52(sp)
8112efa4:	182f883a 	mov	r23,r3
8112efa8:	2000181e 	bne	r4,zero,8112f00c <_strtod_r+0xb84>
8112efac:	1a20003c 	xorhi	r8,r3,32768
8112efb0:	d8800b15 	stw	r2,44(sp)
8112efb4:	402d883a 	mov	r22,r8
8112efb8:	003faf06 	br	8112ee78 <__reset+0xfb10ee78>
8112efbc:	0015883a 	mov	r10,zero
8112efc0:	02c00044 	movi	r11,1
8112efc4:	2800011e 	bne	r5,zero,8112efcc <_strtod_r+0xb44>
8112efc8:	903d7e26 	beq	r18,zero,8112e5c4 <__reset+0xfb10e5c4>
8112efcc:	0013883a 	mov	r9,zero
8112efd0:	003e4706 	br	8112e8f0 <__reset+0xfb10e8f0>
8112efd4:	d8c00a17 	ldw	r3,40(sp)
8112efd8:	dd800c17 	ldw	r22,48(sp)
8112efdc:	1889c83a 	sub	r4,r3,r2
8112efe0:	003f3706 	br	8112ecc0 <__reset+0xfb10ecc0>
8112efe4:	00bef884 	movi	r2,-1054
8112efe8:	05c00044 	movi	r23,1
8112efec:	10c5c83a 	sub	r2,r2,r3
8112eff0:	b884983a 	sll	r2,r23,r2
8112eff4:	ddc00d15 	stw	r23,52(sp)
8112eff8:	d8800b15 	stw	r2,44(sp)
8112effc:	003f4106 	br	8112ed04 <__reset+0xfb10ed04>
8112f000:	ddc00615 	stw	r23,24(sp)
8112f004:	002b883a 	mov	r21,zero
8112f008:	003dc306 	br	8112e718 <__reset+0xfb10e718>
8112f00c:	1811883a 	mov	r8,r3
8112f010:	003fe706 	br	8112efb0 <__reset+0xfb10efb0>
8112f014:	90002e1e 	bne	r18,zero,8112f0d0 <_strtod_r+0xc48>
8112f018:	00c00434 	movhi	r3,16
8112f01c:	18ffffc4 	addi	r3,r3,-1
8112f020:	88c4703a 	and	r2,r17,r3
8112f024:	10002c1e 	bne	r2,zero,8112f0d8 <_strtod_r+0xc50>
8112f028:	000d883a 	mov	r6,zero
8112f02c:	01cffc34 	movhi	r7,16368
8112f030:	b809883a 	mov	r4,r23
8112f034:	b00b883a 	mov	r5,r22
8112f038:	11360fc0 	call	811360fc <__ledf2>
8112f03c:	10021716 	blt	r2,zero,8112f89c <_strtod_r+0x1414>
8112f040:	b809883a 	mov	r4,r23
8112f044:	b00b883a 	mov	r5,r22
8112f048:	000d883a 	mov	r6,zero
8112f04c:	01cff834 	movhi	r7,16352
8112f050:	111ffc00 	call	8111ffc0 <__muldf3>
8112f054:	d8800d15 	stw	r2,52(sp)
8112f058:	182f883a 	mov	r23,r3
8112f05c:	102d883a 	mov	r22,r2
8112f060:	1a20003c 	xorhi	r8,r3,32768
8112f064:	dd800b15 	stw	r22,44(sp)
8112f068:	402d883a 	mov	r22,r8
8112f06c:	003f8206 	br	8112ee78 <__reset+0xfb10ee78>
8112f070:	b013883a 	mov	r9,r22
8112f074:	000b883a 	mov	r5,zero
8112f078:	0015883a 	mov	r10,zero
8112f07c:	893ff404 	addi	r4,r17,-48
8112f080:	00800244 	movi	r2,9
8112f084:	11001036 	bltu	r2,r4,8112f0c8 <_strtod_r+0xc40>
8112f088:	28c00044 	addi	r3,r5,1
8112f08c:	2023883a 	mov	r17,r4
8112f090:	20014d1e 	bne	r4,zero,8112f5c8 <_strtod_r+0x1140>
8112f094:	d9800617 	ldw	r6,24(sp)
8112f098:	180b883a 	mov	r5,r3
8112f09c:	30800044 	addi	r2,r6,1
8112f0a0:	d8800615 	stw	r2,24(sp)
8112f0a4:	34400047 	ldb	r17,1(r6)
8112f0a8:	003ff406 	br	8112f07c <__reset+0xfb10f07c>
8112f0ac:	0019883a 	mov	r12,zero
8112f0b0:	b8800084 	addi	r2,r23,2
8112f0b4:	d8800615 	stw	r2,24(sp)
8112f0b8:	bc400087 	ldb	r17,2(r23)
8112f0bc:	003e1606 	br	8112e918 <__reset+0xfb10e918>
8112f0c0:	03000044 	movi	r12,1
8112f0c4:	003ffa06 	br	8112f0b0 <__reset+0xfb10f0b0>
8112f0c8:	02c00044 	movi	r11,1
8112f0cc:	003d8d06 	br	8112e704 <__reset+0xfb10e704>
8112f0d0:	00800044 	movi	r2,1
8112f0d4:	9080fe26 	beq	r18,r2,8112f4d0 <_strtod_r+0x1048>
8112f0d8:	d8000b15 	stw	zero,44(sp)
8112f0dc:	05affc34 	movhi	r22,49136
8112f0e0:	d8000d15 	stw	zero,52(sp)
8112f0e4:	05cffc34 	movhi	r23,16368
8112f0e8:	003f6306 	br	8112ee78 <__reset+0xfb10ee78>
8112f0ec:	d8000a15 	stw	zero,40(sp)
8112f0f0:	003ec906 	br	8112ec18 <__reset+0xfb10ec18>
8112f0f4:	d9001117 	ldw	r4,68(sp)
8112f0f8:	00bfffc4 	movi	r2,-1
8112f0fc:	2080461e 	bne	r4,r2,8112f218 <_strtod_r+0xd90>
8112f100:	dd000a15 	stw	r20,40(sp)
8112f104:	dd001217 	ldw	r20,72(sp)
8112f108:	a811883a 	mov	r8,r21
8112f10c:	d8800517 	ldw	r2,20(sp)
8112f110:	00c00884 	movi	r3,34
8112f114:	80c00015 	stw	r3,0(r16)
8112f118:	002b883a 	mov	r21,zero
8112f11c:	059ffc34 	movhi	r22,32752
8112f120:	100b883a 	mov	r5,r2
8112f124:	8009883a 	mov	r4,r16
8112f128:	da001315 	stw	r8,76(sp)
8112f12c:	112cc740 	call	8112cc74 <_Bfree>
8112f130:	d9400a17 	ldw	r5,40(sp)
8112f134:	8009883a 	mov	r4,r16
8112f138:	112cc740 	call	8112cc74 <_Bfree>
8112f13c:	980b883a 	mov	r5,r19
8112f140:	8009883a 	mov	r4,r16
8112f144:	112cc740 	call	8112cc74 <_Bfree>
8112f148:	d9400817 	ldw	r5,32(sp)
8112f14c:	8009883a 	mov	r4,r16
8112f150:	112cc740 	call	8112cc74 <_Bfree>
8112f154:	da001317 	ldw	r8,76(sp)
8112f158:	8009883a 	mov	r4,r16
8112f15c:	400b883a 	mov	r5,r8
8112f160:	112cc740 	call	8112cc74 <_Bfree>
8112f164:	003d9206 	br	8112e7b0 <__reset+0xfb10e7b0>
8112f168:	d8c00717 	ldw	r3,28(sp)
8112f16c:	d8800504 	addi	r2,sp,20
8112f170:	01a04574 	movhi	r6,33045
8112f174:	3183bb04 	addi	r6,r6,3820
8112f178:	d8c00115 	stw	r3,4(sp)
8112f17c:	d8800015 	stw	r2,0(sp)
8112f180:	d9c00404 	addi	r7,sp,16
8112f184:	d9400604 	addi	r5,sp,24
8112f188:	8009883a 	mov	r4,r16
8112f18c:	11332f40 	call	811332f4 <__gethex>
8112f190:	154001cc 	andi	r21,r2,7
8112f194:	a83d9b26 	beq	r21,zero,8112e804 <__reset+0xfb10e804>
8112f198:	00c00184 	movi	r3,6
8112f19c:	a8c0d61e 	bne	r21,r3,8112f4f8 <_strtod_r+0x1070>
8112f1a0:	9cc00044 	addi	r19,r19,1
8112f1a4:	dcc00615 	stw	r19,24(sp)
8112f1a8:	002b883a 	mov	r21,zero
8112f1ac:	002d883a 	mov	r22,zero
8112f1b0:	d8000715 	stw	zero,28(sp)
8112f1b4:	003d7e06 	br	8112e7b0 <__reset+0xfb10e7b0>
8112f1b8:	00bf2c34 	movhi	r2,64688
8112f1bc:	88a3883a 	add	r17,r17,r2
8112f1c0:	9009883a 	mov	r4,r18
8112f1c4:	880b883a 	mov	r5,r17
8112f1c8:	112d7280 	call	8112d728 <__ulp>
8112f1cc:	d9000b17 	ldw	r4,44(sp)
8112f1d0:	100d883a 	mov	r6,r2
8112f1d4:	180f883a 	mov	r7,r3
8112f1d8:	b00b883a 	mov	r5,r22
8112f1dc:	111ffc00 	call	8111ffc0 <__muldf3>
8112f1e0:	900d883a 	mov	r6,r18
8112f1e4:	180b883a 	mov	r5,r3
8112f1e8:	880f883a 	mov	r7,r17
8112f1ec:	1009883a 	mov	r4,r2
8112f1f0:	1134ed00 	call	81134ed0 <__adddf3>
8112f1f4:	015f2834 	movhi	r5,31904
8112f1f8:	1025883a 	mov	r18,r2
8112f1fc:	297fffc4 	addi	r5,r5,-1
8112f200:	189ffc2c 	andhi	r2,r3,32752
8112f204:	2880892e 	bgeu	r5,r2,8112f42c <_strtod_r+0xfa4>
8112f208:	d8801017 	ldw	r2,64(sp)
8112f20c:	00dffc34 	movhi	r3,32752
8112f210:	18ffffc4 	addi	r3,r3,-1
8112f214:	10ffb726 	beq	r2,r3,8112f0f4 <__reset+0xfb10f0f4>
8112f218:	045ffc34 	movhi	r17,32752
8112f21c:	8c7fffc4 	addi	r17,r17,-1
8112f220:	04bfffc4 	movi	r18,-1
8112f224:	003f4706 	br	8112ef44 <__reset+0xfb10ef44>
8112f228:	00800884 	movi	r2,34
8112f22c:	80800015 	stw	r2,0(r16)
8112f230:	002b883a 	mov	r21,zero
8112f234:	059ffc34 	movhi	r22,32752
8112f238:	003d5d06 	br	8112e7b0 <__reset+0xfb10e7b0>
8112f23c:	d9000d17 	ldw	r4,52(sp)
8112f240:	b80b883a 	mov	r5,r23
8112f244:	1120fe40 	call	81120fe4 <__fixdfsi>
8112f248:	1009883a 	mov	r4,r2
8112f24c:	11210640 	call	81121064 <__floatsidf>
8112f250:	d9000d17 	ldw	r4,52(sp)
8112f254:	b80b883a 	mov	r5,r23
8112f258:	100d883a 	mov	r6,r2
8112f25c:	180f883a 	mov	r7,r3
8112f260:	11206e00 	call	811206e0 <__subdf3>
8112f264:	d9400e17 	ldw	r5,56(sp)
8112f268:	1039883a 	mov	fp,r2
8112f26c:	182f883a 	mov	r23,r3
8112f270:	2800141e 	bne	r5,zero,8112f2c4 <_strtod_r+0xe3c>
8112f274:	9000131e 	bne	r18,zero,8112f2c4 <_strtod_r+0xe3c>
8112f278:	00800434 	movhi	r2,16
8112f27c:	10bfffc4 	addi	r2,r2,-1
8112f280:	b0ac703a 	and	r22,r22,r2
8112f284:	b0000f1e 	bne	r22,zero,8112f2c4 <_strtod_r+0xe3c>
8112f288:	01a52834 	movhi	r6,38048
8112f28c:	01cff434 	movhi	r7,16336
8112f290:	318d6544 	addi	r6,r6,13717
8112f294:	39ffffc4 	addi	r7,r7,-1
8112f298:	e009883a 	mov	r4,fp
8112f29c:	180b883a 	mov	r5,r3
8112f2a0:	11360fc0 	call	811360fc <__ledf2>
8112f2a4:	103f270e 	bge	r2,zero,8112ef44 <__reset+0xfb10ef44>
8112f2a8:	dd000a15 	stw	r20,40(sp)
8112f2ac:	a811883a 	mov	r8,r21
8112f2b0:	dd001217 	ldw	r20,72(sp)
8112f2b4:	d8800517 	ldw	r2,20(sp)
8112f2b8:	002b883a 	mov	r21,zero
8112f2bc:	882d883a 	mov	r22,r17
8112f2c0:	003f9706 	br	8112f120 <__reset+0xfb10f120>
8112f2c4:	01a52834 	movhi	r6,38048
8112f2c8:	01cff834 	movhi	r7,16352
8112f2cc:	318d6544 	addi	r6,r6,13717
8112f2d0:	39ffffc4 	addi	r7,r7,-1
8112f2d4:	e009883a 	mov	r4,fp
8112f2d8:	b80b883a 	mov	r5,r23
8112f2dc:	11360fc0 	call	811360fc <__ledf2>
8112f2e0:	10000716 	blt	r2,zero,8112f300 <_strtod_r+0xe78>
8112f2e4:	018d6c34 	movhi	r6,13744
8112f2e8:	31b94d44 	addi	r6,r6,-6859
8112f2ec:	01cff834 	movhi	r7,16352
8112f2f0:	e009883a 	mov	r4,fp
8112f2f4:	b80b883a 	mov	r5,r23
8112f2f8:	111fee40 	call	8111fee4 <__gedf2>
8112f2fc:	00bf110e 	bge	zero,r2,8112ef44 <__reset+0xfb10ef44>
8112f300:	dd000a15 	stw	r20,40(sp)
8112f304:	a811883a 	mov	r8,r21
8112f308:	dd001217 	ldw	r20,72(sp)
8112f30c:	d8800517 	ldw	r2,20(sp)
8112f310:	902b883a 	mov	r21,r18
8112f314:	882d883a 	mov	r22,r17
8112f318:	003f8106 	br	8112f120 <__reset+0xfb10f120>
8112f31c:	b83e2f26 	beq	r23,zero,8112ebdc <__reset+0xfb10ebdc>
8112f320:	05efc83a 	sub	r23,zero,r23
8112f324:	b88003cc 	andi	r2,r23,15
8112f328:	10000d26 	beq	r2,zero,8112f360 <_strtod_r+0xed8>
8112f32c:	100490fa 	slli	r2,r2,3
8112f330:	00e04574 	movhi	r3,33045
8112f334:	18c38004 	addi	r3,r3,3584
8112f338:	1885883a 	add	r2,r3,r2
8112f33c:	11800017 	ldw	r6,0(r2)
8112f340:	11c00117 	ldw	r7,4(r2)
8112f344:	9009883a 	mov	r4,r18
8112f348:	880b883a 	mov	r5,r17
8112f34c:	da401315 	stw	r9,76(sp)
8112f350:	11357840 	call	81135784 <__divdf3>
8112f354:	da401317 	ldw	r9,76(sp)
8112f358:	1025883a 	mov	r18,r2
8112f35c:	1823883a 	mov	r17,r3
8112f360:	b82fd13a 	srai	r23,r23,4
8112f364:	b83e1d26 	beq	r23,zero,8112ebdc <__reset+0xfb10ebdc>
8112f368:	008007c4 	movi	r2,31
8112f36c:	15c02816 	blt	r2,r23,8112f410 <_strtod_r+0xf88>
8112f370:	b880040c 	andi	r2,r23,16
8112f374:	10019726 	beq	r2,zero,8112f9d4 <_strtod_r+0x154c>
8112f378:	05c1880e 	bge	zero,r23,8112f99c <_strtod_r+0x1514>
8112f37c:	00c01a84 	movi	r3,106
8112f380:	d8c00915 	stw	r3,36(sp)
8112f384:	04e04574 	movhi	r19,33045
8112f388:	9cc3c004 	addi	r19,r19,3840
8112f38c:	8807883a 	mov	r3,r17
8112f390:	9005883a 	mov	r2,r18
8112f394:	8023883a 	mov	r17,r16
8112f398:	0009883a 	mov	r4,zero
8112f39c:	9821883a 	mov	r16,r19
8112f3a0:	da400a15 	stw	r9,40(sp)
8112f3a4:	1827883a 	mov	r19,r3
8112f3a8:	b980004c 	andi	r6,r23,1
8112f3ac:	30000626 	beq	r6,zero,8112f3c8 <_strtod_r+0xf40>
8112f3b0:	81800017 	ldw	r6,0(r16)
8112f3b4:	81c00117 	ldw	r7,4(r16)
8112f3b8:	1009883a 	mov	r4,r2
8112f3bc:	180b883a 	mov	r5,r3
8112f3c0:	111ffc00 	call	8111ffc0 <__muldf3>
8112f3c4:	01000044 	movi	r4,1
8112f3c8:	b82fd07a 	srai	r23,r23,1
8112f3cc:	84000204 	addi	r16,r16,8
8112f3d0:	b83ff51e 	bne	r23,zero,8112f3a8 <__reset+0xfb10f3a8>
8112f3d4:	21003fcc 	andi	r4,r4,255
8112f3d8:	8821883a 	mov	r16,r17
8112f3dc:	da400a17 	ldw	r9,40(sp)
8112f3e0:	9823883a 	mov	r17,r19
8112f3e4:	2001a51e 	bne	r4,zero,8112fa7c <_strtod_r+0x15f4>
8112f3e8:	d9000917 	ldw	r4,36(sp)
8112f3ec:	20016d1e 	bne	r4,zero,8112f9a4 <_strtod_r+0x151c>
8112f3f0:	000d883a 	mov	r6,zero
8112f3f4:	000f883a 	mov	r7,zero
8112f3f8:	9009883a 	mov	r4,r18
8112f3fc:	880b883a 	mov	r5,r17
8112f400:	da401315 	stw	r9,76(sp)
8112f404:	11360740 	call	81136074 <__eqdf2>
8112f408:	da401317 	ldw	r9,76(sp)
8112f40c:	103df41e 	bne	r2,zero,8112ebe0 <__reset+0xfb10ebe0>
8112f410:	00800884 	movi	r2,34
8112f414:	80800015 	stw	r2,0(r16)
8112f418:	002b883a 	mov	r21,zero
8112f41c:	002d883a 	mov	r22,zero
8112f420:	003ce306 	br	8112e7b0 <__reset+0xfb10e7b0>
8112f424:	055387c4 	movi	r21,19999
8112f428:	003d6b06 	br	8112e9d8 <__reset+0xfb10e9d8>
8112f42c:	0440d434 	movhi	r17,848
8112f430:	1c63883a 	add	r17,r3,r17
8112f434:	882d883a 	mov	r22,r17
8112f438:	003ebe06 	br	8112ef34 <__reset+0xfb10ef34>
8112f43c:	14403fcc 	andi	r17,r2,255
8112f440:	8c40201c 	xori	r17,r17,128
8112f444:	8c7fe004 	addi	r17,r17,-128
8112f448:	dd400817 	ldw	r21,32(sp)
8112f44c:	0027883a 	mov	r19,zero
8112f450:	0039883a 	mov	fp,zero
8112f454:	002d883a 	mov	r22,zero
8112f458:	003c9906 	br	8112e6c0 <__reset+0xfb10e6c0>
8112f45c:	00c00944 	movi	r3,37
8112f460:	1a47c83a 	sub	r3,r3,r9
8112f464:	1d7d8c16 	blt	r3,r21,8112ea98 <__reset+0xfb10ea98>
8112f468:	1261c83a 	sub	r16,r2,r9
8112f46c:	800490fa 	slli	r2,r16,3
8112f470:	04e04574 	movhi	r19,33045
8112f474:	9cc38004 	addi	r19,r19,3584
8112f478:	9885883a 	add	r2,r19,r2
8112f47c:	11000017 	ldw	r4,0(r2)
8112f480:	11400117 	ldw	r5,4(r2)
8112f484:	900d883a 	mov	r6,r18
8112f488:	880f883a 	mov	r7,r17
8112f48c:	111ffc00 	call	8111ffc0 <__muldf3>
8112f490:	ac0dc83a 	sub	r6,r21,r16
8112f494:	300c90fa 	slli	r6,r6,3
8112f498:	1009883a 	mov	r4,r2
8112f49c:	180b883a 	mov	r5,r3
8112f4a0:	9985883a 	add	r2,r19,r6
8112f4a4:	11800017 	ldw	r6,0(r2)
8112f4a8:	11c00117 	ldw	r7,4(r2)
8112f4ac:	111ffc00 	call	8111ffc0 <__muldf3>
8112f4b0:	102b883a 	mov	r21,r2
8112f4b4:	182d883a 	mov	r22,r3
8112f4b8:	003cbd06 	br	8112e7b0 <__reset+0xfb10e7b0>
8112f4bc:	b811883a 	mov	r8,r23
8112f4c0:	003e8606 	br	8112eedc <__reset+0xfb10eedc>
8112f4c4:	d8000d15 	stw	zero,52(sp)
8112f4c8:	05cffc34 	movhi	r23,16368
8112f4cc:	003e8006 	br	8112eed0 <__reset+0xfb10eed0>
8112f4d0:	883f011e 	bne	r17,zero,8112f0d8 <__reset+0xfb10f0d8>
8112f4d4:	dd000a15 	stw	r20,40(sp)
8112f4d8:	dd001217 	ldw	r20,72(sp)
8112f4dc:	a811883a 	mov	r8,r21
8112f4e0:	00800884 	movi	r2,34
8112f4e4:	80800015 	stw	r2,0(r16)
8112f4e8:	002b883a 	mov	r21,zero
8112f4ec:	d8800517 	ldw	r2,20(sp)
8112f4f0:	002d883a 	mov	r22,zero
8112f4f4:	003f0a06 	br	8112f120 <__reset+0xfb10f120>
8112f4f8:	d9800517 	ldw	r6,20(sp)
8112f4fc:	30000826 	beq	r6,zero,8112f520 <_strtod_r+0x1098>
8112f500:	01400d44 	movi	r5,53
8112f504:	d9000204 	addi	r4,sp,8
8112f508:	d8801315 	stw	r2,76(sp)
8112f50c:	112db1c0 	call	8112db1c <__copybits>
8112f510:	d9400517 	ldw	r5,20(sp)
8112f514:	8009883a 	mov	r4,r16
8112f518:	112cc740 	call	8112cc74 <_Bfree>
8112f51c:	d8801317 	ldw	r2,76(sp)
8112f520:	00c00184 	movi	r3,6
8112f524:	1d400f36 	bltu	r3,r21,8112f564 <_strtod_r+0x10dc>
8112f528:	a82a90ba 	slli	r21,r21,2
8112f52c:	00e044f4 	movhi	r3,33043
8112f530:	18fd5004 	addi	r3,r3,-2752
8112f534:	a8eb883a 	add	r21,r21,r3
8112f538:	a8c00017 	ldw	r3,0(r21)
8112f53c:	1800683a 	jmp	r3
8112f540:	8112f5bc 	xorhi	r4,r16,19414
8112f544:	8112f594 	ori	r4,r16,19414
8112f548:	8112f578 	rdprs	r4,r16,19413
8112f54c:	8112f55c 	xori	r4,r16,19413
8112f550:	8112f584 	addi	r4,r16,19414
8112f554:	8112f594 	ori	r4,r16,19414
8112f558:	8112f5bc 	xorhi	r4,r16,19414
8112f55c:	045ffc34 	movhi	r17,32752
8112f560:	0025883a 	mov	r18,zero
8112f564:	1080020c 	andi	r2,r2,8
8112f568:	902b883a 	mov	r21,r18
8112f56c:	103c8f26 	beq	r2,zero,8112e7ac <__reset+0xfb10e7ac>
8112f570:	8da00034 	orhi	r22,r17,32768
8112f574:	003c8e06 	br	8112e7b0 <__reset+0xfb10e7b0>
8112f578:	dc800217 	ldw	r18,8(sp)
8112f57c:	dc400317 	ldw	r17,12(sp)
8112f580:	003ff806 	br	8112f564 <__reset+0xfb10f564>
8112f584:	04600034 	movhi	r17,32768
8112f588:	8c7fffc4 	addi	r17,r17,-1
8112f58c:	04bfffc4 	movi	r18,-1
8112f590:	003ff406 	br	8112f564 <__reset+0xfb10f564>
8112f594:	d8c00417 	ldw	r3,16(sp)
8112f598:	dc400317 	ldw	r17,12(sp)
8112f59c:	013ffc34 	movhi	r4,65520
8112f5a0:	18c10cc4 	addi	r3,r3,1075
8112f5a4:	1806953a 	slli	r3,r3,20
8112f5a8:	213fffc4 	addi	r4,r4,-1
8112f5ac:	8922703a 	and	r17,r17,r4
8112f5b0:	dc800217 	ldw	r18,8(sp)
8112f5b4:	88e2b03a 	or	r17,r17,r3
8112f5b8:	003fea06 	br	8112f564 <__reset+0xfb10f564>
8112f5bc:	0023883a 	mov	r17,zero
8112f5c0:	0025883a 	mov	r18,zero
8112f5c4:	003fe706 	br	8112f564 <__reset+0xfb10f564>
8112f5c8:	01800044 	movi	r6,1
8112f5cc:	50d5883a 	add	r10,r10,r3
8112f5d0:	2a4b883a 	add	r5,r5,r9
8112f5d4:	19811a26 	beq	r3,r6,8112fa40 <_strtod_r+0x15b8>
8112f5d8:	01800204 	movi	r6,8
8112f5dc:	01c00404 	movi	r7,16
8112f5e0:	4a400044 	addi	r9,r9,1
8112f5e4:	48bfffc4 	addi	r2,r9,-1
8112f5e8:	30801616 	blt	r6,r2,8112f644 <_strtod_r+0x11bc>
8112f5ec:	e70002a4 	muli	fp,fp,10
8112f5f0:	497ffb1e 	bne	r9,r5,8112f5e0 <__reset+0xfb10f5e0>
8112f5f4:	d9800617 	ldw	r6,24(sp)
8112f5f8:	4a400044 	addi	r9,r9,1
8112f5fc:	00c00204 	movi	r3,8
8112f600:	19400c0e 	bge	r3,r5,8112f634 <_strtod_r+0x11ac>
8112f604:	00800404 	movi	r2,16
8112f608:	000b883a 	mov	r5,zero
8112f60c:	127ea316 	blt	r2,r9,8112f09c <__reset+0xfb10f09c>
8112f610:	988002a4 	muli	r2,r19,10
8112f614:	20a7883a 	add	r19,r4,r2
8112f618:	003ea006 	br	8112f09c <__reset+0xfb10f09c>
8112f61c:	d8800617 	ldw	r2,24(sp)
8112f620:	8c7ff404 	addi	r17,r17,-48
8112f624:	2a800044 	addi	r10,r5,1
8112f628:	d8800815 	stw	r2,32(sp)
8112f62c:	100d883a 	mov	r6,r2
8112f630:	02400044 	movi	r9,1
8112f634:	e08002a4 	muli	r2,fp,10
8112f638:	000b883a 	mov	r5,zero
8112f63c:	88b9883a 	add	fp,r17,r2
8112f640:	003e9606 	br	8112f09c <__reset+0xfb10f09c>
8112f644:	3a7fea16 	blt	r7,r9,8112f5f0 <__reset+0xfb10f5f0>
8112f648:	9cc002a4 	muli	r19,r19,10
8112f64c:	003fe806 	br	8112f5f0 <__reset+0xfb10f5f0>
8112f650:	00bffa84 	movi	r2,-22
8112f654:	a8bd1016 	blt	r21,r2,8112ea98 <__reset+0xfb10ea98>
8112f658:	a82a90fa 	slli	r21,r21,3
8112f65c:	00a04574 	movhi	r2,33045
8112f660:	10838004 	addi	r2,r2,3584
8112f664:	1545c83a 	sub	r2,r2,r21
8112f668:	11800017 	ldw	r6,0(r2)
8112f66c:	11c00117 	ldw	r7,4(r2)
8112f670:	9009883a 	mov	r4,r18
8112f674:	880b883a 	mov	r5,r17
8112f678:	11357840 	call	81135784 <__divdf3>
8112f67c:	102b883a 	mov	r21,r2
8112f680:	182d883a 	mov	r22,r3
8112f684:	003c4a06 	br	8112e7b0 <__reset+0xfb10e7b0>
8112f688:	dd000a15 	stw	r20,40(sp)
8112f68c:	a811883a 	mov	r8,r21
8112f690:	dd001217 	ldw	r20,72(sp)
8112f694:	003e9e06 	br	8112f110 <__reset+0xfb10f110>
8112f698:	01604574 	movhi	r5,33045
8112f69c:	d9000617 	ldw	r4,24(sp)
8112f6a0:	2943b204 	addi	r5,r5,3784
8112f6a4:	01c00644 	movi	r7,25
8112f6a8:	00000b06 	br	8112f6d8 <_strtod_r+0x1250>
8112f6ac:	21000044 	addi	r4,r4,1
8112f6b0:	20800003 	ldbu	r2,0(r4)
8112f6b4:	10ffefc4 	addi	r3,r2,-65
8112f6b8:	10803fcc 	andi	r2,r2,255
8112f6bc:	1080201c 	xori	r2,r2,128
8112f6c0:	18c03fcc 	andi	r3,r3,255
8112f6c4:	10bfe004 	addi	r2,r2,-128
8112f6c8:	38c00136 	bltu	r7,r3,8112f6d0 <_strtod_r+0x1248>
8112f6cc:	10800804 	addi	r2,r2,32
8112f6d0:	29400044 	addi	r5,r5,1
8112f6d4:	11bbbb1e 	bne	r2,r6,8112e5c4 <__reset+0xfb10e5c4>
8112f6d8:	29800007 	ldb	r6,0(r5)
8112f6dc:	303ff31e 	bne	r6,zero,8112f6ac <__reset+0xfb10f6ac>
8112f6e0:	01a04574 	movhi	r6,33045
8112f6e4:	d9000615 	stw	r4,24(sp)
8112f6e8:	3183b304 	addi	r6,r6,3788
8112f6ec:	200b883a 	mov	r5,r4
8112f6f0:	02000644 	movi	r8,25
8112f6f4:	00000a06 	br	8112f720 <_strtod_r+0x1298>
8112f6f8:	28800003 	ldbu	r2,0(r5)
8112f6fc:	10ffefc4 	addi	r3,r2,-65
8112f700:	10803fcc 	andi	r2,r2,255
8112f704:	1080201c 	xori	r2,r2,128
8112f708:	18c03fcc 	andi	r3,r3,255
8112f70c:	10bfe004 	addi	r2,r2,-128
8112f710:	40c00136 	bltu	r8,r3,8112f718 <_strtod_r+0x1290>
8112f714:	10800804 	addi	r2,r2,32
8112f718:	31800044 	addi	r6,r6,1
8112f71c:	11c0711e 	bne	r2,r7,8112f8e4 <_strtod_r+0x145c>
8112f720:	31c00007 	ldb	r7,0(r6)
8112f724:	29400044 	addi	r5,r5,1
8112f728:	383ff31e 	bne	r7,zero,8112f6f8 <__reset+0xfb10f6f8>
8112f72c:	d9400615 	stw	r5,24(sp)
8112f730:	045ffc34 	movhi	r17,32752
8112f734:	0025883a 	mov	r18,zero
8112f738:	003c1b06 	br	8112e7a8 <__reset+0xfb10e7a8>
8112f73c:	000b883a 	mov	r5,zero
8112f740:	003ccc06 	br	8112ea74 <__reset+0xfb10ea74>
8112f744:	d9400e17 	ldw	r5,56(sp)
8112f748:	dd000a15 	stw	r20,40(sp)
8112f74c:	00800434 	movhi	r2,16
8112f750:	a811883a 	mov	r8,r21
8112f754:	dd001217 	ldw	r20,72(sp)
8112f758:	dd401117 	ldw	r21,68(sp)
8112f75c:	dd801017 	ldw	r22,64(sp)
8112f760:	10bfffc4 	addi	r2,r2,-1
8112f764:	28005626 	beq	r5,zero,8112f8c0 <_strtod_r+0x1438>
8112f768:	8886703a 	and	r3,r17,r2
8112f76c:	18807826 	beq	r3,r2,8112f950 <_strtod_r+0x14c8>
8112f770:	d8c00b17 	ldw	r3,44(sp)
8112f774:	18005726 	beq	r3,zero,8112f8d4 <_strtod_r+0x144c>
8112f778:	1c44703a 	and	r2,r3,r17
8112f77c:	10000f26 	beq	r2,zero,8112f7bc <_strtod_r+0x1334>
8112f780:	d9000e17 	ldw	r4,56(sp)
8112f784:	d9800917 	ldw	r6,36(sp)
8112f788:	20005e26 	beq	r4,zero,8112f904 <_strtod_r+0x147c>
8112f78c:	9009883a 	mov	r4,r18
8112f790:	880b883a 	mov	r5,r17
8112f794:	da001315 	stw	r8,76(sp)
8112f798:	112e41c0 	call	8112e41c <sulp>
8112f79c:	100d883a 	mov	r6,r2
8112f7a0:	180f883a 	mov	r7,r3
8112f7a4:	9009883a 	mov	r4,r18
8112f7a8:	880b883a 	mov	r5,r17
8112f7ac:	1134ed00 	call	81134ed0 <__adddf3>
8112f7b0:	da001317 	ldw	r8,76(sp)
8112f7b4:	102b883a 	mov	r21,r2
8112f7b8:	182d883a 	mov	r22,r3
8112f7bc:	d8c00917 	ldw	r3,36(sp)
8112f7c0:	18000f26 	beq	r3,zero,8112f800 <_strtod_r+0x1378>
8112f7c4:	a809883a 	mov	r4,r21
8112f7c8:	b00b883a 	mov	r5,r22
8112f7cc:	000d883a 	mov	r6,zero
8112f7d0:	01ce5434 	movhi	r7,14672
8112f7d4:	da001315 	stw	r8,76(sp)
8112f7d8:	111ffc00 	call	8111ffc0 <__muldf3>
8112f7dc:	102b883a 	mov	r21,r2
8112f7e0:	182d883a 	mov	r22,r3
8112f7e4:	da001317 	ldw	r8,76(sp)
8112f7e8:	1800051e 	bne	r3,zero,8112f800 <_strtod_r+0x1378>
8112f7ec:	d8800517 	ldw	r2,20(sp)
8112f7f0:	a83e4b1e 	bne	r21,zero,8112f120 <__reset+0xfb10f120>
8112f7f4:	00c00884 	movi	r3,34
8112f7f8:	80c00015 	stw	r3,0(r16)
8112f7fc:	003e4806 	br	8112f120 <__reset+0xfb10f120>
8112f800:	d8800517 	ldw	r2,20(sp)
8112f804:	003e4606 	br	8112f120 <__reset+0xfb10f120>
8112f808:	d9000e17 	ldw	r4,56(sp)
8112f80c:	dd000a15 	stw	r20,40(sp)
8112f810:	a811883a 	mov	r8,r21
8112f814:	dd001217 	ldw	r20,72(sp)
8112f818:	dd401117 	ldw	r21,68(sp)
8112f81c:	dd801017 	ldw	r22,64(sp)
8112f820:	203fe61e 	bne	r4,zero,8112f7bc <__reset+0xfb10f7bc>
8112f824:	903fe51e 	bne	r18,zero,8112f7bc <__reset+0xfb10f7bc>
8112f828:	00800434 	movhi	r2,16
8112f82c:	10bfffc4 	addi	r2,r2,-1
8112f830:	8884703a 	and	r2,r17,r2
8112f834:	103fe11e 	bne	r2,zero,8112f7bc <__reset+0xfb10f7bc>
8112f838:	8ddffc2c 	andhi	r23,r17,32752
8112f83c:	0081ac34 	movhi	r2,1712
8112f840:	15ffde2e 	bgeu	r2,r23,8112f7bc <__reset+0xfb10f7bc>
8112f844:	40800517 	ldw	r2,20(r8)
8112f848:	1000031e 	bne	r2,zero,8112f858 <_strtod_r+0x13d0>
8112f84c:	40800417 	ldw	r2,16(r8)
8112f850:	00c00044 	movi	r3,1
8112f854:	18bfd90e 	bge	r3,r2,8112f7bc <__reset+0xfb10f7bc>
8112f858:	400b883a 	mov	r5,r8
8112f85c:	01800044 	movi	r6,1
8112f860:	8009883a 	mov	r4,r16
8112f864:	112d3740 	call	8112d374 <__lshift>
8112f868:	980b883a 	mov	r5,r19
8112f86c:	1009883a 	mov	r4,r2
8112f870:	d8801315 	stw	r2,76(sp)
8112f874:	112d4c40 	call	8112d4c4 <__mcmp>
8112f878:	da001317 	ldw	r8,76(sp)
8112f87c:	00bfcf0e 	bge	zero,r2,8112f7bc <__reset+0xfb10f7bc>
8112f880:	d8c00917 	ldw	r3,36(sp)
8112f884:	18005c26 	beq	r3,zero,8112f9f8 <_strtod_r+0x1570>
8112f888:	0081ac34 	movhi	r2,1712
8112f88c:	15c05a16 	blt	r2,r23,8112f9f8 <_strtod_r+0x1570>
8112f890:	0080dc34 	movhi	r2,880
8112f894:	15ffcb16 	blt	r2,r23,8112f7c4 <__reset+0xfb10f7c4>
8112f898:	003f1106 	br	8112f4e0 <__reset+0xfb10f4e0>
8112f89c:	002d883a 	mov	r22,zero
8112f8a0:	022ff834 	movhi	r8,49120
8112f8a4:	d8000d15 	stw	zero,52(sp)
8112f8a8:	05cff834 	movhi	r23,16352
8112f8ac:	003ded06 	br	8112f064 <__reset+0xfb10f064>
8112f8b0:	0440d434 	movhi	r17,848
8112f8b4:	1c63883a 	add	r17,r3,r17
8112f8b8:	d8000915 	stw	zero,36(sp)
8112f8bc:	003cc806 	br	8112ebe0 <__reset+0xfb10ebe0>
8112f8c0:	8884703a 	and	r2,r17,r2
8112f8c4:	103faa1e 	bne	r2,zero,8112f770 <__reset+0xfb10f770>
8112f8c8:	903fa91e 	bne	r18,zero,8112f770 <__reset+0xfb10f770>
8112f8cc:	8ddffc2c 	andhi	r23,r17,32752
8112f8d0:	003feb06 	br	8112f880 <__reset+0xfb10f880>
8112f8d4:	d8c00d17 	ldw	r3,52(sp)
8112f8d8:	1cae703a 	and	r23,r3,r18
8112f8dc:	b83fb726 	beq	r23,zero,8112f7bc <__reset+0xfb10f7bc>
8112f8e0:	003fa706 	br	8112f780 <__reset+0xfb10f780>
8112f8e4:	21000044 	addi	r4,r4,1
8112f8e8:	d9000615 	stw	r4,24(sp)
8112f8ec:	003f9006 	br	8112f730 <__reset+0xfb10f730>
8112f8f0:	01604574 	movhi	r5,33045
8112f8f4:	29437604 	addi	r5,r5,3544
8112f8f8:	d9400915 	stw	r5,36(sp)
8112f8fc:	0027883a 	mov	r19,zero
8112f900:	003ca206 	br	8112eb8c <__reset+0xfb10eb8c>
8112f904:	9009883a 	mov	r4,r18
8112f908:	880b883a 	mov	r5,r17
8112f90c:	da001315 	stw	r8,76(sp)
8112f910:	112e41c0 	call	8112e41c <sulp>
8112f914:	100d883a 	mov	r6,r2
8112f918:	180f883a 	mov	r7,r3
8112f91c:	9009883a 	mov	r4,r18
8112f920:	880b883a 	mov	r5,r17
8112f924:	11206e00 	call	811206e0 <__subdf3>
8112f928:	000d883a 	mov	r6,zero
8112f92c:	000f883a 	mov	r7,zero
8112f930:	1009883a 	mov	r4,r2
8112f934:	180b883a 	mov	r5,r3
8112f938:	102b883a 	mov	r21,r2
8112f93c:	182d883a 	mov	r22,r3
8112f940:	11360740 	call	81136074 <__eqdf2>
8112f944:	da001317 	ldw	r8,76(sp)
8112f948:	103ee526 	beq	r2,zero,8112f4e0 <__reset+0xfb10f4e0>
8112f94c:	003f9b06 	br	8112f7bc <__reset+0xfb10f7bc>
8112f950:	d8800917 	ldw	r2,36(sp)
8112f954:	10002226 	beq	r2,zero,8112f9e0 <_strtod_r+0x1558>
8112f958:	889ffc2c 	andhi	r2,r17,32752
8112f95c:	00c1a834 	movhi	r3,1696
8112f960:	18801f36 	bltu	r3,r2,8112f9e0 <_strtod_r+0x1558>
8112f964:	1004d53a 	srli	r2,r2,20
8112f968:	00c01ac4 	movi	r3,107
8112f96c:	1887c83a 	sub	r3,r3,r2
8112f970:	00bfffc4 	movi	r2,-1
8112f974:	10c4983a 	sll	r2,r2,r3
8112f978:	14bf7d1e 	bne	r2,r18,8112f770 <__reset+0xfb10f770>
8112f97c:	00dffc34 	movhi	r3,32752
8112f980:	18ffffc4 	addi	r3,r3,-1
8112f984:	88c03526 	beq	r17,r3,8112fa5c <_strtod_r+0x15d4>
8112f988:	8c5ffc2c 	andhi	r17,r17,32752
8112f98c:	00800434 	movhi	r2,16
8112f990:	002b883a 	mov	r21,zero
8112f994:	88ad883a 	add	r22,r17,r2
8112f998:	003f8806 	br	8112f7bc <__reset+0xfb10f7bc>
8112f99c:	01401a84 	movi	r5,106
8112f9a0:	d9400915 	stw	r5,36(sp)
8112f9a4:	8ddffc2c 	andhi	r23,r17,32752
8112f9a8:	b82ed53a 	srli	r23,r23,20
8112f9ac:	00801ac4 	movi	r2,107
8112f9b0:	15c5c83a 	sub	r2,r2,r23
8112f9b4:	00be8e0e 	bge	zero,r2,8112f3f0 <__reset+0xfb10f3f0>
8112f9b8:	00c007c4 	movi	r3,31
8112f9bc:	18800a0e 	bge	r3,r2,8112f9e8 <_strtod_r+0x1560>
8112f9c0:	00c00d04 	movi	r3,52
8112f9c4:	0025883a 	mov	r18,zero
8112f9c8:	1880270e 	bge	r3,r2,8112fa68 <_strtod_r+0x15e0>
8112f9cc:	0440dc34 	movhi	r17,880
8112f9d0:	003e8706 	br	8112f3f0 <__reset+0xfb10f3f0>
8112f9d4:	d8000915 	stw	zero,36(sp)
8112f9d8:	05fe6a16 	blt	zero,r23,8112f384 <__reset+0xfb10f384>
8112f9dc:	003e8406 	br	8112f3f0 <__reset+0xfb10f3f0>
8112f9e0:	00bfffc4 	movi	r2,-1
8112f9e4:	003fe406 	br	8112f978 <__reset+0xfb10f978>
8112f9e8:	00ffffc4 	movi	r3,-1
8112f9ec:	1884983a 	sll	r2,r3,r2
8112f9f0:	14a4703a 	and	r18,r2,r18
8112f9f4:	003e7e06 	br	8112f3f0 <__reset+0xfb10f3f0>
8112f9f8:	00bffc34 	movhi	r2,65520
8112f9fc:	b8af883a 	add	r23,r23,r2
8112fa00:	057fffc4 	movi	r21,-1
8112fa04:	00800434 	movhi	r2,16
8112fa08:	1545883a 	add	r2,r2,r21
8112fa0c:	b8acb03a 	or	r22,r23,r2
8112fa10:	003f6a06 	br	8112f7bc <__reset+0xfb10f7bc>
8112fa14:	01604574 	movhi	r5,33045
8112fa18:	2943b604 	addi	r5,r5,3800
8112fa1c:	d9800204 	addi	r6,sp,8
8112fa20:	d9000604 	addi	r4,sp,24
8112fa24:	1133b2c0 	call	81133b2c <__hexnan>
8112fa28:	00c00144 	movi	r3,5
8112fa2c:	10fb5c1e 	bne	r2,r3,8112e7a0 <__reset+0xfb10e7a0>
8112fa30:	dc400317 	ldw	r17,12(sp)
8112fa34:	dc800217 	ldw	r18,8(sp)
8112fa38:	8c5ffc34 	orhi	r17,r17,32752
8112fa3c:	003b5a06 	br	8112e7a8 <__reset+0xfb10e7a8>
8112fa40:	480b883a 	mov	r5,r9
8112fa44:	d9800617 	ldw	r6,24(sp)
8112fa48:	4a400044 	addi	r9,r9,1
8112fa4c:	003eeb06 	br	8112f5fc <__reset+0xfb10f5fc>
8112fa50:	1025883a 	mov	r18,r2
8112fa54:	1823883a 	mov	r17,r3
8112fa58:	003c4c06 	br	8112eb8c <__reset+0xfb10eb8c>
8112fa5c:	00ffffc4 	movi	r3,-1
8112fa60:	10ffc91e 	bne	r2,r3,8112f988 <__reset+0xfb10f988>
8112fa64:	003da906 	br	8112f10c <__reset+0xfb10f10c>
8112fa68:	10bff804 	addi	r2,r2,-32
8112fa6c:	00ffffc4 	movi	r3,-1
8112fa70:	1884983a 	sll	r2,r3,r2
8112fa74:	1462703a 	and	r17,r2,r17
8112fa78:	003e5d06 	br	8112f3f0 <__reset+0xfb10f3f0>
8112fa7c:	1025883a 	mov	r18,r2
8112fa80:	1823883a 	mov	r17,r3
8112fa84:	003e5806 	br	8112f3e8 <__reset+0xfb10f3e8>

8112fa88 <strtod>:
8112fa88:	00a04574 	movhi	r2,33045
8112fa8c:	108d0f04 	addi	r2,r2,13372
8112fa90:	280d883a 	mov	r6,r5
8112fa94:	200b883a 	mov	r5,r4
8112fa98:	11000017 	ldw	r4,0(r2)
8112fa9c:	112e4881 	jmpi	8112e488 <_strtod_r>

8112faa0 <strtof>:
8112faa0:	defffb04 	addi	sp,sp,-20
8112faa4:	de00012e 	bgeu	sp,et,8112faac <strtof+0xc>
8112faa8:	003b68fa 	trap	3
8112faac:	dcc00315 	stw	r19,12(sp)
8112fab0:	04e04574 	movhi	r19,33045
8112fab4:	9ccd0f04 	addi	r19,r19,13372
8112fab8:	280d883a 	mov	r6,r5
8112fabc:	200b883a 	mov	r5,r4
8112fac0:	99000017 	ldw	r4,0(r19)
8112fac4:	dfc00415 	stw	ra,16(sp)
8112fac8:	dc800215 	stw	r18,8(sp)
8112facc:	dc400115 	stw	r17,4(sp)
8112fad0:	dc000015 	stw	r16,0(sp)
8112fad4:	112e4880 	call	8112e488 <_strtod_r>
8112fad8:	1009883a 	mov	r4,r2
8112fadc:	180b883a 	mov	r5,r3
8112fae0:	1025883a 	mov	r18,r2
8112fae4:	1823883a 	mov	r17,r3
8112fae8:	11212600 	call	81121260 <__truncdfsf2>
8112faec:	000b883a 	mov	r5,zero
8112faf0:	1009883a 	mov	r4,r2
8112faf4:	1021883a 	mov	r16,r2
8112faf8:	1134cd40 	call	81134cd4 <__eqsf2>
8112fafc:	1000111e 	bne	r2,zero,8112fb44 <strtof+0xa4>
8112fb00:	000d883a 	mov	r6,zero
8112fb04:	000f883a 	mov	r7,zero
8112fb08:	9009883a 	mov	r4,r18
8112fb0c:	880b883a 	mov	r5,r17
8112fb10:	11360740 	call	81136074 <__eqdf2>
8112fb14:	10000b26 	beq	r2,zero,8112fb44 <strtof+0xa4>
8112fb18:	98800017 	ldw	r2,0(r19)
8112fb1c:	00c00884 	movi	r3,34
8112fb20:	10c00015 	stw	r3,0(r2)
8112fb24:	8005883a 	mov	r2,r16
8112fb28:	dfc00417 	ldw	ra,16(sp)
8112fb2c:	dcc00317 	ldw	r19,12(sp)
8112fb30:	dc800217 	ldw	r18,8(sp)
8112fb34:	dc400117 	ldw	r17,4(sp)
8112fb38:	dc000017 	ldw	r16,0(sp)
8112fb3c:	dec00504 	addi	sp,sp,20
8112fb40:	f800283a 	ret
8112fb44:	015fe034 	movhi	r5,32640
8112fb48:	297fffc4 	addi	r5,r5,-1
8112fb4c:	8009883a 	mov	r4,r16
8112fb50:	1134d4c0 	call	81134d4c <__gesf2>
8112fb54:	0080070e 	bge	zero,r2,8112fb74 <strtof+0xd4>
8112fb58:	01dffc34 	movhi	r7,32752
8112fb5c:	39ffffc4 	addi	r7,r7,-1
8112fb60:	01bfffc4 	movi	r6,-1
8112fb64:	9009883a 	mov	r4,r18
8112fb68:	880b883a 	mov	r5,r17
8112fb6c:	111fee40 	call	8111fee4 <__gedf2>
8112fb70:	00bfe90e 	bge	zero,r2,8112fb18 <__reset+0xfb10fb18>
8112fb74:	017fe034 	movhi	r5,65408
8112fb78:	297fffc4 	addi	r5,r5,-1
8112fb7c:	8009883a 	mov	r4,r16
8112fb80:	1134e080 	call	81134e08 <__lesf2>
8112fb84:	103fe70e 	bge	r2,zero,8112fb24 <__reset+0xfb10fb24>
8112fb88:	01fffc34 	movhi	r7,65520
8112fb8c:	39ffffc4 	addi	r7,r7,-1
8112fb90:	01bfffc4 	movi	r6,-1
8112fb94:	9009883a 	mov	r4,r18
8112fb98:	880b883a 	mov	r5,r17
8112fb9c:	11360fc0 	call	811360fc <__ledf2>
8112fba0:	103fdd0e 	bge	r2,zero,8112fb18 <__reset+0xfb10fb18>
8112fba4:	003fdf06 	br	8112fb24 <__reset+0xfb10fb24>

8112fba8 <_strtoul_r>:
8112fba8:	00a04574 	movhi	r2,33045
8112fbac:	defff604 	addi	sp,sp,-40
8112fbb0:	108d0d04 	addi	r2,r2,13364
8112fbb4:	de00012e 	bgeu	sp,et,8112fbbc <_strtoul_r+0x14>
8112fbb8:	003b68fa 	trap	3
8112fbbc:	dc800315 	stw	r18,12(sp)
8112fbc0:	14800017 	ldw	r18,0(r2)
8112fbc4:	dd400615 	stw	r21,24(sp)
8112fbc8:	dd000515 	stw	r20,20(sp)
8112fbcc:	dcc00415 	stw	r19,16(sp)
8112fbd0:	2029883a 	mov	r20,r4
8112fbd4:	dfc00915 	stw	ra,36(sp)
8112fbd8:	ddc00815 	stw	r23,32(sp)
8112fbdc:	dd800715 	stw	r22,28(sp)
8112fbe0:	dc400215 	stw	r17,8(sp)
8112fbe4:	dc000115 	stw	r16,4(sp)
8112fbe8:	2827883a 	mov	r19,r5
8112fbec:	382b883a 	mov	r21,r7
8112fbf0:	2809883a 	mov	r4,r5
8112fbf4:	24000003 	ldbu	r16,0(r4)
8112fbf8:	24400044 	addi	r17,r4,1
8112fbfc:	2007883a 	mov	r3,r4
8112fc00:	9405883a 	add	r2,r18,r16
8112fc04:	10800043 	ldbu	r2,1(r2)
8112fc08:	8809883a 	mov	r4,r17
8112fc0c:	1080020c 	andi	r2,r2,8
8112fc10:	103ff81e 	bne	r2,zero,8112fbf4 <__reset+0xfb10fbf4>
8112fc14:	00800b44 	movi	r2,45
8112fc18:	80805326 	beq	r16,r2,8112fd68 <_strtoul_r+0x1c0>
8112fc1c:	00800ac4 	movi	r2,43
8112fc20:	80805526 	beq	r16,r2,8112fd78 <_strtoul_r+0x1d0>
8112fc24:	002f883a 	mov	r23,zero
8112fc28:	a8000f26 	beq	r21,zero,8112fc68 <_strtoul_r+0xc0>
8112fc2c:	00800404 	movi	r2,16
8112fc30:	a8805f26 	beq	r21,r2,8112fdb0 <_strtoul_r+0x208>
8112fc34:	013fffc4 	movi	r4,-1
8112fc38:	a80b883a 	mov	r5,r21
8112fc3c:	d9800015 	stw	r6,0(sp)
8112fc40:	1134c180 	call	81134c18 <__udivsi3>
8112fc44:	a80b883a 	mov	r5,r21
8112fc48:	013fffc4 	movi	r4,-1
8112fc4c:	102d883a 	mov	r22,r2
8112fc50:	1134c7c0 	call	81134c7c <__umodsi3>
8112fc54:	d9800017 	ldw	r6,0(sp)
8112fc58:	1019883a 	mov	r12,r2
8112fc5c:	a817883a 	mov	r11,r21
8112fc60:	b00f883a 	mov	r7,r22
8112fc64:	00000706 	br	8112fc84 <_strtoul_r+0xdc>
8112fc68:	00800c04 	movi	r2,48
8112fc6c:	80804626 	beq	r16,r2,8112fd88 <_strtoul_r+0x1e0>
8112fc70:	05400284 	movi	r21,10
8112fc74:	01c666b4 	movhi	r7,6554
8112fc78:	03000144 	movi	r12,5
8112fc7c:	39e66644 	addi	r7,r7,-26215
8112fc80:	a817883a 	mov	r11,r21
8112fc84:	9407883a 	add	r3,r18,r16
8112fc88:	18c00043 	ldbu	r3,1(r3)
8112fc8c:	8809883a 	mov	r4,r17
8112fc90:	0011883a 	mov	r8,zero
8112fc94:	1940010c 	andi	r5,r3,4
8112fc98:	0005883a 	mov	r2,zero
8112fc9c:	02800044 	movi	r10,1
8112fca0:	027fffc4 	movi	r9,-1
8112fca4:	28000e26 	beq	r5,zero,8112fce0 <_strtoul_r+0x138>
8112fca8:	843ff404 	addi	r16,r16,-48
8112fcac:	8540120e 	bge	r16,r21,8112fcf8 <_strtoul_r+0x150>
8112fcb0:	42400526 	beq	r8,r9,8112fcc8 <_strtoul_r+0x120>
8112fcb4:	38802236 	bltu	r7,r2,8112fd40 <_strtoul_r+0x198>
8112fcb8:	11c02026 	beq	r2,r7,8112fd3c <_strtoul_r+0x194>
8112fcbc:	12c5383a 	mul	r2,r2,r11
8112fcc0:	02000044 	movi	r8,1
8112fcc4:	8085883a 	add	r2,r16,r2
8112fcc8:	24000003 	ldbu	r16,0(r4)
8112fccc:	21000044 	addi	r4,r4,1
8112fcd0:	9407883a 	add	r3,r18,r16
8112fcd4:	18c00043 	ldbu	r3,1(r3)
8112fcd8:	1940010c 	andi	r5,r3,4
8112fcdc:	283ff21e 	bne	r5,zero,8112fca8 <__reset+0xfb10fca8>
8112fce0:	18c000cc 	andi	r3,r3,3
8112fce4:	18000426 	beq	r3,zero,8112fcf8 <_strtoul_r+0x150>
8112fce8:	1a801726 	beq	r3,r10,8112fd48 <_strtoul_r+0x1a0>
8112fcec:	00c015c4 	movi	r3,87
8112fcf0:	80e1c83a 	sub	r16,r16,r3
8112fcf4:	857fee16 	blt	r16,r21,8112fcb0 <__reset+0xfb10fcb0>
8112fcf8:	40001516 	blt	r8,zero,8112fd50 <_strtoul_r+0x1a8>
8112fcfc:	b8000126 	beq	r23,zero,8112fd04 <_strtoul_r+0x15c>
8112fd00:	0085c83a 	sub	r2,zero,r2
8112fd04:	30000226 	beq	r6,zero,8112fd10 <_strtoul_r+0x168>
8112fd08:	4000151e 	bne	r8,zero,8112fd60 <_strtoul_r+0x1b8>
8112fd0c:	34c00015 	stw	r19,0(r6)
8112fd10:	dfc00917 	ldw	ra,36(sp)
8112fd14:	ddc00817 	ldw	r23,32(sp)
8112fd18:	dd800717 	ldw	r22,28(sp)
8112fd1c:	dd400617 	ldw	r21,24(sp)
8112fd20:	dd000517 	ldw	r20,20(sp)
8112fd24:	dcc00417 	ldw	r19,16(sp)
8112fd28:	dc800317 	ldw	r18,12(sp)
8112fd2c:	dc400217 	ldw	r17,8(sp)
8112fd30:	dc000117 	ldw	r16,4(sp)
8112fd34:	dec00a04 	addi	sp,sp,40
8112fd38:	f800283a 	ret
8112fd3c:	643fdf0e 	bge	r12,r16,8112fcbc <__reset+0xfb10fcbc>
8112fd40:	023fffc4 	movi	r8,-1
8112fd44:	003fe006 	br	8112fcc8 <__reset+0xfb10fcc8>
8112fd48:	00c00dc4 	movi	r3,55
8112fd4c:	003fe806 	br	8112fcf0 <__reset+0xfb10fcf0>
8112fd50:	00800884 	movi	r2,34
8112fd54:	a0800015 	stw	r2,0(r20)
8112fd58:	00bfffc4 	movi	r2,-1
8112fd5c:	303fec26 	beq	r6,zero,8112fd10 <__reset+0xfb10fd10>
8112fd60:	24ffffc4 	addi	r19,r4,-1
8112fd64:	003fe906 	br	8112fd0c <__reset+0xfb10fd0c>
8112fd68:	1c400084 	addi	r17,r3,2
8112fd6c:	1c000043 	ldbu	r16,1(r3)
8112fd70:	05c00044 	movi	r23,1
8112fd74:	003fac06 	br	8112fc28 <__reset+0xfb10fc28>
8112fd78:	1c400084 	addi	r17,r3,2
8112fd7c:	1c000043 	ldbu	r16,1(r3)
8112fd80:	002f883a 	mov	r23,zero
8112fd84:	003fa806 	br	8112fc28 <__reset+0xfb10fc28>
8112fd88:	88800003 	ldbu	r2,0(r17)
8112fd8c:	00c01604 	movi	r3,88
8112fd90:	108037cc 	andi	r2,r2,223
8112fd94:	10c00c26 	beq	r2,r3,8112fdc8 <_strtoul_r+0x220>
8112fd98:	05400204 	movi	r21,8
8112fd9c:	01c80034 	movhi	r7,8192
8112fda0:	030001c4 	movi	r12,7
8112fda4:	39ffffc4 	addi	r7,r7,-1
8112fda8:	a817883a 	mov	r11,r21
8112fdac:	003fb506 	br	8112fc84 <__reset+0xfb10fc84>
8112fdb0:	00800c04 	movi	r2,48
8112fdb4:	80800c1e 	bne	r16,r2,8112fde8 <_strtoul_r+0x240>
8112fdb8:	88800003 	ldbu	r2,0(r17)
8112fdbc:	00c01604 	movi	r3,88
8112fdc0:	108037cc 	andi	r2,r2,223
8112fdc4:	10c0081e 	bne	r2,r3,8112fde8 <_strtoul_r+0x240>
8112fdc8:	02c00404 	movi	r11,16
8112fdcc:	05840034 	movhi	r22,4096
8112fdd0:	8c000043 	ldbu	r16,1(r17)
8112fdd4:	030003c4 	movi	r12,15
8112fdd8:	8c400084 	addi	r17,r17,2
8112fddc:	b5bfffc4 	addi	r22,r22,-1
8112fde0:	582b883a 	mov	r21,r11
8112fde4:	003f9e06 	br	8112fc60 <__reset+0xfb10fc60>
8112fde8:	01c40034 	movhi	r7,4096
8112fdec:	030003c4 	movi	r12,15
8112fdf0:	39ffffc4 	addi	r7,r7,-1
8112fdf4:	a817883a 	mov	r11,r21
8112fdf8:	003fa206 	br	8112fc84 <__reset+0xfb10fc84>

8112fdfc <strtoul>:
8112fdfc:	00a04574 	movhi	r2,33045
8112fe00:	108d0f04 	addi	r2,r2,13372
8112fe04:	300f883a 	mov	r7,r6
8112fe08:	280d883a 	mov	r6,r5
8112fe0c:	200b883a 	mov	r5,r4
8112fe10:	11000017 	ldw	r4,0(r2)
8112fe14:	112fba81 	jmpi	8112fba8 <_strtoul_r>

8112fe18 <_strtoull_r>:
8112fe18:	00a04574 	movhi	r2,33045
8112fe1c:	defff404 	addi	sp,sp,-48
8112fe20:	108d0d04 	addi	r2,r2,13364
8112fe24:	de00012e 	bgeu	sp,et,8112fe2c <_strtoull_r+0x14>
8112fe28:	003b68fa 	trap	3
8112fe2c:	dc400315 	stw	r17,12(sp)
8112fe30:	14400017 	ldw	r17,0(r2)
8112fe34:	dd400715 	stw	r21,28(sp)
8112fe38:	dd000615 	stw	r20,24(sp)
8112fe3c:	dcc00515 	stw	r19,20(sp)
8112fe40:	dc800415 	stw	r18,16(sp)
8112fe44:	dfc00b15 	stw	ra,44(sp)
8112fe48:	df000a15 	stw	fp,40(sp)
8112fe4c:	ddc00915 	stw	r23,36(sp)
8112fe50:	dd800815 	stw	r22,32(sp)
8112fe54:	dc000215 	stw	r16,8(sp)
8112fe58:	2827883a 	mov	r19,r5
8112fe5c:	202b883a 	mov	r21,r4
8112fe60:	3029883a 	mov	r20,r6
8112fe64:	3825883a 	mov	r18,r7
8112fe68:	2807883a 	mov	r3,r5
8112fe6c:	1c000003 	ldbu	r16,0(r3)
8112fe70:	1f000044 	addi	fp,r3,1
8112fe74:	1809883a 	mov	r4,r3
8112fe78:	8c05883a 	add	r2,r17,r16
8112fe7c:	10800043 	ldbu	r2,1(r2)
8112fe80:	e007883a 	mov	r3,fp
8112fe84:	1080020c 	andi	r2,r2,8
8112fe88:	103ff81e 	bne	r2,zero,8112fe6c <__reset+0xfb10fe6c>
8112fe8c:	00800b44 	movi	r2,45
8112fe90:	80806e26 	beq	r16,r2,8113004c <_strtoull_r+0x234>
8112fe94:	00800ac4 	movi	r2,43
8112fe98:	80807026 	beq	r16,r2,8113005c <_strtoull_r+0x244>
8112fe9c:	002f883a 	mov	r23,zero
8112fea0:	90001426 	beq	r18,zero,8112fef4 <_strtoull_r+0xdc>
8112fea4:	00800404 	movi	r2,16
8112fea8:	90807c26 	beq	r18,r2,8113009c <_strtoull_r+0x284>
8112feac:	902dd7fa 	srai	r22,r18,31
8112feb0:	013fffc4 	movi	r4,-1
8112feb4:	200b883a 	mov	r5,r4
8112feb8:	900d883a 	mov	r6,r18
8112febc:	b00f883a 	mov	r7,r22
8112fec0:	11340600 	call	81134060 <__udivdi3>
8112fec4:	013fffc4 	movi	r4,-1
8112fec8:	900d883a 	mov	r6,r18
8112fecc:	b00f883a 	mov	r7,r22
8112fed0:	200b883a 	mov	r5,r4
8112fed4:	d8c00115 	stw	r3,4(sp)
8112fed8:	d8800015 	stw	r2,0(sp)
8112fedc:	11345e00 	call	811345e0 <__umoddi3>
8112fee0:	101b883a 	mov	r13,r2
8112fee4:	9015883a 	mov	r10,r18
8112fee8:	dac00017 	ldw	r11,0(sp)
8112feec:	da000117 	ldw	r8,4(sp)
8112fef0:	00000a06 	br	8112ff1c <_strtoull_r+0x104>
8112fef4:	00800c04 	movi	r2,48
8112fef8:	80805c26 	beq	r16,r2,8113006c <_strtoull_r+0x254>
8112fefc:	02800284 	movi	r10,10
8112ff00:	02e666b4 	movhi	r11,39322
8112ff04:	020666b4 	movhi	r8,6554
8112ff08:	03400144 	movi	r13,5
8112ff0c:	5ae66644 	addi	r11,r11,-26215
8112ff10:	42266644 	addi	r8,r8,-26215
8112ff14:	002d883a 	mov	r22,zero
8112ff18:	5025883a 	mov	r18,r10
8112ff1c:	8c0b883a 	add	r5,r17,r16
8112ff20:	29400043 	ldbu	r5,1(r5)
8112ff24:	e009883a 	mov	r4,fp
8112ff28:	000f883a 	mov	r7,zero
8112ff2c:	2980010c 	andi	r6,r5,4
8112ff30:	0005883a 	mov	r2,zero
8112ff34:	0007883a 	mov	r3,zero
8112ff38:	03000044 	movi	r12,1
8112ff3c:	027fffc4 	movi	r9,-1
8112ff40:	30000d26 	beq	r6,zero,8112ff78 <_strtoull_r+0x160>
8112ff44:	843ff404 	addi	r16,r16,-48
8112ff48:	8480110e 	bge	r16,r18,8112ff90 <_strtoull_r+0x178>
8112ff4c:	3a400426 	beq	r7,r9,8112ff60 <_strtoull_r+0x148>
8112ff50:	40c00236 	bltu	r8,r3,8112ff5c <_strtoull_r+0x144>
8112ff54:	1a00231e 	bne	r3,r8,8112ffe4 <_strtoull_r+0x1cc>
8112ff58:	5880222e 	bgeu	r11,r2,8112ffe4 <_strtoull_r+0x1cc>
8112ff5c:	01ffffc4 	movi	r7,-1
8112ff60:	24000003 	ldbu	r16,0(r4)
8112ff64:	21000044 	addi	r4,r4,1
8112ff68:	8c0b883a 	add	r5,r17,r16
8112ff6c:	29400043 	ldbu	r5,1(r5)
8112ff70:	2980010c 	andi	r6,r5,4
8112ff74:	303ff31e 	bne	r6,zero,8112ff44 <__reset+0xfb10ff44>
8112ff78:	294000cc 	andi	r5,r5,3
8112ff7c:	28000426 	beq	r5,zero,8112ff90 <_strtoull_r+0x178>
8112ff80:	2b002626 	beq	r5,r12,8113001c <_strtoull_r+0x204>
8112ff84:	014015c4 	movi	r5,87
8112ff88:	8161c83a 	sub	r16,r16,r5
8112ff8c:	84bfef16 	blt	r16,r18,8112ff4c <__reset+0xfb10ff4c>
8112ff90:	38002716 	blt	r7,zero,81130030 <_strtoull_r+0x218>
8112ff94:	b8000426 	beq	r23,zero,8112ffa8 <_strtoull_r+0x190>
8112ff98:	0085c83a 	sub	r2,zero,r2
8112ff9c:	100ac03a 	cmpne	r5,r2,zero
8112ffa0:	00e1c83a 	sub	r16,zero,r3
8112ffa4:	8147c83a 	sub	r3,r16,r5
8112ffa8:	a0000226 	beq	r20,zero,8112ffb4 <_strtoull_r+0x19c>
8112ffac:	3800251e 	bne	r7,zero,81130044 <_strtoull_r+0x22c>
8112ffb0:	a4c00015 	stw	r19,0(r20)
8112ffb4:	dfc00b17 	ldw	ra,44(sp)
8112ffb8:	df000a17 	ldw	fp,40(sp)
8112ffbc:	ddc00917 	ldw	r23,36(sp)
8112ffc0:	dd800817 	ldw	r22,32(sp)
8112ffc4:	dd400717 	ldw	r21,28(sp)
8112ffc8:	dd000617 	ldw	r20,24(sp)
8112ffcc:	dcc00517 	ldw	r19,20(sp)
8112ffd0:	dc800417 	ldw	r18,16(sp)
8112ffd4:	dc400317 	ldw	r17,12(sp)
8112ffd8:	dc000217 	ldw	r16,8(sp)
8112ffdc:	dec00c04 	addi	sp,sp,48
8112ffe0:	f800283a 	ret
8112ffe4:	12c00f26 	beq	r2,r11,81130024 <_strtoull_r+0x20c>
8112ffe8:	b08d383a 	mul	r6,r22,r2
8112ffec:	1a87383a 	mul	r3,r3,r10
8112fff0:	128a383a 	mulxuu	r5,r2,r10
8112fff4:	1285383a 	mul	r2,r2,r10
8112fff8:	800fd7fa 	srai	r7,r16,31
8112fffc:	1987883a 	add	r3,r3,r6
81130000:	8085883a 	add	r2,r16,r2
81130004:	1947883a 	add	r3,r3,r5
81130008:	38c7883a 	add	r3,r7,r3
8113000c:	1421803a 	cmpltu	r16,r2,r16
81130010:	80c7883a 	add	r3,r16,r3
81130014:	01c00044 	movi	r7,1
81130018:	003fd106 	br	8112ff60 <__reset+0xfb10ff60>
8113001c:	01400dc4 	movi	r5,55
81130020:	003fd906 	br	8112ff88 <__reset+0xfb10ff88>
81130024:	1a3ff01e 	bne	r3,r8,8112ffe8 <__reset+0xfb10ffe8>
81130028:	6c3fcc16 	blt	r13,r16,8112ff5c <__reset+0xfb10ff5c>
8113002c:	003fee06 	br	8112ffe8 <__reset+0xfb10ffe8>
81130030:	00800884 	movi	r2,34
81130034:	a8800015 	stw	r2,0(r21)
81130038:	00bfffc4 	movi	r2,-1
8113003c:	1007883a 	mov	r3,r2
81130040:	a03fdc26 	beq	r20,zero,8112ffb4 <__reset+0xfb10ffb4>
81130044:	24ffffc4 	addi	r19,r4,-1
81130048:	003fd906 	br	8112ffb0 <__reset+0xfb10ffb0>
8113004c:	27000084 	addi	fp,r4,2
81130050:	24000043 	ldbu	r16,1(r4)
81130054:	05c00044 	movi	r23,1
81130058:	003f9106 	br	8112fea0 <__reset+0xfb10fea0>
8113005c:	27000084 	addi	fp,r4,2
81130060:	24000043 	ldbu	r16,1(r4)
81130064:	002f883a 	mov	r23,zero
81130068:	003f8d06 	br	8112fea0 <__reset+0xfb10fea0>
8113006c:	e0800003 	ldbu	r2,0(fp)
81130070:	00c01604 	movi	r3,88
81130074:	108037cc 	andi	r2,r2,223
81130078:	10c00e26 	beq	r2,r3,811300b4 <_strtoull_r+0x29c>
8113007c:	02800204 	movi	r10,8
81130080:	02ffffc4 	movi	r11,-1
81130084:	02080034 	movhi	r8,8192
81130088:	034001c4 	movi	r13,7
8113008c:	42d1883a 	add	r8,r8,r11
81130090:	002d883a 	mov	r22,zero
81130094:	5025883a 	mov	r18,r10
81130098:	003fa006 	br	8112ff1c <__reset+0xfb10ff1c>
8113009c:	00800c04 	movi	r2,48
811300a0:	80800e1e 	bne	r16,r2,811300dc <_strtoull_r+0x2c4>
811300a4:	e0800003 	ldbu	r2,0(fp)
811300a8:	00c01604 	movi	r3,88
811300ac:	108037cc 	andi	r2,r2,223
811300b0:	10c00a1e 	bne	r2,r3,811300dc <_strtoull_r+0x2c4>
811300b4:	02800404 	movi	r10,16
811300b8:	02ffffc4 	movi	r11,-1
811300bc:	02040034 	movhi	r8,4096
811300c0:	e4000043 	ldbu	r16,1(fp)
811300c4:	034003c4 	movi	r13,15
811300c8:	e7000084 	addi	fp,fp,2
811300cc:	42d1883a 	add	r8,r8,r11
811300d0:	002d883a 	mov	r22,zero
811300d4:	5025883a 	mov	r18,r10
811300d8:	003f9006 	br	8112ff1c <__reset+0xfb10ff1c>
811300dc:	02ffffc4 	movi	r11,-1
811300e0:	02040034 	movhi	r8,4096
811300e4:	034003c4 	movi	r13,15
811300e8:	42d1883a 	add	r8,r8,r11
811300ec:	9015883a 	mov	r10,r18
811300f0:	002d883a 	mov	r22,zero
811300f4:	003f8906 	br	8112ff1c <__reset+0xfb10ff1c>

811300f8 <__ssprint_r>:
811300f8:	defff604 	addi	sp,sp,-40
811300fc:	de00012e 	bgeu	sp,et,81130104 <__ssprint_r+0xc>
81130100:	003b68fa 	trap	3
81130104:	30800217 	ldw	r2,8(r6)
81130108:	dc800215 	stw	r18,8(sp)
8113010c:	dfc00915 	stw	ra,36(sp)
81130110:	df000815 	stw	fp,32(sp)
81130114:	ddc00715 	stw	r23,28(sp)
81130118:	dd800615 	stw	r22,24(sp)
8113011c:	dd400515 	stw	r21,20(sp)
81130120:	dd000415 	stw	r20,16(sp)
81130124:	dcc00315 	stw	r19,12(sp)
81130128:	dc400115 	stw	r17,4(sp)
8113012c:	dc000015 	stw	r16,0(sp)
81130130:	3025883a 	mov	r18,r6
81130134:	10005826 	beq	r2,zero,81130298 <__ssprint_r+0x1a0>
81130138:	2027883a 	mov	r19,r4
8113013c:	35c00017 	ldw	r23,0(r6)
81130140:	29000017 	ldw	r4,0(r5)
81130144:	28800217 	ldw	r2,8(r5)
81130148:	2823883a 	mov	r17,r5
8113014c:	0039883a 	mov	fp,zero
81130150:	0021883a 	mov	r16,zero
81130154:	80003926 	beq	r16,zero,8113023c <__ssprint_r+0x144>
81130158:	102b883a 	mov	r21,r2
8113015c:	102d883a 	mov	r22,r2
81130160:	80803a36 	bltu	r16,r2,8113024c <__ssprint_r+0x154>
81130164:	88c0030b 	ldhu	r3,12(r17)
81130168:	1881200c 	andi	r2,r3,1152
8113016c:	10002626 	beq	r2,zero,81130208 <__ssprint_r+0x110>
81130170:	88800517 	ldw	r2,20(r17)
81130174:	89400417 	ldw	r5,16(r17)
81130178:	81800044 	addi	r6,r16,1
8113017c:	108f883a 	add	r7,r2,r2
81130180:	3885883a 	add	r2,r7,r2
81130184:	100ed7fa 	srli	r7,r2,31
81130188:	216dc83a 	sub	r22,r4,r5
8113018c:	3589883a 	add	r4,r6,r22
81130190:	3885883a 	add	r2,r7,r2
81130194:	102bd07a 	srai	r21,r2,1
81130198:	a80d883a 	mov	r6,r21
8113019c:	a900022e 	bgeu	r21,r4,811301a8 <__ssprint_r+0xb0>
811301a0:	202b883a 	mov	r21,r4
811301a4:	200d883a 	mov	r6,r4
811301a8:	18c1000c 	andi	r3,r3,1024
811301ac:	18002a26 	beq	r3,zero,81130258 <__ssprint_r+0x160>
811301b0:	300b883a 	mov	r5,r6
811301b4:	9809883a 	mov	r4,r19
811301b8:	1121e7c0 	call	81121e7c <_malloc_r>
811301bc:	1029883a 	mov	r20,r2
811301c0:	10002c26 	beq	r2,zero,81130274 <__ssprint_r+0x17c>
811301c4:	89400417 	ldw	r5,16(r17)
811301c8:	b00d883a 	mov	r6,r22
811301cc:	1009883a 	mov	r4,r2
811301d0:	11226900 	call	81122690 <memcpy>
811301d4:	8880030b 	ldhu	r2,12(r17)
811301d8:	00fedfc4 	movi	r3,-1153
811301dc:	10c4703a 	and	r2,r2,r3
811301e0:	10802014 	ori	r2,r2,128
811301e4:	8880030d 	sth	r2,12(r17)
811301e8:	a589883a 	add	r4,r20,r22
811301ec:	adadc83a 	sub	r22,r21,r22
811301f0:	8d400515 	stw	r21,20(r17)
811301f4:	8d800215 	stw	r22,8(r17)
811301f8:	8d000415 	stw	r20,16(r17)
811301fc:	89000015 	stw	r4,0(r17)
81130200:	802b883a 	mov	r21,r16
81130204:	802d883a 	mov	r22,r16
81130208:	b00d883a 	mov	r6,r22
8113020c:	e00b883a 	mov	r5,fp
81130210:	112ca680 	call	8112ca68 <memmove>
81130214:	88800217 	ldw	r2,8(r17)
81130218:	89000017 	ldw	r4,0(r17)
8113021c:	90c00217 	ldw	r3,8(r18)
81130220:	1545c83a 	sub	r2,r2,r21
81130224:	2589883a 	add	r4,r4,r22
81130228:	88800215 	stw	r2,8(r17)
8113022c:	89000015 	stw	r4,0(r17)
81130230:	1c21c83a 	sub	r16,r3,r16
81130234:	94000215 	stw	r16,8(r18)
81130238:	80001726 	beq	r16,zero,81130298 <__ssprint_r+0x1a0>
8113023c:	bf000017 	ldw	fp,0(r23)
81130240:	bc000117 	ldw	r16,4(r23)
81130244:	bdc00204 	addi	r23,r23,8
81130248:	003fc206 	br	81130154 <__reset+0xfb110154>
8113024c:	802b883a 	mov	r21,r16
81130250:	802d883a 	mov	r22,r16
81130254:	003fec06 	br	81130208 <__reset+0xfb110208>
81130258:	9809883a 	mov	r4,r19
8113025c:	112dc880 	call	8112dc88 <_realloc_r>
81130260:	1029883a 	mov	r20,r2
81130264:	103fe01e 	bne	r2,zero,811301e8 <__reset+0xfb1101e8>
81130268:	89400417 	ldw	r5,16(r17)
8113026c:	9809883a 	mov	r4,r19
81130270:	112bbf40 	call	8112bbf4 <_free_r>
81130274:	88c0030b 	ldhu	r3,12(r17)
81130278:	00800304 	movi	r2,12
8113027c:	98800015 	stw	r2,0(r19)
81130280:	18c01014 	ori	r3,r3,64
81130284:	88c0030d 	sth	r3,12(r17)
81130288:	00bfffc4 	movi	r2,-1
8113028c:	90000215 	stw	zero,8(r18)
81130290:	90000115 	stw	zero,4(r18)
81130294:	00000206 	br	811302a0 <__ssprint_r+0x1a8>
81130298:	90000115 	stw	zero,4(r18)
8113029c:	0005883a 	mov	r2,zero
811302a0:	dfc00917 	ldw	ra,36(sp)
811302a4:	df000817 	ldw	fp,32(sp)
811302a8:	ddc00717 	ldw	r23,28(sp)
811302ac:	dd800617 	ldw	r22,24(sp)
811302b0:	dd400517 	ldw	r21,20(sp)
811302b4:	dd000417 	ldw	r20,16(sp)
811302b8:	dcc00317 	ldw	r19,12(sp)
811302bc:	dc800217 	ldw	r18,8(sp)
811302c0:	dc400117 	ldw	r17,4(sp)
811302c4:	dc000017 	ldw	r16,0(sp)
811302c8:	dec00a04 	addi	sp,sp,40
811302cc:	f800283a 	ret

811302d0 <___svfiprintf_internal_r>:
811302d0:	deffc804 	addi	sp,sp,-224
811302d4:	de00012e 	bgeu	sp,et,811302dc <___svfiprintf_internal_r+0xc>
811302d8:	003b68fa 	trap	3
811302dc:	2880030b 	ldhu	r2,12(r5)
811302e0:	dcc03115 	stw	r19,196(sp)
811302e4:	dfc03715 	stw	ra,220(sp)
811302e8:	df003615 	stw	fp,216(sp)
811302ec:	ddc03515 	stw	r23,212(sp)
811302f0:	dd803415 	stw	r22,208(sp)
811302f4:	dd403315 	stw	r21,204(sp)
811302f8:	dd003215 	stw	r20,200(sp)
811302fc:	dc803015 	stw	r18,192(sp)
81130300:	dc402f15 	stw	r17,188(sp)
81130304:	dc002e15 	stw	r16,184(sp)
81130308:	d9402715 	stw	r5,156(sp)
8113030c:	d9002a15 	stw	r4,168(sp)
81130310:	1080200c 	andi	r2,r2,128
81130314:	d9c02315 	stw	r7,140(sp)
81130318:	3027883a 	mov	r19,r6
8113031c:	10000226 	beq	r2,zero,81130328 <___svfiprintf_internal_r+0x58>
81130320:	28800417 	ldw	r2,16(r5)
81130324:	10041d26 	beq	r2,zero,8113139c <___svfiprintf_internal_r+0x10cc>
81130328:	dac01a04 	addi	r11,sp,104
8113032c:	dac01e15 	stw	r11,120(sp)
81130330:	d8801e17 	ldw	r2,120(sp)
81130334:	dac019c4 	addi	r11,sp,103
81130338:	dd402a17 	ldw	r21,168(sp)
8113033c:	ddc02717 	ldw	r23,156(sp)
81130340:	05a04574 	movhi	r22,33045
81130344:	05204574 	movhi	r20,33045
81130348:	dac01f15 	stw	r11,124(sp)
8113034c:	12d7c83a 	sub	r11,r2,r11
81130350:	b583ce04 	addi	r22,r22,3896
81130354:	a503ca04 	addi	r20,r20,3880
81130358:	dec01a15 	stw	sp,104(sp)
8113035c:	d8001c15 	stw	zero,112(sp)
81130360:	d8001b15 	stw	zero,108(sp)
81130364:	d811883a 	mov	r8,sp
81130368:	d8002915 	stw	zero,164(sp)
8113036c:	d8002515 	stw	zero,148(sp)
81130370:	dac02b15 	stw	r11,172(sp)
81130374:	98800007 	ldb	r2,0(r19)
81130378:	1002dd26 	beq	r2,zero,81130ef0 <___svfiprintf_internal_r+0xc20>
8113037c:	00c00944 	movi	r3,37
81130380:	9823883a 	mov	r17,r19
81130384:	10c0021e 	bne	r2,r3,81130390 <___svfiprintf_internal_r+0xc0>
81130388:	00001406 	br	811303dc <___svfiprintf_internal_r+0x10c>
8113038c:	10c00326 	beq	r2,r3,8113039c <___svfiprintf_internal_r+0xcc>
81130390:	8c400044 	addi	r17,r17,1
81130394:	88800007 	ldb	r2,0(r17)
81130398:	103ffc1e 	bne	r2,zero,8113038c <__reset+0xfb11038c>
8113039c:	8ce1c83a 	sub	r16,r17,r19
811303a0:	80000e26 	beq	r16,zero,811303dc <___svfiprintf_internal_r+0x10c>
811303a4:	d8c01c17 	ldw	r3,112(sp)
811303a8:	d8801b17 	ldw	r2,108(sp)
811303ac:	44c00015 	stw	r19,0(r8)
811303b0:	1c07883a 	add	r3,r3,r16
811303b4:	10800044 	addi	r2,r2,1
811303b8:	d8c01c15 	stw	r3,112(sp)
811303bc:	44000115 	stw	r16,4(r8)
811303c0:	d8801b15 	stw	r2,108(sp)
811303c4:	00c001c4 	movi	r3,7
811303c8:	18831e16 	blt	r3,r2,81131044 <___svfiprintf_internal_r+0xd74>
811303cc:	42000204 	addi	r8,r8,8
811303d0:	dac02517 	ldw	r11,148(sp)
811303d4:	5c17883a 	add	r11,r11,r16
811303d8:	dac02515 	stw	r11,148(sp)
811303dc:	88800007 	ldb	r2,0(r17)
811303e0:	1002c526 	beq	r2,zero,81130ef8 <___svfiprintf_internal_r+0xc28>
811303e4:	88c00047 	ldb	r3,1(r17)
811303e8:	8cc00044 	addi	r19,r17,1
811303ec:	d8001d85 	stb	zero,118(sp)
811303f0:	0009883a 	mov	r4,zero
811303f4:	000f883a 	mov	r7,zero
811303f8:	043fffc4 	movi	r16,-1
811303fc:	d8002415 	stw	zero,144(sp)
81130400:	0025883a 	mov	r18,zero
81130404:	01401604 	movi	r5,88
81130408:	01800244 	movi	r6,9
8113040c:	02800a84 	movi	r10,42
81130410:	02401b04 	movi	r9,108
81130414:	9cc00044 	addi	r19,r19,1
81130418:	18bff804 	addi	r2,r3,-32
8113041c:	2881dd36 	bltu	r5,r2,81130b94 <___svfiprintf_internal_r+0x8c4>
81130420:	100490ba 	slli	r2,r2,2
81130424:	02e044f4 	movhi	r11,33043
81130428:	5ac10e04 	addi	r11,r11,1080
8113042c:	12c5883a 	add	r2,r2,r11
81130430:	10800017 	ldw	r2,0(r2)
81130434:	1000683a 	jmp	r2
81130438:	81130634 	orhi	r4,r16,19480
8113043c:	81130b94 	ori	r4,r16,19502
81130440:	81130b94 	ori	r4,r16,19502
81130444:	81130628 	cmpgeui	r4,r16,19480
81130448:	81130b94 	ori	r4,r16,19502
8113044c:	81130b94 	ori	r4,r16,19502
81130450:	81130b94 	ori	r4,r16,19502
81130454:	81130b94 	ori	r4,r16,19502
81130458:	81130b94 	ori	r4,r16,19502
8113045c:	81130b94 	ori	r4,r16,19502
81130460:	8113059c 	xori	r4,r16,19478
81130464:	81130778 	rdprs	r4,r16,19485
81130468:	81130b94 	ori	r4,r16,19502
8113046c:	811305c8 	cmpgei	r4,r16,19479
81130470:	81130bc8 	cmpgei	r4,r16,19503
81130474:	81130b94 	ori	r4,r16,19502
81130478:	81130bbc 	xorhi	r4,r16,19502
8113047c:	81130b5c 	xori	r4,r16,19501
81130480:	81130b5c 	xori	r4,r16,19501
81130484:	81130b5c 	xori	r4,r16,19501
81130488:	81130b5c 	xori	r4,r16,19501
8113048c:	81130b5c 	xori	r4,r16,19501
81130490:	81130b5c 	xori	r4,r16,19501
81130494:	81130b5c 	xori	r4,r16,19501
81130498:	81130b5c 	xori	r4,r16,19501
8113049c:	81130b5c 	xori	r4,r16,19501
811304a0:	81130b94 	ori	r4,r16,19502
811304a4:	81130b94 	ori	r4,r16,19502
811304a8:	81130b94 	ori	r4,r16,19502
811304ac:	81130b94 	ori	r4,r16,19502
811304b0:	81130b94 	ori	r4,r16,19502
811304b4:	81130b94 	ori	r4,r16,19502
811304b8:	81130b94 	ori	r4,r16,19502
811304bc:	81130b94 	ori	r4,r16,19502
811304c0:	81130b94 	ori	r4,r16,19502
811304c4:	81130b94 	ori	r4,r16,19502
811304c8:	81130af8 	rdprs	r4,r16,19499
811304cc:	81130b94 	ori	r4,r16,19502
811304d0:	81130b94 	ori	r4,r16,19502
811304d4:	81130b94 	ori	r4,r16,19502
811304d8:	81130b94 	ori	r4,r16,19502
811304dc:	81130b94 	ori	r4,r16,19502
811304e0:	81130b94 	ori	r4,r16,19502
811304e4:	81130b94 	ori	r4,r16,19502
811304e8:	81130b94 	ori	r4,r16,19502
811304ec:	81130b94 	ori	r4,r16,19502
811304f0:	81130b94 	ori	r4,r16,19502
811304f4:	81130c70 	cmpltui	r4,r16,19505
811304f8:	81130b94 	ori	r4,r16,19502
811304fc:	81130b94 	ori	r4,r16,19502
81130500:	81130b94 	ori	r4,r16,19502
81130504:	81130b94 	ori	r4,r16,19502
81130508:	81130b94 	ori	r4,r16,19502
8113050c:	81130c08 	cmpgei	r4,r16,19504
81130510:	81130b94 	ori	r4,r16,19502
81130514:	81130b94 	ori	r4,r16,19502
81130518:	8113093c 	xorhi	r4,r16,19492
8113051c:	81130b94 	ori	r4,r16,19502
81130520:	81130b94 	ori	r4,r16,19502
81130524:	81130b94 	ori	r4,r16,19502
81130528:	81130b94 	ori	r4,r16,19502
8113052c:	81130b94 	ori	r4,r16,19502
81130530:	81130b94 	ori	r4,r16,19502
81130534:	81130b94 	ori	r4,r16,19502
81130538:	81130b94 	ori	r4,r16,19502
8113053c:	81130b94 	ori	r4,r16,19502
81130540:	81130b94 	ori	r4,r16,19502
81130544:	8113082c 	andhi	r4,r16,19488
81130548:	811309d8 	cmpnei	r4,r16,19495
8113054c:	81130b94 	ori	r4,r16,19502
81130550:	81130b94 	ori	r4,r16,19502
81130554:	81130b94 	ori	r4,r16,19502
81130558:	811309cc 	andi	r4,r16,19495
8113055c:	811309d8 	cmpnei	r4,r16,19495
81130560:	81130b94 	ori	r4,r16,19502
81130564:	81130b94 	ori	r4,r16,19502
81130568:	811309bc 	xorhi	r4,r16,19494
8113056c:	81130b94 	ori	r4,r16,19502
81130570:	81130980 	call	88113098 <__reset+0x20f3098>
81130574:	81130788 	cmpgei	r4,r16,19486
81130578:	811305d4 	ori	r4,r16,19479
8113057c:	81130aec 	andhi	r4,r16,19499
81130580:	81130b94 	ori	r4,r16,19502
81130584:	81130aa0 	cmpeqi	r4,r16,19498
81130588:	81130b94 	ori	r4,r16,19502
8113058c:	811306f8 	rdprs	r4,r16,19483
81130590:	81130b94 	ori	r4,r16,19502
81130594:	81130b94 	ori	r4,r16,19502
81130598:	81130654 	ori	r4,r16,19481
8113059c:	dac02317 	ldw	r11,140(sp)
811305a0:	5ac00017 	ldw	r11,0(r11)
811305a4:	dac02415 	stw	r11,144(sp)
811305a8:	dac02317 	ldw	r11,140(sp)
811305ac:	58800104 	addi	r2,r11,4
811305b0:	dac02417 	ldw	r11,144(sp)
811305b4:	5802e90e 	bge	r11,zero,8113115c <___svfiprintf_internal_r+0xe8c>
811305b8:	dac02417 	ldw	r11,144(sp)
811305bc:	d8802315 	stw	r2,140(sp)
811305c0:	02d7c83a 	sub	r11,zero,r11
811305c4:	dac02415 	stw	r11,144(sp)
811305c8:	94800114 	ori	r18,r18,4
811305cc:	98c00007 	ldb	r3,0(r19)
811305d0:	003f9006 	br	81130414 <__reset+0xfb110414>
811305d4:	00800c04 	movi	r2,48
811305d8:	dac02317 	ldw	r11,140(sp)
811305dc:	d8801d05 	stb	r2,116(sp)
811305e0:	00801e04 	movi	r2,120
811305e4:	d8801d45 	stb	r2,117(sp)
811305e8:	d8001d85 	stb	zero,118(sp)
811305ec:	58c00104 	addi	r3,r11,4
811305f0:	5f000017 	ldw	fp,0(r11)
811305f4:	0013883a 	mov	r9,zero
811305f8:	90800094 	ori	r2,r18,2
811305fc:	80032b16 	blt	r16,zero,811312ac <___svfiprintf_internal_r+0xfdc>
81130600:	00bfdfc4 	movi	r2,-129
81130604:	90a4703a 	and	r18,r18,r2
81130608:	d8c02315 	stw	r3,140(sp)
8113060c:	94800094 	ori	r18,r18,2
81130610:	e002dc26 	beq	fp,zero,81131184 <___svfiprintf_internal_r+0xeb4>
81130614:	01204574 	movhi	r4,33045
81130618:	21034004 	addi	r4,r4,3328
8113061c:	0015883a 	mov	r10,zero
81130620:	d9002915 	stw	r4,164(sp)
81130624:	00002306 	br	811306b4 <___svfiprintf_internal_r+0x3e4>
81130628:	94800054 	ori	r18,r18,1
8113062c:	98c00007 	ldb	r3,0(r19)
81130630:	003f7806 	br	81130414 <__reset+0xfb110414>
81130634:	38803fcc 	andi	r2,r7,255
81130638:	1080201c 	xori	r2,r2,128
8113063c:	10bfe004 	addi	r2,r2,-128
81130640:	1002f31e 	bne	r2,zero,81131210 <___svfiprintf_internal_r+0xf40>
81130644:	01000044 	movi	r4,1
81130648:	01c00804 	movi	r7,32
8113064c:	98c00007 	ldb	r3,0(r19)
81130650:	003f7006 	br	81130414 <__reset+0xfb110414>
81130654:	21003fcc 	andi	r4,r4,255
81130658:	2003aa1e 	bne	r4,zero,81131504 <___svfiprintf_internal_r+0x1234>
8113065c:	00a04574 	movhi	r2,33045
81130660:	10834004 	addi	r2,r2,3328
81130664:	d8802915 	stw	r2,164(sp)
81130668:	9080080c 	andi	r2,r18,32
8113066c:	1000ba26 	beq	r2,zero,81130958 <___svfiprintf_internal_r+0x688>
81130670:	dac02317 	ldw	r11,140(sp)
81130674:	5f000017 	ldw	fp,0(r11)
81130678:	5a400117 	ldw	r9,4(r11)
8113067c:	5ac00204 	addi	r11,r11,8
81130680:	dac02315 	stw	r11,140(sp)
81130684:	9080004c 	andi	r2,r18,1
81130688:	10029026 	beq	r2,zero,811310cc <___svfiprintf_internal_r+0xdfc>
8113068c:	e244b03a 	or	r2,fp,r9
81130690:	1002d41e 	bne	r2,zero,811311e4 <___svfiprintf_internal_r+0xf14>
81130694:	d8001d85 	stb	zero,118(sp)
81130698:	80030b16 	blt	r16,zero,811312c8 <___svfiprintf_internal_r+0xff8>
8113069c:	00bfdfc4 	movi	r2,-129
811306a0:	90a4703a 	and	r18,r18,r2
811306a4:	0015883a 	mov	r10,zero
811306a8:	80002426 	beq	r16,zero,8113073c <___svfiprintf_internal_r+0x46c>
811306ac:	0039883a 	mov	fp,zero
811306b0:	0013883a 	mov	r9,zero
811306b4:	d9002917 	ldw	r4,164(sp)
811306b8:	dc401a04 	addi	r17,sp,104
811306bc:	e08003cc 	andi	r2,fp,15
811306c0:	4806973a 	slli	r3,r9,28
811306c4:	2085883a 	add	r2,r4,r2
811306c8:	e038d13a 	srli	fp,fp,4
811306cc:	10800003 	ldbu	r2,0(r2)
811306d0:	4812d13a 	srli	r9,r9,4
811306d4:	8c7fffc4 	addi	r17,r17,-1
811306d8:	1f38b03a 	or	fp,r3,fp
811306dc:	88800005 	stb	r2,0(r17)
811306e0:	e244b03a 	or	r2,fp,r9
811306e4:	103ff51e 	bne	r2,zero,811306bc <__reset+0xfb1106bc>
811306e8:	dac01e17 	ldw	r11,120(sp)
811306ec:	5c57c83a 	sub	r11,r11,r17
811306f0:	dac02115 	stw	r11,132(sp)
811306f4:	00001406 	br	81130748 <___svfiprintf_internal_r+0x478>
811306f8:	21003fcc 	andi	r4,r4,255
811306fc:	2003741e 	bne	r4,zero,811314d0 <___svfiprintf_internal_r+0x1200>
81130700:	9080080c 	andi	r2,r18,32
81130704:	10014526 	beq	r2,zero,81130c1c <___svfiprintf_internal_r+0x94c>
81130708:	dac02317 	ldw	r11,140(sp)
8113070c:	d8001d85 	stb	zero,118(sp)
81130710:	58c00204 	addi	r3,r11,8
81130714:	5f000017 	ldw	fp,0(r11)
81130718:	5a400117 	ldw	r9,4(r11)
8113071c:	8002d916 	blt	r16,zero,81131284 <___svfiprintf_internal_r+0xfb4>
81130720:	013fdfc4 	movi	r4,-129
81130724:	e244b03a 	or	r2,fp,r9
81130728:	d8c02315 	stw	r3,140(sp)
8113072c:	9124703a 	and	r18,r18,r4
81130730:	0015883a 	mov	r10,zero
81130734:	1000b91e 	bne	r2,zero,81130a1c <___svfiprintf_internal_r+0x74c>
81130738:	8002e61e 	bne	r16,zero,811312d4 <___svfiprintf_internal_r+0x1004>
8113073c:	0021883a 	mov	r16,zero
81130740:	d8002115 	stw	zero,132(sp)
81130744:	dc401a04 	addi	r17,sp,104
81130748:	d8c02117 	ldw	r3,132(sp)
8113074c:	dc002015 	stw	r16,128(sp)
81130750:	80c0010e 	bge	r16,r3,81130758 <___svfiprintf_internal_r+0x488>
81130754:	d8c02015 	stw	r3,128(sp)
81130758:	52803fcc 	andi	r10,r10,255
8113075c:	5280201c 	xori	r10,r10,128
81130760:	52bfe004 	addi	r10,r10,-128
81130764:	50003c26 	beq	r10,zero,81130858 <___svfiprintf_internal_r+0x588>
81130768:	dac02017 	ldw	r11,128(sp)
8113076c:	5ac00044 	addi	r11,r11,1
81130770:	dac02015 	stw	r11,128(sp)
81130774:	00003806 	br	81130858 <___svfiprintf_internal_r+0x588>
81130778:	01000044 	movi	r4,1
8113077c:	01c00ac4 	movi	r7,43
81130780:	98c00007 	ldb	r3,0(r19)
81130784:	003f2306 	br	81130414 <__reset+0xfb110414>
81130788:	21003fcc 	andi	r4,r4,255
8113078c:	2003481e 	bne	r4,zero,811314b0 <___svfiprintf_internal_r+0x11e0>
81130790:	9080080c 	andi	r2,r18,32
81130794:	10013b26 	beq	r2,zero,81130c84 <___svfiprintf_internal_r+0x9b4>
81130798:	dac02317 	ldw	r11,140(sp)
8113079c:	d8001d85 	stb	zero,118(sp)
811307a0:	58800204 	addi	r2,r11,8
811307a4:	5f000017 	ldw	fp,0(r11)
811307a8:	5a400117 	ldw	r9,4(r11)
811307ac:	8002a816 	blt	r16,zero,81131250 <___svfiprintf_internal_r+0xf80>
811307b0:	013fdfc4 	movi	r4,-129
811307b4:	e246b03a 	or	r3,fp,r9
811307b8:	d8802315 	stw	r2,140(sp)
811307bc:	9124703a 	and	r18,r18,r4
811307c0:	18013c26 	beq	r3,zero,81130cb4 <___svfiprintf_internal_r+0x9e4>
811307c4:	0015883a 	mov	r10,zero
811307c8:	dc401a04 	addi	r17,sp,104
811307cc:	e006d0fa 	srli	r3,fp,3
811307d0:	4808977a 	slli	r4,r9,29
811307d4:	4812d0fa 	srli	r9,r9,3
811307d8:	e70001cc 	andi	fp,fp,7
811307dc:	e0800c04 	addi	r2,fp,48
811307e0:	8c7fffc4 	addi	r17,r17,-1
811307e4:	20f8b03a 	or	fp,r4,r3
811307e8:	88800005 	stb	r2,0(r17)
811307ec:	e246b03a 	or	r3,fp,r9
811307f0:	183ff61e 	bne	r3,zero,811307cc <__reset+0xfb1107cc>
811307f4:	90c0004c 	andi	r3,r18,1
811307f8:	1800a526 	beq	r3,zero,81130a90 <___svfiprintf_internal_r+0x7c0>
811307fc:	10803fcc 	andi	r2,r2,255
81130800:	1080201c 	xori	r2,r2,128
81130804:	10bfe004 	addi	r2,r2,-128
81130808:	00c00c04 	movi	r3,48
8113080c:	10ffb626 	beq	r2,r3,811306e8 <__reset+0xfb1106e8>
81130810:	88ffffc5 	stb	r3,-1(r17)
81130814:	d8c01e17 	ldw	r3,120(sp)
81130818:	88bfffc4 	addi	r2,r17,-1
8113081c:	1023883a 	mov	r17,r2
81130820:	1887c83a 	sub	r3,r3,r2
81130824:	d8c02115 	stw	r3,132(sp)
81130828:	003fc706 	br	81130748 <__reset+0xfb110748>
8113082c:	dac02317 	ldw	r11,140(sp)
81130830:	00c00044 	movi	r3,1
81130834:	d8c02015 	stw	r3,128(sp)
81130838:	58800017 	ldw	r2,0(r11)
8113083c:	5ac00104 	addi	r11,r11,4
81130840:	d8001d85 	stb	zero,118(sp)
81130844:	d8801005 	stb	r2,64(sp)
81130848:	dac02315 	stw	r11,140(sp)
8113084c:	d8c02115 	stw	r3,132(sp)
81130850:	dc401004 	addi	r17,sp,64
81130854:	0021883a 	mov	r16,zero
81130858:	90c0008c 	andi	r3,r18,2
8113085c:	d8c02215 	stw	r3,136(sp)
81130860:	18000326 	beq	r3,zero,81130870 <___svfiprintf_internal_r+0x5a0>
81130864:	dac02017 	ldw	r11,128(sp)
81130868:	5ac00084 	addi	r11,r11,2
8113086c:	dac02015 	stw	r11,128(sp)
81130870:	90c0210c 	andi	r3,r18,132
81130874:	d8c02615 	stw	r3,152(sp)
81130878:	1801131e 	bne	r3,zero,81130cc8 <___svfiprintf_internal_r+0x9f8>
8113087c:	dac02417 	ldw	r11,144(sp)
81130880:	d8c02017 	ldw	r3,128(sp)
81130884:	58f9c83a 	sub	fp,r11,r3
81130888:	07010f0e 	bge	zero,fp,81130cc8 <___svfiprintf_internal_r+0x9f8>
8113088c:	02400404 	movi	r9,16
81130890:	d8c01c17 	ldw	r3,112(sp)
81130894:	d8801b17 	ldw	r2,108(sp)
81130898:	4f02d60e 	bge	r9,fp,811313f4 <___svfiprintf_internal_r+0x1124>
8113089c:	01604574 	movhi	r5,33045
811308a0:	2943ce04 	addi	r5,r5,3896
811308a4:	d9402815 	stw	r5,160(sp)
811308a8:	028001c4 	movi	r10,7
811308ac:	00000306 	br	811308bc <___svfiprintf_internal_r+0x5ec>
811308b0:	e73ffc04 	addi	fp,fp,-16
811308b4:	42000204 	addi	r8,r8,8
811308b8:	4f00150e 	bge	r9,fp,81130910 <___svfiprintf_internal_r+0x640>
811308bc:	18c00404 	addi	r3,r3,16
811308c0:	10800044 	addi	r2,r2,1
811308c4:	45800015 	stw	r22,0(r8)
811308c8:	42400115 	stw	r9,4(r8)
811308cc:	d8c01c15 	stw	r3,112(sp)
811308d0:	d8801b15 	stw	r2,108(sp)
811308d4:	50bff60e 	bge	r10,r2,811308b0 <__reset+0xfb1108b0>
811308d8:	d9801a04 	addi	r6,sp,104
811308dc:	b80b883a 	mov	r5,r23
811308e0:	a809883a 	mov	r4,r21
811308e4:	da402c15 	stw	r9,176(sp)
811308e8:	da802d15 	stw	r10,180(sp)
811308ec:	11300f80 	call	811300f8 <__ssprint_r>
811308f0:	da402c17 	ldw	r9,176(sp)
811308f4:	da802d17 	ldw	r10,180(sp)
811308f8:	1001851e 	bne	r2,zero,81130f10 <___svfiprintf_internal_r+0xc40>
811308fc:	e73ffc04 	addi	fp,fp,-16
81130900:	d8c01c17 	ldw	r3,112(sp)
81130904:	d8801b17 	ldw	r2,108(sp)
81130908:	d811883a 	mov	r8,sp
8113090c:	4f3feb16 	blt	r9,fp,811308bc <__reset+0xfb1108bc>
81130910:	dac02817 	ldw	r11,160(sp)
81130914:	e0c7883a 	add	r3,fp,r3
81130918:	10800044 	addi	r2,r2,1
8113091c:	42c00015 	stw	r11,0(r8)
81130920:	47000115 	stw	fp,4(r8)
81130924:	d8c01c15 	stw	r3,112(sp)
81130928:	d8801b15 	stw	r2,108(sp)
8113092c:	010001c4 	movi	r4,7
81130930:	2081ee16 	blt	r4,r2,811310ec <___svfiprintf_internal_r+0xe1c>
81130934:	42000204 	addi	r8,r8,8
81130938:	0000e506 	br	81130cd0 <___svfiprintf_internal_r+0xa00>
8113093c:	21003fcc 	andi	r4,r4,255
81130940:	2002dd1e 	bne	r4,zero,811314b8 <___svfiprintf_internal_r+0x11e8>
81130944:	00a04574 	movhi	r2,33045
81130948:	10833b04 	addi	r2,r2,3308
8113094c:	d8802915 	stw	r2,164(sp)
81130950:	9080080c 	andi	r2,r18,32
81130954:	103f461e 	bne	r2,zero,81130670 <__reset+0xfb110670>
81130958:	9080040c 	andi	r2,r18,16
8113095c:	10022e1e 	bne	r2,zero,81131218 <___svfiprintf_internal_r+0xf48>
81130960:	9080100c 	andi	r2,r18,64
81130964:	dac02317 	ldw	r11,140(sp)
81130968:	10027326 	beq	r2,zero,81131338 <___svfiprintf_internal_r+0x1068>
8113096c:	5f00000b 	ldhu	fp,0(r11)
81130970:	5ac00104 	addi	r11,r11,4
81130974:	0013883a 	mov	r9,zero
81130978:	dac02315 	stw	r11,140(sp)
8113097c:	003f4106 	br	81130684 <__reset+0xfb110684>
81130980:	21003fcc 	andi	r4,r4,255
81130984:	2002e11e 	bne	r4,zero,8113150c <___svfiprintf_internal_r+0x123c>
81130988:	9080080c 	andi	r2,r18,32
8113098c:	1002011e 	bne	r2,zero,81131194 <___svfiprintf_internal_r+0xec4>
81130990:	9080040c 	andi	r2,r18,16
81130994:	10023e1e 	bne	r2,zero,81131290 <___svfiprintf_internal_r+0xfc0>
81130998:	9480100c 	andi	r18,r18,64
8113099c:	90023c26 	beq	r18,zero,81131290 <___svfiprintf_internal_r+0xfc0>
811309a0:	dac02317 	ldw	r11,140(sp)
811309a4:	58800017 	ldw	r2,0(r11)
811309a8:	5ac00104 	addi	r11,r11,4
811309ac:	dac02315 	stw	r11,140(sp)
811309b0:	dac02517 	ldw	r11,148(sp)
811309b4:	12c0000d 	sth	r11,0(r2)
811309b8:	003e6e06 	br	81130374 <__reset+0xfb110374>
811309bc:	98c00007 	ldb	r3,0(r19)
811309c0:	1a422926 	beq	r3,r9,81131268 <___svfiprintf_internal_r+0xf98>
811309c4:	94800414 	ori	r18,r18,16
811309c8:	003e9206 	br	81130414 <__reset+0xfb110414>
811309cc:	94801014 	ori	r18,r18,64
811309d0:	98c00007 	ldb	r3,0(r19)
811309d4:	003e8f06 	br	81130414 <__reset+0xfb110414>
811309d8:	21003fcc 	andi	r4,r4,255
811309dc:	2002c71e 	bne	r4,zero,811314fc <___svfiprintf_internal_r+0x122c>
811309e0:	9080080c 	andi	r2,r18,32
811309e4:	10004926 	beq	r2,zero,81130b0c <___svfiprintf_internal_r+0x83c>
811309e8:	dac02317 	ldw	r11,140(sp)
811309ec:	58800117 	ldw	r2,4(r11)
811309f0:	5f000017 	ldw	fp,0(r11)
811309f4:	5ac00204 	addi	r11,r11,8
811309f8:	dac02315 	stw	r11,140(sp)
811309fc:	1013883a 	mov	r9,r2
81130a00:	10004b16 	blt	r2,zero,81130b30 <___svfiprintf_internal_r+0x860>
81130a04:	da801d83 	ldbu	r10,118(sp)
81130a08:	8001cb16 	blt	r16,zero,81131138 <___svfiprintf_internal_r+0xe68>
81130a0c:	00ffdfc4 	movi	r3,-129
81130a10:	e244b03a 	or	r2,fp,r9
81130a14:	90e4703a 	and	r18,r18,r3
81130a18:	103f4726 	beq	r2,zero,81130738 <__reset+0xfb110738>
81130a1c:	48008c26 	beq	r9,zero,81130c50 <___svfiprintf_internal_r+0x980>
81130a20:	dc802015 	stw	r18,128(sp)
81130a24:	dc002115 	stw	r16,132(sp)
81130a28:	dc401a04 	addi	r17,sp,104
81130a2c:	e021883a 	mov	r16,fp
81130a30:	da002215 	stw	r8,136(sp)
81130a34:	5039883a 	mov	fp,r10
81130a38:	4825883a 	mov	r18,r9
81130a3c:	8009883a 	mov	r4,r16
81130a40:	900b883a 	mov	r5,r18
81130a44:	01800284 	movi	r6,10
81130a48:	000f883a 	mov	r7,zero
81130a4c:	11345e00 	call	811345e0 <__umoddi3>
81130a50:	10800c04 	addi	r2,r2,48
81130a54:	8c7fffc4 	addi	r17,r17,-1
81130a58:	8009883a 	mov	r4,r16
81130a5c:	900b883a 	mov	r5,r18
81130a60:	88800005 	stb	r2,0(r17)
81130a64:	01800284 	movi	r6,10
81130a68:	000f883a 	mov	r7,zero
81130a6c:	11340600 	call	81134060 <__udivdi3>
81130a70:	1021883a 	mov	r16,r2
81130a74:	10c4b03a 	or	r2,r2,r3
81130a78:	1825883a 	mov	r18,r3
81130a7c:	103fef1e 	bne	r2,zero,81130a3c <__reset+0xfb110a3c>
81130a80:	dc802017 	ldw	r18,128(sp)
81130a84:	dc002117 	ldw	r16,132(sp)
81130a88:	da002217 	ldw	r8,136(sp)
81130a8c:	e015883a 	mov	r10,fp
81130a90:	d8c01e17 	ldw	r3,120(sp)
81130a94:	1c47c83a 	sub	r3,r3,r17
81130a98:	d8c02115 	stw	r3,132(sp)
81130a9c:	003f2a06 	br	81130748 <__reset+0xfb110748>
81130aa0:	dac02317 	ldw	r11,140(sp)
81130aa4:	d8001d85 	stb	zero,118(sp)
81130aa8:	5c400017 	ldw	r17,0(r11)
81130aac:	5f000104 	addi	fp,r11,4
81130ab0:	88022f26 	beq	r17,zero,81131370 <___svfiprintf_internal_r+0x10a0>
81130ab4:	80022516 	blt	r16,zero,8113134c <___svfiprintf_internal_r+0x107c>
81130ab8:	800d883a 	mov	r6,r16
81130abc:	000b883a 	mov	r5,zero
81130ac0:	8809883a 	mov	r4,r17
81130ac4:	da002c15 	stw	r8,176(sp)
81130ac8:	112c9840 	call	8112c984 <memchr>
81130acc:	da002c17 	ldw	r8,176(sp)
81130ad0:	10026426 	beq	r2,zero,81131464 <___svfiprintf_internal_r+0x1194>
81130ad4:	1445c83a 	sub	r2,r2,r17
81130ad8:	d8802115 	stw	r2,132(sp)
81130adc:	da801d83 	ldbu	r10,118(sp)
81130ae0:	df002315 	stw	fp,140(sp)
81130ae4:	0021883a 	mov	r16,zero
81130ae8:	003f1706 	br	81130748 <__reset+0xfb110748>
81130aec:	94800814 	ori	r18,r18,32
81130af0:	98c00007 	ldb	r3,0(r19)
81130af4:	003e4706 	br	81130414 <__reset+0xfb110414>
81130af8:	21003fcc 	andi	r4,r4,255
81130afc:	2002701e 	bne	r4,zero,811314c0 <___svfiprintf_internal_r+0x11f0>
81130b00:	94800414 	ori	r18,r18,16
81130b04:	9080080c 	andi	r2,r18,32
81130b08:	103fb71e 	bne	r2,zero,811309e8 <__reset+0xfb1109e8>
81130b0c:	9080040c 	andi	r2,r18,16
81130b10:	1001ab26 	beq	r2,zero,811311c0 <___svfiprintf_internal_r+0xef0>
81130b14:	dac02317 	ldw	r11,140(sp)
81130b18:	5f000017 	ldw	fp,0(r11)
81130b1c:	5ac00104 	addi	r11,r11,4
81130b20:	dac02315 	stw	r11,140(sp)
81130b24:	e013d7fa 	srai	r9,fp,31
81130b28:	4805883a 	mov	r2,r9
81130b2c:	103fb50e 	bge	r2,zero,81130a04 <__reset+0xfb110a04>
81130b30:	0739c83a 	sub	fp,zero,fp
81130b34:	02800b44 	movi	r10,45
81130b38:	e004c03a 	cmpne	r2,fp,zero
81130b3c:	0253c83a 	sub	r9,zero,r9
81130b40:	da801d85 	stb	r10,118(sp)
81130b44:	4893c83a 	sub	r9,r9,r2
81130b48:	80023016 	blt	r16,zero,8113140c <___svfiprintf_internal_r+0x113c>
81130b4c:	00bfdfc4 	movi	r2,-129
81130b50:	90a4703a 	and	r18,r18,r2
81130b54:	483fb21e 	bne	r9,zero,81130a20 <__reset+0xfb110a20>
81130b58:	00003d06 	br	81130c50 <___svfiprintf_internal_r+0x980>
81130b5c:	9817883a 	mov	r11,r19
81130b60:	d8002415 	stw	zero,144(sp)
81130b64:	18bff404 	addi	r2,r3,-48
81130b68:	0019883a 	mov	r12,zero
81130b6c:	58c00007 	ldb	r3,0(r11)
81130b70:	630002a4 	muli	r12,r12,10
81130b74:	9cc00044 	addi	r19,r19,1
81130b78:	9817883a 	mov	r11,r19
81130b7c:	1319883a 	add	r12,r2,r12
81130b80:	18bff404 	addi	r2,r3,-48
81130b84:	30bff92e 	bgeu	r6,r2,81130b6c <__reset+0xfb110b6c>
81130b88:	db002415 	stw	r12,144(sp)
81130b8c:	18bff804 	addi	r2,r3,-32
81130b90:	28be232e 	bgeu	r5,r2,81130420 <__reset+0xfb110420>
81130b94:	21003fcc 	andi	r4,r4,255
81130b98:	20024b1e 	bne	r4,zero,811314c8 <___svfiprintf_internal_r+0x11f8>
81130b9c:	1800d626 	beq	r3,zero,81130ef8 <___svfiprintf_internal_r+0xc28>
81130ba0:	02c00044 	movi	r11,1
81130ba4:	dac02015 	stw	r11,128(sp)
81130ba8:	d8c01005 	stb	r3,64(sp)
81130bac:	d8001d85 	stb	zero,118(sp)
81130bb0:	dac02115 	stw	r11,132(sp)
81130bb4:	dc401004 	addi	r17,sp,64
81130bb8:	003f2606 	br	81130854 <__reset+0xfb110854>
81130bbc:	94802014 	ori	r18,r18,128
81130bc0:	98c00007 	ldb	r3,0(r19)
81130bc4:	003e1306 	br	81130414 <__reset+0xfb110414>
81130bc8:	98c00007 	ldb	r3,0(r19)
81130bcc:	9ac00044 	addi	r11,r19,1
81130bd0:	1a822b26 	beq	r3,r10,81131480 <___svfiprintf_internal_r+0x11b0>
81130bd4:	18bff404 	addi	r2,r3,-48
81130bd8:	0021883a 	mov	r16,zero
81130bdc:	30821e36 	bltu	r6,r2,81131458 <___svfiprintf_internal_r+0x1188>
81130be0:	58c00007 	ldb	r3,0(r11)
81130be4:	840002a4 	muli	r16,r16,10
81130be8:	5cc00044 	addi	r19,r11,1
81130bec:	9817883a 	mov	r11,r19
81130bf0:	80a1883a 	add	r16,r16,r2
81130bf4:	18bff404 	addi	r2,r3,-48
81130bf8:	30bff92e 	bgeu	r6,r2,81130be0 <__reset+0xfb110be0>
81130bfc:	803e060e 	bge	r16,zero,81130418 <__reset+0xfb110418>
81130c00:	043fffc4 	movi	r16,-1
81130c04:	003e0406 	br	81130418 <__reset+0xfb110418>
81130c08:	21003fcc 	andi	r4,r4,255
81130c0c:	2002371e 	bne	r4,zero,811314ec <___svfiprintf_internal_r+0x121c>
81130c10:	94800414 	ori	r18,r18,16
81130c14:	9080080c 	andi	r2,r18,32
81130c18:	103ebb1e 	bne	r2,zero,81130708 <__reset+0xfb110708>
81130c1c:	9080040c 	andi	r2,r18,16
81130c20:	10013b26 	beq	r2,zero,81131110 <___svfiprintf_internal_r+0xe40>
81130c24:	dac02317 	ldw	r11,140(sp)
81130c28:	d8001d85 	stb	zero,118(sp)
81130c2c:	0013883a 	mov	r9,zero
81130c30:	58800104 	addi	r2,r11,4
81130c34:	5f000017 	ldw	fp,0(r11)
81130c38:	80013d16 	blt	r16,zero,81131130 <___svfiprintf_internal_r+0xe60>
81130c3c:	00ffdfc4 	movi	r3,-129
81130c40:	d8802315 	stw	r2,140(sp)
81130c44:	90e4703a 	and	r18,r18,r3
81130c48:	0015883a 	mov	r10,zero
81130c4c:	e03eba26 	beq	fp,zero,81130738 <__reset+0xfb110738>
81130c50:	00800244 	movi	r2,9
81130c54:	173f7236 	bltu	r2,fp,81130a20 <__reset+0xfb110a20>
81130c58:	dac02b17 	ldw	r11,172(sp)
81130c5c:	e7000c04 	addi	fp,fp,48
81130c60:	df0019c5 	stb	fp,103(sp)
81130c64:	dac02115 	stw	r11,132(sp)
81130c68:	dc4019c4 	addi	r17,sp,103
81130c6c:	003eb606 	br	81130748 <__reset+0xfb110748>
81130c70:	21003fcc 	andi	r4,r4,255
81130c74:	20021f1e 	bne	r4,zero,811314f4 <___svfiprintf_internal_r+0x1224>
81130c78:	94800414 	ori	r18,r18,16
81130c7c:	9080080c 	andi	r2,r18,32
81130c80:	103ec51e 	bne	r2,zero,81130798 <__reset+0xfb110798>
81130c84:	9080040c 	andi	r2,r18,16
81130c88:	10016926 	beq	r2,zero,81131230 <___svfiprintf_internal_r+0xf60>
81130c8c:	dac02317 	ldw	r11,140(sp)
81130c90:	d8001d85 	stb	zero,118(sp)
81130c94:	0013883a 	mov	r9,zero
81130c98:	58800104 	addi	r2,r11,4
81130c9c:	5f000017 	ldw	fp,0(r11)
81130ca0:	80016b16 	blt	r16,zero,81131250 <___svfiprintf_internal_r+0xf80>
81130ca4:	00ffdfc4 	movi	r3,-129
81130ca8:	d8802315 	stw	r2,140(sp)
81130cac:	90e4703a 	and	r18,r18,r3
81130cb0:	e03ec41e 	bne	fp,zero,811307c4 <__reset+0xfb1107c4>
81130cb4:	0015883a 	mov	r10,zero
81130cb8:	8001c226 	beq	r16,zero,811313c4 <___svfiprintf_internal_r+0x10f4>
81130cbc:	0039883a 	mov	fp,zero
81130cc0:	0013883a 	mov	r9,zero
81130cc4:	003ec006 	br	811307c8 <__reset+0xfb1107c8>
81130cc8:	d8c01c17 	ldw	r3,112(sp)
81130ccc:	d8801b17 	ldw	r2,108(sp)
81130cd0:	d9001d87 	ldb	r4,118(sp)
81130cd4:	20000b26 	beq	r4,zero,81130d04 <___svfiprintf_internal_r+0xa34>
81130cd8:	d9001d84 	addi	r4,sp,118
81130cdc:	18c00044 	addi	r3,r3,1
81130ce0:	10800044 	addi	r2,r2,1
81130ce4:	41000015 	stw	r4,0(r8)
81130ce8:	01000044 	movi	r4,1
81130cec:	41000115 	stw	r4,4(r8)
81130cf0:	d8c01c15 	stw	r3,112(sp)
81130cf4:	d8801b15 	stw	r2,108(sp)
81130cf8:	010001c4 	movi	r4,7
81130cfc:	2080e116 	blt	r4,r2,81131084 <___svfiprintf_internal_r+0xdb4>
81130d00:	42000204 	addi	r8,r8,8
81130d04:	dac02217 	ldw	r11,136(sp)
81130d08:	58000b26 	beq	r11,zero,81130d38 <___svfiprintf_internal_r+0xa68>
81130d0c:	d9001d04 	addi	r4,sp,116
81130d10:	18c00084 	addi	r3,r3,2
81130d14:	10800044 	addi	r2,r2,1
81130d18:	41000015 	stw	r4,0(r8)
81130d1c:	01000084 	movi	r4,2
81130d20:	41000115 	stw	r4,4(r8)
81130d24:	d8c01c15 	stw	r3,112(sp)
81130d28:	d8801b15 	stw	r2,108(sp)
81130d2c:	010001c4 	movi	r4,7
81130d30:	2080dd16 	blt	r4,r2,811310a8 <___svfiprintf_internal_r+0xdd8>
81130d34:	42000204 	addi	r8,r8,8
81130d38:	dac02617 	ldw	r11,152(sp)
81130d3c:	01002004 	movi	r4,128
81130d40:	59008426 	beq	r11,r4,81130f54 <___svfiprintf_internal_r+0xc84>
81130d44:	dac02117 	ldw	r11,132(sp)
81130d48:	82e1c83a 	sub	r16,r16,r11
81130d4c:	0400270e 	bge	zero,r16,81130dec <___svfiprintf_internal_r+0xb1c>
81130d50:	01c00404 	movi	r7,16
81130d54:	3c016a0e 	bge	r7,r16,81131300 <___svfiprintf_internal_r+0x1030>
81130d58:	01604574 	movhi	r5,33045
81130d5c:	2943ca04 	addi	r5,r5,3880
81130d60:	d9402215 	stw	r5,136(sp)
81130d64:	070001c4 	movi	fp,7
81130d68:	00000306 	br	81130d78 <___svfiprintf_internal_r+0xaa8>
81130d6c:	843ffc04 	addi	r16,r16,-16
81130d70:	42000204 	addi	r8,r8,8
81130d74:	3c00130e 	bge	r7,r16,81130dc4 <___svfiprintf_internal_r+0xaf4>
81130d78:	18c00404 	addi	r3,r3,16
81130d7c:	10800044 	addi	r2,r2,1
81130d80:	45000015 	stw	r20,0(r8)
81130d84:	41c00115 	stw	r7,4(r8)
81130d88:	d8c01c15 	stw	r3,112(sp)
81130d8c:	d8801b15 	stw	r2,108(sp)
81130d90:	e0bff60e 	bge	fp,r2,81130d6c <__reset+0xfb110d6c>
81130d94:	d9801a04 	addi	r6,sp,104
81130d98:	b80b883a 	mov	r5,r23
81130d9c:	a809883a 	mov	r4,r21
81130da0:	d9c02c15 	stw	r7,176(sp)
81130da4:	11300f80 	call	811300f8 <__ssprint_r>
81130da8:	d9c02c17 	ldw	r7,176(sp)
81130dac:	1000581e 	bne	r2,zero,81130f10 <___svfiprintf_internal_r+0xc40>
81130db0:	843ffc04 	addi	r16,r16,-16
81130db4:	d8c01c17 	ldw	r3,112(sp)
81130db8:	d8801b17 	ldw	r2,108(sp)
81130dbc:	d811883a 	mov	r8,sp
81130dc0:	3c3fed16 	blt	r7,r16,81130d78 <__reset+0xfb110d78>
81130dc4:	dac02217 	ldw	r11,136(sp)
81130dc8:	1c07883a 	add	r3,r3,r16
81130dcc:	10800044 	addi	r2,r2,1
81130dd0:	42c00015 	stw	r11,0(r8)
81130dd4:	44000115 	stw	r16,4(r8)
81130dd8:	d8c01c15 	stw	r3,112(sp)
81130ddc:	d8801b15 	stw	r2,108(sp)
81130de0:	010001c4 	movi	r4,7
81130de4:	20809e16 	blt	r4,r2,81131060 <___svfiprintf_internal_r+0xd90>
81130de8:	42000204 	addi	r8,r8,8
81130dec:	dac02117 	ldw	r11,132(sp)
81130df0:	10800044 	addi	r2,r2,1
81130df4:	44400015 	stw	r17,0(r8)
81130df8:	58c7883a 	add	r3,r11,r3
81130dfc:	42c00115 	stw	r11,4(r8)
81130e00:	d8c01c15 	stw	r3,112(sp)
81130e04:	d8801b15 	stw	r2,108(sp)
81130e08:	010001c4 	movi	r4,7
81130e0c:	20807f16 	blt	r4,r2,8113100c <___svfiprintf_internal_r+0xd3c>
81130e10:	42000204 	addi	r8,r8,8
81130e14:	9480010c 	andi	r18,r18,4
81130e18:	90002926 	beq	r18,zero,81130ec0 <___svfiprintf_internal_r+0xbf0>
81130e1c:	dac02417 	ldw	r11,144(sp)
81130e20:	d8802017 	ldw	r2,128(sp)
81130e24:	58a1c83a 	sub	r16,r11,r2
81130e28:	0400250e 	bge	zero,r16,81130ec0 <___svfiprintf_internal_r+0xbf0>
81130e2c:	04400404 	movi	r17,16
81130e30:	d8801b17 	ldw	r2,108(sp)
81130e34:	8c017c0e 	bge	r17,r16,81131428 <___svfiprintf_internal_r+0x1158>
81130e38:	01604574 	movhi	r5,33045
81130e3c:	2943ce04 	addi	r5,r5,3896
81130e40:	d9402815 	stw	r5,160(sp)
81130e44:	048001c4 	movi	r18,7
81130e48:	00000306 	br	81130e58 <___svfiprintf_internal_r+0xb88>
81130e4c:	843ffc04 	addi	r16,r16,-16
81130e50:	42000204 	addi	r8,r8,8
81130e54:	8c00110e 	bge	r17,r16,81130e9c <___svfiprintf_internal_r+0xbcc>
81130e58:	18c00404 	addi	r3,r3,16
81130e5c:	10800044 	addi	r2,r2,1
81130e60:	45800015 	stw	r22,0(r8)
81130e64:	44400115 	stw	r17,4(r8)
81130e68:	d8c01c15 	stw	r3,112(sp)
81130e6c:	d8801b15 	stw	r2,108(sp)
81130e70:	90bff60e 	bge	r18,r2,81130e4c <__reset+0xfb110e4c>
81130e74:	d9801a04 	addi	r6,sp,104
81130e78:	b80b883a 	mov	r5,r23
81130e7c:	a809883a 	mov	r4,r21
81130e80:	11300f80 	call	811300f8 <__ssprint_r>
81130e84:	1000221e 	bne	r2,zero,81130f10 <___svfiprintf_internal_r+0xc40>
81130e88:	843ffc04 	addi	r16,r16,-16
81130e8c:	d8c01c17 	ldw	r3,112(sp)
81130e90:	d8801b17 	ldw	r2,108(sp)
81130e94:	d811883a 	mov	r8,sp
81130e98:	8c3fef16 	blt	r17,r16,81130e58 <__reset+0xfb110e58>
81130e9c:	dac02817 	ldw	r11,160(sp)
81130ea0:	1c07883a 	add	r3,r3,r16
81130ea4:	10800044 	addi	r2,r2,1
81130ea8:	42c00015 	stw	r11,0(r8)
81130eac:	44000115 	stw	r16,4(r8)
81130eb0:	d8c01c15 	stw	r3,112(sp)
81130eb4:	d8801b15 	stw	r2,108(sp)
81130eb8:	010001c4 	movi	r4,7
81130ebc:	2080aa16 	blt	r4,r2,81131168 <___svfiprintf_internal_r+0xe98>
81130ec0:	d8802417 	ldw	r2,144(sp)
81130ec4:	dac02017 	ldw	r11,128(sp)
81130ec8:	12c0010e 	bge	r2,r11,81130ed0 <___svfiprintf_internal_r+0xc00>
81130ecc:	5805883a 	mov	r2,r11
81130ed0:	dac02517 	ldw	r11,148(sp)
81130ed4:	5897883a 	add	r11,r11,r2
81130ed8:	dac02515 	stw	r11,148(sp)
81130edc:	1800531e 	bne	r3,zero,8113102c <___svfiprintf_internal_r+0xd5c>
81130ee0:	98800007 	ldb	r2,0(r19)
81130ee4:	d8001b15 	stw	zero,108(sp)
81130ee8:	d811883a 	mov	r8,sp
81130eec:	103d231e 	bne	r2,zero,8113037c <__reset+0xfb11037c>
81130ef0:	9823883a 	mov	r17,r19
81130ef4:	003d3906 	br	811303dc <__reset+0xfb1103dc>
81130ef8:	d8801c17 	ldw	r2,112(sp)
81130efc:	10000426 	beq	r2,zero,81130f10 <___svfiprintf_internal_r+0xc40>
81130f00:	d9402717 	ldw	r5,156(sp)
81130f04:	d9002a17 	ldw	r4,168(sp)
81130f08:	d9801a04 	addi	r6,sp,104
81130f0c:	11300f80 	call	811300f8 <__ssprint_r>
81130f10:	dac02717 	ldw	r11,156(sp)
81130f14:	d8802517 	ldw	r2,148(sp)
81130f18:	58c0030b 	ldhu	r3,12(r11)
81130f1c:	18c0100c 	andi	r3,r3,64
81130f20:	1801381e 	bne	r3,zero,81131404 <___svfiprintf_internal_r+0x1134>
81130f24:	dfc03717 	ldw	ra,220(sp)
81130f28:	df003617 	ldw	fp,216(sp)
81130f2c:	ddc03517 	ldw	r23,212(sp)
81130f30:	dd803417 	ldw	r22,208(sp)
81130f34:	dd403317 	ldw	r21,204(sp)
81130f38:	dd003217 	ldw	r20,200(sp)
81130f3c:	dcc03117 	ldw	r19,196(sp)
81130f40:	dc803017 	ldw	r18,192(sp)
81130f44:	dc402f17 	ldw	r17,188(sp)
81130f48:	dc002e17 	ldw	r16,184(sp)
81130f4c:	dec03804 	addi	sp,sp,224
81130f50:	f800283a 	ret
81130f54:	dac02417 	ldw	r11,144(sp)
81130f58:	d9002017 	ldw	r4,128(sp)
81130f5c:	5939c83a 	sub	fp,r11,r4
81130f60:	073f780e 	bge	zero,fp,81130d44 <__reset+0xfb110d44>
81130f64:	02400404 	movi	r9,16
81130f68:	4f01370e 	bge	r9,fp,81131448 <___svfiprintf_internal_r+0x1178>
81130f6c:	02e04574 	movhi	r11,33045
81130f70:	5ac3ca04 	addi	r11,r11,3880
81130f74:	dac02215 	stw	r11,136(sp)
81130f78:	028001c4 	movi	r10,7
81130f7c:	00000306 	br	81130f8c <___svfiprintf_internal_r+0xcbc>
81130f80:	e73ffc04 	addi	fp,fp,-16
81130f84:	42000204 	addi	r8,r8,8
81130f88:	4f00150e 	bge	r9,fp,81130fe0 <___svfiprintf_internal_r+0xd10>
81130f8c:	18c00404 	addi	r3,r3,16
81130f90:	10800044 	addi	r2,r2,1
81130f94:	45000015 	stw	r20,0(r8)
81130f98:	42400115 	stw	r9,4(r8)
81130f9c:	d8c01c15 	stw	r3,112(sp)
81130fa0:	d8801b15 	stw	r2,108(sp)
81130fa4:	50bff60e 	bge	r10,r2,81130f80 <__reset+0xfb110f80>
81130fa8:	d9801a04 	addi	r6,sp,104
81130fac:	b80b883a 	mov	r5,r23
81130fb0:	a809883a 	mov	r4,r21
81130fb4:	da402c15 	stw	r9,176(sp)
81130fb8:	da802d15 	stw	r10,180(sp)
81130fbc:	11300f80 	call	811300f8 <__ssprint_r>
81130fc0:	da402c17 	ldw	r9,176(sp)
81130fc4:	da802d17 	ldw	r10,180(sp)
81130fc8:	103fd11e 	bne	r2,zero,81130f10 <__reset+0xfb110f10>
81130fcc:	e73ffc04 	addi	fp,fp,-16
81130fd0:	d8c01c17 	ldw	r3,112(sp)
81130fd4:	d8801b17 	ldw	r2,108(sp)
81130fd8:	d811883a 	mov	r8,sp
81130fdc:	4f3feb16 	blt	r9,fp,81130f8c <__reset+0xfb110f8c>
81130fe0:	dac02217 	ldw	r11,136(sp)
81130fe4:	1f07883a 	add	r3,r3,fp
81130fe8:	10800044 	addi	r2,r2,1
81130fec:	42c00015 	stw	r11,0(r8)
81130ff0:	47000115 	stw	fp,4(r8)
81130ff4:	d8c01c15 	stw	r3,112(sp)
81130ff8:	d8801b15 	stw	r2,108(sp)
81130ffc:	010001c4 	movi	r4,7
81131000:	2080b616 	blt	r4,r2,811312dc <___svfiprintf_internal_r+0x100c>
81131004:	42000204 	addi	r8,r8,8
81131008:	003f4e06 	br	81130d44 <__reset+0xfb110d44>
8113100c:	d9801a04 	addi	r6,sp,104
81131010:	b80b883a 	mov	r5,r23
81131014:	a809883a 	mov	r4,r21
81131018:	11300f80 	call	811300f8 <__ssprint_r>
8113101c:	103fbc1e 	bne	r2,zero,81130f10 <__reset+0xfb110f10>
81131020:	d8c01c17 	ldw	r3,112(sp)
81131024:	d811883a 	mov	r8,sp
81131028:	003f7a06 	br	81130e14 <__reset+0xfb110e14>
8113102c:	d9801a04 	addi	r6,sp,104
81131030:	b80b883a 	mov	r5,r23
81131034:	a809883a 	mov	r4,r21
81131038:	11300f80 	call	811300f8 <__ssprint_r>
8113103c:	103fa826 	beq	r2,zero,81130ee0 <__reset+0xfb110ee0>
81131040:	003fb306 	br	81130f10 <__reset+0xfb110f10>
81131044:	d9801a04 	addi	r6,sp,104
81131048:	b80b883a 	mov	r5,r23
8113104c:	a809883a 	mov	r4,r21
81131050:	11300f80 	call	811300f8 <__ssprint_r>
81131054:	103fae1e 	bne	r2,zero,81130f10 <__reset+0xfb110f10>
81131058:	d811883a 	mov	r8,sp
8113105c:	003cdc06 	br	811303d0 <__reset+0xfb1103d0>
81131060:	d9801a04 	addi	r6,sp,104
81131064:	b80b883a 	mov	r5,r23
81131068:	a809883a 	mov	r4,r21
8113106c:	11300f80 	call	811300f8 <__ssprint_r>
81131070:	103fa71e 	bne	r2,zero,81130f10 <__reset+0xfb110f10>
81131074:	d8c01c17 	ldw	r3,112(sp)
81131078:	d8801b17 	ldw	r2,108(sp)
8113107c:	d811883a 	mov	r8,sp
81131080:	003f5a06 	br	81130dec <__reset+0xfb110dec>
81131084:	d9801a04 	addi	r6,sp,104
81131088:	b80b883a 	mov	r5,r23
8113108c:	a809883a 	mov	r4,r21
81131090:	11300f80 	call	811300f8 <__ssprint_r>
81131094:	103f9e1e 	bne	r2,zero,81130f10 <__reset+0xfb110f10>
81131098:	d8c01c17 	ldw	r3,112(sp)
8113109c:	d8801b17 	ldw	r2,108(sp)
811310a0:	d811883a 	mov	r8,sp
811310a4:	003f1706 	br	81130d04 <__reset+0xfb110d04>
811310a8:	d9801a04 	addi	r6,sp,104
811310ac:	b80b883a 	mov	r5,r23
811310b0:	a809883a 	mov	r4,r21
811310b4:	11300f80 	call	811300f8 <__ssprint_r>
811310b8:	103f951e 	bne	r2,zero,81130f10 <__reset+0xfb110f10>
811310bc:	d8c01c17 	ldw	r3,112(sp)
811310c0:	d8801b17 	ldw	r2,108(sp)
811310c4:	d811883a 	mov	r8,sp
811310c8:	003f1b06 	br	81130d38 <__reset+0xfb110d38>
811310cc:	d8001d85 	stb	zero,118(sp)
811310d0:	80007b16 	blt	r16,zero,811312c0 <___svfiprintf_internal_r+0xff0>
811310d4:	00ffdfc4 	movi	r3,-129
811310d8:	e244b03a 	or	r2,fp,r9
811310dc:	90e4703a 	and	r18,r18,r3
811310e0:	103d7026 	beq	r2,zero,811306a4 <__reset+0xfb1106a4>
811310e4:	0015883a 	mov	r10,zero
811310e8:	003d7206 	br	811306b4 <__reset+0xfb1106b4>
811310ec:	d9801a04 	addi	r6,sp,104
811310f0:	b80b883a 	mov	r5,r23
811310f4:	a809883a 	mov	r4,r21
811310f8:	11300f80 	call	811300f8 <__ssprint_r>
811310fc:	103f841e 	bne	r2,zero,81130f10 <__reset+0xfb110f10>
81131100:	d8c01c17 	ldw	r3,112(sp)
81131104:	d8801b17 	ldw	r2,108(sp)
81131108:	d811883a 	mov	r8,sp
8113110c:	003ef006 	br	81130cd0 <__reset+0xfb110cd0>
81131110:	9080100c 	andi	r2,r18,64
81131114:	d8001d85 	stb	zero,118(sp)
81131118:	dac02317 	ldw	r11,140(sp)
8113111c:	10008126 	beq	r2,zero,81131324 <___svfiprintf_internal_r+0x1054>
81131120:	58800104 	addi	r2,r11,4
81131124:	5f00000b 	ldhu	fp,0(r11)
81131128:	0013883a 	mov	r9,zero
8113112c:	803ec30e 	bge	r16,zero,81130c3c <__reset+0xfb110c3c>
81131130:	d8802315 	stw	r2,140(sp)
81131134:	0015883a 	mov	r10,zero
81131138:	e244b03a 	or	r2,fp,r9
8113113c:	103e371e 	bne	r2,zero,81130a1c <__reset+0xfb110a1c>
81131140:	00800044 	movi	r2,1
81131144:	10803fcc 	andi	r2,r2,255
81131148:	00c00044 	movi	r3,1
8113114c:	10c06126 	beq	r2,r3,811312d4 <___svfiprintf_internal_r+0x1004>
81131150:	00c00084 	movi	r3,2
81131154:	10fd5526 	beq	r2,r3,811306ac <__reset+0xfb1106ac>
81131158:	003ed806 	br	81130cbc <__reset+0xfb110cbc>
8113115c:	d8802315 	stw	r2,140(sp)
81131160:	98c00007 	ldb	r3,0(r19)
81131164:	003cab06 	br	81130414 <__reset+0xfb110414>
81131168:	d9801a04 	addi	r6,sp,104
8113116c:	b80b883a 	mov	r5,r23
81131170:	a809883a 	mov	r4,r21
81131174:	11300f80 	call	811300f8 <__ssprint_r>
81131178:	103f651e 	bne	r2,zero,81130f10 <__reset+0xfb110f10>
8113117c:	d8c01c17 	ldw	r3,112(sp)
81131180:	003f4f06 	br	81130ec0 <__reset+0xfb110ec0>
81131184:	00a04574 	movhi	r2,33045
81131188:	10834004 	addi	r2,r2,3328
8113118c:	d8802915 	stw	r2,164(sp)
81131190:	003d4406 	br	811306a4 <__reset+0xfb1106a4>
81131194:	dac02317 	ldw	r11,140(sp)
81131198:	58800017 	ldw	r2,0(r11)
8113119c:	dac02517 	ldw	r11,148(sp)
811311a0:	5807d7fa 	srai	r3,r11,31
811311a4:	dac02317 	ldw	r11,140(sp)
811311a8:	10c00115 	stw	r3,4(r2)
811311ac:	5ac00104 	addi	r11,r11,4
811311b0:	dac02315 	stw	r11,140(sp)
811311b4:	dac02517 	ldw	r11,148(sp)
811311b8:	12c00015 	stw	r11,0(r2)
811311bc:	003c6d06 	br	81130374 <__reset+0xfb110374>
811311c0:	9080100c 	andi	r2,r18,64
811311c4:	dac02317 	ldw	r11,140(sp)
811311c8:	103e5326 	beq	r2,zero,81130b18 <__reset+0xfb110b18>
811311cc:	5f00000f 	ldh	fp,0(r11)
811311d0:	5ac00104 	addi	r11,r11,4
811311d4:	dac02315 	stw	r11,140(sp)
811311d8:	e013d7fa 	srai	r9,fp,31
811311dc:	4805883a 	mov	r2,r9
811311e0:	003e0706 	br	81130a00 <__reset+0xfb110a00>
811311e4:	00800c04 	movi	r2,48
811311e8:	d8801d05 	stb	r2,116(sp)
811311ec:	d8c01d45 	stb	r3,117(sp)
811311f0:	d8001d85 	stb	zero,118(sp)
811311f4:	90800094 	ori	r2,r18,2
811311f8:	80008f16 	blt	r16,zero,81131438 <___svfiprintf_internal_r+0x1168>
811311fc:	00bfdfc4 	movi	r2,-129
81131200:	90a4703a 	and	r18,r18,r2
81131204:	94800094 	ori	r18,r18,2
81131208:	0015883a 	mov	r10,zero
8113120c:	003d2906 	br	811306b4 <__reset+0xfb1106b4>
81131210:	98c00007 	ldb	r3,0(r19)
81131214:	003c7f06 	br	81130414 <__reset+0xfb110414>
81131218:	dac02317 	ldw	r11,140(sp)
8113121c:	0013883a 	mov	r9,zero
81131220:	5f000017 	ldw	fp,0(r11)
81131224:	5ac00104 	addi	r11,r11,4
81131228:	dac02315 	stw	r11,140(sp)
8113122c:	003d1506 	br	81130684 <__reset+0xfb110684>
81131230:	9080100c 	andi	r2,r18,64
81131234:	d8001d85 	stb	zero,118(sp)
81131238:	dac02317 	ldw	r11,140(sp)
8113123c:	10003426 	beq	r2,zero,81131310 <___svfiprintf_internal_r+0x1040>
81131240:	58800104 	addi	r2,r11,4
81131244:	5f00000b 	ldhu	fp,0(r11)
81131248:	0013883a 	mov	r9,zero
8113124c:	803e950e 	bge	r16,zero,81130ca4 <__reset+0xfb110ca4>
81131250:	e246b03a 	or	r3,fp,r9
81131254:	d8802315 	stw	r2,140(sp)
81131258:	183d5a1e 	bne	r3,zero,811307c4 <__reset+0xfb1107c4>
8113125c:	0015883a 	mov	r10,zero
81131260:	0005883a 	mov	r2,zero
81131264:	003fb706 	br	81131144 <__reset+0xfb111144>
81131268:	98c00043 	ldbu	r3,1(r19)
8113126c:	94800814 	ori	r18,r18,32
81131270:	9cc00044 	addi	r19,r19,1
81131274:	18c03fcc 	andi	r3,r3,255
81131278:	18c0201c 	xori	r3,r3,128
8113127c:	18ffe004 	addi	r3,r3,-128
81131280:	003c6406 	br	81130414 <__reset+0xfb110414>
81131284:	d8c02315 	stw	r3,140(sp)
81131288:	0015883a 	mov	r10,zero
8113128c:	003faa06 	br	81131138 <__reset+0xfb111138>
81131290:	dac02317 	ldw	r11,140(sp)
81131294:	58800017 	ldw	r2,0(r11)
81131298:	5ac00104 	addi	r11,r11,4
8113129c:	dac02315 	stw	r11,140(sp)
811312a0:	dac02517 	ldw	r11,148(sp)
811312a4:	12c00015 	stw	r11,0(r2)
811312a8:	003c3206 	br	81130374 <__reset+0xfb110374>
811312ac:	01204574 	movhi	r4,33045
811312b0:	21034004 	addi	r4,r4,3328
811312b4:	d9002915 	stw	r4,164(sp)
811312b8:	d8c02315 	stw	r3,140(sp)
811312bc:	1025883a 	mov	r18,r2
811312c0:	e244b03a 	or	r2,fp,r9
811312c4:	103f871e 	bne	r2,zero,811310e4 <__reset+0xfb1110e4>
811312c8:	0015883a 	mov	r10,zero
811312cc:	00800084 	movi	r2,2
811312d0:	003f9c06 	br	81131144 <__reset+0xfb111144>
811312d4:	0039883a 	mov	fp,zero
811312d8:	003e5f06 	br	81130c58 <__reset+0xfb110c58>
811312dc:	d9801a04 	addi	r6,sp,104
811312e0:	b80b883a 	mov	r5,r23
811312e4:	a809883a 	mov	r4,r21
811312e8:	11300f80 	call	811300f8 <__ssprint_r>
811312ec:	103f081e 	bne	r2,zero,81130f10 <__reset+0xfb110f10>
811312f0:	d8c01c17 	ldw	r3,112(sp)
811312f4:	d8801b17 	ldw	r2,108(sp)
811312f8:	d811883a 	mov	r8,sp
811312fc:	003e9106 	br	81130d44 <__reset+0xfb110d44>
81131300:	01204574 	movhi	r4,33045
81131304:	2103ca04 	addi	r4,r4,3880
81131308:	d9002215 	stw	r4,136(sp)
8113130c:	003ead06 	br	81130dc4 <__reset+0xfb110dc4>
81131310:	58800104 	addi	r2,r11,4
81131314:	5f000017 	ldw	fp,0(r11)
81131318:	0013883a 	mov	r9,zero
8113131c:	803e610e 	bge	r16,zero,81130ca4 <__reset+0xfb110ca4>
81131320:	003fcb06 	br	81131250 <__reset+0xfb111250>
81131324:	58800104 	addi	r2,r11,4
81131328:	5f000017 	ldw	fp,0(r11)
8113132c:	0013883a 	mov	r9,zero
81131330:	803e420e 	bge	r16,zero,81130c3c <__reset+0xfb110c3c>
81131334:	003f7e06 	br	81131130 <__reset+0xfb111130>
81131338:	5f000017 	ldw	fp,0(r11)
8113133c:	5ac00104 	addi	r11,r11,4
81131340:	0013883a 	mov	r9,zero
81131344:	dac02315 	stw	r11,140(sp)
81131348:	003cce06 	br	81130684 <__reset+0xfb110684>
8113134c:	8809883a 	mov	r4,r17
81131350:	da002c15 	stw	r8,176(sp)
81131354:	11231840 	call	81123184 <strlen>
81131358:	d8802115 	stw	r2,132(sp)
8113135c:	da801d83 	ldbu	r10,118(sp)
81131360:	df002315 	stw	fp,140(sp)
81131364:	0021883a 	mov	r16,zero
81131368:	da002c17 	ldw	r8,176(sp)
8113136c:	003cf606 	br	81130748 <__reset+0xfb110748>
81131370:	00800184 	movi	r2,6
81131374:	1400012e 	bgeu	r2,r16,8113137c <___svfiprintf_internal_r+0x10ac>
81131378:	1021883a 	mov	r16,r2
8113137c:	dc002115 	stw	r16,132(sp)
81131380:	8005883a 	mov	r2,r16
81131384:	80003c16 	blt	r16,zero,81131478 <___svfiprintf_internal_r+0x11a8>
81131388:	04604574 	movhi	r17,33045
8113138c:	d8802015 	stw	r2,128(sp)
81131390:	df002315 	stw	fp,140(sp)
81131394:	8c434504 	addi	r17,r17,3348
81131398:	003d2e06 	br	81130854 <__reset+0xfb110854>
8113139c:	04001004 	movi	r16,64
811313a0:	800b883a 	mov	r5,r16
811313a4:	1121e7c0 	call	81121e7c <_malloc_r>
811313a8:	dac02717 	ldw	r11,156(sp)
811313ac:	58800015 	stw	r2,0(r11)
811313b0:	58800415 	stw	r2,16(r11)
811313b4:	10004826 	beq	r2,zero,811314d8 <___svfiprintf_internal_r+0x1208>
811313b8:	dac02717 	ldw	r11,156(sp)
811313bc:	5c000515 	stw	r16,20(r11)
811313c0:	003bd906 	br	81130328 <__reset+0xfb110328>
811313c4:	9080004c 	andi	r2,r18,1
811313c8:	0015883a 	mov	r10,zero
811313cc:	10000626 	beq	r2,zero,811313e8 <___svfiprintf_internal_r+0x1118>
811313d0:	dac02b17 	ldw	r11,172(sp)
811313d4:	00800c04 	movi	r2,48
811313d8:	d88019c5 	stb	r2,103(sp)
811313dc:	dac02115 	stw	r11,132(sp)
811313e0:	dc4019c4 	addi	r17,sp,103
811313e4:	003cd806 	br	81130748 <__reset+0xfb110748>
811313e8:	d8002115 	stw	zero,132(sp)
811313ec:	dc401a04 	addi	r17,sp,104
811313f0:	003cd506 	br	81130748 <__reset+0xfb110748>
811313f4:	01204574 	movhi	r4,33045
811313f8:	2103ce04 	addi	r4,r4,3896
811313fc:	d9002815 	stw	r4,160(sp)
81131400:	003d4306 	br	81130910 <__reset+0xfb110910>
81131404:	00bfffc4 	movi	r2,-1
81131408:	003ec606 	br	81130f24 <__reset+0xfb110f24>
8113140c:	00800044 	movi	r2,1
81131410:	10803fcc 	andi	r2,r2,255
81131414:	00c00044 	movi	r3,1
81131418:	10fd8026 	beq	r2,r3,81130a1c <__reset+0xfb110a1c>
8113141c:	00c00084 	movi	r3,2
81131420:	10fca426 	beq	r2,r3,811306b4 <__reset+0xfb1106b4>
81131424:	003ce806 	br	811307c8 <__reset+0xfb1107c8>
81131428:	01204574 	movhi	r4,33045
8113142c:	2103ce04 	addi	r4,r4,3896
81131430:	d9002815 	stw	r4,160(sp)
81131434:	003e9906 	br	81130e9c <__reset+0xfb110e9c>
81131438:	1025883a 	mov	r18,r2
8113143c:	0015883a 	mov	r10,zero
81131440:	00800084 	movi	r2,2
81131444:	003ff206 	br	81131410 <__reset+0xfb111410>
81131448:	01604574 	movhi	r5,33045
8113144c:	2943ca04 	addi	r5,r5,3880
81131450:	d9402215 	stw	r5,136(sp)
81131454:	003ee206 	br	81130fe0 <__reset+0xfb110fe0>
81131458:	5827883a 	mov	r19,r11
8113145c:	0021883a 	mov	r16,zero
81131460:	003bed06 	br	81130418 <__reset+0xfb110418>
81131464:	dc002115 	stw	r16,132(sp)
81131468:	da801d83 	ldbu	r10,118(sp)
8113146c:	df002315 	stw	fp,140(sp)
81131470:	0021883a 	mov	r16,zero
81131474:	003cb406 	br	81130748 <__reset+0xfb110748>
81131478:	0005883a 	mov	r2,zero
8113147c:	003fc206 	br	81131388 <__reset+0xfb111388>
81131480:	d8802317 	ldw	r2,140(sp)
81131484:	98c00043 	ldbu	r3,1(r19)
81131488:	5827883a 	mov	r19,r11
8113148c:	14000017 	ldw	r16,0(r2)
81131490:	10800104 	addi	r2,r2,4
81131494:	d8802315 	stw	r2,140(sp)
81131498:	803f760e 	bge	r16,zero,81131274 <__reset+0xfb111274>
8113149c:	18c03fcc 	andi	r3,r3,255
811314a0:	18c0201c 	xori	r3,r3,128
811314a4:	043fffc4 	movi	r16,-1
811314a8:	18ffe004 	addi	r3,r3,-128
811314ac:	003bd906 	br	81130414 <__reset+0xfb110414>
811314b0:	d9c01d85 	stb	r7,118(sp)
811314b4:	003cb606 	br	81130790 <__reset+0xfb110790>
811314b8:	d9c01d85 	stb	r7,118(sp)
811314bc:	003d2106 	br	81130944 <__reset+0xfb110944>
811314c0:	d9c01d85 	stb	r7,118(sp)
811314c4:	003d8e06 	br	81130b00 <__reset+0xfb110b00>
811314c8:	d9c01d85 	stb	r7,118(sp)
811314cc:	003db306 	br	81130b9c <__reset+0xfb110b9c>
811314d0:	d9c01d85 	stb	r7,118(sp)
811314d4:	003c8a06 	br	81130700 <__reset+0xfb110700>
811314d8:	dac02a17 	ldw	r11,168(sp)
811314dc:	00800304 	movi	r2,12
811314e0:	58800015 	stw	r2,0(r11)
811314e4:	00bfffc4 	movi	r2,-1
811314e8:	003e8e06 	br	81130f24 <__reset+0xfb110f24>
811314ec:	d9c01d85 	stb	r7,118(sp)
811314f0:	003dc706 	br	81130c10 <__reset+0xfb110c10>
811314f4:	d9c01d85 	stb	r7,118(sp)
811314f8:	003ddf06 	br	81130c78 <__reset+0xfb110c78>
811314fc:	d9c01d85 	stb	r7,118(sp)
81131500:	003d3706 	br	811309e0 <__reset+0xfb1109e0>
81131504:	d9c01d85 	stb	r7,118(sp)
81131508:	003c5406 	br	8113065c <__reset+0xfb11065c>
8113150c:	d9c01d85 	stb	r7,118(sp)
81131510:	003d1d06 	br	81130988 <__reset+0xfb110988>

81131514 <__submore>:
81131514:	defffa04 	addi	sp,sp,-24
81131518:	de00012e 	bgeu	sp,et,81131520 <__submore+0xc>
8113151c:	003b68fa 	trap	3
81131520:	dc000015 	stw	r16,0(sp)
81131524:	2821883a 	mov	r16,r5
81131528:	29400c17 	ldw	r5,48(r5)
8113152c:	dfc00515 	stw	ra,20(sp)
81131530:	dd000415 	stw	r20,16(sp)
81131534:	dcc00315 	stw	r19,12(sp)
81131538:	dc800215 	stw	r18,8(sp)
8113153c:	dc400115 	stw	r17,4(sp)
81131540:	80801004 	addi	r2,r16,64
81131544:	28801726 	beq	r5,r2,811315a4 <__submore+0x90>
81131548:	84400d17 	ldw	r17,52(r16)
8113154c:	8c67883a 	add	r19,r17,r17
81131550:	980d883a 	mov	r6,r19
81131554:	112dc880 	call	8112dc88 <_realloc_r>
81131558:	1025883a 	mov	r18,r2
8113155c:	10002226 	beq	r2,zero,811315e8 <__submore+0xd4>
81131560:	1469883a 	add	r20,r2,r17
81131564:	880d883a 	mov	r6,r17
81131568:	100b883a 	mov	r5,r2
8113156c:	a009883a 	mov	r4,r20
81131570:	11226900 	call	81122690 <memcpy>
81131574:	0005883a 	mov	r2,zero
81131578:	85000015 	stw	r20,0(r16)
8113157c:	84800c15 	stw	r18,48(r16)
81131580:	84c00d15 	stw	r19,52(r16)
81131584:	dfc00517 	ldw	ra,20(sp)
81131588:	dd000417 	ldw	r20,16(sp)
8113158c:	dcc00317 	ldw	r19,12(sp)
81131590:	dc800217 	ldw	r18,8(sp)
81131594:	dc400117 	ldw	r17,4(sp)
81131598:	dc000017 	ldw	r16,0(sp)
8113159c:	dec00604 	addi	sp,sp,24
811315a0:	f800283a 	ret
811315a4:	04410004 	movi	r17,1024
811315a8:	880b883a 	mov	r5,r17
811315ac:	1121e7c0 	call	81121e7c <_malloc_r>
811315b0:	1007883a 	mov	r3,r2
811315b4:	10000c26 	beq	r2,zero,811315e8 <__submore+0xd4>
811315b8:	80801083 	ldbu	r2,66(r16)
811315bc:	80c00c15 	stw	r3,48(r16)
811315c0:	84400d15 	stw	r17,52(r16)
811315c4:	1880ffc5 	stb	r2,1023(r3)
811315c8:	81401043 	ldbu	r5,65(r16)
811315cc:	1900ff44 	addi	r4,r3,1021
811315d0:	0005883a 	mov	r2,zero
811315d4:	1940ff85 	stb	r5,1022(r3)
811315d8:	81401003 	ldbu	r5,64(r16)
811315dc:	1940ff45 	stb	r5,1021(r3)
811315e0:	81000015 	stw	r4,0(r16)
811315e4:	003fe706 	br	81131584 <__reset+0xfb111584>
811315e8:	00bfffc4 	movi	r2,-1
811315ec:	003fe506 	br	81131584 <__reset+0xfb111584>

811315f0 <_ungetc_r>:
811315f0:	00bfffc4 	movi	r2,-1
811315f4:	28806326 	beq	r5,r2,81131784 <_ungetc_r+0x194>
811315f8:	defffb04 	addi	sp,sp,-20
811315fc:	de00012e 	bgeu	sp,et,81131604 <_ungetc_r+0x14>
81131600:	003b68fa 	trap	3
81131604:	dcc00315 	stw	r19,12(sp)
81131608:	dc400115 	stw	r17,4(sp)
8113160c:	dc000015 	stw	r16,0(sp)
81131610:	dfc00415 	stw	ra,16(sp)
81131614:	dc800215 	stw	r18,8(sp)
81131618:	2023883a 	mov	r17,r4
8113161c:	3021883a 	mov	r16,r6
81131620:	2827883a 	mov	r19,r5
81131624:	20000226 	beq	r4,zero,81131630 <_ungetc_r+0x40>
81131628:	20800e17 	ldw	r2,56(r4)
8113162c:	10002e26 	beq	r2,zero,811316e8 <_ungetc_r+0xf8>
81131630:	80c0030b 	ldhu	r3,12(r16)
81131634:	1888000c 	andi	r2,r3,8192
81131638:	1000051e 	bne	r2,zero,81131650 <_ungetc_r+0x60>
8113163c:	81001917 	ldw	r4,100(r16)
81131640:	00b7ffc4 	movi	r2,-8193
81131644:	18c80014 	ori	r3,r3,8192
81131648:	2084703a 	and	r2,r4,r2
8113164c:	80801915 	stw	r2,100(r16)
81131650:	00bff7c4 	movi	r2,-33
81131654:	1884703a 	and	r2,r3,r2
81131658:	8080030d 	sth	r2,12(r16)
8113165c:	1900010c 	andi	r4,r3,4
81131660:	2000061e 	bne	r4,zero,8113167c <_ungetc_r+0x8c>
81131664:	1900040c 	andi	r4,r3,16
81131668:	20001d26 	beq	r4,zero,811316e0 <_ungetc_r+0xf0>
8113166c:	18c0020c 	andi	r3,r3,8
81131670:	1800331e 	bne	r3,zero,81131740 <_ungetc_r+0x150>
81131674:	10800114 	ori	r2,r2,4
81131678:	8080030d 	sth	r2,12(r16)
8113167c:	80800c17 	ldw	r2,48(r16)
81131680:	9c803fcc 	andi	r18,r19,255
81131684:	10001a26 	beq	r2,zero,811316f0 <_ungetc_r+0x100>
81131688:	80c00117 	ldw	r3,4(r16)
8113168c:	80800d17 	ldw	r2,52(r16)
81131690:	18800f0e 	bge	r3,r2,811316d0 <_ungetc_r+0xe0>
81131694:	80c00017 	ldw	r3,0(r16)
81131698:	9005883a 	mov	r2,r18
8113169c:	193fffc4 	addi	r4,r3,-1
811316a0:	81000015 	stw	r4,0(r16)
811316a4:	1cffffc5 	stb	r19,-1(r3)
811316a8:	80c00117 	ldw	r3,4(r16)
811316ac:	18c00044 	addi	r3,r3,1
811316b0:	80c00115 	stw	r3,4(r16)
811316b4:	dfc00417 	ldw	ra,16(sp)
811316b8:	dcc00317 	ldw	r19,12(sp)
811316bc:	dc800217 	ldw	r18,8(sp)
811316c0:	dc400117 	ldw	r17,4(sp)
811316c4:	dc000017 	ldw	r16,0(sp)
811316c8:	dec00504 	addi	sp,sp,20
811316cc:	f800283a 	ret
811316d0:	800b883a 	mov	r5,r16
811316d4:	8809883a 	mov	r4,r17
811316d8:	11315140 	call	81131514 <__submore>
811316dc:	103fed26 	beq	r2,zero,81131694 <__reset+0xfb111694>
811316e0:	00bfffc4 	movi	r2,-1
811316e4:	003ff306 	br	811316b4 <__reset+0xfb1116b4>
811316e8:	112b75c0 	call	8112b75c <__sinit>
811316ec:	003fd006 	br	81131630 <__reset+0xfb111630>
811316f0:	80c00417 	ldw	r3,16(r16)
811316f4:	80800017 	ldw	r2,0(r16)
811316f8:	18000326 	beq	r3,zero,81131708 <_ungetc_r+0x118>
811316fc:	1880022e 	bgeu	r3,r2,81131708 <_ungetc_r+0x118>
81131700:	10ffffc3 	ldbu	r3,-1(r2)
81131704:	90c01826 	beq	r18,r3,81131768 <_ungetc_r+0x178>
81131708:	81400117 	ldw	r5,4(r16)
8113170c:	80800e15 	stw	r2,56(r16)
81131710:	008000c4 	movi	r2,3
81131714:	81001004 	addi	r4,r16,64
81131718:	80c01084 	addi	r3,r16,66
8113171c:	80800d15 	stw	r2,52(r16)
81131720:	00800044 	movi	r2,1
81131724:	80800115 	stw	r2,4(r16)
81131728:	81400f15 	stw	r5,60(r16)
8113172c:	81000c15 	stw	r4,48(r16)
81131730:	84c01085 	stb	r19,66(r16)
81131734:	80c00015 	stw	r3,0(r16)
81131738:	9005883a 	mov	r2,r18
8113173c:	003fdd06 	br	811316b4 <__reset+0xfb1116b4>
81131740:	800b883a 	mov	r5,r16
81131744:	8809883a 	mov	r4,r17
81131748:	112b3600 	call	8112b360 <_fflush_r>
8113174c:	103fe41e 	bne	r2,zero,811316e0 <__reset+0xfb1116e0>
81131750:	8080030b 	ldhu	r2,12(r16)
81131754:	00fffdc4 	movi	r3,-9
81131758:	80000215 	stw	zero,8(r16)
8113175c:	1884703a 	and	r2,r3,r2
81131760:	80000615 	stw	zero,24(r16)
81131764:	003fc306 	br	81131674 <__reset+0xfb111674>
81131768:	80c00117 	ldw	r3,4(r16)
8113176c:	10bfffc4 	addi	r2,r2,-1
81131770:	80800015 	stw	r2,0(r16)
81131774:	18800044 	addi	r2,r3,1
81131778:	80800115 	stw	r2,4(r16)
8113177c:	9005883a 	mov	r2,r18
81131780:	003fcc06 	br	811316b4 <__reset+0xfb1116b4>
81131784:	00bfffc4 	movi	r2,-1
81131788:	f800283a 	ret

8113178c <ungetc>:
8113178c:	00a04574 	movhi	r2,33045
81131790:	108d0f04 	addi	r2,r2,13372
81131794:	280d883a 	mov	r6,r5
81131798:	200b883a 	mov	r5,r4
8113179c:	11000017 	ldw	r4,0(r2)
811317a0:	11315f01 	jmpi	811315f0 <_ungetc_r>

811317a4 <__sprint_r.part.0>:
811317a4:	defff604 	addi	sp,sp,-40
811317a8:	de00012e 	bgeu	sp,et,811317b0 <__sprint_r.part.0+0xc>
811317ac:	003b68fa 	trap	3
811317b0:	28801917 	ldw	r2,100(r5)
811317b4:	dd400515 	stw	r21,20(sp)
811317b8:	dfc00915 	stw	ra,36(sp)
811317bc:	df000815 	stw	fp,32(sp)
811317c0:	ddc00715 	stw	r23,28(sp)
811317c4:	dd800615 	stw	r22,24(sp)
811317c8:	dd000415 	stw	r20,16(sp)
811317cc:	dcc00315 	stw	r19,12(sp)
811317d0:	dc800215 	stw	r18,8(sp)
811317d4:	dc400115 	stw	r17,4(sp)
811317d8:	dc000015 	stw	r16,0(sp)
811317dc:	1088000c 	andi	r2,r2,8192
811317e0:	302b883a 	mov	r21,r6
811317e4:	10002e26 	beq	r2,zero,811318a0 <__sprint_r.part.0+0xfc>
811317e8:	30800217 	ldw	r2,8(r6)
811317ec:	35800017 	ldw	r22,0(r6)
811317f0:	10002926 	beq	r2,zero,81131898 <__sprint_r.part.0+0xf4>
811317f4:	2827883a 	mov	r19,r5
811317f8:	2029883a 	mov	r20,r4
811317fc:	b5c00104 	addi	r23,r22,4
81131800:	04bfffc4 	movi	r18,-1
81131804:	bc400017 	ldw	r17,0(r23)
81131808:	b4000017 	ldw	r16,0(r22)
8113180c:	0039883a 	mov	fp,zero
81131810:	8822d0ba 	srli	r17,r17,2
81131814:	8800031e 	bne	r17,zero,81131824 <__sprint_r.part.0+0x80>
81131818:	00001806 	br	8113187c <__sprint_r.part.0+0xd8>
8113181c:	84000104 	addi	r16,r16,4
81131820:	8f001526 	beq	r17,fp,81131878 <__sprint_r.part.0+0xd4>
81131824:	81400017 	ldw	r5,0(r16)
81131828:	980d883a 	mov	r6,r19
8113182c:	a009883a 	mov	r4,r20
81131830:	11331480 	call	81133148 <_fputwc_r>
81131834:	e7000044 	addi	fp,fp,1
81131838:	14bff81e 	bne	r2,r18,8113181c <__reset+0xfb11181c>
8113183c:	9005883a 	mov	r2,r18
81131840:	a8000215 	stw	zero,8(r21)
81131844:	a8000115 	stw	zero,4(r21)
81131848:	dfc00917 	ldw	ra,36(sp)
8113184c:	df000817 	ldw	fp,32(sp)
81131850:	ddc00717 	ldw	r23,28(sp)
81131854:	dd800617 	ldw	r22,24(sp)
81131858:	dd400517 	ldw	r21,20(sp)
8113185c:	dd000417 	ldw	r20,16(sp)
81131860:	dcc00317 	ldw	r19,12(sp)
81131864:	dc800217 	ldw	r18,8(sp)
81131868:	dc400117 	ldw	r17,4(sp)
8113186c:	dc000017 	ldw	r16,0(sp)
81131870:	dec00a04 	addi	sp,sp,40
81131874:	f800283a 	ret
81131878:	a8800217 	ldw	r2,8(r21)
8113187c:	8c63883a 	add	r17,r17,r17
81131880:	8c63883a 	add	r17,r17,r17
81131884:	1445c83a 	sub	r2,r2,r17
81131888:	a8800215 	stw	r2,8(r21)
8113188c:	b5800204 	addi	r22,r22,8
81131890:	bdc00204 	addi	r23,r23,8
81131894:	103fdb1e 	bne	r2,zero,81131804 <__reset+0xfb111804>
81131898:	0005883a 	mov	r2,zero
8113189c:	003fe806 	br	81131840 <__reset+0xfb111840>
811318a0:	112bf0c0 	call	8112bf0c <__sfvwrite_r>
811318a4:	003fe606 	br	81131840 <__reset+0xfb111840>

811318a8 <__sprint_r>:
811318a8:	30c00217 	ldw	r3,8(r6)
811318ac:	18000126 	beq	r3,zero,811318b4 <__sprint_r+0xc>
811318b0:	11317a41 	jmpi	811317a4 <__sprint_r.part.0>
811318b4:	30000115 	stw	zero,4(r6)
811318b8:	0005883a 	mov	r2,zero
811318bc:	f800283a 	ret

811318c0 <___vfiprintf_internal_r>:
811318c0:	deffc904 	addi	sp,sp,-220
811318c4:	de00012e 	bgeu	sp,et,811318cc <___vfiprintf_internal_r+0xc>
811318c8:	003b68fa 	trap	3
811318cc:	df003515 	stw	fp,212(sp)
811318d0:	dd003115 	stw	r20,196(sp)
811318d4:	dfc03615 	stw	ra,216(sp)
811318d8:	ddc03415 	stw	r23,208(sp)
811318dc:	dd803315 	stw	r22,204(sp)
811318e0:	dd403215 	stw	r21,200(sp)
811318e4:	dcc03015 	stw	r19,192(sp)
811318e8:	dc802f15 	stw	r18,188(sp)
811318ec:	dc402e15 	stw	r17,184(sp)
811318f0:	dc002d15 	stw	r16,180(sp)
811318f4:	d9002015 	stw	r4,128(sp)
811318f8:	d9c02215 	stw	r7,136(sp)
811318fc:	2829883a 	mov	r20,r5
81131900:	3039883a 	mov	fp,r6
81131904:	20000226 	beq	r4,zero,81131910 <___vfiprintf_internal_r+0x50>
81131908:	20800e17 	ldw	r2,56(r4)
8113190c:	1000cf26 	beq	r2,zero,81131c4c <___vfiprintf_internal_r+0x38c>
81131910:	a080030b 	ldhu	r2,12(r20)
81131914:	10c8000c 	andi	r3,r2,8192
81131918:	1800061e 	bne	r3,zero,81131934 <___vfiprintf_internal_r+0x74>
8113191c:	a1001917 	ldw	r4,100(r20)
81131920:	00f7ffc4 	movi	r3,-8193
81131924:	10880014 	ori	r2,r2,8192
81131928:	20c6703a 	and	r3,r4,r3
8113192c:	a080030d 	sth	r2,12(r20)
81131930:	a0c01915 	stw	r3,100(r20)
81131934:	10c0020c 	andi	r3,r2,8
81131938:	1800a926 	beq	r3,zero,81131be0 <___vfiprintf_internal_r+0x320>
8113193c:	a0c00417 	ldw	r3,16(r20)
81131940:	1800a726 	beq	r3,zero,81131be0 <___vfiprintf_internal_r+0x320>
81131944:	1080068c 	andi	r2,r2,26
81131948:	00c00284 	movi	r3,10
8113194c:	10c0ac26 	beq	r2,r3,81131c00 <___vfiprintf_internal_r+0x340>
81131950:	da801a04 	addi	r10,sp,104
81131954:	da801e15 	stw	r10,120(sp)
81131958:	d8801e17 	ldw	r2,120(sp)
8113195c:	da8019c4 	addi	r10,sp,103
81131960:	05a04574 	movhi	r22,33045
81131964:	05e04574 	movhi	r23,33045
81131968:	da801f15 	stw	r10,124(sp)
8113196c:	1295c83a 	sub	r10,r2,r10
81131970:	b583d604 	addi	r22,r22,3928
81131974:	bdc3d204 	addi	r23,r23,3912
81131978:	dec01a15 	stw	sp,104(sp)
8113197c:	d8001c15 	stw	zero,112(sp)
81131980:	d8001b15 	stw	zero,108(sp)
81131984:	d8002615 	stw	zero,152(sp)
81131988:	d8002315 	stw	zero,140(sp)
8113198c:	da802715 	stw	r10,156(sp)
81131990:	d811883a 	mov	r8,sp
81131994:	dd002115 	stw	r20,132(sp)
81131998:	e021883a 	mov	r16,fp
8113199c:	80800007 	ldb	r2,0(r16)
811319a0:	1003ea26 	beq	r2,zero,8113294c <___vfiprintf_internal_r+0x108c>
811319a4:	00c00944 	movi	r3,37
811319a8:	8025883a 	mov	r18,r16
811319ac:	10c0021e 	bne	r2,r3,811319b8 <___vfiprintf_internal_r+0xf8>
811319b0:	00001606 	br	81131a0c <___vfiprintf_internal_r+0x14c>
811319b4:	10c00326 	beq	r2,r3,811319c4 <___vfiprintf_internal_r+0x104>
811319b8:	94800044 	addi	r18,r18,1
811319bc:	90800007 	ldb	r2,0(r18)
811319c0:	103ffc1e 	bne	r2,zero,811319b4 <__reset+0xfb1119b4>
811319c4:	9423c83a 	sub	r17,r18,r16
811319c8:	88001026 	beq	r17,zero,81131a0c <___vfiprintf_internal_r+0x14c>
811319cc:	d8c01c17 	ldw	r3,112(sp)
811319d0:	d8801b17 	ldw	r2,108(sp)
811319d4:	44000015 	stw	r16,0(r8)
811319d8:	88c7883a 	add	r3,r17,r3
811319dc:	10800044 	addi	r2,r2,1
811319e0:	44400115 	stw	r17,4(r8)
811319e4:	d8c01c15 	stw	r3,112(sp)
811319e8:	d8801b15 	stw	r2,108(sp)
811319ec:	010001c4 	movi	r4,7
811319f0:	2080760e 	bge	r4,r2,81131bcc <___vfiprintf_internal_r+0x30c>
811319f4:	1803821e 	bne	r3,zero,81132800 <___vfiprintf_internal_r+0xf40>
811319f8:	da802317 	ldw	r10,140(sp)
811319fc:	d8001b15 	stw	zero,108(sp)
81131a00:	d811883a 	mov	r8,sp
81131a04:	5455883a 	add	r10,r10,r17
81131a08:	da802315 	stw	r10,140(sp)
81131a0c:	90800007 	ldb	r2,0(r18)
81131a10:	10044626 	beq	r2,zero,81132b2c <___vfiprintf_internal_r+0x126c>
81131a14:	90c00047 	ldb	r3,1(r18)
81131a18:	94000044 	addi	r16,r18,1
81131a1c:	d8001d85 	stb	zero,118(sp)
81131a20:	0009883a 	mov	r4,zero
81131a24:	000f883a 	mov	r7,zero
81131a28:	027fffc4 	movi	r9,-1
81131a2c:	0023883a 	mov	r17,zero
81131a30:	0029883a 	mov	r20,zero
81131a34:	01401604 	movi	r5,88
81131a38:	01800244 	movi	r6,9
81131a3c:	03400a84 	movi	r13,42
81131a40:	03001b04 	movi	r12,108
81131a44:	84000044 	addi	r16,r16,1
81131a48:	18bff804 	addi	r2,r3,-32
81131a4c:	28827336 	bltu	r5,r2,8113241c <___vfiprintf_internal_r+0xb5c>
81131a50:	100490ba 	slli	r2,r2,2
81131a54:	02a044f4 	movhi	r10,33043
81131a58:	52869a04 	addi	r10,r10,6760
81131a5c:	1285883a 	add	r2,r2,r10
81131a60:	10800017 	ldw	r2,0(r2)
81131a64:	1000683a 	jmp	r2
81131a68:	81132150 	cmplti	r4,r16,19589
81131a6c:	8113241c 	xori	r4,r16,19600
81131a70:	8113241c 	xori	r4,r16,19600
81131a74:	81132170 	cmpltui	r4,r16,19589
81131a78:	8113241c 	xori	r4,r16,19600
81131a7c:	8113241c 	xori	r4,r16,19600
81131a80:	8113241c 	xori	r4,r16,19600
81131a84:	8113241c 	xori	r4,r16,19600
81131a88:	8113241c 	xori	r4,r16,19600
81131a8c:	8113241c 	xori	r4,r16,19600
81131a90:	81132358 	cmpnei	r4,r16,19597
81131a94:	81132374 	orhi	r4,r16,19597
81131a98:	8113241c 	xori	r4,r16,19600
81131a9c:	81131c5c 	xori	r4,r16,19569
81131aa0:	81132384 	addi	r4,r16,19598
81131aa4:	8113241c 	xori	r4,r16,19600
81131aa8:	8113217c 	xorhi	r4,r16,19589
81131aac:	81132188 	cmpgei	r4,r16,19590
81131ab0:	81132188 	cmpgei	r4,r16,19590
81131ab4:	81132188 	cmpgei	r4,r16,19590
81131ab8:	81132188 	cmpgei	r4,r16,19590
81131abc:	81132188 	cmpgei	r4,r16,19590
81131ac0:	81132188 	cmpgei	r4,r16,19590
81131ac4:	81132188 	cmpgei	r4,r16,19590
81131ac8:	81132188 	cmpgei	r4,r16,19590
81131acc:	81132188 	cmpgei	r4,r16,19590
81131ad0:	8113241c 	xori	r4,r16,19600
81131ad4:	8113241c 	xori	r4,r16,19600
81131ad8:	8113241c 	xori	r4,r16,19600
81131adc:	8113241c 	xori	r4,r16,19600
81131ae0:	8113241c 	xori	r4,r16,19600
81131ae4:	8113241c 	xori	r4,r16,19600
81131ae8:	8113241c 	xori	r4,r16,19600
81131aec:	8113241c 	xori	r4,r16,19600
81131af0:	8113241c 	xori	r4,r16,19600
81131af4:	8113241c 	xori	r4,r16,19600
81131af8:	811321b4 	orhi	r4,r16,19590
81131afc:	8113241c 	xori	r4,r16,19600
81131b00:	8113241c 	xori	r4,r16,19600
81131b04:	8113241c 	xori	r4,r16,19600
81131b08:	8113241c 	xori	r4,r16,19600
81131b0c:	8113241c 	xori	r4,r16,19600
81131b10:	8113241c 	xori	r4,r16,19600
81131b14:	8113241c 	xori	r4,r16,19600
81131b18:	8113241c 	xori	r4,r16,19600
81131b1c:	8113241c 	xori	r4,r16,19600
81131b20:	8113241c 	xori	r4,r16,19600
81131b24:	811321ec 	andhi	r4,r16,19591
81131b28:	8113241c 	xori	r4,r16,19600
81131b2c:	8113241c 	xori	r4,r16,19600
81131b30:	8113241c 	xori	r4,r16,19600
81131b34:	8113241c 	xori	r4,r16,19600
81131b38:	8113241c 	xori	r4,r16,19600
81131b3c:	81132244 	addi	r4,r16,19593
81131b40:	8113241c 	xori	r4,r16,19600
81131b44:	8113241c 	xori	r4,r16,19600
81131b48:	811322b4 	orhi	r4,r16,19594
81131b4c:	8113241c 	xori	r4,r16,19600
81131b50:	8113241c 	xori	r4,r16,19600
81131b54:	8113241c 	xori	r4,r16,19600
81131b58:	8113241c 	xori	r4,r16,19600
81131b5c:	8113241c 	xori	r4,r16,19600
81131b60:	8113241c 	xori	r4,r16,19600
81131b64:	8113241c 	xori	r4,r16,19600
81131b68:	8113241c 	xori	r4,r16,19600
81131b6c:	8113241c 	xori	r4,r16,19600
81131b70:	8113241c 	xori	r4,r16,19600
81131b74:	81132060 	cmpeqi	r4,r16,19585
81131b78:	8113208c 	andi	r4,r16,19586
81131b7c:	8113241c 	xori	r4,r16,19600
81131b80:	8113241c 	xori	r4,r16,19600
81131b84:	8113241c 	xori	r4,r16,19600
81131b88:	811323c4 	addi	r4,r16,19599
81131b8c:	8113208c 	andi	r4,r16,19586
81131b90:	8113241c 	xori	r4,r16,19600
81131b94:	8113241c 	xori	r4,r16,19600
81131b98:	81131f20 	cmpeqi	r4,r16,19580
81131b9c:	8113241c 	xori	r4,r16,19600
81131ba0:	81131f30 	cmpltui	r4,r16,19580
81131ba4:	81131f6c 	andhi	r4,r16,19581
81131ba8:	81131c68 	cmpgeui	r4,r16,19569
81131bac:	81131f14 	ori	r4,r16,19580
81131bb0:	8113241c 	xori	r4,r16,19600
81131bb4:	811322f0 	cmpltui	r4,r16,19595
81131bb8:	8113241c 	xori	r4,r16,19600
81131bbc:	81132348 	cmpgei	r4,r16,19597
81131bc0:	8113241c 	xori	r4,r16,19600
81131bc4:	8113241c 	xori	r4,r16,19600
81131bc8:	8113200c 	andi	r4,r16,19584
81131bcc:	42000204 	addi	r8,r8,8
81131bd0:	da802317 	ldw	r10,140(sp)
81131bd4:	5455883a 	add	r10,r10,r17
81131bd8:	da802315 	stw	r10,140(sp)
81131bdc:	003f8b06 	br	81131a0c <__reset+0xfb111a0c>
81131be0:	d9002017 	ldw	r4,128(sp)
81131be4:	a00b883a 	mov	r5,r20
81131be8:	11296ec0 	call	811296ec <__swsetup_r>
81131bec:	1003b11e 	bne	r2,zero,81132ab4 <___vfiprintf_internal_r+0x11f4>
81131bf0:	a080030b 	ldhu	r2,12(r20)
81131bf4:	00c00284 	movi	r3,10
81131bf8:	1080068c 	andi	r2,r2,26
81131bfc:	10ff541e 	bne	r2,r3,81131950 <__reset+0xfb111950>
81131c00:	a080038f 	ldh	r2,14(r20)
81131c04:	103f5216 	blt	r2,zero,81131950 <__reset+0xfb111950>
81131c08:	d9c02217 	ldw	r7,136(sp)
81131c0c:	d9002017 	ldw	r4,128(sp)
81131c10:	e00d883a 	mov	r6,fp
81131c14:	a00b883a 	mov	r5,r20
81131c18:	1132d400 	call	81132d40 <__sbprintf>
81131c1c:	dfc03617 	ldw	ra,216(sp)
81131c20:	df003517 	ldw	fp,212(sp)
81131c24:	ddc03417 	ldw	r23,208(sp)
81131c28:	dd803317 	ldw	r22,204(sp)
81131c2c:	dd403217 	ldw	r21,200(sp)
81131c30:	dd003117 	ldw	r20,196(sp)
81131c34:	dcc03017 	ldw	r19,192(sp)
81131c38:	dc802f17 	ldw	r18,188(sp)
81131c3c:	dc402e17 	ldw	r17,184(sp)
81131c40:	dc002d17 	ldw	r16,180(sp)
81131c44:	dec03704 	addi	sp,sp,220
81131c48:	f800283a 	ret
81131c4c:	112b75c0 	call	8112b75c <__sinit>
81131c50:	003f2f06 	br	81131910 <__reset+0xfb111910>
81131c54:	0463c83a 	sub	r17,zero,r17
81131c58:	d8802215 	stw	r2,136(sp)
81131c5c:	a5000114 	ori	r20,r20,4
81131c60:	80c00007 	ldb	r3,0(r16)
81131c64:	003f7706 	br	81131a44 <__reset+0xfb111a44>
81131c68:	00800c04 	movi	r2,48
81131c6c:	da802217 	ldw	r10,136(sp)
81131c70:	d8801d05 	stb	r2,116(sp)
81131c74:	00801e04 	movi	r2,120
81131c78:	d8801d45 	stb	r2,117(sp)
81131c7c:	d8001d85 	stb	zero,118(sp)
81131c80:	50c00104 	addi	r3,r10,4
81131c84:	54800017 	ldw	r18,0(r10)
81131c88:	0027883a 	mov	r19,zero
81131c8c:	a0800094 	ori	r2,r20,2
81131c90:	48030b16 	blt	r9,zero,811328c0 <___vfiprintf_internal_r+0x1000>
81131c94:	00bfdfc4 	movi	r2,-129
81131c98:	a096703a 	and	r11,r20,r2
81131c9c:	d8c02215 	stw	r3,136(sp)
81131ca0:	5d000094 	ori	r20,r11,2
81131ca4:	90032b1e 	bne	r18,zero,81132954 <___vfiprintf_internal_r+0x1094>
81131ca8:	00a04574 	movhi	r2,33045
81131cac:	10834004 	addi	r2,r2,3328
81131cb0:	d8802615 	stw	r2,152(sp)
81131cb4:	0039883a 	mov	fp,zero
81131cb8:	48017b1e 	bne	r9,zero,811322a8 <___vfiprintf_internal_r+0x9e8>
81131cbc:	0013883a 	mov	r9,zero
81131cc0:	0027883a 	mov	r19,zero
81131cc4:	dd401a04 	addi	r21,sp,104
81131cc8:	4825883a 	mov	r18,r9
81131ccc:	4cc0010e 	bge	r9,r19,81131cd4 <___vfiprintf_internal_r+0x414>
81131cd0:	9825883a 	mov	r18,r19
81131cd4:	e7003fcc 	andi	fp,fp,255
81131cd8:	e700201c 	xori	fp,fp,128
81131cdc:	e73fe004 	addi	fp,fp,-128
81131ce0:	e0000126 	beq	fp,zero,81131ce8 <___vfiprintf_internal_r+0x428>
81131ce4:	94800044 	addi	r18,r18,1
81131ce8:	a380008c 	andi	r14,r20,2
81131cec:	70000126 	beq	r14,zero,81131cf4 <___vfiprintf_internal_r+0x434>
81131cf0:	94800084 	addi	r18,r18,2
81131cf4:	a700210c 	andi	fp,r20,132
81131cf8:	e001df1e 	bne	fp,zero,81132478 <___vfiprintf_internal_r+0xbb8>
81131cfc:	8c87c83a 	sub	r3,r17,r18
81131d00:	00c1dd0e 	bge	zero,r3,81132478 <___vfiprintf_internal_r+0xbb8>
81131d04:	01c00404 	movi	r7,16
81131d08:	d8801c17 	ldw	r2,112(sp)
81131d0c:	38c3ad0e 	bge	r7,r3,81132bc4 <___vfiprintf_internal_r+0x1304>
81131d10:	02a04574 	movhi	r10,33045
81131d14:	5283d604 	addi	r10,r10,3928
81131d18:	dc002915 	stw	r16,164(sp)
81131d1c:	d9801b17 	ldw	r6,108(sp)
81131d20:	da802415 	stw	r10,144(sp)
81131d24:	03c001c4 	movi	r15,7
81131d28:	da402515 	stw	r9,148(sp)
81131d2c:	db802815 	stw	r14,160(sp)
81131d30:	1821883a 	mov	r16,r3
81131d34:	00000506 	br	81131d4c <___vfiprintf_internal_r+0x48c>
81131d38:	31400084 	addi	r5,r6,2
81131d3c:	42000204 	addi	r8,r8,8
81131d40:	200d883a 	mov	r6,r4
81131d44:	843ffc04 	addi	r16,r16,-16
81131d48:	3c000d0e 	bge	r7,r16,81131d80 <___vfiprintf_internal_r+0x4c0>
81131d4c:	10800404 	addi	r2,r2,16
81131d50:	31000044 	addi	r4,r6,1
81131d54:	45800015 	stw	r22,0(r8)
81131d58:	41c00115 	stw	r7,4(r8)
81131d5c:	d8801c15 	stw	r2,112(sp)
81131d60:	d9001b15 	stw	r4,108(sp)
81131d64:	793ff40e 	bge	r15,r4,81131d38 <__reset+0xfb111d38>
81131d68:	1001b51e 	bne	r2,zero,81132440 <___vfiprintf_internal_r+0xb80>
81131d6c:	843ffc04 	addi	r16,r16,-16
81131d70:	000d883a 	mov	r6,zero
81131d74:	01400044 	movi	r5,1
81131d78:	d811883a 	mov	r8,sp
81131d7c:	3c3ff316 	blt	r7,r16,81131d4c <__reset+0xfb111d4c>
81131d80:	8007883a 	mov	r3,r16
81131d84:	da402517 	ldw	r9,148(sp)
81131d88:	db802817 	ldw	r14,160(sp)
81131d8c:	dc002917 	ldw	r16,164(sp)
81131d90:	da802417 	ldw	r10,144(sp)
81131d94:	1885883a 	add	r2,r3,r2
81131d98:	40c00115 	stw	r3,4(r8)
81131d9c:	42800015 	stw	r10,0(r8)
81131da0:	d8801c15 	stw	r2,112(sp)
81131da4:	d9401b15 	stw	r5,108(sp)
81131da8:	00c001c4 	movi	r3,7
81131dac:	19426016 	blt	r3,r5,81132730 <___vfiprintf_internal_r+0xe70>
81131db0:	d8c01d87 	ldb	r3,118(sp)
81131db4:	42000204 	addi	r8,r8,8
81131db8:	29000044 	addi	r4,r5,1
81131dbc:	1801b31e 	bne	r3,zero,8113248c <___vfiprintf_internal_r+0xbcc>
81131dc0:	7001c026 	beq	r14,zero,811324c4 <___vfiprintf_internal_r+0xc04>
81131dc4:	d8c01d04 	addi	r3,sp,116
81131dc8:	10800084 	addi	r2,r2,2
81131dcc:	40c00015 	stw	r3,0(r8)
81131dd0:	00c00084 	movi	r3,2
81131dd4:	40c00115 	stw	r3,4(r8)
81131dd8:	d8801c15 	stw	r2,112(sp)
81131ddc:	d9001b15 	stw	r4,108(sp)
81131de0:	00c001c4 	movi	r3,7
81131de4:	1902650e 	bge	r3,r4,8113277c <___vfiprintf_internal_r+0xebc>
81131de8:	10029a1e 	bne	r2,zero,81132854 <___vfiprintf_internal_r+0xf94>
81131dec:	00c02004 	movi	r3,128
81131df0:	01000044 	movi	r4,1
81131df4:	000b883a 	mov	r5,zero
81131df8:	d811883a 	mov	r8,sp
81131dfc:	e0c1b31e 	bne	fp,r3,811324cc <___vfiprintf_internal_r+0xc0c>
81131e00:	8cb9c83a 	sub	fp,r17,r18
81131e04:	0701b10e 	bge	zero,fp,811324cc <___vfiprintf_internal_r+0xc0c>
81131e08:	01c00404 	movi	r7,16
81131e0c:	3f03890e 	bge	r7,fp,81132c34 <___vfiprintf_internal_r+0x1374>
81131e10:	00e04574 	movhi	r3,33045
81131e14:	18c3d204 	addi	r3,r3,3912
81131e18:	d8c02415 	stw	r3,144(sp)
81131e1c:	8007883a 	mov	r3,r16
81131e20:	034001c4 	movi	r13,7
81131e24:	e021883a 	mov	r16,fp
81131e28:	da402515 	stw	r9,148(sp)
81131e2c:	1839883a 	mov	fp,r3
81131e30:	00000506 	br	81131e48 <___vfiprintf_internal_r+0x588>
81131e34:	29800084 	addi	r6,r5,2
81131e38:	42000204 	addi	r8,r8,8
81131e3c:	180b883a 	mov	r5,r3
81131e40:	843ffc04 	addi	r16,r16,-16
81131e44:	3c000d0e 	bge	r7,r16,81131e7c <___vfiprintf_internal_r+0x5bc>
81131e48:	10800404 	addi	r2,r2,16
81131e4c:	28c00044 	addi	r3,r5,1
81131e50:	45c00015 	stw	r23,0(r8)
81131e54:	41c00115 	stw	r7,4(r8)
81131e58:	d8801c15 	stw	r2,112(sp)
81131e5c:	d8c01b15 	stw	r3,108(sp)
81131e60:	68fff40e 	bge	r13,r3,81131e34 <__reset+0xfb111e34>
81131e64:	1002241e 	bne	r2,zero,811326f8 <___vfiprintf_internal_r+0xe38>
81131e68:	843ffc04 	addi	r16,r16,-16
81131e6c:	01800044 	movi	r6,1
81131e70:	000b883a 	mov	r5,zero
81131e74:	d811883a 	mov	r8,sp
81131e78:	3c3ff316 	blt	r7,r16,81131e48 <__reset+0xfb111e48>
81131e7c:	da402517 	ldw	r9,148(sp)
81131e80:	e007883a 	mov	r3,fp
81131e84:	8039883a 	mov	fp,r16
81131e88:	1821883a 	mov	r16,r3
81131e8c:	d8c02417 	ldw	r3,144(sp)
81131e90:	1705883a 	add	r2,r2,fp
81131e94:	47000115 	stw	fp,4(r8)
81131e98:	40c00015 	stw	r3,0(r8)
81131e9c:	d8801c15 	stw	r2,112(sp)
81131ea0:	d9801b15 	stw	r6,108(sp)
81131ea4:	00c001c4 	movi	r3,7
81131ea8:	19827616 	blt	r3,r6,81132884 <___vfiprintf_internal_r+0xfc4>
81131eac:	4cf9c83a 	sub	fp,r9,r19
81131eb0:	42000204 	addi	r8,r8,8
81131eb4:	31000044 	addi	r4,r6,1
81131eb8:	300b883a 	mov	r5,r6
81131ebc:	07018516 	blt	zero,fp,811324d4 <___vfiprintf_internal_r+0xc14>
81131ec0:	9885883a 	add	r2,r19,r2
81131ec4:	45400015 	stw	r21,0(r8)
81131ec8:	44c00115 	stw	r19,4(r8)
81131ecc:	d8801c15 	stw	r2,112(sp)
81131ed0:	d9001b15 	stw	r4,108(sp)
81131ed4:	00c001c4 	movi	r3,7
81131ed8:	1901dd0e 	bge	r3,r4,81132650 <___vfiprintf_internal_r+0xd90>
81131edc:	1002401e 	bne	r2,zero,811327e0 <___vfiprintf_internal_r+0xf20>
81131ee0:	d8001b15 	stw	zero,108(sp)
81131ee4:	a2c0010c 	andi	r11,r20,4
81131ee8:	58000226 	beq	r11,zero,81131ef4 <___vfiprintf_internal_r+0x634>
81131eec:	8ca7c83a 	sub	r19,r17,r18
81131ef0:	04c2f216 	blt	zero,r19,81132abc <___vfiprintf_internal_r+0x11fc>
81131ef4:	8c80010e 	bge	r17,r18,81131efc <___vfiprintf_internal_r+0x63c>
81131ef8:	9023883a 	mov	r17,r18
81131efc:	da802317 	ldw	r10,140(sp)
81131f00:	5455883a 	add	r10,r10,r17
81131f04:	da802315 	stw	r10,140(sp)
81131f08:	d8001b15 	stw	zero,108(sp)
81131f0c:	d811883a 	mov	r8,sp
81131f10:	003ea206 	br	8113199c <__reset+0xfb11199c>
81131f14:	a5000814 	ori	r20,r20,32
81131f18:	80c00007 	ldb	r3,0(r16)
81131f1c:	003ec906 	br	81131a44 <__reset+0xfb111a44>
81131f20:	80c00007 	ldb	r3,0(r16)
81131f24:	1b030926 	beq	r3,r12,81132b4c <___vfiprintf_internal_r+0x128c>
81131f28:	a5000414 	ori	r20,r20,16
81131f2c:	003ec506 	br	81131a44 <__reset+0xfb111a44>
81131f30:	21003fcc 	andi	r4,r4,255
81131f34:	20035e1e 	bne	r4,zero,81132cb0 <___vfiprintf_internal_r+0x13f0>
81131f38:	a080080c 	andi	r2,r20,32
81131f3c:	1002a526 	beq	r2,zero,811329d4 <___vfiprintf_internal_r+0x1114>
81131f40:	da802217 	ldw	r10,136(sp)
81131f44:	50800017 	ldw	r2,0(r10)
81131f48:	da802317 	ldw	r10,140(sp)
81131f4c:	5007d7fa 	srai	r3,r10,31
81131f50:	da802217 	ldw	r10,136(sp)
81131f54:	10c00115 	stw	r3,4(r2)
81131f58:	52800104 	addi	r10,r10,4
81131f5c:	da802215 	stw	r10,136(sp)
81131f60:	da802317 	ldw	r10,140(sp)
81131f64:	12800015 	stw	r10,0(r2)
81131f68:	003e8c06 	br	8113199c <__reset+0xfb11199c>
81131f6c:	21003fcc 	andi	r4,r4,255
81131f70:	2003511e 	bne	r4,zero,81132cb8 <___vfiprintf_internal_r+0x13f8>
81131f74:	a080080c 	andi	r2,r20,32
81131f78:	1000a126 	beq	r2,zero,81132200 <___vfiprintf_internal_r+0x940>
81131f7c:	da802217 	ldw	r10,136(sp)
81131f80:	d8001d85 	stb	zero,118(sp)
81131f84:	50800204 	addi	r2,r10,8
81131f88:	54800017 	ldw	r18,0(r10)
81131f8c:	54c00117 	ldw	r19,4(r10)
81131f90:	4802b416 	blt	r9,zero,81132a64 <___vfiprintf_internal_r+0x11a4>
81131f94:	013fdfc4 	movi	r4,-129
81131f98:	94c6b03a 	or	r3,r18,r19
81131f9c:	d8802215 	stw	r2,136(sp)
81131fa0:	a128703a 	and	r20,r20,r4
81131fa4:	1800a226 	beq	r3,zero,81132230 <___vfiprintf_internal_r+0x970>
81131fa8:	0039883a 	mov	fp,zero
81131fac:	dd401a04 	addi	r21,sp,104
81131fb0:	9006d0fa 	srli	r3,r18,3
81131fb4:	9808977a 	slli	r4,r19,29
81131fb8:	9826d0fa 	srli	r19,r19,3
81131fbc:	948001cc 	andi	r18,r18,7
81131fc0:	90800c04 	addi	r2,r18,48
81131fc4:	ad7fffc4 	addi	r21,r21,-1
81131fc8:	20e4b03a 	or	r18,r4,r3
81131fcc:	a8800005 	stb	r2,0(r21)
81131fd0:	94c6b03a 	or	r3,r18,r19
81131fd4:	183ff61e 	bne	r3,zero,81131fb0 <__reset+0xfb111fb0>
81131fd8:	a0c0004c 	andi	r3,r20,1
81131fdc:	18005926 	beq	r3,zero,81132144 <___vfiprintf_internal_r+0x884>
81131fe0:	10803fcc 	andi	r2,r2,255
81131fe4:	1080201c 	xori	r2,r2,128
81131fe8:	10bfe004 	addi	r2,r2,-128
81131fec:	00c00c04 	movi	r3,48
81131ff0:	10c05426 	beq	r2,r3,81132144 <___vfiprintf_internal_r+0x884>
81131ff4:	da801e17 	ldw	r10,120(sp)
81131ff8:	a8bfffc4 	addi	r2,r21,-1
81131ffc:	a8ffffc5 	stb	r3,-1(r21)
81132000:	50a7c83a 	sub	r19,r10,r2
81132004:	102b883a 	mov	r21,r2
81132008:	003f2f06 	br	81131cc8 <__reset+0xfb111cc8>
8113200c:	21003fcc 	andi	r4,r4,255
81132010:	2003421e 	bne	r4,zero,81132d1c <___vfiprintf_internal_r+0x145c>
81132014:	00a04574 	movhi	r2,33045
81132018:	10834004 	addi	r2,r2,3328
8113201c:	d8802615 	stw	r2,152(sp)
81132020:	a080080c 	andi	r2,r20,32
81132024:	1000aa26 	beq	r2,zero,811322d0 <___vfiprintf_internal_r+0xa10>
81132028:	da802217 	ldw	r10,136(sp)
8113202c:	54800017 	ldw	r18,0(r10)
81132030:	54c00117 	ldw	r19,4(r10)
81132034:	52800204 	addi	r10,r10,8
81132038:	da802215 	stw	r10,136(sp)
8113203c:	a080004c 	andi	r2,r20,1
81132040:	1001d226 	beq	r2,zero,8113278c <___vfiprintf_internal_r+0xecc>
81132044:	94c4b03a 	or	r2,r18,r19
81132048:	1002351e 	bne	r2,zero,81132920 <___vfiprintf_internal_r+0x1060>
8113204c:	d8001d85 	stb	zero,118(sp)
81132050:	48022216 	blt	r9,zero,811328dc <___vfiprintf_internal_r+0x101c>
81132054:	00bfdfc4 	movi	r2,-129
81132058:	a0a8703a 	and	r20,r20,r2
8113205c:	003f1506 	br	81131cb4 <__reset+0xfb111cb4>
81132060:	da802217 	ldw	r10,136(sp)
81132064:	04800044 	movi	r18,1
81132068:	d8001d85 	stb	zero,118(sp)
8113206c:	50800017 	ldw	r2,0(r10)
81132070:	52800104 	addi	r10,r10,4
81132074:	da802215 	stw	r10,136(sp)
81132078:	d8801005 	stb	r2,64(sp)
8113207c:	9027883a 	mov	r19,r18
81132080:	dd401004 	addi	r21,sp,64
81132084:	0013883a 	mov	r9,zero
81132088:	003f1706 	br	81131ce8 <__reset+0xfb111ce8>
8113208c:	21003fcc 	andi	r4,r4,255
81132090:	2003201e 	bne	r4,zero,81132d14 <___vfiprintf_internal_r+0x1454>
81132094:	a080080c 	andi	r2,r20,32
81132098:	10004b26 	beq	r2,zero,811321c8 <___vfiprintf_internal_r+0x908>
8113209c:	da802217 	ldw	r10,136(sp)
811320a0:	50800117 	ldw	r2,4(r10)
811320a4:	54800017 	ldw	r18,0(r10)
811320a8:	52800204 	addi	r10,r10,8
811320ac:	da802215 	stw	r10,136(sp)
811320b0:	1027883a 	mov	r19,r2
811320b4:	10022c16 	blt	r2,zero,81132968 <___vfiprintf_internal_r+0x10a8>
811320b8:	df001d83 	ldbu	fp,118(sp)
811320bc:	48007216 	blt	r9,zero,81132288 <___vfiprintf_internal_r+0x9c8>
811320c0:	00ffdfc4 	movi	r3,-129
811320c4:	94c4b03a 	or	r2,r18,r19
811320c8:	a0e8703a 	and	r20,r20,r3
811320cc:	1000cc26 	beq	r2,zero,81132400 <___vfiprintf_internal_r+0xb40>
811320d0:	98021026 	beq	r19,zero,81132914 <___vfiprintf_internal_r+0x1054>
811320d4:	dc402415 	stw	r17,144(sp)
811320d8:	dc002515 	stw	r16,148(sp)
811320dc:	9823883a 	mov	r17,r19
811320e0:	9021883a 	mov	r16,r18
811320e4:	dd401a04 	addi	r21,sp,104
811320e8:	4825883a 	mov	r18,r9
811320ec:	4027883a 	mov	r19,r8
811320f0:	8009883a 	mov	r4,r16
811320f4:	880b883a 	mov	r5,r17
811320f8:	01800284 	movi	r6,10
811320fc:	000f883a 	mov	r7,zero
81132100:	11345e00 	call	811345e0 <__umoddi3>
81132104:	10800c04 	addi	r2,r2,48
81132108:	ad7fffc4 	addi	r21,r21,-1
8113210c:	8009883a 	mov	r4,r16
81132110:	880b883a 	mov	r5,r17
81132114:	a8800005 	stb	r2,0(r21)
81132118:	01800284 	movi	r6,10
8113211c:	000f883a 	mov	r7,zero
81132120:	11340600 	call	81134060 <__udivdi3>
81132124:	1021883a 	mov	r16,r2
81132128:	10c4b03a 	or	r2,r2,r3
8113212c:	1823883a 	mov	r17,r3
81132130:	103fef1e 	bne	r2,zero,811320f0 <__reset+0xfb1120f0>
81132134:	dc402417 	ldw	r17,144(sp)
81132138:	dc002517 	ldw	r16,148(sp)
8113213c:	9013883a 	mov	r9,r18
81132140:	9811883a 	mov	r8,r19
81132144:	da801e17 	ldw	r10,120(sp)
81132148:	5567c83a 	sub	r19,r10,r21
8113214c:	003ede06 	br	81131cc8 <__reset+0xfb111cc8>
81132150:	38803fcc 	andi	r2,r7,255
81132154:	1080201c 	xori	r2,r2,128
81132158:	10bfe004 	addi	r2,r2,-128
8113215c:	1002371e 	bne	r2,zero,81132a3c <___vfiprintf_internal_r+0x117c>
81132160:	01000044 	movi	r4,1
81132164:	01c00804 	movi	r7,32
81132168:	80c00007 	ldb	r3,0(r16)
8113216c:	003e3506 	br	81131a44 <__reset+0xfb111a44>
81132170:	a5000054 	ori	r20,r20,1
81132174:	80c00007 	ldb	r3,0(r16)
81132178:	003e3206 	br	81131a44 <__reset+0xfb111a44>
8113217c:	a5002014 	ori	r20,r20,128
81132180:	80c00007 	ldb	r3,0(r16)
81132184:	003e2f06 	br	81131a44 <__reset+0xfb111a44>
81132188:	8015883a 	mov	r10,r16
8113218c:	0023883a 	mov	r17,zero
81132190:	18bff404 	addi	r2,r3,-48
81132194:	50c00007 	ldb	r3,0(r10)
81132198:	8c4002a4 	muli	r17,r17,10
8113219c:	84000044 	addi	r16,r16,1
811321a0:	8015883a 	mov	r10,r16
811321a4:	1463883a 	add	r17,r2,r17
811321a8:	18bff404 	addi	r2,r3,-48
811321ac:	30bff92e 	bgeu	r6,r2,81132194 <__reset+0xfb112194>
811321b0:	003e2506 	br	81131a48 <__reset+0xfb111a48>
811321b4:	21003fcc 	andi	r4,r4,255
811321b8:	2002d41e 	bne	r4,zero,81132d0c <___vfiprintf_internal_r+0x144c>
811321bc:	a5000414 	ori	r20,r20,16
811321c0:	a080080c 	andi	r2,r20,32
811321c4:	103fb51e 	bne	r2,zero,8113209c <__reset+0xfb11209c>
811321c8:	a080040c 	andi	r2,r20,16
811321cc:	1001f826 	beq	r2,zero,811329b0 <___vfiprintf_internal_r+0x10f0>
811321d0:	da802217 	ldw	r10,136(sp)
811321d4:	54800017 	ldw	r18,0(r10)
811321d8:	52800104 	addi	r10,r10,4
811321dc:	da802215 	stw	r10,136(sp)
811321e0:	9027d7fa 	srai	r19,r18,31
811321e4:	9805883a 	mov	r2,r19
811321e8:	003fb206 	br	811320b4 <__reset+0xfb1120b4>
811321ec:	21003fcc 	andi	r4,r4,255
811321f0:	2002c41e 	bne	r4,zero,81132d04 <___vfiprintf_internal_r+0x1444>
811321f4:	a5000414 	ori	r20,r20,16
811321f8:	a080080c 	andi	r2,r20,32
811321fc:	103f5f1e 	bne	r2,zero,81131f7c <__reset+0xfb111f7c>
81132200:	a080040c 	andi	r2,r20,16
81132204:	10020f26 	beq	r2,zero,81132a44 <___vfiprintf_internal_r+0x1184>
81132208:	da802217 	ldw	r10,136(sp)
8113220c:	d8001d85 	stb	zero,118(sp)
81132210:	0027883a 	mov	r19,zero
81132214:	50800104 	addi	r2,r10,4
81132218:	54800017 	ldw	r18,0(r10)
8113221c:	48021116 	blt	r9,zero,81132a64 <___vfiprintf_internal_r+0x11a4>
81132220:	00ffdfc4 	movi	r3,-129
81132224:	d8802215 	stw	r2,136(sp)
81132228:	a0e8703a 	and	r20,r20,r3
8113222c:	903f5e1e 	bne	r18,zero,81131fa8 <__reset+0xfb111fa8>
81132230:	0039883a 	mov	fp,zero
81132234:	4802a626 	beq	r9,zero,81132cd0 <___vfiprintf_internal_r+0x1410>
81132238:	0025883a 	mov	r18,zero
8113223c:	0027883a 	mov	r19,zero
81132240:	003f5a06 	br	81131fac <__reset+0xfb111fac>
81132244:	21003fcc 	andi	r4,r4,255
81132248:	20029f1e 	bne	r4,zero,81132cc8 <___vfiprintf_internal_r+0x1408>
8113224c:	a5000414 	ori	r20,r20,16
81132250:	a080080c 	andi	r2,r20,32
81132254:	10005e1e 	bne	r2,zero,811323d0 <___vfiprintf_internal_r+0xb10>
81132258:	a080040c 	andi	r2,r20,16
8113225c:	1001a21e 	bne	r2,zero,811328e8 <___vfiprintf_internal_r+0x1028>
81132260:	a080100c 	andi	r2,r20,64
81132264:	d8001d85 	stb	zero,118(sp)
81132268:	da802217 	ldw	r10,136(sp)
8113226c:	1002231e 	bne	r2,zero,81132afc <___vfiprintf_internal_r+0x123c>
81132270:	50800104 	addi	r2,r10,4
81132274:	54800017 	ldw	r18,0(r10)
81132278:	0027883a 	mov	r19,zero
8113227c:	4801a00e 	bge	r9,zero,81132900 <___vfiprintf_internal_r+0x1040>
81132280:	d8802215 	stw	r2,136(sp)
81132284:	0039883a 	mov	fp,zero
81132288:	94c4b03a 	or	r2,r18,r19
8113228c:	103f901e 	bne	r2,zero,811320d0 <__reset+0xfb1120d0>
81132290:	00800044 	movi	r2,1
81132294:	10803fcc 	andi	r2,r2,255
81132298:	00c00044 	movi	r3,1
8113229c:	10c05926 	beq	r2,r3,81132404 <___vfiprintf_internal_r+0xb44>
811322a0:	00c00084 	movi	r3,2
811322a4:	10ffe41e 	bne	r2,r3,81132238 <__reset+0xfb112238>
811322a8:	0025883a 	mov	r18,zero
811322ac:	0027883a 	mov	r19,zero
811322b0:	00013d06 	br	811327a8 <___vfiprintf_internal_r+0xee8>
811322b4:	21003fcc 	andi	r4,r4,255
811322b8:	2002811e 	bne	r4,zero,81132cc0 <___vfiprintf_internal_r+0x1400>
811322bc:	00a04574 	movhi	r2,33045
811322c0:	10833b04 	addi	r2,r2,3308
811322c4:	d8802615 	stw	r2,152(sp)
811322c8:	a080080c 	andi	r2,r20,32
811322cc:	103f561e 	bne	r2,zero,81132028 <__reset+0xfb112028>
811322d0:	a080040c 	andi	r2,r20,16
811322d4:	1001d126 	beq	r2,zero,81132a1c <___vfiprintf_internal_r+0x115c>
811322d8:	da802217 	ldw	r10,136(sp)
811322dc:	0027883a 	mov	r19,zero
811322e0:	54800017 	ldw	r18,0(r10)
811322e4:	52800104 	addi	r10,r10,4
811322e8:	da802215 	stw	r10,136(sp)
811322ec:	003f5306 	br	8113203c <__reset+0xfb11203c>
811322f0:	da802217 	ldw	r10,136(sp)
811322f4:	d8001d85 	stb	zero,118(sp)
811322f8:	55400017 	ldw	r21,0(r10)
811322fc:	50c00104 	addi	r3,r10,4
81132300:	a8024226 	beq	r21,zero,81132c0c <___vfiprintf_internal_r+0x134c>
81132304:	48021816 	blt	r9,zero,81132b68 <___vfiprintf_internal_r+0x12a8>
81132308:	480d883a 	mov	r6,r9
8113230c:	000b883a 	mov	r5,zero
81132310:	a809883a 	mov	r4,r21
81132314:	d8c02a15 	stw	r3,168(sp)
81132318:	da002b15 	stw	r8,172(sp)
8113231c:	da402c15 	stw	r9,176(sp)
81132320:	112c9840 	call	8112c984 <memchr>
81132324:	d8c02a17 	ldw	r3,168(sp)
81132328:	da002b17 	ldw	r8,172(sp)
8113232c:	da402c17 	ldw	r9,176(sp)
81132330:	10024826 	beq	r2,zero,81132c54 <___vfiprintf_internal_r+0x1394>
81132334:	1567c83a 	sub	r19,r2,r21
81132338:	df001d83 	ldbu	fp,118(sp)
8113233c:	d8c02215 	stw	r3,136(sp)
81132340:	0013883a 	mov	r9,zero
81132344:	003e6006 	br	81131cc8 <__reset+0xfb111cc8>
81132348:	21003fcc 	andi	r4,r4,255
8113234c:	203fc026 	beq	r4,zero,81132250 <__reset+0xfb112250>
81132350:	d9c01d85 	stb	r7,118(sp)
81132354:	003fbe06 	br	81132250 <__reset+0xfb112250>
81132358:	da802217 	ldw	r10,136(sp)
8113235c:	54400017 	ldw	r17,0(r10)
81132360:	50800104 	addi	r2,r10,4
81132364:	883e3b16 	blt	r17,zero,81131c54 <__reset+0xfb111c54>
81132368:	d8802215 	stw	r2,136(sp)
8113236c:	80c00007 	ldb	r3,0(r16)
81132370:	003db406 	br	81131a44 <__reset+0xfb111a44>
81132374:	01000044 	movi	r4,1
81132378:	01c00ac4 	movi	r7,43
8113237c:	80c00007 	ldb	r3,0(r16)
81132380:	003db006 	br	81131a44 <__reset+0xfb111a44>
81132384:	80c00007 	ldb	r3,0(r16)
81132388:	82800044 	addi	r10,r16,1
8113238c:	1b423c26 	beq	r3,r13,81132c80 <___vfiprintf_internal_r+0x13c0>
81132390:	18bff404 	addi	r2,r3,-48
81132394:	0013883a 	mov	r9,zero
81132398:	30822b36 	bltu	r6,r2,81132c48 <___vfiprintf_internal_r+0x1388>
8113239c:	50c00007 	ldb	r3,0(r10)
811323a0:	4a4002a4 	muli	r9,r9,10
811323a4:	54000044 	addi	r16,r10,1
811323a8:	8015883a 	mov	r10,r16
811323ac:	4893883a 	add	r9,r9,r2
811323b0:	18bff404 	addi	r2,r3,-48
811323b4:	30bff92e 	bgeu	r6,r2,8113239c <__reset+0xfb11239c>
811323b8:	483da30e 	bge	r9,zero,81131a48 <__reset+0xfb111a48>
811323bc:	027fffc4 	movi	r9,-1
811323c0:	003da106 	br	81131a48 <__reset+0xfb111a48>
811323c4:	a5001014 	ori	r20,r20,64
811323c8:	80c00007 	ldb	r3,0(r16)
811323cc:	003d9d06 	br	81131a44 <__reset+0xfb111a44>
811323d0:	da802217 	ldw	r10,136(sp)
811323d4:	d8001d85 	stb	zero,118(sp)
811323d8:	50c00204 	addi	r3,r10,8
811323dc:	54800017 	ldw	r18,0(r10)
811323e0:	54c00117 	ldw	r19,4(r10)
811323e4:	4801ca16 	blt	r9,zero,81132b10 <___vfiprintf_internal_r+0x1250>
811323e8:	013fdfc4 	movi	r4,-129
811323ec:	94c4b03a 	or	r2,r18,r19
811323f0:	d8c02215 	stw	r3,136(sp)
811323f4:	a128703a 	and	r20,r20,r4
811323f8:	0039883a 	mov	fp,zero
811323fc:	103f341e 	bne	r2,zero,811320d0 <__reset+0xfb1120d0>
81132400:	483e2e26 	beq	r9,zero,81131cbc <__reset+0xfb111cbc>
81132404:	0025883a 	mov	r18,zero
81132408:	94800c04 	addi	r18,r18,48
8113240c:	dc8019c5 	stb	r18,103(sp)
81132410:	dcc02717 	ldw	r19,156(sp)
81132414:	dd4019c4 	addi	r21,sp,103
81132418:	003e2b06 	br	81131cc8 <__reset+0xfb111cc8>
8113241c:	21003fcc 	andi	r4,r4,255
81132420:	2002361e 	bne	r4,zero,81132cfc <___vfiprintf_internal_r+0x143c>
81132424:	1801c126 	beq	r3,zero,81132b2c <___vfiprintf_internal_r+0x126c>
81132428:	04800044 	movi	r18,1
8113242c:	d8c01005 	stb	r3,64(sp)
81132430:	d8001d85 	stb	zero,118(sp)
81132434:	9027883a 	mov	r19,r18
81132438:	dd401004 	addi	r21,sp,64
8113243c:	003f1106 	br	81132084 <__reset+0xfb112084>
81132440:	d9402117 	ldw	r5,132(sp)
81132444:	d9002017 	ldw	r4,128(sp)
81132448:	d9801a04 	addi	r6,sp,104
8113244c:	d9c02b15 	stw	r7,172(sp)
81132450:	dbc02a15 	stw	r15,168(sp)
81132454:	11317a40 	call	811317a4 <__sprint_r.part.0>
81132458:	d9c02b17 	ldw	r7,172(sp)
8113245c:	dbc02a17 	ldw	r15,168(sp)
81132460:	10006d1e 	bne	r2,zero,81132618 <___vfiprintf_internal_r+0xd58>
81132464:	d9801b17 	ldw	r6,108(sp)
81132468:	d8801c17 	ldw	r2,112(sp)
8113246c:	d811883a 	mov	r8,sp
81132470:	31400044 	addi	r5,r6,1
81132474:	003e3306 	br	81131d44 <__reset+0xfb111d44>
81132478:	d9401b17 	ldw	r5,108(sp)
8113247c:	d8801c17 	ldw	r2,112(sp)
81132480:	29000044 	addi	r4,r5,1
81132484:	d8c01d87 	ldb	r3,118(sp)
81132488:	183e4d26 	beq	r3,zero,81131dc0 <__reset+0xfb111dc0>
8113248c:	00c00044 	movi	r3,1
81132490:	d9401d84 	addi	r5,sp,118
81132494:	10c5883a 	add	r2,r2,r3
81132498:	41400015 	stw	r5,0(r8)
8113249c:	40c00115 	stw	r3,4(r8)
811324a0:	d8801c15 	stw	r2,112(sp)
811324a4:	d9001b15 	stw	r4,108(sp)
811324a8:	014001c4 	movi	r5,7
811324ac:	2900a90e 	bge	r5,r4,81132754 <___vfiprintf_internal_r+0xe94>
811324b0:	1000da1e 	bne	r2,zero,8113281c <___vfiprintf_internal_r+0xf5c>
811324b4:	7000ab1e 	bne	r14,zero,81132764 <___vfiprintf_internal_r+0xea4>
811324b8:	000b883a 	mov	r5,zero
811324bc:	1809883a 	mov	r4,r3
811324c0:	d811883a 	mov	r8,sp
811324c4:	00c02004 	movi	r3,128
811324c8:	e0fe4d26 	beq	fp,r3,81131e00 <__reset+0xfb111e00>
811324cc:	4cf9c83a 	sub	fp,r9,r19
811324d0:	073e7b0e 	bge	zero,fp,81131ec0 <__reset+0xfb111ec0>
811324d4:	01c00404 	movi	r7,16
811324d8:	3f01900e 	bge	r7,fp,81132b1c <___vfiprintf_internal_r+0x125c>
811324dc:	00e04574 	movhi	r3,33045
811324e0:	18c3d204 	addi	r3,r3,3912
811324e4:	d8c02415 	stw	r3,144(sp)
811324e8:	034001c4 	movi	r13,7
811324ec:	00000506 	br	81132504 <___vfiprintf_internal_r+0xc44>
811324f0:	29000084 	addi	r4,r5,2
811324f4:	42000204 	addi	r8,r8,8
811324f8:	180b883a 	mov	r5,r3
811324fc:	e73ffc04 	addi	fp,fp,-16
81132500:	3f000d0e 	bge	r7,fp,81132538 <___vfiprintf_internal_r+0xc78>
81132504:	10800404 	addi	r2,r2,16
81132508:	28c00044 	addi	r3,r5,1
8113250c:	45c00015 	stw	r23,0(r8)
81132510:	41c00115 	stw	r7,4(r8)
81132514:	d8801c15 	stw	r2,112(sp)
81132518:	d8c01b15 	stw	r3,108(sp)
8113251c:	68fff40e 	bge	r13,r3,811324f0 <__reset+0xfb1124f0>
81132520:	1000101e 	bne	r2,zero,81132564 <___vfiprintf_internal_r+0xca4>
81132524:	e73ffc04 	addi	fp,fp,-16
81132528:	01000044 	movi	r4,1
8113252c:	000b883a 	mov	r5,zero
81132530:	d811883a 	mov	r8,sp
81132534:	3f3ff316 	blt	r7,fp,81132504 <__reset+0xfb112504>
81132538:	da802417 	ldw	r10,144(sp)
8113253c:	1705883a 	add	r2,r2,fp
81132540:	47000115 	stw	fp,4(r8)
81132544:	42800015 	stw	r10,0(r8)
81132548:	d8801c15 	stw	r2,112(sp)
8113254c:	d9001b15 	stw	r4,108(sp)
81132550:	00c001c4 	movi	r3,7
81132554:	19003616 	blt	r3,r4,81132630 <___vfiprintf_internal_r+0xd70>
81132558:	42000204 	addi	r8,r8,8
8113255c:	21000044 	addi	r4,r4,1
81132560:	003e5706 	br	81131ec0 <__reset+0xfb111ec0>
81132564:	d9402117 	ldw	r5,132(sp)
81132568:	d9002017 	ldw	r4,128(sp)
8113256c:	d9801a04 	addi	r6,sp,104
81132570:	d9c02b15 	stw	r7,172(sp)
81132574:	db402a15 	stw	r13,168(sp)
81132578:	11317a40 	call	811317a4 <__sprint_r.part.0>
8113257c:	d9c02b17 	ldw	r7,172(sp)
81132580:	db402a17 	ldw	r13,168(sp)
81132584:	1000241e 	bne	r2,zero,81132618 <___vfiprintf_internal_r+0xd58>
81132588:	d9401b17 	ldw	r5,108(sp)
8113258c:	d8801c17 	ldw	r2,112(sp)
81132590:	d811883a 	mov	r8,sp
81132594:	29000044 	addi	r4,r5,1
81132598:	003fd806 	br	811324fc <__reset+0xfb1124fc>
8113259c:	d9401b17 	ldw	r5,108(sp)
811325a0:	00e04574 	movhi	r3,33045
811325a4:	18c3d604 	addi	r3,r3,3928
811325a8:	d8c02415 	stw	r3,144(sp)
811325ac:	29400044 	addi	r5,r5,1
811325b0:	d8c02417 	ldw	r3,144(sp)
811325b4:	14c5883a 	add	r2,r2,r19
811325b8:	44c00115 	stw	r19,4(r8)
811325bc:	40c00015 	stw	r3,0(r8)
811325c0:	d8801c15 	stw	r2,112(sp)
811325c4:	d9401b15 	stw	r5,108(sp)
811325c8:	00c001c4 	movi	r3,7
811325cc:	1940070e 	bge	r3,r5,811325ec <___vfiprintf_internal_r+0xd2c>
811325d0:	103e4826 	beq	r2,zero,81131ef4 <__reset+0xfb111ef4>
811325d4:	d9402117 	ldw	r5,132(sp)
811325d8:	d9002017 	ldw	r4,128(sp)
811325dc:	d9801a04 	addi	r6,sp,104
811325e0:	11317a40 	call	811317a4 <__sprint_r.part.0>
811325e4:	10000c1e 	bne	r2,zero,81132618 <___vfiprintf_internal_r+0xd58>
811325e8:	d8801c17 	ldw	r2,112(sp)
811325ec:	8c80010e 	bge	r17,r18,811325f4 <___vfiprintf_internal_r+0xd34>
811325f0:	9023883a 	mov	r17,r18
811325f4:	da802317 	ldw	r10,140(sp)
811325f8:	5455883a 	add	r10,r10,r17
811325fc:	da802315 	stw	r10,140(sp)
81132600:	103e4126 	beq	r2,zero,81131f08 <__reset+0xfb111f08>
81132604:	d9402117 	ldw	r5,132(sp)
81132608:	d9002017 	ldw	r4,128(sp)
8113260c:	d9801a04 	addi	r6,sp,104
81132610:	11317a40 	call	811317a4 <__sprint_r.part.0>
81132614:	103e3c26 	beq	r2,zero,81131f08 <__reset+0xfb111f08>
81132618:	dd002117 	ldw	r20,132(sp)
8113261c:	a080030b 	ldhu	r2,12(r20)
81132620:	1080100c 	andi	r2,r2,64
81132624:	1001231e 	bne	r2,zero,81132ab4 <___vfiprintf_internal_r+0x11f4>
81132628:	d8802317 	ldw	r2,140(sp)
8113262c:	003d7b06 	br	81131c1c <__reset+0xfb111c1c>
81132630:	1000991e 	bne	r2,zero,81132898 <___vfiprintf_internal_r+0xfd8>
81132634:	00c00044 	movi	r3,1
81132638:	9805883a 	mov	r2,r19
8113263c:	dd400015 	stw	r21,0(sp)
81132640:	dcc00115 	stw	r19,4(sp)
81132644:	dcc01c15 	stw	r19,112(sp)
81132648:	d8c01b15 	stw	r3,108(sp)
8113264c:	d811883a 	mov	r8,sp
81132650:	42000204 	addi	r8,r8,8
81132654:	a2c0010c 	andi	r11,r20,4
81132658:	583fe426 	beq	r11,zero,811325ec <__reset+0xfb1125ec>
8113265c:	8ca7c83a 	sub	r19,r17,r18
81132660:	04ffe20e 	bge	zero,r19,811325ec <__reset+0xfb1125ec>
81132664:	01c00404 	movi	r7,16
81132668:	3cffcc0e 	bge	r7,r19,8113259c <__reset+0xfb11259c>
8113266c:	02a04574 	movhi	r10,33045
81132670:	5283d604 	addi	r10,r10,3928
81132674:	d9001b17 	ldw	r4,108(sp)
81132678:	da802415 	stw	r10,144(sp)
8113267c:	382b883a 	mov	r21,r7
81132680:	050001c4 	movi	r20,7
81132684:	df002017 	ldw	fp,128(sp)
81132688:	00000506 	br	811326a0 <___vfiprintf_internal_r+0xde0>
8113268c:	21400084 	addi	r5,r4,2
81132690:	42000204 	addi	r8,r8,8
81132694:	1809883a 	mov	r4,r3
81132698:	9cfffc04 	addi	r19,r19,-16
8113269c:	acffc40e 	bge	r21,r19,811325b0 <__reset+0xfb1125b0>
811326a0:	10800404 	addi	r2,r2,16
811326a4:	20c00044 	addi	r3,r4,1
811326a8:	45800015 	stw	r22,0(r8)
811326ac:	45400115 	stw	r21,4(r8)
811326b0:	d8801c15 	stw	r2,112(sp)
811326b4:	d8c01b15 	stw	r3,108(sp)
811326b8:	a0fff40e 	bge	r20,r3,8113268c <__reset+0xfb11268c>
811326bc:	1000041e 	bne	r2,zero,811326d0 <___vfiprintf_internal_r+0xe10>
811326c0:	01400044 	movi	r5,1
811326c4:	0009883a 	mov	r4,zero
811326c8:	d811883a 	mov	r8,sp
811326cc:	003ff206 	br	81132698 <__reset+0xfb112698>
811326d0:	d9402117 	ldw	r5,132(sp)
811326d4:	d9801a04 	addi	r6,sp,104
811326d8:	e009883a 	mov	r4,fp
811326dc:	11317a40 	call	811317a4 <__sprint_r.part.0>
811326e0:	103fcd1e 	bne	r2,zero,81132618 <__reset+0xfb112618>
811326e4:	d9001b17 	ldw	r4,108(sp)
811326e8:	d8801c17 	ldw	r2,112(sp)
811326ec:	d811883a 	mov	r8,sp
811326f0:	21400044 	addi	r5,r4,1
811326f4:	003fe806 	br	81132698 <__reset+0xfb112698>
811326f8:	d9402117 	ldw	r5,132(sp)
811326fc:	d9002017 	ldw	r4,128(sp)
81132700:	d9801a04 	addi	r6,sp,104
81132704:	d9c02b15 	stw	r7,172(sp)
81132708:	db402a15 	stw	r13,168(sp)
8113270c:	11317a40 	call	811317a4 <__sprint_r.part.0>
81132710:	d9c02b17 	ldw	r7,172(sp)
81132714:	db402a17 	ldw	r13,168(sp)
81132718:	103fbf1e 	bne	r2,zero,81132618 <__reset+0xfb112618>
8113271c:	d9401b17 	ldw	r5,108(sp)
81132720:	d8801c17 	ldw	r2,112(sp)
81132724:	d811883a 	mov	r8,sp
81132728:	29800044 	addi	r6,r5,1
8113272c:	003dc406 	br	81131e40 <__reset+0xfb111e40>
81132730:	1000d21e 	bne	r2,zero,81132a7c <___vfiprintf_internal_r+0x11bc>
81132734:	d8c01d87 	ldb	r3,118(sp)
81132738:	18009526 	beq	r3,zero,81132990 <___vfiprintf_internal_r+0x10d0>
8113273c:	00800044 	movi	r2,1
81132740:	d8c01d84 	addi	r3,sp,118
81132744:	1009883a 	mov	r4,r2
81132748:	d8c00015 	stw	r3,0(sp)
8113274c:	d8800115 	stw	r2,4(sp)
81132750:	d811883a 	mov	r8,sp
81132754:	200b883a 	mov	r5,r4
81132758:	42000204 	addi	r8,r8,8
8113275c:	21000044 	addi	r4,r4,1
81132760:	003d9706 	br	81131dc0 <__reset+0xfb111dc0>
81132764:	d9001d04 	addi	r4,sp,116
81132768:	00800084 	movi	r2,2
8113276c:	d9000015 	stw	r4,0(sp)
81132770:	d8800115 	stw	r2,4(sp)
81132774:	1809883a 	mov	r4,r3
81132778:	d811883a 	mov	r8,sp
8113277c:	200b883a 	mov	r5,r4
81132780:	42000204 	addi	r8,r8,8
81132784:	21000044 	addi	r4,r4,1
81132788:	003f4e06 	br	811324c4 <__reset+0xfb1124c4>
8113278c:	d8001d85 	stb	zero,118(sp)
81132790:	48005016 	blt	r9,zero,811328d4 <___vfiprintf_internal_r+0x1014>
81132794:	00ffdfc4 	movi	r3,-129
81132798:	94c4b03a 	or	r2,r18,r19
8113279c:	a0e8703a 	and	r20,r20,r3
811327a0:	103d4426 	beq	r2,zero,81131cb4 <__reset+0xfb111cb4>
811327a4:	0039883a 	mov	fp,zero
811327a8:	d9002617 	ldw	r4,152(sp)
811327ac:	dd401a04 	addi	r21,sp,104
811327b0:	908003cc 	andi	r2,r18,15
811327b4:	9806973a 	slli	r3,r19,28
811327b8:	2085883a 	add	r2,r4,r2
811327bc:	9024d13a 	srli	r18,r18,4
811327c0:	10800003 	ldbu	r2,0(r2)
811327c4:	9826d13a 	srli	r19,r19,4
811327c8:	ad7fffc4 	addi	r21,r21,-1
811327cc:	1ca4b03a 	or	r18,r3,r18
811327d0:	a8800005 	stb	r2,0(r21)
811327d4:	94c4b03a 	or	r2,r18,r19
811327d8:	103ff51e 	bne	r2,zero,811327b0 <__reset+0xfb1127b0>
811327dc:	003e5906 	br	81132144 <__reset+0xfb112144>
811327e0:	d9402117 	ldw	r5,132(sp)
811327e4:	d9002017 	ldw	r4,128(sp)
811327e8:	d9801a04 	addi	r6,sp,104
811327ec:	11317a40 	call	811317a4 <__sprint_r.part.0>
811327f0:	103f891e 	bne	r2,zero,81132618 <__reset+0xfb112618>
811327f4:	d8801c17 	ldw	r2,112(sp)
811327f8:	d811883a 	mov	r8,sp
811327fc:	003f9506 	br	81132654 <__reset+0xfb112654>
81132800:	d9402117 	ldw	r5,132(sp)
81132804:	d9002017 	ldw	r4,128(sp)
81132808:	d9801a04 	addi	r6,sp,104
8113280c:	11317a40 	call	811317a4 <__sprint_r.part.0>
81132810:	103f811e 	bne	r2,zero,81132618 <__reset+0xfb112618>
81132814:	d811883a 	mov	r8,sp
81132818:	003ced06 	br	81131bd0 <__reset+0xfb111bd0>
8113281c:	d9402117 	ldw	r5,132(sp)
81132820:	d9002017 	ldw	r4,128(sp)
81132824:	d9801a04 	addi	r6,sp,104
81132828:	da402c15 	stw	r9,176(sp)
8113282c:	db802a15 	stw	r14,168(sp)
81132830:	11317a40 	call	811317a4 <__sprint_r.part.0>
81132834:	da402c17 	ldw	r9,176(sp)
81132838:	db802a17 	ldw	r14,168(sp)
8113283c:	103f761e 	bne	r2,zero,81132618 <__reset+0xfb112618>
81132840:	d9401b17 	ldw	r5,108(sp)
81132844:	d8801c17 	ldw	r2,112(sp)
81132848:	d811883a 	mov	r8,sp
8113284c:	29000044 	addi	r4,r5,1
81132850:	003d5b06 	br	81131dc0 <__reset+0xfb111dc0>
81132854:	d9402117 	ldw	r5,132(sp)
81132858:	d9002017 	ldw	r4,128(sp)
8113285c:	d9801a04 	addi	r6,sp,104
81132860:	da402c15 	stw	r9,176(sp)
81132864:	11317a40 	call	811317a4 <__sprint_r.part.0>
81132868:	da402c17 	ldw	r9,176(sp)
8113286c:	103f6a1e 	bne	r2,zero,81132618 <__reset+0xfb112618>
81132870:	d9401b17 	ldw	r5,108(sp)
81132874:	d8801c17 	ldw	r2,112(sp)
81132878:	d811883a 	mov	r8,sp
8113287c:	29000044 	addi	r4,r5,1
81132880:	003f1006 	br	811324c4 <__reset+0xfb1124c4>
81132884:	1000c31e 	bne	r2,zero,81132b94 <___vfiprintf_internal_r+0x12d4>
81132888:	01000044 	movi	r4,1
8113288c:	000b883a 	mov	r5,zero
81132890:	d811883a 	mov	r8,sp
81132894:	003f0d06 	br	811324cc <__reset+0xfb1124cc>
81132898:	d9402117 	ldw	r5,132(sp)
8113289c:	d9002017 	ldw	r4,128(sp)
811328a0:	d9801a04 	addi	r6,sp,104
811328a4:	11317a40 	call	811317a4 <__sprint_r.part.0>
811328a8:	103f5b1e 	bne	r2,zero,81132618 <__reset+0xfb112618>
811328ac:	d9001b17 	ldw	r4,108(sp)
811328b0:	d8801c17 	ldw	r2,112(sp)
811328b4:	d811883a 	mov	r8,sp
811328b8:	21000044 	addi	r4,r4,1
811328bc:	003d8006 	br	81131ec0 <__reset+0xfb111ec0>
811328c0:	01204574 	movhi	r4,33045
811328c4:	21034004 	addi	r4,r4,3328
811328c8:	d9002615 	stw	r4,152(sp)
811328cc:	d8c02215 	stw	r3,136(sp)
811328d0:	1029883a 	mov	r20,r2
811328d4:	94c4b03a 	or	r2,r18,r19
811328d8:	103fb21e 	bne	r2,zero,811327a4 <__reset+0xfb1127a4>
811328dc:	0039883a 	mov	fp,zero
811328e0:	00800084 	movi	r2,2
811328e4:	003e6b06 	br	81132294 <__reset+0xfb112294>
811328e8:	da802217 	ldw	r10,136(sp)
811328ec:	d8001d85 	stb	zero,118(sp)
811328f0:	0027883a 	mov	r19,zero
811328f4:	50800104 	addi	r2,r10,4
811328f8:	54800017 	ldw	r18,0(r10)
811328fc:	483e6016 	blt	r9,zero,81132280 <__reset+0xfb112280>
81132900:	00ffdfc4 	movi	r3,-129
81132904:	d8802215 	stw	r2,136(sp)
81132908:	a0e8703a 	and	r20,r20,r3
8113290c:	0039883a 	mov	fp,zero
81132910:	903ebb26 	beq	r18,zero,81132400 <__reset+0xfb112400>
81132914:	00800244 	movi	r2,9
81132918:	14bdee36 	bltu	r2,r18,811320d4 <__reset+0xfb1120d4>
8113291c:	003eba06 	br	81132408 <__reset+0xfb112408>
81132920:	00800c04 	movi	r2,48
81132924:	d8c01d45 	stb	r3,117(sp)
81132928:	d8801d05 	stb	r2,116(sp)
8113292c:	d8001d85 	stb	zero,118(sp)
81132930:	a0c00094 	ori	r3,r20,2
81132934:	4800a916 	blt	r9,zero,81132bdc <___vfiprintf_internal_r+0x131c>
81132938:	00bfdfc4 	movi	r2,-129
8113293c:	a096703a 	and	r11,r20,r2
81132940:	5d000094 	ori	r20,r11,2
81132944:	0039883a 	mov	fp,zero
81132948:	003f9706 	br	811327a8 <__reset+0xfb1127a8>
8113294c:	8025883a 	mov	r18,r16
81132950:	003c2e06 	br	81131a0c <__reset+0xfb111a0c>
81132954:	00a04574 	movhi	r2,33045
81132958:	10834004 	addi	r2,r2,3328
8113295c:	0039883a 	mov	fp,zero
81132960:	d8802615 	stw	r2,152(sp)
81132964:	003f9006 	br	811327a8 <__reset+0xfb1127a8>
81132968:	04a5c83a 	sub	r18,zero,r18
8113296c:	07000b44 	movi	fp,45
81132970:	9004c03a 	cmpne	r2,r18,zero
81132974:	04e7c83a 	sub	r19,zero,r19
81132978:	df001d85 	stb	fp,118(sp)
8113297c:	98a7c83a 	sub	r19,r19,r2
81132980:	48009f16 	blt	r9,zero,81132c00 <___vfiprintf_internal_r+0x1340>
81132984:	00bfdfc4 	movi	r2,-129
81132988:	a0a8703a 	and	r20,r20,r2
8113298c:	003dd006 	br	811320d0 <__reset+0xfb1120d0>
81132990:	70004c26 	beq	r14,zero,81132ac4 <___vfiprintf_internal_r+0x1204>
81132994:	00800084 	movi	r2,2
81132998:	d8c01d04 	addi	r3,sp,116
8113299c:	d8c00015 	stw	r3,0(sp)
811329a0:	d8800115 	stw	r2,4(sp)
811329a4:	01000044 	movi	r4,1
811329a8:	d811883a 	mov	r8,sp
811329ac:	003f7306 	br	8113277c <__reset+0xfb11277c>
811329b0:	a080100c 	andi	r2,r20,64
811329b4:	da802217 	ldw	r10,136(sp)
811329b8:	103e0626 	beq	r2,zero,811321d4 <__reset+0xfb1121d4>
811329bc:	5480000f 	ldh	r18,0(r10)
811329c0:	52800104 	addi	r10,r10,4
811329c4:	da802215 	stw	r10,136(sp)
811329c8:	9027d7fa 	srai	r19,r18,31
811329cc:	9805883a 	mov	r2,r19
811329d0:	003db806 	br	811320b4 <__reset+0xfb1120b4>
811329d4:	a080040c 	andi	r2,r20,16
811329d8:	1000091e 	bne	r2,zero,81132a00 <___vfiprintf_internal_r+0x1140>
811329dc:	a2c0100c 	andi	r11,r20,64
811329e0:	58000726 	beq	r11,zero,81132a00 <___vfiprintf_internal_r+0x1140>
811329e4:	da802217 	ldw	r10,136(sp)
811329e8:	50800017 	ldw	r2,0(r10)
811329ec:	52800104 	addi	r10,r10,4
811329f0:	da802215 	stw	r10,136(sp)
811329f4:	da802317 	ldw	r10,140(sp)
811329f8:	1280000d 	sth	r10,0(r2)
811329fc:	003be706 	br	8113199c <__reset+0xfb11199c>
81132a00:	da802217 	ldw	r10,136(sp)
81132a04:	50800017 	ldw	r2,0(r10)
81132a08:	52800104 	addi	r10,r10,4
81132a0c:	da802215 	stw	r10,136(sp)
81132a10:	da802317 	ldw	r10,140(sp)
81132a14:	12800015 	stw	r10,0(r2)
81132a18:	003be006 	br	8113199c <__reset+0xfb11199c>
81132a1c:	a080100c 	andi	r2,r20,64
81132a20:	da802217 	ldw	r10,136(sp)
81132a24:	10003026 	beq	r2,zero,81132ae8 <___vfiprintf_internal_r+0x1228>
81132a28:	5480000b 	ldhu	r18,0(r10)
81132a2c:	52800104 	addi	r10,r10,4
81132a30:	0027883a 	mov	r19,zero
81132a34:	da802215 	stw	r10,136(sp)
81132a38:	003d8006 	br	8113203c <__reset+0xfb11203c>
81132a3c:	80c00007 	ldb	r3,0(r16)
81132a40:	003c0006 	br	81131a44 <__reset+0xfb111a44>
81132a44:	a080100c 	andi	r2,r20,64
81132a48:	d8001d85 	stb	zero,118(sp)
81132a4c:	da802217 	ldw	r10,136(sp)
81132a50:	1000201e 	bne	r2,zero,81132ad4 <___vfiprintf_internal_r+0x1214>
81132a54:	50800104 	addi	r2,r10,4
81132a58:	54800017 	ldw	r18,0(r10)
81132a5c:	0027883a 	mov	r19,zero
81132a60:	483def0e 	bge	r9,zero,81132220 <__reset+0xfb112220>
81132a64:	94c6b03a 	or	r3,r18,r19
81132a68:	d8802215 	stw	r2,136(sp)
81132a6c:	183d4e1e 	bne	r3,zero,81131fa8 <__reset+0xfb111fa8>
81132a70:	0039883a 	mov	fp,zero
81132a74:	0005883a 	mov	r2,zero
81132a78:	003e0606 	br	81132294 <__reset+0xfb112294>
81132a7c:	d9402117 	ldw	r5,132(sp)
81132a80:	d9002017 	ldw	r4,128(sp)
81132a84:	d9801a04 	addi	r6,sp,104
81132a88:	da402c15 	stw	r9,176(sp)
81132a8c:	db802a15 	stw	r14,168(sp)
81132a90:	11317a40 	call	811317a4 <__sprint_r.part.0>
81132a94:	da402c17 	ldw	r9,176(sp)
81132a98:	db802a17 	ldw	r14,168(sp)
81132a9c:	103ede1e 	bne	r2,zero,81132618 <__reset+0xfb112618>
81132aa0:	d9401b17 	ldw	r5,108(sp)
81132aa4:	d8801c17 	ldw	r2,112(sp)
81132aa8:	d811883a 	mov	r8,sp
81132aac:	29000044 	addi	r4,r5,1
81132ab0:	003e7406 	br	81132484 <__reset+0xfb112484>
81132ab4:	00bfffc4 	movi	r2,-1
81132ab8:	003c5806 	br	81131c1c <__reset+0xfb111c1c>
81132abc:	d811883a 	mov	r8,sp
81132ac0:	003ee806 	br	81132664 <__reset+0xfb112664>
81132ac4:	000b883a 	mov	r5,zero
81132ac8:	01000044 	movi	r4,1
81132acc:	d811883a 	mov	r8,sp
81132ad0:	003e7c06 	br	811324c4 <__reset+0xfb1124c4>
81132ad4:	50800104 	addi	r2,r10,4
81132ad8:	5480000b 	ldhu	r18,0(r10)
81132adc:	0027883a 	mov	r19,zero
81132ae0:	483dcf0e 	bge	r9,zero,81132220 <__reset+0xfb112220>
81132ae4:	003fdf06 	br	81132a64 <__reset+0xfb112a64>
81132ae8:	54800017 	ldw	r18,0(r10)
81132aec:	52800104 	addi	r10,r10,4
81132af0:	0027883a 	mov	r19,zero
81132af4:	da802215 	stw	r10,136(sp)
81132af8:	003d5006 	br	8113203c <__reset+0xfb11203c>
81132afc:	50800104 	addi	r2,r10,4
81132b00:	5480000b 	ldhu	r18,0(r10)
81132b04:	0027883a 	mov	r19,zero
81132b08:	483f7d0e 	bge	r9,zero,81132900 <__reset+0xfb112900>
81132b0c:	003ddc06 	br	81132280 <__reset+0xfb112280>
81132b10:	d8c02215 	stw	r3,136(sp)
81132b14:	0039883a 	mov	fp,zero
81132b18:	003ddb06 	br	81132288 <__reset+0xfb112288>
81132b1c:	02a04574 	movhi	r10,33045
81132b20:	5283d204 	addi	r10,r10,3912
81132b24:	da802415 	stw	r10,144(sp)
81132b28:	003e8306 	br	81132538 <__reset+0xfb112538>
81132b2c:	d8801c17 	ldw	r2,112(sp)
81132b30:	dd002117 	ldw	r20,132(sp)
81132b34:	103eb926 	beq	r2,zero,8113261c <__reset+0xfb11261c>
81132b38:	d9002017 	ldw	r4,128(sp)
81132b3c:	d9801a04 	addi	r6,sp,104
81132b40:	a00b883a 	mov	r5,r20
81132b44:	11317a40 	call	811317a4 <__sprint_r.part.0>
81132b48:	003eb406 	br	8113261c <__reset+0xfb11261c>
81132b4c:	80c00043 	ldbu	r3,1(r16)
81132b50:	a5000814 	ori	r20,r20,32
81132b54:	84000044 	addi	r16,r16,1
81132b58:	18c03fcc 	andi	r3,r3,255
81132b5c:	18c0201c 	xori	r3,r3,128
81132b60:	18ffe004 	addi	r3,r3,-128
81132b64:	003bb706 	br	81131a44 <__reset+0xfb111a44>
81132b68:	a809883a 	mov	r4,r21
81132b6c:	d8c02a15 	stw	r3,168(sp)
81132b70:	da002b15 	stw	r8,172(sp)
81132b74:	11231840 	call	81123184 <strlen>
81132b78:	d8c02a17 	ldw	r3,168(sp)
81132b7c:	1027883a 	mov	r19,r2
81132b80:	df001d83 	ldbu	fp,118(sp)
81132b84:	d8c02215 	stw	r3,136(sp)
81132b88:	0013883a 	mov	r9,zero
81132b8c:	da002b17 	ldw	r8,172(sp)
81132b90:	003c4d06 	br	81131cc8 <__reset+0xfb111cc8>
81132b94:	d9402117 	ldw	r5,132(sp)
81132b98:	d9002017 	ldw	r4,128(sp)
81132b9c:	d9801a04 	addi	r6,sp,104
81132ba0:	da402c15 	stw	r9,176(sp)
81132ba4:	11317a40 	call	811317a4 <__sprint_r.part.0>
81132ba8:	da402c17 	ldw	r9,176(sp)
81132bac:	103e9a1e 	bne	r2,zero,81132618 <__reset+0xfb112618>
81132bb0:	d9401b17 	ldw	r5,108(sp)
81132bb4:	d8801c17 	ldw	r2,112(sp)
81132bb8:	d811883a 	mov	r8,sp
81132bbc:	29000044 	addi	r4,r5,1
81132bc0:	003e4206 	br	811324cc <__reset+0xfb1124cc>
81132bc4:	d9401b17 	ldw	r5,108(sp)
81132bc8:	01204574 	movhi	r4,33045
81132bcc:	2103d604 	addi	r4,r4,3928
81132bd0:	d9002415 	stw	r4,144(sp)
81132bd4:	29400044 	addi	r5,r5,1
81132bd8:	003c6d06 	br	81131d90 <__reset+0xfb111d90>
81132bdc:	0039883a 	mov	fp,zero
81132be0:	00800084 	movi	r2,2
81132be4:	10803fcc 	andi	r2,r2,255
81132be8:	01000044 	movi	r4,1
81132bec:	11001e26 	beq	r2,r4,81132c68 <___vfiprintf_internal_r+0x13a8>
81132bf0:	01000084 	movi	r4,2
81132bf4:	11001e1e 	bne	r2,r4,81132c70 <___vfiprintf_internal_r+0x13b0>
81132bf8:	1829883a 	mov	r20,r3
81132bfc:	003eea06 	br	811327a8 <__reset+0xfb1127a8>
81132c00:	a007883a 	mov	r3,r20
81132c04:	00800044 	movi	r2,1
81132c08:	003ff606 	br	81132be4 <__reset+0xfb112be4>
81132c0c:	00800184 	movi	r2,6
81132c10:	1240012e 	bgeu	r2,r9,81132c18 <___vfiprintf_internal_r+0x1358>
81132c14:	1013883a 	mov	r9,r2
81132c18:	4827883a 	mov	r19,r9
81132c1c:	4825883a 	mov	r18,r9
81132c20:	48001516 	blt	r9,zero,81132c78 <___vfiprintf_internal_r+0x13b8>
81132c24:	05604574 	movhi	r21,33045
81132c28:	d8c02215 	stw	r3,136(sp)
81132c2c:	ad434504 	addi	r21,r21,3348
81132c30:	003d1406 	br	81132084 <__reset+0xfb112084>
81132c34:	02a04574 	movhi	r10,33045
81132c38:	5283d204 	addi	r10,r10,3912
81132c3c:	da802415 	stw	r10,144(sp)
81132c40:	200d883a 	mov	r6,r4
81132c44:	003c9106 	br	81131e8c <__reset+0xfb111e8c>
81132c48:	5021883a 	mov	r16,r10
81132c4c:	0013883a 	mov	r9,zero
81132c50:	003b7d06 	br	81131a48 <__reset+0xfb111a48>
81132c54:	4827883a 	mov	r19,r9
81132c58:	df001d83 	ldbu	fp,118(sp)
81132c5c:	d8c02215 	stw	r3,136(sp)
81132c60:	0013883a 	mov	r9,zero
81132c64:	003c1806 	br	81131cc8 <__reset+0xfb111cc8>
81132c68:	1829883a 	mov	r20,r3
81132c6c:	003d1806 	br	811320d0 <__reset+0xfb1120d0>
81132c70:	1829883a 	mov	r20,r3
81132c74:	003ccd06 	br	81131fac <__reset+0xfb111fac>
81132c78:	0025883a 	mov	r18,zero
81132c7c:	003fe906 	br	81132c24 <__reset+0xfb112c24>
81132c80:	d8802217 	ldw	r2,136(sp)
81132c84:	80c00043 	ldbu	r3,1(r16)
81132c88:	5021883a 	mov	r16,r10
81132c8c:	12400017 	ldw	r9,0(r2)
81132c90:	10800104 	addi	r2,r2,4
81132c94:	d8802215 	stw	r2,136(sp)
81132c98:	483faf0e 	bge	r9,zero,81132b58 <__reset+0xfb112b58>
81132c9c:	18c03fcc 	andi	r3,r3,255
81132ca0:	18c0201c 	xori	r3,r3,128
81132ca4:	027fffc4 	movi	r9,-1
81132ca8:	18ffe004 	addi	r3,r3,-128
81132cac:	003b6506 	br	81131a44 <__reset+0xfb111a44>
81132cb0:	d9c01d85 	stb	r7,118(sp)
81132cb4:	003ca006 	br	81131f38 <__reset+0xfb111f38>
81132cb8:	d9c01d85 	stb	r7,118(sp)
81132cbc:	003cad06 	br	81131f74 <__reset+0xfb111f74>
81132cc0:	d9c01d85 	stb	r7,118(sp)
81132cc4:	003d7d06 	br	811322bc <__reset+0xfb1122bc>
81132cc8:	d9c01d85 	stb	r7,118(sp)
81132ccc:	003d5f06 	br	8113224c <__reset+0xfb11224c>
81132cd0:	a080004c 	andi	r2,r20,1
81132cd4:	0039883a 	mov	fp,zero
81132cd8:	10000526 	beq	r2,zero,81132cf0 <___vfiprintf_internal_r+0x1430>
81132cdc:	00800c04 	movi	r2,48
81132ce0:	d88019c5 	stb	r2,103(sp)
81132ce4:	dcc02717 	ldw	r19,156(sp)
81132ce8:	dd4019c4 	addi	r21,sp,103
81132cec:	003bf606 	br	81131cc8 <__reset+0xfb111cc8>
81132cf0:	0027883a 	mov	r19,zero
81132cf4:	dd401a04 	addi	r21,sp,104
81132cf8:	003bf306 	br	81131cc8 <__reset+0xfb111cc8>
81132cfc:	d9c01d85 	stb	r7,118(sp)
81132d00:	003dc806 	br	81132424 <__reset+0xfb112424>
81132d04:	d9c01d85 	stb	r7,118(sp)
81132d08:	003d3a06 	br	811321f4 <__reset+0xfb1121f4>
81132d0c:	d9c01d85 	stb	r7,118(sp)
81132d10:	003d2a06 	br	811321bc <__reset+0xfb1121bc>
81132d14:	d9c01d85 	stb	r7,118(sp)
81132d18:	003cde06 	br	81132094 <__reset+0xfb112094>
81132d1c:	d9c01d85 	stb	r7,118(sp)
81132d20:	003cbc06 	br	81132014 <__reset+0xfb112014>

81132d24 <__vfiprintf_internal>:
81132d24:	00a04574 	movhi	r2,33045
81132d28:	108d0f04 	addi	r2,r2,13372
81132d2c:	300f883a 	mov	r7,r6
81132d30:	280d883a 	mov	r6,r5
81132d34:	200b883a 	mov	r5,r4
81132d38:	11000017 	ldw	r4,0(r2)
81132d3c:	11318c01 	jmpi	811318c0 <___vfiprintf_internal_r>

81132d40 <__sbprintf>:
81132d40:	defee204 	addi	sp,sp,-1144
81132d44:	de00012e 	bgeu	sp,et,81132d4c <__sbprintf+0xc>
81132d48:	003b68fa 	trap	3
81132d4c:	2880030b 	ldhu	r2,12(r5)
81132d50:	2ac01917 	ldw	r11,100(r5)
81132d54:	2a80038b 	ldhu	r10,14(r5)
81132d58:	2a400717 	ldw	r9,28(r5)
81132d5c:	2a000917 	ldw	r8,36(r5)
81132d60:	00c10004 	movi	r3,1024
81132d64:	dc011a15 	stw	r16,1128(sp)
81132d68:	10bfff4c 	andi	r2,r2,65533
81132d6c:	2821883a 	mov	r16,r5
81132d70:	d8cb883a 	add	r5,sp,r3
81132d74:	dc811c15 	stw	r18,1136(sp)
81132d78:	dc411b15 	stw	r17,1132(sp)
81132d7c:	dfc11d15 	stw	ra,1140(sp)
81132d80:	2025883a 	mov	r18,r4
81132d84:	d881030d 	sth	r2,1036(sp)
81132d88:	dac11915 	stw	r11,1124(sp)
81132d8c:	da81038d 	sth	r10,1038(sp)
81132d90:	da410715 	stw	r9,1052(sp)
81132d94:	da010915 	stw	r8,1060(sp)
81132d98:	dec10015 	stw	sp,1024(sp)
81132d9c:	dec10415 	stw	sp,1040(sp)
81132da0:	d8c10215 	stw	r3,1032(sp)
81132da4:	d8c10515 	stw	r3,1044(sp)
81132da8:	d8010615 	stw	zero,1048(sp)
81132dac:	11318c00 	call	811318c0 <___vfiprintf_internal_r>
81132db0:	1023883a 	mov	r17,r2
81132db4:	10000416 	blt	r2,zero,81132dc8 <__sbprintf+0x88>
81132db8:	d9410004 	addi	r5,sp,1024
81132dbc:	9009883a 	mov	r4,r18
81132dc0:	112b3600 	call	8112b360 <_fflush_r>
81132dc4:	10000d1e 	bne	r2,zero,81132dfc <__sbprintf+0xbc>
81132dc8:	d881030b 	ldhu	r2,1036(sp)
81132dcc:	1080100c 	andi	r2,r2,64
81132dd0:	10000326 	beq	r2,zero,81132de0 <__sbprintf+0xa0>
81132dd4:	8080030b 	ldhu	r2,12(r16)
81132dd8:	10801014 	ori	r2,r2,64
81132ddc:	8080030d 	sth	r2,12(r16)
81132de0:	8805883a 	mov	r2,r17
81132de4:	dfc11d17 	ldw	ra,1140(sp)
81132de8:	dc811c17 	ldw	r18,1136(sp)
81132dec:	dc411b17 	ldw	r17,1132(sp)
81132df0:	dc011a17 	ldw	r16,1128(sp)
81132df4:	dec11e04 	addi	sp,sp,1144
81132df8:	f800283a 	ret
81132dfc:	047fffc4 	movi	r17,-1
81132e00:	003ff106 	br	81132dc8 <__reset+0xfb112dc8>

81132e04 <_calloc_r>:
81132e04:	298b383a 	mul	r5,r5,r6
81132e08:	defffe04 	addi	sp,sp,-8
81132e0c:	de00012e 	bgeu	sp,et,81132e14 <_calloc_r+0x10>
81132e10:	003b68fa 	trap	3
81132e14:	dfc00115 	stw	ra,4(sp)
81132e18:	dc000015 	stw	r16,0(sp)
81132e1c:	1121e7c0 	call	81121e7c <_malloc_r>
81132e20:	10002926 	beq	r2,zero,81132ec8 <_calloc_r+0xc4>
81132e24:	11bfff17 	ldw	r6,-4(r2)
81132e28:	1021883a 	mov	r16,r2
81132e2c:	00bfff04 	movi	r2,-4
81132e30:	308c703a 	and	r6,r6,r2
81132e34:	00c00904 	movi	r3,36
81132e38:	308d883a 	add	r6,r6,r2
81132e3c:	19801636 	bltu	r3,r6,81132e98 <_calloc_r+0x94>
81132e40:	008004c4 	movi	r2,19
81132e44:	11800b2e 	bgeu	r2,r6,81132e74 <_calloc_r+0x70>
81132e48:	80000015 	stw	zero,0(r16)
81132e4c:	80000115 	stw	zero,4(r16)
81132e50:	008006c4 	movi	r2,27
81132e54:	11801a2e 	bgeu	r2,r6,81132ec0 <_calloc_r+0xbc>
81132e58:	80000215 	stw	zero,8(r16)
81132e5c:	80000315 	stw	zero,12(r16)
81132e60:	30c0151e 	bne	r6,r3,81132eb8 <_calloc_r+0xb4>
81132e64:	80000415 	stw	zero,16(r16)
81132e68:	80800604 	addi	r2,r16,24
81132e6c:	80000515 	stw	zero,20(r16)
81132e70:	00000106 	br	81132e78 <_calloc_r+0x74>
81132e74:	8005883a 	mov	r2,r16
81132e78:	10000015 	stw	zero,0(r2)
81132e7c:	10000115 	stw	zero,4(r2)
81132e80:	10000215 	stw	zero,8(r2)
81132e84:	8005883a 	mov	r2,r16
81132e88:	dfc00117 	ldw	ra,4(sp)
81132e8c:	dc000017 	ldw	r16,0(sp)
81132e90:	dec00204 	addi	sp,sp,8
81132e94:	f800283a 	ret
81132e98:	000b883a 	mov	r5,zero
81132e9c:	8009883a 	mov	r4,r16
81132ea0:	11227e00 	call	811227e0 <memset>
81132ea4:	8005883a 	mov	r2,r16
81132ea8:	dfc00117 	ldw	ra,4(sp)
81132eac:	dc000017 	ldw	r16,0(sp)
81132eb0:	dec00204 	addi	sp,sp,8
81132eb4:	f800283a 	ret
81132eb8:	80800404 	addi	r2,r16,16
81132ebc:	003fee06 	br	81132e78 <__reset+0xfb112e78>
81132ec0:	80800204 	addi	r2,r16,8
81132ec4:	003fec06 	br	81132e78 <__reset+0xfb112e78>
81132ec8:	0005883a 	mov	r2,zero
81132ecc:	003fee06 	br	81132e88 <__reset+0xfb112e88>

81132ed0 <_fclose_r>:
81132ed0:	28003b26 	beq	r5,zero,81132fc0 <_fclose_r+0xf0>
81132ed4:	defffc04 	addi	sp,sp,-16
81132ed8:	de00012e 	bgeu	sp,et,81132ee0 <_fclose_r+0x10>
81132edc:	003b68fa 	trap	3
81132ee0:	dc400115 	stw	r17,4(sp)
81132ee4:	dc000015 	stw	r16,0(sp)
81132ee8:	dfc00315 	stw	ra,12(sp)
81132eec:	dc800215 	stw	r18,8(sp)
81132ef0:	2023883a 	mov	r17,r4
81132ef4:	2821883a 	mov	r16,r5
81132ef8:	20000226 	beq	r4,zero,81132f04 <_fclose_r+0x34>
81132efc:	20800e17 	ldw	r2,56(r4)
81132f00:	10002726 	beq	r2,zero,81132fa0 <_fclose_r+0xd0>
81132f04:	8080030f 	ldh	r2,12(r16)
81132f08:	1000071e 	bne	r2,zero,81132f28 <_fclose_r+0x58>
81132f0c:	0005883a 	mov	r2,zero
81132f10:	dfc00317 	ldw	ra,12(sp)
81132f14:	dc800217 	ldw	r18,8(sp)
81132f18:	dc400117 	ldw	r17,4(sp)
81132f1c:	dc000017 	ldw	r16,0(sp)
81132f20:	dec00404 	addi	sp,sp,16
81132f24:	f800283a 	ret
81132f28:	800b883a 	mov	r5,r16
81132f2c:	8809883a 	mov	r4,r17
81132f30:	112b13c0 	call	8112b13c <__sflush_r>
81132f34:	1025883a 	mov	r18,r2
81132f38:	80800b17 	ldw	r2,44(r16)
81132f3c:	10000426 	beq	r2,zero,81132f50 <_fclose_r+0x80>
81132f40:	81400717 	ldw	r5,28(r16)
81132f44:	8809883a 	mov	r4,r17
81132f48:	103ee83a 	callr	r2
81132f4c:	10001616 	blt	r2,zero,81132fa8 <_fclose_r+0xd8>
81132f50:	8080030b 	ldhu	r2,12(r16)
81132f54:	1080200c 	andi	r2,r2,128
81132f58:	1000151e 	bne	r2,zero,81132fb0 <_fclose_r+0xe0>
81132f5c:	81400c17 	ldw	r5,48(r16)
81132f60:	28000526 	beq	r5,zero,81132f78 <_fclose_r+0xa8>
81132f64:	80801004 	addi	r2,r16,64
81132f68:	28800226 	beq	r5,r2,81132f74 <_fclose_r+0xa4>
81132f6c:	8809883a 	mov	r4,r17
81132f70:	112bbf40 	call	8112bbf4 <_free_r>
81132f74:	80000c15 	stw	zero,48(r16)
81132f78:	81401117 	ldw	r5,68(r16)
81132f7c:	28000326 	beq	r5,zero,81132f8c <_fclose_r+0xbc>
81132f80:	8809883a 	mov	r4,r17
81132f84:	112bbf40 	call	8112bbf4 <_free_r>
81132f88:	80001115 	stw	zero,68(r16)
81132f8c:	112b76c0 	call	8112b76c <__sfp_lock_acquire>
81132f90:	8000030d 	sth	zero,12(r16)
81132f94:	112b7700 	call	8112b770 <__sfp_lock_release>
81132f98:	9005883a 	mov	r2,r18
81132f9c:	003fdc06 	br	81132f10 <__reset+0xfb112f10>
81132fa0:	112b75c0 	call	8112b75c <__sinit>
81132fa4:	003fd706 	br	81132f04 <__reset+0xfb112f04>
81132fa8:	04bfffc4 	movi	r18,-1
81132fac:	003fe806 	br	81132f50 <__reset+0xfb112f50>
81132fb0:	81400417 	ldw	r5,16(r16)
81132fb4:	8809883a 	mov	r4,r17
81132fb8:	112bbf40 	call	8112bbf4 <_free_r>
81132fbc:	003fe706 	br	81132f5c <__reset+0xfb112f5c>
81132fc0:	0005883a 	mov	r2,zero
81132fc4:	f800283a 	ret

81132fc8 <fclose>:
81132fc8:	00a04574 	movhi	r2,33045
81132fcc:	108d0f04 	addi	r2,r2,13372
81132fd0:	200b883a 	mov	r5,r4
81132fd4:	11000017 	ldw	r4,0(r2)
81132fd8:	1132ed01 	jmpi	81132ed0 <_fclose_r>

81132fdc <__fputwc>:
81132fdc:	defff804 	addi	sp,sp,-32
81132fe0:	de00012e 	bgeu	sp,et,81132fe8 <__fputwc+0xc>
81132fe4:	003b68fa 	trap	3
81132fe8:	dcc00415 	stw	r19,16(sp)
81132fec:	dc800315 	stw	r18,12(sp)
81132ff0:	dc000115 	stw	r16,4(sp)
81132ff4:	dfc00715 	stw	ra,28(sp)
81132ff8:	dd400615 	stw	r21,24(sp)
81132ffc:	dd000515 	stw	r20,20(sp)
81133000:	dc400215 	stw	r17,8(sp)
81133004:	2027883a 	mov	r19,r4
81133008:	2825883a 	mov	r18,r5
8113300c:	3021883a 	mov	r16,r6
81133010:	112c6840 	call	8112c684 <__locale_mb_cur_max>
81133014:	00c00044 	movi	r3,1
81133018:	10c03e26 	beq	r2,r3,81133114 <__fputwc+0x138>
8113301c:	81c01704 	addi	r7,r16,92
81133020:	900d883a 	mov	r6,r18
81133024:	d80b883a 	mov	r5,sp
81133028:	9809883a 	mov	r4,r19
8113302c:	1133e600 	call	81133e60 <_wcrtomb_r>
81133030:	1029883a 	mov	r20,r2
81133034:	00bfffc4 	movi	r2,-1
81133038:	a0802026 	beq	r20,r2,811330bc <__fputwc+0xe0>
8113303c:	d9400003 	ldbu	r5,0(sp)
81133040:	a0001c26 	beq	r20,zero,811330b4 <__fputwc+0xd8>
81133044:	0023883a 	mov	r17,zero
81133048:	05400284 	movi	r21,10
8113304c:	00000906 	br	81133074 <__fputwc+0x98>
81133050:	80800017 	ldw	r2,0(r16)
81133054:	11400005 	stb	r5,0(r2)
81133058:	80c00017 	ldw	r3,0(r16)
8113305c:	18c00044 	addi	r3,r3,1
81133060:	80c00015 	stw	r3,0(r16)
81133064:	8c400044 	addi	r17,r17,1
81133068:	dc45883a 	add	r2,sp,r17
8113306c:	8d00112e 	bgeu	r17,r20,811330b4 <__fputwc+0xd8>
81133070:	11400003 	ldbu	r5,0(r2)
81133074:	80c00217 	ldw	r3,8(r16)
81133078:	18ffffc4 	addi	r3,r3,-1
8113307c:	80c00215 	stw	r3,8(r16)
81133080:	183ff30e 	bge	r3,zero,81133050 <__reset+0xfb113050>
81133084:	80800617 	ldw	r2,24(r16)
81133088:	18801916 	blt	r3,r2,811330f0 <__fputwc+0x114>
8113308c:	80800017 	ldw	r2,0(r16)
81133090:	11400005 	stb	r5,0(r2)
81133094:	80800017 	ldw	r2,0(r16)
81133098:	10c00003 	ldbu	r3,0(r2)
8113309c:	10800044 	addi	r2,r2,1
811330a0:	1d402326 	beq	r3,r21,81133130 <__fputwc+0x154>
811330a4:	80800015 	stw	r2,0(r16)
811330a8:	8c400044 	addi	r17,r17,1
811330ac:	dc45883a 	add	r2,sp,r17
811330b0:	8d3fef36 	bltu	r17,r20,81133070 <__reset+0xfb113070>
811330b4:	9005883a 	mov	r2,r18
811330b8:	00000406 	br	811330cc <__fputwc+0xf0>
811330bc:	80c0030b 	ldhu	r3,12(r16)
811330c0:	a005883a 	mov	r2,r20
811330c4:	18c01014 	ori	r3,r3,64
811330c8:	80c0030d 	sth	r3,12(r16)
811330cc:	dfc00717 	ldw	ra,28(sp)
811330d0:	dd400617 	ldw	r21,24(sp)
811330d4:	dd000517 	ldw	r20,20(sp)
811330d8:	dcc00417 	ldw	r19,16(sp)
811330dc:	dc800317 	ldw	r18,12(sp)
811330e0:	dc400217 	ldw	r17,8(sp)
811330e4:	dc000117 	ldw	r16,4(sp)
811330e8:	dec00804 	addi	sp,sp,32
811330ec:	f800283a 	ret
811330f0:	800d883a 	mov	r6,r16
811330f4:	29403fcc 	andi	r5,r5,255
811330f8:	9809883a 	mov	r4,r19
811330fc:	11295240 	call	81129524 <__swbuf_r>
81133100:	10bfffe0 	cmpeqi	r2,r2,-1
81133104:	10803fcc 	andi	r2,r2,255
81133108:	103fd626 	beq	r2,zero,81133064 <__reset+0xfb113064>
8113310c:	00bfffc4 	movi	r2,-1
81133110:	003fee06 	br	811330cc <__reset+0xfb1130cc>
81133114:	90ffffc4 	addi	r3,r18,-1
81133118:	01003f84 	movi	r4,254
8113311c:	20ffbf36 	bltu	r4,r3,8113301c <__reset+0xfb11301c>
81133120:	900b883a 	mov	r5,r18
81133124:	dc800005 	stb	r18,0(sp)
81133128:	1029883a 	mov	r20,r2
8113312c:	003fc506 	br	81133044 <__reset+0xfb113044>
81133130:	800d883a 	mov	r6,r16
81133134:	a80b883a 	mov	r5,r21
81133138:	9809883a 	mov	r4,r19
8113313c:	11295240 	call	81129524 <__swbuf_r>
81133140:	10bfffe0 	cmpeqi	r2,r2,-1
81133144:	003fef06 	br	81133104 <__reset+0xfb113104>

81133148 <_fputwc_r>:
81133148:	3080030b 	ldhu	r2,12(r6)
8113314c:	10c8000c 	andi	r3,r2,8192
81133150:	1800051e 	bne	r3,zero,81133168 <_fputwc_r+0x20>
81133154:	30c01917 	ldw	r3,100(r6)
81133158:	10880014 	ori	r2,r2,8192
8113315c:	3080030d 	sth	r2,12(r6)
81133160:	18880014 	ori	r2,r3,8192
81133164:	30801915 	stw	r2,100(r6)
81133168:	1132fdc1 	jmpi	81132fdc <__fputwc>

8113316c <fputwc>:
8113316c:	00a04574 	movhi	r2,33045
81133170:	defffc04 	addi	sp,sp,-16
81133174:	108d0f04 	addi	r2,r2,13372
81133178:	de00012e 	bgeu	sp,et,81133180 <fputwc+0x14>
8113317c:	003b68fa 	trap	3
81133180:	dc000115 	stw	r16,4(sp)
81133184:	14000017 	ldw	r16,0(r2)
81133188:	dc400215 	stw	r17,8(sp)
8113318c:	dfc00315 	stw	ra,12(sp)
81133190:	2023883a 	mov	r17,r4
81133194:	80000226 	beq	r16,zero,811331a0 <fputwc+0x34>
81133198:	80800e17 	ldw	r2,56(r16)
8113319c:	10001026 	beq	r2,zero,811331e0 <fputwc+0x74>
811331a0:	2880030b 	ldhu	r2,12(r5)
811331a4:	10c8000c 	andi	r3,r2,8192
811331a8:	1800051e 	bne	r3,zero,811331c0 <fputwc+0x54>
811331ac:	28c01917 	ldw	r3,100(r5)
811331b0:	10880014 	ori	r2,r2,8192
811331b4:	2880030d 	sth	r2,12(r5)
811331b8:	18880014 	ori	r2,r3,8192
811331bc:	28801915 	stw	r2,100(r5)
811331c0:	280d883a 	mov	r6,r5
811331c4:	8009883a 	mov	r4,r16
811331c8:	880b883a 	mov	r5,r17
811331cc:	dfc00317 	ldw	ra,12(sp)
811331d0:	dc400217 	ldw	r17,8(sp)
811331d4:	dc000117 	ldw	r16,4(sp)
811331d8:	dec00404 	addi	sp,sp,16
811331dc:	1132fdc1 	jmpi	81132fdc <__fputwc>
811331e0:	8009883a 	mov	r4,r16
811331e4:	d9400015 	stw	r5,0(sp)
811331e8:	112b75c0 	call	8112b75c <__sinit>
811331ec:	d9400017 	ldw	r5,0(sp)
811331f0:	003feb06 	br	811331a0 <__reset+0xfb1131a0>

811331f4 <rshift>:
811331f4:	2807d17a 	srai	r3,r5,5
811331f8:	20800417 	ldw	r2,16(r4)
811331fc:	22000504 	addi	r8,r4,20
81133200:	1880250e 	bge	r3,r2,81133298 <rshift+0xa4>
81133204:	1085883a 	add	r2,r2,r2
81133208:	18c7883a 	add	r3,r3,r3
8113320c:	1085883a 	add	r2,r2,r2
81133210:	18c7883a 	add	r3,r3,r3
81133214:	294007cc 	andi	r5,r5,31
81133218:	4085883a 	add	r2,r8,r2
8113321c:	40c7883a 	add	r3,r8,r3
81133220:	28002026 	beq	r5,zero,811332a4 <rshift+0xb0>
81133224:	19800017 	ldw	r6,0(r3)
81133228:	02c00804 	movi	r11,32
8113322c:	19c00104 	addi	r7,r3,4
81133230:	5957c83a 	sub	r11,r11,r5
81133234:	314cd83a 	srl	r6,r6,r5
81133238:	38802c2e 	bgeu	r7,r2,811332ec <rshift+0xf8>
8113323c:	4015883a 	mov	r10,r8
81133240:	3a400017 	ldw	r9,0(r7)
81133244:	52800104 	addi	r10,r10,4
81133248:	39c00104 	addi	r7,r7,4
8113324c:	4ad2983a 	sll	r9,r9,r11
81133250:	498cb03a 	or	r6,r9,r6
81133254:	51bfff15 	stw	r6,-4(r10)
81133258:	39bfff17 	ldw	r6,-4(r7)
8113325c:	314cd83a 	srl	r6,r6,r5
81133260:	38bff736 	bltu	r7,r2,81133240 <__reset+0xfb113240>
81133264:	10c7c83a 	sub	r3,r2,r3
81133268:	18fffec4 	addi	r3,r3,-5
8113326c:	1806d0ba 	srli	r3,r3,2
81133270:	18c00044 	addi	r3,r3,1
81133274:	18c7883a 	add	r3,r3,r3
81133278:	18c7883a 	add	r3,r3,r3
8113327c:	40c7883a 	add	r3,r8,r3
81133280:	19800015 	stw	r6,0(r3)
81133284:	30000126 	beq	r6,zero,8113328c <rshift+0x98>
81133288:	18c00104 	addi	r3,r3,4
8113328c:	1a05c83a 	sub	r2,r3,r8
81133290:	1005d0ba 	srai	r2,r2,2
81133294:	00001206 	br	811332e0 <rshift+0xec>
81133298:	20000415 	stw	zero,16(r4)
8113329c:	20000515 	stw	zero,20(r4)
811332a0:	f800283a 	ret
811332a4:	18bffc2e 	bgeu	r3,r2,81133298 <__reset+0xfb113298>
811332a8:	180d883a 	mov	r6,r3
811332ac:	400b883a 	mov	r5,r8
811332b0:	31c00017 	ldw	r7,0(r6)
811332b4:	29400104 	addi	r5,r5,4
811332b8:	31800104 	addi	r6,r6,4
811332bc:	29ffff15 	stw	r7,-4(r5)
811332c0:	30bffb36 	bltu	r6,r2,811332b0 <__reset+0xfb1132b0>
811332c4:	00c6303a 	nor	r3,zero,r3
811332c8:	1885883a 	add	r2,r3,r2
811332cc:	1004d0ba 	srli	r2,r2,2
811332d0:	10800044 	addi	r2,r2,1
811332d4:	1085883a 	add	r2,r2,r2
811332d8:	1085883a 	add	r2,r2,r2
811332dc:	1005d0ba 	srai	r2,r2,2
811332e0:	20800415 	stw	r2,16(r4)
811332e4:	103fed26 	beq	r2,zero,8113329c <__reset+0xfb11329c>
811332e8:	f800283a 	ret
811332ec:	4007883a 	mov	r3,r8
811332f0:	003fe306 	br	81133280 <__reset+0xfb113280>

811332f4 <__gethex>:
811332f4:	deffeb04 	addi	sp,sp,-84
811332f8:	de00012e 	bgeu	sp,et,81133300 <__gethex+0xc>
811332fc:	003b68fa 	trap	3
81133300:	dfc01415 	stw	ra,80(sp)
81133304:	dd801115 	stw	r22,68(sp)
81133308:	dcc00e15 	stw	r19,56(sp)
8113330c:	dc800d15 	stw	r18,52(sp)
81133310:	2827883a 	mov	r19,r5
81133314:	d9000115 	stw	r4,4(sp)
81133318:	d9800015 	stw	r6,0(sp)
8113331c:	d9c00415 	stw	r7,16(sp)
81133320:	df001315 	stw	fp,76(sp)
81133324:	ddc01215 	stw	r23,72(sp)
81133328:	dd401015 	stw	r21,64(sp)
8113332c:	dd000f15 	stw	r20,60(sp)
81133330:	dc400c15 	stw	r17,48(sp)
81133334:	dc000b15 	stw	r16,44(sp)
81133338:	112c6a80 	call	8112c6a8 <_localeconv_r>
8113333c:	14800017 	ldw	r18,0(r2)
81133340:	9009883a 	mov	r4,r18
81133344:	11231840 	call	81123184 <strlen>
81133348:	98c00017 	ldw	r3,0(r19)
8113334c:	102d883a 	mov	r22,r2
81133350:	9085883a 	add	r2,r18,r2
81133354:	10bfffc3 	ldbu	r2,-1(r2)
81133358:	19000083 	ldbu	r4,2(r3)
8113335c:	d8800305 	stb	r2,12(sp)
81133360:	00800c04 	movi	r2,48
81133364:	2081521e 	bne	r4,r2,811338b0 <__gethex+0x5bc>
81133368:	017fff84 	movi	r5,-2
8113336c:	188000c4 	addi	r2,r3,3
81133370:	28cbc83a 	sub	r5,r5,r3
81133374:	200d883a 	mov	r6,r4
81133378:	28a3883a 	add	r17,r5,r2
8113337c:	102b883a 	mov	r21,r2
81133380:	10800044 	addi	r2,r2,1
81133384:	113fffc3 	ldbu	r4,-1(r2)
81133388:	21bffb26 	beq	r4,r6,81133378 <__reset+0xfb113378>
8113338c:	05204574 	movhi	r20,33045
81133390:	a503da04 	addi	r20,r20,3944
81133394:	a109883a 	add	r4,r20,r4
81133398:	20800003 	ldbu	r2,0(r4)
8113339c:	10008826 	beq	r2,zero,811335c0 <__gethex+0x2cc>
811333a0:	a8800003 	ldbu	r2,0(r21)
811333a4:	0015883a 	mov	r10,zero
811333a8:	002f883a 	mov	r23,zero
811333ac:	a085883a 	add	r2,r20,r2
811333b0:	10800003 	ldbu	r2,0(r2)
811333b4:	a821883a 	mov	r16,r21
811333b8:	10000526 	beq	r2,zero,811333d0 <__gethex+0xdc>
811333bc:	84000044 	addi	r16,r16,1
811333c0:	80800003 	ldbu	r2,0(r16)
811333c4:	a085883a 	add	r2,r20,r2
811333c8:	10800003 	ldbu	r2,0(r2)
811333cc:	103ffb1e 	bne	r2,zero,811333bc <__reset+0xfb1133bc>
811333d0:	b00d883a 	mov	r6,r22
811333d4:	900b883a 	mov	r5,r18
811333d8:	8009883a 	mov	r4,r16
811333dc:	da800a15 	stw	r10,40(sp)
811333e0:	1133d900 	call	81133d90 <strncmp>
811333e4:	da800a17 	ldw	r10,40(sp)
811333e8:	1000031e 	bne	r2,zero,811333f8 <__gethex+0x104>
811333ec:	b8015226 	beq	r23,zero,81133938 <__gethex+0x644>
811333f0:	80800003 	ldbu	r2,0(r16)
811333f4:	00000206 	br	81133400 <__gethex+0x10c>
811333f8:	80800003 	ldbu	r2,0(r16)
811333fc:	b8011f26 	beq	r23,zero,8113387c <__gethex+0x588>
81133400:	85efc83a 	sub	r23,r16,r23
81133404:	bdef883a 	add	r23,r23,r23
81133408:	bdef883a 	add	r23,r23,r23
8113340c:	05efc83a 	sub	r23,zero,r23
81133410:	10803fcc 	andi	r2,r2,255
81133414:	01001404 	movi	r4,80
81133418:	11008626 	beq	r2,r4,81133634 <__gethex+0x340>
8113341c:	01001c04 	movi	r4,112
81133420:	11008426 	beq	r2,r4,81133634 <__gethex+0x340>
81133424:	8039883a 	mov	fp,r16
81133428:	9c000015 	stw	r16,0(r19)
8113342c:	5000711e 	bne	r10,zero,811335f4 <__gethex+0x300>
81133430:	e545c83a 	sub	r2,fp,r21
81133434:	10bfffc4 	addi	r2,r2,-1
81133438:	010001c4 	movi	r4,7
8113343c:	000b883a 	mov	r5,zero
81133440:	2080030e 	bge	r4,r2,81133450 <__gethex+0x15c>
81133444:	1005d07a 	srai	r2,r2,1
81133448:	29400044 	addi	r5,r5,1
8113344c:	20bffd16 	blt	r4,r2,81133444 <__reset+0xfb113444>
81133450:	d9000117 	ldw	r4,4(sp)
81133454:	112cbc40 	call	8112cbc4 <_Balloc>
81133458:	10c00504 	addi	r3,r2,20
8113345c:	d8c00215 	stw	r3,8(sp)
81133460:	1021883a 	mov	r16,r2
81133464:	af01732e 	bgeu	r21,fp,81133a34 <__gethex+0x740>
81133468:	dc400303 	ldbu	r17,12(sp)
8113346c:	03400044 	movi	r13,1
81133470:	1815883a 	mov	r10,r3
81133474:	0013883a 	mov	r9,zero
81133478:	0027883a 	mov	r19,zero
8113347c:	6d9bc83a 	sub	r13,r13,r22
81133480:	02c00804 	movi	r11,32
81133484:	e0bfffc3 	ldbu	r2,-1(fp)
81133488:	e3bfffc4 	addi	r14,fp,-1
8113348c:	88803026 	beq	r17,r2,81133550 <__gethex+0x25c>
81133490:	9ac04526 	beq	r19,r11,811335a8 <__gethex+0x2b4>
81133494:	980b883a 	mov	r5,r19
81133498:	9cc00104 	addi	r19,r19,4
8113349c:	e13fffc3 	ldbu	r4,-1(fp)
811334a0:	7039883a 	mov	fp,r14
811334a4:	a109883a 	add	r4,r20,r4
811334a8:	20800003 	ldbu	r2,0(r4)
811334ac:	108003cc 	andi	r2,r2,15
811334b0:	1144983a 	sll	r2,r2,r5
811334b4:	4892b03a 	or	r9,r9,r2
811334b8:	af3ff236 	bltu	r21,fp,81133484 <__reset+0xfb113484>
811334bc:	d8c00217 	ldw	r3,8(sp)
811334c0:	50800104 	addi	r2,r10,4
811334c4:	52400015 	stw	r9,0(r10)
811334c8:	10c5c83a 	sub	r2,r2,r3
811334cc:	1005d0ba 	srai	r2,r2,2
811334d0:	4809883a 	mov	r4,r9
811334d4:	80800415 	stw	r2,16(r16)
811334d8:	1022917a 	slli	r17,r2,5
811334dc:	112ced00 	call	8112ced0 <__hi0bits>
811334e0:	d8c00017 	ldw	r3,0(sp)
811334e4:	8885c83a 	sub	r2,r17,r2
811334e8:	1c800017 	ldw	r18,0(r3)
811334ec:	9080c716 	blt	r18,r2,8113380c <__gethex+0x518>
811334f0:	1480e416 	blt	r2,r18,81133884 <__gethex+0x590>
811334f4:	0027883a 	mov	r19,zero
811334f8:	d8c00017 	ldw	r3,0(sp)
811334fc:	18800217 	ldw	r2,8(r3)
81133500:	15c08d16 	blt	r2,r23,81133738 <__gethex+0x444>
81133504:	d8c00017 	ldw	r3,0(sp)
81133508:	18800117 	ldw	r2,4(r3)
8113350c:	b880aa0e 	bge	r23,r2,811337b8 <__gethex+0x4c4>
81133510:	15efc83a 	sub	r23,r2,r23
81133514:	bc80ed16 	blt	r23,r18,811338cc <__gethex+0x5d8>
81133518:	18c00317 	ldw	r3,12(r3)
8113351c:	01000084 	movi	r4,2
81133520:	19014926 	beq	r3,r4,81133a48 <__gethex+0x754>
81133524:	010000c4 	movi	r4,3
81133528:	19012e26 	beq	r3,r4,811339e4 <__gethex+0x6f0>
8113352c:	01000044 	movi	r4,1
81133530:	19014826 	beq	r3,r4,81133a54 <__gethex+0x760>
81133534:	d9000117 	ldw	r4,4(sp)
81133538:	800b883a 	mov	r5,r16
8113353c:	112cc740 	call	8112cc74 <_Bfree>
81133540:	d8801517 	ldw	r2,84(sp)
81133544:	10000015 	stw	zero,0(r2)
81133548:	00801404 	movi	r2,80
8113354c:	00002b06 	br	811335fc <__gethex+0x308>
81133550:	735f883a 	add	r15,r14,r13
81133554:	7d7fce36 	bltu	r15,r21,81133490 <__reset+0xfb113490>
81133558:	7809883a 	mov	r4,r15
8113355c:	b00d883a 	mov	r6,r22
81133560:	900b883a 	mov	r5,r18
81133564:	da400515 	stw	r9,20(sp)
81133568:	da800a15 	stw	r10,40(sp)
8113356c:	dac00915 	stw	r11,36(sp)
81133570:	db400815 	stw	r13,32(sp)
81133574:	db800615 	stw	r14,24(sp)
81133578:	dbc00715 	stw	r15,28(sp)
8113357c:	1133d900 	call	81133d90 <strncmp>
81133580:	da400517 	ldw	r9,20(sp)
81133584:	da800a17 	ldw	r10,40(sp)
81133588:	dac00917 	ldw	r11,36(sp)
8113358c:	db400817 	ldw	r13,32(sp)
81133590:	db800617 	ldw	r14,24(sp)
81133594:	dbc00717 	ldw	r15,28(sp)
81133598:	103fbd1e 	bne	r2,zero,81133490 <__reset+0xfb113490>
8113359c:	7839883a 	mov	fp,r15
811335a0:	af3fb836 	bltu	r21,fp,81133484 <__reset+0xfb113484>
811335a4:	003fc506 	br	811334bc <__reset+0xfb1134bc>
811335a8:	04c00104 	movi	r19,4
811335ac:	52400015 	stw	r9,0(r10)
811335b0:	000b883a 	mov	r5,zero
811335b4:	54d5883a 	add	r10,r10,r19
811335b8:	0013883a 	mov	r9,zero
811335bc:	003fb706 	br	8113349c <__reset+0xfb11349c>
811335c0:	b00d883a 	mov	r6,r22
811335c4:	900b883a 	mov	r5,r18
811335c8:	a809883a 	mov	r4,r21
811335cc:	1133d900 	call	81133d90 <strncmp>
811335d0:	10006426 	beq	r2,zero,81133764 <__gethex+0x470>
811335d4:	a8800003 	ldbu	r2,0(r21)
811335d8:	a821883a 	mov	r16,r21
811335dc:	10803fcc 	andi	r2,r2,255
811335e0:	01001404 	movi	r4,80
811335e4:	11001126 	beq	r2,r4,8113362c <__gethex+0x338>
811335e8:	01001c04 	movi	r4,112
811335ec:	11000f26 	beq	r2,r4,8113362c <__gethex+0x338>
811335f0:	9c000015 	stw	r16,0(r19)
811335f4:	8800831e 	bne	r17,zero,81133804 <__gethex+0x510>
811335f8:	00800184 	movi	r2,6
811335fc:	dfc01417 	ldw	ra,80(sp)
81133600:	df001317 	ldw	fp,76(sp)
81133604:	ddc01217 	ldw	r23,72(sp)
81133608:	dd801117 	ldw	r22,68(sp)
8113360c:	dd401017 	ldw	r21,64(sp)
81133610:	dd000f17 	ldw	r20,60(sp)
81133614:	dcc00e17 	ldw	r19,56(sp)
81133618:	dc800d17 	ldw	r18,52(sp)
8113361c:	dc400c17 	ldw	r17,48(sp)
81133620:	dc000b17 	ldw	r16,44(sp)
81133624:	dec01504 	addi	sp,sp,84
81133628:	f800283a 	ret
8113362c:	002f883a 	mov	r23,zero
81133630:	02800044 	movi	r10,1
81133634:	80800043 	ldbu	r2,1(r16)
81133638:	01400ac4 	movi	r5,43
8113363c:	11003fcc 	andi	r4,r2,255
81133640:	21406e26 	beq	r4,r5,811337fc <__gethex+0x508>
81133644:	01400b44 	movi	r5,45
81133648:	21404226 	beq	r4,r5,81133754 <__gethex+0x460>
8113364c:	81400044 	addi	r5,r16,1
81133650:	000d883a 	mov	r6,zero
81133654:	10803fcc 	andi	r2,r2,255
81133658:	a085883a 	add	r2,r20,r2
8113365c:	11000003 	ldbu	r4,0(r2)
81133660:	03000604 	movi	r12,24
81133664:	20bfffc4 	addi	r2,r4,-1
81133668:	10803fcc 	andi	r2,r2,255
8113366c:	60bf6d36 	bltu	r12,r2,81133424 <__reset+0xfb113424>
81133670:	2ac00043 	ldbu	r11,1(r5)
81133674:	20803fcc 	andi	r2,r4,255
81133678:	01204574 	movhi	r4,33045
8113367c:	2103da04 	addi	r4,r4,3944
81133680:	22c9883a 	add	r4,r4,r11
81133684:	23400003 	ldbu	r13,0(r4)
81133688:	10bffc04 	addi	r2,r2,-16
8113368c:	29400044 	addi	r5,r5,1
81133690:	693fffc4 	addi	r4,r13,-1
81133694:	21003fcc 	andi	r4,r4,255
81133698:	6b403fcc 	andi	r13,r13,255
8113369c:	61000b36 	bltu	r12,r4,811336cc <__gethex+0x3d8>
811336a0:	29400044 	addi	r5,r5,1
811336a4:	29000003 	ldbu	r4,0(r5)
811336a8:	108002a4 	muli	r2,r2,10
811336ac:	a109883a 	add	r4,r20,r4
811336b0:	22c00003 	ldbu	r11,0(r4)
811336b4:	1345883a 	add	r2,r2,r13
811336b8:	10bffc04 	addi	r2,r2,-16
811336bc:	593fffc4 	addi	r4,r11,-1
811336c0:	21003fcc 	andi	r4,r4,255
811336c4:	5b403fcc 	andi	r13,r11,255
811336c8:	613ff52e 	bgeu	r12,r4,811336a0 <__reset+0xfb1136a0>
811336cc:	30000126 	beq	r6,zero,811336d4 <__gethex+0x3e0>
811336d0:	0085c83a 	sub	r2,zero,r2
811336d4:	8039883a 	mov	fp,r16
811336d8:	b8af883a 	add	r23,r23,r2
811336dc:	2821883a 	mov	r16,r5
811336e0:	003f5106 	br	81133428 <__reset+0xfb113428>
811336e4:	80800217 	ldw	r2,8(r16)
811336e8:	e080f00e 	bge	fp,r2,81133aac <__gethex+0x7b8>
811336ec:	e007883a 	mov	r3,fp
811336f0:	18800144 	addi	r2,r3,5
811336f4:	1085883a 	add	r2,r2,r2
811336f8:	18c00044 	addi	r3,r3,1
811336fc:	1085883a 	add	r2,r2,r2
81133700:	8085883a 	add	r2,r16,r2
81133704:	80c00415 	stw	r3,16(r16)
81133708:	01000044 	movi	r4,1
8113370c:	11000015 	stw	r4,0(r2)
81133710:	00800084 	movi	r2,2
81133714:	8880d826 	beq	r17,r2,81133a78 <__gethex+0x784>
81133718:	e0c0ac0e 	bge	fp,r3,811339cc <__gethex+0x6d8>
8113371c:	01400044 	movi	r5,1
81133720:	8009883a 	mov	r4,r16
81133724:	11331f40 	call	811331f4 <rshift>
81133728:	d8c00017 	ldw	r3,0(sp)
8113372c:	bdc00044 	addi	r23,r23,1
81133730:	18800217 	ldw	r2,8(r3)
81133734:	15c0a70e 	bge	r2,r23,811339d4 <__gethex+0x6e0>
81133738:	d9000117 	ldw	r4,4(sp)
8113373c:	800b883a 	mov	r5,r16
81133740:	112cc740 	call	8112cc74 <_Bfree>
81133744:	d9001517 	ldw	r4,84(sp)
81133748:	008028c4 	movi	r2,163
8113374c:	20000015 	stw	zero,0(r4)
81133750:	003faa06 	br	811335fc <__reset+0xfb1135fc>
81133754:	01800044 	movi	r6,1
81133758:	80800083 	ldbu	r2,2(r16)
8113375c:	81400084 	addi	r5,r16,2
81133760:	003fbc06 	br	81133654 <__reset+0xfb113654>
81133764:	ada1883a 	add	r16,r21,r22
81133768:	81000003 	ldbu	r4,0(r16)
8113376c:	21403fcc 	andi	r5,r4,255
81133770:	a145883a 	add	r2,r20,r5
81133774:	10800003 	ldbu	r2,0(r2)
81133778:	11803fcc 	andi	r6,r2,255
8113377c:	30004f26 	beq	r6,zero,811338bc <__gethex+0x5c8>
81133780:	00c00c04 	movi	r3,48
81133784:	802b883a 	mov	r21,r16
81133788:	28c0061e 	bne	r5,r3,811337a4 <__gethex+0x4b0>
8113378c:	2809883a 	mov	r4,r5
81133790:	ad400044 	addi	r21,r21,1
81133794:	a8800003 	ldbu	r2,0(r21)
81133798:	113ffd26 	beq	r2,r4,81133790 <__reset+0xfb113790>
8113379c:	a085883a 	add	r2,r20,r2
811337a0:	10800003 	ldbu	r2,0(r2)
811337a4:	10803fcc 	andi	r2,r2,255
811337a8:	1015003a 	cmpeq	r10,r2,zero
811337ac:	802f883a 	mov	r23,r16
811337b0:	04400044 	movi	r17,1
811337b4:	003eff06 	br	811333b4 <__reset+0xfb1133b4>
811337b8:	04400044 	movi	r17,1
811337bc:	98000926 	beq	r19,zero,811337e4 <__gethex+0x4f0>
811337c0:	d8c00017 	ldw	r3,0(sp)
811337c4:	18800317 	ldw	r2,12(r3)
811337c8:	00c00084 	movi	r3,2
811337cc:	10c06826 	beq	r2,r3,81133970 <__gethex+0x67c>
811337d0:	00c000c4 	movi	r3,3
811337d4:	10c06a26 	beq	r2,r3,81133980 <__gethex+0x68c>
811337d8:	00c00044 	movi	r3,1
811337dc:	10c08d26 	beq	r2,r3,81133a14 <__gethex+0x720>
811337e0:	8c400414 	ori	r17,r17,16
811337e4:	d9001517 	ldw	r4,84(sp)
811337e8:	d8c00417 	ldw	r3,16(sp)
811337ec:	8805883a 	mov	r2,r17
811337f0:	24000015 	stw	r16,0(r4)
811337f4:	1dc00015 	stw	r23,0(r3)
811337f8:	003f8006 	br	811335fc <__reset+0xfb1135fc>
811337fc:	000d883a 	mov	r6,zero
81133800:	003fd506 	br	81133758 <__reset+0xfb113758>
81133804:	0005883a 	mov	r2,zero
81133808:	003f7c06 	br	811335fc <__reset+0xfb1135fc>
8113380c:	14a3c83a 	sub	r17,r2,r18
81133810:	880b883a 	mov	r5,r17
81133814:	8009883a 	mov	r4,r16
81133818:	112db940 	call	8112db94 <__any_on>
8113381c:	10002926 	beq	r2,zero,811338c4 <__gethex+0x5d0>
81133820:	897fffc4 	addi	r5,r17,-1
81133824:	2807d17a 	srai	r3,r5,5
81133828:	d8800217 	ldw	r2,8(sp)
8113382c:	290007cc 	andi	r4,r5,31
81133830:	18c7883a 	add	r3,r3,r3
81133834:	18c7883a 	add	r3,r3,r3
81133838:	04c00044 	movi	r19,1
8113383c:	10c7883a 	add	r3,r2,r3
81133840:	9908983a 	sll	r4,r19,r4
81133844:	18c00017 	ldw	r3,0(r3)
81133848:	20c6703a 	and	r3,r4,r3
8113384c:	18000626 	beq	r3,zero,81133868 <__gethex+0x574>
81133850:	99407b0e 	bge	r19,r5,81133a40 <__gethex+0x74c>
81133854:	897fff84 	addi	r5,r17,-2
81133858:	8009883a 	mov	r4,r16
8113385c:	112db940 	call	8112db94 <__any_on>
81133860:	10007726 	beq	r2,zero,81133a40 <__gethex+0x74c>
81133864:	04c000c4 	movi	r19,3
81133868:	880b883a 	mov	r5,r17
8113386c:	8009883a 	mov	r4,r16
81133870:	11331f40 	call	811331f4 <rshift>
81133874:	bc6f883a 	add	r23,r23,r17
81133878:	003f1f06 	br	811334f8 <__reset+0xfb1134f8>
8113387c:	002f883a 	mov	r23,zero
81133880:	003ee306 	br	81133410 <__reset+0xfb113410>
81133884:	d9000117 	ldw	r4,4(sp)
81133888:	90a3c83a 	sub	r17,r18,r2
8113388c:	800b883a 	mov	r5,r16
81133890:	880d883a 	mov	r6,r17
81133894:	112d3740 	call	8112d374 <__lshift>
81133898:	10c00504 	addi	r3,r2,20
8113389c:	1021883a 	mov	r16,r2
811338a0:	bc6fc83a 	sub	r23,r23,r17
811338a4:	d8c00215 	stw	r3,8(sp)
811338a8:	0027883a 	mov	r19,zero
811338ac:	003f1206 	br	811334f8 <__reset+0xfb1134f8>
811338b0:	1d400084 	addi	r21,r3,2
811338b4:	0023883a 	mov	r17,zero
811338b8:	003eb406 	br	8113338c <__reset+0xfb11338c>
811338bc:	2005883a 	mov	r2,r4
811338c0:	003f4606 	br	811335dc <__reset+0xfb1135dc>
811338c4:	0027883a 	mov	r19,zero
811338c8:	003fe706 	br	81133868 <__reset+0xfb113868>
811338cc:	bc7fffc4 	addi	r17,r23,-1
811338d0:	9800421e 	bne	r19,zero,811339dc <__gethex+0x6e8>
811338d4:	88000426 	beq	r17,zero,811338e8 <__gethex+0x5f4>
811338d8:	880b883a 	mov	r5,r17
811338dc:	8009883a 	mov	r4,r16
811338e0:	112db940 	call	8112db94 <__any_on>
811338e4:	1027883a 	mov	r19,r2
811338e8:	8805d17a 	srai	r2,r17,5
811338ec:	d8c00217 	ldw	r3,8(sp)
811338f0:	8c4007cc 	andi	r17,r17,31
811338f4:	1085883a 	add	r2,r2,r2
811338f8:	1085883a 	add	r2,r2,r2
811338fc:	1885883a 	add	r2,r3,r2
81133900:	00c00044 	movi	r3,1
81133904:	1c62983a 	sll	r17,r3,r17
81133908:	10800017 	ldw	r2,0(r2)
8113390c:	8884703a 	and	r2,r17,r2
81133910:	10000126 	beq	r2,zero,81133918 <__gethex+0x624>
81133914:	9cc00094 	ori	r19,r19,2
81133918:	b80b883a 	mov	r5,r23
8113391c:	8009883a 	mov	r4,r16
81133920:	11331f40 	call	811331f4 <rshift>
81133924:	d8c00017 	ldw	r3,0(sp)
81133928:	95e5c83a 	sub	r18,r18,r23
8113392c:	04400084 	movi	r17,2
81133930:	1dc00117 	ldw	r23,4(r3)
81133934:	003fa106 	br	811337bc <__reset+0xfb1137bc>
81133938:	85af883a 	add	r23,r16,r22
8113393c:	b8800003 	ldbu	r2,0(r23)
81133940:	b821883a 	mov	r16,r23
81133944:	11003fcc 	andi	r4,r2,255
81133948:	a109883a 	add	r4,r20,r4
8113394c:	21000003 	ldbu	r4,0(r4)
81133950:	203eaa26 	beq	r4,zero,811333fc <__reset+0xfb1133fc>
81133954:	84000044 	addi	r16,r16,1
81133958:	80800003 	ldbu	r2,0(r16)
8113395c:	11003fcc 	andi	r4,r2,255
81133960:	a109883a 	add	r4,r20,r4
81133964:	21000003 	ldbu	r4,0(r4)
81133968:	203ffa1e 	bne	r4,zero,81133954 <__reset+0xfb113954>
8113396c:	003ea306 	br	811333fc <__reset+0xfb1133fc>
81133970:	d9001617 	ldw	r4,88(sp)
81133974:	00800044 	movi	r2,1
81133978:	1109c83a 	sub	r4,r2,r4
8113397c:	d9001615 	stw	r4,88(sp)
81133980:	d8801617 	ldw	r2,88(sp)
81133984:	103f9626 	beq	r2,zero,811337e0 <__reset+0xfb1137e0>
81133988:	87000417 	ldw	fp,16(r16)
8113398c:	d9800217 	ldw	r6,8(sp)
81133990:	013fffc4 	movi	r4,-1
81133994:	e727883a 	add	r19,fp,fp
81133998:	9ce7883a 	add	r19,r19,r19
8113399c:	3005883a 	mov	r2,r6
811339a0:	34cb883a 	add	r5,r6,r19
811339a4:	00000306 	br	811339b4 <__gethex+0x6c0>
811339a8:	10000015 	stw	zero,0(r2)
811339ac:	10800104 	addi	r2,r2,4
811339b0:	117f4c2e 	bgeu	r2,r5,811336e4 <__reset+0xfb1136e4>
811339b4:	10c00017 	ldw	r3,0(r2)
811339b8:	193ffb26 	beq	r3,r4,811339a8 <__reset+0xfb1139a8>
811339bc:	18c00044 	addi	r3,r3,1
811339c0:	10c00015 	stw	r3,0(r2)
811339c4:	00800084 	movi	r2,2
811339c8:	88802b26 	beq	r17,r2,81133a78 <__gethex+0x784>
811339cc:	948007cc 	andi	r18,r18,31
811339d0:	90002f1e 	bne	r18,zero,81133a90 <__gethex+0x79c>
811339d4:	04400844 	movi	r17,33
811339d8:	003f8206 	br	811337e4 <__reset+0xfb1137e4>
811339dc:	04c00044 	movi	r19,1
811339e0:	003fc106 	br	811338e8 <__reset+0xfb1138e8>
811339e4:	d8c01617 	ldw	r3,88(sp)
811339e8:	183ed226 	beq	r3,zero,81133534 <__reset+0xfb113534>
811339ec:	d8c00417 	ldw	r3,16(sp)
811339f0:	d9001517 	ldw	r4,84(sp)
811339f4:	18800015 	stw	r2,0(r3)
811339f8:	d8c00217 	ldw	r3,8(sp)
811339fc:	00800044 	movi	r2,1
81133a00:	80800415 	stw	r2,16(r16)
81133a04:	18800015 	stw	r2,0(r3)
81133a08:	24000015 	stw	r16,0(r4)
81133a0c:	00801884 	movi	r2,98
81133a10:	003efa06 	br	811335fc <__reset+0xfb1135fc>
81133a14:	9880008c 	andi	r2,r19,2
81133a18:	103f7126 	beq	r2,zero,811337e0 <__reset+0xfb1137e0>
81133a1c:	d8c00217 	ldw	r3,8(sp)
81133a20:	18800017 	ldw	r2,0(r3)
81133a24:	9884b03a 	or	r2,r19,r2
81133a28:	1080004c 	andi	r2,r2,1
81133a2c:	103fd61e 	bne	r2,zero,81133988 <__reset+0xfb113988>
81133a30:	003f6b06 	br	811337e0 <__reset+0xfb1137e0>
81133a34:	da800217 	ldw	r10,8(sp)
81133a38:	0013883a 	mov	r9,zero
81133a3c:	003e9f06 	br	811334bc <__reset+0xfb1134bc>
81133a40:	04c00084 	movi	r19,2
81133a44:	003f8806 	br	81133868 <__reset+0xfb113868>
81133a48:	d9001617 	ldw	r4,88(sp)
81133a4c:	203fe726 	beq	r4,zero,811339ec <__reset+0xfb1139ec>
81133a50:	003eb806 	br	81133534 <__reset+0xfb113534>
81133a54:	95feb71e 	bne	r18,r23,81133534 <__reset+0xfb113534>
81133a58:	1cbfe40e 	bge	r3,r18,811339ec <__reset+0xfb1139ec>
81133a5c:	917fffc4 	addi	r5,r18,-1
81133a60:	8009883a 	mov	r4,r16
81133a64:	112db940 	call	8112db94 <__any_on>
81133a68:	103eb226 	beq	r2,zero,81133534 <__reset+0xfb113534>
81133a6c:	d8c00017 	ldw	r3,0(sp)
81133a70:	18800117 	ldw	r2,4(r3)
81133a74:	003fdd06 	br	811339ec <__reset+0xfb1139ec>
81133a78:	d8c00017 	ldw	r3,0(sp)
81133a7c:	18800017 	ldw	r2,0(r3)
81133a80:	10bfffc4 	addi	r2,r2,-1
81133a84:	90801c26 	beq	r18,r2,81133af8 <__gethex+0x804>
81133a88:	04400884 	movi	r17,34
81133a8c:	003f5506 	br	811337e4 <__reset+0xfb1137e4>
81133a90:	34c5883a 	add	r2,r6,r19
81133a94:	113fff17 	ldw	r4,-4(r2)
81133a98:	112ced00 	call	8112ced0 <__hi0bits>
81133a9c:	00c00804 	movi	r3,32
81133aa0:	1ca5c83a 	sub	r18,r3,r18
81133aa4:	14bfcb0e 	bge	r2,r18,811339d4 <__reset+0xfb1139d4>
81133aa8:	003f1c06 	br	8113371c <__reset+0xfb11371c>
81133aac:	81400117 	ldw	r5,4(r16)
81133ab0:	d9000117 	ldw	r4,4(sp)
81133ab4:	29400044 	addi	r5,r5,1
81133ab8:	112cbc40 	call	8112cbc4 <_Balloc>
81133abc:	81800417 	ldw	r6,16(r16)
81133ac0:	81400304 	addi	r5,r16,12
81133ac4:	11000304 	addi	r4,r2,12
81133ac8:	31800084 	addi	r6,r6,2
81133acc:	318d883a 	add	r6,r6,r6
81133ad0:	318d883a 	add	r6,r6,r6
81133ad4:	1029883a 	mov	r20,r2
81133ad8:	11226900 	call	81122690 <memcpy>
81133adc:	d9000117 	ldw	r4,4(sp)
81133ae0:	800b883a 	mov	r5,r16
81133ae4:	a021883a 	mov	r16,r20
81133ae8:	112cc740 	call	8112cc74 <_Bfree>
81133aec:	a0c00417 	ldw	r3,16(r20)
81133af0:	a1800504 	addi	r6,r20,20
81133af4:	003efe06 	br	811336f0 <__reset+0xfb1136f0>
81133af8:	9005d17a 	srai	r2,r18,5
81133afc:	944007cc 	andi	r17,r18,31
81133b00:	1085883a 	add	r2,r2,r2
81133b04:	1085883a 	add	r2,r2,r2
81133b08:	3087883a 	add	r3,r6,r2
81133b0c:	00800044 	movi	r2,1
81133b10:	1462983a 	sll	r17,r2,r17
81133b14:	18800017 	ldw	r2,0(r3)
81133b18:	8884703a 	and	r2,r17,r2
81133b1c:	1022c03a 	cmpne	r17,r2,zero
81133b20:	00800884 	movi	r2,34
81133b24:	1463c83a 	sub	r17,r2,r17
81133b28:	003f2e06 	br	811337e4 <__reset+0xfb1137e4>

81133b2c <__hexnan>:
81133b2c:	defff904 	addi	sp,sp,-28
81133b30:	de00012e 	bgeu	sp,et,81133b38 <__hexnan+0xc>
81133b34:	003b68fa 	trap	3
81133b38:	dc800215 	stw	r18,8(sp)
81133b3c:	2c800017 	ldw	r18,0(r5)
81133b40:	dfc00615 	stw	ra,24(sp)
81133b44:	dd400515 	stw	r21,20(sp)
81133b48:	901fd17a 	srai	r15,r18,5
81133b4c:	dd000415 	stw	r20,16(sp)
81133b50:	dcc00315 	stw	r19,12(sp)
81133b54:	7bdf883a 	add	r15,r15,r15
81133b58:	7bdf883a 	add	r15,r15,r15
81133b5c:	dc400115 	stw	r17,4(sp)
81133b60:	dc000015 	stw	r16,0(sp)
81133b64:	948007cc 	andi	r18,r18,31
81133b68:	33df883a 	add	r15,r6,r15
81133b6c:	90000126 	beq	r18,zero,81133b74 <__hexnan+0x48>
81133b70:	7bc00104 	addi	r15,r15,4
81133b74:	22000017 	ldw	r8,0(r4)
81133b78:	7affff04 	addi	r11,r15,-4
81133b7c:	03a04574 	movhi	r14,33045
81133b80:	783fff15 	stw	zero,-4(r15)
81133b84:	581b883a 	mov	r13,r11
81133b88:	580b883a 	mov	r5,r11
81133b8c:	000f883a 	mov	r7,zero
81133b90:	003f883a 	mov	ra,zero
81133b94:	0019883a 	mov	r12,zero
81133b98:	7383da04 	addi	r14,r14,3944
81133b9c:	04400204 	movi	r17,8
81133ba0:	04000804 	movi	r16,32
81133ba4:	04c001c4 	movi	r19,7
81133ba8:	42000044 	addi	r8,r8,1
81133bac:	40c00003 	ldbu	r3,0(r8)
81133bb0:	18001d26 	beq	r3,zero,81133c28 <__hexnan+0xfc>
81133bb4:	70c5883a 	add	r2,r14,r3
81133bb8:	10800003 	ldbu	r2,0(r2)
81133bbc:	12403fcc 	andi	r9,r2,255
81133bc0:	4800301e 	bne	r9,zero,81133c84 <__hexnan+0x158>
81133bc4:	80c04236 	bltu	r16,r3,81133cd0 <__hexnan+0x1a4>
81133bc8:	fb3ff70e 	bge	ra,r12,81133ba8 <__reset+0xfb113ba8>
81133bcc:	2b40112e 	bgeu	r5,r13,81133c14 <__hexnan+0xe8>
81133bd0:	99c01016 	blt	r19,r7,81133c14 <__hexnan+0xe8>
81133bd4:	89e9c83a 	sub	r20,r17,r7
81133bd8:	a529883a 	add	r20,r20,r20
81133bdc:	2a800017 	ldw	r10,0(r5)
81133be0:	a529883a 	add	r20,r20,r20
81133be4:	852bc83a 	sub	r21,r16,r20
81133be8:	28c00104 	addi	r3,r5,4
81133bec:	2805883a 	mov	r2,r5
81133bf0:	19c00017 	ldw	r7,0(r3)
81133bf4:	10800104 	addi	r2,r2,4
81133bf8:	18c00104 	addi	r3,r3,4
81133bfc:	3d52983a 	sll	r9,r7,r21
81133c00:	4a92b03a 	or	r9,r9,r10
81133c04:	3d14d83a 	srl	r10,r7,r20
81133c08:	127fff15 	stw	r9,-4(r2)
81133c0c:	1abfff15 	stw	r10,-4(r3)
81133c10:	137ff736 	bltu	r2,r13,81133bf0 <__reset+0xfb113bf0>
81133c14:	31402836 	bltu	r6,r5,81133cb8 <__hexnan+0x18c>
81133c18:	42000044 	addi	r8,r8,1
81133c1c:	40c00003 	ldbu	r3,0(r8)
81133c20:	01c00204 	movi	r7,8
81133c24:	183fe31e 	bne	r3,zero,81133bb4 <__reset+0xfb113bb4>
81133c28:	60002b26 	beq	r12,zero,81133cd8 <__hexnan+0x1ac>
81133c2c:	2b40022e 	bgeu	r5,r13,81133c38 <__hexnan+0x10c>
81133c30:	008001c4 	movi	r2,7
81133c34:	11c0430e 	bge	r2,r7,81133d44 <__hexnan+0x218>
81133c38:	3140312e 	bgeu	r6,r5,81133d00 <__hexnan+0x1d4>
81133c3c:	3007883a 	mov	r3,r6
81133c40:	29000017 	ldw	r4,0(r5)
81133c44:	18800104 	addi	r2,r3,4
81133c48:	29400104 	addi	r5,r5,4
81133c4c:	19000015 	stw	r4,0(r3)
81133c50:	1007883a 	mov	r3,r2
81133c54:	597ffa2e 	bgeu	r11,r5,81133c40 <__reset+0xfb113c40>
81133c58:	10000015 	stw	zero,0(r2)
81133c5c:	10800104 	addi	r2,r2,4
81133c60:	58bffd2e 	bgeu	r11,r2,81133c58 <__reset+0xfb113c58>
81133c64:	78bfff17 	ldw	r2,-4(r15)
81133c68:	1000041e 	bne	r2,zero,81133c7c <__hexnan+0x150>
81133c6c:	32c02d26 	beq	r6,r11,81133d24 <__hexnan+0x1f8>
81133c70:	5affff04 	addi	r11,r11,-4
81133c74:	58800017 	ldw	r2,0(r11)
81133c78:	103ffc26 	beq	r2,zero,81133c6c <__reset+0xfb113c6c>
81133c7c:	00800144 	movi	r2,5
81133c80:	00001606 	br	81133cdc <__hexnan+0x1b0>
81133c84:	39c00044 	addi	r7,r7,1
81133c88:	63000044 	addi	r12,r12,1
81133c8c:	89c0040e 	bge	r17,r7,81133ca0 <__hexnan+0x174>
81133c90:	317fc52e 	bgeu	r6,r5,81133ba8 <__reset+0xfb113ba8>
81133c94:	283fff15 	stw	zero,-4(r5)
81133c98:	01c00044 	movi	r7,1
81133c9c:	297fff04 	addi	r5,r5,-4
81133ca0:	28c00017 	ldw	r3,0(r5)
81133ca4:	108003cc 	andi	r2,r2,15
81133ca8:	1806913a 	slli	r3,r3,4
81133cac:	1884b03a 	or	r2,r3,r2
81133cb0:	28800015 	stw	r2,0(r5)
81133cb4:	003fbc06 	br	81133ba8 <__reset+0xfb113ba8>
81133cb8:	2b7fff04 	addi	r13,r5,-4
81133cbc:	283fff15 	stw	zero,-4(r5)
81133cc0:	603f883a 	mov	ra,r12
81133cc4:	680b883a 	mov	r5,r13
81133cc8:	000f883a 	mov	r7,zero
81133ccc:	003fb606 	br	81133ba8 <__reset+0xfb113ba8>
81133cd0:	00800a44 	movi	r2,41
81133cd4:	18801726 	beq	r3,r2,81133d34 <__hexnan+0x208>
81133cd8:	00800104 	movi	r2,4
81133cdc:	dfc00617 	ldw	ra,24(sp)
81133ce0:	dd400517 	ldw	r21,20(sp)
81133ce4:	dd000417 	ldw	r20,16(sp)
81133ce8:	dcc00317 	ldw	r19,12(sp)
81133cec:	dc800217 	ldw	r18,8(sp)
81133cf0:	dc400117 	ldw	r17,4(sp)
81133cf4:	dc000017 	ldw	r16,0(sp)
81133cf8:	dec00704 	addi	sp,sp,28
81133cfc:	f800283a 	ret
81133d00:	903fd826 	beq	r18,zero,81133c64 <__reset+0xfb113c64>
81133d04:	00c00804 	movi	r3,32
81133d08:	1ca5c83a 	sub	r18,r3,r18
81133d0c:	00ffffc4 	movi	r3,-1
81133d10:	78bfff17 	ldw	r2,-4(r15)
81133d14:	1c86d83a 	srl	r3,r3,r18
81133d18:	1884703a 	and	r2,r3,r2
81133d1c:	78bfff15 	stw	r2,-4(r15)
81133d20:	003fd106 	br	81133c68 <__reset+0xfb113c68>
81133d24:	00800044 	movi	r2,1
81133d28:	58800015 	stw	r2,0(r11)
81133d2c:	00800144 	movi	r2,5
81133d30:	003fea06 	br	81133cdc <__reset+0xfb113cdc>
81133d34:	42000044 	addi	r8,r8,1
81133d38:	22000015 	stw	r8,0(r4)
81133d3c:	603fbb1e 	bne	r12,zero,81133c2c <__reset+0xfb113c2c>
81133d40:	003fe506 	br	81133cd8 <__reset+0xfb113cd8>
81133d44:	02400204 	movi	r9,8
81133d48:	49d3c83a 	sub	r9,r9,r7
81133d4c:	4a53883a 	add	r9,r9,r9
81133d50:	2a000017 	ldw	r8,0(r5)
81133d54:	4a53883a 	add	r9,r9,r9
81133d58:	02800804 	movi	r10,32
81133d5c:	5255c83a 	sub	r10,r10,r9
81133d60:	28c00104 	addi	r3,r5,4
81133d64:	2805883a 	mov	r2,r5
81133d68:	19c00017 	ldw	r7,0(r3)
81133d6c:	10800104 	addi	r2,r2,4
81133d70:	18c00104 	addi	r3,r3,4
81133d74:	3a88983a 	sll	r4,r7,r10
81133d78:	2208b03a 	or	r4,r4,r8
81133d7c:	3a50d83a 	srl	r8,r7,r9
81133d80:	113fff15 	stw	r4,-4(r2)
81133d84:	1a3fff15 	stw	r8,-4(r3)
81133d88:	137ff736 	bltu	r2,r13,81133d68 <__reset+0xfb113d68>
81133d8c:	003faa06 	br	81133c38 <__reset+0xfb113c38>

81133d90 <strncmp>:
81133d90:	30003126 	beq	r6,zero,81133e58 <strncmp+0xc8>
81133d94:	2144b03a 	or	r2,r4,r5
81133d98:	108000cc 	andi	r2,r2,3
81133d9c:	10001e1e 	bne	r2,zero,81133e18 <strncmp+0x88>
81133da0:	024000c4 	movi	r9,3
81133da4:	49801c2e 	bgeu	r9,r6,81133e18 <strncmp+0x88>
81133da8:	20800017 	ldw	r2,0(r4)
81133dac:	28c00017 	ldw	r3,0(r5)
81133db0:	10c0191e 	bne	r2,r3,81133e18 <strncmp+0x88>
81133db4:	31bfff04 	addi	r6,r6,-4
81133db8:	30002726 	beq	r6,zero,81133e58 <strncmp+0xc8>
81133dbc:	02ffbff4 	movhi	r11,65279
81133dc0:	5affbfc4 	addi	r11,r11,-257
81133dc4:	0086303a 	nor	r3,zero,r2
81133dc8:	02a02074 	movhi	r10,32897
81133dcc:	12c5883a 	add	r2,r2,r11
81133dd0:	52a02004 	addi	r10,r10,-32640
81133dd4:	10c4703a 	and	r2,r2,r3
81133dd8:	1284703a 	and	r2,r2,r10
81133ddc:	10000b26 	beq	r2,zero,81133e0c <strncmp+0x7c>
81133de0:	00001d06 	br	81133e58 <strncmp+0xc8>
81133de4:	20c00017 	ldw	r3,0(r4)
81133de8:	29c00017 	ldw	r7,0(r5)
81133dec:	1ad1883a 	add	r8,r3,r11
81133df0:	00c4303a 	nor	r2,zero,r3
81133df4:	4084703a 	and	r2,r8,r2
81133df8:	1284703a 	and	r2,r2,r10
81133dfc:	19c0061e 	bne	r3,r7,81133e18 <strncmp+0x88>
81133e00:	31bfff04 	addi	r6,r6,-4
81133e04:	30001426 	beq	r6,zero,81133e58 <strncmp+0xc8>
81133e08:	1000131e 	bne	r2,zero,81133e58 <strncmp+0xc8>
81133e0c:	21000104 	addi	r4,r4,4
81133e10:	29400104 	addi	r5,r5,4
81133e14:	49bff336 	bltu	r9,r6,81133de4 <__reset+0xfb113de4>
81133e18:	28800007 	ldb	r2,0(r5)
81133e1c:	20c00007 	ldb	r3,0(r4)
81133e20:	31bfffc4 	addi	r6,r6,-1
81133e24:	10c0081e 	bne	r2,r3,81133e48 <strncmp+0xb8>
81133e28:	30000b26 	beq	r6,zero,81133e58 <strncmp+0xc8>
81133e2c:	10000a26 	beq	r2,zero,81133e58 <strncmp+0xc8>
81133e30:	21000044 	addi	r4,r4,1
81133e34:	29400044 	addi	r5,r5,1
81133e38:	20800007 	ldb	r2,0(r4)
81133e3c:	28c00007 	ldb	r3,0(r5)
81133e40:	31bfffc4 	addi	r6,r6,-1
81133e44:	10fff826 	beq	r2,r3,81133e28 <__reset+0xfb113e28>
81133e48:	20800003 	ldbu	r2,0(r4)
81133e4c:	28c00003 	ldbu	r3,0(r5)
81133e50:	10c5c83a 	sub	r2,r2,r3
81133e54:	f800283a 	ret
81133e58:	0005883a 	mov	r2,zero
81133e5c:	f800283a 	ret

81133e60 <_wcrtomb_r>:
81133e60:	defff604 	addi	sp,sp,-40
81133e64:	00a04574 	movhi	r2,33045
81133e68:	de00012e 	bgeu	sp,et,81133e70 <_wcrtomb_r+0x10>
81133e6c:	003b68fa 	trap	3
81133e70:	108d1404 	addi	r2,r2,13392
81133e74:	dc800815 	stw	r18,32(sp)
81133e78:	dc400715 	stw	r17,28(sp)
81133e7c:	dc000615 	stw	r16,24(sp)
81133e80:	dfc00915 	stw	ra,36(sp)
81133e84:	2021883a 	mov	r16,r4
81133e88:	3823883a 	mov	r17,r7
81133e8c:	14800017 	ldw	r18,0(r2)
81133e90:	28001426 	beq	r5,zero,81133ee4 <_wcrtomb_r+0x84>
81133e94:	d9400415 	stw	r5,16(sp)
81133e98:	d9800515 	stw	r6,20(sp)
81133e9c:	112c6780 	call	8112c678 <__locale_charset>
81133ea0:	d9800517 	ldw	r6,20(sp)
81133ea4:	d9400417 	ldw	r5,16(sp)
81133ea8:	100f883a 	mov	r7,r2
81133eac:	dc400015 	stw	r17,0(sp)
81133eb0:	8009883a 	mov	r4,r16
81133eb4:	903ee83a 	callr	r18
81133eb8:	00ffffc4 	movi	r3,-1
81133ebc:	10c0031e 	bne	r2,r3,81133ecc <_wcrtomb_r+0x6c>
81133ec0:	88000015 	stw	zero,0(r17)
81133ec4:	00c02284 	movi	r3,138
81133ec8:	80c00015 	stw	r3,0(r16)
81133ecc:	dfc00917 	ldw	ra,36(sp)
81133ed0:	dc800817 	ldw	r18,32(sp)
81133ed4:	dc400717 	ldw	r17,28(sp)
81133ed8:	dc000617 	ldw	r16,24(sp)
81133edc:	dec00a04 	addi	sp,sp,40
81133ee0:	f800283a 	ret
81133ee4:	112c6780 	call	8112c678 <__locale_charset>
81133ee8:	100f883a 	mov	r7,r2
81133eec:	dc400015 	stw	r17,0(sp)
81133ef0:	000d883a 	mov	r6,zero
81133ef4:	d9400104 	addi	r5,sp,4
81133ef8:	8009883a 	mov	r4,r16
81133efc:	903ee83a 	callr	r18
81133f00:	003fed06 	br	81133eb8 <__reset+0xfb113eb8>

81133f04 <wcrtomb>:
81133f04:	defff604 	addi	sp,sp,-40
81133f08:	00a04574 	movhi	r2,33045
81133f0c:	de00012e 	bgeu	sp,et,81133f14 <wcrtomb+0x10>
81133f10:	003b68fa 	trap	3
81133f14:	108d0f04 	addi	r2,r2,13372
81133f18:	dc800615 	stw	r18,24(sp)
81133f1c:	dc400515 	stw	r17,20(sp)
81133f20:	dfc00915 	stw	ra,36(sp)
81133f24:	dd000815 	stw	r20,32(sp)
81133f28:	dcc00715 	stw	r19,28(sp)
81133f2c:	dc000415 	stw	r16,16(sp)
81133f30:	3025883a 	mov	r18,r6
81133f34:	14400017 	ldw	r17,0(r2)
81133f38:	20001926 	beq	r4,zero,81133fa0 <wcrtomb+0x9c>
81133f3c:	00a04574 	movhi	r2,33045
81133f40:	108d1404 	addi	r2,r2,13392
81133f44:	15000017 	ldw	r20,0(r2)
81133f48:	2021883a 	mov	r16,r4
81133f4c:	2827883a 	mov	r19,r5
81133f50:	112c6780 	call	8112c678 <__locale_charset>
81133f54:	100f883a 	mov	r7,r2
81133f58:	dc800015 	stw	r18,0(sp)
81133f5c:	980d883a 	mov	r6,r19
81133f60:	800b883a 	mov	r5,r16
81133f64:	8809883a 	mov	r4,r17
81133f68:	a03ee83a 	callr	r20
81133f6c:	00ffffc4 	movi	r3,-1
81133f70:	10c0031e 	bne	r2,r3,81133f80 <wcrtomb+0x7c>
81133f74:	90000015 	stw	zero,0(r18)
81133f78:	00c02284 	movi	r3,138
81133f7c:	88c00015 	stw	r3,0(r17)
81133f80:	dfc00917 	ldw	ra,36(sp)
81133f84:	dd000817 	ldw	r20,32(sp)
81133f88:	dcc00717 	ldw	r19,28(sp)
81133f8c:	dc800617 	ldw	r18,24(sp)
81133f90:	dc400517 	ldw	r17,20(sp)
81133f94:	dc000417 	ldw	r16,16(sp)
81133f98:	dec00a04 	addi	sp,sp,40
81133f9c:	f800283a 	ret
81133fa0:	00a04574 	movhi	r2,33045
81133fa4:	108d1404 	addi	r2,r2,13392
81133fa8:	14000017 	ldw	r16,0(r2)
81133fac:	112c6780 	call	8112c678 <__locale_charset>
81133fb0:	100f883a 	mov	r7,r2
81133fb4:	dc800015 	stw	r18,0(sp)
81133fb8:	000d883a 	mov	r6,zero
81133fbc:	d9400104 	addi	r5,sp,4
81133fc0:	8809883a 	mov	r4,r17
81133fc4:	803ee83a 	callr	r16
81133fc8:	003fe806 	br	81133f6c <__reset+0xfb113f6c>

81133fcc <__ascii_wctomb>:
81133fcc:	28000526 	beq	r5,zero,81133fe4 <__ascii_wctomb+0x18>
81133fd0:	00803fc4 	movi	r2,255
81133fd4:	11800536 	bltu	r2,r6,81133fec <__ascii_wctomb+0x20>
81133fd8:	29800005 	stb	r6,0(r5)
81133fdc:	00800044 	movi	r2,1
81133fe0:	f800283a 	ret
81133fe4:	0005883a 	mov	r2,zero
81133fe8:	f800283a 	ret
81133fec:	00802284 	movi	r2,138
81133ff0:	20800015 	stw	r2,0(r4)
81133ff4:	00bfffc4 	movi	r2,-1
81133ff8:	f800283a 	ret

81133ffc <_wctomb_r>:
81133ffc:	00a04574 	movhi	r2,33045
81134000:	defff904 	addi	sp,sp,-28
81134004:	108d1404 	addi	r2,r2,13392
81134008:	de00012e 	bgeu	sp,et,81134010 <_wctomb_r+0x14>
8113400c:	003b68fa 	trap	3
81134010:	dfc00615 	stw	ra,24(sp)
81134014:	dc400515 	stw	r17,20(sp)
81134018:	dc000415 	stw	r16,16(sp)
8113401c:	3823883a 	mov	r17,r7
81134020:	14000017 	ldw	r16,0(r2)
81134024:	d9000115 	stw	r4,4(sp)
81134028:	d9400215 	stw	r5,8(sp)
8113402c:	d9800315 	stw	r6,12(sp)
81134030:	112c6780 	call	8112c678 <__locale_charset>
81134034:	d9800317 	ldw	r6,12(sp)
81134038:	d9400217 	ldw	r5,8(sp)
8113403c:	d9000117 	ldw	r4,4(sp)
81134040:	100f883a 	mov	r7,r2
81134044:	dc400015 	stw	r17,0(sp)
81134048:	803ee83a 	callr	r16
8113404c:	dfc00617 	ldw	ra,24(sp)
81134050:	dc400517 	ldw	r17,20(sp)
81134054:	dc000417 	ldw	r16,16(sp)
81134058:	dec00704 	addi	sp,sp,28
8113405c:	f800283a 	ret

81134060 <__udivdi3>:
81134060:	defff504 	addi	sp,sp,-44
81134064:	de00012e 	bgeu	sp,et,8113406c <__udivdi3+0xc>
81134068:	003b68fa 	trap	3
8113406c:	dcc00415 	stw	r19,16(sp)
81134070:	dc000115 	stw	r16,4(sp)
81134074:	dfc00a15 	stw	ra,40(sp)
81134078:	df000915 	stw	fp,36(sp)
8113407c:	ddc00815 	stw	r23,32(sp)
81134080:	dd800715 	stw	r22,28(sp)
81134084:	dd400615 	stw	r21,24(sp)
81134088:	dd000515 	stw	r20,20(sp)
8113408c:	dc800315 	stw	r18,12(sp)
81134090:	dc400215 	stw	r17,8(sp)
81134094:	2027883a 	mov	r19,r4
81134098:	2821883a 	mov	r16,r5
8113409c:	3800411e 	bne	r7,zero,811341a4 <__udivdi3+0x144>
811340a0:	3023883a 	mov	r17,r6
811340a4:	2025883a 	mov	r18,r4
811340a8:	2980522e 	bgeu	r5,r6,811341f4 <__udivdi3+0x194>
811340ac:	00bfffd4 	movui	r2,65535
811340b0:	282d883a 	mov	r22,r5
811340b4:	1180a836 	bltu	r2,r6,81134358 <__udivdi3+0x2f8>
811340b8:	00803fc4 	movi	r2,255
811340bc:	1185803a 	cmpltu	r2,r2,r6
811340c0:	100490fa 	slli	r2,r2,3
811340c4:	3086d83a 	srl	r3,r6,r2
811340c8:	01204574 	movhi	r4,33045
811340cc:	21025404 	addi	r4,r4,2384
811340d0:	20c7883a 	add	r3,r4,r3
811340d4:	18c00003 	ldbu	r3,0(r3)
811340d8:	1885883a 	add	r2,r3,r2
811340dc:	00c00804 	movi	r3,32
811340e0:	1887c83a 	sub	r3,r3,r2
811340e4:	18000526 	beq	r3,zero,811340fc <__udivdi3+0x9c>
811340e8:	80e0983a 	sll	r16,r16,r3
811340ec:	9884d83a 	srl	r2,r19,r2
811340f0:	30e2983a 	sll	r17,r6,r3
811340f4:	98e4983a 	sll	r18,r19,r3
811340f8:	142cb03a 	or	r22,r2,r16
811340fc:	882ad43a 	srli	r21,r17,16
81134100:	b009883a 	mov	r4,r22
81134104:	8d3fffcc 	andi	r20,r17,65535
81134108:	a80b883a 	mov	r5,r21
8113410c:	1134c7c0 	call	81134c7c <__umodsi3>
81134110:	b009883a 	mov	r4,r22
81134114:	a80b883a 	mov	r5,r21
81134118:	1027883a 	mov	r19,r2
8113411c:	1134c180 	call	81134c18 <__udivsi3>
81134120:	102d883a 	mov	r22,r2
81134124:	9826943a 	slli	r19,r19,16
81134128:	9004d43a 	srli	r2,r18,16
8113412c:	a5a1383a 	mul	r16,r20,r22
81134130:	14c4b03a 	or	r2,r2,r19
81134134:	1400052e 	bgeu	r2,r16,8113414c <__udivdi3+0xec>
81134138:	1445883a 	add	r2,r2,r17
8113413c:	b0ffffc4 	addi	r3,r22,-1
81134140:	14400136 	bltu	r2,r17,81134148 <__udivdi3+0xe8>
81134144:	14012336 	bltu	r2,r16,811345d4 <__udivdi3+0x574>
81134148:	182d883a 	mov	r22,r3
8113414c:	1421c83a 	sub	r16,r2,r16
81134150:	a80b883a 	mov	r5,r21
81134154:	8009883a 	mov	r4,r16
81134158:	1134c7c0 	call	81134c7c <__umodsi3>
8113415c:	1027883a 	mov	r19,r2
81134160:	a80b883a 	mov	r5,r21
81134164:	8009883a 	mov	r4,r16
81134168:	1134c180 	call	81134c18 <__udivsi3>
8113416c:	9826943a 	slli	r19,r19,16
81134170:	a0a9383a 	mul	r20,r20,r2
81134174:	94bfffcc 	andi	r18,r18,65535
81134178:	94e4b03a 	or	r18,r18,r19
8113417c:	9500052e 	bgeu	r18,r20,81134194 <__udivdi3+0x134>
81134180:	8ca5883a 	add	r18,r17,r18
81134184:	10ffffc4 	addi	r3,r2,-1
81134188:	9440f136 	bltu	r18,r17,81134550 <__udivdi3+0x4f0>
8113418c:	9500f02e 	bgeu	r18,r20,81134550 <__udivdi3+0x4f0>
81134190:	10bfff84 	addi	r2,r2,-2
81134194:	b00c943a 	slli	r6,r22,16
81134198:	0007883a 	mov	r3,zero
8113419c:	3084b03a 	or	r2,r6,r2
811341a0:	00005906 	br	81134308 <__udivdi3+0x2a8>
811341a4:	29c05636 	bltu	r5,r7,81134300 <__udivdi3+0x2a0>
811341a8:	00bfffd4 	movui	r2,65535
811341ac:	11c0622e 	bgeu	r2,r7,81134338 <__udivdi3+0x2d8>
811341b0:	00804034 	movhi	r2,256
811341b4:	10bfffc4 	addi	r2,r2,-1
811341b8:	11c0ee36 	bltu	r2,r7,81134574 <__udivdi3+0x514>
811341bc:	00800404 	movi	r2,16
811341c0:	3886d83a 	srl	r3,r7,r2
811341c4:	01204574 	movhi	r4,33045
811341c8:	21025404 	addi	r4,r4,2384
811341cc:	20c7883a 	add	r3,r4,r3
811341d0:	18c00003 	ldbu	r3,0(r3)
811341d4:	05400804 	movi	r21,32
811341d8:	1885883a 	add	r2,r3,r2
811341dc:	a8abc83a 	sub	r21,r21,r2
811341e0:	a800621e 	bne	r21,zero,8113436c <__udivdi3+0x30c>
811341e4:	3c00e936 	bltu	r7,r16,8113458c <__udivdi3+0x52c>
811341e8:	9985403a 	cmpgeu	r2,r19,r6
811341ec:	0007883a 	mov	r3,zero
811341f0:	00004506 	br	81134308 <__udivdi3+0x2a8>
811341f4:	3000041e 	bne	r6,zero,81134208 <__udivdi3+0x1a8>
811341f8:	000b883a 	mov	r5,zero
811341fc:	01000044 	movi	r4,1
81134200:	1134c180 	call	81134c18 <__udivsi3>
81134204:	1023883a 	mov	r17,r2
81134208:	00bfffd4 	movui	r2,65535
8113420c:	14404e2e 	bgeu	r2,r17,81134348 <__udivdi3+0x2e8>
81134210:	00804034 	movhi	r2,256
81134214:	10bfffc4 	addi	r2,r2,-1
81134218:	1440d836 	bltu	r2,r17,8113457c <__udivdi3+0x51c>
8113421c:	00800404 	movi	r2,16
81134220:	8886d83a 	srl	r3,r17,r2
81134224:	01204574 	movhi	r4,33045
81134228:	21025404 	addi	r4,r4,2384
8113422c:	20c7883a 	add	r3,r4,r3
81134230:	18c00003 	ldbu	r3,0(r3)
81134234:	1885883a 	add	r2,r3,r2
81134238:	00c00804 	movi	r3,32
8113423c:	1887c83a 	sub	r3,r3,r2
81134240:	18008f1e 	bne	r3,zero,81134480 <__udivdi3+0x420>
81134244:	882ad43a 	srli	r21,r17,16
81134248:	8461c83a 	sub	r16,r16,r17
8113424c:	8d3fffcc 	andi	r20,r17,65535
81134250:	00c00044 	movi	r3,1
81134254:	8009883a 	mov	r4,r16
81134258:	a80b883a 	mov	r5,r21
8113425c:	d8c00015 	stw	r3,0(sp)
81134260:	1134c7c0 	call	81134c7c <__umodsi3>
81134264:	8009883a 	mov	r4,r16
81134268:	a80b883a 	mov	r5,r21
8113426c:	1027883a 	mov	r19,r2
81134270:	1134c180 	call	81134c18 <__udivsi3>
81134274:	9826943a 	slli	r19,r19,16
81134278:	9008d43a 	srli	r4,r18,16
8113427c:	1521383a 	mul	r16,r2,r20
81134280:	102d883a 	mov	r22,r2
81134284:	24c8b03a 	or	r4,r4,r19
81134288:	d8c00017 	ldw	r3,0(sp)
8113428c:	2400052e 	bgeu	r4,r16,811342a4 <__udivdi3+0x244>
81134290:	2449883a 	add	r4,r4,r17
81134294:	b0bfffc4 	addi	r2,r22,-1
81134298:	24400136 	bltu	r4,r17,811342a0 <__udivdi3+0x240>
8113429c:	2400ca36 	bltu	r4,r16,811345c8 <__udivdi3+0x568>
811342a0:	102d883a 	mov	r22,r2
811342a4:	2421c83a 	sub	r16,r4,r16
811342a8:	a80b883a 	mov	r5,r21
811342ac:	8009883a 	mov	r4,r16
811342b0:	d8c00015 	stw	r3,0(sp)
811342b4:	1134c7c0 	call	81134c7c <__umodsi3>
811342b8:	1027883a 	mov	r19,r2
811342bc:	a80b883a 	mov	r5,r21
811342c0:	8009883a 	mov	r4,r16
811342c4:	1134c180 	call	81134c18 <__udivsi3>
811342c8:	9826943a 	slli	r19,r19,16
811342cc:	1529383a 	mul	r20,r2,r20
811342d0:	94bfffcc 	andi	r18,r18,65535
811342d4:	94e4b03a 	or	r18,r18,r19
811342d8:	d8c00017 	ldw	r3,0(sp)
811342dc:	9500052e 	bgeu	r18,r20,811342f4 <__udivdi3+0x294>
811342e0:	8ca5883a 	add	r18,r17,r18
811342e4:	113fffc4 	addi	r4,r2,-1
811342e8:	94409736 	bltu	r18,r17,81134548 <__udivdi3+0x4e8>
811342ec:	9500962e 	bgeu	r18,r20,81134548 <__udivdi3+0x4e8>
811342f0:	10bfff84 	addi	r2,r2,-2
811342f4:	b00c943a 	slli	r6,r22,16
811342f8:	3084b03a 	or	r2,r6,r2
811342fc:	00000206 	br	81134308 <__udivdi3+0x2a8>
81134300:	0007883a 	mov	r3,zero
81134304:	0005883a 	mov	r2,zero
81134308:	dfc00a17 	ldw	ra,40(sp)
8113430c:	df000917 	ldw	fp,36(sp)
81134310:	ddc00817 	ldw	r23,32(sp)
81134314:	dd800717 	ldw	r22,28(sp)
81134318:	dd400617 	ldw	r21,24(sp)
8113431c:	dd000517 	ldw	r20,20(sp)
81134320:	dcc00417 	ldw	r19,16(sp)
81134324:	dc800317 	ldw	r18,12(sp)
81134328:	dc400217 	ldw	r17,8(sp)
8113432c:	dc000117 	ldw	r16,4(sp)
81134330:	dec00b04 	addi	sp,sp,44
81134334:	f800283a 	ret
81134338:	00803fc4 	movi	r2,255
8113433c:	11c5803a 	cmpltu	r2,r2,r7
81134340:	100490fa 	slli	r2,r2,3
81134344:	003f9e06 	br	811341c0 <__reset+0xfb1141c0>
81134348:	00803fc4 	movi	r2,255
8113434c:	1445803a 	cmpltu	r2,r2,r17
81134350:	100490fa 	slli	r2,r2,3
81134354:	003fb206 	br	81134220 <__reset+0xfb114220>
81134358:	00804034 	movhi	r2,256
8113435c:	10bfffc4 	addi	r2,r2,-1
81134360:	11808836 	bltu	r2,r6,81134584 <__udivdi3+0x524>
81134364:	00800404 	movi	r2,16
81134368:	003f5606 	br	811340c4 <__reset+0xfb1140c4>
8113436c:	30aed83a 	srl	r23,r6,r2
81134370:	3d4e983a 	sll	r7,r7,r21
81134374:	80acd83a 	srl	r22,r16,r2
81134378:	9884d83a 	srl	r2,r19,r2
8113437c:	3deeb03a 	or	r23,r7,r23
81134380:	b824d43a 	srli	r18,r23,16
81134384:	8560983a 	sll	r16,r16,r21
81134388:	b009883a 	mov	r4,r22
8113438c:	900b883a 	mov	r5,r18
81134390:	3568983a 	sll	r20,r6,r21
81134394:	1420b03a 	or	r16,r2,r16
81134398:	1134c7c0 	call	81134c7c <__umodsi3>
8113439c:	b009883a 	mov	r4,r22
811343a0:	900b883a 	mov	r5,r18
811343a4:	1023883a 	mov	r17,r2
811343a8:	1134c180 	call	81134c18 <__udivsi3>
811343ac:	8808943a 	slli	r4,r17,16
811343b0:	bf3fffcc 	andi	fp,r23,65535
811343b4:	8006d43a 	srli	r3,r16,16
811343b8:	e0a3383a 	mul	r17,fp,r2
811343bc:	100d883a 	mov	r6,r2
811343c0:	1906b03a 	or	r3,r3,r4
811343c4:	1c40042e 	bgeu	r3,r17,811343d8 <__udivdi3+0x378>
811343c8:	1dc7883a 	add	r3,r3,r23
811343cc:	10bfffc4 	addi	r2,r2,-1
811343d0:	1dc0752e 	bgeu	r3,r23,811345a8 <__udivdi3+0x548>
811343d4:	100d883a 	mov	r6,r2
811343d8:	1c63c83a 	sub	r17,r3,r17
811343dc:	900b883a 	mov	r5,r18
811343e0:	8809883a 	mov	r4,r17
811343e4:	d9800015 	stw	r6,0(sp)
811343e8:	1134c7c0 	call	81134c7c <__umodsi3>
811343ec:	102d883a 	mov	r22,r2
811343f0:	8809883a 	mov	r4,r17
811343f4:	900b883a 	mov	r5,r18
811343f8:	1134c180 	call	81134c18 <__udivsi3>
811343fc:	b02c943a 	slli	r22,r22,16
81134400:	e089383a 	mul	r4,fp,r2
81134404:	843fffcc 	andi	r16,r16,65535
81134408:	85a0b03a 	or	r16,r16,r22
8113440c:	d9800017 	ldw	r6,0(sp)
81134410:	8100042e 	bgeu	r16,r4,81134424 <__udivdi3+0x3c4>
81134414:	85e1883a 	add	r16,r16,r23
81134418:	10ffffc4 	addi	r3,r2,-1
8113441c:	85c05e2e 	bgeu	r16,r23,81134598 <__udivdi3+0x538>
81134420:	1805883a 	mov	r2,r3
81134424:	300c943a 	slli	r6,r6,16
81134428:	a17fffcc 	andi	r5,r20,65535
8113442c:	a028d43a 	srli	r20,r20,16
81134430:	3084b03a 	or	r2,r6,r2
81134434:	10ffffcc 	andi	r3,r2,65535
81134438:	100cd43a 	srli	r6,r2,16
8113443c:	194f383a 	mul	r7,r3,r5
81134440:	1d07383a 	mul	r3,r3,r20
81134444:	314b383a 	mul	r5,r6,r5
81134448:	3810d43a 	srli	r8,r7,16
8113444c:	8121c83a 	sub	r16,r16,r4
81134450:	1947883a 	add	r3,r3,r5
81134454:	40c7883a 	add	r3,r8,r3
81134458:	350d383a 	mul	r6,r6,r20
8113445c:	1940022e 	bgeu	r3,r5,81134468 <__udivdi3+0x408>
81134460:	01000074 	movhi	r4,1
81134464:	310d883a 	add	r6,r6,r4
81134468:	1828d43a 	srli	r20,r3,16
8113446c:	a18d883a 	add	r6,r20,r6
81134470:	81803e36 	bltu	r16,r6,8113456c <__udivdi3+0x50c>
81134474:	81803826 	beq	r16,r6,81134558 <__udivdi3+0x4f8>
81134478:	0007883a 	mov	r3,zero
8113447c:	003fa206 	br	81134308 <__reset+0xfb114308>
81134480:	88e2983a 	sll	r17,r17,r3
81134484:	80a8d83a 	srl	r20,r16,r2
81134488:	80e0983a 	sll	r16,r16,r3
8113448c:	882ad43a 	srli	r21,r17,16
81134490:	9884d83a 	srl	r2,r19,r2
81134494:	a009883a 	mov	r4,r20
81134498:	a80b883a 	mov	r5,r21
8113449c:	142eb03a 	or	r23,r2,r16
811344a0:	98e4983a 	sll	r18,r19,r3
811344a4:	1134c7c0 	call	81134c7c <__umodsi3>
811344a8:	a009883a 	mov	r4,r20
811344ac:	a80b883a 	mov	r5,r21
811344b0:	1021883a 	mov	r16,r2
811344b4:	1134c180 	call	81134c18 <__udivsi3>
811344b8:	1039883a 	mov	fp,r2
811344bc:	8d3fffcc 	andi	r20,r17,65535
811344c0:	8020943a 	slli	r16,r16,16
811344c4:	b804d43a 	srli	r2,r23,16
811344c8:	a72d383a 	mul	r22,r20,fp
811344cc:	1404b03a 	or	r2,r2,r16
811344d0:	1580062e 	bgeu	r2,r22,811344ec <__udivdi3+0x48c>
811344d4:	1445883a 	add	r2,r2,r17
811344d8:	e0ffffc4 	addi	r3,fp,-1
811344dc:	14403836 	bltu	r2,r17,811345c0 <__udivdi3+0x560>
811344e0:	1580372e 	bgeu	r2,r22,811345c0 <__udivdi3+0x560>
811344e4:	e73fff84 	addi	fp,fp,-2
811344e8:	1445883a 	add	r2,r2,r17
811344ec:	15adc83a 	sub	r22,r2,r22
811344f0:	a80b883a 	mov	r5,r21
811344f4:	b009883a 	mov	r4,r22
811344f8:	1134c7c0 	call	81134c7c <__umodsi3>
811344fc:	1027883a 	mov	r19,r2
81134500:	b009883a 	mov	r4,r22
81134504:	a80b883a 	mov	r5,r21
81134508:	1134c180 	call	81134c18 <__udivsi3>
8113450c:	9826943a 	slli	r19,r19,16
81134510:	a0a1383a 	mul	r16,r20,r2
81134514:	b93fffcc 	andi	r4,r23,65535
81134518:	24c8b03a 	or	r4,r4,r19
8113451c:	2400062e 	bgeu	r4,r16,81134538 <__udivdi3+0x4d8>
81134520:	2449883a 	add	r4,r4,r17
81134524:	10ffffc4 	addi	r3,r2,-1
81134528:	24402336 	bltu	r4,r17,811345b8 <__udivdi3+0x558>
8113452c:	2400222e 	bgeu	r4,r16,811345b8 <__udivdi3+0x558>
81134530:	10bfff84 	addi	r2,r2,-2
81134534:	2449883a 	add	r4,r4,r17
81134538:	e038943a 	slli	fp,fp,16
8113453c:	2421c83a 	sub	r16,r4,r16
81134540:	e086b03a 	or	r3,fp,r2
81134544:	003f4306 	br	81134254 <__reset+0xfb114254>
81134548:	2005883a 	mov	r2,r4
8113454c:	003f6906 	br	811342f4 <__reset+0xfb1142f4>
81134550:	1805883a 	mov	r2,r3
81134554:	003f0f06 	br	81134194 <__reset+0xfb114194>
81134558:	1806943a 	slli	r3,r3,16
8113455c:	9d66983a 	sll	r19,r19,r21
81134560:	39ffffcc 	andi	r7,r7,65535
81134564:	19c7883a 	add	r3,r3,r7
81134568:	98ffc32e 	bgeu	r19,r3,81134478 <__reset+0xfb114478>
8113456c:	10bfffc4 	addi	r2,r2,-1
81134570:	003fc106 	br	81134478 <__reset+0xfb114478>
81134574:	00800604 	movi	r2,24
81134578:	003f1106 	br	811341c0 <__reset+0xfb1141c0>
8113457c:	00800604 	movi	r2,24
81134580:	003f2706 	br	81134220 <__reset+0xfb114220>
81134584:	00800604 	movi	r2,24
81134588:	003ece06 	br	811340c4 <__reset+0xfb1140c4>
8113458c:	0007883a 	mov	r3,zero
81134590:	00800044 	movi	r2,1
81134594:	003f5c06 	br	81134308 <__reset+0xfb114308>
81134598:	813fa12e 	bgeu	r16,r4,81134420 <__reset+0xfb114420>
8113459c:	10bfff84 	addi	r2,r2,-2
811345a0:	85e1883a 	add	r16,r16,r23
811345a4:	003f9f06 	br	81134424 <__reset+0xfb114424>
811345a8:	1c7f8a2e 	bgeu	r3,r17,811343d4 <__reset+0xfb1143d4>
811345ac:	31bfff84 	addi	r6,r6,-2
811345b0:	1dc7883a 	add	r3,r3,r23
811345b4:	003f8806 	br	811343d8 <__reset+0xfb1143d8>
811345b8:	1805883a 	mov	r2,r3
811345bc:	003fde06 	br	81134538 <__reset+0xfb114538>
811345c0:	1839883a 	mov	fp,r3
811345c4:	003fc906 	br	811344ec <__reset+0xfb1144ec>
811345c8:	b5bfff84 	addi	r22,r22,-2
811345cc:	2449883a 	add	r4,r4,r17
811345d0:	003f3406 	br	811342a4 <__reset+0xfb1142a4>
811345d4:	b5bfff84 	addi	r22,r22,-2
811345d8:	1445883a 	add	r2,r2,r17
811345dc:	003edb06 	br	8113414c <__reset+0xfb11414c>

811345e0 <__umoddi3>:
811345e0:	defff404 	addi	sp,sp,-48
811345e4:	de00012e 	bgeu	sp,et,811345ec <__umoddi3+0xc>
811345e8:	003b68fa 	trap	3
811345ec:	df000a15 	stw	fp,40(sp)
811345f0:	dc400315 	stw	r17,12(sp)
811345f4:	dc000215 	stw	r16,8(sp)
811345f8:	dfc00b15 	stw	ra,44(sp)
811345fc:	ddc00915 	stw	r23,36(sp)
81134600:	dd800815 	stw	r22,32(sp)
81134604:	dd400715 	stw	r21,28(sp)
81134608:	dd000615 	stw	r20,24(sp)
8113460c:	dcc00515 	stw	r19,20(sp)
81134610:	dc800415 	stw	r18,16(sp)
81134614:	2021883a 	mov	r16,r4
81134618:	2823883a 	mov	r17,r5
8113461c:	2839883a 	mov	fp,r5
81134620:	38003c1e 	bne	r7,zero,81134714 <__umoddi3+0x134>
81134624:	3027883a 	mov	r19,r6
81134628:	2029883a 	mov	r20,r4
8113462c:	2980512e 	bgeu	r5,r6,81134774 <__umoddi3+0x194>
81134630:	00bfffd4 	movui	r2,65535
81134634:	11809a36 	bltu	r2,r6,811348a0 <__umoddi3+0x2c0>
81134638:	01003fc4 	movi	r4,255
8113463c:	2189803a 	cmpltu	r4,r4,r6
81134640:	200890fa 	slli	r4,r4,3
81134644:	3104d83a 	srl	r2,r6,r4
81134648:	00e04574 	movhi	r3,33045
8113464c:	18c25404 	addi	r3,r3,2384
81134650:	1885883a 	add	r2,r3,r2
81134654:	10c00003 	ldbu	r3,0(r2)
81134658:	00800804 	movi	r2,32
8113465c:	1909883a 	add	r4,r3,r4
81134660:	1125c83a 	sub	r18,r2,r4
81134664:	90000526 	beq	r18,zero,8113467c <__umoddi3+0x9c>
81134668:	8ca2983a 	sll	r17,r17,r18
8113466c:	8108d83a 	srl	r4,r16,r4
81134670:	34a6983a 	sll	r19,r6,r18
81134674:	84a8983a 	sll	r20,r16,r18
81134678:	2478b03a 	or	fp,r4,r17
8113467c:	982ed43a 	srli	r23,r19,16
81134680:	e009883a 	mov	r4,fp
81134684:	9dbfffcc 	andi	r22,r19,65535
81134688:	b80b883a 	mov	r5,r23
8113468c:	1134c7c0 	call	81134c7c <__umodsi3>
81134690:	e009883a 	mov	r4,fp
81134694:	b80b883a 	mov	r5,r23
81134698:	102b883a 	mov	r21,r2
8113469c:	1134c180 	call	81134c18 <__udivsi3>
811346a0:	a806943a 	slli	r3,r21,16
811346a4:	a008d43a 	srli	r4,r20,16
811346a8:	b085383a 	mul	r2,r22,r2
811346ac:	20c8b03a 	or	r4,r4,r3
811346b0:	2080032e 	bgeu	r4,r2,811346c0 <__umoddi3+0xe0>
811346b4:	24c9883a 	add	r4,r4,r19
811346b8:	24c00136 	bltu	r4,r19,811346c0 <__umoddi3+0xe0>
811346bc:	20811036 	bltu	r4,r2,81134b00 <__umoddi3+0x520>
811346c0:	20abc83a 	sub	r21,r4,r2
811346c4:	b80b883a 	mov	r5,r23
811346c8:	a809883a 	mov	r4,r21
811346cc:	1134c7c0 	call	81134c7c <__umodsi3>
811346d0:	1023883a 	mov	r17,r2
811346d4:	b80b883a 	mov	r5,r23
811346d8:	a809883a 	mov	r4,r21
811346dc:	1134c180 	call	81134c18 <__udivsi3>
811346e0:	8822943a 	slli	r17,r17,16
811346e4:	b085383a 	mul	r2,r22,r2
811346e8:	a0ffffcc 	andi	r3,r20,65535
811346ec:	1c46b03a 	or	r3,r3,r17
811346f0:	1880042e 	bgeu	r3,r2,81134704 <__umoddi3+0x124>
811346f4:	1cc7883a 	add	r3,r3,r19
811346f8:	1cc00236 	bltu	r3,r19,81134704 <__umoddi3+0x124>
811346fc:	1880012e 	bgeu	r3,r2,81134704 <__umoddi3+0x124>
81134700:	1cc7883a 	add	r3,r3,r19
81134704:	1885c83a 	sub	r2,r3,r2
81134708:	1484d83a 	srl	r2,r2,r18
8113470c:	0007883a 	mov	r3,zero
81134710:	00004f06 	br	81134850 <__umoddi3+0x270>
81134714:	29c04c36 	bltu	r5,r7,81134848 <__umoddi3+0x268>
81134718:	00bfffd4 	movui	r2,65535
8113471c:	11c0582e 	bgeu	r2,r7,81134880 <__umoddi3+0x2a0>
81134720:	00804034 	movhi	r2,256
81134724:	10bfffc4 	addi	r2,r2,-1
81134728:	11c0e736 	bltu	r2,r7,81134ac8 <__umoddi3+0x4e8>
8113472c:	01000404 	movi	r4,16
81134730:	3904d83a 	srl	r2,r7,r4
81134734:	00e04574 	movhi	r3,33045
81134738:	18c25404 	addi	r3,r3,2384
8113473c:	1885883a 	add	r2,r3,r2
81134740:	14c00003 	ldbu	r19,0(r2)
81134744:	00c00804 	movi	r3,32
81134748:	9927883a 	add	r19,r19,r4
8113474c:	1ce9c83a 	sub	r20,r3,r19
81134750:	a000581e 	bne	r20,zero,811348b4 <__umoddi3+0x2d4>
81134754:	3c400136 	bltu	r7,r17,8113475c <__umoddi3+0x17c>
81134758:	8180eb36 	bltu	r16,r6,81134b08 <__umoddi3+0x528>
8113475c:	8185c83a 	sub	r2,r16,r6
81134760:	89e3c83a 	sub	r17,r17,r7
81134764:	8089803a 	cmpltu	r4,r16,r2
81134768:	8939c83a 	sub	fp,r17,r4
8113476c:	e007883a 	mov	r3,fp
81134770:	00003706 	br	81134850 <__umoddi3+0x270>
81134774:	3000041e 	bne	r6,zero,81134788 <__umoddi3+0x1a8>
81134778:	000b883a 	mov	r5,zero
8113477c:	01000044 	movi	r4,1
81134780:	1134c180 	call	81134c18 <__udivsi3>
81134784:	1027883a 	mov	r19,r2
81134788:	00bfffd4 	movui	r2,65535
8113478c:	14c0402e 	bgeu	r2,r19,81134890 <__umoddi3+0x2b0>
81134790:	00804034 	movhi	r2,256
81134794:	10bfffc4 	addi	r2,r2,-1
81134798:	14c0cd36 	bltu	r2,r19,81134ad0 <__umoddi3+0x4f0>
8113479c:	00800404 	movi	r2,16
811347a0:	9886d83a 	srl	r3,r19,r2
811347a4:	01204574 	movhi	r4,33045
811347a8:	21025404 	addi	r4,r4,2384
811347ac:	20c7883a 	add	r3,r4,r3
811347b0:	18c00003 	ldbu	r3,0(r3)
811347b4:	1887883a 	add	r3,r3,r2
811347b8:	00800804 	movi	r2,32
811347bc:	10e5c83a 	sub	r18,r2,r3
811347c0:	9000901e 	bne	r18,zero,81134a04 <__umoddi3+0x424>
811347c4:	982cd43a 	srli	r22,r19,16
811347c8:	8ce3c83a 	sub	r17,r17,r19
811347cc:	9d7fffcc 	andi	r21,r19,65535
811347d0:	b00b883a 	mov	r5,r22
811347d4:	8809883a 	mov	r4,r17
811347d8:	1134c7c0 	call	81134c7c <__umodsi3>
811347dc:	8809883a 	mov	r4,r17
811347e0:	b00b883a 	mov	r5,r22
811347e4:	1021883a 	mov	r16,r2
811347e8:	1134c180 	call	81134c18 <__udivsi3>
811347ec:	8006943a 	slli	r3,r16,16
811347f0:	a008d43a 	srli	r4,r20,16
811347f4:	1545383a 	mul	r2,r2,r21
811347f8:	20c8b03a 	or	r4,r4,r3
811347fc:	2080042e 	bgeu	r4,r2,81134810 <__umoddi3+0x230>
81134800:	24c9883a 	add	r4,r4,r19
81134804:	24c00236 	bltu	r4,r19,81134810 <__umoddi3+0x230>
81134808:	2080012e 	bgeu	r4,r2,81134810 <__umoddi3+0x230>
8113480c:	24c9883a 	add	r4,r4,r19
81134810:	20a1c83a 	sub	r16,r4,r2
81134814:	b00b883a 	mov	r5,r22
81134818:	8009883a 	mov	r4,r16
8113481c:	1134c7c0 	call	81134c7c <__umodsi3>
81134820:	1023883a 	mov	r17,r2
81134824:	b00b883a 	mov	r5,r22
81134828:	8009883a 	mov	r4,r16
8113482c:	1134c180 	call	81134c18 <__udivsi3>
81134830:	8822943a 	slli	r17,r17,16
81134834:	1545383a 	mul	r2,r2,r21
81134838:	a53fffcc 	andi	r20,r20,65535
8113483c:	a446b03a 	or	r3,r20,r17
81134840:	18bfb02e 	bgeu	r3,r2,81134704 <__reset+0xfb114704>
81134844:	003fab06 	br	811346f4 <__reset+0xfb1146f4>
81134848:	2005883a 	mov	r2,r4
8113484c:	2807883a 	mov	r3,r5
81134850:	dfc00b17 	ldw	ra,44(sp)
81134854:	df000a17 	ldw	fp,40(sp)
81134858:	ddc00917 	ldw	r23,36(sp)
8113485c:	dd800817 	ldw	r22,32(sp)
81134860:	dd400717 	ldw	r21,28(sp)
81134864:	dd000617 	ldw	r20,24(sp)
81134868:	dcc00517 	ldw	r19,20(sp)
8113486c:	dc800417 	ldw	r18,16(sp)
81134870:	dc400317 	ldw	r17,12(sp)
81134874:	dc000217 	ldw	r16,8(sp)
81134878:	dec00c04 	addi	sp,sp,48
8113487c:	f800283a 	ret
81134880:	04c03fc4 	movi	r19,255
81134884:	99c9803a 	cmpltu	r4,r19,r7
81134888:	200890fa 	slli	r4,r4,3
8113488c:	003fa806 	br	81134730 <__reset+0xfb114730>
81134890:	00803fc4 	movi	r2,255
81134894:	14c5803a 	cmpltu	r2,r2,r19
81134898:	100490fa 	slli	r2,r2,3
8113489c:	003fc006 	br	811347a0 <__reset+0xfb1147a0>
811348a0:	00804034 	movhi	r2,256
811348a4:	10bfffc4 	addi	r2,r2,-1
811348a8:	11808b36 	bltu	r2,r6,81134ad8 <__umoddi3+0x4f8>
811348ac:	01000404 	movi	r4,16
811348b0:	003f6406 	br	81134644 <__reset+0xfb114644>
811348b4:	34c4d83a 	srl	r2,r6,r19
811348b8:	3d0e983a 	sll	r7,r7,r20
811348bc:	8cf8d83a 	srl	fp,r17,r19
811348c0:	8d10983a 	sll	r8,r17,r20
811348c4:	38aab03a 	or	r21,r7,r2
811348c8:	a82cd43a 	srli	r22,r21,16
811348cc:	84e2d83a 	srl	r17,r16,r19
811348d0:	e009883a 	mov	r4,fp
811348d4:	b00b883a 	mov	r5,r22
811348d8:	8a22b03a 	or	r17,r17,r8
811348dc:	3524983a 	sll	r18,r6,r20
811348e0:	1134c7c0 	call	81134c7c <__umodsi3>
811348e4:	e009883a 	mov	r4,fp
811348e8:	b00b883a 	mov	r5,r22
811348ec:	102f883a 	mov	r23,r2
811348f0:	1134c180 	call	81134c18 <__udivsi3>
811348f4:	100d883a 	mov	r6,r2
811348f8:	b808943a 	slli	r4,r23,16
811348fc:	aa3fffcc 	andi	r8,r21,65535
81134900:	8804d43a 	srli	r2,r17,16
81134904:	41af383a 	mul	r23,r8,r6
81134908:	8520983a 	sll	r16,r16,r20
8113490c:	1104b03a 	or	r2,r2,r4
81134910:	15c0042e 	bgeu	r2,r23,81134924 <__umoddi3+0x344>
81134914:	1545883a 	add	r2,r2,r21
81134918:	30ffffc4 	addi	r3,r6,-1
8113491c:	1540742e 	bgeu	r2,r21,81134af0 <__umoddi3+0x510>
81134920:	180d883a 	mov	r6,r3
81134924:	15efc83a 	sub	r23,r2,r23
81134928:	b00b883a 	mov	r5,r22
8113492c:	b809883a 	mov	r4,r23
81134930:	d9800115 	stw	r6,4(sp)
81134934:	da000015 	stw	r8,0(sp)
81134938:	1134c7c0 	call	81134c7c <__umodsi3>
8113493c:	b00b883a 	mov	r5,r22
81134940:	b809883a 	mov	r4,r23
81134944:	1039883a 	mov	fp,r2
81134948:	1134c180 	call	81134c18 <__udivsi3>
8113494c:	da000017 	ldw	r8,0(sp)
81134950:	e038943a 	slli	fp,fp,16
81134954:	100b883a 	mov	r5,r2
81134958:	4089383a 	mul	r4,r8,r2
8113495c:	8a3fffcc 	andi	r8,r17,65535
81134960:	4710b03a 	or	r8,r8,fp
81134964:	d9800117 	ldw	r6,4(sp)
81134968:	4100042e 	bgeu	r8,r4,8113497c <__umoddi3+0x39c>
8113496c:	4551883a 	add	r8,r8,r21
81134970:	10bfffc4 	addi	r2,r2,-1
81134974:	45405a2e 	bgeu	r8,r21,81134ae0 <__umoddi3+0x500>
81134978:	100b883a 	mov	r5,r2
8113497c:	300c943a 	slli	r6,r6,16
81134980:	91ffffcc 	andi	r7,r18,65535
81134984:	9004d43a 	srli	r2,r18,16
81134988:	314cb03a 	or	r6,r6,r5
8113498c:	317fffcc 	andi	r5,r6,65535
81134990:	300cd43a 	srli	r6,r6,16
81134994:	29d3383a 	mul	r9,r5,r7
81134998:	288b383a 	mul	r5,r5,r2
8113499c:	31cf383a 	mul	r7,r6,r7
811349a0:	4806d43a 	srli	r3,r9,16
811349a4:	4111c83a 	sub	r8,r8,r4
811349a8:	29cb883a 	add	r5,r5,r7
811349ac:	194b883a 	add	r5,r3,r5
811349b0:	3085383a 	mul	r2,r6,r2
811349b4:	29c0022e 	bgeu	r5,r7,811349c0 <__umoddi3+0x3e0>
811349b8:	00c00074 	movhi	r3,1
811349bc:	10c5883a 	add	r2,r2,r3
811349c0:	2808d43a 	srli	r4,r5,16
811349c4:	280a943a 	slli	r5,r5,16
811349c8:	4a7fffcc 	andi	r9,r9,65535
811349cc:	2085883a 	add	r2,r4,r2
811349d0:	2a4b883a 	add	r5,r5,r9
811349d4:	40803636 	bltu	r8,r2,81134ab0 <__umoddi3+0x4d0>
811349d8:	40804d26 	beq	r8,r2,81134b10 <__umoddi3+0x530>
811349dc:	4089c83a 	sub	r4,r8,r2
811349e0:	280f883a 	mov	r7,r5
811349e4:	81cfc83a 	sub	r7,r16,r7
811349e8:	81c7803a 	cmpltu	r3,r16,r7
811349ec:	20c7c83a 	sub	r3,r4,r3
811349f0:	1cc4983a 	sll	r2,r3,r19
811349f4:	3d0ed83a 	srl	r7,r7,r20
811349f8:	1d06d83a 	srl	r3,r3,r20
811349fc:	11c4b03a 	or	r2,r2,r7
81134a00:	003f9306 	br	81134850 <__reset+0xfb114850>
81134a04:	9ca6983a 	sll	r19,r19,r18
81134a08:	88e8d83a 	srl	r20,r17,r3
81134a0c:	80c4d83a 	srl	r2,r16,r3
81134a10:	982cd43a 	srli	r22,r19,16
81134a14:	8ca2983a 	sll	r17,r17,r18
81134a18:	a009883a 	mov	r4,r20
81134a1c:	b00b883a 	mov	r5,r22
81134a20:	1478b03a 	or	fp,r2,r17
81134a24:	1134c7c0 	call	81134c7c <__umodsi3>
81134a28:	a009883a 	mov	r4,r20
81134a2c:	b00b883a 	mov	r5,r22
81134a30:	1023883a 	mov	r17,r2
81134a34:	1134c180 	call	81134c18 <__udivsi3>
81134a38:	9d7fffcc 	andi	r21,r19,65535
81134a3c:	880a943a 	slli	r5,r17,16
81134a40:	e008d43a 	srli	r4,fp,16
81134a44:	a885383a 	mul	r2,r21,r2
81134a48:	84a8983a 	sll	r20,r16,r18
81134a4c:	2148b03a 	or	r4,r4,r5
81134a50:	2080042e 	bgeu	r4,r2,81134a64 <__umoddi3+0x484>
81134a54:	24c9883a 	add	r4,r4,r19
81134a58:	24c00236 	bltu	r4,r19,81134a64 <__umoddi3+0x484>
81134a5c:	2080012e 	bgeu	r4,r2,81134a64 <__umoddi3+0x484>
81134a60:	24c9883a 	add	r4,r4,r19
81134a64:	20a3c83a 	sub	r17,r4,r2
81134a68:	b00b883a 	mov	r5,r22
81134a6c:	8809883a 	mov	r4,r17
81134a70:	1134c7c0 	call	81134c7c <__umodsi3>
81134a74:	102f883a 	mov	r23,r2
81134a78:	8809883a 	mov	r4,r17
81134a7c:	b00b883a 	mov	r5,r22
81134a80:	1134c180 	call	81134c18 <__udivsi3>
81134a84:	b82e943a 	slli	r23,r23,16
81134a88:	a885383a 	mul	r2,r21,r2
81134a8c:	e13fffcc 	andi	r4,fp,65535
81134a90:	25c8b03a 	or	r4,r4,r23
81134a94:	2080042e 	bgeu	r4,r2,81134aa8 <__umoddi3+0x4c8>
81134a98:	24c9883a 	add	r4,r4,r19
81134a9c:	24c00236 	bltu	r4,r19,81134aa8 <__umoddi3+0x4c8>
81134aa0:	2080012e 	bgeu	r4,r2,81134aa8 <__umoddi3+0x4c8>
81134aa4:	24c9883a 	add	r4,r4,r19
81134aa8:	20a3c83a 	sub	r17,r4,r2
81134aac:	003f4806 	br	811347d0 <__reset+0xfb1147d0>
81134ab0:	2c8fc83a 	sub	r7,r5,r18
81134ab4:	1545c83a 	sub	r2,r2,r21
81134ab8:	29cb803a 	cmpltu	r5,r5,r7
81134abc:	1145c83a 	sub	r2,r2,r5
81134ac0:	4089c83a 	sub	r4,r8,r2
81134ac4:	003fc706 	br	811349e4 <__reset+0xfb1149e4>
81134ac8:	01000604 	movi	r4,24
81134acc:	003f1806 	br	81134730 <__reset+0xfb114730>
81134ad0:	00800604 	movi	r2,24
81134ad4:	003f3206 	br	811347a0 <__reset+0xfb1147a0>
81134ad8:	01000604 	movi	r4,24
81134adc:	003ed906 	br	81134644 <__reset+0xfb114644>
81134ae0:	413fa52e 	bgeu	r8,r4,81134978 <__reset+0xfb114978>
81134ae4:	297fff84 	addi	r5,r5,-2
81134ae8:	4551883a 	add	r8,r8,r21
81134aec:	003fa306 	br	8113497c <__reset+0xfb11497c>
81134af0:	15ff8b2e 	bgeu	r2,r23,81134920 <__reset+0xfb114920>
81134af4:	31bfff84 	addi	r6,r6,-2
81134af8:	1545883a 	add	r2,r2,r21
81134afc:	003f8906 	br	81134924 <__reset+0xfb114924>
81134b00:	24c9883a 	add	r4,r4,r19
81134b04:	003eee06 	br	811346c0 <__reset+0xfb1146c0>
81134b08:	8005883a 	mov	r2,r16
81134b0c:	003f1706 	br	8113476c <__reset+0xfb11476c>
81134b10:	817fe736 	bltu	r16,r5,81134ab0 <__reset+0xfb114ab0>
81134b14:	280f883a 	mov	r7,r5
81134b18:	0009883a 	mov	r4,zero
81134b1c:	003fb106 	br	811349e4 <__reset+0xfb1149e4>

81134b20 <__divsi3>:
81134b20:	20001b16 	blt	r4,zero,81134b90 <__divsi3+0x70>
81134b24:	000f883a 	mov	r7,zero
81134b28:	28001616 	blt	r5,zero,81134b84 <__divsi3+0x64>
81134b2c:	200d883a 	mov	r6,r4
81134b30:	29001a2e 	bgeu	r5,r4,81134b9c <__divsi3+0x7c>
81134b34:	00800804 	movi	r2,32
81134b38:	00c00044 	movi	r3,1
81134b3c:	00000106 	br	81134b44 <__divsi3+0x24>
81134b40:	10000d26 	beq	r2,zero,81134b78 <__divsi3+0x58>
81134b44:	294b883a 	add	r5,r5,r5
81134b48:	10bfffc4 	addi	r2,r2,-1
81134b4c:	18c7883a 	add	r3,r3,r3
81134b50:	293ffb36 	bltu	r5,r4,81134b40 <__reset+0xfb114b40>
81134b54:	0005883a 	mov	r2,zero
81134b58:	18000726 	beq	r3,zero,81134b78 <__divsi3+0x58>
81134b5c:	0005883a 	mov	r2,zero
81134b60:	31400236 	bltu	r6,r5,81134b6c <__divsi3+0x4c>
81134b64:	314dc83a 	sub	r6,r6,r5
81134b68:	10c4b03a 	or	r2,r2,r3
81134b6c:	1806d07a 	srli	r3,r3,1
81134b70:	280ad07a 	srli	r5,r5,1
81134b74:	183ffa1e 	bne	r3,zero,81134b60 <__reset+0xfb114b60>
81134b78:	38000126 	beq	r7,zero,81134b80 <__divsi3+0x60>
81134b7c:	0085c83a 	sub	r2,zero,r2
81134b80:	f800283a 	ret
81134b84:	014bc83a 	sub	r5,zero,r5
81134b88:	39c0005c 	xori	r7,r7,1
81134b8c:	003fe706 	br	81134b2c <__reset+0xfb114b2c>
81134b90:	0109c83a 	sub	r4,zero,r4
81134b94:	01c00044 	movi	r7,1
81134b98:	003fe306 	br	81134b28 <__reset+0xfb114b28>
81134b9c:	00c00044 	movi	r3,1
81134ba0:	003fee06 	br	81134b5c <__reset+0xfb114b5c>

81134ba4 <__modsi3>:
81134ba4:	20001716 	blt	r4,zero,81134c04 <__modsi3+0x60>
81134ba8:	000f883a 	mov	r7,zero
81134bac:	2005883a 	mov	r2,r4
81134bb0:	28001216 	blt	r5,zero,81134bfc <__modsi3+0x58>
81134bb4:	2900162e 	bgeu	r5,r4,81134c10 <__modsi3+0x6c>
81134bb8:	01800804 	movi	r6,32
81134bbc:	00c00044 	movi	r3,1
81134bc0:	00000106 	br	81134bc8 <__modsi3+0x24>
81134bc4:	30000a26 	beq	r6,zero,81134bf0 <__modsi3+0x4c>
81134bc8:	294b883a 	add	r5,r5,r5
81134bcc:	31bfffc4 	addi	r6,r6,-1
81134bd0:	18c7883a 	add	r3,r3,r3
81134bd4:	293ffb36 	bltu	r5,r4,81134bc4 <__reset+0xfb114bc4>
81134bd8:	18000526 	beq	r3,zero,81134bf0 <__modsi3+0x4c>
81134bdc:	1806d07a 	srli	r3,r3,1
81134be0:	11400136 	bltu	r2,r5,81134be8 <__modsi3+0x44>
81134be4:	1145c83a 	sub	r2,r2,r5
81134be8:	280ad07a 	srli	r5,r5,1
81134bec:	183ffb1e 	bne	r3,zero,81134bdc <__reset+0xfb114bdc>
81134bf0:	38000126 	beq	r7,zero,81134bf8 <__modsi3+0x54>
81134bf4:	0085c83a 	sub	r2,zero,r2
81134bf8:	f800283a 	ret
81134bfc:	014bc83a 	sub	r5,zero,r5
81134c00:	003fec06 	br	81134bb4 <__reset+0xfb114bb4>
81134c04:	0109c83a 	sub	r4,zero,r4
81134c08:	01c00044 	movi	r7,1
81134c0c:	003fe706 	br	81134bac <__reset+0xfb114bac>
81134c10:	00c00044 	movi	r3,1
81134c14:	003ff106 	br	81134bdc <__reset+0xfb114bdc>

81134c18 <__udivsi3>:
81134c18:	200d883a 	mov	r6,r4
81134c1c:	2900152e 	bgeu	r5,r4,81134c74 <__udivsi3+0x5c>
81134c20:	28001416 	blt	r5,zero,81134c74 <__udivsi3+0x5c>
81134c24:	00800804 	movi	r2,32
81134c28:	00c00044 	movi	r3,1
81134c2c:	00000206 	br	81134c38 <__udivsi3+0x20>
81134c30:	10000e26 	beq	r2,zero,81134c6c <__udivsi3+0x54>
81134c34:	28000516 	blt	r5,zero,81134c4c <__udivsi3+0x34>
81134c38:	294b883a 	add	r5,r5,r5
81134c3c:	10bfffc4 	addi	r2,r2,-1
81134c40:	18c7883a 	add	r3,r3,r3
81134c44:	293ffa36 	bltu	r5,r4,81134c30 <__reset+0xfb114c30>
81134c48:	18000826 	beq	r3,zero,81134c6c <__udivsi3+0x54>
81134c4c:	0005883a 	mov	r2,zero
81134c50:	31400236 	bltu	r6,r5,81134c5c <__udivsi3+0x44>
81134c54:	314dc83a 	sub	r6,r6,r5
81134c58:	10c4b03a 	or	r2,r2,r3
81134c5c:	1806d07a 	srli	r3,r3,1
81134c60:	280ad07a 	srli	r5,r5,1
81134c64:	183ffa1e 	bne	r3,zero,81134c50 <__reset+0xfb114c50>
81134c68:	f800283a 	ret
81134c6c:	0005883a 	mov	r2,zero
81134c70:	f800283a 	ret
81134c74:	00c00044 	movi	r3,1
81134c78:	003ff406 	br	81134c4c <__reset+0xfb114c4c>

81134c7c <__umodsi3>:
81134c7c:	2005883a 	mov	r2,r4
81134c80:	2900122e 	bgeu	r5,r4,81134ccc <__umodsi3+0x50>
81134c84:	28001116 	blt	r5,zero,81134ccc <__umodsi3+0x50>
81134c88:	01800804 	movi	r6,32
81134c8c:	00c00044 	movi	r3,1
81134c90:	00000206 	br	81134c9c <__umodsi3+0x20>
81134c94:	30000c26 	beq	r6,zero,81134cc8 <__umodsi3+0x4c>
81134c98:	28000516 	blt	r5,zero,81134cb0 <__umodsi3+0x34>
81134c9c:	294b883a 	add	r5,r5,r5
81134ca0:	31bfffc4 	addi	r6,r6,-1
81134ca4:	18c7883a 	add	r3,r3,r3
81134ca8:	293ffa36 	bltu	r5,r4,81134c94 <__reset+0xfb114c94>
81134cac:	18000626 	beq	r3,zero,81134cc8 <__umodsi3+0x4c>
81134cb0:	1806d07a 	srli	r3,r3,1
81134cb4:	11400136 	bltu	r2,r5,81134cbc <__umodsi3+0x40>
81134cb8:	1145c83a 	sub	r2,r2,r5
81134cbc:	280ad07a 	srli	r5,r5,1
81134cc0:	183ffb1e 	bne	r3,zero,81134cb0 <__reset+0xfb114cb0>
81134cc4:	f800283a 	ret
81134cc8:	f800283a 	ret
81134ccc:	00c00044 	movi	r3,1
81134cd0:	003ff706 	br	81134cb0 <__reset+0xfb114cb0>

81134cd4 <__eqsf2>:
81134cd4:	2006d5fa 	srli	r3,r4,23
81134cd8:	280cd5fa 	srli	r6,r5,23
81134cdc:	01c02034 	movhi	r7,128
81134ce0:	39ffffc4 	addi	r7,r7,-1
81134ce4:	18c03fcc 	andi	r3,r3,255
81134ce8:	02003fc4 	movi	r8,255
81134cec:	3904703a 	and	r2,r7,r4
81134cf0:	31803fcc 	andi	r6,r6,255
81134cf4:	394e703a 	and	r7,r7,r5
81134cf8:	2008d7fa 	srli	r4,r4,31
81134cfc:	280ad7fa 	srli	r5,r5,31
81134d00:	1a000d26 	beq	r3,r8,81134d38 <__eqsf2+0x64>
81134d04:	02003fc4 	movi	r8,255
81134d08:	32000826 	beq	r6,r8,81134d2c <__eqsf2+0x58>
81134d0c:	19800226 	beq	r3,r6,81134d18 <__eqsf2+0x44>
81134d10:	00800044 	movi	r2,1
81134d14:	f800283a 	ret
81134d18:	11fffd1e 	bne	r2,r7,81134d10 <__reset+0xfb114d10>
81134d1c:	21400926 	beq	r4,r5,81134d44 <__eqsf2+0x70>
81134d20:	183ffb1e 	bne	r3,zero,81134d10 <__reset+0xfb114d10>
81134d24:	1004c03a 	cmpne	r2,r2,zero
81134d28:	f800283a 	ret
81134d2c:	383ff726 	beq	r7,zero,81134d0c <__reset+0xfb114d0c>
81134d30:	00800044 	movi	r2,1
81134d34:	f800283a 	ret
81134d38:	103ff226 	beq	r2,zero,81134d04 <__reset+0xfb114d04>
81134d3c:	00800044 	movi	r2,1
81134d40:	f800283a 	ret
81134d44:	0005883a 	mov	r2,zero
81134d48:	f800283a 	ret

81134d4c <__gesf2>:
81134d4c:	2004d5fa 	srli	r2,r4,23
81134d50:	2806d5fa 	srli	r3,r5,23
81134d54:	01802034 	movhi	r6,128
81134d58:	31bfffc4 	addi	r6,r6,-1
81134d5c:	10803fcc 	andi	r2,r2,255
81134d60:	01c03fc4 	movi	r7,255
81134d64:	3110703a 	and	r8,r6,r4
81134d68:	18c03fcc 	andi	r3,r3,255
81134d6c:	314c703a 	and	r6,r6,r5
81134d70:	2008d7fa 	srli	r4,r4,31
81134d74:	280ad7fa 	srli	r5,r5,31
81134d78:	11c01926 	beq	r2,r7,81134de0 <__gesf2+0x94>
81134d7c:	01c03fc4 	movi	r7,255
81134d80:	19c00f26 	beq	r3,r7,81134dc0 <__gesf2+0x74>
81134d84:	1000061e 	bne	r2,zero,81134da0 <__gesf2+0x54>
81134d88:	400f003a 	cmpeq	r7,r8,zero
81134d8c:	1800071e 	bne	r3,zero,81134dac <__gesf2+0x60>
81134d90:	3000061e 	bne	r6,zero,81134dac <__gesf2+0x60>
81134d94:	0005883a 	mov	r2,zero
81134d98:	40000e1e 	bne	r8,zero,81134dd4 <__gesf2+0x88>
81134d9c:	f800283a 	ret
81134da0:	18000a1e 	bne	r3,zero,81134dcc <__gesf2+0x80>
81134da4:	30000b26 	beq	r6,zero,81134dd4 <__gesf2+0x88>
81134da8:	000f883a 	mov	r7,zero
81134dac:	29403fcc 	andi	r5,r5,255
81134db0:	38000726 	beq	r7,zero,81134dd0 <__gesf2+0x84>
81134db4:	28000826 	beq	r5,zero,81134dd8 <__gesf2+0x8c>
81134db8:	00800044 	movi	r2,1
81134dbc:	f800283a 	ret
81134dc0:	303ff026 	beq	r6,zero,81134d84 <__reset+0xfb114d84>
81134dc4:	00bfff84 	movi	r2,-2
81134dc8:	f800283a 	ret
81134dcc:	29403fcc 	andi	r5,r5,255
81134dd0:	21400526 	beq	r4,r5,81134de8 <__gesf2+0x9c>
81134dd4:	203ff826 	beq	r4,zero,81134db8 <__reset+0xfb114db8>
81134dd8:	00bfffc4 	movi	r2,-1
81134ddc:	f800283a 	ret
81134de0:	403fe626 	beq	r8,zero,81134d7c <__reset+0xfb114d7c>
81134de4:	003ff706 	br	81134dc4 <__reset+0xfb114dc4>
81134de8:	18bffa16 	blt	r3,r2,81134dd4 <__reset+0xfb114dd4>
81134dec:	10c00216 	blt	r2,r3,81134df8 <__gesf2+0xac>
81134df0:	323ff836 	bltu	r6,r8,81134dd4 <__reset+0xfb114dd4>
81134df4:	4180022e 	bgeu	r8,r6,81134e00 <__gesf2+0xb4>
81134df8:	203fef1e 	bne	r4,zero,81134db8 <__reset+0xfb114db8>
81134dfc:	003ff606 	br	81134dd8 <__reset+0xfb114dd8>
81134e00:	0005883a 	mov	r2,zero
81134e04:	f800283a 	ret

81134e08 <__lesf2>:
81134e08:	2004d5fa 	srli	r2,r4,23
81134e0c:	280cd5fa 	srli	r6,r5,23
81134e10:	00c02034 	movhi	r3,128
81134e14:	18ffffc4 	addi	r3,r3,-1
81134e18:	10803fcc 	andi	r2,r2,255
81134e1c:	01c03fc4 	movi	r7,255
81134e20:	1910703a 	and	r8,r3,r4
81134e24:	31803fcc 	andi	r6,r6,255
81134e28:	1946703a 	and	r3,r3,r5
81134e2c:	2008d7fa 	srli	r4,r4,31
81134e30:	280ad7fa 	srli	r5,r5,31
81134e34:	11c01b26 	beq	r2,r7,81134ea4 <__lesf2+0x9c>
81134e38:	01c03fc4 	movi	r7,255
81134e3c:	31c01126 	beq	r6,r7,81134e84 <__lesf2+0x7c>
81134e40:	1000071e 	bne	r2,zero,81134e60 <__lesf2+0x58>
81134e44:	400f003a 	cmpeq	r7,r8,zero
81134e48:	21003fcc 	andi	r4,r4,255
81134e4c:	3000081e 	bne	r6,zero,81134e70 <__lesf2+0x68>
81134e50:	1800071e 	bne	r3,zero,81134e70 <__lesf2+0x68>
81134e54:	0005883a 	mov	r2,zero
81134e58:	40000f1e 	bne	r8,zero,81134e98 <__lesf2+0x90>
81134e5c:	f800283a 	ret
81134e60:	21003fcc 	andi	r4,r4,255
81134e64:	30000a1e 	bne	r6,zero,81134e90 <__lesf2+0x88>
81134e68:	18000b26 	beq	r3,zero,81134e98 <__lesf2+0x90>
81134e6c:	000f883a 	mov	r7,zero
81134e70:	29403fcc 	andi	r5,r5,255
81134e74:	38000726 	beq	r7,zero,81134e94 <__lesf2+0x8c>
81134e78:	28000826 	beq	r5,zero,81134e9c <__lesf2+0x94>
81134e7c:	00800044 	movi	r2,1
81134e80:	f800283a 	ret
81134e84:	183fee26 	beq	r3,zero,81134e40 <__reset+0xfb114e40>
81134e88:	00800084 	movi	r2,2
81134e8c:	f800283a 	ret
81134e90:	29403fcc 	andi	r5,r5,255
81134e94:	21400626 	beq	r4,r5,81134eb0 <__lesf2+0xa8>
81134e98:	203ff826 	beq	r4,zero,81134e7c <__reset+0xfb114e7c>
81134e9c:	00bfffc4 	movi	r2,-1
81134ea0:	f800283a 	ret
81134ea4:	403fe426 	beq	r8,zero,81134e38 <__reset+0xfb114e38>
81134ea8:	00800084 	movi	r2,2
81134eac:	f800283a 	ret
81134eb0:	30bff916 	blt	r6,r2,81134e98 <__reset+0xfb114e98>
81134eb4:	11800216 	blt	r2,r6,81134ec0 <__lesf2+0xb8>
81134eb8:	1a3ff736 	bltu	r3,r8,81134e98 <__reset+0xfb114e98>
81134ebc:	40c0022e 	bgeu	r8,r3,81134ec8 <__lesf2+0xc0>
81134ec0:	203fee1e 	bne	r4,zero,81134e7c <__reset+0xfb114e7c>
81134ec4:	003ff506 	br	81134e9c <__reset+0xfb114e9c>
81134ec8:	0005883a 	mov	r2,zero
81134ecc:	f800283a 	ret

81134ed0 <__adddf3>:
81134ed0:	02c00434 	movhi	r11,16
81134ed4:	5affffc4 	addi	r11,r11,-1
81134ed8:	2806d7fa 	srli	r3,r5,31
81134edc:	2ad4703a 	and	r10,r5,r11
81134ee0:	3ad2703a 	and	r9,r7,r11
81134ee4:	3804d53a 	srli	r2,r7,20
81134ee8:	3018d77a 	srli	r12,r6,29
81134eec:	280ad53a 	srli	r5,r5,20
81134ef0:	501490fa 	slli	r10,r10,3
81134ef4:	2010d77a 	srli	r8,r4,29
81134ef8:	481290fa 	slli	r9,r9,3
81134efc:	380ed7fa 	srli	r7,r7,31
81134f00:	defffb04 	addi	sp,sp,-20
81134f04:	de00012e 	bgeu	sp,et,81134f0c <__adddf3+0x3c>
81134f08:	003b68fa 	trap	3
81134f0c:	dc800215 	stw	r18,8(sp)
81134f10:	dc400115 	stw	r17,4(sp)
81134f14:	dc000015 	stw	r16,0(sp)
81134f18:	dfc00415 	stw	ra,16(sp)
81134f1c:	dcc00315 	stw	r19,12(sp)
81134f20:	1c803fcc 	andi	r18,r3,255
81134f24:	2c01ffcc 	andi	r16,r5,2047
81134f28:	5210b03a 	or	r8,r10,r8
81134f2c:	202290fa 	slli	r17,r4,3
81134f30:	1081ffcc 	andi	r2,r2,2047
81134f34:	4b12b03a 	or	r9,r9,r12
81134f38:	300c90fa 	slli	r6,r6,3
81134f3c:	91c07526 	beq	r18,r7,81135114 <__adddf3+0x244>
81134f40:	8087c83a 	sub	r3,r16,r2
81134f44:	00c0ab0e 	bge	zero,r3,811351f4 <__adddf3+0x324>
81134f48:	10002a1e 	bne	r2,zero,81134ff4 <__adddf3+0x124>
81134f4c:	4984b03a 	or	r2,r9,r6
81134f50:	1000961e 	bne	r2,zero,811351ac <__adddf3+0x2dc>
81134f54:	888001cc 	andi	r2,r17,7
81134f58:	10000726 	beq	r2,zero,81134f78 <__adddf3+0xa8>
81134f5c:	888003cc 	andi	r2,r17,15
81134f60:	00c00104 	movi	r3,4
81134f64:	10c00426 	beq	r2,r3,81134f78 <__adddf3+0xa8>
81134f68:	88c7883a 	add	r3,r17,r3
81134f6c:	1c63803a 	cmpltu	r17,r3,r17
81134f70:	4451883a 	add	r8,r8,r17
81134f74:	1823883a 	mov	r17,r3
81134f78:	4080202c 	andhi	r2,r8,128
81134f7c:	10005926 	beq	r2,zero,811350e4 <__adddf3+0x214>
81134f80:	84000044 	addi	r16,r16,1
81134f84:	0081ffc4 	movi	r2,2047
81134f88:	8080ba26 	beq	r16,r2,81135274 <__adddf3+0x3a4>
81134f8c:	00bfe034 	movhi	r2,65408
81134f90:	10bfffc4 	addi	r2,r2,-1
81134f94:	4090703a 	and	r8,r8,r2
81134f98:	4004977a 	slli	r2,r8,29
81134f9c:	4010927a 	slli	r8,r8,9
81134fa0:	8822d0fa 	srli	r17,r17,3
81134fa4:	8401ffcc 	andi	r16,r16,2047
81134fa8:	4010d33a 	srli	r8,r8,12
81134fac:	9007883a 	mov	r3,r18
81134fb0:	1444b03a 	or	r2,r2,r17
81134fb4:	8401ffcc 	andi	r16,r16,2047
81134fb8:	8020953a 	slli	r16,r16,20
81134fbc:	18c03fcc 	andi	r3,r3,255
81134fc0:	01000434 	movhi	r4,16
81134fc4:	213fffc4 	addi	r4,r4,-1
81134fc8:	180697fa 	slli	r3,r3,31
81134fcc:	4110703a 	and	r8,r8,r4
81134fd0:	4410b03a 	or	r8,r8,r16
81134fd4:	40c6b03a 	or	r3,r8,r3
81134fd8:	dfc00417 	ldw	ra,16(sp)
81134fdc:	dcc00317 	ldw	r19,12(sp)
81134fe0:	dc800217 	ldw	r18,8(sp)
81134fe4:	dc400117 	ldw	r17,4(sp)
81134fe8:	dc000017 	ldw	r16,0(sp)
81134fec:	dec00504 	addi	sp,sp,20
81134ff0:	f800283a 	ret
81134ff4:	0081ffc4 	movi	r2,2047
81134ff8:	80bfd626 	beq	r16,r2,81134f54 <__reset+0xfb114f54>
81134ffc:	4a402034 	orhi	r9,r9,128
81135000:	00800e04 	movi	r2,56
81135004:	10c09f16 	blt	r2,r3,81135284 <__adddf3+0x3b4>
81135008:	008007c4 	movi	r2,31
8113500c:	10c0c216 	blt	r2,r3,81135318 <__adddf3+0x448>
81135010:	00800804 	movi	r2,32
81135014:	10c5c83a 	sub	r2,r2,r3
81135018:	488a983a 	sll	r5,r9,r2
8113501c:	30c8d83a 	srl	r4,r6,r3
81135020:	3084983a 	sll	r2,r6,r2
81135024:	48c6d83a 	srl	r3,r9,r3
81135028:	290cb03a 	or	r6,r5,r4
8113502c:	1004c03a 	cmpne	r2,r2,zero
81135030:	308cb03a 	or	r6,r6,r2
81135034:	898dc83a 	sub	r6,r17,r6
81135038:	89a3803a 	cmpltu	r17,r17,r6
8113503c:	40d1c83a 	sub	r8,r8,r3
81135040:	4451c83a 	sub	r8,r8,r17
81135044:	3023883a 	mov	r17,r6
81135048:	4080202c 	andhi	r2,r8,128
8113504c:	10002326 	beq	r2,zero,811350dc <__adddf3+0x20c>
81135050:	04c02034 	movhi	r19,128
81135054:	9cffffc4 	addi	r19,r19,-1
81135058:	44e6703a 	and	r19,r8,r19
8113505c:	98007626 	beq	r19,zero,81135238 <__adddf3+0x368>
81135060:	9809883a 	mov	r4,r19
81135064:	11214080 	call	81121408 <__clzsi2>
81135068:	10fffe04 	addi	r3,r2,-8
8113506c:	010007c4 	movi	r4,31
81135070:	20c07716 	blt	r4,r3,81135250 <__adddf3+0x380>
81135074:	00800804 	movi	r2,32
81135078:	10c5c83a 	sub	r2,r2,r3
8113507c:	8884d83a 	srl	r2,r17,r2
81135080:	98d0983a 	sll	r8,r19,r3
81135084:	88e2983a 	sll	r17,r17,r3
81135088:	1204b03a 	or	r2,r2,r8
8113508c:	1c007416 	blt	r3,r16,81135260 <__adddf3+0x390>
81135090:	1c21c83a 	sub	r16,r3,r16
81135094:	82000044 	addi	r8,r16,1
81135098:	00c007c4 	movi	r3,31
8113509c:	1a009116 	blt	r3,r8,811352e4 <__adddf3+0x414>
811350a0:	00c00804 	movi	r3,32
811350a4:	1a07c83a 	sub	r3,r3,r8
811350a8:	8a08d83a 	srl	r4,r17,r8
811350ac:	88e2983a 	sll	r17,r17,r3
811350b0:	10c6983a 	sll	r3,r2,r3
811350b4:	1210d83a 	srl	r8,r2,r8
811350b8:	8804c03a 	cmpne	r2,r17,zero
811350bc:	1906b03a 	or	r3,r3,r4
811350c0:	18a2b03a 	or	r17,r3,r2
811350c4:	0021883a 	mov	r16,zero
811350c8:	003fa206 	br	81134f54 <__reset+0xfb114f54>
811350cc:	1890b03a 	or	r8,r3,r2
811350d0:	40017d26 	beq	r8,zero,811356c8 <__adddf3+0x7f8>
811350d4:	1011883a 	mov	r8,r2
811350d8:	1823883a 	mov	r17,r3
811350dc:	888001cc 	andi	r2,r17,7
811350e0:	103f9e1e 	bne	r2,zero,81134f5c <__reset+0xfb114f5c>
811350e4:	4004977a 	slli	r2,r8,29
811350e8:	8822d0fa 	srli	r17,r17,3
811350ec:	4010d0fa 	srli	r8,r8,3
811350f0:	9007883a 	mov	r3,r18
811350f4:	1444b03a 	or	r2,r2,r17
811350f8:	0101ffc4 	movi	r4,2047
811350fc:	81002426 	beq	r16,r4,81135190 <__adddf3+0x2c0>
81135100:	8120703a 	and	r16,r16,r4
81135104:	01000434 	movhi	r4,16
81135108:	213fffc4 	addi	r4,r4,-1
8113510c:	4110703a 	and	r8,r8,r4
81135110:	003fa806 	br	81134fb4 <__reset+0xfb114fb4>
81135114:	8089c83a 	sub	r4,r16,r2
81135118:	01005e0e 	bge	zero,r4,81135294 <__adddf3+0x3c4>
8113511c:	10002b26 	beq	r2,zero,811351cc <__adddf3+0x2fc>
81135120:	0081ffc4 	movi	r2,2047
81135124:	80bf8b26 	beq	r16,r2,81134f54 <__reset+0xfb114f54>
81135128:	4a402034 	orhi	r9,r9,128
8113512c:	00800e04 	movi	r2,56
81135130:	1100a40e 	bge	r2,r4,811353c4 <__adddf3+0x4f4>
81135134:	498cb03a 	or	r6,r9,r6
81135138:	300ac03a 	cmpne	r5,r6,zero
8113513c:	0013883a 	mov	r9,zero
81135140:	2c4b883a 	add	r5,r5,r17
81135144:	2c63803a 	cmpltu	r17,r5,r17
81135148:	4a11883a 	add	r8,r9,r8
8113514c:	8a11883a 	add	r8,r17,r8
81135150:	2823883a 	mov	r17,r5
81135154:	4080202c 	andhi	r2,r8,128
81135158:	103fe026 	beq	r2,zero,811350dc <__reset+0xfb1150dc>
8113515c:	84000044 	addi	r16,r16,1
81135160:	0081ffc4 	movi	r2,2047
81135164:	8080d226 	beq	r16,r2,811354b0 <__adddf3+0x5e0>
81135168:	00bfe034 	movhi	r2,65408
8113516c:	10bfffc4 	addi	r2,r2,-1
81135170:	4090703a 	and	r8,r8,r2
81135174:	880ad07a 	srli	r5,r17,1
81135178:	400897fa 	slli	r4,r8,31
8113517c:	88c0004c 	andi	r3,r17,1
81135180:	28e2b03a 	or	r17,r5,r3
81135184:	4010d07a 	srli	r8,r8,1
81135188:	2462b03a 	or	r17,r4,r17
8113518c:	003f7106 	br	81134f54 <__reset+0xfb114f54>
81135190:	4088b03a 	or	r4,r8,r2
81135194:	20014526 	beq	r4,zero,811356ac <__adddf3+0x7dc>
81135198:	01000434 	movhi	r4,16
8113519c:	42000234 	orhi	r8,r8,8
811351a0:	213fffc4 	addi	r4,r4,-1
811351a4:	4110703a 	and	r8,r8,r4
811351a8:	003f8206 	br	81134fb4 <__reset+0xfb114fb4>
811351ac:	18ffffc4 	addi	r3,r3,-1
811351b0:	1800491e 	bne	r3,zero,811352d8 <__adddf3+0x408>
811351b4:	898bc83a 	sub	r5,r17,r6
811351b8:	8963803a 	cmpltu	r17,r17,r5
811351bc:	4251c83a 	sub	r8,r8,r9
811351c0:	4451c83a 	sub	r8,r8,r17
811351c4:	2823883a 	mov	r17,r5
811351c8:	003f9f06 	br	81135048 <__reset+0xfb115048>
811351cc:	4984b03a 	or	r2,r9,r6
811351d0:	103f6026 	beq	r2,zero,81134f54 <__reset+0xfb114f54>
811351d4:	213fffc4 	addi	r4,r4,-1
811351d8:	2000931e 	bne	r4,zero,81135428 <__adddf3+0x558>
811351dc:	898d883a 	add	r6,r17,r6
811351e0:	3463803a 	cmpltu	r17,r6,r17
811351e4:	4251883a 	add	r8,r8,r9
811351e8:	8a11883a 	add	r8,r17,r8
811351ec:	3023883a 	mov	r17,r6
811351f0:	003fd806 	br	81135154 <__reset+0xfb115154>
811351f4:	1800541e 	bne	r3,zero,81135348 <__adddf3+0x478>
811351f8:	80800044 	addi	r2,r16,1
811351fc:	1081ffcc 	andi	r2,r2,2047
81135200:	00c00044 	movi	r3,1
81135204:	1880a00e 	bge	r3,r2,81135488 <__adddf3+0x5b8>
81135208:	8989c83a 	sub	r4,r17,r6
8113520c:	8905803a 	cmpltu	r2,r17,r4
81135210:	4267c83a 	sub	r19,r8,r9
81135214:	98a7c83a 	sub	r19,r19,r2
81135218:	9880202c 	andhi	r2,r19,128
8113521c:	10006326 	beq	r2,zero,811353ac <__adddf3+0x4dc>
81135220:	3463c83a 	sub	r17,r6,r17
81135224:	4a07c83a 	sub	r3,r9,r8
81135228:	344d803a 	cmpltu	r6,r6,r17
8113522c:	19a7c83a 	sub	r19,r3,r6
81135230:	3825883a 	mov	r18,r7
81135234:	983f8a1e 	bne	r19,zero,81135060 <__reset+0xfb115060>
81135238:	8809883a 	mov	r4,r17
8113523c:	11214080 	call	81121408 <__clzsi2>
81135240:	10800804 	addi	r2,r2,32
81135244:	10fffe04 	addi	r3,r2,-8
81135248:	010007c4 	movi	r4,31
8113524c:	20ff890e 	bge	r4,r3,81135074 <__reset+0xfb115074>
81135250:	10bff604 	addi	r2,r2,-40
81135254:	8884983a 	sll	r2,r17,r2
81135258:	0023883a 	mov	r17,zero
8113525c:	1c3f8c0e 	bge	r3,r16,81135090 <__reset+0xfb115090>
81135260:	023fe034 	movhi	r8,65408
81135264:	423fffc4 	addi	r8,r8,-1
81135268:	80e1c83a 	sub	r16,r16,r3
8113526c:	1210703a 	and	r8,r2,r8
81135270:	003f3806 	br	81134f54 <__reset+0xfb114f54>
81135274:	9007883a 	mov	r3,r18
81135278:	0011883a 	mov	r8,zero
8113527c:	0005883a 	mov	r2,zero
81135280:	003f4c06 	br	81134fb4 <__reset+0xfb114fb4>
81135284:	498cb03a 	or	r6,r9,r6
81135288:	300cc03a 	cmpne	r6,r6,zero
8113528c:	0007883a 	mov	r3,zero
81135290:	003f6806 	br	81135034 <__reset+0xfb115034>
81135294:	20009c1e 	bne	r4,zero,81135508 <__adddf3+0x638>
81135298:	80800044 	addi	r2,r16,1
8113529c:	1141ffcc 	andi	r5,r2,2047
811352a0:	01000044 	movi	r4,1
811352a4:	2140670e 	bge	r4,r5,81135444 <__adddf3+0x574>
811352a8:	0101ffc4 	movi	r4,2047
811352ac:	11007f26 	beq	r2,r4,811354ac <__adddf3+0x5dc>
811352b0:	898d883a 	add	r6,r17,r6
811352b4:	4247883a 	add	r3,r8,r9
811352b8:	3451803a 	cmpltu	r8,r6,r17
811352bc:	40d1883a 	add	r8,r8,r3
811352c0:	402297fa 	slli	r17,r8,31
811352c4:	300cd07a 	srli	r6,r6,1
811352c8:	4010d07a 	srli	r8,r8,1
811352cc:	1021883a 	mov	r16,r2
811352d0:	89a2b03a 	or	r17,r17,r6
811352d4:	003f1f06 	br	81134f54 <__reset+0xfb114f54>
811352d8:	0081ffc4 	movi	r2,2047
811352dc:	80bf481e 	bne	r16,r2,81135000 <__reset+0xfb115000>
811352e0:	003f1c06 	br	81134f54 <__reset+0xfb114f54>
811352e4:	843ff844 	addi	r16,r16,-31
811352e8:	01000804 	movi	r4,32
811352ec:	1406d83a 	srl	r3,r2,r16
811352f0:	41005026 	beq	r8,r4,81135434 <__adddf3+0x564>
811352f4:	01001004 	movi	r4,64
811352f8:	2211c83a 	sub	r8,r4,r8
811352fc:	1204983a 	sll	r2,r2,r8
81135300:	88a2b03a 	or	r17,r17,r2
81135304:	8822c03a 	cmpne	r17,r17,zero
81135308:	1c62b03a 	or	r17,r3,r17
8113530c:	0011883a 	mov	r8,zero
81135310:	0021883a 	mov	r16,zero
81135314:	003f7106 	br	811350dc <__reset+0xfb1150dc>
81135318:	193ff804 	addi	r4,r3,-32
8113531c:	00800804 	movi	r2,32
81135320:	4908d83a 	srl	r4,r9,r4
81135324:	18804526 	beq	r3,r2,8113543c <__adddf3+0x56c>
81135328:	00801004 	movi	r2,64
8113532c:	10c5c83a 	sub	r2,r2,r3
81135330:	4886983a 	sll	r3,r9,r2
81135334:	198cb03a 	or	r6,r3,r6
81135338:	300cc03a 	cmpne	r6,r6,zero
8113533c:	218cb03a 	or	r6,r4,r6
81135340:	0007883a 	mov	r3,zero
81135344:	003f3b06 	br	81135034 <__reset+0xfb115034>
81135348:	80002a26 	beq	r16,zero,811353f4 <__adddf3+0x524>
8113534c:	0101ffc4 	movi	r4,2047
81135350:	11006826 	beq	r2,r4,811354f4 <__adddf3+0x624>
81135354:	00c7c83a 	sub	r3,zero,r3
81135358:	42002034 	orhi	r8,r8,128
8113535c:	01000e04 	movi	r4,56
81135360:	20c07c16 	blt	r4,r3,81135554 <__adddf3+0x684>
81135364:	010007c4 	movi	r4,31
81135368:	20c0da16 	blt	r4,r3,811356d4 <__adddf3+0x804>
8113536c:	01000804 	movi	r4,32
81135370:	20c9c83a 	sub	r4,r4,r3
81135374:	4114983a 	sll	r10,r8,r4
81135378:	88cad83a 	srl	r5,r17,r3
8113537c:	8908983a 	sll	r4,r17,r4
81135380:	40c6d83a 	srl	r3,r8,r3
81135384:	5162b03a 	or	r17,r10,r5
81135388:	2008c03a 	cmpne	r4,r4,zero
8113538c:	8922b03a 	or	r17,r17,r4
81135390:	3463c83a 	sub	r17,r6,r17
81135394:	48c7c83a 	sub	r3,r9,r3
81135398:	344d803a 	cmpltu	r6,r6,r17
8113539c:	1991c83a 	sub	r8,r3,r6
811353a0:	1021883a 	mov	r16,r2
811353a4:	3825883a 	mov	r18,r7
811353a8:	003f2706 	br	81135048 <__reset+0xfb115048>
811353ac:	24d0b03a 	or	r8,r4,r19
811353b0:	40001b1e 	bne	r8,zero,81135420 <__adddf3+0x550>
811353b4:	0005883a 	mov	r2,zero
811353b8:	0007883a 	mov	r3,zero
811353bc:	0021883a 	mov	r16,zero
811353c0:	003f4d06 	br	811350f8 <__reset+0xfb1150f8>
811353c4:	008007c4 	movi	r2,31
811353c8:	11003c16 	blt	r2,r4,811354bc <__adddf3+0x5ec>
811353cc:	00800804 	movi	r2,32
811353d0:	1105c83a 	sub	r2,r2,r4
811353d4:	488e983a 	sll	r7,r9,r2
811353d8:	310ad83a 	srl	r5,r6,r4
811353dc:	3084983a 	sll	r2,r6,r2
811353e0:	4912d83a 	srl	r9,r9,r4
811353e4:	394ab03a 	or	r5,r7,r5
811353e8:	1004c03a 	cmpne	r2,r2,zero
811353ec:	288ab03a 	or	r5,r5,r2
811353f0:	003f5306 	br	81135140 <__reset+0xfb115140>
811353f4:	4448b03a 	or	r4,r8,r17
811353f8:	20003e26 	beq	r4,zero,811354f4 <__adddf3+0x624>
811353fc:	00c6303a 	nor	r3,zero,r3
81135400:	18003a1e 	bne	r3,zero,811354ec <__adddf3+0x61c>
81135404:	3463c83a 	sub	r17,r6,r17
81135408:	4a07c83a 	sub	r3,r9,r8
8113540c:	344d803a 	cmpltu	r6,r6,r17
81135410:	1991c83a 	sub	r8,r3,r6
81135414:	1021883a 	mov	r16,r2
81135418:	3825883a 	mov	r18,r7
8113541c:	003f0a06 	br	81135048 <__reset+0xfb115048>
81135420:	2023883a 	mov	r17,r4
81135424:	003f0d06 	br	8113505c <__reset+0xfb11505c>
81135428:	0081ffc4 	movi	r2,2047
8113542c:	80bf3f1e 	bne	r16,r2,8113512c <__reset+0xfb11512c>
81135430:	003ec806 	br	81134f54 <__reset+0xfb114f54>
81135434:	0005883a 	mov	r2,zero
81135438:	003fb106 	br	81135300 <__reset+0xfb115300>
8113543c:	0007883a 	mov	r3,zero
81135440:	003fbc06 	br	81135334 <__reset+0xfb115334>
81135444:	4444b03a 	or	r2,r8,r17
81135448:	8000871e 	bne	r16,zero,81135668 <__adddf3+0x798>
8113544c:	1000ba26 	beq	r2,zero,81135738 <__adddf3+0x868>
81135450:	4984b03a 	or	r2,r9,r6
81135454:	103ebf26 	beq	r2,zero,81134f54 <__reset+0xfb114f54>
81135458:	8985883a 	add	r2,r17,r6
8113545c:	4247883a 	add	r3,r8,r9
81135460:	1451803a 	cmpltu	r8,r2,r17
81135464:	40d1883a 	add	r8,r8,r3
81135468:	40c0202c 	andhi	r3,r8,128
8113546c:	1023883a 	mov	r17,r2
81135470:	183f1a26 	beq	r3,zero,811350dc <__reset+0xfb1150dc>
81135474:	00bfe034 	movhi	r2,65408
81135478:	10bfffc4 	addi	r2,r2,-1
8113547c:	2021883a 	mov	r16,r4
81135480:	4090703a 	and	r8,r8,r2
81135484:	003eb306 	br	81134f54 <__reset+0xfb114f54>
81135488:	4444b03a 	or	r2,r8,r17
8113548c:	8000291e 	bne	r16,zero,81135534 <__adddf3+0x664>
81135490:	10004b1e 	bne	r2,zero,811355c0 <__adddf3+0x6f0>
81135494:	4990b03a 	or	r8,r9,r6
81135498:	40008b26 	beq	r8,zero,811356c8 <__adddf3+0x7f8>
8113549c:	4811883a 	mov	r8,r9
811354a0:	3023883a 	mov	r17,r6
811354a4:	3825883a 	mov	r18,r7
811354a8:	003eaa06 	br	81134f54 <__reset+0xfb114f54>
811354ac:	1021883a 	mov	r16,r2
811354b0:	0011883a 	mov	r8,zero
811354b4:	0005883a 	mov	r2,zero
811354b8:	003f0f06 	br	811350f8 <__reset+0xfb1150f8>
811354bc:	217ff804 	addi	r5,r4,-32
811354c0:	00800804 	movi	r2,32
811354c4:	494ad83a 	srl	r5,r9,r5
811354c8:	20807d26 	beq	r4,r2,811356c0 <__adddf3+0x7f0>
811354cc:	00801004 	movi	r2,64
811354d0:	1109c83a 	sub	r4,r2,r4
811354d4:	4912983a 	sll	r9,r9,r4
811354d8:	498cb03a 	or	r6,r9,r6
811354dc:	300cc03a 	cmpne	r6,r6,zero
811354e0:	298ab03a 	or	r5,r5,r6
811354e4:	0013883a 	mov	r9,zero
811354e8:	003f1506 	br	81135140 <__reset+0xfb115140>
811354ec:	0101ffc4 	movi	r4,2047
811354f0:	113f9a1e 	bne	r2,r4,8113535c <__reset+0xfb11535c>
811354f4:	4811883a 	mov	r8,r9
811354f8:	3023883a 	mov	r17,r6
811354fc:	1021883a 	mov	r16,r2
81135500:	3825883a 	mov	r18,r7
81135504:	003e9306 	br	81134f54 <__reset+0xfb114f54>
81135508:	8000161e 	bne	r16,zero,81135564 <__adddf3+0x694>
8113550c:	444ab03a 	or	r5,r8,r17
81135510:	28005126 	beq	r5,zero,81135658 <__adddf3+0x788>
81135514:	0108303a 	nor	r4,zero,r4
81135518:	20004d1e 	bne	r4,zero,81135650 <__adddf3+0x780>
8113551c:	89a3883a 	add	r17,r17,r6
81135520:	4253883a 	add	r9,r8,r9
81135524:	898d803a 	cmpltu	r6,r17,r6
81135528:	3251883a 	add	r8,r6,r9
8113552c:	1021883a 	mov	r16,r2
81135530:	003f0806 	br	81135154 <__reset+0xfb115154>
81135534:	1000301e 	bne	r2,zero,811355f8 <__adddf3+0x728>
81135538:	4984b03a 	or	r2,r9,r6
8113553c:	10007126 	beq	r2,zero,81135704 <__adddf3+0x834>
81135540:	4811883a 	mov	r8,r9
81135544:	3023883a 	mov	r17,r6
81135548:	3825883a 	mov	r18,r7
8113554c:	0401ffc4 	movi	r16,2047
81135550:	003e8006 	br	81134f54 <__reset+0xfb114f54>
81135554:	4462b03a 	or	r17,r8,r17
81135558:	8822c03a 	cmpne	r17,r17,zero
8113555c:	0007883a 	mov	r3,zero
81135560:	003f8b06 	br	81135390 <__reset+0xfb115390>
81135564:	0141ffc4 	movi	r5,2047
81135568:	11403b26 	beq	r2,r5,81135658 <__adddf3+0x788>
8113556c:	0109c83a 	sub	r4,zero,r4
81135570:	42002034 	orhi	r8,r8,128
81135574:	01400e04 	movi	r5,56
81135578:	29006716 	blt	r5,r4,81135718 <__adddf3+0x848>
8113557c:	014007c4 	movi	r5,31
81135580:	29007016 	blt	r5,r4,81135744 <__adddf3+0x874>
81135584:	01400804 	movi	r5,32
81135588:	290bc83a 	sub	r5,r5,r4
8113558c:	4154983a 	sll	r10,r8,r5
81135590:	890ed83a 	srl	r7,r17,r4
81135594:	894a983a 	sll	r5,r17,r5
81135598:	4108d83a 	srl	r4,r8,r4
8113559c:	51e2b03a 	or	r17,r10,r7
811355a0:	280ac03a 	cmpne	r5,r5,zero
811355a4:	8962b03a 	or	r17,r17,r5
811355a8:	89a3883a 	add	r17,r17,r6
811355ac:	2253883a 	add	r9,r4,r9
811355b0:	898d803a 	cmpltu	r6,r17,r6
811355b4:	3251883a 	add	r8,r6,r9
811355b8:	1021883a 	mov	r16,r2
811355bc:	003ee506 	br	81135154 <__reset+0xfb115154>
811355c0:	4984b03a 	or	r2,r9,r6
811355c4:	103e6326 	beq	r2,zero,81134f54 <__reset+0xfb114f54>
811355c8:	8987c83a 	sub	r3,r17,r6
811355cc:	88c9803a 	cmpltu	r4,r17,r3
811355d0:	4245c83a 	sub	r2,r8,r9
811355d4:	1105c83a 	sub	r2,r2,r4
811355d8:	1100202c 	andhi	r4,r2,128
811355dc:	203ebb26 	beq	r4,zero,811350cc <__reset+0xfb1150cc>
811355e0:	3463c83a 	sub	r17,r6,r17
811355e4:	4a07c83a 	sub	r3,r9,r8
811355e8:	344d803a 	cmpltu	r6,r6,r17
811355ec:	1991c83a 	sub	r8,r3,r6
811355f0:	3825883a 	mov	r18,r7
811355f4:	003e5706 	br	81134f54 <__reset+0xfb114f54>
811355f8:	4984b03a 	or	r2,r9,r6
811355fc:	10002e26 	beq	r2,zero,811356b8 <__adddf3+0x7e8>
81135600:	4004d0fa 	srli	r2,r8,3
81135604:	8822d0fa 	srli	r17,r17,3
81135608:	4010977a 	slli	r8,r8,29
8113560c:	10c0022c 	andhi	r3,r2,8
81135610:	4462b03a 	or	r17,r8,r17
81135614:	18000826 	beq	r3,zero,81135638 <__adddf3+0x768>
81135618:	4808d0fa 	srli	r4,r9,3
8113561c:	20c0022c 	andhi	r3,r4,8
81135620:	1800051e 	bne	r3,zero,81135638 <__adddf3+0x768>
81135624:	300cd0fa 	srli	r6,r6,3
81135628:	4806977a 	slli	r3,r9,29
8113562c:	2005883a 	mov	r2,r4
81135630:	3825883a 	mov	r18,r7
81135634:	19a2b03a 	or	r17,r3,r6
81135638:	8810d77a 	srli	r8,r17,29
8113563c:	100490fa 	slli	r2,r2,3
81135640:	882290fa 	slli	r17,r17,3
81135644:	0401ffc4 	movi	r16,2047
81135648:	4090b03a 	or	r8,r8,r2
8113564c:	003e4106 	br	81134f54 <__reset+0xfb114f54>
81135650:	0141ffc4 	movi	r5,2047
81135654:	117fc71e 	bne	r2,r5,81135574 <__reset+0xfb115574>
81135658:	4811883a 	mov	r8,r9
8113565c:	3023883a 	mov	r17,r6
81135660:	1021883a 	mov	r16,r2
81135664:	003e3b06 	br	81134f54 <__reset+0xfb114f54>
81135668:	10002f26 	beq	r2,zero,81135728 <__adddf3+0x858>
8113566c:	4984b03a 	or	r2,r9,r6
81135670:	10001126 	beq	r2,zero,811356b8 <__adddf3+0x7e8>
81135674:	4004d0fa 	srli	r2,r8,3
81135678:	8822d0fa 	srli	r17,r17,3
8113567c:	4010977a 	slli	r8,r8,29
81135680:	10c0022c 	andhi	r3,r2,8
81135684:	4462b03a 	or	r17,r8,r17
81135688:	183feb26 	beq	r3,zero,81135638 <__reset+0xfb115638>
8113568c:	4808d0fa 	srli	r4,r9,3
81135690:	20c0022c 	andhi	r3,r4,8
81135694:	183fe81e 	bne	r3,zero,81135638 <__reset+0xfb115638>
81135698:	300cd0fa 	srli	r6,r6,3
8113569c:	4806977a 	slli	r3,r9,29
811356a0:	2005883a 	mov	r2,r4
811356a4:	19a2b03a 	or	r17,r3,r6
811356a8:	003fe306 	br	81135638 <__reset+0xfb115638>
811356ac:	0011883a 	mov	r8,zero
811356b0:	0005883a 	mov	r2,zero
811356b4:	003e3f06 	br	81134fb4 <__reset+0xfb114fb4>
811356b8:	0401ffc4 	movi	r16,2047
811356bc:	003e2506 	br	81134f54 <__reset+0xfb114f54>
811356c0:	0013883a 	mov	r9,zero
811356c4:	003f8406 	br	811354d8 <__reset+0xfb1154d8>
811356c8:	0005883a 	mov	r2,zero
811356cc:	0007883a 	mov	r3,zero
811356d0:	003e8906 	br	811350f8 <__reset+0xfb1150f8>
811356d4:	197ff804 	addi	r5,r3,-32
811356d8:	01000804 	movi	r4,32
811356dc:	414ad83a 	srl	r5,r8,r5
811356e0:	19002426 	beq	r3,r4,81135774 <__adddf3+0x8a4>
811356e4:	01001004 	movi	r4,64
811356e8:	20c7c83a 	sub	r3,r4,r3
811356ec:	40c6983a 	sll	r3,r8,r3
811356f0:	1c46b03a 	or	r3,r3,r17
811356f4:	1806c03a 	cmpne	r3,r3,zero
811356f8:	28e2b03a 	or	r17,r5,r3
811356fc:	0007883a 	mov	r3,zero
81135700:	003f2306 	br	81135390 <__reset+0xfb115390>
81135704:	0007883a 	mov	r3,zero
81135708:	5811883a 	mov	r8,r11
8113570c:	00bfffc4 	movi	r2,-1
81135710:	0401ffc4 	movi	r16,2047
81135714:	003e7806 	br	811350f8 <__reset+0xfb1150f8>
81135718:	4462b03a 	or	r17,r8,r17
8113571c:	8822c03a 	cmpne	r17,r17,zero
81135720:	0009883a 	mov	r4,zero
81135724:	003fa006 	br	811355a8 <__reset+0xfb1155a8>
81135728:	4811883a 	mov	r8,r9
8113572c:	3023883a 	mov	r17,r6
81135730:	0401ffc4 	movi	r16,2047
81135734:	003e0706 	br	81134f54 <__reset+0xfb114f54>
81135738:	4811883a 	mov	r8,r9
8113573c:	3023883a 	mov	r17,r6
81135740:	003e0406 	br	81134f54 <__reset+0xfb114f54>
81135744:	21fff804 	addi	r7,r4,-32
81135748:	01400804 	movi	r5,32
8113574c:	41ced83a 	srl	r7,r8,r7
81135750:	21400a26 	beq	r4,r5,8113577c <__adddf3+0x8ac>
81135754:	01401004 	movi	r5,64
81135758:	2909c83a 	sub	r4,r5,r4
8113575c:	4108983a 	sll	r4,r8,r4
81135760:	2448b03a 	or	r4,r4,r17
81135764:	2008c03a 	cmpne	r4,r4,zero
81135768:	3922b03a 	or	r17,r7,r4
8113576c:	0009883a 	mov	r4,zero
81135770:	003f8d06 	br	811355a8 <__reset+0xfb1155a8>
81135774:	0007883a 	mov	r3,zero
81135778:	003fdd06 	br	811356f0 <__reset+0xfb1156f0>
8113577c:	0009883a 	mov	r4,zero
81135780:	003ff706 	br	81135760 <__reset+0xfb115760>

81135784 <__divdf3>:
81135784:	defff204 	addi	sp,sp,-56
81135788:	de00012e 	bgeu	sp,et,81135790 <__divdf3+0xc>
8113578c:	003b68fa 	trap	3
81135790:	dd400915 	stw	r21,36(sp)
81135794:	282ad53a 	srli	r21,r5,20
81135798:	dd000815 	stw	r20,32(sp)
8113579c:	2828d7fa 	srli	r20,r5,31
811357a0:	dc000415 	stw	r16,16(sp)
811357a4:	04000434 	movhi	r16,16
811357a8:	df000c15 	stw	fp,48(sp)
811357ac:	843fffc4 	addi	r16,r16,-1
811357b0:	dfc00d15 	stw	ra,52(sp)
811357b4:	ddc00b15 	stw	r23,44(sp)
811357b8:	dd800a15 	stw	r22,40(sp)
811357bc:	dcc00715 	stw	r19,28(sp)
811357c0:	dc800615 	stw	r18,24(sp)
811357c4:	dc400515 	stw	r17,20(sp)
811357c8:	ad41ffcc 	andi	r21,r21,2047
811357cc:	2c20703a 	and	r16,r5,r16
811357d0:	a7003fcc 	andi	fp,r20,255
811357d4:	a8006126 	beq	r21,zero,8113595c <__divdf3+0x1d8>
811357d8:	0081ffc4 	movi	r2,2047
811357dc:	2025883a 	mov	r18,r4
811357e0:	a8803726 	beq	r21,r2,811358c0 <__divdf3+0x13c>
811357e4:	80800434 	orhi	r2,r16,16
811357e8:	100490fa 	slli	r2,r2,3
811357ec:	2020d77a 	srli	r16,r4,29
811357f0:	202490fa 	slli	r18,r4,3
811357f4:	ad7f0044 	addi	r21,r21,-1023
811357f8:	80a0b03a 	or	r16,r16,r2
811357fc:	0027883a 	mov	r19,zero
81135800:	0013883a 	mov	r9,zero
81135804:	3804d53a 	srli	r2,r7,20
81135808:	382cd7fa 	srli	r22,r7,31
8113580c:	04400434 	movhi	r17,16
81135810:	8c7fffc4 	addi	r17,r17,-1
81135814:	1081ffcc 	andi	r2,r2,2047
81135818:	3011883a 	mov	r8,r6
8113581c:	3c62703a 	and	r17,r7,r17
81135820:	b5c03fcc 	andi	r23,r22,255
81135824:	10006c26 	beq	r2,zero,811359d8 <__divdf3+0x254>
81135828:	00c1ffc4 	movi	r3,2047
8113582c:	10c06426 	beq	r2,r3,811359c0 <__divdf3+0x23c>
81135830:	88c00434 	orhi	r3,r17,16
81135834:	180690fa 	slli	r3,r3,3
81135838:	3022d77a 	srli	r17,r6,29
8113583c:	301090fa 	slli	r8,r6,3
81135840:	10bf0044 	addi	r2,r2,-1023
81135844:	88e2b03a 	or	r17,r17,r3
81135848:	000f883a 	mov	r7,zero
8113584c:	a58cf03a 	xor	r6,r20,r22
81135850:	3cc8b03a 	or	r4,r7,r19
81135854:	a8abc83a 	sub	r21,r21,r2
81135858:	008003c4 	movi	r2,15
8113585c:	3007883a 	mov	r3,r6
81135860:	34c03fcc 	andi	r19,r6,255
81135864:	11009036 	bltu	r2,r4,81135aa8 <__divdf3+0x324>
81135868:	200890ba 	slli	r4,r4,2
8113586c:	00a044f4 	movhi	r2,33043
81135870:	10962004 	addi	r2,r2,22656
81135874:	2089883a 	add	r4,r4,r2
81135878:	20800017 	ldw	r2,0(r4)
8113587c:	1000683a 	jmp	r2
81135880:	81135aa8 	cmpgeui	r4,r16,19818
81135884:	811358f8 	rdprs	r4,r16,19811
81135888:	81135a98 	cmpnei	r4,r16,19818
8113588c:	811358ec 	andhi	r4,r16,19811
81135890:	81135a98 	cmpnei	r4,r16,19818
81135894:	81135a6c 	andhi	r4,r16,19817
81135898:	81135a98 	cmpnei	r4,r16,19818
8113589c:	811358ec 	andhi	r4,r16,19811
811358a0:	811358f8 	rdprs	r4,r16,19811
811358a4:	811358f8 	rdprs	r4,r16,19811
811358a8:	81135a6c 	andhi	r4,r16,19817
811358ac:	811358ec 	andhi	r4,r16,19811
811358b0:	811358dc 	xori	r4,r16,19811
811358b4:	811358dc 	xori	r4,r16,19811
811358b8:	811358dc 	xori	r4,r16,19811
811358bc:	81135d8c 	andi	r4,r16,19830
811358c0:	2404b03a 	or	r2,r4,r16
811358c4:	1000661e 	bne	r2,zero,81135a60 <__divdf3+0x2dc>
811358c8:	04c00204 	movi	r19,8
811358cc:	0021883a 	mov	r16,zero
811358d0:	0025883a 	mov	r18,zero
811358d4:	02400084 	movi	r9,2
811358d8:	003fca06 	br	81135804 <__reset+0xfb115804>
811358dc:	8023883a 	mov	r17,r16
811358e0:	9011883a 	mov	r8,r18
811358e4:	e02f883a 	mov	r23,fp
811358e8:	480f883a 	mov	r7,r9
811358ec:	00800084 	movi	r2,2
811358f0:	3881311e 	bne	r7,r2,81135db8 <__divdf3+0x634>
811358f4:	b827883a 	mov	r19,r23
811358f8:	98c0004c 	andi	r3,r19,1
811358fc:	0081ffc4 	movi	r2,2047
81135900:	000b883a 	mov	r5,zero
81135904:	0025883a 	mov	r18,zero
81135908:	1004953a 	slli	r2,r2,20
8113590c:	18c03fcc 	andi	r3,r3,255
81135910:	04400434 	movhi	r17,16
81135914:	8c7fffc4 	addi	r17,r17,-1
81135918:	180697fa 	slli	r3,r3,31
8113591c:	2c4a703a 	and	r5,r5,r17
81135920:	288ab03a 	or	r5,r5,r2
81135924:	28c6b03a 	or	r3,r5,r3
81135928:	9005883a 	mov	r2,r18
8113592c:	dfc00d17 	ldw	ra,52(sp)
81135930:	df000c17 	ldw	fp,48(sp)
81135934:	ddc00b17 	ldw	r23,44(sp)
81135938:	dd800a17 	ldw	r22,40(sp)
8113593c:	dd400917 	ldw	r21,36(sp)
81135940:	dd000817 	ldw	r20,32(sp)
81135944:	dcc00717 	ldw	r19,28(sp)
81135948:	dc800617 	ldw	r18,24(sp)
8113594c:	dc400517 	ldw	r17,20(sp)
81135950:	dc000417 	ldw	r16,16(sp)
81135954:	dec00e04 	addi	sp,sp,56
81135958:	f800283a 	ret
8113595c:	2404b03a 	or	r2,r4,r16
81135960:	2027883a 	mov	r19,r4
81135964:	10003926 	beq	r2,zero,81135a4c <__divdf3+0x2c8>
81135968:	80012e26 	beq	r16,zero,81135e24 <__divdf3+0x6a0>
8113596c:	8009883a 	mov	r4,r16
81135970:	d9800315 	stw	r6,12(sp)
81135974:	d9c00215 	stw	r7,8(sp)
81135978:	11214080 	call	81121408 <__clzsi2>
8113597c:	d9800317 	ldw	r6,12(sp)
81135980:	d9c00217 	ldw	r7,8(sp)
81135984:	113ffd44 	addi	r4,r2,-11
81135988:	00c00704 	movi	r3,28
8113598c:	19012116 	blt	r3,r4,81135e14 <__divdf3+0x690>
81135990:	00c00744 	movi	r3,29
81135994:	147ffe04 	addi	r17,r2,-8
81135998:	1907c83a 	sub	r3,r3,r4
8113599c:	8460983a 	sll	r16,r16,r17
811359a0:	98c6d83a 	srl	r3,r19,r3
811359a4:	9c64983a 	sll	r18,r19,r17
811359a8:	1c20b03a 	or	r16,r3,r16
811359ac:	1080fcc4 	addi	r2,r2,1011
811359b0:	00abc83a 	sub	r21,zero,r2
811359b4:	0027883a 	mov	r19,zero
811359b8:	0013883a 	mov	r9,zero
811359bc:	003f9106 	br	81135804 <__reset+0xfb115804>
811359c0:	3446b03a 	or	r3,r6,r17
811359c4:	18001f1e 	bne	r3,zero,81135a44 <__divdf3+0x2c0>
811359c8:	0023883a 	mov	r17,zero
811359cc:	0011883a 	mov	r8,zero
811359d0:	01c00084 	movi	r7,2
811359d4:	003f9d06 	br	8113584c <__reset+0xfb11584c>
811359d8:	3446b03a 	or	r3,r6,r17
811359dc:	18001526 	beq	r3,zero,81135a34 <__divdf3+0x2b0>
811359e0:	88011b26 	beq	r17,zero,81135e50 <__divdf3+0x6cc>
811359e4:	8809883a 	mov	r4,r17
811359e8:	d9800315 	stw	r6,12(sp)
811359ec:	da400115 	stw	r9,4(sp)
811359f0:	11214080 	call	81121408 <__clzsi2>
811359f4:	d9800317 	ldw	r6,12(sp)
811359f8:	da400117 	ldw	r9,4(sp)
811359fc:	113ffd44 	addi	r4,r2,-11
81135a00:	00c00704 	movi	r3,28
81135a04:	19010e16 	blt	r3,r4,81135e40 <__divdf3+0x6bc>
81135a08:	00c00744 	movi	r3,29
81135a0c:	123ffe04 	addi	r8,r2,-8
81135a10:	1907c83a 	sub	r3,r3,r4
81135a14:	8a22983a 	sll	r17,r17,r8
81135a18:	30c6d83a 	srl	r3,r6,r3
81135a1c:	3210983a 	sll	r8,r6,r8
81135a20:	1c62b03a 	or	r17,r3,r17
81135a24:	1080fcc4 	addi	r2,r2,1011
81135a28:	0085c83a 	sub	r2,zero,r2
81135a2c:	000f883a 	mov	r7,zero
81135a30:	003f8606 	br	8113584c <__reset+0xfb11584c>
81135a34:	0023883a 	mov	r17,zero
81135a38:	0011883a 	mov	r8,zero
81135a3c:	01c00044 	movi	r7,1
81135a40:	003f8206 	br	8113584c <__reset+0xfb11584c>
81135a44:	01c000c4 	movi	r7,3
81135a48:	003f8006 	br	8113584c <__reset+0xfb11584c>
81135a4c:	04c00104 	movi	r19,4
81135a50:	0021883a 	mov	r16,zero
81135a54:	0025883a 	mov	r18,zero
81135a58:	02400044 	movi	r9,1
81135a5c:	003f6906 	br	81135804 <__reset+0xfb115804>
81135a60:	04c00304 	movi	r19,12
81135a64:	024000c4 	movi	r9,3
81135a68:	003f6606 	br	81135804 <__reset+0xfb115804>
81135a6c:	01400434 	movhi	r5,16
81135a70:	0007883a 	mov	r3,zero
81135a74:	297fffc4 	addi	r5,r5,-1
81135a78:	04bfffc4 	movi	r18,-1
81135a7c:	0081ffc4 	movi	r2,2047
81135a80:	003fa106 	br	81135908 <__reset+0xfb115908>
81135a84:	00c00044 	movi	r3,1
81135a88:	1887c83a 	sub	r3,r3,r2
81135a8c:	01000e04 	movi	r4,56
81135a90:	20c1210e 	bge	r4,r3,81135f18 <__divdf3+0x794>
81135a94:	98c0004c 	andi	r3,r19,1
81135a98:	0005883a 	mov	r2,zero
81135a9c:	000b883a 	mov	r5,zero
81135aa0:	0025883a 	mov	r18,zero
81135aa4:	003f9806 	br	81135908 <__reset+0xfb115908>
81135aa8:	8c00fd36 	bltu	r17,r16,81135ea0 <__divdf3+0x71c>
81135aac:	8440fb26 	beq	r16,r17,81135e9c <__divdf3+0x718>
81135ab0:	8007883a 	mov	r3,r16
81135ab4:	ad7fffc4 	addi	r21,r21,-1
81135ab8:	0021883a 	mov	r16,zero
81135abc:	4004d63a 	srli	r2,r8,24
81135ac0:	8822923a 	slli	r17,r17,8
81135ac4:	1809883a 	mov	r4,r3
81135ac8:	402c923a 	slli	r22,r8,8
81135acc:	88b8b03a 	or	fp,r17,r2
81135ad0:	e028d43a 	srli	r20,fp,16
81135ad4:	d8c00015 	stw	r3,0(sp)
81135ad8:	e5ffffcc 	andi	r23,fp,65535
81135adc:	a00b883a 	mov	r5,r20
81135ae0:	1134c180 	call	81134c18 <__udivsi3>
81135ae4:	d8c00017 	ldw	r3,0(sp)
81135ae8:	a00b883a 	mov	r5,r20
81135aec:	d8800315 	stw	r2,12(sp)
81135af0:	1809883a 	mov	r4,r3
81135af4:	1134c7c0 	call	81134c7c <__umodsi3>
81135af8:	d9800317 	ldw	r6,12(sp)
81135afc:	1006943a 	slli	r3,r2,16
81135b00:	9004d43a 	srli	r2,r18,16
81135b04:	b9a3383a 	mul	r17,r23,r6
81135b08:	10c4b03a 	or	r2,r2,r3
81135b0c:	1440062e 	bgeu	r2,r17,81135b28 <__divdf3+0x3a4>
81135b10:	1705883a 	add	r2,r2,fp
81135b14:	30ffffc4 	addi	r3,r6,-1
81135b18:	1700ee36 	bltu	r2,fp,81135ed4 <__divdf3+0x750>
81135b1c:	1440ed2e 	bgeu	r2,r17,81135ed4 <__divdf3+0x750>
81135b20:	31bfff84 	addi	r6,r6,-2
81135b24:	1705883a 	add	r2,r2,fp
81135b28:	1463c83a 	sub	r17,r2,r17
81135b2c:	a00b883a 	mov	r5,r20
81135b30:	8809883a 	mov	r4,r17
81135b34:	d9800315 	stw	r6,12(sp)
81135b38:	1134c180 	call	81134c18 <__udivsi3>
81135b3c:	a00b883a 	mov	r5,r20
81135b40:	8809883a 	mov	r4,r17
81135b44:	d8800215 	stw	r2,8(sp)
81135b48:	1134c7c0 	call	81134c7c <__umodsi3>
81135b4c:	d9c00217 	ldw	r7,8(sp)
81135b50:	1004943a 	slli	r2,r2,16
81135b54:	94bfffcc 	andi	r18,r18,65535
81135b58:	b9d1383a 	mul	r8,r23,r7
81135b5c:	90a4b03a 	or	r18,r18,r2
81135b60:	d9800317 	ldw	r6,12(sp)
81135b64:	9200062e 	bgeu	r18,r8,81135b80 <__divdf3+0x3fc>
81135b68:	9725883a 	add	r18,r18,fp
81135b6c:	38bfffc4 	addi	r2,r7,-1
81135b70:	9700d636 	bltu	r18,fp,81135ecc <__divdf3+0x748>
81135b74:	9200d52e 	bgeu	r18,r8,81135ecc <__divdf3+0x748>
81135b78:	39ffff84 	addi	r7,r7,-2
81135b7c:	9725883a 	add	r18,r18,fp
81135b80:	3004943a 	slli	r2,r6,16
81135b84:	b012d43a 	srli	r9,r22,16
81135b88:	b1bfffcc 	andi	r6,r22,65535
81135b8c:	11e2b03a 	or	r17,r2,r7
81135b90:	8806d43a 	srli	r3,r17,16
81135b94:	893fffcc 	andi	r4,r17,65535
81135b98:	218b383a 	mul	r5,r4,r6
81135b9c:	30c5383a 	mul	r2,r6,r3
81135ba0:	2249383a 	mul	r4,r4,r9
81135ba4:	280ed43a 	srli	r7,r5,16
81135ba8:	9225c83a 	sub	r18,r18,r8
81135bac:	2089883a 	add	r4,r4,r2
81135bb0:	3909883a 	add	r4,r7,r4
81135bb4:	1a47383a 	mul	r3,r3,r9
81135bb8:	2080022e 	bgeu	r4,r2,81135bc4 <__divdf3+0x440>
81135bbc:	00800074 	movhi	r2,1
81135bc0:	1887883a 	add	r3,r3,r2
81135bc4:	2004d43a 	srli	r2,r4,16
81135bc8:	2008943a 	slli	r4,r4,16
81135bcc:	297fffcc 	andi	r5,r5,65535
81135bd0:	10c7883a 	add	r3,r2,r3
81135bd4:	2149883a 	add	r4,r4,r5
81135bd8:	90c0a536 	bltu	r18,r3,81135e70 <__divdf3+0x6ec>
81135bdc:	90c0bf26 	beq	r18,r3,81135edc <__divdf3+0x758>
81135be0:	90c7c83a 	sub	r3,r18,r3
81135be4:	810fc83a 	sub	r7,r16,r4
81135be8:	81e5803a 	cmpltu	r18,r16,r7
81135bec:	1ca5c83a 	sub	r18,r3,r18
81135bf0:	e480c126 	beq	fp,r18,81135ef8 <__divdf3+0x774>
81135bf4:	a00b883a 	mov	r5,r20
81135bf8:	9009883a 	mov	r4,r18
81135bfc:	d9800315 	stw	r6,12(sp)
81135c00:	d9c00215 	stw	r7,8(sp)
81135c04:	da400115 	stw	r9,4(sp)
81135c08:	1134c180 	call	81134c18 <__udivsi3>
81135c0c:	a00b883a 	mov	r5,r20
81135c10:	9009883a 	mov	r4,r18
81135c14:	d8800015 	stw	r2,0(sp)
81135c18:	1134c7c0 	call	81134c7c <__umodsi3>
81135c1c:	d9c00217 	ldw	r7,8(sp)
81135c20:	da000017 	ldw	r8,0(sp)
81135c24:	1006943a 	slli	r3,r2,16
81135c28:	3804d43a 	srli	r2,r7,16
81135c2c:	ba21383a 	mul	r16,r23,r8
81135c30:	d9800317 	ldw	r6,12(sp)
81135c34:	10c4b03a 	or	r2,r2,r3
81135c38:	da400117 	ldw	r9,4(sp)
81135c3c:	1400062e 	bgeu	r2,r16,81135c58 <__divdf3+0x4d4>
81135c40:	1705883a 	add	r2,r2,fp
81135c44:	40ffffc4 	addi	r3,r8,-1
81135c48:	1700ad36 	bltu	r2,fp,81135f00 <__divdf3+0x77c>
81135c4c:	1400ac2e 	bgeu	r2,r16,81135f00 <__divdf3+0x77c>
81135c50:	423fff84 	addi	r8,r8,-2
81135c54:	1705883a 	add	r2,r2,fp
81135c58:	1421c83a 	sub	r16,r2,r16
81135c5c:	a00b883a 	mov	r5,r20
81135c60:	8009883a 	mov	r4,r16
81135c64:	d9800315 	stw	r6,12(sp)
81135c68:	d9c00215 	stw	r7,8(sp)
81135c6c:	da000015 	stw	r8,0(sp)
81135c70:	da400115 	stw	r9,4(sp)
81135c74:	1134c180 	call	81134c18 <__udivsi3>
81135c78:	8009883a 	mov	r4,r16
81135c7c:	a00b883a 	mov	r5,r20
81135c80:	1025883a 	mov	r18,r2
81135c84:	1134c7c0 	call	81134c7c <__umodsi3>
81135c88:	d9c00217 	ldw	r7,8(sp)
81135c8c:	1004943a 	slli	r2,r2,16
81135c90:	bcaf383a 	mul	r23,r23,r18
81135c94:	393fffcc 	andi	r4,r7,65535
81135c98:	2088b03a 	or	r4,r4,r2
81135c9c:	d9800317 	ldw	r6,12(sp)
81135ca0:	da000017 	ldw	r8,0(sp)
81135ca4:	da400117 	ldw	r9,4(sp)
81135ca8:	25c0062e 	bgeu	r4,r23,81135cc4 <__divdf3+0x540>
81135cac:	2709883a 	add	r4,r4,fp
81135cb0:	90bfffc4 	addi	r2,r18,-1
81135cb4:	27009436 	bltu	r4,fp,81135f08 <__divdf3+0x784>
81135cb8:	25c0932e 	bgeu	r4,r23,81135f08 <__divdf3+0x784>
81135cbc:	94bfff84 	addi	r18,r18,-2
81135cc0:	2709883a 	add	r4,r4,fp
81135cc4:	4004943a 	slli	r2,r8,16
81135cc8:	25efc83a 	sub	r23,r4,r23
81135ccc:	1490b03a 	or	r8,r2,r18
81135cd0:	4008d43a 	srli	r4,r8,16
81135cd4:	40ffffcc 	andi	r3,r8,65535
81135cd8:	30c5383a 	mul	r2,r6,r3
81135cdc:	1a47383a 	mul	r3,r3,r9
81135ce0:	310d383a 	mul	r6,r6,r4
81135ce4:	100ad43a 	srli	r5,r2,16
81135ce8:	4913383a 	mul	r9,r9,r4
81135cec:	1987883a 	add	r3,r3,r6
81135cf0:	28c7883a 	add	r3,r5,r3
81135cf4:	1980022e 	bgeu	r3,r6,81135d00 <__divdf3+0x57c>
81135cf8:	01000074 	movhi	r4,1
81135cfc:	4913883a 	add	r9,r9,r4
81135d00:	1808d43a 	srli	r4,r3,16
81135d04:	1806943a 	slli	r3,r3,16
81135d08:	10bfffcc 	andi	r2,r2,65535
81135d0c:	2253883a 	add	r9,r4,r9
81135d10:	1887883a 	add	r3,r3,r2
81135d14:	ba403836 	bltu	r23,r9,81135df8 <__divdf3+0x674>
81135d18:	ba403626 	beq	r23,r9,81135df4 <__divdf3+0x670>
81135d1c:	42000054 	ori	r8,r8,1
81135d20:	a880ffc4 	addi	r2,r21,1023
81135d24:	00bf570e 	bge	zero,r2,81135a84 <__reset+0xfb115a84>
81135d28:	40c001cc 	andi	r3,r8,7
81135d2c:	18000726 	beq	r3,zero,81135d4c <__divdf3+0x5c8>
81135d30:	40c003cc 	andi	r3,r8,15
81135d34:	01000104 	movi	r4,4
81135d38:	19000426 	beq	r3,r4,81135d4c <__divdf3+0x5c8>
81135d3c:	4107883a 	add	r3,r8,r4
81135d40:	1a11803a 	cmpltu	r8,r3,r8
81135d44:	8a23883a 	add	r17,r17,r8
81135d48:	1811883a 	mov	r8,r3
81135d4c:	88c0402c 	andhi	r3,r17,256
81135d50:	18000426 	beq	r3,zero,81135d64 <__divdf3+0x5e0>
81135d54:	00ffc034 	movhi	r3,65280
81135d58:	18ffffc4 	addi	r3,r3,-1
81135d5c:	a8810004 	addi	r2,r21,1024
81135d60:	88e2703a 	and	r17,r17,r3
81135d64:	00c1ff84 	movi	r3,2046
81135d68:	18bee316 	blt	r3,r2,811358f8 <__reset+0xfb1158f8>
81135d6c:	8824977a 	slli	r18,r17,29
81135d70:	4010d0fa 	srli	r8,r8,3
81135d74:	8822927a 	slli	r17,r17,9
81135d78:	1081ffcc 	andi	r2,r2,2047
81135d7c:	9224b03a 	or	r18,r18,r8
81135d80:	880ad33a 	srli	r5,r17,12
81135d84:	98c0004c 	andi	r3,r19,1
81135d88:	003edf06 	br	81135908 <__reset+0xfb115908>
81135d8c:	8080022c 	andhi	r2,r16,8
81135d90:	10001226 	beq	r2,zero,81135ddc <__divdf3+0x658>
81135d94:	8880022c 	andhi	r2,r17,8
81135d98:	1000101e 	bne	r2,zero,81135ddc <__divdf3+0x658>
81135d9c:	00800434 	movhi	r2,16
81135da0:	89400234 	orhi	r5,r17,8
81135da4:	10bfffc4 	addi	r2,r2,-1
81135da8:	b007883a 	mov	r3,r22
81135dac:	288a703a 	and	r5,r5,r2
81135db0:	4025883a 	mov	r18,r8
81135db4:	003f3106 	br	81135a7c <__reset+0xfb115a7c>
81135db8:	008000c4 	movi	r2,3
81135dbc:	3880a626 	beq	r7,r2,81136058 <__divdf3+0x8d4>
81135dc0:	00800044 	movi	r2,1
81135dc4:	3880521e 	bne	r7,r2,81135f10 <__divdf3+0x78c>
81135dc8:	b807883a 	mov	r3,r23
81135dcc:	0005883a 	mov	r2,zero
81135dd0:	000b883a 	mov	r5,zero
81135dd4:	0025883a 	mov	r18,zero
81135dd8:	003ecb06 	br	81135908 <__reset+0xfb115908>
81135ddc:	00800434 	movhi	r2,16
81135de0:	81400234 	orhi	r5,r16,8
81135de4:	10bfffc4 	addi	r2,r2,-1
81135de8:	a007883a 	mov	r3,r20
81135dec:	288a703a 	and	r5,r5,r2
81135df0:	003f2206 	br	81135a7c <__reset+0xfb115a7c>
81135df4:	183fca26 	beq	r3,zero,81135d20 <__reset+0xfb115d20>
81135df8:	e5ef883a 	add	r23,fp,r23
81135dfc:	40bfffc4 	addi	r2,r8,-1
81135e00:	bf00392e 	bgeu	r23,fp,81135ee8 <__divdf3+0x764>
81135e04:	1011883a 	mov	r8,r2
81135e08:	ba7fc41e 	bne	r23,r9,81135d1c <__reset+0xfb115d1c>
81135e0c:	b0ffc31e 	bne	r22,r3,81135d1c <__reset+0xfb115d1c>
81135e10:	003fc306 	br	81135d20 <__reset+0xfb115d20>
81135e14:	143ff604 	addi	r16,r2,-40
81135e18:	9c20983a 	sll	r16,r19,r16
81135e1c:	0025883a 	mov	r18,zero
81135e20:	003ee206 	br	811359ac <__reset+0xfb1159ac>
81135e24:	d9800315 	stw	r6,12(sp)
81135e28:	d9c00215 	stw	r7,8(sp)
81135e2c:	11214080 	call	81121408 <__clzsi2>
81135e30:	10800804 	addi	r2,r2,32
81135e34:	d9c00217 	ldw	r7,8(sp)
81135e38:	d9800317 	ldw	r6,12(sp)
81135e3c:	003ed106 	br	81135984 <__reset+0xfb115984>
81135e40:	147ff604 	addi	r17,r2,-40
81135e44:	3462983a 	sll	r17,r6,r17
81135e48:	0011883a 	mov	r8,zero
81135e4c:	003ef506 	br	81135a24 <__reset+0xfb115a24>
81135e50:	3009883a 	mov	r4,r6
81135e54:	d9800315 	stw	r6,12(sp)
81135e58:	da400115 	stw	r9,4(sp)
81135e5c:	11214080 	call	81121408 <__clzsi2>
81135e60:	10800804 	addi	r2,r2,32
81135e64:	da400117 	ldw	r9,4(sp)
81135e68:	d9800317 	ldw	r6,12(sp)
81135e6c:	003ee306 	br	811359fc <__reset+0xfb1159fc>
81135e70:	85a1883a 	add	r16,r16,r22
81135e74:	8585803a 	cmpltu	r2,r16,r22
81135e78:	1705883a 	add	r2,r2,fp
81135e7c:	14a5883a 	add	r18,r2,r18
81135e80:	88bfffc4 	addi	r2,r17,-1
81135e84:	e4800c2e 	bgeu	fp,r18,81135eb8 <__divdf3+0x734>
81135e88:	90c03e36 	bltu	r18,r3,81135f84 <__divdf3+0x800>
81135e8c:	1c806926 	beq	r3,r18,81136034 <__divdf3+0x8b0>
81135e90:	90c7c83a 	sub	r3,r18,r3
81135e94:	1023883a 	mov	r17,r2
81135e98:	003f5206 	br	81135be4 <__reset+0xfb115be4>
81135e9c:	923f0436 	bltu	r18,r8,81135ab0 <__reset+0xfb115ab0>
81135ea0:	800897fa 	slli	r4,r16,31
81135ea4:	9004d07a 	srli	r2,r18,1
81135ea8:	8006d07a 	srli	r3,r16,1
81135eac:	902097fa 	slli	r16,r18,31
81135eb0:	20a4b03a 	or	r18,r4,r2
81135eb4:	003f0106 	br	81135abc <__reset+0xfb115abc>
81135eb8:	e4bff51e 	bne	fp,r18,81135e90 <__reset+0xfb115e90>
81135ebc:	85bff22e 	bgeu	r16,r22,81135e88 <__reset+0xfb115e88>
81135ec0:	e0c7c83a 	sub	r3,fp,r3
81135ec4:	1023883a 	mov	r17,r2
81135ec8:	003f4606 	br	81135be4 <__reset+0xfb115be4>
81135ecc:	100f883a 	mov	r7,r2
81135ed0:	003f2b06 	br	81135b80 <__reset+0xfb115b80>
81135ed4:	180d883a 	mov	r6,r3
81135ed8:	003f1306 	br	81135b28 <__reset+0xfb115b28>
81135edc:	813fe436 	bltu	r16,r4,81135e70 <__reset+0xfb115e70>
81135ee0:	0007883a 	mov	r3,zero
81135ee4:	003f3f06 	br	81135be4 <__reset+0xfb115be4>
81135ee8:	ba402c36 	bltu	r23,r9,81135f9c <__divdf3+0x818>
81135eec:	4dc05426 	beq	r9,r23,81136040 <__divdf3+0x8bc>
81135ef0:	1011883a 	mov	r8,r2
81135ef4:	003f8906 	br	81135d1c <__reset+0xfb115d1c>
81135ef8:	023fffc4 	movi	r8,-1
81135efc:	003f8806 	br	81135d20 <__reset+0xfb115d20>
81135f00:	1811883a 	mov	r8,r3
81135f04:	003f5406 	br	81135c58 <__reset+0xfb115c58>
81135f08:	1025883a 	mov	r18,r2
81135f0c:	003f6d06 	br	81135cc4 <__reset+0xfb115cc4>
81135f10:	b827883a 	mov	r19,r23
81135f14:	003f8206 	br	81135d20 <__reset+0xfb115d20>
81135f18:	010007c4 	movi	r4,31
81135f1c:	20c02616 	blt	r4,r3,81135fb8 <__divdf3+0x834>
81135f20:	00800804 	movi	r2,32
81135f24:	10c5c83a 	sub	r2,r2,r3
81135f28:	888a983a 	sll	r5,r17,r2
81135f2c:	40c8d83a 	srl	r4,r8,r3
81135f30:	4084983a 	sll	r2,r8,r2
81135f34:	88e2d83a 	srl	r17,r17,r3
81135f38:	2906b03a 	or	r3,r5,r4
81135f3c:	1004c03a 	cmpne	r2,r2,zero
81135f40:	1886b03a 	or	r3,r3,r2
81135f44:	188001cc 	andi	r2,r3,7
81135f48:	10000726 	beq	r2,zero,81135f68 <__divdf3+0x7e4>
81135f4c:	188003cc 	andi	r2,r3,15
81135f50:	01000104 	movi	r4,4
81135f54:	11000426 	beq	r2,r4,81135f68 <__divdf3+0x7e4>
81135f58:	1805883a 	mov	r2,r3
81135f5c:	10c00104 	addi	r3,r2,4
81135f60:	1885803a 	cmpltu	r2,r3,r2
81135f64:	88a3883a 	add	r17,r17,r2
81135f68:	8880202c 	andhi	r2,r17,128
81135f6c:	10002726 	beq	r2,zero,8113600c <__divdf3+0x888>
81135f70:	98c0004c 	andi	r3,r19,1
81135f74:	00800044 	movi	r2,1
81135f78:	000b883a 	mov	r5,zero
81135f7c:	0025883a 	mov	r18,zero
81135f80:	003e6106 	br	81135908 <__reset+0xfb115908>
81135f84:	85a1883a 	add	r16,r16,r22
81135f88:	8585803a 	cmpltu	r2,r16,r22
81135f8c:	1705883a 	add	r2,r2,fp
81135f90:	14a5883a 	add	r18,r2,r18
81135f94:	8c7fff84 	addi	r17,r17,-2
81135f98:	003f1106 	br	81135be0 <__reset+0xfb115be0>
81135f9c:	b589883a 	add	r4,r22,r22
81135fa0:	25ad803a 	cmpltu	r22,r4,r22
81135fa4:	b739883a 	add	fp,r22,fp
81135fa8:	40bfff84 	addi	r2,r8,-2
81135fac:	bf2f883a 	add	r23,r23,fp
81135fb0:	202d883a 	mov	r22,r4
81135fb4:	003f9306 	br	81135e04 <__reset+0xfb115e04>
81135fb8:	013ff844 	movi	r4,-31
81135fbc:	2085c83a 	sub	r2,r4,r2
81135fc0:	8888d83a 	srl	r4,r17,r2
81135fc4:	00800804 	movi	r2,32
81135fc8:	18802126 	beq	r3,r2,81136050 <__divdf3+0x8cc>
81135fcc:	00801004 	movi	r2,64
81135fd0:	10c5c83a 	sub	r2,r2,r3
81135fd4:	8884983a 	sll	r2,r17,r2
81135fd8:	1204b03a 	or	r2,r2,r8
81135fdc:	1004c03a 	cmpne	r2,r2,zero
81135fe0:	2084b03a 	or	r2,r4,r2
81135fe4:	144001cc 	andi	r17,r2,7
81135fe8:	88000d1e 	bne	r17,zero,81136020 <__divdf3+0x89c>
81135fec:	000b883a 	mov	r5,zero
81135ff0:	1024d0fa 	srli	r18,r2,3
81135ff4:	98c0004c 	andi	r3,r19,1
81135ff8:	0005883a 	mov	r2,zero
81135ffc:	9464b03a 	or	r18,r18,r17
81136000:	003e4106 	br	81135908 <__reset+0xfb115908>
81136004:	1007883a 	mov	r3,r2
81136008:	0023883a 	mov	r17,zero
8113600c:	880a927a 	slli	r5,r17,9
81136010:	1805883a 	mov	r2,r3
81136014:	8822977a 	slli	r17,r17,29
81136018:	280ad33a 	srli	r5,r5,12
8113601c:	003ff406 	br	81135ff0 <__reset+0xfb115ff0>
81136020:	10c003cc 	andi	r3,r2,15
81136024:	01000104 	movi	r4,4
81136028:	193ff626 	beq	r3,r4,81136004 <__reset+0xfb116004>
8113602c:	0023883a 	mov	r17,zero
81136030:	003fca06 	br	81135f5c <__reset+0xfb115f5c>
81136034:	813fd336 	bltu	r16,r4,81135f84 <__reset+0xfb115f84>
81136038:	1023883a 	mov	r17,r2
8113603c:	003fa806 	br	81135ee0 <__reset+0xfb115ee0>
81136040:	b0ffd636 	bltu	r22,r3,81135f9c <__reset+0xfb115f9c>
81136044:	1011883a 	mov	r8,r2
81136048:	b0ff341e 	bne	r22,r3,81135d1c <__reset+0xfb115d1c>
8113604c:	003f3406 	br	81135d20 <__reset+0xfb115d20>
81136050:	0005883a 	mov	r2,zero
81136054:	003fe006 	br	81135fd8 <__reset+0xfb115fd8>
81136058:	00800434 	movhi	r2,16
8113605c:	89400234 	orhi	r5,r17,8
81136060:	10bfffc4 	addi	r2,r2,-1
81136064:	b807883a 	mov	r3,r23
81136068:	288a703a 	and	r5,r5,r2
8113606c:	4025883a 	mov	r18,r8
81136070:	003e8206 	br	81135a7c <__reset+0xfb115a7c>

81136074 <__eqdf2>:
81136074:	2804d53a 	srli	r2,r5,20
81136078:	3806d53a 	srli	r3,r7,20
8113607c:	02000434 	movhi	r8,16
81136080:	423fffc4 	addi	r8,r8,-1
81136084:	1081ffcc 	andi	r2,r2,2047
81136088:	0281ffc4 	movi	r10,2047
8113608c:	2a12703a 	and	r9,r5,r8
81136090:	18c1ffcc 	andi	r3,r3,2047
81136094:	3a10703a 	and	r8,r7,r8
81136098:	280ad7fa 	srli	r5,r5,31
8113609c:	380ed7fa 	srli	r7,r7,31
811360a0:	12801026 	beq	r2,r10,811360e4 <__eqdf2+0x70>
811360a4:	0281ffc4 	movi	r10,2047
811360a8:	1a800a26 	beq	r3,r10,811360d4 <__eqdf2+0x60>
811360ac:	10c00226 	beq	r2,r3,811360b8 <__eqdf2+0x44>
811360b0:	00800044 	movi	r2,1
811360b4:	f800283a 	ret
811360b8:	4a3ffd1e 	bne	r9,r8,811360b0 <__reset+0xfb1160b0>
811360bc:	21bffc1e 	bne	r4,r6,811360b0 <__reset+0xfb1160b0>
811360c0:	29c00c26 	beq	r5,r7,811360f4 <__eqdf2+0x80>
811360c4:	103ffa1e 	bne	r2,zero,811360b0 <__reset+0xfb1160b0>
811360c8:	2244b03a 	or	r2,r4,r9
811360cc:	1004c03a 	cmpne	r2,r2,zero
811360d0:	f800283a 	ret
811360d4:	3214b03a 	or	r10,r6,r8
811360d8:	503ff426 	beq	r10,zero,811360ac <__reset+0xfb1160ac>
811360dc:	00800044 	movi	r2,1
811360e0:	f800283a 	ret
811360e4:	2254b03a 	or	r10,r4,r9
811360e8:	503fee26 	beq	r10,zero,811360a4 <__reset+0xfb1160a4>
811360ec:	00800044 	movi	r2,1
811360f0:	f800283a 	ret
811360f4:	0005883a 	mov	r2,zero
811360f8:	f800283a 	ret

811360fc <__ledf2>:
811360fc:	2804d53a 	srli	r2,r5,20
81136100:	3810d53a 	srli	r8,r7,20
81136104:	00c00434 	movhi	r3,16
81136108:	18ffffc4 	addi	r3,r3,-1
8113610c:	1081ffcc 	andi	r2,r2,2047
81136110:	0241ffc4 	movi	r9,2047
81136114:	28d4703a 	and	r10,r5,r3
81136118:	4201ffcc 	andi	r8,r8,2047
8113611c:	38c6703a 	and	r3,r7,r3
81136120:	280ad7fa 	srli	r5,r5,31
81136124:	380ed7fa 	srli	r7,r7,31
81136128:	12401f26 	beq	r2,r9,811361a8 <__ledf2+0xac>
8113612c:	0241ffc4 	movi	r9,2047
81136130:	42401426 	beq	r8,r9,81136184 <__ledf2+0x88>
81136134:	1000091e 	bne	r2,zero,8113615c <__ledf2+0x60>
81136138:	2296b03a 	or	r11,r4,r10
8113613c:	5813003a 	cmpeq	r9,r11,zero
81136140:	29403fcc 	andi	r5,r5,255
81136144:	40000a1e 	bne	r8,zero,81136170 <__ledf2+0x74>
81136148:	30d8b03a 	or	r12,r6,r3
8113614c:	6000081e 	bne	r12,zero,81136170 <__ledf2+0x74>
81136150:	0005883a 	mov	r2,zero
81136154:	5800111e 	bne	r11,zero,8113619c <__ledf2+0xa0>
81136158:	f800283a 	ret
8113615c:	29403fcc 	andi	r5,r5,255
81136160:	40000c1e 	bne	r8,zero,81136194 <__ledf2+0x98>
81136164:	30d2b03a 	or	r9,r6,r3
81136168:	48000c26 	beq	r9,zero,8113619c <__ledf2+0xa0>
8113616c:	0013883a 	mov	r9,zero
81136170:	39c03fcc 	andi	r7,r7,255
81136174:	48000826 	beq	r9,zero,81136198 <__ledf2+0x9c>
81136178:	38001126 	beq	r7,zero,811361c0 <__ledf2+0xc4>
8113617c:	00800044 	movi	r2,1
81136180:	f800283a 	ret
81136184:	30d2b03a 	or	r9,r6,r3
81136188:	483fea26 	beq	r9,zero,81136134 <__reset+0xfb116134>
8113618c:	00800084 	movi	r2,2
81136190:	f800283a 	ret
81136194:	39c03fcc 	andi	r7,r7,255
81136198:	39400726 	beq	r7,r5,811361b8 <__ledf2+0xbc>
8113619c:	2800081e 	bne	r5,zero,811361c0 <__ledf2+0xc4>
811361a0:	00800044 	movi	r2,1
811361a4:	f800283a 	ret
811361a8:	2292b03a 	or	r9,r4,r10
811361ac:	483fdf26 	beq	r9,zero,8113612c <__reset+0xfb11612c>
811361b0:	00800084 	movi	r2,2
811361b4:	f800283a 	ret
811361b8:	4080030e 	bge	r8,r2,811361c8 <__ledf2+0xcc>
811361bc:	383fef26 	beq	r7,zero,8113617c <__reset+0xfb11617c>
811361c0:	00bfffc4 	movi	r2,-1
811361c4:	f800283a 	ret
811361c8:	123feb16 	blt	r2,r8,81136178 <__reset+0xfb116178>
811361cc:	1abff336 	bltu	r3,r10,8113619c <__reset+0xfb11619c>
811361d0:	50c00326 	beq	r10,r3,811361e0 <__ledf2+0xe4>
811361d4:	50c0042e 	bgeu	r10,r3,811361e8 <__ledf2+0xec>
811361d8:	283fe81e 	bne	r5,zero,8113617c <__reset+0xfb11617c>
811361dc:	003ff806 	br	811361c0 <__reset+0xfb1161c0>
811361e0:	313fee36 	bltu	r6,r4,8113619c <__reset+0xfb11619c>
811361e4:	21bffc36 	bltu	r4,r6,811361d8 <__reset+0xfb1161d8>
811361e8:	0005883a 	mov	r2,zero
811361ec:	f800283a 	ret

811361f0 <__floatunsidf>:
811361f0:	defffe04 	addi	sp,sp,-8
811361f4:	de00012e 	bgeu	sp,et,811361fc <__floatunsidf+0xc>
811361f8:	003b68fa 	trap	3
811361fc:	dc000015 	stw	r16,0(sp)
81136200:	dfc00115 	stw	ra,4(sp)
81136204:	2021883a 	mov	r16,r4
81136208:	20002226 	beq	r4,zero,81136294 <__floatunsidf+0xa4>
8113620c:	11214080 	call	81121408 <__clzsi2>
81136210:	01010784 	movi	r4,1054
81136214:	2089c83a 	sub	r4,r4,r2
81136218:	01810cc4 	movi	r6,1075
8113621c:	310dc83a 	sub	r6,r6,r4
81136220:	00c007c4 	movi	r3,31
81136224:	1980120e 	bge	r3,r6,81136270 <__floatunsidf+0x80>
81136228:	00c104c4 	movi	r3,1043
8113622c:	1907c83a 	sub	r3,r3,r4
81136230:	80ca983a 	sll	r5,r16,r3
81136234:	00800434 	movhi	r2,16
81136238:	10bfffc4 	addi	r2,r2,-1
8113623c:	2101ffcc 	andi	r4,r4,2047
81136240:	0021883a 	mov	r16,zero
81136244:	288a703a 	and	r5,r5,r2
81136248:	2008953a 	slli	r4,r4,20
8113624c:	00c00434 	movhi	r3,16
81136250:	18ffffc4 	addi	r3,r3,-1
81136254:	28c6703a 	and	r3,r5,r3
81136258:	8005883a 	mov	r2,r16
8113625c:	1906b03a 	or	r3,r3,r4
81136260:	dfc00117 	ldw	ra,4(sp)
81136264:	dc000017 	ldw	r16,0(sp)
81136268:	dec00204 	addi	sp,sp,8
8113626c:	f800283a 	ret
81136270:	00c002c4 	movi	r3,11
81136274:	188bc83a 	sub	r5,r3,r2
81136278:	814ad83a 	srl	r5,r16,r5
8113627c:	00c00434 	movhi	r3,16
81136280:	18ffffc4 	addi	r3,r3,-1
81136284:	81a0983a 	sll	r16,r16,r6
81136288:	2101ffcc 	andi	r4,r4,2047
8113628c:	28ca703a 	and	r5,r5,r3
81136290:	003fed06 	br	81136248 <__reset+0xfb116248>
81136294:	0009883a 	mov	r4,zero
81136298:	000b883a 	mov	r5,zero
8113629c:	003fea06 	br	81136248 <__reset+0xfb116248>

811362a0 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
811362a0:	defffb04 	addi	sp,sp,-20
811362a4:	de00012e 	bgeu	sp,et,811362ac <alt_busy_sleep+0xc>
811362a8:	003b68fa 	trap	3
811362ac:	df000415 	stw	fp,16(sp)
811362b0:	df000404 	addi	fp,sp,16
811362b4:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
811362b8:	008000c4 	movi	r2,3
811362bc:	e0bffd15 	stw	r2,-12(fp)
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
811362c0:	e0fffd17 	ldw	r3,-12(fp)
811362c4:	008003f4 	movhi	r2,15
811362c8:	10909004 	addi	r2,r2,16960
811362cc:	1887383a 	mul	r3,r3,r2
811362d0:	00817db4 	movhi	r2,1526
811362d4:	10b84004 	addi	r2,r2,-7936
811362d8:	10c7203a 	divu	r3,r2,r3
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
811362dc:	00a00034 	movhi	r2,32768
811362e0:	10bfffc4 	addi	r2,r2,-1
811362e4:	10c5203a 	divu	r2,r2,r3
811362e8:	e0ffff17 	ldw	r3,-4(fp)
811362ec:	1885203a 	divu	r2,r3,r2
811362f0:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
811362f4:	e0bffe17 	ldw	r2,-8(fp)
811362f8:	10002526 	beq	r2,zero,81136390 <alt_busy_sleep+0xf0>
  {
    for(i=0;i<big_loops;i++)
811362fc:	e03ffc15 	stw	zero,-16(fp)
81136300:	00001406 	br	81136354 <alt_busy_sleep+0xb4>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
81136304:	00a00034 	movhi	r2,32768
81136308:	10bfffc4 	addi	r2,r2,-1
8113630c:	10bfffc4 	addi	r2,r2,-1
81136310:	103ffe1e 	bne	r2,zero,8113630c <__reset+0xfb11630c>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
81136314:	e0fffd17 	ldw	r3,-12(fp)
81136318:	008003f4 	movhi	r2,15
8113631c:	10909004 	addi	r2,r2,16960
81136320:	1887383a 	mul	r3,r3,r2
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
81136324:	00817db4 	movhi	r2,1526
81136328:	10b84004 	addi	r2,r2,-7936
8113632c:	10c7203a 	divu	r3,r2,r3
81136330:	00a00034 	movhi	r2,32768
81136334:	10bfffc4 	addi	r2,r2,-1
81136338:	10c5203a 	divu	r2,r2,r3
8113633c:	e0ffff17 	ldw	r3,-4(fp)
81136340:	1885c83a 	sub	r2,r3,r2
81136344:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
81136348:	e0bffc17 	ldw	r2,-16(fp)
8113634c:	10800044 	addi	r2,r2,1
81136350:	e0bffc15 	stw	r2,-16(fp)
81136354:	e0fffc17 	ldw	r3,-16(fp)
81136358:	e0bffe17 	ldw	r2,-8(fp)
8113635c:	18bfe916 	blt	r3,r2,81136304 <__reset+0xfb116304>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
81136360:	e0fffd17 	ldw	r3,-12(fp)
81136364:	008003f4 	movhi	r2,15
81136368:	10909004 	addi	r2,r2,16960
8113636c:	1887383a 	mul	r3,r3,r2
81136370:	00817db4 	movhi	r2,1526
81136374:	10b84004 	addi	r2,r2,-7936
81136378:	10c7203a 	divu	r3,r2,r3
8113637c:	e0bfff17 	ldw	r2,-4(fp)
81136380:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
81136384:	10bfffc4 	addi	r2,r2,-1
81136388:	103ffe1e 	bne	r2,zero,81136384 <__reset+0xfb116384>
8113638c:	00000b06 	br	811363bc <alt_busy_sleep+0x11c>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
81136390:	e0fffd17 	ldw	r3,-12(fp)
81136394:	008003f4 	movhi	r2,15
81136398:	10909004 	addi	r2,r2,16960
8113639c:	1887383a 	mul	r3,r3,r2
811363a0:	00817db4 	movhi	r2,1526
811363a4:	10b84004 	addi	r2,r2,-7936
811363a8:	10c7203a 	divu	r3,r2,r3
811363ac:	e0bfff17 	ldw	r2,-4(fp)
811363b0:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
811363b4:	10bfffc4 	addi	r2,r2,-1
811363b8:	00bffe16 	blt	zero,r2,811363b4 <__reset+0xfb1163b4>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
811363bc:	0005883a 	mov	r2,zero
}
811363c0:	e037883a 	mov	sp,fp
811363c4:	df000017 	ldw	fp,0(sp)
811363c8:	dec00104 	addi	sp,sp,4
811363cc:	f800283a 	ret

811363d0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811363d0:	defffe04 	addi	sp,sp,-8
811363d4:	de00012e 	bgeu	sp,et,811363dc <alt_get_errno+0xc>
811363d8:	003b68fa 	trap	3
811363dc:	dfc00115 	stw	ra,4(sp)
811363e0:	df000015 	stw	fp,0(sp)
811363e4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811363e8:	d0a01017 	ldw	r2,-32704(gp)
811363ec:	10000326 	beq	r2,zero,811363fc <alt_get_errno+0x2c>
811363f0:	d0a01017 	ldw	r2,-32704(gp)
811363f4:	103ee83a 	callr	r2
811363f8:	00000106 	br	81136400 <alt_get_errno+0x30>
811363fc:	d0a07804 	addi	r2,gp,-32288
}
81136400:	e037883a 	mov	sp,fp
81136404:	dfc00117 	ldw	ra,4(sp)
81136408:	df000017 	ldw	fp,0(sp)
8113640c:	dec00204 	addi	sp,sp,8
81136410:	f800283a 	ret

81136414 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
81136414:	defffb04 	addi	sp,sp,-20
81136418:	de00012e 	bgeu	sp,et,81136420 <close+0xc>
8113641c:	003b68fa 	trap	3
81136420:	dfc00415 	stw	ra,16(sp)
81136424:	df000315 	stw	fp,12(sp)
81136428:	df000304 	addi	fp,sp,12
8113642c:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
81136430:	e0bfff17 	ldw	r2,-4(fp)
81136434:	10000616 	blt	r2,zero,81136450 <close+0x3c>
81136438:	e0bfff17 	ldw	r2,-4(fp)
8113643c:	10c00324 	muli	r3,r2,12
81136440:	00a04574 	movhi	r2,33045
81136444:	1087f704 	addi	r2,r2,8156
81136448:	1885883a 	add	r2,r3,r2
8113644c:	00000106 	br	81136454 <close+0x40>
81136450:	0005883a 	mov	r2,zero
81136454:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
81136458:	e0bffd17 	ldw	r2,-12(fp)
8113645c:	10001926 	beq	r2,zero,811364c4 <close+0xb0>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
81136460:	e0bffd17 	ldw	r2,-12(fp)
81136464:	10800017 	ldw	r2,0(r2)
81136468:	10800417 	ldw	r2,16(r2)
8113646c:	10000626 	beq	r2,zero,81136488 <close+0x74>
81136470:	e0bffd17 	ldw	r2,-12(fp)
81136474:	10800017 	ldw	r2,0(r2)
81136478:	10800417 	ldw	r2,16(r2)
8113647c:	e13ffd17 	ldw	r4,-12(fp)
81136480:	103ee83a 	callr	r2
81136484:	00000106 	br	8113648c <close+0x78>
81136488:	0005883a 	mov	r2,zero
8113648c:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
81136490:	e13fff17 	ldw	r4,-4(fp)
81136494:	11379f80 	call	811379f8 <alt_release_fd>
    if (rval < 0)
81136498:	e0bffe17 	ldw	r2,-8(fp)
8113649c:	1000070e 	bge	r2,zero,811364bc <close+0xa8>
    {
      ALT_ERRNO = -rval;
811364a0:	11363d00 	call	811363d0 <alt_get_errno>
811364a4:	1007883a 	mov	r3,r2
811364a8:	e0bffe17 	ldw	r2,-8(fp)
811364ac:	0085c83a 	sub	r2,zero,r2
811364b0:	18800015 	stw	r2,0(r3)
      return -1;
811364b4:	00bfffc4 	movi	r2,-1
811364b8:	00000706 	br	811364d8 <close+0xc4>
    }
    return 0;
811364bc:	0005883a 	mov	r2,zero
811364c0:	00000506 	br	811364d8 <close+0xc4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
811364c4:	11363d00 	call	811363d0 <alt_get_errno>
811364c8:	1007883a 	mov	r3,r2
811364cc:	00801444 	movi	r2,81
811364d0:	18800015 	stw	r2,0(r3)
    return -1;
811364d4:	00bfffc4 	movi	r2,-1
  }
}
811364d8:	e037883a 	mov	sp,fp
811364dc:	dfc00117 	ldw	ra,4(sp)
811364e0:	df000017 	ldw	fp,0(sp)
811364e4:	dec00204 	addi	sp,sp,8
811364e8:	f800283a 	ret

811364ec <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
811364ec:	deffff04 	addi	sp,sp,-4
811364f0:	de00012e 	bgeu	sp,et,811364f8 <alt_dcache_flush_all+0xc>
811364f4:	003b68fa 	trap	3
811364f8:	df000015 	stw	fp,0(sp)
811364fc:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
81136500:	0001883a 	nop
81136504:	e037883a 	mov	sp,fp
81136508:	df000017 	ldw	fp,0(sp)
8113650c:	dec00104 	addi	sp,sp,4
81136510:	f800283a 	ret

81136514 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
81136514:	defffc04 	addi	sp,sp,-16
81136518:	de00012e 	bgeu	sp,et,81136520 <alt_dev_null_write+0xc>
8113651c:	003b68fa 	trap	3
81136520:	df000315 	stw	fp,12(sp)
81136524:	df000304 	addi	fp,sp,12
81136528:	e13ffd15 	stw	r4,-12(fp)
8113652c:	e17ffe15 	stw	r5,-8(fp)
81136530:	e1bfff15 	stw	r6,-4(fp)
  return len;
81136534:	e0bfff17 	ldw	r2,-4(fp)
}
81136538:	e037883a 	mov	sp,fp
8113653c:	df000017 	ldw	fp,0(sp)
81136540:	dec00104 	addi	sp,sp,4
81136544:	f800283a 	ret

81136548 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81136548:	defffe04 	addi	sp,sp,-8
8113654c:	de00012e 	bgeu	sp,et,81136554 <alt_get_errno+0xc>
81136550:	003b68fa 	trap	3
81136554:	dfc00115 	stw	ra,4(sp)
81136558:	df000015 	stw	fp,0(sp)
8113655c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81136560:	d0a01017 	ldw	r2,-32704(gp)
81136564:	10000326 	beq	r2,zero,81136574 <alt_get_errno+0x2c>
81136568:	d0a01017 	ldw	r2,-32704(gp)
8113656c:	103ee83a 	callr	r2
81136570:	00000106 	br	81136578 <alt_get_errno+0x30>
81136574:	d0a07804 	addi	r2,gp,-32288
}
81136578:	e037883a 	mov	sp,fp
8113657c:	dfc00117 	ldw	ra,4(sp)
81136580:	df000017 	ldw	fp,0(sp)
81136584:	dec00204 	addi	sp,sp,8
81136588:	f800283a 	ret

8113658c <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
8113658c:	defffb04 	addi	sp,sp,-20
81136590:	de00012e 	bgeu	sp,et,81136598 <fstat+0xc>
81136594:	003b68fa 	trap	3
81136598:	dfc00415 	stw	ra,16(sp)
8113659c:	df000315 	stw	fp,12(sp)
811365a0:	df000304 	addi	fp,sp,12
811365a4:	e13ffe15 	stw	r4,-8(fp)
811365a8:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
811365ac:	e0bffe17 	ldw	r2,-8(fp)
811365b0:	10000616 	blt	r2,zero,811365cc <fstat+0x40>
811365b4:	e0bffe17 	ldw	r2,-8(fp)
811365b8:	10c00324 	muli	r3,r2,12
811365bc:	00a04574 	movhi	r2,33045
811365c0:	1087f704 	addi	r2,r2,8156
811365c4:	1885883a 	add	r2,r3,r2
811365c8:	00000106 	br	811365d0 <fstat+0x44>
811365cc:	0005883a 	mov	r2,zero
811365d0:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
811365d4:	e0bffd17 	ldw	r2,-12(fp)
811365d8:	10001026 	beq	r2,zero,8113661c <fstat+0x90>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
811365dc:	e0bffd17 	ldw	r2,-12(fp)
811365e0:	10800017 	ldw	r2,0(r2)
811365e4:	10800817 	ldw	r2,32(r2)
811365e8:	10000726 	beq	r2,zero,81136608 <fstat+0x7c>
    {
      return fd->dev->fstat(fd, st);
811365ec:	e0bffd17 	ldw	r2,-12(fp)
811365f0:	10800017 	ldw	r2,0(r2)
811365f4:	10800817 	ldw	r2,32(r2)
811365f8:	e17fff17 	ldw	r5,-4(fp)
811365fc:	e13ffd17 	ldw	r4,-12(fp)
81136600:	103ee83a 	callr	r2
81136604:	00000a06 	br	81136630 <fstat+0xa4>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
81136608:	e0bfff17 	ldw	r2,-4(fp)
8113660c:	00c80004 	movi	r3,8192
81136610:	10c00115 	stw	r3,4(r2)
      return 0;
81136614:	0005883a 	mov	r2,zero
81136618:	00000506 	br	81136630 <fstat+0xa4>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
8113661c:	11365480 	call	81136548 <alt_get_errno>
81136620:	1007883a 	mov	r3,r2
81136624:	00801444 	movi	r2,81
81136628:	18800015 	stw	r2,0(r3)
    return -1;
8113662c:	00bfffc4 	movi	r2,-1
  }
}
81136630:	e037883a 	mov	sp,fp
81136634:	dfc00117 	ldw	ra,4(sp)
81136638:	df000017 	ldw	fp,0(sp)
8113663c:	dec00204 	addi	sp,sp,8
81136640:	f800283a 	ret

81136644 <alt_irq_register>:
 */
 
int alt_irq_register (alt_u32 id, 
                      void* context, 
                      alt_isr_func handler)
{
81136644:	defff004 	addi	sp,sp,-64
81136648:	de00012e 	bgeu	sp,et,81136650 <alt_irq_register+0xc>
8113664c:	003b68fa 	trap	3
81136650:	df000f15 	stw	fp,60(sp)
81136654:	df000f04 	addi	fp,sp,60
81136658:	e13ffd15 	stw	r4,-12(fp)
8113665c:	e17ffe15 	stw	r5,-8(fp)
81136660:	e1bfff15 	stw	r6,-4(fp)
  int rc = -EINVAL;  
81136664:	00bffa84 	movi	r2,-22
81136668:	e0bff115 	stw	r2,-60(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
8113666c:	e0bffd17 	ldw	r2,-12(fp)
81136670:	10800828 	cmpgeui	r2,r2,32
81136674:	1000501e 	bne	r2,zero,811367b8 <alt_irq_register+0x174>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136678:	0005303a 	rdctl	r2,status
8113667c:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136680:	e0fff617 	ldw	r3,-40(fp)
81136684:	00bfff84 	movi	r2,-2
81136688:	1884703a 	and	r2,r3,r2
8113668c:	1001703a 	wrctl	status,r2
  
  return context;
81136690:	e0bff617 	ldw	r2,-40(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all ();
81136694:	e0bff315 	stw	r2,-52(fp)

    alt_irq[id].handler = handler;
81136698:	00a045f4 	movhi	r2,33047
8113669c:	10b59e04 	addi	r2,r2,-10632
811366a0:	e0fffd17 	ldw	r3,-12(fp)
811366a4:	180690fa 	slli	r3,r3,3
811366a8:	10c5883a 	add	r2,r2,r3
811366ac:	e0ffff17 	ldw	r3,-4(fp)
811366b0:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = context;
811366b4:	00a045f4 	movhi	r2,33047
811366b8:	10b59e04 	addi	r2,r2,-10632
811366bc:	e0fffd17 	ldw	r3,-12(fp)
811366c0:	180690fa 	slli	r3,r3,3
811366c4:	10c5883a 	add	r2,r2,r3
811366c8:	10800104 	addi	r2,r2,4
811366cc:	e0fffe17 	ldw	r3,-8(fp)
811366d0:	10c00015 	stw	r3,0(r2)

    rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
811366d4:	e0bfff17 	ldw	r2,-4(fp)
811366d8:	10001926 	beq	r2,zero,81136740 <alt_irq_register+0xfc>
811366dc:	e0bffd17 	ldw	r2,-12(fp)
811366e0:	e0bff215 	stw	r2,-56(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811366e4:	0005303a 	rdctl	r2,status
811366e8:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811366ec:	e0fff717 	ldw	r3,-36(fp)
811366f0:	00bfff84 	movi	r2,-2
811366f4:	1884703a 	and	r2,r3,r2
811366f8:	1001703a 	wrctl	status,r2
  
  return context;
811366fc:	e0bff717 	ldw	r2,-36(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
81136700:	e0bff815 	stw	r2,-32(fp)

  alt_irq_active |= (1 << id);
81136704:	00c00044 	movi	r3,1
81136708:	e0bff217 	ldw	r2,-56(fp)
8113670c:	1884983a 	sll	r2,r3,r2
81136710:	1007883a 	mov	r3,r2
81136714:	d0a08017 	ldw	r2,-32256(gp)
81136718:	1884b03a 	or	r2,r3,r2
8113671c:	d0a08015 	stw	r2,-32256(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
81136720:	d0a08017 	ldw	r2,-32256(gp)
81136724:	100170fa 	wrctl	ienable,r2
81136728:	e0bff817 	ldw	r2,-32(fp)
8113672c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136730:	e0bff917 	ldw	r2,-28(fp)
81136734:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
81136738:	0005883a 	mov	r2,zero
8113673c:	00001906 	br	811367a4 <alt_irq_register+0x160>
81136740:	e0bffd17 	ldw	r2,-12(fp)
81136744:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136748:	0005303a 	rdctl	r2,status
8113674c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136750:	e0fffa17 	ldw	r3,-24(fp)
81136754:	00bfff84 	movi	r2,-2
81136758:	1884703a 	and	r2,r3,r2
8113675c:	1001703a 	wrctl	status,r2
  
  return context;
81136760:	e0bffa17 	ldw	r2,-24(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
81136764:	e0bffb15 	stw	r2,-20(fp)

  alt_irq_active &= ~(1 << id);
81136768:	00c00044 	movi	r3,1
8113676c:	e0bff417 	ldw	r2,-48(fp)
81136770:	1884983a 	sll	r2,r3,r2
81136774:	0084303a 	nor	r2,zero,r2
81136778:	1007883a 	mov	r3,r2
8113677c:	d0a08017 	ldw	r2,-32256(gp)
81136780:	1884703a 	and	r2,r3,r2
81136784:	d0a08015 	stw	r2,-32256(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
81136788:	d0a08017 	ldw	r2,-32256(gp)
8113678c:	100170fa 	wrctl	ienable,r2
81136790:	e0bffb17 	ldw	r2,-20(fp)
81136794:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136798:	e0bffc17 	ldw	r2,-16(fp)
8113679c:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
811367a0:	0005883a 	mov	r2,zero
811367a4:	e0bff115 	stw	r2,-60(fp)
811367a8:	e0bff317 	ldw	r2,-52(fp)
811367ac:	e0bff515 	stw	r2,-44(fp)
811367b0:	e0bff517 	ldw	r2,-44(fp)
811367b4:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }
  return rc; 
811367b8:	e0bff117 	ldw	r2,-60(fp)
}
811367bc:	e037883a 	mov	sp,fp
811367c0:	df000017 	ldw	fp,0(sp)
811367c4:	dec00104 	addi	sp,sp,4
811367c8:	f800283a 	ret

811367cc <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811367cc:	defffe04 	addi	sp,sp,-8
811367d0:	de00012e 	bgeu	sp,et,811367d8 <alt_get_errno+0xc>
811367d4:	003b68fa 	trap	3
811367d8:	dfc00115 	stw	ra,4(sp)
811367dc:	df000015 	stw	fp,0(sp)
811367e0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811367e4:	d0a01017 	ldw	r2,-32704(gp)
811367e8:	10000326 	beq	r2,zero,811367f8 <alt_get_errno+0x2c>
811367ec:	d0a01017 	ldw	r2,-32704(gp)
811367f0:	103ee83a 	callr	r2
811367f4:	00000106 	br	811367fc <alt_get_errno+0x30>
811367f8:	d0a07804 	addi	r2,gp,-32288
}
811367fc:	e037883a 	mov	sp,fp
81136800:	dfc00117 	ldw	ra,4(sp)
81136804:	df000017 	ldw	fp,0(sp)
81136808:	dec00204 	addi	sp,sp,8
8113680c:	f800283a 	ret

81136810 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
81136810:	deffed04 	addi	sp,sp,-76
81136814:	de00012e 	bgeu	sp,et,8113681c <isatty+0xc>
81136818:	003b68fa 	trap	3
8113681c:	dfc01215 	stw	ra,72(sp)
81136820:	df001115 	stw	fp,68(sp)
81136824:	df001104 	addi	fp,sp,68
81136828:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
8113682c:	e0bfff17 	ldw	r2,-4(fp)
81136830:	10000616 	blt	r2,zero,8113684c <isatty+0x3c>
81136834:	e0bfff17 	ldw	r2,-4(fp)
81136838:	10c00324 	muli	r3,r2,12
8113683c:	00a04574 	movhi	r2,33045
81136840:	1087f704 	addi	r2,r2,8156
81136844:	1885883a 	add	r2,r3,r2
81136848:	00000106 	br	81136850 <isatty+0x40>
8113684c:	0005883a 	mov	r2,zero
81136850:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
81136854:	e0bfef17 	ldw	r2,-68(fp)
81136858:	10000e26 	beq	r2,zero,81136894 <isatty+0x84>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
8113685c:	e0bfef17 	ldw	r2,-68(fp)
81136860:	10800017 	ldw	r2,0(r2)
81136864:	10800817 	ldw	r2,32(r2)
81136868:	1000021e 	bne	r2,zero,81136874 <isatty+0x64>
    {
      return 1;
8113686c:	00800044 	movi	r2,1
81136870:	00000d06 	br	811368a8 <isatty+0x98>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
81136874:	e0bff004 	addi	r2,fp,-64
81136878:	100b883a 	mov	r5,r2
8113687c:	e13fff17 	ldw	r4,-4(fp)
81136880:	113658c0 	call	8113658c <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
81136884:	e0bff117 	ldw	r2,-60(fp)
81136888:	10880020 	cmpeqi	r2,r2,8192
8113688c:	10803fcc 	andi	r2,r2,255
81136890:	00000506 	br	811368a8 <isatty+0x98>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
81136894:	11367cc0 	call	811367cc <alt_get_errno>
81136898:	1007883a 	mov	r3,r2
8113689c:	00801444 	movi	r2,81
811368a0:	18800015 	stw	r2,0(r3)
    return 0;
811368a4:	0005883a 	mov	r2,zero
  }
}
811368a8:	e037883a 	mov	sp,fp
811368ac:	dfc00117 	ldw	ra,4(sp)
811368b0:	df000017 	ldw	fp,0(sp)
811368b4:	dec00204 	addi	sp,sp,8
811368b8:	f800283a 	ret

811368bc <tx_log_str>:
	#include "sys/alt_log_printf.h"

        .global tx_log_str
tx_log_str:
	/* load base uart / jtag uart address into r6 */
	movhi r6, %hiadj(ALT_LOG_PORT_BASE)
811368bc:	01a04834 	movhi	r6,33056
	addi r6, r6, %lo(ALT_LOG_PORT_BASE)
811368c0:	318c2404 	addi	r6,r6,12432

811368c4 <tx_next_char>:
tx_next_char:
        /* if pointer points to null, return 
         * r4 is the pointer to the str to be printed, set by ALT_LOG_PUTS */
	ldb r7, (r4)
811368c4:	21c00007 	ldb	r7,0(r4)
	beq r0, r7, end_tx
811368c8:	01c00826 	beq	zero,r7,811368ec <end_tx>

811368cc <wait_tx_ready_loop>:

	/* check device transmit ready  */
wait_tx_ready_loop:
        ldwio   r8, ALT_LOG_PRINT_REG_OFFSET(r6)
811368cc:	32000137 	ldwio	r8,4(r6)
        /*UART, ALT_LOG_PRINT_MSK == 0x40
          JTAG UART, ALT_LOG_PRINT_MSK == 0xFFFF0000 */
        andhi   r5, r8, %hi(ALT_LOG_PRINT_MSK)
811368d0:	417fffec 	andhi	r5,r8,65535
        andi    r8, r8, %lo(ALT_LOG_PRINT_MSK)
811368d4:	4200000c 	andi	r8,r8,0
        or      r5, r5, r8
811368d8:	2a0ab03a 	or	r5,r5,r8
        beq     r5, r0, wait_tx_ready_loop	
811368dc:	283ffb26 	beq	r5,zero,811368cc <__reset+0xfb1168cc>
	/* write char */
	stwio   r7, ALT_LOG_PRINT_TXDATA_REG_OFFSET (r6)		
811368e0:	31c00035 	stwio	r7,0(r6)
	/* advance string pointer */
	addi r4, r4, 1
811368e4:	21000044 	addi	r4,r4,1
	br tx_next_char
811368e8:	003ff606 	br	811368c4 <__reset+0xfb1168c4>

811368ec <end_tx>:
end_tx:	
        ret
811368ec:	f800283a 	ret

811368f0 <alt_log_txchar>:



/* Function to put one char onto the UART/JTAG UART txdata register. */
void alt_log_txchar(int c,char *base)
{
811368f0:	defffd04 	addi	sp,sp,-12
811368f4:	de00012e 	bgeu	sp,et,811368fc <alt_log_txchar+0xc>
811368f8:	003b68fa 	trap	3
811368fc:	df000215 	stw	fp,8(sp)
81136900:	df000204 	addi	fp,sp,8
81136904:	e13ffe15 	stw	r4,-8(fp)
81136908:	e17fff15 	stw	r5,-4(fp)
  /* Wait until the device is ready for a character */
  while((ALT_LOG_PRINT_REG_RD(base) & ALT_LOG_PRINT_MSK) == 0)
8113690c:	0001883a 	nop
81136910:	e0bfff17 	ldw	r2,-4(fp)
81136914:	10800104 	addi	r2,r2,4
81136918:	10800037 	ldwio	r2,0(r2)
8113691c:	10bfffec 	andhi	r2,r2,65535
81136920:	103ffb26 	beq	r2,zero,81136910 <__reset+0xfb116910>
    ;
  /* And pop the character into the register */
  ALT_LOG_PRINT_TXDATA_WR(base,c);
81136924:	e0bfff17 	ldw	r2,-4(fp)
81136928:	e0fffe17 	ldw	r3,-8(fp)
8113692c:	10c00035 	stwio	r3,0(r2)
}
81136930:	0001883a 	nop
81136934:	e037883a 	mov	sp,fp
81136938:	df000017 	ldw	fp,0(sp)
8113693c:	dec00104 	addi	sp,sp,4
81136940:	f800283a 	ret

81136944 <alt_log_repchar>:


/* Called by alt_log_private_printf to print out characters repeatedly */
void alt_log_repchar(char c,int r,int base)
{
81136944:	defffb04 	addi	sp,sp,-20
81136948:	de00012e 	bgeu	sp,et,81136950 <alt_log_repchar+0xc>
8113694c:	003b68fa 	trap	3
81136950:	dfc00415 	stw	ra,16(sp)
81136954:	df000315 	stw	fp,12(sp)
81136958:	df000304 	addi	fp,sp,12
8113695c:	2005883a 	mov	r2,r4
81136960:	e17ffe15 	stw	r5,-8(fp)
81136964:	e1bfff15 	stw	r6,-4(fp)
81136968:	e0bffd05 	stb	r2,-12(fp)
  while(r-- > 0)
8113696c:	00000506 	br	81136984 <alt_log_repchar+0x40>
    alt_log_txchar(c,(char*) base);
81136970:	e0bffd07 	ldb	r2,-12(fp)
81136974:	e0ffff17 	ldw	r3,-4(fp)
81136978:	180b883a 	mov	r5,r3
8113697c:	1009883a 	mov	r4,r2
81136980:	11368f00 	call	811368f0 <alt_log_txchar>


/* Called by alt_log_private_printf to print out characters repeatedly */
void alt_log_repchar(char c,int r,int base)
{
  while(r-- > 0)
81136984:	e0bffe17 	ldw	r2,-8(fp)
81136988:	10ffffc4 	addi	r3,r2,-1
8113698c:	e0fffe15 	stw	r3,-8(fp)
81136990:	00bff716 	blt	zero,r2,81136970 <__reset+0xfb116970>
    alt_log_txchar(c,(char*) base);
}
81136994:	0001883a 	nop
81136998:	e037883a 	mov	sp,fp
8113699c:	dfc00117 	ldw	ra,4(sp)
811369a0:	df000017 	ldw	fp,0(sp)
811369a4:	dec00204 	addi	sp,sp,8
811369a8:	f800283a 	ret

811369ac <alt_log_private_printf>:


/* Stripped down printf function */
void alt_log_private_printf(const char *fmt,int base,va_list args)
  {
811369ac:	deffe904 	addi	sp,sp,-92
811369b0:	de00012e 	bgeu	sp,et,811369b8 <alt_log_private_printf+0xc>
811369b4:	003b68fa 	trap	3
811369b8:	dfc01615 	stw	ra,88(sp)
811369bc:	df001515 	stw	fp,84(sp)
811369c0:	dc001415 	stw	r16,80(sp)
811369c4:	df001504 	addi	fp,sp,84
811369c8:	e13ffc15 	stw	r4,-16(fp)
811369cc:	e17ffd15 	stw	r5,-12(fp)
811369d0:	e1bffe15 	stw	r6,-8(fp)
  const char *w;
  char c;
  int state;
  int fmtLeadingZero = 0; /* init these all to 0 for -W warnings. */
811369d4:	e03fed15 	stw	zero,-76(fp)
  int fmtLong = 0;
811369d8:	e03fee15 	stw	zero,-72(fp)
  int fmtBeforeDecimal = 0;
811369dc:	e03fef15 	stw	zero,-68(fp)
  int fmtAfterDecimal = 0;
811369e0:	e03ff015 	stw	zero,-64(fp)
  int fmtBase = 0;
811369e4:	e03ff115 	stw	zero,-60(fp)
  int fmtSigned = 0;
811369e8:	e03ff215 	stw	zero,-56(fp)
  int fmtCase = 0; /* For hex format, if 1, A-F, else a-f. */
811369ec:	e03ff315 	stw	zero,-52(fp)

  w = fmt;
811369f0:	e0bffc17 	ldw	r2,-16(fp)
811369f4:	e0bfeb15 	stw	r2,-84(fp)
  state = pfState_chars;
811369f8:	e03fec15 	stw	zero,-80(fp)

  while(0 != (c = *w++))
811369fc:	00014b06 	br	81136f2c <alt_log_private_printf+0x580>
    {
    switch(state)
81136a00:	e0bfec17 	ldw	r2,-80(fp)
81136a04:	10c00060 	cmpeqi	r3,r2,1
81136a08:	18001b1e 	bne	r3,zero,81136a78 <alt_log_private_printf+0xcc>
81136a0c:	10c000a0 	cmpeqi	r3,r2,2
81136a10:	18002d1e 	bne	r3,zero,81136ac8 <alt_log_private_printf+0x11c>
81136a14:	10000126 	beq	r2,zero,81136a1c <alt_log_private_printf+0x70>
81136a18:	00014406 	br	81136f2c <alt_log_private_printf+0x580>
      {
      case pfState_chars:
        if(c == '%')
81136a1c:	e0bffb07 	ldb	r2,-20(fp)
81136a20:	10800958 	cmpnei	r2,r2,37
81136a24:	10000e1e 	bne	r2,zero,81136a60 <alt_log_private_printf+0xb4>
        {
          fmtLeadingZero = 0;
81136a28:	e03fed15 	stw	zero,-76(fp)
          fmtLong = 0;
81136a2c:	e03fee15 	stw	zero,-72(fp)
          fmtBase = 10;
81136a30:	00800284 	movi	r2,10
81136a34:	e0bff115 	stw	r2,-60(fp)
          fmtSigned = 1;
81136a38:	00800044 	movi	r2,1
81136a3c:	e0bff215 	stw	r2,-56(fp)
          fmtCase = 0; /* Only %X sets this. */
81136a40:	e03ff315 	stw	zero,-52(fp)
          fmtBeforeDecimal = -1;
81136a44:	00bfffc4 	movi	r2,-1
81136a48:	e0bfef15 	stw	r2,-68(fp)
          fmtAfterDecimal = -1;
81136a4c:	00bfffc4 	movi	r2,-1
81136a50:	e0bff015 	stw	r2,-64(fp)
          state = pfState_firstFmtChar;
81136a54:	00800044 	movi	r2,1
81136a58:	e0bfec15 	stw	r2,-80(fp)
81136a5c:	00013306 	br	81136f2c <alt_log_private_printf+0x580>
        }
        else
        {
          alt_log_txchar(c,(char*)base);
81136a60:	e0bffb07 	ldb	r2,-20(fp)
81136a64:	e0fffd17 	ldw	r3,-12(fp)
81136a68:	180b883a 	mov	r5,r3
81136a6c:	1009883a 	mov	r4,r2
81136a70:	11368f00 	call	811368f0 <alt_log_txchar>
        }
        break;
81136a74:	00012d06 	br	81136f2c <alt_log_private_printf+0x580>

      case pfState_firstFmtChar:
        if(c == '0')
81136a78:	e0bffb07 	ldb	r2,-20(fp)
81136a7c:	10800c18 	cmpnei	r2,r2,48
81136a80:	1000051e 	bne	r2,zero,81136a98 <alt_log_private_printf+0xec>
        {
          fmtLeadingZero = 1;
81136a84:	00800044 	movi	r2,1
81136a88:	e0bfed15 	stw	r2,-76(fp)
          state = pfState_otherFmtChar;
81136a8c:	00800084 	movi	r2,2
81136a90:	e0bfec15 	stw	r2,-80(fp)
81136a94:	00012506 	br	81136f2c <alt_log_private_printf+0x580>
        }
        else if(c == '%')
81136a98:	e0bffb07 	ldb	r2,-20(fp)
81136a9c:	10800958 	cmpnei	r2,r2,37
81136aa0:	1000071e 	bne	r2,zero,81136ac0 <alt_log_private_printf+0x114>
        {
          alt_log_txchar(c,(char*)base);
81136aa4:	e0bffb07 	ldb	r2,-20(fp)
81136aa8:	e0fffd17 	ldw	r3,-12(fp)
81136aac:	180b883a 	mov	r5,r3
81136ab0:	1009883a 	mov	r4,r2
81136ab4:	11368f00 	call	811368f0 <alt_log_txchar>
          state = pfState_chars;
81136ab8:	e03fec15 	stw	zero,-80(fp)
81136abc:	00011b06 	br	81136f2c <alt_log_private_printf+0x580>
        }
        else
        {
          state = pfState_otherFmtChar;
81136ac0:	00800084 	movi	r2,2
81136ac4:	e0bfec15 	stw	r2,-80(fp)
        }
        break;

      case pfState_otherFmtChar:
otherFmtChar:
        if(c == '.')
81136ac8:	e0bffb07 	ldb	r2,-20(fp)
81136acc:	10800b98 	cmpnei	r2,r2,46
81136ad0:	1000021e 	bne	r2,zero,81136adc <alt_log_private_printf+0x130>
        {
          fmtAfterDecimal = 0;
81136ad4:	e03ff015 	stw	zero,-64(fp)
81136ad8:	00011306 	br	81136f28 <alt_log_private_printf+0x57c>
        }
        else if('0' <= c && c <= '9')
81136adc:	e0bffb07 	ldb	r2,-20(fp)
81136ae0:	10800c10 	cmplti	r2,r2,48
81136ae4:	10001a1e 	bne	r2,zero,81136b50 <alt_log_private_printf+0x1a4>
81136ae8:	e0bffb07 	ldb	r2,-20(fp)
81136aec:	10800e88 	cmpgei	r2,r2,58
81136af0:	1000171e 	bne	r2,zero,81136b50 <alt_log_private_printf+0x1a4>
        {
          c -= '0';
81136af4:	e0bffb03 	ldbu	r2,-20(fp)
81136af8:	10bff404 	addi	r2,r2,-48
81136afc:	e0bffb05 	stb	r2,-20(fp)
          if(fmtAfterDecimal < 0)     /* still before decimal */
81136b00:	e0bff017 	ldw	r2,-64(fp)
81136b04:	10000c0e 	bge	r2,zero,81136b38 <alt_log_private_printf+0x18c>
          {
            if(fmtBeforeDecimal < 0)
81136b08:	e0bfef17 	ldw	r2,-68(fp)
81136b0c:	1000020e 	bge	r2,zero,81136b18 <alt_log_private_printf+0x16c>
            {
              fmtBeforeDecimal = 0;
81136b10:	e03fef15 	stw	zero,-68(fp)
81136b14:	00000306 	br	81136b24 <alt_log_private_printf+0x178>
            }
            else
            {
              fmtBeforeDecimal *= 10;
81136b18:	e0bfef17 	ldw	r2,-68(fp)
81136b1c:	108002a4 	muli	r2,r2,10
81136b20:	e0bfef15 	stw	r2,-68(fp)
            }
            fmtBeforeDecimal += c;
81136b24:	e0bffb07 	ldb	r2,-20(fp)
81136b28:	e0ffef17 	ldw	r3,-68(fp)
81136b2c:	1885883a 	add	r2,r3,r2
81136b30:	e0bfef15 	stw	r2,-68(fp)
          fmtAfterDecimal = 0;
        }
        else if('0' <= c && c <= '9')
        {
          c -= '0';
          if(fmtAfterDecimal < 0)     /* still before decimal */
81136b34:	0000fc06 	br	81136f28 <alt_log_private_printf+0x57c>
            }
            fmtBeforeDecimal += c;
          }
          else
          {
            fmtAfterDecimal = (fmtAfterDecimal * 10) + c;
81136b38:	e0bff017 	ldw	r2,-64(fp)
81136b3c:	10c002a4 	muli	r3,r2,10
81136b40:	e0bffb07 	ldb	r2,-20(fp)
81136b44:	1885883a 	add	r2,r3,r2
81136b48:	e0bff015 	stw	r2,-64(fp)
          fmtAfterDecimal = 0;
        }
        else if('0' <= c && c <= '9')
        {
          c -= '0';
          if(fmtAfterDecimal < 0)     /* still before decimal */
81136b4c:	0000f606 	br	81136f28 <alt_log_private_printf+0x57c>
          else
          {
            fmtAfterDecimal = (fmtAfterDecimal * 10) + c;
          }
        }
        else if(c == 'l')
81136b50:	e0bffb07 	ldb	r2,-20(fp)
81136b54:	10801b18 	cmpnei	r2,r2,108
81136b58:	1000031e 	bne	r2,zero,81136b68 <alt_log_private_printf+0x1bc>
        {
          fmtLong = 1;
81136b5c:	00800044 	movi	r2,1
81136b60:	e0bfee15 	stw	r2,-72(fp)
81136b64:	0000f006 	br	81136f28 <alt_log_private_printf+0x57c>
        }
        else                  /* we're up to the letter which determines type */
        {
          switch(c)
81136b68:	e0bffb07 	ldb	r2,-20(fp)
81136b6c:	10bfea04 	addi	r2,r2,-88
81136b70:	10c00868 	cmpgeui	r3,r2,33
81136b74:	1800eb1e 	bne	r3,zero,81136f24 <alt_log_private_printf+0x578>
81136b78:	100690ba 	slli	r3,r2,2
81136b7c:	00a044f4 	movhi	r2,33043
81136b80:	109ae404 	addi	r2,r2,27536
81136b84:	1885883a 	add	r2,r3,r2
81136b88:	10800017 	ldw	r2,0(r2)
81136b8c:	1000683a 	jmp	r2
81136b90:	81136e50 	cmplti	r4,r16,19897
81136b94:	81136f24 	muli	r4,r16,19900
81136b98:	81136f24 	muli	r4,r16,19900
81136b9c:	81136f24 	muli	r4,r16,19900
81136ba0:	81136f24 	muli	r4,r16,19900
81136ba4:	81136f24 	muli	r4,r16,19900
81136ba8:	81136f24 	muli	r4,r16,19900
81136bac:	81136f24 	muli	r4,r16,19900
81136bb0:	81136f24 	muli	r4,r16,19900
81136bb4:	81136f24 	muli	r4,r16,19900
81136bb8:	81136f24 	muli	r4,r16,19900
81136bbc:	81136e68 	cmpgeui	r4,r16,19897
81136bc0:	81136c14 	ori	r4,r16,19888
81136bc4:	81136f24 	muli	r4,r16,19900
81136bc8:	81136f24 	muli	r4,r16,19900
81136bcc:	81136f24 	muli	r4,r16,19900
81136bd0:	81136f24 	muli	r4,r16,19900
81136bd4:	81136c14 	ori	r4,r16,19888
81136bd8:	81136f24 	muli	r4,r16,19900
81136bdc:	81136f24 	muli	r4,r16,19900
81136be0:	81136f24 	muli	r4,r16,19900
81136be4:	81136f24 	muli	r4,r16,19900
81136be8:	81136f24 	muli	r4,r16,19900
81136bec:	81136e30 	cmpltui	r4,r16,19896
81136bf0:	81136f24 	muli	r4,r16,19900
81136bf4:	81136f24 	muli	r4,r16,19900
81136bf8:	81136f24 	muli	r4,r16,19900
81136bfc:	81136ea4 	muli	r4,r16,19898
81136c00:	81136f24 	muli	r4,r16,19900
81136c04:	81136e28 	cmpgeui	r4,r16,19896
81136c08:	81136f24 	muli	r4,r16,19900
81136c0c:	81136f24 	muli	r4,r16,19900
81136c10:	81136e40 	call	881136e4 <__reset+0x20f36e4>
                unsigned long vShrink;  /* used to count digits */
                int sign;
                int digitCount;

                /* Get the value */
                if(fmtLong)
81136c14:	e0bfee17 	ldw	r2,-72(fp)
81136c18:	10000e26 	beq	r2,zero,81136c54 <alt_log_private_printf+0x2a8>
                {
                  if (fmtSigned)
81136c1c:	e0bff217 	ldw	r2,-56(fp)
81136c20:	10000626 	beq	r2,zero,81136c3c <alt_log_private_printf+0x290>
                  {
                    v = va_arg(args,long);
81136c24:	e0bffe17 	ldw	r2,-8(fp)
81136c28:	10c00104 	addi	r3,r2,4
81136c2c:	e0fffe15 	stw	r3,-8(fp)
81136c30:	10800017 	ldw	r2,0(r2)
81136c34:	e0bff415 	stw	r2,-48(fp)
81136c38:	00001306 	br	81136c88 <alt_log_private_printf+0x2dc>
                  }
                  else
                  {
                    v = va_arg(args,unsigned long);
81136c3c:	e0bffe17 	ldw	r2,-8(fp)
81136c40:	10c00104 	addi	r3,r2,4
81136c44:	e0fffe15 	stw	r3,-8(fp)
81136c48:	10800017 	ldw	r2,0(r2)
81136c4c:	e0bff415 	stw	r2,-48(fp)
81136c50:	00000d06 	br	81136c88 <alt_log_private_printf+0x2dc>
                  }
                }
                else
                {
                  if (fmtSigned)
81136c54:	e0bff217 	ldw	r2,-56(fp)
81136c58:	10000626 	beq	r2,zero,81136c74 <alt_log_private_printf+0x2c8>
                  {
                    v = va_arg(args,int);
81136c5c:	e0bffe17 	ldw	r2,-8(fp)
81136c60:	10c00104 	addi	r3,r2,4
81136c64:	e0fffe15 	stw	r3,-8(fp)
81136c68:	10800017 	ldw	r2,0(r2)
81136c6c:	e0bff415 	stw	r2,-48(fp)
81136c70:	00000506 	br	81136c88 <alt_log_private_printf+0x2dc>
                  }
                  else
                  {
                    v = va_arg(args,unsigned int);
81136c74:	e0bffe17 	ldw	r2,-8(fp)
81136c78:	10c00104 	addi	r3,r2,4
81136c7c:	e0fffe15 	stw	r3,-8(fp)
81136c80:	10800017 	ldw	r2,0(r2)
81136c84:	e0bff415 	stw	r2,-48(fp)
                  }
                }

                /* Strip sign */
                sign = 0;
81136c88:	e03ff715 	stw	zero,-36(fp)
                  /* (assumes sign bit is #31) */
                if( fmtSigned && (v & (0x80000000)) )
81136c8c:	e0bff217 	ldw	r2,-56(fp)
81136c90:	10000726 	beq	r2,zero,81136cb0 <alt_log_private_printf+0x304>
81136c94:	e0bff417 	ldw	r2,-48(fp)
81136c98:	1000050e 	bge	r2,zero,81136cb0 <alt_log_private_printf+0x304>
                  {
                  v = ~v + 1;
81136c9c:	e0bff417 	ldw	r2,-48(fp)
81136ca0:	0085c83a 	sub	r2,zero,r2
81136ca4:	e0bff415 	stw	r2,-48(fp)
                  sign = 1;
81136ca8:	00800044 	movi	r2,1
81136cac:	e0bff715 	stw	r2,-36(fp)
                  }

                /* Count digits, and get largest place value */
                vShrink = v;
81136cb0:	e0bff417 	ldw	r2,-48(fp)
81136cb4:	e0bff615 	stw	r2,-40(fp)
                p = 1;
81136cb8:	00800044 	movi	r2,1
81136cbc:	e0bff515 	stw	r2,-44(fp)
                digitCount = 1;
81136cc0:	00800044 	movi	r2,1
81136cc4:	e0bff815 	stw	r2,-32(fp)
                while( (vShrink = vShrink / fmtBase) > 0 )
81136cc8:	00000706 	br	81136ce8 <alt_log_private_printf+0x33c>
                  {
                  digitCount++;
81136ccc:	e0bff817 	ldw	r2,-32(fp)
81136cd0:	10800044 	addi	r2,r2,1
81136cd4:	e0bff815 	stw	r2,-32(fp)
                  p *= fmtBase;
81136cd8:	e0bff117 	ldw	r2,-60(fp)
81136cdc:	e0fff517 	ldw	r3,-44(fp)
81136ce0:	1885383a 	mul	r2,r3,r2
81136ce4:	e0bff515 	stw	r2,-44(fp)

                /* Count digits, and get largest place value */
                vShrink = v;
                p = 1;
                digitCount = 1;
                while( (vShrink = vShrink / fmtBase) > 0 )
81136ce8:	e0bff117 	ldw	r2,-60(fp)
81136cec:	e0fff617 	ldw	r3,-40(fp)
81136cf0:	1885203a 	divu	r2,r3,r2
81136cf4:	e0bff615 	stw	r2,-40(fp)
81136cf8:	e0bff617 	ldw	r2,-40(fp)
81136cfc:	103ff31e 	bne	r2,zero,81136ccc <__reset+0xfb116ccc>
                  digitCount++;
                  p *= fmtBase;
                  }

                /* Print leading characters & sign */
                fmtBeforeDecimal -= digitCount;
81136d00:	e0ffef17 	ldw	r3,-68(fp)
81136d04:	e0bff817 	ldw	r2,-32(fp)
81136d08:	1885c83a 	sub	r2,r3,r2
81136d0c:	e0bfef15 	stw	r2,-68(fp)
                if(fmtLeadingZero)
81136d10:	e0bfed17 	ldw	r2,-76(fp)
81136d14:	10000e26 	beq	r2,zero,81136d50 <alt_log_private_printf+0x3a4>
                  {
                  if(sign)
81136d18:	e0bff717 	ldw	r2,-36(fp)
81136d1c:	10000726 	beq	r2,zero,81136d3c <alt_log_private_printf+0x390>
                    {
                    alt_log_txchar('-',(char*)base);
81136d20:	e0bffd17 	ldw	r2,-12(fp)
81136d24:	100b883a 	mov	r5,r2
81136d28:	01000b44 	movi	r4,45
81136d2c:	11368f00 	call	811368f0 <alt_log_txchar>
                    fmtBeforeDecimal--;
81136d30:	e0bfef17 	ldw	r2,-68(fp)
81136d34:	10bfffc4 	addi	r2,r2,-1
81136d38:	e0bfef15 	stw	r2,-68(fp)
                    }
                  alt_log_repchar('0',fmtBeforeDecimal,base);
81136d3c:	e1bffd17 	ldw	r6,-12(fp)
81136d40:	e17fef17 	ldw	r5,-68(fp)
81136d44:	01000c04 	movi	r4,48
81136d48:	11369440 	call	81136944 <alt_log_repchar>
81136d4c:	00003206 	br	81136e18 <alt_log_private_printf+0x46c>
                  }
                else
                  {
                    if(sign)
81136d50:	e0bff717 	ldw	r2,-36(fp)
81136d54:	10000326 	beq	r2,zero,81136d64 <alt_log_private_printf+0x3b8>
                    {
                      fmtBeforeDecimal--;
81136d58:	e0bfef17 	ldw	r2,-68(fp)
81136d5c:	10bfffc4 	addi	r2,r2,-1
81136d60:	e0bfef15 	stw	r2,-68(fp)
                    }
                    alt_log_repchar(' ',fmtBeforeDecimal,base);
81136d64:	e1bffd17 	ldw	r6,-12(fp)
81136d68:	e17fef17 	ldw	r5,-68(fp)
81136d6c:	01000804 	movi	r4,32
81136d70:	11369440 	call	81136944 <alt_log_repchar>
                    if(sign)
81136d74:	e0bff717 	ldw	r2,-36(fp)
81136d78:	10002726 	beq	r2,zero,81136e18 <alt_log_private_printf+0x46c>
                    {
                      alt_log_txchar('-',(char*)base);
81136d7c:	e0bffd17 	ldw	r2,-12(fp)
81136d80:	100b883a 	mov	r5,r2
81136d84:	01000b44 	movi	r4,45
81136d88:	11368f00 	call	811368f0 <alt_log_txchar>
                    }
                  }

                /* Print numbery parts */
                while(p)
81136d8c:	00002206 	br	81136e18 <alt_log_private_printf+0x46c>
                  {
                  unsigned char d;

                  d = v / p;
81136d90:	e0fff417 	ldw	r3,-48(fp)
81136d94:	e0bff517 	ldw	r2,-44(fp)
81136d98:	1885203a 	divu	r2,r3,r2
81136d9c:	e0bff905 	stb	r2,-28(fp)
                  d += '0';
81136da0:	e0bff903 	ldbu	r2,-28(fp)
81136da4:	10800c04 	addi	r2,r2,48
81136da8:	e0bff905 	stb	r2,-28(fp)
                  if(d > '9')
81136dac:	e0bff903 	ldbu	r2,-28(fp)
81136db0:	10800eb0 	cmpltui	r2,r2,58
81136db4:	1000081e 	bne	r2,zero,81136dd8 <alt_log_private_printf+0x42c>
                  {
                    d += (fmtCase ? 'A' : 'a') - '0' - 10;
81136db8:	e0bff317 	ldw	r2,-52(fp)
81136dbc:	10000226 	beq	r2,zero,81136dc8 <alt_log_private_printf+0x41c>
81136dc0:	008001c4 	movi	r2,7
81136dc4:	00000106 	br	81136dcc <alt_log_private_printf+0x420>
81136dc8:	008009c4 	movi	r2,39
81136dcc:	e0fff903 	ldbu	r3,-28(fp)
81136dd0:	10c5883a 	add	r2,r2,r3
81136dd4:	e0bff905 	stb	r2,-28(fp)
                  }
                  alt_log_txchar(d,(char*)base);
81136dd8:	e0bff903 	ldbu	r2,-28(fp)
81136ddc:	e0fffd17 	ldw	r3,-12(fp)
81136de0:	180b883a 	mov	r5,r3
81136de4:	1009883a 	mov	r4,r2
81136de8:	11368f00 	call	811368f0 <alt_log_txchar>

                  v = v % p;
81136dec:	e0bff417 	ldw	r2,-48(fp)
81136df0:	e0fff517 	ldw	r3,-44(fp)
81136df4:	10c9203a 	divu	r4,r2,r3
81136df8:	e0fff517 	ldw	r3,-44(fp)
81136dfc:	20c7383a 	mul	r3,r4,r3
81136e00:	10c5c83a 	sub	r2,r2,r3
81136e04:	e0bff415 	stw	r2,-48(fp)
                  p = p / fmtBase;
81136e08:	e0bff117 	ldw	r2,-60(fp)
81136e0c:	e0fff517 	ldw	r3,-44(fp)
81136e10:	1885203a 	divu	r2,r3,r2
81136e14:	e0bff515 	stw	r2,-44(fp)
                      alt_log_txchar('-',(char*)base);
                    }
                  }

                /* Print numbery parts */
                while(p)
81136e18:	e0bff517 	ldw	r2,-44(fp)
81136e1c:	103fdc1e 	bne	r2,zero,81136d90 <__reset+0xfb116d90>
                  v = v % p;
                  p = p / fmtBase;
                  }
                }

              state = pfState_chars;
81136e20:	e03fec15 	stw	zero,-80(fp)
              break;
81136e24:	00003f06 	br	81136f24 <alt_log_private_printf+0x578>

            case 'u':
              fmtSigned = 0;
81136e28:	e03ff215 	stw	zero,-56(fp)
              goto doIntegerPrint;
81136e2c:	003f7906 	br	81136c14 <__reset+0xfb116c14>
            case 'o':
              fmtSigned = 0;
81136e30:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 8;
81136e34:	00800204 	movi	r2,8
81136e38:	e0bff115 	stw	r2,-60(fp)
              goto doIntegerPrint;
81136e3c:	003f7506 	br	81136c14 <__reset+0xfb116c14>
            case 'x':
              fmtSigned = 0;
81136e40:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 16;
81136e44:	00800404 	movi	r2,16
81136e48:	e0bff115 	stw	r2,-60(fp)
              goto doIntegerPrint;
81136e4c:	003f7106 	br	81136c14 <__reset+0xfb116c14>
            case 'X':
              fmtSigned = 0;
81136e50:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 16;
81136e54:	00800404 	movi	r2,16
81136e58:	e0bff115 	stw	r2,-60(fp)
              fmtCase = 1;
81136e5c:	00800044 	movi	r2,1
81136e60:	e0bff315 	stw	r2,-52(fp)
              goto doIntegerPrint;
81136e64:	003f6b06 	br	81136c14 <__reset+0xfb116c14>

            case 'c':
              alt_log_repchar(' ',fmtBeforeDecimal-1,base);
81136e68:	e0bfef17 	ldw	r2,-68(fp)
81136e6c:	10bfffc4 	addi	r2,r2,-1
81136e70:	e1bffd17 	ldw	r6,-12(fp)
81136e74:	100b883a 	mov	r5,r2
81136e78:	01000804 	movi	r4,32
81136e7c:	11369440 	call	81136944 <alt_log_repchar>
              alt_log_txchar(va_arg(args,int),(char*)base);
81136e80:	e0bffe17 	ldw	r2,-8(fp)
81136e84:	10c00104 	addi	r3,r2,4
81136e88:	e0fffe15 	stw	r3,-8(fp)
81136e8c:	10800017 	ldw	r2,0(r2)
81136e90:	e0fffd17 	ldw	r3,-12(fp)
81136e94:	180b883a 	mov	r5,r3
81136e98:	1009883a 	mov	r4,r2
81136e9c:	11368f00 	call	811368f0 <alt_log_txchar>
              break;
81136ea0:	00002006 	br	81136f24 <alt_log_private_printf+0x578>

            case 's':
                {
                char *s;

                s = va_arg(args,char *);
81136ea4:	e0bffe17 	ldw	r2,-8(fp)
81136ea8:	10c00104 	addi	r3,r2,4
81136eac:	e0fffe15 	stw	r3,-8(fp)
81136eb0:	10800017 	ldw	r2,0(r2)
81136eb4:	e0bffa15 	stw	r2,-24(fp)
                alt_log_repchar(' ',fmtBeforeDecimal-strlen(s),base);
81136eb8:	e43fef17 	ldw	r16,-68(fp)
81136ebc:	e13ffa17 	ldw	r4,-24(fp)
81136ec0:	11231840 	call	81123184 <strlen>
81136ec4:	8085c83a 	sub	r2,r16,r2
81136ec8:	e1bffd17 	ldw	r6,-12(fp)
81136ecc:	100b883a 	mov	r5,r2
81136ed0:	01000804 	movi	r4,32
81136ed4:	11369440 	call	81136944 <alt_log_repchar>

                while(*s)
81136ed8:	00000b06 	br	81136f08 <alt_log_private_printf+0x55c>
                  alt_log_txchar(*s++,(char*)base);
81136edc:	e0bffa17 	ldw	r2,-24(fp)
81136ee0:	10c00044 	addi	r3,r2,1
81136ee4:	e0fffa15 	stw	r3,-24(fp)
81136ee8:	10800003 	ldbu	r2,0(r2)
81136eec:	10803fcc 	andi	r2,r2,255
81136ef0:	1080201c 	xori	r2,r2,128
81136ef4:	10bfe004 	addi	r2,r2,-128
81136ef8:	e0fffd17 	ldw	r3,-12(fp)
81136efc:	180b883a 	mov	r5,r3
81136f00:	1009883a 	mov	r4,r2
81136f04:	11368f00 	call	811368f0 <alt_log_txchar>
                char *s;

                s = va_arg(args,char *);
                alt_log_repchar(' ',fmtBeforeDecimal-strlen(s),base);

                while(*s)
81136f08:	e0bffa17 	ldw	r2,-24(fp)
81136f0c:	10800003 	ldbu	r2,0(r2)
81136f10:	10803fcc 	andi	r2,r2,255
81136f14:	1080201c 	xori	r2,r2,128
81136f18:	10bfe004 	addi	r2,r2,-128
81136f1c:	103fef1e 	bne	r2,zero,81136edc <__reset+0xfb116edc>
                  alt_log_txchar(*s++,(char*)base);
                }
              break;
81136f20:	0001883a 	nop
            } /* switch last letter of fmt */
          state=pfState_chars;
81136f24:	e03fec15 	stw	zero,-80(fp)
          }
        break;
81136f28:	0001883a 	nop
  int fmtCase = 0; /* For hex format, if 1, A-F, else a-f. */

  w = fmt;
  state = pfState_chars;

  while(0 != (c = *w++))
81136f2c:	e0bfeb17 	ldw	r2,-84(fp)
81136f30:	10c00044 	addi	r3,r2,1
81136f34:	e0ffeb15 	stw	r3,-84(fp)
81136f38:	10800003 	ldbu	r2,0(r2)
81136f3c:	e0bffb05 	stb	r2,-20(fp)
81136f40:	e0bffb07 	ldb	r2,-20(fp)
81136f44:	103eae1e 	bne	r2,zero,81136a00 <__reset+0xfb116a00>
          state=pfState_chars;
          }
        break;
      } /* switch */
    } /* while chars left */
  } /* printf */
81136f48:	0001883a 	nop
81136f4c:	e6ffff04 	addi	sp,fp,-4
81136f50:	dfc00217 	ldw	ra,8(sp)
81136f54:	df000117 	ldw	fp,4(sp)
81136f58:	dc000017 	ldw	r16,0(sp)
81136f5c:	dec00304 	addi	sp,sp,12
81136f60:	f800283a 	ret

81136f64 <alt_log_printf_proc>:

/* Main logging printf function */
int alt_log_printf_proc(const char *fmt, ... )
{
81136f64:	defff904 	addi	sp,sp,-28
81136f68:	de00012e 	bgeu	sp,et,81136f70 <alt_log_printf_proc+0xc>
81136f6c:	003b68fa 	trap	3
81136f70:	dfc00315 	stw	ra,12(sp)
81136f74:	df000215 	stw	fp,8(sp)
81136f78:	df000204 	addi	fp,sp,8
81136f7c:	e13fff15 	stw	r4,-4(fp)
81136f80:	e1400215 	stw	r5,8(fp)
81136f84:	e1800315 	stw	r6,12(fp)
81136f88:	e1c00415 	stw	r7,16(fp)
    va_list args;

    va_start (args, fmt);
81136f8c:	e0800204 	addi	r2,fp,8
81136f90:	e0bffe15 	stw	r2,-8(fp)
    alt_log_private_printf(fmt,ALT_LOG_PORT_BASE,args);
81136f94:	e0bffe17 	ldw	r2,-8(fp)
81136f98:	100d883a 	mov	r6,r2
81136f9c:	01604834 	movhi	r5,33056
81136fa0:	294c2404 	addi	r5,r5,12432
81136fa4:	e13fff17 	ldw	r4,-4(fp)
81136fa8:	11369ac0 	call	811369ac <alt_log_private_printf>
    return (0);
81136fac:	0005883a 	mov	r2,zero
}
81136fb0:	e037883a 	mov	sp,fp
81136fb4:	dfc00117 	ldw	ra,4(sp)
81136fb8:	df000017 	ldw	fp,0(sp)
81136fbc:	dec00504 	addi	sp,sp,20
81136fc0:	f800283a 	ret

81136fc4 <altera_avalon_jtag_uart_report_log>:
 * This function, when turned on, prints out the status
 * of the JTAG UART Control register, every ALT_LOG_JTAG_UART_TICKS.
 * If the flag is off, the alarm should never be registered, and this
 * function should never run */
alt_u32 altera_avalon_jtag_uart_report_log(void * context)
{
81136fc4:	defff904 	addi	sp,sp,-28
81136fc8:	de00012e 	bgeu	sp,et,81136fd0 <altera_avalon_jtag_uart_report_log+0xc>
81136fcc:	003b68fa 	trap	3
81136fd0:	dfc00615 	stw	ra,24(sp)
81136fd4:	df000515 	stw	fp,20(sp)
81136fd8:	dc400415 	stw	r17,16(sp)
81136fdc:	dc000315 	stw	r16,12(sp)
81136fe0:	df000504 	addi	fp,sp,20
81136fe4:	e13ffd15 	stw	r4,-12(fp)
    if (alt_log_jtag_uart_alarm_on_flag) {
81136fe8:	d0a08183 	ldbu	r2,-32250(gp)
81136fec:	10803fcc 	andi	r2,r2,255
81136ff0:	10001426 	beq	r2,zero,81137044 <altera_avalon_jtag_uart_report_log+0x80>
    altera_avalon_jtag_uart_state* dev = (altera_avalon_jtag_uart_state*) context;
81136ff4:	e0bffd17 	ldw	r2,-12(fp)
81136ff8:	e0bffb15 	stw	r2,-20(fp)
        const char* header="JTAG Alarm:";
81136ffc:	00a04574 	movhi	r2,33045
81137000:	10841d04 	addi	r2,r2,4212
81137004:	e0bffc15 	stw	r2,-16(fp)
        alt_log_jtag_uart_print_control_reg(dev, dev->base, header);
81137008:	e0bffb17 	ldw	r2,-20(fp)
8113700c:	10800017 	ldw	r2,0(r2)
81137010:	e1bffc17 	ldw	r6,-16(fp)
81137014:	100b883a 	mov	r5,r2
81137018:	e13ffb17 	ldw	r4,-20(fp)
8113701c:	11370640 	call	81137064 <alt_log_jtag_uart_print_control_reg>
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81137020:	d0e08817 	ldw	r3,-32224(gp)
        return ALT_LOG_JTAG_UART_TICKS;
81137024:	00b33374 	movhi	r2,52429
81137028:	10b33344 	addi	r2,r2,-13107
8113702c:	1888383a 	mulxuu	r4,r3,r2
81137030:	1885383a 	mul	r2,r3,r2
81137034:	1021883a 	mov	r16,r2
81137038:	2023883a 	mov	r17,r4
8113703c:	8804d0fa 	srli	r2,r17,3
81137040:	00000106 	br	81137048 <altera_avalon_jtag_uart_report_log+0x84>
    }
    else 
    {  
        /* If flag is not on, return 0 to disable future alarms.
        * Should never be here, alarm should not be enabled at all. */
        return 0;
81137044:	0005883a 	mov	r2,zero
    }
}
81137048:	e6fffe04 	addi	sp,fp,-8
8113704c:	dfc00317 	ldw	ra,12(sp)
81137050:	df000217 	ldw	fp,8(sp)
81137054:	dc400117 	ldw	r17,4(sp)
81137058:	dc000017 	ldw	r16,0(sp)
8113705c:	dec00404 	addi	sp,sp,16
81137060:	f800283a 	ret

81137064 <alt_log_jtag_uart_print_control_reg>:

void alt_log_jtag_uart_print_control_reg(altera_avalon_jtag_uart_state* dev, int base, const char* header)
{
81137064:	deffef04 	addi	sp,sp,-68
81137068:	de00012e 	bgeu	sp,et,81137070 <alt_log_jtag_uart_print_control_reg+0xc>
8113706c:	003b68fa 	trap	3
81137070:	dfc01015 	stw	ra,64(sp)
81137074:	df000f15 	stw	fp,60(sp)
81137078:	df000f04 	addi	fp,sp,60
8113707c:	e13ffd15 	stw	r4,-12(fp)
81137080:	e17ffe15 	stw	r5,-8(fp)
81137084:	e1bfff15 	stw	r6,-4(fp)
     unsigned int control, space, ac, wi, ri, we, re;
     control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
81137088:	e0bffe17 	ldw	r2,-8(fp)
8113708c:	10800104 	addi	r2,r2,4
81137090:	10800037 	ldwio	r2,0(r2)
81137094:	e0bff615 	stw	r2,-40(fp)
     space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >>
81137098:	e0bff617 	ldw	r2,-40(fp)
8113709c:	1004d43a 	srli	r2,r2,16
811370a0:	e0bff715 	stw	r2,-36(fp)
             ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
     we= (control & ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK) >>
811370a4:	e0bff617 	ldw	r2,-40(fp)
811370a8:	1080008c 	andi	r2,r2,2
811370ac:	1004d07a 	srli	r2,r2,1
811370b0:	e0bff815 	stw	r2,-32(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_WE_OFST;
     re= (control & ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK) >>
811370b4:	e0bff617 	ldw	r2,-40(fp)
811370b8:	1080004c 	andi	r2,r2,1
811370bc:	e0bff915 	stw	r2,-28(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_RE_OFST;
     ri= (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK) >>
811370c0:	e0bff617 	ldw	r2,-40(fp)
811370c4:	1080400c 	andi	r2,r2,256
811370c8:	1004d23a 	srli	r2,r2,8
811370cc:	e0bffa15 	stw	r2,-24(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_RI_OFST;
     wi= (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK) >>
811370d0:	e0bff617 	ldw	r2,-40(fp)
811370d4:	1080800c 	andi	r2,r2,512
811370d8:	1004d27a 	srli	r2,r2,9
811370dc:	e0bffb15 	stw	r2,-20(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_WI_OFST;
     ac= (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK) >>
811370e0:	e0bff617 	ldw	r2,-40(fp)
811370e4:	1081000c 	andi	r2,r2,1024
811370e8:	1004d2ba 	srli	r2,r2,10
811370ec:	e0bffc15 	stw	r2,-16(fp)
#ifdef ALTERA_AVALON_JTAG_UART_SMALL
    ALT_LOG_PRINTF(
     "%s HW FIFO wspace=%d AC=%d WI=%d RI=%d WE=%d RE=%d\r\n",
         header,space,ac,wi,ri,we,re);
#else
    ALT_LOG_PRINTF(
811370f0:	e0bffd17 	ldw	r2,-12(fp)
811370f4:	10c01017 	ldw	r3,64(r2)
811370f8:	e0bffd17 	ldw	r2,-12(fp)
811370fc:	10800f17 	ldw	r2,60(r2)
81137100:	1887c83a 	sub	r3,r3,r2
81137104:	e0bff917 	ldw	r2,-28(fp)
81137108:	d8800415 	stw	r2,16(sp)
8113710c:	e0bff817 	ldw	r2,-32(fp)
81137110:	d8800315 	stw	r2,12(sp)
81137114:	e0bffa17 	ldw	r2,-24(fp)
81137118:	d8800215 	stw	r2,8(sp)
8113711c:	e0bffb17 	ldw	r2,-20(fp)
81137120:	d8800115 	stw	r2,4(sp)
81137124:	e0bffc17 	ldw	r2,-16(fp)
81137128:	d8800015 	stw	r2,0(sp)
8113712c:	e1fff717 	ldw	r7,-36(fp)
81137130:	180d883a 	mov	r6,r3
81137134:	e17fff17 	ldw	r5,-4(fp)
81137138:	01204574 	movhi	r4,33045
8113713c:	21042004 	addi	r4,r4,4224
81137140:	1136f640 	call	81136f64 <alt_log_printf_proc>
     "%s SW CirBuf = %d, HW FIFO wspace=%d AC=%d WI=%d RI=%d WE=%d RE=%d\r\n",
         header,(dev->tx_out-dev->tx_in),space,ac,wi,ri,we,re);
#endif   
         
     return;
81137144:	0001883a 	nop

}
81137148:	e037883a 	mov	sp,fp
8113714c:	dfc00117 	ldw	ra,4(sp)
81137150:	df000017 	ldw	fp,0(sp)
81137154:	dec00204 	addi	sp,sp,8
81137158:	f800283a 	ret

8113715c <alt_log_jtag_uart_startup_info>:
/* In altera_avalon_jtag_uart.c
 * Same output as the alarm function above, but this is called in the driver
 * init function.  Hence, it gives the status of the JTAG UART control register
 * right at the initialization of the driver */ 
void alt_log_jtag_uart_startup_info(altera_avalon_jtag_uart_state* dev, int base)
{
8113715c:	defffb04 	addi	sp,sp,-20
81137160:	de00012e 	bgeu	sp,et,81137168 <alt_log_jtag_uart_startup_info+0xc>
81137164:	003b68fa 	trap	3
81137168:	dfc00415 	stw	ra,16(sp)
8113716c:	df000315 	stw	fp,12(sp)
81137170:	df000304 	addi	fp,sp,12
81137174:	e13ffe15 	stw	r4,-8(fp)
81137178:	e17fff15 	stw	r5,-4(fp)
     const char* header="JTAG Startup Info:";
8113717c:	00a04574 	movhi	r2,33045
81137180:	10843204 	addi	r2,r2,4296
81137184:	e0bffd15 	stw	r2,-12(fp)
     alt_log_jtag_uart_print_control_reg(dev, base, header);
81137188:	e1bffd17 	ldw	r6,-12(fp)
8113718c:	e17fff17 	ldw	r5,-4(fp)
81137190:	e13ffe17 	ldw	r4,-8(fp)
81137194:	11370640 	call	81137064 <alt_log_jtag_uart_print_control_reg>
     return;
81137198:	0001883a 	nop
}
8113719c:	e037883a 	mov	sp,fp
811371a0:	dfc00117 	ldw	ra,4(sp)
811371a4:	df000017 	ldw	fp,0(sp)
811371a8:	dec00204 	addi	sp,sp,8
811371ac:	f800283a 	ret

811371b0 <alt_log_jtag_uart_isr_proc>:

/* In altera_avalon_jtag_uart.c
 * When turned on, this function will print out the status of the jtag uart
 * control register every time there is a jtag uart "almost-empty" interrupt. */
void alt_log_jtag_uart_isr_proc(int base, altera_avalon_jtag_uart_state* dev) 
{
811371b0:	defffb04 	addi	sp,sp,-20
811371b4:	de00012e 	bgeu	sp,et,811371bc <alt_log_jtag_uart_isr_proc+0xc>
811371b8:	003b68fa 	trap	3
811371bc:	dfc00415 	stw	ra,16(sp)
811371c0:	df000315 	stw	fp,12(sp)
811371c4:	df000304 	addi	fp,sp,12
811371c8:	e13ffe15 	stw	r4,-8(fp)
811371cc:	e17fff15 	stw	r5,-4(fp)
    if (alt_log_jtag_uart_isr_on_flag) {
811371d0:	d0a081c3 	ldbu	r2,-32249(gp)
811371d4:	10803fcc 	andi	r2,r2,255
811371d8:	10000826 	beq	r2,zero,811371fc <alt_log_jtag_uart_isr_proc+0x4c>
        const char* header="JTAG IRQ:";
811371dc:	00a04574 	movhi	r2,33045
811371e0:	10843704 	addi	r2,r2,4316
811371e4:	e0bffd15 	stw	r2,-12(fp)
        alt_log_jtag_uart_print_control_reg(dev, base, header);
811371e8:	e1bffd17 	ldw	r6,-12(fp)
811371ec:	e17ffe17 	ldw	r5,-8(fp)
811371f0:	e13fff17 	ldw	r4,-4(fp)
811371f4:	11370640 	call	81137064 <alt_log_jtag_uart_print_control_reg>
    }
    return;
811371f8:	0001883a 	nop
811371fc:	0001883a 	nop
}
81137200:	e037883a 	mov	sp,fp
81137204:	dfc00117 	ldw	ra,4(sp)
81137208:	df000017 	ldw	fp,0(sp)
8113720c:	dec00204 	addi	sp,sp,8
81137210:	f800283a 	ret

81137214 <alt_log_write>:
 * When the alt_log_write_on_flag is turned on, this function gets called
 * every time alt_write gets called.  The first 
 * ALT_LOG_WRITE_ECHO_LEN characters of every printf command (or any command
 * that eventually calls write()) gets echoed to the alt_log output. */
void alt_log_write(const void *ptr, size_t len)
{
81137214:	defffa04 	addi	sp,sp,-24
81137218:	de00012e 	bgeu	sp,et,81137220 <alt_log_write+0xc>
8113721c:	003b68fa 	trap	3
81137220:	dfc00515 	stw	ra,20(sp)
81137224:	df000415 	stw	fp,16(sp)
81137228:	df000404 	addi	fp,sp,16
8113722c:	e13ffe15 	stw	r4,-8(fp)
81137230:	e17fff15 	stw	r5,-4(fp)
    if (alt_log_write_on_flag) {
81137234:	d0a08103 	ldbu	r2,-32252(gp)
81137238:	10803fcc 	andi	r2,r2,255
8113723c:	10004026 	beq	r2,zero,81137340 <alt_log_write+0x12c>
    int temp_cnt;
        int length=(ALT_LOG_WRITE_ECHO_LEN>len) ? len : ALT_LOG_WRITE_ECHO_LEN;
81137240:	e0bfff17 	ldw	r2,-4(fp)
81137244:	10c00430 	cmpltui	r3,r2,16
81137248:	1800011e 	bne	r3,zero,81137250 <alt_log_write+0x3c>
8113724c:	008003c4 	movi	r2,15
81137250:	e0bffd15 	stw	r2,-12(fp)

        if (length < 2) return;
81137254:	e0bffd17 	ldw	r2,-12(fp)
81137258:	10800088 	cmpgei	r2,r2,2
8113725c:	10003726 	beq	r2,zero,8113733c <alt_log_write+0x128>

        strncpy (alt_log_write_buf,ptr,length);
81137260:	e0bffd17 	ldw	r2,-12(fp)
81137264:	100d883a 	mov	r6,r2
81137268:	e17ffe17 	ldw	r5,-8(fp)
8113726c:	012045b4 	movhi	r4,33046
81137270:	211c1804 	addi	r4,r4,28768
81137274:	114b1e00 	call	8114b1e0 <strncpy>
    alt_log_write_buf[length-1]='\n';
81137278:	e0bffd17 	ldw	r2,-12(fp)
8113727c:	10ffffc4 	addi	r3,r2,-1
81137280:	00a045b4 	movhi	r2,33046
81137284:	109c1804 	addi	r2,r2,28768
81137288:	10c5883a 	add	r2,r2,r3
8113728c:	00c00284 	movi	r3,10
81137290:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length]='\r';
81137294:	00a045b4 	movhi	r2,33046
81137298:	109c1804 	addi	r2,r2,28768
8113729c:	e0fffd17 	ldw	r3,-12(fp)
811372a0:	10c5883a 	add	r2,r2,r3
811372a4:	00c00344 	movi	r3,13
811372a8:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length+1]='\0';
811372ac:	e0bffd17 	ldw	r2,-12(fp)
811372b0:	10c00044 	addi	r3,r2,1
811372b4:	00a045b4 	movhi	r2,33046
811372b8:	109c1804 	addi	r2,r2,28768
811372bc:	10c5883a 	add	r2,r2,r3
811372c0:	10000005 	stb	zero,0(r2)

    /* Escape Ctrl-D's. If the Ctrl-D gets sent it might kill the terminal
         * connection of alt_log. It will get replaced by 'D'. */
        for (temp_cnt=0;temp_cnt < length; temp_cnt++) {
811372c4:	e03ffc15 	stw	zero,-16(fp)
811372c8:	00001306 	br	81137318 <alt_log_write+0x104>
        if (alt_log_write_buf[temp_cnt]== 0x4) {
811372cc:	00a045b4 	movhi	r2,33046
811372d0:	109c1804 	addi	r2,r2,28768
811372d4:	e0fffc17 	ldw	r3,-16(fp)
811372d8:	10c5883a 	add	r2,r2,r3
811372dc:	10800003 	ldbu	r2,0(r2)
811372e0:	10803fcc 	andi	r2,r2,255
811372e4:	1080201c 	xori	r2,r2,128
811372e8:	10bfe004 	addi	r2,r2,-128
811372ec:	10800118 	cmpnei	r2,r2,4
811372f0:	1000061e 	bne	r2,zero,8113730c <alt_log_write+0xf8>
            alt_log_write_buf[temp_cnt]='D';
811372f4:	00a045b4 	movhi	r2,33046
811372f8:	109c1804 	addi	r2,r2,28768
811372fc:	e0fffc17 	ldw	r3,-16(fp)
81137300:	10c5883a 	add	r2,r2,r3
81137304:	00c01104 	movi	r3,68
81137308:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length]='\r';
    alt_log_write_buf[length+1]='\0';

    /* Escape Ctrl-D's. If the Ctrl-D gets sent it might kill the terminal
         * connection of alt_log. It will get replaced by 'D'. */
        for (temp_cnt=0;temp_cnt < length; temp_cnt++) {
8113730c:	e0bffc17 	ldw	r2,-16(fp)
81137310:	10800044 	addi	r2,r2,1
81137314:	e0bffc15 	stw	r2,-16(fp)
81137318:	e0fffc17 	ldw	r3,-16(fp)
8113731c:	e0bffd17 	ldw	r2,-12(fp)
81137320:	18bfea16 	blt	r3,r2,811372cc <__reset+0xfb1172cc>
        if (alt_log_write_buf[temp_cnt]== 0x4) {
            alt_log_write_buf[temp_cnt]='D';
        }
    }
        ALT_LOG_PRINTF("Write Echo: %s",alt_log_write_buf);
81137324:	016045b4 	movhi	r5,33046
81137328:	295c1804 	addi	r5,r5,28768
8113732c:	01204574 	movhi	r4,33045
81137330:	21043a04 	addi	r4,r4,4328
81137334:	1136f640 	call	81136f64 <alt_log_printf_proc>
81137338:	00000106 	br	81137340 <alt_log_write+0x12c>
{
    if (alt_log_write_on_flag) {
    int temp_cnt;
        int length=(ALT_LOG_WRITE_ECHO_LEN>len) ? len : ALT_LOG_WRITE_ECHO_LEN;

        if (length < 2) return;
8113733c:	0001883a 	nop
            alt_log_write_buf[temp_cnt]='D';
        }
    }
        ALT_LOG_PRINTF("Write Echo: %s",alt_log_write_buf);
    }
}
81137340:	e037883a 	mov	sp,fp
81137344:	dfc00117 	ldw	ra,4(sp)
81137348:	df000017 	ldw	fp,0(sp)
8113734c:	dec00204 	addi	sp,sp,8
81137350:	f800283a 	ret

81137354 <alt_log_system_clock>:

/* In altera_avalon_timer_sc
 * This function prints out a system clock is alive message
 * every ALT_LOG_SYS_CLK_INTERVAL (in ticks).  */
void alt_log_system_clock()
{
81137354:	defffe04 	addi	sp,sp,-8
81137358:	de00012e 	bgeu	sp,et,81137360 <alt_log_system_clock+0xc>
8113735c:	003b68fa 	trap	3
81137360:	dfc00115 	stw	ra,4(sp)
81137364:	df000015 	stw	fp,0(sp)
81137368:	d839883a 	mov	fp,sp
    if (alt_log_sys_clk_on_flag) {
8113736c:	d0a08143 	ldbu	r2,-32251(gp)
81137370:	10803fcc 	andi	r2,r2,255
81137374:	10000e26 	beq	r2,zero,811373b0 <alt_log_system_clock+0x5c>
    alt_log_sys_clk_count++;
81137378:	d0a08417 	ldw	r2,-32240(gp)
8113737c:	10800044 	addi	r2,r2,1
81137380:	d0a08415 	stw	r2,-32240(gp)
81137384:	d0a08817 	ldw	r2,-32224(gp)
        if (alt_log_sys_clk_count > ALT_LOG_SYS_CLK_INTERVAL) {
81137388:	d0e08417 	ldw	r3,-32240(gp)
8113738c:	10c0082e 	bgeu	r2,r3,811373b0 <alt_log_system_clock+0x5c>
            alt_log_sys_clk_count = 0;
81137390:	d0208415 	stw	zero,-32240(gp)
            ALT_LOG_PRINTF("System Clock On %u\r\n",alt_system_clock_in_sec++);
81137394:	d0a08317 	ldw	r2,-32244(gp)
81137398:	10c00044 	addi	r3,r2,1
8113739c:	d0e08315 	stw	r3,-32244(gp)
811373a0:	100b883a 	mov	r5,r2
811373a4:	01204574 	movhi	r4,33045
811373a8:	21043e04 	addi	r4,r4,4344
811373ac:	1136f640 	call	81136f64 <alt_log_printf_proc>
        }
    }
}
811373b0:	0001883a 	nop
811373b4:	e037883a 	mov	sp,fp
811373b8:	dfc00117 	ldw	ra,4(sp)
811373bc:	df000017 	ldw	fp,0(sp)
811373c0:	dec00204 	addi	sp,sp,8
811373c4:	f800283a 	ret

811373c8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811373c8:	defffe04 	addi	sp,sp,-8
811373cc:	de00012e 	bgeu	sp,et,811373d4 <alt_get_errno+0xc>
811373d0:	003b68fa 	trap	3
811373d4:	dfc00115 	stw	ra,4(sp)
811373d8:	df000015 	stw	fp,0(sp)
811373dc:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811373e0:	d0a01017 	ldw	r2,-32704(gp)
811373e4:	10000326 	beq	r2,zero,811373f4 <alt_get_errno+0x2c>
811373e8:	d0a01017 	ldw	r2,-32704(gp)
811373ec:	103ee83a 	callr	r2
811373f0:	00000106 	br	811373f8 <alt_get_errno+0x30>
811373f4:	d0a07804 	addi	r2,gp,-32288
}
811373f8:	e037883a 	mov	sp,fp
811373fc:	dfc00117 	ldw	ra,4(sp)
81137400:	df000017 	ldw	fp,0(sp)
81137404:	dec00204 	addi	sp,sp,8
81137408:	f800283a 	ret

8113740c <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
8113740c:	defff904 	addi	sp,sp,-28
81137410:	de00012e 	bgeu	sp,et,81137418 <lseek+0xc>
81137414:	003b68fa 	trap	3
81137418:	dfc00615 	stw	ra,24(sp)
8113741c:	df000515 	stw	fp,20(sp)
81137420:	df000504 	addi	fp,sp,20
81137424:	e13ffd15 	stw	r4,-12(fp)
81137428:	e17ffe15 	stw	r5,-8(fp)
8113742c:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
81137430:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81137434:	e0bffd17 	ldw	r2,-12(fp)
81137438:	10000616 	blt	r2,zero,81137454 <lseek+0x48>
8113743c:	e0bffd17 	ldw	r2,-12(fp)
81137440:	10c00324 	muli	r3,r2,12
81137444:	00a04574 	movhi	r2,33045
81137448:	1087f704 	addi	r2,r2,8156
8113744c:	1885883a 	add	r2,r3,r2
81137450:	00000106 	br	81137458 <lseek+0x4c>
81137454:	0005883a 	mov	r2,zero
81137458:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
8113745c:	e0bffc17 	ldw	r2,-16(fp)
81137460:	10001026 	beq	r2,zero,811374a4 <lseek+0x98>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
81137464:	e0bffc17 	ldw	r2,-16(fp)
81137468:	10800017 	ldw	r2,0(r2)
8113746c:	10800717 	ldw	r2,28(r2)
81137470:	10000926 	beq	r2,zero,81137498 <lseek+0x8c>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
81137474:	e0bffc17 	ldw	r2,-16(fp)
81137478:	10800017 	ldw	r2,0(r2)
8113747c:	10800717 	ldw	r2,28(r2)
81137480:	e1bfff17 	ldw	r6,-4(fp)
81137484:	e17ffe17 	ldw	r5,-8(fp)
81137488:	e13ffc17 	ldw	r4,-16(fp)
8113748c:	103ee83a 	callr	r2
81137490:	e0bffb15 	stw	r2,-20(fp)
81137494:	00000506 	br	811374ac <lseek+0xa0>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
81137498:	00bfde84 	movi	r2,-134
8113749c:	e0bffb15 	stw	r2,-20(fp)
811374a0:	00000206 	br	811374ac <lseek+0xa0>
    }
  }
  else  
  {
    rc = -EBADFD;
811374a4:	00bfebc4 	movi	r2,-81
811374a8:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
811374ac:	e0bffb17 	ldw	r2,-20(fp)
811374b0:	1000070e 	bge	r2,zero,811374d0 <lseek+0xc4>
  {
    ALT_ERRNO = -rc;
811374b4:	11373c80 	call	811373c8 <alt_get_errno>
811374b8:	1007883a 	mov	r3,r2
811374bc:	e0bffb17 	ldw	r2,-20(fp)
811374c0:	0085c83a 	sub	r2,zero,r2
811374c4:	18800015 	stw	r2,0(r3)
    rc = -1;
811374c8:	00bfffc4 	movi	r2,-1
811374cc:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
811374d0:	e0bffb17 	ldw	r2,-20(fp)
}
811374d4:	e037883a 	mov	sp,fp
811374d8:	dfc00117 	ldw	ra,4(sp)
811374dc:	df000017 	ldw	fp,0(sp)
811374e0:	dec00204 	addi	sp,sp,8
811374e4:	f800283a 	ret

811374e8 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
811374e8:	defff904 	addi	sp,sp,-28
811374ec:	de00012e 	bgeu	sp,et,811374f4 <alt_main+0xc>
811374f0:	003b68fa 	trap	3
811374f4:	dfc00615 	stw	ra,24(sp)
811374f8:	df000515 	stw	fp,20(sp)
811374fc:	df000504 	addi	fp,sp,20
#ifndef ALT_NO_EXIT    
  int result;
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
81137500:	d0a01217 	ldw	r2,-32696(gp)
81137504:	10800058 	cmpnei	r2,r2,1
81137508:	1000031e 	bne	r2,zero,81137518 <alt_main+0x30>
8113750c:	01204574 	movhi	r4,33045
81137510:	21044404 	addi	r4,r4,4368
81137514:	1136f640 	call	81136f64 <alt_log_printf_proc>
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
81137518:	0009883a 	mov	r4,zero
8113751c:	11420400 	call	81142040 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
81137520:	d0a01217 	ldw	r2,-32696(gp)
81137524:	10800058 	cmpnei	r2,r2,1
81137528:	1000031e 	bne	r2,zero,81137538 <alt_main+0x50>
8113752c:	01204574 	movhi	r4,33045
81137530:	21045204 	addi	r4,r4,4424
81137534:	1136f640 	call	81136f64 <alt_log_printf_proc>
  ALT_OS_INIT();
81137538:	1138ad40 	call	81138ad4 <OSInit>
8113753c:	01000044 	movi	r4,1
81137540:	113e7f00 	call	8113e7f0 <OSSemCreate>
81137544:	d0a08b15 	stw	r2,-32212(gp)
81137548:	01000044 	movi	r4,1
8113754c:	113e7f00 	call	8113e7f0 <OSSemCreate>
81137550:	d0a08d15 	stw	r2,-32204(gp)
  /*
   * Initialize the semaphore used to control access to the file descriptor
   * list.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
81137554:	d0a01217 	ldw	r2,-32696(gp)
81137558:	10800058 	cmpnei	r2,r2,1
8113755c:	1000031e 	bne	r2,zero,8113756c <alt_main+0x84>
81137560:	01204574 	movhi	r4,33045
81137564:	21046004 	addi	r4,r4,4480
81137568:	1136f640 	call	81136f64 <alt_log_printf_proc>
8113756c:	d0a07f04 	addi	r2,gp,-32260
81137570:	e0bffc15 	stw	r2,-16(fp)
81137574:	00800044 	movi	r2,1
81137578:	e0bffd0d 	sth	r2,-12(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
8113757c:	e0bffd0b 	ldhu	r2,-12(fp)
81137580:	1009883a 	mov	r4,r2
81137584:	113e7f00 	call	8113e7f0 <OSSemCreate>
81137588:	1007883a 	mov	r3,r2
8113758c:	e0bffc17 	ldw	r2,-16(fp)
81137590:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
81137594:	d0a01217 	ldw	r2,-32696(gp)
81137598:	10800058 	cmpnei	r2,r2,1
8113759c:	1000031e 	bne	r2,zero,811375ac <alt_main+0xc4>
811375a0:	01204574 	movhi	r4,33045
811375a4:	21046e04 	addi	r4,r4,4536
811375a8:	1136f640 	call	81136f64 <alt_log_printf_proc>
  alt_sys_init();
811375ac:	11420800 	call	81142080 <alt_sys_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_sys_init.\r\n");
811375b0:	d0a01217 	ldw	r2,-32696(gp)
811375b4:	10800058 	cmpnei	r2,r2,1
811375b8:	1000031e 	bne	r2,zero,811375c8 <alt_main+0xe0>
811375bc:	01204574 	movhi	r4,33045
811375c0:	21047804 	addi	r4,r4,4576
811375c4:	1136f640 	call	81136f64 <alt_log_printf_proc>
   * been initialized. This is only done if the user has requested these
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
811375c8:	d0a01217 	ldw	r2,-32696(gp)
811375cc:	10800058 	cmpnei	r2,r2,1
811375d0:	1000031e 	bne	r2,zero,811375e0 <alt_main+0xf8>
811375d4:	01204574 	movhi	r4,33045
811375d8:	21048104 	addi	r4,r4,4612
811375dc:	1136f640 	call	81136f64 <alt_log_printf_proc>
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
811375e0:	01a04574 	movhi	r6,33045
811375e4:	31848904 	addi	r6,r6,4644
811375e8:	01604574 	movhi	r5,33045
811375ec:	29448e04 	addi	r5,r5,4664
811375f0:	01204574 	movhi	r4,33045
811375f4:	21048e04 	addi	r4,r4,4664
811375f8:	114a9700 	call	8114a970 <alt_io_redirect>
  /*
   * Finally, call main(). The return code is then passed to a subsequent
   * call to exit() unless the application is never supposed to exit.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");
811375fc:	d0a01217 	ldw	r2,-32696(gp)
81137600:	10800058 	cmpnei	r2,r2,1
81137604:	1000031e 	bne	r2,zero,81137614 <alt_main+0x12c>
81137608:	01204574 	movhi	r4,33045
8113760c:	21049204 	addi	r4,r4,4680
81137610:	1136f640 	call	81136f64 <alt_log_printf_proc>

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
81137614:	d0a08517 	ldw	r2,-32236(gp)
81137618:	d0e08617 	ldw	r3,-32232(gp)
8113761c:	d1208717 	ldw	r4,-32228(gp)
81137620:	200d883a 	mov	r6,r4
81137624:	180b883a 	mov	r5,r3
81137628:	1009883a 	mov	r4,r2
8113762c:	1117ddc0 	call	81117ddc <main>
81137630:	e0bffb15 	stw	r2,-20(fp)
  close(STDOUT_FILENO);
81137634:	01000044 	movi	r4,1
81137638:	11364140 	call	81136414 <close>
  exit (result);
8113763c:	e13ffb17 	ldw	r4,-20(fp)
81137640:	114b1240 	call	8114b124 <exit>

81137644 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81137644:	defffe04 	addi	sp,sp,-8
81137648:	de00012e 	bgeu	sp,et,81137650 <alt_get_errno+0xc>
8113764c:	003b68fa 	trap	3
81137650:	dfc00115 	stw	ra,4(sp)
81137654:	df000015 	stw	fp,0(sp)
81137658:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8113765c:	d0a01017 	ldw	r2,-32704(gp)
81137660:	10000326 	beq	r2,zero,81137670 <alt_get_errno+0x2c>
81137664:	d0a01017 	ldw	r2,-32704(gp)
81137668:	103ee83a 	callr	r2
8113766c:	00000106 	br	81137674 <alt_get_errno+0x30>
81137670:	d0a07804 	addi	r2,gp,-32288
}
81137674:	e037883a 	mov	sp,fp
81137678:	dfc00117 	ldw	ra,4(sp)
8113767c:	df000017 	ldw	fp,0(sp)
81137680:	dec00204 	addi	sp,sp,8
81137684:	f800283a 	ret

81137688 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
81137688:	defffd04 	addi	sp,sp,-12
8113768c:	de00012e 	bgeu	sp,et,81137694 <alt_file_locked+0xc>
81137690:	003b68fa 	trap	3
81137694:	df000215 	stw	fp,8(sp)
81137698:	df000204 	addi	fp,sp,8
8113769c:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
811376a0:	e0bfff17 	ldw	r2,-4(fp)
811376a4:	10800217 	ldw	r2,8(r2)
811376a8:	10d00034 	orhi	r3,r2,16384
811376ac:	e0bfff17 	ldw	r2,-4(fp)
811376b0:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
811376b4:	e03ffe15 	stw	zero,-8(fp)
811376b8:	00001d06 	br	81137730 <alt_file_locked+0xa8>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
811376bc:	00a04574 	movhi	r2,33045
811376c0:	1087f704 	addi	r2,r2,8156
811376c4:	e0fffe17 	ldw	r3,-8(fp)
811376c8:	18c00324 	muli	r3,r3,12
811376cc:	10c5883a 	add	r2,r2,r3
811376d0:	10c00017 	ldw	r3,0(r2)
811376d4:	e0bfff17 	ldw	r2,-4(fp)
811376d8:	10800017 	ldw	r2,0(r2)
811376dc:	1880111e 	bne	r3,r2,81137724 <alt_file_locked+0x9c>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
811376e0:	00a04574 	movhi	r2,33045
811376e4:	1087f704 	addi	r2,r2,8156
811376e8:	e0fffe17 	ldw	r3,-8(fp)
811376ec:	18c00324 	muli	r3,r3,12
811376f0:	10c5883a 	add	r2,r2,r3
811376f4:	10800204 	addi	r2,r2,8
811376f8:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
811376fc:	1000090e 	bge	r2,zero,81137724 <alt_file_locked+0x9c>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
81137700:	e0bffe17 	ldw	r2,-8(fp)
81137704:	10c00324 	muli	r3,r2,12
81137708:	00a04574 	movhi	r2,33045
8113770c:	1087f704 	addi	r2,r2,8156
81137710:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
81137714:	e0bfff17 	ldw	r2,-4(fp)
81137718:	18800226 	beq	r3,r2,81137724 <alt_file_locked+0x9c>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
8113771c:	00bffcc4 	movi	r2,-13
81137720:	00000806 	br	81137744 <alt_file_locked+0xbc>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
81137724:	e0bffe17 	ldw	r2,-8(fp)
81137728:	10800044 	addi	r2,r2,1
8113772c:	e0bffe15 	stw	r2,-8(fp)
81137730:	d0a00f17 	ldw	r2,-32708(gp)
81137734:	1007883a 	mov	r3,r2
81137738:	e0bffe17 	ldw	r2,-8(fp)
8113773c:	18bfdf2e 	bgeu	r3,r2,811376bc <__reset+0xfb1176bc>
    }
  }
  
  /* The device is not locked */
 
  return 0;
81137740:	0005883a 	mov	r2,zero
}
81137744:	e037883a 	mov	sp,fp
81137748:	df000017 	ldw	fp,0(sp)
8113774c:	dec00104 	addi	sp,sp,4
81137750:	f800283a 	ret

81137754 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
81137754:	defff604 	addi	sp,sp,-40
81137758:	de00012e 	bgeu	sp,et,81137760 <open+0xc>
8113775c:	003b68fa 	trap	3
81137760:	dfc00915 	stw	ra,36(sp)
81137764:	df000815 	stw	fp,32(sp)
81137768:	df000804 	addi	fp,sp,32
8113776c:	e13ffd15 	stw	r4,-12(fp)
81137770:	e17ffe15 	stw	r5,-8(fp)
81137774:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
81137778:	00bfffc4 	movi	r2,-1
8113777c:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
81137780:	00bffb44 	movi	r2,-19
81137784:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
81137788:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
8113778c:	d1600d04 	addi	r5,gp,-32716
81137790:	e13ffd17 	ldw	r4,-12(fp)
81137794:	114a3500 	call	8114a350 <alt_find_dev>
81137798:	e0bff815 	stw	r2,-32(fp)
8113779c:	e0bff817 	ldw	r2,-32(fp)
811377a0:	1000051e 	bne	r2,zero,811377b8 <open+0x64>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
811377a4:	e13ffd17 	ldw	r4,-12(fp)
811377a8:	114a3e80 	call	8114a3e8 <alt_find_file>
811377ac:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
811377b0:	00800044 	movi	r2,1
811377b4:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
811377b8:	e0bff817 	ldw	r2,-32(fp)
811377bc:	10002926 	beq	r2,zero,81137864 <open+0x110>
  {
    if ((index = alt_get_fd (dev)) < 0)
811377c0:	e13ff817 	ldw	r4,-32(fp)
811377c4:	114a4f80 	call	8114a4f8 <alt_get_fd>
811377c8:	e0bff915 	stw	r2,-28(fp)
811377cc:	e0bff917 	ldw	r2,-28(fp)
811377d0:	1000030e 	bge	r2,zero,811377e0 <open+0x8c>
    {
      status = index;
811377d4:	e0bff917 	ldw	r2,-28(fp)
811377d8:	e0bffa15 	stw	r2,-24(fp)
811377dc:	00002306 	br	8113786c <open+0x118>
    }
    else
    {
      fd = &alt_fd_list[index];
811377e0:	e0bff917 	ldw	r2,-28(fp)
811377e4:	10c00324 	muli	r3,r2,12
811377e8:	00a04574 	movhi	r2,33045
811377ec:	1087f704 	addi	r2,r2,8156
811377f0:	1885883a 	add	r2,r3,r2
811377f4:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
811377f8:	e0fffe17 	ldw	r3,-8(fp)
811377fc:	00900034 	movhi	r2,16384
81137800:	10bfffc4 	addi	r2,r2,-1
81137804:	1886703a 	and	r3,r3,r2
81137808:	e0bffc17 	ldw	r2,-16(fp)
8113780c:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
81137810:	e0bffb17 	ldw	r2,-20(fp)
81137814:	1000051e 	bne	r2,zero,8113782c <open+0xd8>
81137818:	e13ffc17 	ldw	r4,-16(fp)
8113781c:	11376880 	call	81137688 <alt_file_locked>
81137820:	e0bffa15 	stw	r2,-24(fp)
81137824:	e0bffa17 	ldw	r2,-24(fp)
81137828:	10001016 	blt	r2,zero,8113786c <open+0x118>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
8113782c:	e0bff817 	ldw	r2,-32(fp)
81137830:	10800317 	ldw	r2,12(r2)
81137834:	10000826 	beq	r2,zero,81137858 <open+0x104>
81137838:	e0bff817 	ldw	r2,-32(fp)
8113783c:	10800317 	ldw	r2,12(r2)
81137840:	e1ffff17 	ldw	r7,-4(fp)
81137844:	e1bffe17 	ldw	r6,-8(fp)
81137848:	e17ffd17 	ldw	r5,-12(fp)
8113784c:	e13ffc17 	ldw	r4,-16(fp)
81137850:	103ee83a 	callr	r2
81137854:	00000106 	br	8113785c <open+0x108>
81137858:	0005883a 	mov	r2,zero
8113785c:	e0bffa15 	stw	r2,-24(fp)
81137860:	00000206 	br	8113786c <open+0x118>
      }
    }
  }
  else
  {
    status = -ENODEV;
81137864:	00bffb44 	movi	r2,-19
81137868:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
8113786c:	e0bffa17 	ldw	r2,-24(fp)
81137870:	1000090e 	bge	r2,zero,81137898 <open+0x144>
  {
    alt_release_fd (index);  
81137874:	e13ff917 	ldw	r4,-28(fp)
81137878:	11379f80 	call	811379f8 <alt_release_fd>
    ALT_ERRNO = -status;
8113787c:	11376440 	call	81137644 <alt_get_errno>
81137880:	1007883a 	mov	r3,r2
81137884:	e0bffa17 	ldw	r2,-24(fp)
81137888:	0085c83a 	sub	r2,zero,r2
8113788c:	18800015 	stw	r2,0(r3)
    return -1;
81137890:	00bfffc4 	movi	r2,-1
81137894:	00000106 	br	8113789c <open+0x148>
  }
  
  /* return the reference upon success */

  return index;
81137898:	e0bff917 	ldw	r2,-28(fp)
}
8113789c:	e037883a 	mov	sp,fp
811378a0:	dfc00117 	ldw	ra,4(sp)
811378a4:	df000017 	ldw	fp,0(sp)
811378a8:	dec00204 	addi	sp,sp,8
811378ac:	f800283a 	ret

811378b0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811378b0:	defffe04 	addi	sp,sp,-8
811378b4:	de00012e 	bgeu	sp,et,811378bc <alt_get_errno+0xc>
811378b8:	003b68fa 	trap	3
811378bc:	dfc00115 	stw	ra,4(sp)
811378c0:	df000015 	stw	fp,0(sp)
811378c4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811378c8:	d0a01017 	ldw	r2,-32704(gp)
811378cc:	10000326 	beq	r2,zero,811378dc <alt_get_errno+0x2c>
811378d0:	d0a01017 	ldw	r2,-32704(gp)
811378d4:	103ee83a 	callr	r2
811378d8:	00000106 	br	811378e0 <alt_get_errno+0x30>
811378dc:	d0a07804 	addi	r2,gp,-32288
}
811378e0:	e037883a 	mov	sp,fp
811378e4:	dfc00117 	ldw	ra,4(sp)
811378e8:	df000017 	ldw	fp,0(sp)
811378ec:	dec00204 	addi	sp,sp,8
811378f0:	f800283a 	ret

811378f4 <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
811378f4:	defff904 	addi	sp,sp,-28
811378f8:	de00012e 	bgeu	sp,et,81137900 <read+0xc>
811378fc:	003b68fa 	trap	3
81137900:	dfc00615 	stw	ra,24(sp)
81137904:	df000515 	stw	fp,20(sp)
81137908:	df000504 	addi	fp,sp,20
8113790c:	e13ffd15 	stw	r4,-12(fp)
81137910:	e17ffe15 	stw	r5,-8(fp)
81137914:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81137918:	e0bffd17 	ldw	r2,-12(fp)
8113791c:	10000616 	blt	r2,zero,81137938 <read+0x44>
81137920:	e0bffd17 	ldw	r2,-12(fp)
81137924:	10c00324 	muli	r3,r2,12
81137928:	00a04574 	movhi	r2,33045
8113792c:	1087f704 	addi	r2,r2,8156
81137930:	1885883a 	add	r2,r3,r2
81137934:	00000106 	br	8113793c <read+0x48>
81137938:	0005883a 	mov	r2,zero
8113793c:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
81137940:	e0bffb17 	ldw	r2,-20(fp)
81137944:	10002226 	beq	r2,zero,811379d0 <read+0xdc>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
81137948:	e0bffb17 	ldw	r2,-20(fp)
8113794c:	10800217 	ldw	r2,8(r2)
81137950:	108000cc 	andi	r2,r2,3
81137954:	10800060 	cmpeqi	r2,r2,1
81137958:	1000181e 	bne	r2,zero,811379bc <read+0xc8>
        (fd->dev->read))
8113795c:	e0bffb17 	ldw	r2,-20(fp)
81137960:	10800017 	ldw	r2,0(r2)
81137964:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
81137968:	10001426 	beq	r2,zero,811379bc <read+0xc8>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
8113796c:	e0bffb17 	ldw	r2,-20(fp)
81137970:	10800017 	ldw	r2,0(r2)
81137974:	10800517 	ldw	r2,20(r2)
81137978:	e0ffff17 	ldw	r3,-4(fp)
8113797c:	180d883a 	mov	r6,r3
81137980:	e17ffe17 	ldw	r5,-8(fp)
81137984:	e13ffb17 	ldw	r4,-20(fp)
81137988:	103ee83a 	callr	r2
8113798c:	e0bffc15 	stw	r2,-16(fp)
81137990:	e0bffc17 	ldw	r2,-16(fp)
81137994:	1000070e 	bge	r2,zero,811379b4 <read+0xc0>
        {
          ALT_ERRNO = -rval;
81137998:	11378b00 	call	811378b0 <alt_get_errno>
8113799c:	1007883a 	mov	r3,r2
811379a0:	e0bffc17 	ldw	r2,-16(fp)
811379a4:	0085c83a 	sub	r2,zero,r2
811379a8:	18800015 	stw	r2,0(r3)
          return -1;
811379ac:	00bfffc4 	movi	r2,-1
811379b0:	00000c06 	br	811379e4 <read+0xf0>
        }
        return rval;
811379b4:	e0bffc17 	ldw	r2,-16(fp)
811379b8:	00000a06 	br	811379e4 <read+0xf0>
      }
      else
      {
        ALT_ERRNO = EACCES;
811379bc:	11378b00 	call	811378b0 <alt_get_errno>
811379c0:	1007883a 	mov	r3,r2
811379c4:	00800344 	movi	r2,13
811379c8:	18800015 	stw	r2,0(r3)
811379cc:	00000406 	br	811379e0 <read+0xec>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
811379d0:	11378b00 	call	811378b0 <alt_get_errno>
811379d4:	1007883a 	mov	r3,r2
811379d8:	00801444 	movi	r2,81
811379dc:	18800015 	stw	r2,0(r3)
  }
  return -1;
811379e0:	00bfffc4 	movi	r2,-1
}
811379e4:	e037883a 	mov	sp,fp
811379e8:	dfc00117 	ldw	ra,4(sp)
811379ec:	df000017 	ldw	fp,0(sp)
811379f0:	dec00204 	addi	sp,sp,8
811379f4:	f800283a 	ret

811379f8 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
811379f8:	defffe04 	addi	sp,sp,-8
811379fc:	de00012e 	bgeu	sp,et,81137a04 <alt_release_fd+0xc>
81137a00:	003b68fa 	trap	3
81137a04:	df000115 	stw	fp,4(sp)
81137a08:	df000104 	addi	fp,sp,4
81137a0c:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
81137a10:	e0bfff17 	ldw	r2,-4(fp)
81137a14:	108000d0 	cmplti	r2,r2,3
81137a18:	10000d1e 	bne	r2,zero,81137a50 <alt_release_fd+0x58>
  {
    alt_fd_list[fd].fd_flags = 0;
81137a1c:	00a04574 	movhi	r2,33045
81137a20:	1087f704 	addi	r2,r2,8156
81137a24:	e0ffff17 	ldw	r3,-4(fp)
81137a28:	18c00324 	muli	r3,r3,12
81137a2c:	10c5883a 	add	r2,r2,r3
81137a30:	10800204 	addi	r2,r2,8
81137a34:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
81137a38:	00a04574 	movhi	r2,33045
81137a3c:	1087f704 	addi	r2,r2,8156
81137a40:	e0ffff17 	ldw	r3,-4(fp)
81137a44:	18c00324 	muli	r3,r3,12
81137a48:	10c5883a 	add	r2,r2,r3
81137a4c:	10000015 	stw	zero,0(r2)
  }
}
81137a50:	0001883a 	nop
81137a54:	e037883a 	mov	sp,fp
81137a58:	df000017 	ldw	fp,0(sp)
81137a5c:	dec00104 	addi	sp,sp,4
81137a60:	f800283a 	ret

81137a64 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
81137a64:	defff604 	addi	sp,sp,-40
81137a68:	de00012e 	bgeu	sp,et,81137a70 <sbrk+0xc>
81137a6c:	003b68fa 	trap	3
81137a70:	df000915 	stw	fp,36(sp)
81137a74:	df000904 	addi	fp,sp,36
81137a78:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137a7c:	0005303a 	rdctl	r2,status
81137a80:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137a84:	e0fffe17 	ldw	r3,-8(fp)
81137a88:	00bfff84 	movi	r2,-2
81137a8c:	1884703a 	and	r2,r3,r2
81137a90:	1001703a 	wrctl	status,r2
  
  return context;
81137a94:	e0bffe17 	ldw	r2,-8(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
81137a98:	e0bff815 	stw	r2,-32(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
81137a9c:	d0a01317 	ldw	r2,-32692(gp)
81137aa0:	10c000c4 	addi	r3,r2,3
81137aa4:	00bfff04 	movi	r2,-4
81137aa8:	1884703a 	and	r2,r3,r2
81137aac:	d0a01315 	stw	r2,-32692(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
81137ab0:	d0e01317 	ldw	r3,-32692(gp)
81137ab4:	e0bfff17 	ldw	r2,-4(fp)
81137ab8:	1887883a 	add	r3,r3,r2
81137abc:	00a04834 	movhi	r2,33056
81137ac0:	10a80004 	addi	r2,r2,-24576
81137ac4:	10c0062e 	bgeu	r2,r3,81137ae0 <sbrk+0x7c>
81137ac8:	e0bff817 	ldw	r2,-32(fp)
81137acc:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137ad0:	e0bff717 	ldw	r2,-36(fp)
81137ad4:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
81137ad8:	00bfffc4 	movi	r2,-1
81137adc:	00001c06 	br	81137b50 <sbrk+0xec>
  }
#endif

  prev_heap_end = heap_end; 
81137ae0:	d0a01317 	ldw	r2,-32692(gp)
81137ae4:	e0bffa15 	stw	r2,-24(fp)
  heap_end += incr; 
81137ae8:	d0e01317 	ldw	r3,-32692(gp)
81137aec:	e0bfff17 	ldw	r2,-4(fp)
81137af0:	1885883a 	add	r2,r3,r2
81137af4:	d0a01315 	stw	r2,-32692(gp)
 */

static ALT_INLINE char * ALT_ALWAYS_INLINE alt_stack_limit (void)
{
  char * limit;
  NIOS2_READ_ET(limit);
81137af8:	c005883a 	mov	r2,et
81137afc:	e0bff915 	stw	r2,-28(fp)

  return limit; 
81137b00:	e0fff917 	ldw	r3,-28(fp)
   * pointer overflow. 
   * If the stack limit isn't pointing at the top of the heap then the code
   * is using a different stack so none of this needs to be done.
   */

  if (alt_stack_limit() == prev_heap_end)
81137b04:	e0bffa17 	ldw	r2,-24(fp)
81137b08:	18800c1e 	bne	r3,r2,81137b3c <sbrk+0xd8>
 */

static ALT_INLINE char * ALT_ALWAYS_INLINE alt_stack_pointer (void)
{
  char * pointer;
  NIOS2_READ_SP(pointer);
81137b0c:	d805883a 	mov	r2,sp
81137b10:	e0bffb15 	stw	r2,-20(fp)

  return pointer; 
81137b14:	e0bffb17 	ldw	r2,-20(fp)
  {
    if (alt_stack_pointer() <= heap_end)
81137b18:	d0e01317 	ldw	r3,-32692(gp)
81137b1c:	18800136 	bltu	r3,r2,81137b24 <sbrk+0xc0>
 * alt_report_stack_overflow reports that a stack overflow happened.
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_report_stack_overflow (void)
{
  NIOS2_REPORT_STACK_OVERFLOW();
81137b20:	003da0fa 	break	3
      alt_report_stack_overflow();

    alt_set_stack_limit(heap_end);
81137b24:	d0a01317 	ldw	r2,-32692(gp)
81137b28:	e0bffc15 	stw	r2,-16(fp)
 * limit register.
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_set_stack_limit (char * limit)
{
  alt_stack_limit_value = limit;
81137b2c:	e0bffc17 	ldw	r2,-16(fp)
81137b30:	d0a00015 	stw	r2,-32768(gp)
  NIOS2_WRITE_ET(limit);
81137b34:	e0bffc17 	ldw	r2,-16(fp)
81137b38:	1031883a 	mov	et,r2
81137b3c:	e0bff817 	ldw	r2,-32(fp)
81137b40:	e0bffd15 	stw	r2,-12(fp)
81137b44:	e0bffd17 	ldw	r2,-12(fp)
81137b48:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
81137b4c:	e0bffa17 	ldw	r2,-24(fp)
} 
81137b50:	e037883a 	mov	sp,fp
81137b54:	df000017 	ldw	fp,0(sp)
81137b58:	dec00104 	addi	sp,sp,4
81137b5c:	f800283a 	ret

81137b60 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
81137b60:	defffa04 	addi	sp,sp,-24
81137b64:	de00012e 	bgeu	sp,et,81137b6c <alt_alarm_stop+0xc>
81137b68:	003b68fa 	trap	3
81137b6c:	df000515 	stw	fp,20(sp)
81137b70:	df000504 	addi	fp,sp,20
81137b74:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137b78:	0005303a 	rdctl	r2,status
81137b7c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137b80:	e0fffc17 	ldw	r3,-16(fp)
81137b84:	00bfff84 	movi	r2,-2
81137b88:	1884703a 	and	r2,r3,r2
81137b8c:	1001703a 	wrctl	status,r2
  
  return context;
81137b90:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
81137b94:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
81137b98:	e0bfff17 	ldw	r2,-4(fp)
81137b9c:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
81137ba0:	e0bffd17 	ldw	r2,-12(fp)
81137ba4:	10800017 	ldw	r2,0(r2)
81137ba8:	e0fffd17 	ldw	r3,-12(fp)
81137bac:	18c00117 	ldw	r3,4(r3)
81137bb0:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
81137bb4:	e0bffd17 	ldw	r2,-12(fp)
81137bb8:	10800117 	ldw	r2,4(r2)
81137bbc:	e0fffd17 	ldw	r3,-12(fp)
81137bc0:	18c00017 	ldw	r3,0(r3)
81137bc4:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
81137bc8:	e0bffd17 	ldw	r2,-12(fp)
81137bcc:	e0fffd17 	ldw	r3,-12(fp)
81137bd0:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
81137bd4:	e0bffd17 	ldw	r2,-12(fp)
81137bd8:	e0fffd17 	ldw	r3,-12(fp)
81137bdc:	10c00015 	stw	r3,0(r2)
81137be0:	e0bffb17 	ldw	r2,-20(fp)
81137be4:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137be8:	e0bffe17 	ldw	r2,-8(fp)
81137bec:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
81137bf0:	0001883a 	nop
81137bf4:	e037883a 	mov	sp,fp
81137bf8:	df000017 	ldw	fp,0(sp)
81137bfc:	dec00104 	addi	sp,sp,4
81137c00:	f800283a 	ret

81137c04 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
81137c04:	defffb04 	addi	sp,sp,-20
81137c08:	de00012e 	bgeu	sp,et,81137c10 <alt_tick+0xc>
81137c0c:	003b68fa 	trap	3
81137c10:	dfc00415 	stw	ra,16(sp)
81137c14:	df000315 	stw	fp,12(sp)
81137c18:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
81137c1c:	d0a01417 	ldw	r2,-32688(gp)
81137c20:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
81137c24:	d0a08917 	ldw	r2,-32220(gp)
81137c28:	10800044 	addi	r2,r2,1
81137c2c:	d0a08915 	stw	r2,-32220(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
81137c30:	00002e06 	br	81137cec <alt_tick+0xe8>
  {
    next = (alt_alarm*) alarm->llist.next;
81137c34:	e0bffd17 	ldw	r2,-12(fp)
81137c38:	10800017 	ldw	r2,0(r2)
81137c3c:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
81137c40:	e0bffd17 	ldw	r2,-12(fp)
81137c44:	10800403 	ldbu	r2,16(r2)
81137c48:	10803fcc 	andi	r2,r2,255
81137c4c:	10000426 	beq	r2,zero,81137c60 <alt_tick+0x5c>
81137c50:	d0a08917 	ldw	r2,-32220(gp)
81137c54:	1000021e 	bne	r2,zero,81137c60 <alt_tick+0x5c>
    {
      alarm->rollover = 0;
81137c58:	e0bffd17 	ldw	r2,-12(fp)
81137c5c:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
81137c60:	e0bffd17 	ldw	r2,-12(fp)
81137c64:	10800217 	ldw	r2,8(r2)
81137c68:	d0e08917 	ldw	r3,-32220(gp)
81137c6c:	18801d36 	bltu	r3,r2,81137ce4 <alt_tick+0xe0>
81137c70:	e0bffd17 	ldw	r2,-12(fp)
81137c74:	10800403 	ldbu	r2,16(r2)
81137c78:	10803fcc 	andi	r2,r2,255
81137c7c:	1000191e 	bne	r2,zero,81137ce4 <alt_tick+0xe0>
    {
      next_callback = alarm->callback (alarm->context);
81137c80:	e0bffd17 	ldw	r2,-12(fp)
81137c84:	10800317 	ldw	r2,12(r2)
81137c88:	e0fffd17 	ldw	r3,-12(fp)
81137c8c:	18c00517 	ldw	r3,20(r3)
81137c90:	1809883a 	mov	r4,r3
81137c94:	103ee83a 	callr	r2
81137c98:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
81137c9c:	e0bfff17 	ldw	r2,-4(fp)
81137ca0:	1000031e 	bne	r2,zero,81137cb0 <alt_tick+0xac>
      {
        alt_alarm_stop (alarm);
81137ca4:	e13ffd17 	ldw	r4,-12(fp)
81137ca8:	1137b600 	call	81137b60 <alt_alarm_stop>
81137cac:	00000d06 	br	81137ce4 <alt_tick+0xe0>
      }
      else
      {
        alarm->time += next_callback;
81137cb0:	e0bffd17 	ldw	r2,-12(fp)
81137cb4:	10c00217 	ldw	r3,8(r2)
81137cb8:	e0bfff17 	ldw	r2,-4(fp)
81137cbc:	1887883a 	add	r3,r3,r2
81137cc0:	e0bffd17 	ldw	r2,-12(fp)
81137cc4:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
81137cc8:	e0bffd17 	ldw	r2,-12(fp)
81137ccc:	10c00217 	ldw	r3,8(r2)
81137cd0:	d0a08917 	ldw	r2,-32220(gp)
81137cd4:	1880032e 	bgeu	r3,r2,81137ce4 <alt_tick+0xe0>
        {
          alarm->rollover = 1;
81137cd8:	e0bffd17 	ldw	r2,-12(fp)
81137cdc:	00c00044 	movi	r3,1
81137ce0:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
81137ce4:	e0bffe17 	ldw	r2,-8(fp)
81137ce8:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
81137cec:	e0fffd17 	ldw	r3,-12(fp)
81137cf0:	d0a01404 	addi	r2,gp,-32688
81137cf4:	18bfcf1e 	bne	r3,r2,81137c34 <__reset+0xfb117c34>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
81137cf8:	1138f340 	call	81138f34 <OSTimeTick>
}
81137cfc:	0001883a 	nop
81137d00:	e037883a 	mov	sp,fp
81137d04:	dfc00117 	ldw	ra,4(sp)
81137d08:	df000017 	ldw	fp,0(sp)
81137d0c:	dec00204 	addi	sp,sp,8
81137d10:	f800283a 	ret

81137d14 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
81137d14:	defffb04 	addi	sp,sp,-20
81137d18:	de00012e 	bgeu	sp,et,81137d20 <usleep+0xc>
81137d1c:	003b68fa 	trap	3
81137d20:	dfc00415 	stw	ra,16(sp)
81137d24:	df000315 	stw	fp,12(sp)
81137d28:	df000304 	addi	fp,sp,12
81137d2c:	e13fff15 	stw	r4,-4(fp)
   * If the O/S hasn't started yet, then we delay using a busy loop, rather than
   * OSTimeDly (since this would fail). The use of a busy loop is acceptable,
   * since the system is still running in a single-threaded mode.
   */ 

  if (OSRunning == OS_FALSE)
81137d30:	d0a09103 	ldbu	r2,-32188(gp)
81137d34:	10803fcc 	andi	r2,r2,255
81137d38:	1000031e 	bne	r2,zero,81137d48 <usleep+0x34>
  {
    return alt_busy_sleep (us);
81137d3c:	e13fff17 	ldw	r4,-4(fp)
81137d40:	11362a00 	call	811362a0 <alt_busy_sleep>
81137d44:	00003d06 	br	81137e3c <usleep+0x128>
81137d48:	d0a08817 	ldw	r2,-32224(gp)

  /* 
   * Calculate the number of whole system clock ticks to delay.
   */

  tick_rate = alt_ticks_per_second ();
81137d4c:	e0bffe15 	stw	r2,-8(fp)
  ticks     = (us/ALT_US)* tick_rate + ((us%ALT_US)*tick_rate)/ALT_US;
81137d50:	e0ffff17 	ldw	r3,-4(fp)
81137d54:	0090c734 	movhi	r2,17180
81137d58:	10b7a0c4 	addi	r2,r2,-8573
81137d5c:	1888383a 	mulxuu	r4,r3,r2
81137d60:	1885383a 	mul	r2,r3,r2
81137d64:	1013883a 	mov	r9,r2
81137d68:	2015883a 	mov	r10,r4
81137d6c:	5006d4ba 	srli	r3,r10,18
81137d70:	e0bffe17 	ldw	r2,-8(fp)
81137d74:	1893383a 	mul	r9,r3,r2
81137d78:	e0ffff17 	ldw	r3,-4(fp)
81137d7c:	0090c734 	movhi	r2,17180
81137d80:	10b7a0c4 	addi	r2,r2,-8573
81137d84:	1888383a 	mulxuu	r4,r3,r2
81137d88:	1885383a 	mul	r2,r3,r2
81137d8c:	100f883a 	mov	r7,r2
81137d90:	2011883a 	mov	r8,r4
81137d94:	4004d4ba 	srli	r2,r8,18
81137d98:	010003f4 	movhi	r4,15
81137d9c:	21109004 	addi	r4,r4,16960
81137da0:	1105383a 	mul	r2,r2,r4
81137da4:	1885c83a 	sub	r2,r3,r2
81137da8:	e0fffe17 	ldw	r3,-8(fp)
81137dac:	10c7383a 	mul	r3,r2,r3
81137db0:	0090c734 	movhi	r2,17180
81137db4:	10b7a0c4 	addi	r2,r2,-8573
81137db8:	1888383a 	mulxuu	r4,r3,r2
81137dbc:	1885383a 	mul	r2,r3,r2
81137dc0:	100b883a 	mov	r5,r2
81137dc4:	200d883a 	mov	r6,r4
81137dc8:	3004d4ba 	srli	r2,r6,18
81137dcc:	4885883a 	add	r2,r9,r2
81137dd0:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
81137dd4:	00000706 	br	81137df4 <usleep+0xe0>
  {
    OSTimeDly(0xffff);
81137dd8:	013fffd4 	movui	r4,65535
81137ddc:	11409a40 	call	811409a4 <OSTimeDly>
    ticks -= 0xffff;
81137de0:	e0fffd17 	ldw	r3,-12(fp)
81137de4:	00bffff4 	movhi	r2,65535
81137de8:	10800044 	addi	r2,r2,1
81137dec:	1885883a 	add	r2,r3,r2
81137df0:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
81137df4:	e0bffd17 	ldw	r2,-12(fp)
81137df8:	00ffffd4 	movui	r3,65535
81137dfc:	18bff636 	bltu	r3,r2,81137dd8 <__reset+0xfb117dd8>
  {
    OSTimeDly(0xffff);
    ticks -= 0xffff;
  }

  OSTimeDly ((INT16U) (ticks));
81137e00:	e0bffd17 	ldw	r2,-12(fp)
81137e04:	10bfffcc 	andi	r2,r2,65535
81137e08:	1009883a 	mov	r4,r2
81137e0c:	11409a40 	call	811409a4 <OSTimeDly>
  /*
   * Now delay by the remainder using a busy loop. This is here in order to
   * provide very short delays of less than one clock tick.
   */

  alt_busy_sleep (us%(ALT_US/tick_rate));  
81137e10:	008003f4 	movhi	r2,15
81137e14:	10909004 	addi	r2,r2,16960
81137e18:	e0fffe17 	ldw	r3,-8(fp)
81137e1c:	10c7203a 	divu	r3,r2,r3
81137e20:	e0bfff17 	ldw	r2,-4(fp)
81137e24:	10c9203a 	divu	r4,r2,r3
81137e28:	20c7383a 	mul	r3,r4,r3
81137e2c:	10c5c83a 	sub	r2,r2,r3
81137e30:	1009883a 	mov	r4,r2
81137e34:	11362a00 	call	811362a0 <alt_busy_sleep>

  return 0;  
81137e38:	0005883a 	mov	r2,zero
}
81137e3c:	e037883a 	mov	sp,fp
81137e40:	dfc00117 	ldw	ra,4(sp)
81137e44:	df000017 	ldw	fp,0(sp)
81137e48:	dec00204 	addi	sp,sp,8
81137e4c:	f800283a 	ret

81137e50 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81137e50:	defffe04 	addi	sp,sp,-8
81137e54:	de00012e 	bgeu	sp,et,81137e5c <alt_get_errno+0xc>
81137e58:	003b68fa 	trap	3
81137e5c:	dfc00115 	stw	ra,4(sp)
81137e60:	df000015 	stw	fp,0(sp)
81137e64:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81137e68:	d0a01017 	ldw	r2,-32704(gp)
81137e6c:	10000326 	beq	r2,zero,81137e7c <alt_get_errno+0x2c>
81137e70:	d0a01017 	ldw	r2,-32704(gp)
81137e74:	103ee83a 	callr	r2
81137e78:	00000106 	br	81137e80 <alt_get_errno+0x30>
81137e7c:	d0a07804 	addi	r2,gp,-32288
}
81137e80:	e037883a 	mov	sp,fp
81137e84:	dfc00117 	ldw	ra,4(sp)
81137e88:	df000017 	ldw	fp,0(sp)
81137e8c:	dec00204 	addi	sp,sp,8
81137e90:	f800283a 	ret

81137e94 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
81137e94:	defff904 	addi	sp,sp,-28
81137e98:	de00012e 	bgeu	sp,et,81137ea0 <write+0xc>
81137e9c:	003b68fa 	trap	3
81137ea0:	dfc00615 	stw	ra,24(sp)
81137ea4:	df000515 	stw	fp,20(sp)
81137ea8:	df000504 	addi	fp,sp,20
81137eac:	e13ffd15 	stw	r4,-12(fp)
81137eb0:	e17ffe15 	stw	r5,-8(fp)
81137eb4:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81137eb8:	e0bffd17 	ldw	r2,-12(fp)
81137ebc:	10000616 	blt	r2,zero,81137ed8 <write+0x44>
81137ec0:	e0bffd17 	ldw	r2,-12(fp)
81137ec4:	10c00324 	muli	r3,r2,12
81137ec8:	00a04574 	movhi	r2,33045
81137ecc:	1087f704 	addi	r2,r2,8156
81137ed0:	1885883a 	add	r2,r3,r2
81137ed4:	00000106 	br	81137edc <write+0x48>
81137ed8:	0005883a 	mov	r2,zero
81137edc:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
81137ee0:	e0bffb17 	ldw	r2,-20(fp)
81137ee4:	10002426 	beq	r2,zero,81137f78 <write+0xe4>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
81137ee8:	e0bffb17 	ldw	r2,-20(fp)
81137eec:	10800217 	ldw	r2,8(r2)
81137ef0:	108000cc 	andi	r2,r2,3
81137ef4:	10001b26 	beq	r2,zero,81137f64 <write+0xd0>
81137ef8:	e0bffb17 	ldw	r2,-20(fp)
81137efc:	10800017 	ldw	r2,0(r2)
81137f00:	10800617 	ldw	r2,24(r2)
81137f04:	10001726 	beq	r2,zero,81137f64 <write+0xd0>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);
81137f08:	e17fff17 	ldw	r5,-4(fp)
81137f0c:	e13ffe17 	ldw	r4,-8(fp)
81137f10:	11372140 	call	81137214 <alt_log_write>

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
81137f14:	e0bffb17 	ldw	r2,-20(fp)
81137f18:	10800017 	ldw	r2,0(r2)
81137f1c:	10800617 	ldw	r2,24(r2)
81137f20:	e0ffff17 	ldw	r3,-4(fp)
81137f24:	180d883a 	mov	r6,r3
81137f28:	e17ffe17 	ldw	r5,-8(fp)
81137f2c:	e13ffb17 	ldw	r4,-20(fp)
81137f30:	103ee83a 	callr	r2
81137f34:	e0bffc15 	stw	r2,-16(fp)
81137f38:	e0bffc17 	ldw	r2,-16(fp)
81137f3c:	1000070e 	bge	r2,zero,81137f5c <write+0xc8>
      {
        ALT_ERRNO = -rval;
81137f40:	1137e500 	call	81137e50 <alt_get_errno>
81137f44:	1007883a 	mov	r3,r2
81137f48:	e0bffc17 	ldw	r2,-16(fp)
81137f4c:	0085c83a 	sub	r2,zero,r2
81137f50:	18800015 	stw	r2,0(r3)
        return -1;
81137f54:	00bfffc4 	movi	r2,-1
81137f58:	00000c06 	br	81137f8c <write+0xf8>
      }
      return rval;
81137f5c:	e0bffc17 	ldw	r2,-16(fp)
81137f60:	00000a06 	br	81137f8c <write+0xf8>
    }
    else
    {
      ALT_ERRNO = EACCES;
81137f64:	1137e500 	call	81137e50 <alt_get_errno>
81137f68:	1007883a 	mov	r3,r2
81137f6c:	00800344 	movi	r2,13
81137f70:	18800015 	stw	r2,0(r3)
81137f74:	00000406 	br	81137f88 <write+0xf4>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
81137f78:	1137e500 	call	81137e50 <alt_get_errno>
81137f7c:	1007883a 	mov	r3,r2
81137f80:	00801444 	movi	r2,81
81137f84:	18800015 	stw	r2,0(r3)
  }
  return -1;
81137f88:	00bfffc4 	movi	r2,-1
}
81137f8c:	e037883a 	mov	sp,fp
81137f90:	dfc00117 	ldw	ra,4(sp)
81137f94:	df000017 	ldw	fp,0(sp)
81137f98:	dec00204 	addi	sp,sp,8
81137f9c:	f800283a 	ret

81137fa0 <__env_lock>:
/*
 *
 */

void __env_lock ( struct _reent *_r )
{
81137fa0:	deffde04 	addi	sp,sp,-136
81137fa4:	de00012e 	bgeu	sp,et,81137fac <__env_lock+0xc>
81137fa8:	003b68fa 	trap	3
81137fac:	dfc02115 	stw	ra,132(sp)
81137fb0:	df002015 	stw	fp,128(sp)
81137fb4:	df002004 	addi	fp,sp,128
81137fb8:	e13fff15 	stw	r4,-4(fp)
  INT8U err;
  int id;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
81137fbc:	e0bfe104 	addi	r2,fp,-124
81137fc0:	100b883a 	mov	r5,r2
81137fc4:	01003fc4 	movi	r4,255
81137fc8:	11408000 	call	81140800 <OSTaskQuery>
81137fcc:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
81137fd0:	e0bffe83 	ldbu	r2,-6(fp)
81137fd4:	10803fcc 	andi	r2,r2,255
81137fd8:	10001e1e 	bne	r2,zero,81138054 <__env_lock+0xb4>
    return;

  id = tcb.OSTCBPrio;
81137fdc:	e0bfed83 	ldbu	r2,-74(fp)
81137fe0:	10803fcc 	andi	r2,r2,255
81137fe4:	e0bfe015 	stw	r2,-128(fp)
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
81137fe8:	d0a08b17 	ldw	r2,-32212(gp)
81137fec:	e0fffc04 	addi	r3,fp,-16
81137ff0:	180b883a 	mov	r5,r3
81137ff4:	1009883a 	mov	r4,r2
81137ff8:	113efb80 	call	8113efb8 <OSSemQuery>
  if( semdata.OSEventGrp && id == lockid ) 
81137ffc:	e0bffe03 	ldbu	r2,-8(fp)
81138000:	10803fcc 	andi	r2,r2,255
81138004:	10000726 	beq	r2,zero,81138024 <__env_lock+0x84>
81138008:	d0a01617 	ldw	r2,-32680(gp)
8113800c:	e0ffe017 	ldw	r3,-128(fp)
81138010:	1880041e 	bne	r3,r2,81138024 <__env_lock+0x84>
  {
    /* we do; just count the recursion */

    locks++;
81138014:	d0a08a17 	ldw	r2,-32216(gp)
81138018:	10800044 	addi	r2,r2,1
8113801c:	d0a08a15 	stw	r2,-32216(gp)
81138020:	00000a06 	br	8113804c <__env_lock+0xac>
  }
  else 
  {
    /* wait on the other task to yield, then claim ownership */

    OSSemPend( alt_envsem, 0, &err );
81138024:	d0a08b17 	ldw	r2,-32212(gp)
81138028:	e0fffe84 	addi	r3,fp,-6
8113802c:	180d883a 	mov	r6,r3
81138030:	000b883a 	mov	r5,zero
81138034:	1009883a 	mov	r4,r2
81138038:	113eb180 	call	8113eb18 <OSSemPend>
    locks  = 1;
8113803c:	00800044 	movi	r2,1
81138040:	d0a08a15 	stw	r2,-32216(gp)
    lockid = id;
81138044:	e0bfe017 	ldw	r2,-128(fp)
81138048:	d0a01615 	stw	r2,-32680(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
8113804c:	0001883a 	nop
81138050:	00000106 	br	81138058 <__env_lock+0xb8>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
81138054:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
81138058:	e037883a 	mov	sp,fp
8113805c:	dfc00117 	ldw	ra,4(sp)
81138060:	df000017 	ldw	fp,0(sp)
81138064:	dec00204 	addi	sp,sp,8
81138068:	f800283a 	ret

8113806c <__env_unlock>:
/*
 *
 */

void __env_unlock ( struct _reent *_r )
{
8113806c:	defffd04 	addi	sp,sp,-12
81138070:	de00012e 	bgeu	sp,et,81138078 <__env_unlock+0xc>
81138074:	003b68fa 	trap	3
81138078:	dfc00215 	stw	ra,8(sp)
8113807c:	df000115 	stw	fp,4(sp)
81138080:	df000104 	addi	fp,sp,4
81138084:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
81138088:	d0a08a17 	ldw	r2,-32216(gp)
8113808c:	10000b26 	beq	r2,zero,811380bc <__env_unlock+0x50>
   /* 
    * release the environment once the number of locks == the number 
    * of unlocks 
    */

  if( (--locks) == 0 ) 
81138090:	d0a08a17 	ldw	r2,-32216(gp)
81138094:	10bfffc4 	addi	r2,r2,-1
81138098:	d0a08a15 	stw	r2,-32216(gp)
8113809c:	d0a08a17 	ldw	r2,-32216(gp)
811380a0:	1000071e 	bne	r2,zero,811380c0 <__env_unlock+0x54>
  {
    lockid = -1;
811380a4:	00bfffc4 	movi	r2,-1
811380a8:	d0a01615 	stw	r2,-32680(gp)
    OSSemPost( alt_envsem );
811380ac:	d0a08b17 	ldw	r2,-32212(gp)
811380b0:	1009883a 	mov	r4,r2
811380b4:	113eea00 	call	8113eea0 <OSSemPost>
811380b8:	00000106 	br	811380c0 <__env_unlock+0x54>

void __env_unlock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
    return;
811380bc:	0001883a 	nop
  {
    lockid = -1;
    OSSemPost( alt_envsem );
  }
#endif /* OS_THREAD_SAFE_NEWLIB */
}
811380c0:	e037883a 	mov	sp,fp
811380c4:	dfc00117 	ldw	ra,4(sp)
811380c8:	df000017 	ldw	fp,0(sp)
811380cc:	dec00204 	addi	sp,sp,8
811380d0:	f800283a 	ret

811380d4 <__malloc_lock>:
/*
 *
 */

void __malloc_lock ( struct _reent *_r )
{
811380d4:	deffda04 	addi	sp,sp,-152
811380d8:	de00012e 	bgeu	sp,et,811380e0 <__malloc_lock+0xc>
811380dc:	003b68fa 	trap	3
811380e0:	dfc02515 	stw	ra,148(sp)
811380e4:	df002415 	stw	fp,144(sp)
811380e8:	df002404 	addi	fp,sp,144
811380ec:	e13fff15 	stw	r4,-4(fp)
  OS_TCB tcb;
  OS_SEM_DATA semdata;
  INT8U err;
  int id;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811380f0:	e03fdc15 	stw	zero,-144(fp)
#endif  
  
  if (OSRunning != OS_TRUE)
811380f4:	d0a09103 	ldbu	r2,-32188(gp)
811380f8:	10803fcc 	andi	r2,r2,255
811380fc:	10800060 	cmpeqi	r2,r2,1
81138100:	10003626 	beq	r2,zero,811381dc <__malloc_lock+0x108>
      return;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
81138104:	e0bfe104 	addi	r2,fp,-124
81138108:	100b883a 	mov	r5,r2
8113810c:	01003fc4 	movi	r4,255
81138110:	11408000 	call	81140800 <OSTaskQuery>
81138114:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
81138118:	e0bffe83 	ldbu	r2,-6(fp)
8113811c:	10803fcc 	andi	r2,r2,255
81138120:	1000301e 	bne	r2,zero,811381e4 <__malloc_lock+0x110>
    return;

  id = tcb.OSTCBPrio;
81138124:	e0bfed83 	ldbu	r2,-74(fp)
81138128:	10803fcc 	andi	r2,r2,255
8113812c:	e0bfdd15 	stw	r2,-140(fp)
   
  /* see if we own the heap already */

  OSSemQuery( alt_heapsem, &semdata );
81138130:	d0a08d17 	ldw	r2,-32204(gp)
81138134:	e0fffc04 	addi	r3,fp,-16
81138138:	180b883a 	mov	r5,r3
8113813c:	1009883a 	mov	r4,r2
81138140:	113efb80 	call	8113efb8 <OSSemQuery>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138144:	0005303a 	rdctl	r2,status
81138148:	e0bfe015 	stw	r2,-128(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113814c:	e0ffe017 	ldw	r3,-128(fp)
81138150:	00bfff84 	movi	r2,-2
81138154:	1884703a 	and	r2,r3,r2
81138158:	1001703a 	wrctl	status,r2
  
  return context;
8113815c:	e0bfe017 	ldw	r2,-128(fp)
  
  OS_ENTER_CRITICAL();
81138160:	e0bfdc15 	stw	r2,-144(fp)

  if( !semdata.OSCnt && id == lockid ) 
81138164:	e0bffc0b 	ldhu	r2,-16(fp)
81138168:	10bfffcc 	andi	r2,r2,65535
8113816c:	10000b1e 	bne	r2,zero,8113819c <__malloc_lock+0xc8>
81138170:	d0a01717 	ldw	r2,-32676(gp)
81138174:	e0ffdd17 	ldw	r3,-140(fp)
81138178:	1880081e 	bne	r3,r2,8113819c <__malloc_lock+0xc8>
  {
    /* we do; just count the recursion */
    locks++;
8113817c:	d0a08c17 	ldw	r2,-32208(gp)
81138180:	10800044 	addi	r2,r2,1
81138184:	d0a08c15 	stw	r2,-32208(gp)
81138188:	e0bfdc17 	ldw	r2,-144(fp)
8113818c:	e0bfde15 	stw	r2,-136(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138190:	e0bfde17 	ldw	r2,-136(fp)
81138194:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
81138198:	00000e06 	br	811381d4 <__malloc_lock+0x100>
8113819c:	e0bfdc17 	ldw	r2,-144(fp)
811381a0:	e0bfdf15 	stw	r2,-132(fp)
811381a4:	e0bfdf17 	ldw	r2,-132(fp)
811381a8:	1001703a 	wrctl	status,r2
  else 
  {
    /* wait on the other task to yield the heap, then claim ownership of it */
    OS_EXIT_CRITICAL();

    OSSemPend( alt_heapsem, 0, &err );
811381ac:	d0a08d17 	ldw	r2,-32204(gp)
811381b0:	e0fffe84 	addi	r3,fp,-6
811381b4:	180d883a 	mov	r6,r3
811381b8:	000b883a 	mov	r5,zero
811381bc:	1009883a 	mov	r4,r2
811381c0:	113eb180 	call	8113eb18 <OSSemPend>
    locks  = 1;
811381c4:	00800044 	movi	r2,1
811381c8:	d0a08c15 	stw	r2,-32208(gp)
    lockid = id;
811381cc:	e0bfdd17 	ldw	r2,-140(fp)
811381d0:	d0a01715 	stw	r2,-32676(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
811381d4:	0001883a 	nop
811381d8:	00000306 	br	811381e8 <__malloc_lock+0x114>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif  
  
  if (OSRunning != OS_TRUE)
      return;
811381dc:	0001883a 	nop
811381e0:	00000106 	br	811381e8 <__malloc_lock+0x114>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
811381e4:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
811381e8:	e037883a 	mov	sp,fp
811381ec:	dfc00117 	ldw	ra,4(sp)
811381f0:	df000017 	ldw	fp,0(sp)
811381f4:	dec00204 	addi	sp,sp,8
811381f8:	f800283a 	ret

811381fc <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
811381fc:	defff804 	addi	sp,sp,-32
81138200:	de00012e 	bgeu	sp,et,81138208 <__malloc_unlock+0xc>
81138204:	003b68fa 	trap	3
81138208:	dfc00715 	stw	ra,28(sp)
8113820c:	df000615 	stw	fp,24(sp)
81138210:	df000604 	addi	fp,sp,24
81138214:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB

#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81138218:	e03ffa15 	stw	zero,-24(fp)
#endif 

  if (OSRunning != OS_TRUE)
8113821c:	d0a09103 	ldbu	r2,-32188(gp)
81138220:	10803fcc 	andi	r2,r2,255
81138224:	10800060 	cmpeqi	r2,r2,1
81138228:	10002326 	beq	r2,zero,811382b8 <__malloc_unlock+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113822c:	0005303a 	rdctl	r2,status
81138230:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138234:	e0fffe17 	ldw	r3,-8(fp)
81138238:	00bfff84 	movi	r2,-2
8113823c:	1884703a 	and	r2,r3,r2
81138240:	1001703a 	wrctl	status,r2
  
  return context;
81138244:	e0bffe17 	ldw	r2,-8(fp)
      return;

  OS_ENTER_CRITICAL();
81138248:	e0bffa15 	stw	r2,-24(fp)
  if (locks == 0)
8113824c:	d0a08c17 	ldw	r2,-32208(gp)
81138250:	1000051e 	bne	r2,zero,81138268 <__malloc_unlock+0x6c>
81138254:	e0bffa17 	ldw	r2,-24(fp)
81138258:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113825c:	e0bffb17 	ldw	r2,-20(fp)
81138260:	1001703a 	wrctl	status,r2
  {
      OS_EXIT_CRITICAL();
      return;
81138264:	00001506 	br	811382bc <__malloc_unlock+0xc0>
  }

  /* release the heap once the number of locks == the number of unlocks */
  if( (--locks) == 0 ) 
81138268:	d0a08c17 	ldw	r2,-32208(gp)
8113826c:	10bfffc4 	addi	r2,r2,-1
81138270:	d0a08c15 	stw	r2,-32208(gp)
81138274:	d0a08c17 	ldw	r2,-32208(gp)
81138278:	10000a1e 	bne	r2,zero,811382a4 <__malloc_unlock+0xa8>
  {
    lockid = -1;
8113827c:	00bfffc4 	movi	r2,-1
81138280:	d0a01715 	stw	r2,-32676(gp)
81138284:	e0bffa17 	ldw	r2,-24(fp)
81138288:	e0bffc15 	stw	r2,-16(fp)
8113828c:	e0bffc17 	ldw	r2,-16(fp)
81138290:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSSemPost( alt_heapsem );
81138294:	d0a08d17 	ldw	r2,-32204(gp)
81138298:	1009883a 	mov	r4,r2
8113829c:	113eea00 	call	8113eea0 <OSSemPost>
811382a0:	00000606 	br	811382bc <__malloc_unlock+0xc0>
811382a4:	e0bffa17 	ldw	r2,-24(fp)
811382a8:	e0bffd15 	stw	r2,-12(fp)
811382ac:	e0bffd17 	ldw	r2,-12(fp)
811382b0:	1001703a 	wrctl	status,r2
811382b4:	00000106 	br	811382bc <__malloc_unlock+0xc0>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif 

  if (OSRunning != OS_TRUE)
      return;
811382b8:	0001883a 	nop
  {
      OS_EXIT_CRITICAL();
  }
  
#endif /* OS_THREAD_SAFE_NEWLIB */
}
811382bc:	e037883a 	mov	sp,fp
811382c0:	dfc00117 	ldw	ra,4(sp)
811382c4:	df000017 	ldw	fp,0(sp)
811382c8:	dec00204 	addi	sp,sp,8
811382cc:	f800283a 	ret

811382d0 <OSEventNameGet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
811382d0:	defff704 	addi	sp,sp,-36
811382d4:	de00012e 	bgeu	sp,et,811382dc <OSEventNameGet+0xc>
811382d8:	003b68fa 	trap	3
811382dc:	dfc00815 	stw	ra,32(sp)
811382e0:	df000715 	stw	fp,28(sp)
811382e4:	df000704 	addi	fp,sp,28
811382e8:	e13ffd15 	stw	r4,-12(fp)
811382ec:	e17ffe15 	stw	r5,-8(fp)
811382f0:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811382f4:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
811382f8:	e0bfff17 	ldw	r2,-4(fp)
811382fc:	1000021e 	bne	r2,zero,81138308 <OSEventNameGet+0x38>
        return (0);
81138300:	0005883a 	mov	r2,zero
81138304:	00003706 	br	811383e4 <OSEventNameGet+0x114>
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
81138308:	e0bffd17 	ldw	r2,-12(fp)
8113830c:	1000051e 	bne	r2,zero,81138324 <OSEventNameGet+0x54>
        *perr = OS_ERR_PEVENT_NULL;
81138310:	e0bfff17 	ldw	r2,-4(fp)
81138314:	00c00104 	movi	r3,4
81138318:	10c00005 	stb	r3,0(r2)
        return (0);
8113831c:	0005883a 	mov	r2,zero
81138320:	00003006 	br	811383e4 <OSEventNameGet+0x114>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81138324:	e0bffe17 	ldw	r2,-8(fp)
81138328:	1000051e 	bne	r2,zero,81138340 <OSEventNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
8113832c:	e0bfff17 	ldw	r2,-4(fp)
81138330:	00c00304 	movi	r3,12
81138334:	10c00005 	stb	r3,0(r2)
        return (0);
81138338:	0005883a 	mov	r2,zero
8113833c:	00002906 	br	811383e4 <OSEventNameGet+0x114>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81138340:	d0a0a103 	ldbu	r2,-32124(gp)
81138344:	10803fcc 	andi	r2,r2,255
81138348:	10000526 	beq	r2,zero,81138360 <OSEventNameGet+0x90>
        *perr  = OS_ERR_NAME_GET_ISR;
8113834c:	e0bfff17 	ldw	r2,-4(fp)
81138350:	00c00444 	movi	r3,17
81138354:	10c00005 	stb	r3,0(r2)
        return (0);
81138358:	0005883a 	mov	r2,zero
8113835c:	00002106 	br	811383e4 <OSEventNameGet+0x114>
    }
    switch (pevent->OSEventType) {
81138360:	e0bffd17 	ldw	r2,-12(fp)
81138364:	10800003 	ldbu	r2,0(r2)
81138368:	10803fcc 	andi	r2,r2,255
8113836c:	10bfffc4 	addi	r2,r2,-1
81138370:	10800128 	cmpgeui	r2,r2,4
81138374:	10000526 	beq	r2,zero,8113838c <OSEventNameGet+0xbc>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
81138378:	e0bfff17 	ldw	r2,-4(fp)
8113837c:	00c00044 	movi	r3,1
81138380:	10c00005 	stb	r3,0(r2)
             return (0);
81138384:	0005883a 	mov	r2,zero
81138388:	00001606 	br	811383e4 <OSEventNameGet+0x114>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
8113838c:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138390:	0005303a 	rdctl	r2,status
81138394:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138398:	e0fffb17 	ldw	r3,-20(fp)
8113839c:	00bfff84 	movi	r2,-2
811383a0:	1884703a 	and	r2,r3,r2
811383a4:	1001703a 	wrctl	status,r2
  
  return context;
811383a8:	e0bffb17 	ldw	r2,-20(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return (0);
    }
    OS_ENTER_CRITICAL();
811383ac:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
811383b0:	e0bffd17 	ldw	r2,-12(fp)
811383b4:	10800444 	addi	r2,r2,17
811383b8:	100b883a 	mov	r5,r2
811383bc:	e13ffe17 	ldw	r4,-8(fp)
811383c0:	1139dbc0 	call	81139dbc <OS_StrCopy>
811383c4:	e0bffa05 	stb	r2,-24(fp)
811383c8:	e0bff917 	ldw	r2,-28(fp)
811383cc:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811383d0:	e0bffc17 	ldw	r2,-16(fp)
811383d4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
811383d8:	e0bfff17 	ldw	r2,-4(fp)
811383dc:	10000005 	stb	zero,0(r2)
    return (len);
811383e0:	e0bffa03 	ldbu	r2,-24(fp)
}
811383e4:	e037883a 	mov	sp,fp
811383e8:	dfc00117 	ldw	ra,4(sp)
811383ec:	df000017 	ldw	fp,0(sp)
811383f0:	dec00204 	addi	sp,sp,8
811383f4:	f800283a 	ret

811383f8 <OSEventNameSet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
811383f8:	defff604 	addi	sp,sp,-40
811383fc:	de00012e 	bgeu	sp,et,81138404 <OSEventNameSet+0xc>
81138400:	003b68fa 	trap	3
81138404:	dfc00915 	stw	ra,36(sp)
81138408:	df000815 	stw	fp,32(sp)
8113840c:	df000804 	addi	fp,sp,32
81138410:	e13ffd15 	stw	r4,-12(fp)
81138414:	e17ffe15 	stw	r5,-8(fp)
81138418:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113841c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81138420:	e0bfff17 	ldw	r2,-4(fp)
81138424:	10004026 	beq	r2,zero,81138528 <OSEventNameSet+0x130>
        return;
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
81138428:	e0bffd17 	ldw	r2,-12(fp)
8113842c:	1000041e 	bne	r2,zero,81138440 <OSEventNameSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
81138430:	e0bfff17 	ldw	r2,-4(fp)
81138434:	00c00104 	movi	r3,4
81138438:	10c00005 	stb	r3,0(r2)
        return;
8113843c:	00003b06 	br	8113852c <OSEventNameSet+0x134>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81138440:	e0bffe17 	ldw	r2,-8(fp)
81138444:	1000041e 	bne	r2,zero,81138458 <OSEventNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
81138448:	e0bfff17 	ldw	r2,-4(fp)
8113844c:	00c00304 	movi	r3,12
81138450:	10c00005 	stb	r3,0(r2)
        return;
81138454:	00003506 	br	8113852c <OSEventNameSet+0x134>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81138458:	d0a0a103 	ldbu	r2,-32124(gp)
8113845c:	10803fcc 	andi	r2,r2,255
81138460:	10000426 	beq	r2,zero,81138474 <OSEventNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
81138464:	e0bfff17 	ldw	r2,-4(fp)
81138468:	00c00484 	movi	r3,18
8113846c:	10c00005 	stb	r3,0(r2)
        return;
81138470:	00002e06 	br	8113852c <OSEventNameSet+0x134>
    }
    switch (pevent->OSEventType) {
81138474:	e0bffd17 	ldw	r2,-12(fp)
81138478:	10800003 	ldbu	r2,0(r2)
8113847c:	10803fcc 	andi	r2,r2,255
81138480:	10bfffc4 	addi	r2,r2,-1
81138484:	10800128 	cmpgeui	r2,r2,4
81138488:	10000426 	beq	r2,zero,8113849c <OSEventNameSet+0xa4>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
8113848c:	e0bfff17 	ldw	r2,-4(fp)
81138490:	00c00044 	movi	r3,1
81138494:	10c00005 	stb	r3,0(r2)
             return;
81138498:	00002406 	br	8113852c <OSEventNameSet+0x134>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
8113849c:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811384a0:	0005303a 	rdctl	r2,status
811384a4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811384a8:	e0fffc17 	ldw	r3,-16(fp)
811384ac:	00bfff84 	movi	r2,-2
811384b0:	1884703a 	and	r2,r3,r2
811384b4:	1001703a 	wrctl	status,r2
  
  return context;
811384b8:	e0bffc17 	ldw	r2,-16(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return;
    }
    OS_ENTER_CRITICAL();
811384bc:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
811384c0:	e13ffe17 	ldw	r4,-8(fp)
811384c4:	1139e380 	call	81139e38 <OS_StrLen>
811384c8:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
811384cc:	e0bffa03 	ldbu	r2,-24(fp)
811384d0:	10800830 	cmpltui	r2,r2,32
811384d4:	1000081e 	bne	r2,zero,811384f8 <OSEventNameSet+0x100>
811384d8:	e0bff817 	ldw	r2,-32(fp)
811384dc:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811384e0:	e0bff917 	ldw	r2,-28(fp)
811384e4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_NAME_TOO_LONG;
811384e8:	e0bfff17 	ldw	r2,-4(fp)
811384ec:	00c002c4 	movi	r3,11
811384f0:	10c00005 	stb	r3,0(r2)
        return;
811384f4:	00000d06 	br	8113852c <OSEventNameSet+0x134>
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
811384f8:	e0bffd17 	ldw	r2,-12(fp)
811384fc:	10800444 	addi	r2,r2,17
81138500:	e17ffe17 	ldw	r5,-8(fp)
81138504:	1009883a 	mov	r4,r2
81138508:	1139dbc0 	call	81139dbc <OS_StrCopy>
8113850c:	e0bff817 	ldw	r2,-32(fp)
81138510:	e0bffb15 	stw	r2,-20(fp)
81138514:	e0bffb17 	ldw	r2,-20(fp)
81138518:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113851c:	e0bfff17 	ldw	r2,-4(fp)
81138520:	10000005 	stb	zero,0(r2)
81138524:	00000106 	br	8113852c <OSEventNameSet+0x134>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
81138528:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
8113852c:	e037883a 	mov	sp,fp
81138530:	dfc00117 	ldw	ra,4(sp)
81138534:	df000017 	ldw	fp,0(sp)
81138538:	dec00204 	addi	sp,sp,8
8113853c:	f800283a 	ret

81138540 <OSEventPendMulti>:
*********************************************************************************************************
*/
/*$PAGE*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
{
81138540:	deffed04 	addi	sp,sp,-76
81138544:	de00012e 	bgeu	sp,et,8113854c <OSEventPendMulti+0xc>
81138548:	003b68fa 	trap	3
8113854c:	dfc01215 	stw	ra,72(sp)
81138550:	df001115 	stw	fp,68(sp)
81138554:	df001104 	addi	fp,sp,68
81138558:	e13ffc15 	stw	r4,-16(fp)
8113855c:	e17ffd15 	stw	r5,-12(fp)
81138560:	e1bffe15 	stw	r6,-8(fp)
81138564:	3805883a 	mov	r2,r7
81138568:	e0bfff0d 	sth	r2,-4(fp)
#endif
    BOOLEAN     events_rdy;
    INT16U      events_rdy_nbr;
    INT8U       events_stat;
#if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
    OS_CPU_SR   cpu_sr = 0;
8113856c:	e03ff315 	stw	zero,-52(fp)
#endif



#if (OS_ARG_CHK_EN > 0)
    if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
81138570:	e0800217 	ldw	r2,8(fp)
81138574:	1000021e 	bne	r2,zero,81138580 <OSEventPendMulti+0x40>
        return (0);
81138578:	0005883a 	mov	r2,zero
8113857c:	00015006 	br	81138ac0 <OSEventPendMulti+0x580>
    }
    if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
81138580:	e0bffc17 	ldw	r2,-16(fp)
81138584:	1000051e 	bne	r2,zero,8113859c <OSEventPendMulti+0x5c>
       *perr =  OS_ERR_PEVENT_NULL;
81138588:	e0800217 	ldw	r2,8(fp)
8113858c:	00c00104 	movi	r3,4
81138590:	10c00005 	stb	r3,0(r2)
        return (0);
81138594:	0005883a 	mov	r2,zero
81138598:	00014906 	br	81138ac0 <OSEventPendMulti+0x580>
    }
    if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
8113859c:	e0bffd17 	ldw	r2,-12(fp)
811385a0:	1000051e 	bne	r2,zero,811385b8 <OSEventPendMulti+0x78>
       *perr =  OS_ERR_PEVENT_NULL;
811385a4:	e0800217 	ldw	r2,8(fp)
811385a8:	00c00104 	movi	r3,4
811385ac:	10c00005 	stb	r3,0(r2)
        return (0);
811385b0:	0005883a 	mov	r2,zero
811385b4:	00014206 	br	81138ac0 <OSEventPendMulti+0x580>
    }
    if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
811385b8:	e0bffe17 	ldw	r2,-8(fp)
811385bc:	1000051e 	bne	r2,zero,811385d4 <OSEventPendMulti+0x94>
       *perr =  OS_ERR_PEVENT_NULL;
811385c0:	e0800217 	ldw	r2,8(fp)
811385c4:	00c00104 	movi	r3,4
811385c8:	10c00005 	stb	r3,0(r2)
        return (0);
811385cc:	0005883a 	mov	r2,zero
811385d0:	00013b06 	br	81138ac0 <OSEventPendMulti+0x580>
    }
#endif

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
811385d4:	e0bffd17 	ldw	r2,-12(fp)
811385d8:	10000015 	stw	zero,0(r2)

    pevents     =  pevents_pend;
811385dc:	e0bffc17 	ldw	r2,-16(fp)
811385e0:	e0bfef15 	stw	r2,-68(fp)
    pevent      = *pevents;
811385e4:	e0bfef17 	ldw	r2,-68(fp)
811385e8:	10800017 	ldw	r2,0(r2)
811385ec:	e0bff015 	stw	r2,-64(fp)
    while  (pevent != (OS_EVENT *)0) {
811385f0:	00001506 	br	81138648 <OSEventPendMulti+0x108>
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
811385f4:	e0bff017 	ldw	r2,-64(fp)
811385f8:	10800003 	ldbu	r2,0(r2)
811385fc:	10803fcc 	andi	r2,r2,255
81138600:	10c000a0 	cmpeqi	r3,r2,2
81138604:	1800071e 	bne	r3,zero,81138624 <OSEventPendMulti+0xe4>
81138608:	108000e0 	cmpeqi	r2,r2,3
8113860c:	1000071e 	bne	r2,zero,8113862c <OSEventPendMulti+0xec>
#endif

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
81138610:	e0800217 	ldw	r2,8(fp)
81138614:	00c00044 	movi	r3,1
81138618:	10c00005 	stb	r3,0(r2)
                 return (0);
8113861c:	0005883a 	mov	r2,zero
81138620:	00012706 	br	81138ac0 <OSEventPendMulti+0x580>
            case OS_EVENT_TYPE_MBOX:
                 break;
#endif
#if ((OS_Q_EN   > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 break;
81138624:	0001883a 	nop
81138628:	00000106 	br	81138630 <OSEventPendMulti+0xf0>
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
#if (OS_SEM_EN  > 0)
            case OS_EVENT_TYPE_SEM:
                 break;
8113862c:	0001883a 	nop
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
                 return (0);
        }
        pevents++;
81138630:	e0bfef17 	ldw	r2,-68(fp)
81138634:	10800104 	addi	r2,r2,4
81138638:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
8113863c:	e0bfef17 	ldw	r2,-68(fp)
81138640:	10800017 	ldw	r2,0(r2)
81138644:	e0bff015 	stw	r2,-64(fp)

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */

    pevents     =  pevents_pend;
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
81138648:	e0bff017 	ldw	r2,-64(fp)
8113864c:	103fe91e 	bne	r2,zero,811385f4 <__reset+0xfb1185f4>
        }
        pevents++;
        pevent = *pevents;
    }

    if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
81138650:	d0a0a103 	ldbu	r2,-32124(gp)
81138654:	10803fcc 	andi	r2,r2,255
81138658:	10000526 	beq	r2,zero,81138670 <OSEventPendMulti+0x130>
       *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
8113865c:	e0800217 	ldw	r2,8(fp)
81138660:	00c00084 	movi	r3,2
81138664:	10c00005 	stb	r3,0(r2)
        return (0);
81138668:	0005883a 	mov	r2,zero
8113866c:	00011406 	br	81138ac0 <OSEventPendMulti+0x580>
    }
    if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
81138670:	d0a08f03 	ldbu	r2,-32196(gp)
81138674:	10803fcc 	andi	r2,r2,255
81138678:	10000526 	beq	r2,zero,81138690 <OSEventPendMulti+0x150>
       *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
8113867c:	e0800217 	ldw	r2,8(fp)
81138680:	00c00344 	movi	r3,13
81138684:	10c00005 	stb	r3,0(r2)
        return (0);
81138688:	0005883a 	mov	r2,zero
8113868c:	00010c06 	br	81138ac0 <OSEventPendMulti+0x580>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138690:	0005303a 	rdctl	r2,status
81138694:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138698:	e0fffb17 	ldw	r3,-20(fp)
8113869c:	00bfff84 	movi	r2,-2
811386a0:	1884703a 	and	r2,r3,r2
811386a4:	1001703a 	wrctl	status,r2
  
  return context;
811386a8:	e0bffb17 	ldw	r2,-20(fp)
    }

/*$PAGE*/
    OS_ENTER_CRITICAL();
811386ac:	e0bff315 	stw	r2,-52(fp)
    events_rdy     =  OS_FALSE;
811386b0:	e03ff105 	stb	zero,-60(fp)
    events_rdy_nbr =  0;
811386b4:	e03ff18d 	sth	zero,-58(fp)
    events_stat    =  OS_STAT_RDY;
811386b8:	e03ff205 	stb	zero,-56(fp)
    pevents        =  pevents_pend;
811386bc:	e0bffc17 	ldw	r2,-16(fp)
811386c0:	e0bfef15 	stw	r2,-68(fp)
    pevent         = *pevents;
811386c4:	e0bfef17 	ldw	r2,-68(fp)
811386c8:	10800017 	ldw	r2,0(r2)
811386cc:	e0bff015 	stw	r2,-64(fp)
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
811386d0:	00006406 	br	81138864 <OSEventPendMulti+0x324>
        switch (pevent->OSEventType) {
811386d4:	e0bff017 	ldw	r2,-64(fp)
811386d8:	10800003 	ldbu	r2,0(r2)
811386dc:	10803fcc 	andi	r2,r2,255
811386e0:	10c000a0 	cmpeqi	r3,r2,2
811386e4:	18001f1e 	bne	r3,zero,81138764 <OSEventPendMulti+0x224>
811386e8:	108000e0 	cmpeqi	r2,r2,3
811386ec:	10004c26 	beq	r2,zero,81138820 <OSEventPendMulti+0x2e0>
#if (OS_SEM_EN > 0)
            case OS_EVENT_TYPE_SEM:
                 if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
811386f0:	e0bff017 	ldw	r2,-64(fp)
811386f4:	1080020b 	ldhu	r2,8(r2)
811386f8:	10bfffcc 	andi	r2,r2,65535
811386fc:	10001526 	beq	r2,zero,81138754 <OSEventPendMulti+0x214>
                     pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
81138700:	e0bff017 	ldw	r2,-64(fp)
81138704:	1080020b 	ldhu	r2,8(r2)
81138708:	10bfffc4 	addi	r2,r2,-1
8113870c:	1007883a 	mov	r3,r2
81138710:	e0bff017 	ldw	r2,-64(fp)
81138714:	10c0020d 	sth	r3,8(r2)
                    *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
81138718:	e0bffd17 	ldw	r2,-12(fp)
8113871c:	10c00104 	addi	r3,r2,4
81138720:	e0fffd15 	stw	r3,-12(fp)
81138724:	e0fff017 	ldw	r3,-64(fp)
81138728:	10c00015 	stw	r3,0(r2)
                      events_rdy   =  OS_TRUE;
8113872c:	00800044 	movi	r2,1
81138730:	e0bff105 	stb	r2,-60(fp)
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
81138734:	e0bffe17 	ldw	r2,-8(fp)
81138738:	10c00104 	addi	r3,r2,4
8113873c:	e0fffe15 	stw	r3,-8(fp)
81138740:	10000015 	stw	zero,0(r2)
                      events_rdy_nbr++;
81138744:	e0bff18b 	ldhu	r2,-58(fp)
81138748:	10800044 	addi	r2,r2,1
8113874c:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
                 }
                 break;
81138750:	00003e06 	br	8113884c <OSEventPendMulti+0x30c>
                      events_rdy   =  OS_TRUE;
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
                      events_rdy_nbr++;

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
81138754:	e0bff203 	ldbu	r2,-56(fp)
81138758:	10800054 	ori	r2,r2,1
8113875c:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
81138760:	00003a06 	br	8113884c <OSEventPendMulti+0x30c>
                 break;
#endif

#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 pq = (OS_Q *)pevent->OSEventPtr;
81138764:	e0bff017 	ldw	r2,-64(fp)
81138768:	10800117 	ldw	r2,4(r2)
8113876c:	e0bff515 	stw	r2,-44(fp)
                 if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
81138770:	e0bff517 	ldw	r2,-44(fp)
81138774:	1080058b 	ldhu	r2,22(r2)
81138778:	10bfffcc 	andi	r2,r2,65535
8113877c:	10002426 	beq	r2,zero,81138810 <OSEventPendMulti+0x2d0>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++ = (void *)*pq->OSQOut++;
81138780:	e0bffe17 	ldw	r2,-8(fp)
81138784:	10c00104 	addi	r3,r2,4
81138788:	e0fffe15 	stw	r3,-8(fp)
8113878c:	e0fff517 	ldw	r3,-44(fp)
81138790:	18c00417 	ldw	r3,16(r3)
81138794:	19400104 	addi	r5,r3,4
81138798:	e13ff517 	ldw	r4,-44(fp)
8113879c:	21400415 	stw	r5,16(r4)
811387a0:	18c00017 	ldw	r3,0(r3)
811387a4:	10c00015 	stw	r3,0(r2)
                     if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
811387a8:	e0bff517 	ldw	r2,-44(fp)
811387ac:	10c00417 	ldw	r3,16(r2)
811387b0:	e0bff517 	ldw	r2,-44(fp)
811387b4:	10800217 	ldw	r2,8(r2)
811387b8:	1880041e 	bne	r3,r2,811387cc <OSEventPendMulti+0x28c>
                         pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
811387bc:	e0bff517 	ldw	r2,-44(fp)
811387c0:	10c00117 	ldw	r3,4(r2)
811387c4:	e0bff517 	ldw	r2,-44(fp)
811387c8:	10c00415 	stw	r3,16(r2)
                     }
                     pq->OSQEntries--;                  /* Update number of queue entries              */
811387cc:	e0bff517 	ldw	r2,-44(fp)
811387d0:	1080058b 	ldhu	r2,22(r2)
811387d4:	10bfffc4 	addi	r2,r2,-1
811387d8:	1007883a 	mov	r3,r2
811387dc:	e0bff517 	ldw	r2,-44(fp)
811387e0:	10c0058d 	sth	r3,22(r2)
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
811387e4:	e0bffd17 	ldw	r2,-12(fp)
811387e8:	10c00104 	addi	r3,r2,4
811387ec:	e0fffd15 	stw	r3,-12(fp)
811387f0:	e0fff017 	ldw	r3,-64(fp)
811387f4:	10c00015 	stw	r3,0(r2)
                      events_rdy   = OS_TRUE;
811387f8:	00800044 	movi	r2,1
811387fc:	e0bff105 	stb	r2,-60(fp)
                      events_rdy_nbr++;
81138800:	e0bff18b 	ldhu	r2,-58(fp)
81138804:	10800044 	addi	r2,r2,1
81138808:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
                 }
                 break;
8113880c:	00000f06 	br	8113884c <OSEventPendMulti+0x30c>
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
                      events_rdy   = OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
81138810:	e0bff203 	ldbu	r2,-56(fp)
81138814:	10800114 	ori	r2,r2,4
81138818:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
8113881c:	00000b06 	br	8113884c <OSEventPendMulti+0x30c>
81138820:	e0bff317 	ldw	r2,-52(fp)
81138824:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138828:	e0bff417 	ldw	r2,-48(fp)
8113882c:	1001703a 	wrctl	status,r2

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                 OS_EXIT_CRITICAL();
                *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
81138830:	e0bffd17 	ldw	r2,-12(fp)
81138834:	10000015 	stw	zero,0(r2)
                *perr        =  OS_ERR_EVENT_TYPE;
81138838:	e0800217 	ldw	r2,8(fp)
8113883c:	00c00044 	movi	r3,1
81138840:	10c00005 	stb	r3,0(r2)
                 return (events_rdy_nbr);
81138844:	e0bff18b 	ldhu	r2,-58(fp)
81138848:	00009d06 	br	81138ac0 <OSEventPendMulti+0x580>
        }
        pevents++;
8113884c:	e0bfef17 	ldw	r2,-68(fp)
81138850:	10800104 	addi	r2,r2,4
81138854:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
81138858:	e0bfef17 	ldw	r2,-68(fp)
8113885c:	10800017 	ldw	r2,0(r2)
81138860:	e0bff015 	stw	r2,-64(fp)
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0;
    events_stat    =  OS_STAT_RDY;
    pevents        =  pevents_pend;
    pevent         = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
81138864:	e0bff017 	ldw	r2,-64(fp)
81138868:	103f9a1e 	bne	r2,zero,811386d4 <__reset+0xfb1186d4>
        }
        pevents++;
        pevent = *pevents;
    }

    if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
8113886c:	e0bff103 	ldbu	r2,-60(fp)
81138870:	10800058 	cmpnei	r2,r2,1
81138874:	10000a1e 	bne	r2,zero,811388a0 <OSEventPendMulti+0x360>
       *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
81138878:	e0bffd17 	ldw	r2,-12(fp)
8113887c:	10000015 	stw	zero,0(r2)
81138880:	e0bff317 	ldw	r2,-52(fp)
81138884:	e0bff615 	stw	r2,-40(fp)
81138888:	e0bff617 	ldw	r2,-40(fp)
8113888c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
       *perr        =  OS_ERR_NONE;
81138890:	e0800217 	ldw	r2,8(fp)
81138894:	10000005 	stb	zero,0(r2)
        return (events_rdy_nbr);
81138898:	e0bff18b 	ldhu	r2,-58(fp)
8113889c:	00008806 	br	81138ac0 <OSEventPendMulti+0x580>
    }
/*$PAGE*/
                                                        /* Otherwise, must wait until any event occurs */
    OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
811388a0:	d0a0a217 	ldw	r2,-32120(gp)
811388a4:	d0e0a217 	ldw	r3,-32120(gp)
811388a8:	19000c03 	ldbu	r4,48(r3)
811388ac:	e0fff203 	ldbu	r3,-56(fp)
811388b0:	20c6b03a 	or	r3,r4,r3
811388b4:	1809883a 	mov	r4,r3
811388b8:	00ffe004 	movi	r3,-128
811388bc:	20c6b03a 	or	r3,r4,r3
811388c0:	10c00c05 	stb	r3,48(r2)
                               OS_STAT_MULTI;           /* ... pend on multiple events                 */
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
811388c4:	d0a0a217 	ldw	r2,-32120(gp)
811388c8:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
811388cc:	d0a0a217 	ldw	r2,-32120(gp)
811388d0:	e0ffff0b 	ldhu	r3,-4(fp)
811388d4:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
811388d8:	e13ffc17 	ldw	r4,-16(fp)
811388dc:	11394640 	call	81139464 <OS_EventTaskWaitMulti>
811388e0:	e0bff317 	ldw	r2,-52(fp)
811388e4:	e0bff915 	stw	r2,-28(fp)
811388e8:	e0bff917 	ldw	r2,-28(fp)
811388ec:	1001703a 	wrctl	status,r2

    OS_EXIT_CRITICAL();
    OS_Sched();                                         /* Find next highest priority task ready       */
811388f0:	1139c680 	call	81139c68 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811388f4:	0005303a 	rdctl	r2,status
811388f8:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811388fc:	e0fff717 	ldw	r3,-36(fp)
81138900:	00bfff84 	movi	r2,-2
81138904:	1884703a 	and	r2,r3,r2
81138908:	1001703a 	wrctl	status,r2
  
  return context;
8113890c:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
81138910:	e0bff315 	stw	r2,-52(fp)

    switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
81138914:	d0a0a217 	ldw	r2,-32120(gp)
81138918:	10800c43 	ldbu	r2,49(r2)
8113891c:	10803fcc 	andi	r2,r2,255
81138920:	10000226 	beq	r2,zero,8113892c <OSEventPendMulti+0x3ec>
81138924:	108000a0 	cmpeqi	r2,r2,2
81138928:	10001826 	beq	r2,zero,8113898c <OSEventPendMulti+0x44c>
        case OS_STAT_PEND_OK:
        case OS_STAT_PEND_ABORT:
             pevent = OSTCBCur->OSTCBEventPtr;
8113892c:	d0a0a217 	ldw	r2,-32120(gp)
81138930:	10800717 	ldw	r2,28(r2)
81138934:	e0bff015 	stw	r2,-64(fp)
             if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
81138938:	e0bff017 	ldw	r2,-64(fp)
8113893c:	10000b26 	beq	r2,zero,8113896c <OSEventPendMulti+0x42c>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
81138940:	e0bffd17 	ldw	r2,-12(fp)
81138944:	10c00104 	addi	r3,r2,4
81138948:	e0fffd15 	stw	r3,-12(fp)
8113894c:	e0fff017 	ldw	r3,-64(fp)
81138950:	10c00015 	stw	r3,0(r2)
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
81138954:	e0bffd17 	ldw	r2,-12(fp)
81138958:	10000015 	stw	zero,0(r2)
                  events_rdy_nbr++;
8113895c:	e0bff18b 	ldhu	r2,-58(fp)
81138960:	10800044 	addi	r2,r2,1
81138964:	e0bff18d 	sth	r2,-58(fp)

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
             }
			 break;
81138968:	00000d06 	br	811389a0 <OSEventPendMulti+0x460>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
                  events_rdy_nbr++;

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
8113896c:	d0a0a217 	ldw	r2,-32120(gp)
81138970:	00c00044 	movi	r3,1
81138974:	10c00c45 	stb	r3,49(r2)
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
81138978:	d0a0a217 	ldw	r2,-32120(gp)
8113897c:	e17ffc17 	ldw	r5,-16(fp)
81138980:	1009883a 	mov	r4,r2
81138984:	113967c0 	call	8113967c <OS_EventTaskRemoveMulti>
             }
			 break;
81138988:	00000506 	br	811389a0 <OSEventPendMulti+0x460>

        case OS_STAT_PEND_TO:
        default:                                        /* ... remove task from events' wait lists     */
             OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
8113898c:	d0a0a217 	ldw	r2,-32120(gp)
81138990:	e17ffc17 	ldw	r5,-16(fp)
81138994:	1009883a 	mov	r4,r2
81138998:	113967c0 	call	8113967c <OS_EventTaskRemoveMulti>
             break;
8113899c:	0001883a 	nop
    }

    switch (OSTCBCur->OSTCBStatPend) {
811389a0:	d0a0a217 	ldw	r2,-32120(gp)
811389a4:	10800c43 	ldbu	r2,49(r2)
811389a8:	10803fcc 	andi	r2,r2,255
811389ac:	10000326 	beq	r2,zero,811389bc <OSEventPendMulti+0x47c>
811389b0:	108000a0 	cmpeqi	r2,r2,2
811389b4:	1000231e 	bne	r2,zero,81138a44 <OSEventPendMulti+0x504>
811389b8:	00002a06 	br	81138a64 <OSEventPendMulti+0x524>
        case OS_STAT_PEND_OK:
             switch (pevent->OSEventType) {             /* Return event's message                      */
811389bc:	e0bff017 	ldw	r2,-64(fp)
811389c0:	10800003 	ldbu	r2,0(r2)
811389c4:	10803fcc 	andi	r2,r2,255
811389c8:	0080100e 	bge	zero,r2,81138a0c <OSEventPendMulti+0x4cc>
811389cc:	10c000d0 	cmplti	r3,r2,3
811389d0:	1800071e 	bne	r3,zero,811389f0 <OSEventPendMulti+0x4b0>
811389d4:	108000e0 	cmpeqi	r2,r2,3
811389d8:	10000c26 	beq	r2,zero,81138a0c <OSEventPendMulti+0x4cc>
#if (OS_SEM_EN > 0)
                 case OS_EVENT_TYPE_SEM:
                     *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
811389dc:	e0bffe17 	ldw	r2,-8(fp)
811389e0:	10c00104 	addi	r3,r2,4
811389e4:	e0fffe15 	stw	r3,-8(fp)
811389e8:	10000015 	stw	zero,0(r2)
                      break;
811389ec:	00001206 	br	81138a38 <OSEventPendMulti+0x4f8>

#if ((OS_MBOX_EN > 0) ||                 \
    ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
                 case OS_EVENT_TYPE_MBOX:
                 case OS_EVENT_TYPE_Q:
                     *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
811389f0:	e0bffe17 	ldw	r2,-8(fp)
811389f4:	10c00104 	addi	r3,r2,4
811389f8:	e0fffe15 	stw	r3,-8(fp)
811389fc:	d0e0a217 	ldw	r3,-32120(gp)
81138a00:	18c00917 	ldw	r3,36(r3)
81138a04:	10c00015 	stw	r3,0(r2)
                      break;
81138a08:	00000b06 	br	81138a38 <OSEventPendMulti+0x4f8>
81138a0c:	e0bff317 	ldw	r2,-52(fp)
81138a10:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138a14:	e0bff817 	ldw	r2,-32(fp)
81138a18:	1001703a 	wrctl	status,r2

                 case OS_EVENT_TYPE_MUTEX:                                       
                 case OS_EVENT_TYPE_FLAG:
                 default:           
                      OS_EXIT_CRITICAL();
                     *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
81138a1c:	e0bffd17 	ldw	r2,-12(fp)
81138a20:	10000015 	stw	zero,0(r2)
                     *perr        =  OS_ERR_EVENT_TYPE;
81138a24:	e0800217 	ldw	r2,8(fp)
81138a28:	00c00044 	movi	r3,1
81138a2c:	10c00005 	stb	r3,0(r2)
                      return (events_rdy_nbr);
81138a30:	e0bff18b 	ldhu	r2,-58(fp)
81138a34:	00002206 	br	81138ac0 <OSEventPendMulti+0x580>
             }
            *perr = OS_ERR_NONE;
81138a38:	e0800217 	ldw	r2,8(fp)
81138a3c:	10000005 	stb	zero,0(r2)
             break;
81138a40:	00001006 	br	81138a84 <OSEventPendMulti+0x544>

        case OS_STAT_PEND_ABORT:
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
81138a44:	e0bffe17 	ldw	r2,-8(fp)
81138a48:	10c00104 	addi	r3,r2,4
81138a4c:	e0fffe15 	stw	r3,-8(fp)
81138a50:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
81138a54:	e0800217 	ldw	r2,8(fp)
81138a58:	00c00384 	movi	r3,14
81138a5c:	10c00005 	stb	r3,0(r2)
             break;
81138a60:	00000806 	br	81138a84 <OSEventPendMulti+0x544>
                                                        
        case OS_STAT_PEND_TO:                                                
        default:        
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
81138a64:	e0bffe17 	ldw	r2,-8(fp)
81138a68:	10c00104 	addi	r3,r2,4
81138a6c:	e0fffe15 	stw	r3,-8(fp)
81138a70:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
81138a74:	e0800217 	ldw	r2,8(fp)
81138a78:	00c00284 	movi	r3,10
81138a7c:	10c00005 	stb	r3,0(r2)
             break;
81138a80:	0001883a 	nop
    }

    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
81138a84:	d0a0a217 	ldw	r2,-32120(gp)
81138a88:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
81138a8c:	d0a0a217 	ldw	r2,-32120(gp)
81138a90:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
81138a94:	d0a0a217 	ldw	r2,-32120(gp)
81138a98:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
81138a9c:	d0a0a217 	ldw	r2,-32120(gp)
81138aa0:	10000815 	stw	zero,32(r2)
    OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
81138aa4:	d0a0a217 	ldw	r2,-32120(gp)
81138aa8:	10000915 	stw	zero,36(r2)
81138aac:	e0bff317 	ldw	r2,-52(fp)
81138ab0:	e0bffa15 	stw	r2,-24(fp)
81138ab4:	e0bffa17 	ldw	r2,-24(fp)
81138ab8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();

    return (events_rdy_nbr);
81138abc:	e0bff18b 	ldhu	r2,-58(fp)
}
81138ac0:	e037883a 	mov	sp,fp
81138ac4:	dfc00117 	ldw	ra,4(sp)
81138ac8:	df000017 	ldw	fp,0(sp)
81138acc:	dec00204 	addi	sp,sp,8
81138ad0:	f800283a 	ret

81138ad4 <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
81138ad4:	defffe04 	addi	sp,sp,-8
81138ad8:	de00012e 	bgeu	sp,et,81138ae0 <OSInit+0xc>
81138adc:	003b68fa 	trap	3
81138ae0:	dfc00115 	stw	ra,4(sp)
81138ae4:	df000015 	stw	fp,0(sp)
81138ae8:	d839883a 	mov	fp,sp
    OSInitHookBegin();                                           /* Call port specific initialization code   */
81138aec:	114afd80 	call	8114afd8 <OSInitHookBegin>

    OS_InitMisc();                                               /* Initialize miscellaneous variables       */
81138af0:	11398dc0 	call	811398dc <OS_InitMisc>

    OS_InitRdyList();                                            /* Initialize the Ready List                */
81138af4:	113992c0 	call	8113992c <OS_InitRdyList>

    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
81138af8:	1139ab00 	call	81139ab0 <OS_InitTCBList>

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
81138afc:	11397f40 	call	811397f4 <OS_InitEventList>

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
81138b00:	113ba700 	call	8113ba70 <OS_FlagInit>
#endif

#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
81138b04:	113c3b80 	call	8113c3b8 <OS_MemInit>
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
81138b08:	113e6880 	call	8113e688 <OS_QInit>
#endif

    OS_InitTaskIdle();                                           /* Create the Idle Task                     */
81138b0c:	11399a00 	call	811399a0 <OS_InitTaskIdle>
#if OS_TASK_STAT_EN > 0
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
81138b10:	1139a280 	call	81139a28 <OS_InitTaskStat>
#endif

#if OS_TMR_EN > 0
    OSTmr_Init();                                                /* Initialize the Timer Manager             */
81138b14:	1141a2c0 	call	81141a2c <OSTmr_Init>
#endif

    OSInitHookEnd();                                             /* Call port specific init. code            */
81138b18:	114b0040 	call	8114b004 <OSInitHookEnd>

#if OS_DEBUG_EN > 0
    OSDebugInit();
81138b1c:	113a38c0 	call	8113a38c <OSDebugInit>
#endif
}
81138b20:	0001883a 	nop
81138b24:	e037883a 	mov	sp,fp
81138b28:	dfc00117 	ldw	ra,4(sp)
81138b2c:	df000017 	ldw	fp,0(sp)
81138b30:	dec00204 	addi	sp,sp,8
81138b34:	f800283a 	ret

81138b38 <OSIntEnter>:
*              5) You are allowed to nest interrupts up to 255 levels deep.
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
81138b38:	deffff04 	addi	sp,sp,-4
81138b3c:	de00012e 	bgeu	sp,et,81138b44 <OSIntEnter+0xc>
81138b40:	003b68fa 	trap	3
81138b44:	df000015 	stw	fp,0(sp)
81138b48:	d839883a 	mov	fp,sp
    if (OSRunning == OS_TRUE) {
81138b4c:	d0a09103 	ldbu	r2,-32188(gp)
81138b50:	10803fcc 	andi	r2,r2,255
81138b54:	10800058 	cmpnei	r2,r2,1
81138b58:	1000071e 	bne	r2,zero,81138b78 <OSIntEnter+0x40>
        if (OSIntNesting < 255u) {
81138b5c:	d0a0a103 	ldbu	r2,-32124(gp)
81138b60:	10803fcc 	andi	r2,r2,255
81138b64:	10803fe0 	cmpeqi	r2,r2,255
81138b68:	1000031e 	bne	r2,zero,81138b78 <OSIntEnter+0x40>
            OSIntNesting++;                      /* Increment ISR nesting level                        */
81138b6c:	d0a0a103 	ldbu	r2,-32124(gp)
81138b70:	10800044 	addi	r2,r2,1
81138b74:	d0a0a105 	stb	r2,-32124(gp)
        }
    }
}
81138b78:	0001883a 	nop
81138b7c:	e037883a 	mov	sp,fp
81138b80:	df000017 	ldw	fp,0(sp)
81138b84:	dec00104 	addi	sp,sp,4
81138b88:	f800283a 	ret

81138b8c <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
81138b8c:	defffb04 	addi	sp,sp,-20
81138b90:	de00012e 	bgeu	sp,et,81138b98 <OSIntExit+0xc>
81138b94:	003b68fa 	trap	3
81138b98:	dfc00415 	stw	ra,16(sp)
81138b9c:	df000315 	stw	fp,12(sp)
81138ba0:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81138ba4:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {
81138ba8:	d0a09103 	ldbu	r2,-32188(gp)
81138bac:	10803fcc 	andi	r2,r2,255
81138bb0:	10800058 	cmpnei	r2,r2,1
81138bb4:	10002f1e 	bne	r2,zero,81138c74 <OSIntExit+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138bb8:	0005303a 	rdctl	r2,status
81138bbc:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138bc0:	e0ffff17 	ldw	r3,-4(fp)
81138bc4:	00bfff84 	movi	r2,-2
81138bc8:	1884703a 	and	r2,r3,r2
81138bcc:	1001703a 	wrctl	status,r2
  
  return context;
81138bd0:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
81138bd4:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
81138bd8:	d0a0a103 	ldbu	r2,-32124(gp)
81138bdc:	10803fcc 	andi	r2,r2,255
81138be0:	10000326 	beq	r2,zero,81138bf0 <OSIntExit+0x64>
            OSIntNesting--;
81138be4:	d0a0a103 	ldbu	r2,-32124(gp)
81138be8:	10bfffc4 	addi	r2,r2,-1
81138bec:	d0a0a105 	stb	r2,-32124(gp)
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
81138bf0:	d0a0a103 	ldbu	r2,-32124(gp)
81138bf4:	10803fcc 	andi	r2,r2,255
81138bf8:	10001a1e 	bne	r2,zero,81138c64 <OSIntExit+0xd8>
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
81138bfc:	d0a08f03 	ldbu	r2,-32196(gp)
81138c00:	10803fcc 	andi	r2,r2,255
81138c04:	1000171e 	bne	r2,zero,81138c64 <OSIntExit+0xd8>
                OS_SchedNew();
81138c08:	1139d400 	call	81139d40 <OS_SchedNew>
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
81138c0c:	d0e09383 	ldbu	r3,-32178(gp)
81138c10:	d0a093c3 	ldbu	r2,-32177(gp)
81138c14:	18c03fcc 	andi	r3,r3,255
81138c18:	10803fcc 	andi	r2,r2,255
81138c1c:	18801126 	beq	r3,r2,81138c64 <OSIntExit+0xd8>
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
81138c20:	d0a09383 	ldbu	r2,-32178(gp)
81138c24:	10c03fcc 	andi	r3,r2,255
81138c28:	00a045f4 	movhi	r2,33047
81138c2c:	10b41904 	addi	r2,r2,-12188
81138c30:	18c7883a 	add	r3,r3,r3
81138c34:	18c7883a 	add	r3,r3,r3
81138c38:	10c5883a 	add	r2,r2,r3
81138c3c:	10800017 	ldw	r2,0(r2)
81138c40:	d0a09c15 	stw	r2,-32144(gp)
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
81138c44:	d0a09c17 	ldw	r2,-32144(gp)
81138c48:	10c00e17 	ldw	r3,56(r2)
81138c4c:	18c00044 	addi	r3,r3,1
81138c50:	10c00e15 	stw	r3,56(r2)
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
81138c54:	d0a09617 	ldw	r2,-32168(gp)
81138c58:	10800044 	addi	r2,r2,1
81138c5c:	d0a09615 	stw	r2,-32168(gp)
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
81138c60:	114ac980 	call	8114ac98 <OSCtxSw>
81138c64:	e0bffd17 	ldw	r2,-12(fp)
81138c68:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138c6c:	e0bffe17 	ldw	r2,-8(fp)
81138c70:	1001703a 	wrctl	status,r2
                }
            }
        }
        OS_EXIT_CRITICAL();
    }
}
81138c74:	0001883a 	nop
81138c78:	e037883a 	mov	sp,fp
81138c7c:	dfc00117 	ldw	ra,4(sp)
81138c80:	df000017 	ldw	fp,0(sp)
81138c84:	dec00204 	addi	sp,sp,8
81138c88:	f800283a 	ret

81138c8c <OSSchedLock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedLock (void)
{
81138c8c:	defffc04 	addi	sp,sp,-16
81138c90:	de00012e 	bgeu	sp,et,81138c98 <OSSchedLock+0xc>
81138c94:	003b68fa 	trap	3
81138c98:	df000315 	stw	fp,12(sp)
81138c9c:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81138ca0:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
81138ca4:	d0a09103 	ldbu	r2,-32188(gp)
81138ca8:	10803fcc 	andi	r2,r2,255
81138cac:	10800058 	cmpnei	r2,r2,1
81138cb0:	1000161e 	bne	r2,zero,81138d0c <OSSchedLock+0x80>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138cb4:	0005303a 	rdctl	r2,status
81138cb8:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138cbc:	e0ffff17 	ldw	r3,-4(fp)
81138cc0:	00bfff84 	movi	r2,-2
81138cc4:	1884703a 	and	r2,r3,r2
81138cc8:	1001703a 	wrctl	status,r2
  
  return context;
81138ccc:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
81138cd0:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
81138cd4:	d0a0a103 	ldbu	r2,-32124(gp)
81138cd8:	10803fcc 	andi	r2,r2,255
81138cdc:	1000071e 	bne	r2,zero,81138cfc <OSSchedLock+0x70>
            if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
81138ce0:	d0a08f03 	ldbu	r2,-32196(gp)
81138ce4:	10803fcc 	andi	r2,r2,255
81138ce8:	10803fe0 	cmpeqi	r2,r2,255
81138cec:	1000031e 	bne	r2,zero,81138cfc <OSSchedLock+0x70>
                OSLockNesting++;                 /* Increment lock nesting level                       */
81138cf0:	d0a08f03 	ldbu	r2,-32196(gp)
81138cf4:	10800044 	addi	r2,r2,1
81138cf8:	d0a08f05 	stb	r2,-32196(gp)
81138cfc:	e0bffd17 	ldw	r2,-12(fp)
81138d00:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138d04:	e0bffe17 	ldw	r2,-8(fp)
81138d08:	1001703a 	wrctl	status,r2
            }
        }
        OS_EXIT_CRITICAL();
    }
}
81138d0c:	0001883a 	nop
81138d10:	e037883a 	mov	sp,fp
81138d14:	df000017 	ldw	fp,0(sp)
81138d18:	dec00104 	addi	sp,sp,4
81138d1c:	f800283a 	ret

81138d20 <OSSchedUnlock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedUnlock (void)
{
81138d20:	defff804 	addi	sp,sp,-32
81138d24:	de00012e 	bgeu	sp,et,81138d2c <OSSchedUnlock+0xc>
81138d28:	003b68fa 	trap	3
81138d2c:	dfc00715 	stw	ra,28(sp)
81138d30:	df000615 	stw	fp,24(sp)
81138d34:	df000604 	addi	fp,sp,24
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81138d38:	e03ffa15 	stw	zero,-24(fp)
#endif



    if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
81138d3c:	d0a09103 	ldbu	r2,-32188(gp)
81138d40:	10803fcc 	andi	r2,r2,255
81138d44:	10800058 	cmpnei	r2,r2,1
81138d48:	1000281e 	bne	r2,zero,81138dec <OSSchedUnlock+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138d4c:	0005303a 	rdctl	r2,status
81138d50:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138d54:	e0ffff17 	ldw	r3,-4(fp)
81138d58:	00bfff84 	movi	r2,-2
81138d5c:	1884703a 	and	r2,r3,r2
81138d60:	1001703a 	wrctl	status,r2
  
  return context;
81138d64:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
81138d68:	e0bffa15 	stw	r2,-24(fp)
        if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
81138d6c:	d0a08f03 	ldbu	r2,-32196(gp)
81138d70:	10803fcc 	andi	r2,r2,255
81138d74:	10001926 	beq	r2,zero,81138ddc <OSSchedUnlock+0xbc>
            OSLockNesting--;                               /* Decrement lock nesting level             */
81138d78:	d0a08f03 	ldbu	r2,-32196(gp)
81138d7c:	10bfffc4 	addi	r2,r2,-1
81138d80:	d0a08f05 	stb	r2,-32196(gp)
            if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
81138d84:	d0a08f03 	ldbu	r2,-32196(gp)
81138d88:	10803fcc 	andi	r2,r2,255
81138d8c:	10000e1e 	bne	r2,zero,81138dc8 <OSSchedUnlock+0xa8>
                if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
81138d90:	d0a0a103 	ldbu	r2,-32124(gp)
81138d94:	10803fcc 	andi	r2,r2,255
81138d98:	1000061e 	bne	r2,zero,81138db4 <OSSchedUnlock+0x94>
81138d9c:	e0bffa17 	ldw	r2,-24(fp)
81138da0:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138da4:	e0bffb17 	ldw	r2,-20(fp)
81138da8:	1001703a 	wrctl	status,r2
                    OS_EXIT_CRITICAL();
                    OS_Sched();                            /* See if a HPT is ready                    */
81138dac:	1139c680 	call	81139c68 <OS_Sched>
            }
        } else {
            OS_EXIT_CRITICAL();
        }
    }
}
81138db0:	00000e06 	br	81138dec <OSSchedUnlock+0xcc>
81138db4:	e0bffa17 	ldw	r2,-24(fp)
81138db8:	e0bffc15 	stw	r2,-16(fp)
81138dbc:	e0bffc17 	ldw	r2,-16(fp)
81138dc0:	1001703a 	wrctl	status,r2
81138dc4:	00000906 	br	81138dec <OSSchedUnlock+0xcc>
81138dc8:	e0bffa17 	ldw	r2,-24(fp)
81138dcc:	e0bffd15 	stw	r2,-12(fp)
81138dd0:	e0bffd17 	ldw	r2,-12(fp)
81138dd4:	1001703a 	wrctl	status,r2
81138dd8:	00000406 	br	81138dec <OSSchedUnlock+0xcc>
81138ddc:	e0bffa17 	ldw	r2,-24(fp)
81138de0:	e0bffe15 	stw	r2,-8(fp)
81138de4:	e0bffe17 	ldw	r2,-8(fp)
81138de8:	1001703a 	wrctl	status,r2
81138dec:	0001883a 	nop
81138df0:	e037883a 	mov	sp,fp
81138df4:	dfc00117 	ldw	ra,4(sp)
81138df8:	df000017 	ldw	fp,0(sp)
81138dfc:	dec00204 	addi	sp,sp,8
81138e00:	f800283a 	ret

81138e04 <OSStart>:
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
81138e04:	defffe04 	addi	sp,sp,-8
81138e08:	de00012e 	bgeu	sp,et,81138e10 <OSStart+0xc>
81138e0c:	003b68fa 	trap	3
81138e10:	dfc00115 	stw	ra,4(sp)
81138e14:	df000015 	stw	fp,0(sp)
81138e18:	d839883a 	mov	fp,sp
    if (OSRunning == OS_FALSE) {
81138e1c:	d0a09103 	ldbu	r2,-32188(gp)
81138e20:	10803fcc 	andi	r2,r2,255
81138e24:	10000f1e 	bne	r2,zero,81138e64 <OSStart+0x60>
        OS_SchedNew();                               /* Find highest priority's task priority number   */
81138e28:	1139d400 	call	81139d40 <OS_SchedNew>
        OSPrioCur     = OSPrioHighRdy;
81138e2c:	d0a09383 	ldbu	r2,-32178(gp)
81138e30:	d0a093c5 	stb	r2,-32177(gp)
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
81138e34:	d0a09383 	ldbu	r2,-32178(gp)
81138e38:	10c03fcc 	andi	r3,r2,255
81138e3c:	00a045f4 	movhi	r2,33047
81138e40:	10b41904 	addi	r2,r2,-12188
81138e44:	18c7883a 	add	r3,r3,r3
81138e48:	18c7883a 	add	r3,r3,r3
81138e4c:	10c5883a 	add	r2,r2,r3
81138e50:	10800017 	ldw	r2,0(r2)
81138e54:	d0a09c15 	stw	r2,-32144(gp)
        OSTCBCur      = OSTCBHighRdy;
81138e58:	d0a09c17 	ldw	r2,-32144(gp)
81138e5c:	d0a0a215 	stw	r2,-32120(gp)
        OSStartHighRdy();                            /* Execute target specific code to start task     */
81138e60:	114ad340 	call	8114ad34 <OSStartHighRdy>
    }
}
81138e64:	0001883a 	nop
81138e68:	e037883a 	mov	sp,fp
81138e6c:	dfc00117 	ldw	ra,4(sp)
81138e70:	df000017 	ldw	fp,0(sp)
81138e74:	dec00204 	addi	sp,sp,8
81138e78:	f800283a 	ret

81138e7c <OSStatInit>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OSStatInit (void)
{
81138e7c:	defff904 	addi	sp,sp,-28
81138e80:	de00012e 	bgeu	sp,et,81138e88 <OSStatInit+0xc>
81138e84:	003b68fa 	trap	3
81138e88:	dfc00615 	stw	ra,24(sp)
81138e8c:	df000515 	stw	fp,20(sp)
81138e90:	df000504 	addi	fp,sp,20
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81138e94:	e03ffb15 	stw	zero,-20(fp)
#endif



    OSTimeDly(2);                                /* Synchronize with clock tick                        */
81138e98:	01000084 	movi	r4,2
81138e9c:	11409a40 	call	811409a4 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138ea0:	0005303a 	rdctl	r2,status
81138ea4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138ea8:	e0fffc17 	ldw	r3,-16(fp)
81138eac:	00bfff84 	movi	r2,-2
81138eb0:	1884703a 	and	r2,r3,r2
81138eb4:	1001703a 	wrctl	status,r2
  
  return context;
81138eb8:	e0bffc17 	ldw	r2,-16(fp)
    OS_ENTER_CRITICAL();
81138ebc:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
81138ec0:	d0209215 	stw	zero,-32184(gp)
81138ec4:	e0bffb17 	ldw	r2,-20(fp)
81138ec8:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138ecc:	e0bffd17 	ldw	r2,-12(fp)
81138ed0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
81138ed4:	01001904 	movi	r4,100
81138ed8:	11409a40 	call	811409a4 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138edc:	0005303a 	rdctl	r2,status
81138ee0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138ee4:	e0fffe17 	ldw	r3,-8(fp)
81138ee8:	00bfff84 	movi	r2,-2
81138eec:	1884703a 	and	r2,r3,r2
81138ef0:	1001703a 	wrctl	status,r2
  
  return context;
81138ef4:	e0bffe17 	ldw	r2,-8(fp)
    OS_ENTER_CRITICAL();
81138ef8:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
81138efc:	d0a09217 	ldw	r2,-32184(gp)
81138f00:	d0a09815 	stw	r2,-32160(gp)
    OSStatRdy    = OS_TRUE;
81138f04:	00800044 	movi	r2,1
81138f08:	d0a0a705 	stb	r2,-32100(gp)
81138f0c:	e0bffb17 	ldw	r2,-20(fp)
81138f10:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138f14:	e0bfff17 	ldw	r2,-4(fp)
81138f18:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
81138f1c:	0001883a 	nop
81138f20:	e037883a 	mov	sp,fp
81138f24:	dfc00117 	ldw	ra,4(sp)
81138f28:	df000017 	ldw	fp,0(sp)
81138f2c:	dec00204 	addi	sp,sp,8
81138f30:	f800283a 	ret

81138f34 <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
81138f34:	defff704 	addi	sp,sp,-36
81138f38:	de00012e 	bgeu	sp,et,81138f40 <OSTimeTick+0xc>
81138f3c:	003b68fa 	trap	3
81138f40:	dfc00815 	stw	ra,32(sp)
81138f44:	df000715 	stw	fp,28(sp)
81138f48:	df000704 	addi	fp,sp,28
    OS_TCB    *ptcb;
#if OS_TICK_STEP_EN > 0
    BOOLEAN    step;
#endif
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81138f4c:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
81138f50:	114af840 	call	8114af84 <OSTimeTickHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138f54:	0005303a 	rdctl	r2,status
81138f58:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138f5c:	e0fffd17 	ldw	r3,-12(fp)
81138f60:	00bfff84 	movi	r2,-2
81138f64:	1884703a 	and	r2,r3,r2
81138f68:	1001703a 	wrctl	status,r2
  
  return context;
81138f6c:	e0bffd17 	ldw	r2,-12(fp)
#endif
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
81138f70:	e0bffb15 	stw	r2,-20(fp)
    OSTime++;
81138f74:	d0a0a417 	ldw	r2,-32112(gp)
81138f78:	10800044 	addi	r2,r2,1
81138f7c:	d0a0a415 	stw	r2,-32112(gp)
81138f80:	e0bffb17 	ldw	r2,-20(fp)
81138f84:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138f88:	e0bfff17 	ldw	r2,-4(fp)
81138f8c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#endif
    if (OSRunning == OS_TRUE) {
81138f90:	d0a09103 	ldbu	r2,-32188(gp)
81138f94:	10803fcc 	andi	r2,r2,255
81138f98:	10800058 	cmpnei	r2,r2,1
81138f9c:	10006a1e 	bne	r2,zero,81139148 <OSTimeTick+0x214>
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
81138fa0:	d0a09503 	ldbu	r2,-32172(gp)
81138fa4:	10803fcc 	andi	r2,r2,255
81138fa8:	10c00060 	cmpeqi	r3,r2,1
81138fac:	1800061e 	bne	r3,zero,81138fc8 <OSTimeTick+0x94>
81138fb0:	10c000a0 	cmpeqi	r3,r2,2
81138fb4:	1800061e 	bne	r3,zero,81138fd0 <OSTimeTick+0x9c>
81138fb8:	10000a1e 	bne	r2,zero,81138fe4 <OSTimeTick+0xb0>
            case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                 step = OS_TRUE;
81138fbc:	00800044 	movi	r2,1
81138fc0:	e0bffa05 	stb	r2,-24(fp)
                 break;
81138fc4:	00000b06 	br	81138ff4 <OSTimeTick+0xc0>

            case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                 step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
81138fc8:	e03ffa05 	stb	zero,-24(fp)
                 break;
81138fcc:	00000906 	br	81138ff4 <OSTimeTick+0xc0>

            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                 step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
81138fd0:	00800044 	movi	r2,1
81138fd4:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_WAIT;
81138fd8:	00800044 	movi	r2,1
81138fdc:	d0a09505 	stb	r2,-32172(gp)
                 break;
81138fe0:	00000406 	br	81138ff4 <OSTimeTick+0xc0>

            default:                                       /* Invalid case, correct situation              */
                 step            = OS_TRUE;
81138fe4:	00800044 	movi	r2,1
81138fe8:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_DIS;
81138fec:	d0209505 	stb	zero,-32172(gp)
                 break;
81138ff0:	0001883a 	nop
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
81138ff4:	e0bffa03 	ldbu	r2,-24(fp)
81138ff8:	10005226 	beq	r2,zero,81139144 <OSTimeTick+0x210>
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
81138ffc:	d0a09417 	ldw	r2,-32176(gp)
81139000:	e0bff915 	stw	r2,-28(fp)
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
81139004:	00004906 	br	8113912c <OSTimeTick+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139008:	0005303a 	rdctl	r2,status
8113900c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139010:	e0fffc17 	ldw	r3,-16(fp)
81139014:	00bfff84 	movi	r2,-2
81139018:	1884703a 	and	r2,r3,r2
8113901c:	1001703a 	wrctl	status,r2
  
  return context;
81139020:	e0bffc17 	ldw	r2,-16(fp)
            OS_ENTER_CRITICAL();
81139024:	e0bffb15 	stw	r2,-20(fp)
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
81139028:	e0bff917 	ldw	r2,-28(fp)
8113902c:	10800b8b 	ldhu	r2,46(r2)
81139030:	10bfffcc 	andi	r2,r2,65535
81139034:	10003626 	beq	r2,zero,81139110 <OSTimeTick+0x1dc>
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
81139038:	e0bff917 	ldw	r2,-28(fp)
8113903c:	10800b8b 	ldhu	r2,46(r2)
81139040:	10bfffc4 	addi	r2,r2,-1
81139044:	1007883a 	mov	r3,r2
81139048:	e0bff917 	ldw	r2,-28(fp)
8113904c:	10c00b8d 	sth	r3,46(r2)
81139050:	e0bff917 	ldw	r2,-28(fp)
81139054:	10800b8b 	ldhu	r2,46(r2)
81139058:	10bfffcc 	andi	r2,r2,65535
8113905c:	10002c1e 	bne	r2,zero,81139110 <OSTimeTick+0x1dc>
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
81139060:	e0bff917 	ldw	r2,-28(fp)
81139064:	10800c03 	ldbu	r2,48(r2)
81139068:	10803fcc 	andi	r2,r2,255
8113906c:	10800dcc 	andi	r2,r2,55
81139070:	10000b26 	beq	r2,zero,811390a0 <OSTimeTick+0x16c>
                        ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
81139074:	e0bff917 	ldw	r2,-28(fp)
81139078:	10c00c03 	ldbu	r3,48(r2)
8113907c:	00bff204 	movi	r2,-56
81139080:	1884703a 	and	r2,r3,r2
81139084:	1007883a 	mov	r3,r2
81139088:	e0bff917 	ldw	r2,-28(fp)
8113908c:	10c00c05 	stb	r3,48(r2)
                        ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
81139090:	e0bff917 	ldw	r2,-28(fp)
81139094:	00c00044 	movi	r3,1
81139098:	10c00c45 	stb	r3,49(r2)
8113909c:	00000206 	br	811390a8 <OSTimeTick+0x174>
                    } else {
                        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
811390a0:	e0bff917 	ldw	r2,-28(fp)
811390a4:	10000c45 	stb	zero,49(r2)
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
811390a8:	e0bff917 	ldw	r2,-28(fp)
811390ac:	10800c03 	ldbu	r2,48(r2)
811390b0:	10803fcc 	andi	r2,r2,255
811390b4:	1080020c 	andi	r2,r2,8
811390b8:	1000151e 	bne	r2,zero,81139110 <OSTimeTick+0x1dc>
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
811390bc:	e0bff917 	ldw	r2,-28(fp)
811390c0:	10c00d83 	ldbu	r3,54(r2)
811390c4:	d0a09e03 	ldbu	r2,-32136(gp)
811390c8:	1884b03a 	or	r2,r3,r2
811390cc:	d0a09e05 	stb	r2,-32136(gp)
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
811390d0:	e0bff917 	ldw	r2,-28(fp)
811390d4:	10800d03 	ldbu	r2,52(r2)
811390d8:	10c03fcc 	andi	r3,r2,255
811390dc:	e0bff917 	ldw	r2,-28(fp)
811390e0:	10800d03 	ldbu	r2,52(r2)
811390e4:	11003fcc 	andi	r4,r2,255
811390e8:	d0a09e44 	addi	r2,gp,-32135
811390ec:	2085883a 	add	r2,r4,r2
811390f0:	11000003 	ldbu	r4,0(r2)
811390f4:	e0bff917 	ldw	r2,-28(fp)
811390f8:	10800d43 	ldbu	r2,53(r2)
811390fc:	2084b03a 	or	r2,r4,r2
81139100:	1009883a 	mov	r4,r2
81139104:	d0a09e44 	addi	r2,gp,-32135
81139108:	1885883a 	add	r2,r3,r2
8113910c:	11000005 	stb	r4,0(r2)
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
81139110:	e0bff917 	ldw	r2,-28(fp)
81139114:	10800517 	ldw	r2,20(r2)
81139118:	e0bff915 	stw	r2,-28(fp)
8113911c:	e0bffb17 	ldw	r2,-20(fp)
81139120:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139124:	e0bffe17 	ldw	r2,-8(fp)
81139128:	1001703a 	wrctl	status,r2
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
8113912c:	e0bff917 	ldw	r2,-28(fp)
81139130:	10800c83 	ldbu	r2,50(r2)
81139134:	10803fcc 	andi	r2,r2,255
81139138:	10800a98 	cmpnei	r2,r2,42
8113913c:	103fb21e 	bne	r2,zero,81139008 <__reset+0xfb119008>
81139140:	00000106 	br	81139148 <OSTimeTick+0x214>
                 step            = OS_TRUE;
                 OSTickStepState = OS_TICK_STEP_DIS;
                 break;
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
81139144:	0001883a 	nop
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
81139148:	e037883a 	mov	sp,fp
8113914c:	dfc00117 	ldw	ra,4(sp)
81139150:	df000017 	ldw	fp,0(sp)
81139154:	dec00204 	addi	sp,sp,8
81139158:	f800283a 	ret

8113915c <OSVersion>:
* Returns    : the version number of uC/OS-II multiplied by 100.
*********************************************************************************************************
*/

INT16U  OSVersion (void)
{
8113915c:	deffff04 	addi	sp,sp,-4
81139160:	de00012e 	bgeu	sp,et,81139168 <OSVersion+0xc>
81139164:	003b68fa 	trap	3
81139168:	df000015 	stw	fp,0(sp)
8113916c:	d839883a 	mov	fp,sp
    return (OS_VERSION);
81139170:	00804784 	movi	r2,286
}
81139174:	e037883a 	mov	sp,fp
81139178:	df000017 	ldw	fp,0(sp)
8113917c:	dec00104 	addi	sp,sp,4
81139180:	f800283a 	ret

81139184 <OS_Dummy>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
void  OS_Dummy (void)
{
81139184:	deffff04 	addi	sp,sp,-4
81139188:	de00012e 	bgeu	sp,et,81139190 <OS_Dummy+0xc>
8113918c:	003b68fa 	trap	3
81139190:	df000015 	stw	fp,0(sp)
81139194:	d839883a 	mov	fp,sp
}
81139198:	0001883a 	nop
8113919c:	e037883a 	mov	sp,fp
811391a0:	df000017 	ldw	fp,0(sp)
811391a4:	dec00104 	addi	sp,sp,4
811391a8:	f800283a 	ret

811391ac <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
{
811391ac:	defff804 	addi	sp,sp,-32
811391b0:	de00012e 	bgeu	sp,et,811391b8 <OS_EventTaskRdy+0xc>
811391b4:	003b68fa 	trap	3
811391b8:	dfc00715 	stw	ra,28(sp)
811391bc:	df000615 	stw	fp,24(sp)
811391c0:	df000604 	addi	fp,sp,24
811391c4:	e13ffc15 	stw	r4,-16(fp)
811391c8:	e17ffd15 	stw	r5,-12(fp)
811391cc:	3007883a 	mov	r3,r6
811391d0:	3805883a 	mov	r2,r7
811391d4:	e0fffe05 	stb	r3,-8(fp)
811391d8:	e0bfff05 	stb	r2,-4(fp)
    INT16U  *ptbl;
#endif


#if OS_LOWEST_PRIO <= 63
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
811391dc:	e0bffc17 	ldw	r2,-16(fp)
811391e0:	10800283 	ldbu	r2,10(r2)
811391e4:	10c03fcc 	andi	r3,r2,255
811391e8:	00a04574 	movhi	r2,33045
811391ec:	10849a04 	addi	r2,r2,4712
811391f0:	10c5883a 	add	r2,r2,r3
811391f4:	10800003 	ldbu	r2,0(r2)
811391f8:	e0bffa05 	stb	r2,-24(fp)
    x    = OSUnMapTbl[pevent->OSEventTbl[y]];
811391fc:	e0bffa03 	ldbu	r2,-24(fp)
81139200:	e0fffc17 	ldw	r3,-16(fp)
81139204:	1885883a 	add	r2,r3,r2
81139208:	108002c4 	addi	r2,r2,11
8113920c:	10800003 	ldbu	r2,0(r2)
81139210:	10c03fcc 	andi	r3,r2,255
81139214:	00a04574 	movhi	r2,33045
81139218:	10849a04 	addi	r2,r2,4712
8113921c:	10c5883a 	add	r2,r2,r3
81139220:	10800003 	ldbu	r2,0(r2)
81139224:	e0bffa45 	stb	r2,-23(fp)
    prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
81139228:	e0bffa03 	ldbu	r2,-24(fp)
8113922c:	100490fa 	slli	r2,r2,3
81139230:	1007883a 	mov	r3,r2
81139234:	e0bffa43 	ldbu	r2,-23(fp)
81139238:	1885883a 	add	r2,r3,r2
8113923c:	e0bffa85 	stb	r2,-22(fp)
        x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
    }
    prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
#endif

    ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
81139240:	e0fffa83 	ldbu	r3,-22(fp)
81139244:	00a045f4 	movhi	r2,33047
81139248:	10b41904 	addi	r2,r2,-12188
8113924c:	18c7883a 	add	r3,r3,r3
81139250:	18c7883a 	add	r3,r3,r3
81139254:	10c5883a 	add	r2,r2,r3
81139258:	10800017 	ldw	r2,0(r2)
8113925c:	e0bffb15 	stw	r2,-20(fp)
    ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
81139260:	e0bffb17 	ldw	r2,-20(fp)
81139264:	10000b8d 	sth	zero,46(r2)
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
81139268:	e0bffb17 	ldw	r2,-20(fp)
8113926c:	e0fffd17 	ldw	r3,-12(fp)
81139270:	10c00915 	stw	r3,36(r2)
#else
    pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
81139274:	e0bffb17 	ldw	r2,-20(fp)
81139278:	10800c03 	ldbu	r2,48(r2)
8113927c:	1007883a 	mov	r3,r2
81139280:	e0bffe03 	ldbu	r2,-8(fp)
81139284:	0084303a 	nor	r2,zero,r2
81139288:	1884703a 	and	r2,r3,r2
8113928c:	1007883a 	mov	r3,r2
81139290:	e0bffb17 	ldw	r2,-20(fp)
81139294:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
81139298:	e0bffb17 	ldw	r2,-20(fp)
8113929c:	e0ffff03 	ldbu	r3,-4(fp)
811392a0:	10c00c45 	stb	r3,49(r2)
                                                        /* See if task is ready (could be susp'd)      */
    if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
811392a4:	e0bffb17 	ldw	r2,-20(fp)
811392a8:	10800c03 	ldbu	r2,48(r2)
811392ac:	10803fcc 	andi	r2,r2,255
811392b0:	1080020c 	andi	r2,r2,8
811392b4:	1000111e 	bne	r2,zero,811392fc <OS_EventTaskRdy+0x150>
        OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
811392b8:	e0bffb17 	ldw	r2,-20(fp)
811392bc:	10c00d83 	ldbu	r3,54(r2)
811392c0:	d0a09e03 	ldbu	r2,-32136(gp)
811392c4:	1884b03a 	or	r2,r3,r2
811392c8:	d0a09e05 	stb	r2,-32136(gp)
        OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
811392cc:	e0fffa03 	ldbu	r3,-24(fp)
811392d0:	e13ffa03 	ldbu	r4,-24(fp)
811392d4:	d0a09e44 	addi	r2,gp,-32135
811392d8:	2085883a 	add	r2,r4,r2
811392dc:	11000003 	ldbu	r4,0(r2)
811392e0:	e0bffb17 	ldw	r2,-20(fp)
811392e4:	10800d43 	ldbu	r2,53(r2)
811392e8:	2084b03a 	or	r2,r4,r2
811392ec:	1009883a 	mov	r4,r2
811392f0:	d0a09e44 	addi	r2,gp,-32135
811392f4:	1885883a 	add	r2,r3,r2
811392f8:	11000005 	stb	r4,0(r2)
    }

    OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
811392fc:	e17ffc17 	ldw	r5,-16(fp)
81139300:	e13ffb17 	ldw	r4,-20(fp)
81139304:	11395bc0 	call	811395bc <OS_EventTaskRemove>
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
81139308:	e0bffb17 	ldw	r2,-20(fp)
8113930c:	10800817 	ldw	r2,32(r2)
81139310:	10000826 	beq	r2,zero,81139334 <OS_EventTaskRdy+0x188>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
81139314:	e0bffb17 	ldw	r2,-20(fp)
81139318:	10800817 	ldw	r2,32(r2)
8113931c:	100b883a 	mov	r5,r2
81139320:	e13ffb17 	ldw	r4,-20(fp)
81139324:	113967c0 	call	8113967c <OS_EventTaskRemoveMulti>
        ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
81139328:	e0bffb17 	ldw	r2,-20(fp)
8113932c:	e0fffc17 	ldw	r3,-16(fp)
81139330:	10c00715 	stw	r3,28(r2)
    }
#endif

    return (prio);
81139334:	e0bffa83 	ldbu	r2,-22(fp)
}
81139338:	e037883a 	mov	sp,fp
8113933c:	dfc00117 	ldw	ra,4(sp)
81139340:	df000017 	ldw	fp,0(sp)
81139344:	dec00204 	addi	sp,sp,8
81139348:	f800283a 	ret

8113934c <OS_EventTaskWait>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskWait (OS_EVENT *pevent)
{
8113934c:	defffd04 	addi	sp,sp,-12
81139350:	de00012e 	bgeu	sp,et,81139358 <OS_EventTaskWait+0xc>
81139354:	003b68fa 	trap	3
81139358:	df000215 	stw	fp,8(sp)
8113935c:	df000204 	addi	fp,sp,8
81139360:	e13fff15 	stw	r4,-4(fp)
    INT8U  y;


    OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
81139364:	d0a0a217 	ldw	r2,-32120(gp)
81139368:	e0ffff17 	ldw	r3,-4(fp)
8113936c:	10c00715 	stw	r3,28(r2)

    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
81139370:	d0a0a217 	ldw	r2,-32120(gp)
81139374:	10800d03 	ldbu	r2,52(r2)
81139378:	10803fcc 	andi	r2,r2,255
8113937c:	d0e0a217 	ldw	r3,-32120(gp)
81139380:	18c00d03 	ldbu	r3,52(r3)
81139384:	18c03fcc 	andi	r3,r3,255
81139388:	e13fff17 	ldw	r4,-4(fp)
8113938c:	20c7883a 	add	r3,r4,r3
81139390:	18c002c4 	addi	r3,r3,11
81139394:	19000003 	ldbu	r4,0(r3)
81139398:	d0e0a217 	ldw	r3,-32120(gp)
8113939c:	18c00d43 	ldbu	r3,53(r3)
811393a0:	20c6b03a 	or	r3,r4,r3
811393a4:	1809883a 	mov	r4,r3
811393a8:	e0ffff17 	ldw	r3,-4(fp)
811393ac:	1885883a 	add	r2,r3,r2
811393b0:	108002c4 	addi	r2,r2,11
811393b4:	11000005 	stb	r4,0(r2)
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
811393b8:	e0bfff17 	ldw	r2,-4(fp)
811393bc:	10c00283 	ldbu	r3,10(r2)
811393c0:	d0a0a217 	ldw	r2,-32120(gp)
811393c4:	10800d83 	ldbu	r2,54(r2)
811393c8:	1884b03a 	or	r2,r3,r2
811393cc:	1007883a 	mov	r3,r2
811393d0:	e0bfff17 	ldw	r2,-4(fp)
811393d4:	10c00285 	stb	r3,10(r2)

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
811393d8:	d0a0a217 	ldw	r2,-32120(gp)
811393dc:	10800d03 	ldbu	r2,52(r2)
811393e0:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
811393e4:	e0fffe03 	ldbu	r3,-8(fp)
811393e8:	e13ffe03 	ldbu	r4,-8(fp)
811393ec:	d0a09e44 	addi	r2,gp,-32135
811393f0:	2085883a 	add	r2,r4,r2
811393f4:	10800003 	ldbu	r2,0(r2)
811393f8:	1009883a 	mov	r4,r2
811393fc:	d0a0a217 	ldw	r2,-32120(gp)
81139400:	10800d43 	ldbu	r2,53(r2)
81139404:	0084303a 	nor	r2,zero,r2
81139408:	2084703a 	and	r2,r4,r2
8113940c:	1009883a 	mov	r4,r2
81139410:	d0a09e44 	addi	r2,gp,-32135
81139414:	1885883a 	add	r2,r3,r2
81139418:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
8113941c:	e0fffe03 	ldbu	r3,-8(fp)
81139420:	d0a09e44 	addi	r2,gp,-32135
81139424:	1885883a 	add	r2,r3,r2
81139428:	10800003 	ldbu	r2,0(r2)
8113942c:	10803fcc 	andi	r2,r2,255
81139430:	1000071e 	bne	r2,zero,81139450 <OS_EventTaskWait+0x104>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
81139434:	d0a0a217 	ldw	r2,-32120(gp)
81139438:	10800d83 	ldbu	r2,54(r2)
8113943c:	0084303a 	nor	r2,zero,r2
81139440:	1007883a 	mov	r3,r2
81139444:	d0a09e03 	ldbu	r2,-32136(gp)
81139448:	1884703a 	and	r2,r3,r2
8113944c:	d0a09e05 	stb	r2,-32136(gp)
    }
}
81139450:	0001883a 	nop
81139454:	e037883a 	mov	sp,fp
81139458:	df000017 	ldw	fp,0(sp)
8113945c:	dec00104 	addi	sp,sp,4
81139460:	f800283a 	ret

81139464 <OS_EventTaskWaitMulti>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
{
81139464:	defffb04 	addi	sp,sp,-20
81139468:	de00012e 	bgeu	sp,et,81139470 <OS_EventTaskWaitMulti+0xc>
8113946c:	003b68fa 	trap	3
81139470:	df000415 	stw	fp,16(sp)
81139474:	df000404 	addi	fp,sp,16
81139478:	e13fff15 	stw	r4,-4(fp)
    OS_EVENT **pevents;
    OS_EVENT  *pevent;
    INT8U      y;


    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
8113947c:	d0a0a217 	ldw	r2,-32120(gp)
81139480:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
81139484:	d0a0a217 	ldw	r2,-32120(gp)
81139488:	e0ffff17 	ldw	r3,-4(fp)
8113948c:	10c00815 	stw	r3,32(r2)

    pevents =  pevents_wait;
81139490:	e0bfff17 	ldw	r2,-4(fp)
81139494:	e0bffc15 	stw	r2,-16(fp)
    pevent  = *pevents;
81139498:	e0bffc17 	ldw	r2,-16(fp)
8113949c:	10800017 	ldw	r2,0(r2)
811394a0:	e0bffd15 	stw	r2,-12(fp)
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
811394a4:	00002006 	br	81139528 <OS_EventTaskWaitMulti+0xc4>
        pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
811394a8:	d0a0a217 	ldw	r2,-32120(gp)
811394ac:	10800d03 	ldbu	r2,52(r2)
811394b0:	10803fcc 	andi	r2,r2,255
811394b4:	d0e0a217 	ldw	r3,-32120(gp)
811394b8:	18c00d03 	ldbu	r3,52(r3)
811394bc:	18c03fcc 	andi	r3,r3,255
811394c0:	e13ffd17 	ldw	r4,-12(fp)
811394c4:	20c7883a 	add	r3,r4,r3
811394c8:	18c002c4 	addi	r3,r3,11
811394cc:	19000003 	ldbu	r4,0(r3)
811394d0:	d0e0a217 	ldw	r3,-32120(gp)
811394d4:	18c00d43 	ldbu	r3,53(r3)
811394d8:	20c6b03a 	or	r3,r4,r3
811394dc:	1809883a 	mov	r4,r3
811394e0:	e0fffd17 	ldw	r3,-12(fp)
811394e4:	1885883a 	add	r2,r3,r2
811394e8:	108002c4 	addi	r2,r2,11
811394ec:	11000005 	stb	r4,0(r2)
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
811394f0:	e0bffd17 	ldw	r2,-12(fp)
811394f4:	10c00283 	ldbu	r3,10(r2)
811394f8:	d0a0a217 	ldw	r2,-32120(gp)
811394fc:	10800d83 	ldbu	r2,54(r2)
81139500:	1884b03a 	or	r2,r3,r2
81139504:	1007883a 	mov	r3,r2
81139508:	e0bffd17 	ldw	r2,-12(fp)
8113950c:	10c00285 	stb	r3,10(r2)
        pevents++;
81139510:	e0bffc17 	ldw	r2,-16(fp)
81139514:	10800104 	addi	r2,r2,4
81139518:	e0bffc15 	stw	r2,-16(fp)
        pevent = *pevents;
8113951c:	e0bffc17 	ldw	r2,-16(fp)
81139520:	10800017 	ldw	r2,0(r2)
81139524:	e0bffd15 	stw	r2,-12(fp)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */

    pevents =  pevents_wait;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
81139528:	e0bffd17 	ldw	r2,-12(fp)
8113952c:	103fde1e 	bne	r2,zero,811394a8 <__reset+0xfb1194a8>
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
        pevents++;
        pevent = *pevents;
    }

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
81139530:	d0a0a217 	ldw	r2,-32120(gp)
81139534:	10800d03 	ldbu	r2,52(r2)
81139538:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
8113953c:	e0fffe03 	ldbu	r3,-8(fp)
81139540:	e13ffe03 	ldbu	r4,-8(fp)
81139544:	d0a09e44 	addi	r2,gp,-32135
81139548:	2085883a 	add	r2,r4,r2
8113954c:	10800003 	ldbu	r2,0(r2)
81139550:	1009883a 	mov	r4,r2
81139554:	d0a0a217 	ldw	r2,-32120(gp)
81139558:	10800d43 	ldbu	r2,53(r2)
8113955c:	0084303a 	nor	r2,zero,r2
81139560:	2084703a 	and	r2,r4,r2
81139564:	1009883a 	mov	r4,r2
81139568:	d0a09e44 	addi	r2,gp,-32135
8113956c:	1885883a 	add	r2,r3,r2
81139570:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
81139574:	e0fffe03 	ldbu	r3,-8(fp)
81139578:	d0a09e44 	addi	r2,gp,-32135
8113957c:	1885883a 	add	r2,r3,r2
81139580:	10800003 	ldbu	r2,0(r2)
81139584:	10803fcc 	andi	r2,r2,255
81139588:	1000071e 	bne	r2,zero,811395a8 <OS_EventTaskWaitMulti+0x144>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
8113958c:	d0a0a217 	ldw	r2,-32120(gp)
81139590:	10800d83 	ldbu	r2,54(r2)
81139594:	0084303a 	nor	r2,zero,r2
81139598:	1007883a 	mov	r3,r2
8113959c:	d0a09e03 	ldbu	r2,-32136(gp)
811395a0:	1884703a 	and	r2,r3,r2
811395a4:	d0a09e05 	stb	r2,-32136(gp)
    }
}
811395a8:	0001883a 	nop
811395ac:	e037883a 	mov	sp,fp
811395b0:	df000017 	ldw	fp,0(sp)
811395b4:	dec00104 	addi	sp,sp,4
811395b8:	f800283a 	ret

811395bc <OS_EventTaskRemove>:
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskRemove (OS_TCB   *ptcb,
                          OS_EVENT *pevent)
{
811395bc:	defffc04 	addi	sp,sp,-16
811395c0:	de00012e 	bgeu	sp,et,811395c8 <OS_EventTaskRemove+0xc>
811395c4:	003b68fa 	trap	3
811395c8:	df000315 	stw	fp,12(sp)
811395cc:	df000304 	addi	fp,sp,12
811395d0:	e13ffe15 	stw	r4,-8(fp)
811395d4:	e17fff15 	stw	r5,-4(fp)
    INT8U  y;


    y                       =  ptcb->OSTCBY;
811395d8:	e0bffe17 	ldw	r2,-8(fp)
811395dc:	10800d03 	ldbu	r2,52(r2)
811395e0:	e0bffd05 	stb	r2,-12(fp)
    pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
811395e4:	e0bffd03 	ldbu	r2,-12(fp)
811395e8:	e0fffd03 	ldbu	r3,-12(fp)
811395ec:	e13fff17 	ldw	r4,-4(fp)
811395f0:	20c7883a 	add	r3,r4,r3
811395f4:	18c002c4 	addi	r3,r3,11
811395f8:	18c00003 	ldbu	r3,0(r3)
811395fc:	1809883a 	mov	r4,r3
81139600:	e0fffe17 	ldw	r3,-8(fp)
81139604:	18c00d43 	ldbu	r3,53(r3)
81139608:	00c6303a 	nor	r3,zero,r3
8113960c:	20c6703a 	and	r3,r4,r3
81139610:	1809883a 	mov	r4,r3
81139614:	e0ffff17 	ldw	r3,-4(fp)
81139618:	1885883a 	add	r2,r3,r2
8113961c:	108002c4 	addi	r2,r2,11
81139620:	11000005 	stb	r4,0(r2)
    if (pevent->OSEventTbl[y] == 0) {
81139624:	e0bffd03 	ldbu	r2,-12(fp)
81139628:	e0ffff17 	ldw	r3,-4(fp)
8113962c:	1885883a 	add	r2,r3,r2
81139630:	108002c4 	addi	r2,r2,11
81139634:	10800003 	ldbu	r2,0(r2)
81139638:	10803fcc 	andi	r2,r2,255
8113963c:	10000a1e 	bne	r2,zero,81139668 <OS_EventTaskRemove+0xac>
        pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
81139640:	e0bfff17 	ldw	r2,-4(fp)
81139644:	10800283 	ldbu	r2,10(r2)
81139648:	1007883a 	mov	r3,r2
8113964c:	e0bffe17 	ldw	r2,-8(fp)
81139650:	10800d83 	ldbu	r2,54(r2)
81139654:	0084303a 	nor	r2,zero,r2
81139658:	1884703a 	and	r2,r3,r2
8113965c:	1007883a 	mov	r3,r2
81139660:	e0bfff17 	ldw	r2,-4(fp)
81139664:	10c00285 	stb	r3,10(r2)
    }
}
81139668:	0001883a 	nop
8113966c:	e037883a 	mov	sp,fp
81139670:	df000017 	ldw	fp,0(sp)
81139674:	dec00104 	addi	sp,sp,4
81139678:	f800283a 	ret

8113967c <OS_EventTaskRemoveMulti>:
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                               OS_EVENT **pevents_multi)
{
8113967c:	defffa04 	addi	sp,sp,-24
81139680:	de00012e 	bgeu	sp,et,81139688 <OS_EventTaskRemoveMulti+0xc>
81139684:	003b68fa 	trap	3
81139688:	df000515 	stw	fp,20(sp)
8113968c:	df000504 	addi	fp,sp,20
81139690:	e13ffe15 	stw	r4,-8(fp)
81139694:	e17fff15 	stw	r5,-4(fp)
    INT16U     bity;
    INT16U     bitx;
#endif


    y       =  ptcb->OSTCBY;
81139698:	e0bffe17 	ldw	r2,-8(fp)
8113969c:	10800d03 	ldbu	r2,52(r2)
811396a0:	e0bffd05 	stb	r2,-12(fp)
    bity    =  ptcb->OSTCBBitY;
811396a4:	e0bffe17 	ldw	r2,-8(fp)
811396a8:	10800d83 	ldbu	r2,54(r2)
811396ac:	e0bffd45 	stb	r2,-11(fp)
    bitx    =  ptcb->OSTCBBitX;
811396b0:	e0bffe17 	ldw	r2,-8(fp)
811396b4:	10800d43 	ldbu	r2,53(r2)
811396b8:	e0bffd85 	stb	r2,-10(fp)
    pevents =  pevents_multi;
811396bc:	e0bfff17 	ldw	r2,-4(fp)
811396c0:	e0bffb15 	stw	r2,-20(fp)
    pevent  = *pevents;
811396c4:	e0bffb17 	ldw	r2,-20(fp)
811396c8:	10800017 	ldw	r2,0(r2)
811396cc:	e0bffc15 	stw	r2,-16(fp)
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
811396d0:	00002506 	br	81139768 <OS_EventTaskRemoveMulti+0xec>
        pevent->OSEventTbl[y]  &= ~bitx;
811396d4:	e0bffd03 	ldbu	r2,-12(fp)
811396d8:	e0fffd03 	ldbu	r3,-12(fp)
811396dc:	e13ffc17 	ldw	r4,-16(fp)
811396e0:	20c7883a 	add	r3,r4,r3
811396e4:	18c002c4 	addi	r3,r3,11
811396e8:	18c00003 	ldbu	r3,0(r3)
811396ec:	1809883a 	mov	r4,r3
811396f0:	e0fffd83 	ldbu	r3,-10(fp)
811396f4:	00c6303a 	nor	r3,zero,r3
811396f8:	20c6703a 	and	r3,r4,r3
811396fc:	1809883a 	mov	r4,r3
81139700:	e0fffc17 	ldw	r3,-16(fp)
81139704:	1885883a 	add	r2,r3,r2
81139708:	108002c4 	addi	r2,r2,11
8113970c:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y] == 0) {
81139710:	e0bffd03 	ldbu	r2,-12(fp)
81139714:	e0fffc17 	ldw	r3,-16(fp)
81139718:	1885883a 	add	r2,r3,r2
8113971c:	108002c4 	addi	r2,r2,11
81139720:	10800003 	ldbu	r2,0(r2)
81139724:	10803fcc 	andi	r2,r2,255
81139728:	1000091e 	bne	r2,zero,81139750 <OS_EventTaskRemoveMulti+0xd4>
            pevent->OSEventGrp &= ~bity;
8113972c:	e0bffc17 	ldw	r2,-16(fp)
81139730:	10800283 	ldbu	r2,10(r2)
81139734:	1007883a 	mov	r3,r2
81139738:	e0bffd43 	ldbu	r2,-11(fp)
8113973c:	0084303a 	nor	r2,zero,r2
81139740:	1884703a 	and	r2,r3,r2
81139744:	1007883a 	mov	r3,r2
81139748:	e0bffc17 	ldw	r2,-16(fp)
8113974c:	10c00285 	stb	r3,10(r2)
        }
        pevents++;
81139750:	e0bffb17 	ldw	r2,-20(fp)
81139754:	10800104 	addi	r2,r2,4
81139758:	e0bffb15 	stw	r2,-20(fp)
        pevent = *pevents;
8113975c:	e0bffb17 	ldw	r2,-20(fp)
81139760:	10800017 	ldw	r2,0(r2)
81139764:	e0bffc15 	stw	r2,-16(fp)
    y       =  ptcb->OSTCBY;
    bity    =  ptcb->OSTCBBitY;
    bitx    =  ptcb->OSTCBBitX;
    pevents =  pevents_multi;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
81139768:	e0bffc17 	ldw	r2,-16(fp)
8113976c:	103fd91e 	bne	r2,zero,811396d4 <__reset+0xfb1196d4>
            pevent->OSEventGrp &= ~bity;
        }
        pevents++;
        pevent = *pevents;
    }
}
81139770:	0001883a 	nop
81139774:	e037883a 	mov	sp,fp
81139778:	df000017 	ldw	fp,0(sp)
8113977c:	dec00104 	addi	sp,sp,4
81139780:	f800283a 	ret

81139784 <OS_EventWaitListInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventWaitListInit (OS_EVENT *pevent)
{
81139784:	defffc04 	addi	sp,sp,-16
81139788:	de00012e 	bgeu	sp,et,81139790 <OS_EventWaitListInit+0xc>
8113978c:	003b68fa 	trap	3
81139790:	df000315 	stw	fp,12(sp)
81139794:	df000304 	addi	fp,sp,12
81139798:	e13fff15 	stw	r4,-4(fp)
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
8113979c:	e0bfff17 	ldw	r2,-4(fp)
811397a0:	10000285 	stb	zero,10(r2)
    ptbl               = &pevent->OSEventTbl[0];
811397a4:	e0bfff17 	ldw	r2,-4(fp)
811397a8:	108002c4 	addi	r2,r2,11
811397ac:	e0bffd15 	stw	r2,-12(fp)

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
811397b0:	e03ffe05 	stb	zero,-8(fp)
811397b4:	00000706 	br	811397d4 <OS_EventWaitListInit+0x50>
        *ptbl++ = 0;
811397b8:	e0bffd17 	ldw	r2,-12(fp)
811397bc:	10c00044 	addi	r3,r2,1
811397c0:	e0fffd15 	stw	r3,-12(fp)
811397c4:	10000005 	stb	zero,0(r2)


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
811397c8:	e0bffe03 	ldbu	r2,-8(fp)
811397cc:	10800044 	addi	r2,r2,1
811397d0:	e0bffe05 	stb	r2,-8(fp)
811397d4:	e0bffe03 	ldbu	r2,-8(fp)
811397d8:	108001b0 	cmpltui	r2,r2,6
811397dc:	103ff61e 	bne	r2,zero,811397b8 <__reset+0xfb1197b8>
        *ptbl++ = 0;
    }
}
811397e0:	0001883a 	nop
811397e4:	e037883a 	mov	sp,fp
811397e8:	df000017 	ldw	fp,0(sp)
811397ec:	dec00104 	addi	sp,sp,4
811397f0:	f800283a 	ret

811397f4 <OS_InitEventList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitEventList (void)
{
811397f4:	defffb04 	addi	sp,sp,-20
811397f8:	de00012e 	bgeu	sp,et,81139800 <OS_InitEventList+0xc>
811397fc:	003b68fa 	trap	3
81139800:	dfc00415 	stw	ra,16(sp)
81139804:	df000315 	stw	fp,12(sp)
81139808:	df000304 	addi	fp,sp,12
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
8113980c:	01434004 	movi	r5,3328
81139810:	012045f4 	movhi	r4,33047
81139814:	212c6b04 	addi	r4,r4,-20052
81139818:	1139b9c0 	call	81139b9c <OS_MemClr>
    pevent1 = &OSEventTbl[0];
8113981c:	00a045f4 	movhi	r2,33047
81139820:	10ac6b04 	addi	r2,r2,-20052
81139824:	e0bffe15 	stw	r2,-8(fp)
    pevent2 = &OSEventTbl[1];
81139828:	00a045f4 	movhi	r2,33047
8113982c:	10ac7804 	addi	r2,r2,-20000
81139830:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
81139834:	e03ffd0d 	sth	zero,-12(fp)
81139838:	00001306 	br	81139888 <OS_InitEventList+0x94>
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113983c:	e0bffe17 	ldw	r2,-8(fp)
81139840:	10000005 	stb	zero,0(r2)
        pevent1->OSEventPtr     = pevent2;
81139844:	e0bffe17 	ldw	r2,-8(fp)
81139848:	e0ffff17 	ldw	r3,-4(fp)
8113984c:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
81139850:	e0bffe17 	ldw	r2,-8(fp)
81139854:	00c00fc4 	movi	r3,63
81139858:	10c00445 	stb	r3,17(r2)
        pevent1->OSEventName[1] = OS_ASCII_NUL;
8113985c:	e0bffe17 	ldw	r2,-8(fp)
81139860:	10000485 	stb	zero,18(r2)
#endif
        pevent1++;
81139864:	e0bffe17 	ldw	r2,-8(fp)
81139868:	10800d04 	addi	r2,r2,52
8113986c:	e0bffe15 	stw	r2,-8(fp)
        pevent2++;
81139870:	e0bfff17 	ldw	r2,-4(fp)
81139874:	10800d04 	addi	r2,r2,52
81139878:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
8113987c:	e0bffd0b 	ldhu	r2,-12(fp)
81139880:	10800044 	addi	r2,r2,1
81139884:	e0bffd0d 	sth	r2,-12(fp)
81139888:	e0bffd0b 	ldhu	r2,-12(fp)
8113988c:	10800ff0 	cmpltui	r2,r2,63
81139890:	103fea1e 	bne	r2,zero,8113983c <__reset+0xfb11983c>
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
81139894:	e0bffe17 	ldw	r2,-8(fp)
81139898:	10000005 	stb	zero,0(r2)
    pevent1->OSEventPtr             = (OS_EVENT *)0;
8113989c:	e0bffe17 	ldw	r2,-8(fp)
811398a0:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';
811398a4:	e0bffe17 	ldw	r2,-8(fp)
811398a8:	00c00fc4 	movi	r3,63
811398ac:	10c00445 	stb	r3,17(r2)
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
811398b0:	e0bffe17 	ldw	r2,-8(fp)
811398b4:	10000485 	stb	zero,18(r2)
#endif
    OSEventFreeList                 = &OSEventTbl[0];
811398b8:	00a045f4 	movhi	r2,33047
811398bc:	10ac6b04 	addi	r2,r2,-20052
811398c0:	d0a0a015 	stw	r2,-32128(gp)
    OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
    OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
#endif
#endif
#endif
}
811398c4:	0001883a 	nop
811398c8:	e037883a 	mov	sp,fp
811398cc:	dfc00117 	ldw	ra,4(sp)
811398d0:	df000017 	ldw	fp,0(sp)
811398d4:	dec00204 	addi	sp,sp,8
811398d8:	f800283a 	ret

811398dc <OS_InitMisc>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitMisc (void)
{
811398dc:	deffff04 	addi	sp,sp,-4
811398e0:	de00012e 	bgeu	sp,et,811398e8 <OS_InitMisc+0xc>
811398e4:	003b68fa 	trap	3
811398e8:	df000015 	stw	fp,0(sp)
811398ec:	d839883a 	mov	fp,sp
#if OS_TIME_GET_SET_EN > 0
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
811398f0:	d020a415 	stw	zero,-32112(gp)
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
811398f4:	d020a105 	stb	zero,-32124(gp)
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
811398f8:	d0208f05 	stb	zero,-32196(gp)

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
811398fc:	d0209a45 	stb	zero,-32151(gp)

    OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
81139900:	d0209105 	stb	zero,-32188(gp)

    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
81139904:	d0209615 	stw	zero,-32168(gp)
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
81139908:	d0209215 	stw	zero,-32184(gp)

#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
8113990c:	d020a815 	stw	zero,-32096(gp)
    OSIdleCtrMax  = 0L;
81139910:	d0209815 	stw	zero,-32160(gp)
    OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
81139914:	d020a705 	stb	zero,-32100(gp)
#endif
}
81139918:	0001883a 	nop
8113991c:	e037883a 	mov	sp,fp
81139920:	df000017 	ldw	fp,0(sp)
81139924:	dec00104 	addi	sp,sp,4
81139928:	f800283a 	ret

8113992c <OS_InitRdyList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitRdyList (void)
{
8113992c:	defffd04 	addi	sp,sp,-12
81139930:	de00012e 	bgeu	sp,et,81139938 <OS_InitRdyList+0xc>
81139934:	003b68fa 	trap	3
81139938:	df000215 	stw	fp,8(sp)
8113993c:	df000204 	addi	fp,sp,8
#else
    INT16U  *prdytbl;
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
81139940:	d0209e05 	stb	zero,-32136(gp)
    prdytbl       = &OSRdyTbl[0];
81139944:	d0a09e44 	addi	r2,gp,-32135
81139948:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
8113994c:	e03ffe05 	stb	zero,-8(fp)
81139950:	00000706 	br	81139970 <OS_InitRdyList+0x44>
        *prdytbl++ = 0;
81139954:	e0bfff17 	ldw	r2,-4(fp)
81139958:	10c00044 	addi	r3,r2,1
8113995c:	e0ffff15 	stw	r3,-4(fp)
81139960:	10000005 	stb	zero,0(r2)
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
81139964:	e0bffe03 	ldbu	r2,-8(fp)
81139968:	10800044 	addi	r2,r2,1
8113996c:	e0bffe05 	stb	r2,-8(fp)
81139970:	e0bffe03 	ldbu	r2,-8(fp)
81139974:	108001b0 	cmpltui	r2,r2,6
81139978:	103ff61e 	bne	r2,zero,81139954 <__reset+0xfb119954>
        *prdytbl++ = 0;
    }

    OSPrioCur     = 0;
8113997c:	d02093c5 	stb	zero,-32177(gp)
    OSPrioHighRdy = 0;
81139980:	d0209385 	stb	zero,-32178(gp)

    OSTCBHighRdy  = (OS_TCB *)0;
81139984:	d0209c15 	stw	zero,-32144(gp)
    OSTCBCur      = (OS_TCB *)0;
81139988:	d020a215 	stw	zero,-32120(gp)
}
8113998c:	0001883a 	nop
81139990:	e037883a 	mov	sp,fp
81139994:	df000017 	ldw	fp,0(sp)
81139998:	dec00104 	addi	sp,sp,4
8113999c:	f800283a 	ret

811399a0 <OS_InitTaskIdle>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTaskIdle (void)
{
811399a0:	defff804 	addi	sp,sp,-32
811399a4:	de00012e 	bgeu	sp,et,811399ac <OS_InitTaskIdle+0xc>
811399a8:	003b68fa 	trap	3
811399ac:	dfc00715 	stw	ra,28(sp)
811399b0:	df000615 	stw	fp,24(sp)
811399b4:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
811399b8:	008000c4 	movi	r2,3
811399bc:	d8800415 	stw	r2,16(sp)
811399c0:	d8000315 	stw	zero,12(sp)
811399c4:	00810004 	movi	r2,1024
811399c8:	d8800215 	stw	r2,8(sp)
811399cc:	00a045f4 	movhi	r2,33047
811399d0:	10a86b04 	addi	r2,r2,-24148
811399d4:	d8800115 	stw	r2,4(sp)
811399d8:	00bfffd4 	movui	r2,65535
811399dc:	d8800015 	stw	r2,0(sp)
811399e0:	01c00a84 	movi	r7,42
811399e4:	01a045f4 	movhi	r6,33047
811399e8:	31ac6a04 	addi	r6,r6,-20056
811399ec:	000b883a 	mov	r5,zero
811399f0:	01204534 	movhi	r4,33044
811399f4:	2127a504 	addi	r4,r4,-24940
811399f8:	113f8840 	call	8113f884 <OSTaskCreateExt>
                       OS_TASK_IDLE_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
811399fc:	e1bfff04 	addi	r6,fp,-4
81139a00:	01604574 	movhi	r5,33045
81139a04:	2944da04 	addi	r5,r5,4968
81139a08:	01000a84 	movi	r4,42
81139a0c:	11400b40 	call	811400b4 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
#endif
#endif
}
81139a10:	0001883a 	nop
81139a14:	e037883a 	mov	sp,fp
81139a18:	dfc00117 	ldw	ra,4(sp)
81139a1c:	df000017 	ldw	fp,0(sp)
81139a20:	dec00204 	addi	sp,sp,8
81139a24:	f800283a 	ret

81139a28 <OS_InitTaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
static  void  OS_InitTaskStat (void)
{
81139a28:	defff804 	addi	sp,sp,-32
81139a2c:	de00012e 	bgeu	sp,et,81139a34 <OS_InitTaskStat+0xc>
81139a30:	003b68fa 	trap	3
81139a34:	dfc00715 	stw	ra,28(sp)
81139a38:	df000615 	stw	fp,24(sp)
81139a3c:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskStat,
81139a40:	008000c4 	movi	r2,3
81139a44:	d8800415 	stw	r2,16(sp)
81139a48:	d8000315 	stw	zero,12(sp)
81139a4c:	00810004 	movi	r2,1024
81139a50:	d8800215 	stw	r2,8(sp)
81139a54:	00a045f4 	movhi	r2,33047
81139a58:	10a1ab04 	addi	r2,r2,-31060
81139a5c:	d8800115 	stw	r2,4(sp)
81139a60:	00bfff94 	movui	r2,65534
81139a64:	d8800015 	stw	r2,0(sp)
81139a68:	01c00a44 	movi	r7,41
81139a6c:	01a045f4 	movhi	r6,33047
81139a70:	31a5aa04 	addi	r6,r6,-26968
81139a74:	000b883a 	mov	r5,zero
81139a78:	01204534 	movhi	r4,33044
81139a7c:	2127be04 	addi	r4,r4,-24840
81139a80:	113f8840 	call	8113f884 <OSTaskCreateExt>
                       OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
81139a84:	e1bfff04 	addi	r6,fp,-4
81139a88:	01604574 	movhi	r5,33045
81139a8c:	2944de04 	addi	r5,r5,4984
81139a90:	01000a44 	movi	r4,41
81139a94:	11400b40 	call	811400b4 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
#endif
#endif
}
81139a98:	0001883a 	nop
81139a9c:	e037883a 	mov	sp,fp
81139aa0:	dfc00117 	ldw	ra,4(sp)
81139aa4:	df000017 	ldw	fp,0(sp)
81139aa8:	dec00204 	addi	sp,sp,8
81139aac:	f800283a 	ret

81139ab0 <OS_InitTCBList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTCBList (void)
{
81139ab0:	defffb04 	addi	sp,sp,-20
81139ab4:	de00012e 	bgeu	sp,et,81139abc <OS_InitTCBList+0xc>
81139ab8:	003b68fa 	trap	3
81139abc:	dfc00415 	stw	ra,16(sp)
81139ac0:	df000315 	stw	fp,12(sp)
81139ac4:	df000304 	addi	fp,sp,12
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
81139ac8:	01446e04 	movi	r5,4536
81139acc:	012045f4 	movhi	r4,33047
81139ad0:	212fab04 	addi	r4,r4,-16724
81139ad4:	1139b9c0 	call	81139b9c <OS_MemClr>
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
81139ad8:	01402b04 	movi	r5,172
81139adc:	012045f4 	movhi	r4,33047
81139ae0:	21341904 	addi	r4,r4,-12188
81139ae4:	1139b9c0 	call	81139b9c <OS_MemClr>
    ptcb1 = &OSTCBTbl[0];
81139ae8:	00a045f4 	movhi	r2,33047
81139aec:	10afab04 	addi	r2,r2,-16724
81139af0:	e0bffe15 	stw	r2,-8(fp)
    ptcb2 = &OSTCBTbl[1];
81139af4:	00a045f4 	movhi	r2,33047
81139af8:	10afc604 	addi	r2,r2,-16616
81139afc:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
81139b00:	e03ffd05 	stb	zero,-12(fp)
81139b04:	00001106 	br	81139b4c <OS_InitTCBList+0x9c>
        ptcb1->OSTCBNext = ptcb2;
81139b08:	e0bffe17 	ldw	r2,-8(fp)
81139b0c:	e0ffff17 	ldw	r3,-4(fp)
81139b10:	10c00515 	stw	r3,20(r2)
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
81139b14:	e0bffe17 	ldw	r2,-8(fp)
81139b18:	00c00fc4 	movi	r3,63
81139b1c:	10c01305 	stb	r3,76(r2)
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
81139b20:	e0bffe17 	ldw	r2,-8(fp)
81139b24:	10001345 	stb	zero,77(r2)
#endif
        ptcb1++;
81139b28:	e0bffe17 	ldw	r2,-8(fp)
81139b2c:	10801b04 	addi	r2,r2,108
81139b30:	e0bffe15 	stw	r2,-8(fp)
        ptcb2++;
81139b34:	e0bfff17 	ldw	r2,-4(fp)
81139b38:	10801b04 	addi	r2,r2,108
81139b3c:	e0bfff15 	stw	r2,-4(fp)

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
81139b40:	e0bffd03 	ldbu	r2,-12(fp)
81139b44:	10800044 	addi	r2,r2,1
81139b48:	e0bffd05 	stb	r2,-12(fp)
81139b4c:	e0bffd03 	ldbu	r2,-12(fp)
81139b50:	10800a70 	cmpltui	r2,r2,41
81139b54:	103fec1e 	bne	r2,zero,81139b08 <__reset+0xfb119b08>
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
81139b58:	e0bffe17 	ldw	r2,-8(fp)
81139b5c:	10000515 	stw	zero,20(r2)
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
81139b60:	e0bffe17 	ldw	r2,-8(fp)
81139b64:	00c00fc4 	movi	r3,63
81139b68:	10c01305 	stb	r3,76(r2)
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
81139b6c:	e0bffe17 	ldw	r2,-8(fp)
81139b70:	10001345 	stb	zero,77(r2)
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
81139b74:	d0209415 	stw	zero,-32176(gp)
    OSTCBFreeList           = &OSTCBTbl[0];
81139b78:	00a045f4 	movhi	r2,33047
81139b7c:	10afab04 	addi	r2,r2,-16724
81139b80:	d0a09915 	stw	r2,-32156(gp)
}
81139b84:	0001883a 	nop
81139b88:	e037883a 	mov	sp,fp
81139b8c:	dfc00117 	ldw	ra,4(sp)
81139b90:	df000017 	ldw	fp,0(sp)
81139b94:	dec00204 	addi	sp,sp,8
81139b98:	f800283a 	ret

81139b9c <OS_MemClr>:
*                 of the alignment of the destination.
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
81139b9c:	defffd04 	addi	sp,sp,-12
81139ba0:	de00012e 	bgeu	sp,et,81139ba8 <OS_MemClr+0xc>
81139ba4:	003b68fa 	trap	3
81139ba8:	df000215 	stw	fp,8(sp)
81139bac:	df000204 	addi	fp,sp,8
81139bb0:	e13ffe15 	stw	r4,-8(fp)
81139bb4:	2805883a 	mov	r2,r5
81139bb8:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
81139bbc:	00000706 	br	81139bdc <OS_MemClr+0x40>
        *pdest++ = (INT8U)0;
81139bc0:	e0bffe17 	ldw	r2,-8(fp)
81139bc4:	10c00044 	addi	r3,r2,1
81139bc8:	e0fffe15 	stw	r3,-8(fp)
81139bcc:	10000005 	stb	zero,0(r2)
        size--;
81139bd0:	e0bfff0b 	ldhu	r2,-4(fp)
81139bd4:	10bfffc4 	addi	r2,r2,-1
81139bd8:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
81139bdc:	e0bfff0b 	ldhu	r2,-4(fp)
81139be0:	103ff71e 	bne	r2,zero,81139bc0 <__reset+0xfb119bc0>
        *pdest++ = (INT8U)0;
        size--;
    }
}
81139be4:	0001883a 	nop
81139be8:	e037883a 	mov	sp,fp
81139bec:	df000017 	ldw	fp,0(sp)
81139bf0:	dec00104 	addi	sp,sp,4
81139bf4:	f800283a 	ret

81139bf8 <OS_MemCopy>:
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
81139bf8:	defffc04 	addi	sp,sp,-16
81139bfc:	de00012e 	bgeu	sp,et,81139c04 <OS_MemCopy+0xc>
81139c00:	003b68fa 	trap	3
81139c04:	df000315 	stw	fp,12(sp)
81139c08:	df000304 	addi	fp,sp,12
81139c0c:	e13ffd15 	stw	r4,-12(fp)
81139c10:	e17ffe15 	stw	r5,-8(fp)
81139c14:	3005883a 	mov	r2,r6
81139c18:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
81139c1c:	00000b06 	br	81139c4c <OS_MemCopy+0x54>
        *pdest++ = *psrc++;
81139c20:	e0bffd17 	ldw	r2,-12(fp)
81139c24:	10c00044 	addi	r3,r2,1
81139c28:	e0fffd15 	stw	r3,-12(fp)
81139c2c:	e0fffe17 	ldw	r3,-8(fp)
81139c30:	19000044 	addi	r4,r3,1
81139c34:	e13ffe15 	stw	r4,-8(fp)
81139c38:	18c00003 	ldbu	r3,0(r3)
81139c3c:	10c00005 	stb	r3,0(r2)
        size--;
81139c40:	e0bfff0b 	ldhu	r2,-4(fp)
81139c44:	10bfffc4 	addi	r2,r2,-1
81139c48:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
81139c4c:	e0bfff0b 	ldhu	r2,-4(fp)
81139c50:	103ff31e 	bne	r2,zero,81139c20 <__reset+0xfb119c20>
        *pdest++ = *psrc++;
        size--;
    }
}
81139c54:	0001883a 	nop
81139c58:	e037883a 	mov	sp,fp
81139c5c:	df000017 	ldw	fp,0(sp)
81139c60:	dec00104 	addi	sp,sp,4
81139c64:	f800283a 	ret

81139c68 <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
81139c68:	defffb04 	addi	sp,sp,-20
81139c6c:	de00012e 	bgeu	sp,et,81139c74 <OS_Sched+0xc>
81139c70:	003b68fa 	trap	3
81139c74:	dfc00415 	stw	ra,16(sp)
81139c78:	df000315 	stw	fp,12(sp)
81139c7c:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81139c80:	e03ffd15 	stw	zero,-12(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139c84:	0005303a 	rdctl	r2,status
81139c88:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139c8c:	e0ffff17 	ldw	r3,-4(fp)
81139c90:	00bfff84 	movi	r2,-2
81139c94:	1884703a 	and	r2,r3,r2
81139c98:	1001703a 	wrctl	status,r2
  
  return context;
81139c9c:	e0bfff17 	ldw	r2,-4(fp)
#endif



    OS_ENTER_CRITICAL();
81139ca0:	e0bffd15 	stw	r2,-12(fp)
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
81139ca4:	d0a0a103 	ldbu	r2,-32124(gp)
81139ca8:	10803fcc 	andi	r2,r2,255
81139cac:	10001a1e 	bne	r2,zero,81139d18 <OS_Sched+0xb0>
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
81139cb0:	d0a08f03 	ldbu	r2,-32196(gp)
81139cb4:	10803fcc 	andi	r2,r2,255
81139cb8:	1000171e 	bne	r2,zero,81139d18 <OS_Sched+0xb0>
            OS_SchedNew();
81139cbc:	1139d400 	call	81139d40 <OS_SchedNew>
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
81139cc0:	d0e09383 	ldbu	r3,-32178(gp)
81139cc4:	d0a093c3 	ldbu	r2,-32177(gp)
81139cc8:	18c03fcc 	andi	r3,r3,255
81139ccc:	10803fcc 	andi	r2,r2,255
81139cd0:	18801126 	beq	r3,r2,81139d18 <OS_Sched+0xb0>
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
81139cd4:	d0a09383 	ldbu	r2,-32178(gp)
81139cd8:	10c03fcc 	andi	r3,r2,255
81139cdc:	00a045f4 	movhi	r2,33047
81139ce0:	10b41904 	addi	r2,r2,-12188
81139ce4:	18c7883a 	add	r3,r3,r3
81139ce8:	18c7883a 	add	r3,r3,r3
81139cec:	10c5883a 	add	r2,r2,r3
81139cf0:	10800017 	ldw	r2,0(r2)
81139cf4:	d0a09c15 	stw	r2,-32144(gp)
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
81139cf8:	d0a09c17 	ldw	r2,-32144(gp)
81139cfc:	10c00e17 	ldw	r3,56(r2)
81139d00:	18c00044 	addi	r3,r3,1
81139d04:	10c00e15 	stw	r3,56(r2)
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
81139d08:	d0a09617 	ldw	r2,-32168(gp)
81139d0c:	10800044 	addi	r2,r2,1
81139d10:	d0a09615 	stw	r2,-32168(gp)
                OS_TASK_SW();                          /* Perform a context switch                     */
81139d14:	114ac980 	call	8114ac98 <OSCtxSw>
81139d18:	e0bffd17 	ldw	r2,-12(fp)
81139d1c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139d20:	e0bffe17 	ldw	r2,-8(fp)
81139d24:	1001703a 	wrctl	status,r2
            }
        }
    }
    OS_EXIT_CRITICAL();
}
81139d28:	0001883a 	nop
81139d2c:	e037883a 	mov	sp,fp
81139d30:	dfc00117 	ldw	ra,4(sp)
81139d34:	df000017 	ldw	fp,0(sp)
81139d38:	dec00204 	addi	sp,sp,8
81139d3c:	f800283a 	ret

81139d40 <OS_SchedNew>:
*              2) Interrupts are assumed to be disabled when this function is called.
*********************************************************************************************************
*/

static  void  OS_SchedNew (void)
{
81139d40:	defffe04 	addi	sp,sp,-8
81139d44:	de00012e 	bgeu	sp,et,81139d4c <OS_SchedNew+0xc>
81139d48:	003b68fa 	trap	3
81139d4c:	df000115 	stw	fp,4(sp)
81139d50:	df000104 	addi	fp,sp,4
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
81139d54:	d0a09e03 	ldbu	r2,-32136(gp)
81139d58:	10c03fcc 	andi	r3,r2,255
81139d5c:	00a04574 	movhi	r2,33045
81139d60:	10849a04 	addi	r2,r2,4712
81139d64:	10c5883a 	add	r2,r2,r3
81139d68:	10800003 	ldbu	r2,0(r2)
81139d6c:	e0bfff05 	stb	r2,-4(fp)
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
81139d70:	e0bfff03 	ldbu	r2,-4(fp)
81139d74:	100490fa 	slli	r2,r2,3
81139d78:	1009883a 	mov	r4,r2
81139d7c:	e0ffff03 	ldbu	r3,-4(fp)
81139d80:	d0a09e44 	addi	r2,gp,-32135
81139d84:	1885883a 	add	r2,r3,r2
81139d88:	10800003 	ldbu	r2,0(r2)
81139d8c:	10c03fcc 	andi	r3,r2,255
81139d90:	00a04574 	movhi	r2,33045
81139d94:	10849a04 	addi	r2,r2,4712
81139d98:	10c5883a 	add	r2,r2,r3
81139d9c:	10800003 	ldbu	r2,0(r2)
81139da0:	2085883a 	add	r2,r4,r2
81139da4:	d0a09385 	stb	r2,-32178(gp)
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
    } else {
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
    }
#endif
}
81139da8:	0001883a 	nop
81139dac:	e037883a 	mov	sp,fp
81139db0:	df000017 	ldw	fp,0(sp)
81139db4:	dec00104 	addi	sp,sp,4
81139db8:	f800283a 	ret

81139dbc <OS_StrCopy>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
{
81139dbc:	defffc04 	addi	sp,sp,-16
81139dc0:	de00012e 	bgeu	sp,et,81139dc8 <OS_StrCopy+0xc>
81139dc4:	003b68fa 	trap	3
81139dc8:	df000315 	stw	fp,12(sp)
81139dcc:	df000304 	addi	fp,sp,12
81139dd0:	e13ffe15 	stw	r4,-8(fp)
81139dd4:	e17fff15 	stw	r5,-4(fp)
    INT8U  len;


    len = 0;
81139dd8:	e03ffd05 	stb	zero,-12(fp)
    while (*psrc != OS_ASCII_NUL) {
81139ddc:	00000b06 	br	81139e0c <OS_StrCopy+0x50>
        *pdest++ = *psrc++;
81139de0:	e0bffe17 	ldw	r2,-8(fp)
81139de4:	10c00044 	addi	r3,r2,1
81139de8:	e0fffe15 	stw	r3,-8(fp)
81139dec:	e0ffff17 	ldw	r3,-4(fp)
81139df0:	19000044 	addi	r4,r3,1
81139df4:	e13fff15 	stw	r4,-4(fp)
81139df8:	18c00003 	ldbu	r3,0(r3)
81139dfc:	10c00005 	stb	r3,0(r2)
        len++;
81139e00:	e0bffd03 	ldbu	r2,-12(fp)
81139e04:	10800044 	addi	r2,r2,1
81139e08:	e0bffd05 	stb	r2,-12(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
81139e0c:	e0bfff17 	ldw	r2,-4(fp)
81139e10:	10800003 	ldbu	r2,0(r2)
81139e14:	10803fcc 	andi	r2,r2,255
81139e18:	103ff11e 	bne	r2,zero,81139de0 <__reset+0xfb119de0>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
81139e1c:	e0bffe17 	ldw	r2,-8(fp)
81139e20:	10000005 	stb	zero,0(r2)
    return (len);
81139e24:	e0bffd03 	ldbu	r2,-12(fp)
}
81139e28:	e037883a 	mov	sp,fp
81139e2c:	df000017 	ldw	fp,0(sp)
81139e30:	dec00104 	addi	sp,sp,4
81139e34:	f800283a 	ret

81139e38 <OS_StrLen>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrLen (INT8U *psrc)
{
81139e38:	defffd04 	addi	sp,sp,-12
81139e3c:	de00012e 	bgeu	sp,et,81139e44 <OS_StrLen+0xc>
81139e40:	003b68fa 	trap	3
81139e44:	df000215 	stw	fp,8(sp)
81139e48:	df000204 	addi	fp,sp,8
81139e4c:	e13fff15 	stw	r4,-4(fp)
    INT8U  len;


    len = 0;
81139e50:	e03ffe05 	stb	zero,-8(fp)
    while (*psrc != OS_ASCII_NUL) {
81139e54:	00000606 	br	81139e70 <OS_StrLen+0x38>
        psrc++;
81139e58:	e0bfff17 	ldw	r2,-4(fp)
81139e5c:	10800044 	addi	r2,r2,1
81139e60:	e0bfff15 	stw	r2,-4(fp)
        len++;
81139e64:	e0bffe03 	ldbu	r2,-8(fp)
81139e68:	10800044 	addi	r2,r2,1
81139e6c:	e0bffe05 	stb	r2,-8(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
81139e70:	e0bfff17 	ldw	r2,-4(fp)
81139e74:	10800003 	ldbu	r2,0(r2)
81139e78:	10803fcc 	andi	r2,r2,255
81139e7c:	103ff61e 	bne	r2,zero,81139e58 <__reset+0xfb119e58>
        psrc++;
        len++;
    }
    return (len);
81139e80:	e0bffe03 	ldbu	r2,-8(fp)
}
81139e84:	e037883a 	mov	sp,fp
81139e88:	df000017 	ldw	fp,0(sp)
81139e8c:	dec00104 	addi	sp,sp,4
81139e90:	f800283a 	ret

81139e94 <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *p_arg)
{
81139e94:	defffa04 	addi	sp,sp,-24
81139e98:	de00012e 	bgeu	sp,et,81139ea0 <OS_TaskIdle+0xc>
81139e9c:	003b68fa 	trap	3
81139ea0:	dfc00515 	stw	ra,20(sp)
81139ea4:	df000415 	stw	fp,16(sp)
81139ea8:	df000404 	addi	fp,sp,16
81139eac:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81139eb0:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139eb4:	0005303a 	rdctl	r2,status
81139eb8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139ebc:	e0fffd17 	ldw	r3,-12(fp)
81139ec0:	00bfff84 	movi	r2,-2
81139ec4:	1884703a 	and	r2,r3,r2
81139ec8:	1001703a 	wrctl	status,r2
  
  return context;
81139ecc:	e0bffd17 	ldw	r2,-12(fp)



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    for (;;) {
        OS_ENTER_CRITICAL();
81139ed0:	e0bffc15 	stw	r2,-16(fp)
        OSIdleCtr++;
81139ed4:	d0a09217 	ldw	r2,-32184(gp)
81139ed8:	10800044 	addi	r2,r2,1
81139edc:	d0a09215 	stw	r2,-32184(gp)
81139ee0:	e0bffc17 	ldw	r2,-16(fp)
81139ee4:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139ee8:	e0bffe17 	ldw	r2,-8(fp)
81139eec:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
81139ef0:	114b02c0 	call	8114b02c <OSTaskIdleHook>
    }
81139ef4:	003fef06 	br	81139eb4 <__reset+0xfb119eb4>

81139ef8 <OS_TaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OS_TaskStat (void *p_arg)
{
81139ef8:	defff804 	addi	sp,sp,-32
81139efc:	de00012e 	bgeu	sp,et,81139f04 <OS_TaskStat+0xc>
81139f00:	003b68fa 	trap	3
81139f04:	dfc00715 	stw	ra,28(sp)
81139f08:	df000615 	stw	fp,24(sp)
81139f0c:	dc400515 	stw	r17,20(sp)
81139f10:	dc000415 	stw	r16,16(sp)
81139f14:	df000604 	addi	fp,sp,24
81139f18:	e13ffd15 	stw	r4,-12(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81139f1c:	e03ffa15 	stw	zero,-24(fp)
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
81139f20:	00000206 	br	81139f2c <OS_TaskStat+0x34>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
81139f24:	01003204 	movi	r4,200
81139f28:	11409a40 	call	811409a4 <OSTimeDly>
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
81139f2c:	d0a0a703 	ldbu	r2,-32100(gp)
81139f30:	10803fcc 	andi	r2,r2,255
81139f34:	103ffb26 	beq	r2,zero,81139f24 <__reset+0xfb119f24>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
    }
    OSIdleCtrMax /= 100L;
81139f38:	d0e09817 	ldw	r3,-32160(gp)
81139f3c:	00947b34 	movhi	r2,20972
81139f40:	10a147c4 	addi	r2,r2,-31457
81139f44:	1888383a 	mulxuu	r4,r3,r2
81139f48:	1885383a 	mul	r2,r3,r2
81139f4c:	1021883a 	mov	r16,r2
81139f50:	2023883a 	mov	r17,r4
81139f54:	8804d17a 	srli	r2,r17,5
81139f58:	d0a09815 	stw	r2,-32160(gp)
    if (OSIdleCtrMax == 0L) {
81139f5c:	d0a09817 	ldw	r2,-32160(gp)
81139f60:	1000031e 	bne	r2,zero,81139f70 <OS_TaskStat+0x78>
        OSCPUUsage = 0;
81139f64:	d0209a05 	stb	zero,-32152(gp)
        (void)OSTaskSuspend(OS_PRIO_SELF);
81139f68:	01003fc4 	movi	r4,255
81139f6c:	11406140 	call	81140614 <OSTaskSuspend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139f70:	0005303a 	rdctl	r2,status
81139f74:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139f78:	e0fffb17 	ldw	r3,-20(fp)
81139f7c:	00bfff84 	movi	r2,-2
81139f80:	1884703a 	and	r2,r3,r2
81139f84:	1001703a 	wrctl	status,r2
  
  return context;
81139f88:	e0bffb17 	ldw	r2,-20(fp)
    }
    for (;;) {
        OS_ENTER_CRITICAL();
81139f8c:	e0bffa15 	stw	r2,-24(fp)
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
81139f90:	d0a09217 	ldw	r2,-32184(gp)
81139f94:	d0a0a815 	stw	r2,-32096(gp)
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
81139f98:	d0209215 	stw	zero,-32184(gp)
81139f9c:	e0bffa17 	ldw	r2,-24(fp)
81139fa0:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139fa4:	e0bffc17 	ldw	r2,-16(fp)
81139fa8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
81139fac:	d0e0a817 	ldw	r3,-32096(gp)
81139fb0:	d0a09817 	ldw	r2,-32160(gp)
81139fb4:	1885203a 	divu	r2,r3,r2
81139fb8:	1007883a 	mov	r3,r2
81139fbc:	00801904 	movi	r2,100
81139fc0:	10c5c83a 	sub	r2,r2,r3
81139fc4:	d0a09a05 	stb	r2,-32152(gp)
        OSTaskStatHook();                        /* Invoke user definable hook                         */
81139fc8:	114af5c0 	call	8114af5c <OSTaskStatHook>
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
        OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
81139fcc:	1139fdc0 	call	81139fdc <OS_TaskStatStkChk>
#endif
        OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
81139fd0:	01001904 	movi	r4,100
81139fd4:	11409a40 	call	811409a4 <OSTimeDly>
    }
81139fd8:	003fe506 	br	81139f70 <__reset+0xfb119f70>

81139fdc <OS_TaskStatStkChk>:
*********************************************************************************************************
*/

#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStatStkChk (void)
{
81139fdc:	defffa04 	addi	sp,sp,-24
81139fe0:	de00012e 	bgeu	sp,et,81139fe8 <OS_TaskStatStkChk+0xc>
81139fe4:	003b68fa 	trap	3
81139fe8:	dfc00515 	stw	ra,20(sp)
81139fec:	df000415 	stw	fp,16(sp)
81139ff0:	df000404 	addi	fp,sp,16
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
81139ff4:	e03ffc05 	stb	zero,-16(fp)
81139ff8:	00002406 	br	8113a08c <OS_TaskStatStkChk+0xb0>
        err = OSTaskStkChk(prio, &stk_data);
81139ffc:	e0bffc03 	ldbu	r2,-16(fp)
8113a000:	e0fffe04 	addi	r3,fp,-8
8113a004:	180b883a 	mov	r5,r3
8113a008:	1009883a 	mov	r4,r2
8113a00c:	114044c0 	call	8114044c <OSTaskStkChk>
8113a010:	e0bffc45 	stb	r2,-15(fp)
        if (err == OS_ERR_NONE) {
8113a014:	e0bffc43 	ldbu	r2,-15(fp)
8113a018:	1000191e 	bne	r2,zero,8113a080 <OS_TaskStatStkChk+0xa4>
            ptcb = OSTCBPrioTbl[prio];
8113a01c:	e0fffc03 	ldbu	r3,-16(fp)
8113a020:	00a045f4 	movhi	r2,33047
8113a024:	10b41904 	addi	r2,r2,-12188
8113a028:	18c7883a 	add	r3,r3,r3
8113a02c:	18c7883a 	add	r3,r3,r3
8113a030:	10c5883a 	add	r2,r2,r3
8113a034:	10800017 	ldw	r2,0(r2)
8113a038:	e0bffd15 	stw	r2,-12(fp)
            if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
8113a03c:	e0bffd17 	ldw	r2,-12(fp)
8113a040:	10000f26 	beq	r2,zero,8113a080 <OS_TaskStatStkChk+0xa4>
                if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
8113a044:	e0bffd17 	ldw	r2,-12(fp)
8113a048:	10800060 	cmpeqi	r2,r2,1
8113a04c:	10000c1e 	bne	r2,zero,8113a080 <OS_TaskStatStkChk+0xa4>
#if OS_TASK_PROFILE_EN > 0
                    #if OS_STK_GROWTH == 1
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
8113a050:	e0bffd17 	ldw	r2,-12(fp)
8113a054:	10c00217 	ldw	r3,8(r2)
8113a058:	e0bffd17 	ldw	r2,-12(fp)
8113a05c:	10800317 	ldw	r2,12(r2)
8113a060:	1085883a 	add	r2,r2,r2
8113a064:	1085883a 	add	r2,r2,r2
8113a068:	1887883a 	add	r3,r3,r2
8113a06c:	e0bffd17 	ldw	r2,-12(fp)
8113a070:	10c01115 	stw	r3,68(r2)
                    #else
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    #endif
                    ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
8113a074:	e0ffff17 	ldw	r3,-4(fp)
8113a078:	e0bffd17 	ldw	r2,-12(fp)
8113a07c:	10c01215 	stw	r3,72(r2)
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
8113a080:	e0bffc03 	ldbu	r2,-16(fp)
8113a084:	10800044 	addi	r2,r2,1
8113a088:	e0bffc05 	stb	r2,-16(fp)
8113a08c:	e0bffc03 	ldbu	r2,-16(fp)
8113a090:	10800af0 	cmpltui	r2,r2,43
8113a094:	103fd91e 	bne	r2,zero,81139ffc <__reset+0xfb119ffc>
#endif
                }
            }
        }
    }
}
8113a098:	0001883a 	nop
8113a09c:	e037883a 	mov	sp,fp
8113a0a0:	dfc00117 	ldw	ra,4(sp)
8113a0a4:	df000017 	ldw	fp,0(sp)
8113a0a8:	dec00204 	addi	sp,sp,8
8113a0ac:	f800283a 	ret

8113a0b0 <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
8113a0b0:	defff204 	addi	sp,sp,-56
8113a0b4:	de00012e 	bgeu	sp,et,8113a0bc <OS_TCBInit+0xc>
8113a0b8:	003b68fa 	trap	3
8113a0bc:	dfc00d15 	stw	ra,52(sp)
8113a0c0:	df000c15 	stw	fp,48(sp)
8113a0c4:	df000c04 	addi	fp,sp,48
8113a0c8:	e17ffc15 	stw	r5,-16(fp)
8113a0cc:	e1bffd15 	stw	r6,-12(fp)
8113a0d0:	3807883a 	mov	r3,r7
8113a0d4:	e0800417 	ldw	r2,16(fp)
8113a0d8:	e13ffb05 	stb	r4,-20(fp)
8113a0dc:	e0fffe0d 	sth	r3,-8(fp)
8113a0e0:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113a0e4:	e03ff415 	stw	zero,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a0e8:	0005303a 	rdctl	r2,status
8113a0ec:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a0f0:	e0fffa17 	ldw	r3,-24(fp)
8113a0f4:	00bfff84 	movi	r2,-2
8113a0f8:	1884703a 	and	r2,r3,r2
8113a0fc:	1001703a 	wrctl	status,r2
  
  return context;
8113a100:	e0bffa17 	ldw	r2,-24(fp)
#endif



    OS_ENTER_CRITICAL();
8113a104:	e0bff415 	stw	r2,-48(fp)
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
8113a108:	d0a09917 	ldw	r2,-32156(gp)
8113a10c:	e0bff615 	stw	r2,-40(fp)
    if (ptcb != (OS_TCB *)0) {
8113a110:	e0bff617 	ldw	r2,-40(fp)
8113a114:	10009326 	beq	r2,zero,8113a364 <OS_TCBInit+0x2b4>
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
8113a118:	e0bff617 	ldw	r2,-40(fp)
8113a11c:	10800517 	ldw	r2,20(r2)
8113a120:	d0a09915 	stw	r2,-32156(gp)
8113a124:	e0bff417 	ldw	r2,-48(fp)
8113a128:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a12c:	e0bff817 	ldw	r2,-32(fp)
8113a130:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
8113a134:	e0bff617 	ldw	r2,-40(fp)
8113a138:	e0fffc17 	ldw	r3,-16(fp)
8113a13c:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
8113a140:	e0bff617 	ldw	r2,-40(fp)
8113a144:	e0fffb03 	ldbu	r3,-20(fp)
8113a148:	10c00c85 	stb	r3,50(r2)
        ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
8113a14c:	e0bff617 	ldw	r2,-40(fp)
8113a150:	10000c05 	stb	zero,48(r2)
        ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
8113a154:	e0bff617 	ldw	r2,-40(fp)
8113a158:	10000c45 	stb	zero,49(r2)
        ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
8113a15c:	e0bff617 	ldw	r2,-40(fp)
8113a160:	10000b8d 	sth	zero,46(r2)

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
8113a164:	e0bff617 	ldw	r2,-40(fp)
8113a168:	e0c00317 	ldw	r3,12(fp)
8113a16c:	10c00115 	stw	r3,4(r2)
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
8113a170:	e0bff617 	ldw	r2,-40(fp)
8113a174:	e0c00217 	ldw	r3,8(fp)
8113a178:	10c00315 	stw	r3,12(r2)
        ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
8113a17c:	e0bff617 	ldw	r2,-40(fp)
8113a180:	e0fffd17 	ldw	r3,-12(fp)
8113a184:	10c00215 	stw	r3,8(r2)
        ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
8113a188:	e0bff617 	ldw	r2,-40(fp)
8113a18c:	e0ffff0b 	ldhu	r3,-4(fp)
8113a190:	10c0040d 	sth	r3,16(r2)
        ptcb->OSTCBId            = id;                     /* Store task ID                            */
8113a194:	e0bff617 	ldw	r2,-40(fp)
8113a198:	e0fffe0b 	ldhu	r3,-8(fp)
8113a19c:	10c0048d 	sth	r3,18(r2)
        opt                      = opt;
        id                       = id;
#endif

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
8113a1a0:	e0bff617 	ldw	r2,-40(fp)
8113a1a4:	10000dc5 	stb	zero,55(r2)
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
8113a1a8:	e0bffb03 	ldbu	r2,-20(fp)
8113a1ac:	1004d0fa 	srli	r2,r2,3
8113a1b0:	1007883a 	mov	r3,r2
8113a1b4:	e0bff617 	ldw	r2,-40(fp)
8113a1b8:	10c00d05 	stb	r3,52(r2)
        ptcb->OSTCBX             = (INT8U)(prio & 0x07);
8113a1bc:	e0bffb03 	ldbu	r2,-20(fp)
8113a1c0:	108001cc 	andi	r2,r2,7
8113a1c4:	1007883a 	mov	r3,r2
8113a1c8:	e0bff617 	ldw	r2,-40(fp)
8113a1cc:	10c00cc5 	stb	r3,51(r2)
        ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
8113a1d0:	e0bff617 	ldw	r2,-40(fp)
8113a1d4:	10800d03 	ldbu	r2,52(r2)
8113a1d8:	10803fcc 	andi	r2,r2,255
8113a1dc:	00c00044 	movi	r3,1
8113a1e0:	1884983a 	sll	r2,r3,r2
8113a1e4:	1007883a 	mov	r3,r2
8113a1e8:	e0bff617 	ldw	r2,-40(fp)
8113a1ec:	10c00d85 	stb	r3,54(r2)
        ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
8113a1f0:	e0bff617 	ldw	r2,-40(fp)
8113a1f4:	10800cc3 	ldbu	r2,51(r2)
8113a1f8:	10803fcc 	andi	r2,r2,255
8113a1fc:	00c00044 	movi	r3,1
8113a200:	1884983a 	sll	r2,r3,r2
8113a204:	1007883a 	mov	r3,r2
8113a208:	e0bff617 	ldw	r2,-40(fp)
8113a20c:	10c00d45 	stb	r3,53(r2)
        ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
        ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
#endif

#if (OS_EVENT_EN)
        ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
8113a210:	e0bff617 	ldw	r2,-40(fp)
8113a214:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
        ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
8113a218:	e0bff617 	ldw	r2,-40(fp)
8113a21c:	10000815 	stw	zero,32(r2)
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
8113a220:	e0bff617 	ldw	r2,-40(fp)
8113a224:	10000a15 	stw	zero,40(r2)
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
8113a228:	e0bff617 	ldw	r2,-40(fp)
8113a22c:	10000915 	stw	zero,36(r2)
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
8113a230:	e0bff617 	ldw	r2,-40(fp)
8113a234:	10000e15 	stw	zero,56(r2)
        ptcb->OSTCBCyclesStart = 0L;
8113a238:	e0bff617 	ldw	r2,-40(fp)
8113a23c:	10001015 	stw	zero,64(r2)
        ptcb->OSTCBCyclesTot   = 0L;
8113a240:	e0bff617 	ldw	r2,-40(fp)
8113a244:	10000f15 	stw	zero,60(r2)
        ptcb->OSTCBStkBase     = (OS_STK *)0;
8113a248:	e0bff617 	ldw	r2,-40(fp)
8113a24c:	10001115 	stw	zero,68(r2)
        ptcb->OSTCBStkUsed     = 0L;
8113a250:	e0bff617 	ldw	r2,-40(fp)
8113a254:	10001215 	stw	zero,72(r2)
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
8113a258:	e0bff617 	ldw	r2,-40(fp)
8113a25c:	00c00fc4 	movi	r3,63
8113a260:	10c01305 	stb	r3,76(r2)
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
8113a264:	e0bff617 	ldw	r2,-40(fp)
8113a268:	10001345 	stb	zero,77(r2)
#endif

        OSTCBInitHook(ptcb);
8113a26c:	e13ff617 	ldw	r4,-40(fp)
8113a270:	114b0540 	call	8114b054 <OSTCBInitHook>

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
8113a274:	e13ff617 	ldw	r4,-40(fp)
8113a278:	114aedc0 	call	8114aedc <OSTaskCreateHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a27c:	0005303a 	rdctl	r2,status
8113a280:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a284:	e0fff517 	ldw	r3,-44(fp)
8113a288:	00bfff84 	movi	r2,-2
8113a28c:	1884703a 	and	r2,r3,r2
8113a290:	1001703a 	wrctl	status,r2
  
  return context;
8113a294:	e0bff517 	ldw	r2,-44(fp)

        OS_ENTER_CRITICAL();
8113a298:	e0bff415 	stw	r2,-48(fp)
        OSTCBPrioTbl[prio] = ptcb;
8113a29c:	e0fffb03 	ldbu	r3,-20(fp)
8113a2a0:	00a045f4 	movhi	r2,33047
8113a2a4:	10b41904 	addi	r2,r2,-12188
8113a2a8:	18c7883a 	add	r3,r3,r3
8113a2ac:	18c7883a 	add	r3,r3,r3
8113a2b0:	10c5883a 	add	r2,r2,r3
8113a2b4:	e0fff617 	ldw	r3,-40(fp)
8113a2b8:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
8113a2bc:	d0e09417 	ldw	r3,-32176(gp)
8113a2c0:	e0bff617 	ldw	r2,-40(fp)
8113a2c4:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBPrev    = (OS_TCB *)0;
8113a2c8:	e0bff617 	ldw	r2,-40(fp)
8113a2cc:	10000615 	stw	zero,24(r2)
        if (OSTCBList != (OS_TCB *)0) {
8113a2d0:	d0a09417 	ldw	r2,-32176(gp)
8113a2d4:	10000326 	beq	r2,zero,8113a2e4 <OS_TCBInit+0x234>
            OSTCBList->OSTCBPrev = ptcb;
8113a2d8:	d0a09417 	ldw	r2,-32176(gp)
8113a2dc:	e0fff617 	ldw	r3,-40(fp)
8113a2e0:	10c00615 	stw	r3,24(r2)
        }
        OSTCBList               = ptcb;
8113a2e4:	e0bff617 	ldw	r2,-40(fp)
8113a2e8:	d0a09415 	stw	r2,-32176(gp)
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
8113a2ec:	e0bff617 	ldw	r2,-40(fp)
8113a2f0:	10c00d83 	ldbu	r3,54(r2)
8113a2f4:	d0a09e03 	ldbu	r2,-32136(gp)
8113a2f8:	1884b03a 	or	r2,r3,r2
8113a2fc:	d0a09e05 	stb	r2,-32136(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113a300:	e0bff617 	ldw	r2,-40(fp)
8113a304:	10800d03 	ldbu	r2,52(r2)
8113a308:	10c03fcc 	andi	r3,r2,255
8113a30c:	e0bff617 	ldw	r2,-40(fp)
8113a310:	10800d03 	ldbu	r2,52(r2)
8113a314:	11003fcc 	andi	r4,r2,255
8113a318:	d0a09e44 	addi	r2,gp,-32135
8113a31c:	2085883a 	add	r2,r4,r2
8113a320:	11000003 	ldbu	r4,0(r2)
8113a324:	e0bff617 	ldw	r2,-40(fp)
8113a328:	10800d43 	ldbu	r2,53(r2)
8113a32c:	2084b03a 	or	r2,r4,r2
8113a330:	1009883a 	mov	r4,r2
8113a334:	d0a09e44 	addi	r2,gp,-32135
8113a338:	1885883a 	add	r2,r3,r2
8113a33c:	11000005 	stb	r4,0(r2)
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
8113a340:	d0a09a43 	ldbu	r2,-32151(gp)
8113a344:	10800044 	addi	r2,r2,1
8113a348:	d0a09a45 	stb	r2,-32151(gp)
8113a34c:	e0bff417 	ldw	r2,-48(fp)
8113a350:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a354:	e0bff717 	ldw	r2,-36(fp)
8113a358:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
8113a35c:	0005883a 	mov	r2,zero
8113a360:	00000506 	br	8113a378 <OS_TCBInit+0x2c8>
8113a364:	e0bff417 	ldw	r2,-48(fp)
8113a368:	e0bff915 	stw	r2,-28(fp)
8113a36c:	e0bff917 	ldw	r2,-28(fp)
8113a370:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NO_MORE_TCB);
8113a374:	00801084 	movi	r2,66
}
8113a378:	e037883a 	mov	sp,fp
8113a37c:	dfc00117 	ldw	ra,4(sp)
8113a380:	df000017 	ldw	fp,0(sp)
8113a384:	dec00204 	addi	sp,sp,8
8113a388:	f800283a 	ret

8113a38c <OSDebugInit>:
*********************************************************************************************************
*/

#if OS_DEBUG_EN > 0
void  OSDebugInit (void)
{
8113a38c:	defffe04 	addi	sp,sp,-8
8113a390:	de00012e 	bgeu	sp,et,8113a398 <OSDebugInit+0xc>
8113a394:	003b68fa 	trap	3
8113a398:	df000115 	stw	fp,4(sp)
8113a39c:	df000104 	addi	fp,sp,4
    void  *ptemp;

    
    ptemp = (void *)&OSDebugEn;
8113a3a0:	d0a01804 	addi	r2,gp,-32672
8113a3a4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEndiannessTest;
8113a3a8:	d0a01904 	addi	r2,gp,-32668
8113a3ac:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEventMax;
8113a3b0:	d0a01a84 	addi	r2,gp,-32662
8113a3b4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventNameSize;
8113a3b8:	d0a01b04 	addi	r2,gp,-32660
8113a3bc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventEn;
8113a3c0:	d0a01a04 	addi	r2,gp,-32664
8113a3c4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventSize;
8113a3c8:	d0a01b84 	addi	r2,gp,-32658
8113a3cc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventTblSize;
8113a3d0:	d0a01c04 	addi	r2,gp,-32656
8113a3d4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventMultiEn;
8113a3d8:	d0a01c84 	addi	r2,gp,-32654
8113a3dc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSFlagEn;
8113a3e0:	d0a01d04 	addi	r2,gp,-32652
8113a3e4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagGrpSize;
8113a3e8:	d0a01d84 	addi	r2,gp,-32650
8113a3ec:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNodeSize;
8113a3f0:	d0a01e04 	addi	r2,gp,-32648
8113a3f4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagWidth;
8113a3f8:	d0a01e84 	addi	r2,gp,-32646
8113a3fc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagMax;
8113a400:	d0a01f04 	addi	r2,gp,-32644
8113a404:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNameSize;
8113a408:	d0a01f84 	addi	r2,gp,-32642
8113a40c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSLowestPrio;
8113a410:	d0a02004 	addi	r2,gp,-32640
8113a414:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMboxEn;
8113a418:	d0a02084 	addi	r2,gp,-32638
8113a41c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMemEn;
8113a420:	d0a02104 	addi	r2,gp,-32636
8113a424:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemMax;
8113a428:	d0a02184 	addi	r2,gp,-32634
8113a42c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemNameSize;
8113a430:	d0a02204 	addi	r2,gp,-32632
8113a434:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemSize;
8113a438:	d0a02284 	addi	r2,gp,-32630
8113a43c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemTblSize;
8113a440:	d0a02304 	addi	r2,gp,-32628
8113a444:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMutexEn;
8113a448:	d0a02384 	addi	r2,gp,-32626
8113a44c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSPtrSize;
8113a450:	d0a02404 	addi	r2,gp,-32624
8113a454:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSQEn;
8113a458:	d0a02484 	addi	r2,gp,-32622
8113a45c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQMax;
8113a460:	d0a02504 	addi	r2,gp,-32620
8113a464:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQSize;
8113a468:	d0a02584 	addi	r2,gp,-32618
8113a46c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSRdyTblSize;
8113a470:	d0a02604 	addi	r2,gp,-32616
8113a474:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSSemEn;
8113a478:	d0a02684 	addi	r2,gp,-32614
8113a47c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSStkWidth;
8113a480:	d0a02704 	addi	r2,gp,-32612
8113a484:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTaskCreateEn;
8113a488:	d0a02784 	addi	r2,gp,-32610
8113a48c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskCreateExtEn;
8113a490:	d0a02804 	addi	r2,gp,-32608
8113a494:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskDelEn;
8113a498:	d0a02884 	addi	r2,gp,-32606
8113a49c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskIdleStkSize;
8113a4a0:	d0a02904 	addi	r2,gp,-32604
8113a4a4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskProfileEn;
8113a4a8:	d0a02984 	addi	r2,gp,-32602
8113a4ac:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskMax;
8113a4b0:	d0a02a04 	addi	r2,gp,-32600
8113a4b4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskNameSize;
8113a4b8:	d0a02a84 	addi	r2,gp,-32598
8113a4bc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatEn;
8113a4c0:	d0a02b04 	addi	r2,gp,-32596
8113a4c4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkSize;
8113a4c8:	d0a02b84 	addi	r2,gp,-32594
8113a4cc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkChkEn;
8113a4d0:	d0a02c04 	addi	r2,gp,-32592
8113a4d4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskSwHookEn;
8113a4d8:	d0a02c84 	addi	r2,gp,-32590
8113a4dc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTCBPrioTblMax;
8113a4e0:	d0a02d04 	addi	r2,gp,-32588
8113a4e4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTCBSize;
8113a4e8:	d0a02d84 	addi	r2,gp,-32586
8113a4ec:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTicksPerSec;
8113a4f0:	d0a02e04 	addi	r2,gp,-32584
8113a4f4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTimeTickHookEn;
8113a4f8:	d0a02e84 	addi	r2,gp,-32582
8113a4fc:	e0bfff15 	stw	r2,-4(fp)

#if OS_TMR_EN > 0
    ptemp = (void *)&OSTmrTbl[0];
8113a500:	00a045b4 	movhi	r2,33046
8113a504:	109e3704 	addi	r2,r2,30940
8113a508:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrWheelTbl[0];
8113a50c:	00a045b4 	movhi	r2,33046
8113a510:	109c2304 	addi	r2,r2,28812
8113a514:	e0bfff15 	stw	r2,-4(fp)
    
    ptemp = (void *)&OSTmrEn;
8113a518:	d0a02f84 	addi	r2,gp,-32578
8113a51c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgMax;
8113a520:	d0a03004 	addi	r2,gp,-32576
8113a524:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgNameSize;
8113a528:	d0a03084 	addi	r2,gp,-32574
8113a52c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgWheelSize;
8113a530:	d0a03104 	addi	r2,gp,-32572
8113a534:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgTicksPerSec;
8113a538:	d0a03184 	addi	r2,gp,-32570
8113a53c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrSize;
8113a540:	d0a03204 	addi	r2,gp,-32568
8113a544:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrTblSize;
8113a548:	d0a03284 	addi	r2,gp,-32566
8113a54c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTmrWheelSize;
8113a550:	d0a03304 	addi	r2,gp,-32564
8113a554:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrWheelTblSize;
8113a558:	d0a03384 	addi	r2,gp,-32562
8113a55c:	e0bfff15 	stw	r2,-4(fp)
#endif

    ptemp = (void *)&OSVersionNbr;
8113a560:	d0a02f04 	addi	r2,gp,-32580
8113a564:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSDataSize;
8113a568:	d0a03404 	addi	r2,gp,-32560
8113a56c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = ptemp;                             /* Prevent compiler warning for 'ptemp' not being used! */
}
8113a570:	0001883a 	nop
8113a574:	e037883a 	mov	sp,fp
8113a578:	df000017 	ldw	fp,0(sp)
8113a57c:	dec00104 	addi	sp,sp,4
8113a580:	f800283a 	ret

8113a584 <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)
{
8113a584:	defff204 	addi	sp,sp,-56
8113a588:	de00012e 	bgeu	sp,et,8113a590 <OSFlagAccept+0xc>
8113a58c:	003b68fa 	trap	3
8113a590:	df000d15 	stw	fp,52(sp)
8113a594:	df000d04 	addi	fp,sp,52
8113a598:	e13ffc15 	stw	r4,-16(fp)
8113a59c:	2807883a 	mov	r3,r5
8113a5a0:	3005883a 	mov	r2,r6
8113a5a4:	e1ffff15 	stw	r7,-4(fp)
8113a5a8:	e0fffd0d 	sth	r3,-12(fp)
8113a5ac:	e0bffe05 	stb	r2,-8(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8113a5b0:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113a5b4:	e0bfff17 	ldw	r2,-4(fp)
8113a5b8:	1000021e 	bne	r2,zero,8113a5c4 <OSFlagAccept+0x40>
        return ((OS_FLAGS)0);
8113a5bc:	0005883a 	mov	r2,zero
8113a5c0:	0000b006 	br	8113a884 <OSFlagAccept+0x300>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
8113a5c4:	e0bffc17 	ldw	r2,-16(fp)
8113a5c8:	1000051e 	bne	r2,zero,8113a5e0 <OSFlagAccept+0x5c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113a5cc:	e0bfff17 	ldw	r2,-4(fp)
8113a5d0:	00c01b84 	movi	r3,110
8113a5d4:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113a5d8:	0005883a 	mov	r2,zero
8113a5dc:	0000a906 	br	8113a884 <OSFlagAccept+0x300>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
8113a5e0:	e0bffc17 	ldw	r2,-16(fp)
8113a5e4:	10800003 	ldbu	r2,0(r2)
8113a5e8:	10803fcc 	andi	r2,r2,255
8113a5ec:	10800160 	cmpeqi	r2,r2,5
8113a5f0:	1000051e 	bne	r2,zero,8113a608 <OSFlagAccept+0x84>
        *perr = OS_ERR_EVENT_TYPE;
8113a5f4:	e0bfff17 	ldw	r2,-4(fp)
8113a5f8:	00c00044 	movi	r3,1
8113a5fc:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113a600:	0005883a 	mov	r2,zero
8113a604:	00009f06 	br	8113a884 <OSFlagAccept+0x300>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
8113a608:	e0fffe03 	ldbu	r3,-8(fp)
8113a60c:	00bfe004 	movi	r2,-128
8113a610:	1884703a 	and	r2,r3,r2
8113a614:	e0bff505 	stb	r2,-44(fp)
    if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
8113a618:	e0bff503 	ldbu	r2,-44(fp)
8113a61c:	10000626 	beq	r2,zero,8113a638 <OSFlagAccept+0xb4>
        wait_type &= ~OS_FLAG_CONSUME;
8113a620:	e0bffe03 	ldbu	r2,-8(fp)
8113a624:	10801fcc 	andi	r2,r2,127
8113a628:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
8113a62c:	00800044 	movi	r2,1
8113a630:	e0bff385 	stb	r2,-50(fp)
8113a634:	00000106 	br	8113a63c <OSFlagAccept+0xb8>
    } else {
        consume    = OS_FALSE;
8113a638:	e03ff385 	stb	zero,-50(fp)
    }
/*$PAGE*/
    *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
8113a63c:	e0bfff17 	ldw	r2,-4(fp)
8113a640:	10000005 	stb	zero,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a644:	0005303a 	rdctl	r2,status
8113a648:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a64c:	e0fffb17 	ldw	r3,-20(fp)
8113a650:	00bfff84 	movi	r2,-2
8113a654:	1884703a 	and	r2,r3,r2
8113a658:	1001703a 	wrctl	status,r2
  
  return context;
8113a65c:	e0bffb17 	ldw	r2,-20(fp)
    OS_ENTER_CRITICAL();
8113a660:	e0bff415 	stw	r2,-48(fp)
    switch (wait_type) {
8113a664:	e0bffe03 	ldbu	r2,-8(fp)
8113a668:	10c00060 	cmpeqi	r3,r2,1
8113a66c:	18005f1e 	bne	r3,zero,8113a7ec <OSFlagAccept+0x268>
8113a670:	10c00088 	cmpgei	r3,r2,2
8113a674:	1800021e 	bne	r3,zero,8113a680 <OSFlagAccept+0xfc>
8113a678:	10003f26 	beq	r2,zero,8113a778 <OSFlagAccept+0x1f4>
8113a67c:	00007706 	br	8113a85c <OSFlagAccept+0x2d8>
8113a680:	10c000a0 	cmpeqi	r3,r2,2
8113a684:	1800031e 	bne	r3,zero,8113a694 <OSFlagAccept+0x110>
8113a688:	108000e0 	cmpeqi	r2,r2,3
8113a68c:	10001e1e 	bne	r2,zero,8113a708 <OSFlagAccept+0x184>
8113a690:	00007206 	br	8113a85c <OSFlagAccept+0x2d8>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
8113a694:	e0bffc17 	ldw	r2,-16(fp)
8113a698:	10c0020b 	ldhu	r3,8(r2)
8113a69c:	e0bffd0b 	ldhu	r2,-12(fp)
8113a6a0:	1884703a 	and	r2,r3,r2
8113a6a4:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
8113a6a8:	e0fff30b 	ldhu	r3,-52(fp)
8113a6ac:	e0bffd0b 	ldhu	r2,-12(fp)
8113a6b0:	18800d1e 	bne	r3,r2,8113a6e8 <OSFlagAccept+0x164>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113a6b4:	e0bff383 	ldbu	r2,-50(fp)
8113a6b8:	10800058 	cmpnei	r2,r2,1
8113a6bc:	10000d1e 	bne	r2,zero,8113a6f4 <OSFlagAccept+0x170>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
8113a6c0:	e0bffc17 	ldw	r2,-16(fp)
8113a6c4:	1080020b 	ldhu	r2,8(r2)
8113a6c8:	1007883a 	mov	r3,r2
8113a6cc:	e0bff30b 	ldhu	r2,-52(fp)
8113a6d0:	0084303a 	nor	r2,zero,r2
8113a6d4:	1884703a 	and	r2,r3,r2
8113a6d8:	1007883a 	mov	r3,r2
8113a6dc:	e0bffc17 	ldw	r2,-16(fp)
8113a6e0:	10c0020d 	sth	r3,8(r2)
8113a6e4:	00000306 	br	8113a6f4 <OSFlagAccept+0x170>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8113a6e8:	e0bfff17 	ldw	r2,-4(fp)
8113a6ec:	00c01c04 	movi	r3,112
8113a6f0:	10c00005 	stb	r3,0(r2)
8113a6f4:	e0bff417 	ldw	r2,-48(fp)
8113a6f8:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a6fc:	e0bff617 	ldw	r2,-40(fp)
8113a700:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
8113a704:	00005e06 	br	8113a880 <OSFlagAccept+0x2fc>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
8113a708:	e0bffc17 	ldw	r2,-16(fp)
8113a70c:	10c0020b 	ldhu	r3,8(r2)
8113a710:	e0bffd0b 	ldhu	r2,-12(fp)
8113a714:	1884703a 	and	r2,r3,r2
8113a718:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
8113a71c:	e0bff30b 	ldhu	r2,-52(fp)
8113a720:	10000d26 	beq	r2,zero,8113a758 <OSFlagAccept+0x1d4>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113a724:	e0bff383 	ldbu	r2,-50(fp)
8113a728:	10800058 	cmpnei	r2,r2,1
8113a72c:	10000d1e 	bne	r2,zero,8113a764 <OSFlagAccept+0x1e0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
8113a730:	e0bffc17 	ldw	r2,-16(fp)
8113a734:	1080020b 	ldhu	r2,8(r2)
8113a738:	1007883a 	mov	r3,r2
8113a73c:	e0bff30b 	ldhu	r2,-52(fp)
8113a740:	0084303a 	nor	r2,zero,r2
8113a744:	1884703a 	and	r2,r3,r2
8113a748:	1007883a 	mov	r3,r2
8113a74c:	e0bffc17 	ldw	r2,-16(fp)
8113a750:	10c0020d 	sth	r3,8(r2)
8113a754:	00000306 	br	8113a764 <OSFlagAccept+0x1e0>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8113a758:	e0bfff17 	ldw	r2,-4(fp)
8113a75c:	00c01c04 	movi	r3,112
8113a760:	10c00005 	stb	r3,0(r2)
8113a764:	e0bff417 	ldw	r2,-48(fp)
8113a768:	e0bff715 	stw	r2,-36(fp)
8113a76c:	e0bff717 	ldw	r2,-36(fp)
8113a770:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
8113a774:	00004206 	br	8113a880 <OSFlagAccept+0x2fc>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
8113a778:	e0bffc17 	ldw	r2,-16(fp)
8113a77c:	1080020b 	ldhu	r2,8(r2)
8113a780:	0084303a 	nor	r2,zero,r2
8113a784:	1007883a 	mov	r3,r2
8113a788:	e0bffd0b 	ldhu	r2,-12(fp)
8113a78c:	1884703a 	and	r2,r3,r2
8113a790:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
8113a794:	e0fff30b 	ldhu	r3,-52(fp)
8113a798:	e0bffd0b 	ldhu	r2,-12(fp)
8113a79c:	18800b1e 	bne	r3,r2,8113a7cc <OSFlagAccept+0x248>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113a7a0:	e0bff383 	ldbu	r2,-50(fp)
8113a7a4:	10800058 	cmpnei	r2,r2,1
8113a7a8:	10000b1e 	bne	r2,zero,8113a7d8 <OSFlagAccept+0x254>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
8113a7ac:	e0bffc17 	ldw	r2,-16(fp)
8113a7b0:	10c0020b 	ldhu	r3,8(r2)
8113a7b4:	e0bff30b 	ldhu	r2,-52(fp)
8113a7b8:	1884b03a 	or	r2,r3,r2
8113a7bc:	1007883a 	mov	r3,r2
8113a7c0:	e0bffc17 	ldw	r2,-16(fp)
8113a7c4:	10c0020d 	sth	r3,8(r2)
8113a7c8:	00000306 	br	8113a7d8 <OSFlagAccept+0x254>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8113a7cc:	e0bfff17 	ldw	r2,-4(fp)
8113a7d0:	00c01c04 	movi	r3,112
8113a7d4:	10c00005 	stb	r3,0(r2)
8113a7d8:	e0bff417 	ldw	r2,-48(fp)
8113a7dc:	e0bff815 	stw	r2,-32(fp)
8113a7e0:	e0bff817 	ldw	r2,-32(fp)
8113a7e4:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
8113a7e8:	00002506 	br	8113a880 <OSFlagAccept+0x2fc>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
8113a7ec:	e0bffc17 	ldw	r2,-16(fp)
8113a7f0:	1080020b 	ldhu	r2,8(r2)
8113a7f4:	0084303a 	nor	r2,zero,r2
8113a7f8:	1007883a 	mov	r3,r2
8113a7fc:	e0bffd0b 	ldhu	r2,-12(fp)
8113a800:	1884703a 	and	r2,r3,r2
8113a804:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
8113a808:	e0bff30b 	ldhu	r2,-52(fp)
8113a80c:	10000b26 	beq	r2,zero,8113a83c <OSFlagAccept+0x2b8>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113a810:	e0bff383 	ldbu	r2,-50(fp)
8113a814:	10800058 	cmpnei	r2,r2,1
8113a818:	10000b1e 	bne	r2,zero,8113a848 <OSFlagAccept+0x2c4>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
8113a81c:	e0bffc17 	ldw	r2,-16(fp)
8113a820:	10c0020b 	ldhu	r3,8(r2)
8113a824:	e0bff30b 	ldhu	r2,-52(fp)
8113a828:	1884b03a 	or	r2,r3,r2
8113a82c:	1007883a 	mov	r3,r2
8113a830:	e0bffc17 	ldw	r2,-16(fp)
8113a834:	10c0020d 	sth	r3,8(r2)
8113a838:	00000306 	br	8113a848 <OSFlagAccept+0x2c4>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8113a83c:	e0bfff17 	ldw	r2,-4(fp)
8113a840:	00c01c04 	movi	r3,112
8113a844:	10c00005 	stb	r3,0(r2)
8113a848:	e0bff417 	ldw	r2,-48(fp)
8113a84c:	e0bff915 	stw	r2,-28(fp)
8113a850:	e0bff917 	ldw	r2,-28(fp)
8113a854:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
8113a858:	00000906 	br	8113a880 <OSFlagAccept+0x2fc>
8113a85c:	e0bff417 	ldw	r2,-48(fp)
8113a860:	e0bffa15 	stw	r2,-24(fp)
8113a864:	e0bffa17 	ldw	r2,-24(fp)
8113a868:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
8113a86c:	e03ff30d 	sth	zero,-52(fp)
             *perr     = OS_ERR_FLAG_WAIT_TYPE;
8113a870:	e0bfff17 	ldw	r2,-4(fp)
8113a874:	00c01bc4 	movi	r3,111
8113a878:	10c00005 	stb	r3,0(r2)
             break;
8113a87c:	0001883a 	nop
    }
    return (flags_rdy);
8113a880:	e0bff30b 	ldhu	r2,-52(fp)
}
8113a884:	e037883a 	mov	sp,fp
8113a888:	df000017 	ldw	fp,0(sp)
8113a88c:	dec00104 	addi	sp,sp,4
8113a890:	f800283a 	ret

8113a894 <OSFlagCreate>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *perr)
{
8113a894:	defff804 	addi	sp,sp,-32
8113a898:	de00012e 	bgeu	sp,et,8113a8a0 <OSFlagCreate+0xc>
8113a89c:	003b68fa 	trap	3
8113a8a0:	df000715 	stw	fp,28(sp)
8113a8a4:	df000704 	addi	fp,sp,28
8113a8a8:	2005883a 	mov	r2,r4
8113a8ac:	e17fff15 	stw	r5,-4(fp)
8113a8b0:	e0bffe0d 	sth	r2,-8(fp)
    OS_FLAG_GRP *pgrp;
#if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
    OS_CPU_SR    cpu_sr = 0;
8113a8b4:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
8113a8b8:	e0bfff17 	ldw	r2,-4(fp)
8113a8bc:	1000021e 	bne	r2,zero,8113a8c8 <OSFlagCreate+0x34>
        return ((OS_FLAG_GRP *)0);
8113a8c0:	0005883a 	mov	r2,zero
8113a8c4:	00003306 	br	8113a994 <OSFlagCreate+0x100>
    }
#endif
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
8113a8c8:	d0a0a103 	ldbu	r2,-32124(gp)
8113a8cc:	10803fcc 	andi	r2,r2,255
8113a8d0:	10000526 	beq	r2,zero,8113a8e8 <OSFlagCreate+0x54>
        *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
8113a8d4:	e0bfff17 	ldw	r2,-4(fp)
8113a8d8:	00c00404 	movi	r3,16
8113a8dc:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAG_GRP *)0);
8113a8e0:	0005883a 	mov	r2,zero
8113a8e4:	00002b06 	br	8113a994 <OSFlagCreate+0x100>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a8e8:	0005303a 	rdctl	r2,status
8113a8ec:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a8f0:	e0fffd17 	ldw	r3,-12(fp)
8113a8f4:	00bfff84 	movi	r2,-2
8113a8f8:	1884703a 	and	r2,r3,r2
8113a8fc:	1001703a 	wrctl	status,r2
  
  return context;
8113a900:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113a904:	e0bff915 	stw	r2,-28(fp)
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
8113a908:	d0a0a617 	ldw	r2,-32104(gp)
8113a90c:	e0bffb15 	stw	r2,-20(fp)
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
8113a910:	e0bffb17 	ldw	r2,-20(fp)
8113a914:	10001726 	beq	r2,zero,8113a974 <OSFlagCreate+0xe0>
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
8113a918:	d0a0a617 	ldw	r2,-32104(gp)
8113a91c:	10800117 	ldw	r2,4(r2)
8113a920:	d0a0a615 	stw	r2,-32104(gp)
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
8113a924:	e0bffb17 	ldw	r2,-20(fp)
8113a928:	00c00144 	movi	r3,5
8113a92c:	10c00005 	stb	r3,0(r2)
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
8113a930:	e0bffb17 	ldw	r2,-20(fp)
8113a934:	e0fffe0b 	ldhu	r3,-8(fp)
8113a938:	10c0020d 	sth	r3,8(r2)
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
8113a93c:	e0bffb17 	ldw	r2,-20(fp)
8113a940:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
8113a944:	e0bffb17 	ldw	r2,-20(fp)
8113a948:	00c00fc4 	movi	r3,63
8113a94c:	10c00285 	stb	r3,10(r2)
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
8113a950:	e0bffb17 	ldw	r2,-20(fp)
8113a954:	100002c5 	stb	zero,11(r2)
8113a958:	e0bff917 	ldw	r2,-28(fp)
8113a95c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a960:	e0bffa17 	ldw	r2,-24(fp)
8113a964:	1001703a 	wrctl	status,r2
#endif
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_NONE;
8113a968:	e0bfff17 	ldw	r2,-4(fp)
8113a96c:	10000005 	stb	zero,0(r2)
8113a970:	00000706 	br	8113a990 <OSFlagCreate+0xfc>
8113a974:	e0bff917 	ldw	r2,-28(fp)
8113a978:	e0bffc15 	stw	r2,-16(fp)
8113a97c:	e0bffc17 	ldw	r2,-16(fp)
8113a980:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_FLAG_GRP_DEPLETED;
8113a984:	e0bfff17 	ldw	r2,-4(fp)
8113a988:	00c01c84 	movi	r3,114
8113a98c:	10c00005 	stb	r3,0(r2)
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
8113a990:	e0bffb17 	ldw	r2,-20(fp)
}
8113a994:	e037883a 	mov	sp,fp
8113a998:	df000017 	ldw	fp,0(sp)
8113a99c:	dec00104 	addi	sp,sp,4
8113a9a0:	f800283a 	ret

8113a9a4 <OSFlagDel>:
*********************************************************************************************************
*/

#if OS_FLAG_DEL_EN > 0
OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *perr)
{
8113a9a4:	defff204 	addi	sp,sp,-56
8113a9a8:	de00012e 	bgeu	sp,et,8113a9b0 <OSFlagDel+0xc>
8113a9ac:	003b68fa 	trap	3
8113a9b0:	dfc00d15 	stw	ra,52(sp)
8113a9b4:	df000c15 	stw	fp,48(sp)
8113a9b8:	df000c04 	addi	fp,sp,48
8113a9bc:	e13ffd15 	stw	r4,-12(fp)
8113a9c0:	2805883a 	mov	r2,r5
8113a9c4:	e1bfff15 	stw	r6,-4(fp)
8113a9c8:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       tasks_waiting;
    OS_FLAG_NODE *pnode;
    OS_FLAG_GRP  *pgrp_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8113a9cc:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113a9d0:	e0bfff17 	ldw	r2,-4(fp)
8113a9d4:	1000021e 	bne	r2,zero,8113a9e0 <OSFlagDel+0x3c>
        return (pgrp);
8113a9d8:	e0bffd17 	ldw	r2,-12(fp)
8113a9dc:	00008006 	br	8113abe0 <OSFlagDel+0x23c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
8113a9e0:	e0bffd17 	ldw	r2,-12(fp)
8113a9e4:	1000051e 	bne	r2,zero,8113a9fc <OSFlagDel+0x58>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113a9e8:	e0bfff17 	ldw	r2,-4(fp)
8113a9ec:	00c01b84 	movi	r3,110
8113a9f0:	10c00005 	stb	r3,0(r2)
        return (pgrp);
8113a9f4:	e0bffd17 	ldw	r2,-12(fp)
8113a9f8:	00007906 	br	8113abe0 <OSFlagDel+0x23c>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113a9fc:	d0a0a103 	ldbu	r2,-32124(gp)
8113aa00:	10803fcc 	andi	r2,r2,255
8113aa04:	10000526 	beq	r2,zero,8113aa1c <OSFlagDel+0x78>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
8113aa08:	e0bfff17 	ldw	r2,-4(fp)
8113aa0c:	00c003c4 	movi	r3,15
8113aa10:	10c00005 	stb	r3,0(r2)
        return (pgrp);
8113aa14:	e0bffd17 	ldw	r2,-12(fp)
8113aa18:	00007106 	br	8113abe0 <OSFlagDel+0x23c>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
8113aa1c:	e0bffd17 	ldw	r2,-12(fp)
8113aa20:	10800003 	ldbu	r2,0(r2)
8113aa24:	10803fcc 	andi	r2,r2,255
8113aa28:	10800160 	cmpeqi	r2,r2,5
8113aa2c:	1000051e 	bne	r2,zero,8113aa44 <OSFlagDel+0xa0>
        *perr = OS_ERR_EVENT_TYPE;
8113aa30:	e0bfff17 	ldw	r2,-4(fp)
8113aa34:	00c00044 	movi	r3,1
8113aa38:	10c00005 	stb	r3,0(r2)
        return (pgrp);
8113aa3c:	e0bffd17 	ldw	r2,-12(fp)
8113aa40:	00006706 	br	8113abe0 <OSFlagDel+0x23c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113aa44:	0005303a 	rdctl	r2,status
8113aa48:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113aa4c:	e0fffc17 	ldw	r3,-16(fp)
8113aa50:	00bfff84 	movi	r2,-2
8113aa54:	1884703a 	and	r2,r3,r2
8113aa58:	1001703a 	wrctl	status,r2
  
  return context;
8113aa5c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113aa60:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
8113aa64:	e0bffd17 	ldw	r2,-12(fp)
8113aa68:	10800117 	ldw	r2,4(r2)
8113aa6c:	10000326 	beq	r2,zero,8113aa7c <OSFlagDel+0xd8>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8113aa70:	00800044 	movi	r2,1
8113aa74:	e0bff405 	stb	r2,-48(fp)
8113aa78:	00000106 	br	8113aa80 <OSFlagDel+0xdc>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8113aa7c:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
8113aa80:	e0bffe03 	ldbu	r2,-8(fp)
8113aa84:	10000326 	beq	r2,zero,8113aa94 <OSFlagDel+0xf0>
8113aa88:	10800060 	cmpeqi	r2,r2,1
8113aa8c:	1000231e 	bne	r2,zero,8113ab1c <OSFlagDel+0x178>
8113aa90:	00004806 	br	8113abb4 <OSFlagDel+0x210>
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == OS_FALSE) {
8113aa94:	e0bff403 	ldbu	r2,-48(fp)
8113aa98:	1000161e 	bne	r2,zero,8113aaf4 <OSFlagDel+0x150>
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
8113aa9c:	e0bffd17 	ldw	r2,-12(fp)
8113aaa0:	00c00fc4 	movi	r3,63
8113aaa4:	10c00285 	stb	r3,10(r2)
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
8113aaa8:	e0bffd17 	ldw	r2,-12(fp)
8113aaac:	100002c5 	stb	zero,11(r2)
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
8113aab0:	e0bffd17 	ldw	r2,-12(fp)
8113aab4:	10000005 	stb	zero,0(r2)
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
8113aab8:	d0e0a617 	ldw	r3,-32104(gp)
8113aabc:	e0bffd17 	ldw	r2,-12(fp)
8113aac0:	10c00115 	stw	r3,4(r2)
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
8113aac4:	e0bffd17 	ldw	r2,-12(fp)
8113aac8:	1000020d 	sth	zero,8(r2)
                 OSFlagFreeList       = pgrp;
8113aacc:	e0bffd17 	ldw	r2,-12(fp)
8113aad0:	d0a0a615 	stw	r2,-32104(gp)
8113aad4:	e0bff717 	ldw	r2,-36(fp)
8113aad8:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113aadc:	e0bff817 	ldw	r2,-32(fp)
8113aae0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
8113aae4:	e0bfff17 	ldw	r2,-4(fp)
8113aae8:	10000005 	stb	zero,0(r2)
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
8113aaec:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
                 pgrp_return          = pgrp;
             }
             break;
8113aaf0:	00003a06 	br	8113abdc <OSFlagDel+0x238>
8113aaf4:	e0bff717 	ldw	r2,-36(fp)
8113aaf8:	e0bff915 	stw	r2,-28(fp)
8113aafc:	e0bff917 	ldw	r2,-28(fp)
8113ab00:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
8113ab04:	e0bfff17 	ldw	r2,-4(fp)
8113ab08:	00c01244 	movi	r3,73
8113ab0c:	10c00005 	stb	r3,0(r2)
                 pgrp_return          = pgrp;
8113ab10:	e0bffd17 	ldw	r2,-12(fp)
8113ab14:	e0bff615 	stw	r2,-40(fp)
             }
             break;
8113ab18:	00003006 	br	8113abdc <OSFlagDel+0x238>

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
8113ab1c:	e0bffd17 	ldw	r2,-12(fp)
8113ab20:	10800117 	ldw	r2,4(r2)
8113ab24:	e0bff515 	stw	r2,-44(fp)
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
8113ab28:	00000606 	br	8113ab44 <OSFlagDel+0x1a0>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
8113ab2c:	000b883a 	mov	r5,zero
8113ab30:	e13ff517 	ldw	r4,-44(fp)
8113ab34:	113bb580 	call	8113bb58 <OS_FlagTaskRdy>
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
8113ab38:	e0bff517 	ldw	r2,-44(fp)
8113ab3c:	10800017 	ldw	r2,0(r2)
8113ab40:	e0bff515 	stw	r2,-44(fp)
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
8113ab44:	e0bff517 	ldw	r2,-44(fp)
8113ab48:	103ff81e 	bne	r2,zero,8113ab2c <__reset+0xfb11ab2c>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
8113ab4c:	e0bffd17 	ldw	r2,-12(fp)
8113ab50:	00c00fc4 	movi	r3,63
8113ab54:	10c00285 	stb	r3,10(r2)
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
8113ab58:	e0bffd17 	ldw	r2,-12(fp)
8113ab5c:	100002c5 	stb	zero,11(r2)
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
8113ab60:	e0bffd17 	ldw	r2,-12(fp)
8113ab64:	10000005 	stb	zero,0(r2)
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
8113ab68:	d0e0a617 	ldw	r3,-32104(gp)
8113ab6c:	e0bffd17 	ldw	r2,-12(fp)
8113ab70:	10c00115 	stw	r3,4(r2)
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
8113ab74:	e0bffd17 	ldw	r2,-12(fp)
8113ab78:	1000020d 	sth	zero,8(r2)
             OSFlagFreeList       = pgrp;
8113ab7c:	e0bffd17 	ldw	r2,-12(fp)
8113ab80:	d0a0a615 	stw	r2,-32104(gp)
8113ab84:	e0bff717 	ldw	r2,-36(fp)
8113ab88:	e0bffa15 	stw	r2,-24(fp)
8113ab8c:	e0bffa17 	ldw	r2,-24(fp)
8113ab90:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8113ab94:	e0bff403 	ldbu	r2,-48(fp)
8113ab98:	10800058 	cmpnei	r2,r2,1
8113ab9c:	1000011e 	bne	r2,zero,8113aba4 <OSFlagDel+0x200>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8113aba0:	1139c680 	call	81139c68 <OS_Sched>
             }
             *perr = OS_ERR_NONE;
8113aba4:	e0bfff17 	ldw	r2,-4(fp)
8113aba8:	10000005 	stb	zero,0(r2)
             pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
8113abac:	e03ff615 	stw	zero,-40(fp)
             break;
8113abb0:	00000a06 	br	8113abdc <OSFlagDel+0x238>
8113abb4:	e0bff717 	ldw	r2,-36(fp)
8113abb8:	e0bffb15 	stw	r2,-20(fp)
8113abbc:	e0bffb17 	ldw	r2,-20(fp)
8113abc0:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                = OS_ERR_INVALID_OPT;
8113abc4:	e0bfff17 	ldw	r2,-4(fp)
8113abc8:	00c001c4 	movi	r3,7
8113abcc:	10c00005 	stb	r3,0(r2)
             pgrp_return          = pgrp;
8113abd0:	e0bffd17 	ldw	r2,-12(fp)
8113abd4:	e0bff615 	stw	r2,-40(fp)
             break;
8113abd8:	0001883a 	nop
    }
    return (pgrp_return);
8113abdc:	e0bff617 	ldw	r2,-40(fp)
}
8113abe0:	e037883a 	mov	sp,fp
8113abe4:	dfc00117 	ldw	ra,4(sp)
8113abe8:	df000017 	ldw	fp,0(sp)
8113abec:	dec00204 	addi	sp,sp,8
8113abf0:	f800283a 	ret

8113abf4 <OSFlagNameGet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
8113abf4:	defff604 	addi	sp,sp,-40
8113abf8:	de00012e 	bgeu	sp,et,8113ac00 <OSFlagNameGet+0xc>
8113abfc:	003b68fa 	trap	3
8113ac00:	dfc00915 	stw	ra,36(sp)
8113ac04:	df000815 	stw	fp,32(sp)
8113ac08:	df000804 	addi	fp,sp,32
8113ac0c:	e13ffd15 	stw	r4,-12(fp)
8113ac10:	e17ffe15 	stw	r5,-8(fp)
8113ac14:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113ac18:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113ac1c:	e0bfff17 	ldw	r2,-4(fp)
8113ac20:	1000021e 	bne	r2,zero,8113ac2c <OSFlagNameGet+0x38>
        return (0);
8113ac24:	0005883a 	mov	r2,zero
8113ac28:	00003906 	br	8113ad10 <OSFlagNameGet+0x11c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
8113ac2c:	e0bffd17 	ldw	r2,-12(fp)
8113ac30:	1000051e 	bne	r2,zero,8113ac48 <OSFlagNameGet+0x54>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113ac34:	e0bfff17 	ldw	r2,-4(fp)
8113ac38:	00c01b84 	movi	r3,110
8113ac3c:	10c00005 	stb	r3,0(r2)
        return (0);
8113ac40:	0005883a 	mov	r2,zero
8113ac44:	00003206 	br	8113ad10 <OSFlagNameGet+0x11c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8113ac48:	e0bffe17 	ldw	r2,-8(fp)
8113ac4c:	1000051e 	bne	r2,zero,8113ac64 <OSFlagNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
8113ac50:	e0bfff17 	ldw	r2,-4(fp)
8113ac54:	00c00304 	movi	r3,12
8113ac58:	10c00005 	stb	r3,0(r2)
        return (0);
8113ac5c:	0005883a 	mov	r2,zero
8113ac60:	00002b06 	br	8113ad10 <OSFlagNameGet+0x11c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113ac64:	d0a0a103 	ldbu	r2,-32124(gp)
8113ac68:	10803fcc 	andi	r2,r2,255
8113ac6c:	10000526 	beq	r2,zero,8113ac84 <OSFlagNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
8113ac70:	e0bfff17 	ldw	r2,-4(fp)
8113ac74:	00c00444 	movi	r3,17
8113ac78:	10c00005 	stb	r3,0(r2)
        return (0);
8113ac7c:	0005883a 	mov	r2,zero
8113ac80:	00002306 	br	8113ad10 <OSFlagNameGet+0x11c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ac84:	0005303a 	rdctl	r2,status
8113ac88:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ac8c:	e0fffc17 	ldw	r3,-16(fp)
8113ac90:	00bfff84 	movi	r2,-2
8113ac94:	1884703a 	and	r2,r3,r2
8113ac98:	1001703a 	wrctl	status,r2
  
  return context;
8113ac9c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113aca0:	e0bff815 	stw	r2,-32(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
8113aca4:	e0bffd17 	ldw	r2,-12(fp)
8113aca8:	10800003 	ldbu	r2,0(r2)
8113acac:	10803fcc 	andi	r2,r2,255
8113acb0:	10800160 	cmpeqi	r2,r2,5
8113acb4:	1000091e 	bne	r2,zero,8113acdc <OSFlagNameGet+0xe8>
8113acb8:	e0bff817 	ldw	r2,-32(fp)
8113acbc:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113acc0:	e0bff917 	ldw	r2,-28(fp)
8113acc4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
8113acc8:	e0bfff17 	ldw	r2,-4(fp)
8113accc:	00c00044 	movi	r3,1
8113acd0:	10c00005 	stb	r3,0(r2)
        return (0);
8113acd4:	0005883a 	mov	r2,zero
8113acd8:	00000d06 	br	8113ad10 <OSFlagNameGet+0x11c>
    }
    len   = OS_StrCopy(pname, pgrp->OSFlagName); /* Copy name from OS_FLAG_GRP                         */
8113acdc:	e0bffd17 	ldw	r2,-12(fp)
8113ace0:	10800284 	addi	r2,r2,10
8113ace4:	100b883a 	mov	r5,r2
8113ace8:	e13ffe17 	ldw	r4,-8(fp)
8113acec:	1139dbc0 	call	81139dbc <OS_StrCopy>
8113acf0:	e0bffb05 	stb	r2,-20(fp)
8113acf4:	e0bff817 	ldw	r2,-32(fp)
8113acf8:	e0bffa15 	stw	r2,-24(fp)
8113acfc:	e0bffa17 	ldw	r2,-24(fp)
8113ad00:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113ad04:	e0bfff17 	ldw	r2,-4(fp)
8113ad08:	10000005 	stb	zero,0(r2)
    return (len);
8113ad0c:	e0bffb03 	ldbu	r2,-20(fp)
}
8113ad10:	e037883a 	mov	sp,fp
8113ad14:	dfc00117 	ldw	ra,4(sp)
8113ad18:	df000017 	ldw	fp,0(sp)
8113ad1c:	dec00204 	addi	sp,sp,8
8113ad20:	f800283a 	ret

8113ad24 <OSFlagNameSet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
void  OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
8113ad24:	defff504 	addi	sp,sp,-44
8113ad28:	de00012e 	bgeu	sp,et,8113ad30 <OSFlagNameSet+0xc>
8113ad2c:	003b68fa 	trap	3
8113ad30:	dfc00a15 	stw	ra,40(sp)
8113ad34:	df000915 	stw	fp,36(sp)
8113ad38:	df000904 	addi	fp,sp,36
8113ad3c:	e13ffd15 	stw	r4,-12(fp)
8113ad40:	e17ffe15 	stw	r5,-8(fp)
8113ad44:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113ad48:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113ad4c:	e0bfff17 	ldw	r2,-4(fp)
8113ad50:	10004326 	beq	r2,zero,8113ae60 <OSFlagNameSet+0x13c>
        return;
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
8113ad54:	e0bffd17 	ldw	r2,-12(fp)
8113ad58:	1000041e 	bne	r2,zero,8113ad6c <OSFlagNameSet+0x48>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113ad5c:	e0bfff17 	ldw	r2,-4(fp)
8113ad60:	00c01b84 	movi	r3,110
8113ad64:	10c00005 	stb	r3,0(r2)
        return;
8113ad68:	00003e06 	br	8113ae64 <OSFlagNameSet+0x140>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8113ad6c:	e0bffe17 	ldw	r2,-8(fp)
8113ad70:	1000041e 	bne	r2,zero,8113ad84 <OSFlagNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
8113ad74:	e0bfff17 	ldw	r2,-4(fp)
8113ad78:	00c00304 	movi	r3,12
8113ad7c:	10c00005 	stb	r3,0(r2)
        return;
8113ad80:	00003806 	br	8113ae64 <OSFlagNameSet+0x140>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113ad84:	d0a0a103 	ldbu	r2,-32124(gp)
8113ad88:	10803fcc 	andi	r2,r2,255
8113ad8c:	10000426 	beq	r2,zero,8113ada0 <OSFlagNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
8113ad90:	e0bfff17 	ldw	r2,-4(fp)
8113ad94:	00c00484 	movi	r3,18
8113ad98:	10c00005 	stb	r3,0(r2)
        return;
8113ad9c:	00003106 	br	8113ae64 <OSFlagNameSet+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ada0:	0005303a 	rdctl	r2,status
8113ada4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ada8:	e0fffc17 	ldw	r3,-16(fp)
8113adac:	00bfff84 	movi	r2,-2
8113adb0:	1884703a 	and	r2,r3,r2
8113adb4:	1001703a 	wrctl	status,r2
  
  return context;
8113adb8:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113adbc:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
8113adc0:	e0bffd17 	ldw	r2,-12(fp)
8113adc4:	10800003 	ldbu	r2,0(r2)
8113adc8:	10803fcc 	andi	r2,r2,255
8113adcc:	10800160 	cmpeqi	r2,r2,5
8113add0:	1000081e 	bne	r2,zero,8113adf4 <OSFlagNameSet+0xd0>
8113add4:	e0bff717 	ldw	r2,-36(fp)
8113add8:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113addc:	e0bff817 	ldw	r2,-32(fp)
8113ade0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
8113ade4:	e0bfff17 	ldw	r2,-4(fp)
8113ade8:	00c00044 	movi	r3,1
8113adec:	10c00005 	stb	r3,0(r2)
        return;
8113adf0:	00001c06 	br	8113ae64 <OSFlagNameSet+0x140>
    }
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
8113adf4:	e13ffe17 	ldw	r4,-8(fp)
8113adf8:	1139e380 	call	81139e38 <OS_StrLen>
8113adfc:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
8113ae00:	e0bffa03 	ldbu	r2,-24(fp)
8113ae04:	10800830 	cmpltui	r2,r2,32
8113ae08:	1000081e 	bne	r2,zero,8113ae2c <OSFlagNameSet+0x108>
8113ae0c:	e0bff717 	ldw	r2,-36(fp)
8113ae10:	e0bff915 	stw	r2,-28(fp)
8113ae14:	e0bff917 	ldw	r2,-28(fp)
8113ae18:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_FLAG_NAME_TOO_LONG;
8113ae1c:	e0bfff17 	ldw	r2,-4(fp)
8113ae20:	00c01cc4 	movi	r3,115
8113ae24:	10c00005 	stb	r3,0(r2)
        return;
8113ae28:	00000e06 	br	8113ae64 <OSFlagNameSet+0x140>
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
8113ae2c:	e0bffd17 	ldw	r2,-12(fp)
8113ae30:	10800284 	addi	r2,r2,10
8113ae34:	e17ffe17 	ldw	r5,-8(fp)
8113ae38:	1009883a 	mov	r4,r2
8113ae3c:	1139dbc0 	call	81139dbc <OS_StrCopy>
8113ae40:	e0bff717 	ldw	r2,-36(fp)
8113ae44:	e0bffb15 	stw	r2,-20(fp)
8113ae48:	e0bffb17 	ldw	r2,-20(fp)
8113ae4c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113ae50:	e0bfff17 	ldw	r2,-4(fp)
8113ae54:	10000005 	stb	zero,0(r2)
    return;
8113ae58:	0001883a 	nop
8113ae5c:	00000106 	br	8113ae64 <OSFlagNameSet+0x140>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
8113ae60:	0001883a 	nop
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return;
}
8113ae64:	e037883a 	mov	sp,fp
8113ae68:	dfc00117 	ldw	ra,4(sp)
8113ae6c:	df000017 	ldw	fp,0(sp)
8113ae70:	dec00204 	addi	sp,sp,8
8113ae74:	f800283a 	ret

8113ae78 <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *perr)
{
8113ae78:	deffe104 	addi	sp,sp,-124
8113ae7c:	de00012e 	bgeu	sp,et,8113ae84 <OSFlagPend+0xc>
8113ae80:	003b68fa 	trap	3
8113ae84:	dfc01e15 	stw	ra,120(sp)
8113ae88:	df001d15 	stw	fp,116(sp)
8113ae8c:	df001d04 	addi	fp,sp,116
8113ae90:	e13ffc15 	stw	r4,-16(fp)
8113ae94:	2809883a 	mov	r4,r5
8113ae98:	3007883a 	mov	r3,r6
8113ae9c:	3805883a 	mov	r2,r7
8113aea0:	e13ffd0d 	sth	r4,-12(fp)
8113aea4:	e0fffe05 	stb	r3,-8(fp)
8113aea8:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    INT8U         pend_stat;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8113aeac:	e03fe515 	stw	zero,-108(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113aeb0:	e0800217 	ldw	r2,8(fp)
8113aeb4:	1000021e 	bne	r2,zero,8113aec0 <OSFlagPend+0x48>
        return ((OS_FLAGS)0);
8113aeb8:	0005883a 	mov	r2,zero
8113aebc:	00015906 	br	8113b424 <OSFlagPend+0x5ac>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
8113aec0:	e0bffc17 	ldw	r2,-16(fp)
8113aec4:	1000051e 	bne	r2,zero,8113aedc <OSFlagPend+0x64>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113aec8:	e0800217 	ldw	r2,8(fp)
8113aecc:	00c01b84 	movi	r3,110
8113aed0:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113aed4:	0005883a 	mov	r2,zero
8113aed8:	00015206 	br	8113b424 <OSFlagPend+0x5ac>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113aedc:	d0a0a103 	ldbu	r2,-32124(gp)
8113aee0:	10803fcc 	andi	r2,r2,255
8113aee4:	10000526 	beq	r2,zero,8113aefc <OSFlagPend+0x84>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
8113aee8:	e0800217 	ldw	r2,8(fp)
8113aeec:	00c00084 	movi	r3,2
8113aef0:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113aef4:	0005883a 	mov	r2,zero
8113aef8:	00014a06 	br	8113b424 <OSFlagPend+0x5ac>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
8113aefc:	d0a08f03 	ldbu	r2,-32196(gp)
8113af00:	10803fcc 	andi	r2,r2,255
8113af04:	10000526 	beq	r2,zero,8113af1c <OSFlagPend+0xa4>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
8113af08:	e0800217 	ldw	r2,8(fp)
8113af0c:	00c00344 	movi	r3,13
8113af10:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113af14:	0005883a 	mov	r2,zero
8113af18:	00014206 	br	8113b424 <OSFlagPend+0x5ac>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
8113af1c:	e0bffc17 	ldw	r2,-16(fp)
8113af20:	10800003 	ldbu	r2,0(r2)
8113af24:	10803fcc 	andi	r2,r2,255
8113af28:	10800160 	cmpeqi	r2,r2,5
8113af2c:	1000051e 	bne	r2,zero,8113af44 <OSFlagPend+0xcc>
        *perr = OS_ERR_EVENT_TYPE;
8113af30:	e0800217 	ldw	r2,8(fp)
8113af34:	00c00044 	movi	r3,1
8113af38:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113af3c:	0005883a 	mov	r2,zero
8113af40:	00013806 	br	8113b424 <OSFlagPend+0x5ac>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
8113af44:	e0fffe03 	ldbu	r3,-8(fp)
8113af48:	00bfe004 	movi	r2,-128
8113af4c:	1884703a 	and	r2,r3,r2
8113af50:	e0bfe605 	stb	r2,-104(fp)
    if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
8113af54:	e0bfe603 	ldbu	r2,-104(fp)
8113af58:	10000626 	beq	r2,zero,8113af74 <OSFlagPend+0xfc>
        wait_type &= ~(INT8U)OS_FLAG_CONSUME;
8113af5c:	e0bffe03 	ldbu	r2,-8(fp)
8113af60:	10801fcc 	andi	r2,r2,127
8113af64:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
8113af68:	00800044 	movi	r2,1
8113af6c:	e0bfe405 	stb	r2,-112(fp)
8113af70:	00000106 	br	8113af78 <OSFlagPend+0x100>
    } else {
        consume    = OS_FALSE;
8113af74:	e03fe405 	stb	zero,-112(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113af78:	0005303a 	rdctl	r2,status
8113af7c:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113af80:	e0fff617 	ldw	r3,-40(fp)
8113af84:	00bfff84 	movi	r2,-2
8113af88:	1884703a 	and	r2,r3,r2
8113af8c:	1001703a 	wrctl	status,r2
  
  return context;
8113af90:	e0bff617 	ldw	r2,-40(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
8113af94:	e0bfe515 	stw	r2,-108(fp)
    switch (wait_type) {
8113af98:	e0bffe03 	ldbu	r2,-8(fp)
8113af9c:	10c00060 	cmpeqi	r3,r2,1
8113afa0:	1800921e 	bne	r3,zero,8113b1ec <OSFlagPend+0x374>
8113afa4:	10c00088 	cmpgei	r3,r2,2
8113afa8:	1800021e 	bne	r3,zero,8113afb4 <OSFlagPend+0x13c>
8113afac:	10006126 	beq	r2,zero,8113b134 <OSFlagPend+0x2bc>
8113afb0:	0000bb06 	br	8113b2a0 <OSFlagPend+0x428>
8113afb4:	10c000a0 	cmpeqi	r3,r2,2
8113afb8:	1800031e 	bne	r3,zero,8113afc8 <OSFlagPend+0x150>
8113afbc:	108000e0 	cmpeqi	r2,r2,3
8113afc0:	10002f1e 	bne	r2,zero,8113b080 <OSFlagPend+0x208>
8113afc4:	0000b606 	br	8113b2a0 <OSFlagPend+0x428>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
8113afc8:	e0bffc17 	ldw	r2,-16(fp)
8113afcc:	10c0020b 	ldhu	r3,8(r2)
8113afd0:	e0bffd0b 	ldhu	r2,-12(fp)
8113afd4:	1884703a 	and	r2,r3,r2
8113afd8:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
8113afdc:	e0ffe80b 	ldhu	r3,-96(fp)
8113afe0:	e0bffd0b 	ldhu	r2,-12(fp)
8113afe4:	1880171e 	bne	r3,r2,8113b044 <OSFlagPend+0x1cc>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113afe8:	e0bfe403 	ldbu	r2,-112(fp)
8113afec:	10800058 	cmpnei	r2,r2,1
8113aff0:	1000091e 	bne	r2,zero,8113b018 <OSFlagPend+0x1a0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
8113aff4:	e0bffc17 	ldw	r2,-16(fp)
8113aff8:	1080020b 	ldhu	r2,8(r2)
8113affc:	1007883a 	mov	r3,r2
8113b000:	e0bfe80b 	ldhu	r2,-96(fp)
8113b004:	0084303a 	nor	r2,zero,r2
8113b008:	1884703a 	and	r2,r3,r2
8113b00c:	1007883a 	mov	r3,r2
8113b010:	e0bffc17 	ldw	r2,-16(fp)
8113b014:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8113b018:	d0a0a217 	ldw	r2,-32120(gp)
8113b01c:	e0ffe80b 	ldhu	r3,-96(fp)
8113b020:	10c00b0d 	sth	r3,44(r2)
8113b024:	e0bfe517 	ldw	r2,-108(fp)
8113b028:	e0bfe715 	stw	r2,-100(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b02c:	e0bfe717 	ldw	r2,-100(fp)
8113b030:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8113b034:	e0800217 	ldw	r2,8(fp)
8113b038:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8113b03c:	e0bfe80b 	ldhu	r2,-96(fp)
8113b040:	0000f806 	br	8113b424 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8113b044:	e13ffd0b 	ldhu	r4,-12(fp)
8113b048:	e17ffe03 	ldbu	r5,-8(fp)
8113b04c:	e0bfff0b 	ldhu	r2,-4(fp)
8113b050:	e0fff704 	addi	r3,fp,-36
8113b054:	d8800015 	stw	r2,0(sp)
8113b058:	280f883a 	mov	r7,r5
8113b05c:	200d883a 	mov	r6,r4
8113b060:	180b883a 	mov	r5,r3
8113b064:	e13ffc17 	ldw	r4,-16(fp)
8113b068:	113b9080 	call	8113b908 <OS_FlagBlock>
8113b06c:	e0bfe517 	ldw	r2,-108(fp)
8113b070:	e0bfe915 	stw	r2,-92(fp)
8113b074:	e0bfe917 	ldw	r2,-92(fp)
8113b078:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8113b07c:	00009206 	br	8113b2c8 <OSFlagPend+0x450>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
8113b080:	e0bffc17 	ldw	r2,-16(fp)
8113b084:	10c0020b 	ldhu	r3,8(r2)
8113b088:	e0bffd0b 	ldhu	r2,-12(fp)
8113b08c:	1884703a 	and	r2,r3,r2
8113b090:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
8113b094:	e0bfe80b 	ldhu	r2,-96(fp)
8113b098:	10001726 	beq	r2,zero,8113b0f8 <OSFlagPend+0x280>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113b09c:	e0bfe403 	ldbu	r2,-112(fp)
8113b0a0:	10800058 	cmpnei	r2,r2,1
8113b0a4:	1000091e 	bne	r2,zero,8113b0cc <OSFlagPend+0x254>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
8113b0a8:	e0bffc17 	ldw	r2,-16(fp)
8113b0ac:	1080020b 	ldhu	r2,8(r2)
8113b0b0:	1007883a 	mov	r3,r2
8113b0b4:	e0bfe80b 	ldhu	r2,-96(fp)
8113b0b8:	0084303a 	nor	r2,zero,r2
8113b0bc:	1884703a 	and	r2,r3,r2
8113b0c0:	1007883a 	mov	r3,r2
8113b0c4:	e0bffc17 	ldw	r2,-16(fp)
8113b0c8:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8113b0cc:	d0a0a217 	ldw	r2,-32120(gp)
8113b0d0:	e0ffe80b 	ldhu	r3,-96(fp)
8113b0d4:	10c00b0d 	sth	r3,44(r2)
8113b0d8:	e0bfe517 	ldw	r2,-108(fp)
8113b0dc:	e0bfea15 	stw	r2,-88(fp)
8113b0e0:	e0bfea17 	ldw	r2,-88(fp)
8113b0e4:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8113b0e8:	e0800217 	ldw	r2,8(fp)
8113b0ec:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8113b0f0:	e0bfe80b 	ldhu	r2,-96(fp)
8113b0f4:	0000cb06 	br	8113b424 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8113b0f8:	e13ffd0b 	ldhu	r4,-12(fp)
8113b0fc:	e17ffe03 	ldbu	r5,-8(fp)
8113b100:	e0bfff0b 	ldhu	r2,-4(fp)
8113b104:	e0fff704 	addi	r3,fp,-36
8113b108:	d8800015 	stw	r2,0(sp)
8113b10c:	280f883a 	mov	r7,r5
8113b110:	200d883a 	mov	r6,r4
8113b114:	180b883a 	mov	r5,r3
8113b118:	e13ffc17 	ldw	r4,-16(fp)
8113b11c:	113b9080 	call	8113b908 <OS_FlagBlock>
8113b120:	e0bfe517 	ldw	r2,-108(fp)
8113b124:	e0bfeb15 	stw	r2,-84(fp)
8113b128:	e0bfeb17 	ldw	r2,-84(fp)
8113b12c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8113b130:	00006506 	br	8113b2c8 <OSFlagPend+0x450>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
8113b134:	e0bffc17 	ldw	r2,-16(fp)
8113b138:	1080020b 	ldhu	r2,8(r2)
8113b13c:	0084303a 	nor	r2,zero,r2
8113b140:	1007883a 	mov	r3,r2
8113b144:	e0bffd0b 	ldhu	r2,-12(fp)
8113b148:	1884703a 	and	r2,r3,r2
8113b14c:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
8113b150:	e0ffe80b 	ldhu	r3,-96(fp)
8113b154:	e0bffd0b 	ldhu	r2,-12(fp)
8113b158:	1880151e 	bne	r3,r2,8113b1b0 <OSFlagPend+0x338>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113b15c:	e0bfe403 	ldbu	r2,-112(fp)
8113b160:	10800058 	cmpnei	r2,r2,1
8113b164:	1000071e 	bne	r2,zero,8113b184 <OSFlagPend+0x30c>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
8113b168:	e0bffc17 	ldw	r2,-16(fp)
8113b16c:	10c0020b 	ldhu	r3,8(r2)
8113b170:	e0bfe80b 	ldhu	r2,-96(fp)
8113b174:	1884b03a 	or	r2,r3,r2
8113b178:	1007883a 	mov	r3,r2
8113b17c:	e0bffc17 	ldw	r2,-16(fp)
8113b180:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8113b184:	d0a0a217 	ldw	r2,-32120(gp)
8113b188:	e0ffe80b 	ldhu	r3,-96(fp)
8113b18c:	10c00b0d 	sth	r3,44(r2)
8113b190:	e0bfe517 	ldw	r2,-108(fp)
8113b194:	e0bfec15 	stw	r2,-80(fp)
8113b198:	e0bfec17 	ldw	r2,-80(fp)
8113b19c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8113b1a0:	e0800217 	ldw	r2,8(fp)
8113b1a4:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8113b1a8:	e0bfe80b 	ldhu	r2,-96(fp)
8113b1ac:	00009d06 	br	8113b424 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8113b1b0:	e13ffd0b 	ldhu	r4,-12(fp)
8113b1b4:	e17ffe03 	ldbu	r5,-8(fp)
8113b1b8:	e0bfff0b 	ldhu	r2,-4(fp)
8113b1bc:	e0fff704 	addi	r3,fp,-36
8113b1c0:	d8800015 	stw	r2,0(sp)
8113b1c4:	280f883a 	mov	r7,r5
8113b1c8:	200d883a 	mov	r6,r4
8113b1cc:	180b883a 	mov	r5,r3
8113b1d0:	e13ffc17 	ldw	r4,-16(fp)
8113b1d4:	113b9080 	call	8113b908 <OS_FlagBlock>
8113b1d8:	e0bfe517 	ldw	r2,-108(fp)
8113b1dc:	e0bfed15 	stw	r2,-76(fp)
8113b1e0:	e0bfed17 	ldw	r2,-76(fp)
8113b1e4:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8113b1e8:	00003706 	br	8113b2c8 <OSFlagPend+0x450>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
8113b1ec:	e0bffc17 	ldw	r2,-16(fp)
8113b1f0:	1080020b 	ldhu	r2,8(r2)
8113b1f4:	0084303a 	nor	r2,zero,r2
8113b1f8:	1007883a 	mov	r3,r2
8113b1fc:	e0bffd0b 	ldhu	r2,-12(fp)
8113b200:	1884703a 	and	r2,r3,r2
8113b204:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
8113b208:	e0bfe80b 	ldhu	r2,-96(fp)
8113b20c:	10001526 	beq	r2,zero,8113b264 <OSFlagPend+0x3ec>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113b210:	e0bfe403 	ldbu	r2,-112(fp)
8113b214:	10800058 	cmpnei	r2,r2,1
8113b218:	1000071e 	bne	r2,zero,8113b238 <OSFlagPend+0x3c0>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
8113b21c:	e0bffc17 	ldw	r2,-16(fp)
8113b220:	10c0020b 	ldhu	r3,8(r2)
8113b224:	e0bfe80b 	ldhu	r2,-96(fp)
8113b228:	1884b03a 	or	r2,r3,r2
8113b22c:	1007883a 	mov	r3,r2
8113b230:	e0bffc17 	ldw	r2,-16(fp)
8113b234:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8113b238:	d0a0a217 	ldw	r2,-32120(gp)
8113b23c:	e0ffe80b 	ldhu	r3,-96(fp)
8113b240:	10c00b0d 	sth	r3,44(r2)
8113b244:	e0bfe517 	ldw	r2,-108(fp)
8113b248:	e0bfee15 	stw	r2,-72(fp)
8113b24c:	e0bfee17 	ldw	r2,-72(fp)
8113b250:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8113b254:	e0800217 	ldw	r2,8(fp)
8113b258:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8113b25c:	e0bfe80b 	ldhu	r2,-96(fp)
8113b260:	00007006 	br	8113b424 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8113b264:	e13ffd0b 	ldhu	r4,-12(fp)
8113b268:	e17ffe03 	ldbu	r5,-8(fp)
8113b26c:	e0bfff0b 	ldhu	r2,-4(fp)
8113b270:	e0fff704 	addi	r3,fp,-36
8113b274:	d8800015 	stw	r2,0(sp)
8113b278:	280f883a 	mov	r7,r5
8113b27c:	200d883a 	mov	r6,r4
8113b280:	180b883a 	mov	r5,r3
8113b284:	e13ffc17 	ldw	r4,-16(fp)
8113b288:	113b9080 	call	8113b908 <OS_FlagBlock>
8113b28c:	e0bfe517 	ldw	r2,-108(fp)
8113b290:	e0bfef15 	stw	r2,-68(fp)
8113b294:	e0bfef17 	ldw	r2,-68(fp)
8113b298:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8113b29c:	00000a06 	br	8113b2c8 <OSFlagPend+0x450>
8113b2a0:	e0bfe517 	ldw	r2,-108(fp)
8113b2a4:	e0bff015 	stw	r2,-64(fp)
8113b2a8:	e0bff017 	ldw	r2,-64(fp)
8113b2ac:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
8113b2b0:	e03fe80d 	sth	zero,-96(fp)
             *perr      = OS_ERR_FLAG_WAIT_TYPE;
8113b2b4:	e0800217 	ldw	r2,8(fp)
8113b2b8:	00c01bc4 	movi	r3,111
8113b2bc:	10c00005 	stb	r3,0(r2)
             return (flags_rdy);
8113b2c0:	e0bfe80b 	ldhu	r2,-96(fp)
8113b2c4:	00005706 	br	8113b424 <OSFlagPend+0x5ac>
    }
/*$PAGE*/
    OS_Sched();                                            /* Find next HPT ready to run               */
8113b2c8:	1139c680 	call	81139c68 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b2cc:	0005303a 	rdctl	r2,status
8113b2d0:	e0bff115 	stw	r2,-60(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b2d4:	e0fff117 	ldw	r3,-60(fp)
8113b2d8:	00bfff84 	movi	r2,-2
8113b2dc:	1884703a 	and	r2,r3,r2
8113b2e0:	1001703a 	wrctl	status,r2
  
  return context;
8113b2e4:	e0bff117 	ldw	r2,-60(fp)
    OS_ENTER_CRITICAL();
8113b2e8:	e0bfe515 	stw	r2,-108(fp)
    if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
8113b2ec:	d0a0a217 	ldw	r2,-32120(gp)
8113b2f0:	10800c43 	ldbu	r2,49(r2)
8113b2f4:	10803fcc 	andi	r2,r2,255
8113b2f8:	10001c26 	beq	r2,zero,8113b36c <OSFlagPend+0x4f4>
        pend_stat                = OSTCBCur->OSTCBStatPend;
8113b2fc:	d0a0a217 	ldw	r2,-32120(gp)
8113b300:	10800c43 	ldbu	r2,49(r2)
8113b304:	e0bff305 	stb	r2,-52(fp)
        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113b308:	d0a0a217 	ldw	r2,-32120(gp)
8113b30c:	10000c45 	stb	zero,49(r2)
        OS_FlagUnlink(&node);
8113b310:	e0bff704 	addi	r2,fp,-36
8113b314:	1009883a 	mov	r4,r2
8113b318:	113bc540 	call	8113bc54 <OS_FlagUnlink>
        OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
8113b31c:	d0a0a217 	ldw	r2,-32120(gp)
8113b320:	10000c05 	stb	zero,48(r2)
8113b324:	e0bfe517 	ldw	r2,-108(fp)
8113b328:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b32c:	e0bff217 	ldw	r2,-56(fp)
8113b330:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        flags_rdy                = (OS_FLAGS)0;
8113b334:	e03fe80d 	sth	zero,-96(fp)
        switch (pend_stat) {
8113b338:	e0bff303 	ldbu	r2,-52(fp)
8113b33c:	108000a0 	cmpeqi	r2,r2,2
8113b340:	10000426 	beq	r2,zero,8113b354 <OSFlagPend+0x4dc>
            case OS_STAT_PEND_ABORT:
                 *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
8113b344:	e0800217 	ldw	r2,8(fp)
8113b348:	00c00384 	movi	r3,14
8113b34c:	10c00005 	stb	r3,0(r2)
                 break;
8113b350:	00000406 	br	8113b364 <OSFlagPend+0x4ec>

            case OS_STAT_PEND_TO:
            default:
                 *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
8113b354:	e0800217 	ldw	r2,8(fp)
8113b358:	00c00284 	movi	r3,10
8113b35c:	10c00005 	stb	r3,0(r2)
                 break;
8113b360:	0001883a 	nop
        }
        return (flags_rdy);
8113b364:	e0bfe80b 	ldhu	r2,-96(fp)
8113b368:	00002e06 	br	8113b424 <OSFlagPend+0x5ac>
    }
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
8113b36c:	d0a0a217 	ldw	r2,-32120(gp)
8113b370:	10800b0b 	ldhu	r2,44(r2)
8113b374:	e0bfe80d 	sth	r2,-96(fp)
    if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
8113b378:	e0bfe403 	ldbu	r2,-112(fp)
8113b37c:	10800058 	cmpnei	r2,r2,1
8113b380:	1000211e 	bne	r2,zero,8113b408 <OSFlagPend+0x590>
        switch (wait_type) {
8113b384:	e0bffe03 	ldbu	r2,-8(fp)
8113b388:	10001616 	blt	r2,zero,8113b3e4 <OSFlagPend+0x56c>
8113b38c:	10c00090 	cmplti	r3,r2,2
8113b390:	18000c1e 	bne	r3,zero,8113b3c4 <OSFlagPend+0x54c>
8113b394:	10800108 	cmpgei	r2,r2,4
8113b398:	1000121e 	bne	r2,zero,8113b3e4 <OSFlagPend+0x56c>
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
8113b39c:	e0bffc17 	ldw	r2,-16(fp)
8113b3a0:	1080020b 	ldhu	r2,8(r2)
8113b3a4:	1007883a 	mov	r3,r2
8113b3a8:	e0bfe80b 	ldhu	r2,-96(fp)
8113b3ac:	0084303a 	nor	r2,zero,r2
8113b3b0:	1884703a 	and	r2,r3,r2
8113b3b4:	1007883a 	mov	r3,r2
8113b3b8:	e0bffc17 	ldw	r2,-16(fp)
8113b3bc:	10c0020d 	sth	r3,8(r2)
                 break;
8113b3c0:	00001106 	br	8113b408 <OSFlagPend+0x590>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
8113b3c4:	e0bffc17 	ldw	r2,-16(fp)
8113b3c8:	10c0020b 	ldhu	r3,8(r2)
8113b3cc:	e0bfe80b 	ldhu	r2,-96(fp)
8113b3d0:	1884b03a 	or	r2,r3,r2
8113b3d4:	1007883a 	mov	r3,r2
8113b3d8:	e0bffc17 	ldw	r2,-16(fp)
8113b3dc:	10c0020d 	sth	r3,8(r2)
                 break;
8113b3e0:	00000906 	br	8113b408 <OSFlagPend+0x590>
8113b3e4:	e0bfe517 	ldw	r2,-108(fp)
8113b3e8:	e0bff415 	stw	r2,-48(fp)
8113b3ec:	e0bff417 	ldw	r2,-48(fp)
8113b3f0:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
8113b3f4:	e0800217 	ldw	r2,8(fp)
8113b3f8:	00c01bc4 	movi	r3,111
8113b3fc:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
8113b400:	0005883a 	mov	r2,zero
8113b404:	00000706 	br	8113b424 <OSFlagPend+0x5ac>
8113b408:	e0bfe517 	ldw	r2,-108(fp)
8113b40c:	e0bff515 	stw	r2,-44(fp)
8113b410:	e0bff517 	ldw	r2,-44(fp)
8113b414:	1001703a 	wrctl	status,r2
        }
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
8113b418:	e0800217 	ldw	r2,8(fp)
8113b41c:	10000005 	stb	zero,0(r2)
    return (flags_rdy);
8113b420:	e0bfe80b 	ldhu	r2,-96(fp)
}
8113b424:	e037883a 	mov	sp,fp
8113b428:	dfc00117 	ldw	ra,4(sp)
8113b42c:	df000017 	ldw	fp,0(sp)
8113b430:	dec00204 	addi	sp,sp,8
8113b434:	f800283a 	ret

8113b438 <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
8113b438:	defffb04 	addi	sp,sp,-20
8113b43c:	de00012e 	bgeu	sp,et,8113b444 <OSFlagPendGetFlagsRdy+0xc>
8113b440:	003b68fa 	trap	3
8113b444:	df000415 	stw	fp,16(sp)
8113b448:	df000404 	addi	fp,sp,16
    OS_FLAGS      flags;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8113b44c:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b450:	0005303a 	rdctl	r2,status
8113b454:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b458:	e0fffe17 	ldw	r3,-8(fp)
8113b45c:	00bfff84 	movi	r2,-2
8113b460:	1884703a 	and	r2,r3,r2
8113b464:	1001703a 	wrctl	status,r2
  
  return context;
8113b468:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
8113b46c:	e0bffc15 	stw	r2,-16(fp)
    flags = OSTCBCur->OSTCBFlagsRdy;
8113b470:	d0a0a217 	ldw	r2,-32120(gp)
8113b474:	10800b0b 	ldhu	r2,44(r2)
8113b478:	e0bffd0d 	sth	r2,-12(fp)
8113b47c:	e0bffc17 	ldw	r2,-16(fp)
8113b480:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b484:	e0bfff17 	ldw	r2,-4(fp)
8113b488:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (flags);
8113b48c:	e0bffd0b 	ldhu	r2,-12(fp)
}
8113b490:	e037883a 	mov	sp,fp
8113b494:	df000017 	ldw	fp,0(sp)
8113b498:	dec00104 	addi	sp,sp,4
8113b49c:	f800283a 	ret

8113b4a0 <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)
{
8113b4a0:	deffef04 	addi	sp,sp,-68
8113b4a4:	de00012e 	bgeu	sp,et,8113b4ac <OSFlagPost+0xc>
8113b4a8:	003b68fa 	trap	3
8113b4ac:	dfc01015 	stw	ra,64(sp)
8113b4b0:	df000f15 	stw	fp,60(sp)
8113b4b4:	df000f04 	addi	fp,sp,60
8113b4b8:	e13ffc15 	stw	r4,-16(fp)
8113b4bc:	2807883a 	mov	r3,r5
8113b4c0:	3005883a 	mov	r2,r6
8113b4c4:	e1ffff15 	stw	r7,-4(fp)
8113b4c8:	e0fffd0d 	sth	r3,-12(fp)
8113b4cc:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       sched;
    OS_FLAGS      flags_cur;
    OS_FLAGS      flags_rdy;
    BOOLEAN       rdy;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR     cpu_sr = 0;
8113b4d0:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
8113b4d4:	e0bfff17 	ldw	r2,-4(fp)
8113b4d8:	1000021e 	bne	r2,zero,8113b4e4 <OSFlagPost+0x44>
        return ((OS_FLAGS)0);
8113b4dc:	0005883a 	mov	r2,zero
8113b4e0:	0000d106 	br	8113b828 <OSFlagPost+0x388>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
8113b4e4:	e0bffc17 	ldw	r2,-16(fp)
8113b4e8:	1000051e 	bne	r2,zero,8113b500 <OSFlagPost+0x60>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113b4ec:	e0bfff17 	ldw	r2,-4(fp)
8113b4f0:	00c01b84 	movi	r3,110
8113b4f4:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113b4f8:	0005883a 	mov	r2,zero
8113b4fc:	0000ca06 	br	8113b828 <OSFlagPost+0x388>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
8113b500:	e0bffc17 	ldw	r2,-16(fp)
8113b504:	10800003 	ldbu	r2,0(r2)
8113b508:	10803fcc 	andi	r2,r2,255
8113b50c:	10800160 	cmpeqi	r2,r2,5
8113b510:	1000051e 	bne	r2,zero,8113b528 <OSFlagPost+0x88>
        *perr = OS_ERR_EVENT_TYPE;
8113b514:	e0bfff17 	ldw	r2,-4(fp)
8113b518:	00c00044 	movi	r3,1
8113b51c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113b520:	0005883a 	mov	r2,zero
8113b524:	0000c006 	br	8113b828 <OSFlagPost+0x388>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b528:	0005303a 	rdctl	r2,status
8113b52c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b530:	e0fffb17 	ldw	r3,-20(fp)
8113b534:	00bfff84 	movi	r2,-2
8113b538:	1884703a 	and	r2,r3,r2
8113b53c:	1001703a 	wrctl	status,r2
  
  return context;
8113b540:	e0bffb17 	ldw	r2,-20(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
8113b544:	e0bff315 	stw	r2,-52(fp)
    switch (opt) {
8113b548:	e0bffe03 	ldbu	r2,-8(fp)
8113b54c:	10000326 	beq	r2,zero,8113b55c <OSFlagPost+0xbc>
8113b550:	10800060 	cmpeqi	r2,r2,1
8113b554:	10000b1e 	bne	r2,zero,8113b584 <OSFlagPost+0xe4>
8113b558:	00001206 	br	8113b5a4 <OSFlagPost+0x104>
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
8113b55c:	e0bffc17 	ldw	r2,-16(fp)
8113b560:	1080020b 	ldhu	r2,8(r2)
8113b564:	1007883a 	mov	r3,r2
8113b568:	e0bffd0b 	ldhu	r2,-12(fp)
8113b56c:	0084303a 	nor	r2,zero,r2
8113b570:	1884703a 	and	r2,r3,r2
8113b574:	1007883a 	mov	r3,r2
8113b578:	e0bffc17 	ldw	r2,-16(fp)
8113b57c:	10c0020d 	sth	r3,8(r2)
             break;
8113b580:	00001106 	br	8113b5c8 <OSFlagPost+0x128>

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
8113b584:	e0bffc17 	ldw	r2,-16(fp)
8113b588:	10c0020b 	ldhu	r3,8(r2)
8113b58c:	e0bffd0b 	ldhu	r2,-12(fp)
8113b590:	1884b03a 	or	r2,r3,r2
8113b594:	1007883a 	mov	r3,r2
8113b598:	e0bffc17 	ldw	r2,-16(fp)
8113b59c:	10c0020d 	sth	r3,8(r2)
             break;
8113b5a0:	00000906 	br	8113b5c8 <OSFlagPost+0x128>
8113b5a4:	e0bff317 	ldw	r2,-52(fp)
8113b5a8:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b5ac:	e0bff417 	ldw	r2,-48(fp)
8113b5b0:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
             *perr = OS_ERR_FLAG_INVALID_OPT;
8113b5b4:	e0bfff17 	ldw	r2,-4(fp)
8113b5b8:	00c01c44 	movi	r3,113
8113b5bc:	10c00005 	stb	r3,0(r2)
             return ((OS_FLAGS)0);
8113b5c0:	0005883a 	mov	r2,zero
8113b5c4:	00009806 	br	8113b828 <OSFlagPost+0x388>
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
8113b5c8:	e03ff205 	stb	zero,-56(fp)
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
8113b5cc:	e0bffc17 	ldw	r2,-16(fp)
8113b5d0:	10800117 	ldw	r2,4(r2)
8113b5d4:	e0bff115 	stw	r2,-60(fp)
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
8113b5d8:	00007706 	br	8113b7b8 <OSFlagPost+0x318>
        switch (pnode->OSFlagNodeWaitType) {
8113b5dc:	e0bff117 	ldw	r2,-60(fp)
8113b5e0:	10800483 	ldbu	r2,18(r2)
8113b5e4:	10803fcc 	andi	r2,r2,255
8113b5e8:	10c00060 	cmpeqi	r3,r2,1
8113b5ec:	18004a1e 	bne	r3,zero,8113b718 <OSFlagPost+0x278>
8113b5f0:	10c00088 	cmpgei	r3,r2,2
8113b5f4:	1800021e 	bne	r3,zero,8113b600 <OSFlagPost+0x160>
8113b5f8:	10002f26 	beq	r2,zero,8113b6b8 <OSFlagPost+0x218>
8113b5fc:	00005b06 	br	8113b76c <OSFlagPost+0x2cc>
8113b600:	10c000a0 	cmpeqi	r3,r2,2
8113b604:	1800031e 	bne	r3,zero,8113b614 <OSFlagPost+0x174>
8113b608:	108000e0 	cmpeqi	r2,r2,3
8113b60c:	1000171e 	bne	r2,zero,8113b66c <OSFlagPost+0x1cc>
8113b610:	00005606 	br	8113b76c <OSFlagPost+0x2cc>
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8113b614:	e0bffc17 	ldw	r2,-16(fp)
8113b618:	10c0020b 	ldhu	r3,8(r2)
8113b61c:	e0bff117 	ldw	r2,-60(fp)
8113b620:	1080040b 	ldhu	r2,16(r2)
8113b624:	1884703a 	and	r2,r3,r2
8113b628:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
8113b62c:	e0bff117 	ldw	r2,-60(fp)
8113b630:	1080040b 	ldhu	r2,16(r2)
8113b634:	10ffffcc 	andi	r3,r2,65535
8113b638:	e0bff60b 	ldhu	r2,-40(fp)
8113b63c:	1880541e 	bne	r3,r2,8113b790 <OSFlagPost+0x2f0>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8113b640:	e0bff60b 	ldhu	r2,-40(fp)
8113b644:	100b883a 	mov	r5,r2
8113b648:	e13ff117 	ldw	r4,-60(fp)
8113b64c:	113bb580 	call	8113bb58 <OS_FlagTaskRdy>
8113b650:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
8113b654:	e0bff683 	ldbu	r2,-38(fp)
8113b658:	10800058 	cmpnei	r2,r2,1
8113b65c:	10004c1e 	bne	r2,zero,8113b790 <OSFlagPost+0x2f0>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8113b660:	00800044 	movi	r2,1
8113b664:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
8113b668:	00004906 	br	8113b790 <OSFlagPost+0x2f0>

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8113b66c:	e0bffc17 	ldw	r2,-16(fp)
8113b670:	10c0020b 	ldhu	r3,8(r2)
8113b674:	e0bff117 	ldw	r2,-60(fp)
8113b678:	1080040b 	ldhu	r2,16(r2)
8113b67c:	1884703a 	and	r2,r3,r2
8113b680:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
8113b684:	e0bff60b 	ldhu	r2,-40(fp)
8113b688:	10004326 	beq	r2,zero,8113b798 <OSFlagPost+0x2f8>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8113b68c:	e0bff60b 	ldhu	r2,-40(fp)
8113b690:	100b883a 	mov	r5,r2
8113b694:	e13ff117 	ldw	r4,-60(fp)
8113b698:	113bb580 	call	8113bb58 <OS_FlagTaskRdy>
8113b69c:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
8113b6a0:	e0bff683 	ldbu	r2,-38(fp)
8113b6a4:	10800058 	cmpnei	r2,r2,1
8113b6a8:	10003b1e 	bne	r2,zero,8113b798 <OSFlagPost+0x2f8>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8113b6ac:	00800044 	movi	r2,1
8113b6b0:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
8113b6b4:	00003806 	br	8113b798 <OSFlagPost+0x2f8>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8113b6b8:	e0bffc17 	ldw	r2,-16(fp)
8113b6bc:	1080020b 	ldhu	r2,8(r2)
8113b6c0:	0084303a 	nor	r2,zero,r2
8113b6c4:	1007883a 	mov	r3,r2
8113b6c8:	e0bff117 	ldw	r2,-60(fp)
8113b6cc:	1080040b 	ldhu	r2,16(r2)
8113b6d0:	1884703a 	and	r2,r3,r2
8113b6d4:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
8113b6d8:	e0bff117 	ldw	r2,-60(fp)
8113b6dc:	1080040b 	ldhu	r2,16(r2)
8113b6e0:	10ffffcc 	andi	r3,r2,65535
8113b6e4:	e0bff60b 	ldhu	r2,-40(fp)
8113b6e8:	18802d1e 	bne	r3,r2,8113b7a0 <OSFlagPost+0x300>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8113b6ec:	e0bff60b 	ldhu	r2,-40(fp)
8113b6f0:	100b883a 	mov	r5,r2
8113b6f4:	e13ff117 	ldw	r4,-60(fp)
8113b6f8:	113bb580 	call	8113bb58 <OS_FlagTaskRdy>
8113b6fc:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
8113b700:	e0bff683 	ldbu	r2,-38(fp)
8113b704:	10800058 	cmpnei	r2,r2,1
8113b708:	1000251e 	bne	r2,zero,8113b7a0 <OSFlagPost+0x300>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8113b70c:	00800044 	movi	r2,1
8113b710:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
8113b714:	00002206 	br	8113b7a0 <OSFlagPost+0x300>

            case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8113b718:	e0bffc17 	ldw	r2,-16(fp)
8113b71c:	1080020b 	ldhu	r2,8(r2)
8113b720:	0084303a 	nor	r2,zero,r2
8113b724:	1007883a 	mov	r3,r2
8113b728:	e0bff117 	ldw	r2,-60(fp)
8113b72c:	1080040b 	ldhu	r2,16(r2)
8113b730:	1884703a 	and	r2,r3,r2
8113b734:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
8113b738:	e0bff60b 	ldhu	r2,-40(fp)
8113b73c:	10001a26 	beq	r2,zero,8113b7a8 <OSFlagPost+0x308>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8113b740:	e0bff60b 	ldhu	r2,-40(fp)
8113b744:	100b883a 	mov	r5,r2
8113b748:	e13ff117 	ldw	r4,-60(fp)
8113b74c:	113bb580 	call	8113bb58 <OS_FlagTaskRdy>
8113b750:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
8113b754:	e0bff683 	ldbu	r2,-38(fp)
8113b758:	10800058 	cmpnei	r2,r2,1
8113b75c:	1000121e 	bne	r2,zero,8113b7a8 <OSFlagPost+0x308>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8113b760:	00800044 	movi	r2,1
8113b764:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
8113b768:	00000f06 	br	8113b7a8 <OSFlagPost+0x308>
8113b76c:	e0bff317 	ldw	r2,-52(fp)
8113b770:	e0bff515 	stw	r2,-44(fp)
8113b774:	e0bff517 	ldw	r2,-44(fp)
8113b778:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
8113b77c:	e0bfff17 	ldw	r2,-4(fp)
8113b780:	00c01bc4 	movi	r3,111
8113b784:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
8113b788:	0005883a 	mov	r2,zero
8113b78c:	00002606 	br	8113b828 <OSFlagPost+0x388>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
8113b790:	0001883a 	nop
8113b794:	00000506 	br	8113b7ac <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
8113b798:	0001883a 	nop
8113b79c:	00000306 	br	8113b7ac <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
8113b7a0:	0001883a 	nop
8113b7a4:	00000106 	br	8113b7ac <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
8113b7a8:	0001883a 	nop
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
8113b7ac:	e0bff117 	ldw	r2,-60(fp)
8113b7b0:	10800017 	ldw	r2,0(r2)
8113b7b4:	e0bff115 	stw	r2,-60(fp)
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
8113b7b8:	e0bff117 	ldw	r2,-60(fp)
8113b7bc:	103f871e 	bne	r2,zero,8113b5dc <__reset+0xfb11b5dc>
8113b7c0:	e0bff317 	ldw	r2,-52(fp)
8113b7c4:	e0bff715 	stw	r2,-36(fp)
8113b7c8:	e0bff717 	ldw	r2,-36(fp)
8113b7cc:	1001703a 	wrctl	status,r2
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
    if (sched == OS_TRUE) {
8113b7d0:	e0bff203 	ldbu	r2,-56(fp)
8113b7d4:	10800058 	cmpnei	r2,r2,1
8113b7d8:	1000011e 	bne	r2,zero,8113b7e0 <OSFlagPost+0x340>
        OS_Sched();
8113b7dc:	1139c680 	call	81139c68 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b7e0:	0005303a 	rdctl	r2,status
8113b7e4:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b7e8:	e0fffa17 	ldw	r3,-24(fp)
8113b7ec:	00bfff84 	movi	r2,-2
8113b7f0:	1884703a 	and	r2,r3,r2
8113b7f4:	1001703a 	wrctl	status,r2
  
  return context;
8113b7f8:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
8113b7fc:	e0bff315 	stw	r2,-52(fp)
    flags_cur = pgrp->OSFlagFlags;
8113b800:	e0bffc17 	ldw	r2,-16(fp)
8113b804:	1080020b 	ldhu	r2,8(r2)
8113b808:	e0bff90d 	sth	r2,-28(fp)
8113b80c:	e0bff317 	ldw	r2,-52(fp)
8113b810:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b814:	e0bff817 	ldw	r2,-32(fp)
8113b818:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr     = OS_ERR_NONE;
8113b81c:	e0bfff17 	ldw	r2,-4(fp)
8113b820:	10000005 	stb	zero,0(r2)
    return (flags_cur);
8113b824:	e0bff90b 	ldhu	r2,-28(fp)
}
8113b828:	e037883a 	mov	sp,fp
8113b82c:	dfc00117 	ldw	ra,4(sp)
8113b830:	df000017 	ldw	fp,0(sp)
8113b834:	dec00204 	addi	sp,sp,8
8113b838:	f800283a 	ret

8113b83c <OSFlagQuery>:
*********************************************************************************************************
*/

#if OS_FLAG_QUERY_EN > 0
OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *perr)
{
8113b83c:	defff904 	addi	sp,sp,-28
8113b840:	de00012e 	bgeu	sp,et,8113b848 <OSFlagQuery+0xc>
8113b844:	003b68fa 	trap	3
8113b848:	df000615 	stw	fp,24(sp)
8113b84c:	df000604 	addi	fp,sp,24
8113b850:	e13ffe15 	stw	r4,-8(fp)
8113b854:	e17fff15 	stw	r5,-4(fp)
    OS_FLAGS   flags;
#if OS_CRITICAL_METHOD == 3                       /* Allocate storage for CPU status register          */
    OS_CPU_SR  cpu_sr = 0;
8113b858:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
8113b85c:	e0bfff17 	ldw	r2,-4(fp)
8113b860:	1000021e 	bne	r2,zero,8113b86c <OSFlagQuery+0x30>
        return ((OS_FLAGS)0);
8113b864:	0005883a 	mov	r2,zero
8113b868:	00002306 	br	8113b8f8 <OSFlagQuery+0xbc>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
8113b86c:	e0bffe17 	ldw	r2,-8(fp)
8113b870:	1000051e 	bne	r2,zero,8113b888 <OSFlagQuery+0x4c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113b874:	e0bfff17 	ldw	r2,-4(fp)
8113b878:	00c01b84 	movi	r3,110
8113b87c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113b880:	0005883a 	mov	r2,zero
8113b884:	00001c06 	br	8113b8f8 <OSFlagQuery+0xbc>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
8113b888:	e0bffe17 	ldw	r2,-8(fp)
8113b88c:	10800003 	ldbu	r2,0(r2)
8113b890:	10803fcc 	andi	r2,r2,255
8113b894:	10800160 	cmpeqi	r2,r2,5
8113b898:	1000051e 	bne	r2,zero,8113b8b0 <OSFlagQuery+0x74>
        *perr = OS_ERR_EVENT_TYPE;
8113b89c:	e0bfff17 	ldw	r2,-4(fp)
8113b8a0:	00c00044 	movi	r3,1
8113b8a4:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113b8a8:	0005883a 	mov	r2,zero
8113b8ac:	00001206 	br	8113b8f8 <OSFlagQuery+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b8b0:	0005303a 	rdctl	r2,status
8113b8b4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b8b8:	e0fffc17 	ldw	r3,-16(fp)
8113b8bc:	00bfff84 	movi	r2,-2
8113b8c0:	1884703a 	and	r2,r3,r2
8113b8c4:	1001703a 	wrctl	status,r2
  
  return context;
8113b8c8:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113b8cc:	e0bffa15 	stw	r2,-24(fp)
    flags = pgrp->OSFlagFlags;
8113b8d0:	e0bffe17 	ldw	r2,-8(fp)
8113b8d4:	1080020b 	ldhu	r2,8(r2)
8113b8d8:	e0bffb0d 	sth	r2,-20(fp)
8113b8dc:	e0bffa17 	ldw	r2,-24(fp)
8113b8e0:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b8e4:	e0bffd17 	ldw	r2,-12(fp)
8113b8e8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113b8ec:	e0bfff17 	ldw	r2,-4(fp)
8113b8f0:	10000005 	stb	zero,0(r2)
    return (flags);                               /* Return the current value of the event flags       */
8113b8f4:	e0bffb0b 	ldhu	r2,-20(fp)
}
8113b8f8:	e037883a 	mov	sp,fp
8113b8fc:	df000017 	ldw	fp,0(sp)
8113b900:	dec00104 	addi	sp,sp,4
8113b904:	f800283a 	ret

8113b908 <OS_FlagBlock>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
8113b908:	defff804 	addi	sp,sp,-32
8113b90c:	de00012e 	bgeu	sp,et,8113b914 <OS_FlagBlock+0xc>
8113b910:	003b68fa 	trap	3
8113b914:	df000715 	stw	fp,28(sp)
8113b918:	df000704 	addi	fp,sp,28
8113b91c:	e13ffb15 	stw	r4,-20(fp)
8113b920:	e17ffc15 	stw	r5,-16(fp)
8113b924:	3009883a 	mov	r4,r6
8113b928:	3807883a 	mov	r3,r7
8113b92c:	e0800117 	ldw	r2,4(fp)
8113b930:	e13ffd0d 	sth	r4,-12(fp)
8113b934:	e0fffe05 	stb	r3,-8(fp)
8113b938:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
8113b93c:	d0a0a217 	ldw	r2,-32120(gp)
8113b940:	d0e0a217 	ldw	r3,-32120(gp)
8113b944:	18c00c03 	ldbu	r3,48(r3)
8113b948:	18c00814 	ori	r3,r3,32
8113b94c:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
8113b950:	d0a0a217 	ldw	r2,-32120(gp)
8113b954:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
8113b958:	d0a0a217 	ldw	r2,-32120(gp)
8113b95c:	e0ffff0b 	ldhu	r3,-4(fp)
8113b960:	10c00b8d 	sth	r3,46(r2)
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
8113b964:	d0a0a217 	ldw	r2,-32120(gp)
8113b968:	e0fffc17 	ldw	r3,-16(fp)
8113b96c:	10c00a15 	stw	r3,40(r2)
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
8113b970:	e0bffc17 	ldw	r2,-16(fp)
8113b974:	e0fffd0b 	ldhu	r3,-12(fp)
8113b978:	10c0040d 	sth	r3,16(r2)
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
8113b97c:	e0bffc17 	ldw	r2,-16(fp)
8113b980:	e0fffe03 	ldbu	r3,-8(fp)
8113b984:	10c00485 	stb	r3,18(r2)
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
8113b988:	d0e0a217 	ldw	r3,-32120(gp)
8113b98c:	e0bffc17 	ldw	r2,-16(fp)
8113b990:	10c00215 	stw	r3,8(r2)
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
8113b994:	e0bffb17 	ldw	r2,-20(fp)
8113b998:	10c00117 	ldw	r3,4(r2)
8113b99c:	e0bffc17 	ldw	r2,-16(fp)
8113b9a0:	10c00015 	stw	r3,0(r2)
    pnode->OSFlagNodePrev     = (void *)0;
8113b9a4:	e0bffc17 	ldw	r2,-16(fp)
8113b9a8:	10000115 	stw	zero,4(r2)
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
8113b9ac:	e0bffc17 	ldw	r2,-16(fp)
8113b9b0:	e0fffb17 	ldw	r3,-20(fp)
8113b9b4:	10c00315 	stw	r3,12(r2)
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
8113b9b8:	e0bffb17 	ldw	r2,-20(fp)
8113b9bc:	10800117 	ldw	r2,4(r2)
8113b9c0:	e0bff915 	stw	r2,-28(fp)
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
8113b9c4:	e0bff917 	ldw	r2,-28(fp)
8113b9c8:	10000326 	beq	r2,zero,8113b9d8 <OS_FlagBlock+0xd0>
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
8113b9cc:	e0bff917 	ldw	r2,-28(fp)
8113b9d0:	e0fffc17 	ldw	r3,-16(fp)
8113b9d4:	10c00115 	stw	r3,4(r2)
    }
    pgrp->OSFlagWaitList = (void *)pnode;
8113b9d8:	e0bffb17 	ldw	r2,-20(fp)
8113b9dc:	e0fffc17 	ldw	r3,-16(fp)
8113b9e0:	10c00115 	stw	r3,4(r2)

    y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
8113b9e4:	d0a0a217 	ldw	r2,-32120(gp)
8113b9e8:	10800d03 	ldbu	r2,52(r2)
8113b9ec:	e0bffa05 	stb	r2,-24(fp)
    OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
8113b9f0:	e0fffa03 	ldbu	r3,-24(fp)
8113b9f4:	e13ffa03 	ldbu	r4,-24(fp)
8113b9f8:	d0a09e44 	addi	r2,gp,-32135
8113b9fc:	2085883a 	add	r2,r4,r2
8113ba00:	10800003 	ldbu	r2,0(r2)
8113ba04:	1009883a 	mov	r4,r2
8113ba08:	d0a0a217 	ldw	r2,-32120(gp)
8113ba0c:	10800d43 	ldbu	r2,53(r2)
8113ba10:	0084303a 	nor	r2,zero,r2
8113ba14:	2084703a 	and	r2,r4,r2
8113ba18:	1009883a 	mov	r4,r2
8113ba1c:	d0a09e44 	addi	r2,gp,-32135
8113ba20:	1885883a 	add	r2,r3,r2
8113ba24:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0x00) {
8113ba28:	e0fffa03 	ldbu	r3,-24(fp)
8113ba2c:	d0a09e44 	addi	r2,gp,-32135
8113ba30:	1885883a 	add	r2,r3,r2
8113ba34:	10800003 	ldbu	r2,0(r2)
8113ba38:	10803fcc 	andi	r2,r2,255
8113ba3c:	1000071e 	bne	r2,zero,8113ba5c <OS_FlagBlock+0x154>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
8113ba40:	d0a0a217 	ldw	r2,-32120(gp)
8113ba44:	10800d83 	ldbu	r2,54(r2)
8113ba48:	0084303a 	nor	r2,zero,r2
8113ba4c:	1007883a 	mov	r3,r2
8113ba50:	d0a09e03 	ldbu	r2,-32136(gp)
8113ba54:	1884703a 	and	r2,r3,r2
8113ba58:	d0a09e05 	stb	r2,-32136(gp)
    }
}
8113ba5c:	0001883a 	nop
8113ba60:	e037883a 	mov	sp,fp
8113ba64:	df000017 	ldw	fp,0(sp)
8113ba68:	dec00104 	addi	sp,sp,4
8113ba6c:	f800283a 	ret

8113ba70 <OS_FlagInit>:
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
8113ba70:	defffb04 	addi	sp,sp,-20
8113ba74:	de00012e 	bgeu	sp,et,8113ba7c <OS_FlagInit+0xc>
8113ba78:	003b68fa 	trap	3
8113ba7c:	dfc00415 	stw	ra,16(sp)
8113ba80:	df000315 	stw	fp,12(sp)
8113ba84:	df000304 	addi	fp,sp,12
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
8113ba88:	01421004 	movi	r5,2112
8113ba8c:	012045b4 	movhi	r4,33046
8113ba90:	211c2704 	addi	r4,r4,28828
8113ba94:	1139b9c0 	call	81139b9c <OS_MemClr>
    pgrp1 = &OSFlagTbl[0];
8113ba98:	00a045b4 	movhi	r2,33046
8113ba9c:	109c2704 	addi	r2,r2,28828
8113baa0:	e0bffe15 	stw	r2,-8(fp)
    pgrp2 = &OSFlagTbl[1];
8113baa4:	00a045b4 	movhi	r2,33046
8113baa8:	109c3204 	addi	r2,r2,28872
8113baac:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
8113bab0:	e03ffd0d 	sth	zero,-12(fp)
8113bab4:	00001306 	br	8113bb04 <OS_FlagInit+0x94>
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
8113bab8:	e0bffe17 	ldw	r2,-8(fp)
8113babc:	10000005 	stb	zero,0(r2)
        pgrp1->OSFlagWaitList = (void *)pgrp2;
8113bac0:	e0bffe17 	ldw	r2,-8(fp)
8113bac4:	e0ffff17 	ldw	r3,-4(fp)
8113bac8:	10c00115 	stw	r3,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
8113bacc:	e0bffe17 	ldw	r2,-8(fp)
8113bad0:	00c00fc4 	movi	r3,63
8113bad4:	10c00285 	stb	r3,10(r2)
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
8113bad8:	e0bffe17 	ldw	r2,-8(fp)
8113badc:	100002c5 	stb	zero,11(r2)
#endif
        pgrp1++;
8113bae0:	e0bffe17 	ldw	r2,-8(fp)
8113bae4:	10800b04 	addi	r2,r2,44
8113bae8:	e0bffe15 	stw	r2,-8(fp)
        pgrp2++;
8113baec:	e0bfff17 	ldw	r2,-4(fp)
8113baf0:	10800b04 	addi	r2,r2,44
8113baf4:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
8113baf8:	e0bffd0b 	ldhu	r2,-12(fp)
8113bafc:	10800044 	addi	r2,r2,1
8113bb00:	e0bffd0d 	sth	r2,-12(fp)
8113bb04:	e0bffd0b 	ldhu	r2,-12(fp)
8113bb08:	10800bf0 	cmpltui	r2,r2,47
8113bb0c:	103fea1e 	bne	r2,zero,8113bab8 <__reset+0xfb11bab8>
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
8113bb10:	e0bffe17 	ldw	r2,-8(fp)
8113bb14:	10000005 	stb	zero,0(r2)
    pgrp1->OSFlagWaitList = (void *)0;
8113bb18:	e0bffe17 	ldw	r2,-8(fp)
8113bb1c:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
8113bb20:	e0bffe17 	ldw	r2,-8(fp)
8113bb24:	00c00fc4 	movi	r3,63
8113bb28:	10c00285 	stb	r3,10(r2)
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
8113bb2c:	e0bffe17 	ldw	r2,-8(fp)
8113bb30:	100002c5 	stb	zero,11(r2)
#endif
    OSFlagFreeList        = &OSFlagTbl[0];
8113bb34:	00a045b4 	movhi	r2,33046
8113bb38:	109c2704 	addi	r2,r2,28828
8113bb3c:	d0a0a615 	stw	r2,-32104(gp)
#endif
}
8113bb40:	0001883a 	nop
8113bb44:	e037883a 	mov	sp,fp
8113bb48:	dfc00117 	ldw	ra,4(sp)
8113bb4c:	df000017 	ldw	fp,0(sp)
8113bb50:	dec00204 	addi	sp,sp,8
8113bb54:	f800283a 	ret

8113bb58 <OS_FlagTaskRdy>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
8113bb58:	defffa04 	addi	sp,sp,-24
8113bb5c:	de00012e 	bgeu	sp,et,8113bb64 <OS_FlagTaskRdy+0xc>
8113bb60:	003b68fa 	trap	3
8113bb64:	dfc00515 	stw	ra,20(sp)
8113bb68:	df000415 	stw	fp,16(sp)
8113bb6c:	df000404 	addi	fp,sp,16
8113bb70:	e13ffe15 	stw	r4,-8(fp)
8113bb74:	2805883a 	mov	r2,r5
8113bb78:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
8113bb7c:	e0bffe17 	ldw	r2,-8(fp)
8113bb80:	10800217 	ldw	r2,8(r2)
8113bb84:	e0bffd15 	stw	r2,-12(fp)
    ptcb->OSTCBDly       = 0;
8113bb88:	e0bffd17 	ldw	r2,-12(fp)
8113bb8c:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBFlagsRdy  = flags_rdy;
8113bb90:	e0bffd17 	ldw	r2,-12(fp)
8113bb94:	e0ffff0b 	ldhu	r3,-4(fp)
8113bb98:	10c00b0d 	sth	r3,44(r2)
    ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
8113bb9c:	e0bffd17 	ldw	r2,-12(fp)
8113bba0:	10c00c03 	ldbu	r3,48(r2)
8113bba4:	00bff7c4 	movi	r2,-33
8113bba8:	1884703a 	and	r2,r3,r2
8113bbac:	1007883a 	mov	r3,r2
8113bbb0:	e0bffd17 	ldw	r2,-12(fp)
8113bbb4:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
8113bbb8:	e0bffd17 	ldw	r2,-12(fp)
8113bbbc:	10000c45 	stb	zero,49(r2)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
8113bbc0:	e0bffd17 	ldw	r2,-12(fp)
8113bbc4:	10800c03 	ldbu	r2,48(r2)
8113bbc8:	10803fcc 	andi	r2,r2,255
8113bbcc:	1000181e 	bne	r2,zero,8113bc30 <OS_FlagTaskRdy+0xd8>
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
8113bbd0:	e0bffd17 	ldw	r2,-12(fp)
8113bbd4:	10c00d83 	ldbu	r3,54(r2)
8113bbd8:	d0a09e03 	ldbu	r2,-32136(gp)
8113bbdc:	1884b03a 	or	r2,r3,r2
8113bbe0:	d0a09e05 	stb	r2,-32136(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113bbe4:	e0bffd17 	ldw	r2,-12(fp)
8113bbe8:	10800d03 	ldbu	r2,52(r2)
8113bbec:	10c03fcc 	andi	r3,r2,255
8113bbf0:	e0bffd17 	ldw	r2,-12(fp)
8113bbf4:	10800d03 	ldbu	r2,52(r2)
8113bbf8:	11003fcc 	andi	r4,r2,255
8113bbfc:	d0a09e44 	addi	r2,gp,-32135
8113bc00:	2085883a 	add	r2,r4,r2
8113bc04:	11000003 	ldbu	r4,0(r2)
8113bc08:	e0bffd17 	ldw	r2,-12(fp)
8113bc0c:	10800d43 	ldbu	r2,53(r2)
8113bc10:	2084b03a 	or	r2,r4,r2
8113bc14:	1009883a 	mov	r4,r2
8113bc18:	d0a09e44 	addi	r2,gp,-32135
8113bc1c:	1885883a 	add	r2,r3,r2
8113bc20:	11000005 	stb	r4,0(r2)
        sched                   = OS_TRUE;
8113bc24:	00800044 	movi	r2,1
8113bc28:	e0bffc05 	stb	r2,-16(fp)
8113bc2c:	00000106 	br	8113bc34 <OS_FlagTaskRdy+0xdc>
    } else {
        sched                   = OS_FALSE;
8113bc30:	e03ffc05 	stb	zero,-16(fp)
    }
    OS_FlagUnlink(pnode);
8113bc34:	e13ffe17 	ldw	r4,-8(fp)
8113bc38:	113bc540 	call	8113bc54 <OS_FlagUnlink>
    return (sched);
8113bc3c:	e0bffc03 	ldbu	r2,-16(fp)
}
8113bc40:	e037883a 	mov	sp,fp
8113bc44:	dfc00117 	ldw	ra,4(sp)
8113bc48:	df000017 	ldw	fp,0(sp)
8113bc4c:	dec00204 	addi	sp,sp,8
8113bc50:	f800283a 	ret

8113bc54 <OS_FlagUnlink>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
{
8113bc54:	defffa04 	addi	sp,sp,-24
8113bc58:	de00012e 	bgeu	sp,et,8113bc60 <OS_FlagUnlink+0xc>
8113bc5c:	003b68fa 	trap	3
8113bc60:	df000515 	stw	fp,20(sp)
8113bc64:	df000504 	addi	fp,sp,20
8113bc68:	e13fff15 	stw	r4,-4(fp)
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
8113bc6c:	e0bfff17 	ldw	r2,-4(fp)
8113bc70:	10800117 	ldw	r2,4(r2)
8113bc74:	e0bffb15 	stw	r2,-20(fp)
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
8113bc78:	e0bfff17 	ldw	r2,-4(fp)
8113bc7c:	10800017 	ldw	r2,0(r2)
8113bc80:	e0bffc15 	stw	r2,-16(fp)
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
8113bc84:	e0bffb17 	ldw	r2,-20(fp)
8113bc88:	10000b1e 	bne	r2,zero,8113bcb8 <OS_FlagUnlink+0x64>
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
8113bc8c:	e0bfff17 	ldw	r2,-4(fp)
8113bc90:	10800317 	ldw	r2,12(r2)
8113bc94:	e0bffd15 	stw	r2,-12(fp)
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
8113bc98:	e0bffd17 	ldw	r2,-12(fp)
8113bc9c:	e0fffc17 	ldw	r3,-16(fp)
8113bca0:	10c00115 	stw	r3,4(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {
8113bca4:	e0bffc17 	ldw	r2,-16(fp)
8113bca8:	10000b26 	beq	r2,zero,8113bcd8 <OS_FlagUnlink+0x84>
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
8113bcac:	e0bffc17 	ldw	r2,-16(fp)
8113bcb0:	10000115 	stw	zero,4(r2)
8113bcb4:	00000806 	br	8113bcd8 <OS_FlagUnlink+0x84>
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
8113bcb8:	e0bffb17 	ldw	r2,-20(fp)
8113bcbc:	e0fffc17 	ldw	r3,-16(fp)
8113bcc0:	10c00015 	stw	r3,0(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
8113bcc4:	e0bffc17 	ldw	r2,-16(fp)
8113bcc8:	10000326 	beq	r2,zero,8113bcd8 <OS_FlagUnlink+0x84>
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
8113bccc:	e0bffc17 	ldw	r2,-16(fp)
8113bcd0:	e0fffb17 	ldw	r3,-20(fp)
8113bcd4:	10c00115 	stw	r3,4(r2)
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
8113bcd8:	e0bfff17 	ldw	r2,-4(fp)
8113bcdc:	10800217 	ldw	r2,8(r2)
8113bce0:	e0bffe15 	stw	r2,-8(fp)
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
8113bce4:	e0bffe17 	ldw	r2,-8(fp)
8113bce8:	10000a15 	stw	zero,40(r2)
#endif
}
8113bcec:	0001883a 	nop
8113bcf0:	e037883a 	mov	sp,fp
8113bcf4:	df000017 	ldw	fp,0(sp)
8113bcf8:	dec00104 	addi	sp,sp,4
8113bcfc:	f800283a 	ret

8113bd00 <OSMemCreate>:
*                              free partition is available.
*********************************************************************************************************
*/

OS_MEM  *OSMemCreate (void *addr, INT32U nblks, INT32U blksize, INT8U *perr)
{
8113bd00:	defff404 	addi	sp,sp,-48
8113bd04:	de00012e 	bgeu	sp,et,8113bd0c <OSMemCreate+0xc>
8113bd08:	003b68fa 	trap	3
8113bd0c:	df000b15 	stw	fp,44(sp)
8113bd10:	df000b04 	addi	fp,sp,44
8113bd14:	e13ffc15 	stw	r4,-16(fp)
8113bd18:	e17ffd15 	stw	r5,-12(fp)
8113bd1c:	e1bffe15 	stw	r6,-8(fp)
8113bd20:	e1ffff15 	stw	r7,-4(fp)
    OS_MEM    *pmem;
    INT8U     *pblk;
    void     **plink;
    INT32U     i;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113bd24:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0              
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113bd28:	e0bfff17 	ldw	r2,-4(fp)
8113bd2c:	1000021e 	bne	r2,zero,8113bd38 <OSMemCreate+0x38>
        return ((OS_MEM *)0);
8113bd30:	0005883a 	mov	r2,zero
8113bd34:	00006506 	br	8113becc <OSMemCreate+0x1cc>
    }
    if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
8113bd38:	e0bffc17 	ldw	r2,-16(fp)
8113bd3c:	1000051e 	bne	r2,zero,8113bd54 <OSMemCreate+0x54>
        *perr = OS_ERR_MEM_INVALID_ADDR;
8113bd40:	e0bfff17 	ldw	r2,-4(fp)
8113bd44:	00c01884 	movi	r3,98
8113bd48:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113bd4c:	0005883a 	mov	r2,zero
8113bd50:	00005e06 	br	8113becc <OSMemCreate+0x1cc>
    }
    if (((INT32U)addr & (sizeof(void *) - 1)) != 0){  /* Must be pointer size aligned                  */
8113bd54:	e0bffc17 	ldw	r2,-16(fp)
8113bd58:	108000cc 	andi	r2,r2,3
8113bd5c:	10000526 	beq	r2,zero,8113bd74 <OSMemCreate+0x74>
        *perr = OS_ERR_MEM_INVALID_ADDR;
8113bd60:	e0bfff17 	ldw	r2,-4(fp)
8113bd64:	00c01884 	movi	r3,98
8113bd68:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113bd6c:	0005883a 	mov	r2,zero
8113bd70:	00005606 	br	8113becc <OSMemCreate+0x1cc>
    }
    if (nblks < 2) {                                  /* Must have at least 2 blocks per partition     */
8113bd74:	e0bffd17 	ldw	r2,-12(fp)
8113bd78:	108000a8 	cmpgeui	r2,r2,2
8113bd7c:	1000051e 	bne	r2,zero,8113bd94 <OSMemCreate+0x94>
        *perr = OS_ERR_MEM_INVALID_BLKS;
8113bd80:	e0bfff17 	ldw	r2,-4(fp)
8113bd84:	00c016c4 	movi	r3,91
8113bd88:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113bd8c:	0005883a 	mov	r2,zero
8113bd90:	00004e06 	br	8113becc <OSMemCreate+0x1cc>
    }
    if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
8113bd94:	e0bffe17 	ldw	r2,-8(fp)
8113bd98:	10800128 	cmpgeui	r2,r2,4
8113bd9c:	1000051e 	bne	r2,zero,8113bdb4 <OSMemCreate+0xb4>
        *perr = OS_ERR_MEM_INVALID_SIZE;
8113bda0:	e0bfff17 	ldw	r2,-4(fp)
8113bda4:	00c01704 	movi	r3,92
8113bda8:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113bdac:	0005883a 	mov	r2,zero
8113bdb0:	00004606 	br	8113becc <OSMemCreate+0x1cc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113bdb4:	0005303a 	rdctl	r2,status
8113bdb8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113bdbc:	e0fffb17 	ldw	r3,-20(fp)
8113bdc0:	00bfff84 	movi	r2,-2
8113bdc4:	1884703a 	and	r2,r3,r2
8113bdc8:	1001703a 	wrctl	status,r2
  
  return context;
8113bdcc:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113bdd0:	e0bff815 	stw	r2,-32(fp)
    pmem = OSMemFreeList;                             /* Get next free memory partition                */
8113bdd4:	d0a09b17 	ldw	r2,-32148(gp)
8113bdd8:	e0bffa15 	stw	r2,-24(fp)
    if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
8113bddc:	d0a09b17 	ldw	r2,-32148(gp)
8113bde0:	10000326 	beq	r2,zero,8113bdf0 <OSMemCreate+0xf0>
        OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
8113bde4:	d0a09b17 	ldw	r2,-32148(gp)
8113bde8:	10800117 	ldw	r2,4(r2)
8113bdec:	d0a09b15 	stw	r2,-32148(gp)
8113bdf0:	e0bff817 	ldw	r2,-32(fp)
8113bdf4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113bdf8:	e0bff917 	ldw	r2,-28(fp)
8113bdfc:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
8113be00:	e0bffa17 	ldw	r2,-24(fp)
8113be04:	1000051e 	bne	r2,zero,8113be1c <OSMemCreate+0x11c>
        *perr = OS_ERR_MEM_INVALID_PART;
8113be08:	e0bfff17 	ldw	r2,-4(fp)
8113be0c:	00c01684 	movi	r3,90
8113be10:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113be14:	0005883a 	mov	r2,zero
8113be18:	00002c06 	br	8113becc <OSMemCreate+0x1cc>
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
8113be1c:	e0bffc17 	ldw	r2,-16(fp)
8113be20:	e0bff615 	stw	r2,-40(fp)
    pblk  = (INT8U *)((INT32U)addr + blksize);
8113be24:	e0fffc17 	ldw	r3,-16(fp)
8113be28:	e0bffe17 	ldw	r2,-8(fp)
8113be2c:	1885883a 	add	r2,r3,r2
8113be30:	e0bff515 	stw	r2,-44(fp)
    for (i = 0; i < (nblks - 1); i++) {
8113be34:	e03ff715 	stw	zero,-36(fp)
8113be38:	00000c06 	br	8113be6c <OSMemCreate+0x16c>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
8113be3c:	e0bff617 	ldw	r2,-40(fp)
8113be40:	e0fff517 	ldw	r3,-44(fp)
8113be44:	10c00015 	stw	r3,0(r2)
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
8113be48:	e0bff517 	ldw	r2,-44(fp)
8113be4c:	e0bff615 	stw	r2,-40(fp)
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
8113be50:	e0fff517 	ldw	r3,-44(fp)
8113be54:	e0bffe17 	ldw	r2,-8(fp)
8113be58:	1885883a 	add	r2,r3,r2
8113be5c:	e0bff515 	stw	r2,-44(fp)
        *perr = OS_ERR_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0; i < (nblks - 1); i++) {
8113be60:	e0bff717 	ldw	r2,-36(fp)
8113be64:	10800044 	addi	r2,r2,1
8113be68:	e0bff715 	stw	r2,-36(fp)
8113be6c:	e0bffd17 	ldw	r2,-12(fp)
8113be70:	10bfffc4 	addi	r2,r2,-1
8113be74:	e0fff717 	ldw	r3,-36(fp)
8113be78:	18bff036 	bltu	r3,r2,8113be3c <__reset+0xfb11be3c>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
    }
    *plink              = (void *)0;                  /* Last memory block points to NULL              */
8113be7c:	e0bff617 	ldw	r2,-40(fp)
8113be80:	10000015 	stw	zero,0(r2)
    pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
8113be84:	e0bffa17 	ldw	r2,-24(fp)
8113be88:	e0fffc17 	ldw	r3,-16(fp)
8113be8c:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
8113be90:	e0bffa17 	ldw	r2,-24(fp)
8113be94:	e0fffc17 	ldw	r3,-16(fp)
8113be98:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
8113be9c:	e0bffa17 	ldw	r2,-24(fp)
8113bea0:	e0fffd17 	ldw	r3,-12(fp)
8113bea4:	10c00415 	stw	r3,16(r2)
    pmem->OSMemNBlks    = nblks;
8113bea8:	e0bffa17 	ldw	r2,-24(fp)
8113beac:	e0fffd17 	ldw	r3,-12(fp)
8113beb0:	10c00315 	stw	r3,12(r2)
    pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
8113beb4:	e0bffa17 	ldw	r2,-24(fp)
8113beb8:	e0fffe17 	ldw	r3,-8(fp)
8113bebc:	10c00215 	stw	r3,8(r2)
    *perr               = OS_ERR_NONE;
8113bec0:	e0bfff17 	ldw	r2,-4(fp)
8113bec4:	10000005 	stb	zero,0(r2)
    return (pmem);
8113bec8:	e0bffa17 	ldw	r2,-24(fp)
}
8113becc:	e037883a 	mov	sp,fp
8113bed0:	df000017 	ldw	fp,0(sp)
8113bed4:	dec00104 	addi	sp,sp,4
8113bed8:	f800283a 	ret

8113bedc <OSMemGet>:
*               A pointer to NULL if an error is detected
*********************************************************************************************************
*/

void  *OSMemGet (OS_MEM *pmem, INT8U *perr)
{
8113bedc:	defff804 	addi	sp,sp,-32
8113bee0:	de00012e 	bgeu	sp,et,8113bee8 <OSMemGet+0xc>
8113bee4:	003b68fa 	trap	3
8113bee8:	df000715 	stw	fp,28(sp)
8113beec:	df000704 	addi	fp,sp,28
8113bef0:	e13ffe15 	stw	r4,-8(fp)
8113bef4:	e17fff15 	stw	r5,-4(fp)
    void      *pblk;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113bef8:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113befc:	e0bfff17 	ldw	r2,-4(fp)
8113bf00:	1000021e 	bne	r2,zero,8113bf0c <OSMemGet+0x30>
        return ((void *)0);
8113bf04:	0005883a 	mov	r2,zero
8113bf08:	00002e06 	br	8113bfc4 <OSMemGet+0xe8>
    }
    if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
8113bf0c:	e0bffe17 	ldw	r2,-8(fp)
8113bf10:	1000051e 	bne	r2,zero,8113bf28 <OSMemGet+0x4c>
        *perr = OS_ERR_MEM_INVALID_PMEM;
8113bf14:	e0bfff17 	ldw	r2,-4(fp)
8113bf18:	00c01804 	movi	r3,96
8113bf1c:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113bf20:	0005883a 	mov	r2,zero
8113bf24:	00002706 	br	8113bfc4 <OSMemGet+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113bf28:	0005303a 	rdctl	r2,status
8113bf2c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113bf30:	e0fffd17 	ldw	r3,-12(fp)
8113bf34:	00bfff84 	movi	r2,-2
8113bf38:	1884703a 	and	r2,r3,r2
8113bf3c:	1001703a 	wrctl	status,r2
  
  return context;
8113bf40:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113bf44:	e0bff915 	stw	r2,-28(fp)
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
8113bf48:	e0bffe17 	ldw	r2,-8(fp)
8113bf4c:	10800417 	ldw	r2,16(r2)
8113bf50:	10001426 	beq	r2,zero,8113bfa4 <OSMemGet+0xc8>
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
8113bf54:	e0bffe17 	ldw	r2,-8(fp)
8113bf58:	10800117 	ldw	r2,4(r2)
8113bf5c:	e0bffb15 	stw	r2,-20(fp)
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
8113bf60:	e0bffb17 	ldw	r2,-20(fp)
8113bf64:	10c00017 	ldw	r3,0(r2)
8113bf68:	e0bffe17 	ldw	r2,-8(fp)
8113bf6c:	10c00115 	stw	r3,4(r2)
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
8113bf70:	e0bffe17 	ldw	r2,-8(fp)
8113bf74:	10800417 	ldw	r2,16(r2)
8113bf78:	10ffffc4 	addi	r3,r2,-1
8113bf7c:	e0bffe17 	ldw	r2,-8(fp)
8113bf80:	10c00415 	stw	r3,16(r2)
8113bf84:	e0bff917 	ldw	r2,-28(fp)
8113bf88:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113bf8c:	e0bffa17 	ldw	r2,-24(fp)
8113bf90:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;                          /*      No error                                 */
8113bf94:	e0bfff17 	ldw	r2,-4(fp)
8113bf98:	10000005 	stb	zero,0(r2)
        return (pblk);                                /*      Return memory block to caller            */
8113bf9c:	e0bffb17 	ldw	r2,-20(fp)
8113bfa0:	00000806 	br	8113bfc4 <OSMemGet+0xe8>
8113bfa4:	e0bff917 	ldw	r2,-28(fp)
8113bfa8:	e0bffc15 	stw	r2,-16(fp)
8113bfac:	e0bffc17 	ldw	r2,-16(fp)
8113bfb0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
8113bfb4:	e0bfff17 	ldw	r2,-4(fp)
8113bfb8:	00c01744 	movi	r3,93
8113bfbc:	10c00005 	stb	r3,0(r2)
    return ((void *)0);                               /*      Return NULL pointer to caller            */
8113bfc0:	0005883a 	mov	r2,zero
}
8113bfc4:	e037883a 	mov	sp,fp
8113bfc8:	df000017 	ldw	fp,0(sp)
8113bfcc:	dec00104 	addi	sp,sp,4
8113bfd0:	f800283a 	ret

8113bfd4 <OSMemNameGet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
INT8U  OSMemNameGet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
8113bfd4:	defff704 	addi	sp,sp,-36
8113bfd8:	de00012e 	bgeu	sp,et,8113bfe0 <OSMemNameGet+0xc>
8113bfdc:	003b68fa 	trap	3
8113bfe0:	dfc00815 	stw	ra,32(sp)
8113bfe4:	df000715 	stw	fp,28(sp)
8113bfe8:	df000704 	addi	fp,sp,28
8113bfec:	e13ffd15 	stw	r4,-12(fp)
8113bff0:	e17ffe15 	stw	r5,-8(fp)
8113bff4:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113bff8:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113bffc:	e0bfff17 	ldw	r2,-4(fp)
8113c000:	1000021e 	bne	r2,zero,8113c00c <OSMemNameGet+0x38>
        return (0);
8113c004:	0005883a 	mov	r2,zero
8113c008:	00002b06 	br	8113c0b8 <OSMemNameGet+0xe4>
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
8113c00c:	e0bffd17 	ldw	r2,-12(fp)
8113c010:	1000051e 	bne	r2,zero,8113c028 <OSMemNameGet+0x54>
        *perr = OS_ERR_MEM_INVALID_PMEM;
8113c014:	e0bfff17 	ldw	r2,-4(fp)
8113c018:	00c01804 	movi	r3,96
8113c01c:	10c00005 	stb	r3,0(r2)
        return (0);
8113c020:	0005883a 	mov	r2,zero
8113c024:	00002406 	br	8113c0b8 <OSMemNameGet+0xe4>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8113c028:	e0bffe17 	ldw	r2,-8(fp)
8113c02c:	1000051e 	bne	r2,zero,8113c044 <OSMemNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
8113c030:	e0bfff17 	ldw	r2,-4(fp)
8113c034:	00c00304 	movi	r3,12
8113c038:	10c00005 	stb	r3,0(r2)
        return (0);
8113c03c:	0005883a 	mov	r2,zero
8113c040:	00001d06 	br	8113c0b8 <OSMemNameGet+0xe4>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113c044:	d0a0a103 	ldbu	r2,-32124(gp)
8113c048:	10803fcc 	andi	r2,r2,255
8113c04c:	10000526 	beq	r2,zero,8113c064 <OSMemNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
8113c050:	e0bfff17 	ldw	r2,-4(fp)
8113c054:	00c00444 	movi	r3,17
8113c058:	10c00005 	stb	r3,0(r2)
        return (0);
8113c05c:	0005883a 	mov	r2,zero
8113c060:	00001506 	br	8113c0b8 <OSMemNameGet+0xe4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c064:	0005303a 	rdctl	r2,status
8113c068:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c06c:	e0fffb17 	ldw	r3,-20(fp)
8113c070:	00bfff84 	movi	r2,-2
8113c074:	1884703a 	and	r2,r3,r2
8113c078:	1001703a 	wrctl	status,r2
  
  return context;
8113c07c:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
8113c080:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pmem->OSMemName);  /* Copy name from OS_MEM                              */
8113c084:	e0bffd17 	ldw	r2,-12(fp)
8113c088:	10800504 	addi	r2,r2,20
8113c08c:	100b883a 	mov	r5,r2
8113c090:	e13ffe17 	ldw	r4,-8(fp)
8113c094:	1139dbc0 	call	81139dbc <OS_StrCopy>
8113c098:	e0bffa05 	stb	r2,-24(fp)
8113c09c:	e0bff917 	ldw	r2,-28(fp)
8113c0a0:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c0a4:	e0bffc17 	ldw	r2,-16(fp)
8113c0a8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113c0ac:	e0bfff17 	ldw	r2,-4(fp)
8113c0b0:	10000005 	stb	zero,0(r2)
    return (len);
8113c0b4:	e0bffa03 	ldbu	r2,-24(fp)
}
8113c0b8:	e037883a 	mov	sp,fp
8113c0bc:	dfc00117 	ldw	ra,4(sp)
8113c0c0:	df000017 	ldw	fp,0(sp)
8113c0c4:	dec00204 	addi	sp,sp,8
8113c0c8:	f800283a 	ret

8113c0cc <OSMemNameSet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
void  OSMemNameSet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
8113c0cc:	defff604 	addi	sp,sp,-40
8113c0d0:	de00012e 	bgeu	sp,et,8113c0d8 <OSMemNameSet+0xc>
8113c0d4:	003b68fa 	trap	3
8113c0d8:	dfc00915 	stw	ra,36(sp)
8113c0dc:	df000815 	stw	fp,32(sp)
8113c0e0:	df000804 	addi	fp,sp,32
8113c0e4:	e13ffd15 	stw	r4,-12(fp)
8113c0e8:	e17ffe15 	stw	r5,-8(fp)
8113c0ec:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113c0f0:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113c0f4:	e0bfff17 	ldw	r2,-4(fp)
8113c0f8:	10003526 	beq	r2,zero,8113c1d0 <OSMemNameSet+0x104>
        return;
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
8113c0fc:	e0bffd17 	ldw	r2,-12(fp)
8113c100:	1000041e 	bne	r2,zero,8113c114 <OSMemNameSet+0x48>
        *perr = OS_ERR_MEM_INVALID_PMEM;
8113c104:	e0bfff17 	ldw	r2,-4(fp)
8113c108:	00c01804 	movi	r3,96
8113c10c:	10c00005 	stb	r3,0(r2)
        return;
8113c110:	00003006 	br	8113c1d4 <OSMemNameSet+0x108>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8113c114:	e0bffe17 	ldw	r2,-8(fp)
8113c118:	1000041e 	bne	r2,zero,8113c12c <OSMemNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
8113c11c:	e0bfff17 	ldw	r2,-4(fp)
8113c120:	00c00304 	movi	r3,12
8113c124:	10c00005 	stb	r3,0(r2)
        return;
8113c128:	00002a06 	br	8113c1d4 <OSMemNameSet+0x108>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113c12c:	d0a0a103 	ldbu	r2,-32124(gp)
8113c130:	10803fcc 	andi	r2,r2,255
8113c134:	10000426 	beq	r2,zero,8113c148 <OSMemNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
8113c138:	e0bfff17 	ldw	r2,-4(fp)
8113c13c:	00c00484 	movi	r3,18
8113c140:	10c00005 	stb	r3,0(r2)
        return;
8113c144:	00002306 	br	8113c1d4 <OSMemNameSet+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c148:	0005303a 	rdctl	r2,status
8113c14c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c150:	e0fffc17 	ldw	r3,-16(fp)
8113c154:	00bfff84 	movi	r2,-2
8113c158:	1884703a 	and	r2,r3,r2
8113c15c:	1001703a 	wrctl	status,r2
  
  return context;
8113c160:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113c164:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
8113c168:	e13ffe17 	ldw	r4,-8(fp)
8113c16c:	1139e380 	call	81139e38 <OS_StrLen>
8113c170:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_MEM_NAME_SIZE - 1)) {          /* No                                                 */
8113c174:	e0bffa03 	ldbu	r2,-24(fp)
8113c178:	10800830 	cmpltui	r2,r2,32
8113c17c:	1000081e 	bne	r2,zero,8113c1a0 <OSMemNameSet+0xd4>
8113c180:	e0bff817 	ldw	r2,-32(fp)
8113c184:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c188:	e0bff917 	ldw	r2,-28(fp)
8113c18c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_MEM_NAME_TOO_LONG;
8113c190:	e0bfff17 	ldw	r2,-4(fp)
8113c194:	00c018c4 	movi	r3,99
8113c198:	10c00005 	stb	r3,0(r2)
        return;
8113c19c:	00000d06 	br	8113c1d4 <OSMemNameSet+0x108>
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
8113c1a0:	e0bffd17 	ldw	r2,-12(fp)
8113c1a4:	10800504 	addi	r2,r2,20
8113c1a8:	e17ffe17 	ldw	r5,-8(fp)
8113c1ac:	1009883a 	mov	r4,r2
8113c1b0:	1139dbc0 	call	81139dbc <OS_StrCopy>
8113c1b4:	e0bff817 	ldw	r2,-32(fp)
8113c1b8:	e0bffb15 	stw	r2,-20(fp)
8113c1bc:	e0bffb17 	ldw	r2,-20(fp)
8113c1c0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113c1c4:	e0bfff17 	ldw	r2,-4(fp)
8113c1c8:	10000005 	stb	zero,0(r2)
8113c1cc:	00000106 	br	8113c1d4 <OSMemNameSet+0x108>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
8113c1d0:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
8113c1d4:	e037883a 	mov	sp,fp
8113c1d8:	dfc00117 	ldw	ra,4(sp)
8113c1dc:	df000017 	ldw	fp,0(sp)
8113c1e0:	dec00204 	addi	sp,sp,8
8113c1e4:	f800283a 	ret

8113c1e8 <OSMemPut>:
*               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
*********************************************************************************************************
*/

INT8U  OSMemPut (OS_MEM *pmem, void *pblk)
{
8113c1e8:	defff904 	addi	sp,sp,-28
8113c1ec:	de00012e 	bgeu	sp,et,8113c1f4 <OSMemPut+0xc>
8113c1f0:	003b68fa 	trap	3
8113c1f4:	df000615 	stw	fp,24(sp)
8113c1f8:	df000604 	addi	fp,sp,24
8113c1fc:	e13ffe15 	stw	r4,-8(fp)
8113c200:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113c204:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
8113c208:	e0bffe17 	ldw	r2,-8(fp)
8113c20c:	1000021e 	bne	r2,zero,8113c218 <OSMemPut+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
8113c210:	00801804 	movi	r2,96
8113c214:	00002806 	br	8113c2b8 <OSMemPut+0xd0>
    }
    if (pblk == (void *)0) {                     /* Must release a valid block                         */
8113c218:	e0bfff17 	ldw	r2,-4(fp)
8113c21c:	1000021e 	bne	r2,zero,8113c228 <OSMemPut+0x40>
        return (OS_ERR_MEM_INVALID_PBLK);
8113c220:	008017c4 	movi	r2,95
8113c224:	00002406 	br	8113c2b8 <OSMemPut+0xd0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c228:	0005303a 	rdctl	r2,status
8113c22c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c230:	e0fffd17 	ldw	r3,-12(fp)
8113c234:	00bfff84 	movi	r2,-2
8113c238:	1884703a 	and	r2,r3,r2
8113c23c:	1001703a 	wrctl	status,r2
  
  return context;
8113c240:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113c244:	e0bffa15 	stw	r2,-24(fp)
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
8113c248:	e0bffe17 	ldw	r2,-8(fp)
8113c24c:	10c00417 	ldw	r3,16(r2)
8113c250:	e0bffe17 	ldw	r2,-8(fp)
8113c254:	10800317 	ldw	r2,12(r2)
8113c258:	18800636 	bltu	r3,r2,8113c274 <OSMemPut+0x8c>
8113c25c:	e0bffa17 	ldw	r2,-24(fp)
8113c260:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c264:	e0bffb17 	ldw	r2,-20(fp)
8113c268:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_MEM_FULL);
8113c26c:	00801784 	movi	r2,94
8113c270:	00001106 	br	8113c2b8 <OSMemPut+0xd0>
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
8113c274:	e0bffe17 	ldw	r2,-8(fp)
8113c278:	10c00117 	ldw	r3,4(r2)
8113c27c:	e0bfff17 	ldw	r2,-4(fp)
8113c280:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = pblk;
8113c284:	e0bffe17 	ldw	r2,-8(fp)
8113c288:	e0ffff17 	ldw	r3,-4(fp)
8113c28c:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
8113c290:	e0bffe17 	ldw	r2,-8(fp)
8113c294:	10800417 	ldw	r2,16(r2)
8113c298:	10c00044 	addi	r3,r2,1
8113c29c:	e0bffe17 	ldw	r2,-8(fp)
8113c2a0:	10c00415 	stw	r3,16(r2)
8113c2a4:	e0bffa17 	ldw	r2,-24(fp)
8113c2a8:	e0bffc15 	stw	r2,-16(fp)
8113c2ac:	e0bffc17 	ldw	r2,-16(fp)
8113c2b0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
8113c2b4:	0005883a 	mov	r2,zero
}
8113c2b8:	e037883a 	mov	sp,fp
8113c2bc:	df000017 	ldw	fp,0(sp)
8113c2c0:	dec00104 	addi	sp,sp,4
8113c2c4:	f800283a 	ret

8113c2c8 <OSMemQuery>:
*********************************************************************************************************
*/

#if OS_MEM_QUERY_EN > 0
INT8U  OSMemQuery (OS_MEM *pmem, OS_MEM_DATA *p_mem_data)
{
8113c2c8:	defffa04 	addi	sp,sp,-24
8113c2cc:	de00012e 	bgeu	sp,et,8113c2d4 <OSMemQuery+0xc>
8113c2d0:	003b68fa 	trap	3
8113c2d4:	df000515 	stw	fp,20(sp)
8113c2d8:	df000504 	addi	fp,sp,20
8113c2dc:	e13ffe15 	stw	r4,-8(fp)
8113c2e0:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113c2e4:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
8113c2e8:	e0bffe17 	ldw	r2,-8(fp)
8113c2ec:	1000021e 	bne	r2,zero,8113c2f8 <OSMemQuery+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
8113c2f0:	00801804 	movi	r2,96
8113c2f4:	00002c06 	br	8113c3a8 <OSMemQuery+0xe0>
    }
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
8113c2f8:	e0bfff17 	ldw	r2,-4(fp)
8113c2fc:	1000021e 	bne	r2,zero,8113c308 <OSMemQuery+0x40>
        return (OS_ERR_MEM_INVALID_PDATA);
8113c300:	00801844 	movi	r2,97
8113c304:	00002806 	br	8113c3a8 <OSMemQuery+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c308:	0005303a 	rdctl	r2,status
8113c30c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c310:	e0fffc17 	ldw	r3,-16(fp)
8113c314:	00bfff84 	movi	r2,-2
8113c318:	1884703a 	and	r2,r3,r2
8113c31c:	1001703a 	wrctl	status,r2
  
  return context;
8113c320:	e0bffc17 	ldw	r2,-16(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113c324:	e0bffb15 	stw	r2,-20(fp)
    p_mem_data->OSAddr     = pmem->OSMemAddr;
8113c328:	e0bffe17 	ldw	r2,-8(fp)
8113c32c:	10c00017 	ldw	r3,0(r2)
8113c330:	e0bfff17 	ldw	r2,-4(fp)
8113c334:	10c00015 	stw	r3,0(r2)
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
8113c338:	e0bffe17 	ldw	r2,-8(fp)
8113c33c:	10c00117 	ldw	r3,4(r2)
8113c340:	e0bfff17 	ldw	r2,-4(fp)
8113c344:	10c00115 	stw	r3,4(r2)
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
8113c348:	e0bffe17 	ldw	r2,-8(fp)
8113c34c:	10c00217 	ldw	r3,8(r2)
8113c350:	e0bfff17 	ldw	r2,-4(fp)
8113c354:	10c00215 	stw	r3,8(r2)
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
8113c358:	e0bffe17 	ldw	r2,-8(fp)
8113c35c:	10c00317 	ldw	r3,12(r2)
8113c360:	e0bfff17 	ldw	r2,-4(fp)
8113c364:	10c00315 	stw	r3,12(r2)
    p_mem_data->OSNFree    = pmem->OSMemNFree;
8113c368:	e0bffe17 	ldw	r2,-8(fp)
8113c36c:	10c00417 	ldw	r3,16(r2)
8113c370:	e0bfff17 	ldw	r2,-4(fp)
8113c374:	10c00415 	stw	r3,16(r2)
8113c378:	e0bffb17 	ldw	r2,-20(fp)
8113c37c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c380:	e0bffd17 	ldw	r2,-12(fp)
8113c384:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
8113c388:	e0bfff17 	ldw	r2,-4(fp)
8113c38c:	10c00317 	ldw	r3,12(r2)
8113c390:	e0bfff17 	ldw	r2,-4(fp)
8113c394:	10800417 	ldw	r2,16(r2)
8113c398:	1887c83a 	sub	r3,r3,r2
8113c39c:	e0bfff17 	ldw	r2,-4(fp)
8113c3a0:	10c00515 	stw	r3,20(r2)
    return (OS_ERR_NONE);
8113c3a4:	0005883a 	mov	r2,zero
}
8113c3a8:	e037883a 	mov	sp,fp
8113c3ac:	df000017 	ldw	fp,0(sp)
8113c3b0:	dec00104 	addi	sp,sp,4
8113c3b4:	f800283a 	ret

8113c3b8 <OS_MemInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_MemInit (void)
{
8113c3b8:	defffc04 	addi	sp,sp,-16
8113c3bc:	de00012e 	bgeu	sp,et,8113c3c4 <OS_MemInit+0xc>
8113c3c0:	003b68fa 	trap	3
8113c3c4:	dfc00315 	stw	ra,12(sp)
8113c3c8:	df000215 	stw	fp,8(sp)
8113c3cc:	df000204 	addi	fp,sp,8
#if OS_MAX_MEM_PART >= 2
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
8113c3d0:	01430c04 	movi	r5,3120
8113c3d4:	012045b4 	movhi	r4,33046
8113c3d8:	211e9f04 	addi	r4,r4,31356
8113c3dc:	1139b9c0 	call	81139b9c <OS_MemClr>
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
8113c3e0:	00a045b4 	movhi	r2,33046
8113c3e4:	109e9f04 	addi	r2,r2,31356
8113c3e8:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
8113c3ec:	e03fff0d 	sth	zero,-4(fp)
8113c3f0:	00001306 	br	8113c440 <OS_MemInit+0x88>
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
8113c3f4:	e0bfff0b 	ldhu	r2,-4(fp)
8113c3f8:	10800044 	addi	r2,r2,1
8113c3fc:	10c00d24 	muli	r3,r2,52
8113c400:	00a045b4 	movhi	r2,33046
8113c404:	109e9f04 	addi	r2,r2,31356
8113c408:	1887883a 	add	r3,r3,r2
8113c40c:	e0bffe17 	ldw	r2,-8(fp)
8113c410:	10c00115 	stw	r3,4(r2)
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
8113c414:	e0bffe17 	ldw	r2,-8(fp)
8113c418:	00c00fc4 	movi	r3,63
8113c41c:	10c00505 	stb	r3,20(r2)
        pmem->OSMemName[1]  = OS_ASCII_NUL;
8113c420:	e0bffe17 	ldw	r2,-8(fp)
8113c424:	10000545 	stb	zero,21(r2)
#endif
        pmem++;
8113c428:	e0bffe17 	ldw	r2,-8(fp)
8113c42c:	10800d04 	addi	r2,r2,52
8113c430:	e0bffe15 	stw	r2,-8(fp)
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
8113c434:	e0bfff0b 	ldhu	r2,-4(fp)
8113c438:	10800044 	addi	r2,r2,1
8113c43c:	e0bfff0d 	sth	r2,-4(fp)
8113c440:	e0bfff0b 	ldhu	r2,-4(fp)
8113c444:	10800ef0 	cmpltui	r2,r2,59
8113c448:	103fea1e 	bne	r2,zero,8113c3f4 <__reset+0xfb11c3f4>
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
        pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
8113c44c:	e0bffe17 	ldw	r2,-8(fp)
8113c450:	10000115 	stw	zero,4(r2)
#if OS_MEM_NAME_SIZE > 1
    pmem->OSMemName[0]  = '?';                            /* Unknown name                              */
8113c454:	e0bffe17 	ldw	r2,-8(fp)
8113c458:	00c00fc4 	movi	r3,63
8113c45c:	10c00505 	stb	r3,20(r2)
    pmem->OSMemName[1]  = OS_ASCII_NUL;
8113c460:	e0bffe17 	ldw	r2,-8(fp)
8113c464:	10000545 	stb	zero,21(r2)
#endif

    OSMemFreeList       = &OSMemTbl[0];                   /* Point to beginning of free list           */
8113c468:	00a045b4 	movhi	r2,33046
8113c46c:	109e9f04 	addi	r2,r2,31356
8113c470:	d0a09b15 	stw	r2,-32148(gp)
#endif
}
8113c474:	0001883a 	nop
8113c478:	e037883a 	mov	sp,fp
8113c47c:	dfc00117 	ldw	ra,4(sp)
8113c480:	df000017 	ldw	fp,0(sp)
8113c484:	dec00204 	addi	sp,sp,8
8113c488:	f800283a 	ret

8113c48c <OSMutexAccept>:
*********************************************************************************************************
*/

#if OS_MUTEX_ACCEPT_EN > 0
BOOLEAN  OSMutexAccept (OS_EVENT *pevent, INT8U *perr)
{
8113c48c:	defff704 	addi	sp,sp,-36
8113c490:	de00012e 	bgeu	sp,et,8113c498 <OSMutexAccept+0xc>
8113c494:	003b68fa 	trap	3
8113c498:	df000815 	stw	fp,32(sp)
8113c49c:	df000804 	addi	fp,sp,32
8113c4a0:	e13ffe15 	stw	r4,-8(fp)
8113c4a4:	e17fff15 	stw	r5,-4(fp)
    INT8U      pip;                                    /* Priority Inheritance Priority (PIP)          */
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113c4a8:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                          /* Validate 'perr'                              */
8113c4ac:	e0bfff17 	ldw	r2,-4(fp)
8113c4b0:	1000021e 	bne	r2,zero,8113c4bc <OSMutexAccept+0x30>
        return (OS_FALSE);
8113c4b4:	0005883a 	mov	r2,zero
8113c4b8:	00005b06 	br	8113c628 <OSMutexAccept+0x19c>
    }
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
8113c4bc:	e0bffe17 	ldw	r2,-8(fp)
8113c4c0:	1000051e 	bne	r2,zero,8113c4d8 <OSMutexAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113c4c4:	e0bfff17 	ldw	r2,-4(fp)
8113c4c8:	00c00104 	movi	r3,4
8113c4cc:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113c4d0:	0005883a 	mov	r2,zero
8113c4d4:	00005406 	br	8113c628 <OSMutexAccept+0x19c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
8113c4d8:	e0bffe17 	ldw	r2,-8(fp)
8113c4dc:	10800003 	ldbu	r2,0(r2)
8113c4e0:	10803fcc 	andi	r2,r2,255
8113c4e4:	10800120 	cmpeqi	r2,r2,4
8113c4e8:	1000051e 	bne	r2,zero,8113c500 <OSMutexAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
8113c4ec:	e0bfff17 	ldw	r2,-4(fp)
8113c4f0:	00c00044 	movi	r3,1
8113c4f4:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113c4f8:	0005883a 	mov	r2,zero
8113c4fc:	00004a06 	br	8113c628 <OSMutexAccept+0x19c>
    }
    if (OSIntNesting > 0) {                            /* Make sure it's not called from an ISR        */
8113c500:	d0a0a103 	ldbu	r2,-32124(gp)
8113c504:	10803fcc 	andi	r2,r2,255
8113c508:	10000526 	beq	r2,zero,8113c520 <OSMutexAccept+0x94>
        *perr = OS_ERR_PEND_ISR;
8113c50c:	e0bfff17 	ldw	r2,-4(fp)
8113c510:	00c00084 	movi	r3,2
8113c514:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113c518:	0005883a 	mov	r2,zero
8113c51c:	00004206 	br	8113c628 <OSMutexAccept+0x19c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c520:	0005303a 	rdctl	r2,status
8113c524:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c528:	e0fffd17 	ldw	r3,-12(fp)
8113c52c:	00bfff84 	movi	r2,-2
8113c530:	1884703a 	and	r2,r3,r2
8113c534:	1001703a 	wrctl	status,r2
  
  return context;
8113c538:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
8113c53c:	e0bff815 	stw	r2,-32(fp)
    pip = (INT8U)(pevent->OSEventCnt >> 8);            /* Get PIP from mutex                           */
8113c540:	e0bffe17 	ldw	r2,-8(fp)
8113c544:	1080020b 	ldhu	r2,8(r2)
8113c548:	10bfffcc 	andi	r2,r2,65535
8113c54c:	1004d23a 	srli	r2,r2,8
8113c550:	e0bffa05 	stb	r2,-24(fp)
    if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
8113c554:	e0bffe17 	ldw	r2,-8(fp)
8113c558:	1080020b 	ldhu	r2,8(r2)
8113c55c:	10bfffcc 	andi	r2,r2,65535
8113c560:	10803fcc 	andi	r2,r2,255
8113c564:	10803fd8 	cmpnei	r2,r2,255
8113c568:	1000281e 	bne	r2,zero,8113c60c <OSMutexAccept+0x180>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
8113c56c:	e0bffe17 	ldw	r2,-8(fp)
8113c570:	10c0020b 	ldhu	r3,8(r2)
8113c574:	00bfc004 	movi	r2,-256
8113c578:	1884703a 	and	r2,r3,r2
8113c57c:	1007883a 	mov	r3,r2
8113c580:	e0bffe17 	ldw	r2,-8(fp)
8113c584:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
8113c588:	e0bffe17 	ldw	r2,-8(fp)
8113c58c:	10c0020b 	ldhu	r3,8(r2)
8113c590:	d0a0a217 	ldw	r2,-32120(gp)
8113c594:	10800c83 	ldbu	r2,50(r2)
8113c598:	10803fcc 	andi	r2,r2,255
8113c59c:	1884b03a 	or	r2,r3,r2
8113c5a0:	1007883a 	mov	r3,r2
8113c5a4:	e0bffe17 	ldw	r2,-8(fp)
8113c5a8:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex           */
8113c5ac:	d0e0a217 	ldw	r3,-32120(gp)
8113c5b0:	e0bffe17 	ldw	r2,-8(fp)
8113c5b4:	10c00115 	stw	r3,4(r2)
        if (OSTCBCur->OSTCBPrio <= pip) {              /*      PIP 'must' have a SMALLER prio ...      */
8113c5b8:	d0a0a217 	ldw	r2,-32120(gp)
8113c5bc:	10800c83 	ldbu	r2,50(r2)
8113c5c0:	10803fcc 	andi	r2,r2,255
8113c5c4:	e0fffa03 	ldbu	r3,-24(fp)
8113c5c8:	18800836 	bltu	r3,r2,8113c5ec <OSMutexAccept+0x160>
8113c5cc:	e0bff817 	ldw	r2,-32(fp)
8113c5d0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c5d4:	e0bff917 	ldw	r2,-28(fp)
8113c5d8:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                        /*      ... than current task!                  */
            *perr = OS_ERR_PIP_LOWER;
8113c5dc:	e0bfff17 	ldw	r2,-4(fp)
8113c5e0:	00c01e04 	movi	r3,120
8113c5e4:	10c00005 	stb	r3,0(r2)
8113c5e8:	00000606 	br	8113c604 <OSMutexAccept+0x178>
8113c5ec:	e0bff817 	ldw	r2,-32(fp)
8113c5f0:	e0bffb15 	stw	r2,-20(fp)
8113c5f4:	e0bffb17 	ldw	r2,-20(fp)
8113c5f8:	1001703a 	wrctl	status,r2
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
8113c5fc:	e0bfff17 	ldw	r2,-4(fp)
8113c600:	10000005 	stb	zero,0(r2)
        }
        return (OS_TRUE);
8113c604:	00800044 	movi	r2,1
8113c608:	00000706 	br	8113c628 <OSMutexAccept+0x19c>
8113c60c:	e0bff817 	ldw	r2,-32(fp)
8113c610:	e0bffc15 	stw	r2,-16(fp)
8113c614:	e0bffc17 	ldw	r2,-16(fp)
8113c618:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113c61c:	e0bfff17 	ldw	r2,-4(fp)
8113c620:	10000005 	stb	zero,0(r2)
    return (OS_FALSE);
8113c624:	0005883a 	mov	r2,zero
}
8113c628:	e037883a 	mov	sp,fp
8113c62c:	df000017 	ldw	fp,0(sp)
8113c630:	dec00104 	addi	sp,sp,4
8113c634:	f800283a 	ret

8113c638 <OSMutexCreate>:
*                 to use to reduce priority inversion.
*********************************************************************************************************
*/

OS_EVENT  *OSMutexCreate (INT8U prio, INT8U *perr)
{
8113c638:	defff604 	addi	sp,sp,-40
8113c63c:	de00012e 	bgeu	sp,et,8113c644 <OSMutexCreate+0xc>
8113c640:	003b68fa 	trap	3
8113c644:	dfc00915 	stw	ra,36(sp)
8113c648:	df000815 	stw	fp,32(sp)
8113c64c:	df000804 	addi	fp,sp,32
8113c650:	2005883a 	mov	r2,r4
8113c654:	e17fff15 	stw	r5,-4(fp)
8113c658:	e0bffe05 	stb	r2,-8(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113c65c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113c660:	e0bfff17 	ldw	r2,-4(fp)
8113c664:	1000021e 	bne	r2,zero,8113c670 <OSMutexCreate+0x38>
        return ((OS_EVENT *)0);
8113c668:	0005883a 	mov	r2,zero
8113c66c:	00006106 	br	8113c7f4 <OSMutexCreate+0x1bc>
    }
    if (prio >= OS_LOWEST_PRIO) {                          /* Validate PIP                             */
8113c670:	e0bffe03 	ldbu	r2,-8(fp)
8113c674:	10800ab0 	cmpltui	r2,r2,42
8113c678:	1000051e 	bne	r2,zero,8113c690 <OSMutexCreate+0x58>
        *perr = OS_ERR_PRIO_INVALID;
8113c67c:	e0bfff17 	ldw	r2,-4(fp)
8113c680:	00c00a84 	movi	r3,42
8113c684:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
8113c688:	0005883a 	mov	r2,zero
8113c68c:	00005906 	br	8113c7f4 <OSMutexCreate+0x1bc>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113c690:	d0a0a103 	ldbu	r2,-32124(gp)
8113c694:	10803fcc 	andi	r2,r2,255
8113c698:	10000526 	beq	r2,zero,8113c6b0 <OSMutexCreate+0x78>
        *perr = OS_ERR_CREATE_ISR;                         /* ... can't CREATE mutex from an ISR       */
8113c69c:	e0bfff17 	ldw	r2,-4(fp)
8113c6a0:	00c00404 	movi	r3,16
8113c6a4:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
8113c6a8:	0005883a 	mov	r2,zero
8113c6ac:	00005106 	br	8113c7f4 <OSMutexCreate+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c6b0:	0005303a 	rdctl	r2,status
8113c6b4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c6b8:	e0fffd17 	ldw	r3,-12(fp)
8113c6bc:	00bfff84 	movi	r2,-2
8113c6c0:	1884703a 	and	r2,r3,r2
8113c6c4:	1001703a 	wrctl	status,r2
  
  return context;
8113c6c8:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113c6cc:	e0bff815 	stw	r2,-32(fp)
    if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {               /* Mutex priority must not already exist    */
8113c6d0:	e0fffe03 	ldbu	r3,-8(fp)
8113c6d4:	00a045f4 	movhi	r2,33047
8113c6d8:	10b41904 	addi	r2,r2,-12188
8113c6dc:	18c7883a 	add	r3,r3,r3
8113c6e0:	18c7883a 	add	r3,r3,r3
8113c6e4:	10c5883a 	add	r2,r2,r3
8113c6e8:	10800017 	ldw	r2,0(r2)
8113c6ec:	10000926 	beq	r2,zero,8113c714 <OSMutexCreate+0xdc>
8113c6f0:	e0bff817 	ldw	r2,-32(fp)
8113c6f4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c6f8:	e0bff917 	ldw	r2,-28(fp)
8113c6fc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                /* Task already exist at priority ...       */
        *perr = OS_ERR_PRIO_EXIST;                         /* ... inheritance priority                 */
8113c700:	e0bfff17 	ldw	r2,-4(fp)
8113c704:	00c00a04 	movi	r3,40
8113c708:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
8113c70c:	0005883a 	mov	r2,zero
8113c710:	00003806 	br	8113c7f4 <OSMutexCreate+0x1bc>
    }
    OSTCBPrioTbl[prio] = OS_TCB_RESERVED;                  /* Reserve the table entry                  */
8113c714:	e0fffe03 	ldbu	r3,-8(fp)
8113c718:	00a045f4 	movhi	r2,33047
8113c71c:	10b41904 	addi	r2,r2,-12188
8113c720:	18c7883a 	add	r3,r3,r3
8113c724:	18c7883a 	add	r3,r3,r3
8113c728:	10c5883a 	add	r2,r2,r3
8113c72c:	00c00044 	movi	r3,1
8113c730:	10c00015 	stw	r3,0(r2)
    pevent             = OSEventFreeList;                  /* Get next free event control block        */
8113c734:	d0a0a017 	ldw	r2,-32128(gp)
8113c738:	e0bffb15 	stw	r2,-20(fp)
    if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available              */
8113c73c:	e0bffb17 	ldw	r2,-20(fp)
8113c740:	1000101e 	bne	r2,zero,8113c784 <OSMutexCreate+0x14c>
        OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* No, Release the table entry              */
8113c744:	e0fffe03 	ldbu	r3,-8(fp)
8113c748:	00a045f4 	movhi	r2,33047
8113c74c:	10b41904 	addi	r2,r2,-12188
8113c750:	18c7883a 	add	r3,r3,r3
8113c754:	18c7883a 	add	r3,r3,r3
8113c758:	10c5883a 	add	r2,r2,r3
8113c75c:	10000015 	stw	zero,0(r2)
8113c760:	e0bff817 	ldw	r2,-32(fp)
8113c764:	e0bffa15 	stw	r2,-24(fp)
8113c768:	e0bffa17 	ldw	r2,-24(fp)
8113c76c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr              = OS_ERR_PEVENT_NULL;           /* No more event control blocks             */
8113c770:	e0bfff17 	ldw	r2,-4(fp)
8113c774:	00c00104 	movi	r3,4
8113c778:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113c77c:	e0bffb17 	ldw	r2,-20(fp)
8113c780:	00001c06 	br	8113c7f4 <OSMutexCreate+0x1bc>
    }
    OSEventFreeList        = (OS_EVENT *)OSEventFreeList->OSEventPtr;   /* Adjust the free list        */
8113c784:	d0a0a017 	ldw	r2,-32128(gp)
8113c788:	10800117 	ldw	r2,4(r2)
8113c78c:	d0a0a015 	stw	r2,-32128(gp)
8113c790:	e0bff817 	ldw	r2,-32(fp)
8113c794:	e0bffc15 	stw	r2,-16(fp)
8113c798:	e0bffc17 	ldw	r2,-16(fp)
8113c79c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    pevent->OSEventType    = OS_EVENT_TYPE_MUTEX;
8113c7a0:	e0bffb17 	ldw	r2,-20(fp)
8113c7a4:	00c00104 	movi	r3,4
8113c7a8:	10c00005 	stb	r3,0(r2)
    pevent->OSEventCnt     = (INT16U)((INT16U)prio << 8) | OS_MUTEX_AVAILABLE; /* Resource is avail.   */
8113c7ac:	e0bffe03 	ldbu	r2,-8(fp)
8113c7b0:	1004923a 	slli	r2,r2,8
8113c7b4:	10803fd4 	ori	r2,r2,255
8113c7b8:	1007883a 	mov	r3,r2
8113c7bc:	e0bffb17 	ldw	r2,-20(fp)
8113c7c0:	10c0020d 	sth	r3,8(r2)
    pevent->OSEventPtr     = (void *)0;                                 /* No task owning the mutex    */
8113c7c4:	e0bffb17 	ldw	r2,-20(fp)
8113c7c8:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent->OSEventName[0] = '?';
8113c7cc:	e0bffb17 	ldw	r2,-20(fp)
8113c7d0:	00c00fc4 	movi	r3,63
8113c7d4:	10c00445 	stb	r3,17(r2)
    pevent->OSEventName[1] = OS_ASCII_NUL;
8113c7d8:	e0bffb17 	ldw	r2,-20(fp)
8113c7dc:	10000485 	stb	zero,18(r2)
#endif
    OS_EventWaitListInit(pevent);
8113c7e0:	e13ffb17 	ldw	r4,-20(fp)
8113c7e4:	11397840 	call	81139784 <OS_EventWaitListInit>
    *perr                  = OS_ERR_NONE;
8113c7e8:	e0bfff17 	ldw	r2,-4(fp)
8113c7ec:	10000005 	stb	zero,0(r2)
    return (pevent);
8113c7f0:	e0bffb17 	ldw	r2,-20(fp)
}
8113c7f4:	e037883a 	mov	sp,fp
8113c7f8:	dfc00117 	ldw	ra,4(sp)
8113c7fc:	df000017 	ldw	fp,0(sp)
8113c800:	dec00204 	addi	sp,sp,8
8113c804:	f800283a 	ret

8113c808 <OSMutexDel>:
*********************************************************************************************************
*/

#if OS_MUTEX_DEL_EN
OS_EVENT  *OSMutexDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113c808:	defff004 	addi	sp,sp,-64
8113c80c:	de00012e 	bgeu	sp,et,8113c814 <OSMutexDel+0xc>
8113c810:	003b68fa 	trap	3
8113c814:	dfc00f15 	stw	ra,60(sp)
8113c818:	df000e15 	stw	fp,56(sp)
8113c81c:	df000e04 	addi	fp,sp,56
8113c820:	e13ffd15 	stw	r4,-12(fp)
8113c824:	2805883a 	mov	r2,r5
8113c828:	e1bfff15 	stw	r6,-4(fp)
8113c82c:	e0bffe05 	stb	r2,-8(fp)
    OS_EVENT  *pevent_return;
    INT8U      pip;                                        /* Priority inheritance priority            */
    INT8U      prio;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113c830:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113c834:	e0bfff17 	ldw	r2,-4(fp)
8113c838:	1000021e 	bne	r2,zero,8113c844 <OSMutexDel+0x3c>
        return (pevent);
8113c83c:	e0bffd17 	ldw	r2,-12(fp)
8113c840:	0000ad06 	br	8113caf8 <OSMutexDel+0x2f0>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113c844:	e0bffd17 	ldw	r2,-12(fp)
8113c848:	1000051e 	bne	r2,zero,8113c860 <OSMutexDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113c84c:	e0bfff17 	ldw	r2,-4(fp)
8113c850:	00c00104 	movi	r3,4
8113c854:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113c858:	e0bffd17 	ldw	r2,-12(fp)
8113c85c:	0000a606 	br	8113caf8 <OSMutexDel+0x2f0>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
8113c860:	e0bffd17 	ldw	r2,-12(fp)
8113c864:	10800003 	ldbu	r2,0(r2)
8113c868:	10803fcc 	andi	r2,r2,255
8113c86c:	10800120 	cmpeqi	r2,r2,4
8113c870:	1000051e 	bne	r2,zero,8113c888 <OSMutexDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113c874:	e0bfff17 	ldw	r2,-4(fp)
8113c878:	00c00044 	movi	r3,1
8113c87c:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113c880:	e0bffd17 	ldw	r2,-12(fp)
8113c884:	00009c06 	br	8113caf8 <OSMutexDel+0x2f0>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113c888:	d0a0a103 	ldbu	r2,-32124(gp)
8113c88c:	10803fcc 	andi	r2,r2,255
8113c890:	10000526 	beq	r2,zero,8113c8a8 <OSMutexDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
8113c894:	e0bfff17 	ldw	r2,-4(fp)
8113c898:	00c003c4 	movi	r3,15
8113c89c:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113c8a0:	e0bffd17 	ldw	r2,-12(fp)
8113c8a4:	00009406 	br	8113caf8 <OSMutexDel+0x2f0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c8a8:	0005303a 	rdctl	r2,status
8113c8ac:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c8b0:	e0fffc17 	ldw	r3,-16(fp)
8113c8b4:	00bfff84 	movi	r2,-2
8113c8b8:	1884703a 	and	r2,r3,r2
8113c8bc:	1001703a 	wrctl	status,r2
  
  return context;
8113c8c0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113c8c4:	e0bff415 	stw	r2,-48(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on mutex        */
8113c8c8:	e0bffd17 	ldw	r2,-12(fp)
8113c8cc:	10800283 	ldbu	r2,10(r2)
8113c8d0:	10803fcc 	andi	r2,r2,255
8113c8d4:	10000326 	beq	r2,zero,8113c8e4 <OSMutexDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8113c8d8:	00800044 	movi	r2,1
8113c8dc:	e0bff205 	stb	r2,-56(fp)
8113c8e0:	00000106 	br	8113c8e8 <OSMutexDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8113c8e4:	e03ff205 	stb	zero,-56(fp)
    }
    switch (opt) {
8113c8e8:	e0bffe03 	ldbu	r2,-8(fp)
8113c8ec:	10000326 	beq	r2,zero,8113c8fc <OSMutexDel+0xf4>
8113c8f0:	10800060 	cmpeqi	r2,r2,1
8113c8f4:	10002f1e 	bne	r2,zero,8113c9b4 <OSMutexDel+0x1ac>
8113c8f8:	00007406 	br	8113cacc <OSMutexDel+0x2c4>
        case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING --- */
             if (tasks_waiting == OS_FALSE) {
8113c8fc:	e0bff203 	ldbu	r2,-56(fp)
8113c900:	1000221e 	bne	r2,zero,8113c98c <OSMutexDel+0x184>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
8113c904:	e0bffd17 	ldw	r2,-12(fp)
8113c908:	00c00fc4 	movi	r3,63
8113c90c:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
8113c910:	e0bffd17 	ldw	r2,-12(fp)
8113c914:	10000485 	stb	zero,18(r2)
#endif
                 pip                 = (INT8U)(pevent->OSEventCnt >> 8);
8113c918:	e0bffd17 	ldw	r2,-12(fp)
8113c91c:	1080020b 	ldhu	r2,8(r2)
8113c920:	10bfffcc 	andi	r2,r2,65535
8113c924:	1004d23a 	srli	r2,r2,8
8113c928:	e0bff605 	stb	r2,-40(fp)
                 OSTCBPrioTbl[pip]   = (OS_TCB *)0;        /* Free up the PIP                          */
8113c92c:	e0fff603 	ldbu	r3,-40(fp)
8113c930:	00a045f4 	movhi	r2,33047
8113c934:	10b41904 	addi	r2,r2,-12188
8113c938:	18c7883a 	add	r3,r3,r3
8113c93c:	18c7883a 	add	r3,r3,r3
8113c940:	10c5883a 	add	r2,r2,r3
8113c944:	10000015 	stw	zero,0(r2)
                 pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
8113c948:	e0bffd17 	ldw	r2,-12(fp)
8113c94c:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
8113c950:	d0e0a017 	ldw	r3,-32128(gp)
8113c954:	e0bffd17 	ldw	r2,-12(fp)
8113c958:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt  = 0;
8113c95c:	e0bffd17 	ldw	r2,-12(fp)
8113c960:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList     = pevent;
8113c964:	e0bffd17 	ldw	r2,-12(fp)
8113c968:	d0a0a015 	stw	r2,-32128(gp)
8113c96c:	e0bff417 	ldw	r2,-48(fp)
8113c970:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c974:	e0bff517 	ldw	r2,-44(fp)
8113c978:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
8113c97c:	e0bfff17 	ldw	r2,-4(fp)
8113c980:	10000005 	stb	zero,0(r2)
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
8113c984:	e03ff315 	stw	zero,-52(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
                 pevent_return       = pevent;
             }
             break;
8113c988:	00005a06 	br	8113caf4 <OSMutexDel+0x2ec>
8113c98c:	e0bff417 	ldw	r2,-48(fp)
8113c990:	e0bff715 	stw	r2,-36(fp)
8113c994:	e0bff717 	ldw	r2,-36(fp)
8113c998:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
8113c99c:	e0bfff17 	ldw	r2,-4(fp)
8113c9a0:	00c01244 	movi	r3,73
8113c9a4:	10c00005 	stb	r3,0(r2)
                 pevent_return       = pevent;
8113c9a8:	e0bffd17 	ldw	r2,-12(fp)
8113c9ac:	e0bff315 	stw	r2,-52(fp)
             }
             break;
8113c9b0:	00005006 	br	8113caf4 <OSMutexDel+0x2ec>

        case OS_DEL_ALWAYS:                                /* ALWAYS DELETE THE MUTEX ---------------- */
             pip  = (INT8U)(pevent->OSEventCnt >> 8);                     /* Get PIP of mutex          */
8113c9b4:	e0bffd17 	ldw	r2,-12(fp)
8113c9b8:	1080020b 	ldhu	r2,8(r2)
8113c9bc:	10bfffcc 	andi	r2,r2,65535
8113c9c0:	1004d23a 	srli	r2,r2,8
8113c9c4:	e0bff605 	stb	r2,-40(fp)
             prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original prio */
8113c9c8:	e0bffd17 	ldw	r2,-12(fp)
8113c9cc:	1080020b 	ldhu	r2,8(r2)
8113c9d0:	e0bff905 	stb	r2,-28(fp)
             ptcb = (OS_TCB *)pevent->OSEventPtr;
8113c9d4:	e0bffd17 	ldw	r2,-12(fp)
8113c9d8:	10800117 	ldw	r2,4(r2)
8113c9dc:	e0bffa15 	stw	r2,-24(fp)
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
8113c9e0:	e0bffa17 	ldw	r2,-24(fp)
8113c9e4:	10000f26 	beq	r2,zero,8113ca24 <OSMutexDel+0x21c>
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
8113c9e8:	e0bffa17 	ldw	r2,-24(fp)
8113c9ec:	10800c83 	ldbu	r2,50(r2)
8113c9f0:	10c03fcc 	andi	r3,r2,255
8113c9f4:	e0bff603 	ldbu	r2,-40(fp)
8113c9f8:	18800a1e 	bne	r3,r2,8113ca24 <OSMutexDel+0x21c>
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
8113c9fc:	e0bff903 	ldbu	r2,-28(fp)
8113ca00:	100b883a 	mov	r5,r2
8113ca04:	e13ffa17 	ldw	r4,-24(fp)
8113ca08:	113d4440 	call	8113d444 <OSMutex_RdyAtPrio>
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
8113ca0c:	00000506 	br	8113ca24 <OSMutexDel+0x21c>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
8113ca10:	000f883a 	mov	r7,zero
8113ca14:	01800404 	movi	r6,16
8113ca18:	000b883a 	mov	r5,zero
8113ca1c:	e13ffd17 	ldw	r4,-12(fp)
8113ca20:	11391ac0 	call	811391ac <OS_EventTaskRdy>
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
8113ca24:	e0bffd17 	ldw	r2,-12(fp)
8113ca28:	10800283 	ldbu	r2,10(r2)
8113ca2c:	10803fcc 	andi	r2,r2,255
8113ca30:	103ff71e 	bne	r2,zero,8113ca10 <__reset+0xfb11ca10>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
8113ca34:	e0bffd17 	ldw	r2,-12(fp)
8113ca38:	00c00fc4 	movi	r3,63
8113ca3c:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
8113ca40:	e0bffd17 	ldw	r2,-12(fp)
8113ca44:	10000485 	stb	zero,18(r2)
#endif
             pip                 = (INT8U)(pevent->OSEventCnt >> 8);
8113ca48:	e0bffd17 	ldw	r2,-12(fp)
8113ca4c:	1080020b 	ldhu	r2,8(r2)
8113ca50:	10bfffcc 	andi	r2,r2,65535
8113ca54:	1004d23a 	srli	r2,r2,8
8113ca58:	e0bff605 	stb	r2,-40(fp)
             OSTCBPrioTbl[pip]   = (OS_TCB *)0;            /* Free up the PIP                          */
8113ca5c:	e0fff603 	ldbu	r3,-40(fp)
8113ca60:	00a045f4 	movhi	r2,33047
8113ca64:	10b41904 	addi	r2,r2,-12188
8113ca68:	18c7883a 	add	r3,r3,r3
8113ca6c:	18c7883a 	add	r3,r3,r3
8113ca70:	10c5883a 	add	r2,r2,r3
8113ca74:	10000015 	stw	zero,0(r2)
             pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
8113ca78:	e0bffd17 	ldw	r2,-12(fp)
8113ca7c:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr  = OSEventFreeList;        /* Return Event Control Block to free list  */
8113ca80:	d0e0a017 	ldw	r3,-32128(gp)
8113ca84:	e0bffd17 	ldw	r2,-12(fp)
8113ca88:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt  = 0;
8113ca8c:	e0bffd17 	ldw	r2,-12(fp)
8113ca90:	1000020d 	sth	zero,8(r2)
             OSEventFreeList     = pevent;                 /* Get next free event control block        */
8113ca94:	e0bffd17 	ldw	r2,-12(fp)
8113ca98:	d0a0a015 	stw	r2,-32128(gp)
8113ca9c:	e0bff417 	ldw	r2,-48(fp)
8113caa0:	e0bff815 	stw	r2,-32(fp)
8113caa4:	e0bff817 	ldw	r2,-32(fp)
8113caa8:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8113caac:	e0bff203 	ldbu	r2,-56(fp)
8113cab0:	10800058 	cmpnei	r2,r2,1
8113cab4:	1000011e 	bne	r2,zero,8113cabc <OSMutexDel+0x2b4>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8113cab8:	1139c680 	call	81139c68 <OS_Sched>
             }
             *perr         = OS_ERR_NONE;
8113cabc:	e0bfff17 	ldw	r2,-4(fp)
8113cac0:	10000005 	stb	zero,0(r2)
             pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted                   */
8113cac4:	e03ff315 	stw	zero,-52(fp)
             break;
8113cac8:	00000a06 	br	8113caf4 <OSMutexDel+0x2ec>
8113cacc:	e0bff417 	ldw	r2,-48(fp)
8113cad0:	e0bffb15 	stw	r2,-20(fp)
8113cad4:	e0bffb17 	ldw	r2,-20(fp)
8113cad8:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr         = OS_ERR_INVALID_OPT;
8113cadc:	e0bfff17 	ldw	r2,-4(fp)
8113cae0:	00c001c4 	movi	r3,7
8113cae4:	10c00005 	stb	r3,0(r2)
             pevent_return = pevent;
8113cae8:	e0bffd17 	ldw	r2,-12(fp)
8113caec:	e0bff315 	stw	r2,-52(fp)
             break;
8113caf0:	0001883a 	nop
    }
    return (pevent_return);
8113caf4:	e0bff317 	ldw	r2,-52(fp)
}
8113caf8:	e037883a 	mov	sp,fp
8113cafc:	dfc00117 	ldw	ra,4(sp)
8113cb00:	df000017 	ldw	fp,0(sp)
8113cb04:	dec00204 	addi	sp,sp,8
8113cb08:	f800283a 	ret

8113cb0c <OSMutexPend>:
*              2) You MUST NOT change the priority of the task that owns the mutex
*********************************************************************************************************
*/

void  OSMutexPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
8113cb0c:	deffee04 	addi	sp,sp,-72
8113cb10:	de00012e 	bgeu	sp,et,8113cb18 <OSMutexPend+0xc>
8113cb14:	003b68fa 	trap	3
8113cb18:	dfc01115 	stw	ra,68(sp)
8113cb1c:	df001015 	stw	fp,64(sp)
8113cb20:	df001004 	addi	fp,sp,64
8113cb24:	e13ffd15 	stw	r4,-12(fp)
8113cb28:	2805883a 	mov	r2,r5
8113cb2c:	e1bfff15 	stw	r6,-4(fp)
8113cb30:	e0bffe0d 	sth	r2,-8(fp)
    BOOLEAN    rdy;                                        /* Flag indicating task was ready           */
    OS_TCB    *ptcb;
    OS_EVENT  *pevent2;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113cb34:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113cb38:	e0bfff17 	ldw	r2,-4(fp)
8113cb3c:	10015626 	beq	r2,zero,8113d098 <OSMutexPend+0x58c>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113cb40:	e0bffd17 	ldw	r2,-12(fp)
8113cb44:	1000041e 	bne	r2,zero,8113cb58 <OSMutexPend+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113cb48:	e0bfff17 	ldw	r2,-4(fp)
8113cb4c:	00c00104 	movi	r3,4
8113cb50:	10c00005 	stb	r3,0(r2)
        return;
8113cb54:	00015106 	br	8113d09c <OSMutexPend+0x590>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
8113cb58:	e0bffd17 	ldw	r2,-12(fp)
8113cb5c:	10800003 	ldbu	r2,0(r2)
8113cb60:	10803fcc 	andi	r2,r2,255
8113cb64:	10800120 	cmpeqi	r2,r2,4
8113cb68:	1000041e 	bne	r2,zero,8113cb7c <OSMutexPend+0x70>
        *perr = OS_ERR_EVENT_TYPE;
8113cb6c:	e0bfff17 	ldw	r2,-4(fp)
8113cb70:	00c00044 	movi	r3,1
8113cb74:	10c00005 	stb	r3,0(r2)
        return;
8113cb78:	00014806 	br	8113d09c <OSMutexPend+0x590>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113cb7c:	d0a0a103 	ldbu	r2,-32124(gp)
8113cb80:	10803fcc 	andi	r2,r2,255
8113cb84:	10000426 	beq	r2,zero,8113cb98 <OSMutexPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
8113cb88:	e0bfff17 	ldw	r2,-4(fp)
8113cb8c:	00c00084 	movi	r3,2
8113cb90:	10c00005 	stb	r3,0(r2)
        return;
8113cb94:	00014106 	br	8113d09c <OSMutexPend+0x590>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
8113cb98:	d0a08f03 	ldbu	r2,-32196(gp)
8113cb9c:	10803fcc 	andi	r2,r2,255
8113cba0:	10000426 	beq	r2,zero,8113cbb4 <OSMutexPend+0xa8>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
8113cba4:	e0bfff17 	ldw	r2,-4(fp)
8113cba8:	00c00344 	movi	r3,13
8113cbac:	10c00005 	stb	r3,0(r2)
        return;
8113cbb0:	00013a06 	br	8113d09c <OSMutexPend+0x590>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113cbb4:	0005303a 	rdctl	r2,status
8113cbb8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113cbbc:	e0fffc17 	ldw	r3,-16(fp)
8113cbc0:	00bfff84 	movi	r2,-2
8113cbc4:	1884703a 	and	r2,r3,r2
8113cbc8:	1001703a 	wrctl	status,r2
  
  return context;
8113cbcc:	e0bffc17 	ldw	r2,-16(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
8113cbd0:	e0bff115 	stw	r2,-60(fp)
    pip = (INT8U)(pevent->OSEventCnt >> 8);                /* Get PIP from mutex                       */
8113cbd4:	e0bffd17 	ldw	r2,-12(fp)
8113cbd8:	1080020b 	ldhu	r2,8(r2)
8113cbdc:	10bfffcc 	andi	r2,r2,65535
8113cbe0:	1004d23a 	srli	r2,r2,8
8113cbe4:	e0bff305 	stb	r2,-52(fp)
                                                           /* Is Mutex available?                      */
    if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
8113cbe8:	e0bffd17 	ldw	r2,-12(fp)
8113cbec:	1080020b 	ldhu	r2,8(r2)
8113cbf0:	10803fcc 	andi	r2,r2,255
8113cbf4:	10803fd8 	cmpnei	r2,r2,255
8113cbf8:	1000271e 	bne	r2,zero,8113cc98 <OSMutexPend+0x18c>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
8113cbfc:	e0bffd17 	ldw	r2,-12(fp)
8113cc00:	10c0020b 	ldhu	r3,8(r2)
8113cc04:	00bfc004 	movi	r2,-256
8113cc08:	1884703a 	and	r2,r3,r2
8113cc0c:	1007883a 	mov	r3,r2
8113cc10:	e0bffd17 	ldw	r2,-12(fp)
8113cc14:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task        */
8113cc18:	e0bffd17 	ldw	r2,-12(fp)
8113cc1c:	10c0020b 	ldhu	r3,8(r2)
8113cc20:	d0a0a217 	ldw	r2,-32120(gp)
8113cc24:	10800c83 	ldbu	r2,50(r2)
8113cc28:	10803fcc 	andi	r2,r2,255
8113cc2c:	1884b03a 	or	r2,r3,r2
8113cc30:	1007883a 	mov	r3,r2
8113cc34:	e0bffd17 	ldw	r2,-12(fp)
8113cc38:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB       */
8113cc3c:	d0e0a217 	ldw	r3,-32120(gp)
8113cc40:	e0bffd17 	ldw	r2,-12(fp)
8113cc44:	10c00115 	stw	r3,4(r2)
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
8113cc48:	d0a0a217 	ldw	r2,-32120(gp)
8113cc4c:	10800c83 	ldbu	r2,50(r2)
8113cc50:	10803fcc 	andi	r2,r2,255
8113cc54:	e0fff303 	ldbu	r3,-52(fp)
8113cc58:	18800836 	bltu	r3,r2,8113cc7c <OSMutexPend+0x170>
8113cc5c:	e0bff117 	ldw	r2,-60(fp)
8113cc60:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113cc64:	e0bff217 	ldw	r2,-56(fp)
8113cc68:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
            *perr = OS_ERR_PIP_LOWER;
8113cc6c:	e0bfff17 	ldw	r2,-4(fp)
8113cc70:	00c01e04 	movi	r3,120
8113cc74:	10c00005 	stb	r3,0(r2)
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
        }
        return;
8113cc78:	00010806 	br	8113d09c <OSMutexPend+0x590>
8113cc7c:	e0bff117 	ldw	r2,-60(fp)
8113cc80:	e0bff415 	stw	r2,-48(fp)
8113cc84:	e0bff417 	ldw	r2,-48(fp)
8113cc88:	1001703a 	wrctl	status,r2
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
            *perr = OS_ERR_PIP_LOWER;
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
8113cc8c:	e0bfff17 	ldw	r2,-4(fp)
8113cc90:	10000005 	stb	zero,0(r2)
        }
        return;
8113cc94:	00010106 	br	8113d09c <OSMutexPend+0x590>
    }
    mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* No, Get priority of mutex owner   */
8113cc98:	e0bffd17 	ldw	r2,-12(fp)
8113cc9c:	1080020b 	ldhu	r2,8(r2)
8113cca0:	e0bff605 	stb	r2,-40(fp)
    ptcb  = (OS_TCB *)(pevent->OSEventPtr);                       /*     Point to TCB of mutex owner   */
8113cca4:	e0bffd17 	ldw	r2,-12(fp)
8113cca8:	10800117 	ldw	r2,4(r2)
8113ccac:	e0bff715 	stw	r2,-36(fp)
    if (ptcb->OSTCBPrio > pip) {                                  /*     Need to promote prio of owner?*/
8113ccb0:	e0bff717 	ldw	r2,-36(fp)
8113ccb4:	10800c83 	ldbu	r2,50(r2)
8113ccb8:	10803fcc 	andi	r2,r2,255
8113ccbc:	e0fff303 	ldbu	r3,-52(fp)
8113ccc0:	1880b92e 	bgeu	r3,r2,8113cfa8 <OSMutexPend+0x49c>
        if (mprio > OSTCBCur->OSTCBPrio) {
8113ccc4:	d0a0a217 	ldw	r2,-32120(gp)
8113ccc8:	10800c83 	ldbu	r2,50(r2)
8113cccc:	10c03fcc 	andi	r3,r2,255
8113ccd0:	e0bff603 	ldbu	r2,-40(fp)
8113ccd4:	1880b42e 	bgeu	r3,r2,8113cfa8 <OSMutexPend+0x49c>
            y = ptcb->OSTCBY;
8113ccd8:	e0bff717 	ldw	r2,-36(fp)
8113ccdc:	10800d03 	ldbu	r2,52(r2)
8113cce0:	e0bff805 	stb	r2,-32(fp)
            if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0) {           /*     See if mutex owner is ready   */
8113cce4:	e0fff803 	ldbu	r3,-32(fp)
8113cce8:	d0a09e44 	addi	r2,gp,-32135
8113ccec:	1885883a 	add	r2,r3,r2
8113ccf0:	10c00003 	ldbu	r3,0(r2)
8113ccf4:	e0bff717 	ldw	r2,-36(fp)
8113ccf8:	10800d43 	ldbu	r2,53(r2)
8113ccfc:	1884703a 	and	r2,r3,r2
8113cd00:	10803fcc 	andi	r2,r2,255
8113cd04:	10001e26 	beq	r2,zero,8113cd80 <OSMutexPend+0x274>
                OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                  /*     Yes, Remove owner from Rdy ...*/
8113cd08:	e0fff803 	ldbu	r3,-32(fp)
8113cd0c:	e13ff803 	ldbu	r4,-32(fp)
8113cd10:	d0a09e44 	addi	r2,gp,-32135
8113cd14:	2085883a 	add	r2,r4,r2
8113cd18:	10800003 	ldbu	r2,0(r2)
8113cd1c:	1009883a 	mov	r4,r2
8113cd20:	e0bff717 	ldw	r2,-36(fp)
8113cd24:	10800d43 	ldbu	r2,53(r2)
8113cd28:	0084303a 	nor	r2,zero,r2
8113cd2c:	2084703a 	and	r2,r4,r2
8113cd30:	1009883a 	mov	r4,r2
8113cd34:	d0a09e44 	addi	r2,gp,-32135
8113cd38:	1885883a 	add	r2,r3,r2
8113cd3c:	11000005 	stb	r4,0(r2)
                if (OSRdyTbl[y] == 0) {                           /*          ... list at current prio */
8113cd40:	e0fff803 	ldbu	r3,-32(fp)
8113cd44:	d0a09e44 	addi	r2,gp,-32135
8113cd48:	1885883a 	add	r2,r3,r2
8113cd4c:	10800003 	ldbu	r2,0(r2)
8113cd50:	10803fcc 	andi	r2,r2,255
8113cd54:	1000071e 	bne	r2,zero,8113cd74 <OSMutexPend+0x268>
                    OSRdyGrp &= ~ptcb->OSTCBBitY;
8113cd58:	e0bff717 	ldw	r2,-36(fp)
8113cd5c:	10800d83 	ldbu	r2,54(r2)
8113cd60:	0084303a 	nor	r2,zero,r2
8113cd64:	1007883a 	mov	r3,r2
8113cd68:	d0a09e03 	ldbu	r2,-32136(gp)
8113cd6c:	1884703a 	and	r2,r3,r2
8113cd70:	d0a09e05 	stb	r2,-32136(gp)
                }
                rdy = OS_TRUE;
8113cd74:	00800044 	movi	r2,1
8113cd78:	e0bff005 	stb	r2,-64(fp)
8113cd7c:	00002a06 	br	8113ce28 <OSMutexPend+0x31c>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
8113cd80:	e0bff717 	ldw	r2,-36(fp)
8113cd84:	10800717 	ldw	r2,28(r2)
8113cd88:	e0bff915 	stw	r2,-28(fp)
                if (pevent2 != (OS_EVENT *)0) {                   /* Remove from event wait list       */
8113cd8c:	e0bff917 	ldw	r2,-28(fp)
8113cd90:	10002426 	beq	r2,zero,8113ce24 <OSMutexPend+0x318>
                    if ((pevent2->OSEventTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX) == 0) {
8113cd94:	e0bff717 	ldw	r2,-36(fp)
8113cd98:	10800d03 	ldbu	r2,52(r2)
8113cd9c:	10803fcc 	andi	r2,r2,255
8113cda0:	e0fff717 	ldw	r3,-36(fp)
8113cda4:	18c00d03 	ldbu	r3,52(r3)
8113cda8:	18c03fcc 	andi	r3,r3,255
8113cdac:	e13ff917 	ldw	r4,-28(fp)
8113cdb0:	20c7883a 	add	r3,r4,r3
8113cdb4:	18c002c4 	addi	r3,r3,11
8113cdb8:	18c00003 	ldbu	r3,0(r3)
8113cdbc:	1809883a 	mov	r4,r3
8113cdc0:	e0fff717 	ldw	r3,-36(fp)
8113cdc4:	18c00d43 	ldbu	r3,53(r3)
8113cdc8:	00c6303a 	nor	r3,zero,r3
8113cdcc:	20c6703a 	and	r3,r4,r3
8113cdd0:	1809883a 	mov	r4,r3
8113cdd4:	e0fff917 	ldw	r3,-28(fp)
8113cdd8:	1887883a 	add	r3,r3,r2
8113cddc:	18c002c4 	addi	r3,r3,11
8113cde0:	19000005 	stb	r4,0(r3)
8113cde4:	e0fff917 	ldw	r3,-28(fp)
8113cde8:	1885883a 	add	r2,r3,r2
8113cdec:	108002c4 	addi	r2,r2,11
8113cdf0:	10800003 	ldbu	r2,0(r2)
8113cdf4:	10803fcc 	andi	r2,r2,255
8113cdf8:	10000a1e 	bne	r2,zero,8113ce24 <OSMutexPend+0x318>
                        pevent2->OSEventGrp &= ~ptcb->OSTCBBitY;
8113cdfc:	e0bff917 	ldw	r2,-28(fp)
8113ce00:	10800283 	ldbu	r2,10(r2)
8113ce04:	1007883a 	mov	r3,r2
8113ce08:	e0bff717 	ldw	r2,-36(fp)
8113ce0c:	10800d83 	ldbu	r2,54(r2)
8113ce10:	0084303a 	nor	r2,zero,r2
8113ce14:	1884703a 	and	r2,r3,r2
8113ce18:	1007883a 	mov	r3,r2
8113ce1c:	e0bff917 	ldw	r2,-28(fp)
8113ce20:	10c00285 	stb	r3,10(r2)
                    }
                }
                rdy = OS_FALSE;                            /* No                                       */
8113ce24:	e03ff005 	stb	zero,-64(fp)
            }
            ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
8113ce28:	e0bff717 	ldw	r2,-36(fp)
8113ce2c:	e0fff303 	ldbu	r3,-52(fp)
8113ce30:	10c00c85 	stb	r3,50(r2)
#if OS_LOWEST_PRIO <= 63
            ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3);
8113ce34:	e0bff717 	ldw	r2,-36(fp)
8113ce38:	10800c83 	ldbu	r2,50(r2)
8113ce3c:	10803fcc 	andi	r2,r2,255
8113ce40:	1004d0fa 	srli	r2,r2,3
8113ce44:	1007883a 	mov	r3,r2
8113ce48:	e0bff717 	ldw	r2,-36(fp)
8113ce4c:	10c00d05 	stb	r3,52(r2)
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07);
8113ce50:	e0bff717 	ldw	r2,-36(fp)
8113ce54:	10800c83 	ldbu	r2,50(r2)
8113ce58:	108001cc 	andi	r2,r2,7
8113ce5c:	1007883a 	mov	r3,r2
8113ce60:	e0bff717 	ldw	r2,-36(fp)
8113ce64:	10c00cc5 	stb	r3,51(r2)
            ptcb->OSTCBBitY = (INT8U)(1 << ptcb->OSTCBY);
8113ce68:	e0bff717 	ldw	r2,-36(fp)
8113ce6c:	10800d03 	ldbu	r2,52(r2)
8113ce70:	10803fcc 	andi	r2,r2,255
8113ce74:	00c00044 	movi	r3,1
8113ce78:	1884983a 	sll	r2,r3,r2
8113ce7c:	1007883a 	mov	r3,r2
8113ce80:	e0bff717 	ldw	r2,-36(fp)
8113ce84:	10c00d85 	stb	r3,54(r2)
            ptcb->OSTCBBitX = (INT8U)(1 << ptcb->OSTCBX);
8113ce88:	e0bff717 	ldw	r2,-36(fp)
8113ce8c:	10800cc3 	ldbu	r2,51(r2)
8113ce90:	10803fcc 	andi	r2,r2,255
8113ce94:	00c00044 	movi	r3,1
8113ce98:	1884983a 	sll	r2,r3,r2
8113ce9c:	1007883a 	mov	r3,r2
8113cea0:	e0bff717 	ldw	r2,-36(fp)
8113cea4:	10c00d45 	stb	r3,53(r2)
            ptcb->OSTCBY    = (INT8U)((ptcb->OSTCBPrio >> 4) & 0xFF);
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x0F);
            ptcb->OSTCBBitY = (INT16U)(1 << ptcb->OSTCBY);
            ptcb->OSTCBBitX = (INT16U)(1 << ptcb->OSTCBX);
#endif
            if (rdy == OS_TRUE) {                          /* If task was ready at owner's priority ...*/
8113cea8:	e0bff003 	ldbu	r2,-64(fp)
8113ceac:	10800058 	cmpnei	r2,r2,1
8113ceb0:	1000161e 	bne	r2,zero,8113cf0c <OSMutexPend+0x400>
                OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.       */
8113ceb4:	e0bff717 	ldw	r2,-36(fp)
8113ceb8:	10c00d83 	ldbu	r3,54(r2)
8113cebc:	d0a09e03 	ldbu	r2,-32136(gp)
8113cec0:	1884b03a 	or	r2,r3,r2
8113cec4:	d0a09e05 	stb	r2,-32136(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113cec8:	e0bff717 	ldw	r2,-36(fp)
8113cecc:	10800d03 	ldbu	r2,52(r2)
8113ced0:	10c03fcc 	andi	r3,r2,255
8113ced4:	e0bff717 	ldw	r2,-36(fp)
8113ced8:	10800d03 	ldbu	r2,52(r2)
8113cedc:	11003fcc 	andi	r4,r2,255
8113cee0:	d0a09e44 	addi	r2,gp,-32135
8113cee4:	2085883a 	add	r2,r4,r2
8113cee8:	11000003 	ldbu	r4,0(r2)
8113ceec:	e0bff717 	ldw	r2,-36(fp)
8113cef0:	10800d43 	ldbu	r2,53(r2)
8113cef4:	2084b03a 	or	r2,r4,r2
8113cef8:	1009883a 	mov	r4,r2
8113cefc:	d0a09e44 	addi	r2,gp,-32135
8113cf00:	1885883a 	add	r2,r3,r2
8113cf04:	11000005 	stb	r4,0(r2)
8113cf08:	00001f06 	br	8113cf88 <OSMutexPend+0x47c>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
8113cf0c:	e0bff717 	ldw	r2,-36(fp)
8113cf10:	10800717 	ldw	r2,28(r2)
8113cf14:	e0bff915 	stw	r2,-28(fp)
                if (pevent2 != (OS_EVENT *)0) {            /* Add to event wait list                   */
8113cf18:	e0bff917 	ldw	r2,-28(fp)
8113cf1c:	10001a26 	beq	r2,zero,8113cf88 <OSMutexPend+0x47c>
                    pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
8113cf20:	e0bff917 	ldw	r2,-28(fp)
8113cf24:	10c00283 	ldbu	r3,10(r2)
8113cf28:	e0bff717 	ldw	r2,-36(fp)
8113cf2c:	10800d83 	ldbu	r2,54(r2)
8113cf30:	1884b03a 	or	r2,r3,r2
8113cf34:	1007883a 	mov	r3,r2
8113cf38:	e0bff917 	ldw	r2,-28(fp)
8113cf3c:	10c00285 	stb	r3,10(r2)
                    pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113cf40:	e0bff717 	ldw	r2,-36(fp)
8113cf44:	10800d03 	ldbu	r2,52(r2)
8113cf48:	10803fcc 	andi	r2,r2,255
8113cf4c:	e0fff717 	ldw	r3,-36(fp)
8113cf50:	18c00d03 	ldbu	r3,52(r3)
8113cf54:	18c03fcc 	andi	r3,r3,255
8113cf58:	e13ff917 	ldw	r4,-28(fp)
8113cf5c:	20c7883a 	add	r3,r4,r3
8113cf60:	18c002c4 	addi	r3,r3,11
8113cf64:	19000003 	ldbu	r4,0(r3)
8113cf68:	e0fff717 	ldw	r3,-36(fp)
8113cf6c:	18c00d43 	ldbu	r3,53(r3)
8113cf70:	20c6b03a 	or	r3,r4,r3
8113cf74:	1809883a 	mov	r4,r3
8113cf78:	e0fff917 	ldw	r3,-28(fp)
8113cf7c:	1885883a 	add	r2,r3,r2
8113cf80:	108002c4 	addi	r2,r2,11
8113cf84:	11000005 	stb	r4,0(r2)
                }
            }
            OSTCBPrioTbl[pip] = ptcb;
8113cf88:	e0fff303 	ldbu	r3,-52(fp)
8113cf8c:	00a045f4 	movhi	r2,33047
8113cf90:	10b41904 	addi	r2,r2,-12188
8113cf94:	18c7883a 	add	r3,r3,r3
8113cf98:	18c7883a 	add	r3,r3,r3
8113cf9c:	10c5883a 	add	r2,r2,r3
8113cfa0:	e0fff717 	ldw	r3,-36(fp)
8113cfa4:	10c00015 	stw	r3,0(r2)
        }
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_MUTEX;         /* Mutex not available, pend current task        */
8113cfa8:	d0a0a217 	ldw	r2,-32120(gp)
8113cfac:	d0e0a217 	ldw	r3,-32120(gp)
8113cfb0:	18c00c03 	ldbu	r3,48(r3)
8113cfb4:	18c00414 	ori	r3,r3,16
8113cfb8:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113cfbc:	d0a0a217 	ldw	r2,-32120(gp)
8113cfc0:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store timeout in current task's TCB           */
8113cfc4:	d0a0a217 	ldw	r2,-32120(gp)
8113cfc8:	e0fffe0b 	ldhu	r3,-8(fp)
8113cfcc:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
8113cfd0:	e13ffd17 	ldw	r4,-12(fp)
8113cfd4:	113934c0 	call	8113934c <OS_EventTaskWait>
8113cfd8:	e0bff117 	ldw	r2,-60(fp)
8113cfdc:	e0bffb15 	stw	r2,-20(fp)
8113cfe0:	e0bffb17 	ldw	r2,-20(fp)
8113cfe4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
8113cfe8:	1139c680 	call	81139c68 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113cfec:	0005303a 	rdctl	r2,status
8113cff0:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113cff4:	e0fff517 	ldw	r3,-44(fp)
8113cff8:	00bfff84 	movi	r2,-2
8113cffc:	1884703a 	and	r2,r3,r2
8113d000:	1001703a 	wrctl	status,r2
  
  return context;
8113d004:	e0bff517 	ldw	r2,-44(fp)
    OS_ENTER_CRITICAL();
8113d008:	e0bff115 	stw	r2,-60(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
8113d00c:	d0a0a217 	ldw	r2,-32120(gp)
8113d010:	10800c43 	ldbu	r2,49(r2)
8113d014:	10803fcc 	andi	r2,r2,255
8113d018:	10000326 	beq	r2,zero,8113d028 <OSMutexPend+0x51c>
8113d01c:	108000a0 	cmpeqi	r2,r2,2
8113d020:	1000041e 	bne	r2,zero,8113d034 <OSMutexPend+0x528>
8113d024:	00000706 	br	8113d044 <OSMutexPend+0x538>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
8113d028:	e0bfff17 	ldw	r2,-4(fp)
8113d02c:	10000005 	stb	zero,0(r2)
             break;
8113d030:	00000c06 	br	8113d064 <OSMutexPend+0x558>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted getting mutex        */
8113d034:	e0bfff17 	ldw	r2,-4(fp)
8113d038:	00c00384 	movi	r3,14
8113d03c:	10c00005 	stb	r3,0(r2)
             break;
8113d040:	00000806 	br	8113d064 <OSMutexPend+0x558>
             
        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
8113d044:	d0a0a217 	ldw	r2,-32120(gp)
8113d048:	e17ffd17 	ldw	r5,-12(fp)
8113d04c:	1009883a 	mov	r4,r2
8113d050:	11395bc0 	call	811395bc <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get mutex within TO   */
8113d054:	e0bfff17 	ldw	r2,-4(fp)
8113d058:	00c00284 	movi	r3,10
8113d05c:	10c00005 	stb	r3,0(r2)
             break;
8113d060:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
8113d064:	d0a0a217 	ldw	r2,-32120(gp)
8113d068:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
8113d06c:	d0a0a217 	ldw	r2,-32120(gp)
8113d070:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
8113d074:	d0a0a217 	ldw	r2,-32120(gp)
8113d078:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8113d07c:	d0a0a217 	ldw	r2,-32120(gp)
8113d080:	10000815 	stw	zero,32(r2)
8113d084:	e0bff117 	ldw	r2,-60(fp)
8113d088:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d08c:	e0bffa17 	ldw	r2,-24(fp)
8113d090:	1001703a 	wrctl	status,r2
8113d094:	00000106 	br	8113d09c <OSMutexPend+0x590>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
        return;
8113d098:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
8113d09c:	e037883a 	mov	sp,fp
8113d0a0:	dfc00117 	ldw	ra,4(sp)
8113d0a4:	df000017 	ldw	fp,0(sp)
8113d0a8:	dec00204 	addi	sp,sp,8
8113d0ac:	f800283a 	ret

8113d0b0 <OSMutexPost>:
*                                      what tasks will be using the Mutex.
*********************************************************************************************************
*/

INT8U  OSMutexPost (OS_EVENT *pevent)
{
8113d0b0:	defff604 	addi	sp,sp,-40
8113d0b4:	de00012e 	bgeu	sp,et,8113d0bc <OSMutexPost+0xc>
8113d0b8:	003b68fa 	trap	3
8113d0bc:	dfc00915 	stw	ra,36(sp)
8113d0c0:	df000815 	stw	fp,32(sp)
8113d0c4:	df000804 	addi	fp,sp,32
8113d0c8:	e13fff15 	stw	r4,-4(fp)
    INT8U      pip;                                   /* Priority inheritance priority                 */
    INT8U      prio;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113d0cc:	e03ff815 	stw	zero,-32(fp)
#endif



    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
8113d0d0:	d0a0a103 	ldbu	r2,-32124(gp)
8113d0d4:	10803fcc 	andi	r2,r2,255
8113d0d8:	10000226 	beq	r2,zero,8113d0e4 <OSMutexPost+0x34>
        return (OS_ERR_POST_ISR);                     /* ... can't POST mutex from an ISR              */
8113d0dc:	00800144 	movi	r2,5
8113d0e0:	00007606 	br	8113d2bc <OSMutexPost+0x20c>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113d0e4:	e0bfff17 	ldw	r2,-4(fp)
8113d0e8:	1000021e 	bne	r2,zero,8113d0f4 <OSMutexPost+0x44>
        return (OS_ERR_PEVENT_NULL);
8113d0ec:	00800104 	movi	r2,4
8113d0f0:	00007206 	br	8113d2bc <OSMutexPost+0x20c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
8113d0f4:	e0bfff17 	ldw	r2,-4(fp)
8113d0f8:	10800003 	ldbu	r2,0(r2)
8113d0fc:	10803fcc 	andi	r2,r2,255
8113d100:	10800120 	cmpeqi	r2,r2,4
8113d104:	1000021e 	bne	r2,zero,8113d110 <OSMutexPost+0x60>
        return (OS_ERR_EVENT_TYPE);
8113d108:	00800044 	movi	r2,1
8113d10c:	00006b06 	br	8113d2bc <OSMutexPost+0x20c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d110:	0005303a 	rdctl	r2,status
8113d114:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d118:	e0fffe17 	ldw	r3,-8(fp)
8113d11c:	00bfff84 	movi	r2,-2
8113d120:	1884703a 	and	r2,r3,r2
8113d124:	1001703a 	wrctl	status,r2
  
  return context;
8113d128:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113d12c:	e0bff815 	stw	r2,-32(fp)
    pip  = (INT8U)(pevent->OSEventCnt >> 8);          /* Get priority inheritance priority of mutex    */
8113d130:	e0bfff17 	ldw	r2,-4(fp)
8113d134:	1080020b 	ldhu	r2,8(r2)
8113d138:	10bfffcc 	andi	r2,r2,65535
8113d13c:	1004d23a 	srli	r2,r2,8
8113d140:	e0bffa05 	stb	r2,-24(fp)
    prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
8113d144:	e0bfff17 	ldw	r2,-4(fp)
8113d148:	1080020b 	ldhu	r2,8(r2)
8113d14c:	e0bffa45 	stb	r2,-23(fp)
    if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
8113d150:	e0bfff17 	ldw	r2,-4(fp)
8113d154:	10c00117 	ldw	r3,4(r2)
8113d158:	d0a0a217 	ldw	r2,-32120(gp)
8113d15c:	18800626 	beq	r3,r2,8113d178 <OSMutexPost+0xc8>
8113d160:	e0bff817 	ldw	r2,-32(fp)
8113d164:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d168:	e0bff917 	ldw	r2,-28(fp)
8113d16c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NOT_MUTEX_OWNER);
8113d170:	00801904 	movi	r2,100
8113d174:	00005106 	br	8113d2bc <OSMutexPost+0x20c>
    }
    if (OSTCBCur->OSTCBPrio == pip) {                 /* Did we have to raise current task's priority? */
8113d178:	d0a0a217 	ldw	r2,-32120(gp)
8113d17c:	10800c83 	ldbu	r2,50(r2)
8113d180:	10c03fcc 	andi	r3,r2,255
8113d184:	e0bffa03 	ldbu	r2,-24(fp)
8113d188:	1880051e 	bne	r3,r2,8113d1a0 <OSMutexPost+0xf0>
        OSMutex_RdyAtPrio(OSTCBCur, prio);            /* Restore the task's original priority          */
8113d18c:	d0a0a217 	ldw	r2,-32120(gp)
8113d190:	e0fffa43 	ldbu	r3,-23(fp)
8113d194:	180b883a 	mov	r5,r3
8113d198:	1009883a 	mov	r4,r2
8113d19c:	113d4440 	call	8113d444 <OSMutex_RdyAtPrio>
    }
    OSTCBPrioTbl[pip] = OS_TCB_RESERVED;              /* Reserve table entry                           */
8113d1a0:	e0fffa03 	ldbu	r3,-24(fp)
8113d1a4:	00a045f4 	movhi	r2,33047
8113d1a8:	10b41904 	addi	r2,r2,-12188
8113d1ac:	18c7883a 	add	r3,r3,r3
8113d1b0:	18c7883a 	add	r3,r3,r3
8113d1b4:	10c5883a 	add	r2,r2,r3
8113d1b8:	00c00044 	movi	r3,1
8113d1bc:	10c00015 	stw	r3,0(r2)
    if (pevent->OSEventGrp != 0) {                    /* Any task waiting for the mutex?               */
8113d1c0:	e0bfff17 	ldw	r2,-4(fp)
8113d1c4:	10800283 	ldbu	r2,10(r2)
8113d1c8:	10803fcc 	andi	r2,r2,255
8113d1cc:	10002e26 	beq	r2,zero,8113d288 <OSMutexPost+0x1d8>
                                                      /* Yes, Make HPT waiting for mutex ready         */
        prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
8113d1d0:	000f883a 	mov	r7,zero
8113d1d4:	01800404 	movi	r6,16
8113d1d8:	000b883a 	mov	r5,zero
8113d1dc:	e13fff17 	ldw	r4,-4(fp)
8113d1e0:	11391ac0 	call	811391ac <OS_EventTaskRdy>
8113d1e4:	e0bffa45 	stb	r2,-23(fp)
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
8113d1e8:	e0bfff17 	ldw	r2,-4(fp)
8113d1ec:	10c0020b 	ldhu	r3,8(r2)
8113d1f0:	00bfc004 	movi	r2,-256
8113d1f4:	1884703a 	and	r2,r3,r2
8113d1f8:	1007883a 	mov	r3,r2
8113d1fc:	e0bfff17 	ldw	r2,-4(fp)
8113d200:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= prio;
8113d204:	e0bfff17 	ldw	r2,-4(fp)
8113d208:	10c0020b 	ldhu	r3,8(r2)
8113d20c:	e0bffa43 	ldbu	r2,-23(fp)
8113d210:	1884b03a 	or	r2,r3,r2
8113d214:	1007883a 	mov	r3,r2
8113d218:	e0bfff17 	ldw	r2,-4(fp)
8113d21c:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB         */
8113d220:	e0fffa43 	ldbu	r3,-23(fp)
8113d224:	00a045f4 	movhi	r2,33047
8113d228:	10b41904 	addi	r2,r2,-12188
8113d22c:	18c7883a 	add	r3,r3,r3
8113d230:	18c7883a 	add	r3,r3,r3
8113d234:	10c5883a 	add	r2,r2,r3
8113d238:	10c00017 	ldw	r3,0(r2)
8113d23c:	e0bfff17 	ldw	r2,-4(fp)
8113d240:	10c00115 	stw	r3,4(r2)
        if (prio <= pip) {                            /*      PIP 'must' have a SMALLER prio ...       */
8113d244:	e0bffa43 	ldbu	r2,-23(fp)
8113d248:	e0fffa03 	ldbu	r3,-24(fp)
8113d24c:	18800736 	bltu	r3,r2,8113d26c <OSMutexPost+0x1bc>
8113d250:	e0bff817 	ldw	r2,-32(fp)
8113d254:	e0bffb15 	stw	r2,-20(fp)
8113d258:	e0bffb17 	ldw	r2,-20(fp)
8113d25c:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                       /*      ... than current task!                   */
            OS_Sched();                               /*      Find highest priority task ready to run  */
8113d260:	1139c680 	call	81139c68 <OS_Sched>
            return (OS_ERR_PIP_LOWER);
8113d264:	00801e04 	movi	r2,120
8113d268:	00001406 	br	8113d2bc <OSMutexPost+0x20c>
8113d26c:	e0bff817 	ldw	r2,-32(fp)
8113d270:	e0bffc15 	stw	r2,-16(fp)
8113d274:	e0bffc17 	ldw	r2,-16(fp)
8113d278:	1001703a 	wrctl	status,r2
        } else {
            OS_EXIT_CRITICAL();
            OS_Sched();                               /*      Find highest priority task ready to run  */
8113d27c:	1139c680 	call	81139c68 <OS_Sched>
            return (OS_ERR_NONE);
8113d280:	0005883a 	mov	r2,zero
8113d284:	00000d06 	br	8113d2bc <OSMutexPost+0x20c>
        }
    }
    pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available                   */
8113d288:	e0bfff17 	ldw	r2,-4(fp)
8113d28c:	1080020b 	ldhu	r2,8(r2)
8113d290:	10803fd4 	ori	r2,r2,255
8113d294:	1007883a 	mov	r3,r2
8113d298:	e0bfff17 	ldw	r2,-4(fp)
8113d29c:	10c0020d 	sth	r3,8(r2)
    pevent->OSEventPtr  = (void *)0;
8113d2a0:	e0bfff17 	ldw	r2,-4(fp)
8113d2a4:	10000115 	stw	zero,4(r2)
8113d2a8:	e0bff817 	ldw	r2,-32(fp)
8113d2ac:	e0bffd15 	stw	r2,-12(fp)
8113d2b0:	e0bffd17 	ldw	r2,-12(fp)
8113d2b4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113d2b8:	0005883a 	mov	r2,zero
}
8113d2bc:	e037883a 	mov	sp,fp
8113d2c0:	dfc00117 	ldw	ra,4(sp)
8113d2c4:	df000017 	ldw	fp,0(sp)
8113d2c8:	dec00204 	addi	sp,sp,8
8113d2cc:	f800283a 	ret

8113d2d0 <OSMutexQuery>:
*********************************************************************************************************
*/

#if OS_MUTEX_QUERY_EN > 0
INT8U  OSMutexQuery (OS_EVENT *pevent, OS_MUTEX_DATA *p_mutex_data)
{
8113d2d0:	defff704 	addi	sp,sp,-36
8113d2d4:	de00012e 	bgeu	sp,et,8113d2dc <OSMutexQuery+0xc>
8113d2d8:	003b68fa 	trap	3
8113d2dc:	df000815 	stw	fp,32(sp)
8113d2e0:	df000804 	addi	fp,sp,32
8113d2e4:	e13ffe15 	stw	r4,-8(fp)
8113d2e8:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113d2ec:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113d2f0:	d0a0a103 	ldbu	r2,-32124(gp)
8113d2f4:	10803fcc 	andi	r2,r2,255
8113d2f8:	10000226 	beq	r2,zero,8113d304 <OSMutexQuery+0x34>
        return (OS_ERR_QUERY_ISR);                         /* ... can't QUERY mutex from an ISR        */
8113d2fc:	00800184 	movi	r2,6
8113d300:	00004c06 	br	8113d434 <OSMutexQuery+0x164>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113d304:	e0bffe17 	ldw	r2,-8(fp)
8113d308:	1000021e 	bne	r2,zero,8113d314 <OSMutexQuery+0x44>
        return (OS_ERR_PEVENT_NULL);
8113d30c:	00800104 	movi	r2,4
8113d310:	00004806 	br	8113d434 <OSMutexQuery+0x164>
    }
    if (p_mutex_data == (OS_MUTEX_DATA *)0) {              /* Validate 'p_mutex_data'                  */
8113d314:	e0bfff17 	ldw	r2,-4(fp)
8113d318:	1000021e 	bne	r2,zero,8113d324 <OSMutexQuery+0x54>
        return (OS_ERR_PDATA_NULL);
8113d31c:	00800244 	movi	r2,9
8113d320:	00004406 	br	8113d434 <OSMutexQuery+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
8113d324:	e0bffe17 	ldw	r2,-8(fp)
8113d328:	10800003 	ldbu	r2,0(r2)
8113d32c:	10803fcc 	andi	r2,r2,255
8113d330:	10800120 	cmpeqi	r2,r2,4
8113d334:	1000021e 	bne	r2,zero,8113d340 <OSMutexQuery+0x70>
        return (OS_ERR_EVENT_TYPE);
8113d338:	00800044 	movi	r2,1
8113d33c:	00003d06 	br	8113d434 <OSMutexQuery+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d340:	0005303a 	rdctl	r2,status
8113d344:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d348:	e0fffd17 	ldw	r3,-12(fp)
8113d34c:	00bfff84 	movi	r2,-2
8113d350:	1884703a 	and	r2,r3,r2
8113d354:	1001703a 	wrctl	status,r2
  
  return context;
8113d358:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113d35c:	e0bffb15 	stw	r2,-20(fp)
    p_mutex_data->OSMutexPIP  = (INT8U)(pevent->OSEventCnt >> 8);
8113d360:	e0bffe17 	ldw	r2,-8(fp)
8113d364:	1080020b 	ldhu	r2,8(r2)
8113d368:	10bfffcc 	andi	r2,r2,65535
8113d36c:	1004d23a 	srli	r2,r2,8
8113d370:	1007883a 	mov	r3,r2
8113d374:	e0bfff17 	ldw	r2,-4(fp)
8113d378:	10c00245 	stb	r3,9(r2)
    p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
8113d37c:	e0bffe17 	ldw	r2,-8(fp)
8113d380:	1080020b 	ldhu	r2,8(r2)
8113d384:	1007883a 	mov	r3,r2
8113d388:	e0bfff17 	ldw	r2,-4(fp)
8113d38c:	10c00205 	stb	r3,8(r2)
    if (p_mutex_data->OSOwnerPrio == 0xFF) {
8113d390:	e0bfff17 	ldw	r2,-4(fp)
8113d394:	10800203 	ldbu	r2,8(r2)
8113d398:	10803fcc 	andi	r2,r2,255
8113d39c:	10803fd8 	cmpnei	r2,r2,255
8113d3a0:	1000041e 	bne	r2,zero,8113d3b4 <OSMutexQuery+0xe4>
        p_mutex_data->OSValue = OS_TRUE;
8113d3a4:	e0bfff17 	ldw	r2,-4(fp)
8113d3a8:	00c00044 	movi	r3,1
8113d3ac:	10c001c5 	stb	r3,7(r2)
8113d3b0:	00000206 	br	8113d3bc <OSMutexQuery+0xec>
    } else {
        p_mutex_data->OSValue = OS_FALSE;
8113d3b4:	e0bfff17 	ldw	r2,-4(fp)
8113d3b8:	100001c5 	stb	zero,7(r2)
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
8113d3bc:	e0bffe17 	ldw	r2,-8(fp)
8113d3c0:	10c00283 	ldbu	r3,10(r2)
8113d3c4:	e0bfff17 	ldw	r2,-4(fp)
8113d3c8:	10c00185 	stb	r3,6(r2)
    psrc                      = &pevent->OSEventTbl[0];
8113d3cc:	e0bffe17 	ldw	r2,-8(fp)
8113d3d0:	108002c4 	addi	r2,r2,11
8113d3d4:	e0bff915 	stw	r2,-28(fp)
    pdest                     = &p_mutex_data->OSEventTbl[0];
8113d3d8:	e0bfff17 	ldw	r2,-4(fp)
8113d3dc:	e0bffa15 	stw	r2,-24(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113d3e0:	e03ff805 	stb	zero,-32(fp)
8113d3e4:	00000b06 	br	8113d414 <OSMutexQuery+0x144>
        *pdest++ = *psrc++;
8113d3e8:	e0bffa17 	ldw	r2,-24(fp)
8113d3ec:	10c00044 	addi	r3,r2,1
8113d3f0:	e0fffa15 	stw	r3,-24(fp)
8113d3f4:	e0fff917 	ldw	r3,-28(fp)
8113d3f8:	19000044 	addi	r4,r3,1
8113d3fc:	e13ff915 	stw	r4,-28(fp)
8113d400:	18c00003 	ldbu	r3,0(r3)
8113d404:	10c00005 	stb	r3,0(r2)
        p_mutex_data->OSValue = OS_FALSE;
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
    psrc                      = &pevent->OSEventTbl[0];
    pdest                     = &p_mutex_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113d408:	e0bff803 	ldbu	r2,-32(fp)
8113d40c:	10800044 	addi	r2,r2,1
8113d410:	e0bff805 	stb	r2,-32(fp)
8113d414:	e0bff803 	ldbu	r2,-32(fp)
8113d418:	108001b0 	cmpltui	r2,r2,6
8113d41c:	103ff21e 	bne	r2,zero,8113d3e8 <__reset+0xfb11d3e8>
8113d420:	e0bffb17 	ldw	r2,-20(fp)
8113d424:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d428:	e0bffc17 	ldw	r2,-16(fp)
8113d42c:	1001703a 	wrctl	status,r2
        *pdest++ = *psrc++;
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113d430:	0005883a 	mov	r2,zero
}
8113d434:	e037883a 	mov	sp,fp
8113d438:	df000017 	ldw	fp,0(sp)
8113d43c:	dec00104 	addi	sp,sp,4
8113d440:	f800283a 	ret

8113d444 <OSMutex_RdyAtPrio>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OSMutex_RdyAtPrio (OS_TCB *ptcb, INT8U prio)
{
8113d444:	defffc04 	addi	sp,sp,-16
8113d448:	de00012e 	bgeu	sp,et,8113d450 <OSMutex_RdyAtPrio+0xc>
8113d44c:	003b68fa 	trap	3
8113d450:	df000315 	stw	fp,12(sp)
8113d454:	df000304 	addi	fp,sp,12
8113d458:	e13ffe15 	stw	r4,-8(fp)
8113d45c:	2805883a 	mov	r2,r5
8113d460:	e0bfff05 	stb	r2,-4(fp)
    INT8U   y;


    y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pip'    */
8113d464:	e0bffe17 	ldw	r2,-8(fp)
8113d468:	10800d03 	ldbu	r2,52(r2)
8113d46c:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
8113d470:	e0fffd03 	ldbu	r3,-12(fp)
8113d474:	e13ffd03 	ldbu	r4,-12(fp)
8113d478:	d0a09e44 	addi	r2,gp,-32135
8113d47c:	2085883a 	add	r2,r4,r2
8113d480:	10800003 	ldbu	r2,0(r2)
8113d484:	1009883a 	mov	r4,r2
8113d488:	e0bffe17 	ldw	r2,-8(fp)
8113d48c:	10800d43 	ldbu	r2,53(r2)
8113d490:	0084303a 	nor	r2,zero,r2
8113d494:	2084703a 	and	r2,r4,r2
8113d498:	1009883a 	mov	r4,r2
8113d49c:	d0a09e44 	addi	r2,gp,-32135
8113d4a0:	1885883a 	add	r2,r3,r2
8113d4a4:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
8113d4a8:	e0fffd03 	ldbu	r3,-12(fp)
8113d4ac:	d0a09e44 	addi	r2,gp,-32135
8113d4b0:	1885883a 	add	r2,r3,r2
8113d4b4:	10800003 	ldbu	r2,0(r2)
8113d4b8:	10803fcc 	andi	r2,r2,255
8113d4bc:	1000071e 	bne	r2,zero,8113d4dc <OSMutex_RdyAtPrio+0x98>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
8113d4c0:	e0bffe17 	ldw	r2,-8(fp)
8113d4c4:	10800d83 	ldbu	r2,54(r2)
8113d4c8:	0084303a 	nor	r2,zero,r2
8113d4cc:	1007883a 	mov	r3,r2
8113d4d0:	d0a09e03 	ldbu	r2,-32136(gp)
8113d4d4:	1884703a 	and	r2,r3,r2
8113d4d8:	d0a09e05 	stb	r2,-32136(gp)
    }
    ptcb->OSTCBPrio         = prio;
8113d4dc:	e0bffe17 	ldw	r2,-8(fp)
8113d4e0:	e0ffff03 	ldbu	r3,-4(fp)
8113d4e4:	10c00c85 	stb	r3,50(r2)
#if OS_LOWEST_PRIO <= 63
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)3) & (INT8U)0x07);
8113d4e8:	e0bfff03 	ldbu	r2,-4(fp)
8113d4ec:	1004d0fa 	srli	r2,r2,3
8113d4f0:	108001cc 	andi	r2,r2,7
8113d4f4:	1007883a 	mov	r3,r2
8113d4f8:	e0bffe17 	ldw	r2,-8(fp)
8113d4fc:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x07);
8113d500:	e0bfff03 	ldbu	r2,-4(fp)
8113d504:	108001cc 	andi	r2,r2,7
8113d508:	1007883a 	mov	r3,r2
8113d50c:	e0bffe17 	ldw	r2,-8(fp)
8113d510:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY         = (INT8U)(1 << ptcb->OSTCBY);
8113d514:	e0bffe17 	ldw	r2,-8(fp)
8113d518:	10800d03 	ldbu	r2,52(r2)
8113d51c:	10803fcc 	andi	r2,r2,255
8113d520:	00c00044 	movi	r3,1
8113d524:	1884983a 	sll	r2,r3,r2
8113d528:	1007883a 	mov	r3,r2
8113d52c:	e0bffe17 	ldw	r2,-8(fp)
8113d530:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX         = (INT8U)(1 << ptcb->OSTCBX);
8113d534:	e0bffe17 	ldw	r2,-8(fp)
8113d538:	10800cc3 	ldbu	r2,51(r2)
8113d53c:	10803fcc 	andi	r2,r2,255
8113d540:	00c00044 	movi	r3,1
8113d544:	1884983a 	sll	r2,r3,r2
8113d548:	1007883a 	mov	r3,r2
8113d54c:	e0bffe17 	ldw	r2,-8(fp)
8113d550:	10c00d45 	stb	r3,53(r2)
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)4) & (INT8U)0x0F);
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x0F);
    ptcb->OSTCBBitY         = (INT16U)(1 << ptcb->OSTCBY);
    ptcb->OSTCBBitX         = (INT16U)(1 << ptcb->OSTCBX);
#endif
    OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
8113d554:	e0bffe17 	ldw	r2,-8(fp)
8113d558:	10c00d83 	ldbu	r3,54(r2)
8113d55c:	d0a09e03 	ldbu	r2,-32136(gp)
8113d560:	1884b03a 	or	r2,r3,r2
8113d564:	d0a09e05 	stb	r2,-32136(gp)
    OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113d568:	e0bffe17 	ldw	r2,-8(fp)
8113d56c:	10800d03 	ldbu	r2,52(r2)
8113d570:	10c03fcc 	andi	r3,r2,255
8113d574:	e0bffe17 	ldw	r2,-8(fp)
8113d578:	10800d03 	ldbu	r2,52(r2)
8113d57c:	11003fcc 	andi	r4,r2,255
8113d580:	d0a09e44 	addi	r2,gp,-32135
8113d584:	2085883a 	add	r2,r4,r2
8113d588:	11000003 	ldbu	r4,0(r2)
8113d58c:	e0bffe17 	ldw	r2,-8(fp)
8113d590:	10800d43 	ldbu	r2,53(r2)
8113d594:	2084b03a 	or	r2,r4,r2
8113d598:	1009883a 	mov	r4,r2
8113d59c:	d0a09e44 	addi	r2,gp,-32135
8113d5a0:	1885883a 	add	r2,r3,r2
8113d5a4:	11000005 	stb	r4,0(r2)
    OSTCBPrioTbl[prio]      = ptcb;
8113d5a8:	e0ffff03 	ldbu	r3,-4(fp)
8113d5ac:	00a045f4 	movhi	r2,33047
8113d5b0:	10b41904 	addi	r2,r2,-12188
8113d5b4:	18c7883a 	add	r3,r3,r3
8113d5b8:	18c7883a 	add	r3,r3,r3
8113d5bc:	10c5883a 	add	r2,r2,r3
8113d5c0:	e0fffe17 	ldw	r3,-8(fp)
8113d5c4:	10c00015 	stw	r3,0(r2)
}
8113d5c8:	0001883a 	nop
8113d5cc:	e037883a 	mov	sp,fp
8113d5d0:	df000017 	ldw	fp,0(sp)
8113d5d4:	dec00104 	addi	sp,sp,4
8113d5d8:	f800283a 	ret

8113d5dc <OSQAccept>:
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *perr)
{
8113d5dc:	defff804 	addi	sp,sp,-32
8113d5e0:	de00012e 	bgeu	sp,et,8113d5e8 <OSQAccept+0xc>
8113d5e4:	003b68fa 	trap	3
8113d5e8:	df000715 	stw	fp,28(sp)
8113d5ec:	df000704 	addi	fp,sp,28
8113d5f0:	e13ffe15 	stw	r4,-8(fp)
8113d5f4:	e17fff15 	stw	r5,-4(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113d5f8:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113d5fc:	e0bfff17 	ldw	r2,-4(fp)
8113d600:	1000021e 	bne	r2,zero,8113d60c <OSQAccept+0x30>
        return ((void *)0);
8113d604:	0005883a 	mov	r2,zero
8113d608:	00004206 	br	8113d714 <OSQAccept+0x138>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
8113d60c:	e0bffe17 	ldw	r2,-8(fp)
8113d610:	1000051e 	bne	r2,zero,8113d628 <OSQAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113d614:	e0bfff17 	ldw	r2,-4(fp)
8113d618:	00c00104 	movi	r3,4
8113d61c:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113d620:	0005883a 	mov	r2,zero
8113d624:	00003b06 	br	8113d714 <OSQAccept+0x138>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
8113d628:	e0bffe17 	ldw	r2,-8(fp)
8113d62c:	10800003 	ldbu	r2,0(r2)
8113d630:	10803fcc 	andi	r2,r2,255
8113d634:	108000a0 	cmpeqi	r2,r2,2
8113d638:	1000051e 	bne	r2,zero,8113d650 <OSQAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
8113d63c:	e0bfff17 	ldw	r2,-4(fp)
8113d640:	00c00044 	movi	r3,1
8113d644:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113d648:	0005883a 	mov	r2,zero
8113d64c:	00003106 	br	8113d714 <OSQAccept+0x138>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d650:	0005303a 	rdctl	r2,status
8113d654:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d658:	e0fffd17 	ldw	r3,-12(fp)
8113d65c:	00bfff84 	movi	r2,-2
8113d660:	1884703a 	and	r2,r3,r2
8113d664:	1001703a 	wrctl	status,r2
  
  return context;
8113d668:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113d66c:	e0bffa15 	stw	r2,-24(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
8113d670:	e0bffe17 	ldw	r2,-8(fp)
8113d674:	10800117 	ldw	r2,4(r2)
8113d678:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
8113d67c:	e0bffc17 	ldw	r2,-16(fp)
8113d680:	1080058b 	ldhu	r2,22(r2)
8113d684:	10bfffcc 	andi	r2,r2,65535
8113d688:	10001926 	beq	r2,zero,8113d6f0 <OSQAccept+0x114>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
8113d68c:	e0bffc17 	ldw	r2,-16(fp)
8113d690:	10800417 	ldw	r2,16(r2)
8113d694:	11000104 	addi	r4,r2,4
8113d698:	e0fffc17 	ldw	r3,-16(fp)
8113d69c:	19000415 	stw	r4,16(r3)
8113d6a0:	10800017 	ldw	r2,0(r2)
8113d6a4:	e0bff915 	stw	r2,-28(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
8113d6a8:	e0bffc17 	ldw	r2,-16(fp)
8113d6ac:	1080058b 	ldhu	r2,22(r2)
8113d6b0:	10bfffc4 	addi	r2,r2,-1
8113d6b4:	1007883a 	mov	r3,r2
8113d6b8:	e0bffc17 	ldw	r2,-16(fp)
8113d6bc:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
8113d6c0:	e0bffc17 	ldw	r2,-16(fp)
8113d6c4:	10c00417 	ldw	r3,16(r2)
8113d6c8:	e0bffc17 	ldw	r2,-16(fp)
8113d6cc:	10800217 	ldw	r2,8(r2)
8113d6d0:	1880041e 	bne	r3,r2,8113d6e4 <OSQAccept+0x108>
            pq->OSQOut = pq->OSQStart;
8113d6d4:	e0bffc17 	ldw	r2,-16(fp)
8113d6d8:	10c00117 	ldw	r3,4(r2)
8113d6dc:	e0bffc17 	ldw	r2,-16(fp)
8113d6e0:	10c00415 	stw	r3,16(r2)
        }
        *perr = OS_ERR_NONE;
8113d6e4:	e0bfff17 	ldw	r2,-4(fp)
8113d6e8:	10000005 	stb	zero,0(r2)
8113d6ec:	00000406 	br	8113d700 <OSQAccept+0x124>
    } else {
        *perr = OS_ERR_Q_EMPTY;
8113d6f0:	e0bfff17 	ldw	r2,-4(fp)
8113d6f4:	00c007c4 	movi	r3,31
8113d6f8:	10c00005 	stb	r3,0(r2)
        pmsg  = (void *)0;                       /* Queue is empty                                     */
8113d6fc:	e03ff915 	stw	zero,-28(fp)
8113d700:	e0bffa17 	ldw	r2,-24(fp)
8113d704:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d708:	e0bffb17 	ldw	r2,-20(fp)
8113d70c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (pmsg);                               /* Return message received (or NULL)                  */
8113d710:	e0bff917 	ldw	r2,-28(fp)
}
8113d714:	e037883a 	mov	sp,fp
8113d718:	df000017 	ldw	fp,0(sp)
8113d71c:	dec00104 	addi	sp,sp,4
8113d720:	f800283a 	ret

8113d724 <OSQCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
8113d724:	defff404 	addi	sp,sp,-48
8113d728:	de00012e 	bgeu	sp,et,8113d730 <OSQCreate+0xc>
8113d72c:	003b68fa 	trap	3
8113d730:	dfc00b15 	stw	ra,44(sp)
8113d734:	df000a15 	stw	fp,40(sp)
8113d738:	df000a04 	addi	fp,sp,40
8113d73c:	e13ffe15 	stw	r4,-8(fp)
8113d740:	2805883a 	mov	r2,r5
8113d744:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113d748:	e03ff715 	stw	zero,-36(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
8113d74c:	d0a0a103 	ldbu	r2,-32124(gp)
8113d750:	10803fcc 	andi	r2,r2,255
8113d754:	10000226 	beq	r2,zero,8113d760 <OSQCreate+0x3c>
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
8113d758:	0005883a 	mov	r2,zero
8113d75c:	00005906 	br	8113d8c4 <OSQCreate+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d760:	0005303a 	rdctl	r2,status
8113d764:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d768:	e0fffd17 	ldw	r3,-12(fp)
8113d76c:	00bfff84 	movi	r2,-2
8113d770:	1884703a 	and	r2,r3,r2
8113d774:	1001703a 	wrctl	status,r2
  
  return context;
8113d778:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113d77c:	e0bff715 	stw	r2,-36(fp)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
8113d780:	d0a0a017 	ldw	r2,-32128(gp)
8113d784:	e0bff615 	stw	r2,-40(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
8113d788:	d0a0a017 	ldw	r2,-32128(gp)
8113d78c:	10000326 	beq	r2,zero,8113d79c <OSQCreate+0x78>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
8113d790:	d0a0a017 	ldw	r2,-32128(gp)
8113d794:	10800117 	ldw	r2,4(r2)
8113d798:	d0a0a015 	stw	r2,-32128(gp)
8113d79c:	e0bff717 	ldw	r2,-36(fp)
8113d7a0:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d7a4:	e0bff817 	ldw	r2,-32(fp)
8113d7a8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
8113d7ac:	e0bff617 	ldw	r2,-40(fp)
8113d7b0:	10004326 	beq	r2,zero,8113d8c0 <OSQCreate+0x19c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d7b4:	0005303a 	rdctl	r2,status
8113d7b8:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d7bc:	e0fff917 	ldw	r3,-28(fp)
8113d7c0:	00bfff84 	movi	r2,-2
8113d7c4:	1884703a 	and	r2,r3,r2
8113d7c8:	1001703a 	wrctl	status,r2
  
  return context;
8113d7cc:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();
8113d7d0:	e0bff715 	stw	r2,-36(fp)
        pq = OSQFreeList;                        /* Get a free queue control block                     */
8113d7d4:	d0a09d17 	ldw	r2,-32140(gp)
8113d7d8:	e0bffb15 	stw	r2,-20(fp)
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
8113d7dc:	e0bffb17 	ldw	r2,-20(fp)
8113d7e0:	10002d26 	beq	r2,zero,8113d898 <OSQCreate+0x174>
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
8113d7e4:	d0a09d17 	ldw	r2,-32140(gp)
8113d7e8:	10800017 	ldw	r2,0(r2)
8113d7ec:	d0a09d15 	stw	r2,-32140(gp)
8113d7f0:	e0bff717 	ldw	r2,-36(fp)
8113d7f4:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d7f8:	e0bffa17 	ldw	r2,-24(fp)
8113d7fc:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pq->OSQStart           = start;               /*      Initialize the queue                 */
8113d800:	e0bffb17 	ldw	r2,-20(fp)
8113d804:	e0fffe17 	ldw	r3,-8(fp)
8113d808:	10c00115 	stw	r3,4(r2)
            pq->OSQEnd             = &start[size];
8113d80c:	e0bfff0b 	ldhu	r2,-4(fp)
8113d810:	1085883a 	add	r2,r2,r2
8113d814:	1085883a 	add	r2,r2,r2
8113d818:	1007883a 	mov	r3,r2
8113d81c:	e0bffe17 	ldw	r2,-8(fp)
8113d820:	10c7883a 	add	r3,r2,r3
8113d824:	e0bffb17 	ldw	r2,-20(fp)
8113d828:	10c00215 	stw	r3,8(r2)
            pq->OSQIn              = start;
8113d82c:	e0bffb17 	ldw	r2,-20(fp)
8113d830:	e0fffe17 	ldw	r3,-8(fp)
8113d834:	10c00315 	stw	r3,12(r2)
            pq->OSQOut             = start;
8113d838:	e0bffb17 	ldw	r2,-20(fp)
8113d83c:	e0fffe17 	ldw	r3,-8(fp)
8113d840:	10c00415 	stw	r3,16(r2)
            pq->OSQSize            = size;
8113d844:	e0bffb17 	ldw	r2,-20(fp)
8113d848:	e0ffff0b 	ldhu	r3,-4(fp)
8113d84c:	10c0050d 	sth	r3,20(r2)
            pq->OSQEntries         = 0;
8113d850:	e0bffb17 	ldw	r2,-20(fp)
8113d854:	1000058d 	sth	zero,22(r2)
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
8113d858:	e0bff617 	ldw	r2,-40(fp)
8113d85c:	00c00084 	movi	r3,2
8113d860:	10c00005 	stb	r3,0(r2)
            pevent->OSEventCnt     = 0;
8113d864:	e0bff617 	ldw	r2,-40(fp)
8113d868:	1000020d 	sth	zero,8(r2)
            pevent->OSEventPtr     = pq;
8113d86c:	e0bff617 	ldw	r2,-40(fp)
8113d870:	e0fffb17 	ldw	r3,-20(fp)
8113d874:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
8113d878:	e0bff617 	ldw	r2,-40(fp)
8113d87c:	00c00fc4 	movi	r3,63
8113d880:	10c00445 	stb	r3,17(r2)
            pevent->OSEventName[1] = OS_ASCII_NUL;
8113d884:	e0bff617 	ldw	r2,-40(fp)
8113d888:	10000485 	stb	zero,18(r2)
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
8113d88c:	e13ff617 	ldw	r4,-40(fp)
8113d890:	11397840 	call	81139784 <OS_EventWaitListInit>
8113d894:	00000a06 	br	8113d8c0 <OSQCreate+0x19c>
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
8113d898:	d0e0a017 	ldw	r3,-32128(gp)
8113d89c:	e0bff617 	ldw	r2,-40(fp)
8113d8a0:	10c00115 	stw	r3,4(r2)
            OSEventFreeList    = pevent;
8113d8a4:	e0bff617 	ldw	r2,-40(fp)
8113d8a8:	d0a0a015 	stw	r2,-32128(gp)
8113d8ac:	e0bff717 	ldw	r2,-36(fp)
8113d8b0:	e0bffc15 	stw	r2,-16(fp)
8113d8b4:	e0bffc17 	ldw	r2,-16(fp)
8113d8b8:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pevent = (OS_EVENT *)0;
8113d8bc:	e03ff615 	stw	zero,-40(fp)
        }
    }
    return (pevent);
8113d8c0:	e0bff617 	ldw	r2,-40(fp)
}
8113d8c4:	e037883a 	mov	sp,fp
8113d8c8:	dfc00117 	ldw	ra,4(sp)
8113d8cc:	df000017 	ldw	fp,0(sp)
8113d8d0:	dec00204 	addi	sp,sp,8
8113d8d4:	f800283a 	ret

8113d8d8 <OSQDel>:
*********************************************************************************************************
*/

#if OS_Q_DEL_EN > 0
OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113d8d8:	defff204 	addi	sp,sp,-56
8113d8dc:	de00012e 	bgeu	sp,et,8113d8e4 <OSQDel+0xc>
8113d8e0:	003b68fa 	trap	3
8113d8e4:	dfc00d15 	stw	ra,52(sp)
8113d8e8:	df000c15 	stw	fp,48(sp)
8113d8ec:	df000c04 	addi	fp,sp,48
8113d8f0:	e13ffd15 	stw	r4,-12(fp)
8113d8f4:	2805883a 	mov	r2,r5
8113d8f8:	e1bfff15 	stw	r6,-4(fp)
8113d8fc:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113d900:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113d904:	e0bfff17 	ldw	r2,-4(fp)
8113d908:	1000021e 	bne	r2,zero,8113d914 <OSQDel+0x3c>
        return (pevent);
8113d90c:	e0bffd17 	ldw	r2,-12(fp)
8113d910:	00008e06 	br	8113db4c <OSQDel+0x274>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113d914:	e0bffd17 	ldw	r2,-12(fp)
8113d918:	1000051e 	bne	r2,zero,8113d930 <OSQDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113d91c:	e0bfff17 	ldw	r2,-4(fp)
8113d920:	00c00104 	movi	r3,4
8113d924:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113d928:	e0bffd17 	ldw	r2,-12(fp)
8113d92c:	00008706 	br	8113db4c <OSQDel+0x274>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
8113d930:	e0bffd17 	ldw	r2,-12(fp)
8113d934:	10800003 	ldbu	r2,0(r2)
8113d938:	10803fcc 	andi	r2,r2,255
8113d93c:	108000a0 	cmpeqi	r2,r2,2
8113d940:	1000051e 	bne	r2,zero,8113d958 <OSQDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113d944:	e0bfff17 	ldw	r2,-4(fp)
8113d948:	00c00044 	movi	r3,1
8113d94c:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113d950:	e0bffd17 	ldw	r2,-12(fp)
8113d954:	00007d06 	br	8113db4c <OSQDel+0x274>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113d958:	d0a0a103 	ldbu	r2,-32124(gp)
8113d95c:	10803fcc 	andi	r2,r2,255
8113d960:	10000526 	beq	r2,zero,8113d978 <OSQDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
8113d964:	e0bfff17 	ldw	r2,-4(fp)
8113d968:	00c003c4 	movi	r3,15
8113d96c:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113d970:	e0bffd17 	ldw	r2,-12(fp)
8113d974:	00007506 	br	8113db4c <OSQDel+0x274>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d978:	0005303a 	rdctl	r2,status
8113d97c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d980:	e0fffc17 	ldw	r3,-16(fp)
8113d984:	00bfff84 	movi	r2,-2
8113d988:	1884703a 	and	r2,r3,r2
8113d98c:	1001703a 	wrctl	status,r2
  
  return context;
8113d990:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113d994:	e0bff615 	stw	r2,-40(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
8113d998:	e0bffd17 	ldw	r2,-12(fp)
8113d99c:	10800283 	ldbu	r2,10(r2)
8113d9a0:	10803fcc 	andi	r2,r2,255
8113d9a4:	10000326 	beq	r2,zero,8113d9b4 <OSQDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8113d9a8:	00800044 	movi	r2,1
8113d9ac:	e0bff405 	stb	r2,-48(fp)
8113d9b0:	00000106 	br	8113d9b8 <OSQDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8113d9b4:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
8113d9b8:	e0bffe03 	ldbu	r2,-8(fp)
8113d9bc:	10000326 	beq	r2,zero,8113d9cc <OSQDel+0xf4>
8113d9c0:	10800060 	cmpeqi	r2,r2,1
8113d9c4:	1000301e 	bne	r2,zero,8113da88 <OSQDel+0x1b0>
8113d9c8:	00005506 	br	8113db20 <OSQDel+0x248>
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == OS_FALSE) {
8113d9cc:	e0bff403 	ldbu	r2,-48(fp)
8113d9d0:	10001e1e 	bne	r2,zero,8113da4c <OSQDel+0x174>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
8113d9d4:	e0bffd17 	ldw	r2,-12(fp)
8113d9d8:	00c00fc4 	movi	r3,63
8113d9dc:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
8113d9e0:	e0bffd17 	ldw	r2,-12(fp)
8113d9e4:	10000485 	stb	zero,18(r2)
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
8113d9e8:	e0bffd17 	ldw	r2,-12(fp)
8113d9ec:	10800117 	ldw	r2,4(r2)
8113d9f0:	e0bff815 	stw	r2,-32(fp)
                 pq->OSQPtr             = OSQFreeList;
8113d9f4:	d0e09d17 	ldw	r3,-32140(gp)
8113d9f8:	e0bff817 	ldw	r2,-32(fp)
8113d9fc:	10c00015 	stw	r3,0(r2)
                 OSQFreeList            = pq;
8113da00:	e0bff817 	ldw	r2,-32(fp)
8113da04:	d0a09d15 	stw	r2,-32140(gp)
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113da08:	e0bffd17 	ldw	r2,-12(fp)
8113da0c:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
8113da10:	d0e0a017 	ldw	r3,-32128(gp)
8113da14:	e0bffd17 	ldw	r2,-12(fp)
8113da18:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
8113da1c:	e0bffd17 	ldw	r2,-12(fp)
8113da20:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
8113da24:	e0bffd17 	ldw	r2,-12(fp)
8113da28:	d0a0a015 	stw	r2,-32128(gp)
8113da2c:	e0bff617 	ldw	r2,-40(fp)
8113da30:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113da34:	e0bff717 	ldw	r2,-36(fp)
8113da38:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
8113da3c:	e0bfff17 	ldw	r2,-4(fp)
8113da40:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
8113da44:	e03ff515 	stw	zero,-44(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
8113da48:	00003f06 	br	8113db48 <OSQDel+0x270>
8113da4c:	e0bff617 	ldw	r2,-40(fp)
8113da50:	e0bff915 	stw	r2,-28(fp)
8113da54:	e0bff917 	ldw	r2,-28(fp)
8113da58:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
8113da5c:	e0bfff17 	ldw	r2,-4(fp)
8113da60:	00c01244 	movi	r3,73
8113da64:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
8113da68:	e0bffd17 	ldw	r2,-12(fp)
8113da6c:	e0bff515 	stw	r2,-44(fp)
             }
             break;
8113da70:	00003506 	br	8113db48 <OSQDel+0x270>

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
8113da74:	000f883a 	mov	r7,zero
8113da78:	01800104 	movi	r6,4
8113da7c:	000b883a 	mov	r5,zero
8113da80:	e13ffd17 	ldw	r4,-12(fp)
8113da84:	11391ac0 	call	811391ac <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
8113da88:	e0bffd17 	ldw	r2,-12(fp)
8113da8c:	10800283 	ldbu	r2,10(r2)
8113da90:	10803fcc 	andi	r2,r2,255
8113da94:	103ff71e 	bne	r2,zero,8113da74 <__reset+0xfb11da74>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
8113da98:	e0bffd17 	ldw	r2,-12(fp)
8113da9c:	00c00fc4 	movi	r3,63
8113daa0:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
8113daa4:	e0bffd17 	ldw	r2,-12(fp)
8113daa8:	10000485 	stb	zero,18(r2)
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
8113daac:	e0bffd17 	ldw	r2,-12(fp)
8113dab0:	10800117 	ldw	r2,4(r2)
8113dab4:	e0bff815 	stw	r2,-32(fp)
             pq->OSQPtr             = OSQFreeList;
8113dab8:	d0e09d17 	ldw	r3,-32140(gp)
8113dabc:	e0bff817 	ldw	r2,-32(fp)
8113dac0:	10c00015 	stw	r3,0(r2)
             OSQFreeList            = pq;
8113dac4:	e0bff817 	ldw	r2,-32(fp)
8113dac8:	d0a09d15 	stw	r2,-32140(gp)
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113dacc:	e0bffd17 	ldw	r2,-12(fp)
8113dad0:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
8113dad4:	d0e0a017 	ldw	r3,-32128(gp)
8113dad8:	e0bffd17 	ldw	r2,-12(fp)
8113dadc:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
8113dae0:	e0bffd17 	ldw	r2,-12(fp)
8113dae4:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
8113dae8:	e0bffd17 	ldw	r2,-12(fp)
8113daec:	d0a0a015 	stw	r2,-32128(gp)
8113daf0:	e0bff617 	ldw	r2,-40(fp)
8113daf4:	e0bffa15 	stw	r2,-24(fp)
8113daf8:	e0bffa17 	ldw	r2,-24(fp)
8113dafc:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8113db00:	e0bff403 	ldbu	r2,-48(fp)
8113db04:	10800058 	cmpnei	r2,r2,1
8113db08:	1000011e 	bne	r2,zero,8113db10 <OSQDel+0x238>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8113db0c:	1139c680 	call	81139c68 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
8113db10:	e0bfff17 	ldw	r2,-4(fp)
8113db14:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
8113db18:	e03ff515 	stw	zero,-44(fp)
             break;
8113db1c:	00000a06 	br	8113db48 <OSQDel+0x270>
8113db20:	e0bff617 	ldw	r2,-40(fp)
8113db24:	e0bffb15 	stw	r2,-20(fp)
8113db28:	e0bffb17 	ldw	r2,-20(fp)
8113db2c:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
8113db30:	e0bfff17 	ldw	r2,-4(fp)
8113db34:	00c001c4 	movi	r3,7
8113db38:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
8113db3c:	e0bffd17 	ldw	r2,-12(fp)
8113db40:	e0bff515 	stw	r2,-44(fp)
             break;
8113db44:	0001883a 	nop
    }
    return (pevent_return);
8113db48:	e0bff517 	ldw	r2,-44(fp)
}
8113db4c:	e037883a 	mov	sp,fp
8113db50:	dfc00117 	ldw	ra,4(sp)
8113db54:	df000017 	ldw	fp,0(sp)
8113db58:	dec00204 	addi	sp,sp,8
8113db5c:	f800283a 	ret

8113db60 <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0
INT8U  OSQFlush (OS_EVENT *pevent)
{
8113db60:	defffa04 	addi	sp,sp,-24
8113db64:	de00012e 	bgeu	sp,et,8113db6c <OSQFlush+0xc>
8113db68:	003b68fa 	trap	3
8113db6c:	df000515 	stw	fp,20(sp)
8113db70:	df000504 	addi	fp,sp,20
8113db74:	e13fff15 	stw	r4,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113db78:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113db7c:	e0bfff17 	ldw	r2,-4(fp)
8113db80:	1000021e 	bne	r2,zero,8113db8c <OSQFlush+0x2c>
        return (OS_ERR_PEVENT_NULL);
8113db84:	00800104 	movi	r2,4
8113db88:	00002106 	br	8113dc10 <OSQFlush+0xb0>
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
8113db8c:	e0bfff17 	ldw	r2,-4(fp)
8113db90:	10800003 	ldbu	r2,0(r2)
8113db94:	10803fcc 	andi	r2,r2,255
8113db98:	108000a0 	cmpeqi	r2,r2,2
8113db9c:	1000021e 	bne	r2,zero,8113dba8 <OSQFlush+0x48>
        return (OS_ERR_EVENT_TYPE);
8113dba0:	00800044 	movi	r2,1
8113dba4:	00001a06 	br	8113dc10 <OSQFlush+0xb0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113dba8:	0005303a 	rdctl	r2,status
8113dbac:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113dbb0:	e0fffd17 	ldw	r3,-12(fp)
8113dbb4:	00bfff84 	movi	r2,-2
8113dbb8:	1884703a 	and	r2,r3,r2
8113dbbc:	1001703a 	wrctl	status,r2
  
  return context;
8113dbc0:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113dbc4:	e0bffb15 	stw	r2,-20(fp)
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
8113dbc8:	e0bfff17 	ldw	r2,-4(fp)
8113dbcc:	10800117 	ldw	r2,4(r2)
8113dbd0:	e0bffc15 	stw	r2,-16(fp)
    pq->OSQIn      = pq->OSQStart;
8113dbd4:	e0bffc17 	ldw	r2,-16(fp)
8113dbd8:	10c00117 	ldw	r3,4(r2)
8113dbdc:	e0bffc17 	ldw	r2,-16(fp)
8113dbe0:	10c00315 	stw	r3,12(r2)
    pq->OSQOut     = pq->OSQStart;
8113dbe4:	e0bffc17 	ldw	r2,-16(fp)
8113dbe8:	10c00117 	ldw	r3,4(r2)
8113dbec:	e0bffc17 	ldw	r2,-16(fp)
8113dbf0:	10c00415 	stw	r3,16(r2)
    pq->OSQEntries = 0;
8113dbf4:	e0bffc17 	ldw	r2,-16(fp)
8113dbf8:	1000058d 	sth	zero,22(r2)
8113dbfc:	e0bffb17 	ldw	r2,-20(fp)
8113dc00:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113dc04:	e0bffe17 	ldw	r2,-8(fp)
8113dc08:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113dc0c:	0005883a 	mov	r2,zero
}
8113dc10:	e037883a 	mov	sp,fp
8113dc14:	df000017 	ldw	fp,0(sp)
8113dc18:	dec00104 	addi	sp,sp,4
8113dc1c:	f800283a 	ret

8113dc20 <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
8113dc20:	defff304 	addi	sp,sp,-52
8113dc24:	de00012e 	bgeu	sp,et,8113dc2c <OSQPend+0xc>
8113dc28:	003b68fa 	trap	3
8113dc2c:	dfc00c15 	stw	ra,48(sp)
8113dc30:	df000b15 	stw	fp,44(sp)
8113dc34:	df000b04 	addi	fp,sp,44
8113dc38:	e13ffd15 	stw	r4,-12(fp)
8113dc3c:	2805883a 	mov	r2,r5
8113dc40:	e1bfff15 	stw	r6,-4(fp)
8113dc44:	e0bffe0d 	sth	r2,-8(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113dc48:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113dc4c:	e0bfff17 	ldw	r2,-4(fp)
8113dc50:	1000021e 	bne	r2,zero,8113dc5c <OSQPend+0x3c>
        return ((void *)0);
8113dc54:	0005883a 	mov	r2,zero
8113dc58:	00009106 	br	8113dea0 <OSQPend+0x280>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
8113dc5c:	e0bffd17 	ldw	r2,-12(fp)
8113dc60:	1000051e 	bne	r2,zero,8113dc78 <OSQPend+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113dc64:	e0bfff17 	ldw	r2,-4(fp)
8113dc68:	00c00104 	movi	r3,4
8113dc6c:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113dc70:	0005883a 	mov	r2,zero
8113dc74:	00008a06 	br	8113dea0 <OSQPend+0x280>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
8113dc78:	e0bffd17 	ldw	r2,-12(fp)
8113dc7c:	10800003 	ldbu	r2,0(r2)
8113dc80:	10803fcc 	andi	r2,r2,255
8113dc84:	108000a0 	cmpeqi	r2,r2,2
8113dc88:	1000051e 	bne	r2,zero,8113dca0 <OSQPend+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113dc8c:	e0bfff17 	ldw	r2,-4(fp)
8113dc90:	00c00044 	movi	r3,1
8113dc94:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113dc98:	0005883a 	mov	r2,zero
8113dc9c:	00008006 	br	8113dea0 <OSQPend+0x280>
    }
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
8113dca0:	d0a0a103 	ldbu	r2,-32124(gp)
8113dca4:	10803fcc 	andi	r2,r2,255
8113dca8:	10000526 	beq	r2,zero,8113dcc0 <OSQPend+0xa0>
        *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
8113dcac:	e0bfff17 	ldw	r2,-4(fp)
8113dcb0:	00c00084 	movi	r3,2
8113dcb4:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113dcb8:	0005883a 	mov	r2,zero
8113dcbc:	00007806 	br	8113dea0 <OSQPend+0x280>
    }
    if (OSLockNesting > 0) {                     /* See if called with scheduler locked ...            */
8113dcc0:	d0a08f03 	ldbu	r2,-32196(gp)
8113dcc4:	10803fcc 	andi	r2,r2,255
8113dcc8:	10000526 	beq	r2,zero,8113dce0 <OSQPend+0xc0>
        *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
8113dccc:	e0bfff17 	ldw	r2,-4(fp)
8113dcd0:	00c00344 	movi	r3,13
8113dcd4:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113dcd8:	0005883a 	mov	r2,zero
8113dcdc:	00007006 	br	8113dea0 <OSQPend+0x280>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113dce0:	0005303a 	rdctl	r2,status
8113dce4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113dce8:	e0fffc17 	ldw	r3,-16(fp)
8113dcec:	00bfff84 	movi	r2,-2
8113dcf0:	1884703a 	and	r2,r3,r2
8113dcf4:	1001703a 	wrctl	status,r2
  
  return context;
8113dcf8:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113dcfc:	e0bff615 	stw	r2,-40(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
8113dd00:	e0bffd17 	ldw	r2,-12(fp)
8113dd04:	10800117 	ldw	r2,4(r2)
8113dd08:	e0bff815 	stw	r2,-32(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
8113dd0c:	e0bff817 	ldw	r2,-32(fp)
8113dd10:	1080058b 	ldhu	r2,22(r2)
8113dd14:	10bfffcc 	andi	r2,r2,65535
8113dd18:	10001e26 	beq	r2,zero,8113dd94 <OSQPend+0x174>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
8113dd1c:	e0bff817 	ldw	r2,-32(fp)
8113dd20:	10800417 	ldw	r2,16(r2)
8113dd24:	11000104 	addi	r4,r2,4
8113dd28:	e0fff817 	ldw	r3,-32(fp)
8113dd2c:	19000415 	stw	r4,16(r3)
8113dd30:	10800017 	ldw	r2,0(r2)
8113dd34:	e0bff515 	stw	r2,-44(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
8113dd38:	e0bff817 	ldw	r2,-32(fp)
8113dd3c:	1080058b 	ldhu	r2,22(r2)
8113dd40:	10bfffc4 	addi	r2,r2,-1
8113dd44:	1007883a 	mov	r3,r2
8113dd48:	e0bff817 	ldw	r2,-32(fp)
8113dd4c:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
8113dd50:	e0bff817 	ldw	r2,-32(fp)
8113dd54:	10c00417 	ldw	r3,16(r2)
8113dd58:	e0bff817 	ldw	r2,-32(fp)
8113dd5c:	10800217 	ldw	r2,8(r2)
8113dd60:	1880041e 	bne	r3,r2,8113dd74 <OSQPend+0x154>
            pq->OSQOut = pq->OSQStart;
8113dd64:	e0bff817 	ldw	r2,-32(fp)
8113dd68:	10c00117 	ldw	r3,4(r2)
8113dd6c:	e0bff817 	ldw	r2,-32(fp)
8113dd70:	10c00415 	stw	r3,16(r2)
8113dd74:	e0bff617 	ldw	r2,-40(fp)
8113dd78:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113dd7c:	e0bff717 	ldw	r2,-36(fp)
8113dd80:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
8113dd84:	e0bfff17 	ldw	r2,-4(fp)
8113dd88:	10000005 	stb	zero,0(r2)
        return (pmsg);                           /* Return message received                            */
8113dd8c:	e0bff517 	ldw	r2,-44(fp)
8113dd90:	00004306 	br	8113dea0 <OSQPend+0x280>
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
8113dd94:	d0a0a217 	ldw	r2,-32120(gp)
8113dd98:	d0e0a217 	ldw	r3,-32120(gp)
8113dd9c:	18c00c03 	ldbu	r3,48(r3)
8113dda0:	18c00114 	ori	r3,r3,4
8113dda4:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113dda8:	d0a0a217 	ldw	r2,-32120(gp)
8113ddac:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
8113ddb0:	d0a0a217 	ldw	r2,-32120(gp)
8113ddb4:	e0fffe0b 	ldhu	r3,-8(fp)
8113ddb8:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
8113ddbc:	e13ffd17 	ldw	r4,-12(fp)
8113ddc0:	113934c0 	call	8113934c <OS_EventTaskWait>
8113ddc4:	e0bff617 	ldw	r2,-40(fp)
8113ddc8:	e0bffb15 	stw	r2,-20(fp)
8113ddcc:	e0bffb17 	ldw	r2,-20(fp)
8113ddd0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                  /* Find next highest priority task ready to run       */
8113ddd4:	1139c680 	call	81139c68 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ddd8:	0005303a 	rdctl	r2,status
8113dddc:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113dde0:	e0fff917 	ldw	r3,-28(fp)
8113dde4:	00bfff84 	movi	r2,-2
8113dde8:	1884703a 	and	r2,r3,r2
8113ddec:	1001703a 	wrctl	status,r2
  
  return context;
8113ddf0:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
8113ddf4:	e0bff615 	stw	r2,-40(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
8113ddf8:	d0a0a217 	ldw	r2,-32120(gp)
8113ddfc:	10800c43 	ldbu	r2,49(r2)
8113de00:	10803fcc 	andi	r2,r2,255
8113de04:	10000326 	beq	r2,zero,8113de14 <OSQPend+0x1f4>
8113de08:	108000a0 	cmpeqi	r2,r2,2
8113de0c:	1000071e 	bne	r2,zero,8113de2c <OSQPend+0x20c>
8113de10:	00000b06 	br	8113de40 <OSQPend+0x220>
        case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
             pmsg =  OSTCBCur->OSTCBMsg;
8113de14:	d0a0a217 	ldw	r2,-32120(gp)
8113de18:	10800917 	ldw	r2,36(r2)
8113de1c:	e0bff515 	stw	r2,-44(fp)
            *perr =  OS_ERR_NONE;
8113de20:	e0bfff17 	ldw	r2,-4(fp)
8113de24:	10000005 	stb	zero,0(r2)
             break;
8113de28:	00000e06 	br	8113de64 <OSQPend+0x244>

        case OS_STAT_PEND_ABORT:
             pmsg = (void *)0;
8113de2c:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
8113de30:	e0bfff17 	ldw	r2,-4(fp)
8113de34:	00c00384 	movi	r3,14
8113de38:	10c00005 	stb	r3,0(r2)
             break;
8113de3c:	00000906 	br	8113de64 <OSQPend+0x244>

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
8113de40:	d0a0a217 	ldw	r2,-32120(gp)
8113de44:	e17ffd17 	ldw	r5,-12(fp)
8113de48:	1009883a 	mov	r4,r2
8113de4c:	11395bc0 	call	811395bc <OS_EventTaskRemove>
             pmsg = (void *)0;
8113de50:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
8113de54:	e0bfff17 	ldw	r2,-4(fp)
8113de58:	00c00284 	movi	r3,10
8113de5c:	10c00005 	stb	r3,0(r2)
             break;
8113de60:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
8113de64:	d0a0a217 	ldw	r2,-32120(gp)
8113de68:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
8113de6c:	d0a0a217 	ldw	r2,-32120(gp)
8113de70:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
8113de74:	d0a0a217 	ldw	r2,-32120(gp)
8113de78:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8113de7c:	d0a0a217 	ldw	r2,-32120(gp)
8113de80:	10000815 	stw	zero,32(r2)
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
8113de84:	d0a0a217 	ldw	r2,-32120(gp)
8113de88:	10000915 	stw	zero,36(r2)
8113de8c:	e0bff617 	ldw	r2,-40(fp)
8113de90:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113de94:	e0bffa17 	ldw	r2,-24(fp)
8113de98:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (pmsg);                                    /* Return received message                       */
8113de9c:	e0bff517 	ldw	r2,-44(fp)
}
8113dea0:	e037883a 	mov	sp,fp
8113dea4:	dfc00117 	ldw	ra,4(sp)
8113dea8:	df000017 	ldw	fp,0(sp)
8113deac:	dec00204 	addi	sp,sp,8
8113deb0:	f800283a 	ret

8113deb4 <OSQPendAbort>:
*********************************************************************************************************
*/

#if OS_Q_PEND_ABORT_EN > 0
INT8U  OSQPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113deb4:	defff604 	addi	sp,sp,-40
8113deb8:	de00012e 	bgeu	sp,et,8113dec0 <OSQPendAbort+0xc>
8113debc:	003b68fa 	trap	3
8113dec0:	dfc00915 	stw	ra,36(sp)
8113dec4:	df000815 	stw	fp,32(sp)
8113dec8:	df000804 	addi	fp,sp,32
8113decc:	e13ffd15 	stw	r4,-12(fp)
8113ded0:	2805883a 	mov	r2,r5
8113ded4:	e1bfff15 	stw	r6,-4(fp)
8113ded8:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113dedc:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113dee0:	e0bfff17 	ldw	r2,-4(fp)
8113dee4:	1000021e 	bne	r2,zero,8113def0 <OSQPendAbort+0x3c>
        return (0);
8113dee8:	0005883a 	mov	r2,zero
8113deec:	00004906 	br	8113e014 <OSQPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113def0:	e0bffd17 	ldw	r2,-12(fp)
8113def4:	1000051e 	bne	r2,zero,8113df0c <OSQPendAbort+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113def8:	e0bfff17 	ldw	r2,-4(fp)
8113defc:	00c00104 	movi	r3,4
8113df00:	10c00005 	stb	r3,0(r2)
        return (0);
8113df04:	0005883a 	mov	r2,zero
8113df08:	00004206 	br	8113e014 <OSQPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
8113df0c:	e0bffd17 	ldw	r2,-12(fp)
8113df10:	10800003 	ldbu	r2,0(r2)
8113df14:	10803fcc 	andi	r2,r2,255
8113df18:	108000a0 	cmpeqi	r2,r2,2
8113df1c:	1000051e 	bne	r2,zero,8113df34 <OSQPendAbort+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113df20:	e0bfff17 	ldw	r2,-4(fp)
8113df24:	00c00044 	movi	r3,1
8113df28:	10c00005 	stb	r3,0(r2)
        return (0);
8113df2c:	0005883a 	mov	r2,zero
8113df30:	00003806 	br	8113e014 <OSQPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113df34:	0005303a 	rdctl	r2,status
8113df38:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113df3c:	e0fffc17 	ldw	r3,-16(fp)
8113df40:	00bfff84 	movi	r2,-2
8113df44:	1884703a 	and	r2,r3,r2
8113df48:	1001703a 	wrctl	status,r2
  
  return context;
8113df4c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113df50:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
8113df54:	e0bffd17 	ldw	r2,-12(fp)
8113df58:	10800283 	ldbu	r2,10(r2)
8113df5c:	10803fcc 	andi	r2,r2,255
8113df60:	10002526 	beq	r2,zero,8113dff8 <OSQPendAbort+0x144>
        nbr_tasks = 0;
8113df64:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
8113df68:	e0bffe03 	ldbu	r2,-8(fp)
8113df6c:	10800060 	cmpeqi	r2,r2,1
8113df70:	10000e26 	beq	r2,zero,8113dfac <OSQPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
8113df74:	00000806 	br	8113df98 <OSQPendAbort+0xe4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
8113df78:	01c00084 	movi	r7,2
8113df7c:	01800104 	movi	r6,4
8113df80:	000b883a 	mov	r5,zero
8113df84:	e13ffd17 	ldw	r4,-12(fp)
8113df88:	11391ac0 	call	811391ac <OS_EventTaskRdy>
                     nbr_tasks++;
8113df8c:	e0bff803 	ldbu	r2,-32(fp)
8113df90:	10800044 	addi	r2,r2,1
8113df94:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
8113df98:	e0bffd17 	ldw	r2,-12(fp)
8113df9c:	10800283 	ldbu	r2,10(r2)
8113dfa0:	10803fcc 	andi	r2,r2,255
8113dfa4:	103ff41e 	bne	r2,zero,8113df78 <__reset+0xfb11df78>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
8113dfa8:	00000906 	br	8113dfd0 <OSQPendAbort+0x11c>
               
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on queue    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
8113dfac:	01c00084 	movi	r7,2
8113dfb0:	01800104 	movi	r6,4
8113dfb4:	000b883a 	mov	r5,zero
8113dfb8:	e13ffd17 	ldw	r4,-12(fp)
8113dfbc:	11391ac0 	call	811391ac <OS_EventTaskRdy>
                 nbr_tasks++;
8113dfc0:	e0bff803 	ldbu	r2,-32(fp)
8113dfc4:	10800044 	addi	r2,r2,1
8113dfc8:	e0bff805 	stb	r2,-32(fp)
                 break;
8113dfcc:	0001883a 	nop
8113dfd0:	e0bff917 	ldw	r2,-28(fp)
8113dfd4:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113dfd8:	e0bffa17 	ldw	r2,-24(fp)
8113dfdc:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                        /* Find HPT ready to run                    */
8113dfe0:	1139c680 	call	81139c68 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
8113dfe4:	e0bfff17 	ldw	r2,-4(fp)
8113dfe8:	00c00384 	movi	r3,14
8113dfec:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
8113dff0:	e0bff803 	ldbu	r2,-32(fp)
8113dff4:	00000706 	br	8113e014 <OSQPendAbort+0x160>
8113dff8:	e0bff917 	ldw	r2,-28(fp)
8113dffc:	e0bffb15 	stw	r2,-20(fp)
8113e000:	e0bffb17 	ldw	r2,-20(fp)
8113e004:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113e008:	e0bfff17 	ldw	r2,-4(fp)
8113e00c:	10000005 	stb	zero,0(r2)
    return (0);                                            /* No tasks waiting on queue                */
8113e010:	0005883a 	mov	r2,zero
}
8113e014:	e037883a 	mov	sp,fp
8113e018:	dfc00117 	ldw	ra,4(sp)
8113e01c:	df000017 	ldw	fp,0(sp)
8113e020:	dec00204 	addi	sp,sp,8
8113e024:	f800283a 	ret

8113e028 <OSQPost>:
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *pmsg)
{
8113e028:	defff604 	addi	sp,sp,-40
8113e02c:	de00012e 	bgeu	sp,et,8113e034 <OSQPost+0xc>
8113e030:	003b68fa 	trap	3
8113e034:	dfc00915 	stw	ra,36(sp)
8113e038:	df000815 	stw	fp,32(sp)
8113e03c:	df000804 	addi	fp,sp,32
8113e040:	e13ffe15 	stw	r4,-8(fp)
8113e044:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113e048:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
8113e04c:	e0bffe17 	ldw	r2,-8(fp)
8113e050:	1000021e 	bne	r2,zero,8113e05c <OSQPost+0x34>
        return (OS_ERR_PEVENT_NULL);
8113e054:	00800104 	movi	r2,4
8113e058:	00004a06 	br	8113e184 <OSQPost+0x15c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
8113e05c:	e0bffe17 	ldw	r2,-8(fp)
8113e060:	10800003 	ldbu	r2,0(r2)
8113e064:	10803fcc 	andi	r2,r2,255
8113e068:	108000a0 	cmpeqi	r2,r2,2
8113e06c:	1000021e 	bne	r2,zero,8113e078 <OSQPost+0x50>
        return (OS_ERR_EVENT_TYPE);
8113e070:	00800044 	movi	r2,1
8113e074:	00004306 	br	8113e184 <OSQPost+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e078:	0005303a 	rdctl	r2,status
8113e07c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e080:	e0fffd17 	ldw	r3,-12(fp)
8113e084:	00bfff84 	movi	r2,-2
8113e088:	1884703a 	and	r2,r3,r2
8113e08c:	1001703a 	wrctl	status,r2
  
  return context;
8113e090:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113e094:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                     /* See if any task pending on queue             */
8113e098:	e0bffe17 	ldw	r2,-8(fp)
8113e09c:	10800283 	ldbu	r2,10(r2)
8113e0a0:	10803fcc 	andi	r2,r2,255
8113e0a4:	10000c26 	beq	r2,zero,8113e0d8 <OSQPost+0xb0>
                                                       /* Ready highest priority task waiting on event */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8113e0a8:	000f883a 	mov	r7,zero
8113e0ac:	01800104 	movi	r6,4
8113e0b0:	e17fff17 	ldw	r5,-4(fp)
8113e0b4:	e13ffe17 	ldw	r4,-8(fp)
8113e0b8:	11391ac0 	call	811391ac <OS_EventTaskRdy>
8113e0bc:	e0bff817 	ldw	r2,-32(fp)
8113e0c0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e0c4:	e0bff917 	ldw	r2,-28(fp)
8113e0c8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                    /* Find highest priority task ready to run      */
8113e0cc:	1139c680 	call	81139c68 <OS_Sched>
        return (OS_ERR_NONE);
8113e0d0:	0005883a 	mov	r2,zero
8113e0d4:	00002b06 	br	8113e184 <OSQPost+0x15c>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
8113e0d8:	e0bffe17 	ldw	r2,-8(fp)
8113e0dc:	10800117 	ldw	r2,4(r2)
8113e0e0:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
8113e0e4:	e0bffb17 	ldw	r2,-20(fp)
8113e0e8:	10c0058b 	ldhu	r3,22(r2)
8113e0ec:	e0bffb17 	ldw	r2,-20(fp)
8113e0f0:	1080050b 	ldhu	r2,20(r2)
8113e0f4:	18ffffcc 	andi	r3,r3,65535
8113e0f8:	10bfffcc 	andi	r2,r2,65535
8113e0fc:	18800636 	bltu	r3,r2,8113e118 <OSQPost+0xf0>
8113e100:	e0bff817 	ldw	r2,-32(fp)
8113e104:	e0bffa15 	stw	r2,-24(fp)
8113e108:	e0bffa17 	ldw	r2,-24(fp)
8113e10c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
8113e110:	00800784 	movi	r2,30
8113e114:	00001b06 	br	8113e184 <OSQPost+0x15c>
    }
    *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
8113e118:	e0bffb17 	ldw	r2,-20(fp)
8113e11c:	10800317 	ldw	r2,12(r2)
8113e120:	11000104 	addi	r4,r2,4
8113e124:	e0fffb17 	ldw	r3,-20(fp)
8113e128:	19000315 	stw	r4,12(r3)
8113e12c:	e0ffff17 	ldw	r3,-4(fp)
8113e130:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
8113e134:	e0bffb17 	ldw	r2,-20(fp)
8113e138:	1080058b 	ldhu	r2,22(r2)
8113e13c:	10800044 	addi	r2,r2,1
8113e140:	1007883a 	mov	r3,r2
8113e144:	e0bffb17 	ldw	r2,-20(fp)
8113e148:	10c0058d 	sth	r3,22(r2)
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
8113e14c:	e0bffb17 	ldw	r2,-20(fp)
8113e150:	10c00317 	ldw	r3,12(r2)
8113e154:	e0bffb17 	ldw	r2,-20(fp)
8113e158:	10800217 	ldw	r2,8(r2)
8113e15c:	1880041e 	bne	r3,r2,8113e170 <OSQPost+0x148>
        pq->OSQIn = pq->OSQStart;
8113e160:	e0bffb17 	ldw	r2,-20(fp)
8113e164:	10c00117 	ldw	r3,4(r2)
8113e168:	e0bffb17 	ldw	r2,-20(fp)
8113e16c:	10c00315 	stw	r3,12(r2)
8113e170:	e0bff817 	ldw	r2,-32(fp)
8113e174:	e0bffc15 	stw	r2,-16(fp)
8113e178:	e0bffc17 	ldw	r2,-16(fp)
8113e17c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113e180:	0005883a 	mov	r2,zero
}
8113e184:	e037883a 	mov	sp,fp
8113e188:	dfc00117 	ldw	ra,4(sp)
8113e18c:	df000017 	ldw	fp,0(sp)
8113e190:	dec00204 	addi	sp,sp,8
8113e194:	f800283a 	ret

8113e198 <OSQPostFront>:
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *pmsg)
{
8113e198:	defff604 	addi	sp,sp,-40
8113e19c:	de00012e 	bgeu	sp,et,8113e1a4 <OSQPostFront+0xc>
8113e1a0:	003b68fa 	trap	3
8113e1a4:	dfc00915 	stw	ra,36(sp)
8113e1a8:	df000815 	stw	fp,32(sp)
8113e1ac:	df000804 	addi	fp,sp,32
8113e1b0:	e13ffe15 	stw	r4,-8(fp)
8113e1b4:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113e1b8:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113e1bc:	e0bffe17 	ldw	r2,-8(fp)
8113e1c0:	1000021e 	bne	r2,zero,8113e1cc <OSQPostFront+0x34>
        return (OS_ERR_PEVENT_NULL);
8113e1c4:	00800104 	movi	r2,4
8113e1c8:	00004c06 	br	8113e2fc <OSQPostFront+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
8113e1cc:	e0bffe17 	ldw	r2,-8(fp)
8113e1d0:	10800003 	ldbu	r2,0(r2)
8113e1d4:	10803fcc 	andi	r2,r2,255
8113e1d8:	108000a0 	cmpeqi	r2,r2,2
8113e1dc:	1000021e 	bne	r2,zero,8113e1e8 <OSQPostFront+0x50>
        return (OS_ERR_EVENT_TYPE);
8113e1e0:	00800044 	movi	r2,1
8113e1e4:	00004506 	br	8113e2fc <OSQPostFront+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e1e8:	0005303a 	rdctl	r2,status
8113e1ec:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e1f0:	e0fffd17 	ldw	r3,-12(fp)
8113e1f4:	00bfff84 	movi	r2,-2
8113e1f8:	1884703a 	and	r2,r3,r2
8113e1fc:	1001703a 	wrctl	status,r2
  
  return context;
8113e200:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113e204:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on queue              */
8113e208:	e0bffe17 	ldw	r2,-8(fp)
8113e20c:	10800283 	ldbu	r2,10(r2)
8113e210:	10803fcc 	andi	r2,r2,255
8113e214:	10000c26 	beq	r2,zero,8113e248 <OSQPostFront+0xb0>
                                                      /* Ready highest priority task waiting on event  */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8113e218:	000f883a 	mov	r7,zero
8113e21c:	01800104 	movi	r6,4
8113e220:	e17fff17 	ldw	r5,-4(fp)
8113e224:	e13ffe17 	ldw	r4,-8(fp)
8113e228:	11391ac0 	call	811391ac <OS_EventTaskRdy>
8113e22c:	e0bff817 	ldw	r2,-32(fp)
8113e230:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e234:	e0bff917 	ldw	r2,-28(fp)
8113e238:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find highest priority task ready to run       */
8113e23c:	1139c680 	call	81139c68 <OS_Sched>
        return (OS_ERR_NONE);
8113e240:	0005883a 	mov	r2,zero
8113e244:	00002d06 	br	8113e2fc <OSQPostFront+0x164>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
8113e248:	e0bffe17 	ldw	r2,-8(fp)
8113e24c:	10800117 	ldw	r2,4(r2)
8113e250:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
8113e254:	e0bffb17 	ldw	r2,-20(fp)
8113e258:	10c0058b 	ldhu	r3,22(r2)
8113e25c:	e0bffb17 	ldw	r2,-20(fp)
8113e260:	1080050b 	ldhu	r2,20(r2)
8113e264:	18ffffcc 	andi	r3,r3,65535
8113e268:	10bfffcc 	andi	r2,r2,65535
8113e26c:	18800636 	bltu	r3,r2,8113e288 <OSQPostFront+0xf0>
8113e270:	e0bff817 	ldw	r2,-32(fp)
8113e274:	e0bffa15 	stw	r2,-24(fp)
8113e278:	e0bffa17 	ldw	r2,-24(fp)
8113e27c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
8113e280:	00800784 	movi	r2,30
8113e284:	00001d06 	br	8113e2fc <OSQPostFront+0x164>
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
8113e288:	e0bffb17 	ldw	r2,-20(fp)
8113e28c:	10c00417 	ldw	r3,16(r2)
8113e290:	e0bffb17 	ldw	r2,-20(fp)
8113e294:	10800117 	ldw	r2,4(r2)
8113e298:	1880041e 	bne	r3,r2,8113e2ac <OSQPostFront+0x114>
        pq->OSQOut = pq->OSQEnd;
8113e29c:	e0bffb17 	ldw	r2,-20(fp)
8113e2a0:	10c00217 	ldw	r3,8(r2)
8113e2a4:	e0bffb17 	ldw	r2,-20(fp)
8113e2a8:	10c00415 	stw	r3,16(r2)
    }
    pq->OSQOut--;
8113e2ac:	e0bffb17 	ldw	r2,-20(fp)
8113e2b0:	10800417 	ldw	r2,16(r2)
8113e2b4:	10ffff04 	addi	r3,r2,-4
8113e2b8:	e0bffb17 	ldw	r2,-20(fp)
8113e2bc:	10c00415 	stw	r3,16(r2)
    *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
8113e2c0:	e0bffb17 	ldw	r2,-20(fp)
8113e2c4:	10800417 	ldw	r2,16(r2)
8113e2c8:	e0ffff17 	ldw	r3,-4(fp)
8113e2cc:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
8113e2d0:	e0bffb17 	ldw	r2,-20(fp)
8113e2d4:	1080058b 	ldhu	r2,22(r2)
8113e2d8:	10800044 	addi	r2,r2,1
8113e2dc:	1007883a 	mov	r3,r2
8113e2e0:	e0bffb17 	ldw	r2,-20(fp)
8113e2e4:	10c0058d 	sth	r3,22(r2)
8113e2e8:	e0bff817 	ldw	r2,-32(fp)
8113e2ec:	e0bffc15 	stw	r2,-16(fp)
8113e2f0:	e0bffc17 	ldw	r2,-16(fp)
8113e2f4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113e2f8:	0005883a 	mov	r2,zero
}
8113e2fc:	e037883a 	mov	sp,fp
8113e300:	dfc00117 	ldw	ra,4(sp)
8113e304:	df000017 	ldw	fp,0(sp)
8113e308:	dec00204 	addi	sp,sp,8
8113e30c:	f800283a 	ret

8113e310 <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
{
8113e310:	defff504 	addi	sp,sp,-44
8113e314:	de00012e 	bgeu	sp,et,8113e31c <OSQPostOpt+0xc>
8113e318:	003b68fa 	trap	3
8113e31c:	dfc00a15 	stw	ra,40(sp)
8113e320:	df000915 	stw	fp,36(sp)
8113e324:	df000904 	addi	fp,sp,36
8113e328:	e13ffd15 	stw	r4,-12(fp)
8113e32c:	e17ffe15 	stw	r5,-8(fp)
8113e330:	3005883a 	mov	r2,r6
8113e334:	e0bfff05 	stb	r2,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113e338:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113e33c:	e0bffd17 	ldw	r2,-12(fp)
8113e340:	1000021e 	bne	r2,zero,8113e34c <OSQPostOpt+0x3c>
        return (OS_ERR_PEVENT_NULL);
8113e344:	00800104 	movi	r2,4
8113e348:	00007106 	br	8113e510 <OSQPostOpt+0x200>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
8113e34c:	e0bffd17 	ldw	r2,-12(fp)
8113e350:	10800003 	ldbu	r2,0(r2)
8113e354:	10803fcc 	andi	r2,r2,255
8113e358:	108000a0 	cmpeqi	r2,r2,2
8113e35c:	1000021e 	bne	r2,zero,8113e368 <OSQPostOpt+0x58>
        return (OS_ERR_EVENT_TYPE);
8113e360:	00800044 	movi	r2,1
8113e364:	00006a06 	br	8113e510 <OSQPostOpt+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e368:	0005303a 	rdctl	r2,status
8113e36c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e370:	e0fffc17 	ldw	r3,-16(fp)
8113e374:	00bfff84 	movi	r2,-2
8113e378:	1884703a 	and	r2,r3,r2
8113e37c:	1001703a 	wrctl	status,r2
  
  return context;
8113e380:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113e384:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
8113e388:	e0bffd17 	ldw	r2,-12(fp)
8113e38c:	10800283 	ldbu	r2,10(r2)
8113e390:	10803fcc 	andi	r2,r2,255
8113e394:	10001d26 	beq	r2,zero,8113e40c <OSQPostOpt+0xfc>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
8113e398:	e0bfff03 	ldbu	r2,-4(fp)
8113e39c:	1080004c 	andi	r2,r2,1
8113e3a0:	10000b26 	beq	r2,zero,8113e3d0 <OSQPostOpt+0xc0>
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
8113e3a4:	00000506 	br	8113e3bc <OSQPostOpt+0xac>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8113e3a8:	000f883a 	mov	r7,zero
8113e3ac:	01800104 	movi	r6,4
8113e3b0:	e17ffe17 	ldw	r5,-8(fp)
8113e3b4:	e13ffd17 	ldw	r4,-12(fp)
8113e3b8:	11391ac0 	call	811391ac <OS_EventTaskRdy>
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
8113e3bc:	e0bffd17 	ldw	r2,-12(fp)
8113e3c0:	10800283 	ldbu	r2,10(r2)
8113e3c4:	10803fcc 	andi	r2,r2,255
8113e3c8:	103ff71e 	bne	r2,zero,8113e3a8 <__reset+0xfb11e3a8>
8113e3cc:	00000506 	br	8113e3e4 <OSQPostOpt+0xd4>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on queue             */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8113e3d0:	000f883a 	mov	r7,zero
8113e3d4:	01800104 	movi	r6,4
8113e3d8:	e17ffe17 	ldw	r5,-8(fp)
8113e3dc:	e13ffd17 	ldw	r4,-12(fp)
8113e3e0:	11391ac0 	call	811391ac <OS_EventTaskRdy>
8113e3e4:	e0bff717 	ldw	r2,-36(fp)
8113e3e8:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e3ec:	e0bff817 	ldw	r2,-32(fp)
8113e3f0:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
8113e3f4:	e0bfff03 	ldbu	r2,-4(fp)
8113e3f8:	1080010c 	andi	r2,r2,4
8113e3fc:	1000011e 	bne	r2,zero,8113e404 <OSQPostOpt+0xf4>
            OS_Sched();                               /* Find highest priority task ready to run       */
8113e400:	1139c680 	call	81139c68 <OS_Sched>
        }
        return (OS_ERR_NONE);
8113e404:	0005883a 	mov	r2,zero
8113e408:	00004106 	br	8113e510 <OSQPostOpt+0x200>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
8113e40c:	e0bffd17 	ldw	r2,-12(fp)
8113e410:	10800117 	ldw	r2,4(r2)
8113e414:	e0bffa15 	stw	r2,-24(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
8113e418:	e0bffa17 	ldw	r2,-24(fp)
8113e41c:	10c0058b 	ldhu	r3,22(r2)
8113e420:	e0bffa17 	ldw	r2,-24(fp)
8113e424:	1080050b 	ldhu	r2,20(r2)
8113e428:	18ffffcc 	andi	r3,r3,65535
8113e42c:	10bfffcc 	andi	r2,r2,65535
8113e430:	18800636 	bltu	r3,r2,8113e44c <OSQPostOpt+0x13c>
8113e434:	e0bff717 	ldw	r2,-36(fp)
8113e438:	e0bff915 	stw	r2,-28(fp)
8113e43c:	e0bff917 	ldw	r2,-28(fp)
8113e440:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
8113e444:	00800784 	movi	r2,30
8113e448:	00003106 	br	8113e510 <OSQPostOpt+0x200>
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
8113e44c:	e0bfff03 	ldbu	r2,-4(fp)
8113e450:	1080008c 	andi	r2,r2,2
8113e454:	10001326 	beq	r2,zero,8113e4a4 <OSQPostOpt+0x194>
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
8113e458:	e0bffa17 	ldw	r2,-24(fp)
8113e45c:	10c00417 	ldw	r3,16(r2)
8113e460:	e0bffa17 	ldw	r2,-24(fp)
8113e464:	10800117 	ldw	r2,4(r2)
8113e468:	1880041e 	bne	r3,r2,8113e47c <OSQPostOpt+0x16c>
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
8113e46c:	e0bffa17 	ldw	r2,-24(fp)
8113e470:	10c00217 	ldw	r3,8(r2)
8113e474:	e0bffa17 	ldw	r2,-24(fp)
8113e478:	10c00415 	stw	r3,16(r2)
        }
        pq->OSQOut--;
8113e47c:	e0bffa17 	ldw	r2,-24(fp)
8113e480:	10800417 	ldw	r2,16(r2)
8113e484:	10ffff04 	addi	r3,r2,-4
8113e488:	e0bffa17 	ldw	r2,-24(fp)
8113e48c:	10c00415 	stw	r3,16(r2)
        *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
8113e490:	e0bffa17 	ldw	r2,-24(fp)
8113e494:	10800417 	ldw	r2,16(r2)
8113e498:	e0fffe17 	ldw	r3,-8(fp)
8113e49c:	10c00015 	stw	r3,0(r2)
8113e4a0:	00001006 	br	8113e4e4 <OSQPostOpt+0x1d4>
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
8113e4a4:	e0bffa17 	ldw	r2,-24(fp)
8113e4a8:	10800317 	ldw	r2,12(r2)
8113e4ac:	11000104 	addi	r4,r2,4
8113e4b0:	e0fffa17 	ldw	r3,-24(fp)
8113e4b4:	19000315 	stw	r4,12(r3)
8113e4b8:	e0fffe17 	ldw	r3,-8(fp)
8113e4bc:	10c00015 	stw	r3,0(r2)
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
8113e4c0:	e0bffa17 	ldw	r2,-24(fp)
8113e4c4:	10c00317 	ldw	r3,12(r2)
8113e4c8:	e0bffa17 	ldw	r2,-24(fp)
8113e4cc:	10800217 	ldw	r2,8(r2)
8113e4d0:	1880041e 	bne	r3,r2,8113e4e4 <OSQPostOpt+0x1d4>
            pq->OSQIn = pq->OSQStart;
8113e4d4:	e0bffa17 	ldw	r2,-24(fp)
8113e4d8:	10c00117 	ldw	r3,4(r2)
8113e4dc:	e0bffa17 	ldw	r2,-24(fp)
8113e4e0:	10c00315 	stw	r3,12(r2)
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
8113e4e4:	e0bffa17 	ldw	r2,-24(fp)
8113e4e8:	1080058b 	ldhu	r2,22(r2)
8113e4ec:	10800044 	addi	r2,r2,1
8113e4f0:	1007883a 	mov	r3,r2
8113e4f4:	e0bffa17 	ldw	r2,-24(fp)
8113e4f8:	10c0058d 	sth	r3,22(r2)
8113e4fc:	e0bff717 	ldw	r2,-36(fp)
8113e500:	e0bffb15 	stw	r2,-20(fp)
8113e504:	e0bffb17 	ldw	r2,-20(fp)
8113e508:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113e50c:	0005883a 	mov	r2,zero
}
8113e510:	e037883a 	mov	sp,fp
8113e514:	dfc00117 	ldw	ra,4(sp)
8113e518:	df000017 	ldw	fp,0(sp)
8113e51c:	dec00204 	addi	sp,sp,8
8113e520:	f800283a 	ret

8113e524 <OSQQuery>:
*********************************************************************************************************
*/

#if OS_Q_QUERY_EN > 0
INT8U  OSQQuery (OS_EVENT *pevent, OS_Q_DATA *p_q_data)
{
8113e524:	defff604 	addi	sp,sp,-40
8113e528:	de00012e 	bgeu	sp,et,8113e530 <OSQQuery+0xc>
8113e52c:	003b68fa 	trap	3
8113e530:	df000915 	stw	fp,36(sp)
8113e534:	df000904 	addi	fp,sp,36
8113e538:	e13ffe15 	stw	r4,-8(fp)
8113e53c:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113e540:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
8113e544:	e0bffe17 	ldw	r2,-8(fp)
8113e548:	1000021e 	bne	r2,zero,8113e554 <OSQQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
8113e54c:	00800104 	movi	r2,4
8113e550:	00004906 	br	8113e678 <OSQQuery+0x154>
    }
    if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
8113e554:	e0bfff17 	ldw	r2,-4(fp)
8113e558:	1000021e 	bne	r2,zero,8113e564 <OSQQuery+0x40>
        return (OS_ERR_PDATA_NULL);
8113e55c:	00800244 	movi	r2,9
8113e560:	00004506 	br	8113e678 <OSQQuery+0x154>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
8113e564:	e0bffe17 	ldw	r2,-8(fp)
8113e568:	10800003 	ldbu	r2,0(r2)
8113e56c:	10803fcc 	andi	r2,r2,255
8113e570:	108000a0 	cmpeqi	r2,r2,2
8113e574:	1000021e 	bne	r2,zero,8113e580 <OSQQuery+0x5c>
        return (OS_ERR_EVENT_TYPE);
8113e578:	00800044 	movi	r2,1
8113e57c:	00003e06 	br	8113e678 <OSQQuery+0x154>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e580:	0005303a 	rdctl	r2,status
8113e584:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e588:	e0fffd17 	ldw	r3,-12(fp)
8113e58c:	00bfff84 	movi	r2,-2
8113e590:	1884703a 	and	r2,r3,r2
8113e594:	1001703a 	wrctl	status,r2
  
  return context;
8113e598:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113e59c:	e0bffa15 	stw	r2,-24(fp)
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
8113e5a0:	e0bffe17 	ldw	r2,-8(fp)
8113e5a4:	10c00283 	ldbu	r3,10(r2)
8113e5a8:	e0bfff17 	ldw	r2,-4(fp)
8113e5ac:	10c00385 	stb	r3,14(r2)
    psrc                 = &pevent->OSEventTbl[0];
8113e5b0:	e0bffe17 	ldw	r2,-8(fp)
8113e5b4:	108002c4 	addi	r2,r2,11
8113e5b8:	e0bff815 	stw	r2,-32(fp)
    pdest                = &p_q_data->OSEventTbl[0];
8113e5bc:	e0bfff17 	ldw	r2,-4(fp)
8113e5c0:	10800204 	addi	r2,r2,8
8113e5c4:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113e5c8:	e03ff705 	stb	zero,-36(fp)
8113e5cc:	00000b06 	br	8113e5fc <OSQQuery+0xd8>
        *pdest++ = *psrc++;
8113e5d0:	e0bff917 	ldw	r2,-28(fp)
8113e5d4:	10c00044 	addi	r3,r2,1
8113e5d8:	e0fff915 	stw	r3,-28(fp)
8113e5dc:	e0fff817 	ldw	r3,-32(fp)
8113e5e0:	19000044 	addi	r4,r3,1
8113e5e4:	e13ff815 	stw	r4,-32(fp)
8113e5e8:	18c00003 	ldbu	r3,0(r3)
8113e5ec:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113e5f0:	e0bff703 	ldbu	r2,-36(fp)
8113e5f4:	10800044 	addi	r2,r2,1
8113e5f8:	e0bff705 	stb	r2,-36(fp)
8113e5fc:	e0bff703 	ldbu	r2,-36(fp)
8113e600:	108001b0 	cmpltui	r2,r2,6
8113e604:	103ff21e 	bne	r2,zero,8113e5d0 <__reset+0xfb11e5d0>
        *pdest++ = *psrc++;
    }
    pq = (OS_Q *)pevent->OSEventPtr;
8113e608:	e0bffe17 	ldw	r2,-8(fp)
8113e60c:	10800117 	ldw	r2,4(r2)
8113e610:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {
8113e614:	e0bffc17 	ldw	r2,-16(fp)
8113e618:	1080058b 	ldhu	r2,22(r2)
8113e61c:	10bfffcc 	andi	r2,r2,65535
8113e620:	10000626 	beq	r2,zero,8113e63c <OSQQuery+0x118>
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
8113e624:	e0bffc17 	ldw	r2,-16(fp)
8113e628:	10800417 	ldw	r2,16(r2)
8113e62c:	10c00017 	ldw	r3,0(r2)
8113e630:	e0bfff17 	ldw	r2,-4(fp)
8113e634:	10c00015 	stw	r3,0(r2)
8113e638:	00000206 	br	8113e644 <OSQQuery+0x120>
    } else {
        p_q_data->OSMsg = (void *)0;
8113e63c:	e0bfff17 	ldw	r2,-4(fp)
8113e640:	10000015 	stw	zero,0(r2)
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
8113e644:	e0bffc17 	ldw	r2,-16(fp)
8113e648:	10c0058b 	ldhu	r3,22(r2)
8113e64c:	e0bfff17 	ldw	r2,-4(fp)
8113e650:	10c0010d 	sth	r3,4(r2)
    p_q_data->OSQSize = pq->OSQSize;
8113e654:	e0bffc17 	ldw	r2,-16(fp)
8113e658:	10c0050b 	ldhu	r3,20(r2)
8113e65c:	e0bfff17 	ldw	r2,-4(fp)
8113e660:	10c0018d 	sth	r3,6(r2)
8113e664:	e0bffa17 	ldw	r2,-24(fp)
8113e668:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e66c:	e0bffb17 	ldw	r2,-20(fp)
8113e670:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113e674:	0005883a 	mov	r2,zero
}
8113e678:	e037883a 	mov	sp,fp
8113e67c:	df000017 	ldw	fp,0(sp)
8113e680:	dec00104 	addi	sp,sp,4
8113e684:	f800283a 	ret

8113e688 <OS_QInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
8113e688:	defffb04 	addi	sp,sp,-20
8113e68c:	de00012e 	bgeu	sp,et,8113e694 <OS_QInit+0xc>
8113e690:	003b68fa 	trap	3
8113e694:	dfc00415 	stw	ra,16(sp)
8113e698:	df000315 	stw	fp,12(sp)
8113e69c:	df000304 	addi	fp,sp,12
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
8113e6a0:	0140c004 	movi	r5,768
8113e6a4:	012045f4 	movhi	r4,33047
8113e6a8:	2125ab04 	addi	r4,r4,-26964
8113e6ac:	1139b9c0 	call	81139b9c <OS_MemClr>
    pq1 = &OSQTbl[0];
8113e6b0:	00a045f4 	movhi	r2,33047
8113e6b4:	10a5ab04 	addi	r2,r2,-26964
8113e6b8:	e0bffe15 	stw	r2,-8(fp)
    pq2 = &OSQTbl[1];
8113e6bc:	00a045f4 	movhi	r2,33047
8113e6c0:	10a5b104 	addi	r2,r2,-26940
8113e6c4:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
8113e6c8:	e03ffd0d 	sth	zero,-12(fp)
8113e6cc:	00000c06 	br	8113e700 <OS_QInit+0x78>
        pq1->OSQPtr = pq2;
8113e6d0:	e0bffe17 	ldw	r2,-8(fp)
8113e6d4:	e0ffff17 	ldw	r3,-4(fp)
8113e6d8:	10c00015 	stw	r3,0(r2)
        pq1++;
8113e6dc:	e0bffe17 	ldw	r2,-8(fp)
8113e6e0:	10800604 	addi	r2,r2,24
8113e6e4:	e0bffe15 	stw	r2,-8(fp)
        pq2++;
8113e6e8:	e0bfff17 	ldw	r2,-4(fp)
8113e6ec:	10800604 	addi	r2,r2,24
8113e6f0:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
8113e6f4:	e0bffd0b 	ldhu	r2,-12(fp)
8113e6f8:	10800044 	addi	r2,r2,1
8113e6fc:	e0bffd0d 	sth	r2,-12(fp)
8113e700:	e0bffd0b 	ldhu	r2,-12(fp)
8113e704:	108007f0 	cmpltui	r2,r2,31
8113e708:	103ff11e 	bne	r2,zero,8113e6d0 <__reset+0xfb11e6d0>
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
8113e70c:	e0bffe17 	ldw	r2,-8(fp)
8113e710:	10000015 	stw	zero,0(r2)
    OSQFreeList = &OSQTbl[0];
8113e714:	00a045f4 	movhi	r2,33047
8113e718:	10a5ab04 	addi	r2,r2,-26964
8113e71c:	d0a09d15 	stw	r2,-32140(gp)
#endif
}
8113e720:	0001883a 	nop
8113e724:	e037883a 	mov	sp,fp
8113e728:	dfc00117 	ldw	ra,4(sp)
8113e72c:	df000017 	ldw	fp,0(sp)
8113e730:	dec00204 	addi	sp,sp,8
8113e734:	f800283a 	ret

8113e738 <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0
INT16U  OSSemAccept (OS_EVENT *pevent)
{
8113e738:	defffa04 	addi	sp,sp,-24
8113e73c:	de00012e 	bgeu	sp,et,8113e744 <OSSemAccept+0xc>
8113e740:	003b68fa 	trap	3
8113e744:	df000515 	stw	fp,20(sp)
8113e748:	df000504 	addi	fp,sp,20
8113e74c:	e13fff15 	stw	r4,-4(fp)
    INT16U     cnt;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113e750:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113e754:	e0bfff17 	ldw	r2,-4(fp)
8113e758:	1000021e 	bne	r2,zero,8113e764 <OSSemAccept+0x2c>
        return (0);
8113e75c:	0005883a 	mov	r2,zero
8113e760:	00001f06 	br	8113e7e0 <OSSemAccept+0xa8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113e764:	e0bfff17 	ldw	r2,-4(fp)
8113e768:	10800003 	ldbu	r2,0(r2)
8113e76c:	10803fcc 	andi	r2,r2,255
8113e770:	108000e0 	cmpeqi	r2,r2,3
8113e774:	1000021e 	bne	r2,zero,8113e780 <OSSemAccept+0x48>
        return (0);
8113e778:	0005883a 	mov	r2,zero
8113e77c:	00001806 	br	8113e7e0 <OSSemAccept+0xa8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e780:	0005303a 	rdctl	r2,status
8113e784:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e788:	e0fffe17 	ldw	r3,-8(fp)
8113e78c:	00bfff84 	movi	r2,-2
8113e790:	1884703a 	and	r2,r3,r2
8113e794:	1001703a 	wrctl	status,r2
  
  return context;
8113e798:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113e79c:	e0bffb15 	stw	r2,-20(fp)
    cnt = pevent->OSEventCnt;
8113e7a0:	e0bfff17 	ldw	r2,-4(fp)
8113e7a4:	1080020b 	ldhu	r2,8(r2)
8113e7a8:	e0bffd0d 	sth	r2,-12(fp)
    if (cnt > 0) {                                    /* See if resource is available                  */
8113e7ac:	e0bffd0b 	ldhu	r2,-12(fp)
8113e7b0:	10000626 	beq	r2,zero,8113e7cc <OSSemAccept+0x94>
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
8113e7b4:	e0bfff17 	ldw	r2,-4(fp)
8113e7b8:	1080020b 	ldhu	r2,8(r2)
8113e7bc:	10bfffc4 	addi	r2,r2,-1
8113e7c0:	1007883a 	mov	r3,r2
8113e7c4:	e0bfff17 	ldw	r2,-4(fp)
8113e7c8:	10c0020d 	sth	r3,8(r2)
8113e7cc:	e0bffb17 	ldw	r2,-20(fp)
8113e7d0:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e7d4:	e0bffc17 	ldw	r2,-16(fp)
8113e7d8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (cnt);                                     /* Return semaphore count                        */
8113e7dc:	e0bffd0b 	ldhu	r2,-12(fp)
}
8113e7e0:	e037883a 	mov	sp,fp
8113e7e4:	df000017 	ldw	fp,0(sp)
8113e7e8:	dec00104 	addi	sp,sp,4
8113e7ec:	f800283a 	ret

8113e7f0 <OSSemCreate>:
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
8113e7f0:	defff904 	addi	sp,sp,-28
8113e7f4:	de00012e 	bgeu	sp,et,8113e7fc <OSSemCreate+0xc>
8113e7f8:	003b68fa 	trap	3
8113e7fc:	dfc00615 	stw	ra,24(sp)
8113e800:	df000515 	stw	fp,20(sp)
8113e804:	df000504 	addi	fp,sp,20
8113e808:	2005883a 	mov	r2,r4
8113e80c:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113e810:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113e814:	d0a0a103 	ldbu	r2,-32124(gp)
8113e818:	10803fcc 	andi	r2,r2,255
8113e81c:	10000226 	beq	r2,zero,8113e828 <OSSemCreate+0x38>
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
8113e820:	0005883a 	mov	r2,zero
8113e824:	00002506 	br	8113e8bc <OSSemCreate+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e828:	0005303a 	rdctl	r2,status
8113e82c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e830:	e0fffe17 	ldw	r3,-8(fp)
8113e834:	00bfff84 	movi	r2,-2
8113e838:	1884703a 	and	r2,r3,r2
8113e83c:	1001703a 	wrctl	status,r2
  
  return context;
8113e840:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113e844:	e0bffb15 	stw	r2,-20(fp)
    pevent = OSEventFreeList;                              /* Get next free event control block        */
8113e848:	d0a0a017 	ldw	r2,-32128(gp)
8113e84c:	e0bffd15 	stw	r2,-12(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
8113e850:	d0a0a017 	ldw	r2,-32128(gp)
8113e854:	10000326 	beq	r2,zero,8113e864 <OSSemCreate+0x74>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
8113e858:	d0a0a017 	ldw	r2,-32128(gp)
8113e85c:	10800117 	ldw	r2,4(r2)
8113e860:	d0a0a015 	stw	r2,-32128(gp)
8113e864:	e0bffb17 	ldw	r2,-20(fp)
8113e868:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e86c:	e0bffc17 	ldw	r2,-16(fp)
8113e870:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
8113e874:	e0bffd17 	ldw	r2,-12(fp)
8113e878:	10000f26 	beq	r2,zero,8113e8b8 <OSSemCreate+0xc8>
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
8113e87c:	e0bffd17 	ldw	r2,-12(fp)
8113e880:	00c000c4 	movi	r3,3
8113e884:	10c00005 	stb	r3,0(r2)
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
8113e888:	e0bffd17 	ldw	r2,-12(fp)
8113e88c:	e0ffff0b 	ldhu	r3,-4(fp)
8113e890:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
8113e894:	e0bffd17 	ldw	r2,-12(fp)
8113e898:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
8113e89c:	e0bffd17 	ldw	r2,-12(fp)
8113e8a0:	00c00fc4 	movi	r3,63
8113e8a4:	10c00445 	stb	r3,17(r2)
        pevent->OSEventName[1] = OS_ASCII_NUL;
8113e8a8:	e0bffd17 	ldw	r2,-12(fp)
8113e8ac:	10000485 	stb	zero,18(r2)
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
8113e8b0:	e13ffd17 	ldw	r4,-12(fp)
8113e8b4:	11397840 	call	81139784 <OS_EventWaitListInit>
    }
    return (pevent);
8113e8b8:	e0bffd17 	ldw	r2,-12(fp)
}
8113e8bc:	e037883a 	mov	sp,fp
8113e8c0:	dfc00117 	ldw	ra,4(sp)
8113e8c4:	df000017 	ldw	fp,0(sp)
8113e8c8:	dec00204 	addi	sp,sp,8
8113e8cc:	f800283a 	ret

8113e8d0 <OSSemDel>:
*********************************************************************************************************
*/

#if OS_SEM_DEL_EN > 0
OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113e8d0:	defff304 	addi	sp,sp,-52
8113e8d4:	de00012e 	bgeu	sp,et,8113e8dc <OSSemDel+0xc>
8113e8d8:	003b68fa 	trap	3
8113e8dc:	dfc00c15 	stw	ra,48(sp)
8113e8e0:	df000b15 	stw	fp,44(sp)
8113e8e4:	df000b04 	addi	fp,sp,44
8113e8e8:	e13ffd15 	stw	r4,-12(fp)
8113e8ec:	2805883a 	mov	r2,r5
8113e8f0:	e1bfff15 	stw	r6,-4(fp)
8113e8f4:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113e8f8:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113e8fc:	e0bfff17 	ldw	r2,-4(fp)
8113e900:	1000021e 	bne	r2,zero,8113e90c <OSSemDel+0x3c>
        return (pevent);
8113e904:	e0bffd17 	ldw	r2,-12(fp)
8113e908:	00007e06 	br	8113eb04 <OSSemDel+0x234>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113e90c:	e0bffd17 	ldw	r2,-12(fp)
8113e910:	1000051e 	bne	r2,zero,8113e928 <OSSemDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113e914:	e0bfff17 	ldw	r2,-4(fp)
8113e918:	00c00104 	movi	r3,4
8113e91c:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113e920:	e0bffd17 	ldw	r2,-12(fp)
8113e924:	00007706 	br	8113eb04 <OSSemDel+0x234>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
8113e928:	e0bffd17 	ldw	r2,-12(fp)
8113e92c:	10800003 	ldbu	r2,0(r2)
8113e930:	10803fcc 	andi	r2,r2,255
8113e934:	108000e0 	cmpeqi	r2,r2,3
8113e938:	1000051e 	bne	r2,zero,8113e950 <OSSemDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113e93c:	e0bfff17 	ldw	r2,-4(fp)
8113e940:	00c00044 	movi	r3,1
8113e944:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113e948:	e0bffd17 	ldw	r2,-12(fp)
8113e94c:	00006d06 	br	8113eb04 <OSSemDel+0x234>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113e950:	d0a0a103 	ldbu	r2,-32124(gp)
8113e954:	10803fcc 	andi	r2,r2,255
8113e958:	10000526 	beq	r2,zero,8113e970 <OSSemDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
8113e95c:	e0bfff17 	ldw	r2,-4(fp)
8113e960:	00c003c4 	movi	r3,15
8113e964:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113e968:	e0bffd17 	ldw	r2,-12(fp)
8113e96c:	00006506 	br	8113eb04 <OSSemDel+0x234>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e970:	0005303a 	rdctl	r2,status
8113e974:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e978:	e0fffc17 	ldw	r3,-16(fp)
8113e97c:	00bfff84 	movi	r2,-2
8113e980:	1884703a 	and	r2,r3,r2
8113e984:	1001703a 	wrctl	status,r2
  
  return context;
8113e988:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113e98c:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
8113e990:	e0bffd17 	ldw	r2,-12(fp)
8113e994:	10800283 	ldbu	r2,10(r2)
8113e998:	10803fcc 	andi	r2,r2,255
8113e99c:	10000326 	beq	r2,zero,8113e9ac <OSSemDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8113e9a0:	00800044 	movi	r2,1
8113e9a4:	e0bff505 	stb	r2,-44(fp)
8113e9a8:	00000106 	br	8113e9b0 <OSSemDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8113e9ac:	e03ff505 	stb	zero,-44(fp)
    }
    switch (opt) {
8113e9b0:	e0bffe03 	ldbu	r2,-8(fp)
8113e9b4:	10000326 	beq	r2,zero,8113e9c4 <OSSemDel+0xf4>
8113e9b8:	10800060 	cmpeqi	r2,r2,1
8113e9bc:	1000281e 	bne	r2,zero,8113ea60 <OSSemDel+0x190>
8113e9c0:	00004506 	br	8113ead8 <OSSemDel+0x208>
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == OS_FALSE) {
8113e9c4:	e0bff503 	ldbu	r2,-44(fp)
8113e9c8:	1000161e 	bne	r2,zero,8113ea24 <OSSemDel+0x154>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
8113e9cc:	e0bffd17 	ldw	r2,-12(fp)
8113e9d0:	00c00fc4 	movi	r3,63
8113e9d4:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
8113e9d8:	e0bffd17 	ldw	r2,-12(fp)
8113e9dc:	10000485 	stb	zero,18(r2)
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113e9e0:	e0bffd17 	ldw	r2,-12(fp)
8113e9e4:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
8113e9e8:	d0e0a017 	ldw	r3,-32128(gp)
8113e9ec:	e0bffd17 	ldw	r2,-12(fp)
8113e9f0:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
8113e9f4:	e0bffd17 	ldw	r2,-12(fp)
8113e9f8:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
8113e9fc:	e0bffd17 	ldw	r2,-12(fp)
8113ea00:	d0a0a015 	stw	r2,-32128(gp)
8113ea04:	e0bff717 	ldw	r2,-36(fp)
8113ea08:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ea0c:	e0bff817 	ldw	r2,-32(fp)
8113ea10:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
8113ea14:	e0bfff17 	ldw	r2,-4(fp)
8113ea18:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
8113ea1c:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
8113ea20:	00003706 	br	8113eb00 <OSSemDel+0x230>
8113ea24:	e0bff717 	ldw	r2,-36(fp)
8113ea28:	e0bff915 	stw	r2,-28(fp)
8113ea2c:	e0bff917 	ldw	r2,-28(fp)
8113ea30:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
8113ea34:	e0bfff17 	ldw	r2,-4(fp)
8113ea38:	00c01244 	movi	r3,73
8113ea3c:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
8113ea40:	e0bffd17 	ldw	r2,-12(fp)
8113ea44:	e0bff615 	stw	r2,-40(fp)
             }
             break;
8113ea48:	00002d06 	br	8113eb00 <OSSemDel+0x230>

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
8113ea4c:	000f883a 	mov	r7,zero
8113ea50:	01800044 	movi	r6,1
8113ea54:	000b883a 	mov	r5,zero
8113ea58:	e13ffd17 	ldw	r4,-12(fp)
8113ea5c:	11391ac0 	call	811391ac <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
8113ea60:	e0bffd17 	ldw	r2,-12(fp)
8113ea64:	10800283 	ldbu	r2,10(r2)
8113ea68:	10803fcc 	andi	r2,r2,255
8113ea6c:	103ff71e 	bne	r2,zero,8113ea4c <__reset+0xfb11ea4c>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
8113ea70:	e0bffd17 	ldw	r2,-12(fp)
8113ea74:	00c00fc4 	movi	r3,63
8113ea78:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
8113ea7c:	e0bffd17 	ldw	r2,-12(fp)
8113ea80:	10000485 	stb	zero,18(r2)
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113ea84:	e0bffd17 	ldw	r2,-12(fp)
8113ea88:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
8113ea8c:	d0e0a017 	ldw	r3,-32128(gp)
8113ea90:	e0bffd17 	ldw	r2,-12(fp)
8113ea94:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
8113ea98:	e0bffd17 	ldw	r2,-12(fp)
8113ea9c:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
8113eaa0:	e0bffd17 	ldw	r2,-12(fp)
8113eaa4:	d0a0a015 	stw	r2,-32128(gp)
8113eaa8:	e0bff717 	ldw	r2,-36(fp)
8113eaac:	e0bffa15 	stw	r2,-24(fp)
8113eab0:	e0bffa17 	ldw	r2,-24(fp)
8113eab4:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8113eab8:	e0bff503 	ldbu	r2,-44(fp)
8113eabc:	10800058 	cmpnei	r2,r2,1
8113eac0:	1000011e 	bne	r2,zero,8113eac8 <OSSemDel+0x1f8>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8113eac4:	1139c680 	call	81139c68 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
8113eac8:	e0bfff17 	ldw	r2,-4(fp)
8113eacc:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
8113ead0:	e03ff615 	stw	zero,-40(fp)
             break;
8113ead4:	00000a06 	br	8113eb00 <OSSemDel+0x230>
8113ead8:	e0bff717 	ldw	r2,-36(fp)
8113eadc:	e0bffb15 	stw	r2,-20(fp)
8113eae0:	e0bffb17 	ldw	r2,-20(fp)
8113eae4:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
8113eae8:	e0bfff17 	ldw	r2,-4(fp)
8113eaec:	00c001c4 	movi	r3,7
8113eaf0:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
8113eaf4:	e0bffd17 	ldw	r2,-12(fp)
8113eaf8:	e0bff615 	stw	r2,-40(fp)
             break;
8113eafc:	0001883a 	nop
    }
    return (pevent_return);
8113eb00:	e0bff617 	ldw	r2,-40(fp)
}
8113eb04:	e037883a 	mov	sp,fp
8113eb08:	dfc00117 	ldw	ra,4(sp)
8113eb0c:	df000017 	ldw	fp,0(sp)
8113eb10:	dec00204 	addi	sp,sp,8
8113eb14:	f800283a 	ret

8113eb18 <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/
/*$PAGE*/
void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
8113eb18:	defff504 	addi	sp,sp,-44
8113eb1c:	de00012e 	bgeu	sp,et,8113eb24 <OSSemPend+0xc>
8113eb20:	003b68fa 	trap	3
8113eb24:	dfc00a15 	stw	ra,40(sp)
8113eb28:	df000915 	stw	fp,36(sp)
8113eb2c:	df000904 	addi	fp,sp,36
8113eb30:	e13ffd15 	stw	r4,-12(fp)
8113eb34:	2805883a 	mov	r2,r5
8113eb38:	e1bfff15 	stw	r6,-4(fp)
8113eb3c:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113eb40:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113eb44:	e0bfff17 	ldw	r2,-4(fp)
8113eb48:	10007226 	beq	r2,zero,8113ed14 <OSSemPend+0x1fc>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113eb4c:	e0bffd17 	ldw	r2,-12(fp)
8113eb50:	1000041e 	bne	r2,zero,8113eb64 <OSSemPend+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113eb54:	e0bfff17 	ldw	r2,-4(fp)
8113eb58:	00c00104 	movi	r3,4
8113eb5c:	10c00005 	stb	r3,0(r2)
        return;
8113eb60:	00006d06 	br	8113ed18 <OSSemPend+0x200>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113eb64:	e0bffd17 	ldw	r2,-12(fp)
8113eb68:	10800003 	ldbu	r2,0(r2)
8113eb6c:	10803fcc 	andi	r2,r2,255
8113eb70:	108000e0 	cmpeqi	r2,r2,3
8113eb74:	1000041e 	bne	r2,zero,8113eb88 <OSSemPend+0x70>
        *perr = OS_ERR_EVENT_TYPE;
8113eb78:	e0bfff17 	ldw	r2,-4(fp)
8113eb7c:	00c00044 	movi	r3,1
8113eb80:	10c00005 	stb	r3,0(r2)
        return;
8113eb84:	00006406 	br	8113ed18 <OSSemPend+0x200>
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
8113eb88:	d0a0a103 	ldbu	r2,-32124(gp)
8113eb8c:	10803fcc 	andi	r2,r2,255
8113eb90:	10000426 	beq	r2,zero,8113eba4 <OSSemPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
8113eb94:	e0bfff17 	ldw	r2,-4(fp)
8113eb98:	00c00084 	movi	r3,2
8113eb9c:	10c00005 	stb	r3,0(r2)
        return;
8113eba0:	00005d06 	br	8113ed18 <OSSemPend+0x200>
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
8113eba4:	d0a08f03 	ldbu	r2,-32196(gp)
8113eba8:	10803fcc 	andi	r2,r2,255
8113ebac:	10000426 	beq	r2,zero,8113ebc0 <OSSemPend+0xa8>
        *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
8113ebb0:	e0bfff17 	ldw	r2,-4(fp)
8113ebb4:	00c00344 	movi	r3,13
8113ebb8:	10c00005 	stb	r3,0(r2)
        return;
8113ebbc:	00005606 	br	8113ed18 <OSSemPend+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ebc0:	0005303a 	rdctl	r2,status
8113ebc4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ebc8:	e0fffc17 	ldw	r3,-16(fp)
8113ebcc:	00bfff84 	movi	r2,-2
8113ebd0:	1884703a 	and	r2,r3,r2
8113ebd4:	1001703a 	wrctl	status,r2
  
  return context;
8113ebd8:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113ebdc:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
8113ebe0:	e0bffd17 	ldw	r2,-12(fp)
8113ebe4:	1080020b 	ldhu	r2,8(r2)
8113ebe8:	10bfffcc 	andi	r2,r2,65535
8113ebec:	10000d26 	beq	r2,zero,8113ec24 <OSSemPend+0x10c>
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
8113ebf0:	e0bffd17 	ldw	r2,-12(fp)
8113ebf4:	1080020b 	ldhu	r2,8(r2)
8113ebf8:	10bfffc4 	addi	r2,r2,-1
8113ebfc:	1007883a 	mov	r3,r2
8113ec00:	e0bffd17 	ldw	r2,-12(fp)
8113ec04:	10c0020d 	sth	r3,8(r2)
8113ec08:	e0bff717 	ldw	r2,-36(fp)
8113ec0c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ec10:	e0bff817 	ldw	r2,-32(fp)
8113ec14:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
8113ec18:	e0bfff17 	ldw	r2,-4(fp)
8113ec1c:	10000005 	stb	zero,0(r2)
        return;
8113ec20:	00003d06 	br	8113ed18 <OSSemPend+0x200>
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
8113ec24:	d0a0a217 	ldw	r2,-32120(gp)
8113ec28:	d0e0a217 	ldw	r3,-32120(gp)
8113ec2c:	18c00c03 	ldbu	r3,48(r3)
8113ec30:	18c00054 	ori	r3,r3,1
8113ec34:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113ec38:	d0a0a217 	ldw	r2,-32120(gp)
8113ec3c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
8113ec40:	d0a0a217 	ldw	r2,-32120(gp)
8113ec44:	e0fffe0b 	ldhu	r3,-8(fp)
8113ec48:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
8113ec4c:	e13ffd17 	ldw	r4,-12(fp)
8113ec50:	113934c0 	call	8113934c <OS_EventTaskWait>
8113ec54:	e0bff717 	ldw	r2,-36(fp)
8113ec58:	e0bffb15 	stw	r2,-20(fp)
8113ec5c:	e0bffb17 	ldw	r2,-20(fp)
8113ec60:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
8113ec64:	1139c680 	call	81139c68 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ec68:	0005303a 	rdctl	r2,status
8113ec6c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ec70:	e0fff917 	ldw	r3,-28(fp)
8113ec74:	00bfff84 	movi	r2,-2
8113ec78:	1884703a 	and	r2,r3,r2
8113ec7c:	1001703a 	wrctl	status,r2
  
  return context;
8113ec80:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
8113ec84:	e0bff715 	stw	r2,-36(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
8113ec88:	d0a0a217 	ldw	r2,-32120(gp)
8113ec8c:	10800c43 	ldbu	r2,49(r2)
8113ec90:	10803fcc 	andi	r2,r2,255
8113ec94:	10000326 	beq	r2,zero,8113eca4 <OSSemPend+0x18c>
8113ec98:	108000a0 	cmpeqi	r2,r2,2
8113ec9c:	1000041e 	bne	r2,zero,8113ecb0 <OSSemPend+0x198>
8113eca0:	00000706 	br	8113ecc0 <OSSemPend+0x1a8>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
8113eca4:	e0bfff17 	ldw	r2,-4(fp)
8113eca8:	10000005 	stb	zero,0(r2)
             break;
8113ecac:	00000c06 	br	8113ece0 <OSSemPend+0x1c8>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
8113ecb0:	e0bfff17 	ldw	r2,-4(fp)
8113ecb4:	00c00384 	movi	r3,14
8113ecb8:	10c00005 	stb	r3,0(r2)
             break;
8113ecbc:	00000806 	br	8113ece0 <OSSemPend+0x1c8>

        case OS_STAT_PEND_TO:
        default:        
             OS_EventTaskRemove(OSTCBCur, pevent);
8113ecc0:	d0a0a217 	ldw	r2,-32120(gp)
8113ecc4:	e17ffd17 	ldw	r5,-12(fp)
8113ecc8:	1009883a 	mov	r4,r2
8113eccc:	11395bc0 	call	811395bc <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
8113ecd0:	e0bfff17 	ldw	r2,-4(fp)
8113ecd4:	00c00284 	movi	r3,10
8113ecd8:	10c00005 	stb	r3,0(r2)
             break;
8113ecdc:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
8113ece0:	d0a0a217 	ldw	r2,-32120(gp)
8113ece4:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
8113ece8:	d0a0a217 	ldw	r2,-32120(gp)
8113ecec:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
8113ecf0:	d0a0a217 	ldw	r2,-32120(gp)
8113ecf4:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8113ecf8:	d0a0a217 	ldw	r2,-32120(gp)
8113ecfc:	10000815 	stw	zero,32(r2)
8113ed00:	e0bff717 	ldw	r2,-36(fp)
8113ed04:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ed08:	e0bffa17 	ldw	r2,-24(fp)
8113ed0c:	1001703a 	wrctl	status,r2
8113ed10:	00000106 	br	8113ed18 <OSSemPend+0x200>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
8113ed14:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
8113ed18:	e037883a 	mov	sp,fp
8113ed1c:	dfc00117 	ldw	ra,4(sp)
8113ed20:	df000017 	ldw	fp,0(sp)
8113ed24:	dec00204 	addi	sp,sp,8
8113ed28:	f800283a 	ret

8113ed2c <OSSemPendAbort>:
*********************************************************************************************************
*/

#if OS_SEM_PEND_ABORT_EN > 0
INT8U  OSSemPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113ed2c:	defff604 	addi	sp,sp,-40
8113ed30:	de00012e 	bgeu	sp,et,8113ed38 <OSSemPendAbort+0xc>
8113ed34:	003b68fa 	trap	3
8113ed38:	dfc00915 	stw	ra,36(sp)
8113ed3c:	df000815 	stw	fp,32(sp)
8113ed40:	df000804 	addi	fp,sp,32
8113ed44:	e13ffd15 	stw	r4,-12(fp)
8113ed48:	2805883a 	mov	r2,r5
8113ed4c:	e1bfff15 	stw	r6,-4(fp)
8113ed50:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113ed54:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113ed58:	e0bfff17 	ldw	r2,-4(fp)
8113ed5c:	1000021e 	bne	r2,zero,8113ed68 <OSSemPendAbort+0x3c>
        return (0);
8113ed60:	0005883a 	mov	r2,zero
8113ed64:	00004906 	br	8113ee8c <OSSemPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113ed68:	e0bffd17 	ldw	r2,-12(fp)
8113ed6c:	1000051e 	bne	r2,zero,8113ed84 <OSSemPendAbort+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113ed70:	e0bfff17 	ldw	r2,-4(fp)
8113ed74:	00c00104 	movi	r3,4
8113ed78:	10c00005 	stb	r3,0(r2)
        return (0);
8113ed7c:	0005883a 	mov	r2,zero
8113ed80:	00004206 	br	8113ee8c <OSSemPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113ed84:	e0bffd17 	ldw	r2,-12(fp)
8113ed88:	10800003 	ldbu	r2,0(r2)
8113ed8c:	10803fcc 	andi	r2,r2,255
8113ed90:	108000e0 	cmpeqi	r2,r2,3
8113ed94:	1000051e 	bne	r2,zero,8113edac <OSSemPendAbort+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113ed98:	e0bfff17 	ldw	r2,-4(fp)
8113ed9c:	00c00044 	movi	r3,1
8113eda0:	10c00005 	stb	r3,0(r2)
        return (0);
8113eda4:	0005883a 	mov	r2,zero
8113eda8:	00003806 	br	8113ee8c <OSSemPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113edac:	0005303a 	rdctl	r2,status
8113edb0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113edb4:	e0fffc17 	ldw	r3,-16(fp)
8113edb8:	00bfff84 	movi	r2,-2
8113edbc:	1884703a 	and	r2,r3,r2
8113edc0:	1001703a 	wrctl	status,r2
  
  return context;
8113edc4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113edc8:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
8113edcc:	e0bffd17 	ldw	r2,-12(fp)
8113edd0:	10800283 	ldbu	r2,10(r2)
8113edd4:	10803fcc 	andi	r2,r2,255
8113edd8:	10002526 	beq	r2,zero,8113ee70 <OSSemPendAbort+0x144>
        nbr_tasks = 0;
8113eddc:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
8113ede0:	e0bffe03 	ldbu	r2,-8(fp)
8113ede4:	10800060 	cmpeqi	r2,r2,1
8113ede8:	10000e26 	beq	r2,zero,8113ee24 <OSSemPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
8113edec:	00000806 	br	8113ee10 <OSSemPendAbort+0xe4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
8113edf0:	01c00084 	movi	r7,2
8113edf4:	01800044 	movi	r6,1
8113edf8:	000b883a 	mov	r5,zero
8113edfc:	e13ffd17 	ldw	r4,-12(fp)
8113ee00:	11391ac0 	call	811391ac <OS_EventTaskRdy>
                     nbr_tasks++;
8113ee04:	e0bff803 	ldbu	r2,-32(fp)
8113ee08:	10800044 	addi	r2,r2,1
8113ee0c:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
8113ee10:	e0bffd17 	ldw	r2,-12(fp)
8113ee14:	10800283 	ldbu	r2,10(r2)
8113ee18:	10803fcc 	andi	r2,r2,255
8113ee1c:	103ff41e 	bne	r2,zero,8113edf0 <__reset+0xfb11edf0>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
8113ee20:	00000906 	br	8113ee48 <OSSemPendAbort+0x11c>
                 
            case OS_PEND_OPT_NONE:
            default:                                  /* No,  ready HPT       waiting on semaphore     */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
8113ee24:	01c00084 	movi	r7,2
8113ee28:	01800044 	movi	r6,1
8113ee2c:	000b883a 	mov	r5,zero
8113ee30:	e13ffd17 	ldw	r4,-12(fp)
8113ee34:	11391ac0 	call	811391ac <OS_EventTaskRdy>
                 nbr_tasks++;
8113ee38:	e0bff803 	ldbu	r2,-32(fp)
8113ee3c:	10800044 	addi	r2,r2,1
8113ee40:	e0bff805 	stb	r2,-32(fp)
                 break;
8113ee44:	0001883a 	nop
8113ee48:	e0bff917 	ldw	r2,-28(fp)
8113ee4c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ee50:	e0bffa17 	ldw	r2,-24(fp)
8113ee54:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
8113ee58:	1139c680 	call	81139c68 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
8113ee5c:	e0bfff17 	ldw	r2,-4(fp)
8113ee60:	00c00384 	movi	r3,14
8113ee64:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
8113ee68:	e0bff803 	ldbu	r2,-32(fp)
8113ee6c:	00000706 	br	8113ee8c <OSSemPendAbort+0x160>
8113ee70:	e0bff917 	ldw	r2,-28(fp)
8113ee74:	e0bffb15 	stw	r2,-20(fp)
8113ee78:	e0bffb17 	ldw	r2,-20(fp)
8113ee7c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113ee80:	e0bfff17 	ldw	r2,-4(fp)
8113ee84:	10000005 	stb	zero,0(r2)
    return (0);                                       /* No tasks waiting on semaphore                 */
8113ee88:	0005883a 	mov	r2,zero
}
8113ee8c:	e037883a 	mov	sp,fp
8113ee90:	dfc00117 	ldw	ra,4(sp)
8113ee94:	df000017 	ldw	fp,0(sp)
8113ee98:	dec00204 	addi	sp,sp,8
8113ee9c:	f800283a 	ret

8113eea0 <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
8113eea0:	defff804 	addi	sp,sp,-32
8113eea4:	de00012e 	bgeu	sp,et,8113eeac <OSSemPost+0xc>
8113eea8:	003b68fa 	trap	3
8113eeac:	dfc00715 	stw	ra,28(sp)
8113eeb0:	df000615 	stw	fp,24(sp)
8113eeb4:	df000604 	addi	fp,sp,24
8113eeb8:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113eebc:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113eec0:	e0bfff17 	ldw	r2,-4(fp)
8113eec4:	1000021e 	bne	r2,zero,8113eed0 <OSSemPost+0x30>
        return (OS_ERR_PEVENT_NULL);
8113eec8:	00800104 	movi	r2,4
8113eecc:	00003506 	br	8113efa4 <OSSemPost+0x104>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113eed0:	e0bfff17 	ldw	r2,-4(fp)
8113eed4:	10800003 	ldbu	r2,0(r2)
8113eed8:	10803fcc 	andi	r2,r2,255
8113eedc:	108000e0 	cmpeqi	r2,r2,3
8113eee0:	1000021e 	bne	r2,zero,8113eeec <OSSemPost+0x4c>
        return (OS_ERR_EVENT_TYPE);
8113eee4:	00800044 	movi	r2,1
8113eee8:	00002e06 	br	8113efa4 <OSSemPost+0x104>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113eeec:	0005303a 	rdctl	r2,status
8113eef0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113eef4:	e0fffe17 	ldw	r3,-8(fp)
8113eef8:	00bfff84 	movi	r2,-2
8113eefc:	1884703a 	and	r2,r3,r2
8113ef00:	1001703a 	wrctl	status,r2
  
  return context;
8113ef04:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113ef08:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting for semaphore         */
8113ef0c:	e0bfff17 	ldw	r2,-4(fp)
8113ef10:	10800283 	ldbu	r2,10(r2)
8113ef14:	10803fcc 	andi	r2,r2,255
8113ef18:	10000c26 	beq	r2,zero,8113ef4c <OSSemPost+0xac>
                                                      /* Ready HPT waiting on event                    */
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
8113ef1c:	000f883a 	mov	r7,zero
8113ef20:	01800044 	movi	r6,1
8113ef24:	000b883a 	mov	r5,zero
8113ef28:	e13fff17 	ldw	r4,-4(fp)
8113ef2c:	11391ac0 	call	811391ac <OS_EventTaskRdy>
8113ef30:	e0bffa17 	ldw	r2,-24(fp)
8113ef34:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ef38:	e0bffb17 	ldw	r2,-20(fp)
8113ef3c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
8113ef40:	1139c680 	call	81139c68 <OS_Sched>
        return (OS_ERR_NONE);
8113ef44:	0005883a 	mov	r2,zero
8113ef48:	00001606 	br	8113efa4 <OSSemPost+0x104>
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
8113ef4c:	e0bfff17 	ldw	r2,-4(fp)
8113ef50:	1080020b 	ldhu	r2,8(r2)
8113ef54:	10ffffcc 	andi	r3,r2,65535
8113ef58:	00bfffd4 	movui	r2,65535
8113ef5c:	18800c26 	beq	r3,r2,8113ef90 <OSSemPost+0xf0>
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
8113ef60:	e0bfff17 	ldw	r2,-4(fp)
8113ef64:	1080020b 	ldhu	r2,8(r2)
8113ef68:	10800044 	addi	r2,r2,1
8113ef6c:	1007883a 	mov	r3,r2
8113ef70:	e0bfff17 	ldw	r2,-4(fp)
8113ef74:	10c0020d 	sth	r3,8(r2)
8113ef78:	e0bffa17 	ldw	r2,-24(fp)
8113ef7c:	e0bffc15 	stw	r2,-16(fp)
8113ef80:	e0bffc17 	ldw	r2,-16(fp)
8113ef84:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
8113ef88:	0005883a 	mov	r2,zero
8113ef8c:	00000506 	br	8113efa4 <OSSemPost+0x104>
8113ef90:	e0bffa17 	ldw	r2,-24(fp)
8113ef94:	e0bffd15 	stw	r2,-12(fp)
8113ef98:	e0bffd17 	ldw	r2,-12(fp)
8113ef9c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    return (OS_ERR_SEM_OVF);
8113efa0:	00800c84 	movi	r2,50
}
8113efa4:	e037883a 	mov	sp,fp
8113efa8:	dfc00117 	ldw	ra,4(sp)
8113efac:	df000017 	ldw	fp,0(sp)
8113efb0:	dec00204 	addi	sp,sp,8
8113efb4:	f800283a 	ret

8113efb8 <OSSemQuery>:
*********************************************************************************************************
*/

#if OS_SEM_QUERY_EN > 0
INT8U  OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data)
{
8113efb8:	defff704 	addi	sp,sp,-36
8113efbc:	de00012e 	bgeu	sp,et,8113efc4 <OSSemQuery+0xc>
8113efc0:	003b68fa 	trap	3
8113efc4:	df000815 	stw	fp,32(sp)
8113efc8:	df000804 	addi	fp,sp,32
8113efcc:	e13ffe15 	stw	r4,-8(fp)
8113efd0:	e17fff15 	stw	r5,-4(fp)
    INT16U    *psrc;
    INT16U    *pdest;
#endif
    INT8U      i;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113efd4:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113efd8:	e0bffe17 	ldw	r2,-8(fp)
8113efdc:	1000021e 	bne	r2,zero,8113efe8 <OSSemQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
8113efe0:	00800104 	movi	r2,4
8113efe4:	00003606 	br	8113f0c0 <OSSemQuery+0x108>
    }
    if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
8113efe8:	e0bfff17 	ldw	r2,-4(fp)
8113efec:	1000021e 	bne	r2,zero,8113eff8 <OSSemQuery+0x40>
        return (OS_ERR_PDATA_NULL);
8113eff0:	00800244 	movi	r2,9
8113eff4:	00003206 	br	8113f0c0 <OSSemQuery+0x108>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
8113eff8:	e0bffe17 	ldw	r2,-8(fp)
8113effc:	10800003 	ldbu	r2,0(r2)
8113f000:	10803fcc 	andi	r2,r2,255
8113f004:	108000e0 	cmpeqi	r2,r2,3
8113f008:	1000021e 	bne	r2,zero,8113f014 <OSSemQuery+0x5c>
        return (OS_ERR_EVENT_TYPE);
8113f00c:	00800044 	movi	r2,1
8113f010:	00002b06 	br	8113f0c0 <OSSemQuery+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f014:	0005303a 	rdctl	r2,status
8113f018:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f01c:	e0fffd17 	ldw	r3,-12(fp)
8113f020:	00bfff84 	movi	r2,-2
8113f024:	1884703a 	and	r2,r3,r2
8113f028:	1001703a 	wrctl	status,r2
  
  return context;
8113f02c:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113f030:	e0bffb15 	stw	r2,-20(fp)
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
8113f034:	e0bffe17 	ldw	r2,-8(fp)
8113f038:	10c00283 	ldbu	r3,10(r2)
8113f03c:	e0bfff17 	ldw	r2,-4(fp)
8113f040:	10c00205 	stb	r3,8(r2)
    psrc                   = &pevent->OSEventTbl[0];
8113f044:	e0bffe17 	ldw	r2,-8(fp)
8113f048:	108002c4 	addi	r2,r2,11
8113f04c:	e0bff815 	stw	r2,-32(fp)
    pdest                  = &p_sem_data->OSEventTbl[0];
8113f050:	e0bfff17 	ldw	r2,-4(fp)
8113f054:	10800084 	addi	r2,r2,2
8113f058:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113f05c:	e03ffa05 	stb	zero,-24(fp)
8113f060:	00000b06 	br	8113f090 <OSSemQuery+0xd8>
        *pdest++ = *psrc++;
8113f064:	e0bff917 	ldw	r2,-28(fp)
8113f068:	10c00044 	addi	r3,r2,1
8113f06c:	e0fff915 	stw	r3,-28(fp)
8113f070:	e0fff817 	ldw	r3,-32(fp)
8113f074:	19000044 	addi	r4,r3,1
8113f078:	e13ff815 	stw	r4,-32(fp)
8113f07c:	18c00003 	ldbu	r3,0(r3)
8113f080:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
    psrc                   = &pevent->OSEventTbl[0];
    pdest                  = &p_sem_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113f084:	e0bffa03 	ldbu	r2,-24(fp)
8113f088:	10800044 	addi	r2,r2,1
8113f08c:	e0bffa05 	stb	r2,-24(fp)
8113f090:	e0bffa03 	ldbu	r2,-24(fp)
8113f094:	108001b0 	cmpltui	r2,r2,6
8113f098:	103ff21e 	bne	r2,zero,8113f064 <__reset+0xfb11f064>
        *pdest++ = *psrc++;
    }
    p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
8113f09c:	e0bffe17 	ldw	r2,-8(fp)
8113f0a0:	10c0020b 	ldhu	r3,8(r2)
8113f0a4:	e0bfff17 	ldw	r2,-4(fp)
8113f0a8:	10c0000d 	sth	r3,0(r2)
8113f0ac:	e0bffb17 	ldw	r2,-20(fp)
8113f0b0:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f0b4:	e0bffc17 	ldw	r2,-16(fp)
8113f0b8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113f0bc:	0005883a 	mov	r2,zero
}
8113f0c0:	e037883a 	mov	sp,fp
8113f0c4:	df000017 	ldw	fp,0(sp)
8113f0c8:	dec00104 	addi	sp,sp,4
8113f0cc:	f800283a 	ret

8113f0d0 <OSSemSet>:
*********************************************************************************************************
*/

#if OS_SEM_SET_EN > 0
void  OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *perr)
{
8113f0d0:	defff904 	addi	sp,sp,-28
8113f0d4:	de00012e 	bgeu	sp,et,8113f0dc <OSSemSet+0xc>
8113f0d8:	003b68fa 	trap	3
8113f0dc:	df000615 	stw	fp,24(sp)
8113f0e0:	df000604 	addi	fp,sp,24
8113f0e4:	e13ffd15 	stw	r4,-12(fp)
8113f0e8:	2805883a 	mov	r2,r5
8113f0ec:	e1bfff15 	stw	r6,-4(fp)
8113f0f0:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113f0f4:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113f0f8:	e0bfff17 	ldw	r2,-4(fp)
8113f0fc:	10003126 	beq	r2,zero,8113f1c4 <OSSemSet+0xf4>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113f100:	e0bffd17 	ldw	r2,-12(fp)
8113f104:	1000041e 	bne	r2,zero,8113f118 <OSSemSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
8113f108:	e0bfff17 	ldw	r2,-4(fp)
8113f10c:	00c00104 	movi	r3,4
8113f110:	10c00005 	stb	r3,0(r2)
        return;
8113f114:	00002c06 	br	8113f1c8 <OSSemSet+0xf8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113f118:	e0bffd17 	ldw	r2,-12(fp)
8113f11c:	10800003 	ldbu	r2,0(r2)
8113f120:	10803fcc 	andi	r2,r2,255
8113f124:	108000e0 	cmpeqi	r2,r2,3
8113f128:	1000041e 	bne	r2,zero,8113f13c <OSSemSet+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
8113f12c:	e0bfff17 	ldw	r2,-4(fp)
8113f130:	00c00044 	movi	r3,1
8113f134:	10c00005 	stb	r3,0(r2)
        return;
8113f138:	00002306 	br	8113f1c8 <OSSemSet+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f13c:	0005303a 	rdctl	r2,status
8113f140:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f144:	e0fffc17 	ldw	r3,-16(fp)
8113f148:	00bfff84 	movi	r2,-2
8113f14c:	1884703a 	and	r2,r3,r2
8113f150:	1001703a 	wrctl	status,r2
  
  return context;
8113f154:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113f158:	e0bffa15 	stw	r2,-24(fp)
    *perr = OS_ERR_NONE;
8113f15c:	e0bfff17 	ldw	r2,-4(fp)
8113f160:	10000005 	stb	zero,0(r2)
    if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
8113f164:	e0bffd17 	ldw	r2,-12(fp)
8113f168:	1080020b 	ldhu	r2,8(r2)
8113f16c:	10bfffcc 	andi	r2,r2,65535
8113f170:	10000426 	beq	r2,zero,8113f184 <OSSemSet+0xb4>
        pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
8113f174:	e0bffd17 	ldw	r2,-12(fp)
8113f178:	e0fffe0b 	ldhu	r3,-8(fp)
8113f17c:	10c0020d 	sth	r3,8(r2)
8113f180:	00000b06 	br	8113f1b0 <OSSemSet+0xe0>
    } else {                                          /* No                                            */
        if (pevent->OSEventGrp == 0) {                /*      See if task(s) waiting?                  */
8113f184:	e0bffd17 	ldw	r2,-12(fp)
8113f188:	10800283 	ldbu	r2,10(r2)
8113f18c:	10803fcc 	andi	r2,r2,255
8113f190:	1000041e 	bne	r2,zero,8113f1a4 <OSSemSet+0xd4>
            pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
8113f194:	e0bffd17 	ldw	r2,-12(fp)
8113f198:	e0fffe0b 	ldhu	r3,-8(fp)
8113f19c:	10c0020d 	sth	r3,8(r2)
8113f1a0:	00000306 	br	8113f1b0 <OSSemSet+0xe0>
        } else {
            *perr              = OS_ERR_TASK_WAITING;
8113f1a4:	e0bfff17 	ldw	r2,-4(fp)
8113f1a8:	00c01244 	movi	r3,73
8113f1ac:	10c00005 	stb	r3,0(r2)
8113f1b0:	e0bffa17 	ldw	r2,-24(fp)
8113f1b4:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f1b8:	e0bffb17 	ldw	r2,-20(fp)
8113f1bc:	1001703a 	wrctl	status,r2
8113f1c0:	00000106 	br	8113f1c8 <OSSemSet+0xf8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
8113f1c4:	0001883a 	nop
        } else {
            *perr              = OS_ERR_TASK_WAITING;
        }
    }
    OS_EXIT_CRITICAL();
}
8113f1c8:	e037883a 	mov	sp,fp
8113f1cc:	df000017 	ldw	fp,0(sp)
8113f1d0:	dec00104 	addi	sp,sp,4
8113f1d4:	f800283a 	ret

8113f1d8 <OSTaskChangePrio>:
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
8113f1d8:	defff104 	addi	sp,sp,-60
8113f1dc:	de00012e 	bgeu	sp,et,8113f1e4 <OSTaskChangePrio+0xc>
8113f1e0:	003b68fa 	trap	3
8113f1e4:	dfc00e15 	stw	ra,56(sp)
8113f1e8:	df000d15 	stw	fp,52(sp)
8113f1ec:	df000d04 	addi	fp,sp,52
8113f1f0:	2007883a 	mov	r3,r4
8113f1f4:	2805883a 	mov	r2,r5
8113f1f8:	e0fffe05 	stb	r3,-8(fp)
8113f1fc:	e0bfff05 	stb	r2,-4(fp)
    INT16U     bitx_new;
    INT16U     bity_old;
    INT16U     bitx_old;
#endif
#if OS_CRITICAL_METHOD == 3
    OS_CPU_SR  cpu_sr = 0;                                  /* Storage for CPU status register         */
8113f200:	e03ff515 	stw	zero,-44(fp)
#endif


/*$PAGE*/
#if OS_ARG_CHK_EN > 0
    if (oldprio >= OS_LOWEST_PRIO) {
8113f204:	e0bffe03 	ldbu	r2,-8(fp)
8113f208:	10800ab0 	cmpltui	r2,r2,42
8113f20c:	1000051e 	bne	r2,zero,8113f224 <OSTaskChangePrio+0x4c>
        if (oldprio != OS_PRIO_SELF) {
8113f210:	e0bffe03 	ldbu	r2,-8(fp)
8113f214:	10803fe0 	cmpeqi	r2,r2,255
8113f218:	1000021e 	bne	r2,zero,8113f224 <OSTaskChangePrio+0x4c>
            return (OS_ERR_PRIO_INVALID);
8113f21c:	00800a84 	movi	r2,42
8113f220:	00012606 	br	8113f6bc <OSTaskChangePrio+0x4e4>
        }
    }
    if (newprio >= OS_LOWEST_PRIO) {
8113f224:	e0bfff03 	ldbu	r2,-4(fp)
8113f228:	10800ab0 	cmpltui	r2,r2,42
8113f22c:	1000021e 	bne	r2,zero,8113f238 <OSTaskChangePrio+0x60>
        return (OS_ERR_PRIO_INVALID);
8113f230:	00800a84 	movi	r2,42
8113f234:	00012106 	br	8113f6bc <OSTaskChangePrio+0x4e4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f238:	0005303a 	rdctl	r2,status
8113f23c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f240:	e0fffd17 	ldw	r3,-12(fp)
8113f244:	00bfff84 	movi	r2,-2
8113f248:	1884703a 	and	r2,r3,r2
8113f24c:	1001703a 	wrctl	status,r2
  
  return context;
8113f250:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113f254:	e0bff515 	stw	r2,-44(fp)
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
8113f258:	e0ffff03 	ldbu	r3,-4(fp)
8113f25c:	00a045f4 	movhi	r2,33047
8113f260:	10b41904 	addi	r2,r2,-12188
8113f264:	18c7883a 	add	r3,r3,r3
8113f268:	18c7883a 	add	r3,r3,r3
8113f26c:	10c5883a 	add	r2,r2,r3
8113f270:	10800017 	ldw	r2,0(r2)
8113f274:	10000626 	beq	r2,zero,8113f290 <OSTaskChangePrio+0xb8>
8113f278:	e0bff517 	ldw	r2,-44(fp)
8113f27c:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f280:	e0bff617 	ldw	r2,-40(fp)
8113f284:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO_EXIST);
8113f288:	00800a04 	movi	r2,40
8113f28c:	00010b06 	br	8113f6bc <OSTaskChangePrio+0x4e4>
    }
    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
8113f290:	e0bffe03 	ldbu	r2,-8(fp)
8113f294:	10803fd8 	cmpnei	r2,r2,255
8113f298:	1000031e 	bne	r2,zero,8113f2a8 <OSTaskChangePrio+0xd0>
        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
8113f29c:	d0a0a217 	ldw	r2,-32120(gp)
8113f2a0:	10800c83 	ldbu	r2,50(r2)
8113f2a4:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[oldprio];
8113f2a8:	e0fffe03 	ldbu	r3,-8(fp)
8113f2ac:	00a045f4 	movhi	r2,33047
8113f2b0:	10b41904 	addi	r2,r2,-12188
8113f2b4:	18c7883a 	add	r3,r3,r3
8113f2b8:	18c7883a 	add	r3,r3,r3
8113f2bc:	10c5883a 	add	r2,r2,r3
8113f2c0:	10800017 	ldw	r2,0(r2)
8113f2c4:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
8113f2c8:	e0bff817 	ldw	r2,-32(fp)
8113f2cc:	1000061e 	bne	r2,zero,8113f2e8 <OSTaskChangePrio+0x110>
8113f2d0:	e0bff517 	ldw	r2,-44(fp)
8113f2d4:	e0bff715 	stw	r2,-36(fp)
8113f2d8:	e0bff717 	ldw	r2,-36(fp)
8113f2dc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_PRIO);
8113f2e0:	00800a44 	movi	r2,41
8113f2e4:	0000f506 	br	8113f6bc <OSTaskChangePrio+0x4e4>
    }
    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
8113f2e8:	e0bff817 	ldw	r2,-32(fp)
8113f2ec:	10800058 	cmpnei	r2,r2,1
8113f2f0:	1000061e 	bne	r2,zero,8113f30c <OSTaskChangePrio+0x134>
8113f2f4:	e0bff517 	ldw	r2,-44(fp)
8113f2f8:	e0bff915 	stw	r2,-28(fp)
8113f2fc:	e0bff917 	ldw	r2,-28(fp)
8113f300:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_TASK_NOT_EXIST);
8113f304:	008010c4 	movi	r2,67
8113f308:	0000ec06 	br	8113f6bc <OSTaskChangePrio+0x4e4>
    }
#if OS_LOWEST_PRIO <= 63
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
8113f30c:	e0bfff03 	ldbu	r2,-4(fp)
8113f310:	1004d0fa 	srli	r2,r2,3
8113f314:	e0bffb05 	stb	r2,-20(fp)
    x_new                 = (INT8U)(newprio & 0x07);
8113f318:	e0bfff03 	ldbu	r2,-4(fp)
8113f31c:	108001cc 	andi	r2,r2,7
8113f320:	e0bffb45 	stb	r2,-19(fp)
    bity_new              = (INT8U)(1 << y_new);
8113f324:	e0bffb03 	ldbu	r2,-20(fp)
8113f328:	00c00044 	movi	r3,1
8113f32c:	1884983a 	sll	r2,r3,r2
8113f330:	e0bffb85 	stb	r2,-18(fp)
    bitx_new              = (INT8U)(1 << x_new);
8113f334:	e0bffb43 	ldbu	r2,-19(fp)
8113f338:	00c00044 	movi	r3,1
8113f33c:	1884983a 	sll	r2,r3,r2
8113f340:	e0bffbc5 	stb	r2,-17(fp)
    x_new                 = (INT8U)( newprio & 0x0F);
    bity_new              = (INT16U)(1 << y_new);
    bitx_new              = (INT16U)(1 << x_new);
#endif

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
8113f344:	e0fffe03 	ldbu	r3,-8(fp)
8113f348:	00a045f4 	movhi	r2,33047
8113f34c:	10b41904 	addi	r2,r2,-12188
8113f350:	18c7883a 	add	r3,r3,r3
8113f354:	18c7883a 	add	r3,r3,r3
8113f358:	10c5883a 	add	r2,r2,r3
8113f35c:	10000015 	stw	zero,0(r2)
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
8113f360:	e0ffff03 	ldbu	r3,-4(fp)
8113f364:	00a045f4 	movhi	r2,33047
8113f368:	10b41904 	addi	r2,r2,-12188
8113f36c:	18c7883a 	add	r3,r3,r3
8113f370:	18c7883a 	add	r3,r3,r3
8113f374:	10c5883a 	add	r2,r2,r3
8113f378:	e0fff817 	ldw	r3,-32(fp)
8113f37c:	10c00015 	stw	r3,0(r2)
    y_old                 =  ptcb->OSTCBY;
8113f380:	e0bff817 	ldw	r2,-32(fp)
8113f384:	10800d03 	ldbu	r2,52(r2)
8113f388:	e0bffc05 	stb	r2,-16(fp)
    bity_old              =  ptcb->OSTCBBitY;
8113f38c:	e0bff817 	ldw	r2,-32(fp)
8113f390:	10800d83 	ldbu	r2,54(r2)
8113f394:	e0bffc45 	stb	r2,-15(fp)
    bitx_old              =  ptcb->OSTCBBitX;
8113f398:	e0bff817 	ldw	r2,-32(fp)
8113f39c:	10800d43 	ldbu	r2,53(r2)
8113f3a0:	e0bffc85 	stb	r2,-14(fp)
    if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
8113f3a4:	e0fffc03 	ldbu	r3,-16(fp)
8113f3a8:	d0a09e44 	addi	r2,gp,-32135
8113f3ac:	1885883a 	add	r2,r3,r2
8113f3b0:	10c00003 	ldbu	r3,0(r2)
8113f3b4:	e0bffc83 	ldbu	r2,-14(fp)
8113f3b8:	1884703a 	and	r2,r3,r2
8113f3bc:	10803fcc 	andi	r2,r2,255
8113f3c0:	10002826 	beq	r2,zero,8113f464 <OSTaskChangePrio+0x28c>
         OSRdyTbl[y_old] &= ~bitx_old;
8113f3c4:	e0fffc03 	ldbu	r3,-16(fp)
8113f3c8:	e13ffc03 	ldbu	r4,-16(fp)
8113f3cc:	d0a09e44 	addi	r2,gp,-32135
8113f3d0:	2085883a 	add	r2,r4,r2
8113f3d4:	10800003 	ldbu	r2,0(r2)
8113f3d8:	1009883a 	mov	r4,r2
8113f3dc:	e0bffc83 	ldbu	r2,-14(fp)
8113f3e0:	0084303a 	nor	r2,zero,r2
8113f3e4:	2084703a 	and	r2,r4,r2
8113f3e8:	1009883a 	mov	r4,r2
8113f3ec:	d0a09e44 	addi	r2,gp,-32135
8113f3f0:	1885883a 	add	r2,r3,r2
8113f3f4:	11000005 	stb	r4,0(r2)
         if (OSRdyTbl[y_old] == 0) {
8113f3f8:	e0fffc03 	ldbu	r3,-16(fp)
8113f3fc:	d0a09e44 	addi	r2,gp,-32135
8113f400:	1885883a 	add	r2,r3,r2
8113f404:	10800003 	ldbu	r2,0(r2)
8113f408:	10803fcc 	andi	r2,r2,255
8113f40c:	1000061e 	bne	r2,zero,8113f428 <OSTaskChangePrio+0x250>
             OSRdyGrp &= ~bity_old;
8113f410:	e0bffc43 	ldbu	r2,-15(fp)
8113f414:	0084303a 	nor	r2,zero,r2
8113f418:	1007883a 	mov	r3,r2
8113f41c:	d0a09e03 	ldbu	r2,-32136(gp)
8113f420:	1884703a 	and	r2,r3,r2
8113f424:	d0a09e05 	stb	r2,-32136(gp)
         }
         OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
8113f428:	d0e09e03 	ldbu	r3,-32136(gp)
8113f42c:	e0bffb83 	ldbu	r2,-18(fp)
8113f430:	1884b03a 	or	r2,r3,r2
8113f434:	d0a09e05 	stb	r2,-32136(gp)
         OSRdyTbl[y_new] |= bitx_new;
8113f438:	e0fffb03 	ldbu	r3,-20(fp)
8113f43c:	e13ffb03 	ldbu	r4,-20(fp)
8113f440:	d0a09e44 	addi	r2,gp,-32135
8113f444:	2085883a 	add	r2,r4,r2
8113f448:	11000003 	ldbu	r4,0(r2)
8113f44c:	e0bffbc3 	ldbu	r2,-17(fp)
8113f450:	2084b03a 	or	r2,r4,r2
8113f454:	1009883a 	mov	r4,r2
8113f458:	d0a09e44 	addi	r2,gp,-32135
8113f45c:	1885883a 	add	r2,r3,r2
8113f460:	11000005 	stb	r4,0(r2)
    }

#if (OS_EVENT_EN)
    pevent = ptcb->OSTCBEventPtr;
8113f464:	e0bff817 	ldw	r2,-32(fp)
8113f468:	10800717 	ldw	r2,28(r2)
8113f46c:	e0bff315 	stw	r2,-52(fp)
    if (pevent != (OS_EVENT *)0) {
8113f470:	e0bff317 	ldw	r2,-52(fp)
8113f474:	10003326 	beq	r2,zero,8113f544 <OSTaskChangePrio+0x36c>
        pevent->OSEventTbl[y_old] &= ~bitx_old;             /* Remove old task prio from wait list     */
8113f478:	e0bffc03 	ldbu	r2,-16(fp)
8113f47c:	e0fffc03 	ldbu	r3,-16(fp)
8113f480:	e13ff317 	ldw	r4,-52(fp)
8113f484:	20c7883a 	add	r3,r4,r3
8113f488:	18c002c4 	addi	r3,r3,11
8113f48c:	18c00003 	ldbu	r3,0(r3)
8113f490:	1809883a 	mov	r4,r3
8113f494:	e0fffc83 	ldbu	r3,-14(fp)
8113f498:	00c6303a 	nor	r3,zero,r3
8113f49c:	20c6703a 	and	r3,r4,r3
8113f4a0:	1809883a 	mov	r4,r3
8113f4a4:	e0fff317 	ldw	r3,-52(fp)
8113f4a8:	1885883a 	add	r2,r3,r2
8113f4ac:	108002c4 	addi	r2,r2,11
8113f4b0:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y_old] == 0) {
8113f4b4:	e0bffc03 	ldbu	r2,-16(fp)
8113f4b8:	e0fff317 	ldw	r3,-52(fp)
8113f4bc:	1885883a 	add	r2,r3,r2
8113f4c0:	108002c4 	addi	r2,r2,11
8113f4c4:	10800003 	ldbu	r2,0(r2)
8113f4c8:	10803fcc 	andi	r2,r2,255
8113f4cc:	1000091e 	bne	r2,zero,8113f4f4 <OSTaskChangePrio+0x31c>
            pevent->OSEventGrp    &= ~bity_old;
8113f4d0:	e0bff317 	ldw	r2,-52(fp)
8113f4d4:	10800283 	ldbu	r2,10(r2)
8113f4d8:	1007883a 	mov	r3,r2
8113f4dc:	e0bffc43 	ldbu	r2,-15(fp)
8113f4e0:	0084303a 	nor	r2,zero,r2
8113f4e4:	1884703a 	and	r2,r3,r2
8113f4e8:	1007883a 	mov	r3,r2
8113f4ec:	e0bff317 	ldw	r2,-52(fp)
8113f4f0:	10c00285 	stb	r3,10(r2)
        }
        pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
8113f4f4:	e0bff317 	ldw	r2,-52(fp)
8113f4f8:	10c00283 	ldbu	r3,10(r2)
8113f4fc:	e0bffb83 	ldbu	r2,-18(fp)
8113f500:	1884b03a 	or	r2,r3,r2
8113f504:	1007883a 	mov	r3,r2
8113f508:	e0bff317 	ldw	r2,-52(fp)
8113f50c:	10c00285 	stb	r3,10(r2)
        pevent->OSEventTbl[y_new] |= bitx_new;
8113f510:	e0bffb03 	ldbu	r2,-20(fp)
8113f514:	e0fffb03 	ldbu	r3,-20(fp)
8113f518:	e13ff317 	ldw	r4,-52(fp)
8113f51c:	20c7883a 	add	r3,r4,r3
8113f520:	18c002c4 	addi	r3,r3,11
8113f524:	19000003 	ldbu	r4,0(r3)
8113f528:	e0fffbc3 	ldbu	r3,-17(fp)
8113f52c:	20c6b03a 	or	r3,r4,r3
8113f530:	1809883a 	mov	r4,r3
8113f534:	e0fff317 	ldw	r3,-52(fp)
8113f538:	1885883a 	add	r2,r3,r2
8113f53c:	108002c4 	addi	r2,r2,11
8113f540:	11000005 	stb	r4,0(r2)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
8113f544:	e0bff817 	ldw	r2,-32(fp)
8113f548:	10800817 	ldw	r2,32(r2)
8113f54c:	10004226 	beq	r2,zero,8113f658 <OSTaskChangePrio+0x480>
        pevents =  ptcb->OSTCBEventMultiPtr;
8113f550:	e0bff817 	ldw	r2,-32(fp)
8113f554:	10800817 	ldw	r2,32(r2)
8113f558:	e0bff415 	stw	r2,-48(fp)
        pevent  = *pevents;
8113f55c:	e0bff417 	ldw	r2,-48(fp)
8113f560:	10800017 	ldw	r2,0(r2)
8113f564:	e0bff315 	stw	r2,-52(fp)
        while (pevent != (OS_EVENT *)0) {
8113f568:	00003906 	br	8113f650 <OSTaskChangePrio+0x478>
            pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
8113f56c:	e0bffc03 	ldbu	r2,-16(fp)
8113f570:	e0fffc03 	ldbu	r3,-16(fp)
8113f574:	e13ff317 	ldw	r4,-52(fp)
8113f578:	20c7883a 	add	r3,r4,r3
8113f57c:	18c002c4 	addi	r3,r3,11
8113f580:	18c00003 	ldbu	r3,0(r3)
8113f584:	1809883a 	mov	r4,r3
8113f588:	e0fffc83 	ldbu	r3,-14(fp)
8113f58c:	00c6303a 	nor	r3,zero,r3
8113f590:	20c6703a 	and	r3,r4,r3
8113f594:	1809883a 	mov	r4,r3
8113f598:	e0fff317 	ldw	r3,-52(fp)
8113f59c:	1885883a 	add	r2,r3,r2
8113f5a0:	108002c4 	addi	r2,r2,11
8113f5a4:	11000005 	stb	r4,0(r2)
            if (pevent->OSEventTbl[y_old] == 0) {
8113f5a8:	e0bffc03 	ldbu	r2,-16(fp)
8113f5ac:	e0fff317 	ldw	r3,-52(fp)
8113f5b0:	1885883a 	add	r2,r3,r2
8113f5b4:	108002c4 	addi	r2,r2,11
8113f5b8:	10800003 	ldbu	r2,0(r2)
8113f5bc:	10803fcc 	andi	r2,r2,255
8113f5c0:	1000091e 	bne	r2,zero,8113f5e8 <OSTaskChangePrio+0x410>
                pevent->OSEventGrp    &= ~bity_old;
8113f5c4:	e0bff317 	ldw	r2,-52(fp)
8113f5c8:	10800283 	ldbu	r2,10(r2)
8113f5cc:	1007883a 	mov	r3,r2
8113f5d0:	e0bffc43 	ldbu	r2,-15(fp)
8113f5d4:	0084303a 	nor	r2,zero,r2
8113f5d8:	1884703a 	and	r2,r3,r2
8113f5dc:	1007883a 	mov	r3,r2
8113f5e0:	e0bff317 	ldw	r2,-52(fp)
8113f5e4:	10c00285 	stb	r3,10(r2)
            }
            pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
8113f5e8:	e0bff317 	ldw	r2,-52(fp)
8113f5ec:	10c00283 	ldbu	r3,10(r2)
8113f5f0:	e0bffb83 	ldbu	r2,-18(fp)
8113f5f4:	1884b03a 	or	r2,r3,r2
8113f5f8:	1007883a 	mov	r3,r2
8113f5fc:	e0bff317 	ldw	r2,-52(fp)
8113f600:	10c00285 	stb	r3,10(r2)
            pevent->OSEventTbl[y_new] |= bitx_new;
8113f604:	e0bffb03 	ldbu	r2,-20(fp)
8113f608:	e0fffb03 	ldbu	r3,-20(fp)
8113f60c:	e13ff317 	ldw	r4,-52(fp)
8113f610:	20c7883a 	add	r3,r4,r3
8113f614:	18c002c4 	addi	r3,r3,11
8113f618:	19000003 	ldbu	r4,0(r3)
8113f61c:	e0fffbc3 	ldbu	r3,-17(fp)
8113f620:	20c6b03a 	or	r3,r4,r3
8113f624:	1809883a 	mov	r4,r3
8113f628:	e0fff317 	ldw	r3,-52(fp)
8113f62c:	1885883a 	add	r2,r3,r2
8113f630:	108002c4 	addi	r2,r2,11
8113f634:	11000005 	stb	r4,0(r2)
            pevents++;
8113f638:	e0bff417 	ldw	r2,-48(fp)
8113f63c:	10800104 	addi	r2,r2,4
8113f640:	e0bff415 	stw	r2,-48(fp)
            pevent                     = *pevents;
8113f644:	e0bff417 	ldw	r2,-48(fp)
8113f648:	10800017 	ldw	r2,0(r2)
8113f64c:	e0bff315 	stw	r2,-52(fp)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
        pevents =  ptcb->OSTCBEventMultiPtr;
        pevent  = *pevents;
        while (pevent != (OS_EVENT *)0) {
8113f650:	e0bff317 	ldw	r2,-52(fp)
8113f654:	103fc51e 	bne	r2,zero,8113f56c <__reset+0xfb11f56c>
        }
    }
#endif
#endif

    ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
8113f658:	e0bff817 	ldw	r2,-32(fp)
8113f65c:	e0ffff03 	ldbu	r3,-4(fp)
8113f660:	10c00c85 	stb	r3,50(r2)
    ptcb->OSTCBY    = y_new;
8113f664:	e0bff817 	ldw	r2,-32(fp)
8113f668:	e0fffb03 	ldbu	r3,-20(fp)
8113f66c:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX    = x_new;
8113f670:	e0bff817 	ldw	r2,-32(fp)
8113f674:	e0fffb43 	ldbu	r3,-19(fp)
8113f678:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY = bity_new;
8113f67c:	e0bff817 	ldw	r2,-32(fp)
8113f680:	e0fffb83 	ldbu	r3,-18(fp)
8113f684:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX = bitx_new;
8113f688:	e0bff817 	ldw	r2,-32(fp)
8113f68c:	e0fffbc3 	ldbu	r3,-17(fp)
8113f690:	10c00d45 	stb	r3,53(r2)
8113f694:	e0bff517 	ldw	r2,-44(fp)
8113f698:	e0bffa15 	stw	r2,-24(fp)
8113f69c:	e0bffa17 	ldw	r2,-24(fp)
8113f6a0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
8113f6a4:	d0a09103 	ldbu	r2,-32188(gp)
8113f6a8:	10803fcc 	andi	r2,r2,255
8113f6ac:	10800058 	cmpnei	r2,r2,1
8113f6b0:	1000011e 	bne	r2,zero,8113f6b8 <OSTaskChangePrio+0x4e0>
        OS_Sched();                                         /* Find new highest priority task          */
8113f6b4:	1139c680 	call	81139c68 <OS_Sched>
    }
    return (OS_ERR_NONE);
8113f6b8:	0005883a 	mov	r2,zero
}
8113f6bc:	e037883a 	mov	sp,fp
8113f6c0:	dfc00117 	ldw	ra,4(sp)
8113f6c4:	df000017 	ldw	fp,0(sp)
8113f6c8:	dec00204 	addi	sp,sp,8
8113f6cc:	f800283a 	ret

8113f6d0 <OSTaskCreate>:
*********************************************************************************************************
*/

#if OS_TASK_CREATE_EN > 0
INT8U  OSTaskCreate (void (*task)(void *p_arg), void *p_arg, OS_STK *ptos, INT8U prio)
{
8113f6d0:	deffee04 	addi	sp,sp,-72
8113f6d4:	de00012e 	bgeu	sp,et,8113f6dc <OSTaskCreate+0xc>
8113f6d8:	003b68fa 	trap	3
8113f6dc:	dfc01115 	stw	ra,68(sp)
8113f6e0:	df001015 	stw	fp,64(sp)
8113f6e4:	df001004 	addi	fp,sp,64
8113f6e8:	e13ffc15 	stw	r4,-16(fp)
8113f6ec:	e17ffd15 	stw	r5,-12(fp)
8113f6f0:	e1bffe15 	stw	r6,-8(fp)
8113f6f4:	3805883a 	mov	r2,r7
8113f6f8:	e0bfff05 	stb	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
8113f6fc:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
8113f700:	e0bfff03 	ldbu	r2,-4(fp)
8113f704:	10800af0 	cmpltui	r2,r2,43
8113f708:	1000021e 	bne	r2,zero,8113f714 <OSTaskCreate+0x44>
        return (OS_ERR_PRIO_INVALID);
8113f70c:	00800a84 	movi	r2,42
8113f710:	00005706 	br	8113f870 <OSTaskCreate+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f714:	0005303a 	rdctl	r2,status
8113f718:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f71c:	e0fffb17 	ldw	r3,-20(fp)
8113f720:	00bfff84 	movi	r2,-2
8113f724:	1884703a 	and	r2,r3,r2
8113f728:	1001703a 	wrctl	status,r2
  
  return context;
8113f72c:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113f730:	e0bff315 	stw	r2,-52(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
8113f734:	d0a0a103 	ldbu	r2,-32124(gp)
8113f738:	10803fcc 	andi	r2,r2,255
8113f73c:	10000626 	beq	r2,zero,8113f758 <OSTaskCreate+0x88>
8113f740:	e0bff317 	ldw	r2,-52(fp)
8113f744:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f748:	e0bff417 	ldw	r2,-48(fp)
8113f74c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
8113f750:	00800f04 	movi	r2,60
8113f754:	00004606 	br	8113f870 <OSTaskCreate+0x1a0>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
8113f758:	e0ffff03 	ldbu	r3,-4(fp)
8113f75c:	00a045f4 	movhi	r2,33047
8113f760:	10b41904 	addi	r2,r2,-12188
8113f764:	18c7883a 	add	r3,r3,r3
8113f768:	18c7883a 	add	r3,r3,r3
8113f76c:	10c5883a 	add	r2,r2,r3
8113f770:	10800017 	ldw	r2,0(r2)
8113f774:	1000391e 	bne	r2,zero,8113f85c <OSTaskCreate+0x18c>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
8113f778:	e0ffff03 	ldbu	r3,-4(fp)
8113f77c:	00a045f4 	movhi	r2,33047
8113f780:	10b41904 	addi	r2,r2,-12188
8113f784:	18c7883a 	add	r3,r3,r3
8113f788:	18c7883a 	add	r3,r3,r3
8113f78c:	10c5883a 	add	r2,r2,r3
8113f790:	00c00044 	movi	r3,1
8113f794:	10c00015 	stw	r3,0(r2)
8113f798:	e0bff317 	ldw	r2,-52(fp)
8113f79c:	e0bff515 	stw	r2,-44(fp)
8113f7a0:	e0bff517 	ldw	r2,-44(fp)
8113f7a4:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
        psp = OSTaskStkInit(task, p_arg, ptos, 0);              /* Initialize the task's stack         */
8113f7a8:	000f883a 	mov	r7,zero
8113f7ac:	e1bffe17 	ldw	r6,-8(fp)
8113f7b0:	e17ffd17 	ldw	r5,-12(fp)
8113f7b4:	e13ffc17 	ldw	r4,-16(fp)
8113f7b8:	114ad780 	call	8114ad78 <OSTaskStkInit>
8113f7bc:	e0bff715 	stw	r2,-36(fp)
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
8113f7c0:	e0bfff03 	ldbu	r2,-4(fp)
8113f7c4:	d8000215 	stw	zero,8(sp)
8113f7c8:	d8000115 	stw	zero,4(sp)
8113f7cc:	d8000015 	stw	zero,0(sp)
8113f7d0:	000f883a 	mov	r7,zero
8113f7d4:	000d883a 	mov	r6,zero
8113f7d8:	e17ff717 	ldw	r5,-36(fp)
8113f7dc:	1009883a 	mov	r4,r2
8113f7e0:	113a0b00 	call	8113a0b0 <OS_TCBInit>
8113f7e4:	e0bff805 	stb	r2,-32(fp)
        if (err == OS_ERR_NONE) {
8113f7e8:	e0bff803 	ldbu	r2,-32(fp)
8113f7ec:	1000061e 	bne	r2,zero,8113f808 <OSTaskCreate+0x138>
            if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
8113f7f0:	d0a09103 	ldbu	r2,-32188(gp)
8113f7f4:	10803fcc 	andi	r2,r2,255
8113f7f8:	10800058 	cmpnei	r2,r2,1
8113f7fc:	1000151e 	bne	r2,zero,8113f854 <OSTaskCreate+0x184>
                OS_Sched();
8113f800:	1139c680 	call	81139c68 <OS_Sched>
8113f804:	00001306 	br	8113f854 <OSTaskCreate+0x184>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f808:	0005303a 	rdctl	r2,status
8113f80c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f810:	e0fffa17 	ldw	r3,-24(fp)
8113f814:	00bfff84 	movi	r2,-2
8113f818:	1884703a 	and	r2,r3,r2
8113f81c:	1001703a 	wrctl	status,r2
  
  return context;
8113f820:	e0bffa17 	ldw	r2,-24(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
8113f824:	e0bff315 	stw	r2,-52(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
8113f828:	e0ffff03 	ldbu	r3,-4(fp)
8113f82c:	00a045f4 	movhi	r2,33047
8113f830:	10b41904 	addi	r2,r2,-12188
8113f834:	18c7883a 	add	r3,r3,r3
8113f838:	18c7883a 	add	r3,r3,r3
8113f83c:	10c5883a 	add	r2,r2,r3
8113f840:	10000015 	stw	zero,0(r2)
8113f844:	e0bff317 	ldw	r2,-52(fp)
8113f848:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f84c:	e0bff617 	ldw	r2,-40(fp)
8113f850:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
8113f854:	e0bff803 	ldbu	r2,-32(fp)
8113f858:	00000506 	br	8113f870 <OSTaskCreate+0x1a0>
8113f85c:	e0bff317 	ldw	r2,-52(fp)
8113f860:	e0bff915 	stw	r2,-28(fp)
8113f864:	e0bff917 	ldw	r2,-28(fp)
8113f868:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
8113f86c:	00800a04 	movi	r2,40
}
8113f870:	e037883a 	mov	sp,fp
8113f874:	dfc00117 	ldw	ra,4(sp)
8113f878:	df000017 	ldw	fp,0(sp)
8113f87c:	dec00204 	addi	sp,sp,8
8113f880:	f800283a 	ret

8113f884 <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
8113f884:	deffec04 	addi	sp,sp,-80
8113f888:	de00012e 	bgeu	sp,et,8113f890 <OSTaskCreateExt+0xc>
8113f88c:	003b68fa 	trap	3
8113f890:	dfc01315 	stw	ra,76(sp)
8113f894:	df001215 	stw	fp,72(sp)
8113f898:	df001204 	addi	fp,sp,72
8113f89c:	e13ffa15 	stw	r4,-24(fp)
8113f8a0:	e17ffb15 	stw	r5,-20(fp)
8113f8a4:	e1bffc15 	stw	r6,-16(fp)
8113f8a8:	3809883a 	mov	r4,r7
8113f8ac:	e0c00217 	ldw	r3,8(fp)
8113f8b0:	e0800617 	ldw	r2,24(fp)
8113f8b4:	e13ffd05 	stb	r4,-12(fp)
8113f8b8:	e0fffe0d 	sth	r3,-8(fp)
8113f8bc:	e0bfff0d 	sth	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
8113f8c0:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
8113f8c4:	e0bffd03 	ldbu	r2,-12(fp)
8113f8c8:	10800af0 	cmpltui	r2,r2,43
8113f8cc:	1000021e 	bne	r2,zero,8113f8d8 <OSTaskCreateExt+0x54>
        return (OS_ERR_PRIO_INVALID);
8113f8d0:	00800a84 	movi	r2,42
8113f8d4:	00006106 	br	8113fa5c <OSTaskCreateExt+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f8d8:	0005303a 	rdctl	r2,status
8113f8dc:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f8e0:	e0fff917 	ldw	r3,-28(fp)
8113f8e4:	00bfff84 	movi	r2,-2
8113f8e8:	1884703a 	and	r2,r3,r2
8113f8ec:	1001703a 	wrctl	status,r2
  
  return context;
8113f8f0:	e0bff917 	ldw	r2,-28(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113f8f4:	e0bff115 	stw	r2,-60(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
8113f8f8:	d0a0a103 	ldbu	r2,-32124(gp)
8113f8fc:	10803fcc 	andi	r2,r2,255
8113f900:	10000626 	beq	r2,zero,8113f91c <OSTaskCreateExt+0x98>
8113f904:	e0bff117 	ldw	r2,-60(fp)
8113f908:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f90c:	e0bff217 	ldw	r2,-56(fp)
8113f910:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
8113f914:	00800f04 	movi	r2,60
8113f918:	00005006 	br	8113fa5c <OSTaskCreateExt+0x1d8>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
8113f91c:	e0fffd03 	ldbu	r3,-12(fp)
8113f920:	00a045f4 	movhi	r2,33047
8113f924:	10b41904 	addi	r2,r2,-12188
8113f928:	18c7883a 	add	r3,r3,r3
8113f92c:	18c7883a 	add	r3,r3,r3
8113f930:	10c5883a 	add	r2,r2,r3
8113f934:	10800017 	ldw	r2,0(r2)
8113f938:	1000431e 	bne	r2,zero,8113fa48 <OSTaskCreateExt+0x1c4>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
8113f93c:	e0fffd03 	ldbu	r3,-12(fp)
8113f940:	00a045f4 	movhi	r2,33047
8113f944:	10b41904 	addi	r2,r2,-12188
8113f948:	18c7883a 	add	r3,r3,r3
8113f94c:	18c7883a 	add	r3,r3,r3
8113f950:	10c5883a 	add	r2,r2,r3
8113f954:	00c00044 	movi	r3,1
8113f958:	10c00015 	stw	r3,0(r2)
8113f95c:	e0bff117 	ldw	r2,-60(fp)
8113f960:	e0bff315 	stw	r2,-52(fp)
8113f964:	e0bff317 	ldw	r2,-52(fp)
8113f968:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();

#if (OS_TASK_STAT_STK_CHK_EN > 0)
        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
8113f96c:	e0bfff0b 	ldhu	r2,-4(fp)
8113f970:	100d883a 	mov	r6,r2
8113f974:	e1400417 	ldw	r5,16(fp)
8113f978:	e1000317 	ldw	r4,12(fp)
8113f97c:	114092c0 	call	8114092c <OS_TaskStkClr>
#endif

        psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
8113f980:	e0bfff0b 	ldhu	r2,-4(fp)
8113f984:	100f883a 	mov	r7,r2
8113f988:	e1bffc17 	ldw	r6,-16(fp)
8113f98c:	e17ffb17 	ldw	r5,-20(fp)
8113f990:	e13ffa17 	ldw	r4,-24(fp)
8113f994:	114ad780 	call	8114ad78 <OSTaskStkInit>
8113f998:	e0bff515 	stw	r2,-44(fp)
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
8113f99c:	e0fffd03 	ldbu	r3,-12(fp)
8113f9a0:	e13ffe0b 	ldhu	r4,-8(fp)
8113f9a4:	e0bfff0b 	ldhu	r2,-4(fp)
8113f9a8:	d8800215 	stw	r2,8(sp)
8113f9ac:	e0800517 	ldw	r2,20(fp)
8113f9b0:	d8800115 	stw	r2,4(sp)
8113f9b4:	e0800417 	ldw	r2,16(fp)
8113f9b8:	d8800015 	stw	r2,0(sp)
8113f9bc:	200f883a 	mov	r7,r4
8113f9c0:	e1800317 	ldw	r6,12(fp)
8113f9c4:	e17ff517 	ldw	r5,-44(fp)
8113f9c8:	1809883a 	mov	r4,r3
8113f9cc:	113a0b00 	call	8113a0b0 <OS_TCBInit>
8113f9d0:	e0bff605 	stb	r2,-40(fp)
        if (err == OS_ERR_NONE) {
8113f9d4:	e0bff603 	ldbu	r2,-40(fp)
8113f9d8:	1000061e 	bne	r2,zero,8113f9f4 <OSTaskCreateExt+0x170>
            if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
8113f9dc:	d0a09103 	ldbu	r2,-32188(gp)
8113f9e0:	10803fcc 	andi	r2,r2,255
8113f9e4:	10800058 	cmpnei	r2,r2,1
8113f9e8:	1000151e 	bne	r2,zero,8113fa40 <OSTaskCreateExt+0x1bc>
                OS_Sched();
8113f9ec:	1139c680 	call	81139c68 <OS_Sched>
8113f9f0:	00001306 	br	8113fa40 <OSTaskCreateExt+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f9f4:	0005303a 	rdctl	r2,status
8113f9f8:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f9fc:	e0fff817 	ldw	r3,-32(fp)
8113fa00:	00bfff84 	movi	r2,-2
8113fa04:	1884703a 	and	r2,r3,r2
8113fa08:	1001703a 	wrctl	status,r2
  
  return context;
8113fa0c:	e0bff817 	ldw	r2,-32(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
8113fa10:	e0bff115 	stw	r2,-60(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
8113fa14:	e0fffd03 	ldbu	r3,-12(fp)
8113fa18:	00a045f4 	movhi	r2,33047
8113fa1c:	10b41904 	addi	r2,r2,-12188
8113fa20:	18c7883a 	add	r3,r3,r3
8113fa24:	18c7883a 	add	r3,r3,r3
8113fa28:	10c5883a 	add	r2,r2,r3
8113fa2c:	10000015 	stw	zero,0(r2)
8113fa30:	e0bff117 	ldw	r2,-60(fp)
8113fa34:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113fa38:	e0bff417 	ldw	r2,-48(fp)
8113fa3c:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
8113fa40:	e0bff603 	ldbu	r2,-40(fp)
8113fa44:	00000506 	br	8113fa5c <OSTaskCreateExt+0x1d8>
8113fa48:	e0bff117 	ldw	r2,-60(fp)
8113fa4c:	e0bff715 	stw	r2,-36(fp)
8113fa50:	e0bff717 	ldw	r2,-36(fp)
8113fa54:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
8113fa58:	00800a04 	movi	r2,40
}
8113fa5c:	e037883a 	mov	sp,fp
8113fa60:	dfc00117 	ldw	ra,4(sp)
8113fa64:	df000017 	ldw	fp,0(sp)
8113fa68:	dec00204 	addi	sp,sp,8
8113fa6c:	f800283a 	ret

8113fa70 <OSTaskDel>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDel (INT8U prio)
{
8113fa70:	defff404 	addi	sp,sp,-48
8113fa74:	de00012e 	bgeu	sp,et,8113fa7c <OSTaskDel+0xc>
8113fa78:	003b68fa 	trap	3
8113fa7c:	dfc00b15 	stw	ra,44(sp)
8113fa80:	df000a15 	stw	fp,40(sp)
8113fa84:	df000a04 	addi	fp,sp,40
8113fa88:	2005883a 	mov	r2,r4
8113fa8c:	e0bfff05 	stb	r2,-4(fp)
#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FLAG_NODE *pnode;
#endif
    OS_TCB       *ptcb;
#if OS_CRITICAL_METHOD == 3                             /* Allocate storage for CPU status register    */
    OS_CPU_SR     cpu_sr = 0;
8113fa90:	e03ff615 	stw	zero,-40(fp)
#endif



    if (OSIntNesting > 0) {                             /* See if trying to delete from ISR            */
8113fa94:	d0a0a103 	ldbu	r2,-32124(gp)
8113fa98:	10803fcc 	andi	r2,r2,255
8113fa9c:	10000226 	beq	r2,zero,8113faa8 <OSTaskDel+0x38>
        return (OS_ERR_TASK_DEL_ISR);
8113faa0:	00801004 	movi	r2,64
8113faa4:	0000c006 	br	8113fda8 <OSTaskDel+0x338>
    }
    if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
8113faa8:	e0bfff03 	ldbu	r2,-4(fp)
8113faac:	10800a98 	cmpnei	r2,r2,42
8113fab0:	1000021e 	bne	r2,zero,8113fabc <OSTaskDel+0x4c>
        return (OS_ERR_TASK_DEL_IDLE);
8113fab4:	00800f84 	movi	r2,62
8113fab8:	0000bb06 	br	8113fda8 <OSTaskDel+0x338>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
8113fabc:	e0bfff03 	ldbu	r2,-4(fp)
8113fac0:	10800ab0 	cmpltui	r2,r2,42
8113fac4:	1000051e 	bne	r2,zero,8113fadc <OSTaskDel+0x6c>
        if (prio != OS_PRIO_SELF) {
8113fac8:	e0bfff03 	ldbu	r2,-4(fp)
8113facc:	10803fe0 	cmpeqi	r2,r2,255
8113fad0:	1000021e 	bne	r2,zero,8113fadc <OSTaskDel+0x6c>
            return (OS_ERR_PRIO_INVALID);
8113fad4:	00800a84 	movi	r2,42
8113fad8:	0000b306 	br	8113fda8 <OSTaskDel+0x338>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113fadc:	0005303a 	rdctl	r2,status
8113fae0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113fae4:	e0fffe17 	ldw	r3,-8(fp)
8113fae8:	00bfff84 	movi	r2,-2
8113faec:	1884703a 	and	r2,r3,r2
8113faf0:	1001703a 	wrctl	status,r2
  
  return context;
8113faf4:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif

/*$PAGE*/
    OS_ENTER_CRITICAL();
8113faf8:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
8113fafc:	e0bfff03 	ldbu	r2,-4(fp)
8113fb00:	10803fd8 	cmpnei	r2,r2,255
8113fb04:	1000031e 	bne	r2,zero,8113fb14 <OSTaskDel+0xa4>
        prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
8113fb08:	d0a0a217 	ldw	r2,-32120(gp)
8113fb0c:	10800c83 	ldbu	r2,50(r2)
8113fb10:	e0bfff05 	stb	r2,-4(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113fb14:	e0ffff03 	ldbu	r3,-4(fp)
8113fb18:	00a045f4 	movhi	r2,33047
8113fb1c:	10b41904 	addi	r2,r2,-12188
8113fb20:	18c7883a 	add	r3,r3,r3
8113fb24:	18c7883a 	add	r3,r3,r3
8113fb28:	10c5883a 	add	r2,r2,r3
8113fb2c:	10800017 	ldw	r2,0(r2)
8113fb30:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
8113fb34:	e0bff817 	ldw	r2,-32(fp)
8113fb38:	1000061e 	bne	r2,zero,8113fb54 <OSTaskDel+0xe4>
8113fb3c:	e0bff617 	ldw	r2,-40(fp)
8113fb40:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113fb44:	e0bff717 	ldw	r2,-36(fp)
8113fb48:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113fb4c:	008010c4 	movi	r2,67
8113fb50:	00009506 	br	8113fda8 <OSTaskDel+0x338>
    }
    if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
8113fb54:	e0bff817 	ldw	r2,-32(fp)
8113fb58:	10800058 	cmpnei	r2,r2,1
8113fb5c:	1000061e 	bne	r2,zero,8113fb78 <OSTaskDel+0x108>
8113fb60:	e0bff617 	ldw	r2,-40(fp)
8113fb64:	e0bff915 	stw	r2,-28(fp)
8113fb68:	e0bff917 	ldw	r2,-28(fp)
8113fb6c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
8113fb70:	00800f44 	movi	r2,61
8113fb74:	00008c06 	br	8113fda8 <OSTaskDel+0x338>
    }

    OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX;
8113fb78:	e0bff817 	ldw	r2,-32(fp)
8113fb7c:	10800d03 	ldbu	r2,52(r2)
8113fb80:	10c03fcc 	andi	r3,r2,255
8113fb84:	e0bff817 	ldw	r2,-32(fp)
8113fb88:	10800d03 	ldbu	r2,52(r2)
8113fb8c:	11003fcc 	andi	r4,r2,255
8113fb90:	d0a09e44 	addi	r2,gp,-32135
8113fb94:	2085883a 	add	r2,r4,r2
8113fb98:	10800003 	ldbu	r2,0(r2)
8113fb9c:	1009883a 	mov	r4,r2
8113fba0:	e0bff817 	ldw	r2,-32(fp)
8113fba4:	10800d43 	ldbu	r2,53(r2)
8113fba8:	0084303a 	nor	r2,zero,r2
8113fbac:	2084703a 	and	r2,r4,r2
8113fbb0:	1009883a 	mov	r4,r2
8113fbb4:	d0a09e44 	addi	r2,gp,-32135
8113fbb8:	1885883a 	add	r2,r3,r2
8113fbbc:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[ptcb->OSTCBY] == 0) {                  /* Make task not ready                         */
8113fbc0:	e0bff817 	ldw	r2,-32(fp)
8113fbc4:	10800d03 	ldbu	r2,52(r2)
8113fbc8:	10c03fcc 	andi	r3,r2,255
8113fbcc:	d0a09e44 	addi	r2,gp,-32135
8113fbd0:	1885883a 	add	r2,r3,r2
8113fbd4:	10800003 	ldbu	r2,0(r2)
8113fbd8:	10803fcc 	andi	r2,r2,255
8113fbdc:	1000071e 	bne	r2,zero,8113fbfc <OSTaskDel+0x18c>
        OSRdyGrp           &= ~ptcb->OSTCBBitY;
8113fbe0:	e0bff817 	ldw	r2,-32(fp)
8113fbe4:	10800d83 	ldbu	r2,54(r2)
8113fbe8:	0084303a 	nor	r2,zero,r2
8113fbec:	1007883a 	mov	r3,r2
8113fbf0:	d0a09e03 	ldbu	r2,-32136(gp)
8113fbf4:	1884703a 	and	r2,r3,r2
8113fbf8:	d0a09e05 	stb	r2,-32136(gp)
    }
    
#if (OS_EVENT_EN)
    if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
8113fbfc:	e0bff817 	ldw	r2,-32(fp)
8113fc00:	10800717 	ldw	r2,28(r2)
8113fc04:	10000526 	beq	r2,zero,8113fc1c <OSTaskDel+0x1ac>
        OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
8113fc08:	e0bff817 	ldw	r2,-32(fp)
8113fc0c:	10800717 	ldw	r2,28(r2)
8113fc10:	100b883a 	mov	r5,r2
8113fc14:	e13ff817 	ldw	r4,-32(fp)
8113fc18:	11395bc0 	call	811395bc <OS_EventTaskRemove>
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
8113fc1c:	e0bff817 	ldw	r2,-32(fp)
8113fc20:	10800817 	ldw	r2,32(r2)
8113fc24:	10000526 	beq	r2,zero,8113fc3c <OSTaskDel+0x1cc>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
8113fc28:	e0bff817 	ldw	r2,-32(fp)
8113fc2c:	10800817 	ldw	r2,32(r2)
8113fc30:	100b883a 	mov	r5,r2
8113fc34:	e13ff817 	ldw	r4,-32(fp)
8113fc38:	113967c0 	call	8113967c <OS_EventTaskRemoveMulti>
    }
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    pnode = ptcb->OSTCBFlagNode;
8113fc3c:	e0bff817 	ldw	r2,-32(fp)
8113fc40:	10800a17 	ldw	r2,40(r2)
8113fc44:	e0bffb15 	stw	r2,-20(fp)
    if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
8113fc48:	e0bffb17 	ldw	r2,-20(fp)
8113fc4c:	10000226 	beq	r2,zero,8113fc58 <OSTaskDel+0x1e8>
        OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
8113fc50:	e13ffb17 	ldw	r4,-20(fp)
8113fc54:	113bc540 	call	8113bc54 <OS_FlagUnlink>
    }
#endif

    ptcb->OSTCBDly      = 0;                            /* Prevent OSTimeTick() from updating          */
8113fc58:	e0bff817 	ldw	r2,-32(fp)
8113fc5c:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
8113fc60:	e0bff817 	ldw	r2,-32(fp)
8113fc64:	10000c05 	stb	zero,48(r2)
    ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
8113fc68:	e0bff817 	ldw	r2,-32(fp)
8113fc6c:	10000c45 	stb	zero,49(r2)
    if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
8113fc70:	d0a08f03 	ldbu	r2,-32196(gp)
8113fc74:	10803fcc 	andi	r2,r2,255
8113fc78:	10803fe0 	cmpeqi	r2,r2,255
8113fc7c:	1000031e 	bne	r2,zero,8113fc8c <OSTaskDel+0x21c>
        OSLockNesting++;
8113fc80:	d0a08f03 	ldbu	r2,-32196(gp)
8113fc84:	10800044 	addi	r2,r2,1
8113fc88:	d0a08f05 	stb	r2,-32196(gp)
8113fc8c:	e0bff617 	ldw	r2,-40(fp)
8113fc90:	e0bffd15 	stw	r2,-12(fp)
8113fc94:	e0bffd17 	ldw	r2,-12(fp)
8113fc98:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
    OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
8113fc9c:	11391840 	call	81139184 <OS_Dummy>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113fca0:	0005303a 	rdctl	r2,status
8113fca4:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113fca8:	e0fffa17 	ldw	r3,-24(fp)
8113fcac:	00bfff84 	movi	r2,-2
8113fcb0:	1884703a 	and	r2,r3,r2
8113fcb4:	1001703a 	wrctl	status,r2
  
  return context;
8113fcb8:	e0bffa17 	ldw	r2,-24(fp)
    OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
8113fcbc:	e0bff615 	stw	r2,-40(fp)
    if (OSLockNesting > 0) {                            /* Remove context switch lock                  */
8113fcc0:	d0a08f03 	ldbu	r2,-32196(gp)
8113fcc4:	10803fcc 	andi	r2,r2,255
8113fcc8:	10000326 	beq	r2,zero,8113fcd8 <OSTaskDel+0x268>
        OSLockNesting--;
8113fccc:	d0a08f03 	ldbu	r2,-32196(gp)
8113fcd0:	10bfffc4 	addi	r2,r2,-1
8113fcd4:	d0a08f05 	stb	r2,-32196(gp)
    }
    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
8113fcd8:	e13ff817 	ldw	r4,-32(fp)
8113fcdc:	114af080 	call	8114af08 <OSTaskDelHook>
    OSTaskCtr--;                                        /* One less task being managed                 */
8113fce0:	d0a09a43 	ldbu	r2,-32151(gp)
8113fce4:	10bfffc4 	addi	r2,r2,-1
8113fce8:	d0a09a45 	stb	r2,-32151(gp)
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
8113fcec:	e0ffff03 	ldbu	r3,-4(fp)
8113fcf0:	00a045f4 	movhi	r2,33047
8113fcf4:	10b41904 	addi	r2,r2,-12188
8113fcf8:	18c7883a 	add	r3,r3,r3
8113fcfc:	18c7883a 	add	r3,r3,r3
8113fd00:	10c5883a 	add	r2,r2,r3
8113fd04:	10000015 	stw	zero,0(r2)
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
8113fd08:	e0bff817 	ldw	r2,-32(fp)
8113fd0c:	10800617 	ldw	r2,24(r2)
8113fd10:	1000071e 	bne	r2,zero,8113fd30 <OSTaskDel+0x2c0>
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
8113fd14:	e0bff817 	ldw	r2,-32(fp)
8113fd18:	10800517 	ldw	r2,20(r2)
8113fd1c:	10000615 	stw	zero,24(r2)
        OSTCBList                  = ptcb->OSTCBNext;
8113fd20:	e0bff817 	ldw	r2,-32(fp)
8113fd24:	10800517 	ldw	r2,20(r2)
8113fd28:	d0a09415 	stw	r2,-32176(gp)
8113fd2c:	00000a06 	br	8113fd58 <OSTaskDel+0x2e8>
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
8113fd30:	e0bff817 	ldw	r2,-32(fp)
8113fd34:	10800617 	ldw	r2,24(r2)
8113fd38:	e0fff817 	ldw	r3,-32(fp)
8113fd3c:	18c00517 	ldw	r3,20(r3)
8113fd40:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
8113fd44:	e0bff817 	ldw	r2,-32(fp)
8113fd48:	10800517 	ldw	r2,20(r2)
8113fd4c:	e0fff817 	ldw	r3,-32(fp)
8113fd50:	18c00617 	ldw	r3,24(r3)
8113fd54:	10c00615 	stw	r3,24(r2)
    }
    ptcb->OSTCBNext   = OSTCBFreeList;                  /* Return TCB to free TCB list                 */
8113fd58:	d0e09917 	ldw	r3,-32156(gp)
8113fd5c:	e0bff817 	ldw	r2,-32(fp)
8113fd60:	10c00515 	stw	r3,20(r2)
    OSTCBFreeList     = ptcb;
8113fd64:	e0bff817 	ldw	r2,-32(fp)
8113fd68:	d0a09915 	stw	r2,-32156(gp)
#if OS_TASK_NAME_SIZE > 1
    ptcb->OSTCBTaskName[0] = '?';                       /* Unknown name                                */
8113fd6c:	e0bff817 	ldw	r2,-32(fp)
8113fd70:	00c00fc4 	movi	r3,63
8113fd74:	10c01305 	stb	r3,76(r2)
    ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
8113fd78:	e0bff817 	ldw	r2,-32(fp)
8113fd7c:	10001345 	stb	zero,77(r2)
8113fd80:	e0bff617 	ldw	r2,-40(fp)
8113fd84:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113fd88:	e0bffc17 	ldw	r2,-16(fp)
8113fd8c:	1001703a 	wrctl	status,r2
#endif
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
8113fd90:	d0a09103 	ldbu	r2,-32188(gp)
8113fd94:	10803fcc 	andi	r2,r2,255
8113fd98:	10800058 	cmpnei	r2,r2,1
8113fd9c:	1000011e 	bne	r2,zero,8113fda4 <OSTaskDel+0x334>
        OS_Sched();                                     /* Find new highest priority task              */
8113fda0:	1139c680 	call	81139c68 <OS_Sched>
    }
    return (OS_ERR_NONE);
8113fda4:	0005883a 	mov	r2,zero
}
8113fda8:	e037883a 	mov	sp,fp
8113fdac:	dfc00117 	ldw	ra,4(sp)
8113fdb0:	df000017 	ldw	fp,0(sp)
8113fdb4:	dec00204 	addi	sp,sp,8
8113fdb8:	f800283a 	ret

8113fdbc <OSTaskDelReq>:
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDelReq (INT8U prio)
{
8113fdbc:	defff504 	addi	sp,sp,-44
8113fdc0:	de00012e 	bgeu	sp,et,8113fdc8 <OSTaskDelReq+0xc>
8113fdc4:	003b68fa 	trap	3
8113fdc8:	df000a15 	stw	fp,40(sp)
8113fdcc:	df000a04 	addi	fp,sp,40
8113fdd0:	2005883a 	mov	r2,r4
8113fdd4:	e0bfff05 	stb	r2,-4(fp)
    INT8U      stat;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113fdd8:	e03ff615 	stw	zero,-40(fp)
#endif



    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
8113fddc:	e0bfff03 	ldbu	r2,-4(fp)
8113fde0:	10800a98 	cmpnei	r2,r2,42
8113fde4:	1000021e 	bne	r2,zero,8113fdf0 <OSTaskDelReq+0x34>
        return (OS_ERR_TASK_DEL_IDLE);
8113fde8:	00800f84 	movi	r2,62
8113fdec:	00004506 	br	8113ff04 <OSTaskDelReq+0x148>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
8113fdf0:	e0bfff03 	ldbu	r2,-4(fp)
8113fdf4:	10800ab0 	cmpltui	r2,r2,42
8113fdf8:	1000051e 	bne	r2,zero,8113fe10 <OSTaskDelReq+0x54>
        if (prio != OS_PRIO_SELF) {
8113fdfc:	e0bfff03 	ldbu	r2,-4(fp)
8113fe00:	10803fe0 	cmpeqi	r2,r2,255
8113fe04:	1000021e 	bne	r2,zero,8113fe10 <OSTaskDelReq+0x54>
            return (OS_ERR_PRIO_INVALID);
8113fe08:	00800a84 	movi	r2,42
8113fe0c:	00003d06 	br	8113ff04 <OSTaskDelReq+0x148>
        }
    }
#endif
    if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
8113fe10:	e0bfff03 	ldbu	r2,-4(fp)
8113fe14:	10803fd8 	cmpnei	r2,r2,255
8113fe18:	1000111e 	bne	r2,zero,8113fe60 <OSTaskDelReq+0xa4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113fe1c:	0005303a 	rdctl	r2,status
8113fe20:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113fe24:	e0fff917 	ldw	r3,-28(fp)
8113fe28:	00bfff84 	movi	r2,-2
8113fe2c:	1884703a 	and	r2,r3,r2
8113fe30:	1001703a 	wrctl	status,r2
  
  return context;
8113fe34:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
8113fe38:	e0bff615 	stw	r2,-40(fp)
        stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
8113fe3c:	d0a0a217 	ldw	r2,-32120(gp)
8113fe40:	10800dc3 	ldbu	r2,55(r2)
8113fe44:	e0bff805 	stb	r2,-32(fp)
8113fe48:	e0bff617 	ldw	r2,-40(fp)
8113fe4c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113fe50:	e0bffe17 	ldw	r2,-8(fp)
8113fe54:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (stat);
8113fe58:	e0bff803 	ldbu	r2,-32(fp)
8113fe5c:	00002906 	br	8113ff04 <OSTaskDelReq+0x148>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113fe60:	0005303a 	rdctl	r2,status
8113fe64:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113fe68:	e0fff717 	ldw	r3,-36(fp)
8113fe6c:	00bfff84 	movi	r2,-2
8113fe70:	1884703a 	and	r2,r3,r2
8113fe74:	1001703a 	wrctl	status,r2
  
  return context;
8113fe78:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
8113fe7c:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
8113fe80:	e0ffff03 	ldbu	r3,-4(fp)
8113fe84:	00a045f4 	movhi	r2,33047
8113fe88:	10b41904 	addi	r2,r2,-12188
8113fe8c:	18c7883a 	add	r3,r3,r3
8113fe90:	18c7883a 	add	r3,r3,r3
8113fe94:	10c5883a 	add	r2,r2,r3
8113fe98:	10800017 	ldw	r2,0(r2)
8113fe9c:	e0bffb15 	stw	r2,-20(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
8113fea0:	e0bffb17 	ldw	r2,-20(fp)
8113fea4:	1000061e 	bne	r2,zero,8113fec0 <OSTaskDelReq+0x104>
8113fea8:	e0bff617 	ldw	r2,-40(fp)
8113feac:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113feb0:	e0bffa17 	ldw	r2,-24(fp)
8113feb4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
8113feb8:	008010c4 	movi	r2,67
8113febc:	00001106 	br	8113ff04 <OSTaskDelReq+0x148>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
8113fec0:	e0bffb17 	ldw	r2,-20(fp)
8113fec4:	10800058 	cmpnei	r2,r2,1
8113fec8:	1000061e 	bne	r2,zero,8113fee4 <OSTaskDelReq+0x128>
8113fecc:	e0bff617 	ldw	r2,-40(fp)
8113fed0:	e0bffc15 	stw	r2,-16(fp)
8113fed4:	e0bffc17 	ldw	r2,-16(fp)
8113fed8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
8113fedc:	00800f44 	movi	r2,61
8113fee0:	00000806 	br	8113ff04 <OSTaskDelReq+0x148>
    }
    ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
8113fee4:	e0bffb17 	ldw	r2,-20(fp)
8113fee8:	00c00fc4 	movi	r3,63
8113feec:	10c00dc5 	stb	r3,55(r2)
8113fef0:	e0bff617 	ldw	r2,-40(fp)
8113fef4:	e0bffd15 	stw	r2,-12(fp)
8113fef8:	e0bffd17 	ldw	r2,-12(fp)
8113fefc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113ff00:	0005883a 	mov	r2,zero
}
8113ff04:	e037883a 	mov	sp,fp
8113ff08:	df000017 	ldw	fp,0(sp)
8113ff0c:	dec00104 	addi	sp,sp,4
8113ff10:	f800283a 	ret

8113ff14 <OSTaskNameGet>:
*********************************************************************************************************
*/

#if OS_TASK_NAME_SIZE > 1
INT8U  OSTaskNameGet (INT8U prio, INT8U *pname, INT8U *perr)
{
8113ff14:	defff404 	addi	sp,sp,-48
8113ff18:	de00012e 	bgeu	sp,et,8113ff20 <OSTaskNameGet+0xc>
8113ff1c:	003b68fa 	trap	3
8113ff20:	dfc00b15 	stw	ra,44(sp)
8113ff24:	df000a15 	stw	fp,40(sp)
8113ff28:	df000a04 	addi	fp,sp,40
8113ff2c:	2005883a 	mov	r2,r4
8113ff30:	e17ffe15 	stw	r5,-8(fp)
8113ff34:	e1bfff15 	stw	r6,-4(fp)
8113ff38:	e0bffd05 	stb	r2,-12(fp)
    OS_TCB    *ptcb;
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                              /* Allocate storage for CPU status register   */
    OS_CPU_SR  cpu_sr = 0;
8113ff3c:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                            /* Validate 'perr'                            */
8113ff40:	e0bfff17 	ldw	r2,-4(fp)
8113ff44:	1000021e 	bne	r2,zero,8113ff50 <OSTaskNameGet+0x3c>
        return (0);
8113ff48:	0005883a 	mov	r2,zero
8113ff4c:	00005406 	br	811400a0 <OSTaskNameGet+0x18c>
    }
    if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
8113ff50:	e0bffd03 	ldbu	r2,-12(fp)
8113ff54:	10800af0 	cmpltui	r2,r2,43
8113ff58:	1000081e 	bne	r2,zero,8113ff7c <OSTaskNameGet+0x68>
        if (prio != OS_PRIO_SELF) {
8113ff5c:	e0bffd03 	ldbu	r2,-12(fp)
8113ff60:	10803fe0 	cmpeqi	r2,r2,255
8113ff64:	1000051e 	bne	r2,zero,8113ff7c <OSTaskNameGet+0x68>
            *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
8113ff68:	e0bfff17 	ldw	r2,-4(fp)
8113ff6c:	00c00a84 	movi	r3,42
8113ff70:	10c00005 	stb	r3,0(r2)
            return (0);
8113ff74:	0005883a 	mov	r2,zero
8113ff78:	00004906 	br	811400a0 <OSTaskNameGet+0x18c>
        }
    }
    if (pname == (INT8U *)0) {                           /* Is 'pname' a NULL pointer?                 */
8113ff7c:	e0bffe17 	ldw	r2,-8(fp)
8113ff80:	1000051e 	bne	r2,zero,8113ff98 <OSTaskNameGet+0x84>
        *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
8113ff84:	e0bfff17 	ldw	r2,-4(fp)
8113ff88:	00c00304 	movi	r3,12
8113ff8c:	10c00005 	stb	r3,0(r2)
        return (0);
8113ff90:	0005883a 	mov	r2,zero
8113ff94:	00004206 	br	811400a0 <OSTaskNameGet+0x18c>
    }
#endif
    if (OSIntNesting > 0) {                              /* See if trying to call from an ISR          */
8113ff98:	d0a0a103 	ldbu	r2,-32124(gp)
8113ff9c:	10803fcc 	andi	r2,r2,255
8113ffa0:	10000526 	beq	r2,zero,8113ffb8 <OSTaskNameGet+0xa4>
        *perr = OS_ERR_NAME_GET_ISR;
8113ffa4:	e0bfff17 	ldw	r2,-4(fp)
8113ffa8:	00c00444 	movi	r3,17
8113ffac:	10c00005 	stb	r3,0(r2)
        return (0);
8113ffb0:	0005883a 	mov	r2,zero
8113ffb4:	00003a06 	br	811400a0 <OSTaskNameGet+0x18c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ffb8:	0005303a 	rdctl	r2,status
8113ffbc:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ffc0:	e0fffc17 	ldw	r3,-16(fp)
8113ffc4:	00bfff84 	movi	r2,-2
8113ffc8:	1884703a 	and	r2,r3,r2
8113ffcc:	1001703a 	wrctl	status,r2
  
  return context;
8113ffd0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113ffd4:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
8113ffd8:	e0bffd03 	ldbu	r2,-12(fp)
8113ffdc:	10803fd8 	cmpnei	r2,r2,255
8113ffe0:	1000031e 	bne	r2,zero,8113fff0 <OSTaskNameGet+0xdc>
        prio = OSTCBCur->OSTCBPrio;
8113ffe4:	d0a0a217 	ldw	r2,-32120(gp)
8113ffe8:	10800c83 	ldbu	r2,50(r2)
8113ffec:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113fff0:	e0fffd03 	ldbu	r3,-12(fp)
8113fff4:	00a045f4 	movhi	r2,33047
8113fff8:	10b41904 	addi	r2,r2,-12188
8113fffc:	18c7883a 	add	r3,r3,r3
81140000:	18c7883a 	add	r3,r3,r3
81140004:	10c5883a 	add	r2,r2,r3
81140008:	10800017 	ldw	r2,0(r2)
8114000c:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
81140010:	e0bff817 	ldw	r2,-32(fp)
81140014:	1000091e 	bne	r2,zero,8114003c <OSTaskNameGet+0x128>
81140018:	e0bff617 	ldw	r2,-40(fp)
8114001c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140020:	e0bff717 	ldw	r2,-36(fp)
81140024:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* No                                         */
        *perr = OS_ERR_TASK_NOT_EXIST;
81140028:	e0bfff17 	ldw	r2,-4(fp)
8114002c:	00c010c4 	movi	r3,67
81140030:	10c00005 	stb	r3,0(r2)
        return (0);
81140034:	0005883a 	mov	r2,zero
81140038:	00001906 	br	811400a0 <OSTaskNameGet+0x18c>
    }
    if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
8114003c:	e0bff817 	ldw	r2,-32(fp)
81140040:	10800058 	cmpnei	r2,r2,1
81140044:	1000091e 	bne	r2,zero,8114006c <OSTaskNameGet+0x158>
81140048:	e0bff617 	ldw	r2,-40(fp)
8114004c:	e0bff915 	stw	r2,-28(fp)
81140050:	e0bff917 	ldw	r2,-28(fp)
81140054:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* Yes                                        */
        *perr = OS_ERR_TASK_NOT_EXIST;
81140058:	e0bfff17 	ldw	r2,-4(fp)
8114005c:	00c010c4 	movi	r3,67
81140060:	10c00005 	stb	r3,0(r2)
        return (0);
81140064:	0005883a 	mov	r2,zero
81140068:	00000d06 	br	811400a0 <OSTaskNameGet+0x18c>
    }
    len   = OS_StrCopy(pname, ptcb->OSTCBTaskName);      /* Yes, copy name from TCB                    */
8114006c:	e0bff817 	ldw	r2,-32(fp)
81140070:	10801304 	addi	r2,r2,76
81140074:	100b883a 	mov	r5,r2
81140078:	e13ffe17 	ldw	r4,-8(fp)
8114007c:	1139dbc0 	call	81139dbc <OS_StrCopy>
81140080:	e0bffb05 	stb	r2,-20(fp)
81140084:	e0bff617 	ldw	r2,-40(fp)
81140088:	e0bffa15 	stw	r2,-24(fp)
8114008c:	e0bffa17 	ldw	r2,-24(fp)
81140090:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81140094:	e0bfff17 	ldw	r2,-4(fp)
81140098:	10000005 	stb	zero,0(r2)
    return (len);
8114009c:	e0bffb03 	ldbu	r2,-20(fp)
}
811400a0:	e037883a 	mov	sp,fp
811400a4:	dfc00117 	ldw	ra,4(sp)
811400a8:	df000017 	ldw	fp,0(sp)
811400ac:	dec00204 	addi	sp,sp,8
811400b0:	f800283a 	ret

811400b4 <OSTaskNameSet>:
* Returns    : None
*********************************************************************************************************
*/
#if OS_TASK_NAME_SIZE > 1
void  OSTaskNameSet (INT8U prio, INT8U *pname, INT8U *perr)
{
811400b4:	defff304 	addi	sp,sp,-52
811400b8:	de00012e 	bgeu	sp,et,811400c0 <OSTaskNameSet+0xc>
811400bc:	003b68fa 	trap	3
811400c0:	dfc00c15 	stw	ra,48(sp)
811400c4:	df000b15 	stw	fp,44(sp)
811400c8:	df000b04 	addi	fp,sp,44
811400cc:	2005883a 	mov	r2,r4
811400d0:	e17ffe15 	stw	r5,-8(fp)
811400d4:	e1bfff15 	stw	r6,-4(fp)
811400d8:	e0bffd05 	stb	r2,-12(fp)
    INT8U      len;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
811400dc:	e03ff515 	stw	zero,-44(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
811400e0:	e0bfff17 	ldw	r2,-4(fp)
811400e4:	10005c26 	beq	r2,zero,81140258 <OSTaskNameSet+0x1a4>
        return;
    }
    if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
811400e8:	e0bffd03 	ldbu	r2,-12(fp)
811400ec:	10800af0 	cmpltui	r2,r2,43
811400f0:	1000071e 	bne	r2,zero,81140110 <OSTaskNameSet+0x5c>
        if (prio != OS_PRIO_SELF) {
811400f4:	e0bffd03 	ldbu	r2,-12(fp)
811400f8:	10803fe0 	cmpeqi	r2,r2,255
811400fc:	1000041e 	bne	r2,zero,81140110 <OSTaskNameSet+0x5c>
            *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
81140100:	e0bfff17 	ldw	r2,-4(fp)
81140104:	00c00a84 	movi	r3,42
81140108:	10c00005 	stb	r3,0(r2)
            return;
8114010c:	00005306 	br	8114025c <OSTaskNameSet+0x1a8>
        }
    }
    if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
81140110:	e0bffe17 	ldw	r2,-8(fp)
81140114:	1000041e 	bne	r2,zero,81140128 <OSTaskNameSet+0x74>
        *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
81140118:	e0bfff17 	ldw	r2,-4(fp)
8114011c:	00c00304 	movi	r3,12
81140120:	10c00005 	stb	r3,0(r2)
        return;
81140124:	00004d06 	br	8114025c <OSTaskNameSet+0x1a8>
    }
#endif
    if (OSIntNesting > 0) {                          /* See if trying to call from an ISR              */
81140128:	d0a0a103 	ldbu	r2,-32124(gp)
8114012c:	10803fcc 	andi	r2,r2,255
81140130:	10000426 	beq	r2,zero,81140144 <OSTaskNameSet+0x90>
        *perr = OS_ERR_NAME_SET_ISR;
81140134:	e0bfff17 	ldw	r2,-4(fp)
81140138:	00c00484 	movi	r3,18
8114013c:	10c00005 	stb	r3,0(r2)
        return;
81140140:	00004606 	br	8114025c <OSTaskNameSet+0x1a8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140144:	0005303a 	rdctl	r2,status
81140148:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114014c:	e0fffc17 	ldw	r3,-16(fp)
81140150:	00bfff84 	movi	r2,-2
81140154:	1884703a 	and	r2,r3,r2
81140158:	1001703a 	wrctl	status,r2
  
  return context;
8114015c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81140160:	e0bff515 	stw	r2,-44(fp)
    if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
81140164:	e0bffd03 	ldbu	r2,-12(fp)
81140168:	10803fd8 	cmpnei	r2,r2,255
8114016c:	1000031e 	bne	r2,zero,8114017c <OSTaskNameSet+0xc8>
        prio = OSTCBCur->OSTCBPrio;
81140170:	d0a0a217 	ldw	r2,-32120(gp)
81140174:	10800c83 	ldbu	r2,50(r2)
81140178:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8114017c:	e0fffd03 	ldbu	r3,-12(fp)
81140180:	00a045f4 	movhi	r2,33047
81140184:	10b41904 	addi	r2,r2,-12188
81140188:	18c7883a 	add	r3,r3,r3
8114018c:	18c7883a 	add	r3,r3,r3
81140190:	10c5883a 	add	r2,r2,r3
81140194:	10800017 	ldw	r2,0(r2)
81140198:	e0bff715 	stw	r2,-36(fp)
    if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
8114019c:	e0bff717 	ldw	r2,-36(fp)
811401a0:	1000081e 	bne	r2,zero,811401c4 <OSTaskNameSet+0x110>
811401a4:	e0bff517 	ldw	r2,-44(fp)
811401a8:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811401ac:	e0bff617 	ldw	r2,-40(fp)
811401b0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* No                                             */
        *perr = OS_ERR_TASK_NOT_EXIST;
811401b4:	e0bfff17 	ldw	r2,-4(fp)
811401b8:	00c010c4 	movi	r3,67
811401bc:	10c00005 	stb	r3,0(r2)
        return;
811401c0:	00002606 	br	8114025c <OSTaskNameSet+0x1a8>
    }
    if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
811401c4:	e0bff717 	ldw	r2,-36(fp)
811401c8:	10800058 	cmpnei	r2,r2,1
811401cc:	1000081e 	bne	r2,zero,811401f0 <OSTaskNameSet+0x13c>
811401d0:	e0bff517 	ldw	r2,-44(fp)
811401d4:	e0bff815 	stw	r2,-32(fp)
811401d8:	e0bff817 	ldw	r2,-32(fp)
811401dc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* Yes                                            */
        *perr = OS_ERR_TASK_NOT_EXIST;
811401e0:	e0bfff17 	ldw	r2,-4(fp)
811401e4:	00c010c4 	movi	r3,67
811401e8:	10c00005 	stb	r3,0(r2)
        return;
811401ec:	00001b06 	br	8114025c <OSTaskNameSet+0x1a8>
    }
    len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
811401f0:	e13ffe17 	ldw	r4,-8(fp)
811401f4:	1139e380 	call	81139e38 <OS_StrLen>
811401f8:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
811401fc:	e0bffa03 	ldbu	r2,-24(fp)
81140200:	10800830 	cmpltui	r2,r2,32
81140204:	1000081e 	bne	r2,zero,81140228 <OSTaskNameSet+0x174>
81140208:	e0bff517 	ldw	r2,-44(fp)
8114020c:	e0bff915 	stw	r2,-28(fp)
81140210:	e0bff917 	ldw	r2,-28(fp)
81140214:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_TASK_NAME_TOO_LONG;
81140218:	e0bfff17 	ldw	r2,-4(fp)
8114021c:	00c01044 	movi	r3,65
81140220:	10c00005 	stb	r3,0(r2)
        return;
81140224:	00000d06 	br	8114025c <OSTaskNameSet+0x1a8>
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
81140228:	e0bff717 	ldw	r2,-36(fp)
8114022c:	10801304 	addi	r2,r2,76
81140230:	e17ffe17 	ldw	r5,-8(fp)
81140234:	1009883a 	mov	r4,r2
81140238:	1139dbc0 	call	81139dbc <OS_StrCopy>
8114023c:	e0bff517 	ldw	r2,-44(fp)
81140240:	e0bffb15 	stw	r2,-20(fp)
81140244:	e0bffb17 	ldw	r2,-20(fp)
81140248:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8114024c:	e0bfff17 	ldw	r2,-4(fp)
81140250:	10000005 	stb	zero,0(r2)
81140254:	00000106 	br	8114025c <OSTaskNameSet+0x1a8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
        return;
81140258:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
8114025c:	e037883a 	mov	sp,fp
81140260:	dfc00117 	ldw	ra,4(sp)
81140264:	df000017 	ldw	fp,0(sp)
81140268:	dec00204 	addi	sp,sp,8
8114026c:	f800283a 	ret

81140270 <OSTaskResume>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskResume (INT8U prio)
{
81140270:	defff404 	addi	sp,sp,-48
81140274:	de00012e 	bgeu	sp,et,8114027c <OSTaskResume+0xc>
81140278:	003b68fa 	trap	3
8114027c:	dfc00b15 	stw	ra,44(sp)
81140280:	df000a15 	stw	fp,40(sp)
81140284:	df000a04 	addi	fp,sp,40
81140288:	2005883a 	mov	r2,r4
8114028c:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                   /* Storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
81140290:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
81140294:	e0bfff03 	ldbu	r2,-4(fp)
81140298:	10800ab0 	cmpltui	r2,r2,42
8114029c:	1000021e 	bne	r2,zero,811402a8 <OSTaskResume+0x38>
        return (OS_ERR_PRIO_INVALID);
811402a0:	00800a84 	movi	r2,42
811402a4:	00006406 	br	81140438 <OSTaskResume+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811402a8:	0005303a 	rdctl	r2,status
811402ac:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811402b0:	e0fffe17 	ldw	r3,-8(fp)
811402b4:	00bfff84 	movi	r2,-2
811402b8:	1884703a 	and	r2,r3,r2
811402bc:	1001703a 	wrctl	status,r2
  
  return context;
811402c0:	e0bffe17 	ldw	r2,-8(fp)
    }
#endif
    OS_ENTER_CRITICAL();
811402c4:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
811402c8:	e0ffff03 	ldbu	r3,-4(fp)
811402cc:	00a045f4 	movhi	r2,33047
811402d0:	10b41904 	addi	r2,r2,-12188
811402d4:	18c7883a 	add	r3,r3,r3
811402d8:	18c7883a 	add	r3,r3,r3
811402dc:	10c5883a 	add	r2,r2,r3
811402e0:	10800017 	ldw	r2,0(r2)
811402e4:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
811402e8:	e0bff817 	ldw	r2,-32(fp)
811402ec:	1000061e 	bne	r2,zero,81140308 <OSTaskResume+0x98>
811402f0:	e0bff617 	ldw	r2,-40(fp)
811402f4:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811402f8:	e0bff717 	ldw	r2,-36(fp)
811402fc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_RESUME_PRIO);
81140300:	00801184 	movi	r2,70
81140304:	00004c06 	br	81140438 <OSTaskResume+0x1c8>
    }
    if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
81140308:	e0bff817 	ldw	r2,-32(fp)
8114030c:	10800058 	cmpnei	r2,r2,1
81140310:	1000061e 	bne	r2,zero,8114032c <OSTaskResume+0xbc>
81140314:	e0bff617 	ldw	r2,-40(fp)
81140318:	e0bff915 	stw	r2,-28(fp)
8114031c:	e0bff917 	ldw	r2,-28(fp)
81140320:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81140324:	008010c4 	movi	r2,67
81140328:	00004306 	br	81140438 <OSTaskResume+0x1c8>
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
8114032c:	e0bff817 	ldw	r2,-32(fp)
81140330:	10800c03 	ldbu	r2,48(r2)
81140334:	10803fcc 	andi	r2,r2,255
81140338:	1080020c 	andi	r2,r2,8
8114033c:	10003926 	beq	r2,zero,81140424 <OSTaskResume+0x1b4>
        ptcb->OSTCBStat &= ~(INT8U)OS_STAT_SUSPEND;           /* Remove suspension                     */
81140340:	e0bff817 	ldw	r2,-32(fp)
81140344:	10c00c03 	ldbu	r3,48(r2)
81140348:	00bffdc4 	movi	r2,-9
8114034c:	1884703a 	and	r2,r3,r2
81140350:	1007883a 	mov	r3,r2
81140354:	e0bff817 	ldw	r2,-32(fp)
81140358:	10c00c05 	stb	r3,48(r2)
        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
8114035c:	e0bff817 	ldw	r2,-32(fp)
81140360:	10800c03 	ldbu	r2,48(r2)
81140364:	10803fcc 	andi	r2,r2,255
81140368:	1000281e 	bne	r2,zero,8114040c <OSTaskResume+0x19c>
            if (ptcb->OSTCBDly == 0) {
8114036c:	e0bff817 	ldw	r2,-32(fp)
81140370:	10800b8b 	ldhu	r2,46(r2)
81140374:	10bfffcc 	andi	r2,r2,65535
81140378:	10001f1e 	bne	r2,zero,811403f8 <OSTaskResume+0x188>
                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
8114037c:	e0bff817 	ldw	r2,-32(fp)
81140380:	10c00d83 	ldbu	r3,54(r2)
81140384:	d0a09e03 	ldbu	r2,-32136(gp)
81140388:	1884b03a 	or	r2,r3,r2
8114038c:	d0a09e05 	stb	r2,-32136(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81140390:	e0bff817 	ldw	r2,-32(fp)
81140394:	10800d03 	ldbu	r2,52(r2)
81140398:	10c03fcc 	andi	r3,r2,255
8114039c:	e0bff817 	ldw	r2,-32(fp)
811403a0:	10800d03 	ldbu	r2,52(r2)
811403a4:	11003fcc 	andi	r4,r2,255
811403a8:	d0a09e44 	addi	r2,gp,-32135
811403ac:	2085883a 	add	r2,r4,r2
811403b0:	11000003 	ldbu	r4,0(r2)
811403b4:	e0bff817 	ldw	r2,-32(fp)
811403b8:	10800d43 	ldbu	r2,53(r2)
811403bc:	2084b03a 	or	r2,r4,r2
811403c0:	1009883a 	mov	r4,r2
811403c4:	d0a09e44 	addi	r2,gp,-32135
811403c8:	1885883a 	add	r2,r3,r2
811403cc:	11000005 	stb	r4,0(r2)
811403d0:	e0bff617 	ldw	r2,-40(fp)
811403d4:	e0bffa15 	stw	r2,-24(fp)
811403d8:	e0bffa17 	ldw	r2,-24(fp)
811403dc:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
                if (OSRunning == OS_TRUE) {
811403e0:	d0a09103 	ldbu	r2,-32188(gp)
811403e4:	10803fcc 	andi	r2,r2,255
811403e8:	10800058 	cmpnei	r2,r2,1
811403ec:	10000b1e 	bne	r2,zero,8114041c <OSTaskResume+0x1ac>
                    OS_Sched();                               /* Find new highest priority task        */
811403f0:	1139c680 	call	81139c68 <OS_Sched>
811403f4:	00000906 	br	8114041c <OSTaskResume+0x1ac>
811403f8:	e0bff617 	ldw	r2,-40(fp)
811403fc:	e0bffb15 	stw	r2,-20(fp)
81140400:	e0bffb17 	ldw	r2,-20(fp)
81140404:	1001703a 	wrctl	status,r2
81140408:	00000406 	br	8114041c <OSTaskResume+0x1ac>
8114040c:	e0bff617 	ldw	r2,-40(fp)
81140410:	e0bffc15 	stw	r2,-16(fp)
81140414:	e0bffc17 	ldw	r2,-16(fp)
81140418:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
            }
        } else {                                              /* Must be pending on event              */
            OS_EXIT_CRITICAL();
        }
        return (OS_ERR_NONE);
8114041c:	0005883a 	mov	r2,zero
81140420:	00000506 	br	81140438 <OSTaskResume+0x1c8>
81140424:	e0bff617 	ldw	r2,-40(fp)
81140428:	e0bffd15 	stw	r2,-12(fp)
8114042c:	e0bffd17 	ldw	r2,-12(fp)
81140430:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NOT_SUSPENDED);
81140434:	00801104 	movi	r2,68
}
81140438:	e037883a 	mov	sp,fp
8114043c:	dfc00117 	ldw	ra,4(sp)
81140440:	df000017 	ldw	fp,0(sp)
81140444:	dec00204 	addi	sp,sp,8
81140448:	f800283a 	ret

8114044c <OSTaskStkChk>:
*              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
8114044c:	defff304 	addi	sp,sp,-52
81140450:	de00012e 	bgeu	sp,et,81140458 <OSTaskStkChk+0xc>
81140454:	003b68fa 	trap	3
81140458:	df000c15 	stw	fp,48(sp)
8114045c:	df000c04 	addi	fp,sp,48
81140460:	2005883a 	mov	r2,r4
81140464:	e17fff15 	stw	r5,-4(fp)
81140468:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
    OS_STK    *pchk;
    INT32U     nfree;
    INT32U     size;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8114046c:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
81140470:	e0bffe03 	ldbu	r2,-8(fp)
81140474:	10800af0 	cmpltui	r2,r2,43
81140478:	1000051e 	bne	r2,zero,81140490 <OSTaskStkChk+0x44>
        if (prio != OS_PRIO_SELF) {
8114047c:	e0bffe03 	ldbu	r2,-8(fp)
81140480:	10803fe0 	cmpeqi	r2,r2,255
81140484:	1000021e 	bne	r2,zero,81140490 <OSTaskStkChk+0x44>
            return (OS_ERR_PRIO_INVALID);
81140488:	00800a84 	movi	r2,42
8114048c:	00005d06 	br	81140604 <OSTaskStkChk+0x1b8>
        }
    }
    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
81140490:	e0bfff17 	ldw	r2,-4(fp)
81140494:	1000021e 	bne	r2,zero,811404a0 <OSTaskStkChk+0x54>
        return (OS_ERR_PDATA_NULL);
81140498:	00800244 	movi	r2,9
8114049c:	00005906 	br	81140604 <OSTaskStkChk+0x1b8>
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
811404a0:	e0bfff17 	ldw	r2,-4(fp)
811404a4:	10000015 	stw	zero,0(r2)
    p_stk_data->OSUsed = 0;
811404a8:	e0bfff17 	ldw	r2,-4(fp)
811404ac:	10000115 	stw	zero,4(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811404b0:	0005303a 	rdctl	r2,status
811404b4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811404b8:	e0fffd17 	ldw	r3,-12(fp)
811404bc:	00bfff84 	movi	r2,-2
811404c0:	1884703a 	and	r2,r3,r2
811404c4:	1001703a 	wrctl	status,r2
  
  return context;
811404c8:	e0bffd17 	ldw	r2,-12(fp)
    OS_ENTER_CRITICAL();
811404cc:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
811404d0:	e0bffe03 	ldbu	r2,-8(fp)
811404d4:	10803fd8 	cmpnei	r2,r2,255
811404d8:	1000031e 	bne	r2,zero,811404e8 <OSTaskStkChk+0x9c>
        prio = OSTCBCur->OSTCBPrio;
811404dc:	d0a0a217 	ldw	r2,-32120(gp)
811404e0:	10800c83 	ldbu	r2,50(r2)
811404e4:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
811404e8:	e0fffe03 	ldbu	r3,-8(fp)
811404ec:	00a045f4 	movhi	r2,33047
811404f0:	10b41904 	addi	r2,r2,-12188
811404f4:	18c7883a 	add	r3,r3,r3
811404f8:	18c7883a 	add	r3,r3,r3
811404fc:	10c5883a 	add	r2,r2,r3
81140500:	10800017 	ldw	r2,0(r2)
81140504:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
81140508:	e0bff817 	ldw	r2,-32(fp)
8114050c:	1000061e 	bne	r2,zero,81140528 <OSTaskStkChk+0xdc>
81140510:	e0bff617 	ldw	r2,-40(fp)
81140514:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140518:	e0bff717 	ldw	r2,-36(fp)
8114051c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81140520:	008010c4 	movi	r2,67
81140524:	00003706 	br	81140604 <OSTaskStkChk+0x1b8>
    }
    if (ptcb == OS_TCB_RESERVED) {
81140528:	e0bff817 	ldw	r2,-32(fp)
8114052c:	10800058 	cmpnei	r2,r2,1
81140530:	1000061e 	bne	r2,zero,8114054c <OSTaskStkChk+0x100>
81140534:	e0bff617 	ldw	r2,-40(fp)
81140538:	e0bff915 	stw	r2,-28(fp)
8114053c:	e0bff917 	ldw	r2,-28(fp)
81140540:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81140544:	008010c4 	movi	r2,67
81140548:	00002e06 	br	81140604 <OSTaskStkChk+0x1b8>
    }
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
8114054c:	e0bff817 	ldw	r2,-32(fp)
81140550:	1080040b 	ldhu	r2,16(r2)
81140554:	10bfffcc 	andi	r2,r2,65535
81140558:	1080004c 	andi	r2,r2,1
8114055c:	1000061e 	bne	r2,zero,81140578 <OSTaskStkChk+0x12c>
81140560:	e0bff617 	ldw	r2,-40(fp)
81140564:	e0bffa15 	stw	r2,-24(fp)
81140568:	e0bffa17 	ldw	r2,-24(fp)
8114056c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_OPT);
81140570:	00801144 	movi	r2,69
81140574:	00002306 	br	81140604 <OSTaskStkChk+0x1b8>
    }
    nfree = 0;
81140578:	e03ff515 	stw	zero,-44(fp)
    size  = ptcb->OSTCBStkSize;
8114057c:	e0bff817 	ldw	r2,-32(fp)
81140580:	10800317 	ldw	r2,12(r2)
81140584:	e0bffc15 	stw	r2,-16(fp)
    pchk  = ptcb->OSTCBStkBottom;
81140588:	e0bff817 	ldw	r2,-32(fp)
8114058c:	10800217 	ldw	r2,8(r2)
81140590:	e0bff415 	stw	r2,-48(fp)
81140594:	e0bff617 	ldw	r2,-40(fp)
81140598:	e0bffb15 	stw	r2,-20(fp)
8114059c:	e0bffb17 	ldw	r2,-20(fp)
811405a0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
811405a4:	00000306 	br	811405b4 <OSTaskStkChk+0x168>
        nfree++;
811405a8:	e0bff517 	ldw	r2,-44(fp)
811405ac:	10800044 	addi	r2,r2,1
811405b0:	e0bff515 	stw	r2,-44(fp)
    nfree = 0;
    size  = ptcb->OSTCBStkSize;
    pchk  = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
811405b4:	e0bff417 	ldw	r2,-48(fp)
811405b8:	10c00104 	addi	r3,r2,4
811405bc:	e0fff415 	stw	r3,-48(fp)
811405c0:	10800017 	ldw	r2,0(r2)
811405c4:	103ff826 	beq	r2,zero,811405a8 <__reset+0xfb1205a8>
#else
    while (*pchk-- == (OS_STK)0) {
        nfree++;
    }
#endif
    p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
811405c8:	e0bff517 	ldw	r2,-44(fp)
811405cc:	1085883a 	add	r2,r2,r2
811405d0:	1085883a 	add	r2,r2,r2
811405d4:	1007883a 	mov	r3,r2
811405d8:	e0bfff17 	ldw	r2,-4(fp)
811405dc:	10c00015 	stw	r3,0(r2)
    p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
811405e0:	e0fffc17 	ldw	r3,-16(fp)
811405e4:	e0bff517 	ldw	r2,-44(fp)
811405e8:	1885c83a 	sub	r2,r3,r2
811405ec:	1085883a 	add	r2,r2,r2
811405f0:	1085883a 	add	r2,r2,r2
811405f4:	1007883a 	mov	r3,r2
811405f8:	e0bfff17 	ldw	r2,-4(fp)
811405fc:	10c00115 	stw	r3,4(r2)
    return (OS_ERR_NONE);
81140600:	0005883a 	mov	r2,zero
}
81140604:	e037883a 	mov	sp,fp
81140608:	df000017 	ldw	fp,0(sp)
8114060c:	dec00104 	addi	sp,sp,4
81140610:	f800283a 	ret

81140614 <OSTaskSuspend>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskSuspend (INT8U prio)
{
81140614:	defff504 	addi	sp,sp,-44
81140618:	de00012e 	bgeu	sp,et,81140620 <OSTaskSuspend+0xc>
8114061c:	003b68fa 	trap	3
81140620:	dfc00a15 	stw	ra,40(sp)
81140624:	df000915 	stw	fp,36(sp)
81140628:	df000904 	addi	fp,sp,36
8114062c:	2005883a 	mov	r2,r4
81140630:	e0bfff05 	stb	r2,-4(fp)
    BOOLEAN    self;
    OS_TCB    *ptcb;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81140634:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
81140638:	e0bfff03 	ldbu	r2,-4(fp)
8114063c:	10800a98 	cmpnei	r2,r2,42
81140640:	1000021e 	bne	r2,zero,8114064c <OSTaskSuspend+0x38>
        return (OS_ERR_TASK_SUSPEND_IDLE);
81140644:	008011c4 	movi	r2,71
81140648:	00006806 	br	811407ec <OSTaskSuspend+0x1d8>
    }
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
8114064c:	e0bfff03 	ldbu	r2,-4(fp)
81140650:	10800ab0 	cmpltui	r2,r2,42
81140654:	1000051e 	bne	r2,zero,8114066c <OSTaskSuspend+0x58>
        if (prio != OS_PRIO_SELF) {
81140658:	e0bfff03 	ldbu	r2,-4(fp)
8114065c:	10803fe0 	cmpeqi	r2,r2,255
81140660:	1000021e 	bne	r2,zero,8114066c <OSTaskSuspend+0x58>
            return (OS_ERR_PRIO_INVALID);
81140664:	00800a84 	movi	r2,42
81140668:	00006006 	br	811407ec <OSTaskSuspend+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114066c:	0005303a 	rdctl	r2,status
81140670:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140674:	e0fffe17 	ldw	r3,-8(fp)
81140678:	00bfff84 	movi	r2,-2
8114067c:	1884703a 	and	r2,r3,r2
81140680:	1001703a 	wrctl	status,r2
  
  return context;
81140684:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif
    OS_ENTER_CRITICAL();
81140688:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
8114068c:	e0bfff03 	ldbu	r2,-4(fp)
81140690:	10803fd8 	cmpnei	r2,r2,255
81140694:	1000061e 	bne	r2,zero,811406b0 <OSTaskSuspend+0x9c>
        prio = OSTCBCur->OSTCBPrio;
81140698:	d0a0a217 	ldw	r2,-32120(gp)
8114069c:	10800c83 	ldbu	r2,50(r2)
811406a0:	e0bfff05 	stb	r2,-4(fp)
        self = OS_TRUE;
811406a4:	00800044 	movi	r2,1
811406a8:	e0bff705 	stb	r2,-36(fp)
811406ac:	00000906 	br	811406d4 <OSTaskSuspend+0xc0>
    } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
811406b0:	d0a0a217 	ldw	r2,-32120(gp)
811406b4:	10800c83 	ldbu	r2,50(r2)
811406b8:	10c03fcc 	andi	r3,r2,255
811406bc:	e0bfff03 	ldbu	r2,-4(fp)
811406c0:	1880031e 	bne	r3,r2,811406d0 <OSTaskSuspend+0xbc>
        self = OS_TRUE;
811406c4:	00800044 	movi	r2,1
811406c8:	e0bff705 	stb	r2,-36(fp)
811406cc:	00000106 	br	811406d4 <OSTaskSuspend+0xc0>
    } else {
        self = OS_FALSE;                                        /* No suspending another task          */
811406d0:	e03ff705 	stb	zero,-36(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
811406d4:	e0ffff03 	ldbu	r3,-4(fp)
811406d8:	00a045f4 	movhi	r2,33047
811406dc:	10b41904 	addi	r2,r2,-12188
811406e0:	18c7883a 	add	r3,r3,r3
811406e4:	18c7883a 	add	r3,r3,r3
811406e8:	10c5883a 	add	r2,r2,r3
811406ec:	10800017 	ldw	r2,0(r2)
811406f0:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
811406f4:	e0bffa17 	ldw	r2,-24(fp)
811406f8:	1000061e 	bne	r2,zero,81140714 <OSTaskSuspend+0x100>
811406fc:	e0bff817 	ldw	r2,-32(fp)
81140700:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140704:	e0bff917 	ldw	r2,-28(fp)
81140708:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_SUSPEND_PRIO);
8114070c:	00801204 	movi	r2,72
81140710:	00003606 	br	811407ec <OSTaskSuspend+0x1d8>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
81140714:	e0bffa17 	ldw	r2,-24(fp)
81140718:	10800058 	cmpnei	r2,r2,1
8114071c:	1000061e 	bne	r2,zero,81140738 <OSTaskSuspend+0x124>
81140720:	e0bff817 	ldw	r2,-32(fp)
81140724:	e0bffb15 	stw	r2,-20(fp)
81140728:	e0bffb17 	ldw	r2,-20(fp)
8114072c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81140730:	008010c4 	movi	r2,67
81140734:	00002d06 	br	811407ec <OSTaskSuspend+0x1d8>
    }
    y            = ptcb->OSTCBY;
81140738:	e0bffa17 	ldw	r2,-24(fp)
8114073c:	10800d03 	ldbu	r2,52(r2)
81140740:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
81140744:	e0fffd03 	ldbu	r3,-12(fp)
81140748:	e13ffd03 	ldbu	r4,-12(fp)
8114074c:	d0a09e44 	addi	r2,gp,-32135
81140750:	2085883a 	add	r2,r4,r2
81140754:	10800003 	ldbu	r2,0(r2)
81140758:	1009883a 	mov	r4,r2
8114075c:	e0bffa17 	ldw	r2,-24(fp)
81140760:	10800d43 	ldbu	r2,53(r2)
81140764:	0084303a 	nor	r2,zero,r2
81140768:	2084703a 	and	r2,r4,r2
8114076c:	1009883a 	mov	r4,r2
81140770:	d0a09e44 	addi	r2,gp,-32135
81140774:	1885883a 	add	r2,r3,r2
81140778:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
8114077c:	e0fffd03 	ldbu	r3,-12(fp)
81140780:	d0a09e44 	addi	r2,gp,-32135
81140784:	1885883a 	add	r2,r3,r2
81140788:	10800003 	ldbu	r2,0(r2)
8114078c:	10803fcc 	andi	r2,r2,255
81140790:	1000071e 	bne	r2,zero,811407b0 <OSTaskSuspend+0x19c>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
81140794:	e0bffa17 	ldw	r2,-24(fp)
81140798:	10800d83 	ldbu	r2,54(r2)
8114079c:	0084303a 	nor	r2,zero,r2
811407a0:	1007883a 	mov	r3,r2
811407a4:	d0a09e03 	ldbu	r2,-32136(gp)
811407a8:	1884703a 	and	r2,r3,r2
811407ac:	d0a09e05 	stb	r2,-32136(gp)
    }
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
811407b0:	e0bffa17 	ldw	r2,-24(fp)
811407b4:	10800c03 	ldbu	r2,48(r2)
811407b8:	10800214 	ori	r2,r2,8
811407bc:	1007883a 	mov	r3,r2
811407c0:	e0bffa17 	ldw	r2,-24(fp)
811407c4:	10c00c05 	stb	r3,48(r2)
811407c8:	e0bff817 	ldw	r2,-32(fp)
811407cc:	e0bffc15 	stw	r2,-16(fp)
811407d0:	e0bffc17 	ldw	r2,-16(fp)
811407d4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
811407d8:	e0bff703 	ldbu	r2,-36(fp)
811407dc:	10800058 	cmpnei	r2,r2,1
811407e0:	1000011e 	bne	r2,zero,811407e8 <OSTaskSuspend+0x1d4>
        OS_Sched();                                             /* Find new highest priority task      */
811407e4:	1139c680 	call	81139c68 <OS_Sched>
    }
    return (OS_ERR_NONE);
811407e8:	0005883a 	mov	r2,zero
}
811407ec:	e037883a 	mov	sp,fp
811407f0:	dfc00117 	ldw	ra,4(sp)
811407f4:	df000017 	ldw	fp,0(sp)
811407f8:	dec00204 	addi	sp,sp,8
811407fc:	f800283a 	ret

81140800 <OSTaskQuery>:
*********************************************************************************************************
*/

#if OS_TASK_QUERY_EN > 0
INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
{
81140800:	defff604 	addi	sp,sp,-40
81140804:	de00012e 	bgeu	sp,et,8114080c <OSTaskQuery+0xc>
81140808:	003b68fa 	trap	3
8114080c:	dfc00915 	stw	ra,36(sp)
81140810:	df000815 	stw	fp,32(sp)
81140814:	df000804 	addi	fp,sp,32
81140818:	2005883a 	mov	r2,r4
8114081c:	e17fff15 	stw	r5,-4(fp)
81140820:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81140824:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
81140828:	e0bffe03 	ldbu	r2,-8(fp)
8114082c:	10800af0 	cmpltui	r2,r2,43
81140830:	1000051e 	bne	r2,zero,81140848 <OSTaskQuery+0x48>
        if (prio != OS_PRIO_SELF) {
81140834:	e0bffe03 	ldbu	r2,-8(fp)
81140838:	10803fe0 	cmpeqi	r2,r2,255
8114083c:	1000021e 	bne	r2,zero,81140848 <OSTaskQuery+0x48>
            return (OS_ERR_PRIO_INVALID);
81140840:	00800a84 	movi	r2,42
81140844:	00003406 	br	81140918 <OSTaskQuery+0x118>
        }
    }
    if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
81140848:	e0bfff17 	ldw	r2,-4(fp)
8114084c:	1000021e 	bne	r2,zero,81140858 <OSTaskQuery+0x58>
        return (OS_ERR_PDATA_NULL);
81140850:	00800244 	movi	r2,9
81140854:	00003006 	br	81140918 <OSTaskQuery+0x118>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140858:	0005303a 	rdctl	r2,status
8114085c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140860:	e0fffd17 	ldw	r3,-12(fp)
81140864:	00bfff84 	movi	r2,-2
81140868:	1884703a 	and	r2,r3,r2
8114086c:	1001703a 	wrctl	status,r2
  
  return context;
81140870:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81140874:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
81140878:	e0bffe03 	ldbu	r2,-8(fp)
8114087c:	10803fd8 	cmpnei	r2,r2,255
81140880:	1000031e 	bne	r2,zero,81140890 <OSTaskQuery+0x90>
        prio = OSTCBCur->OSTCBPrio;
81140884:	d0a0a217 	ldw	r2,-32120(gp)
81140888:	10800c83 	ldbu	r2,50(r2)
8114088c:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
81140890:	e0fffe03 	ldbu	r3,-8(fp)
81140894:	00a045f4 	movhi	r2,33047
81140898:	10b41904 	addi	r2,r2,-12188
8114089c:	18c7883a 	add	r3,r3,r3
811408a0:	18c7883a 	add	r3,r3,r3
811408a4:	10c5883a 	add	r2,r2,r3
811408a8:	10800017 	ldw	r2,0(r2)
811408ac:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
811408b0:	e0bffa17 	ldw	r2,-24(fp)
811408b4:	1000061e 	bne	r2,zero,811408d0 <OSTaskQuery+0xd0>
811408b8:	e0bff817 	ldw	r2,-32(fp)
811408bc:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811408c0:	e0bff917 	ldw	r2,-28(fp)
811408c4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO);
811408c8:	00800a44 	movi	r2,41
811408cc:	00001206 	br	81140918 <OSTaskQuery+0x118>
    }
    if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
811408d0:	e0bffa17 	ldw	r2,-24(fp)
811408d4:	10800058 	cmpnei	r2,r2,1
811408d8:	1000061e 	bne	r2,zero,811408f4 <OSTaskQuery+0xf4>
811408dc:	e0bff817 	ldw	r2,-32(fp)
811408e0:	e0bffb15 	stw	r2,-20(fp)
811408e4:	e0bffb17 	ldw	r2,-20(fp)
811408e8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
811408ec:	008010c4 	movi	r2,67
811408f0:	00000906 	br	81140918 <OSTaskQuery+0x118>
    }
                                                 /* Copy TCB into user storage area                    */
    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
811408f4:	01801b04 	movi	r6,108
811408f8:	e17ffa17 	ldw	r5,-24(fp)
811408fc:	e13fff17 	ldw	r4,-4(fp)
81140900:	1139bf80 	call	81139bf8 <OS_MemCopy>
81140904:	e0bff817 	ldw	r2,-32(fp)
81140908:	e0bffc15 	stw	r2,-16(fp)
8114090c:	e0bffc17 	ldw	r2,-16(fp)
81140910:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81140914:	0005883a 	mov	r2,zero
}
81140918:	e037883a 	mov	sp,fp
8114091c:	dfc00117 	ldw	ra,4(sp)
81140920:	df000017 	ldw	fp,0(sp)
81140924:	dec00204 	addi	sp,sp,8
81140928:	f800283a 	ret

8114092c <OS_TaskStkClr>:
* Returns    : none
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
8114092c:	defffc04 	addi	sp,sp,-16
81140930:	de00012e 	bgeu	sp,et,81140938 <OS_TaskStkClr+0xc>
81140934:	003b68fa 	trap	3
81140938:	df000315 	stw	fp,12(sp)
8114093c:	df000304 	addi	fp,sp,12
81140940:	e13ffd15 	stw	r4,-12(fp)
81140944:	e17ffe15 	stw	r5,-8(fp)
81140948:	3005883a 	mov	r2,r6
8114094c:	e0bfff0d 	sth	r2,-4(fp)
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
81140950:	e0bfff0b 	ldhu	r2,-4(fp)
81140954:	1080004c 	andi	r2,r2,1
81140958:	10000d26 	beq	r2,zero,81140990 <OS_TaskStkClr+0x64>
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
8114095c:	e0bfff0b 	ldhu	r2,-4(fp)
81140960:	1080008c 	andi	r2,r2,2
81140964:	10000a26 	beq	r2,zero,81140990 <OS_TaskStkClr+0x64>
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
81140968:	00000706 	br	81140988 <OS_TaskStkClr+0x5c>
                size--;
8114096c:	e0bffe17 	ldw	r2,-8(fp)
81140970:	10bfffc4 	addi	r2,r2,-1
81140974:	e0bffe15 	stw	r2,-8(fp)
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
81140978:	e0bffd17 	ldw	r2,-12(fp)
8114097c:	10c00104 	addi	r3,r2,4
81140980:	e0fffd15 	stw	r3,-12(fp)
81140984:	10000015 	stw	zero,0(r2)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
81140988:	e0bffe17 	ldw	r2,-8(fp)
8114098c:	103ff71e 	bne	r2,zero,8114096c <__reset+0xfb12096c>
                *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
            }
#endif
        }
    }
}
81140990:	0001883a 	nop
81140994:	e037883a 	mov	sp,fp
81140998:	df000017 	ldw	fp,0(sp)
8114099c:	dec00104 	addi	sp,sp,4
811409a0:	f800283a 	ret

811409a4 <OSTimeDly>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT16U ticks)
{
811409a4:	defff904 	addi	sp,sp,-28
811409a8:	de00012e 	bgeu	sp,et,811409b0 <OSTimeDly+0xc>
811409ac:	003b68fa 	trap	3
811409b0:	dfc00615 	stw	ra,24(sp)
811409b4:	df000515 	stw	fp,20(sp)
811409b8:	df000504 	addi	fp,sp,20
811409bc:	2005883a 	mov	r2,r4
811409c0:	e0bfff0d 	sth	r2,-4(fp)
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811409c4:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
811409c8:	d0a0a103 	ldbu	r2,-32124(gp)
811409cc:	10803fcc 	andi	r2,r2,255
811409d0:	1000311e 	bne	r2,zero,81140a98 <OSTimeDly+0xf4>
        return;
    }
    if (ticks > 0) {                             /* 0 means no delay!                                  */
811409d4:	e0bfff0b 	ldhu	r2,-4(fp)
811409d8:	10003026 	beq	r2,zero,81140a9c <OSTimeDly+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811409dc:	0005303a 	rdctl	r2,status
811409e0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811409e4:	e0fffe17 	ldw	r3,-8(fp)
811409e8:	00bfff84 	movi	r2,-2
811409ec:	1884703a 	and	r2,r3,r2
811409f0:	1001703a 	wrctl	status,r2
  
  return context;
811409f4:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
811409f8:	e0bffb15 	stw	r2,-20(fp)
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
811409fc:	d0a0a217 	ldw	r2,-32120(gp)
81140a00:	10800d03 	ldbu	r2,52(r2)
81140a04:	e0bffd05 	stb	r2,-12(fp)
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
81140a08:	e0fffd03 	ldbu	r3,-12(fp)
81140a0c:	e13ffd03 	ldbu	r4,-12(fp)
81140a10:	d0a09e44 	addi	r2,gp,-32135
81140a14:	2085883a 	add	r2,r4,r2
81140a18:	10800003 	ldbu	r2,0(r2)
81140a1c:	1009883a 	mov	r4,r2
81140a20:	d0a0a217 	ldw	r2,-32120(gp)
81140a24:	10800d43 	ldbu	r2,53(r2)
81140a28:	0084303a 	nor	r2,zero,r2
81140a2c:	2084703a 	and	r2,r4,r2
81140a30:	1009883a 	mov	r4,r2
81140a34:	d0a09e44 	addi	r2,gp,-32135
81140a38:	1885883a 	add	r2,r3,r2
81140a3c:	11000005 	stb	r4,0(r2)
        if (OSRdyTbl[y] == 0) {
81140a40:	e0fffd03 	ldbu	r3,-12(fp)
81140a44:	d0a09e44 	addi	r2,gp,-32135
81140a48:	1885883a 	add	r2,r3,r2
81140a4c:	10800003 	ldbu	r2,0(r2)
81140a50:	10803fcc 	andi	r2,r2,255
81140a54:	1000071e 	bne	r2,zero,81140a74 <OSTimeDly+0xd0>
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
81140a58:	d0a0a217 	ldw	r2,-32120(gp)
81140a5c:	10800d83 	ldbu	r2,54(r2)
81140a60:	0084303a 	nor	r2,zero,r2
81140a64:	1007883a 	mov	r3,r2
81140a68:	d0a09e03 	ldbu	r2,-32136(gp)
81140a6c:	1884703a 	and	r2,r3,r2
81140a70:	d0a09e05 	stb	r2,-32136(gp)
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
81140a74:	d0a0a217 	ldw	r2,-32120(gp)
81140a78:	e0ffff0b 	ldhu	r3,-4(fp)
81140a7c:	10c00b8d 	sth	r3,46(r2)
81140a80:	e0bffb17 	ldw	r2,-20(fp)
81140a84:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140a88:	e0bffc17 	ldw	r2,-16(fp)
81140a8c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
81140a90:	1139c680 	call	81139c68 <OS_Sched>
81140a94:	00000106 	br	81140a9c <OSTimeDly+0xf8>
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
        return;
81140a98:	0001883a 	nop
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
    }
}
81140a9c:	e037883a 	mov	sp,fp
81140aa0:	dfc00117 	ldw	ra,4(sp)
81140aa4:	df000017 	ldw	fp,0(sp)
81140aa8:	dec00204 	addi	sp,sp,8
81140aac:	f800283a 	ret

81140ab0 <OSTimeDlyHMSM>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U ms)
{
81140ab0:	defff804 	addi	sp,sp,-32
81140ab4:	de00012e 	bgeu	sp,et,81140abc <OSTimeDlyHMSM+0xc>
81140ab8:	003b68fa 	trap	3
81140abc:	dfc00715 	stw	ra,28(sp)
81140ac0:	df000615 	stw	fp,24(sp)
81140ac4:	df000604 	addi	fp,sp,24
81140ac8:	2015883a 	mov	r10,r4
81140acc:	2809883a 	mov	r4,r5
81140ad0:	3007883a 	mov	r3,r6
81140ad4:	3805883a 	mov	r2,r7
81140ad8:	e2bffc05 	stb	r10,-16(fp)
81140adc:	e13ffd05 	stb	r4,-12(fp)
81140ae0:	e0fffe05 	stb	r3,-8(fp)
81140ae4:	e0bfff0d 	sth	r2,-4(fp)
    INT32U ticks;
    INT16U loops;


    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81140ae8:	d0a0a103 	ldbu	r2,-32124(gp)
81140aec:	10803fcc 	andi	r2,r2,255
81140af0:	10000226 	beq	r2,zero,81140afc <OSTimeDlyHMSM+0x4c>
        return (OS_ERR_TIME_DLY_ISR);
81140af4:	00801544 	movi	r2,85
81140af8:	00004106 	br	81140c00 <OSTimeDlyHMSM+0x150>
    }
#if OS_ARG_CHK_EN > 0
    if (hours == 0) {
81140afc:	e0bffc03 	ldbu	r2,-16(fp)
81140b00:	1000081e 	bne	r2,zero,81140b24 <OSTimeDlyHMSM+0x74>
        if (minutes == 0) {
81140b04:	e0bffd03 	ldbu	r2,-12(fp)
81140b08:	1000061e 	bne	r2,zero,81140b24 <OSTimeDlyHMSM+0x74>
            if (seconds == 0) {
81140b0c:	e0bffe03 	ldbu	r2,-8(fp)
81140b10:	1000041e 	bne	r2,zero,81140b24 <OSTimeDlyHMSM+0x74>
                if (ms == 0) {
81140b14:	e0bfff0b 	ldhu	r2,-4(fp)
81140b18:	1000021e 	bne	r2,zero,81140b24 <OSTimeDlyHMSM+0x74>
                    return (OS_ERR_TIME_ZERO_DLY);
81140b1c:	00801504 	movi	r2,84
81140b20:	00003706 	br	81140c00 <OSTimeDlyHMSM+0x150>
                }
            }
        }
    }
    if (minutes > 59) {
81140b24:	e0bffd03 	ldbu	r2,-12(fp)
81140b28:	10800f30 	cmpltui	r2,r2,60
81140b2c:	1000021e 	bne	r2,zero,81140b38 <OSTimeDlyHMSM+0x88>
        return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
81140b30:	00801444 	movi	r2,81
81140b34:	00003206 	br	81140c00 <OSTimeDlyHMSM+0x150>
    }
    if (seconds > 59) {
81140b38:	e0bffe03 	ldbu	r2,-8(fp)
81140b3c:	10800f30 	cmpltui	r2,r2,60
81140b40:	1000021e 	bne	r2,zero,81140b4c <OSTimeDlyHMSM+0x9c>
        return (OS_ERR_TIME_INVALID_SECONDS);
81140b44:	00801484 	movi	r2,82
81140b48:	00002d06 	br	81140c00 <OSTimeDlyHMSM+0x150>
    }
    if (ms > 999) {
81140b4c:	e0bfff0b 	ldhu	r2,-4(fp)
81140b50:	1080fa30 	cmpltui	r2,r2,1000
81140b54:	1000021e 	bne	r2,zero,81140b60 <OSTimeDlyHMSM+0xb0>
        return (OS_ERR_TIME_INVALID_MS);
81140b58:	008014c4 	movi	r2,83
81140b5c:	00002806 	br	81140c00 <OSTimeDlyHMSM+0x150>
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
81140b60:	e0bffc03 	ldbu	r2,-16(fp)
81140b64:	10c38424 	muli	r3,r2,3600
81140b68:	e0bffd03 	ldbu	r2,-12(fp)
81140b6c:	10800f24 	muli	r2,r2,60
81140b70:	1887883a 	add	r3,r3,r2
81140b74:	e0bffe03 	ldbu	r2,-8(fp)
81140b78:	1885883a 	add	r2,r3,r2
81140b7c:	1100fa24 	muli	r4,r2,1000
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
81140b80:	e0bfff0b 	ldhu	r2,-4(fp)
81140b84:	10c0fa24 	muli	r3,r2,1000
81140b88:	008418b4 	movhi	r2,4194
81140b8c:	109374c4 	addi	r2,r2,19923
81140b90:	188a383a 	mulxuu	r5,r3,r2
81140b94:	1885383a 	mul	r2,r3,r2
81140b98:	1011883a 	mov	r8,r2
81140b9c:	2813883a 	mov	r9,r5
81140ba0:	4804d1ba 	srli	r2,r9,6
        return (OS_ERR_TIME_INVALID_MS);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
81140ba4:	2085883a 	add	r2,r4,r2
81140ba8:	e0bffb15 	stw	r2,-20(fp)
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
81140bac:	e0bffb17 	ldw	r2,-20(fp)
81140bb0:	1004d43a 	srli	r2,r2,16
81140bb4:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
81140bb8:	e0bffb17 	ldw	r2,-20(fp)
81140bbc:	10bfffcc 	andi	r2,r2,65535
81140bc0:	e0bffb15 	stw	r2,-20(fp)
    OSTimeDly((INT16U)ticks);
81140bc4:	e0bffb17 	ldw	r2,-20(fp)
81140bc8:	10bfffcc 	andi	r2,r2,65535
81140bcc:	1009883a 	mov	r4,r2
81140bd0:	11409a40 	call	811409a4 <OSTimeDly>
    while (loops > 0) {
81140bd4:	00000706 	br	81140bf4 <OSTimeDlyHMSM+0x144>
        OSTimeDly((INT16U)32768u);
81140bd8:	01200014 	movui	r4,32768
81140bdc:	11409a40 	call	811409a4 <OSTimeDly>
        OSTimeDly((INT16U)32768u);
81140be0:	01200014 	movui	r4,32768
81140be4:	11409a40 	call	811409a4 <OSTimeDly>
        loops--;
81140be8:	e0bffa0b 	ldhu	r2,-24(fp)
81140bec:	10bfffc4 	addi	r2,r2,-1
81140bf0:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
81140bf4:	e0bffa0b 	ldhu	r2,-24(fp)
81140bf8:	103ff71e 	bne	r2,zero,81140bd8 <__reset+0xfb120bd8>
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_ERR_NONE);
81140bfc:	0005883a 	mov	r2,zero
}
81140c00:	e037883a 	mov	sp,fp
81140c04:	dfc00117 	ldw	ra,4(sp)
81140c08:	df000017 	ldw	fp,0(sp)
81140c0c:	dec00204 	addi	sp,sp,8
81140c10:	f800283a 	ret

81140c14 <OSTimeDlyResume>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_RESUME_EN > 0
INT8U  OSTimeDlyResume (INT8U prio)
{
81140c14:	defff504 	addi	sp,sp,-44
81140c18:	de00012e 	bgeu	sp,et,81140c20 <OSTimeDlyResume+0xc>
81140c1c:	003b68fa 	trap	3
81140c20:	dfc00a15 	stw	ra,40(sp)
81140c24:	df000915 	stw	fp,36(sp)
81140c28:	df000904 	addi	fp,sp,36
81140c2c:	2005883a 	mov	r2,r4
81140c30:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                    /* Storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81140c34:	e03ff715 	stw	zero,-36(fp)
#endif



    if (prio >= OS_LOWEST_PRIO) {
81140c38:	e0bfff03 	ldbu	r2,-4(fp)
81140c3c:	10800ab0 	cmpltui	r2,r2,42
81140c40:	1000021e 	bne	r2,zero,81140c4c <OSTimeDlyResume+0x38>
        return (OS_ERR_PRIO_INVALID);
81140c44:	00800a84 	movi	r2,42
81140c48:	00006406 	br	81140ddc <OSTimeDlyResume+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140c4c:	0005303a 	rdctl	r2,status
81140c50:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140c54:	e0fffe17 	ldw	r3,-8(fp)
81140c58:	00bfff84 	movi	r2,-2
81140c5c:	1884703a 	and	r2,r3,r2
81140c60:	1001703a 	wrctl	status,r2
  
  return context;
81140c64:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
81140c68:	e0bff715 	stw	r2,-36(fp)
    ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
81140c6c:	e0ffff03 	ldbu	r3,-4(fp)
81140c70:	00a045f4 	movhi	r2,33047
81140c74:	10b41904 	addi	r2,r2,-12188
81140c78:	18c7883a 	add	r3,r3,r3
81140c7c:	18c7883a 	add	r3,r3,r3
81140c80:	10c5883a 	add	r2,r2,r3
81140c84:	10800017 	ldw	r2,0(r2)
81140c88:	e0bff915 	stw	r2,-28(fp)
    if (ptcb == (OS_TCB *)0) {
81140c8c:	e0bff917 	ldw	r2,-28(fp)
81140c90:	1000061e 	bne	r2,zero,81140cac <OSTimeDlyResume+0x98>
81140c94:	e0bff717 	ldw	r2,-36(fp)
81140c98:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140c9c:	e0bff817 	ldw	r2,-32(fp)
81140ca0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
81140ca4:	008010c4 	movi	r2,67
81140ca8:	00004c06 	br	81140ddc <OSTimeDlyResume+0x1c8>
    }
    if (ptcb == OS_TCB_RESERVED) {
81140cac:	e0bff917 	ldw	r2,-28(fp)
81140cb0:	10800058 	cmpnei	r2,r2,1
81140cb4:	1000061e 	bne	r2,zero,81140cd0 <OSTimeDlyResume+0xbc>
81140cb8:	e0bff717 	ldw	r2,-36(fp)
81140cbc:	e0bffa15 	stw	r2,-24(fp)
81140cc0:	e0bffa17 	ldw	r2,-24(fp)
81140cc4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
81140cc8:	008010c4 	movi	r2,67
81140ccc:	00004306 	br	81140ddc <OSTimeDlyResume+0x1c8>
    }
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
81140cd0:	e0bff917 	ldw	r2,-28(fp)
81140cd4:	10800b8b 	ldhu	r2,46(r2)
81140cd8:	10bfffcc 	andi	r2,r2,65535
81140cdc:	1000061e 	bne	r2,zero,81140cf8 <OSTimeDlyResume+0xe4>
81140ce0:	e0bff717 	ldw	r2,-36(fp)
81140ce4:	e0bffb15 	stw	r2,-20(fp)
81140ce8:	e0bffb17 	ldw	r2,-20(fp)
81140cec:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
81140cf0:	00801404 	movi	r2,80
81140cf4:	00003906 	br	81140ddc <OSTimeDlyResume+0x1c8>
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
81140cf8:	e0bff917 	ldw	r2,-28(fp)
81140cfc:	10000b8d 	sth	zero,46(r2)
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
81140d00:	e0bff917 	ldw	r2,-28(fp)
81140d04:	10800c03 	ldbu	r2,48(r2)
81140d08:	10803fcc 	andi	r2,r2,255
81140d0c:	10800dcc 	andi	r2,r2,55
81140d10:	10000b26 	beq	r2,zero,81140d40 <OSTimeDlyResume+0x12c>
        ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
81140d14:	e0bff917 	ldw	r2,-28(fp)
81140d18:	10c00c03 	ldbu	r3,48(r2)
81140d1c:	00bff204 	movi	r2,-56
81140d20:	1884703a 	and	r2,r3,r2
81140d24:	1007883a 	mov	r3,r2
81140d28:	e0bff917 	ldw	r2,-28(fp)
81140d2c:	10c00c05 	stb	r3,48(r2)
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
81140d30:	e0bff917 	ldw	r2,-28(fp)
81140d34:	00c00044 	movi	r3,1
81140d38:	10c00c45 	stb	r3,49(r2)
81140d3c:	00000206 	br	81140d48 <OSTimeDlyResume+0x134>
    } else {
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
81140d40:	e0bff917 	ldw	r2,-28(fp)
81140d44:	10000c45 	stb	zero,49(r2)
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
81140d48:	e0bff917 	ldw	r2,-28(fp)
81140d4c:	10800c03 	ldbu	r2,48(r2)
81140d50:	10803fcc 	andi	r2,r2,255
81140d54:	1080020c 	andi	r2,r2,8
81140d58:	10001b1e 	bne	r2,zero,81140dc8 <OSTimeDlyResume+0x1b4>
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
81140d5c:	e0bff917 	ldw	r2,-28(fp)
81140d60:	10c00d83 	ldbu	r3,54(r2)
81140d64:	d0a09e03 	ldbu	r2,-32136(gp)
81140d68:	1884b03a 	or	r2,r3,r2
81140d6c:	d0a09e05 	stb	r2,-32136(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81140d70:	e0bff917 	ldw	r2,-28(fp)
81140d74:	10800d03 	ldbu	r2,52(r2)
81140d78:	10c03fcc 	andi	r3,r2,255
81140d7c:	e0bff917 	ldw	r2,-28(fp)
81140d80:	10800d03 	ldbu	r2,52(r2)
81140d84:	11003fcc 	andi	r4,r2,255
81140d88:	d0a09e44 	addi	r2,gp,-32135
81140d8c:	2085883a 	add	r2,r4,r2
81140d90:	11000003 	ldbu	r4,0(r2)
81140d94:	e0bff917 	ldw	r2,-28(fp)
81140d98:	10800d43 	ldbu	r2,53(r2)
81140d9c:	2084b03a 	or	r2,r4,r2
81140da0:	1009883a 	mov	r4,r2
81140da4:	d0a09e44 	addi	r2,gp,-32135
81140da8:	1885883a 	add	r2,r3,r2
81140dac:	11000005 	stb	r4,0(r2)
81140db0:	e0bff717 	ldw	r2,-36(fp)
81140db4:	e0bffc15 	stw	r2,-16(fp)
81140db8:	e0bffc17 	ldw	r2,-16(fp)
81140dbc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                            /* See if this is new highest priority  */
81140dc0:	1139c680 	call	81139c68 <OS_Sched>
81140dc4:	00000406 	br	81140dd8 <OSTimeDlyResume+0x1c4>
81140dc8:	e0bff717 	ldw	r2,-36(fp)
81140dcc:	e0bffd15 	stw	r2,-12(fp)
81140dd0:	e0bffd17 	ldw	r2,-12(fp)
81140dd4:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
    }
    return (OS_ERR_NONE);
81140dd8:	0005883a 	mov	r2,zero
}
81140ddc:	e037883a 	mov	sp,fp
81140de0:	dfc00117 	ldw	ra,4(sp)
81140de4:	df000017 	ldw	fp,0(sp)
81140de8:	dec00204 	addi	sp,sp,8
81140dec:	f800283a 	ret

81140df0 <OSTimeGet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
INT32U  OSTimeGet (void)
{
81140df0:	defffb04 	addi	sp,sp,-20
81140df4:	de00012e 	bgeu	sp,et,81140dfc <OSTimeGet+0xc>
81140df8:	003b68fa 	trap	3
81140dfc:	df000415 	stw	fp,16(sp)
81140e00:	df000404 	addi	fp,sp,16
    INT32U     ticks;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81140e04:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140e08:	0005303a 	rdctl	r2,status
81140e0c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140e10:	e0fffe17 	ldw	r3,-8(fp)
81140e14:	00bfff84 	movi	r2,-2
81140e18:	1884703a 	and	r2,r3,r2
81140e1c:	1001703a 	wrctl	status,r2
  
  return context;
81140e20:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
81140e24:	e0bffc15 	stw	r2,-16(fp)
    ticks = OSTime;
81140e28:	d0a0a417 	ldw	r2,-32112(gp)
81140e2c:	e0bffd15 	stw	r2,-12(fp)
81140e30:	e0bffc17 	ldw	r2,-16(fp)
81140e34:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140e38:	e0bfff17 	ldw	r2,-4(fp)
81140e3c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (ticks);
81140e40:	e0bffd17 	ldw	r2,-12(fp)
}
81140e44:	e037883a 	mov	sp,fp
81140e48:	df000017 	ldw	fp,0(sp)
81140e4c:	dec00104 	addi	sp,sp,4
81140e50:	f800283a 	ret

81140e54 <OSTimeSet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
void  OSTimeSet (INT32U ticks)
{
81140e54:	defffb04 	addi	sp,sp,-20
81140e58:	de00012e 	bgeu	sp,et,81140e60 <OSTimeSet+0xc>
81140e5c:	003b68fa 	trap	3
81140e60:	df000415 	stw	fp,16(sp)
81140e64:	df000404 	addi	fp,sp,16
81140e68:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81140e6c:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140e70:	0005303a 	rdctl	r2,status
81140e74:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140e78:	e0fffd17 	ldw	r3,-12(fp)
81140e7c:	00bfff84 	movi	r2,-2
81140e80:	1884703a 	and	r2,r3,r2
81140e84:	1001703a 	wrctl	status,r2
  
  return context;
81140e88:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
81140e8c:	e0bffc15 	stw	r2,-16(fp)
    OSTime = ticks;
81140e90:	e0bfff17 	ldw	r2,-4(fp)
81140e94:	d0a0a415 	stw	r2,-32112(gp)
81140e98:	e0bffc17 	ldw	r2,-16(fp)
81140e9c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140ea0:	e0bffe17 	ldw	r2,-8(fp)
81140ea4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
81140ea8:	0001883a 	nop
81140eac:	e037883a 	mov	sp,fp
81140eb0:	df000017 	ldw	fp,0(sp)
81140eb4:	dec00104 	addi	sp,sp,4
81140eb8:	f800283a 	ret

81140ebc <OSTmrCreate>:
                      INT8U            opt,
                      OS_TMR_CALLBACK  callback,
                      void            *callback_arg,
                      INT8U           *pname,
                      INT8U           *perr)
{
81140ebc:	defff804 	addi	sp,sp,-32
81140ec0:	de00012e 	bgeu	sp,et,81140ec8 <OSTmrCreate+0xc>
81140ec4:	003b68fa 	trap	3
81140ec8:	dfc00715 	stw	ra,28(sp)
81140ecc:	df000615 	stw	fp,24(sp)
81140ed0:	df000604 	addi	fp,sp,24
81140ed4:	e13ffc15 	stw	r4,-16(fp)
81140ed8:	e17ffd15 	stw	r5,-12(fp)
81140edc:	3005883a 	mov	r2,r6
81140ee0:	e1ffff15 	stw	r7,-4(fp)
81140ee4:	e0bffe05 	stb	r2,-8(fp)
    INT8U     len;
#endif


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
81140ee8:	e0800417 	ldw	r2,16(fp)
81140eec:	1000021e 	bne	r2,zero,81140ef8 <OSTmrCreate+0x3c>
        return ((OS_TMR *)0);
81140ef0:	0005883a 	mov	r2,zero
81140ef4:	00005d06 	br	8114106c <OSTmrCreate+0x1b0>
    }
    switch (opt) {
81140ef8:	e0bffe03 	ldbu	r2,-8(fp)
81140efc:	10c00060 	cmpeqi	r3,r2,1
81140f00:	1800091e 	bne	r3,zero,81140f28 <OSTmrCreate+0x6c>
81140f04:	108000a0 	cmpeqi	r2,r2,2
81140f08:	10000e26 	beq	r2,zero,81140f44 <OSTmrCreate+0x88>
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
81140f0c:	e0bffd17 	ldw	r2,-12(fp)
81140f10:	1000111e 	bne	r2,zero,81140f58 <OSTmrCreate+0x9c>
                 *perr = OS_ERR_TMR_INVALID_PERIOD;
81140f14:	e0800417 	ldw	r2,16(fp)
81140f18:	00ffe0c4 	movi	r3,-125
81140f1c:	10c00005 	stb	r3,0(r2)
                 return ((OS_TMR *)0);
81140f20:	0005883a 	mov	r2,zero
81140f24:	00005106 	br	8114106c <OSTmrCreate+0x1b0>
             }
             break;

        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
81140f28:	e0bffc17 	ldw	r2,-16(fp)
81140f2c:	10000c1e 	bne	r2,zero,81140f60 <OSTmrCreate+0xa4>
                 *perr = OS_ERR_TMR_INVALID_DLY;
81140f30:	e0800417 	ldw	r2,16(fp)
81140f34:	00ffe084 	movi	r3,-126
81140f38:	10c00005 	stb	r3,0(r2)
                 return ((OS_TMR *)0);
81140f3c:	0005883a 	mov	r2,zero
81140f40:	00004a06 	br	8114106c <OSTmrCreate+0x1b0>
             }
             break;

        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
81140f44:	e0800417 	ldw	r2,16(fp)
81140f48:	00ffe104 	movi	r3,-124
81140f4c:	10c00005 	stb	r3,0(r2)
             return ((OS_TMR *)0);
81140f50:	0005883a 	mov	r2,zero
81140f54:	00004506 	br	8114106c <OSTmrCreate+0x1b0>
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
                 *perr = OS_ERR_TMR_INVALID_PERIOD;
                 return ((OS_TMR *)0);
             }
             break;
81140f58:	0001883a 	nop
81140f5c:	00000106 	br	81140f64 <OSTmrCreate+0xa8>
        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
                 *perr = OS_ERR_TMR_INVALID_DLY;
                 return ((OS_TMR *)0);
             }
             break;
81140f60:	0001883a 	nop
        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
             return ((OS_TMR *)0);
    }
#endif
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
81140f64:	d0a0a103 	ldbu	r2,-32124(gp)
81140f68:	10803fcc 	andi	r2,r2,255
81140f6c:	10000526 	beq	r2,zero,81140f84 <OSTmrCreate+0xc8>
        *perr  = OS_ERR_TMR_ISR;
81140f70:	e0800417 	ldw	r2,16(fp)
81140f74:	00ffe2c4 	movi	r3,-117
81140f78:	10c00005 	stb	r3,0(r2)
        return ((OS_TMR *)0);
81140f7c:	0005883a 	mov	r2,zero
81140f80:	00003a06 	br	8114106c <OSTmrCreate+0x1b0>
    }
    OSTmr_Lock();
81140f84:	1141e740 	call	81141e74 <OSTmr_Lock>
    ptmr = OSTmr_Alloc();                                   /* Obtain a timer from the free pool                      */
81140f88:	11419140 	call	81141914 <OSTmr_Alloc>
81140f8c:	e0bffa15 	stw	r2,-24(fp)
    if (ptmr == (OS_TMR *)0) {
81140f90:	e0bffa17 	ldw	r2,-24(fp)
81140f94:	1000061e 	bne	r2,zero,81140fb0 <OSTmrCreate+0xf4>
        OSTmr_Unlock();
81140f98:	1141eb80 	call	81141eb8 <OSTmr_Unlock>
        *perr = OS_ERR_TMR_NON_AVAIL;
81140f9c:	e0800417 	ldw	r2,16(fp)
81140fa0:	00ffe184 	movi	r3,-122
81140fa4:	10c00005 	stb	r3,0(r2)
        return ((OS_TMR *)0);
81140fa8:	0005883a 	mov	r2,zero
81140fac:	00002f06 	br	8114106c <OSTmrCreate+0x1b0>
    }
    ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet                 */
81140fb0:	e0bffa17 	ldw	r2,-24(fp)
81140fb4:	00c00044 	movi	r3,1
81140fb8:	10c00c45 	stb	r3,49(r2)
    ptmr->OSTmrDly         = dly;
81140fbc:	e0bffa17 	ldw	r2,-24(fp)
81140fc0:	e0fffc17 	ldw	r3,-16(fp)
81140fc4:	10c00615 	stw	r3,24(r2)
    ptmr->OSTmrPeriod      = period;
81140fc8:	e0bffa17 	ldw	r2,-24(fp)
81140fcc:	e0fffd17 	ldw	r3,-12(fp)
81140fd0:	10c00715 	stw	r3,28(r2)
    ptmr->OSTmrOpt         = opt;
81140fd4:	e0bffa17 	ldw	r2,-24(fp)
81140fd8:	e0fffe03 	ldbu	r3,-8(fp)
81140fdc:	10c00c05 	stb	r3,48(r2)
    ptmr->OSTmrCallback    = callback;
81140fe0:	e0bffa17 	ldw	r2,-24(fp)
81140fe4:	e0ffff17 	ldw	r3,-4(fp)
81140fe8:	10c00115 	stw	r3,4(r2)
    ptmr->OSTmrCallbackArg = callback_arg;
81140fec:	e0bffa17 	ldw	r2,-24(fp)
81140ff0:	e0c00217 	ldw	r3,8(fp)
81140ff4:	10c00215 	stw	r3,8(r2)
#if OS_TMR_CFG_NAME_SIZE > 0
    if (pname !=(INT8U *)0) {
81140ff8:	e0800317 	ldw	r2,12(fp)
81140ffc:	10001726 	beq	r2,zero,8114105c <OSTmrCreate+0x1a0>
        len = OS_StrLen(pname);                             /* Copy timer name                                        */
81141000:	e1000317 	ldw	r4,12(fp)
81141004:	1139e380 	call	81139e38 <OS_StrLen>
81141008:	e0bffb05 	stb	r2,-20(fp)
        if (len < OS_TMR_CFG_NAME_SIZE) {
8114100c:	e0bffb03 	ldbu	r2,-20(fp)
81141010:	10800428 	cmpgeui	r2,r2,16
81141014:	1000061e 	bne	r2,zero,81141030 <OSTmrCreate+0x174>
            (void)OS_StrCopy(ptmr->OSTmrName, pname);
81141018:	e0bffa17 	ldw	r2,-24(fp)
8114101c:	10800804 	addi	r2,r2,32
81141020:	e1400317 	ldw	r5,12(fp)
81141024:	1009883a 	mov	r4,r2
81141028:	1139dbc0 	call	81139dbc <OS_StrCopy>
8114102c:	00000b06 	br	8114105c <OSTmrCreate+0x1a0>
        } else {
#if OS_TMR_CFG_NAME_SIZE > 1
            ptmr->OSTmrName[0] = '#';                       /* Invalid size specified                                 */
81141030:	e0bffa17 	ldw	r2,-24(fp)
81141034:	00c008c4 	movi	r3,35
81141038:	10c00805 	stb	r3,32(r2)
            ptmr->OSTmrName[1] = OS_ASCII_NUL;
8114103c:	e0bffa17 	ldw	r2,-24(fp)
81141040:	10000845 	stb	zero,33(r2)
#endif
            *perr              = OS_ERR_TMR_NAME_TOO_LONG;
81141044:	e0800417 	ldw	r2,16(fp)
81141048:	00ffe304 	movi	r3,-116
8114104c:	10c00005 	stb	r3,0(r2)
            OSTmr_Unlock();
81141050:	1141eb80 	call	81141eb8 <OSTmr_Unlock>
            return (ptmr);
81141054:	e0bffa17 	ldw	r2,-24(fp)
81141058:	00000406 	br	8114106c <OSTmrCreate+0x1b0>
        }
    }
#endif
    OSTmr_Unlock();
8114105c:	1141eb80 	call	81141eb8 <OSTmr_Unlock>
    *perr = OS_ERR_NONE;
81141060:	e0800417 	ldw	r2,16(fp)
81141064:	10000005 	stb	zero,0(r2)
    return (ptmr);
81141068:	e0bffa17 	ldw	r2,-24(fp)
}
8114106c:	e037883a 	mov	sp,fp
81141070:	dfc00117 	ldw	ra,4(sp)
81141074:	df000017 	ldw	fp,0(sp)
81141078:	dec00204 	addi	sp,sp,8
8114107c:	f800283a 	ret

81141080 <OSTmrDel>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrDel (OS_TMR  *ptmr,
                   INT8U   *perr)
{
81141080:	defffc04 	addi	sp,sp,-16
81141084:	de00012e 	bgeu	sp,et,8114108c <OSTmrDel+0xc>
81141088:	003b68fa 	trap	3
8114108c:	dfc00315 	stw	ra,12(sp)
81141090:	df000215 	stw	fp,8(sp)
81141094:	df000204 	addi	fp,sp,8
81141098:	e13ffe15 	stw	r4,-8(fp)
8114109c:	e17fff15 	stw	r5,-4(fp)
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
811410a0:	e0bfff17 	ldw	r2,-4(fp)
811410a4:	1000021e 	bne	r2,zero,811410b0 <OSTmrDel+0x30>
        return (OS_FALSE);
811410a8:	0005883a 	mov	r2,zero
811410ac:	00003f06 	br	811411ac <OSTmrDel+0x12c>
    }
    if (ptmr == (OS_TMR *)0) {
811410b0:	e0bffe17 	ldw	r2,-8(fp)
811410b4:	1000051e 	bne	r2,zero,811410cc <OSTmrDel+0x4c>
        *perr = OS_ERR_TMR_INVALID;
811410b8:	e0bfff17 	ldw	r2,-4(fp)
811410bc:	00ffe284 	movi	r3,-118
811410c0:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811410c4:	0005883a 	mov	r2,zero
811410c8:	00003806 	br	811411ac <OSTmrDel+0x12c>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
811410cc:	e0bffe17 	ldw	r2,-8(fp)
811410d0:	10800003 	ldbu	r2,0(r2)
811410d4:	10803fcc 	andi	r2,r2,255
811410d8:	10801920 	cmpeqi	r2,r2,100
811410dc:	1000051e 	bne	r2,zero,811410f4 <OSTmrDel+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
811410e0:	e0bfff17 	ldw	r2,-4(fp)
811410e4:	00ffe244 	movi	r3,-119
811410e8:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811410ec:	0005883a 	mov	r2,zero
811410f0:	00002e06 	br	811411ac <OSTmrDel+0x12c>
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
811410f4:	d0a0a103 	ldbu	r2,-32124(gp)
811410f8:	10803fcc 	andi	r2,r2,255
811410fc:	10000526 	beq	r2,zero,81141114 <OSTmrDel+0x94>
        *perr  = OS_ERR_TMR_ISR;
81141100:	e0bfff17 	ldw	r2,-4(fp)
81141104:	00ffe2c4 	movi	r3,-117
81141108:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8114110c:	0005883a 	mov	r2,zero
81141110:	00002606 	br	811411ac <OSTmrDel+0x12c>
    }
    OSTmr_Lock();
81141114:	1141e740 	call	81141e74 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
81141118:	e0bffe17 	ldw	r2,-8(fp)
8114111c:	10800c43 	ldbu	r2,49(r2)
81141120:	10803fcc 	andi	r2,r2,255
81141124:	10c000c8 	cmpgei	r3,r2,3
81141128:	1800031e 	bne	r3,zero,81141138 <OSTmrDel+0xb8>
8114112c:	00800d16 	blt	zero,r2,81141164 <OSTmrDel+0xe4>
81141130:	10001326 	beq	r2,zero,81141180 <OSTmrDel+0x100>
81141134:	00001806 	br	81141198 <OSTmrDel+0x118>
81141138:	108000e0 	cmpeqi	r2,r2,3
8114113c:	10001626 	beq	r2,zero,81141198 <OSTmrDel+0x118>
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                            /* Remove from current wheel spoke                        */
81141140:	e13ffe17 	ldw	r4,-8(fp)
81141144:	1141d780 	call	81141d78 <OSTmr_Unlink>
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
81141148:	e13ffe17 	ldw	r4,-8(fp)
8114114c:	11419880 	call	81141988 <OSTmr_Free>
             OSTmr_Unlock();
81141150:	1141eb80 	call	81141eb8 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81141154:	e0bfff17 	ldw	r2,-4(fp)
81141158:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
8114115c:	00800044 	movi	r2,1
81141160:	00001206 	br	811411ac <OSTmrDel+0x12c>

        case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...                           */
        case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time              */
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
81141164:	e13ffe17 	ldw	r4,-8(fp)
81141168:	11419880 	call	81141988 <OSTmr_Free>
             OSTmr_Unlock();
8114116c:	1141eb80 	call	81141eb8 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81141170:	e0bfff17 	ldw	r2,-4(fp)
81141174:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
81141178:	00800044 	movi	r2,1
8114117c:	00000b06 	br	811411ac <OSTmrDel+0x12c>

        case OS_TMR_STATE_UNUSED:                           /* Already deleted                                        */
             OSTmr_Unlock();
81141180:	1141eb80 	call	81141eb8 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
81141184:	e0bfff17 	ldw	r2,-4(fp)
81141188:	00ffe1c4 	movi	r3,-121
8114118c:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
81141190:	0005883a 	mov	r2,zero
81141194:	00000506 	br	811411ac <OSTmrDel+0x12c>

        default:
             OSTmr_Unlock();
81141198:	1141eb80 	call	81141eb8 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8114119c:	e0bfff17 	ldw	r2,-4(fp)
811411a0:	00ffe344 	movi	r3,-115
811411a4:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
811411a8:	0005883a 	mov	r2,zero
    }
}
811411ac:	e037883a 	mov	sp,fp
811411b0:	dfc00117 	ldw	ra,4(sp)
811411b4:	df000017 	ldw	fp,0(sp)
811411b8:	dec00204 	addi	sp,sp,8
811411bc:	f800283a 	ret

811411c0 <OSTmrNameGet>:

#if OS_TMR_EN > 0 && OS_TMR_CFG_NAME_SIZE > 0
INT8U  OSTmrNameGet (OS_TMR  *ptmr,
                     INT8U   *pdest,
                     INT8U   *perr)
{
811411c0:	defffa04 	addi	sp,sp,-24
811411c4:	de00012e 	bgeu	sp,et,811411cc <OSTmrNameGet+0xc>
811411c8:	003b68fa 	trap	3
811411cc:	dfc00515 	stw	ra,20(sp)
811411d0:	df000415 	stw	fp,16(sp)
811411d4:	df000404 	addi	fp,sp,16
811411d8:	e13ffd15 	stw	r4,-12(fp)
811411dc:	e17ffe15 	stw	r5,-8(fp)
811411e0:	e1bfff15 	stw	r6,-4(fp)
    INT8U  len;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
811411e4:	e0bfff17 	ldw	r2,-4(fp)
811411e8:	1000021e 	bne	r2,zero,811411f4 <OSTmrNameGet+0x34>
        return (0);
811411ec:	0005883a 	mov	r2,zero
811411f0:	00003e06 	br	811412ec <OSTmrNameGet+0x12c>
    }
    if (pdest == (INT8U *)0) {
811411f4:	e0bffe17 	ldw	r2,-8(fp)
811411f8:	1000051e 	bne	r2,zero,81141210 <OSTmrNameGet+0x50>
        *perr = OS_ERR_TMR_INVALID_DEST;
811411fc:	e0bfff17 	ldw	r2,-4(fp)
81141200:	00ffe204 	movi	r3,-120
81141204:	10c00005 	stb	r3,0(r2)
        return (0);
81141208:	0005883a 	mov	r2,zero
8114120c:	00003706 	br	811412ec <OSTmrNameGet+0x12c>
    }
    if (ptmr == (OS_TMR *)0) {
81141210:	e0bffd17 	ldw	r2,-12(fp)
81141214:	1000051e 	bne	r2,zero,8114122c <OSTmrNameGet+0x6c>
        *perr = OS_ERR_TMR_INVALID;
81141218:	e0bfff17 	ldw	r2,-4(fp)
8114121c:	00ffe284 	movi	r3,-118
81141220:	10c00005 	stb	r3,0(r2)
        return (0);
81141224:	0005883a 	mov	r2,zero
81141228:	00003006 	br	811412ec <OSTmrNameGet+0x12c>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
8114122c:	e0bffd17 	ldw	r2,-12(fp)
81141230:	10800003 	ldbu	r2,0(r2)
81141234:	10803fcc 	andi	r2,r2,255
81141238:	10801920 	cmpeqi	r2,r2,100
8114123c:	1000051e 	bne	r2,zero,81141254 <OSTmrNameGet+0x94>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81141240:	e0bfff17 	ldw	r2,-4(fp)
81141244:	00ffe244 	movi	r3,-119
81141248:	10c00005 	stb	r3,0(r2)
        return (0);
8114124c:	0005883a 	mov	r2,zero
81141250:	00002606 	br	811412ec <OSTmrNameGet+0x12c>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
81141254:	d0a0a103 	ldbu	r2,-32124(gp)
81141258:	10803fcc 	andi	r2,r2,255
8114125c:	10000526 	beq	r2,zero,81141274 <OSTmrNameGet+0xb4>
        *perr = OS_ERR_NAME_GET_ISR;
81141260:	e0bfff17 	ldw	r2,-4(fp)
81141264:	00c00444 	movi	r3,17
81141268:	10c00005 	stb	r3,0(r2)
        return (0);
8114126c:	0005883a 	mov	r2,zero
81141270:	00001e06 	br	811412ec <OSTmrNameGet+0x12c>
    }
    OSTmr_Lock();
81141274:	1141e740 	call	81141e74 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
81141278:	e0bffd17 	ldw	r2,-12(fp)
8114127c:	10800c43 	ldbu	r2,49(r2)
81141280:	10803fcc 	andi	r2,r2,255
81141284:	10000e26 	beq	r2,zero,811412c0 <OSTmrNameGet+0x100>
81141288:	10001316 	blt	r2,zero,811412d8 <OSTmrNameGet+0x118>
8114128c:	10800108 	cmpgei	r2,r2,4
81141290:	1000111e 	bne	r2,zero,811412d8 <OSTmrNameGet+0x118>
        case OS_TMR_STATE_RUNNING:
        case OS_TMR_STATE_STOPPED:
        case OS_TMR_STATE_COMPLETED:
             len   = OS_StrCopy(pdest, ptmr->OSTmrName);
81141294:	e0bffd17 	ldw	r2,-12(fp)
81141298:	10800804 	addi	r2,r2,32
8114129c:	100b883a 	mov	r5,r2
811412a0:	e13ffe17 	ldw	r4,-8(fp)
811412a4:	1139dbc0 	call	81139dbc <OS_StrCopy>
811412a8:	e0bffc05 	stb	r2,-16(fp)
             OSTmr_Unlock();
811412ac:	1141eb80 	call	81141eb8 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
811412b0:	e0bfff17 	ldw	r2,-4(fp)
811412b4:	10000005 	stb	zero,0(r2)
             return (len);
811412b8:	e0bffc03 	ldbu	r2,-16(fp)
811412bc:	00000b06 	br	811412ec <OSTmrNameGet+0x12c>

        case OS_TMR_STATE_UNUSED:                      /* Timer is not allocated                                      */
             OSTmr_Unlock();
811412c0:	1141eb80 	call	81141eb8 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
811412c4:	e0bfff17 	ldw	r2,-4(fp)
811412c8:	00ffe1c4 	movi	r3,-121
811412cc:	10c00005 	stb	r3,0(r2)
             return (0);
811412d0:	0005883a 	mov	r2,zero
811412d4:	00000506 	br	811412ec <OSTmrNameGet+0x12c>

        default:
             OSTmr_Unlock();
811412d8:	1141eb80 	call	81141eb8 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
811412dc:	e0bfff17 	ldw	r2,-4(fp)
811412e0:	00ffe344 	movi	r3,-115
811412e4:	10c00005 	stb	r3,0(r2)
             return (0);
811412e8:	0005883a 	mov	r2,zero
    }
}
811412ec:	e037883a 	mov	sp,fp
811412f0:	dfc00117 	ldw	ra,4(sp)
811412f4:	df000017 	ldw	fp,0(sp)
811412f8:	dec00204 	addi	sp,sp,8
811412fc:	f800283a 	ret

81141300 <OSTmrRemainGet>:
*/

#if OS_TMR_EN > 0
INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
                        INT8U   *perr)
{
81141300:	defffb04 	addi	sp,sp,-20
81141304:	de00012e 	bgeu	sp,et,8114130c <OSTmrRemainGet+0xc>
81141308:	003b68fa 	trap	3
8114130c:	dfc00415 	stw	ra,16(sp)
81141310:	df000315 	stw	fp,12(sp)
81141314:	df000304 	addi	fp,sp,12
81141318:	e13ffe15 	stw	r4,-8(fp)
8114131c:	e17fff15 	stw	r5,-4(fp)
    INT32U  remain;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
81141320:	e0bfff17 	ldw	r2,-4(fp)
81141324:	1000021e 	bne	r2,zero,81141330 <OSTmrRemainGet+0x30>
        return (0);
81141328:	0005883a 	mov	r2,zero
8114132c:	00005d06 	br	811414a4 <OSTmrRemainGet+0x1a4>
    }
    if (ptmr == (OS_TMR *)0) {
81141330:	e0bffe17 	ldw	r2,-8(fp)
81141334:	1000051e 	bne	r2,zero,8114134c <OSTmrRemainGet+0x4c>
        *perr = OS_ERR_TMR_INVALID;
81141338:	e0bfff17 	ldw	r2,-4(fp)
8114133c:	00ffe284 	movi	r3,-118
81141340:	10c00005 	stb	r3,0(r2)
        return (0);
81141344:	0005883a 	mov	r2,zero
81141348:	00005606 	br	811414a4 <OSTmrRemainGet+0x1a4>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
8114134c:	e0bffe17 	ldw	r2,-8(fp)
81141350:	10800003 	ldbu	r2,0(r2)
81141354:	10803fcc 	andi	r2,r2,255
81141358:	10801920 	cmpeqi	r2,r2,100
8114135c:	1000051e 	bne	r2,zero,81141374 <OSTmrRemainGet+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81141360:	e0bfff17 	ldw	r2,-4(fp)
81141364:	00ffe244 	movi	r3,-119
81141368:	10c00005 	stb	r3,0(r2)
        return (0);
8114136c:	0005883a 	mov	r2,zero
81141370:	00004c06 	br	811414a4 <OSTmrRemainGet+0x1a4>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
81141374:	d0a0a103 	ldbu	r2,-32124(gp)
81141378:	10803fcc 	andi	r2,r2,255
8114137c:	10000526 	beq	r2,zero,81141394 <OSTmrRemainGet+0x94>
        *perr = OS_ERR_TMR_ISR;
81141380:	e0bfff17 	ldw	r2,-4(fp)
81141384:	00ffe2c4 	movi	r3,-117
81141388:	10c00005 	stb	r3,0(r2)
        return (0);
8114138c:	0005883a 	mov	r2,zero
81141390:	00004406 	br	811414a4 <OSTmrRemainGet+0x1a4>
    }
    OSTmr_Lock();
81141394:	1141e740 	call	81141e74 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
81141398:	e0bffe17 	ldw	r2,-8(fp)
8114139c:	10800c43 	ldbu	r2,49(r2)
811413a0:	10803fcc 	andi	r2,r2,255
811413a4:	10c00060 	cmpeqi	r3,r2,1
811413a8:	1800121e 	bne	r3,zero,811413f4 <OSTmrRemainGet+0xf4>
811413ac:	10c00088 	cmpgei	r3,r2,2
811413b0:	1800021e 	bne	r3,zero,811413bc <OSTmrRemainGet+0xbc>
811413b4:	10003026 	beq	r2,zero,81141478 <OSTmrRemainGet+0x178>
811413b8:	00003506 	br	81141490 <OSTmrRemainGet+0x190>
811413bc:	10c000a0 	cmpeqi	r3,r2,2
811413c0:	1800281e 	bne	r3,zero,81141464 <OSTmrRemainGet+0x164>
811413c4:	108000e0 	cmpeqi	r2,r2,3
811413c8:	10003126 	beq	r2,zero,81141490 <OSTmrRemainGet+0x190>
        case OS_TMR_STATE_RUNNING:
             remain = ptmr->OSTmrMatch - OSTmrTime;    /* Determine how much time is left to timeout                  */
811413cc:	e0bffe17 	ldw	r2,-8(fp)
811413d0:	10c00517 	ldw	r3,20(r2)
811413d4:	d0a0a317 	ldw	r2,-32116(gp)
811413d8:	1885c83a 	sub	r2,r3,r2
811413dc:	e0bffd15 	stw	r2,-12(fp)
             OSTmr_Unlock();
811413e0:	1141eb80 	call	81141eb8 <OSTmr_Unlock>
             *perr  = OS_ERR_NONE;
811413e4:	e0bfff17 	ldw	r2,-4(fp)
811413e8:	10000005 	stb	zero,0(r2)
             return (remain);
811413ec:	e0bffd17 	ldw	r2,-12(fp)
811413f0:	00002c06 	br	811414a4 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_STOPPED:                     /* It's assumed that the timer has not started yet             */
             switch (ptmr->OSTmrOpt) {
811413f4:	e0bffe17 	ldw	r2,-8(fp)
811413f8:	10800c03 	ldbu	r2,48(r2)
811413fc:	10803fcc 	andi	r2,r2,255
81141400:	108000a0 	cmpeqi	r2,r2,2
81141404:	10000e26 	beq	r2,zero,81141440 <OSTmrRemainGet+0x140>
                 case OS_TMR_OPT_PERIODIC:
                      if (ptmr->OSTmrDly == 0) {
81141408:	e0bffe17 	ldw	r2,-8(fp)
8114140c:	10800617 	ldw	r2,24(r2)
81141410:	1000041e 	bne	r2,zero,81141424 <OSTmrRemainGet+0x124>
                          remain = ptmr->OSTmrPeriod;
81141414:	e0bffe17 	ldw	r2,-8(fp)
81141418:	10800717 	ldw	r2,28(r2)
8114141c:	e0bffd15 	stw	r2,-12(fp)
81141420:	00000306 	br	81141430 <OSTmrRemainGet+0x130>
                      } else {
                          remain = ptmr->OSTmrDly;
81141424:	e0bffe17 	ldw	r2,-8(fp)
81141428:	10800617 	ldw	r2,24(r2)
8114142c:	e0bffd15 	stw	r2,-12(fp)
                      }
                      OSTmr_Unlock();
81141430:	1141eb80 	call	81141eb8 <OSTmr_Unlock>
                      *perr  = OS_ERR_NONE;
81141434:	e0bfff17 	ldw	r2,-4(fp)
81141438:	10000005 	stb	zero,0(r2)
                      break;
8114143c:	00000706 	br	8114145c <OSTmrRemainGet+0x15c>

                 case OS_TMR_OPT_ONE_SHOT:
                 default:
                      remain = ptmr->OSTmrDly;
81141440:	e0bffe17 	ldw	r2,-8(fp)
81141444:	10800617 	ldw	r2,24(r2)
81141448:	e0bffd15 	stw	r2,-12(fp)
                      OSTmr_Unlock();
8114144c:	1141eb80 	call	81141eb8 <OSTmr_Unlock>
                      *perr  = OS_ERR_NONE;
81141450:	e0bfff17 	ldw	r2,-4(fp)
81141454:	10000005 	stb	zero,0(r2)
                      break;
81141458:	0001883a 	nop
             }
             return (remain);
8114145c:	e0bffd17 	ldw	r2,-12(fp)
81141460:	00001006 	br	811414a4 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_COMPLETED:                   /* Only ONE-SHOT that timed out can be in this state           */
             OSTmr_Unlock();
81141464:	1141eb80 	call	81141eb8 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81141468:	e0bfff17 	ldw	r2,-4(fp)
8114146c:	10000005 	stb	zero,0(r2)
             return (0);
81141470:	0005883a 	mov	r2,zero
81141474:	00000b06 	br	811414a4 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_UNUSED:
             OSTmr_Unlock();
81141478:	1141eb80 	call	81141eb8 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8114147c:	e0bfff17 	ldw	r2,-4(fp)
81141480:	00ffe1c4 	movi	r3,-121
81141484:	10c00005 	stb	r3,0(r2)
             return (0);
81141488:	0005883a 	mov	r2,zero
8114148c:	00000506 	br	811414a4 <OSTmrRemainGet+0x1a4>

        default:
             OSTmr_Unlock();
81141490:	1141eb80 	call	81141eb8 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
81141494:	e0bfff17 	ldw	r2,-4(fp)
81141498:	00ffe344 	movi	r3,-115
8114149c:	10c00005 	stb	r3,0(r2)
             return (0);
811414a0:	0005883a 	mov	r2,zero
    }
}
811414a4:	e037883a 	mov	sp,fp
811414a8:	dfc00117 	ldw	ra,4(sp)
811414ac:	df000017 	ldw	fp,0(sp)
811414b0:	dec00204 	addi	sp,sp,8
811414b4:	f800283a 	ret

811414b8 <OSTmrStateGet>:
*/

#if OS_TMR_EN > 0
INT8U  OSTmrStateGet (OS_TMR  *ptmr,
                      INT8U   *perr)
{
811414b8:	defffb04 	addi	sp,sp,-20
811414bc:	de00012e 	bgeu	sp,et,811414c4 <OSTmrStateGet+0xc>
811414c0:	003b68fa 	trap	3
811414c4:	dfc00415 	stw	ra,16(sp)
811414c8:	df000315 	stw	fp,12(sp)
811414cc:	df000304 	addi	fp,sp,12
811414d0:	e13ffe15 	stw	r4,-8(fp)
811414d4:	e17fff15 	stw	r5,-4(fp)
    INT8U  state;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
811414d8:	e0bfff17 	ldw	r2,-4(fp)
811414dc:	1000021e 	bne	r2,zero,811414e8 <OSTmrStateGet+0x30>
        return (0);
811414e0:	0005883a 	mov	r2,zero
811414e4:	00002a06 	br	81141590 <OSTmrStateGet+0xd8>
    }
    if (ptmr == (OS_TMR *)0) {
811414e8:	e0bffe17 	ldw	r2,-8(fp)
811414ec:	1000051e 	bne	r2,zero,81141504 <OSTmrStateGet+0x4c>
        *perr = OS_ERR_TMR_INVALID;
811414f0:	e0bfff17 	ldw	r2,-4(fp)
811414f4:	00ffe284 	movi	r3,-118
811414f8:	10c00005 	stb	r3,0(r2)
        return (0);
811414fc:	0005883a 	mov	r2,zero
81141500:	00002306 	br	81141590 <OSTmrStateGet+0xd8>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
81141504:	e0bffe17 	ldw	r2,-8(fp)
81141508:	10800003 	ldbu	r2,0(r2)
8114150c:	10803fcc 	andi	r2,r2,255
81141510:	10801920 	cmpeqi	r2,r2,100
81141514:	1000051e 	bne	r2,zero,8114152c <OSTmrStateGet+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81141518:	e0bfff17 	ldw	r2,-4(fp)
8114151c:	00ffe244 	movi	r3,-119
81141520:	10c00005 	stb	r3,0(r2)
        return (0);
81141524:	0005883a 	mov	r2,zero
81141528:	00001906 	br	81141590 <OSTmrStateGet+0xd8>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
8114152c:	d0a0a103 	ldbu	r2,-32124(gp)
81141530:	10803fcc 	andi	r2,r2,255
81141534:	10000526 	beq	r2,zero,8114154c <OSTmrStateGet+0x94>
        *perr = OS_ERR_TMR_ISR;
81141538:	e0bfff17 	ldw	r2,-4(fp)
8114153c:	00ffe2c4 	movi	r3,-117
81141540:	10c00005 	stb	r3,0(r2)
        return (0);
81141544:	0005883a 	mov	r2,zero
81141548:	00001106 	br	81141590 <OSTmrStateGet+0xd8>
    }
    OSTmr_Lock();
8114154c:	1141e740 	call	81141e74 <OSTmr_Lock>
    state = ptmr->OSTmrState;
81141550:	e0bffe17 	ldw	r2,-8(fp)
81141554:	10800c43 	ldbu	r2,49(r2)
81141558:	e0bffd05 	stb	r2,-12(fp)
    switch (state) {
8114155c:	e0bffd03 	ldbu	r2,-12(fp)
81141560:	1005883a 	mov	r2,r2
81141564:	10800128 	cmpgeui	r2,r2,4
81141568:	1000031e 	bne	r2,zero,81141578 <OSTmrStateGet+0xc0>
        case OS_TMR_STATE_UNUSED:   
        case OS_TMR_STATE_STOPPED:  
        case OS_TMR_STATE_COMPLETED:
        case OS_TMR_STATE_RUNNING:  
             *perr = OS_ERR_NONE;
8114156c:	e0bfff17 	ldw	r2,-4(fp)
81141570:	10000005 	stb	zero,0(r2)
             break;
81141574:	00000406 	br	81141588 <OSTmrStateGet+0xd0>
             
        default:
             *perr = OS_ERR_TMR_INVALID_STATE;
81141578:	e0bfff17 	ldw	r2,-4(fp)
8114157c:	00ffe344 	movi	r3,-115
81141580:	10c00005 	stb	r3,0(r2)
             break;
81141584:	0001883a 	nop
    }
    OSTmr_Unlock();
81141588:	1141eb80 	call	81141eb8 <OSTmr_Unlock>
    return (state);
8114158c:	e0bffd03 	ldbu	r2,-12(fp)
}
81141590:	e037883a 	mov	sp,fp
81141594:	dfc00117 	ldw	ra,4(sp)
81141598:	df000017 	ldw	fp,0(sp)
8114159c:	dec00204 	addi	sp,sp,8
811415a0:	f800283a 	ret

811415a4 <OSTmrStart>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrStart (OS_TMR   *ptmr,
                     INT8U    *perr)
{
811415a4:	defffc04 	addi	sp,sp,-16
811415a8:	de00012e 	bgeu	sp,et,811415b0 <OSTmrStart+0xc>
811415ac:	003b68fa 	trap	3
811415b0:	dfc00315 	stw	ra,12(sp)
811415b4:	df000215 	stw	fp,8(sp)
811415b8:	df000204 	addi	fp,sp,8
811415bc:	e13ffe15 	stw	r4,-8(fp)
811415c0:	e17fff15 	stw	r5,-4(fp)
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
811415c4:	e0bfff17 	ldw	r2,-4(fp)
811415c8:	1000021e 	bne	r2,zero,811415d4 <OSTmrStart+0x30>
        return (OS_FALSE);
811415cc:	0005883a 	mov	r2,zero
811415d0:	00004106 	br	811416d8 <OSTmrStart+0x134>
    }
    if (ptmr == (OS_TMR *)0) {
811415d4:	e0bffe17 	ldw	r2,-8(fp)
811415d8:	1000051e 	bne	r2,zero,811415f0 <OSTmrStart+0x4c>
        *perr = OS_ERR_TMR_INVALID;
811415dc:	e0bfff17 	ldw	r2,-4(fp)
811415e0:	00ffe284 	movi	r3,-118
811415e4:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811415e8:	0005883a 	mov	r2,zero
811415ec:	00003a06 	br	811416d8 <OSTmrStart+0x134>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
811415f0:	e0bffe17 	ldw	r2,-8(fp)
811415f4:	10800003 	ldbu	r2,0(r2)
811415f8:	10803fcc 	andi	r2,r2,255
811415fc:	10801920 	cmpeqi	r2,r2,100
81141600:	1000051e 	bne	r2,zero,81141618 <OSTmrStart+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81141604:	e0bfff17 	ldw	r2,-4(fp)
81141608:	00ffe244 	movi	r3,-119
8114160c:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81141610:	0005883a 	mov	r2,zero
81141614:	00003006 	br	811416d8 <OSTmrStart+0x134>
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
81141618:	d0a0a103 	ldbu	r2,-32124(gp)
8114161c:	10803fcc 	andi	r2,r2,255
81141620:	10000526 	beq	r2,zero,81141638 <OSTmrStart+0x94>
        *perr  = OS_ERR_TMR_ISR;
81141624:	e0bfff17 	ldw	r2,-4(fp)
81141628:	00ffe2c4 	movi	r3,-117
8114162c:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81141630:	0005883a 	mov	r2,zero
81141634:	00002806 	br	811416d8 <OSTmrStart+0x134>
    }
    OSTmr_Lock();
81141638:	1141e740 	call	81141e74 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8114163c:	e0bffe17 	ldw	r2,-8(fp)
81141640:	10800c43 	ldbu	r2,49(r2)
81141644:	10803fcc 	andi	r2,r2,255
81141648:	10c000c8 	cmpgei	r3,r2,3
8114164c:	1800031e 	bne	r3,zero,8114165c <OSTmrStart+0xb8>
81141650:	00800e16 	blt	zero,r2,8114168c <OSTmrStart+0xe8>
81141654:	10001526 	beq	r2,zero,811416ac <OSTmrStart+0x108>
81141658:	00001a06 	br	811416c4 <OSTmrStart+0x120>
8114165c:	108000e0 	cmpeqi	r2,r2,3
81141660:	10001826 	beq	r2,zero,811416c4 <OSTmrStart+0x120>
        case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
             OSTmr_Unlink(ptmr);                            /* ... Stop the timer                                     */
81141664:	e13ffe17 	ldw	r4,-8(fp)
81141668:	1141d780 	call	81141d78 <OSTmr_Unlink>
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
8114166c:	000b883a 	mov	r5,zero
81141670:	e13ffe17 	ldw	r4,-8(fp)
81141674:	1141c280 	call	81141c28 <OSTmr_Link>
             OSTmr_Unlock();
81141678:	1141eb80 	call	81141eb8 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8114167c:	e0bfff17 	ldw	r2,-4(fp)
81141680:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
81141684:	00800044 	movi	r2,1
81141688:	00001306 	br	811416d8 <OSTmrStart+0x134>

        case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
        case OS_TMR_STATE_COMPLETED:
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
8114168c:	000b883a 	mov	r5,zero
81141690:	e13ffe17 	ldw	r4,-8(fp)
81141694:	1141c280 	call	81141c28 <OSTmr_Link>
             OSTmr_Unlock();
81141698:	1141eb80 	call	81141eb8 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8114169c:	e0bfff17 	ldw	r2,-4(fp)
811416a0:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
811416a4:	00800044 	movi	r2,1
811416a8:	00000b06 	br	811416d8 <OSTmrStart+0x134>

        case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
             OSTmr_Unlock();
811416ac:	1141eb80 	call	81141eb8 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
811416b0:	e0bfff17 	ldw	r2,-4(fp)
811416b4:	00ffe1c4 	movi	r3,-121
811416b8:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
811416bc:	0005883a 	mov	r2,zero
811416c0:	00000506 	br	811416d8 <OSTmrStart+0x134>

        default:
             OSTmr_Unlock();
811416c4:	1141eb80 	call	81141eb8 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
811416c8:	e0bfff17 	ldw	r2,-4(fp)
811416cc:	00ffe344 	movi	r3,-115
811416d0:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
811416d4:	0005883a 	mov	r2,zero
    }
}
811416d8:	e037883a 	mov	sp,fp
811416dc:	dfc00117 	ldw	ra,4(sp)
811416e0:	df000017 	ldw	fp,0(sp)
811416e4:	dec00204 	addi	sp,sp,8
811416e8:	f800283a 	ret

811416ec <OSTmrStop>:
#if OS_TMR_EN > 0
BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
                    INT8U    opt,
                    void    *callback_arg,
                    INT8U   *perr)
{
811416ec:	defff904 	addi	sp,sp,-28
811416f0:	de00012e 	bgeu	sp,et,811416f8 <OSTmrStop+0xc>
811416f4:	003b68fa 	trap	3
811416f8:	dfc00615 	stw	ra,24(sp)
811416fc:	df000515 	stw	fp,20(sp)
81141700:	df000504 	addi	fp,sp,20
81141704:	e13ffc15 	stw	r4,-16(fp)
81141708:	2805883a 	mov	r2,r5
8114170c:	e1bffe15 	stw	r6,-8(fp)
81141710:	e1ffff15 	stw	r7,-4(fp)
81141714:	e0bffd05 	stb	r2,-12(fp)
    OS_TMR_CALLBACK  pfnct;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                                     /* Validate arguments                               */
81141718:	e0bfff17 	ldw	r2,-4(fp)
8114171c:	1000021e 	bne	r2,zero,81141728 <OSTmrStop+0x3c>
        return (OS_FALSE);
81141720:	0005883a 	mov	r2,zero
81141724:	00006606 	br	811418c0 <OSTmrStop+0x1d4>
    }
    if (ptmr == (OS_TMR *)0) {
81141728:	e0bffc17 	ldw	r2,-16(fp)
8114172c:	1000051e 	bne	r2,zero,81141744 <OSTmrStop+0x58>
        *perr = OS_ERR_TMR_INVALID;
81141730:	e0bfff17 	ldw	r2,-4(fp)
81141734:	00ffe284 	movi	r3,-118
81141738:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8114173c:	0005883a 	mov	r2,zero
81141740:	00005f06 	br	811418c0 <OSTmrStop+0x1d4>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure                         */
81141744:	e0bffc17 	ldw	r2,-16(fp)
81141748:	10800003 	ldbu	r2,0(r2)
8114174c:	10803fcc 	andi	r2,r2,255
81141750:	10801920 	cmpeqi	r2,r2,100
81141754:	1000051e 	bne	r2,zero,8114176c <OSTmrStop+0x80>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81141758:	e0bfff17 	ldw	r2,-4(fp)
8114175c:	00ffe244 	movi	r3,-119
81141760:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81141764:	0005883a 	mov	r2,zero
81141768:	00005506 	br	811418c0 <OSTmrStop+0x1d4>
    }
    if (OSIntNesting > 0) {                                       /* See if trying to call from an ISR                */
8114176c:	d0a0a103 	ldbu	r2,-32124(gp)
81141770:	10803fcc 	andi	r2,r2,255
81141774:	10000526 	beq	r2,zero,8114178c <OSTmrStop+0xa0>
        *perr  = OS_ERR_TMR_ISR;
81141778:	e0bfff17 	ldw	r2,-4(fp)
8114177c:	00ffe2c4 	movi	r3,-117
81141780:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81141784:	0005883a 	mov	r2,zero
81141788:	00004d06 	br	811418c0 <OSTmrStop+0x1d4>
    }
    OSTmr_Lock();
8114178c:	1141e740 	call	81141e74 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
81141790:	e0bffc17 	ldw	r2,-16(fp)
81141794:	10800c43 	ldbu	r2,49(r2)
81141798:	10803fcc 	andi	r2,r2,255
8114179c:	10c000c8 	cmpgei	r3,r2,3
811417a0:	1800031e 	bne	r3,zero,811417b0 <OSTmrStop+0xc4>
811417a4:	00803516 	blt	zero,r2,8114187c <OSTmrStop+0x190>
811417a8:	10003a26 	beq	r2,zero,81141894 <OSTmrStop+0x1a8>
811417ac:	00003f06 	br	811418ac <OSTmrStop+0x1c0>
811417b0:	108000e0 	cmpeqi	r2,r2,3
811417b4:	10003d26 	beq	r2,zero,811418ac <OSTmrStop+0x1c0>
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke                  */
811417b8:	e13ffc17 	ldw	r4,-16(fp)
811417bc:	1141d780 	call	81141d78 <OSTmr_Unlink>
             *perr = OS_ERR_NONE;
811417c0:	e0bfff17 	ldw	r2,-4(fp)
811417c4:	10000005 	stb	zero,0(r2)
             switch (opt) {
811417c8:	e0bffd03 	ldbu	r2,-12(fp)
811417cc:	10c000e0 	cmpeqi	r3,r2,3
811417d0:	1800041e 	bne	r3,zero,811417e4 <OSTmrStop+0xf8>
811417d4:	10c00120 	cmpeqi	r3,r2,4
811417d8:	1800121e 	bne	r3,zero,81141824 <OSTmrStop+0x138>
811417dc:	10002326 	beq	r2,zero,8114186c <OSTmrStop+0x180>
811417e0:	00001e06 	br	8114185c <OSTmrStop+0x170>
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
811417e4:	e0bffc17 	ldw	r2,-16(fp)
811417e8:	10800117 	ldw	r2,4(r2)
811417ec:	e0bffb15 	stw	r2,-20(fp)
                      if (pfnct != (OS_TMR_CALLBACK)0) {
811417f0:	e0bffb17 	ldw	r2,-20(fp)
811417f4:	10000726 	beq	r2,zero,81141814 <OSTmrStop+0x128>
                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
811417f8:	e0bffc17 	ldw	r2,-16(fp)
811417fc:	10c00217 	ldw	r3,8(r2)
81141800:	e0bffb17 	ldw	r2,-20(fp)
81141804:	180b883a 	mov	r5,r3
81141808:	e13ffc17 	ldw	r4,-16(fp)
8114180c:	103ee83a 	callr	r2
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;
81141810:	00001706 	br	81141870 <OSTmrStop+0x184>
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
                      if (pfnct != (OS_TMR_CALLBACK)0) {
                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
81141814:	e0bfff17 	ldw	r2,-4(fp)
81141818:	00ffe3c4 	movi	r3,-113
8114181c:	10c00005 	stb	r3,0(r2)
                      }
                      break;
81141820:	00001306 	br	81141870 <OSTmrStop+0x184>

                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
81141824:	e0bffc17 	ldw	r2,-16(fp)
81141828:	10800117 	ldw	r2,4(r2)
8114182c:	e0bffb15 	stw	r2,-20(fp)
                      if (pfnct != (OS_TMR_CALLBACK)0) {
81141830:	e0bffb17 	ldw	r2,-20(fp)
81141834:	10000526 	beq	r2,zero,8114184c <OSTmrStop+0x160>
                          (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
81141838:	e0bffb17 	ldw	r2,-20(fp)
8114183c:	e17ffe17 	ldw	r5,-8(fp)
81141840:	e13ffc17 	ldw	r4,-16(fp)
81141844:	103ee83a 	callr	r2
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;
81141848:	00000906 	br	81141870 <OSTmrStop+0x184>
                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
                      if (pfnct != (OS_TMR_CALLBACK)0) {
                          (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
8114184c:	e0bfff17 	ldw	r2,-4(fp)
81141850:	00ffe3c4 	movi	r3,-113
81141854:	10c00005 	stb	r3,0(r2)
                      }
                      break;
81141858:	00000506 	br	81141870 <OSTmrStop+0x184>

                 case OS_TMR_OPT_NONE:
                      break;

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
8114185c:	e0bfff17 	ldw	r2,-4(fp)
81141860:	00ffe104 	movi	r3,-124
81141864:	10c00005 	stb	r3,0(r2)
                     break;
81141868:	00000106 	br	81141870 <OSTmrStop+0x184>
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;

                 case OS_TMR_OPT_NONE:
                      break;
8114186c:	0001883a 	nop

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
                     break;
             }
             OSTmr_Unlock();
81141870:	1141eb80 	call	81141eb8 <OSTmr_Unlock>
             return (OS_TRUE);
81141874:	00800044 	movi	r2,1
81141878:	00001106 	br	811418c0 <OSTmrStop+0x1d4>

        case OS_TMR_STATE_COMPLETED:                              /* Timer has already completed the ONE-SHOT or ...  */
        case OS_TMR_STATE_STOPPED:                                /* ... timer has not started yet.                   */
             OSTmr_Unlock();
8114187c:	1141eb80 	call	81141eb8 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_STOPPED;
81141880:	e0bfff17 	ldw	r2,-4(fp)
81141884:	00ffe384 	movi	r3,-114
81141888:	10c00005 	stb	r3,0(r2)
             return (OS_TRUE);
8114188c:	00800044 	movi	r2,1
81141890:	00000b06 	br	811418c0 <OSTmrStop+0x1d4>

        case OS_TMR_STATE_UNUSED:                                 /* Timer was not created                            */
             OSTmr_Unlock();
81141894:	1141eb80 	call	81141eb8 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
81141898:	e0bfff17 	ldw	r2,-4(fp)
8114189c:	00ffe1c4 	movi	r3,-121
811418a0:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
811418a4:	0005883a 	mov	r2,zero
811418a8:	00000506 	br	811418c0 <OSTmrStop+0x1d4>

        default:
             OSTmr_Unlock();
811418ac:	1141eb80 	call	81141eb8 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
811418b0:	e0bfff17 	ldw	r2,-4(fp)
811418b4:	00ffe344 	movi	r3,-115
811418b8:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
811418bc:	0005883a 	mov	r2,zero
    }
}
811418c0:	e037883a 	mov	sp,fp
811418c4:	dfc00117 	ldw	ra,4(sp)
811418c8:	df000017 	ldw	fp,0(sp)
811418cc:	dec00204 	addi	sp,sp,8
811418d0:	f800283a 	ret

811418d4 <OSTmrSignal>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
INT8U  OSTmrSignal (void)
{
811418d4:	defffd04 	addi	sp,sp,-12
811418d8:	de00012e 	bgeu	sp,et,811418e0 <OSTmrSignal+0xc>
811418dc:	003b68fa 	trap	3
811418e0:	dfc00215 	stw	ra,8(sp)
811418e4:	df000115 	stw	fp,4(sp)
811418e8:	df000104 	addi	fp,sp,4
    INT8U  err;


    err = OSSemPost(OSTmrSemSignal);
811418ec:	d0a09017 	ldw	r2,-32192(gp)
811418f0:	1009883a 	mov	r4,r2
811418f4:	113eea00 	call	8113eea0 <OSSemPost>
811418f8:	e0bfff05 	stb	r2,-4(fp)
    return (err);
811418fc:	e0bfff03 	ldbu	r2,-4(fp)
}
81141900:	e037883a 	mov	sp,fp
81141904:	dfc00117 	ldw	ra,4(sp)
81141908:	df000017 	ldw	fp,0(sp)
8114190c:	dec00204 	addi	sp,sp,8
81141910:	f800283a 	ret

81141914 <OSTmr_Alloc>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  OS_TMR  *OSTmr_Alloc (void)
{
81141914:	defffe04 	addi	sp,sp,-8
81141918:	de00012e 	bgeu	sp,et,81141920 <OSTmr_Alloc+0xc>
8114191c:	003b68fa 	trap	3
81141920:	df000115 	stw	fp,4(sp)
81141924:	df000104 	addi	fp,sp,4
    OS_TMR *ptmr;


    if (OSTmrFreeList == (OS_TMR *)0) {
81141928:	d0a08e17 	ldw	r2,-32200(gp)
8114192c:	1000021e 	bne	r2,zero,81141938 <OSTmr_Alloc+0x24>
        return ((OS_TMR *)0);
81141930:	0005883a 	mov	r2,zero
81141934:	00001006 	br	81141978 <OSTmr_Alloc+0x64>
    }
    ptmr            = (OS_TMR *)OSTmrFreeList;
81141938:	d0a08e17 	ldw	r2,-32200(gp)
8114193c:	e0bfff15 	stw	r2,-4(fp)
    OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
81141940:	e0bfff17 	ldw	r2,-4(fp)
81141944:	10800317 	ldw	r2,12(r2)
81141948:	d0a08e15 	stw	r2,-32200(gp)
    ptmr->OSTmrNext = (OS_TCB *)0;
8114194c:	e0bfff17 	ldw	r2,-4(fp)
81141950:	10000315 	stw	zero,12(r2)
    ptmr->OSTmrPrev = (OS_TCB *)0;
81141954:	e0bfff17 	ldw	r2,-4(fp)
81141958:	10000415 	stw	zero,16(r2)
    OSTmrUsed++;
8114195c:	d0a0930b 	ldhu	r2,-32180(gp)
81141960:	10800044 	addi	r2,r2,1
81141964:	d0a0930d 	sth	r2,-32180(gp)
    OSTmrFree--;
81141968:	d0a0970b 	ldhu	r2,-32164(gp)
8114196c:	10bfffc4 	addi	r2,r2,-1
81141970:	d0a0970d 	sth	r2,-32164(gp)
    return (ptmr);
81141974:	e0bfff17 	ldw	r2,-4(fp)
}
81141978:	e037883a 	mov	sp,fp
8114197c:	df000017 	ldw	fp,0(sp)
81141980:	dec00104 	addi	sp,sp,4
81141984:	f800283a 	ret

81141988 <OSTmr_Free>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Free (OS_TMR *ptmr)
{
81141988:	defffe04 	addi	sp,sp,-8
8114198c:	de00012e 	bgeu	sp,et,81141994 <OSTmr_Free+0xc>
81141990:	003b68fa 	trap	3
81141994:	df000115 	stw	fp,4(sp)
81141998:	df000104 	addi	fp,sp,4
8114199c:	e13fff15 	stw	r4,-4(fp)
    ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
811419a0:	e0bfff17 	ldw	r2,-4(fp)
811419a4:	10000c45 	stb	zero,49(r2)
    ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
811419a8:	e0bfff17 	ldw	r2,-4(fp)
811419ac:	10000c05 	stb	zero,48(r2)
    ptmr->OSTmrPeriod      = 0;
811419b0:	e0bfff17 	ldw	r2,-4(fp)
811419b4:	10000715 	stw	zero,28(r2)
    ptmr->OSTmrMatch       = 0;
811419b8:	e0bfff17 	ldw	r2,-4(fp)
811419bc:	10000515 	stw	zero,20(r2)
    ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
811419c0:	e0bfff17 	ldw	r2,-4(fp)
811419c4:	10000115 	stw	zero,4(r2)
    ptmr->OSTmrCallbackArg = (void *)0;
811419c8:	e0bfff17 	ldw	r2,-4(fp)
811419cc:	10000215 	stw	zero,8(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr->OSTmrName[0]     = '?';                      /* Unknown name                                                */
811419d0:	e0bfff17 	ldw	r2,-4(fp)
811419d4:	00c00fc4 	movi	r3,63
811419d8:	10c00805 	stb	r3,32(r2)
    ptmr->OSTmrName[1]     = OS_ASCII_NUL;
811419dc:	e0bfff17 	ldw	r2,-4(fp)
811419e0:	10000845 	stb	zero,33(r2)
#endif

    ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
811419e4:	e0bfff17 	ldw	r2,-4(fp)
811419e8:	10000415 	stw	zero,16(r2)
    ptmr->OSTmrNext        = OSTmrFreeList;
811419ec:	d0e08e17 	ldw	r3,-32200(gp)
811419f0:	e0bfff17 	ldw	r2,-4(fp)
811419f4:	10c00315 	stw	r3,12(r2)
    OSTmrFreeList          = ptmr;
811419f8:	e0bfff17 	ldw	r2,-4(fp)
811419fc:	d0a08e15 	stw	r2,-32200(gp)

    OSTmrUsed--;                                       /* Update timer object statistics                              */
81141a00:	d0a0930b 	ldhu	r2,-32180(gp)
81141a04:	10bfffc4 	addi	r2,r2,-1
81141a08:	d0a0930d 	sth	r2,-32180(gp)
    OSTmrFree++;
81141a0c:	d0a0970b 	ldhu	r2,-32164(gp)
81141a10:	10800044 	addi	r2,r2,1
81141a14:	d0a0970d 	sth	r2,-32164(gp)
}
81141a18:	0001883a 	nop
81141a1c:	e037883a 	mov	sp,fp
81141a20:	df000017 	ldw	fp,0(sp)
81141a24:	dec00104 	addi	sp,sp,4
81141a28:	f800283a 	ret

81141a2c <OSTmr_Init>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
void  OSTmr_Init (void)
{
81141a2c:	defffa04 	addi	sp,sp,-24
81141a30:	de00012e 	bgeu	sp,et,81141a38 <OSTmr_Init+0xc>
81141a34:	003b68fa 	trap	3
81141a38:	dfc00515 	stw	ra,20(sp)
81141a3c:	df000415 	stw	fp,16(sp)
81141a40:	df000404 	addi	fp,sp,16
    INT16U   i;
    OS_TMR  *ptmr1;
    OS_TMR  *ptmr2;


    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
81141a44:	01406804 	movi	r5,416
81141a48:	012045b4 	movhi	r4,33046
81141a4c:	211e3704 	addi	r4,r4,30940
81141a50:	1139b9c0 	call	81139b9c <OS_MemClr>
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */
81141a54:	01400404 	movi	r5,16
81141a58:	012045b4 	movhi	r4,33046
81141a5c:	211c2304 	addi	r4,r4,28812
81141a60:	1139b9c0 	call	81139b9c <OS_MemClr>

    ptmr1 = &OSTmrTbl[0];
81141a64:	00a045b4 	movhi	r2,33046
81141a68:	109e3704 	addi	r2,r2,30940
81141a6c:	e0bffd15 	stw	r2,-12(fp)
    ptmr2 = &OSTmrTbl[1];
81141a70:	00a045b4 	movhi	r2,33046
81141a74:	109e4404 	addi	r2,r2,30992
81141a78:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
81141a7c:	e03ffc0d 	sth	zero,-16(fp)
81141a80:	00001606 	br	81141adc <OSTmr_Init+0xb0>
        ptmr1->OSTmrType    = OS_TMR_TYPE;
81141a84:	e0bffd17 	ldw	r2,-12(fp)
81141a88:	00c01904 	movi	r3,100
81141a8c:	10c00005 	stb	r3,0(r2)
        ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive            */
81141a90:	e0bffd17 	ldw	r2,-12(fp)
81141a94:	10000c45 	stb	zero,49(r2)
        ptmr1->OSTmrNext    = (void *)ptmr2;                            /* Link to next timer                         */
81141a98:	e0bffd17 	ldw	r2,-12(fp)
81141a9c:	e0fffe17 	ldw	r3,-8(fp)
81141aa0:	10c00315 	stw	r3,12(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
        ptmr1->OSTmrName[0] = '?';                                      /* Unknown name                               */
81141aa4:	e0bffd17 	ldw	r2,-12(fp)
81141aa8:	00c00fc4 	movi	r3,63
81141aac:	10c00805 	stb	r3,32(r2)
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
81141ab0:	e0bffd17 	ldw	r2,-12(fp)
81141ab4:	10000845 	stb	zero,33(r2)
#endif
        ptmr1++;
81141ab8:	e0bffd17 	ldw	r2,-12(fp)
81141abc:	10800d04 	addi	r2,r2,52
81141ac0:	e0bffd15 	stw	r2,-12(fp)
        ptmr2++;
81141ac4:	e0bffe17 	ldw	r2,-8(fp)
81141ac8:	10800d04 	addi	r2,r2,52
81141acc:	e0bffe15 	stw	r2,-8(fp)
    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */

    ptmr1 = &OSTmrTbl[0];
    ptmr2 = &OSTmrTbl[1];
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
81141ad0:	e0bffc0b 	ldhu	r2,-16(fp)
81141ad4:	10800044 	addi	r2,r2,1
81141ad8:	e0bffc0d 	sth	r2,-16(fp)
81141adc:	e0bffc0b 	ldhu	r2,-16(fp)
81141ae0:	108001f0 	cmpltui	r2,r2,7
81141ae4:	103fe71e 	bne	r2,zero,81141a84 <__reset+0xfb121a84>
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
#endif
        ptmr1++;
        ptmr2++;
    }
    ptmr1->OSTmrType    = OS_TMR_TYPE;
81141ae8:	e0bffd17 	ldw	r2,-12(fp)
81141aec:	00c01904 	movi	r3,100
81141af0:	10c00005 	stb	r3,0(r2)
    ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive            */
81141af4:	e0bffd17 	ldw	r2,-12(fp)
81141af8:	10000c45 	stb	zero,49(r2)
    ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                                */
81141afc:	e0bffd17 	ldw	r2,-12(fp)
81141b00:	10000315 	stw	zero,12(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr1->OSTmrName[0] = '?';                                          /* Unknown name                               */
81141b04:	e0bffd17 	ldw	r2,-12(fp)
81141b08:	00c00fc4 	movi	r3,63
81141b0c:	10c00805 	stb	r3,32(r2)
    ptmr1->OSTmrName[1] = OS_ASCII_NUL;
81141b10:	e0bffd17 	ldw	r2,-12(fp)
81141b14:	10000845 	stb	zero,33(r2)
#endif
    OSTmrTime           = 0;
81141b18:	d020a315 	stw	zero,-32116(gp)
    OSTmrUsed           = 0;
81141b1c:	d020930d 	sth	zero,-32180(gp)
    OSTmrFree           = OS_TMR_CFG_MAX;
81141b20:	00800204 	movi	r2,8
81141b24:	d0a0970d 	sth	r2,-32164(gp)
    OSTmrFreeList       = &OSTmrTbl[0];
81141b28:	00a045b4 	movhi	r2,33046
81141b2c:	109e3704 	addi	r2,r2,30940
81141b30:	d0a08e15 	stw	r2,-32200(gp)
    OSTmrSem            = OSSemCreate(1);
81141b34:	01000044 	movi	r4,1
81141b38:	113e7f00 	call	8113e7f0 <OSSemCreate>
81141b3c:	d0a0a515 	stw	r2,-32108(gp)
    OSTmrSemSignal      = OSSemCreate(0);
81141b40:	0009883a 	mov	r4,zero
81141b44:	113e7f00 	call	8113e7f0 <OSSemCreate>
81141b48:	d0a09015 	stw	r2,-32192(gp)

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSem,       (INT8U *)"uC/OS-II TmrLock",   &err);/* Assign names to semaphores                 */
81141b4c:	d0a0a517 	ldw	r2,-32108(gp)
81141b50:	e0ffff04 	addi	r3,fp,-4
81141b54:	180d883a 	mov	r6,r3
81141b58:	01604574 	movhi	r5,33045
81141b5c:	2944e204 	addi	r5,r5,5000
81141b60:	1009883a 	mov	r4,r2
81141b64:	11383f80 	call	811383f8 <OSEventNameSet>
    OSEventNameSet(OSTmrSem,       (INT8U *)"OS-TmrLock",         &err);
#endif
#endif

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"uC/OS-II TmrSignal", &err);
81141b68:	d0a09017 	ldw	r2,-32192(gp)
81141b6c:	e0ffff04 	addi	r3,fp,-4
81141b70:	180d883a 	mov	r6,r3
81141b74:	01604574 	movhi	r5,33045
81141b78:	2944e704 	addi	r5,r5,5020
81141b7c:	1009883a 	mov	r4,r2
81141b80:	11383f80 	call	811383f8 <OSEventNameSet>
#if OS_EVENT_NAME_SIZE > 10
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"OS-TmrSig",          &err);
#endif
#endif

    OSTmr_InitTask();
81141b84:	1141ba00 	call	81141ba0 <OSTmr_InitTask>
}
81141b88:	0001883a 	nop
81141b8c:	e037883a 	mov	sp,fp
81141b90:	dfc00117 	ldw	ra,4(sp)
81141b94:	df000017 	ldw	fp,0(sp)
81141b98:	dec00204 	addi	sp,sp,8
81141b9c:	f800283a 	ret

81141ba0 <OSTmr_InitTask>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_InitTask (void)
{
81141ba0:	defff804 	addi	sp,sp,-32
81141ba4:	de00012e 	bgeu	sp,et,81141bac <OSTmr_InitTask+0xc>
81141ba8:	003b68fa 	trap	3
81141bac:	dfc00715 	stw	ra,28(sp)
81141bb0:	df000615 	stw	fp,24(sp)
81141bb4:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OSTmr_Task,
81141bb8:	008000c4 	movi	r2,3
81141bbc:	d8800415 	stw	r2,16(sp)
81141bc0:	d8000315 	stw	zero,12(sp)
81141bc4:	00808004 	movi	r2,512
81141bc8:	d8800215 	stw	r2,8(sp)
81141bcc:	00a045f4 	movhi	r2,33047
81141bd0:	10a66b04 	addi	r2,r2,-26196
81141bd4:	d8800115 	stw	r2,4(sp)
81141bd8:	00bfff54 	movui	r2,65533
81141bdc:	d8800015 	stw	r2,0(sp)
81141be0:	01c00744 	movi	r7,29
81141be4:	01a045f4 	movhi	r6,33047
81141be8:	31a86a04 	addi	r6,r6,-24152
81141bec:	000b883a 	mov	r5,zero
81141bf0:	01204534 	movhi	r4,33044
81141bf4:	2107bd04 	addi	r4,r4,7924
81141bf8:	113f8840 	call	8113f884 <OSTaskCreateExt>
                       OS_TASK_TMR_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 12
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"uC/OS-II Tmr", &err);
81141bfc:	e1bfff04 	addi	r6,fp,-4
81141c00:	01604574 	movhi	r5,33045
81141c04:	2944ec04 	addi	r5,r5,5040
81141c08:	01000744 	movi	r4,29
81141c0c:	11400b40 	call	811400b4 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 6
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"OS-Tmr", &err);
#endif
#endif
}
81141c10:	0001883a 	nop
81141c14:	e037883a 	mov	sp,fp
81141c18:	dfc00117 	ldw	ra,4(sp)
81141c1c:	df000017 	ldw	fp,0(sp)
81141c20:	dec00204 	addi	sp,sp,8
81141c24:	f800283a 	ret

81141c28 <OSTmr_Link>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Link (OS_TMR *ptmr, INT8U type)
{
81141c28:	defffa04 	addi	sp,sp,-24
81141c2c:	de00012e 	bgeu	sp,et,81141c34 <OSTmr_Link+0xc>
81141c30:	003b68fa 	trap	3
81141c34:	df000515 	stw	fp,20(sp)
81141c38:	df000504 	addi	fp,sp,20
81141c3c:	e13ffe15 	stw	r4,-8(fp)
81141c40:	2805883a 	mov	r2,r5
81141c44:	e0bfff05 	stb	r2,-4(fp)
    OS_TMR       *ptmr1;
    OS_TMR_WHEEL *pspoke;
    INT16U        spoke;


    ptmr->OSTmrState = OS_TMR_STATE_RUNNING;
81141c48:	e0bffe17 	ldw	r2,-8(fp)
81141c4c:	00c000c4 	movi	r3,3
81141c50:	10c00c45 	stb	r3,49(r2)
    if (type == OS_TMR_LINK_PERIODIC) {                            /* Determine when timer will expire                */
81141c54:	e0bfff03 	ldbu	r2,-4(fp)
81141c58:	10800058 	cmpnei	r2,r2,1
81141c5c:	1000071e 	bne	r2,zero,81141c7c <OSTmr_Link+0x54>
        ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
81141c60:	e0bffe17 	ldw	r2,-8(fp)
81141c64:	10c00717 	ldw	r3,28(r2)
81141c68:	d0a0a317 	ldw	r2,-32116(gp)
81141c6c:	1887883a 	add	r3,r3,r2
81141c70:	e0bffe17 	ldw	r2,-8(fp)
81141c74:	10c00515 	stw	r3,20(r2)
81141c78:	00001006 	br	81141cbc <OSTmr_Link+0x94>
    } else {
        if (ptmr->OSTmrDly == 0) {
81141c7c:	e0bffe17 	ldw	r2,-8(fp)
81141c80:	10800617 	ldw	r2,24(r2)
81141c84:	1000071e 	bne	r2,zero,81141ca4 <OSTmr_Link+0x7c>
            ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
81141c88:	e0bffe17 	ldw	r2,-8(fp)
81141c8c:	10c00717 	ldw	r3,28(r2)
81141c90:	d0a0a317 	ldw	r2,-32116(gp)
81141c94:	1887883a 	add	r3,r3,r2
81141c98:	e0bffe17 	ldw	r2,-8(fp)
81141c9c:	10c00515 	stw	r3,20(r2)
81141ca0:	00000606 	br	81141cbc <OSTmr_Link+0x94>
        } else {
            ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
81141ca4:	e0bffe17 	ldw	r2,-8(fp)
81141ca8:	10c00617 	ldw	r3,24(r2)
81141cac:	d0a0a317 	ldw	r2,-32116(gp)
81141cb0:	1887883a 	add	r3,r3,r2
81141cb4:	e0bffe17 	ldw	r2,-8(fp)
81141cb8:	10c00515 	stw	r3,20(r2)
        }
    }
    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
81141cbc:	e0bffe17 	ldw	r2,-8(fp)
81141cc0:	10800517 	ldw	r2,20(r2)
81141cc4:	1080004c 	andi	r2,r2,1
81141cc8:	e0bffb0d 	sth	r2,-20(fp)
    pspoke = &OSTmrWheelTbl[spoke];
81141ccc:	e0bffb0b 	ldhu	r2,-20(fp)
81141cd0:	100690fa 	slli	r3,r2,3
81141cd4:	00a045b4 	movhi	r2,33046
81141cd8:	109c2304 	addi	r2,r2,28812
81141cdc:	1885883a 	add	r2,r3,r2
81141ce0:	e0bffc15 	stw	r2,-16(fp)

    if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
81141ce4:	e0bffc17 	ldw	r2,-16(fp)
81141ce8:	10800017 	ldw	r2,0(r2)
81141cec:	1000091e 	bne	r2,zero,81141d14 <OSTmr_Link+0xec>
        pspoke->OSTmrFirst   = ptmr;
81141cf0:	e0bffc17 	ldw	r2,-16(fp)
81141cf4:	e0fffe17 	ldw	r3,-8(fp)
81141cf8:	10c00015 	stw	r3,0(r2)
        ptmr->OSTmrNext      = (OS_TMR *)0;
81141cfc:	e0bffe17 	ldw	r2,-8(fp)
81141d00:	10000315 	stw	zero,12(r2)
        pspoke->OSTmrEntries = 1;
81141d04:	e0bffc17 	ldw	r2,-16(fp)
81141d08:	00c00044 	movi	r3,1
81141d0c:	10c0010d 	sth	r3,4(r2)
81141d10:	00001206 	br	81141d5c <OSTmr_Link+0x134>
    } else {
        ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke               */
81141d14:	e0bffc17 	ldw	r2,-16(fp)
81141d18:	10800017 	ldw	r2,0(r2)
81141d1c:	e0bffd15 	stw	r2,-12(fp)
        pspoke->OSTmrFirst   = ptmr;
81141d20:	e0bffc17 	ldw	r2,-16(fp)
81141d24:	e0fffe17 	ldw	r3,-8(fp)
81141d28:	10c00015 	stw	r3,0(r2)
        ptmr->OSTmrNext      = (void *)ptmr1;
81141d2c:	e0bffe17 	ldw	r2,-8(fp)
81141d30:	e0fffd17 	ldw	r3,-12(fp)
81141d34:	10c00315 	stw	r3,12(r2)
        ptmr1->OSTmrPrev     = (void *)ptmr;
81141d38:	e0bffd17 	ldw	r2,-12(fp)
81141d3c:	e0fffe17 	ldw	r3,-8(fp)
81141d40:	10c00415 	stw	r3,16(r2)
        pspoke->OSTmrEntries++;
81141d44:	e0bffc17 	ldw	r2,-16(fp)
81141d48:	1080010b 	ldhu	r2,4(r2)
81141d4c:	10800044 	addi	r2,r2,1
81141d50:	1007883a 	mov	r3,r2
81141d54:	e0bffc17 	ldw	r2,-16(fp)
81141d58:	10c0010d 	sth	r3,4(r2)
    }
    ptmr->OSTmrPrev = (void *)0;                                   /* Timer always inserted as first node in list     */
81141d5c:	e0bffe17 	ldw	r2,-8(fp)
81141d60:	10000415 	stw	zero,16(r2)
}
81141d64:	0001883a 	nop
81141d68:	e037883a 	mov	sp,fp
81141d6c:	df000017 	ldw	fp,0(sp)
81141d70:	dec00104 	addi	sp,sp,4
81141d74:	f800283a 	ret

81141d78 <OSTmr_Unlink>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Unlink (OS_TMR *ptmr)
{
81141d78:	defffa04 	addi	sp,sp,-24
81141d7c:	de00012e 	bgeu	sp,et,81141d84 <OSTmr_Unlink+0xc>
81141d80:	003b68fa 	trap	3
81141d84:	df000515 	stw	fp,20(sp)
81141d88:	df000504 	addi	fp,sp,20
81141d8c:	e13fff15 	stw	r4,-4(fp)
    OS_TMR        *ptmr2;
    OS_TMR_WHEEL  *pspoke;
    INT16U         spoke;


    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
81141d90:	e0bfff17 	ldw	r2,-4(fp)
81141d94:	10800517 	ldw	r2,20(r2)
81141d98:	1080004c 	andi	r2,r2,1
81141d9c:	e0bffb0d 	sth	r2,-20(fp)
    pspoke = &OSTmrWheelTbl[spoke];
81141da0:	e0bffb0b 	ldhu	r2,-20(fp)
81141da4:	100690fa 	slli	r3,r2,3
81141da8:	00a045b4 	movhi	r2,33046
81141dac:	109c2304 	addi	r2,r2,28812
81141db0:	1885883a 	add	r2,r3,r2
81141db4:	e0bffc15 	stw	r2,-16(fp)

    if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning of list     */
81141db8:	e0bffc17 	ldw	r2,-16(fp)
81141dbc:	10c00017 	ldw	r3,0(r2)
81141dc0:	e0bfff17 	ldw	r2,-4(fp)
81141dc4:	18800b1e 	bne	r3,r2,81141df4 <OSTmr_Unlink+0x7c>
        ptmr1              = (OS_TMR *)ptmr->OSTmrNext;
81141dc8:	e0bfff17 	ldw	r2,-4(fp)
81141dcc:	10800317 	ldw	r2,12(r2)
81141dd0:	e0bffd15 	stw	r2,-12(fp)
        pspoke->OSTmrFirst = (OS_TMR *)ptmr1;
81141dd4:	e0bffc17 	ldw	r2,-16(fp)
81141dd8:	e0fffd17 	ldw	r3,-12(fp)
81141ddc:	10c00015 	stw	r3,0(r2)
        if (ptmr1 != (OS_TMR *)0) {
81141de0:	e0bffd17 	ldw	r2,-12(fp)
81141de4:	10001126 	beq	r2,zero,81141e2c <OSTmr_Unlink+0xb4>
            ptmr1->OSTmrPrev = (void *)0;
81141de8:	e0bffd17 	ldw	r2,-12(fp)
81141dec:	10000415 	stw	zero,16(r2)
81141df0:	00000e06 	br	81141e2c <OSTmr_Unlink+0xb4>
        }
    } else {
        ptmr1            = (OS_TMR *)ptmr->OSTmrPrev;       /* Remove timer from somewhere in the list                */
81141df4:	e0bfff17 	ldw	r2,-4(fp)
81141df8:	10800417 	ldw	r2,16(r2)
81141dfc:	e0bffd15 	stw	r2,-12(fp)
        ptmr2            = (OS_TMR *)ptmr->OSTmrNext;
81141e00:	e0bfff17 	ldw	r2,-4(fp)
81141e04:	10800317 	ldw	r2,12(r2)
81141e08:	e0bffe15 	stw	r2,-8(fp)
        ptmr1->OSTmrNext = ptmr2;
81141e0c:	e0bffd17 	ldw	r2,-12(fp)
81141e10:	e0fffe17 	ldw	r3,-8(fp)
81141e14:	10c00315 	stw	r3,12(r2)
        if (ptmr2 != (OS_TMR *)0) {
81141e18:	e0bffe17 	ldw	r2,-8(fp)
81141e1c:	10000326 	beq	r2,zero,81141e2c <OSTmr_Unlink+0xb4>
            ptmr2->OSTmrPrev = (void *)ptmr1;
81141e20:	e0bffe17 	ldw	r2,-8(fp)
81141e24:	e0fffd17 	ldw	r3,-12(fp)
81141e28:	10c00415 	stw	r3,16(r2)
        }
    }
    ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
81141e2c:	e0bfff17 	ldw	r2,-4(fp)
81141e30:	00c00044 	movi	r3,1
81141e34:	10c00c45 	stb	r3,49(r2)
    ptmr->OSTmrNext  = (void *)0;
81141e38:	e0bfff17 	ldw	r2,-4(fp)
81141e3c:	10000315 	stw	zero,12(r2)
    ptmr->OSTmrPrev  = (void *)0;
81141e40:	e0bfff17 	ldw	r2,-4(fp)
81141e44:	10000415 	stw	zero,16(r2)
    pspoke->OSTmrEntries--;
81141e48:	e0bffc17 	ldw	r2,-16(fp)
81141e4c:	1080010b 	ldhu	r2,4(r2)
81141e50:	10bfffc4 	addi	r2,r2,-1
81141e54:	1007883a 	mov	r3,r2
81141e58:	e0bffc17 	ldw	r2,-16(fp)
81141e5c:	10c0010d 	sth	r3,4(r2)
}
81141e60:	0001883a 	nop
81141e64:	e037883a 	mov	sp,fp
81141e68:	df000017 	ldw	fp,0(sp)
81141e6c:	dec00104 	addi	sp,sp,4
81141e70:	f800283a 	ret

81141e74 <OSTmr_Lock>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Lock (void)
{
81141e74:	defffd04 	addi	sp,sp,-12
81141e78:	de00012e 	bgeu	sp,et,81141e80 <OSTmr_Lock+0xc>
81141e7c:	003b68fa 	trap	3
81141e80:	dfc00215 	stw	ra,8(sp)
81141e84:	df000115 	stw	fp,4(sp)
81141e88:	df000104 	addi	fp,sp,4
    INT8U  err;


    OSSemPend(OSTmrSem, 0, &err);
81141e8c:	d0a0a517 	ldw	r2,-32108(gp)
81141e90:	e1bfff04 	addi	r6,fp,-4
81141e94:	000b883a 	mov	r5,zero
81141e98:	1009883a 	mov	r4,r2
81141e9c:	113eb180 	call	8113eb18 <OSSemPend>
    (void)err;
}
81141ea0:	0001883a 	nop
81141ea4:	e037883a 	mov	sp,fp
81141ea8:	dfc00117 	ldw	ra,4(sp)
81141eac:	df000017 	ldw	fp,0(sp)
81141eb0:	dec00204 	addi	sp,sp,8
81141eb4:	f800283a 	ret

81141eb8 <OSTmr_Unlock>:



#if OS_TMR_EN > 0
static  void  OSTmr_Unlock (void)
{
81141eb8:	defffe04 	addi	sp,sp,-8
81141ebc:	de00012e 	bgeu	sp,et,81141ec4 <OSTmr_Unlock+0xc>
81141ec0:	003b68fa 	trap	3
81141ec4:	dfc00115 	stw	ra,4(sp)
81141ec8:	df000015 	stw	fp,0(sp)
81141ecc:	d839883a 	mov	fp,sp
    (void)OSSemPost(OSTmrSem);
81141ed0:	d0a0a517 	ldw	r2,-32108(gp)
81141ed4:	1009883a 	mov	r4,r2
81141ed8:	113eea00 	call	8113eea0 <OSSemPost>
}
81141edc:	0001883a 	nop
81141ee0:	e037883a 	mov	sp,fp
81141ee4:	dfc00117 	ldw	ra,4(sp)
81141ee8:	df000017 	ldw	fp,0(sp)
81141eec:	dec00204 	addi	sp,sp,8
81141ef0:	f800283a 	ret

81141ef4 <OSTmr_Task>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Task (void *p_arg)
{
81141ef4:	defff704 	addi	sp,sp,-36
81141ef8:	de00012e 	bgeu	sp,et,81141f00 <OSTmr_Task+0xc>
81141efc:	003b68fa 	trap	3
81141f00:	dfc00815 	stw	ra,32(sp)
81141f04:	df000715 	stw	fp,28(sp)
81141f08:	df000704 	addi	fp,sp,28
81141f0c:	e13fff15 	stw	r4,-4(fp)
    INT16U           spoke;


    (void)p_arg;                                                 /* Not using 'p_arg', prevent compiler warning       */
    for (;;) {
        OSSemPend(OSTmrSemSignal, 0, &err);                      /* Wait for signal indicating time to update timers  */
81141f10:	d0a09017 	ldw	r2,-32192(gp)
81141f14:	e0fffe04 	addi	r3,fp,-8
81141f18:	180d883a 	mov	r6,r3
81141f1c:	000b883a 	mov	r5,zero
81141f20:	1009883a 	mov	r4,r2
81141f24:	113eb180 	call	8113eb18 <OSSemPend>
        OSTmr_Lock();
81141f28:	1141e740 	call	81141e74 <OSTmr_Lock>
        OSTmrTime++;                                             /* Increment the current time                        */
81141f2c:	d0a0a317 	ldw	r2,-32116(gp)
81141f30:	10800044 	addi	r2,r2,1
81141f34:	d0a0a315 	stw	r2,-32116(gp)
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
81141f38:	d0a0a317 	ldw	r2,-32116(gp)
81141f3c:	1080004c 	andi	r2,r2,1
81141f40:	e0bffa0d 	sth	r2,-24(fp)
        pspoke = &OSTmrWheelTbl[spoke];
81141f44:	e0bffa0b 	ldhu	r2,-24(fp)
81141f48:	100690fa 	slli	r3,r2,3
81141f4c:	00a045b4 	movhi	r2,33046
81141f50:	109c2304 	addi	r2,r2,28812
81141f54:	1885883a 	add	r2,r3,r2
81141f58:	e0bffb15 	stw	r2,-20(fp)
        ptmr   = pspoke->OSTmrFirst;
81141f5c:	e0bffb17 	ldw	r2,-20(fp)
81141f60:	10800017 	ldw	r2,0(r2)
81141f64:	e0bff915 	stw	r2,-28(fp)
        while (ptmr != (OS_TMR *)0) {
81141f68:	00002206 	br	81141ff4 <OSTmr_Task+0x100>
            ptmr_next = (OS_TMR *)ptmr->OSTmrNext;               /* Point to next timer to update because current ... */
81141f6c:	e0bff917 	ldw	r2,-28(fp)
81141f70:	10800317 	ldw	r2,12(r2)
81141f74:	e0bffc15 	stw	r2,-16(fp)
                                                                 /* ... timer could get unlinked from the wheel.      */
            if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires                   */
81141f78:	e0bff917 	ldw	r2,-28(fp)
81141f7c:	10c00517 	ldw	r3,20(r2)
81141f80:	d0a0a317 	ldw	r2,-32116(gp)
81141f84:	1880191e 	bne	r3,r2,81141fec <OSTmr_Task+0xf8>
                pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available            */
81141f88:	e0bff917 	ldw	r2,-28(fp)
81141f8c:	10800117 	ldw	r2,4(r2)
81141f90:	e0bffd15 	stw	r2,-12(fp)
                if (pfnct != (OS_TMR_CALLBACK)0) {
81141f94:	e0bffd17 	ldw	r2,-12(fp)
81141f98:	10000626 	beq	r2,zero,81141fb4 <OSTmr_Task+0xc0>
                    (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);
81141f9c:	e0bff917 	ldw	r2,-28(fp)
81141fa0:	10c00217 	ldw	r3,8(r2)
81141fa4:	e0bffd17 	ldw	r2,-12(fp)
81141fa8:	180b883a 	mov	r5,r3
81141fac:	e13ff917 	ldw	r4,-28(fp)
81141fb0:	103ee83a 	callr	r2
                }
                OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke                   */
81141fb4:	e13ff917 	ldw	r4,-28(fp)
81141fb8:	1141d780 	call	81141d78 <OSTmr_Unlink>
                if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
81141fbc:	e0bff917 	ldw	r2,-28(fp)
81141fc0:	10800c03 	ldbu	r2,48(r2)
81141fc4:	10803fcc 	andi	r2,r2,255
81141fc8:	10800098 	cmpnei	r2,r2,2
81141fcc:	1000041e 	bne	r2,zero,81141fe0 <OSTmr_Task+0xec>
                    OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in wheel        */
81141fd0:	01400044 	movi	r5,1
81141fd4:	e13ff917 	ldw	r4,-28(fp)
81141fd8:	1141c280 	call	81141c28 <OSTmr_Link>
81141fdc:	00000306 	br	81141fec <OSTmr_Task+0xf8>
                } else {
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
81141fe0:	e0bff917 	ldw	r2,-28(fp)
81141fe4:	00c00084 	movi	r3,2
81141fe8:	10c00c45 	stb	r3,49(r2)
                }
            }
            ptmr = ptmr_next;
81141fec:	e0bffc17 	ldw	r2,-16(fp)
81141ff0:	e0bff915 	stw	r2,-28(fp)
        OSTmr_Lock();
        OSTmrTime++;                                             /* Increment the current time                        */
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
        pspoke = &OSTmrWheelTbl[spoke];
        ptmr   = pspoke->OSTmrFirst;
        while (ptmr != (OS_TMR *)0) {
81141ff4:	e0bff917 	ldw	r2,-28(fp)
81141ff8:	103fdc1e 	bne	r2,zero,81141f6c <__reset+0xfb121f6c>
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
                }
            }
            ptmr = ptmr_next;
        }
        OSTmr_Unlock();
81141ffc:	1141eb80 	call	81141eb8 <OSTmr_Unlock>
    }
81142000:	003fc306 	br	81141f10 <__reset+0xfb121f10>

81142004 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
81142004:	defffd04 	addi	sp,sp,-12
81142008:	de00012e 	bgeu	sp,et,81142010 <alt_dev_reg+0xc>
8114200c:	003b68fa 	trap	3
81142010:	dfc00215 	stw	ra,8(sp)
81142014:	df000115 	stw	fp,4(sp)
81142018:	df000104 	addi	fp,sp,4
8114201c:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
81142020:	d1600d04 	addi	r5,gp,-32716
81142024:	e13fff17 	ldw	r4,-4(fp)
81142028:	114a2a40 	call	8114a2a4 <alt_dev_llist_insert>
}
8114202c:	e037883a 	mov	sp,fp
81142030:	dfc00117 	ldw	ra,4(sp)
81142034:	df000017 	ldw	fp,0(sp)
81142038:	dec00204 	addi	sp,sp,8
8114203c:	f800283a 	ret

81142040 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
81142040:	defffd04 	addi	sp,sp,-12
81142044:	de00012e 	bgeu	sp,et,8114204c <alt_irq_init+0xc>
81142048:	003b68fa 	trap	3
8114204c:	dfc00215 	stw	ra,8(sp)
81142050:	df000115 	stw	fp,4(sp)
81142054:	df000104 	addi	fp,sp,4
81142058:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_0, nios2_gen2_0);
8114205c:	114ac6c0 	call	8114ac6c <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
81142060:	00800044 	movi	r2,1
81142064:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
81142068:	0001883a 	nop
8114206c:	e037883a 	mov	sp,fp
81142070:	dfc00117 	ldw	ra,4(sp)
81142074:	df000017 	ldw	fp,0(sp)
81142078:	dec00204 	addi	sp,sp,8
8114207c:	f800283a 	ret

81142080 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
81142080:	defffe04 	addi	sp,sp,-8
81142084:	de00012e 	bgeu	sp,et,8114208c <alt_sys_init+0xc>
81142088:	003b68fa 	trap	3
8114208c:	dfc00115 	stw	ra,4(sp)
81142090:	df000015 	stw	fp,0(sp)
81142094:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_1MS, timer_1ms);
81142098:	01c0fa04 	movi	r7,1000
8114209c:	01800304 	movi	r6,12
811420a0:	000b883a 	mov	r5,zero
811420a4:	01200034 	movhi	r4,32768
811420a8:	21022004 	addi	r4,r4,2176
811420ac:	11473d80 	call	811473d8 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_TIMER_INIT ( TIMER_1US, timer_1us);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
811420b0:	018002c4 	movi	r6,11
811420b4:	000b883a 	mov	r5,zero
811420b8:	01204574 	movhi	r4,33045
811420bc:	21088804 	addi	r4,r4,8736
811420c0:	11466c40 	call	811466c4 <altera_avalon_jtag_uart_init>
811420c4:	01204574 	movhi	r4,33045
811420c8:	21087e04 	addi	r4,r4,8696
811420cc:	11420040 	call	81142004 <alt_dev_reg>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS, sysid_qsys);
811420d0:	0001883a 	nop
    ALTERA_AVALON_UART_INIT ( RS232_UART, rs232_uart);
811420d4:	018003c4 	movi	r6,15
811420d8:	000b883a 	mov	r5,zero
811420dc:	01204574 	movhi	r4,33045
811420e0:	210ca304 	addi	r4,r4,12940
811420e4:	11475840 	call	81147584 <altera_avalon_uart_init>
811420e8:	01204574 	movhi	r4,33045
811420ec:	210c9904 	addi	r4,r4,12900
811420f0:	11420040 	call	81142004 <alt_dev_reg>
    ALTERA_MSGDMA_INIT ( DMA_DDR_M1, dma_DDR_M1);
811420f4:	00a04574 	movhi	r2,33045
811420f8:	108ccd04 	addi	r2,r2,13108
811420fc:	10c00717 	ldw	r3,28(r2)
81142100:	00a04574 	movhi	r2,33045
81142104:	108ccd04 	addi	r2,r2,13108
81142108:	10800817 	ldw	r2,32(r2)
8114210c:	100d883a 	mov	r6,r2
81142110:	180b883a 	mov	r5,r3
81142114:	01204574 	movhi	r4,33045
81142118:	210ccd04 	addi	r4,r4,13108
8114211c:	1149e0c0 	call	81149e0c <alt_msgdma_init>
    ALTERA_MSGDMA_INIT ( DMA_DDR_M2, dma_DDR_M2);
81142120:	00a04574 	movhi	r2,33045
81142124:	108ce604 	addi	r2,r2,13208
81142128:	10c00717 	ldw	r3,28(r2)
8114212c:	00a04574 	movhi	r2,33045
81142130:	108ce604 	addi	r2,r2,13208
81142134:	10800817 	ldw	r2,32(r2)
81142138:	100d883a 	mov	r6,r2
8114213c:	180b883a 	mov	r5,r3
81142140:	01204574 	movhi	r4,33045
81142144:	210ce604 	addi	r4,r4,13208
81142148:	1149e0c0 	call	81149e0c <alt_msgdma_init>
    ALTERA_UP_SD_CARD_AVALON_INTERFACE_INIT ( ALTERA_UP_SD_CARD_AVALON_INTERFACE_0, Altera_UP_SD_Card_Avalon_Interface_0);
8114214c:	01204574 	movhi	r4,33045
81142150:	210cff04 	addi	r4,r4,13308
81142154:	11420040 	call	81142004 <alt_dev_reg>
}
81142158:	0001883a 	nop
8114215c:	e037883a 	mov	sp,fp
81142160:	dfc00117 	ldw	ra,4(sp)
81142164:	df000017 	ldw	fp,0(sp)
81142168:	dec00204 	addi	sp,sp,8
8114216c:	f800283a 	ret

81142170 <Write_Sector_Data>:
///////////////////////////////////////////////////////////////////////////

        
bool Write_Sector_Data(int sector_index, int partition_offset)
// This function writes a sector at the specified address on the SD Card.
{
81142170:	defffa04 	addi	sp,sp,-24
81142174:	de00012e 	bgeu	sp,et,8114217c <Write_Sector_Data+0xc>
81142178:	003b68fa 	trap	3
8114217c:	dfc00515 	stw	ra,20(sp)
81142180:	df000415 	stw	fp,16(sp)
81142184:	df000404 	addi	fp,sp,16
81142188:	e13ffe15 	stw	r4,-8(fp)
8114218c:	e17fff15 	stw	r5,-4(fp)
    bool result = false;
81142190:	e03ffc15 	stw	zero,-16(fp)
    
    if (alt_up_sd_card_is_Present())
81142194:	1144f580 	call	81144f58 <alt_up_sd_card_is_Present>
81142198:	10001e26 	beq	r2,zero,81142214 <Write_Sector_Data+0xa4>
    {
        short int reg_state = 0xff;
8114219c:	00803fc4 	movi	r2,255
811421a0:	e0bffd0d 	sth	r2,-12(fp)

		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
         * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
811421a4:	d0a0af17 	ldw	r2,-32068(gp)
811421a8:	e13ffe17 	ldw	r4,-8(fp)
811421ac:	e0ffff17 	ldw	r3,-4(fp)
811421b0:	20c7883a 	add	r3,r4,r3
811421b4:	1806927a 	slli	r3,r3,9
811421b8:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_WRITE_BLOCK);
811421bc:	d0a0ae17 	ldw	r2,-32072(gp)
811421c0:	00c00604 	movi	r3,24
811421c4:	10c0002d 	sthio	r3,0(r2)
        do {
            reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
811421c8:	d0a0ab17 	ldw	r2,-32084(gp)
811421cc:	1080002b 	ldhuio	r2,0(r2)
811421d0:	10bfffcc 	andi	r2,r2,65535
811421d4:	e0bffd0d 	sth	r2,-12(fp)
        } while ((reg_state & 0x04)!=0);
811421d8:	e0bffd0b 	ldhu	r2,-12(fp)
811421dc:	10bfffcc 	andi	r2,r2,65535
811421e0:	1080010c 	andi	r2,r2,4
811421e4:	103ff81e 	bne	r2,zero,811421c8 <__reset+0xfb1221c8>
        // Make sure the request did not time out.
        if ((reg_state & 0x10) == 0)
811421e8:	e0bffd0b 	ldhu	r2,-12(fp)
811421ec:	10bfffcc 	andi	r2,r2,65535
811421f0:	1080040c 	andi	r2,r2,16
811421f4:	1000071e 	bne	r2,zero,81142214 <Write_Sector_Data+0xa4>
        {
            result = true;
811421f8:	00800044 	movi	r2,1
811421fc:	e0bffc15 	stw	r2,-16(fp)
            current_sector_modified = false;
81142200:	d020b415 	stw	zero,-32048(gp)
            current_sector_index = sector_index+partition_offset;
81142204:	e0fffe17 	ldw	r3,-8(fp)
81142208:	e0bfff17 	ldw	r2,-4(fp)
8114220c:	1885883a 	add	r2,r3,r2
81142210:	d0a0b515 	stw	r2,-32044(gp)
        }
    }
    return result;
81142214:	e0bffc17 	ldw	r2,-16(fp)
}
81142218:	e037883a 	mov	sp,fp
8114221c:	dfc00117 	ldw	ra,4(sp)
81142220:	df000017 	ldw	fp,0(sp)
81142224:	dec00204 	addi	sp,sp,8
81142228:	f800283a 	ret

8114222c <Save_Modified_Sector>:


bool Save_Modified_Sector()
// If the sector has been modified, then save it to the SD Card.
{
8114222c:	defffd04 	addi	sp,sp,-12
81142230:	de00012e 	bgeu	sp,et,81142238 <Save_Modified_Sector+0xc>
81142234:	003b68fa 	trap	3
81142238:	dfc00215 	stw	ra,8(sp)
8114223c:	df000115 	stw	fp,4(sp)
81142240:	df000104 	addi	fp,sp,4
    bool result = true;
81142244:	00800044 	movi	r2,1
81142248:	e0bfff15 	stw	r2,-4(fp)
    if (current_sector_modified)
8114224c:	d0a0b417 	ldw	r2,-32048(gp)
81142250:	10000526 	beq	r2,zero,81142268 <Save_Modified_Sector+0x3c>
    {
        result = Write_Sector_Data(current_sector_index, 0);
81142254:	d0a0b517 	ldw	r2,-32044(gp)
81142258:	000b883a 	mov	r5,zero
8114225c:	1009883a 	mov	r4,r2
81142260:	11421700 	call	81142170 <Write_Sector_Data>
81142264:	e0bfff15 	stw	r2,-4(fp)
    }
    return result;
81142268:	e0bfff17 	ldw	r2,-4(fp)
}
8114226c:	e037883a 	mov	sp,fp
81142270:	dfc00117 	ldw	ra,4(sp)
81142274:	df000017 	ldw	fp,0(sp)
81142278:	dec00204 	addi	sp,sp,8
8114227c:	f800283a 	ret

81142280 <Read_Sector_Data>:


bool Read_Sector_Data(int sector_index, int partition_offset)
// This function reads a sector at the specified address on the SD Card.
{
81142280:	defffa04 	addi	sp,sp,-24
81142284:	de00012e 	bgeu	sp,et,8114228c <Read_Sector_Data+0xc>
81142288:	003b68fa 	trap	3
8114228c:	dfc00515 	stw	ra,20(sp)
81142290:	df000415 	stw	fp,16(sp)
81142294:	df000404 	addi	fp,sp,16
81142298:	e13ffe15 	stw	r4,-8(fp)
8114229c:	e17fff15 	stw	r5,-4(fp)
	bool result = false;
811422a0:	e03ffc15 	stw	zero,-16(fp)
    
	if (alt_up_sd_card_is_Present())
811422a4:	1144f580 	call	81144f58 <alt_up_sd_card_is_Present>
811422a8:	10002726 	beq	r2,zero,81142348 <Read_Sector_Data+0xc8>
	{
		short int reg_state = 0xff;
811422ac:	00803fc4 	movi	r2,255
811422b0:	e0bffd0d 	sth	r2,-12(fp)
        
        /* Write data to the SD card if the current buffer is out of date. */
        if (current_sector_modified)
811422b4:	d0a0b417 	ldw	r2,-32048(gp)
811422b8:	10000726 	beq	r2,zero,811422d8 <Read_Sector_Data+0x58>
        {
            if (Write_Sector_Data(current_sector_index, 0) == false)
811422bc:	d0a0b517 	ldw	r2,-32044(gp)
811422c0:	000b883a 	mov	r5,zero
811422c4:	1009883a 	mov	r4,r2
811422c8:	11421700 	call	81142170 <Write_Sector_Data>
811422cc:	1000021e 	bne	r2,zero,811422d8 <Read_Sector_Data+0x58>
            {
                return false;
811422d0:	0005883a 	mov	r2,zero
811422d4:	00001d06 	br	8114234c <Read_Sector_Data+0xcc>
            }
        }
		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
		 * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
811422d8:	d0a0af17 	ldw	r2,-32068(gp)
811422dc:	e13ffe17 	ldw	r4,-8(fp)
811422e0:	e0ffff17 	ldw	r3,-4(fp)
811422e4:	20c7883a 	add	r3,r4,r3
811422e8:	1806927a 	slli	r3,r3,9
811422ec:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_READ_BLOCK);
811422f0:	d0a0ae17 	ldw	r2,-32072(gp)
811422f4:	00c00444 	movi	r3,17
811422f8:	10c0002d 	sthio	r3,0(r2)
		do {
			reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
811422fc:	d0a0ab17 	ldw	r2,-32084(gp)
81142300:	1080002b 	ldhuio	r2,0(r2)
81142304:	10bfffcc 	andi	r2,r2,65535
81142308:	e0bffd0d 	sth	r2,-12(fp)
		} while ((reg_state & 0x04)!=0);
8114230c:	e0bffd0b 	ldhu	r2,-12(fp)
81142310:	10bfffcc 	andi	r2,r2,65535
81142314:	1080010c 	andi	r2,r2,4
81142318:	103ff81e 	bne	r2,zero,811422fc <__reset+0xfb1222fc>
		// Make sure the request did not time out.
		if ((reg_state & 0x10) == 0)
8114231c:	e0bffd0b 	ldhu	r2,-12(fp)
81142320:	10bfffcc 	andi	r2,r2,65535
81142324:	1080040c 	andi	r2,r2,16
81142328:	1000071e 	bne	r2,zero,81142348 <Read_Sector_Data+0xc8>
		{
			result = true;
8114232c:	00800044 	movi	r2,1
81142330:	e0bffc15 	stw	r2,-16(fp)
            current_sector_modified = false;
81142334:	d020b415 	stw	zero,-32048(gp)
            current_sector_index = sector_index+partition_offset;
81142338:	e0fffe17 	ldw	r3,-8(fp)
8114233c:	e0bfff17 	ldw	r2,-4(fp)
81142340:	1885883a 	add	r2,r3,r2
81142344:	d0a0b515 	stw	r2,-32044(gp)
		}
	}
	return result;
81142348:	e0bffc17 	ldw	r2,-16(fp)
}
8114234c:	e037883a 	mov	sp,fp
81142350:	dfc00117 	ldw	ra,4(sp)
81142354:	df000017 	ldw	fp,0(sp)
81142358:	dec00204 	addi	sp,sp,8
8114235c:	f800283a 	ret

81142360 <get_cluster_flag>:


bool get_cluster_flag(unsigned int cluster_index, unsigned short int *flag)
// Read a cluster flag.
{
81142360:	defffb04 	addi	sp,sp,-20
81142364:	de00012e 	bgeu	sp,et,8114236c <get_cluster_flag+0xc>
81142368:	003b68fa 	trap	3
8114236c:	dfc00415 	stw	ra,16(sp)
81142370:	df000315 	stw	fp,12(sp)
81142374:	df000304 	addi	fp,sp,12
81142378:	e13ffe15 	stw	r4,-8(fp)
8114237c:	e17fff15 	stw	r5,-4(fp)
    unsigned int sector_index = (cluster_index / 256) + fat_partition_offset_in_512_byte_sectors;
81142380:	e0bffe17 	ldw	r2,-8(fp)
81142384:	1004d23a 	srli	r2,r2,8
81142388:	d0e0b117 	ldw	r3,-32060(gp)
8114238c:	10c5883a 	add	r2,r2,r3
81142390:	e0bffd15 	stw	r2,-12(fp)
    
    sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
81142394:	00a045f4 	movhi	r2,33047
81142398:	10b44904 	addi	r2,r2,-11996
8114239c:	10801117 	ldw	r2,68(r2)
811423a0:	e0fffd17 	ldw	r3,-12(fp)
811423a4:	1885883a 	add	r2,r3,r2
811423a8:	e0bffd15 	stw	r2,-12(fp)
     
    if (sector_index != current_sector_index)
811423ac:	d0a0b517 	ldw	r2,-32044(gp)
811423b0:	e0fffd17 	ldw	r3,-12(fp)
811423b4:	18800726 	beq	r3,r2,811423d4 <get_cluster_flag+0x74>
    {
        if (Read_Sector_Data(sector_index, 0) == false)
811423b8:	e0bffd17 	ldw	r2,-12(fp)
811423bc:	000b883a 	mov	r5,zero
811423c0:	1009883a 	mov	r4,r2
811423c4:	11422800 	call	81142280 <Read_Sector_Data>
811423c8:	1000021e 	bne	r2,zero,811423d4 <get_cluster_flag+0x74>
        {
            return false;
811423cc:	0005883a 	mov	r2,zero
811423d0:	00000d06 	br	81142408 <get_cluster_flag+0xa8>
        }
    }
    *flag = (unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256));
811423d4:	e0bffe17 	ldw	r2,-8(fp)
811423d8:	10803fcc 	andi	r2,r2,255
811423dc:	1085883a 	add	r2,r2,r2
811423e0:	1007883a 	mov	r3,r2
811423e4:	d0a0b317 	ldw	r2,-32052(gp)
811423e8:	10800a17 	ldw	r2,40(r2)
811423ec:	1885883a 	add	r2,r3,r2
811423f0:	1080002b 	ldhuio	r2,0(r2)
811423f4:	10bfffcc 	andi	r2,r2,65535
811423f8:	1007883a 	mov	r3,r2
811423fc:	e0bfff17 	ldw	r2,-4(fp)
81142400:	10c0000d 	sth	r3,0(r2)
    return true;
81142404:	00800044 	movi	r2,1
}
81142408:	e037883a 	mov	sp,fp
8114240c:	dfc00117 	ldw	ra,4(sp)
81142410:	df000017 	ldw	fp,0(sp)
81142414:	dec00204 	addi	sp,sp,8
81142418:	f800283a 	ret

8114241c <mark_cluster>:


bool mark_cluster(unsigned int cluster_index, short int flag, bool first_fat)
// Place a marker on the specified cluster in a given FAT.
{
8114241c:	defffa04 	addi	sp,sp,-24
81142420:	de00012e 	bgeu	sp,et,81142428 <mark_cluster+0xc>
81142424:	003b68fa 	trap	3
81142428:	dfc00515 	stw	ra,20(sp)
8114242c:	df000415 	stw	fp,16(sp)
81142430:	df000404 	addi	fp,sp,16
81142434:	e13ffd15 	stw	r4,-12(fp)
81142438:	2805883a 	mov	r2,r5
8114243c:	e1bfff15 	stw	r6,-4(fp)
81142440:	e0bffe0d 	sth	r2,-8(fp)
    unsigned int sector_index = (cluster_index / 256) +  fat_partition_offset_in_512_byte_sectors;
81142444:	e0bffd17 	ldw	r2,-12(fp)
81142448:	1004d23a 	srli	r2,r2,8
8114244c:	d0e0b117 	ldw	r3,-32060(gp)
81142450:	10c5883a 	add	r2,r2,r3
81142454:	e0bffc15 	stw	r2,-16(fp)
    
    if (first_fat)
81142458:	e0bfff17 	ldw	r2,-4(fp)
8114245c:	10000726 	beq	r2,zero,8114247c <mark_cluster+0x60>
    {
        sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
81142460:	00a045f4 	movhi	r2,33047
81142464:	10b44904 	addi	r2,r2,-11996
81142468:	10801117 	ldw	r2,68(r2)
8114246c:	e0fffc17 	ldw	r3,-16(fp)
81142470:	1885883a 	add	r2,r3,r2
81142474:	e0bffc15 	stw	r2,-16(fp)
81142478:	00000606 	br	81142494 <mark_cluster+0x78>
    }
    else
    {
        sector_index  = sector_index + boot_sector_data.second_fat_sector_offset;
8114247c:	00a045f4 	movhi	r2,33047
81142480:	10b44904 	addi	r2,r2,-11996
81142484:	10801217 	ldw	r2,72(r2)
81142488:	e0fffc17 	ldw	r3,-16(fp)
8114248c:	1885883a 	add	r2,r3,r2
81142490:	e0bffc15 	stw	r2,-16(fp)
    }
     
    if (sector_index != current_sector_index)
81142494:	d0a0b517 	ldw	r2,-32044(gp)
81142498:	e0fffc17 	ldw	r3,-16(fp)
8114249c:	18800726 	beq	r3,r2,811424bc <mark_cluster+0xa0>
    {
        if (Read_Sector_Data(sector_index, 0) == false)
811424a0:	e0bffc17 	ldw	r2,-16(fp)
811424a4:	000b883a 	mov	r5,zero
811424a8:	1009883a 	mov	r4,r2
811424ac:	11422800 	call	81142280 <Read_Sector_Data>
811424b0:	1000021e 	bne	r2,zero,811424bc <mark_cluster+0xa0>
        {
            return false;
811424b4:	0005883a 	mov	r2,zero
811424b8:	00000d06 	br	811424f0 <mark_cluster+0xd4>
        }
    }
    IOWR_16DIRECT(device_pointer->base, 2*(cluster_index % 256), flag);
811424bc:	e0bffd17 	ldw	r2,-12(fp)
811424c0:	10803fcc 	andi	r2,r2,255
811424c4:	1085883a 	add	r2,r2,r2
811424c8:	1007883a 	mov	r3,r2
811424cc:	d0a0b317 	ldw	r2,-32052(gp)
811424d0:	10800a17 	ldw	r2,40(r2)
811424d4:	1885883a 	add	r2,r3,r2
811424d8:	1007883a 	mov	r3,r2
811424dc:	e0bffe0f 	ldh	r2,-8(fp)
811424e0:	1880002d 	sthio	r2,0(r3)
    current_sector_modified = true;
811424e4:	00800044 	movi	r2,1
811424e8:	d0a0b415 	stw	r2,-32048(gp)
    return true;
811424ec:	00800044 	movi	r2,1
}
811424f0:	e037883a 	mov	sp,fp
811424f4:	dfc00117 	ldw	ra,4(sp)
811424f8:	df000017 	ldw	fp,0(sp)
811424fc:	dec00204 	addi	sp,sp,8
81142500:	f800283a 	ret

81142504 <Check_for_Master_Boot_Record>:

bool Check_for_Master_Boot_Record(void)
// This function reads the first 512 bytes on the SD Card. This data should
// contain the Master Boot Record. If it does, then print
// relevant information and return true. Otherwise, return false. 
{
81142504:	defff704 	addi	sp,sp,-36
81142508:	de00012e 	bgeu	sp,et,81142510 <Check_for_Master_Boot_Record+0xc>
8114250c:	003b68fa 	trap	3
81142510:	dfc00815 	stw	ra,32(sp)
81142514:	df000715 	stw	fp,28(sp)
81142518:	df000704 	addi	fp,sp,28
	bool result = false;
8114251c:	e03ff915 	stw	zero,-28(fp)
	int index;
	int end, offset, partition_size;

	/* Load the first 512 bytes of data from SD card. */
	if (Read_Sector_Data(0, 0))
81142520:	000b883a 	mov	r5,zero
81142524:	0009883a 	mov	r4,zero
81142528:	11422800 	call	81142280 <Read_Sector_Data>
8114252c:	10005a26 	beq	r2,zero,81142698 <Check_for_Master_Boot_Record+0x194>
	{
		end =  (short int) IORD_16DIRECT(device_pointer->base,0x1fe);
81142530:	d0a0b317 	ldw	r2,-32052(gp)
81142534:	10800a17 	ldw	r2,40(r2)
81142538:	10807f84 	addi	r2,r2,510
8114253c:	1080002b 	ldhuio	r2,0(r2)
81142540:	10bfffcc 	andi	r2,r2,65535
81142544:	10bfffcc 	andi	r2,r2,65535
81142548:	10a0001c 	xori	r2,r2,32768
8114254c:	10a00004 	addi	r2,r2,-32768
81142550:	e0bffb15 	stw	r2,-20(fp)

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
81142554:	e0bffb17 	ldw	r2,-20(fp)
81142558:	10ffffcc 	andi	r3,r2,65535
8114255c:	00aa9554 	movui	r2,43605
81142560:	18804d1e 	bne	r3,r2,81142698 <Check_for_Master_Boot_Record+0x194>
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
81142564:	e03ffa15 	stw	zero,-24(fp)
81142568:	00004806 	br	8114268c <Check_for_Master_Boot_Record+0x188>
			{
				int partition_data_offset = (index * 16) + 0x01be;
8114256c:	e0bffa17 	ldw	r2,-24(fp)
81142570:	1004913a 	slli	r2,r2,4
81142574:	10806f84 	addi	r2,r2,446
81142578:	e0bffc15 	stw	r2,-16(fp)
				char type;
		        
				// Read Partition type
				type = (unsigned char) IORD_8DIRECT(device_pointer->base,partition_data_offset + 0x04);
8114257c:	d0a0b317 	ldw	r2,-32052(gp)
81142580:	10c00a17 	ldw	r3,40(r2)
81142584:	e0bffc17 	ldw	r2,-16(fp)
81142588:	1885883a 	add	r2,r3,r2
8114258c:	10800104 	addi	r2,r2,4
81142590:	10800023 	ldbuio	r2,0(r2)
81142594:	10803fcc 	andi	r2,r2,255
81142598:	e0bffd05 	stb	r2,-12(fp)

				// Check if this is an FAT parition
				if ((type == 1) || (type == 4) || (type == 6) || (type == 14))
8114259c:	e0bffd07 	ldb	r2,-12(fp)
811425a0:	10800060 	cmpeqi	r2,r2,1
811425a4:	1000091e 	bne	r2,zero,811425cc <Check_for_Master_Boot_Record+0xc8>
811425a8:	e0bffd07 	ldb	r2,-12(fp)
811425ac:	10800120 	cmpeqi	r2,r2,4
811425b0:	1000061e 	bne	r2,zero,811425cc <Check_for_Master_Boot_Record+0xc8>
811425b4:	e0bffd07 	ldb	r2,-12(fp)
811425b8:	108001a0 	cmpeqi	r2,r2,6
811425bc:	1000031e 	bne	r2,zero,811425cc <Check_for_Master_Boot_Record+0xc8>
811425c0:	e0bffd07 	ldb	r2,-12(fp)
811425c4:	10800398 	cmpnei	r2,r2,14
811425c8:	10002d1e 	bne	r2,zero,81142680 <Check_for_Master_Boot_Record+0x17c>
				{
					// Get partition offset and size.
					offset = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0A)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x08));
811425cc:	d0a0b317 	ldw	r2,-32052(gp)
811425d0:	10c00a17 	ldw	r3,40(r2)
811425d4:	e0bffc17 	ldw	r2,-16(fp)
811425d8:	1885883a 	add	r2,r3,r2
811425dc:	10800284 	addi	r2,r2,10
811425e0:	1080002b 	ldhuio	r2,0(r2)
811425e4:	10bfffcc 	andi	r2,r2,65535
811425e8:	1006943a 	slli	r3,r2,16
811425ec:	d0a0b317 	ldw	r2,-32052(gp)
811425f0:	11000a17 	ldw	r4,40(r2)
811425f4:	e0bffc17 	ldw	r2,-16(fp)
811425f8:	2085883a 	add	r2,r4,r2
811425fc:	10800204 	addi	r2,r2,8
81142600:	1080002b 	ldhuio	r2,0(r2)
81142604:	10bfffcc 	andi	r2,r2,65535
81142608:	10bfffcc 	andi	r2,r2,65535
8114260c:	1884b03a 	or	r2,r3,r2
81142610:	e0bffe15 	stw	r2,-8(fp)
					partition_size = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0E)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0C));
81142614:	d0a0b317 	ldw	r2,-32052(gp)
81142618:	10c00a17 	ldw	r3,40(r2)
8114261c:	e0bffc17 	ldw	r2,-16(fp)
81142620:	1885883a 	add	r2,r3,r2
81142624:	10800384 	addi	r2,r2,14
81142628:	1080002b 	ldhuio	r2,0(r2)
8114262c:	10bfffcc 	andi	r2,r2,65535
81142630:	1006943a 	slli	r3,r2,16
81142634:	d0a0b317 	ldw	r2,-32052(gp)
81142638:	11000a17 	ldw	r4,40(r2)
8114263c:	e0bffc17 	ldw	r2,-16(fp)
81142640:	2085883a 	add	r2,r4,r2
81142644:	10800304 	addi	r2,r2,12
81142648:	1080002b 	ldhuio	r2,0(r2)
8114264c:	10bfffcc 	andi	r2,r2,65535
81142650:	10bfffcc 	andi	r2,r2,65535
81142654:	1884b03a 	or	r2,r3,r2
81142658:	e0bfff15 	stw	r2,-4(fp)
		            
					// Check if the partition is valid
					if (partition_size > 0)
8114265c:	e0bfff17 	ldw	r2,-4(fp)
81142660:	0080070e 	bge	zero,r2,81142680 <Check_for_Master_Boot_Record+0x17c>
					{
						result = true;
81142664:	00800044 	movi	r2,1
81142668:	e0bff915 	stw	r2,-28(fp)
						fat_partition_size_in_512_byte_sectors = partition_size;
8114266c:	e0bfff17 	ldw	r2,-4(fp)
81142670:	d0a0b215 	stw	r2,-32056(gp)
						fat_partition_offset_in_512_byte_sectors = offset;
81142674:	e0bffe17 	ldw	r2,-8(fp)
81142678:	d0a0b115 	stw	r2,-32060(gp)
						break;
8114267c:	00000606 	br	81142698 <Check_for_Master_Boot_Record+0x194>

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
81142680:	e0bffa17 	ldw	r2,-24(fp)
81142684:	10800044 	addi	r2,r2,1
81142688:	e0bffa15 	stw	r2,-24(fp)
8114268c:	e0bffa17 	ldw	r2,-24(fp)
81142690:	10800110 	cmplti	r2,r2,4
81142694:	103fb51e 	bne	r2,zero,8114256c <__reset+0xfb12256c>
				}
			}
		}
	}

	return result;
81142698:	e0bff917 	ldw	r2,-28(fp)
}
8114269c:	e037883a 	mov	sp,fp
811426a0:	dfc00117 	ldw	ra,4(sp)
811426a4:	df000017 	ldw	fp,0(sp)
811426a8:	dec00204 	addi	sp,sp,8
811426ac:	f800283a 	ret

811426b0 <Read_File_Record_At_Offset>:


bool Read_File_Record_At_Offset(int offset, t_file_record *record, unsigned int cluster_index, unsigned int sector_in_cluster)
// This function reads a file record
{
811426b0:	defff804 	addi	sp,sp,-32
811426b4:	de00012e 	bgeu	sp,et,811426bc <Read_File_Record_At_Offset+0xc>
811426b8:	003b68fa 	trap	3
811426bc:	dfc00715 	stw	ra,28(sp)
811426c0:	df000615 	stw	fp,24(sp)
811426c4:	df000604 	addi	fp,sp,24
811426c8:	e13ffc15 	stw	r4,-16(fp)
811426cc:	e17ffd15 	stw	r5,-12(fp)
811426d0:	e1bffe15 	stw	r6,-8(fp)
811426d4:	e1ffff15 	stw	r7,-4(fp)
	bool result = false;
811426d8:	e03ffa15 	stw	zero,-24(fp)
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
811426dc:	e0bffc17 	ldw	r2,-16(fp)
811426e0:	108007cc 	andi	r2,r2,31
811426e4:	10008d1e 	bne	r2,zero,8114291c <Read_File_Record_At_Offset+0x26c>
811426e8:	1144f580 	call	81144f58 <alt_up_sd_card_is_Present>
811426ec:	10008b26 	beq	r2,zero,8114291c <Read_File_Record_At_Offset+0x26c>
811426f0:	d0a0aa17 	ldw	r2,-32088(gp)
811426f4:	10008926 	beq	r2,zero,8114291c <Read_File_Record_At_Offset+0x26c>
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
811426f8:	e03ffb15 	stw	zero,-20(fp)
811426fc:	00001106 	br	81142744 <Read_File_Record_At_Offset+0x94>
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
81142700:	e0fffc17 	ldw	r3,-16(fp)
81142704:	e0bffb17 	ldw	r2,-20(fp)
81142708:	1885883a 	add	r2,r3,r2
8114270c:	1007883a 	mov	r3,r2
81142710:	d0a0b317 	ldw	r2,-32052(gp)
81142714:	10800a17 	ldw	r2,40(r2)
81142718:	1885883a 	add	r2,r3,r2
8114271c:	10800023 	ldbuio	r2,0(r2)
81142720:	10803fcc 	andi	r2,r2,255
81142724:	1009883a 	mov	r4,r2
81142728:	e0fffd17 	ldw	r3,-12(fp)
8114272c:	e0bffb17 	ldw	r2,-20(fp)
81142730:	1885883a 	add	r2,r3,r2
81142734:	11000005 	stb	r4,0(r2)
	bool result = false;
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
81142738:	e0bffb17 	ldw	r2,-20(fp)
8114273c:	10800044 	addi	r2,r2,1
81142740:	e0bffb15 	stw	r2,-20(fp)
81142744:	e0bffb17 	ldw	r2,-20(fp)
81142748:	10800210 	cmplti	r2,r2,8
8114274c:	103fec1e 	bne	r2,zero,81142700 <__reset+0xfb122700>
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
81142750:	e03ffb15 	stw	zero,-20(fp)
81142754:	00001306 	br	811427a4 <Read_File_Record_At_Offset+0xf4>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
81142758:	e0fffc17 	ldw	r3,-16(fp)
8114275c:	e0bffb17 	ldw	r2,-20(fp)
81142760:	1885883a 	add	r2,r3,r2
81142764:	1007883a 	mov	r3,r2
81142768:	d0a0b317 	ldw	r2,-32052(gp)
8114276c:	10800a17 	ldw	r2,40(r2)
81142770:	1885883a 	add	r2,r3,r2
81142774:	10800204 	addi	r2,r2,8
81142778:	10800023 	ldbuio	r2,0(r2)
8114277c:	10803fcc 	andi	r2,r2,255
81142780:	1009883a 	mov	r4,r2
81142784:	e0fffd17 	ldw	r3,-12(fp)
81142788:	e0bffb17 	ldw	r2,-20(fp)
8114278c:	1885883a 	add	r2,r3,r2
81142790:	10800204 	addi	r2,r2,8
81142794:	11000005 	stb	r4,0(r2)

		for (counter = 0; counter < 8; counter++)
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
81142798:	e0bffb17 	ldw	r2,-20(fp)
8114279c:	10800044 	addi	r2,r2,1
811427a0:	e0bffb15 	stw	r2,-20(fp)
811427a4:	e0bffb17 	ldw	r2,-20(fp)
811427a8:	108000d0 	cmplti	r2,r2,3
811427ac:	103fea1e 	bne	r2,zero,81142758 <__reset+0xfb122758>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
		}        
		record->attributes          =   (char) IORD_8DIRECT(device_pointer->base, offset+11);
811427b0:	d0a0b317 	ldw	r2,-32052(gp)
811427b4:	10c00a17 	ldw	r3,40(r2)
811427b8:	e0bffc17 	ldw	r2,-16(fp)
811427bc:	1885883a 	add	r2,r3,r2
811427c0:	108002c4 	addi	r2,r2,11
811427c4:	10800023 	ldbuio	r2,0(r2)
811427c8:	10803fcc 	andi	r2,r2,255
811427cc:	1007883a 	mov	r3,r2
811427d0:	e0bffd17 	ldw	r2,-12(fp)
811427d4:	10c002c5 	stb	r3,11(r2)
		/* Ignore reserved bytes at locations 12 and 13. */
		record->create_time         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+14);
811427d8:	d0a0b317 	ldw	r2,-32052(gp)
811427dc:	10c00a17 	ldw	r3,40(r2)
811427e0:	e0bffc17 	ldw	r2,-16(fp)
811427e4:	1885883a 	add	r2,r3,r2
811427e8:	10800384 	addi	r2,r2,14
811427ec:	1080002b 	ldhuio	r2,0(r2)
811427f0:	10bfffcc 	andi	r2,r2,65535
811427f4:	1007883a 	mov	r3,r2
811427f8:	e0bffd17 	ldw	r2,-12(fp)
811427fc:	10c0030d 	sth	r3,12(r2)
		record->create_date         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+16);
81142800:	d0a0b317 	ldw	r2,-32052(gp)
81142804:	10c00a17 	ldw	r3,40(r2)
81142808:	e0bffc17 	ldw	r2,-16(fp)
8114280c:	1885883a 	add	r2,r3,r2
81142810:	10800404 	addi	r2,r2,16
81142814:	1080002b 	ldhuio	r2,0(r2)
81142818:	10bfffcc 	andi	r2,r2,65535
8114281c:	1007883a 	mov	r3,r2
81142820:	e0bffd17 	ldw	r2,-12(fp)
81142824:	10c0038d 	sth	r3,14(r2)
		record->last_access_date    =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+18);
81142828:	d0a0b317 	ldw	r2,-32052(gp)
8114282c:	10c00a17 	ldw	r3,40(r2)
81142830:	e0bffc17 	ldw	r2,-16(fp)
81142834:	1885883a 	add	r2,r3,r2
81142838:	10800484 	addi	r2,r2,18
8114283c:	1080002b 	ldhuio	r2,0(r2)
81142840:	10bfffcc 	andi	r2,r2,65535
81142844:	1007883a 	mov	r3,r2
81142848:	e0bffd17 	ldw	r2,-12(fp)
8114284c:	10c0040d 	sth	r3,16(r2)
		/* Ignore reserved bytes at locations 20 and 21. */
		record->last_modified_time  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+22);
81142850:	d0a0b317 	ldw	r2,-32052(gp)
81142854:	10c00a17 	ldw	r3,40(r2)
81142858:	e0bffc17 	ldw	r2,-16(fp)
8114285c:	1885883a 	add	r2,r3,r2
81142860:	10800584 	addi	r2,r2,22
81142864:	1080002b 	ldhuio	r2,0(r2)
81142868:	10bfffcc 	andi	r2,r2,65535
8114286c:	1007883a 	mov	r3,r2
81142870:	e0bffd17 	ldw	r2,-12(fp)
81142874:	10c0048d 	sth	r3,18(r2)
		record->last_modified_date  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+24);
81142878:	d0a0b317 	ldw	r2,-32052(gp)
8114287c:	10c00a17 	ldw	r3,40(r2)
81142880:	e0bffc17 	ldw	r2,-16(fp)
81142884:	1885883a 	add	r2,r3,r2
81142888:	10800604 	addi	r2,r2,24
8114288c:	1080002b 	ldhuio	r2,0(r2)
81142890:	10bfffcc 	andi	r2,r2,65535
81142894:	1007883a 	mov	r3,r2
81142898:	e0bffd17 	ldw	r2,-12(fp)
8114289c:	10c0050d 	sth	r3,20(r2)
		record->start_cluster_index =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+26);
811428a0:	d0a0b317 	ldw	r2,-32052(gp)
811428a4:	10c00a17 	ldw	r3,40(r2)
811428a8:	e0bffc17 	ldw	r2,-16(fp)
811428ac:	1885883a 	add	r2,r3,r2
811428b0:	10800684 	addi	r2,r2,26
811428b4:	1080002b 	ldhuio	r2,0(r2)
811428b8:	10bfffcc 	andi	r2,r2,65535
811428bc:	1007883a 	mov	r3,r2
811428c0:	e0bffd17 	ldw	r2,-12(fp)
811428c4:	10c0058d 	sth	r3,22(r2)
		record->file_size_in_bytes  =	(unsigned int) IORD_32DIRECT(device_pointer->base, offset+28);
811428c8:	d0a0b317 	ldw	r2,-32052(gp)
811428cc:	10c00a17 	ldw	r3,40(r2)
811428d0:	e0bffc17 	ldw	r2,-16(fp)
811428d4:	1885883a 	add	r2,r3,r2
811428d8:	10800704 	addi	r2,r2,28
811428dc:	10800037 	ldwio	r2,0(r2)
811428e0:	1007883a 	mov	r3,r2
811428e4:	e0bffd17 	ldw	r2,-12(fp)
811428e8:	10c00615 	stw	r3,24(r2)
		record->file_record_cluster = cluster_index;
811428ec:	e0bffd17 	ldw	r2,-12(fp)
811428f0:	e0fffe17 	ldw	r3,-8(fp)
811428f4:	10c00a15 	stw	r3,40(r2)
		record->file_record_sector_in_cluster = sector_in_cluster;
811428f8:	e0bffd17 	ldw	r2,-12(fp)
811428fc:	e0ffff17 	ldw	r3,-4(fp)
81142900:	10c00b15 	stw	r3,44(r2)
		record->file_record_offset = offset;
81142904:	e0bffc17 	ldw	r2,-16(fp)
81142908:	1007883a 	mov	r3,r2
8114290c:	e0bffd17 	ldw	r2,-12(fp)
81142910:	10c00c0d 	sth	r3,48(r2)
		result = true;
81142914:	00800044 	movi	r2,1
81142918:	e0bffa15 	stw	r2,-24(fp)
	}
	return result;
8114291c:	e0bffa17 	ldw	r2,-24(fp)
}
81142920:	e037883a 	mov	sp,fp
81142924:	dfc00117 	ldw	ra,4(sp)
81142928:	df000017 	ldw	fp,0(sp)
8114292c:	dec00204 	addi	sp,sp,8
81142930:	f800283a 	ret

81142934 <Write_File_Record_At_Offset>:


bool Write_File_Record_At_Offset(int offset, t_file_record *record)
// This function writes a file record at a given offset. The offset is given in bytes.
{
81142934:	defff904 	addi	sp,sp,-28
81142938:	de00012e 	bgeu	sp,et,81142940 <Write_File_Record_At_Offset+0xc>
8114293c:	003b68fa 	trap	3
81142940:	dfc00615 	stw	ra,24(sp)
81142944:	df000515 	stw	fp,20(sp)
81142948:	df000504 	addi	fp,sp,20
8114294c:	e13ffe15 	stw	r4,-8(fp)
81142950:	e17fff15 	stw	r5,-4(fp)
    bool result = false;
81142954:	e03ffb15 	stw	zero,-20(fp)
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81142958:	e0bffe17 	ldw	r2,-8(fp)
8114295c:	108007cc 	andi	r2,r2,31
81142960:	1000931e 	bne	r2,zero,81142bb0 <Write_File_Record_At_Offset+0x27c>
81142964:	1144f580 	call	81144f58 <alt_up_sd_card_is_Present>
81142968:	10009126 	beq	r2,zero,81142bb0 <Write_File_Record_At_Offset+0x27c>
8114296c:	d0a0aa17 	ldw	r2,-32088(gp)
81142970:	10008f26 	beq	r2,zero,81142bb0 <Write_File_Record_At_Offset+0x27c>
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
81142974:	e03ffc15 	stw	zero,-16(fp)
81142978:	00001f06 	br	811429f8 <Write_File_Record_At_Offset+0xc4>
        {
            short int two_chars = (short int) record->name[counter+1];
8114297c:	e0bffc17 	ldw	r2,-16(fp)
81142980:	10800044 	addi	r2,r2,1
81142984:	e0ffff17 	ldw	r3,-4(fp)
81142988:	1885883a 	add	r2,r3,r2
8114298c:	10800003 	ldbu	r2,0(r2)
81142990:	10803fcc 	andi	r2,r2,255
81142994:	e0bffd0d 	sth	r2,-12(fp)
            two_chars = two_chars << 8;
81142998:	e0bffd0f 	ldh	r2,-12(fp)
8114299c:	1004923a 	slli	r2,r2,8
811429a0:	e0bffd0d 	sth	r2,-12(fp)
            two_chars = two_chars | record->name[counter];
811429a4:	e0ffff17 	ldw	r3,-4(fp)
811429a8:	e0bffc17 	ldw	r2,-16(fp)
811429ac:	1885883a 	add	r2,r3,r2
811429b0:	10800003 	ldbu	r2,0(r2)
811429b4:	10c03fcc 	andi	r3,r2,255
811429b8:	e0bffd0b 	ldhu	r2,-12(fp)
811429bc:	1884b03a 	or	r2,r3,r2
811429c0:	e0bffd0d 	sth	r2,-12(fp)
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
811429c4:	e0fffe17 	ldw	r3,-8(fp)
811429c8:	e0bffc17 	ldw	r2,-16(fp)
811429cc:	1885883a 	add	r2,r3,r2
811429d0:	1007883a 	mov	r3,r2
811429d4:	d0a0b317 	ldw	r2,-32052(gp)
811429d8:	10800a17 	ldw	r2,40(r2)
811429dc:	1885883a 	add	r2,r3,r2
811429e0:	1007883a 	mov	r3,r2
811429e4:	e0bffd0f 	ldh	r2,-12(fp)
811429e8:	1880002d 	sthio	r2,0(r3)
    bool result = false;
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
811429ec:	e0bffc17 	ldw	r2,-16(fp)
811429f0:	10800084 	addi	r2,r2,2
811429f4:	e0bffc15 	stw	r2,-16(fp)
811429f8:	e0bffc17 	ldw	r2,-16(fp)
811429fc:	10800210 	cmplti	r2,r2,8
81142a00:	103fde1e 	bne	r2,zero,8114297c <__reset+0xfb12297c>
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
81142a04:	e03ffc15 	stw	zero,-16(fp)
81142a08:	00001306 	br	81142a58 <Write_File_Record_At_Offset+0x124>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
81142a0c:	e0fffe17 	ldw	r3,-8(fp)
81142a10:	e0bffc17 	ldw	r2,-16(fp)
81142a14:	1885883a 	add	r2,r3,r2
81142a18:	1007883a 	mov	r3,r2
81142a1c:	d0a0b317 	ldw	r2,-32052(gp)
81142a20:	10800a17 	ldw	r2,40(r2)
81142a24:	1885883a 	add	r2,r3,r2
81142a28:	10800204 	addi	r2,r2,8
81142a2c:	1009883a 	mov	r4,r2
81142a30:	e0ffff17 	ldw	r3,-4(fp)
81142a34:	e0bffc17 	ldw	r2,-16(fp)
81142a38:	1885883a 	add	r2,r3,r2
81142a3c:	10800204 	addi	r2,r2,8
81142a40:	10800003 	ldbu	r2,0(r2)
81142a44:	10803fcc 	andi	r2,r2,255
81142a48:	20800025 	stbio	r2,0(r4)
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
81142a4c:	e0bffc17 	ldw	r2,-16(fp)
81142a50:	10800044 	addi	r2,r2,1
81142a54:	e0bffc15 	stw	r2,-16(fp)
81142a58:	e0bffc17 	ldw	r2,-16(fp)
81142a5c:	108000d0 	cmplti	r2,r2,3
81142a60:	103fea1e 	bne	r2,zero,81142a0c <__reset+0xfb122a0c>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
        }        
        IOWR_8DIRECT(device_pointer->base, offset+11, record->attributes);
81142a64:	d0a0b317 	ldw	r2,-32052(gp)
81142a68:	10c00a17 	ldw	r3,40(r2)
81142a6c:	e0bffe17 	ldw	r2,-8(fp)
81142a70:	1885883a 	add	r2,r3,r2
81142a74:	108002c4 	addi	r2,r2,11
81142a78:	1007883a 	mov	r3,r2
81142a7c:	e0bfff17 	ldw	r2,-4(fp)
81142a80:	108002c3 	ldbu	r2,11(r2)
81142a84:	10803fcc 	andi	r2,r2,255
81142a88:	18800025 	stbio	r2,0(r3)
        /* Ignore reserved bytes at locations 12 and 13. */
        IOWR_16DIRECT(device_pointer->base, offset+14, record->create_time);
81142a8c:	d0a0b317 	ldw	r2,-32052(gp)
81142a90:	10c00a17 	ldw	r3,40(r2)
81142a94:	e0bffe17 	ldw	r2,-8(fp)
81142a98:	1885883a 	add	r2,r3,r2
81142a9c:	10800384 	addi	r2,r2,14
81142aa0:	1007883a 	mov	r3,r2
81142aa4:	e0bfff17 	ldw	r2,-4(fp)
81142aa8:	1080030b 	ldhu	r2,12(r2)
81142aac:	10bfffcc 	andi	r2,r2,65535
81142ab0:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+16, record->create_date);
81142ab4:	d0a0b317 	ldw	r2,-32052(gp)
81142ab8:	10c00a17 	ldw	r3,40(r2)
81142abc:	e0bffe17 	ldw	r2,-8(fp)
81142ac0:	1885883a 	add	r2,r3,r2
81142ac4:	10800404 	addi	r2,r2,16
81142ac8:	1007883a 	mov	r3,r2
81142acc:	e0bfff17 	ldw	r2,-4(fp)
81142ad0:	1080038b 	ldhu	r2,14(r2)
81142ad4:	10bfffcc 	andi	r2,r2,65535
81142ad8:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+18, record->last_access_date);
81142adc:	d0a0b317 	ldw	r2,-32052(gp)
81142ae0:	10c00a17 	ldw	r3,40(r2)
81142ae4:	e0bffe17 	ldw	r2,-8(fp)
81142ae8:	1885883a 	add	r2,r3,r2
81142aec:	10800484 	addi	r2,r2,18
81142af0:	1007883a 	mov	r3,r2
81142af4:	e0bfff17 	ldw	r2,-4(fp)
81142af8:	1080040b 	ldhu	r2,16(r2)
81142afc:	10bfffcc 	andi	r2,r2,65535
81142b00:	1880002d 	sthio	r2,0(r3)
        /* Ignore reserved bytes at locations 20 and 21. */
        IOWR_16DIRECT(device_pointer->base, offset+22, record->last_modified_time);
81142b04:	d0a0b317 	ldw	r2,-32052(gp)
81142b08:	10c00a17 	ldw	r3,40(r2)
81142b0c:	e0bffe17 	ldw	r2,-8(fp)
81142b10:	1885883a 	add	r2,r3,r2
81142b14:	10800584 	addi	r2,r2,22
81142b18:	1007883a 	mov	r3,r2
81142b1c:	e0bfff17 	ldw	r2,-4(fp)
81142b20:	1080048b 	ldhu	r2,18(r2)
81142b24:	10bfffcc 	andi	r2,r2,65535
81142b28:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+24, record->last_modified_date);
81142b2c:	d0a0b317 	ldw	r2,-32052(gp)
81142b30:	10c00a17 	ldw	r3,40(r2)
81142b34:	e0bffe17 	ldw	r2,-8(fp)
81142b38:	1885883a 	add	r2,r3,r2
81142b3c:	10800604 	addi	r2,r2,24
81142b40:	1007883a 	mov	r3,r2
81142b44:	e0bfff17 	ldw	r2,-4(fp)
81142b48:	1080050b 	ldhu	r2,20(r2)
81142b4c:	10bfffcc 	andi	r2,r2,65535
81142b50:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+26, record->start_cluster_index);
81142b54:	d0a0b317 	ldw	r2,-32052(gp)
81142b58:	10c00a17 	ldw	r3,40(r2)
81142b5c:	e0bffe17 	ldw	r2,-8(fp)
81142b60:	1885883a 	add	r2,r3,r2
81142b64:	10800684 	addi	r2,r2,26
81142b68:	1007883a 	mov	r3,r2
81142b6c:	e0bfff17 	ldw	r2,-4(fp)
81142b70:	1080058b 	ldhu	r2,22(r2)
81142b74:	10bfffcc 	andi	r2,r2,65535
81142b78:	1880002d 	sthio	r2,0(r3)
        IOWR_32DIRECT(device_pointer->base, offset+28, record->file_size_in_bytes);
81142b7c:	d0a0b317 	ldw	r2,-32052(gp)
81142b80:	10c00a17 	ldw	r3,40(r2)
81142b84:	e0bffe17 	ldw	r2,-8(fp)
81142b88:	1885883a 	add	r2,r3,r2
81142b8c:	10800704 	addi	r2,r2,28
81142b90:	1007883a 	mov	r3,r2
81142b94:	e0bfff17 	ldw	r2,-4(fp)
81142b98:	10800617 	ldw	r2,24(r2)
81142b9c:	18800035 	stwio	r2,0(r3)
        current_sector_modified = true;                  
81142ba0:	00800044 	movi	r2,1
81142ba4:	d0a0b415 	stw	r2,-32048(gp)
        result = true;
81142ba8:	00800044 	movi	r2,1
81142bac:	e0bffb15 	stw	r2,-20(fp)
    }
    return result;
81142bb0:	e0bffb17 	ldw	r2,-20(fp)
}
81142bb4:	e037883a 	mov	sp,fp
81142bb8:	dfc00117 	ldw	ra,4(sp)
81142bbc:	df000017 	ldw	fp,0(sp)
81142bc0:	dec00204 	addi	sp,sp,8
81142bc4:	f800283a 	ret

81142bc8 <Check_for_DOS_FAT>:
// This function reads the boot sector for the FAT file system on the SD Card.
// The offset_address should point to the sector on the card where the boot sector is located.
// The sector number is specified either in the master Boot Record, or is 0 by default for a purely FAT
// based file system. If the specified sector contains a FAT boot sector, then this function prints the
// relevant information and returns 1. Otherwise, it returns 0. 
{
81142bc8:	defff904 	addi	sp,sp,-28
81142bcc:	de00012e 	bgeu	sp,et,81142bd4 <Check_for_DOS_FAT+0xc>
81142bd0:	003b68fa 	trap	3
81142bd4:	dfc00615 	stw	ra,24(sp)
81142bd8:	df000515 	stw	fp,20(sp)
81142bdc:	df000504 	addi	fp,sp,20
81142be0:	e13fff15 	stw	r4,-4(fp)
	bool result = false;
81142be4:	e03ffb15 	stw	zero,-20(fp)
	int counter = 0;
81142be8:	e03ffc15 	stw	zero,-16(fp)
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
81142bec:	e17fff17 	ldw	r5,-4(fp)
81142bf0:	0009883a 	mov	r4,zero
81142bf4:	11422800 	call	81142280 <Read_Sector_Data>
81142bf8:	e0bffb15 	stw	r2,-20(fp)
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
81142bfc:	d0a0b317 	ldw	r2,-32052(gp)
81142c00:	10800a17 	ldw	r2,40(r2)
81142c04:	10807f84 	addi	r2,r2,510
81142c08:	1080002b 	ldhuio	r2,0(r2)
81142c0c:	10bfffcc 	andi	r2,r2,65535
81142c10:	e0bffe0d 	sth	r2,-8(fp)
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
81142c14:	e0bffe0f 	ldh	r2,-8(fp)
81142c18:	10ffffcc 	andi	r3,r2,65535
81142c1c:	00aa9554 	movui	r2,43605
81142c20:	1881841e 	bne	r3,r2,81143234 <Check_for_DOS_FAT+0x66c>
81142c24:	e0bffb17 	ldw	r2,-20(fp)
81142c28:	10018226 	beq	r2,zero,81143234 <Check_for_DOS_FAT+0x66c>
	{
		int num_clusters = 0;
81142c2c:	e03ffd15 	stw	zero,-12(fp)

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
81142c30:	d0a0b317 	ldw	r2,-32052(gp)
81142c34:	10800a17 	ldw	r2,40(r2)
81142c38:	10800023 	ldbuio	r2,0(r2)
81142c3c:	10803fcc 	andi	r2,r2,255
81142c40:	1007883a 	mov	r3,r2
81142c44:	00a045f4 	movhi	r2,33047
81142c48:	10b44904 	addi	r2,r2,-11996
81142c4c:	10c00005 	stb	r3,0(r2)
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
81142c50:	d0a0b317 	ldw	r2,-32052(gp)
81142c54:	10800a17 	ldw	r2,40(r2)
81142c58:	10800044 	addi	r2,r2,1
81142c5c:	10800023 	ldbuio	r2,0(r2)
81142c60:	10803fcc 	andi	r2,r2,255
81142c64:	1007883a 	mov	r3,r2
81142c68:	00a045f4 	movhi	r2,33047
81142c6c:	10b44904 	addi	r2,r2,-11996
81142c70:	10c00045 	stb	r3,1(r2)
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
81142c74:	d0a0b317 	ldw	r2,-32052(gp)
81142c78:	10800a17 	ldw	r2,40(r2)
81142c7c:	10800084 	addi	r2,r2,2
81142c80:	10800023 	ldbuio	r2,0(r2)
81142c84:	10803fcc 	andi	r2,r2,255
81142c88:	1007883a 	mov	r3,r2
81142c8c:	00a045f4 	movhi	r2,33047
81142c90:	10b44904 	addi	r2,r2,-11996
81142c94:	10c00085 	stb	r3,2(r2)
		for (counter = 0; counter < 8; counter++)
81142c98:	e03ffc15 	stw	zero,-16(fp)
81142c9c:	00001106 	br	81142ce4 <Check_for_DOS_FAT+0x11c>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
81142ca0:	d0a0b317 	ldw	r2,-32052(gp)
81142ca4:	10c00a17 	ldw	r3,40(r2)
81142ca8:	e0bffc17 	ldw	r2,-16(fp)
81142cac:	1885883a 	add	r2,r3,r2
81142cb0:	108000c4 	addi	r2,r2,3
81142cb4:	10800023 	ldbuio	r2,0(r2)
81142cb8:	10803fcc 	andi	r2,r2,255
81142cbc:	1009883a 	mov	r4,r2
81142cc0:	00a045f4 	movhi	r2,33047
81142cc4:	10b44904 	addi	r2,r2,-11996
81142cc8:	e0fffc17 	ldw	r3,-16(fp)
81142ccc:	10c5883a 	add	r2,r2,r3
81142cd0:	108000c4 	addi	r2,r2,3
81142cd4:	11000005 	stb	r4,0(r2)
		int num_clusters = 0;

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
		for (counter = 0; counter < 8; counter++)
81142cd8:	e0bffc17 	ldw	r2,-16(fp)
81142cdc:	10800044 	addi	r2,r2,1
81142ce0:	e0bffc15 	stw	r2,-16(fp)
81142ce4:	e0bffc17 	ldw	r2,-16(fp)
81142ce8:	10800210 	cmplti	r2,r2,8
81142cec:	103fec1e 	bne	r2,zero,81142ca0 <__reset+0xfb122ca0>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
		}
		boot_sector_data.sector_size_in_bytes = (((unsigned char) IORD_8DIRECT(device_pointer->base, 12)) << 8 ) | ((char) IORD_8DIRECT(device_pointer->base, 11));
81142cf0:	d0a0b317 	ldw	r2,-32052(gp)
81142cf4:	10800a17 	ldw	r2,40(r2)
81142cf8:	10800304 	addi	r2,r2,12
81142cfc:	10800023 	ldbuio	r2,0(r2)
81142d00:	10803fcc 	andi	r2,r2,255
81142d04:	1004923a 	slli	r2,r2,8
81142d08:	1007883a 	mov	r3,r2
81142d0c:	d0a0b317 	ldw	r2,-32052(gp)
81142d10:	10800a17 	ldw	r2,40(r2)
81142d14:	108002c4 	addi	r2,r2,11
81142d18:	10800023 	ldbuio	r2,0(r2)
81142d1c:	10803fcc 	andi	r2,r2,255
81142d20:	10803fcc 	andi	r2,r2,255
81142d24:	1080201c 	xori	r2,r2,128
81142d28:	10bfe004 	addi	r2,r2,-128
81142d2c:	1884b03a 	or	r2,r3,r2
81142d30:	1007883a 	mov	r3,r2
81142d34:	00a045f4 	movhi	r2,33047
81142d38:	10b44904 	addi	r2,r2,-11996
81142d3c:	10c0030d 	sth	r3,12(r2)
		boot_sector_data.sectors_per_cluster = ((unsigned char) IORD_8DIRECT(device_pointer->base, 13));
81142d40:	d0a0b317 	ldw	r2,-32052(gp)
81142d44:	10800a17 	ldw	r2,40(r2)
81142d48:	10800344 	addi	r2,r2,13
81142d4c:	10800023 	ldbuio	r2,0(r2)
81142d50:	10803fcc 	andi	r2,r2,255
81142d54:	1007883a 	mov	r3,r2
81142d58:	00a045f4 	movhi	r2,33047
81142d5c:	10b44904 	addi	r2,r2,-11996
81142d60:	10c00385 	stb	r3,14(r2)
		boot_sector_data.reserved_sectors = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 14));
81142d64:	d0a0b317 	ldw	r2,-32052(gp)
81142d68:	10800a17 	ldw	r2,40(r2)
81142d6c:	10800384 	addi	r2,r2,14
81142d70:	1080002b 	ldhuio	r2,0(r2)
81142d74:	10bfffcc 	andi	r2,r2,65535
81142d78:	1007883a 	mov	r3,r2
81142d7c:	00a045f4 	movhi	r2,33047
81142d80:	10b44904 	addi	r2,r2,-11996
81142d84:	10c0040d 	sth	r3,16(r2)
		boot_sector_data.number_of_FATs = ((unsigned char) IORD_8DIRECT(device_pointer->base, 16));
81142d88:	d0a0b317 	ldw	r2,-32052(gp)
81142d8c:	10800a17 	ldw	r2,40(r2)
81142d90:	10800404 	addi	r2,r2,16
81142d94:	10800023 	ldbuio	r2,0(r2)
81142d98:	10803fcc 	andi	r2,r2,255
81142d9c:	1007883a 	mov	r3,r2
81142da0:	00a045f4 	movhi	r2,33047
81142da4:	10b44904 	addi	r2,r2,-11996
81142da8:	10c00485 	stb	r3,18(r2)
		boot_sector_data.max_number_of_dir_entires = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 18)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 17));
81142dac:	d0a0b317 	ldw	r2,-32052(gp)
81142db0:	10800a17 	ldw	r2,40(r2)
81142db4:	10800484 	addi	r2,r2,18
81142db8:	10800023 	ldbuio	r2,0(r2)
81142dbc:	10803fcc 	andi	r2,r2,255
81142dc0:	1004923a 	slli	r2,r2,8
81142dc4:	1007883a 	mov	r3,r2
81142dc8:	d0a0b317 	ldw	r2,-32052(gp)
81142dcc:	10800a17 	ldw	r2,40(r2)
81142dd0:	10800444 	addi	r2,r2,17
81142dd4:	10800023 	ldbuio	r2,0(r2)
81142dd8:	10803fcc 	andi	r2,r2,255
81142ddc:	10803fcc 	andi	r2,r2,255
81142de0:	1884b03a 	or	r2,r3,r2
81142de4:	1007883a 	mov	r3,r2
81142de8:	00a045f4 	movhi	r2,33047
81142dec:	10b44904 	addi	r2,r2,-11996
81142df0:	10c0050d 	sth	r3,20(r2)
		boot_sector_data.number_of_sectors_in_partition = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 20)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 19));
81142df4:	d0a0b317 	ldw	r2,-32052(gp)
81142df8:	10800a17 	ldw	r2,40(r2)
81142dfc:	10800504 	addi	r2,r2,20
81142e00:	10800023 	ldbuio	r2,0(r2)
81142e04:	10803fcc 	andi	r2,r2,255
81142e08:	1004923a 	slli	r2,r2,8
81142e0c:	1007883a 	mov	r3,r2
81142e10:	d0a0b317 	ldw	r2,-32052(gp)
81142e14:	10800a17 	ldw	r2,40(r2)
81142e18:	108004c4 	addi	r2,r2,19
81142e1c:	10800023 	ldbuio	r2,0(r2)
81142e20:	10803fcc 	andi	r2,r2,255
81142e24:	10803fcc 	andi	r2,r2,255
81142e28:	1884b03a 	or	r2,r3,r2
81142e2c:	1007883a 	mov	r3,r2
81142e30:	00a045f4 	movhi	r2,33047
81142e34:	10b44904 	addi	r2,r2,-11996
81142e38:	10c0058d 	sth	r3,22(r2)
		boot_sector_data.media_descriptor = ((unsigned char) IORD_8DIRECT(device_pointer->base, 21));
81142e3c:	d0a0b317 	ldw	r2,-32052(gp)
81142e40:	10800a17 	ldw	r2,40(r2)
81142e44:	10800544 	addi	r2,r2,21
81142e48:	10800023 	ldbuio	r2,0(r2)
81142e4c:	10803fcc 	andi	r2,r2,255
81142e50:	1007883a 	mov	r3,r2
81142e54:	00a045f4 	movhi	r2,33047
81142e58:	10b44904 	addi	r2,r2,-11996
81142e5c:	10c00605 	stb	r3,24(r2)
		boot_sector_data.number_of_sectors_per_table = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 22));
81142e60:	d0a0b317 	ldw	r2,-32052(gp)
81142e64:	10800a17 	ldw	r2,40(r2)
81142e68:	10800584 	addi	r2,r2,22
81142e6c:	1080002b 	ldhuio	r2,0(r2)
81142e70:	10bfffcc 	andi	r2,r2,65535
81142e74:	1007883a 	mov	r3,r2
81142e78:	00a045f4 	movhi	r2,33047
81142e7c:	10b44904 	addi	r2,r2,-11996
81142e80:	10c0068d 	sth	r3,26(r2)
		boot_sector_data.number_of_sectors_per_track = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 24));
81142e84:	d0a0b317 	ldw	r2,-32052(gp)
81142e88:	10800a17 	ldw	r2,40(r2)
81142e8c:	10800604 	addi	r2,r2,24
81142e90:	1080002b 	ldhuio	r2,0(r2)
81142e94:	10bfffcc 	andi	r2,r2,65535
81142e98:	1007883a 	mov	r3,r2
81142e9c:	00a045f4 	movhi	r2,33047
81142ea0:	10b44904 	addi	r2,r2,-11996
81142ea4:	10c0070d 	sth	r3,28(r2)
		boot_sector_data.number_of_heads = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 26));
81142ea8:	d0a0b317 	ldw	r2,-32052(gp)
81142eac:	10800a17 	ldw	r2,40(r2)
81142eb0:	10800684 	addi	r2,r2,26
81142eb4:	1080002b 	ldhuio	r2,0(r2)
81142eb8:	10bfffcc 	andi	r2,r2,65535
81142ebc:	1007883a 	mov	r3,r2
81142ec0:	00a045f4 	movhi	r2,33047
81142ec4:	10b44904 	addi	r2,r2,-11996
81142ec8:	10c0078d 	sth	r3,30(r2)
		boot_sector_data.number_of_hidden_sectors = ((unsigned int) IORD_32DIRECT(device_pointer->base, 28));
81142ecc:	d0a0b317 	ldw	r2,-32052(gp)
81142ed0:	10800a17 	ldw	r2,40(r2)
81142ed4:	10800704 	addi	r2,r2,28
81142ed8:	10800037 	ldwio	r2,0(r2)
81142edc:	1007883a 	mov	r3,r2
81142ee0:	00a045f4 	movhi	r2,33047
81142ee4:	10b44904 	addi	r2,r2,-11996
81142ee8:	10c00815 	stw	r3,32(r2)
		boot_sector_data.total_sector_count_if_above_32MB = ((unsigned int) IORD_32DIRECT(device_pointer->base, 32));
81142eec:	d0a0b317 	ldw	r2,-32052(gp)
81142ef0:	10800a17 	ldw	r2,40(r2)
81142ef4:	10800804 	addi	r2,r2,32
81142ef8:	10800037 	ldwio	r2,0(r2)
81142efc:	1007883a 	mov	r3,r2
81142f00:	00a045f4 	movhi	r2,33047
81142f04:	10b44904 	addi	r2,r2,-11996
81142f08:	10c00915 	stw	r3,36(r2)
		boot_sector_data.drive_number = ((unsigned char) IORD_8DIRECT(device_pointer->base, 36));
81142f0c:	d0a0b317 	ldw	r2,-32052(gp)
81142f10:	10800a17 	ldw	r2,40(r2)
81142f14:	10800904 	addi	r2,r2,36
81142f18:	10800023 	ldbuio	r2,0(r2)
81142f1c:	10803fcc 	andi	r2,r2,255
81142f20:	1007883a 	mov	r3,r2
81142f24:	00a045f4 	movhi	r2,33047
81142f28:	10b44904 	addi	r2,r2,-11996
81142f2c:	10c00a05 	stb	r3,40(r2)
		boot_sector_data.current_head = ((unsigned char) IORD_8DIRECT(device_pointer->base, 37));
81142f30:	d0a0b317 	ldw	r2,-32052(gp)
81142f34:	10800a17 	ldw	r2,40(r2)
81142f38:	10800944 	addi	r2,r2,37
81142f3c:	10800023 	ldbuio	r2,0(r2)
81142f40:	10803fcc 	andi	r2,r2,255
81142f44:	1007883a 	mov	r3,r2
81142f48:	00a045f4 	movhi	r2,33047
81142f4c:	10b44904 	addi	r2,r2,-11996
81142f50:	10c00a45 	stb	r3,41(r2)
		boot_sector_data.boot_signature = ((unsigned char) IORD_8DIRECT(device_pointer->base, 38));
81142f54:	d0a0b317 	ldw	r2,-32052(gp)
81142f58:	10800a17 	ldw	r2,40(r2)
81142f5c:	10800984 	addi	r2,r2,38
81142f60:	10800023 	ldbuio	r2,0(r2)
81142f64:	10803fcc 	andi	r2,r2,255
81142f68:	1007883a 	mov	r3,r2
81142f6c:	00a045f4 	movhi	r2,33047
81142f70:	10b44904 	addi	r2,r2,-11996
81142f74:	10c00a85 	stb	r3,42(r2)
		boot_sector_data.first_fat_sector_offset = boot_sector_data.reserved_sectors;
81142f78:	00a045f4 	movhi	r2,33047
81142f7c:	10b44904 	addi	r2,r2,-11996
81142f80:	1080040b 	ldhu	r2,16(r2)
81142f84:	10ffffcc 	andi	r3,r2,65535
81142f88:	00a045f4 	movhi	r2,33047
81142f8c:	10b44904 	addi	r2,r2,-11996
81142f90:	10c01115 	stw	r3,68(r2)
		boot_sector_data.second_fat_sector_offset = boot_sector_data.first_fat_sector_offset + boot_sector_data.number_of_sectors_per_table;
81142f94:	00a045f4 	movhi	r2,33047
81142f98:	10b44904 	addi	r2,r2,-11996
81142f9c:	10c01117 	ldw	r3,68(r2)
81142fa0:	00a045f4 	movhi	r2,33047
81142fa4:	10b44904 	addi	r2,r2,-11996
81142fa8:	1080068b 	ldhu	r2,26(r2)
81142fac:	10bfffcc 	andi	r2,r2,65535
81142fb0:	1887883a 	add	r3,r3,r2
81142fb4:	00a045f4 	movhi	r2,33047
81142fb8:	10b44904 	addi	r2,r2,-11996
81142fbc:	10c01215 	stw	r3,72(r2)
		boot_sector_data.root_directory_sector_offset = boot_sector_data.second_fat_sector_offset + boot_sector_data.number_of_sectors_per_table; 
81142fc0:	00a045f4 	movhi	r2,33047
81142fc4:	10b44904 	addi	r2,r2,-11996
81142fc8:	10c01217 	ldw	r3,72(r2)
81142fcc:	00a045f4 	movhi	r2,33047
81142fd0:	10b44904 	addi	r2,r2,-11996
81142fd4:	1080068b 	ldhu	r2,26(r2)
81142fd8:	10bfffcc 	andi	r2,r2,65535
81142fdc:	1887883a 	add	r3,r3,r2
81142fe0:	00a045f4 	movhi	r2,33047
81142fe4:	10b44904 	addi	r2,r2,-11996
81142fe8:	10c01315 	stw	r3,76(r2)
		boot_sector_data.data_sector_offset = boot_sector_data.root_directory_sector_offset + (32*boot_sector_data.max_number_of_dir_entires / boot_sector_data.sector_size_in_bytes);    
81142fec:	00a045f4 	movhi	r2,33047
81142ff0:	10b44904 	addi	r2,r2,-11996
81142ff4:	10c01317 	ldw	r3,76(r2)
81142ff8:	00a045f4 	movhi	r2,33047
81142ffc:	10b44904 	addi	r2,r2,-11996
81143000:	1080050b 	ldhu	r2,20(r2)
81143004:	10bfffcc 	andi	r2,r2,65535
81143008:	1008917a 	slli	r4,r2,5
8114300c:	00a045f4 	movhi	r2,33047
81143010:	10b44904 	addi	r2,r2,-11996
81143014:	1080030b 	ldhu	r2,12(r2)
81143018:	10bfffcc 	andi	r2,r2,65535
8114301c:	2085283a 	div	r2,r4,r2
81143020:	1887883a 	add	r3,r3,r2
81143024:	00a045f4 	movhi	r2,33047
81143028:	10b44904 	addi	r2,r2,-11996
8114302c:	10c01415 	stw	r3,80(r2)
	    
		if (boot_sector_data.number_of_sectors_in_partition > 0)
81143030:	00a045f4 	movhi	r2,33047
81143034:	10b44904 	addi	r2,r2,-11996
81143038:	1080058b 	ldhu	r2,22(r2)
8114303c:	10bfffcc 	andi	r2,r2,65535
81143040:	10000b26 	beq	r2,zero,81143070 <Check_for_DOS_FAT+0x4a8>
		{
			num_clusters = (boot_sector_data.number_of_sectors_in_partition / boot_sector_data.sectors_per_cluster);
81143044:	00a045f4 	movhi	r2,33047
81143048:	10b44904 	addi	r2,r2,-11996
8114304c:	1080058b 	ldhu	r2,22(r2)
81143050:	10ffffcc 	andi	r3,r2,65535
81143054:	00a045f4 	movhi	r2,33047
81143058:	10b44904 	addi	r2,r2,-11996
8114305c:	10800383 	ldbu	r2,14(r2)
81143060:	10803fcc 	andi	r2,r2,255
81143064:	1885283a 	div	r2,r3,r2
81143068:	e0bffd15 	stw	r2,-12(fp)
8114306c:	00000906 	br	81143094 <Check_for_DOS_FAT+0x4cc>
		}
		else
		{
			num_clusters = (boot_sector_data.total_sector_count_if_above_32MB / boot_sector_data.sectors_per_cluster);
81143070:	00a045f4 	movhi	r2,33047
81143074:	10b44904 	addi	r2,r2,-11996
81143078:	10c00917 	ldw	r3,36(r2)
8114307c:	00a045f4 	movhi	r2,33047
81143080:	10b44904 	addi	r2,r2,-11996
81143084:	10800383 	ldbu	r2,14(r2)
81143088:	10803fcc 	andi	r2,r2,255
8114308c:	1885203a 	divu	r2,r3,r2
81143090:	e0bffd15 	stw	r2,-12(fp)
		}
		if (num_clusters < 4087)
81143094:	e0bffd17 	ldw	r2,-12(fp)
81143098:	1083fdc8 	cmpgei	r2,r2,4087
8114309c:	1000051e 	bne	r2,zero,811430b4 <Check_for_DOS_FAT+0x4ec>
		{
			boot_sector_data.bits_for_cluster_index = 12;
811430a0:	00a045f4 	movhi	r2,33047
811430a4:	10b44904 	addi	r2,r2,-11996
811430a8:	00c00304 	movi	r3,12
811430ac:	10c01085 	stb	r3,66(r2)
811430b0:	00000c06 	br	811430e4 <Check_for_DOS_FAT+0x51c>
		}
		else if (num_clusters <= 65517)
811430b4:	e0bffd17 	ldw	r2,-12(fp)
811430b8:	00fffb54 	movui	r3,65517
811430bc:	18800516 	blt	r3,r2,811430d4 <Check_for_DOS_FAT+0x50c>
		{
			boot_sector_data.bits_for_cluster_index = 16;
811430c0:	00a045f4 	movhi	r2,33047
811430c4:	10b44904 	addi	r2,r2,-11996
811430c8:	00c00404 	movi	r3,16
811430cc:	10c01085 	stb	r3,66(r2)
811430d0:	00000406 	br	811430e4 <Check_for_DOS_FAT+0x51c>
		}
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
811430d4:	00a045f4 	movhi	r2,33047
811430d8:	10b44904 	addi	r2,r2,-11996
811430dc:	00c00804 	movi	r3,32
811430e0:	10c01085 	stb	r3,66(r2)
		}
	    
		for (counter = 0; counter < 4; counter++)
811430e4:	e03ffc15 	stw	zero,-16(fp)
811430e8:	00001106 	br	81143130 <Check_for_DOS_FAT+0x568>
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
811430ec:	d0a0b317 	ldw	r2,-32052(gp)
811430f0:	10c00a17 	ldw	r3,40(r2)
811430f4:	e0bffc17 	ldw	r2,-16(fp)
811430f8:	1885883a 	add	r2,r3,r2
811430fc:	108009c4 	addi	r2,r2,39
81143100:	10800023 	ldbuio	r2,0(r2)
81143104:	10803fcc 	andi	r2,r2,255
81143108:	1009883a 	mov	r4,r2
8114310c:	00a045f4 	movhi	r2,33047
81143110:	10b44904 	addi	r2,r2,-11996
81143114:	e0fffc17 	ldw	r3,-16(fp)
81143118:	10c5883a 	add	r2,r2,r3
8114311c:	10800ac4 	addi	r2,r2,43
81143120:	11000005 	stb	r4,0(r2)
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
		}
	    
		for (counter = 0; counter < 4; counter++)
81143124:	e0bffc17 	ldw	r2,-16(fp)
81143128:	10800044 	addi	r2,r2,1
8114312c:	e0bffc15 	stw	r2,-16(fp)
81143130:	e0bffc17 	ldw	r2,-16(fp)
81143134:	10800110 	cmplti	r2,r2,4
81143138:	103fec1e 	bne	r2,zero,811430ec <__reset+0xfb1230ec>
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
8114313c:	e03ffc15 	stw	zero,-16(fp)
81143140:	00001106 	br	81143188 <Check_for_DOS_FAT+0x5c0>
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
81143144:	d0a0b317 	ldw	r2,-32052(gp)
81143148:	10c00a17 	ldw	r3,40(r2)
8114314c:	e0bffc17 	ldw	r2,-16(fp)
81143150:	1885883a 	add	r2,r3,r2
81143154:	10800ac4 	addi	r2,r2,43
81143158:	10800023 	ldbuio	r2,0(r2)
8114315c:	10803fcc 	andi	r2,r2,255
81143160:	1009883a 	mov	r4,r2
81143164:	00a045f4 	movhi	r2,33047
81143168:	10b44904 	addi	r2,r2,-11996
8114316c:	e0fffc17 	ldw	r3,-16(fp)
81143170:	10c5883a 	add	r2,r2,r3
81143174:	10800bc4 	addi	r2,r2,47
81143178:	11000005 	stb	r4,0(r2)
	    
		for (counter = 0; counter < 4; counter++)
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
8114317c:	e0bffc17 	ldw	r2,-16(fp)
81143180:	10800044 	addi	r2,r2,1
81143184:	e0bffc15 	stw	r2,-16(fp)
81143188:	e0bffc17 	ldw	r2,-16(fp)
8114318c:	108002d0 	cmplti	r2,r2,11
81143190:	103fec1e 	bne	r2,zero,81143144 <__reset+0xfb123144>
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
81143194:	e03ffc15 	stw	zero,-16(fp)
81143198:	00001106 	br	811431e0 <Check_for_DOS_FAT+0x618>
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
8114319c:	d0a0b317 	ldw	r2,-32052(gp)
811431a0:	10c00a17 	ldw	r3,40(r2)
811431a4:	e0bffc17 	ldw	r2,-16(fp)
811431a8:	1885883a 	add	r2,r3,r2
811431ac:	10800d84 	addi	r2,r2,54
811431b0:	10800023 	ldbuio	r2,0(r2)
811431b4:	10803fcc 	andi	r2,r2,255
811431b8:	1009883a 	mov	r4,r2
811431bc:	00a045f4 	movhi	r2,33047
811431c0:	10b44904 	addi	r2,r2,-11996
811431c4:	e0fffc17 	ldw	r3,-16(fp)
811431c8:	10c5883a 	add	r2,r2,r3
811431cc:	10800e84 	addi	r2,r2,58
811431d0:	11000005 	stb	r4,0(r2)
		}    
		for (counter = 0; counter < 11; counter++)
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
811431d4:	e0bffc17 	ldw	r2,-16(fp)
811431d8:	10800044 	addi	r2,r2,1
811431dc:	e0bffc15 	stw	r2,-16(fp)
811431e0:	e0bffc17 	ldw	r2,-16(fp)
811431e4:	10800210 	cmplti	r2,r2,8
811431e8:	103fec1e 	bne	r2,zero,8114319c <__reset+0xfb12319c>
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
811431ec:	e03ffc15 	stw	zero,-16(fp)
811431f0:	00000a06 	br	8114321c <Check_for_DOS_FAT+0x654>
		{
			active_files[counter].in_use = false;
811431f4:	00a045f4 	movhi	r2,33047
811431f8:	10b45e04 	addi	r2,r2,-11912
811431fc:	e0fffc17 	ldw	r3,-16(fp)
81143200:	180691ba 	slli	r3,r3,6
81143204:	10c5883a 	add	r2,r2,r3
81143208:	10800f04 	addi	r2,r2,60
8114320c:	10000015 	stw	zero,0(r2)
		for (counter = 0; counter < 8; counter++)
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
81143210:	e0bffc17 	ldw	r2,-16(fp)
81143214:	10800044 	addi	r2,r2,1
81143218:	e0bffc15 	stw	r2,-16(fp)
8114321c:	e0bffc17 	ldw	r2,-16(fp)
81143220:	10800510 	cmplti	r2,r2,20
81143224:	103ff31e 	bne	r2,zero,811431f4 <__reset+0xfb1231f4>
		{
			active_files[counter].in_use = false;
		}
		result = true;
81143228:	00800044 	movi	r2,1
8114322c:	e0bffb15 	stw	r2,-20(fp)
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
	{
81143230:	00000106 	br	81143238 <Check_for_DOS_FAT+0x670>
		}
		result = true;
	}
    else
    {
        result = false;
81143234:	e03ffb15 	stw	zero,-20(fp)
    }
	return result;
81143238:	e0bffb17 	ldw	r2,-20(fp)
}
8114323c:	e037883a 	mov	sp,fp
81143240:	dfc00117 	ldw	ra,4(sp)
81143244:	df000017 	ldw	fp,0(sp)
81143248:	dec00204 	addi	sp,sp,8
8114324c:	f800283a 	ret

81143250 <Look_for_FAT16>:


bool Look_for_FAT16(void)
// Read the SD card to determine if it contains a FAT16 partition.
{
81143250:	defffc04 	addi	sp,sp,-16
81143254:	de00012e 	bgeu	sp,et,8114325c <Look_for_FAT16+0xc>
81143258:	003b68fa 	trap	3
8114325c:	dfc00315 	stw	ra,12(sp)
81143260:	df000215 	stw	fp,8(sp)
81143264:	df000204 	addi	fp,sp,8
	bool result = false;
81143268:	e03ffe15 	stw	zero,-8(fp)

	if (alt_up_sd_card_is_Present())
8114326c:	1144f580 	call	81144f58 <alt_up_sd_card_is_Present>
81143270:	10002e26 	beq	r2,zero,8114332c <Look_for_FAT16+0xdc>
	{
		short int csd_file_format = *CSD_register_w0;
81143274:	d0a0ad17 	ldw	r2,-32076(gp)
81143278:	1080000b 	ldhu	r2,0(r2)
8114327c:	e0bfff0d 	sth	r2,-4(fp)
        
		fat_partition_offset_in_512_byte_sectors = 0;
81143280:	d020b115 	stw	zero,-32060(gp)
		fat_partition_size_in_512_byte_sectors = 0;              
81143284:	d020b215 	stw	zero,-32056(gp)

		if (((csd_file_format & 0x8000) == 0) && ((csd_file_format & 0x0c00) != 0x0c00))
81143288:	e0bfff0f 	ldh	r2,-4(fp)
8114328c:	10002716 	blt	r2,zero,8114332c <Look_for_FAT16+0xdc>
81143290:	e0bfff0b 	ldhu	r2,-4(fp)
81143294:	10bfffcc 	andi	r2,r2,65535
81143298:	1083000c 	andi	r2,r2,3072
8114329c:	10830020 	cmpeqi	r2,r2,3072
811432a0:	1000221e 	bne	r2,zero,8114332c <Look_for_FAT16+0xdc>
		{
			if ((csd_file_format & 0x0c00) == 0x0400)
811432a4:	e0bfff0b 	ldhu	r2,-4(fp)
811432a8:	10bfffcc 	andi	r2,r2,65535
811432ac:	1083000c 	andi	r2,r2,3072
811432b0:	10810018 	cmpnei	r2,r2,1024
811432b4:	1000031e 	bne	r2,zero,811432c4 <Look_for_FAT16+0x74>
			{
				/* SD Card contains files stored in a DOS FAT (floppy like) file format, without a partition table */
				result = Check_for_DOS_FAT(0);
811432b8:	0009883a 	mov	r4,zero
811432bc:	1142bc80 	call	81142bc8 <Check_for_DOS_FAT>
811432c0:	e0bffe15 	stw	r2,-8(fp)
			}
			if ((csd_file_format & 0x0c00) == 0x0000)
811432c4:	e0bfff0b 	ldhu	r2,-4(fp)
811432c8:	10bfffcc 	andi	r2,r2,65535
811432cc:	1083000c 	andi	r2,r2,3072
811432d0:	1000061e 	bne	r2,zero,811432ec <Look_for_FAT16+0x9c>
			{
				/* SD Card contains files stored in a Hard disk-like file format that contains a partition table */
				if (Check_for_Master_Boot_Record())
811432d4:	11425040 	call	81142504 <Check_for_Master_Boot_Record>
811432d8:	10000426 	beq	r2,zero,811432ec <Look_for_FAT16+0x9c>
				{
					result = Check_for_DOS_FAT(fat_partition_offset_in_512_byte_sectors);
811432dc:	d0a0b117 	ldw	r2,-32060(gp)
811432e0:	1009883a 	mov	r4,r2
811432e4:	1142bc80 	call	81142bc8 <Check_for_DOS_FAT>
811432e8:	e0bffe15 	stw	r2,-8(fp)
				}                        
			}
			if (result == true)
811432ec:	e0bffe17 	ldw	r2,-8(fp)
811432f0:	10800058 	cmpnei	r2,r2,1
811432f4:	10000d1e 	bne	r2,zero,8114332c <Look_for_FAT16+0xdc>
			{
				// Accept only FAT16, not FAT12.
				if (boot_sector_data.bits_for_cluster_index != 16)
811432f8:	00a045f4 	movhi	r2,33047
811432fc:	10b44904 	addi	r2,r2,-11996
81143300:	10801083 	ldbu	r2,66(r2)
81143304:	10803fcc 	andi	r2,r2,255
81143308:	10800420 	cmpeqi	r2,r2,16
8114330c:	1000021e 	bne	r2,zero,81143318 <Look_for_FAT16+0xc8>
				{
					result = false;
81143310:	e03ffe15 	stw	zero,-8(fp)
81143314:	00000506 	br	8114332c <Look_for_FAT16+0xdc>
				}
				else
				{
					fat_partition_size_in_512_byte_sectors = boot_sector_data.number_of_sectors_in_partition;
81143318:	00a045f4 	movhi	r2,33047
8114331c:	10b44904 	addi	r2,r2,-11996
81143320:	1080058b 	ldhu	r2,22(r2)
81143324:	10bfffcc 	andi	r2,r2,65535
81143328:	d0a0b215 	stw	r2,-32056(gp)
				}
			}
		}
	}
	return result;
8114332c:	e0bffe17 	ldw	r2,-8(fp)
}
81143330:	e037883a 	mov	sp,fp
81143334:	dfc00117 	ldw	ra,4(sp)
81143338:	df000017 	ldw	fp,0(sp)
8114333c:	dec00204 	addi	sp,sp,8
81143340:	f800283a 	ret

81143344 <filename_to_upper_case>:
 

void filename_to_upper_case(char *file_name)
// Change file name to upper case.
{
81143344:	defffb04 	addi	sp,sp,-20
81143348:	de00012e 	bgeu	sp,et,81143350 <filename_to_upper_case+0xc>
8114334c:	003b68fa 	trap	3
81143350:	dfc00415 	stw	ra,16(sp)
81143354:	df000315 	stw	fp,12(sp)
81143358:	df000304 	addi	fp,sp,12
8114335c:	e13fff15 	stw	r4,-4(fp)
    int index;
    int length = strlen(file_name);
81143360:	e13fff17 	ldw	r4,-4(fp)
81143364:	11231840 	call	81123184 <strlen>
81143368:	e0bffe15 	stw	r2,-8(fp)
    
    for (index = 0; index < length; index++)
8114336c:	e03ffd15 	stw	zero,-12(fp)
81143370:	00001e06 	br	811433ec <filename_to_upper_case+0xa8>
    {
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
81143374:	e0bffd17 	ldw	r2,-12(fp)
81143378:	e0ffff17 	ldw	r3,-4(fp)
8114337c:	1885883a 	add	r2,r3,r2
81143380:	10800003 	ldbu	r2,0(r2)
81143384:	10803fcc 	andi	r2,r2,255
81143388:	1080201c 	xori	r2,r2,128
8114338c:	10bfe004 	addi	r2,r2,-128
81143390:	10801850 	cmplti	r2,r2,97
81143394:	1000121e 	bne	r2,zero,811433e0 <filename_to_upper_case+0x9c>
81143398:	e0bffd17 	ldw	r2,-12(fp)
8114339c:	e0ffff17 	ldw	r3,-4(fp)
811433a0:	1885883a 	add	r2,r3,r2
811433a4:	10800003 	ldbu	r2,0(r2)
811433a8:	10803fcc 	andi	r2,r2,255
811433ac:	1080201c 	xori	r2,r2,128
811433b0:	10bfe004 	addi	r2,r2,-128
811433b4:	10801ec8 	cmpgei	r2,r2,123
811433b8:	1000091e 	bne	r2,zero,811433e0 <filename_to_upper_case+0x9c>
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
811433bc:	e0bffd17 	ldw	r2,-12(fp)
811433c0:	e0ffff17 	ldw	r3,-4(fp)
811433c4:	1885883a 	add	r2,r3,r2
811433c8:	e0fffd17 	ldw	r3,-12(fp)
811433cc:	e13fff17 	ldw	r4,-4(fp)
811433d0:	20c7883a 	add	r3,r4,r3
811433d4:	18c00003 	ldbu	r3,0(r3)
811433d8:	18fff804 	addi	r3,r3,-32
811433dc:	10c00005 	stb	r3,0(r2)
// Change file name to upper case.
{
    int index;
    int length = strlen(file_name);
    
    for (index = 0; index < length; index++)
811433e0:	e0bffd17 	ldw	r2,-12(fp)
811433e4:	10800044 	addi	r2,r2,1
811433e8:	e0bffd15 	stw	r2,-12(fp)
811433ec:	e0fffd17 	ldw	r3,-12(fp)
811433f0:	e0bffe17 	ldw	r2,-8(fp)
811433f4:	18bfdf16 	blt	r3,r2,81143374 <__reset+0xfb123374>
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
        }
    }
}
811433f8:	0001883a 	nop
811433fc:	e037883a 	mov	sp,fp
81143400:	dfc00117 	ldw	ra,4(sp)
81143404:	df000017 	ldw	fp,0(sp)
81143408:	dec00204 	addi	sp,sp,8
8114340c:	f800283a 	ret

81143410 <check_file_name_for_FAT16_compliance>:


bool check_file_name_for_FAT16_compliance(char *file_name)
// Check if the file complies with FAT16 naming convention.
{
81143410:	defff804 	addi	sp,sp,-32
81143414:	de00012e 	bgeu	sp,et,8114341c <check_file_name_for_FAT16_compliance+0xc>
81143418:	003b68fa 	trap	3
8114341c:	dfc00715 	stw	ra,28(sp)
81143420:	df000615 	stw	fp,24(sp)
81143424:	df000604 	addi	fp,sp,24
81143428:	e13fff15 	stw	r4,-4(fp)
    int length = strlen(file_name);
8114342c:	e13fff17 	ldw	r4,-4(fp)
81143430:	11231840 	call	81123184 <strlen>
81143434:	e0bffe15 	stw	r2,-8(fp)
    int index;
    int last_dir_break_position = -1;
81143438:	00bfffc4 	movi	r2,-1
8114343c:	e0bffb15 	stw	r2,-20(fp)
    int last_period = -1;
81143440:	00bfffc4 	movi	r2,-1
81143444:	e0bffc15 	stw	r2,-16(fp)
    bool result = true;
81143448:	00800044 	movi	r2,1
8114344c:	e0bffd15 	stw	r2,-12(fp)
    
    for(index = 0; index < length; index++)
81143450:	e03ffa15 	stw	zero,-24(fp)
81143454:	00006d06 	br	8114360c <check_file_name_for_FAT16_compliance+0x1fc>
    {
        if ((file_name[index] == ' ') ||
81143458:	e0bffa17 	ldw	r2,-24(fp)
8114345c:	e0ffff17 	ldw	r3,-4(fp)
81143460:	1885883a 	add	r2,r3,r2
81143464:	10800003 	ldbu	r2,0(r2)
81143468:	10803fcc 	andi	r2,r2,255
8114346c:	1080201c 	xori	r2,r2,128
81143470:	10bfe004 	addi	r2,r2,-128
81143474:	10800820 	cmpeqi	r2,r2,32
81143478:	10003e1e 	bne	r2,zero,81143574 <check_file_name_for_FAT16_compliance+0x164>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
8114347c:	e0bffa17 	ldw	r2,-24(fp)
81143480:	10ffffc4 	addi	r3,r2,-1
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
81143484:	e0bffb17 	ldw	r2,-20(fp)
81143488:	1880121e 	bne	r3,r2,811434d4 <check_file_name_for_FAT16_compliance+0xc4>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
8114348c:	e0bffa17 	ldw	r2,-24(fp)
81143490:	e0ffff17 	ldw	r3,-4(fp)
81143494:	1885883a 	add	r2,r3,r2
81143498:	10800003 	ldbu	r2,0(r2)
8114349c:	10803fcc 	andi	r2,r2,255
811434a0:	1080201c 	xori	r2,r2,128
811434a4:	10bfe004 	addi	r2,r2,-128
811434a8:	10801720 	cmpeqi	r2,r2,92
811434ac:	1000311e 	bne	r2,zero,81143574 <check_file_name_for_FAT16_compliance+0x164>
811434b0:	e0bffa17 	ldw	r2,-24(fp)
811434b4:	e0ffff17 	ldw	r3,-4(fp)
811434b8:	1885883a 	add	r2,r3,r2
811434bc:	10800003 	ldbu	r2,0(r2)
811434c0:	10803fcc 	andi	r2,r2,255
811434c4:	1080201c 	xori	r2,r2,128
811434c8:	10bfe004 	addi	r2,r2,-128
811434cc:	10800be0 	cmpeqi	r2,r2,47
811434d0:	1000281e 	bne	r2,zero,81143574 <check_file_name_for_FAT16_compliance+0x164>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
811434d4:	e0fffa17 	ldw	r3,-24(fp)
811434d8:	e0bffc17 	ldw	r2,-16(fp)
811434dc:	1885c83a 	sub	r2,r3,r2
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
811434e0:	10800258 	cmpnei	r2,r2,9
811434e4:	1000091e 	bne	r2,zero,8114350c <check_file_name_for_FAT16_compliance+0xfc>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
811434e8:	e0bffa17 	ldw	r2,-24(fp)
811434ec:	e0ffff17 	ldw	r3,-4(fp)
811434f0:	1885883a 	add	r2,r3,r2
811434f4:	10800003 	ldbu	r2,0(r2)
811434f8:	10803fcc 	andi	r2,r2,255
811434fc:	1080201c 	xori	r2,r2,128
81143500:	10bfe004 	addi	r2,r2,-128
81143504:	10800b98 	cmpnei	r2,r2,46
81143508:	10001a1e 	bne	r2,zero,81143574 <check_file_name_for_FAT16_compliance+0x164>
8114350c:	e0fffb17 	ldw	r3,-20(fp)
81143510:	e0bffc17 	ldw	r2,-16(fp)
81143514:	18801926 	beq	r3,r2,8114357c <check_file_name_for_FAT16_compliance+0x16c>
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
81143518:	e0fffa17 	ldw	r3,-24(fp)
8114351c:	e0bffc17 	ldw	r2,-16(fp)
81143520:	1885c83a 	sub	r2,r3,r2
81143524:	10800110 	cmplti	r2,r2,4
81143528:	1000141e 	bne	r2,zero,8114357c <check_file_name_for_FAT16_compliance+0x16c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
8114352c:	e0bffa17 	ldw	r2,-24(fp)
81143530:	e0ffff17 	ldw	r3,-4(fp)
81143534:	1885883a 	add	r2,r3,r2
81143538:	10800003 	ldbu	r2,0(r2)
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
            ((index - last_period == 9) && (file_name[index] != '.')) ||
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
8114353c:	10803fcc 	andi	r2,r2,255
81143540:	1080201c 	xori	r2,r2,128
81143544:	10bfe004 	addi	r2,r2,-128
81143548:	10801720 	cmpeqi	r2,r2,92
8114354c:	10000b1e 	bne	r2,zero,8114357c <check_file_name_for_FAT16_compliance+0x16c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
81143550:	e0bffa17 	ldw	r2,-24(fp)
81143554:	e0ffff17 	ldw	r3,-4(fp)
81143558:	1885883a 	add	r2,r3,r2
8114355c:	10800003 	ldbu	r2,0(r2)
81143560:	10803fcc 	andi	r2,r2,255
81143564:	1080201c 	xori	r2,r2,128
81143568:	10bfe004 	addi	r2,r2,-128
8114356c:	10800be0 	cmpeqi	r2,r2,47
81143570:	1000021e 	bne	r2,zero,8114357c <check_file_name_for_FAT16_compliance+0x16c>
           )
        {
            result = false;
81143574:	e03ffd15 	stw	zero,-12(fp)
            break;
81143578:	00002706 	br	81143618 <check_file_name_for_FAT16_compliance+0x208>
        }
        if ((file_name[index] == '\\') || (file_name[index] == '/'))
8114357c:	e0bffa17 	ldw	r2,-24(fp)
81143580:	e0ffff17 	ldw	r3,-4(fp)
81143584:	1885883a 	add	r2,r3,r2
81143588:	10800003 	ldbu	r2,0(r2)
8114358c:	10803fcc 	andi	r2,r2,255
81143590:	1080201c 	xori	r2,r2,128
81143594:	10bfe004 	addi	r2,r2,-128
81143598:	10801720 	cmpeqi	r2,r2,92
8114359c:	1000091e 	bne	r2,zero,811435c4 <check_file_name_for_FAT16_compliance+0x1b4>
811435a0:	e0bffa17 	ldw	r2,-24(fp)
811435a4:	e0ffff17 	ldw	r3,-4(fp)
811435a8:	1885883a 	add	r2,r3,r2
811435ac:	10800003 	ldbu	r2,0(r2)
811435b0:	10803fcc 	andi	r2,r2,255
811435b4:	1080201c 	xori	r2,r2,128
811435b8:	10bfe004 	addi	r2,r2,-128
811435bc:	10800bd8 	cmpnei	r2,r2,47
811435c0:	1000041e 	bne	r2,zero,811435d4 <check_file_name_for_FAT16_compliance+0x1c4>
        {
            last_period = index;
811435c4:	e0bffa17 	ldw	r2,-24(fp)
811435c8:	e0bffc15 	stw	r2,-16(fp)
            last_dir_break_position = index;
811435cc:	e0bffa17 	ldw	r2,-24(fp)
811435d0:	e0bffb15 	stw	r2,-20(fp)
        }
        if (file_name[index] == '.')
811435d4:	e0bffa17 	ldw	r2,-24(fp)
811435d8:	e0ffff17 	ldw	r3,-4(fp)
811435dc:	1885883a 	add	r2,r3,r2
811435e0:	10800003 	ldbu	r2,0(r2)
811435e4:	10803fcc 	andi	r2,r2,255
811435e8:	1080201c 	xori	r2,r2,128
811435ec:	10bfe004 	addi	r2,r2,-128
811435f0:	10800b98 	cmpnei	r2,r2,46
811435f4:	1000021e 	bne	r2,zero,81143600 <check_file_name_for_FAT16_compliance+0x1f0>
        {
            last_period = index;
811435f8:	e0bffa17 	ldw	r2,-24(fp)
811435fc:	e0bffc15 	stw	r2,-16(fp)
    int index;
    int last_dir_break_position = -1;
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
81143600:	e0bffa17 	ldw	r2,-24(fp)
81143604:	10800044 	addi	r2,r2,1
81143608:	e0bffa15 	stw	r2,-24(fp)
8114360c:	e0fffa17 	ldw	r3,-24(fp)
81143610:	e0bffe17 	ldw	r2,-8(fp)
81143614:	18bf9016 	blt	r3,r2,81143458 <__reset+0xfb123458>
        if (file_name[index] == '.')
        {
            last_period = index;
        }
    }
    if ((file_name[length-1] == '\\') || (file_name[length-1] == '/'))
81143618:	e0bffe17 	ldw	r2,-8(fp)
8114361c:	10bfffc4 	addi	r2,r2,-1
81143620:	e0ffff17 	ldw	r3,-4(fp)
81143624:	1885883a 	add	r2,r3,r2
81143628:	10800003 	ldbu	r2,0(r2)
8114362c:	10803fcc 	andi	r2,r2,255
81143630:	1080201c 	xori	r2,r2,128
81143634:	10bfe004 	addi	r2,r2,-128
81143638:	10801720 	cmpeqi	r2,r2,92
8114363c:	10000a1e 	bne	r2,zero,81143668 <check_file_name_for_FAT16_compliance+0x258>
81143640:	e0bffe17 	ldw	r2,-8(fp)
81143644:	10bfffc4 	addi	r2,r2,-1
81143648:	e0ffff17 	ldw	r3,-4(fp)
8114364c:	1885883a 	add	r2,r3,r2
81143650:	10800003 	ldbu	r2,0(r2)
81143654:	10803fcc 	andi	r2,r2,255
81143658:	1080201c 	xori	r2,r2,128
8114365c:	10bfe004 	addi	r2,r2,-128
81143660:	10800bd8 	cmpnei	r2,r2,47
81143664:	1000011e 	bne	r2,zero,8114366c <check_file_name_for_FAT16_compliance+0x25c>
    {
        result = false;
81143668:	e03ffd15 	stw	zero,-12(fp)
    }
    return result;
8114366c:	e0bffd17 	ldw	r2,-12(fp)
}
81143670:	e037883a 	mov	sp,fp
81143674:	dfc00117 	ldw	ra,4(sp)
81143678:	df000017 	ldw	fp,0(sp)
8114367c:	dec00204 	addi	sp,sp,8
81143680:	f800283a 	ret

81143684 <get_dir_divider_location>:


int get_dir_divider_location(char *name)
// Find a directory divider location.
{
81143684:	defffb04 	addi	sp,sp,-20
81143688:	de00012e 	bgeu	sp,et,81143690 <get_dir_divider_location+0xc>
8114368c:	003b68fa 	trap	3
81143690:	dfc00415 	stw	ra,16(sp)
81143694:	df000315 	stw	fp,12(sp)
81143698:	df000304 	addi	fp,sp,12
8114369c:	e13fff15 	stw	r4,-4(fp)
    int index = 0;
811436a0:	e03ffd15 	stw	zero,-12(fp)
    int length = strlen(name);
811436a4:	e13fff17 	ldw	r4,-4(fp)
811436a8:	11231840 	call	81123184 <strlen>
811436ac:	e0bffe15 	stw	r2,-8(fp)
    
    for(index = 0; index < length; index++)
811436b0:	e03ffd15 	stw	zero,-12(fp)
811436b4:	00001506 	br	8114370c <get_dir_divider_location+0x88>
    {
        if ((name[index] == '\\') || (name[index] == '/'))
811436b8:	e0bffd17 	ldw	r2,-12(fp)
811436bc:	e0ffff17 	ldw	r3,-4(fp)
811436c0:	1885883a 	add	r2,r3,r2
811436c4:	10800003 	ldbu	r2,0(r2)
811436c8:	10803fcc 	andi	r2,r2,255
811436cc:	1080201c 	xori	r2,r2,128
811436d0:	10bfe004 	addi	r2,r2,-128
811436d4:	10801720 	cmpeqi	r2,r2,92
811436d8:	10000f1e 	bne	r2,zero,81143718 <get_dir_divider_location+0x94>
811436dc:	e0bffd17 	ldw	r2,-12(fp)
811436e0:	e0ffff17 	ldw	r3,-4(fp)
811436e4:	1885883a 	add	r2,r3,r2
811436e8:	10800003 	ldbu	r2,0(r2)
811436ec:	10803fcc 	andi	r2,r2,255
811436f0:	1080201c 	xori	r2,r2,128
811436f4:	10bfe004 	addi	r2,r2,-128
811436f8:	10800be0 	cmpeqi	r2,r2,47
811436fc:	1000061e 	bne	r2,zero,81143718 <get_dir_divider_location+0x94>
// Find a directory divider location.
{
    int index = 0;
    int length = strlen(name);
    
    for(index = 0; index < length; index++)
81143700:	e0bffd17 	ldw	r2,-12(fp)
81143704:	10800044 	addi	r2,r2,1
81143708:	e0bffd15 	stw	r2,-12(fp)
8114370c:	e0fffd17 	ldw	r3,-12(fp)
81143710:	e0bffe17 	ldw	r2,-8(fp)
81143714:	18bfe816 	blt	r3,r2,811436b8 <__reset+0xfb1236b8>
        {
            break;
        }
    }
    
    if (index == length)
81143718:	e0fffd17 	ldw	r3,-12(fp)
8114371c:	e0bffe17 	ldw	r2,-8(fp)
81143720:	1880021e 	bne	r3,r2,8114372c <get_dir_divider_location+0xa8>
    {
        index = -1;
81143724:	00bfffc4 	movi	r2,-1
81143728:	e0bffd15 	stw	r2,-12(fp)
    }
    
    return index;
8114372c:	e0bffd17 	ldw	r2,-12(fp)
}
81143730:	e037883a 	mov	sp,fp
81143734:	dfc00117 	ldw	ra,4(sp)
81143738:	df000017 	ldw	fp,0(sp)
8114373c:	dec00204 	addi	sp,sp,8
81143740:	f800283a 	ret

81143744 <match_file_record_to_name_ext>:


bool match_file_record_to_name_ext(t_file_record *file_record, char *name, char *extension)
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
81143744:	defffa04 	addi	sp,sp,-24
81143748:	de00012e 	bgeu	sp,et,81143750 <match_file_record_to_name_ext+0xc>
8114374c:	003b68fa 	trap	3
81143750:	df000515 	stw	fp,20(sp)
81143754:	df000504 	addi	fp,sp,20
81143758:	e13ffd15 	stw	r4,-12(fp)
8114375c:	e17ffe15 	stw	r5,-8(fp)
81143760:	e1bfff15 	stw	r6,-4(fp)
    bool match = true;
81143764:	00800044 	movi	r2,1
81143768:	e0bffb15 	stw	r2,-20(fp)
	int index;

    for (index = 0; index < 8; index++)
8114376c:	e03ffc15 	stw	zero,-16(fp)
81143770:	00004606 	br	8114388c <match_file_record_to_name_ext+0x148>
    {
        if (CHAR_TO_UPPER(file_record->name[index]) != CHAR_TO_UPPER(name[index]))
81143774:	e0fffd17 	ldw	r3,-12(fp)
81143778:	e0bffc17 	ldw	r2,-16(fp)
8114377c:	1885883a 	add	r2,r3,r2
81143780:	10800003 	ldbu	r2,0(r2)
81143784:	10803fcc 	andi	r2,r2,255
81143788:	10801870 	cmpltui	r2,r2,97
8114378c:	1000101e 	bne	r2,zero,811437d0 <match_file_record_to_name_ext+0x8c>
81143790:	e0fffd17 	ldw	r3,-12(fp)
81143794:	e0bffc17 	ldw	r2,-16(fp)
81143798:	1885883a 	add	r2,r3,r2
8114379c:	10800003 	ldbu	r2,0(r2)
811437a0:	10803fcc 	andi	r2,r2,255
811437a4:	10801ee8 	cmpgeui	r2,r2,123
811437a8:	1000091e 	bne	r2,zero,811437d0 <match_file_record_to_name_ext+0x8c>
811437ac:	e0fffd17 	ldw	r3,-12(fp)
811437b0:	e0bffc17 	ldw	r2,-16(fp)
811437b4:	1885883a 	add	r2,r3,r2
811437b8:	10800003 	ldbu	r2,0(r2)
811437bc:	10bff804 	addi	r2,r2,-32
811437c0:	10c03fcc 	andi	r3,r2,255
811437c4:	18c0201c 	xori	r3,r3,128
811437c8:	18ffe004 	addi	r3,r3,-128
811437cc:	00000706 	br	811437ec <match_file_record_to_name_ext+0xa8>
811437d0:	e0fffd17 	ldw	r3,-12(fp)
811437d4:	e0bffc17 	ldw	r2,-16(fp)
811437d8:	1885883a 	add	r2,r3,r2
811437dc:	10800003 	ldbu	r2,0(r2)
811437e0:	10c03fcc 	andi	r3,r2,255
811437e4:	18c0201c 	xori	r3,r3,128
811437e8:	18ffe004 	addi	r3,r3,-128
811437ec:	e0bffc17 	ldw	r2,-16(fp)
811437f0:	e13ffe17 	ldw	r4,-8(fp)
811437f4:	2085883a 	add	r2,r4,r2
811437f8:	10800003 	ldbu	r2,0(r2)
811437fc:	10803fcc 	andi	r2,r2,255
81143800:	1080201c 	xori	r2,r2,128
81143804:	10bfe004 	addi	r2,r2,-128
81143808:	10801850 	cmplti	r2,r2,97
8114380c:	1000121e 	bne	r2,zero,81143858 <match_file_record_to_name_ext+0x114>
81143810:	e0bffc17 	ldw	r2,-16(fp)
81143814:	e13ffe17 	ldw	r4,-8(fp)
81143818:	2085883a 	add	r2,r4,r2
8114381c:	10800003 	ldbu	r2,0(r2)
81143820:	10803fcc 	andi	r2,r2,255
81143824:	1080201c 	xori	r2,r2,128
81143828:	10bfe004 	addi	r2,r2,-128
8114382c:	10801ec8 	cmpgei	r2,r2,123
81143830:	1000091e 	bne	r2,zero,81143858 <match_file_record_to_name_ext+0x114>
81143834:	e0bffc17 	ldw	r2,-16(fp)
81143838:	e13ffe17 	ldw	r4,-8(fp)
8114383c:	2085883a 	add	r2,r4,r2
81143840:	10800003 	ldbu	r2,0(r2)
81143844:	10bff804 	addi	r2,r2,-32
81143848:	10803fcc 	andi	r2,r2,255
8114384c:	1080201c 	xori	r2,r2,128
81143850:	10bfe004 	addi	r2,r2,-128
81143854:	00000706 	br	81143874 <match_file_record_to_name_ext+0x130>
81143858:	e0bffc17 	ldw	r2,-16(fp)
8114385c:	e13ffe17 	ldw	r4,-8(fp)
81143860:	2085883a 	add	r2,r4,r2
81143864:	10800003 	ldbu	r2,0(r2)
81143868:	10803fcc 	andi	r2,r2,255
8114386c:	1080201c 	xori	r2,r2,128
81143870:	10bfe004 	addi	r2,r2,-128
81143874:	18800226 	beq	r3,r2,81143880 <match_file_record_to_name_ext+0x13c>
        {
            match = false;
81143878:	e03ffb15 	stw	zero,-20(fp)
			break;
8114387c:	00000606 	br	81143898 <match_file_record_to_name_ext+0x154>
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
    bool match = true;
	int index;

    for (index = 0; index < 8; index++)
81143880:	e0bffc17 	ldw	r2,-16(fp)
81143884:	10800044 	addi	r2,r2,1
81143888:	e0bffc15 	stw	r2,-16(fp)
8114388c:	e0bffc17 	ldw	r2,-16(fp)
81143890:	10800210 	cmplti	r2,r2,8
81143894:	103fb71e 	bne	r2,zero,81143774 <__reset+0xfb123774>
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
81143898:	e03ffc15 	stw	zero,-16(fp)
8114389c:	00004a06 	br	811439c8 <match_file_record_to_name_ext+0x284>
    {
        if (CHAR_TO_UPPER(file_record->extension[index]) != CHAR_TO_UPPER(extension[index]))
811438a0:	e0fffd17 	ldw	r3,-12(fp)
811438a4:	e0bffc17 	ldw	r2,-16(fp)
811438a8:	1885883a 	add	r2,r3,r2
811438ac:	10800204 	addi	r2,r2,8
811438b0:	10800003 	ldbu	r2,0(r2)
811438b4:	10803fcc 	andi	r2,r2,255
811438b8:	10801870 	cmpltui	r2,r2,97
811438bc:	1000121e 	bne	r2,zero,81143908 <match_file_record_to_name_ext+0x1c4>
811438c0:	e0fffd17 	ldw	r3,-12(fp)
811438c4:	e0bffc17 	ldw	r2,-16(fp)
811438c8:	1885883a 	add	r2,r3,r2
811438cc:	10800204 	addi	r2,r2,8
811438d0:	10800003 	ldbu	r2,0(r2)
811438d4:	10803fcc 	andi	r2,r2,255
811438d8:	10801ee8 	cmpgeui	r2,r2,123
811438dc:	10000a1e 	bne	r2,zero,81143908 <match_file_record_to_name_ext+0x1c4>
811438e0:	e0fffd17 	ldw	r3,-12(fp)
811438e4:	e0bffc17 	ldw	r2,-16(fp)
811438e8:	1885883a 	add	r2,r3,r2
811438ec:	10800204 	addi	r2,r2,8
811438f0:	10800003 	ldbu	r2,0(r2)
811438f4:	10bff804 	addi	r2,r2,-32
811438f8:	10c03fcc 	andi	r3,r2,255
811438fc:	18c0201c 	xori	r3,r3,128
81143900:	18ffe004 	addi	r3,r3,-128
81143904:	00000806 	br	81143928 <match_file_record_to_name_ext+0x1e4>
81143908:	e0fffd17 	ldw	r3,-12(fp)
8114390c:	e0bffc17 	ldw	r2,-16(fp)
81143910:	1885883a 	add	r2,r3,r2
81143914:	10800204 	addi	r2,r2,8
81143918:	10800003 	ldbu	r2,0(r2)
8114391c:	10c03fcc 	andi	r3,r2,255
81143920:	18c0201c 	xori	r3,r3,128
81143924:	18ffe004 	addi	r3,r3,-128
81143928:	e0bffc17 	ldw	r2,-16(fp)
8114392c:	e13fff17 	ldw	r4,-4(fp)
81143930:	2085883a 	add	r2,r4,r2
81143934:	10800003 	ldbu	r2,0(r2)
81143938:	10803fcc 	andi	r2,r2,255
8114393c:	1080201c 	xori	r2,r2,128
81143940:	10bfe004 	addi	r2,r2,-128
81143944:	10801850 	cmplti	r2,r2,97
81143948:	1000121e 	bne	r2,zero,81143994 <match_file_record_to_name_ext+0x250>
8114394c:	e0bffc17 	ldw	r2,-16(fp)
81143950:	e13fff17 	ldw	r4,-4(fp)
81143954:	2085883a 	add	r2,r4,r2
81143958:	10800003 	ldbu	r2,0(r2)
8114395c:	10803fcc 	andi	r2,r2,255
81143960:	1080201c 	xori	r2,r2,128
81143964:	10bfe004 	addi	r2,r2,-128
81143968:	10801ec8 	cmpgei	r2,r2,123
8114396c:	1000091e 	bne	r2,zero,81143994 <match_file_record_to_name_ext+0x250>
81143970:	e0bffc17 	ldw	r2,-16(fp)
81143974:	e13fff17 	ldw	r4,-4(fp)
81143978:	2085883a 	add	r2,r4,r2
8114397c:	10800003 	ldbu	r2,0(r2)
81143980:	10bff804 	addi	r2,r2,-32
81143984:	10803fcc 	andi	r2,r2,255
81143988:	1080201c 	xori	r2,r2,128
8114398c:	10bfe004 	addi	r2,r2,-128
81143990:	00000706 	br	811439b0 <match_file_record_to_name_ext+0x26c>
81143994:	e0bffc17 	ldw	r2,-16(fp)
81143998:	e13fff17 	ldw	r4,-4(fp)
8114399c:	2085883a 	add	r2,r4,r2
811439a0:	10800003 	ldbu	r2,0(r2)
811439a4:	10803fcc 	andi	r2,r2,255
811439a8:	1080201c 	xori	r2,r2,128
811439ac:	10bfe004 	addi	r2,r2,-128
811439b0:	18800226 	beq	r3,r2,811439bc <match_file_record_to_name_ext+0x278>
        {
            match = false;
811439b4:	e03ffb15 	stw	zero,-20(fp)
			break;
811439b8:	00000606 	br	811439d4 <match_file_record_to_name_ext+0x290>
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
811439bc:	e0bffc17 	ldw	r2,-16(fp)
811439c0:	10800044 	addi	r2,r2,1
811439c4:	e0bffc15 	stw	r2,-16(fp)
811439c8:	e0bffc17 	ldw	r2,-16(fp)
811439cc:	108000d0 	cmplti	r2,r2,3
811439d0:	103fb31e 	bne	r2,zero,811438a0 <__reset+0xfb1238a0>
        {
            match = false;
			break;
        }
    }
	return match;
811439d4:	e0bffb17 	ldw	r2,-20(fp)
}
811439d8:	e037883a 	mov	sp,fp
811439dc:	df000017 	ldw	fp,0(sp)
811439e0:	dec00104 	addi	sp,sp,4
811439e4:	f800283a 	ret

811439e8 <get_home_directory_cluster_for_file>:


bool get_home_directory_cluster_for_file(char *file_name, int *home_directory_cluster, t_file_record *file_record)
// Scan the directories in given in the file name and find the root directory for the file.
{
811439e8:	deffe704 	addi	sp,sp,-100
811439ec:	de00012e 	bgeu	sp,et,811439f4 <get_home_directory_cluster_for_file+0xc>
811439f0:	003b68fa 	trap	3
811439f4:	dfc01815 	stw	ra,96(sp)
811439f8:	df001715 	stw	fp,92(sp)
811439fc:	df001704 	addi	fp,sp,92
81143a00:	e13ffd15 	stw	r4,-12(fp)
81143a04:	e17ffe15 	stw	r5,-8(fp)
81143a08:	e1bfff15 	stw	r6,-4(fp)
    bool result = false;
81143a0c:	e03fe915 	stw	zero,-92(fp)
    int home_dir_cluster = 0;
81143a10:	e03fea15 	stw	zero,-88(fp)
    int location, index;
    int start_location = 0;
81143a14:	e03fed15 	stw	zero,-76(fp)
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
81143a18:	e13ffd17 	ldw	r4,-12(fp)
81143a1c:	11436840 	call	81143684 <get_dir_divider_location>
81143a20:	e0bfeb15 	stw	r2,-84(fp)
    while (location > 0)
81143a24:	00012f06 	br	81143ee4 <get_home_directory_cluster_for_file+0x4fc>
    {
        char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
81143a28:	00800804 	movi	r2,32
81143a2c:	e0bff905 	stb	r2,-28(fp)
81143a30:	00800804 	movi	r2,32
81143a34:	e0bff945 	stb	r2,-27(fp)
81143a38:	00800804 	movi	r2,32
81143a3c:	e0bff985 	stb	r2,-26(fp)
81143a40:	00800804 	movi	r2,32
81143a44:	e0bff9c5 	stb	r2,-25(fp)
81143a48:	00800804 	movi	r2,32
81143a4c:	e0bffa05 	stb	r2,-24(fp)
81143a50:	00800804 	movi	r2,32
81143a54:	e0bffa45 	stb	r2,-23(fp)
81143a58:	00800804 	movi	r2,32
81143a5c:	e0bffa85 	stb	r2,-22(fp)
81143a60:	00800804 	movi	r2,32
81143a64:	e0bffac5 	stb	r2,-21(fp)
        char extension[3] = { ' ', ' ', ' ' };
81143a68:	00800804 	movi	r2,32
81143a6c:	e0bffb05 	stb	r2,-20(fp)
81143a70:	00800804 	movi	r2,32
81143a74:	e0bffb45 	stb	r2,-19(fp)
81143a78:	00800804 	movi	r2,32
81143a7c:	e0bffb85 	stb	r2,-18(fp)
        int ext_index = -1;
81143a80:	00bfffc4 	movi	r2,-1
81143a84:	e0bfee15 	stw	r2,-72(fp)
        int new_cluster = home_dir_cluster;
81143a88:	e0bfea17 	ldw	r2,-88(fp)
81143a8c:	e0bfef15 	stw	r2,-68(fp)
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
81143a90:	e03fec15 	stw	zero,-80(fp)
81143a94:	00002d06 	br	81143b4c <get_home_directory_cluster_for_file+0x164>
        {
            if (file_name[index+start_location] == '.')
81143a98:	e0ffec17 	ldw	r3,-80(fp)
81143a9c:	e0bfed17 	ldw	r2,-76(fp)
81143aa0:	1885883a 	add	r2,r3,r2
81143aa4:	1007883a 	mov	r3,r2
81143aa8:	e0bffd17 	ldw	r2,-12(fp)
81143aac:	10c5883a 	add	r2,r2,r3
81143ab0:	10800003 	ldbu	r2,0(r2)
81143ab4:	10803fcc 	andi	r2,r2,255
81143ab8:	1080201c 	xori	r2,r2,128
81143abc:	10bfe004 	addi	r2,r2,-128
81143ac0:	10800b98 	cmpnei	r2,r2,46
81143ac4:	1000031e 	bne	r2,zero,81143ad4 <get_home_directory_cluster_for_file+0xec>
            {
                ext_index = index;
81143ac8:	e0bfec17 	ldw	r2,-80(fp)
81143acc:	e0bfee15 	stw	r2,-72(fp)
81143ad0:	00001b06 	br	81143b40 <get_home_directory_cluster_for_file+0x158>
            }
            else if (ext_index < 0)
81143ad4:	e0bfee17 	ldw	r2,-72(fp)
81143ad8:	10000c0e 	bge	r2,zero,81143b0c <get_home_directory_cluster_for_file+0x124>
            {
                name[index] = file_name[index+start_location];
81143adc:	e0ffec17 	ldw	r3,-80(fp)
81143ae0:	e0bfed17 	ldw	r2,-76(fp)
81143ae4:	1885883a 	add	r2,r3,r2
81143ae8:	1007883a 	mov	r3,r2
81143aec:	e0bffd17 	ldw	r2,-12(fp)
81143af0:	10c5883a 	add	r2,r2,r3
81143af4:	10c00003 	ldbu	r3,0(r2)
81143af8:	e13ff904 	addi	r4,fp,-28
81143afc:	e0bfec17 	ldw	r2,-80(fp)
81143b00:	2085883a 	add	r2,r4,r2
81143b04:	10c00005 	stb	r3,0(r2)
81143b08:	00000d06 	br	81143b40 <get_home_directory_cluster_for_file+0x158>
            }
            else
            {
                extension[index-ext_index] = file_name[index+start_location];
81143b0c:	e0ffec17 	ldw	r3,-80(fp)
81143b10:	e0bfee17 	ldw	r2,-72(fp)
81143b14:	1885c83a 	sub	r2,r3,r2
81143b18:	e13fec17 	ldw	r4,-80(fp)
81143b1c:	e0ffed17 	ldw	r3,-76(fp)
81143b20:	20c7883a 	add	r3,r4,r3
81143b24:	1809883a 	mov	r4,r3
81143b28:	e0fffd17 	ldw	r3,-12(fp)
81143b2c:	1907883a 	add	r3,r3,r4
81143b30:	18c00003 	ldbu	r3,0(r3)
81143b34:	e13ffb04 	addi	r4,fp,-20
81143b38:	2085883a 	add	r2,r4,r2
81143b3c:	10c00005 	stb	r3,0(r2)
        char extension[3] = { ' ', ' ', ' ' };
        int ext_index = -1;
        int new_cluster = home_dir_cluster;
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
81143b40:	e0bfec17 	ldw	r2,-80(fp)
81143b44:	10800044 	addi	r2,r2,1
81143b48:	e0bfec15 	stw	r2,-80(fp)
81143b4c:	e0ffec17 	ldw	r3,-80(fp)
81143b50:	e0bfeb17 	ldw	r2,-84(fp)
81143b54:	18bfd016 	blt	r3,r2,81143a98 <__reset+0xfb123a98>
            {
                extension[index-ext_index] = file_name[index+start_location];
            }
        }
        
        if (home_dir_cluster == 0)
81143b58:	e0bfea17 	ldw	r2,-88(fp)
81143b5c:	10005c1e 	bne	r2,zero,81143cd0 <get_home_directory_cluster_for_file+0x2e8>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
81143b60:	00a045f4 	movhi	r2,33047
81143b64:	10b44904 	addi	r2,r2,-11996
81143b68:	1080050b 	ldhu	r2,20(r2)
81143b6c:	10bfffcc 	andi	r2,r2,65535
81143b70:	1006917a 	slli	r3,r2,5
81143b74:	00a045f4 	movhi	r2,33047
81143b78:	10b44904 	addi	r2,r2,-11996
81143b7c:	1080030b 	ldhu	r2,12(r2)
81143b80:	10bfffcc 	andi	r2,r2,65535
81143b84:	1885283a 	div	r2,r3,r2
81143b88:	e0bff715 	stw	r2,-36(fp)
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81143b8c:	e03ff015 	stw	zero,-64(fp)
81143b90:	00003b06 	br	81143c80 <get_home_directory_cluster_for_file+0x298>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
81143b94:	00a045f4 	movhi	r2,33047
81143b98:	10b44904 	addi	r2,r2,-11996
81143b9c:	10c01317 	ldw	r3,76(r2)
81143ba0:	e0bff017 	ldw	r2,-64(fp)
81143ba4:	1885883a 	add	r2,r3,r2
81143ba8:	1007883a 	mov	r3,r2
81143bac:	d0a0b117 	ldw	r2,-32060(gp)
81143bb0:	100b883a 	mov	r5,r2
81143bb4:	1809883a 	mov	r4,r3
81143bb8:	11422800 	call	81142280 <Read_Sector_Data>
81143bbc:	10003426 	beq	r2,zero,81143c90 <get_home_directory_cluster_for_file+0x2a8>
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
81143bc0:	e03ff115 	stw	zero,-60(fp)
81143bc4:	00002506 	br	81143c5c <get_home_directory_cluster_for_file+0x274>
                    {
                       
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
81143bc8:	e0bff117 	ldw	r2,-60(fp)
81143bcc:	1004917a 	slli	r2,r2,5
81143bd0:	e0fff017 	ldw	r3,-64(fp)
81143bd4:	180f883a 	mov	r7,r3
81143bd8:	000d883a 	mov	r6,zero
81143bdc:	e17fff17 	ldw	r5,-4(fp)
81143be0:	1009883a 	mov	r4,r2
81143be4:	11426b00 	call	811426b0 <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
81143be8:	e0bfff17 	ldw	r2,-4(fp)
81143bec:	10800003 	ldbu	r2,0(r2)
81143bf0:	10803fcc 	andi	r2,r2,255
81143bf4:	10803960 	cmpeqi	r2,r2,229
81143bf8:	1000151e 	bne	r2,zero,81143c50 <get_home_directory_cluster_for_file+0x268>
81143bfc:	e0bfff17 	ldw	r2,-4(fp)
81143c00:	10800003 	ldbu	r2,0(r2)
81143c04:	10803fcc 	andi	r2,r2,255
81143c08:	10001126 	beq	r2,zero,81143c50 <get_home_directory_cluster_for_file+0x268>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
81143c0c:	e0fffb04 	addi	r3,fp,-20
81143c10:	e0bff904 	addi	r2,fp,-28
81143c14:	180d883a 	mov	r6,r3
81143c18:	100b883a 	mov	r5,r2
81143c1c:	e13fff17 	ldw	r4,-4(fp)
81143c20:	11437440 	call	81143744 <match_file_record_to_name_ext>
81143c24:	e0bff815 	stw	r2,-32(fp)
                            if (match)
81143c28:	e0bff817 	ldw	r2,-32(fp)
81143c2c:	10000826 	beq	r2,zero,81143c50 <get_home_directory_cluster_for_file+0x268>
                            {
                                new_cluster = file_record->start_cluster_index;
81143c30:	e0bfff17 	ldw	r2,-4(fp)
81143c34:	1080058b 	ldhu	r2,22(r2)
81143c38:	10bfffcc 	andi	r2,r2,65535
81143c3c:	e0bfef15 	stw	r2,-68(fp)
                                file_record->file_record_cluster = 1; // Home directory is a subdirectory in the root directory.
81143c40:	e0bfff17 	ldw	r2,-4(fp)
81143c44:	00c00044 	movi	r3,1
81143c48:	10c00a15 	stw	r3,40(r2)
                                break;
81143c4c:	00000606 	br	81143c68 <get_home_directory_cluster_for_file+0x280>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
81143c50:	e0bff117 	ldw	r2,-60(fp)
81143c54:	10800044 	addi	r2,r2,1
81143c58:	e0bff115 	stw	r2,-60(fp)
81143c5c:	e0bff117 	ldw	r2,-60(fp)
81143c60:	10800410 	cmplti	r2,r2,16
81143c64:	103fd81e 	bne	r2,zero,81143bc8 <__reset+0xfb123bc8>
                }
                else
                {
                    break;
                }
                if (new_cluster != home_dir_cluster)
81143c68:	e0ffef17 	ldw	r3,-68(fp)
81143c6c:	e0bfea17 	ldw	r2,-88(fp)
81143c70:	1880091e 	bne	r3,r2,81143c98 <get_home_directory_cluster_for_file+0x2b0>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81143c74:	e0bff017 	ldw	r2,-64(fp)
81143c78:	10800044 	addi	r2,r2,1
81143c7c:	e0bff015 	stw	r2,-64(fp)
81143c80:	e0fff017 	ldw	r3,-64(fp)
81143c84:	e0bff717 	ldw	r2,-36(fp)
81143c88:	18bfc216 	blt	r3,r2,81143b94 <__reset+0xfb123b94>
81143c8c:	00000306 	br	81143c9c <get_home_directory_cluster_for_file+0x2b4>
                        }
                    }
                }
                else
                {
                    break;
81143c90:	0001883a 	nop
81143c94:	00000106 	br	81143c9c <get_home_directory_cluster_for_file+0x2b4>
                }
                if (new_cluster != home_dir_cluster)
                {
                    break;
81143c98:	0001883a 	nop
                }
            }
            if (new_cluster != home_dir_cluster)
81143c9c:	e0ffef17 	ldw	r3,-68(fp)
81143ca0:	e0bfea17 	ldw	r2,-88(fp)
81143ca4:	18800826 	beq	r3,r2,81143cc8 <get_home_directory_cluster_for_file+0x2e0>
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
81143ca8:	e0bfef17 	ldw	r2,-68(fp)
81143cac:	e0bfea15 	stw	r2,-88(fp)
                start_location = start_location+location+1;
81143cb0:	e0ffed17 	ldw	r3,-76(fp)
81143cb4:	e0bfeb17 	ldw	r2,-84(fp)
81143cb8:	1885883a 	add	r2,r3,r2
81143cbc:	10800044 	addi	r2,r2,1
81143cc0:	e0bfed15 	stw	r2,-76(fp)
81143cc4:	00007d06 	br	81143ebc <get_home_directory_cluster_for_file+0x4d4>
            }
            else
            {
                // Directory path is invalid. 
                return false;
81143cc8:	0005883a 	mov	r2,zero
81143ccc:	00009106 	br	81143f14 <get_home_directory_cluster_for_file+0x52c>
            }
        } else {
            // This is a subdirectory that can have any number of elements. So scan through it as though it was a file
            // and see if you can find the directory of interest.
            int cluster = home_dir_cluster;
81143cd0:	e0bfea17 	ldw	r2,-88(fp)
81143cd4:	e0bff415 	stw	r2,-48(fp)
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
81143cd8:	e0bff417 	ldw	r2,-48(fp)
81143cdc:	10ffff84 	addi	r3,r2,-2
81143ce0:	00a045f4 	movhi	r2,33047
81143ce4:	10b44904 	addi	r2,r2,-11996
81143ce8:	10800383 	ldbu	r2,14(r2)
81143cec:	10803fcc 	andi	r2,r2,255
81143cf0:	1885383a 	mul	r2,r3,r2
81143cf4:	1007883a 	mov	r3,r2
81143cf8:	00a045f4 	movhi	r2,33047
81143cfc:	10b44904 	addi	r2,r2,-11996
81143d00:	10801417 	ldw	r2,80(r2)
81143d04:	1885883a 	add	r2,r3,r2
81143d08:	e0bff515 	stw	r2,-44(fp)
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81143d0c:	e03ff215 	stw	zero,-56(fp)
81143d10:	00003606 	br	81143dec <get_home_directory_cluster_for_file+0x404>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
81143d14:	e0fff217 	ldw	r3,-56(fp)
81143d18:	e0bff517 	ldw	r2,-44(fp)
81143d1c:	1885883a 	add	r2,r3,r2
81143d20:	d0e0b117 	ldw	r3,-32060(gp)
81143d24:	180b883a 	mov	r5,r3
81143d28:	1009883a 	mov	r4,r2
81143d2c:	11422800 	call	81142280 <Read_Sector_Data>
81143d30:	10003526 	beq	r2,zero,81143e08 <get_home_directory_cluster_for_file+0x420>
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
81143d34:	e03ff315 	stw	zero,-52(fp)
81143d38:	00002306 	br	81143dc8 <get_home_directory_cluster_for_file+0x3e0>
                        {                         
                            // Read file record.
                            Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
81143d3c:	e0bff317 	ldw	r2,-52(fp)
81143d40:	1004917a 	slli	r2,r2,5
81143d44:	e0fff417 	ldw	r3,-48(fp)
81143d48:	e13ff217 	ldw	r4,-56(fp)
81143d4c:	200f883a 	mov	r7,r4
81143d50:	180d883a 	mov	r6,r3
81143d54:	e17fff17 	ldw	r5,-4(fp)
81143d58:	1009883a 	mov	r4,r2
81143d5c:	11426b00 	call	811426b0 <Read_File_Record_At_Offset>
                            if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
81143d60:	e0bfff17 	ldw	r2,-4(fp)
81143d64:	10800003 	ldbu	r2,0(r2)
81143d68:	10803fcc 	andi	r2,r2,255
81143d6c:	10803960 	cmpeqi	r2,r2,229
81143d70:	1000121e 	bne	r2,zero,81143dbc <get_home_directory_cluster_for_file+0x3d4>
81143d74:	e0bfff17 	ldw	r2,-4(fp)
81143d78:	10800003 	ldbu	r2,0(r2)
81143d7c:	10803fcc 	andi	r2,r2,255
81143d80:	10000e26 	beq	r2,zero,81143dbc <get_home_directory_cluster_for_file+0x3d4>
                            {
								bool match = match_file_record_to_name_ext(file_record, name, extension);
81143d84:	e0fffb04 	addi	r3,fp,-20
81143d88:	e0bff904 	addi	r2,fp,-28
81143d8c:	180d883a 	mov	r6,r3
81143d90:	100b883a 	mov	r5,r2
81143d94:	e13fff17 	ldw	r4,-4(fp)
81143d98:	11437440 	call	81143744 <match_file_record_to_name_ext>
81143d9c:	e0bff615 	stw	r2,-40(fp)
                                if (match)
81143da0:	e0bff617 	ldw	r2,-40(fp)
81143da4:	10000526 	beq	r2,zero,81143dbc <get_home_directory_cluster_for_file+0x3d4>
                                {
                                    new_cluster = file_record->start_cluster_index;                                   
81143da8:	e0bfff17 	ldw	r2,-4(fp)
81143dac:	1080058b 	ldhu	r2,22(r2)
81143db0:	10bfffcc 	andi	r2,r2,65535
81143db4:	e0bfef15 	stw	r2,-68(fp)
                                    break;
81143db8:	00000606 	br	81143dd4 <get_home_directory_cluster_for_file+0x3ec>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
81143dbc:	e0bff317 	ldw	r2,-52(fp)
81143dc0:	10800044 	addi	r2,r2,1
81143dc4:	e0bff315 	stw	r2,-52(fp)
81143dc8:	e0bff317 	ldw	r2,-52(fp)
81143dcc:	10800410 	cmplti	r2,r2,16
81143dd0:	103fda1e 	bne	r2,zero,81143d3c <__reset+0xfb123d3c>
                    }
                    else
                    {
                        break;
                    }
                    if (new_cluster != home_dir_cluster)
81143dd4:	e0ffef17 	ldw	r3,-68(fp)
81143dd8:	e0bfea17 	ldw	r2,-88(fp)
81143ddc:	18800c1e 	bne	r3,r2,81143e10 <get_home_directory_cluster_for_file+0x428>
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81143de0:	e0bff217 	ldw	r2,-56(fp)
81143de4:	10800044 	addi	r2,r2,1
81143de8:	e0bff215 	stw	r2,-56(fp)
81143dec:	00a045f4 	movhi	r2,33047
81143df0:	10b44904 	addi	r2,r2,-11996
81143df4:	10800383 	ldbu	r2,14(r2)
81143df8:	10803fcc 	andi	r2,r2,255
81143dfc:	e0fff217 	ldw	r3,-56(fp)
81143e00:	18bfc416 	blt	r3,r2,81143d14 <__reset+0xfb123d14>
81143e04:	00000306 	br	81143e14 <get_home_directory_cluster_for_file+0x42c>
                            }
                        }
                    }
                    else
                    {
                        break;
81143e08:	0001883a 	nop
81143e0c:	00000106 	br	81143e14 <get_home_directory_cluster_for_file+0x42c>
                    }
                    if (new_cluster != home_dir_cluster)
                    {
                        break;
81143e10:	0001883a 	nop
                    }
                }
                // If this is the end of the cluster and the directory has not been found, then see if there is another cluster
                // that holds data for the current directory.
                if (new_cluster == home_dir_cluster)
81143e14:	e0ffef17 	ldw	r3,-68(fp)
81143e18:	e0bfea17 	ldw	r2,-88(fp)
81143e1c:	1880141e 	bne	r3,r2,81143e70 <get_home_directory_cluster_for_file+0x488>
                {
					unsigned short int next_cluster;

					if (get_cluster_flag(new_cluster, &next_cluster))
81143e20:	e0bfef17 	ldw	r2,-68(fp)
81143e24:	e0fffc04 	addi	r3,fp,-16
81143e28:	180b883a 	mov	r5,r3
81143e2c:	1009883a 	mov	r4,r2
81143e30:	11423600 	call	81142360 <get_cluster_flag>
81143e34:	10000c26 	beq	r2,zero,81143e68 <get_home_directory_cluster_for_file+0x480>
					{
						// The directory needs to be expanded to store more files.
						if ((next_cluster & 0x0000fff8) == 0x0000fff8)
81143e38:	e0bffc0b 	ldhu	r2,-16(fp)
81143e3c:	10bfffcc 	andi	r2,r2,65535
81143e40:	10fffe0c 	andi	r3,r2,65528
81143e44:	00bffe14 	movui	r2,65528
81143e48:	1880021e 	bne	r3,r2,81143e54 <get_home_directory_cluster_for_file+0x46c>
						{
							return false;
81143e4c:	0005883a 	mov	r2,zero
81143e50:	00003006 	br	81143f14 <get_home_directory_cluster_for_file+0x52c>
						}
						new_cluster = (next_cluster & 0x0000fff8);
81143e54:	e0bffc0b 	ldhu	r2,-16(fp)
81143e58:	10bfffcc 	andi	r2,r2,65535
81143e5c:	10bffe0c 	andi	r2,r2,65528
81143e60:	e0bfef15 	stw	r2,-68(fp)
81143e64:	00000206 	br	81143e70 <get_home_directory_cluster_for_file+0x488>
					}
					else
					{
						// Directory path is invalid.                 
						return false;
81143e68:	0005883a 	mov	r2,zero
81143e6c:	00002906 	br	81143f14 <get_home_directory_cluster_for_file+0x52c>
					}
                }              
            } while ((cluster < 0x0000fff8) && (new_cluster == home_dir_cluster));
81143e70:	e0bff417 	ldw	r2,-48(fp)
81143e74:	00fffdd4 	movui	r3,65527
81143e78:	18800316 	blt	r3,r2,81143e88 <get_home_directory_cluster_for_file+0x4a0>
81143e7c:	e0ffef17 	ldw	r3,-68(fp)
81143e80:	e0bfea17 	ldw	r2,-88(fp)
81143e84:	18bf9426 	beq	r3,r2,81143cd8 <__reset+0xfb123cd8>
            if (new_cluster != home_dir_cluster)
81143e88:	e0ffef17 	ldw	r3,-68(fp)
81143e8c:	e0bfea17 	ldw	r2,-88(fp)
81143e90:	18800826 	beq	r3,r2,81143eb4 <get_home_directory_cluster_for_file+0x4cc>
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
81143e94:	e0bfef17 	ldw	r2,-68(fp)
81143e98:	e0bfea15 	stw	r2,-88(fp)
                start_location = start_location+location+1;
81143e9c:	e0ffed17 	ldw	r3,-76(fp)
81143ea0:	e0bfeb17 	ldw	r2,-84(fp)
81143ea4:	1885883a 	add	r2,r3,r2
81143ea8:	10800044 	addi	r2,r2,1
81143eac:	e0bfed15 	stw	r2,-76(fp)
81143eb0:	00000206 	br	81143ebc <get_home_directory_cluster_for_file+0x4d4>
            }
            else
            {
                // Directory path is invalid. 
                return false;
81143eb4:	0005883a 	mov	r2,zero
81143eb8:	00001606 	br	81143f14 <get_home_directory_cluster_for_file+0x52c>
            }            
        }
        location = get_dir_divider_location(&(file_name[start_location]));
81143ebc:	e0bfed17 	ldw	r2,-76(fp)
81143ec0:	e0fffd17 	ldw	r3,-12(fp)
81143ec4:	1885883a 	add	r2,r3,r2
81143ec8:	1009883a 	mov	r4,r2
81143ecc:	11436840 	call	81143684 <get_dir_divider_location>
81143ed0:	e0bfeb15 	stw	r2,-84(fp)
        if (location < 0)
81143ed4:	e0bfeb17 	ldw	r2,-84(fp)
81143ed8:	1000020e 	bge	r2,zero,81143ee4 <get_home_directory_cluster_for_file+0x4fc>
        {
            // Directory has been located.
            result = true;
81143edc:	00800044 	movi	r2,1
81143ee0:	e0bfe915 	stw	r2,-92(fp)
    int location, index;
    int start_location = 0;
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
    while (location > 0)
81143ee4:	e0bfeb17 	ldw	r2,-84(fp)
81143ee8:	00becf16 	blt	zero,r2,81143a28 <__reset+0xfb123a28>
            // Directory has been located.
            result = true;
        }
    }
    
    *home_directory_cluster = home_dir_cluster;
81143eec:	e0bffe17 	ldw	r2,-8(fp)
81143ef0:	e0ffea17 	ldw	r3,-88(fp)
81143ef4:	10c00015 	stw	r3,0(r2)
    if (home_dir_cluster == 0)
81143ef8:	e0bfea17 	ldw	r2,-88(fp)
81143efc:	1000041e 	bne	r2,zero,81143f10 <get_home_directory_cluster_for_file+0x528>
    {
        file_record->file_record_cluster = 0; // Home directory is the root directory.
81143f00:	e0bfff17 	ldw	r2,-4(fp)
81143f04:	10000a15 	stw	zero,40(r2)
		result = true;
81143f08:	00800044 	movi	r2,1
81143f0c:	e0bfe915 	stw	r2,-92(fp)
    }
    return result;
81143f10:	e0bfe917 	ldw	r2,-92(fp)
}
81143f14:	e037883a 	mov	sp,fp
81143f18:	dfc00117 	ldw	ra,4(sp)
81143f1c:	df000017 	ldw	fp,0(sp)
81143f20:	dec00204 	addi	sp,sp,8
81143f24:	f800283a 	ret

81143f28 <find_file_in_directory>:


bool find_file_in_directory(int directory_start_cluster, char *file_name, t_file_record *file_record)
// Given a cluster and a file name, check if the file already exists. Return the file record if the file is found.
{
81143f28:	deffe804 	addi	sp,sp,-96
81143f2c:	de00012e 	bgeu	sp,et,81143f34 <find_file_in_directory+0xc>
81143f30:	003b68fa 	trap	3
81143f34:	dfc01715 	stw	ra,92(sp)
81143f38:	df001615 	stw	fp,88(sp)
81143f3c:	df001604 	addi	fp,sp,88
81143f40:	e13ffd15 	stw	r4,-12(fp)
81143f44:	e17ffe15 	stw	r5,-8(fp)
81143f48:	e1bfff15 	stw	r6,-4(fp)
    int location = get_dir_divider_location( file_name );
81143f4c:	e13ffe17 	ldw	r4,-8(fp)
81143f50:	11436840 	call	81143684 <get_dir_divider_location>
81143f54:	e0bfea15 	stw	r2,-88(fp)
    int last_dir_separator = 0;
81143f58:	e03feb15 	stw	zero,-84(fp)
    char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
81143f5c:	00800804 	movi	r2,32
81143f60:	e0bff905 	stb	r2,-28(fp)
81143f64:	00800804 	movi	r2,32
81143f68:	e0bff945 	stb	r2,-27(fp)
81143f6c:	00800804 	movi	r2,32
81143f70:	e0bff985 	stb	r2,-26(fp)
81143f74:	00800804 	movi	r2,32
81143f78:	e0bff9c5 	stb	r2,-25(fp)
81143f7c:	00800804 	movi	r2,32
81143f80:	e0bffa05 	stb	r2,-24(fp)
81143f84:	00800804 	movi	r2,32
81143f88:	e0bffa45 	stb	r2,-23(fp)
81143f8c:	00800804 	movi	r2,32
81143f90:	e0bffa85 	stb	r2,-22(fp)
81143f94:	00800804 	movi	r2,32
81143f98:	e0bffac5 	stb	r2,-21(fp)
    char extension[3] = { ' ', ' ', ' ' };
81143f9c:	00800804 	movi	r2,32
81143fa0:	e0bffb05 	stb	r2,-20(fp)
81143fa4:	00800804 	movi	r2,32
81143fa8:	e0bffb45 	stb	r2,-19(fp)
81143fac:	00800804 	movi	r2,32
81143fb0:	e0bffb85 	stb	r2,-18(fp)
    int ext_index = -1;
81143fb4:	00bfffc4 	movi	r2,-1
81143fb8:	e0bfec15 	stw	r2,-80(fp)
    int cluster = directory_start_cluster;
81143fbc:	e0bffd17 	ldw	r2,-12(fp)
81143fc0:	e0bfed15 	stw	r2,-76(fp)
    int index;
	int length = strlen(file_name);
81143fc4:	e13ffe17 	ldw	r4,-8(fp)
81143fc8:	11231840 	call	81123184 <strlen>
81143fcc:	e0bff415 	stw	r2,-48(fp)
    bool result = false;
81143fd0:	e03fef15 	stw	zero,-68(fp)
    
    // Skip through all directory separators.
    while (location > 0)
81143fd4:	00000b06 	br	81144004 <find_file_in_directory+0xdc>
    {
        last_dir_separator = last_dir_separator+location+1;
81143fd8:	e0ffeb17 	ldw	r3,-84(fp)
81143fdc:	e0bfea17 	ldw	r2,-88(fp)
81143fe0:	1885883a 	add	r2,r3,r2
81143fe4:	10800044 	addi	r2,r2,1
81143fe8:	e0bfeb15 	stw	r2,-84(fp)
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
81143fec:	e0bfeb17 	ldw	r2,-84(fp)
81143ff0:	e0fffe17 	ldw	r3,-8(fp)
81143ff4:	1885883a 	add	r2,r3,r2
81143ff8:	1009883a 	mov	r4,r2
81143ffc:	11436840 	call	81143684 <get_dir_divider_location>
81144000:	e0bfea15 	stw	r2,-88(fp)
    int index;
	int length = strlen(file_name);
    bool result = false;
    
    // Skip through all directory separators.
    while (location > 0)
81144004:	e0bfea17 	ldw	r2,-88(fp)
81144008:	00bff316 	blt	zero,r2,81143fd8 <__reset+0xfb123fd8>
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
8114400c:	e0bfeb17 	ldw	r2,-84(fp)
81144010:	e0bfee15 	stw	r2,-72(fp)
81144014:	00002706 	br	811440b4 <find_file_in_directory+0x18c>
    {
        if (file_name[index] == '.')
81144018:	e0bfee17 	ldw	r2,-72(fp)
8114401c:	e0fffe17 	ldw	r3,-8(fp)
81144020:	1885883a 	add	r2,r3,r2
81144024:	10800003 	ldbu	r2,0(r2)
81144028:	10803fcc 	andi	r2,r2,255
8114402c:	1080201c 	xori	r2,r2,128
81144030:	10bfe004 	addi	r2,r2,-128
81144034:	10800b98 	cmpnei	r2,r2,46
81144038:	1000031e 	bne	r2,zero,81144048 <find_file_in_directory+0x120>
        {
            ext_index = index;
8114403c:	e0bfee17 	ldw	r2,-72(fp)
81144040:	e0bfec15 	stw	r2,-80(fp)
81144044:	00001806 	br	811440a8 <find_file_in_directory+0x180>
        }
        else if (ext_index < 0)
81144048:	e0bfec17 	ldw	r2,-80(fp)
8114404c:	10000b0e 	bge	r2,zero,8114407c <find_file_in_directory+0x154>
        {
            name[index-last_dir_separator] = file_name[index];
81144050:	e0ffee17 	ldw	r3,-72(fp)
81144054:	e0bfeb17 	ldw	r2,-84(fp)
81144058:	1885c83a 	sub	r2,r3,r2
8114405c:	e0ffee17 	ldw	r3,-72(fp)
81144060:	e13ffe17 	ldw	r4,-8(fp)
81144064:	20c7883a 	add	r3,r4,r3
81144068:	18c00003 	ldbu	r3,0(r3)
8114406c:	e13ff904 	addi	r4,fp,-28
81144070:	2085883a 	add	r2,r4,r2
81144074:	10c00005 	stb	r3,0(r2)
81144078:	00000b06 	br	811440a8 <find_file_in_directory+0x180>
        }
        else
        {
            extension[index-ext_index-1] = file_name[index];
8114407c:	e0ffee17 	ldw	r3,-72(fp)
81144080:	e0bfec17 	ldw	r2,-80(fp)
81144084:	1885c83a 	sub	r2,r3,r2
81144088:	10bfffc4 	addi	r2,r2,-1
8114408c:	e0ffee17 	ldw	r3,-72(fp)
81144090:	e13ffe17 	ldw	r4,-8(fp)
81144094:	20c7883a 	add	r3,r4,r3
81144098:	18c00003 	ldbu	r3,0(r3)
8114409c:	e13ffb04 	addi	r4,fp,-20
811440a0:	2085883a 	add	r2,r4,r2
811440a4:	10c00005 	stb	r3,0(r2)
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
811440a8:	e0bfee17 	ldw	r2,-72(fp)
811440ac:	10800044 	addi	r2,r2,1
811440b0:	e0bfee15 	stw	r2,-72(fp)
811440b4:	e0ffee17 	ldw	r3,-72(fp)
811440b8:	e0bff417 	ldw	r2,-48(fp)
811440bc:	18bfd616 	blt	r3,r2,81144018 <__reset+0xfb124018>
            extension[index-ext_index-1] = file_name[index];
        }
    }

    // Look for the file.
    if (directory_start_cluster == 0)
811440c0:	e0bffd17 	ldw	r2,-12(fp)
811440c4:	1000461e 	bne	r2,zero,811441e0 <find_file_in_directory+0x2b8>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
811440c8:	00a045f4 	movhi	r2,33047
811440cc:	10b44904 	addi	r2,r2,-11996
811440d0:	1080050b 	ldhu	r2,20(r2)
811440d4:	10bfffcc 	andi	r2,r2,65535
811440d8:	1006917a 	slli	r3,r2,5
811440dc:	00a045f4 	movhi	r2,33047
811440e0:	10b44904 	addi	r2,r2,-11996
811440e4:	1080030b 	ldhu	r2,12(r2)
811440e8:	10bfffcc 	andi	r2,r2,65535
811440ec:	1885283a 	div	r2,r3,r2
811440f0:	e0bff715 	stw	r2,-36(fp)
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
811440f4:	e03ff015 	stw	zero,-64(fp)
811440f8:	00003506 	br	811441d0 <find_file_in_directory+0x2a8>
        {
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
811440fc:	00a045f4 	movhi	r2,33047
81144100:	10b44904 	addi	r2,r2,-11996
81144104:	10c01317 	ldw	r3,76(r2)
81144108:	e0bff017 	ldw	r2,-64(fp)
8114410c:	1885883a 	add	r2,r3,r2
81144110:	1007883a 	mov	r3,r2
81144114:	d0a0b117 	ldw	r2,-32060(gp)
81144118:	100b883a 	mov	r5,r2
8114411c:	1809883a 	mov	r4,r3
81144120:	11422800 	call	81142280 <Read_Sector_Data>
81144124:	10009626 	beq	r2,zero,81144380 <find_file_in_directory+0x458>
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
81144128:	e03ff115 	stw	zero,-60(fp)
8114412c:	00002006 	br	811441b0 <find_file_in_directory+0x288>
                {
                    // Read file record.
                    Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
81144130:	e0bff117 	ldw	r2,-60(fp)
81144134:	1004917a 	slli	r2,r2,5
81144138:	e0fff017 	ldw	r3,-64(fp)
8114413c:	180f883a 	mov	r7,r3
81144140:	000d883a 	mov	r6,zero
81144144:	e17fff17 	ldw	r5,-4(fp)
81144148:	1009883a 	mov	r4,r2
8114414c:	11426b00 	call	811426b0 <Read_File_Record_At_Offset>
                    if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
81144150:	e0bfff17 	ldw	r2,-4(fp)
81144154:	10800003 	ldbu	r2,0(r2)
81144158:	10803fcc 	andi	r2,r2,255
8114415c:	10803960 	cmpeqi	r2,r2,229
81144160:	1000101e 	bne	r2,zero,811441a4 <find_file_in_directory+0x27c>
81144164:	e0bfff17 	ldw	r2,-4(fp)
81144168:	10800003 	ldbu	r2,0(r2)
8114416c:	10803fcc 	andi	r2,r2,255
81144170:	10000c26 	beq	r2,zero,811441a4 <find_file_in_directory+0x27c>
                    {
                        bool match = match_file_record_to_name_ext(file_record, name, extension);
81144174:	e0fffb04 	addi	r3,fp,-20
81144178:	e0bff904 	addi	r2,fp,-28
8114417c:	180d883a 	mov	r6,r3
81144180:	100b883a 	mov	r5,r2
81144184:	e13fff17 	ldw	r4,-4(fp)
81144188:	11437440 	call	81143744 <match_file_record_to_name_ext>
8114418c:	e0bff815 	stw	r2,-32(fp)

                        if (match)
81144190:	e0bff817 	ldw	r2,-32(fp)
81144194:	10000326 	beq	r2,zero,811441a4 <find_file_in_directory+0x27c>
                        {
                            result = true;
81144198:	00800044 	movi	r2,1
8114419c:	e0bfef15 	stw	r2,-68(fp)
                            break;
811441a0:	00000606 	br	811441bc <find_file_in_directory+0x294>
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
811441a4:	e0bff117 	ldw	r2,-60(fp)
811441a8:	10800044 	addi	r2,r2,1
811441ac:	e0bff115 	stw	r2,-60(fp)
811441b0:	e0bff117 	ldw	r2,-60(fp)
811441b4:	10800410 	cmplti	r2,r2,16
811441b8:	103fdd1e 	bne	r2,zero,81144130 <__reset+0xfb124130>
            }
            else
            {
                break;
            }
            if (result)
811441bc:	e0bfef17 	ldw	r2,-68(fp)
811441c0:	1000711e 	bne	r2,zero,81144388 <find_file_in_directory+0x460>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
811441c4:	e0bff017 	ldw	r2,-64(fp)
811441c8:	10800044 	addi	r2,r2,1
811441cc:	e0bff015 	stw	r2,-64(fp)
811441d0:	e0fff017 	ldw	r3,-64(fp)
811441d4:	e0bff717 	ldw	r2,-36(fp)
811441d8:	18bfc816 	blt	r3,r2,811440fc <__reset+0xfb1240fc>
811441dc:	00006b06 	br	8114438c <find_file_in_directory+0x464>
        }
    }
    else
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
811441e0:	e0bfed17 	ldw	r2,-76(fp)
811441e4:	10ffff84 	addi	r3,r2,-2
811441e8:	00a045f4 	movhi	r2,33047
811441ec:	10b44904 	addi	r2,r2,-11996
811441f0:	10800383 	ldbu	r2,14(r2)
811441f4:	10803fcc 	andi	r2,r2,255
811441f8:	1885383a 	mul	r2,r3,r2
811441fc:	1007883a 	mov	r3,r2
81144200:	00a045f4 	movhi	r2,33047
81144204:	10b44904 	addi	r2,r2,-11996
81144208:	10801417 	ldw	r2,80(r2)
8114420c:	1885883a 	add	r2,r3,r2
81144210:	e0bff515 	stw	r2,-44(fp)
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81144214:	e03ff215 	stw	zero,-56(fp)
81144218:	00003306 	br	811442e8 <find_file_in_directory+0x3c0>
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
8114421c:	e0fff217 	ldw	r3,-56(fp)
81144220:	e0bff517 	ldw	r2,-44(fp)
81144224:	1885883a 	add	r2,r3,r2
81144228:	d0e0b117 	ldw	r3,-32060(gp)
8114422c:	180b883a 	mov	r5,r3
81144230:	1009883a 	mov	r4,r2
81144234:	11422800 	call	81142280 <Read_Sector_Data>
81144238:	10003226 	beq	r2,zero,81144304 <find_file_in_directory+0x3dc>
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
8114423c:	e03ff315 	stw	zero,-52(fp)
81144240:	00002106 	br	811442c8 <find_file_in_directory+0x3a0>
                    {
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
81144244:	e0bff317 	ldw	r2,-52(fp)
81144248:	1004917a 	slli	r2,r2,5
8114424c:	e0ffed17 	ldw	r3,-76(fp)
81144250:	e13ff217 	ldw	r4,-56(fp)
81144254:	200f883a 	mov	r7,r4
81144258:	180d883a 	mov	r6,r3
8114425c:	e17fff17 	ldw	r5,-4(fp)
81144260:	1009883a 	mov	r4,r2
81144264:	11426b00 	call	811426b0 <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
81144268:	e0bfff17 	ldw	r2,-4(fp)
8114426c:	10800003 	ldbu	r2,0(r2)
81144270:	10803fcc 	andi	r2,r2,255
81144274:	10803960 	cmpeqi	r2,r2,229
81144278:	1000101e 	bne	r2,zero,811442bc <find_file_in_directory+0x394>
8114427c:	e0bfff17 	ldw	r2,-4(fp)
81144280:	10800003 	ldbu	r2,0(r2)
81144284:	10803fcc 	andi	r2,r2,255
81144288:	10000c26 	beq	r2,zero,811442bc <find_file_in_directory+0x394>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
8114428c:	e0fffb04 	addi	r3,fp,-20
81144290:	e0bff904 	addi	r2,fp,-28
81144294:	180d883a 	mov	r6,r3
81144298:	100b883a 	mov	r5,r2
8114429c:	e13fff17 	ldw	r4,-4(fp)
811442a0:	11437440 	call	81143744 <match_file_record_to_name_ext>
811442a4:	e0bff615 	stw	r2,-40(fp)

                            if (match)
811442a8:	e0bff617 	ldw	r2,-40(fp)
811442ac:	10000326 	beq	r2,zero,811442bc <find_file_in_directory+0x394>
                            {                               
                                result = true;
811442b0:	00800044 	movi	r2,1
811442b4:	e0bfef15 	stw	r2,-68(fp)
                                break;
811442b8:	00000606 	br	811442d4 <find_file_in_directory+0x3ac>
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
811442bc:	e0bff317 	ldw	r2,-52(fp)
811442c0:	10800044 	addi	r2,r2,1
811442c4:	e0bff315 	stw	r2,-52(fp)
811442c8:	e0bff317 	ldw	r2,-52(fp)
811442cc:	10800410 	cmplti	r2,r2,16
811442d0:	103fdc1e 	bne	r2,zero,81144244 <__reset+0xfb124244>
                }
                else
                {
                    break;
                }
                if (result)
811442d4:	e0bfef17 	ldw	r2,-68(fp)
811442d8:	10000c1e 	bne	r2,zero,8114430c <find_file_in_directory+0x3e4>
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
811442dc:	e0bff217 	ldw	r2,-56(fp)
811442e0:	10800044 	addi	r2,r2,1
811442e4:	e0bff215 	stw	r2,-56(fp)
811442e8:	00a045f4 	movhi	r2,33047
811442ec:	10b44904 	addi	r2,r2,-11996
811442f0:	10800383 	ldbu	r2,14(r2)
811442f4:	10803fcc 	andi	r2,r2,255
811442f8:	e0fff217 	ldw	r3,-56(fp)
811442fc:	18bfc716 	blt	r3,r2,8114421c <__reset+0xfb12421c>
81144300:	00000306 	br	81144310 <find_file_in_directory+0x3e8>
                        }
                    }
                }
                else
                {
                    break;
81144304:	0001883a 	nop
81144308:	00000106 	br	81144310 <find_file_in_directory+0x3e8>
                }
                if (result)
                {
                    break;
8114430c:	0001883a 	nop
                }
            }
            // If this is the end of the cluster and the file has not been found, then see if there is another cluster
            // that holds data for the current directory.
            if (result == false)
81144310:	e0bfef17 	ldw	r2,-68(fp)
81144314:	1000141e 	bne	r2,zero,81144368 <find_file_in_directory+0x440>
            {
				unsigned short int new_cluster;

				if (get_cluster_flag(cluster, &new_cluster))
81144318:	e0bfed17 	ldw	r2,-76(fp)
8114431c:	e0fffc04 	addi	r3,fp,-16
81144320:	180b883a 	mov	r5,r3
81144324:	1009883a 	mov	r4,r2
81144328:	11423600 	call	81142360 <get_cluster_flag>
8114432c:	10000c26 	beq	r2,zero,81144360 <find_file_in_directory+0x438>
				{
					// The directory needs to be expanded to store more files.
					if ((new_cluster & 0x0000fff8) == 0x0000fff8)
81144330:	e0bffc0b 	ldhu	r2,-16(fp)
81144334:	10bfffcc 	andi	r2,r2,65535
81144338:	10fffe0c 	andi	r3,r2,65528
8114433c:	00bffe14 	movui	r2,65528
81144340:	1880021e 	bne	r3,r2,8114434c <find_file_in_directory+0x424>
					{
						return false;
81144344:	0005883a 	mov	r2,zero
81144348:	00001106 	br	81144390 <find_file_in_directory+0x468>
					}
					cluster = (new_cluster & 0x0000fff8);
8114434c:	e0bffc0b 	ldhu	r2,-16(fp)
81144350:	10bfffcc 	andi	r2,r2,65535
81144354:	10bffe0c 	andi	r2,r2,65528
81144358:	e0bfed15 	stw	r2,-76(fp)
8114435c:	00000206 	br	81144368 <find_file_in_directory+0x440>
				}
				else
                {
                    // Directory path is invalid.                 
                    return false;
81144360:	0005883a 	mov	r2,zero
81144364:	00000a06 	br	81144390 <find_file_in_directory+0x468>
                }
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
81144368:	e0bfed17 	ldw	r2,-76(fp)
8114436c:	00fffdd4 	movui	r3,65527
81144370:	18800616 	blt	r3,r2,8114438c <find_file_in_directory+0x464>
81144374:	e0bfef17 	ldw	r2,-68(fp)
81144378:	103f9926 	beq	r2,zero,811441e0 <__reset+0xfb1241e0>
8114437c:	00000306 	br	8114438c <find_file_in_directory+0x464>
                    }
                }
            }
            else
            {
                break;
81144380:	0001883a 	nop
81144384:	00000106 	br	8114438c <find_file_in_directory+0x464>
            }
            if (result)
            {
                break;
81144388:	0001883a 	nop
                }
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
    }
    
    return result;   
8114438c:	e0bfef17 	ldw	r2,-68(fp)
}
81144390:	e037883a 	mov	sp,fp
81144394:	dfc00117 	ldw	ra,4(sp)
81144398:	df000017 	ldw	fp,0(sp)
8114439c:	dec00204 	addi	sp,sp,8
811443a0:	f800283a 	ret

811443a4 <find_first_empty_cluster>:


bool find_first_empty_cluster(unsigned int *cluster_number)
// Find the first empty cluster. It will be marked by a 0 entry in the File Allocation Table.
{
811443a4:	defff504 	addi	sp,sp,-44
811443a8:	de00012e 	bgeu	sp,et,811443b0 <find_first_empty_cluster+0xc>
811443ac:	003b68fa 	trap	3
811443b0:	dfc00a15 	stw	ra,40(sp)
811443b4:	df000915 	stw	fp,36(sp)
811443b8:	df000904 	addi	fp,sp,36
811443bc:	e13fff15 	stw	r4,-4(fp)
    unsigned int sector = boot_sector_data.first_fat_sector_offset;
811443c0:	00a045f4 	movhi	r2,33047
811443c4:	10b44904 	addi	r2,r2,-11996
811443c8:	10801117 	ldw	r2,68(r2)
811443cc:	e0bff715 	stw	r2,-36(fp)
    unsigned int cluster_index = 2;
811443d0:	00800084 	movi	r2,2
811443d4:	e0bff815 	stw	r2,-32(fp)
    short int cluster = -1;
811443d8:	00bfffc4 	movi	r2,-1
811443dc:	e0bff90d 	sth	r2,-28(fp)
    bool result = false;
811443e0:	e03ffa15 	stw	zero,-24(fp)
	unsigned max_cluster_index = 0;
811443e4:	e03ffb15 	stw	zero,-20(fp)
	unsigned int non_data_sectors = boot_sector_data.data_sector_offset;
811443e8:	00a045f4 	movhi	r2,33047
811443ec:	10b44904 	addi	r2,r2,-11996
811443f0:	10801417 	ldw	r2,80(r2)
811443f4:	e0bffc15 	stw	r2,-16(fp)
	unsigned int less_than_32 = boot_sector_data.number_of_sectors_in_partition;
811443f8:	00a045f4 	movhi	r2,33047
811443fc:	10b44904 	addi	r2,r2,-11996
81144400:	1080058b 	ldhu	r2,22(r2)
81144404:	10bfffcc 	andi	r2,r2,65535
81144408:	e0bffd15 	stw	r2,-12(fp)
	unsigned int greater_than_32 = boot_sector_data.total_sector_count_if_above_32MB;
8114440c:	00a045f4 	movhi	r2,33047
81144410:	10b44904 	addi	r2,r2,-11996
81144414:	10800917 	ldw	r2,36(r2)
81144418:	e0bffe15 	stw	r2,-8(fp)

	if (less_than_32 > greater_than_32)
8114441c:	e0bffd17 	ldw	r2,-12(fp)
81144420:	e0fffe17 	ldw	r3,-8(fp)
81144424:	18800b2e 	bgeu	r3,r2,81144454 <find_first_empty_cluster+0xb0>
	{
		max_cluster_index = ((less_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
81144428:	e0fffd17 	ldw	r3,-12(fp)
8114442c:	e0bffc17 	ldw	r2,-16(fp)
81144430:	1887c83a 	sub	r3,r3,r2
81144434:	00a045f4 	movhi	r2,33047
81144438:	10b44904 	addi	r2,r2,-11996
8114443c:	10800383 	ldbu	r2,14(r2)
81144440:	10803fcc 	andi	r2,r2,255
81144444:	1885203a 	divu	r2,r3,r2
81144448:	10800044 	addi	r2,r2,1
8114444c:	e0bffb15 	stw	r2,-20(fp)
81144450:	00002a06 	br	811444fc <find_first_empty_cluster+0x158>
	}
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
81144454:	e0fffe17 	ldw	r3,-8(fp)
81144458:	e0bffc17 	ldw	r2,-16(fp)
8114445c:	1887c83a 	sub	r3,r3,r2
81144460:	00a045f4 	movhi	r2,33047
81144464:	10b44904 	addi	r2,r2,-11996
81144468:	10800383 	ldbu	r2,14(r2)
8114446c:	10803fcc 	andi	r2,r2,255
81144470:	1885203a 	divu	r2,r3,r2
81144474:	10800044 	addi	r2,r2,1
81144478:	e0bffb15 	stw	r2,-20(fp)
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
8114447c:	00001f06 	br	811444fc <find_first_empty_cluster+0x158>
    {
        if (Read_Sector_Data( sector, fat_partition_offset_in_512_byte_sectors))
81144480:	e0bff717 	ldw	r2,-36(fp)
81144484:	d0e0b117 	ldw	r3,-32060(gp)
81144488:	180b883a 	mov	r5,r3
8114448c:	1009883a 	mov	r4,r2
81144490:	11422800 	call	81142280 <Read_Sector_Data>
81144494:	10001426 	beq	r2,zero,811444e8 <find_first_empty_cluster+0x144>
        {
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
81144498:	e0bff817 	ldw	r2,-32(fp)
8114449c:	10803fcc 	andi	r2,r2,255
811444a0:	1085883a 	add	r2,r2,r2
811444a4:	1007883a 	mov	r3,r2
811444a8:	d0a0b317 	ldw	r2,-32052(gp)
811444ac:	10800a17 	ldw	r2,40(r2)
811444b0:	1885883a 	add	r2,r3,r2
811444b4:	1080002b 	ldhuio	r2,0(r2)
811444b8:	10bfffcc 	andi	r2,r2,65535
811444bc:	e0bff90d 	sth	r2,-28(fp)
                if (cluster == 0)
811444c0:	e0bff90f 	ldh	r2,-28(fp)
811444c4:	10000726 	beq	r2,zero,811444e4 <find_first_empty_cluster+0x140>
                    // Free cluster found.
                    break;
                }
                else
                {
                    cluster_index++;
811444c8:	e0bff817 	ldw	r2,-32(fp)
811444cc:	10800044 	addi	r2,r2,1
811444d0:	e0bff815 	stw	r2,-32(fp)
                } 
            } while ((cluster_index % 256) != 0);
811444d4:	e0bff817 	ldw	r2,-32(fp)
811444d8:	10803fcc 	andi	r2,r2,255
811444dc:	103fee1e 	bne	r2,zero,81144498 <__reset+0xfb124498>
811444e0:	00000106 	br	811444e8 <find_first_empty_cluster+0x144>
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
                if (cluster == 0)
                {
                    // Free cluster found.
                    break;
811444e4:	0001883a 	nop
                {
                    cluster_index++;
                } 
            } while ((cluster_index % 256) != 0);
        }
        if (cluster == 0)
811444e8:	e0bff90f 	ldh	r2,-28(fp)
811444ec:	10000926 	beq	r2,zero,81144514 <find_first_empty_cluster+0x170>
        {
            break;
        }
        sector++;
811444f0:	e0bff717 	ldw	r2,-36(fp)
811444f4:	10800044 	addi	r2,r2,1
811444f8:	e0bff715 	stw	r2,-36(fp)
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
811444fc:	00a045f4 	movhi	r2,33047
81144500:	10b44904 	addi	r2,r2,-11996
81144504:	10c01217 	ldw	r3,72(r2)
81144508:	e0bff717 	ldw	r2,-36(fp)
8114450c:	18bfdc1e 	bne	r3,r2,81144480 <__reset+0xfb124480>
81144510:	00000106 	br	81144518 <find_first_empty_cluster+0x174>
                } 
            } while ((cluster_index % 256) != 0);
        }
        if (cluster == 0)
        {
            break;
81144514:	0001883a 	nop
        }
        sector++;
    }
    if ((cluster == 0) && (cluster <= max_cluster_index))
81144518:	e0bff90f 	ldh	r2,-28(fp)
8114451c:	1000081e 	bne	r2,zero,81144540 <find_first_empty_cluster+0x19c>
81144520:	e0bff90f 	ldh	r2,-28(fp)
81144524:	e0fffb17 	ldw	r3,-20(fp)
81144528:	18800536 	bltu	r3,r2,81144540 <find_first_empty_cluster+0x19c>
    {
        *cluster_number = cluster_index;
8114452c:	e0bfff17 	ldw	r2,-4(fp)
81144530:	e0fff817 	ldw	r3,-32(fp)
81144534:	10c00015 	stw	r3,0(r2)
		result = true;
81144538:	00800044 	movi	r2,1
8114453c:	e0bffa15 	stw	r2,-24(fp)
    }
    return result;
81144540:	e0bffa17 	ldw	r2,-24(fp)
}
81144544:	e037883a 	mov	sp,fp
81144548:	dfc00117 	ldw	ra,4(sp)
8114454c:	df000017 	ldw	fp,0(sp)
81144550:	dec00204 	addi	sp,sp,8
81144554:	f800283a 	ret

81144558 <find_first_empty_record_in_a_subdirectory>:


int find_first_empty_record_in_a_subdirectory(int start_cluster_index)
// Search for a free spot in a subdirectory. Return an encoded location for the file record.
{
81144558:	defff604 	addi	sp,sp,-40
8114455c:	de00012e 	bgeu	sp,et,81144564 <find_first_empty_record_in_a_subdirectory+0xc>
81144560:	003b68fa 	trap	3
81144564:	dfc00915 	stw	ra,36(sp)
81144568:	df000815 	stw	fp,32(sp)
8114456c:	df000804 	addi	fp,sp,32
81144570:	e13fff15 	stw	r4,-4(fp)
    int result = -1;
81144574:	00bfffc4 	movi	r2,-1
81144578:	e0bff815 	stw	r2,-32(fp)
    int cluster = start_cluster_index;
8114457c:	e0bfff17 	ldw	r2,-4(fp)
81144580:	e0bff915 	stw	r2,-28(fp)
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
81144584:	e0bff917 	ldw	r2,-28(fp)
81144588:	10ffff84 	addi	r3,r2,-2
8114458c:	00a045f4 	movhi	r2,33047
81144590:	10b44904 	addi	r2,r2,-11996
81144594:	10800383 	ldbu	r2,14(r2)
81144598:	10803fcc 	andi	r2,r2,255
8114459c:	1885383a 	mul	r2,r3,r2
811445a0:	1007883a 	mov	r3,r2
811445a4:	00a045f4 	movhi	r2,33047
811445a8:	10b44904 	addi	r2,r2,-11996
811445ac:	10801417 	ldw	r2,80(r2)
811445b0:	1885883a 	add	r2,r3,r2
811445b4:	e0bffc15 	stw	r2,-16(fp)
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
811445b8:	e03ffa15 	stw	zero,-24(fp)
811445bc:	00002c06 	br	81144670 <find_first_empty_record_in_a_subdirectory+0x118>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
811445c0:	e0fffa17 	ldw	r3,-24(fp)
811445c4:	e0bffc17 	ldw	r2,-16(fp)
811445c8:	1885883a 	add	r2,r3,r2
811445cc:	d0e0b117 	ldw	r3,-32060(gp)
811445d0:	180b883a 	mov	r5,r3
811445d4:	1009883a 	mov	r4,r2
811445d8:	11422800 	call	81142280 <Read_Sector_Data>
811445dc:	10002b26 	beq	r2,zero,8114468c <find_first_empty_record_in_a_subdirectory+0x134>
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
811445e0:	e03ffb15 	stw	zero,-20(fp)
811445e4:	00001c06 	br	81144658 <find_first_empty_record_in_a_subdirectory+0x100>
                {
                    unsigned short int leading_char;
                    
                    // Read file record.
                    leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
811445e8:	e0bffb17 	ldw	r2,-20(fp)
811445ec:	1004917a 	slli	r2,r2,5
811445f0:	1007883a 	mov	r3,r2
811445f4:	d0a0b317 	ldw	r2,-32052(gp)
811445f8:	10800a17 	ldw	r2,40(r2)
811445fc:	1885883a 	add	r2,r3,r2
81144600:	10800023 	ldbuio	r2,0(r2)
81144604:	10803fcc 	andi	r2,r2,255
81144608:	10803fcc 	andi	r2,r2,255
8114460c:	e0bffd0d 	sth	r2,-12(fp)
                    if ((leading_char == 0x00e5) || (leading_char == 0))
81144610:	e0bffd0b 	ldhu	r2,-12(fp)
81144614:	10803960 	cmpeqi	r2,r2,229
81144618:	1000021e 	bne	r2,zero,81144624 <find_first_empty_record_in_a_subdirectory+0xcc>
8114461c:	e0bffd0b 	ldhu	r2,-12(fp)
81144620:	10000a1e 	bne	r2,zero,8114464c <find_first_empty_record_in_a_subdirectory+0xf4>
                    {
                        result = (cluster) | ((sector_index*16 + file_counter) << 16);
81144624:	e0bffa17 	ldw	r2,-24(fp)
81144628:	1006913a 	slli	r3,r2,4
8114462c:	e0bffb17 	ldw	r2,-20(fp)
81144630:	1885883a 	add	r2,r3,r2
81144634:	1006943a 	slli	r3,r2,16
81144638:	e0bff917 	ldw	r2,-28(fp)
8114463c:	1884b03a 	or	r2,r3,r2
81144640:	e0bff815 	stw	r2,-32(fp)
                        return result;
81144644:	e0bff817 	ldw	r2,-32(fp)
81144648:	00005306 	br	81144798 <find_first_empty_record_in_a_subdirectory+0x240>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
8114464c:	e0bffb17 	ldw	r2,-20(fp)
81144650:	10800044 	addi	r2,r2,1
81144654:	e0bffb15 	stw	r2,-20(fp)
81144658:	e0bffb17 	ldw	r2,-20(fp)
8114465c:	10800410 	cmplti	r2,r2,16
81144660:	103fe11e 	bne	r2,zero,811445e8 <__reset+0xfb1245e8>
    int cluster = start_cluster_index;
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81144664:	e0bffa17 	ldw	r2,-24(fp)
81144668:	10800044 	addi	r2,r2,1
8114466c:	e0bffa15 	stw	r2,-24(fp)
81144670:	00a045f4 	movhi	r2,33047
81144674:	10b44904 	addi	r2,r2,-11996
81144678:	10800383 	ldbu	r2,14(r2)
8114467c:	10803fcc 	andi	r2,r2,255
81144680:	e0fffa17 	ldw	r3,-24(fp)
81144684:	18bfce16 	blt	r3,r2,811445c0 <__reset+0xfb1245c0>
81144688:	00000106 	br	81144690 <find_first_empty_record_in_a_subdirectory+0x138>
                    }
                }
            }
            else
            {
                break;
8114468c:	0001883a 	nop
            }
        }
        // If this is the end of the cluster and the file has not been found, then see if there is another cluster
        // that holds data for the current directory.
        if (result < 0)
81144690:	e0bff817 	ldw	r2,-32(fp)
81144694:	1000390e 	bge	r2,zero,8114477c <find_first_empty_record_in_a_subdirectory+0x224>
        {
			unsigned short int new_cluster;
			if (get_cluster_flag(cluster, &new_cluster))
81144698:	e0bff917 	ldw	r2,-28(fp)
8114469c:	e0fffd84 	addi	r3,fp,-10
811446a0:	180b883a 	mov	r5,r3
811446a4:	1009883a 	mov	r4,r2
811446a8:	11423600 	call	81142360 <get_cluster_flag>
811446ac:	10003126 	beq	r2,zero,81144774 <find_first_empty_record_in_a_subdirectory+0x21c>
			{
                // The directory needs to be expanded to store more files.
				if ((new_cluster & 0x0000fff8) == 0x0000fff8)
811446b0:	e0bffd8b 	ldhu	r2,-10(fp)
811446b4:	10bfffcc 	andi	r2,r2,65535
811446b8:	10fffe0c 	andi	r3,r2,65528
811446bc:	00bffe14 	movui	r2,65528
811446c0:	18802e1e 	bne	r3,r2,8114477c <find_first_empty_record_in_a_subdirectory+0x224>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
811446c4:	e0bffe04 	addi	r2,fp,-8
811446c8:	1009883a 	mov	r4,r2
811446cc:	11443a40 	call	811443a4 <find_first_empty_cluster>
811446d0:	10002326 	beq	r2,zero,81144760 <find_first_empty_record_in_a_subdirectory+0x208>
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
811446d4:	e0bff917 	ldw	r2,-28(fp)
811446d8:	e0fffe17 	ldw	r3,-8(fp)
811446dc:	18ffffcc 	andi	r3,r3,65535
811446e0:	18e0001c 	xori	r3,r3,32768
811446e4:	18e00004 	addi	r3,r3,-32768
811446e8:	01800044 	movi	r6,1
811446ec:	180b883a 	mov	r5,r3
811446f0:	1009883a 	mov	r4,r2
811446f4:	114241c0 	call	8114241c <mark_cluster>
811446f8:	10001926 	beq	r2,zero,81144760 <find_first_empty_record_in_a_subdirectory+0x208>
811446fc:	e0bffe17 	ldw	r2,-8(fp)
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
81144700:	01800044 	movi	r6,1
81144704:	017fffc4 	movi	r5,-1
81144708:	1009883a 	mov	r4,r2
8114470c:	114241c0 	call	8114241c <mark_cluster>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
81144710:	10001326 	beq	r2,zero,81144760 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
81144714:	e0bff917 	ldw	r2,-28(fp)
81144718:	e0fffe17 	ldw	r3,-8(fp)
8114471c:	18ffffcc 	andi	r3,r3,65535
81144720:	18e0001c 	xori	r3,r3,32768
81144724:	18e00004 	addi	r3,r3,-32768
81144728:	000d883a 	mov	r6,zero
8114472c:	180b883a 	mov	r5,r3
81144730:	1009883a 	mov	r4,r2
81144734:	114241c0 	call	8114241c <mark_cluster>
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
81144738:	10000926 	beq	r2,zero,81144760 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
8114473c:	e0bffe17 	ldw	r2,-8(fp)
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
81144740:	000d883a 	mov	r6,zero
81144744:	017fffc4 	movi	r5,-1
81144748:	1009883a 	mov	r4,r2
8114474c:	114241c0 	call	8114241c <mark_cluster>
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
81144750:	10000326 	beq	r2,zero,81144760 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
						{
							Save_Modified_Sector();
81144754:	114222c0 	call	8114222c <Save_Modified_Sector>
							// The new file will begin at the first entry of the directory.
							result = new_dir_cluster;                           
81144758:	e0bffe17 	ldw	r2,-8(fp)
8114475c:	e0bff815 	stw	r2,-32(fp)
						}
					}
					cluster = (new_cluster & 0x0000fff8);
81144760:	e0bffd8b 	ldhu	r2,-10(fp)
81144764:	10bfffcc 	andi	r2,r2,65535
81144768:	10bffe0c 	andi	r2,r2,65528
8114476c:	e0bff915 	stw	r2,-28(fp)
81144770:	00000206 	br	8114477c <find_first_empty_record_in_a_subdirectory+0x224>
				}
			}
			else
			{
				// Error encountered.                 
				result = -1;
81144774:	00bfffc4 	movi	r2,-1
81144778:	e0bff815 	stw	r2,-32(fp)
			}
        }              
    } while ((cluster < 0x0000fff8) && (result == -1)); 
8114477c:	e0bff917 	ldw	r2,-28(fp)
81144780:	00fffdd4 	movui	r3,65527
81144784:	18800316 	blt	r3,r2,81144794 <find_first_empty_record_in_a_subdirectory+0x23c>
81144788:	e0bff817 	ldw	r2,-32(fp)
8114478c:	10bfffe0 	cmpeqi	r2,r2,-1
81144790:	103f7c1e 	bne	r2,zero,81144584 <__reset+0xfb124584>
    return result; 
81144794:	e0bff817 	ldw	r2,-32(fp)
}
81144798:	e037883a 	mov	sp,fp
8114479c:	dfc00117 	ldw	ra,4(sp)
811447a0:	df000017 	ldw	fp,0(sp)
811447a4:	dec00204 	addi	sp,sp,8
811447a8:	f800283a 	ret

811447ac <find_first_empty_record_in_root_directory>:


int find_first_empty_record_in_root_directory()
// Find a first unused record location to use. Return -1 if none is found.
{
811447ac:	defff904 	addi	sp,sp,-28
811447b0:	de00012e 	bgeu	sp,et,811447b8 <find_first_empty_record_in_root_directory+0xc>
811447b4:	003b68fa 	trap	3
811447b8:	dfc00615 	stw	ra,24(sp)
811447bc:	df000515 	stw	fp,20(sp)
811447c0:	df000504 	addi	fp,sp,20
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
811447c4:	00a045f4 	movhi	r2,33047
811447c8:	10b44904 	addi	r2,r2,-11996
811447cc:	1080050b 	ldhu	r2,20(r2)
811447d0:	10bfffcc 	andi	r2,r2,65535
811447d4:	1006917a 	slli	r3,r2,5
811447d8:	00a045f4 	movhi	r2,33047
811447dc:	10b44904 	addi	r2,r2,-11996
811447e0:	1080030b 	ldhu	r2,12(r2)
811447e4:	10bfffcc 	andi	r2,r2,65535
811447e8:	1885283a 	div	r2,r3,r2
811447ec:	e0bffd15 	stw	r2,-12(fp)
    int sector_index;
    int result = -1;
811447f0:	00bfffc4 	movi	r2,-1
811447f4:	e0bffe15 	stw	r2,-8(fp)
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
811447f8:	e03ffb15 	stw	zero,-20(fp)
811447fc:	00002d06 	br	811448b4 <find_first_empty_record_in_root_directory+0x108>
    {
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
81144800:	00a045f4 	movhi	r2,33047
81144804:	10b44904 	addi	r2,r2,-11996
81144808:	10c01317 	ldw	r3,76(r2)
8114480c:	e0bffb17 	ldw	r2,-20(fp)
81144810:	1885883a 	add	r2,r3,r2
81144814:	1007883a 	mov	r3,r2
81144818:	d0a0b117 	ldw	r2,-32060(gp)
8114481c:	100b883a 	mov	r5,r2
81144820:	1809883a 	mov	r4,r3
81144824:	11422800 	call	81142280 <Read_Sector_Data>
81144828:	10002626 	beq	r2,zero,811448c4 <find_first_empty_record_in_root_directory+0x118>
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
8114482c:	e03ffc15 	stw	zero,-16(fp)
81144830:	00001a06 	br	8114489c <find_first_empty_record_in_root_directory+0xf0>
            {
                unsigned short int leading_char;
                
                // Read first character of the file record.
                leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
81144834:	e0bffc17 	ldw	r2,-16(fp)
81144838:	1004917a 	slli	r2,r2,5
8114483c:	1007883a 	mov	r3,r2
81144840:	d0a0b317 	ldw	r2,-32052(gp)
81144844:	10800a17 	ldw	r2,40(r2)
81144848:	1885883a 	add	r2,r3,r2
8114484c:	10800023 	ldbuio	r2,0(r2)
81144850:	10803fcc 	andi	r2,r2,255
81144854:	10803fcc 	andi	r2,r2,255
81144858:	e0bfff0d 	sth	r2,-4(fp)
                if ((leading_char == 0x00e5) || (leading_char == 0))
8114485c:	e0bfff0b 	ldhu	r2,-4(fp)
81144860:	10803960 	cmpeqi	r2,r2,229
81144864:	1000021e 	bne	r2,zero,81144870 <find_first_empty_record_in_root_directory+0xc4>
81144868:	e0bfff0b 	ldhu	r2,-4(fp)
8114486c:	1000081e 	bne	r2,zero,81144890 <find_first_empty_record_in_root_directory+0xe4>
                {
                    result = (sector_index*16 + file_counter) << 16;
81144870:	e0bffb17 	ldw	r2,-20(fp)
81144874:	1006913a 	slli	r3,r2,4
81144878:	e0bffc17 	ldw	r2,-16(fp)
8114487c:	1885883a 	add	r2,r3,r2
81144880:	1004943a 	slli	r2,r2,16
81144884:	e0bffe15 	stw	r2,-8(fp)
                    return result;
81144888:	e0bffe17 	ldw	r2,-8(fp)
8114488c:	00000f06 	br	811448cc <find_first_empty_record_in_root_directory+0x120>
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
81144890:	e0bffc17 	ldw	r2,-16(fp)
81144894:	10800044 	addi	r2,r2,1
81144898:	e0bffc15 	stw	r2,-16(fp)
8114489c:	e0bffc17 	ldw	r2,-16(fp)
811448a0:	10800410 	cmplti	r2,r2,16
811448a4:	103fe31e 	bne	r2,zero,81144834 <__reset+0xfb124834>
{
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    int sector_index;
    int result = -1;
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
811448a8:	e0bffb17 	ldw	r2,-20(fp)
811448ac:	10800044 	addi	r2,r2,1
811448b0:	e0bffb15 	stw	r2,-20(fp)
811448b4:	e0fffb17 	ldw	r3,-20(fp)
811448b8:	e0bffd17 	ldw	r2,-12(fp)
811448bc:	18bfd016 	blt	r3,r2,81144800 <__reset+0xfb124800>
811448c0:	00000106 	br	811448c8 <find_first_empty_record_in_root_directory+0x11c>
                }
            }
        }
        else
        {
            break;
811448c4:	0001883a 	nop
        }
    }
    return result;
811448c8:	e0bffe17 	ldw	r2,-8(fp)
}
811448cc:	e037883a 	mov	sp,fp
811448d0:	dfc00117 	ldw	ra,4(sp)
811448d4:	df000017 	ldw	fp,0(sp)
811448d8:	dec00204 	addi	sp,sp,8
811448dc:	f800283a 	ret

811448e0 <convert_filename_to_name_extension>:

void convert_filename_to_name_extension(char *filename, char *name, char *extension)
// This function converts the file name into a name . extension format.
{
811448e0:	defffa04 	addi	sp,sp,-24
811448e4:	de00012e 	bgeu	sp,et,811448ec <convert_filename_to_name_extension+0xc>
811448e8:	003b68fa 	trap	3
811448ec:	df000515 	stw	fp,20(sp)
811448f0:	df000504 	addi	fp,sp,20
811448f4:	e13ffd15 	stw	r4,-12(fp)
811448f8:	e17ffe15 	stw	r5,-8(fp)
811448fc:	e1bfff15 	stw	r6,-4(fp)
    int counter;
    int local = 0;
81144900:	e03ffc15 	stw	zero,-16(fp)
    
    for(counter = 0; counter < 8; counter++)
81144904:	e03ffb15 	stw	zero,-20(fp)
81144908:	00002506 	br	811449a0 <convert_filename_to_name_extension+0xc0>
    {
        if (filename[local] != '.')
8114490c:	e0bffc17 	ldw	r2,-16(fp)
81144910:	e0fffd17 	ldw	r3,-12(fp)
81144914:	1885883a 	add	r2,r3,r2
81144918:	10800003 	ldbu	r2,0(r2)
8114491c:	10803fcc 	andi	r2,r2,255
81144920:	1080201c 	xori	r2,r2,128
81144924:	10bfe004 	addi	r2,r2,-128
81144928:	10800ba0 	cmpeqi	r2,r2,46
8114492c:	1000141e 	bne	r2,zero,81144980 <convert_filename_to_name_extension+0xa0>
        {
            name[counter] = filename[local];
81144930:	e0bffb17 	ldw	r2,-20(fp)
81144934:	e0fffe17 	ldw	r3,-8(fp)
81144938:	1885883a 	add	r2,r3,r2
8114493c:	e0fffc17 	ldw	r3,-16(fp)
81144940:	e13ffd17 	ldw	r4,-12(fp)
81144944:	20c7883a 	add	r3,r4,r3
81144948:	18c00003 	ldbu	r3,0(r3)
8114494c:	10c00005 	stb	r3,0(r2)
            if (filename[local] != 0) local++;
81144950:	e0bffc17 	ldw	r2,-16(fp)
81144954:	e0fffd17 	ldw	r3,-12(fp)
81144958:	1885883a 	add	r2,r3,r2
8114495c:	10800003 	ldbu	r2,0(r2)
81144960:	10803fcc 	andi	r2,r2,255
81144964:	1080201c 	xori	r2,r2,128
81144968:	10bfe004 	addi	r2,r2,-128
8114496c:	10000926 	beq	r2,zero,81144994 <convert_filename_to_name_extension+0xb4>
81144970:	e0bffc17 	ldw	r2,-16(fp)
81144974:	10800044 	addi	r2,r2,1
81144978:	e0bffc15 	stw	r2,-16(fp)
8114497c:	00000506 	br	81144994 <convert_filename_to_name_extension+0xb4>
        }
        else
        {
            name[counter] = ' ';
81144980:	e0bffb17 	ldw	r2,-20(fp)
81144984:	e0fffe17 	ldw	r3,-8(fp)
81144988:	1885883a 	add	r2,r3,r2
8114498c:	00c00804 	movi	r3,32
81144990:	10c00005 	stb	r3,0(r2)
// This function converts the file name into a name . extension format.
{
    int counter;
    int local = 0;
    
    for(counter = 0; counter < 8; counter++)
81144994:	e0bffb17 	ldw	r2,-20(fp)
81144998:	10800044 	addi	r2,r2,1
8114499c:	e0bffb15 	stw	r2,-20(fp)
811449a0:	e0bffb17 	ldw	r2,-20(fp)
811449a4:	10800210 	cmplti	r2,r2,8
811449a8:	103fd81e 	bne	r2,zero,8114490c <__reset+0xfb12490c>
        else
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
811449ac:	e0bffc17 	ldw	r2,-16(fp)
811449b0:	e0fffd17 	ldw	r3,-12(fp)
811449b4:	1885883a 	add	r2,r3,r2
811449b8:	10800003 	ldbu	r2,0(r2)
811449bc:	10803fcc 	andi	r2,r2,255
811449c0:	1080201c 	xori	r2,r2,128
811449c4:	10bfe004 	addi	r2,r2,-128
811449c8:	10800b98 	cmpnei	r2,r2,46
811449cc:	1000031e 	bne	r2,zero,811449dc <convert_filename_to_name_extension+0xfc>
811449d0:	e0bffc17 	ldw	r2,-16(fp)
811449d4:	10800044 	addi	r2,r2,1
811449d8:	e0bffc15 	stw	r2,-16(fp)
    for(counter = 0; counter < 3; counter++)
811449dc:	e03ffb15 	stw	zero,-20(fp)
811449e0:	00001c06 	br	81144a54 <convert_filename_to_name_extension+0x174>
    {
        if (filename[local] != 0)
811449e4:	e0bffc17 	ldw	r2,-16(fp)
811449e8:	e0fffd17 	ldw	r3,-12(fp)
811449ec:	1885883a 	add	r2,r3,r2
811449f0:	10800003 	ldbu	r2,0(r2)
811449f4:	10803fcc 	andi	r2,r2,255
811449f8:	1080201c 	xori	r2,r2,128
811449fc:	10bfe004 	addi	r2,r2,-128
81144a00:	10000c26 	beq	r2,zero,81144a34 <convert_filename_to_name_extension+0x154>
        {
            extension[counter] = filename[local];
81144a04:	e0bffb17 	ldw	r2,-20(fp)
81144a08:	e0ffff17 	ldw	r3,-4(fp)
81144a0c:	1885883a 	add	r2,r3,r2
81144a10:	e0fffc17 	ldw	r3,-16(fp)
81144a14:	e13ffd17 	ldw	r4,-12(fp)
81144a18:	20c7883a 	add	r3,r4,r3
81144a1c:	18c00003 	ldbu	r3,0(r3)
81144a20:	10c00005 	stb	r3,0(r2)
            local++;
81144a24:	e0bffc17 	ldw	r2,-16(fp)
81144a28:	10800044 	addi	r2,r2,1
81144a2c:	e0bffc15 	stw	r2,-16(fp)
81144a30:	00000506 	br	81144a48 <convert_filename_to_name_extension+0x168>
        }
        else
        {
            extension[counter] = ' ';
81144a34:	e0bffb17 	ldw	r2,-20(fp)
81144a38:	e0ffff17 	ldw	r3,-4(fp)
81144a3c:	1885883a 	add	r2,r3,r2
81144a40:	00c00804 	movi	r3,32
81144a44:	10c00005 	stb	r3,0(r2)
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
    for(counter = 0; counter < 3; counter++)
81144a48:	e0bffb17 	ldw	r2,-20(fp)
81144a4c:	10800044 	addi	r2,r2,1
81144a50:	e0bffb15 	stw	r2,-20(fp)
81144a54:	e0bffb17 	ldw	r2,-20(fp)
81144a58:	108000d0 	cmplti	r2,r2,3
81144a5c:	103fe11e 	bne	r2,zero,811449e4 <__reset+0xfb1249e4>
        {
            extension[counter] = ' ';
        }
    }

}
81144a60:	0001883a 	nop
81144a64:	e037883a 	mov	sp,fp
81144a68:	df000017 	ldw	fp,0(sp)
81144a6c:	dec00104 	addi	sp,sp,4
81144a70:	f800283a 	ret

81144a74 <create_file>:

bool create_file(char *name, t_file_record *file_record, t_file_record *home_dir)
// Create a file in a given directory. Expand the directory if needed.
{
81144a74:	defff504 	addi	sp,sp,-44
81144a78:	de00012e 	bgeu	sp,et,81144a80 <create_file+0xc>
81144a7c:	003b68fa 	trap	3
81144a80:	dfc00a15 	stw	ra,40(sp)
81144a84:	df000915 	stw	fp,36(sp)
81144a88:	df000904 	addi	fp,sp,36
81144a8c:	e13ffd15 	stw	r4,-12(fp)
81144a90:	e17ffe15 	stw	r5,-8(fp)
81144a94:	e1bfff15 	stw	r6,-4(fp)
    unsigned int cluster_number;
    bool result = false;
81144a98:	e03ff715 	stw	zero,-36(fp)
    
    if (find_first_empty_cluster(&cluster_number))
81144a9c:	e0bffc04 	addi	r2,fp,-16
81144aa0:	1009883a 	mov	r4,r2
81144aa4:	11443a40 	call	811443a4 <find_first_empty_cluster>
81144aa8:	1000a026 	beq	r2,zero,81144d2c <create_file+0x2b8>
    {
        int record_index;
        
        if (home_dir->file_record_cluster == 0)
81144aac:	e0bfff17 	ldw	r2,-4(fp)
81144ab0:	10800a17 	ldw	r2,40(r2)
81144ab4:	1000031e 	bne	r2,zero,81144ac4 <create_file+0x50>
        {
            // Put a file in the root directory.
            record_index = find_first_empty_record_in_root_directory();
81144ab8:	11447ac0 	call	811447ac <find_first_empty_record_in_root_directory>
81144abc:	e0bff815 	stw	r2,-32(fp)
81144ac0:	00000606 	br	81144adc <create_file+0x68>
        }
        else
        {
            // Put a file in a subdirectory.
            record_index = find_first_empty_record_in_a_subdirectory(home_dir->start_cluster_index);           
81144ac4:	e0bfff17 	ldw	r2,-4(fp)
81144ac8:	1080058b 	ldhu	r2,22(r2)
81144acc:	10bfffcc 	andi	r2,r2,65535
81144ad0:	1009883a 	mov	r4,r2
81144ad4:	11445580 	call	81144558 <find_first_empty_record_in_a_subdirectory>
81144ad8:	e0bff815 	stw	r2,-32(fp)
        }
        if (record_index >= 0)
81144adc:	e0bff817 	ldw	r2,-32(fp)
81144ae0:	10009216 	blt	r2,zero,81144d2c <create_file+0x2b8>
        {   
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
81144ae4:	e13ffd17 	ldw	r4,-12(fp)
81144ae8:	11436840 	call	81143684 <get_dir_divider_location>
81144aec:	e0bff915 	stw	r2,-28(fp)
            int last_dir_separator = 0;
81144af0:	e03ffa15 	stw	zero,-24(fp)

            // Skip through all directory separators.
            while (location > 0)
81144af4:	00000b06 	br	81144b24 <create_file+0xb0>
            {
                last_dir_separator = last_dir_separator+location+1;
81144af8:	e0fffa17 	ldw	r3,-24(fp)
81144afc:	e0bff917 	ldw	r2,-28(fp)
81144b00:	1885883a 	add	r2,r3,r2
81144b04:	10800044 	addi	r2,r2,1
81144b08:	e0bffa15 	stw	r2,-24(fp)
                location = get_dir_divider_location( &(name[last_dir_separator]) );
81144b0c:	e0bffa17 	ldw	r2,-24(fp)
81144b10:	e0fffd17 	ldw	r3,-12(fp)
81144b14:	1885883a 	add	r2,r3,r2
81144b18:	1009883a 	mov	r4,r2
81144b1c:	11436840 	call	81143684 <get_dir_divider_location>
81144b20:	e0bff915 	stw	r2,-28(fp)
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
            int last_dir_separator = 0;

            // Skip through all directory separators.
            while (location > 0)
81144b24:	e0bff917 	ldw	r2,-28(fp)
81144b28:	00bff316 	blt	zero,r2,81144af8 <__reset+0xfb124af8>
            {
                last_dir_separator = last_dir_separator+location+1;
                location = get_dir_divider_location( &(name[last_dir_separator]) );
            }
            
            convert_filename_to_name_extension(&(name[last_dir_separator]), (char *)file_record->name, (char *)file_record->extension);
81144b2c:	e0bffa17 	ldw	r2,-24(fp)
81144b30:	e0fffd17 	ldw	r3,-12(fp)
81144b34:	1887883a 	add	r3,r3,r2
81144b38:	e13ffe17 	ldw	r4,-8(fp)
81144b3c:	e0bffe17 	ldw	r2,-8(fp)
81144b40:	10800204 	addi	r2,r2,8
81144b44:	100d883a 	mov	r6,r2
81144b48:	200b883a 	mov	r5,r4
81144b4c:	1809883a 	mov	r4,r3
81144b50:	11448e00 	call	811448e0 <convert_filename_to_name_extension>
                         
            file_record->attributes = 0;
81144b54:	e0bffe17 	ldw	r2,-8(fp)
81144b58:	100002c5 	stb	zero,11(r2)
            file_record->create_time = 0;
81144b5c:	e0bffe17 	ldw	r2,-8(fp)
81144b60:	1000030d 	sth	zero,12(r2)
            file_record->create_date = 0;
81144b64:	e0bffe17 	ldw	r2,-8(fp)
81144b68:	1000038d 	sth	zero,14(r2)
            file_record->last_access_date = 0;
81144b6c:	e0bffe17 	ldw	r2,-8(fp)
81144b70:	1000040d 	sth	zero,16(r2)
            file_record->last_modified_time = 0;
81144b74:	e0bffe17 	ldw	r2,-8(fp)
81144b78:	1000048d 	sth	zero,18(r2)
            file_record->last_modified_date = 0;
81144b7c:	e0bffe17 	ldw	r2,-8(fp)
81144b80:	1000050d 	sth	zero,20(r2)
            file_record->start_cluster_index = cluster_number;
81144b84:	e0bffc17 	ldw	r2,-16(fp)
81144b88:	1007883a 	mov	r3,r2
81144b8c:	e0bffe17 	ldw	r2,-8(fp)
81144b90:	10c0058d 	sth	r3,22(r2)
            file_record->file_size_in_bytes = 0;
81144b94:	e0bffe17 	ldw	r2,-8(fp)
81144b98:	10000615 	stw	zero,24(r2)
            file_record->current_cluster_index = cluster_number;
81144b9c:	e0fffc17 	ldw	r3,-16(fp)
81144ba0:	e0bffe17 	ldw	r2,-8(fp)
81144ba4:	10c00715 	stw	r3,28(r2)
            file_record->current_sector_in_cluster = 0;
81144ba8:	e0bffe17 	ldw	r2,-8(fp)
81144bac:	10000815 	stw	zero,32(r2)
            file_record->current_byte_position = 0;
81144bb0:	e0bffe17 	ldw	r2,-8(fp)
81144bb4:	10000915 	stw	zero,36(r2)
            file_record->file_record_cluster = record_index & 0x0000ffff;
81144bb8:	e0bff817 	ldw	r2,-32(fp)
81144bbc:	10ffffcc 	andi	r3,r2,65535
81144bc0:	e0bffe17 	ldw	r2,-8(fp)
81144bc4:	10c00a15 	stw	r3,40(r2)
            file_record->file_record_sector_in_cluster = ((record_index >> 16) & 0x0000ffff) / 16;
81144bc8:	e0bff817 	ldw	r2,-32(fp)
81144bcc:	1004d43a 	srli	r2,r2,16
81144bd0:	1000010e 	bge	r2,zero,81144bd8 <create_file+0x164>
81144bd4:	108003c4 	addi	r2,r2,15
81144bd8:	1005d13a 	srai	r2,r2,4
81144bdc:	1007883a 	mov	r3,r2
81144be0:	e0bffe17 	ldw	r2,-8(fp)
81144be4:	10c00b15 	stw	r3,44(r2)
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
81144be8:	e0bff817 	ldw	r2,-32(fp)
81144bec:	1004d43a 	srli	r2,r2,16
81144bf0:	1007883a 	mov	r3,r2
81144bf4:	00a00034 	movhi	r2,32768
81144bf8:	108003c4 	addi	r2,r2,15
81144bfc:	1884703a 	and	r2,r3,r2
81144c00:	1000040e 	bge	r2,zero,81144c14 <create_file+0x1a0>
81144c04:	10bfffc4 	addi	r2,r2,-1
81144c08:	00fffc04 	movi	r3,-16
81144c0c:	10c4b03a 	or	r2,r2,r3
81144c10:	10800044 	addi	r2,r2,1
81144c14:	1004917a 	slli	r2,r2,5
81144c18:	1007883a 	mov	r3,r2
81144c1c:	e0bffe17 	ldw	r2,-8(fp)
81144c20:	10c00c0d 	sth	r3,48(r2)
            file_record->home_directory_cluster = home_dir->start_cluster_index;
81144c24:	e0bfff17 	ldw	r2,-4(fp)
81144c28:	1080058b 	ldhu	r2,22(r2)
81144c2c:	10ffffcc 	andi	r3,r2,65535
81144c30:	e0bffe17 	ldw	r2,-8(fp)
81144c34:	10c00d15 	stw	r3,52(r2)
            file_record->in_use = true;
81144c38:	e0bffe17 	ldw	r2,-8(fp)
81144c3c:	00c00044 	movi	r3,1
81144c40:	10c00f15 	stw	r3,60(r2)
            file_record->modified = true;
81144c44:	e0bffe17 	ldw	r2,-8(fp)
81144c48:	00c00044 	movi	r3,1
81144c4c:	10c00e15 	stw	r3,56(r2)
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
81144c50:	e0bffe17 	ldw	r2,-8(fp)
81144c54:	10800a17 	ldw	r2,40(r2)
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
81144c58:	1000071e 	bne	r2,zero,81144c78 <create_file+0x204>
81144c5c:	00a045f4 	movhi	r2,33047
81144c60:	10b44904 	addi	r2,r2,-11996
81144c64:	10c01317 	ldw	r3,76(r2)
81144c68:	e0bffe17 	ldw	r2,-8(fp)
81144c6c:	10800b17 	ldw	r2,44(r2)
81144c70:	1885883a 	add	r2,r3,r2
81144c74:	00000f06 	br	81144cb4 <create_file+0x240>
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
81144c78:	00a045f4 	movhi	r2,33047
81144c7c:	10b44904 	addi	r2,r2,-11996
81144c80:	10c01417 	ldw	r3,80(r2)
81144c84:	e0bffe17 	ldw	r2,-8(fp)
81144c88:	10800a17 	ldw	r2,40(r2)
81144c8c:	113fff84 	addi	r4,r2,-2
81144c90:	00a045f4 	movhi	r2,33047
81144c94:	10b44904 	addi	r2,r2,-11996
81144c98:	10800383 	ldbu	r2,14(r2)
81144c9c:	10803fcc 	andi	r2,r2,255
81144ca0:	2085383a 	mul	r2,r4,r2
81144ca4:	1887883a 	add	r3,r3,r2
                                     file_record->file_record_sector_in_cluster);
81144ca8:	e0bffe17 	ldw	r2,-8(fp)
81144cac:	10800b17 	ldw	r2,44(r2)
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
            file_record->modified = true;
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
81144cb0:	1885883a 	add	r2,r3,r2
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
            file_record->modified = true;
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
81144cb4:	e0bffb15 	stw	r2,-20(fp)
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
                                     file_record->file_record_sector_in_cluster);

			if (Read_Sector_Data(file_record_sector, fat_partition_offset_in_512_byte_sectors))
81144cb8:	e0bffb17 	ldw	r2,-20(fp)
81144cbc:	d0e0b117 	ldw	r3,-32060(gp)
81144cc0:	180b883a 	mov	r5,r3
81144cc4:	1009883a 	mov	r4,r2
81144cc8:	11422800 	call	81142280 <Read_Sector_Data>
81144ccc:	10001726 	beq	r2,zero,81144d2c <create_file+0x2b8>
            {
                if (Write_File_Record_At_Offset(file_record->file_record_offset, file_record))
81144cd0:	e0bffe17 	ldw	r2,-8(fp)
81144cd4:	10800c0b 	ldhu	r2,48(r2)
81144cd8:	10bfffcc 	andi	r2,r2,65535
81144cdc:	10a0001c 	xori	r2,r2,32768
81144ce0:	10a00004 	addi	r2,r2,-32768
81144ce4:	e17ffe17 	ldw	r5,-8(fp)
81144ce8:	1009883a 	mov	r4,r2
81144cec:	11429340 	call	81142934 <Write_File_Record_At_Offset>
81144cf0:	10000e26 	beq	r2,zero,81144d2c <create_file+0x2b8>
                {
                    Save_Modified_Sector();
81144cf4:	114222c0 	call	8114222c <Save_Modified_Sector>
                    // Mark the first cluster of the file as the last cluster at first.
                    mark_cluster(cluster_number, ((short int) (0xffff)), true);
81144cf8:	e0bffc17 	ldw	r2,-16(fp)
81144cfc:	01800044 	movi	r6,1
81144d00:	017fffc4 	movi	r5,-1
81144d04:	1009883a 	mov	r4,r2
81144d08:	114241c0 	call	8114241c <mark_cluster>
                    if (mark_cluster(cluster_number, ((short int) (0xffff)), false))
81144d0c:	e0bffc17 	ldw	r2,-16(fp)
81144d10:	000d883a 	mov	r6,zero
81144d14:	017fffc4 	movi	r5,-1
81144d18:	1009883a 	mov	r4,r2
81144d1c:	114241c0 	call	8114241c <mark_cluster>
81144d20:	10000226 	beq	r2,zero,81144d2c <create_file+0x2b8>
                    {
                        result = true;
81144d24:	00800044 	movi	r2,1
81144d28:	e0bff715 	stw	r2,-36(fp)
                }
            }
        }

    }
    return result;           
81144d2c:	e0bff717 	ldw	r2,-36(fp)
}
81144d30:	e037883a 	mov	sp,fp
81144d34:	dfc00117 	ldw	ra,4(sp)
81144d38:	df000017 	ldw	fp,0(sp)
81144d3c:	dec00204 	addi	sp,sp,8
81144d40:	f800283a 	ret

81144d44 <copy_file_record_name_to_string>:


void copy_file_record_name_to_string(t_file_record *file_record, char *file_name)
/* Copy a file name from the file record to a given string */
{
81144d44:	defffb04 	addi	sp,sp,-20
81144d48:	de00012e 	bgeu	sp,et,81144d50 <copy_file_record_name_to_string+0xc>
81144d4c:	003b68fa 	trap	3
81144d50:	df000415 	stw	fp,16(sp)
81144d54:	df000404 	addi	fp,sp,16
81144d58:	e13ffe15 	stw	r4,-8(fp)
81144d5c:	e17fff15 	stw	r5,-4(fp)
	int index;
	int flength = 0;
81144d60:	e03ffd15 	stw	zero,-12(fp)

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
81144d64:	e03ffc15 	stw	zero,-16(fp)
81144d68:	00001506 	br	81144dc0 <copy_file_record_name_to_string+0x7c>
	{
		if (file_record->name[index] != ' ')
81144d6c:	e0fffe17 	ldw	r3,-8(fp)
81144d70:	e0bffc17 	ldw	r2,-16(fp)
81144d74:	1885883a 	add	r2,r3,r2
81144d78:	10800003 	ldbu	r2,0(r2)
81144d7c:	10803fcc 	andi	r2,r2,255
81144d80:	10800820 	cmpeqi	r2,r2,32
81144d84:	10000b1e 	bne	r2,zero,81144db4 <copy_file_record_name_to_string+0x70>
		{
			file_name[flength] = file_record->name[index];
81144d88:	e0bffd17 	ldw	r2,-12(fp)
81144d8c:	e0ffff17 	ldw	r3,-4(fp)
81144d90:	1885883a 	add	r2,r3,r2
81144d94:	e13ffe17 	ldw	r4,-8(fp)
81144d98:	e0fffc17 	ldw	r3,-16(fp)
81144d9c:	20c7883a 	add	r3,r4,r3
81144da0:	18c00003 	ldbu	r3,0(r3)
81144da4:	10c00005 	stb	r3,0(r2)
			flength = flength + 1;
81144da8:	e0bffd17 	ldw	r2,-12(fp)
81144dac:	10800044 	addi	r2,r2,1
81144db0:	e0bffd15 	stw	r2,-12(fp)
{
	int index;
	int flength = 0;

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
81144db4:	e0bffc17 	ldw	r2,-16(fp)
81144db8:	10800044 	addi	r2,r2,1
81144dbc:	e0bffc15 	stw	r2,-16(fp)
81144dc0:	e0bffc17 	ldw	r2,-16(fp)
81144dc4:	10800210 	cmplti	r2,r2,8
81144dc8:	103fe81e 	bne	r2,zero,81144d6c <__reset+0xfb124d6c>
		{
			file_name[flength] = file_record->name[index];
			flength = flength + 1;
		}
	}
	if (file_record->extension[0] != ' ')
81144dcc:	e0bffe17 	ldw	r2,-8(fp)
81144dd0:	10800203 	ldbu	r2,8(r2)
81144dd4:	10803fcc 	andi	r2,r2,255
81144dd8:	10800820 	cmpeqi	r2,r2,32
81144ddc:	1000241e 	bne	r2,zero,81144e70 <copy_file_record_name_to_string+0x12c>
	{
		file_name[flength] = '.';
81144de0:	e0bffd17 	ldw	r2,-12(fp)
81144de4:	e0ffff17 	ldw	r3,-4(fp)
81144de8:	1885883a 	add	r2,r3,r2
81144dec:	00c00b84 	movi	r3,46
81144df0:	10c00005 	stb	r3,0(r2)
		flength = flength + 1;
81144df4:	e0bffd17 	ldw	r2,-12(fp)
81144df8:	10800044 	addi	r2,r2,1
81144dfc:	e0bffd15 	stw	r2,-12(fp)
		for (index = 0; index < 3; index++)
81144e00:	e03ffc15 	stw	zero,-16(fp)
81144e04:	00001706 	br	81144e64 <copy_file_record_name_to_string+0x120>
		{
			if (file_record->extension[index] != ' ')
81144e08:	e0fffe17 	ldw	r3,-8(fp)
81144e0c:	e0bffc17 	ldw	r2,-16(fp)
81144e10:	1885883a 	add	r2,r3,r2
81144e14:	10800204 	addi	r2,r2,8
81144e18:	10800003 	ldbu	r2,0(r2)
81144e1c:	10803fcc 	andi	r2,r2,255
81144e20:	10800820 	cmpeqi	r2,r2,32
81144e24:	10000c1e 	bne	r2,zero,81144e58 <copy_file_record_name_to_string+0x114>
			{
				file_name[flength] = file_record->extension[index];
81144e28:	e0bffd17 	ldw	r2,-12(fp)
81144e2c:	e0ffff17 	ldw	r3,-4(fp)
81144e30:	1885883a 	add	r2,r3,r2
81144e34:	e13ffe17 	ldw	r4,-8(fp)
81144e38:	e0fffc17 	ldw	r3,-16(fp)
81144e3c:	20c7883a 	add	r3,r4,r3
81144e40:	18c00204 	addi	r3,r3,8
81144e44:	18c00003 	ldbu	r3,0(r3)
81144e48:	10c00005 	stb	r3,0(r2)
				flength = flength + 1;
81144e4c:	e0bffd17 	ldw	r2,-12(fp)
81144e50:	10800044 	addi	r2,r2,1
81144e54:	e0bffd15 	stw	r2,-12(fp)
	}
	if (file_record->extension[0] != ' ')
	{
		file_name[flength] = '.';
		flength = flength + 1;
		for (index = 0; index < 3; index++)
81144e58:	e0bffc17 	ldw	r2,-16(fp)
81144e5c:	10800044 	addi	r2,r2,1
81144e60:	e0bffc15 	stw	r2,-16(fp)
81144e64:	e0bffc17 	ldw	r2,-16(fp)
81144e68:	108000d0 	cmplti	r2,r2,3
81144e6c:	103fe61e 	bne	r2,zero,81144e08 <__reset+0xfb124e08>
				file_name[flength] = file_record->extension[index];
				flength = flength + 1;
			}
		}
	}
	file_name[flength] = 0;
81144e70:	e0bffd17 	ldw	r2,-12(fp)
81144e74:	e0ffff17 	ldw	r3,-4(fp)
81144e78:	1885883a 	add	r2,r3,r2
81144e7c:	10000005 	stb	zero,0(r2)
}
81144e80:	0001883a 	nop
81144e84:	e037883a 	mov	sp,fp
81144e88:	df000017 	ldw	fp,0(sp)
81144e8c:	dec00104 	addi	sp,sp,4
81144e90:	f800283a 	ret

81144e94 <alt_up_sd_card_open_dev>:
// Direct functions
///////////////////////////////////////////////////////////////////////////


alt_up_sd_card_dev* alt_up_sd_card_open_dev(const char* name)
{
81144e94:	defffc04 	addi	sp,sp,-16
81144e98:	de00012e 	bgeu	sp,et,81144ea0 <alt_up_sd_card_open_dev+0xc>
81144e9c:	003b68fa 	trap	3
81144ea0:	dfc00315 	stw	ra,12(sp)
81144ea4:	df000215 	stw	fp,8(sp)
81144ea8:	df000204 	addi	fp,sp,8
81144eac:	e13fff15 	stw	r4,-4(fp)
	// find the device from the device list 
	// (see altera_hal/HAL/inc/priv/alt_file.h 
	// and altera_hal/HAL/src/alt_find_dev.c 
	// for details)
	alt_up_sd_card_dev *dev = (alt_up_sd_card_dev *) alt_find_dev(name, &alt_dev_list);
81144eb0:	d1600d04 	addi	r5,gp,-32716
81144eb4:	e13fff17 	ldw	r4,-4(fp)
81144eb8:	114a3500 	call	8114a350 <alt_find_dev>
81144ebc:	e0bffe15 	stw	r2,-8(fp)

	if (dev != NULL)
81144ec0:	e0bffe17 	ldw	r2,-8(fp)
81144ec4:	10001e26 	beq	r2,zero,81144f40 <alt_up_sd_card_open_dev+0xac>
	{
		aux_status_register = ((short int *) SD_CARD_AUX_STATUS(dev->base));
81144ec8:	e0bffe17 	ldw	r2,-8(fp)
81144ecc:	10800a17 	ldw	r2,40(r2)
81144ed0:	10808d04 	addi	r2,r2,564
81144ed4:	d0a0ab15 	stw	r2,-32084(gp)
		status_register = ((int *) SD_CARD_STATUS(dev->base));
81144ed8:	e0bffe17 	ldw	r2,-8(fp)
81144edc:	10800a17 	ldw	r2,40(r2)
81144ee0:	10808904 	addi	r2,r2,548
81144ee4:	d0a0ac15 	stw	r2,-32080(gp)
		CSD_register_w0 = ((short int *) SD_CARD_CSD(dev->base, 0));
81144ee8:	e0bffe17 	ldw	r2,-8(fp)
81144eec:	10800a17 	ldw	r2,40(r2)
81144ef0:	10808404 	addi	r2,r2,528
81144ef4:	d0a0ad15 	stw	r2,-32076(gp)
		command_register = ((short int *) SD_CARD_COMMAND(dev->base));
81144ef8:	e0bffe17 	ldw	r2,-8(fp)
81144efc:	10800a17 	ldw	r2,40(r2)
81144f00:	10808c04 	addi	r2,r2,560
81144f04:	d0a0ae15 	stw	r2,-32072(gp)
		command_argument_register = ((int *) SD_CARD_ARGUMENT(dev->base));
81144f08:	e0bffe17 	ldw	r2,-8(fp)
81144f0c:	10800a17 	ldw	r2,40(r2)
81144f10:	10808b04 	addi	r2,r2,556
81144f14:	d0a0af15 	stw	r2,-32068(gp)
		buffer_memory = (char *) SD_CARD_BUFFER(dev->base, 0);
81144f18:	e0bffe17 	ldw	r2,-8(fp)
81144f1c:	10800a17 	ldw	r2,40(r2)
81144f20:	d0a0b015 	stw	r2,-32064(gp)
		device_pointer = dev;
81144f24:	e0bffe17 	ldw	r2,-8(fp)
81144f28:	d0a0b315 	stw	r2,-32052(gp)
		initialized = false;
81144f2c:	d020a915 	stw	zero,-32092(gp)
		is_sd_card_formated_as_FAT16 = false;
81144f30:	d020aa15 	stw	zero,-32088(gp)
		search_data.valid = false;
81144f34:	00a045f4 	movhi	r2,33047
81144f38:	10b44404 	addi	r2,r2,-12016
81144f3c:	10000415 	stw	zero,16(r2)
	}
	return dev;
81144f40:	e0bffe17 	ldw	r2,-8(fp)
}
81144f44:	e037883a 	mov	sp,fp
81144f48:	dfc00117 	ldw	ra,4(sp)
81144f4c:	df000017 	ldw	fp,0(sp)
81144f50:	dec00204 	addi	sp,sp,8
81144f54:	f800283a 	ret

81144f58 <alt_up_sd_card_is_Present>:


bool alt_up_sd_card_is_Present(void)
// Check if there is an SD Card insterted into the SD Card socket.
{
81144f58:	defffd04 	addi	sp,sp,-12
81144f5c:	de00012e 	bgeu	sp,et,81144f64 <alt_up_sd_card_is_Present+0xc>
81144f60:	003b68fa 	trap	3
81144f64:	df000215 	stw	fp,8(sp)
81144f68:	df000204 	addi	fp,sp,8
    bool result = false;
81144f6c:	e03ffe15 	stw	zero,-8(fp)

    if ((device_pointer != NULL) && ((IORD_16DIRECT(aux_status_register,0) & 0x02) != 0))
81144f70:	d0a0b317 	ldw	r2,-32052(gp)
81144f74:	10000826 	beq	r2,zero,81144f98 <alt_up_sd_card_is_Present+0x40>
81144f78:	d0a0ab17 	ldw	r2,-32084(gp)
81144f7c:	1080002b 	ldhuio	r2,0(r2)
81144f80:	10bfffcc 	andi	r2,r2,65535
81144f84:	1080008c 	andi	r2,r2,2
81144f88:	10000326 	beq	r2,zero,81144f98 <alt_up_sd_card_is_Present+0x40>
    {
        result = true;
81144f8c:	00800044 	movi	r2,1
81144f90:	e0bffe15 	stw	r2,-8(fp)
81144f94:	00001e06 	br	81145010 <alt_up_sd_card_is_Present+0xb8>
    }
	else if (initialized == true)
81144f98:	d0a0a917 	ldw	r2,-32092(gp)
81144f9c:	10800058 	cmpnei	r2,r2,1
81144fa0:	10001b1e 	bne	r2,zero,81145010 <alt_up_sd_card_is_Present+0xb8>
	{
		int index;

		initialized = false;
81144fa4:	d020a915 	stw	zero,-32092(gp)
		search_data.valid = false;
81144fa8:	00a045f4 	movhi	r2,33047
81144fac:	10b44404 	addi	r2,r2,-12016
81144fb0:	10000415 	stw	zero,16(r2)
		is_sd_card_formated_as_FAT16 = false;
81144fb4:	d020aa15 	stw	zero,-32088(gp)

		for(index = 0; index < MAX_FILES_OPENED; index++)
81144fb8:	e03fff15 	stw	zero,-4(fp)
81144fbc:	00001106 	br	81145004 <alt_up_sd_card_is_Present+0xac>
		{
			active_files[index].in_use = false;
81144fc0:	00a045f4 	movhi	r2,33047
81144fc4:	10b45e04 	addi	r2,r2,-11912
81144fc8:	e0ffff17 	ldw	r3,-4(fp)
81144fcc:	180691ba 	slli	r3,r3,6
81144fd0:	10c5883a 	add	r2,r2,r3
81144fd4:	10800f04 	addi	r2,r2,60
81144fd8:	10000015 	stw	zero,0(r2)
			active_files[index].modified = false;
81144fdc:	00a045f4 	movhi	r2,33047
81144fe0:	10b45e04 	addi	r2,r2,-11912
81144fe4:	e0ffff17 	ldw	r3,-4(fp)
81144fe8:	180691ba 	slli	r3,r3,6
81144fec:	10c5883a 	add	r2,r2,r3
81144ff0:	10800e04 	addi	r2,r2,56
81144ff4:	10000015 	stw	zero,0(r2)

		initialized = false;
		search_data.valid = false;
		is_sd_card_formated_as_FAT16 = false;

		for(index = 0; index < MAX_FILES_OPENED; index++)
81144ff8:	e0bfff17 	ldw	r2,-4(fp)
81144ffc:	10800044 	addi	r2,r2,1
81145000:	e0bfff15 	stw	r2,-4(fp)
81145004:	e0bfff17 	ldw	r2,-4(fp)
81145008:	10800510 	cmplti	r2,r2,20
8114500c:	103fec1e 	bne	r2,zero,81144fc0 <__reset+0xfb124fc0>
		{
			active_files[index].in_use = false;
			active_files[index].modified = false;
		}
	}
    return result;
81145010:	e0bffe17 	ldw	r2,-8(fp)
}
81145014:	e037883a 	mov	sp,fp
81145018:	df000017 	ldw	fp,0(sp)
8114501c:	dec00104 	addi	sp,sp,4
81145020:	f800283a 	ret

81145024 <alt_up_sd_card_is_FAT16>:
/* This function reads the SD card data in an effort to determine if the card is formated as a FAT16
 * volume. Please note that FAT12 has a similar format, but will not be supported by this driver.
 * If the card contains a FAT16 volume, the local data structures will be initialized to allow reading and writing
 * to the SD card as though it was a hard drive.
 */
{
81145024:	defffd04 	addi	sp,sp,-12
81145028:	de00012e 	bgeu	sp,et,81145030 <alt_up_sd_card_is_FAT16+0xc>
8114502c:	003b68fa 	trap	3
81145030:	dfc00215 	stw	ra,8(sp)
81145034:	df000115 	stw	fp,4(sp)
81145038:	df000104 	addi	fp,sp,4
	bool result = false;
8114503c:	e03fff15 	stw	zero,-4(fp)

	if (alt_up_sd_card_is_Present())
81145040:	1144f580 	call	81144f58 <alt_up_sd_card_is_Present>
81145044:	10000c26 	beq	r2,zero,81145078 <alt_up_sd_card_is_FAT16+0x54>
	{
		// Check if an SD Card is in the SD Card slot.
		if (initialized == false)
81145048:	d0a0a917 	ldw	r2,-32092(gp)
8114504c:	1000071e 	bne	r2,zero,8114506c <alt_up_sd_card_is_FAT16+0x48>
		{
			// Now determine if the card is formatted as FAT 16.
			is_sd_card_formated_as_FAT16 = Look_for_FAT16();
81145050:	11432500 	call	81143250 <Look_for_FAT16>
81145054:	d0a0aa15 	stw	r2,-32088(gp)
			initialized = is_sd_card_formated_as_FAT16;
81145058:	d0a0aa17 	ldw	r2,-32088(gp)
8114505c:	d0a0a915 	stw	r2,-32092(gp)
			search_data.valid = false;
81145060:	00a045f4 	movhi	r2,33047
81145064:	10b44404 	addi	r2,r2,-12016
81145068:	10000415 	stw	zero,16(r2)
		}
		result = is_sd_card_formated_as_FAT16;
8114506c:	d0a0aa17 	ldw	r2,-32088(gp)
81145070:	e0bfff15 	stw	r2,-4(fp)
81145074:	00000206 	br	81145080 <alt_up_sd_card_is_FAT16+0x5c>
	}
	else
	{
		// If not then you may as well not open the device.
		initialized = false;
81145078:	d020a915 	stw	zero,-32092(gp)
		is_sd_card_formated_as_FAT16 = false;
8114507c:	d020aa15 	stw	zero,-32088(gp)
	}

	return result;
81145080:	e0bfff17 	ldw	r2,-4(fp)
}
81145084:	e037883a 	mov	sp,fp
81145088:	dfc00117 	ldw	ra,4(sp)
8114508c:	df000017 	ldw	fp,0(sp)
81145090:	dec00204 	addi	sp,sp,8
81145094:	f800283a 	ret

81145098 <alt_up_sd_card_find_first>:
 * "first/sub/." - look through a directory named "sub", that is located within the subdirectory named "first". "first" is located in the root directory.
 * Invalid examples include:
 * "/.", "/////." - this is not the root directory.
 * "/first/." - the first character may not be a '/'.
 */
{
81145098:	deffea04 	addi	sp,sp,-88
8114509c:	de00012e 	bgeu	sp,et,811450a4 <alt_up_sd_card_find_first+0xc>
811450a0:	003b68fa 	trap	3
811450a4:	dfc01515 	stw	ra,84(sp)
811450a8:	df001415 	stw	fp,80(sp)
811450ac:	df001404 	addi	fp,sp,80
811450b0:	e13ffe15 	stw	r4,-8(fp)
811450b4:	e17fff15 	stw	r5,-4(fp)
	short int result = 2;
811450b8:	00800084 	movi	r2,2
811450bc:	e0bfec0d 	sth	r2,-80(fp)
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
811450c0:	1144f580 	call	81144f58 <alt_up_sd_card_is_Present>
811450c4:	10002426 	beq	r2,zero,81145158 <alt_up_sd_card_find_first+0xc0>
811450c8:	d0a0aa17 	ldw	r2,-32088(gp)
811450cc:	10002226 	beq	r2,zero,81145158 <alt_up_sd_card_find_first+0xc0>
	{
		int home_directory_cluster;
		t_file_record file_record;

		if (get_home_directory_cluster_for_file(directory_to_search_through, &home_directory_cluster, &file_record))
811450d0:	e0ffee04 	addi	r3,fp,-72
811450d4:	e0bfed04 	addi	r2,fp,-76
811450d8:	180d883a 	mov	r6,r3
811450dc:	100b883a 	mov	r5,r2
811450e0:	e13ffe17 	ldw	r4,-8(fp)
811450e4:	11439e80 	call	811439e8 <get_home_directory_cluster_for_file>
811450e8:	10001926 	beq	r2,zero,81145150 <alt_up_sd_card_find_first+0xb8>
		{
			search_data.directory_root_cluster = home_directory_cluster;
811450ec:	e0bfed17 	ldw	r2,-76(fp)
811450f0:	1007883a 	mov	r3,r2
811450f4:	00a045f4 	movhi	r2,33047
811450f8:	10b44404 	addi	r2,r2,-12016
811450fc:	10c00015 	stw	r3,0(r2)
			search_data.current_cluster_index = home_directory_cluster;
81145100:	e0bfed17 	ldw	r2,-76(fp)
81145104:	1007883a 	mov	r3,r2
81145108:	00a045f4 	movhi	r2,33047
8114510c:	10b44404 	addi	r2,r2,-12016
81145110:	10c00115 	stw	r3,4(r2)
			search_data.current_sector_in_cluster = 0;
81145114:	00a045f4 	movhi	r2,33047
81145118:	10b44404 	addi	r2,r2,-12016
8114511c:	10000215 	stw	zero,8(r2)
			search_data.file_index_in_sector = -1;
81145120:	00a045f4 	movhi	r2,33047
81145124:	10b44404 	addi	r2,r2,-12016
81145128:	00ffffc4 	movi	r3,-1
8114512c:	10c0030d 	sth	r3,12(r2)
			search_data.valid = true;
81145130:	00a045f4 	movhi	r2,33047
81145134:	10b44404 	addi	r2,r2,-12016
81145138:	00c00044 	movi	r3,1
8114513c:	10c00415 	stw	r3,16(r2)
			result = alt_up_sd_card_find_next(file_name);
81145140:	e13fff17 	ldw	r4,-4(fp)
81145144:	11451700 	call	81145170 <alt_up_sd_card_find_next>
81145148:	e0bfec0d 	sth	r2,-80(fp)
8114514c:	00000206 	br	81145158 <alt_up_sd_card_find_first+0xc0>
		}
		else
		{
			result = 1;
81145150:	00800044 	movi	r2,1
81145154:	e0bfec0d 	sth	r2,-80(fp)
		}
	}
	return result;
81145158:	e0bfec0b 	ldhu	r2,-80(fp)
}
8114515c:	e037883a 	mov	sp,fp
81145160:	dfc00117 	ldw	ra,4(sp)
81145164:	df000017 	ldw	fp,0(sp)
81145168:	dec00204 	addi	sp,sp,8
8114516c:	f800283a 	ret

81145170 <alt_up_sd_card_find_next>:
 *		-1 - end of directory.
 *		0 - success
 *		2 - No card or incorrect card format.
 *		3 - find_first has not been called successfully.
 */
{
81145170:	deffe404 	addi	sp,sp,-112
81145174:	de00012e 	bgeu	sp,et,8114517c <alt_up_sd_card_find_next+0xc>
81145178:	003b68fa 	trap	3
8114517c:	dfc01b15 	stw	ra,108(sp)
81145180:	df001a15 	stw	fp,104(sp)
81145184:	df001a04 	addi	fp,sp,104
81145188:	e13fff15 	stw	r4,-4(fp)
	short int result = 2;
8114518c:	00800084 	movi	r2,2
81145190:	e0bfe60d 	sth	r2,-104(fp)
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81145194:	1144f580 	call	81144f58 <alt_up_sd_card_is_Present>
81145198:	1000df26 	beq	r2,zero,81145518 <alt_up_sd_card_find_next+0x3a8>
8114519c:	d0a0aa17 	ldw	r2,-32088(gp)
811451a0:	1000dd26 	beq	r2,zero,81145518 <alt_up_sd_card_find_next+0x3a8>
	{
		if (search_data.valid)
811451a4:	00a045f4 	movhi	r2,33047
811451a8:	10b44404 	addi	r2,r2,-12016
811451ac:	10800417 	ldw	r2,16(r2)
811451b0:	1000d726 	beq	r2,zero,81145510 <alt_up_sd_card_find_next+0x3a0>
		{
			t_file_record file_record;
			int cluster = search_data.current_cluster_index;
811451b4:	00a045f4 	movhi	r2,33047
811451b8:	10b44404 	addi	r2,r2,-12016
811451bc:	10800117 	ldw	r2,4(r2)
811451c0:	e0bfe715 	stw	r2,-100(fp)

			if (cluster == 0)
811451c4:	e0bfe717 	ldw	r2,-100(fp)
811451c8:	1000561e 	bne	r2,zero,81145324 <alt_up_sd_card_find_next+0x1b4>
			{
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
811451cc:	00a045f4 	movhi	r2,33047
811451d0:	10b44904 	addi	r2,r2,-11996
811451d4:	1080050b 	ldhu	r2,20(r2)
811451d8:	10bfffcc 	andi	r2,r2,65535
811451dc:	1006917a 	slli	r3,r2,5
811451e0:	00a045f4 	movhi	r2,33047
811451e4:	10b44904 	addi	r2,r2,-11996
811451e8:	1080030b 	ldhu	r2,12(r2)
811451ec:	10bfffcc 	andi	r2,r2,65535
811451f0:	1885283a 	div	r2,r3,r2
811451f4:	e0bfec15 	stw	r2,-80(fp)
				int sector_index = search_data.current_sector_in_cluster;
811451f8:	00a045f4 	movhi	r2,33047
811451fc:	10b44404 	addi	r2,r2,-12016
81145200:	10800217 	ldw	r2,8(r2)
81145204:	e0bfe815 	stw	r2,-96(fp)
				int file_counter = search_data.file_index_in_sector+1;
81145208:	00a045f4 	movhi	r2,33047
8114520c:	10b44404 	addi	r2,r2,-12016
81145210:	1080030b 	ldhu	r2,12(r2)
81145214:	10bfffcc 	andi	r2,r2,65535
81145218:	10a0001c 	xori	r2,r2,32768
8114521c:	10a00004 	addi	r2,r2,-32768
81145220:	10800044 	addi	r2,r2,1
81145224:	e0bfe915 	stw	r2,-92(fp)
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
81145228:	00003606 	br	81145304 <alt_up_sd_card_find_next+0x194>
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
8114522c:	00a045f4 	movhi	r2,33047
81145230:	10b44904 	addi	r2,r2,-11996
81145234:	10c01317 	ldw	r3,76(r2)
81145238:	e0bfe817 	ldw	r2,-96(fp)
8114523c:	1885883a 	add	r2,r3,r2
81145240:	1007883a 	mov	r3,r2
81145244:	d0a0b117 	ldw	r2,-32060(gp)
81145248:	100b883a 	mov	r5,r2
8114524c:	1809883a 	mov	r4,r3
81145250:	11422800 	call	81142280 <Read_Sector_Data>
81145254:	10002f26 	beq	r2,zero,81145314 <alt_up_sd_card_find_next+0x1a4>
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
81145258:	00002306 	br	811452e8 <alt_up_sd_card_find_next+0x178>
						{
							if (Read_File_Record_At_Offset(file_counter*32, &file_record, 0, sector_index))
8114525c:	e0bfe917 	ldw	r2,-92(fp)
81145260:	1004917a 	slli	r2,r2,5
81145264:	e13fe817 	ldw	r4,-96(fp)
81145268:	e0ffef04 	addi	r3,fp,-68
8114526c:	200f883a 	mov	r7,r4
81145270:	000d883a 	mov	r6,zero
81145274:	180b883a 	mov	r5,r3
81145278:	1009883a 	mov	r4,r2
8114527c:	11426b00 	call	811426b0 <Read_File_Record_At_Offset>
81145280:	10001626 	beq	r2,zero,811452dc <alt_up_sd_card_find_next+0x16c>
							{
								if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
81145284:	e0bfef03 	ldbu	r2,-68(fp)
81145288:	10803fcc 	andi	r2,r2,255
8114528c:	10001326 	beq	r2,zero,811452dc <alt_up_sd_card_find_next+0x16c>
81145290:	e0bfef03 	ldbu	r2,-68(fp)
81145294:	10803fcc 	andi	r2,r2,255
81145298:	10803960 	cmpeqi	r2,r2,229
8114529c:	10000f1e 	bne	r2,zero,811452dc <alt_up_sd_card_find_next+0x16c>
								{
									/* Update search structure. */
									search_data.file_index_in_sector = file_counter;
811452a0:	e0bfe917 	ldw	r2,-92(fp)
811452a4:	1007883a 	mov	r3,r2
811452a8:	00a045f4 	movhi	r2,33047
811452ac:	10b44404 	addi	r2,r2,-12016
811452b0:	10c0030d 	sth	r3,12(r2)
									search_data.current_sector_in_cluster = sector_index;
811452b4:	e0ffe817 	ldw	r3,-96(fp)
811452b8:	00a045f4 	movhi	r2,33047
811452bc:	10b44404 	addi	r2,r2,-12016
811452c0:	10c00215 	stw	r3,8(r2)

									/* Copy file name.*/
									copy_file_record_name_to_string(&file_record, file_name);
811452c4:	e0bfef04 	addi	r2,fp,-68
811452c8:	e17fff17 	ldw	r5,-4(fp)
811452cc:	1009883a 	mov	r4,r2
811452d0:	1144d440 	call	81144d44 <copy_file_record_name_to_string>
									return 0;
811452d4:	0005883a 	mov	r2,zero
811452d8:	00009006 	br	8114551c <alt_up_sd_card_find_next+0x3ac>
				for (; sector_index < max_root_dir_sectors; sector_index++)
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
811452dc:	e0bfe917 	ldw	r2,-92(fp)
811452e0:	10800044 	addi	r2,r2,1
811452e4:	e0bfe915 	stw	r2,-92(fp)
811452e8:	e0bfe917 	ldw	r2,-92(fp)
811452ec:	10800410 	cmplti	r2,r2,16
811452f0:	103fda1e 	bne	r2,zero,8114525c <__reset+0xfb12525c>
									copy_file_record_name_to_string(&file_record, file_name);
									return 0;
								}
							}
						}
						file_counter = 0;
811452f4:	e03fe915 	stw	zero,-92(fp)
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
				int sector_index = search_data.current_sector_in_cluster;
				int file_counter = search_data.file_index_in_sector+1;
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
811452f8:	e0bfe817 	ldw	r2,-96(fp)
811452fc:	10800044 	addi	r2,r2,1
81145300:	e0bfe815 	stw	r2,-96(fp)
81145304:	e0ffe817 	ldw	r3,-96(fp)
81145308:	e0bfec17 	ldw	r2,-80(fp)
8114530c:	18bfc716 	blt	r3,r2,8114522c <__reset+0xfb12522c>
81145310:	00000106 	br	81145318 <alt_up_sd_card_find_next+0x1a8>
						}
						file_counter = 0;
					}
					else
					{
						break;
81145314:	0001883a 	nop
					}
				}
				result = -1;
81145318:	00bfffc4 	movi	r2,-1
8114531c:	e0bfe60d 	sth	r2,-104(fp)
81145320:	00007d06 	br	81145518 <alt_up_sd_card_find_next+0x3a8>
			}
			else
			{
				int file_counter = search_data.file_index_in_sector+1;
81145324:	00a045f4 	movhi	r2,33047
81145328:	10b44404 	addi	r2,r2,-12016
8114532c:	1080030b 	ldhu	r2,12(r2)
81145330:	10bfffcc 	andi	r2,r2,65535
81145334:	10a0001c 	xori	r2,r2,32768
81145338:	10a00004 	addi	r2,r2,-32768
8114533c:	10800044 	addi	r2,r2,1
81145340:	e0bfea15 	stw	r2,-88(fp)
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
81145344:	e0bfe717 	ldw	r2,-100(fp)
81145348:	10ffff84 	addi	r3,r2,-2
8114534c:	00a045f4 	movhi	r2,33047
81145350:	10b44904 	addi	r2,r2,-11996
81145354:	10800383 	ldbu	r2,14(r2)
81145358:	10803fcc 	andi	r2,r2,255
8114535c:	1885383a 	mul	r2,r3,r2
81145360:	1007883a 	mov	r3,r2
81145364:	00a045f4 	movhi	r2,33047
81145368:	10b44904 	addi	r2,r2,-11996
8114536c:	10801417 	ldw	r2,80(r2)
81145370:	1885883a 	add	r2,r3,r2
81145374:	e0bfed15 	stw	r2,-76(fp)
					int sector_index = search_data.current_sector_in_cluster;
81145378:	00a045f4 	movhi	r2,33047
8114537c:	10b44404 	addi	r2,r2,-12016
81145380:	10800217 	ldw	r2,8(r2)
81145384:	e0bfeb15 	stw	r2,-84(fp)
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81145388:	00003806 	br	8114546c <alt_up_sd_card_find_next+0x2fc>
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
8114538c:	e0ffeb17 	ldw	r3,-84(fp)
81145390:	e0bfed17 	ldw	r2,-76(fp)
81145394:	1885883a 	add	r2,r3,r2
81145398:	d0e0b117 	ldw	r3,-32060(gp)
8114539c:	180b883a 	mov	r5,r3
811453a0:	1009883a 	mov	r4,r2
811453a4:	11422800 	call	81142280 <Read_Sector_Data>
811453a8:	10003726 	beq	r2,zero,81145488 <alt_up_sd_card_find_next+0x318>
						{        
							for (; file_counter < 16; file_counter++)
811453ac:	00002806 	br	81145450 <alt_up_sd_card_find_next+0x2e0>
							{
								if (Read_File_Record_At_Offset(file_counter*32, &file_record, cluster, sector_index))
811453b0:	e0bfea17 	ldw	r2,-88(fp)
811453b4:	1004917a 	slli	r2,r2,5
811453b8:	e13fe717 	ldw	r4,-100(fp)
811453bc:	e17feb17 	ldw	r5,-84(fp)
811453c0:	e0ffef04 	addi	r3,fp,-68
811453c4:	280f883a 	mov	r7,r5
811453c8:	200d883a 	mov	r6,r4
811453cc:	180b883a 	mov	r5,r3
811453d0:	1009883a 	mov	r4,r2
811453d4:	11426b00 	call	811426b0 <Read_File_Record_At_Offset>
811453d8:	10001a26 	beq	r2,zero,81145444 <alt_up_sd_card_find_next+0x2d4>
								{
									if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
811453dc:	e0bfef03 	ldbu	r2,-68(fp)
811453e0:	10803fcc 	andi	r2,r2,255
811453e4:	10001726 	beq	r2,zero,81145444 <alt_up_sd_card_find_next+0x2d4>
811453e8:	e0bfef03 	ldbu	r2,-68(fp)
811453ec:	10803fcc 	andi	r2,r2,255
811453f0:	10803960 	cmpeqi	r2,r2,229
811453f4:	1000131e 	bne	r2,zero,81145444 <alt_up_sd_card_find_next+0x2d4>
									{
										/* Update search structure. */
										search_data.current_cluster_index = cluster;
811453f8:	e0ffe717 	ldw	r3,-100(fp)
811453fc:	00a045f4 	movhi	r2,33047
81145400:	10b44404 	addi	r2,r2,-12016
81145404:	10c00115 	stw	r3,4(r2)
										search_data.file_index_in_sector = file_counter;
81145408:	e0bfea17 	ldw	r2,-88(fp)
8114540c:	1007883a 	mov	r3,r2
81145410:	00a045f4 	movhi	r2,33047
81145414:	10b44404 	addi	r2,r2,-12016
81145418:	10c0030d 	sth	r3,12(r2)
										search_data.current_sector_in_cluster = sector_index;
8114541c:	e0ffeb17 	ldw	r3,-84(fp)
81145420:	00a045f4 	movhi	r2,33047
81145424:	10b44404 	addi	r2,r2,-12016
81145428:	10c00215 	stw	r3,8(r2)

										/* Copy file name.*/
										copy_file_record_name_to_string(&file_record, file_name);
8114542c:	e0bfef04 	addi	r2,fp,-68
81145430:	e17fff17 	ldw	r5,-4(fp)
81145434:	1009883a 	mov	r4,r2
81145438:	1144d440 	call	81144d44 <copy_file_record_name_to_string>
										return 0;
8114543c:	0005883a 	mov	r2,zero
81145440:	00003606 	br	8114551c <alt_up_sd_card_find_next+0x3ac>
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
						{        
							for (; file_counter < 16; file_counter++)
81145444:	e0bfea17 	ldw	r2,-88(fp)
81145448:	10800044 	addi	r2,r2,1
8114544c:	e0bfea15 	stw	r2,-88(fp)
81145450:	e0bfea17 	ldw	r2,-88(fp)
81145454:	10800410 	cmplti	r2,r2,16
81145458:	103fd51e 	bne	r2,zero,811453b0 <__reset+0xfb1253b0>
										copy_file_record_name_to_string(&file_record, file_name);
										return 0;
									}
								}
							}
							file_counter = 0;
8114545c:	e03fea15 	stw	zero,-88(fp)
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
					int sector_index = search_data.current_sector_in_cluster;
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81145460:	e0bfeb17 	ldw	r2,-84(fp)
81145464:	10800044 	addi	r2,r2,1
81145468:	e0bfeb15 	stw	r2,-84(fp)
8114546c:	00a045f4 	movhi	r2,33047
81145470:	10b44904 	addi	r2,r2,-11996
81145474:	10800383 	ldbu	r2,14(r2)
81145478:	10803fcc 	andi	r2,r2,255
8114547c:	e0ffeb17 	ldw	r3,-84(fp)
81145480:	18bfc216 	blt	r3,r2,8114538c <__reset+0xfb12538c>
81145484:	00000106 	br	8114548c <alt_up_sd_card_find_next+0x31c>
							}
							file_counter = 0;
						}
						else
						{
							break;
81145488:	0001883a 	nop
						}
					}
					// If this is the end of the cluster and the file has not been found, then see if there is another cluster
					// that holds data for the current directory.
					if (sector_index >= boot_sector_data.sectors_per_cluster)
8114548c:	00a045f4 	movhi	r2,33047
81145490:	10b44904 	addi	r2,r2,-11996
81145494:	10800383 	ldbu	r2,14(r2)
81145498:	10803fcc 	andi	r2,r2,255
8114549c:	e0ffeb17 	ldw	r3,-84(fp)
811454a0:	18801716 	blt	r3,r2,81145500 <alt_up_sd_card_find_next+0x390>
					{
						unsigned short int new_cluster;

						if (get_cluster_flag(cluster, &new_cluster))
811454a4:	e0bfe717 	ldw	r2,-100(fp)
811454a8:	e0ffee04 	addi	r3,fp,-72
811454ac:	180b883a 	mov	r5,r3
811454b0:	1009883a 	mov	r4,r2
811454b4:	11423600 	call	81142360 <get_cluster_flag>
811454b8:	10000f26 	beq	r2,zero,811454f8 <alt_up_sd_card_find_next+0x388>
						{
							if ((new_cluster & 0x0000fff8) == 0x0000fff8)
811454bc:	e0bfee0b 	ldhu	r2,-72(fp)
811454c0:	10bfffcc 	andi	r2,r2,65535
811454c4:	10fffe0c 	andi	r3,r2,65528
811454c8:	00bffe14 	movui	r2,65528
811454cc:	1880051e 	bne	r3,r2,811454e4 <alt_up_sd_card_find_next+0x374>
							{
								result = -1;
811454d0:	00bfffc4 	movi	r2,-1
811454d4:	e0bfe60d 	sth	r2,-104(fp)
								search_data.valid = false;
811454d8:	00a045f4 	movhi	r2,33047
811454dc:	10b44404 	addi	r2,r2,-12016
811454e0:	10000415 	stw	zero,16(r2)
							}
							cluster = ((new_cluster) & 0x0000fff8);
811454e4:	e0bfee0b 	ldhu	r2,-72(fp)
811454e8:	10bfffcc 	andi	r2,r2,65535
811454ec:	10bffe0c 	andi	r2,r2,65528
811454f0:	e0bfe715 	stw	r2,-100(fp)
811454f4:	00000206 	br	81145500 <alt_up_sd_card_find_next+0x390>
						}
						else
						{
							// Error encountered.                 
							result = -1;
811454f8:	00bfffc4 	movi	r2,-1
811454fc:	e0bfe60d 	sth	r2,-104(fp)
						}
					}              
				} while (cluster < 0x0000fff8);
81145500:	e0bfe717 	ldw	r2,-100(fp)
81145504:	00fffdd4 	movui	r3,65527
81145508:	18bf8e0e 	bge	r3,r2,81145344 <__reset+0xfb125344>
8114550c:	00000206 	br	81145518 <alt_up_sd_card_find_next+0x3a8>
			}
		}
		else
		{
			// Call Find_First first.
			result = 3;
81145510:	008000c4 	movi	r2,3
81145514:	e0bfe60d 	sth	r2,-104(fp)
		}
	}
	return result;
81145518:	e0bfe60b 	ldhu	r2,-104(fp)
}
8114551c:	e037883a 	mov	sp,fp
81145520:	dfc00117 	ldw	ra,4(sp)
81145524:	df000017 	ldw	fp,0(sp)
81145528:	dec00204 	addi	sp,sp,8
8114552c:	f800283a 	ret

81145530 <alt_up_sd_card_fopen>:
 *      create - a flag set to true to create a file if it does not already exist
 * Output:
 *      An index to the file record assigned to the specified file. -1 is returned if the file could not be opened.
 *		Return -2 if the specified file has already been opened previously.
 */
{
81145530:	deffe904 	addi	sp,sp,-92
81145534:	de00012e 	bgeu	sp,et,8114553c <alt_up_sd_card_fopen+0xc>
81145538:	003b68fa 	trap	3
8114553c:	dfc01615 	stw	ra,88(sp)
81145540:	df001515 	stw	fp,84(sp)
81145544:	df001504 	addi	fp,sp,84
81145548:	e13ffe15 	stw	r4,-8(fp)
8114554c:	e17fff15 	stw	r5,-4(fp)
	short int file_record_index = -1;
81145550:	00bfffc4 	movi	r2,-1
81145554:	e0bfeb0d 	sth	r2,-84(fp)

	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81145558:	1144f580 	call	81144f58 <alt_up_sd_card_is_Present>
8114555c:	1000cf26 	beq	r2,zero,8114589c <alt_up_sd_card_fopen+0x36c>
81145560:	d0a0aa17 	ldw	r2,-32088(gp)
81145564:	1000cd26 	beq	r2,zero,8114589c <alt_up_sd_card_fopen+0x36c>
	{
        unsigned int home_directory_cluster = 0;
81145568:	e03fed15 	stw	zero,-76(fp)
         * Rules:
         *  - no spaces
         *  - at most 12 chatacters per name, with a period in 9th position.
         *  - a / or a \ every at most 12 characters.
         */
        filename_to_upper_case(name);
8114556c:	e13ffe17 	ldw	r4,-8(fp)
81145570:	11433440 	call	81143344 <filename_to_upper_case>
        if (check_file_name_for_FAT16_compliance(name))
81145574:	e13ffe17 	ldw	r4,-8(fp)
81145578:	11434100 	call	81143410 <check_file_name_for_FAT16_compliance>
8114557c:	1000c726 	beq	r2,zero,8114589c <alt_up_sd_card_fopen+0x36c>
        {
			int index;

            /* Get home directory cluster location for the specified file. 0 means root directory. */
            if (!get_home_directory_cluster_for_file(name, (int *) &home_directory_cluster, &home_dir))
81145580:	e0ffee04 	addi	r3,fp,-72
81145584:	e0bfed04 	addi	r2,fp,-76
81145588:	180d883a 	mov	r6,r3
8114558c:	100b883a 	mov	r5,r2
81145590:	e13ffe17 	ldw	r4,-8(fp)
81145594:	11439e80 	call	811439e8 <get_home_directory_cluster_for_file>
81145598:	1000021e 	bne	r2,zero,811455a4 <alt_up_sd_card_fopen+0x74>
            {
                return file_record_index;
8114559c:	e0bfeb0b 	ldhu	r2,-84(fp)
811455a0:	0000bf06 	br	811458a0 <alt_up_sd_card_fopen+0x370>
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
811455a4:	e03fec15 	stw	zero,-80(fp)
811455a8:	00000e06 	br	811455e4 <alt_up_sd_card_fopen+0xb4>
    		{
    			if (active_files[index].in_use == false)
811455ac:	00a045f4 	movhi	r2,33047
811455b0:	10b45e04 	addi	r2,r2,-11912
811455b4:	e0ffec17 	ldw	r3,-80(fp)
811455b8:	180691ba 	slli	r3,r3,6
811455bc:	10c5883a 	add	r2,r2,r3
811455c0:	10800f04 	addi	r2,r2,60
811455c4:	10800017 	ldw	r2,0(r2)
811455c8:	1000031e 	bne	r2,zero,811455d8 <alt_up_sd_card_fopen+0xa8>
    			{
    				file_record_index = index;
811455cc:	e0bfec17 	ldw	r2,-80(fp)
811455d0:	e0bfeb0d 	sth	r2,-84(fp)
    				break;
811455d4:	00000606 	br	811455f0 <alt_up_sd_card_fopen+0xc0>
            {
                return file_record_index;
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
811455d8:	e0bfec17 	ldw	r2,-80(fp)
811455dc:	10800044 	addi	r2,r2,1
811455e0:	e0bfec15 	stw	r2,-80(fp)
811455e4:	e0bfec17 	ldw	r2,-80(fp)
811455e8:	10800510 	cmplti	r2,r2,20
811455ec:	103fef1e 	bne	r2,zero,811455ac <__reset+0xfb1255ac>
    			{
    				file_record_index = index;
    				break;
    			}
    		}
    		if (file_record_index >= 0)
811455f0:	e0bfeb0f 	ldh	r2,-84(fp)
811455f4:	1000a916 	blt	r2,zero,8114589c <alt_up_sd_card_fopen+0x36c>
    		{
    			/* If file record is found, then look for the specified file. If the create flag is set to true 
    			 * and the file is not found, then it should be created in the current directory. 
    			 */
                
                if (find_file_in_directory(home_directory_cluster, name, &(active_files[file_record_index])))
811455f8:	e0bfed17 	ldw	r2,-76(fp)
811455fc:	1009883a 	mov	r4,r2
81145600:	e0bfeb0f 	ldh	r2,-84(fp)
81145604:	100691ba 	slli	r3,r2,6
81145608:	00a045f4 	movhi	r2,33047
8114560c:	10b45e04 	addi	r2,r2,-11912
81145610:	1885883a 	add	r2,r3,r2
81145614:	100d883a 	mov	r6,r2
81145618:	e17ffe17 	ldw	r5,-8(fp)
8114561c:	1143f280 	call	81143f28 <find_file_in_directory>
81145620:	10007b26 	beq	r2,zero,81145810 <alt_up_sd_card_fopen+0x2e0>
                {
                    if (create)
81145624:	e0bfff17 	ldw	r2,-4(fp)
81145628:	10000226 	beq	r2,zero,81145634 <alt_up_sd_card_fopen+0x104>
                    {
                        /* Do not allow overwriting existing files for now. */
                        return -1;
8114562c:	00bfffc4 	movi	r2,-1
81145630:	00009b06 	br	811458a0 <alt_up_sd_card_fopen+0x370>
                    }
                    active_files[file_record_index].current_cluster_index = active_files[file_record_index].start_cluster_index;
81145634:	e13feb0f 	ldh	r4,-84(fp)
81145638:	e0ffeb0f 	ldh	r3,-84(fp)
8114563c:	00a045f4 	movhi	r2,33047
81145640:	10b45e04 	addi	r2,r2,-11912
81145644:	180691ba 	slli	r3,r3,6
81145648:	10c5883a 	add	r2,r2,r3
8114564c:	10800584 	addi	r2,r2,22
81145650:	1080000b 	ldhu	r2,0(r2)
81145654:	10ffffcc 	andi	r3,r2,65535
81145658:	00a045f4 	movhi	r2,33047
8114565c:	10b45e04 	addi	r2,r2,-11912
81145660:	200891ba 	slli	r4,r4,6
81145664:	1105883a 	add	r2,r2,r4
81145668:	10800704 	addi	r2,r2,28
8114566c:	10c00015 	stw	r3,0(r2)
                    active_files[file_record_index].current_sector_in_cluster = 0;
81145670:	e0ffeb0f 	ldh	r3,-84(fp)
81145674:	00a045f4 	movhi	r2,33047
81145678:	10b45e04 	addi	r2,r2,-11912
8114567c:	180691ba 	slli	r3,r3,6
81145680:	10c5883a 	add	r2,r2,r3
81145684:	10800804 	addi	r2,r2,32
81145688:	10000015 	stw	zero,0(r2)
                    active_files[file_record_index].current_byte_position = 0;
8114568c:	e0ffeb0f 	ldh	r3,-84(fp)
81145690:	00a045f4 	movhi	r2,33047
81145694:	10b45e04 	addi	r2,r2,-11912
81145698:	180691ba 	slli	r3,r3,6
8114569c:	10c5883a 	add	r2,r2,r3
811456a0:	10800904 	addi	r2,r2,36
811456a4:	10000015 	stw	zero,0(r2)
                    active_files[file_record_index].in_use = true;
811456a8:	e0ffeb0f 	ldh	r3,-84(fp)
811456ac:	00a045f4 	movhi	r2,33047
811456b0:	10b45e04 	addi	r2,r2,-11912
811456b4:	180691ba 	slli	r3,r3,6
811456b8:	10c5883a 	add	r2,r2,r3
811456bc:	10800f04 	addi	r2,r2,60
811456c0:	00c00044 	movi	r3,1
811456c4:	10c00015 	stw	r3,0(r2)
    				active_files[file_record_index].modified = false;
811456c8:	e0ffeb0f 	ldh	r3,-84(fp)
811456cc:	00a045f4 	movhi	r2,33047
811456d0:	10b45e04 	addi	r2,r2,-11912
811456d4:	180691ba 	slli	r3,r3,6
811456d8:	10c5883a 	add	r2,r2,r3
811456dc:	10800e04 	addi	r2,r2,56
811456e0:	10000015 	stw	zero,0(r2)

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
811456e4:	e03fec15 	stw	zero,-80(fp)
811456e8:	00004506 	br	81145800 <alt_up_sd_card_fopen+0x2d0>
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
811456ec:	e0ffeb0f 	ldh	r3,-84(fp)
811456f0:	e0bfec17 	ldw	r2,-80(fp)
811456f4:	18803f26 	beq	r3,r2,811457f4 <alt_up_sd_card_fopen+0x2c4>
811456f8:	00a045f4 	movhi	r2,33047
811456fc:	10b45e04 	addi	r2,r2,-11912
81145700:	e0ffec17 	ldw	r3,-80(fp)
81145704:	180691ba 	slli	r3,r3,6
81145708:	10c5883a 	add	r2,r2,r3
8114570c:	10800f04 	addi	r2,r2,60
81145710:	10800017 	ldw	r2,0(r2)
81145714:	10800058 	cmpnei	r2,r2,1
81145718:	1000361e 	bne	r2,zero,811457f4 <alt_up_sd_card_fopen+0x2c4>
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
8114571c:	e0ffeb0f 	ldh	r3,-84(fp)
81145720:	00a045f4 	movhi	r2,33047
81145724:	10b45e04 	addi	r2,r2,-11912
81145728:	180691ba 	slli	r3,r3,6
8114572c:	10c5883a 	add	r2,r2,r3
81145730:	10800a04 	addi	r2,r2,40
81145734:	10c00017 	ldw	r3,0(r2)
81145738:	00a045f4 	movhi	r2,33047
8114573c:	10b45e04 	addi	r2,r2,-11912
81145740:	e13fec17 	ldw	r4,-80(fp)
81145744:	200891ba 	slli	r4,r4,6
81145748:	1105883a 	add	r2,r2,r4
8114574c:	10800a04 	addi	r2,r2,40
81145750:	10800017 	ldw	r2,0(r2)
81145754:	1880271e 	bne	r3,r2,811457f4 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
81145758:	e0ffeb0f 	ldh	r3,-84(fp)
8114575c:	00a045f4 	movhi	r2,33047
81145760:	10b45e04 	addi	r2,r2,-11912
81145764:	180691ba 	slli	r3,r3,6
81145768:	10c5883a 	add	r2,r2,r3
8114576c:	10800b04 	addi	r2,r2,44
81145770:	10c00017 	ldw	r3,0(r2)
81145774:	00a045f4 	movhi	r2,33047
81145778:	10b45e04 	addi	r2,r2,-11912
8114577c:	e13fec17 	ldw	r4,-80(fp)
81145780:	200891ba 	slli	r4,r4,6
81145784:	1105883a 	add	r2,r2,r4
81145788:	10800b04 	addi	r2,r2,44
8114578c:	10800017 	ldw	r2,0(r2)
					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
81145790:	1880181e 	bne	r3,r2,811457f4 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
81145794:	e0ffeb0f 	ldh	r3,-84(fp)
81145798:	00a045f4 	movhi	r2,33047
8114579c:	10b45e04 	addi	r2,r2,-11912
811457a0:	180691ba 	slli	r3,r3,6
811457a4:	10c5883a 	add	r2,r2,r3
811457a8:	10800c04 	addi	r2,r2,48
811457ac:	1100000b 	ldhu	r4,0(r2)
811457b0:	00a045f4 	movhi	r2,33047
811457b4:	10b45e04 	addi	r2,r2,-11912
811457b8:	e0ffec17 	ldw	r3,-80(fp)
811457bc:	180691ba 	slli	r3,r3,6
811457c0:	10c5883a 	add	r2,r2,r3
811457c4:	10800c04 	addi	r2,r2,48
811457c8:	1080000b 	ldhu	r2,0(r2)
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
811457cc:	20ffffcc 	andi	r3,r4,65535
811457d0:	18e0001c 	xori	r3,r3,32768
811457d4:	18e00004 	addi	r3,r3,-32768
811457d8:	10bfffcc 	andi	r2,r2,65535
811457dc:	10a0001c 	xori	r2,r2,32768
811457e0:	10a00004 	addi	r2,r2,-32768
811457e4:	1880031e 	bne	r3,r2,811457f4 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
							{
								// file already in use.
								file_record_index = -2;
811457e8:	00bfff84 	movi	r2,-2
811457ec:	e0bfeb0d 	sth	r2,-84(fp)
								break;
811457f0:	00002a06 	br	8114589c <alt_up_sd_card_fopen+0x36c>
                    active_files[file_record_index].current_byte_position = 0;
                    active_files[file_record_index].in_use = true;
    				active_files[file_record_index].modified = false;

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
811457f4:	e0bfec17 	ldw	r2,-80(fp)
811457f8:	10800044 	addi	r2,r2,1
811457fc:	e0bfec15 	stw	r2,-80(fp)
81145800:	e0bfec17 	ldw	r2,-80(fp)
81145804:	10800510 	cmplti	r2,r2,20
81145808:	103fb81e 	bne	r2,zero,811456ec <__reset+0xfb1256ec>
8114580c:	00002306 	br	8114589c <alt_up_sd_card_fopen+0x36c>
							}
						}
					}

                }
                else if (create)
81145810:	e0bfff17 	ldw	r2,-4(fp)
81145814:	10001f26 	beq	r2,zero,81145894 <alt_up_sd_card_fopen+0x364>
                {
                    /* Create file if needed. */
                    if (create_file(name, &(active_files[file_record_index]), &home_dir))
81145818:	e0bfeb0f 	ldh	r2,-84(fp)
8114581c:	100691ba 	slli	r3,r2,6
81145820:	00a045f4 	movhi	r2,33047
81145824:	10b45e04 	addi	r2,r2,-11912
81145828:	1885883a 	add	r2,r3,r2
8114582c:	e0ffee04 	addi	r3,fp,-72
81145830:	180d883a 	mov	r6,r3
81145834:	100b883a 	mov	r5,r2
81145838:	e13ffe17 	ldw	r4,-8(fp)
8114583c:	1144a740 	call	81144a74 <create_file>
81145840:	10001126 	beq	r2,zero,81145888 <alt_up_sd_card_fopen+0x358>
                    {
                        active_files[file_record_index].in_use = true;
81145844:	e0ffeb0f 	ldh	r3,-84(fp)
81145848:	00a045f4 	movhi	r2,33047
8114584c:	10b45e04 	addi	r2,r2,-11912
81145850:	180691ba 	slli	r3,r3,6
81145854:	10c5883a 	add	r2,r2,r3
81145858:	10800f04 	addi	r2,r2,60
8114585c:	00c00044 	movi	r3,1
81145860:	10c00015 	stw	r3,0(r2)
    					active_files[file_record_index].modified = true;
81145864:	e0ffeb0f 	ldh	r3,-84(fp)
81145868:	00a045f4 	movhi	r2,33047
8114586c:	10b45e04 	addi	r2,r2,-11912
81145870:	180691ba 	slli	r3,r3,6
81145874:	10c5883a 	add	r2,r2,r3
81145878:	10800e04 	addi	r2,r2,56
8114587c:	00c00044 	movi	r3,1
81145880:	10c00015 	stw	r3,0(r2)
81145884:	00000506 	br	8114589c <alt_up_sd_card_fopen+0x36c>
                    }
                    else
                    {
                        /* If file creation fails then return an invalid file handle. */
                        file_record_index = -1;
81145888:	00bfffc4 	movi	r2,-1
8114588c:	e0bfeb0d 	sth	r2,-84(fp)
81145890:	00000206 	br	8114589c <alt_up_sd_card_fopen+0x36c>
                    }                
                }
                else
                {
                    /* Otherwise the file could not be opened.*/
                    file_record_index = -1;
81145894:	00bfffc4 	movi	r2,-1
81145898:	e0bfeb0d 	sth	r2,-84(fp)
                }
    		}
        }
	}

	return file_record_index;
8114589c:	e0bfeb0b 	ldhu	r2,-84(fp)
}
811458a0:	e037883a 	mov	sp,fp
811458a4:	dfc00117 	ldw	ra,4(sp)
811458a8:	df000017 	ldw	fp,0(sp)
811458ac:	dec00204 	addi	sp,sp,8
811458b0:	f800283a 	ret

811458b4 <alt_up_sd_card_set_attributes>:


void alt_up_sd_card_set_attributes(short int file_handle, short int attributes)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
811458b4:	defffd04 	addi	sp,sp,-12
811458b8:	de00012e 	bgeu	sp,et,811458c0 <alt_up_sd_card_set_attributes+0xc>
811458bc:	003b68fa 	trap	3
811458c0:	df000215 	stw	fp,8(sp)
811458c4:	df000204 	addi	fp,sp,8
811458c8:	2007883a 	mov	r3,r4
811458cc:	2805883a 	mov	r2,r5
811458d0:	e0fffe0d 	sth	r3,-8(fp)
811458d4:	e0bfff0d 	sth	r2,-4(fp)
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
811458d8:	e0bffe0f 	ldh	r2,-8(fp)
811458dc:	10001416 	blt	r2,zero,81145930 <alt_up_sd_card_set_attributes+0x7c>
811458e0:	e0bffe0f 	ldh	r2,-8(fp)
811458e4:	10800508 	cmpgei	r2,r2,20
811458e8:	1000111e 	bne	r2,zero,81145930 <alt_up_sd_card_set_attributes+0x7c>
    {
        if (active_files[file_handle].in_use)
811458ec:	e0fffe0f 	ldh	r3,-8(fp)
811458f0:	00a045f4 	movhi	r2,33047
811458f4:	10b45e04 	addi	r2,r2,-11912
811458f8:	180691ba 	slli	r3,r3,6
811458fc:	10c5883a 	add	r2,r2,r3
81145900:	10800f04 	addi	r2,r2,60
81145904:	10800017 	ldw	r2,0(r2)
81145908:	10000926 	beq	r2,zero,81145930 <alt_up_sd_card_set_attributes+0x7c>
        {
            active_files[file_handle].attributes = ((char)(attributes & 0x00ff));
8114590c:	e0fffe0f 	ldh	r3,-8(fp)
81145910:	e0bfff0b 	ldhu	r2,-4(fp)
81145914:	1009883a 	mov	r4,r2
81145918:	00a045f4 	movhi	r2,33047
8114591c:	10b45e04 	addi	r2,r2,-11912
81145920:	180691ba 	slli	r3,r3,6
81145924:	10c5883a 	add	r2,r2,r3
81145928:	108002c4 	addi	r2,r2,11
8114592c:	11000005 	stb	r4,0(r2)
        }
    }
}
81145930:	0001883a 	nop
81145934:	e037883a 	mov	sp,fp
81145938:	df000017 	ldw	fp,0(sp)
8114593c:	dec00104 	addi	sp,sp,4
81145940:	f800283a 	ret

81145944 <alt_up_sd_card_get_attributes>:


short int alt_up_sd_card_get_attributes(short int file_handle)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
81145944:	defffd04 	addi	sp,sp,-12
81145948:	de00012e 	bgeu	sp,et,81145950 <alt_up_sd_card_get_attributes+0xc>
8114594c:	003b68fa 	trap	3
81145950:	df000215 	stw	fp,8(sp)
81145954:	df000204 	addi	fp,sp,8
81145958:	2005883a 	mov	r2,r4
8114595c:	e0bfff0d 	sth	r2,-4(fp)
	short int result = -1;
81145960:	00bfffc4 	movi	r2,-1
81145964:	e0bffe0d 	sth	r2,-8(fp)
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
81145968:	e0bfff0f 	ldh	r2,-4(fp)
8114596c:	10001416 	blt	r2,zero,811459c0 <alt_up_sd_card_get_attributes+0x7c>
81145970:	e0bfff0f 	ldh	r2,-4(fp)
81145974:	10800508 	cmpgei	r2,r2,20
81145978:	1000111e 	bne	r2,zero,811459c0 <alt_up_sd_card_get_attributes+0x7c>
    {
        if (active_files[file_handle].in_use)
8114597c:	e0ffff0f 	ldh	r3,-4(fp)
81145980:	00a045f4 	movhi	r2,33047
81145984:	10b45e04 	addi	r2,r2,-11912
81145988:	180691ba 	slli	r3,r3,6
8114598c:	10c5883a 	add	r2,r2,r3
81145990:	10800f04 	addi	r2,r2,60
81145994:	10800017 	ldw	r2,0(r2)
81145998:	10000926 	beq	r2,zero,811459c0 <alt_up_sd_card_get_attributes+0x7c>
		{
			result = ((active_files[file_handle].attributes) & 0x00ff);
8114599c:	e0ffff0f 	ldh	r3,-4(fp)
811459a0:	00a045f4 	movhi	r2,33047
811459a4:	10b45e04 	addi	r2,r2,-11912
811459a8:	180691ba 	slli	r3,r3,6
811459ac:	10c5883a 	add	r2,r2,r3
811459b0:	108002c4 	addi	r2,r2,11
811459b4:	10800003 	ldbu	r2,0(r2)
811459b8:	10803fcc 	andi	r2,r2,255
811459bc:	e0bffe0d 	sth	r2,-8(fp)
		}
	}
	return result;
811459c0:	e0bffe0b 	ldhu	r2,-8(fp)
}
811459c4:	e037883a 	mov	sp,fp
811459c8:	df000017 	ldw	fp,0(sp)
811459cc:	dec00104 	addi	sp,sp,4
811459d0:	f800283a 	ret

811459d4 <alt_up_sd_card_read>:

short int alt_up_sd_card_read(short int file_handle)
/* Read a single character from a given file. Return -1 if at the end of a file. Any other negative number
 * means that the file could not be read. A number between 0 and 255 is an ASCII character read from the SD Card. */
{
811459d4:	defffa04 	addi	sp,sp,-24
811459d8:	de00012e 	bgeu	sp,et,811459e0 <alt_up_sd_card_read+0xc>
811459dc:	003b68fa 	trap	3
811459e0:	dfc00515 	stw	ra,20(sp)
811459e4:	df000415 	stw	fp,16(sp)
811459e8:	df000404 	addi	fp,sp,16
811459ec:	2005883a 	mov	r2,r4
811459f0:	e0bfff0d 	sth	r2,-4(fp)
    short int ch = -1;
811459f4:	00bfffc4 	movi	r2,-1
811459f8:	e0bffc0d 	sth	r2,-16(fp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
811459fc:	e0bfff0f 	ldh	r2,-4(fp)
81145a00:	1000ce16 	blt	r2,zero,81145d3c <alt_up_sd_card_read+0x368>
81145a04:	e0bfff0f 	ldh	r2,-4(fp)
81145a08:	10800508 	cmpgei	r2,r2,20
81145a0c:	1000cb1e 	bne	r2,zero,81145d3c <alt_up_sd_card_read+0x368>
    {
        if (active_files[file_handle].in_use)
81145a10:	e0ffff0f 	ldh	r3,-4(fp)
81145a14:	00a045f4 	movhi	r2,33047
81145a18:	10b45e04 	addi	r2,r2,-11912
81145a1c:	180691ba 	slli	r3,r3,6
81145a20:	10c5883a 	add	r2,r2,r3
81145a24:	10800f04 	addi	r2,r2,60
81145a28:	10800017 	ldw	r2,0(r2)
81145a2c:	1000c326 	beq	r2,zero,81145d3c <alt_up_sd_card_read+0x368>
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
81145a30:	e0ffff0f 	ldh	r3,-4(fp)
81145a34:	00a045f4 	movhi	r2,33047
81145a38:	10b45e04 	addi	r2,r2,-11912
81145a3c:	180691ba 	slli	r3,r3,6
81145a40:	10c5883a 	add	r2,r2,r3
81145a44:	10800904 	addi	r2,r2,36
81145a48:	10c00017 	ldw	r3,0(r2)
81145a4c:	e13fff0f 	ldh	r4,-4(fp)
81145a50:	00a045f4 	movhi	r2,33047
81145a54:	10b45e04 	addi	r2,r2,-11912
81145a58:	200891ba 	slli	r4,r4,6
81145a5c:	1105883a 	add	r2,r2,r4
81145a60:	10800604 	addi	r2,r2,24
81145a64:	10800017 	ldw	r2,0(r2)
81145a68:	1880b42e 	bgeu	r3,r2,81145d3c <alt_up_sd_card_read+0x368>
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81145a6c:	00a045f4 	movhi	r2,33047
81145a70:	10b44904 	addi	r2,r2,-11996
81145a74:	10c01417 	ldw	r3,80(r2)
81145a78:	e13fff0f 	ldh	r4,-4(fp)
81145a7c:	00a045f4 	movhi	r2,33047
81145a80:	10b45e04 	addi	r2,r2,-11912
81145a84:	200891ba 	slli	r4,r4,6
81145a88:	1105883a 	add	r2,r2,r4
81145a8c:	10800704 	addi	r2,r2,28
81145a90:	10800017 	ldw	r2,0(r2)
81145a94:	113fff84 	addi	r4,r2,-2
81145a98:	00a045f4 	movhi	r2,33047
81145a9c:	10b44904 	addi	r2,r2,-11996
81145aa0:	10800383 	ldbu	r2,14(r2)
81145aa4:	10803fcc 	andi	r2,r2,255
81145aa8:	2085383a 	mul	r2,r4,r2
81145aac:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;
81145ab0:	e13fff0f 	ldh	r4,-4(fp)
81145ab4:	00a045f4 	movhi	r2,33047
81145ab8:	10b45e04 	addi	r2,r2,-11912
81145abc:	200891ba 	slli	r4,r4,6
81145ac0:	1105883a 	add	r2,r2,r4
81145ac4:	10800804 	addi	r2,r2,32
81145ac8:	10800017 	ldw	r2,0(r2)
    {
        if (active_files[file_handle].in_use)
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81145acc:	1885883a 	add	r2,r3,r2
81145ad0:	e0bffd15 	stw	r2,-12(fp)
                                  active_files[file_handle].current_sector_in_cluster;
                
                if ((active_files[file_handle].current_byte_position > 0) && ((active_files[file_handle].current_byte_position % 512) == 0))
81145ad4:	e0ffff0f 	ldh	r3,-4(fp)
81145ad8:	00a045f4 	movhi	r2,33047
81145adc:	10b45e04 	addi	r2,r2,-11912
81145ae0:	180691ba 	slli	r3,r3,6
81145ae4:	10c5883a 	add	r2,r2,r3
81145ae8:	10800904 	addi	r2,r2,36
81145aec:	10800017 	ldw	r2,0(r2)
81145af0:	10006826 	beq	r2,zero,81145c94 <alt_up_sd_card_read+0x2c0>
81145af4:	e0ffff0f 	ldh	r3,-4(fp)
81145af8:	00a045f4 	movhi	r2,33047
81145afc:	10b45e04 	addi	r2,r2,-11912
81145b00:	180691ba 	slli	r3,r3,6
81145b04:	10c5883a 	add	r2,r2,r3
81145b08:	10800904 	addi	r2,r2,36
81145b0c:	10800017 	ldw	r2,0(r2)
81145b10:	10807fcc 	andi	r2,r2,511
81145b14:	10005f1e 	bne	r2,zero,81145c94 <alt_up_sd_card_read+0x2c0>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
81145b18:	e0ffff0f 	ldh	r3,-4(fp)
81145b1c:	00a045f4 	movhi	r2,33047
81145b20:	10b45e04 	addi	r2,r2,-11912
81145b24:	180691ba 	slli	r3,r3,6
81145b28:	10c5883a 	add	r2,r2,r3
81145b2c:	10800804 	addi	r2,r2,32
81145b30:	10c00017 	ldw	r3,0(r2)
81145b34:	00a045f4 	movhi	r2,33047
81145b38:	10b44904 	addi	r2,r2,-11996
81145b3c:	10800383 	ldbu	r2,14(r2)
81145b40:	10803fcc 	andi	r2,r2,255
81145b44:	10bfffc4 	addi	r2,r2,-1
81145b48:	1880401e 	bne	r3,r2,81145c4c <alt_up_sd_card_read+0x278>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
81145b4c:	e0ffff0f 	ldh	r3,-4(fp)
81145b50:	00a045f4 	movhi	r2,33047
81145b54:	10b45e04 	addi	r2,r2,-11912
81145b58:	180691ba 	slli	r3,r3,6
81145b5c:	10c5883a 	add	r2,r2,r3
81145b60:	10800704 	addi	r2,r2,28
81145b64:	10800017 	ldw	r2,0(r2)
81145b68:	e0fffe04 	addi	r3,fp,-8
81145b6c:	180b883a 	mov	r5,r3
81145b70:	1009883a 	mov	r4,r2
81145b74:	11423600 	call	81142360 <get_cluster_flag>
81145b78:	10003226 	beq	r2,zero,81145c44 <alt_up_sd_card_read+0x270>
                        {
                            if ((next_cluster & 0x0000fff8) == 0x0000fff8)
81145b7c:	e0bffe0b 	ldhu	r2,-8(fp)
81145b80:	10bfffcc 	andi	r2,r2,65535
81145b84:	10fffe0c 	andi	r3,r2,65528
81145b88:	00bffe14 	movui	r2,65528
81145b8c:	1880021e 	bne	r3,r2,81145b98 <alt_up_sd_card_read+0x1c4>
                            {
                                /* End of file */
                                return -1;
81145b90:	00bfffc4 	movi	r2,-1
81145b94:	00006a06 	br	81145d40 <alt_up_sd_card_read+0x36c>
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
81145b98:	e13fff0f 	ldh	r4,-4(fp)
81145b9c:	e0bffe0b 	ldhu	r2,-8(fp)
81145ba0:	10ffffcc 	andi	r3,r2,65535
81145ba4:	00a045f4 	movhi	r2,33047
81145ba8:	10b45e04 	addi	r2,r2,-11912
81145bac:	200891ba 	slli	r4,r4,6
81145bb0:	1105883a 	add	r2,r2,r4
81145bb4:	10800704 	addi	r2,r2,28
81145bb8:	10c00015 	stw	r3,0(r2)
								active_files[file_handle].current_sector_in_cluster = 0;
81145bbc:	e0ffff0f 	ldh	r3,-4(fp)
81145bc0:	00a045f4 	movhi	r2,33047
81145bc4:	10b45e04 	addi	r2,r2,-11912
81145bc8:	180691ba 	slli	r3,r3,6
81145bcc:	10c5883a 	add	r2,r2,r3
81145bd0:	10800804 	addi	r2,r2,32
81145bd4:	10000015 	stw	zero,0(r2)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81145bd8:	00a045f4 	movhi	r2,33047
81145bdc:	10b44904 	addi	r2,r2,-11996
81145be0:	10c01417 	ldw	r3,80(r2)
81145be4:	e13fff0f 	ldh	r4,-4(fp)
81145be8:	00a045f4 	movhi	r2,33047
81145bec:	10b45e04 	addi	r2,r2,-11912
81145bf0:	200891ba 	slli	r4,r4,6
81145bf4:	1105883a 	add	r2,r2,r4
81145bf8:	10800704 	addi	r2,r2,28
81145bfc:	10800017 	ldw	r2,0(r2)
81145c00:	113fff84 	addi	r4,r2,-2
81145c04:	00a045f4 	movhi	r2,33047
81145c08:	10b44904 	addi	r2,r2,-11996
81145c0c:	10800383 	ldbu	r2,14(r2)
81145c10:	10803fcc 	andi	r2,r2,255
81145c14:	2085383a 	mul	r2,r4,r2
81145c18:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;                                
81145c1c:	e13fff0f 	ldh	r4,-4(fp)
81145c20:	00a045f4 	movhi	r2,33047
81145c24:	10b45e04 	addi	r2,r2,-11912
81145c28:	200891ba 	slli	r4,r4,6
81145c2c:	1105883a 	add	r2,r2,r4
81145c30:	10800804 	addi	r2,r2,32
81145c34:	10800017 	ldw	r2,0(r2)
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81145c38:	1885883a 	add	r2,r3,r2
81145c3c:	e0bffd15 	stw	r2,-12(fp)
81145c40:	00001406 	br	81145c94 <alt_up_sd_card_read+0x2c0>
                                  active_files[file_handle].current_sector_in_cluster;                                
                            }
                        }
                        else
                        {
                            return -2;
81145c44:	00bfff84 	movi	r2,-2
81145c48:	00003d06 	br	81145d40 <alt_up_sd_card_read+0x36c>
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
81145c4c:	e13fff0f 	ldh	r4,-4(fp)
81145c50:	e0ffff0f 	ldh	r3,-4(fp)
81145c54:	00a045f4 	movhi	r2,33047
81145c58:	10b45e04 	addi	r2,r2,-11912
81145c5c:	180691ba 	slli	r3,r3,6
81145c60:	10c5883a 	add	r2,r2,r3
81145c64:	10800804 	addi	r2,r2,32
81145c68:	10800017 	ldw	r2,0(r2)
81145c6c:	10c00044 	addi	r3,r2,1
81145c70:	00a045f4 	movhi	r2,33047
81145c74:	10b45e04 	addi	r2,r2,-11912
81145c78:	200891ba 	slli	r4,r4,6
81145c7c:	1105883a 	add	r2,r2,r4
81145c80:	10800804 	addi	r2,r2,32
81145c84:	10c00015 	stw	r3,0(r2)
                        data_sector = data_sector + 1;
81145c88:	e0bffd17 	ldw	r2,-12(fp)
81145c8c:	10800044 	addi	r2,r2,1
81145c90:	e0bffd15 	stw	r2,-12(fp)
                    }
                }
                // Reading te first byte of the file.
                if (current_sector_index != (data_sector + fat_partition_offset_in_512_byte_sectors))
81145c94:	d0e0b117 	ldw	r3,-32060(gp)
81145c98:	e0bffd17 	ldw	r2,-12(fp)
81145c9c:	1885883a 	add	r2,r3,r2
81145ca0:	1007883a 	mov	r3,r2
81145ca4:	d0a0b517 	ldw	r2,-32044(gp)
81145ca8:	18800726 	beq	r3,r2,81145cc8 <alt_up_sd_card_read+0x2f4>
                {
                    if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
81145cac:	d0a0b117 	ldw	r2,-32060(gp)
81145cb0:	100b883a 	mov	r5,r2
81145cb4:	e13ffd17 	ldw	r4,-12(fp)
81145cb8:	11422800 	call	81142280 <Read_Sector_Data>
81145cbc:	1000021e 	bne	r2,zero,81145cc8 <alt_up_sd_card_read+0x2f4>
                    {
						return -2;
81145cc0:	00bfff84 	movi	r2,-2
81145cc4:	00001e06 	br	81145d40 <alt_up_sd_card_read+0x36c>
                    }
                }

                ch = (unsigned char) IORD_8DIRECT(buffer_memory, (active_files[file_handle].current_byte_position % 512));
81145cc8:	d0e0b017 	ldw	r3,-32064(gp)
81145ccc:	e13fff0f 	ldh	r4,-4(fp)
81145cd0:	00a045f4 	movhi	r2,33047
81145cd4:	10b45e04 	addi	r2,r2,-11912
81145cd8:	200891ba 	slli	r4,r4,6
81145cdc:	1105883a 	add	r2,r2,r4
81145ce0:	10800904 	addi	r2,r2,36
81145ce4:	10800017 	ldw	r2,0(r2)
81145ce8:	10807fcc 	andi	r2,r2,511
81145cec:	1885883a 	add	r2,r3,r2
81145cf0:	10800023 	ldbuio	r2,0(r2)
81145cf4:	10803fcc 	andi	r2,r2,255
81145cf8:	10803fcc 	andi	r2,r2,255
81145cfc:	e0bffc0d 	sth	r2,-16(fp)
                active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
81145d00:	e13fff0f 	ldh	r4,-4(fp)
81145d04:	e0ffff0f 	ldh	r3,-4(fp)
81145d08:	00a045f4 	movhi	r2,33047
81145d0c:	10b45e04 	addi	r2,r2,-11912
81145d10:	180691ba 	slli	r3,r3,6
81145d14:	10c5883a 	add	r2,r2,r3
81145d18:	10800904 	addi	r2,r2,36
81145d1c:	10800017 	ldw	r2,0(r2)
81145d20:	10c00044 	addi	r3,r2,1
81145d24:	00a045f4 	movhi	r2,33047
81145d28:	10b45e04 	addi	r2,r2,-11912
81145d2c:	200891ba 	slli	r4,r4,6
81145d30:	1105883a 	add	r2,r2,r4
81145d34:	10800904 	addi	r2,r2,36
81145d38:	10c00015 	stw	r3,0(r2)
            }
        }
    }
    
    return ch;
81145d3c:	e0bffc0b 	ldhu	r2,-16(fp)
}
81145d40:	e037883a 	mov	sp,fp
81145d44:	dfc00117 	ldw	ra,4(sp)
81145d48:	df000017 	ldw	fp,0(sp)
81145d4c:	dec00204 	addi	sp,sp,8
81145d50:	f800283a 	ret

81145d54 <alt_up_sd_card_write>:


bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
81145d54:	defff804 	addi	sp,sp,-32
81145d58:	de00012e 	bgeu	sp,et,81145d60 <alt_up_sd_card_write+0xc>
81145d5c:	003b68fa 	trap	3
81145d60:	dfc00715 	stw	ra,28(sp)
81145d64:	df000615 	stw	fp,24(sp)
81145d68:	df000604 	addi	fp,sp,24
81145d6c:	2007883a 	mov	r3,r4
81145d70:	2805883a 	mov	r2,r5
81145d74:	e0fffe0d 	sth	r3,-8(fp)
81145d78:	e0bfff05 	stb	r2,-4(fp)
    bool result = false;
81145d7c:	e03ffa15 	stw	zero,-24(fp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
81145d80:	e0bffe0f 	ldh	r2,-8(fp)
81145d84:	10017716 	blt	r2,zero,81146364 <alt_up_sd_card_write+0x610>
81145d88:	e0bffe0f 	ldh	r2,-8(fp)
81145d8c:	10800508 	cmpgei	r2,r2,20
81145d90:	1001741e 	bne	r2,zero,81146364 <alt_up_sd_card_write+0x610>
    {
        if (active_files[file_handle].in_use)
81145d94:	e0fffe0f 	ldh	r3,-8(fp)
81145d98:	00a045f4 	movhi	r2,33047
81145d9c:	10b45e04 	addi	r2,r2,-11912
81145da0:	180691ba 	slli	r3,r3,6
81145da4:	10c5883a 	add	r2,r2,r3
81145da8:	10800f04 	addi	r2,r2,60
81145dac:	10800017 	ldw	r2,0(r2)
81145db0:	10016c26 	beq	r2,zero,81146364 <alt_up_sd_card_write+0x610>
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81145db4:	00a045f4 	movhi	r2,33047
81145db8:	10b44904 	addi	r2,r2,-11996
81145dbc:	10c01417 	ldw	r3,80(r2)
81145dc0:	e13ffe0f 	ldh	r4,-8(fp)
81145dc4:	00a045f4 	movhi	r2,33047
81145dc8:	10b45e04 	addi	r2,r2,-11912
81145dcc:	200891ba 	slli	r4,r4,6
81145dd0:	1105883a 	add	r2,r2,r4
81145dd4:	10800704 	addi	r2,r2,28
81145dd8:	10800017 	ldw	r2,0(r2)
81145ddc:	113fff84 	addi	r4,r2,-2
81145de0:	00a045f4 	movhi	r2,33047
81145de4:	10b44904 	addi	r2,r2,-11996
81145de8:	10800383 	ldbu	r2,14(r2)
81145dec:	10803fcc 	andi	r2,r2,255
81145df0:	2085383a 	mul	r2,r4,r2
81145df4:	1887883a 	add	r3,r3,r2
                              active_files[file_handle].current_sector_in_cluster;
81145df8:	e13ffe0f 	ldh	r4,-8(fp)
81145dfc:	00a045f4 	movhi	r2,33047
81145e00:	10b45e04 	addi	r2,r2,-11912
81145e04:	200891ba 	slli	r4,r4,6
81145e08:	1105883a 	add	r2,r2,r4
81145e0c:	10800804 	addi	r2,r2,32
81145e10:	10800017 	ldw	r2,0(r2)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81145e14:	1885883a 	add	r2,r3,r2
81145e18:	e0bffb15 	stw	r2,-20(fp)
                              active_files[file_handle].current_sector_in_cluster;
			short int buffer_offset = active_files[file_handle].current_byte_position % boot_sector_data.sector_size_in_bytes;
81145e1c:	e0fffe0f 	ldh	r3,-8(fp)
81145e20:	00a045f4 	movhi	r2,33047
81145e24:	10b45e04 	addi	r2,r2,-11912
81145e28:	180691ba 	slli	r3,r3,6
81145e2c:	10c5883a 	add	r2,r2,r3
81145e30:	10800904 	addi	r2,r2,36
81145e34:	10c00017 	ldw	r3,0(r2)
81145e38:	00a045f4 	movhi	r2,33047
81145e3c:	10b44904 	addi	r2,r2,-11996
81145e40:	1080030b 	ldhu	r2,12(r2)
81145e44:	10bfffcc 	andi	r2,r2,65535
81145e48:	1889203a 	divu	r4,r3,r2
81145e4c:	2085383a 	mul	r2,r4,r2
81145e50:	1885c83a 	sub	r2,r3,r2
81145e54:	e0bffc0d 	sth	r2,-16(fp)

			if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
81145e58:	e0fffe0f 	ldh	r3,-8(fp)
81145e5c:	00a045f4 	movhi	r2,33047
81145e60:	10b45e04 	addi	r2,r2,-11912
81145e64:	180691ba 	slli	r3,r3,6
81145e68:	10c5883a 	add	r2,r2,r3
81145e6c:	10800904 	addi	r2,r2,36
81145e70:	10c00017 	ldw	r3,0(r2)
81145e74:	e13ffe0f 	ldh	r4,-8(fp)
81145e78:	00a045f4 	movhi	r2,33047
81145e7c:	10b45e04 	addi	r2,r2,-11912
81145e80:	200891ba 	slli	r4,r4,6
81145e84:	1105883a 	add	r2,r2,r4
81145e88:	10800604 	addi	r2,r2,24
81145e8c:	10800017 	ldw	r2,0(r2)
81145e90:	1880672e 	bgeu	r3,r2,81146030 <alt_up_sd_card_write+0x2dc>
            {
                if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
81145e94:	e0fffe0f 	ldh	r3,-8(fp)
81145e98:	00a045f4 	movhi	r2,33047
81145e9c:	10b45e04 	addi	r2,r2,-11912
81145ea0:	180691ba 	slli	r3,r3,6
81145ea4:	10c5883a 	add	r2,r2,r3
81145ea8:	10800904 	addi	r2,r2,36
81145eac:	10800017 	ldw	r2,0(r2)
81145eb0:	1000e126 	beq	r2,zero,81146238 <alt_up_sd_card_write+0x4e4>
81145eb4:	e0bffc0f 	ldh	r2,-16(fp)
81145eb8:	1000df1e 	bne	r2,zero,81146238 <alt_up_sd_card_write+0x4e4>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
81145ebc:	e0fffe0f 	ldh	r3,-8(fp)
81145ec0:	00a045f4 	movhi	r2,33047
81145ec4:	10b45e04 	addi	r2,r2,-11912
81145ec8:	180691ba 	slli	r3,r3,6
81145ecc:	10c5883a 	add	r2,r2,r3
81145ed0:	10800804 	addi	r2,r2,32
81145ed4:	10c00017 	ldw	r3,0(r2)
81145ed8:	00a045f4 	movhi	r2,33047
81145edc:	10b44904 	addi	r2,r2,-11996
81145ee0:	10800383 	ldbu	r2,14(r2)
81145ee4:	10803fcc 	andi	r2,r2,255
81145ee8:	10bfffc4 	addi	r2,r2,-1
81145eec:	18803d1e 	bne	r3,r2,81145fe4 <alt_up_sd_card_write+0x290>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
81145ef0:	e0fffe0f 	ldh	r3,-8(fp)
81145ef4:	00a045f4 	movhi	r2,33047
81145ef8:	10b45e04 	addi	r2,r2,-11912
81145efc:	180691ba 	slli	r3,r3,6
81145f00:	10c5883a 	add	r2,r2,r3
81145f04:	10800704 	addi	r2,r2,28
81145f08:	10800017 	ldw	r2,0(r2)
81145f0c:	e0fffc84 	addi	r3,fp,-14
81145f10:	180b883a 	mov	r5,r3
81145f14:	1009883a 	mov	r4,r2
81145f18:	11423600 	call	81142360 <get_cluster_flag>
81145f1c:	10002f26 	beq	r2,zero,81145fdc <alt_up_sd_card_write+0x288>
                        {
                            if (next_cluster < 0x0000fff8)
81145f20:	e0bffc8b 	ldhu	r2,-14(fp)
81145f24:	10bfffcc 	andi	r2,r2,65535
81145f28:	10bffe28 	cmpgeui	r2,r2,65528
81145f2c:	1000c21e 	bne	r2,zero,81146238 <alt_up_sd_card_write+0x4e4>
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
81145f30:	e13ffe0f 	ldh	r4,-8(fp)
81145f34:	e0bffc8b 	ldhu	r2,-14(fp)
81145f38:	10ffffcc 	andi	r3,r2,65535
81145f3c:	00a045f4 	movhi	r2,33047
81145f40:	10b45e04 	addi	r2,r2,-11912
81145f44:	200891ba 	slli	r4,r4,6
81145f48:	1105883a 	add	r2,r2,r4
81145f4c:	10800704 	addi	r2,r2,28
81145f50:	10c00015 	stw	r3,0(r2)
								active_files[file_handle].current_sector_in_cluster = 0;
81145f54:	e0fffe0f 	ldh	r3,-8(fp)
81145f58:	00a045f4 	movhi	r2,33047
81145f5c:	10b45e04 	addi	r2,r2,-11912
81145f60:	180691ba 	slli	r3,r3,6
81145f64:	10c5883a 	add	r2,r2,r3
81145f68:	10800804 	addi	r2,r2,32
81145f6c:	10000015 	stw	zero,0(r2)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81145f70:	00a045f4 	movhi	r2,33047
81145f74:	10b44904 	addi	r2,r2,-11996
81145f78:	10c01417 	ldw	r3,80(r2)
81145f7c:	e13ffe0f 	ldh	r4,-8(fp)
81145f80:	00a045f4 	movhi	r2,33047
81145f84:	10b45e04 	addi	r2,r2,-11912
81145f88:	200891ba 	slli	r4,r4,6
81145f8c:	1105883a 	add	r2,r2,r4
81145f90:	10800704 	addi	r2,r2,28
81145f94:	10800017 	ldw	r2,0(r2)
81145f98:	113fff84 	addi	r4,r2,-2
81145f9c:	00a045f4 	movhi	r2,33047
81145fa0:	10b44904 	addi	r2,r2,-11996
81145fa4:	10800383 	ldbu	r2,14(r2)
81145fa8:	10803fcc 	andi	r2,r2,255
81145fac:	2085383a 	mul	r2,r4,r2
81145fb0:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;                                
81145fb4:	e13ffe0f 	ldh	r4,-8(fp)
81145fb8:	00a045f4 	movhi	r2,33047
81145fbc:	10b45e04 	addi	r2,r2,-11912
81145fc0:	200891ba 	slli	r4,r4,6
81145fc4:	1105883a 	add	r2,r2,r4
81145fc8:	10800804 	addi	r2,r2,32
81145fcc:	10800017 	ldw	r2,0(r2)
                        {
                            if (next_cluster < 0x0000fff8)
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81145fd0:	1885883a 	add	r2,r3,r2
81145fd4:	e0bffb15 	stw	r2,-20(fp)
81145fd8:	00009706 	br	81146238 <alt_up_sd_card_write+0x4e4>
                                  active_files[file_handle].current_sector_in_cluster;                                
                            }
                        }
                        else
                        {
                            return false;
81145fdc:	0005883a 	mov	r2,zero
81145fe0:	0000e106 	br	81146368 <alt_up_sd_card_write+0x614>
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
81145fe4:	e13ffe0f 	ldh	r4,-8(fp)
81145fe8:	e0fffe0f 	ldh	r3,-8(fp)
81145fec:	00a045f4 	movhi	r2,33047
81145ff0:	10b45e04 	addi	r2,r2,-11912
81145ff4:	180691ba 	slli	r3,r3,6
81145ff8:	10c5883a 	add	r2,r2,r3
81145ffc:	10800804 	addi	r2,r2,32
81146000:	10800017 	ldw	r2,0(r2)
81146004:	10c00044 	addi	r3,r2,1
81146008:	00a045f4 	movhi	r2,33047
8114600c:	10b45e04 	addi	r2,r2,-11912
81146010:	200891ba 	slli	r4,r4,6
81146014:	1105883a 	add	r2,r2,r4
81146018:	10800804 	addi	r2,r2,32
8114601c:	10c00015 	stw	r3,0(r2)
                        data_sector = data_sector + 1;
81146020:	e0bffb17 	ldw	r2,-20(fp)
81146024:	10800044 	addi	r2,r2,1
81146028:	e0bffb15 	stw	r2,-20(fp)
8114602c:	00008206 	br	81146238 <alt_up_sd_card_write+0x4e4>
                }
            }
			else
			{
				/* You are adding data to the end of the file, so increment its size and look for an additional data cluster if needed. */
				if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
81146030:	e0fffe0f 	ldh	r3,-8(fp)
81146034:	00a045f4 	movhi	r2,33047
81146038:	10b45e04 	addi	r2,r2,-11912
8114603c:	180691ba 	slli	r3,r3,6
81146040:	10c5883a 	add	r2,r2,r3
81146044:	10800904 	addi	r2,r2,36
81146048:	10800017 	ldw	r2,0(r2)
8114604c:	10007a26 	beq	r2,zero,81146238 <alt_up_sd_card_write+0x4e4>
81146050:	e0bffc0f 	ldh	r2,-16(fp)
81146054:	1000781e 	bne	r2,zero,81146238 <alt_up_sd_card_write+0x4e4>
				{
					if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
81146058:	e0fffe0f 	ldh	r3,-8(fp)
8114605c:	00a045f4 	movhi	r2,33047
81146060:	10b45e04 	addi	r2,r2,-11912
81146064:	180691ba 	slli	r3,r3,6
81146068:	10c5883a 	add	r2,r2,r3
8114606c:	10800804 	addi	r2,r2,32
81146070:	10c00017 	ldw	r3,0(r2)
81146074:	00a045f4 	movhi	r2,33047
81146078:	10b44904 	addi	r2,r2,-11996
8114607c:	10800383 	ldbu	r2,14(r2)
81146080:	10803fcc 	andi	r2,r2,255
81146084:	10bfffc4 	addi	r2,r2,-1
81146088:	18803e1e 	bne	r3,r2,81146184 <alt_up_sd_card_write+0x430>
					{
						/* Find a new cluster if possible. */
						unsigned int cluster_number;

						if (find_first_empty_cluster(&cluster_number))
8114608c:	e0bffd04 	addi	r2,fp,-12
81146090:	1009883a 	mov	r4,r2
81146094:	11443a40 	call	811443a4 <find_first_empty_cluster>
81146098:	10003826 	beq	r2,zero,8114617c <alt_up_sd_card_write+0x428>
						{
							// mark clusters in both File Allocation Tables.
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), true);
8114609c:	e0fffe0f 	ldh	r3,-8(fp)
811460a0:	00a045f4 	movhi	r2,33047
811460a4:	10b45e04 	addi	r2,r2,-11912
811460a8:	180691ba 	slli	r3,r3,6
811460ac:	10c5883a 	add	r2,r2,r3
811460b0:	10800704 	addi	r2,r2,28
811460b4:	10800017 	ldw	r2,0(r2)
811460b8:	e0fffd17 	ldw	r3,-12(fp)
811460bc:	18ffffcc 	andi	r3,r3,65535
811460c0:	18e0001c 	xori	r3,r3,32768
811460c4:	18e00004 	addi	r3,r3,-32768
811460c8:	01800044 	movi	r6,1
811460cc:	180b883a 	mov	r5,r3
811460d0:	1009883a 	mov	r4,r2
811460d4:	114241c0 	call	8114241c <mark_cluster>
							mark_cluster(cluster_number, 0xffff, true);
811460d8:	e0bffd17 	ldw	r2,-12(fp)
811460dc:	01800044 	movi	r6,1
811460e0:	017fffc4 	movi	r5,-1
811460e4:	1009883a 	mov	r4,r2
811460e8:	114241c0 	call	8114241c <mark_cluster>
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), false);
811460ec:	e0fffe0f 	ldh	r3,-8(fp)
811460f0:	00a045f4 	movhi	r2,33047
811460f4:	10b45e04 	addi	r2,r2,-11912
811460f8:	180691ba 	slli	r3,r3,6
811460fc:	10c5883a 	add	r2,r2,r3
81146100:	10800704 	addi	r2,r2,28
81146104:	10800017 	ldw	r2,0(r2)
81146108:	e0fffd17 	ldw	r3,-12(fp)
8114610c:	18ffffcc 	andi	r3,r3,65535
81146110:	18e0001c 	xori	r3,r3,32768
81146114:	18e00004 	addi	r3,r3,-32768
81146118:	000d883a 	mov	r6,zero
8114611c:	180b883a 	mov	r5,r3
81146120:	1009883a 	mov	r4,r2
81146124:	114241c0 	call	8114241c <mark_cluster>
							mark_cluster(cluster_number, 0xffff, false);
81146128:	e0bffd17 	ldw	r2,-12(fp)
8114612c:	000d883a 	mov	r6,zero
81146130:	017fffc4 	movi	r5,-1
81146134:	1009883a 	mov	r4,r2
81146138:	114241c0 	call	8114241c <mark_cluster>
							// Change cluster index and sector index to compute a new data sector.
							active_files[file_handle].current_cluster_index = cluster_number;
8114613c:	e13ffe0f 	ldh	r4,-8(fp)
81146140:	e0fffd17 	ldw	r3,-12(fp)
81146144:	00a045f4 	movhi	r2,33047
81146148:	10b45e04 	addi	r2,r2,-11912
8114614c:	200891ba 	slli	r4,r4,6
81146150:	1105883a 	add	r2,r2,r4
81146154:	10800704 	addi	r2,r2,28
81146158:	10c00015 	stw	r3,0(r2)
							active_files[file_handle].current_sector_in_cluster = 0;
8114615c:	e0fffe0f 	ldh	r3,-8(fp)
81146160:	00a045f4 	movhi	r2,33047
81146164:	10b45e04 	addi	r2,r2,-11912
81146168:	180691ba 	slli	r3,r3,6
8114616c:	10c5883a 	add	r2,r2,r3
81146170:	10800804 	addi	r2,r2,32
81146174:	10000015 	stw	zero,0(r2)
81146178:	00001506 	br	811461d0 <alt_up_sd_card_write+0x47c>
						}
						else
						{
							return false;
8114617c:	0005883a 	mov	r2,zero
81146180:	00007906 	br	81146368 <alt_up_sd_card_write+0x614>
						}
					}
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
81146184:	e13ffe0f 	ldh	r4,-8(fp)
81146188:	e0fffe0f 	ldh	r3,-8(fp)
8114618c:	00a045f4 	movhi	r2,33047
81146190:	10b45e04 	addi	r2,r2,-11912
81146194:	180691ba 	slli	r3,r3,6
81146198:	10c5883a 	add	r2,r2,r3
8114619c:	10800904 	addi	r2,r2,36
811461a0:	10c00017 	ldw	r3,0(r2)
811461a4:	00a045f4 	movhi	r2,33047
811461a8:	10b44904 	addi	r2,r2,-11996
811461ac:	1080030b 	ldhu	r2,12(r2)
811461b0:	10bfffcc 	andi	r2,r2,65535
811461b4:	1887203a 	divu	r3,r3,r2
811461b8:	00a045f4 	movhi	r2,33047
811461bc:	10b45e04 	addi	r2,r2,-11912
811461c0:	200891ba 	slli	r4,r4,6
811461c4:	1105883a 	add	r2,r2,r4
811461c8:	10800804 	addi	r2,r2,32
811461cc:	10c00015 	stw	r3,0(r2)
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
811461d0:	00a045f4 	movhi	r2,33047
811461d4:	10b44904 	addi	r2,r2,-11996
811461d8:	10c01417 	ldw	r3,80(r2)
811461dc:	e13ffe0f 	ldh	r4,-8(fp)
811461e0:	00a045f4 	movhi	r2,33047
811461e4:	10b45e04 	addi	r2,r2,-11912
811461e8:	200891ba 	slli	r4,r4,6
811461ec:	1105883a 	add	r2,r2,r4
811461f0:	10800704 	addi	r2,r2,28
811461f4:	10800017 	ldw	r2,0(r2)
811461f8:	113fff84 	addi	r4,r2,-2
811461fc:	00a045f4 	movhi	r2,33047
81146200:	10b44904 	addi	r2,r2,-11996
81146204:	10800383 	ldbu	r2,14(r2)
81146208:	10803fcc 	andi	r2,r2,255
8114620c:	2085383a 	mul	r2,r4,r2
81146210:	1887883a 	add	r3,r3,r2
                          active_files[file_handle].current_sector_in_cluster;
81146214:	e13ffe0f 	ldh	r4,-8(fp)
81146218:	00a045f4 	movhi	r2,33047
8114621c:	10b45e04 	addi	r2,r2,-11912
81146220:	200891ba 	slli	r4,r4,6
81146224:	1105883a 	add	r2,r2,r4
81146228:	10800804 	addi	r2,r2,32
8114622c:	10800017 	ldw	r2,0(r2)
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81146230:	1885883a 	add	r2,r3,r2
81146234:	e0bffb15 	stw	r2,-20(fp)
                          active_files[file_handle].current_sector_in_cluster;
				}
			}
            // Reading a data sector into the buffer. Note that changes to the most recently modified sector will be saved before
			// a new sector is read from the SD Card.
            if (current_sector_index != data_sector + fat_partition_offset_in_512_byte_sectors)
81146238:	d0e0b117 	ldw	r3,-32060(gp)
8114623c:	e0bffb17 	ldw	r2,-20(fp)
81146240:	1885883a 	add	r2,r3,r2
81146244:	1007883a 	mov	r3,r2
81146248:	d0a0b517 	ldw	r2,-32044(gp)
8114624c:	18800726 	beq	r3,r2,8114626c <alt_up_sd_card_write+0x518>
            {
                if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
81146250:	d0a0b117 	ldw	r2,-32060(gp)
81146254:	100b883a 	mov	r5,r2
81146258:	e13ffb17 	ldw	r4,-20(fp)
8114625c:	11422800 	call	81142280 <Read_Sector_Data>
81146260:	1000021e 	bne	r2,zero,8114626c <alt_up_sd_card_write+0x518>
                {
					return false;
81146264:	0005883a 	mov	r2,zero
81146268:	00003f06 	br	81146368 <alt_up_sd_card_write+0x614>
                }
            }
            // Write a byte of data to the buffer.
			IOWR_8DIRECT(buffer_memory, buffer_offset, byte_of_data);
8114626c:	d0e0b017 	ldw	r3,-32064(gp)
81146270:	e0bffc0f 	ldh	r2,-16(fp)
81146274:	1885883a 	add	r2,r3,r2
81146278:	e0ffff07 	ldb	r3,-4(fp)
8114627c:	10c00025 	stbio	r3,0(r2)
			active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
81146280:	e13ffe0f 	ldh	r4,-8(fp)
81146284:	e0fffe0f 	ldh	r3,-8(fp)
81146288:	00a045f4 	movhi	r2,33047
8114628c:	10b45e04 	addi	r2,r2,-11912
81146290:	180691ba 	slli	r3,r3,6
81146294:	10c5883a 	add	r2,r2,r3
81146298:	10800904 	addi	r2,r2,36
8114629c:	10800017 	ldw	r2,0(r2)
811462a0:	10c00044 	addi	r3,r2,1
811462a4:	00a045f4 	movhi	r2,33047
811462a8:	10b45e04 	addi	r2,r2,-11912
811462ac:	200891ba 	slli	r4,r4,6
811462b0:	1105883a 	add	r2,r2,r4
811462b4:	10800904 	addi	r2,r2,36
811462b8:	10c00015 	stw	r3,0(r2)

			// Modify the file record only when necessary.
			if (active_files[file_handle].current_byte_position >= active_files[file_handle].file_size_in_bytes)
811462bc:	e0fffe0f 	ldh	r3,-8(fp)
811462c0:	00a045f4 	movhi	r2,33047
811462c4:	10b45e04 	addi	r2,r2,-11912
811462c8:	180691ba 	slli	r3,r3,6
811462cc:	10c5883a 	add	r2,r2,r3
811462d0:	10800904 	addi	r2,r2,36
811462d4:	10c00017 	ldw	r3,0(r2)
811462d8:	e13ffe0f 	ldh	r4,-8(fp)
811462dc:	00a045f4 	movhi	r2,33047
811462e0:	10b45e04 	addi	r2,r2,-11912
811462e4:	200891ba 	slli	r4,r4,6
811462e8:	1105883a 	add	r2,r2,r4
811462ec:	10800604 	addi	r2,r2,24
811462f0:	10800017 	ldw	r2,0(r2)
811462f4:	18801736 	bltu	r3,r2,81146354 <alt_up_sd_card_write+0x600>
			{
				active_files[file_handle].file_size_in_bytes = active_files[file_handle].file_size_in_bytes + 1;
811462f8:	e13ffe0f 	ldh	r4,-8(fp)
811462fc:	e0fffe0f 	ldh	r3,-8(fp)
81146300:	00a045f4 	movhi	r2,33047
81146304:	10b45e04 	addi	r2,r2,-11912
81146308:	180691ba 	slli	r3,r3,6
8114630c:	10c5883a 	add	r2,r2,r3
81146310:	10800604 	addi	r2,r2,24
81146314:	10800017 	ldw	r2,0(r2)
81146318:	10c00044 	addi	r3,r2,1
8114631c:	00a045f4 	movhi	r2,33047
81146320:	10b45e04 	addi	r2,r2,-11912
81146324:	200891ba 	slli	r4,r4,6
81146328:	1105883a 	add	r2,r2,r4
8114632c:	10800604 	addi	r2,r2,24
81146330:	10c00015 	stw	r3,0(r2)
				active_files[file_handle].modified = true;
81146334:	e0fffe0f 	ldh	r3,-8(fp)
81146338:	00a045f4 	movhi	r2,33047
8114633c:	10b45e04 	addi	r2,r2,-11912
81146340:	180691ba 	slli	r3,r3,6
81146344:	10c5883a 	add	r2,r2,r3
81146348:	10800e04 	addi	r2,r2,56
8114634c:	00c00044 	movi	r3,1
81146350:	10c00015 	stw	r3,0(r2)
			}
            // Invaldiate the buffer to ensure that the buffer contents are written to the SD card whe nthe file is closed.
            current_sector_modified = true;
81146354:	00800044 	movi	r2,1
81146358:	d0a0b415 	stw	r2,-32048(gp)
			result = true;
8114635c:	00800044 	movi	r2,1
81146360:	e0bffa15 	stw	r2,-24(fp)
		}
    }
    
    return result;
81146364:	e0bffa17 	ldw	r2,-24(fp)
}
81146368:	e037883a 	mov	sp,fp
8114636c:	dfc00117 	ldw	ra,4(sp)
81146370:	df000017 	ldw	fp,0(sp)
81146374:	dec00204 	addi	sp,sp,8
81146378:	f800283a 	ret

8114637c <alt_up_sd_card_fclose>:


bool alt_up_sd_card_fclose(short int file_handle)
// This function closes an opened file and saves data to SD Card if necessary.
{
8114637c:	defffb04 	addi	sp,sp,-20
81146380:	de00012e 	bgeu	sp,et,81146388 <alt_up_sd_card_fclose+0xc>
81146384:	003b68fa 	trap	3
81146388:	dfc00415 	stw	ra,16(sp)
8114638c:	df000315 	stw	fp,12(sp)
81146390:	df000304 	addi	fp,sp,12
81146394:	2005883a 	mov	r2,r4
81146398:	e0bfff0d 	sth	r2,-4(fp)
    bool result = false;
8114639c:	e03ffd15 	stw	zero,-12(fp)
    if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
811463a0:	1144f580 	call	81144f58 <alt_up_sd_card_is_Present>
811463a4:	10006026 	beq	r2,zero,81146528 <alt_up_sd_card_fclose+0x1ac>
811463a8:	d0a0aa17 	ldw	r2,-32088(gp)
811463ac:	10005e26 	beq	r2,zero,81146528 <alt_up_sd_card_fclose+0x1ac>
    {
        if (active_files[file_handle].in_use) 
811463b0:	e0ffff0f 	ldh	r3,-4(fp)
811463b4:	00a045f4 	movhi	r2,33047
811463b8:	10b45e04 	addi	r2,r2,-11912
811463bc:	180691ba 	slli	r3,r3,6
811463c0:	10c5883a 	add	r2,r2,r3
811463c4:	10800f04 	addi	r2,r2,60
811463c8:	10800017 	ldw	r2,0(r2)
811463cc:	10005626 	beq	r2,zero,81146528 <alt_up_sd_card_fclose+0x1ac>
        {
			if (active_files[file_handle].modified)
811463d0:	e0ffff0f 	ldh	r3,-4(fp)
811463d4:	00a045f4 	movhi	r2,33047
811463d8:	10b45e04 	addi	r2,r2,-11912
811463dc:	180691ba 	slli	r3,r3,6
811463e0:	10c5883a 	add	r2,r2,r3
811463e4:	10800e04 	addi	r2,r2,56
811463e8:	10800017 	ldw	r2,0(r2)
811463ec:	10004526 	beq	r2,zero,81146504 <alt_up_sd_card_fclose+0x188>
			{
				unsigned int record_sector = active_files[file_handle].file_record_sector_in_cluster;
811463f0:	e0ffff0f 	ldh	r3,-4(fp)
811463f4:	00a045f4 	movhi	r2,33047
811463f8:	10b45e04 	addi	r2,r2,-11912
811463fc:	180691ba 	slli	r3,r3,6
81146400:	10c5883a 	add	r2,r2,r3
81146404:	10800b04 	addi	r2,r2,44
81146408:	10800017 	ldw	r2,0(r2)
8114640c:	e0bffe15 	stw	r2,-8(fp)
				if (active_files[file_handle].file_record_cluster == 0)
81146410:	e0ffff0f 	ldh	r3,-4(fp)
81146414:	00a045f4 	movhi	r2,33047
81146418:	10b45e04 	addi	r2,r2,-11912
8114641c:	180691ba 	slli	r3,r3,6
81146420:	10c5883a 	add	r2,r2,r3
81146424:	10800a04 	addi	r2,r2,40
81146428:	10800017 	ldw	r2,0(r2)
8114642c:	1000071e 	bne	r2,zero,8114644c <alt_up_sd_card_fclose+0xd0>
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
81146430:	00a045f4 	movhi	r2,33047
81146434:	10b44904 	addi	r2,r2,-11996
81146438:	10801317 	ldw	r2,76(r2)
8114643c:	e0fffe17 	ldw	r3,-8(fp)
81146440:	1885883a 	add	r2,r3,r2
81146444:	e0bffe15 	stw	r2,-8(fp)
81146448:	00001406 	br	8114649c <alt_up_sd_card_fclose+0x120>
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
8114644c:	00a045f4 	movhi	r2,33047
81146450:	10b44904 	addi	r2,r2,-11996
81146454:	10c01417 	ldw	r3,80(r2)
81146458:	e0bffe17 	ldw	r2,-8(fp)
8114645c:	1887883a 	add	r3,r3,r2
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
81146460:	e13fff0f 	ldh	r4,-4(fp)
81146464:	00a045f4 	movhi	r2,33047
81146468:	10b45e04 	addi	r2,r2,-11912
8114646c:	200891ba 	slli	r4,r4,6
81146470:	1105883a 	add	r2,r2,r4
81146474:	10800a04 	addi	r2,r2,40
81146478:	10800017 	ldw	r2,0(r2)
8114647c:	113fff84 	addi	r4,r2,-2
81146480:	00a045f4 	movhi	r2,33047
81146484:	10b44904 	addi	r2,r2,-11996
81146488:	10800383 	ldbu	r2,14(r2)
8114648c:	10803fcc 	andi	r2,r2,255
81146490:	2085383a 	mul	r2,r4,r2
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
81146494:	1885883a 	add	r2,r3,r2
81146498:	e0bffe15 	stw	r2,-8(fp)
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
				}
				if (Read_Sector_Data(record_sector, fat_partition_offset_in_512_byte_sectors))
8114649c:	e0bffe17 	ldw	r2,-8(fp)
811464a0:	d0e0b117 	ldw	r3,-32060(gp)
811464a4:	180b883a 	mov	r5,r3
811464a8:	1009883a 	mov	r4,r2
811464ac:	11422800 	call	81142280 <Read_Sector_Data>
811464b0:	10001426 	beq	r2,zero,81146504 <alt_up_sd_card_fclose+0x188>
				{
					if (Write_File_Record_At_Offset(active_files[file_handle].file_record_offset, &(active_files[file_handle])))
811464b4:	e0ffff0f 	ldh	r3,-4(fp)
811464b8:	00a045f4 	movhi	r2,33047
811464bc:	10b45e04 	addi	r2,r2,-11912
811464c0:	180691ba 	slli	r3,r3,6
811464c4:	10c5883a 	add	r2,r2,r3
811464c8:	10800c04 	addi	r2,r2,48
811464cc:	1080000b 	ldhu	r2,0(r2)
811464d0:	113fffcc 	andi	r4,r2,65535
811464d4:	2120001c 	xori	r4,r4,32768
811464d8:	21200004 	addi	r4,r4,-32768
811464dc:	e0bfff0f 	ldh	r2,-4(fp)
811464e0:	100691ba 	slli	r3,r2,6
811464e4:	00a045f4 	movhi	r2,33047
811464e8:	10b45e04 	addi	r2,r2,-11912
811464ec:	1885883a 	add	r2,r3,r2
811464f0:	100b883a 	mov	r5,r2
811464f4:	11429340 	call	81142934 <Write_File_Record_At_Offset>
811464f8:	10000226 	beq	r2,zero,81146504 <alt_up_sd_card_fclose+0x188>
					{
						// Make sure that the Data has been saved to the SD Card.
						result = Save_Modified_Sector();
811464fc:	114222c0 	call	8114222c <Save_Modified_Sector>
81146500:	e0bffd15 	stw	r2,-12(fp)
					}
				}
			}
			active_files[file_handle].in_use = false;
81146504:	e0ffff0f 	ldh	r3,-4(fp)
81146508:	00a045f4 	movhi	r2,33047
8114650c:	10b45e04 	addi	r2,r2,-11912
81146510:	180691ba 	slli	r3,r3,6
81146514:	10c5883a 	add	r2,r2,r3
81146518:	10800f04 	addi	r2,r2,60
8114651c:	10000015 	stw	zero,0(r2)
			result = true;
81146520:	00800044 	movi	r2,1
81146524:	e0bffd15 	stw	r2,-12(fp)
        }
    }
    
    return result;
81146528:	e0bffd17 	ldw	r2,-12(fp)
}
8114652c:	e037883a 	mov	sp,fp
81146530:	dfc00117 	ldw	ra,4(sp)
81146534:	df000017 	ldw	fp,0(sp)
81146538:	dec00204 	addi	sp,sp,8
8114653c:	f800283a 	ret

81146540 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
81146540:	defffa04 	addi	sp,sp,-24
81146544:	de00012e 	bgeu	sp,et,8114654c <altera_avalon_jtag_uart_read_fd+0xc>
81146548:	003b68fa 	trap	3
8114654c:	dfc00515 	stw	ra,20(sp)
81146550:	df000415 	stw	fp,16(sp)
81146554:	df000404 	addi	fp,sp,16
81146558:	e13ffd15 	stw	r4,-12(fp)
8114655c:	e17ffe15 	stw	r5,-8(fp)
81146560:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
81146564:	e0bffd17 	ldw	r2,-12(fp)
81146568:	10800017 	ldw	r2,0(r2)
8114656c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
81146570:	e0bffc17 	ldw	r2,-16(fp)
81146574:	10c00a04 	addi	r3,r2,40
81146578:	e0bffd17 	ldw	r2,-12(fp)
8114657c:	10800217 	ldw	r2,8(r2)
81146580:	100f883a 	mov	r7,r2
81146584:	e1bfff17 	ldw	r6,-4(fp)
81146588:	e17ffe17 	ldw	r5,-8(fp)
8114658c:	1809883a 	mov	r4,r3
81146590:	1146dc40 	call	81146dc4 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
81146594:	e037883a 	mov	sp,fp
81146598:	dfc00117 	ldw	ra,4(sp)
8114659c:	df000017 	ldw	fp,0(sp)
811465a0:	dec00204 	addi	sp,sp,8
811465a4:	f800283a 	ret

811465a8 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
811465a8:	defffa04 	addi	sp,sp,-24
811465ac:	de00012e 	bgeu	sp,et,811465b4 <altera_avalon_jtag_uart_write_fd+0xc>
811465b0:	003b68fa 	trap	3
811465b4:	dfc00515 	stw	ra,20(sp)
811465b8:	df000415 	stw	fp,16(sp)
811465bc:	df000404 	addi	fp,sp,16
811465c0:	e13ffd15 	stw	r4,-12(fp)
811465c4:	e17ffe15 	stw	r5,-8(fp)
811465c8:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
811465cc:	e0bffd17 	ldw	r2,-12(fp)
811465d0:	10800017 	ldw	r2,0(r2)
811465d4:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
811465d8:	e0bffc17 	ldw	r2,-16(fp)
811465dc:	10c00a04 	addi	r3,r2,40
811465e0:	e0bffd17 	ldw	r2,-12(fp)
811465e4:	10800217 	ldw	r2,8(r2)
811465e8:	100f883a 	mov	r7,r2
811465ec:	e1bfff17 	ldw	r6,-4(fp)
811465f0:	e17ffe17 	ldw	r5,-8(fp)
811465f4:	1809883a 	mov	r4,r3
811465f8:	11470880 	call	81147088 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
811465fc:	e037883a 	mov	sp,fp
81146600:	dfc00117 	ldw	ra,4(sp)
81146604:	df000017 	ldw	fp,0(sp)
81146608:	dec00204 	addi	sp,sp,8
8114660c:	f800283a 	ret

81146610 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
81146610:	defffc04 	addi	sp,sp,-16
81146614:	de00012e 	bgeu	sp,et,8114661c <altera_avalon_jtag_uart_close_fd+0xc>
81146618:	003b68fa 	trap	3
8114661c:	dfc00315 	stw	ra,12(sp)
81146620:	df000215 	stw	fp,8(sp)
81146624:	df000204 	addi	fp,sp,8
81146628:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
8114662c:	e0bfff17 	ldw	r2,-4(fp)
81146630:	10800017 	ldw	r2,0(r2)
81146634:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
81146638:	e0bffe17 	ldw	r2,-8(fp)
8114663c:	10c00a04 	addi	r3,r2,40
81146640:	e0bfff17 	ldw	r2,-4(fp)
81146644:	10800217 	ldw	r2,8(r2)
81146648:	100b883a 	mov	r5,r2
8114664c:	1809883a 	mov	r4,r3
81146650:	1146c5c0 	call	81146c5c <altera_avalon_jtag_uart_close>
}
81146654:	e037883a 	mov	sp,fp
81146658:	dfc00117 	ldw	ra,4(sp)
8114665c:	df000017 	ldw	fp,0(sp)
81146660:	dec00204 	addi	sp,sp,8
81146664:	f800283a 	ret

81146668 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
81146668:	defffa04 	addi	sp,sp,-24
8114666c:	de00012e 	bgeu	sp,et,81146674 <altera_avalon_jtag_uart_ioctl_fd+0xc>
81146670:	003b68fa 	trap	3
81146674:	dfc00515 	stw	ra,20(sp)
81146678:	df000415 	stw	fp,16(sp)
8114667c:	df000404 	addi	fp,sp,16
81146680:	e13ffd15 	stw	r4,-12(fp)
81146684:	e17ffe15 	stw	r5,-8(fp)
81146688:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
8114668c:	e0bffd17 	ldw	r2,-12(fp)
81146690:	10800017 	ldw	r2,0(r2)
81146694:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
81146698:	e0bffc17 	ldw	r2,-16(fp)
8114669c:	10800a04 	addi	r2,r2,40
811466a0:	e1bfff17 	ldw	r6,-4(fp)
811466a4:	e17ffe17 	ldw	r5,-8(fp)
811466a8:	1009883a 	mov	r4,r2
811466ac:	1146ccc0 	call	81146ccc <altera_avalon_jtag_uart_ioctl>
}
811466b0:	e037883a 	mov	sp,fp
811466b4:	dfc00117 	ldw	ra,4(sp)
811466b8:	df000017 	ldw	fp,0(sp)
811466bc:	dec00204 	addi	sp,sp,8
811466c0:	f800283a 	ret

811466c4 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
811466c4:	deffef04 	addi	sp,sp,-68
811466c8:	de00012e 	bgeu	sp,et,811466d0 <altera_avalon_jtag_uart_init+0xc>
811466cc:	003b68fa 	trap	3
811466d0:	dfc01015 	stw	ra,64(sp)
811466d4:	df000f15 	stw	fp,60(sp)
811466d8:	dc400e15 	stw	r17,56(sp)
811466dc:	dc000d15 	stw	r16,52(sp)
811466e0:	df000f04 	addi	fp,sp,60
811466e4:	e13ff715 	stw	r4,-36(fp)
811466e8:	e17ff815 	stw	r5,-32(fp)
811466ec:	e1bff915 	stw	r6,-28(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
811466f0:	e0bff717 	ldw	r2,-36(fp)
811466f4:	10800c04 	addi	r2,r2,48
811466f8:	e0bff215 	stw	r2,-56(fp)
811466fc:	e03ff60d 	sth	zero,-40(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
81146700:	e0bff60b 	ldhu	r2,-40(fp)
81146704:	e0fff684 	addi	r3,fp,-38
81146708:	180b883a 	mov	r5,r3
8114670c:	1009883a 	mov	r4,r2
81146710:	113a8940 	call	8113a894 <OSFlagCreate>
81146714:	1007883a 	mov	r3,r2
81146718:	e0bff217 	ldw	r2,-56(fp)
8114671c:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->read_lock, 1);
81146720:	e0bff717 	ldw	r2,-36(fp)
81146724:	10800a04 	addi	r2,r2,40
81146728:	e0bff315 	stw	r2,-52(fp)
8114672c:	00800044 	movi	r2,1
81146730:	e0bff58d 	sth	r2,-42(fp)
81146734:	e0bff58b 	ldhu	r2,-42(fp)
81146738:	1009883a 	mov	r4,r2
8114673c:	113e7f00 	call	8113e7f0 <OSSemCreate>
81146740:	1007883a 	mov	r3,r2
81146744:	e0bff317 	ldw	r2,-52(fp)
81146748:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->write_lock, 1);
8114674c:	e0bff717 	ldw	r2,-36(fp)
81146750:	10800b04 	addi	r2,r2,44
81146754:	e0bff415 	stw	r2,-48(fp)
81146758:	00800044 	movi	r2,1
8114675c:	e0bff50d 	sth	r2,-44(fp)
81146760:	e0bff50b 	ldhu	r2,-44(fp)
81146764:	1009883a 	mov	r4,r2
81146768:	113e7f00 	call	8113e7f0 <OSSemCreate>
8114676c:	1007883a 	mov	r3,r2
81146770:	e0bff417 	ldw	r2,-48(fp)
81146774:	10c00015 	stw	r3,0(r2)

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
81146778:	e0bff717 	ldw	r2,-36(fp)
8114677c:	00c00044 	movi	r3,1
81146780:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
81146784:	e0bff717 	ldw	r2,-36(fp)
81146788:	10800017 	ldw	r2,0(r2)
8114678c:	10800104 	addi	r2,r2,4
81146790:	1007883a 	mov	r3,r2
81146794:	e0bff717 	ldw	r2,-36(fp)
81146798:	10800817 	ldw	r2,32(r2)
8114679c:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
811467a0:	e0bff817 	ldw	r2,-32(fp)
811467a4:	e0fff917 	ldw	r3,-28(fp)
811467a8:	d8000015 	stw	zero,0(sp)
811467ac:	e1fff717 	ldw	r7,-36(fp)
811467b0:	01a04534 	movhi	r6,33044
811467b4:	319a2504 	addi	r6,r6,26772
811467b8:	180b883a 	mov	r5,r3
811467bc:	1009883a 	mov	r4,r2
811467c0:	114a5dc0 	call	8114a5dc <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
811467c4:	e0bff717 	ldw	r2,-36(fp)
811467c8:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
811467cc:	e0bff717 	ldw	r2,-36(fp)
811467d0:	10800204 	addi	r2,r2,8
811467d4:	d0e08817 	ldw	r3,-32224(gp)
811467d8:	e1fff717 	ldw	r7,-36(fp)
811467dc:	01a04534 	movhi	r6,33044
811467e0:	319ad404 	addi	r6,r6,27472
811467e4:	180b883a 	mov	r5,r3
811467e8:	1009883a 	mov	r4,r2
811467ec:	114a12c0 	call	8114a12c <alt_alarm_start>
811467f0:	1000040e 	bge	r2,zero,81146804 <altera_avalon_jtag_uart_init+0x140>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
811467f4:	e0fff717 	ldw	r3,-36(fp)
811467f8:	00a00034 	movhi	r2,32768
811467fc:	10bfffc4 	addi	r2,r2,-1
81146800:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
81146804:	d0a08183 	ldbu	r2,-32250(gp)
81146808:	10803fcc 	andi	r2,r2,255
8114680c:	10800058 	cmpnei	r2,r2,1
81146810:	10000f1e 	bne	r2,zero,81146850 <altera_avalon_jtag_uart_init+0x18c>
81146814:	d0e08817 	ldw	r3,-32224(gp)
81146818:	00b33374 	movhi	r2,52429
8114681c:	10b33344 	addi	r2,r2,-13107
81146820:	1888383a 	mulxuu	r4,r3,r2
81146824:	1885383a 	mul	r2,r3,r2
81146828:	1021883a 	mov	r16,r2
8114682c:	2023883a 	mov	r17,r4
81146830:	8804d0fa 	srli	r2,r17,3
81146834:	e1fff717 	ldw	r7,-36(fp)
81146838:	01a044f4 	movhi	r6,33043
8114683c:	319bf104 	addi	r6,r6,28612
81146840:	100b883a 	mov	r5,r2
81146844:	012045b4 	movhi	r4,33046
81146848:	211c1d04 	addi	r4,r4,28788
8114684c:	114a12c0 	call	8114a12c <alt_alarm_start>
81146850:	d0a08203 	ldbu	r2,-32248(gp)
81146854:	10803fcc 	andi	r2,r2,255
81146858:	10800058 	cmpnei	r2,r2,1
8114685c:	1000051e 	bne	r2,zero,81146874 <altera_avalon_jtag_uart_init+0x1b0>
81146860:	e0bff717 	ldw	r2,-36(fp)
81146864:	10800017 	ldw	r2,0(r2)
81146868:	100b883a 	mov	r5,r2
8114686c:	e13ff717 	ldw	r4,-36(fp)
81146870:	113715c0 	call	8113715c <alt_log_jtag_uart_startup_info>
}
81146874:	0001883a 	nop
81146878:	e6fffe04 	addi	sp,fp,-8
8114687c:	dfc00317 	ldw	ra,12(sp)
81146880:	df000217 	ldw	fp,8(sp)
81146884:	dc400117 	ldw	r17,4(sp)
81146888:	dc000017 	ldw	r16,0(sp)
8114688c:	dec00404 	addi	sp,sp,16
81146890:	f800283a 	ret

81146894 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
81146894:	defff204 	addi	sp,sp,-56
81146898:	de00012e 	bgeu	sp,et,811468a0 <altera_avalon_jtag_uart_irq+0xc>
8114689c:	003b68fa 	trap	3
811468a0:	dfc00d15 	stw	ra,52(sp)
811468a4:	df000c15 	stw	fp,48(sp)
811468a8:	df000c04 	addi	fp,sp,48
811468ac:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
811468b0:	e0bfff17 	ldw	r2,-4(fp)
811468b4:	e0bff615 	stw	r2,-40(fp)
  unsigned int base = sp->base;
811468b8:	e0bff617 	ldw	r2,-40(fp)
811468bc:	10800017 	ldw	r2,0(r2)
811468c0:	e0bff715 	stw	r2,-36(fp)

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);
811468c4:	e0bff717 	ldw	r2,-36(fp)
811468c8:	e17ff617 	ldw	r5,-40(fp)
811468cc:	1009883a 	mov	r4,r2
811468d0:	11371b00 	call	811371b0 <alt_log_jtag_uart_isr_proc>

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
811468d4:	e0bff717 	ldw	r2,-36(fp)
811468d8:	10800104 	addi	r2,r2,4
811468dc:	10800037 	ldwio	r2,0(r2)
811468e0:	e0bff815 	stw	r2,-32(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
811468e4:	e0bff817 	ldw	r2,-32(fp)
811468e8:	1080c00c 	andi	r2,r2,768
811468ec:	10009126 	beq	r2,zero,81146b34 <altera_avalon_jtag_uart_irq+0x2a0>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
811468f0:	e0bff817 	ldw	r2,-32(fp)
811468f4:	1080400c 	andi	r2,r2,256
811468f8:	10004726 	beq	r2,zero,81146a18 <altera_avalon_jtag_uart_irq+0x184>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
811468fc:	00800074 	movhi	r2,1
81146900:	e0bff415 	stw	r2,-48(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81146904:	e0bff617 	ldw	r2,-40(fp)
81146908:	10800d17 	ldw	r2,52(r2)
8114690c:	10800044 	addi	r2,r2,1
81146910:	1081ffcc 	andi	r2,r2,2047
81146914:	e0bff915 	stw	r2,-28(fp)
        if (next == sp->rx_out)
81146918:	e0bff617 	ldw	r2,-40(fp)
8114691c:	10c00e17 	ldw	r3,56(r2)
81146920:	e0bff917 	ldw	r2,-28(fp)
81146924:	18802726 	beq	r3,r2,811469c4 <altera_avalon_jtag_uart_irq+0x130>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
81146928:	e0bff717 	ldw	r2,-36(fp)
8114692c:	10800037 	ldwio	r2,0(r2)
81146930:	e0bff415 	stw	r2,-48(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
81146934:	e0bff417 	ldw	r2,-48(fp)
81146938:	10a0000c 	andi	r2,r2,32768
8114693c:	10002326 	beq	r2,zero,811469cc <altera_avalon_jtag_uart_irq+0x138>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
81146940:	e0bff617 	ldw	r2,-40(fp)
81146944:	10800d17 	ldw	r2,52(r2)
81146948:	e0fff417 	ldw	r3,-48(fp)
8114694c:	1809883a 	mov	r4,r3
81146950:	e0fff617 	ldw	r3,-40(fp)
81146954:	1885883a 	add	r2,r3,r2
81146958:	10801104 	addi	r2,r2,68
8114695c:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81146960:	e0bff617 	ldw	r2,-40(fp)
81146964:	10800d17 	ldw	r2,52(r2)
81146968:	10800044 	addi	r2,r2,1
8114696c:	10c1ffcc 	andi	r3,r2,2047
81146970:	e0bff617 	ldw	r2,-40(fp)
81146974:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
81146978:	e0bff617 	ldw	r2,-40(fp)
8114697c:	10800c17 	ldw	r2,48(r2)
81146980:	e0bffb15 	stw	r2,-20(fp)
81146984:	00800044 	movi	r2,1
81146988:	e0bffc0d 	sth	r2,-16(fp)
8114698c:	00800044 	movi	r2,1
81146990:	e0bffc85 	stb	r2,-14(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81146994:	d0a09103 	ldbu	r2,-32188(gp)
81146998:	10803fcc 	andi	r2,r2,255
8114699c:	103fd926 	beq	r2,zero,81146904 <__reset+0xfb126904>
  {
    OSFlagPost (group, flags, opt, &err);
811469a0:	e0bffc0b 	ldhu	r2,-16(fp)
811469a4:	e0fffc83 	ldbu	r3,-14(fp)
811469a8:	e13ffdc4 	addi	r4,fp,-9
811469ac:	200f883a 	mov	r7,r4
811469b0:	180d883a 	mov	r6,r3
811469b4:	100b883a 	mov	r5,r2
811469b8:	e13ffb17 	ldw	r4,-20(fp)
811469bc:	113b4a00 	call	8113b4a0 <OSFlagPost>
      }
811469c0:	003fd006 	br	81146904 <__reset+0xfb126904>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
811469c4:	0001883a 	nop
811469c8:	00000106 	br	811469d0 <altera_avalon_jtag_uart_irq+0x13c>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
811469cc:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
811469d0:	e0bff417 	ldw	r2,-48(fp)
811469d4:	10bfffec 	andhi	r2,r2,65535
811469d8:	10000f26 	beq	r2,zero,81146a18 <altera_avalon_jtag_uart_irq+0x184>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
811469dc:	e0bff617 	ldw	r2,-40(fp)
811469e0:	10c00817 	ldw	r3,32(r2)
811469e4:	00bfff84 	movi	r2,-2
811469e8:	1886703a 	and	r3,r3,r2
811469ec:	e0bff617 	ldw	r2,-40(fp)
811469f0:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
811469f4:	e0bff717 	ldw	r2,-36(fp)
811469f8:	10800104 	addi	r2,r2,4
811469fc:	1007883a 	mov	r3,r2
81146a00:	e0bff617 	ldw	r2,-40(fp)
81146a04:	10800817 	ldw	r2,32(r2)
81146a08:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
81146a0c:	e0bff717 	ldw	r2,-36(fp)
81146a10:	10800104 	addi	r2,r2,4
81146a14:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
81146a18:	e0bff817 	ldw	r2,-32(fp)
81146a1c:	1080800c 	andi	r2,r2,512
81146a20:	103fac26 	beq	r2,zero,811468d4 <__reset+0xfb1268d4>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
81146a24:	e0bff817 	ldw	r2,-32(fp)
81146a28:	1004d43a 	srli	r2,r2,16
81146a2c:	e0bff515 	stw	r2,-44(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
81146a30:	00002606 	br	81146acc <altera_avalon_jtag_uart_irq+0x238>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
81146a34:	e0bff717 	ldw	r2,-36(fp)
81146a38:	e0fff617 	ldw	r3,-40(fp)
81146a3c:	18c01017 	ldw	r3,64(r3)
81146a40:	e13ff617 	ldw	r4,-40(fp)
81146a44:	20c7883a 	add	r3,r4,r3
81146a48:	18c21104 	addi	r3,r3,2116
81146a4c:	18c00003 	ldbu	r3,0(r3)
81146a50:	18c03fcc 	andi	r3,r3,255
81146a54:	18c0201c 	xori	r3,r3,128
81146a58:	18ffe004 	addi	r3,r3,-128
81146a5c:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81146a60:	e0bff617 	ldw	r2,-40(fp)
81146a64:	10801017 	ldw	r2,64(r2)
81146a68:	10800044 	addi	r2,r2,1
81146a6c:	10c1ffcc 	andi	r3,r2,2047
81146a70:	e0bff617 	ldw	r2,-40(fp)
81146a74:	10c01015 	stw	r3,64(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);
81146a78:	e0bff617 	ldw	r2,-40(fp)
81146a7c:	10800c17 	ldw	r2,48(r2)
81146a80:	e0bffa15 	stw	r2,-24(fp)
81146a84:	00800084 	movi	r2,2
81146a88:	e0bffd0d 	sth	r2,-12(fp)
81146a8c:	00800044 	movi	r2,1
81146a90:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81146a94:	d0a09103 	ldbu	r2,-32188(gp)
81146a98:	10803fcc 	andi	r2,r2,255
81146a9c:	10000826 	beq	r2,zero,81146ac0 <altera_avalon_jtag_uart_irq+0x22c>
  {
    OSFlagPost (group, flags, opt, &err);
81146aa0:	e0bffd0b 	ldhu	r2,-12(fp)
81146aa4:	e0fffd83 	ldbu	r3,-10(fp)
81146aa8:	e13ffe04 	addi	r4,fp,-8
81146aac:	200f883a 	mov	r7,r4
81146ab0:	180d883a 	mov	r6,r3
81146ab4:	100b883a 	mov	r5,r2
81146ab8:	e13ffa17 	ldw	r4,-24(fp)
81146abc:	113b4a00 	call	8113b4a0 <OSFlagPost>

        space--;
81146ac0:	e0bff517 	ldw	r2,-44(fp)
81146ac4:	10bfffc4 	addi	r2,r2,-1
81146ac8:	e0bff515 	stw	r2,-44(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
81146acc:	e0bff517 	ldw	r2,-44(fp)
81146ad0:	10000526 	beq	r2,zero,81146ae8 <altera_avalon_jtag_uart_irq+0x254>
81146ad4:	e0bff617 	ldw	r2,-40(fp)
81146ad8:	10c01017 	ldw	r3,64(r2)
81146adc:	e0bff617 	ldw	r2,-40(fp)
81146ae0:	10800f17 	ldw	r2,60(r2)
81146ae4:	18bfd31e 	bne	r3,r2,81146a34 <__reset+0xfb126a34>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
81146ae8:	e0bff517 	ldw	r2,-44(fp)
81146aec:	103f7926 	beq	r2,zero,811468d4 <__reset+0xfb1268d4>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
81146af0:	e0bff617 	ldw	r2,-40(fp)
81146af4:	10c00817 	ldw	r3,32(r2)
81146af8:	00bfff44 	movi	r2,-3
81146afc:	1886703a 	and	r3,r3,r2
81146b00:	e0bff617 	ldw	r2,-40(fp)
81146b04:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
81146b08:	e0bff617 	ldw	r2,-40(fp)
81146b0c:	10800017 	ldw	r2,0(r2)
81146b10:	10800104 	addi	r2,r2,4
81146b14:	1007883a 	mov	r3,r2
81146b18:	e0bff617 	ldw	r2,-40(fp)
81146b1c:	10800817 	ldw	r2,32(r2)
81146b20:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
81146b24:	e0bff717 	ldw	r2,-36(fp)
81146b28:	10800104 	addi	r2,r2,4
81146b2c:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
81146b30:	003f6806 	br	811468d4 <__reset+0xfb1268d4>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
81146b34:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
81146b38:	0001883a 	nop
81146b3c:	e037883a 	mov	sp,fp
81146b40:	dfc00117 	ldw	ra,4(sp)
81146b44:	df000017 	ldw	fp,0(sp)
81146b48:	dec00204 	addi	sp,sp,8
81146b4c:	f800283a 	ret

81146b50 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
81146b50:	defff904 	addi	sp,sp,-28
81146b54:	de00012e 	bgeu	sp,et,81146b5c <altera_avalon_jtag_uart_timeout+0xc>
81146b58:	003b68fa 	trap	3
81146b5c:	dfc00615 	stw	ra,24(sp)
81146b60:	df000515 	stw	fp,20(sp)
81146b64:	df000504 	addi	fp,sp,20
81146b68:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
81146b6c:	e0bfff17 	ldw	r2,-4(fp)
81146b70:	e0bffb15 	stw	r2,-20(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
81146b74:	e0bffb17 	ldw	r2,-20(fp)
81146b78:	10800017 	ldw	r2,0(r2)
81146b7c:	10800104 	addi	r2,r2,4
81146b80:	10800037 	ldwio	r2,0(r2)
81146b84:	e0bffc15 	stw	r2,-16(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
81146b88:	e0bffc17 	ldw	r2,-16(fp)
81146b8c:	1081000c 	andi	r2,r2,1024
81146b90:	10000b26 	beq	r2,zero,81146bc0 <altera_avalon_jtag_uart_timeout+0x70>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
81146b94:	e0bffb17 	ldw	r2,-20(fp)
81146b98:	10800017 	ldw	r2,0(r2)
81146b9c:	10800104 	addi	r2,r2,4
81146ba0:	1007883a 	mov	r3,r2
81146ba4:	e0bffb17 	ldw	r2,-20(fp)
81146ba8:	10800817 	ldw	r2,32(r2)
81146bac:	10810014 	ori	r2,r2,1024
81146bb0:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
81146bb4:	e0bffb17 	ldw	r2,-20(fp)
81146bb8:	10000915 	stw	zero,36(r2)
81146bbc:	00002106 	br	81146c44 <altera_avalon_jtag_uart_timeout+0xf4>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
81146bc0:	e0bffb17 	ldw	r2,-20(fp)
81146bc4:	10c00917 	ldw	r3,36(r2)
81146bc8:	00a00034 	movhi	r2,32768
81146bcc:	10bfff04 	addi	r2,r2,-4
81146bd0:	10c01c36 	bltu	r2,r3,81146c44 <altera_avalon_jtag_uart_timeout+0xf4>
    sp->host_inactive++;
81146bd4:	e0bffb17 	ldw	r2,-20(fp)
81146bd8:	10800917 	ldw	r2,36(r2)
81146bdc:	10c00044 	addi	r3,r2,1
81146be0:	e0bffb17 	ldw	r2,-20(fp)
81146be4:	10c00915 	stw	r3,36(r2)
    
    if (sp->host_inactive >= sp->timeout) {
81146be8:	e0bffb17 	ldw	r2,-20(fp)
81146bec:	10c00917 	ldw	r3,36(r2)
81146bf0:	e0bffb17 	ldw	r2,-20(fp)
81146bf4:	10800117 	ldw	r2,4(r2)
81146bf8:	18801236 	bltu	r3,r2,81146c44 <altera_avalon_jtag_uart_timeout+0xf4>
      /* Post an event to indicate host is inactive (for jtag_uart_read */
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
81146bfc:	e0bffb17 	ldw	r2,-20(fp)
81146c00:	10800c17 	ldw	r2,48(r2)
81146c04:	e0bffd15 	stw	r2,-12(fp)
81146c08:	00800104 	movi	r2,4
81146c0c:	e0bffe0d 	sth	r2,-8(fp)
81146c10:	00800044 	movi	r2,1
81146c14:	e0bffe85 	stb	r2,-6(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81146c18:	d0a09103 	ldbu	r2,-32188(gp)
81146c1c:	10803fcc 	andi	r2,r2,255
81146c20:	10000826 	beq	r2,zero,81146c44 <altera_avalon_jtag_uart_timeout+0xf4>
  {
    OSFlagPost (group, flags, opt, &err);
81146c24:	e0bffe0b 	ldhu	r2,-8(fp)
81146c28:	e0fffe83 	ldbu	r3,-6(fp)
81146c2c:	e13ffec4 	addi	r4,fp,-5
81146c30:	200f883a 	mov	r7,r4
81146c34:	180d883a 	mov	r6,r3
81146c38:	100b883a 	mov	r5,r2
81146c3c:	e13ffd17 	ldw	r4,-12(fp)
81146c40:	113b4a00 	call	8113b4a0 <OSFlagPost>
81146c44:	d0a08817 	ldw	r2,-32224(gp)
    }
  }

  return alt_ticks_per_second();
}
81146c48:	e037883a 	mov	sp,fp
81146c4c:	dfc00117 	ldw	ra,4(sp)
81146c50:	df000017 	ldw	fp,0(sp)
81146c54:	dec00204 	addi	sp,sp,8
81146c58:	f800283a 	ret

81146c5c <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
81146c5c:	defffd04 	addi	sp,sp,-12
81146c60:	de00012e 	bgeu	sp,et,81146c68 <altera_avalon_jtag_uart_close+0xc>
81146c64:	003b68fa 	trap	3
81146c68:	df000215 	stw	fp,8(sp)
81146c6c:	df000204 	addi	fp,sp,8
81146c70:	e13ffe15 	stw	r4,-8(fp)
81146c74:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
81146c78:	00000506 	br	81146c90 <altera_avalon_jtag_uart_close+0x34>
    if (flags & O_NONBLOCK) {
81146c7c:	e0bfff17 	ldw	r2,-4(fp)
81146c80:	1090000c 	andi	r2,r2,16384
81146c84:	10000226 	beq	r2,zero,81146c90 <altera_avalon_jtag_uart_close+0x34>
      return -EWOULDBLOCK; 
81146c88:	00bffd44 	movi	r2,-11
81146c8c:	00000b06 	br	81146cbc <altera_avalon_jtag_uart_close+0x60>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
81146c90:	e0bffe17 	ldw	r2,-8(fp)
81146c94:	10c01017 	ldw	r3,64(r2)
81146c98:	e0bffe17 	ldw	r2,-8(fp)
81146c9c:	10800f17 	ldw	r2,60(r2)
81146ca0:	18800526 	beq	r3,r2,81146cb8 <altera_avalon_jtag_uart_close+0x5c>
81146ca4:	e0bffe17 	ldw	r2,-8(fp)
81146ca8:	10c00917 	ldw	r3,36(r2)
81146cac:	e0bffe17 	ldw	r2,-8(fp)
81146cb0:	10800117 	ldw	r2,4(r2)
81146cb4:	18bff136 	bltu	r3,r2,81146c7c <__reset+0xfb126c7c>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
81146cb8:	0005883a 	mov	r2,zero
}
81146cbc:	e037883a 	mov	sp,fp
81146cc0:	df000017 	ldw	fp,0(sp)
81146cc4:	dec00104 	addi	sp,sp,4
81146cc8:	f800283a 	ret

81146ccc <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
81146ccc:	defffa04 	addi	sp,sp,-24
81146cd0:	de00012e 	bgeu	sp,et,81146cd8 <altera_avalon_jtag_uart_ioctl+0xc>
81146cd4:	003b68fa 	trap	3
81146cd8:	df000515 	stw	fp,20(sp)
81146cdc:	df000504 	addi	fp,sp,20
81146ce0:	e13ffd15 	stw	r4,-12(fp)
81146ce4:	e17ffe15 	stw	r5,-8(fp)
81146ce8:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
81146cec:	00bff9c4 	movi	r2,-25
81146cf0:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
81146cf4:	e0bffe17 	ldw	r2,-8(fp)
81146cf8:	10da8060 	cmpeqi	r3,r2,27137
81146cfc:	1800031e 	bne	r3,zero,81146d0c <altera_avalon_jtag_uart_ioctl+0x40>
81146d00:	109a80a0 	cmpeqi	r2,r2,27138
81146d04:	1000181e 	bne	r2,zero,81146d68 <altera_avalon_jtag_uart_ioctl+0x9c>
      rc = 0;
    }
    break;

  default:
    break;
81146d08:	00002906 	br	81146db0 <altera_avalon_jtag_uart_ioctl+0xe4>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
81146d0c:	e0bffd17 	ldw	r2,-12(fp)
81146d10:	10c00117 	ldw	r3,4(r2)
81146d14:	00a00034 	movhi	r2,32768
81146d18:	10bfffc4 	addi	r2,r2,-1
81146d1c:	18802126 	beq	r3,r2,81146da4 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
81146d20:	e0bfff17 	ldw	r2,-4(fp)
81146d24:	10800017 	ldw	r2,0(r2)
81146d28:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
81146d2c:	e0bffc17 	ldw	r2,-16(fp)
81146d30:	10800090 	cmplti	r2,r2,2
81146d34:	1000061e 	bne	r2,zero,81146d50 <altera_avalon_jtag_uart_ioctl+0x84>
81146d38:	e0fffc17 	ldw	r3,-16(fp)
81146d3c:	00a00034 	movhi	r2,32768
81146d40:	10bfffc4 	addi	r2,r2,-1
81146d44:	18800226 	beq	r3,r2,81146d50 <altera_avalon_jtag_uart_ioctl+0x84>
81146d48:	e0bffc17 	ldw	r2,-16(fp)
81146d4c:	00000206 	br	81146d58 <altera_avalon_jtag_uart_ioctl+0x8c>
81146d50:	00a00034 	movhi	r2,32768
81146d54:	10bfff84 	addi	r2,r2,-2
81146d58:	e0fffd17 	ldw	r3,-12(fp)
81146d5c:	18800115 	stw	r2,4(r3)
      rc = 0;
81146d60:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
81146d64:	00000f06 	br	81146da4 <altera_avalon_jtag_uart_ioctl+0xd8>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
81146d68:	e0bffd17 	ldw	r2,-12(fp)
81146d6c:	10c00117 	ldw	r3,4(r2)
81146d70:	00a00034 	movhi	r2,32768
81146d74:	10bfffc4 	addi	r2,r2,-1
81146d78:	18800c26 	beq	r3,r2,81146dac <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
81146d7c:	e0bffd17 	ldw	r2,-12(fp)
81146d80:	10c00917 	ldw	r3,36(r2)
81146d84:	e0bffd17 	ldw	r2,-12(fp)
81146d88:	10800117 	ldw	r2,4(r2)
81146d8c:	1885803a 	cmpltu	r2,r3,r2
81146d90:	10c03fcc 	andi	r3,r2,255
81146d94:	e0bfff17 	ldw	r2,-4(fp)
81146d98:	10c00015 	stw	r3,0(r2)
      rc = 0;
81146d9c:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
81146da0:	00000206 	br	81146dac <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
81146da4:	0001883a 	nop
81146da8:	00000106 	br	81146db0 <altera_avalon_jtag_uart_ioctl+0xe4>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
81146dac:	0001883a 	nop

  default:
    break;
  }

  return rc;
81146db0:	e0bffb17 	ldw	r2,-20(fp)
}
81146db4:	e037883a 	mov	sp,fp
81146db8:	df000017 	ldw	fp,0(sp)
81146dbc:	dec00104 	addi	sp,sp,4
81146dc0:	f800283a 	ret

81146dc4 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
81146dc4:	deffed04 	addi	sp,sp,-76
81146dc8:	de00012e 	bgeu	sp,et,81146dd0 <altera_avalon_jtag_uart_read+0xc>
81146dcc:	003b68fa 	trap	3
81146dd0:	dfc01215 	stw	ra,72(sp)
81146dd4:	df001115 	stw	fp,68(sp)
81146dd8:	df001104 	addi	fp,sp,68
81146ddc:	e13ffc15 	stw	r4,-16(fp)
81146de0:	e17ffd15 	stw	r5,-12(fp)
81146de4:	e1bffe15 	stw	r6,-8(fp)
81146de8:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
81146dec:	e0bffd17 	ldw	r2,-12(fp)
81146df0:	e0bff015 	stw	r2,-64(fp)

  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);
81146df4:	e0bffc17 	ldw	r2,-16(fp)
81146df8:	10800a17 	ldw	r2,40(r2)
81146dfc:	e0bff815 	stw	r2,-32(fp)
81146e00:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
81146e04:	e0bff90b 	ldhu	r2,-28(fp)
81146e08:	e0fffb04 	addi	r3,fp,-20
81146e0c:	180d883a 	mov	r6,r3
81146e10:	100b883a 	mov	r5,r2
81146e14:	e13ff817 	ldw	r4,-32(fp)
81146e18:	113eb180 	call	8113eb18 <OSSemPend>

  while (space > 0)
81146e1c:	00006106 	br	81146fa4 <altera_avalon_jtag_uart_read+0x1e0>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
81146e20:	e0bffc17 	ldw	r2,-16(fp)
81146e24:	10800d17 	ldw	r2,52(r2)
81146e28:	e0bff315 	stw	r2,-52(fp)
      out = sp->rx_out;
81146e2c:	e0bffc17 	ldw	r2,-16(fp)
81146e30:	10800e17 	ldw	r2,56(r2)
81146e34:	e0bff415 	stw	r2,-48(fp)

      if (in >= out)
81146e38:	e0fff317 	ldw	r3,-52(fp)
81146e3c:	e0bff417 	ldw	r2,-48(fp)
81146e40:	18800536 	bltu	r3,r2,81146e58 <altera_avalon_jtag_uart_read+0x94>
        n = in - out;
81146e44:	e0fff317 	ldw	r3,-52(fp)
81146e48:	e0bff417 	ldw	r2,-48(fp)
81146e4c:	1885c83a 	sub	r2,r3,r2
81146e50:	e0bff115 	stw	r2,-60(fp)
81146e54:	00000406 	br	81146e68 <altera_avalon_jtag_uart_read+0xa4>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
81146e58:	00c20004 	movi	r3,2048
81146e5c:	e0bff417 	ldw	r2,-48(fp)
81146e60:	1885c83a 	sub	r2,r3,r2
81146e64:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
81146e68:	e0bff117 	ldw	r2,-60(fp)
81146e6c:	10001e26 	beq	r2,zero,81146ee8 <altera_avalon_jtag_uart_read+0x124>
        break; /* No more data available */

      if (n > space)
81146e70:	e0fffe17 	ldw	r3,-8(fp)
81146e74:	e0bff117 	ldw	r2,-60(fp)
81146e78:	1880022e 	bgeu	r3,r2,81146e84 <altera_avalon_jtag_uart_read+0xc0>
        n = space;
81146e7c:	e0bffe17 	ldw	r2,-8(fp)
81146e80:	e0bff115 	stw	r2,-60(fp)

      memcpy(ptr, sp->rx_buf + out, n);
81146e84:	e0bffc17 	ldw	r2,-16(fp)
81146e88:	10c01104 	addi	r3,r2,68
81146e8c:	e0bff417 	ldw	r2,-48(fp)
81146e90:	1885883a 	add	r2,r3,r2
81146e94:	e1bff117 	ldw	r6,-60(fp)
81146e98:	100b883a 	mov	r5,r2
81146e9c:	e13ff017 	ldw	r4,-64(fp)
81146ea0:	11226900 	call	81122690 <memcpy>
      ptr   += n;
81146ea4:	e0fff017 	ldw	r3,-64(fp)
81146ea8:	e0bff117 	ldw	r2,-60(fp)
81146eac:	1885883a 	add	r2,r3,r2
81146eb0:	e0bff015 	stw	r2,-64(fp)
      space -= n;
81146eb4:	e0fffe17 	ldw	r3,-8(fp)
81146eb8:	e0bff117 	ldw	r2,-60(fp)
81146ebc:	1885c83a 	sub	r2,r3,r2
81146ec0:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81146ec4:	e0fff417 	ldw	r3,-48(fp)
81146ec8:	e0bff117 	ldw	r2,-60(fp)
81146ecc:	1885883a 	add	r2,r3,r2
81146ed0:	10c1ffcc 	andi	r3,r2,2047
81146ed4:	e0bffc17 	ldw	r2,-16(fp)
81146ed8:	10c00e15 	stw	r3,56(r2)
    }
    while (space > 0);
81146edc:	e0bffe17 	ldw	r2,-8(fp)
81146ee0:	00bfcf16 	blt	zero,r2,81146e20 <__reset+0xfb126e20>
81146ee4:	00000106 	br	81146eec <altera_avalon_jtag_uart_read+0x128>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
81146ee8:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
81146eec:	e0fff017 	ldw	r3,-64(fp)
81146ef0:	e0bffd17 	ldw	r2,-12(fp)
81146ef4:	18802e1e 	bne	r3,r2,81146fb0 <altera_avalon_jtag_uart_read+0x1ec>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
81146ef8:	e0bfff17 	ldw	r2,-4(fp)
81146efc:	1090000c 	andi	r2,r2,16384
81146f00:	10002d1e 	bne	r2,zero,81146fb8 <altera_avalon_jtag_uart_read+0x1f4>
      break;

#ifdef __ucosii__
    /* OS Present: Pend on a flag if the OS is running, otherwise spin */
    if(OSRunning == OS_TRUE) {
81146f04:	d0a09103 	ldbu	r2,-32188(gp)
81146f08:	10803fcc 	andi	r2,r2,255
81146f0c:	10800058 	cmpnei	r2,r2,1
81146f10:	1000161e 	bne	r2,zero,81146f6c <altera_avalon_jtag_uart_read+0x1a8>
       * When running in a multi-threaded mode, we pend on the read event
       * flag set and timeout event flag set in the isr. This avoids wasting CPU
       * cycles waiting in this thread, when we could be doing something more
       * profitable elsewhere.
       */
      ALT_FLAG_PEND (sp->events,
81146f14:	e0bffc17 	ldw	r2,-16(fp)
81146f18:	10800c17 	ldw	r2,48(r2)
81146f1c:	e0bff215 	stw	r2,-56(fp)
81146f20:	00800144 	movi	r2,5
81146f24:	e0bff98d 	sth	r2,-26(fp)
81146f28:	00bfe0c4 	movi	r2,-125
81146f2c:	e0bffa05 	stb	r2,-24(fp)
81146f30:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81146f34:	d0a09103 	ldbu	r2,-32188(gp)
81146f38:	10803fcc 	andi	r2,r2,255
81146f3c:	10001526 	beq	r2,zero,81146f94 <altera_avalon_jtag_uart_read+0x1d0>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81146f40:	e0fff98b 	ldhu	r3,-26(fp)
81146f44:	e13ffa03 	ldbu	r4,-24(fp)
81146f48:	e17ffa8b 	ldhu	r5,-22(fp)
81146f4c:	e0bffb44 	addi	r2,fp,-19
81146f50:	d8800015 	stw	r2,0(sp)
81146f54:	280f883a 	mov	r7,r5
81146f58:	200d883a 	mov	r6,r4
81146f5c:	180b883a 	mov	r5,r3
81146f60:	e13ff217 	ldw	r4,-56(fp)
81146f64:	113ae780 	call	8113ae78 <OSFlagPend>
81146f68:	00000a06 	br	81146f94 <altera_avalon_jtag_uart_read+0x1d0>
                     OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                     0);
    }
    else {
      /* Spin until more data arrives or until host disconnects */
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
81146f6c:	0001883a 	nop
81146f70:	e0bffc17 	ldw	r2,-16(fp)
81146f74:	10c00d17 	ldw	r3,52(r2)
81146f78:	e0bff317 	ldw	r2,-52(fp)
81146f7c:	1880051e 	bne	r3,r2,81146f94 <altera_avalon_jtag_uart_read+0x1d0>
81146f80:	e0bffc17 	ldw	r2,-16(fp)
81146f84:	10c00917 	ldw	r3,36(r2)
81146f88:	e0bffc17 	ldw	r2,-16(fp)
81146f8c:	10800117 	ldw	r2,4(r2)
81146f90:	18bff736 	bltu	r3,r2,81146f70 <__reset+0xfb126f70>
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
81146f94:	e0bffc17 	ldw	r2,-16(fp)
81146f98:	10c00d17 	ldw	r3,52(r2)
81146f9c:	e0bff317 	ldw	r2,-52(fp)
81146fa0:	18800726 	beq	r3,r2,81146fc0 <altera_avalon_jtag_uart_read+0x1fc>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
81146fa4:	e0bffe17 	ldw	r2,-8(fp)
81146fa8:	00bf9d16 	blt	zero,r2,81146e20 <__reset+0xfb126e20>
81146fac:	00000506 	br	81146fc4 <altera_avalon_jtag_uart_read+0x200>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
81146fb0:	0001883a 	nop
81146fb4:	00000306 	br	81146fc4 <altera_avalon_jtag_uart_read+0x200>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
81146fb8:	0001883a 	nop
81146fbc:	00000106 	br	81146fc4 <altera_avalon_jtag_uart_read+0x200>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
81146fc0:	0001883a 	nop
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
81146fc4:	e0bffc17 	ldw	r2,-16(fp)
81146fc8:	10800a17 	ldw	r2,40(r2)
81146fcc:	1009883a 	mov	r4,r2
81146fd0:	113eea00 	call	8113eea0 <OSSemPost>

  if (ptr != buffer)
81146fd4:	e0fff017 	ldw	r3,-64(fp)
81146fd8:	e0bffd17 	ldw	r2,-12(fp)
81146fdc:	18801826 	beq	r3,r2,81147040 <altera_avalon_jtag_uart_read+0x27c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81146fe0:	0005303a 	rdctl	r2,status
81146fe4:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81146fe8:	e0fff717 	ldw	r3,-36(fp)
81146fec:	00bfff84 	movi	r2,-2
81146ff0:	1884703a 	and	r2,r3,r2
81146ff4:	1001703a 	wrctl	status,r2
  
  return context;
81146ff8:	e0bff717 	ldw	r2,-36(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
81146ffc:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
81147000:	e0bffc17 	ldw	r2,-16(fp)
81147004:	10800817 	ldw	r2,32(r2)
81147008:	10c00054 	ori	r3,r2,1
8114700c:	e0bffc17 	ldw	r2,-16(fp)
81147010:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
81147014:	e0bffc17 	ldw	r2,-16(fp)
81147018:	10800017 	ldw	r2,0(r2)
8114701c:	10800104 	addi	r2,r2,4
81147020:	1007883a 	mov	r3,r2
81147024:	e0bffc17 	ldw	r2,-16(fp)
81147028:	10800817 	ldw	r2,32(r2)
8114702c:	18800035 	stwio	r2,0(r3)
81147030:	e0bff617 	ldw	r2,-40(fp)
81147034:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81147038:	e0bff517 	ldw	r2,-44(fp)
8114703c:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
81147040:	e0fff017 	ldw	r3,-64(fp)
81147044:	e0bffd17 	ldw	r2,-12(fp)
81147048:	18800426 	beq	r3,r2,8114705c <altera_avalon_jtag_uart_read+0x298>
    return ptr - buffer;
8114704c:	e0fff017 	ldw	r3,-64(fp)
81147050:	e0bffd17 	ldw	r2,-12(fp)
81147054:	1885c83a 	sub	r2,r3,r2
81147058:	00000606 	br	81147074 <altera_avalon_jtag_uart_read+0x2b0>
  else if (flags & O_NONBLOCK)
8114705c:	e0bfff17 	ldw	r2,-4(fp)
81147060:	1090000c 	andi	r2,r2,16384
81147064:	10000226 	beq	r2,zero,81147070 <altera_avalon_jtag_uart_read+0x2ac>
    return -EWOULDBLOCK;
81147068:	00bffd44 	movi	r2,-11
8114706c:	00000106 	br	81147074 <altera_avalon_jtag_uart_read+0x2b0>
  else
    return -EIO;
81147070:	00bffec4 	movi	r2,-5
}
81147074:	e037883a 	mov	sp,fp
81147078:	dfc00117 	ldw	ra,4(sp)
8114707c:	df000017 	ldw	fp,0(sp)
81147080:	dec00204 	addi	sp,sp,8
81147084:	f800283a 	ret

81147088 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
81147088:	deffed04 	addi	sp,sp,-76
8114708c:	de00012e 	bgeu	sp,et,81147094 <altera_avalon_jtag_uart_write+0xc>
81147090:	003b68fa 	trap	3
81147094:	dfc01215 	stw	ra,72(sp)
81147098:	df001115 	stw	fp,68(sp)
8114709c:	df001104 	addi	fp,sp,68
811470a0:	e13ffc15 	stw	r4,-16(fp)
811470a4:	e17ffd15 	stw	r5,-12(fp)
811470a8:	e1bffe15 	stw	r6,-8(fp)
811470ac:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
811470b0:	e03ff015 	stw	zero,-64(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
811470b4:	e0bffd17 	ldw	r2,-12(fp)
811470b8:	e0bff215 	stw	r2,-56(fp)

  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */
  ALT_SEM_PEND (sp->write_lock, 0);
811470bc:	e0bffc17 	ldw	r2,-16(fp)
811470c0:	10800b17 	ldw	r2,44(r2)
811470c4:	e0bff815 	stw	r2,-32(fp)
811470c8:	e03ff90d 	sth	zero,-28(fp)
811470cc:	e0bff90b 	ldhu	r2,-28(fp)
811470d0:	e0fffb44 	addi	r3,fp,-19
811470d4:	180d883a 	mov	r6,r3
811470d8:	100b883a 	mov	r5,r2
811470dc:	e13ff817 	ldw	r4,-32(fp)
811470e0:	113eb180 	call	8113eb18 <OSSemPend>

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
811470e4:	00003706 	br	811471c4 <altera_avalon_jtag_uart_write+0x13c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
811470e8:	e0bffc17 	ldw	r2,-16(fp)
811470ec:	10800f17 	ldw	r2,60(r2)
811470f0:	e0bff415 	stw	r2,-48(fp)
      out = sp->tx_out;
811470f4:	e0bffc17 	ldw	r2,-16(fp)
811470f8:	10801017 	ldw	r2,64(r2)
811470fc:	e0bff015 	stw	r2,-64(fp)

      if (in < out)
81147100:	e0fff417 	ldw	r3,-48(fp)
81147104:	e0bff017 	ldw	r2,-64(fp)
81147108:	1880062e 	bgeu	r3,r2,81147124 <altera_avalon_jtag_uart_write+0x9c>
        n = out - 1 - in;
8114710c:	e0fff017 	ldw	r3,-64(fp)
81147110:	e0bff417 	ldw	r2,-48(fp)
81147114:	1885c83a 	sub	r2,r3,r2
81147118:	10bfffc4 	addi	r2,r2,-1
8114711c:	e0bff115 	stw	r2,-60(fp)
81147120:	00000b06 	br	81147150 <altera_avalon_jtag_uart_write+0xc8>
      else if (out > 0)
81147124:	e0bff017 	ldw	r2,-64(fp)
81147128:	10000526 	beq	r2,zero,81147140 <altera_avalon_jtag_uart_write+0xb8>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
8114712c:	00c20004 	movi	r3,2048
81147130:	e0bff417 	ldw	r2,-48(fp)
81147134:	1885c83a 	sub	r2,r3,r2
81147138:	e0bff115 	stw	r2,-60(fp)
8114713c:	00000406 	br	81147150 <altera_avalon_jtag_uart_write+0xc8>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
81147140:	00c1ffc4 	movi	r3,2047
81147144:	e0bff417 	ldw	r2,-48(fp)
81147148:	1885c83a 	sub	r2,r3,r2
8114714c:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
81147150:	e0bff117 	ldw	r2,-60(fp)
81147154:	10001e26 	beq	r2,zero,811471d0 <altera_avalon_jtag_uart_write+0x148>
        break;

      if (n > count)
81147158:	e0fffe17 	ldw	r3,-8(fp)
8114715c:	e0bff117 	ldw	r2,-60(fp)
81147160:	1880022e 	bgeu	r3,r2,8114716c <altera_avalon_jtag_uart_write+0xe4>
        n = count;
81147164:	e0bffe17 	ldw	r2,-8(fp)
81147168:	e0bff115 	stw	r2,-60(fp)

      memcpy(sp->tx_buf + in, ptr, n);
8114716c:	e0bffc17 	ldw	r2,-16(fp)
81147170:	10c21104 	addi	r3,r2,2116
81147174:	e0bff417 	ldw	r2,-48(fp)
81147178:	1885883a 	add	r2,r3,r2
8114717c:	e1bff117 	ldw	r6,-60(fp)
81147180:	e17ffd17 	ldw	r5,-12(fp)
81147184:	1009883a 	mov	r4,r2
81147188:	11226900 	call	81122690 <memcpy>
      ptr   += n;
8114718c:	e0fffd17 	ldw	r3,-12(fp)
81147190:	e0bff117 	ldw	r2,-60(fp)
81147194:	1885883a 	add	r2,r3,r2
81147198:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
8114719c:	e0fffe17 	ldw	r3,-8(fp)
811471a0:	e0bff117 	ldw	r2,-60(fp)
811471a4:	1885c83a 	sub	r2,r3,r2
811471a8:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
811471ac:	e0fff417 	ldw	r3,-48(fp)
811471b0:	e0bff117 	ldw	r2,-60(fp)
811471b4:	1885883a 	add	r2,r3,r2
811471b8:	10c1ffcc 	andi	r3,r2,2047
811471bc:	e0bffc17 	ldw	r2,-16(fp)
811471c0:	10c00f15 	stw	r3,60(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
811471c4:	e0bffe17 	ldw	r2,-8(fp)
811471c8:	00bfc716 	blt	zero,r2,811470e8 <__reset+0xfb1270e8>
811471cc:	00000106 	br	811471d4 <altera_avalon_jtag_uart_write+0x14c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
811471d0:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811471d4:	0005303a 	rdctl	r2,status
811471d8:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811471dc:	e0fff717 	ldw	r3,-36(fp)
811471e0:	00bfff84 	movi	r2,-2
811471e4:	1884703a 	and	r2,r3,r2
811471e8:	1001703a 	wrctl	status,r2
  
  return context;
811471ec:	e0bff717 	ldw	r2,-36(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
811471f0:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
811471f4:	e0bffc17 	ldw	r2,-16(fp)
811471f8:	10800817 	ldw	r2,32(r2)
811471fc:	10c00094 	ori	r3,r2,2
81147200:	e0bffc17 	ldw	r2,-16(fp)
81147204:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
81147208:	e0bffc17 	ldw	r2,-16(fp)
8114720c:	10800017 	ldw	r2,0(r2)
81147210:	10800104 	addi	r2,r2,4
81147214:	1007883a 	mov	r3,r2
81147218:	e0bffc17 	ldw	r2,-16(fp)
8114721c:	10800817 	ldw	r2,32(r2)
81147220:	18800035 	stwio	r2,0(r3)
81147224:	e0bff617 	ldw	r2,-40(fp)
81147228:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114722c:	e0bff317 	ldw	r2,-52(fp)
81147230:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
81147234:	e0bffe17 	ldw	r2,-8(fp)
81147238:	00802a0e 	bge	zero,r2,811472e4 <altera_avalon_jtag_uart_write+0x25c>
    {
      if (flags & O_NONBLOCK)
8114723c:	e0bfff17 	ldw	r2,-4(fp)
81147240:	1090000c 	andi	r2,r2,16384
81147244:	10002a1e 	bne	r2,zero,811472f0 <altera_avalon_jtag_uart_write+0x268>
        break;

#ifdef __ucosii__
      /* OS Present: Pend on a flag if the OS is running, otherwise spin */
      if(OSRunning == OS_TRUE) {
81147248:	d0a09103 	ldbu	r2,-32188(gp)
8114724c:	10803fcc 	andi	r2,r2,255
81147250:	10800058 	cmpnei	r2,r2,1
81147254:	1000161e 	bne	r2,zero,811472b0 <altera_avalon_jtag_uart_write+0x228>
         * more profitable elsewhere.
         */
#ifdef ALTERA_AVALON_JTAG_UART_IGNORE_FIFO_FULL_ERROR
        if(!sp->host_inactive)
#endif
        ALT_FLAG_PEND (sp->events,
81147258:	e0bffc17 	ldw	r2,-16(fp)
8114725c:	10800c17 	ldw	r2,48(r2)
81147260:	e0bff515 	stw	r2,-44(fp)
81147264:	00800184 	movi	r2,6
81147268:	e0bff98d 	sth	r2,-26(fp)
8114726c:	00bfe0c4 	movi	r2,-125
81147270:	e0bffa05 	stb	r2,-24(fp)
81147274:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81147278:	d0a09103 	ldbu	r2,-32188(gp)
8114727c:	10803fcc 	andi	r2,r2,255
81147280:	10001526 	beq	r2,zero,811472d8 <altera_avalon_jtag_uart_write+0x250>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81147284:	e0fff98b 	ldhu	r3,-26(fp)
81147288:	e13ffa03 	ldbu	r4,-24(fp)
8114728c:	e17ffa8b 	ldhu	r5,-22(fp)
81147290:	e0bffb04 	addi	r2,fp,-20
81147294:	d8800015 	stw	r2,0(sp)
81147298:	280f883a 	mov	r7,r5
8114729c:	200d883a 	mov	r6,r4
811472a0:	180b883a 	mov	r5,r3
811472a4:	e13ff517 	ldw	r4,-44(fp)
811472a8:	113ae780 	call	8113ae78 <OSFlagPend>
811472ac:	00000a06 	br	811472d8 <altera_avalon_jtag_uart_write+0x250>
        /*
         * OS not running: Wait for data to be removed from buffer.
         * Once the interrupt routine has removed some data then we
         * will be able to insert some more.
         */
        while (out == sp->tx_out && sp->host_inactive < sp->timeout)
811472b0:	0001883a 	nop
811472b4:	e0bffc17 	ldw	r2,-16(fp)
811472b8:	10c01017 	ldw	r3,64(r2)
811472bc:	e0bff017 	ldw	r2,-64(fp)
811472c0:	1880051e 	bne	r3,r2,811472d8 <altera_avalon_jtag_uart_write+0x250>
811472c4:	e0bffc17 	ldw	r2,-16(fp)
811472c8:	10c00917 	ldw	r3,36(r2)
811472cc:	e0bffc17 	ldw	r2,-16(fp)
811472d0:	10800117 	ldw	r2,4(r2)
811472d4:	18bff736 	bltu	r3,r2,811472b4 <__reset+0xfb1272b4>
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
811472d8:	e0bffc17 	ldw	r2,-16(fp)
811472dc:	10800917 	ldw	r2,36(r2)
811472e0:	1000051e 	bne	r2,zero,811472f8 <altera_avalon_jtag_uart_write+0x270>
         break;
    }
  }
  while (count > 0);
811472e4:	e0bffe17 	ldw	r2,-8(fp)
811472e8:	00bfb616 	blt	zero,r2,811471c4 <__reset+0xfb1271c4>
811472ec:	00000306 	br	811472fc <altera_avalon_jtag_uart_write+0x274>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
811472f0:	0001883a 	nop
811472f4:	00000106 	br	811472fc <altera_avalon_jtag_uart_write+0x274>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
811472f8:	0001883a 	nop

  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);
811472fc:	e0bffc17 	ldw	r2,-16(fp)
81147300:	10800b17 	ldw	r2,44(r2)
81147304:	1009883a 	mov	r4,r2
81147308:	113eea00 	call	8113eea0 <OSSemPost>

  if (ptr != start)
8114730c:	e0fffd17 	ldw	r3,-12(fp)
81147310:	e0bff217 	ldw	r2,-56(fp)
81147314:	18800426 	beq	r3,r2,81147328 <altera_avalon_jtag_uart_write+0x2a0>
    return ptr - start;
81147318:	e0fffd17 	ldw	r3,-12(fp)
8114731c:	e0bff217 	ldw	r2,-56(fp)
81147320:	1885c83a 	sub	r2,r3,r2
81147324:	00000606 	br	81147340 <altera_avalon_jtag_uart_write+0x2b8>
  else if (flags & O_NONBLOCK)
81147328:	e0bfff17 	ldw	r2,-4(fp)
8114732c:	1090000c 	andi	r2,r2,16384
81147330:	10000226 	beq	r2,zero,8114733c <altera_avalon_jtag_uart_write+0x2b4>
    return -EWOULDBLOCK;
81147334:	00bffd44 	movi	r2,-11
81147338:	00000106 	br	81147340 <altera_avalon_jtag_uart_write+0x2b8>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
8114733c:	00bffec4 	movi	r2,-5
}
81147340:	e037883a 	mov	sp,fp
81147344:	dfc00117 	ldw	ra,4(sp)
81147348:	df000017 	ldw	fp,0(sp)
8114734c:	dec00204 	addi	sp,sp,8
81147350:	f800283a 	ret

81147354 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
81147354:	defffa04 	addi	sp,sp,-24
81147358:	de00012e 	bgeu	sp,et,81147360 <alt_avalon_timer_sc_irq+0xc>
8114735c:	003b68fa 	trap	3
81147360:	dfc00515 	stw	ra,20(sp)
81147364:	df000415 	stw	fp,16(sp)
81147368:	df000404 	addi	fp,sp,16
8114736c:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
81147370:	0007883a 	mov	r3,zero
81147374:	e0bfff17 	ldw	r2,-4(fp)
81147378:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
8114737c:	e0bfff17 	ldw	r2,-4(fp)
81147380:	10800104 	addi	r2,r2,4
81147384:	10800037 	ldwio	r2,0(r2)

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
  ALT_LOG_SYS_CLK_HEARTBEAT();
81147388:	11373540 	call	81137354 <alt_log_system_clock>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114738c:	0005303a 	rdctl	r2,status
81147390:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81147394:	e0fffd17 	ldw	r3,-12(fp)
81147398:	00bfff84 	movi	r2,-2
8114739c:	1884703a 	and	r2,r3,r2
811473a0:	1001703a 	wrctl	status,r2
  
  return context;
811473a4:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
811473a8:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
811473ac:	1137c040 	call	81137c04 <alt_tick>
811473b0:	e0bffc17 	ldw	r2,-16(fp)
811473b4:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811473b8:	e0bffe17 	ldw	r2,-8(fp)
811473bc:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
811473c0:	0001883a 	nop
811473c4:	e037883a 	mov	sp,fp
811473c8:	dfc00117 	ldw	ra,4(sp)
811473cc:	df000017 	ldw	fp,0(sp)
811473d0:	dec00204 	addi	sp,sp,8
811473d4:	f800283a 	ret

811473d8 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
811473d8:	defff804 	addi	sp,sp,-32
811473dc:	de00012e 	bgeu	sp,et,811473e4 <alt_avalon_timer_sc_init+0xc>
811473e0:	003b68fa 	trap	3
811473e4:	dfc00715 	stw	ra,28(sp)
811473e8:	df000615 	stw	fp,24(sp)
811473ec:	df000604 	addi	fp,sp,24
811473f0:	e13ffc15 	stw	r4,-16(fp)
811473f4:	e17ffd15 	stw	r5,-12(fp)
811473f8:	e1bffe15 	stw	r6,-8(fp)
811473fc:	e1ffff15 	stw	r7,-4(fp)
81147400:	e0bfff17 	ldw	r2,-4(fp)
81147404:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
81147408:	d0a08817 	ldw	r2,-32224(gp)
8114740c:	1000021e 	bne	r2,zero,81147418 <alt_avalon_timer_sc_init+0x40>
  {
    _alt_tick_rate = nticks;
81147410:	e0bffb17 	ldw	r2,-20(fp)
81147414:	d0a08815 	stw	r2,-32224(gp)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
81147418:	e0bffc17 	ldw	r2,-16(fp)
8114741c:	10800104 	addi	r2,r2,4
81147420:	00c001c4 	movi	r3,7
81147424:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
81147428:	d8000015 	stw	zero,0(sp)
8114742c:	e1fffc17 	ldw	r7,-16(fp)
81147430:	01a04534 	movhi	r6,33044
81147434:	319cd504 	addi	r6,r6,29524
81147438:	e17ffe17 	ldw	r5,-8(fp)
8114743c:	e13ffd17 	ldw	r4,-12(fp)
81147440:	114a5dc0 	call	8114a5dc <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
81147444:	0001883a 	nop
81147448:	e037883a 	mov	sp,fp
8114744c:	dfc00117 	ldw	ra,4(sp)
81147450:	df000017 	ldw	fp,0(sp)
81147454:	dec00204 	addi	sp,sp,8
81147458:	f800283a 	ret

8114745c <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
8114745c:	defffa04 	addi	sp,sp,-24
81147460:	de00012e 	bgeu	sp,et,81147468 <altera_avalon_uart_read_fd+0xc>
81147464:	003b68fa 	trap	3
81147468:	dfc00515 	stw	ra,20(sp)
8114746c:	df000415 	stw	fp,16(sp)
81147470:	df000404 	addi	fp,sp,16
81147474:	e13ffd15 	stw	r4,-12(fp)
81147478:	e17ffe15 	stw	r5,-8(fp)
8114747c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
81147480:	e0bffd17 	ldw	r2,-12(fp)
81147484:	10800017 	ldw	r2,0(r2)
81147488:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_read(&dev->state, buffer, space,
8114748c:	e0bffc17 	ldw	r2,-16(fp)
81147490:	10c00a04 	addi	r3,r2,40
81147494:	e0bffd17 	ldw	r2,-12(fp)
81147498:	10800217 	ldw	r2,8(r2)
8114749c:	100f883a 	mov	r7,r2
811474a0:	e1bfff17 	ldw	r6,-4(fp)
811474a4:	e17ffe17 	ldw	r5,-8(fp)
811474a8:	1809883a 	mov	r4,r3
811474ac:	1147b1c0 	call	81147b1c <altera_avalon_uart_read>
      fd->fd_flags);
}
811474b0:	e037883a 	mov	sp,fp
811474b4:	dfc00117 	ldw	ra,4(sp)
811474b8:	df000017 	ldw	fp,0(sp)
811474bc:	dec00204 	addi	sp,sp,8
811474c0:	f800283a 	ret

811474c4 <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
811474c4:	defffa04 	addi	sp,sp,-24
811474c8:	de00012e 	bgeu	sp,et,811474d0 <altera_avalon_uart_write_fd+0xc>
811474cc:	003b68fa 	trap	3
811474d0:	dfc00515 	stw	ra,20(sp)
811474d4:	df000415 	stw	fp,16(sp)
811474d8:	df000404 	addi	fp,sp,16
811474dc:	e13ffd15 	stw	r4,-12(fp)
811474e0:	e17ffe15 	stw	r5,-8(fp)
811474e4:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
811474e8:	e0bffd17 	ldw	r2,-12(fp)
811474ec:	10800017 	ldw	r2,0(r2)
811474f0:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_write(&dev->state, buffer, space,
811474f4:	e0bffc17 	ldw	r2,-16(fp)
811474f8:	10c00a04 	addi	r3,r2,40
811474fc:	e0bffd17 	ldw	r2,-12(fp)
81147500:	10800217 	ldw	r2,8(r2)
81147504:	100f883a 	mov	r7,r2
81147508:	e1bfff17 	ldw	r6,-4(fp)
8114750c:	e17ffe17 	ldw	r5,-8(fp)
81147510:	1809883a 	mov	r4,r3
81147514:	1147dd00 	call	81147dd0 <altera_avalon_uart_write>
      fd->fd_flags);
}
81147518:	e037883a 	mov	sp,fp
8114751c:	dfc00117 	ldw	ra,4(sp)
81147520:	df000017 	ldw	fp,0(sp)
81147524:	dec00204 	addi	sp,sp,8
81147528:	f800283a 	ret

8114752c <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
8114752c:	defffc04 	addi	sp,sp,-16
81147530:	de00012e 	bgeu	sp,et,81147538 <altera_avalon_uart_close_fd+0xc>
81147534:	003b68fa 	trap	3
81147538:	dfc00315 	stw	ra,12(sp)
8114753c:	df000215 	stw	fp,8(sp)
81147540:	df000204 	addi	fp,sp,8
81147544:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
81147548:	e0bfff17 	ldw	r2,-4(fp)
8114754c:	10800017 	ldw	r2,0(r2)
81147550:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
81147554:	e0bffe17 	ldw	r2,-8(fp)
81147558:	10c00a04 	addi	r3,r2,40
8114755c:	e0bfff17 	ldw	r2,-4(fp)
81147560:	10800217 	ldw	r2,8(r2)
81147564:	100b883a 	mov	r5,r2
81147568:	1809883a 	mov	r4,r3
8114756c:	1147a7c0 	call	81147a7c <altera_avalon_uart_close>
}
81147570:	e037883a 	mov	sp,fp
81147574:	dfc00117 	ldw	ra,4(sp)
81147578:	df000017 	ldw	fp,0(sp)
8114757c:	dec00204 	addi	sp,sp,8
81147580:	f800283a 	ret

81147584 <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
81147584:	defff304 	addi	sp,sp,-52
81147588:	de00012e 	bgeu	sp,et,81147590 <altera_avalon_uart_init+0xc>
8114758c:	003b68fa 	trap	3
81147590:	dfc00c15 	stw	ra,48(sp)
81147594:	df000b15 	stw	fp,44(sp)
81147598:	df000b04 	addi	fp,sp,44
8114759c:	e13ffd15 	stw	r4,-12(fp)
811475a0:	e17ffe15 	stw	r5,-8(fp)
811475a4:	e1bfff15 	stw	r6,-4(fp)
  void* base = sp->base;
811475a8:	e0bffd17 	ldw	r2,-12(fp)
811475ac:	10800017 	ldw	r2,0(r2)
811475b0:	e0bff615 	stw	r2,-40(fp)
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
811475b4:	e0bffd17 	ldw	r2,-12(fp)
811475b8:	10800704 	addi	r2,r2,28
811475bc:	e0bffa15 	stw	r2,-24(fp)
811475c0:	e03ffb0d 	sth	zero,-20(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
811475c4:	e0bffb0b 	ldhu	r2,-20(fp)
811475c8:	e0fffc84 	addi	r3,fp,-14
811475cc:	180b883a 	mov	r5,r3
811475d0:	1009883a 	mov	r4,r2
811475d4:	113a8940 	call	8113a894 <OSFlagCreate>
811475d8:	1007883a 	mov	r3,r2
811475dc:	e0bffa17 	ldw	r2,-24(fp)
811475e0:	10c00015 	stw	r3,0(r2)
  return err;
811475e4:	e0bffc83 	ldbu	r2,-14(fp)
811475e8:	10803fcc 	andi	r2,r2,255
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
811475ec:	1000241e 	bne	r2,zero,81147680 <altera_avalon_uart_init+0xfc>
811475f0:	e0bffd17 	ldw	r2,-12(fp)
811475f4:	10800804 	addi	r2,r2,32
811475f8:	e0bff715 	stw	r2,-36(fp)
811475fc:	00800044 	movi	r2,1
81147600:	e0bffb8d 	sth	r2,-18(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
81147604:	e0bffb8b 	ldhu	r2,-18(fp)
81147608:	1009883a 	mov	r4,r2
8114760c:	113e7f00 	call	8113e7f0 <OSSemCreate>
81147610:	1007883a 	mov	r3,r2
81147614:	e0bff717 	ldw	r2,-36(fp)
81147618:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
8114761c:	e0bff717 	ldw	r2,-36(fp)
81147620:	10800017 	ldw	r2,0(r2)
81147624:	10000226 	beq	r2,zero,81147630 <altera_avalon_uart_init+0xac>
81147628:	0005883a 	mov	r2,zero
8114762c:	00000106 	br	81147634 <altera_avalon_uart_init+0xb0>
81147630:	00bfffc4 	movi	r2,-1
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
81147634:	1000121e 	bne	r2,zero,81147680 <altera_avalon_uart_init+0xfc>
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);
81147638:	e0bffd17 	ldw	r2,-12(fp)
8114763c:	10800904 	addi	r2,r2,36
81147640:	e0bff815 	stw	r2,-32(fp)
81147644:	00800044 	movi	r2,1
81147648:	e0bffc0d 	sth	r2,-16(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
8114764c:	e0bffc0b 	ldhu	r2,-16(fp)
81147650:	1009883a 	mov	r4,r2
81147654:	113e7f00 	call	8113e7f0 <OSSemCreate>
81147658:	1007883a 	mov	r3,r2
8114765c:	e0bff817 	ldw	r2,-32(fp)
81147660:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
81147664:	e0bff817 	ldw	r2,-32(fp)
81147668:	10800017 	ldw	r2,0(r2)
8114766c:	10000226 	beq	r2,zero,81147678 <altera_avalon_uart_init+0xf4>
81147670:	0005883a 	mov	r2,zero
81147674:	00000106 	br	8114767c <altera_avalon_uart_init+0xf8>
81147678:	00bfffc4 	movi	r2,-1
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
8114767c:	10000226 	beq	r2,zero,81147688 <altera_avalon_uart_init+0x104>
81147680:	00800044 	movi	r2,1
81147684:	00000106 	br	8114768c <altera_avalon_uart_init+0x108>
81147688:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
8114768c:	e0bff915 	stw	r2,-28(fp)
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
81147690:	e0bff917 	ldw	r2,-28(fp)
81147694:	10000f1e 	bne	r2,zero,811476d4 <altera_avalon_uart_init+0x150>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
81147698:	e0bffd17 	ldw	r2,-12(fp)
8114769c:	00c32004 	movi	r3,3200
811476a0:	10c00115 	stw	r3,4(r2)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
811476a4:	e0bff617 	ldw	r2,-40(fp)
811476a8:	10800304 	addi	r2,r2,12
811476ac:	e0fffd17 	ldw	r3,-12(fp)
811476b0:	18c00117 	ldw	r3,4(r3)
811476b4:	10c00035 	stwio	r3,0(r2)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
811476b8:	d8000015 	stw	zero,0(sp)
811476bc:	e1fffd17 	ldw	r7,-12(fp)
811476c0:	01a04534 	movhi	r6,33044
811476c4:	319dbb04 	addi	r6,r6,30444
811476c8:	e17fff17 	ldw	r5,-4(fp)
811476cc:	e13ffe17 	ldw	r4,-8(fp)
811476d0:	114a5dc0 	call	8114a5dc <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
811476d4:	0001883a 	nop
811476d8:	e037883a 	mov	sp,fp
811476dc:	dfc00117 	ldw	ra,4(sp)
811476e0:	df000017 	ldw	fp,0(sp)
811476e4:	dec00204 	addi	sp,sp,8
811476e8:	f800283a 	ret

811476ec <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
811476ec:	defffa04 	addi	sp,sp,-24
811476f0:	de00012e 	bgeu	sp,et,811476f8 <altera_avalon_uart_irq+0xc>
811476f4:	003b68fa 	trap	3
811476f8:	dfc00515 	stw	ra,20(sp)
811476fc:	df000415 	stw	fp,16(sp)
81147700:	df000404 	addi	fp,sp,16
81147704:	e13fff15 	stw	r4,-4(fp)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
81147708:	e0bfff17 	ldw	r2,-4(fp)
8114770c:	e0bffc15 	stw	r2,-16(fp)
  void* base               = sp->base;
81147710:	e0bffc17 	ldw	r2,-16(fp)
81147714:	10800017 	ldw	r2,0(r2)
81147718:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
8114771c:	e0bffd17 	ldw	r2,-12(fp)
81147720:	10800204 	addi	r2,r2,8
81147724:	10800037 	ldwio	r2,0(r2)
81147728:	e0bffe15 	stw	r2,-8(fp)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
8114772c:	e0bffd17 	ldw	r2,-12(fp)
81147730:	10800204 	addi	r2,r2,8
81147734:	0007883a 	mov	r3,zero
81147738:	10c00035 	stwio	r3,0(r2)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
8114773c:	e0bffd17 	ldw	r2,-12(fp)
81147740:	10800204 	addi	r2,r2,8
81147744:	10800037 	ldwio	r2,0(r2)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
81147748:	e0bffe17 	ldw	r2,-8(fp)
8114774c:	1080200c 	andi	r2,r2,128
81147750:	10000326 	beq	r2,zero,81147760 <altera_avalon_uart_irq+0x74>
  {
    altera_avalon_uart_rxirq(sp, status);
81147754:	e17ffe17 	ldw	r5,-8(fp)
81147758:	e13ffc17 	ldw	r4,-16(fp)
8114775c:	11477900 	call	81147790 <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
81147760:	e0bffe17 	ldw	r2,-8(fp)
81147764:	1081100c 	andi	r2,r2,1088
81147768:	10000326 	beq	r2,zero,81147778 <altera_avalon_uart_irq+0x8c>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
8114776c:	e17ffe17 	ldw	r5,-8(fp)
81147770:	e13ffc17 	ldw	r4,-16(fp)
81147774:	11478d00 	call	811478d0 <altera_avalon_uart_txirq>
  }
  

}
81147778:	0001883a 	nop
8114777c:	e037883a 	mov	sp,fp
81147780:	dfc00117 	ldw	ra,4(sp)
81147784:	df000017 	ldw	fp,0(sp)
81147788:	dec00204 	addi	sp,sp,8
8114778c:	f800283a 	ret

81147790 <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
81147790:	defff904 	addi	sp,sp,-28
81147794:	de00012e 	bgeu	sp,et,8114779c <altera_avalon_uart_rxirq+0xc>
81147798:	003b68fa 	trap	3
8114779c:	dfc00615 	stw	ra,24(sp)
811477a0:	df000515 	stw	fp,20(sp)
811477a4:	df000504 	addi	fp,sp,20
811477a8:	e13ffe15 	stw	r4,-8(fp)
811477ac:	e17fff15 	stw	r5,-4(fp)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
811477b0:	e0bfff17 	ldw	r2,-4(fp)
811477b4:	108000cc 	andi	r2,r2,3
811477b8:	10003f1e 	bne	r2,zero,811478b8 <altera_avalon_uart_rxirq+0x128>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
811477bc:	e0bffe17 	ldw	r2,-8(fp)
811477c0:	10c00317 	ldw	r3,12(r2)
811477c4:	e0bffe17 	ldw	r2,-8(fp)
811477c8:	10800217 	ldw	r2,8(r2)
811477cc:	1880121e 	bne	r3,r2,81147818 <altera_avalon_uart_rxirq+0x88>
  {
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, OS_FLAG_SET);
811477d0:	e0bffe17 	ldw	r2,-8(fp)
811477d4:	10800717 	ldw	r2,28(r2)
811477d8:	e0bffc15 	stw	r2,-16(fp)
811477dc:	00800044 	movi	r2,1
811477e0:	e0bffd0d 	sth	r2,-12(fp)
811477e4:	00800044 	movi	r2,1
811477e8:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
811477ec:	d0a09103 	ldbu	r2,-32188(gp)
811477f0:	10803fcc 	andi	r2,r2,255
811477f4:	10000826 	beq	r2,zero,81147818 <altera_avalon_uart_rxirq+0x88>
  {
    OSFlagPost (group, flags, opt, &err);
811477f8:	e0bffd0b 	ldhu	r2,-12(fp)
811477fc:	e0fffd83 	ldbu	r3,-10(fp)
81147800:	e13ffdc4 	addi	r4,fp,-9
81147804:	200f883a 	mov	r7,r4
81147808:	180d883a 	mov	r6,r3
8114780c:	100b883a 	mov	r5,r2
81147810:	e13ffc17 	ldw	r4,-16(fp)
81147814:	113b4a00 	call	8113b4a0 <OSFlagPost>
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
81147818:	e0bffe17 	ldw	r2,-8(fp)
8114781c:	10800317 	ldw	r2,12(r2)
81147820:	10800044 	addi	r2,r2,1
81147824:	10800fcc 	andi	r2,r2,63
81147828:	e0bffb15 	stw	r2,-20(fp)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
8114782c:	e0bffe17 	ldw	r2,-8(fp)
81147830:	10800317 	ldw	r2,12(r2)
81147834:	e0fffe17 	ldw	r3,-8(fp)
81147838:	18c00017 	ldw	r3,0(r3)
8114783c:	18c00037 	ldwio	r3,0(r3)
81147840:	1809883a 	mov	r4,r3
81147844:	e0fffe17 	ldw	r3,-8(fp)
81147848:	1885883a 	add	r2,r3,r2
8114784c:	10800a04 	addi	r2,r2,40
81147850:	11000005 	stb	r4,0(r2)

  sp->rx_end = next;
81147854:	e0bffe17 	ldw	r2,-8(fp)
81147858:	e0fffb17 	ldw	r3,-20(fp)
8114785c:	10c00315 	stw	r3,12(r2)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
81147860:	e0bffe17 	ldw	r2,-8(fp)
81147864:	10800317 	ldw	r2,12(r2)
81147868:	10800044 	addi	r2,r2,1
8114786c:	10800fcc 	andi	r2,r2,63
81147870:	e0bffb15 	stw	r2,-20(fp)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
81147874:	e0bffe17 	ldw	r2,-8(fp)
81147878:	10c00217 	ldw	r3,8(r2)
8114787c:	e0bffb17 	ldw	r2,-20(fp)
81147880:	18800e1e 	bne	r3,r2,811478bc <altera_avalon_uart_rxirq+0x12c>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
81147884:	e0bffe17 	ldw	r2,-8(fp)
81147888:	10c00117 	ldw	r3,4(r2)
8114788c:	00bfdfc4 	movi	r2,-129
81147890:	1886703a 	and	r3,r3,r2
81147894:	e0bffe17 	ldw	r2,-8(fp)
81147898:	10c00115 	stw	r3,4(r2)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
8114789c:	e0bffe17 	ldw	r2,-8(fp)
811478a0:	10800017 	ldw	r2,0(r2)
811478a4:	10800304 	addi	r2,r2,12
811478a8:	e0fffe17 	ldw	r3,-8(fp)
811478ac:	18c00117 	ldw	r3,4(r3)
811478b0:	10c00035 	stwio	r3,0(r2)
811478b4:	00000106 	br	811478bc <altera_avalon_uart_rxirq+0x12c>
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
                  ALTERA_AVALON_UART_STATUS_FE_MSK))
  {
    return;
811478b8:	0001883a 	nop
  if (next == sp->rx_start)
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
  }   
}
811478bc:	e037883a 	mov	sp,fp
811478c0:	dfc00117 	ldw	ra,4(sp)
811478c4:	df000017 	ldw	fp,0(sp)
811478c8:	dec00204 	addi	sp,sp,8
811478cc:	f800283a 	ret

811478d0 <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
811478d0:	defffa04 	addi	sp,sp,-24
811478d4:	de00012e 	bgeu	sp,et,811478dc <altera_avalon_uart_txirq+0xc>
811478d8:	003b68fa 	trap	3
811478dc:	dfc00515 	stw	ra,20(sp)
811478e0:	df000415 	stw	fp,16(sp)
811478e4:	df000404 	addi	fp,sp,16
811478e8:	e13ffe15 	stw	r4,-8(fp)
811478ec:	e17fff15 	stw	r5,-4(fp)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
811478f0:	e0bffe17 	ldw	r2,-8(fp)
811478f4:	10c00417 	ldw	r3,16(r2)
811478f8:	e0bffe17 	ldw	r2,-8(fp)
811478fc:	10800517 	ldw	r2,20(r2)
81147900:	18804726 	beq	r3,r2,81147a20 <altera_avalon_uart_txirq+0x150>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
81147904:	e0bffe17 	ldw	r2,-8(fp)
81147908:	10800617 	ldw	r2,24(r2)
8114790c:	1080008c 	andi	r2,r2,2
81147910:	10000326 	beq	r2,zero,81147920 <altera_avalon_uart_txirq+0x50>
      (status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
81147914:	e0bfff17 	ldw	r2,-4(fp)
81147918:	1082000c 	andi	r2,r2,2048
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
8114791c:	10003226 	beq	r2,zero,811479e8 <altera_avalon_uart_txirq+0x118>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
81147920:	e0bffe17 	ldw	r2,-8(fp)
81147924:	10c00417 	ldw	r3,16(r2)
81147928:	e0bffe17 	ldw	r2,-8(fp)
8114792c:	10800517 	ldw	r2,20(r2)
81147930:	10800044 	addi	r2,r2,1
81147934:	10800fcc 	andi	r2,r2,63
81147938:	1880121e 	bne	r3,r2,81147984 <altera_avalon_uart_txirq+0xb4>
      { 
        ALT_FLAG_POST (sp->events, 
8114793c:	e0bffe17 	ldw	r2,-8(fp)
81147940:	10800717 	ldw	r2,28(r2)
81147944:	e0bffc15 	stw	r2,-16(fp)
81147948:	00800084 	movi	r2,2
8114794c:	e0bffd0d 	sth	r2,-12(fp)
81147950:	00800044 	movi	r2,1
81147954:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81147958:	d0a09103 	ldbu	r2,-32188(gp)
8114795c:	10803fcc 	andi	r2,r2,255
81147960:	10000826 	beq	r2,zero,81147984 <altera_avalon_uart_txirq+0xb4>
  {
    OSFlagPost (group, flags, opt, &err);
81147964:	e0bffd0b 	ldhu	r2,-12(fp)
81147968:	e0fffd83 	ldbu	r3,-10(fp)
8114796c:	e13ffdc4 	addi	r4,fp,-9
81147970:	200f883a 	mov	r7,r4
81147974:	180d883a 	mov	r6,r3
81147978:	100b883a 	mov	r5,r2
8114797c:	e13ffc17 	ldw	r4,-16(fp)
81147980:	113b4a00 	call	8113b4a0 <OSFlagPost>
                       OS_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
81147984:	e0bffe17 	ldw	r2,-8(fp)
81147988:	10800017 	ldw	r2,0(r2)
8114798c:	10800104 	addi	r2,r2,4
81147990:	e0fffe17 	ldw	r3,-8(fp)
81147994:	18c00417 	ldw	r3,16(r3)
81147998:	e13ffe17 	ldw	r4,-8(fp)
8114799c:	20c7883a 	add	r3,r4,r3
811479a0:	18c01a04 	addi	r3,r3,104
811479a4:	18c00003 	ldbu	r3,0(r3)
811479a8:	18c03fcc 	andi	r3,r3,255
811479ac:	10c00035 	stwio	r3,0(r2)

      sp->tx_start = (++sp->tx_start) & ALT_AVALON_UART_BUF_MSK;
811479b0:	e0bffe17 	ldw	r2,-8(fp)
811479b4:	10800417 	ldw	r2,16(r2)
811479b8:	10800044 	addi	r2,r2,1
811479bc:	e0fffe17 	ldw	r3,-8(fp)
811479c0:	18800415 	stw	r2,16(r3)
811479c4:	10c00fcc 	andi	r3,r2,63
811479c8:	e0bffe17 	ldw	r2,-8(fp)
811479cc:	10c00415 	stw	r3,16(r2)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
811479d0:	e0bffe17 	ldw	r2,-8(fp)
811479d4:	10800117 	ldw	r2,4(r2)
811479d8:	10c01014 	ori	r3,r2,64
811479dc:	e0bffe17 	ldw	r2,-8(fp)
811479e0:	10c00115 	stw	r3,4(r2)
811479e4:	00000e06 	br	81147a20 <altera_avalon_uart_txirq+0x150>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
811479e8:	e0bffe17 	ldw	r2,-8(fp)
811479ec:	10800017 	ldw	r2,0(r2)
811479f0:	10800204 	addi	r2,r2,8
811479f4:	10800037 	ldwio	r2,0(r2)
811479f8:	e0bfff15 	stw	r2,-4(fp)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
811479fc:	e0bfff17 	ldw	r2,-4(fp)
81147a00:	1082000c 	andi	r2,r2,2048
81147a04:	1000061e 	bne	r2,zero,81147a20 <altera_avalon_uart_txirq+0x150>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
81147a08:	e0bffe17 	ldw	r2,-8(fp)
81147a0c:	10c00117 	ldw	r3,4(r2)
81147a10:	00bfefc4 	movi	r2,-65
81147a14:	1886703a 	and	r3,r3,r2
81147a18:	e0bffe17 	ldw	r2,-8(fp)
81147a1c:	10c00115 	stw	r3,4(r2)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
81147a20:	e0bffe17 	ldw	r2,-8(fp)
81147a24:	10c00417 	ldw	r3,16(r2)
81147a28:	e0bffe17 	ldw	r2,-8(fp)
81147a2c:	10800517 	ldw	r2,20(r2)
81147a30:	1880061e 	bne	r3,r2,81147a4c <altera_avalon_uart_txirq+0x17c>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
81147a34:	e0bffe17 	ldw	r2,-8(fp)
81147a38:	10c00117 	ldw	r3,4(r2)
81147a3c:	00beefc4 	movi	r2,-1089
81147a40:	1886703a 	and	r3,r3,r2
81147a44:	e0bffe17 	ldw	r2,-8(fp)
81147a48:	10c00115 	stw	r3,4(r2)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81147a4c:	e0bffe17 	ldw	r2,-8(fp)
81147a50:	10800017 	ldw	r2,0(r2)
81147a54:	10800304 	addi	r2,r2,12
81147a58:	e0fffe17 	ldw	r3,-8(fp)
81147a5c:	18c00117 	ldw	r3,4(r3)
81147a60:	10c00035 	stwio	r3,0(r2)
}
81147a64:	0001883a 	nop
81147a68:	e037883a 	mov	sp,fp
81147a6c:	dfc00117 	ldw	ra,4(sp)
81147a70:	df000017 	ldw	fp,0(sp)
81147a74:	dec00204 	addi	sp,sp,8
81147a78:	f800283a 	ret

81147a7c <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
81147a7c:	defffd04 	addi	sp,sp,-12
81147a80:	de00012e 	bgeu	sp,et,81147a88 <altera_avalon_uart_close+0xc>
81147a84:	003b68fa 	trap	3
81147a88:	df000215 	stw	fp,8(sp)
81147a8c:	df000204 	addi	fp,sp,8
81147a90:	e13ffe15 	stw	r4,-8(fp)
81147a94:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
81147a98:	00000506 	br	81147ab0 <altera_avalon_uart_close+0x34>
    if (flags & O_NONBLOCK) {
81147a9c:	e0bfff17 	ldw	r2,-4(fp)
81147aa0:	1090000c 	andi	r2,r2,16384
81147aa4:	10000226 	beq	r2,zero,81147ab0 <altera_avalon_uart_close+0x34>
      return -EWOULDBLOCK; 
81147aa8:	00bffd44 	movi	r2,-11
81147aac:	00000606 	br	81147ac8 <altera_avalon_uart_close+0x4c>
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
81147ab0:	e0bffe17 	ldw	r2,-8(fp)
81147ab4:	10c00417 	ldw	r3,16(r2)
81147ab8:	e0bffe17 	ldw	r2,-8(fp)
81147abc:	10800517 	ldw	r2,20(r2)
81147ac0:	18bff61e 	bne	r3,r2,81147a9c <__reset+0xfb127a9c>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
81147ac4:	0005883a 	mov	r2,zero
}
81147ac8:	e037883a 	mov	sp,fp
81147acc:	df000017 	ldw	fp,0(sp)
81147ad0:	dec00104 	addi	sp,sp,4
81147ad4:	f800283a 	ret

81147ad8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81147ad8:	defffe04 	addi	sp,sp,-8
81147adc:	de00012e 	bgeu	sp,et,81147ae4 <alt_get_errno+0xc>
81147ae0:	003b68fa 	trap	3
81147ae4:	dfc00115 	stw	ra,4(sp)
81147ae8:	df000015 	stw	fp,0(sp)
81147aec:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81147af0:	d0a01017 	ldw	r2,-32704(gp)
81147af4:	10000326 	beq	r2,zero,81147b04 <alt_get_errno+0x2c>
81147af8:	d0a01017 	ldw	r2,-32704(gp)
81147afc:	103ee83a 	callr	r2
81147b00:	00000106 	br	81147b08 <alt_get_errno+0x30>
81147b04:	d0a07804 	addi	r2,gp,-32288
}
81147b08:	e037883a 	mov	sp,fp
81147b0c:	dfc00117 	ldw	ra,4(sp)
81147b10:	df000017 	ldw	fp,0(sp)
81147b14:	dec00204 	addi	sp,sp,8
81147b18:	f800283a 	ret

81147b1c <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
81147b1c:	deffec04 	addi	sp,sp,-80
81147b20:	de00012e 	bgeu	sp,et,81147b28 <altera_avalon_uart_read+0xc>
81147b24:	003b68fa 	trap	3
81147b28:	dfc01315 	stw	ra,76(sp)
81147b2c:	df001215 	stw	fp,72(sp)
81147b30:	df001204 	addi	fp,sp,72
81147b34:	e13ffc15 	stw	r4,-16(fp)
81147b38:	e17ffd15 	stw	r5,-12(fp)
81147b3c:	e1bffe15 	stw	r6,-8(fp)
81147b40:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             block;
  alt_u8          read_would_block = 0;
81147b44:	e03fef05 	stb	zero,-68(fp)
  int             count = 0;
81147b48:	e03ff015 	stw	zero,-64(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
81147b4c:	e0bfff17 	ldw	r2,-4(fp)
81147b50:	1090000c 	andi	r2,r2,16384
81147b54:	1005003a 	cmpeq	r2,r2,zero
81147b58:	10803fcc 	andi	r2,r2,255
81147b5c:	e0bff115 	stw	r2,-60(fp)
  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */

  ALT_SEM_PEND (sp->read_lock, 0);
81147b60:	e0bffc17 	ldw	r2,-16(fp)
81147b64:	10800817 	ldw	r2,32(r2)
81147b68:	e0bff815 	stw	r2,-32(fp)
81147b6c:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
81147b70:	e0bff90b 	ldhu	r2,-28(fp)
81147b74:	e0fffb44 	addi	r3,fp,-19
81147b78:	180d883a 	mov	r6,r3
81147b7c:	100b883a 	mov	r5,r2
81147b80:	e13ff817 	ldw	r4,-32(fp)
81147b84:	113eb180 	call	8113eb18 <OSSemPend>
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
81147b88:	00001306 	br	81147bd8 <altera_avalon_uart_read+0xbc>
    {
      count++;
81147b8c:	e0bff017 	ldw	r2,-64(fp)
81147b90:	10800044 	addi	r2,r2,1
81147b94:	e0bff015 	stw	r2,-64(fp)
      *ptr++ = sp->rx_buf[sp->rx_start];
81147b98:	e0bffd17 	ldw	r2,-12(fp)
81147b9c:	10c00044 	addi	r3,r2,1
81147ba0:	e0fffd15 	stw	r3,-12(fp)
81147ba4:	e0fffc17 	ldw	r3,-16(fp)
81147ba8:	18c00217 	ldw	r3,8(r3)
81147bac:	e13ffc17 	ldw	r4,-16(fp)
81147bb0:	20c7883a 	add	r3,r4,r3
81147bb4:	18c00a04 	addi	r3,r3,40
81147bb8:	18c00003 	ldbu	r3,0(r3)
81147bbc:	10c00005 	stb	r3,0(r2)
      
      sp->rx_start = (sp->rx_start+1) & ALT_AVALON_UART_BUF_MSK;
81147bc0:	e0bffc17 	ldw	r2,-16(fp)
81147bc4:	10800217 	ldw	r2,8(r2)
81147bc8:	10800044 	addi	r2,r2,1
81147bcc:	10c00fcc 	andi	r3,r2,63
81147bd0:	e0bffc17 	ldw	r2,-16(fp)
81147bd4:	10c00215 	stw	r3,8(r2)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
81147bd8:	e0fff017 	ldw	r3,-64(fp)
81147bdc:	e0bffe17 	ldw	r2,-8(fp)
81147be0:	1880050e 	bge	r3,r2,81147bf8 <altera_avalon_uart_read+0xdc>
81147be4:	e0bffc17 	ldw	r2,-16(fp)
81147be8:	10c00217 	ldw	r3,8(r2)
81147bec:	e0bffc17 	ldw	r2,-16(fp)
81147bf0:	10800317 	ldw	r2,12(r2)
81147bf4:	18bfe51e 	bne	r3,r2,81147b8c <__reset+0xfb127b8c>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
81147bf8:	e0bff017 	ldw	r2,-64(fp)
81147bfc:	10003a1e 	bne	r2,zero,81147ce8 <altera_avalon_uart_read+0x1cc>
81147c00:	e0bffc17 	ldw	r2,-16(fp)
81147c04:	10c00217 	ldw	r3,8(r2)
81147c08:	e0bffc17 	ldw	r2,-16(fp)
81147c0c:	10800317 	ldw	r2,12(r2)
81147c10:	1880351e 	bne	r3,r2,81147ce8 <altera_avalon_uart_read+0x1cc>
    {
      if (!block)
81147c14:	e0bff117 	ldw	r2,-60(fp)
81147c18:	1000071e 	bne	r2,zero,81147c38 <altera_avalon_uart_read+0x11c>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
81147c1c:	1147ad80 	call	81147ad8 <alt_get_errno>
81147c20:	1007883a 	mov	r3,r2
81147c24:	008002c4 	movi	r2,11
81147c28:	18800015 	stw	r2,0(r3)
        read_would_block = 1;
81147c2c:	00800044 	movi	r2,1
81147c30:	e0bfef05 	stb	r2,-68(fp)
        break;
81147c34:	00003006 	br	81147cf8 <altera_avalon_uart_read+0x1dc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81147c38:	0005303a 	rdctl	r2,status
81147c3c:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81147c40:	e0fff517 	ldw	r3,-44(fp)
81147c44:	00bfff84 	movi	r2,-2
81147c48:	1884703a 	and	r2,r3,r2
81147c4c:	1001703a 	wrctl	status,r2
  
  return context;
81147c50:	e0bff517 	ldw	r2,-44(fp)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
81147c54:	e0bff415 	stw	r2,-48(fp)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
81147c58:	e0bffc17 	ldw	r2,-16(fp)
81147c5c:	10800117 	ldw	r2,4(r2)
81147c60:	10c02014 	ori	r3,r2,128
81147c64:	e0bffc17 	ldw	r2,-16(fp)
81147c68:	10c00115 	stw	r3,4(r2)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81147c6c:	e0bffc17 	ldw	r2,-16(fp)
81147c70:	10800017 	ldw	r2,0(r2)
81147c74:	10800304 	addi	r2,r2,12
81147c78:	e0fffc17 	ldw	r3,-16(fp)
81147c7c:	18c00117 	ldw	r3,4(r3)
81147c80:	10c00035 	stwio	r3,0(r2)
81147c84:	e0bff417 	ldw	r2,-48(fp)
81147c88:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81147c8c:	e0bff617 	ldw	r2,-40(fp)
81147c90:	1001703a 	wrctl	status,r2
        * flag set in the interrupt service routine. This avoids wasting CPU
        * cycles waiting in this thread, when we could be doing something more 
        * profitable elsewhere.
        */

       ALT_FLAG_PEND (sp->events, 
81147c94:	e0bffc17 	ldw	r2,-16(fp)
81147c98:	10800717 	ldw	r2,28(r2)
81147c9c:	e0bff215 	stw	r2,-56(fp)
81147ca0:	00800044 	movi	r2,1
81147ca4:	e0bff98d 	sth	r2,-26(fp)
81147ca8:	00bfe0c4 	movi	r2,-125
81147cac:	e0bffa05 	stb	r2,-24(fp)
81147cb0:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81147cb4:	d0a09103 	ldbu	r2,-32188(gp)
81147cb8:	10803fcc 	andi	r2,r2,255
81147cbc:	10000a26 	beq	r2,zero,81147ce8 <altera_avalon_uart_read+0x1cc>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81147cc0:	e0fff98b 	ldhu	r3,-26(fp)
81147cc4:	e13ffa03 	ldbu	r4,-24(fp)
81147cc8:	e17ffa8b 	ldhu	r5,-22(fp)
81147ccc:	e0bffb04 	addi	r2,fp,-20
81147cd0:	d8800015 	stw	r2,0(sp)
81147cd4:	280f883a 	mov	r7,r5
81147cd8:	200d883a 	mov	r6,r4
81147cdc:	180b883a 	mov	r5,r3
81147ce0:	e13ff217 	ldw	r4,-56(fp)
81147ce4:	113ae780 	call	8113ae78 <OSFlagPend>
                      OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                      0);
      }
    }
  }
  while (!count && len);
81147ce8:	e0bff017 	ldw	r2,-64(fp)
81147cec:	1000021e 	bne	r2,zero,81147cf8 <altera_avalon_uart_read+0x1dc>
81147cf0:	e0bffe17 	ldw	r2,-8(fp)
81147cf4:	103fb81e 	bne	r2,zero,81147bd8 <__reset+0xfb127bd8>
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
81147cf8:	e0bffc17 	ldw	r2,-16(fp)
81147cfc:	10800817 	ldw	r2,32(r2)
81147d00:	1009883a 	mov	r4,r2
81147d04:	113eea00 	call	8113eea0 <OSSemPost>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81147d08:	0005303a 	rdctl	r2,status
81147d0c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81147d10:	e0fff717 	ldw	r3,-36(fp)
81147d14:	00bfff84 	movi	r2,-2
81147d18:	1884703a 	and	r2,r3,r2
81147d1c:	1001703a 	wrctl	status,r2
  
  return context;
81147d20:	e0bff717 	ldw	r2,-36(fp)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
81147d24:	e0bff415 	stw	r2,-48(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
81147d28:	e0bffc17 	ldw	r2,-16(fp)
81147d2c:	10800117 	ldw	r2,4(r2)
81147d30:	10c02014 	ori	r3,r2,128
81147d34:	e0bffc17 	ldw	r2,-16(fp)
81147d38:	10c00115 	stw	r3,4(r2)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81147d3c:	e0bffc17 	ldw	r2,-16(fp)
81147d40:	10800017 	ldw	r2,0(r2)
81147d44:	10800304 	addi	r2,r2,12
81147d48:	e0fffc17 	ldw	r3,-16(fp)
81147d4c:	18c00117 	ldw	r3,4(r3)
81147d50:	10c00035 	stwio	r3,0(r2)
81147d54:	e0bff417 	ldw	r2,-48(fp)
81147d58:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81147d5c:	e0bff317 	ldw	r2,-52(fp)
81147d60:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
81147d64:	e0bfef03 	ldbu	r2,-68(fp)
81147d68:	10000226 	beq	r2,zero,81147d74 <altera_avalon_uart_read+0x258>
    return -EWOULDBLOCK;
81147d6c:	00bffd44 	movi	r2,-11
81147d70:	00000106 	br	81147d78 <altera_avalon_uart_read+0x25c>
  }
  else {
    return count;
81147d74:	e0bff017 	ldw	r2,-64(fp)
  }
}
81147d78:	e037883a 	mov	sp,fp
81147d7c:	dfc00117 	ldw	ra,4(sp)
81147d80:	df000017 	ldw	fp,0(sp)
81147d84:	dec00204 	addi	sp,sp,8
81147d88:	f800283a 	ret

81147d8c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81147d8c:	defffe04 	addi	sp,sp,-8
81147d90:	de00012e 	bgeu	sp,et,81147d98 <alt_get_errno+0xc>
81147d94:	003b68fa 	trap	3
81147d98:	dfc00115 	stw	ra,4(sp)
81147d9c:	df000015 	stw	fp,0(sp)
81147da0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81147da4:	d0a01017 	ldw	r2,-32704(gp)
81147da8:	10000326 	beq	r2,zero,81147db8 <alt_get_errno+0x2c>
81147dac:	d0a01017 	ldw	r2,-32704(gp)
81147db0:	103ee83a 	callr	r2
81147db4:	00000106 	br	81147dbc <alt_get_errno+0x30>
81147db8:	d0a07804 	addi	r2,gp,-32288
}
81147dbc:	e037883a 	mov	sp,fp
81147dc0:	dfc00117 	ldw	ra,4(sp)
81147dc4:	df000017 	ldw	fp,0(sp)
81147dc8:	dec00204 	addi	sp,sp,8
81147dcc:	f800283a 	ret

81147dd0 <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
81147dd0:	deffec04 	addi	sp,sp,-80
81147dd4:	de00012e 	bgeu	sp,et,81147ddc <altera_avalon_uart_write+0xc>
81147dd8:	003b68fa 	trap	3
81147ddc:	dfc01315 	stw	ra,76(sp)
81147de0:	df001215 	stw	fp,72(sp)
81147de4:	df001204 	addi	fp,sp,72
81147de8:	e13ffc15 	stw	r4,-16(fp)
81147dec:	e17ffd15 	stw	r5,-12(fp)
81147df0:	e1bffe15 	stw	r6,-8(fp)
81147df4:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
81147df8:	e0bffe17 	ldw	r2,-8(fp)
81147dfc:	e0bfef15 	stw	r2,-68(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
81147e00:	e0bfff17 	ldw	r2,-4(fp)
81147e04:	1090000c 	andi	r2,r2,16384
81147e08:	e0bff015 	stw	r2,-64(fp)
  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */

  ALT_SEM_PEND (sp->write_lock, 0);
81147e0c:	e0bffc17 	ldw	r2,-16(fp)
81147e10:	10800917 	ldw	r2,36(r2)
81147e14:	e0bff815 	stw	r2,-32(fp)
81147e18:	e03ff90d 	sth	zero,-28(fp)
81147e1c:	e0bff90b 	ldhu	r2,-28(fp)
81147e20:	e0fffb44 	addi	r3,fp,-19
81147e24:	180d883a 	mov	r6,r3
81147e28:	100b883a 	mov	r5,r2
81147e2c:	e13ff817 	ldw	r4,-32(fp)
81147e30:	113eb180 	call	8113eb18 <OSSemPend>
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
81147e34:	00005106 	br	81147f7c <altera_avalon_uart_write+0x1ac>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
81147e38:	e0bffc17 	ldw	r2,-16(fp)
81147e3c:	10800517 	ldw	r2,20(r2)
81147e40:	10800044 	addi	r2,r2,1
81147e44:	10800fcc 	andi	r2,r2,63
81147e48:	e0bff215 	stw	r2,-56(fp)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
81147e4c:	e0bffc17 	ldw	r2,-16(fp)
81147e50:	10c00417 	ldw	r3,16(r2)
81147e54:	e0bff217 	ldw	r2,-56(fp)
81147e58:	1880371e 	bne	r3,r2,81147f38 <altera_avalon_uart_write+0x168>
    {
      if (no_block)
81147e5c:	e0bff017 	ldw	r2,-64(fp)
81147e60:	10000526 	beq	r2,zero,81147e78 <altera_avalon_uart_write+0xa8>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
81147e64:	1147d8c0 	call	81147d8c <alt_get_errno>
81147e68:	1007883a 	mov	r3,r2
81147e6c:	008002c4 	movi	r2,11
81147e70:	18800015 	stw	r2,0(r3)
        break;
81147e74:	00004306 	br	81147f84 <altera_avalon_uart_write+0x1b4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81147e78:	0005303a 	rdctl	r2,status
81147e7c:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81147e80:	e0fff517 	ldw	r3,-44(fp)
81147e84:	00bfff84 	movi	r2,-2
81147e88:	1884703a 	and	r2,r3,r2
81147e8c:	1001703a 	wrctl	status,r2
  
  return context;
81147e90:	e0bff517 	ldw	r2,-44(fp)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
81147e94:	e0bff415 	stw	r2,-48(fp)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
81147e98:	e0bffc17 	ldw	r2,-16(fp)
81147e9c:	10800117 	ldw	r2,4(r2)
81147ea0:	10c11014 	ori	r3,r2,1088
81147ea4:	e0bffc17 	ldw	r2,-16(fp)
81147ea8:	10c00115 	stw	r3,4(r2)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81147eac:	e0bffc17 	ldw	r2,-16(fp)
81147eb0:	10800017 	ldw	r2,0(r2)
81147eb4:	10800304 	addi	r2,r2,12
81147eb8:	e0fffc17 	ldw	r3,-16(fp)
81147ebc:	18c00117 	ldw	r3,4(r3)
81147ec0:	10c00035 	stwio	r3,0(r2)
81147ec4:	e0bff417 	ldw	r2,-48(fp)
81147ec8:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81147ecc:	e0bff117 	ldw	r2,-60(fp)
81147ed0:	1001703a 	wrctl	status,r2
           * flag set in the interrupt service routine. This avoids wasting CPU
           * cycles waiting in this thread, when we could be doing something
           * more profitable elsewhere.
           */

          ALT_FLAG_PEND (sp->events, 
81147ed4:	e0bffc17 	ldw	r2,-16(fp)
81147ed8:	10800717 	ldw	r2,28(r2)
81147edc:	e0bff315 	stw	r2,-52(fp)
81147ee0:	00800084 	movi	r2,2
81147ee4:	e0bff98d 	sth	r2,-26(fp)
81147ee8:	00bfe0c4 	movi	r2,-125
81147eec:	e0bffa05 	stb	r2,-24(fp)
81147ef0:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81147ef4:	d0a09103 	ldbu	r2,-32188(gp)
81147ef8:	10803fcc 	andi	r2,r2,255
81147efc:	10000a26 	beq	r2,zero,81147f28 <altera_avalon_uart_write+0x158>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81147f00:	e0fff98b 	ldhu	r3,-26(fp)
81147f04:	e13ffa03 	ldbu	r4,-24(fp)
81147f08:	e17ffa8b 	ldhu	r5,-22(fp)
81147f0c:	e0bffb04 	addi	r2,fp,-20
81147f10:	d8800015 	stw	r2,0(sp)
81147f14:	280f883a 	mov	r7,r5
81147f18:	200d883a 	mov	r6,r4
81147f1c:	180b883a 	mov	r5,r3
81147f20:	e13ff317 	ldw	r4,-52(fp)
81147f24:	113ae780 	call	8113ae78 <OSFlagPend>
                         ALT_UART_WRITE_RDY,
                         OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                         0);
        }
        while ((next == sp->tx_start));
81147f28:	e0bffc17 	ldw	r2,-16(fp)
81147f2c:	10c00417 	ldw	r3,16(r2)
81147f30:	e0bff217 	ldw	r2,-56(fp)
81147f34:	18bfe726 	beq	r3,r2,81147ed4 <__reset+0xfb127ed4>
      }
    }

    count--;
81147f38:	e0bfef17 	ldw	r2,-68(fp)
81147f3c:	10bfffc4 	addi	r2,r2,-1
81147f40:	e0bfef15 	stw	r2,-68(fp)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
81147f44:	e0bffc17 	ldw	r2,-16(fp)
81147f48:	10c00517 	ldw	r3,20(r2)
81147f4c:	e0bffd17 	ldw	r2,-12(fp)
81147f50:	11000044 	addi	r4,r2,1
81147f54:	e13ffd15 	stw	r4,-12(fp)
81147f58:	10800003 	ldbu	r2,0(r2)
81147f5c:	1009883a 	mov	r4,r2
81147f60:	e0bffc17 	ldw	r2,-16(fp)
81147f64:	10c5883a 	add	r2,r2,r3
81147f68:	10801a04 	addi	r2,r2,104
81147f6c:	11000005 	stb	r4,0(r2)
    sp->tx_end = next;
81147f70:	e0bffc17 	ldw	r2,-16(fp)
81147f74:	e0fff217 	ldw	r3,-56(fp)
81147f78:	10c00515 	stw	r3,20(r2)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
81147f7c:	e0bfef17 	ldw	r2,-68(fp)
81147f80:	103fad1e 	bne	r2,zero,81147e38 <__reset+0xfb127e38>
  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);
81147f84:	e0bffc17 	ldw	r2,-16(fp)
81147f88:	10800917 	ldw	r2,36(r2)
81147f8c:	1009883a 	mov	r4,r2
81147f90:	113eea00 	call	8113eea0 <OSSemPost>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81147f94:	0005303a 	rdctl	r2,status
81147f98:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81147f9c:	e0fff717 	ldw	r3,-36(fp)
81147fa0:	00bfff84 	movi	r2,-2
81147fa4:	1884703a 	and	r2,r3,r2
81147fa8:	1001703a 	wrctl	status,r2
  
  return context;
81147fac:	e0bff717 	ldw	r2,-36(fp)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
81147fb0:	e0bff415 	stw	r2,-48(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
81147fb4:	e0bffc17 	ldw	r2,-16(fp)
81147fb8:	10800117 	ldw	r2,4(r2)
81147fbc:	10c11014 	ori	r3,r2,1088
81147fc0:	e0bffc17 	ldw	r2,-16(fp)
81147fc4:	10c00115 	stw	r3,4(r2)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81147fc8:	e0bffc17 	ldw	r2,-16(fp)
81147fcc:	10800017 	ldw	r2,0(r2)
81147fd0:	10800304 	addi	r2,r2,12
81147fd4:	e0fffc17 	ldw	r3,-16(fp)
81147fd8:	18c00117 	ldw	r3,4(r3)
81147fdc:	10c00035 	stwio	r3,0(r2)
81147fe0:	e0bff417 	ldw	r2,-48(fp)
81147fe4:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81147fe8:	e0bff617 	ldw	r2,-40(fp)
81147fec:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
81147ff0:	e0fffe17 	ldw	r3,-8(fp)
81147ff4:	e0bfef17 	ldw	r2,-68(fp)
81147ff8:	1885c83a 	sub	r2,r3,r2
}
81147ffc:	e037883a 	mov	sp,fp
81148000:	dfc00117 	ldw	ra,4(sp)
81148004:	df000017 	ldw	fp,0(sp)
81148008:	dec00204 	addi	sp,sp,8
8114800c:	f800283a 	ret

81148010 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81148010:	defffe04 	addi	sp,sp,-8
81148014:	de00012e 	bgeu	sp,et,8114801c <alt_get_errno+0xc>
81148018:	003b68fa 	trap	3
8114801c:	dfc00115 	stw	ra,4(sp)
81148020:	df000015 	stw	fp,0(sp)
81148024:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81148028:	d0a01017 	ldw	r2,-32704(gp)
8114802c:	10000326 	beq	r2,zero,8114803c <alt_get_errno+0x2c>
81148030:	d0a01017 	ldw	r2,-32704(gp)
81148034:	103ee83a 	callr	r2
81148038:	00000106 	br	81148040 <alt_get_errno+0x30>
8114803c:	d0a07804 	addi	r2,gp,-32288
}
81148040:	e037883a 	mov	sp,fp
81148044:	dfc00117 	ldw	ra,4(sp)
81148048:	df000017 	ldw	fp,0(sp)
8114804c:	dec00204 	addi	sp,sp,8
81148050:	f800283a 	ret

81148054 <alt_msgdma_write_standard_descriptor>:
 */
static int alt_msgdma_write_standard_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_standard_descriptor *descriptor)
{
81148054:	defffc04 	addi	sp,sp,-16
81148058:	de00012e 	bgeu	sp,et,81148060 <alt_msgdma_write_standard_descriptor+0xc>
8114805c:	003b68fa 	trap	3
81148060:	df000315 	stw	fp,12(sp)
81148064:	df000304 	addi	fp,sp,12
81148068:	e13ffd15 	stw	r4,-12(fp)
8114806c:	e17ffe15 	stw	r5,-8(fp)
81148070:	e1bfff15 	stw	r6,-4(fp)
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
81148074:	e0bffd17 	ldw	r2,-12(fp)
81148078:	10800037 	ldwio	r2,0(r2)
8114807c:	1080010c 	andi	r2,r2,4
81148080:	10000226 	beq	r2,zero,8114808c <alt_msgdma_write_standard_descriptor+0x38>
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
		is non-blocking*/
        return -ENOSPC;
81148084:	00bff904 	movi	r2,-28
81148088:	00001506 	br	811480e0 <alt_msgdma_write_standard_descriptor+0x8c>
    }

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base, 
8114808c:	e0bfff17 	ldw	r2,-4(fp)
81148090:	10800017 	ldw	r2,0(r2)
81148094:	1007883a 	mov	r3,r2
81148098:	e0bffe17 	ldw	r2,-8(fp)
8114809c:	10c00035 	stwio	r3,0(r2)
		(alt_u32)descriptor->read_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base, 
811480a0:	e0bffe17 	ldw	r2,-8(fp)
811480a4:	10800104 	addi	r2,r2,4
811480a8:	e0ffff17 	ldw	r3,-4(fp)
811480ac:	18c00117 	ldw	r3,4(r3)
811480b0:	10c00035 	stwio	r3,0(r2)
	(	alt_u32)descriptor->write_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base, 
811480b4:	e0bffe17 	ldw	r2,-8(fp)
811480b8:	10800204 	addi	r2,r2,8
811480bc:	e0ffff17 	ldw	r3,-4(fp)
811480c0:	18c00217 	ldw	r3,8(r3)
811480c4:	10c00035 	stwio	r3,0(r2)
		descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_STANDARD(descriptor_base, 
811480c8:	e0bffe17 	ldw	r2,-8(fp)
811480cc:	10800304 	addi	r2,r2,12
811480d0:	e0ffff17 	ldw	r3,-4(fp)
811480d4:	18c00317 	ldw	r3,12(r3)
811480d8:	10c00035 	stwio	r3,0(r2)
		descriptor->control);
        return 0;
811480dc:	0005883a 	mov	r2,zero
}
811480e0:	e037883a 	mov	sp,fp
811480e4:	df000017 	ldw	fp,0(sp)
811480e8:	dec00104 	addi	sp,sp,4
811480ec:	f800283a 	ret

811480f0 <alt_msgdma_write_extended_descriptor>:
 */
static int alt_msgdma_write_extended_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_extended_descriptor *descriptor)
{
811480f0:	defffc04 	addi	sp,sp,-16
811480f4:	de00012e 	bgeu	sp,et,811480fc <alt_msgdma_write_extended_descriptor+0xc>
811480f8:	003b68fa 	trap	3
811480fc:	df000315 	stw	fp,12(sp)
81148100:	df000304 	addi	fp,sp,12
81148104:	e13ffd15 	stw	r4,-12(fp)
81148108:	e17ffe15 	stw	r5,-8(fp)
8114810c:	e1bfff15 	stw	r6,-4(fp)
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
81148110:	e0bffd17 	ldw	r2,-12(fp)
81148114:	10800037 	ldwio	r2,0(r2)
81148118:	1080010c 	andi	r2,r2,4
8114811c:	10000226 	beq	r2,zero,81148128 <alt_msgdma_write_extended_descriptor+0x38>
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
	is non-blocking*/
        return -ENOSPC;
81148120:	00bff904 	movi	r2,-28
81148124:	00003b06 	br	81148214 <alt_msgdma_write_extended_descriptor+0x124>
    }

    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(
81148128:	e0bfff17 	ldw	r2,-4(fp)
8114812c:	10800017 	ldw	r2,0(r2)
81148130:	1007883a 	mov	r3,r2
81148134:	e0bffe17 	ldw	r2,-8(fp)
81148138:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	(alt_u32)descriptor->read_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(
8114813c:	e0bffe17 	ldw	r2,-8(fp)
81148140:	10800104 	addi	r2,r2,4
81148144:	e0ffff17 	ldw	r3,-4(fp)
81148148:	18c00117 	ldw	r3,4(r3)
8114814c:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
		(alt_u32)descriptor->write_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(
81148150:	e0bffe17 	ldw	r2,-8(fp)
81148154:	10800204 	addi	r2,r2,8
81148158:	e0ffff17 	ldw	r3,-4(fp)
8114815c:	18c00217 	ldw	r3,8(r3)
81148160:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	descriptor->transfer_length);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(
81148164:	e0bffe17 	ldw	r2,-8(fp)
81148168:	10800304 	addi	r2,r2,12
8114816c:	e0ffff17 	ldw	r3,-4(fp)
81148170:	18c0030b 	ldhu	r3,12(r3)
81148174:	18ffffcc 	andi	r3,r3,65535
81148178:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->sequence_number);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(
8114817c:	e0bffe17 	ldw	r2,-8(fp)
81148180:	10800384 	addi	r2,r2,14
81148184:	e0ffff17 	ldw	r3,-4(fp)
81148188:	18c00383 	ldbu	r3,14(r3)
8114818c:	18c03fcc 	andi	r3,r3,255
81148190:	10c00025 	stbio	r3,0(r2)
		descriptor_base, 
    	descriptor->read_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(
81148194:	e0bffe17 	ldw	r2,-8(fp)
81148198:	108003c4 	addi	r2,r2,15
8114819c:	e0ffff17 	ldw	r3,-4(fp)
811481a0:	18c003c3 	ldbu	r3,15(r3)
811481a4:	18c03fcc 	andi	r3,r3,255
811481a8:	10c00025 	stbio	r3,0(r2)
		descriptor_base, 
    	descriptor->write_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(
811481ac:	e0bffe17 	ldw	r2,-8(fp)
811481b0:	10800404 	addi	r2,r2,16
811481b4:	e0ffff17 	ldw	r3,-4(fp)
811481b8:	18c0040b 	ldhu	r3,16(r3)
811481bc:	18ffffcc 	andi	r3,r3,65535
811481c0:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->read_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(
811481c4:	e0bffe17 	ldw	r2,-8(fp)
811481c8:	10800484 	addi	r2,r2,18
811481cc:	e0ffff17 	ldw	r3,-4(fp)
811481d0:	18c0048b 	ldhu	r3,18(r3)
811481d4:	18ffffcc 	andi	r3,r3,65535
811481d8:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->write_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base, 0);
811481dc:	e0bffe17 	ldw	r2,-8(fp)
811481e0:	10800504 	addi	r2,r2,20
811481e4:	0007883a 	mov	r3,zero
811481e8:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base, 0);
811481ec:	e0bffe17 	ldw	r2,-8(fp)
811481f0:	10800604 	addi	r2,r2,24
811481f4:	0007883a 	mov	r3,zero
811481f8:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(
811481fc:	e0bffe17 	ldw	r2,-8(fp)
81148200:	10800704 	addi	r2,r2,28
81148204:	e0ffff17 	ldw	r3,-4(fp)
81148208:	18c00717 	ldw	r3,28(r3)
8114820c:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	descriptor->control);
    return 0;
81148210:	0005883a 	mov	r2,zero
}
81148214:	e037883a 	mov	sp,fp
81148218:	df000017 	ldw	fp,0(sp)
8114821c:	dec00104 	addi	sp,sp,4
81148220:	f800283a 	ret

81148224 <alt_msgdma_irq>:
 * alt_msgdma_irq()
 *
 * Interrupt handler for the Modular Scatter-Gather DMA controller.
 */
static void alt_msgdma_irq(void *context)
{
81148224:	defff804 	addi	sp,sp,-32
81148228:	de00012e 	bgeu	sp,et,81148230 <alt_msgdma_irq+0xc>
8114822c:	003b68fa 	trap	3
81148230:	dfc00715 	stw	ra,28(sp)
81148234:	df000615 	stw	fp,24(sp)
81148238:	df000604 	addi	fp,sp,24
8114823c:	e13fff15 	stw	r4,-4(fp)
    alt_msgdma_dev *dev = (alt_msgdma_dev *) context;
81148240:	e0bfff17 	ldw	r2,-4(fp)
81148244:	e0bffa15 	stw	r2,-24(fp)
    alt_irq_context cpu_sr;
    alt_u32 temporary_control;

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
81148248:	e0bffa17 	ldw	r2,-24(fp)
8114824c:	10801783 	ldbu	r2,94(r2)
81148250:	10803fcc 	andi	r2,r2,255
81148254:	10001126 	beq	r2,zero,8114829c <alt_msgdma_irq+0x78>
    {
        temporary_control = 
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
81148258:	e0bffa17 	ldw	r2,-24(fp)
8114825c:	10800617 	ldw	r2,24(r2)
81148260:	10800037 	ldwio	r2,0(r2)

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
    {
        temporary_control = 
81148264:	1007883a 	mov	r3,r2
81148268:	00bffdc4 	movi	r2,-9
8114826c:	1884703a 	and	r2,r3,r2
81148270:	e0bffb15 	stw	r2,-20(fp)
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				& ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
        
        IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
81148274:	e0bffa17 	ldw	r2,-24(fp)
81148278:	10800617 	ldw	r2,24(r2)
8114827c:	e0fffb17 	ldw	r3,-20(fp)
81148280:	10c00035 	stwio	r3,0(r2)
        		temporary_control);
        
        /* clear the IRQ status- W1C */
        IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base,
81148284:	e0bffa17 	ldw	r2,-24(fp)
81148288:	10800617 	ldw	r2,24(r2)
8114828c:	10800404 	addi	r2,r2,16
81148290:	00c00044 	movi	r3,1
81148294:	10c00035 	stwio	r3,0(r2)
81148298:	00001106 	br	811482e0 <alt_msgdma_irq+0xbc>
        		ALT_MSGDMA_PREFETCHER_STATUS_IRQ_SET_MASK);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
8114829c:	e0bffa17 	ldw	r2,-24(fp)
811482a0:	10800317 	ldw	r2,12(r2)
811482a4:	10800104 	addi	r2,r2,4
811482a8:	10800037 	ldwio	r2,0(r2)
811482ac:	1007883a 	mov	r3,r2
811482b0:	00bffbc4 	movi	r2,-17
811482b4:	1884703a 	and	r2,r3,r2
811482b8:	e0bffb15 	stw	r2,-20(fp)
    			& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
811482bc:	e0bffa17 	ldw	r2,-24(fp)
811482c0:	10800317 	ldw	r2,12(r2)
811482c4:	10800104 	addi	r2,r2,4
811482c8:	e0fffb17 	ldw	r3,-20(fp)
811482cc:	10c00035 	stwio	r3,0(r2)
    	/* clear the IRQ status */
    	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
811482d0:	e0bffa17 	ldw	r2,-24(fp)
811482d4:	10800317 	ldw	r2,12(r2)
811482d8:	00c08004 	movi	r3,512
811482dc:	10c00035 	stwio	r3,0(r2)
    * Other interrupts are explicitly disabled if callbacks
    * are registered because there is no guarantee that they are 
    * pre-emption-safe. This allows the driver to support 
    * interrupt pre-emption.
    */
    if(dev->callback) 
811482e0:	e0bffa17 	ldw	r2,-24(fp)
811482e4:	10800b17 	ldw	r2,44(r2)
811482e8:	10001226 	beq	r2,zero,81148334 <alt_msgdma_irq+0x110>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811482ec:	0005303a 	rdctl	r2,status
811482f0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811482f4:	e0fffd17 	ldw	r3,-12(fp)
811482f8:	00bfff84 	movi	r2,-2
811482fc:	1884703a 	and	r2,r3,r2
81148300:	1001703a 	wrctl	status,r2
  
  return context;
81148304:	e0bffd17 	ldw	r2,-12(fp)
    {
        cpu_sr = alt_irq_disable_all();
81148308:	e0bffc15 	stw	r2,-16(fp)
        dev->callback (dev->callback_context);
8114830c:	e0bffa17 	ldw	r2,-24(fp)
81148310:	10800b17 	ldw	r2,44(r2)
81148314:	e0fffa17 	ldw	r3,-24(fp)
81148318:	18c00c17 	ldw	r3,48(r3)
8114831c:	1809883a 	mov	r4,r3
81148320:	103ee83a 	callr	r2
81148324:	e0bffc17 	ldw	r2,-16(fp)
81148328:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114832c:	e0bffe17 	ldw	r2,-8(fp)
81148330:	1001703a 	wrctl	status,r2
        alt_irq_enable_all(cpu_sr);
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
81148334:	e0bffa17 	ldw	r2,-24(fp)
81148338:	10801783 	ldbu	r2,94(r2)
8114833c:	10803fcc 	andi	r2,r2,255
81148340:	10000a26 	beq	r2,zero,8114836c <alt_msgdma_irq+0x148>
    {
    	temporary_control = 
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
81148344:	e0bffa17 	ldw	r2,-24(fp)
81148348:	10800617 	ldw	r2,24(r2)
8114834c:	10800037 	ldwio	r2,0(r2)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
81148350:	10800214 	ori	r2,r2,8
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
    {
    	temporary_control = 
81148354:	e0bffb15 	stw	r2,-20(fp)
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
    	
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
81148358:	e0bffa17 	ldw	r2,-24(fp)
8114835c:	10800617 	ldw	r2,24(r2)
81148360:	e0fffb17 	ldw	r3,-20(fp)
81148364:	10c00035 	stwio	r3,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
    }

    return;
81148368:	00000c06 	br	8114839c <alt_msgdma_irq+0x178>
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
8114836c:	e0bffa17 	ldw	r2,-24(fp)
81148370:	10800317 	ldw	r2,12(r2)
81148374:	10800104 	addi	r2,r2,4
81148378:	10800037 	ldwio	r2,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
8114837c:	10800414 	ori	r2,r2,16
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
81148380:	e0bffb15 	stw	r2,-20(fp)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
81148384:	e0bffa17 	ldw	r2,-24(fp)
81148388:	10800317 	ldw	r2,12(r2)
8114838c:	10800104 	addi	r2,r2,4
81148390:	e0fffb17 	ldw	r3,-20(fp)
81148394:	10c00035 	stwio	r3,0(r2)
    }

    return;
81148398:	0001883a 	nop
}
8114839c:	e037883a 	mov	sp,fp
811483a0:	dfc00117 	ldw	ra,4(sp)
811483a4:	df000017 	ldw	fp,0(sp)
811483a8:	dec00204 	addi	sp,sp,8
811483ac:	f800283a 	ret

811483b0 <alt_msgdma_construct_standard_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
811483b0:	defffb04 	addi	sp,sp,-20
811483b4:	de00012e 	bgeu	sp,et,811483bc <alt_msgdma_construct_standard_descriptor+0xc>
811483b8:	003b68fa 	trap	3
811483bc:	df000415 	stw	fp,16(sp)
811483c0:	df000404 	addi	fp,sp,16
811483c4:	e13ffc15 	stw	r4,-16(fp)
811483c8:	e17ffd15 	stw	r5,-12(fp)
811483cc:	e1bffe15 	stw	r6,-8(fp)
811483d0:	e1ffff15 	stw	r7,-4(fp)
    if(dev->max_byte < length ||
811483d4:	e0bffc17 	ldw	r2,-16(fp)
811483d8:	10c01217 	ldw	r3,72(r2)
811483dc:	e0800117 	ldw	r2,4(fp)
811483e0:	18800436 	bltu	r3,r2,811483f4 <alt_msgdma_construct_standard_descriptor+0x44>
       dev->enhanced_features != 0
811483e4:	e0bffc17 	ldw	r2,-16(fp)
811483e8:	10801703 	ldbu	r2,92(r2)
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
811483ec:	10803fcc 	andi	r2,r2,255
811483f0:	10000226 	beq	r2,zero,811483fc <alt_msgdma_construct_standard_descriptor+0x4c>
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
811483f4:	00bffa84 	movi	r2,-22
811483f8:	00000e06 	br	81148434 <alt_msgdma_construct_standard_descriptor+0x84>
    }
    descriptor->read_address = read_address;
811483fc:	e0bffd17 	ldw	r2,-12(fp)
81148400:	e0fffe17 	ldw	r3,-8(fp)
81148404:	10c00015 	stw	r3,0(r2)
    descriptor->write_address = write_address;
81148408:	e0bffd17 	ldw	r2,-12(fp)
8114840c:	e0ffff17 	ldw	r3,-4(fp)
81148410:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
81148414:	e0bffd17 	ldw	r2,-12(fp)
81148418:	e0c00117 	ldw	r3,4(fp)
8114841c:	10c00215 	stw	r3,8(r2)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81148420:	e0800217 	ldw	r2,8(fp)
81148424:	10e00034 	orhi	r3,r2,32768
81148428:	e0bffd17 	ldw	r2,-12(fp)
8114842c:	10c00315 	stw	r3,12(r2)
    
    return 0;
81148430:	0005883a 	mov	r2,zero
}
81148434:	e037883a 	mov	sp,fp
81148438:	df000017 	ldw	fp,0(sp)
8114843c:	dec00104 	addi	sp,sp,4
81148440:	f800283a 	ret

81148444 <alt_msgdma_construct_extended_descriptor>:
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
81148444:	defff604 	addi	sp,sp,-40
81148448:	de00012e 	bgeu	sp,et,81148450 <alt_msgdma_construct_extended_descriptor+0xc>
8114844c:	003b68fa 	trap	3
81148450:	df000915 	stw	fp,36(sp)
81148454:	df000904 	addi	fp,sp,36
81148458:	e13ff715 	stw	r4,-36(fp)
8114845c:	e17ff815 	stw	r5,-32(fp)
81148460:	e1bff915 	stw	r6,-28(fp)
81148464:	e1fffa15 	stw	r7,-24(fp)
81148468:	e1800317 	ldw	r6,12(fp)
8114846c:	e1400417 	ldw	r5,16(fp)
81148470:	e1000517 	ldw	r4,20(fp)
81148474:	e0c00617 	ldw	r3,24(fp)
81148478:	e0800717 	ldw	r2,28(fp)
8114847c:	e1bffb0d 	sth	r6,-20(fp)
81148480:	e17ffc05 	stb	r5,-16(fp)
81148484:	e13ffd05 	stb	r4,-12(fp)
81148488:	e0fffe0d 	sth	r3,-8(fp)
8114848c:	e0bfff0d 	sth	r2,-4(fp)
    if(dev->max_byte < length ||
81148490:	e0bff717 	ldw	r2,-36(fp)
81148494:	10c01217 	ldw	r3,72(r2)
81148498:	e0800117 	ldw	r2,4(fp)
8114849c:	18801936 	bltu	r3,r2,81148504 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
811484a0:	e13ff717 	ldw	r4,-36(fp)
811484a4:	20801317 	ldw	r2,76(r4)
811484a8:	20c01417 	ldw	r3,80(r4)
811484ac:	e13ffe0b 	ldhu	r4,-8(fp)
811484b0:	213fffcc 	andi	r4,r4,65535
811484b4:	2015883a 	mov	r10,r4
811484b8:	0017883a 	mov	r11,zero
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
811484bc:	1ac01136 	bltu	r3,r11,81148504 <alt_msgdma_construct_extended_descriptor+0xc0>
811484c0:	58c0011e 	bne	r11,r3,811484c8 <alt_msgdma_construct_extended_descriptor+0x84>
811484c4:	12800f36 	bltu	r2,r10,81148504 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
811484c8:	e13ff717 	ldw	r4,-36(fp)
811484cc:	20801317 	ldw	r2,76(r4)
811484d0:	20c01417 	ldw	r3,80(r4)
811484d4:	e13fff0b 	ldhu	r4,-4(fp)
811484d8:	213fffcc 	andi	r4,r4,65535
811484dc:	2011883a 	mov	r8,r4
811484e0:	0013883a 	mov	r9,zero
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
811484e4:	1a400736 	bltu	r3,r9,81148504 <alt_msgdma_construct_extended_descriptor+0xc0>
811484e8:	48c0011e 	bne	r9,r3,811484f0 <alt_msgdma_construct_extended_descriptor+0xac>
811484ec:	12000536 	bltu	r2,r8,81148504 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
811484f0:	e0bff717 	ldw	r2,-36(fp)
811484f4:	10801703 	ldbu	r2,92(r2)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
811484f8:	10803fcc 	andi	r2,r2,255
811484fc:	10800060 	cmpeqi	r2,r2,1
81148500:	1000021e 	bne	r2,zero,8114850c <alt_msgdma_construct_extended_descriptor+0xc8>
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
81148504:	00bffa84 	movi	r2,-22
81148508:	00002106 	br	81148590 <alt_msgdma_construct_extended_descriptor+0x14c>
    }
    
    descriptor->read_address_low = read_address;
8114850c:	e0bff817 	ldw	r2,-32(fp)
81148510:	e0fff917 	ldw	r3,-28(fp)
81148514:	10c00015 	stw	r3,0(r2)
    descriptor->write_address_low = write_address;
81148518:	e0bff817 	ldw	r2,-32(fp)
8114851c:	e0fffa17 	ldw	r3,-24(fp)
81148520:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
81148524:	e0bff817 	ldw	r2,-32(fp)
81148528:	e0c00117 	ldw	r3,4(fp)
8114852c:	10c00215 	stw	r3,8(r2)
    descriptor->sequence_number = sequence_number;
81148530:	e0bff817 	ldw	r2,-32(fp)
81148534:	e0fffb0b 	ldhu	r3,-20(fp)
81148538:	10c0030d 	sth	r3,12(r2)
    descriptor->read_burst_count = read_burst_count;
8114853c:	e0bff817 	ldw	r2,-32(fp)
81148540:	e0fffc03 	ldbu	r3,-16(fp)
81148544:	10c00385 	stb	r3,14(r2)
    descriptor->write_burst_count = write_burst_count;
81148548:	e0bff817 	ldw	r2,-32(fp)
8114854c:	e0fffd03 	ldbu	r3,-12(fp)
81148550:	10c003c5 	stb	r3,15(r2)
    descriptor->read_stride = read_stride;
81148554:	e0bff817 	ldw	r2,-32(fp)
81148558:	e0fffe0b 	ldhu	r3,-8(fp)
8114855c:	10c0040d 	sth	r3,16(r2)
    descriptor->write_stride = write_stride;
81148560:	e0bff817 	ldw	r2,-32(fp)
81148564:	e0ffff0b 	ldhu	r3,-4(fp)
81148568:	10c0048d 	sth	r3,18(r2)
    descriptor->read_address_high = NULL;
8114856c:	e0bff817 	ldw	r2,-32(fp)
81148570:	10000515 	stw	zero,20(r2)
    descriptor->write_address_high = NULL;
81148574:	e0bff817 	ldw	r2,-32(fp)
81148578:	10000615 	stw	zero,24(r2)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
8114857c:	e0800217 	ldw	r2,8(fp)
81148580:	10e00034 	orhi	r3,r2,32768
81148584:	e0bff817 	ldw	r2,-32(fp)
81148588:	10c00715 	stw	r3,28(r2)

  return 0 ;
8114858c:	0005883a 	mov	r2,zero

}
81148590:	e037883a 	mov	sp,fp
81148594:	df000017 	ldw	fp,0(sp)
81148598:	dec00104 	addi	sp,sp,4
8114859c:	f800283a 	ret

811485a0 <alt_msgdma_descriptor_async_transfer>:
 */
static int alt_msgdma_descriptor_async_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
811485a0:	deffee04 	addi	sp,sp,-72
811485a4:	de00012e 	bgeu	sp,et,811485ac <alt_msgdma_descriptor_async_transfer+0xc>
811485a8:	003b68fa 	trap	3
811485ac:	dfc01115 	stw	ra,68(sp)
811485b0:	df001015 	stw	fp,64(sp)
811485b4:	df001004 	addi	fp,sp,64
811485b8:	e13ffd15 	stw	r4,-12(fp)
811485bc:	e17ffe15 	stw	r5,-8(fp)
811485c0:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 control = 0;
811485c4:	e03ff115 	stw	zero,-60(fp)
    alt_irq_context context = 0;
811485c8:	e03ff215 	stw	zero,-56(fp)
    alt_u16 counter = 0;
811485cc:	e03ff00d 	sth	zero,-64(fp)
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
811485d0:	e0bffd17 	ldw	r2,-12(fp)
811485d4:	10800317 	ldw	r2,12(r2)
811485d8:	10800204 	addi	r2,r2,8
811485dc:	10800037 	ldwio	r2,0(r2)
	alt_msgdma_extended_descriptor *extended_desc)
{
    alt_u32 control = 0;
    alt_irq_context context = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
811485e0:	10bfffcc 	andi	r2,r2,65535
811485e4:	e0bff315 	stw	r2,-52(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
811485e8:	e0bffd17 	ldw	r2,-12(fp)
811485ec:	10800317 	ldw	r2,12(r2)
811485f0:	10800204 	addi	r2,r2,8
811485f4:	10800037 	ldwio	r2,0(r2)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
811485f8:	1004d43a 	srli	r2,r2,16
811485fc:	e0bff415 	stw	r2,-48(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
81148600:	e0bffd17 	ldw	r2,-12(fp)
81148604:	10800917 	ldw	r2,36(r2)
81148608:	e0fff417 	ldw	r3,-48(fp)
8114860c:	1880042e 	bgeu	r3,r2,81148620 <alt_msgdma_descriptor_async_transfer+0x80>
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
81148610:	e0bffd17 	ldw	r2,-12(fp)
81148614:	10800917 	ldw	r2,36(r2)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
81148618:	e0fff317 	ldw	r3,-52(fp)
8114861c:	18800236 	bltu	r3,r2,81148628 <alt_msgdma_descriptor_async_transfer+0x88>
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
	{
		/*at least one write or read FIFO descriptor buffer is full,
		returning so that this function is non-blocking*/
		return -ENOSPC;
81148620:	00bff904 	movi	r2,-28
81148624:	0000a906 	br	811488cc <alt_msgdma_descriptor_async_transfer+0x32c>
	
	/*
	* When running in a multi threaded environment, obtain the "regs_lock"
	* semaphore. This ensures that accessing registers is thread-safe.
	*/
	ALT_SEM_PEND (dev->regs_lock, 0);
81148628:	e0bffd17 	ldw	r2,-12(fp)
8114862c:	10801817 	ldw	r2,96(r2)
81148630:	e0bff615 	stw	r2,-40(fp)
81148634:	e03ffc0d 	sth	zero,-16(fp)
81148638:	e0bffc0b 	ldhu	r2,-16(fp)
8114863c:	e0fffc84 	addi	r3,fp,-14
81148640:	180d883a 	mov	r6,r3
81148644:	100b883a 	mov	r5,r2
81148648:	e13ff617 	ldw	r4,-40(fp)
8114864c:	113eb180 	call	8113eb18 <OSSemPend>
	
	/* Stop the msgdma dispatcher from issuing more descriptors to the
	read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
81148650:	00800804 	movi	r2,32
81148654:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81148658:	0005303a 	rdctl	r2,status
8114865c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81148660:	e0fff717 	ldw	r3,-36(fp)
81148664:	00bfff84 	movi	r2,-2
81148668:	1884703a 	and	r2,r3,r2
8114866c:	1001703a 	wrctl	status,r2
  
  return context;
81148670:	e0bff717 	ldw	r2,-36(fp)
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
81148674:	e0bff215 	stw	r2,-56(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81148678:	e0bffd17 	ldw	r2,-12(fp)
8114867c:	10800317 	ldw	r2,12(r2)
81148680:	10800104 	addi	r2,r2,4
81148684:	e0fff117 	ldw	r3,-60(fp)
81148688:	10c00035 	stwio	r3,0(r2)
	/*
	* Clear any (previous) status register information
	* that might occlude our error checking later.
	*/
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
8114868c:	e0bffd17 	ldw	r2,-12(fp)
81148690:	10800317 	ldw	r2,12(r2)
81148694:	e0fffd17 	ldw	r3,-12(fp)
81148698:	18c00317 	ldw	r3,12(r3)
8114869c:	18c00037 	ldwio	r3,0(r3)
811486a0:	10c00035 	stwio	r3,0(r2)
811486a4:	e0bff217 	ldw	r2,-56(fp)
811486a8:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811486ac:	e0bffb17 	ldw	r2,-20(fp)
811486b0:	1001703a 	wrctl	status,r2
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
811486b4:	e0bffe17 	ldw	r2,-8(fp)
811486b8:	10001e26 	beq	r2,zero,81148734 <alt_msgdma_descriptor_async_transfer+0x194>
811486bc:	e0bfff17 	ldw	r2,-4(fp)
811486c0:	10001c1e 	bne	r2,zero,81148734 <alt_msgdma_descriptor_async_transfer+0x194>
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
811486c4:	00001106 	br	8114870c <alt_msgdma_descriptor_async_transfer+0x16c>
		dev->csr_base, dev->descriptor_base, standard_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
811486c8:	01000044 	movi	r4,1
811486cc:	11362a00 	call	811362a0 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
811486d0:	e0bff00b 	ldhu	r2,-64(fp)
811486d4:	1084e230 	cmpltui	r2,r2,5000
811486d8:	1000091e 	bne	r2,zero,81148700 <alt_msgdma_descriptor_async_transfer+0x160>
            {
                alt_printf("time out after 5 msec while waiting" 
811486dc:	01204574 	movhi	r4,33045
811486e0:	21051404 	addi	r4,r4,5200
811486e4:	114a9f40 	call	8114a9f4 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
811486e8:	e0bffd17 	ldw	r2,-12(fp)
811486ec:	10801817 	ldw	r2,96(r2)
811486f0:	1009883a 	mov	r4,r2
811486f4:	113eea00 	call	8113eea0 <OSSemPost>
				
                return -ETIME;
811486f8:	00bff084 	movi	r2,-62
811486fc:	00007306 	br	811488cc <alt_msgdma_descriptor_async_transfer+0x32c>
            }
            counter++; 
81148700:	e0bff00b 	ldhu	r2,-64(fp)
81148704:	10800044 	addi	r2,r2,1
81148708:	e0bff00d 	sth	r2,-64(fp)

    if (NULL != standard_desc && NULL == extended_desc)
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
8114870c:	e0bffd17 	ldw	r2,-12(fp)
81148710:	10c00317 	ldw	r3,12(r2)
81148714:	e0bffd17 	ldw	r2,-12(fp)
81148718:	10800417 	ldw	r2,16(r2)
8114871c:	e1bffe17 	ldw	r6,-8(fp)
81148720:	100b883a 	mov	r5,r2
81148724:	1809883a 	mov	r4,r3
81148728:	11480540 	call	81148054 <alt_msgdma_write_standard_descriptor>
8114872c:	103fe61e 	bne	r2,zero,811486c8 <__reset+0xfb1286c8>
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
81148730:	00002706 	br	811487d0 <alt_msgdma_descriptor_async_transfer+0x230>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
81148734:	e0bffe17 	ldw	r2,-8(fp)
81148738:	10001f1e 	bne	r2,zero,811487b8 <alt_msgdma_descriptor_async_transfer+0x218>
8114873c:	e0bfff17 	ldw	r2,-4(fp)
81148740:	10001d26 	beq	r2,zero,811487b8 <alt_msgdma_descriptor_async_transfer+0x218>
    {
        counter = 0; /* reset counter */
81148744:	e03ff00d 	sth	zero,-64(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
81148748:	00001106 	br	81148790 <alt_msgdma_descriptor_async_transfer+0x1f0>
		dev->csr_base, 
		dev->descriptor_base, 
		extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
8114874c:	01000044 	movi	r4,1
81148750:	11362a00 	call	811362a0 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81148754:	e0bff00b 	ldhu	r2,-64(fp)
81148758:	1084e230 	cmpltui	r2,r2,5000
8114875c:	1000091e 	bne	r2,zero,81148784 <alt_msgdma_descriptor_async_transfer+0x1e4>
            {
                alt_printf("time out after 5 msec while waiting free FIFO buffer" 
81148760:	01204574 	movhi	r4,33045
81148764:	21052a04 	addi	r4,r4,5288
81148768:	114a9f40 	call	8114a9f4 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
8114876c:	e0bffd17 	ldw	r2,-12(fp)
81148770:	10801817 	ldw	r2,96(r2)
81148774:	1009883a 	mov	r4,r2
81148778:	113eea00 	call	8113eea0 <OSSemPost>
				
                return -ETIME;
8114877c:	00bff084 	movi	r2,-62
81148780:	00005206 	br	811488cc <alt_msgdma_descriptor_async_transfer+0x32c>
            }
            counter++; 
81148784:	e0bff00b 	ldhu	r2,-64(fp)
81148788:	10800044 	addi	r2,r2,1
8114878c:	e0bff00d 	sth	r2,-64(fp)
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
81148790:	e0bffd17 	ldw	r2,-12(fp)
81148794:	10c00317 	ldw	r3,12(r2)
81148798:	e0bffd17 	ldw	r2,-12(fp)
8114879c:	10800417 	ldw	r2,16(r2)
811487a0:	e1bfff17 	ldw	r6,-4(fp)
811487a4:	100b883a 	mov	r5,r2
811487a8:	1809883a 	mov	r4,r3
811487ac:	11480f00 	call	811480f0 <alt_msgdma_write_extended_descriptor>
811487b0:	103fe61e 	bne	r2,zero,8114874c <__reset+0xfb12874c>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
811487b4:	00000606 	br	811487d0 <alt_msgdma_descriptor_async_transfer+0x230>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
811487b8:	e0bffd17 	ldw	r2,-12(fp)
811487bc:	10801817 	ldw	r2,96(r2)
811487c0:	1009883a 	mov	r4,r2
811487c4:	113eea00 	call	8113eea0 <OSSemPost>
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
811487c8:	00bfffc4 	movi	r2,-1
811487cc:	00003f06 	br	811488cc <alt_msgdma_descriptor_async_transfer+0x32c>
    * If a callback routine has been previously registered which will be
    * called from the msgdma ISR. Set up controller to:
    *  - Run
    *  - Stop on an error with any particular descriptor
    */
    if(dev->callback)
811487d0:	e0bffd17 	ldw	r2,-12(fp)
811487d4:	10800b17 	ldw	r2,44(r2)
811487d8:	10001c26 	beq	r2,zero,8114884c <alt_msgdma_descriptor_async_transfer+0x2ac>
    {

        control |= (dev->control |
811487dc:	e0bffd17 	ldw	r2,-12(fp)
811487e0:	10c00d17 	ldw	r3,52(r2)
811487e4:	e0bff117 	ldw	r2,-60(fp)
811487e8:	1884b03a 	or	r2,r3,r2
811487ec:	10800514 	ori	r2,r2,20
811487f0:	e0bff115 	stw	r2,-60(fp)
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
                    ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
        control &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
811487f4:	e0fff117 	ldw	r3,-60(fp)
811487f8:	00bff7c4 	movi	r2,-33
811487fc:	1884703a 	and	r2,r3,r2
81148800:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81148804:	0005303a 	rdctl	r2,status
81148808:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114880c:	e0fff917 	ldw	r3,-28(fp)
81148810:	00bfff84 	movi	r2,-2
81148814:	1884703a 	and	r2,r3,r2
81148818:	1001703a 	wrctl	status,r2
  
  return context;
8114881c:	e0bff917 	ldw	r2,-28(fp)
    /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all(); 
81148820:	e0bff215 	stw	r2,-56(fp)
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81148824:	e0bffd17 	ldw	r2,-12(fp)
81148828:	10800317 	ldw	r2,12(r2)
8114882c:	10800104 	addi	r2,r2,4
81148830:	e0fff117 	ldw	r3,-60(fp)
81148834:	10c00035 	stwio	r3,0(r2)
81148838:	e0bff217 	ldw	r2,-56(fp)
8114883c:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81148840:	e0bff517 	ldw	r2,-44(fp)
81148844:	1001703a 	wrctl	status,r2
81148848:	00001b06 	br	811488b8 <alt_msgdma_descriptor_async_transfer+0x318>
    *   - Stop on an error with any particular descriptor
    *   - Disable interrupt generation
    */
    else
    {
        control |= (dev->control |
8114884c:	e0bffd17 	ldw	r2,-12(fp)
81148850:	10c00d17 	ldw	r3,52(r2)
81148854:	e0bff117 	ldw	r2,-60(fp)
81148858:	1884b03a 	or	r2,r3,r2
8114885c:	10800114 	ori	r2,r2,4
81148860:	e0bff115 	stw	r2,-60(fp)
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK );
        control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
81148864:	e0fff117 	ldw	r3,-60(fp)
81148868:	00bff3c4 	movi	r2,-49
8114886c:	1884703a 	and	r2,r3,r2
81148870:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81148874:	0005303a 	rdctl	r2,status
81148878:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114887c:	e0fffa17 	ldw	r3,-24(fp)
81148880:	00bfff84 	movi	r2,-2
81148884:	1884703a 	and	r2,r3,r2
81148888:	1001703a 	wrctl	status,r2
  
  return context;
8114888c:	e0bffa17 	ldw	r2,-24(fp)
                   (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
        /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all();
81148890:	e0bff215 	stw	r2,-56(fp)
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81148894:	e0bffd17 	ldw	r2,-12(fp)
81148898:	10800317 	ldw	r2,12(r2)
8114889c:	10800104 	addi	r2,r2,4
811488a0:	e0fff117 	ldw	r3,-60(fp)
811488a4:	10c00035 	stwio	r3,0(r2)
811488a8:	e0bff217 	ldw	r2,-56(fp)
811488ac:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811488b0:	e0bff817 	ldw	r2,-32(fp)
811488b4:	1001703a 	wrctl	status,r2

    /*
	 * Now that access to the registers is complete, release the registers
     * semaphore so that other threads can access the registers.
     */
    ALT_SEM_POST (dev->regs_lock);
811488b8:	e0bffd17 	ldw	r2,-12(fp)
811488bc:	10801817 	ldw	r2,96(r2)
811488c0:	1009883a 	mov	r4,r2
811488c4:	113eea00 	call	8113eea0 <OSSemPost>
    
    return 0;
811488c8:	0005883a 	mov	r2,zero
}
811488cc:	e037883a 	mov	sp,fp
811488d0:	dfc00117 	ldw	ra,4(sp)
811488d4:	df000017 	ldw	fp,0(sp)
811488d8:	dec00204 	addi	sp,sp,8
811488dc:	f800283a 	ret

811488e0 <alt_msgdma_descriptor_sync_transfer>:
 */
static int alt_msgdma_descriptor_sync_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
811488e0:	deffee04 	addi	sp,sp,-72
811488e4:	de00012e 	bgeu	sp,et,811488ec <alt_msgdma_descriptor_sync_transfer+0xc>
811488e8:	003b68fa 	trap	3
811488ec:	dfc01115 	stw	ra,68(sp)
811488f0:	df001015 	stw	fp,64(sp)
811488f4:	df001004 	addi	fp,sp,64
811488f8:	e13ffd15 	stw	r4,-12(fp)
811488fc:	e17ffe15 	stw	r5,-8(fp)
81148900:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 control=0;
81148904:	e03ff415 	stw	zero,-48(fp)
    alt_irq_context context=0;
81148908:	e03ff515 	stw	zero,-44(fp)
    alt_u32 csr_status = 0;
8114890c:	e03ff015 	stw	zero,-64(fp)
    alt_u16 counter = 0;
81148910:	e03ff10d 	sth	zero,-60(fp)
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81148914:	e0bffd17 	ldw	r2,-12(fp)
81148918:	10800317 	ldw	r2,12(r2)
8114891c:	10800204 	addi	r2,r2,8
81148920:	10800037 	ldwio	r2,0(r2)
{
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
81148924:	10bfffcc 	andi	r2,r2,65535
81148928:	e0bff215 	stw	r2,-56(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
8114892c:	e0bffd17 	ldw	r2,-12(fp)
81148930:	10800317 	ldw	r2,12(r2)
81148934:	10800204 	addi	r2,r2,8
81148938:	10800037 	ldwio	r2,0(r2)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
8114893c:	1004d43a 	srli	r2,r2,16
81148940:	e0bff315 	stw	r2,-52(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;
    alt_u32 error = ALTERA_MSGDMA_CSR_STOPPED_ON_ERROR_MASK | 
81148944:	00807804 	movi	r2,480
81148948:	e0bff615 	stw	r2,-40(fp)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
8114894c:	00001906 	br	811489b4 <alt_msgdma_descriptor_sync_transfer+0xd4>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
    { 
        alt_busy_sleep(1); /* delay 1us */
81148950:	01000044 	movi	r4,1
81148954:	11362a00 	call	811362a0 <alt_busy_sleep>
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81148958:	e0bff10b 	ldhu	r2,-60(fp)
8114895c:	1084e230 	cmpltui	r2,r2,5000
81148960:	1000051e 	bne	r2,zero,81148978 <alt_msgdma_descriptor_sync_transfer+0x98>
        {
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
81148964:	01204574 	movhi	r4,33045
81148968:	21054004 	addi	r4,r4,5376
8114896c:	114a9f40 	call	8114a9f4 <alt_printf>
				" for storing descriptor\n");
            return -ETIME;
81148970:	00bff084 	movi	r2,-62
81148974:	0000d706 	br	81148cd4 <alt_msgdma_descriptor_sync_transfer+0x3f4>
        }
        counter++;  
81148978:	e0bff10b 	ldhu	r2,-60(fp)
8114897c:	10800044 	addi	r2,r2,1
81148980:	e0bff10d 	sth	r2,-60(fp)
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81148984:	e0bffd17 	ldw	r2,-12(fp)
81148988:	10800317 	ldw	r2,12(r2)
8114898c:	10800204 	addi	r2,r2,8
81148990:	10800037 	ldwio	r2,0(r2)
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
				" for storing descriptor\n");
            return -ETIME;
        }
        counter++;  
        fifo_read_fill_level = (
81148994:	10bfffcc 	andi	r2,r2,65535
81148998:	e0bff215 	stw	r2,-56(fp)
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
8114899c:	e0bffd17 	ldw	r2,-12(fp)
811489a0:	10800317 	ldw	r2,12(r2)
811489a4:	10800204 	addi	r2,r2,8
811489a8:	10800037 	ldwio	r2,0(r2)
        counter++;  
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
811489ac:	1004d43a 	srli	r2,r2,16
811489b0:	e0bff315 	stw	r2,-52(fp)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
811489b4:	e0bffd17 	ldw	r2,-12(fp)
811489b8:	10800917 	ldw	r2,36(r2)
811489bc:	e0fff317 	ldw	r3,-52(fp)
811489c0:	18bfe32e 	bgeu	r3,r2,81148950 <__reset+0xfb128950>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
811489c4:	e0bffd17 	ldw	r2,-12(fp)
811489c8:	10800917 	ldw	r2,36(r2)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
811489cc:	e0fff217 	ldw	r3,-56(fp)
811489d0:	18bfdf2e 	bgeu	r3,r2,81148950 <__reset+0xfb128950>

     /*
     * When running in a multi threaded environment, obtain the "regs_lock"
     * semaphore. This ensures that accessing registers is thread-safe.
     */
	ALT_SEM_PEND (dev->regs_lock, 0);
811489d4:	e0bffd17 	ldw	r2,-12(fp)
811489d8:	10801817 	ldw	r2,96(r2)
811489dc:	e0bff815 	stw	r2,-32(fp)
811489e0:	e03ffc0d 	sth	zero,-16(fp)
811489e4:	e0bffc0b 	ldhu	r2,-16(fp)
811489e8:	e0fffc84 	addi	r3,fp,-14
811489ec:	180d883a 	mov	r6,r3
811489f0:	100b883a 	mov	r5,r2
811489f4:	e13ff817 	ldw	r4,-32(fp)
811489f8:	113eb180 	call	8113eb18 <OSSemPend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811489fc:	0005303a 	rdctl	r2,status
81148a00:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81148a04:	e0fffb17 	ldw	r3,-20(fp)
81148a08:	00bfff84 	movi	r2,-2
81148a0c:	1884703a 	and	r2,r3,r2
81148a10:	1001703a 	wrctl	status,r2
  
  return context;
81148a14:	e0bffb17 	ldw	r2,-20(fp)
    
    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();
81148a18:	e0bff515 	stw	r2,-44(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
81148a1c:	e0bffd17 	ldw	r2,-12(fp)
81148a20:	10800317 	ldw	r2,12(r2)
81148a24:	10800104 	addi	r2,r2,4
81148a28:	00c00804 	movi	r3,32
81148a2c:	10c00035 	stwio	r3,0(r2)
        ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
81148a30:	e0bffd17 	ldw	r2,-12(fp)
81148a34:	10800317 	ldw	r2,12(r2)
81148a38:	e0fffd17 	ldw	r3,-12(fp)
81148a3c:	18c00317 	ldw	r3,12(r3)
81148a40:	18c00037 	ldwio	r3,0(r3)
81148a44:	10c00035 	stwio	r3,0(r2)
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
81148a48:	e0bffe17 	ldw	r2,-8(fp)
81148a4c:	10001f26 	beq	r2,zero,81148acc <alt_msgdma_descriptor_sync_transfer+0x1ec>
81148a50:	e0bfff17 	ldw	r2,-4(fp)
81148a54:	10001d1e 	bne	r2,zero,81148acc <alt_msgdma_descriptor_sync_transfer+0x1ec>
    {
        counter = 0; /* reset counter */
81148a58:	e03ff10d 	sth	zero,-60(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
81148a5c:	00001106 	br	81148aa4 <alt_msgdma_descriptor_sync_transfer+0x1c4>
			dev->csr_base, dev->descriptor_base, standard_desc))
        {     
            alt_busy_sleep(1); /* delay 1us */
81148a60:	01000044 	movi	r4,1
81148a64:	11362a00 	call	811362a0 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81148a68:	e0bff10b 	ldhu	r2,-60(fp)
81148a6c:	1084e230 	cmpltui	r2,r2,5000
81148a70:	1000091e 	bne	r2,zero,81148a98 <alt_msgdma_descriptor_sync_transfer+0x1b8>
            {
                alt_printf("time out after 5 msec while writing standard" 
81148a74:	01204574 	movhi	r4,33045
81148a78:	21055404 	addi	r4,r4,5456
81148a7c:	114a9f40 	call	8114a9f4 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
81148a80:	e0bffd17 	ldw	r2,-12(fp)
81148a84:	10801817 	ldw	r2,96(r2)
81148a88:	1009883a 	mov	r4,r2
81148a8c:	113eea00 	call	8113eea0 <OSSemPost>
				
                return -ETIME;
81148a90:	00bff084 	movi	r2,-62
81148a94:	00008f06 	br	81148cd4 <alt_msgdma_descriptor_sync_transfer+0x3f4>
            }
            counter++;    
81148a98:	e0bff10b 	ldhu	r2,-60(fp)
81148a9c:	10800044 	addi	r2,r2,1
81148aa0:	e0bff10d 	sth	r2,-60(fp)
    if (NULL != standard_desc && NULL == extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
81148aa4:	e0bffd17 	ldw	r2,-12(fp)
81148aa8:	10c00317 	ldw	r3,12(r2)
81148aac:	e0bffd17 	ldw	r2,-12(fp)
81148ab0:	10800417 	ldw	r2,16(r2)
81148ab4:	e1bffe17 	ldw	r6,-8(fp)
81148ab8:	100b883a 	mov	r5,r2
81148abc:	1809883a 	mov	r4,r3
81148ac0:	11480540 	call	81148054 <alt_msgdma_write_standard_descriptor>
81148ac4:	103fe61e 	bne	r2,zero,81148a60 <__reset+0xfb128a60>
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
81148ac8:	00002706 	br	81148b68 <alt_msgdma_descriptor_sync_transfer+0x288>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
81148acc:	e0bffe17 	ldw	r2,-8(fp)
81148ad0:	10001f1e 	bne	r2,zero,81148b50 <alt_msgdma_descriptor_sync_transfer+0x270>
81148ad4:	e0bfff17 	ldw	r2,-4(fp)
81148ad8:	10001d26 	beq	r2,zero,81148b50 <alt_msgdma_descriptor_sync_transfer+0x270>
    {
        counter = 0; /* reset counter */
81148adc:	e03ff10d 	sth	zero,-60(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
81148ae0:	00001106 	br	81148b28 <alt_msgdma_descriptor_sync_transfer+0x248>
			dev->csr_base, dev->descriptor_base, extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
81148ae4:	01000044 	movi	r4,1
81148ae8:	11362a00 	call	811362a0 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81148aec:	e0bff10b 	ldhu	r2,-60(fp)
81148af0:	1084e230 	cmpltui	r2,r2,5000
81148af4:	1000091e 	bne	r2,zero,81148b1c <alt_msgdma_descriptor_sync_transfer+0x23c>
            {
                alt_printf("time out after 5 msec while writing extended" 
81148af8:	01204574 	movhi	r4,33045
81148afc:	21056504 	addi	r4,r4,5524
81148b00:	114a9f40 	call	8114a9f4 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
81148b04:	e0bffd17 	ldw	r2,-12(fp)
81148b08:	10801817 	ldw	r2,96(r2)
81148b0c:	1009883a 	mov	r4,r2
81148b10:	113eea00 	call	8113eea0 <OSSemPost>
				
                return -ETIME;
81148b14:	00bff084 	movi	r2,-62
81148b18:	00006e06 	br	81148cd4 <alt_msgdma_descriptor_sync_transfer+0x3f4>
            }
            counter++;
81148b1c:	e0bff10b 	ldhu	r2,-60(fp)
81148b20:	10800044 	addi	r2,r2,1
81148b24:	e0bff10d 	sth	r2,-60(fp)
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
81148b28:	e0bffd17 	ldw	r2,-12(fp)
81148b2c:	10c00317 	ldw	r3,12(r2)
81148b30:	e0bffd17 	ldw	r2,-12(fp)
81148b34:	10800417 	ldw	r2,16(r2)
81148b38:	e1bfff17 	ldw	r6,-4(fp)
81148b3c:	100b883a 	mov	r5,r2
81148b40:	1809883a 	mov	r4,r3
81148b44:	11480f00 	call	811480f0 <alt_msgdma_write_extended_descriptor>
81148b48:	103fe61e 	bne	r2,zero,81148ae4 <__reset+0xfb128ae4>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
81148b4c:	00000606 	br	81148b68 <alt_msgdma_descriptor_sync_transfer+0x288>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
81148b50:	e0bffd17 	ldw	r2,-12(fp)
81148b54:	10801817 	ldw	r2,96(r2)
81148b58:	1009883a 	mov	r4,r2
81148b5c:	113eea00 	call	8113eea0 <OSSemPost>
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
81148b60:	00bfffc4 	movi	r2,-1
81148b64:	00005b06 	br	81148cd4 <alt_msgdma_descriptor_sync_transfer+0x3f4>
    * Set up msgdma controller to:
    * - Disable interrupt generation
    * - Run once a valid descriptor is written to controller
    * - Stop on an error with any particular descriptor
    */
     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
81148b68:	e0bffd17 	ldw	r2,-12(fp)
81148b6c:	10800317 	ldw	r2,12(r2)
81148b70:	10800104 	addi	r2,r2,4
81148b74:	e0fffd17 	ldw	r3,-12(fp)
81148b78:	19000d17 	ldw	r4,52(r3)
81148b7c:	00fff2c4 	movi	r3,-53
81148b80:	20c6703a 	and	r3,r4,r3
81148b84:	18c00114 	ori	r3,r3,4
81148b88:	10c00035 	stwio	r3,0(r2)
81148b8c:	e0bff517 	ldw	r2,-44(fp)
81148b90:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81148b94:	e0bff717 	ldw	r2,-36(fp)
81148b98:	1001703a 	wrctl	status,r2
		(~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
		(~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK)) ;
	 
	alt_irq_enable_all(context);
     
    counter = 0; /* reset counter */ 
81148b9c:	e03ff10d 	sth	zero,-60(fp)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
81148ba0:	e0bffd17 	ldw	r2,-12(fp)
81148ba4:	10800317 	ldw	r2,12(r2)
81148ba8:	10800037 	ldwio	r2,0(r2)
81148bac:	e0bff015 	stw	r2,-64(fp)
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
81148bb0:	00001506 	br	81148c08 <alt_msgdma_descriptor_sync_transfer+0x328>
    {
        alt_busy_sleep(1); /* delay 1us */
81148bb4:	01000044 	movi	r4,1
81148bb8:	11362a00 	call	811362a0 <alt_busy_sleep>
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81148bbc:	e0bff10b 	ldhu	r2,-60(fp)
81148bc0:	1084e230 	cmpltui	r2,r2,5000
81148bc4:	1000091e 	bne	r2,zero,81148bec <alt_msgdma_descriptor_sync_transfer+0x30c>
        {
            alt_printf("time out after 5 msec while waiting for any pending" 
81148bc8:	01204574 	movhi	r4,33045
81148bcc:	21057604 	addi	r4,r4,5592
81148bd0:	114a9f40 	call	8114a9f4 <alt_printf>
			
			/*
			* Now that access to the registers is complete, release the registers
			* semaphore so that other threads can access the registers.
			*/
			ALT_SEM_POST (dev->regs_lock);
81148bd4:	e0bffd17 	ldw	r2,-12(fp)
81148bd8:	10801817 	ldw	r2,96(r2)
81148bdc:	1009883a 	mov	r4,r2
81148be0:	113eea00 	call	8113eea0 <OSSemPost>
			
            return -ETIME;
81148be4:	00bff084 	movi	r2,-62
81148be8:	00003a06 	br	81148cd4 <alt_msgdma_descriptor_sync_transfer+0x3f4>
        }
        counter++;
81148bec:	e0bff10b 	ldhu	r2,-60(fp)
81148bf0:	10800044 	addi	r2,r2,1
81148bf4:	e0bff10d 	sth	r2,-60(fp)
        csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
81148bf8:	e0bffd17 	ldw	r2,-12(fp)
81148bfc:	10800317 	ldw	r2,12(r2)
81148c00:	10800037 	ldwio	r2,0(r2)
81148c04:	e0bff015 	stw	r2,-64(fp)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
81148c08:	e0fff017 	ldw	r3,-64(fp)
81148c0c:	e0bff617 	ldw	r2,-40(fp)
81148c10:	1884703a 	and	r2,r3,r2
81148c14:	1000031e 	bne	r2,zero,81148c24 <alt_msgdma_descriptor_sync_transfer+0x344>
81148c18:	e0bff017 	ldw	r2,-64(fp)
81148c1c:	1080004c 	andi	r2,r2,1
81148c20:	103fe41e 	bne	r2,zero,81148bb4 <__reset+0xfb128bb4>
    }
    

    /*Errors or conditions causing the dispatcher stopping issuing read/write 
      commands to masters*/
    if(0 != (csr_status & error))
81148c24:	e0fff017 	ldw	r3,-64(fp)
81148c28:	e0bff617 	ldw	r2,-40(fp)
81148c2c:	1884703a 	and	r2,r3,r2
81148c30:	10000626 	beq	r2,zero,81148c4c <alt_msgdma_descriptor_sync_transfer+0x36c>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
81148c34:	e0bffd17 	ldw	r2,-12(fp)
81148c38:	10801817 	ldw	r2,96(r2)
81148c3c:	1009883a 	mov	r4,r2
81148c40:	113eea00 	call	8113eea0 <OSSemPost>
		
        return error;
81148c44:	e0bff617 	ldw	r2,-40(fp)
81148c48:	00002206 	br	81148cd4 <alt_msgdma_descriptor_sync_transfer+0x3f4>
    }

    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* stop issuing more descriptors */
    control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) | 
81148c4c:	e0bffd17 	ldw	r2,-12(fp)
81148c50:	10800317 	ldw	r2,12(r2)
81148c54:	10800104 	addi	r2,r2,4
81148c58:	10800037 	ldwio	r2,0(r2)
81148c5c:	10800814 	ori	r2,r2,32
81148c60:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81148c64:	0005303a 	rdctl	r2,status
81148c68:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81148c6c:	e0fffa17 	ldw	r3,-24(fp)
81148c70:	00bfff84 	movi	r2,-2
81148c74:	1884703a 	and	r2,r3,r2
81148c78:	1001703a 	wrctl	status,r2
  
  return context;
81148c7c:	e0bffa17 	ldw	r2,-24(fp)
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();  
81148c80:	e0bff515 	stw	r2,-44(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81148c84:	e0bffd17 	ldw	r2,-12(fp)
81148c88:	10800317 	ldw	r2,12(r2)
81148c8c:	10800104 	addi	r2,r2,4
81148c90:	e0fff417 	ldw	r3,-48(fp)
81148c94:	10c00035 	stwio	r3,0(r2)
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
81148c98:	e0bffd17 	ldw	r2,-12(fp)
81148c9c:	10800317 	ldw	r2,12(r2)
81148ca0:	e0fffd17 	ldw	r3,-12(fp)
81148ca4:	18c00317 	ldw	r3,12(r3)
81148ca8:	18c00037 	ldwio	r3,0(r3)
81148cac:	10c00035 	stwio	r3,0(r2)
81148cb0:	e0bff517 	ldw	r2,-44(fp)
81148cb4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81148cb8:	e0bff917 	ldw	r2,-28(fp)
81148cbc:	1001703a 	wrctl	status,r2

	/*
	* Now that access to the registers is complete, release the registers
	* semaphore so that other threads can access the registers.
	*/
    ALT_SEM_POST (dev->regs_lock);
81148cc0:	e0bffd17 	ldw	r2,-12(fp)
81148cc4:	10801817 	ldw	r2,96(r2)
81148cc8:	1009883a 	mov	r4,r2
81148ccc:	113eea00 	call	8113eea0 <OSSemPost>
    
    return 0;
81148cd0:	0005883a 	mov	r2,zero

}
81148cd4:	e037883a 	mov	sp,fp
81148cd8:	dfc00117 	ldw	ra,4(sp)
81148cdc:	df000017 	ldw	fp,0(sp)
81148ce0:	dec00204 	addi	sp,sp,8
81148ce4:	f800283a 	ret

81148ce8 <alt_msgdma_construct_standard_st_to_mm_descriptor>:
 */
int alt_msgdma_construct_standard_st_to_mm_descriptor (
    alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *write_address, alt_u32 length, alt_u32 control)
{
81148ce8:	defff804 	addi	sp,sp,-32
81148cec:	de00012e 	bgeu	sp,et,81148cf4 <alt_msgdma_construct_standard_st_to_mm_descriptor+0xc>
81148cf0:	003b68fa 	trap	3
81148cf4:	dfc00715 	stw	ra,28(sp)
81148cf8:	df000615 	stw	fp,24(sp)
81148cfc:	df000604 	addi	fp,sp,24
81148d00:	e13ffc15 	stw	r4,-16(fp)
81148d04:	e17ffd15 	stw	r5,-12(fp)
81148d08:	e1bffe15 	stw	r6,-8(fp)
81148d0c:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, NULL, 
81148d10:	e0800217 	ldw	r2,8(fp)
81148d14:	d8800115 	stw	r2,4(sp)
81148d18:	e0bfff17 	ldw	r2,-4(fp)
81148d1c:	d8800015 	stw	r2,0(sp)
81148d20:	e1fffe17 	ldw	r7,-8(fp)
81148d24:	000d883a 	mov	r6,zero
81148d28:	e17ffd17 	ldw	r5,-12(fp)
81148d2c:	e13ffc17 	ldw	r4,-16(fp)
81148d30:	11483b00 	call	811483b0 <alt_msgdma_construct_standard_descriptor>
            write_address, length, control);
}
81148d34:	e037883a 	mov	sp,fp
81148d38:	dfc00117 	ldw	ra,4(sp)
81148d3c:	df000017 	ldw	fp,0(sp)
81148d40:	dec00204 	addi	sp,sp,8
81148d44:	f800283a 	ret

81148d48 <alt_msgdma_construct_standard_mm_to_st_descriptor>:
    alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address,
	alt_u32 length,
	alt_u32 control)
{
81148d48:	defff804 	addi	sp,sp,-32
81148d4c:	de00012e 	bgeu	sp,et,81148d54 <alt_msgdma_construct_standard_mm_to_st_descriptor+0xc>
81148d50:	003b68fa 	trap	3
81148d54:	dfc00715 	stw	ra,28(sp)
81148d58:	df000615 	stw	fp,24(sp)
81148d5c:	df000604 	addi	fp,sp,24
81148d60:	e13ffc15 	stw	r4,-16(fp)
81148d64:	e17ffd15 	stw	r5,-12(fp)
81148d68:	e1bffe15 	stw	r6,-8(fp)
81148d6c:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
81148d70:	e0800217 	ldw	r2,8(fp)
81148d74:	d8800115 	stw	r2,4(sp)
81148d78:	e0bfff17 	ldw	r2,-4(fp)
81148d7c:	d8800015 	stw	r2,0(sp)
81148d80:	000f883a 	mov	r7,zero
81148d84:	e1bffe17 	ldw	r6,-8(fp)
81148d88:	e17ffd17 	ldw	r5,-12(fp)
81148d8c:	e13ffc17 	ldw	r4,-16(fp)
81148d90:	11483b00 	call	811483b0 <alt_msgdma_construct_standard_descriptor>
            NULL, length, control);

}
81148d94:	e037883a 	mov	sp,fp
81148d98:	dfc00117 	ldw	ra,4(sp)
81148d9c:	df000017 	ldw	fp,0(sp)
81148da0:	dec00204 	addi	sp,sp,8
81148da4:	f800283a 	ret

81148da8 <alt_msgdma_construct_standard_mm_to_mm_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81148da8:	defff804 	addi	sp,sp,-32
81148dac:	de00012e 	bgeu	sp,et,81148db4 <alt_msgdma_construct_standard_mm_to_mm_descriptor+0xc>
81148db0:	003b68fa 	trap	3
81148db4:	dfc00715 	stw	ra,28(sp)
81148db8:	df000615 	stw	fp,24(sp)
81148dbc:	df000604 	addi	fp,sp,24
81148dc0:	e13ffc15 	stw	r4,-16(fp)
81148dc4:	e17ffd15 	stw	r5,-12(fp)
81148dc8:	e1bffe15 	stw	r6,-8(fp)
81148dcc:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
81148dd0:	e0800317 	ldw	r2,12(fp)
81148dd4:	d8800115 	stw	r2,4(sp)
81148dd8:	e0800217 	ldw	r2,8(fp)
81148ddc:	d8800015 	stw	r2,0(sp)
81148de0:	e1ffff17 	ldw	r7,-4(fp)
81148de4:	e1bffe17 	ldw	r6,-8(fp)
81148de8:	e17ffd17 	ldw	r5,-12(fp)
81148dec:	e13ffc17 	ldw	r4,-16(fp)
81148df0:	11483b00 	call	811483b0 <alt_msgdma_construct_standard_descriptor>
            write_address, length, control);
}
81148df4:	e037883a 	mov	sp,fp
81148df8:	dfc00117 	ldw	ra,4(sp)
81148dfc:	df000017 	ldw	fp,0(sp)
81148e00:	dec00204 	addi	sp,sp,8
81148e04:	f800283a 	ret

81148e08 <alt_msgdma_construct_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 write_burst_count, 
	alt_u16 write_stride)
{
81148e08:	defff004 	addi	sp,sp,-64
81148e0c:	de00012e 	bgeu	sp,et,81148e14 <alt_msgdma_construct_extended_st_to_mm_descriptor+0xc>
81148e10:	003b68fa 	trap	3
81148e14:	dfc00f15 	stw	ra,60(sp)
81148e18:	df000e15 	stw	fp,56(sp)
81148e1c:	df000e04 	addi	fp,sp,56
81148e20:	e13ff915 	stw	r4,-28(fp)
81148e24:	e17ffa15 	stw	r5,-24(fp)
81148e28:	e1bffb15 	stw	r6,-20(fp)
81148e2c:	e1fffc15 	stw	r7,-16(fp)
81148e30:	e1000317 	ldw	r4,12(fp)
81148e34:	e0c00417 	ldw	r3,16(fp)
81148e38:	e0800517 	ldw	r2,20(fp)
81148e3c:	e13ffd0d 	sth	r4,-12(fp)
81148e40:	e0fffe05 	stb	r3,-8(fp)
81148e44:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
81148e48:	e0bffd0b 	ldhu	r2,-12(fp)
81148e4c:	e0fffe03 	ldbu	r3,-8(fp)
81148e50:	e13fff0b 	ldhu	r4,-4(fp)
81148e54:	d9000615 	stw	r4,24(sp)
81148e58:	d8000515 	stw	zero,20(sp)
81148e5c:	d8c00415 	stw	r3,16(sp)
81148e60:	d8000315 	stw	zero,12(sp)
81148e64:	d8800215 	stw	r2,8(sp)
81148e68:	e0800217 	ldw	r2,8(fp)
81148e6c:	d8800115 	stw	r2,4(sp)
81148e70:	e0bffc17 	ldw	r2,-16(fp)
81148e74:	d8800015 	stw	r2,0(sp)
81148e78:	e1fffb17 	ldw	r7,-20(fp)
81148e7c:	000d883a 	mov	r6,zero
81148e80:	e17ffa17 	ldw	r5,-24(fp)
81148e84:	e13ff917 	ldw	r4,-28(fp)
81148e88:	11484440 	call	81148444 <alt_msgdma_construct_extended_descriptor>
            NULL, write_address, length, control, sequence_number, 0, 
            write_burst_count, 0, write_stride);
}
81148e8c:	e037883a 	mov	sp,fp
81148e90:	dfc00117 	ldw	ra,4(sp)
81148e94:	df000017 	ldw	fp,0(sp)
81148e98:	dec00204 	addi	sp,sp,8
81148e9c:	f800283a 	ret

81148ea0 <alt_msgdma_construct_extended_mm_to_st_descriptor>:
	alt_u32 length,
	alt_u32 control,
	alt_u16 sequence_number,
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
81148ea0:	defff004 	addi	sp,sp,-64
81148ea4:	de00012e 	bgeu	sp,et,81148eac <alt_msgdma_construct_extended_mm_to_st_descriptor+0xc>
81148ea8:	003b68fa 	trap	3
81148eac:	dfc00f15 	stw	ra,60(sp)
81148eb0:	df000e15 	stw	fp,56(sp)
81148eb4:	df000e04 	addi	fp,sp,56
81148eb8:	e13ff915 	stw	r4,-28(fp)
81148ebc:	e17ffa15 	stw	r5,-24(fp)
81148ec0:	e1bffb15 	stw	r6,-20(fp)
81148ec4:	e1fffc15 	stw	r7,-16(fp)
81148ec8:	e1000317 	ldw	r4,12(fp)
81148ecc:	e0c00417 	ldw	r3,16(fp)
81148ed0:	e0800517 	ldw	r2,20(fp)
81148ed4:	e13ffd0d 	sth	r4,-12(fp)
81148ed8:	e0fffe05 	stb	r3,-8(fp)
81148edc:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, read_address, 
81148ee0:	e0bffd0b 	ldhu	r2,-12(fp)
81148ee4:	e0fffe03 	ldbu	r3,-8(fp)
81148ee8:	e13fff0b 	ldhu	r4,-4(fp)
81148eec:	d8000615 	stw	zero,24(sp)
81148ef0:	d9000515 	stw	r4,20(sp)
81148ef4:	d8000415 	stw	zero,16(sp)
81148ef8:	d8c00315 	stw	r3,12(sp)
81148efc:	d8800215 	stw	r2,8(sp)
81148f00:	e0800217 	ldw	r2,8(fp)
81148f04:	d8800115 	stw	r2,4(sp)
81148f08:	e0bffc17 	ldw	r2,-16(fp)
81148f0c:	d8800015 	stw	r2,0(sp)
81148f10:	000f883a 	mov	r7,zero
81148f14:	e1bffb17 	ldw	r6,-20(fp)
81148f18:	e17ffa17 	ldw	r5,-24(fp)
81148f1c:	e13ff917 	ldw	r4,-28(fp)
81148f20:	11484440 	call	81148444 <alt_msgdma_construct_extended_descriptor>
            NULL, length, control, sequence_number, read_burst_count, 0, 
            read_stride, 0);

}
81148f24:	e037883a 	mov	sp,fp
81148f28:	dfc00117 	ldw	ra,4(sp)
81148f2c:	df000017 	ldw	fp,0(sp)
81148f30:	dec00204 	addi	sp,sp,8
81148f34:	f800283a 	ret

81148f38 <alt_msgdma_construct_extended_mm_to_mm_descriptor>:
    alt_u16 sequence_number, 
    alt_u8 read_burst_count, 
    alt_u8 write_burst_count,
    alt_u16 read_stride, 
    alt_u16 write_stride)
{
81148f38:	deffee04 	addi	sp,sp,-72
81148f3c:	de00012e 	bgeu	sp,et,81148f44 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0xc>
81148f40:	003b68fa 	trap	3
81148f44:	dfc01115 	stw	ra,68(sp)
81148f48:	df001015 	stw	fp,64(sp)
81148f4c:	df001004 	addi	fp,sp,64
81148f50:	e13ff715 	stw	r4,-36(fp)
81148f54:	e17ff815 	stw	r5,-32(fp)
81148f58:	e1bff915 	stw	r6,-28(fp)
81148f5c:	e1fffa15 	stw	r7,-24(fp)
81148f60:	e1800417 	ldw	r6,16(fp)
81148f64:	e1400517 	ldw	r5,20(fp)
81148f68:	e1000617 	ldw	r4,24(fp)
81148f6c:	e0c00717 	ldw	r3,28(fp)
81148f70:	e0800817 	ldw	r2,32(fp)
81148f74:	e1bffb0d 	sth	r6,-20(fp)
81148f78:	e17ffc05 	stb	r5,-16(fp)
81148f7c:	e13ffd05 	stb	r4,-12(fp)
81148f80:	e0fffe0d 	sth	r3,-8(fp)
81148f84:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
81148f88:	e0bffb0b 	ldhu	r2,-20(fp)
81148f8c:	e0fffc03 	ldbu	r3,-16(fp)
81148f90:	e13ffd03 	ldbu	r4,-12(fp)
81148f94:	e17ffe0b 	ldhu	r5,-8(fp)
81148f98:	e1bfff0b 	ldhu	r6,-4(fp)
81148f9c:	d9800615 	stw	r6,24(sp)
81148fa0:	d9400515 	stw	r5,20(sp)
81148fa4:	d9000415 	stw	r4,16(sp)
81148fa8:	d8c00315 	stw	r3,12(sp)
81148fac:	d8800215 	stw	r2,8(sp)
81148fb0:	e0800317 	ldw	r2,12(fp)
81148fb4:	d8800115 	stw	r2,4(sp)
81148fb8:	e0800217 	ldw	r2,8(fp)
81148fbc:	d8800015 	stw	r2,0(sp)
81148fc0:	e1fffa17 	ldw	r7,-24(fp)
81148fc4:	e1bff917 	ldw	r6,-28(fp)
81148fc8:	e17ff817 	ldw	r5,-32(fp)
81148fcc:	e13ff717 	ldw	r4,-36(fp)
81148fd0:	11484440 	call	81148444 <alt_msgdma_construct_extended_descriptor>
            read_address, write_address, length, control, sequence_number, 
            read_burst_count, write_burst_count, read_stride, write_stride);

}
81148fd4:	e037883a 	mov	sp,fp
81148fd8:	dfc00117 	ldw	ra,4(sp)
81148fdc:	df000017 	ldw	fp,0(sp)
81148fe0:	dec00204 	addi	sp,sp,8
81148fe4:	f800283a 	ret

81148fe8 <alt_msgdma_construct_prefetcher_standard_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81148fe8:	defffb04 	addi	sp,sp,-20
81148fec:	de00012e 	bgeu	sp,et,81148ff4 <alt_msgdma_construct_prefetcher_standard_descriptor+0xc>
81148ff0:	003b68fa 	trap	3
81148ff4:	df000415 	stw	fp,16(sp)
81148ff8:	df000404 	addi	fp,sp,16
81148ffc:	e13ffc15 	stw	r4,-16(fp)
81149000:	e17ffd15 	stw	r5,-12(fp)
81149004:	e1bffe15 	stw	r6,-8(fp)
81149008:	e1ffff15 	stw	r7,-4(fp)
    if(dev->max_byte < length ||
8114900c:	e0bffc17 	ldw	r2,-16(fp)
81149010:	10c01217 	ldw	r3,72(r2)
81149014:	e0800117 	ldw	r2,4(fp)
81149018:	18800436 	bltu	r3,r2,8114902c <alt_msgdma_construct_prefetcher_standard_descriptor+0x44>
       dev->enhanced_features != 0
8114901c:	e0bffc17 	ldw	r2,-16(fp)
81149020:	10801703 	ldbu	r2,92(r2)
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
81149024:	10803fcc 	andi	r2,r2,255
81149028:	10000226 	beq	r2,zero,81149034 <alt_msgdma_construct_prefetcher_standard_descriptor+0x4c>
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
8114902c:	00bffa84 	movi	r2,-22
81149030:	00001406 	br	81149084 <alt_msgdma_construct_prefetcher_standard_descriptor+0x9c>
    }
    descriptor->read_address = read_address;
81149034:	e0bffd17 	ldw	r2,-12(fp)
81149038:	e0fffe17 	ldw	r3,-8(fp)
8114903c:	10c00015 	stw	r3,0(r2)
    descriptor->write_address = write_address;
81149040:	e0bffd17 	ldw	r2,-12(fp)
81149044:	e0ffff17 	ldw	r3,-4(fp)
81149048:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
8114904c:	e0bffd17 	ldw	r2,-12(fp)
81149050:	e0c00117 	ldw	r3,4(fp)
81149054:	10c00215 	stw	r3,8(r2)
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
81149058:	e0fffd17 	ldw	r3,-12(fp)
8114905c:	e0bffd17 	ldw	r2,-12(fp)
81149060:	10c00315 	stw	r3,12(r2)
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81149064:	e0c00217 	ldw	r3,8(fp)
81149068:	00900034 	movhi	r2,16384
8114906c:	10bfffc4 	addi	r2,r2,-1
81149070:	1884703a 	and	r2,r3,r2
81149074:	10e00034 	orhi	r3,r2,32768
    descriptor->transfer_length = length;
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
81149078:	e0bffd17 	ldw	r2,-12(fp)
8114907c:	10c00715 	stw	r3,28(r2)
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
81149080:	0005883a 	mov	r2,zero
}
81149084:	e037883a 	mov	sp,fp
81149088:	df000017 	ldw	fp,0(sp)
8114908c:	dec00104 	addi	sp,sp,4
81149090:	f800283a 	ret

81149094 <alt_msgdma_construct_prefetcher_extended_descriptor>:
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
81149094:	defff404 	addi	sp,sp,-48
81149098:	de00012e 	bgeu	sp,et,811490a0 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc>
8114909c:	003b68fa 	trap	3
811490a0:	df000b15 	stw	fp,44(sp)
811490a4:	df000b04 	addi	fp,sp,44
811490a8:	e13ff715 	stw	r4,-36(fp)
811490ac:	e17ff815 	stw	r5,-32(fp)
811490b0:	e1bff915 	stw	r6,-28(fp)
811490b4:	e1fffa15 	stw	r7,-24(fp)
811490b8:	e1800517 	ldw	r6,20(fp)
811490bc:	e1400617 	ldw	r5,24(fp)
811490c0:	e1000717 	ldw	r4,28(fp)
811490c4:	e0c00817 	ldw	r3,32(fp)
811490c8:	e0800917 	ldw	r2,36(fp)
811490cc:	e1bffb0d 	sth	r6,-20(fp)
811490d0:	e17ffc05 	stb	r5,-16(fp)
811490d4:	e13ffd05 	stb	r4,-12(fp)
811490d8:	e0fffe0d 	sth	r3,-8(fp)
811490dc:	e0bfff0d 	sth	r2,-4(fp)
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
811490e0:	e0bff717 	ldw	r2,-36(fp)
811490e4:	10c01217 	ldw	r3,72(r2)
811490e8:	e0800317 	ldw	r2,12(fp)
811490ec:	18801936 	bltu	r3,r2,81149154 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
811490f0:	e13ff717 	ldw	r4,-36(fp)
811490f4:	20801317 	ldw	r2,76(r4)
811490f8:	20c01417 	ldw	r3,80(r4)
811490fc:	e13ffe0b 	ldhu	r4,-8(fp)
81149100:	213fffcc 	andi	r4,r4,65535
81149104:	2015883a 	mov	r10,r4
81149108:	0017883a 	mov	r11,zero
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
8114910c:	1ac01136 	bltu	r3,r11,81149154 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
81149110:	58c0011e 	bne	r11,r3,81149118 <alt_msgdma_construct_prefetcher_extended_descriptor+0x84>
81149114:	12800f36 	bltu	r2,r10,81149154 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
81149118:	e13ff717 	ldw	r4,-36(fp)
8114911c:	20801317 	ldw	r2,76(r4)
81149120:	20c01417 	ldw	r3,80(r4)
81149124:	e13fff0b 	ldhu	r4,-4(fp)
81149128:	213fffcc 	andi	r4,r4,65535
8114912c:	2011883a 	mov	r8,r4
81149130:	0013883a 	mov	r9,zero
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
81149134:	1a400736 	bltu	r3,r9,81149154 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
81149138:	48c0011e 	bne	r9,r3,81149140 <alt_msgdma_construct_prefetcher_extended_descriptor+0xac>
8114913c:	12000536 	bltu	r2,r8,81149154 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
81149140:	e0bff717 	ldw	r2,-36(fp)
81149144:	10801703 	ldbu	r2,92(r2)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
81149148:	10803fcc 	andi	r2,r2,255
8114914c:	10800060 	cmpeqi	r2,r2,1
81149150:	1000021e 	bne	r2,zero,8114915c <alt_msgdma_construct_prefetcher_extended_descriptor+0xc8>
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
81149154:	00bffa84 	movi	r2,-22
81149158:	00003106 	br	81149220 <alt_msgdma_construct_prefetcher_extended_descriptor+0x18c>
    }
    
    descriptor->read_address_high = read_address_high;
8114915c:	e0bff817 	ldw	r2,-32(fp)
81149160:	e0fff917 	ldw	r3,-28(fp)
81149164:	10c00915 	stw	r3,36(r2)
    descriptor->read_address_low = read_address_low;
81149168:	e0bff817 	ldw	r2,-32(fp)
8114916c:	e0fffa17 	ldw	r3,-24(fp)
81149170:	10c00015 	stw	r3,0(r2)
    descriptor->write_address_high = write_address_high;
81149174:	e0bff817 	ldw	r2,-32(fp)
81149178:	e0c00117 	ldw	r3,4(fp)
8114917c:	10c00a15 	stw	r3,40(r2)
    descriptor->write_address_low = write_address_low;
81149180:	e0bff817 	ldw	r2,-32(fp)
81149184:	e0c00217 	ldw	r3,8(fp)
81149188:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
8114918c:	e0bff817 	ldw	r2,-32(fp)
81149190:	e0c00317 	ldw	r3,12(fp)
81149194:	10c00215 	stw	r3,8(r2)
    descriptor->sequence_number = sequence_number;
81149198:	e0bff817 	ldw	r2,-32(fp)
8114919c:	e0fffb0b 	ldhu	r3,-20(fp)
811491a0:	10c0070d 	sth	r3,28(r2)
    descriptor->read_burst_count = read_burst_count;
811491a4:	e0bff817 	ldw	r2,-32(fp)
811491a8:	e0fffc03 	ldbu	r3,-16(fp)
811491ac:	10c00785 	stb	r3,30(r2)
    descriptor->write_burst_count = write_burst_count;
811491b0:	e0bff817 	ldw	r2,-32(fp)
811491b4:	e0fffd03 	ldbu	r3,-12(fp)
811491b8:	10c007c5 	stb	r3,31(r2)
    descriptor->read_stride = read_stride;
811491bc:	e0bff817 	ldw	r2,-32(fp)
811491c0:	e0fffe0b 	ldhu	r3,-8(fp)
811491c4:	10c0080d 	sth	r3,32(r2)
    descriptor->write_stride = write_stride;
811491c8:	e0bff817 	ldw	r2,-32(fp)
811491cc:	e0ffff0b 	ldhu	r3,-4(fp)
811491d0:	10c0088d 	sth	r3,34(r2)
    /* have descriptor point to itself */
	node_addr.u64 = (uintptr_t)descriptor;
811491d4:	e0bff817 	ldw	r2,-32(fp)
811491d8:	1019883a 	mov	r12,r2
811491dc:	001b883a 	mov	r13,zero
811491e0:	e33ff515 	stw	r12,-44(fp)
811491e4:	e37ff615 	stw	r13,-40(fp)
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
811491e8:	e0fff517 	ldw	r3,-44(fp)
811491ec:	e0bff817 	ldw	r2,-32(fp)
811491f0:	10c00315 	stw	r3,12(r2)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
811491f4:	e0fff617 	ldw	r3,-40(fp)
811491f8:	e0bff817 	ldw	r2,-32(fp)
811491fc:	10c00b15 	stw	r3,44(r2)
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81149200:	e0c00417 	ldw	r3,16(fp)
81149204:	00900034 	movhi	r2,16384
81149208:	10bfffc4 	addi	r2,r2,-1
8114920c:	1884703a 	and	r2,r3,r2
81149210:	10e00034 	orhi	r3,r2,32768
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
81149214:	e0bff817 	ldw	r2,-32(fp)
81149218:	10c00f15 	stw	r3,60(r2)
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
8114921c:	0005883a 	mov	r2,zero
}
81149220:	e037883a 	mov	sp,fp
81149224:	df000017 	ldw	fp,0(sp)
81149228:	dec00104 	addi	sp,sp,4
8114922c:	f800283a 	ret

81149230 <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address,
	alt_u32 write_address,
	alt_u32 length,
	alt_u32 control)
{
81149230:	defff804 	addi	sp,sp,-32
81149234:	de00012e 	bgeu	sp,et,8114923c <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor+0xc>
81149238:	003b68fa 	trap	3
8114923c:	dfc00715 	stw	ra,28(sp)
81149240:	df000615 	stw	fp,24(sp)
81149244:	df000604 	addi	fp,sp,24
81149248:	e13ffc15 	stw	r4,-16(fp)
8114924c:	e17ffd15 	stw	r5,-12(fp)
81149250:	e1bffe15 	stw	r6,-8(fp)
81149254:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
81149258:	e0800317 	ldw	r2,12(fp)
8114925c:	d8800115 	stw	r2,4(sp)
81149260:	e0800217 	ldw	r2,8(fp)
81149264:	d8800015 	stw	r2,0(sp)
81149268:	e1ffff17 	ldw	r7,-4(fp)
8114926c:	e1bffe17 	ldw	r6,-8(fp)
81149270:	e17ffd17 	ldw	r5,-12(fp)
81149274:	e13ffc17 	ldw	r4,-16(fp)
81149278:	1148fe80 	call	81148fe8 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		read_address, write_address, length, control);
}
8114927c:	e037883a 	mov	sp,fp
81149280:	dfc00117 	ldw	ra,4(sp)
81149284:	df000017 	ldw	fp,0(sp)
81149288:	dec00204 	addi	sp,sp,8
8114928c:	f800283a 	ret

81149290 <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor>:
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *descriptor, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81149290:	defff804 	addi	sp,sp,-32
81149294:	de00012e 	bgeu	sp,et,8114929c <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor+0xc>
81149298:	003b68fa 	trap	3
8114929c:	dfc00715 	stw	ra,28(sp)
811492a0:	df000615 	stw	fp,24(sp)
811492a4:	df000604 	addi	fp,sp,24
811492a8:	e13ffc15 	stw	r4,-16(fp)
811492ac:	e17ffd15 	stw	r5,-12(fp)
811492b0:	e1bffe15 	stw	r6,-8(fp)
811492b4:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
811492b8:	e0800217 	ldw	r2,8(fp)
811492bc:	d8800115 	stw	r2,4(sp)
811492c0:	e0bfff17 	ldw	r2,-4(fp)
811492c4:	d8800015 	stw	r2,0(sp)
811492c8:	e1fffe17 	ldw	r7,-8(fp)
811492cc:	000d883a 	mov	r6,zero
811492d0:	e17ffd17 	ldw	r5,-12(fp)
811492d4:	e13ffc17 	ldw	r4,-16(fp)
811492d8:	1148fe80 	call	81148fe8 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		0, write_address, length, control);
}
811492dc:	e037883a 	mov	sp,fp
811492e0:	dfc00117 	ldw	ra,4(sp)
811492e4:	df000017 	ldw	fp,0(sp)
811492e8:	dec00204 	addi	sp,sp,8
811492ec:	f800283a 	ret

811492f0 <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor>:
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *descriptor, 
	alt_u32 read_address, 
	alt_u32 length, 
	alt_u32 control)
{
811492f0:	defff804 	addi	sp,sp,-32
811492f4:	de00012e 	bgeu	sp,et,811492fc <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor+0xc>
811492f8:	003b68fa 	trap	3
811492fc:	dfc00715 	stw	ra,28(sp)
81149300:	df000615 	stw	fp,24(sp)
81149304:	df000604 	addi	fp,sp,24
81149308:	e13ffc15 	stw	r4,-16(fp)
8114930c:	e17ffd15 	stw	r5,-12(fp)
81149310:	e1bffe15 	stw	r6,-8(fp)
81149314:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
81149318:	e0800217 	ldw	r2,8(fp)
8114931c:	d8800115 	stw	r2,4(sp)
81149320:	e0bfff17 	ldw	r2,-4(fp)
81149324:	d8800015 	stw	r2,0(sp)
81149328:	000f883a 	mov	r7,zero
8114932c:	e1bffe17 	ldw	r6,-8(fp)
81149330:	e17ffd17 	ldw	r5,-12(fp)
81149334:	e13ffc17 	ldw	r4,-16(fp)
81149338:	1148fe80 	call	81148fe8 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		read_address, 0, length, control);
}
8114933c:	e037883a 	mov	sp,fp
81149340:	dfc00117 	ldw	ra,4(sp)
81149344:	df000017 	ldw	fp,0(sp)
81149348:	dec00204 	addi	sp,sp,8
8114934c:	f800283a 	ret

81149350 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number,
	alt_u8 write_burst_count,
	alt_u16 write_stride)
{
81149350:	deffee04 	addi	sp,sp,-72
81149354:	de00012e 	bgeu	sp,et,8114935c <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor+0xc>
81149358:	003b68fa 	trap	3
8114935c:	dfc01115 	stw	ra,68(sp)
81149360:	df001015 	stw	fp,64(sp)
81149364:	df001004 	addi	fp,sp,64
81149368:	e13ff915 	stw	r4,-28(fp)
8114936c:	e17ffa15 	stw	r5,-24(fp)
81149370:	e1bffb15 	stw	r6,-20(fp)
81149374:	e1fffc15 	stw	r7,-16(fp)
81149378:	e1000417 	ldw	r4,16(fp)
8114937c:	e0c00517 	ldw	r3,20(fp)
81149380:	e0800617 	ldw	r2,24(fp)
81149384:	e13ffd0d 	sth	r4,-12(fp)
81149388:	e0fffe05 	stb	r3,-8(fp)
8114938c:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor, 
81149390:	e0bffd0b 	ldhu	r2,-12(fp)
81149394:	e0fffe03 	ldbu	r3,-8(fp)
81149398:	e13fff0b 	ldhu	r4,-4(fp)
8114939c:	d9000815 	stw	r4,32(sp)
811493a0:	d8000715 	stw	zero,28(sp)
811493a4:	d8c00615 	stw	r3,24(sp)
811493a8:	d8000515 	stw	zero,20(sp)
811493ac:	d8800415 	stw	r2,16(sp)
811493b0:	e0800317 	ldw	r2,12(fp)
811493b4:	d8800315 	stw	r2,12(sp)
811493b8:	e0800217 	ldw	r2,8(fp)
811493bc:	d8800215 	stw	r2,8(sp)
811493c0:	e0bffc17 	ldw	r2,-16(fp)
811493c4:	d8800115 	stw	r2,4(sp)
811493c8:	e0bffb17 	ldw	r2,-20(fp)
811493cc:	d8800015 	stw	r2,0(sp)
811493d0:	000f883a 	mov	r7,zero
811493d4:	000d883a 	mov	r6,zero
811493d8:	e17ffa17 	ldw	r5,-24(fp)
811493dc:	e13ff917 	ldw	r4,-28(fp)
811493e0:	11490940 	call	81149094 <alt_msgdma_construct_prefetcher_extended_descriptor>
            0, 0, write_address_high, write_address_low, length, control, 
			sequence_number, 0, write_burst_count, 0, write_stride);
}
811493e4:	e037883a 	mov	sp,fp
811493e8:	dfc00117 	ldw	ra,4(sp)
811493ec:	df000017 	ldw	fp,0(sp)
811493f0:	dec00204 	addi	sp,sp,8
811493f4:	f800283a 	ret

811493f8 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
811493f8:	deffee04 	addi	sp,sp,-72
811493fc:	de00012e 	bgeu	sp,et,81149404 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor+0xc>
81149400:	003b68fa 	trap	3
81149404:	dfc01115 	stw	ra,68(sp)
81149408:	df001015 	stw	fp,64(sp)
8114940c:	df001004 	addi	fp,sp,64
81149410:	e13ff915 	stw	r4,-28(fp)
81149414:	e17ffa15 	stw	r5,-24(fp)
81149418:	e1bffb15 	stw	r6,-20(fp)
8114941c:	e1fffc15 	stw	r7,-16(fp)
81149420:	e1000417 	ldw	r4,16(fp)
81149424:	e0c00517 	ldw	r3,20(fp)
81149428:	e0800617 	ldw	r2,24(fp)
8114942c:	e13ffd0d 	sth	r4,-12(fp)
81149430:	e0fffe05 	stb	r3,-8(fp)
81149434:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
81149438:	e0bffd0b 	ldhu	r2,-12(fp)
8114943c:	e0fffe03 	ldbu	r3,-8(fp)
81149440:	e13fff0b 	ldhu	r4,-4(fp)
81149444:	d8000815 	stw	zero,32(sp)
81149448:	d9000715 	stw	r4,28(sp)
8114944c:	d8000615 	stw	zero,24(sp)
81149450:	d8c00515 	stw	r3,20(sp)
81149454:	d8800415 	stw	r2,16(sp)
81149458:	e0800317 	ldw	r2,12(fp)
8114945c:	d8800315 	stw	r2,12(sp)
81149460:	e0800217 	ldw	r2,8(fp)
81149464:	d8800215 	stw	r2,8(sp)
81149468:	d8000115 	stw	zero,4(sp)
8114946c:	d8000015 	stw	zero,0(sp)
81149470:	e1fffc17 	ldw	r7,-16(fp)
81149474:	e1bffb17 	ldw	r6,-20(fp)
81149478:	e17ffa17 	ldw	r5,-24(fp)
8114947c:	e13ff917 	ldw	r4,-28(fp)
81149480:	11490940 	call	81149094 <alt_msgdma_construct_prefetcher_extended_descriptor>
    		read_address_high, read_address_low, 0, 0, length, control, 
			sequence_number, read_burst_count, 0, read_stride, 0);
}
81149484:	e037883a 	mov	sp,fp
81149488:	dfc00117 	ldw	ra,4(sp)
8114948c:	df000017 	ldw	fp,0(sp)
81149490:	dec00204 	addi	sp,sp,8
81149494:	f800283a 	ret

81149498 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor>:
	alt_u16 sequence_number,
	alt_u8 read_burst_count,
	alt_u8 write_burst_count, 
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
81149498:	deffec04 	addi	sp,sp,-80
8114949c:	de00012e 	bgeu	sp,et,811494a4 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0xc>
811494a0:	003b68fa 	trap	3
811494a4:	dfc01315 	stw	ra,76(sp)
811494a8:	df001215 	stw	fp,72(sp)
811494ac:	df001204 	addi	fp,sp,72
811494b0:	e13ff715 	stw	r4,-36(fp)
811494b4:	e17ff815 	stw	r5,-32(fp)
811494b8:	e1bff915 	stw	r6,-28(fp)
811494bc:	e1fffa15 	stw	r7,-24(fp)
811494c0:	e1800617 	ldw	r6,24(fp)
811494c4:	e1400717 	ldw	r5,28(fp)
811494c8:	e1000817 	ldw	r4,32(fp)
811494cc:	e0c00917 	ldw	r3,36(fp)
811494d0:	e0800a17 	ldw	r2,40(fp)
811494d4:	e1bffb0d 	sth	r6,-20(fp)
811494d8:	e17ffc05 	stb	r5,-16(fp)
811494dc:	e13ffd05 	stb	r4,-12(fp)
811494e0:	e0fffe0d 	sth	r3,-8(fp)
811494e4:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
811494e8:	e0bffb0b 	ldhu	r2,-20(fp)
811494ec:	e0fffc03 	ldbu	r3,-16(fp)
811494f0:	e13ffd03 	ldbu	r4,-12(fp)
811494f4:	e17ffe0b 	ldhu	r5,-8(fp)
811494f8:	e1bfff0b 	ldhu	r6,-4(fp)
811494fc:	d9800815 	stw	r6,32(sp)
81149500:	d9400715 	stw	r5,28(sp)
81149504:	d9000615 	stw	r4,24(sp)
81149508:	d8c00515 	stw	r3,20(sp)
8114950c:	d8800415 	stw	r2,16(sp)
81149510:	e0800517 	ldw	r2,20(fp)
81149514:	d8800315 	stw	r2,12(sp)
81149518:	e0800417 	ldw	r2,16(fp)
8114951c:	d8800215 	stw	r2,8(sp)
81149520:	e0800317 	ldw	r2,12(fp)
81149524:	d8800115 	stw	r2,4(sp)
81149528:	e0800217 	ldw	r2,8(fp)
8114952c:	d8800015 	stw	r2,0(sp)
81149530:	e1fffa17 	ldw	r7,-24(fp)
81149534:	e1bff917 	ldw	r6,-28(fp)
81149538:	e17ff817 	ldw	r5,-32(fp)
8114953c:	e13ff717 	ldw	r4,-36(fp)
81149540:	11490940 	call	81149094 <alt_msgdma_construct_prefetcher_extended_descriptor>
            read_address_high, read_address_low, write_address_high, 
			write_address_low, length, control, sequence_number, 
			read_burst_count, write_burst_count, read_stride, write_stride);

}
81149544:	e037883a 	mov	sp,fp
81149548:	dfc00117 	ldw	ra,4(sp)
8114954c:	df000017 	ldw	fp,0(sp)
81149550:	dec00204 	addi	sp,sp,8
81149554:	f800283a 	ret

81149558 <alt_msgdma_prefetcher_add_standard_desc_to_list>:
 *           descriptor.next_ptr not pointing back to itslef)
 */
int alt_msgdma_prefetcher_add_standard_desc_to_list (
	alt_msgdma_prefetcher_standard_descriptor** list,
	alt_msgdma_prefetcher_standard_descriptor* descriptor)
{
81149558:	defffc04 	addi	sp,sp,-16
8114955c:	de00012e 	bgeu	sp,et,81149564 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xc>
81149560:	003b68fa 	trap	3
81149564:	df000315 	stw	fp,12(sp)
81149568:	df000304 	addi	fp,sp,12
8114956c:	e13ffe15 	stw	r4,-8(fp)
81149570:	e17fff15 	stw	r5,-4(fp)
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	
	if (descriptor == NULL)
81149574:	e0bfff17 	ldw	r2,-4(fp)
81149578:	1000021e 	bne	r2,zero,81149584 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x2c>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
8114957c:	00bffa84 	movi	r2,-22
81149580:	00002f06 	br	81149640 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (descriptor->next_desc_ptr != (alt_u32)descriptor)
81149584:	e0bfff17 	ldw	r2,-4(fp)
81149588:	10c00317 	ldw	r3,12(r2)
8114958c:	e0bfff17 	ldw	r2,-4(fp)
81149590:	18800226 	beq	r3,r2,8114959c <alt_msgdma_prefetcher_add_standard_desc_to_list+0x44>
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
81149594:	00bffa84 	movi	r2,-22
81149598:	00002906 	br	81149640 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (*list == NULL)
8114959c:	e0bffe17 	ldw	r2,-8(fp)
811495a0:	10800017 	ldw	r2,0(r2)
811495a4:	1000051e 	bne	r2,zero,811495bc <alt_msgdma_prefetcher_add_standard_desc_to_list+0x64>
	{
		*list = descriptor;  /* make this root-node if list is empty */
811495a8:	e0bffe17 	ldw	r2,-8(fp)
811495ac:	e0ffff17 	ldw	r3,-4(fp)
811495b0:	10c00015 	stw	r3,0(r2)
		return 0;  /* successfully added */
811495b4:	0005883a 	mov	r2,zero
811495b8:	00002106 	br	81149640 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (*list == descriptor)
811495bc:	e0bffe17 	ldw	r2,-8(fp)
811495c0:	10c00017 	ldw	r3,0(r2)
811495c4:	e0bfff17 	ldw	r2,-4(fp)
811495c8:	1880021e 	bne	r3,r2,811495d4 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x7c>
	{
		return -EINVAL;  /* this descriptor cannot already be root-node */
811495cc:	00bffa84 	movi	r2,-22
811495d0:	00001b06 	br	81149640 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
811495d4:	e0bffe17 	ldw	r2,-8(fp)
811495d8:	10800017 	ldw	r2,0(r2)
811495dc:	e0bffd15 	stw	r2,-12(fp)
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
811495e0:	00000906 	br	81149608 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xb0>
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
811495e4:	e0bffd17 	ldw	r2,-12(fp)
811495e8:	10c00317 	ldw	r3,12(r2)
811495ec:	e0bfff17 	ldw	r2,-4(fp)
811495f0:	1880021e 	bne	r3,r2,811495fc <alt_msgdma_prefetcher_add_standard_desc_to_list+0xa4>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
811495f4:	00bffa84 	movi	r2,-22
811495f8:	00001106 	br	81149640 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
		}
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
811495fc:	e0bffd17 	ldw	r2,-12(fp)
81149600:	10800317 	ldw	r2,12(r2)
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		last_descr_ptr = 
81149604:	e0bffd15 	stw	r2,-12(fp)
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
81149608:	e0bffd17 	ldw	r2,-12(fp)
8114960c:	10800317 	ldw	r2,12(r2)
81149610:	e0fffe17 	ldw	r3,-8(fp)
81149614:	18c00017 	ldw	r3,0(r3)
81149618:	10fff21e 	bne	r2,r3,811495e4 <__reset+0xfb1295e4>
		}
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* add this descriptor to end of list */
	last_descr_ptr->next_desc_ptr = (alt_u32)((uintptr_t)descriptor);
8114961c:	e0ffff17 	ldw	r3,-4(fp)
81149620:	e0bffd17 	ldw	r2,-12(fp)
81149624:	10c00315 	stw	r3,12(r2)
	/* ensure new last pointer points the start of the list */
	descriptor->next_desc_ptr = (alt_u32)((uintptr_t)*list);  
81149628:	e0bffe17 	ldw	r2,-8(fp)
8114962c:	10800017 	ldw	r2,0(r2)
81149630:	1007883a 	mov	r3,r2
81149634:	e0bfff17 	ldw	r2,-4(fp)
81149638:	10c00315 	stw	r3,12(r2)
	return 0; /* successfully added */
8114963c:	0005883a 	mov	r2,zero
}
81149640:	e037883a 	mov	sp,fp
81149644:	df000017 	ldw	fp,0(sp)
81149648:	dec00104 	addi	sp,sp,4
8114964c:	f800283a 	ret

81149650 <alt_msgdma_prefetcher_add_extended_desc_to_list>:

int alt_msgdma_prefetcher_add_extended_desc_to_list (
	alt_msgdma_prefetcher_extended_descriptor** list,
	alt_msgdma_prefetcher_extended_descriptor* descriptor)
{
81149650:	defff804 	addi	sp,sp,-32
81149654:	de00012e 	bgeu	sp,et,8114965c <alt_msgdma_prefetcher_add_extended_desc_to_list+0xc>
81149658:	003b68fa 	trap	3
8114965c:	df000715 	stw	fp,28(sp)
81149660:	df000704 	addi	fp,sp,28
81149664:	e13ffe15 	stw	r4,-8(fp)
81149668:	e17fff15 	stw	r5,-4(fp)
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	msgdma_addr64 root_node_addr, next_node_addr;
	
	if (descriptor == NULL)
8114966c:	e13fff17 	ldw	r4,-4(fp)
81149670:	2000021e 	bne	r4,zero,8114967c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x2c>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
81149674:	00bffa84 	movi	r2,-22
81149678:	00005906 	br	811497e0 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
8114967c:	e13fff17 	ldw	r4,-4(fp)
81149680:	2015883a 	mov	r10,r4
81149684:	0017883a 	mov	r11,zero
81149688:	e2bffc15 	stw	r10,-16(fp)
8114968c:	e2fffd15 	stw	r11,-12(fp)
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
81149690:	e13fff17 	ldw	r4,-4(fp)
81149694:	21400317 	ldw	r5,12(r4)
81149698:	e13ffc17 	ldw	r4,-16(fp)
8114969c:	29000626 	beq	r5,r4,811496b8 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x68>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
811496a0:	e13fff17 	ldw	r4,-4(fp)
811496a4:	21400b17 	ldw	r5,44(r4)
811496a8:	e13ffd17 	ldw	r4,-12(fp)
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
811496ac:	29000226 	beq	r5,r4,811496b8 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x68>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
811496b0:	00bffa84 	movi	r2,-22
811496b4:	00004a06 	br	811497e0 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	if (*list == NULL)
811496b8:	e13ffe17 	ldw	r4,-8(fp)
811496bc:	21000017 	ldw	r4,0(r4)
811496c0:	2000051e 	bne	r4,zero,811496d8 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x88>
	{
		*list = descriptor;  /* make this the root-node if list is empty */
811496c4:	e0bffe17 	ldw	r2,-8(fp)
811496c8:	e0ffff17 	ldw	r3,-4(fp)
811496cc:	10c00015 	stw	r3,0(r2)
		return 0;
811496d0:	0005883a 	mov	r2,zero
811496d4:	00004206 	br	811497e0 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	if (*list == descriptor)
811496d8:	e13ffe17 	ldw	r4,-8(fp)
811496dc:	21400017 	ldw	r5,0(r4)
811496e0:	e13fff17 	ldw	r4,-4(fp)
811496e4:	2900021e 	bne	r5,r4,811496f0 <alt_msgdma_prefetcher_add_extended_desc_to_list+0xa0>
	{
		return -EINVAL;  /* this descriptor cannot already be root-node */
811496e8:	00bffa84 	movi	r2,-22
811496ec:	00003c06 	br	811497e0 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
811496f0:	e13ffe17 	ldw	r4,-8(fp)
811496f4:	21000017 	ldw	r4,0(r4)
811496f8:	e13ff915 	stw	r4,-28(fp)
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
811496fc:	e13ffe17 	ldw	r4,-8(fp)
81149700:	21000017 	ldw	r4,0(r4)
81149704:	2011883a 	mov	r8,r4
81149708:	0013883a 	mov	r9,zero
8114970c:	e23ffa15 	stw	r8,-24(fp)
81149710:	e27ffb15 	stw	r9,-20(fp)
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
81149714:	00001806 	br	81149778 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x128>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* first check if descriptor already in the list */
		next_node_addr.u64 = (uintptr_t)descriptor;
81149718:	e13fff17 	ldw	r4,-4(fp)
8114971c:	200d883a 	mov	r6,r4
81149720:	000f883a 	mov	r7,zero
81149724:	e1bffc15 	stw	r6,-16(fp)
81149728:	e1fffd15 	stw	r7,-12(fp)
		if ((last_descr_ptr->next_desc_ptr_low == next_node_addr.u32[0])
8114972c:	e13ff917 	ldw	r4,-28(fp)
81149730:	21400317 	ldw	r5,12(r4)
81149734:	e13ffc17 	ldw	r4,-16(fp)
81149738:	2900061e 	bne	r5,r4,81149754 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x104>
			&& (last_descr_ptr->next_desc_ptr_high == next_node_addr.u32[1]))
8114973c:	e13ff917 	ldw	r4,-28(fp)
81149740:	21400b17 	ldw	r5,44(r4)
81149744:	e13ffd17 	ldw	r4,-12(fp)
81149748:	2900021e 	bne	r5,r4,81149754 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x104>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
8114974c:	00bffa84 	movi	r2,-22
81149750:	00002306 	br	811497e0 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
81149754:	e13ff917 	ldw	r4,-28(fp)
81149758:	21000317 	ldw	r4,12(r4)
8114975c:	e13ffc15 	stw	r4,-16(fp)
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
81149760:	e13ff917 	ldw	r4,-28(fp)
81149764:	21000b17 	ldw	r4,44(r4)
81149768:	e13ffd15 	stw	r4,-12(fp)
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
8114976c:	e13ffc17 	ldw	r4,-16(fp)
81149770:	e17ffd17 	ldw	r5,-12(fp)
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
81149774:	e13ff915 	stw	r4,-28(fp)
	last_descr_ptr = *list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
81149778:	e13ff917 	ldw	r4,-28(fp)
8114977c:	21400317 	ldw	r5,12(r4)
81149780:	e13ffa17 	ldw	r4,-24(fp)
81149784:	29000426 	beq	r5,r4,81149798 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x148>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
81149788:	e13ff917 	ldw	r4,-28(fp)
8114978c:	21400b17 	ldw	r5,44(r4)
81149790:	e13ffb17 	ldw	r4,-20(fp)
81149794:	293fe01e 	bne	r5,r4,81149718 <__reset+0xfb129718>
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* add this descriptor to end of list */
	next_node_addr.u64 = (uintptr_t)descriptor;
81149798:	e13fff17 	ldw	r4,-4(fp)
8114979c:	2005883a 	mov	r2,r4
811497a0:	0007883a 	mov	r3,zero
811497a4:	e0bffc15 	stw	r2,-16(fp)
811497a8:	e0fffd15 	stw	r3,-12(fp)
	last_descr_ptr->next_desc_ptr_low = next_node_addr.u32[0];
811497ac:	e0fffc17 	ldw	r3,-16(fp)
811497b0:	e0bff917 	ldw	r2,-28(fp)
811497b4:	10c00315 	stw	r3,12(r2)
	last_descr_ptr->next_desc_ptr_high = next_node_addr.u32[1];
811497b8:	e0fffd17 	ldw	r3,-12(fp)
811497bc:	e0bff917 	ldw	r2,-28(fp)
811497c0:	10c00b15 	stw	r3,44(r2)
	/* ensure new last pointer points the beginning of the list */
	descriptor->next_desc_ptr_low = root_node_addr.u32[0];
811497c4:	e0fffa17 	ldw	r3,-24(fp)
811497c8:	e0bfff17 	ldw	r2,-4(fp)
811497cc:	10c00315 	stw	r3,12(r2)
	descriptor->next_desc_ptr_high = root_node_addr.u32[1];
811497d0:	e0fffb17 	ldw	r3,-20(fp)
811497d4:	e0bfff17 	ldw	r2,-4(fp)
811497d8:	10c00b15 	stw	r3,44(r2)
	return 0;
811497dc:	0005883a 	mov	r2,zero
}
811497e0:	e037883a 	mov	sp,fp
811497e4:	df000017 	ldw	fp,0(sp)
811497e8:	dec00104 	addi	sp,sp,4
811497ec:	f800283a 	ret

811497f0 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>:
 * prefetcher since if used the create descriptor APIs the set_by_hw bits are
 * still set to SW owned. 
 */
int alt_msgdma_prefetcher_set_std_list_own_by_hw_bits (
	alt_msgdma_prefetcher_standard_descriptor *list)
{
811497f0:	defffc04 	addi	sp,sp,-16
811497f4:	de00012e 	bgeu	sp,et,811497fc <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0xc>
811497f8:	003b68fa 	trap	3
811497fc:	df000315 	stw	fp,12(sp)
81149800:	df000304 	addi	fp,sp,12
81149804:	e13fff15 	stw	r4,-4(fp)
	alt_u32 descriptor_control_field = 0;
81149808:	e03ffe15 	stw	zero,-8(fp)
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	if (list == NULL)
8114980c:	e0bfff17 	ldw	r2,-4(fp)
81149810:	1000021e 	bne	r2,zero,8114981c <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x2c>
	{
		return -EINVAL;  /* this list cannot be empty */
81149814:	00bffa84 	movi	r2,-22
81149818:	00001906 	br	81149880 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x90>
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
8114981c:	e0bfff17 	ldw	r2,-4(fp)
81149820:	e0bffd15 	stw	r2,-12(fp)
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
81149824:	00000a06 	br	81149850 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x60>
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
81149828:	e0bffd17 	ldw	r2,-12(fp)
8114982c:	10800717 	ldw	r2,28(r2)
81149830:	e0bffe15 	stw	r2,-8(fp)
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
81149834:	e0bffe17 	ldw	r2,-8(fp)
81149838:	10d00034 	orhi	r3,r2,16384
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
8114983c:	e0bffd17 	ldw	r2,-12(fp)
81149840:	10c00715 	stw	r3,28(r2)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
81149844:	e0bffd17 	ldw	r2,-12(fp)
81149848:	10800317 	ldw	r2,12(r2)
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
8114984c:	e0bffd15 	stw	r2,-12(fp)
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
81149850:	e0bffd17 	ldw	r2,-12(fp)
81149854:	10c00317 	ldw	r3,12(r2)
81149858:	e0bfff17 	ldw	r2,-4(fp)
8114985c:	18bff21e 	bne	r3,r2,81149828 <__reset+0xfb129828>
		/* go to next node in list */
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
81149860:	e0bffd17 	ldw	r2,-12(fp)
81149864:	10800717 	ldw	r2,28(r2)
81149868:	e0bffe15 	stw	r2,-8(fp)
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
8114986c:	e0bffe17 	ldw	r2,-8(fp)
81149870:	10d00034 	orhi	r3,r2,16384
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
81149874:	e0bffd17 	ldw	r2,-12(fp)
81149878:	10c00715 	stw	r3,28(r2)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	
	return 0;
8114987c:	0005883a 	mov	r2,zero
}
81149880:	e037883a 	mov	sp,fp
81149884:	df000017 	ldw	fp,0(sp)
81149888:	dec00104 	addi	sp,sp,4
8114988c:	f800283a 	ret

81149890 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>:
 * prefetcher since if used the create descriptor APIs the set_by_hw bits are
 * still set to SW owned. 
 */
int alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits (
	alt_msgdma_prefetcher_extended_descriptor *list)
{
81149890:	defff804 	addi	sp,sp,-32
81149894:	de00012e 	bgeu	sp,et,8114989c <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xc>
81149898:	003b68fa 	trap	3
8114989c:	df000715 	stw	fp,28(sp)
811498a0:	df000704 	addi	fp,sp,28
811498a4:	e13fff15 	stw	r4,-4(fp)
	alt_u32 descriptor_control_field = 0;
811498a8:	e03ffa15 	stw	zero,-24(fp)
	msgdma_addr64 root_node_addr, next_node_addr;
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	
	if (list == NULL)
811498ac:	e13fff17 	ldw	r4,-4(fp)
811498b0:	2000021e 	bne	r4,zero,811498bc <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x2c>
	{
		return -EINVAL;  /* this list cannot be empty */
811498b4:	00bffa84 	movi	r2,-22
811498b8:	00002806 	br	8114995c <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xcc>
	}
	
	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
811498bc:	e13fff17 	ldw	r4,-4(fp)
811498c0:	e13ff915 	stw	r4,-28(fp)
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;
811498c4:	e13fff17 	ldw	r4,-4(fp)
811498c8:	2005883a 	mov	r2,r4
811498cc:	0007883a 	mov	r3,zero
811498d0:	e0bffb15 	stw	r2,-20(fp)
811498d4:	e0fffc15 	stw	r3,-16(fp)

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
811498d8:	00001006 	br	8114991c <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x8c>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
811498dc:	e0bff917 	ldw	r2,-28(fp)
811498e0:	10800f17 	ldw	r2,60(r2)
811498e4:	e0bffa15 	stw	r2,-24(fp)
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
811498e8:	e0bffa17 	ldw	r2,-24(fp)
811498ec:	10d00034 	orhi	r3,r2,16384
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
811498f0:	e0bff917 	ldw	r2,-28(fp)
811498f4:	10c00f15 	stw	r3,60(r2)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
811498f8:	e0bff917 	ldw	r2,-28(fp)
811498fc:	10800317 	ldw	r2,12(r2)
81149900:	e0bffd15 	stw	r2,-12(fp)
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
81149904:	e0bff917 	ldw	r2,-28(fp)
81149908:	10800b17 	ldw	r2,44(r2)
8114990c:	e0bffe15 	stw	r2,-8(fp)
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
81149910:	e0bffd17 	ldw	r2,-12(fp)
81149914:	e0fffe17 	ldw	r3,-8(fp)
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
81149918:	e0bff915 	stw	r2,-28(fp)
	last_descr_ptr = list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
8114991c:	e0bff917 	ldw	r2,-28(fp)
81149920:	10c00317 	ldw	r3,12(r2)
81149924:	e0bffb17 	ldw	r2,-20(fp)
81149928:	18800426 	beq	r3,r2,8114993c <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xac>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
8114992c:	e0bff917 	ldw	r2,-28(fp)
81149930:	10c00b17 	ldw	r3,44(r2)
81149934:	e0bffc17 	ldw	r2,-16(fp)
81149938:	18bfe81e 	bne	r3,r2,811498dc <__reset+0xfb1298dc>
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
8114993c:	e0bff917 	ldw	r2,-28(fp)
81149940:	10800f17 	ldw	r2,60(r2)
81149944:	e0bffa15 	stw	r2,-24(fp)
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
81149948:	e0bffa17 	ldw	r2,-24(fp)
8114994c:	10d00034 	orhi	r3,r2,16384
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
81149950:	e0bff917 	ldw	r2,-28(fp)
81149954:	10c00f15 	stw	r3,60(r2)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	return 0;
81149958:	0005883a 	mov	r2,zero
}
8114995c:	e037883a 	mov	sp,fp
81149960:	df000017 	ldw	fp,0(sp)
81149964:	dec00104 	addi	sp,sp,4
81149968:	f800283a 	ret

8114996c <alt_msgdma_start_prefetcher_with_list_addr>:
int alt_msgdma_start_prefetcher_with_list_addr (
	alt_msgdma_dev *dev,
	alt_u64  list_addr,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
8114996c:	deffeb04 	addi	sp,sp,-84
81149970:	de00012e 	bgeu	sp,et,81149978 <alt_msgdma_start_prefetcher_with_list_addr+0xc>
81149974:	003b68fa 	trap	3
81149978:	dfc01415 	stw	ra,80(sp)
8114997c:	df001315 	stw	fp,76(sp)
81149980:	df001304 	addi	fp,sp,76
81149984:	e13ffb15 	stw	r4,-20(fp)
81149988:	e17ffc15 	stw	r5,-16(fp)
8114998c:	e1bffd15 	stw	r6,-12(fp)
81149990:	3807883a 	mov	r3,r7
81149994:	e0800217 	ldw	r2,8(fp)
81149998:	e0fffe05 	stb	r3,-8(fp)
8114999c:	e0bfff05 	stb	r2,-4(fp)
	alt_u32 prefetcher_ctl = 0;
811499a0:	e03fed15 	stw	zero,-76(fp)
	alt_u32 dispatcher_ctl = 0;
811499a4:	e03fee15 	stw	zero,-72(fp)
	alt_irq_context context = 0;
811499a8:	e03fef15 	stw	zero,-68(fp)
	
	/* use helper struct to get easy access to hi/low address */
	msgdma_addr64 root_node_addr;
	root_node_addr.u64 = list_addr;  
811499ac:	e0bffc17 	ldw	r2,-16(fp)
811499b0:	e0bff815 	stw	r2,-32(fp)
811499b4:	e0bffd17 	ldw	r2,-12(fp)
811499b8:	e0bff915 	stw	r2,-28(fp)
	
	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND (dev->regs_lock, 0);
811499bc:	e0bffb17 	ldw	r2,-20(fp)
811499c0:	10801817 	ldw	r2,96(r2)
811499c4:	e0bff615 	stw	r2,-40(fp)
811499c8:	e03ff70d 	sth	zero,-36(fp)
811499cc:	e0bff70b 	ldhu	r2,-36(fp)
811499d0:	e0fffa04 	addi	r3,fp,-24
811499d4:	180d883a 	mov	r6,r3
811499d8:	100b883a 	mov	r5,r2
811499dc:	e13ff617 	ldw	r4,-40(fp)
811499e0:	113eb180 	call	8113eb18 <OSSemPend>
	
	/* case where prefetcher already started, return busy error */ 
	prefetcher_ctl = IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base);
811499e4:	e0bffb17 	ldw	r2,-20(fp)
811499e8:	10800617 	ldw	r2,24(r2)
811499ec:	10800037 	ldwio	r2,0(r2)
811499f0:	e0bfed15 	stw	r2,-76(fp)
	if(ALT_MSGDMA_PREFETCHER_CTRL_RUN_GET(prefetcher_ctl)){
811499f4:	e0bfed17 	ldw	r2,-76(fp)
811499f8:	1080004c 	andi	r2,r2,1
811499fc:	10000626 	beq	r2,zero,81149a18 <alt_msgdma_start_prefetcher_with_list_addr+0xac>
		/* release the registers semaphore */
		ALT_SEM_POST (dev->regs_lock);
81149a00:	e0bffb17 	ldw	r2,-20(fp)
81149a04:	10801817 	ldw	r2,96(r2)
81149a08:	1009883a 	mov	r4,r2
81149a0c:	113eea00 	call	8113eea0 <OSSemPost>
		return -EBUSY;
81149a10:	00bffc04 	movi	r2,-16
81149a14:	00009606 	br	81149c70 <alt_msgdma_start_prefetcher_with_list_addr+0x304>
	}
		
	/* Stop the msgdma dispatcher from issuing more descriptors to the
	   read or write masters  */
	/* stop issuing more descriptors */
	dispatcher_ctl = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
81149a18:	00800804 	movi	r2,32
81149a1c:	e0bfee15 	stw	r2,-72(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81149a20:	0005303a 	rdctl	r2,status
81149a24:	e0bff215 	stw	r2,-56(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81149a28:	e0fff217 	ldw	r3,-56(fp)
81149a2c:	00bfff84 	movi	r2,-2
81149a30:	1884703a 	and	r2,r3,r2
81149a34:	1001703a 	wrctl	status,r2
  
  return context;
81149a38:	e0bff217 	ldw	r2,-56(fp)
	
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
81149a3c:	e0bfef15 	stw	r2,-68(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
81149a40:	e0bffb17 	ldw	r2,-20(fp)
81149a44:	10800317 	ldw	r2,12(r2)
81149a48:	10800104 	addi	r2,r2,4
81149a4c:	e0ffee17 	ldw	r3,-72(fp)
81149a50:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS( dev->csr_base, 
81149a54:	e0bffb17 	ldw	r2,-20(fp)
81149a58:	10800317 	ldw	r2,12(r2)
81149a5c:	e0fffb17 	ldw	r3,-20(fp)
81149a60:	18c00317 	ldw	r3,12(r3)
81149a64:	18c00037 	ldwio	r3,0(r3)
81149a68:	10c00035 	stwio	r3,0(r2)
81149a6c:	e0bfef17 	ldw	r2,-68(fp)
81149a70:	e0bff015 	stw	r2,-64(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81149a74:	e0bff017 	ldw	r2,-64(fp)
81149a78:	1001703a 	wrctl	status,r2
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up dispatcher to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if(dev->callback)
81149a7c:	e0bffb17 	ldw	r2,-20(fp)
81149a80:	10800b17 	ldw	r2,44(r2)
81149a84:	10002326 	beq	r2,zero,81149b14 <alt_msgdma_start_prefetcher_with_list_addr+0x1a8>
	{
		dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK 
81149a88:	e0bffb17 	ldw	r2,-20(fp)
81149a8c:	10c00d17 	ldw	r3,52(r2)
81149a90:	e0bfee17 	ldw	r2,-72(fp)
81149a94:	1884b03a 	or	r2,r3,r2
81149a98:	10800514 	ori	r2,r2,20
81149a9c:	e0bfee15 	stw	r2,-72(fp)
				| ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
		dispatcher_ctl &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
81149aa0:	e0ffee17 	ldw	r3,-72(fp)
81149aa4:	00bff7c4 	movi	r2,-33
81149aa8:	1884703a 	and	r2,r3,r2
81149aac:	e0bfee15 	stw	r2,-72(fp)
		
		prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
81149ab0:	e0bfed17 	ldw	r2,-76(fp)
81149ab4:	10800214 	ori	r2,r2,8
81149ab8:	e0bfed15 	stw	r2,-76(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81149abc:	0005303a 	rdctl	r2,status
81149ac0:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81149ac4:	e0fff417 	ldw	r3,-48(fp)
81149ac8:	00bfff84 	movi	r2,-2
81149acc:	1884703a 	and	r2,r3,r2
81149ad0:	1001703a 	wrctl	status,r2
  
  return context;
81149ad4:	e0bff417 	ldw	r2,-48(fp)
	    /* making sure the read-modify-write below can't be pre-empted */
	    context = alt_irq_disable_all(); 
81149ad8:	e0bfef15 	stw	r2,-68(fp)
	    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
81149adc:	e0bffb17 	ldw	r2,-20(fp)
81149ae0:	10800317 	ldw	r2,12(r2)
81149ae4:	10800104 	addi	r2,r2,4
81149ae8:	e0ffee17 	ldw	r3,-72(fp)
81149aec:	10c00035 	stwio	r3,0(r2)
		IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
81149af0:	e0bffb17 	ldw	r2,-20(fp)
81149af4:	10800617 	ldw	r2,24(r2)
81149af8:	e0ffed17 	ldw	r3,-76(fp)
81149afc:	10c00035 	stwio	r3,0(r2)
81149b00:	e0bfef17 	ldw	r2,-68(fp)
81149b04:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81149b08:	e0bff117 	ldw	r2,-60(fp)
81149b0c:	1001703a 	wrctl	status,r2
81149b10:	00002306 	br	81149ba0 <alt_msgdma_start_prefetcher_with_list_addr+0x234>
	  *   - Stop on an error with any particular descriptor
	  *   - Disable interrupt generation
	  */
	 else
	 {
		 dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
81149b14:	e0bffb17 	ldw	r2,-20(fp)
81149b18:	10c00d17 	ldw	r3,52(r2)
81149b1c:	e0bfee17 	ldw	r2,-72(fp)
81149b20:	1884b03a 	or	r2,r3,r2
81149b24:	10800114 	ori	r2,r2,4
81149b28:	e0bfee15 	stw	r2,-72(fp)
		 dispatcher_ctl &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) 
81149b2c:	e0ffee17 	ldw	r3,-72(fp)
81149b30:	00bff3c4 	movi	r2,-49
81149b34:	1884703a 	and	r2,r3,r2
81149b38:	e0bfee15 	stw	r2,-72(fp)
				 & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
81149b3c:	e0ffed17 	ldw	r3,-76(fp)
81149b40:	00bffdc4 	movi	r2,-9
81149b44:	1884703a 	and	r2,r3,r2
81149b48:	e0bfed15 	stw	r2,-76(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81149b4c:	0005303a 	rdctl	r2,status
81149b50:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81149b54:	e0fff517 	ldw	r3,-44(fp)
81149b58:	00bfff84 	movi	r2,-2
81149b5c:	1884703a 	and	r2,r3,r2
81149b60:	1001703a 	wrctl	status,r2
  
  return context;
81149b64:	e0bff517 	ldw	r2,-44(fp)
	     /* making sure the read-modify-write below can't be pre-empted */
	     context = alt_irq_disable_all();
81149b68:	e0bfef15 	stw	r2,-68(fp)
	     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
81149b6c:	e0bffb17 	ldw	r2,-20(fp)
81149b70:	10800317 	ldw	r2,12(r2)
81149b74:	10800104 	addi	r2,r2,4
81149b78:	e0ffee17 	ldw	r3,-72(fp)
81149b7c:	10c00035 	stwio	r3,0(r2)
	     IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
81149b80:	e0bffb17 	ldw	r2,-20(fp)
81149b84:	10800617 	ldw	r2,24(r2)
81149b88:	e0ffed17 	ldw	r3,-76(fp)
81149b8c:	10c00035 	stwio	r3,0(r2)
81149b90:	e0bfef17 	ldw	r2,-68(fp)
81149b94:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81149b98:	e0bff317 	ldw	r2,-52(fp)
81149b9c:	1001703a 	wrctl	status,r2
	     alt_irq_enable_all(context);
	 }   
	
	 /* set next descriptor registers to point to the list root-node */
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_LOW(dev->prefetcher_base,
81149ba0:	e0bffb17 	ldw	r2,-20(fp)
81149ba4:	10800617 	ldw	r2,24(r2)
81149ba8:	10800104 	addi	r2,r2,4
81149bac:	e0fff817 	ldw	r3,-32(fp)
81149bb0:	10c00035 	stwio	r3,0(r2)
			 root_node_addr.u32[0]);
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_HIGH(dev->prefetcher_base,
81149bb4:	e0bffb17 	ldw	r2,-20(fp)
81149bb8:	10800617 	ldw	r2,24(r2)
81149bbc:	10800204 	addi	r2,r2,8
81149bc0:	e0fff917 	ldw	r3,-28(fp)
81149bc4:	10c00035 	stwio	r3,0(r2)
			 root_node_addr.u32[1]);
		
	 /* set park-mode */
	 if (park_mode_en){
81149bc8:	e0bffe03 	ldbu	r2,-8(fp)
81149bcc:	10000426 	beq	r2,zero,81149be0 <alt_msgdma_start_prefetcher_with_list_addr+0x274>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_SET_MASK;
81149bd0:	e0bfed17 	ldw	r2,-76(fp)
81149bd4:	10800414 	ori	r2,r2,16
81149bd8:	e0bfed15 	stw	r2,-76(fp)
81149bdc:	00000406 	br	81149bf0 <alt_msgdma_start_prefetcher_with_list_addr+0x284>
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_CLR_MASK;
81149be0:	e0ffed17 	ldw	r3,-76(fp)
81149be4:	00bffbc4 	movi	r2,-17
81149be8:	1884703a 	and	r2,r3,r2
81149bec:	e0bfed15 	stw	r2,-76(fp)
	 }
	 
	 /* set poll-en */
	 if (poll_en){
81149bf0:	e0bfff03 	ldbu	r2,-4(fp)
81149bf4:	10000e26 	beq	r2,zero,81149c30 <alt_msgdma_start_prefetcher_with_list_addr+0x2c4>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_MASK; 
81149bf8:	e0bfed17 	ldw	r2,-76(fp)
81149bfc:	10800094 	ori	r2,r2,2
81149c00:	e0bfed15 	stw	r2,-76(fp)
		 if(IORD_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
81149c04:	e0bffb17 	ldw	r2,-20(fp)
81149c08:	10800617 	ldw	r2,24(r2)
81149c0c:	10800304 	addi	r2,r2,12
81149c10:	10800037 	ldwio	r2,0(r2)
81149c14:	10000a1e 	bne	r2,zero,81149c40 <alt_msgdma_start_prefetcher_with_list_addr+0x2d4>
				 dev->prefetcher_base) == 0){
			 /* set poll frequency to some non-zero default value */
			 IOWR_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
81149c18:	e0bffb17 	ldw	r2,-20(fp)
81149c1c:	10800617 	ldw	r2,24(r2)
81149c20:	10800304 	addi	r2,r2,12
81149c24:	00c03fc4 	movi	r3,255
81149c28:	10c00035 	stwio	r3,0(r2)
81149c2c:	00000406 	br	81149c40 <alt_msgdma_start_prefetcher_with_list_addr+0x2d4>
					 dev->prefetcher_base, 0xFF);
		 }
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_CLR_MASK; 
81149c30:	e0ffed17 	ldw	r3,-76(fp)
81149c34:	00bfff44 	movi	r2,-3
81149c38:	1884703a 	and	r2,r3,r2
81149c3c:	e0bfed15 	stw	r2,-76(fp)
	 }
	 
	 /* set the prefetcher run bit */
	 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_RUN_SET_MASK;
81149c40:	e0bfed17 	ldw	r2,-76(fp)
81149c44:	10800054 	ori	r2,r2,1
81149c48:	e0bfed15 	stw	r2,-76(fp)
	 /* start the dma since run bit is set */
	 IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
81149c4c:	e0bffb17 	ldw	r2,-20(fp)
81149c50:	10800617 	ldw	r2,24(r2)
81149c54:	e0ffed17 	ldw	r3,-76(fp)
81149c58:	10c00035 	stwio	r3,0(r2)
	 
	 /*
	  * Now that access to the registers is complete, release the registers
	  * semaphore so that other threads can access the registers.
	  */
	 ALT_SEM_POST (dev->regs_lock);
81149c5c:	e0bffb17 	ldw	r2,-20(fp)
81149c60:	10801817 	ldw	r2,96(r2)
81149c64:	1009883a 	mov	r4,r2
81149c68:	113eea00 	call	8113eea0 <OSSemPost>
	 
	 return 0;
81149c6c:	0005883a 	mov	r2,zero
}
81149c70:	e037883a 	mov	sp,fp
81149c74:	dfc00117 	ldw	ra,4(sp)
81149c78:	df000017 	ldw	fp,0(sp)
81149c7c:	dec00204 	addi	sp,sp,8
81149c80:	f800283a 	ret

81149c84 <alt_msgdma_start_prefetcher_with_std_desc_list>:
int alt_msgdma_start_prefetcher_with_std_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{	
81149c84:	defff704 	addi	sp,sp,-36
81149c88:	de00012e 	bgeu	sp,et,81149c90 <alt_msgdma_start_prefetcher_with_std_desc_list+0xc>
81149c8c:	003b68fa 	trap	3
81149c90:	dfc00815 	stw	ra,32(sp)
81149c94:	df000715 	stw	fp,28(sp)
81149c98:	dc400615 	stw	r17,24(sp)
81149c9c:	dc000515 	stw	r16,20(sp)
81149ca0:	df000704 	addi	fp,sp,28
81149ca4:	e13ffa15 	stw	r4,-24(fp)
81149ca8:	e17ffb15 	stw	r5,-20(fp)
81149cac:	3007883a 	mov	r3,r6
81149cb0:	3805883a 	mov	r2,r7
81149cb4:	e0fffc05 	stb	r3,-16(fp)
81149cb8:	e0bffd05 	stb	r2,-12(fp)
	if (alt_msgdma_prefetcher_set_std_list_own_by_hw_bits(list) != 0){
81149cbc:	e13ffb17 	ldw	r4,-20(fp)
81149cc0:	11497f00 	call	811497f0 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>
81149cc4:	10000226 	beq	r2,zero,81149cd0 <alt_msgdma_start_prefetcher_with_std_desc_list+0x4c>
		return -EINVAL;
81149cc8:	00bffa84 	movi	r2,-22
81149ccc:	00000b06 	br	81149cfc <alt_msgdma_start_prefetcher_with_std_desc_list+0x78>
	}
	
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list,
81149cd0:	e0bffb17 	ldw	r2,-20(fp)
81149cd4:	1021883a 	mov	r16,r2
81149cd8:	0023883a 	mov	r17,zero
81149cdc:	e0fffc03 	ldbu	r3,-16(fp)
81149ce0:	e0bffd03 	ldbu	r2,-12(fp)
81149ce4:	d8800015 	stw	r2,0(sp)
81149ce8:	180f883a 	mov	r7,r3
81149cec:	800b883a 	mov	r5,r16
81149cf0:	880d883a 	mov	r6,r17
81149cf4:	e13ffa17 	ldw	r4,-24(fp)
81149cf8:	114996c0 	call	8114996c <alt_msgdma_start_prefetcher_with_list_addr>
			park_mode_en, poll_en);
}
81149cfc:	e6fffe04 	addi	sp,fp,-8
81149d00:	dfc00317 	ldw	ra,12(sp)
81149d04:	df000217 	ldw	fp,8(sp)
81149d08:	dc400117 	ldw	r17,4(sp)
81149d0c:	dc000017 	ldw	r16,0(sp)
81149d10:	dec00404 	addi	sp,sp,16
81149d14:	f800283a 	ret

81149d18 <alt_msgdma_start_prefetcher_with_extd_desc_list>:
int alt_msgdma_start_prefetcher_with_extd_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_extended_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
81149d18:	defff704 	addi	sp,sp,-36
81149d1c:	de00012e 	bgeu	sp,et,81149d24 <alt_msgdma_start_prefetcher_with_extd_desc_list+0xc>
81149d20:	003b68fa 	trap	3
81149d24:	dfc00815 	stw	ra,32(sp)
81149d28:	df000715 	stw	fp,28(sp)
81149d2c:	dc400615 	stw	r17,24(sp)
81149d30:	dc000515 	stw	r16,20(sp)
81149d34:	df000704 	addi	fp,sp,28
81149d38:	e13ffa15 	stw	r4,-24(fp)
81149d3c:	e17ffb15 	stw	r5,-20(fp)
81149d40:	3007883a 	mov	r3,r6
81149d44:	3805883a 	mov	r2,r7
81149d48:	e0fffc05 	stb	r3,-16(fp)
81149d4c:	e0bffd05 	stb	r2,-12(fp)
	if (alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits(list) != 0){
81149d50:	e13ffb17 	ldw	r4,-20(fp)
81149d54:	11498900 	call	81149890 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>
81149d58:	10000226 	beq	r2,zero,81149d64 <alt_msgdma_start_prefetcher_with_extd_desc_list+0x4c>
		return -EINVAL;
81149d5c:	00bffa84 	movi	r2,-22
81149d60:	00000b06 	br	81149d90 <alt_msgdma_start_prefetcher_with_extd_desc_list+0x78>
	}
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list, 
81149d64:	e0bffb17 	ldw	r2,-20(fp)
81149d68:	1021883a 	mov	r16,r2
81149d6c:	0023883a 	mov	r17,zero
81149d70:	e0fffc03 	ldbu	r3,-16(fp)
81149d74:	e0bffd03 	ldbu	r2,-12(fp)
81149d78:	d8800015 	stw	r2,0(sp)
81149d7c:	180f883a 	mov	r7,r3
81149d80:	800b883a 	mov	r5,r16
81149d84:	880d883a 	mov	r6,r17
81149d88:	e13ffa17 	ldw	r4,-24(fp)
81149d8c:	114996c0 	call	8114996c <alt_msgdma_start_prefetcher_with_list_addr>
			park_mode_en, poll_en);
}
81149d90:	e6fffe04 	addi	sp,fp,-8
81149d94:	dfc00317 	ldw	ra,12(sp)
81149d98:	df000217 	ldw	fp,8(sp)
81149d9c:	dc400117 	ldw	r17,4(sp)
81149da0:	dc000017 	ldw	r16,0(sp)
81149da4:	dec00404 	addi	sp,sp,16
81149da8:	f800283a 	ret

81149dac <alt_msgdma_open>:
 * Returns:
 * - Pointer to msgdma device instance structure, or null if the device
 *   could not be opened.
 */
alt_msgdma_dev* alt_msgdma_open (const char* name)
{
81149dac:	defffc04 	addi	sp,sp,-16
81149db0:	de00012e 	bgeu	sp,et,81149db8 <alt_msgdma_open+0xc>
81149db4:	003b68fa 	trap	3
81149db8:	dfc00315 	stw	ra,12(sp)
81149dbc:	df000215 	stw	fp,8(sp)
81149dc0:	df000204 	addi	fp,sp,8
81149dc4:	e13fff15 	stw	r4,-4(fp)
    alt_msgdma_dev* dev = NULL;
81149dc8:	e03ffe15 	stw	zero,-8(fp)

    dev = (alt_msgdma_dev*) alt_find_dev (name, &alt_msgdma_list);
81149dcc:	d1603504 	addi	r5,gp,-32556
81149dd0:	e13fff17 	ldw	r4,-4(fp)
81149dd4:	114a3500 	call	8114a350 <alt_find_dev>
81149dd8:	e0bffe15 	stw	r2,-8(fp)

    if (NULL == dev)
81149ddc:	e0bffe17 	ldw	r2,-8(fp)
81149de0:	1000041e 	bne	r2,zero,81149df4 <alt_msgdma_open+0x48>
    {
        ALT_ERRNO = ENODEV;
81149de4:	11480100 	call	81148010 <alt_get_errno>
81149de8:	1007883a 	mov	r3,r2
81149dec:	008004c4 	movi	r2,19
81149df0:	18800015 	stw	r2,0(r3)
    }

    return dev;
81149df4:	e0bffe17 	ldw	r2,-8(fp)
}
81149df8:	e037883a 	mov	sp,fp
81149dfc:	dfc00117 	ldw	ra,4(sp)
81149e00:	df000017 	ldw	fp,0(sp)
81149e04:	dec00204 	addi	sp,sp,8
81149e08:	f800283a 	ret

81149e0c <alt_msgdma_init>:
 * This routine disables interrupts, descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_msgdma_init (alt_msgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
81149e0c:	defff604 	addi	sp,sp,-40
81149e10:	de00012e 	bgeu	sp,et,81149e18 <alt_msgdma_init+0xc>
81149e14:	003b68fa 	trap	3
81149e18:	dfc00915 	stw	ra,36(sp)
81149e1c:	df000815 	stw	fp,32(sp)
81149e20:	df000804 	addi	fp,sp,32
81149e24:	e13ffd15 	stw	r4,-12(fp)
81149e28:	e17ffe15 	stw	r5,-8(fp)
81149e2c:	e1bfff15 	stw	r6,-4(fp)
    extern alt_llist alt_msgdma_list;
    alt_u32 temporary_control;
    int error;

    if (dev->prefetcher_enable)
81149e30:	e0bffd17 	ldw	r2,-12(fp)
81149e34:	10801783 	ldbu	r2,94(r2)
81149e38:	10803fcc 	andi	r2,r2,255
81149e3c:	10000b26 	beq	r2,zero,81149e6c <alt_msgdma_init+0x60>
    {
    	/* start prefetcher reset sequence */
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, 
81149e40:	e0bffd17 	ldw	r2,-12(fp)
81149e44:	10800617 	ldw	r2,24(r2)
81149e48:	00c00104 	movi	r3,4
81149e4c:	10c00035 	stwio	r3,0(r2)
    			ALT_MSGDMA_PREFETCHER_CTRL_RESET_SET_MASK);
    	/* wait until hw clears the bit */
    	while(ALT_MSGDMA_PREFETCHER_CTRL_RESET_GET(
81149e50:	0001883a 	nop
81149e54:	e0bffd17 	ldw	r2,-12(fp)
81149e58:	10800617 	ldw	r2,24(r2)
81149e5c:	10800037 	ldwio	r2,0(r2)
81149e60:	1080010c 	andi	r2,r2,4
81149e64:	1005d0ba 	srai	r2,r2,2
81149e68:	103ffa1e 	bne	r2,zero,81149e54 <__reset+0xfb129e54>
    }    
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
81149e6c:	e0bffd17 	ldw	r2,-12(fp)
81149e70:	10800317 	ldw	r2,12(r2)
81149e74:	10800104 	addi	r2,r2,4
81149e78:	00c00084 	movi	r3,2
81149e7c:	10c00035 	stwio	r3,0(r2)
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
81149e80:	0001883a 	nop
81149e84:	e0bffd17 	ldw	r2,-12(fp)
81149e88:	10800317 	ldw	r2,12(r2)
81149e8c:	10800037 	ldwio	r2,0(r2)
    		& ALTERA_MSGDMA_CSR_RESET_STATE_MASK));
81149e90:	1080100c 	andi	r2,r2,64
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
81149e94:	103ffb1e 	bne	r2,zero,81149e84 <__reset+0xfb129e84>
    * Disable interrupts, halt descriptor processing,
    * and clear status register content
    */

    /* disable global interrupt */
    temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
81149e98:	e0bffd17 	ldw	r2,-12(fp)
81149e9c:	10800317 	ldw	r2,12(r2)
81149ea0:	10800104 	addi	r2,r2,4
81149ea4:	10800037 	ldwio	r2,0(r2)
81149ea8:	1007883a 	mov	r3,r2
81149eac:	00bffbc4 	movi	r2,-17
81149eb0:	1884703a 	and	r2,r3,r2
81149eb4:	e0bff915 	stw	r2,-28(fp)
    		& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    /* stopping descriptor */
    temporary_control |= ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
81149eb8:	e0bff917 	ldw	r2,-28(fp)
81149ebc:	10800814 	ori	r2,r2,32
81149ec0:	e0bff915 	stw	r2,-28(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
81149ec4:	e0bffd17 	ldw	r2,-12(fp)
81149ec8:	10800317 	ldw	r2,12(r2)
81149ecc:	10800104 	addi	r2,r2,4
81149ed0:	e0fff917 	ldw	r3,-28(fp)
81149ed4:	10c00035 	stwio	r3,0(r2)

    /* clear the CSR status register */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base, 
81149ed8:	e0bffd17 	ldw	r2,-12(fp)
81149edc:	10800317 	ldw	r2,12(r2)
81149ee0:	e0fffd17 	ldw	r3,-12(fp)
81149ee4:	18c00317 	ldw	r3,12(r3)
81149ee8:	18c00037 	ldwio	r3,0(r3)
81149eec:	10c00035 	stwio	r3,0(r2)
    		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
    
    if (dev->prefetcher_enable)
81149ef0:	e0bffd17 	ldw	r2,-12(fp)
81149ef4:	10801783 	ldbu	r2,94(r2)
81149ef8:	10803fcc 	andi	r2,r2,255
81149efc:	10000826 	beq	r2,zero,81149f20 <alt_msgdma_init+0x114>
    {
    	/* clear all status bits that are set, since theyre W1C */
    	IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base, 
81149f00:	e0bffd17 	ldw	r2,-12(fp)
81149f04:	10800617 	ldw	r2,24(r2)
81149f08:	10800404 	addi	r2,r2,16
81149f0c:	e0fffd17 	ldw	r3,-12(fp)
81149f10:	18c00617 	ldw	r3,24(r3)
81149f14:	18c00404 	addi	r3,r3,16
81149f18:	18c00037 	ldwio	r3,0(r3)
81149f1c:	10c00035 	stwio	r3,0(r2)
    			IORD_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base));
    }

    /* Register this instance of the msgdma controller with HAL */
    alt_dev_llist_insert((alt_dev_llist*) dev, &alt_msgdma_list);
81149f20:	d1603504 	addi	r5,gp,-32556
81149f24:	e13ffd17 	ldw	r4,-12(fp)
81149f28:	114a2a40 	call	8114a2a4 <alt_dev_llist_insert>

    /*
     * Creating semaphores used to protect access to the registers 
     * when running in a multi-threaded environment.
     */
    error = ALT_SEM_CREATE (&dev->regs_lock, 1);
81149f2c:	e0bffd17 	ldw	r2,-12(fp)
81149f30:	10801804 	addi	r2,r2,96
81149f34:	e0bffb15 	stw	r2,-20(fp)
81149f38:	00800044 	movi	r2,1
81149f3c:	e0bffc0d 	sth	r2,-16(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
81149f40:	e0bffc0b 	ldhu	r2,-16(fp)
81149f44:	1009883a 	mov	r4,r2
81149f48:	113e7f00 	call	8113e7f0 <OSSemCreate>
81149f4c:	1007883a 	mov	r3,r2
81149f50:	e0bffb17 	ldw	r2,-20(fp)
81149f54:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
81149f58:	e0bffb17 	ldw	r2,-20(fp)
81149f5c:	10800017 	ldw	r2,0(r2)
81149f60:	10000226 	beq	r2,zero,81149f6c <alt_msgdma_init+0x160>
81149f64:	0005883a 	mov	r2,zero
81149f68:	00000106 	br	81149f70 <alt_msgdma_init+0x164>
81149f6c:	00bfffc4 	movi	r2,-1
81149f70:	e0bffa15 	stw	r2,-24(fp)
            
    if (!error)
81149f74:	e0bffa17 	ldw	r2,-24(fp)
81149f78:	1000081e 	bne	r2,zero,81149f9c <alt_msgdma_init+0x190>
    {        
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
81149f7c:	d8000015 	stw	zero,0(sp)
81149f80:	e1fffd17 	ldw	r7,-12(fp)
81149f84:	01a04574 	movhi	r6,33045
81149f88:	31a08904 	addi	r6,r6,-32220
81149f8c:	e17fff17 	ldw	r5,-4(fp)
81149f90:	e13ffe17 	ldw	r4,-8(fp)
81149f94:	114a5dc0 	call	8114a5dc <alt_ic_isr_register>
    else
    {
        alt_printf("failed to create semaphores\n");
    }
    
    return;
81149f98:	00000406 	br	81149fac <alt_msgdma_init+0x1a0>
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
    }
    else
    {
        alt_printf("failed to create semaphores\n");
81149f9c:	01204574 	movhi	r4,33045
81149fa0:	21058804 	addi	r4,r4,5664
81149fa4:	114a9f40 	call	8114a9f4 <alt_printf>
    }
    
    return;
81149fa8:	0001883a 	nop

}
81149fac:	e037883a 	mov	sp,fp
81149fb0:	dfc00117 	ldw	ra,4(sp)
81149fb4:	df000017 	ldw	fp,0(sp)
81149fb8:	dec00204 	addi	sp,sp,8
81149fbc:	f800283a 	ret

81149fc0 <alt_msgdma_register_callback>:
void alt_msgdma_register_callback(
	alt_msgdma_dev *dev,
	alt_msgdma_callback callback,
	alt_u32 control,
	void *context)
{
81149fc0:	defffb04 	addi	sp,sp,-20
81149fc4:	de00012e 	bgeu	sp,et,81149fcc <alt_msgdma_register_callback+0xc>
81149fc8:	003b68fa 	trap	3
81149fcc:	df000415 	stw	fp,16(sp)
81149fd0:	df000404 	addi	fp,sp,16
81149fd4:	e13ffc15 	stw	r4,-16(fp)
81149fd8:	e17ffd15 	stw	r5,-12(fp)
81149fdc:	e1bffe15 	stw	r6,-8(fp)
81149fe0:	e1ffff15 	stw	r7,-4(fp)
    dev->callback         = callback;
81149fe4:	e0bffc17 	ldw	r2,-16(fp)
81149fe8:	e0fffd17 	ldw	r3,-12(fp)
81149fec:	10c00b15 	stw	r3,44(r2)
    dev->callback_context = context;
81149ff0:	e0bffc17 	ldw	r2,-16(fp)
81149ff4:	e0ffff17 	ldw	r3,-4(fp)
81149ff8:	10c00c15 	stw	r3,48(r2)
    dev->control          = control;
81149ffc:	e0bffc17 	ldw	r2,-16(fp)
8114a000:	e0fffe17 	ldw	r3,-8(fp)
8114a004:	10c00d15 	stw	r3,52(r2)

    return ;
8114a008:	0001883a 	nop
}
8114a00c:	e037883a 	mov	sp,fp
8114a010:	df000017 	ldw	fp,0(sp)
8114a014:	dec00104 	addi	sp,sp,4
8114a018:	f800283a 	ret

8114a01c <alt_msgdma_standard_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_standard_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
8114a01c:	defffc04 	addi	sp,sp,-16
8114a020:	de00012e 	bgeu	sp,et,8114a028 <alt_msgdma_standard_descriptor_async_transfer+0xc>
8114a024:	003b68fa 	trap	3
8114a028:	dfc00315 	stw	ra,12(sp)
8114a02c:	df000215 	stw	fp,8(sp)
8114a030:	df000204 	addi	fp,sp,8
8114a034:	e13ffe15 	stw	r4,-8(fp)
8114a038:	e17fff15 	stw	r5,-4(fp)
   /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
    return alt_msgdma_descriptor_async_transfer(dev, desc, NULL);
8114a03c:	000d883a 	mov	r6,zero
8114a040:	e17fff17 	ldw	r5,-4(fp)
8114a044:	e13ffe17 	ldw	r4,-8(fp)
8114a048:	11485a00 	call	811485a0 <alt_msgdma_descriptor_async_transfer>

}
8114a04c:	e037883a 	mov	sp,fp
8114a050:	dfc00117 	ldw	ra,4(sp)
8114a054:	df000017 	ldw	fp,0(sp)
8114a058:	dec00204 	addi	sp,sp,8
8114a05c:	f800283a 	ret

8114a060 <alt_msgdma_extended_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_extended_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
8114a060:	defffc04 	addi	sp,sp,-16
8114a064:	de00012e 	bgeu	sp,et,8114a06c <alt_msgdma_extended_descriptor_async_transfer+0xc>
8114a068:	003b68fa 	trap	3
8114a06c:	dfc00315 	stw	ra,12(sp)
8114a070:	df000215 	stw	fp,8(sp)
8114a074:	df000204 	addi	fp,sp,8
8114a078:	e13ffe15 	stw	r4,-8(fp)
8114a07c:	e17fff15 	stw	r5,-4(fp)
    /*
    * Error detection/handling should be performed at the application
    * or callback level as appropriate.
    */
    return alt_msgdma_descriptor_async_transfer(dev, NULL, desc);
8114a080:	e1bfff17 	ldw	r6,-4(fp)
8114a084:	000b883a 	mov	r5,zero
8114a088:	e13ffe17 	ldw	r4,-8(fp)
8114a08c:	11485a00 	call	811485a0 <alt_msgdma_descriptor_async_transfer>
}
8114a090:	e037883a 	mov	sp,fp
8114a094:	dfc00117 	ldw	ra,4(sp)
8114a098:	df000017 	ldw	fp,0(sp)
8114a09c:	dec00204 	addi	sp,sp,8
8114a0a0:	f800283a 	ret

8114a0a4 <alt_msgdma_standard_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_standard_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
8114a0a4:	defffc04 	addi	sp,sp,-16
8114a0a8:	de00012e 	bgeu	sp,et,8114a0b0 <alt_msgdma_standard_descriptor_sync_transfer+0xc>
8114a0ac:	003b68fa 	trap	3
8114a0b0:	dfc00315 	stw	ra,12(sp)
8114a0b4:	df000215 	stw	fp,8(sp)
8114a0b8:	df000204 	addi	fp,sp,8
8114a0bc:	e13ffe15 	stw	r4,-8(fp)
8114a0c0:	e17fff15 	stw	r5,-4(fp)
    return alt_msgdma_descriptor_sync_transfer(dev, desc, NULL);
8114a0c4:	000d883a 	mov	r6,zero
8114a0c8:	e17fff17 	ldw	r5,-4(fp)
8114a0cc:	e13ffe17 	ldw	r4,-8(fp)
8114a0d0:	11488e00 	call	811488e0 <alt_msgdma_descriptor_sync_transfer>
}
8114a0d4:	e037883a 	mov	sp,fp
8114a0d8:	dfc00117 	ldw	ra,4(sp)
8114a0dc:	df000017 	ldw	fp,0(sp)
8114a0e0:	dec00204 	addi	sp,sp,8
8114a0e4:	f800283a 	ret

8114a0e8 <alt_msgdma_extended_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_extended_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
8114a0e8:	defffc04 	addi	sp,sp,-16
8114a0ec:	de00012e 	bgeu	sp,et,8114a0f4 <alt_msgdma_extended_descriptor_sync_transfer+0xc>
8114a0f0:	003b68fa 	trap	3
8114a0f4:	dfc00315 	stw	ra,12(sp)
8114a0f8:	df000215 	stw	fp,8(sp)
8114a0fc:	df000204 	addi	fp,sp,8
8114a100:	e13ffe15 	stw	r4,-8(fp)
8114a104:	e17fff15 	stw	r5,-4(fp)
    return alt_msgdma_descriptor_sync_transfer(dev, NULL, desc);
8114a108:	e1bfff17 	ldw	r6,-4(fp)
8114a10c:	000b883a 	mov	r5,zero
8114a110:	e13ffe17 	ldw	r4,-8(fp)
8114a114:	11488e00 	call	811488e0 <alt_msgdma_descriptor_sync_transfer>
}
8114a118:	e037883a 	mov	sp,fp
8114a11c:	dfc00117 	ldw	ra,4(sp)
8114a120:	df000017 	ldw	fp,0(sp)
8114a124:	dec00204 	addi	sp,sp,8
8114a128:	f800283a 	ret

8114a12c <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
8114a12c:	defff504 	addi	sp,sp,-44
8114a130:	de00012e 	bgeu	sp,et,8114a138 <alt_alarm_start+0xc>
8114a134:	003b68fa 	trap	3
8114a138:	df000a15 	stw	fp,40(sp)
8114a13c:	df000a04 	addi	fp,sp,40
8114a140:	e13ffc15 	stw	r4,-16(fp)
8114a144:	e17ffd15 	stw	r5,-12(fp)
8114a148:	e1bffe15 	stw	r6,-8(fp)
8114a14c:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
8114a150:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
8114a154:	d0a08817 	ldw	r2,-32224(gp)
  
  if (alt_ticks_per_second ())
8114a158:	10003c26 	beq	r2,zero,8114a24c <alt_alarm_start+0x120>
  {
    if (alarm)
8114a15c:	e0bffc17 	ldw	r2,-16(fp)
8114a160:	10003826 	beq	r2,zero,8114a244 <alt_alarm_start+0x118>
    {
      alarm->callback = callback;
8114a164:	e0bffc17 	ldw	r2,-16(fp)
8114a168:	e0fffe17 	ldw	r3,-8(fp)
8114a16c:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
8114a170:	e0bffc17 	ldw	r2,-16(fp)
8114a174:	e0ffff17 	ldw	r3,-4(fp)
8114a178:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114a17c:	0005303a 	rdctl	r2,status
8114a180:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114a184:	e0fff917 	ldw	r3,-28(fp)
8114a188:	00bfff84 	movi	r2,-2
8114a18c:	1884703a 	and	r2,r3,r2
8114a190:	1001703a 	wrctl	status,r2
  
  return context;
8114a194:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
8114a198:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
8114a19c:	d0a08917 	ldw	r2,-32220(gp)
      
      current_nticks = alt_nticks();
8114a1a0:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
8114a1a4:	e0fffd17 	ldw	r3,-12(fp)
8114a1a8:	e0bff617 	ldw	r2,-40(fp)
8114a1ac:	1885883a 	add	r2,r3,r2
8114a1b0:	10c00044 	addi	r3,r2,1
8114a1b4:	e0bffc17 	ldw	r2,-16(fp)
8114a1b8:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
8114a1bc:	e0bffc17 	ldw	r2,-16(fp)
8114a1c0:	10c00217 	ldw	r3,8(r2)
8114a1c4:	e0bff617 	ldw	r2,-40(fp)
8114a1c8:	1880042e 	bgeu	r3,r2,8114a1dc <alt_alarm_start+0xb0>
      {
        alarm->rollover = 1;
8114a1cc:	e0bffc17 	ldw	r2,-16(fp)
8114a1d0:	00c00044 	movi	r3,1
8114a1d4:	10c00405 	stb	r3,16(r2)
8114a1d8:	00000206 	br	8114a1e4 <alt_alarm_start+0xb8>
      }
      else
      {
        alarm->rollover = 0;
8114a1dc:	e0bffc17 	ldw	r2,-16(fp)
8114a1e0:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
8114a1e4:	e0bffc17 	ldw	r2,-16(fp)
8114a1e8:	d0e01404 	addi	r3,gp,-32688
8114a1ec:	e0fffa15 	stw	r3,-24(fp)
8114a1f0:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
8114a1f4:	e0bffb17 	ldw	r2,-20(fp)
8114a1f8:	e0fffa17 	ldw	r3,-24(fp)
8114a1fc:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
8114a200:	e0bffa17 	ldw	r2,-24(fp)
8114a204:	10c00017 	ldw	r3,0(r2)
8114a208:	e0bffb17 	ldw	r2,-20(fp)
8114a20c:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
8114a210:	e0bffa17 	ldw	r2,-24(fp)
8114a214:	10800017 	ldw	r2,0(r2)
8114a218:	e0fffb17 	ldw	r3,-20(fp)
8114a21c:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
8114a220:	e0bffa17 	ldw	r2,-24(fp)
8114a224:	e0fffb17 	ldw	r3,-20(fp)
8114a228:	10c00015 	stw	r3,0(r2)
8114a22c:	e0bff817 	ldw	r2,-32(fp)
8114a230:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114a234:	e0bff717 	ldw	r2,-36(fp)
8114a238:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
8114a23c:	0005883a 	mov	r2,zero
8114a240:	00000306 	br	8114a250 <alt_alarm_start+0x124>
    }
    else
    {
      return -EINVAL;
8114a244:	00bffa84 	movi	r2,-22
8114a248:	00000106 	br	8114a250 <alt_alarm_start+0x124>
    }
  }
  else
  {
    return -ENOTSUP;
8114a24c:	00bfde84 	movi	r2,-134
  }
}
8114a250:	e037883a 	mov	sp,fp
8114a254:	df000017 	ldw	fp,0(sp)
8114a258:	dec00104 	addi	sp,sp,4
8114a25c:	f800283a 	ret

8114a260 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8114a260:	defffe04 	addi	sp,sp,-8
8114a264:	de00012e 	bgeu	sp,et,8114a26c <alt_get_errno+0xc>
8114a268:	003b68fa 	trap	3
8114a26c:	dfc00115 	stw	ra,4(sp)
8114a270:	df000015 	stw	fp,0(sp)
8114a274:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8114a278:	d0a01017 	ldw	r2,-32704(gp)
8114a27c:	10000326 	beq	r2,zero,8114a28c <alt_get_errno+0x2c>
8114a280:	d0a01017 	ldw	r2,-32704(gp)
8114a284:	103ee83a 	callr	r2
8114a288:	00000106 	br	8114a290 <alt_get_errno+0x30>
8114a28c:	d0a07804 	addi	r2,gp,-32288
}
8114a290:	e037883a 	mov	sp,fp
8114a294:	dfc00117 	ldw	ra,4(sp)
8114a298:	df000017 	ldw	fp,0(sp)
8114a29c:	dec00204 	addi	sp,sp,8
8114a2a0:	f800283a 	ret

8114a2a4 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
8114a2a4:	defffa04 	addi	sp,sp,-24
8114a2a8:	de00012e 	bgeu	sp,et,8114a2b0 <alt_dev_llist_insert+0xc>
8114a2ac:	003b68fa 	trap	3
8114a2b0:	dfc00515 	stw	ra,20(sp)
8114a2b4:	df000415 	stw	fp,16(sp)
8114a2b8:	df000404 	addi	fp,sp,16
8114a2bc:	e13ffe15 	stw	r4,-8(fp)
8114a2c0:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
8114a2c4:	e0bffe17 	ldw	r2,-8(fp)
8114a2c8:	10000326 	beq	r2,zero,8114a2d8 <alt_dev_llist_insert+0x34>
8114a2cc:	e0bffe17 	ldw	r2,-8(fp)
8114a2d0:	10800217 	ldw	r2,8(r2)
8114a2d4:	1000061e 	bne	r2,zero,8114a2f0 <alt_dev_llist_insert+0x4c>
  {
    ALT_ERRNO = EINVAL;
8114a2d8:	114a2600 	call	8114a260 <alt_get_errno>
8114a2dc:	1007883a 	mov	r3,r2
8114a2e0:	00800584 	movi	r2,22
8114a2e4:	18800015 	stw	r2,0(r3)
    return -EINVAL;
8114a2e8:	00bffa84 	movi	r2,-22
8114a2ec:	00001306 	br	8114a33c <alt_dev_llist_insert+0x98>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
8114a2f0:	e0bffe17 	ldw	r2,-8(fp)
8114a2f4:	e0ffff17 	ldw	r3,-4(fp)
8114a2f8:	e0fffc15 	stw	r3,-16(fp)
8114a2fc:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
8114a300:	e0bffd17 	ldw	r2,-12(fp)
8114a304:	e0fffc17 	ldw	r3,-16(fp)
8114a308:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
8114a30c:	e0bffc17 	ldw	r2,-16(fp)
8114a310:	10c00017 	ldw	r3,0(r2)
8114a314:	e0bffd17 	ldw	r2,-12(fp)
8114a318:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
8114a31c:	e0bffc17 	ldw	r2,-16(fp)
8114a320:	10800017 	ldw	r2,0(r2)
8114a324:	e0fffd17 	ldw	r3,-12(fp)
8114a328:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
8114a32c:	e0bffc17 	ldw	r2,-16(fp)
8114a330:	e0fffd17 	ldw	r3,-12(fp)
8114a334:	10c00015 	stw	r3,0(r2)

  return 0;  
8114a338:	0005883a 	mov	r2,zero
}
8114a33c:	e037883a 	mov	sp,fp
8114a340:	dfc00117 	ldw	ra,4(sp)
8114a344:	df000017 	ldw	fp,0(sp)
8114a348:	dec00204 	addi	sp,sp,8
8114a34c:	f800283a 	ret

8114a350 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
8114a350:	defffa04 	addi	sp,sp,-24
8114a354:	de00012e 	bgeu	sp,et,8114a35c <alt_find_dev+0xc>
8114a358:	003b68fa 	trap	3
8114a35c:	dfc00515 	stw	ra,20(sp)
8114a360:	df000415 	stw	fp,16(sp)
8114a364:	df000404 	addi	fp,sp,16
8114a368:	e13ffe15 	stw	r4,-8(fp)
8114a36c:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
8114a370:	e0bfff17 	ldw	r2,-4(fp)
8114a374:	10800017 	ldw	r2,0(r2)
8114a378:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
8114a37c:	e13ffe17 	ldw	r4,-8(fp)
8114a380:	11231840 	call	81123184 <strlen>
8114a384:	10800044 	addi	r2,r2,1
8114a388:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
8114a38c:	00000d06 	br	8114a3c4 <alt_find_dev+0x74>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
8114a390:	e0bffc17 	ldw	r2,-16(fp)
8114a394:	10800217 	ldw	r2,8(r2)
8114a398:	e0fffd17 	ldw	r3,-12(fp)
8114a39c:	180d883a 	mov	r6,r3
8114a3a0:	e17ffe17 	ldw	r5,-8(fp)
8114a3a4:	1009883a 	mov	r4,r2
8114a3a8:	114b1640 	call	8114b164 <memcmp>
8114a3ac:	1000021e 	bne	r2,zero,8114a3b8 <alt_find_dev+0x68>
    {
      /* match found */

      return next;
8114a3b0:	e0bffc17 	ldw	r2,-16(fp)
8114a3b4:	00000706 	br	8114a3d4 <alt_find_dev+0x84>
    }
    next = (alt_dev*) next->llist.next;
8114a3b8:	e0bffc17 	ldw	r2,-16(fp)
8114a3bc:	10800017 	ldw	r2,0(r2)
8114a3c0:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
8114a3c4:	e0fffc17 	ldw	r3,-16(fp)
8114a3c8:	e0bfff17 	ldw	r2,-4(fp)
8114a3cc:	18bff01e 	bne	r3,r2,8114a390 <__reset+0xfb12a390>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
8114a3d0:	0005883a 	mov	r2,zero
}
8114a3d4:	e037883a 	mov	sp,fp
8114a3d8:	dfc00117 	ldw	ra,4(sp)
8114a3dc:	df000017 	ldw	fp,0(sp)
8114a3e0:	dec00204 	addi	sp,sp,8
8114a3e4:	f800283a 	ret

8114a3e8 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
8114a3e8:	defffb04 	addi	sp,sp,-20
8114a3ec:	de00012e 	bgeu	sp,et,8114a3f4 <alt_find_file+0xc>
8114a3f0:	003b68fa 	trap	3
8114a3f4:	dfc00415 	stw	ra,16(sp)
8114a3f8:	df000315 	stw	fp,12(sp)
8114a3fc:	df000304 	addi	fp,sp,12
8114a400:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
8114a404:	d0a00b17 	ldw	r2,-32724(gp)
8114a408:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
8114a40c:	00003106 	br	8114a4d4 <alt_find_file+0xec>
  {
    len = strlen(next->name);
8114a410:	e0bffd17 	ldw	r2,-12(fp)
8114a414:	10800217 	ldw	r2,8(r2)
8114a418:	1009883a 	mov	r4,r2
8114a41c:	11231840 	call	81123184 <strlen>
8114a420:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
8114a424:	e0bffd17 	ldw	r2,-12(fp)
8114a428:	10c00217 	ldw	r3,8(r2)
8114a42c:	e0bffe17 	ldw	r2,-8(fp)
8114a430:	10bfffc4 	addi	r2,r2,-1
8114a434:	1885883a 	add	r2,r3,r2
8114a438:	10800003 	ldbu	r2,0(r2)
8114a43c:	10803fcc 	andi	r2,r2,255
8114a440:	1080201c 	xori	r2,r2,128
8114a444:	10bfe004 	addi	r2,r2,-128
8114a448:	10800bd8 	cmpnei	r2,r2,47
8114a44c:	1000031e 	bne	r2,zero,8114a45c <alt_find_file+0x74>
    {
      len -= 1;
8114a450:	e0bffe17 	ldw	r2,-8(fp)
8114a454:	10bfffc4 	addi	r2,r2,-1
8114a458:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
8114a45c:	e0bffe17 	ldw	r2,-8(fp)
8114a460:	e0ffff17 	ldw	r3,-4(fp)
8114a464:	1885883a 	add	r2,r3,r2
8114a468:	10800003 	ldbu	r2,0(r2)
8114a46c:	10803fcc 	andi	r2,r2,255
8114a470:	1080201c 	xori	r2,r2,128
8114a474:	10bfe004 	addi	r2,r2,-128
8114a478:	10800be0 	cmpeqi	r2,r2,47
8114a47c:	1000081e 	bne	r2,zero,8114a4a0 <alt_find_file+0xb8>
8114a480:	e0bffe17 	ldw	r2,-8(fp)
8114a484:	e0ffff17 	ldw	r3,-4(fp)
8114a488:	1885883a 	add	r2,r3,r2
8114a48c:	10800003 	ldbu	r2,0(r2)
8114a490:	10803fcc 	andi	r2,r2,255
8114a494:	1080201c 	xori	r2,r2,128
8114a498:	10bfe004 	addi	r2,r2,-128
8114a49c:	10000a1e 	bne	r2,zero,8114a4c8 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
8114a4a0:	e0bffd17 	ldw	r2,-12(fp)
8114a4a4:	10800217 	ldw	r2,8(r2)
8114a4a8:	e0fffe17 	ldw	r3,-8(fp)
8114a4ac:	180d883a 	mov	r6,r3
8114a4b0:	e17fff17 	ldw	r5,-4(fp)
8114a4b4:	1009883a 	mov	r4,r2
8114a4b8:	114b1640 	call	8114b164 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
8114a4bc:	1000021e 	bne	r2,zero,8114a4c8 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
8114a4c0:	e0bffd17 	ldw	r2,-12(fp)
8114a4c4:	00000706 	br	8114a4e4 <alt_find_file+0xfc>
    }
    next = (alt_dev*) next->llist.next;
8114a4c8:	e0bffd17 	ldw	r2,-12(fp)
8114a4cc:	10800017 	ldw	r2,0(r2)
8114a4d0:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
8114a4d4:	e0fffd17 	ldw	r3,-12(fp)
8114a4d8:	d0a00b04 	addi	r2,gp,-32724
8114a4dc:	18bfcc1e 	bne	r3,r2,8114a410 <__reset+0xfb12a410>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
8114a4e0:	0005883a 	mov	r2,zero
}
8114a4e4:	e037883a 	mov	sp,fp
8114a4e8:	dfc00117 	ldw	ra,4(sp)
8114a4ec:	df000017 	ldw	fp,0(sp)
8114a4f0:	dec00204 	addi	sp,sp,8
8114a4f4:	f800283a 	ret

8114a4f8 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
8114a4f8:	defff904 	addi	sp,sp,-28
8114a4fc:	de00012e 	bgeu	sp,et,8114a504 <alt_get_fd+0xc>
8114a500:	003b68fa 	trap	3
8114a504:	dfc00615 	stw	ra,24(sp)
8114a508:	df000515 	stw	fp,20(sp)
8114a50c:	df000504 	addi	fp,sp,20
8114a510:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
8114a514:	00bffa04 	movi	r2,-24
8114a518:	e0bffc15 	stw	r2,-16(fp)
  /* 
   * Take the alt_fd_list_lock semaphore in order to avoid races when 
   * accessing the file descriptor pool.
   */
  
  ALT_SEM_PEND(alt_fd_list_lock, 0);
8114a51c:	d0a07f17 	ldw	r2,-32260(gp)
8114a520:	e0bffd15 	stw	r2,-12(fp)
8114a524:	e03ffe0d 	sth	zero,-8(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
8114a528:	e0bffe0b 	ldhu	r2,-8(fp)
8114a52c:	e0fffe84 	addi	r3,fp,-6
8114a530:	180d883a 	mov	r6,r3
8114a534:	100b883a 	mov	r5,r2
8114a538:	e13ffd17 	ldw	r4,-12(fp)
8114a53c:	113eb180 	call	8113eb18 <OSSemPend>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
8114a540:	e03ffb15 	stw	zero,-20(fp)
8114a544:	00001906 	br	8114a5ac <alt_get_fd+0xb4>
  {
    if (!alt_fd_list[i].dev)
8114a548:	00a04574 	movhi	r2,33045
8114a54c:	1087f704 	addi	r2,r2,8156
8114a550:	e0fffb17 	ldw	r3,-20(fp)
8114a554:	18c00324 	muli	r3,r3,12
8114a558:	10c5883a 	add	r2,r2,r3
8114a55c:	10800017 	ldw	r2,0(r2)
8114a560:	10000f1e 	bne	r2,zero,8114a5a0 <alt_get_fd+0xa8>
    {
      alt_fd_list[i].dev = dev;
8114a564:	00a04574 	movhi	r2,33045
8114a568:	1087f704 	addi	r2,r2,8156
8114a56c:	e0fffb17 	ldw	r3,-20(fp)
8114a570:	18c00324 	muli	r3,r3,12
8114a574:	10c5883a 	add	r2,r2,r3
8114a578:	e0ffff17 	ldw	r3,-4(fp)
8114a57c:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
8114a580:	d0e00f17 	ldw	r3,-32708(gp)
8114a584:	e0bffb17 	ldw	r2,-20(fp)
8114a588:	1880020e 	bge	r3,r2,8114a594 <alt_get_fd+0x9c>
      {
        alt_max_fd = i;
8114a58c:	e0bffb17 	ldw	r2,-20(fp)
8114a590:	d0a00f15 	stw	r2,-32708(gp)
      }
      rc = i;
8114a594:	e0bffb17 	ldw	r2,-20(fp)
8114a598:	e0bffc15 	stw	r2,-16(fp)
      goto alt_get_fd_exit;
8114a59c:	00000606 	br	8114a5b8 <alt_get_fd+0xc0>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
8114a5a0:	e0bffb17 	ldw	r2,-20(fp)
8114a5a4:	10800044 	addi	r2,r2,1
8114a5a8:	e0bffb15 	stw	r2,-20(fp)
8114a5ac:	e0bffb17 	ldw	r2,-20(fp)
8114a5b0:	10800810 	cmplti	r2,r2,32
8114a5b4:	103fe41e 	bne	r2,zero,8114a548 <__reset+0xfb12a548>
  /*
   * Release the alt_fd_list_lock semaphore now that we are done with the
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);
8114a5b8:	d0a07f17 	ldw	r2,-32260(gp)
8114a5bc:	1009883a 	mov	r4,r2
8114a5c0:	113eea00 	call	8113eea0 <OSSemPost>

  return rc;
8114a5c4:	e0bffc17 	ldw	r2,-16(fp)
}
8114a5c8:	e037883a 	mov	sp,fp
8114a5cc:	dfc00117 	ldw	ra,4(sp)
8114a5d0:	df000017 	ldw	fp,0(sp)
8114a5d4:	dec00204 	addi	sp,sp,8
8114a5d8:	f800283a 	ret

8114a5dc <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
8114a5dc:	defff904 	addi	sp,sp,-28
8114a5e0:	de00012e 	bgeu	sp,et,8114a5e8 <alt_ic_isr_register+0xc>
8114a5e4:	003b68fa 	trap	3
8114a5e8:	dfc00615 	stw	ra,24(sp)
8114a5ec:	df000515 	stw	fp,20(sp)
8114a5f0:	df000504 	addi	fp,sp,20
8114a5f4:	e13ffc15 	stw	r4,-16(fp)
8114a5f8:	e17ffd15 	stw	r5,-12(fp)
8114a5fc:	e1bffe15 	stw	r6,-8(fp)
8114a600:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
8114a604:	e0800217 	ldw	r2,8(fp)
8114a608:	d8800015 	stw	r2,0(sp)
8114a60c:	e1ffff17 	ldw	r7,-4(fp)
8114a610:	e1bffe17 	ldw	r6,-8(fp)
8114a614:	e17ffd17 	ldw	r5,-12(fp)
8114a618:	e13ffc17 	ldw	r4,-16(fp)
8114a61c:	114a7ac0 	call	8114a7ac <alt_iic_isr_register>
}  
8114a620:	e037883a 	mov	sp,fp
8114a624:	dfc00117 	ldw	ra,4(sp)
8114a628:	df000017 	ldw	fp,0(sp)
8114a62c:	dec00204 	addi	sp,sp,8
8114a630:	f800283a 	ret

8114a634 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
8114a634:	defff904 	addi	sp,sp,-28
8114a638:	de00012e 	bgeu	sp,et,8114a640 <alt_ic_irq_enable+0xc>
8114a63c:	003b68fa 	trap	3
8114a640:	df000615 	stw	fp,24(sp)
8114a644:	df000604 	addi	fp,sp,24
8114a648:	e13ffe15 	stw	r4,-8(fp)
8114a64c:	e17fff15 	stw	r5,-4(fp)
8114a650:	e0bfff17 	ldw	r2,-4(fp)
8114a654:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114a658:	0005303a 	rdctl	r2,status
8114a65c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114a660:	e0fffb17 	ldw	r3,-20(fp)
8114a664:	00bfff84 	movi	r2,-2
8114a668:	1884703a 	and	r2,r3,r2
8114a66c:	1001703a 	wrctl	status,r2
  
  return context;
8114a670:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
8114a674:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
8114a678:	00c00044 	movi	r3,1
8114a67c:	e0bffa17 	ldw	r2,-24(fp)
8114a680:	1884983a 	sll	r2,r3,r2
8114a684:	1007883a 	mov	r3,r2
8114a688:	d0a08017 	ldw	r2,-32256(gp)
8114a68c:	1884b03a 	or	r2,r3,r2
8114a690:	d0a08015 	stw	r2,-32256(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
8114a694:	d0a08017 	ldw	r2,-32256(gp)
8114a698:	100170fa 	wrctl	ienable,r2
8114a69c:	e0bffc17 	ldw	r2,-16(fp)
8114a6a0:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114a6a4:	e0bffd17 	ldw	r2,-12(fp)
8114a6a8:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
8114a6ac:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
8114a6b0:	0001883a 	nop
}
8114a6b4:	e037883a 	mov	sp,fp
8114a6b8:	df000017 	ldw	fp,0(sp)
8114a6bc:	dec00104 	addi	sp,sp,4
8114a6c0:	f800283a 	ret

8114a6c4 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
8114a6c4:	defff904 	addi	sp,sp,-28
8114a6c8:	de00012e 	bgeu	sp,et,8114a6d0 <alt_ic_irq_disable+0xc>
8114a6cc:	003b68fa 	trap	3
8114a6d0:	df000615 	stw	fp,24(sp)
8114a6d4:	df000604 	addi	fp,sp,24
8114a6d8:	e13ffe15 	stw	r4,-8(fp)
8114a6dc:	e17fff15 	stw	r5,-4(fp)
8114a6e0:	e0bfff17 	ldw	r2,-4(fp)
8114a6e4:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114a6e8:	0005303a 	rdctl	r2,status
8114a6ec:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114a6f0:	e0fffb17 	ldw	r3,-20(fp)
8114a6f4:	00bfff84 	movi	r2,-2
8114a6f8:	1884703a 	and	r2,r3,r2
8114a6fc:	1001703a 	wrctl	status,r2
  
  return context;
8114a700:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
8114a704:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
8114a708:	00c00044 	movi	r3,1
8114a70c:	e0bffa17 	ldw	r2,-24(fp)
8114a710:	1884983a 	sll	r2,r3,r2
8114a714:	0084303a 	nor	r2,zero,r2
8114a718:	1007883a 	mov	r3,r2
8114a71c:	d0a08017 	ldw	r2,-32256(gp)
8114a720:	1884703a 	and	r2,r3,r2
8114a724:	d0a08015 	stw	r2,-32256(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
8114a728:	d0a08017 	ldw	r2,-32256(gp)
8114a72c:	100170fa 	wrctl	ienable,r2
8114a730:	e0bffc17 	ldw	r2,-16(fp)
8114a734:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114a738:	e0bffd17 	ldw	r2,-12(fp)
8114a73c:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
8114a740:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
8114a744:	0001883a 	nop
}
8114a748:	e037883a 	mov	sp,fp
8114a74c:	df000017 	ldw	fp,0(sp)
8114a750:	dec00104 	addi	sp,sp,4
8114a754:	f800283a 	ret

8114a758 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
8114a758:	defffc04 	addi	sp,sp,-16
8114a75c:	de00012e 	bgeu	sp,et,8114a764 <alt_ic_irq_enabled+0xc>
8114a760:	003b68fa 	trap	3
8114a764:	df000315 	stw	fp,12(sp)
8114a768:	df000304 	addi	fp,sp,12
8114a76c:	e13ffe15 	stw	r4,-8(fp)
8114a770:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
8114a774:	000530fa 	rdctl	r2,ienable
8114a778:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
8114a77c:	00c00044 	movi	r3,1
8114a780:	e0bfff17 	ldw	r2,-4(fp)
8114a784:	1884983a 	sll	r2,r3,r2
8114a788:	1007883a 	mov	r3,r2
8114a78c:	e0bffd17 	ldw	r2,-12(fp)
8114a790:	1884703a 	and	r2,r3,r2
8114a794:	1004c03a 	cmpne	r2,r2,zero
8114a798:	10803fcc 	andi	r2,r2,255
}
8114a79c:	e037883a 	mov	sp,fp
8114a7a0:	df000017 	ldw	fp,0(sp)
8114a7a4:	dec00104 	addi	sp,sp,4
8114a7a8:	f800283a 	ret

8114a7ac <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
8114a7ac:	defff504 	addi	sp,sp,-44
8114a7b0:	de00012e 	bgeu	sp,et,8114a7b8 <alt_iic_isr_register+0xc>
8114a7b4:	003b68fa 	trap	3
8114a7b8:	dfc00a15 	stw	ra,40(sp)
8114a7bc:	df000915 	stw	fp,36(sp)
8114a7c0:	df000904 	addi	fp,sp,36
8114a7c4:	e13ffc15 	stw	r4,-16(fp)
8114a7c8:	e17ffd15 	stw	r5,-12(fp)
8114a7cc:	e1bffe15 	stw	r6,-8(fp)
8114a7d0:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
8114a7d4:	00bffa84 	movi	r2,-22
8114a7d8:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
8114a7dc:	e0bffd17 	ldw	r2,-12(fp)
8114a7e0:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
8114a7e4:	e0bff817 	ldw	r2,-32(fp)
8114a7e8:	10800808 	cmpgei	r2,r2,32
8114a7ec:	1000271e 	bne	r2,zero,8114a88c <alt_iic_isr_register+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114a7f0:	0005303a 	rdctl	r2,status
8114a7f4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114a7f8:	e0fffb17 	ldw	r3,-20(fp)
8114a7fc:	00bfff84 	movi	r2,-2
8114a800:	1884703a 	and	r2,r3,r2
8114a804:	1001703a 	wrctl	status,r2
  
  return context;
8114a808:	e0bffb17 	ldw	r2,-20(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
8114a80c:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = isr;
8114a810:	00a045f4 	movhi	r2,33047
8114a814:	10b59e04 	addi	r2,r2,-10632
8114a818:	e0fff817 	ldw	r3,-32(fp)
8114a81c:	180690fa 	slli	r3,r3,3
8114a820:	10c5883a 	add	r2,r2,r3
8114a824:	e0fffe17 	ldw	r3,-8(fp)
8114a828:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
8114a82c:	00a045f4 	movhi	r2,33047
8114a830:	10b59e04 	addi	r2,r2,-10632
8114a834:	e0fff817 	ldw	r3,-32(fp)
8114a838:	180690fa 	slli	r3,r3,3
8114a83c:	10c5883a 	add	r2,r2,r3
8114a840:	10800104 	addi	r2,r2,4
8114a844:	e0ffff17 	ldw	r3,-4(fp)
8114a848:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
8114a84c:	e0bffe17 	ldw	r2,-8(fp)
8114a850:	10000526 	beq	r2,zero,8114a868 <alt_iic_isr_register+0xbc>
8114a854:	e0bff817 	ldw	r2,-32(fp)
8114a858:	100b883a 	mov	r5,r2
8114a85c:	e13ffc17 	ldw	r4,-16(fp)
8114a860:	114a6340 	call	8114a634 <alt_ic_irq_enable>
8114a864:	00000406 	br	8114a878 <alt_iic_isr_register+0xcc>
8114a868:	e0bff817 	ldw	r2,-32(fp)
8114a86c:	100b883a 	mov	r5,r2
8114a870:	e13ffc17 	ldw	r4,-16(fp)
8114a874:	114a6c40 	call	8114a6c4 <alt_ic_irq_disable>
8114a878:	e0bff715 	stw	r2,-36(fp)
8114a87c:	e0bffa17 	ldw	r2,-24(fp)
8114a880:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114a884:	e0bff917 	ldw	r2,-28(fp)
8114a888:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
8114a88c:	e0bff717 	ldw	r2,-36(fp)
}
8114a890:	e037883a 	mov	sp,fp
8114a894:	dfc00117 	ldw	ra,4(sp)
8114a898:	df000017 	ldw	fp,0(sp)
8114a89c:	dec00204 	addi	sp,sp,8
8114a8a0:	f800283a 	ret

8114a8a4 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
8114a8a4:	defff904 	addi	sp,sp,-28
8114a8a8:	de00012e 	bgeu	sp,et,8114a8b0 <alt_open_fd+0xc>
8114a8ac:	003b68fa 	trap	3
8114a8b0:	dfc00615 	stw	ra,24(sp)
8114a8b4:	df000515 	stw	fp,20(sp)
8114a8b8:	df000504 	addi	fp,sp,20
8114a8bc:	e13ffc15 	stw	r4,-16(fp)
8114a8c0:	e17ffd15 	stw	r5,-12(fp)
8114a8c4:	e1bffe15 	stw	r6,-8(fp)
8114a8c8:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
8114a8cc:	e1bfff17 	ldw	r6,-4(fp)
8114a8d0:	e17ffe17 	ldw	r5,-8(fp)
8114a8d4:	e13ffd17 	ldw	r4,-12(fp)
8114a8d8:	11377540 	call	81137754 <open>
8114a8dc:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
8114a8e0:	e0bffb17 	ldw	r2,-20(fp)
8114a8e4:	10001c16 	blt	r2,zero,8114a958 <alt_open_fd+0xb4>
  {
    fd->dev      = alt_fd_list[old].dev;
8114a8e8:	00a04574 	movhi	r2,33045
8114a8ec:	1087f704 	addi	r2,r2,8156
8114a8f0:	e0fffb17 	ldw	r3,-20(fp)
8114a8f4:	18c00324 	muli	r3,r3,12
8114a8f8:	10c5883a 	add	r2,r2,r3
8114a8fc:	10c00017 	ldw	r3,0(r2)
8114a900:	e0bffc17 	ldw	r2,-16(fp)
8114a904:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
8114a908:	00a04574 	movhi	r2,33045
8114a90c:	1087f704 	addi	r2,r2,8156
8114a910:	e0fffb17 	ldw	r3,-20(fp)
8114a914:	18c00324 	muli	r3,r3,12
8114a918:	10c5883a 	add	r2,r2,r3
8114a91c:	10800104 	addi	r2,r2,4
8114a920:	10c00017 	ldw	r3,0(r2)
8114a924:	e0bffc17 	ldw	r2,-16(fp)
8114a928:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
8114a92c:	00a04574 	movhi	r2,33045
8114a930:	1087f704 	addi	r2,r2,8156
8114a934:	e0fffb17 	ldw	r3,-20(fp)
8114a938:	18c00324 	muli	r3,r3,12
8114a93c:	10c5883a 	add	r2,r2,r3
8114a940:	10800204 	addi	r2,r2,8
8114a944:	10c00017 	ldw	r3,0(r2)
8114a948:	e0bffc17 	ldw	r2,-16(fp)
8114a94c:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
8114a950:	e13ffb17 	ldw	r4,-20(fp)
8114a954:	11379f80 	call	811379f8 <alt_release_fd>
  }
} 
8114a958:	0001883a 	nop
8114a95c:	e037883a 	mov	sp,fp
8114a960:	dfc00117 	ldw	ra,4(sp)
8114a964:	df000017 	ldw	fp,0(sp)
8114a968:	dec00204 	addi	sp,sp,8
8114a96c:	f800283a 	ret

8114a970 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
8114a970:	defffb04 	addi	sp,sp,-20
8114a974:	de00012e 	bgeu	sp,et,8114a97c <alt_io_redirect+0xc>
8114a978:	003b68fa 	trap	3
8114a97c:	dfc00415 	stw	ra,16(sp)
8114a980:	df000315 	stw	fp,12(sp)
8114a984:	df000304 	addi	fp,sp,12
8114a988:	e13ffd15 	stw	r4,-12(fp)
8114a98c:	e17ffe15 	stw	r5,-8(fp)
8114a990:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
8114a994:	01c07fc4 	movi	r7,511
8114a998:	01800044 	movi	r6,1
8114a99c:	e17ffd17 	ldw	r5,-12(fp)
8114a9a0:	01204574 	movhi	r4,33045
8114a9a4:	2107fa04 	addi	r4,r4,8168
8114a9a8:	114a8a40 	call	8114a8a4 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
8114a9ac:	01c07fc4 	movi	r7,511
8114a9b0:	000d883a 	mov	r6,zero
8114a9b4:	e17ffe17 	ldw	r5,-8(fp)
8114a9b8:	01204574 	movhi	r4,33045
8114a9bc:	2107f704 	addi	r4,r4,8156
8114a9c0:	114a8a40 	call	8114a8a4 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
8114a9c4:	01c07fc4 	movi	r7,511
8114a9c8:	01800044 	movi	r6,1
8114a9cc:	e17fff17 	ldw	r5,-4(fp)
8114a9d0:	01204574 	movhi	r4,33045
8114a9d4:	2107fd04 	addi	r4,r4,8180
8114a9d8:	114a8a40 	call	8114a8a4 <alt_open_fd>
}  
8114a9dc:	0001883a 	nop
8114a9e0:	e037883a 	mov	sp,fp
8114a9e4:	dfc00117 	ldw	ra,4(sp)
8114a9e8:	df000017 	ldw	fp,0(sp)
8114a9ec:	dec00204 	addi	sp,sp,8
8114a9f0:	f800283a 	ret

8114a9f4 <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
8114a9f4:	defff204 	addi	sp,sp,-56
8114a9f8:	de00012e 	bgeu	sp,et,8114aa00 <alt_printf+0xc>
8114a9fc:	003b68fa 	trap	3
8114aa00:	dfc00a15 	stw	ra,40(sp)
8114aa04:	df000915 	stw	fp,36(sp)
8114aa08:	df000904 	addi	fp,sp,36
8114aa0c:	e13fff15 	stw	r4,-4(fp)
8114aa10:	e1400215 	stw	r5,8(fp)
8114aa14:	e1800315 	stw	r6,12(fp)
8114aa18:	e1c00415 	stw	r7,16(fp)
	va_list args;
	va_start(args, fmt);
8114aa1c:	e0800204 	addi	r2,fp,8
8114aa20:	e0bffe15 	stw	r2,-8(fp)
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
8114aa24:	e0bfff17 	ldw	r2,-4(fp)
8114aa28:	e0bff715 	stw	r2,-36(fp)
    while ((c = *w++) != 0)
8114aa2c:	00006f06 	br	8114abec <alt_printf+0x1f8>
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
8114aa30:	e0bff807 	ldb	r2,-32(fp)
8114aa34:	10800960 	cmpeqi	r2,r2,37
8114aa38:	1000041e 	bne	r2,zero,8114aa4c <alt_printf+0x58>
        {
            alt_putchar(c);
8114aa3c:	e0bff807 	ldb	r2,-32(fp)
8114aa40:	1009883a 	mov	r4,r2
8114aa44:	114ac280 	call	8114ac28 <alt_putchar>
8114aa48:	00006806 	br	8114abec <alt_printf+0x1f8>
        }
        else
        {
            /* Get format character.  If none     */
            /* available, processing is complete. */
            if ((c = *w++) != 0)
8114aa4c:	e0bff717 	ldw	r2,-36(fp)
8114aa50:	10c00044 	addi	r3,r2,1
8114aa54:	e0fff715 	stw	r3,-36(fp)
8114aa58:	10800003 	ldbu	r2,0(r2)
8114aa5c:	e0bff805 	stb	r2,-32(fp)
8114aa60:	e0bff807 	ldb	r2,-32(fp)
8114aa64:	10006926 	beq	r2,zero,8114ac0c <alt_printf+0x218>
            {
                if (c == '%')
8114aa68:	e0bff807 	ldb	r2,-32(fp)
8114aa6c:	10800958 	cmpnei	r2,r2,37
8114aa70:	1000041e 	bne	r2,zero,8114aa84 <alt_printf+0x90>
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
8114aa74:	e0bff807 	ldb	r2,-32(fp)
8114aa78:	1009883a 	mov	r4,r2
8114aa7c:	114ac280 	call	8114ac28 <alt_putchar>
8114aa80:	00005a06 	br	8114abec <alt_printf+0x1f8>
                } 
                else if (c == 'c')
8114aa84:	e0bff807 	ldb	r2,-32(fp)
8114aa88:	108018d8 	cmpnei	r2,r2,99
8114aa8c:	1000081e 	bne	r2,zero,8114aab0 <alt_printf+0xbc>
                {
                    int v = va_arg(args, int);
8114aa90:	e0bffe17 	ldw	r2,-8(fp)
8114aa94:	10c00104 	addi	r3,r2,4
8114aa98:	e0fffe15 	stw	r3,-8(fp)
8114aa9c:	10800017 	ldw	r2,0(r2)
8114aaa0:	e0bffd15 	stw	r2,-12(fp)
                    alt_putchar(v);
8114aaa4:	e13ffd17 	ldw	r4,-12(fp)
8114aaa8:	114ac280 	call	8114ac28 <alt_putchar>
8114aaac:	00004f06 	br	8114abec <alt_printf+0x1f8>
                }
                else if (c == 'x')
8114aab0:	e0bff807 	ldb	r2,-32(fp)
8114aab4:	10801e18 	cmpnei	r2,r2,120
8114aab8:	1000341e 	bne	r2,zero,8114ab8c <alt_printf+0x198>
                {
                    /* Process hexadecimal number format. */
                    unsigned long v = va_arg(args, unsigned long);
8114aabc:	e0bffe17 	ldw	r2,-8(fp)
8114aac0:	10c00104 	addi	r3,r2,4
8114aac4:	e0fffe15 	stw	r3,-8(fp)
8114aac8:	10800017 	ldw	r2,0(r2)
8114aacc:	e0bffb15 	stw	r2,-20(fp)
                    unsigned long digit;
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
8114aad0:	e0bffb17 	ldw	r2,-20(fp)
8114aad4:	1000031e 	bne	r2,zero,8114aae4 <alt_printf+0xf0>
                    {
                        alt_putchar('0');
8114aad8:	01000c04 	movi	r4,48
8114aadc:	114ac280 	call	8114ac28 <alt_putchar>
                        continue;
8114aae0:	00004206 	br	8114abec <alt_printf+0x1f8>
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
8114aae4:	00800704 	movi	r2,28
8114aae8:	e0bff915 	stw	r2,-28(fp)
                    while (!(v & (0xF << digit_shift)))
8114aaec:	00000306 	br	8114aafc <alt_printf+0x108>
                        digit_shift -= 4;
8114aaf0:	e0bff917 	ldw	r2,-28(fp)
8114aaf4:	10bfff04 	addi	r2,r2,-4
8114aaf8:	e0bff915 	stw	r2,-28(fp)
                        continue;
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
8114aafc:	00c003c4 	movi	r3,15
8114ab00:	e0bff917 	ldw	r2,-28(fp)
8114ab04:	1884983a 	sll	r2,r3,r2
8114ab08:	1007883a 	mov	r3,r2
8114ab0c:	e0bffb17 	ldw	r2,-20(fp)
8114ab10:	1884703a 	and	r2,r3,r2
8114ab14:	103ff626 	beq	r2,zero,8114aaf0 <__reset+0xfb12aaf0>
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
8114ab18:	00001906 	br	8114ab80 <alt_printf+0x18c>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
8114ab1c:	00c003c4 	movi	r3,15
8114ab20:	e0bff917 	ldw	r2,-28(fp)
8114ab24:	1884983a 	sll	r2,r3,r2
8114ab28:	1007883a 	mov	r3,r2
8114ab2c:	e0bffb17 	ldw	r2,-20(fp)
8114ab30:	1886703a 	and	r3,r3,r2
8114ab34:	e0bff917 	ldw	r2,-28(fp)
8114ab38:	1884d83a 	srl	r2,r3,r2
8114ab3c:	e0bffc15 	stw	r2,-16(fp)
                        if (digit <= 9)
8114ab40:	e0bffc17 	ldw	r2,-16(fp)
8114ab44:	108002a8 	cmpgeui	r2,r2,10
8114ab48:	1000041e 	bne	r2,zero,8114ab5c <alt_printf+0x168>
                            c = '0' + digit;
8114ab4c:	e0bffc17 	ldw	r2,-16(fp)
8114ab50:	10800c04 	addi	r2,r2,48
8114ab54:	e0bff805 	stb	r2,-32(fp)
8114ab58:	00000306 	br	8114ab68 <alt_printf+0x174>
                        else
                            c = 'a' + digit - 10;
8114ab5c:	e0bffc17 	ldw	r2,-16(fp)
8114ab60:	108015c4 	addi	r2,r2,87
8114ab64:	e0bff805 	stb	r2,-32(fp)
                        alt_putchar(c);
8114ab68:	e0bff807 	ldb	r2,-32(fp)
8114ab6c:	1009883a 	mov	r4,r2
8114ab70:	114ac280 	call	8114ac28 <alt_putchar>
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
8114ab74:	e0bff917 	ldw	r2,-28(fp)
8114ab78:	10bfff04 	addi	r2,r2,-4
8114ab7c:	e0bff915 	stw	r2,-28(fp)
8114ab80:	e0bff917 	ldw	r2,-28(fp)
8114ab84:	103fe50e 	bge	r2,zero,8114ab1c <__reset+0xfb12ab1c>
8114ab88:	00001806 	br	8114abec <alt_printf+0x1f8>
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
8114ab8c:	e0bff807 	ldb	r2,-32(fp)
8114ab90:	10801cd8 	cmpnei	r2,r2,115
8114ab94:	1000151e 	bne	r2,zero,8114abec <alt_printf+0x1f8>
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);
8114ab98:	e0bffe17 	ldw	r2,-8(fp)
8114ab9c:	10c00104 	addi	r3,r2,4
8114aba0:	e0fffe15 	stw	r3,-8(fp)
8114aba4:	10800017 	ldw	r2,0(r2)
8114aba8:	e0bffa15 	stw	r2,-24(fp)

                    while(*s)
8114abac:	00000906 	br	8114abd4 <alt_printf+0x1e0>
                      alt_putchar(*s++);
8114abb0:	e0bffa17 	ldw	r2,-24(fp)
8114abb4:	10c00044 	addi	r3,r2,1
8114abb8:	e0fffa15 	stw	r3,-24(fp)
8114abbc:	10800003 	ldbu	r2,0(r2)
8114abc0:	10803fcc 	andi	r2,r2,255
8114abc4:	1080201c 	xori	r2,r2,128
8114abc8:	10bfe004 	addi	r2,r2,-128
8114abcc:	1009883a 	mov	r4,r2
8114abd0:	114ac280 	call	8114ac28 <alt_putchar>
                else if (c == 's')
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);

                    while(*s)
8114abd4:	e0bffa17 	ldw	r2,-24(fp)
8114abd8:	10800003 	ldbu	r2,0(r2)
8114abdc:	10803fcc 	andi	r2,r2,255
8114abe0:	1080201c 	xori	r2,r2,128
8114abe4:	10bfe004 	addi	r2,r2,-128
8114abe8:	103ff11e 	bne	r2,zero,8114abb0 <__reset+0xfb12abb0>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
8114abec:	e0bff717 	ldw	r2,-36(fp)
8114abf0:	10c00044 	addi	r3,r2,1
8114abf4:	e0fff715 	stw	r3,-36(fp)
8114abf8:	10800003 	ldbu	r2,0(r2)
8114abfc:	e0bff805 	stb	r2,-32(fp)
8114ac00:	e0bff807 	ldb	r2,-32(fp)
8114ac04:	103f8a1e 	bne	r2,zero,8114aa30 <__reset+0xfb12aa30>
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
8114ac08:	00000106 	br	8114ac10 <alt_printf+0x21c>
                      alt_putchar(*s++);
                }
            }
            else
            {
                break;
8114ac0c:	0001883a 	nop
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
8114ac10:	0001883a 	nop
8114ac14:	e037883a 	mov	sp,fp
8114ac18:	dfc00117 	ldw	ra,4(sp)
8114ac1c:	df000017 	ldw	fp,0(sp)
8114ac20:	dec00504 	addi	sp,sp,20
8114ac24:	f800283a 	ret

8114ac28 <alt_putchar>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
8114ac28:	defffd04 	addi	sp,sp,-12
8114ac2c:	de00012e 	bgeu	sp,et,8114ac34 <alt_putchar+0xc>
8114ac30:	003b68fa 	trap	3
8114ac34:	dfc00215 	stw	ra,8(sp)
8114ac38:	df000115 	stw	fp,4(sp)
8114ac3c:	df000104 	addi	fp,sp,4
8114ac40:	e13fff15 	stw	r4,-4(fp)
    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
        return -1;
    }
    return c;
#else
    return putchar(c);
8114ac44:	d0a00517 	ldw	r2,-32748(gp)
8114ac48:	10800217 	ldw	r2,8(r2)
8114ac4c:	100b883a 	mov	r5,r2
8114ac50:	e13fff17 	ldw	r4,-4(fp)
8114ac54:	1122a940 	call	81122a94 <putc>
#endif
#endif
}
8114ac58:	e037883a 	mov	sp,fp
8114ac5c:	dfc00117 	ldw	ra,4(sp)
8114ac60:	df000017 	ldw	fp,0(sp)
8114ac64:	dec00204 	addi	sp,sp,8
8114ac68:	f800283a 	ret

8114ac6c <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
8114ac6c:	deffff04 	addi	sp,sp,-4
8114ac70:	de00012e 	bgeu	sp,et,8114ac78 <altera_nios2_gen2_irq_init+0xc>
8114ac74:	003b68fa 	trap	3
8114ac78:	df000015 	stw	fp,0(sp)
8114ac7c:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
8114ac80:	000170fa 	wrctl	ienable,zero
}
8114ac84:	0001883a 	nop
8114ac88:	e037883a 	mov	sp,fp
8114ac8c:	df000017 	ldw	fp,0(sp)
8114ac90:	dec00104 	addi	sp,sp,4
8114ac94:	f800283a 	ret

8114ac98 <OSCtxSw>:

      /* 
       * Save the remaining registers to the stack. 
       */

      addi sp, sp, -44
8114ac98:	defff504 	addi	sp,sp,-44

#ifdef ALT_STACK_CHECK

      bltu  sp, et, .Lstack_overflow
8114ac9c:	de002436 	bltu	sp,et,8114ad30 <OSCtxSw+0x98>

#endif

#if OS_THREAD_SAFE_NEWLIB
      ldw r3, %gprel(_impure_ptr)(gp)   /* load the pointer */
8114aca0:	d0e00517 	ldw	r3,-32748(gp)
#endif /* OS_THREAD_SAFE_NEWLIB */

      ldw r4, %gprel(OSTCBCur)(gp)
8114aca4:	d120a217 	ldw	r4,-32120(gp)

      stw ra,  0(sp)
8114aca8:	dfc00015 	stw	ra,0(sp)
      stw fp,  4(sp)
8114acac:	df000115 	stw	fp,4(sp)
      stw r23, 8(sp)
8114acb0:	ddc00215 	stw	r23,8(sp)
      stw r22, 12(sp)
8114acb4:	dd800315 	stw	r22,12(sp)
      stw r21, 16(sp)
8114acb8:	dd400415 	stw	r21,16(sp)
      stw r20, 20(sp)
8114acbc:	dd000515 	stw	r20,20(sp)
      stw r19, 24(sp)
8114acc0:	dcc00615 	stw	r19,24(sp)
      stw r18, 28(sp)
8114acc4:	dc800715 	stw	r18,28(sp)
      stw r17, 32(sp)
8114acc8:	dc400815 	stw	r17,32(sp)
      stw r16, 36(sp)
8114accc:	dc000915 	stw	r16,36(sp)
       * store the current value of _impure_ptr so it can be restored
       * later; _impure_ptr is asigned on a per task basis. It is used
       * by Newlib to achieve reentrancy.	
       */

      stw r3, 40(sp)                  /* save the impure pointer */
8114acd0:	d8c00a15 	stw	r3,40(sp)
      /* 
       * Save the current tasks stack pointer into the current tasks OS_TCB.
       * i.e. OSTCBCur->OSTCBStkPtr = sp;
       */

      stw sp, (r4)                  /* save the stack pointer (OSTCBStkPtr */
8114acd4:	26c00015 	stw	sp,0(r4)

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
8114acd8:	114af340 	call	8114af34 <OSTaskSwHook>
      /*
       * OSTCBCur = OSTCBHighRdy; 
       * OSPrioCur = OSPrioHighRdy; 
       */

      ldw r4, %gprel(OSTCBHighRdy)(gp)
8114acdc:	d1209c17 	ldw	r4,-32144(gp)
      ldb r5, %gprel(OSPrioHighRdy)(gp)
8114ace0:	d1609387 	ldb	r5,-32178(gp)

      stw r4, %gprel(OSTCBCur)(gp)     /* set the current task to be the new task */
8114ace4:	d120a215 	stw	r4,-32120(gp)
      stb r5, %gprel(OSPrioCur)(gp)    /* store the new task's priority as the current */
8114ace8:	d16093c5 	stb	r5,-32177(gp)

      /*
       * Set the stack pointer to point to the new task's stack
       */

      ldw sp, (r4) /* the stack pointer is the first entry in the OS_TCB structure */
8114acec:	26c00017 	ldw	sp,0(r4)
      
#if defined(ALT_STACK_CHECK) && (OS_TASK_CREATE_EXT_EN > 0)

      ldw et, 8(r4)                  /* load the new stack limit */
8114acf0:	26000217 	ldw	et,8(r4)
      /*
       * restore the value of _impure_ptr ; _impure_ptr is asigned on a 
       * per task basis. It is used by Newlib to achieve reentrancy.	
       */

      ldw r3, 40(sp)                  /* load the new impure pointer */
8114acf4:	d8c00a17 	ldw	r3,40(sp)

      /*
       * Restore the saved registers for the new task.
       */

      ldw ra,  0(sp)
8114acf8:	dfc00017 	ldw	ra,0(sp)
      ldw fp,  4(sp)
8114acfc:	df000117 	ldw	fp,4(sp)
      ldw r23, 8(sp)
8114ad00:	ddc00217 	ldw	r23,8(sp)
      ldw r22, 12(sp)
8114ad04:	dd800317 	ldw	r22,12(sp)
      ldw r21, 16(sp)
8114ad08:	dd400417 	ldw	r21,16(sp)
      ldw r20, 20(sp)
8114ad0c:	dd000517 	ldw	r20,20(sp)
      ldw r19, 24(sp)
8114ad10:	dcc00617 	ldw	r19,24(sp)
      ldw r18, 28(sp)
8114ad14:	dc800717 	ldw	r18,28(sp)
      ldw r17, 32(sp)
8114ad18:	dc400817 	ldw	r17,32(sp)
      ldw r16, 36(sp)
8114ad1c:	dc000917 	ldw	r16,36(sp)

#if OS_THREAD_SAFE_NEWLIB

      stw r3, %gprel(_impure_ptr)(gp) /* update _impure_ptr */
8114ad20:	d0e00515 	stw	r3,-32748(gp)

#endif /* OS_THREAD_SAFE_NEWLIB */

#if defined(ALT_STACK_CHECK) && (OS_TASK_CREATE_EXT_EN > 0)

      stw et, %gprel(alt_stack_limit_value)(gp)
8114ad24:	d6200015 	stw	et,-32768(gp)

#endif

      addi sp, sp, 44
8114ad28:	dec00b04 	addi	sp,sp,44

      /*
       * resume execution of the new task.
       */

      ret
8114ad2c:	f800283a 	ret

#ifdef ALT_STACK_CHECK

.Lstack_overflow:
        break 3
8114ad30:	003da0fa 	break	3

8114ad34 <OSStartHighRdy>:

      /*
       * disable interrupts so that the scheduler doesn't run while
       * we're initialising this task.
       */  
      rdctl r18, status
8114ad34:	0025303a 	rdctl	r18,status
      subi  r17, zero, 2   /* r17 = 0xfffffffe */
8114ad38:	047fff84 	movi	r17,-2
      and   r18, r18, r17
8114ad3c:	9464703a 	and	r18,r18,r17
      wrctl status, r18
8114ad40:	9001703a 	wrctl	status,r18

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
8114ad44:	114af340 	call	8114af34 <OSTaskSwHook>

      /* 
       * set OSRunning = TRUE.
       */

      movi r18, 1                    /* set r18 to the value 'TRUE' */
8114ad48:	04800044 	movi	r18,1
      stb r18, %gprel(OSRunning)(gp) /* save this to OSRunning */
8114ad4c:	d4a09105 	stb	r18,-32188(gp)

      /*
       * start execution of the new task.
       */

      br 9b
8114ad50:	003fe206 	br	8114acdc <__reset+0xfb12acdc>

8114ad54 <OSStartTsk>:

OSStartTsk:
      /* This instruction is never executed.  Its here to make the
       * backtrace work right 
       */
      movi sp, 0
8114ad54:	06c00004 	movi	sp,0

      /* Enable interrupts */
      rdctl r2, status
8114ad58:	0005303a 	rdctl	r2,status
      ori   r2, r2, 0x1
8114ad5c:	10800054 	ori	r2,r2,1
      wrctl status, r2
8114ad60:	1001703a 	wrctl	status,r2

      ldw r2, 4(sp)
8114ad64:	d8800117 	ldw	r2,4(sp)
      ldw r4, 0(sp)
8114ad68:	d9000017 	ldw	r4,0(sp)

      addi sp, sp, 8
8114ad6c:	dec00204 	addi	sp,sp,8

      callr r2
8114ad70:	103ee83a 	callr	r2

      nop
8114ad74:	0001883a 	nop

8114ad78 <OSTaskStkInit>:
 *              been placed on the stack in the proper order.
 *
 ***********************************************************************************************/

OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *pstk, INT16U opt)
{
8114ad78:	defff704 	addi	sp,sp,-36
8114ad7c:	de00012e 	bgeu	sp,et,8114ad84 <OSTaskStkInit+0xc>
8114ad80:	003b68fa 	trap	3
8114ad84:	dfc00815 	stw	ra,32(sp)
8114ad88:	df000715 	stw	fp,28(sp)
8114ad8c:	df000704 	addi	fp,sp,28
8114ad90:	e13ffc15 	stw	r4,-16(fp)
8114ad94:	e17ffd15 	stw	r5,-12(fp)
8114ad98:	e1bffe15 	stw	r6,-8(fp)
8114ad9c:	3805883a 	mov	r2,r7
8114ada0:	e0bfff0d 	sth	r2,-4(fp)
    * create and initialise the impure pointer used for Newlib thread local storage.
    * This is only done if the C library is being used in a thread safe mode. Otherwise
    * a single reent structure is used for all threads, which saves memory.
    */

   local_impure_ptr = (struct _reent*)((((INT32U)(pstk)) & ~0x3) - sizeof(struct _reent));
8114ada4:	e0fffe17 	ldw	r3,-8(fp)
8114ada8:	00bfff04 	movi	r2,-4
8114adac:	1884703a 	and	r2,r3,r2
8114adb0:	10bef704 	addi	r2,r2,-1060
8114adb4:	e0bff915 	stw	r2,-28(fp)

   _REENT_INIT_PTR (local_impure_ptr);
8114adb8:	01810904 	movi	r6,1060
8114adbc:	000b883a 	mov	r5,zero
8114adc0:	e13ff917 	ldw	r4,-28(fp)
8114adc4:	11227e00 	call	811227e0 <memset>
8114adc8:	e0bff917 	ldw	r2,-28(fp)
8114adcc:	10c0bb04 	addi	r3,r2,748
8114add0:	e0bff917 	ldw	r2,-28(fp)
8114add4:	10c00115 	stw	r3,4(r2)
8114add8:	e0bff917 	ldw	r2,-28(fp)
8114addc:	10c0d504 	addi	r3,r2,852
8114ade0:	e0bff917 	ldw	r2,-28(fp)
8114ade4:	10c00215 	stw	r3,8(r2)
8114ade8:	e0bff917 	ldw	r2,-28(fp)
8114adec:	10c0ef04 	addi	r3,r2,956
8114adf0:	e0bff917 	ldw	r2,-28(fp)
8114adf4:	10c00315 	stw	r3,12(r2)
8114adf8:	e0fff917 	ldw	r3,-28(fp)
8114adfc:	00a04574 	movhi	r2,33045
8114ae00:	10859004 	addi	r2,r2,5696
8114ae04:	18800d15 	stw	r2,52(r3)
8114ae08:	e0bff917 	ldw	r2,-28(fp)
8114ae0c:	00c00044 	movi	r3,1
8114ae10:	10c02915 	stw	r3,164(r2)
8114ae14:	10002a15 	stw	zero,168(r2)
8114ae18:	e0bff917 	ldw	r2,-28(fp)
8114ae1c:	00ccc384 	movi	r3,13070
8114ae20:	10c02b0d 	sth	r3,172(r2)
8114ae24:	e0bff917 	ldw	r2,-28(fp)
8114ae28:	00eaf344 	movi	r3,-21555
8114ae2c:	10c02b8d 	sth	r3,174(r2)
8114ae30:	e0bff917 	ldw	r2,-28(fp)
8114ae34:	00c48d04 	movi	r3,4660
8114ae38:	10c02c0d 	sth	r3,176(r2)
8114ae3c:	e0bff917 	ldw	r2,-28(fp)
8114ae40:	00f99b44 	movi	r3,-6547
8114ae44:	10c02c8d 	sth	r3,178(r2)
8114ae48:	e0bff917 	ldw	r2,-28(fp)
8114ae4c:	00f7bb04 	movi	r3,-8468
8114ae50:	10c02d0d 	sth	r3,180(r2)
8114ae54:	e0bff917 	ldw	r2,-28(fp)
8114ae58:	00c00144 	movi	r3,5
8114ae5c:	10c02d8d 	sth	r3,182(r2)
8114ae60:	e0bff917 	ldw	r2,-28(fp)
8114ae64:	00c002c4 	movi	r3,11
8114ae68:	10c02e0d 	sth	r3,184(r2)
   /* 
    * create a stack frame at the top of the stack (leaving space for the 
    * reentrant data structure).
    */

   frame_pointer = (INT32U*) local_impure_ptr;
8114ae6c:	e0bff917 	ldw	r2,-28(fp)
8114ae70:	e0bffa15 	stw	r2,-24(fp)
#else
   frame_pointer =   (INT32U*) (((INT32U)(pstk)) & ~0x3);
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk = frame_pointer - 13;
8114ae74:	e0bffa17 	ldw	r2,-24(fp)
8114ae78:	10bff304 	addi	r2,r2,-52
8114ae7c:	e0bffb15 	stw	r2,-20(fp)

   /* Now fill the stack frame. */

   stk[12] = (INT32U)task;            /* task address (ra) */
8114ae80:	e0bffb17 	ldw	r2,-20(fp)
8114ae84:	10800c04 	addi	r2,r2,48
8114ae88:	e0fffc17 	ldw	r3,-16(fp)
8114ae8c:	10c00015 	stw	r3,0(r2)
   stk[11] = (INT32U) pdata;          /* first register argument (r4) */
8114ae90:	e0bffb17 	ldw	r2,-20(fp)
8114ae94:	10800b04 	addi	r2,r2,44
8114ae98:	e0fffd17 	ldw	r3,-12(fp)
8114ae9c:	10c00015 	stw	r3,0(r2)

#if OS_THREAD_SAFE_NEWLIB
   stk[10] = (INT32U) local_impure_ptr; /* value of _impure_ptr for this thread */
8114aea0:	e0bffb17 	ldw	r2,-20(fp)
8114aea4:	10800a04 	addi	r2,r2,40
8114aea8:	e0fff917 	ldw	r3,-28(fp)
8114aeac:	10c00015 	stw	r3,0(r2)
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk[0]  = ((INT32U)&OSStartTsk) + 4;/* exception return address (ea) */  
8114aeb0:	00a04574 	movhi	r2,33045
8114aeb4:	10ab5504 	addi	r2,r2,-21164
8114aeb8:	10c00104 	addi	r3,r2,4
8114aebc:	e0bffb17 	ldw	r2,-20(fp)
8114aec0:	10c00015 	stw	r3,0(r2)
    */
   __asm__ (".set OSTCBNext_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBNext)));
   __asm__ (".set OSTCBPrio_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBPrio)));
   __asm__ (".set OSTCBStkPtr_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBStkPtr)));
  
   return((OS_STK *)stk);
8114aec4:	e0bffb17 	ldw	r2,-20(fp)
}
8114aec8:	e037883a 	mov	sp,fp
8114aecc:	dfc00117 	ldw	ra,4(sp)
8114aed0:	df000017 	ldw	fp,0(sp)
8114aed4:	dec00204 	addi	sp,sp,8
8114aed8:	f800283a 	ret

8114aedc <OSTaskCreateHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskCreateHook (OS_TCB *ptcb)
{
8114aedc:	defffe04 	addi	sp,sp,-8
8114aee0:	de00012e 	bgeu	sp,et,8114aee8 <OSTaskCreateHook+0xc>
8114aee4:	003b68fa 	trap	3
8114aee8:	df000115 	stw	fp,4(sp)
8114aeec:	df000104 	addi	fp,sp,4
8114aef0:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning */
}
8114aef4:	0001883a 	nop
8114aef8:	e037883a 	mov	sp,fp
8114aefc:	df000017 	ldw	fp,0(sp)
8114af00:	dec00104 	addi	sp,sp,4
8114af04:	f800283a 	ret

8114af08 <OSTaskDelHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskDelHook (OS_TCB *ptcb)
{
8114af08:	defffe04 	addi	sp,sp,-8
8114af0c:	de00012e 	bgeu	sp,et,8114af14 <OSTaskDelHook+0xc>
8114af10:	003b68fa 	trap	3
8114af14:	df000115 	stw	fp,4(sp)
8114af18:	df000104 	addi	fp,sp,4
8114af1c:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
8114af20:	0001883a 	nop
8114af24:	e037883a 	mov	sp,fp
8114af28:	df000017 	ldw	fp,0(sp)
8114af2c:	dec00104 	addi	sp,sp,4
8114af30:	f800283a 	ret

8114af34 <OSTaskSwHook>:
*                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
*                 task being switched out (i.e. the preempted task).
*********************************************************************************************************
*/
void OSTaskSwHook (void)
{
8114af34:	deffff04 	addi	sp,sp,-4
8114af38:	de00012e 	bgeu	sp,et,8114af40 <OSTaskSwHook+0xc>
8114af3c:	003b68fa 	trap	3
8114af40:	df000015 	stw	fp,0(sp)
8114af44:	d839883a 	mov	fp,sp
}
8114af48:	0001883a 	nop
8114af4c:	e037883a 	mov	sp,fp
8114af50:	df000017 	ldw	fp,0(sp)
8114af54:	dec00104 	addi	sp,sp,4
8114af58:	f800283a 	ret

8114af5c <OSTaskStatHook>:
*
* Arguments  : none
*********************************************************************************************************
*/
void OSTaskStatHook (void)
{
8114af5c:	deffff04 	addi	sp,sp,-4
8114af60:	de00012e 	bgeu	sp,et,8114af68 <OSTaskStatHook+0xc>
8114af64:	003b68fa 	trap	3
8114af68:	df000015 	stw	fp,0(sp)
8114af6c:	d839883a 	mov	fp,sp
}
8114af70:	0001883a 	nop
8114af74:	e037883a 	mov	sp,fp
8114af78:	df000017 	ldw	fp,0(sp)
8114af7c:	dec00104 	addi	sp,sp,4
8114af80:	f800283a 	ret

8114af84 <OSTimeTickHook>:
#ifdef ALT_INICHE
void cticks_hook(void);
#endif

void OSTimeTickHook (void)
{
8114af84:	defffe04 	addi	sp,sp,-8
8114af88:	de00012e 	bgeu	sp,et,8114af90 <OSTimeTickHook+0xc>
8114af8c:	003b68fa 	trap	3
8114af90:	dfc00115 	stw	ra,4(sp)
8114af94:	df000015 	stw	fp,0(sp)
8114af98:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr++;
8114af9c:	d0a0b60b 	ldhu	r2,-32040(gp)
8114afa0:	10800044 	addi	r2,r2,1
8114afa4:	d0a0b60d 	sth	r2,-32040(gp)
    if (OSTmrCtr >= (OS_TICKS_PER_SEC / OS_TMR_CFG_TICKS_PER_SEC)) {
8114afa8:	d0a0b60b 	ldhu	r2,-32040(gp)
8114afac:	10bfffcc 	andi	r2,r2,65535
8114afb0:	10807d30 	cmpltui	r2,r2,500
8114afb4:	1000021e 	bne	r2,zero,8114afc0 <OSTimeTickHook+0x3c>
        OSTmrCtr = 0;
8114afb8:	d020b60d 	sth	zero,-32040(gp)
        OSTmrSignal();
8114afbc:	11418d40 	call	811418d4 <OSTmrSignal>
    
#ifdef ALT_INICHE
    /* Service the Interniche timer */
    cticks_hook();
#endif
}
8114afc0:	0001883a 	nop
8114afc4:	e037883a 	mov	sp,fp
8114afc8:	dfc00117 	ldw	ra,4(sp)
8114afcc:	df000017 	ldw	fp,0(sp)
8114afd0:	dec00204 	addi	sp,sp,8
8114afd4:	f800283a 	ret

8114afd8 <OSInitHookBegin>:

void OSInitHookBegin(void)
{
8114afd8:	deffff04 	addi	sp,sp,-4
8114afdc:	de00012e 	bgeu	sp,et,8114afe4 <OSInitHookBegin+0xc>
8114afe0:	003b68fa 	trap	3
8114afe4:	df000015 	stw	fp,0(sp)
8114afe8:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr = 0;
8114afec:	d020b60d 	sth	zero,-32040(gp)
#endif
}
8114aff0:	0001883a 	nop
8114aff4:	e037883a 	mov	sp,fp
8114aff8:	df000017 	ldw	fp,0(sp)
8114affc:	dec00104 	addi	sp,sp,4
8114b000:	f800283a 	ret

8114b004 <OSInitHookEnd>:

void OSInitHookEnd(void)
{
8114b004:	deffff04 	addi	sp,sp,-4
8114b008:	de00012e 	bgeu	sp,et,8114b010 <OSInitHookEnd+0xc>
8114b00c:	003b68fa 	trap	3
8114b010:	df000015 	stw	fp,0(sp)
8114b014:	d839883a 	mov	fp,sp
}
8114b018:	0001883a 	nop
8114b01c:	e037883a 	mov	sp,fp
8114b020:	df000017 	ldw	fp,0(sp)
8114b024:	dec00104 	addi	sp,sp,4
8114b028:	f800283a 	ret

8114b02c <OSTaskIdleHook>:

void OSTaskIdleHook(void)
{
8114b02c:	deffff04 	addi	sp,sp,-4
8114b030:	de00012e 	bgeu	sp,et,8114b038 <OSTaskIdleHook+0xc>
8114b034:	003b68fa 	trap	3
8114b038:	df000015 	stw	fp,0(sp)
8114b03c:	d839883a 	mov	fp,sp
}
8114b040:	0001883a 	nop
8114b044:	e037883a 	mov	sp,fp
8114b048:	df000017 	ldw	fp,0(sp)
8114b04c:	dec00104 	addi	sp,sp,4
8114b050:	f800283a 	ret

8114b054 <OSTCBInitHook>:

void OSTCBInitHook(OS_TCB *ptcb)
{
8114b054:	defffe04 	addi	sp,sp,-8
8114b058:	de00012e 	bgeu	sp,et,8114b060 <OSTCBInitHook+0xc>
8114b05c:	003b68fa 	trap	3
8114b060:	df000115 	stw	fp,4(sp)
8114b064:	df000104 	addi	fp,sp,4
8114b068:	e13fff15 	stw	r4,-4(fp)
}
8114b06c:	0001883a 	nop
8114b070:	e037883a 	mov	sp,fp
8114b074:	df000017 	ldw	fp,0(sp)
8114b078:	dec00104 	addi	sp,sp,4
8114b07c:	f800283a 	ret

8114b080 <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
8114b080:	defffe04 	addi	sp,sp,-8
8114b084:	de00012e 	bgeu	sp,et,8114b08c <alt_exception_cause_generated_bad_addr+0xc>
8114b088:	003b68fa 	trap	3
8114b08c:	df000115 	stw	fp,4(sp)
8114b090:	df000104 	addi	fp,sp,4
8114b094:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
8114b098:	e0bfff17 	ldw	r2,-4(fp)
8114b09c:	10bffe84 	addi	r2,r2,-6
8114b0a0:	10c00428 	cmpgeui	r3,r2,16
8114b0a4:	18001a1e 	bne	r3,zero,8114b110 <alt_exception_cause_generated_bad_addr+0x90>
8114b0a8:	100690ba 	slli	r3,r2,2
8114b0ac:	00a04574 	movhi	r2,33045
8114b0b0:	10ac3004 	addi	r2,r2,-20288
8114b0b4:	1885883a 	add	r2,r3,r2
8114b0b8:	10800017 	ldw	r2,0(r2)
8114b0bc:	1000683a 	jmp	r2
8114b0c0:	8114b100 	call	88114b10 <__reset+0x20f4b10>
8114b0c4:	8114b100 	call	88114b10 <__reset+0x20f4b10>
8114b0c8:	8114b110 	cmplti	r4,r16,21188
8114b0cc:	8114b110 	cmplti	r4,r16,21188
8114b0d0:	8114b110 	cmplti	r4,r16,21188
8114b0d4:	8114b100 	call	88114b10 <__reset+0x20f4b10>
8114b0d8:	8114b108 	cmpgei	r4,r16,21188
8114b0dc:	8114b110 	cmplti	r4,r16,21188
8114b0e0:	8114b100 	call	88114b10 <__reset+0x20f4b10>
8114b0e4:	8114b100 	call	88114b10 <__reset+0x20f4b10>
8114b0e8:	8114b110 	cmplti	r4,r16,21188
8114b0ec:	8114b100 	call	88114b10 <__reset+0x20f4b10>
8114b0f0:	8114b108 	cmpgei	r4,r16,21188
8114b0f4:	8114b110 	cmplti	r4,r16,21188
8114b0f8:	8114b110 	cmplti	r4,r16,21188
8114b0fc:	8114b100 	call	88114b10 <__reset+0x20f4b10>
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
8114b100:	00800044 	movi	r2,1
8114b104:	00000306 	br	8114b114 <alt_exception_cause_generated_bad_addr+0x94>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
8114b108:	0005883a 	mov	r2,zero
8114b10c:	00000106 	br	8114b114 <alt_exception_cause_generated_bad_addr+0x94>

  default:
    return 0;
8114b110:	0005883a 	mov	r2,zero
  }
}
8114b114:	e037883a 	mov	sp,fp
8114b118:	df000017 	ldw	fp,0(sp)
8114b11c:	dec00104 	addi	sp,sp,4
8114b120:	f800283a 	ret

8114b124 <exit>:
8114b124:	defffe04 	addi	sp,sp,-8
8114b128:	000b883a 	mov	r5,zero
8114b12c:	de00012e 	bgeu	sp,et,8114b134 <exit+0x10>
8114b130:	003b68fa 	trap	3
8114b134:	dc000015 	stw	r16,0(sp)
8114b138:	dfc00115 	stw	ra,4(sp)
8114b13c:	2021883a 	mov	r16,r4
8114b140:	114b2cc0 	call	8114b2cc <__call_exitprocs>
8114b144:	00a04574 	movhi	r2,33045
8114b148:	108d0e04 	addi	r2,r2,13368
8114b14c:	11000017 	ldw	r4,0(r2)
8114b150:	20800f17 	ldw	r2,60(r4)
8114b154:	10000126 	beq	r2,zero,8114b15c <exit+0x38>
8114b158:	103ee83a 	callr	r2
8114b15c:	8009883a 	mov	r4,r16
8114b160:	114b4540 	call	8114b454 <_exit>

8114b164 <memcmp>:
8114b164:	01c000c4 	movi	r7,3
8114b168:	3980192e 	bgeu	r7,r6,8114b1d0 <memcmp+0x6c>
8114b16c:	2144b03a 	or	r2,r4,r5
8114b170:	11c4703a 	and	r2,r2,r7
8114b174:	10000f26 	beq	r2,zero,8114b1b4 <memcmp+0x50>
8114b178:	20800003 	ldbu	r2,0(r4)
8114b17c:	28c00003 	ldbu	r3,0(r5)
8114b180:	10c0151e 	bne	r2,r3,8114b1d8 <memcmp+0x74>
8114b184:	31bfff84 	addi	r6,r6,-2
8114b188:	01ffffc4 	movi	r7,-1
8114b18c:	00000406 	br	8114b1a0 <memcmp+0x3c>
8114b190:	20800003 	ldbu	r2,0(r4)
8114b194:	28c00003 	ldbu	r3,0(r5)
8114b198:	31bfffc4 	addi	r6,r6,-1
8114b19c:	10c00e1e 	bne	r2,r3,8114b1d8 <memcmp+0x74>
8114b1a0:	21000044 	addi	r4,r4,1
8114b1a4:	29400044 	addi	r5,r5,1
8114b1a8:	31fff91e 	bne	r6,r7,8114b190 <__reset+0xfb12b190>
8114b1ac:	0005883a 	mov	r2,zero
8114b1b0:	f800283a 	ret
8114b1b4:	20c00017 	ldw	r3,0(r4)
8114b1b8:	28800017 	ldw	r2,0(r5)
8114b1bc:	18bfee1e 	bne	r3,r2,8114b178 <__reset+0xfb12b178>
8114b1c0:	31bfff04 	addi	r6,r6,-4
8114b1c4:	21000104 	addi	r4,r4,4
8114b1c8:	29400104 	addi	r5,r5,4
8114b1cc:	39bff936 	bltu	r7,r6,8114b1b4 <__reset+0xfb12b1b4>
8114b1d0:	303fe91e 	bne	r6,zero,8114b178 <__reset+0xfb12b178>
8114b1d4:	003ff506 	br	8114b1ac <__reset+0xfb12b1ac>
8114b1d8:	10c5c83a 	sub	r2,r2,r3
8114b1dc:	f800283a 	ret

8114b1e0 <strncpy>:
8114b1e0:	2906b03a 	or	r3,r5,r4
8114b1e4:	18c000cc 	andi	r3,r3,3
8114b1e8:	2005883a 	mov	r2,r4
8114b1ec:	18002c1e 	bne	r3,zero,8114b2a0 <strncpy+0xc0>
8114b1f0:	010000c4 	movi	r4,3
8114b1f4:	21802a2e 	bgeu	r4,r6,8114b2a0 <strncpy+0xc0>
8114b1f8:	033fbff4 	movhi	r12,65279
8114b1fc:	02e02074 	movhi	r11,32897
8114b200:	633fbfc4 	addi	r12,r12,-257
8114b204:	5ae02004 	addi	r11,r11,-32640
8114b208:	100f883a 	mov	r7,r2
8114b20c:	2a000017 	ldw	r8,0(r5)
8114b210:	3815883a 	mov	r10,r7
8114b214:	4313883a 	add	r9,r8,r12
8114b218:	0206303a 	nor	r3,zero,r8
8114b21c:	48c6703a 	and	r3,r9,r3
8114b220:	1ac6703a 	and	r3,r3,r11
8114b224:	1800261e 	bne	r3,zero,8114b2c0 <strncpy+0xe0>
8114b228:	39c00104 	addi	r7,r7,4
8114b22c:	52000015 	stw	r8,0(r10)
8114b230:	31bfff04 	addi	r6,r6,-4
8114b234:	3811883a 	mov	r8,r7
8114b238:	29400104 	addi	r5,r5,4
8114b23c:	21bff336 	bltu	r4,r6,8114b20c <__reset+0xfb12b20c>
8114b240:	30001e26 	beq	r6,zero,8114b2bc <strncpy+0xdc>
8114b244:	29c00003 	ldbu	r7,0(r5)
8114b248:	31bfffc4 	addi	r6,r6,-1
8114b24c:	40c00044 	addi	r3,r8,1
8114b250:	41c00005 	stb	r7,0(r8)
8114b254:	39c03fcc 	andi	r7,r7,255
8114b258:	39c0201c 	xori	r7,r7,128
8114b25c:	39ffe004 	addi	r7,r7,-128
8114b260:	29400044 	addi	r5,r5,1
8114b264:	38001026 	beq	r7,zero,8114b2a8 <strncpy+0xc8>
8114b268:	1811883a 	mov	r8,r3
8114b26c:	00000906 	br	8114b294 <strncpy+0xb4>
8114b270:	29c00003 	ldbu	r7,0(r5)
8114b274:	31bfffc4 	addi	r6,r6,-1
8114b278:	29400044 	addi	r5,r5,1
8114b27c:	41c00005 	stb	r7,0(r8)
8114b280:	39c03fcc 	andi	r7,r7,255
8114b284:	39c0201c 	xori	r7,r7,128
8114b288:	39ffe004 	addi	r7,r7,-128
8114b28c:	1811883a 	mov	r8,r3
8114b290:	38000526 	beq	r7,zero,8114b2a8 <strncpy+0xc8>
8114b294:	18c00044 	addi	r3,r3,1
8114b298:	303ff51e 	bne	r6,zero,8114b270 <__reset+0xfb12b270>
8114b29c:	f800283a 	ret
8114b2a0:	1011883a 	mov	r8,r2
8114b2a4:	003fe606 	br	8114b240 <__reset+0xfb12b240>
8114b2a8:	30000726 	beq	r6,zero,8114b2c8 <strncpy+0xe8>
8114b2ac:	198d883a 	add	r6,r3,r6
8114b2b0:	18000005 	stb	zero,0(r3)
8114b2b4:	18c00044 	addi	r3,r3,1
8114b2b8:	19bffd1e 	bne	r3,r6,8114b2b0 <__reset+0xfb12b2b0>
8114b2bc:	f800283a 	ret
8114b2c0:	3811883a 	mov	r8,r7
8114b2c4:	003fdf06 	br	8114b244 <__reset+0xfb12b244>
8114b2c8:	f800283a 	ret

8114b2cc <__call_exitprocs>:
8114b2cc:	defff504 	addi	sp,sp,-44
8114b2d0:	de00012e 	bgeu	sp,et,8114b2d8 <__call_exitprocs+0xc>
8114b2d4:	003b68fa 	trap	3
8114b2d8:	df000915 	stw	fp,36(sp)
8114b2dc:	dd400615 	stw	r21,24(sp)
8114b2e0:	dc800315 	stw	r18,12(sp)
8114b2e4:	dfc00a15 	stw	ra,40(sp)
8114b2e8:	ddc00815 	stw	r23,32(sp)
8114b2ec:	dd800715 	stw	r22,28(sp)
8114b2f0:	dd000515 	stw	r20,20(sp)
8114b2f4:	dcc00415 	stw	r19,16(sp)
8114b2f8:	dc400215 	stw	r17,8(sp)
8114b2fc:	dc000115 	stw	r16,4(sp)
8114b300:	d9000015 	stw	r4,0(sp)
8114b304:	2839883a 	mov	fp,r5
8114b308:	04800044 	movi	r18,1
8114b30c:	057fffc4 	movi	r21,-1
8114b310:	00a04574 	movhi	r2,33045
8114b314:	108d0e04 	addi	r2,r2,13368
8114b318:	12000017 	ldw	r8,0(r2)
8114b31c:	45005217 	ldw	r20,328(r8)
8114b320:	44c05204 	addi	r19,r8,328
8114b324:	a0001c26 	beq	r20,zero,8114b398 <__call_exitprocs+0xcc>
8114b328:	a0800117 	ldw	r2,4(r20)
8114b32c:	15ffffc4 	addi	r23,r2,-1
8114b330:	b8000d16 	blt	r23,zero,8114b368 <__call_exitprocs+0x9c>
8114b334:	14000044 	addi	r16,r2,1
8114b338:	8421883a 	add	r16,r16,r16
8114b33c:	8421883a 	add	r16,r16,r16
8114b340:	84402004 	addi	r17,r16,128
8114b344:	a463883a 	add	r17,r20,r17
8114b348:	a421883a 	add	r16,r20,r16
8114b34c:	e0001e26 	beq	fp,zero,8114b3c8 <__call_exitprocs+0xfc>
8114b350:	80804017 	ldw	r2,256(r16)
8114b354:	e0801c26 	beq	fp,r2,8114b3c8 <__call_exitprocs+0xfc>
8114b358:	bdffffc4 	addi	r23,r23,-1
8114b35c:	843fff04 	addi	r16,r16,-4
8114b360:	8c7fff04 	addi	r17,r17,-4
8114b364:	bd7ff91e 	bne	r23,r21,8114b34c <__reset+0xfb12b34c>
8114b368:	00800034 	movhi	r2,0
8114b36c:	10800004 	addi	r2,r2,0
8114b370:	10000926 	beq	r2,zero,8114b398 <__call_exitprocs+0xcc>
8114b374:	a0800117 	ldw	r2,4(r20)
8114b378:	1000301e 	bne	r2,zero,8114b43c <__call_exitprocs+0x170>
8114b37c:	a0800017 	ldw	r2,0(r20)
8114b380:	10003226 	beq	r2,zero,8114b44c <__call_exitprocs+0x180>
8114b384:	a009883a 	mov	r4,r20
8114b388:	98800015 	stw	r2,0(r19)
8114b38c:	00000000 	call	80000000 <OSCtxSw_SWITCH_PC+0x7fffffbc>
8114b390:	9d000017 	ldw	r20,0(r19)
8114b394:	a03fe41e 	bne	r20,zero,8114b328 <__reset+0xfb12b328>
8114b398:	dfc00a17 	ldw	ra,40(sp)
8114b39c:	df000917 	ldw	fp,36(sp)
8114b3a0:	ddc00817 	ldw	r23,32(sp)
8114b3a4:	dd800717 	ldw	r22,28(sp)
8114b3a8:	dd400617 	ldw	r21,24(sp)
8114b3ac:	dd000517 	ldw	r20,20(sp)
8114b3b0:	dcc00417 	ldw	r19,16(sp)
8114b3b4:	dc800317 	ldw	r18,12(sp)
8114b3b8:	dc400217 	ldw	r17,8(sp)
8114b3bc:	dc000117 	ldw	r16,4(sp)
8114b3c0:	dec00b04 	addi	sp,sp,44
8114b3c4:	f800283a 	ret
8114b3c8:	a0800117 	ldw	r2,4(r20)
8114b3cc:	80c00017 	ldw	r3,0(r16)
8114b3d0:	10bfffc4 	addi	r2,r2,-1
8114b3d4:	15c01426 	beq	r2,r23,8114b428 <__call_exitprocs+0x15c>
8114b3d8:	80000015 	stw	zero,0(r16)
8114b3dc:	183fde26 	beq	r3,zero,8114b358 <__reset+0xfb12b358>
8114b3e0:	95c8983a 	sll	r4,r18,r23
8114b3e4:	a0806217 	ldw	r2,392(r20)
8114b3e8:	a5800117 	ldw	r22,4(r20)
8114b3ec:	2084703a 	and	r2,r4,r2
8114b3f0:	10000b26 	beq	r2,zero,8114b420 <__call_exitprocs+0x154>
8114b3f4:	a0806317 	ldw	r2,396(r20)
8114b3f8:	2088703a 	and	r4,r4,r2
8114b3fc:	20000c1e 	bne	r4,zero,8114b430 <__call_exitprocs+0x164>
8114b400:	89400017 	ldw	r5,0(r17)
8114b404:	d9000017 	ldw	r4,0(sp)
8114b408:	183ee83a 	callr	r3
8114b40c:	a0800117 	ldw	r2,4(r20)
8114b410:	15bfbf1e 	bne	r2,r22,8114b310 <__reset+0xfb12b310>
8114b414:	98800017 	ldw	r2,0(r19)
8114b418:	153fcf26 	beq	r2,r20,8114b358 <__reset+0xfb12b358>
8114b41c:	003fbc06 	br	8114b310 <__reset+0xfb12b310>
8114b420:	183ee83a 	callr	r3
8114b424:	003ff906 	br	8114b40c <__reset+0xfb12b40c>
8114b428:	a5c00115 	stw	r23,4(r20)
8114b42c:	003feb06 	br	8114b3dc <__reset+0xfb12b3dc>
8114b430:	89000017 	ldw	r4,0(r17)
8114b434:	183ee83a 	callr	r3
8114b438:	003ff406 	br	8114b40c <__reset+0xfb12b40c>
8114b43c:	a0800017 	ldw	r2,0(r20)
8114b440:	a027883a 	mov	r19,r20
8114b444:	1029883a 	mov	r20,r2
8114b448:	003fb606 	br	8114b324 <__reset+0xfb12b324>
8114b44c:	0005883a 	mov	r2,zero
8114b450:	003ffb06 	br	8114b440 <__reset+0xfb12b440>

8114b454 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
8114b454:	defffc04 	addi	sp,sp,-16
8114b458:	de00012e 	bgeu	sp,et,8114b460 <_exit+0xc>
8114b45c:	003b68fa 	trap	3
8114b460:	dfc00315 	stw	ra,12(sp)
8114b464:	df000215 	stw	fp,8(sp)
8114b468:	df000204 	addi	fp,sp,8
8114b46c:	e13fff15 	stw	r4,-4(fp)
  /* ALT_LOG - please see HAL/inc/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
8114b470:	d0a01217 	ldw	r2,-32696(gp)
8114b474:	10800058 	cmpnei	r2,r2,1
8114b478:	1000031e 	bne	r2,zero,8114b488 <_exit+0x34>
8114b47c:	01204574 	movhi	r4,33045
8114b480:	21059104 	addi	r4,r4,5700
8114b484:	1136f640 	call	81136f64 <alt_log_printf_proc>
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
8114b488:	d0a01217 	ldw	r2,-32696(gp)
8114b48c:	10800058 	cmpnei	r2,r2,1
8114b490:	1000041e 	bne	r2,zero,8114b4a4 <_exit+0x50>
8114b494:	e17fff17 	ldw	r5,-4(fp)
8114b498:	01204574 	movhi	r4,33045
8114b49c:	21059c04 	addi	r4,r4,5744
8114b4a0:	1136f640 	call	81136f64 <alt_log_printf_proc>
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
8114b4a4:	d0a01217 	ldw	r2,-32696(gp)
8114b4a8:	10800058 	cmpnei	r2,r2,1
8114b4ac:	1000031e 	bne	r2,zero,8114b4bc <_exit+0x68>
8114b4b0:	01204574 	movhi	r4,33045
8114b4b4:	2105a704 	addi	r4,r4,5788
8114b4b8:	1136f640 	call	81136f64 <alt_log_printf_proc>
  ALT_OS_STOP();
8114b4bc:	d0209105 	stb	zero,-32188(gp)

  /* Provide notification to the simulator that we've stopped */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_SIM_HALT().\r\n");
8114b4c0:	d0a01217 	ldw	r2,-32696(gp)
8114b4c4:	10800058 	cmpnei	r2,r2,1
8114b4c8:	1000031e 	bne	r2,zero,8114b4d8 <_exit+0x84>
8114b4cc:	01204574 	movhi	r4,33045
8114b4d0:	2105b104 	addi	r4,r4,5828
8114b4d4:	1136f640 	call	81136f64 <alt_log_printf_proc>
8114b4d8:	e0bfff17 	ldw	r2,-4(fp)
8114b4dc:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
8114b4e0:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
8114b4e4:	10000226 	beq	r2,zero,8114b4f0 <_exit+0x9c>
    ALT_SIM_FAIL();
8114b4e8:	002af070 	cmpltui	zero,zero,43969
8114b4ec:	00000106 	br	8114b4f4 <_exit+0xa0>
  } else {
    ALT_SIM_PASS();
8114b4f0:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
8114b4f4:	d0a01217 	ldw	r2,-32696(gp)
8114b4f8:	10800058 	cmpnei	r2,r2,1
8114b4fc:	1000031e 	bne	r2,zero,8114b50c <_exit+0xb8>
8114b500:	01204574 	movhi	r4,33045
8114b504:	2105bb04 	addi	r4,r4,5868
8114b508:	1136f640 	call	81136f64 <alt_log_printf_proc>
  while (1);
8114b50c:	003fff06 	br	8114b50c <__reset+0xfb12b50c>
