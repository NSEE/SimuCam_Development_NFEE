
Simucam_R0_UART.elf:     file format elf32-littlenios2
Simucam_R0_UART.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x8110025c

Program Header:
    LOAD off    0x00001020 vaddr 0x81100020 paddr 0x81100020 align 2**12
         filesz 0x00052c08 memsz 0x0006ce6c flags rwx
    LOAD off    0x00054000 vaddr 0x86020000 paddr 0x86020000 align 2**12
         filesz 0x00000000 memsz 0x00000000 flags r-x

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000000  86020000  86020000  00054000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   0000023c  81100020  81100020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0004ac5c  8110025c  8110025c  0000125c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00005f7c  8114aeb8  8114aeb8  0004beb8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001df4  81150e34  81150e34  00051e34  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          0001a264  81152c28  81152c28  00053c28  2**2
                  ALLOC, SMALL_DATA
  6 .onchip_memory 00000000  8116ce8c  8116ce8c  00054000  2**0
                  CONTENTS
  7 .ext_flash    00000000  86020020  86020020  00054000  2**0
                  CONTENTS
  8 .comment      00000023  00000000  00000000  00054000  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00001d58  00000000  00000000  00054028  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   00071fae  00000000  00000000  00055d80  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 000169a9  00000000  00000000  000c7d2e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00022cfa  00000000  00000000  000de6d7  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  000099c8  00000000  00000000  001013d4  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0000cab2  00000000  00000000  0010ad9c  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00026ecc  00000000  00000000  0011784e  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_alt_sim_info 00000040  00000000  00000000  0013e71c  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 00002390  00000000  00000000  0013e760  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .thread_model 00000006  00000000  00000000  0014cf59  2**0
                  CONTENTS, READONLY
 19 .cpu          0000000c  00000000  00000000  0014cf5f  2**0
                  CONTENTS, READONLY
 20 .qsys         00000001  00000000  00000000  0014cf6b  2**0
                  CONTENTS, READONLY
 21 .simulation_enabled 00000001  00000000  00000000  0014cf6c  2**0
                  CONTENTS, READONLY
 22 .sysid_hash   00000004  00000000  00000000  0014cf6d  2**0
                  CONTENTS, READONLY
 23 .sysid_base   00000004  00000000  00000000  0014cf71  2**0
                  CONTENTS, READONLY
 24 .sysid_time   00000004  00000000  00000000  0014cf75  2**0
                  CONTENTS, READONLY
 25 .stderr_dev   0000000b  00000000  00000000  0014cf79  2**0
                  CONTENTS, READONLY
 26 .stdin_dev    0000000a  00000000  00000000  0014cf84  2**0
                  CONTENTS, READONLY
 27 .stdout_dev   0000000a  00000000  00000000  0014cf8e  2**0
                  CONTENTS, READONLY
 28 .sopc_system_name 00000011  00000000  00000000  0014cf98  2**0
                  CONTENTS, READONLY
 29 .quartus_project_dir 0000003f  00000000  00000000  0014cfa9  2**0
                  CONTENTS, READONLY
 30 .sopcinfo     00226f57  00000000  00000000  0014cfe8  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
86020000 l    d  .entry	00000000 .entry
81100020 l    d  .exceptions	00000000 .exceptions
8110025c l    d  .text	00000000 .text
8114aeb8 l    d  .rodata	00000000 .rodata
81150e34 l    d  .rwdata	00000000 .rwdata
81152c28 l    d  .bss	00000000 .bss
8116ce8c l    d  .onchip_memory	00000000 .onchip_memory
86020020 l    d  .ext_flash	00000000 .ext_flash
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../Simucam_R0_UART_bsp//obj/HAL/src/crt0.o
81100304 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 ddr2.c
00000000 l    df *ABS*	00000000 dma.c
00000000 l    df *ABS*	00000000 sense.c
00000000 l    df *ABS*	00000000 simucam_dma.c
00000000 l    df *ABS*	00000000 comm_channel.c
811047ec l     F .text	00000050 uliCommReadReg
81104798 l     F .text	00000054 vCommWriteReg
00000000 l    df *ABS*	00000000 data_packet.c
8110502c l     F .text	00000050 uliDpktReadReg
81104fd8 l     F .text	00000054 vDpktWriteReg
00000000 l    df *ABS*	00000000 fee_buffers.c
81152c4c l     O .bss	00000004 viCh1HoldContext
81152c50 l     O .bss	00000004 viCh2HoldContext
81152c54 l     O .bss	00000004 viCh3HoldContext
81152c58 l     O .bss	00000004 viCh4HoldContext
81152c5c l     O .bss	00000004 viCh5HoldContext
81152c60 l     O .bss	00000004 viCh6HoldContext
81152c64 l     O .bss	00000004 viCh7HoldContext
81152c68 l     O .bss	00000004 viCh8HoldContext
81106cb4 l     F .text	00000054 vFeebWriteReg
81106d08 l     F .text	00000050 uliFeebReadReg
00000000 l    df *ABS*	00000000 rmap.c
81152c6c l     O .bss	00000004 viCh1HoldContext
81152c70 l     O .bss	00000004 viCh2HoldContext
81152c74 l     O .bss	00000004 viCh3HoldContext
81152c78 l     O .bss	00000004 viCh4HoldContext
81152c7c l     O .bss	00000004 viCh5HoldContext
81152c80 l     O .bss	00000004 viCh6HoldContext
81152c84 l     O .bss	00000004 viCh7HoldContext
81152c88 l     O .bss	00000004 viCh8HoldContext
81109ea4 l     F .text	00000054 vRmapWriteReg
81109f48 l     F .text	00000268 uliConvRmapCfgAddr
00000000 l    df *ABS*	00000000 spw_controller.c
8110a87c l     F .text	00000050 uliSpwcReadReg
8110a828 l     F .text	00000054 vSpwcWriteReg
00000000 l    df *ABS*	00000000 ctrl_io_lvds.c
81152b50 l     O .rwdata	00000001 ucIoValue
8110aa7c l     F .text	0000007c bCtrlIoLvdsDrive
00000000 l    df *ABS*	00000000 i2c.c
00000000 l    df *ABS*	00000000 leds.c
00000000 l    df *ABS*	00000000 msgdma.c
8110b36c l     F .text	0000013c msgdma_write_extended_descriptor
8110b4a8 l     F .text	00000164 msgdma_construct_extended_descriptor
8110b60c l     F .text	00000318 msgdma_descriptor_async_transfer
8110b924 l     F .text	00000418 msgdma_descriptor_sync_transfer
00000000 l    df *ABS*	00000000 power_spi.c
00000000 l    df *ABS*	00000000 reset.c
8110c4bc l     F .text	00000054 vRstcWriteReg
8110c510 l     F .text	00000050 uliRstReadReg
00000000 l    df *ABS*	00000000 rtcc_spi.c
00000000 l    df *ABS*	00000000 seven_seg.c
00000000 l    df *ABS*	00000000 sync.c
81152c90 l     O .bss	00000004 viHoldContext
00000000 l    df *ABS*	00000000 data_control_task.c
00000000 l    df *ABS*	00000000 fee_task.c
81152c98 l     O .bss	00000004 pxNFee.5673
81152c9c l     O .bss	00000004 incrementador.5678
81152ca0 l     O .bss	00000004 tCodFeeTask.5676
00000000 l    df *ABS*	00000000 in_ack_handler_task.c
81152ca6 l     O .bss	00000004 xRAckLocal.5601
00000000 l    df *ABS*	00000000 initialization_task.c
00000000 l    df *ABS*	00000000 nfee_control_task.c
81152cac l     O .bss	00000004 bDmaBack.5642
81152cb0 l     O .bss	00000001 ucWhoGetDMA.5643
00000000 l    df *ABS*	00000000 out_ack_handler_task.c
81152cb2 l     O .bss	00000004 xSAckLocal.5586
00000000 l    df *ABS*	00000000 parser_comm_task.c
81152e2c l     O .bss	0000004c PreParsedLocal.5639
81152e78 l     O .bss	00000054 xTcPusL.5638
00000000 l    df *ABS*	00000000 receiver_uart_task.c
81152ecc l     O .bss	0000004c xPreParsedReader.5631
00000000 l    df *ABS*	00000000 sender_com_task.c
00000000 l    df *ABS*	00000000 sim_meb_task.c
81152f18 l     O .bss	00000054 xPusLocal.5874
00000000 l    df *ABS*	00000000 stack_monitor_task.c
00000000 l    df *ABS*	00000000 timeout_checker_ack_task.c
00000000 l    df *ABS*	00000000 simucam_main.c
00000000 l    df *ABS*	00000000 ccd.c
00000000 l    df *ABS*	00000000 communication_utils.c
00000000 l    df *ABS*	00000000 configs_simucam.c
00000000 l    df *ABS*	00000000 crc8.c
8114e77f l     O .rodata	00000100 crc8_table
00000000 l    df *ABS*	00000000 data_controller.c
00000000 l    df *ABS*	00000000 error_handler_simucam.c
00000000 l    df *ABS*	00000000 events_handler.c
00000000 l    df *ABS*	00000000 fee.c
00000000 l    df *ABS*	00000000 fee_controller.c
00000000 l    df *ABS*	00000000 initialization_simucam.c
00000000 l    df *ABS*	00000000 log_manager_simucam.c
00000000 l    df *ABS*	00000000 meb.c
00000000 l    df *ABS*	00000000 pattern.c
00000000 l    df *ABS*	00000000 sdcard_file_manager.c
00000000 l    df *ABS*	00000000 sync_handler.c
00000000 l    df *ABS*	00000000 test_module_simucam.c
00000000 l    df *ABS*	00000000 util.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 divsf3.c
00000000 l    df *ABS*	00000000 mulsf3.c
00000000 l    df *ABS*	00000000 floatsisf.c
00000000 l    df *ABS*	00000000 floatunsisf.c
00000000 l    df *ABS*	00000000 gedf2.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 subdf3.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 extendsfdf2.c
00000000 l    df *ABS*	00000000 truncdfsf2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 atoi.c
00000000 l    df *ABS*	00000000 ctype_.c
81150275 l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 fopen.c
00000000 l    df *ABS*	00000000 fprintf.c
00000000 l    df *ABS*	00000000 fputc.c
00000000 l    df *ABS*	00000000 fseek.c
00000000 l    df *ABS*	00000000 fseeko.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 fwrite.c
00000000 l    df *ABS*	00000000 impure.c
81150e34 l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 openr.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 refill.c
81122604 l     F .text	0000001c lflush
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 scanf.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strcspn.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 strnlen.c
00000000 l    df *ABS*	00000000 strtol.c
00000000 l    df *ABS*	00000000 vfprintf.c
81150442 l     O .rodata	00000010 zeroes.4389
81150452 l     O .rodata	00000010 blanks.4388
00000000 l    df *ABS*	00000000 vfprintf.c
81150462 l     O .rodata	00000010 zeroes.4404
8112727c l     F .text	000000c4 __sbprintf
81150472 l     O .rodata	00000010 blanks.4403
00000000 l    df *ABS*	00000000 vfscanf.c
8115048a l     O .rodata	00000022 basefix.4359
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 dtoa.c
81128f64 l     F .text	00000208 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
8112aab4 l     F .text	00000008 __fp_unlock
8112aac8 l     F .text	000001a4 __sinit.part.1
8112ac6c l     F .text	00000008 __fp_lock
00000000 l    df *ABS*	00000000 flags.c
00000000 l    df *ABS*	00000000 fread.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 iswspace.c
00000000 l    df *ABS*	00000000 locale.c
81151680 l     O .rwdata	00000020 lc_ctype_charset
81151660 l     O .rwdata	00000020 lc_message_charset
811516a0 l     O .rwdata	00000038 lconv
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 mbrtowc.c
00000000 l    df *ABS*	00000000 mbtowc_r.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mprec.c
811504c8 l     O .rodata	0000000c p05.2768
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 sccl.c
00000000 l    df *ABS*	00000000 sf_nan.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 strtod.c
8112dadc l     F .text	0000006c sulp
81150610 l     O .rodata	00000014 fpi.2737
81150624 l     O .rodata	00000028 tinytens
811505fc l     O .rodata	00000014 fpinan.2773
00000000 l    df *ABS*	00000000 strtoll_r.c
00000000 l    df *ABS*	00000000 strtoul.c
00000000 l    df *ABS*	00000000 strtoull_r.c
00000000 l    df *ABS*	00000000 vfprintf.c
8115065c l     O .rodata	00000010 blanks.4332
8115064c l     O .rodata	00000010 zeroes.4333
00000000 l    df *ABS*	00000000 ungetc.c
00000000 l    df *ABS*	00000000 vfprintf.c
8113114c l     F .text	00000104 __sprint_r.part.0
8115067c l     O .rodata	00000010 blanks.4348
8115066c l     O .rodata	00000010 zeroes.4349
811326e8 l     F .text	000000c4 __sbprintf
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fputwc.c
00000000 l    df *ABS*	00000000 gdtoa-gethex.c
81132b9c l     F .text	00000100 rshift
00000000 l    df *ABS*	00000000 gdtoa-hexnan.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 wcrtomb.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 eqsf2.c
00000000 l    df *ABS*	00000000 gesf2.c
00000000 l    df *ABS*	00000000 lesf2.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 divdf3.c
00000000 l    df *ABS*	00000000 eqdf2.c
00000000 l    df *ABS*	00000000 ledf2.c
00000000 l    df *ABS*	00000000 floatunsidf.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_close.c
81135d78 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
81135ebc l     F .text	00000034 alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
81135ef0 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_irq_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_isatty.c
81136174 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_log_macro.o
8113626c l       .text	00000000 tx_next_char
81136294 l       .text	00000000 end_tx
81136274 l       .text	00000000 wait_tx_ready_loop
00000000 l    df *ABS*	00000000 alt_log_printf.c
00000000 l    df *ABS*	00000000 alt_lseek.c
81136d70 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_open.c
81136fec l     F .text	00000044 alt_get_errno
81137030 l     F .text	000000cc alt_file_locked
00000000 l    df *ABS*	00000000 alt_read.c
81137258 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
81152b98 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
811377f8 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_env_lock.c
81152ba4 l     O .rwdata	00000004 lockid
81152d74 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
81152ba8 l     O .rwdata	00000004 lockid
81152d7c l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 os_core.c
81139284 l     F .text	00000050 OS_InitMisc
811392d4 l     F .text	00000074 OS_InitRdyList
81139458 l     F .text	000000ec OS_InitTCBList
8113919c l     F .text	000000e8 OS_InitEventList
81139348 l     F .text	00000088 OS_InitTaskIdle
811393d0 l     F .text	00000088 OS_InitTaskStat
811396e8 l     F .text	0000007c OS_SchedNew
00000000 l    df *ABS*	00000000 os_dbg.c
00000000 l    df *ABS*	00000000 os_flag.c
8113b500 l     F .text	000000fc OS_FlagTaskRdy
8113b2b0 l     F .text	00000168 OS_FlagBlock
00000000 l    df *ABS*	00000000 os_mem.c
00000000 l    df *ABS*	00000000 os_mutex.c
8113cdec l     F .text	00000198 OSMutex_RdyAtPrio
00000000 l    df *ABS*	00000000 os_q.c
00000000 l    df *ABS*	00000000 os_sem.c
00000000 l    df *ABS*	00000000 os_task.c
00000000 l    df *ABS*	00000000 os_time.c
00000000 l    df *ABS*	00000000 os_tmr.c
8114181c l     F .text	00000044 OSTmr_Lock
811412bc l     F .text	00000074 OSTmr_Alloc
81141860 l     F .text	0000003c OSTmr_Unlock
81141720 l     F .text	000000fc OSTmr_Unlink
81141330 l     F .text	000000a4 OSTmr_Free
811415d0 l     F .text	00000150 OSTmr_Link
81141548 l     F .text	00000088 OSTmr_InitTask
8114189c l     F .text	00000110 OSTmr_Task
00000000 l    df *ABS*	00000000 alt_sys_init.c
811419ac l     F .text	0000003c alt_dev_reg
8115191c l     O .rwdata	0000106c jtag_uart_0
81152988 l     O .rwdata	000000d0 rs232_uart
81152a58 l     O .rwdata	00000064 dma_DDR_M1
81152abc l     O .rwdata	00000064 dma_DDR_M2
81152b20 l     O .rwdata	0000002c Altera_UP_SD_Card_Avalon_Interface_0
00000000 l    df *ABS*	00000000 Altera_UP_SD_Card_Avalon_Interface.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
8114623c l     F .text	000002bc altera_avalon_jtag_uart_irq
811464f8 l     F .text	0000010c altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
81146cfc l     F .text	00000084 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
81147094 l     F .text	000000a4 altera_avalon_uart_irq
81147138 l     F .text	00000140 altera_avalon_uart_rxirq
81147278 l     F .text	000001ac altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
81147480 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
81147734 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 altera_msgdma.c
811479b8 l     F .text	00000044 alt_get_errno
811479fc l     F .text	0000009c alt_msgdma_write_standard_descriptor
81147a98 l     F .text	00000134 alt_msgdma_write_extended_descriptor
81147bcc l     F .text	0000018c alt_msgdma_irq
81147d58 l     F .text	00000094 alt_msgdma_construct_standard_descriptor
81147dec l     F .text	0000015c alt_msgdma_construct_extended_descriptor
81147f48 l     F .text	00000340 alt_msgdma_descriptor_async_transfer
81148288 l     F .text	00000408 alt_msgdma_descriptor_sync_transfer
81148990 l     F .text	000000ac alt_msgdma_construct_prefetcher_standard_descriptor
81148a3c l     F .text	0000019c alt_msgdma_construct_prefetcher_extended_descriptor
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
81149c08 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
8114a24c l     F .text	000000cc alt_open_fd
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 os_cpu_a.o
00000044 l       *ABS*	00000000 OSCtxSw_SWITCH_PC
00000000 l    df *ABS*	00000000 os_cpu_c.c
81152e24 l     O .bss	00000002 OSTmrCtr
00000014 l       *ABS*	00000000 OSTCBNext_OFFSET
00000032 l       *ABS*	00000000 OSTCBPrio_OFFSET
00000000 l       *ABS*	00000000 OSTCBStkPtr_OFFSET
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 strncpy.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
81152e28 g     O .bss	00000004 alt_instruction_exception_handler
81107174 g     F .text	00000044 vRmapCh7IrqFlagClrWriteCmd
811536ac g     O .bss	00001000 vFeeTask0_stk
8111b970 g     F .text	0000004c vFailDeleteInitialization
8111a414 g     F .text	00000d44 vLoadDebugConfs
81152df8 g     O .bss	00000004 aux_status_register
811546ac g     O .bss	00001000 vInAckHandlerTask_stk
811499c4 g     F .text	00000044 alt_msgdma_standard_descriptor_async_transfer
811074bc g     F .text	00000050 uliRmapCh1WriteCmdAddress
8110cb5c g     F .text	0000004c vSyncInitIrq
81116bec g     F .text	00000284 vCheckRetransmission128
8112d160 g     F .text	0000007c _mprec_log10
8110cd64 g     F .text	00000040 bSyncSetMbt
8111cf34 g     F .text	00000054 vFailRequestDMAFromIRQ
8110ac60 g     F .text	00000108 I2C_Read
81152bf6 g     O .rwdata	00000002 OSTaskNameSize
81152cbc g     O .bss	00000004 xWaitSyncQFee
811556ac g     O .bss	00000260 xBuffer64
8112d254 g     F .text	0000008c __any_on
8112bc28 g     F .text	0000005c _isatty_r
811504d4 g     O .rodata	00000028 __mprec_tinytens
81107464 g     F .text	00000058 bRmapCh8IrqFlagWriteCmd
81136e90 g     F .text	0000015c alt_main
81106570 g     F .text	00000078 bFeebGetRightBufferEmpty
81122528 g     F .text	000000c8 _puts_r
811057b8 g     F .text	00000058 bFeebCh3IrqFlagBufferEmpty
81152d84 g     O .bss	00000004 OSTmrFreeList
8116cd8c g     O .bss	00000100 alt_irq
8112bd98 g     F .text	00000068 _lseek_r
8111e1c4 g     F .text	00000030 vChangeDefaultAutoResetSync
8113bd60 g     F .text	000000d4 OS_MemInit
8111cee0 g     F .text	00000054 vFailRequestDMA
811065e8 g     F .text	00000068 bFeebGetCh1LeftBufferEmpty
8111970c g     F .text	000009d8 vLoadDefaultETHConf
81112024 g     F .text	0000014c bCheckInAck64
8115590c g     O .bss	00000150 xPus
811407fc g     F .text	00000068 OSTimeSet
81115898 g     F .text	0000008c vPusType250run
8112ae6c g     F .text	000000ac __sflags
8111c8b4 g     F .text	00000068 vCoudlNotCreateNFee2Task
8111cca0 g     F .text	0000004c vCouldNotGetMutexMebPus
81135a1c g     F .text	00000088 .hidden __eqdf2
81115f64 g     F .text	00000088 vSendCmdQToDataCTRL
81102a8c g     F .text	0000004c DMA_DESCRIPTOR_BUFFER_FULL
8111e0b0 g     F .text	00000034 vLoadDefaultSyncSource
8111b408 g     F .text	0000004c vFailCreateMutexDMA
81141eac g     F .text	000001ac Check_for_Master_Boot_Record
811667a0 g     O .bss	00000010 OSTmrWheelTbl
8110755c g     F .text	00000050 uliRmapCh3WriteCmdAddress
81148750 g     F .text	00000060 alt_msgdma_construct_standard_mm_to_mm_descriptor
81155a5c g     O .bss	00000020 xFeeQueueTBL3
81137ee8 g     F .text	00000594 OSEventPendMulti
81152cc0 g     O .bss	00000004 xNfeeSchedule
8116ce8c g       *ABS*	00000000 __alt_heap_start
8114a884 g     F .text	0000002c OSTaskCreateHook
81145d24 g     F .text	000001c4 alt_up_sd_card_fclose
81152cc4 g     O .bss	00000004 xSemCountBuffer64
81104550 g     F .text	0000016c bCommSetGlobalIrqEn
81107960 g     F .text	00000088 bRmapGetIrqControl
8112236c g     F .text	00000044 printf
81152c8d g     O .bss	00000001 SspdConfigControl
8110d180 g     F .text	00000054 bSyncCtrReset
81152bce g     O .rwdata	00000002 OSMboxEn
8111032c g     F .text	00000424 vQCmdFeeRMAPWaitingSync
8111ec98 g     F .text	000000a4 aatoh
811384e0 g     F .text	00000054 OSIntEnter
81133808 g     F .text	000000a4 _wcrtomb_r
811056c4 g     F .text	00000044 vFeebCh8IrqFlagClrBufferEmpty
8111b8d8 g     F .text	0000004c vFailReceiverCreate
81152cc8 g     O .bss	00000004 xQMaskDataCtrl
811051d4 g     F .text	00000084 vFeebCh2HandleIrq
81122a90 g     F .text	00000064 __sseek
8112ae1c g     F .text	00000010 __sinit
8110bdfc g     F .text	00000044 iMsgdmaExtendedDescriptorAsyncTransfer
81128be4 g     F .text	00000148 __swbuf_r
811173c4 g     F .text	00000470 bResourcesInitRTOS
8110a3c8 g     F .text	000000f4 bSpwcGetLinkError
81152bde g     O .rwdata	00000002 OSQEn
8110f9c0 g     F .text	00000514 vQCmdFeeRMAPinStandBy
81106e9c g     F .text	00000040 vRmapCh4HandleIrq
8112bcb4 g     F .text	00000084 _setlocale_r
81155a7c g     O .bss	00000020 SyncTBL2
81152b54 g     O .rwdata	00000004 LedsPainelControl
81152f94 g     O .bss	00000100 cDebugBuffer
8112ac74 g     F .text	00000070 __sfmoreglue
81131134 g     F .text	00000018 ungetc
811059c8 g     F .text	000000d4 bFeebCh1SetBufferSize
81137ba4 g     F .text	000000d4 __malloc_unlock
81102d88 g     F .text	00000214 DMA_MULTIPLE_TRANSFER
8114a904 g     F .text	00000028 OSTaskStatHook
81115dc0 g     F .text	00000088 vSendCmdQToNFeeCTRL
8111e120 g     F .text	00000030 vChangeDefaultSyncSource
81152d88 g     O .bss	00000001 OSLockNesting
81152d8c g     O .bss	00000004 OSTmrSemSignal
8111d360 g     F .text	000001e0 vNFeeStructureInit
81152ccc g     O .bss	00000004 xSemCommInit
81102910 g     F .text	00000080 uliXorshift32
8112db48 g     F .text	00001600 _strtod_r
81152cd0 g     O .bss	00000004 xSemCountSenderACK
8111ee50 g     F .text	00000448 .hidden __divsf3
81152e1c g     O .bss	00000004 current_sector_modified
81152c1c g     O .rwdata	00000002 OSDataSize
81152d90 g     O .bss	00000001 OSRunning
8110a6a4 g     F .text	00000184 bSpwcInitCh
81136b58 g     F .text	00000064 alt_log_jtag_uart_isr_proc
81155a9c g     O .bss	00001000 senderTask_stk
81108454 g     F .text	00000094 bRmapGetMemConfigStat
81152cd4 g     O .bss	00000004 fp
81156a9c g     O .bss	00000048 xNfeeScheduleTBL
81111edc g     F .text	00000148 bCheckInAck128
8112c128 g     F .text	0000015c memmove
8114a980 g     F .text	0000002c OSInitHookBegin
8110d61c g     F .text	00000074 bSyncCtrCh8OutEnable
811108bc g     F .text	00000090 bEnableDbBuffer
81152c14 g     O .rwdata	00000002 OSTmrSize
8112ae04 g     F .text	00000018 _cleanup
8111e54c g     F .text	00000040 siCloseFile
81106b30 g     F .text	00000184 bFeebInitCh
8112c284 g     F .text	000000b0 _Balloc
8111e150 g     F .text	00000038 vLoadDefaultAutoResetSync
81107a70 g     F .text	000000d8 bRmapSetCodecConfig
81144900 g     F .text	000000cc alt_up_sd_card_is_Present
81148690 g     F .text	00000060 alt_msgdma_construct_standard_st_to_mm_descriptor
81152c30 g     O .bss	00000004 pxDmaM1Dev
81102b24 g     F .text	000000a8 DMA_DISPATCHER_STOP
81141bd4 g     F .text	00000054 Save_Modified_Sector
81105918 g     F .text	00000058 bFeebCh7IrqFlagBufferEmpty
81152d94 g     O .bss	00000004 OSIdleCtr
81152d50 g     O .bss	00000001 alt_log_write_on_flag
8110a8cc g     F .text	0000003c bEnableIsoDrivers
8111f8c0 g     F .text	000000dc .hidden __gtdf2
8114a614 g     F .text	0000002c altera_nios2_gen2_irq_init
8114a6fc g       .text	00000000 OSStartTsk
8110ced8 g     F .text	00000070 bSyncSetNCycles
81139a58 g     F .text	000002dc OS_TCBInit
81152d53 g     O .bss	00000001 alt_log_jtag_uart_isr_on_flag
8111dd38 g     F .text	00000078 vInitSimucamBasicHW
81156ae4 g     O .bss	00001000 vTimeoutCheckerTask_stk
8110d534 g     F .text	00000074 bSyncCtrCh6OutEnable
8110afdc g     F .text	00000138 i2c_write
86020000 g     F .entry	00000000 __reset
81152e14 g     O .bss	00000004 fat_partition_size_in_512_byte_sectors
81152d98 g     O .bss	00000002 OSTmrUsed
81152cd8 g     O .bss	00000004 xSemCountBuffer128
81103264 g     F .text	000000f8 TEMP_Read
811078b8 g     F .text	000000a8 bRmapSetIrqControl
81105d18 g     F .text	000000d4 bFeebCh5SetBufferSize
81157ae4 g     O .bss	00001000 vDataControlTask_stk
811052dc g     F .text	00000084 vFeebCh4HandleIrq
81152c1a g     O .rwdata	00000002 OSTmrWheelTblSize
8111d9e0 g     F .text	0000002c cFeeSpwChannelDisable
81152bba g     O .rwdata	00000002 OSEventSize
81152d9a g     O .bss	00000001 OSPrioHighRdy
81121508 g     F .text	00000064 _fstat_r
8114a8b0 g     F .text	0000002c OSTaskDelHook
81152d2c g     O .bss	00000004 errno
8110d910 g     F .text	0000003c uliSyncGetCtr
81128b74 g     F .text	0000001c __svfscanf
81122a04 g     F .text	00000008 __seofread
8114a6dc g       .text	00000000 OSStartHighRdy
8111d2c0 g     F .text	00000028 vEvtChangeFeeControllerMode
81110af8 g     F .text	00000968 vPrintConsoleNFee
81112e54 g     F .text	000000c8 bSendCmdQToNFeeInst
81106f5c g     F .text	00000040 vRmapCh7HandleIrq
8113f22c g     F .text	000001ec OSTaskCreateExt
81166774 g     O .bss	00000011 alt_log_write_buf
81104a68 g     F .text	0000012c bDpktGetPacketConfig
811076ec g     F .text	00000050 uliRmapCh8WriteCmdAddress
8111bc94 g     F .text	00000068 vFailGetCountSemaphorePreParsedBuffer
8112fc78 g     F .text	00001244 ___svfiprintf_internal_r
811149f0 g     F .text	00000364 bPreParserV2
8113ade0 g     F .text	00000068 OSFlagPendGetFlagsRdy
81152bfa g     O .rwdata	00000002 OSTaskStatStkSize
81106720 g     F .text	00000068 bFeebGetCh2RightBufferEmpty
81139f2c g     F .text	00000310 OSFlagAccept
8113d508 g     F .text	000000c0 OSQFlush
81153494 g     O .bss	00000118 xRmap
8113cf84 g     F .text	00000148 OSQAccept
81152d64 g     O .bss	00000004 alt_argv
8115ab4c g       *ABS*	00000000 _gp
8111b5a0 g     F .text	0000004c vFailSendPreAckReceiverSemaphore
811376bc g     F .text	0000013c usleep
81144ed8 g     F .text	00000384 alt_up_sd_card_fopen
8111e3b8 g     F .text	00000030 bSDcardIsPresent
81114d54 g     F .text	00000178 vSenderComTask
81144a40 g     F .text	000000d8 alt_up_sd_card_find_first
8113f078 g     F .text	000001b4 OSTaskCreate
8111be34 g     F .text	00000068 vFailSendNack
81152e08 g     O .bss	00000004 command_argument_register
8113eb80 g     F .text	000004f8 OSTaskChangePrio
8111545c g     F .text	000000ac vPusMebInTaskConfigMode
8111c5ac g     F .text	00000088 vCouldNotSendTMPusCommand
81152d80 g     O .bss	00000004 alt_heapsem
8111d880 g     F .text	000000b0 vResetMemCCDFEE
8110b274 g     F .text	00000080 bSetBoardLeds
81139d34 g     F .text	000001f8 OSDebugInit
8113f418 g     F .text	0000034c OSTaskDel
8113be34 g     F .text	000001ac OSMutexAccept
81158ae4 g     O .bss	000002b8 xSimMeb
8111dc1c g     F .text	00000040 vSetTimeCode
81149238 g     F .text	000000dc alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits
81152cdc g     O .bss	00000004 xSemCountPreParsed
81151700 g     O .rwdata	00000180 alt_fd_list
81105868 g     F .text	00000058 bFeebCh5IrqFlagBufferEmpty
8115189c g     O .rwdata	0000001d alt_log_msg_alt_main
811667b0 g     O .bss	00000840 OSFlagTbl
811071fc g     F .text	00000058 bRmapCh1IrqFlagWriteCmd
8111b708 g     F .text	00000068 vFailGetCountSemaphoreReceiverTask
811075fc g     F .text	00000050 uliRmapCh5WriteCmdAddress
8111e008 g     F .text	0000003c vLoadDefaultRTValue
81138f64 g     F .text	000000c0 OS_EventTaskRemove
81158d9c g     O .bss	00001000 vFeeTask5_stk
81152d52 g     O .bss	00000001 alt_log_jtag_uart_alarm_on_flag
81144154 g     F .text	00000134 find_first_empty_record_in_root_directory
81149cf8 g     F .text	00000098 alt_find_dev
81122054 g     F .text	00000150 memcpy
811334d4 g     F .text	00000264 __hexnan
81104e64 g     F .text	00000174 bDpktInitCh
81159d9c g     O .bss	00000160 xBuffer32
81152be4 g     O .rwdata	00000002 OSRdyTblSize
81166ff0 g     O .bss	000001a0 OSTmrTbl
8112aabc g     F .text	0000000c _cleanup_r
81120a40 g     F .text	000000e4 .hidden __floatsidf
81119334 g     F .text	000001a8 vSendPusTM64
8110ccd4 g     F .text	0000004c ucSyncStatusErrorCode
81115ed0 g     F .text	00000094 vSendCmdQToNFeeCTRL_GEN
8111dadc g     F .text	00000034 cFeeRMAPLogDisable
811132dc g     F .text	00000df0 vParserCommTask
8114a318 g     F .text	00000084 alt_io_redirect
8111da70 g     F .text	00000034 cFeeRMAPEchoingDisable
81135aa4 g     F .text	000000f4 .hidden __ltdf2
8111cbec g     F .text	0000004c vFailSendPUStoMebTask
8110740c g     F .text	00000058 bRmapCh7IrqFlagWriteCmd
811061e4 g     F .text	000000d4 bFeebSetIrqControl
8111c3a4 g     F .text	00000068 vCouldNotRetransmitB128TimeoutTask
81152ce0 g     O .bss	00000004 xMutexReceivedACK
81103be0 g     F .text	000000b0 bSdmaInitM2Dma
81152c48 g     O .bss	00000004 EDpktMode
811496c0 g     F .text	00000094 alt_msgdma_start_prefetcher_with_extd_desc_list
81149a08 g     F .text	00000044 alt_msgdma_extended_descriptor_async_transfer
8110d228 g     F .text	00000054 bSyncCtrErrInj
81149968 g     F .text	0000005c alt_msgdma_register_callback
8111a0e4 g     F .text	00000330 vShowEthConfig
8111ddb0 g     F .text	00000030 bLogWriteSDCard
8111ba24 g     F .text	00000068 vFailSetCountSemaphorexBuffer64
811225f0 g     F .text	00000014 puts
8111e5cc g     F .text	00000284 bInitSync
8114aa28 g     F .text	000000a4 alt_exception_cause_generated_bad_addr
8110ca08 g     F .text	00000128 vSyncHandleIrq
81137c78 g     F .text	00000128 OSEventNameGet
8110552c g     F .text	00000044 vFeebCh2IrqFlagClrBufferEmpty
81152bc8 g     O .rwdata	00000002 OSFlagMax
8112beb4 g     F .text	000000e0 mbrtowc
81143d4c g     F .text	000001b4 find_first_empty_cluster
81115fec g     F .text	00000088 vSendCmdQToDataCTRL_PRIO
8110d4c0 g     F .text	00000074 bSyncCtrCh5OutEnable
81152c94 g     O .bss	00000001 vucN
8112d8b4 g     F .text	00000074 __fpclassifyd
8110cc34 g     F .text	00000054 bSyncStatusExtnIrq
81128b90 g     F .text	00000054 _vfscanf_r
8113c4b4 g     F .text	000005a4 OSMutexPend
8112d0b4 g     F .text	000000ac __ratio
8114483c g     F .text	000000c4 alt_up_sd_card_open_dev
8111c634 g     F .text	00000068 vWarnCouldNotgetMutexRetrans128
81138534 g     F .text	00000100 OSIntExit
8110cda4 g     F .text	00000040 bSyncSetBt
811326cc g     F .text	0000001c __vfiprintf_internal
8111ccec g     F .text	00000068 vCouldNotCreateQueueMaskNfeeCtrl
81152c02 g     O .rwdata	00000002 OSTCBSize
811054e8 g     F .text	00000044 vFeebCh1IrqFlagClrBufferEmpty
81152d9b g     O .bss	00000001 OSPrioCur
8114676c g     F .text	000002c4 altera_avalon_jtag_uart_read
81148f00 g     F .text	000000f8 alt_msgdma_prefetcher_add_standard_desc_to_list
81122334 g     F .text	00000038 _printf_r
811345c0 g     F .text	00000064 .hidden __udivsi3
811361b8 g     F .text	000000ac isatty
81152c8c g     O .bss	00000001 LedsBoardControl
81152ce4 g     O .bss	00000004 xSemCountReceivedACK
81152be8 g     O .rwdata	00000002 OSStkWidth
8112bc84 g     F .text	00000030 iswspace
81150524 g     O .rodata	000000c8 __mprec_tens
81152bdc g     O .rwdata	00000002 OSPtrSize
8111cf88 g     F .text	00000054 vFailSendRMAPFromIRQ
8111ca54 g     F .text	00000068 vCoudlNotCreateNFeeControllerTask
8112bd38 g     F .text	0000000c __locale_charset
8110d3d8 g     F .text	00000074 bSyncCtrCh3OutEnable
811347b0 g     F .text	000000c8 .hidden __lesf2
81152bbc g     O .rwdata	00000002 OSEventTblSize
8111edd4 g     F .text	0000007c .hidden __fixunsdfsi
8114a640 g       .text	00000000 OSCtxSw
8110ad68 g     F .text	00000160 I2C_MultipleRead
81136cfc g     F .text	00000074 alt_log_system_clock
81152d38 g     O .bss	00000004 __malloc_top_pad
81152d9c g     O .bss	00000004 OSTCBList
8114127c g     F .text	00000040 OSTmrSignal
81152d48 g     O .bss	00000004 alt_fd_list_lock
8112f7a4 g     F .text	0000001c strtoul
81152b6c g     O .rwdata	00000004 __mb_cur_max
8112bd68 g     F .text	0000000c _localeconv_r
8112f7c0 g     F .text	000002e0 _strtoull_r
8110c44c g     F .text	00000070 vRstcHoldDeviceReset
8112c6a8 g     F .text	00000044 __i2b
8112b5cc g     F .text	000004c4 __sfvwrite_r
8114302c g     F .text	000000c0 get_dir_divider_location
811070a8 g     F .text	00000044 vRmapCh4IrqFlagClrWriteCmd
81167190 g     O .bss	00000c30 OSMemTbl
81152da0 g     O .bss	00000001 OSTickStepState
8113690c g     F .text	00000060 alt_log_printf_proc
81104da0 g     F .text	000000c4 bDpktGetPixelDelay
81159efc g     O .bss	00001800 vReceiverUartTask_stk
811227fc g     F .text	0000005c _sbrk_r
81152ce8 g     O .bss	00000004 xSemTimeoutChecker
81142cec g     F .text	000000cc filename_to_upper_case
81152d54 g     O .bss	00000001 alt_log_jtag_uart_startup_info_on_flag
81152be0 g     O .rwdata	00000002 OSQMax
8114525c g     F .text	00000090 alt_up_sd_card_set_attributes
8113c1b0 g     F .text	00000304 OSMutexDel
81167dc0 g     O .bss	00001000 OSTaskStatStk
8111e3e8 g     F .text	00000030 bSDcardFAT16Check
8113b97c g     F .text	000000f8 OSMemNameGet
8111b3a8 g     F .text	00000060 vFailCreateMutexSResources
81142058 g     F .text	00000284 Read_File_Record_At_Offset
8115b6fc g     O .bss	00000040 xQMaskCMDNDataCtrlTBL
81152bc0 g     O .rwdata	00000002 OSFlagEn
8112d2e0 g     F .text	00000068 _read_r
81152c06 g     O .rwdata	00000002 OSTimeTickHookEn
8113b5fc g     F .text	000000ac OS_FlagUnlink
8113d9d0 g     F .text	00000170 OSQPost
81102478 g     F .text	00000498 bDdr2MemoryRandomReadTest
81152b88 g     O .rwdata	00000004 alt_max_fd
8111c150 g     F .text	0000004c vFailTimeoutCheckerTaskCreate
811395a0 g     F .text	00000070 OS_MemCopy
81139610 g     F .text	000000d8 OS_Sched
811438d0 g     F .text	0000047c find_file_in_directory
81132878 g     F .text	000000f8 _fclose_r
8113b884 g     F .text	000000f8 OSMemGet
8113fa5c g     F .text	000001bc OSTaskNameSet
8112aa84 g     F .text	00000030 fflush
81152d34 g     O .bss	00000004 __malloc_max_sbrked_mem
81152da4 g     O .bss	00000004 OSCtxSwCtr
81105dec g     F .text	000000d4 bFeebCh6SetBufferSize
8114a92c g     F .text	00000054 OSTimeTickHook
8115b73c g     O .bss	00001000 vOutAckHandlerTask_stk
81135fec g     F .text	00000188 alt_irq_register
81152bca g     O .rwdata	00000002 OSFlagNameSize
81120b24 g     F .text	00000118 .hidden __extendsfdf2
81139024 g     F .text	00000108 OS_EventTaskRemoveMulti
8111c774 g     F .text	00000070 vFailCreateNFEESyncQueue
811449cc g     F .text	00000074 alt_up_sd_card_is_FAT16
8110aaf8 g     F .text	00000088 I2C_TestAdress
81134878 g     F .text	000008b4 .hidden __adddf3
81166788 g     O .bss	00000018 alt_log_jtag_uart_alarm_1
8113467c g     F .text	00000078 .hidden __nesf2
81107064 g     F .text	00000044 vRmapCh3IrqFlagClrWriteCmd
81105108 g     F .text	0000008c usiLineTrDelayCalcPeriodNs
81138e0c g     F .text	00000158 OS_EventTaskWaitMulti
8115c73c g     O .bss	00000020 SyncTBL4
8112ce4c g     F .text	00000114 __b2d
81148c38 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor
81152be2 g     O .rwdata	00000002 OSQSize
81133f88 g     F .text	00000540 .hidden __umoddi3
81136db4 g     F .text	000000dc lseek
8113e4c0 g     F .text	00000214 OSSemPend
8111cc38 g     F .text	00000068 vCouldNotGetCmdQueueMeb
81107bd4 g     F .text	00000160 bRmapGetCodecStatus
8110a4bc g     F .text	000000d0 bSpwcGetLinkStatus
81106910 g     F .text	00000088 bFeebGetWindowing
81152b5c g     O .rwdata	00000004 _global_impure_ptr
8110c9bc g     F .text	0000004c bSSDisplayUpdate
81143390 g     F .text	00000540 get_home_directory_cluster_for_file
8112d348 g     F .text	0000056c _realloc_r
81152bcc g     O .rwdata	00000002 OSLowestPrio
8116ce8c g       *ABS*	00000000 __bss_end
8114a154 g     F .text	000000f8 alt_iic_isr_register
8114a9fc g     F .text	0000002c OSTCBInitHook
81152c12 g     O .rwdata	00000002 OSTmrCfgTicksPerSec
811375ac g     F .text	00000110 alt_tick
8110773c g     F .text	0000017c vRmapInitIrq
8111b6a0 g     F .text	00000068 vFailGetMutexSenderTask
8110c36c g     F .text	0000006c vRstcSimucamReset
811109b0 g     F .text	000000a4 bSendRequestNFeeCtrl
8115068c g     O .rodata	00000100 __hexdig
811497b4 g     F .text	000001b4 alt_msgdma_init
81133a08 g     F .text	00000580 .hidden __udivdi3
811146d8 g     F .text	0000017c setPreAckSenderFreePos
81132af0 g     F .text	00000024 _fputwc_r
81152bb4 g     O .rwdata	00000002 OSEventEn
811504fc g     O .rodata	00000028 __mprec_bigtens
8112c484 g     F .text	0000010c __s2b
81152c0e g     O .rwdata	00000002 OSTmrCfgNameSize
8115c75c g     O .bss	00000020 xFeeQueueTBL4
8110ce64 g     F .text	00000074 bSyncSetPolarity
81116e70 g     F .text	0000028c vCheckRetransmission64
81135b98 g     F .text	000000b0 .hidden __floatunsidf
81152d58 g     O .bss	00000004 alt_system_clock_in_sec
81136b04 g     F .text	00000054 alt_log_jtag_uart_startup_info
8111bc2c g     F .text	00000068 vFailFoundBufferRetransmission
8112cb84 g     F .text	00000060 __mcmp
81152e20 g     O .bss	00000004 current_sector_index
81146f2c g     F .text	00000168 altera_avalon_uart_init
81149a90 g     F .text	00000044 alt_msgdma_extended_descriptor_sync_transfer
811040ec g     F .text	00000464 bSdmaDmaM2Transfer
8111dc5c g     F .text	00000034 vResetTimeCode
8111d9b4 g     F .text	0000002c cFeeSpwChannelEnable
8112ae3c g     F .text	00000018 __fp_lock_all
8111d11c g     F .text	0000004c vFailSendMsgDataCTRL
8114a100 g     F .text	00000054 alt_ic_irq_enabled
8110ab80 g     F .text	000000e0 I2C_Write
811072ac g     F .text	00000058 bRmapCh3IrqFlagWriteCmd
81152da8 g     O .bss	00000002 OSTmrFree
8113b418 g     F .text	000000e8 OS_FlagInit
81137508 g     F .text	000000a4 alt_alarm_stop
81122e64 g     F .text	0000001c strtol
81152d51 g     O .bss	00000001 alt_log_sys_clk_on_flag
81140a28 g     F .text	00000140 OSTmrDel
81141dc4 g     F .text	000000e8 mark_cluster
81152bf0 g     O .rwdata	00000002 OSTaskIdleStkSize
81152d4c g     O .bss	00000004 alt_irq_active
8113e0e0 g     F .text	000000b8 OSSemAccept
811210a0 g     F .text	0000044c _fseeko_r
81117d08 g     F .text	00000260 vFillMemmoryPattern
81122be0 g     F .text	00000044 strnlen
8113bb90 g     F .text	000000e0 OSMemPut
8113b6a8 g     F .text	000001dc OSMemCreate
81152dac g     O .bss	00000004 OSIdleCtrMax
811194dc g     F .text	000001a8 vSendPusTM128
81100104 g     F .exceptions	000000dc alt_irq_handler
81136354 g     F .text	000005b8 alt_log_private_printf
811516d8 g     O .rwdata	00000028 alt_dev_null
81148848 g     F .text	00000098 alt_msgdma_construct_extended_mm_to_st_descriptor
8110ce24 g     F .text	00000040 bSyncSetOst
81152c04 g     O .rwdata	00000002 OSTicksPerSec
81151880 g     O .rwdata	00000019 alt_log_msg_bss
81144288 g     F .text	00000194 convert_filename_to_name_extension
811084e8 g     F .text	0000104c bRmapSetRmapMemHKArea
81106788 g     F .text	000000e0 bFeebSetBufferSize
81114ecc g     F .text	00000434 vSimMebTask
8110aec8 g     F .text	00000094 i2c_start
8114a640 g       .text	00000000 OSIntCtxSw
8111cfdc g     F .text	00000054 vFailSendMsgSync
8110d44c g     F .text	00000074 bSyncCtrCh4OutEnable
8114962c g     F .text	00000094 alt_msgdma_start_prefetcher_with_std_desc_list
81135e94 g     F .text	00000028 alt_dcache_flush_all
8112c590 g     F .text	00000068 __hi0bits
81115924 g     F .text	00000114 vPusType251run
8110764c g     F .text	00000050 uliRmapCh6WriteCmdAddress
8111e044 g     F .text	0000003c vChangeRTValue
81152df4 g     O .bss	00000004 is_sd_card_formated_as_FAT16
81116a68 g     F .text	00000184 vCheck
8111d310 g     F .text	00000050 vNFeeNotInUse
811209c0 g     F .text	00000080 .hidden __fixdfsi
81112f1c g     F .text	000000c8 bSendCmdQToNFeeInst_Prio
81105f94 g     F .text	000000d4 bFeebCh8SetBufferSize
81106a20 g     F .text	00000088 bFeebStopCh
8110da3c g     F .text	00000084 uliPerCalcPeriodMs
81112840 g     F .text	00000424 vNFeeControlTask
8115c77c g     O .bss	00001000 vInitialTask_stk
81152cec g     O .bss	00000002 usiIdCMD
8115d77c g     O .bss	00000020 SyncTBL3
8110d12c g     F .text	00000054 bSyncCtrStart
81143f00 g     F .text	00000254 find_first_empty_record_in_a_subdirectory
8112f148 g     F .text	00000018 strtod
81106aa8 g     F .text	00000088 bFeebClrCh
81152db0 g     O .bss	00000004 OSTCBFreeList
811073b4 g     F .text	00000058 bRmapCh6IrqFlagWriteCmd
8113e6d4 g     F .text	00000174 OSSemPendAbort
8111b840 g     F .text	0000004c vFailGetMacRTC
811075ac g     F .text	00000050 uliRmapCh4WriteCmdAddress
81100000 g       *ABS*	00000000 __alt_mem_onchip_memory
8111c0b8 g     F .text	0000004c vFailCreateTimerRetransmisison
8111bbc4 g     F .text	00000068 vFailGetCountSemaphorexBuffer32
811183a4 g     F .text	000002f0 bSendUART128v2
8111de78 g     F .text	000000ec vSimucamStructureInit
81152b80 g     O .rwdata	00000008 alt_dev_list
81120fd0 g     F .text	0000004c _fputc_r
8113783c g     F .text	0000010c write
811223b0 g     F .text	000000a8 _putc_r
81152e18 g     O .bss	00000004 device_pointer
81152c08 g     O .rwdata	00000002 OSVersionNbr
811346f4 g     F .text	000000bc .hidden __gtsf2
8111d200 g     F .text	0000004c vFailFlushMEBQueue
811140cc g     F .text	00000118 getPreParsedPacket
8111085c g     F .text	00000060 bEnableSPWChannel
81135f34 g     F .text	000000b8 fstat
8111dcc4 g     F .text	00000040 vChangeIdNFEEMaster
81120fa4 g     F .text	0000002c fprintf
8111daa4 g     F .text	00000038 cFeeRMAPLogEnable
81102c74 g     F .text	00000114 DMA_SINGLE_TRANSFER
811058c0 g     F .text	00000058 bFeebCh6IrqFlagBufferEmpty
8111c204 g     F .text	00000068 vFailPostBlockingSemTimeoutTask
8111e978 g     F .text	00000058 _reg_write
8111dd04 g     F .text	00000034 vChangeDefaultIdNFEEMaster
81135aa4 g     F .text	000000f4 .hidden __ledf2
81106edc g     F .text	00000040 vRmapCh5HandleIrq
81110750 g     F .text	00000054 bDisableRmapIRQ
8115d79c g     O .bss	00001000 vStackMonitor_stk
8111c544 g     F .text	00000068 vCouldNotSendLog
81140ca8 g     F .text	000001b8 OSTmrRemainGet
81152bb0 g     O .rwdata	00000004 OSEndiannessTest
8110c560 g     F .text	00000058 v_spi_start
8112c8ec g     F .text	00000148 __pow5mult
8110750c g     F .text	00000050 uliRmapCh2WriteCmdAddress
81131268 g     F .text	00001464 ___vfiprintf_internal_r
81152d44 g     O .bss	00000004 __nlocale_changed
81134624 g     F .text	00000058 .hidden __umodsi3
8110d27c g     F .text	00000074 bSyncCtrSyncOutEnable
8111e418 g     F .text	000000f8 bInitializeSDCard
8111bfd4 g     F .text	0000004c vFailParserCommTaskCreate
8111c4dc g     F .text	00000068 vCouldNotSendReset
8112289c g     F .text	00000038 _scanf_r
8111c06c g     F .text	0000004c vFailOutAckHandlerTaskCreate
81152bc2 g     O .rwdata	00000002 OSFlagGrpSize
81115508 g     F .text	0000008c vPusType250conf
8115e79c g     O .bss	00000058 xInUseRetrans
8110cbe4 g     F .text	00000050 bSyncIrqFlagSync
81148c98 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor
81140e60 g     F .text	000000ec OSTmrStateGet
8116ce8c g       *ABS*	00000000 end
811053e4 g     F .text	00000084 vFeebCh6HandleIrq
81117f68 g     F .text	00000260 vPrintMemmoryPattern
8111bd64 g     F .text	00000068 vNoContentInPreParsedBuffer
811214ec g     F .text	0000001c fseeko
811141e4 g     F .text	00000168 bSendMessagePUStoMebTask
8111c704 g     F .text	00000070 vFailCreateNFEEQueue
81120e54 g     F .text	0000000c _atoi_r
81147778 g     F .text	00000240 altera_avalon_uart_write
81136298 g     F .text	00000054 alt_log_txchar
81121084 g     F .text	0000001c fseek
81118314 g     F .text	00000090 vCCDChangeValues
8114606c g     F .text	000001d0 altera_avalon_jtag_uart_init
811398a0 g     F .text	000000e4 OS_TaskStat
811001e0 g     F .exceptions	0000007c alt_instruction_exception_entry
8111b4a0 g     F .text	0000004c vFailTestCriticasParts
811fa000 g       *ABS*	00000000 __alt_stack_pointer
8110200c g     F .text	0000046c bDdr2MemoryRandomWriteTest
81146d80 g     F .text	00000084 alt_avalon_timer_sc_init
81106868 g     F .text	000000a8 bFeebSetWindowing
81146e6c g     F .text	00000068 altera_avalon_uart_write_fd
81120de4 g     F .text	00000064 .hidden __clzsi2
81146ed4 g     F .text	00000058 altera_avalon_uart_close_fd
8115e7f4 g     O .bss	00000020 xMebQTBL
81146a30 g     F .text	000002cc altera_avalon_jtag_uart_write
811413d4 g     F .text	00000174 OSTmr_Init
8115e814 g     O .bss	00000348 xBuffer128
8112ae2c g     F .text	00000004 __sfp_lock_acquire
8110335c g     F .text	00000048 sense_log_temp
8112c044 g     F .text	000000e4 memchr
81139544 g     F .text	0000005c OS_MemClr
81125060 g     F .text	00002200 ___vfprintf_internal_r
8114a720 g     F .text	00000164 OSTaskStkInit
811228d4 g     F .text	00000060 _sprintf_r
81108180 g     F .text	000002d4 bRmapGetMemConfigArea
81152cee g     O .bss	00000001 SemCount32
8112b2b4 g     F .text	00000318 _free_r
8114a39c g     F .text	00000234 alt_printf
811192e4 g     F .text	00000050 vTimeoutCheck
8111ea28 g     F .text	000001fc _print_codec_status
8112bd44 g     F .text	00000010 __locale_mb_cur_max
81138b54 g     F .text	000001a0 OS_EventTaskRdy
811079e8 g     F .text	00000088 bRmapGetIrqFlags
81102bcc g     F .text	000000a8 DMA_DISPATCHER_RESET
8114ac74 g     F .text	00000188 __call_exitprocs
81112d2c g     F .text	00000128 vPerformActionNFCRunning
81152db4 g     O .bss	00000001 OSCPUUsage
8111c984 g     F .text	00000068 vCoudlNotCreateNFee4Task
81152d40 g     O .bss	00000004 __mlocale_changed
81112c64 g     F .text	000000c8 vPerformActionNFCConfig
8110d1d4 g     F .text	00000054 bSyncCtrOneShot
81152b64 g     O .rwdata	00000004 __malloc_sbrk_base
8110025c g     F .text	000000ac _start
8110d94c g     F .text	0000003c uliSyncReadStatus
81152d6c g     O .bss	00000004 _alt_tick_rate
8113d5c8 g     F .text	00000294 OSQPend
8112f268 g     F .text	000002e8 _strtoll_r
8115eb5c g     O .bss	00000040 xQMaskCMDNFeeCtrlTBL
81166724 g     O .bss	00000034 xDefaults
8114034c g     F .text	0000010c OSTimeDly
811157ec g     F .text	000000ac vPusMebInTaskRunningMode
8110cba8 g     F .text	0000003c vSyncIrqFlagClrSync
8112ca34 g     F .text	00000150 __lshift
81112fe4 g     F .text	000002f8 vOutAckHandlerTask
811486f0 g     F .text	00000060 alt_msgdma_construct_standard_mm_to_st_descriptor
81152d70 g     O .bss	00000004 _alt_nticks
8113729c g     F .text	00000104 read
81141a28 g     F .text	000000f0 alt_sys_init
8111f69c g     F .text	0000012c .hidden __floatsisf
81107020 g     F .text	00000044 vRmapCh2IrqFlagClrWriteCmd
8112faa0 g     F .text	000001d8 __ssprint_r
811222cc g     F .text	00000068 _open_r
8111e8f0 g     F .text	00000088 bTestSimucamCriticalHW
811063ec g     F .text	0000010c bFeebGetBuffersStatus
8111b158 g     F .text	000000a4 ucCrc8
81100818 g     F .text	00000cb0 bDdr2EepromDump
81152db5 g     O .bss	00000001 OSTaskCtr
81136264 g       .text	00000000 tx_log_str
81115300 g     F .text	0000015c vPusMebTask
81119294 g     F .text	00000050 siPosStr
81115e48 g     F .text	00000088 vSendCmdQToNFeeCTRL_PRIO
81133738 g     F .text	000000d0 strncmp
8110d988 g     F .text	0000005c bSyncWriteReg
8110735c g     F .text	00000058 bRmapCh5IrqFlagWriteCmd
81140458 g     F .text	00000164 OSTimeDlyHMSM
8112c6ec g     F .text	00000200 __multiply
81146604 g     F .text	00000070 altera_avalon_jtag_uart_close
8110c730 g     F .text	00000058 v_spi_end
8111e58c g     F .text	00000040 cGetNextChar
8114ab88 g     F .text	000000ec strncpy
81152f6c g     O .bss	00000028 __malloc_current_mallinfo
81152bb6 g     O .rwdata	00000002 OSEventMax
8113467c g     F .text	00000078 .hidden __eqsf2
8112cf60 g     F .text	00000154 __d2b
8113e848 g     F .text	00000118 OSSemPost
811055b4 g     F .text	00000044 vFeebCh4IrqFlagClrBufferEmpty
8111e080 g     F .text	00000030 vChangeDefaultRTValue
811054a8 g     F .text	00000040 vFeebCh8HandleIrq
81152df0 g     O .bss	00000004 initialized
81119144 g     F .text	00000100 vSendLog
811386c8 g     F .text	000000e4 OSSchedUnlock
8110c788 g     F .text	00000164 RTCC_SPI_R_MAC
81152b94 g     O .rwdata	00000004 alt_log_boot_on_flag
81145ee8 g     F .text	00000068 altera_avalon_jtag_uart_read_fd
8112f550 g     F .text	00000254 _strtoul_r
8115eb9c g     O .bss	00000020 xFeeQueueTBL5
81149ea0 g     F .text	000000e4 alt_get_fd
81152db8 g     O .bss	00000004 OSMemFreeList
81138824 g     F .text	000000b8 OSStatInit
8111e8bc g     F .text	00000034 bClearCounterSync
81102990 g     F .text	00000064 DMA_OPEN_DEVICE
8116c824 g     O .bss	00000014 search_data
8110a1b0 g     F .text	00000134 bSpwcSetLink
81135c48 g     F .text	00000130 alt_busy_sleep
8113b1e4 g     F .text	000000cc OSFlagQuery
8110d2f0 g     F .text	00000074 bSyncCtrCh1OutEnable
81152bec g     O .rwdata	00000002 OSTaskCreateExtEn
8111ec24 g     F .text	00000074 _split_codec_status
81128f08 g     F .text	0000005c _close_r
8111bdcc g     F .text	00000068 vCouldNotSendEthConfUART
811122bc g     F .text	00000584 vInitialTask
81136a0c g     F .text	000000f8 alt_log_jtag_uart_print_control_reg
81148bd8 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor
8114ab0c g     F .text	0000007c memcmp
81138b2c g     F .text	00000028 OS_Dummy
81145fb8 g     F .text	00000058 altera_avalon_jtag_uart_close_fd
8116ce8c g       *ABS*	00000000 __alt_stack_base
81105ec0 g     F .text	000000d4 bFeebCh7SetBufferSize
81146010 g     F .text	0000005c altera_avalon_jtag_uart_ioctl_fd
811055f8 g     F .text	00000044 vFeebCh5IrqFlagClrBufferEmpty
8112156c g     F .text	000000d4 _fwrite_r
8111617c g     F .text	000000a4 vReleaseSyncMessages
81148cf8 g     F .text	000000a8 alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor
81105708 g     F .text	00000058 bFeebCh1IrqFlagBufferEmpty
81128dac g     F .text	0000015c __swsetup_r
81168dc0 g     O .bss	00000300 OSQTbl
8111cdbc g     F .text	00000068 vCouldNotGetQueueMaskNfeeCtrl
81166758 g     O .bss	0000001c xConfEth
8113512c g     F .text	000008f0 .hidden __divdf3
8111e0e4 g     F .text	0000003c vChangeSyncSource
8112ace4 g     F .text	00000120 __sfp
8116c838 g     O .bss	00000054 boot_sector_data
8111cd54 g     F .text	00000068 vCouldNotCreateQueueMaskDataCtrl
8110a61c g     F .text	00000088 bSpwcClearTimecode
81102ad8 g     F .text	0000004c DMA_DESCRIPTOR_BUFFER_EMPTY
8112d1dc g     F .text	00000078 __copybits
81151258 g     O .rwdata	00000408 __malloc_av_
8112ae38 g     F .text	00000004 __sinit_lock_release
81152c28 g     O .bss	00000004 uliInitialState
8110af5c g     F .text	00000080 i2c_stop
8111ed3c g     F .text	00000064 Verif_Error
8111eda0 g     F .text	00000034 toInt
8111b5ec g     F .text	0000004c vFailSendPreAckSenderSemaphore
81152dbc g     O .bss	00000004 OSTCBHighRdy
8111f99c g     F .text	00000720 .hidden __muldf3
811229a8 g     F .text	0000005c __sread
8112b14c g     F .text	0000003c fread
81152dc0 g     O .bss	00000004 OSQFreeList
81149d90 g     F .text	00000110 alt_find_file
81149c4c g     F .text	000000ac alt_dev_llist_insert
81137a7c g     F .text	00000128 __malloc_lock
81120f74 g     F .text	00000030 _fprintf_r
8113740c g     F .text	000000fc sbrk
8111d930 g     F .text	0000002c vFeeSpwRMAPLoadDefault
8111bb5c g     F .text	00000068 vFailGetCountSemaphorexBuffer64
81122e80 g     F .text	000021e0 ___svfprintf_internal_r
81119684 g     F .text	00000088 vTMPusTestConnection
81152cf0 g     O .bss	00000004 xMebQ
81137da0 g     F .text	00000148 OSEventNameSet
8112aa20 g     F .text	00000064 _fflush_r
811327ac g     F .text	000000cc _calloc_r
81152dc4 g     O .bss	00000001 OSRdyGrp
8111d0d0 g     F .text	0000004c vFailSendMsgFeeCTRL
8110cd20 g     F .text	00000044 ucSyncStatusCycleNumber
81107b48 g     F .text	0000008c bRmapGetCodecConfig
81140f4c g     F .text	00000148 OSTmrStart
81105360 g     F .text	00000084 vFeebCh5HandleIrq
81120f5c g     F .text	00000018 fopen
811029f4 g     F .text	0000004c DMA_CONFIG
81152c28 g       *ABS*	00000000 __bss_start
81105c44 g     F .text	000000d4 bFeebCh4SetBufferSize
811221a4 g     F .text	00000128 memset
8111459c g     F .text	0000013c setPreParsedFreePos
8110f594 g     F .text	000001fc vQCmdFEEinStandBy
81149754 g     F .text	00000060 alt_msgdma_open
8111e23c g     F .text	0000017c pattern_createPattern
81117b48 g     F .text	000001c0 main
8111b770 g     F .text	00000068 vFailGetMutexReceiverTask
8115ebbc g     O .bss	00001000 vNFeeControlTask_stk
811071b8 g     F .text	00000044 vRmapCh8IrqFlagClrWriteCmd
8111df9c g     F .text	0000003c vChangeEPValue
81107304 g     F .text	00000058 bRmapCh4IrqFlagWriteCmd
81152d68 g     O .bss	00000004 alt_envp
8111d168 g     F .text	0000004c vFailFlushQueue
81152d30 g     O .bss	00000004 __malloc_max_total_mem
81148ff8 g     F .text	000001a0 alt_msgdma_prefetcher_add_extended_desc_to_list
8111b1fc g     F .text	0000005c ucCrc8wInit
8111c104 g     F .text	0000004c vCouldNotCheckBufferTimeOutFunction
81145f50 g     F .text	00000068 altera_avalon_jtag_uart_write_fd
81102f9c g     F .text	000002c8 POWER_Read
8110b114 g     F .text	00000160 i2c_read
8115fbbc g     O .bss	00000020 SyncTBL5
81128d2c g     F .text	00000018 __swbuf
8115098c g     O .rodata	00000100 OSUnMapTbl
811347b0 g     F .text	000000c8 .hidden __ltsf2
811452ec g     F .text	00000090 alt_up_sd_card_get_attributes
8112af18 g     F .text	00000234 _fread_r
8111b638 g     F .text	00000068 vFailGetCountSemaphoreSenderTask
8110a908 g     F .text	0000003c bDisableIsoDrivers
81152be6 g     O .rwdata	00000002 OSSemEn
81141b18 g     F .text	000000bc Write_Sector_Data
811456fc g     F .text	00000628 alt_up_sd_card_write
81152cf4 g     O .bss	00000004 xFeeQ
81106650 g     F .text	00000068 bFeebGetCh1RightBufferEmpty
8113ae48 g     F .text	0000039c OSFlagPost
81122af4 g     F .text	00000008 __sclose
8111c40c g     F .text	00000068 vFailStartTimerRetransmission
811fa000 g       *ABS*	00000000 __alt_heap_limit
81132970 g     F .text	00000014 fclose
81138cf4 g     F .text	00000118 OS_EventTaskWait
8111c2d4 g     F .text	00000068 vCouldNotRetransmitB32TimeoutTask
81122c24 g     F .text	00000240 _strtol_r
81120c3c g     F .text	000001a8 .hidden __truncdfsf2
8115fbdc g     O .bss	00000020 xFeeQueueTBL2
81139984 g     F .text	000000d4 OS_TaskStatStkChk
8113f764 g     F .text	00000158 OSTaskDelReq
81104b94 g     F .text	000000c4 bDpktGetPacketHeader
81106d58 g     F .text	000000c4 vRmapCh1HandleIrq
8112916c g     F .text	00001690 _dtoa_r
81149314 g     F .text	00000318 alt_msgdma_start_prefetcher_with_list_addr
81121840 g     F .text	00000814 _malloc_r
8115fbfc g     O .bss	00000020 SyncTBL0
81133974 g     F .text	00000030 __ascii_wctomb
8113bfe0 g     F .text	000001d0 OSMutexCreate
8111c26c g     F .text	00000068 vFailCouldNotRetransmitTimeoutTask
81112170 g     F .text	0000014c bCheckInAck32
81152b8c g     O .rwdata	00000004 alt_errno
81148e40 g     F .text	000000c0 alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor
811387ac g     F .text	00000078 OSStart
8110a2e4 g     F .text	000000e4 bSpwcGetLink
8110be84 g     F .text	000004e8 POWER_SPI_RW
81130ebc g     F .text	000000dc __submore
8113696c g     F .text	000000a0 altera_avalon_jtag_uart_report_log
81137a14 g     F .text	00000068 __env_unlock
8111c84c g     F .text	00000068 vCoudlNotCreateNFee1Task
8112ba90 g     F .text	000000cc _fwalk
8113fc18 g     F .text	000001dc OSTaskResume
8113bc70 g     F .text	000000f0 OSMemQuery
81152bf8 g     O .rwdata	00000002 OSTaskStatEn
8116ce8c g       *ABS*	00000000 __alt_stack_limit
81152c38 g     O .bss	00000004 ECommSpwCh
8111e188 g     F .text	0000003c vChangeAutoResetSync
8112bfe0 g     F .text	00000064 _mbtowc_r
81111b8c g     F .text	00000350 vInAckHandlerTaskV2
81152bd2 g     O .rwdata	00000002 OSMemMax
8113db40 g     F .text	00000178 OSQPostFront
81122458 g     F .text	000000d0 putc
811344c8 g     F .text	00000084 .hidden __divsi3
81152dc5 g     O .bss	00000006 OSRdyTbl
81152bac g     O .rwdata	00000002 OSDebugEn
811518f0 g     O .rwdata	0000002a alt_log_msg_cache
8112b188 g     F .text	0000012c _malloc_trim_r
81109d00 g     F .text	000001a4 bRmapInitCh
81152d24 g     O .bss	00000008 xSdHandle
8111f298 g     F .text	00000404 .hidden __mulsf3
81152bc4 g     O .rwdata	00000002 OSFlagNodeSize
81152c2c g     O .bss	00000004 pnt_memory
8111e1f4 g     F .text	00000048 vSyncReset
81111664 g     F .text	00000528 vLoadCtemp
8110cde4 g     F .text	00000040 bSyncSetPer
81100308 g     F .text	00000510 bDdr2EepromTest
81152dfc g     O .bss	00000004 status_register
81152c0c g     O .rwdata	00000002 OSTmrCfgMax
8110d778 g     F .text	00000074 bSyncIrqFlagClrError
8111be9c g     F .text	00000068 vFailSetPreAckSenderBuffer
8112da00 g     F .text	000000dc strcmp
81152e04 g     O .bss	00000004 command_register
8113d0cc g     F .text	000001b4 OSQCreate
8113f8bc g     F .text	000001a0 OSTaskNameGet
8115fc1c g     O .bss	00001000 vFeeTask4_stk
81160c1c g     O .bss	00000018 xReceivedACK
8113dcb8 g     F .text	00000214 OSQPostOpt
811388dc g     F .text	00000228 OSTimeTick
81152bf4 g     O .rwdata	00000002 OSTaskMax
8113e198 g     F .text	000000e0 OSSemCreate
81152c18 g     O .rwdata	00000002 OSTmrWheelSize
8111c69c g     F .text	00000068 vFailCreateScheduleQueue
8111e9d0 g     F .text	00000058 _reg_read
8113cc78 g     F .text	00000174 OSMutexQuery
81110a54 g     F .text	000000a4 bSendGiveBackNFeeCtrl
81135a1c g     F .text	00000088 .hidden __nedf2
81152bee g     O .rwdata	00000002 OSTaskDelEn
8111df64 g     F .text	00000038 vLoadDefaultEPValue
81160c34 g     O .bss	00001000 vFeeTask1_stk
8110d5a8 g     F .text	00000074 bSyncCtrCh7OutEnable
8113e960 g     F .text	00000118 OSSemQuery
8113d280 g     F .text	00000288 OSQDel
8113d85c g     F .text	00000174 OSQPendAbort
81152cf8 g     O .bss	00000004 xMutexPreParsed
811419e8 g     F .text	00000040 alt_irq_init
811373a0 g     F .text	0000006c alt_release_fd
81141d08 g     F .text	000000bc get_cluster_flag
8110d7ec g     F .text	00000074 bSyncIrqFlagClrBlank
81149a4c g     F .text	00000044 alt_msgdma_standard_descriptor_sync_transfer
8110cb30 g     F .text	0000002c vSyncClearCounter
81111460 g     F .text	00000204 bPrepareDoubleBuffer
811518bc g     O .rwdata	00000031 alt_log_msg_stackpointer
81122934 g     F .text	00000074 sprintf
81150074 g     O .rodata	00000100 .hidden __clz_tab
811422dc g     F .text	00000294 Write_File_Record_At_Offset
81101584 g     F .text	0000057c bDdr2MemoryWriteTest
8111b7d8 g     F .text	00000068 vFailGetMutexTxUARTSenderTask
81152d3c g     O .bss	00000004 _PathLocale
8110d8b8 g     F .text	00000058 bSyncIrqFlagBlank
8110bd3c g     F .text	000000c0 iMsgdmaConstructExtendedMmToMmDescriptor
81141094 g     F .text	000001e8 OSTmrStop
81109ef8 g     F .text	00000050 uliRmapReadReg
81119244 g     F .text	00000050 usiGetIdCMD
8110d9e4 g     F .text	00000058 uliSyncReadReg
8112f160 g     F .text	00000108 strtof
81105258 g     F .text	00000084 vFeebCh3HandleIrq
811346f4 g     F .text	000000bc .hidden __gesf2
81122afc g     F .text	0000004c strcspn
81128d44 g     F .text	00000068 _write_r
8110c3d8 g     F .text	00000074 vRstcReleaseDeviceReset
8111c020 g     F .text	0000004c vFailInAckHandlerTaskCreate
81138634 g     F .text	00000094 OSSchedLock
8111c91c g     F .text	00000068 vCoudlNotCreateNFee3Task
8112bd74 g     F .text	00000018 setlocale
81148da0 g     F .text	000000a0 alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor
811690c0 g     O .bss	00000800 OSTmrTaskStk
81122858 g     F .text	00000044 scanf
8111cb8c g     F .text	00000060 vFailCreateMutexSPUSQueueMeb
8113a23c g     F .text	00000110 OSFlagCreate
81142570 g     F .text	00000688 Check_for_DOS_FAT
81116074 g     F .text	00000064 vMebInit
8114441c g     F .text	000002d0 create_file
8112d9f8 g     F .text	00000008 nanf
81152b60 g     O .rwdata	00000004 _impure_ptr
81152e00 g     O .bss	00000004 CSD_register_w0
81152d60 g     O .bss	00000004 alt_argc
8111baf4 g     F .text	00000068 vFailGetCountSemaphorexBuffer128
8112a7fc g     F .text	00000224 __sflush_r
8112be00 g     F .text	000000b4 _mbrtowc_r
8110a58c g     F .text	00000090 bSpwcGetTimecode
8112bd60 g     F .text	00000008 __locale_cjk_lang
811033a4 g     F .text	0000078c sense_log
81152c3c g     O .bss	00000004 ESdmaBufferSide
81152bbe g     O .rwdata	00000002 OSEventMultiEn
81121080 g     F .text	00000004 _fseek_r
81161c34 g     O .bss	00001800 vParserCommTask_stk
8111b338 g     F .text	00000070 printErrorTask
8111dfd8 g     F .text	00000030 vChangeDefaultEPValue
811170fc g     F .text	000002c8 vCheckRetransmission32
81140864 g     F .text	000001c4 OSTmrCreate
81116220 g     F .text	000007dc vStackMonitor
81122620 g     F .text	000001dc __srefill_r
8110a944 g     F .text	0000003c bEnableLvdsBoard
81152cfc g     O .bss	00000004 xMutexBuffer32
81152ca4 g     O .bss	00000001 ucIterationSide
81106e1c g     F .text	00000040 vRmapCh2HandleIrq
8113a34c g     F .text	00000250 OSFlagDel
81152dcc g     O .bss	00000004 OSEventFreeList
8110a9bc g     F .text	000000c0 bSetPreEmphasys
8110f3d0 g     F .text	000001c4 vQCmdFEEinConfig
81100020 g       .exceptions	00000000 alt_irq_entry
8112bf94 g     F .text	0000004c __ascii_mbtowc
8110d0b4 g     F .text	00000078 bSyncCtrExtnIrq
811066b8 g     F .text	00000068 bFeebGetCh2LeftBufferEmpty
8112cde8 g     F .text	00000064 __ulp
8111db10 g     F .text	0000010c vNFeeControlInit
811160d8 g     F .text	000000a4 vSwapMemmory
8113a820 g     F .text	000005c0 OSFlagPend
81152c0a g     O .rwdata	00000002 OSTmrEn
8112ae54 g     F .text	00000018 __fp_unlock_all
81163434 g     O .bss	00000010 xDma
8112101c g     F .text	00000064 fputc
811107a4 g     F .text	00000058 bEnableRmapIRQ
8111898c g     F .text	000002f8 bSendUART32v2
81114854 g     F .text	0000019c setPreAckReceiverFreePos
8110d074 g     F .text	00000040 bSyncErrInj
81152b78 g     O .rwdata	00000008 alt_fs_list
81163444 g     O .bss	00001000 vSimMebTask_stk
8111cb24 g     F .text	00000068 vCoudlNotCreateMebTask
81142db8 g     F .text	00000274 check_file_name_for_FAT16_compliance
81164444 g     O .bss	00001000 vFeeTask3_stk
81140b68 g     F .text	00000140 OSTmrNameGet
81153094 g     O .bss	00000400 xSZData
8110f790 g     F .text	00000230 vQCmdFEEinFullPattern
81139764 g     F .text	0000007c OS_StrCopy
81152e0c g     O .bss	00000004 buffer_memory
8111bcfc g     F .text	00000068 vFailGetxMutexPreParsedParserRxTask
8111dde0 g     F .text	00000098 vLogWriteNUC
81152bd4 g     O .rwdata	00000002 OSMemNameSize
81103b30 g     F .text	000000b0 bSdmaInitM1Dma
8110d704 g     F .text	00000074 bSyncIrqEnableBlank
8114a9ac g     F .text	00000028 OSInitHookEnd
8111d540 g     F .text	00000340 vUpdateMemMapFEE
8111bf6c g     F .text	00000068 vFailSetPreAckReceiverBuffer
81105970 g     F .text	00000058 bFeebCh8IrqFlagBufferEmpty
81152c00 g     O .rwdata	00000002 OSTCBPrioTblMax
8112bd8c g     F .text	0000000c localeconv
8111cabc g     F .text	00000068 vCoudlNotCreateDataControllerTask
81152d00 g     O .bss	00000004 xTimerRetransmission
8111434c g     F .text	00000250 vReceiverUartTask
81152d5c g     O .bss	00000004 alt_log_sys_clk_count
81152bfc g     O .rwdata	00000002 OSTaskStatStkChkEn
81136bbc g     F .text	00000140 alt_log_write
81165444 g     O .bss	00001000 vFeeTask2_stk
81152d04 g     O .bss	00000004 xMutexBuffer128
81105194 g     F .text	00000040 vFeebCh1HandleIrq
8111e850 g     F .text	0000003c bStartSync
81105468 g     F .text	00000040 vFeebCh7HandleIrq
8111e88c g     F .text	00000030 bStopSync
81152c40 g     O .bss	00000004 ECommBufferSide
81149f84 g     F .text	00000058 alt_ic_isr_register
81152bd0 g     O .rwdata	00000002 OSMemEn
81106e5c g     F .text	00000040 vRmapCh3HandleIrq
81152b4c g     O .rwdata	00000004 alt_stack_limit_value
81115a38 g     F .text	00000388 vPusType252run
8111d084 g     F .text	0000004c vFailSendMsgMasterSyncMeb
81121640 g     F .text	0000003c fwrite
81152e10 g     O .bss	00000004 fat_partition_offset_in_512_byte_sectors
81152bda g     O .rwdata	00000002 OSMutexEn
8111ce24 g     F .text	00000068 vCouldNotGetQueueMaskDataCtrl
81152c28 g       *ABS*	00000000 _edata
81146e04 g     F .text	00000068 altera_avalon_uart_read_fd
8111dc90 g     F .text	00000034 vLoadDefaultIdNFEEMaster
8110507c g     F .text	0000008c usiAdcPxDelayCalcPeriodNs
8116ce8c g       *ABS*	00000000 _end
8116c88c g     O .bss	00000500 active_files
81152dd0 g     O .bss	00000001 OSIntNesting
8111b88c g     F .text	0000004c vFailInitialization
811014c8 g     F .text	000000bc bDdr2SwitchMemory
8111da0c g     F .text	0000002c cFeeRMAPDump
81105b70 g     F .text	000000d4 bFeebCh3SetBufferSize
81152d08 g     O .bss	00000004 xSemCountBuffer32
81132984 g     F .text	0000016c __fputwc
81152d0c g     O .bss	00000004 xQMaskFeeCtrl
8111d95c g     F .text	0000002c vFeeSpwRMAPChangeConfig
81128b04 g     F .text	00000070 vfscanf
811446ec g     F .text	00000150 copy_file_record_name_to_string
81146674 g     F .text	000000f8 altera_avalon_jtag_uart_ioctl
811405bc g     F .text	000001dc OSTimeDlyResume
81142bf8 g     F .text	000000f4 Look_for_FAT16
811107fc g     F .text	00000060 bDisableSPWChannel
8113a6cc g     F .text	00000154 OSFlagNameSet
8111094c g     F .text	00000064 bDisAndClrDbBuffer
81152d10 g     O .bss	00000004 xMutexBuffer64
81107d34 g     F .text	00000160 bRmapGetCodecError
8113fdf4 g     F .text	000001c8 OSTaskStkChk
8114a06c g     F .text	00000094 alt_ic_irq_disable
81103c90 g     F .text	0000045c bSdmaDmaM1Transfer
81152bd6 g     O .rwdata	00000002 OSMemSize
811155e8 g     F .text	00000204 vPusType252conf
8111b9bc g     F .text	00000068 vFailSetCountSemaphorexBuffer32
81122a0c g     F .text	00000084 __swrite
81152b68 g     O .rwdata	00000004 __malloc_trim_threshold
8112bd54 g     F .text	0000000c __locale_msgcharset
81166444 g     O .bss	00000020 xFeeQueueTBL1
81152dd4 g     O .bss	00000004 OSTCBCur
8111c33c g     F .text	00000068 vCouldNotRetransmitB64TimeoutTask
8110be40 g     F .text	00000044 iMsgdmaExtendedDescriptorSyncTransfer
8114aacc g     F .text	00000040 exit
8113ca58 g     F .text	00000220 OSMutexPost
8110d860 g     F .text	00000058 bSyncIrqFlagError
81144b18 g     F .text	000003c0 alt_up_sd_card_find_next
81152bd8 g     O .rwdata	00000002 OSMemTblSize
8112bb5c g     F .text	000000cc _fwalk_reent
81149198 g     F .text	000000a0 alt_msgdma_prefetcher_set_std_list_own_by_hw_bits
8111f7c8 g     F .text	000000f8 .hidden __floatunsisf
8112cbe4 g     F .text	00000204 __mdiff
8111c7e4 g     F .text	00000068 vCoudlNotCreateNFee0Task
81106068 g     F .text	0000017c vFeebInitIrq
8110483c g     F .text	0000022c bDpktSetPacketConfig
8111b924 g     F .text	0000004c vFailSenderCreate
8113454c g     F .text	00000074 .hidden __modsi3
8111c9ec g     F .text	00000068 vCoudlNotCreateNFee5Task
8110cfc0 g     F .text	0000003c uliSyncGetPer
81106f1c g     F .text	00000040 vRmapCh6HandleIrq
81152d14 g     O .bss	00000004 xMutexSenderACK
8111c19c g     F .text	00000068 vFailGetBlockingSemTimeoutTask
81152b58 g     O .rwdata	00000004 __ctype_ptr__
8111bf04 g     F .text	00000068 vFailSetPreParsedBuffer
81141c28 g     F .text	000000e0 Read_Sector_Data
811fa000 g       *ABS*	00000000 __alt_data_end
81100020 g     F .exceptions	00000000 alt_exception
8112ae30 g     F .text	00000004 __sfp_lock_release
811062b8 g     F .text	000000ac bFeebGetIrqControl
8111c474 g     F .text	00000068 vCouldNotSendTurnOff
8113847c g     F .text	00000064 OSInit
8110b2f4 g     F .text	00000078 bSetPainelLeds
811488e0 g     F .text	000000b0 alt_msgdma_construct_extended_mm_to_mm_descriptor
81152dd8 g     O .bss	00000004 OSTmrTime
81101b00 g     F .text	0000050c bDdr2MemoryReadTest
81107e94 g     F .text	000002ec bRmapSetMemConfigArea
811401a8 g     F .text	0000012c OSTaskQuery
8110d690 g     F .text	00000074 bSyncIrqEnableError
81152d18 g     O .bss	00000004 xMutexPus
8113e030 g     F .text	000000b0 OS_QInit
8112d928 g     F .text	000000d0 __sccl
81120e48 g     F .text	0000000c atoi
8110db60 g     F .text	00001688 vFeeTask
811397e0 g     F .text	0000005c OS_StrLen
8111d24c g     F .text	0000004c vFailFlushNFEEQueue
81105760 g     F .text	00000058 bFeebCh2IrqFlagBufferEmpty
8111b258 g     F .text	000000e0 vDataControllerInit
8113ba74 g     F .text	0000011c OSMemNameSet
81150174 g     O .rodata	00000101 _ctype_
8110cf84 g     F .text	0000003c uliSyncGetBt
84000000 g       *ABS*	00000000 __alt_mem_ext_flash
8111ba8c g     F .text	00000068 vFailSetCountSemaphorexBuffer128
81152bf2 g     O .rwdata	00000002 OSTaskProfileEn
8111d298 g     F .text	00000028 vEvtChangeMebMode
811487b0 g     F .text	00000098 alt_msgdma_construct_extended_st_to_mm_descriptor
81152d1c g     O .bss	00000004 xTxUARTMutex
81152ddc g     O .bss	00000004 OSTime
81152b70 g     O .rwdata	00000004 __mbtowc
81147424 g     F .text	0000005c altera_avalon_uart_close
8110f1e8 g     F .text	000001e8 vQCmdFEEinWaitingSync
81152de0 g     O .bss	00000004 OSTmrSem
81115594 g     F .text	00000054 vPusType251conf
811698c0 g     O .bss	00001000 OSTaskIdleStk
81120e60 g     F .text	000000fc _fopen_r
81152cb8 g     O .bss	00000004 pdata
8114adfc g     F .text	000000bc _exit
811064f8 g     F .text	00000078 bFeebGetLeftBufferEmpty
81149ad4 g     F .text	00000134 alt_alarm_start
8113a59c g     F .text	00000130 OSFlagNameGet
81140798 g     F .text	00000064 OSTimeGet
81152c44 g     O .bss	00000004 ESdmaChBufferId
8114537c g     F .text	00000380 alt_up_sd_card_read
811070ec g     F .text	00000044 vRmapCh5IrqFlagClrWriteCmd
8112167c g     F .text	000001c4 __smakebuf_r
81152d20 g     O .bss	00000001 SemCount64
81118694 g     F .text	000002f8 bSendUART64v2
8111d1b4 g     F .text	0000004c vFailFlushQueueData
81105810 g     F .text	00000058 bFeebCh4IrqFlagBufferEmpty
81152c20 g     O .rwdata	00000008 alt_msgdma_list
81122b48 g     F .text	00000098 strlen
8110c67c g     F .text	000000b4 uc_spi_get_byte
81107130 g     F .text	00000044 vRmapCh6IrqFlagClrWriteCmd
8111ce8c g     F .text	00000054 vFailSendMsgAccessDMA
8114a8dc g     F .text	00000028 OSTaskSwHook
811370fc g     F .text	0000015c open
81109534 g     F .text	000007cc bRmapGetRmapMemHKArea
8116a8c0 g     O .bss	00000d00 OSEventTbl
8111d988 g     F .text	0000002c vFeeSpwRMAPChangeDefault
8111f8c0 g     F .text	000000dc .hidden __gedf2
8111d030 g     F .text	00000054 vFailSendMsgSyncRMAPTRIGGER
81166464 g     O .bss	00000020 xSenderACK
8114a5d0 g     F .text	00000044 alt_putchar
8116b5c0 g     O .bss	000011b8 OSTCBTbl
81132c9c g     F .text	00000838 __gethex
8113ea78 g     F .text	00000108 OSSemSet
811169fc g     F .text	0000006c vTimeoutCheckerTaskv2
8111da38 g     F .text	00000038 cFeeRMAPEchoingEnable
81152b74 g     O .rwdata	00000004 __wctomb
81117834 g     F .text	00000314 vVariablesInitialization
81131250 g     F .text	00000018 __sprint_r
8110fed4 g     F .text	00000458 vQCmdFeeRMAPinFullPattern
81106364 g     F .text	00000088 bFeebGetIrqFlags
81152c34 g     O .bss	00000004 pxDmaM2Dev
8111b454 g     F .text	0000004c vFailCreateSemaphoreResources
81152b90 g     O .rwdata	00000004 alt_priority_mask
8110a980 g     F .text	0000003c bDisableLvdsBoard
8113e278 g     F .text	00000248 OSSemDel
81105a9c g     F .text	000000d4 bFeebCh2SetBufferSize
81152de4 g     O .bss	00000004 OSFlagFreeList
8110c5b8 g     F .text	000000c4 v_spi_send_byte
8110c8ec g     F .text	000000d0 bSSDisplayConfig
81149fdc g     F .text	00000090 alt_ic_irq_enable
81152bb8 g     O .rwdata	00000002 OSEventNameSize
81127260 g     F .text	0000001c __vfprintf_internal
81152de8 g     O .bss	00000001 OSStatRdy
8110d364 g     F .text	00000074 bSyncCtrCh2OutEnable
8116c778 g     O .bss	000000ac OSTCBPrioTbl
811474c4 g     F .text	00000270 altera_avalon_uart_read
811339a4 g     F .text	00000064 _wctomb_r
81137948 g     F .text	000000cc __env_lock
81152bfe g     O .rwdata	00000002 OSTaskSwHookEn
811535ac g     O .bss	00000100 cTemp
81105570 g     F .text	00000044 vFeebCh3IrqFlagClrBufferEmpty
811200bc g     F .text	00000904 .hidden __subdf3
81166484 g     O .bss	00000260 xPreParsed
8110cffc g     F .text	0000003c uliSyncGetOst
81152d21 g     O .bss	00000001 SemCount128
81106f9c g     F .text	00000040 vRmapCh8HandleIrq
8110563c g     F .text	00000044 vFeebCh6IrqFlagClrBufferEmpty
81118c84 g     F .text	00000290 vSendEthConf
811046bc g     F .text	000000dc bCommInitCh
8112c5f8 g     F .text	000000b0 __lo0bits
81127340 g     F .text	000017c4 __svfscanf_r
81152b9c g     O .rwdata	00000008 alt_alarm_list
81130f98 g     F .text	0000019c _ungetc_r
81152bc6 g     O .rwdata	00000002 OSFlagWidth
81106fdc g     F .text	00000044 vRmapCh1IrqFlagClrWriteCmd
81102a40 g     F .text	0000004c DMA_BUSY
811338ac g     F .text	000000c8 wcrtomb
81104c58 g     F .text	00000148 bDpktSetPixelDelay
811181c8 g     F .text	0000014c vCCDLoadDefaultValues
81135dbc g     F .text	000000d8 close
8110d038 g     F .text	0000003c uliSyncGetGeneral
8111d2e8 g     F .text	00000028 vEvtChangeDataControllerMode
81152d78 g     O .bss	00000004 alt_envsem
811362ec g     F .text	00000068 alt_log_repchar
81152dec g     O .bss	00000004 OSIdleCtrRun
81138b04 g     F .text	00000028 OSVersion
81152c10 g     O .rwdata	00000002 OSTmrCfgWheelSize
811402d4 g     F .text	00000078 OS_TaskStkClr
8111e510 g     F .text	0000003c siOpenFile
8110dac0 g     F .text	000000a0 vDataControlTask
81152bea g     O .rwdata	00000002 OSTaskCreateEn
81107254 g     F .text	00000058 bRmapCh2IrqFlagWriteCmd
8110769c g     F .text	00000050 uliRmapCh7WriteCmdAddress
81106998 g     F .text	00000088 bFeebStartCh
81118f14 g     F .text	00000118 vSendTurnOff
8111b554 g     F .text	0000004c vFailSendPreParsedSemaphore
811430ec g     F .text	000002a4 match_file_record_to_name_ext
8113912c g     F .text	00000070 OS_EventWaitListInit
81132b14 g     F .text	00000088 fputwc
811666e4 g     O .bss	00000020 xFeeQueueTBL0
8111b4ec g     F .text	00000068 vFailSendxSemCommInit
8114a9d4 g     F .text	00000028 OSTaskIdleHook
8111902c g     F .text	00000118 vSendReset
8112ae34 g     F .text	00000004 __sinit_lock_acquire
8112c35c g     F .text	00000128 __multadd
81166704 g     O .bss	00000020 SyncTBL1
81105680 g     F .text	00000044 vFeebCh7IrqFlagClrBufferEmpty
8110cc88 g     F .text	0000004c ucSyncStatusState
8113ffbc g     F .text	000001ec OSTaskSuspend
8112c334 g     F .text	00000028 _Bfree
8110cf48 g     F .text	0000003c uliSyncGetMbt
8113983c g     F .text	00000064 OS_TaskIdle
81152c16 g     O .rwdata	00000002 OSTmrTblSize
8113decc g     F .text	00000164 OSQQuery



Disassembly of section .exceptions:

81100020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
81100020:	deffed04 	addi	sp,sp,-76

#ifdef ALT_STACK_CHECK
        /* Ensure stack didn't just overflow. */
        bltu  sp, et, .Lstack_overflow
81100024:	de003636 	bltu	sp,et,81100100 <alt_exception+0xe0>
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
81100028:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
8110002c:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
81100030:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
81100034:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
81100038:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
8110003c:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
81100040:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
81100044:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
81100048:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
8110004c:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
81100050:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
81100054:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
81100058:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
8110005c:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
81100060:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
81100064:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
81100068:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
8110006c:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
81100070:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
81100074:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
81100078:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
8110007c:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
81100080:	10000326 	beq	r2,zero,81100090 <alt_exception+0x70>
        beq   r4, zero, .Lnot_irq
81100084:	20000226 	beq	r4,zero,81100090 <alt_exception+0x70>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
81100088:	11001040 	call	81100104 <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
8110008c:	00000706 	br	811000ac <alt_exception+0x8c>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
81100090:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
81100094:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
81100098:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
8110009c:	11001e00 	call	811001e0 <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
811000a0:	1000021e 	bne	r2,zero,811000ac <alt_exception+0x8c>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
811000a4:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
811000a8:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
811000ac:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
811000b0:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
811000b4:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
811000b8:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
811000bc:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
811000c0:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
811000c4:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
811000c8:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
811000cc:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
811000d0:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
811000d4:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
811000d8:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
811000dc:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
811000e0:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
811000e4:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
811000e8:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
811000ec:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
811000f0:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
811000f4:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
811000f8:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
811000fc:	ef80083a 	eret

#ifdef ALT_STACK_CHECK
.Lstack_overflow:
        break 3
81100100:	003da0fa 	break	3

81100104 <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
81100104:	defff904 	addi	sp,sp,-28
81100108:	de00012e 	bgeu	sp,et,81100110 <alt_irq_handler+0xc>
8110010c:	003b68fa 	trap	3
81100110:	dfc00615 	stw	ra,24(sp)
81100114:	df000515 	stw	fp,20(sp)
81100118:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
8110011c:	11384e00 	call	811384e0 <OSIntEnter>
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
81100120:	0005313a 	rdctl	r2,ipending
81100124:	e0bffe15 	stw	r2,-8(fp)

  return active;
81100128:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
8110012c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
81100130:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
81100134:	00800044 	movi	r2,1
81100138:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
8110013c:	e0fffb17 	ldw	r3,-20(fp)
81100140:	e0bffc17 	ldw	r2,-16(fp)
81100144:	1884703a 	and	r2,r3,r2
81100148:	10001426 	beq	r2,zero,8110019c <alt_irq_handler+0x98>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
8110014c:	00a045f4 	movhi	r2,33047
81100150:	10b36304 	addi	r2,r2,-12916
81100154:	e0fffd17 	ldw	r3,-12(fp)
81100158:	180690fa 	slli	r3,r3,3
8110015c:	10c5883a 	add	r2,r2,r3
81100160:	10c00017 	ldw	r3,0(r2)
81100164:	00a045f4 	movhi	r2,33047
81100168:	10b36304 	addi	r2,r2,-12916
8110016c:	e13ffd17 	ldw	r4,-12(fp)
81100170:	200890fa 	slli	r4,r4,3
81100174:	1105883a 	add	r2,r2,r4
81100178:	10800104 	addi	r2,r2,4
8110017c:	10800017 	ldw	r2,0(r2)
81100180:	1009883a 	mov	r4,r2
81100184:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
81100188:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
8110018c:	0005313a 	rdctl	r2,ipending
81100190:	e0bfff15 	stw	r2,-4(fp)

  return active;
81100194:	e0bfff17 	ldw	r2,-4(fp)
81100198:	00000706 	br	811001b8 <alt_irq_handler+0xb4>
      }
      mask <<= 1;
8110019c:	e0bffc17 	ldw	r2,-16(fp)
811001a0:	1085883a 	add	r2,r2,r2
811001a4:	e0bffc15 	stw	r2,-16(fp)
      i++;
811001a8:	e0bffd17 	ldw	r2,-12(fp)
811001ac:	10800044 	addi	r2,r2,1
811001b0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
811001b4:	003fe106 	br	8110013c <__reset+0xfb0e013c>

    active = alt_irq_pending ();
811001b8:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
811001bc:	e0bffb17 	ldw	r2,-20(fp)
811001c0:	103fdb1e 	bne	r2,zero,81100130 <__reset+0xfb0e0130>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
811001c4:	11385340 	call	81138534 <OSIntExit>
}
811001c8:	0001883a 	nop
811001cc:	e037883a 	mov	sp,fp
811001d0:	dfc00117 	ldw	ra,4(sp)
811001d4:	df000017 	ldw	fp,0(sp)
811001d8:	dec00204 	addi	sp,sp,8
811001dc:	f800283a 	ret

811001e0 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
811001e0:	defffb04 	addi	sp,sp,-20
811001e4:	de00012e 	bgeu	sp,et,811001ec <alt_instruction_exception_entry+0xc>
811001e8:	003b68fa 	trap	3
811001ec:	dfc00415 	stw	ra,16(sp)
811001f0:	df000315 	stw	fp,12(sp)
811001f4:	df000304 	addi	fp,sp,12
811001f8:	e13fff15 	stw	r4,-4(fp)
 * NIOS2_EXCEPTION_CAUSE_NOT_PRESENT. Your handling routine should
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
811001fc:	000531fa 	rdctl	r2,exception
81100200:	e0bffd15 	stw	r2,-12(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
81100204:	e0bffd17 	ldw	r2,-12(fp)
81100208:	10801f0c 	andi	r2,r2,124
8110020c:	1004d0ba 	srli	r2,r2,2
81100210:	e0bffd15 	stw	r2,-12(fp)
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
81100214:	0005333a 	rdctl	r2,badaddr
81100218:	e0bffe15 	stw	r2,-8(fp)
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
8110021c:	d0a0b717 	ldw	r2,-32036(gp)
81100220:	10000726 	beq	r2,zero,81100240 <alt_instruction_exception_entry+0x60>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
81100224:	d0a0b717 	ldw	r2,-32036(gp)
81100228:	e0fffd17 	ldw	r3,-12(fp)
8110022c:	e1bffe17 	ldw	r6,-8(fp)
81100230:	e17fff17 	ldw	r5,-4(fp)
81100234:	1809883a 	mov	r4,r3
81100238:	103ee83a 	callr	r2
8110023c:	00000206 	br	81100248 <alt_instruction_exception_entry+0x68>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
81100240:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
81100244:	0005883a 	mov	r2,zero
}
81100248:	e037883a 	mov	sp,fp
8110024c:	dfc00117 	ldw	ra,4(sp)
81100250:	df000017 	ldw	fp,0(sp)
81100254:	dec00204 	addi	sp,sp,8
81100258:	f800283a 	ret

Disassembly of section .text:

8110025c <_start>:
    .int 2, 1, 0b, 1b
    .popsection
#endif /* Initialize Data Cache */

    /* Log that caches have been initialized. */
    ALT_LOG_PUTS(alt_log_msg_cache)
8110025c:	01204574 	movhi	r4,33045
81100260:	210ae504 	addi	r4,r4,11156
81100264:	21400037 	ldwio	r5,0(r4)
81100268:	01400326 	beq	zero,r5,81100278 <_start+0x1c>
8110026c:	01204574 	movhi	r4,33045
81100270:	21063c04 	addi	r4,r4,6384
81100274:	11362640 	call	81136264 <tx_log_str>

    /* Log that the stack pointer is about to be setup. */
    ALT_LOG_PUTS(alt_log_msg_stackpointer)
81100278:	01204574 	movhi	r4,33045
8110027c:	210ae504 	addi	r4,r4,11156
81100280:	21400037 	ldwio	r5,0(r4)
81100284:	01400326 	beq	zero,r5,81100294 <_start+0x38>
81100288:	01204574 	movhi	r4,33045
8110028c:	21062f04 	addi	r4,r4,6332
81100290:	11362640 	call	81136264 <tx_log_str>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
81100294:	06e047f4 	movhi	sp,33055
    ori sp, sp, %lo(__alt_stack_pointer)
81100298:	dee80014 	ori	sp,sp,40960
    movhi gp, %hi(_gp)
8110029c:	06a04574 	movhi	gp,33045
    ori gp, gp, %lo(_gp)
811002a0:	d6aad314 	ori	gp,gp,43852
 * by the linker script. They mark the begining and the end of the bss
 * region. The linker script guarantees that these values are word aligned.
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)
811002a4:	01204574 	movhi	r4,33045
811002a8:	210ae504 	addi	r4,r4,11156
811002ac:	21400037 	ldwio	r5,0(r4)
811002b0:	01400326 	beq	zero,r5,811002c0 <_start+0x64>
811002b4:	01204574 	movhi	r4,33045
811002b8:	21062004 	addi	r4,r4,6272
811002bc:	11362640 	call	81136264 <tx_log_str>

    movhi r2, %hi(__bss_start)
811002c0:	00a04574 	movhi	r2,33045
    ori r2, r2, %lo(__bss_start)
811002c4:	108b0a14 	ori	r2,r2,11304

    movhi r3, %hi(__bss_end)
811002c8:	00e045b4 	movhi	r3,33046
    ori r3, r3, %lo(__bss_end)
811002cc:	18f3a314 	ori	r3,r3,52876

    beq r2, r3, 1f
811002d0:	10c00326 	beq	r2,r3,811002e0 <_start+0x84>

0:
    stw zero, (r2)
811002d4:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
811002d8:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
811002dc:	10fffd36 	bltu	r2,r3,811002d4 <__reset+0xfb0e02d4>
    /*
     * Set up the stack limit (if required).  The linker has set up the
     * copy of the variable which is in memory.
     */

    ldw   et, %gprel(alt_stack_limit_value)(gp)
811002e0:	d6200017 	ldw	et,-32768(gp)
#endif

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)
811002e4:	01204574 	movhi	r4,33045
811002e8:	210ae504 	addi	r4,r4,11156
811002ec:	21400037 	ldwio	r5,0(r4)
811002f0:	01400326 	beq	zero,r5,81100300 <_start+0xa4>
811002f4:	01204574 	movhi	r4,33045
811002f8:	21062704 	addi	r4,r4,6300
811002fc:	11362640 	call	81136264 <tx_log_str>

    /* Call the C entry point. It should never return. */
    call alt_main
81100300:	1136e900 	call	81136e90 <alt_main>

81100304 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
81100304:	003fff06 	br	81100304 <__reset+0xfb0e0304>

81100308 <bDdr2EepromTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2EepromTest(alt_u8 ucMemoryId) {
81100308:	defff604 	addi	sp,sp,-40
8110030c:	de00012e 	bgeu	sp,et,81100314 <bDdr2EepromTest+0xc>
81100310:	003b68fa 	trap	3
81100314:	dfc00915 	stw	ra,36(sp)
81100318:	df000815 	stw	fp,32(sp)
8110031c:	df000804 	addi	fp,sp,32
81100320:	2005883a 	mov	r2,r4
81100324:	e0bfff05 	stb	r2,-4(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 EEPROM Test =====\n");
81100328:	00e04574 	movhi	r3,33045
8110032c:	18cbe504 	addi	r3,r3,12180
81100330:	00a04574 	movhi	r2,33045
81100334:	10abae04 	addi	r2,r2,-20808
81100338:	1009883a 	mov	r4,r2
8110033c:	00800884 	movi	r2,34
81100340:	100d883a 	mov	r6,r2
81100344:	200b883a 	mov	r5,r4
81100348:	1809883a 	mov	r4,r3
8110034c:	11220540 	call	81122054 <memcpy>
	debug(fp, cDebugBuffer);
81100350:	d0a06217 	ldw	r2,-32376(gp)
81100354:	01604574 	movhi	r5,33045
81100358:	294be504 	addi	r5,r5,12180
8110035c:	1009883a 	mov	r4,r2
81100360:	1120fa40 	call	81120fa4 <fprintf>
#endif
	const alt_u8 cucDeviceAddr = DDR2_EEPROM_I2C_ADDRESS;
81100364:	00bfe804 	movi	r2,-96
81100368:	e0bffd05 	stb	r2,-12(fp)
	bool bSuccess;
	alt_u32 uliI2cSclBase;
	alt_u32 uliI2cSdaBase;
	int iI;

	bSuccess = TRUE;
8110036c:	00800044 	movi	r2,1
81100370:	e0bff915 	stw	r2,-28(fp)
	switch (ucMemoryId) {
81100374:	e0bfff03 	ldbu	r2,-4(fp)
81100378:	10000326 	beq	r2,zero,81100388 <bDdr2EepromTest+0x80>
8110037c:	10800060 	cmpeqi	r2,r2,1
81100380:	1000081e 	bne	r2,zero,811003a4 <bDdr2EepromTest+0x9c>
81100384:	00000e06 	br	811003c0 <bDdr2EepromTest+0xb8>
	case DDR2_M1_ID:
		uliI2cSclBase = DDR2_M1_EEPROM_I2C_SCL_BASE;
81100388:	00a00034 	movhi	r2,32768
8110038c:	10827c04 	addi	r2,r2,2544
81100390:	e0bffa15 	stw	r2,-24(fp)
		uliI2cSdaBase = DDR2_M1_EEPROM_I2C_SDA_BASE;
81100394:	00a00034 	movhi	r2,32768
81100398:	10828004 	addi	r2,r2,2560
8110039c:	e0bffb15 	stw	r2,-20(fp)
		break;
811003a0:	00001906 	br	81100408 <bDdr2EepromTest+0x100>
	case DDR2_M2_ID:
		uliI2cSclBase = DDR2_M2_EEPROM_I2C_SCL_BASE;
811003a4:	00a00034 	movhi	r2,32768
811003a8:	10825804 	addi	r2,r2,2400
811003ac:	e0bffa15 	stw	r2,-24(fp)
		uliI2cSdaBase = DDR2_M2_EEPROM_I2C_SDA_BASE;
811003b0:	00a00034 	movhi	r2,32768
811003b4:	10825c04 	addi	r2,r2,2416
811003b8:	e0bffb15 	stw	r2,-20(fp)
		break;
811003bc:	00001206 	br	81100408 <bDdr2EepromTest+0x100>
	default:
		bSuccess = FALSE;
811003c0:	e03ff915 	stw	zero,-28(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811003c4:	00e04574 	movhi	r3,33045
811003c8:	18cbe504 	addi	r3,r3,12180
811003cc:	00a04574 	movhi	r2,33045
811003d0:	10abb704 	addi	r2,r2,-20772
811003d4:	1009883a 	mov	r4,r2
811003d8:	00800bc4 	movi	r2,47
811003dc:	100d883a 	mov	r6,r2
811003e0:	200b883a 	mov	r5,r4
811003e4:	1809883a 	mov	r4,r3
811003e8:	11220540 	call	81122054 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
811003ec:	d0a06217 	ldw	r2,-32376(gp)
811003f0:	01604574 	movhi	r5,33045
811003f4:	294be504 	addi	r5,r5,12180
811003f8:	1009883a 	mov	r4,r2
811003fc:	1120fa40 	call	81120fa4 <fprintf>
		;
#endif
		return bSuccess;
81100400:	e0bff917 	ldw	r2,-28(fp)
81100404:	0000ff06 	br	81100804 <bDdr2EepromTest+0x4fc>
	}

	alt_u8 ucControlAddr, ucValue;
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Read Test\n");
81100408:	00e04574 	movhi	r3,33045
8110040c:	18cbe504 	addi	r3,r3,12180
81100410:	00a04574 	movhi	r2,33045
81100414:	10abc304 	addi	r2,r2,-20724
81100418:	1009883a 	mov	r4,r2
8110041c:	008005c4 	movi	r2,23
81100420:	100d883a 	mov	r6,r2
81100424:	200b883a 	mov	r5,r4
81100428:	1809883a 	mov	r4,r3
8110042c:	11220540 	call	81122054 <memcpy>
	debug(fp, cDebugBuffer);
81100430:	d0a06217 	ldw	r2,-32376(gp)
81100434:	01604574 	movhi	r5,33045
81100438:	294be504 	addi	r5,r5,12180
8110043c:	1009883a 	mov	r4,r2
81100440:	1120fa40 	call	81120fa4 <fprintf>
#endif
	usleep(20 * 1000);
81100444:	01138804 	movi	r4,20000
81100448:	11376bc0 	call	811376bc <usleep>
	for (iI = 0; iI < 256 && bSuccess; iI++) {
8110044c:	e03ffc15 	stw	zero,-16(fp)
81100450:	00003306 	br	81100520 <bDdr2EepromTest+0x218>
		ucControlAddr = iI;
81100454:	e0bffc17 	ldw	r2,-16(fp)
81100458:	e0bffd45 	stb	r2,-11(fp)
		bSuccess = I2C_Read(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
8110045c:	e0bffd03 	ldbu	r2,-12(fp)
81100460:	10c03fcc 	andi	r3,r2,255
81100464:	18c0201c 	xori	r3,r3,128
81100468:	18ffe004 	addi	r3,r3,-128
8110046c:	e13ffd43 	ldbu	r4,-11(fp)
81100470:	e0bffe04 	addi	r2,fp,-8
81100474:	d8800015 	stw	r2,0(sp)
81100478:	200f883a 	mov	r7,r4
8110047c:	180d883a 	mov	r6,r3
81100480:	e17ffb17 	ldw	r5,-20(fp)
81100484:	e13ffa17 	ldw	r4,-24(fp)
81100488:	110ac600 	call	8110ac60 <I2C_Read>
8110048c:	e0bff915 	stw	r2,-28(fp)
				ucControlAddr, &ucValue);
		if (bSuccess) {
81100490:	e0bff917 	ldw	r2,-28(fp)
81100494:	10001026 	beq	r2,zero,811004d8 <bDdr2EepromTest+0x1d0>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "EEPROM[%03d]=%02Xh\n", ucControlAddr,
81100498:	e0bffd43 	ldbu	r2,-11(fp)
8110049c:	e0fffe03 	ldbu	r3,-8(fp)
811004a0:	18c03fcc 	andi	r3,r3,255
811004a4:	180f883a 	mov	r7,r3
811004a8:	100d883a 	mov	r6,r2
811004ac:	01604574 	movhi	r5,33045
811004b0:	296bc904 	addi	r5,r5,-20700
811004b4:	01204574 	movhi	r4,33045
811004b8:	210be504 	addi	r4,r4,12180
811004bc:	11229340 	call	81122934 <sprintf>
					ucValue);
			debug(fp, cDebugBuffer);
811004c0:	d0a06217 	ldw	r2,-32376(gp)
811004c4:	01604574 	movhi	r5,33045
811004c8:	294be504 	addi	r5,r5,12180
811004cc:	1009883a 	mov	r4,r2
811004d0:	1120fa40 	call	81120fa4 <fprintf>
811004d4:	00000f06 	br	81100514 <bDdr2EepromTest+0x20c>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "Failed to read EEPROM\n");
811004d8:	00e04574 	movhi	r3,33045
811004dc:	18cbe504 	addi	r3,r3,12180
811004e0:	00a04574 	movhi	r2,33045
811004e4:	10abce04 	addi	r2,r2,-20680
811004e8:	1009883a 	mov	r4,r2
811004ec:	008005c4 	movi	r2,23
811004f0:	100d883a 	mov	r6,r2
811004f4:	200b883a 	mov	r5,r4
811004f8:	1809883a 	mov	r4,r3
811004fc:	11220540 	call	81122054 <memcpy>
			debug(fp, cDebugBuffer);
81100500:	d0a06217 	ldw	r2,-32376(gp)
81100504:	01604574 	movhi	r5,33045
81100508:	294be504 	addi	r5,r5,12180
8110050c:	1009883a 	mov	r4,r2
81100510:	1120fa40 	call	81120fa4 <fprintf>
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Read Test\n");
	debug(fp, cDebugBuffer);
#endif
	usleep(20 * 1000);
	for (iI = 0; iI < 256 && bSuccess; iI++) {
81100514:	e0bffc17 	ldw	r2,-16(fp)
81100518:	10800044 	addi	r2,r2,1
8110051c:	e0bffc15 	stw	r2,-16(fp)
81100520:	e0bffc17 	ldw	r2,-16(fp)
81100524:	10804008 	cmpgei	r2,r2,256
81100528:	1000021e 	bne	r2,zero,81100534 <bDdr2EepromTest+0x22c>
8110052c:	e0bff917 	ldw	r2,-28(fp)
81100530:	103fc81e 	bne	r2,zero,81100454 <__reset+0xfb0e0454>
			sprintf(cDebugBuffer, "Failed to read EEPROM\n");
			debug(fp, cDebugBuffer);
#endif
		}
	}
	if (bSuccess) {
81100534:	e0bff917 	ldw	r2,-28(fp)
81100538:	10001026 	beq	r2,zero,8110057c <bDdr2EepromTest+0x274>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Read Test Completed\n\n");
8110053c:	00e04574 	movhi	r3,33045
81100540:	18cbe504 	addi	r3,r3,12180
81100544:	00a04574 	movhi	r2,33045
81100548:	10abd404 	addi	r2,r2,-20656
8110054c:	1009883a 	mov	r4,r2
81100550:	00800884 	movi	r2,34
81100554:	100d883a 	mov	r6,r2
81100558:	200b883a 	mov	r5,r4
8110055c:	1809883a 	mov	r4,r3
81100560:	11220540 	call	81122054 <memcpy>
		debug(fp, cDebugBuffer);
81100564:	d0a06217 	ldw	r2,-32376(gp)
81100568:	01604574 	movhi	r5,33045
8110056c:	294be504 	addi	r5,r5,12180
81100570:	1009883a 	mov	r4,r2
81100574:	1120fa40 	call	81120fa4 <fprintf>
81100578:	00000f06 	br	811005b8 <bDdr2EepromTest+0x2b0>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Read Test Failed\n\n");
8110057c:	00e04574 	movhi	r3,33045
81100580:	18cbe504 	addi	r3,r3,12180
81100584:	00a04574 	movhi	r2,33045
81100588:	10abdd04 	addi	r2,r2,-20620
8110058c:	1009883a 	mov	r4,r2
81100590:	008007c4 	movi	r2,31
81100594:	100d883a 	mov	r6,r2
81100598:	200b883a 	mov	r5,r4
8110059c:	1809883a 	mov	r4,r3
811005a0:	11220540 	call	81122054 <memcpy>
		debug(fp, cDebugBuffer);
811005a4:	d0a06217 	ldw	r2,-32376(gp)
811005a8:	01604574 	movhi	r5,33045
811005ac:	294be504 	addi	r5,r5,12180
811005b0:	1009883a 	mov	r4,r2
811005b4:	1120fa40 	call	81120fa4 <fprintf>
#endif
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Write Test\n");
811005b8:	00e04574 	movhi	r3,33045
811005bc:	18cbe504 	addi	r3,r3,12180
811005c0:	00a04574 	movhi	r2,33045
811005c4:	10abe504 	addi	r2,r2,-20588
811005c8:	1009883a 	mov	r4,r2
811005cc:	00800604 	movi	r2,24
811005d0:	100d883a 	mov	r6,r2
811005d4:	200b883a 	mov	r5,r4
811005d8:	1809883a 	mov	r4,r3
811005dc:	11220540 	call	81122054 <memcpy>
	debug(fp, cDebugBuffer);
811005e0:	d0a06217 	ldw	r2,-32376(gp)
811005e4:	01604574 	movhi	r5,33045
811005e8:	294be504 	addi	r5,r5,12180
811005ec:	1009883a 	mov	r4,r2
811005f0:	1120fa40 	call	81120fa4 <fprintf>
#endif
	alt_u8 ucWriteData = 0x12, ucTestAddr = 128;
811005f4:	00800484 	movi	r2,18
811005f8:	e0bffd85 	stb	r2,-10(fp)
811005fc:	00bfe004 	movi	r2,-128
81100600:	e0bffdc5 	stb	r2,-9(fp)
	alt_u8 ucReadData;
	usleep(20 * 1000);
81100604:	01138804 	movi	r4,20000
81100608:	11376bc0 	call	811376bc <usleep>
	bSuccess = I2C_Write(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
8110060c:	e0bffd03 	ldbu	r2,-12(fp)
81100610:	10c03fcc 	andi	r3,r2,255
81100614:	18c0201c 	xori	r3,r3,128
81100618:	18ffe004 	addi	r3,r3,-128
8110061c:	e13ffdc3 	ldbu	r4,-9(fp)
81100620:	e0bffd83 	ldbu	r2,-10(fp)
81100624:	d8800015 	stw	r2,0(sp)
81100628:	200f883a 	mov	r7,r4
8110062c:	180d883a 	mov	r6,r3
81100630:	e17ffb17 	ldw	r5,-20(fp)
81100634:	e13ffa17 	ldw	r4,-24(fp)
81100638:	110ab800 	call	8110ab80 <I2C_Write>
8110063c:	e0bff915 	stw	r2,-28(fp)
			ucTestAddr, ucWriteData);
	if (!bSuccess) {
81100640:	e0bff917 	ldw	r2,-28(fp)
81100644:	1000101e 	bne	r2,zero,81100688 <bDdr2EepromTest+0x380>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Failed to write EEPROM\n");
81100648:	00e04574 	movhi	r3,33045
8110064c:	18cbe504 	addi	r3,r3,12180
81100650:	00a04574 	movhi	r2,33045
81100654:	10abeb04 	addi	r2,r2,-20564
81100658:	1009883a 	mov	r4,r2
8110065c:	00800604 	movi	r2,24
81100660:	100d883a 	mov	r6,r2
81100664:	200b883a 	mov	r5,r4
81100668:	1809883a 	mov	r4,r3
8110066c:	11220540 	call	81122054 <memcpy>
		debug(fp, cDebugBuffer);
81100670:	d0a06217 	ldw	r2,-32376(gp)
81100674:	01604574 	movhi	r5,33045
81100678:	294be504 	addi	r5,r5,12180
8110067c:	1009883a 	mov	r4,r2
81100680:	1120fa40 	call	81120fa4 <fprintf>
81100684:	00003306 	br	81100754 <bDdr2EepromTest+0x44c>
#endif
	} else {
		bSuccess = I2C_Read(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100688:	e0bffd03 	ldbu	r2,-12(fp)
8110068c:	10c03fcc 	andi	r3,r2,255
81100690:	18c0201c 	xori	r3,r3,128
81100694:	18ffe004 	addi	r3,r3,-128
81100698:	e13ffdc3 	ldbu	r4,-9(fp)
8110069c:	e0bffe44 	addi	r2,fp,-7
811006a0:	d8800015 	stw	r2,0(sp)
811006a4:	200f883a 	mov	r7,r4
811006a8:	180d883a 	mov	r6,r3
811006ac:	e17ffb17 	ldw	r5,-20(fp)
811006b0:	e13ffa17 	ldw	r4,-24(fp)
811006b4:	110ac600 	call	8110ac60 <I2C_Read>
811006b8:	e0bff915 	stw	r2,-28(fp)
				ucTestAddr, &ucReadData);
		if (!bSuccess) {
811006bc:	e0bff917 	ldw	r2,-28(fp)
811006c0:	1000101e 	bne	r2,zero,81100704 <bDdr2EepromTest+0x3fc>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "Failed to read EEPROM for verify\n");
811006c4:	00e04574 	movhi	r3,33045
811006c8:	18cbe504 	addi	r3,r3,12180
811006cc:	00a04574 	movhi	r2,33045
811006d0:	10abf104 	addi	r2,r2,-20540
811006d4:	1009883a 	mov	r4,r2
811006d8:	00800884 	movi	r2,34
811006dc:	100d883a 	mov	r6,r2
811006e0:	200b883a 	mov	r5,r4
811006e4:	1809883a 	mov	r4,r3
811006e8:	11220540 	call	81122054 <memcpy>
			debug(fp, cDebugBuffer);
811006ec:	d0a06217 	ldw	r2,-32376(gp)
811006f0:	01604574 	movhi	r5,33045
811006f4:	294be504 	addi	r5,r5,12180
811006f8:	1009883a 	mov	r4,r2
811006fc:	1120fa40 	call	81120fa4 <fprintf>
81100700:	00001406 	br	81100754 <bDdr2EepromTest+0x44c>
#endif
		} else {
			if (ucReadData != ucWriteData) {
81100704:	e0bffe43 	ldbu	r2,-7(fp)
81100708:	10c03fcc 	andi	r3,r2,255
8110070c:	e0bffd83 	ldbu	r2,-10(fp)
81100710:	18801026 	beq	r3,r2,81100754 <bDdr2EepromTest+0x44c>
				bSuccess = FALSE;
81100714:	e03ff915 	stw	zero,-28(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100718:	e0bffe43 	ldbu	r2,-7(fp)
8110071c:	10803fcc 	andi	r2,r2,255
81100720:	e0fffd83 	ldbu	r3,-10(fp)
81100724:	180f883a 	mov	r7,r3
81100728:	100d883a 	mov	r6,r2
8110072c:	01604574 	movhi	r5,33045
81100730:	296bfa04 	addi	r5,r5,-20504
81100734:	01204574 	movhi	r4,33045
81100738:	210be504 	addi	r4,r4,12180
8110073c:	11229340 	call	81122934 <sprintf>
						"Verify EEPROM write fail, ReadData=%02Xh, WriteData=%02Xh\n",
						ucReadData, ucWriteData);
				debug(fp, cDebugBuffer);
81100740:	d0a06217 	ldw	r2,-32376(gp)
81100744:	01604574 	movhi	r5,33045
81100748:	294be504 	addi	r5,r5,12180
8110074c:	1009883a 	mov	r4,r2
81100750:	1120fa40 	call	81120fa4 <fprintf>
#endif
			}
		}
	}
	if (bSuccess) {
81100754:	e0bff917 	ldw	r2,-28(fp)
81100758:	10001026 	beq	r2,zero,8110079c <bDdr2EepromTest+0x494>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Write Test Completed\n\n");
8110075c:	00e04574 	movhi	r3,33045
81100760:	18cbe504 	addi	r3,r3,12180
81100764:	00a04574 	movhi	r2,33045
81100768:	10ac0904 	addi	r2,r2,-20444
8110076c:	1009883a 	mov	r4,r2
81100770:	008008c4 	movi	r2,35
81100774:	100d883a 	mov	r6,r2
81100778:	200b883a 	mov	r5,r4
8110077c:	1809883a 	mov	r4,r3
81100780:	11220540 	call	81122054 <memcpy>
		debug(fp, cDebugBuffer);
81100784:	d0a06217 	ldw	r2,-32376(gp)
81100788:	01604574 	movhi	r5,33045
8110078c:	294be504 	addi	r5,r5,12180
81100790:	1009883a 	mov	r4,r2
81100794:	1120fa40 	call	81120fa4 <fprintf>
81100798:	00000f06 	br	811007d8 <bDdr2EepromTest+0x4d0>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Write Test Failed\n\n");
8110079c:	00e04574 	movhi	r3,33045
811007a0:	18cbe504 	addi	r3,r3,12180
811007a4:	00a04574 	movhi	r2,33045
811007a8:	10ac1204 	addi	r2,r2,-20408
811007ac:	1009883a 	mov	r4,r2
811007b0:	00800804 	movi	r2,32
811007b4:	100d883a 	mov	r6,r2
811007b8:	200b883a 	mov	r5,r4
811007bc:	1809883a 	mov	r4,r3
811007c0:	11220540 	call	81122054 <memcpy>
		debug(fp, cDebugBuffer);
811007c4:	d0a06217 	ldw	r2,-32376(gp)
811007c8:	01604574 	movhi	r5,33045
811007cc:	294be504 	addi	r5,r5,12180
811007d0:	1009883a 	mov	r4,r2
811007d4:	1120fa40 	call	81120fa4 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811007d8:	00a04574 	movhi	r2,33045
811007dc:	108be504 	addi	r2,r2,12180
811007e0:	00c00284 	movi	r3,10
811007e4:	10c00005 	stb	r3,0(r2)
811007e8:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811007ec:	d0a06217 	ldw	r2,-32376(gp)
811007f0:	01604574 	movhi	r5,33045
811007f4:	294be504 	addi	r5,r5,12180
811007f8:	1009883a 	mov	r4,r2
811007fc:	1120fa40 	call	81120fa4 <fprintf>
#endif

	return bSuccess;
81100800:	e0bff917 	ldw	r2,-28(fp)
}
81100804:	e037883a 	mov	sp,fp
81100808:	dfc00117 	ldw	ra,4(sp)
8110080c:	df000017 	ldw	fp,0(sp)
81100810:	dec00204 	addi	sp,sp,8
81100814:	f800283a 	ret

81100818 <bDdr2EepromDump>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2EepromDump(alt_u8 ucMemoryId) {
81100818:	deffb704 	addi	sp,sp,-292
8110081c:	de00012e 	bgeu	sp,et,81100824 <bDdr2EepromDump+0xc>
81100820:	003b68fa 	trap	3
81100824:	dfc04815 	stw	ra,288(sp)
81100828:	df004715 	stw	fp,284(sp)
8110082c:	df004704 	addi	fp,sp,284
81100830:	2005883a 	mov	r2,r4
81100834:	e0bfff05 	stb	r2,-4(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 EEPROM Dump =====\n");
81100838:	00e04574 	movhi	r3,33045
8110083c:	18cbe504 	addi	r3,r3,12180
81100840:	00a04574 	movhi	r2,33045
81100844:	10ac1a04 	addi	r2,r2,-20376
81100848:	1009883a 	mov	r4,r2
8110084c:	00800884 	movi	r2,34
81100850:	100d883a 	mov	r6,r2
81100854:	200b883a 	mov	r5,r4
81100858:	1809883a 	mov	r4,r3
8110085c:	11220540 	call	81122054 <memcpy>
	debug(fp, cDebugBuffer);
81100860:	d0a06217 	ldw	r2,-32376(gp)
81100864:	01604574 	movhi	r5,33045
81100868:	294be504 	addi	r5,r5,12180
8110086c:	1009883a 	mov	r4,r2
81100870:	1120fa40 	call	81120fa4 <fprintf>
#endif
	const alt_u8 cucDeviceAddr = DDR2_EEPROM_I2C_ADDRESS;
81100874:	00bfe804 	movi	r2,-96
81100878:	e0bfbd05 	stb	r2,-268(fp)
	bool bSuccess;
	alt_u32 uliI2cSclBase;
	alt_u32 uliI2cSdaBase;
	int iI;

	bSuccess = TRUE;
8110087c:	00800044 	movi	r2,1
81100880:	e0bfbe15 	stw	r2,-264(fp)
	switch (ucMemoryId) {
81100884:	e0bfff03 	ldbu	r2,-4(fp)
81100888:	10000326 	beq	r2,zero,81100898 <bDdr2EepromDump+0x80>
8110088c:	10800060 	cmpeqi	r2,r2,1
81100890:	1000081e 	bne	r2,zero,811008b4 <bDdr2EepromDump+0x9c>
81100894:	00000e06 	br	811008d0 <bDdr2EepromDump+0xb8>
	case DDR2_M1_ID:
		uliI2cSclBase = DDR2_M1_EEPROM_I2C_SCL_BASE;
81100898:	00a00034 	movhi	r2,32768
8110089c:	10827c04 	addi	r2,r2,2544
811008a0:	e0bfba15 	stw	r2,-280(fp)
		uliI2cSdaBase = DDR2_M1_EEPROM_I2C_SDA_BASE;
811008a4:	00a00034 	movhi	r2,32768
811008a8:	10828004 	addi	r2,r2,2560
811008ac:	e0bfbb15 	stw	r2,-276(fp)
		break;
811008b0:	00001906 	br	81100918 <bDdr2EepromDump+0x100>
	case DDR2_M2_ID:
		uliI2cSclBase = DDR2_M2_EEPROM_I2C_SCL_BASE;
811008b4:	00a00034 	movhi	r2,32768
811008b8:	10825804 	addi	r2,r2,2400
811008bc:	e0bfba15 	stw	r2,-280(fp)
		uliI2cSdaBase = DDR2_M2_EEPROM_I2C_SDA_BASE;
811008c0:	00a00034 	movhi	r2,32768
811008c4:	10825c04 	addi	r2,r2,2416
811008c8:	e0bfbb15 	stw	r2,-276(fp)
		break;
811008cc:	00001206 	br	81100918 <bDdr2EepromDump+0x100>
	default:
		bSuccess = FALSE;
811008d0:	e03fbe15 	stw	zero,-264(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811008d4:	00e04574 	movhi	r3,33045
811008d8:	18cbe504 	addi	r3,r3,12180
811008dc:	00a04574 	movhi	r2,33045
811008e0:	10ac2304 	addi	r2,r2,-20340
811008e4:	1009883a 	mov	r4,r2
811008e8:	00800bc4 	movi	r2,47
811008ec:	100d883a 	mov	r6,r2
811008f0:	200b883a 	mov	r5,r4
811008f4:	1809883a 	mov	r4,r3
811008f8:	11220540 	call	81122054 <memcpy>
				"DR2 Memory ID not identified!! Aborting Dump \n");
		debug(fp, cDebugBuffer)
811008fc:	d0a06217 	ldw	r2,-32376(gp)
81100900:	01604574 	movhi	r5,33045
81100904:	294be504 	addi	r5,r5,12180
81100908:	1009883a 	mov	r4,r2
8110090c:	1120fa40 	call	81120fa4 <fprintf>
		;
#endif
		return bSuccess;
81100910:	e0bfbe17 	ldw	r2,-264(fp)
81100914:	0002e706 	br	811014b4 <bDdr2EepromDump+0xc9c>
	}

	alt_u8 ucSZData[256];
	bSuccess = I2C_MultipleRead(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100918:	e0bfbd03 	ldbu	r2,-268(fp)
8110091c:	10c03fcc 	andi	r3,r2,255
81100920:	18c0201c 	xori	r3,r3,128
81100924:	18ffe004 	addi	r3,r3,-128
81100928:	e13fbf04 	addi	r4,fp,-260
8110092c:	00804004 	movi	r2,256
81100930:	d8800015 	stw	r2,0(sp)
81100934:	200f883a 	mov	r7,r4
81100938:	180d883a 	mov	r6,r3
8110093c:	e17fbb17 	ldw	r5,-276(fp)
81100940:	e13fba17 	ldw	r4,-280(fp)
81100944:	110ad680 	call	8110ad68 <I2C_MultipleRead>
81100948:	e0bfbe15 	stw	r2,-264(fp)
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
8110094c:	e0bfbe17 	ldw	r2,-264(fp)
81100950:	1002be26 	beq	r2,zero,8110144c <bDdr2EepromDump+0xc34>
		for (iI = 0; iI < 256 && bSuccess; iI++) {
81100954:	e03fbc15 	stw	zero,-272(fp)
81100958:	0002b606 	br	81101434 <bDdr2EepromDump+0xc1c>
			if (iI == 0) {
8110095c:	e0bfbc17 	ldw	r2,-272(fp)
81100960:	1000121e 	bne	r2,zero,811009ac <bDdr2EepromDump+0x194>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"(Number of SPD Bytes Used)\n" "EEPROM[%03d]=%02Xh ",
						iI, ucSZData[iI]);
81100964:	e0ffbf04 	addi	r3,fp,-260
81100968:	e0bfbc17 	ldw	r2,-272(fp)
8110096c:	1885883a 	add	r2,r3,r2
81100970:	10800003 	ldbu	r2,0(r2)
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
		for (iI = 0; iI < 256 && bSuccess; iI++) {
			if (iI == 0) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100974:	10803fcc 	andi	r2,r2,255
81100978:	100f883a 	mov	r7,r2
8110097c:	e1bfbc17 	ldw	r6,-272(fp)
81100980:	01604574 	movhi	r5,33045
81100984:	296c2f04 	addi	r5,r5,-20292
81100988:	01204574 	movhi	r4,33045
8110098c:	210be504 	addi	r4,r4,12180
81100990:	11229340 	call	81122934 <sprintf>
						"(Number of SPD Bytes Used)\n" "EEPROM[%03d]=%02Xh ",
						iI, ucSZData[iI]);
				debug(fp, cDebugBuffer);
81100994:	d0a06217 	ldw	r2,-32376(gp)
81100998:	01604574 	movhi	r5,33045
8110099c:	294be504 	addi	r5,r5,12180
811009a0:	1009883a 	mov	r4,r2
811009a4:	1120fa40 	call	81120fa4 <fprintf>
811009a8:	00029f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 1) {
811009ac:	e0bfbc17 	ldw	r2,-272(fp)
811009b0:	10800058 	cmpnei	r2,r2,1
811009b4:	1000101e 	bne	r2,zero,811009f8 <bDdr2EepromDump+0x1e0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811009b8:	00e04574 	movhi	r3,33045
811009bc:	18cbe504 	addi	r3,r3,12180
811009c0:	00a04574 	movhi	r2,33045
811009c4:	10ac3b04 	addi	r2,r2,-20244
811009c8:	1009883a 	mov	r4,r2
811009cc:	00800c04 	movi	r2,48
811009d0:	100d883a 	mov	r6,r2
811009d4:	200b883a 	mov	r5,r4
811009d8:	1809883a 	mov	r4,r3
811009dc:	11220540 	call	81122054 <memcpy>
						"(Total Number of Bytes in SPD Device, Log2(N))\n");
				debug(fp, cDebugBuffer);
811009e0:	d0a06217 	ldw	r2,-32376(gp)
811009e4:	01604574 	movhi	r5,33045
811009e8:	294be504 	addi	r5,r5,12180
811009ec:	1009883a 	mov	r4,r2
811009f0:	1120fa40 	call	81120fa4 <fprintf>
811009f4:	00028c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 2) {
811009f8:	e0bfbc17 	ldw	r2,-272(fp)
811009fc:	10800098 	cmpnei	r2,r2,2
81100a00:	1000101e 	bne	r2,zero,81100a44 <bDdr2EepromDump+0x22c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Basic Memory Type[08h:DDR2])\n");
81100a04:	00e04574 	movhi	r3,33045
81100a08:	18cbe504 	addi	r3,r3,12180
81100a0c:	00a04574 	movhi	r2,33045
81100a10:	10ac4704 	addi	r2,r2,-20196
81100a14:	1009883a 	mov	r4,r2
81100a18:	008007c4 	movi	r2,31
81100a1c:	100d883a 	mov	r6,r2
81100a20:	200b883a 	mov	r5,r4
81100a24:	1809883a 	mov	r4,r3
81100a28:	11220540 	call	81122054 <memcpy>
				debug(fp, cDebugBuffer);
81100a2c:	d0a06217 	ldw	r2,-32376(gp)
81100a30:	01604574 	movhi	r5,33045
81100a34:	294be504 	addi	r5,r5,12180
81100a38:	1009883a 	mov	r4,r2
81100a3c:	1120fa40 	call	81120fa4 <fprintf>
81100a40:	00027906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 3) {
81100a44:	e0bfbc17 	ldw	r2,-272(fp)
81100a48:	108000d8 	cmpnei	r2,r2,3
81100a4c:	1000101e 	bne	r2,zero,81100a90 <bDdr2EepromDump+0x278>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100a50:	00e04574 	movhi	r3,33045
81100a54:	18cbe504 	addi	r3,r3,12180
81100a58:	00a04574 	movhi	r2,33045
81100a5c:	10ac4f04 	addi	r2,r2,-20164
81100a60:	1009883a 	mov	r4,r2
81100a64:	008009c4 	movi	r2,39
81100a68:	100d883a 	mov	r6,r2
81100a6c:	200b883a 	mov	r5,r4
81100a70:	1809883a 	mov	r4,r3
81100a74:	11220540 	call	81122054 <memcpy>
						"(Number of Row Addresses on Assembly)\n");
				debug(fp, cDebugBuffer);
81100a78:	d0a06217 	ldw	r2,-32376(gp)
81100a7c:	01604574 	movhi	r5,33045
81100a80:	294be504 	addi	r5,r5,12180
81100a84:	1009883a 	mov	r4,r2
81100a88:	1120fa40 	call	81120fa4 <fprintf>
81100a8c:	00026606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 4) {
81100a90:	e0bfbc17 	ldw	r2,-272(fp)
81100a94:	10800118 	cmpnei	r2,r2,4
81100a98:	1000101e 	bne	r2,zero,81100adc <bDdr2EepromDump+0x2c4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100a9c:	00e04574 	movhi	r3,33045
81100aa0:	18cbe504 	addi	r3,r3,12180
81100aa4:	00a04574 	movhi	r2,33045
81100aa8:	10ac5904 	addi	r2,r2,-20124
81100aac:	1009883a 	mov	r4,r2
81100ab0:	00800a84 	movi	r2,42
81100ab4:	100d883a 	mov	r6,r2
81100ab8:	200b883a 	mov	r5,r4
81100abc:	1809883a 	mov	r4,r3
81100ac0:	11220540 	call	81122054 <memcpy>
						"(Number of Column Addresses on Assembly)\n");
				debug(fp, cDebugBuffer);
81100ac4:	d0a06217 	ldw	r2,-32376(gp)
81100ac8:	01604574 	movhi	r5,33045
81100acc:	294be504 	addi	r5,r5,12180
81100ad0:	1009883a 	mov	r4,r2
81100ad4:	1120fa40 	call	81120fa4 <fprintf>
81100ad8:	00025306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 5) {
81100adc:	e0bfbc17 	ldw	r2,-272(fp)
81100ae0:	10800158 	cmpnei	r2,r2,5
81100ae4:	1000101e 	bne	r2,zero,81100b28 <bDdr2EepromDump+0x310>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100ae8:	00e04574 	movhi	r3,33045
81100aec:	18cbe504 	addi	r3,r3,12180
81100af0:	00a04574 	movhi	r2,33045
81100af4:	10ac6404 	addi	r2,r2,-20080
81100af8:	1009883a 	mov	r4,r2
81100afc:	00800c04 	movi	r2,48
81100b00:	100d883a 	mov	r6,r2
81100b04:	200b883a 	mov	r5,r4
81100b08:	1809883a 	mov	r4,r3
81100b0c:	11220540 	call	81122054 <memcpy>
						"(DIMM Height and Module Rank Number[b2b1b0+1])\n");
				debug(fp, cDebugBuffer);
81100b10:	d0a06217 	ldw	r2,-32376(gp)
81100b14:	01604574 	movhi	r5,33045
81100b18:	294be504 	addi	r5,r5,12180
81100b1c:	1009883a 	mov	r4,r2
81100b20:	1120fa40 	call	81120fa4 <fprintf>
81100b24:	00024006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 6) {
81100b28:	e0bfbc17 	ldw	r2,-272(fp)
81100b2c:	10800198 	cmpnei	r2,r2,6
81100b30:	1000101e 	bne	r2,zero,81100b74 <bDdr2EepromDump+0x35c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Module Data Width)\n");
81100b34:	00e04574 	movhi	r3,33045
81100b38:	18cbe504 	addi	r3,r3,12180
81100b3c:	00a04574 	movhi	r2,33045
81100b40:	10ac7004 	addi	r2,r2,-20032
81100b44:	1009883a 	mov	r4,r2
81100b48:	00800544 	movi	r2,21
81100b4c:	100d883a 	mov	r6,r2
81100b50:	200b883a 	mov	r5,r4
81100b54:	1809883a 	mov	r4,r3
81100b58:	11220540 	call	81122054 <memcpy>
				debug(fp, cDebugBuffer);
81100b5c:	d0a06217 	ldw	r2,-32376(gp)
81100b60:	01604574 	movhi	r5,33045
81100b64:	294be504 	addi	r5,r5,12180
81100b68:	1009883a 	mov	r4,r2
81100b6c:	1120fa40 	call	81120fa4 <fprintf>
81100b70:	00022d06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 7) {
81100b74:	e0bfbc17 	ldw	r2,-272(fp)
81100b78:	108001d8 	cmpnei	r2,r2,7
81100b7c:	1000101e 	bne	r2,zero,81100bc0 <bDdr2EepromDump+0x3a8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Module Data Width, Continued)\n");
81100b80:	00e04574 	movhi	r3,33045
81100b84:	18cbe504 	addi	r3,r3,12180
81100b88:	00a04574 	movhi	r2,33045
81100b8c:	10ac7604 	addi	r2,r2,-20008
81100b90:	1009883a 	mov	r4,r2
81100b94:	00800804 	movi	r2,32
81100b98:	100d883a 	mov	r6,r2
81100b9c:	200b883a 	mov	r5,r4
81100ba0:	1809883a 	mov	r4,r3
81100ba4:	11220540 	call	81122054 <memcpy>
				debug(fp, cDebugBuffer);
81100ba8:	d0a06217 	ldw	r2,-32376(gp)
81100bac:	01604574 	movhi	r5,33045
81100bb0:	294be504 	addi	r5,r5,12180
81100bb4:	1009883a 	mov	r4,r2
81100bb8:	1120fa40 	call	81120fa4 <fprintf>
81100bbc:	00021a06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 16) {
81100bc0:	e0bfbc17 	ldw	r2,-272(fp)
81100bc4:	10800418 	cmpnei	r2,r2,16
81100bc8:	1000101e 	bne	r2,zero,81100c0c <bDdr2EepromDump+0x3f4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100bcc:	00e04574 	movhi	r3,33045
81100bd0:	18cbe504 	addi	r3,r3,12180
81100bd4:	00a04574 	movhi	r2,33045
81100bd8:	10ac7e04 	addi	r2,r2,-19976
81100bdc:	1009883a 	mov	r4,r2
81100be0:	00800d04 	movi	r2,52
81100be4:	100d883a 	mov	r6,r2
81100be8:	200b883a 	mov	r5,r4
81100bec:	1809883a 	mov	r4,r3
81100bf0:	11220540 	call	81122054 <memcpy>
						"(Burst Lengths Supported[bitmap: x x x x 8 4 x x])\n");
				debug(fp, cDebugBuffer);
81100bf4:	d0a06217 	ldw	r2,-32376(gp)
81100bf8:	01604574 	movhi	r5,33045
81100bfc:	294be504 	addi	r5,r5,12180
81100c00:	1009883a 	mov	r4,r2
81100c04:	1120fa40 	call	81120fa4 <fprintf>
81100c08:	00020706 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 13) {
81100c0c:	e0bfbc17 	ldw	r2,-272(fp)
81100c10:	10800358 	cmpnei	r2,r2,13
81100c14:	1000101e 	bne	r2,zero,81100c58 <bDdr2EepromDump+0x440>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Primary SDRAM width)\n");
81100c18:	00e04574 	movhi	r3,33045
81100c1c:	18cbe504 	addi	r3,r3,12180
81100c20:	00a04574 	movhi	r2,33045
81100c24:	10ac8b04 	addi	r2,r2,-19924
81100c28:	1009883a 	mov	r4,r2
81100c2c:	008005c4 	movi	r2,23
81100c30:	100d883a 	mov	r6,r2
81100c34:	200b883a 	mov	r5,r4
81100c38:	1809883a 	mov	r4,r3
81100c3c:	11220540 	call	81122054 <memcpy>
				debug(fp, cDebugBuffer);
81100c40:	d0a06217 	ldw	r2,-32376(gp)
81100c44:	01604574 	movhi	r5,33045
81100c48:	294be504 	addi	r5,r5,12180
81100c4c:	1009883a 	mov	r4,r2
81100c50:	1120fa40 	call	81120fa4 <fprintf>
81100c54:	0001f406 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 14) {
81100c58:	e0bfbc17 	ldw	r2,-272(fp)
81100c5c:	10800398 	cmpnei	r2,r2,14
81100c60:	1000101e 	bne	r2,zero,81100ca4 <bDdr2EepromDump+0x48c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(ECC SDRAM width)\n");
81100c64:	00e04574 	movhi	r3,33045
81100c68:	18cbe504 	addi	r3,r3,12180
81100c6c:	00a04574 	movhi	r2,33045
81100c70:	10ac9104 	addi	r2,r2,-19900
81100c74:	1009883a 	mov	r4,r2
81100c78:	008004c4 	movi	r2,19
81100c7c:	100d883a 	mov	r6,r2
81100c80:	200b883a 	mov	r5,r4
81100c84:	1809883a 	mov	r4,r3
81100c88:	11220540 	call	81122054 <memcpy>
				debug(fp, cDebugBuffer);
81100c8c:	d0a06217 	ldw	r2,-32376(gp)
81100c90:	01604574 	movhi	r5,33045
81100c94:	294be504 	addi	r5,r5,12180
81100c98:	1009883a 	mov	r4,r2
81100c9c:	1120fa40 	call	81120fa4 <fprintf>
81100ca0:	0001e106 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 17) {
81100ca4:	e0bfbc17 	ldw	r2,-272(fp)
81100ca8:	10800458 	cmpnei	r2,r2,17
81100cac:	1000101e 	bne	r2,zero,81100cf0 <bDdr2EepromDump+0x4d8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Banks per SDRAM device)\n");
81100cb0:	00e04574 	movhi	r3,33045
81100cb4:	18cbe504 	addi	r3,r3,12180
81100cb8:	00a04574 	movhi	r2,33045
81100cbc:	10ac9604 	addi	r2,r2,-19880
81100cc0:	1009883a 	mov	r4,r2
81100cc4:	00800684 	movi	r2,26
81100cc8:	100d883a 	mov	r6,r2
81100ccc:	200b883a 	mov	r5,r4
81100cd0:	1809883a 	mov	r4,r3
81100cd4:	11220540 	call	81122054 <memcpy>
				debug(fp, cDebugBuffer);
81100cd8:	d0a06217 	ldw	r2,-32376(gp)
81100cdc:	01604574 	movhi	r5,33045
81100ce0:	294be504 	addi	r5,r5,12180
81100ce4:	1009883a 	mov	r4,r2
81100ce8:	1120fa40 	call	81120fa4 <fprintf>
81100cec:	0001ce06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 18) {
81100cf0:	e0bfbc17 	ldw	r2,-272(fp)
81100cf4:	10800498 	cmpnei	r2,r2,18
81100cf8:	1000101e 	bne	r2,zero,81100d3c <bDdr2EepromDump+0x524>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100cfc:	00e04574 	movhi	r3,33045
81100d00:	18cbe504 	addi	r3,r3,12180
81100d04:	00a04574 	movhi	r2,33045
81100d08:	10ac9d04 	addi	r2,r2,-19852
81100d0c:	1009883a 	mov	r4,r2
81100d10:	00800d44 	movi	r2,53
81100d14:	100d883a 	mov	r6,r2
81100d18:	200b883a 	mov	r5,r4
81100d1c:	1809883a 	mov	r4,r3
81100d20:	11220540 	call	81122054 <memcpy>
						"(CAS lantencies supported[bitmap: x x 5 4 3 2 x x])\n");
				debug(fp, cDebugBuffer);
81100d24:	d0a06217 	ldw	r2,-32376(gp)
81100d28:	01604574 	movhi	r5,33045
81100d2c:	294be504 	addi	r5,r5,12180
81100d30:	1009883a 	mov	r4,r2
81100d34:	1120fa40 	call	81120fa4 <fprintf>
81100d38:	0001bb06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 20) {
81100d3c:	e0bfbc17 	ldw	r2,-272(fp)
81100d40:	10800518 	cmpnei	r2,r2,20
81100d44:	1000101e 	bne	r2,zero,81100d88 <bDdr2EepromDump+0x570>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100d48:	00e04574 	movhi	r3,33045
81100d4c:	18cbe504 	addi	r3,r3,12180
81100d50:	00a04574 	movhi	r2,33045
81100d54:	10acab04 	addi	r2,r2,-19796
81100d58:	1009883a 	mov	r4,r2
81100d5c:	00801204 	movi	r2,72
81100d60:	100d883a 	mov	r6,r2
81100d64:	200b883a 	mov	r5,r4
81100d68:	1809883a 	mov	r4,r3
81100d6c:	11220540 	call	81122054 <memcpy>
						"(DIMM Type: x x Mini-UDIMM Mini-RDIMM Micro-DIMM SO-DIMM UDIMMM RDIMM)\n");
				debug(fp, cDebugBuffer);
81100d70:	d0a06217 	ldw	r2,-32376(gp)
81100d74:	01604574 	movhi	r5,33045
81100d78:	294be504 	addi	r5,r5,12180
81100d7c:	1009883a 	mov	r4,r2
81100d80:	1120fa40 	call	81120fa4 <fprintf>
81100d84:	0001a806 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 22) {
81100d88:	e0bfbc17 	ldw	r2,-272(fp)
81100d8c:	10800598 	cmpnei	r2,r2,22
81100d90:	1000101e 	bne	r2,zero,81100dd4 <bDdr2EepromDump+0x5bc>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Memory Chip feature bitmap)\n");
81100d94:	00e04574 	movhi	r3,33045
81100d98:	18cbe504 	addi	r3,r3,12180
81100d9c:	00a04574 	movhi	r2,33045
81100da0:	10acbd04 	addi	r2,r2,-19724
81100da4:	1009883a 	mov	r4,r2
81100da8:	00800784 	movi	r2,30
81100dac:	100d883a 	mov	r6,r2
81100db0:	200b883a 	mov	r5,r4
81100db4:	1809883a 	mov	r4,r3
81100db8:	11220540 	call	81122054 <memcpy>
				debug(fp, cDebugBuffer);
81100dbc:	d0a06217 	ldw	r2,-32376(gp)
81100dc0:	01604574 	movhi	r5,33045
81100dc4:	294be504 	addi	r5,r5,12180
81100dc8:	1009883a 	mov	r4,r2
81100dcc:	1120fa40 	call	81120fa4 <fprintf>
81100dd0:	00019506 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 27) {
81100dd4:	e0bfbc17 	ldw	r2,-272(fp)
81100dd8:	108006d8 	cmpnei	r2,r2,27
81100ddc:	1000101e 	bne	r2,zero,81100e20 <bDdr2EepromDump+0x608>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100de0:	00e04574 	movhi	r3,33045
81100de4:	18cbe504 	addi	r3,r3,12180
81100de8:	00a04574 	movhi	r2,33045
81100dec:	10acc504 	addi	r2,r2,-19692
81100df0:	1009883a 	mov	r4,r2
81100df4:	00800a04 	movi	r2,40
81100df8:	100d883a 	mov	r6,r2
81100dfc:	200b883a 	mov	r5,r4
81100e00:	1809883a 	mov	r4,r3
81100e04:	11220540 	call	81122054 <memcpy>
						"(Minimun row precharge time[tRP;nsx4])\n");
				debug(fp, cDebugBuffer);
81100e08:	d0a06217 	ldw	r2,-32376(gp)
81100e0c:	01604574 	movhi	r5,33045
81100e10:	294be504 	addi	r5,r5,12180
81100e14:	1009883a 	mov	r4,r2
81100e18:	1120fa40 	call	81120fa4 <fprintf>
81100e1c:	00018206 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 28) {
81100e20:	e0bfbc17 	ldw	r2,-272(fp)
81100e24:	10800718 	cmpnei	r2,r2,28
81100e28:	1000101e 	bne	r2,zero,81100e6c <bDdr2EepromDump+0x654>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100e2c:	00e04574 	movhi	r3,33045
81100e30:	18cbe504 	addi	r3,r3,12180
81100e34:	00a04574 	movhi	r2,33045
81100e38:	10accf04 	addi	r2,r2,-19652
81100e3c:	1009883a 	mov	r4,r2
81100e40:	00800cc4 	movi	r2,51
81100e44:	100d883a 	mov	r6,r2
81100e48:	200b883a 	mov	r5,r4
81100e4c:	1809883a 	mov	r4,r3
81100e50:	11220540 	call	81122054 <memcpy>
						"(Minimun row active-row activce delay[tRRD;nsx4])\n");
				debug(fp, cDebugBuffer);
81100e54:	d0a06217 	ldw	r2,-32376(gp)
81100e58:	01604574 	movhi	r5,33045
81100e5c:	294be504 	addi	r5,r5,12180
81100e60:	1009883a 	mov	r4,r2
81100e64:	1120fa40 	call	81120fa4 <fprintf>
81100e68:	00016f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 29) {
81100e6c:	e0bfbc17 	ldw	r2,-272(fp)
81100e70:	10800758 	cmpnei	r2,r2,29
81100e74:	1000101e 	bne	r2,zero,81100eb8 <bDdr2EepromDump+0x6a0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100e78:	00e04574 	movhi	r3,33045
81100e7c:	18cbe504 	addi	r3,r3,12180
81100e80:	00a04574 	movhi	r2,33045
81100e84:	10acdc04 	addi	r2,r2,-19600
81100e88:	1009883a 	mov	r4,r2
81100e8c:	008009c4 	movi	r2,39
81100e90:	100d883a 	mov	r6,r2
81100e94:	200b883a 	mov	r5,r4
81100e98:	1809883a 	mov	r4,r3
81100e9c:	11220540 	call	81122054 <memcpy>
						"(Minimun RAS to CAS delay[tRCD;nsx4])\n");
				debug(fp, cDebugBuffer);
81100ea0:	d0a06217 	ldw	r2,-32376(gp)
81100ea4:	01604574 	movhi	r5,33045
81100ea8:	294be504 	addi	r5,r5,12180
81100eac:	1009883a 	mov	r4,r2
81100eb0:	1120fa40 	call	81120fa4 <fprintf>
81100eb4:	00015c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 30) {
81100eb8:	e0bfbc17 	ldw	r2,-272(fp)
81100ebc:	10800798 	cmpnei	r2,r2,30
81100ec0:	1000101e 	bne	r2,zero,81100f04 <bDdr2EepromDump+0x6ec>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100ec4:	00e04574 	movhi	r3,33045
81100ec8:	18cbe504 	addi	r3,r3,12180
81100ecc:	00a04574 	movhi	r2,33045
81100ed0:	10ace604 	addi	r2,r2,-19560
81100ed4:	1009883a 	mov	r4,r2
81100ed8:	00800b04 	movi	r2,44
81100edc:	100d883a 	mov	r6,r2
81100ee0:	200b883a 	mov	r5,r4
81100ee4:	1809883a 	mov	r4,r3
81100ee8:	11220540 	call	81122054 <memcpy>
						"(Minimun acive to precharge time[tRAS;ns])\n");
				debug(fp, cDebugBuffer);
81100eec:	d0a06217 	ldw	r2,-32376(gp)
81100ef0:	01604574 	movhi	r5,33045
81100ef4:	294be504 	addi	r5,r5,12180
81100ef8:	1009883a 	mov	r4,r2
81100efc:	1120fa40 	call	81120fa4 <fprintf>
81100f00:	00014906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 31) {
81100f04:	e0bfbc17 	ldw	r2,-272(fp)
81100f08:	108007d8 	cmpnei	r2,r2,31
81100f0c:	1000101e 	bne	r2,zero,81100f50 <bDdr2EepromDump+0x738>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100f10:	00e04574 	movhi	r3,33045
81100f14:	18cbe504 	addi	r3,r3,12180
81100f18:	00a04574 	movhi	r2,33045
81100f1c:	10acf104 	addi	r2,r2,-19516
81100f20:	1009883a 	mov	r4,r2
81100f24:	008010c4 	movi	r2,67
81100f28:	100d883a 	mov	r6,r2
81100f2c:	200b883a 	mov	r5,r4
81100f30:	1809883a 	mov	r4,r3
81100f34:	11220540 	call	81122054 <memcpy>
						"(Size of each rank[bitmap:512MB,256MB,128MB,16GB,8GB,4GB,2GB,1GB)\n");
				debug(fp, cDebugBuffer);
81100f38:	d0a06217 	ldw	r2,-32376(gp)
81100f3c:	01604574 	movhi	r5,33045
81100f40:	294be504 	addi	r5,r5,12180
81100f44:	1009883a 	mov	r4,r2
81100f48:	1120fa40 	call	81120fa4 <fprintf>
81100f4c:	00013606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 36) {
81100f50:	e0bfbc17 	ldw	r2,-272(fp)
81100f54:	10800918 	cmpnei	r2,r2,36
81100f58:	1000101e 	bne	r2,zero,81100f9c <bDdr2EepromDump+0x784>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100f5c:	00e04574 	movhi	r3,33045
81100f60:	18cbe504 	addi	r3,r3,12180
81100f64:	00a04574 	movhi	r2,33045
81100f68:	10ad0204 	addi	r2,r2,-19448
81100f6c:	1009883a 	mov	r4,r2
81100f70:	00800a84 	movi	r2,42
81100f74:	100d883a 	mov	r6,r2
81100f78:	200b883a 	mov	r5,r4
81100f7c:	1809883a 	mov	r4,r3
81100f80:	11220540 	call	81122054 <memcpy>
						"(Minimun write receovery time[tWR;nsx4])\n");
				debug(fp, cDebugBuffer);
81100f84:	d0a06217 	ldw	r2,-32376(gp)
81100f88:	01604574 	movhi	r5,33045
81100f8c:	294be504 	addi	r5,r5,12180
81100f90:	1009883a 	mov	r4,r2
81100f94:	1120fa40 	call	81120fa4 <fprintf>
81100f98:	00012306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 37) {
81100f9c:	e0bfbc17 	ldw	r2,-272(fp)
81100fa0:	10800958 	cmpnei	r2,r2,37
81100fa4:	1000101e 	bne	r2,zero,81100fe8 <bDdr2EepromDump+0x7d0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100fa8:	00e04574 	movhi	r3,33045
81100fac:	18cbe504 	addi	r3,r3,12180
81100fb0:	00a04574 	movhi	r2,33045
81100fb4:	10ad0d04 	addi	r2,r2,-19404
81100fb8:	1009883a 	mov	r4,r2
81100fbc:	00800cc4 	movi	r2,51
81100fc0:	100d883a 	mov	r6,r2
81100fc4:	200b883a 	mov	r5,r4
81100fc8:	1809883a 	mov	r4,r3
81100fcc:	11220540 	call	81122054 <memcpy>
						"(Internal write to read command delay[tWTR;nsx4])\n");
				debug(fp, cDebugBuffer);
81100fd0:	d0a06217 	ldw	r2,-32376(gp)
81100fd4:	01604574 	movhi	r5,33045
81100fd8:	294be504 	addi	r5,r5,12180
81100fdc:	1009883a 	mov	r4,r2
81100fe0:	1120fa40 	call	81120fa4 <fprintf>
81100fe4:	00011006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 38) {
81100fe8:	e0bfbc17 	ldw	r2,-272(fp)
81100fec:	10800998 	cmpnei	r2,r2,38
81100ff0:	1000101e 	bne	r2,zero,81101034 <bDdr2EepromDump+0x81c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100ff4:	00e04574 	movhi	r3,33045
81100ff8:	18cbe504 	addi	r3,r3,12180
81100ffc:	00a04574 	movhi	r2,33045
81101000:	10ad1a04 	addi	r2,r2,-19352
81101004:	1009883a 	mov	r4,r2
81101008:	00800dc4 	movi	r2,55
8110100c:	100d883a 	mov	r6,r2
81101010:	200b883a 	mov	r5,r4
81101014:	1809883a 	mov	r4,r3
81101018:	11220540 	call	81122054 <memcpy>
						"(Internal read to precharge command delay[tRTP;nsx4])\n");
				debug(fp, cDebugBuffer);
8110101c:	d0a06217 	ldw	r2,-32376(gp)
81101020:	01604574 	movhi	r5,33045
81101024:	294be504 	addi	r5,r5,12180
81101028:	1009883a 	mov	r4,r2
8110102c:	1120fa40 	call	81120fa4 <fprintf>
81101030:	0000fd06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 41) {
81101034:	e0bfbc17 	ldw	r2,-272(fp)
81101038:	10800a58 	cmpnei	r2,r2,41
8110103c:	1000101e 	bne	r2,zero,81101080 <bDdr2EepromDump+0x868>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101040:	00e04574 	movhi	r3,33045
81101044:	18cbe504 	addi	r3,r3,12180
81101048:	00a04574 	movhi	r2,33045
8110104c:	10ad2804 	addi	r2,r2,-19296
81101050:	1009883a 	mov	r4,r2
81101054:	00800c84 	movi	r2,50
81101058:	100d883a 	mov	r6,r2
8110105c:	200b883a 	mov	r5,r4
81101060:	1809883a 	mov	r4,r3
81101064:	11220540 	call	81122054 <memcpy>
						"(Minimun activce to active/refresh time[tRC;ns])\n");
				debug(fp, cDebugBuffer);
81101068:	d0a06217 	ldw	r2,-32376(gp)
8110106c:	01604574 	movhi	r5,33045
81101070:	294be504 	addi	r5,r5,12180
81101074:	1009883a 	mov	r4,r2
81101078:	1120fa40 	call	81120fa4 <fprintf>
8110107c:	0000ea06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 42) {
81101080:	e0bfbc17 	ldw	r2,-272(fp)
81101084:	10800a98 	cmpnei	r2,r2,42
81101088:	1000101e 	bne	r2,zero,811010cc <bDdr2EepromDump+0x8b4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
8110108c:	00e04574 	movhi	r3,33045
81101090:	18cbe504 	addi	r3,r3,12180
81101094:	00a04574 	movhi	r2,33045
81101098:	10ad3504 	addi	r2,r2,-19244
8110109c:	1009883a 	mov	r4,r2
811010a0:	00800cc4 	movi	r2,51
811010a4:	100d883a 	mov	r6,r2
811010a8:	200b883a 	mov	r5,r4
811010ac:	1809883a 	mov	r4,r3
811010b0:	11220540 	call	81122054 <memcpy>
						"(Minimun refresh to active/refresh time[tRFC;ns])\n");
				debug(fp, cDebugBuffer);
811010b4:	d0a06217 	ldw	r2,-32376(gp)
811010b8:	01604574 	movhi	r5,33045
811010bc:	294be504 	addi	r5,r5,12180
811010c0:	1009883a 	mov	r4,r2
811010c4:	1120fa40 	call	81120fa4 <fprintf>
811010c8:	0000d706 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 62) {
811010cc:	e0bfbc17 	ldw	r2,-272(fp)
811010d0:	10800f98 	cmpnei	r2,r2,62
811010d4:	1000101e 	bne	r2,zero,81101118 <bDdr2EepromDump+0x900>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(SPD Revision)\n");
811010d8:	00e04574 	movhi	r3,33045
811010dc:	18cbe504 	addi	r3,r3,12180
811010e0:	00a04574 	movhi	r2,33045
811010e4:	10ad4204 	addi	r2,r2,-19192
811010e8:	1009883a 	mov	r4,r2
811010ec:	00800404 	movi	r2,16
811010f0:	100d883a 	mov	r6,r2
811010f4:	200b883a 	mov	r5,r4
811010f8:	1809883a 	mov	r4,r3
811010fc:	11220540 	call	81122054 <memcpy>
				debug(fp, cDebugBuffer);
81101100:	d0a06217 	ldw	r2,-32376(gp)
81101104:	01604574 	movhi	r5,33045
81101108:	294be504 	addi	r5,r5,12180
8110110c:	1009883a 	mov	r4,r2
81101110:	1120fa40 	call	81120fa4 <fprintf>
81101114:	0000c406 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 63) {
81101118:	e0bfbc17 	ldw	r2,-272(fp)
8110111c:	10800fd8 	cmpnei	r2,r2,63
81101120:	10001f1e 	bne	r2,zero,811011a0 <bDdr2EepromDump+0x988>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Checksum)\n");
81101124:	00a04574 	movhi	r2,33045
81101128:	108be504 	addi	r2,r2,12180
8110112c:	00c00a04 	movi	r3,40
81101130:	10c00005 	stb	r3,0(r2)
81101134:	00c010c4 	movi	r3,67
81101138:	10c00045 	stb	r3,1(r2)
8110113c:	00c01a04 	movi	r3,104
81101140:	10c00085 	stb	r3,2(r2)
81101144:	00c01944 	movi	r3,101
81101148:	10c000c5 	stb	r3,3(r2)
8110114c:	00c018c4 	movi	r3,99
81101150:	10c00105 	stb	r3,4(r2)
81101154:	00c01ac4 	movi	r3,107
81101158:	10c00145 	stb	r3,5(r2)
8110115c:	00c01cc4 	movi	r3,115
81101160:	10c00185 	stb	r3,6(r2)
81101164:	00c01d44 	movi	r3,117
81101168:	10c001c5 	stb	r3,7(r2)
8110116c:	00c01b44 	movi	r3,109
81101170:	10c00205 	stb	r3,8(r2)
81101174:	00c00a44 	movi	r3,41
81101178:	10c00245 	stb	r3,9(r2)
8110117c:	00c00284 	movi	r3,10
81101180:	10c00285 	stb	r3,10(r2)
81101184:	100002c5 	stb	zero,11(r2)
				debug(fp, cDebugBuffer);
81101188:	d0a06217 	ldw	r2,-32376(gp)
8110118c:	01604574 	movhi	r5,33045
81101190:	294be504 	addi	r5,r5,12180
81101194:	1009883a 	mov	r4,r2
81101198:	1120fa40 	call	81120fa4 <fprintf>
8110119c:	0000a206 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 64) {
811011a0:	e0bfbc17 	ldw	r2,-272(fp)
811011a4:	10801018 	cmpnei	r2,r2,64
811011a8:	1000101e 	bne	r2,zero,811011ec <bDdr2EepromDump+0x9d4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(64~71: Manufacturer JEDEC ID)\n");
811011ac:	00e04574 	movhi	r3,33045
811011b0:	18cbe504 	addi	r3,r3,12180
811011b4:	00a04574 	movhi	r2,33045
811011b8:	10ad4604 	addi	r2,r2,-19176
811011bc:	1009883a 	mov	r4,r2
811011c0:	00800804 	movi	r2,32
811011c4:	100d883a 	mov	r6,r2
811011c8:	200b883a 	mov	r5,r4
811011cc:	1809883a 	mov	r4,r3
811011d0:	11220540 	call	81122054 <memcpy>
				debug(fp, cDebugBuffer);
811011d4:	d0a06217 	ldw	r2,-32376(gp)
811011d8:	01604574 	movhi	r5,33045
811011dc:	294be504 	addi	r5,r5,12180
811011e0:	1009883a 	mov	r4,r2
811011e4:	1120fa40 	call	81120fa4 <fprintf>
811011e8:	00008f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 72) {
811011ec:	e0bfbc17 	ldw	r2,-272(fp)
811011f0:	10801218 	cmpnei	r2,r2,72
811011f4:	1000101e 	bne	r2,zero,81101238 <bDdr2EepromDump+0xa20>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811011f8:	00e04574 	movhi	r3,33045
811011fc:	18cbe504 	addi	r3,r3,12180
81101200:	00a04574 	movhi	r2,33045
81101204:	10ad4e04 	addi	r2,r2,-19144
81101208:	1009883a 	mov	r4,r2
8110120c:	00800dc4 	movi	r2,55
81101210:	100d883a 	mov	r6,r2
81101214:	200b883a 	mov	r5,r4
81101218:	1809883a 	mov	r4,r3
8110121c:	11220540 	call	81122054 <memcpy>
						"(Module manufacturing location[Vendor-specific code])\n");
				debug(fp, cDebugBuffer);
81101220:	d0a06217 	ldw	r2,-32376(gp)
81101224:	01604574 	movhi	r5,33045
81101228:	294be504 	addi	r5,r5,12180
8110122c:	1009883a 	mov	r4,r2
81101230:	1120fa40 	call	81120fa4 <fprintf>
81101234:	00007c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 73) {
81101238:	e0bfbc17 	ldw	r2,-272(fp)
8110123c:	10801258 	cmpnei	r2,r2,73
81101240:	1000101e 	bne	r2,zero,81101284 <bDdr2EepromDump+0xa6c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(73~90: Moduloe part number)\n");
81101244:	00e04574 	movhi	r3,33045
81101248:	18cbe504 	addi	r3,r3,12180
8110124c:	00a04574 	movhi	r2,33045
81101250:	10ad5c04 	addi	r2,r2,-19088
81101254:	1009883a 	mov	r4,r2
81101258:	00800784 	movi	r2,30
8110125c:	100d883a 	mov	r6,r2
81101260:	200b883a 	mov	r5,r4
81101264:	1809883a 	mov	r4,r3
81101268:	11220540 	call	81122054 <memcpy>
				debug(fp, cDebugBuffer);
8110126c:	d0a06217 	ldw	r2,-32376(gp)
81101270:	01604574 	movhi	r5,33045
81101274:	294be504 	addi	r5,r5,12180
81101278:	1009883a 	mov	r4,r2
8110127c:	1120fa40 	call	81120fa4 <fprintf>
81101280:	00006906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 91) {
81101284:	e0bfbc17 	ldw	r2,-272(fp)
81101288:	108016d8 	cmpnei	r2,r2,91
8110128c:	1000101e 	bne	r2,zero,811012d0 <bDdr2EepromDump+0xab8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(91~92: Moduloe revision code)\n");
81101290:	00e04574 	movhi	r3,33045
81101294:	18cbe504 	addi	r3,r3,12180
81101298:	00a04574 	movhi	r2,33045
8110129c:	10ad6404 	addi	r2,r2,-19056
811012a0:	1009883a 	mov	r4,r2
811012a4:	00800804 	movi	r2,32
811012a8:	100d883a 	mov	r6,r2
811012ac:	200b883a 	mov	r5,r4
811012b0:	1809883a 	mov	r4,r3
811012b4:	11220540 	call	81122054 <memcpy>
				debug(fp, cDebugBuffer);
811012b8:	d0a06217 	ldw	r2,-32376(gp)
811012bc:	01604574 	movhi	r5,33045
811012c0:	294be504 	addi	r5,r5,12180
811012c4:	1009883a 	mov	r4,r2
811012c8:	1120fa40 	call	81120fa4 <fprintf>
811012cc:	00005606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 93) {
811012d0:	e0bfbc17 	ldw	r2,-272(fp)
811012d4:	10801758 	cmpnei	r2,r2,93
811012d8:	1000101e 	bne	r2,zero,8110131c <bDdr2EepromDump+0xb04>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811012dc:	00e04574 	movhi	r3,33045
811012e0:	18cbe504 	addi	r3,r3,12180
811012e4:	00a04574 	movhi	r2,33045
811012e8:	10ad6c04 	addi	r2,r2,-19024
811012ec:	1009883a 	mov	r4,r2
811012f0:	008009c4 	movi	r2,39
811012f4:	100d883a 	mov	r6,r2
811012f8:	200b883a 	mov	r5,r4
811012fc:	1809883a 	mov	r4,r3
81101300:	11220540 	call	81122054 <memcpy>
						"(Manufacture Years since 2000[0-255])\n");
				debug(fp, cDebugBuffer);
81101304:	d0a06217 	ldw	r2,-32376(gp)
81101308:	01604574 	movhi	r5,33045
8110130c:	294be504 	addi	r5,r5,12180
81101310:	1009883a 	mov	r4,r2
81101314:	1120fa40 	call	81120fa4 <fprintf>
81101318:	00004306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 94) {
8110131c:	e0bfbc17 	ldw	r2,-272(fp)
81101320:	10801798 	cmpnei	r2,r2,94
81101324:	1000101e 	bne	r2,zero,81101368 <bDdr2EepromDump+0xb50>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Manufacture Weeks[1-52])\n");
81101328:	00e04574 	movhi	r3,33045
8110132c:	18cbe504 	addi	r3,r3,12180
81101330:	00a04574 	movhi	r2,33045
81101334:	10ad7604 	addi	r2,r2,-18984
81101338:	1009883a 	mov	r4,r2
8110133c:	008006c4 	movi	r2,27
81101340:	100d883a 	mov	r6,r2
81101344:	200b883a 	mov	r5,r4
81101348:	1809883a 	mov	r4,r3
8110134c:	11220540 	call	81122054 <memcpy>
				debug(fp, cDebugBuffer);
81101350:	d0a06217 	ldw	r2,-32376(gp)
81101354:	01604574 	movhi	r5,33045
81101358:	294be504 	addi	r5,r5,12180
8110135c:	1009883a 	mov	r4,r2
81101360:	1120fa40 	call	81120fa4 <fprintf>
81101364:	00003006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 95) {
81101368:	e0bfbc17 	ldw	r2,-272(fp)
8110136c:	108017d8 	cmpnei	r2,r2,95
81101370:	1000101e 	bne	r2,zero,811013b4 <bDdr2EepromDump+0xb9c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101374:	00e04574 	movhi	r3,33045
81101378:	18cbe504 	addi	r3,r3,12180
8110137c:	00a04574 	movhi	r2,33045
81101380:	10ad7d04 	addi	r2,r2,-18956
81101384:	1009883a 	mov	r4,r2
81101388:	00800a04 	movi	r2,40
8110138c:	100d883a 	mov	r6,r2
81101390:	200b883a 	mov	r5,r4
81101394:	1809883a 	mov	r4,r3
81101398:	11220540 	call	81122054 <memcpy>
						"(95~98[4-bytes]: Module serial number)\n");
				debug(fp, cDebugBuffer);
8110139c:	d0a06217 	ldw	r2,-32376(gp)
811013a0:	01604574 	movhi	r5,33045
811013a4:	294be504 	addi	r5,r5,12180
811013a8:	1009883a 	mov	r4,r2
811013ac:	1120fa40 	call	81120fa4 <fprintf>
811013b0:	00001d06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 99) {
811013b4:	e0bfbc17 	ldw	r2,-272(fp)
811013b8:	108018d8 	cmpnei	r2,r2,99
811013bc:	1000101e 	bne	r2,zero,81101400 <bDdr2EepromDump+0xbe8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(99~128: Manufacturer-specific data)\n");
811013c0:	00e04574 	movhi	r3,33045
811013c4:	18cbe504 	addi	r3,r3,12180
811013c8:	00a04574 	movhi	r2,33045
811013cc:	10ad8704 	addi	r2,r2,-18916
811013d0:	1009883a 	mov	r4,r2
811013d4:	00800984 	movi	r2,38
811013d8:	100d883a 	mov	r6,r2
811013dc:	200b883a 	mov	r5,r4
811013e0:	1809883a 	mov	r4,r3
811013e4:	11220540 	call	81122054 <memcpy>
				debug(fp, cDebugBuffer);
811013e8:	d0a06217 	ldw	r2,-32376(gp)
811013ec:	01604574 	movhi	r5,33045
811013f0:	294be504 	addi	r5,r5,12180
811013f4:	1009883a 	mov	r4,r2
811013f8:	1120fa40 	call	81120fa4 <fprintf>
811013fc:	00000a06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "\n");
81101400:	00a04574 	movhi	r2,33045
81101404:	108be504 	addi	r2,r2,12180
81101408:	00c00284 	movi	r3,10
8110140c:	10c00005 	stb	r3,0(r2)
81101410:	10000045 	stb	zero,1(r2)
				debug(fp, cDebugBuffer);
81101414:	d0a06217 	ldw	r2,-32376(gp)
81101418:	01604574 	movhi	r5,33045
8110141c:	294be504 	addi	r5,r5,12180
81101420:	1009883a 	mov	r4,r2
81101424:	1120fa40 	call	81120fa4 <fprintf>

	alt_u8 ucSZData[256];
	bSuccess = I2C_MultipleRead(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
		for (iI = 0; iI < 256 && bSuccess; iI++) {
81101428:	e0bfbc17 	ldw	r2,-272(fp)
8110142c:	10800044 	addi	r2,r2,1
81101430:	e0bfbc15 	stw	r2,-272(fp)
81101434:	e0bfbc17 	ldw	r2,-272(fp)
81101438:	10804008 	cmpgei	r2,r2,256
8110143c:	1000121e 	bne	r2,zero,81101488 <bDdr2EepromDump+0xc70>
81101440:	e0bfbe17 	ldw	r2,-264(fp)
81101444:	103d451e 	bne	r2,zero,8110095c <__reset+0xfb0e095c>
81101448:	00000f06 	br	81101488 <bDdr2EepromDump+0xc70>
#endif
			}
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Failed to dump EEPROM\n");
8110144c:	00e04574 	movhi	r3,33045
81101450:	18cbe504 	addi	r3,r3,12180
81101454:	00a04574 	movhi	r2,33045
81101458:	10ad9104 	addi	r2,r2,-18876
8110145c:	1009883a 	mov	r4,r2
81101460:	008005c4 	movi	r2,23
81101464:	100d883a 	mov	r6,r2
81101468:	200b883a 	mov	r5,r4
8110146c:	1809883a 	mov	r4,r3
81101470:	11220540 	call	81122054 <memcpy>
		debug(fp, cDebugBuffer);
81101474:	d0a06217 	ldw	r2,-32376(gp)
81101478:	01604574 	movhi	r5,33045
8110147c:	294be504 	addi	r5,r5,12180
81101480:	1009883a 	mov	r4,r2
81101484:	1120fa40 	call	81120fa4 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101488:	00a04574 	movhi	r2,33045
8110148c:	108be504 	addi	r2,r2,12180
81101490:	00c00284 	movi	r3,10
81101494:	10c00005 	stb	r3,0(r2)
81101498:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
8110149c:	d0a06217 	ldw	r2,-32376(gp)
811014a0:	01604574 	movhi	r5,33045
811014a4:	294be504 	addi	r5,r5,12180
811014a8:	1009883a 	mov	r4,r2
811014ac:	1120fa40 	call	81120fa4 <fprintf>
#endif

	return bSuccess;
811014b0:	e0bfbe17 	ldw	r2,-264(fp)
}
811014b4:	e037883a 	mov	sp,fp
811014b8:	dfc00117 	ldw	ra,4(sp)
811014bc:	df000017 	ldw	fp,0(sp)
811014c0:	dec00204 	addi	sp,sp,8
811014c4:	f800283a 	ret

811014c8 <bDdr2SwitchMemory>:

bool bDdr2SwitchMemory(alt_u8 ucMemoryId) {
811014c8:	defffb04 	addi	sp,sp,-20
811014cc:	de00012e 	bgeu	sp,et,811014d4 <bDdr2SwitchMemory+0xc>
811014d0:	003b68fa 	trap	3
811014d4:	dfc00415 	stw	ra,16(sp)
811014d8:	df000315 	stw	fp,12(sp)
811014dc:	df000304 	addi	fp,sp,12
811014e0:	2005883a 	mov	r2,r4
811014e4:	e0bfff05 	stb	r2,-4(fp)

	bool bSuccess;
	alt_u32 *puliDdr2MemAddr = (alt_u32 *) DDR2_EXT_ADDR_CONTROL_BASE;
811014e8:	00a04834 	movhi	r2,33056
811014ec:	108c2204 	addi	r2,r2,12424
811014f0:	e0bffe15 	stw	r2,-8(fp)

	bSuccess = TRUE;
811014f4:	00800044 	movi	r2,1
811014f8:	e0bffd15 	stw	r2,-12(fp)
	switch (ucMemoryId) {
811014fc:	e0bfff03 	ldbu	r2,-4(fp)
81101500:	10000326 	beq	r2,zero,81101510 <bDdr2SwitchMemory+0x48>
81101504:	10800060 	cmpeqi	r2,r2,1
81101508:	1000041e 	bne	r2,zero,8110151c <bDdr2SwitchMemory+0x54>
8110150c:	00000706 	br	8110152c <bDdr2SwitchMemory+0x64>
	case DDR2_M1_ID:
		*(puliDdr2MemAddr) = (alt_u32) DDR2_M1_MEMORY_WINDOWED_OFFSET;
81101510:	e0bffe17 	ldw	r2,-8(fp)
81101514:	10000015 	stw	zero,0(r2)
		break;
81101518:	00001406 	br	8110156c <bDdr2SwitchMemory+0xa4>
	case DDR2_M2_ID:
		*(puliDdr2MemAddr) = (alt_u32) DDR2_M2_MEMORY_WINDOWED_OFFSET;
8110151c:	e0bffe17 	ldw	r2,-8(fp)
81101520:	00e00034 	movhi	r3,32768
81101524:	10c00015 	stw	r3,0(r2)
		break;
81101528:	00001006 	br	8110156c <bDdr2SwitchMemory+0xa4>
	default:
		bSuccess = FALSE;
8110152c:	e03ffd15 	stw	zero,-12(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101530:	00e04574 	movhi	r3,33045
81101534:	18cbe504 	addi	r3,r3,12180
81101538:	00a04574 	movhi	r2,33045
8110153c:	10ad9704 	addi	r2,r2,-18852
81101540:	1009883a 	mov	r4,r2
81101544:	00800f04 	movi	r2,60
81101548:	100d883a 	mov	r6,r2
8110154c:	200b883a 	mov	r5,r4
81101550:	1809883a 	mov	r4,r3
81101554:	11220540 	call	81122054 <memcpy>
				"DR2 Memory ID not identified!! Error switching memories!! \n");
		debug(fp, cDebugBuffer)
81101558:	d0a06217 	ldw	r2,-32376(gp)
8110155c:	01604574 	movhi	r5,33045
81101560:	294be504 	addi	r5,r5,12180
81101564:	1009883a 	mov	r4,r2
81101568:	1120fa40 	call	81120fa4 <fprintf>
		;
#endif
	}

	return bSuccess;
8110156c:	e0bffd17 	ldw	r2,-12(fp)
}
81101570:	e037883a 	mov	sp,fp
81101574:	dfc00117 	ldw	ra,4(sp)
81101578:	df000017 	ldw	fp,0(sp)
8110157c:	dec00204 	addi	sp,sp,8
81101580:	f800283a 	ret

81101584 <bDdr2MemoryWriteTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryWriteTest(alt_u8 ucMemoryId) {
81101584:	deffe204 	addi	sp,sp,-120
81101588:	de00012e 	bgeu	sp,et,81101590 <bDdr2MemoryWriteTest+0xc>
8110158c:	003b68fa 	trap	3
81101590:	dfc01d15 	stw	ra,116(sp)
81101594:	df001c15 	stw	fp,112(sp)
81101598:	dc401b15 	stw	r17,108(sp)
8110159c:	dc001a15 	stw	r16,104(sp)
811015a0:	df001c04 	addi	fp,sp,112
811015a4:	2005883a 	mov	r2,r4
811015a8:	e0bffd05 	stb	r2,-12(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Write Test =====\n");
811015ac:	00e04574 	movhi	r3,33045
811015b0:	18cbe504 	addi	r3,r3,12180
811015b4:	00a04574 	movhi	r2,33045
811015b8:	10ada604 	addi	r2,r2,-18792
811015bc:	1009883a 	mov	r4,r2
811015c0:	00800a04 	movi	r2,40
811015c4:	100d883a 	mov	r6,r2
811015c8:	200b883a 	mov	r5,r4
811015cc:	1809883a 	mov	r4,r3
811015d0:	11220540 	call	81122054 <memcpy>
	debug(fp, cDebugBuffer);
811015d4:	d0a06217 	ldw	r2,-32376(gp)
811015d8:	01604574 	movhi	r5,33045
811015dc:	294be504 	addi	r5,r5,12180
811015e0:	1009883a 	mov	r4,r2
811015e4:	1120fa40 	call	81120fa4 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
811015e8:	00800044 	movi	r2,1
811015ec:	e0bfed15 	stw	r2,-76(fp)
	switch (ucMemoryId) {
811015f0:	e0bffd03 	ldbu	r2,-12(fp)
811015f4:	10000326 	beq	r2,zero,81101604 <bDdr2MemoryWriteTest+0x80>
811015f8:	10800060 	cmpeqi	r2,r2,1
811015fc:	1000081e 	bne	r2,zero,81101620 <bDdr2MemoryWriteTest+0x9c>
81101600:	00000e06 	br	8110163c <bDdr2MemoryWriteTest+0xb8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101604:	e0bffd03 	ldbu	r2,-12(fp)
81101608:	1009883a 	mov	r4,r2
8110160c:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101610:	e03fe515 	stw	zero,-108(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81101614:	00a00034 	movhi	r2,32768
81101618:	e0bfe615 	stw	r2,-104(fp)
		break;
8110161c:	00001906 	br	81101684 <bDdr2MemoryWriteTest+0x100>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101620:	e0bffd03 	ldbu	r2,-12(fp)
81101624:	1009883a 	mov	r4,r2
81101628:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
8110162c:	e03fe515 	stw	zero,-108(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81101630:	00a00034 	movhi	r2,32768
81101634:	e0bfe615 	stw	r2,-104(fp)
		break;
81101638:	00001206 	br	81101684 <bDdr2MemoryWriteTest+0x100>
	default:
		bSuccess = FALSE;
8110163c:	e03fed15 	stw	zero,-76(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101640:	00e04574 	movhi	r3,33045
81101644:	18cbe504 	addi	r3,r3,12180
81101648:	00a04574 	movhi	r2,33045
8110164c:	10abb704 	addi	r2,r2,-20772
81101650:	1009883a 	mov	r4,r2
81101654:	00800bc4 	movi	r2,47
81101658:	100d883a 	mov	r6,r2
8110165c:	200b883a 	mov	r5,r4
81101660:	1809883a 	mov	r4,r3
81101664:	11220540 	call	81122054 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81101668:	d0a06217 	ldw	r2,-32376(gp)
8110166c:	01604574 	movhi	r5,33045
81101670:	294be504 	addi	r5,r5,12180
81101674:	1009883a 	mov	r4,r2
81101678:	1120fa40 	call	81120fa4 <fprintf>
		;
#endif
		return bSuccess;
8110167c:	e0bfed17 	ldw	r2,-76(fp)
81101680:	00011806 	br	81101ae4 <bDdr2MemoryWriteTest+0x560>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
81101684:	e0bfe617 	ldw	r2,-104(fp)
81101688:	1004d53a 	srli	r2,r2,20
8110168c:	100d883a 	mov	r6,r2
81101690:	01604574 	movhi	r5,33045
81101694:	296db004 	addi	r5,r5,-18752
81101698:	01204574 	movhi	r4,33045
8110169c:	210be504 	addi	r4,r4,12180
811016a0:	11229340 	call	81122934 <sprintf>
	debug(fp, cDebugBuffer);
811016a4:	d0a06217 	ldw	r2,-32376(gp)
811016a8:	01604574 	movhi	r5,33045
811016ac:	294be504 	addi	r5,r5,12180
811016b0:	1009883a 	mov	r4,r2
811016b4:	1120fa40 	call	81120fa4 <fprintf>

	int iI, iNRemainedLen, iNAccessLen;
	TMyData *pxDes;

	int iNItemNum, iNPos;
	const int ciMyDataSize = sizeof(TMyData);
811016b8:	00800104 	movi	r2,4
811016bc:	e0bfee15 	stw	r2,-72(fp)
	int iNProgressIndex = 0;
811016c0:	e03fec15 	stw	zero,-80(fp)
	alt_u32 uliInitValue;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;
811016c4:	e03fef15 	stw	zero,-68(fp)

	for (iI = 0; iI < 10; iI++) {
811016c8:	e03fe715 	stw	zero,-100(fp)
811016cc:	00001506 	br	81101724 <bDdr2MemoryWriteTest+0x1a0>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
811016d0:	e0ffe617 	ldw	r3,-104(fp)
811016d4:	00b33374 	movhi	r2,52429
811016d8:	10b33344 	addi	r2,r2,-13107
811016dc:	1888383a 	mulxuu	r4,r3,r2
811016e0:	1885383a 	mul	r2,r3,r2
811016e4:	1021883a 	mov	r16,r2
811016e8:	2023883a 	mov	r17,r4
811016ec:	8804d0fa 	srli	r2,r17,3
811016f0:	e0ffe717 	ldw	r3,-100(fp)
811016f4:	18c00044 	addi	r3,r3,1
811016f8:	10c7383a 	mul	r3,r2,r3
811016fc:	e0bfe717 	ldw	r2,-100(fp)
81101700:	1085883a 	add	r2,r2,r2
81101704:	1085883a 	add	r2,r2,r2
81101708:	e13fe504 	addi	r4,fp,-108
8110170c:	2085883a 	add	r2,r4,r2
81101710:	10800e04 	addi	r2,r2,56
81101714:	10c00015 	stw	r3,0(r2)
	int iNProgressIndex = 0;
	alt_u32 uliInitValue;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;

	for (iI = 0; iI < 10; iI++) {
81101718:	e0bfe717 	ldw	r2,-100(fp)
8110171c:	10800044 	addi	r2,r2,1
81101720:	e0bfe715 	stw	r2,-100(fp)
81101724:	e0bfe717 	ldw	r2,-100(fp)
81101728:	10800290 	cmplti	r2,r2,10
8110172c:	103fe81e 	bne	r2,zero,811016d0 <__reset+0xfb0e16d0>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81101730:	d0a08917 	ldw	r2,-32220(gp)
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}
	uliInitValue = alt_nticks();
81101734:	e0bff015 	stw	r2,-64(fp)
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
81101738:	00804004 	movi	r2,256
8110173c:	e0bfea15 	stw	r2,-88(fp)
	for (iI = 0; iI < iNItemNum; iI++) {
81101740:	e03fe715 	stw	zero,-100(fp)
81101744:	00001e06 	br	811017c0 <bDdr2MemoryWriteTest+0x23c>
		if (iI == 0) {
81101748:	e0bfe717 	ldw	r2,-100(fp)
8110174c:	1000091e 	bne	r2,zero,81101774 <bDdr2MemoryWriteTest+0x1f0>
			xSZData[iI] = uliInitValue;
81101750:	00a04574 	movhi	r2,33045
81101754:	108c2504 	addi	r2,r2,12436
81101758:	e0ffe717 	ldw	r3,-100(fp)
8110175c:	18c7883a 	add	r3,r3,r3
81101760:	18c7883a 	add	r3,r3,r3
81101764:	10c5883a 	add	r2,r2,r3
81101768:	e0fff017 	ldw	r3,-64(fp)
8110176c:	10c00015 	stw	r3,0(r2)
81101770:	00001006 	br	811017b4 <bDdr2MemoryWriteTest+0x230>
		} else {
			xSZData[iI] = xSZData[iI - 1] * 13;
81101774:	e0bfe717 	ldw	r2,-100(fp)
81101778:	10ffffc4 	addi	r3,r2,-1
8110177c:	00a04574 	movhi	r2,33045
81101780:	108c2504 	addi	r2,r2,12436
81101784:	18c7883a 	add	r3,r3,r3
81101788:	18c7883a 	add	r3,r3,r3
8110178c:	10c5883a 	add	r2,r2,r3
81101790:	10800017 	ldw	r2,0(r2)
81101794:	11000364 	muli	r4,r2,13
81101798:	00a04574 	movhi	r2,33045
8110179c:	108c2504 	addi	r2,r2,12436
811017a0:	e0ffe717 	ldw	r3,-100(fp)
811017a4:	18c7883a 	add	r3,r3,r3
811017a8:	18c7883a 	add	r3,r3,r3
811017ac:	10c5883a 	add	r2,r2,r3
811017b0:	11000015 	stw	r4,0(r2)
	for (iI = 0; iI < 10; iI++) {
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}
	uliInitValue = alt_nticks();
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
	for (iI = 0; iI < iNItemNum; iI++) {
811017b4:	e0bfe717 	ldw	r2,-100(fp)
811017b8:	10800044 	addi	r2,r2,1
811017bc:	e0bfe715 	stw	r2,-100(fp)
811017c0:	e0ffe717 	ldw	r3,-100(fp)
811017c4:	e0bfea17 	ldw	r2,-88(fp)
811017c8:	18bfdf16 	blt	r3,r2,81101748 <__reset+0xfb0e1748>
			xSZData[iI] = uliInitValue;
		} else {
			xSZData[iI] = xSZData[iI - 1] * 13;
		}
	}
	xSZData[iNItemNum - 1] = 0xAAAAAAAA;
811017cc:	e0bfea17 	ldw	r2,-88(fp)
811017d0:	10ffffc4 	addi	r3,r2,-1
811017d4:	00a04574 	movhi	r2,33045
811017d8:	108c2504 	addi	r2,r2,12436
811017dc:	18c7883a 	add	r3,r3,r3
811017e0:	18c7883a 	add	r3,r3,r3
811017e4:	10c7883a 	add	r3,r2,r3
811017e8:	00aaaaf4 	movhi	r2,43691
811017ec:	10aaaa84 	addi	r2,r2,-21846
811017f0:	18800015 	stw	r2,0(r3)
	xSZData[iNItemNum - 2] = 0x55555555;
811017f4:	e0bfea17 	ldw	r2,-88(fp)
811017f8:	10ffff84 	addi	r3,r2,-2
811017fc:	00a04574 	movhi	r2,33045
81101800:	108c2504 	addi	r2,r2,12436
81101804:	18c7883a 	add	r3,r3,r3
81101808:	18c7883a 	add	r3,r3,r3
8110180c:	10c7883a 	add	r3,r2,r3
81101810:	00955574 	movhi	r2,21845
81101814:	10955544 	addi	r2,r2,21845
81101818:	18800015 	stw	r2,0(r3)
	xSZData[iNItemNum - 3] = 0x00000000;
8110181c:	e0bfea17 	ldw	r2,-88(fp)
81101820:	10ffff44 	addi	r3,r2,-3
81101824:	00a04574 	movhi	r2,33045
81101828:	108c2504 	addi	r2,r2,12436
8110182c:	18c7883a 	add	r3,r3,r3
81101830:	18c7883a 	add	r3,r3,r3
81101834:	10c5883a 	add	r2,r2,r3
81101838:	10000015 	stw	zero,0(r2)
	xSZData[iNItemNum - 4] = 0xFFFFFFFF;
8110183c:	e0bfea17 	ldw	r2,-88(fp)
81101840:	10ffff04 	addi	r3,r2,-4
81101844:	00a04574 	movhi	r2,33045
81101848:	108c2504 	addi	r2,r2,12436
8110184c:	18c7883a 	add	r3,r3,r3
81101850:	18c7883a 	add	r3,r3,r3
81101854:	10c5883a 	add	r2,r2,r3
81101858:	00ffffc4 	movi	r3,-1
8110185c:	10c00015 	stw	r3,0(r2)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Writing data...\n");
81101860:	00e04574 	movhi	r3,33045
81101864:	18cbe504 	addi	r3,r3,12180
81101868:	00a04574 	movhi	r2,33045
8110186c:	10adb604 	addi	r2,r2,-18728
81101870:	1009883a 	mov	r4,r2
81101874:	00800444 	movi	r2,17
81101878:	100d883a 	mov	r6,r2
8110187c:	200b883a 	mov	r5,r4
81101880:	1809883a 	mov	r4,r3
81101884:	11220540 	call	81122054 <memcpy>
	debug(fp, cDebugBuffer);
81101888:	d0a06217 	ldw	r2,-32376(gp)
8110188c:	01604574 	movhi	r5,33045
81101890:	294be504 	addi	r5,r5,12180
81101894:	1009883a 	mov	r4,r2
81101898:	1120fa40 	call	81120fa4 <fprintf>
8110189c:	d0a08917 	ldw	r2,-32220(gp)
#endif
	iTimeStart = alt_nticks();
811018a0:	e0bff115 	stw	r2,-60(fp)
	pxDes = (TMyData *) uliDdr2Base;
811018a4:	e0bfe517 	ldw	r2,-108(fp)
811018a8:	e0bfe915 	stw	r2,-92(fp)
	iNAccessLen = sizeof(xSZData);
811018ac:	00810004 	movi	r2,1024
811018b0:	e0bfe815 	stw	r2,-96(fp)
	iNItemNum = iNAccessLen / ciMyDataSize;
811018b4:	e0ffe817 	ldw	r3,-96(fp)
811018b8:	e0bfee17 	ldw	r2,-72(fp)
811018bc:	1885283a 	div	r2,r3,r2
811018c0:	e0bfea15 	stw	r2,-88(fp)
	iNPos = 0;
811018c4:	e03feb15 	stw	zero,-84(fp)
	while (iNPos < uliByteLen) {
811018c8:	00003a06 	br	811019b4 <bDdr2MemoryWriteTest+0x430>
		iNRemainedLen = uliByteLen - iNPos;
811018cc:	e0bfeb17 	ldw	r2,-84(fp)
811018d0:	e0ffe617 	ldw	r3,-104(fp)
811018d4:	1885c83a 	sub	r2,r3,r2
811018d8:	e0bff215 	stw	r2,-56(fp)
		if (iNAccessLen > iNRemainedLen) {
811018dc:	e0bfe817 	ldw	r2,-96(fp)
811018e0:	e0fff217 	ldw	r3,-56(fp)
811018e4:	1880060e 	bge	r3,r2,81101900 <bDdr2MemoryWriteTest+0x37c>
			iNAccessLen = iNRemainedLen;
811018e8:	e0bff217 	ldw	r2,-56(fp)
811018ec:	e0bfe815 	stw	r2,-96(fp)
			iNItemNum = iNAccessLen / ciMyDataSize;
811018f0:	e0ffe817 	ldw	r3,-96(fp)
811018f4:	e0bfee17 	ldw	r2,-72(fp)
811018f8:	1885283a 	div	r2,r3,r2
811018fc:	e0bfea15 	stw	r2,-88(fp)
		}
		memcpy(pxDes, xSZData, iNAccessLen);
81101900:	e0bfe817 	ldw	r2,-96(fp)
81101904:	100d883a 	mov	r6,r2
81101908:	01604574 	movhi	r5,33045
8110190c:	294c2504 	addi	r5,r5,12436
81101910:	e13fe917 	ldw	r4,-92(fp)
81101914:	11220540 	call	81122054 <memcpy>
		pxDes += iNItemNum;
81101918:	e0bfea17 	ldw	r2,-88(fp)
8110191c:	1085883a 	add	r2,r2,r2
81101920:	1085883a 	add	r2,r2,r2
81101924:	1007883a 	mov	r3,r2
81101928:	e0bfe917 	ldw	r2,-92(fp)
8110192c:	10c5883a 	add	r2,r2,r3
81101930:	e0bfe915 	stw	r2,-92(fp)
		iNPos += iNAccessLen;
81101934:	e0ffeb17 	ldw	r3,-84(fp)
81101938:	e0bfe817 	ldw	r2,-96(fp)
8110193c:	1885883a 	add	r2,r3,r2
81101940:	e0bfeb15 	stw	r2,-84(fp)
		if (iNProgressIndex <= 9 && iNPos >= uliSZProgress[iNProgressIndex]) {
81101944:	e0bfec17 	ldw	r2,-80(fp)
81101948:	10800288 	cmpgei	r2,r2,10
8110194c:	1000191e 	bne	r2,zero,811019b4 <bDdr2MemoryWriteTest+0x430>
81101950:	e0bfec17 	ldw	r2,-80(fp)
81101954:	1085883a 	add	r2,r2,r2
81101958:	1085883a 	add	r2,r2,r2
8110195c:	e0ffe504 	addi	r3,fp,-108
81101960:	1885883a 	add	r2,r3,r2
81101964:	10800e04 	addi	r2,r2,56
81101968:	10800017 	ldw	r2,0(r2)
8110196c:	e0ffeb17 	ldw	r3,-84(fp)
81101970:	18801036 	bltu	r3,r2,811019b4 <bDdr2MemoryWriteTest+0x430>
			iNProgressIndex++;
81101974:	e0bfec17 	ldw	r2,-80(fp)
81101978:	10800044 	addi	r2,r2,1
8110197c:	e0bfec15 	stw	r2,-80(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
81101980:	e0bfec17 	ldw	r2,-80(fp)
81101984:	108002a4 	muli	r2,r2,10
81101988:	100d883a 	mov	r6,r2
8110198c:	01604574 	movhi	r5,33045
81101990:	296dbb04 	addi	r5,r5,-18708
81101994:	01204574 	movhi	r4,33045
81101998:	210be504 	addi	r4,r4,12180
8110199c:	11229340 	call	81122934 <sprintf>
			debug(fp, cDebugBuffer);
811019a0:	d0a06217 	ldw	r2,-32376(gp)
811019a4:	01604574 	movhi	r5,33045
811019a8:	294be504 	addi	r5,r5,12180
811019ac:	1009883a 	mov	r4,r2
811019b0:	1120fa40 	call	81120fa4 <fprintf>
	iTimeStart = alt_nticks();
	pxDes = (TMyData *) uliDdr2Base;
	iNAccessLen = sizeof(xSZData);
	iNItemNum = iNAccessLen / ciMyDataSize;
	iNPos = 0;
	while (iNPos < uliByteLen) {
811019b4:	e0ffeb17 	ldw	r3,-84(fp)
811019b8:	e0bfe617 	ldw	r2,-104(fp)
811019bc:	18bfc336 	bltu	r3,r2,811018cc <__reset+0xfb0e18cc>
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
			debug(fp, cDebugBuffer);
#endif
		}
	}
	alt_dcache_flush_all();
811019c0:	1135e940 	call	81135e94 <alt_dcache_flush_all>
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811019c4:	00a04574 	movhi	r2,33045
811019c8:	108be504 	addi	r2,r2,12180
811019cc:	00c00284 	movi	r3,10
811019d0:	10c00005 	stb	r3,0(r2)
811019d4:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811019d8:	d0a06217 	ldw	r2,-32376(gp)
811019dc:	01604574 	movhi	r5,33045
811019e0:	294be504 	addi	r5,r5,12180
811019e4:	1009883a 	mov	r4,r2
811019e8:	1120fa40 	call	81120fa4 <fprintf>
811019ec:	d0e08917 	ldw	r3,-32220(gp)
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
811019f0:	e0bff117 	ldw	r2,-60(fp)
811019f4:	1885c83a 	sub	r2,r3,r2
811019f8:	e0bfef15 	stw	r2,-68(fp)
	if (bSuccess) {
811019fc:	e0bfed17 	ldw	r2,-76(fp)
81101a00:	10001e26 	beq	r2,zero,81101a7c <bDdr2MemoryWriteTest+0x4f8>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
				"DDR2 write test pass, size=%lu bytes, %.3f sec\n", uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
81101a04:	e13fef17 	ldw	r4,-68(fp)
81101a08:	111f69c0 	call	8111f69c <__floatsisf>
81101a0c:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81101a10:	d0a08817 	ldw	r2,-32224(gp)
81101a14:	1009883a 	mov	r4,r2
81101a18:	111f7c80 	call	8111f7c8 <__floatunsisf>
81101a1c:	1007883a 	mov	r3,r2
81101a20:	180b883a 	mov	r5,r3
81101a24:	8009883a 	mov	r4,r16
81101a28:	111ee500 	call	8111ee50 <__divsf3>
81101a2c:	1007883a 	mov	r3,r2
81101a30:	1805883a 	mov	r2,r3
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
	if (bSuccess) {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101a34:	1009883a 	mov	r4,r2
81101a38:	1120b240 	call	81120b24 <__extendsfdf2>
81101a3c:	1009883a 	mov	r4,r2
81101a40:	180b883a 	mov	r5,r3
81101a44:	d9400015 	stw	r5,0(sp)
81101a48:	200f883a 	mov	r7,r4
81101a4c:	e1bfe617 	ldw	r6,-104(fp)
81101a50:	01604574 	movhi	r5,33045
81101a54:	296dbd04 	addi	r5,r5,-18700
81101a58:	01204574 	movhi	r4,33045
81101a5c:	210be504 	addi	r4,r4,12180
81101a60:	11229340 	call	81122934 <sprintf>
				"DDR2 write test pass, size=%lu bytes, %.3f sec\n", uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
		debug(fp, cDebugBuffer);
81101a64:	d0a06217 	ldw	r2,-32376(gp)
81101a68:	01604574 	movhi	r5,33045
81101a6c:	294be504 	addi	r5,r5,12180
81101a70:	1009883a 	mov	r4,r2
81101a74:	1120fa40 	call	81120fa4 <fprintf>
81101a78:	00000f06 	br	81101ab8 <bDdr2MemoryWriteTest+0x534>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 write test fail\n");
81101a7c:	00e04574 	movhi	r3,33045
81101a80:	18cbe504 	addi	r3,r3,12180
81101a84:	00a04574 	movhi	r2,33045
81101a88:	10adc904 	addi	r2,r2,-18652
81101a8c:	1009883a 	mov	r4,r2
81101a90:	00800584 	movi	r2,22
81101a94:	100d883a 	mov	r6,r2
81101a98:	200b883a 	mov	r5,r4
81101a9c:	1809883a 	mov	r4,r3
81101aa0:	11220540 	call	81122054 <memcpy>
		debug(fp, cDebugBuffer);
81101aa4:	d0a06217 	ldw	r2,-32376(gp)
81101aa8:	01604574 	movhi	r5,33045
81101aac:	294be504 	addi	r5,r5,12180
81101ab0:	1009883a 	mov	r4,r2
81101ab4:	1120fa40 	call	81120fa4 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101ab8:	00a04574 	movhi	r2,33045
81101abc:	108be504 	addi	r2,r2,12180
81101ac0:	00c00284 	movi	r3,10
81101ac4:	10c00005 	stb	r3,0(r2)
81101ac8:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101acc:	d0a06217 	ldw	r2,-32376(gp)
81101ad0:	01604574 	movhi	r5,33045
81101ad4:	294be504 	addi	r5,r5,12180
81101ad8:	1009883a 	mov	r4,r2
81101adc:	1120fa40 	call	81120fa4 <fprintf>
#endif

	return bSuccess;
81101ae0:	e0bfed17 	ldw	r2,-76(fp)
}
81101ae4:	e6fffe04 	addi	sp,fp,-8
81101ae8:	dfc00317 	ldw	ra,12(sp)
81101aec:	df000217 	ldw	fp,8(sp)
81101af0:	dc400117 	ldw	r17,4(sp)
81101af4:	dc000017 	ldw	r16,0(sp)
81101af8:	dec00404 	addi	sp,sp,16
81101afc:	f800283a 	ret

81101b00 <bDdr2MemoryReadTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryReadTest(alt_u8 ucMemoryId) {
81101b00:	deffe204 	addi	sp,sp,-120
81101b04:	de00012e 	bgeu	sp,et,81101b0c <bDdr2MemoryReadTest+0xc>
81101b08:	003b68fa 	trap	3
81101b0c:	dfc01d15 	stw	ra,116(sp)
81101b10:	df001c15 	stw	fp,112(sp)
81101b14:	dc401b15 	stw	r17,108(sp)
81101b18:	dc001a15 	stw	r16,104(sp)
81101b1c:	df001c04 	addi	fp,sp,112
81101b20:	2005883a 	mov	r2,r4
81101b24:	e0bffd05 	stb	r2,-12(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Read Test =====\n");
81101b28:	00e04574 	movhi	r3,33045
81101b2c:	18cbe504 	addi	r3,r3,12180
81101b30:	00a04574 	movhi	r2,33045
81101b34:	10adcf04 	addi	r2,r2,-18628
81101b38:	1009883a 	mov	r4,r2
81101b3c:	008009c4 	movi	r2,39
81101b40:	100d883a 	mov	r6,r2
81101b44:	200b883a 	mov	r5,r4
81101b48:	1809883a 	mov	r4,r3
81101b4c:	11220540 	call	81122054 <memcpy>
	debug(fp, cDebugBuffer);
81101b50:	d0a06217 	ldw	r2,-32376(gp)
81101b54:	01604574 	movhi	r5,33045
81101b58:	294be504 	addi	r5,r5,12180
81101b5c:	1009883a 	mov	r4,r2
81101b60:	1120fa40 	call	81120fa4 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
81101b64:	00800044 	movi	r2,1
81101b68:	e0bfe515 	stw	r2,-108(fp)
	switch (ucMemoryId) {
81101b6c:	e0bffd03 	ldbu	r2,-12(fp)
81101b70:	10000326 	beq	r2,zero,81101b80 <bDdr2MemoryReadTest+0x80>
81101b74:	10800060 	cmpeqi	r2,r2,1
81101b78:	1000081e 	bne	r2,zero,81101b9c <bDdr2MemoryReadTest+0x9c>
81101b7c:	00000e06 	br	81101bb8 <bDdr2MemoryReadTest+0xb8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101b80:	e0bffd03 	ldbu	r2,-12(fp)
81101b84:	1009883a 	mov	r4,r2
81101b88:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101b8c:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81101b90:	00a00034 	movhi	r2,32768
81101b94:	e0bfe715 	stw	r2,-100(fp)
		break;
81101b98:	00001906 	br	81101c00 <bDdr2MemoryReadTest+0x100>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101b9c:	e0bffd03 	ldbu	r2,-12(fp)
81101ba0:	1009883a 	mov	r4,r2
81101ba4:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101ba8:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81101bac:	00a00034 	movhi	r2,32768
81101bb0:	e0bfe715 	stw	r2,-100(fp)
		break;
81101bb4:	00001206 	br	81101c00 <bDdr2MemoryReadTest+0x100>
	default:
		bSuccess = FALSE;
81101bb8:	e03fe515 	stw	zero,-108(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101bbc:	00e04574 	movhi	r3,33045
81101bc0:	18cbe504 	addi	r3,r3,12180
81101bc4:	00a04574 	movhi	r2,33045
81101bc8:	10abb704 	addi	r2,r2,-20772
81101bcc:	1009883a 	mov	r4,r2
81101bd0:	00800bc4 	movi	r2,47
81101bd4:	100d883a 	mov	r6,r2
81101bd8:	200b883a 	mov	r5,r4
81101bdc:	1809883a 	mov	r4,r3
81101be0:	11220540 	call	81122054 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81101be4:	d0a06217 	ldw	r2,-32376(gp)
81101be8:	01604574 	movhi	r5,33045
81101bec:	294be504 	addi	r5,r5,12180
81101bf0:	1009883a 	mov	r4,r2
81101bf4:	1120fa40 	call	81120fa4 <fprintf>
		;
#endif
		return bSuccess;
81101bf8:	e0bfe517 	ldw	r2,-108(fp)
81101bfc:	0000fc06 	br	81101ff0 <bDdr2MemoryReadTest+0x4f0>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %lu MBytes\n", uliByteLen / 1024 / 1024);
81101c00:	e0bfe717 	ldw	r2,-100(fp)
81101c04:	1004d53a 	srli	r2,r2,20
81101c08:	100d883a 	mov	r6,r2
81101c0c:	01604574 	movhi	r5,33045
81101c10:	296dd904 	addi	r5,r5,-18588
81101c14:	01204574 	movhi	r4,33045
81101c18:	210be504 	addi	r4,r4,12180
81101c1c:	11229340 	call	81122934 <sprintf>
	debug(fp, cDebugBuffer);
81101c20:	d0a06217 	ldw	r2,-32376(gp)
81101c24:	01604574 	movhi	r5,33045
81101c28:	294be504 	addi	r5,r5,12180
81101c2c:	1009883a 	mov	r4,r2
81101c30:	1120fa40 	call	81120fa4 <fprintf>
#endif

	int iI, iNRemainedLen, iNAccessLen;
	TMyData *pxDes, *pxSrc;
	int iNItemNum, iNPos;
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
81101c34:	00804004 	movi	r2,256
81101c38:	e0bfec15 	stw	r2,-80(fp)
	const int ciMyDataSize = sizeof(TMyData);
81101c3c:	00800104 	movi	r2,4
81101c40:	e0bfef15 	stw	r2,-68(fp)
	iNAccessLen = iNItemNum * ciMyDataSize;
81101c44:	e0ffec17 	ldw	r3,-80(fp)
81101c48:	e0bfef17 	ldw	r2,-68(fp)
81101c4c:	1885383a 	mul	r2,r3,r2
81101c50:	e0bfe915 	stw	r2,-92(fp)
	int iNProgressIndex = 0;
81101c54:	e03fee15 	stw	zero,-72(fp)
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;
81101c58:	e03ff015 	stw	zero,-64(fp)

	for (iI = 0; iI < 10; iI++) {
81101c5c:	e03fe815 	stw	zero,-96(fp)
81101c60:	00001506 	br	81101cb8 <bDdr2MemoryReadTest+0x1b8>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
81101c64:	e0ffe717 	ldw	r3,-100(fp)
81101c68:	00b33374 	movhi	r2,52429
81101c6c:	10b33344 	addi	r2,r2,-13107
81101c70:	1888383a 	mulxuu	r4,r3,r2
81101c74:	1885383a 	mul	r2,r3,r2
81101c78:	1021883a 	mov	r16,r2
81101c7c:	2023883a 	mov	r17,r4
81101c80:	8804d0fa 	srli	r2,r17,3
81101c84:	e0ffe817 	ldw	r3,-96(fp)
81101c88:	18c00044 	addi	r3,r3,1
81101c8c:	10c7383a 	mul	r3,r2,r3
81101c90:	e0bfe817 	ldw	r2,-96(fp)
81101c94:	1085883a 	add	r2,r2,r2
81101c98:	1085883a 	add	r2,r2,r2
81101c9c:	e13fe504 	addi	r4,fp,-108
81101ca0:	2085883a 	add	r2,r4,r2
81101ca4:	10800e04 	addi	r2,r2,56
81101ca8:	10c00015 	stw	r3,0(r2)
	iNAccessLen = iNItemNum * ciMyDataSize;
	int iNProgressIndex = 0;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;

	for (iI = 0; iI < 10; iI++) {
81101cac:	e0bfe817 	ldw	r2,-96(fp)
81101cb0:	10800044 	addi	r2,r2,1
81101cb4:	e0bfe815 	stw	r2,-96(fp)
81101cb8:	e0bfe817 	ldw	r2,-96(fp)
81101cbc:	10800290 	cmplti	r2,r2,10
81101cc0:	103fe81e 	bne	r2,zero,81101c64 <__reset+0xfb0e1c64>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}

	iNProgressIndex = 0;
81101cc4:	e03fee15 	stw	zero,-72(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Reading/Verifying Data...\n");
81101cc8:	00e04574 	movhi	r3,33045
81101ccc:	18cbe504 	addi	r3,r3,12180
81101cd0:	00a04574 	movhi	r2,33045
81101cd4:	10addf04 	addi	r2,r2,-18564
81101cd8:	1009883a 	mov	r4,r2
81101cdc:	008006c4 	movi	r2,27
81101ce0:	100d883a 	mov	r6,r2
81101ce4:	200b883a 	mov	r5,r4
81101ce8:	1809883a 	mov	r4,r3
81101cec:	11220540 	call	81122054 <memcpy>
	debug(fp, cDebugBuffer);
81101cf0:	d0a06217 	ldw	r2,-32376(gp)
81101cf4:	01604574 	movhi	r5,33045
81101cf8:	294be504 	addi	r5,r5,12180
81101cfc:	1009883a 	mov	r4,r2
81101d00:	1120fa40 	call	81120fa4 <fprintf>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81101d04:	d0a08917 	ldw	r2,-32220(gp)
#endif
	iTimeStart = alt_nticks();
81101d08:	e0bff115 	stw	r2,-60(fp)

	pxSrc = (TMyData *) uliDdr2Base;
81101d0c:	e0bfe617 	ldw	r2,-104(fp)
81101d10:	e0bfeb15 	stw	r2,-84(fp)
	iNAccessLen = sizeof(xSZData);
81101d14:	00810004 	movi	r2,1024
81101d18:	e0bfe915 	stw	r2,-92(fp)
	iNItemNum = iNAccessLen / ciMyDataSize;
81101d1c:	e0ffe917 	ldw	r3,-92(fp)
81101d20:	e0bfef17 	ldw	r2,-68(fp)
81101d24:	1885283a 	div	r2,r3,r2
81101d28:	e0bfec15 	stw	r2,-80(fp)
	iNPos = 0;
81101d2c:	e03fed15 	stw	zero,-76(fp)
	while (bSuccess && iNPos < uliByteLen) {
81101d30:	00006206 	br	81101ebc <bDdr2MemoryReadTest+0x3bc>
		iNRemainedLen = uliByteLen - iNPos;
81101d34:	e0bfed17 	ldw	r2,-76(fp)
81101d38:	e0ffe717 	ldw	r3,-100(fp)
81101d3c:	1885c83a 	sub	r2,r3,r2
81101d40:	e0bff215 	stw	r2,-56(fp)
		if (iNAccessLen > iNRemainedLen) {
81101d44:	e0bfe917 	ldw	r2,-92(fp)
81101d48:	e0fff217 	ldw	r3,-56(fp)
81101d4c:	1880060e 	bge	r3,r2,81101d68 <bDdr2MemoryReadTest+0x268>
			iNAccessLen = iNRemainedLen;
81101d50:	e0bff217 	ldw	r2,-56(fp)
81101d54:	e0bfe915 	stw	r2,-92(fp)
			iNItemNum = iNAccessLen / ciMyDataSize;
81101d58:	e0ffe917 	ldw	r3,-92(fp)
81101d5c:	e0bfef17 	ldw	r2,-68(fp)
81101d60:	1885283a 	div	r2,r3,r2
81101d64:	e0bfec15 	stw	r2,-80(fp)
		}
		pxDes = xSZData;
81101d68:	00a04574 	movhi	r2,33045
81101d6c:	108c2504 	addi	r2,r2,12436
81101d70:	e0bfea15 	stw	r2,-88(fp)
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
81101d74:	e03fe815 	stw	zero,-96(fp)
81101d78:	00002b06 	br	81101e28 <bDdr2MemoryReadTest+0x328>
			if (*pxSrc++ != *pxDes++) {
81101d7c:	e0bfeb17 	ldw	r2,-84(fp)
81101d80:	10c00104 	addi	r3,r2,4
81101d84:	e0ffeb15 	stw	r3,-84(fp)
81101d88:	10c00017 	ldw	r3,0(r2)
81101d8c:	e0bfea17 	ldw	r2,-88(fp)
81101d90:	11000104 	addi	r4,r2,4
81101d94:	e13fea15 	stw	r4,-88(fp)
81101d98:	10800017 	ldw	r2,0(r2)
81101d9c:	18801f26 	beq	r3,r2,81101e1c <bDdr2MemoryReadTest+0x31c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
81101da0:	e0bfeb17 	ldw	r2,-84(fp)
81101da4:	10bfff04 	addi	r2,r2,-4
81101da8:	10800017 	ldw	r2,0(r2)
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101dac:	1009883a 	mov	r4,r2
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
81101db0:	00a04574 	movhi	r2,33045
81101db4:	108c2504 	addi	r2,r2,12436
81101db8:	e0ffe817 	ldw	r3,-96(fp)
81101dbc:	18c7883a 	add	r3,r3,r3
81101dc0:	18c7883a 	add	r3,r3,r3
81101dc4:	10c5883a 	add	r2,r2,r3
81101dc8:	10800017 	ldw	r2,0(r2)
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101dcc:	100b883a 	mov	r5,r2
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
						(iNPos / ciMyDataSize) + iI);
81101dd0:	e0ffed17 	ldw	r3,-76(fp)
81101dd4:	e0bfef17 	ldw	r2,-68(fp)
81101dd8:	1887283a 	div	r3,r3,r2
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101ddc:	e0bfe817 	ldw	r2,-96(fp)
81101de0:	1885883a 	add	r2,r3,r2
81101de4:	d8800015 	stw	r2,0(sp)
81101de8:	280f883a 	mov	r7,r5
81101dec:	200d883a 	mov	r6,r4
81101df0:	01604574 	movhi	r5,33045
81101df4:	296de604 	addi	r5,r5,-18536
81101df8:	01204574 	movhi	r4,33045
81101dfc:	210be504 	addi	r4,r4,12180
81101e00:	11229340 	call	81122934 <sprintf>
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
						(iNPos / ciMyDataSize) + iI);
				debug(fp, cDebugBuffer);
81101e04:	d0a06217 	ldw	r2,-32376(gp)
81101e08:	01604574 	movhi	r5,33045
81101e0c:	294be504 	addi	r5,r5,12180
81101e10:	1009883a 	mov	r4,r2
81101e14:	1120fa40 	call	81120fa4 <fprintf>
#endif
				bSuccess = FALSE;
81101e18:	e03fe515 	stw	zero,-108(fp)
		if (iNAccessLen > iNRemainedLen) {
			iNAccessLen = iNRemainedLen;
			iNItemNum = iNAccessLen / ciMyDataSize;
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
81101e1c:	e0bfe817 	ldw	r2,-96(fp)
81101e20:	10800044 	addi	r2,r2,1
81101e24:	e0bfe815 	stw	r2,-96(fp)
81101e28:	e0ffe817 	ldw	r3,-96(fp)
81101e2c:	e0bfec17 	ldw	r2,-80(fp)
81101e30:	1880020e 	bge	r3,r2,81101e3c <bDdr2MemoryReadTest+0x33c>
81101e34:	e0bfe517 	ldw	r2,-108(fp)
81101e38:	103fd01e 	bne	r2,zero,81101d7c <__reset+0xfb0e1d7c>
				debug(fp, cDebugBuffer);
#endif
				bSuccess = FALSE;
			}
		}
		iNPos += iNAccessLen;
81101e3c:	e0ffed17 	ldw	r3,-76(fp)
81101e40:	e0bfe917 	ldw	r2,-92(fp)
81101e44:	1885883a 	add	r2,r3,r2
81101e48:	e0bfed15 	stw	r2,-76(fp)
		if (iNProgressIndex <= 9 && iNPos >= uliSZProgress[iNProgressIndex]) {
81101e4c:	e0bfee17 	ldw	r2,-72(fp)
81101e50:	10800288 	cmpgei	r2,r2,10
81101e54:	1000191e 	bne	r2,zero,81101ebc <bDdr2MemoryReadTest+0x3bc>
81101e58:	e0bfee17 	ldw	r2,-72(fp)
81101e5c:	1085883a 	add	r2,r2,r2
81101e60:	1085883a 	add	r2,r2,r2
81101e64:	e0ffe504 	addi	r3,fp,-108
81101e68:	1885883a 	add	r2,r3,r2
81101e6c:	10800e04 	addi	r2,r2,56
81101e70:	10800017 	ldw	r2,0(r2)
81101e74:	e0ffed17 	ldw	r3,-76(fp)
81101e78:	18801036 	bltu	r3,r2,81101ebc <bDdr2MemoryReadTest+0x3bc>
			iNProgressIndex++;
81101e7c:	e0bfee17 	ldw	r2,-72(fp)
81101e80:	10800044 	addi	r2,r2,1
81101e84:	e0bfee15 	stw	r2,-72(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
81101e88:	e0bfee17 	ldw	r2,-72(fp)
81101e8c:	108002a4 	muli	r2,r2,10
81101e90:	100d883a 	mov	r6,r2
81101e94:	01604574 	movhi	r5,33045
81101e98:	296dbb04 	addi	r5,r5,-18708
81101e9c:	01204574 	movhi	r4,33045
81101ea0:	210be504 	addi	r4,r4,12180
81101ea4:	11229340 	call	81122934 <sprintf>
			debug(fp, cDebugBuffer);
81101ea8:	d0a06217 	ldw	r2,-32376(gp)
81101eac:	01604574 	movhi	r5,33045
81101eb0:	294be504 	addi	r5,r5,12180
81101eb4:	1009883a 	mov	r4,r2
81101eb8:	1120fa40 	call	81120fa4 <fprintf>

	pxSrc = (TMyData *) uliDdr2Base;
	iNAccessLen = sizeof(xSZData);
	iNItemNum = iNAccessLen / ciMyDataSize;
	iNPos = 0;
	while (bSuccess && iNPos < uliByteLen) {
81101ebc:	e0bfe517 	ldw	r2,-108(fp)
81101ec0:	10000326 	beq	r2,zero,81101ed0 <bDdr2MemoryReadTest+0x3d0>
81101ec4:	e0ffed17 	ldw	r3,-76(fp)
81101ec8:	e0bfe717 	ldw	r2,-100(fp)
81101ecc:	18bf9936 	bltu	r3,r2,81101d34 <__reset+0xfb0e1d34>
			debug(fp, cDebugBuffer);
#endif
		}
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101ed0:	00a04574 	movhi	r2,33045
81101ed4:	108be504 	addi	r2,r2,12180
81101ed8:	00c00284 	movi	r3,10
81101edc:	10c00005 	stb	r3,0(r2)
81101ee0:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101ee4:	d0a06217 	ldw	r2,-32376(gp)
81101ee8:	01604574 	movhi	r5,33045
81101eec:	294be504 	addi	r5,r5,12180
81101ef0:	1009883a 	mov	r4,r2
81101ef4:	1120fa40 	call	81120fa4 <fprintf>
81101ef8:	d0e08917 	ldw	r3,-32220(gp)
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
81101efc:	e0bff117 	ldw	r2,-60(fp)
81101f00:	1885c83a 	sub	r2,r3,r2
81101f04:	e0bff015 	stw	r2,-64(fp)
	if (bSuccess) {
81101f08:	e0bfe517 	ldw	r2,-108(fp)
81101f0c:	10001e26 	beq	r2,zero,81101f88 <bDdr2MemoryReadTest+0x488>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test pass, size=%ld bytes, %.3f sec\n",
				uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
81101f10:	e13ff017 	ldw	r4,-64(fp)
81101f14:	111f69c0 	call	8111f69c <__floatsisf>
81101f18:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81101f1c:	d0a08817 	ldw	r2,-32224(gp)
81101f20:	1009883a 	mov	r4,r2
81101f24:	111f7c80 	call	8111f7c8 <__floatunsisf>
81101f28:	1007883a 	mov	r3,r2
81101f2c:	180b883a 	mov	r5,r3
81101f30:	8009883a 	mov	r4,r16
81101f34:	111ee500 	call	8111ee50 <__divsf3>
81101f38:	1007883a 	mov	r3,r2
81101f3c:	1805883a 	mov	r2,r3
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
	if (bSuccess) {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test pass, size=%ld bytes, %.3f sec\n",
81101f40:	1009883a 	mov	r4,r2
81101f44:	1120b240 	call	81120b24 <__extendsfdf2>
81101f48:	1009883a 	mov	r4,r2
81101f4c:	180b883a 	mov	r5,r3
81101f50:	d9400015 	stw	r5,0(sp)
81101f54:	200f883a 	mov	r7,r4
81101f58:	e1bfe717 	ldw	r6,-100(fp)
81101f5c:	01604574 	movhi	r5,33045
81101f60:	296df404 	addi	r5,r5,-18480
81101f64:	01204574 	movhi	r4,33045
81101f68:	210be504 	addi	r4,r4,12180
81101f6c:	11229340 	call	81122934 <sprintf>
				uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
		debug(fp, cDebugBuffer);
81101f70:	d0a06217 	ldw	r2,-32376(gp)
81101f74:	01604574 	movhi	r5,33045
81101f78:	294be504 	addi	r5,r5,12180
81101f7c:	1009883a 	mov	r4,r2
81101f80:	1120fa40 	call	81120fa4 <fprintf>
81101f84:	00000f06 	br	81101fc4 <bDdr2MemoryReadTest+0x4c4>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test fail\n");
81101f88:	00e04574 	movhi	r3,33045
81101f8c:	18cbe504 	addi	r3,r3,12180
81101f90:	00a04574 	movhi	r2,33045
81101f94:	10ae0004 	addi	r2,r2,-18432
81101f98:	1009883a 	mov	r4,r2
81101f9c:	00800544 	movi	r2,21
81101fa0:	100d883a 	mov	r6,r2
81101fa4:	200b883a 	mov	r5,r4
81101fa8:	1809883a 	mov	r4,r3
81101fac:	11220540 	call	81122054 <memcpy>
		debug(fp, cDebugBuffer);
81101fb0:	d0a06217 	ldw	r2,-32376(gp)
81101fb4:	01604574 	movhi	r5,33045
81101fb8:	294be504 	addi	r5,r5,12180
81101fbc:	1009883a 	mov	r4,r2
81101fc0:	1120fa40 	call	81120fa4 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101fc4:	00a04574 	movhi	r2,33045
81101fc8:	108be504 	addi	r2,r2,12180
81101fcc:	00c00284 	movi	r3,10
81101fd0:	10c00005 	stb	r3,0(r2)
81101fd4:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101fd8:	d0a06217 	ldw	r2,-32376(gp)
81101fdc:	01604574 	movhi	r5,33045
81101fe0:	294be504 	addi	r5,r5,12180
81101fe4:	1009883a 	mov	r4,r2
81101fe8:	1120fa40 	call	81120fa4 <fprintf>
#endif

	return bSuccess;
81101fec:	e0bfe517 	ldw	r2,-108(fp)
}
81101ff0:	e6fffe04 	addi	sp,fp,-8
81101ff4:	dfc00317 	ldw	ra,12(sp)
81101ff8:	df000217 	ldw	fp,8(sp)
81101ffc:	dc400117 	ldw	r17,4(sp)
81102000:	dc000017 	ldw	r16,0(sp)
81102004:	dec00404 	addi	sp,sp,16
81102008:	f800283a 	ret

8110200c <bDdr2MemoryRandomWriteTest>:
 * @param [in] bTime  Controla se a durao da funo ser medida
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryRandomWriteTest(alt_u8 ucMemoryId, bool bVerbose, bool bTime) {
8110200c:	deffec04 	addi	sp,sp,-80
81102010:	de00012e 	bgeu	sp,et,81102018 <bDdr2MemoryRandomWriteTest+0xc>
81102014:	003b68fa 	trap	3
81102018:	dfc01315 	stw	ra,76(sp)
8110201c:	df001215 	stw	fp,72(sp)
81102020:	dcc01115 	stw	r19,68(sp)
81102024:	dc801015 	stw	r18,64(sp)
81102028:	dc400f15 	stw	r17,60(sp)
8110202c:	dc000e15 	stw	r16,56(sp)
81102030:	df001204 	addi	fp,sp,72
81102034:	2005883a 	mov	r2,r4
81102038:	e17ffa15 	stw	r5,-24(fp)
8110203c:	e1bffb15 	stw	r6,-20(fp)
81102040:	e0bff905 	stb	r2,-28(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Random Write Test =====\n");
81102044:	00e04574 	movhi	r3,33045
81102048:	18cbe504 	addi	r3,r3,12180
8110204c:	00a04574 	movhi	r2,33045
81102050:	10ae0604 	addi	r2,r2,-18408
81102054:	1009883a 	mov	r4,r2
81102058:	00800bc4 	movi	r2,47
8110205c:	100d883a 	mov	r6,r2
81102060:	200b883a 	mov	r5,r4
81102064:	1809883a 	mov	r4,r3
81102068:	11220540 	call	81122054 <memcpy>
	debug(fp, cDebugBuffer);
8110206c:	d0a06217 	ldw	r2,-32376(gp)
81102070:	01604574 	movhi	r5,33045
81102074:	294be504 	addi	r5,r5,12180
81102078:	1009883a 	mov	r4,r2
8110207c:	1120fa40 	call	81120fa4 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
81102080:	00800044 	movi	r2,1
81102084:	e0bff415 	stw	r2,-48(fp)
	switch (ucMemoryId) {
81102088:	e0bff903 	ldbu	r2,-28(fp)
8110208c:	10000326 	beq	r2,zero,8110209c <bDdr2MemoryRandomWriteTest+0x90>
81102090:	10800060 	cmpeqi	r2,r2,1
81102094:	1000081e 	bne	r2,zero,811020b8 <bDdr2MemoryRandomWriteTest+0xac>
81102098:	00000e06 	br	811020d4 <bDdr2MemoryRandomWriteTest+0xc8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
8110209c:	e0bff903 	ldbu	r2,-28(fp)
811020a0:	1009883a 	mov	r4,r2
811020a4:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
811020a8:	e03fef15 	stw	zero,-68(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
811020ac:	00a00034 	movhi	r2,32768
811020b0:	e0bff015 	stw	r2,-64(fp)
		break;
811020b4:	00001906 	br	8110211c <bDdr2MemoryRandomWriteTest+0x110>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
811020b8:	e0bff903 	ldbu	r2,-28(fp)
811020bc:	1009883a 	mov	r4,r2
811020c0:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
811020c4:	e03fef15 	stw	zero,-68(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
811020c8:	00a00034 	movhi	r2,32768
811020cc:	e0bff015 	stw	r2,-64(fp)
		break;
811020d0:	00001206 	br	8110211c <bDdr2MemoryRandomWriteTest+0x110>
	default:
		bSuccess = FALSE;
811020d4:	e03ff415 	stw	zero,-48(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811020d8:	00e04574 	movhi	r3,33045
811020dc:	18cbe504 	addi	r3,r3,12180
811020e0:	00a04574 	movhi	r2,33045
811020e4:	10abb704 	addi	r2,r2,-20772
811020e8:	1009883a 	mov	r4,r2
811020ec:	00800bc4 	movi	r2,47
811020f0:	100d883a 	mov	r6,r2
811020f4:	200b883a 	mov	r5,r4
811020f8:	1809883a 	mov	r4,r3
811020fc:	11220540 	call	81122054 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81102100:	d0a06217 	ldw	r2,-32376(gp)
81102104:	01604574 	movhi	r5,33045
81102108:	294be504 	addi	r5,r5,12180
8110210c:	1009883a 	mov	r4,r2
81102110:	1120fa40 	call	81120fa4 <fprintf>
		;
#endif
		return bSuccess;
81102114:	e0bff417 	ldw	r2,-48(fp)
81102118:	0000ce06 	br	81102454 <bDdr2MemoryRandomWriteTest+0x448>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
8110211c:	e0bff017 	ldw	r2,-64(fp)
81102120:	1004d53a 	srli	r2,r2,20
81102124:	100d883a 	mov	r6,r2
81102128:	01604574 	movhi	r5,33045
8110212c:	296db004 	addi	r5,r5,-18752
81102130:	01204574 	movhi	r4,33045
81102134:	210be504 	addi	r4,r4,12180
81102138:	11229340 	call	81122934 <sprintf>
	debug(fp, cDebugBuffer);
8110213c:	d0a06217 	ldw	r2,-32376(gp)
81102140:	01604574 	movhi	r5,33045
81102144:	294be504 	addi	r5,r5,12180
81102148:	1009883a 	mov	r4,r2
8110214c:	1120fa40 	call	81120fa4 <fprintf>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81102150:	d0a08917 	ldw	r2,-32220(gp)
	alt_u32 uliCurrentState;
	alt_u32 uliMemoryEndAddress;
	alt_u32 uliNextMilestone;
	alt_u8 ucPercentage;

	uliInitialState = alt_nticks();
81102154:	d0a03715 	stw	r2,-32548(gp)
	uliCurrentState = uliInitialState;
81102158:	d0a03717 	ldw	r2,-32548(gp)
8110215c:	e0bff815 	stw	r2,-32(fp)
	uliMemoryEndAddress = uliDdr2Base + uliByteLen;
81102160:	e0ffef17 	ldw	r3,-68(fp)
81102164:	e0bff017 	ldw	r2,-64(fp)
81102168:	1885883a 	add	r2,r3,r2
8110216c:	e0bff515 	stw	r2,-44(fp)
	uliNextMilestone = uliDdr2Base + uliByteLen / 20;
81102170:	e0fff017 	ldw	r3,-64(fp)
81102174:	00b33374 	movhi	r2,52429
81102178:	10b33344 	addi	r2,r2,-13107
8110217c:	1888383a 	mulxuu	r4,r3,r2
81102180:	1885383a 	mul	r2,r3,r2
81102184:	1025883a 	mov	r18,r2
81102188:	2027883a 	mov	r19,r4
8110218c:	9806d13a 	srli	r3,r19,4
81102190:	e0bfef17 	ldw	r2,-68(fp)
81102194:	1885883a 	add	r2,r3,r2
81102198:	e0bff215 	stw	r2,-56(fp)
	ucPercentage = 5;
8110219c:	00800144 	movi	r2,5
811021a0:	e0bff305 	stb	r2,-52(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Writing to memory...\n");
811021a4:	00e04574 	movhi	r3,33045
811021a8:	18cbe504 	addi	r3,r3,12180
811021ac:	00a04574 	movhi	r2,33045
811021b0:	10ae1204 	addi	r2,r2,-18360
811021b4:	1009883a 	mov	r4,r2
811021b8:	00800584 	movi	r2,22
811021bc:	100d883a 	mov	r6,r2
811021c0:	200b883a 	mov	r5,r4
811021c4:	1809883a 	mov	r4,r3
811021c8:	11220540 	call	81122054 <memcpy>
	debug(fp, cDebugBuffer);
811021cc:	d0a06217 	ldw	r2,-32376(gp)
811021d0:	01604574 	movhi	r5,33045
811021d4:	294be504 	addi	r5,r5,12180
811021d8:	1009883a 	mov	r4,r2
811021dc:	1120fa40 	call	81120fa4 <fprintf>
#endif
	if (bVerbose == DDR2_VERBOSE) {
811021e0:	e0bffa17 	ldw	r2,-24(fp)
811021e4:	10800058 	cmpnei	r2,r2,1
811021e8:	10000a1e 	bne	r2,zero,81102214 <bDdr2MemoryRandomWriteTest+0x208>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "00%%..");
811021ec:	01604574 	movhi	r5,33045
811021f0:	296e1804 	addi	r5,r5,-18336
811021f4:	01204574 	movhi	r4,33045
811021f8:	210be504 	addi	r4,r4,12180
811021fc:	11229340 	call	81122934 <sprintf>
		debug(fp, cDebugBuffer);
81102200:	d0a06217 	ldw	r2,-32376(gp)
81102204:	01604574 	movhi	r5,33045
81102208:	294be504 	addi	r5,r5,12180
8110220c:	1009883a 	mov	r4,r2
81102210:	1120fa40 	call	81120fa4 <fprintf>
#endif
	}
	int TimeStart, TimeElapsed = 0;
81102214:	e03ff615 	stw	zero,-40(fp)
81102218:	d0a08917 	ldw	r2,-32220(gp)

	TimeStart = alt_nticks();
8110221c:	e0bff715 	stw	r2,-36(fp)
	for (puliDestination = (alt_u32*) uliDdr2Base;
81102220:	e0bfef17 	ldw	r2,-68(fp)
81102224:	e0bff115 	stw	r2,-60(fp)
81102228:	00002c06 	br	811022dc <bDdr2MemoryRandomWriteTest+0x2d0>
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
		*puliDestination = uliXorshift32(&uliCurrentState);
8110222c:	e0bff804 	addi	r2,fp,-32
81102230:	1009883a 	mov	r4,r2
81102234:	11029100 	call	81102910 <uliXorshift32>
81102238:	1007883a 	mov	r3,r2
8110223c:	e0bff117 	ldw	r2,-60(fp)
81102240:	10c00015 	stw	r3,0(r2)
		if ((bVerbose == DDR2_VERBOSE)
				& ((alt_u32) puliDestination > uliNextMilestone)) {
81102244:	e0bffa17 	ldw	r2,-24(fp)
81102248:	10800060 	cmpeqi	r2,r2,1
8110224c:	1009883a 	mov	r4,r2
81102250:	e0bff117 	ldw	r2,-60(fp)
81102254:	e0fff217 	ldw	r3,-56(fp)
81102258:	1885803a 	cmpltu	r2,r3,r2
8110225c:	2084703a 	and	r2,r4,r2
	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
		*puliDestination = uliXorshift32(&uliCurrentState);
		if ((bVerbose == DDR2_VERBOSE)
81102260:	10803fcc 	andi	r2,r2,255
81102264:	10001a26 	beq	r2,zero,811022d0 <bDdr2MemoryRandomWriteTest+0x2c4>
				& ((alt_u32) puliDestination > uliNextMilestone)) {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "..%02d%%..", ucPercentage);
81102268:	e0bff303 	ldbu	r2,-52(fp)
8110226c:	100d883a 	mov	r6,r2
81102270:	01604574 	movhi	r5,33045
81102274:	296e1a04 	addi	r5,r5,-18328
81102278:	01204574 	movhi	r4,33045
8110227c:	210be504 	addi	r4,r4,12180
81102280:	11229340 	call	81122934 <sprintf>
			debug(fp, cDebugBuffer);
81102284:	d0a06217 	ldw	r2,-32376(gp)
81102288:	01604574 	movhi	r5,33045
8110228c:	294be504 	addi	r5,r5,12180
81102290:	1009883a 	mov	r4,r2
81102294:	1120fa40 	call	81120fa4 <fprintf>
#endif
			uliNextMilestone += uliByteLen / 20;
81102298:	e0fff017 	ldw	r3,-64(fp)
8110229c:	00b33374 	movhi	r2,52429
811022a0:	10b33344 	addi	r2,r2,-13107
811022a4:	1888383a 	mulxuu	r4,r3,r2
811022a8:	1885383a 	mul	r2,r3,r2
811022ac:	1021883a 	mov	r16,r2
811022b0:	2023883a 	mov	r17,r4
811022b4:	8804d13a 	srli	r2,r17,4
811022b8:	e0fff217 	ldw	r3,-56(fp)
811022bc:	1885883a 	add	r2,r3,r2
811022c0:	e0bff215 	stw	r2,-56(fp)
			ucPercentage += 5;
811022c4:	e0bff303 	ldbu	r2,-52(fp)
811022c8:	10800144 	addi	r2,r2,5
811022cc:	e0bff305 	stb	r2,-52(fp)
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
811022d0:	e0bff117 	ldw	r2,-60(fp)
811022d4:	10800104 	addi	r2,r2,4
811022d8:	e0bff115 	stw	r2,-60(fp)
	}
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
811022dc:	e0fff117 	ldw	r3,-60(fp)
#endif
	}
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
811022e0:	e0bff517 	ldw	r2,-44(fp)
811022e4:	18bfd136 	bltu	r3,r2,8110222c <__reset+0xfb0e222c>
#endif
			uliNextMilestone += uliByteLen / 20;
			ucPercentage += 5;
		}
	}
	alt_dcache_flush_all();
811022e8:	1135e940 	call	81135e94 <alt_dcache_flush_all>
	if (bVerbose == DDR2_VERBOSE) {
811022ec:	e0bffa17 	ldw	r2,-24(fp)
811022f0:	10800058 	cmpnei	r2,r2,1
811022f4:	10000a1e 	bne	r2,zero,81102320 <bDdr2MemoryRandomWriteTest+0x314>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "..100%%\n");
811022f8:	01604574 	movhi	r5,33045
811022fc:	296e1d04 	addi	r5,r5,-18316
81102300:	01204574 	movhi	r4,33045
81102304:	210be504 	addi	r4,r4,12180
81102308:	11229340 	call	81122934 <sprintf>
		debug(fp, cDebugBuffer);
8110230c:	d0a06217 	ldw	r2,-32376(gp)
81102310:	01604574 	movhi	r5,33045
81102314:	294be504 	addi	r5,r5,12180
81102318:	1009883a 	mov	r4,r2
8110231c:	1120fa40 	call	81120fa4 <fprintf>
#endif
	}

	if (bSuccess) {
81102320:	e0bff417 	ldw	r2,-48(fp)
81102324:	10003126 	beq	r2,zero,811023ec <bDdr2MemoryRandomWriteTest+0x3e0>
		if (bTime == TRUE) {
81102328:	e0bffb17 	ldw	r2,-20(fp)
8110232c:	10800058 	cmpnei	r2,r2,1
81102330:	1000221e 	bne	r2,zero,811023bc <bDdr2MemoryRandomWriteTest+0x3b0>
81102334:	d0e08917 	ldw	r3,-32220(gp)
			TimeElapsed = alt_nticks() - TimeStart;
81102338:	e0bff717 	ldw	r2,-36(fp)
8110233c:	1885c83a 	sub	r2,r3,r2
81102340:	e0bff615 	stw	r2,-40(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
					"DDR2 write test pass, size=%ld bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
81102344:	e13ff617 	ldw	r4,-40(fp)
81102348:	111f69c0 	call	8111f69c <__floatsisf>
8110234c:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81102350:	d0a08817 	ldw	r2,-32224(gp)
81102354:	1009883a 	mov	r4,r2
81102358:	111f7c80 	call	8111f7c8 <__floatunsisf>
8110235c:	1007883a 	mov	r3,r2
81102360:	180b883a 	mov	r5,r3
81102364:	8009883a 	mov	r4,r16
81102368:	111ee500 	call	8111ee50 <__divsf3>
8110236c:	1007883a 	mov	r3,r2
81102370:	1805883a 	mov	r2,r3

	if (bSuccess) {
		if (bTime == TRUE) {
			TimeElapsed = alt_nticks() - TimeStart;
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
81102374:	1009883a 	mov	r4,r2
81102378:	1120b240 	call	81120b24 <__extendsfdf2>
8110237c:	1009883a 	mov	r4,r2
81102380:	180b883a 	mov	r5,r3
81102384:	d9400015 	stw	r5,0(sp)
81102388:	200f883a 	mov	r7,r4
8110238c:	e1bff017 	ldw	r6,-64(fp)
81102390:	01604574 	movhi	r5,33045
81102394:	296e2004 	addi	r5,r5,-18304
81102398:	01204574 	movhi	r4,33045
8110239c:	210be504 	addi	r4,r4,12180
811023a0:	11229340 	call	81122934 <sprintf>
					"DDR2 write test pass, size=%ld bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
			debug(fp, cDebugBuffer);
811023a4:	d0a06217 	ldw	r2,-32376(gp)
811023a8:	01604574 	movhi	r5,33045
811023ac:	294be504 	addi	r5,r5,12180
811023b0:	1009883a 	mov	r4,r2
811023b4:	1120fa40 	call	81120fa4 <fprintf>
811023b8:	00001b06 	br	81102428 <bDdr2MemoryRandomWriteTest+0x41c>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "DDR2 write test pass, size=%ld bytes\n",
811023bc:	e1bff017 	ldw	r6,-64(fp)
811023c0:	01604574 	movhi	r5,33045
811023c4:	296e2c04 	addi	r5,r5,-18256
811023c8:	01204574 	movhi	r4,33045
811023cc:	210be504 	addi	r4,r4,12180
811023d0:	11229340 	call	81122934 <sprintf>
					uliByteLen);
			debug(fp, cDebugBuffer);
811023d4:	d0a06217 	ldw	r2,-32376(gp)
811023d8:	01604574 	movhi	r5,33045
811023dc:	294be504 	addi	r5,r5,12180
811023e0:	1009883a 	mov	r4,r2
811023e4:	1120fa40 	call	81120fa4 <fprintf>
811023e8:	00000f06 	br	81102428 <bDdr2MemoryRandomWriteTest+0x41c>
#endif
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 write test fail\n");
811023ec:	00e04574 	movhi	r3,33045
811023f0:	18cbe504 	addi	r3,r3,12180
811023f4:	00a04574 	movhi	r2,33045
811023f8:	10adc904 	addi	r2,r2,-18652
811023fc:	1009883a 	mov	r4,r2
81102400:	00800584 	movi	r2,22
81102404:	100d883a 	mov	r6,r2
81102408:	200b883a 	mov	r5,r4
8110240c:	1809883a 	mov	r4,r3
81102410:	11220540 	call	81122054 <memcpy>
		debug(fp, cDebugBuffer);
81102414:	d0a06217 	ldw	r2,-32376(gp)
81102418:	01604574 	movhi	r5,33045
8110241c:	294be504 	addi	r5,r5,12180
81102420:	1009883a 	mov	r4,r2
81102424:	1120fa40 	call	81120fa4 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81102428:	00a04574 	movhi	r2,33045
8110242c:	108be504 	addi	r2,r2,12180
81102430:	00c00284 	movi	r3,10
81102434:	10c00005 	stb	r3,0(r2)
81102438:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
8110243c:	d0a06217 	ldw	r2,-32376(gp)
81102440:	01604574 	movhi	r5,33045
81102444:	294be504 	addi	r5,r5,12180
81102448:	1009883a 	mov	r4,r2
8110244c:	1120fa40 	call	81120fa4 <fprintf>
#endif

	return bSuccess;
81102450:	e0bff417 	ldw	r2,-48(fp)
}
81102454:	e6fffc04 	addi	sp,fp,-16
81102458:	dfc00517 	ldw	ra,20(sp)
8110245c:	df000417 	ldw	fp,16(sp)
81102460:	dcc00317 	ldw	r19,12(sp)
81102464:	dc800217 	ldw	r18,8(sp)
81102468:	dc400117 	ldw	r17,4(sp)
8110246c:	dc000017 	ldw	r16,0(sp)
81102470:	dec00604 	addi	sp,sp,24
81102474:	f800283a 	ret

81102478 <bDdr2MemoryRandomReadTest>:
 * @param [in] bTime  Controla se a durao da funo ser medida
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryRandomReadTest(alt_u8 ucMemoryId, bool bVerbose, bool bTime) {
81102478:	deffec04 	addi	sp,sp,-80
8110247c:	de00012e 	bgeu	sp,et,81102484 <bDdr2MemoryRandomReadTest+0xc>
81102480:	003b68fa 	trap	3
81102484:	dfc01315 	stw	ra,76(sp)
81102488:	df001215 	stw	fp,72(sp)
8110248c:	dcc01115 	stw	r19,68(sp)
81102490:	dc801015 	stw	r18,64(sp)
81102494:	dc400f15 	stw	r17,60(sp)
81102498:	dc000e15 	stw	r16,56(sp)
8110249c:	df001204 	addi	fp,sp,72
811024a0:	2005883a 	mov	r2,r4
811024a4:	e17ffa15 	stw	r5,-24(fp)
811024a8:	e1bffb15 	stw	r6,-20(fp)
811024ac:	e0bff905 	stb	r2,-28(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Random Read Test =====\n");
811024b0:	00e04574 	movhi	r3,33045
811024b4:	18cbe504 	addi	r3,r3,12180
811024b8:	00a04574 	movhi	r2,33045
811024bc:	10ae3604 	addi	r2,r2,-18216
811024c0:	1009883a 	mov	r4,r2
811024c4:	00800b84 	movi	r2,46
811024c8:	100d883a 	mov	r6,r2
811024cc:	200b883a 	mov	r5,r4
811024d0:	1809883a 	mov	r4,r3
811024d4:	11220540 	call	81122054 <memcpy>
	debug(fp, cDebugBuffer);
811024d8:	d0a06217 	ldw	r2,-32376(gp)
811024dc:	01604574 	movhi	r5,33045
811024e0:	294be504 	addi	r5,r5,12180
811024e4:	1009883a 	mov	r4,r2
811024e8:	1120fa40 	call	81120fa4 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
811024ec:	00800044 	movi	r2,1
811024f0:	e0bfef15 	stw	r2,-68(fp)
	switch (ucMemoryId) {
811024f4:	e0bff903 	ldbu	r2,-28(fp)
811024f8:	10000326 	beq	r2,zero,81102508 <bDdr2MemoryRandomReadTest+0x90>
811024fc:	10800060 	cmpeqi	r2,r2,1
81102500:	1000081e 	bne	r2,zero,81102524 <bDdr2MemoryRandomReadTest+0xac>
81102504:	00000e06 	br	81102540 <bDdr2MemoryRandomReadTest+0xc8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81102508:	e0bff903 	ldbu	r2,-28(fp)
8110250c:	1009883a 	mov	r4,r2
81102510:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81102514:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81102518:	00a00034 	movhi	r2,32768
8110251c:	e0bff115 	stw	r2,-60(fp)
		break;
81102520:	00001906 	br	81102588 <bDdr2MemoryRandomReadTest+0x110>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81102524:	e0bff903 	ldbu	r2,-28(fp)
81102528:	1009883a 	mov	r4,r2
8110252c:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81102530:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81102534:	00a00034 	movhi	r2,32768
81102538:	e0bff115 	stw	r2,-60(fp)
		break;
8110253c:	00001206 	br	81102588 <bDdr2MemoryRandomReadTest+0x110>
	default:
		bSuccess = FALSE;
81102540:	e03fef15 	stw	zero,-68(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81102544:	00e04574 	movhi	r3,33045
81102548:	18cbe504 	addi	r3,r3,12180
8110254c:	00a04574 	movhi	r2,33045
81102550:	10abb704 	addi	r2,r2,-20772
81102554:	1009883a 	mov	r4,r2
81102558:	00800bc4 	movi	r2,47
8110255c:	100d883a 	mov	r6,r2
81102560:	200b883a 	mov	r5,r4
81102564:	1809883a 	mov	r4,r3
81102568:	11220540 	call	81122054 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
8110256c:	d0a06217 	ldw	r2,-32376(gp)
81102570:	01604574 	movhi	r5,33045
81102574:	294be504 	addi	r5,r5,12180
81102578:	1009883a 	mov	r4,r2
8110257c:	1120fa40 	call	81120fa4 <fprintf>
		;
#endif
		return bSuccess;
81102580:	e0bfef17 	ldw	r2,-68(fp)
81102584:	0000d906 	br	811028ec <bDdr2MemoryRandomReadTest+0x474>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
81102588:	e0bff117 	ldw	r2,-60(fp)
8110258c:	1004d53a 	srli	r2,r2,20
81102590:	100d883a 	mov	r6,r2
81102594:	01604574 	movhi	r5,33045
81102598:	296db004 	addi	r5,r5,-18752
8110259c:	01204574 	movhi	r4,33045
811025a0:	210be504 	addi	r4,r4,12180
811025a4:	11229340 	call	81122934 <sprintf>
	debug(fp, cDebugBuffer);
811025a8:	d0a06217 	ldw	r2,-32376(gp)
811025ac:	01604574 	movhi	r5,33045
811025b0:	294be504 	addi	r5,r5,12180
811025b4:	1009883a 	mov	r4,r2
811025b8:	1120fa40 	call	81120fa4 <fprintf>
	alt_u32 uliCurrentState;
	alt_u32 uliMemoryEndAddress;
	alt_u32 uliNextMilestone;
	alt_u8 ucPercentage;

	uliCurrentState = uliInitialState;
811025bc:	d0a03717 	ldw	r2,-32548(gp)
811025c0:	e0bff815 	stw	r2,-32(fp)
	uliMemoryEndAddress = uliDdr2Base + uliByteLen;
811025c4:	e0fff017 	ldw	r3,-64(fp)
811025c8:	e0bff117 	ldw	r2,-60(fp)
811025cc:	1885883a 	add	r2,r3,r2
811025d0:	e0bff515 	stw	r2,-44(fp)
	uliNextMilestone = uliDdr2Base + uliByteLen / 20;
811025d4:	e0fff117 	ldw	r3,-60(fp)
811025d8:	00b33374 	movhi	r2,52429
811025dc:	10b33344 	addi	r2,r2,-13107
811025e0:	1888383a 	mulxuu	r4,r3,r2
811025e4:	1885383a 	mul	r2,r3,r2
811025e8:	1025883a 	mov	r18,r2
811025ec:	2027883a 	mov	r19,r4
811025f0:	9806d13a 	srli	r3,r19,4
811025f4:	e0bff017 	ldw	r2,-64(fp)
811025f8:	1885883a 	add	r2,r3,r2
811025fc:	e0bff315 	stw	r2,-52(fp)
	ucPercentage = 5;
81102600:	00800144 	movi	r2,5
81102604:	e0bff405 	stb	r2,-48(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Reading from memory...\n");
81102608:	00e04574 	movhi	r3,33045
8110260c:	18cbe504 	addi	r3,r3,12180
81102610:	00a04574 	movhi	r2,33045
81102614:	10ae4204 	addi	r2,r2,-18168
81102618:	1009883a 	mov	r4,r2
8110261c:	00800604 	movi	r2,24
81102620:	100d883a 	mov	r6,r2
81102624:	200b883a 	mov	r5,r4
81102628:	1809883a 	mov	r4,r3
8110262c:	11220540 	call	81122054 <memcpy>
	debug(fp, cDebugBuffer);
81102630:	d0a06217 	ldw	r2,-32376(gp)
81102634:	01604574 	movhi	r5,33045
81102638:	294be504 	addi	r5,r5,12180
8110263c:	1009883a 	mov	r4,r2
81102640:	1120fa40 	call	81120fa4 <fprintf>
#endif
	if (bVerbose == DDR2_VERBOSE) {
81102644:	e0bffa17 	ldw	r2,-24(fp)
81102648:	10800058 	cmpnei	r2,r2,1
8110264c:	10000a1e 	bne	r2,zero,81102678 <bDdr2MemoryRandomReadTest+0x200>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "00%%..");
81102650:	01604574 	movhi	r5,33045
81102654:	296e1804 	addi	r5,r5,-18336
81102658:	01204574 	movhi	r4,33045
8110265c:	210be504 	addi	r4,r4,12180
81102660:	11229340 	call	81122934 <sprintf>
		debug(fp, cDebugBuffer);
81102664:	d0a06217 	ldw	r2,-32376(gp)
81102668:	01604574 	movhi	r5,33045
8110266c:	294be504 	addi	r5,r5,12180
81102670:	1009883a 	mov	r4,r2
81102674:	1120fa40 	call	81120fa4 <fprintf>
#endif
	}

	int TimeStart, TimeElapsed = 0;
81102678:	e03ff615 	stw	zero,-40(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
8110267c:	d0a08917 	ldw	r2,-32220(gp)

	TimeStart = alt_nticks();
81102680:	e0bff715 	stw	r2,-36(fp)
	for (puliSource = (alt_u32*) uliDdr2Base;
81102684:	e0bff017 	ldw	r2,-64(fp)
81102688:	e0bff215 	stw	r2,-56(fp)
8110268c:	00003a06 	br	81102778 <bDdr2MemoryRandomReadTest+0x300>
			(alt_u32) puliSource < uliMemoryEndAddress; puliSource++) {
		if (uliXorshift32(&uliCurrentState) != *puliSource) {
81102690:	e0bff804 	addi	r2,fp,-32
81102694:	1009883a 	mov	r4,r2
81102698:	11029100 	call	81102910 <uliXorshift32>
8110269c:	1007883a 	mov	r3,r2
811026a0:	e0bff217 	ldw	r2,-56(fp)
811026a4:	10800017 	ldw	r2,0(r2)
811026a8:	18801026 	beq	r3,r2,811026ec <bDdr2MemoryRandomReadTest+0x274>
			bSuccess = FALSE;
811026ac:	e03fef15 	stw	zero,-68(fp)
			if (bVerbose == DDR2_VERBOSE) {
811026b0:	e0bffa17 	ldw	r2,-24(fp)
811026b4:	10800058 	cmpnei	r2,r2,1
811026b8:	10000c1e 	bne	r2,zero,811026ec <bDdr2MemoryRandomReadTest+0x274>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "Failed to read adress 0x%08lX\n",
811026bc:	e0bff217 	ldw	r2,-56(fp)
811026c0:	100d883a 	mov	r6,r2
811026c4:	01604574 	movhi	r5,33045
811026c8:	296e4804 	addi	r5,r5,-18144
811026cc:	01204574 	movhi	r4,33045
811026d0:	210be504 	addi	r4,r4,12180
811026d4:	11229340 	call	81122934 <sprintf>
						(alt_u32)puliSource);
				debug(fp, cDebugBuffer);
811026d8:	d0a06217 	ldw	r2,-32376(gp)
811026dc:	01604574 	movhi	r5,33045
811026e0:	294be504 	addi	r5,r5,12180
811026e4:	1009883a 	mov	r4,r2
811026e8:	1120fa40 	call	81120fa4 <fprintf>
#endif
			}
		}
		if ((bVerbose == DDR2_VERBOSE)
811026ec:	e0bffa17 	ldw	r2,-24(fp)
811026f0:	10800058 	cmpnei	r2,r2,1
811026f4:	10001d1e 	bne	r2,zero,8110276c <bDdr2MemoryRandomReadTest+0x2f4>
				&& ((alt_u32) puliSource > uliNextMilestone)) {
811026f8:	e0bff217 	ldw	r2,-56(fp)
811026fc:	e0fff317 	ldw	r3,-52(fp)
81102700:	18801a2e 	bgeu	r3,r2,8110276c <bDdr2MemoryRandomReadTest+0x2f4>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "..%02d%%..", ucPercentage);
81102704:	e0bff403 	ldbu	r2,-48(fp)
81102708:	100d883a 	mov	r6,r2
8110270c:	01604574 	movhi	r5,33045
81102710:	296e1a04 	addi	r5,r5,-18328
81102714:	01204574 	movhi	r4,33045
81102718:	210be504 	addi	r4,r4,12180
8110271c:	11229340 	call	81122934 <sprintf>
			debug(fp, cDebugBuffer);
81102720:	d0a06217 	ldw	r2,-32376(gp)
81102724:	01604574 	movhi	r5,33045
81102728:	294be504 	addi	r5,r5,12180
8110272c:	1009883a 	mov	r4,r2
81102730:	1120fa40 	call	81120fa4 <fprintf>
#endif
			uliNextMilestone += uliByteLen / 20;
81102734:	e0fff117 	ldw	r3,-60(fp)
81102738:	00b33374 	movhi	r2,52429
8110273c:	10b33344 	addi	r2,r2,-13107
81102740:	1888383a 	mulxuu	r4,r3,r2
81102744:	1885383a 	mul	r2,r3,r2
81102748:	1021883a 	mov	r16,r2
8110274c:	2023883a 	mov	r17,r4
81102750:	8804d13a 	srli	r2,r17,4
81102754:	e0fff317 	ldw	r3,-52(fp)
81102758:	1885883a 	add	r2,r3,r2
8110275c:	e0bff315 	stw	r2,-52(fp)
			ucPercentage += 5;
81102760:	e0bff403 	ldbu	r2,-48(fp)
81102764:	10800144 	addi	r2,r2,5
81102768:	e0bff405 	stb	r2,-48(fp)

	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliSource = (alt_u32*) uliDdr2Base;
			(alt_u32) puliSource < uliMemoryEndAddress; puliSource++) {
8110276c:	e0bff217 	ldw	r2,-56(fp)
81102770:	10800104 	addi	r2,r2,4
81102774:	e0bff215 	stw	r2,-56(fp)
81102778:	e0fff217 	ldw	r3,-56(fp)
	}

	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliSource = (alt_u32*) uliDdr2Base;
8110277c:	e0bff517 	ldw	r2,-44(fp)
81102780:	18bfc336 	bltu	r3,r2,81102690 <__reset+0xfb0e2690>
#endif
			uliNextMilestone += uliByteLen / 20;
			ucPercentage += 5;
		}
	}
	if (bVerbose == DDR2_VERBOSE) {
81102784:	e0bffa17 	ldw	r2,-24(fp)
81102788:	10800058 	cmpnei	r2,r2,1
8110278c:	10000a1e 	bne	r2,zero,811027b8 <bDdr2MemoryRandomReadTest+0x340>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "..100%%\n");
81102790:	01604574 	movhi	r5,33045
81102794:	296e1d04 	addi	r5,r5,-18316
81102798:	01204574 	movhi	r4,33045
8110279c:	210be504 	addi	r4,r4,12180
811027a0:	11229340 	call	81122934 <sprintf>
		debug(fp, cDebugBuffer);
811027a4:	d0a06217 	ldw	r2,-32376(gp)
811027a8:	01604574 	movhi	r5,33045
811027ac:	294be504 	addi	r5,r5,12180
811027b0:	1009883a 	mov	r4,r2
811027b4:	1120fa40 	call	81120fa4 <fprintf>
#endif
	}

	if (bSuccess) {
811027b8:	e0bfef17 	ldw	r2,-68(fp)
811027bc:	10003126 	beq	r2,zero,81102884 <bDdr2MemoryRandomReadTest+0x40c>
		if (bTime == TRUE) {
811027c0:	e0bffb17 	ldw	r2,-20(fp)
811027c4:	10800058 	cmpnei	r2,r2,1
811027c8:	1000221e 	bne	r2,zero,81102854 <bDdr2MemoryRandomReadTest+0x3dc>
811027cc:	d0e08917 	ldw	r3,-32220(gp)
			TimeElapsed = alt_nticks() - TimeStart;
811027d0:	e0bff717 	ldw	r2,-36(fp)
811027d4:	1885c83a 	sub	r2,r3,r2
811027d8:	e0bff615 	stw	r2,-40(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
					"DDR2 read test pass, size=%lu bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
811027dc:	e13ff617 	ldw	r4,-40(fp)
811027e0:	111f69c0 	call	8111f69c <__floatsisf>
811027e4:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
811027e8:	d0a08817 	ldw	r2,-32224(gp)
811027ec:	1009883a 	mov	r4,r2
811027f0:	111f7c80 	call	8111f7c8 <__floatunsisf>
811027f4:	1007883a 	mov	r3,r2
811027f8:	180b883a 	mov	r5,r3
811027fc:	8009883a 	mov	r4,r16
81102800:	111ee500 	call	8111ee50 <__divsf3>
81102804:	1007883a 	mov	r3,r2
81102808:	1805883a 	mov	r2,r3

	if (bSuccess) {
		if (bTime == TRUE) {
			TimeElapsed = alt_nticks() - TimeStart;
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
8110280c:	1009883a 	mov	r4,r2
81102810:	1120b240 	call	81120b24 <__extendsfdf2>
81102814:	1009883a 	mov	r4,r2
81102818:	180b883a 	mov	r5,r3
8110281c:	d9400015 	stw	r5,0(sp)
81102820:	200f883a 	mov	r7,r4
81102824:	e1bff117 	ldw	r6,-60(fp)
81102828:	01604574 	movhi	r5,33045
8110282c:	296e5004 	addi	r5,r5,-18112
81102830:	01204574 	movhi	r4,33045
81102834:	210be504 	addi	r4,r4,12180
81102838:	11229340 	call	81122934 <sprintf>
					"DDR2 read test pass, size=%lu bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
			debug(fp, cDebugBuffer);
8110283c:	d0a06217 	ldw	r2,-32376(gp)
81102840:	01604574 	movhi	r5,33045
81102844:	294be504 	addi	r5,r5,12180
81102848:	1009883a 	mov	r4,r2
8110284c:	1120fa40 	call	81120fa4 <fprintf>
81102850:	00001b06 	br	811028c0 <bDdr2MemoryRandomReadTest+0x448>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "DDR2 read test pass, size=%lu bytes\n",
81102854:	e1bff117 	ldw	r6,-60(fp)
81102858:	01604574 	movhi	r5,33045
8110285c:	296e5c04 	addi	r5,r5,-18064
81102860:	01204574 	movhi	r4,33045
81102864:	210be504 	addi	r4,r4,12180
81102868:	11229340 	call	81122934 <sprintf>
					uliByteLen);
			debug(fp, cDebugBuffer);
8110286c:	d0a06217 	ldw	r2,-32376(gp)
81102870:	01604574 	movhi	r5,33045
81102874:	294be504 	addi	r5,r5,12180
81102878:	1009883a 	mov	r4,r2
8110287c:	1120fa40 	call	81120fa4 <fprintf>
81102880:	00000f06 	br	811028c0 <bDdr2MemoryRandomReadTest+0x448>
#endif
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test fail\n");
81102884:	00e04574 	movhi	r3,33045
81102888:	18cbe504 	addi	r3,r3,12180
8110288c:	00a04574 	movhi	r2,33045
81102890:	10ae0004 	addi	r2,r2,-18432
81102894:	1009883a 	mov	r4,r2
81102898:	00800544 	movi	r2,21
8110289c:	100d883a 	mov	r6,r2
811028a0:	200b883a 	mov	r5,r4
811028a4:	1809883a 	mov	r4,r3
811028a8:	11220540 	call	81122054 <memcpy>
		debug(fp, cDebugBuffer);
811028ac:	d0a06217 	ldw	r2,-32376(gp)
811028b0:	01604574 	movhi	r5,33045
811028b4:	294be504 	addi	r5,r5,12180
811028b8:	1009883a 	mov	r4,r2
811028bc:	1120fa40 	call	81120fa4 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811028c0:	00a04574 	movhi	r2,33045
811028c4:	108be504 	addi	r2,r2,12180
811028c8:	00c00284 	movi	r3,10
811028cc:	10c00005 	stb	r3,0(r2)
811028d0:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811028d4:	d0a06217 	ldw	r2,-32376(gp)
811028d8:	01604574 	movhi	r5,33045
811028dc:	294be504 	addi	r5,r5,12180
811028e0:	1009883a 	mov	r4,r2
811028e4:	1120fa40 	call	81120fa4 <fprintf>
#endif

	return bSuccess;
811028e8:	e0bfef17 	ldw	r2,-68(fp)
}
811028ec:	e6fffc04 	addi	sp,fp,-16
811028f0:	dfc00517 	ldw	ra,20(sp)
811028f4:	df000417 	ldw	fp,16(sp)
811028f8:	dcc00317 	ldw	r19,12(sp)
811028fc:	dc800217 	ldw	r18,8(sp)
81102900:	dc400117 	ldw	r17,4(sp)
81102904:	dc000017 	ldw	r16,0(sp)
81102908:	dec00604 	addi	sp,sp,24
8110290c:	f800283a 	ret

81102910 <uliXorshift32>:
 * @param [in] bDRIVE  Estado atual do RNG
 *
 * @retval Nmero aleatrio resultate do RNG
 *
 */
alt_u32 uliXorshift32(alt_u32 *puliState) {
81102910:	defffd04 	addi	sp,sp,-12
81102914:	de00012e 	bgeu	sp,et,8110291c <uliXorshift32+0xc>
81102918:	003b68fa 	trap	3
8110291c:	df000215 	stw	fp,8(sp)
81102920:	df000204 	addi	fp,sp,8
81102924:	e13fff15 	stw	r4,-4(fp)

	alt_u32 uliX = *puliState;
81102928:	e0bfff17 	ldw	r2,-4(fp)
8110292c:	10800017 	ldw	r2,0(r2)
81102930:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX << 13;
81102934:	e0bffe17 	ldw	r2,-8(fp)
81102938:	1004937a 	slli	r2,r2,13
8110293c:	e0fffe17 	ldw	r3,-8(fp)
81102940:	1884f03a 	xor	r2,r3,r2
81102944:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX >> 17;
81102948:	e0bffe17 	ldw	r2,-8(fp)
8110294c:	1004d47a 	srli	r2,r2,17
81102950:	e0fffe17 	ldw	r3,-8(fp)
81102954:	1884f03a 	xor	r2,r3,r2
81102958:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX << 5;
8110295c:	e0bffe17 	ldw	r2,-8(fp)
81102960:	1004917a 	slli	r2,r2,5
81102964:	e0fffe17 	ldw	r3,-8(fp)
81102968:	1884f03a 	xor	r2,r3,r2
8110296c:	e0bffe15 	stw	r2,-8(fp)
	*puliState = uliX;
81102970:	e0bfff17 	ldw	r2,-4(fp)
81102974:	e0fffe17 	ldw	r3,-8(fp)
81102978:	10c00015 	stw	r3,0(r2)

	return uliX;
8110297c:	e0bffe17 	ldw	r2,-8(fp)
}
81102980:	e037883a 	mov	sp,fp
81102984:	df000017 	ldw	fp,0(sp)
81102988:	dec00104 	addi	sp,sp,4
8110298c:	f800283a 	ret

81102990 <DMA_OPEN_DEVICE>:
 * @param [in] DmaName  String com o nome do DMA (XXX_CSR_NAME)
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_OPEN_DEVICE(alt_msgdma_dev **DmaDevice, const char* DmaName){
81102990:	defffb04 	addi	sp,sp,-20
81102994:	de00012e 	bgeu	sp,et,8110299c <DMA_OPEN_DEVICE+0xc>
81102998:	003b68fa 	trap	3
8110299c:	dfc00415 	stw	ra,16(sp)
811029a0:	df000315 	stw	fp,12(sp)
811029a4:	df000304 	addi	fp,sp,12
811029a8:	e13ffe15 	stw	r4,-8(fp)
811029ac:	e17fff15 	stw	r5,-4(fp)
  bool bSuccess = TRUE;
811029b0:	00800044 	movi	r2,1
811029b4:	e0bffd15 	stw	r2,-12(fp)
  
  //Open DMA based on name

  *DmaDevice = alt_msgdma_open((char *)DmaName);
811029b8:	e13fff17 	ldw	r4,-4(fp)
811029bc:	11497540 	call	81149754 <alt_msgdma_open>
811029c0:	1007883a 	mov	r3,r2
811029c4:	e0bffe17 	ldw	r2,-8(fp)
811029c8:	10c00015 	stw	r3,0(r2)
  
  //Check if DMA opened correctly;
  if(*DmaDevice == NULL){
811029cc:	e0bffe17 	ldw	r2,-8(fp)
811029d0:	10800017 	ldw	r2,0(r2)
811029d4:	1000011e 	bne	r2,zero,811029dc <DMA_OPEN_DEVICE+0x4c>
    bSuccess = FALSE;
811029d8:	e03ffd15 	stw	zero,-12(fp)
  }
  
  return bSuccess;
811029dc:	e0bffd17 	ldw	r2,-12(fp)
}
811029e0:	e037883a 	mov	sp,fp
811029e4:	dfc00117 	ldw	ra,4(sp)
811029e8:	df000017 	ldw	fp,0(sp)
811029ec:	dec00204 	addi	sp,sp,8
811029f0:	f800283a 	ret

811029f4 <DMA_CONFIG>:
 * @param [in] ConfigMask  Mascara com as configuraes do DMA (overwrite)
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_CONFIG(alt_msgdma_dev *DmaDevice, alt_u32 ConfigMask){
811029f4:	defffc04 	addi	sp,sp,-16
811029f8:	de00012e 	bgeu	sp,et,81102a00 <DMA_CONFIG+0xc>
811029fc:	003b68fa 	trap	3
81102a00:	df000315 	stw	fp,12(sp)
81102a04:	df000304 	addi	fp,sp,12
81102a08:	e13ffe15 	stw	r4,-8(fp)
81102a0c:	e17fff15 	stw	r5,-4(fp)
  bool bSuccess = TRUE;
81102a10:	00800044 	movi	r2,1
81102a14:	e0bffd15 	stw	r2,-12(fp)
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ConfigMask);
81102a18:	e0bffe17 	ldw	r2,-8(fp)
81102a1c:	10800317 	ldw	r2,12(r2)
81102a20:	10800104 	addi	r2,r2,4
81102a24:	e0ffff17 	ldw	r3,-4(fp)
81102a28:	10c00035 	stwio	r3,0(r2)
  return bSuccess;
81102a2c:	e0bffd17 	ldw	r2,-12(fp)
}
81102a30:	e037883a 	mov	sp,fp
81102a34:	df000017 	ldw	fp,0(sp)
81102a38:	dec00104 	addi	sp,sp,4
81102a3c:	f800283a 	ret

81102a40 <DMA_BUSY>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : DMA Ocupado
 *
 */
bool DMA_BUSY(alt_msgdma_dev *DmaDevice){
81102a40:	defffd04 	addi	sp,sp,-12
81102a44:	de00012e 	bgeu	sp,et,81102a4c <DMA_BUSY+0xc>
81102a48:	003b68fa 	trap	3
81102a4c:	df000215 	stw	fp,8(sp)
81102a50:	df000204 	addi	fp,sp,8
81102a54:	e13fff15 	stw	r4,-4(fp)
  bool bBusy = FALSE;
81102a58:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK){
81102a5c:	e0bfff17 	ldw	r2,-4(fp)
81102a60:	10800317 	ldw	r2,12(r2)
81102a64:	10800037 	ldwio	r2,0(r2)
81102a68:	1080004c 	andi	r2,r2,1
81102a6c:	10000226 	beq	r2,zero,81102a78 <DMA_BUSY+0x38>
    bBusy = TRUE;
81102a70:	00800044 	movi	r2,1
81102a74:	e0bffe15 	stw	r2,-8(fp)
  }
  return bBusy;
81102a78:	e0bffe17 	ldw	r2,-8(fp)
}
81102a7c:	e037883a 	mov	sp,fp
81102a80:	df000017 	ldw	fp,0(sp)
81102a84:	dec00104 	addi	sp,sp,4
81102a88:	f800283a 	ret

81102a8c <DMA_DESCRIPTOR_BUFFER_FULL>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : Buffer Cheio
 *
 */
bool DMA_DESCRIPTOR_BUFFER_FULL(alt_msgdma_dev *DmaDevice){
81102a8c:	defffd04 	addi	sp,sp,-12
81102a90:	de00012e 	bgeu	sp,et,81102a98 <DMA_DESCRIPTOR_BUFFER_FULL+0xc>
81102a94:	003b68fa 	trap	3
81102a98:	df000215 	stw	fp,8(sp)
81102a9c:	df000204 	addi	fp,sp,8
81102aa0:	e13fff15 	stw	r4,-4(fp)
  bool bFull = FALSE;
81102aa4:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK){
81102aa8:	e0bfff17 	ldw	r2,-4(fp)
81102aac:	10800317 	ldw	r2,12(r2)
81102ab0:	10800037 	ldwio	r2,0(r2)
81102ab4:	1080010c 	andi	r2,r2,4
81102ab8:	10000226 	beq	r2,zero,81102ac4 <DMA_DESCRIPTOR_BUFFER_FULL+0x38>
    bFull = TRUE;
81102abc:	00800044 	movi	r2,1
81102ac0:	e0bffe15 	stw	r2,-8(fp)
  }
  return bFull;
81102ac4:	e0bffe17 	ldw	r2,-8(fp)
}
81102ac8:	e037883a 	mov	sp,fp
81102acc:	df000017 	ldw	fp,0(sp)
81102ad0:	dec00104 	addi	sp,sp,4
81102ad4:	f800283a 	ret

81102ad8 <DMA_DESCRIPTOR_BUFFER_EMPTY>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : Buffer Vazio
 *
 */
bool DMA_DESCRIPTOR_BUFFER_EMPTY(alt_msgdma_dev *DmaDevice){
81102ad8:	defffd04 	addi	sp,sp,-12
81102adc:	de00012e 	bgeu	sp,et,81102ae4 <DMA_DESCRIPTOR_BUFFER_EMPTY+0xc>
81102ae0:	003b68fa 	trap	3
81102ae4:	df000215 	stw	fp,8(sp)
81102ae8:	df000204 	addi	fp,sp,8
81102aec:	e13fff15 	stw	r4,-4(fp)
  bool bEmpty = FALSE;
81102af0:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_EMPTY_MASK){
81102af4:	e0bfff17 	ldw	r2,-4(fp)
81102af8:	10800317 	ldw	r2,12(r2)
81102afc:	10800037 	ldwio	r2,0(r2)
81102b00:	1080008c 	andi	r2,r2,2
81102b04:	10000226 	beq	r2,zero,81102b10 <DMA_DESCRIPTOR_BUFFER_EMPTY+0x38>
    bEmpty = TRUE;
81102b08:	00800044 	movi	r2,1
81102b0c:	e0bffe15 	stw	r2,-8(fp)
  }
  return bEmpty;
81102b10:	e0bffe17 	ldw	r2,-8(fp)
}
81102b14:	e037883a 	mov	sp,fp
81102b18:	df000017 	ldw	fp,0(sp)
81102b1c:	dec00104 	addi	sp,sp,4
81102b20:	f800283a 	ret

81102b24 <DMA_DISPATCHER_STOP>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_DISPATCHER_STOP(alt_msgdma_dev *DmaDevice, bool bWait, alt_32 WaitPeriodUs){
81102b24:	defffa04 	addi	sp,sp,-24
81102b28:	de00012e 	bgeu	sp,et,81102b30 <DMA_DISPATCHER_STOP+0xc>
81102b2c:	003b68fa 	trap	3
81102b30:	dfc00515 	stw	ra,20(sp)
81102b34:	df000415 	stw	fp,16(sp)
81102b38:	df000404 	addi	fp,sp,16
81102b3c:	e13ffd15 	stw	r4,-12(fp)
81102b40:	e17ffe15 	stw	r5,-8(fp)
81102b44:	e1bfff15 	stw	r6,-4(fp)
  bool bSuccess = TRUE;
81102b48:	00800044 	movi	r2,1
81102b4c:	e0bffc15 	stw	r2,-16(fp)
  
  //Send stop command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_STOP_MASK);
81102b50:	e0bffd17 	ldw	r2,-12(fp)
81102b54:	10800317 	ldw	r2,12(r2)
81102b58:	10800104 	addi	r2,r2,4
81102b5c:	00c00044 	movi	r3,1
81102b60:	10c00035 	stwio	r3,0(r2)
  
  if (bWait == DMA_WAIT) {
81102b64:	e0bffe17 	ldw	r2,-8(fp)
81102b68:	10800058 	cmpnei	r2,r2,1
81102b6c:	10000f1e 	bne	r2,zero,81102bac <DMA_DISPATCHER_STOP+0x88>
    //Wait stop to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_STOP_STATE_MASK) {
81102b70:	00000806 	br	81102b94 <DMA_DISPATCHER_STOP+0x70>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102b74:	e0bfff17 	ldw	r2,-4(fp)
81102b78:	1000031e 	bne	r2,zero,81102b88 <DMA_DISPATCHER_STOP+0x64>
        usleep(1);
81102b7c:	01000044 	movi	r4,1
81102b80:	11376bc0 	call	811376bc <usleep>
81102b84:	00000306 	br	81102b94 <DMA_DISPATCHER_STOP+0x70>
      } else {
        usleep(WaitPeriodUs);
81102b88:	e0bfff17 	ldw	r2,-4(fp)
81102b8c:	1009883a 	mov	r4,r2
81102b90:	11376bc0 	call	811376bc <usleep>
  //Send stop command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_STOP_MASK);
  
  if (bWait == DMA_WAIT) {
    //Wait stop to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_STOP_STATE_MASK) {
81102b94:	e0bffd17 	ldw	r2,-12(fp)
81102b98:	10800317 	ldw	r2,12(r2)
81102b9c:	10800037 	ldwio	r2,0(r2)
81102ba0:	1080080c 	andi	r2,r2,32
81102ba4:	103ff31e 	bne	r2,zero,81102b74 <__reset+0xfb0e2b74>
81102ba8:	00000206 	br	81102bb4 <DMA_DISPATCHER_STOP+0x90>
      } else {
        usleep(WaitPeriodUs);
      }
    }
  } else {
    return bSuccess;
81102bac:	e0bffc17 	ldw	r2,-16(fp)
81102bb0:	00000106 	br	81102bb8 <DMA_DISPATCHER_STOP+0x94>
  }
  
  return bSuccess;
81102bb4:	e0bffc17 	ldw	r2,-16(fp)
}
81102bb8:	e037883a 	mov	sp,fp
81102bbc:	dfc00117 	ldw	ra,4(sp)
81102bc0:	df000017 	ldw	fp,0(sp)
81102bc4:	dec00204 	addi	sp,sp,8
81102bc8:	f800283a 	ret

81102bcc <DMA_DISPATCHER_RESET>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_DISPATCHER_RESET(alt_msgdma_dev *DmaDevice, bool bWait, alt_32 WaitPeriodUs){
81102bcc:	defffa04 	addi	sp,sp,-24
81102bd0:	de00012e 	bgeu	sp,et,81102bd8 <DMA_DISPATCHER_RESET+0xc>
81102bd4:	003b68fa 	trap	3
81102bd8:	dfc00515 	stw	ra,20(sp)
81102bdc:	df000415 	stw	fp,16(sp)
81102be0:	df000404 	addi	fp,sp,16
81102be4:	e13ffd15 	stw	r4,-12(fp)
81102be8:	e17ffe15 	stw	r5,-8(fp)
81102bec:	e1bfff15 	stw	r6,-4(fp)
  bool bSuccess = TRUE;
81102bf0:	00800044 	movi	r2,1
81102bf4:	e0bffc15 	stw	r2,-16(fp)
  
  //Send reset command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
81102bf8:	e0bffd17 	ldw	r2,-12(fp)
81102bfc:	10800317 	ldw	r2,12(r2)
81102c00:	10800104 	addi	r2,r2,4
81102c04:	00c00084 	movi	r3,2
81102c08:	10c00035 	stwio	r3,0(r2)
  
  if (bWait == DMA_WAIT) {
81102c0c:	e0bffe17 	ldw	r2,-8(fp)
81102c10:	10800058 	cmpnei	r2,r2,1
81102c14:	10000f1e 	bne	r2,zero,81102c54 <DMA_DISPATCHER_RESET+0x88>
    //Wait reset to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81102c18:	00000806 	br	81102c3c <DMA_DISPATCHER_RESET+0x70>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102c1c:	e0bfff17 	ldw	r2,-4(fp)
81102c20:	1000031e 	bne	r2,zero,81102c30 <DMA_DISPATCHER_RESET+0x64>
        usleep(1);
81102c24:	01000044 	movi	r4,1
81102c28:	11376bc0 	call	811376bc <usleep>
81102c2c:	00000306 	br	81102c3c <DMA_DISPATCHER_RESET+0x70>
      } else {
        usleep(WaitPeriodUs);
81102c30:	e0bfff17 	ldw	r2,-4(fp)
81102c34:	1009883a 	mov	r4,r2
81102c38:	11376bc0 	call	811376bc <usleep>
  //Send reset command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
  
  if (bWait == DMA_WAIT) {
    //Wait reset to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81102c3c:	e0bffd17 	ldw	r2,-12(fp)
81102c40:	10800317 	ldw	r2,12(r2)
81102c44:	10800037 	ldwio	r2,0(r2)
81102c48:	1080100c 	andi	r2,r2,64
81102c4c:	103ff31e 	bne	r2,zero,81102c1c <__reset+0xfb0e2c1c>
81102c50:	00000206 	br	81102c5c <DMA_DISPATCHER_RESET+0x90>
      } else {
        usleep(WaitPeriodUs);
      }
    }
  } else {
    return bSuccess;
81102c54:	e0bffc17 	ldw	r2,-16(fp)
81102c58:	00000106 	br	81102c60 <DMA_DISPATCHER_RESET+0x94>
  }
  
  return bSuccess;
81102c5c:	e0bffc17 	ldw	r2,-16(fp)
}
81102c60:	e037883a 	mov	sp,fp
81102c64:	dfc00117 	ldw	ra,4(sp)
81102c68:	df000017 	ldw	fp,0(sp)
81102c6c:	dec00204 	addi	sp,sp,8
81102c70:	f800283a 	ret

81102c74 <DMA_SINGLE_TRANSFER>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_SINGLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddress, alt_u32 DestinationAddress, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
81102c74:	defff604 	addi	sp,sp,-40
81102c78:	de00012e 	bgeu	sp,et,81102c80 <DMA_SINGLE_TRANSFER+0xc>
81102c7c:	003b68fa 	trap	3
81102c80:	dfc00915 	stw	ra,36(sp)
81102c84:	df000815 	stw	fp,32(sp)
81102c88:	dc000715 	stw	r16,28(sp)
81102c8c:	df000804 	addi	fp,sp,32
81102c90:	e13ffb15 	stw	r4,-20(fp)
81102c94:	e17ffc15 	stw	r5,-16(fp)
81102c98:	e1bffd15 	stw	r6,-12(fp)
81102c9c:	e1fffe15 	stw	r7,-8(fp)
81102ca0:	defff804 	addi	sp,sp,-32
81102ca4:	d8800204 	addi	r2,sp,8
81102ca8:	108003c4 	addi	r2,r2,15
81102cac:	1004d13a 	srli	r2,r2,4
81102cb0:	1020913a 	slli	r16,r2,4
  bool bSuccess = TRUE;
81102cb4:	00800044 	movi	r2,1
81102cb8:	e0bffa15 	stw	r2,-24(fp)
  alt_msgdma_standard_descriptor DmaDescriptor;

  if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddress, (alt_u32 *)DestinationAddress, TransferSize, ControlBits) != 0){
81102cbc:	e0fffc17 	ldw	r3,-16(fp)
81102cc0:	e13ffd17 	ldw	r4,-12(fp)
81102cc4:	e0800217 	ldw	r2,8(fp)
81102cc8:	d8800115 	stw	r2,4(sp)
81102ccc:	e0bffe17 	ldw	r2,-8(fp)
81102cd0:	d8800015 	stw	r2,0(sp)
81102cd4:	200f883a 	mov	r7,r4
81102cd8:	180d883a 	mov	r6,r3
81102cdc:	800b883a 	mov	r5,r16
81102ce0:	e13ffb17 	ldw	r4,-20(fp)
81102ce4:	11487500 	call	81148750 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102ce8:	10000326 	beq	r2,zero,81102cf8 <DMA_SINGLE_TRANSFER+0x84>
    bSuccess = FALSE;
81102cec:	e03ffa15 	stw	zero,-24(fp)
    return bSuccess;
81102cf0:	e0bffa17 	ldw	r2,-24(fp)
81102cf4:	00001e06 	br	81102d70 <DMA_SINGLE_TRANSFER+0xfc>
  } else {
    if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102cf8:	800b883a 	mov	r5,r16
81102cfc:	e13ffb17 	ldw	r4,-20(fp)
81102d00:	11499c40 	call	811499c4 <alt_msgdma_standard_descriptor_async_transfer>
81102d04:	10000326 	beq	r2,zero,81102d14 <DMA_SINGLE_TRANSFER+0xa0>
      bSuccess = FALSE;
81102d08:	e03ffa15 	stw	zero,-24(fp)
      return bSuccess;
81102d0c:	e0bffa17 	ldw	r2,-24(fp)
81102d10:	00001706 	br	81102d70 <DMA_SINGLE_TRANSFER+0xfc>
    }
  }
  
  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
81102d14:	e0bffa17 	ldw	r2,-24(fp)
81102d18:	10800060 	cmpeqi	r2,r2,1
81102d1c:	1007883a 	mov	r3,r2
81102d20:	e0800317 	ldw	r2,12(fp)
81102d24:	10800060 	cmpeqi	r2,r2,1
81102d28:	1884703a 	and	r2,r3,r2
81102d2c:	10803fcc 	andi	r2,r2,255
81102d30:	10000e26 	beq	r2,zero,81102d6c <DMA_SINGLE_TRANSFER+0xf8>
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102d34:	00000806 	br	81102d58 <DMA_SINGLE_TRANSFER+0xe4>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102d38:	e0800417 	ldw	r2,16(fp)
81102d3c:	1000031e 	bne	r2,zero,81102d4c <DMA_SINGLE_TRANSFER+0xd8>
        usleep(1000);
81102d40:	0100fa04 	movi	r4,1000
81102d44:	11376bc0 	call	811376bc <usleep>
81102d48:	00000306 	br	81102d58 <DMA_SINGLE_TRANSFER+0xe4>
      } else {
        usleep(WaitPeriodUs);
81102d4c:	e0800417 	ldw	r2,16(fp)
81102d50:	1009883a 	mov	r4,r2
81102d54:	11376bc0 	call	811376bc <usleep>
      return bSuccess;
    }
  }
  
  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102d58:	e0bffb17 	ldw	r2,-20(fp)
81102d5c:	10800317 	ldw	r2,12(r2)
81102d60:	10800037 	ldwio	r2,0(r2)
81102d64:	1080004c 	andi	r2,r2,1
81102d68:	103ff31e 	bne	r2,zero,81102d38 <__reset+0xfb0e2d38>
        usleep(WaitPeriodUs);
      }
    }
  }
  
  return bSuccess;
81102d6c:	e0bffa17 	ldw	r2,-24(fp)
}
81102d70:	e6ffff04 	addi	sp,fp,-4
81102d74:	dfc00217 	ldw	ra,8(sp)
81102d78:	df000117 	ldw	fp,4(sp)
81102d7c:	dc000017 	ldw	r16,0(sp)
81102d80:	dec00304 	addi	sp,sp,12
81102d84:	f800283a 	ret

81102d88 <DMA_MULTIPLE_TRANSFER>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_MULTIPLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddressArray[], alt_u32 DestinationAddressArray[], alt_u8 TransferNumber, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
81102d88:	defff504 	addi	sp,sp,-44
81102d8c:	de00012e 	bgeu	sp,et,81102d94 <DMA_MULTIPLE_TRANSFER+0xc>
81102d90:	003b68fa 	trap	3
81102d94:	dfc00a15 	stw	ra,40(sp)
81102d98:	df000915 	stw	fp,36(sp)
81102d9c:	dc000815 	stw	r16,32(sp)
81102da0:	df000904 	addi	fp,sp,36
81102da4:	e13ffb15 	stw	r4,-20(fp)
81102da8:	e17ffc15 	stw	r5,-16(fp)
81102dac:	e1bffd15 	stw	r6,-12(fp)
81102db0:	3805883a 	mov	r2,r7
81102db4:	e0bffe05 	stb	r2,-8(fp)
81102db8:	defff804 	addi	sp,sp,-32
81102dbc:	d8800204 	addi	r2,sp,8
81102dc0:	108003c4 	addi	r2,r2,15
81102dc4:	1004d13a 	srli	r2,r2,4
81102dc8:	1020913a 	slli	r16,r2,4
  bool bSuccess = TRUE;
81102dcc:	00800044 	movi	r2,1
81102dd0:	e0bff915 	stw	r2,-28(fp)
  alt_msgdma_standard_descriptor DmaDescriptor;
  alt_u8 i = 0;
81102dd4:	e03ffa05 	stb	zero,-24(fp)

  while ((bSuccess == TRUE) & (i < (TransferNumber - 1))){
81102dd8:	00002506 	br	81102e70 <DMA_MULTIPLE_TRANSFER+0xe8>
    if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddressArray[i], (alt_u32 *)DestinationAddressArray[i], TransferSize, (ControlBits | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_EARLY_DONE_ENABLE_MASK)) != 0){
81102ddc:	e0bffa03 	ldbu	r2,-24(fp)
81102de0:	1085883a 	add	r2,r2,r2
81102de4:	1085883a 	add	r2,r2,r2
81102de8:	1007883a 	mov	r3,r2
81102dec:	e0bffc17 	ldw	r2,-16(fp)
81102df0:	10c5883a 	add	r2,r2,r3
81102df4:	10800017 	ldw	r2,0(r2)
81102df8:	1009883a 	mov	r4,r2
81102dfc:	e0bffa03 	ldbu	r2,-24(fp)
81102e00:	1085883a 	add	r2,r2,r2
81102e04:	1085883a 	add	r2,r2,r2
81102e08:	1007883a 	mov	r3,r2
81102e0c:	e0bffd17 	ldw	r2,-12(fp)
81102e10:	10c5883a 	add	r2,r2,r3
81102e14:	10800017 	ldw	r2,0(r2)
81102e18:	1007883a 	mov	r3,r2
81102e1c:	e0800317 	ldw	r2,12(fp)
81102e20:	10804034 	orhi	r2,r2,256
81102e24:	d8800115 	stw	r2,4(sp)
81102e28:	e0800217 	ldw	r2,8(fp)
81102e2c:	d8800015 	stw	r2,0(sp)
81102e30:	180f883a 	mov	r7,r3
81102e34:	200d883a 	mov	r6,r4
81102e38:	800b883a 	mov	r5,r16
81102e3c:	e13ffb17 	ldw	r4,-20(fp)
81102e40:	11487500 	call	81148750 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102e44:	10000226 	beq	r2,zero,81102e50 <DMA_MULTIPLE_TRANSFER+0xc8>
      bSuccess = FALSE;
81102e48:	e03ff915 	stw	zero,-28(fp)
81102e4c:	00000506 	br	81102e64 <DMA_MULTIPLE_TRANSFER+0xdc>
    } else {
      if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102e50:	800b883a 	mov	r5,r16
81102e54:	e13ffb17 	ldw	r4,-20(fp)
81102e58:	11499c40 	call	811499c4 <alt_msgdma_standard_descriptor_async_transfer>
81102e5c:	10000126 	beq	r2,zero,81102e64 <DMA_MULTIPLE_TRANSFER+0xdc>
        bSuccess = FALSE;
81102e60:	e03ff915 	stw	zero,-28(fp)
      }
    }
	i++;
81102e64:	e0bffa03 	ldbu	r2,-24(fp)
81102e68:	10800044 	addi	r2,r2,1
81102e6c:	e0bffa05 	stb	r2,-24(fp)
bool DMA_MULTIPLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddressArray[], alt_u32 DestinationAddressArray[], alt_u8 TransferNumber, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
  bool bSuccess = TRUE;
  alt_msgdma_standard_descriptor DmaDescriptor;
  alt_u8 i = 0;

  while ((bSuccess == TRUE) & (i < (TransferNumber - 1))){
81102e70:	e0bff917 	ldw	r2,-28(fp)
81102e74:	10800060 	cmpeqi	r2,r2,1
81102e78:	1009883a 	mov	r4,r2
81102e7c:	e0fffa03 	ldbu	r3,-24(fp)
81102e80:	e0bffe03 	ldbu	r2,-8(fp)
81102e84:	10bfffc4 	addi	r2,r2,-1
81102e88:	1884803a 	cmplt	r2,r3,r2
81102e8c:	2084703a 	and	r2,r4,r2
81102e90:	10803fcc 	andi	r2,r2,255
81102e94:	103fd11e 	bne	r2,zero,81102ddc <__reset+0xfb0e2ddc>
        bSuccess = FALSE;
      }
    }
	i++;
  }
  if (bSuccess == TRUE){
81102e98:	e0bff917 	ldw	r2,-28(fp)
81102e9c:	10800058 	cmpnei	r2,r2,1
81102ea0:	1000211e 	bne	r2,zero,81102f28 <DMA_MULTIPLE_TRANSFER+0x1a0>
    if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddressArray[i], (alt_u32 *)DestinationAddressArray[i], TransferSize, ControlBits) != 0){
81102ea4:	e0bffa03 	ldbu	r2,-24(fp)
81102ea8:	1085883a 	add	r2,r2,r2
81102eac:	1085883a 	add	r2,r2,r2
81102eb0:	1007883a 	mov	r3,r2
81102eb4:	e0bffc17 	ldw	r2,-16(fp)
81102eb8:	10c5883a 	add	r2,r2,r3
81102ebc:	10800017 	ldw	r2,0(r2)
81102ec0:	1009883a 	mov	r4,r2
81102ec4:	e0bffa03 	ldbu	r2,-24(fp)
81102ec8:	1085883a 	add	r2,r2,r2
81102ecc:	1085883a 	add	r2,r2,r2
81102ed0:	1007883a 	mov	r3,r2
81102ed4:	e0bffd17 	ldw	r2,-12(fp)
81102ed8:	10c5883a 	add	r2,r2,r3
81102edc:	10800017 	ldw	r2,0(r2)
81102ee0:	1007883a 	mov	r3,r2
81102ee4:	e0800317 	ldw	r2,12(fp)
81102ee8:	d8800115 	stw	r2,4(sp)
81102eec:	e0800217 	ldw	r2,8(fp)
81102ef0:	d8800015 	stw	r2,0(sp)
81102ef4:	180f883a 	mov	r7,r3
81102ef8:	200d883a 	mov	r6,r4
81102efc:	800b883a 	mov	r5,r16
81102f00:	e13ffb17 	ldw	r4,-20(fp)
81102f04:	11487500 	call	81148750 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102f08:	10000226 	beq	r2,zero,81102f14 <DMA_MULTIPLE_TRANSFER+0x18c>
      bSuccess = FALSE;
81102f0c:	e03ff915 	stw	zero,-28(fp)
81102f10:	00000506 	br	81102f28 <DMA_MULTIPLE_TRANSFER+0x1a0>
    } else {
      if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102f14:	800b883a 	mov	r5,r16
81102f18:	e13ffb17 	ldw	r4,-20(fp)
81102f1c:	11499c40 	call	811499c4 <alt_msgdma_standard_descriptor_async_transfer>
81102f20:	10000126 	beq	r2,zero,81102f28 <DMA_MULTIPLE_TRANSFER+0x1a0>
        bSuccess = FALSE;
81102f24:	e03ff915 	stw	zero,-28(fp)
      }
    }
  }

  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
81102f28:	e0bff917 	ldw	r2,-28(fp)
81102f2c:	10800060 	cmpeqi	r2,r2,1
81102f30:	1007883a 	mov	r3,r2
81102f34:	e0800417 	ldw	r2,16(fp)
81102f38:	10800060 	cmpeqi	r2,r2,1
81102f3c:	1884703a 	and	r2,r3,r2
81102f40:	10803fcc 	andi	r2,r2,255
81102f44:	10000e26 	beq	r2,zero,81102f80 <DMA_MULTIPLE_TRANSFER+0x1f8>
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102f48:	00000806 	br	81102f6c <DMA_MULTIPLE_TRANSFER+0x1e4>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102f4c:	e0800517 	ldw	r2,20(fp)
81102f50:	1000031e 	bne	r2,zero,81102f60 <DMA_MULTIPLE_TRANSFER+0x1d8>
    	usleep(1000);
81102f54:	0100fa04 	movi	r4,1000
81102f58:	11376bc0 	call	811376bc <usleep>
81102f5c:	00000306 	br	81102f6c <DMA_MULTIPLE_TRANSFER+0x1e4>
      } else {
    	usleep(WaitPeriodUs);
81102f60:	e0800517 	ldw	r2,20(fp)
81102f64:	1009883a 	mov	r4,r2
81102f68:	11376bc0 	call	811376bc <usleep>
      }
    }
  }

  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102f6c:	e0bffb17 	ldw	r2,-20(fp)
81102f70:	10800317 	ldw	r2,12(r2)
81102f74:	10800037 	ldwio	r2,0(r2)
81102f78:	1080004c 	andi	r2,r2,1
81102f7c:	103ff31e 	bne	r2,zero,81102f4c <__reset+0xfb0e2f4c>
    	usleep(WaitPeriodUs);
      }
    }
  }
  
  return bSuccess;
81102f80:	e0bff917 	ldw	r2,-28(fp)
}
81102f84:	e6ffff04 	addi	sp,fp,-4
81102f88:	dfc00217 	ldw	ra,8(sp)
81102f8c:	df000117 	ldw	fp,4(sp)
81102f90:	dc000017 	ldw	r16,0(sp)
81102f94:	dec00304 	addi	sp,sp,12
81102f98:	f800283a 	ret

81102f9c <POWER_Read>:

#ifdef DEBUG_ON
char cDebugBuffer[256];
#endif

bool POWER_Read(alt_u32 szVol[POWER_PORT_NUM]) {
81102f9c:	deffef04 	addi	sp,sp,-68
81102fa0:	de00012e 	bgeu	sp,et,81102fa8 <POWER_Read+0xc>
81102fa4:	003b68fa 	trap	3
81102fa8:	dfc01015 	stw	ra,64(sp)
81102fac:	df000f15 	stw	fp,60(sp)
81102fb0:	df000f04 	addi	fp,sp,60
81102fb4:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess = TRUE;
81102fb8:	00800044 	movi	r2,1
81102fbc:	e0bff315 	stw	r2,-52(fp)
	int i, c, nPortIndex = 0;
81102fc0:	e03ff615 	stw	zero,-40(fp)
	int szPortNum[] = { POWER_DEVICE0_PORT_NUM, POWER_DEVICE1_PORT_NUM };
81102fc4:	00800204 	movi	r2,8
81102fc8:	e0bffc15 	stw	r2,-16(fp)
81102fcc:	00800104 	movi	r2,4
81102fd0:	e0bffd15 	stw	r2,-12(fp)
	alt_u32 Value32;
	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL, PARITY;
	const bool bEN = TRUE; // alwasy update next conversion channel
81102fd4:	00800044 	movi	r2,1
81102fd8:	e0bff715 	stw	r2,-36(fp)
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
81102fdc:	00800044 	movi	r2,1
81102fe0:	e0bff815 	stw	r2,-32(fp)
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
81102fe4:	e03ff915 	stw	zero,-28(fp)
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
81102fe8:	e03ff515 	stw	zero,-44(fp)
81102fec:	00009206 	br	81103238 <POWER_Read+0x29c>
		NextChannel = 0;
81102ff0:	e03ffa05 	stb	zero,-24(fp)
		bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
81102ff4:	e0bff517 	ldw	r2,-44(fp)
81102ff8:	10c03fcc 	andi	r3,r2,255
81102ffc:	e13ffa03 	ldbu	r4,-24(fp)
81103000:	e0bfff17 	ldw	r2,-4(fp)
81103004:	d8800115 	stw	r2,4(sp)
81103008:	e0bff917 	ldw	r2,-28(fp)
8110300c:	d8800015 	stw	r2,0(sp)
81103010:	e1fff817 	ldw	r7,-32(fp)
81103014:	e1bff717 	ldw	r6,-36(fp)
81103018:	200b883a 	mov	r5,r4
8110301c:	1809883a 	mov	r4,r3
81103020:	110be840 	call	8110be84 <POWER_SPI_RW>
81103024:	e0bff315 	stw	r2,-52(fp)
		for (i = 0; i < szPortNum[c] && bSuccess; i++) {
81103028:	e03ff415 	stw	zero,-48(fp)
8110302c:	00007406 	br	81103200 <POWER_Read+0x264>
			NextChannel = i + 1;
81103030:	e0bff417 	ldw	r2,-48(fp)
81103034:	10800044 	addi	r2,r2,1
81103038:	e0bffa05 	stb	r2,-24(fp)
			bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &Value32);
8110303c:	e0bff517 	ldw	r2,-44(fp)
81103040:	10c03fcc 	andi	r3,r2,255
81103044:	e13ffa03 	ldbu	r4,-24(fp)
81103048:	e0bffe04 	addi	r2,fp,-8
8110304c:	d8800115 	stw	r2,4(sp)
81103050:	e0bff917 	ldw	r2,-28(fp)
81103054:	d8800015 	stw	r2,0(sp)
81103058:	e1fff817 	ldw	r7,-32(fp)
8110305c:	e1bff717 	ldw	r6,-36(fp)
81103060:	200b883a 	mov	r5,r4
81103064:	1809883a 	mov	r4,r3
81103068:	110be840 	call	8110be84 <POWER_SPI_RW>
8110306c:	e0bff315 	stw	r2,-52(fp)
			if (bSuccess) {
81103070:	e0bff317 	ldw	r2,-52(fp)
81103074:	10005026 	beq	r2,zero,811031b8 <POWER_Read+0x21c>
				HEAD = (Value32 >> 30) & 0x03;
81103078:	e0bffe17 	ldw	r2,-8(fp)
8110307c:	1004d7ba 	srli	r2,r2,30
81103080:	e0bffa45 	stb	r2,-23(fp)
				Channel = (Value32 >> 1) & 0x07;
81103084:	e0bffe17 	ldw	r2,-8(fp)
81103088:	1004d07a 	srli	r2,r2,1
8110308c:	108001cc 	andi	r2,r2,7
81103090:	e0bffa85 	stb	r2,-22(fp)
				SIGN = (Value32 >> 4) & 0x01;
81103094:	e0bffe17 	ldw	r2,-8(fp)
81103098:	1004d13a 	srli	r2,r2,4
8110309c:	1080004c 	andi	r2,r2,1
811030a0:	e0bffac5 	stb	r2,-21(fp)
				SGL = (Value32 >> 5) & 0x01;
811030a4:	e0bffe17 	ldw	r2,-8(fp)
811030a8:	1004d17a 	srli	r2,r2,5
811030ac:	1080004c 	andi	r2,r2,1
811030b0:	e0bffb05 	stb	r2,-20(fp)
				PARITY = Value32 & 0x01;
811030b4:	e0bffe17 	ldw	r2,-8(fp)
811030b8:	1080004c 	andi	r2,r2,1
811030bc:	e0bffb45 	stb	r2,-19(fp)
				if (HEAD != 0) {
811030c0:	e0bffa43 	ldbu	r2,-23(fp)
811030c4:	10000d26 	beq	r2,zero,811030fc <POWER_Read+0x160>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer, "[%d]Unexpected HEAD\r\n", i);
811030c8:	e1bff417 	ldw	r6,-48(fp)
811030cc:	01604574 	movhi	r5,33045
811030d0:	296e6604 	addi	r5,r5,-18024
811030d4:	01204574 	movhi	r4,33045
811030d8:	210be504 	addi	r4,r4,12180
811030dc:	11229340 	call	81122934 <sprintf>
					debug(fp, cDebugBuffer);
811030e0:	d0a06217 	ldw	r2,-32376(gp)
811030e4:	01604574 	movhi	r5,33045
811030e8:	294be504 	addi	r5,r5,12180
811030ec:	1009883a 	mov	r4,r2
811030f0:	1120fa40 	call	81120fa4 <fprintf>
#endif
					bSuccess = FALSE;
811030f4:	e03ff315 	stw	zero,-52(fp)
811030f8:	00002206 	br	81103184 <POWER_Read+0x1e8>
				} else if (Channel != i) {
811030fc:	e0fffa83 	ldbu	r3,-22(fp)
81103100:	e0bff417 	ldw	r2,-48(fp)
81103104:	18801026 	beq	r3,r2,81103148 <POWER_Read+0x1ac>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer,
81103108:	e0bffa83 	ldbu	r2,-22(fp)
8110310c:	d8800015 	stw	r2,0(sp)
81103110:	e1fff417 	ldw	r7,-48(fp)
81103114:	e1bff417 	ldw	r6,-48(fp)
81103118:	01604574 	movhi	r5,33045
8110311c:	296e6c04 	addi	r5,r5,-18000
81103120:	01204574 	movhi	r4,33045
81103124:	210be504 	addi	r4,r4,12180
81103128:	11229340 	call	81122934 <sprintf>
							"[%d]Unexpected Channel. Expected:%d, Read:%d\r\n",
							i, i, Channel);
					debug(fp, cDebugBuffer);
8110312c:	d0a06217 	ldw	r2,-32376(gp)
81103130:	01604574 	movhi	r5,33045
81103134:	294be504 	addi	r5,r5,12180
81103138:	1009883a 	mov	r4,r2
8110313c:	1120fa40 	call	81120fa4 <fprintf>
#endif
					bSuccess = FALSE;
81103140:	e03ff315 	stw	zero,-52(fp)
81103144:	00000f06 	br	81103184 <POWER_Read+0x1e8>
				} else if (SIGN ^ bSIGN) {
81103148:	e0fffac3 	ldbu	r3,-21(fp)
8110314c:	e0bff817 	ldw	r2,-32(fp)
81103150:	18800c26 	beq	r3,r2,81103184 <POWER_Read+0x1e8>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer, "[%d]Unexpected SIGN\r\n", i);
81103154:	e1bff417 	ldw	r6,-48(fp)
81103158:	01604574 	movhi	r5,33045
8110315c:	296e7804 	addi	r5,r5,-17952
81103160:	01204574 	movhi	r4,33045
81103164:	210be504 	addi	r4,r4,12180
81103168:	11229340 	call	81122934 <sprintf>
					debug(fp, cDebugBuffer);
8110316c:	d0a06217 	ldw	r2,-32376(gp)
81103170:	01604574 	movhi	r5,33045
81103174:	294be504 	addi	r5,r5,12180
81103178:	1009883a 	mov	r4,r2
8110317c:	1120fa40 	call	81120fa4 <fprintf>
#endif
					bSuccess = FALSE;
81103180:	e03ff315 	stw	zero,-52(fp)
					sprintf(cDebugBuffer, "[%d]Unexpected SGL\r\n", i);
					debug(fp, cDebugBuffer);
#endif
					bSuccess = FALSE;
				}
				if (bSuccess)
81103184:	e0bff317 	ldw	r2,-52(fp)
81103188:	10001a26 	beq	r2,zero,811031f4 <POWER_Read+0x258>
					szVol[nPortIndex++] = Value32; //(Value32 >> 6) & 0xFFFFFF; // 24 bits
8110318c:	e0bff617 	ldw	r2,-40(fp)
81103190:	10c00044 	addi	r3,r2,1
81103194:	e0fff615 	stw	r3,-40(fp)
81103198:	1085883a 	add	r2,r2,r2
8110319c:	1085883a 	add	r2,r2,r2
811031a0:	1007883a 	mov	r3,r2
811031a4:	e0bfff17 	ldw	r2,-4(fp)
811031a8:	10c5883a 	add	r2,r2,r3
811031ac:	e0fffe17 	ldw	r3,-8(fp)
811031b0:	10c00015 	stw	r3,0(r2)
811031b4:	00000f06 	br	811031f4 <POWER_Read+0x258>
			} else {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "SPI Read Error\r\n");
811031b8:	00e04574 	movhi	r3,33045
811031bc:	18cbe504 	addi	r3,r3,12180
811031c0:	00a04574 	movhi	r2,33045
811031c4:	10ae7e04 	addi	r2,r2,-17928
811031c8:	1009883a 	mov	r4,r2
811031cc:	00800444 	movi	r2,17
811031d0:	100d883a 	mov	r6,r2
811031d4:	200b883a 	mov	r5,r4
811031d8:	1809883a 	mov	r4,r3
811031dc:	11220540 	call	81122054 <memcpy>
				debug(fp, cDebugBuffer);
811031e0:	d0a06217 	ldw	r2,-32376(gp)
811031e4:	01604574 	movhi	r5,33045
811031e8:	294be504 	addi	r5,r5,12180
811031ec:	1009883a 	mov	r4,r2
811031f0:	1120fa40 	call	81120fa4 <fprintf>
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
		NextChannel = 0;
		bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
		for (i = 0; i < szPortNum[c] && bSuccess; i++) {
811031f4:	e0bff417 	ldw	r2,-48(fp)
811031f8:	10800044 	addi	r2,r2,1
811031fc:	e0bff415 	stw	r2,-48(fp)
81103200:	e0bff517 	ldw	r2,-44(fp)
81103204:	1085883a 	add	r2,r2,r2
81103208:	1085883a 	add	r2,r2,r2
8110320c:	e0fff304 	addi	r3,fp,-52
81103210:	1885883a 	add	r2,r3,r2
81103214:	10800904 	addi	r2,r2,36
81103218:	10800017 	ldw	r2,0(r2)
8110321c:	e0fff417 	ldw	r3,-48(fp)
81103220:	1880020e 	bge	r3,r2,8110322c <POWER_Read+0x290>
81103224:	e0bff317 	ldw	r2,-52(fp)
81103228:	103f811e 	bne	r2,zero,81103030 <__reset+0xfb0e3030>
	alt_u32 Value32;
	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL, PARITY;
	const bool bEN = TRUE; // alwasy update next conversion channel
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
8110322c:	e0bff517 	ldw	r2,-44(fp)
81103230:	10800044 	addi	r2,r2,1
81103234:	e0bff515 	stw	r2,-44(fp)
81103238:	e0bff517 	ldw	r2,-44(fp)
8110323c:	10800088 	cmpgei	r2,r2,2
81103240:	1000021e 	bne	r2,zero,8110324c <POWER_Read+0x2b0>
81103244:	e0bff317 	ldw	r2,-52(fp)
81103248:	103f691e 	bne	r2,zero,81102ff0 <__reset+0xfb0e2ff0>
				debug(fp, cDebugBuffer);
#endif
			}
		} // for i
	} // for c
	return bSuccess;
8110324c:	e0bff317 	ldw	r2,-52(fp)
}
81103250:	e037883a 	mov	sp,fp
81103254:	dfc00117 	ldw	ra,4(sp)
81103258:	df000017 	ldw	fp,0(sp)
8110325c:	dec00204 	addi	sp,sp,8
81103260:	f800283a 	ret

81103264 <TEMP_Read>:

bool TEMP_Read(alt_8 *pFpgaTemp, alt_8 *pBoardTemp) {
81103264:	defff904 	addi	sp,sp,-28
81103268:	de00012e 	bgeu	sp,et,81103270 <TEMP_Read+0xc>
8110326c:	003b68fa 	trap	3
81103270:	dfc00615 	stw	ra,24(sp)
81103274:	df000515 	stw	fp,20(sp)
81103278:	df000504 	addi	fp,sp,20
8110327c:	e13ffe15 	stw	r4,-8(fp)
81103280:	e17fff15 	stw	r5,-4(fp)
	bool bSuccess;
	const alt_u8 DeviceAddr = 0x30;
81103284:	00800c04 	movi	r2,48
81103288:	e0bffd85 	stb	r2,-10(fp)
	alt_8 FpgaTemp, BoardTemp;
	char Data;

	// read local temp
	bSuccess = I2C_Read(TEMP_SCL_BASE, TEMP_SDA_BASE, DeviceAddr, 0x00,
8110328c:	e0bffd83 	ldbu	r2,-10(fp)
81103290:	10c03fcc 	andi	r3,r2,255
81103294:	18c0201c 	xori	r3,r3,128
81103298:	18ffe004 	addi	r3,r3,-128
8110329c:	e0bffdc4 	addi	r2,fp,-9
811032a0:	d8800015 	stw	r2,0(sp)
811032a4:	000f883a 	mov	r7,zero
811032a8:	180d883a 	mov	r6,r3
811032ac:	01600034 	movhi	r5,32768
811032b0:	29426004 	addi	r5,r5,2432
811032b4:	01200034 	movhi	r4,32768
811032b8:	21026404 	addi	r4,r4,2448
811032bc:	110ac600 	call	8110ac60 <I2C_Read>
811032c0:	e0bffc15 	stw	r2,-16(fp)
			(alt_u8 *) &Data);
	if (bSuccess)
811032c4:	e0bffc17 	ldw	r2,-16(fp)
811032c8:	10000226 	beq	r2,zero,811032d4 <TEMP_Read+0x70>
		BoardTemp = Data;
811032cc:	e0bffdc3 	ldbu	r2,-9(fp)
811032d0:	e0bffd45 	stb	r2,-11(fp)

	// read remote temp
	if (bSuccess) {
811032d4:	e0bffc17 	ldw	r2,-16(fp)
811032d8:	10001226 	beq	r2,zero,81103324 <TEMP_Read+0xc0>
		bSuccess = I2C_Read(TEMP_SCL_BASE, TEMP_SDA_BASE, DeviceAddr, 0x01,
811032dc:	e0bffd83 	ldbu	r2,-10(fp)
811032e0:	10c03fcc 	andi	r3,r2,255
811032e4:	18c0201c 	xori	r3,r3,128
811032e8:	18ffe004 	addi	r3,r3,-128
811032ec:	e0bffdc4 	addi	r2,fp,-9
811032f0:	d8800015 	stw	r2,0(sp)
811032f4:	01c00044 	movi	r7,1
811032f8:	180d883a 	mov	r6,r3
811032fc:	01600034 	movhi	r5,32768
81103300:	29426004 	addi	r5,r5,2432
81103304:	01200034 	movhi	r4,32768
81103308:	21026404 	addi	r4,r4,2448
8110330c:	110ac600 	call	8110ac60 <I2C_Read>
81103310:	e0bffc15 	stw	r2,-16(fp)
				(alt_u8 *) &Data);
		if (bSuccess)
81103314:	e0bffc17 	ldw	r2,-16(fp)
81103318:	10000226 	beq	r2,zero,81103324 <TEMP_Read+0xc0>
			FpgaTemp = Data;
8110331c:	e0bffdc3 	ldbu	r2,-9(fp)
81103320:	e0bffd05 	stb	r2,-12(fp)
	}
	//
	if (bSuccess) {
81103324:	e0bffc17 	ldw	r2,-16(fp)
81103328:	10000626 	beq	r2,zero,81103344 <TEMP_Read+0xe0>
		*pFpgaTemp = FpgaTemp;
8110332c:	e0bffe17 	ldw	r2,-8(fp)
81103330:	e0fffd03 	ldbu	r3,-12(fp)
81103334:	10c00005 	stb	r3,0(r2)
		*pBoardTemp = BoardTemp;
81103338:	e0bfff17 	ldw	r2,-4(fp)
8110333c:	e0fffd43 	ldbu	r3,-11(fp)
81103340:	10c00005 	stb	r3,0(r2)
	}

	return bSuccess;
81103344:	e0bffc17 	ldw	r2,-16(fp)
}
81103348:	e037883a 	mov	sp,fp
8110334c:	dfc00117 	ldw	ra,4(sp)
81103350:	df000017 	ldw	fp,0(sp)
81103354:	dec00204 	addi	sp,sp,8
81103358:	f800283a 	ret

8110335c <sense_log_temp>:

bool sense_log_temp(alt_u8 *FpgaTemp, alt_u8 *BoardTemp) {
8110335c:	defffb04 	addi	sp,sp,-20
81103360:	de00012e 	bgeu	sp,et,81103368 <sense_log_temp+0xc>
81103364:	003b68fa 	trap	3
81103368:	dfc00415 	stw	ra,16(sp)
8110336c:	df000315 	stw	fp,12(sp)
81103370:	df000304 	addi	fp,sp,12
81103374:	e13ffe15 	stw	r4,-8(fp)
81103378:	e17fff15 	stw	r5,-4(fp)
	bool bSuccess;

	// show temp
	bSuccess = TEMP_Read((alt_8*) FpgaTemp, (alt_8*) BoardTemp);
8110337c:	e17fff17 	ldw	r5,-4(fp)
81103380:	e13ffe17 	ldw	r4,-8(fp)
81103384:	11032640 	call	81103264 <TEMP_Read>
81103388:	e0bffd15 	stw	r2,-12(fp)

	return (bSuccess);
8110338c:	e0bffd17 	ldw	r2,-12(fp)
}
81103390:	e037883a 	mov	sp,fp
81103394:	dfc00117 	ldw	ra,4(sp)
81103398:	df000017 	ldw	fp,0(sp)
8110339c:	dec00204 	addi	sp,sp,8
811033a0:	f800283a 	ret

811033a4 <sense_log>:

void sense_log(void) {
811033a4:	deff0404 	addi	sp,sp,-1008
811033a8:	de00012e 	bgeu	sp,et,811033b0 <sense_log+0xc>
811033ac:	003b68fa 	trap	3
811033b0:	dfc0fb15 	stw	ra,1004(sp)
811033b4:	df00fa15 	stw	fp,1000(sp)
811033b8:	dd40f915 	stw	r21,996(sp)
811033bc:	dd00f815 	stw	r20,992(sp)
811033c0:	dcc0f715 	stw	r19,988(sp)
811033c4:	dc80f615 	stw	r18,984(sp)
811033c8:	dc40f515 	stw	r17,980(sp)
811033cc:	dc00f415 	stw	r16,976(sp)
811033d0:	df00fa04 	addi	fp,sp,1000
	bool bSuccess;
	int i;
	const float fRef = 5.0; // 5.0V
811033d4:	00902834 	movhi	r2,16544
811033d8:	e0bf0e15 	stw	r2,-968(fp)
	float fVolDrop, fCurrent, fPower, fVol;
	alt_u32 szVol[POWER_PORT_NUM];
	alt_u32 SIG, MSB, RESULT;
	float szRes[] = { 0.003, 0.001, 0.003, 0.003, 0.003, 0.003, 0.003, 0.003,
811033dc:	008ed174 	movhi	r2,15173
811033e0:	10a6e984 	addi	r2,r2,-25690
811033e4:	e0bf2215 	stw	r2,-888(fp)
811033e8:	008ea0f4 	movhi	r2,14979
811033ec:	10849bc4 	addi	r2,r2,4719
811033f0:	e0bf2315 	stw	r2,-884(fp)
811033f4:	008ed174 	movhi	r2,15173
811033f8:	10a6e984 	addi	r2,r2,-25690
811033fc:	e0bf2415 	stw	r2,-880(fp)
81103400:	008ed174 	movhi	r2,15173
81103404:	10a6e984 	addi	r2,r2,-25690
81103408:	e0bf2515 	stw	r2,-876(fp)
8110340c:	008ed174 	movhi	r2,15173
81103410:	10a6e984 	addi	r2,r2,-25690
81103414:	e0bf2615 	stw	r2,-872(fp)
81103418:	008ed174 	movhi	r2,15173
8110341c:	10a6e984 	addi	r2,r2,-25690
81103420:	e0bf2715 	stw	r2,-868(fp)
81103424:	008ed174 	movhi	r2,15173
81103428:	10a6e984 	addi	r2,r2,-25690
8110342c:	e0bf2815 	stw	r2,-864(fp)
81103430:	008ed174 	movhi	r2,15173
81103434:	10a6e984 	addi	r2,r2,-25690
81103438:	e0bf2915 	stw	r2,-860(fp)
8110343c:	008ed174 	movhi	r2,15173
81103440:	10a6e984 	addi	r2,r2,-25690
81103444:	e0bf2a15 	stw	r2,-856(fp)
81103448:	008ed174 	movhi	r2,15173
8110344c:	10a6e984 	addi	r2,r2,-25690
81103450:	e0bf2b15 	stw	r2,-852(fp)
81103454:	008ed174 	movhi	r2,15173
81103458:	10a6e984 	addi	r2,r2,-25690
8110345c:	e0bf2c15 	stw	r2,-848(fp)
81103460:	008ed174 	movhi	r2,15173
81103464:	10a6e984 	addi	r2,r2,-25690
81103468:	e0bf2d15 	stw	r2,-844(fp)
			0.003, 0.003, 0.003, 0.003 };
	float szRefVol[] = { 0.9, 0.9, 3.0, 0.9, 1.8, 2.5, 1.8, 2.5, 1.1, 1.4, 3.3,
8110346c:	008fd9b4 	movhi	r2,16230
81103470:	10999984 	addi	r2,r2,26214
81103474:	e0bf2e15 	stw	r2,-840(fp)
81103478:	008fd9b4 	movhi	r2,16230
8110347c:	10999984 	addi	r2,r2,26214
81103480:	e0bf2f15 	stw	r2,-836(fp)
81103484:	00901034 	movhi	r2,16448
81103488:	e0bf3015 	stw	r2,-832(fp)
8110348c:	008fd9b4 	movhi	r2,16230
81103490:	10999984 	addi	r2,r2,26214
81103494:	e0bf3115 	stw	r2,-828(fp)
81103498:	008ff9b4 	movhi	r2,16358
8110349c:	10999984 	addi	r2,r2,26214
811034a0:	e0bf3215 	stw	r2,-824(fp)
811034a4:	00900834 	movhi	r2,16416
811034a8:	e0bf3315 	stw	r2,-820(fp)
811034ac:	008ff9b4 	movhi	r2,16358
811034b0:	10999984 	addi	r2,r2,26214
811034b4:	e0bf3415 	stw	r2,-816(fp)
811034b8:	00900834 	movhi	r2,16416
811034bc:	e0bf3515 	stw	r2,-812(fp)
811034c0:	008fe374 	movhi	r2,16269
811034c4:	10b33344 	addi	r2,r2,-13107
811034c8:	e0bf3615 	stw	r2,-808(fp)
811034cc:	008fecf4 	movhi	r2,16307
811034d0:	108cccc4 	addi	r2,r2,13107
811034d4:	e0bf3715 	stw	r2,-804(fp)
811034d8:	009014f4 	movhi	r2,16467
811034dc:	108cccc4 	addi	r2,r2,13107
811034e0:	e0bf3815 	stw	r2,-800(fp)
811034e4:	00900834 	movhi	r2,16416
811034e8:	e0bf3915 	stw	r2,-796(fp)
			2.5 };
	char szName[][64] = { "VCCD_PLL", "VCC0P9", "GPIO_VCCIOPD", "VCCHIP",
811034ec:	00a04574 	movhi	r2,33045
811034f0:	10aeb504 	addi	r2,r2,-17708
811034f4:	e0ff3a04 	addi	r3,fp,-792
811034f8:	1009883a 	mov	r4,r2
811034fc:	0080c004 	movi	r2,768
81103500:	100d883a 	mov	r6,r2
81103504:	200b883a 	mov	r5,r4
81103508:	1809883a 	mov	r4,r3
8110350c:	11220540 	call	81122054 <memcpy>
			"VCC1P8_34R", "HSMA_VCCIO", "VCC1P8_78R", "VCCA_PLL", "VCCL_GXB",
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };

	// show power
	bSuccess = POWER_Read(szVol);
81103510:	e0bf1604 	addi	r2,fp,-936
81103514:	1009883a 	mov	r4,r2
81103518:	1102f9c0 	call	81102f9c <POWER_Read>
8110351c:	e0bf0f15 	stw	r2,-964(fp)
	if (bSuccess) {
81103520:	e0bf0f17 	ldw	r2,-964(fp)
81103524:	10016026 	beq	r2,zero,81103aa8 <sense_log+0x704>
		for (i = 0; i < POWER_PORT_NUM && bSuccess; i++) {
81103528:	e03f0c15 	stw	zero,-976(fp)
8110352c:	00014c06 	br	81103a60 <sense_log+0x6bc>
			SIG = (szVol[i] >> 29) & 0x01;
81103530:	e0bf0c17 	ldw	r2,-976(fp)
81103534:	1085883a 	add	r2,r2,r2
81103538:	1085883a 	add	r2,r2,r2
8110353c:	e0ff0c04 	addi	r3,fp,-976
81103540:	1885883a 	add	r2,r3,r2
81103544:	10800a04 	addi	r2,r2,40
81103548:	10800017 	ldw	r2,0(r2)
8110354c:	1004d77a 	srli	r2,r2,29
81103550:	1080004c 	andi	r2,r2,1
81103554:	e0bf1015 	stw	r2,-960(fp)
			MSB = (szVol[i] >> 28) & 0x01;
81103558:	e0bf0c17 	ldw	r2,-976(fp)
8110355c:	1085883a 	add	r2,r2,r2
81103560:	1085883a 	add	r2,r2,r2
81103564:	e0ff0c04 	addi	r3,fp,-976
81103568:	1885883a 	add	r2,r3,r2
8110356c:	10800a04 	addi	r2,r2,40
81103570:	10800017 	ldw	r2,0(r2)
81103574:	1004d73a 	srli	r2,r2,28
81103578:	1080004c 	andi	r2,r2,1
8110357c:	e0bf1115 	stw	r2,-956(fp)
			RESULT = (szVol[i] >> 6) & 0x3FFFFF; // 22 bits
81103580:	e0bf0c17 	ldw	r2,-976(fp)
81103584:	1085883a 	add	r2,r2,r2
81103588:	1085883a 	add	r2,r2,r2
8110358c:	e0ff0c04 	addi	r3,fp,-976
81103590:	1885883a 	add	r2,r3,r2
81103594:	10800a04 	addi	r2,r2,40
81103598:	10800017 	ldw	r2,0(r2)
8110359c:	1006d1ba 	srli	r3,r2,6
811035a0:	00801034 	movhi	r2,64
811035a4:	10bfffc4 	addi	r2,r2,-1
811035a8:	1884703a 	and	r2,r3,r2
811035ac:	e0bf1215 	stw	r2,-952(fp)
			if (MSB == 0)
811035b0:	e0bf1117 	ldw	r2,-956(fp)
811035b4:	1000091e 	bne	r2,zero,811035dc <sense_log+0x238>
				fVolDrop = (float) (RESULT) / (float) 0x400000;
811035b8:	e13f1217 	ldw	r4,-952(fp)
811035bc:	111f7c80 	call	8111f7c8 <__floatunsisf>
811035c0:	1007883a 	mov	r3,r2
811035c4:	0152a034 	movhi	r5,19072
811035c8:	1809883a 	mov	r4,r3
811035cc:	111ee500 	call	8111ee50 <__divsf3>
811035d0:	1007883a 	mov	r3,r2
811035d4:	e0ff0d15 	stw	r3,-972(fp)
811035d8:	00000106 	br	811035e0 <sense_log+0x23c>
			else
				fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
811035dc:	e03f0d15 	stw	zero,-972(fp)
			if (SIG && MSB) {
811035e0:	e0bf1017 	ldw	r2,-960(fp)
811035e4:	10002626 	beq	r2,zero,81103680 <sense_log+0x2dc>
811035e8:	e0bf1117 	ldw	r2,-956(fp)
811035ec:	10002426 	beq	r2,zero,81103680 <sense_log+0x2dc>
				fVol = fRef * 0.5;
811035f0:	014fc034 	movhi	r5,16128
811035f4:	e13f0e17 	ldw	r4,-968(fp)
811035f8:	111f2980 	call	8111f298 <__mulsf3>
811035fc:	1007883a 	mov	r3,r2
81103600:	e0ff1315 	stw	r3,-948(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Over]\r\n  VolDrop:%f(V)\r\n",
						szName[i], (int) szVol[i], fVol);
81103604:	e0ff3a04 	addi	r3,fp,-792
81103608:	e0bf0c17 	ldw	r2,-976(fp)
8110360c:	100491ba 	slli	r2,r2,6
81103610:	18a1883a 	add	r16,r3,r2
81103614:	e0bf0c17 	ldw	r2,-976(fp)
81103618:	1085883a 	add	r2,r2,r2
8110361c:	1085883a 	add	r2,r2,r2
81103620:	e0ff0c04 	addi	r3,fp,-976
81103624:	1885883a 	add	r2,r3,r2
81103628:	10800a04 	addi	r2,r2,40
8110362c:	10800017 	ldw	r2,0(r2)
			else
				fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
			if (SIG && MSB) {
				fVol = fRef * 0.5;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Over]\r\n  VolDrop:%f(V)\r\n",
81103630:	1023883a 	mov	r17,r2
81103634:	e13f1317 	ldw	r4,-948(fp)
81103638:	1120b240 	call	81120b24 <__extendsfdf2>
8110363c:	1009883a 	mov	r4,r2
81103640:	180b883a 	mov	r5,r3
81103644:	d9000015 	stw	r4,0(sp)
81103648:	d9400115 	stw	r5,4(sp)
8110364c:	880f883a 	mov	r7,r17
81103650:	800d883a 	mov	r6,r16
81103654:	01604574 	movhi	r5,33045
81103658:	296e8304 	addi	r5,r5,-17908
8110365c:	01204574 	movhi	r4,33045
81103660:	210be504 	addi	r4,r4,12180
81103664:	11229340 	call	81122934 <sprintf>
						szName[i], (int) szVol[i], fVol);
				debug(fp, cDebugBuffer);
81103668:	d0a06217 	ldw	r2,-32376(gp)
8110366c:	01604574 	movhi	r5,33045
81103670:	294be504 	addi	r5,r5,12180
81103674:	1009883a 	mov	r4,r2
81103678:	1120fa40 	call	81120fa4 <fprintf>
8110367c:	0000f506 	br	81103a54 <sense_log+0x6b0>
#endif
			} else if (SIG && !MSB) {
81103680:	e0bf1017 	ldw	r2,-960(fp)
81103684:	10006426 	beq	r2,zero,81103818 <sense_log+0x474>
81103688:	e0bf1117 	ldw	r2,-956(fp)
8110368c:	1000621e 	bne	r2,zero,81103818 <sense_log+0x474>
				fVol = fRef * 0.5 * fVolDrop;
81103690:	e13f0e17 	ldw	r4,-968(fp)
81103694:	1120b240 	call	81120b24 <__extendsfdf2>
81103698:	1011883a 	mov	r8,r2
8110369c:	1813883a 	mov	r9,r3
811036a0:	000d883a 	mov	r6,zero
811036a4:	01cff834 	movhi	r7,16352
811036a8:	4009883a 	mov	r4,r8
811036ac:	480b883a 	mov	r5,r9
811036b0:	111f99c0 	call	8111f99c <__muldf3>
811036b4:	1009883a 	mov	r4,r2
811036b8:	180b883a 	mov	r5,r3
811036bc:	2021883a 	mov	r16,r4
811036c0:	2823883a 	mov	r17,r5
811036c4:	e13f0d17 	ldw	r4,-972(fp)
811036c8:	1120b240 	call	81120b24 <__extendsfdf2>
811036cc:	1009883a 	mov	r4,r2
811036d0:	180b883a 	mov	r5,r3
811036d4:	200d883a 	mov	r6,r4
811036d8:	280f883a 	mov	r7,r5
811036dc:	8009883a 	mov	r4,r16
811036e0:	880b883a 	mov	r5,r17
811036e4:	111f99c0 	call	8111f99c <__muldf3>
811036e8:	1009883a 	mov	r4,r2
811036ec:	180b883a 	mov	r5,r3
811036f0:	2005883a 	mov	r2,r4
811036f4:	2807883a 	mov	r3,r5
811036f8:	1009883a 	mov	r4,r2
811036fc:	180b883a 	mov	r5,r3
81103700:	1120c3c0 	call	81120c3c <__truncdfsf2>
81103704:	1007883a 	mov	r3,r2
81103708:	e0ff1315 	stw	r3,-948(fp)
				fCurrent = fVolDrop / szRes[i];
8110370c:	e0bf0c17 	ldw	r2,-976(fp)
81103710:	1085883a 	add	r2,r2,r2
81103714:	1085883a 	add	r2,r2,r2
81103718:	e0ff0c04 	addi	r3,fp,-976
8110371c:	1885883a 	add	r2,r3,r2
81103720:	10801604 	addi	r2,r2,88
81103724:	10c00017 	ldw	r3,0(r2)
81103728:	180b883a 	mov	r5,r3
8110372c:	e13f0d17 	ldw	r4,-972(fp)
81103730:	111ee500 	call	8111ee50 <__divsf3>
81103734:	1007883a 	mov	r3,r2
81103738:	e0ff1415 	stw	r3,-944(fp)
				fPower = szRefVol[i] * fCurrent;
8110373c:	e0bf0c17 	ldw	r2,-976(fp)
81103740:	1085883a 	add	r2,r2,r2
81103744:	1085883a 	add	r2,r2,r2
81103748:	e0ff0c04 	addi	r3,fp,-976
8110374c:	1885883a 	add	r2,r3,r2
81103750:	10802204 	addi	r2,r2,136
81103754:	10c00017 	ldw	r3,0(r2)
81103758:	e17f1417 	ldw	r5,-944(fp)
8110375c:	1809883a 	mov	r4,r3
81103760:	111f2980 	call	8111f298 <__mulsf3>
81103764:	1007883a 	mov	r3,r2
81103768:	e0ff1515 	stw	r3,-940(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"[%s:%06XH,Pos]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
8110376c:	e0ff3a04 	addi	r3,fp,-792
81103770:	e0bf0c17 	ldw	r2,-976(fp)
81103774:	100491ba 	slli	r2,r2,6
81103778:	18a9883a 	add	r20,r3,r2
8110377c:	e0bf0c17 	ldw	r2,-976(fp)
81103780:	1085883a 	add	r2,r2,r2
81103784:	1085883a 	add	r2,r2,r2
81103788:	e0ff0c04 	addi	r3,fp,-976
8110378c:	1885883a 	add	r2,r3,r2
81103790:	10800a04 	addi	r2,r2,40
81103794:	10800017 	ldw	r2,0(r2)
			} else if (SIG && !MSB) {
				fVol = fRef * 0.5 * fVolDrop;
				fCurrent = fVolDrop / szRes[i];
				fPower = szRefVol[i] * fCurrent;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81103798:	102b883a 	mov	r21,r2
8110379c:	e13f0d17 	ldw	r4,-972(fp)
811037a0:	1120b240 	call	81120b24 <__extendsfdf2>
811037a4:	1021883a 	mov	r16,r2
811037a8:	1823883a 	mov	r17,r3
811037ac:	e13f1417 	ldw	r4,-944(fp)
811037b0:	1120b240 	call	81120b24 <__extendsfdf2>
811037b4:	1025883a 	mov	r18,r2
811037b8:	1827883a 	mov	r19,r3
811037bc:	e13f1517 	ldw	r4,-940(fp)
811037c0:	1120b240 	call	81120b24 <__extendsfdf2>
811037c4:	1009883a 	mov	r4,r2
811037c8:	180b883a 	mov	r5,r3
811037cc:	d9000415 	stw	r4,16(sp)
811037d0:	d9400515 	stw	r5,20(sp)
811037d4:	dc800215 	stw	r18,8(sp)
811037d8:	dcc00315 	stw	r19,12(sp)
811037dc:	dc000015 	stw	r16,0(sp)
811037e0:	dc400115 	stw	r17,4(sp)
811037e4:	a80f883a 	mov	r7,r21
811037e8:	a00d883a 	mov	r6,r20
811037ec:	01604574 	movhi	r5,33045
811037f0:	296e8c04 	addi	r5,r5,-17872
811037f4:	01204574 	movhi	r4,33045
811037f8:	210be504 	addi	r4,r4,12180
811037fc:	11229340 	call	81122934 <sprintf>
						"[%s:%06XH,Pos]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
				debug(fp, cDebugBuffer);
81103800:	d0a06217 	ldw	r2,-32376(gp)
81103804:	01604574 	movhi	r5,33045
81103808:	294be504 	addi	r5,r5,12180
8110380c:	1009883a 	mov	r4,r2
81103810:	1120fa40 	call	81120fa4 <fprintf>
81103814:	00008f06 	br	81103a54 <sense_log+0x6b0>
#endif
			} else if (!SIG && MSB) {
81103818:	e0bf1017 	ldw	r2,-960(fp)
8110381c:	1000641e 	bne	r2,zero,811039b0 <sense_log+0x60c>
81103820:	e0bf1117 	ldw	r2,-956(fp)
81103824:	10006226 	beq	r2,zero,811039b0 <sense_log+0x60c>
				fVol = fRef * 0.5 * fVolDrop;
81103828:	e13f0e17 	ldw	r4,-968(fp)
8110382c:	1120b240 	call	81120b24 <__extendsfdf2>
81103830:	1011883a 	mov	r8,r2
81103834:	1813883a 	mov	r9,r3
81103838:	000d883a 	mov	r6,zero
8110383c:	01cff834 	movhi	r7,16352
81103840:	4009883a 	mov	r4,r8
81103844:	480b883a 	mov	r5,r9
81103848:	111f99c0 	call	8111f99c <__muldf3>
8110384c:	1009883a 	mov	r4,r2
81103850:	180b883a 	mov	r5,r3
81103854:	2021883a 	mov	r16,r4
81103858:	2823883a 	mov	r17,r5
8110385c:	e13f0d17 	ldw	r4,-972(fp)
81103860:	1120b240 	call	81120b24 <__extendsfdf2>
81103864:	1009883a 	mov	r4,r2
81103868:	180b883a 	mov	r5,r3
8110386c:	200d883a 	mov	r6,r4
81103870:	280f883a 	mov	r7,r5
81103874:	8009883a 	mov	r4,r16
81103878:	880b883a 	mov	r5,r17
8110387c:	111f99c0 	call	8111f99c <__muldf3>
81103880:	1009883a 	mov	r4,r2
81103884:	180b883a 	mov	r5,r3
81103888:	2005883a 	mov	r2,r4
8110388c:	2807883a 	mov	r3,r5
81103890:	1009883a 	mov	r4,r2
81103894:	180b883a 	mov	r5,r3
81103898:	1120c3c0 	call	81120c3c <__truncdfsf2>
8110389c:	1007883a 	mov	r3,r2
811038a0:	e0ff1315 	stw	r3,-948(fp)
				fCurrent = fVolDrop / szRes[i];
811038a4:	e0bf0c17 	ldw	r2,-976(fp)
811038a8:	1085883a 	add	r2,r2,r2
811038ac:	1085883a 	add	r2,r2,r2
811038b0:	e0ff0c04 	addi	r3,fp,-976
811038b4:	1885883a 	add	r2,r3,r2
811038b8:	10801604 	addi	r2,r2,88
811038bc:	10c00017 	ldw	r3,0(r2)
811038c0:	180b883a 	mov	r5,r3
811038c4:	e13f0d17 	ldw	r4,-972(fp)
811038c8:	111ee500 	call	8111ee50 <__divsf3>
811038cc:	1007883a 	mov	r3,r2
811038d0:	e0ff1415 	stw	r3,-944(fp)
				fPower = szRefVol[i] * fCurrent;
811038d4:	e0bf0c17 	ldw	r2,-976(fp)
811038d8:	1085883a 	add	r2,r2,r2
811038dc:	1085883a 	add	r2,r2,r2
811038e0:	e0ff0c04 	addi	r3,fp,-976
811038e4:	1885883a 	add	r2,r3,r2
811038e8:	10802204 	addi	r2,r2,136
811038ec:	10c00017 	ldw	r3,0(r2)
811038f0:	e17f1417 	ldw	r5,-944(fp)
811038f4:	1809883a 	mov	r4,r3
811038f8:	111f2980 	call	8111f298 <__mulsf3>
811038fc:	1007883a 	mov	r3,r2
81103900:	e0ff1515 	stw	r3,-940(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"[%s:%06XH,Neg]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
81103904:	e0ff3a04 	addi	r3,fp,-792
81103908:	e0bf0c17 	ldw	r2,-976(fp)
8110390c:	100491ba 	slli	r2,r2,6
81103910:	18a9883a 	add	r20,r3,r2
81103914:	e0bf0c17 	ldw	r2,-976(fp)
81103918:	1085883a 	add	r2,r2,r2
8110391c:	1085883a 	add	r2,r2,r2
81103920:	e0ff0c04 	addi	r3,fp,-976
81103924:	1885883a 	add	r2,r3,r2
81103928:	10800a04 	addi	r2,r2,40
8110392c:	10800017 	ldw	r2,0(r2)
			} else if (!SIG && MSB) {
				fVol = fRef * 0.5 * fVolDrop;
				fCurrent = fVolDrop / szRes[i];
				fPower = szRefVol[i] * fCurrent;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81103930:	102b883a 	mov	r21,r2
81103934:	e13f0d17 	ldw	r4,-972(fp)
81103938:	1120b240 	call	81120b24 <__extendsfdf2>
8110393c:	1021883a 	mov	r16,r2
81103940:	1823883a 	mov	r17,r3
81103944:	e13f1417 	ldw	r4,-944(fp)
81103948:	1120b240 	call	81120b24 <__extendsfdf2>
8110394c:	1025883a 	mov	r18,r2
81103950:	1827883a 	mov	r19,r3
81103954:	e13f1517 	ldw	r4,-940(fp)
81103958:	1120b240 	call	81120b24 <__extendsfdf2>
8110395c:	1009883a 	mov	r4,r2
81103960:	180b883a 	mov	r5,r3
81103964:	d9000415 	stw	r4,16(sp)
81103968:	d9400515 	stw	r5,20(sp)
8110396c:	dc800215 	stw	r18,8(sp)
81103970:	dcc00315 	stw	r19,12(sp)
81103974:	dc000015 	stw	r16,0(sp)
81103978:	dc400115 	stw	r17,4(sp)
8110397c:	a80f883a 	mov	r7,r21
81103980:	a00d883a 	mov	r6,r20
81103984:	01604574 	movhi	r5,33045
81103988:	296e9c04 	addi	r5,r5,-17808
8110398c:	01204574 	movhi	r4,33045
81103990:	210be504 	addi	r4,r4,12180
81103994:	11229340 	call	81122934 <sprintf>
						"[%s:%06XH,Neg]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
				debug(fp, cDebugBuffer);
81103998:	d0a06217 	ldw	r2,-32376(gp)
8110399c:	01604574 	movhi	r5,33045
811039a0:	294be504 	addi	r5,r5,12180
811039a4:	1009883a 	mov	r4,r2
811039a8:	1120fa40 	call	81120fa4 <fprintf>
811039ac:	00002906 	br	81103a54 <sense_log+0x6b0>
#endif
			} else if (!SIG && !MSB) {
811039b0:	e0bf1017 	ldw	r2,-960(fp)
811039b4:	1000271e 	bne	r2,zero,81103a54 <sense_log+0x6b0>
811039b8:	e0bf1117 	ldw	r2,-956(fp)
811039bc:	1000251e 	bne	r2,zero,81103a54 <sense_log+0x6b0>
				fVol = -fRef * 0.5;
811039c0:	e0bf0e17 	ldw	r2,-968(fp)
811039c4:	10a0003c 	xorhi	r2,r2,32768
811039c8:	014fc034 	movhi	r5,16128
811039cc:	1009883a 	mov	r4,r2
811039d0:	111f2980 	call	8111f298 <__mulsf3>
811039d4:	1007883a 	mov	r3,r2
811039d8:	e0ff1315 	stw	r3,-948(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Under]\r\n  VolDrop:%f(V)\r\n",
						szName[i], (int) szVol[i], fVol);
811039dc:	e0ff3a04 	addi	r3,fp,-792
811039e0:	e0bf0c17 	ldw	r2,-976(fp)
811039e4:	100491ba 	slli	r2,r2,6
811039e8:	18a1883a 	add	r16,r3,r2
811039ec:	e0bf0c17 	ldw	r2,-976(fp)
811039f0:	1085883a 	add	r2,r2,r2
811039f4:	1085883a 	add	r2,r2,r2
811039f8:	e0ff0c04 	addi	r3,fp,-976
811039fc:	1885883a 	add	r2,r3,r2
81103a00:	10800a04 	addi	r2,r2,40
81103a04:	10800017 	ldw	r2,0(r2)
				debug(fp, cDebugBuffer);
#endif
			} else if (!SIG && !MSB) {
				fVol = -fRef * 0.5;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Under]\r\n  VolDrop:%f(V)\r\n",
81103a08:	1023883a 	mov	r17,r2
81103a0c:	e13f1317 	ldw	r4,-948(fp)
81103a10:	1120b240 	call	81120b24 <__extendsfdf2>
81103a14:	1009883a 	mov	r4,r2
81103a18:	180b883a 	mov	r5,r3
81103a1c:	d9000015 	stw	r4,0(sp)
81103a20:	d9400115 	stw	r5,4(sp)
81103a24:	880f883a 	mov	r7,r17
81103a28:	800d883a 	mov	r6,r16
81103a2c:	01604574 	movhi	r5,33045
81103a30:	296eac04 	addi	r5,r5,-17744
81103a34:	01204574 	movhi	r4,33045
81103a38:	210be504 	addi	r4,r4,12180
81103a3c:	11229340 	call	81122934 <sprintf>
						szName[i], (int) szVol[i], fVol);
				debug(fp, cDebugBuffer);
81103a40:	d0a06217 	ldw	r2,-32376(gp)
81103a44:	01604574 	movhi	r5,33045
81103a48:	294be504 	addi	r5,r5,12180
81103a4c:	1009883a 	mov	r4,r2
81103a50:	1120fa40 	call	81120fa4 <fprintf>
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };

	// show power
	bSuccess = POWER_Read(szVol);
	if (bSuccess) {
		for (i = 0; i < POWER_PORT_NUM && bSuccess; i++) {
81103a54:	e0bf0c17 	ldw	r2,-976(fp)
81103a58:	10800044 	addi	r2,r2,1
81103a5c:	e0bf0c15 	stw	r2,-976(fp)
81103a60:	e0bf0c17 	ldw	r2,-976(fp)
81103a64:	10800308 	cmpgei	r2,r2,12
81103a68:	1000021e 	bne	r2,zero,81103a74 <sense_log+0x6d0>
81103a6c:	e0bf0f17 	ldw	r2,-964(fp)
81103a70:	103eaf1e 	bne	r2,zero,81103530 <__reset+0xfb0e3530>
				debug(fp, cDebugBuffer);
#endif
			}
		}
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "\r\n");
81103a74:	00a04574 	movhi	r2,33045
81103a78:	108be504 	addi	r2,r2,12180
81103a7c:	00c00344 	movi	r3,13
81103a80:	10c00005 	stb	r3,0(r2)
81103a84:	00c00284 	movi	r3,10
81103a88:	10c00045 	stb	r3,1(r2)
81103a8c:	10000085 	stb	zero,2(r2)
		debug(fp, cDebugBuffer);
81103a90:	d0a06217 	ldw	r2,-32376(gp)
81103a94:	01604574 	movhi	r5,33045
81103a98:	294be504 	addi	r5,r5,12180
81103a9c:	1009883a 	mov	r4,r2
81103aa0:	1120fa40 	call	81120fa4 <fprintf>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Error\r\n");
		debug(fp, cDebugBuffer);
#endif
	}
}
81103aa4:	00001606 	br	81103b00 <sense_log+0x75c>
		sprintf(cDebugBuffer, "\r\n");
		debug(fp, cDebugBuffer);
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Error\r\n");
81103aa8:	00a04574 	movhi	r2,33045
81103aac:	108be504 	addi	r2,r2,12180
81103ab0:	00c01144 	movi	r3,69
81103ab4:	10c00005 	stb	r3,0(r2)
81103ab8:	00c01c84 	movi	r3,114
81103abc:	10c00045 	stb	r3,1(r2)
81103ac0:	00c01c84 	movi	r3,114
81103ac4:	10c00085 	stb	r3,2(r2)
81103ac8:	00c01bc4 	movi	r3,111
81103acc:	10c000c5 	stb	r3,3(r2)
81103ad0:	00c01c84 	movi	r3,114
81103ad4:	10c00105 	stb	r3,4(r2)
81103ad8:	00c00344 	movi	r3,13
81103adc:	10c00145 	stb	r3,5(r2)
81103ae0:	00c00284 	movi	r3,10
81103ae4:	10c00185 	stb	r3,6(r2)
81103ae8:	100001c5 	stb	zero,7(r2)
		debug(fp, cDebugBuffer);
81103aec:	d0a06217 	ldw	r2,-32376(gp)
81103af0:	01604574 	movhi	r5,33045
81103af4:	294be504 	addi	r5,r5,12180
81103af8:	1009883a 	mov	r4,r2
81103afc:	1120fa40 	call	81120fa4 <fprintf>
#endif
	}
}
81103b00:	0001883a 	nop
81103b04:	e6fffa04 	addi	sp,fp,-24
81103b08:	dfc00717 	ldw	ra,28(sp)
81103b0c:	df000617 	ldw	fp,24(sp)
81103b10:	dd400517 	ldw	r21,20(sp)
81103b14:	dd000417 	ldw	r20,16(sp)
81103b18:	dcc00317 	ldw	r19,12(sp)
81103b1c:	dc800217 	ldw	r18,8(sp)
81103b20:	dc400117 	ldw	r17,4(sp)
81103b24:	dc000017 	ldw	r16,0(sp)
81103b28:	dec00804 	addi	sp,sp,32
81103b2c:	f800283a 	ret

81103b30 <bSdmaInitM1Dma>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bSdmaInitM1Dma(void) {
81103b30:	defffc04 	addi	sp,sp,-16
81103b34:	de00012e 	bgeu	sp,et,81103b3c <bSdmaInitM1Dma+0xc>
81103b38:	003b68fa 	trap	3
81103b3c:	dfc00315 	stw	ra,12(sp)
81103b40:	df000215 	stw	fp,8(sp)
81103b44:	df000204 	addi	fp,sp,8
	bool bStatus = TRUE;
81103b48:	00800044 	movi	r2,1
81103b4c:	e0bffe15 	stw	r2,-8(fp)
	alt_u16 usiCounter = 0;
81103b50:	e03fff0d 	sth	zero,-4(fp)

	// open dma device
	pxDmaM1Dev = alt_msgdma_open((char *) SDMA_DMA_M1_NAME);
81103b54:	01204574 	movhi	r4,33045
81103b58:	212f7504 	addi	r4,r4,-16940
81103b5c:	11497540 	call	81149754 <alt_msgdma_open>
81103b60:	d0a03915 	stw	r2,-32540(gp)

	// check if the device was opened
	if (pxDmaM1Dev == NULL) {
81103b64:	d0a03917 	ldw	r2,-32540(gp)
81103b68:	1000021e 	bne	r2,zero,81103b74 <bSdmaInitM1Dma+0x44>
		// device not opened
		bStatus = FALSE;
81103b6c:	e03ffe15 	stw	zero,-8(fp)
81103b70:	00001506 	br	81103bc8 <bSdmaInitM1Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
81103b74:	d0a03917 	ldw	r2,-32540(gp)
81103b78:	10800317 	ldw	r2,12(r2)
81103b7c:	10800104 	addi	r2,r2,4
81103b80:	00c00084 	movi	r3,2
81103b84:	10c00035 	stwio	r3,0(r2)
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103b88:	00000a06 	br	81103bb4 <bSdmaInitM1Dma+0x84>
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
			usleep(1);
81103b8c:	01000044 	movi	r4,1
81103b90:	11376bc0 	call	811376bc <usleep>
			usiCounter++;
81103b94:	e0bfff0b 	ldhu	r2,-4(fp)
81103b98:	10800044 	addi	r2,r2,1
81103b9c:	e0bfff0d 	sth	r2,-4(fp)
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
81103ba0:	e0bfff0b 	ldhu	r2,-4(fp)
81103ba4:	1084e230 	cmpltui	r2,r2,5000
81103ba8:	1000021e 	bne	r2,zero,81103bb4 <bSdmaInitM1Dma+0x84>
				bStatus = FALSE;
81103bac:	e03ffe15 	stw	zero,-8(fp)
				break;
81103bb0:	00000506 	br	81103bc8 <bSdmaInitM1Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103bb4:	d0a03917 	ldw	r2,-32540(gp)
81103bb8:	10800317 	ldw	r2,12(r2)
81103bbc:	10800037 	ldwio	r2,0(r2)
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103bc0:	1080100c 	andi	r2,r2,64
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103bc4:	103ff11e 	bne	r2,zero,81103b8c <__reset+0xfb0e3b8c>
				break;
			}
		}
	}

	return bStatus;
81103bc8:	e0bffe17 	ldw	r2,-8(fp)
}
81103bcc:	e037883a 	mov	sp,fp
81103bd0:	dfc00117 	ldw	ra,4(sp)
81103bd4:	df000017 	ldw	fp,0(sp)
81103bd8:	dec00204 	addi	sp,sp,8
81103bdc:	f800283a 	ret

81103be0 <bSdmaInitM2Dma>:

bool bSdmaInitM2Dma(void) {
81103be0:	defffc04 	addi	sp,sp,-16
81103be4:	de00012e 	bgeu	sp,et,81103bec <bSdmaInitM2Dma+0xc>
81103be8:	003b68fa 	trap	3
81103bec:	dfc00315 	stw	ra,12(sp)
81103bf0:	df000215 	stw	fp,8(sp)
81103bf4:	df000204 	addi	fp,sp,8
	bool bStatus = TRUE;
81103bf8:	00800044 	movi	r2,1
81103bfc:	e0bffe15 	stw	r2,-8(fp)
	alt_u16 usiCounter = 0;
81103c00:	e03fff0d 	sth	zero,-4(fp)

	// open dma device
	pxDmaM2Dev = alt_msgdma_open((char *) SDMA_DMA_M2_NAME);
81103c04:	01204574 	movhi	r4,33045
81103c08:	212f7a04 	addi	r4,r4,-16920
81103c0c:	11497540 	call	81149754 <alt_msgdma_open>
81103c10:	d0a03a15 	stw	r2,-32536(gp)

	// check if the device was opened
	if (pxDmaM2Dev == NULL) {
81103c14:	d0a03a17 	ldw	r2,-32536(gp)
81103c18:	1000021e 	bne	r2,zero,81103c24 <bSdmaInitM2Dma+0x44>
		// device not opened
		bStatus = FALSE;
81103c1c:	e03ffe15 	stw	zero,-8(fp)
81103c20:	00001506 	br	81103c78 <bSdmaInitM2Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
81103c24:	d0a03a17 	ldw	r2,-32536(gp)
81103c28:	10800317 	ldw	r2,12(r2)
81103c2c:	10800104 	addi	r2,r2,4
81103c30:	00c00084 	movi	r3,2
81103c34:	10c00035 	stwio	r3,0(r2)
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103c38:	00000a06 	br	81103c64 <bSdmaInitM2Dma+0x84>
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
			usleep(1);
81103c3c:	01000044 	movi	r4,1
81103c40:	11376bc0 	call	811376bc <usleep>
			usiCounter++;
81103c44:	e0bfff0b 	ldhu	r2,-4(fp)
81103c48:	10800044 	addi	r2,r2,1
81103c4c:	e0bfff0d 	sth	r2,-4(fp)
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
81103c50:	e0bfff0b 	ldhu	r2,-4(fp)
81103c54:	1084e230 	cmpltui	r2,r2,5000
81103c58:	1000021e 	bne	r2,zero,81103c64 <bSdmaInitM2Dma+0x84>
				bStatus = FALSE;
81103c5c:	e03ffe15 	stw	zero,-8(fp)
				break;
81103c60:	00000506 	br	81103c78 <bSdmaInitM2Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103c64:	d0a03a17 	ldw	r2,-32536(gp)
81103c68:	10800317 	ldw	r2,12(r2)
81103c6c:	10800037 	ldwio	r2,0(r2)
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103c70:	1080100c 	andi	r2,r2,64
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103c74:	103ff11e 	bne	r2,zero,81103c3c <__reset+0xfb0e3c3c>
				break;
			}
		}
	}

	return bStatus;
81103c78:	e0bffe17 	ldw	r2,-8(fp)
}
81103c7c:	e037883a 	mov	sp,fp
81103c80:	dfc00117 	ldw	ra,4(sp)
81103c84:	df000017 	ldw	fp,0(sp)
81103c88:	dec00204 	addi	sp,sp,8
81103c8c:	f800283a 	ret

81103c90 <bSdmaDmaM1Transfer>:

bool bSdmaDmaM1Transfer(alt_u32 *uliDdrInitialAddr,
		alt_u16 usiTransferSizeInBlocks, alt_u8 ucBufferSide,
		alt_u8 ucChBufferId) {
81103c90:	deffe804 	addi	sp,sp,-96
81103c94:	de00012e 	bgeu	sp,et,81103c9c <bSdmaDmaM1Transfer+0xc>
81103c98:	003b68fa 	trap	3
81103c9c:	dfc01715 	stw	ra,92(sp)
81103ca0:	df001615 	stw	fp,88(sp)
81103ca4:	dc001515 	stw	r16,84(sp)
81103ca8:	df001604 	addi	fp,sp,88
81103cac:	e13ffb15 	stw	r4,-20(fp)
81103cb0:	2809883a 	mov	r4,r5
81103cb4:	3007883a 	mov	r3,r6
81103cb8:	3805883a 	mov	r2,r7
81103cbc:	e13ffc0d 	sth	r4,-16(fp)
81103cc0:	e0fffd05 	stb	r3,-12(fp)
81103cc4:	e0bffe05 	stb	r2,-8(fp)
81103cc8:	defff004 	addi	sp,sp,-64
81103ccc:	d8800904 	addi	r2,sp,36
81103cd0:	108007c4 	addi	r2,r2,31
81103cd4:	1004d17a 	srli	r2,r2,5
81103cd8:	1020917a 	slli	r16,r2,5
	bool bStatus = TRUE;
81103cdc:	00800044 	movi	r2,1
81103ce0:	e0bff315 	stw	r2,-52(fp)
	alt_u16 usiCnt = 0;
81103ce4:	e03ff70d 	sth	zero,-36(fp)

	alt_msgdma_extended_descriptor xDmaExtendedDescriptor;

	alt_u32 uliDestAddrLow = 0;
81103ce8:	e03ff415 	stw	zero,-48(fp)
	alt_u32 uliDestAddrHigh = 0;
81103cec:	e03ff515 	stw	zero,-44(fp)

	alt_u32 uliSrcAddrLow = 0;
81103cf0:	e03ff815 	stw	zero,-32(fp)
	alt_u32 uliSrcAddrHigh = 0;
81103cf4:	e03ff915 	stw	zero,-28(fp)

	alt_u32 uliControlBits = 0x00000000;
81103cf8:	e03ffa15 	stw	zero,-24(fp)

	bool bBufferEmptyFlag = FALSE;
81103cfc:	e03ff615 	stw	zero,-40(fp)

	switch (ucChBufferId) {
81103d00:	e0bffe03 	ldbu	r2,-8(fp)
81103d04:	10c00228 	cmpgeui	r3,r2,8
81103d08:	1800b81e 	bne	r3,zero,81103fec <bSdmaDmaM1Transfer+0x35c>
81103d0c:	100690ba 	slli	r3,r2,2
81103d10:	00a04434 	movhi	r2,33040
81103d14:	108f4904 	addi	r2,r2,15652
81103d18:	1885883a 	add	r2,r3,r2
81103d1c:	10800017 	ldw	r2,0(r2)
81103d20:	1000683a 	jmp	r2
81103d24:	81103d44 	addi	r4,r16,16629
81103d28:	81103d98 	cmpnei	r4,r16,16630
81103d2c:	81103df4 	orhi	r4,r16,16631
81103d30:	81103e48 	cmpgei	r4,r16,16633
81103d34:	81103e9c 	xori	r4,r16,16634
81103d38:	81103ef0 	cmpltui	r4,r16,16635
81103d3c:	81103f44 	addi	r4,r16,16637
81103d40:	81103f98 	cmpnei	r4,r16,16638
	case eSdmaCh1Buffer:
		switch (ucBufferSide) {
81103d44:	e0bffd03 	ldbu	r2,-12(fp)
81103d48:	10000826 	beq	r2,zero,81103d6c <bSdmaDmaM1Transfer+0xdc>
81103d4c:	10800060 	cmpeqi	r2,r2,1
81103d50:	10000d26 	beq	r2,zero,81103d88 <bSdmaDmaM1Transfer+0xf8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_LOW;
81103d54:	e03ff415 	stw	zero,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_HIGH;
81103d58:	00800044 	movi	r2,1
81103d5c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh1RightBufferEmpty();
81103d60:	11066500 	call	81106650 <bFeebGetCh1RightBufferEmpty>
81103d64:	e0bff615 	stw	r2,-40(fp)
			break;
81103d68:	00000a06 	br	81103d94 <bSdmaDmaM1Transfer+0x104>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_LOW;
81103d6c:	00800074 	movhi	r2,1
81103d70:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_HIGH;
81103d74:	00800044 	movi	r2,1
81103d78:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh1LeftBufferEmpty();
81103d7c:	11065e80 	call	811065e8 <bFeebGetCh1LeftBufferEmpty>
81103d80:	e0bff615 	stw	r2,-40(fp)
			break;
81103d84:	00000306 	br	81103d94 <bSdmaDmaM1Transfer+0x104>
		default:
			bStatus = FALSE;
81103d88:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81103d8c:	e03ff615 	stw	zero,-40(fp)
			break;
81103d90:	0001883a 	nop
		}
		break;
81103d94:	00009706 	br	81103ff4 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh2Buffer:
		switch (ucBufferSide) {
81103d98:	e0bffd03 	ldbu	r2,-12(fp)
81103d9c:	10000926 	beq	r2,zero,81103dc4 <bSdmaDmaM1Transfer+0x134>
81103da0:	10800060 	cmpeqi	r2,r2,1
81103da4:	10000f26 	beq	r2,zero,81103de4 <bSdmaDmaM1Transfer+0x154>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_LOW;
81103da8:	00880004 	movi	r2,8192
81103dac:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_HIGH;
81103db0:	00800044 	movi	r2,1
81103db4:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh2RightBufferEmpty();
81103db8:	11067200 	call	81106720 <bFeebGetCh2RightBufferEmpty>
81103dbc:	e0bff615 	stw	r2,-40(fp)
			break;
81103dc0:	00000b06 	br	81103df0 <bSdmaDmaM1Transfer+0x160>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_LOW;
81103dc4:	00800074 	movhi	r2,1
81103dc8:	10880004 	addi	r2,r2,8192
81103dcc:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_HIGH;
81103dd0:	00800044 	movi	r2,1
81103dd4:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh2LeftBufferEmpty();
81103dd8:	11066b80 	call	811066b8 <bFeebGetCh2LeftBufferEmpty>
81103ddc:	e0bff615 	stw	r2,-40(fp)
			break;
81103de0:	00000306 	br	81103df0 <bSdmaDmaM1Transfer+0x160>
		default:
			bStatus = FALSE;
81103de4:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81103de8:	e03ff615 	stw	zero,-40(fp)
			break;
81103dec:	0001883a 	nop
		}
		break;
81103df0:	00008006 	br	81103ff4 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh3Buffer:
		switch (ucBufferSide) {
81103df4:	e0bffd03 	ldbu	r2,-12(fp)
81103df8:	10000826 	beq	r2,zero,81103e1c <bSdmaDmaM1Transfer+0x18c>
81103dfc:	10800060 	cmpeqi	r2,r2,1
81103e00:	10000d26 	beq	r2,zero,81103e38 <bSdmaDmaM1Transfer+0x1a8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_LOW;
81103e04:	00900004 	movi	r2,16384
81103e08:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_HIGH;
81103e0c:	00800044 	movi	r2,1
81103e10:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103e14:	e03ff615 	stw	zero,-40(fp)
			break;
81103e18:	00000a06 	br	81103e44 <bSdmaDmaM1Transfer+0x1b4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_LOW;
81103e1c:	00800074 	movhi	r2,1
81103e20:	10900004 	addi	r2,r2,16384
81103e24:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_HIGH;
81103e28:	00800044 	movi	r2,1
81103e2c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103e30:	e03ff615 	stw	zero,-40(fp)
			break;
81103e34:	00000306 	br	81103e44 <bSdmaDmaM1Transfer+0x1b4>
		default:
			bStatus = FALSE;
81103e38:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81103e3c:	e03ff615 	stw	zero,-40(fp)
			break;
81103e40:	0001883a 	nop
		}
		break;
81103e44:	00006b06 	br	81103ff4 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh4Buffer:
		switch (ucBufferSide) {
81103e48:	e0bffd03 	ldbu	r2,-12(fp)
81103e4c:	10000826 	beq	r2,zero,81103e70 <bSdmaDmaM1Transfer+0x1e0>
81103e50:	10800060 	cmpeqi	r2,r2,1
81103e54:	10000d26 	beq	r2,zero,81103e8c <bSdmaDmaM1Transfer+0x1fc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_LOW;
81103e58:	00980004 	movi	r2,24576
81103e5c:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_HIGH;
81103e60:	00800044 	movi	r2,1
81103e64:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103e68:	e03ff615 	stw	zero,-40(fp)
			break;
81103e6c:	00000a06 	br	81103e98 <bSdmaDmaM1Transfer+0x208>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_LOW;
81103e70:	00800074 	movhi	r2,1
81103e74:	10980004 	addi	r2,r2,24576
81103e78:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_HIGH;
81103e7c:	00800044 	movi	r2,1
81103e80:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103e84:	e03ff615 	stw	zero,-40(fp)
			break;
81103e88:	00000306 	br	81103e98 <bSdmaDmaM1Transfer+0x208>
		default:
			bStatus = FALSE;
81103e8c:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81103e90:	e03ff615 	stw	zero,-40(fp)
			break;
81103e94:	0001883a 	nop
		}
		break;
81103e98:	00005606 	br	81103ff4 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh5Buffer:
		switch (ucBufferSide) {
81103e9c:	e0bffd03 	ldbu	r2,-12(fp)
81103ea0:	10000826 	beq	r2,zero,81103ec4 <bSdmaDmaM1Transfer+0x234>
81103ea4:	10800060 	cmpeqi	r2,r2,1
81103ea8:	10000d26 	beq	r2,zero,81103ee0 <bSdmaDmaM1Transfer+0x250>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_LOW;
81103eac:	00a00014 	movui	r2,32768
81103eb0:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_HIGH;
81103eb4:	00800044 	movi	r2,1
81103eb8:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103ebc:	e03ff615 	stw	zero,-40(fp)
			break;
81103ec0:	00000a06 	br	81103eec <bSdmaDmaM1Transfer+0x25c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_LOW;
81103ec4:	008000b4 	movhi	r2,2
81103ec8:	10a00004 	addi	r2,r2,-32768
81103ecc:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_HIGH;
81103ed0:	00800044 	movi	r2,1
81103ed4:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103ed8:	e03ff615 	stw	zero,-40(fp)
			break;
81103edc:	00000306 	br	81103eec <bSdmaDmaM1Transfer+0x25c>
		default:
			bStatus = FALSE;
81103ee0:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81103ee4:	e03ff615 	stw	zero,-40(fp)
			break;
81103ee8:	0001883a 	nop
		}
		break;
81103eec:	00004106 	br	81103ff4 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh6Buffer:
		switch (ucBufferSide) {
81103ef0:	e0bffd03 	ldbu	r2,-12(fp)
81103ef4:	10000826 	beq	r2,zero,81103f18 <bSdmaDmaM1Transfer+0x288>
81103ef8:	10800060 	cmpeqi	r2,r2,1
81103efc:	10000d26 	beq	r2,zero,81103f34 <bSdmaDmaM1Transfer+0x2a4>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_LOW;
81103f00:	00a80014 	movui	r2,40960
81103f04:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_HIGH;
81103f08:	00800044 	movi	r2,1
81103f0c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103f10:	e03ff615 	stw	zero,-40(fp)
			break;
81103f14:	00000a06 	br	81103f40 <bSdmaDmaM1Transfer+0x2b0>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_LOW;
81103f18:	008000b4 	movhi	r2,2
81103f1c:	10a80004 	addi	r2,r2,-24576
81103f20:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_HIGH;
81103f24:	00800044 	movi	r2,1
81103f28:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103f2c:	e03ff615 	stw	zero,-40(fp)
			break;
81103f30:	00000306 	br	81103f40 <bSdmaDmaM1Transfer+0x2b0>
		default:
			bStatus = FALSE;
81103f34:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81103f38:	e03ff615 	stw	zero,-40(fp)
			break;
81103f3c:	0001883a 	nop
		}
		break;
81103f40:	00002c06 	br	81103ff4 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh7Buffer:
		switch (ucBufferSide) {
81103f44:	e0bffd03 	ldbu	r2,-12(fp)
81103f48:	10000826 	beq	r2,zero,81103f6c <bSdmaDmaM1Transfer+0x2dc>
81103f4c:	10800060 	cmpeqi	r2,r2,1
81103f50:	10000d26 	beq	r2,zero,81103f88 <bSdmaDmaM1Transfer+0x2f8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_LOW;
81103f54:	00b00014 	movui	r2,49152
81103f58:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_HIGH;
81103f5c:	00800044 	movi	r2,1
81103f60:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103f64:	e03ff615 	stw	zero,-40(fp)
			break;
81103f68:	00000a06 	br	81103f94 <bSdmaDmaM1Transfer+0x304>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_LOW;
81103f6c:	008000b4 	movhi	r2,2
81103f70:	10b00004 	addi	r2,r2,-16384
81103f74:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_HIGH;
81103f78:	00800044 	movi	r2,1
81103f7c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103f80:	e03ff615 	stw	zero,-40(fp)
			break;
81103f84:	00000306 	br	81103f94 <bSdmaDmaM1Transfer+0x304>
		default:
			bStatus = FALSE;
81103f88:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81103f8c:	e03ff615 	stw	zero,-40(fp)
			break;
81103f90:	0001883a 	nop
		}
		break;
81103f94:	00001706 	br	81103ff4 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh8Buffer:
		switch (ucBufferSide) {
81103f98:	e0bffd03 	ldbu	r2,-12(fp)
81103f9c:	10000826 	beq	r2,zero,81103fc0 <bSdmaDmaM1Transfer+0x330>
81103fa0:	10800060 	cmpeqi	r2,r2,1
81103fa4:	10000d26 	beq	r2,zero,81103fdc <bSdmaDmaM1Transfer+0x34c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_LOW;
81103fa8:	00b80014 	movui	r2,57344
81103fac:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_HIGH;
81103fb0:	00800044 	movi	r2,1
81103fb4:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103fb8:	e03ff615 	stw	zero,-40(fp)
			break;
81103fbc:	00000a06 	br	81103fe8 <bSdmaDmaM1Transfer+0x358>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_LOW;
81103fc0:	008000b4 	movhi	r2,2
81103fc4:	10b80004 	addi	r2,r2,-8192
81103fc8:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_HIGH;
81103fcc:	00800044 	movi	r2,1
81103fd0:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103fd4:	e03ff615 	stw	zero,-40(fp)
			break;
81103fd8:	00000306 	br	81103fe8 <bSdmaDmaM1Transfer+0x358>
		default:
			bStatus = FALSE;
81103fdc:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81103fe0:	e03ff615 	stw	zero,-40(fp)
			break;
81103fe4:	0001883a 	nop
		}
		break;
81103fe8:	00000206 	br	81103ff4 <bSdmaDmaM1Transfer+0x364>
	default:
		bStatus = FALSE;
81103fec:	e03ff315 	stw	zero,-52(fp)
		break;
81103ff0:	0001883a 	nop
	}

	uliSrcAddrLow = (alt_u32) SDMA_M1_BASE_ADDR_LOW
81103ff4:	e0bffb17 	ldw	r2,-20(fp)
81103ff8:	e0bff815 	stw	r2,-32(fp)
			+ (alt_u32) uliDdrInitialAddr;
	uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
81103ffc:	e03ff915 	stw	zero,-28(fp)

	if ((bStatus) && (bBufferEmptyFlag) && (usiTransferSizeInBlocks <= 16)) {
81104000:	e0bff317 	ldw	r2,-52(fp)
81104004:	10003226 	beq	r2,zero,811040d0 <bSdmaDmaM1Transfer+0x440>
81104008:	e0bff617 	ldw	r2,-40(fp)
8110400c:	10003026 	beq	r2,zero,811040d0 <bSdmaDmaM1Transfer+0x440>
81104010:	e0bffc0b 	ldhu	r2,-16(fp)
81104014:	10800468 	cmpgeui	r2,r2,17
81104018:	10002d1e 	bne	r2,zero,811040d0 <bSdmaDmaM1Transfer+0x440>
		if (pxDmaM1Dev == NULL) {
8110401c:	d0a03917 	ldw	r2,-32540(gp)
81104020:	1000041e 	bne	r2,zero,81104034 <bSdmaDmaM1Transfer+0x3a4>
			bStatus = FALSE;
81104024:	e03ff315 	stw	zero,-52(fp)
81104028:	00002906 	br	811040d0 <bSdmaDmaM1Transfer+0x440>
//			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
8110402c:	01000044 	movi	r4,1
81104030:	1135c480 	call	81135c48 <alt_busy_sleep>
			bStatus = FALSE;
		} else {
//			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81104034:	d0a03917 	ldw	r2,-32540(gp)
81104038:	10800317 	ldw	r2,12(r2)
8110403c:	10800037 	ldwio	r2,0(r2)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
81104040:	1080010c 	andi	r2,r2,4
		if (pxDmaM1Dev == NULL) {
			bStatus = FALSE;
		} else {
//			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
81104044:	103ff91e 	bne	r2,zero,8110402c <__reset+0xfb0e402c>
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
				}
				if (iMsgdmaConstructExtendedMmToMmDescriptor(pxDmaM1Dev,
81104048:	d2203917 	ldw	r8,-32540(gp)
8110404c:	e1bff817 	ldw	r6,-32(fp)
81104050:	e1fff417 	ldw	r7,-48(fp)
81104054:	e0bffc0b 	ldhu	r2,-16(fp)
81104058:	10802224 	muli	r2,r2,136
8110405c:	e0fff917 	ldw	r3,-28(fp)
81104060:	e13ff517 	ldw	r4,-44(fp)
81104064:	01400044 	movi	r5,1
81104068:	d9400815 	stw	r5,32(sp)
8110406c:	01400044 	movi	r5,1
81104070:	d9400715 	stw	r5,28(sp)
81104074:	01400044 	movi	r5,1
81104078:	d9400615 	stw	r5,24(sp)
8110407c:	01400044 	movi	r5,1
81104080:	d9400515 	stw	r5,20(sp)
81104084:	01400044 	movi	r5,1
81104088:	d9400415 	stw	r5,16(sp)
8110408c:	d9000315 	stw	r4,12(sp)
81104090:	d8c00215 	stw	r3,8(sp)
81104094:	e0fffa17 	ldw	r3,-24(fp)
81104098:	d8c00115 	stw	r3,4(sp)
8110409c:	d8800015 	stw	r2,0(sp)
811040a0:	800b883a 	mov	r5,r16
811040a4:	4009883a 	mov	r4,r8
811040a8:	110bd3c0 	call	8110bd3c <iMsgdmaConstructExtendedMmToMmDescriptor>
811040ac:	10000226 	beq	r2,zero,811040b8 <bSdmaDmaM1Transfer+0x428>
						&xDmaExtendedDescriptor, (alt_u32 *) uliSrcAddrLow,
						(alt_u32 *) uliDestAddrLow,
						SDMA_PIXEL_BLOCK_SIZE_BYTES*usiTransferSizeInBlocks, uliControlBits,
						(alt_u32 *) uliSrcAddrHigh, (alt_u32 *) uliDestAddrHigh,
						1, 1, 1, 1, 1)) {
					bStatus = FALSE;
811040b0:	e03ff315 	stw	zero,-52(fp)
811040b4:	00000606 	br	811040d0 <bSdmaDmaM1Transfer+0x440>
//					break;
				} else {
					if (iMsgdmaExtendedDescriptorSyncTransfer(pxDmaM1Dev,
811040b8:	d0a03917 	ldw	r2,-32540(gp)
811040bc:	800b883a 	mov	r5,r16
811040c0:	1009883a 	mov	r4,r2
811040c4:	110be400 	call	8110be40 <iMsgdmaExtendedDescriptorSyncTransfer>
811040c8:	10000126 	beq	r2,zero,811040d0 <bSdmaDmaM1Transfer+0x440>
							&xDmaExtendedDescriptor)) {
						bStatus = FALSE;
811040cc:	e03ff315 	stw	zero,-52(fp)
//					uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
				}
//			}
		}
	}
	return bStatus;
811040d0:	e0bff317 	ldw	r2,-52(fp)
}
811040d4:	e6ffff04 	addi	sp,fp,-4
811040d8:	dfc00217 	ldw	ra,8(sp)
811040dc:	df000117 	ldw	fp,4(sp)
811040e0:	dc000017 	ldw	r16,0(sp)
811040e4:	dec00304 	addi	sp,sp,12
811040e8:	f800283a 	ret

811040ec <bSdmaDmaM2Transfer>:

bool bSdmaDmaM2Transfer(alt_u32 *uliDdrInitialAddr,
		alt_u16 usiTransferSizeInBlocks, alt_u8 ucBufferSide,
		alt_u8 ucChBufferId) {
811040ec:	deffe804 	addi	sp,sp,-96
811040f0:	de00012e 	bgeu	sp,et,811040f8 <bSdmaDmaM2Transfer+0xc>
811040f4:	003b68fa 	trap	3
811040f8:	dfc01715 	stw	ra,92(sp)
811040fc:	df001615 	stw	fp,88(sp)
81104100:	dc001515 	stw	r16,84(sp)
81104104:	df001604 	addi	fp,sp,88
81104108:	e13ffb15 	stw	r4,-20(fp)
8110410c:	2809883a 	mov	r4,r5
81104110:	3007883a 	mov	r3,r6
81104114:	3805883a 	mov	r2,r7
81104118:	e13ffc0d 	sth	r4,-16(fp)
8110411c:	e0fffd05 	stb	r3,-12(fp)
81104120:	e0bffe05 	stb	r2,-8(fp)
81104124:	defff004 	addi	sp,sp,-64
81104128:	d8800904 	addi	r2,sp,36
8110412c:	108007c4 	addi	r2,r2,31
81104130:	1004d17a 	srli	r2,r2,5
81104134:	1020917a 	slli	r16,r2,5
	bool bStatus = TRUE;
81104138:	00800044 	movi	r2,1
8110413c:	e0bff315 	stw	r2,-52(fp)
	alt_u16 usiCnt = 0;
81104140:	e03ff70d 	sth	zero,-36(fp)

	alt_msgdma_extended_descriptor xDmaExtendedDescriptor;

	alt_u32 uliDestAddrLow = 0;
81104144:	e03ff415 	stw	zero,-48(fp)
	alt_u32 uliDestAddrHigh = 0;
81104148:	e03ff515 	stw	zero,-44(fp)

	alt_u32 uliSrcAddrLow = 0;
8110414c:	e03ff815 	stw	zero,-32(fp)
	alt_u32 uliSrcAddrHigh = 0;
81104150:	e03ff915 	stw	zero,-28(fp)

	alt_u32 uliControlBits = 0x00000000;
81104154:	e03ffa15 	stw	zero,-24(fp)

	bool bBufferEmptyFlag = FALSE;
81104158:	e03ff615 	stw	zero,-40(fp)

	switch (ucChBufferId) {
8110415c:	e0bffe03 	ldbu	r2,-8(fp)
81104160:	10c00228 	cmpgeui	r3,r2,8
81104164:	1800b81e 	bne	r3,zero,81104448 <bSdmaDmaM2Transfer+0x35c>
81104168:	100690ba 	slli	r3,r2,2
8110416c:	00a04434 	movhi	r2,33040
81104170:	10906004 	addi	r2,r2,16768
81104174:	1885883a 	add	r2,r3,r2
81104178:	10800017 	ldw	r2,0(r2)
8110417c:	1000683a 	jmp	r2
81104180:	811041a0 	cmpeqi	r4,r16,16646
81104184:	811041f4 	orhi	r4,r16,16647
81104188:	81104250 	cmplti	r4,r16,16649
8110418c:	811042a4 	muli	r4,r16,16650
81104190:	811042f8 	rdprs	r4,r16,16651
81104194:	8110434c 	andi	r4,r16,16653
81104198:	811043a0 	cmpeqi	r4,r16,16654
8110419c:	811043f4 	orhi	r4,r16,16655
	case eSdmaCh1Buffer:
		switch (ucBufferSide) {
811041a0:	e0bffd03 	ldbu	r2,-12(fp)
811041a4:	10000826 	beq	r2,zero,811041c8 <bSdmaDmaM2Transfer+0xdc>
811041a8:	10800060 	cmpeqi	r2,r2,1
811041ac:	10000d26 	beq	r2,zero,811041e4 <bSdmaDmaM2Transfer+0xf8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_LOW;
811041b0:	e03ff415 	stw	zero,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_HIGH;
811041b4:	00800044 	movi	r2,1
811041b8:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh1RightBufferEmpty();
811041bc:	11066500 	call	81106650 <bFeebGetCh1RightBufferEmpty>
811041c0:	e0bff615 	stw	r2,-40(fp)
			break;
811041c4:	00000a06 	br	811041f0 <bSdmaDmaM2Transfer+0x104>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_LOW;
811041c8:	00800074 	movhi	r2,1
811041cc:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_HIGH;
811041d0:	00800044 	movi	r2,1
811041d4:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh1LeftBufferEmpty();
811041d8:	11065e80 	call	811065e8 <bFeebGetCh1LeftBufferEmpty>
811041dc:	e0bff615 	stw	r2,-40(fp)
			break;
811041e0:	00000306 	br	811041f0 <bSdmaDmaM2Transfer+0x104>
		default:
			bStatus = FALSE;
811041e4:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
811041e8:	e03ff615 	stw	zero,-40(fp)
			break;
811041ec:	0001883a 	nop
		}
		break;
811041f0:	00009706 	br	81104450 <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh2Buffer:
		switch (ucBufferSide) {
811041f4:	e0bffd03 	ldbu	r2,-12(fp)
811041f8:	10000926 	beq	r2,zero,81104220 <bSdmaDmaM2Transfer+0x134>
811041fc:	10800060 	cmpeqi	r2,r2,1
81104200:	10000f26 	beq	r2,zero,81104240 <bSdmaDmaM2Transfer+0x154>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_LOW;
81104204:	00880004 	movi	r2,8192
81104208:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_HIGH;
8110420c:	00800044 	movi	r2,1
81104210:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh2RightBufferEmpty();
81104214:	11067200 	call	81106720 <bFeebGetCh2RightBufferEmpty>
81104218:	e0bff615 	stw	r2,-40(fp)
			break;
8110421c:	00000b06 	br	8110424c <bSdmaDmaM2Transfer+0x160>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_LOW;
81104220:	00800074 	movhi	r2,1
81104224:	10880004 	addi	r2,r2,8192
81104228:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_HIGH;
8110422c:	00800044 	movi	r2,1
81104230:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh2LeftBufferEmpty();
81104234:	11066b80 	call	811066b8 <bFeebGetCh2LeftBufferEmpty>
81104238:	e0bff615 	stw	r2,-40(fp)
			break;
8110423c:	00000306 	br	8110424c <bSdmaDmaM2Transfer+0x160>
		default:
			bStatus = FALSE;
81104240:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81104244:	e03ff615 	stw	zero,-40(fp)
			break;
81104248:	0001883a 	nop
		}
		break;
8110424c:	00008006 	br	81104450 <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh3Buffer:
		switch (ucBufferSide) {
81104250:	e0bffd03 	ldbu	r2,-12(fp)
81104254:	10000826 	beq	r2,zero,81104278 <bSdmaDmaM2Transfer+0x18c>
81104258:	10800060 	cmpeqi	r2,r2,1
8110425c:	10000d26 	beq	r2,zero,81104294 <bSdmaDmaM2Transfer+0x1a8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_LOW;
81104260:	00900004 	movi	r2,16384
81104264:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_HIGH;
81104268:	00800044 	movi	r2,1
8110426c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81104270:	e03ff615 	stw	zero,-40(fp)
			break;
81104274:	00000a06 	br	811042a0 <bSdmaDmaM2Transfer+0x1b4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_LOW;
81104278:	00800074 	movhi	r2,1
8110427c:	10900004 	addi	r2,r2,16384
81104280:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_HIGH;
81104284:	00800044 	movi	r2,1
81104288:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
8110428c:	e03ff615 	stw	zero,-40(fp)
			break;
81104290:	00000306 	br	811042a0 <bSdmaDmaM2Transfer+0x1b4>
		default:
			bStatus = FALSE;
81104294:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81104298:	e03ff615 	stw	zero,-40(fp)
			break;
8110429c:	0001883a 	nop
		}
		break;
811042a0:	00006b06 	br	81104450 <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh4Buffer:
		switch (ucBufferSide) {
811042a4:	e0bffd03 	ldbu	r2,-12(fp)
811042a8:	10000826 	beq	r2,zero,811042cc <bSdmaDmaM2Transfer+0x1e0>
811042ac:	10800060 	cmpeqi	r2,r2,1
811042b0:	10000d26 	beq	r2,zero,811042e8 <bSdmaDmaM2Transfer+0x1fc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_LOW;
811042b4:	00980004 	movi	r2,24576
811042b8:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_HIGH;
811042bc:	00800044 	movi	r2,1
811042c0:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
811042c4:	e03ff615 	stw	zero,-40(fp)
			break;
811042c8:	00000a06 	br	811042f4 <bSdmaDmaM2Transfer+0x208>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_LOW;
811042cc:	00800074 	movhi	r2,1
811042d0:	10980004 	addi	r2,r2,24576
811042d4:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_HIGH;
811042d8:	00800044 	movi	r2,1
811042dc:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
811042e0:	e03ff615 	stw	zero,-40(fp)
			break;
811042e4:	00000306 	br	811042f4 <bSdmaDmaM2Transfer+0x208>
		default:
			bStatus = FALSE;
811042e8:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
811042ec:	e03ff615 	stw	zero,-40(fp)
			break;
811042f0:	0001883a 	nop
		}
		break;
811042f4:	00005606 	br	81104450 <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh5Buffer:
		switch (ucBufferSide) {
811042f8:	e0bffd03 	ldbu	r2,-12(fp)
811042fc:	10000826 	beq	r2,zero,81104320 <bSdmaDmaM2Transfer+0x234>
81104300:	10800060 	cmpeqi	r2,r2,1
81104304:	10000d26 	beq	r2,zero,8110433c <bSdmaDmaM2Transfer+0x250>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_LOW;
81104308:	00a00014 	movui	r2,32768
8110430c:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_HIGH;
81104310:	00800044 	movi	r2,1
81104314:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81104318:	e03ff615 	stw	zero,-40(fp)
			break;
8110431c:	00000a06 	br	81104348 <bSdmaDmaM2Transfer+0x25c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_LOW;
81104320:	008000b4 	movhi	r2,2
81104324:	10a00004 	addi	r2,r2,-32768
81104328:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_HIGH;
8110432c:	00800044 	movi	r2,1
81104330:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81104334:	e03ff615 	stw	zero,-40(fp)
			break;
81104338:	00000306 	br	81104348 <bSdmaDmaM2Transfer+0x25c>
		default:
			bStatus = FALSE;
8110433c:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81104340:	e03ff615 	stw	zero,-40(fp)
			break;
81104344:	0001883a 	nop
		}
		break;
81104348:	00004106 	br	81104450 <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh6Buffer:
		switch (ucBufferSide) {
8110434c:	e0bffd03 	ldbu	r2,-12(fp)
81104350:	10000826 	beq	r2,zero,81104374 <bSdmaDmaM2Transfer+0x288>
81104354:	10800060 	cmpeqi	r2,r2,1
81104358:	10000d26 	beq	r2,zero,81104390 <bSdmaDmaM2Transfer+0x2a4>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_LOW;
8110435c:	00a80014 	movui	r2,40960
81104360:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_HIGH;
81104364:	00800044 	movi	r2,1
81104368:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
8110436c:	e03ff615 	stw	zero,-40(fp)
			break;
81104370:	00000a06 	br	8110439c <bSdmaDmaM2Transfer+0x2b0>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_LOW;
81104374:	008000b4 	movhi	r2,2
81104378:	10a80004 	addi	r2,r2,-24576
8110437c:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_HIGH;
81104380:	00800044 	movi	r2,1
81104384:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81104388:	e03ff615 	stw	zero,-40(fp)
			break;
8110438c:	00000306 	br	8110439c <bSdmaDmaM2Transfer+0x2b0>
		default:
			bStatus = FALSE;
81104390:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81104394:	e03ff615 	stw	zero,-40(fp)
			break;
81104398:	0001883a 	nop
		}
		break;
8110439c:	00002c06 	br	81104450 <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh7Buffer:
		switch (ucBufferSide) {
811043a0:	e0bffd03 	ldbu	r2,-12(fp)
811043a4:	10000826 	beq	r2,zero,811043c8 <bSdmaDmaM2Transfer+0x2dc>
811043a8:	10800060 	cmpeqi	r2,r2,1
811043ac:	10000d26 	beq	r2,zero,811043e4 <bSdmaDmaM2Transfer+0x2f8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_LOW;
811043b0:	00b00014 	movui	r2,49152
811043b4:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_HIGH;
811043b8:	00800044 	movi	r2,1
811043bc:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
811043c0:	e03ff615 	stw	zero,-40(fp)
			break;
811043c4:	00000a06 	br	811043f0 <bSdmaDmaM2Transfer+0x304>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_LOW;
811043c8:	008000b4 	movhi	r2,2
811043cc:	10b00004 	addi	r2,r2,-16384
811043d0:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_HIGH;
811043d4:	00800044 	movi	r2,1
811043d8:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
811043dc:	e03ff615 	stw	zero,-40(fp)
			break;
811043e0:	00000306 	br	811043f0 <bSdmaDmaM2Transfer+0x304>
		default:
			bStatus = FALSE;
811043e4:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
811043e8:	e03ff615 	stw	zero,-40(fp)
			break;
811043ec:	0001883a 	nop
		}
		break;
811043f0:	00001706 	br	81104450 <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh8Buffer:
		switch (ucBufferSide) {
811043f4:	e0bffd03 	ldbu	r2,-12(fp)
811043f8:	10000826 	beq	r2,zero,8110441c <bSdmaDmaM2Transfer+0x330>
811043fc:	10800060 	cmpeqi	r2,r2,1
81104400:	10000d26 	beq	r2,zero,81104438 <bSdmaDmaM2Transfer+0x34c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_LOW;
81104404:	00b80014 	movui	r2,57344
81104408:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_HIGH;
8110440c:	00800044 	movi	r2,1
81104410:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81104414:	e03ff615 	stw	zero,-40(fp)
			break;
81104418:	00000a06 	br	81104444 <bSdmaDmaM2Transfer+0x358>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_LOW;
8110441c:	008000b4 	movhi	r2,2
81104420:	10b80004 	addi	r2,r2,-8192
81104424:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_HIGH;
81104428:	00800044 	movi	r2,1
8110442c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81104430:	e03ff615 	stw	zero,-40(fp)
			break;
81104434:	00000306 	br	81104444 <bSdmaDmaM2Transfer+0x358>
		default:
			bStatus = FALSE;
81104438:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
8110443c:	e03ff615 	stw	zero,-40(fp)
			break;
81104440:	0001883a 	nop
		}
		break;
81104444:	00000206 	br	81104450 <bSdmaDmaM2Transfer+0x364>
	default:
		bStatus = FALSE;
81104448:	e03ff315 	stw	zero,-52(fp)
		break;
8110444c:	0001883a 	nop
	}

	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
			+ (alt_u32) uliDdrInitialAddr;
81104450:	e0fffb17 	ldw	r3,-20(fp)
	default:
		bStatus = FALSE;
		break;
	}

	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
81104454:	00a00034 	movhi	r2,32768
81104458:	1885883a 	add	r2,r3,r2
8110445c:	e0bff815 	stw	r2,-32(fp)
			+ (alt_u32) uliDdrInitialAddr;
	uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
81104460:	e03ff915 	stw	zero,-28(fp)

	if ((bStatus) && (bBufferEmptyFlag) && (usiTransferSizeInBlocks <= 16)) {
81104464:	e0bff317 	ldw	r2,-52(fp)
81104468:	10003226 	beq	r2,zero,81104534 <bSdmaDmaM2Transfer+0x448>
8110446c:	e0bff617 	ldw	r2,-40(fp)
81104470:	10003026 	beq	r2,zero,81104534 <bSdmaDmaM2Transfer+0x448>
81104474:	e0bffc0b 	ldhu	r2,-16(fp)
81104478:	10800468 	cmpgeui	r2,r2,17
8110447c:	10002d1e 	bne	r2,zero,81104534 <bSdmaDmaM2Transfer+0x448>
		if (pxDmaM2Dev == NULL) {
81104480:	d0a03a17 	ldw	r2,-32536(gp)
81104484:	1000041e 	bne	r2,zero,81104498 <bSdmaDmaM2Transfer+0x3ac>
			bStatus = FALSE;
81104488:	e03ff315 	stw	zero,-52(fp)
8110448c:	00002906 	br	81104534 <bSdmaDmaM2Transfer+0x448>
//			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
81104490:	01000044 	movi	r4,1
81104494:	1135c480 	call	81135c48 <alt_busy_sleep>
			bStatus = FALSE;
		} else {
//			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81104498:	d0a03a17 	ldw	r2,-32536(gp)
8110449c:	10800317 	ldw	r2,12(r2)
811044a0:	10800037 	ldwio	r2,0(r2)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
811044a4:	1080010c 	andi	r2,r2,4
		if (pxDmaM2Dev == NULL) {
			bStatus = FALSE;
		} else {
//			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
811044a8:	103ff91e 	bne	r2,zero,81104490 <__reset+0xfb0e4490>
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
				}
				if (iMsgdmaConstructExtendedMmToMmDescriptor(pxDmaM2Dev,
811044ac:	d2203a17 	ldw	r8,-32536(gp)
811044b0:	e1bff817 	ldw	r6,-32(fp)
811044b4:	e1fff417 	ldw	r7,-48(fp)
811044b8:	e0bffc0b 	ldhu	r2,-16(fp)
811044bc:	10802224 	muli	r2,r2,136
811044c0:	e0fff917 	ldw	r3,-28(fp)
811044c4:	e13ff517 	ldw	r4,-44(fp)
811044c8:	01400044 	movi	r5,1
811044cc:	d9400815 	stw	r5,32(sp)
811044d0:	01400044 	movi	r5,1
811044d4:	d9400715 	stw	r5,28(sp)
811044d8:	01400044 	movi	r5,1
811044dc:	d9400615 	stw	r5,24(sp)
811044e0:	01400044 	movi	r5,1
811044e4:	d9400515 	stw	r5,20(sp)
811044e8:	01400044 	movi	r5,1
811044ec:	d9400415 	stw	r5,16(sp)
811044f0:	d9000315 	stw	r4,12(sp)
811044f4:	d8c00215 	stw	r3,8(sp)
811044f8:	e0fffa17 	ldw	r3,-24(fp)
811044fc:	d8c00115 	stw	r3,4(sp)
81104500:	d8800015 	stw	r2,0(sp)
81104504:	800b883a 	mov	r5,r16
81104508:	4009883a 	mov	r4,r8
8110450c:	110bd3c0 	call	8110bd3c <iMsgdmaConstructExtendedMmToMmDescriptor>
81104510:	10000226 	beq	r2,zero,8110451c <bSdmaDmaM2Transfer+0x430>
						&xDmaExtendedDescriptor, (alt_u32 *) uliSrcAddrLow,
						(alt_u32 *) uliDestAddrLow,
						SDMA_PIXEL_BLOCK_SIZE_BYTES*usiTransferSizeInBlocks, uliControlBits,
						(alt_u32 *) uliSrcAddrHigh, (alt_u32 *) uliDestAddrHigh,
						1, 1, 1, 1, 1)) {
					bStatus = FALSE;
81104514:	e03ff315 	stw	zero,-52(fp)
81104518:	00000606 	br	81104534 <bSdmaDmaM2Transfer+0x448>
//					break;
				} else {
					if (iMsgdmaExtendedDescriptorSyncTransfer(pxDmaM2Dev,
8110451c:	d0a03a17 	ldw	r2,-32536(gp)
81104520:	800b883a 	mov	r5,r16
81104524:	1009883a 	mov	r4,r2
81104528:	110be400 	call	8110be40 <iMsgdmaExtendedDescriptorSyncTransfer>
8110452c:	10000126 	beq	r2,zero,81104534 <bSdmaDmaM2Transfer+0x448>
							&xDmaExtendedDescriptor)) {
						bStatus = FALSE;
81104530:	e03ff315 	stw	zero,-52(fp)
//					uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
				}
//			}
		}
	}
	return bStatus;
81104534:	e0bff317 	ldw	r2,-52(fp)
}
81104538:	e6ffff04 	addi	sp,fp,-4
8110453c:	dfc00217 	ldw	ra,8(sp)
81104540:	df000117 	ldw	fp,4(sp)
81104544:	dc000017 	ldw	r16,0(sp)
81104548:	dec00304 	addi	sp,sp,12
8110454c:	f800283a 	ret

81104550 <bCommSetGlobalIrqEn>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bCommSetGlobalIrqEn(bool bGlobalIrqEnable, alt_u8 ucCommCh) {
81104550:	defff904 	addi	sp,sp,-28
81104554:	de00012e 	bgeu	sp,et,8110455c <bCommSetGlobalIrqEn+0xc>
81104558:	003b68fa 	trap	3
8110455c:	dfc00615 	stw	ra,24(sp)
81104560:	df000515 	stw	fp,20(sp)
81104564:	df000504 	addi	fp,sp,20
81104568:	e13ffe15 	stw	r4,-8(fp)
8110456c:	2805883a 	mov	r2,r5
81104570:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81104574:	00800044 	movi	r2,1
81104578:	e0bffb15 	stw	r2,-20(fp)
	alt_u32 uliReg = 0;
8110457c:	e03ffc15 	stw	zero,-16(fp)
	alt_u32 *puliCommAddr = 0;
81104580:	e03ffd15 	stw	zero,-12(fp)

	switch (ucCommCh) {
81104584:	e0bfff03 	ldbu	r2,-4(fp)
81104588:	10c00228 	cmpgeui	r3,r2,8
8110458c:	18002e1e 	bne	r3,zero,81104648 <bCommSetGlobalIrqEn+0xf8>
81104590:	100690ba 	slli	r3,r2,2
81104594:	00a04434 	movhi	r2,33040
81104598:	10916a04 	addi	r2,r2,17832
8110459c:	1885883a 	add	r2,r3,r2
811045a0:	10800017 	ldw	r2,0(r2)
811045a4:	1000683a 	jmp	r2
811045a8:	811045c8 	cmpgei	r4,r16,16663
811045ac:	811045d8 	cmpnei	r4,r16,16663
811045b0:	811045e8 	cmpgeui	r4,r16,16663
811045b4:	811045f8 	rdprs	r4,r16,16663
811045b8:	81104608 	cmpgei	r4,r16,16664
811045bc:	81104618 	cmpnei	r4,r16,16664
811045c0:	81104628 	cmpgeui	r4,r16,16664
811045c4:	81104638 	rdprs	r4,r16,16664
	case eCommSpwCh1:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
811045c8:	00a04834 	movhi	r2,33056
811045cc:	108b0004 	addi	r2,r2,11264
811045d0:	e0bffd15 	stw	r2,-12(fp)
		break;
811045d4:	00001e06 	br	81104650 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh2:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
811045d8:	00a04834 	movhi	r2,33056
811045dc:	108a0004 	addi	r2,r2,10240
811045e0:	e0bffd15 	stw	r2,-12(fp)
		break;
811045e4:	00001a06 	br	81104650 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh3:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
811045e8:	00a04834 	movhi	r2,33056
811045ec:	108b0004 	addi	r2,r2,11264
811045f0:	e0bffd15 	stw	r2,-12(fp)
		break;
811045f4:	00001606 	br	81104650 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh4:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
811045f8:	00a04834 	movhi	r2,33056
811045fc:	108a0004 	addi	r2,r2,10240
81104600:	e0bffd15 	stw	r2,-12(fp)
		break;
81104604:	00001206 	br	81104650 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh5:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81104608:	00a04834 	movhi	r2,33056
8110460c:	108b0004 	addi	r2,r2,11264
81104610:	e0bffd15 	stw	r2,-12(fp)
		break;
81104614:	00000e06 	br	81104650 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh6:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81104618:	00a04834 	movhi	r2,33056
8110461c:	108a0004 	addi	r2,r2,10240
81104620:	e0bffd15 	stw	r2,-12(fp)
		break;
81104624:	00000a06 	br	81104650 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh7:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81104628:	00a04834 	movhi	r2,33056
8110462c:	108b0004 	addi	r2,r2,11264
81104630:	e0bffd15 	stw	r2,-12(fp)
		break;
81104634:	00000606 	br	81104650 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh8:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81104638:	00a04834 	movhi	r2,33056
8110463c:	108a0004 	addi	r2,r2,10240
81104640:	e0bffd15 	stw	r2,-12(fp)
		break;
81104644:	00000206 	br	81104650 <bCommSetGlobalIrqEn+0x100>
	default:
		bStatus = FALSE;
81104648:	e03ffb15 	stw	zero,-20(fp)
		break;
8110464c:	0001883a 	nop
	}

	if (bStatus) {
81104650:	e0bffb17 	ldw	r2,-20(fp)
81104654:	10001326 	beq	r2,zero,811046a4 <bCommSetGlobalIrqEn+0x154>
		uliReg = uliCommReadReg(puliCommAddr,
81104658:	01400444 	movi	r5,17
8110465c:	e13ffd17 	ldw	r4,-12(fp)
81104660:	11047ec0 	call	811047ec <uliCommReadReg>
81104664:	e0bffc15 	stw	r2,-16(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (bGlobalIrqEnable) {
81104668:	e0bffe17 	ldw	r2,-8(fp)
8110466c:	10000426 	beq	r2,zero,81104680 <bCommSetGlobalIrqEn+0x130>
			uliReg |= COMM_IRQ_GLOBAL_EN_MSK;
81104670:	e0bffc17 	ldw	r2,-16(fp)
81104674:	10800074 	orhi	r2,r2,1
81104678:	e0bffc15 	stw	r2,-16(fp)
8110467c:	00000506 	br	81104694 <bCommSetGlobalIrqEn+0x144>
		} else {
			uliReg &= (~COMM_IRQ_GLOBAL_EN_MSK);
81104680:	e0fffc17 	ldw	r3,-16(fp)
81104684:	00bffff4 	movhi	r2,65535
81104688:	10bfffc4 	addi	r2,r2,-1
8110468c:	1884703a 	and	r2,r3,r2
81104690:	e0bffc15 	stw	r2,-16(fp)
		}

		vCommWriteReg(puliCommAddr, COMM_IRQ_CONTROL_REG_OFST, uliReg);
81104694:	e1bffc17 	ldw	r6,-16(fp)
81104698:	01400444 	movi	r5,17
8110469c:	e13ffd17 	ldw	r4,-12(fp)
811046a0:	11047980 	call	81104798 <vCommWriteReg>
	}

	return bStatus;
811046a4:	e0bffb17 	ldw	r2,-20(fp)
}
811046a8:	e037883a 	mov	sp,fp
811046ac:	dfc00117 	ldw	ra,4(sp)
811046b0:	df000017 	ldw	fp,0(sp)
811046b4:	dec00204 	addi	sp,sp,8
811046b8:	f800283a 	ret

811046bc <bCommInitCh>:

bool bCommInitCh(TCommChannel *pxCommCh, alt_u8 ucCommCh) {
811046bc:	defffb04 	addi	sp,sp,-20
811046c0:	de00012e 	bgeu	sp,et,811046c8 <bCommInitCh+0xc>
811046c4:	003b68fa 	trap	3
811046c8:	dfc00415 	stw	ra,16(sp)
811046cc:	df000315 	stw	fp,12(sp)
811046d0:	df000304 	addi	fp,sp,12
811046d4:	e13ffe15 	stw	r4,-8(fp)
811046d8:	2805883a 	mov	r2,r5
811046dc:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
811046e0:	00800044 	movi	r2,1
811046e4:	e0bffd15 	stw	r2,-12(fp)

	if (!bSpwcInitCh(&(pxCommCh->xSpacewire), ucCommCh)) {
811046e8:	e0bffe17 	ldw	r2,-8(fp)
811046ec:	10805704 	addi	r2,r2,348
811046f0:	e0ffff03 	ldbu	r3,-4(fp)
811046f4:	180b883a 	mov	r5,r3
811046f8:	1009883a 	mov	r4,r2
811046fc:	110a6a40 	call	8110a6a4 <bSpwcInitCh>
81104700:	1000011e 	bne	r2,zero,81104708 <bCommInitCh+0x4c>
		bStatus = FALSE;
81104704:	e03ffd15 	stw	zero,-12(fp)
	}
	vFeebInitIrq(ucCommCh);
81104708:	e0bfff03 	ldbu	r2,-4(fp)
8110470c:	1009883a 	mov	r4,r2
81104710:	11060680 	call	81106068 <vFeebInitIrq>

	if (!bFeebInitCh(&(pxCommCh->xFeeBuffer), ucCommCh)) {
81104714:	e0bffe17 	ldw	r2,-8(fp)
81104718:	10800904 	addi	r2,r2,36
8110471c:	e0ffff03 	ldbu	r3,-4(fp)
81104720:	180b883a 	mov	r5,r3
81104724:	1009883a 	mov	r4,r2
81104728:	1106b300 	call	81106b30 <bFeebInitCh>
8110472c:	1000011e 	bne	r2,zero,81104734 <bCommInitCh+0x78>
		bStatus = FALSE;
81104730:	e03ffd15 	stw	zero,-12(fp)
	}
	if (!bRmapInitCh(&(pxCommCh->xRmap), ucCommCh)) {
81104734:	e0bffe17 	ldw	r2,-8(fp)
81104738:	10801104 	addi	r2,r2,68
8110473c:	e0ffff03 	ldbu	r3,-4(fp)
81104740:	180b883a 	mov	r5,r3
81104744:	1009883a 	mov	r4,r2
81104748:	1109d000 	call	81109d00 <bRmapInitCh>
8110474c:	1000011e 	bne	r2,zero,81104754 <bCommInitCh+0x98>
		bStatus = FALSE;
81104750:	e03ffd15 	stw	zero,-12(fp)
	}
	vRmapInitIrq(ucCommCh);
81104754:	e0bfff03 	ldbu	r2,-4(fp)
81104758:	1009883a 	mov	r4,r2
8110475c:	110773c0 	call	8110773c <vRmapInitIrq>

	if (!bDpktInitCh(&(pxCommCh->xDataPacket), ucCommCh)) {
81104760:	e0bffe17 	ldw	r2,-8(fp)
81104764:	10800104 	addi	r2,r2,4
81104768:	e0ffff03 	ldbu	r3,-4(fp)
8110476c:	180b883a 	mov	r5,r3
81104770:	1009883a 	mov	r4,r2
81104774:	1104e640 	call	81104e64 <bDpktInitCh>
81104778:	1000011e 	bne	r2,zero,81104780 <bCommInitCh+0xc4>
		bStatus = FALSE;
8110477c:	e03ffd15 	stw	zero,-12(fp)
	}
	return bStatus;
81104780:	e0bffd17 	ldw	r2,-12(fp)
}
81104784:	e037883a 	mov	sp,fp
81104788:	dfc00117 	ldw	ra,4(sp)
8110478c:	df000017 	ldw	fp,0(sp)
81104790:	dec00204 	addi	sp,sp,8
81104794:	f800283a 	ret

81104798 <vCommWriteReg>:
//! [public functions]

//! [private functions]
static void vCommWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81104798:	defffc04 	addi	sp,sp,-16
8110479c:	de00012e 	bgeu	sp,et,811047a4 <vCommWriteReg+0xc>
811047a0:	003b68fa 	trap	3
811047a4:	df000315 	stw	fp,12(sp)
811047a8:	df000304 	addi	fp,sp,12
811047ac:	e13ffd15 	stw	r4,-12(fp)
811047b0:	e17ffe15 	stw	r5,-8(fp)
811047b4:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
811047b8:	e0bffe17 	ldw	r2,-8(fp)
811047bc:	1085883a 	add	r2,r2,r2
811047c0:	1085883a 	add	r2,r2,r2
811047c4:	1007883a 	mov	r3,r2
811047c8:	e0bffd17 	ldw	r2,-12(fp)
811047cc:	10c5883a 	add	r2,r2,r3
811047d0:	e0ffff17 	ldw	r3,-4(fp)
811047d4:	10c00015 	stw	r3,0(r2)
}
811047d8:	0001883a 	nop
811047dc:	e037883a 	mov	sp,fp
811047e0:	df000017 	ldw	fp,0(sp)
811047e4:	dec00104 	addi	sp,sp,4
811047e8:	f800283a 	ret

811047ec <uliCommReadReg>:

static alt_u32 uliCommReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
811047ec:	defffc04 	addi	sp,sp,-16
811047f0:	de00012e 	bgeu	sp,et,811047f8 <uliCommReadReg+0xc>
811047f4:	003b68fa 	trap	3
811047f8:	df000315 	stw	fp,12(sp)
811047fc:	df000304 	addi	fp,sp,12
81104800:	e13ffe15 	stw	r4,-8(fp)
81104804:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81104808:	e0bfff17 	ldw	r2,-4(fp)
8110480c:	1085883a 	add	r2,r2,r2
81104810:	1085883a 	add	r2,r2,r2
81104814:	1007883a 	mov	r3,r2
81104818:	e0bffe17 	ldw	r2,-8(fp)
8110481c:	10c5883a 	add	r2,r2,r3
81104820:	10800017 	ldw	r2,0(r2)
81104824:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81104828:	e0bffd17 	ldw	r2,-12(fp)
}
8110482c:	e037883a 	mov	sp,fp
81104830:	df000017 	ldw	fp,0(sp)
81104834:	dec00104 	addi	sp,sp,4
81104838:	f800283a 	ret

8110483c <bDpktSetPacketConfig>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bDpktSetPacketConfig(TDpktChannel *pxDpktCh) {
8110483c:	defffb04 	addi	sp,sp,-20
81104840:	de00012e 	bgeu	sp,et,81104848 <bDpktSetPacketConfig+0xc>
81104844:	003b68fa 	trap	3
81104848:	dfc00415 	stw	ra,16(sp)
8110484c:	df000315 	stw	fp,12(sp)
81104850:	df000304 	addi	fp,sp,12
81104854:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104858:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110485c:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104860:	e0bfff17 	ldw	r2,-4(fp)
81104864:	10007a26 	beq	r2,zero,81104a50 <bDpktSetPacketConfig+0x214>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104868:	e0bfff17 	ldw	r2,-4(fp)
8110486c:	10800017 	ldw	r2,0(r2)
81104870:	01400204 	movi	r5,8
81104874:	1009883a 	mov	r4,r2
81104878:	110502c0 	call	8110502c <uliDpktReadReg>
8110487c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
81104880:	e0bffe17 	ldw	r2,-8(fp)
81104884:	10bfffec 	andhi	r2,r2,65535
81104888:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
8110488c:	e0bfff17 	ldw	r2,-4(fp)
81104890:	1080010b 	ldhu	r2,4(r2)
81104894:	10bfffcc 	andi	r2,r2,65535

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
81104898:	e0fffe17 	ldw	r3,-8(fp)
8110489c:	1884b03a 	or	r2,r3,r2
811048a0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_Y_SIZE_MSK);
811048a4:	e0bffe17 	ldw	r2,-8(fp)
811048a8:	10bfffcc 	andi	r2,r2,65535
811048ac:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdYSize << 16));
811048b0:	e0bfff17 	ldw	r2,-4(fp)
811048b4:	1080018b 	ldhu	r2,6(r2)
811048b8:	10bfffcc 	andi	r2,r2,65535
811048bc:	1004943a 	slli	r2,r2,16
811048c0:	1007883a 	mov	r3,r2

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_Y_SIZE_MSK
811048c4:	e0bffe17 	ldw	r2,-8(fp)
811048c8:	10c4b03a 	or	r2,r2,r3
811048cc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdYSize << 16));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_1_REG_OFST,
811048d0:	e0bfff17 	ldw	r2,-4(fp)
811048d4:	10800017 	ldw	r2,0(r2)
811048d8:	e1bffe17 	ldw	r6,-8(fp)
811048dc:	01400204 	movi	r5,8
811048e0:	1009883a 	mov	r4,r2
811048e4:	1104fd80 	call	81104fd8 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
811048e8:	e0bfff17 	ldw	r2,-4(fp)
811048ec:	10800017 	ldw	r2,0(r2)
811048f0:	01400244 	movi	r5,9
811048f4:	1009883a 	mov	r4,r2
811048f8:	110502c0 	call	8110502c <uliDpktReadReg>
811048fc:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
81104900:	e0bffe17 	ldw	r2,-8(fp)
81104904:	10bfffec 	andhi	r2,r2,65535
81104908:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
8110490c:	e0bfff17 	ldw	r2,-4(fp)
81104910:	1080020b 	ldhu	r2,8(r2)
81104914:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
81104918:	e0fffe17 	ldw	r3,-8(fp)
8110491c:	1884b03a 	or	r2,r3,r2
81104920:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
81104924:	e0bffe17 	ldw	r2,-8(fp)
81104928:	10bfffcc 	andi	r2,r2,65535
8110492c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |=
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize
81104930:	e0bfff17 	ldw	r2,-4(fp)
81104934:	1080028b 	ldhu	r2,10(r2)
										<< 16));
81104938:	10bfffcc 	andi	r2,r2,65535
8110493c:	1004943a 	slli	r2,r2,16
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
		uliReg |=
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
81104940:	1007883a 	mov	r3,r2

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
		uliReg |=
81104944:	e0bffe17 	ldw	r2,-8(fp)
81104948:	10c4b03a 	or	r2,r2,r3
8110494c:	e0bffe15 	stw	r2,-8(fp)
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize
										<< 16));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_2_REG_OFST,
81104950:	e0bfff17 	ldw	r2,-4(fp)
81104954:	10800017 	ldw	r2,0(r2)
81104958:	e1bffe17 	ldw	r6,-8(fp)
8110495c:	01400244 	movi	r5,9
81104960:	1009883a 	mov	r4,r2
81104964:	1104fd80 	call	81104fd8 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104968:	e0bfff17 	ldw	r2,-4(fp)
8110496c:	10800017 	ldw	r2,0(r2)
81104970:	01400284 	movi	r5,10
81104974:	1009883a 	mov	r4,r2
81104978:	110502c0 	call	8110502c <uliDpktReadReg>
8110497c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
81104980:	e0bffe17 	ldw	r2,-8(fp)
81104984:	10bfffec 	andhi	r2,r2,65535
81104988:	e0bffe15 	stw	r2,-8(fp)
		uliReg |=
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiPacketLength
8110498c:	e0bfff17 	ldw	r2,-4(fp)
81104990:	1080030b 	ldhu	r2,12(r2)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
		uliReg |=
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
81104994:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
		uliReg |=
81104998:	e0fffe17 	ldw	r3,-8(fp)
8110499c:	1884b03a 	or	r2,r3,r2
811049a0:	e0bffe15 	stw	r2,-8(fp)
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiPacketLength
										<< 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_3_REG_OFST,
811049a4:	e0bfff17 	ldw	r2,-4(fp)
811049a8:	10800017 	ldw	r2,0(r2)
811049ac:	e1bffe17 	ldw	r6,-8(fp)
811049b0:	01400284 	movi	r5,10
811049b4:	1009883a 	mov	r4,r2
811049b8:	1104fd80 	call	81104fd8 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
811049bc:	e0bfff17 	ldw	r2,-4(fp)
811049c0:	10800017 	ldw	r2,0(r2)
811049c4:	014002c4 	movi	r5,11
811049c8:	1009883a 	mov	r4,r2
811049cc:	110502c0 	call	8110502c <uliDpktReadReg>
811049d0:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_4_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
811049d4:	e0fffe17 	ldw	r3,-8(fp)
811049d8:	00bfc004 	movi	r2,-256
811049dc:	1884703a 	and	r2,r3,r2
811049e0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
811049e4:	e0bfff17 	ldw	r2,-4(fp)
811049e8:	10800383 	ldbu	r2,14(r2)
811049ec:	10803fcc 	andi	r2,r2,255
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_4_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
811049f0:	e0fffe17 	ldw	r3,-8(fp)
811049f4:	1884b03a 	or	r2,r3,r2
811049f8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_NUMBER_MSK);
811049fc:	e0fffe17 	ldw	r3,-8(fp)
81104a00:	00bffff4 	movhi	r2,65535
81104a04:	10803fc4 	addi	r2,r2,255
81104a08:	1884703a 	and	r2,r3,r2
81104a0c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_NUMBER_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucCcdNumber << 8));
81104a10:	e0bfff17 	ldw	r2,-4(fp)
81104a14:	108003c3 	ldbu	r2,15(r2)
81104a18:	10803fcc 	andi	r2,r2,255
81104a1c:	1004923a 	slli	r2,r2,8
81104a20:	10bfffcc 	andi	r2,r2,65535

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_NUMBER_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_NUMBER_MSK
81104a24:	e0fffe17 	ldw	r3,-8(fp)
81104a28:	1884b03a 	or	r2,r3,r2
81104a2c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucCcdNumber << 8));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_4_REG_OFST,
81104a30:	e0bfff17 	ldw	r2,-4(fp)
81104a34:	10800017 	ldw	r2,0(r2)
81104a38:	e1bffe17 	ldw	r6,-8(fp)
81104a3c:	014002c4 	movi	r5,11
81104a40:	1009883a 	mov	r4,r2
81104a44:	1104fd80 	call	81104fd8 <vDpktWriteReg>
				uliReg);

		bStatus = TRUE;
81104a48:	00800044 	movi	r2,1
81104a4c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104a50:	e0bffd17 	ldw	r2,-12(fp)
}
81104a54:	e037883a 	mov	sp,fp
81104a58:	dfc00117 	ldw	ra,4(sp)
81104a5c:	df000017 	ldw	fp,0(sp)
81104a60:	dec00204 	addi	sp,sp,8
81104a64:	f800283a 	ret

81104a68 <bDpktGetPacketConfig>:

bool bDpktGetPacketConfig(TDpktChannel *pxDpktCh) {
81104a68:	defffb04 	addi	sp,sp,-20
81104a6c:	de00012e 	bgeu	sp,et,81104a74 <bDpktGetPacketConfig+0xc>
81104a70:	003b68fa 	trap	3
81104a74:	dfc00415 	stw	ra,16(sp)
81104a78:	df000315 	stw	fp,12(sp)
81104a7c:	df000304 	addi	fp,sp,12
81104a80:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104a84:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104a88:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104a8c:	e0bfff17 	ldw	r2,-4(fp)
81104a90:	10003a26 	beq	r2,zero,81104b7c <bDpktGetPacketConfig+0x114>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104a94:	e0bfff17 	ldw	r2,-4(fp)
81104a98:	10800017 	ldw	r2,0(r2)
81104a9c:	01400204 	movi	r5,8
81104aa0:	1009883a 	mov	r4,r2
81104aa4:	110502c0 	call	8110502c <uliDpktReadReg>
81104aa8:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_1_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiCcdXSize = (alt_u16)(
81104aac:	e0bffe17 	ldw	r2,-8(fp)
81104ab0:	1007883a 	mov	r3,r2
81104ab4:	e0bfff17 	ldw	r2,-4(fp)
81104ab8:	10c0010d 	sth	r3,4(r2)
				(uliReg & COMM_DATA_PKT_CCD_X_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiCcdYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_CCD_Y_SIZE_MSK) >> 16);
81104abc:	e0bffe17 	ldw	r2,-8(fp)
81104ac0:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_1_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiCcdXSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_CCD_X_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiCcdYSize = (alt_u16)(
81104ac4:	1007883a 	mov	r3,r2
81104ac8:	e0bfff17 	ldw	r2,-4(fp)
81104acc:	10c0018d 	sth	r3,6(r2)
				(uliReg & COMM_DATA_PKT_CCD_Y_SIZE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104ad0:	e0bfff17 	ldw	r2,-4(fp)
81104ad4:	10800017 	ldw	r2,0(r2)
81104ad8:	01400244 	movi	r5,9
81104adc:	1009883a 	mov	r4,r2
81104ae0:	110502c0 	call	8110502c <uliDpktReadReg>
81104ae4:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_2_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiDataYSize = (alt_u16)(
81104ae8:	e0bffe17 	ldw	r2,-8(fp)
81104aec:	1007883a 	mov	r3,r2
81104af0:	e0bfff17 	ldw	r2,-4(fp)
81104af4:	10c0020d 	sth	r3,8(r2)
				(uliReg & COMM_DATA_PKT_DATA_Y_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_OVER_Y_SIZE_MSK) >> 16);
81104af8:	e0bffe17 	ldw	r2,-8(fp)
81104afc:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_2_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiDataYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_DATA_Y_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize = (alt_u16)(
81104b00:	1007883a 	mov	r3,r2
81104b04:	e0bfff17 	ldw	r2,-4(fp)
81104b08:	10c0028d 	sth	r3,10(r2)
				(uliReg & COMM_DATA_PKT_OVER_Y_SIZE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104b0c:	e0bfff17 	ldw	r2,-4(fp)
81104b10:	10800017 	ldw	r2,0(r2)
81104b14:	01400284 	movi	r5,10
81104b18:	1009883a 	mov	r4,r2
81104b1c:	110502c0 	call	8110502c <uliDpktReadReg>
81104b20:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiPacketLength = (alt_u16)(
81104b24:	e0bffe17 	ldw	r2,-8(fp)
81104b28:	1007883a 	mov	r3,r2
81104b2c:	e0bfff17 	ldw	r2,-4(fp)
81104b30:	10c0030d 	sth	r3,12(r2)
				(uliReg & COMM_DATA_PKT_LENGTH_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104b34:	e0bfff17 	ldw	r2,-4(fp)
81104b38:	10800017 	ldw	r2,0(r2)
81104b3c:	014002c4 	movi	r5,11
81104b40:	1009883a 	mov	r4,r2
81104b44:	110502c0 	call	8110502c <uliDpktReadReg>
81104b48:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_4_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.ucFeeMode= (alt_u8)(
81104b4c:	e0bffe17 	ldw	r2,-8(fp)
81104b50:	1007883a 	mov	r3,r2
81104b54:	e0bfff17 	ldw	r2,-4(fp)
81104b58:	10c00385 	stb	r3,14(r2)
				(uliReg & COMM_DATA_PKT_FEE_MODE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.ucCcdNumber= (alt_u8)(
				(uliReg & COMM_DATA_PKT_CCD_NUMBER_MSK) >> 8);
81104b5c:	e0bffe17 	ldw	r2,-8(fp)
81104b60:	10bfc00c 	andi	r2,r2,65280
81104b64:	1004d23a 	srli	r2,r2,8
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_4_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.ucFeeMode= (alt_u8)(
				(uliReg & COMM_DATA_PKT_FEE_MODE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.ucCcdNumber= (alt_u8)(
81104b68:	1007883a 	mov	r3,r2
81104b6c:	e0bfff17 	ldw	r2,-4(fp)
81104b70:	10c003c5 	stb	r3,15(r2)
				(uliReg & COMM_DATA_PKT_CCD_NUMBER_MSK) >> 8);

		bStatus = TRUE;
81104b74:	00800044 	movi	r2,1
81104b78:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104b7c:	e0bffd17 	ldw	r2,-12(fp)
}
81104b80:	e037883a 	mov	sp,fp
81104b84:	dfc00117 	ldw	ra,4(sp)
81104b88:	df000017 	ldw	fp,0(sp)
81104b8c:	dec00204 	addi	sp,sp,8
81104b90:	f800283a 	ret

81104b94 <bDpktGetPacketHeader>:

bool bDpktGetPacketHeader(TDpktChannel *pxDpktCh) {
81104b94:	defffb04 	addi	sp,sp,-20
81104b98:	de00012e 	bgeu	sp,et,81104ba0 <bDpktGetPacketHeader+0xc>
81104b9c:	003b68fa 	trap	3
81104ba0:	dfc00415 	stw	ra,16(sp)
81104ba4:	df000315 	stw	fp,12(sp)
81104ba8:	df000304 	addi	fp,sp,12
81104bac:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104bb0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104bb4:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104bb8:	e0bfff17 	ldw	r2,-4(fp)
81104bbc:	10002026 	beq	r2,zero,81104c40 <bDpktGetPacketHeader+0xac>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104bc0:	e0bfff17 	ldw	r2,-4(fp)
81104bc4:	10800017 	ldw	r2,0(r2)
81104bc8:	01400304 	movi	r5,12
81104bcc:	1009883a 	mov	r4,r2
81104bd0:	110502c0 	call	8110502c <uliDpktReadReg>
81104bd4:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_HDR_1_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiLength = (alt_u16)(
81104bd8:	e0bffe17 	ldw	r2,-8(fp)
81104bdc:	1007883a 	mov	r3,r2
81104be0:	e0bfff17 	ldw	r2,-4(fp)
81104be4:	10c0040d 	sth	r3,16(r2)
				(uliReg & COMM_DATA_PKT_HDR_LENGTH_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiType = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_TYPE_MSK) >> 16);
81104be8:	e0bffe17 	ldw	r2,-8(fp)
81104bec:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_HDR_1_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiLength = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_LENGTH_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiType = (alt_u16)(
81104bf0:	1007883a 	mov	r3,r2
81104bf4:	e0bfff17 	ldw	r2,-4(fp)
81104bf8:	10c0048d 	sth	r3,18(r2)
				(uliReg & COMM_DATA_PKT_HDR_TYPE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104bfc:	e0bfff17 	ldw	r2,-4(fp)
81104c00:	10800017 	ldw	r2,0(r2)
81104c04:	01400344 	movi	r5,13
81104c08:	1009883a 	mov	r4,r2
81104c0c:	110502c0 	call	8110502c <uliDpktReadReg>
81104c10:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_HDR_2_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiFrameCounter = (alt_u16)(
81104c14:	e0bffe17 	ldw	r2,-8(fp)
81104c18:	1007883a 	mov	r3,r2
81104c1c:	e0bfff17 	ldw	r2,-4(fp)
81104c20:	10c0050d 	sth	r3,20(r2)
				(uliReg & COMM_DATA_PKT_HDR_FRAME_CNT_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiSequenceCounter = (alt_u16)(
				(uliReg & COMM_DATA_PKT_SEQ_CNT_MSK) >> 16);
81104c24:	e0bffe17 	ldw	r2,-8(fp)
81104c28:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_HDR_2_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiFrameCounter = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_FRAME_CNT_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiSequenceCounter = (alt_u16)(
81104c2c:	1007883a 	mov	r3,r2
81104c30:	e0bfff17 	ldw	r2,-4(fp)
81104c34:	10c0058d 	sth	r3,22(r2)
				(uliReg & COMM_DATA_PKT_SEQ_CNT_MSK) >> 16);

		bStatus = TRUE;
81104c38:	00800044 	movi	r2,1
81104c3c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104c40:	e0bffd17 	ldw	r2,-12(fp)
}
81104c44:	e037883a 	mov	sp,fp
81104c48:	dfc00117 	ldw	ra,4(sp)
81104c4c:	df000017 	ldw	fp,0(sp)
81104c50:	dec00204 	addi	sp,sp,8
81104c54:	f800283a 	ret

81104c58 <bDpktSetPixelDelay>:

bool bDpktSetPixelDelay(TDpktChannel *pxDpktCh) {
81104c58:	defffb04 	addi	sp,sp,-20
81104c5c:	de00012e 	bgeu	sp,et,81104c64 <bDpktSetPixelDelay+0xc>
81104c60:	003b68fa 	trap	3
81104c64:	dfc00415 	stw	ra,16(sp)
81104c68:	df000315 	stw	fp,12(sp)
81104c6c:	df000304 	addi	fp,sp,12
81104c70:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104c74:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104c78:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104c7c:	e0bfff17 	ldw	r2,-4(fp)
81104c80:	10004126 	beq	r2,zero,81104d88 <bDpktSetPixelDelay+0x130>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104c84:	e0bfff17 	ldw	r2,-4(fp)
81104c88:	10800017 	ldw	r2,0(r2)
81104c8c:	01400384 	movi	r5,14
81104c90:	1009883a 	mov	r4,r2
81104c94:	110502c0 	call	8110502c <uliDpktReadReg>
81104c98:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LINE_DLY_MSK);
81104c9c:	e0bffe17 	ldw	r2,-8(fp)
81104ca0:	10bfffec 	andhi	r2,r2,65535
81104ca4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_LINE_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiLineDelay << 0));
81104ca8:	e0bfff17 	ldw	r2,-4(fp)
81104cac:	1080060b 	ldhu	r2,24(r2)
81104cb0:	10bfffcc 	andi	r2,r2,65535

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LINE_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_LINE_DLY_MSK
81104cb4:	e0fffe17 	ldw	r3,-8(fp)
81104cb8:	1884b03a 	or	r2,r3,r2
81104cbc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiLineDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_1_REG_OFST,
81104cc0:	e0bfff17 	ldw	r2,-4(fp)
81104cc4:	10800017 	ldw	r2,0(r2)
81104cc8:	e1bffe17 	ldw	r6,-8(fp)
81104ccc:	01400384 	movi	r5,14
81104cd0:	1009883a 	mov	r4,r2
81104cd4:	1104fd80 	call	81104fd8 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104cd8:	e0bfff17 	ldw	r2,-4(fp)
81104cdc:	10800017 	ldw	r2,0(r2)
81104ce0:	014003c4 	movi	r5,15
81104ce4:	1009883a 	mov	r4,r2
81104ce8:	110502c0 	call	8110502c <uliDpktReadReg>
81104cec:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_COLUMN_DLY_MSK);
81104cf0:	e0bffe17 	ldw	r2,-8(fp)
81104cf4:	10bfffec 	andhi	r2,r2,65535
81104cf8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_COLUMN_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiColumnDelay << 0));
81104cfc:	e0bfff17 	ldw	r2,-4(fp)
81104d00:	1080068b 	ldhu	r2,26(r2)
81104d04:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_COLUMN_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_COLUMN_DLY_MSK
81104d08:	e0fffe17 	ldw	r3,-8(fp)
81104d0c:	1884b03a 	or	r2,r3,r2
81104d10:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiColumnDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_2_REG_OFST,
81104d14:	e0bfff17 	ldw	r2,-4(fp)
81104d18:	10800017 	ldw	r2,0(r2)
81104d1c:	e1bffe17 	ldw	r6,-8(fp)
81104d20:	014003c4 	movi	r5,15
81104d24:	1009883a 	mov	r4,r2
81104d28:	1104fd80 	call	81104fd8 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104d2c:	e0bfff17 	ldw	r2,-4(fp)
81104d30:	10800017 	ldw	r2,0(r2)
81104d34:	01400404 	movi	r5,16
81104d38:	1009883a 	mov	r4,r2
81104d3c:	110502c0 	call	8110502c <uliDpktReadReg>
81104d40:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_ADC_DLY_MSK);
81104d44:	e0bffe17 	ldw	r2,-8(fp)
81104d48:	10bfffec 	andhi	r2,r2,65535
81104d4c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_ADC_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiAdcDelay << 0));
81104d50:	e0bfff17 	ldw	r2,-4(fp)
81104d54:	1080070b 	ldhu	r2,28(r2)
81104d58:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_ADC_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_ADC_DLY_MSK
81104d5c:	e0fffe17 	ldw	r3,-8(fp)
81104d60:	1884b03a 	or	r2,r3,r2
81104d64:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiAdcDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_3_REG_OFST,
81104d68:	e0bfff17 	ldw	r2,-4(fp)
81104d6c:	10800017 	ldw	r2,0(r2)
81104d70:	e1bffe17 	ldw	r6,-8(fp)
81104d74:	01400404 	movi	r5,16
81104d78:	1009883a 	mov	r4,r2
81104d7c:	1104fd80 	call	81104fd8 <vDpktWriteReg>
				uliReg);

		bStatus = TRUE;
81104d80:	00800044 	movi	r2,1
81104d84:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104d88:	e0bffd17 	ldw	r2,-12(fp)
}
81104d8c:	e037883a 	mov	sp,fp
81104d90:	dfc00117 	ldw	ra,4(sp)
81104d94:	df000017 	ldw	fp,0(sp)
81104d98:	dec00204 	addi	sp,sp,8
81104d9c:	f800283a 	ret

81104da0 <bDpktGetPixelDelay>:

bool bDpktGetPixelDelay(TDpktChannel *pxDpktCh) {
81104da0:	defffb04 	addi	sp,sp,-20
81104da4:	de00012e 	bgeu	sp,et,81104dac <bDpktGetPixelDelay+0xc>
81104da8:	003b68fa 	trap	3
81104dac:	dfc00415 	stw	ra,16(sp)
81104db0:	df000315 	stw	fp,12(sp)
81104db4:	df000304 	addi	fp,sp,12
81104db8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104dbc:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104dc0:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104dc4:	e0bfff17 	ldw	r2,-4(fp)
81104dc8:	10002026 	beq	r2,zero,81104e4c <bDpktGetPixelDelay+0xac>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104dcc:	e0bfff17 	ldw	r2,-4(fp)
81104dd0:	10800017 	ldw	r2,0(r2)
81104dd4:	01400384 	movi	r5,14
81104dd8:	1009883a 	mov	r4,r2
81104ddc:	110502c0 	call	8110502c <uliDpktReadReg>
81104de0:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiLineDelay = (alt_u16)(
81104de4:	e0bffe17 	ldw	r2,-8(fp)
81104de8:	1007883a 	mov	r3,r2
81104dec:	e0bfff17 	ldw	r2,-4(fp)
81104df0:	10c0060d 	sth	r3,24(r2)
				(uliReg & COMM_DATA_PKT_LINE_DLY_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104df4:	e0bfff17 	ldw	r2,-4(fp)
81104df8:	10800017 	ldw	r2,0(r2)
81104dfc:	014003c4 	movi	r5,15
81104e00:	1009883a 	mov	r4,r2
81104e04:	110502c0 	call	8110502c <uliDpktReadReg>
81104e08:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiColumnDelay = (alt_u16)(
81104e0c:	e0bffe17 	ldw	r2,-8(fp)
81104e10:	1007883a 	mov	r3,r2
81104e14:	e0bfff17 	ldw	r2,-4(fp)
81104e18:	10c0068d 	sth	r3,26(r2)
				(uliReg & COMM_DATA_PKT_COLUMN_DLY_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104e1c:	e0bfff17 	ldw	r2,-4(fp)
81104e20:	10800017 	ldw	r2,0(r2)
81104e24:	01400404 	movi	r5,16
81104e28:	1009883a 	mov	r4,r2
81104e2c:	110502c0 	call	8110502c <uliDpktReadReg>
81104e30:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiAdcDelay = (alt_u16)(
81104e34:	e0bffe17 	ldw	r2,-8(fp)
81104e38:	1007883a 	mov	r3,r2
81104e3c:	e0bfff17 	ldw	r2,-4(fp)
81104e40:	10c0070d 	sth	r3,28(r2)
				(uliReg & COMM_DATA_PKT_ADC_DLY_MSK) >> 0);

		bStatus = TRUE;
81104e44:	00800044 	movi	r2,1
81104e48:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104e4c:	e0bffd17 	ldw	r2,-12(fp)
}
81104e50:	e037883a 	mov	sp,fp
81104e54:	dfc00117 	ldw	ra,4(sp)
81104e58:	df000017 	ldw	fp,0(sp)
81104e5c:	dec00204 	addi	sp,sp,8
81104e60:	f800283a 	ret

81104e64 <bDpktInitCh>:

bool bDpktInitCh(TDpktChannel *pxDpktCh, alt_u8 ucCommCh) {
81104e64:	defffb04 	addi	sp,sp,-20
81104e68:	de00012e 	bgeu	sp,et,81104e70 <bDpktInitCh+0xc>
81104e6c:	003b68fa 	trap	3
81104e70:	dfc00415 	stw	ra,16(sp)
81104e74:	df000315 	stw	fp,12(sp)
81104e78:	df000304 	addi	fp,sp,12
81104e7c:	e13ffe15 	stw	r4,-8(fp)
81104e80:	2805883a 	mov	r2,r5
81104e84:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81104e88:	e03ffd15 	stw	zero,-12(fp)

	if (pxDpktCh != NULL) {
81104e8c:	e0bffe17 	ldw	r2,-8(fp)
81104e90:	10004b26 	beq	r2,zero,81104fc0 <bDpktInitCh+0x15c>
		bStatus = TRUE;
81104e94:	00800044 	movi	r2,1
81104e98:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81104e9c:	e0bfff03 	ldbu	r2,-4(fp)
81104ea0:	10c00228 	cmpgeui	r3,r2,8
81104ea4:	1800361e 	bne	r3,zero,81104f80 <bDpktInitCh+0x11c>
81104ea8:	100690ba 	slli	r3,r2,2
81104eac:	00a04434 	movhi	r2,33040
81104eb0:	1093b004 	addi	r2,r2,20160
81104eb4:	1885883a 	add	r2,r3,r2
81104eb8:	10800017 	ldw	r2,0(r2)
81104ebc:	1000683a 	jmp	r2
81104ec0:	81104ee0 	cmpeqi	r4,r16,16699
81104ec4:	81104ef4 	orhi	r4,r16,16699
81104ec8:	81104f08 	cmpgei	r4,r16,16700
81104ecc:	81104f1c 	xori	r4,r16,16700
81104ed0:	81104f30 	cmpltui	r4,r16,16700
81104ed4:	81104f44 	addi	r4,r16,16701
81104ed8:	81104f58 	cmpnei	r4,r16,16701
81104edc:	81104f6c 	andhi	r4,r16,16701
		case eCommSpwCh1:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81104ee0:	e0fffe17 	ldw	r3,-8(fp)
81104ee4:	00a04834 	movhi	r2,33056
81104ee8:	108b0004 	addi	r2,r2,11264
81104eec:	18800015 	stw	r2,0(r3)
			break;
81104ef0:	00002506 	br	81104f88 <bDpktInitCh+0x124>
		case eCommSpwCh2:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81104ef4:	e0fffe17 	ldw	r3,-8(fp)
81104ef8:	00a04834 	movhi	r2,33056
81104efc:	108a0004 	addi	r2,r2,10240
81104f00:	18800015 	stw	r2,0(r3)
			break;
81104f04:	00002006 	br	81104f88 <bDpktInitCh+0x124>
		case eCommSpwCh3:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81104f08:	e0fffe17 	ldw	r3,-8(fp)
81104f0c:	00a04834 	movhi	r2,33056
81104f10:	108b0004 	addi	r2,r2,11264
81104f14:	18800015 	stw	r2,0(r3)
			break;
81104f18:	00001b06 	br	81104f88 <bDpktInitCh+0x124>
		case eCommSpwCh4:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81104f1c:	e0fffe17 	ldw	r3,-8(fp)
81104f20:	00a04834 	movhi	r2,33056
81104f24:	108a0004 	addi	r2,r2,10240
81104f28:	18800015 	stw	r2,0(r3)
			break;
81104f2c:	00001606 	br	81104f88 <bDpktInitCh+0x124>
		case eCommSpwCh5:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81104f30:	e0fffe17 	ldw	r3,-8(fp)
81104f34:	00a04834 	movhi	r2,33056
81104f38:	108b0004 	addi	r2,r2,11264
81104f3c:	18800015 	stw	r2,0(r3)
			break;
81104f40:	00001106 	br	81104f88 <bDpktInitCh+0x124>
		case eCommSpwCh6:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81104f44:	e0fffe17 	ldw	r3,-8(fp)
81104f48:	00a04834 	movhi	r2,33056
81104f4c:	108a0004 	addi	r2,r2,10240
81104f50:	18800015 	stw	r2,0(r3)
			break;
81104f54:	00000c06 	br	81104f88 <bDpktInitCh+0x124>
		case eCommSpwCh7:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81104f58:	e0fffe17 	ldw	r3,-8(fp)
81104f5c:	00a04834 	movhi	r2,33056
81104f60:	108b0004 	addi	r2,r2,11264
81104f64:	18800015 	stw	r2,0(r3)
			break;
81104f68:	00000706 	br	81104f88 <bDpktInitCh+0x124>
		case eCommSpwCh8:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81104f6c:	e0fffe17 	ldw	r3,-8(fp)
81104f70:	00a04834 	movhi	r2,33056
81104f74:	108a0004 	addi	r2,r2,10240
81104f78:	18800015 	stw	r2,0(r3)
			break;
81104f7c:	00000206 	br	81104f88 <bDpktInitCh+0x124>
		default:
			bStatus = FALSE;
81104f80:	e03ffd15 	stw	zero,-12(fp)
			break;
81104f84:	0001883a 	nop
		}

		if (bStatus) {
81104f88:	e0bffd17 	ldw	r2,-12(fp)
81104f8c:	10000c26 	beq	r2,zero,81104fc0 <bDpktInitCh+0x15c>
			if (!bDpktGetPacketConfig(pxDpktCh)) {
81104f90:	e13ffe17 	ldw	r4,-8(fp)
81104f94:	1104a680 	call	81104a68 <bDpktGetPacketConfig>
81104f98:	1000011e 	bne	r2,zero,81104fa0 <bDpktInitCh+0x13c>
				bStatus = FALSE;
81104f9c:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bDpktGetPacketHeader(pxDpktCh)) {
81104fa0:	e13ffe17 	ldw	r4,-8(fp)
81104fa4:	1104b940 	call	81104b94 <bDpktGetPacketHeader>
81104fa8:	1000011e 	bne	r2,zero,81104fb0 <bDpktInitCh+0x14c>
				bStatus = FALSE;
81104fac:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bDpktGetPixelDelay(pxDpktCh)) {
81104fb0:	e13ffe17 	ldw	r4,-8(fp)
81104fb4:	1104da00 	call	81104da0 <bDpktGetPixelDelay>
81104fb8:	1000011e 	bne	r2,zero,81104fc0 <bDpktInitCh+0x15c>
				bStatus = FALSE;
81104fbc:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81104fc0:	e0bffd17 	ldw	r2,-12(fp)
}
81104fc4:	e037883a 	mov	sp,fp
81104fc8:	dfc00117 	ldw	ra,4(sp)
81104fcc:	df000017 	ldw	fp,0(sp)
81104fd0:	dec00204 	addi	sp,sp,8
81104fd4:	f800283a 	ret

81104fd8 <vDpktWriteReg>:
//! [public functions]

//! [private functions]
static void vDpktWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81104fd8:	defffc04 	addi	sp,sp,-16
81104fdc:	de00012e 	bgeu	sp,et,81104fe4 <vDpktWriteReg+0xc>
81104fe0:	003b68fa 	trap	3
81104fe4:	df000315 	stw	fp,12(sp)
81104fe8:	df000304 	addi	fp,sp,12
81104fec:	e13ffd15 	stw	r4,-12(fp)
81104ff0:	e17ffe15 	stw	r5,-8(fp)
81104ff4:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81104ff8:	e0bffe17 	ldw	r2,-8(fp)
81104ffc:	1085883a 	add	r2,r2,r2
81105000:	1085883a 	add	r2,r2,r2
81105004:	1007883a 	mov	r3,r2
81105008:	e0bffd17 	ldw	r2,-12(fp)
8110500c:	10c5883a 	add	r2,r2,r3
81105010:	e0ffff17 	ldw	r3,-4(fp)
81105014:	10c00015 	stw	r3,0(r2)
}
81105018:	0001883a 	nop
8110501c:	e037883a 	mov	sp,fp
81105020:	df000017 	ldw	fp,0(sp)
81105024:	dec00104 	addi	sp,sp,4
81105028:	f800283a 	ret

8110502c <uliDpktReadReg>:

static alt_u32 uliDpktReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8110502c:	defffc04 	addi	sp,sp,-16
81105030:	de00012e 	bgeu	sp,et,81105038 <uliDpktReadReg+0xc>
81105034:	003b68fa 	trap	3
81105038:	df000315 	stw	fp,12(sp)
8110503c:	df000304 	addi	fp,sp,12
81105040:	e13ffe15 	stw	r4,-8(fp)
81105044:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81105048:	e0bfff17 	ldw	r2,-4(fp)
8110504c:	1085883a 	add	r2,r2,r2
81105050:	1085883a 	add	r2,r2,r2
81105054:	1007883a 	mov	r3,r2
81105058:	e0bffe17 	ldw	r2,-8(fp)
8110505c:	10c5883a 	add	r2,r2,r3
81105060:	10800017 	ldw	r2,0(r2)
81105064:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81105068:	e0bffd17 	ldw	r2,-12(fp)
}
8110506c:	e037883a 	mov	sp,fp
81105070:	df000017 	ldw	fp,0(sp)
81105074:	dec00104 	addi	sp,sp,4
81105078:	f800283a 	ret

8110507c <usiAdcPxDelayCalcPeriodNs>:

/*
 * Return the necessary delay value for a
 * ADC Pixel Delay period in uliPeriodNs ns.
 */
alt_u16 usiAdcPxDelayCalcPeriodNs(alt_u32 uliPeriodNs) {
8110507c:	defffc04 	addi	sp,sp,-16
81105080:	de00012e 	bgeu	sp,et,81105088 <usiAdcPxDelayCalcPeriodNs+0xc>
81105084:	003b68fa 	trap	3
81105088:	dfc00315 	stw	ra,12(sp)
8110508c:	df000215 	stw	fp,8(sp)
81105090:	df000204 	addi	fp,sp,8
81105094:	e13fff15 	stw	r4,-4(fp)
	 * Delay[ns] / 10 = Delay[ns] * 1e-1
	 * AdcPxDelay = Delay[ns] * 1e-1
	 */

	alt_u16 usiAdcPxDelay;
	usiAdcPxDelay = (alt_u16) ((float) uliPeriodNs * 1e-1);
81105098:	e13fff17 	ldw	r4,-4(fp)
8110509c:	111f7c80 	call	8111f7c8 <__floatunsisf>
811050a0:	1007883a 	mov	r3,r2
811050a4:	1809883a 	mov	r4,r3
811050a8:	1120b240 	call	81120b24 <__extendsfdf2>
811050ac:	1011883a 	mov	r8,r2
811050b0:	1813883a 	mov	r9,r3
811050b4:	01a666b4 	movhi	r6,39322
811050b8:	31a66684 	addi	r6,r6,-26214
811050bc:	01cfeeb4 	movhi	r7,16314
811050c0:	39e66644 	addi	r7,r7,-26215
811050c4:	4009883a 	mov	r4,r8
811050c8:	480b883a 	mov	r5,r9
811050cc:	111f99c0 	call	8111f99c <__muldf3>
811050d0:	1009883a 	mov	r4,r2
811050d4:	180b883a 	mov	r5,r3
811050d8:	2005883a 	mov	r2,r4
811050dc:	2807883a 	mov	r3,r5
811050e0:	1009883a 	mov	r4,r2
811050e4:	180b883a 	mov	r5,r3
811050e8:	111edd40 	call	8111edd4 <__fixunsdfsi>
811050ec:	e0bffe0d 	sth	r2,-8(fp)

	return usiAdcPxDelay;
811050f0:	e0bffe0b 	ldhu	r2,-8(fp)
}
811050f4:	e037883a 	mov	sp,fp
811050f8:	dfc00117 	ldw	ra,4(sp)
811050fc:	df000017 	ldw	fp,0(sp)
81105100:	dec00204 	addi	sp,sp,8
81105104:	f800283a 	ret

81105108 <usiLineTrDelayCalcPeriodNs>:

/*
 * Return the necessary delay value for a
 * Line Transfer Delay period in uliPeriodNs ns.
 */
alt_u16 usiLineTrDelayCalcPeriodNs(alt_u32 uliPeriodNs) {
81105108:	defffc04 	addi	sp,sp,-16
8110510c:	de00012e 	bgeu	sp,et,81105114 <usiLineTrDelayCalcPeriodNs+0xc>
81105110:	003b68fa 	trap	3
81105114:	dfc00315 	stw	ra,12(sp)
81105118:	df000215 	stw	fp,8(sp)
8110511c:	df000204 	addi	fp,sp,8
81105120:	e13fff15 	stw	r4,-4(fp)
	 * Delay[ns] / 100 = Delay[ns] * 1e-2
	 * LineTrDelay = Delay[ns] * 1e-2
	 */

	alt_u16 LineTrDelay;
	LineTrDelay = (alt_u16) ((float) uliPeriodNs * 1e-2);
81105124:	e13fff17 	ldw	r4,-4(fp)
81105128:	111f7c80 	call	8111f7c8 <__floatunsisf>
8110512c:	1007883a 	mov	r3,r2
81105130:	1809883a 	mov	r4,r3
81105134:	1120b240 	call	81120b24 <__extendsfdf2>
81105138:	1011883a 	mov	r8,r2
8110513c:	1813883a 	mov	r9,r3
81105140:	0191ebb4 	movhi	r6,18350
81105144:	31851ec4 	addi	r6,r6,5243
81105148:	01cfe134 	movhi	r7,16260
8110514c:	39deb844 	addi	r7,r7,31457
81105150:	4009883a 	mov	r4,r8
81105154:	480b883a 	mov	r5,r9
81105158:	111f99c0 	call	8111f99c <__muldf3>
8110515c:	1009883a 	mov	r4,r2
81105160:	180b883a 	mov	r5,r3
81105164:	2005883a 	mov	r2,r4
81105168:	2807883a 	mov	r3,r5
8110516c:	1009883a 	mov	r4,r2
81105170:	180b883a 	mov	r5,r3
81105174:	111edd40 	call	8111edd4 <__fixunsdfsi>
81105178:	e0bffe0d 	sth	r2,-8(fp)

	return LineTrDelay;
8110517c:	e0bffe0b 	ldhu	r2,-8(fp)
}
81105180:	e037883a 	mov	sp,fp
81105184:	dfc00117 	ldw	ra,4(sp)
81105188:	df000017 	ldw	fp,0(sp)
8110518c:	dec00204 	addi	sp,sp,8
81105190:	f800283a 	ret

81105194 <vFeebCh1HandleIrq>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vFeebCh1HandleIrq(void* pvContext) {
81105194:	defffb04 	addi	sp,sp,-20
81105198:	de00012e 	bgeu	sp,et,811051a0 <vFeebCh1HandleIrq+0xc>
8110519c:	003b68fa 	trap	3
811051a0:	dfc00415 	stw	ra,16(sp)
811051a4:	df000315 	stw	fp,12(sp)
811051a8:	df000304 	addi	fp,sp,12
811051ac:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
811051b0:	e0bfff17 	ldw	r2,-4(fp)
811051b4:	e0bffd15 	stw	r2,-12(fp)
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	INT8U error_codel;
	tQMask uiCmdtoSend;

	vFeebCh1IrqFlagClrBufferEmpty();
811051b8:	11054e80 	call	811054e8 <vFeebCh1IrqFlagClrBufferEmpty>
	/* Make one requests for the Double buffer */
	/* Address of the NFEE is hard coded */



}
811051bc:	0001883a 	nop
811051c0:	e037883a 	mov	sp,fp
811051c4:	dfc00117 	ldw	ra,4(sp)
811051c8:	df000017 	ldw	fp,0(sp)
811051cc:	dec00204 	addi	sp,sp,8
811051d0:	f800283a 	ret

811051d4 <vFeebCh2HandleIrq>:

void vFeebCh2HandleIrq(void* pvContext) {
811051d4:	defffa04 	addi	sp,sp,-24
811051d8:	de00012e 	bgeu	sp,et,811051e0 <vFeebCh2HandleIrq+0xc>
811051dc:	003b68fa 	trap	3
811051e0:	dfc00515 	stw	ra,20(sp)
811051e4:	df000415 	stw	fp,16(sp)
811051e8:	df000404 	addi	fp,sp,16
811051ec:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
811051f0:	e0bfff17 	ldw	r2,-4(fp)
811051f4:	e0bffc15 	stw	r2,-16(fp)

	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
811051f8:	00800404 	movi	r2,16
811051fc:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
81105200:	00bfe004 	movi	r2,-128
81105204:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
81105208:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 1;
8110520c:	00800044 	movi	r2,1
81105210:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
81105214:	d0a05d17 	ldw	r2,-32396(gp)
81105218:	e0fffe17 	ldw	r3,-8(fp)
8110521c:	180b883a 	mov	r5,r3
81105220:	1009883a 	mov	r4,r2
81105224:	113d9d00 	call	8113d9d0 <OSQPost>
81105228:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
8110522c:	e0bffd03 	ldbu	r2,-12(fp)
81105230:	10000226 	beq	r2,zero,8110523c <vFeebCh2HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 1 );
81105234:	01000044 	movi	r4,1
81105238:	111cf340 	call	8111cf34 <vFailRequestDMAFromIRQ>
	}

	vFeebCh2IrqFlagClrBufferEmpty();
8110523c:	110552c0 	call	8110552c <vFeebCh2IrqFlagClrBufferEmpty>
}
81105240:	0001883a 	nop
81105244:	e037883a 	mov	sp,fp
81105248:	dfc00117 	ldw	ra,4(sp)
8110524c:	df000017 	ldw	fp,0(sp)
81105250:	dec00204 	addi	sp,sp,8
81105254:	f800283a 	ret

81105258 <vFeebCh3HandleIrq>:

void vFeebCh3HandleIrq(void* pvContext) {
81105258:	defffa04 	addi	sp,sp,-24
8110525c:	de00012e 	bgeu	sp,et,81105264 <vFeebCh3HandleIrq+0xc>
81105260:	003b68fa 	trap	3
81105264:	dfc00515 	stw	ra,20(sp)
81105268:	df000415 	stw	fp,16(sp)
8110526c:	df000404 	addi	fp,sp,16
81105270:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105274:	e0bfff17 	ldw	r2,-4(fp)
81105278:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
8110527c:	00800404 	movi	r2,16
81105280:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
81105284:	00bfe004 	movi	r2,-128
81105288:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
8110528c:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 2;
81105290:	00800084 	movi	r2,2
81105294:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
81105298:	d0a05d17 	ldw	r2,-32396(gp)
8110529c:	e0fffe17 	ldw	r3,-8(fp)
811052a0:	180b883a 	mov	r5,r3
811052a4:	1009883a 	mov	r4,r2
811052a8:	113d9d00 	call	8113d9d0 <OSQPost>
811052ac:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
811052b0:	e0bffd03 	ldbu	r2,-12(fp)
811052b4:	10000226 	beq	r2,zero,811052c0 <vFeebCh3HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 2 );
811052b8:	01000084 	movi	r4,2
811052bc:	111cf340 	call	8111cf34 <vFailRequestDMAFromIRQ>
	}

	vFeebCh3IrqFlagClrBufferEmpty();
811052c0:	11055700 	call	81105570 <vFeebCh3IrqFlagClrBufferEmpty>
}
811052c4:	0001883a 	nop
811052c8:	e037883a 	mov	sp,fp
811052cc:	dfc00117 	ldw	ra,4(sp)
811052d0:	df000017 	ldw	fp,0(sp)
811052d4:	dec00204 	addi	sp,sp,8
811052d8:	f800283a 	ret

811052dc <vFeebCh4HandleIrq>:

void vFeebCh4HandleIrq(void* pvContext) {
811052dc:	defffa04 	addi	sp,sp,-24
811052e0:	de00012e 	bgeu	sp,et,811052e8 <vFeebCh4HandleIrq+0xc>
811052e4:	003b68fa 	trap	3
811052e8:	dfc00515 	stw	ra,20(sp)
811052ec:	df000415 	stw	fp,16(sp)
811052f0:	df000404 	addi	fp,sp,16
811052f4:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
811052f8:	e0bfff17 	ldw	r2,-4(fp)
811052fc:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81105300:	00800404 	movi	r2,16
81105304:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
81105308:	00bfe004 	movi	r2,-128
8110530c:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
81105310:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 3;
81105314:	008000c4 	movi	r2,3
81105318:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
8110531c:	d0a05d17 	ldw	r2,-32396(gp)
81105320:	e0fffe17 	ldw	r3,-8(fp)
81105324:	180b883a 	mov	r5,r3
81105328:	1009883a 	mov	r4,r2
8110532c:	113d9d00 	call	8113d9d0 <OSQPost>
81105330:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
81105334:	e0bffd03 	ldbu	r2,-12(fp)
81105338:	10000226 	beq	r2,zero,81105344 <vFeebCh4HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 3 );
8110533c:	010000c4 	movi	r4,3
81105340:	111cf340 	call	8111cf34 <vFailRequestDMAFromIRQ>
	}

	vFeebCh4IrqFlagClrBufferEmpty();
81105344:	11055b40 	call	811055b4 <vFeebCh4IrqFlagClrBufferEmpty>
}
81105348:	0001883a 	nop
8110534c:	e037883a 	mov	sp,fp
81105350:	dfc00117 	ldw	ra,4(sp)
81105354:	df000017 	ldw	fp,0(sp)
81105358:	dec00204 	addi	sp,sp,8
8110535c:	f800283a 	ret

81105360 <vFeebCh5HandleIrq>:

void vFeebCh5HandleIrq(void* pvContext) {
81105360:	defffa04 	addi	sp,sp,-24
81105364:	de00012e 	bgeu	sp,et,8110536c <vFeebCh5HandleIrq+0xc>
81105368:	003b68fa 	trap	3
8110536c:	dfc00515 	stw	ra,20(sp)
81105370:	df000415 	stw	fp,16(sp)
81105374:	df000404 	addi	fp,sp,16
81105378:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
8110537c:	e0bfff17 	ldw	r2,-4(fp)
81105380:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81105384:	00800404 	movi	r2,16
81105388:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
8110538c:	00bfe004 	movi	r2,-128
81105390:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
81105394:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 4;
81105398:	00800104 	movi	r2,4
8110539c:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
811053a0:	d0a05d17 	ldw	r2,-32396(gp)
811053a4:	e0fffe17 	ldw	r3,-8(fp)
811053a8:	180b883a 	mov	r5,r3
811053ac:	1009883a 	mov	r4,r2
811053b0:	113d9d00 	call	8113d9d0 <OSQPost>
811053b4:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
811053b8:	e0bffd03 	ldbu	r2,-12(fp)
811053bc:	10000226 	beq	r2,zero,811053c8 <vFeebCh5HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 4 );
811053c0:	01000104 	movi	r4,4
811053c4:	111cf340 	call	8111cf34 <vFailRequestDMAFromIRQ>
	}

	vFeebCh5IrqFlagClrBufferEmpty();
811053c8:	11055f80 	call	811055f8 <vFeebCh5IrqFlagClrBufferEmpty>
}
811053cc:	0001883a 	nop
811053d0:	e037883a 	mov	sp,fp
811053d4:	dfc00117 	ldw	ra,4(sp)
811053d8:	df000017 	ldw	fp,0(sp)
811053dc:	dec00204 	addi	sp,sp,8
811053e0:	f800283a 	ret

811053e4 <vFeebCh6HandleIrq>:

void vFeebCh6HandleIrq(void* pvContext) {
811053e4:	defffa04 	addi	sp,sp,-24
811053e8:	de00012e 	bgeu	sp,et,811053f0 <vFeebCh6HandleIrq+0xc>
811053ec:	003b68fa 	trap	3
811053f0:	dfc00515 	stw	ra,20(sp)
811053f4:	df000415 	stw	fp,16(sp)
811053f8:	df000404 	addi	fp,sp,16
811053fc:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105400:	e0bfff17 	ldw	r2,-4(fp)
81105404:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81105408:	00800404 	movi	r2,16
8110540c:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
81105410:	00bfe004 	movi	r2,-128
81105414:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
81105418:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 5;
8110541c:	00800144 	movi	r2,5
81105420:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
81105424:	d0a05d17 	ldw	r2,-32396(gp)
81105428:	e0fffe17 	ldw	r3,-8(fp)
8110542c:	180b883a 	mov	r5,r3
81105430:	1009883a 	mov	r4,r2
81105434:	113d9d00 	call	8113d9d0 <OSQPost>
81105438:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
8110543c:	e0bffd03 	ldbu	r2,-12(fp)
81105440:	10000226 	beq	r2,zero,8110544c <vFeebCh6HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 5 );
81105444:	01000144 	movi	r4,5
81105448:	111cf340 	call	8111cf34 <vFailRequestDMAFromIRQ>
	}


	vFeebCh6IrqFlagClrBufferEmpty();
8110544c:	110563c0 	call	8110563c <vFeebCh6IrqFlagClrBufferEmpty>
}
81105450:	0001883a 	nop
81105454:	e037883a 	mov	sp,fp
81105458:	dfc00117 	ldw	ra,4(sp)
8110545c:	df000017 	ldw	fp,0(sp)
81105460:	dec00204 	addi	sp,sp,8
81105464:	f800283a 	ret

81105468 <vFeebCh7HandleIrq>:

void vFeebCh7HandleIrq(void* pvContext) {
81105468:	defffc04 	addi	sp,sp,-16
8110546c:	de00012e 	bgeu	sp,et,81105474 <vFeebCh7HandleIrq+0xc>
81105470:	003b68fa 	trap	3
81105474:	dfc00315 	stw	ra,12(sp)
81105478:	df000215 	stw	fp,8(sp)
8110547c:	df000204 	addi	fp,sp,8
81105480:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105484:	e0bfff17 	ldw	r2,-4(fp)
81105488:	e0bffe15 	stw	r2,-8(fp)


	vFeebCh7IrqFlagClrBufferEmpty();
8110548c:	11056800 	call	81105680 <vFeebCh7IrqFlagClrBufferEmpty>
}
81105490:	0001883a 	nop
81105494:	e037883a 	mov	sp,fp
81105498:	dfc00117 	ldw	ra,4(sp)
8110549c:	df000017 	ldw	fp,0(sp)
811054a0:	dec00204 	addi	sp,sp,8
811054a4:	f800283a 	ret

811054a8 <vFeebCh8HandleIrq>:

void vFeebCh8HandleIrq(void* pvContext) {
811054a8:	defffc04 	addi	sp,sp,-16
811054ac:	de00012e 	bgeu	sp,et,811054b4 <vFeebCh8HandleIrq+0xc>
811054b0:	003b68fa 	trap	3
811054b4:	dfc00315 	stw	ra,12(sp)
811054b8:	df000215 	stw	fp,8(sp)
811054bc:	df000204 	addi	fp,sp,8
811054c0:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
811054c4:	e0bfff17 	ldw	r2,-4(fp)
811054c8:	e0bffe15 	stw	r2,-8(fp)


	vFeebCh8IrqFlagClrBufferEmpty();
811054cc:	11056c40 	call	811056c4 <vFeebCh8IrqFlagClrBufferEmpty>
}
811054d0:	0001883a 	nop
811054d4:	e037883a 	mov	sp,fp
811054d8:	dfc00117 	ldw	ra,4(sp)
811054dc:	df000017 	ldw	fp,0(sp)
811054e0:	dec00204 	addi	sp,sp,8
811054e4:	f800283a 	ret

811054e8 <vFeebCh1IrqFlagClrBufferEmpty>:

void vFeebCh1IrqFlagClrBufferEmpty(void) {
811054e8:	defffe04 	addi	sp,sp,-8
811054ec:	de00012e 	bgeu	sp,et,811054f4 <vFeebCh1IrqFlagClrBufferEmpty+0xc>
811054f0:	003b68fa 	trap	3
811054f4:	dfc00115 	stw	ra,4(sp)
811054f8:	df000015 	stw	fp,0(sp)
811054fc:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81105500:	01804004 	movi	r6,256
81105504:	014004c4 	movi	r5,19
81105508:	01204834 	movhi	r4,33056
8110550c:	210b0004 	addi	r4,r4,11264
81105510:	1106cb40 	call	81106cb4 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105514:	0001883a 	nop
81105518:	e037883a 	mov	sp,fp
8110551c:	dfc00117 	ldw	ra,4(sp)
81105520:	df000017 	ldw	fp,0(sp)
81105524:	dec00204 	addi	sp,sp,8
81105528:	f800283a 	ret

8110552c <vFeebCh2IrqFlagClrBufferEmpty>:

void vFeebCh2IrqFlagClrBufferEmpty(void) {
8110552c:	defffe04 	addi	sp,sp,-8
81105530:	de00012e 	bgeu	sp,et,81105538 <vFeebCh2IrqFlagClrBufferEmpty+0xc>
81105534:	003b68fa 	trap	3
81105538:	dfc00115 	stw	ra,4(sp)
8110553c:	df000015 	stw	fp,0(sp)
81105540:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81105544:	01804004 	movi	r6,256
81105548:	014004c4 	movi	r5,19
8110554c:	01204834 	movhi	r4,33056
81105550:	210a0004 	addi	r4,r4,10240
81105554:	1106cb40 	call	81106cb4 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105558:	0001883a 	nop
8110555c:	e037883a 	mov	sp,fp
81105560:	dfc00117 	ldw	ra,4(sp)
81105564:	df000017 	ldw	fp,0(sp)
81105568:	dec00204 	addi	sp,sp,8
8110556c:	f800283a 	ret

81105570 <vFeebCh3IrqFlagClrBufferEmpty>:

void vFeebCh3IrqFlagClrBufferEmpty(void) {
81105570:	defffe04 	addi	sp,sp,-8
81105574:	de00012e 	bgeu	sp,et,8110557c <vFeebCh3IrqFlagClrBufferEmpty+0xc>
81105578:	003b68fa 	trap	3
8110557c:	dfc00115 	stw	ra,4(sp)
81105580:	df000015 	stw	fp,0(sp)
81105584:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105588:	01804004 	movi	r6,256
8110558c:	014004c4 	movi	r5,19
81105590:	01204834 	movhi	r4,33056
81105594:	210b0004 	addi	r4,r4,11264
81105598:	1106cb40 	call	81106cb4 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
8110559c:	0001883a 	nop
811055a0:	e037883a 	mov	sp,fp
811055a4:	dfc00117 	ldw	ra,4(sp)
811055a8:	df000017 	ldw	fp,0(sp)
811055ac:	dec00204 	addi	sp,sp,8
811055b0:	f800283a 	ret

811055b4 <vFeebCh4IrqFlagClrBufferEmpty>:

void vFeebCh4IrqFlagClrBufferEmpty(void) {
811055b4:	defffe04 	addi	sp,sp,-8
811055b8:	de00012e 	bgeu	sp,et,811055c0 <vFeebCh4IrqFlagClrBufferEmpty+0xc>
811055bc:	003b68fa 	trap	3
811055c0:	dfc00115 	stw	ra,4(sp)
811055c4:	df000015 	stw	fp,0(sp)
811055c8:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
811055cc:	01804004 	movi	r6,256
811055d0:	014004c4 	movi	r5,19
811055d4:	01204834 	movhi	r4,33056
811055d8:	210a0004 	addi	r4,r4,10240
811055dc:	1106cb40 	call	81106cb4 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811055e0:	0001883a 	nop
811055e4:	e037883a 	mov	sp,fp
811055e8:	dfc00117 	ldw	ra,4(sp)
811055ec:	df000017 	ldw	fp,0(sp)
811055f0:	dec00204 	addi	sp,sp,8
811055f4:	f800283a 	ret

811055f8 <vFeebCh5IrqFlagClrBufferEmpty>:

void vFeebCh5IrqFlagClrBufferEmpty(void) {
811055f8:	defffe04 	addi	sp,sp,-8
811055fc:	de00012e 	bgeu	sp,et,81105604 <vFeebCh5IrqFlagClrBufferEmpty+0xc>
81105600:	003b68fa 	trap	3
81105604:	dfc00115 	stw	ra,4(sp)
81105608:	df000015 	stw	fp,0(sp)
8110560c:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105610:	01804004 	movi	r6,256
81105614:	014004c4 	movi	r5,19
81105618:	01204834 	movhi	r4,33056
8110561c:	210b0004 	addi	r4,r4,11264
81105620:	1106cb40 	call	81106cb4 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105624:	0001883a 	nop
81105628:	e037883a 	mov	sp,fp
8110562c:	dfc00117 	ldw	ra,4(sp)
81105630:	df000017 	ldw	fp,0(sp)
81105634:	dec00204 	addi	sp,sp,8
81105638:	f800283a 	ret

8110563c <vFeebCh6IrqFlagClrBufferEmpty>:

void vFeebCh6IrqFlagClrBufferEmpty(void) {
8110563c:	defffe04 	addi	sp,sp,-8
81105640:	de00012e 	bgeu	sp,et,81105648 <vFeebCh6IrqFlagClrBufferEmpty+0xc>
81105644:	003b68fa 	trap	3
81105648:	dfc00115 	stw	ra,4(sp)
8110564c:	df000015 	stw	fp,0(sp)
81105650:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105654:	01804004 	movi	r6,256
81105658:	014004c4 	movi	r5,19
8110565c:	01204834 	movhi	r4,33056
81105660:	210a0004 	addi	r4,r4,10240
81105664:	1106cb40 	call	81106cb4 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105668:	0001883a 	nop
8110566c:	e037883a 	mov	sp,fp
81105670:	dfc00117 	ldw	ra,4(sp)
81105674:	df000017 	ldw	fp,0(sp)
81105678:	dec00204 	addi	sp,sp,8
8110567c:	f800283a 	ret

81105680 <vFeebCh7IrqFlagClrBufferEmpty>:

void vFeebCh7IrqFlagClrBufferEmpty(void) {
81105680:	defffe04 	addi	sp,sp,-8
81105684:	de00012e 	bgeu	sp,et,8110568c <vFeebCh7IrqFlagClrBufferEmpty+0xc>
81105688:	003b68fa 	trap	3
8110568c:	dfc00115 	stw	ra,4(sp)
81105690:	df000015 	stw	fp,0(sp)
81105694:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81105698:	01804004 	movi	r6,256
8110569c:	014004c4 	movi	r5,19
811056a0:	01204834 	movhi	r4,33056
811056a4:	210b0004 	addi	r4,r4,11264
811056a8:	1106cb40 	call	81106cb4 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811056ac:	0001883a 	nop
811056b0:	e037883a 	mov	sp,fp
811056b4:	dfc00117 	ldw	ra,4(sp)
811056b8:	df000017 	ldw	fp,0(sp)
811056bc:	dec00204 	addi	sp,sp,8
811056c0:	f800283a 	ret

811056c4 <vFeebCh8IrqFlagClrBufferEmpty>:

void vFeebCh8IrqFlagClrBufferEmpty(void) {
811056c4:	defffe04 	addi	sp,sp,-8
811056c8:	de00012e 	bgeu	sp,et,811056d0 <vFeebCh8IrqFlagClrBufferEmpty+0xc>
811056cc:	003b68fa 	trap	3
811056d0:	dfc00115 	stw	ra,4(sp)
811056d4:	df000015 	stw	fp,0(sp)
811056d8:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
811056dc:	01804004 	movi	r6,256
811056e0:	014004c4 	movi	r5,19
811056e4:	01204834 	movhi	r4,33056
811056e8:	210a0004 	addi	r4,r4,10240
811056ec:	1106cb40 	call	81106cb4 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811056f0:	0001883a 	nop
811056f4:	e037883a 	mov	sp,fp
811056f8:	dfc00117 	ldw	ra,4(sp)
811056fc:	df000017 	ldw	fp,0(sp)
81105700:	dec00204 	addi	sp,sp,8
81105704:	f800283a 	ret

81105708 <bFeebCh1IrqFlagBufferEmpty>:

bool bFeebCh1IrqFlagBufferEmpty(void) {
81105708:	defffd04 	addi	sp,sp,-12
8110570c:	de00012e 	bgeu	sp,et,81105714 <bFeebCh1IrqFlagBufferEmpty+0xc>
81105710:	003b68fa 	trap	3
81105714:	dfc00215 	stw	ra,8(sp)
81105718:	df000115 	stw	fp,4(sp)
8110571c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81105720:	01400484 	movi	r5,18
81105724:	01204834 	movhi	r4,33056
81105728:	210b0004 	addi	r4,r4,11264
8110572c:	1106d080 	call	81106d08 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105730:	1080400c 	andi	r2,r2,256
}

bool bFeebCh1IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81105734:	10000326 	beq	r2,zero,81105744 <bFeebCh1IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105738:	00800044 	movi	r2,1
8110573c:	e0bfff15 	stw	r2,-4(fp)
81105740:	00000106 	br	81105748 <bFeebCh1IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105744:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105748:	e0bfff17 	ldw	r2,-4(fp)
}
8110574c:	e037883a 	mov	sp,fp
81105750:	dfc00117 	ldw	ra,4(sp)
81105754:	df000017 	ldw	fp,0(sp)
81105758:	dec00204 	addi	sp,sp,8
8110575c:	f800283a 	ret

81105760 <bFeebCh2IrqFlagBufferEmpty>:

bool bFeebCh2IrqFlagBufferEmpty(void) {
81105760:	defffd04 	addi	sp,sp,-12
81105764:	de00012e 	bgeu	sp,et,8110576c <bFeebCh2IrqFlagBufferEmpty+0xc>
81105768:	003b68fa 	trap	3
8110576c:	dfc00215 	stw	ra,8(sp)
81105770:	df000115 	stw	fp,4(sp)
81105774:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81105778:	01400484 	movi	r5,18
8110577c:	01204834 	movhi	r4,33056
81105780:	210a0004 	addi	r4,r4,10240
81105784:	1106d080 	call	81106d08 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105788:	1080400c 	andi	r2,r2,256
}

bool bFeebCh2IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
8110578c:	10000326 	beq	r2,zero,8110579c <bFeebCh2IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105790:	00800044 	movi	r2,1
81105794:	e0bfff15 	stw	r2,-4(fp)
81105798:	00000106 	br	811057a0 <bFeebCh2IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
8110579c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811057a0:	e0bfff17 	ldw	r2,-4(fp)
}
811057a4:	e037883a 	mov	sp,fp
811057a8:	dfc00117 	ldw	ra,4(sp)
811057ac:	df000017 	ldw	fp,0(sp)
811057b0:	dec00204 	addi	sp,sp,8
811057b4:	f800283a 	ret

811057b8 <bFeebCh3IrqFlagBufferEmpty>:

bool bFeebCh3IrqFlagBufferEmpty(void) {
811057b8:	defffd04 	addi	sp,sp,-12
811057bc:	de00012e 	bgeu	sp,et,811057c4 <bFeebCh3IrqFlagBufferEmpty+0xc>
811057c0:	003b68fa 	trap	3
811057c4:	dfc00215 	stw	ra,8(sp)
811057c8:	df000115 	stw	fp,4(sp)
811057cc:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
811057d0:	01400484 	movi	r5,18
811057d4:	01204834 	movhi	r4,33056
811057d8:	210b0004 	addi	r4,r4,11264
811057dc:	1106d080 	call	81106d08 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811057e0:	1080400c 	andi	r2,r2,256
}

bool bFeebCh3IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
811057e4:	10000326 	beq	r2,zero,811057f4 <bFeebCh3IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811057e8:	00800044 	movi	r2,1
811057ec:	e0bfff15 	stw	r2,-4(fp)
811057f0:	00000106 	br	811057f8 <bFeebCh3IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811057f4:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811057f8:	e0bfff17 	ldw	r2,-4(fp)
}
811057fc:	e037883a 	mov	sp,fp
81105800:	dfc00117 	ldw	ra,4(sp)
81105804:	df000017 	ldw	fp,0(sp)
81105808:	dec00204 	addi	sp,sp,8
8110580c:	f800283a 	ret

81105810 <bFeebCh4IrqFlagBufferEmpty>:

bool bFeebCh4IrqFlagBufferEmpty(void) {
81105810:	defffd04 	addi	sp,sp,-12
81105814:	de00012e 	bgeu	sp,et,8110581c <bFeebCh4IrqFlagBufferEmpty+0xc>
81105818:	003b68fa 	trap	3
8110581c:	dfc00215 	stw	ra,8(sp)
81105820:	df000115 	stw	fp,4(sp)
81105824:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81105828:	01400484 	movi	r5,18
8110582c:	01204834 	movhi	r4,33056
81105830:	210a0004 	addi	r4,r4,10240
81105834:	1106d080 	call	81106d08 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105838:	1080400c 	andi	r2,r2,256
}

bool bFeebCh4IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
8110583c:	10000326 	beq	r2,zero,8110584c <bFeebCh4IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105840:	00800044 	movi	r2,1
81105844:	e0bfff15 	stw	r2,-4(fp)
81105848:	00000106 	br	81105850 <bFeebCh4IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
8110584c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105850:	e0bfff17 	ldw	r2,-4(fp)
}
81105854:	e037883a 	mov	sp,fp
81105858:	dfc00117 	ldw	ra,4(sp)
8110585c:	df000017 	ldw	fp,0(sp)
81105860:	dec00204 	addi	sp,sp,8
81105864:	f800283a 	ret

81105868 <bFeebCh5IrqFlagBufferEmpty>:

bool bFeebCh5IrqFlagBufferEmpty(void) {
81105868:	defffd04 	addi	sp,sp,-12
8110586c:	de00012e 	bgeu	sp,et,81105874 <bFeebCh5IrqFlagBufferEmpty+0xc>
81105870:	003b68fa 	trap	3
81105874:	dfc00215 	stw	ra,8(sp)
81105878:	df000115 	stw	fp,4(sp)
8110587c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105880:	01400484 	movi	r5,18
81105884:	01204834 	movhi	r4,33056
81105888:	210b0004 	addi	r4,r4,11264
8110588c:	1106d080 	call	81106d08 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105890:	1080400c 	andi	r2,r2,256
}

bool bFeebCh5IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105894:	10000326 	beq	r2,zero,811058a4 <bFeebCh5IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105898:	00800044 	movi	r2,1
8110589c:	e0bfff15 	stw	r2,-4(fp)
811058a0:	00000106 	br	811058a8 <bFeebCh5IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811058a4:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811058a8:	e0bfff17 	ldw	r2,-4(fp)
}
811058ac:	e037883a 	mov	sp,fp
811058b0:	dfc00117 	ldw	ra,4(sp)
811058b4:	df000017 	ldw	fp,0(sp)
811058b8:	dec00204 	addi	sp,sp,8
811058bc:	f800283a 	ret

811058c0 <bFeebCh6IrqFlagBufferEmpty>:

bool bFeebCh6IrqFlagBufferEmpty(void) {
811058c0:	defffd04 	addi	sp,sp,-12
811058c4:	de00012e 	bgeu	sp,et,811058cc <bFeebCh6IrqFlagBufferEmpty+0xc>
811058c8:	003b68fa 	trap	3
811058cc:	dfc00215 	stw	ra,8(sp)
811058d0:	df000115 	stw	fp,4(sp)
811058d4:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811058d8:	01400484 	movi	r5,18
811058dc:	01204834 	movhi	r4,33056
811058e0:	210a0004 	addi	r4,r4,10240
811058e4:	1106d080 	call	81106d08 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811058e8:	1080400c 	andi	r2,r2,256
}

bool bFeebCh6IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811058ec:	10000326 	beq	r2,zero,811058fc <bFeebCh6IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811058f0:	00800044 	movi	r2,1
811058f4:	e0bfff15 	stw	r2,-4(fp)
811058f8:	00000106 	br	81105900 <bFeebCh6IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811058fc:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105900:	e0bfff17 	ldw	r2,-4(fp)
}
81105904:	e037883a 	mov	sp,fp
81105908:	dfc00117 	ldw	ra,4(sp)
8110590c:	df000017 	ldw	fp,0(sp)
81105910:	dec00204 	addi	sp,sp,8
81105914:	f800283a 	ret

81105918 <bFeebCh7IrqFlagBufferEmpty>:

bool bFeebCh7IrqFlagBufferEmpty(void) {
81105918:	defffd04 	addi	sp,sp,-12
8110591c:	de00012e 	bgeu	sp,et,81105924 <bFeebCh7IrqFlagBufferEmpty+0xc>
81105920:	003b68fa 	trap	3
81105924:	dfc00215 	stw	ra,8(sp)
81105928:	df000115 	stw	fp,4(sp)
8110592c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81105930:	01400484 	movi	r5,18
81105934:	01204834 	movhi	r4,33056
81105938:	210b0004 	addi	r4,r4,11264
8110593c:	1106d080 	call	81106d08 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105940:	1080400c 	andi	r2,r2,256
}

bool bFeebCh7IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81105944:	10000326 	beq	r2,zero,81105954 <bFeebCh7IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105948:	00800044 	movi	r2,1
8110594c:	e0bfff15 	stw	r2,-4(fp)
81105950:	00000106 	br	81105958 <bFeebCh7IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105954:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105958:	e0bfff17 	ldw	r2,-4(fp)
}
8110595c:	e037883a 	mov	sp,fp
81105960:	dfc00117 	ldw	ra,4(sp)
81105964:	df000017 	ldw	fp,0(sp)
81105968:	dec00204 	addi	sp,sp,8
8110596c:	f800283a 	ret

81105970 <bFeebCh8IrqFlagBufferEmpty>:

bool bFeebCh8IrqFlagBufferEmpty(void) {
81105970:	defffd04 	addi	sp,sp,-12
81105974:	de00012e 	bgeu	sp,et,8110597c <bFeebCh8IrqFlagBufferEmpty+0xc>
81105978:	003b68fa 	trap	3
8110597c:	dfc00215 	stw	ra,8(sp)
81105980:	df000115 	stw	fp,4(sp)
81105984:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81105988:	01400484 	movi	r5,18
8110598c:	01204834 	movhi	r4,33056
81105990:	210a0004 	addi	r4,r4,10240
81105994:	1106d080 	call	81106d08 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105998:	1080400c 	andi	r2,r2,256
}

bool bFeebCh8IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
8110599c:	10000326 	beq	r2,zero,811059ac <bFeebCh8IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811059a0:	00800044 	movi	r2,1
811059a4:	e0bfff15 	stw	r2,-4(fp)
811059a8:	00000106 	br	811059b0 <bFeebCh8IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811059ac:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811059b0:	e0bfff17 	ldw	r2,-4(fp)
}
811059b4:	e037883a 	mov	sp,fp
811059b8:	dfc00117 	ldw	ra,4(sp)
811059bc:	df000017 	ldw	fp,0(sp)
811059c0:	dec00204 	addi	sp,sp,8
811059c4:	f800283a 	ret

811059c8 <bFeebCh1SetBufferSize>:

bool bFeebCh1SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
811059c8:	defffa04 	addi	sp,sp,-24
811059cc:	de00012e 	bgeu	sp,et,811059d4 <bFeebCh1SetBufferSize+0xc>
811059d0:	003b68fa 	trap	3
811059d4:	dfc00515 	stw	ra,20(sp)
811059d8:	df000415 	stw	fp,16(sp)
811059dc:	df000404 	addi	fp,sp,16
811059e0:	2007883a 	mov	r3,r4
811059e4:	2805883a 	mov	r2,r5
811059e8:	e0fffe05 	stb	r3,-8(fp)
811059ec:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
811059f0:	00800044 	movi	r2,1
811059f4:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
811059f8:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
811059fc:	e0bffe03 	ldbu	r2,-8(fp)
81105a00:	10001f26 	beq	r2,zero,81105a80 <bFeebCh1SetBufferSize+0xb8>
81105a04:	e0bffe03 	ldbu	r2,-8(fp)
81105a08:	10800468 	cmpgeui	r2,r2,17
81105a0c:	10001c1e 	bne	r2,zero,81105a80 <bFeebCh1SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105a10:	e0bfff03 	ldbu	r2,-4(fp)
81105a14:	10000326 	beq	r2,zero,81105a24 <bFeebCh1SetBufferSize+0x5c>
81105a18:	10800060 	cmpeqi	r2,r2,1
81105a1c:	10000b1e 	bne	r2,zero,81105a4c <bFeebCh1SetBufferSize+0x84>
81105a20:	00001406 	br	81105a74 <bFeebCh1SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105a24:	e0bffe03 	ldbu	r2,-8(fp)
81105a28:	10bfffc4 	addi	r2,r2,-1
81105a2c:	108003cc 	andi	r2,r2,15
81105a30:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81105a34:	e1bffd17 	ldw	r6,-12(fp)
81105a38:	01400544 	movi	r5,21
81105a3c:	01204834 	movhi	r4,33056
81105a40:	210b0004 	addi	r4,r4,11264
81105a44:	1106cb40 	call	81106cb4 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105a48:	00000c06 	br	81105a7c <bFeebCh1SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105a4c:	e0bffe03 	ldbu	r2,-8(fp)
81105a50:	10bfffc4 	addi	r2,r2,-1
81105a54:	108003cc 	andi	r2,r2,15
81105a58:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81105a5c:	e1bffd17 	ldw	r6,-12(fp)
81105a60:	01400504 	movi	r5,20
81105a64:	01204834 	movhi	r4,33056
81105a68:	210b0004 	addi	r4,r4,11264
81105a6c:	1106cb40 	call	81106cb4 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105a70:	00000206 	br	81105a7c <bFeebCh1SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105a74:	e03ffc15 	stw	zero,-16(fp)
			break;
81105a78:	0001883a 	nop
		}
	} else {
81105a7c:	00000106 	br	81105a84 <bFeebCh1SetBufferSize+0xbc>
		bStatus = FALSE;
81105a80:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105a84:	e0bffc17 	ldw	r2,-16(fp)
}
81105a88:	e037883a 	mov	sp,fp
81105a8c:	dfc00117 	ldw	ra,4(sp)
81105a90:	df000017 	ldw	fp,0(sp)
81105a94:	dec00204 	addi	sp,sp,8
81105a98:	f800283a 	ret

81105a9c <bFeebCh2SetBufferSize>:

bool bFeebCh2SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105a9c:	defffa04 	addi	sp,sp,-24
81105aa0:	de00012e 	bgeu	sp,et,81105aa8 <bFeebCh2SetBufferSize+0xc>
81105aa4:	003b68fa 	trap	3
81105aa8:	dfc00515 	stw	ra,20(sp)
81105aac:	df000415 	stw	fp,16(sp)
81105ab0:	df000404 	addi	fp,sp,16
81105ab4:	2007883a 	mov	r3,r4
81105ab8:	2805883a 	mov	r2,r5
81105abc:	e0fffe05 	stb	r3,-8(fp)
81105ac0:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105ac4:	00800044 	movi	r2,1
81105ac8:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105acc:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105ad0:	e0bffe03 	ldbu	r2,-8(fp)
81105ad4:	10001f26 	beq	r2,zero,81105b54 <bFeebCh2SetBufferSize+0xb8>
81105ad8:	e0bffe03 	ldbu	r2,-8(fp)
81105adc:	10800468 	cmpgeui	r2,r2,17
81105ae0:	10001c1e 	bne	r2,zero,81105b54 <bFeebCh2SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105ae4:	e0bfff03 	ldbu	r2,-4(fp)
81105ae8:	10000326 	beq	r2,zero,81105af8 <bFeebCh2SetBufferSize+0x5c>
81105aec:	10800060 	cmpeqi	r2,r2,1
81105af0:	10000b1e 	bne	r2,zero,81105b20 <bFeebCh2SetBufferSize+0x84>
81105af4:	00001406 	br	81105b48 <bFeebCh2SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105af8:	e0bffe03 	ldbu	r2,-8(fp)
81105afc:	10bfffc4 	addi	r2,r2,-1
81105b00:	108003cc 	andi	r2,r2,15
81105b04:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81105b08:	e1bffd17 	ldw	r6,-12(fp)
81105b0c:	01400544 	movi	r5,21
81105b10:	01204834 	movhi	r4,33056
81105b14:	210a0004 	addi	r4,r4,10240
81105b18:	1106cb40 	call	81106cb4 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105b1c:	00000c06 	br	81105b50 <bFeebCh2SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105b20:	e0bffe03 	ldbu	r2,-8(fp)
81105b24:	10bfffc4 	addi	r2,r2,-1
81105b28:	108003cc 	andi	r2,r2,15
81105b2c:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81105b30:	e1bffd17 	ldw	r6,-12(fp)
81105b34:	01400504 	movi	r5,20
81105b38:	01204834 	movhi	r4,33056
81105b3c:	210a0004 	addi	r4,r4,10240
81105b40:	1106cb40 	call	81106cb4 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105b44:	00000206 	br	81105b50 <bFeebCh2SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105b48:	e03ffc15 	stw	zero,-16(fp)
			break;
81105b4c:	0001883a 	nop
		}
	} else {
81105b50:	00000106 	br	81105b58 <bFeebCh2SetBufferSize+0xbc>
		bStatus = FALSE;
81105b54:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105b58:	e0bffc17 	ldw	r2,-16(fp)
}
81105b5c:	e037883a 	mov	sp,fp
81105b60:	dfc00117 	ldw	ra,4(sp)
81105b64:	df000017 	ldw	fp,0(sp)
81105b68:	dec00204 	addi	sp,sp,8
81105b6c:	f800283a 	ret

81105b70 <bFeebCh3SetBufferSize>:

bool bFeebCh3SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105b70:	defffa04 	addi	sp,sp,-24
81105b74:	de00012e 	bgeu	sp,et,81105b7c <bFeebCh3SetBufferSize+0xc>
81105b78:	003b68fa 	trap	3
81105b7c:	dfc00515 	stw	ra,20(sp)
81105b80:	df000415 	stw	fp,16(sp)
81105b84:	df000404 	addi	fp,sp,16
81105b88:	2007883a 	mov	r3,r4
81105b8c:	2805883a 	mov	r2,r5
81105b90:	e0fffe05 	stb	r3,-8(fp)
81105b94:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105b98:	00800044 	movi	r2,1
81105b9c:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105ba0:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105ba4:	e0bffe03 	ldbu	r2,-8(fp)
81105ba8:	10001f26 	beq	r2,zero,81105c28 <bFeebCh3SetBufferSize+0xb8>
81105bac:	e0bffe03 	ldbu	r2,-8(fp)
81105bb0:	10800468 	cmpgeui	r2,r2,17
81105bb4:	10001c1e 	bne	r2,zero,81105c28 <bFeebCh3SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105bb8:	e0bfff03 	ldbu	r2,-4(fp)
81105bbc:	10000326 	beq	r2,zero,81105bcc <bFeebCh3SetBufferSize+0x5c>
81105bc0:	10800060 	cmpeqi	r2,r2,1
81105bc4:	10000b1e 	bne	r2,zero,81105bf4 <bFeebCh3SetBufferSize+0x84>
81105bc8:	00001406 	br	81105c1c <bFeebCh3SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105bcc:	e0bffe03 	ldbu	r2,-8(fp)
81105bd0:	10bfffc4 	addi	r2,r2,-1
81105bd4:	108003cc 	andi	r2,r2,15
81105bd8:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105bdc:	e1bffd17 	ldw	r6,-12(fp)
81105be0:	01400544 	movi	r5,21
81105be4:	01204834 	movhi	r4,33056
81105be8:	210b0004 	addi	r4,r4,11264
81105bec:	1106cb40 	call	81106cb4 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105bf0:	00000c06 	br	81105c24 <bFeebCh3SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105bf4:	e0bffe03 	ldbu	r2,-8(fp)
81105bf8:	10bfffc4 	addi	r2,r2,-1
81105bfc:	108003cc 	andi	r2,r2,15
81105c00:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105c04:	e1bffd17 	ldw	r6,-12(fp)
81105c08:	01400504 	movi	r5,20
81105c0c:	01204834 	movhi	r4,33056
81105c10:	210b0004 	addi	r4,r4,11264
81105c14:	1106cb40 	call	81106cb4 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105c18:	00000206 	br	81105c24 <bFeebCh3SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105c1c:	e03ffc15 	stw	zero,-16(fp)
			break;
81105c20:	0001883a 	nop
		}
	} else {
81105c24:	00000106 	br	81105c2c <bFeebCh3SetBufferSize+0xbc>
		bStatus = FALSE;
81105c28:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105c2c:	e0bffc17 	ldw	r2,-16(fp)
}
81105c30:	e037883a 	mov	sp,fp
81105c34:	dfc00117 	ldw	ra,4(sp)
81105c38:	df000017 	ldw	fp,0(sp)
81105c3c:	dec00204 	addi	sp,sp,8
81105c40:	f800283a 	ret

81105c44 <bFeebCh4SetBufferSize>:

bool bFeebCh4SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105c44:	defffa04 	addi	sp,sp,-24
81105c48:	de00012e 	bgeu	sp,et,81105c50 <bFeebCh4SetBufferSize+0xc>
81105c4c:	003b68fa 	trap	3
81105c50:	dfc00515 	stw	ra,20(sp)
81105c54:	df000415 	stw	fp,16(sp)
81105c58:	df000404 	addi	fp,sp,16
81105c5c:	2007883a 	mov	r3,r4
81105c60:	2805883a 	mov	r2,r5
81105c64:	e0fffe05 	stb	r3,-8(fp)
81105c68:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105c6c:	00800044 	movi	r2,1
81105c70:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105c74:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105c78:	e0bffe03 	ldbu	r2,-8(fp)
81105c7c:	10001f26 	beq	r2,zero,81105cfc <bFeebCh4SetBufferSize+0xb8>
81105c80:	e0bffe03 	ldbu	r2,-8(fp)
81105c84:	10800468 	cmpgeui	r2,r2,17
81105c88:	10001c1e 	bne	r2,zero,81105cfc <bFeebCh4SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105c8c:	e0bfff03 	ldbu	r2,-4(fp)
81105c90:	10000326 	beq	r2,zero,81105ca0 <bFeebCh4SetBufferSize+0x5c>
81105c94:	10800060 	cmpeqi	r2,r2,1
81105c98:	10000b1e 	bne	r2,zero,81105cc8 <bFeebCh4SetBufferSize+0x84>
81105c9c:	00001406 	br	81105cf0 <bFeebCh4SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105ca0:	e0bffe03 	ldbu	r2,-8(fp)
81105ca4:	10bfffc4 	addi	r2,r2,-1
81105ca8:	108003cc 	andi	r2,r2,15
81105cac:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81105cb0:	e1bffd17 	ldw	r6,-12(fp)
81105cb4:	01400544 	movi	r5,21
81105cb8:	01204834 	movhi	r4,33056
81105cbc:	210a0004 	addi	r4,r4,10240
81105cc0:	1106cb40 	call	81106cb4 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105cc4:	00000c06 	br	81105cf8 <bFeebCh4SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105cc8:	e0bffe03 	ldbu	r2,-8(fp)
81105ccc:	10bfffc4 	addi	r2,r2,-1
81105cd0:	108003cc 	andi	r2,r2,15
81105cd4:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81105cd8:	e1bffd17 	ldw	r6,-12(fp)
81105cdc:	01400504 	movi	r5,20
81105ce0:	01204834 	movhi	r4,33056
81105ce4:	210a0004 	addi	r4,r4,10240
81105ce8:	1106cb40 	call	81106cb4 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105cec:	00000206 	br	81105cf8 <bFeebCh4SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105cf0:	e03ffc15 	stw	zero,-16(fp)
			break;
81105cf4:	0001883a 	nop
		}
	} else {
81105cf8:	00000106 	br	81105d00 <bFeebCh4SetBufferSize+0xbc>
		bStatus = FALSE;
81105cfc:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105d00:	e0bffc17 	ldw	r2,-16(fp)
}
81105d04:	e037883a 	mov	sp,fp
81105d08:	dfc00117 	ldw	ra,4(sp)
81105d0c:	df000017 	ldw	fp,0(sp)
81105d10:	dec00204 	addi	sp,sp,8
81105d14:	f800283a 	ret

81105d18 <bFeebCh5SetBufferSize>:

bool bFeebCh5SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105d18:	defffa04 	addi	sp,sp,-24
81105d1c:	de00012e 	bgeu	sp,et,81105d24 <bFeebCh5SetBufferSize+0xc>
81105d20:	003b68fa 	trap	3
81105d24:	dfc00515 	stw	ra,20(sp)
81105d28:	df000415 	stw	fp,16(sp)
81105d2c:	df000404 	addi	fp,sp,16
81105d30:	2007883a 	mov	r3,r4
81105d34:	2805883a 	mov	r2,r5
81105d38:	e0fffe05 	stb	r3,-8(fp)
81105d3c:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105d40:	00800044 	movi	r2,1
81105d44:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105d48:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105d4c:	e0bffe03 	ldbu	r2,-8(fp)
81105d50:	10001f26 	beq	r2,zero,81105dd0 <bFeebCh5SetBufferSize+0xb8>
81105d54:	e0bffe03 	ldbu	r2,-8(fp)
81105d58:	10800468 	cmpgeui	r2,r2,17
81105d5c:	10001c1e 	bne	r2,zero,81105dd0 <bFeebCh5SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105d60:	e0bfff03 	ldbu	r2,-4(fp)
81105d64:	10000326 	beq	r2,zero,81105d74 <bFeebCh5SetBufferSize+0x5c>
81105d68:	10800060 	cmpeqi	r2,r2,1
81105d6c:	10000b1e 	bne	r2,zero,81105d9c <bFeebCh5SetBufferSize+0x84>
81105d70:	00001406 	br	81105dc4 <bFeebCh5SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105d74:	e0bffe03 	ldbu	r2,-8(fp)
81105d78:	10bfffc4 	addi	r2,r2,-1
81105d7c:	108003cc 	andi	r2,r2,15
81105d80:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105d84:	e1bffd17 	ldw	r6,-12(fp)
81105d88:	01400544 	movi	r5,21
81105d8c:	01204834 	movhi	r4,33056
81105d90:	210b0004 	addi	r4,r4,11264
81105d94:	1106cb40 	call	81106cb4 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105d98:	00000c06 	br	81105dcc <bFeebCh5SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105d9c:	e0bffe03 	ldbu	r2,-8(fp)
81105da0:	10bfffc4 	addi	r2,r2,-1
81105da4:	108003cc 	andi	r2,r2,15
81105da8:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105dac:	e1bffd17 	ldw	r6,-12(fp)
81105db0:	01400504 	movi	r5,20
81105db4:	01204834 	movhi	r4,33056
81105db8:	210b0004 	addi	r4,r4,11264
81105dbc:	1106cb40 	call	81106cb4 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105dc0:	00000206 	br	81105dcc <bFeebCh5SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105dc4:	e03ffc15 	stw	zero,-16(fp)
			break;
81105dc8:	0001883a 	nop
		}
	} else {
81105dcc:	00000106 	br	81105dd4 <bFeebCh5SetBufferSize+0xbc>
		bStatus = FALSE;
81105dd0:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105dd4:	e0bffc17 	ldw	r2,-16(fp)
}
81105dd8:	e037883a 	mov	sp,fp
81105ddc:	dfc00117 	ldw	ra,4(sp)
81105de0:	df000017 	ldw	fp,0(sp)
81105de4:	dec00204 	addi	sp,sp,8
81105de8:	f800283a 	ret

81105dec <bFeebCh6SetBufferSize>:

bool bFeebCh6SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105dec:	defffa04 	addi	sp,sp,-24
81105df0:	de00012e 	bgeu	sp,et,81105df8 <bFeebCh6SetBufferSize+0xc>
81105df4:	003b68fa 	trap	3
81105df8:	dfc00515 	stw	ra,20(sp)
81105dfc:	df000415 	stw	fp,16(sp)
81105e00:	df000404 	addi	fp,sp,16
81105e04:	2007883a 	mov	r3,r4
81105e08:	2805883a 	mov	r2,r5
81105e0c:	e0fffe05 	stb	r3,-8(fp)
81105e10:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105e14:	00800044 	movi	r2,1
81105e18:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105e1c:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105e20:	e0bffe03 	ldbu	r2,-8(fp)
81105e24:	10001f26 	beq	r2,zero,81105ea4 <bFeebCh6SetBufferSize+0xb8>
81105e28:	e0bffe03 	ldbu	r2,-8(fp)
81105e2c:	10800468 	cmpgeui	r2,r2,17
81105e30:	10001c1e 	bne	r2,zero,81105ea4 <bFeebCh6SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105e34:	e0bfff03 	ldbu	r2,-4(fp)
81105e38:	10000326 	beq	r2,zero,81105e48 <bFeebCh6SetBufferSize+0x5c>
81105e3c:	10800060 	cmpeqi	r2,r2,1
81105e40:	10000b1e 	bne	r2,zero,81105e70 <bFeebCh6SetBufferSize+0x84>
81105e44:	00001406 	br	81105e98 <bFeebCh6SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105e48:	e0bffe03 	ldbu	r2,-8(fp)
81105e4c:	10bfffc4 	addi	r2,r2,-1
81105e50:	108003cc 	andi	r2,r2,15
81105e54:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105e58:	e1bffd17 	ldw	r6,-12(fp)
81105e5c:	01400544 	movi	r5,21
81105e60:	01204834 	movhi	r4,33056
81105e64:	210a0004 	addi	r4,r4,10240
81105e68:	1106cb40 	call	81106cb4 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105e6c:	00000c06 	br	81105ea0 <bFeebCh6SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105e70:	e0bffe03 	ldbu	r2,-8(fp)
81105e74:	10bfffc4 	addi	r2,r2,-1
81105e78:	108003cc 	andi	r2,r2,15
81105e7c:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105e80:	e1bffd17 	ldw	r6,-12(fp)
81105e84:	01400504 	movi	r5,20
81105e88:	01204834 	movhi	r4,33056
81105e8c:	210a0004 	addi	r4,r4,10240
81105e90:	1106cb40 	call	81106cb4 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105e94:	00000206 	br	81105ea0 <bFeebCh6SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105e98:	e03ffc15 	stw	zero,-16(fp)
			break;
81105e9c:	0001883a 	nop
		}
	} else {
81105ea0:	00000106 	br	81105ea8 <bFeebCh6SetBufferSize+0xbc>
		bStatus = FALSE;
81105ea4:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105ea8:	e0bffc17 	ldw	r2,-16(fp)
}
81105eac:	e037883a 	mov	sp,fp
81105eb0:	dfc00117 	ldw	ra,4(sp)
81105eb4:	df000017 	ldw	fp,0(sp)
81105eb8:	dec00204 	addi	sp,sp,8
81105ebc:	f800283a 	ret

81105ec0 <bFeebCh7SetBufferSize>:

bool bFeebCh7SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105ec0:	defffa04 	addi	sp,sp,-24
81105ec4:	de00012e 	bgeu	sp,et,81105ecc <bFeebCh7SetBufferSize+0xc>
81105ec8:	003b68fa 	trap	3
81105ecc:	dfc00515 	stw	ra,20(sp)
81105ed0:	df000415 	stw	fp,16(sp)
81105ed4:	df000404 	addi	fp,sp,16
81105ed8:	2007883a 	mov	r3,r4
81105edc:	2805883a 	mov	r2,r5
81105ee0:	e0fffe05 	stb	r3,-8(fp)
81105ee4:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105ee8:	00800044 	movi	r2,1
81105eec:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105ef0:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105ef4:	e0bffe03 	ldbu	r2,-8(fp)
81105ef8:	10001f26 	beq	r2,zero,81105f78 <bFeebCh7SetBufferSize+0xb8>
81105efc:	e0bffe03 	ldbu	r2,-8(fp)
81105f00:	10800468 	cmpgeui	r2,r2,17
81105f04:	10001c1e 	bne	r2,zero,81105f78 <bFeebCh7SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105f08:	e0bfff03 	ldbu	r2,-4(fp)
81105f0c:	10000326 	beq	r2,zero,81105f1c <bFeebCh7SetBufferSize+0x5c>
81105f10:	10800060 	cmpeqi	r2,r2,1
81105f14:	10000b1e 	bne	r2,zero,81105f44 <bFeebCh7SetBufferSize+0x84>
81105f18:	00001406 	br	81105f6c <bFeebCh7SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105f1c:	e0bffe03 	ldbu	r2,-8(fp)
81105f20:	10bfffc4 	addi	r2,r2,-1
81105f24:	108003cc 	andi	r2,r2,15
81105f28:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81105f2c:	e1bffd17 	ldw	r6,-12(fp)
81105f30:	01400544 	movi	r5,21
81105f34:	01204834 	movhi	r4,33056
81105f38:	210b0004 	addi	r4,r4,11264
81105f3c:	1106cb40 	call	81106cb4 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105f40:	00000c06 	br	81105f74 <bFeebCh7SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105f44:	e0bffe03 	ldbu	r2,-8(fp)
81105f48:	10bfffc4 	addi	r2,r2,-1
81105f4c:	108003cc 	andi	r2,r2,15
81105f50:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81105f54:	e1bffd17 	ldw	r6,-12(fp)
81105f58:	01400504 	movi	r5,20
81105f5c:	01204834 	movhi	r4,33056
81105f60:	210b0004 	addi	r4,r4,11264
81105f64:	1106cb40 	call	81106cb4 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105f68:	00000206 	br	81105f74 <bFeebCh7SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105f6c:	e03ffc15 	stw	zero,-16(fp)
			break;
81105f70:	0001883a 	nop
		}
	} else {
81105f74:	00000106 	br	81105f7c <bFeebCh7SetBufferSize+0xbc>
		bStatus = FALSE;
81105f78:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105f7c:	e0bffc17 	ldw	r2,-16(fp)
}
81105f80:	e037883a 	mov	sp,fp
81105f84:	dfc00117 	ldw	ra,4(sp)
81105f88:	df000017 	ldw	fp,0(sp)
81105f8c:	dec00204 	addi	sp,sp,8
81105f90:	f800283a 	ret

81105f94 <bFeebCh8SetBufferSize>:

bool bFeebCh8SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105f94:	defffa04 	addi	sp,sp,-24
81105f98:	de00012e 	bgeu	sp,et,81105fa0 <bFeebCh8SetBufferSize+0xc>
81105f9c:	003b68fa 	trap	3
81105fa0:	dfc00515 	stw	ra,20(sp)
81105fa4:	df000415 	stw	fp,16(sp)
81105fa8:	df000404 	addi	fp,sp,16
81105fac:	2007883a 	mov	r3,r4
81105fb0:	2805883a 	mov	r2,r5
81105fb4:	e0fffe05 	stb	r3,-8(fp)
81105fb8:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105fbc:	00800044 	movi	r2,1
81105fc0:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105fc4:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105fc8:	e0bffe03 	ldbu	r2,-8(fp)
81105fcc:	10001f26 	beq	r2,zero,8110604c <bFeebCh8SetBufferSize+0xb8>
81105fd0:	e0bffe03 	ldbu	r2,-8(fp)
81105fd4:	10800468 	cmpgeui	r2,r2,17
81105fd8:	10001c1e 	bne	r2,zero,8110604c <bFeebCh8SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105fdc:	e0bfff03 	ldbu	r2,-4(fp)
81105fe0:	10000326 	beq	r2,zero,81105ff0 <bFeebCh8SetBufferSize+0x5c>
81105fe4:	10800060 	cmpeqi	r2,r2,1
81105fe8:	10000b1e 	bne	r2,zero,81106018 <bFeebCh8SetBufferSize+0x84>
81105fec:	00001406 	br	81106040 <bFeebCh8SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105ff0:	e0bffe03 	ldbu	r2,-8(fp)
81105ff4:	10bfffc4 	addi	r2,r2,-1
81105ff8:	108003cc 	andi	r2,r2,15
81105ffc:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81106000:	e1bffd17 	ldw	r6,-12(fp)
81106004:	01400544 	movi	r5,21
81106008:	01204834 	movhi	r4,33056
8110600c:	210a0004 	addi	r4,r4,10240
81106010:	1106cb40 	call	81106cb4 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81106014:	00000c06 	br	81106048 <bFeebCh8SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81106018:	e0bffe03 	ldbu	r2,-8(fp)
8110601c:	10bfffc4 	addi	r2,r2,-1
81106020:	108003cc 	andi	r2,r2,15
81106024:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81106028:	e1bffd17 	ldw	r6,-12(fp)
8110602c:	01400504 	movi	r5,20
81106030:	01204834 	movhi	r4,33056
81106034:	210a0004 	addi	r4,r4,10240
81106038:	1106cb40 	call	81106cb4 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
8110603c:	00000206 	br	81106048 <bFeebCh8SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81106040:	e03ffc15 	stw	zero,-16(fp)
			break;
81106044:	0001883a 	nop
		}
	} else {
81106048:	00000106 	br	81106050 <bFeebCh8SetBufferSize+0xbc>
		bStatus = FALSE;
8110604c:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81106050:	e0bffc17 	ldw	r2,-16(fp)
}
81106054:	e037883a 	mov	sp,fp
81106058:	dfc00117 	ldw	ra,4(sp)
8110605c:	df000017 	ldw	fp,0(sp)
81106060:	dec00204 	addi	sp,sp,8
81106064:	f800283a 	ret

81106068 <vFeebInitIrq>:

void vFeebInitIrq(alt_u8 ucCommCh) {
81106068:	defffc04 	addi	sp,sp,-16
8110606c:	de00012e 	bgeu	sp,et,81106074 <vFeebInitIrq+0xc>
81106070:	003b68fa 	trap	3
81106074:	dfc00315 	stw	ra,12(sp)
81106078:	df000215 	stw	fp,8(sp)
8110607c:	df000204 	addi	fp,sp,8
81106080:	2005883a 	mov	r2,r4
81106084:	e0bfff05 	stb	r2,-4(fp)
	void* pvHoldContext;
	switch (ucCommCh) {
81106088:	e0bfff03 	ldbu	r2,-4(fp)
8110608c:	10c00228 	cmpgeui	r3,r2,8
81106090:	18004e1e 	bne	r3,zero,811061cc <vFeebInitIrq+0x164>
81106094:	100690ba 	slli	r3,r2,2
81106098:	00a04434 	movhi	r2,33040
8110609c:	10982b04 	addi	r2,r2,24748
811060a0:	1885883a 	add	r2,r3,r2
811060a4:	10800017 	ldw	r2,0(r2)
811060a8:	1000683a 	jmp	r2
811060ac:	811060cc 	andi	r4,r16,16771
811060b0:	811060ec 	andhi	r4,r16,16771
811060b4:	8110610c 	andi	r4,r16,16772
811060b8:	8110612c 	andhi	r4,r16,16772
811060bc:	8110614c 	andi	r4,r16,16773
811060c0:	8110616c 	andhi	r4,r16,16773
811060c4:	8110618c 	andi	r4,r16,16774
811060c8:	811061ac 	andhi	r4,r16,16774
	case eCommSpwCh1:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh1HoldContext;
811060cc:	d0a04004 	addi	r2,gp,-32512
811060d0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_1_BUFFERS_IRQ, pvHoldContext,
811060d4:	01a04434 	movhi	r6,33040
811060d8:	31946504 	addi	r6,r6,20884
811060dc:	e17ffe17 	ldw	r5,-8(fp)
811060e0:	01000584 	movi	r4,22
811060e4:	1135fec0 	call	81135fec <alt_irq_register>
				vFeebCh1HandleIrq);
		break;
811060e8:	00003806 	br	811061cc <vFeebInitIrq+0x164>
	case eCommSpwCh2:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh2HoldContext;
811060ec:	d0a04104 	addi	r2,gp,-32508
811060f0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_2_BUFFERS_IRQ, pvHoldContext,
811060f4:	01a04434 	movhi	r6,33040
811060f8:	31947504 	addi	r6,r6,20948
811060fc:	e17ffe17 	ldw	r5,-8(fp)
81106100:	01000504 	movi	r4,20
81106104:	1135fec0 	call	81135fec <alt_irq_register>
				vFeebCh2HandleIrq);
		break;
81106108:	00003006 	br	811061cc <vFeebInitIrq+0x164>
	case eCommSpwCh3:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh3HoldContext;
8110610c:	d0a04204 	addi	r2,gp,-32504
81106110:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_3_BUFFERS_IRQ, pvHoldContext,
81106114:	01a04434 	movhi	r6,33040
81106118:	31949604 	addi	r6,r6,21080
8110611c:	e17ffe17 	ldw	r5,-8(fp)
81106120:	01000484 	movi	r4,18
81106124:	1135fec0 	call	81135fec <alt_irq_register>
				vFeebCh3HandleIrq);
		break;
81106128:	00002806 	br	811061cc <vFeebInitIrq+0x164>
	case eCommSpwCh4:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh4HoldContext;
8110612c:	d0a04304 	addi	r2,gp,-32500
81106130:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_4_BUFFERS_IRQ, pvHoldContext,
81106134:	01a04434 	movhi	r6,33040
81106138:	3194b704 	addi	r6,r6,21212
8110613c:	e17ffe17 	ldw	r5,-8(fp)
81106140:	01000404 	movi	r4,16
81106144:	1135fec0 	call	81135fec <alt_irq_register>
				vFeebCh4HandleIrq);
		break;
81106148:	00002006 	br	811061cc <vFeebInitIrq+0x164>
	case eCommSpwCh5:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh5HoldContext;
8110614c:	d0a04404 	addi	r2,gp,-32496
81106150:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_5_BUFFERS_IRQ, pvHoldContext,
81106154:	01a04434 	movhi	r6,33040
81106158:	3194d804 	addi	r6,r6,21344
8110615c:	e17ffe17 	ldw	r5,-8(fp)
81106160:	01000204 	movi	r4,8
81106164:	1135fec0 	call	81135fec <alt_irq_register>
				vFeebCh5HandleIrq);
		break;
81106168:	00001806 	br	811061cc <vFeebInitIrq+0x164>
	case eCommSpwCh6:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh6HoldContext;
8110616c:	d0a04504 	addi	r2,gp,-32492
81106170:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_6_BUFFERS_IRQ, pvHoldContext,
81106174:	01a04434 	movhi	r6,33040
81106178:	3194f904 	addi	r6,r6,21476
8110617c:	e17ffe17 	ldw	r5,-8(fp)
81106180:	01000184 	movi	r4,6
81106184:	1135fec0 	call	81135fec <alt_irq_register>
				vFeebCh6HandleIrq);
		break;
81106188:	00001006 	br	811061cc <vFeebInitIrq+0x164>
	case eCommSpwCh7:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh7HoldContext;
8110618c:	d0a04604 	addi	r2,gp,-32488
81106190:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_7_BUFFERS_IRQ, pvHoldContext,
81106194:	01a04434 	movhi	r6,33040
81106198:	31951a04 	addi	r6,r6,21608
8110619c:	e17ffe17 	ldw	r5,-8(fp)
811061a0:	01000144 	movi	r4,5
811061a4:	1135fec0 	call	81135fec <alt_irq_register>
				vFeebCh7HandleIrq);
		break;
811061a8:	00000806 	br	811061cc <vFeebInitIrq+0x164>
	case eCommSpwCh8:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh8HoldContext;
811061ac:	d0a04704 	addi	r2,gp,-32484
811061b0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_8_BUFFERS_IRQ, pvHoldContext,
811061b4:	01a04434 	movhi	r6,33040
811061b8:	31952a04 	addi	r6,r6,21672
811061bc:	e17ffe17 	ldw	r5,-8(fp)
811061c0:	01000084 	movi	r4,2
811061c4:	1135fec0 	call	81135fec <alt_irq_register>
				vFeebCh8HandleIrq);
		break;
811061c8:	0001883a 	nop
	}
}
811061cc:	0001883a 	nop
811061d0:	e037883a 	mov	sp,fp
811061d4:	dfc00117 	ldw	ra,4(sp)
811061d8:	df000017 	ldw	fp,0(sp)
811061dc:	dec00204 	addi	sp,sp,8
811061e0:	f800283a 	ret

811061e4 <bFeebSetIrqControl>:

bool bFeebSetIrqControl(TFeebChannel *pxFeebCh) {
811061e4:	defffb04 	addi	sp,sp,-20
811061e8:	de00012e 	bgeu	sp,et,811061f0 <bFeebSetIrqControl+0xc>
811061ec:	003b68fa 	trap	3
811061f0:	dfc00415 	stw	ra,16(sp)
811061f4:	df000315 	stw	fp,12(sp)
811061f8:	df000304 	addi	fp,sp,12
811061fc:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106200:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106204:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106208:	e0bfff17 	ldw	r2,-4(fp)
8110620c:	10002426 	beq	r2,zero,811062a0 <bFeebSetIrqControl+0xbc>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106210:	e0bfff17 	ldw	r2,-4(fp)
81106214:	10800017 	ldw	r2,0(r2)
81106218:	01400444 	movi	r5,17
8110621c:	1009883a 	mov	r4,r2
81106220:	1106d080 	call	81106d08 <uliFeebReadReg>
81106224:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (pxFeebCh->xIrqControl.bLeftBufferEmptyEn) {
81106228:	e0bfff17 	ldw	r2,-4(fp)
8110622c:	10800217 	ldw	r2,8(r2)
81106230:	10000426 	beq	r2,zero,81106244 <bFeebSetIrqControl+0x60>
			uliReg |= COMM_IRQ_LEFT_BUFF_EPY_EN_MSK;
81106234:	e0bffe17 	ldw	r2,-8(fp)
81106238:	10808014 	ori	r2,r2,512
8110623c:	e0bffe15 	stw	r2,-8(fp)
81106240:	00000406 	br	81106254 <bFeebSetIrqControl+0x70>
		} else {
			uliReg &= (~COMM_IRQ_LEFT_BUFF_EPY_EN_MSK);
81106244:	e0fffe17 	ldw	r3,-8(fp)
81106248:	00bf7fc4 	movi	r2,-513
8110624c:	1884703a 	and	r2,r3,r2
81106250:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxFeebCh->xIrqControl.bRightBufferEmptyEn) {
81106254:	e0bfff17 	ldw	r2,-4(fp)
81106258:	10800317 	ldw	r2,12(r2)
8110625c:	10000426 	beq	r2,zero,81106270 <bFeebSetIrqControl+0x8c>
			uliReg |= COMM_IRQ_RIGH_BUFF_EPY_EN_MSK;
81106260:	e0bffe17 	ldw	r2,-8(fp)
81106264:	10804014 	ori	r2,r2,256
81106268:	e0bffe15 	stw	r2,-8(fp)
8110626c:	00000406 	br	81106280 <bFeebSetIrqControl+0x9c>
		} else {
			uliReg &= (~COMM_IRQ_RIGH_BUFF_EPY_EN_MSK);
81106270:	e0fffe17 	ldw	r3,-8(fp)
81106274:	00bfbfc4 	movi	r2,-257
81106278:	1884703a 	and	r2,r3,r2
8110627c:	e0bffe15 	stw	r2,-8(fp)
		}

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_IRQ_CONTROL_REG_OFST,
81106280:	e0bfff17 	ldw	r2,-4(fp)
81106284:	10800017 	ldw	r2,0(r2)
81106288:	e1bffe17 	ldw	r6,-8(fp)
8110628c:	01400444 	movi	r5,17
81106290:	1009883a 	mov	r4,r2
81106294:	1106cb40 	call	81106cb4 <vFeebWriteReg>
				uliReg);
		bStatus = TRUE;
81106298:	00800044 	movi	r2,1
8110629c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811062a0:	e0bffd17 	ldw	r2,-12(fp)
}
811062a4:	e037883a 	mov	sp,fp
811062a8:	dfc00117 	ldw	ra,4(sp)
811062ac:	df000017 	ldw	fp,0(sp)
811062b0:	dec00204 	addi	sp,sp,8
811062b4:	f800283a 	ret

811062b8 <bFeebGetIrqControl>:

bool bFeebGetIrqControl(TFeebChannel *pxFeebCh) {
811062b8:	defffb04 	addi	sp,sp,-20
811062bc:	de00012e 	bgeu	sp,et,811062c4 <bFeebGetIrqControl+0xc>
811062c0:	003b68fa 	trap	3
811062c4:	dfc00415 	stw	ra,16(sp)
811062c8:	df000315 	stw	fp,12(sp)
811062cc:	df000304 	addi	fp,sp,12
811062d0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811062d4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811062d8:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811062dc:	e0bfff17 	ldw	r2,-4(fp)
811062e0:	10001a26 	beq	r2,zero,8110634c <bFeebGetIrqControl+0x94>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811062e4:	e0bfff17 	ldw	r2,-4(fp)
811062e8:	10800017 	ldw	r2,0(r2)
811062ec:	01400444 	movi	r5,17
811062f0:	1009883a 	mov	r4,r2
811062f4:	1106d080 	call	81106d08 <uliFeebReadReg>
811062f8:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (uliReg & COMM_IRQ_LEFT_BUFF_EPY_EN_MSK) {
811062fc:	e0bffe17 	ldw	r2,-8(fp)
81106300:	1080800c 	andi	r2,r2,512
81106304:	10000426 	beq	r2,zero,81106318 <bFeebGetIrqControl+0x60>
			pxFeebCh->xIrqControl.bLeftBufferEmptyEn = TRUE;
81106308:	e0bfff17 	ldw	r2,-4(fp)
8110630c:	00c00044 	movi	r3,1
81106310:	10c00215 	stw	r3,8(r2)
81106314:	00000206 	br	81106320 <bFeebGetIrqControl+0x68>
		} else {
			pxFeebCh->xIrqControl.bLeftBufferEmptyEn = FALSE;
81106318:	e0bfff17 	ldw	r2,-4(fp)
8110631c:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_IRQ_RIGH_BUFF_EPY_EN_MSK) {
81106320:	e0bffe17 	ldw	r2,-8(fp)
81106324:	1080400c 	andi	r2,r2,256
81106328:	10000426 	beq	r2,zero,8110633c <bFeebGetIrqControl+0x84>
			pxFeebCh->xIrqControl.bRightBufferEmptyEn = TRUE;
8110632c:	e0bfff17 	ldw	r2,-4(fp)
81106330:	00c00044 	movi	r3,1
81106334:	10c00315 	stw	r3,12(r2)
81106338:	00000206 	br	81106344 <bFeebGetIrqControl+0x8c>
		} else {
			pxFeebCh->xIrqControl.bRightBufferEmptyEn = FALSE;
8110633c:	e0bfff17 	ldw	r2,-4(fp)
81106340:	10000315 	stw	zero,12(r2)
		}

		bStatus = TRUE;
81106344:	00800044 	movi	r2,1
81106348:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110634c:	e0bffd17 	ldw	r2,-12(fp)
}
81106350:	e037883a 	mov	sp,fp
81106354:	dfc00117 	ldw	ra,4(sp)
81106358:	df000017 	ldw	fp,0(sp)
8110635c:	dec00204 	addi	sp,sp,8
81106360:	f800283a 	ret

81106364 <bFeebGetIrqFlags>:

bool bFeebGetIrqFlags(TFeebChannel *pxFeebCh) {
81106364:	defffb04 	addi	sp,sp,-20
81106368:	de00012e 	bgeu	sp,et,81106370 <bFeebGetIrqFlags+0xc>
8110636c:	003b68fa 	trap	3
81106370:	dfc00415 	stw	ra,16(sp)
81106374:	df000315 	stw	fp,12(sp)
81106378:	df000304 	addi	fp,sp,12
8110637c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106380:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106384:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106388:	e0bfff17 	ldw	r2,-4(fp)
8110638c:	10001126 	beq	r2,zero,811063d4 <bFeebGetIrqFlags+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106390:	e0bfff17 	ldw	r2,-4(fp)
81106394:	10800017 	ldw	r2,0(r2)
81106398:	01400484 	movi	r5,18
8110639c:	1009883a 	mov	r4,r2
811063a0:	1106d080 	call	81106d08 <uliFeebReadReg>
811063a4:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_FLAGS_REG_OFST);

		if (uliReg & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811063a8:	e0bffe17 	ldw	r2,-8(fp)
811063ac:	1080400c 	andi	r2,r2,256
811063b0:	10000426 	beq	r2,zero,811063c4 <bFeebGetIrqFlags+0x60>
			pxFeebCh->xIrqFlag.bBufferEmptyFlag = TRUE;
811063b4:	e0bfff17 	ldw	r2,-4(fp)
811063b8:	00c00044 	movi	r3,1
811063bc:	10c00415 	stw	r3,16(r2)
811063c0:	00000206 	br	811063cc <bFeebGetIrqFlags+0x68>
		} else {
			pxFeebCh->xIrqFlag.bBufferEmptyFlag = FALSE;
811063c4:	e0bfff17 	ldw	r2,-4(fp)
811063c8:	10000415 	stw	zero,16(r2)
		}

		bStatus = TRUE;
811063cc:	00800044 	movi	r2,1
811063d0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811063d4:	e0bffd17 	ldw	r2,-12(fp)
}
811063d8:	e037883a 	mov	sp,fp
811063dc:	dfc00117 	ldw	ra,4(sp)
811063e0:	df000017 	ldw	fp,0(sp)
811063e4:	dec00204 	addi	sp,sp,8
811063e8:	f800283a 	ret

811063ec <bFeebGetBuffersStatus>:

bool bFeebGetBuffersStatus(TFeebChannel *pxFeebCh) {
811063ec:	defffb04 	addi	sp,sp,-20
811063f0:	de00012e 	bgeu	sp,et,811063f8 <bFeebGetBuffersStatus+0xc>
811063f4:	003b68fa 	trap	3
811063f8:	dfc00415 	stw	ra,16(sp)
811063fc:	df000315 	stw	fp,12(sp)
81106400:	df000304 	addi	fp,sp,12
81106404:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106408:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110640c:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106410:	e0bfff17 	ldw	r2,-4(fp)
81106414:	10003226 	beq	r2,zero,811064e0 <bFeebGetBuffersStatus+0xf4>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106418:	e0bfff17 	ldw	r2,-4(fp)
8110641c:	10800017 	ldw	r2,0(r2)
81106420:	014000c4 	movi	r5,3
81106424:	1009883a 	mov	r4,r2
81106428:	1106d080 	call	81106d08 <uliFeebReadReg>
8110642c:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
81106430:	e0bffe17 	ldw	r2,-8(fp)
81106434:	1080008c 	andi	r2,r2,2
81106438:	10000426 	beq	r2,zero,8110644c <bFeebGetBuffersStatus+0x60>
			pxFeebCh->xBufferStatus.bLeftBufferEmpty = TRUE;
8110643c:	e0bfff17 	ldw	r2,-4(fp)
81106440:	00c00044 	movi	r3,1
81106444:	10c00515 	stw	r3,20(r2)
81106448:	00000206 	br	81106454 <bFeebGetBuffersStatus+0x68>
		} else {
			pxFeebCh->xBufferStatus.bLeftBufferEmpty = FALSE;
8110644c:	e0bfff17 	ldw	r2,-4(fp)
81106450:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
81106454:	e0bffe17 	ldw	r2,-8(fp)
81106458:	1080004c 	andi	r2,r2,1
8110645c:	10000426 	beq	r2,zero,81106470 <bFeebGetBuffersStatus+0x84>
			pxFeebCh->xBufferStatus.bRightBufferEmpty = TRUE;
81106460:	e0bfff17 	ldw	r2,-4(fp)
81106464:	00c00044 	movi	r3,1
81106468:	10c00615 	stw	r3,24(r2)
8110646c:	00000206 	br	81106478 <bFeebGetBuffersStatus+0x8c>
		} else {
			pxFeebCh->xBufferStatus.bRightBufferEmpty = FALSE;
81106470:	e0bfff17 	ldw	r2,-4(fp)
81106474:	10000615 	stw	zero,24(r2)
		}

		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106478:	e0bfff17 	ldw	r2,-4(fp)
8110647c:	10800017 	ldw	r2,0(r2)
81106480:	01400504 	movi	r5,20
81106484:	1009883a 	mov	r4,r2
81106488:	1106d080 	call	81106d08 <uliFeebReadReg>
8110648c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RIGT_FEEBUFF_SIZE_REG_OFST);
		pxFeebCh->xBufferStatus.ucRightBufferSize = (alt_u8) (uliReg
81106490:	e0bffe17 	ldw	r2,-8(fp)
81106494:	108003cc 	andi	r2,r2,15
81106498:	10800044 	addi	r2,r2,1
8110649c:	1007883a 	mov	r3,r2
811064a0:	e0bfff17 	ldw	r2,-4(fp)
811064a4:	10c00745 	stb	r3,29(r2)
				& COMM_RIGT_FEEBUFF_SIZE_MSK) + 1;

		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811064a8:	e0bfff17 	ldw	r2,-4(fp)
811064ac:	10800017 	ldw	r2,0(r2)
811064b0:	01400544 	movi	r5,21
811064b4:	1009883a 	mov	r4,r2
811064b8:	1106d080 	call	81106d08 <uliFeebReadReg>
811064bc:	e0bffe15 	stw	r2,-8(fp)
		COMM_LEFT_FEEBUFF_SIZE_REG_OFST);
		pxFeebCh->xBufferStatus.ucRightBufferSize = (alt_u8) (uliReg
811064c0:	e0bffe17 	ldw	r2,-8(fp)
811064c4:	108003cc 	andi	r2,r2,15
811064c8:	10800044 	addi	r2,r2,1
811064cc:	1007883a 	mov	r3,r2
811064d0:	e0bfff17 	ldw	r2,-4(fp)
811064d4:	10c00745 	stb	r3,29(r2)
				& COMM_LEFT_FEEBUFF_SIZE_MSK) + 1;

		bStatus = TRUE;
811064d8:	00800044 	movi	r2,1
811064dc:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811064e0:	e0bffd17 	ldw	r2,-12(fp)
}
811064e4:	e037883a 	mov	sp,fp
811064e8:	dfc00117 	ldw	ra,4(sp)
811064ec:	df000017 	ldw	fp,0(sp)
811064f0:	dec00204 	addi	sp,sp,8
811064f4:	f800283a 	ret

811064f8 <bFeebGetLeftBufferEmpty>:

bool bFeebGetLeftBufferEmpty(TFeebChannel *pxFeebCh){
811064f8:	defffb04 	addi	sp,sp,-20
811064fc:	de00012e 	bgeu	sp,et,81106504 <bFeebGetLeftBufferEmpty+0xc>
81106500:	003b68fa 	trap	3
81106504:	dfc00415 	stw	ra,16(sp)
81106508:	df000315 	stw	fp,12(sp)
8110650c:	df000304 	addi	fp,sp,12
81106510:	e13fff15 	stw	r4,-4(fp)
	bool bFlag = FALSE;
81106514:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106518:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
8110651c:	e0bfff17 	ldw	r2,-4(fp)
81106520:	10000d26 	beq	r2,zero,81106558 <bFeebGetLeftBufferEmpty+0x60>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106524:	e0bfff17 	ldw	r2,-4(fp)
81106528:	10800017 	ldw	r2,0(r2)
8110652c:	014000c4 	movi	r5,3
81106530:	1009883a 	mov	r4,r2
81106534:	1106d080 	call	81106d08 <uliFeebReadReg>
81106538:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
8110653c:	e0bffe17 	ldw	r2,-8(fp)
81106540:	1080008c 	andi	r2,r2,2
81106544:	10000326 	beq	r2,zero,81106554 <bFeebGetLeftBufferEmpty+0x5c>
			bFlag = TRUE;
81106548:	00800044 	movi	r2,1
8110654c:	e0bffd15 	stw	r2,-12(fp)
81106550:	00000106 	br	81106558 <bFeebGetLeftBufferEmpty+0x60>
		} else {
			bFlag = FALSE;
81106554:	e03ffd15 	stw	zero,-12(fp)
		}

	}

	return bFlag;
81106558:	e0bffd17 	ldw	r2,-12(fp)
}
8110655c:	e037883a 	mov	sp,fp
81106560:	dfc00117 	ldw	ra,4(sp)
81106564:	df000017 	ldw	fp,0(sp)
81106568:	dec00204 	addi	sp,sp,8
8110656c:	f800283a 	ret

81106570 <bFeebGetRightBufferEmpty>:

bool bFeebGetRightBufferEmpty(TFeebChannel *pxFeebCh){
81106570:	defffb04 	addi	sp,sp,-20
81106574:	de00012e 	bgeu	sp,et,8110657c <bFeebGetRightBufferEmpty+0xc>
81106578:	003b68fa 	trap	3
8110657c:	dfc00415 	stw	ra,16(sp)
81106580:	df000315 	stw	fp,12(sp)
81106584:	df000304 	addi	fp,sp,12
81106588:	e13fff15 	stw	r4,-4(fp)
	bool bFlag = FALSE;
8110658c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106590:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106594:	e0bfff17 	ldw	r2,-4(fp)
81106598:	10000d26 	beq	r2,zero,811065d0 <bFeebGetRightBufferEmpty+0x60>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
8110659c:	e0bfff17 	ldw	r2,-4(fp)
811065a0:	10800017 	ldw	r2,0(r2)
811065a4:	014000c4 	movi	r5,3
811065a8:	1009883a 	mov	r4,r2
811065ac:	1106d080 	call	81106d08 <uliFeebReadReg>
811065b0:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
811065b4:	e0bffe17 	ldw	r2,-8(fp)
811065b8:	1080004c 	andi	r2,r2,1
811065bc:	10000326 	beq	r2,zero,811065cc <bFeebGetRightBufferEmpty+0x5c>
			bFlag = TRUE;
811065c0:	00800044 	movi	r2,1
811065c4:	e0bffd15 	stw	r2,-12(fp)
811065c8:	00000106 	br	811065d0 <bFeebGetRightBufferEmpty+0x60>
		} else {
			bFlag = FALSE;
811065cc:	e03ffd15 	stw	zero,-12(fp)
		}

	}

	return bFlag;
811065d0:	e0bffd17 	ldw	r2,-12(fp)
}
811065d4:	e037883a 	mov	sp,fp
811065d8:	dfc00117 	ldw	ra,4(sp)
811065dc:	df000017 	ldw	fp,0(sp)
811065e0:	dec00204 	addi	sp,sp,8
811065e4:	f800283a 	ret

811065e8 <bFeebGetCh1LeftBufferEmpty>:

bool bFeebGetCh1LeftBufferEmpty(void){
811065e8:	defffc04 	addi	sp,sp,-16
811065ec:	de00012e 	bgeu	sp,et,811065f4 <bFeebGetCh1LeftBufferEmpty+0xc>
811065f0:	003b68fa 	trap	3
811065f4:	dfc00315 	stw	ra,12(sp)
811065f8:	df000215 	stw	fp,8(sp)
811065fc:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
81106600:	e03ffe15 	stw	zero,-8(fp)
	alt_u32 uliReg = 0;
81106604:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_1_BASE_ADDR,
81106608:	014000c4 	movi	r5,3
8110660c:	01204834 	movhi	r4,33056
81106610:	210b0004 	addi	r4,r4,11264
81106614:	1106d080 	call	81106d08 <uliFeebReadReg>
81106618:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
8110661c:	e0bfff17 	ldw	r2,-4(fp)
81106620:	1080008c 	andi	r2,r2,2
81106624:	10000326 	beq	r2,zero,81106634 <bFeebGetCh1LeftBufferEmpty+0x4c>
			bFlag = TRUE;
81106628:	00800044 	movi	r2,1
8110662c:	e0bffe15 	stw	r2,-8(fp)
81106630:	00000106 	br	81106638 <bFeebGetCh1LeftBufferEmpty+0x50>
		} else {
			bFlag = FALSE;
81106634:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
81106638:	e0bffe17 	ldw	r2,-8(fp)
}
8110663c:	e037883a 	mov	sp,fp
81106640:	dfc00117 	ldw	ra,4(sp)
81106644:	df000017 	ldw	fp,0(sp)
81106648:	dec00204 	addi	sp,sp,8
8110664c:	f800283a 	ret

81106650 <bFeebGetCh1RightBufferEmpty>:

bool bFeebGetCh1RightBufferEmpty(void){
81106650:	defffc04 	addi	sp,sp,-16
81106654:	de00012e 	bgeu	sp,et,8110665c <bFeebGetCh1RightBufferEmpty+0xc>
81106658:	003b68fa 	trap	3
8110665c:	dfc00315 	stw	ra,12(sp)
81106660:	df000215 	stw	fp,8(sp)
81106664:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
81106668:	e03ffe15 	stw	zero,-8(fp)
	alt_u32 uliReg = 0;
8110666c:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_1_BASE_ADDR,
81106670:	014000c4 	movi	r5,3
81106674:	01204834 	movhi	r4,33056
81106678:	210b0004 	addi	r4,r4,11264
8110667c:	1106d080 	call	81106d08 <uliFeebReadReg>
81106680:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
81106684:	e0bfff17 	ldw	r2,-4(fp)
81106688:	1080004c 	andi	r2,r2,1
8110668c:	10000326 	beq	r2,zero,8110669c <bFeebGetCh1RightBufferEmpty+0x4c>
			bFlag = TRUE;
81106690:	00800044 	movi	r2,1
81106694:	e0bffe15 	stw	r2,-8(fp)
81106698:	00000106 	br	811066a0 <bFeebGetCh1RightBufferEmpty+0x50>
		} else {
			bFlag = FALSE;
8110669c:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
811066a0:	e0bffe17 	ldw	r2,-8(fp)
}
811066a4:	e037883a 	mov	sp,fp
811066a8:	dfc00117 	ldw	ra,4(sp)
811066ac:	df000017 	ldw	fp,0(sp)
811066b0:	dec00204 	addi	sp,sp,8
811066b4:	f800283a 	ret

811066b8 <bFeebGetCh2LeftBufferEmpty>:

bool bFeebGetCh2LeftBufferEmpty(void){
811066b8:	defffc04 	addi	sp,sp,-16
811066bc:	de00012e 	bgeu	sp,et,811066c4 <bFeebGetCh2LeftBufferEmpty+0xc>
811066c0:	003b68fa 	trap	3
811066c4:	dfc00315 	stw	ra,12(sp)
811066c8:	df000215 	stw	fp,8(sp)
811066cc:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
811066d0:	e03ffe15 	stw	zero,-8(fp)
	alt_u32 uliReg = 0;
811066d4:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_2_BASE_ADDR,
811066d8:	014000c4 	movi	r5,3
811066dc:	01204834 	movhi	r4,33056
811066e0:	210a0004 	addi	r4,r4,10240
811066e4:	1106d080 	call	81106d08 <uliFeebReadReg>
811066e8:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
811066ec:	e0bfff17 	ldw	r2,-4(fp)
811066f0:	1080008c 	andi	r2,r2,2
811066f4:	10000326 	beq	r2,zero,81106704 <bFeebGetCh2LeftBufferEmpty+0x4c>
			bFlag = TRUE;
811066f8:	00800044 	movi	r2,1
811066fc:	e0bffe15 	stw	r2,-8(fp)
81106700:	00000106 	br	81106708 <bFeebGetCh2LeftBufferEmpty+0x50>
		} else {
			bFlag = FALSE;
81106704:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
81106708:	e0bffe17 	ldw	r2,-8(fp)
}
8110670c:	e037883a 	mov	sp,fp
81106710:	dfc00117 	ldw	ra,4(sp)
81106714:	df000017 	ldw	fp,0(sp)
81106718:	dec00204 	addi	sp,sp,8
8110671c:	f800283a 	ret

81106720 <bFeebGetCh2RightBufferEmpty>:

bool bFeebGetCh2RightBufferEmpty(void){
81106720:	defffc04 	addi	sp,sp,-16
81106724:	de00012e 	bgeu	sp,et,8110672c <bFeebGetCh2RightBufferEmpty+0xc>
81106728:	003b68fa 	trap	3
8110672c:	dfc00315 	stw	ra,12(sp)
81106730:	df000215 	stw	fp,8(sp)
81106734:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
81106738:	e03ffe15 	stw	zero,-8(fp)
	alt_u32 uliReg = 0;
8110673c:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_2_BASE_ADDR,
81106740:	014000c4 	movi	r5,3
81106744:	01204834 	movhi	r4,33056
81106748:	210a0004 	addi	r4,r4,10240
8110674c:	1106d080 	call	81106d08 <uliFeebReadReg>
81106750:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
81106754:	e0bfff17 	ldw	r2,-4(fp)
81106758:	1080004c 	andi	r2,r2,1
8110675c:	10000326 	beq	r2,zero,8110676c <bFeebGetCh2RightBufferEmpty+0x4c>
			bFlag = TRUE;
81106760:	00800044 	movi	r2,1
81106764:	e0bffe15 	stw	r2,-8(fp)
81106768:	00000106 	br	81106770 <bFeebGetCh2RightBufferEmpty+0x50>
		} else {
			bFlag = FALSE;
8110676c:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
81106770:	e0bffe17 	ldw	r2,-8(fp)
}
81106774:	e037883a 	mov	sp,fp
81106778:	dfc00117 	ldw	ra,4(sp)
8110677c:	df000017 	ldw	fp,0(sp)
81106780:	dec00204 	addi	sp,sp,8
81106784:	f800283a 	ret

81106788 <bFeebSetBufferSize>:

bool bFeebSetBufferSize(TFeebChannel *pxFeebCh, alt_u8 ucBufferSizeInBlocks,
		alt_u8 ucBufferSide) {
81106788:	defff904 	addi	sp,sp,-28
8110678c:	de00012e 	bgeu	sp,et,81106794 <bFeebSetBufferSize+0xc>
81106790:	003b68fa 	trap	3
81106794:	dfc00615 	stw	ra,24(sp)
81106798:	df000515 	stw	fp,20(sp)
8110679c:	df000504 	addi	fp,sp,20
811067a0:	e13ffd15 	stw	r4,-12(fp)
811067a4:	2807883a 	mov	r3,r5
811067a8:	3005883a 	mov	r2,r6
811067ac:	e0fffe05 	stb	r3,-8(fp)
811067b0:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
811067b4:	00800044 	movi	r2,1
811067b8:	e0bffb15 	stw	r2,-20(fp)
	alt_u32 uliReg = 0;
811067bc:	e03ffc15 	stw	zero,-16(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
811067c0:	e0bffe03 	ldbu	r2,-8(fp)
811067c4:	10002126 	beq	r2,zero,8110684c <bFeebSetBufferSize+0xc4>
811067c8:	e0bffe03 	ldbu	r2,-8(fp)
811067cc:	10800468 	cmpgeui	r2,r2,17
811067d0:	10001e1e 	bne	r2,zero,8110684c <bFeebSetBufferSize+0xc4>
		switch (ucBufferSide) {
811067d4:	e0bfff03 	ldbu	r2,-4(fp)
811067d8:	10000326 	beq	r2,zero,811067e8 <bFeebSetBufferSize+0x60>
811067dc:	10800060 	cmpeqi	r2,r2,1
811067e0:	10000c1e 	bne	r2,zero,81106814 <bFeebSetBufferSize+0x8c>
811067e4:	00001606 	br	81106840 <bFeebSetBufferSize+0xb8>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
811067e8:	e0bffe03 	ldbu	r2,-8(fp)
811067ec:	10bfffc4 	addi	r2,r2,-1
811067f0:	108003cc 	andi	r2,r2,15
811067f4:	e0bffc15 	stw	r2,-16(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg(pxFeebCh->puliFeebChAddr,
811067f8:	e0bffd17 	ldw	r2,-12(fp)
811067fc:	10800017 	ldw	r2,0(r2)
81106800:	e1bffc17 	ldw	r6,-16(fp)
81106804:	01400544 	movi	r5,21
81106808:	1009883a 	mov	r4,r2
8110680c:	1106cb40 	call	81106cb4 <vFeebWriteReg>
					COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81106810:	00000d06 	br	81106848 <bFeebSetBufferSize+0xc0>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81106814:	e0bffe03 	ldbu	r2,-8(fp)
81106818:	10bfffc4 	addi	r2,r2,-1
8110681c:	108003cc 	andi	r2,r2,15
81106820:	e0bffc15 	stw	r2,-16(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg(pxFeebCh->puliFeebChAddr,
81106824:	e0bffd17 	ldw	r2,-12(fp)
81106828:	10800017 	ldw	r2,0(r2)
8110682c:	e1bffc17 	ldw	r6,-16(fp)
81106830:	01400504 	movi	r5,20
81106834:	1009883a 	mov	r4,r2
81106838:	1106cb40 	call	81106cb4 <vFeebWriteReg>
					COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
8110683c:	00000206 	br	81106848 <bFeebSetBufferSize+0xc0>
		default:
			bStatus = FALSE;
81106840:	e03ffb15 	stw	zero,-20(fp)
			break;
81106844:	0001883a 	nop
		}
	} else {
81106848:	00000106 	br	81106850 <bFeebSetBufferSize+0xc8>
		bStatus = FALSE;
8110684c:	e03ffb15 	stw	zero,-20(fp)
	}

	return bStatus;
81106850:	e0bffb17 	ldw	r2,-20(fp)
}
81106854:	e037883a 	mov	sp,fp
81106858:	dfc00117 	ldw	ra,4(sp)
8110685c:	df000017 	ldw	fp,0(sp)
81106860:	dec00204 	addi	sp,sp,8
81106864:	f800283a 	ret

81106868 <bFeebSetWindowing>:

bool bFeebSetWindowing(TFeebChannel *pxFeebCh) {
81106868:	defffb04 	addi	sp,sp,-20
8110686c:	de00012e 	bgeu	sp,et,81106874 <bFeebSetWindowing+0xc>
81106870:	003b68fa 	trap	3
81106874:	dfc00415 	stw	ra,16(sp)
81106878:	df000315 	stw	fp,12(sp)
8110687c:	df000304 	addi	fp,sp,12
81106880:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106884:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106888:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
8110688c:	e0bfff17 	ldw	r2,-4(fp)
81106890:	10001926 	beq	r2,zero,811068f8 <bFeebSetWindowing+0x90>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106894:	e0bfff17 	ldw	r2,-4(fp)
81106898:	10800017 	ldw	r2,0(r2)
8110689c:	01400084 	movi	r5,2
811068a0:	1009883a 	mov	r4,r2
811068a4:	1106d080 	call	81106d08 <uliFeebReadReg>
811068a8:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		if (pxFeebCh->xWindowingConfig.bMasking) {
811068ac:	e0bfff17 	ldw	r2,-4(fp)
811068b0:	10800117 	ldw	r2,4(r2)
811068b4:	10000426 	beq	r2,zero,811068c8 <bFeebSetWindowing+0x60>
			uliReg |= COMM_FEE_MASKING_EN_MSK;
811068b8:	e0bffe17 	ldw	r2,-8(fp)
811068bc:	10800214 	ori	r2,r2,8
811068c0:	e0bffe15 	stw	r2,-8(fp)
811068c4:	00000406 	br	811068d8 <bFeebSetWindowing+0x70>
		} else {
			uliReg &= (~COMM_FEE_MASKING_EN_MSK);
811068c8:	e0fffe17 	ldw	r3,-8(fp)
811068cc:	00bffdc4 	movi	r2,-9
811068d0:	1884703a 	and	r2,r3,r2
811068d4:	e0bffe15 	stw	r2,-8(fp)
		}

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
811068d8:	e0bfff17 	ldw	r2,-4(fp)
811068dc:	10800017 	ldw	r2,0(r2)
811068e0:	e1bffe17 	ldw	r6,-8(fp)
811068e4:	01400084 	movi	r5,2
811068e8:	1009883a 	mov	r4,r2
811068ec:	1106cb40 	call	81106cb4 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
811068f0:	00800044 	movi	r2,1
811068f4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811068f8:	e0bffd17 	ldw	r2,-12(fp)
}
811068fc:	e037883a 	mov	sp,fp
81106900:	dfc00117 	ldw	ra,4(sp)
81106904:	df000017 	ldw	fp,0(sp)
81106908:	dec00204 	addi	sp,sp,8
8110690c:	f800283a 	ret

81106910 <bFeebGetWindowing>:

bool bFeebGetWindowing(TFeebChannel *pxFeebCh) {
81106910:	defffb04 	addi	sp,sp,-20
81106914:	de00012e 	bgeu	sp,et,8110691c <bFeebGetWindowing+0xc>
81106918:	003b68fa 	trap	3
8110691c:	dfc00415 	stw	ra,16(sp)
81106920:	df000315 	stw	fp,12(sp)
81106924:	df000304 	addi	fp,sp,12
81106928:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110692c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106930:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106934:	e0bfff17 	ldw	r2,-4(fp)
81106938:	10001126 	beq	r2,zero,81106980 <bFeebGetWindowing+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
8110693c:	e0bfff17 	ldw	r2,-4(fp)
81106940:	10800017 	ldw	r2,0(r2)
81106944:	01400084 	movi	r5,2
81106948:	1009883a 	mov	r4,r2
8110694c:	1106d080 	call	81106d08 <uliFeebReadReg>
81106950:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		if (uliReg & COMM_FEE_MASKING_EN_MSK) {
81106954:	e0bffe17 	ldw	r2,-8(fp)
81106958:	1080020c 	andi	r2,r2,8
8110695c:	10000426 	beq	r2,zero,81106970 <bFeebGetWindowing+0x60>
			pxFeebCh->xWindowingConfig.bMasking = TRUE;
81106960:	e0bfff17 	ldw	r2,-4(fp)
81106964:	00c00044 	movi	r3,1
81106968:	10c00115 	stw	r3,4(r2)
8110696c:	00000206 	br	81106978 <bFeebGetWindowing+0x68>
		} else {
			pxFeebCh->xWindowingConfig.bMasking = FALSE;
81106970:	e0bfff17 	ldw	r2,-4(fp)
81106974:	10000115 	stw	zero,4(r2)
		}

		bStatus = TRUE;
81106978:	00800044 	movi	r2,1
8110697c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106980:	e0bffd17 	ldw	r2,-12(fp)
}
81106984:	e037883a 	mov	sp,fp
81106988:	dfc00117 	ldw	ra,4(sp)
8110698c:	df000017 	ldw	fp,0(sp)
81106990:	dec00204 	addi	sp,sp,8
81106994:	f800283a 	ret

81106998 <bFeebStartCh>:

bool bFeebStartCh(TFeebChannel *pxFeebCh) {
81106998:	defffb04 	addi	sp,sp,-20
8110699c:	de00012e 	bgeu	sp,et,811069a4 <bFeebStartCh+0xc>
811069a0:	003b68fa 	trap	3
811069a4:	dfc00415 	stw	ra,16(sp)
811069a8:	df000315 	stw	fp,12(sp)
811069ac:	df000304 	addi	fp,sp,12
811069b0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811069b4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811069b8:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811069bc:	e0bfff17 	ldw	r2,-4(fp)
811069c0:	10001126 	beq	r2,zero,81106a08 <bFeebStartCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811069c4:	e0bfff17 	ldw	r2,-4(fp)
811069c8:	10800017 	ldw	r2,0(r2)
811069cc:	01400084 	movi	r5,2
811069d0:	1009883a 	mov	r4,r2
811069d4:	1106d080 	call	81106d08 <uliFeebReadReg>
811069d8:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_START_MSK;
811069dc:	e0bffe17 	ldw	r2,-8(fp)
811069e0:	10800114 	ori	r2,r2,4
811069e4:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
811069e8:	e0bfff17 	ldw	r2,-4(fp)
811069ec:	10800017 	ldw	r2,0(r2)
811069f0:	e1bffe17 	ldw	r6,-8(fp)
811069f4:	01400084 	movi	r5,2
811069f8:	1009883a 	mov	r4,r2
811069fc:	1106cb40 	call	81106cb4 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81106a00:	00800044 	movi	r2,1
81106a04:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106a08:	e0bffd17 	ldw	r2,-12(fp)
}
81106a0c:	e037883a 	mov	sp,fp
81106a10:	dfc00117 	ldw	ra,4(sp)
81106a14:	df000017 	ldw	fp,0(sp)
81106a18:	dec00204 	addi	sp,sp,8
81106a1c:	f800283a 	ret

81106a20 <bFeebStopCh>:

bool bFeebStopCh(TFeebChannel *pxFeebCh) {
81106a20:	defffb04 	addi	sp,sp,-20
81106a24:	de00012e 	bgeu	sp,et,81106a2c <bFeebStopCh+0xc>
81106a28:	003b68fa 	trap	3
81106a2c:	dfc00415 	stw	ra,16(sp)
81106a30:	df000315 	stw	fp,12(sp)
81106a34:	df000304 	addi	fp,sp,12
81106a38:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106a3c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106a40:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106a44:	e0bfff17 	ldw	r2,-4(fp)
81106a48:	10001126 	beq	r2,zero,81106a90 <bFeebStopCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106a4c:	e0bfff17 	ldw	r2,-4(fp)
81106a50:	10800017 	ldw	r2,0(r2)
81106a54:	01400084 	movi	r5,2
81106a58:	1009883a 	mov	r4,r2
81106a5c:	1106d080 	call	81106d08 <uliFeebReadReg>
81106a60:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_STOP_MSK;
81106a64:	e0bffe17 	ldw	r2,-8(fp)
81106a68:	10800094 	ori	r2,r2,2
81106a6c:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81106a70:	e0bfff17 	ldw	r2,-4(fp)
81106a74:	10800017 	ldw	r2,0(r2)
81106a78:	e1bffe17 	ldw	r6,-8(fp)
81106a7c:	01400084 	movi	r5,2
81106a80:	1009883a 	mov	r4,r2
81106a84:	1106cb40 	call	81106cb4 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81106a88:	00800044 	movi	r2,1
81106a8c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106a90:	e0bffd17 	ldw	r2,-12(fp)
}
81106a94:	e037883a 	mov	sp,fp
81106a98:	dfc00117 	ldw	ra,4(sp)
81106a9c:	df000017 	ldw	fp,0(sp)
81106aa0:	dec00204 	addi	sp,sp,8
81106aa4:	f800283a 	ret

81106aa8 <bFeebClrCh>:

bool bFeebClrCh(TFeebChannel *pxFeebCh) {
81106aa8:	defffb04 	addi	sp,sp,-20
81106aac:	de00012e 	bgeu	sp,et,81106ab4 <bFeebClrCh+0xc>
81106ab0:	003b68fa 	trap	3
81106ab4:	dfc00415 	stw	ra,16(sp)
81106ab8:	df000315 	stw	fp,12(sp)
81106abc:	df000304 	addi	fp,sp,12
81106ac0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106ac4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106ac8:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106acc:	e0bfff17 	ldw	r2,-4(fp)
81106ad0:	10001126 	beq	r2,zero,81106b18 <bFeebClrCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106ad4:	e0bfff17 	ldw	r2,-4(fp)
81106ad8:	10800017 	ldw	r2,0(r2)
81106adc:	01400084 	movi	r5,2
81106ae0:	1009883a 	mov	r4,r2
81106ae4:	1106d080 	call	81106d08 <uliFeebReadReg>
81106ae8:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_CLR_MSK;
81106aec:	e0bffe17 	ldw	r2,-8(fp)
81106af0:	10800054 	ori	r2,r2,1
81106af4:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81106af8:	e0bfff17 	ldw	r2,-4(fp)
81106afc:	10800017 	ldw	r2,0(r2)
81106b00:	e1bffe17 	ldw	r6,-8(fp)
81106b04:	01400084 	movi	r5,2
81106b08:	1009883a 	mov	r4,r2
81106b0c:	1106cb40 	call	81106cb4 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81106b10:	00800044 	movi	r2,1
81106b14:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106b18:	e0bffd17 	ldw	r2,-12(fp)
}
81106b1c:	e037883a 	mov	sp,fp
81106b20:	dfc00117 	ldw	ra,4(sp)
81106b24:	df000017 	ldw	fp,0(sp)
81106b28:	dec00204 	addi	sp,sp,8
81106b2c:	f800283a 	ret

81106b30 <bFeebInitCh>:

bool bFeebInitCh(TFeebChannel *pxFeebCh, alt_u8 ucCommCh) {
81106b30:	defffb04 	addi	sp,sp,-20
81106b34:	de00012e 	bgeu	sp,et,81106b3c <bFeebInitCh+0xc>
81106b38:	003b68fa 	trap	3
81106b3c:	dfc00415 	stw	ra,16(sp)
81106b40:	df000315 	stw	fp,12(sp)
81106b44:	df000304 	addi	fp,sp,12
81106b48:	e13ffe15 	stw	r4,-8(fp)
81106b4c:	2805883a 	mov	r2,r5
81106b50:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81106b54:	e03ffd15 	stw	zero,-12(fp)

	if (pxFeebCh != NULL) {
81106b58:	e0bffe17 	ldw	r2,-8(fp)
81106b5c:	10004f26 	beq	r2,zero,81106c9c <bFeebInitCh+0x16c>
		bStatus = TRUE;
81106b60:	00800044 	movi	r2,1
81106b64:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81106b68:	e0bfff03 	ldbu	r2,-4(fp)
81106b6c:	10c00228 	cmpgeui	r3,r2,8
81106b70:	1800361e 	bne	r3,zero,81106c4c <bFeebInitCh+0x11c>
81106b74:	100690ba 	slli	r3,r2,2
81106b78:	00a04434 	movhi	r2,33040
81106b7c:	109ae304 	addi	r2,r2,27532
81106b80:	1885883a 	add	r2,r3,r2
81106b84:	10800017 	ldw	r2,0(r2)
81106b88:	1000683a 	jmp	r2
81106b8c:	81106bac 	andhi	r4,r16,16814
81106b90:	81106bc0 	call	881106bc <__reset+0x20f06bc>
81106b94:	81106bd4 	ori	r4,r16,16815
81106b98:	81106be8 	cmpgeui	r4,r16,16815
81106b9c:	81106bfc 	xorhi	r4,r16,16815
81106ba0:	81106c10 	cmplti	r4,r16,16816
81106ba4:	81106c24 	muli	r4,r16,16816
81106ba8:	81106c38 	rdprs	r4,r16,16816
		case eCommSpwCh1:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81106bac:	e0fffe17 	ldw	r3,-8(fp)
81106bb0:	00a04834 	movhi	r2,33056
81106bb4:	108b0004 	addi	r2,r2,11264
81106bb8:	18800015 	stw	r2,0(r3)
			break;
81106bbc:	00002506 	br	81106c54 <bFeebInitCh+0x124>
		case eCommSpwCh2:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81106bc0:	e0fffe17 	ldw	r3,-8(fp)
81106bc4:	00a04834 	movhi	r2,33056
81106bc8:	108a0004 	addi	r2,r2,10240
81106bcc:	18800015 	stw	r2,0(r3)
			break;
81106bd0:	00002006 	br	81106c54 <bFeebInitCh+0x124>
		case eCommSpwCh3:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81106bd4:	e0fffe17 	ldw	r3,-8(fp)
81106bd8:	00a04834 	movhi	r2,33056
81106bdc:	108b0004 	addi	r2,r2,11264
81106be0:	18800015 	stw	r2,0(r3)
			break;
81106be4:	00001b06 	br	81106c54 <bFeebInitCh+0x124>
		case eCommSpwCh4:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81106be8:	e0fffe17 	ldw	r3,-8(fp)
81106bec:	00a04834 	movhi	r2,33056
81106bf0:	108a0004 	addi	r2,r2,10240
81106bf4:	18800015 	stw	r2,0(r3)
			break;
81106bf8:	00001606 	br	81106c54 <bFeebInitCh+0x124>
		case eCommSpwCh5:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81106bfc:	e0fffe17 	ldw	r3,-8(fp)
81106c00:	00a04834 	movhi	r2,33056
81106c04:	108b0004 	addi	r2,r2,11264
81106c08:	18800015 	stw	r2,0(r3)
			break;
81106c0c:	00001106 	br	81106c54 <bFeebInitCh+0x124>
		case eCommSpwCh6:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81106c10:	e0fffe17 	ldw	r3,-8(fp)
81106c14:	00a04834 	movhi	r2,33056
81106c18:	108a0004 	addi	r2,r2,10240
81106c1c:	18800015 	stw	r2,0(r3)
			break;
81106c20:	00000c06 	br	81106c54 <bFeebInitCh+0x124>
		case eCommSpwCh7:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81106c24:	e0fffe17 	ldw	r3,-8(fp)
81106c28:	00a04834 	movhi	r2,33056
81106c2c:	108b0004 	addi	r2,r2,11264
81106c30:	18800015 	stw	r2,0(r3)
			break;
81106c34:	00000706 	br	81106c54 <bFeebInitCh+0x124>
		case eCommSpwCh8:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81106c38:	e0fffe17 	ldw	r3,-8(fp)
81106c3c:	00a04834 	movhi	r2,33056
81106c40:	108a0004 	addi	r2,r2,10240
81106c44:	18800015 	stw	r2,0(r3)
			break;
81106c48:	00000206 	br	81106c54 <bFeebInitCh+0x124>
		default:
			bStatus = FALSE;
81106c4c:	e03ffd15 	stw	zero,-12(fp)
			break;
81106c50:	0001883a 	nop
		}

		if (bStatus) {
81106c54:	e0bffd17 	ldw	r2,-12(fp)
81106c58:	10001026 	beq	r2,zero,81106c9c <bFeebInitCh+0x16c>
			if (!bFeebGetIrqControl(pxFeebCh)) {
81106c5c:	e13ffe17 	ldw	r4,-8(fp)
81106c60:	11062b80 	call	811062b8 <bFeebGetIrqControl>
81106c64:	1000011e 	bne	r2,zero,81106c6c <bFeebInitCh+0x13c>
				bStatus = FALSE;
81106c68:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetIrqFlags(pxFeebCh)) {
81106c6c:	e13ffe17 	ldw	r4,-8(fp)
81106c70:	11063640 	call	81106364 <bFeebGetIrqFlags>
81106c74:	1000011e 	bne	r2,zero,81106c7c <bFeebInitCh+0x14c>
				bStatus = FALSE;
81106c78:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetBuffersStatus(pxFeebCh)) {
81106c7c:	e13ffe17 	ldw	r4,-8(fp)
81106c80:	11063ec0 	call	811063ec <bFeebGetBuffersStatus>
81106c84:	1000011e 	bne	r2,zero,81106c8c <bFeebInitCh+0x15c>
				bStatus = FALSE;
81106c88:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetWindowing(pxFeebCh)) {
81106c8c:	e13ffe17 	ldw	r4,-8(fp)
81106c90:	11069100 	call	81106910 <bFeebGetWindowing>
81106c94:	1000011e 	bne	r2,zero,81106c9c <bFeebInitCh+0x16c>
				bStatus = FALSE;
81106c98:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81106c9c:	e0bffd17 	ldw	r2,-12(fp)
}
81106ca0:	e037883a 	mov	sp,fp
81106ca4:	dfc00117 	ldw	ra,4(sp)
81106ca8:	df000017 	ldw	fp,0(sp)
81106cac:	dec00204 	addi	sp,sp,8
81106cb0:	f800283a 	ret

81106cb4 <vFeebWriteReg>:

//! [public functions]

//! [private functions]
static void vFeebWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81106cb4:	defffc04 	addi	sp,sp,-16
81106cb8:	de00012e 	bgeu	sp,et,81106cc0 <vFeebWriteReg+0xc>
81106cbc:	003b68fa 	trap	3
81106cc0:	df000315 	stw	fp,12(sp)
81106cc4:	df000304 	addi	fp,sp,12
81106cc8:	e13ffd15 	stw	r4,-12(fp)
81106ccc:	e17ffe15 	stw	r5,-8(fp)
81106cd0:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81106cd4:	e0bffe17 	ldw	r2,-8(fp)
81106cd8:	1085883a 	add	r2,r2,r2
81106cdc:	1085883a 	add	r2,r2,r2
81106ce0:	1007883a 	mov	r3,r2
81106ce4:	e0bffd17 	ldw	r2,-12(fp)
81106ce8:	10c5883a 	add	r2,r2,r3
81106cec:	e0ffff17 	ldw	r3,-4(fp)
81106cf0:	10c00015 	stw	r3,0(r2)
}
81106cf4:	0001883a 	nop
81106cf8:	e037883a 	mov	sp,fp
81106cfc:	df000017 	ldw	fp,0(sp)
81106d00:	dec00104 	addi	sp,sp,4
81106d04:	f800283a 	ret

81106d08 <uliFeebReadReg>:

static alt_u32 uliFeebReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81106d08:	defffc04 	addi	sp,sp,-16
81106d0c:	de00012e 	bgeu	sp,et,81106d14 <uliFeebReadReg+0xc>
81106d10:	003b68fa 	trap	3
81106d14:	df000315 	stw	fp,12(sp)
81106d18:	df000304 	addi	fp,sp,12
81106d1c:	e13ffe15 	stw	r4,-8(fp)
81106d20:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81106d24:	e0bfff17 	ldw	r2,-4(fp)
81106d28:	1085883a 	add	r2,r2,r2
81106d2c:	1085883a 	add	r2,r2,r2
81106d30:	1007883a 	mov	r3,r2
81106d34:	e0bffe17 	ldw	r2,-8(fp)
81106d38:	10c5883a 	add	r2,r2,r3
81106d3c:	10800017 	ldw	r2,0(r2)
81106d40:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81106d44:	e0bffd17 	ldw	r2,-12(fp)
}
81106d48:	e037883a 	mov	sp,fp
81106d4c:	df000017 	ldw	fp,0(sp)
81106d50:	dec00104 	addi	sp,sp,4
81106d54:	f800283a 	ret

81106d58 <vRmapCh1HandleIrq>:
//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
/* todo:Trigger not working right */
void vRmapCh1HandleIrq(void* pvContext) {
81106d58:	defffa04 	addi	sp,sp,-24
81106d5c:	de00012e 	bgeu	sp,et,81106d64 <vRmapCh1HandleIrq+0xc>
81106d60:	003b68fa 	trap	3
81106d64:	dfc00515 	stw	ra,20(sp)
81106d68:	df000415 	stw	fp,16(sp)
81106d6c:	df000404 	addi	fp,sp,16
81106d70:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106d74:	e0bfff17 	ldw	r2,-4(fp)
81106d78:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;

	/* Warnning simplification: For now all address is lower than 1 bytes  */

#ifdef DEBUG_ON
	fprintf(fp,"IRQ RMAP.\n");
81106d7c:	d0a06217 	ldw	r2,-32376(gp)
81106d80:	100f883a 	mov	r7,r2
81106d84:	01800284 	movi	r6,10
81106d88:	01400044 	movi	r5,1
81106d8c:	01204574 	movhi	r4,33045
81106d90:	212f7f04 	addi	r4,r4,-16900
81106d94:	11216400 	call	81121640 <fwrite>
#endif

	ucADDRReg = (unsigned char)uliRmapCh1WriteCmdAddress();
81106d98:	11074bc0 	call	811074bc <uliRmapCh1WriteCmdAddress>
81106d9c:	e0bffd05 	stb	r2,-12(fp)

	uiCmdRmap.ucByte[3] = M_NFEE_BASE_ADDR + 0;
81106da0:	00800444 	movi	r2,17
81106da4:	e0bffec5 	stb	r2,-5(fp)
	uiCmdRmap.ucByte[2] = M_FEE_RMAP;
81106da8:	00bffc04 	movi	r2,-16
81106dac:	e0bffe85 	stb	r2,-6(fp)
	uiCmdRmap.ucByte[1] = ucADDRReg;
81106db0:	e0bffd03 	ldbu	r2,-12(fp)
81106db4:	e0bffe45 	stb	r2,-7(fp)
	uiCmdRmap.ucByte[0] = 0;
81106db8:	e03ffe05 	stb	zero,-8(fp)

#ifdef DEBUG_ON
	fprintf(fp,"IucADDRReg: %u\n", ucADDRReg);
81106dbc:	d0a06217 	ldw	r2,-32376(gp)
81106dc0:	e0fffd03 	ldbu	r3,-12(fp)
81106dc4:	180d883a 	mov	r6,r3
81106dc8:	01604574 	movhi	r5,33045
81106dcc:	296f8204 	addi	r5,r5,-16888
81106dd0:	1009883a 	mov	r4,r2
81106dd4:	1120fa40 	call	81120fa4 <fprintf>
#endif

	error_codel = OSQPostFront(xFeeQ[0], (void *)uiCmdRmap.ulWord);
81106dd8:	d0a06a17 	ldw	r2,-32344(gp)
81106ddc:	e0fffe17 	ldw	r3,-8(fp)
81106de0:	180b883a 	mov	r5,r3
81106de4:	1009883a 	mov	r4,r2
81106de8:	113db400 	call	8113db40 <OSQPostFront>
81106dec:	e0bffd45 	stb	r2,-11(fp)
	if ( error_codel != OS_ERR_NONE ) {
81106df0:	e0bffd43 	ldbu	r2,-11(fp)
81106df4:	10000226 	beq	r2,zero,81106e00 <vRmapCh1HandleIrq+0xa8>
		vFailSendRMAPFromIRQ( 0 );
81106df8:	0009883a 	mov	r4,zero
81106dfc:	111cf880 	call	8111cf88 <vFailSendRMAPFromIRQ>
	}

	vRmapCh1IrqFlagClrWriteCmd();
81106e00:	1106fdc0 	call	81106fdc <vRmapCh1IrqFlagClrWriteCmd>
}
81106e04:	0001883a 	nop
81106e08:	e037883a 	mov	sp,fp
81106e0c:	dfc00117 	ldw	ra,4(sp)
81106e10:	df000017 	ldw	fp,0(sp)
81106e14:	dec00204 	addi	sp,sp,8
81106e18:	f800283a 	ret

81106e1c <vRmapCh2HandleIrq>:

void vRmapCh2HandleIrq(void* pvContext) {
81106e1c:	defffc04 	addi	sp,sp,-16
81106e20:	de00012e 	bgeu	sp,et,81106e28 <vRmapCh2HandleIrq+0xc>
81106e24:	003b68fa 	trap	3
81106e28:	dfc00315 	stw	ra,12(sp)
81106e2c:	df000215 	stw	fp,8(sp)
81106e30:	df000204 	addi	fp,sp,8
81106e34:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106e38:	e0bfff17 	ldw	r2,-4(fp)
81106e3c:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh2IrqFlagClrWriteCmd();
81106e40:	11070200 	call	81107020 <vRmapCh2IrqFlagClrWriteCmd>
}
81106e44:	0001883a 	nop
81106e48:	e037883a 	mov	sp,fp
81106e4c:	dfc00117 	ldw	ra,4(sp)
81106e50:	df000017 	ldw	fp,0(sp)
81106e54:	dec00204 	addi	sp,sp,8
81106e58:	f800283a 	ret

81106e5c <vRmapCh3HandleIrq>:

void vRmapCh3HandleIrq(void* pvContext) {
81106e5c:	defffc04 	addi	sp,sp,-16
81106e60:	de00012e 	bgeu	sp,et,81106e68 <vRmapCh3HandleIrq+0xc>
81106e64:	003b68fa 	trap	3
81106e68:	dfc00315 	stw	ra,12(sp)
81106e6c:	df000215 	stw	fp,8(sp)
81106e70:	df000204 	addi	fp,sp,8
81106e74:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106e78:	e0bfff17 	ldw	r2,-4(fp)
81106e7c:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh3IrqFlagClrWriteCmd();
81106e80:	11070640 	call	81107064 <vRmapCh3IrqFlagClrWriteCmd>
}
81106e84:	0001883a 	nop
81106e88:	e037883a 	mov	sp,fp
81106e8c:	dfc00117 	ldw	ra,4(sp)
81106e90:	df000017 	ldw	fp,0(sp)
81106e94:	dec00204 	addi	sp,sp,8
81106e98:	f800283a 	ret

81106e9c <vRmapCh4HandleIrq>:

void vRmapCh4HandleIrq(void* pvContext) {
81106e9c:	defffc04 	addi	sp,sp,-16
81106ea0:	de00012e 	bgeu	sp,et,81106ea8 <vRmapCh4HandleIrq+0xc>
81106ea4:	003b68fa 	trap	3
81106ea8:	dfc00315 	stw	ra,12(sp)
81106eac:	df000215 	stw	fp,8(sp)
81106eb0:	df000204 	addi	fp,sp,8
81106eb4:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106eb8:	e0bfff17 	ldw	r2,-4(fp)
81106ebc:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh4IrqFlagClrWriteCmd();
81106ec0:	11070a80 	call	811070a8 <vRmapCh4IrqFlagClrWriteCmd>
}
81106ec4:	0001883a 	nop
81106ec8:	e037883a 	mov	sp,fp
81106ecc:	dfc00117 	ldw	ra,4(sp)
81106ed0:	df000017 	ldw	fp,0(sp)
81106ed4:	dec00204 	addi	sp,sp,8
81106ed8:	f800283a 	ret

81106edc <vRmapCh5HandleIrq>:

void vRmapCh5HandleIrq(void* pvContext) {
81106edc:	defffc04 	addi	sp,sp,-16
81106ee0:	de00012e 	bgeu	sp,et,81106ee8 <vRmapCh5HandleIrq+0xc>
81106ee4:	003b68fa 	trap	3
81106ee8:	dfc00315 	stw	ra,12(sp)
81106eec:	df000215 	stw	fp,8(sp)
81106ef0:	df000204 	addi	fp,sp,8
81106ef4:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106ef8:	e0bfff17 	ldw	r2,-4(fp)
81106efc:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh5IrqFlagClrWriteCmd();
81106f00:	11070ec0 	call	811070ec <vRmapCh5IrqFlagClrWriteCmd>
}
81106f04:	0001883a 	nop
81106f08:	e037883a 	mov	sp,fp
81106f0c:	dfc00117 	ldw	ra,4(sp)
81106f10:	df000017 	ldw	fp,0(sp)
81106f14:	dec00204 	addi	sp,sp,8
81106f18:	f800283a 	ret

81106f1c <vRmapCh6HandleIrq>:

void vRmapCh6HandleIrq(void* pvContext) {
81106f1c:	defffc04 	addi	sp,sp,-16
81106f20:	de00012e 	bgeu	sp,et,81106f28 <vRmapCh6HandleIrq+0xc>
81106f24:	003b68fa 	trap	3
81106f28:	dfc00315 	stw	ra,12(sp)
81106f2c:	df000215 	stw	fp,8(sp)
81106f30:	df000204 	addi	fp,sp,8
81106f34:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106f38:	e0bfff17 	ldw	r2,-4(fp)
81106f3c:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*hold_context_ptr = ...;
	// if (*hold_context_ptr == '0') {}...
	// App logic sequence...
	vRmapCh6IrqFlagClrWriteCmd();
81106f40:	11071300 	call	81107130 <vRmapCh6IrqFlagClrWriteCmd>
}
81106f44:	0001883a 	nop
81106f48:	e037883a 	mov	sp,fp
81106f4c:	dfc00117 	ldw	ra,4(sp)
81106f50:	df000017 	ldw	fp,0(sp)
81106f54:	dec00204 	addi	sp,sp,8
81106f58:	f800283a 	ret

81106f5c <vRmapCh7HandleIrq>:

void vRmapCh7HandleIrq(void* pvContext) {
81106f5c:	defffc04 	addi	sp,sp,-16
81106f60:	de00012e 	bgeu	sp,et,81106f68 <vRmapCh7HandleIrq+0xc>
81106f64:	003b68fa 	trap	3
81106f68:	dfc00315 	stw	ra,12(sp)
81106f6c:	df000215 	stw	fp,8(sp)
81106f70:	df000204 	addi	fp,sp,8
81106f74:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106f78:	e0bfff17 	ldw	r2,-4(fp)
81106f7c:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh7IrqFlagClrWriteCmd();
81106f80:	11071740 	call	81107174 <vRmapCh7IrqFlagClrWriteCmd>
}
81106f84:	0001883a 	nop
81106f88:	e037883a 	mov	sp,fp
81106f8c:	dfc00117 	ldw	ra,4(sp)
81106f90:	df000017 	ldw	fp,0(sp)
81106f94:	dec00204 	addi	sp,sp,8
81106f98:	f800283a 	ret

81106f9c <vRmapCh8HandleIrq>:

void vRmapCh8HandleIrq(void* pvContext) {
81106f9c:	defffc04 	addi	sp,sp,-16
81106fa0:	de00012e 	bgeu	sp,et,81106fa8 <vRmapCh8HandleIrq+0xc>
81106fa4:	003b68fa 	trap	3
81106fa8:	dfc00315 	stw	ra,12(sp)
81106fac:	df000215 	stw	fp,8(sp)
81106fb0:	df000204 	addi	fp,sp,8
81106fb4:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106fb8:	e0bfff17 	ldw	r2,-4(fp)
81106fbc:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh8IrqFlagClrWriteCmd();
81106fc0:	11071b80 	call	811071b8 <vRmapCh8IrqFlagClrWriteCmd>
}
81106fc4:	0001883a 	nop
81106fc8:	e037883a 	mov	sp,fp
81106fcc:	dfc00117 	ldw	ra,4(sp)
81106fd0:	df000017 	ldw	fp,0(sp)
81106fd4:	dec00204 	addi	sp,sp,8
81106fd8:	f800283a 	ret

81106fdc <vRmapCh1IrqFlagClrWriteCmd>:

void vRmapCh1IrqFlagClrWriteCmd(void) {
81106fdc:	defffe04 	addi	sp,sp,-8
81106fe0:	de00012e 	bgeu	sp,et,81106fe8 <vRmapCh1IrqFlagClrWriteCmd+0xc>
81106fe4:	003b68fa 	trap	3
81106fe8:	dfc00115 	stw	ra,4(sp)
81106fec:	df000015 	stw	fp,0(sp)
81106ff0:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81106ff4:	01800044 	movi	r6,1
81106ff8:	014004c4 	movi	r5,19
81106ffc:	01204834 	movhi	r4,33056
81107000:	210b0004 	addi	r4,r4,11264
81107004:	1109ea40 	call	81109ea4 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81107008:	0001883a 	nop
8110700c:	e037883a 	mov	sp,fp
81107010:	dfc00117 	ldw	ra,4(sp)
81107014:	df000017 	ldw	fp,0(sp)
81107018:	dec00204 	addi	sp,sp,8
8110701c:	f800283a 	ret

81107020 <vRmapCh2IrqFlagClrWriteCmd>:

void vRmapCh2IrqFlagClrWriteCmd(void) {
81107020:	defffe04 	addi	sp,sp,-8
81107024:	de00012e 	bgeu	sp,et,8110702c <vRmapCh2IrqFlagClrWriteCmd+0xc>
81107028:	003b68fa 	trap	3
8110702c:	dfc00115 	stw	ra,4(sp)
81107030:	df000015 	stw	fp,0(sp)
81107034:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81107038:	01800044 	movi	r6,1
8110703c:	014004c4 	movi	r5,19
81107040:	01204834 	movhi	r4,33056
81107044:	210a0004 	addi	r4,r4,10240
81107048:	1109ea40 	call	81109ea4 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
8110704c:	0001883a 	nop
81107050:	e037883a 	mov	sp,fp
81107054:	dfc00117 	ldw	ra,4(sp)
81107058:	df000017 	ldw	fp,0(sp)
8110705c:	dec00204 	addi	sp,sp,8
81107060:	f800283a 	ret

81107064 <vRmapCh3IrqFlagClrWriteCmd>:

void vRmapCh3IrqFlagClrWriteCmd(void) {
81107064:	defffe04 	addi	sp,sp,-8
81107068:	de00012e 	bgeu	sp,et,81107070 <vRmapCh3IrqFlagClrWriteCmd+0xc>
8110706c:	003b68fa 	trap	3
81107070:	dfc00115 	stw	ra,4(sp)
81107074:	df000015 	stw	fp,0(sp)
81107078:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
8110707c:	01800044 	movi	r6,1
81107080:	014004c4 	movi	r5,19
81107084:	01204834 	movhi	r4,33056
81107088:	210b0004 	addi	r4,r4,11264
8110708c:	1109ea40 	call	81109ea4 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81107090:	0001883a 	nop
81107094:	e037883a 	mov	sp,fp
81107098:	dfc00117 	ldw	ra,4(sp)
8110709c:	df000017 	ldw	fp,0(sp)
811070a0:	dec00204 	addi	sp,sp,8
811070a4:	f800283a 	ret

811070a8 <vRmapCh4IrqFlagClrWriteCmd>:

void vRmapCh4IrqFlagClrWriteCmd(void) {
811070a8:	defffe04 	addi	sp,sp,-8
811070ac:	de00012e 	bgeu	sp,et,811070b4 <vRmapCh4IrqFlagClrWriteCmd+0xc>
811070b0:	003b68fa 	trap	3
811070b4:	dfc00115 	stw	ra,4(sp)
811070b8:	df000015 	stw	fp,0(sp)
811070bc:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
811070c0:	01800044 	movi	r6,1
811070c4:	014004c4 	movi	r5,19
811070c8:	01204834 	movhi	r4,33056
811070cc:	210a0004 	addi	r4,r4,10240
811070d0:	1109ea40 	call	81109ea4 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
811070d4:	0001883a 	nop
811070d8:	e037883a 	mov	sp,fp
811070dc:	dfc00117 	ldw	ra,4(sp)
811070e0:	df000017 	ldw	fp,0(sp)
811070e4:	dec00204 	addi	sp,sp,8
811070e8:	f800283a 	ret

811070ec <vRmapCh5IrqFlagClrWriteCmd>:

void vRmapCh5IrqFlagClrWriteCmd(void) {
811070ec:	defffe04 	addi	sp,sp,-8
811070f0:	de00012e 	bgeu	sp,et,811070f8 <vRmapCh5IrqFlagClrWriteCmd+0xc>
811070f4:	003b68fa 	trap	3
811070f8:	dfc00115 	stw	ra,4(sp)
811070fc:	df000015 	stw	fp,0(sp)
81107100:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81107104:	01800044 	movi	r6,1
81107108:	014004c4 	movi	r5,19
8110710c:	01204834 	movhi	r4,33056
81107110:	210b0004 	addi	r4,r4,11264
81107114:	1109ea40 	call	81109ea4 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81107118:	0001883a 	nop
8110711c:	e037883a 	mov	sp,fp
81107120:	dfc00117 	ldw	ra,4(sp)
81107124:	df000017 	ldw	fp,0(sp)
81107128:	dec00204 	addi	sp,sp,8
8110712c:	f800283a 	ret

81107130 <vRmapCh6IrqFlagClrWriteCmd>:

void vRmapCh6IrqFlagClrWriteCmd(void) {
81107130:	defffe04 	addi	sp,sp,-8
81107134:	de00012e 	bgeu	sp,et,8110713c <vRmapCh6IrqFlagClrWriteCmd+0xc>
81107138:	003b68fa 	trap	3
8110713c:	dfc00115 	stw	ra,4(sp)
81107140:	df000015 	stw	fp,0(sp)
81107144:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81107148:	01800044 	movi	r6,1
8110714c:	014004c4 	movi	r5,19
81107150:	01204834 	movhi	r4,33056
81107154:	210a0004 	addi	r4,r4,10240
81107158:	1109ea40 	call	81109ea4 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
8110715c:	0001883a 	nop
81107160:	e037883a 	mov	sp,fp
81107164:	dfc00117 	ldw	ra,4(sp)
81107168:	df000017 	ldw	fp,0(sp)
8110716c:	dec00204 	addi	sp,sp,8
81107170:	f800283a 	ret

81107174 <vRmapCh7IrqFlagClrWriteCmd>:

void vRmapCh7IrqFlagClrWriteCmd(void) {
81107174:	defffe04 	addi	sp,sp,-8
81107178:	de00012e 	bgeu	sp,et,81107180 <vRmapCh7IrqFlagClrWriteCmd+0xc>
8110717c:	003b68fa 	trap	3
81107180:	dfc00115 	stw	ra,4(sp)
81107184:	df000015 	stw	fp,0(sp)
81107188:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
8110718c:	01800044 	movi	r6,1
81107190:	014004c4 	movi	r5,19
81107194:	01204834 	movhi	r4,33056
81107198:	210b0004 	addi	r4,r4,11264
8110719c:	1109ea40 	call	81109ea4 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
811071a0:	0001883a 	nop
811071a4:	e037883a 	mov	sp,fp
811071a8:	dfc00117 	ldw	ra,4(sp)
811071ac:	df000017 	ldw	fp,0(sp)
811071b0:	dec00204 	addi	sp,sp,8
811071b4:	f800283a 	ret

811071b8 <vRmapCh8IrqFlagClrWriteCmd>:

void vRmapCh8IrqFlagClrWriteCmd(void) {
811071b8:	defffe04 	addi	sp,sp,-8
811071bc:	de00012e 	bgeu	sp,et,811071c4 <vRmapCh8IrqFlagClrWriteCmd+0xc>
811071c0:	003b68fa 	trap	3
811071c4:	dfc00115 	stw	ra,4(sp)
811071c8:	df000015 	stw	fp,0(sp)
811071cc:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
811071d0:	01800044 	movi	r6,1
811071d4:	014004c4 	movi	r5,19
811071d8:	01204834 	movhi	r4,33056
811071dc:	210a0004 	addi	r4,r4,10240
811071e0:	1109ea40 	call	81109ea4 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
811071e4:	0001883a 	nop
811071e8:	e037883a 	mov	sp,fp
811071ec:	dfc00117 	ldw	ra,4(sp)
811071f0:	df000017 	ldw	fp,0(sp)
811071f4:	dec00204 	addi	sp,sp,8
811071f8:	f800283a 	ret

811071fc <bRmapCh1IrqFlagWriteCmd>:

bool bRmapCh1IrqFlagWriteCmd(void) {
811071fc:	defffd04 	addi	sp,sp,-12
81107200:	de00012e 	bgeu	sp,et,81107208 <bRmapCh1IrqFlagWriteCmd+0xc>
81107204:	003b68fa 	trap	3
81107208:	dfc00215 	stw	ra,8(sp)
8110720c:	df000115 	stw	fp,4(sp)
81107210:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81107214:	01400484 	movi	r5,18
81107218:	01204834 	movhi	r4,33056
8110721c:	210b0004 	addi	r4,r4,11264
81107220:	1109ef80 	call	81109ef8 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107224:	1080004c 	andi	r2,r2,1
}

bool bRmapCh1IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81107228:	10000326 	beq	r2,zero,81107238 <bRmapCh1IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
8110722c:	00800044 	movi	r2,1
81107230:	e0bfff15 	stw	r2,-4(fp)
81107234:	00000106 	br	8110723c <bRmapCh1IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81107238:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110723c:	e0bfff17 	ldw	r2,-4(fp)
}
81107240:	e037883a 	mov	sp,fp
81107244:	dfc00117 	ldw	ra,4(sp)
81107248:	df000017 	ldw	fp,0(sp)
8110724c:	dec00204 	addi	sp,sp,8
81107250:	f800283a 	ret

81107254 <bRmapCh2IrqFlagWriteCmd>:

bool bRmapCh2IrqFlagWriteCmd(void) {
81107254:	defffd04 	addi	sp,sp,-12
81107258:	de00012e 	bgeu	sp,et,81107260 <bRmapCh2IrqFlagWriteCmd+0xc>
8110725c:	003b68fa 	trap	3
81107260:	dfc00215 	stw	ra,8(sp)
81107264:	df000115 	stw	fp,4(sp)
81107268:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
8110726c:	01400484 	movi	r5,18
81107270:	01204834 	movhi	r4,33056
81107274:	210a0004 	addi	r4,r4,10240
81107278:	1109ef80 	call	81109ef8 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
8110727c:	1080004c 	andi	r2,r2,1
}

bool bRmapCh2IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81107280:	10000326 	beq	r2,zero,81107290 <bRmapCh2IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81107284:	00800044 	movi	r2,1
81107288:	e0bfff15 	stw	r2,-4(fp)
8110728c:	00000106 	br	81107294 <bRmapCh2IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81107290:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107294:	e0bfff17 	ldw	r2,-4(fp)
}
81107298:	e037883a 	mov	sp,fp
8110729c:	dfc00117 	ldw	ra,4(sp)
811072a0:	df000017 	ldw	fp,0(sp)
811072a4:	dec00204 	addi	sp,sp,8
811072a8:	f800283a 	ret

811072ac <bRmapCh3IrqFlagWriteCmd>:

bool bRmapCh3IrqFlagWriteCmd(void) {
811072ac:	defffd04 	addi	sp,sp,-12
811072b0:	de00012e 	bgeu	sp,et,811072b8 <bRmapCh3IrqFlagWriteCmd+0xc>
811072b4:	003b68fa 	trap	3
811072b8:	dfc00215 	stw	ra,8(sp)
811072bc:	df000115 	stw	fp,4(sp)
811072c0:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
811072c4:	01400484 	movi	r5,18
811072c8:	01204834 	movhi	r4,33056
811072cc:	210b0004 	addi	r4,r4,11264
811072d0:	1109ef80 	call	81109ef8 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811072d4:	1080004c 	andi	r2,r2,1
}

bool bRmapCh3IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
811072d8:	10000326 	beq	r2,zero,811072e8 <bRmapCh3IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811072dc:	00800044 	movi	r2,1
811072e0:	e0bfff15 	stw	r2,-4(fp)
811072e4:	00000106 	br	811072ec <bRmapCh3IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
811072e8:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811072ec:	e0bfff17 	ldw	r2,-4(fp)
}
811072f0:	e037883a 	mov	sp,fp
811072f4:	dfc00117 	ldw	ra,4(sp)
811072f8:	df000017 	ldw	fp,0(sp)
811072fc:	dec00204 	addi	sp,sp,8
81107300:	f800283a 	ret

81107304 <bRmapCh4IrqFlagWriteCmd>:

bool bRmapCh4IrqFlagWriteCmd(void) {
81107304:	defffd04 	addi	sp,sp,-12
81107308:	de00012e 	bgeu	sp,et,81107310 <bRmapCh4IrqFlagWriteCmd+0xc>
8110730c:	003b68fa 	trap	3
81107310:	dfc00215 	stw	ra,8(sp)
81107314:	df000115 	stw	fp,4(sp)
81107318:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
8110731c:	01400484 	movi	r5,18
81107320:	01204834 	movhi	r4,33056
81107324:	210a0004 	addi	r4,r4,10240
81107328:	1109ef80 	call	81109ef8 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
8110732c:	1080004c 	andi	r2,r2,1
}

bool bRmapCh4IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81107330:	10000326 	beq	r2,zero,81107340 <bRmapCh4IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81107334:	00800044 	movi	r2,1
81107338:	e0bfff15 	stw	r2,-4(fp)
8110733c:	00000106 	br	81107344 <bRmapCh4IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81107340:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107344:	e0bfff17 	ldw	r2,-4(fp)
}
81107348:	e037883a 	mov	sp,fp
8110734c:	dfc00117 	ldw	ra,4(sp)
81107350:	df000017 	ldw	fp,0(sp)
81107354:	dec00204 	addi	sp,sp,8
81107358:	f800283a 	ret

8110735c <bRmapCh5IrqFlagWriteCmd>:

bool bRmapCh5IrqFlagWriteCmd(void) {
8110735c:	defffd04 	addi	sp,sp,-12
81107360:	de00012e 	bgeu	sp,et,81107368 <bRmapCh5IrqFlagWriteCmd+0xc>
81107364:	003b68fa 	trap	3
81107368:	dfc00215 	stw	ra,8(sp)
8110736c:	df000115 	stw	fp,4(sp)
81107370:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81107374:	01400484 	movi	r5,18
81107378:	01204834 	movhi	r4,33056
8110737c:	210b0004 	addi	r4,r4,11264
81107380:	1109ef80 	call	81109ef8 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107384:	1080004c 	andi	r2,r2,1
}

bool bRmapCh5IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81107388:	10000326 	beq	r2,zero,81107398 <bRmapCh5IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
8110738c:	00800044 	movi	r2,1
81107390:	e0bfff15 	stw	r2,-4(fp)
81107394:	00000106 	br	8110739c <bRmapCh5IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81107398:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110739c:	e0bfff17 	ldw	r2,-4(fp)
}
811073a0:	e037883a 	mov	sp,fp
811073a4:	dfc00117 	ldw	ra,4(sp)
811073a8:	df000017 	ldw	fp,0(sp)
811073ac:	dec00204 	addi	sp,sp,8
811073b0:	f800283a 	ret

811073b4 <bRmapCh6IrqFlagWriteCmd>:

bool bRmapCh6IrqFlagWriteCmd(void) {
811073b4:	defffd04 	addi	sp,sp,-12
811073b8:	de00012e 	bgeu	sp,et,811073c0 <bRmapCh6IrqFlagWriteCmd+0xc>
811073bc:	003b68fa 	trap	3
811073c0:	dfc00215 	stw	ra,8(sp)
811073c4:	df000115 	stw	fp,4(sp)
811073c8:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811073cc:	01400484 	movi	r5,18
811073d0:	01204834 	movhi	r4,33056
811073d4:	210a0004 	addi	r4,r4,10240
811073d8:	1109ef80 	call	81109ef8 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811073dc:	1080004c 	andi	r2,r2,1
}

bool bRmapCh6IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811073e0:	10000326 	beq	r2,zero,811073f0 <bRmapCh6IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811073e4:	00800044 	movi	r2,1
811073e8:	e0bfff15 	stw	r2,-4(fp)
811073ec:	00000106 	br	811073f4 <bRmapCh6IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
811073f0:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811073f4:	e0bfff17 	ldw	r2,-4(fp)
}
811073f8:	e037883a 	mov	sp,fp
811073fc:	dfc00117 	ldw	ra,4(sp)
81107400:	df000017 	ldw	fp,0(sp)
81107404:	dec00204 	addi	sp,sp,8
81107408:	f800283a 	ret

8110740c <bRmapCh7IrqFlagWriteCmd>:

bool bRmapCh7IrqFlagWriteCmd(void) {
8110740c:	defffd04 	addi	sp,sp,-12
81107410:	de00012e 	bgeu	sp,et,81107418 <bRmapCh7IrqFlagWriteCmd+0xc>
81107414:	003b68fa 	trap	3
81107418:	dfc00215 	stw	ra,8(sp)
8110741c:	df000115 	stw	fp,4(sp)
81107420:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81107424:	01400484 	movi	r5,18
81107428:	01204834 	movhi	r4,33056
8110742c:	210b0004 	addi	r4,r4,11264
81107430:	1109ef80 	call	81109ef8 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107434:	1080004c 	andi	r2,r2,1
}

bool bRmapCh7IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81107438:	10000326 	beq	r2,zero,81107448 <bRmapCh7IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
8110743c:	00800044 	movi	r2,1
81107440:	e0bfff15 	stw	r2,-4(fp)
81107444:	00000106 	br	8110744c <bRmapCh7IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81107448:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110744c:	e0bfff17 	ldw	r2,-4(fp)
}
81107450:	e037883a 	mov	sp,fp
81107454:	dfc00117 	ldw	ra,4(sp)
81107458:	df000017 	ldw	fp,0(sp)
8110745c:	dec00204 	addi	sp,sp,8
81107460:	f800283a 	ret

81107464 <bRmapCh8IrqFlagWriteCmd>:

bool bRmapCh8IrqFlagWriteCmd(void) {
81107464:	defffd04 	addi	sp,sp,-12
81107468:	de00012e 	bgeu	sp,et,81107470 <bRmapCh8IrqFlagWriteCmd+0xc>
8110746c:	003b68fa 	trap	3
81107470:	dfc00215 	stw	ra,8(sp)
81107474:	df000115 	stw	fp,4(sp)
81107478:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
8110747c:	01400484 	movi	r5,18
81107480:	01204834 	movhi	r4,33056
81107484:	210a0004 	addi	r4,r4,10240
81107488:	1109ef80 	call	81109ef8 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
8110748c:	1080004c 	andi	r2,r2,1
}

bool bRmapCh8IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81107490:	10000326 	beq	r2,zero,811074a0 <bRmapCh8IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81107494:	00800044 	movi	r2,1
81107498:	e0bfff15 	stw	r2,-4(fp)
8110749c:	00000106 	br	811074a4 <bRmapCh8IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
811074a0:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811074a4:	e0bfff17 	ldw	r2,-4(fp)
}
811074a8:	e037883a 	mov	sp,fp
811074ac:	dfc00117 	ldw	ra,4(sp)
811074b0:	df000017 	ldw	fp,0(sp)
811074b4:	dec00204 	addi	sp,sp,8
811074b8:	f800283a 	ret

811074bc <uliRmapCh1WriteCmdAddress>:

alt_u32 uliRmapCh1WriteCmdAddress(void) {
811074bc:	defffd04 	addi	sp,sp,-12
811074c0:	de00012e 	bgeu	sp,et,811074c8 <uliRmapCh1WriteCmdAddress+0xc>
811074c4:	003b68fa 	trap	3
811074c8:	dfc00215 	stw	ra,8(sp)
811074cc:	df000115 	stw	fp,4(sp)
811074d0:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811074d4:	01400184 	movi	r5,6
811074d8:	01204834 	movhi	r4,33056
811074dc:	210b0004 	addi	r4,r4,11264
811074e0:	1109ef80 	call	81109ef8 <uliRmapReadReg>
811074e4:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_1_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);


	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811074e8:	e13fff17 	ldw	r4,-4(fp)
811074ec:	1109f480 	call	81109f48 <uliConvRmapCfgAddr>
811074f0:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811074f4:	e0bfff17 	ldw	r2,-4(fp)
}
811074f8:	e037883a 	mov	sp,fp
811074fc:	dfc00117 	ldw	ra,4(sp)
81107500:	df000017 	ldw	fp,0(sp)
81107504:	dec00204 	addi	sp,sp,8
81107508:	f800283a 	ret

8110750c <uliRmapCh2WriteCmdAddress>:

alt_u32 uliRmapCh2WriteCmdAddress(void) {
8110750c:	defffd04 	addi	sp,sp,-12
81107510:	de00012e 	bgeu	sp,et,81107518 <uliRmapCh2WriteCmdAddress+0xc>
81107514:	003b68fa 	trap	3
81107518:	dfc00215 	stw	ra,8(sp)
8110751c:	df000115 	stw	fp,4(sp)
81107520:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107524:	01400184 	movi	r5,6
81107528:	01204834 	movhi	r4,33056
8110752c:	210a0004 	addi	r4,r4,10240
81107530:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81107534:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_2_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81107538:	e13fff17 	ldw	r4,-4(fp)
8110753c:	1109f480 	call	81109f48 <uliConvRmapCfgAddr>
81107540:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107544:	e0bfff17 	ldw	r2,-4(fp)
}
81107548:	e037883a 	mov	sp,fp
8110754c:	dfc00117 	ldw	ra,4(sp)
81107550:	df000017 	ldw	fp,0(sp)
81107554:	dec00204 	addi	sp,sp,8
81107558:	f800283a 	ret

8110755c <uliRmapCh3WriteCmdAddress>:

alt_u32 uliRmapCh3WriteCmdAddress(void) {
8110755c:	defffd04 	addi	sp,sp,-12
81107560:	de00012e 	bgeu	sp,et,81107568 <uliRmapCh3WriteCmdAddress+0xc>
81107564:	003b68fa 	trap	3
81107568:	dfc00215 	stw	ra,8(sp)
8110756c:	df000115 	stw	fp,4(sp)
81107570:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107574:	01400184 	movi	r5,6
81107578:	01204834 	movhi	r4,33056
8110757c:	210b0004 	addi	r4,r4,11264
81107580:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81107584:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_3_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81107588:	e13fff17 	ldw	r4,-4(fp)
8110758c:	1109f480 	call	81109f48 <uliConvRmapCfgAddr>
81107590:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107594:	e0bfff17 	ldw	r2,-4(fp)
}
81107598:	e037883a 	mov	sp,fp
8110759c:	dfc00117 	ldw	ra,4(sp)
811075a0:	df000017 	ldw	fp,0(sp)
811075a4:	dec00204 	addi	sp,sp,8
811075a8:	f800283a 	ret

811075ac <uliRmapCh4WriteCmdAddress>:

alt_u32 uliRmapCh4WriteCmdAddress(void) {
811075ac:	defffd04 	addi	sp,sp,-12
811075b0:	de00012e 	bgeu	sp,et,811075b8 <uliRmapCh4WriteCmdAddress+0xc>
811075b4:	003b68fa 	trap	3
811075b8:	dfc00215 	stw	ra,8(sp)
811075bc:	df000115 	stw	fp,4(sp)
811075c0:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811075c4:	01400184 	movi	r5,6
811075c8:	01204834 	movhi	r4,33056
811075cc:	210a0004 	addi	r4,r4,10240
811075d0:	1109ef80 	call	81109ef8 <uliRmapReadReg>
811075d4:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_4_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811075d8:	e13fff17 	ldw	r4,-4(fp)
811075dc:	1109f480 	call	81109f48 <uliConvRmapCfgAddr>
811075e0:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811075e4:	e0bfff17 	ldw	r2,-4(fp)
}
811075e8:	e037883a 	mov	sp,fp
811075ec:	dfc00117 	ldw	ra,4(sp)
811075f0:	df000017 	ldw	fp,0(sp)
811075f4:	dec00204 	addi	sp,sp,8
811075f8:	f800283a 	ret

811075fc <uliRmapCh5WriteCmdAddress>:

alt_u32 uliRmapCh5WriteCmdAddress(void) {
811075fc:	defffd04 	addi	sp,sp,-12
81107600:	de00012e 	bgeu	sp,et,81107608 <uliRmapCh5WriteCmdAddress+0xc>
81107604:	003b68fa 	trap	3
81107608:	dfc00215 	stw	ra,8(sp)
8110760c:	df000115 	stw	fp,4(sp)
81107610:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107614:	01400184 	movi	r5,6
81107618:	01204834 	movhi	r4,33056
8110761c:	210b0004 	addi	r4,r4,11264
81107620:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81107624:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_5_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81107628:	e13fff17 	ldw	r4,-4(fp)
8110762c:	1109f480 	call	81109f48 <uliConvRmapCfgAddr>
81107630:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107634:	e0bfff17 	ldw	r2,-4(fp)
}
81107638:	e037883a 	mov	sp,fp
8110763c:	dfc00117 	ldw	ra,4(sp)
81107640:	df000017 	ldw	fp,0(sp)
81107644:	dec00204 	addi	sp,sp,8
81107648:	f800283a 	ret

8110764c <uliRmapCh6WriteCmdAddress>:

alt_u32 uliRmapCh6WriteCmdAddress(void) {
8110764c:	defffd04 	addi	sp,sp,-12
81107650:	de00012e 	bgeu	sp,et,81107658 <uliRmapCh6WriteCmdAddress+0xc>
81107654:	003b68fa 	trap	3
81107658:	dfc00215 	stw	ra,8(sp)
8110765c:	df000115 	stw	fp,4(sp)
81107660:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107664:	01400184 	movi	r5,6
81107668:	01204834 	movhi	r4,33056
8110766c:	210a0004 	addi	r4,r4,10240
81107670:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81107674:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_6_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81107678:	e13fff17 	ldw	r4,-4(fp)
8110767c:	1109f480 	call	81109f48 <uliConvRmapCfgAddr>
81107680:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107684:	e0bfff17 	ldw	r2,-4(fp)
}
81107688:	e037883a 	mov	sp,fp
8110768c:	dfc00117 	ldw	ra,4(sp)
81107690:	df000017 	ldw	fp,0(sp)
81107694:	dec00204 	addi	sp,sp,8
81107698:	f800283a 	ret

8110769c <uliRmapCh7WriteCmdAddress>:

alt_u32 uliRmapCh7WriteCmdAddress(void) {
8110769c:	defffd04 	addi	sp,sp,-12
811076a0:	de00012e 	bgeu	sp,et,811076a8 <uliRmapCh7WriteCmdAddress+0xc>
811076a4:	003b68fa 	trap	3
811076a8:	dfc00215 	stw	ra,8(sp)
811076ac:	df000115 	stw	fp,4(sp)
811076b0:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811076b4:	01400184 	movi	r5,6
811076b8:	01204834 	movhi	r4,33056
811076bc:	210b0004 	addi	r4,r4,11264
811076c0:	1109ef80 	call	81109ef8 <uliRmapReadReg>
811076c4:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_7_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811076c8:	e13fff17 	ldw	r4,-4(fp)
811076cc:	1109f480 	call	81109f48 <uliConvRmapCfgAddr>
811076d0:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811076d4:	e0bfff17 	ldw	r2,-4(fp)
}
811076d8:	e037883a 	mov	sp,fp
811076dc:	dfc00117 	ldw	ra,4(sp)
811076e0:	df000017 	ldw	fp,0(sp)
811076e4:	dec00204 	addi	sp,sp,8
811076e8:	f800283a 	ret

811076ec <uliRmapCh8WriteCmdAddress>:

alt_u32 uliRmapCh8WriteCmdAddress(void) {
811076ec:	defffd04 	addi	sp,sp,-12
811076f0:	de00012e 	bgeu	sp,et,811076f8 <uliRmapCh8WriteCmdAddress+0xc>
811076f4:	003b68fa 	trap	3
811076f8:	dfc00215 	stw	ra,8(sp)
811076fc:	df000115 	stw	fp,4(sp)
81107700:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107704:	01400184 	movi	r5,6
81107708:	01204834 	movhi	r4,33056
8110770c:	210a0004 	addi	r4,r4,10240
81107710:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81107714:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_8_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81107718:	e13fff17 	ldw	r4,-4(fp)
8110771c:	1109f480 	call	81109f48 <uliConvRmapCfgAddr>
81107720:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107724:	e0bfff17 	ldw	r2,-4(fp)
}
81107728:	e037883a 	mov	sp,fp
8110772c:	dfc00117 	ldw	ra,4(sp)
81107730:	df000017 	ldw	fp,0(sp)
81107734:	dec00204 	addi	sp,sp,8
81107738:	f800283a 	ret

8110773c <vRmapInitIrq>:

void vRmapInitIrq(alt_u8 ucCommCh) {
8110773c:	defffc04 	addi	sp,sp,-16
81107740:	de00012e 	bgeu	sp,et,81107748 <vRmapInitIrq+0xc>
81107744:	003b68fa 	trap	3
81107748:	dfc00315 	stw	ra,12(sp)
8110774c:	df000215 	stw	fp,8(sp)
81107750:	df000204 	addi	fp,sp,8
81107754:	2005883a 	mov	r2,r4
81107758:	e0bfff05 	stb	r2,-4(fp)
	void* pvHoldContext;
	switch (ucCommCh) {
8110775c:	e0bfff03 	ldbu	r2,-4(fp)
81107760:	10c00228 	cmpgeui	r3,r2,8
81107764:	18004e1e 	bne	r3,zero,811078a0 <vRmapInitIrq+0x164>
81107768:	100690ba 	slli	r3,r2,2
8110776c:	00a04434 	movhi	r2,33040
81107770:	109de004 	addi	r2,r2,30592
81107774:	1885883a 	add	r2,r3,r2
81107778:	10800017 	ldw	r2,0(r2)
8110777c:	1000683a 	jmp	r2
81107780:	811077a0 	cmpeqi	r4,r16,16862
81107784:	811077c0 	call	8811077c <__reset+0x20f077c>
81107788:	811077e0 	cmpeqi	r4,r16,16863
8110778c:	81107800 	call	88110780 <__reset+0x20f0780>
81107790:	81107820 	cmpeqi	r4,r16,16864
81107794:	81107840 	call	88110784 <__reset+0x20f0784>
81107798:	81107860 	cmpeqi	r4,r16,16865
8110779c:	81107880 	call	88110788 <__reset+0x20f0788>
	case eCommSpwCh1:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh1HoldContext;
811077a0:	d0a04804 	addi	r2,gp,-32480
811077a4:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_1_RMAP_IRQ, pvHoldContext, vRmapCh1HandleIrq);
811077a8:	01a04434 	movhi	r6,33040
811077ac:	319b5604 	addi	r6,r6,27992
811077b0:	e17ffe17 	ldw	r5,-8(fp)
811077b4:	010005c4 	movi	r4,23
811077b8:	1135fec0 	call	81135fec <alt_irq_register>
		break;
811077bc:	00003806 	br	811078a0 <vRmapInitIrq+0x164>
	case eCommSpwCh2:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh2HoldContext;
811077c0:	d0a04904 	addi	r2,gp,-32476
811077c4:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_2_RMAP_IRQ, pvHoldContext, vRmapCh2HandleIrq);
811077c8:	01a04434 	movhi	r6,33040
811077cc:	319b8704 	addi	r6,r6,28188
811077d0:	e17ffe17 	ldw	r5,-8(fp)
811077d4:	01000544 	movi	r4,21
811077d8:	1135fec0 	call	81135fec <alt_irq_register>
		break;
811077dc:	00003006 	br	811078a0 <vRmapInitIrq+0x164>
	case eCommSpwCh3:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh3HoldContext;
811077e0:	d0a04a04 	addi	r2,gp,-32472
811077e4:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_3_RMAP_IRQ, pvHoldContext, vRmapCh3HandleIrq);
811077e8:	01a04434 	movhi	r6,33040
811077ec:	319b9704 	addi	r6,r6,28252
811077f0:	e17ffe17 	ldw	r5,-8(fp)
811077f4:	010004c4 	movi	r4,19
811077f8:	1135fec0 	call	81135fec <alt_irq_register>
		break;
811077fc:	00002806 	br	811078a0 <vRmapInitIrq+0x164>
	case eCommSpwCh4:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh4HoldContext;
81107800:	d0a04b04 	addi	r2,gp,-32468
81107804:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_4_RMAP_IRQ, pvHoldContext, vRmapCh4HandleIrq);
81107808:	01a04434 	movhi	r6,33040
8110780c:	319ba704 	addi	r6,r6,28316
81107810:	e17ffe17 	ldw	r5,-8(fp)
81107814:	01000444 	movi	r4,17
81107818:	1135fec0 	call	81135fec <alt_irq_register>
		break;
8110781c:	00002006 	br	811078a0 <vRmapInitIrq+0x164>
	case eCommSpwCh5:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh5HoldContext;
81107820:	d0a04c04 	addi	r2,gp,-32464
81107824:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_5_RMAP_IRQ, pvHoldContext, vRmapCh5HandleIrq);
81107828:	01a04434 	movhi	r6,33040
8110782c:	319bb704 	addi	r6,r6,28380
81107830:	e17ffe17 	ldw	r5,-8(fp)
81107834:	01000244 	movi	r4,9
81107838:	1135fec0 	call	81135fec <alt_irq_register>
		break;
8110783c:	00001806 	br	811078a0 <vRmapInitIrq+0x164>
	case eCommSpwCh6:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh6HoldContext;
81107840:	d0a04d04 	addi	r2,gp,-32460
81107844:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_6_RMAP_IRQ, pvHoldContext, vRmapCh6HandleIrq);
81107848:	01a04434 	movhi	r6,33040
8110784c:	319bc704 	addi	r6,r6,28444
81107850:	e17ffe17 	ldw	r5,-8(fp)
81107854:	010001c4 	movi	r4,7
81107858:	1135fec0 	call	81135fec <alt_irq_register>
		break;
8110785c:	00001006 	br	811078a0 <vRmapInitIrq+0x164>
	case eCommSpwCh7:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh7HoldContext;
81107860:	d0a04e04 	addi	r2,gp,-32456
81107864:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_7_RMAP_IRQ, pvHoldContext, vRmapCh7HandleIrq);
81107868:	01a04434 	movhi	r6,33040
8110786c:	319bd704 	addi	r6,r6,28508
81107870:	e17ffe17 	ldw	r5,-8(fp)
81107874:	01000104 	movi	r4,4
81107878:	1135fec0 	call	81135fec <alt_irq_register>
		break;
8110787c:	00000806 	br	811078a0 <vRmapInitIrq+0x164>
	case eCommSpwCh8:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh8HoldContext;
81107880:	d0a04f04 	addi	r2,gp,-32452
81107884:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_8_RMAP_IRQ, pvHoldContext, vRmapCh8HandleIrq);
81107888:	01a04434 	movhi	r6,33040
8110788c:	319be704 	addi	r6,r6,28572
81107890:	e17ffe17 	ldw	r5,-8(fp)
81107894:	010000c4 	movi	r4,3
81107898:	1135fec0 	call	81135fec <alt_irq_register>
		break;
8110789c:	0001883a 	nop
	}
}
811078a0:	0001883a 	nop
811078a4:	e037883a 	mov	sp,fp
811078a8:	dfc00117 	ldw	ra,4(sp)
811078ac:	df000017 	ldw	fp,0(sp)
811078b0:	dec00204 	addi	sp,sp,8
811078b4:	f800283a 	ret

811078b8 <bRmapSetIrqControl>:

bool bRmapSetIrqControl(TRmapChannel *pxRmapCh) {
811078b8:	defffb04 	addi	sp,sp,-20
811078bc:	de00012e 	bgeu	sp,et,811078c4 <bRmapSetIrqControl+0xc>
811078c0:	003b68fa 	trap	3
811078c4:	dfc00415 	stw	ra,16(sp)
811078c8:	df000315 	stw	fp,12(sp)
811078cc:	df000304 	addi	fp,sp,12
811078d0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811078d4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811078d8:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
811078dc:	e0bfff17 	ldw	r2,-4(fp)
811078e0:	10001926 	beq	r2,zero,81107948 <bRmapSetIrqControl+0x90>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811078e4:	e0bfff17 	ldw	r2,-4(fp)
811078e8:	10800017 	ldw	r2,0(r2)
811078ec:	01400444 	movi	r5,17
811078f0:	1009883a 	mov	r4,r2
811078f4:	1109ef80 	call	81109ef8 <uliRmapReadReg>
811078f8:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (pxRmapCh->xRmapIrqControl.bWriteCmdEn) {
811078fc:	e0bfff17 	ldw	r2,-4(fp)
81107900:	10801017 	ldw	r2,64(r2)
81107904:	10000426 	beq	r2,zero,81107918 <bRmapSetIrqControl+0x60>
			uliReg |= COMM_IRQ_RMAP_WRCMD_EN_MSK;
81107908:	e0bffe17 	ldw	r2,-8(fp)
8110790c:	10800054 	ori	r2,r2,1
81107910:	e0bffe15 	stw	r2,-8(fp)
81107914:	00000406 	br	81107928 <bRmapSetIrqControl+0x70>
		} else {
			uliReg &= (~COMM_IRQ_RMAP_WRCMD_EN_MSK);
81107918:	e0fffe17 	ldw	r3,-8(fp)
8110791c:	00bfff84 	movi	r2,-2
81107920:	1884703a 	and	r2,r3,r2
81107924:	e0bffe15 	stw	r2,-8(fp)
		}

		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_IRQ_CONTROL_REG_OFST,
81107928:	e0bfff17 	ldw	r2,-4(fp)
8110792c:	10800017 	ldw	r2,0(r2)
81107930:	e1bffe17 	ldw	r6,-8(fp)
81107934:	01400444 	movi	r5,17
81107938:	1009883a 	mov	r4,r2
8110793c:	1109ea40 	call	81109ea4 <vRmapWriteReg>
				uliReg);
		bStatus = TRUE;
81107940:	00800044 	movi	r2,1
81107944:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107948:	e0bffd17 	ldw	r2,-12(fp)
}
8110794c:	e037883a 	mov	sp,fp
81107950:	dfc00117 	ldw	ra,4(sp)
81107954:	df000017 	ldw	fp,0(sp)
81107958:	dec00204 	addi	sp,sp,8
8110795c:	f800283a 	ret

81107960 <bRmapGetIrqControl>:

bool bRmapGetIrqControl(TRmapChannel *pxRmapCh) {
81107960:	defffb04 	addi	sp,sp,-20
81107964:	de00012e 	bgeu	sp,et,8110796c <bRmapGetIrqControl+0xc>
81107968:	003b68fa 	trap	3
8110796c:	dfc00415 	stw	ra,16(sp)
81107970:	df000315 	stw	fp,12(sp)
81107974:	df000304 	addi	fp,sp,12
81107978:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110797c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107980:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107984:	e0bfff17 	ldw	r2,-4(fp)
81107988:	10001126 	beq	r2,zero,811079d0 <bRmapGetIrqControl+0x70>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110798c:	e0bfff17 	ldw	r2,-4(fp)
81107990:	10800017 	ldw	r2,0(r2)
81107994:	01400444 	movi	r5,17
81107998:	1009883a 	mov	r4,r2
8110799c:	1109ef80 	call	81109ef8 <uliRmapReadReg>
811079a0:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (uliReg & COMM_IRQ_RMAP_WRCMD_EN_MSK) {
811079a4:	e0bffe17 	ldw	r2,-8(fp)
811079a8:	1080004c 	andi	r2,r2,1
811079ac:	10000426 	beq	r2,zero,811079c0 <bRmapGetIrqControl+0x60>
			pxRmapCh->xRmapIrqControl.bWriteCmdEn = TRUE;
811079b0:	e0bfff17 	ldw	r2,-4(fp)
811079b4:	00c00044 	movi	r3,1
811079b8:	10c01015 	stw	r3,64(r2)
811079bc:	00000206 	br	811079c8 <bRmapGetIrqControl+0x68>
		} else {
			pxRmapCh->xRmapIrqControl.bWriteCmdEn = FALSE;
811079c0:	e0bfff17 	ldw	r2,-4(fp)
811079c4:	10001015 	stw	zero,64(r2)
		}

		bStatus = TRUE;
811079c8:	00800044 	movi	r2,1
811079cc:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811079d0:	e0bffd17 	ldw	r2,-12(fp)
}
811079d4:	e037883a 	mov	sp,fp
811079d8:	dfc00117 	ldw	ra,4(sp)
811079dc:	df000017 	ldw	fp,0(sp)
811079e0:	dec00204 	addi	sp,sp,8
811079e4:	f800283a 	ret

811079e8 <bRmapGetIrqFlags>:

bool bRmapGetIrqFlags(TRmapChannel *pxRmapCh) {
811079e8:	defffb04 	addi	sp,sp,-20
811079ec:	de00012e 	bgeu	sp,et,811079f4 <bRmapGetIrqFlags+0xc>
811079f0:	003b68fa 	trap	3
811079f4:	dfc00415 	stw	ra,16(sp)
811079f8:	df000315 	stw	fp,12(sp)
811079fc:	df000304 	addi	fp,sp,12
81107a00:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107a04:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107a08:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107a0c:	e0bfff17 	ldw	r2,-4(fp)
81107a10:	10001126 	beq	r2,zero,81107a58 <bRmapGetIrqFlags+0x70>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107a14:	e0bfff17 	ldw	r2,-4(fp)
81107a18:	10800017 	ldw	r2,0(r2)
81107a1c:	01400484 	movi	r5,18
81107a20:	1009883a 	mov	r4,r2
81107a24:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81107a28:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_FLAGS_REG_OFST);

		if (uliReg & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107a2c:	e0bffe17 	ldw	r2,-8(fp)
81107a30:	1080004c 	andi	r2,r2,1
81107a34:	10000426 	beq	r2,zero,81107a48 <bRmapGetIrqFlags+0x60>
			pxRmapCh->xRmapIrqFlag.bWriteCmdFlag = TRUE;
81107a38:	e0bfff17 	ldw	r2,-4(fp)
81107a3c:	00c00044 	movi	r3,1
81107a40:	10c01115 	stw	r3,68(r2)
81107a44:	00000206 	br	81107a50 <bRmapGetIrqFlags+0x68>
		} else {
			pxRmapCh->xRmapIrqFlag.bWriteCmdFlag = FALSE;
81107a48:	e0bfff17 	ldw	r2,-4(fp)
81107a4c:	10001115 	stw	zero,68(r2)
		}

		bStatus = TRUE;
81107a50:	00800044 	movi	r2,1
81107a54:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107a58:	e0bffd17 	ldw	r2,-12(fp)
}
81107a5c:	e037883a 	mov	sp,fp
81107a60:	dfc00117 	ldw	ra,4(sp)
81107a64:	df000017 	ldw	fp,0(sp)
81107a68:	dec00204 	addi	sp,sp,8
81107a6c:	f800283a 	ret

81107a70 <bRmapSetCodecConfig>:

bool bRmapSetCodecConfig(TRmapChannel *pxRmapCh) {
81107a70:	defffb04 	addi	sp,sp,-20
81107a74:	de00012e 	bgeu	sp,et,81107a7c <bRmapSetCodecConfig+0xc>
81107a78:	003b68fa 	trap	3
81107a7c:	dfc00415 	stw	ra,16(sp)
81107a80:	df000315 	stw	fp,12(sp)
81107a84:	df000304 	addi	fp,sp,12
81107a88:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107a8c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107a90:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107a94:	e0bfff17 	ldw	r2,-4(fp)
81107a98:	10002526 	beq	r2,zero,81107b30 <bRmapSetCodecConfig+0xc0>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107a9c:	e0bfff17 	ldw	r2,-4(fp)
81107aa0:	10800017 	ldw	r2,0(r2)
81107aa4:	01400104 	movi	r5,4
81107aa8:	1009883a 	mov	r4,r2
81107aac:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81107ab0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_CFG_REG_OFST);

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
81107ab4:	e0fffe17 	ldw	r3,-8(fp)
81107ab8:	00bfc004 	movi	r2,-256
81107abc:	1884703a 	and	r2,r3,r2
81107ac0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
81107ac4:	e0bfff17 	ldw	r2,-4(fp)
81107ac8:	10800143 	ldbu	r2,5(r2)
81107acc:	10803fcc 	andi	r2,r2,255

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_CODEC_CFG_REG_OFST);

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
81107ad0:	e0fffe17 	ldw	r3,-8(fp)
81107ad4:	1884b03a 	or	r2,r3,r2
81107ad8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
		uliReg &= (~COMM_RMAP_TARGET_KEY_MSK);
81107adc:	e0fffe17 	ldw	r3,-8(fp)
81107ae0:	00bffff4 	movhi	r2,65535
81107ae4:	10803fc4 	addi	r2,r2,255
81107ae8:	1884703a 	and	r2,r3,r2
81107aec:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_TARGET_KEY_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucKey << 8));
81107af0:	e0bfff17 	ldw	r2,-4(fp)
81107af4:	10800103 	ldbu	r2,4(r2)
81107af8:	10803fcc 	andi	r2,r2,255
81107afc:	1004923a 	slli	r2,r2,8
81107b00:	10bfffcc 	andi	r2,r2,65535

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
		uliReg &= (~COMM_RMAP_TARGET_KEY_MSK);
		uliReg |= (COMM_RMAP_TARGET_KEY_MSK
81107b04:	e0fffe17 	ldw	r3,-8(fp)
81107b08:	1884b03a 	or	r2,r3,r2
81107b0c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucKey << 8));

		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CODEC_CFG_REG_OFST,
81107b10:	e0bfff17 	ldw	r2,-4(fp)
81107b14:	10800017 	ldw	r2,0(r2)
81107b18:	e1bffe17 	ldw	r6,-8(fp)
81107b1c:	01400104 	movi	r5,4
81107b20:	1009883a 	mov	r4,r2
81107b24:	1109ea40 	call	81109ea4 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
81107b28:	00800044 	movi	r2,1
81107b2c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107b30:	e0bffd17 	ldw	r2,-12(fp)
}
81107b34:	e037883a 	mov	sp,fp
81107b38:	dfc00117 	ldw	ra,4(sp)
81107b3c:	df000017 	ldw	fp,0(sp)
81107b40:	dec00204 	addi	sp,sp,8
81107b44:	f800283a 	ret

81107b48 <bRmapGetCodecConfig>:

bool bRmapGetCodecConfig(TRmapChannel *pxRmapCh) {
81107b48:	defffb04 	addi	sp,sp,-20
81107b4c:	de00012e 	bgeu	sp,et,81107b54 <bRmapGetCodecConfig+0xc>
81107b50:	003b68fa 	trap	3
81107b54:	dfc00415 	stw	ra,16(sp)
81107b58:	df000315 	stw	fp,12(sp)
81107b5c:	df000304 	addi	fp,sp,12
81107b60:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107b64:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107b68:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107b6c:	e0bfff17 	ldw	r2,-4(fp)
81107b70:	10001226 	beq	r2,zero,81107bbc <bRmapGetCodecConfig+0x74>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107b74:	e0bfff17 	ldw	r2,-4(fp)
81107b78:	10800017 	ldw	r2,0(r2)
81107b7c:	01400104 	movi	r5,4
81107b80:	1009883a 	mov	r4,r2
81107b84:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81107b88:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_CFG_REG_OFST);

		pxRmapCh->xRmapCodecConfig.ucLogicalAddress = (alt_u8) ((uliReg
81107b8c:	e0bffe17 	ldw	r2,-8(fp)
81107b90:	1007883a 	mov	r3,r2
81107b94:	e0bfff17 	ldw	r2,-4(fp)
81107b98:	10c00145 	stb	r3,5(r2)
				& COMM_RMAP_TARGET_LOG_ADDR_MSK) >> 0);
		pxRmapCh->xRmapCodecConfig.ucKey = (alt_u8) ((uliReg
				& COMM_RMAP_TARGET_KEY_MSK) >> 8);
81107b9c:	e0bffe17 	ldw	r2,-8(fp)
81107ba0:	10bfc00c 	andi	r2,r2,65280
81107ba4:	1004d23a 	srli	r2,r2,8
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_CODEC_CFG_REG_OFST);

		pxRmapCh->xRmapCodecConfig.ucLogicalAddress = (alt_u8) ((uliReg
				& COMM_RMAP_TARGET_LOG_ADDR_MSK) >> 0);
		pxRmapCh->xRmapCodecConfig.ucKey = (alt_u8) ((uliReg
81107ba8:	1007883a 	mov	r3,r2
81107bac:	e0bfff17 	ldw	r2,-4(fp)
81107bb0:	10c00105 	stb	r3,4(r2)
				& COMM_RMAP_TARGET_KEY_MSK) >> 8);

		bStatus = TRUE;
81107bb4:	00800044 	movi	r2,1
81107bb8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107bbc:	e0bffd17 	ldw	r2,-12(fp)
}
81107bc0:	e037883a 	mov	sp,fp
81107bc4:	dfc00117 	ldw	ra,4(sp)
81107bc8:	df000017 	ldw	fp,0(sp)
81107bcc:	dec00204 	addi	sp,sp,8
81107bd0:	f800283a 	ret

81107bd4 <bRmapGetCodecStatus>:

bool bRmapGetCodecStatus(TRmapChannel *pxRmapCh) {
81107bd4:	defffb04 	addi	sp,sp,-20
81107bd8:	de00012e 	bgeu	sp,et,81107be0 <bRmapGetCodecStatus+0xc>
81107bdc:	003b68fa 	trap	3
81107be0:	dfc00415 	stw	ra,16(sp)
81107be4:	df000315 	stw	fp,12(sp)
81107be8:	df000304 	addi	fp,sp,12
81107bec:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107bf0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107bf4:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107bf8:	e0bfff17 	ldw	r2,-4(fp)
81107bfc:	10004726 	beq	r2,zero,81107d1c <bRmapGetCodecStatus+0x148>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107c00:	e0bfff17 	ldw	r2,-4(fp)
81107c04:	10800017 	ldw	r2,0(r2)
81107c08:	01400144 	movi	r5,5
81107c0c:	1009883a 	mov	r4,r2
81107c10:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81107c14:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_STAT_REG_OFST);

		if (uliReg & COMM_RMAP_STAT_CMD_RECEIVED_MSK) {
81107c18:	e0bffe17 	ldw	r2,-8(fp)
81107c1c:	1080004c 	andi	r2,r2,1
81107c20:	10000426 	beq	r2,zero,81107c34 <bRmapGetCodecStatus+0x60>
			pxRmapCh->xRmapCodecStatus.bCommandReceived = TRUE;
81107c24:	e0bfff17 	ldw	r2,-4(fp)
81107c28:	00c00044 	movi	r3,1
81107c2c:	10c00215 	stw	r3,8(r2)
81107c30:	00000206 	br	81107c3c <bRmapGetCodecStatus+0x68>
		} else {
			pxRmapCh->xRmapCodecStatus.bCommandReceived = FALSE;
81107c34:	e0bfff17 	ldw	r2,-4(fp)
81107c38:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_RMAP_STAT_WR_REQ_MSK) {
81107c3c:	e0bffe17 	ldw	r2,-8(fp)
81107c40:	1080008c 	andi	r2,r2,2
81107c44:	10000426 	beq	r2,zero,81107c58 <bRmapGetCodecStatus+0x84>
			pxRmapCh->xRmapCodecStatus.bWriteRequested = TRUE;
81107c48:	e0bfff17 	ldw	r2,-4(fp)
81107c4c:	00c00044 	movi	r3,1
81107c50:	10c00315 	stw	r3,12(r2)
81107c54:	00000206 	br	81107c60 <bRmapGetCodecStatus+0x8c>
		} else {
			pxRmapCh->xRmapCodecStatus.bWriteRequested = FALSE;
81107c58:	e0bfff17 	ldw	r2,-4(fp)
81107c5c:	10000315 	stw	zero,12(r2)
		}
		if (uliReg & COMM_RMAP_STAT_WR_AUTH_MSK) {
81107c60:	e0bffe17 	ldw	r2,-8(fp)
81107c64:	1080010c 	andi	r2,r2,4
81107c68:	10000426 	beq	r2,zero,81107c7c <bRmapGetCodecStatus+0xa8>
			pxRmapCh->xRmapCodecStatus.bWriteAuthorized = TRUE;
81107c6c:	e0bfff17 	ldw	r2,-4(fp)
81107c70:	00c00044 	movi	r3,1
81107c74:	10c00415 	stw	r3,16(r2)
81107c78:	00000206 	br	81107c84 <bRmapGetCodecStatus+0xb0>
		} else {
			pxRmapCh->xRmapCodecStatus.bWriteAuthorized = FALSE;
81107c7c:	e0bfff17 	ldw	r2,-4(fp)
81107c80:	10000415 	stw	zero,16(r2)
		}
		if (uliReg & COMM_RMAP_STAT_RD_REQ_MSK) {
81107c84:	e0bffe17 	ldw	r2,-8(fp)
81107c88:	1080020c 	andi	r2,r2,8
81107c8c:	10000426 	beq	r2,zero,81107ca0 <bRmapGetCodecStatus+0xcc>
			pxRmapCh->xRmapCodecStatus.bReadRequested = TRUE;
81107c90:	e0bfff17 	ldw	r2,-4(fp)
81107c94:	00c00044 	movi	r3,1
81107c98:	10c00515 	stw	r3,20(r2)
81107c9c:	00000206 	br	81107ca8 <bRmapGetCodecStatus+0xd4>
		} else {
			pxRmapCh->xRmapCodecStatus.bReadRequested = FALSE;
81107ca0:	e0bfff17 	ldw	r2,-4(fp)
81107ca4:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_RMAP_STAT_RD_AUTH_MSK) {
81107ca8:	e0bffe17 	ldw	r2,-8(fp)
81107cac:	1080040c 	andi	r2,r2,16
81107cb0:	10000426 	beq	r2,zero,81107cc4 <bRmapGetCodecStatus+0xf0>
			pxRmapCh->xRmapCodecStatus.bReadAuthorized = TRUE;
81107cb4:	e0bfff17 	ldw	r2,-4(fp)
81107cb8:	00c00044 	movi	r3,1
81107cbc:	10c00615 	stw	r3,24(r2)
81107cc0:	00000206 	br	81107ccc <bRmapGetCodecStatus+0xf8>
		} else {
			pxRmapCh->xRmapCodecStatus.bReadAuthorized = FALSE;
81107cc4:	e0bfff17 	ldw	r2,-4(fp)
81107cc8:	10000615 	stw	zero,24(r2)
		}
		if (uliReg & COMM_RMAP_STAT_REPLY_SEND_MSK) {
81107ccc:	e0bffe17 	ldw	r2,-8(fp)
81107cd0:	1080080c 	andi	r2,r2,32
81107cd4:	10000426 	beq	r2,zero,81107ce8 <bRmapGetCodecStatus+0x114>
			pxRmapCh->xRmapCodecStatus.bReplySended = TRUE;
81107cd8:	e0bfff17 	ldw	r2,-4(fp)
81107cdc:	00c00044 	movi	r3,1
81107ce0:	10c00715 	stw	r3,28(r2)
81107ce4:	00000206 	br	81107cf0 <bRmapGetCodecStatus+0x11c>
		} else {
			pxRmapCh->xRmapCodecStatus.bReplySended = FALSE;
81107ce8:	e0bfff17 	ldw	r2,-4(fp)
81107cec:	10000715 	stw	zero,28(r2)
		}
		if (uliReg & COMM_RMAP_STAT_DISCARD_PKG_MSK) {
81107cf0:	e0bffe17 	ldw	r2,-8(fp)
81107cf4:	1080100c 	andi	r2,r2,64
81107cf8:	10000426 	beq	r2,zero,81107d0c <bRmapGetCodecStatus+0x138>
			pxRmapCh->xRmapCodecStatus.bDiscardedPackage = TRUE;
81107cfc:	e0bfff17 	ldw	r2,-4(fp)
81107d00:	00c00044 	movi	r3,1
81107d04:	10c00815 	stw	r3,32(r2)
81107d08:	00000206 	br	81107d14 <bRmapGetCodecStatus+0x140>
		} else {
			pxRmapCh->xRmapCodecStatus.bCommandReceived = FALSE;
81107d0c:	e0bfff17 	ldw	r2,-4(fp)
81107d10:	10000215 	stw	zero,8(r2)
		}

		bStatus = TRUE;
81107d14:	00800044 	movi	r2,1
81107d18:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107d1c:	e0bffd17 	ldw	r2,-12(fp)
}
81107d20:	e037883a 	mov	sp,fp
81107d24:	dfc00117 	ldw	ra,4(sp)
81107d28:	df000017 	ldw	fp,0(sp)
81107d2c:	dec00204 	addi	sp,sp,8
81107d30:	f800283a 	ret

81107d34 <bRmapGetCodecError>:

bool bRmapGetCodecError(TRmapChannel *pxRmapCh) {
81107d34:	defffb04 	addi	sp,sp,-20
81107d38:	de00012e 	bgeu	sp,et,81107d40 <bRmapGetCodecError+0xc>
81107d3c:	003b68fa 	trap	3
81107d40:	dfc00415 	stw	ra,16(sp)
81107d44:	df000315 	stw	fp,12(sp)
81107d48:	df000304 	addi	fp,sp,12
81107d4c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107d50:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107d54:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107d58:	e0bfff17 	ldw	r2,-4(fp)
81107d5c:	10004726 	beq	r2,zero,81107e7c <bRmapGetCodecError+0x148>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107d60:	e0bfff17 	ldw	r2,-4(fp)
81107d64:	10800017 	ldw	r2,0(r2)
81107d68:	01400144 	movi	r5,5
81107d6c:	1009883a 	mov	r4,r2
81107d70:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81107d74:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_STAT_REG_OFST);

		if (uliReg & COMM_RMAP_ERR_EARLY_EOP_MSK) {
81107d78:	e0bffe17 	ldw	r2,-8(fp)
81107d7c:	1080006c 	andhi	r2,r2,1
81107d80:	10000426 	beq	r2,zero,81107d94 <bRmapGetCodecError+0x60>
			pxRmapCh->xRmapCodecError.bEarlyEop = TRUE;
81107d84:	e0bfff17 	ldw	r2,-4(fp)
81107d88:	00c00044 	movi	r3,1
81107d8c:	10c00915 	stw	r3,36(r2)
81107d90:	00000206 	br	81107d9c <bRmapGetCodecError+0x68>
		} else {
			pxRmapCh->xRmapCodecError.bEarlyEop = FALSE;
81107d94:	e0bfff17 	ldw	r2,-4(fp)
81107d98:	10000915 	stw	zero,36(r2)
		}
		if (uliReg & COMM_RMAP_ERR_EEP_MSK) {
81107d9c:	e0bffe17 	ldw	r2,-8(fp)
81107da0:	108000ac 	andhi	r2,r2,2
81107da4:	10000426 	beq	r2,zero,81107db8 <bRmapGetCodecError+0x84>
			pxRmapCh->xRmapCodecError.bEep = TRUE;
81107da8:	e0bfff17 	ldw	r2,-4(fp)
81107dac:	00c00044 	movi	r3,1
81107db0:	10c00a15 	stw	r3,40(r2)
81107db4:	00000206 	br	81107dc0 <bRmapGetCodecError+0x8c>
		} else {
			pxRmapCh->xRmapCodecError.bEep = FALSE;
81107db8:	e0bfff17 	ldw	r2,-4(fp)
81107dbc:	10000a15 	stw	zero,40(r2)
		}
		if (uliReg & COMM_RMAP_ERR_HEADER_CRC_MSK) {
81107dc0:	e0bffe17 	ldw	r2,-8(fp)
81107dc4:	1080012c 	andhi	r2,r2,4
81107dc8:	10000426 	beq	r2,zero,81107ddc <bRmapGetCodecError+0xa8>
			pxRmapCh->xRmapCodecError.bHeaderCRC = TRUE;
81107dcc:	e0bfff17 	ldw	r2,-4(fp)
81107dd0:	00c00044 	movi	r3,1
81107dd4:	10c00b15 	stw	r3,44(r2)
81107dd8:	00000206 	br	81107de4 <bRmapGetCodecError+0xb0>
		} else {
			pxRmapCh->xRmapCodecError.bHeaderCRC = FALSE;
81107ddc:	e0bfff17 	ldw	r2,-4(fp)
81107de0:	10000b15 	stw	zero,44(r2)
		}
		if (uliReg & COMM_RMAP_ERR_UNUSED_PKT_MSK) {
81107de4:	e0bffe17 	ldw	r2,-8(fp)
81107de8:	1080022c 	andhi	r2,r2,8
81107dec:	10000426 	beq	r2,zero,81107e00 <bRmapGetCodecError+0xcc>
			pxRmapCh->xRmapCodecError.bUnusedPacketType = TRUE;
81107df0:	e0bfff17 	ldw	r2,-4(fp)
81107df4:	00c00044 	movi	r3,1
81107df8:	10c00c15 	stw	r3,48(r2)
81107dfc:	00000206 	br	81107e08 <bRmapGetCodecError+0xd4>
		} else {
			pxRmapCh->xRmapCodecError.bUnusedPacketType = FALSE;
81107e00:	e0bfff17 	ldw	r2,-4(fp)
81107e04:	10000c15 	stw	zero,48(r2)
		}
		if (uliReg & COMM_RMAP_ERR_INVALID_CMD_MSK) {
81107e08:	e0bffe17 	ldw	r2,-8(fp)
81107e0c:	1080042c 	andhi	r2,r2,16
81107e10:	10000426 	beq	r2,zero,81107e24 <bRmapGetCodecError+0xf0>
			pxRmapCh->xRmapCodecError.bInvalidCommandCode = TRUE;
81107e14:	e0bfff17 	ldw	r2,-4(fp)
81107e18:	00c00044 	movi	r3,1
81107e1c:	10c00d15 	stw	r3,52(r2)
81107e20:	00000206 	br	81107e2c <bRmapGetCodecError+0xf8>
		} else {
			pxRmapCh->xRmapCodecError.bInvalidCommandCode = FALSE;
81107e24:	e0bfff17 	ldw	r2,-4(fp)
81107e28:	10000d15 	stw	zero,52(r2)
		}
		if (uliReg & COMM_RMAP_ERR_TOO_MUCH_DATA_MSK) {
81107e2c:	e0bffe17 	ldw	r2,-8(fp)
81107e30:	1080082c 	andhi	r2,r2,32
81107e34:	10000426 	beq	r2,zero,81107e48 <bRmapGetCodecError+0x114>
			pxRmapCh->xRmapCodecError.bTooMuchData = TRUE;
81107e38:	e0bfff17 	ldw	r2,-4(fp)
81107e3c:	00c00044 	movi	r3,1
81107e40:	10c00e15 	stw	r3,56(r2)
81107e44:	00000206 	br	81107e50 <bRmapGetCodecError+0x11c>
		} else {
			pxRmapCh->xRmapCodecError.bTooMuchData = FALSE;
81107e48:	e0bfff17 	ldw	r2,-4(fp)
81107e4c:	10000e15 	stw	zero,56(r2)
		}
		if (uliReg & COMM_RMAP_ERR_INVALID_DCRC_MSK) {
81107e50:	e0bffe17 	ldw	r2,-8(fp)
81107e54:	1080102c 	andhi	r2,r2,64
81107e58:	10000426 	beq	r2,zero,81107e6c <bRmapGetCodecError+0x138>
			pxRmapCh->xRmapCodecError.bInvalidDataCrc = TRUE;
81107e5c:	e0bfff17 	ldw	r2,-4(fp)
81107e60:	00c00044 	movi	r3,1
81107e64:	10c00f15 	stw	r3,60(r2)
81107e68:	00000206 	br	81107e74 <bRmapGetCodecError+0x140>
		} else {
			pxRmapCh->xRmapCodecError.bInvalidDataCrc = FALSE;
81107e6c:	e0bfff17 	ldw	r2,-4(fp)
81107e70:	10000f15 	stw	zero,60(r2)
		}

		bStatus = TRUE;
81107e74:	00800044 	movi	r2,1
81107e78:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107e7c:	e0bffd17 	ldw	r2,-12(fp)
}
81107e80:	e037883a 	mov	sp,fp
81107e84:	dfc00117 	ldw	ra,4(sp)
81107e88:	df000017 	ldw	fp,0(sp)
81107e8c:	dec00204 	addi	sp,sp,8
81107e90:	f800283a 	ret

81107e94 <bRmapSetMemConfigArea>:

bool bRmapSetMemConfigArea(TRmapChannel *pxRmapCh) {
81107e94:	defffb04 	addi	sp,sp,-20
81107e98:	de00012e 	bgeu	sp,et,81107ea0 <bRmapSetMemConfigArea+0xc>
81107e9c:	003b68fa 	trap	3
81107ea0:	dfc00415 	stw	ra,16(sp)
81107ea4:	df000315 	stw	fp,12(sp)
81107ea8:	df000304 	addi	fp,sp,12
81107eac:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107eb0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107eb4:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107eb8:	e0bfff17 	ldw	r2,-4(fp)
81107ebc:	1000aa26 	beq	r2,zero,81108168 <bRmapSetMemConfigArea+0x2d4>

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config;
81107ec0:	e0bfff17 	ldw	r2,-4(fp)
81107ec4:	10801217 	ldw	r2,72(r2)
81107ec8:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_REGCLK_DIR_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 3));
//			uliReg &= (~COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK);
//			uliReg |= (COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 4));
//			uliReg &= (~COMM_RMAP_REGCLK_TRCNT_CTRL_MSK);
//			uliReg |= (COMM_RMAP_REGCLK_TRCNT_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 20));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107ecc:	e0bfff17 	ldw	r2,-4(fp)
81107ed0:	10800017 	ldw	r2,0(r2)
81107ed4:	e1bffe17 	ldw	r6,-8(fp)
81107ed8:	01401004 	movi	r5,64
81107edc:	1009883a 	mov	r4,r2
81107ee0:	1109ea40 	call	81109ea4 <vRmapWriteReg>
		COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config;
81107ee4:	e0bfff17 	ldw	r2,-4(fp)
81107ee8:	10801317 	ldw	r2,76(r2)
81107eec:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_SL_RDOUT_PAUSE_CNT_MSK);
//			uliReg |= (COMM_RMAP_SL_RDOUT_PAUSE_CNT_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107ef0:	e0bfff17 	ldw	r2,-4(fp)
81107ef4:	10800017 	ldw	r2,0(r2)
81107ef8:	e1bffe17 	ldw	r6,-8(fp)
81107efc:	01401044 	movi	r5,65
81107f00:	1009883a 	mov	r4,r2
81107f04:	1109ea40 	call	81109ea4 <vRmapWriteReg>
		COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SPW_PKT_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config;
81107f08:	e0bfff17 	ldw	r2,-4(fp)
81107f0c:	10801417 	ldw	r2,80(r2)
81107f10:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_DIGITISE_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
//			uliReg &= (~COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK);
//			uliReg |= (COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
//			uliReg &= (~COMM_RMAP_PACKET_SIZE_CTRL_MSK);
//			uliReg |= (COMM_RMAP_PACKET_SIZE_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107f14:	e0bfff17 	ldw	r2,-4(fp)
81107f18:	10800017 	ldw	r2,0(r2)
81107f1c:	e1bffe17 	ldw	r6,-8(fp)
81107f20:	01401084 	movi	r5,66
81107f24:	1009883a 	mov	r4,r2
81107f28:	1109ea40 	call	81109ea4 <vRmapWriteReg>
		COMM_RMAP_SPW_PKT_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SPW_PKT_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSpwPacket2Config;
81107f2c:	e0bfff17 	ldw	r2,-4(fp)
81107f30:	10801517 	ldw	r2,84(r2)
81107f34:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107f38:	e0bfff17 	ldw	r2,-4(fp)
81107f3c:	10800017 	ldw	r2,0(r2)
81107f40:	e1bffe17 	ldw	r6,-8(fp)
81107f44:	014010c4 	movi	r5,67
81107f48:	1009883a 	mov	r4,r2
81107f4c:	1109ea40 	call	81109ea4 <vRmapWriteReg>
		COMM_RMAP_SPW_PKT_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_1_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
81107f50:	e0bfff17 	ldw	r2,-4(fp)
81107f54:	10802217 	ldw	r2,136(r2)
81107f58:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107f5c:	e0bfff17 	ldw	r2,-4(fp)
81107f60:	10800017 	ldw	r2,0(r2)
81107f64:	e1bffe17 	ldw	r6,-8(fp)
81107f68:	01401104 	movi	r5,68
81107f6c:	1009883a 	mov	r4,r2
81107f70:	1109ea40 	call	81109ea4 <vRmapWriteReg>
		COMM_RMAP_CCD_1_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_1_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config;
81107f74:	e0bfff17 	ldw	r2,-4(fp)
81107f78:	10801717 	ldw	r2,92(r2)
81107f7c:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107f80:	e0bfff17 	ldw	r2,-4(fp)
81107f84:	10800017 	ldw	r2,0(r2)
81107f88:	e1bffe17 	ldw	r6,-8(fp)
81107f8c:	01401144 	movi	r5,69
81107f90:	1009883a 	mov	r4,r2
81107f94:	1109ea40 	call	81109ea4 <vRmapWriteReg>
		COMM_RMAP_CCD_1_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_2_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config;
81107f98:	e0bfff17 	ldw	r2,-4(fp)
81107f9c:	10801817 	ldw	r2,96(r2)
81107fa0:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107fa4:	e0bfff17 	ldw	r2,-4(fp)
81107fa8:	10800017 	ldw	r2,0(r2)
81107fac:	e1bffe17 	ldw	r6,-8(fp)
81107fb0:	01401184 	movi	r5,70
81107fb4:	1009883a 	mov	r4,r2
81107fb8:	1109ea40 	call	81109ea4 <vRmapWriteReg>
		COMM_RMAP_CCD_2_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_2_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config;
81107fbc:	e0bfff17 	ldw	r2,-4(fp)
81107fc0:	10801917 	ldw	r2,100(r2)
81107fc4:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107fc8:	e0bfff17 	ldw	r2,-4(fp)
81107fcc:	10800017 	ldw	r2,0(r2)
81107fd0:	e1bffe17 	ldw	r6,-8(fp)
81107fd4:	014011c4 	movi	r5,71
81107fd8:	1009883a 	mov	r4,r2
81107fdc:	1109ea40 	call	81109ea4 <vRmapWriteReg>
		COMM_RMAP_CCD_2_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_3_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config;
81107fe0:	e0bfff17 	ldw	r2,-4(fp)
81107fe4:	10801a17 	ldw	r2,104(r2)
81107fe8:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107fec:	e0bfff17 	ldw	r2,-4(fp)
81107ff0:	10800017 	ldw	r2,0(r2)
81107ff4:	e1bffe17 	ldw	r6,-8(fp)
81107ff8:	01401204 	movi	r5,72
81107ffc:	1009883a 	mov	r4,r2
81108000:	1109ea40 	call	81109ea4 <vRmapWriteReg>
		COMM_RMAP_CCD_3_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_3_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config;
81108004:	e0bfff17 	ldw	r2,-4(fp)
81108008:	10801b17 	ldw	r2,108(r2)
8110800c:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81108010:	e0bfff17 	ldw	r2,-4(fp)
81108014:	10800017 	ldw	r2,0(r2)
81108018:	e1bffe17 	ldw	r6,-8(fp)
8110801c:	01401244 	movi	r5,73
81108020:	1009883a 	mov	r4,r2
81108024:	1109ea40 	call	81109ea4 <vRmapWriteReg>
		COMM_RMAP_CCD_3_W_2_CFG_REG_OFST, uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108028:	e0bfff17 	ldw	r2,-4(fp)
8110802c:	10800017 	ldw	r2,0(r2)
81108030:	01401284 	movi	r5,74
81108034:	1009883a 	mov	r4,r2
81108038:	1109ef80 	call	81109ef8 <uliRmapReadReg>
8110803c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config;
81108040:	e0bfff17 	ldw	r2,-4(fp)
81108044:	10801c17 	ldw	r2,112(r2)
81108048:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
8110804c:	e0bfff17 	ldw	r2,-4(fp)
81108050:	10800017 	ldw	r2,0(r2)
81108054:	e1bffe17 	ldw	r6,-8(fp)
81108058:	01401284 	movi	r5,74
8110805c:	1009883a 	mov	r4,r2
81108060:	1109ea40 	call	81109ea4 <vRmapWriteReg>
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_4_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config;
81108064:	e0bfff17 	ldw	r2,-4(fp)
81108068:	10801d17 	ldw	r2,116(r2)
8110806c:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81108070:	e0bfff17 	ldw	r2,-4(fp)
81108074:	10800017 	ldw	r2,0(r2)
81108078:	e1bffe17 	ldw	r6,-8(fp)
8110807c:	014012c4 	movi	r5,75
81108080:	1009883a 	mov	r4,r2
81108084:	1109ea40 	call	81109ea4 <vRmapWriteReg>
		COMM_RMAP_CCD_4_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_OP_MODE_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig;
81108088:	e0bfff17 	ldw	r2,-4(fp)
8110808c:	10801e17 	ldw	r2,120(r2)
81108090:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_MODE_SEL_CTRL_MSK);
//			uliReg |= (COMM_RMAP_MODE_SEL_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_OP_MODE_CFG_REG_OFST,
81108094:	e0bfff17 	ldw	r2,-4(fp)
81108098:	10800017 	ldw	r2,0(r2)
8110809c:	e1bffe17 	ldw	r6,-8(fp)
811080a0:	01401304 	movi	r5,76
811080a4:	1009883a 	mov	r4,r2
811080a8:	1109ea40 	call	81109ea4 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SYNC_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSyncConfig;
811080ac:	e0bfff17 	ldw	r2,-4(fp)
811080b0:	10801f17 	ldw	r2,124(r2)
811080b4:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_SYNC_CFG_MSK);
//			uliReg |= (COMM_RMAP_SYNC_CFG_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSyncConfig. << 0));
//			uliReg &= (~COMM_RMAP_SELF_TRIGGER_CTRL_MSK);
//			uliReg |= (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSyncConfig. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SYNC_CFG_REG_OFST,
811080b8:	e0bfff17 	ldw	r2,-4(fp)
811080bc:	10800017 	ldw	r2,0(r2)
811080c0:	e1bffe17 	ldw	r6,-8(fp)
811080c4:	01401344 	movi	r5,77
811080c8:	1009883a 	mov	r4,r2
811080cc:	1109ea40 	call	81109ea4 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_DAC_CTRL_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliDacControl;
811080d0:	e0bfff17 	ldw	r2,-4(fp)
811080d4:	10802017 	ldw	r2,128(r2)
811080d8:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_DAC_CTRL_REG_OFST,
811080dc:	e0bfff17 	ldw	r2,-4(fp)
811080e0:	10800017 	ldw	r2,0(r2)
811080e4:	e1bffe17 	ldw	r6,-8(fp)
811080e8:	01401384 	movi	r5,78
811080ec:	1009883a 	mov	r4,r2
811080f0:	1109ea40 	call	81109ea4 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CLK_SRCE_CTRL_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
811080f4:	e0bfff17 	ldw	r2,-4(fp)
811080f8:	10802217 	ldw	r2,136(r2)
811080fc:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81108100:	e0bfff17 	ldw	r2,-4(fp)
81108104:	10800017 	ldw	r2,0(r2)
81108108:	e1bffe17 	ldw	r6,-8(fp)
8110810c:	014013c4 	movi	r5,79
81108110:	1009883a 	mov	r4,r2
81108114:	1109ea40 	call	81109ea4 <vRmapWriteReg>
		COMM_RMAP_CLK_SRCE_CTRL_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_FRAME_NUMBER_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
81108118:	e0bfff17 	ldw	r2,-4(fp)
8110811c:	10802217 	ldw	r2,136(r2)
81108120:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_FRAME_NUMBER_MSK);
//			uliReg |= (COMM_RMAP_FRAME_NUMBER_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliFrameNumber. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_FRAME_NUMBER_REG_OFST,
81108124:	e0bfff17 	ldw	r2,-4(fp)
81108128:	10800017 	ldw	r2,0(r2)
8110812c:	e1bffe17 	ldw	r6,-8(fp)
81108130:	01401404 	movi	r5,80
81108134:	1009883a 	mov	r4,r2
81108138:	1109ea40 	call	81109ea4 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CURRENT_MODE_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCurrentMode;
8110813c:	e0bfff17 	ldw	r2,-4(fp)
81108140:	10802317 	ldw	r2,140(r2)
81108144:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_CURRENT_MODE_MSK);
//			uliReg |= (COMM_RMAP_CURRENT_MODE_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCurrentMode. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CURRENT_MODE_REG_OFST,
81108148:	e0bfff17 	ldw	r2,-4(fp)
8110814c:	10800017 	ldw	r2,0(r2)
81108150:	e1bffe17 	ldw	r6,-8(fp)
81108154:	01401444 	movi	r5,81
81108158:	1009883a 	mov	r4,r2
8110815c:	1109ea40 	call	81109ea4 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
81108160:	00800044 	movi	r2,1
81108164:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81108168:	e0bffd17 	ldw	r2,-12(fp)
}
8110816c:	e037883a 	mov	sp,fp
81108170:	dfc00117 	ldw	ra,4(sp)
81108174:	df000017 	ldw	fp,0(sp)
81108178:	dec00204 	addi	sp,sp,8
8110817c:	f800283a 	ret

81108180 <bRmapGetMemConfigArea>:

bool bRmapGetMemConfigArea(TRmapChannel *pxRmapCh) {
81108180:	defffb04 	addi	sp,sp,-20
81108184:	de00012e 	bgeu	sp,et,8110818c <bRmapGetMemConfigArea+0xc>
81108188:	003b68fa 	trap	3
8110818c:	dfc00415 	stw	ra,16(sp)
81108190:	df000315 	stw	fp,12(sp)
81108194:	df000304 	addi	fp,sp,12
81108198:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110819c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811081a0:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
811081a4:	e0bfff17 	ldw	r2,-4(fp)
811081a8:	1000a426 	beq	r2,zero,8110843c <bRmapGetMemConfigArea+0x2bc>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811081ac:	e0bfff17 	ldw	r2,-4(fp)
811081b0:	10800017 	ldw	r2,0(r2)
811081b4:	01401004 	movi	r5,64
811081b8:	1009883a 	mov	r4,r2
811081bc:	1109ef80 	call	81109ef8 <uliRmapReadReg>
811081c0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config = uliReg;
811081c4:	e0bfff17 	ldw	r2,-4(fp)
811081c8:	e0fffe17 	ldw	r3,-8(fp)
811081cc:	10c01215 	stw	r3,72(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811081d0:	e0bfff17 	ldw	r2,-4(fp)
811081d4:	10800017 	ldw	r2,0(r2)
811081d8:	01401044 	movi	r5,65
811081dc:	1009883a 	mov	r4,r2
811081e0:	1109ef80 	call	81109ef8 <uliRmapReadReg>
811081e4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config = uliReg;
811081e8:	e0bfff17 	ldw	r2,-4(fp)
811081ec:	e0fffe17 	ldw	r3,-8(fp)
811081f0:	10c01315 	stw	r3,76(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811081f4:	e0bfff17 	ldw	r2,-4(fp)
811081f8:	10800017 	ldw	r2,0(r2)
811081fc:	01401084 	movi	r5,66
81108200:	1009883a 	mov	r4,r2
81108204:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81108208:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SPW_PKT_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config = uliReg;
8110820c:	e0bfff17 	ldw	r2,-4(fp)
81108210:	e0fffe17 	ldw	r3,-8(fp)
81108214:	10c01415 	stw	r3,80(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108218:	e0bfff17 	ldw	r2,-4(fp)
8110821c:	10800017 	ldw	r2,0(r2)
81108220:	014010c4 	movi	r5,67
81108224:	1009883a 	mov	r4,r2
81108228:	1109ef80 	call	81109ef8 <uliRmapReadReg>
8110822c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SPW_PKT_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSpwPacket2Config = uliReg;
81108230:	e0bfff17 	ldw	r2,-4(fp)
81108234:	e0fffe17 	ldw	r3,-8(fp)
81108238:	10c01515 	stw	r3,84(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110823c:	e0bfff17 	ldw	r2,-4(fp)
81108240:	10800017 	ldw	r2,0(r2)
81108244:	01401104 	movi	r5,68
81108248:	1009883a 	mov	r4,r2
8110824c:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81108250:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_1_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
81108254:	e0bfff17 	ldw	r2,-4(fp)
81108258:	e0fffe17 	ldw	r3,-8(fp)
8110825c:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108260:	e0bfff17 	ldw	r2,-4(fp)
81108264:	10800017 	ldw	r2,0(r2)
81108268:	01401144 	movi	r5,69
8110826c:	1009883a 	mov	r4,r2
81108270:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81108274:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_1_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config = uliReg;
81108278:	e0bfff17 	ldw	r2,-4(fp)
8110827c:	e0fffe17 	ldw	r3,-8(fp)
81108280:	10c01715 	stw	r3,92(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108284:	e0bfff17 	ldw	r2,-4(fp)
81108288:	10800017 	ldw	r2,0(r2)
8110828c:	01401184 	movi	r5,70
81108290:	1009883a 	mov	r4,r2
81108294:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81108298:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_2_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config = uliReg;
8110829c:	e0bfff17 	ldw	r2,-4(fp)
811082a0:	e0fffe17 	ldw	r3,-8(fp)
811082a4:	10c01815 	stw	r3,96(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811082a8:	e0bfff17 	ldw	r2,-4(fp)
811082ac:	10800017 	ldw	r2,0(r2)
811082b0:	014011c4 	movi	r5,71
811082b4:	1009883a 	mov	r4,r2
811082b8:	1109ef80 	call	81109ef8 <uliRmapReadReg>
811082bc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_2_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config = uliReg;
811082c0:	e0bfff17 	ldw	r2,-4(fp)
811082c4:	e0fffe17 	ldw	r3,-8(fp)
811082c8:	10c01915 	stw	r3,100(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811082cc:	e0bfff17 	ldw	r2,-4(fp)
811082d0:	10800017 	ldw	r2,0(r2)
811082d4:	01401204 	movi	r5,72
811082d8:	1009883a 	mov	r4,r2
811082dc:	1109ef80 	call	81109ef8 <uliRmapReadReg>
811082e0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_3_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config = uliReg;
811082e4:	e0bfff17 	ldw	r2,-4(fp)
811082e8:	e0fffe17 	ldw	r3,-8(fp)
811082ec:	10c01a15 	stw	r3,104(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811082f0:	e0bfff17 	ldw	r2,-4(fp)
811082f4:	10800017 	ldw	r2,0(r2)
811082f8:	01401244 	movi	r5,73
811082fc:	1009883a 	mov	r4,r2
81108300:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81108304:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_3_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config = uliReg;
81108308:	e0bfff17 	ldw	r2,-4(fp)
8110830c:	e0fffe17 	ldw	r3,-8(fp)
81108310:	10c01b15 	stw	r3,108(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108314:	e0bfff17 	ldw	r2,-4(fp)
81108318:	10800017 	ldw	r2,0(r2)
8110831c:	01401284 	movi	r5,74
81108320:	1009883a 	mov	r4,r2
81108324:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81108328:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config = uliReg;
8110832c:	e0bfff17 	ldw	r2,-4(fp)
81108330:	e0fffe17 	ldw	r3,-8(fp)
81108334:	10c01c15 	stw	r3,112(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108338:	e0bfff17 	ldw	r2,-4(fp)
8110833c:	10800017 	ldw	r2,0(r2)
81108340:	014012c4 	movi	r5,75
81108344:	1009883a 	mov	r4,r2
81108348:	1109ef80 	call	81109ef8 <uliRmapReadReg>
8110834c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config = uliReg;
81108350:	e0bfff17 	ldw	r2,-4(fp)
81108354:	e0fffe17 	ldw	r3,-8(fp)
81108358:	10c01d15 	stw	r3,116(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110835c:	e0bfff17 	ldw	r2,-4(fp)
81108360:	10800017 	ldw	r2,0(r2)
81108364:	01401304 	movi	r5,76
81108368:	1009883a 	mov	r4,r2
8110836c:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81108370:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_OP_MODE_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig = uliReg;
81108374:	e0bfff17 	ldw	r2,-4(fp)
81108378:	e0fffe17 	ldw	r3,-8(fp)
8110837c:	10c01e15 	stw	r3,120(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108380:	e0bfff17 	ldw	r2,-4(fp)
81108384:	10800017 	ldw	r2,0(r2)
81108388:	01401344 	movi	r5,77
8110838c:	1009883a 	mov	r4,r2
81108390:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81108394:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SYNC_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSyncConfig = uliReg;
81108398:	e0bfff17 	ldw	r2,-4(fp)
8110839c:	e0fffe17 	ldw	r3,-8(fp)
811083a0:	10c01f15 	stw	r3,124(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811083a4:	e0bfff17 	ldw	r2,-4(fp)
811083a8:	10800017 	ldw	r2,0(r2)
811083ac:	01401384 	movi	r5,78
811083b0:	1009883a 	mov	r4,r2
811083b4:	1109ef80 	call	81109ef8 <uliRmapReadReg>
811083b8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_DAC_CTRL_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliDacControl = uliReg;
811083bc:	e0bfff17 	ldw	r2,-4(fp)
811083c0:	e0fffe17 	ldw	r3,-8(fp)
811083c4:	10c02015 	stw	r3,128(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811083c8:	e0bfff17 	ldw	r2,-4(fp)
811083cc:	10800017 	ldw	r2,0(r2)
811083d0:	014013c4 	movi	r5,79
811083d4:	1009883a 	mov	r4,r2
811083d8:	1109ef80 	call	81109ef8 <uliRmapReadReg>
811083dc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CLK_SRCE_CTRL_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
811083e0:	e0bfff17 	ldw	r2,-4(fp)
811083e4:	e0fffe17 	ldw	r3,-8(fp)
811083e8:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811083ec:	e0bfff17 	ldw	r2,-4(fp)
811083f0:	10800017 	ldw	r2,0(r2)
811083f4:	01401404 	movi	r5,80
811083f8:	1009883a 	mov	r4,r2
811083fc:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81108400:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_FRAME_NUMBER_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
81108404:	e0bfff17 	ldw	r2,-4(fp)
81108408:	e0fffe17 	ldw	r3,-8(fp)
8110840c:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108410:	e0bfff17 	ldw	r2,-4(fp)
81108414:	10800017 	ldw	r2,0(r2)
81108418:	01401444 	movi	r5,81
8110841c:	1009883a 	mov	r4,r2
81108420:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81108424:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CURRENT_MODE_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCurrentMode = uliReg;
81108428:	e0bfff17 	ldw	r2,-4(fp)
8110842c:	e0fffe17 	ldw	r3,-8(fp)
81108430:	10c02315 	stw	r3,140(r2)

		bStatus = TRUE;
81108434:	00800044 	movi	r2,1
81108438:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110843c:	e0bffd17 	ldw	r2,-12(fp)
}
81108440:	e037883a 	mov	sp,fp
81108444:	dfc00117 	ldw	ra,4(sp)
81108448:	df000017 	ldw	fp,0(sp)
8110844c:	dec00204 	addi	sp,sp,8
81108450:	f800283a 	ret

81108454 <bRmapGetMemConfigStat>:

bool bRmapGetMemConfigStat(TRmapChannel *pxRmapCh) {
81108454:	defffb04 	addi	sp,sp,-20
81108458:	de00012e 	bgeu	sp,et,81108460 <bRmapGetMemConfigStat+0xc>
8110845c:	003b68fa 	trap	3
81108460:	dfc00415 	stw	ra,16(sp)
81108464:	df000315 	stw	fp,12(sp)
81108468:	df000304 	addi	fp,sp,12
8110846c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81108470:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81108474:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81108478:	e0bfff17 	ldw	r2,-4(fp)
8110847c:	10001426 	beq	r2,zero,811084d0 <bRmapGetMemConfigStat+0x7c>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108480:	e0bfff17 	ldw	r2,-4(fp)
81108484:	10800017 	ldw	r2,0(r2)
81108488:	014001c4 	movi	r5,7
8110848c:	1009883a 	mov	r4,r2
81108490:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81108494:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_LST_RD_ADDR_REG_OFST);

		pxRmapCh->xRmapMemConfigStat.uliLastReadAddress = (alt_u32) ((uliReg
81108498:	e0bfff17 	ldw	r2,-4(fp)
8110849c:	e0fffe17 	ldw	r3,-8(fp)
811084a0:	10c02515 	stw	r3,148(r2)
				& COMM_RMAP_LST_RD_ADDR_MSK) >> 0);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811084a4:	e0bfff17 	ldw	r2,-4(fp)
811084a8:	10800017 	ldw	r2,0(r2)
811084ac:	01400184 	movi	r5,6
811084b0:	1009883a 	mov	r4,r2
811084b4:	1109ef80 	call	81109ef8 <uliRmapReadReg>
811084b8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_LST_WR_ADDR_REG_OFST);

		pxRmapCh->xRmapMemConfigStat.uliLastWriteAddress = (alt_u32) ((uliReg
811084bc:	e0bfff17 	ldw	r2,-4(fp)
811084c0:	e0fffe17 	ldw	r3,-8(fp)
811084c4:	10c02415 	stw	r3,144(r2)
				& COMM_RMAP_LST_WR_ADDR_MSK) >> 0);

		bStatus = TRUE;
811084c8:	00800044 	movi	r2,1
811084cc:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811084d0:	e0bffd17 	ldw	r2,-12(fp)
}
811084d4:	e037883a 	mov	sp,fp
811084d8:	dfc00117 	ldw	ra,4(sp)
811084dc:	df000017 	ldw	fp,0(sp)
811084e0:	dec00204 	addi	sp,sp,8
811084e4:	f800283a 	ret

811084e8 <bRmapSetRmapMemHKArea>:

bool bRmapSetRmapMemHKArea(TRmapChannel *pxRmapCh) {
811084e8:	defffb04 	addi	sp,sp,-20
811084ec:	de00012e 	bgeu	sp,et,811084f4 <bRmapSetRmapMemHKArea+0xc>
811084f0:	003b68fa 	trap	3
811084f4:	dfc00415 	stw	ra,16(sp)
811084f8:	df000315 	stw	fp,12(sp)
811084fc:	df000304 	addi	fp,sp,12
81108500:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81108504:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81108508:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
8110850c:	e0bfff17 	ldw	r2,-4(fp)
81108510:	10040226 	beq	r2,zero,8110951c <bRmapSetRmapMemHKArea+0x1034>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108514:	e0bfff17 	ldw	r2,-4(fp)
81108518:	10800017 	ldw	r2,0(r2)
8110851c:	01402804 	movi	r5,160
81108520:	1009883a 	mov	r4,r2
81108524:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81108528:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
8110852c:	e0bffe17 	ldw	r2,-8(fp)
81108530:	10bfffec 	andhi	r2,r2,65535
81108534:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
81108538:	e0bfff17 	ldw	r2,-4(fp)
8110853c:	1080260b 	ldhu	r2,152(r2)
81108540:	10bfffcc 	andi	r2,r2,65535
	if (pxRmapCh != NULL) {

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
81108544:	e0fffe17 	ldw	r3,-8(fp)
81108548:	1884b03a 	or	r2,r3,r2
8110854c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_F_MSK);
81108550:	e0bffe17 	ldw	r2,-8(fp)
81108554:	10bfffcc 	andi	r2,r2,65535
81108558:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF << 16));
8110855c:	e0bfff17 	ldw	r2,-4(fp)
81108560:	1080268b 	ldhu	r2,154(r2)
81108564:	10bfffcc 	andi	r2,r2,65535
81108568:	1004943a 	slli	r2,r2,16
8110856c:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_F_MSK
81108570:	e0bffe17 	ldw	r2,-8(fp)
81108574:	10c4b03a 	or	r2,r2,r3
81108578:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_0_REG_OFST,
8110857c:	e0bfff17 	ldw	r2,-4(fp)
81108580:	10800017 	ldw	r2,0(r2)
81108584:	e1bffe17 	ldw	r6,-8(fp)
81108588:	01402804 	movi	r5,160
8110858c:	1009883a 	mov	r4,r2
81108590:	1109ea40 	call	81109ea4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108594:	e0bfff17 	ldw	r2,-4(fp)
81108598:	10800017 	ldw	r2,0(r2)
8110859c:	01402844 	movi	r5,161
811085a0:	1009883a 	mov	r4,r2
811085a4:	1109ef80 	call	81109ef8 <uliRmapReadReg>
811085a8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
811085ac:	e0bffe17 	ldw	r2,-8(fp)
811085b0:	10bfffec 	andhi	r2,r2,65535
811085b4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
811085b8:	e0bfff17 	ldw	r2,-4(fp)
811085bc:	1080270b 	ldhu	r2,156(r2)
811085c0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
811085c4:	e0fffe17 	ldw	r3,-8(fp)
811085c8:	1884b03a 	or	r2,r3,r2
811085cc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_E_MSK);
811085d0:	e0bffe17 	ldw	r2,-8(fp)
811085d4:	10bfffcc 	andi	r2,r2,65535
811085d8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE << 16));
811085dc:	e0bfff17 	ldw	r2,-4(fp)
811085e0:	1080278b 	ldhu	r2,158(r2)
811085e4:	10bfffcc 	andi	r2,r2,65535
811085e8:	1004943a 	slli	r2,r2,16
811085ec:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_E_MSK
811085f0:	e0bffe17 	ldw	r2,-8(fp)
811085f4:	10c4b03a 	or	r2,r2,r3
811085f8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_1_REG_OFST,
811085fc:	e0bfff17 	ldw	r2,-4(fp)
81108600:	10800017 	ldw	r2,0(r2)
81108604:	e1bffe17 	ldw	r6,-8(fp)
81108608:	01402844 	movi	r5,161
8110860c:	1009883a 	mov	r4,r2
81108610:	1109ea40 	call	81109ea4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108614:	e0bfff17 	ldw	r2,-4(fp)
81108618:	10800017 	ldw	r2,0(r2)
8110861c:	01402884 	movi	r5,162
81108620:	1009883a 	mov	r4,r2
81108624:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81108628:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
8110862c:	e0bffe17 	ldw	r2,-8(fp)
81108630:	10bfffec 	andhi	r2,r2,65535
81108634:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
81108638:	e0bfff17 	ldw	r2,-4(fp)
8110863c:	1080280b 	ldhu	r2,160(r2)
81108640:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
81108644:	e0fffe17 	ldw	r3,-8(fp)
81108648:	1884b03a 	or	r2,r3,r2
8110864c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VRD_MON_MSK);
81108650:	e0bffe17 	ldw	r2,-8(fp)
81108654:	10bfffcc 	andi	r2,r2,65535
81108658:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon << 16));
8110865c:	e0bfff17 	ldw	r2,-4(fp)
81108660:	1080288b 	ldhu	r2,162(r2)
81108664:	10bfffcc 	andi	r2,r2,65535
81108668:	1004943a 	slli	r2,r2,16
8110866c:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VRD_MON_MSK
81108670:	e0bffe17 	ldw	r2,-8(fp)
81108674:	10c4b03a 	or	r2,r2,r3
81108678:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_2_REG_OFST,
8110867c:	e0bfff17 	ldw	r2,-4(fp)
81108680:	10800017 	ldw	r2,0(r2)
81108684:	e1bffe17 	ldw	r6,-8(fp)
81108688:	01402884 	movi	r5,162
8110868c:	1009883a 	mov	r4,r2
81108690:	1109ea40 	call	81109ea4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108694:	e0bfff17 	ldw	r2,-4(fp)
81108698:	10800017 	ldw	r2,0(r2)
8110869c:	014028c4 	movi	r5,163
811086a0:	1009883a 	mov	r4,r2
811086a4:	1109ef80 	call	81109ef8 <uliRmapReadReg>
811086a8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
811086ac:	e0bffe17 	ldw	r2,-8(fp)
811086b0:	10bfffec 	andhi	r2,r2,65535
811086b4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
811086b8:	e0bfff17 	ldw	r2,-4(fp)
811086bc:	1080290b 	ldhu	r2,164(r2)
811086c0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
811086c4:	e0fffe17 	ldw	r3,-8(fp)
811086c8:	1884b03a 	or	r2,r3,r2
811086cc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_F_MSK);
811086d0:	e0bffe17 	ldw	r2,-8(fp)
811086d4:	10bfffcc 	andi	r2,r2,65535
811086d8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF << 16));
811086dc:	e0bfff17 	ldw	r2,-4(fp)
811086e0:	1080298b 	ldhu	r2,166(r2)
811086e4:	10bfffcc 	andi	r2,r2,65535
811086e8:	1004943a 	slli	r2,r2,16
811086ec:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_F_MSK
811086f0:	e0bffe17 	ldw	r2,-8(fp)
811086f4:	10c4b03a 	or	r2,r2,r3
811086f8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_3_REG_OFST,
811086fc:	e0bfff17 	ldw	r2,-4(fp)
81108700:	10800017 	ldw	r2,0(r2)
81108704:	e1bffe17 	ldw	r6,-8(fp)
81108708:	014028c4 	movi	r5,163
8110870c:	1009883a 	mov	r4,r2
81108710:	1109ea40 	call	81109ea4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108714:	e0bfff17 	ldw	r2,-4(fp)
81108718:	10800017 	ldw	r2,0(r2)
8110871c:	01402904 	movi	r5,164
81108720:	1009883a 	mov	r4,r2
81108724:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81108728:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
8110872c:	e0bffe17 	ldw	r2,-8(fp)
81108730:	10bfffec 	andhi	r2,r2,65535
81108734:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
81108738:	e0bfff17 	ldw	r2,-4(fp)
8110873c:	10802a0b 	ldhu	r2,168(r2)
81108740:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
81108744:	e0fffe17 	ldw	r3,-8(fp)
81108748:	1884b03a 	or	r2,r3,r2
8110874c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_E_MSK);
81108750:	e0bffe17 	ldw	r2,-8(fp)
81108754:	10bfffcc 	andi	r2,r2,65535
81108758:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE << 16));
8110875c:	e0bfff17 	ldw	r2,-4(fp)
81108760:	10802a8b 	ldhu	r2,170(r2)
81108764:	10bfffcc 	andi	r2,r2,65535
81108768:	1004943a 	slli	r2,r2,16
8110876c:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_E_MSK
81108770:	e0bffe17 	ldw	r2,-8(fp)
81108774:	10c4b03a 	or	r2,r2,r3
81108778:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_4_REG_OFST,
8110877c:	e0bfff17 	ldw	r2,-4(fp)
81108780:	10800017 	ldw	r2,0(r2)
81108784:	e1bffe17 	ldw	r6,-8(fp)
81108788:	01402904 	movi	r5,164
8110878c:	1009883a 	mov	r4,r2
81108790:	1109ea40 	call	81109ea4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108794:	e0bfff17 	ldw	r2,-4(fp)
81108798:	10800017 	ldw	r2,0(r2)
8110879c:	01402944 	movi	r5,165
811087a0:	1009883a 	mov	r4,r2
811087a4:	1109ef80 	call	81109ef8 <uliRmapReadReg>
811087a8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
811087ac:	e0bffe17 	ldw	r2,-8(fp)
811087b0:	10bfffec 	andhi	r2,r2,65535
811087b4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
811087b8:	e0bfff17 	ldw	r2,-4(fp)
811087bc:	10802b0b 	ldhu	r2,172(r2)
811087c0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
811087c4:	e0fffe17 	ldw	r3,-8(fp)
811087c8:	1884b03a 	or	r2,r3,r2
811087cc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VRD_MON_MSK);
811087d0:	e0bffe17 	ldw	r2,-8(fp)
811087d4:	10bfffcc 	andi	r2,r2,65535
811087d8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon << 16));
811087dc:	e0bfff17 	ldw	r2,-4(fp)
811087e0:	10802b8b 	ldhu	r2,174(r2)
811087e4:	10bfffcc 	andi	r2,r2,65535
811087e8:	1004943a 	slli	r2,r2,16
811087ec:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VRD_MON_MSK
811087f0:	e0bffe17 	ldw	r2,-8(fp)
811087f4:	10c4b03a 	or	r2,r2,r3
811087f8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_5_REG_OFST,
811087fc:	e0bfff17 	ldw	r2,-4(fp)
81108800:	10800017 	ldw	r2,0(r2)
81108804:	e1bffe17 	ldw	r6,-8(fp)
81108808:	01402944 	movi	r5,165
8110880c:	1009883a 	mov	r4,r2
81108810:	1109ea40 	call	81109ea4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108814:	e0bfff17 	ldw	r2,-4(fp)
81108818:	10800017 	ldw	r2,0(r2)
8110881c:	01402984 	movi	r5,166
81108820:	1009883a 	mov	r4,r2
81108824:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81108828:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
8110882c:	e0bffe17 	ldw	r2,-8(fp)
81108830:	10bfffec 	andhi	r2,r2,65535
81108834:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
81108838:	e0bfff17 	ldw	r2,-4(fp)
8110883c:	10802c0b 	ldhu	r2,176(r2)
81108840:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
81108844:	e0fffe17 	ldw	r3,-8(fp)
81108848:	1884b03a 	or	r2,r3,r2
8110884c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_MSK);
81108850:	e0bffe17 	ldw	r2,-8(fp)
81108854:	10bfffcc 	andi	r2,r2,65535
81108858:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VRCLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclk << 16));
8110885c:	e0bfff17 	ldw	r2,-4(fp)
81108860:	10802c8b 	ldhu	r2,178(r2)
81108864:	10bfffcc 	andi	r2,r2,65535
81108868:	1004943a 	slli	r2,r2,16
8110886c:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_MSK);
		uliReg |= (COMM_RMAP_HK_VRCLK_MSK
81108870:	e0bffe17 	ldw	r2,-8(fp)
81108874:	10c4b03a 	or	r2,r2,r3
81108878:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclk << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_6_REG_OFST,
8110887c:	e0bfff17 	ldw	r2,-4(fp)
81108880:	10800017 	ldw	r2,0(r2)
81108884:	e1bffe17 	ldw	r6,-8(fp)
81108888:	01402984 	movi	r5,166
8110888c:	1009883a 	mov	r4,r2
81108890:	1109ea40 	call	81109ea4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108894:	e0bfff17 	ldw	r2,-4(fp)
81108898:	10800017 	ldw	r2,0(r2)
8110889c:	014029c4 	movi	r5,167
811088a0:	1009883a 	mov	r4,r2
811088a4:	1109ef80 	call	81109ef8 <uliRmapReadReg>
811088a8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
811088ac:	e0bffe17 	ldw	r2,-8(fp)
811088b0:	10bfffec 	andhi	r2,r2,65535
811088b4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
811088b8:	e0bfff17 	ldw	r2,-4(fp)
811088bc:	10802d0b 	ldhu	r2,180(r2)
811088c0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
811088c4:	e0fffe17 	ldw	r3,-8(fp)
811088c8:	1884b03a 	or	r2,r3,r2
811088cc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_LOW_MSK);
811088d0:	e0bffe17 	ldw	r2,-8(fp)
811088d4:	10bfffcc 	andi	r2,r2,65535
811088d8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VRCLK_LOW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclkLow << 16));
811088dc:	e0bfff17 	ldw	r2,-4(fp)
811088e0:	10802d8b 	ldhu	r2,182(r2)
811088e4:	10bfffcc 	andi	r2,r2,65535
811088e8:	1004943a 	slli	r2,r2,16
811088ec:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_LOW_MSK);
		uliReg |= (COMM_RMAP_HK_VRCLK_LOW_MSK
811088f0:	e0bffe17 	ldw	r2,-8(fp)
811088f4:	10c4b03a 	or	r2,r2,r3
811088f8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclkLow << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_7_REG_OFST,
811088fc:	e0bfff17 	ldw	r2,-4(fp)
81108900:	10800017 	ldw	r2,0(r2)
81108904:	e1bffe17 	ldw	r6,-8(fp)
81108908:	014029c4 	movi	r5,167
8110890c:	1009883a 	mov	r4,r2
81108910:	1109ea40 	call	81109ea4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108914:	e0bfff17 	ldw	r2,-4(fp)
81108918:	10800017 	ldw	r2,0(r2)
8110891c:	01402a04 	movi	r5,168
81108920:	1009883a 	mov	r4,r2
81108924:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81108928:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
8110892c:	e0bffe17 	ldw	r2,-8(fp)
81108930:	10bfffec 	andhi	r2,r2,65535
81108934:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
81108938:	e0bfff17 	ldw	r2,-4(fp)
8110893c:	10802e0b 	ldhu	r2,184(r2)
81108940:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
81108944:	e0fffe17 	ldw	r3,-8(fp)
81108948:	1884b03a 	or	r2,r3,r2
8110894c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VB_NEG_MSK);
81108950:	e0bffe17 	ldw	r2,-8(fp)
81108954:	10bfffcc 	andi	r2,r2,65535
81108958:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VB_NEG_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbNeg << 16));
8110895c:	e0bfff17 	ldw	r2,-4(fp)
81108960:	10802e8b 	ldhu	r2,186(r2)
81108964:	10bfffcc 	andi	r2,r2,65535
81108968:	1004943a 	slli	r2,r2,16
8110896c:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VB_NEG_MSK);
		uliReg |= (COMM_RMAP_HK_5VB_NEG_MSK
81108970:	e0bffe17 	ldw	r2,-8(fp)
81108974:	10c4b03a 	or	r2,r2,r3
81108978:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbNeg << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_8_REG_OFST,
8110897c:	e0bfff17 	ldw	r2,-4(fp)
81108980:	10800017 	ldw	r2,0(r2)
81108984:	e1bffe17 	ldw	r6,-8(fp)
81108988:	01402a04 	movi	r5,168
8110898c:	1009883a 	mov	r4,r2
81108990:	1109ea40 	call	81109ea4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108994:	e0bfff17 	ldw	r2,-4(fp)
81108998:	10800017 	ldw	r2,0(r2)
8110899c:	01402a44 	movi	r5,169
811089a0:	1009883a 	mov	r4,r2
811089a4:	1109ef80 	call	81109ef8 <uliRmapReadReg>
811089a8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
811089ac:	e0bffe17 	ldw	r2,-8(fp)
811089b0:	10bfffec 	andhi	r2,r2,65535
811089b4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
811089b8:	e0bfff17 	ldw	r2,-4(fp)
811089bc:	10802f0b 	ldhu	r2,188(r2)
811089c0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
811089c4:	e0fffe17 	ldw	r3,-8(fp)
811089c8:	1884b03a 	or	r2,r3,r2
811089cc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VA_POS_MSK);
811089d0:	e0bffe17 	ldw	r2,-8(fp)
811089d4:	10bfffcc 	andi	r2,r2,65535
811089d8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_2_5VA_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vaPos << 16));
811089dc:	e0bfff17 	ldw	r2,-4(fp)
811089e0:	10802f8b 	ldhu	r2,190(r2)
811089e4:	10bfffcc 	andi	r2,r2,65535
811089e8:	1004943a 	slli	r2,r2,16
811089ec:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VA_POS_MSK);
		uliReg |= (COMM_RMAP_HK_2_5VA_POS_MSK
811089f0:	e0bffe17 	ldw	r2,-8(fp)
811089f4:	10c4b03a 	or	r2,r2,r3
811089f8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vaPos << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_9_REG_OFST,
811089fc:	e0bfff17 	ldw	r2,-4(fp)
81108a00:	10800017 	ldw	r2,0(r2)
81108a04:	e1bffe17 	ldw	r6,-8(fp)
81108a08:	01402a44 	movi	r5,169
81108a0c:	1009883a 	mov	r4,r2
81108a10:	1109ea40 	call	81109ea4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108a14:	e0bfff17 	ldw	r2,-4(fp)
81108a18:	10800017 	ldw	r2,0(r2)
81108a1c:	01402a84 	movi	r5,170
81108a20:	1009883a 	mov	r4,r2
81108a24:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81108a28:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
81108a2c:	e0bffe17 	ldw	r2,-8(fp)
81108a30:	10bfffec 	andhi	r2,r2,65535
81108a34:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
81108a38:	e0bfff17 	ldw	r2,-4(fp)
81108a3c:	1080300b 	ldhu	r2,192(r2)
81108a40:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
81108a44:	e0fffe17 	ldw	r3,-8(fp)
81108a48:	1884b03a 	or	r2,r3,r2
81108a4c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VD_POS_MSK);
81108a50:	e0bffe17 	ldw	r2,-8(fp)
81108a54:	10bfffcc 	andi	r2,r2,65535
81108a58:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_2_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vdPos << 16));
81108a5c:	e0bfff17 	ldw	r2,-4(fp)
81108a60:	1080308b 	ldhu	r2,194(r2)
81108a64:	10bfffcc 	andi	r2,r2,65535
81108a68:	1004943a 	slli	r2,r2,16
81108a6c:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_2_5VD_POS_MSK
81108a70:	e0bffe17 	ldw	r2,-8(fp)
81108a74:	10c4b03a 	or	r2,r2,r3
81108a78:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vdPos << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_10_REG_OFST,
81108a7c:	e0bfff17 	ldw	r2,-4(fp)
81108a80:	10800017 	ldw	r2,0(r2)
81108a84:	e1bffe17 	ldw	r6,-8(fp)
81108a88:	01402a84 	movi	r5,170
81108a8c:	1009883a 	mov	r4,r2
81108a90:	1109ea40 	call	81109ea4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108a94:	e0bfff17 	ldw	r2,-4(fp)
81108a98:	10800017 	ldw	r2,0(r2)
81108a9c:	01402ac4 	movi	r5,171
81108aa0:	1009883a 	mov	r4,r2
81108aa4:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81108aa8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
81108aac:	e0bffe17 	ldw	r2,-8(fp)
81108ab0:	10bfffec 	andhi	r2,r2,65535
81108ab4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
81108ab8:	e0bfff17 	ldw	r2,-4(fp)
81108abc:	1080310b 	ldhu	r2,196(r2)
81108ac0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
81108ac4:	e0fffe17 	ldw	r3,-8(fp)
81108ac8:	1884b03a 	or	r2,r3,r2
81108acc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VREF_MSK);
81108ad0:	e0bffe17 	ldw	r2,-8(fp)
81108ad4:	10bfffcc 	andi	r2,r2,65535
81108ad8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VREF_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vref << 16));
81108adc:	e0bfff17 	ldw	r2,-4(fp)
81108ae0:	1080318b 	ldhu	r2,198(r2)
81108ae4:	10bfffcc 	andi	r2,r2,65535
81108ae8:	1004943a 	slli	r2,r2,16
81108aec:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VREF_MSK);
		uliReg |= (COMM_RMAP_HK_5VREF_MSK
81108af0:	e0bffe17 	ldw	r2,-8(fp)
81108af4:	10c4b03a 	or	r2,r2,r3
81108af8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vref << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_11_REG_OFST,
81108afc:	e0bfff17 	ldw	r2,-4(fp)
81108b00:	10800017 	ldw	r2,0(r2)
81108b04:	e1bffe17 	ldw	r6,-8(fp)
81108b08:	01402ac4 	movi	r5,171
81108b0c:	1009883a 	mov	r4,r2
81108b10:	1109ea40 	call	81109ea4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108b14:	e0bfff17 	ldw	r2,-4(fp)
81108b18:	10800017 	ldw	r2,0(r2)
81108b1c:	01402b04 	movi	r5,172
81108b20:	1009883a 	mov	r4,r2
81108b24:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81108b28:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
81108b2c:	e0bffe17 	ldw	r2,-8(fp)
81108b30:	10bfffec 	andhi	r2,r2,65535
81108b34:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
81108b38:	e0bfff17 	ldw	r2,-4(fp)
81108b3c:	1080320b 	ldhu	r2,200(r2)
81108b40:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
81108b44:	e0fffe17 	ldw	r3,-8(fp)
81108b48:	1884b03a 	or	r2,r3,r2
81108b4c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VCLK_POS_RAW_MSK);
81108b50:	e0bffe17 	ldw	r2,-8(fp)
81108b54:	10bfffcc 	andi	r2,r2,65535
81108b58:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCLK_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw << 16));
81108b5c:	e0bfff17 	ldw	r2,-4(fp)
81108b60:	1080328b 	ldhu	r2,202(r2)
81108b64:	10bfffcc 	andi	r2,r2,65535
81108b68:	1004943a 	slli	r2,r2,16
81108b6c:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VCLK_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VCLK_POS_RAW_MSK
81108b70:	e0bffe17 	ldw	r2,-8(fp)
81108b74:	10c4b03a 	or	r2,r2,r3
81108b78:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_12_REG_OFST,
81108b7c:	e0bfff17 	ldw	r2,-4(fp)
81108b80:	10800017 	ldw	r2,0(r2)
81108b84:	e1bffe17 	ldw	r6,-8(fp)
81108b88:	01402b04 	movi	r5,172
81108b8c:	1009883a 	mov	r4,r2
81108b90:	1109ea40 	call	81109ea4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108b94:	e0bfff17 	ldw	r2,-4(fp)
81108b98:	10800017 	ldw	r2,0(r2)
81108b9c:	01402b44 	movi	r5,173
81108ba0:	1009883a 	mov	r4,r2
81108ba4:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81108ba8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
81108bac:	e0bffe17 	ldw	r2,-8(fp)
81108bb0:	10bfffec 	andhi	r2,r2,65535
81108bb4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
81108bb8:	e0bfff17 	ldw	r2,-4(fp)
81108bbc:	1080330b 	ldhu	r2,204(r2)
81108bc0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
81108bc4:	e0fffe17 	ldw	r3,-8(fp)
81108bc8:	1884b03a 	or	r2,r3,r2
81108bcc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VAN3_NEG_RAW_MSK);
81108bd0:	e0bffe17 	ldw	r2,-8(fp)
81108bd4:	10bfffcc 	andi	r2,r2,65535
81108bd8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN3_NEG_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw << 16));
81108bdc:	e0bfff17 	ldw	r2,-4(fp)
81108be0:	1080338b 	ldhu	r2,206(r2)
81108be4:	10bfffcc 	andi	r2,r2,65535
81108be8:	1004943a 	slli	r2,r2,16
81108bec:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VAN3_NEG_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN3_NEG_RAW_MSK
81108bf0:	e0bffe17 	ldw	r2,-8(fp)
81108bf4:	10c4b03a 	or	r2,r2,r3
81108bf8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_13_REG_OFST,
81108bfc:	e0bfff17 	ldw	r2,-4(fp)
81108c00:	10800017 	ldw	r2,0(r2)
81108c04:	e1bffe17 	ldw	r6,-8(fp)
81108c08:	01402b44 	movi	r5,173
81108c0c:	1009883a 	mov	r4,r2
81108c10:	1109ea40 	call	81109ea4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108c14:	e0bfff17 	ldw	r2,-4(fp)
81108c18:	10800017 	ldw	r2,0(r2)
81108c1c:	01402b84 	movi	r5,174
81108c20:	1009883a 	mov	r4,r2
81108c24:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81108c28:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
81108c2c:	e0bffe17 	ldw	r2,-8(fp)
81108c30:	10bfffec 	andhi	r2,r2,65535
81108c34:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
81108c38:	e0bfff17 	ldw	r2,-4(fp)
81108c3c:	1080340b 	ldhu	r2,208(r2)
81108c40:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
81108c44:	e0fffe17 	ldw	r3,-8(fp)
81108c48:	1884b03a 	or	r2,r3,r2
81108c4c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VDIG_FPGA_RAW_MSK);
81108c50:	e0bffe17 	ldw	r2,-8(fp)
81108c54:	10bfffcc 	andi	r2,r2,65535
81108c58:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VDIG_FPGA_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw << 16));
81108c5c:	e0bfff17 	ldw	r2,-4(fp)
81108c60:	1080348b 	ldhu	r2,210(r2)
81108c64:	10bfffcc 	andi	r2,r2,65535
81108c68:	1004943a 	slli	r2,r2,16
81108c6c:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VDIG_FPGA_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VDIG_FPGA_RAW_MSK
81108c70:	e0bffe17 	ldw	r2,-8(fp)
81108c74:	10c4b03a 	or	r2,r2,r3
81108c78:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_14_REG_OFST,
81108c7c:	e0bfff17 	ldw	r2,-4(fp)
81108c80:	10800017 	ldw	r2,0(r2)
81108c84:	e1bffe17 	ldw	r6,-8(fp)
81108c88:	01402b84 	movi	r5,174
81108c8c:	1009883a 	mov	r4,r2
81108c90:	1109ea40 	call	81109ea4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108c94:	e0bfff17 	ldw	r2,-4(fp)
81108c98:	10800017 	ldw	r2,0(r2)
81108c9c:	01402bc4 	movi	r5,175
81108ca0:	1009883a 	mov	r4,r2
81108ca4:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81108ca8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
81108cac:	e0bffe17 	ldw	r2,-8(fp)
81108cb0:	10bfffec 	andhi	r2,r2,65535
81108cb4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
81108cb8:	e0bfff17 	ldw	r2,-4(fp)
81108cbc:	1080350b 	ldhu	r2,212(r2)
81108cc0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
81108cc4:	e0fffe17 	ldw	r3,-8(fp)
81108cc8:	1884b03a 	or	r2,r3,r2
81108ccc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VICLK_LOW_MSK);
81108cd0:	e0bffe17 	ldw	r2,-8(fp)
81108cd4:	10bfffcc 	andi	r2,r2,65535
81108cd8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VICLK_LOW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclkLow << 16));
81108cdc:	e0bfff17 	ldw	r2,-4(fp)
81108ce0:	1080358b 	ldhu	r2,214(r2)
81108ce4:	10bfffcc 	andi	r2,r2,65535
81108ce8:	1004943a 	slli	r2,r2,16
81108cec:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VICLK_LOW_MSK);
		uliReg |= (COMM_RMAP_HK_VICLK_LOW_MSK
81108cf0:	e0bffe17 	ldw	r2,-8(fp)
81108cf4:	10c4b03a 	or	r2,r2,r3
81108cf8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclkLow << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_15_REG_OFST,
81108cfc:	e0bfff17 	ldw	r2,-4(fp)
81108d00:	10800017 	ldw	r2,0(r2)
81108d04:	e1bffe17 	ldw	r6,-8(fp)
81108d08:	01402bc4 	movi	r5,175
81108d0c:	1009883a 	mov	r4,r2
81108d10:	1109ea40 	call	81109ea4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108d14:	e0bfff17 	ldw	r2,-4(fp)
81108d18:	10800017 	ldw	r2,0(r2)
81108d1c:	01402c04 	movi	r5,176
81108d20:	1009883a 	mov	r4,r2
81108d24:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81108d28:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
81108d2c:	e0bffe17 	ldw	r2,-8(fp)
81108d30:	10bfffec 	andhi	r2,r2,65535
81108d34:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
81108d38:	e0bfff17 	ldw	r2,-4(fp)
81108d3c:	1080360b 	ldhu	r2,216(r2)
81108d40:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
81108d44:	e0fffe17 	ldw	r3,-8(fp)
81108d48:	1884b03a 	or	r2,r3,r2
81108d4c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_F_MSK);
81108d50:	e0bffe17 	ldw	r2,-8(fp)
81108d54:	10bfffcc 	andi	r2,r2,65535
81108d58:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF << 16));
81108d5c:	e0bfff17 	ldw	r2,-4(fp)
81108d60:	1080368b 	ldhu	r2,218(r2)
81108d64:	10bfffcc 	andi	r2,r2,65535
81108d68:	1004943a 	slli	r2,r2,16
81108d6c:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_F_MSK);
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_F_MSK
81108d70:	e0bffe17 	ldw	r2,-8(fp)
81108d74:	10c4b03a 	or	r2,r2,r3
81108d78:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_16_REG_OFST,
81108d7c:	e0bfff17 	ldw	r2,-4(fp)
81108d80:	10800017 	ldw	r2,0(r2)
81108d84:	e1bffe17 	ldw	r6,-8(fp)
81108d88:	01402c04 	movi	r5,176
81108d8c:	1009883a 	mov	r4,r2
81108d90:	1109ea40 	call	81109ea4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108d94:	e0bfff17 	ldw	r2,-4(fp)
81108d98:	10800017 	ldw	r2,0(r2)
81108d9c:	01402c44 	movi	r5,177
81108da0:	1009883a 	mov	r4,r2
81108da4:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81108da8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
81108dac:	e0bffe17 	ldw	r2,-8(fp)
81108db0:	10bfffec 	andhi	r2,r2,65535
81108db4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
81108db8:	e0bfff17 	ldw	r2,-4(fp)
81108dbc:	1080370b 	ldhu	r2,220(r2)
81108dc0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
81108dc4:	e0fffe17 	ldw	r3,-8(fp)
81108dc8:	1884b03a 	or	r2,r3,r2
81108dcc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_TEMP_MSK);
81108dd0:	e0bffe17 	ldw	r2,-8(fp)
81108dd4:	10bfffcc 	andi	r2,r2,65535
81108dd8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp << 16));
81108ddc:	e0bfff17 	ldw	r2,-4(fp)
81108de0:	1080378b 	ldhu	r2,222(r2)
81108de4:	10bfffcc 	andi	r2,r2,65535
81108de8:	1004943a 	slli	r2,r2,16
81108dec:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_TEMP_MSK
81108df0:	e0bffe17 	ldw	r2,-8(fp)
81108df4:	10c4b03a 	or	r2,r2,r3
81108df8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_17_REG_OFST,
81108dfc:	e0bfff17 	ldw	r2,-4(fp)
81108e00:	10800017 	ldw	r2,0(r2)
81108e04:	e1bffe17 	ldw	r6,-8(fp)
81108e08:	01402c44 	movi	r5,177
81108e0c:	1009883a 	mov	r4,r2
81108e10:	1109ea40 	call	81109ea4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108e14:	e0bfff17 	ldw	r2,-4(fp)
81108e18:	10800017 	ldw	r2,0(r2)
81108e1c:	01402c84 	movi	r5,178
81108e20:	1009883a 	mov	r4,r2
81108e24:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81108e28:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
81108e2c:	e0bffe17 	ldw	r2,-8(fp)
81108e30:	10bfffec 	andhi	r2,r2,65535
81108e34:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
81108e38:	e0bfff17 	ldw	r2,-4(fp)
81108e3c:	1080380b 	ldhu	r2,224(r2)
81108e40:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
81108e44:	e0fffe17 	ldw	r3,-8(fp)
81108e48:	1884b03a 	or	r2,r3,r2
81108e4c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_TEMP_MSK);
81108e50:	e0bffe17 	ldw	r2,-8(fp)
81108e54:	10bfffcc 	andi	r2,r2,65535
81108e58:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp << 16));
81108e5c:	e0bfff17 	ldw	r2,-4(fp)
81108e60:	1080388b 	ldhu	r2,226(r2)
81108e64:	10bfffcc 	andi	r2,r2,65535
81108e68:	1004943a 	slli	r2,r2,16
81108e6c:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_TEMP_MSK
81108e70:	e0bffe17 	ldw	r2,-8(fp)
81108e74:	10c4b03a 	or	r2,r2,r3
81108e78:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_18_REG_OFST,
81108e7c:	e0bfff17 	ldw	r2,-4(fp)
81108e80:	10800017 	ldw	r2,0(r2)
81108e84:	e1bffe17 	ldw	r6,-8(fp)
81108e88:	01402c84 	movi	r5,178
81108e8c:	1009883a 	mov	r4,r2
81108e90:	1109ea40 	call	81109ea4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108e94:	e0bfff17 	ldw	r2,-4(fp)
81108e98:	10800017 	ldw	r2,0(r2)
81108e9c:	01402cc4 	movi	r5,179
81108ea0:	1009883a 	mov	r4,r2
81108ea4:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81108ea8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
81108eac:	e0bffe17 	ldw	r2,-8(fp)
81108eb0:	10bfffec 	andhi	r2,r2,65535
81108eb4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
81108eb8:	e0bfff17 	ldw	r2,-4(fp)
81108ebc:	1080390b 	ldhu	r2,228(r2)
81108ec0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
81108ec4:	e0fffe17 	ldw	r3,-8(fp)
81108ec8:	1884b03a 	or	r2,r3,r2
81108ecc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_0_MSK);
81108ed0:	e0bffe17 	ldw	r2,-8(fp)
81108ed4:	10bfffcc 	andi	r2,r2,65535
81108ed8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_0_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 << 16));
81108edc:	e0bfff17 	ldw	r2,-4(fp)
81108ee0:	1080398b 	ldhu	r2,230(r2)
81108ee4:	10bfffcc 	andi	r2,r2,65535
81108ee8:	1004943a 	slli	r2,r2,16
81108eec:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_0_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_0_MSK
81108ef0:	e0bffe17 	ldw	r2,-8(fp)
81108ef4:	10c4b03a 	or	r2,r2,r3
81108ef8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_19_REG_OFST,
81108efc:	e0bfff17 	ldw	r2,-4(fp)
81108f00:	10800017 	ldw	r2,0(r2)
81108f04:	e1bffe17 	ldw	r6,-8(fp)
81108f08:	01402cc4 	movi	r5,179
81108f0c:	1009883a 	mov	r4,r2
81108f10:	1109ea40 	call	81109ea4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108f14:	e0bfff17 	ldw	r2,-4(fp)
81108f18:	10800017 	ldw	r2,0(r2)
81108f1c:	01402d04 	movi	r5,180
81108f20:	1009883a 	mov	r4,r2
81108f24:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81108f28:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
81108f2c:	e0bffe17 	ldw	r2,-8(fp)
81108f30:	10bfffec 	andhi	r2,r2,65535
81108f34:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
81108f38:	e0bfff17 	ldw	r2,-4(fp)
81108f3c:	10803a0b 	ldhu	r2,232(r2)
81108f40:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
81108f44:	e0fffe17 	ldw	r3,-8(fp)
81108f48:	1884b03a 	or	r2,r3,r2
81108f4c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_2_MSK);
81108f50:	e0bffe17 	ldw	r2,-8(fp)
81108f54:	10bfffcc 	andi	r2,r2,65535
81108f58:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_2_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 << 16));
81108f5c:	e0bfff17 	ldw	r2,-4(fp)
81108f60:	10803a8b 	ldhu	r2,234(r2)
81108f64:	10bfffcc 	andi	r2,r2,65535
81108f68:	1004943a 	slli	r2,r2,16
81108f6c:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_2_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_2_MSK
81108f70:	e0bffe17 	ldw	r2,-8(fp)
81108f74:	10c4b03a 	or	r2,r2,r3
81108f78:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_20_REG_OFST,
81108f7c:	e0bfff17 	ldw	r2,-4(fp)
81108f80:	10800017 	ldw	r2,0(r2)
81108f84:	e1bffe17 	ldw	r6,-8(fp)
81108f88:	01402d04 	movi	r5,180
81108f8c:	1009883a 	mov	r4,r2
81108f90:	1109ea40 	call	81109ea4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108f94:	e0bfff17 	ldw	r2,-4(fp)
81108f98:	10800017 	ldw	r2,0(r2)
81108f9c:	01402d44 	movi	r5,181
81108fa0:	1009883a 	mov	r4,r2
81108fa4:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81108fa8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
81108fac:	e0bffe17 	ldw	r2,-8(fp)
81108fb0:	10bfffec 	andhi	r2,r2,65535
81108fb4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
81108fb8:	e0bfff17 	ldw	r2,-4(fp)
81108fbc:	10803b0b 	ldhu	r2,236(r2)
81108fc0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
81108fc4:	e0fffe17 	ldw	r3,-8(fp)
81108fc8:	1884b03a 	or	r2,r3,r2
81108fcc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_4_MSK);
81108fd0:	e0bffe17 	ldw	r2,-8(fp)
81108fd4:	10bfffcc 	andi	r2,r2,65535
81108fd8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_4_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 << 16));
81108fdc:	e0bfff17 	ldw	r2,-4(fp)
81108fe0:	10803b8b 	ldhu	r2,238(r2)
81108fe4:	10bfffcc 	andi	r2,r2,65535
81108fe8:	1004943a 	slli	r2,r2,16
81108fec:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_4_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_4_MSK
81108ff0:	e0bffe17 	ldw	r2,-8(fp)
81108ff4:	10c4b03a 	or	r2,r2,r3
81108ff8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_21_REG_OFST,
81108ffc:	e0bfff17 	ldw	r2,-4(fp)
81109000:	10800017 	ldw	r2,0(r2)
81109004:	e1bffe17 	ldw	r6,-8(fp)
81109008:	01402d44 	movi	r5,181
8110900c:	1009883a 	mov	r4,r2
81109010:	1109ea40 	call	81109ea4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109014:	e0bfff17 	ldw	r2,-4(fp)
81109018:	10800017 	ldw	r2,0(r2)
8110901c:	01402d84 	movi	r5,182
81109020:	1009883a 	mov	r4,r2
81109024:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81109028:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
8110902c:	e0bffe17 	ldw	r2,-8(fp)
81109030:	10bfffec 	andhi	r2,r2,65535
81109034:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
81109038:	e0bfff17 	ldw	r2,-4(fp)
8110903c:	10803c0b 	ldhu	r2,240(r2)
81109040:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
81109044:	e0fffe17 	ldw	r3,-8(fp)
81109048:	1884b03a 	or	r2,r3,r2
8110904c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_6_MSK);
81109050:	e0bffe17 	ldw	r2,-8(fp)
81109054:	10bfffcc 	andi	r2,r2,65535
81109058:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_6_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 << 16));
8110905c:	e0bfff17 	ldw	r2,-4(fp)
81109060:	10803c8b 	ldhu	r2,242(r2)
81109064:	10bfffcc 	andi	r2,r2,65535
81109068:	1004943a 	slli	r2,r2,16
8110906c:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_6_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_6_MSK
81109070:	e0bffe17 	ldw	r2,-8(fp)
81109074:	10c4b03a 	or	r2,r2,r3
81109078:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_22_REG_OFST,
8110907c:	e0bfff17 	ldw	r2,-4(fp)
81109080:	10800017 	ldw	r2,0(r2)
81109084:	e1bffe17 	ldw	r6,-8(fp)
81109088:	01402d84 	movi	r5,182
8110908c:	1009883a 	mov	r4,r2
81109090:	1109ea40 	call	81109ea4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109094:	e0bfff17 	ldw	r2,-4(fp)
81109098:	10800017 	ldw	r2,0(r2)
8110909c:	01402dc4 	movi	r5,183
811090a0:	1009883a 	mov	r4,r2
811090a4:	1109ef80 	call	81109ef8 <uliRmapReadReg>
811090a8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
811090ac:	e0bffe17 	ldw	r2,-8(fp)
811090b0:	10bfffec 	andhi	r2,r2,65535
811090b4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
811090b8:	e0bfff17 	ldw	r2,-4(fp)
811090bc:	10803d0b 	ldhu	r2,244(r2)
811090c0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
811090c4:	e0fffe17 	ldw	r3,-8(fp)
811090c8:	1884b03a 	or	r2,r3,r2
811090cc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_8_MSK);
811090d0:	e0bffe17 	ldw	r2,-8(fp)
811090d4:	10bfffcc 	andi	r2,r2,65535
811090d8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_8_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 << 16));
811090dc:	e0bfff17 	ldw	r2,-4(fp)
811090e0:	10803d8b 	ldhu	r2,246(r2)
811090e4:	10bfffcc 	andi	r2,r2,65535
811090e8:	1004943a 	slli	r2,r2,16
811090ec:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_8_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_8_MSK
811090f0:	e0bffe17 	ldw	r2,-8(fp)
811090f4:	10c4b03a 	or	r2,r2,r3
811090f8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_23_REG_OFST,
811090fc:	e0bfff17 	ldw	r2,-4(fp)
81109100:	10800017 	ldw	r2,0(r2)
81109104:	e1bffe17 	ldw	r6,-8(fp)
81109108:	01402dc4 	movi	r5,183
8110910c:	1009883a 	mov	r4,r2
81109110:	1109ea40 	call	81109ea4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109114:	e0bfff17 	ldw	r2,-4(fp)
81109118:	10800017 	ldw	r2,0(r2)
8110911c:	01402e04 	movi	r5,184
81109120:	1009883a 	mov	r4,r2
81109124:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81109128:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
8110912c:	e0bffe17 	ldw	r2,-8(fp)
81109130:	10bfffec 	andhi	r2,r2,65535
81109134:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
81109138:	e0bfff17 	ldw	r2,-4(fp)
8110913c:	10803e0b 	ldhu	r2,248(r2)
81109140:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
81109144:	e0fffe17 	ldw	r3,-8(fp)
81109148:	1884b03a 	or	r2,r3,r2
8110914c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_10_MSK);
81109150:	e0bffe17 	ldw	r2,-8(fp)
81109154:	10bfffcc 	andi	r2,r2,65535
81109158:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_10_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 << 16));
8110915c:	e0bfff17 	ldw	r2,-4(fp)
81109160:	10803e8b 	ldhu	r2,250(r2)
81109164:	10bfffcc 	andi	r2,r2,65535
81109168:	1004943a 	slli	r2,r2,16
8110916c:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_10_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_10_MSK
81109170:	e0bffe17 	ldw	r2,-8(fp)
81109174:	10c4b03a 	or	r2,r2,r3
81109178:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_24_REG_OFST,
8110917c:	e0bfff17 	ldw	r2,-4(fp)
81109180:	10800017 	ldw	r2,0(r2)
81109184:	e1bffe17 	ldw	r6,-8(fp)
81109188:	01402e04 	movi	r5,184
8110918c:	1009883a 	mov	r4,r2
81109190:	1109ea40 	call	81109ea4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109194:	e0bfff17 	ldw	r2,-4(fp)
81109198:	10800017 	ldw	r2,0(r2)
8110919c:	01402e44 	movi	r5,185
811091a0:	1009883a 	mov	r4,r2
811091a4:	1109ef80 	call	81109ef8 <uliRmapReadReg>
811091a8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
811091ac:	e0bffe17 	ldw	r2,-8(fp)
811091b0:	10bfffec 	andhi	r2,r2,65535
811091b4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
811091b8:	e0bfff17 	ldw	r2,-4(fp)
811091bc:	10803f0b 	ldhu	r2,252(r2)
811091c0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
811091c4:	e0fffe17 	ldw	r3,-8(fp)
811091c8:	1884b03a 	or	r2,r3,r2
811091cc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_12_MSK);
811091d0:	e0bffe17 	ldw	r2,-8(fp)
811091d4:	10bfffcc 	andi	r2,r2,65535
811091d8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_12_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 << 16));
811091dc:	e0bfff17 	ldw	r2,-4(fp)
811091e0:	10803f8b 	ldhu	r2,254(r2)
811091e4:	10bfffcc 	andi	r2,r2,65535
811091e8:	1004943a 	slli	r2,r2,16
811091ec:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_12_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_12_MSK
811091f0:	e0bffe17 	ldw	r2,-8(fp)
811091f4:	10c4b03a 	or	r2,r2,r3
811091f8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_25_REG_OFST,
811091fc:	e0bfff17 	ldw	r2,-4(fp)
81109200:	10800017 	ldw	r2,0(r2)
81109204:	e1bffe17 	ldw	r6,-8(fp)
81109208:	01402e44 	movi	r5,185
8110920c:	1009883a 	mov	r4,r2
81109210:	1109ea40 	call	81109ea4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109214:	e0bfff17 	ldw	r2,-4(fp)
81109218:	10800017 	ldw	r2,0(r2)
8110921c:	01402e84 	movi	r5,186
81109220:	1009883a 	mov	r4,r2
81109224:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81109228:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
8110922c:	e0bffe17 	ldw	r2,-8(fp)
81109230:	10bfffec 	andhi	r2,r2,65535
81109234:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
81109238:	e0bfff17 	ldw	r2,-4(fp)
8110923c:	1080400b 	ldhu	r2,256(r2)
81109240:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
81109244:	e0fffe17 	ldw	r3,-8(fp)
81109248:	1884b03a 	or	r2,r3,r2
8110924c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_14_MSK);
81109250:	e0bffe17 	ldw	r2,-8(fp)
81109254:	10bfffcc 	andi	r2,r2,65535
81109258:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_14_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 << 16));
8110925c:	e0bfff17 	ldw	r2,-4(fp)
81109260:	1080408b 	ldhu	r2,258(r2)
81109264:	10bfffcc 	andi	r2,r2,65535
81109268:	1004943a 	slli	r2,r2,16
8110926c:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_14_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_14_MSK
81109270:	e0bffe17 	ldw	r2,-8(fp)
81109274:	10c4b03a 	or	r2,r2,r3
81109278:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_26_REG_OFST,
8110927c:	e0bfff17 	ldw	r2,-4(fp)
81109280:	10800017 	ldw	r2,0(r2)
81109284:	e1bffe17 	ldw	r6,-8(fp)
81109288:	01402e84 	movi	r5,186
8110928c:	1009883a 	mov	r4,r2
81109290:	1109ea40 	call	81109ea4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109294:	e0bfff17 	ldw	r2,-4(fp)
81109298:	10800017 	ldw	r2,0(r2)
8110929c:	01402ec4 	movi	r5,187
811092a0:	1009883a 	mov	r4,r2
811092a4:	1109ef80 	call	81109ef8 <uliRmapReadReg>
811092a8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
811092ac:	e0bffe17 	ldw	r2,-8(fp)
811092b0:	10bfffec 	andhi	r2,r2,65535
811092b4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
811092b8:	e0bfff17 	ldw	r2,-4(fp)
811092bc:	1080410b 	ldhu	r2,260(r2)
811092c0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
811092c4:	e0fffe17 	ldw	r3,-8(fp)
811092c8:	1884b03a 	or	r2,r3,r2
811092cc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT0_MSK);
811092d0:	e0bffe17 	ldw	r2,-8(fp)
811092d4:	10bfffcc 	andi	r2,r2,65535
811092d8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT0_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 << 16));
811092dc:	e0bfff17 	ldw	r2,-4(fp)
811092e0:	1080418b 	ldhu	r2,262(r2)
811092e4:	10bfffcc 	andi	r2,r2,65535
811092e8:	1004943a 	slli	r2,r2,16
811092ec:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT0_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT0_MSK
811092f0:	e0bffe17 	ldw	r2,-8(fp)
811092f4:	10c4b03a 	or	r2,r2,r3
811092f8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_27_REG_OFST,
811092fc:	e0bfff17 	ldw	r2,-4(fp)
81109300:	10800017 	ldw	r2,0(r2)
81109304:	e1bffe17 	ldw	r6,-8(fp)
81109308:	01402ec4 	movi	r5,187
8110930c:	1009883a 	mov	r4,r2
81109310:	1109ea40 	call	81109ea4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109314:	e0bfff17 	ldw	r2,-4(fp)
81109318:	10800017 	ldw	r2,0(r2)
8110931c:	01402f04 	movi	r5,188
81109320:	1009883a 	mov	r4,r2
81109324:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81109328:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
8110932c:	e0bffe17 	ldw	r2,-8(fp)
81109330:	10bfffec 	andhi	r2,r2,65535
81109334:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
81109338:	e0bfff17 	ldw	r2,-4(fp)
8110933c:	1080420b 	ldhu	r2,264(r2)
81109340:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
81109344:	e0fffe17 	ldw	r3,-8(fp)
81109348:	1884b03a 	or	r2,r3,r2
8110934c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT2_MSK);
81109350:	e0bffe17 	ldw	r2,-8(fp)
81109354:	10bfffcc 	andi	r2,r2,65535
81109358:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT2_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 << 16));
8110935c:	e0bfff17 	ldw	r2,-4(fp)
81109360:	1080428b 	ldhu	r2,266(r2)
81109364:	10bfffcc 	andi	r2,r2,65535
81109368:	1004943a 	slli	r2,r2,16
8110936c:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT2_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT2_MSK
81109370:	e0bffe17 	ldw	r2,-8(fp)
81109374:	10c4b03a 	or	r2,r2,r3
81109378:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_28_REG_OFST,
8110937c:	e0bfff17 	ldw	r2,-4(fp)
81109380:	10800017 	ldw	r2,0(r2)
81109384:	e1bffe17 	ldw	r6,-8(fp)
81109388:	01402f04 	movi	r5,188
8110938c:	1009883a 	mov	r4,r2
81109390:	1109ea40 	call	81109ea4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109394:	e0bfff17 	ldw	r2,-4(fp)
81109398:	10800017 	ldw	r2,0(r2)
8110939c:	01402f44 	movi	r5,189
811093a0:	1009883a 	mov	r4,r2
811093a4:	1109ef80 	call	81109ef8 <uliRmapReadReg>
811093a8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
811093ac:	e0bffe17 	ldw	r2,-8(fp)
811093b0:	10bfffec 	andhi	r2,r2,65535
811093b4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
811093b8:	e0bfff17 	ldw	r2,-4(fp)
811093bc:	1080430b 	ldhu	r2,268(r2)
811093c0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
811093c4:	e0fffe17 	ldw	r3,-8(fp)
811093c8:	1884b03a 	or	r2,r3,r2
811093cc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT4_MSK);
811093d0:	e0bffe17 	ldw	r2,-8(fp)
811093d4:	10bfffcc 	andi	r2,r2,65535
811093d8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT4_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 << 16));
811093dc:	e0bfff17 	ldw	r2,-4(fp)
811093e0:	1080438b 	ldhu	r2,270(r2)
811093e4:	10bfffcc 	andi	r2,r2,65535
811093e8:	1004943a 	slli	r2,r2,16
811093ec:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT4_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT4_MSK
811093f0:	e0bffe17 	ldw	r2,-8(fp)
811093f4:	10c4b03a 	or	r2,r2,r3
811093f8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_29_REG_OFST,
811093fc:	e0bfff17 	ldw	r2,-4(fp)
81109400:	10800017 	ldw	r2,0(r2)
81109404:	e1bffe17 	ldw	r6,-8(fp)
81109408:	01402f44 	movi	r5,189
8110940c:	1009883a 	mov	r4,r2
81109410:	1109ea40 	call	81109ea4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109414:	e0bfff17 	ldw	r2,-4(fp)
81109418:	10800017 	ldw	r2,0(r2)
8110941c:	01402f84 	movi	r5,190
81109420:	1009883a 	mov	r4,r2
81109424:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81109428:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
8110942c:	e0bffe17 	ldw	r2,-8(fp)
81109430:	10bfffec 	andhi	r2,r2,65535
81109434:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
81109438:	e0bfff17 	ldw	r2,-4(fp)
8110943c:	1080440b 	ldhu	r2,272(r2)
81109440:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
81109444:	e0fffe17 	ldw	r3,-8(fp)
81109448:	1884b03a 	or	r2,r3,r2
8110944c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT6_MSK);
81109450:	e0bffe17 	ldw	r2,-8(fp)
81109454:	10bfffcc 	andi	r2,r2,65535
81109458:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT6_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 << 16));
8110945c:	e0bfff17 	ldw	r2,-4(fp)
81109460:	1080448b 	ldhu	r2,274(r2)
81109464:	10bfffcc 	andi	r2,r2,65535
81109468:	1004943a 	slli	r2,r2,16
8110946c:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT6_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT6_MSK
81109470:	e0bffe17 	ldw	r2,-8(fp)
81109474:	10c4b03a 	or	r2,r2,r3
81109478:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_30_REG_OFST,
8110947c:	e0bfff17 	ldw	r2,-4(fp)
81109480:	10800017 	ldw	r2,0(r2)
81109484:	e1bffe17 	ldw	r6,-8(fp)
81109488:	01402f84 	movi	r5,190
8110948c:	1009883a 	mov	r4,r2
81109490:	1109ea40 	call	81109ea4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109494:	e0bfff17 	ldw	r2,-4(fp)
81109498:	10800017 	ldw	r2,0(r2)
8110949c:	01402fc4 	movi	r5,191
811094a0:	1009883a 	mov	r4,r2
811094a4:	1109ef80 	call	81109ef8 <uliRmapReadReg>
811094a8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
811094ac:	e0bffe17 	ldw	r2,-8(fp)
811094b0:	10bfffec 	andhi	r2,r2,65535
811094b4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
811094b8:	e0bfff17 	ldw	r2,-4(fp)
811094bc:	1080450b 	ldhu	r2,276(r2)
811094c0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
811094c4:	e0fffe17 	ldw	r3,-8(fp)
811094c8:	1884b03a 	or	r2,r3,r2
811094cc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
		uliReg &= (~COMM_RMAP_ZERO_HIRES_AMP_MSK);
811094d0:	e0bffe17 	ldw	r2,-8(fp)
811094d4:	10bfffcc 	andi	r2,r2,65535
811094d8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_ZERO_HIRES_AMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp << 16));
811094dc:	e0bfff17 	ldw	r2,-4(fp)
811094e0:	1080458b 	ldhu	r2,278(r2)
811094e4:	10bfffcc 	andi	r2,r2,65535
811094e8:	1004943a 	slli	r2,r2,16
811094ec:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
		uliReg &= (~COMM_RMAP_ZERO_HIRES_AMP_MSK);
		uliReg |= (COMM_RMAP_ZERO_HIRES_AMP_MSK
811094f0:	e0bffe17 	ldw	r2,-8(fp)
811094f4:	10c4b03a 	or	r2,r2,r3
811094f8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_31_REG_OFST,
811094fc:	e0bfff17 	ldw	r2,-4(fp)
81109500:	10800017 	ldw	r2,0(r2)
81109504:	e1bffe17 	ldw	r6,-8(fp)
81109508:	01402fc4 	movi	r5,191
8110950c:	1009883a 	mov	r4,r2
81109510:	1109ea40 	call	81109ea4 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
81109514:	00800044 	movi	r2,1
81109518:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110951c:	e0bffd17 	ldw	r2,-12(fp)
}
81109520:	e037883a 	mov	sp,fp
81109524:	dfc00117 	ldw	ra,4(sp)
81109528:	df000017 	ldw	fp,0(sp)
8110952c:	dec00204 	addi	sp,sp,8
81109530:	f800283a 	ret

81109534 <bRmapGetRmapMemHKArea>:

bool bRmapGetRmapMemHKArea(TRmapChannel *pxRmapCh) {
81109534:	defffb04 	addi	sp,sp,-20
81109538:	de00012e 	bgeu	sp,et,81109540 <bRmapGetRmapMemHKArea+0xc>
8110953c:	003b68fa 	trap	3
81109540:	dfc00415 	stw	ra,16(sp)
81109544:	df000315 	stw	fp,12(sp)
81109548:	df000304 	addi	fp,sp,12
8110954c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81109550:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81109554:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81109558:	e0bfff17 	ldw	r2,-4(fp)
8110955c:	1001e226 	beq	r2,zero,81109ce8 <bRmapGetRmapMemHKArea+0x7b4>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109560:	e0bfff17 	ldw	r2,-4(fp)
81109564:	10800017 	ldw	r2,0(r2)
81109568:	01402804 	movi	r5,160
8110956c:	1009883a 	mov	r4,r2
81109570:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81109574:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_0_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE = (alt_u16) ((uliReg
81109578:	e0bffe17 	ldw	r2,-8(fp)
8110957c:	1007883a 	mov	r3,r2
81109580:	e0bfff17 	ldw	r2,-4(fp)
81109584:	10c0260d 	sth	r3,152(r2)
				& COMM_RMAP_HK_CCD1_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VOD_F_MSK) >> 16);
81109588:	e0bffe17 	ldw	r2,-8(fp)
8110958c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_0_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF = (alt_u16) ((uliReg
81109590:	1007883a 	mov	r3,r2
81109594:	e0bfff17 	ldw	r2,-4(fp)
81109598:	10c0268d 	sth	r3,154(r2)
				& COMM_RMAP_HK_CCD1_VOD_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110959c:	e0bfff17 	ldw	r2,-4(fp)
811095a0:	10800017 	ldw	r2,0(r2)
811095a4:	01402844 	movi	r5,161
811095a8:	1009883a 	mov	r4,r2
811095ac:	1109ef80 	call	81109ef8 <uliRmapReadReg>
811095b0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_1_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon = (alt_u16) ((uliReg
811095b4:	e0bffe17 	ldw	r2,-8(fp)
811095b8:	1007883a 	mov	r3,r2
811095bc:	e0bfff17 	ldw	r2,-4(fp)
811095c0:	10c0270d 	sth	r3,156(r2)
				& COMM_RMAP_HK_CCD1_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VOD_E_MSK) >> 16);
811095c4:	e0bffe17 	ldw	r2,-8(fp)
811095c8:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_1_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE = (alt_u16) ((uliReg
811095cc:	1007883a 	mov	r3,r2
811095d0:	e0bfff17 	ldw	r2,-4(fp)
811095d4:	10c0278d 	sth	r3,158(r2)
				& COMM_RMAP_HK_CCD2_VOD_E_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811095d8:	e0bfff17 	ldw	r2,-4(fp)
811095dc:	10800017 	ldw	r2,0(r2)
811095e0:	01402884 	movi	r5,162
811095e4:	1009883a 	mov	r4,r2
811095e8:	1109ef80 	call	81109ef8 <uliRmapReadReg>
811095ec:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_2_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF = (alt_u16) ((uliReg
811095f0:	e0bffe17 	ldw	r2,-8(fp)
811095f4:	1007883a 	mov	r3,r2
811095f8:	e0bfff17 	ldw	r2,-4(fp)
811095fc:	10c0280d 	sth	r3,160(r2)
				& COMM_RMAP_HK_CCD2_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VRD_MON_MSK) >> 16);
81109600:	e0bffe17 	ldw	r2,-8(fp)
81109604:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_2_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon = (alt_u16) ((uliReg
81109608:	1007883a 	mov	r3,r2
8110960c:	e0bfff17 	ldw	r2,-4(fp)
81109610:	10c0288d 	sth	r3,162(r2)
				& COMM_RMAP_HK_CCD2_VRD_MON_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109614:	e0bfff17 	ldw	r2,-4(fp)
81109618:	10800017 	ldw	r2,0(r2)
8110961c:	014028c4 	movi	r5,163
81109620:	1009883a 	mov	r4,r2
81109624:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81109628:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_3_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE = (alt_u16) ((uliReg
8110962c:	e0bffe17 	ldw	r2,-8(fp)
81109630:	1007883a 	mov	r3,r2
81109634:	e0bfff17 	ldw	r2,-4(fp)
81109638:	10c0290d 	sth	r3,164(r2)
				& COMM_RMAP_HK_CCD3_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VOD_F_MSK) >> 16);
8110963c:	e0bffe17 	ldw	r2,-8(fp)
81109640:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_3_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF = (alt_u16) ((uliReg
81109644:	1007883a 	mov	r3,r2
81109648:	e0bfff17 	ldw	r2,-4(fp)
8110964c:	10c0298d 	sth	r3,166(r2)
				& COMM_RMAP_HK_CCD3_VOD_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109650:	e0bfff17 	ldw	r2,-4(fp)
81109654:	10800017 	ldw	r2,0(r2)
81109658:	01402904 	movi	r5,164
8110965c:	1009883a 	mov	r4,r2
81109660:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81109664:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_4_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon = (alt_u16) ((uliReg
81109668:	e0bffe17 	ldw	r2,-8(fp)
8110966c:	1007883a 	mov	r3,r2
81109670:	e0bfff17 	ldw	r2,-4(fp)
81109674:	10c02a0d 	sth	r3,168(r2)
				& COMM_RMAP_HK_CCD3_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VOD_E_MSK) >> 16);
81109678:	e0bffe17 	ldw	r2,-8(fp)
8110967c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_4_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE = (alt_u16) ((uliReg
81109680:	1007883a 	mov	r3,r2
81109684:	e0bfff17 	ldw	r2,-4(fp)
81109688:	10c02a8d 	sth	r3,170(r2)
				& COMM_RMAP_HK_CCD4_VOD_E_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110968c:	e0bfff17 	ldw	r2,-4(fp)
81109690:	10800017 	ldw	r2,0(r2)
81109694:	01402944 	movi	r5,165
81109698:	1009883a 	mov	r4,r2
8110969c:	1109ef80 	call	81109ef8 <uliRmapReadReg>
811096a0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_5_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF = (alt_u16) ((uliReg
811096a4:	e0bffe17 	ldw	r2,-8(fp)
811096a8:	1007883a 	mov	r3,r2
811096ac:	e0bfff17 	ldw	r2,-4(fp)
811096b0:	10c02b0d 	sth	r3,172(r2)
				& COMM_RMAP_HK_CCD4_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VRD_MON_MSK) >> 16);
811096b4:	e0bffe17 	ldw	r2,-8(fp)
811096b8:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_5_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon = (alt_u16) ((uliReg
811096bc:	1007883a 	mov	r3,r2
811096c0:	e0bfff17 	ldw	r2,-4(fp)
811096c4:	10c02b8d 	sth	r3,174(r2)
				& COMM_RMAP_HK_CCD4_VRD_MON_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811096c8:	e0bfff17 	ldw	r2,-4(fp)
811096cc:	10800017 	ldw	r2,0(r2)
811096d0:	01402984 	movi	r5,166
811096d4:	1009883a 	mov	r4,r2
811096d8:	1109ef80 	call	81109ef8 <uliRmapReadReg>
811096dc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_6_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccd = (alt_u16) ((uliReg
811096e0:	e0bffe17 	ldw	r2,-8(fp)
811096e4:	1007883a 	mov	r3,r2
811096e8:	e0bfff17 	ldw	r2,-4(fp)
811096ec:	10c02c0d 	sth	r3,176(r2)
				& COMM_RMAP_HK_VCCD_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclk = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VRCLK_MSK) >> 16);
811096f0:	e0bffe17 	ldw	r2,-8(fp)
811096f4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_6_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccd = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCCD_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclk = (alt_u16) ((uliReg
811096f8:	1007883a 	mov	r3,r2
811096fc:	e0bfff17 	ldw	r2,-4(fp)
81109700:	10c02c8d 	sth	r3,178(r2)
				& COMM_RMAP_HK_VRCLK_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109704:	e0bfff17 	ldw	r2,-4(fp)
81109708:	10800017 	ldw	r2,0(r2)
8110970c:	014029c4 	movi	r5,167
81109710:	1009883a 	mov	r4,r2
81109714:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81109718:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_7_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkViclk = (alt_u16) ((uliReg
8110971c:	e0bffe17 	ldw	r2,-8(fp)
81109720:	1007883a 	mov	r3,r2
81109724:	e0bfff17 	ldw	r2,-4(fp)
81109728:	10c02d0d 	sth	r3,180(r2)
				& COMM_RMAP_HK_VICLK_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclkLow = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VRCLK_LOW_MSK) >> 16);
8110972c:	e0bffe17 	ldw	r2,-8(fp)
81109730:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_7_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkViclk = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VICLK_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclkLow = (alt_u16) ((uliReg
81109734:	1007883a 	mov	r3,r2
81109738:	e0bfff17 	ldw	r2,-4(fp)
8110973c:	10c02d8d 	sth	r3,182(r2)
				& COMM_RMAP_HK_VRCLK_LOW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109740:	e0bfff17 	ldw	r2,-4(fp)
81109744:	10800017 	ldw	r2,0(r2)
81109748:	01402a04 	movi	r5,168
8110974c:	1009883a 	mov	r4,r2
81109750:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81109754:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_8_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk5vbPos = (alt_u16) ((uliReg
81109758:	e0bffe17 	ldw	r2,-8(fp)
8110975c:	1007883a 	mov	r3,r2
81109760:	e0bfff17 	ldw	r2,-4(fp)
81109764:	10c02e0d 	sth	r3,184(r2)
				& COMM_RMAP_HK_5VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vbNeg = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VB_NEG_MSK) >> 16);
81109768:	e0bffe17 	ldw	r2,-8(fp)
8110976c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_8_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk5vbPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vbNeg = (alt_u16) ((uliReg
81109770:	1007883a 	mov	r3,r2
81109774:	e0bfff17 	ldw	r2,-4(fp)
81109778:	10c02e8d 	sth	r3,186(r2)
				& COMM_RMAP_HK_5VB_NEG_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110977c:	e0bfff17 	ldw	r2,-4(fp)
81109780:	10800017 	ldw	r2,0(r2)
81109784:	01402a44 	movi	r5,169
81109788:	1009883a 	mov	r4,r2
8110978c:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81109790:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_9_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vbPos = (alt_u16) ((uliReg
81109794:	e0bffe17 	ldw	r2,-8(fp)
81109798:	1007883a 	mov	r3,r2
8110979c:	e0bfff17 	ldw	r2,-4(fp)
811097a0:	10c02f0d 	sth	r3,188(r2)
				& COMM_RMAP_HK_3_3VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vaPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_2_5VA_POS_MSK) >> 16);
811097a4:	e0bffe17 	ldw	r2,-8(fp)
811097a8:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_9_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vbPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_3_3VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vaPos = (alt_u16) ((uliReg
811097ac:	1007883a 	mov	r3,r2
811097b0:	e0bfff17 	ldw	r2,-4(fp)
811097b4:	10c02f8d 	sth	r3,190(r2)
				& COMM_RMAP_HK_2_5VA_POS_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811097b8:	e0bfff17 	ldw	r2,-4(fp)
811097bc:	10800017 	ldw	r2,0(r2)
811097c0:	01402a84 	movi	r5,170
811097c4:	1009883a 	mov	r4,r2
811097c8:	1109ef80 	call	81109ef8 <uliRmapReadReg>
811097cc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_10_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vdPos = (alt_u16) ((uliReg
811097d0:	e0bffe17 	ldw	r2,-8(fp)
811097d4:	1007883a 	mov	r3,r2
811097d8:	e0bfff17 	ldw	r2,-4(fp)
811097dc:	10c0300d 	sth	r3,192(r2)
				& COMM_RMAP_HK_3_3VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_2_5VD_POS_MSK) >> 16);
811097e0:	e0bffe17 	ldw	r2,-8(fp)
811097e4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_10_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_3_3VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vdPos = (alt_u16) ((uliReg
811097e8:	1007883a 	mov	r3,r2
811097ec:	e0bfff17 	ldw	r2,-4(fp)
811097f0:	10c0308d 	sth	r3,194(r2)
				& COMM_RMAP_HK_2_5VD_POS_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811097f4:	e0bfff17 	ldw	r2,-4(fp)
811097f8:	10800017 	ldw	r2,0(r2)
811097fc:	01402ac4 	movi	r5,171
81109800:	1009883a 	mov	r4,r2
81109804:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81109808:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_11_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk15vdPos = (alt_u16) ((uliReg
8110980c:	e0bffe17 	ldw	r2,-8(fp)
81109810:	1007883a 	mov	r3,r2
81109814:	e0bfff17 	ldw	r2,-4(fp)
81109818:	10c0310d 	sth	r3,196(r2)
				& COMM_RMAP_HK_1_5VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vref = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VREF_MSK) >> 16);
8110981c:	e0bffe17 	ldw	r2,-8(fp)
81109820:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_11_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk15vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_1_5VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vref = (alt_u16) ((uliReg
81109824:	1007883a 	mov	r3,r2
81109828:	e0bfff17 	ldw	r2,-4(fp)
8110982c:	10c0318d 	sth	r3,198(r2)
				& COMM_RMAP_HK_5VREF_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109830:	e0bfff17 	ldw	r2,-4(fp)
81109834:	10800017 	ldw	r2,0(r2)
81109838:	01402b04 	movi	r5,172
8110983c:	1009883a 	mov	r4,r2
81109840:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81109844:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_12_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw = (alt_u16) ((uliReg
81109848:	e0bffe17 	ldw	r2,-8(fp)
8110984c:	1007883a 	mov	r3,r2
81109850:	e0bfff17 	ldw	r2,-4(fp)
81109854:	10c0320d 	sth	r3,200(r2)
				& COMM_RMAP_HK_VCCD_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCLK_POS_RAW_MSK) >> 16);
81109858:	e0bffe17 	ldw	r2,-8(fp)
8110985c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_12_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCCD_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw = (alt_u16) ((uliReg
81109860:	1007883a 	mov	r3,r2
81109864:	e0bfff17 	ldw	r2,-4(fp)
81109868:	10c0328d 	sth	r3,202(r2)
				& COMM_RMAP_HK_VCLK_POS_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110986c:	e0bfff17 	ldw	r2,-4(fp)
81109870:	10800017 	ldw	r2,0(r2)
81109874:	01402b44 	movi	r5,173
81109878:	1009883a 	mov	r4,r2
8110987c:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81109880:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_13_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw = (alt_u16) ((uliReg
81109884:	e0bffe17 	ldw	r2,-8(fp)
81109888:	1007883a 	mov	r3,r2
8110988c:	e0bfff17 	ldw	r2,-4(fp)
81109890:	10c0330d 	sth	r3,204(r2)
				& COMM_RMAP_HK_VAN1_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN3_NEG_RAW_MSK) >> 16);
81109894:	e0bffe17 	ldw	r2,-8(fp)
81109898:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_13_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN1_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw = (alt_u16) ((uliReg
8110989c:	1007883a 	mov	r3,r2
811098a0:	e0bfff17 	ldw	r2,-4(fp)
811098a4:	10c0338d 	sth	r3,206(r2)
				& COMM_RMAP_HK_VAN3_NEG_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811098a8:	e0bfff17 	ldw	r2,-4(fp)
811098ac:	10800017 	ldw	r2,0(r2)
811098b0:	01402b84 	movi	r5,174
811098b4:	1009883a 	mov	r4,r2
811098b8:	1109ef80 	call	81109ef8 <uliRmapReadReg>
811098bc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_14_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw = (alt_u16) ((uliReg
811098c0:	e0bffe17 	ldw	r2,-8(fp)
811098c4:	1007883a 	mov	r3,r2
811098c8:	e0bfff17 	ldw	r2,-4(fp)
811098cc:	10c0340d 	sth	r3,208(r2)
				& COMM_RMAP_HK_VAN2_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VDIG_FPGA_RAW_MSK) >> 16);
811098d0:	e0bffe17 	ldw	r2,-8(fp)
811098d4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_14_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN2_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw = (alt_u16) ((uliReg
811098d8:	1007883a 	mov	r3,r2
811098dc:	e0bfff17 	ldw	r2,-4(fp)
811098e0:	10c0348d 	sth	r3,210(r2)
				& COMM_RMAP_HK_VDIG_FPGA_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811098e4:	e0bfff17 	ldw	r2,-4(fp)
811098e8:	10800017 	ldw	r2,0(r2)
811098ec:	01402bc4 	movi	r5,175
811098f0:	1009883a 	mov	r4,r2
811098f4:	1109ef80 	call	81109ef8 <uliRmapReadReg>
811098f8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_15_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw = (alt_u16) ((uliReg
811098fc:	e0bffe17 	ldw	r2,-8(fp)
81109900:	1007883a 	mov	r3,r2
81109904:	e0bfff17 	ldw	r2,-4(fp)
81109908:	10c0350d 	sth	r3,212(r2)
				& COMM_RMAP_HK_VDIG_SPW_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkViclkLow = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VICLK_LOW_MSK) >> 16);
8110990c:	e0bffe17 	ldw	r2,-8(fp)
81109910:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_15_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VDIG_SPW_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkViclkLow = (alt_u16) ((uliReg
81109914:	1007883a 	mov	r3,r2
81109918:	e0bfff17 	ldw	r2,-4(fp)
8110991c:	10c0358d 	sth	r3,214(r2)
				& COMM_RMAP_HK_VICLK_LOW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109920:	e0bfff17 	ldw	r2,-4(fp)
81109924:	10800017 	ldw	r2,0(r2)
81109928:	01402c04 	movi	r5,176
8110992c:	1009883a 	mov	r4,r2
81109930:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81109934:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_16_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE = (alt_u16) ((uliReg
81109938:	e0bffe17 	ldw	r2,-8(fp)
8110993c:	1007883a 	mov	r3,r2
81109940:	e0bfff17 	ldw	r2,-4(fp)
81109944:	10c0360d 	sth	r3,216(r2)
				& COMM_RMAP_HK_ADC_TEMP_A_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_ADC_TEMP_A_F_MSK) >> 16);
81109948:	e0bffe17 	ldw	r2,-8(fp)
8110994c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_16_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_ADC_TEMP_A_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF = (alt_u16) ((uliReg
81109950:	1007883a 	mov	r3,r2
81109954:	e0bfff17 	ldw	r2,-4(fp)
81109958:	10c0368d 	sth	r3,218(r2)
				& COMM_RMAP_HK_ADC_TEMP_A_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110995c:	e0bfff17 	ldw	r2,-4(fp)
81109960:	10800017 	ldw	r2,0(r2)
81109964:	01402c44 	movi	r5,177
81109968:	1009883a 	mov	r4,r2
8110996c:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81109970:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_17_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp = (alt_u16) ((uliReg
81109974:	e0bffe17 	ldw	r2,-8(fp)
81109978:	1007883a 	mov	r3,r2
8110997c:	e0bfff17 	ldw	r2,-4(fp)
81109980:	10c0370d 	sth	r3,220(r2)
				& COMM_RMAP_HK_CCD1_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_TEMP_MSK) >> 16);
81109984:	e0bffe17 	ldw	r2,-8(fp)
81109988:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_17_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp = (alt_u16) ((uliReg
8110998c:	1007883a 	mov	r3,r2
81109990:	e0bfff17 	ldw	r2,-4(fp)
81109994:	10c0378d 	sth	r3,222(r2)
				& COMM_RMAP_HK_CCD2_TEMP_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109998:	e0bfff17 	ldw	r2,-4(fp)
8110999c:	10800017 	ldw	r2,0(r2)
811099a0:	01402c84 	movi	r5,178
811099a4:	1009883a 	mov	r4,r2
811099a8:	1109ef80 	call	81109ef8 <uliRmapReadReg>
811099ac:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_18_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp = (alt_u16) ((uliReg
811099b0:	e0bffe17 	ldw	r2,-8(fp)
811099b4:	1007883a 	mov	r3,r2
811099b8:	e0bfff17 	ldw	r2,-4(fp)
811099bc:	10c0380d 	sth	r3,224(r2)
				& COMM_RMAP_HK_CCD3_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_TEMP_MSK) >> 16);
811099c0:	e0bffe17 	ldw	r2,-8(fp)
811099c4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_18_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp = (alt_u16) ((uliReg
811099c8:	1007883a 	mov	r3,r2
811099cc:	e0bfff17 	ldw	r2,-4(fp)
811099d0:	10c0388d 	sth	r3,226(r2)
				& COMM_RMAP_HK_CCD4_TEMP_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811099d4:	e0bfff17 	ldw	r2,-4(fp)
811099d8:	10800017 	ldw	r2,0(r2)
811099dc:	01402cc4 	movi	r5,179
811099e0:	1009883a 	mov	r4,r2
811099e4:	1109ef80 	call	81109ef8 <uliRmapReadReg>
811099e8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_19_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkWp605Spare = (alt_u16) ((uliReg
811099ec:	e0bffe17 	ldw	r2,-8(fp)
811099f0:	1007883a 	mov	r3,r2
811099f4:	e0bfff17 	ldw	r2,-4(fp)
811099f8:	10c0390d 	sth	r3,228(r2)
				& COMM_RMAP_HK_WP605_SPARE_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_0_MSK) >> 16);
811099fc:	e0bffe17 	ldw	r2,-8(fp)
81109a00:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_19_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkWp605Spare = (alt_u16) ((uliReg
				& COMM_RMAP_HK_WP605_SPARE_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 = (alt_u16) ((uliReg
81109a04:	1007883a 	mov	r3,r2
81109a08:	e0bfff17 	ldw	r2,-4(fp)
81109a0c:	10c0398d 	sth	r3,230(r2)
				& COMM_RMAP_LOWRES_PRT_A_0_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109a10:	e0bfff17 	ldw	r2,-4(fp)
81109a14:	10800017 	ldw	r2,0(r2)
81109a18:	01402d04 	movi	r5,180
81109a1c:	1009883a 	mov	r4,r2
81109a20:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81109a24:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_20_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 = (alt_u16) ((uliReg
81109a28:	e0bffe17 	ldw	r2,-8(fp)
81109a2c:	1007883a 	mov	r3,r2
81109a30:	e0bfff17 	ldw	r2,-4(fp)
81109a34:	10c03a0d 	sth	r3,232(r2)
				& COMM_RMAP_LOWRES_PRT_A_1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_2_MSK) >> 16);
81109a38:	e0bffe17 	ldw	r2,-8(fp)
81109a3c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_20_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 = (alt_u16) ((uliReg
81109a40:	1007883a 	mov	r3,r2
81109a44:	e0bfff17 	ldw	r2,-4(fp)
81109a48:	10c03a8d 	sth	r3,234(r2)
				& COMM_RMAP_LOWRES_PRT_A_2_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109a4c:	e0bfff17 	ldw	r2,-4(fp)
81109a50:	10800017 	ldw	r2,0(r2)
81109a54:	01402d44 	movi	r5,181
81109a58:	1009883a 	mov	r4,r2
81109a5c:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81109a60:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_21_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 = (alt_u16) ((uliReg
81109a64:	e0bffe17 	ldw	r2,-8(fp)
81109a68:	1007883a 	mov	r3,r2
81109a6c:	e0bfff17 	ldw	r2,-4(fp)
81109a70:	10c03b0d 	sth	r3,236(r2)
				& COMM_RMAP_LOWRES_PRT_A_3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_4_MSK) >> 16);
81109a74:	e0bffe17 	ldw	r2,-8(fp)
81109a78:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_21_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 = (alt_u16) ((uliReg
81109a7c:	1007883a 	mov	r3,r2
81109a80:	e0bfff17 	ldw	r2,-4(fp)
81109a84:	10c03b8d 	sth	r3,238(r2)
				& COMM_RMAP_LOWRES_PRT_A_4_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109a88:	e0bfff17 	ldw	r2,-4(fp)
81109a8c:	10800017 	ldw	r2,0(r2)
81109a90:	01402d84 	movi	r5,182
81109a94:	1009883a 	mov	r4,r2
81109a98:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81109a9c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_22_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 = (alt_u16) ((uliReg
81109aa0:	e0bffe17 	ldw	r2,-8(fp)
81109aa4:	1007883a 	mov	r3,r2
81109aa8:	e0bfff17 	ldw	r2,-4(fp)
81109aac:	10c03c0d 	sth	r3,240(r2)
				& COMM_RMAP_LOWRES_PRT_A_5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_6_MSK) >> 16);
81109ab0:	e0bffe17 	ldw	r2,-8(fp)
81109ab4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_22_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 = (alt_u16) ((uliReg
81109ab8:	1007883a 	mov	r3,r2
81109abc:	e0bfff17 	ldw	r2,-4(fp)
81109ac0:	10c03c8d 	sth	r3,242(r2)
				& COMM_RMAP_LOWRES_PRT_A_6_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109ac4:	e0bfff17 	ldw	r2,-4(fp)
81109ac8:	10800017 	ldw	r2,0(r2)
81109acc:	01402dc4 	movi	r5,183
81109ad0:	1009883a 	mov	r4,r2
81109ad4:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81109ad8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_23_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 = (alt_u16) ((uliReg
81109adc:	e0bffe17 	ldw	r2,-8(fp)
81109ae0:	1007883a 	mov	r3,r2
81109ae4:	e0bfff17 	ldw	r2,-4(fp)
81109ae8:	10c03d0d 	sth	r3,244(r2)
				& COMM_RMAP_LOWRES_PRT_A_7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_8_MSK) >> 16);
81109aec:	e0bffe17 	ldw	r2,-8(fp)
81109af0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_23_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 = (alt_u16) ((uliReg
81109af4:	1007883a 	mov	r3,r2
81109af8:	e0bfff17 	ldw	r2,-4(fp)
81109afc:	10c03d8d 	sth	r3,246(r2)
				& COMM_RMAP_LOWRES_PRT_A_8_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109b00:	e0bfff17 	ldw	r2,-4(fp)
81109b04:	10800017 	ldw	r2,0(r2)
81109b08:	01402e04 	movi	r5,184
81109b0c:	1009883a 	mov	r4,r2
81109b10:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81109b14:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_24_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 = (alt_u16) ((uliReg
81109b18:	e0bffe17 	ldw	r2,-8(fp)
81109b1c:	1007883a 	mov	r3,r2
81109b20:	e0bfff17 	ldw	r2,-4(fp)
81109b24:	10c03e0d 	sth	r3,248(r2)
				& COMM_RMAP_LOWRES_PRT_A_9_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_10_MSK) >> 16);
81109b28:	e0bffe17 	ldw	r2,-8(fp)
81109b2c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_24_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_9_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 = (alt_u16) ((uliReg
81109b30:	1007883a 	mov	r3,r2
81109b34:	e0bfff17 	ldw	r2,-4(fp)
81109b38:	10c03e8d 	sth	r3,250(r2)
				& COMM_RMAP_LOWRES_PRT_A_10_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109b3c:	e0bfff17 	ldw	r2,-4(fp)
81109b40:	10800017 	ldw	r2,0(r2)
81109b44:	01402e44 	movi	r5,185
81109b48:	1009883a 	mov	r4,r2
81109b4c:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81109b50:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_25_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 = (alt_u16) ((uliReg
81109b54:	e0bffe17 	ldw	r2,-8(fp)
81109b58:	1007883a 	mov	r3,r2
81109b5c:	e0bfff17 	ldw	r2,-4(fp)
81109b60:	10c03f0d 	sth	r3,252(r2)
				& COMM_RMAP_LOWRES_PRT_A_11_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_12_MSK) >> 16);
81109b64:	e0bffe17 	ldw	r2,-8(fp)
81109b68:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_25_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_11_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 = (alt_u16) ((uliReg
81109b6c:	1007883a 	mov	r3,r2
81109b70:	e0bfff17 	ldw	r2,-4(fp)
81109b74:	10c03f8d 	sth	r3,254(r2)
				& COMM_RMAP_LOWRES_PRT_A_12_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109b78:	e0bfff17 	ldw	r2,-4(fp)
81109b7c:	10800017 	ldw	r2,0(r2)
81109b80:	01402e84 	movi	r5,186
81109b84:	1009883a 	mov	r4,r2
81109b88:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81109b8c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_26_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 = (alt_u16) ((uliReg
81109b90:	e0bffe17 	ldw	r2,-8(fp)
81109b94:	1007883a 	mov	r3,r2
81109b98:	e0bfff17 	ldw	r2,-4(fp)
81109b9c:	10c0400d 	sth	r3,256(r2)
				& COMM_RMAP_LOWRES_PRT_A_13_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_14_MSK) >> 16);
81109ba0:	e0bffe17 	ldw	r2,-8(fp)
81109ba4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_26_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_13_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 = (alt_u16) ((uliReg
81109ba8:	1007883a 	mov	r3,r2
81109bac:	e0bfff17 	ldw	r2,-4(fp)
81109bb0:	10c0408d 	sth	r3,258(r2)
				& COMM_RMAP_LOWRES_PRT_A_14_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109bb4:	e0bfff17 	ldw	r2,-4(fp)
81109bb8:	10800017 	ldw	r2,0(r2)
81109bbc:	01402ec4 	movi	r5,187
81109bc0:	1009883a 	mov	r4,r2
81109bc4:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81109bc8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_27_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 = (alt_u16) ((uliReg
81109bcc:	e0bffe17 	ldw	r2,-8(fp)
81109bd0:	1007883a 	mov	r3,r2
81109bd4:	e0bfff17 	ldw	r2,-4(fp)
81109bd8:	10c0410d 	sth	r3,260(r2)
				& COMM_RMAP_LOWRES_PRT_A_15_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT0_MSK) >> 16);
81109bdc:	e0bffe17 	ldw	r2,-8(fp)
81109be0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_27_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_15_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 = (alt_u16) ((uliReg
81109be4:	1007883a 	mov	r3,r2
81109be8:	e0bfff17 	ldw	r2,-4(fp)
81109bec:	10c0418d 	sth	r3,262(r2)
				& COMM_RMAP_SEL_HIRES_PRT0_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109bf0:	e0bfff17 	ldw	r2,-4(fp)
81109bf4:	10800017 	ldw	r2,0(r2)
81109bf8:	01402f04 	movi	r5,188
81109bfc:	1009883a 	mov	r4,r2
81109c00:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81109c04:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_28_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 = (alt_u16) ((uliReg
81109c08:	e0bffe17 	ldw	r2,-8(fp)
81109c0c:	1007883a 	mov	r3,r2
81109c10:	e0bfff17 	ldw	r2,-4(fp)
81109c14:	10c0420d 	sth	r3,264(r2)
				& COMM_RMAP_SEL_HIRES_PRT1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT2_MSK) >> 16);
81109c18:	e0bffe17 	ldw	r2,-8(fp)
81109c1c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_28_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 = (alt_u16) ((uliReg
81109c20:	1007883a 	mov	r3,r2
81109c24:	e0bfff17 	ldw	r2,-4(fp)
81109c28:	10c0428d 	sth	r3,266(r2)
				& COMM_RMAP_SEL_HIRES_PRT2_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109c2c:	e0bfff17 	ldw	r2,-4(fp)
81109c30:	10800017 	ldw	r2,0(r2)
81109c34:	01402f44 	movi	r5,189
81109c38:	1009883a 	mov	r4,r2
81109c3c:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81109c40:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_29_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 = (alt_u16) ((uliReg
81109c44:	e0bffe17 	ldw	r2,-8(fp)
81109c48:	1007883a 	mov	r3,r2
81109c4c:	e0bfff17 	ldw	r2,-4(fp)
81109c50:	10c0430d 	sth	r3,268(r2)
				& COMM_RMAP_SEL_HIRES_PRT3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT4_MSK) >> 16);
81109c54:	e0bffe17 	ldw	r2,-8(fp)
81109c58:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_29_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 = (alt_u16) ((uliReg
81109c5c:	1007883a 	mov	r3,r2
81109c60:	e0bfff17 	ldw	r2,-4(fp)
81109c64:	10c0438d 	sth	r3,270(r2)
				& COMM_RMAP_SEL_HIRES_PRT4_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109c68:	e0bfff17 	ldw	r2,-4(fp)
81109c6c:	10800017 	ldw	r2,0(r2)
81109c70:	01402f84 	movi	r5,190
81109c74:	1009883a 	mov	r4,r2
81109c78:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81109c7c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_30_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 = (alt_u16) ((uliReg
81109c80:	e0bffe17 	ldw	r2,-8(fp)
81109c84:	1007883a 	mov	r3,r2
81109c88:	e0bfff17 	ldw	r2,-4(fp)
81109c8c:	10c0440d 	sth	r3,272(r2)
				& COMM_RMAP_SEL_HIRES_PRT5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT6_MSK) >> 16);
81109c90:	e0bffe17 	ldw	r2,-8(fp)
81109c94:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_30_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 = (alt_u16) ((uliReg
81109c98:	1007883a 	mov	r3,r2
81109c9c:	e0bfff17 	ldw	r2,-4(fp)
81109ca0:	10c0448d 	sth	r3,274(r2)
				& COMM_RMAP_SEL_HIRES_PRT6_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109ca4:	e0bfff17 	ldw	r2,-4(fp)
81109ca8:	10800017 	ldw	r2,0(r2)
81109cac:	01402fc4 	movi	r5,191
81109cb0:	1009883a 	mov	r4,r2
81109cb4:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81109cb8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_31_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 = (alt_u16) ((uliReg
81109cbc:	e0bffe17 	ldw	r2,-8(fp)
81109cc0:	1007883a 	mov	r3,r2
81109cc4:	e0bfff17 	ldw	r2,-4(fp)
81109cc8:	10c0450d 	sth	r3,276(r2)
				& COMM_RMAP_SEL_HIRES_PRT7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp = (alt_u16) ((uliReg
				& COMM_RMAP_ZERO_HIRES_AMP_MSK) >> 16);
81109ccc:	e0bffe17 	ldw	r2,-8(fp)
81109cd0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_31_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp = (alt_u16) ((uliReg
81109cd4:	1007883a 	mov	r3,r2
81109cd8:	e0bfff17 	ldw	r2,-4(fp)
81109cdc:	10c0458d 	sth	r3,278(r2)
				& COMM_RMAP_ZERO_HIRES_AMP_MSK) >> 16);

		bStatus = TRUE;
81109ce0:	00800044 	movi	r2,1
81109ce4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81109ce8:	e0bffd17 	ldw	r2,-12(fp)
}
81109cec:	e037883a 	mov	sp,fp
81109cf0:	dfc00117 	ldw	ra,4(sp)
81109cf4:	df000017 	ldw	fp,0(sp)
81109cf8:	dec00204 	addi	sp,sp,8
81109cfc:	f800283a 	ret

81109d00 <bRmapInitCh>:

bool bRmapInitCh(TRmapChannel *pxRmapCh, alt_u8 ucCommCh) {
81109d00:	defffb04 	addi	sp,sp,-20
81109d04:	de00012e 	bgeu	sp,et,81109d0c <bRmapInitCh+0xc>
81109d08:	003b68fa 	trap	3
81109d0c:	dfc00415 	stw	ra,16(sp)
81109d10:	df000315 	stw	fp,12(sp)
81109d14:	df000304 	addi	fp,sp,12
81109d18:	e13ffe15 	stw	r4,-8(fp)
81109d1c:	2805883a 	mov	r2,r5
81109d20:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81109d24:	e03ffd15 	stw	zero,-12(fp)

	if (pxRmapCh != NULL) {
81109d28:	e0bffe17 	ldw	r2,-8(fp)
81109d2c:	10005726 	beq	r2,zero,81109e8c <bRmapInitCh+0x18c>
		bStatus = TRUE;
81109d30:	00800044 	movi	r2,1
81109d34:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81109d38:	e0bfff03 	ldbu	r2,-4(fp)
81109d3c:	10c00228 	cmpgeui	r3,r2,8
81109d40:	1800361e 	bne	r3,zero,81109e1c <bRmapInitCh+0x11c>
81109d44:	100690ba 	slli	r3,r2,2
81109d48:	00a04474 	movhi	r2,33041
81109d4c:	10a75704 	addi	r2,r2,-25252
81109d50:	1885883a 	add	r2,r3,r2
81109d54:	10800017 	ldw	r2,0(r2)
81109d58:	1000683a 	jmp	r2
81109d5c:	81109d7c 	xorhi	r4,r16,17013
81109d60:	81109d90 	cmplti	r4,r16,17014
81109d64:	81109da4 	muli	r4,r16,17014
81109d68:	81109db8 	rdprs	r4,r16,17014
81109d6c:	81109dcc 	andi	r4,r16,17015
81109d70:	81109de0 	cmpeqi	r4,r16,17015
81109d74:	81109df4 	orhi	r4,r16,17015
81109d78:	81109e08 	cmpgei	r4,r16,17016
		case eCommSpwCh1:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81109d7c:	e0fffe17 	ldw	r3,-8(fp)
81109d80:	00a04834 	movhi	r2,33056
81109d84:	108b0004 	addi	r2,r2,11264
81109d88:	18800015 	stw	r2,0(r3)
			break;
81109d8c:	00002506 	br	81109e24 <bRmapInitCh+0x124>
		case eCommSpwCh2:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81109d90:	e0fffe17 	ldw	r3,-8(fp)
81109d94:	00a04834 	movhi	r2,33056
81109d98:	108a0004 	addi	r2,r2,10240
81109d9c:	18800015 	stw	r2,0(r3)
			break;
81109da0:	00002006 	br	81109e24 <bRmapInitCh+0x124>
		case eCommSpwCh3:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81109da4:	e0fffe17 	ldw	r3,-8(fp)
81109da8:	00a04834 	movhi	r2,33056
81109dac:	108b0004 	addi	r2,r2,11264
81109db0:	18800015 	stw	r2,0(r3)
			break;
81109db4:	00001b06 	br	81109e24 <bRmapInitCh+0x124>
		case eCommSpwCh4:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81109db8:	e0fffe17 	ldw	r3,-8(fp)
81109dbc:	00a04834 	movhi	r2,33056
81109dc0:	108a0004 	addi	r2,r2,10240
81109dc4:	18800015 	stw	r2,0(r3)
			break;
81109dc8:	00001606 	br	81109e24 <bRmapInitCh+0x124>
		case eCommSpwCh5:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81109dcc:	e0fffe17 	ldw	r3,-8(fp)
81109dd0:	00a04834 	movhi	r2,33056
81109dd4:	108b0004 	addi	r2,r2,11264
81109dd8:	18800015 	stw	r2,0(r3)
			break;
81109ddc:	00001106 	br	81109e24 <bRmapInitCh+0x124>
		case eCommSpwCh6:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81109de0:	e0fffe17 	ldw	r3,-8(fp)
81109de4:	00a04834 	movhi	r2,33056
81109de8:	108a0004 	addi	r2,r2,10240
81109dec:	18800015 	stw	r2,0(r3)
			break;
81109df0:	00000c06 	br	81109e24 <bRmapInitCh+0x124>
		case eCommSpwCh7:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81109df4:	e0fffe17 	ldw	r3,-8(fp)
81109df8:	00a04834 	movhi	r2,33056
81109dfc:	108b0004 	addi	r2,r2,11264
81109e00:	18800015 	stw	r2,0(r3)
			break;
81109e04:	00000706 	br	81109e24 <bRmapInitCh+0x124>
		case eCommSpwCh8:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81109e08:	e0fffe17 	ldw	r3,-8(fp)
81109e0c:	00a04834 	movhi	r2,33056
81109e10:	108a0004 	addi	r2,r2,10240
81109e14:	18800015 	stw	r2,0(r3)
			break;
81109e18:	00000206 	br	81109e24 <bRmapInitCh+0x124>
		default:
			bStatus = FALSE;
81109e1c:	e03ffd15 	stw	zero,-12(fp)
			break;
81109e20:	0001883a 	nop
		}

		if (bStatus) {
81109e24:	e0bffd17 	ldw	r2,-12(fp)
81109e28:	10001826 	beq	r2,zero,81109e8c <bRmapInitCh+0x18c>
			if (!bRmapGetIrqControl(pxRmapCh)) {
81109e2c:	e13ffe17 	ldw	r4,-8(fp)
81109e30:	11079600 	call	81107960 <bRmapGetIrqControl>
81109e34:	1000011e 	bne	r2,zero,81109e3c <bRmapInitCh+0x13c>
				bStatus = FALSE;
81109e38:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetCodecConfig(pxRmapCh)) {
81109e3c:	e13ffe17 	ldw	r4,-8(fp)
81109e40:	1107b480 	call	81107b48 <bRmapGetCodecConfig>
81109e44:	1000011e 	bne	r2,zero,81109e4c <bRmapInitCh+0x14c>
				bStatus = FALSE;
81109e48:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetCodecStatus(pxRmapCh)) {
81109e4c:	e13ffe17 	ldw	r4,-8(fp)
81109e50:	1107bd40 	call	81107bd4 <bRmapGetCodecStatus>
81109e54:	1000011e 	bne	r2,zero,81109e5c <bRmapInitCh+0x15c>
				bStatus = FALSE;
81109e58:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetMemConfigArea(pxRmapCh)) {
81109e5c:	e13ffe17 	ldw	r4,-8(fp)
81109e60:	11081800 	call	81108180 <bRmapGetMemConfigArea>
81109e64:	1000011e 	bne	r2,zero,81109e6c <bRmapInitCh+0x16c>
				bStatus = FALSE;
81109e68:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetMemConfigStat(pxRmapCh)) {
81109e6c:	e13ffe17 	ldw	r4,-8(fp)
81109e70:	11084540 	call	81108454 <bRmapGetMemConfigStat>
81109e74:	1000011e 	bne	r2,zero,81109e7c <bRmapInitCh+0x17c>
				bStatus = FALSE;
81109e78:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetRmapMemHKArea(pxRmapCh)) {
81109e7c:	e13ffe17 	ldw	r4,-8(fp)
81109e80:	11095340 	call	81109534 <bRmapGetRmapMemHKArea>
81109e84:	1000011e 	bne	r2,zero,81109e8c <bRmapInitCh+0x18c>
				bStatus = FALSE;
81109e88:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81109e8c:	e0bffd17 	ldw	r2,-12(fp)
}
81109e90:	e037883a 	mov	sp,fp
81109e94:	dfc00117 	ldw	ra,4(sp)
81109e98:	df000017 	ldw	fp,0(sp)
81109e9c:	dec00204 	addi	sp,sp,8
81109ea0:	f800283a 	ret

81109ea4 <vRmapWriteReg>:
//! [public functions]

//! [private functions]
static void vRmapWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81109ea4:	defffc04 	addi	sp,sp,-16
81109ea8:	de00012e 	bgeu	sp,et,81109eb0 <vRmapWriteReg+0xc>
81109eac:	003b68fa 	trap	3
81109eb0:	df000315 	stw	fp,12(sp)
81109eb4:	df000304 	addi	fp,sp,12
81109eb8:	e13ffd15 	stw	r4,-12(fp)
81109ebc:	e17ffe15 	stw	r5,-8(fp)
81109ec0:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81109ec4:	e0bffe17 	ldw	r2,-8(fp)
81109ec8:	1085883a 	add	r2,r2,r2
81109ecc:	1085883a 	add	r2,r2,r2
81109ed0:	1007883a 	mov	r3,r2
81109ed4:	e0bffd17 	ldw	r2,-12(fp)
81109ed8:	10c5883a 	add	r2,r2,r3
81109edc:	e0ffff17 	ldw	r3,-4(fp)
81109ee0:	10c00015 	stw	r3,0(r2)
}
81109ee4:	0001883a 	nop
81109ee8:	e037883a 	mov	sp,fp
81109eec:	df000017 	ldw	fp,0(sp)
81109ef0:	dec00104 	addi	sp,sp,4
81109ef4:	f800283a 	ret

81109ef8 <uliRmapReadReg>:

alt_u32 uliRmapReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81109ef8:	defffc04 	addi	sp,sp,-16
81109efc:	de00012e 	bgeu	sp,et,81109f04 <uliRmapReadReg+0xc>
81109f00:	003b68fa 	trap	3
81109f04:	df000315 	stw	fp,12(sp)
81109f08:	df000304 	addi	fp,sp,12
81109f0c:	e13ffe15 	stw	r4,-8(fp)
81109f10:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81109f14:	e0bfff17 	ldw	r2,-4(fp)
81109f18:	1085883a 	add	r2,r2,r2
81109f1c:	1085883a 	add	r2,r2,r2
81109f20:	1007883a 	mov	r3,r2
81109f24:	e0bffe17 	ldw	r2,-8(fp)
81109f28:	10c5883a 	add	r2,r2,r3
81109f2c:	10800017 	ldw	r2,0(r2)
81109f30:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81109f34:	e0bffd17 	ldw	r2,-12(fp)
}
81109f38:	e037883a 	mov	sp,fp
81109f3c:	df000017 	ldw	fp,0(sp)
81109f40:	dec00104 	addi	sp,sp,4
81109f44:	f800283a 	ret

81109f48 <uliConvRmapCfgAddr>:

static alt_u32 uliConvRmapCfgAddr(alt_u32 puliRmapAddr) {
81109f48:	defffd04 	addi	sp,sp,-12
81109f4c:	de00012e 	bgeu	sp,et,81109f54 <uliConvRmapCfgAddr+0xc>
81109f50:	003b68fa 	trap	3
81109f54:	df000215 	stw	fp,8(sp)
81109f58:	df000204 	addi	fp,sp,8
81109f5c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliValue;

	switch (puliRmapAddr) {
81109f60:	e0bfff17 	ldw	r2,-4(fp)
81109f64:	10801368 	cmpgeui	r2,r2,77
81109f68:	10008a1e 	bne	r2,zero,8110a194 <uliConvRmapCfgAddr+0x24c>
81109f6c:	e0bfff17 	ldw	r2,-4(fp)
81109f70:	100690ba 	slli	r3,r2,2
81109f74:	00a04474 	movhi	r2,33041
81109f78:	10a7e204 	addi	r2,r2,-24696
81109f7c:	1885883a 	add	r2,r3,r2
81109f80:	10800017 	ldw	r2,0(r2)
81109f84:	1000683a 	jmp	r2
81109f88:	8110a0bc 	xorhi	r4,r16,17026
81109f8c:	8110a194 	ori	r4,r16,17030
81109f90:	8110a194 	ori	r4,r16,17030
81109f94:	8110a194 	ori	r4,r16,17030
81109f98:	8110a0c8 	cmpgei	r4,r16,17027
81109f9c:	8110a194 	ori	r4,r16,17030
81109fa0:	8110a194 	ori	r4,r16,17030
81109fa4:	8110a194 	ori	r4,r16,17030
81109fa8:	8110a0d4 	ori	r4,r16,17027
81109fac:	8110a194 	ori	r4,r16,17030
81109fb0:	8110a194 	ori	r4,r16,17030
81109fb4:	8110a194 	ori	r4,r16,17030
81109fb8:	8110a0e0 	cmpeqi	r4,r16,17027
81109fbc:	8110a194 	ori	r4,r16,17030
81109fc0:	8110a194 	ori	r4,r16,17030
81109fc4:	8110a194 	ori	r4,r16,17030
81109fc8:	8110a0ec 	andhi	r4,r16,17027
81109fcc:	8110a194 	ori	r4,r16,17030
81109fd0:	8110a194 	ori	r4,r16,17030
81109fd4:	8110a194 	ori	r4,r16,17030
81109fd8:	8110a0f8 	rdprs	r4,r16,17027
81109fdc:	8110a194 	ori	r4,r16,17030
81109fe0:	8110a194 	ori	r4,r16,17030
81109fe4:	8110a194 	ori	r4,r16,17030
81109fe8:	8110a104 	addi	r4,r16,17028
81109fec:	8110a194 	ori	r4,r16,17030
81109ff0:	8110a194 	ori	r4,r16,17030
81109ff4:	8110a194 	ori	r4,r16,17030
81109ff8:	8110a110 	cmplti	r4,r16,17028
81109ffc:	8110a194 	ori	r4,r16,17030
8110a000:	8110a194 	ori	r4,r16,17030
8110a004:	8110a194 	ori	r4,r16,17030
8110a008:	8110a11c 	xori	r4,r16,17028
8110a00c:	8110a194 	ori	r4,r16,17030
8110a010:	8110a194 	ori	r4,r16,17030
8110a014:	8110a194 	ori	r4,r16,17030
8110a018:	8110a128 	cmpgeui	r4,r16,17028
8110a01c:	8110a194 	ori	r4,r16,17030
8110a020:	8110a194 	ori	r4,r16,17030
8110a024:	8110a194 	ori	r4,r16,17030
8110a028:	8110a134 	orhi	r4,r16,17028
8110a02c:	8110a194 	ori	r4,r16,17030
8110a030:	8110a194 	ori	r4,r16,17030
8110a034:	8110a194 	ori	r4,r16,17030
8110a038:	8110a140 	call	88110a14 <__reset+0x20f0a14>
8110a03c:	8110a194 	ori	r4,r16,17030
8110a040:	8110a194 	ori	r4,r16,17030
8110a044:	8110a194 	ori	r4,r16,17030
8110a048:	8110a194 	ori	r4,r16,17030
8110a04c:	8110a194 	ori	r4,r16,17030
8110a050:	8110a194 	ori	r4,r16,17030
8110a054:	8110a194 	ori	r4,r16,17030
8110a058:	8110a194 	ori	r4,r16,17030
8110a05c:	8110a194 	ori	r4,r16,17030
8110a060:	8110a194 	ori	r4,r16,17030
8110a064:	8110a194 	ori	r4,r16,17030
8110a068:	8110a14c 	andi	r4,r16,17029
8110a06c:	8110a194 	ori	r4,r16,17030
8110a070:	8110a194 	ori	r4,r16,17030
8110a074:	8110a194 	ori	r4,r16,17030
8110a078:	8110a158 	cmpnei	r4,r16,17029
8110a07c:	8110a194 	ori	r4,r16,17030
8110a080:	8110a194 	ori	r4,r16,17030
8110a084:	8110a194 	ori	r4,r16,17030
8110a088:	8110a164 	muli	r4,r16,17029
8110a08c:	8110a194 	ori	r4,r16,17030
8110a090:	8110a194 	ori	r4,r16,17030
8110a094:	8110a194 	ori	r4,r16,17030
8110a098:	8110a170 	cmpltui	r4,r16,17029
8110a09c:	8110a194 	ori	r4,r16,17030
8110a0a0:	8110a194 	ori	r4,r16,17030
8110a0a4:	8110a194 	ori	r4,r16,17030
8110a0a8:	8110a17c 	xorhi	r4,r16,17029
8110a0ac:	8110a194 	ori	r4,r16,17030
8110a0b0:	8110a194 	ori	r4,r16,17030
8110a0b4:	8110a194 	ori	r4,r16,17030
8110a0b8:	8110a188 	cmpgei	r4,r16,17030
	case 0x00000000:
		uliValue = 0x00000040;
8110a0bc:	00801004 	movi	r2,64
8110a0c0:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a0c4:	00003506 	br	8110a19c <uliConvRmapCfgAddr+0x254>
	case 0x00000004:
		uliValue = 0x00000041;
8110a0c8:	00801044 	movi	r2,65
8110a0cc:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a0d0:	00003206 	br	8110a19c <uliConvRmapCfgAddr+0x254>
	case 0x00000008:
		uliValue = 0x00000042;
8110a0d4:	00801084 	movi	r2,66
8110a0d8:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a0dc:	00002f06 	br	8110a19c <uliConvRmapCfgAddr+0x254>
	case 0x0000000C:
		uliValue = 0x00000043;
8110a0e0:	008010c4 	movi	r2,67
8110a0e4:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a0e8:	00002c06 	br	8110a19c <uliConvRmapCfgAddr+0x254>
	case 0x00000010:
		uliValue = 0x00000044;
8110a0ec:	00801104 	movi	r2,68
8110a0f0:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a0f4:	00002906 	br	8110a19c <uliConvRmapCfgAddr+0x254>
	case 0x00000014:
		uliValue = 0x00000045;
8110a0f8:	00801144 	movi	r2,69
8110a0fc:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a100:	00002606 	br	8110a19c <uliConvRmapCfgAddr+0x254>
	case 0x00000018:
		uliValue = 0x00000046;
8110a104:	00801184 	movi	r2,70
8110a108:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a10c:	00002306 	br	8110a19c <uliConvRmapCfgAddr+0x254>
	case 0x0000001C:
		uliValue = 0x00000047;
8110a110:	008011c4 	movi	r2,71
8110a114:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a118:	00002006 	br	8110a19c <uliConvRmapCfgAddr+0x254>
	case 0x00000020:
		uliValue = 0x00000048;
8110a11c:	00801204 	movi	r2,72
8110a120:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a124:	00001d06 	br	8110a19c <uliConvRmapCfgAddr+0x254>
	case 0x00000024:
		uliValue = 0x00000049;
8110a128:	00801244 	movi	r2,73
8110a12c:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a130:	00001a06 	br	8110a19c <uliConvRmapCfgAddr+0x254>
	case 0x00000028:
		uliValue = 0x0000004A;
8110a134:	00801284 	movi	r2,74
8110a138:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a13c:	00001706 	br	8110a19c <uliConvRmapCfgAddr+0x254>
	case 0x0000002C:
		uliValue = 0x0000004B;
8110a140:	008012c4 	movi	r2,75
8110a144:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a148:	00001406 	br	8110a19c <uliConvRmapCfgAddr+0x254>
	case 0x00000038:
		uliValue = 0x0000004C;
8110a14c:	00801304 	movi	r2,76
8110a150:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a154:	00001106 	br	8110a19c <uliConvRmapCfgAddr+0x254>
	case 0x0000003C:
		uliValue = 0x0000004D;
8110a158:	00801344 	movi	r2,77
8110a15c:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a160:	00000e06 	br	8110a19c <uliConvRmapCfgAddr+0x254>
	case 0x00000040:
		uliValue = 0x0000004E;
8110a164:	00801384 	movi	r2,78
8110a168:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a16c:	00000b06 	br	8110a19c <uliConvRmapCfgAddr+0x254>
	case 0x00000044:
		uliValue = 0x0000004F;
8110a170:	008013c4 	movi	r2,79
8110a174:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a178:	00000806 	br	8110a19c <uliConvRmapCfgAddr+0x254>
	case 0x00000048:
		uliValue = 0x00000050;
8110a17c:	00801404 	movi	r2,80
8110a180:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a184:	00000506 	br	8110a19c <uliConvRmapCfgAddr+0x254>
	case 0x0000004C:
		uliValue = 0x00000051;
8110a188:	00801444 	movi	r2,81
8110a18c:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a190:	00000206 	br	8110a19c <uliConvRmapCfgAddr+0x254>
	default:
		uliValue = 0x00000000;
8110a194:	e03ffe15 	stw	zero,-8(fp)
		break;
8110a198:	0001883a 	nop
	}

	return uliValue;
8110a19c:	e0bffe17 	ldw	r2,-8(fp)
}
8110a1a0:	e037883a 	mov	sp,fp
8110a1a4:	df000017 	ldw	fp,0(sp)
8110a1a8:	dec00104 	addi	sp,sp,4
8110a1ac:	f800283a 	ret

8110a1b0 <bSpwcSetLink>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bSpwcSetLink(TSpwcChannel *pxSpwcCh) {
8110a1b0:	defffb04 	addi	sp,sp,-20
8110a1b4:	de00012e 	bgeu	sp,et,8110a1bc <bSpwcSetLink+0xc>
8110a1b8:	003b68fa 	trap	3
8110a1bc:	dfc00415 	stw	ra,16(sp)
8110a1c0:	df000315 	stw	fp,12(sp)
8110a1c4:	df000304 	addi	fp,sp,12
8110a1c8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110a1cc:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110a1d0:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110a1d4:	e0bfff17 	ldw	r2,-4(fp)
8110a1d8:	10003c26 	beq	r2,zero,8110a2cc <bSpwcSetLink+0x11c>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110a1dc:	e0bfff17 	ldw	r2,-4(fp)
8110a1e0:	10800017 	ldw	r2,0(r2)
8110a1e4:	000b883a 	mov	r5,zero
8110a1e8:	1009883a 	mov	r4,r2
8110a1ec:	110a87c0 	call	8110a87c <uliSpwcReadReg>
8110a1f0:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (pxSpwcCh->xLinkConfig.bAutostart) {
8110a1f4:	e0bfff17 	ldw	r2,-4(fp)
8110a1f8:	10800117 	ldw	r2,4(r2)
8110a1fc:	10000426 	beq	r2,zero,8110a210 <bSpwcSetLink+0x60>
			uliReg |= COMM_SPW_LNKCFG_AUTOSTART_MSK;
8110a200:	e0bffe17 	ldw	r2,-8(fp)
8110a204:	10800114 	ori	r2,r2,4
8110a208:	e0bffe15 	stw	r2,-8(fp)
8110a20c:	00000406 	br	8110a220 <bSpwcSetLink+0x70>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_AUTOSTART_MSK);
8110a210:	e0fffe17 	ldw	r3,-8(fp)
8110a214:	00bffec4 	movi	r2,-5
8110a218:	1884703a 	and	r2,r3,r2
8110a21c:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxSpwcCh->xLinkConfig.bLinkStart) {
8110a220:	e0bfff17 	ldw	r2,-4(fp)
8110a224:	10800217 	ldw	r2,8(r2)
8110a228:	10000426 	beq	r2,zero,8110a23c <bSpwcSetLink+0x8c>
			uliReg |= COMM_SPW_LNKCFG_LINKSTART_MSK;
8110a22c:	e0bffe17 	ldw	r2,-8(fp)
8110a230:	10800094 	ori	r2,r2,2
8110a234:	e0bffe15 	stw	r2,-8(fp)
8110a238:	00000406 	br	8110a24c <bSpwcSetLink+0x9c>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_LINKSTART_MSK);
8110a23c:	e0fffe17 	ldw	r3,-8(fp)
8110a240:	00bfff44 	movi	r2,-3
8110a244:	1884703a 	and	r2,r3,r2
8110a248:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxSpwcCh->xLinkConfig.bDisconnect) {
8110a24c:	e0bfff17 	ldw	r2,-4(fp)
8110a250:	10800317 	ldw	r2,12(r2)
8110a254:	10000426 	beq	r2,zero,8110a268 <bSpwcSetLink+0xb8>
			uliReg |= COMM_SPW_LNKCFG_DISCONNECT_MSK;
8110a258:	e0bffe17 	ldw	r2,-8(fp)
8110a25c:	10800054 	ori	r2,r2,1
8110a260:	e0bffe15 	stw	r2,-8(fp)
8110a264:	00000406 	br	8110a278 <bSpwcSetLink+0xc8>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_DISCONNECT_MSK);
8110a268:	e0fffe17 	ldw	r3,-8(fp)
8110a26c:	00bfff84 	movi	r2,-2
8110a270:	1884703a 	and	r2,r3,r2
8110a274:	e0bffe15 	stw	r2,-8(fp)
		}
		uliReg &= (~COMM_SPW_LNKCFG_TXDIVCNT_MSK);
8110a278:	e0fffe17 	ldw	r3,-8(fp)
8110a27c:	00804034 	movhi	r2,256
8110a280:	10bfffc4 	addi	r2,r2,-1
8110a284:	1884703a 	and	r2,r3,r2
8110a288:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_SPW_LNKCFG_TXDIVCNT_MSK
				& (alt_u32)(pxSpwcCh->xLinkConfig.ucTxDivCnt << 24));
8110a28c:	e0bfff17 	ldw	r2,-4(fp)
8110a290:	10800403 	ldbu	r2,16(r2)
8110a294:	10803fcc 	andi	r2,r2,255
8110a298:	1004963a 	slli	r2,r2,24
8110a29c:	1007883a 	mov	r3,r2
			uliReg |= COMM_SPW_LNKCFG_DISCONNECT_MSK;
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_DISCONNECT_MSK);
		}
		uliReg &= (~COMM_SPW_LNKCFG_TXDIVCNT_MSK);
		uliReg |= (COMM_SPW_LNKCFG_TXDIVCNT_MSK
8110a2a0:	e0bffe17 	ldw	r2,-8(fp)
8110a2a4:	10c4b03a 	or	r2,r2,r3
8110a2a8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxSpwcCh->xLinkConfig.ucTxDivCnt << 24));

		vSpwcWriteReg(pxSpwcCh->puliSpwcChAddr, COMM_LINK_CFG_STAT_REG_OFST,
8110a2ac:	e0bfff17 	ldw	r2,-4(fp)
8110a2b0:	10800017 	ldw	r2,0(r2)
8110a2b4:	e1bffe17 	ldw	r6,-8(fp)
8110a2b8:	000b883a 	mov	r5,zero
8110a2bc:	1009883a 	mov	r4,r2
8110a2c0:	110a8280 	call	8110a828 <vSpwcWriteReg>
				uliReg);
		bStatus = TRUE;
8110a2c4:	00800044 	movi	r2,1
8110a2c8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a2cc:	e0bffd17 	ldw	r2,-12(fp)
}
8110a2d0:	e037883a 	mov	sp,fp
8110a2d4:	dfc00117 	ldw	ra,4(sp)
8110a2d8:	df000017 	ldw	fp,0(sp)
8110a2dc:	dec00204 	addi	sp,sp,8
8110a2e0:	f800283a 	ret

8110a2e4 <bSpwcGetLink>:

bool bSpwcGetLink(TSpwcChannel *pxSpwcCh) {
8110a2e4:	defffb04 	addi	sp,sp,-20
8110a2e8:	de00012e 	bgeu	sp,et,8110a2f0 <bSpwcGetLink+0xc>
8110a2ec:	003b68fa 	trap	3
8110a2f0:	dfc00415 	stw	ra,16(sp)
8110a2f4:	df000315 	stw	fp,12(sp)
8110a2f8:	df000304 	addi	fp,sp,12
8110a2fc:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110a300:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110a304:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110a308:	e0bfff17 	ldw	r2,-4(fp)
8110a30c:	10002826 	beq	r2,zero,8110a3b0 <bSpwcGetLink+0xcc>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110a310:	e0bfff17 	ldw	r2,-4(fp)
8110a314:	10800017 	ldw	r2,0(r2)
8110a318:	000b883a 	mov	r5,zero
8110a31c:	1009883a 	mov	r4,r2
8110a320:	110a87c0 	call	8110a87c <uliSpwcReadReg>
8110a324:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKCFG_AUTOSTART_MSK) {
8110a328:	e0bffe17 	ldw	r2,-8(fp)
8110a32c:	1080010c 	andi	r2,r2,4
8110a330:	10000426 	beq	r2,zero,8110a344 <bSpwcGetLink+0x60>
			pxSpwcCh->xLinkConfig.bAutostart = TRUE;
8110a334:	e0bfff17 	ldw	r2,-4(fp)
8110a338:	00c00044 	movi	r3,1
8110a33c:	10c00115 	stw	r3,4(r2)
8110a340:	00000206 	br	8110a34c <bSpwcGetLink+0x68>
		} else {
			pxSpwcCh->xLinkConfig.bAutostart = FALSE;
8110a344:	e0bfff17 	ldw	r2,-4(fp)
8110a348:	10000115 	stw	zero,4(r2)
		}
		if (uliReg & COMM_SPW_LNKCFG_LINKSTART_MSK) {
8110a34c:	e0bffe17 	ldw	r2,-8(fp)
8110a350:	1080008c 	andi	r2,r2,2
8110a354:	10000426 	beq	r2,zero,8110a368 <bSpwcGetLink+0x84>
			pxSpwcCh->xLinkConfig.bLinkStart = TRUE;
8110a358:	e0bfff17 	ldw	r2,-4(fp)
8110a35c:	00c00044 	movi	r3,1
8110a360:	10c00215 	stw	r3,8(r2)
8110a364:	00000206 	br	8110a370 <bSpwcGetLink+0x8c>
		} else {
			pxSpwcCh->xLinkConfig.bLinkStart = FALSE;
8110a368:	e0bfff17 	ldw	r2,-4(fp)
8110a36c:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_SPW_LNKCFG_DISCONNECT_MSK) {
8110a370:	e0bffe17 	ldw	r2,-8(fp)
8110a374:	1080004c 	andi	r2,r2,1
8110a378:	10000426 	beq	r2,zero,8110a38c <bSpwcGetLink+0xa8>
			pxSpwcCh->xLinkConfig.bDisconnect = TRUE;
8110a37c:	e0bfff17 	ldw	r2,-4(fp)
8110a380:	00c00044 	movi	r3,1
8110a384:	10c00315 	stw	r3,12(r2)
8110a388:	00000206 	br	8110a394 <bSpwcGetLink+0xb0>
		} else {
			pxSpwcCh->xLinkConfig.bDisconnect = FALSE;
8110a38c:	e0bfff17 	ldw	r2,-4(fp)
8110a390:	10000315 	stw	zero,12(r2)
		}
		pxSpwcCh->xLinkConfig.ucTxDivCnt= (alt_u8)(
				(uliReg & COMM_SPW_LNKCFG_TXDIVCNT_MSK) >> 24);
8110a394:	e0bffe17 	ldw	r2,-8(fp)
8110a398:	1004d63a 	srli	r2,r2,24
		if (uliReg & COMM_SPW_LNKCFG_DISCONNECT_MSK) {
			pxSpwcCh->xLinkConfig.bDisconnect = TRUE;
		} else {
			pxSpwcCh->xLinkConfig.bDisconnect = FALSE;
		}
		pxSpwcCh->xLinkConfig.ucTxDivCnt= (alt_u8)(
8110a39c:	1007883a 	mov	r3,r2
8110a3a0:	e0bfff17 	ldw	r2,-4(fp)
8110a3a4:	10c00405 	stb	r3,16(r2)
				(uliReg & COMM_SPW_LNKCFG_TXDIVCNT_MSK) >> 24);

		bStatus = TRUE;
8110a3a8:	00800044 	movi	r2,1
8110a3ac:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a3b0:	e0bffd17 	ldw	r2,-12(fp)
}
8110a3b4:	e037883a 	mov	sp,fp
8110a3b8:	dfc00117 	ldw	ra,4(sp)
8110a3bc:	df000017 	ldw	fp,0(sp)
8110a3c0:	dec00204 	addi	sp,sp,8
8110a3c4:	f800283a 	ret

8110a3c8 <bSpwcGetLinkError>:

bool bSpwcGetLinkError(TSpwcChannel *pxSpwcCh) {
8110a3c8:	defffb04 	addi	sp,sp,-20
8110a3cc:	de00012e 	bgeu	sp,et,8110a3d4 <bSpwcGetLinkError+0xc>
8110a3d0:	003b68fa 	trap	3
8110a3d4:	dfc00415 	stw	ra,16(sp)
8110a3d8:	df000315 	stw	fp,12(sp)
8110a3dc:	df000304 	addi	fp,sp,12
8110a3e0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110a3e4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110a3e8:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110a3ec:	e0bfff17 	ldw	r2,-4(fp)
8110a3f0:	10002c26 	beq	r2,zero,8110a4a4 <bSpwcGetLinkError+0xdc>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110a3f4:	e0bfff17 	ldw	r2,-4(fp)
8110a3f8:	10800017 	ldw	r2,0(r2)
8110a3fc:	000b883a 	mov	r5,zero
8110a400:	1009883a 	mov	r4,r2
8110a404:	110a87c0 	call	8110a87c <uliSpwcReadReg>
8110a408:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKERR_DISCONNECT_MSK) {
8110a40c:	e0bffe17 	ldw	r2,-8(fp)
8110a410:	1080006c 	andhi	r2,r2,1
8110a414:	10000426 	beq	r2,zero,8110a428 <bSpwcGetLinkError+0x60>
			pxSpwcCh->xLinkError.bDisconnect = TRUE;
8110a418:	e0bfff17 	ldw	r2,-4(fp)
8110a41c:	00c00044 	movi	r3,1
8110a420:	10c00515 	stw	r3,20(r2)
8110a424:	00000206 	br	8110a430 <bSpwcGetLinkError+0x68>
		} else {
			pxSpwcCh->xLinkError.bDisconnect = FALSE;
8110a428:	e0bfff17 	ldw	r2,-4(fp)
8110a42c:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_PARITY_MSK) {
8110a430:	e0bffe17 	ldw	r2,-8(fp)
8110a434:	108000ac 	andhi	r2,r2,2
8110a438:	10000426 	beq	r2,zero,8110a44c <bSpwcGetLinkError+0x84>
			pxSpwcCh->xLinkError.bParity = TRUE;
8110a43c:	e0bfff17 	ldw	r2,-4(fp)
8110a440:	00c00044 	movi	r3,1
8110a444:	10c00615 	stw	r3,24(r2)
8110a448:	00000206 	br	8110a454 <bSpwcGetLinkError+0x8c>
		} else {
			pxSpwcCh->xLinkError.bParity = FALSE;
8110a44c:	e0bfff17 	ldw	r2,-4(fp)
8110a450:	10000615 	stw	zero,24(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_ESCAPE_MSK) {
8110a454:	e0bffe17 	ldw	r2,-8(fp)
8110a458:	1080012c 	andhi	r2,r2,4
8110a45c:	10000426 	beq	r2,zero,8110a470 <bSpwcGetLinkError+0xa8>
			pxSpwcCh->xLinkError.bEscape = TRUE;
8110a460:	e0bfff17 	ldw	r2,-4(fp)
8110a464:	00c00044 	movi	r3,1
8110a468:	10c00715 	stw	r3,28(r2)
8110a46c:	00000206 	br	8110a478 <bSpwcGetLinkError+0xb0>
		} else {
			pxSpwcCh->xLinkError.bEscape = FALSE;
8110a470:	e0bfff17 	ldw	r2,-4(fp)
8110a474:	10000715 	stw	zero,28(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_CREDIT_MSK) {
8110a478:	e0bffe17 	ldw	r2,-8(fp)
8110a47c:	1080022c 	andhi	r2,r2,8
8110a480:	10000426 	beq	r2,zero,8110a494 <bSpwcGetLinkError+0xcc>
			pxSpwcCh->xLinkError.bCredit = TRUE;
8110a484:	e0bfff17 	ldw	r2,-4(fp)
8110a488:	00c00044 	movi	r3,1
8110a48c:	10c00815 	stw	r3,32(r2)
8110a490:	00000206 	br	8110a49c <bSpwcGetLinkError+0xd4>
		} else {
			pxSpwcCh->xLinkError.bCredit = FALSE;
8110a494:	e0bfff17 	ldw	r2,-4(fp)
8110a498:	10000815 	stw	zero,32(r2)
		}

		bStatus = TRUE;
8110a49c:	00800044 	movi	r2,1
8110a4a0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a4a4:	e0bffd17 	ldw	r2,-12(fp)
}
8110a4a8:	e037883a 	mov	sp,fp
8110a4ac:	dfc00117 	ldw	ra,4(sp)
8110a4b0:	df000017 	ldw	fp,0(sp)
8110a4b4:	dec00204 	addi	sp,sp,8
8110a4b8:	f800283a 	ret

8110a4bc <bSpwcGetLinkStatus>:

bool bSpwcGetLinkStatus(TSpwcChannel *pxSpwcCh) {
8110a4bc:	defffb04 	addi	sp,sp,-20
8110a4c0:	de00012e 	bgeu	sp,et,8110a4c8 <bSpwcGetLinkStatus+0xc>
8110a4c4:	003b68fa 	trap	3
8110a4c8:	dfc00415 	stw	ra,16(sp)
8110a4cc:	df000315 	stw	fp,12(sp)
8110a4d0:	df000304 	addi	fp,sp,12
8110a4d4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110a4d8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110a4dc:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110a4e0:	e0bfff17 	ldw	r2,-4(fp)
8110a4e4:	10002326 	beq	r2,zero,8110a574 <bSpwcGetLinkStatus+0xb8>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110a4e8:	e0bfff17 	ldw	r2,-4(fp)
8110a4ec:	10800017 	ldw	r2,0(r2)
8110a4f0:	000b883a 	mov	r5,zero
8110a4f4:	1009883a 	mov	r4,r2
8110a4f8:	110a87c0 	call	8110a87c <uliSpwcReadReg>
8110a4fc:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKSTAT_STARTED_MSK) {
8110a500:	e0bffe17 	ldw	r2,-8(fp)
8110a504:	1081000c 	andi	r2,r2,1024
8110a508:	10000426 	beq	r2,zero,8110a51c <bSpwcGetLinkStatus+0x60>
			pxSpwcCh->xLinkStatus.bStarted = TRUE;
8110a50c:	e0bfff17 	ldw	r2,-4(fp)
8110a510:	00c00044 	movi	r3,1
8110a514:	10c00915 	stw	r3,36(r2)
8110a518:	00000206 	br	8110a524 <bSpwcGetLinkStatus+0x68>
		} else {
			pxSpwcCh->xLinkStatus.bStarted = FALSE;
8110a51c:	e0bfff17 	ldw	r2,-4(fp)
8110a520:	10000915 	stw	zero,36(r2)
		}
		if (uliReg & COMM_SPW_LNKSTAT_CONNECTING_MSK) {
8110a524:	e0bffe17 	ldw	r2,-8(fp)
8110a528:	1080800c 	andi	r2,r2,512
8110a52c:	10000426 	beq	r2,zero,8110a540 <bSpwcGetLinkStatus+0x84>
			pxSpwcCh->xLinkStatus.bConnecting = TRUE;
8110a530:	e0bfff17 	ldw	r2,-4(fp)
8110a534:	00c00044 	movi	r3,1
8110a538:	10c00a15 	stw	r3,40(r2)
8110a53c:	00000206 	br	8110a548 <bSpwcGetLinkStatus+0x8c>
		} else {
			pxSpwcCh->xLinkStatus.bConnecting = FALSE;
8110a540:	e0bfff17 	ldw	r2,-4(fp)
8110a544:	10000a15 	stw	zero,40(r2)
		}
		if (uliReg & COMM_SPW_LNKSTAT_RUNNING_MSK) {
8110a548:	e0bffe17 	ldw	r2,-8(fp)
8110a54c:	1080400c 	andi	r2,r2,256
8110a550:	10000426 	beq	r2,zero,8110a564 <bSpwcGetLinkStatus+0xa8>
			pxSpwcCh->xLinkStatus.bRunning = TRUE;
8110a554:	e0bfff17 	ldw	r2,-4(fp)
8110a558:	00c00044 	movi	r3,1
8110a55c:	10c00b15 	stw	r3,44(r2)
8110a560:	00000206 	br	8110a56c <bSpwcGetLinkStatus+0xb0>
		} else {
			pxSpwcCh->xLinkStatus.bRunning = FALSE;
8110a564:	e0bfff17 	ldw	r2,-4(fp)
8110a568:	10000b15 	stw	zero,44(r2)
		}

		bStatus = TRUE;
8110a56c:	00800044 	movi	r2,1
8110a570:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a574:	e0bffd17 	ldw	r2,-12(fp)
}
8110a578:	e037883a 	mov	sp,fp
8110a57c:	dfc00117 	ldw	ra,4(sp)
8110a580:	df000017 	ldw	fp,0(sp)
8110a584:	dec00204 	addi	sp,sp,8
8110a588:	f800283a 	ret

8110a58c <bSpwcGetTimecode>:

bool bSpwcGetTimecode(TSpwcChannel *pxSpwcCh) {
8110a58c:	defffb04 	addi	sp,sp,-20
8110a590:	de00012e 	bgeu	sp,et,8110a598 <bSpwcGetTimecode+0xc>
8110a594:	003b68fa 	trap	3
8110a598:	dfc00415 	stw	ra,16(sp)
8110a59c:	df000315 	stw	fp,12(sp)
8110a5a0:	df000304 	addi	fp,sp,12
8110a5a4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110a5a8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110a5ac:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110a5b0:	e0bfff17 	ldw	r2,-4(fp)
8110a5b4:	10001326 	beq	r2,zero,8110a604 <bSpwcGetTimecode+0x78>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110a5b8:	e0bfff17 	ldw	r2,-4(fp)
8110a5bc:	10800017 	ldw	r2,0(r2)
8110a5c0:	01400044 	movi	r5,1
8110a5c4:	1009883a 	mov	r4,r2
8110a5c8:	110a87c0 	call	8110a87c <uliSpwcReadReg>
8110a5cc:	e0bffe15 	stw	r2,-8(fp)
		COMM_TIMECODE_REG_OFST);

		pxSpwcCh->xTimecode.ucControl= (alt_u8)(
				(uliReg & COMM_TIMECODE_CONTROL_MSK) >> 6);
8110a5d0:	e0bffe17 	ldw	r2,-8(fp)
8110a5d4:	1080300c 	andi	r2,r2,192
8110a5d8:	1004d1ba 	srli	r2,r2,6

	if (pxSpwcCh != NULL) {
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
		COMM_TIMECODE_REG_OFST);

		pxSpwcCh->xTimecode.ucControl= (alt_u8)(
8110a5dc:	1007883a 	mov	r3,r2
8110a5e0:	e0bfff17 	ldw	r2,-4(fp)
8110a5e4:	10c00c05 	stb	r3,48(r2)
				(uliReg & COMM_TIMECODE_CONTROL_MSK) >> 6);
		pxSpwcCh->xTimecode.ucCounter= (alt_u8)(
8110a5e8:	e0bffe17 	ldw	r2,-8(fp)
8110a5ec:	10800fcc 	andi	r2,r2,63
8110a5f0:	1007883a 	mov	r3,r2
8110a5f4:	e0bfff17 	ldw	r2,-4(fp)
8110a5f8:	10c00c45 	stb	r3,49(r2)
				(uliReg & COMM_TIMECODE_TIME_MSK) >> 0);

		bStatus = TRUE;
8110a5fc:	00800044 	movi	r2,1
8110a600:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a604:	e0bffd17 	ldw	r2,-12(fp)
}
8110a608:	e037883a 	mov	sp,fp
8110a60c:	dfc00117 	ldw	ra,4(sp)
8110a610:	df000017 	ldw	fp,0(sp)
8110a614:	dec00204 	addi	sp,sp,8
8110a618:	f800283a 	ret

8110a61c <bSpwcClearTimecode>:

bool bSpwcClearTimecode(TSpwcChannel *pxSpwcCh) {
8110a61c:	defffb04 	addi	sp,sp,-20
8110a620:	de00012e 	bgeu	sp,et,8110a628 <bSpwcClearTimecode+0xc>
8110a624:	003b68fa 	trap	3
8110a628:	dfc00415 	stw	ra,16(sp)
8110a62c:	df000315 	stw	fp,12(sp)
8110a630:	df000304 	addi	fp,sp,12
8110a634:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110a638:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110a63c:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110a640:	e0bfff17 	ldw	r2,-4(fp)
8110a644:	10001126 	beq	r2,zero,8110a68c <bSpwcClearTimecode+0x70>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110a648:	e0bfff17 	ldw	r2,-4(fp)
8110a64c:	10800017 	ldw	r2,0(r2)
8110a650:	01400044 	movi	r5,1
8110a654:	1009883a 	mov	r4,r2
8110a658:	110a87c0 	call	8110a87c <uliSpwcReadReg>
8110a65c:	e0bffe15 	stw	r2,-8(fp)
		COMM_TIMECODE_REG_OFST);

		uliReg |= COMM_TIMECODE_CLR_MSK;
8110a660:	e0bffe17 	ldw	r2,-8(fp)
8110a664:	10804014 	ori	r2,r2,256
8110a668:	e0bffe15 	stw	r2,-8(fp)

		vSpwcWriteReg(pxSpwcCh->puliSpwcChAddr, COMM_TIMECODE_REG_OFST, uliReg);
8110a66c:	e0bfff17 	ldw	r2,-4(fp)
8110a670:	10800017 	ldw	r2,0(r2)
8110a674:	e1bffe17 	ldw	r6,-8(fp)
8110a678:	01400044 	movi	r5,1
8110a67c:	1009883a 	mov	r4,r2
8110a680:	110a8280 	call	8110a828 <vSpwcWriteReg>
		bStatus = TRUE;
8110a684:	00800044 	movi	r2,1
8110a688:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a68c:	e0bffd17 	ldw	r2,-12(fp)
}
8110a690:	e037883a 	mov	sp,fp
8110a694:	dfc00117 	ldw	ra,4(sp)
8110a698:	df000017 	ldw	fp,0(sp)
8110a69c:	dec00204 	addi	sp,sp,8
8110a6a0:	f800283a 	ret

8110a6a4 <bSpwcInitCh>:

bool bSpwcInitCh(TSpwcChannel *pxSpwcCh, alt_u8 ucCommCh) {
8110a6a4:	defffb04 	addi	sp,sp,-20
8110a6a8:	de00012e 	bgeu	sp,et,8110a6b0 <bSpwcInitCh+0xc>
8110a6ac:	003b68fa 	trap	3
8110a6b0:	dfc00415 	stw	ra,16(sp)
8110a6b4:	df000315 	stw	fp,12(sp)
8110a6b8:	df000304 	addi	fp,sp,12
8110a6bc:	e13ffe15 	stw	r4,-8(fp)
8110a6c0:	2805883a 	mov	r2,r5
8110a6c4:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
8110a6c8:	e03ffd15 	stw	zero,-12(fp)

	if (pxSpwcCh != NULL) {
8110a6cc:	e0bffe17 	ldw	r2,-8(fp)
8110a6d0:	10004f26 	beq	r2,zero,8110a810 <bSpwcInitCh+0x16c>
		bStatus = TRUE;
8110a6d4:	00800044 	movi	r2,1
8110a6d8:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
8110a6dc:	e0bfff03 	ldbu	r2,-4(fp)
8110a6e0:	10c00228 	cmpgeui	r3,r2,8
8110a6e4:	1800361e 	bne	r3,zero,8110a7c0 <bSpwcInitCh+0x11c>
8110a6e8:	100690ba 	slli	r3,r2,2
8110a6ec:	00a04474 	movhi	r2,33041
8110a6f0:	10a9c004 	addi	r2,r2,-22784
8110a6f4:	1885883a 	add	r2,r3,r2
8110a6f8:	10800017 	ldw	r2,0(r2)
8110a6fc:	1000683a 	jmp	r2
8110a700:	8110a720 	cmpeqi	r4,r16,17052
8110a704:	8110a734 	orhi	r4,r16,17052
8110a708:	8110a748 	cmpgei	r4,r16,17053
8110a70c:	8110a75c 	xori	r4,r16,17053
8110a710:	8110a770 	cmpltui	r4,r16,17053
8110a714:	8110a784 	addi	r4,r16,17054
8110a718:	8110a798 	cmpnei	r4,r16,17054
8110a71c:	8110a7ac 	andhi	r4,r16,17054
		case eCommSpwCh1:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
8110a720:	e0fffe17 	ldw	r3,-8(fp)
8110a724:	00a04834 	movhi	r2,33056
8110a728:	108b0004 	addi	r2,r2,11264
8110a72c:	18800015 	stw	r2,0(r3)
			break;
8110a730:	00002506 	br	8110a7c8 <bSpwcInitCh+0x124>
		case eCommSpwCh2:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
8110a734:	e0fffe17 	ldw	r3,-8(fp)
8110a738:	00a04834 	movhi	r2,33056
8110a73c:	108a0004 	addi	r2,r2,10240
8110a740:	18800015 	stw	r2,0(r3)
			break;
8110a744:	00002006 	br	8110a7c8 <bSpwcInitCh+0x124>
		case eCommSpwCh3:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
8110a748:	e0fffe17 	ldw	r3,-8(fp)
8110a74c:	00a04834 	movhi	r2,33056
8110a750:	108b0004 	addi	r2,r2,11264
8110a754:	18800015 	stw	r2,0(r3)
			break;
8110a758:	00001b06 	br	8110a7c8 <bSpwcInitCh+0x124>
		case eCommSpwCh4:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
8110a75c:	e0fffe17 	ldw	r3,-8(fp)
8110a760:	00a04834 	movhi	r2,33056
8110a764:	108a0004 	addi	r2,r2,10240
8110a768:	18800015 	stw	r2,0(r3)
			break;
8110a76c:	00001606 	br	8110a7c8 <bSpwcInitCh+0x124>
		case eCommSpwCh5:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
8110a770:	e0fffe17 	ldw	r3,-8(fp)
8110a774:	00a04834 	movhi	r2,33056
8110a778:	108b0004 	addi	r2,r2,11264
8110a77c:	18800015 	stw	r2,0(r3)
			break;
8110a780:	00001106 	br	8110a7c8 <bSpwcInitCh+0x124>
		case eCommSpwCh6:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
8110a784:	e0fffe17 	ldw	r3,-8(fp)
8110a788:	00a04834 	movhi	r2,33056
8110a78c:	108a0004 	addi	r2,r2,10240
8110a790:	18800015 	stw	r2,0(r3)
			break;
8110a794:	00000c06 	br	8110a7c8 <bSpwcInitCh+0x124>
		case eCommSpwCh7:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
8110a798:	e0fffe17 	ldw	r3,-8(fp)
8110a79c:	00a04834 	movhi	r2,33056
8110a7a0:	108b0004 	addi	r2,r2,11264
8110a7a4:	18800015 	stw	r2,0(r3)
			break;
8110a7a8:	00000706 	br	8110a7c8 <bSpwcInitCh+0x124>
		case eCommSpwCh8:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
8110a7ac:	e0fffe17 	ldw	r3,-8(fp)
8110a7b0:	00a04834 	movhi	r2,33056
8110a7b4:	108a0004 	addi	r2,r2,10240
8110a7b8:	18800015 	stw	r2,0(r3)
			break;
8110a7bc:	00000206 	br	8110a7c8 <bSpwcInitCh+0x124>
		default:
			bStatus = FALSE;
8110a7c0:	e03ffd15 	stw	zero,-12(fp)
			break;
8110a7c4:	0001883a 	nop
		}

		if (bStatus) {
8110a7c8:	e0bffd17 	ldw	r2,-12(fp)
8110a7cc:	10001026 	beq	r2,zero,8110a810 <bSpwcInitCh+0x16c>
			if (!bSpwcGetLink(pxSpwcCh)) {
8110a7d0:	e13ffe17 	ldw	r4,-8(fp)
8110a7d4:	110a2e40 	call	8110a2e4 <bSpwcGetLink>
8110a7d8:	1000011e 	bne	r2,zero,8110a7e0 <bSpwcInitCh+0x13c>
				bStatus = FALSE;
8110a7dc:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetLinkError(pxSpwcCh)) {
8110a7e0:	e13ffe17 	ldw	r4,-8(fp)
8110a7e4:	110a3c80 	call	8110a3c8 <bSpwcGetLinkError>
8110a7e8:	1000011e 	bne	r2,zero,8110a7f0 <bSpwcInitCh+0x14c>
				bStatus = FALSE;
8110a7ec:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetLinkStatus(pxSpwcCh)) {
8110a7f0:	e13ffe17 	ldw	r4,-8(fp)
8110a7f4:	110a4bc0 	call	8110a4bc <bSpwcGetLinkStatus>
8110a7f8:	1000011e 	bne	r2,zero,8110a800 <bSpwcInitCh+0x15c>
				bStatus = FALSE;
8110a7fc:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetTimecode(pxSpwcCh)) {
8110a800:	e13ffe17 	ldw	r4,-8(fp)
8110a804:	110a58c0 	call	8110a58c <bSpwcGetTimecode>
8110a808:	1000011e 	bne	r2,zero,8110a810 <bSpwcInitCh+0x16c>
				bStatus = FALSE;
8110a80c:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
8110a810:	e0bffd17 	ldw	r2,-12(fp)
}
8110a814:	e037883a 	mov	sp,fp
8110a818:	dfc00117 	ldw	ra,4(sp)
8110a81c:	df000017 	ldw	fp,0(sp)
8110a820:	dec00204 	addi	sp,sp,8
8110a824:	f800283a 	ret

8110a828 <vSpwcWriteReg>:
//! [public functions]

//! [private functions]
static void vSpwcWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
8110a828:	defffc04 	addi	sp,sp,-16
8110a82c:	de00012e 	bgeu	sp,et,8110a834 <vSpwcWriteReg+0xc>
8110a830:	003b68fa 	trap	3
8110a834:	df000315 	stw	fp,12(sp)
8110a838:	df000304 	addi	fp,sp,12
8110a83c:	e13ffd15 	stw	r4,-12(fp)
8110a840:	e17ffe15 	stw	r5,-8(fp)
8110a844:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
8110a848:	e0bffe17 	ldw	r2,-8(fp)
8110a84c:	1085883a 	add	r2,r2,r2
8110a850:	1085883a 	add	r2,r2,r2
8110a854:	1007883a 	mov	r3,r2
8110a858:	e0bffd17 	ldw	r2,-12(fp)
8110a85c:	10c5883a 	add	r2,r2,r3
8110a860:	e0ffff17 	ldw	r3,-4(fp)
8110a864:	10c00015 	stw	r3,0(r2)
}
8110a868:	0001883a 	nop
8110a86c:	e037883a 	mov	sp,fp
8110a870:	df000017 	ldw	fp,0(sp)
8110a874:	dec00104 	addi	sp,sp,4
8110a878:	f800283a 	ret

8110a87c <uliSpwcReadReg>:

static alt_u32 uliSpwcReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8110a87c:	defffc04 	addi	sp,sp,-16
8110a880:	de00012e 	bgeu	sp,et,8110a888 <uliSpwcReadReg+0xc>
8110a884:	003b68fa 	trap	3
8110a888:	df000315 	stw	fp,12(sp)
8110a88c:	df000304 	addi	fp,sp,12
8110a890:	e13ffe15 	stw	r4,-8(fp)
8110a894:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
8110a898:	e0bfff17 	ldw	r2,-4(fp)
8110a89c:	1085883a 	add	r2,r2,r2
8110a8a0:	1085883a 	add	r2,r2,r2
8110a8a4:	1007883a 	mov	r3,r2
8110a8a8:	e0bffe17 	ldw	r2,-8(fp)
8110a8ac:	10c5883a 	add	r2,r2,r3
8110a8b0:	10800017 	ldw	r2,0(r2)
8110a8b4:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8110a8b8:	e0bffd17 	ldw	r2,-12(fp)
}
8110a8bc:	e037883a 	mov	sp,fp
8110a8c0:	df000017 	ldw	fp,0(sp)
8110a8c4:	dec00104 	addi	sp,sp,4
8110a8c8:	f800283a 	ret

8110a8cc <bEnableIsoDrivers>:
//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bEnableIsoDrivers(void)
{
8110a8cc:	defffe04 	addi	sp,sp,-8
8110a8d0:	de00012e 	bgeu	sp,et,8110a8d8 <bEnableIsoDrivers+0xc>
8110a8d4:	003b68fa 	trap	3
8110a8d8:	dfc00115 	stw	ra,4(sp)
8110a8dc:	df000015 	stw	fp,0(sp)
8110a8e0:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_EN_ISO_DRIVERS_MSK);
8110a8e4:	01400204 	movi	r5,8
8110a8e8:	01000044 	movi	r4,1
8110a8ec:	110aa7c0 	call	8110aa7c <bCtrlIoLvdsDrive>
  return  TRUE;
8110a8f0:	00800044 	movi	r2,1
}
8110a8f4:	e037883a 	mov	sp,fp
8110a8f8:	dfc00117 	ldw	ra,4(sp)
8110a8fc:	df000017 	ldw	fp,0(sp)
8110a900:	dec00204 	addi	sp,sp,8
8110a904:	f800283a 	ret

8110a908 <bDisableIsoDrivers>:

bool bDisableIsoDrivers(void)
{
8110a908:	defffe04 	addi	sp,sp,-8
8110a90c:	de00012e 	bgeu	sp,et,8110a914 <bDisableIsoDrivers+0xc>
8110a910:	003b68fa 	trap	3
8110a914:	dfc00115 	stw	ra,4(sp)
8110a918:	df000015 	stw	fp,0(sp)
8110a91c:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_EN_ISO_DRIVERS_MSK);
8110a920:	01400204 	movi	r5,8
8110a924:	0009883a 	mov	r4,zero
8110a928:	110aa7c0 	call	8110aa7c <bCtrlIoLvdsDrive>
  return  TRUE;
8110a92c:	00800044 	movi	r2,1
}
8110a930:	e037883a 	mov	sp,fp
8110a934:	dfc00117 	ldw	ra,4(sp)
8110a938:	df000017 	ldw	fp,0(sp)
8110a93c:	dec00204 	addi	sp,sp,8
8110a940:	f800283a 	ret

8110a944 <bEnableLvdsBoard>:

bool bEnableLvdsBoard(void)
{
8110a944:	defffe04 	addi	sp,sp,-8
8110a948:	de00012e 	bgeu	sp,et,8110a950 <bEnableLvdsBoard+0xc>
8110a94c:	003b68fa 	trap	3
8110a950:	dfc00115 	stw	ra,4(sp)
8110a954:	df000015 	stw	fp,0(sp)
8110a958:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PWDN_MSK);
8110a95c:	01400104 	movi	r5,4
8110a960:	01000044 	movi	r4,1
8110a964:	110aa7c0 	call	8110aa7c <bCtrlIoLvdsDrive>
  return  TRUE;
8110a968:	00800044 	movi	r2,1
}
8110a96c:	e037883a 	mov	sp,fp
8110a970:	dfc00117 	ldw	ra,4(sp)
8110a974:	df000017 	ldw	fp,0(sp)
8110a978:	dec00204 	addi	sp,sp,8
8110a97c:	f800283a 	ret

8110a980 <bDisableLvdsBoard>:

bool bDisableLvdsBoard(void)
{
8110a980:	defffe04 	addi	sp,sp,-8
8110a984:	de00012e 	bgeu	sp,et,8110a98c <bDisableLvdsBoard+0xc>
8110a988:	003b68fa 	trap	3
8110a98c:	dfc00115 	stw	ra,4(sp)
8110a990:	df000015 	stw	fp,0(sp)
8110a994:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PWDN_MSK);
8110a998:	01400104 	movi	r5,4
8110a99c:	0009883a 	mov	r4,zero
8110a9a0:	110aa7c0 	call	8110aa7c <bCtrlIoLvdsDrive>
  return  TRUE;
8110a9a4:	00800044 	movi	r2,1
}
8110a9a8:	e037883a 	mov	sp,fp
8110a9ac:	dfc00117 	ldw	ra,4(sp)
8110a9b0:	df000017 	ldw	fp,0(sp)
8110a9b4:	dec00204 	addi	sp,sp,8
8110a9b8:	f800283a 	ret

8110a9bc <bSetPreEmphasys>:

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
8110a9bc:	defffd04 	addi	sp,sp,-12
8110a9c0:	de00012e 	bgeu	sp,et,8110a9c8 <bSetPreEmphasys+0xc>
8110a9c4:	003b68fa 	trap	3
8110a9c8:	dfc00215 	stw	ra,8(sp)
8110a9cc:	df000115 	stw	fp,4(sp)
8110a9d0:	df000104 	addi	fp,sp,4
8110a9d4:	2005883a 	mov	r2,r4
8110a9d8:	e0bfff05 	stb	r2,-4(fp)
  switch (ucPemLevel) {
8110a9dc:	e0bfff03 	ldbu	r2,-4(fp)
8110a9e0:	10c00060 	cmpeqi	r3,r2,1
8110a9e4:	18000d1e 	bne	r3,zero,8110aa1c <bSetPreEmphasys+0x60>
8110a9e8:	10c00088 	cmpgei	r3,r2,2
8110a9ec:	1800021e 	bne	r3,zero,8110a9f8 <bSetPreEmphasys+0x3c>
8110a9f0:	10000626 	beq	r2,zero,8110aa0c <bSetPreEmphasys+0x50>
      break;
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
      break;
    default:
      break;
8110a9f4:	00001b06 	br	8110aa64 <bSetPreEmphasys+0xa8>
  return  TRUE;
}

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
  switch (ucPemLevel) {
8110a9f8:	10c000a0 	cmpeqi	r3,r2,2
8110a9fc:	18000e1e 	bne	r3,zero,8110aa38 <bSetPreEmphasys+0x7c>
8110aa00:	108000e0 	cmpeqi	r2,r2,3
8110aa04:	1000131e 	bne	r2,zero,8110aa54 <bSetPreEmphasys+0x98>
      break;
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
      break;
    default:
      break;
8110aa08:	00001606 	br	8110aa64 <bSetPreEmphasys+0xa8>

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
  switch (ucPemLevel) {
    case LVDS_PEM_OFF:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
8110aa0c:	014000c4 	movi	r5,3
8110aa10:	0009883a 	mov	r4,zero
8110aa14:	110aa7c0 	call	8110aa7c <bCtrlIoLvdsDrive>
      break;
8110aa18:	00001206 	br	8110aa64 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_LO:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM1_MSK);
8110aa1c:	01400084 	movi	r5,2
8110aa20:	0009883a 	mov	r4,zero
8110aa24:	110aa7c0 	call	8110aa7c <bCtrlIoLvdsDrive>
      bCtrlIoLvdsDrive(LVDS_IO_ON,  LVDS_PEM0_MSK);
8110aa28:	01400044 	movi	r5,1
8110aa2c:	01000044 	movi	r4,1
8110aa30:	110aa7c0 	call	8110aa7c <bCtrlIoLvdsDrive>
      break;
8110aa34:	00000b06 	br	8110aa64 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_MID:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM0_MSK);
8110aa38:	01400044 	movi	r5,1
8110aa3c:	0009883a 	mov	r4,zero
8110aa40:	110aa7c0 	call	8110aa7c <bCtrlIoLvdsDrive>
      bCtrlIoLvdsDrive(LVDS_IO_ON,  LVDS_PEM1_MSK);
8110aa44:	01400084 	movi	r5,2
8110aa48:	01000044 	movi	r4,1
8110aa4c:	110aa7c0 	call	8110aa7c <bCtrlIoLvdsDrive>
      break;
8110aa50:	00000406 	br	8110aa64 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
8110aa54:	014000c4 	movi	r5,3
8110aa58:	01000044 	movi	r4,1
8110aa5c:	110aa7c0 	call	8110aa7c <bCtrlIoLvdsDrive>
      break;
8110aa60:	0001883a 	nop
    default:
      break;
  }
  return TRUE;
8110aa64:	00800044 	movi	r2,1
}
8110aa68:	e037883a 	mov	sp,fp
8110aa6c:	dfc00117 	ldw	ra,4(sp)
8110aa70:	df000017 	ldw	fp,0(sp)
8110aa74:	dec00204 	addi	sp,sp,8
8110aa78:	f800283a 	ret

8110aa7c <bCtrlIoLvdsDrive>:
 * @param [in] ulliMask   -> mascara de i/os a serem alterados
 *
 * @retval TRUE -> sucesso
 */
static bool bCtrlIoLvdsDrive(bool bOnOff, alt_u8 ucMask)
{
8110aa7c:	defffd04 	addi	sp,sp,-12
8110aa80:	de00012e 	bgeu	sp,et,8110aa88 <bCtrlIoLvdsDrive+0xc>
8110aa84:	003b68fa 	trap	3
8110aa88:	df000215 	stw	fp,8(sp)
8110aa8c:	df000204 	addi	fp,sp,8
8110aa90:	e13ffe15 	stw	r4,-8(fp)
8110aa94:	2805883a 	mov	r2,r5
8110aa98:	e0bfff05 	stb	r2,-4(fp)
  if (bOnOff == LVDS_IO_OFF) {
8110aa9c:	e0bffe17 	ldw	r2,-8(fp)
8110aaa0:	1000071e 	bne	r2,zero,8110aac0 <bCtrlIoLvdsDrive+0x44>
	 ucIoValue &= (~ucMask);
8110aaa4:	e0bfff03 	ldbu	r2,-4(fp)
8110aaa8:	0084303a 	nor	r2,zero,r2
8110aaac:	1007883a 	mov	r3,r2
8110aab0:	d0a00103 	ldbu	r2,-32764(gp)
8110aab4:	1884703a 	and	r2,r3,r2
8110aab8:	d0a00105 	stb	r2,-32764(gp)
8110aabc:	00000406 	br	8110aad0 <bCtrlIoLvdsDrive+0x54>
  }
  else {
	 ucIoValue |= ucMask;
8110aac0:	d0e00103 	ldbu	r3,-32764(gp)
8110aac4:	e0bfff03 	ldbu	r2,-4(fp)
8110aac8:	1884b03a 	or	r2,r3,r2
8110aacc:	d0a00105 	stb	r2,-32764(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LVDS_CTRL_IO_LVDS_ADDR_BASE, ucIoValue);
8110aad0:	d0a00103 	ldbu	r2,-32764(gp)
8110aad4:	10c03fcc 	andi	r3,r2,255
8110aad8:	00a00034 	movhi	r2,32768
8110aadc:	10822804 	addi	r2,r2,2208
8110aae0:	10c00035 	stwio	r3,0(r2)
  return TRUE;
8110aae4:	00800044 	movi	r2,1
}
8110aae8:	e037883a 	mov	sp,fp
8110aaec:	df000017 	ldw	fp,0(sp)
8110aaf0:	dec00104 	addi	sp,sp,4
8110aaf4:	f800283a 	ret

8110aaf8 <I2C_TestAdress>:
void i2c_start(alt_u32 clk_base, alt_u32 data_base);
void i2c_stop(alt_u32 clk_base, alt_u32 data_base);
bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data);
void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck);

bool I2C_TestAdress(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr){
8110aaf8:	defffa04 	addi	sp,sp,-24
8110aafc:	de00012e 	bgeu	sp,et,8110ab04 <I2C_TestAdress+0xc>
8110ab00:	003b68fa 	trap	3
8110ab04:	dfc00515 	stw	ra,20(sp)
8110ab08:	df000415 	stw	fp,16(sp)
8110ab0c:	df000404 	addi	fp,sp,16
8110ab10:	e13ffd15 	stw	r4,-12(fp)
8110ab14:	e17ffe15 	stw	r5,-8(fp)
8110ab18:	3005883a 	mov	r2,r6
8110ab1c:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
8110ab20:	00800044 	movi	r2,1
8110ab24:	e0bffc15 	stw	r2,-16(fp)
    //alt_u8 DeviceAddr;
    
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8110ab28:	e17ffe17 	ldw	r5,-8(fp)
8110ab2c:	e13ffd17 	ldw	r4,-12(fp)
8110ab30:	110aec80 	call	8110aec8 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8110ab34:	e0bfff03 	ldbu	r2,-4(fp)
8110ab38:	10803fcc 	andi	r2,r2,255
8110ab3c:	100d883a 	mov	r6,r2
8110ab40:	e17ffe17 	ldw	r5,-8(fp)
8110ab44:	e13ffd17 	ldw	r4,-12(fp)
8110ab48:	110afdc0 	call	8110afdc <i2c_write>
8110ab4c:	1000011e 	bne	r2,zero,8110ab54 <I2C_TestAdress+0x5c>
        bSuccess = FALSE;
8110ab50:	e03ffc15 	stw	zero,-16(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    i2c_stop(clk_base, data_base);
8110ab54:	e17ffe17 	ldw	r5,-8(fp)
8110ab58:	e13ffd17 	ldw	r4,-12(fp)
8110ab5c:	110af5c0 	call	8110af5c <i2c_stop>
    
    usleep(7*1000); // delay to wait EE2 ready (at least 5 ms delay is required)
8110ab60:	0106d604 	movi	r4,7000
8110ab64:	11376bc0 	call	811376bc <usleep>
    
    return bSuccess;
8110ab68:	e0bffc17 	ldw	r2,-16(fp)

}
8110ab6c:	e037883a 	mov	sp,fp
8110ab70:	dfc00117 	ldw	ra,4(sp)
8110ab74:	df000017 	ldw	fp,0(sp)
8110ab78:	dec00204 	addi	sp,sp,8
8110ab7c:	f800283a 	ret

8110ab80 <I2C_Write>:

bool I2C_Write(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 ControlData){
8110ab80:	defff804 	addi	sp,sp,-32
8110ab84:	de00012e 	bgeu	sp,et,8110ab8c <I2C_Write+0xc>
8110ab88:	003b68fa 	trap	3
8110ab8c:	dfc00715 	stw	ra,28(sp)
8110ab90:	df000615 	stw	fp,24(sp)
8110ab94:	df000604 	addi	fp,sp,24
8110ab98:	e13ffb15 	stw	r4,-20(fp)
8110ab9c:	e17ffc15 	stw	r5,-16(fp)
8110aba0:	3009883a 	mov	r4,r6
8110aba4:	3807883a 	mov	r3,r7
8110aba8:	e0800217 	ldw	r2,8(fp)
8110abac:	e13ffd05 	stb	r4,-12(fp)
8110abb0:	e0fffe05 	stb	r3,-8(fp)
8110abb4:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
8110abb8:	00800044 	movi	r2,1
8110abbc:	e0bffa15 	stw	r2,-24(fp)
    //alt_u8 DeviceAddr;
    
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8110abc0:	e17ffc17 	ldw	r5,-16(fp)
8110abc4:	e13ffb17 	ldw	r4,-20(fp)
8110abc8:	110aec80 	call	8110aec8 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8110abcc:	e0bffd03 	ldbu	r2,-12(fp)
8110abd0:	10803fcc 	andi	r2,r2,255
8110abd4:	100d883a 	mov	r6,r2
8110abd8:	e17ffc17 	ldw	r5,-16(fp)
8110abdc:	e13ffb17 	ldw	r4,-20(fp)
8110abe0:	110afdc0 	call	8110afdc <i2c_write>
8110abe4:	1000011e 	bne	r2,zero,8110abec <I2C_Write+0x6c>
        bSuccess = FALSE;
8110abe8:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
8110abec:	e0bffa17 	ldw	r2,-24(fp)
8110abf0:	10000726 	beq	r2,zero,8110ac10 <I2C_Write+0x90>
8110abf4:	e0bffe03 	ldbu	r2,-8(fp)
8110abf8:	100d883a 	mov	r6,r2
8110abfc:	e17ffc17 	ldw	r5,-16(fp)
8110ac00:	e13ffb17 	ldw	r4,-20(fp)
8110ac04:	110afdc0 	call	8110afdc <i2c_write>
8110ac08:	1000011e 	bne	r2,zero,8110ac10 <I2C_Write+0x90>
        bSuccess = FALSE;
8110ac0c:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }            
    if (bSuccess && !i2c_write(clk_base, data_base, ControlData)){  
8110ac10:	e0bffa17 	ldw	r2,-24(fp)
8110ac14:	10000726 	beq	r2,zero,8110ac34 <I2C_Write+0xb4>
8110ac18:	e0bfff03 	ldbu	r2,-4(fp)
8110ac1c:	100d883a 	mov	r6,r2
8110ac20:	e17ffc17 	ldw	r5,-16(fp)
8110ac24:	e13ffb17 	ldw	r4,-20(fp)
8110ac28:	110afdc0 	call	8110afdc <i2c_write>
8110ac2c:	1000011e 	bne	r2,zero,8110ac34 <I2C_Write+0xb4>
        bSuccess = FALSE;
8110ac30:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: write NACK!\n"));
    }
    i2c_stop(clk_base, data_base);
8110ac34:	e17ffc17 	ldw	r5,-16(fp)
8110ac38:	e13ffb17 	ldw	r4,-20(fp)
8110ac3c:	110af5c0 	call	8110af5c <i2c_stop>
    
    usleep(7*1000); // delay to wait EE2 ready (at least 5 ms delay is required)
8110ac40:	0106d604 	movi	r4,7000
8110ac44:	11376bc0 	call	811376bc <usleep>
    
    return bSuccess;
8110ac48:	e0bffa17 	ldw	r2,-24(fp)

}
8110ac4c:	e037883a 	mov	sp,fp
8110ac50:	dfc00117 	ldw	ra,4(sp)
8110ac54:	df000017 	ldw	fp,0(sp)
8110ac58:	dec00204 	addi	sp,sp,8
8110ac5c:	f800283a 	ret

8110ac60 <I2C_Read>:

bool I2C_Read(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 *pControlData){
8110ac60:	defff904 	addi	sp,sp,-28
8110ac64:	de00012e 	bgeu	sp,et,8110ac6c <I2C_Read+0xc>
8110ac68:	003b68fa 	trap	3
8110ac6c:	dfc00615 	stw	ra,24(sp)
8110ac70:	df000515 	stw	fp,20(sp)
8110ac74:	df000504 	addi	fp,sp,20
8110ac78:	e13ffc15 	stw	r4,-16(fp)
8110ac7c:	e17ffd15 	stw	r5,-12(fp)
8110ac80:	3007883a 	mov	r3,r6
8110ac84:	3805883a 	mov	r2,r7
8110ac88:	e0fffe05 	stb	r3,-8(fp)
8110ac8c:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
8110ac90:	00800044 	movi	r2,1
8110ac94:	e0bffb15 	stw	r2,-20(fp)
    //alt_u8 DeviceAddr;
   
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8110ac98:	e17ffd17 	ldw	r5,-12(fp)
8110ac9c:	e13ffc17 	ldw	r4,-16(fp)
8110aca0:	110aec80 	call	8110aec8 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8110aca4:	e0bffe03 	ldbu	r2,-8(fp)
8110aca8:	10803fcc 	andi	r2,r2,255
8110acac:	100d883a 	mov	r6,r2
8110acb0:	e17ffd17 	ldw	r5,-12(fp)
8110acb4:	e13ffc17 	ldw	r4,-16(fp)
8110acb8:	110afdc0 	call	8110afdc <i2c_write>
8110acbc:	1000011e 	bne	r2,zero,8110acc4 <I2C_Read+0x64>
        bSuccess = FALSE;
8110acc0:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
8110acc4:	e0bffb17 	ldw	r2,-20(fp)
8110acc8:	10000726 	beq	r2,zero,8110ace8 <I2C_Read+0x88>
8110accc:	e0bfff03 	ldbu	r2,-4(fp)
8110acd0:	100d883a 	mov	r6,r2
8110acd4:	e17ffd17 	ldw	r5,-12(fp)
8110acd8:	e13ffc17 	ldw	r4,-16(fp)
8110acdc:	110afdc0 	call	8110afdc <i2c_write>
8110ace0:	1000011e 	bne	r2,zero,8110ace8 <I2C_Read+0x88>
        bSuccess = FALSE;
8110ace4:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }            
    i2c_start(clk_base, data_base);  // restart
8110ace8:	e17ffd17 	ldw	r5,-12(fp)
8110acec:	e13ffc17 	ldw	r4,-16(fp)
8110acf0:	110aec80 	call	8110aec8 <i2c_start>
    DeviceAddr |= 1; // Read
8110acf4:	e0bffe03 	ldbu	r2,-8(fp)
8110acf8:	10800054 	ori	r2,r2,1
8110acfc:	e0bffe05 	stb	r2,-8(fp)
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
8110ad00:	e0bffb17 	ldw	r2,-20(fp)
8110ad04:	10000826 	beq	r2,zero,8110ad28 <I2C_Read+0xc8>
8110ad08:	e0bffe03 	ldbu	r2,-8(fp)
8110ad0c:	10803fcc 	andi	r2,r2,255
8110ad10:	100d883a 	mov	r6,r2
8110ad14:	e17ffd17 	ldw	r5,-12(fp)
8110ad18:	e13ffc17 	ldw	r4,-16(fp)
8110ad1c:	110afdc0 	call	8110afdc <i2c_write>
8110ad20:	1000011e 	bne	r2,zero,8110ad28 <I2C_Read+0xc8>
        bSuccess = FALSE;
8110ad24:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
8110ad28:	e0bffb17 	ldw	r2,-20(fp)
8110ad2c:	10000526 	beq	r2,zero,8110ad44 <I2C_Read+0xe4>
        i2c_read(clk_base, data_base, pControlData, FALSE);  // read
8110ad30:	000f883a 	mov	r7,zero
8110ad34:	e1800217 	ldw	r6,8(fp)
8110ad38:	e17ffd17 	ldw	r5,-12(fp)
8110ad3c:	e13ffc17 	ldw	r4,-16(fp)
8110ad40:	110b1140 	call	8110b114 <i2c_read>
    }        
    i2c_stop(clk_base, data_base);
8110ad44:	e17ffd17 	ldw	r5,-12(fp)
8110ad48:	e13ffc17 	ldw	r4,-16(fp)
8110ad4c:	110af5c0 	call	8110af5c <i2c_stop>
    
    return bSuccess;
8110ad50:	e0bffb17 	ldw	r2,-20(fp)
}
8110ad54:	e037883a 	mov	sp,fp
8110ad58:	dfc00117 	ldw	ra,4(sp)
8110ad5c:	df000017 	ldw	fp,0(sp)
8110ad60:	dec00204 	addi	sp,sp,8
8110ad64:	f800283a 	ret

8110ad68 <I2C_MultipleRead>:

bool I2C_MultipleRead(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 szData[], alt_u16 len){
8110ad68:	defff604 	addi	sp,sp,-40
8110ad6c:	de00012e 	bgeu	sp,et,8110ad74 <I2C_MultipleRead+0xc>
8110ad70:	003b68fa 	trap	3
8110ad74:	dfc00915 	stw	ra,36(sp)
8110ad78:	df000815 	stw	fp,32(sp)
8110ad7c:	df000804 	addi	fp,sp,32
8110ad80:	e13ffb15 	stw	r4,-20(fp)
8110ad84:	e17ffc15 	stw	r5,-16(fp)
8110ad88:	3007883a 	mov	r3,r6
8110ad8c:	e1fffe15 	stw	r7,-8(fp)
8110ad90:	e0800217 	ldw	r2,8(fp)
8110ad94:	e0fffd05 	stb	r3,-12(fp)
8110ad98:	e0bfff0d 	sth	r2,-4(fp)
    int i;
    bool bSuccess = TRUE;
8110ad9c:	00800044 	movi	r2,1
8110ada0:	e0bff915 	stw	r2,-28(fp)
    //alt_u8 DeviceAddr, 
    alt_u8 ControlAddr = 0;
8110ada4:	e03ffa05 	stb	zero,-24(fp)
    
   
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8110ada8:	e17ffc17 	ldw	r5,-16(fp)
8110adac:	e13ffb17 	ldw	r4,-20(fp)
8110adb0:	110aec80 	call	8110aec8 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8110adb4:	e0bffd03 	ldbu	r2,-12(fp)
8110adb8:	10803fcc 	andi	r2,r2,255
8110adbc:	100d883a 	mov	r6,r2
8110adc0:	e17ffc17 	ldw	r5,-16(fp)
8110adc4:	e13ffb17 	ldw	r4,-20(fp)
8110adc8:	110afdc0 	call	8110afdc <i2c_write>
8110adcc:	1000011e 	bne	r2,zero,8110add4 <I2C_MultipleRead+0x6c>
        bSuccess = FALSE;
8110add0:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
8110add4:	e0bff917 	ldw	r2,-28(fp)
8110add8:	10000726 	beq	r2,zero,8110adf8 <I2C_MultipleRead+0x90>
8110addc:	e0bffa03 	ldbu	r2,-24(fp)
8110ade0:	100d883a 	mov	r6,r2
8110ade4:	e17ffc17 	ldw	r5,-16(fp)
8110ade8:	e13ffb17 	ldw	r4,-20(fp)
8110adec:	110afdc0 	call	8110afdc <i2c_write>
8110adf0:	1000011e 	bne	r2,zero,8110adf8 <I2C_MultipleRead+0x90>
        bSuccess = FALSE;
8110adf4:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }    
    if (bSuccess)        
8110adf8:	e0bff917 	ldw	r2,-28(fp)
8110adfc:	10000326 	beq	r2,zero,8110ae0c <I2C_MultipleRead+0xa4>
        i2c_start(clk_base, data_base);  // restart
8110ae00:	e17ffc17 	ldw	r5,-16(fp)
8110ae04:	e13ffb17 	ldw	r4,-20(fp)
8110ae08:	110aec80 	call	8110aec8 <i2c_start>
    DeviceAddr |= 1; // Read
8110ae0c:	e0bffd03 	ldbu	r2,-12(fp)
8110ae10:	10800054 	ori	r2,r2,1
8110ae14:	e0bffd05 	stb	r2,-12(fp)
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
8110ae18:	e0bff917 	ldw	r2,-28(fp)
8110ae1c:	10000826 	beq	r2,zero,8110ae40 <I2C_MultipleRead+0xd8>
8110ae20:	e0bffd03 	ldbu	r2,-12(fp)
8110ae24:	10803fcc 	andi	r2,r2,255
8110ae28:	100d883a 	mov	r6,r2
8110ae2c:	e17ffc17 	ldw	r5,-16(fp)
8110ae30:	e13ffb17 	ldw	r4,-20(fp)
8110ae34:	110afdc0 	call	8110afdc <i2c_write>
8110ae38:	1000011e 	bne	r2,zero,8110ae40 <I2C_MultipleRead+0xd8>
        bSuccess = FALSE;
8110ae3c:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
8110ae40:	e0bff917 	ldw	r2,-28(fp)
8110ae44:	10001726 	beq	r2,zero,8110aea4 <I2C_MultipleRead+0x13c>
        for(i=0;i<len && bSuccess;i++){
8110ae48:	e03ff815 	stw	zero,-32(fp)
8110ae4c:	00001006 	br	8110ae90 <I2C_MultipleRead+0x128>
            i2c_read(clk_base, data_base, &szData[i], (i==(len-1))?FALSE:TRUE);  // read
8110ae50:	e0bff817 	ldw	r2,-32(fp)
8110ae54:	e0fffe17 	ldw	r3,-8(fp)
8110ae58:	1889883a 	add	r4,r3,r2
8110ae5c:	e0bfff0b 	ldhu	r2,-4(fp)
8110ae60:	10ffffc4 	addi	r3,r2,-1
8110ae64:	e0bff817 	ldw	r2,-32(fp)
8110ae68:	1884c03a 	cmpne	r2,r3,r2
8110ae6c:	10803fcc 	andi	r2,r2,255
8110ae70:	100f883a 	mov	r7,r2
8110ae74:	200d883a 	mov	r6,r4
8110ae78:	e17ffc17 	ldw	r5,-16(fp)
8110ae7c:	e13ffb17 	ldw	r4,-20(fp)
8110ae80:	110b1140 	call	8110b114 <i2c_read>
        bSuccess = FALSE;
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
        for(i=0;i<len && bSuccess;i++){
8110ae84:	e0bff817 	ldw	r2,-32(fp)
8110ae88:	10800044 	addi	r2,r2,1
8110ae8c:	e0bff815 	stw	r2,-32(fp)
8110ae90:	e0bfff0b 	ldhu	r2,-4(fp)
8110ae94:	e0fff817 	ldw	r3,-32(fp)
8110ae98:	1880020e 	bge	r3,r2,8110aea4 <I2C_MultipleRead+0x13c>
8110ae9c:	e0bff917 	ldw	r2,-28(fp)
8110aea0:	103feb1e 	bne	r2,zero,8110ae50 <__reset+0xfb0eae50>
            i2c_read(clk_base, data_base, &szData[i], (i==(len-1))?FALSE:TRUE);  // read
        }            
    }        
    i2c_stop(clk_base, data_base);
8110aea4:	e17ffc17 	ldw	r5,-16(fp)
8110aea8:	e13ffb17 	ldw	r4,-20(fp)
8110aeac:	110af5c0 	call	8110af5c <i2c_stop>
    
    return bSuccess;    
8110aeb0:	e0bff917 	ldw	r2,-28(fp)
    
}
8110aeb4:	e037883a 	mov	sp,fp
8110aeb8:	dfc00117 	ldw	ra,4(sp)
8110aebc:	df000017 	ldw	fp,0(sp)
8110aec0:	dec00204 	addi	sp,sp,8
8110aec4:	f800283a 	ret

8110aec8 <i2c_start>:
///////////// Interncal function (i2cXXX) body //////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////


//SDA 1->0 while SCL=1
void i2c_start(alt_u32 clk_base, alt_u32 data_base){
8110aec8:	defffc04 	addi	sp,sp,-16
8110aecc:	de00012e 	bgeu	sp,et,8110aed4 <i2c_start+0xc>
8110aed0:	003b68fa 	trap	3
8110aed4:	dfc00315 	stw	ra,12(sp)
8110aed8:	df000215 	stw	fp,8(sp)
8110aedc:	df000204 	addi	fp,sp,8
8110aee0:	e13ffe15 	stw	r4,-8(fp)
8110aee4:	e17fff15 	stw	r5,-4(fp)
    
    // make sure it is in normal state
    SDA_DIR_OUT(data_base);  // data output enabled
8110aee8:	e0bfff17 	ldw	r2,-4(fp)
8110aeec:	10800104 	addi	r2,r2,4
8110aef0:	1007883a 	mov	r3,r2
8110aef4:	00800044 	movi	r2,1
8110aef8:	18800035 	stwio	r2,0(r3)
    
    
    
    // start condition
    SDA_HIGH(data_base); // data high
8110aefc:	e0bfff17 	ldw	r2,-4(fp)
8110af00:	00c00044 	movi	r3,1
8110af04:	10c00035 	stwio	r3,0(r2)
    SCL_HIGH(clk_base);
8110af08:	e0bffe17 	ldw	r2,-8(fp)
8110af0c:	00c00044 	movi	r3,1
8110af10:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;
8110af14:	01000044 	movi	r4,1
8110af18:	11376bc0 	call	811376bc <usleep>
     
    SDA_LOW(data_base); // data low
8110af1c:	e0bfff17 	ldw	r2,-4(fp)
8110af20:	0007883a 	mov	r3,zero
8110af24:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; 
8110af28:	01000044 	movi	r4,1
8110af2c:	11376bc0 	call	811376bc <usleep>
    SCL_LOW(clk_base); // clock low
8110af30:	e0bffe17 	ldw	r2,-8(fp)
8110af34:	0007883a 	mov	r3,zero
8110af38:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;
8110af3c:	01000044 	movi	r4,1
8110af40:	11376bc0 	call	811376bc <usleep>
}
8110af44:	0001883a 	nop
8110af48:	e037883a 	mov	sp,fp
8110af4c:	dfc00117 	ldw	ra,4(sp)
8110af50:	df000017 	ldw	fp,0(sp)
8110af54:	dec00204 	addi	sp,sp,8
8110af58:	f800283a 	ret

8110af5c <i2c_stop>:

// SDA 0->1 while SCL=1
void i2c_stop(alt_u32 clk_base, alt_u32 data_base){
8110af5c:	defffc04 	addi	sp,sp,-16
8110af60:	de00012e 	bgeu	sp,et,8110af68 <i2c_stop+0xc>
8110af64:	003b68fa 	trap	3
8110af68:	dfc00315 	stw	ra,12(sp)
8110af6c:	df000215 	stw	fp,8(sp)
8110af70:	df000204 	addi	fp,sp,8
8110af74:	e13ffe15 	stw	r4,-8(fp)
8110af78:	e17fff15 	stw	r5,-4(fp)
    // assume SCL = 0
    
    SDA_DIR_OUT(data_base);  // data output enabled
8110af7c:	e0bfff17 	ldw	r2,-4(fp)
8110af80:	10800104 	addi	r2,r2,4
8110af84:	1007883a 	mov	r3,r2
8110af88:	00800044 	movi	r2,1
8110af8c:	18800035 	stwio	r2,0(r3)
    SDA_LOW(data_base); // Data Low
8110af90:	e0bfff17 	ldw	r2,-4(fp)
8110af94:	0007883a 	mov	r3,zero
8110af98:	10c00035 	stwio	r3,0(r2)
    //SCL_DELAY; 
    SCL_HIGH(clk_base);  // clock high
8110af9c:	e0bffe17 	ldw	r2,-8(fp)
8110afa0:	00c00044 	movi	r3,1
8110afa4:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock high long delay
8110afa8:	01000044 	movi	r4,1
8110afac:	11376bc0 	call	811376bc <usleep>
    SDA_HIGH(data_base); // data high
8110afb0:	e0bfff17 	ldw	r2,-4(fp)
8110afb4:	00c00044 	movi	r3,1
8110afb8:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // data high delay
8110afbc:	01000044 	movi	r4,1
8110afc0:	11376bc0 	call	811376bc <usleep>
    

    
}
8110afc4:	0001883a 	nop
8110afc8:	e037883a 	mov	sp,fp
8110afcc:	dfc00117 	ldw	ra,4(sp)
8110afd0:	df000017 	ldw	fp,0(sp)
8110afd4:	dec00204 	addi	sp,sp,8
8110afd8:	f800283a 	ret

8110afdc <i2c_write>:

bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data){ // return true if device response ack
8110afdc:	defff804 	addi	sp,sp,-32
8110afe0:	de00012e 	bgeu	sp,et,8110afe8 <i2c_write+0xc>
8110afe4:	003b68fa 	trap	3
8110afe8:	dfc00715 	stw	ra,28(sp)
8110afec:	df000615 	stw	fp,24(sp)
8110aff0:	df000604 	addi	fp,sp,24
8110aff4:	e13ffd15 	stw	r4,-12(fp)
8110aff8:	e17ffe15 	stw	r5,-8(fp)
8110affc:	3005883a 	mov	r2,r6
8110b000:	e0bfff05 	stb	r2,-4(fp)
    alt_u8 Mask = 0x80;
8110b004:	00bfe004 	movi	r2,-128
8110b008:	e0bffa05 	stb	r2,-24(fp)
    bool bAck;
    int i;
    
    // assume, SCL = 0
    
    SDA_DIR_OUT(data_base);  // data write mode
8110b00c:	e0bffe17 	ldw	r2,-8(fp)
8110b010:	10800104 	addi	r2,r2,4
8110b014:	1007883a 	mov	r3,r2
8110b018:	00800044 	movi	r2,1
8110b01c:	18800035 	stwio	r2,0(r3)
    
    for(i=0;i<8;i++){
8110b020:	e03ffb15 	stw	zero,-20(fp)
8110b024:	00001f06 	br	8110b0a4 <i2c_write+0xc8>
        SCL_LOW(clk_base);  // new, make sure data change at clk low
8110b028:	e0bffd17 	ldw	r2,-12(fp)
8110b02c:	0007883a 	mov	r3,zero
8110b030:	10c00035 	stwio	r3,0(r2)
        // output data on bus
        if (Data & Mask){ // there is a delay in this command
8110b034:	e0ffff03 	ldbu	r3,-4(fp)
8110b038:	e0bffa03 	ldbu	r2,-24(fp)
8110b03c:	1884703a 	and	r2,r3,r2
8110b040:	10803fcc 	andi	r2,r2,255
8110b044:	10000426 	beq	r2,zero,8110b058 <i2c_write+0x7c>
            SDA_HIGH(data_base);
8110b048:	e0bffe17 	ldw	r2,-8(fp)
8110b04c:	00c00044 	movi	r3,1
8110b050:	10c00035 	stwio	r3,0(r2)
8110b054:	00000306 	br	8110b064 <i2c_write+0x88>
        }else{    
            SDA_LOW(data_base);
8110b058:	e0bffe17 	ldw	r2,-8(fp)
8110b05c:	0007883a 	mov	r3,zero
8110b060:	10c00035 	stwio	r3,0(r2)
        }
        Mask >>= 1; // there is a delay in this command
8110b064:	e0bffa03 	ldbu	r2,-24(fp)
8110b068:	1004d07a 	srli	r2,r2,1
8110b06c:	e0bffa05 	stb	r2,-24(fp)
        // clock high
        SCL_HIGH(clk_base);
8110b070:	e0bffd17 	ldw	r2,-12(fp)
8110b074:	00c00044 	movi	r3,1
8110b078:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110b07c:	01000044 	movi	r4,1
8110b080:	11376bc0 	call	811376bc <usleep>
        SCL_LOW(clk_base);
8110b084:	e0bffd17 	ldw	r2,-12(fp)
8110b088:	0007883a 	mov	r3,zero
8110b08c:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110b090:	01000044 	movi	r4,1
8110b094:	11376bc0 	call	811376bc <usleep>
    
    // assume, SCL = 0
    
    SDA_DIR_OUT(data_base);  // data write mode
    
    for(i=0;i<8;i++){
8110b098:	e0bffb17 	ldw	r2,-20(fp)
8110b09c:	10800044 	addi	r2,r2,1
8110b0a0:	e0bffb15 	stw	r2,-20(fp)
8110b0a4:	e0bffb17 	ldw	r2,-20(fp)
8110b0a8:	10800210 	cmplti	r2,r2,8
8110b0ac:	103fde1e 	bne	r2,zero,8110b028 <__reset+0xfb0eb028>
        SCL_LOW(clk_base);
        SCL_DELAY;
    }
    
    //===== get ack
    SDA_DIR_IN(data_base);  // data read mode
8110b0b0:	e0bffe17 	ldw	r2,-8(fp)
8110b0b4:	10800104 	addi	r2,r2,4
8110b0b8:	0007883a 	mov	r3,zero
8110b0bc:	10c00035 	stwio	r3,0(r2)
    //SCL_DELAY;
    // clock high
    SCL_HIGH(clk_base);  // clock high
8110b0c0:	e0bffd17 	ldw	r2,-12(fp)
8110b0c4:	00c00044 	movi	r3,1
8110b0c8:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;  // clock high delay
8110b0cc:	01000044 	movi	r4,1
8110b0d0:	11376bc0 	call	811376bc <usleep>
    bAck = SDA_READ(data_base)?FALSE:TRUE;  // get ack
8110b0d4:	e0bffe17 	ldw	r2,-8(fp)
8110b0d8:	10800037 	ldwio	r2,0(r2)
8110b0dc:	1005003a 	cmpeq	r2,r2,zero
8110b0e0:	10803fcc 	andi	r2,r2,255
8110b0e4:	e0bffc15 	stw	r2,-16(fp)
    //SCL_DELAY;
    //SDA_DIR_OUT;
    SCL_LOW(clk_base); // clock low         
8110b0e8:	e0bffd17 	ldw	r2,-12(fp)
8110b0ec:	0007883a 	mov	r3,zero
8110b0f0:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
8110b0f4:	01000044 	movi	r4,1
8110b0f8:	11376bc0 	call	811376bc <usleep>
    return bAck;
8110b0fc:	e0bffc17 	ldw	r2,-16(fp)
}    
8110b100:	e037883a 	mov	sp,fp
8110b104:	dfc00117 	ldw	ra,4(sp)
8110b108:	df000017 	ldw	fp,0(sp)
8110b10c:	dec00204 	addi	sp,sp,8
8110b110:	f800283a 	ret

8110b114 <i2c_read>:

void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck){ // return true if device response ack
8110b114:	defff804 	addi	sp,sp,-32
8110b118:	de00012e 	bgeu	sp,et,8110b120 <i2c_read+0xc>
8110b11c:	003b68fa 	trap	3
8110b120:	dfc00715 	stw	ra,28(sp)
8110b124:	df000615 	stw	fp,24(sp)
8110b128:	df000604 	addi	fp,sp,24
8110b12c:	e13ffc15 	stw	r4,-16(fp)
8110b130:	e17ffd15 	stw	r5,-12(fp)
8110b134:	e1bffe15 	stw	r6,-8(fp)
8110b138:	e1ffff15 	stw	r7,-4(fp)
    alt_u8 Data=0;
8110b13c:	e03ffa05 	stb	zero,-24(fp)
    int i;
    
    // assume SCL = low
    
    SDA_DIR_IN(data_base);  // set data read mode
8110b140:	e0bffd17 	ldw	r2,-12(fp)
8110b144:	10800104 	addi	r2,r2,4
8110b148:	0007883a 	mov	r3,zero
8110b14c:	10c00035 	stwio	r3,0(r2)
    SCL_LOW(clk_base); // clock low
8110b150:	e0bffc17 	ldw	r2,-16(fp)
8110b154:	0007883a 	mov	r3,zero
8110b158:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
8110b15c:	01000044 	movi	r4,1
8110b160:	11376bc0 	call	811376bc <usleep>

    for(i=0;i<8;i++){
8110b164:	e03ffb15 	stw	zero,-20(fp)
8110b168:	00001606 	br	8110b1c4 <i2c_read+0xb0>
        Data <<= 1;
8110b16c:	e0bffa03 	ldbu	r2,-24(fp)
8110b170:	1085883a 	add	r2,r2,r2
8110b174:	e0bffa05 	stb	r2,-24(fp)
        SCL_HIGH(clk_base);  // clock high
8110b178:	e0bffc17 	ldw	r2,-16(fp)
8110b17c:	00c00044 	movi	r3,1
8110b180:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110b184:	01000044 	movi	r4,1
8110b188:	11376bc0 	call	811376bc <usleep>
        if (SDA_READ(data_base))  // read data   
8110b18c:	e0bffd17 	ldw	r2,-12(fp)
8110b190:	10800037 	ldwio	r2,0(r2)
8110b194:	10000326 	beq	r2,zero,8110b1a4 <i2c_read+0x90>
            Data |= 0x01;
8110b198:	e0bffa03 	ldbu	r2,-24(fp)
8110b19c:	10800054 	ori	r2,r2,1
8110b1a0:	e0bffa05 	stb	r2,-24(fp)
        SCL_LOW(clk_base);  // clock log  
8110b1a4:	e0bffc17 	ldw	r2,-16(fp)
8110b1a8:	0007883a 	mov	r3,zero
8110b1ac:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110b1b0:	01000044 	movi	r4,1
8110b1b4:	11376bc0 	call	811376bc <usleep>
    
    SDA_DIR_IN(data_base);  // set data read mode
    SCL_LOW(clk_base); // clock low
    SCL_DELAY; // clock low delay

    for(i=0;i<8;i++){
8110b1b8:	e0bffb17 	ldw	r2,-20(fp)
8110b1bc:	10800044 	addi	r2,r2,1
8110b1c0:	e0bffb15 	stw	r2,-20(fp)
8110b1c4:	e0bffb17 	ldw	r2,-20(fp)
8110b1c8:	10800210 	cmplti	r2,r2,8
8110b1cc:	103fe71e 	bne	r2,zero,8110b16c <__reset+0xfb0eb16c>
        SCL_LOW(clk_base);  // clock log  
        SCL_DELAY;
    }
    
    // send ACK
    SCL_LOW(clk_base);  // new, make sure data change at clk low
8110b1d0:	e0bffc17 	ldw	r2,-16(fp)
8110b1d4:	0007883a 	mov	r3,zero
8110b1d8:	10c00035 	stwio	r3,0(r2)
    SDA_DIR_OUT(data_base);  // set data write mode
8110b1dc:	e0bffd17 	ldw	r2,-12(fp)
8110b1e0:	10800104 	addi	r2,r2,4
8110b1e4:	1007883a 	mov	r3,r2
8110b1e8:	00800044 	movi	r2,1
8110b1ec:	18800035 	stwio	r2,0(r3)
    if (bAck)
8110b1f0:	e0bfff17 	ldw	r2,-4(fp)
8110b1f4:	10000426 	beq	r2,zero,8110b208 <i2c_read+0xf4>
        SDA_LOW(data_base);
8110b1f8:	e0bffd17 	ldw	r2,-12(fp)
8110b1fc:	0007883a 	mov	r3,zero
8110b200:	10c00035 	stwio	r3,0(r2)
8110b204:	00000306 	br	8110b214 <i2c_read+0x100>
    else
        SDA_HIGH(data_base);
8110b208:	e0bffd17 	ldw	r2,-12(fp)
8110b20c:	00c00044 	movi	r3,1
8110b210:	10c00035 	stwio	r3,0(r2)
    SCL_HIGH(clk_base); // clock high
8110b214:	e0bffc17 	ldw	r2,-16(fp)
8110b218:	00c00044 	movi	r3,1
8110b21c:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock high  delay
8110b220:	01000044 	movi	r4,1
8110b224:	11376bc0 	call	811376bc <usleep>
    SCL_LOW(clk_base); // clock low
8110b228:	e0bffc17 	ldw	r2,-16(fp)
8110b22c:	0007883a 	mov	r3,zero
8110b230:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
8110b234:	01000044 	movi	r4,1
8110b238:	11376bc0 	call	811376bc <usleep>
    SDA_LOW(data_base);  // data low
8110b23c:	e0bffd17 	ldw	r2,-12(fp)
8110b240:	0007883a 	mov	r3,zero
8110b244:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // data low delay
8110b248:	01000044 	movi	r4,1
8110b24c:	11376bc0 	call	811376bc <usleep>
//    SDA_DIR_IN;  // set data read mode
    
    *pData = Data;
8110b250:	e0bffe17 	ldw	r2,-8(fp)
8110b254:	e0fffa03 	ldbu	r3,-24(fp)
8110b258:	10c00005 	stb	r3,0(r2)
}
8110b25c:	0001883a 	nop
8110b260:	e037883a 	mov	sp,fp
8110b264:	dfc00117 	ldw	ra,4(sp)
8110b268:	df000017 	ldw	fp,0(sp)
8110b26c:	dec00204 	addi	sp,sp,8
8110b270:	f800283a 	ret

8110b274 <bSetBoardLeds>:
 * @param [in] LedsMask  Mascara de leds a serem modificados
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSetBoardLeds(bool bDRIVE, alt_u8 LedsMask){
8110b274:	defffd04 	addi	sp,sp,-12
8110b278:	de00012e 	bgeu	sp,et,8110b280 <bSetBoardLeds+0xc>
8110b27c:	003b68fa 	trap	3
8110b280:	df000215 	stw	fp,8(sp)
8110b284:	df000204 	addi	fp,sp,8
8110b288:	e13ffe15 	stw	r4,-8(fp)
8110b28c:	2805883a 	mov	r2,r5
8110b290:	e0bfff05 	stb	r2,-4(fp)

  // Board LEDs state: ON = 0; OFF = 1;

  if (bDRIVE == LEDS_ON){
8110b294:	e0bffe17 	ldw	r2,-8(fp)
8110b298:	10800058 	cmpnei	r2,r2,1
8110b29c:	1000071e 	bne	r2,zero,8110b2bc <bSetBoardLeds+0x48>
	LedsBoardControl &= (~LedsMask);
8110b2a0:	e0bfff03 	ldbu	r2,-4(fp)
8110b2a4:	0084303a 	nor	r2,zero,r2
8110b2a8:	1007883a 	mov	r3,r2
8110b2ac:	d0a05003 	ldbu	r2,-32448(gp)
8110b2b0:	1884703a 	and	r2,r3,r2
8110b2b4:	d0a05005 	stb	r2,-32448(gp)
8110b2b8:	00000406 	br	8110b2cc <bSetBoardLeds+0x58>
  } else {
	LedsBoardControl |= LedsMask;
8110b2bc:	d0e05003 	ldbu	r3,-32448(gp)
8110b2c0:	e0bfff03 	ldbu	r2,-4(fp)
8110b2c4:	1884b03a 	or	r2,r3,r2
8110b2c8:	d0a05005 	stb	r2,-32448(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LEDS_BOARD_BASE, LedsBoardControl);
8110b2cc:	d0a05003 	ldbu	r2,-32448(gp)
8110b2d0:	10c03fcc 	andi	r3,r2,255
8110b2d4:	00a00034 	movhi	r2,32768
8110b2d8:	10827404 	addi	r2,r2,2512
8110b2dc:	10c00035 	stwio	r3,0(r2)

  return TRUE;
8110b2e0:	00800044 	movi	r2,1
}
8110b2e4:	e037883a 	mov	sp,fp
8110b2e8:	df000017 	ldw	fp,0(sp)
8110b2ec:	dec00104 	addi	sp,sp,4
8110b2f0:	f800283a 	ret

8110b2f4 <bSetPainelLeds>:
 * @param [in] LedsMask  Mascara de leds a serem modificados
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSetPainelLeds(bool bDRIVE, alt_u32 LedsMask){
8110b2f4:	defffd04 	addi	sp,sp,-12
8110b2f8:	de00012e 	bgeu	sp,et,8110b300 <bSetPainelLeds+0xc>
8110b2fc:	003b68fa 	trap	3
8110b300:	df000215 	stw	fp,8(sp)
8110b304:	df000204 	addi	fp,sp,8
8110b308:	e13ffe15 	stw	r4,-8(fp)
8110b30c:	e17fff15 	stw	r5,-4(fp)

  // Painel LEDs state: ON = 1; OFF = 0;

  if (bDRIVE == LEDS_ON){
8110b310:	e0bffe17 	ldw	r2,-8(fp)
8110b314:	10800058 	cmpnei	r2,r2,1
8110b318:	1000051e 	bne	r2,zero,8110b330 <bSetPainelLeds+0x3c>
	LedsPainelControl |= LedsMask;
8110b31c:	d0e00217 	ldw	r3,-32760(gp)
8110b320:	e0bfff17 	ldw	r2,-4(fp)
8110b324:	1884b03a 	or	r2,r3,r2
8110b328:	d0a00215 	stw	r2,-32760(gp)
8110b32c:	00000506 	br	8110b344 <bSetPainelLeds+0x50>
  } else {
	LedsPainelControl &= (~LedsMask);
8110b330:	e0bfff17 	ldw	r2,-4(fp)
8110b334:	0086303a 	nor	r3,zero,r2
8110b338:	d0a00217 	ldw	r2,-32760(gp)
8110b33c:	1884703a 	and	r2,r3,r2
8110b340:	d0a00215 	stw	r2,-32760(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LEDS_PAINEL_BASE, LedsPainelControl);
8110b344:	d0a00217 	ldw	r2,-32760(gp)
8110b348:	1007883a 	mov	r3,r2
8110b34c:	00a00034 	movhi	r2,32768
8110b350:	10824004 	addi	r2,r2,2304
8110b354:	10c00035 	stwio	r3,0(r2)

  return TRUE;
8110b358:	00800044 	movi	r2,1
}
8110b35c:	e037883a 	mov	sp,fp
8110b360:	df000017 	ldw	fp,0(sp)
8110b364:	dec00104 	addi	sp,sp,4
8110b368:	f800283a 	ret

8110b36c <msgdma_write_extended_descriptor>:
/*
 * This function is used for writing extended descriptors to the dispatcher.  
 It handles only 32-bit descriptors.
 */
static int msgdma_write_extended_descriptor(alt_u32 *csr_base,
		alt_u32 *descriptor_base, alt_msgdma_extended_descriptor *descriptor) {
8110b36c:	defffc04 	addi	sp,sp,-16
8110b370:	de00012e 	bgeu	sp,et,8110b378 <msgdma_write_extended_descriptor+0xc>
8110b374:	003b68fa 	trap	3
8110b378:	df000315 	stw	fp,12(sp)
8110b37c:	df000304 	addi	fp,sp,12
8110b380:	e13ffd15 	stw	r4,-12(fp)
8110b384:	e17ffe15 	stw	r5,-8(fp)
8110b388:	e1bfff15 	stw	r6,-4(fp)
	if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) &
8110b38c:	e0bffd17 	ldw	r2,-12(fp)
8110b390:	10800037 	ldwio	r2,0(r2)
8110b394:	1080010c 	andi	r2,r2,4
8110b398:	10000226 	beq	r2,zero,8110b3a4 <msgdma_write_extended_descriptor+0x38>
	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
		/*at least one descriptor buffer is full, returning so that this function
		 is non-blocking*/
		return -ENOSPC;
8110b39c:	00bff904 	movi	r2,-28
8110b3a0:	00003d06 	br	8110b498 <msgdma_write_extended_descriptor+0x12c>
	}

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base,
8110b3a4:	e0bfff17 	ldw	r2,-4(fp)
8110b3a8:	10800017 	ldw	r2,0(r2)
8110b3ac:	1007883a 	mov	r3,r2
8110b3b0:	e0bffe17 	ldw	r2,-8(fp)
8110b3b4:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->read_address_low);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base,
8110b3b8:	e0bffe17 	ldw	r2,-8(fp)
8110b3bc:	10800104 	addi	r2,r2,4
8110b3c0:	e0ffff17 	ldw	r3,-4(fp)
8110b3c4:	18c00117 	ldw	r3,4(r3)
8110b3c8:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->write_address_low);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base,
8110b3cc:	e0bffe17 	ldw	r2,-8(fp)
8110b3d0:	10800204 	addi	r2,r2,8
8110b3d4:	e0ffff17 	ldw	r3,-4(fp)
8110b3d8:	18c00217 	ldw	r3,8(r3)
8110b3dc:	10c00035 	stwio	r3,0(r2)
			descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(descriptor_base,
8110b3e0:	e0bffe17 	ldw	r2,-8(fp)
8110b3e4:	10800304 	addi	r2,r2,12
8110b3e8:	e0ffff17 	ldw	r3,-4(fp)
8110b3ec:	18c0030b 	ldhu	r3,12(r3)
8110b3f0:	18ffffcc 	andi	r3,r3,65535
8110b3f4:	10c0002d 	sthio	r3,0(r2)
			descriptor->sequence_number);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(descriptor_base,
8110b3f8:	e0bffe17 	ldw	r2,-8(fp)
8110b3fc:	10800384 	addi	r2,r2,14
8110b400:	e0ffff17 	ldw	r3,-4(fp)
8110b404:	18c00383 	ldbu	r3,14(r3)
8110b408:	18c03fcc 	andi	r3,r3,255
8110b40c:	10c00025 	stbio	r3,0(r2)
			descriptor->read_burst_count);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(descriptor_base,
8110b410:	e0bffe17 	ldw	r2,-8(fp)
8110b414:	108003c4 	addi	r2,r2,15
8110b418:	e0ffff17 	ldw	r3,-4(fp)
8110b41c:	18c003c3 	ldbu	r3,15(r3)
8110b420:	18c03fcc 	andi	r3,r3,255
8110b424:	10c00025 	stbio	r3,0(r2)
			descriptor->write_burst_count);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(descriptor_base,
8110b428:	e0bffe17 	ldw	r2,-8(fp)
8110b42c:	10800404 	addi	r2,r2,16
8110b430:	e0ffff17 	ldw	r3,-4(fp)
8110b434:	18c0040b 	ldhu	r3,16(r3)
8110b438:	18ffffcc 	andi	r3,r3,65535
8110b43c:	10c0002d 	sthio	r3,0(r2)
			descriptor->read_stride);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(descriptor_base,
8110b440:	e0bffe17 	ldw	r2,-8(fp)
8110b444:	10800484 	addi	r2,r2,18
8110b448:	e0ffff17 	ldw	r3,-4(fp)
8110b44c:	18c0048b 	ldhu	r3,18(r3)
8110b450:	18ffffcc 	andi	r3,r3,65535
8110b454:	10c0002d 	sthio	r3,0(r2)
			descriptor->write_stride);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base,
8110b458:	e0bffe17 	ldw	r2,-8(fp)
8110b45c:	10800504 	addi	r2,r2,20
8110b460:	e0ffff17 	ldw	r3,-4(fp)
8110b464:	18c00517 	ldw	r3,20(r3)
8110b468:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->read_address_high);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base,
8110b46c:	e0bffe17 	ldw	r2,-8(fp)
8110b470:	10800604 	addi	r2,r2,24
8110b474:	e0ffff17 	ldw	r3,-4(fp)
8110b478:	18c00617 	ldw	r3,24(r3)
8110b47c:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->write_address_high);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(descriptor_base,
8110b480:	e0bffe17 	ldw	r2,-8(fp)
8110b484:	10800704 	addi	r2,r2,28
8110b488:	e0ffff17 	ldw	r3,-4(fp)
8110b48c:	18c00717 	ldw	r3,28(r3)
8110b490:	10c00035 	stwio	r3,0(r2)
			descriptor->control);
	return 0;
8110b494:	0005883a 	mov	r2,zero
}
8110b498:	e037883a 	mov	sp,fp
8110b49c:	df000017 	ldw	fp,0(sp)
8110b4a0:	dec00104 	addi	sp,sp,4
8110b4a4:	f800283a 	ret

8110b4a8 <msgdma_construct_extended_descriptor>:
static int msgdma_construct_extended_descriptor(alt_msgdma_dev *dev,
		alt_msgdma_extended_descriptor *descriptor, alt_u32 *read_address,
		alt_u32 *write_address, alt_u32 length, alt_u32 control,
		alt_u32 *read_address_high, alt_u32 *write_address_high,
		alt_u16 sequence_number, alt_u8 read_burst_count,
		alt_u8 write_burst_count, alt_u16 read_stride, alt_u16 write_stride) {
8110b4a8:	defff604 	addi	sp,sp,-40
8110b4ac:	de00012e 	bgeu	sp,et,8110b4b4 <msgdma_construct_extended_descriptor+0xc>
8110b4b0:	003b68fa 	trap	3
8110b4b4:	df000915 	stw	fp,36(sp)
8110b4b8:	df000904 	addi	fp,sp,36
8110b4bc:	e13ff715 	stw	r4,-36(fp)
8110b4c0:	e17ff815 	stw	r5,-32(fp)
8110b4c4:	e1bff915 	stw	r6,-28(fp)
8110b4c8:	e1fffa15 	stw	r7,-24(fp)
8110b4cc:	e1800517 	ldw	r6,20(fp)
8110b4d0:	e1400617 	ldw	r5,24(fp)
8110b4d4:	e1000717 	ldw	r4,28(fp)
8110b4d8:	e0c00817 	ldw	r3,32(fp)
8110b4dc:	e0800917 	ldw	r2,36(fp)
8110b4e0:	e1bffb0d 	sth	r6,-20(fp)
8110b4e4:	e17ffc05 	stb	r5,-16(fp)
8110b4e8:	e13ffd05 	stb	r4,-12(fp)
8110b4ec:	e0fffe0d 	sth	r3,-8(fp)
8110b4f0:	e0bfff0d 	sth	r2,-4(fp)
	if (dev->max_byte < length || dev->max_stride < read_stride
8110b4f4:	e0bff717 	ldw	r2,-36(fp)
8110b4f8:	10c01217 	ldw	r3,72(r2)
8110b4fc:	e0800117 	ldw	r2,4(fp)
8110b500:	18801936 	bltu	r3,r2,8110b568 <msgdma_construct_extended_descriptor+0xc0>
8110b504:	e13ff717 	ldw	r4,-36(fp)
8110b508:	20801317 	ldw	r2,76(r4)
8110b50c:	20c01417 	ldw	r3,80(r4)
8110b510:	e13ffe0b 	ldhu	r4,-8(fp)
8110b514:	213fffcc 	andi	r4,r4,65535
8110b518:	2015883a 	mov	r10,r4
8110b51c:	0017883a 	mov	r11,zero
8110b520:	1ac01136 	bltu	r3,r11,8110b568 <msgdma_construct_extended_descriptor+0xc0>
8110b524:	58c0011e 	bne	r11,r3,8110b52c <msgdma_construct_extended_descriptor+0x84>
8110b528:	12800f36 	bltu	r2,r10,8110b568 <msgdma_construct_extended_descriptor+0xc0>
			|| dev->max_stride < write_stride || dev->enhanced_features != 1) {
8110b52c:	e13ff717 	ldw	r4,-36(fp)
8110b530:	20801317 	ldw	r2,76(r4)
8110b534:	20c01417 	ldw	r3,80(r4)
8110b538:	e13fff0b 	ldhu	r4,-4(fp)
8110b53c:	213fffcc 	andi	r4,r4,65535
8110b540:	2011883a 	mov	r8,r4
8110b544:	0013883a 	mov	r9,zero
8110b548:	1a400736 	bltu	r3,r9,8110b568 <msgdma_construct_extended_descriptor+0xc0>
8110b54c:	48c0011e 	bne	r9,r3,8110b554 <msgdma_construct_extended_descriptor+0xac>
8110b550:	12000536 	bltu	r2,r8,8110b568 <msgdma_construct_extended_descriptor+0xc0>
8110b554:	e0bff717 	ldw	r2,-36(fp)
8110b558:	10801703 	ldbu	r2,92(r2)
8110b55c:	10803fcc 	andi	r2,r2,255
8110b560:	10800060 	cmpeqi	r2,r2,1
8110b564:	1000021e 	bne	r2,zero,8110b570 <msgdma_construct_extended_descriptor+0xc8>
		return -EINVAL;
8110b568:	00bffa84 	movi	r2,-22
8110b56c:	00002306 	br	8110b5fc <msgdma_construct_extended_descriptor+0x154>
	}

	descriptor->read_address_low = read_address;
8110b570:	e0bff817 	ldw	r2,-32(fp)
8110b574:	e0fff917 	ldw	r3,-28(fp)
8110b578:	10c00015 	stw	r3,0(r2)
	descriptor->write_address_low = write_address;
8110b57c:	e0bff817 	ldw	r2,-32(fp)
8110b580:	e0fffa17 	ldw	r3,-24(fp)
8110b584:	10c00115 	stw	r3,4(r2)
	descriptor->transfer_length = length;
8110b588:	e0bff817 	ldw	r2,-32(fp)
8110b58c:	e0c00117 	ldw	r3,4(fp)
8110b590:	10c00215 	stw	r3,8(r2)
	descriptor->sequence_number = sequence_number;
8110b594:	e0bff817 	ldw	r2,-32(fp)
8110b598:	e0fffb0b 	ldhu	r3,-20(fp)
8110b59c:	10c0030d 	sth	r3,12(r2)
	descriptor->read_burst_count = read_burst_count;
8110b5a0:	e0bff817 	ldw	r2,-32(fp)
8110b5a4:	e0fffc03 	ldbu	r3,-16(fp)
8110b5a8:	10c00385 	stb	r3,14(r2)
	descriptor->write_burst_count = write_burst_count;
8110b5ac:	e0bff817 	ldw	r2,-32(fp)
8110b5b0:	e0fffd03 	ldbu	r3,-12(fp)
8110b5b4:	10c003c5 	stb	r3,15(r2)
	descriptor->read_stride = read_stride;
8110b5b8:	e0bff817 	ldw	r2,-32(fp)
8110b5bc:	e0fffe0b 	ldhu	r3,-8(fp)
8110b5c0:	10c0040d 	sth	r3,16(r2)
	descriptor->write_stride = write_stride;
8110b5c4:	e0bff817 	ldw	r2,-32(fp)
8110b5c8:	e0ffff0b 	ldhu	r3,-4(fp)
8110b5cc:	10c0048d 	sth	r3,18(r2)
	descriptor->read_address_high = read_address_high;
8110b5d0:	e0bff817 	ldw	r2,-32(fp)
8110b5d4:	e0c00317 	ldw	r3,12(fp)
8110b5d8:	10c00515 	stw	r3,20(r2)
	descriptor->write_address_high = write_address_high;
8110b5dc:	e0bff817 	ldw	r2,-32(fp)
8110b5e0:	e0c00417 	ldw	r3,16(fp)
8110b5e4:	10c00615 	stw	r3,24(r2)
	descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
8110b5e8:	e0800217 	ldw	r2,8(fp)
8110b5ec:	10e00034 	orhi	r3,r2,32768
8110b5f0:	e0bff817 	ldw	r2,-32(fp)
8110b5f4:	10c00715 	stw	r3,28(r2)

	return 0;
8110b5f8:	0005883a 	mov	r2,zero

}
8110b5fc:	e037883a 	mov	sp,fp
8110b600:	df000017 	ldw	fp,0(sp)
8110b604:	dec00104 	addi	sp,sp,4
8110b608:	f800283a 	ret

8110b60c <msgdma_descriptor_async_transfer>:
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
static int msgdma_descriptor_async_transfer(alt_msgdma_dev *dev,
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
8110b60c:	deffee04 	addi	sp,sp,-72
8110b610:	de00012e 	bgeu	sp,et,8110b618 <msgdma_descriptor_async_transfer+0xc>
8110b614:	003b68fa 	trap	3
8110b618:	dfc01115 	stw	ra,68(sp)
8110b61c:	df001015 	stw	fp,64(sp)
8110b620:	df001004 	addi	fp,sp,64
8110b624:	e13ffd15 	stw	r4,-12(fp)
8110b628:	e17ffe15 	stw	r5,-8(fp)
8110b62c:	e1bfff15 	stw	r6,-4(fp)
	alt_u32 control = 0;
8110b630:	e03ff115 	stw	zero,-60(fp)
	alt_irq_context context = 0;
8110b634:	e03ff215 	stw	zero,-56(fp)
	alt_u16 counter = 0;
8110b638:	e03ff00d 	sth	zero,-64(fp)
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110b63c:	e0bffd17 	ldw	r2,-12(fp)
8110b640:	10800317 	ldw	r2,12(r2)
8110b644:	10800204 	addi	r2,r2,8
8110b648:	10800037 	ldwio	r2,0(r2)
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
	alt_u32 control = 0;
	alt_irq_context context = 0;
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
8110b64c:	10bfffcc 	andi	r2,r2,65535
8110b650:	e0bff315 	stw	r2,-52(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110b654:	e0bffd17 	ldw	r2,-12(fp)
8110b658:	10800317 	ldw	r2,12(r2)
8110b65c:	10800204 	addi	r2,r2,8
8110b660:	10800037 	ldwio	r2,0(r2)
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
8110b664:	1004d43a 	srli	r2,r2,16
8110b668:	e0bff415 	stw	r2,-48(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110b66c:	e0bffd17 	ldw	r2,-12(fp)
8110b670:	10800917 	ldw	r2,36(r2)
8110b674:	e0fff417 	ldw	r3,-48(fp)
8110b678:	1880042e 	bgeu	r3,r2,8110b68c <msgdma_descriptor_async_transfer+0x80>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
8110b67c:	e0bffd17 	ldw	r2,-12(fp)
8110b680:	10800917 	ldw	r2,36(r2)
8110b684:	e0fff317 	ldw	r3,-52(fp)
8110b688:	18800236 	bltu	r3,r2,8110b694 <msgdma_descriptor_async_transfer+0x88>
		/*at least one write or read FIFO descriptor buffer is full,
		 returning so that this function is non-blocking*/
		return -ENOSPC;
8110b68c:	00bff904 	movi	r2,-28
8110b690:	00009f06 	br	8110b910 <msgdma_descriptor_async_transfer+0x304>

	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND(dev->regs_lock, 0);
8110b694:	e0bffd17 	ldw	r2,-12(fp)
8110b698:	10801817 	ldw	r2,96(r2)
8110b69c:	e0bff615 	stw	r2,-40(fp)
8110b6a0:	e03ffc0d 	sth	zero,-16(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
8110b6a4:	e0bffc0b 	ldhu	r2,-16(fp)
8110b6a8:	e0fffc84 	addi	r3,fp,-14
8110b6ac:	180d883a 	mov	r6,r3
8110b6b0:	100b883a 	mov	r5,r2
8110b6b4:	e13ff617 	ldw	r4,-40(fp)
8110b6b8:	113e4c00 	call	8113e4c0 <OSSemPend>

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8110b6bc:	00800804 	movi	r2,32
8110b6c0:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110b6c4:	0005303a 	rdctl	r2,status
8110b6c8:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110b6cc:	e0fff717 	ldw	r3,-36(fp)
8110b6d0:	00bfff84 	movi	r2,-2
8110b6d4:	1884703a 	and	r2,r3,r2
8110b6d8:	1001703a 	wrctl	status,r2
  
  return context;
8110b6dc:	e0bff717 	ldw	r2,-36(fp)
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110b6e0:	e0bff215 	stw	r2,-56(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110b6e4:	e0bffd17 	ldw	r2,-12(fp)
8110b6e8:	10800317 	ldw	r2,12(r2)
8110b6ec:	10800104 	addi	r2,r2,4
8110b6f0:	e0fff117 	ldw	r3,-60(fp)
8110b6f4:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110b6f8:	e0bffd17 	ldw	r2,-12(fp)
8110b6fc:	10800317 	ldw	r2,12(r2)
8110b700:	e0fffd17 	ldw	r3,-12(fp)
8110b704:	18c00317 	ldw	r3,12(r3)
8110b708:	18c00037 	ldwio	r3,0(r3)
8110b70c:	10c00035 	stwio	r3,0(r2)
8110b710:	e0bff217 	ldw	r2,-56(fp)
8110b714:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110b718:	e0bffb17 	ldw	r2,-20(fp)
8110b71c:	1001703a 	wrctl	status,r2
			IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

	if (NULL != standard_desc && NULL == extended_desc) {
8110b720:	e0bffe17 	ldw	r2,-8(fp)
8110b724:	10001026 	beq	r2,zero,8110b768 <msgdma_descriptor_async_transfer+0x15c>
8110b728:	e0bfff17 	ldw	r2,-4(fp)
8110b72c:	10000e1e 	bne	r2,zero,8110b768 <msgdma_descriptor_async_transfer+0x15c>
		counter = 0; /* reset counter */
8110b730:	e03ff00d 	sth	zero,-64(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
#ifdef DEBUG_ON
		debug(fp, "invalid dma descriptor option\n");
8110b734:	d0a06217 	ldw	r2,-32376(gp)
8110b738:	100f883a 	mov	r7,r2
8110b73c:	01800784 	movi	r6,30
8110b740:	01400044 	movi	r5,1
8110b744:	01204574 	movhi	r4,33045
8110b748:	212f8604 	addi	r4,r4,-16872
8110b74c:	11216400 	call	81121640 <fwrite>
		/*
		 * Now that access to the registers is complete, release the
		 * registers semaphore so that other threads can access the
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110b750:	e0bffd17 	ldw	r2,-12(fp)
8110b754:	10801817 	ldw	r2,96(r2)
8110b758:	1009883a 	mov	r4,r2
8110b75c:	113e8480 	call	8113e848 <OSSemPost>

		return -ETIME;
8110b760:	00bff084 	movi	r2,-62
8110b764:	00006a06 	br	8110b910 <msgdma_descriptor_async_transfer+0x304>
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110b768:	e0bffe17 	ldw	r2,-8(fp)
8110b76c:	1000231e 	bne	r2,zero,8110b7fc <msgdma_descriptor_async_transfer+0x1f0>
8110b770:	e0bfff17 	ldw	r2,-4(fp)
8110b774:	10002126 	beq	r2,zero,8110b7fc <msgdma_descriptor_async_transfer+0x1f0>
		counter = 0; /* reset counter */
8110b778:	e03ff00d 	sth	zero,-64(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110b77c:	00001506 	br	8110b7d4 <msgdma_descriptor_async_transfer+0x1c8>
				!= msgdma_write_extended_descriptor(dev->csr_base,
						dev->descriptor_base, extended_desc)) {
			alt_busy_sleep(1); /* delay 1us */
8110b780:	01000044 	movi	r4,1
8110b784:	1135c480 	call	81135c48 <alt_busy_sleep>
			if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110b788:	e0bff00b 	ldhu	r2,-64(fp)
8110b78c:	1084e230 	cmpltui	r2,r2,5000
8110b790:	10000d1e 	bne	r2,zero,8110b7c8 <msgdma_descriptor_async_transfer+0x1bc>
			{
#ifdef DEBUG_ON
				debug(fp,
8110b794:	d0a06217 	ldw	r2,-32376(gp)
8110b798:	100f883a 	mov	r7,r2
8110b79c:	01801544 	movi	r6,85
8110b7a0:	01400044 	movi	r5,1
8110b7a4:	01204574 	movhi	r4,33045
8110b7a8:	212f8e04 	addi	r4,r4,-16840
8110b7ac:	11216400 	call	81121640 <fwrite>
				/*
				 * Now that access to the registers is complete, release the
				 * registers semaphore so that other threads can access the
				 * registers.
				 */
				ALT_SEM_POST(dev->regs_lock);
8110b7b0:	e0bffd17 	ldw	r2,-12(fp)
8110b7b4:	10801817 	ldw	r2,96(r2)
8110b7b8:	1009883a 	mov	r4,r2
8110b7bc:	113e8480 	call	8113e848 <OSSemPost>

				return -ETIME;
8110b7c0:	00bff084 	movi	r2,-62
8110b7c4:	00005206 	br	8110b910 <msgdma_descriptor_async_transfer+0x304>
			}
			counter++;
8110b7c8:	e0bff00b 	ldhu	r2,-64(fp)
8110b7cc:	10800044 	addi	r2,r2,1
8110b7d0:	e0bff00d 	sth	r2,-64(fp)
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
				!= msgdma_write_extended_descriptor(dev->csr_base,
8110b7d4:	e0bffd17 	ldw	r2,-12(fp)
8110b7d8:	10c00317 	ldw	r3,12(r2)
8110b7dc:	e0bffd17 	ldw	r2,-12(fp)
8110b7e0:	10800417 	ldw	r2,16(r2)
8110b7e4:	e1bfff17 	ldw	r6,-4(fp)
8110b7e8:	100b883a 	mov	r5,r2
8110b7ec:	1809883a 	mov	r4,r3
8110b7f0:	110b36c0 	call	8110b36c <msgdma_write_extended_descriptor>
		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110b7f4:	103fe21e 	bne	r2,zero,8110b780 <__reset+0xfb0eb780>
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110b7f8:	00000606 	br	8110b814 <msgdma_descriptor_async_transfer+0x208>
	} else {
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110b7fc:	e0bffd17 	ldw	r2,-12(fp)
8110b800:	10801817 	ldw	r2,96(r2)
8110b804:	1009883a 	mov	r4,r2
8110b808:	113e8480 	call	8113e848 <OSSemPost>

		/* operation not permitted due to descriptor type conflict */
		return -EPERM;
8110b80c:	00bfffc4 	movi	r2,-1
8110b810:	00003f06 	br	8110b910 <msgdma_descriptor_async_transfer+0x304>
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up controller to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if (dev->callback) {
8110b814:	e0bffd17 	ldw	r2,-12(fp)
8110b818:	10800b17 	ldw	r2,44(r2)
8110b81c:	10001c26 	beq	r2,zero,8110b890 <msgdma_descriptor_async_transfer+0x284>

		control |= (dev->control |
8110b820:	e0bffd17 	ldw	r2,-12(fp)
8110b824:	10c00d17 	ldw	r3,52(r2)
8110b828:	e0bff117 	ldw	r2,-60(fp)
8110b82c:	1884b03a 	or	r2,r3,r2
8110b830:	10800514 	ori	r2,r2,20
8110b834:	e0bff115 	stw	r2,-60(fp)
		ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
		ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
8110b838:	e0fff117 	ldw	r3,-60(fp)
8110b83c:	00bff7c4 	movi	r2,-33
8110b840:	1884703a 	and	r2,r3,r2
8110b844:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110b848:	0005303a 	rdctl	r2,status
8110b84c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110b850:	e0fff917 	ldw	r3,-28(fp)
8110b854:	00bfff84 	movi	r2,-2
8110b858:	1884703a 	and	r2,r3,r2
8110b85c:	1001703a 	wrctl	status,r2
  
  return context;
8110b860:	e0bff917 	ldw	r2,-28(fp)
		/* making sure the read-modify-write below can't be pre-empted */
		context = alt_irq_disable_all();
8110b864:	e0bff215 	stw	r2,-56(fp)
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110b868:	e0bffd17 	ldw	r2,-12(fp)
8110b86c:	10800317 	ldw	r2,12(r2)
8110b870:	10800104 	addi	r2,r2,4
8110b874:	e0fff117 	ldw	r3,-60(fp)
8110b878:	10c00035 	stwio	r3,0(r2)
8110b87c:	e0bff217 	ldw	r2,-56(fp)
8110b880:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110b884:	e0bff517 	ldw	r2,-44(fp)
8110b888:	1001703a 	wrctl	status,r2
8110b88c:	00001b06 	br	8110b8fc <msgdma_descriptor_async_transfer+0x2f0>
	 *   - Run
	 *   - Stop on an error with any particular descriptor
	 *   - Disable interrupt generation
	 */
	else {
		control |= (dev->control |
8110b890:	e0bffd17 	ldw	r2,-12(fp)
8110b894:	10c00d17 	ldw	r3,52(r2)
8110b898:	e0bff117 	ldw	r2,-60(fp)
8110b89c:	1884b03a 	or	r2,r3,r2
8110b8a0:	10800114 	ori	r2,r2,4
8110b8a4:	e0bff115 	stw	r2,-60(fp)
		ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
		control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK)
8110b8a8:	e0fff117 	ldw	r3,-60(fp)
8110b8ac:	00bff3c4 	movi	r2,-49
8110b8b0:	1884703a 	and	r2,r3,r2
8110b8b4:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110b8b8:	0005303a 	rdctl	r2,status
8110b8bc:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110b8c0:	e0fffa17 	ldw	r3,-24(fp)
8110b8c4:	00bfff84 	movi	r2,-2
8110b8c8:	1884703a 	and	r2,r3,r2
8110b8cc:	1001703a 	wrctl	status,r2
  
  return context;
8110b8d0:	e0bffa17 	ldw	r2,-24(fp)
				& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		/* making sure the read-modify-write below can't be pre-empted */
		context = alt_irq_disable_all();
8110b8d4:	e0bff215 	stw	r2,-56(fp)
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110b8d8:	e0bffd17 	ldw	r2,-12(fp)
8110b8dc:	10800317 	ldw	r2,12(r2)
8110b8e0:	10800104 	addi	r2,r2,4
8110b8e4:	e0fff117 	ldw	r3,-60(fp)
8110b8e8:	10c00035 	stwio	r3,0(r2)
8110b8ec:	e0bff217 	ldw	r2,-56(fp)
8110b8f0:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110b8f4:	e0bff817 	ldw	r2,-32(fp)
8110b8f8:	1001703a 	wrctl	status,r2

	/*
	 * Now that access to the registers is complete, release the registers
	 * semaphore so that other threads can access the registers.
	 */
	ALT_SEM_POST(dev->regs_lock);
8110b8fc:	e0bffd17 	ldw	r2,-12(fp)
8110b900:	10801817 	ldw	r2,96(r2)
8110b904:	1009883a 	mov	r4,r2
8110b908:	113e8480 	call	8113e848 <OSSemPost>

	return 0;
8110b90c:	0005883a 	mov	r2,zero
}
8110b910:	e037883a 	mov	sp,fp
8110b914:	dfc00117 	ldw	ra,4(sp)
8110b918:	df000017 	ldw	fp,0(sp)
8110b91c:	dec00204 	addi	sp,sp,8
8110b920:	f800283a 	ret

8110b924 <msgdma_descriptor_sync_transfer>:
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
static int msgdma_descriptor_sync_transfer(alt_msgdma_dev *dev,
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
8110b924:	deffee04 	addi	sp,sp,-72
8110b928:	de00012e 	bgeu	sp,et,8110b930 <msgdma_descriptor_sync_transfer+0xc>
8110b92c:	003b68fa 	trap	3
8110b930:	dfc01115 	stw	ra,68(sp)
8110b934:	df001015 	stw	fp,64(sp)
8110b938:	df001004 	addi	fp,sp,64
8110b93c:	e13ffd15 	stw	r4,-12(fp)
8110b940:	e17ffe15 	stw	r5,-8(fp)
8110b944:	e1bfff15 	stw	r6,-4(fp)
	alt_u32 control = 0;
8110b948:	e03ff415 	stw	zero,-48(fp)
	alt_irq_context context = 0;
8110b94c:	e03ff515 	stw	zero,-44(fp)
	alt_u32 csr_status = 0;
8110b950:	e03ff015 	stw	zero,-64(fp)
	alt_u16 counter = 0;
8110b954:	e03ff10d 	sth	zero,-60(fp)
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110b958:	e0bffd17 	ldw	r2,-12(fp)
8110b95c:	10800317 	ldw	r2,12(r2)
8110b960:	10800204 	addi	r2,r2,8
8110b964:	10800037 	ldwio	r2,0(r2)
		alt_msgdma_extended_descriptor *extended_desc) {
	alt_u32 control = 0;
	alt_irq_context context = 0;
	alt_u32 csr_status = 0;
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
8110b968:	10bfffcc 	andi	r2,r2,65535
8110b96c:	e0bff215 	stw	r2,-56(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110b970:	e0bffd17 	ldw	r2,-12(fp)
8110b974:	10800317 	ldw	r2,12(r2)
8110b978:	10800204 	addi	r2,r2,8
8110b97c:	10800037 	ldwio	r2,0(r2)
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
8110b980:	1004d43a 	srli	r2,r2,16
8110b984:	e0bff315 	stw	r2,-52(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;
	alt_u32 error = ALTERA_MSGDMA_CSR_STOPPED_ON_ERROR_MASK |
8110b988:	00807804 	movi	r2,480
8110b98c:	e0bff615 	stw	r2,-40(fp)
	ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
	ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
	ALTERA_MSGDMA_CSR_RESET_STATE_MASK;

	/* Wait for available FIFO buffer to store new descriptor*/
	while ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110b990:	00002406 	br	8110ba24 <msgdma_descriptor_sync_transfer+0x100>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
		alt_busy_sleep(1); /* delay 1us */
8110b994:	01000044 	movi	r4,1
8110b998:	1135c480 	call	81135c48 <alt_busy_sleep>
#ifdef DEBUG_ON
	fprintf(fp,"\n-- DMA can't write in the descriptor \n ");
8110b99c:	d0a06217 	ldw	r2,-32376(gp)
8110b9a0:	100f883a 	mov	r7,r2
8110b9a4:	01800a04 	movi	r6,40
8110b9a8:	01400044 	movi	r5,1
8110b9ac:	01204574 	movhi	r4,33045
8110b9b0:	212fa404 	addi	r4,r4,-16752
8110b9b4:	11216400 	call	81121640 <fwrite>
#endif
		if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110b9b8:	e0bff10b 	ldhu	r2,-60(fp)
8110b9bc:	1084e230 	cmpltui	r2,r2,5000
8110b9c0:	1000091e 	bne	r2,zero,8110b9e8 <msgdma_descriptor_sync_transfer+0xc4>
		{
#ifdef DEBUG_ON
			debug(fp,
8110b9c4:	d0a06217 	ldw	r2,-32376(gp)
8110b9c8:	100f883a 	mov	r7,r2
8110b9cc:	01801304 	movi	r6,76
8110b9d0:	01400044 	movi	r5,1
8110b9d4:	01204574 	movhi	r4,33045
8110b9d8:	212faf04 	addi	r4,r4,-16708
8110b9dc:	11216400 	call	81121640 <fwrite>
					"time out after 5 msec while waiting free FIFO buffer for storing descriptor\n");
#endif
			return -ETIME;
8110b9e0:	00bff084 	movi	r2,-62
8110b9e4:	0000d006 	br	8110bd28 <msgdma_descriptor_sync_transfer+0x404>
		}
		counter++;
8110b9e8:	e0bff10b 	ldhu	r2,-60(fp)
8110b9ec:	10800044 	addi	r2,r2,1
8110b9f0:	e0bff10d 	sth	r2,-60(fp)
		fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110b9f4:	e0bffd17 	ldw	r2,-12(fp)
8110b9f8:	10800317 	ldw	r2,12(r2)
8110b9fc:	10800204 	addi	r2,r2,8
8110ba00:	10800037 	ldwio	r2,0(r2)
					"time out after 5 msec while waiting free FIFO buffer for storing descriptor\n");
#endif
			return -ETIME;
		}
		counter++;
		fifo_read_fill_level = (
8110ba04:	10bfffcc 	andi	r2,r2,65535
8110ba08:	e0bff215 	stw	r2,-56(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110ba0c:	e0bffd17 	ldw	r2,-12(fp)
8110ba10:	10800317 	ldw	r2,12(r2)
8110ba14:	10800204 	addi	r2,r2,8
8110ba18:	10800037 	ldwio	r2,0(r2)
		counter++;
		fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		fifo_write_fill_level = (
8110ba1c:	1004d43a 	srli	r2,r2,16
8110ba20:	e0bff315 	stw	r2,-52(fp)
	ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
	ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
	ALTERA_MSGDMA_CSR_RESET_STATE_MASK;

	/* Wait for available FIFO buffer to store new descriptor*/
	while ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110ba24:	e0bffd17 	ldw	r2,-12(fp)
8110ba28:	10800917 	ldw	r2,36(r2)
8110ba2c:	e0fff317 	ldw	r3,-52(fp)
8110ba30:	18bfd82e 	bgeu	r3,r2,8110b994 <__reset+0xfb0eb994>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
8110ba34:	e0bffd17 	ldw	r2,-12(fp)
8110ba38:	10800917 	ldw	r2,36(r2)
8110ba3c:	e0fff217 	ldw	r3,-56(fp)
8110ba40:	18bfd42e 	bgeu	r3,r2,8110b994 <__reset+0xfb0eb994>

	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND(dev->regs_lock, 0);
8110ba44:	e0bffd17 	ldw	r2,-12(fp)
8110ba48:	10801817 	ldw	r2,96(r2)
8110ba4c:	e0bff815 	stw	r2,-32(fp)
8110ba50:	e03ffc0d 	sth	zero,-16(fp)
8110ba54:	e0bffc0b 	ldhu	r2,-16(fp)
8110ba58:	e0fffc84 	addi	r3,fp,-14
8110ba5c:	180d883a 	mov	r6,r3
8110ba60:	100b883a 	mov	r5,r2
8110ba64:	e13ff817 	ldw	r4,-32(fp)
8110ba68:	113e4c00 	call	8113e4c0 <OSSemPend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110ba6c:	0005303a 	rdctl	r2,status
8110ba70:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110ba74:	e0fffb17 	ldw	r3,-20(fp)
8110ba78:	00bfff84 	movi	r2,-2
8110ba7c:	1884703a 	and	r2,r3,r2
8110ba80:	1001703a 	wrctl	status,r2
  
  return context;
8110ba84:	e0bffb17 	ldw	r2,-20(fp)

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110ba88:	e0bff515 	stw	r2,-44(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8110ba8c:	e0bffd17 	ldw	r2,-12(fp)
8110ba90:	10800317 	ldw	r2,12(r2)
8110ba94:	10800104 	addi	r2,r2,4
8110ba98:	00c00804 	movi	r3,32
8110ba9c:	10c00035 	stwio	r3,0(r2)
			ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110baa0:	e0bffd17 	ldw	r2,-12(fp)
8110baa4:	10800317 	ldw	r2,12(r2)
8110baa8:	e0fffd17 	ldw	r3,-12(fp)
8110baac:	18c00317 	ldw	r3,12(r3)
8110bab0:	18c00037 	ldwio	r3,0(r3)
8110bab4:	10c00035 	stwio	r3,0(r2)
			IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

	if (NULL != standard_desc && NULL == extended_desc) {
8110bab8:	e0bffe17 	ldw	r2,-8(fp)
8110babc:	10001026 	beq	r2,zero,8110bb00 <msgdma_descriptor_sync_transfer+0x1dc>
8110bac0:	e0bfff17 	ldw	r2,-4(fp)
8110bac4:	10000e1e 	bne	r2,zero,8110bb00 <msgdma_descriptor_sync_transfer+0x1dc>
		counter = 0; /* reset counter */
8110bac8:	e03ff10d 	sth	zero,-60(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
#ifdef DEBUG_ON
		debug(fp, "invalid dma descriptor option\n");
8110bacc:	d0a06217 	ldw	r2,-32376(gp)
8110bad0:	100f883a 	mov	r7,r2
8110bad4:	01800784 	movi	r6,30
8110bad8:	01400044 	movi	r5,1
8110badc:	01204574 	movhi	r4,33045
8110bae0:	212f8604 	addi	r4,r4,-16872
8110bae4:	11216400 	call	81121640 <fwrite>
		/*
		 * Now that access to the registers is complete, release the
		 * registers semaphore so that other threads can access the
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110bae8:	e0bffd17 	ldw	r2,-12(fp)
8110baec:	10801817 	ldw	r2,96(r2)
8110baf0:	1009883a 	mov	r4,r2
8110baf4:	113e8480 	call	8113e848 <OSSemPost>

		return -ETIME;
8110baf8:	00bff084 	movi	r2,-62
8110bafc:	00008a06 	br	8110bd28 <msgdma_descriptor_sync_transfer+0x404>
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110bb00:	e0bffe17 	ldw	r2,-8(fp)
8110bb04:	1000231e 	bne	r2,zero,8110bb94 <msgdma_descriptor_sync_transfer+0x270>
8110bb08:	e0bfff17 	ldw	r2,-4(fp)
8110bb0c:	10002126 	beq	r2,zero,8110bb94 <msgdma_descriptor_sync_transfer+0x270>
		counter = 0; /* reset counter */
8110bb10:	e03ff10d 	sth	zero,-60(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110bb14:	00001506 	br	8110bb6c <msgdma_descriptor_sync_transfer+0x248>
				!= msgdma_write_extended_descriptor(dev->csr_base,
						dev->descriptor_base, extended_desc)) {
			alt_busy_sleep(1); /* delay 1us */
8110bb18:	01000044 	movi	r4,1
8110bb1c:	1135c480 	call	81135c48 <alt_busy_sleep>
			if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110bb20:	e0bff10b 	ldhu	r2,-60(fp)
8110bb24:	1084e230 	cmpltui	r2,r2,5000
8110bb28:	10000d1e 	bne	r2,zero,8110bb60 <msgdma_descriptor_sync_transfer+0x23c>
			{
#ifdef DEBUG_ON
				debug(fp,
8110bb2c:	d0a06217 	ldw	r2,-32376(gp)
8110bb30:	100f883a 	mov	r7,r2
8110bb34:	01801004 	movi	r6,64
8110bb38:	01400044 	movi	r5,1
8110bb3c:	01204574 	movhi	r4,33045
8110bb40:	212fc304 	addi	r4,r4,-16628
8110bb44:	11216400 	call	81121640 <fwrite>
				/*
				 * Now that access to the registers is complete, release the
				 * registers semaphore so that other threads can access the
				 * registers.
				 */
				ALT_SEM_POST(dev->regs_lock);
8110bb48:	e0bffd17 	ldw	r2,-12(fp)
8110bb4c:	10801817 	ldw	r2,96(r2)
8110bb50:	1009883a 	mov	r4,r2
8110bb54:	113e8480 	call	8113e848 <OSSemPost>

				return -ETIME;
8110bb58:	00bff084 	movi	r2,-62
8110bb5c:	00007206 	br	8110bd28 <msgdma_descriptor_sync_transfer+0x404>
			}
			counter++;
8110bb60:	e0bff10b 	ldhu	r2,-60(fp)
8110bb64:	10800044 	addi	r2,r2,1
8110bb68:	e0bff10d 	sth	r2,-60(fp)
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
				!= msgdma_write_extended_descriptor(dev->csr_base,
8110bb6c:	e0bffd17 	ldw	r2,-12(fp)
8110bb70:	10c00317 	ldw	r3,12(r2)
8110bb74:	e0bffd17 	ldw	r2,-12(fp)
8110bb78:	10800417 	ldw	r2,16(r2)
8110bb7c:	e1bfff17 	ldw	r6,-4(fp)
8110bb80:	100b883a 	mov	r5,r2
8110bb84:	1809883a 	mov	r4,r3
8110bb88:	110b36c0 	call	8110b36c <msgdma_write_extended_descriptor>
		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110bb8c:	103fe21e 	bne	r2,zero,8110bb18 <__reset+0xfb0ebb18>
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110bb90:	00000606 	br	8110bbac <msgdma_descriptor_sync_transfer+0x288>
	} else {
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110bb94:	e0bffd17 	ldw	r2,-12(fp)
8110bb98:	10801817 	ldw	r2,96(r2)
8110bb9c:	1009883a 	mov	r4,r2
8110bba0:	113e8480 	call	8113e848 <OSSemPost>

		/* operation not permitted due to descriptor type conflict */
		return -EPERM;
8110bba4:	00bfffc4 	movi	r2,-1
8110bba8:	00005f06 	br	8110bd28 <msgdma_descriptor_sync_transfer+0x404>
	 * Set up msgdma controller to:
	 * - Disable interrupt generation
	 * - Run once a valid descriptor is written to controller
	 * - Stop on an error with any particular descriptor
	 */
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8110bbac:	e0bffd17 	ldw	r2,-12(fp)
8110bbb0:	10800317 	ldw	r2,12(r2)
8110bbb4:	10800104 	addi	r2,r2,4
8110bbb8:	e0fffd17 	ldw	r3,-12(fp)
8110bbbc:	19000d17 	ldw	r4,52(r3)
8110bbc0:	00fff2c4 	movi	r3,-53
8110bbc4:	20c6703a 	and	r3,r4,r3
8110bbc8:	18c00114 	ori	r3,r3,4
8110bbcc:	10c00035 	stwio	r3,0(r2)
8110bbd0:	e0bff517 	ldw	r2,-44(fp)
8110bbd4:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110bbd8:	e0bff717 	ldw	r2,-36(fp)
8110bbdc:	1001703a 	wrctl	status,r2
			(dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK ) & (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK));

	alt_irq_enable_all(context);

	counter = 0; /* reset counter */
8110bbe0:	e03ff10d 	sth	zero,-60(fp)

	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
8110bbe4:	e0bffd17 	ldw	r2,-12(fp)
8110bbe8:	10800317 	ldw	r2,12(r2)
8110bbec:	10800037 	ldwio	r2,0(r2)
8110bbf0:	e0bff015 	stw	r2,-64(fp)

	/* Wait for any pending transfers to complete or checking any errors or
	 conditions causing descriptor to stop dispatching */
	while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK)) {
8110bbf4:	00001906 	br	8110bc5c <msgdma_descriptor_sync_transfer+0x338>
		alt_busy_sleep(1); /* delay 1us */
8110bbf8:	01000044 	movi	r4,1
8110bbfc:	1135c480 	call	81135c48 <alt_busy_sleep>
		if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110bc00:	e0bff10b 	ldhu	r2,-60(fp)
8110bc04:	1084e230 	cmpltui	r2,r2,5000
8110bc08:	10000d1e 	bne	r2,zero,8110bc40 <msgdma_descriptor_sync_transfer+0x31c>
		{
#ifdef DEBUG_ON
			debug(fp,
8110bc0c:	d0a06217 	ldw	r2,-32376(gp)
8110bc10:	100f883a 	mov	r7,r2
8110bc14:	01801184 	movi	r6,70
8110bc18:	01400044 	movi	r5,1
8110bc1c:	01204574 	movhi	r4,33045
8110bc20:	212fd404 	addi	r4,r4,-16560
8110bc24:	11216400 	call	81121640 <fwrite>

			/*
			 * Now that access to the registers is complete, release the registers
			 * semaphore so that other threads can access the registers.
			 */
			ALT_SEM_POST(dev->regs_lock);
8110bc28:	e0bffd17 	ldw	r2,-12(fp)
8110bc2c:	10801817 	ldw	r2,96(r2)
8110bc30:	1009883a 	mov	r4,r2
8110bc34:	113e8480 	call	8113e848 <OSSemPost>

			return -ETIME;
8110bc38:	00bff084 	movi	r2,-62
8110bc3c:	00003a06 	br	8110bd28 <msgdma_descriptor_sync_transfer+0x404>
		}
		counter++;
8110bc40:	e0bff10b 	ldhu	r2,-60(fp)
8110bc44:	10800044 	addi	r2,r2,1
8110bc48:	e0bff10d 	sth	r2,-60(fp)
		csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
8110bc4c:	e0bffd17 	ldw	r2,-12(fp)
8110bc50:	10800317 	ldw	r2,12(r2)
8110bc54:	10800037 	ldwio	r2,0(r2)
8110bc58:	e0bff015 	stw	r2,-64(fp)

	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);

	/* Wait for any pending transfers to complete or checking any errors or
	 conditions causing descriptor to stop dispatching */
	while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK)) {
8110bc5c:	e0fff017 	ldw	r3,-64(fp)
8110bc60:	e0bff617 	ldw	r2,-40(fp)
8110bc64:	1884703a 	and	r2,r3,r2
8110bc68:	1000031e 	bne	r2,zero,8110bc78 <msgdma_descriptor_sync_transfer+0x354>
8110bc6c:	e0bff017 	ldw	r2,-64(fp)
8110bc70:	1080004c 	andi	r2,r2,1
8110bc74:	103fe01e 	bne	r2,zero,8110bbf8 <__reset+0xfb0ebbf8>
		csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	}

	/*Errors or conditions causing the dispatcher stopping issuing read/write
	 commands to masters*/
	if (0 != (csr_status & error)) {
8110bc78:	e0fff017 	ldw	r3,-64(fp)
8110bc7c:	e0bff617 	ldw	r2,-40(fp)
8110bc80:	1884703a 	and	r2,r3,r2
8110bc84:	10000626 	beq	r2,zero,8110bca0 <msgdma_descriptor_sync_transfer+0x37c>
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110bc88:	e0bffd17 	ldw	r2,-12(fp)
8110bc8c:	10801817 	ldw	r2,96(r2)
8110bc90:	1009883a 	mov	r4,r2
8110bc94:	113e8480 	call	8113e848 <OSSemPost>

		return error;
8110bc98:	e0bff617 	ldw	r2,-40(fp)
8110bc9c:	00002206 	br	8110bd28 <msgdma_descriptor_sync_transfer+0x404>
	}

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* stop issuing more descriptors */
	control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) |
8110bca0:	e0bffd17 	ldw	r2,-12(fp)
8110bca4:	10800317 	ldw	r2,12(r2)
8110bca8:	10800104 	addi	r2,r2,4
8110bcac:	10800037 	ldwio	r2,0(r2)
8110bcb0:	10800814 	ori	r2,r2,32
8110bcb4:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110bcb8:	0005303a 	rdctl	r2,status
8110bcbc:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110bcc0:	e0fffa17 	ldw	r3,-24(fp)
8110bcc4:	00bfff84 	movi	r2,-2
8110bcc8:	1884703a 	and	r2,r3,r2
8110bccc:	1001703a 	wrctl	status,r2
  
  return context;
8110bcd0:	e0bffa17 	ldw	r2,-24(fp)
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110bcd4:	e0bff515 	stw	r2,-44(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110bcd8:	e0bffd17 	ldw	r2,-12(fp)
8110bcdc:	10800317 	ldw	r2,12(r2)
8110bce0:	10800104 	addi	r2,r2,4
8110bce4:	e0fff417 	ldw	r3,-48(fp)
8110bce8:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110bcec:	e0bffd17 	ldw	r2,-12(fp)
8110bcf0:	10800317 	ldw	r2,12(r2)
8110bcf4:	e0fffd17 	ldw	r3,-12(fp)
8110bcf8:	18c00317 	ldw	r3,12(r3)
8110bcfc:	18c00037 	ldwio	r3,0(r3)
8110bd00:	10c00035 	stwio	r3,0(r2)
8110bd04:	e0bff517 	ldw	r2,-44(fp)
8110bd08:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110bd0c:	e0bff917 	ldw	r2,-28(fp)
8110bd10:	1001703a 	wrctl	status,r2

	/*
	 * Now that access to the registers is complete, release the registers
	 * semaphore so that other threads can access the registers.
	 */
	ALT_SEM_POST(dev->regs_lock);
8110bd14:	e0bffd17 	ldw	r2,-12(fp)
8110bd18:	10801817 	ldw	r2,96(r2)
8110bd1c:	1009883a 	mov	r4,r2
8110bd20:	113e8480 	call	8113e848 <OSSemPost>

	return 0;
8110bd24:	0005883a 	mov	r2,zero

}
8110bd28:	e037883a 	mov	sp,fp
8110bd2c:	dfc00117 	ldw	ra,4(sp)
8110bd30:	df000017 	ldw	fp,0(sp)
8110bd34:	dec00204 	addi	sp,sp,8
8110bd38:	f800283a 	ret

8110bd3c <iMsgdmaConstructExtendedMmToMmDescriptor>:
int iMsgdmaConstructExtendedMmToMmDescriptor(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDescriptor, alt_u32 *puliReadAddress,
		alt_u32 *puliWriteAddress, alt_u32 uliLength, alt_u32 uliControl,
		alt_u32 *puliReadAddressHigh, alt_u32 *puliWriteAddressHigh,
		alt_u16 usiSequenceNumber, alt_u8 ucReadBurstCount,
		alt_u8 ucWriteBurstCount, alt_u16 usiReadStride, alt_u16 usiWriteStride) {
8110bd3c:	deffec04 	addi	sp,sp,-80
8110bd40:	de00012e 	bgeu	sp,et,8110bd48 <iMsgdmaConstructExtendedMmToMmDescriptor+0xc>
8110bd44:	003b68fa 	trap	3
8110bd48:	dfc01315 	stw	ra,76(sp)
8110bd4c:	df001215 	stw	fp,72(sp)
8110bd50:	df001204 	addi	fp,sp,72
8110bd54:	e13ff715 	stw	r4,-36(fp)
8110bd58:	e17ff815 	stw	r5,-32(fp)
8110bd5c:	e1bff915 	stw	r6,-28(fp)
8110bd60:	e1fffa15 	stw	r7,-24(fp)
8110bd64:	e1800617 	ldw	r6,24(fp)
8110bd68:	e1400717 	ldw	r5,28(fp)
8110bd6c:	e1000817 	ldw	r4,32(fp)
8110bd70:	e0c00917 	ldw	r3,36(fp)
8110bd74:	e0800a17 	ldw	r2,40(fp)
8110bd78:	e1bffb0d 	sth	r6,-20(fp)
8110bd7c:	e17ffc05 	stb	r5,-16(fp)
8110bd80:	e13ffd05 	stb	r4,-12(fp)
8110bd84:	e0fffe0d 	sth	r3,-8(fp)
8110bd88:	e0bfff0d 	sth	r2,-4(fp)
	return msgdma_construct_extended_descriptor(pxDev, pxDescriptor,
8110bd8c:	e0bffb0b 	ldhu	r2,-20(fp)
8110bd90:	e0fffc03 	ldbu	r3,-16(fp)
8110bd94:	e13ffd03 	ldbu	r4,-12(fp)
8110bd98:	e17ffe0b 	ldhu	r5,-8(fp)
8110bd9c:	e1bfff0b 	ldhu	r6,-4(fp)
8110bda0:	d9800815 	stw	r6,32(sp)
8110bda4:	d9400715 	stw	r5,28(sp)
8110bda8:	d9000615 	stw	r4,24(sp)
8110bdac:	d8c00515 	stw	r3,20(sp)
8110bdb0:	d8800415 	stw	r2,16(sp)
8110bdb4:	e0800517 	ldw	r2,20(fp)
8110bdb8:	d8800315 	stw	r2,12(sp)
8110bdbc:	e0800417 	ldw	r2,16(fp)
8110bdc0:	d8800215 	stw	r2,8(sp)
8110bdc4:	e0800317 	ldw	r2,12(fp)
8110bdc8:	d8800115 	stw	r2,4(sp)
8110bdcc:	e0800217 	ldw	r2,8(fp)
8110bdd0:	d8800015 	stw	r2,0(sp)
8110bdd4:	e1fffa17 	ldw	r7,-24(fp)
8110bdd8:	e1bff917 	ldw	r6,-28(fp)
8110bddc:	e17ff817 	ldw	r5,-32(fp)
8110bde0:	e13ff717 	ldw	r4,-36(fp)
8110bde4:	110b4a80 	call	8110b4a8 <msgdma_construct_extended_descriptor>
			puliReadAddress, puliWriteAddress, uliLength, uliControl,
			puliReadAddressHigh, puliWriteAddressHigh, usiSequenceNumber,
			ucReadBurstCount, ucWriteBurstCount, usiReadStride, usiWriteStride);

}
8110bde8:	e037883a 	mov	sp,fp
8110bdec:	dfc00117 	ldw	ra,4(sp)
8110bdf0:	df000017 	ldw	fp,0(sp)
8110bdf4:	dec00204 	addi	sp,sp,8
8110bdf8:	f800283a 	ret

8110bdfc <iMsgdmaExtendedDescriptorAsyncTransfer>:
 * -ENOSPC -> FIFO descriptor buffer is full
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int iMsgdmaExtendedDescriptorAsyncTransfer(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDesc) {
8110bdfc:	defffc04 	addi	sp,sp,-16
8110be00:	de00012e 	bgeu	sp,et,8110be08 <iMsgdmaExtendedDescriptorAsyncTransfer+0xc>
8110be04:	003b68fa 	trap	3
8110be08:	dfc00315 	stw	ra,12(sp)
8110be0c:	df000215 	stw	fp,8(sp)
8110be10:	df000204 	addi	fp,sp,8
8110be14:	e13ffe15 	stw	r4,-8(fp)
8110be18:	e17fff15 	stw	r5,-4(fp)
	/*
	 * Error detection/handling should be performed at the application
	 * or callback level as appropriate.
	 */
	return msgdma_descriptor_async_transfer(pxDev, NULL, pxDesc);
8110be1c:	e1bfff17 	ldw	r6,-4(fp)
8110be20:	000b883a 	mov	r5,zero
8110be24:	e13ffe17 	ldw	r4,-8(fp)
8110be28:	110b60c0 	call	8110b60c <msgdma_descriptor_async_transfer>
}
8110be2c:	e037883a 	mov	sp,fp
8110be30:	dfc00117 	ldw	ra,4(sp)
8110be34:	df000017 	ldw	fp,0(sp)
8110be38:	dec00204 	addi	sp,sp,8
8110be3c:	f800283a 	ret

8110be40 <iMsgdmaExtendedDescriptorSyncTransfer>:
 *           return -EPERM (operation not permitted due to descriptor type 
 *		conflict)
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int iMsgdmaExtendedDescriptorSyncTransfer(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDesc) {
8110be40:	defffc04 	addi	sp,sp,-16
8110be44:	de00012e 	bgeu	sp,et,8110be4c <iMsgdmaExtendedDescriptorSyncTransfer+0xc>
8110be48:	003b68fa 	trap	3
8110be4c:	dfc00315 	stw	ra,12(sp)
8110be50:	df000215 	stw	fp,8(sp)
8110be54:	df000204 	addi	fp,sp,8
8110be58:	e13ffe15 	stw	r4,-8(fp)
8110be5c:	e17fff15 	stw	r5,-4(fp)
	return msgdma_descriptor_sync_transfer(pxDev, NULL, pxDesc);
8110be60:	e1bfff17 	ldw	r6,-4(fp)
8110be64:	000b883a 	mov	r5,zero
8110be68:	e13ffe17 	ldw	r4,-8(fp)
8110be6c:	110b9240 	call	8110b924 <msgdma_descriptor_sync_transfer>
}
8110be70:	e037883a 	mov	sp,fp
8110be74:	dfc00117 	ldw	ra,4(sp)
8110be78:	df000017 	ldw	fp,0(sp)
8110be7c:	dec00204 	addi	sp,sp,8
8110be80:	f800283a 	ret

8110be84 <POWER_SPI_RW>:
#define SPI_SDI(x)    IOWR_ALTERA_AVALON_PIO_DATA(CSENSE_SDI_BASE,x)
#define SPI_SDO       (IORD_ALTERA_AVALON_PIO_DATA(CSENSE_SDO_BASE) & 0x01)
#define SPI_DELAY     usleep(15)  // based on 50MHZ of CPU clock
// Note. SCK: typical 19.2KHZ (53 ms)
bool POWER_SPI_RW(alt_u8 IcIndex, alt_u8 NextChannel, bool bEN, bool bSIGN,
		bool bSGL, alt_u32 *pValue) {
8110be84:	defff204 	addi	sp,sp,-56
8110be88:	de00012e 	bgeu	sp,et,8110be90 <POWER_SPI_RW+0xc>
8110be8c:	003b68fa 	trap	3
8110be90:	dfc00d15 	stw	ra,52(sp)
8110be94:	df000c15 	stw	fp,48(sp)
8110be98:	df000c04 	addi	fp,sp,48
8110be9c:	2007883a 	mov	r3,r4
8110bea0:	2805883a 	mov	r2,r5
8110bea4:	e1bffe15 	stw	r6,-8(fp)
8110bea8:	e1ffff15 	stw	r7,-4(fp)
8110beac:	e0fffc05 	stb	r3,-16(fp)
8110beb0:	e0bffd05 	stb	r2,-12(fp)
	bool bSuccess;
	alt_u8 Config8;
	alt_u32 Value32 = 0, Mask32;
8110beb4:	e03ff515 	stw	zero,-44(fp)
	int i, nWait = 0, nZeroCnt;
8110beb8:	e03ff815 	stw	zero,-32(fp)
	const int nMaxWait = 1000000;
8110bebc:	008003f4 	movhi	r2,15
8110bec0:	10909004 	addi	r2,r2,16960
8110bec4:	e0bffa15 	stw	r2,-24(fp)

	//
	Config8 = 0x80;
8110bec8:	00bfe004 	movi	r2,-128
8110becc:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bEN) ? 0x20 : 0x00;
8110bed0:	e0bffe17 	ldw	r2,-8(fp)
8110bed4:	10000226 	beq	r2,zero,8110bee0 <POWER_SPI_RW+0x5c>
8110bed8:	00800804 	movi	r2,32
8110bedc:	00000106 	br	8110bee4 <POWER_SPI_RW+0x60>
8110bee0:	0005883a 	mov	r2,zero
8110bee4:	e0fff403 	ldbu	r3,-48(fp)
8110bee8:	10c4b03a 	or	r2,r2,r3
8110beec:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bSGL) ? 0x10 : 0x00;
8110bef0:	e0800217 	ldw	r2,8(fp)
8110bef4:	10000226 	beq	r2,zero,8110bf00 <POWER_SPI_RW+0x7c>
8110bef8:	00800404 	movi	r2,16
8110befc:	00000106 	br	8110bf04 <POWER_SPI_RW+0x80>
8110bf00:	0005883a 	mov	r2,zero
8110bf04:	e0fff403 	ldbu	r3,-48(fp)
8110bf08:	10c4b03a 	or	r2,r2,r3
8110bf0c:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bSIGN) ? 0x08 : 0x00;
8110bf10:	e0bfff17 	ldw	r2,-4(fp)
8110bf14:	10000226 	beq	r2,zero,8110bf20 <POWER_SPI_RW+0x9c>
8110bf18:	00800204 	movi	r2,8
8110bf1c:	00000106 	br	8110bf24 <POWER_SPI_RW+0xa0>
8110bf20:	0005883a 	mov	r2,zero
8110bf24:	e0fff403 	ldbu	r3,-48(fp)
8110bf28:	10c4b03a 	or	r2,r2,r3
8110bf2c:	e0bff405 	stb	r2,-48(fp)
	Config8 |= NextChannel & 0x07; // channel
8110bf30:	e0bffd03 	ldbu	r2,-12(fp)
8110bf34:	108001cc 	andi	r2,r2,7
8110bf38:	1007883a 	mov	r3,r2
8110bf3c:	e0bff403 	ldbu	r2,-48(fp)
8110bf40:	1884b03a 	or	r2,r3,r2
8110bf44:	e0bff405 	stb	r2,-48(fp)

	SPI_FO(0); // use internal conversion clock
8110bf48:	0007883a 	mov	r3,zero
8110bf4c:	00a00034 	movhi	r2,32768
8110bf50:	10824404 	addi	r2,r2,2320
8110bf54:	10c00035 	stwio	r3,0(r2)
	SPI_SCK(0);  // set low to active extenal serial clock mode.
8110bf58:	0007883a 	mov	r3,zero
8110bf5c:	00a00034 	movhi	r2,32768
8110bf60:	10824c04 	addi	r2,r2,2352
8110bf64:	10c00035 	stwio	r3,0(r2)
	SPI_CS_N(IcIndex, 0);  // chip select: active
8110bf68:	e0bffc03 	ldbu	r2,-16(fp)
8110bf6c:	1000021e 	bne	r2,zero,8110bf78 <POWER_SPI_RW+0xf4>
8110bf70:	00c00084 	movi	r3,2
8110bf74:	00000106 	br	8110bf7c <POWER_SPI_RW+0xf8>
8110bf78:	00c00044 	movi	r3,1
8110bf7c:	00a00034 	movhi	r2,32768
8110bf80:	10824804 	addi	r2,r2,2336
8110bf84:	10c00035 	stwio	r3,0(r2)
	SPI_DELAY;
8110bf88:	010003c4 	movi	r4,15
8110bf8c:	11376bc0 	call	811376bc <usleep>

	// wait for converion end (when conversion done, SPI_SDO is low)
	while (SPI_SDO && nWait < nMaxWait) {
8110bf90:	00000306 	br	8110bfa0 <POWER_SPI_RW+0x11c>
		nWait++;
8110bf94:	e0bff817 	ldw	r2,-32(fp)
8110bf98:	10800044 	addi	r2,r2,1
8110bf9c:	e0bff815 	stw	r2,-32(fp)
	SPI_SCK(0);  // set low to active extenal serial clock mode.
	SPI_CS_N(IcIndex, 0);  // chip select: active
	SPI_DELAY;

	// wait for converion end (when conversion done, SPI_SDO is low)
	while (SPI_SDO && nWait < nMaxWait) {
8110bfa0:	00a00034 	movhi	r2,32768
8110bfa4:	10825404 	addi	r2,r2,2384
8110bfa8:	10800037 	ldwio	r2,0(r2)
8110bfac:	1080004c 	andi	r2,r2,1
8110bfb0:	10000326 	beq	r2,zero,8110bfc0 <POWER_SPI_RW+0x13c>
8110bfb4:	e0fff817 	ldw	r3,-32(fp)
8110bfb8:	e0bffa17 	ldw	r2,-24(fp)
8110bfbc:	18bff516 	blt	r3,r2,8110bf94 <__reset+0xfb0ebf94>
		nWait++;
	}

	if (SPI_SDO) {
8110bfc0:	00a00034 	movhi	r2,32768
8110bfc4:	10825404 	addi	r2,r2,2384
8110bfc8:	10800037 	ldwio	r2,0(r2)
8110bfcc:	1080004c 	andi	r2,r2,1
8110bfd0:	10000626 	beq	r2,zero,8110bfec <POWER_SPI_RW+0x168>
		SPI_CS_N(IcIndex, 1);  // chip select: inactive
8110bfd4:	00c000c4 	movi	r3,3
8110bfd8:	00a00034 	movhi	r2,32768
8110bfdc:	10824804 	addi	r2,r2,2336
8110bfe0:	10c00035 	stwio	r3,0(r2)
#ifdef DEBUG_ON
//		debug(fp, "Timeout \r\n");
#endif
		return FALSE;
8110bfe4:	0005883a 	mov	r2,zero
8110bfe8:	0000db06 	br	8110c358 <POWER_SPI_RW+0x4d4>
	}

	for (i = 0; i < 2; i++) // send config bits 7:6,
8110bfec:	e03ff715 	stw	zero,-36(fp)
8110bff0:	00002406 	br	8110c084 <POWER_SPI_RW+0x200>
			// ignore EOC/ and DMY bits
			{
		SPI_SDI((Config8 & 0x80) ? 1 : 0);    //sdi=nextch.7; // put data on pin
8110bff4:	e0bff403 	ldbu	r2,-48(fp)
8110bff8:	10803fcc 	andi	r2,r2,255
8110bffc:	1004d1fa 	srli	r2,r2,7
8110c000:	10c03fcc 	andi	r3,r2,255
8110c004:	00a00034 	movhi	r2,32768
8110c008:	10825004 	addi	r2,r2,2368
8110c00c:	10c00035 	stwio	r3,0(r2)
		Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
8110c010:	e0bff403 	ldbu	r2,-48(fp)
8110c014:	1085883a 	add	r2,r2,r2
8110c018:	e0bff405 	stb	r2,-48(fp)
		Value32 <<= 1; //result_0 = rl(result_0);// get ready to load lsb
8110c01c:	e0bff517 	ldw	r2,-44(fp)
8110c020:	1085883a 	add	r2,r2,r2
8110c024:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_0.0 = sdo; // load lsb
8110c028:	00a00034 	movhi	r2,32768
8110c02c:	10825404 	addi	r2,r2,2384
8110c030:	10800037 	ldwio	r2,0(r2)
8110c034:	1080004c 	andi	r2,r2,1
8110c038:	1007883a 	mov	r3,r2
8110c03c:	e0bff517 	ldw	r2,-44(fp)
8110c040:	10c4b03a 	or	r2,r2,r3
8110c044:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110c048:	00c00044 	movi	r3,1
8110c04c:	00a00034 	movhi	r2,32768
8110c050:	10824c04 	addi	r2,r2,2352
8110c054:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c058:	010003c4 	movi	r4,15
8110c05c:	11376bc0 	call	811376bc <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110c060:	0007883a 	mov	r3,zero
8110c064:	00a00034 	movhi	r2,32768
8110c068:	10824c04 	addi	r2,r2,2352
8110c06c:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c070:	010003c4 	movi	r4,15
8110c074:	11376bc0 	call	811376bc <usleep>
//		debug(fp, "Timeout \r\n");
#endif
		return FALSE;
	}

	for (i = 0; i < 2; i++) // send config bits 7:6,
8110c078:	e0bff717 	ldw	r2,-36(fp)
8110c07c:	10800044 	addi	r2,r2,1
8110c080:	e0bff715 	stw	r2,-36(fp)
8110c084:	e0bff717 	ldw	r2,-36(fp)
8110c088:	10800090 	cmplti	r2,r2,2
8110c08c:	103fd91e 	bne	r2,zero,8110bff4 <__reset+0xfb0ebff4>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // send config, read byte 3
8110c090:	e03ff715 	stw	zero,-36(fp)
8110c094:	00002406 	br	8110c128 <POWER_SPI_RW+0x2a4>
			{
		SPI_SDI((Config8 & 0x80) ? 1 : 0); //sdi=nextch.7; // put data on pin
8110c098:	e0bff403 	ldbu	r2,-48(fp)
8110c09c:	10803fcc 	andi	r2,r2,255
8110c0a0:	1004d1fa 	srli	r2,r2,7
8110c0a4:	10c03fcc 	andi	r3,r2,255
8110c0a8:	00a00034 	movhi	r2,32768
8110c0ac:	10825004 	addi	r2,r2,2368
8110c0b0:	10c00035 	stwio	r3,0(r2)
		Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
8110c0b4:	e0bff403 	ldbu	r2,-48(fp)
8110c0b8:	1085883a 	add	r2,r2,r2
8110c0bc:	e0bff405 	stb	r2,-48(fp)

		Value32 <<= 1; //result_3 = rl(result_3);// get ready to load lsb
8110c0c0:	e0bff517 	ldw	r2,-44(fp)
8110c0c4:	1085883a 	add	r2,r2,r2
8110c0c8:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_3.0 = sdo; // load lsb
8110c0cc:	00a00034 	movhi	r2,32768
8110c0d0:	10825404 	addi	r2,r2,2384
8110c0d4:	10800037 	ldwio	r2,0(r2)
8110c0d8:	1080004c 	andi	r2,r2,1
8110c0dc:	1007883a 	mov	r3,r2
8110c0e0:	e0bff517 	ldw	r2,-44(fp)
8110c0e4:	10c4b03a 	or	r2,r2,r3
8110c0e8:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110c0ec:	00c00044 	movi	r3,1
8110c0f0:	00a00034 	movhi	r2,32768
8110c0f4:	10824c04 	addi	r2,r2,2352
8110c0f8:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c0fc:	010003c4 	movi	r4,15
8110c100:	11376bc0 	call	811376bc <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110c104:	0007883a 	mov	r3,zero
8110c108:	00a00034 	movhi	r2,32768
8110c10c:	10824c04 	addi	r2,r2,2352
8110c110:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c114:	010003c4 	movi	r4,15
8110c118:	11376bc0 	call	811376bc <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // send config, read byte 3
8110c11c:	e0bff717 	ldw	r2,-36(fp)
8110c120:	10800044 	addi	r2,r2,1
8110c124:	e0bff715 	stw	r2,-36(fp)
8110c128:	e0bff717 	ldw	r2,-36(fp)
8110c12c:	10800210 	cmplti	r2,r2,8
8110c130:	103fd91e 	bne	r2,zero,8110c098 <__reset+0xfb0ec098>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 2
8110c134:	e03ff715 	stw	zero,-36(fp)
8110c138:	00001a06 	br	8110c1a4 <POWER_SPI_RW+0x320>
			{
		Value32 <<= 1; //result_2 = rl(result_2);// get ready to load lsb
8110c13c:	e0bff517 	ldw	r2,-44(fp)
8110c140:	1085883a 	add	r2,r2,r2
8110c144:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_2.0 = sdo; // load lsb
8110c148:	00a00034 	movhi	r2,32768
8110c14c:	10825404 	addi	r2,r2,2384
8110c150:	10800037 	ldwio	r2,0(r2)
8110c154:	1080004c 	andi	r2,r2,1
8110c158:	1007883a 	mov	r3,r2
8110c15c:	e0bff517 	ldw	r2,-44(fp)
8110c160:	10c4b03a 	or	r2,r2,r3
8110c164:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110c168:	00c00044 	movi	r3,1
8110c16c:	00a00034 	movhi	r2,32768
8110c170:	10824c04 	addi	r2,r2,2352
8110c174:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c178:	010003c4 	movi	r4,15
8110c17c:	11376bc0 	call	811376bc <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110c180:	0007883a 	mov	r3,zero
8110c184:	00a00034 	movhi	r2,32768
8110c188:	10824c04 	addi	r2,r2,2352
8110c18c:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c190:	010003c4 	movi	r4,15
8110c194:	11376bc0 	call	811376bc <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 2
8110c198:	e0bff717 	ldw	r2,-36(fp)
8110c19c:	10800044 	addi	r2,r2,1
8110c1a0:	e0bff715 	stw	r2,-36(fp)
8110c1a4:	e0bff717 	ldw	r2,-36(fp)
8110c1a8:	10800210 	cmplti	r2,r2,8
8110c1ac:	103fe31e 	bne	r2,zero,8110c13c <__reset+0xfb0ec13c>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 1
8110c1b0:	e03ff715 	stw	zero,-36(fp)
8110c1b4:	00001a06 	br	8110c220 <POWER_SPI_RW+0x39c>
			{
		Value32 <<= 1; //result_1 = rl(result_1);// get ready to load lsb
8110c1b8:	e0bff517 	ldw	r2,-44(fp)
8110c1bc:	1085883a 	add	r2,r2,r2
8110c1c0:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_1.0 = sdo; // load lsb
8110c1c4:	00a00034 	movhi	r2,32768
8110c1c8:	10825404 	addi	r2,r2,2384
8110c1cc:	10800037 	ldwio	r2,0(r2)
8110c1d0:	1080004c 	andi	r2,r2,1
8110c1d4:	1007883a 	mov	r3,r2
8110c1d8:	e0bff517 	ldw	r2,-44(fp)
8110c1dc:	10c4b03a 	or	r2,r2,r3
8110c1e0:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110c1e4:	00c00044 	movi	r3,1
8110c1e8:	00a00034 	movhi	r2,32768
8110c1ec:	10824c04 	addi	r2,r2,2352
8110c1f0:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c1f4:	010003c4 	movi	r4,15
8110c1f8:	11376bc0 	call	811376bc <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110c1fc:	0007883a 	mov	r3,zero
8110c200:	00a00034 	movhi	r2,32768
8110c204:	10824c04 	addi	r2,r2,2352
8110c208:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c20c:	010003c4 	movi	r4,15
8110c210:	11376bc0 	call	811376bc <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 1
8110c214:	e0bff717 	ldw	r2,-36(fp)
8110c218:	10800044 	addi	r2,r2,1
8110c21c:	e0bff715 	stw	r2,-36(fp)
8110c220:	e0bff717 	ldw	r2,-36(fp)
8110c224:	10800210 	cmplti	r2,r2,8
8110c228:	103fe31e 	bne	r2,zero,8110c1b8 <__reset+0xfb0ec1b8>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 6; i++) // read byte 0
8110c22c:	e03ff715 	stw	zero,-36(fp)
8110c230:	00001a06 	br	8110c29c <POWER_SPI_RW+0x418>
			{
		Value32 <<= 1; //result_0 = rl(result_0);// get ready to load lsb
8110c234:	e0bff517 	ldw	r2,-44(fp)
8110c238:	1085883a 	add	r2,r2,r2
8110c23c:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_0.0 = sdo; // load lsb
8110c240:	00a00034 	movhi	r2,32768
8110c244:	10825404 	addi	r2,r2,2384
8110c248:	10800037 	ldwio	r2,0(r2)
8110c24c:	1080004c 	andi	r2,r2,1
8110c250:	1007883a 	mov	r3,r2
8110c254:	e0bff517 	ldw	r2,-44(fp)
8110c258:	10c4b03a 	or	r2,r2,r3
8110c25c:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110c260:	00c00044 	movi	r3,1
8110c264:	00a00034 	movhi	r2,32768
8110c268:	10824c04 	addi	r2,r2,2352
8110c26c:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c270:	010003c4 	movi	r4,15
8110c274:	11376bc0 	call	811376bc <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110c278:	0007883a 	mov	r3,zero
8110c27c:	00a00034 	movhi	r2,32768
8110c280:	10824c04 	addi	r2,r2,2352
8110c284:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c288:	010003c4 	movi	r4,15
8110c28c:	11376bc0 	call	811376bc <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 6; i++) // read byte 0
8110c290:	e0bff717 	ldw	r2,-36(fp)
8110c294:	10800044 	addi	r2,r2,1
8110c298:	e0bff715 	stw	r2,-36(fp)
8110c29c:	e0bff717 	ldw	r2,-36(fp)
8110c2a0:	10800190 	cmplti	r2,r2,6
8110c2a4:	103fe31e 	bne	r2,zero,8110c234 <__reset+0xfb0ec234>
		SPI_SCK(1); //sck=1; // clock high
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}
	SPI_SCK(1);
8110c2a8:	00c00044 	movi	r3,1
8110c2ac:	00a00034 	movhi	r2,32768
8110c2b0:	10824c04 	addi	r2,r2,2352
8110c2b4:	10c00035 	stwio	r3,0(r2)
	SPI_DELAY;
8110c2b8:	010003c4 	movi	r4,15
8110c2bc:	11376bc0 	call	811376bc <usleep>
	SPI_CS_N(IcIndex, 1);  // chip select: inactive
8110c2c0:	00c000c4 	movi	r3,3
8110c2c4:	00a00034 	movhi	r2,32768
8110c2c8:	10824804 	addi	r2,r2,2336
8110c2cc:	10c00035 	stwio	r3,0(r2)

	// check parity
	nZeroCnt = 0;
8110c2d0:	e03ff915 	stw	zero,-28(fp)
	Mask32 = 0x01;
8110c2d4:	00800044 	movi	r2,1
8110c2d8:	e0bff615 	stw	r2,-40(fp)
	for (i = 0; i < 32; i++) {
8110c2dc:	e03ff715 	stw	zero,-36(fp)
8110c2e0:	00000d06 	br	8110c318 <POWER_SPI_RW+0x494>
		if ((Value32 & Mask32) == 0x00) {
8110c2e4:	e0fff517 	ldw	r3,-44(fp)
8110c2e8:	e0bff617 	ldw	r2,-40(fp)
8110c2ec:	1884703a 	and	r2,r3,r2
8110c2f0:	1000031e 	bne	r2,zero,8110c300 <POWER_SPI_RW+0x47c>
			nZeroCnt++;
8110c2f4:	e0bff917 	ldw	r2,-28(fp)
8110c2f8:	10800044 	addi	r2,r2,1
8110c2fc:	e0bff915 	stw	r2,-28(fp)
		}
		Mask32 <<= 1;
8110c300:	e0bff617 	ldw	r2,-40(fp)
8110c304:	1085883a 	add	r2,r2,r2
8110c308:	e0bff615 	stw	r2,-40(fp)
	SPI_CS_N(IcIndex, 1);  // chip select: inactive

	// check parity
	nZeroCnt = 0;
	Mask32 = 0x01;
	for (i = 0; i < 32; i++) {
8110c30c:	e0bff717 	ldw	r2,-36(fp)
8110c310:	10800044 	addi	r2,r2,1
8110c314:	e0bff715 	stw	r2,-36(fp)
8110c318:	e0bff717 	ldw	r2,-36(fp)
8110c31c:	10800810 	cmplti	r2,r2,32
8110c320:	103ff01e 	bne	r2,zero,8110c2e4 <__reset+0xfb0ec2e4>
		if ((Value32 & Mask32) == 0x00) {
			nZeroCnt++;
		}
		Mask32 <<= 1;
	}
	bSuccess = (nZeroCnt & 0x01) ? FALSE : TRUE;
8110c324:	e0bff917 	ldw	r2,-28(fp)
8110c328:	1080004c 	andi	r2,r2,1
8110c32c:	1005003a 	cmpeq	r2,r2,zero
8110c330:	10803fcc 	andi	r2,r2,255
8110c334:	e0bffb15 	stw	r2,-20(fp)
	if (!bSuccess) {
8110c338:	e0bffb17 	ldw	r2,-20(fp)
8110c33c:	1000021e 	bne	r2,zero,8110c348 <POWER_SPI_RW+0x4c4>
#ifdef DEBUG_ON
//		debug(fp, "Parity Check Error \r\n");
#endif
		return FALSE;
8110c340:	0005883a 	mov	r2,zero
8110c344:	00000406 	br	8110c358 <POWER_SPI_RW+0x4d4>
	}

	*pValue = Value32;
8110c348:	e0800317 	ldw	r2,12(fp)
8110c34c:	e0fff517 	ldw	r3,-44(fp)
8110c350:	10c00015 	stw	r3,0(r2)

	return bSuccess;
8110c354:	e0bffb17 	ldw	r2,-20(fp)
}
8110c358:	e037883a 	mov	sp,fp
8110c35c:	dfc00117 	ldw	ra,4(sp)
8110c360:	df000017 	ldw	fp,0(sp)
8110c364:	dec00204 	addi	sp,sp,8
8110c368:	f800283a 	ret

8110c36c <vRstcSimucamReset>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vRstcSimucamReset(alt_u16 usiRstCnt) {
8110c36c:	defffc04 	addi	sp,sp,-16
8110c370:	de00012e 	bgeu	sp,et,8110c378 <vRstcSimucamReset+0xc>
8110c374:	003b68fa 	trap	3
8110c378:	dfc00315 	stw	ra,12(sp)
8110c37c:	df000215 	stw	fp,8(sp)
8110c380:	df000204 	addi	fp,sp,8
8110c384:	2005883a 	mov	r2,r4
8110c388:	e0bfff0d 	sth	r2,-4(fp)
	alt_u32 uliReg = 0;
8110c38c:	e03ffe15 	stw	zero,-8(fp)

	uliReg |= (alt_u32) (usiRstCnt & RSTC_SIMUCAM_RST_TMR_MSK);
8110c390:	e0bfff0b 	ldhu	r2,-4(fp)
8110c394:	e0fffe17 	ldw	r3,-8(fp)
8110c398:	1884b03a 	or	r2,r3,r2
8110c39c:	e0bffe15 	stw	r2,-8(fp)
	uliReg |= (alt_u32) RSTC_SIMUCAM_RST_CTRL_MSK;
8110c3a0:	e0bffe17 	ldw	r2,-8(fp)
8110c3a4:	10800074 	orhi	r2,r2,1
8110c3a8:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110c3ac:	e1bffe17 	ldw	r6,-8(fp)
8110c3b0:	000b883a 	mov	r5,zero
8110c3b4:	01200034 	movhi	r4,32768
8110c3b8:	21020004 	addi	r4,r4,2048
8110c3bc:	110c4bc0 	call	8110c4bc <vRstcWriteReg>
	RSTC_SIMUCAM_RESET_REG_OFFSET, uliReg);
}
8110c3c0:	0001883a 	nop
8110c3c4:	e037883a 	mov	sp,fp
8110c3c8:	dfc00117 	ldw	ra,4(sp)
8110c3cc:	df000017 	ldw	fp,0(sp)
8110c3d0:	dec00204 	addi	sp,sp,8
8110c3d4:	f800283a 	ret

8110c3d8 <vRstcReleaseDeviceReset>:

void vRstcReleaseDeviceReset(alt_u32 usiRstMask) {
8110c3d8:	defffc04 	addi	sp,sp,-16
8110c3dc:	de00012e 	bgeu	sp,et,8110c3e4 <vRstcReleaseDeviceReset+0xc>
8110c3e0:	003b68fa 	trap	3
8110c3e4:	dfc00315 	stw	ra,12(sp)
8110c3e8:	df000215 	stw	fp,8(sp)
8110c3ec:	df000204 	addi	fp,sp,8
8110c3f0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliReg = 0;
8110c3f4:	e03ffe15 	stw	zero,-8(fp)

	uliReg = uliRstReadReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110c3f8:	01400044 	movi	r5,1
8110c3fc:	01200034 	movhi	r4,32768
8110c400:	21020004 	addi	r4,r4,2048
8110c404:	110c5100 	call	8110c510 <uliRstReadReg>
8110c408:	e0bffe15 	stw	r2,-8(fp)
	RSTC_DEVICE_RESET_REG_OFFSET);
	uliReg &= ~((alt_u32) usiRstMask);
8110c40c:	e0bfff17 	ldw	r2,-4(fp)
8110c410:	0084303a 	nor	r2,zero,r2
8110c414:	e0fffe17 	ldw	r3,-8(fp)
8110c418:	1884703a 	and	r2,r3,r2
8110c41c:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110c420:	e1bffe17 	ldw	r6,-8(fp)
8110c424:	01400044 	movi	r5,1
8110c428:	01200034 	movhi	r4,32768
8110c42c:	21020004 	addi	r4,r4,2048
8110c430:	110c4bc0 	call	8110c4bc <vRstcWriteReg>
	RSTC_DEVICE_RESET_REG_OFFSET, uliReg);
}
8110c434:	0001883a 	nop
8110c438:	e037883a 	mov	sp,fp
8110c43c:	dfc00117 	ldw	ra,4(sp)
8110c440:	df000017 	ldw	fp,0(sp)
8110c444:	dec00204 	addi	sp,sp,8
8110c448:	f800283a 	ret

8110c44c <vRstcHoldDeviceReset>:

void vRstcHoldDeviceReset(alt_u32 usiRstMask) {
8110c44c:	defffc04 	addi	sp,sp,-16
8110c450:	de00012e 	bgeu	sp,et,8110c458 <vRstcHoldDeviceReset+0xc>
8110c454:	003b68fa 	trap	3
8110c458:	dfc00315 	stw	ra,12(sp)
8110c45c:	df000215 	stw	fp,8(sp)
8110c460:	df000204 	addi	fp,sp,8
8110c464:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliReg = 0;
8110c468:	e03ffe15 	stw	zero,-8(fp)

	uliReg = uliRstReadReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110c46c:	01400044 	movi	r5,1
8110c470:	01200034 	movhi	r4,32768
8110c474:	21020004 	addi	r4,r4,2048
8110c478:	110c5100 	call	8110c510 <uliRstReadReg>
8110c47c:	e0bffe15 	stw	r2,-8(fp)
	RSTC_DEVICE_RESET_REG_OFFSET);
	uliReg |= (alt_u32) usiRstMask;
8110c480:	e0fffe17 	ldw	r3,-8(fp)
8110c484:	e0bfff17 	ldw	r2,-4(fp)
8110c488:	1884b03a 	or	r2,r3,r2
8110c48c:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110c490:	e1bffe17 	ldw	r6,-8(fp)
8110c494:	01400044 	movi	r5,1
8110c498:	01200034 	movhi	r4,32768
8110c49c:	21020004 	addi	r4,r4,2048
8110c4a0:	110c4bc0 	call	8110c4bc <vRstcWriteReg>
	RSTC_DEVICE_RESET_REG_OFFSET, uliReg);
}
8110c4a4:	0001883a 	nop
8110c4a8:	e037883a 	mov	sp,fp
8110c4ac:	dfc00117 	ldw	ra,4(sp)
8110c4b0:	df000017 	ldw	fp,0(sp)
8110c4b4:	dec00204 	addi	sp,sp,8
8110c4b8:	f800283a 	ret

8110c4bc <vRstcWriteReg>:
//! [public functions]

//! [private functions]
static void vRstcWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
8110c4bc:	defffc04 	addi	sp,sp,-16
8110c4c0:	de00012e 	bgeu	sp,et,8110c4c8 <vRstcWriteReg+0xc>
8110c4c4:	003b68fa 	trap	3
8110c4c8:	df000315 	stw	fp,12(sp)
8110c4cc:	df000304 	addi	fp,sp,12
8110c4d0:	e13ffd15 	stw	r4,-12(fp)
8110c4d4:	e17ffe15 	stw	r5,-8(fp)
8110c4d8:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
8110c4dc:	e0bffe17 	ldw	r2,-8(fp)
8110c4e0:	1085883a 	add	r2,r2,r2
8110c4e4:	1085883a 	add	r2,r2,r2
8110c4e8:	1007883a 	mov	r3,r2
8110c4ec:	e0bffd17 	ldw	r2,-12(fp)
8110c4f0:	10c5883a 	add	r2,r2,r3
8110c4f4:	e0ffff17 	ldw	r3,-4(fp)
8110c4f8:	10c00015 	stw	r3,0(r2)
}
8110c4fc:	0001883a 	nop
8110c500:	e037883a 	mov	sp,fp
8110c504:	df000017 	ldw	fp,0(sp)
8110c508:	dec00104 	addi	sp,sp,4
8110c50c:	f800283a 	ret

8110c510 <uliRstReadReg>:

static alt_u32 uliRstReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8110c510:	defffc04 	addi	sp,sp,-16
8110c514:	de00012e 	bgeu	sp,et,8110c51c <uliRstReadReg+0xc>
8110c518:	003b68fa 	trap	3
8110c51c:	df000315 	stw	fp,12(sp)
8110c520:	df000304 	addi	fp,sp,12
8110c524:	e13ffe15 	stw	r4,-8(fp)
8110c528:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
8110c52c:	e0bfff17 	ldw	r2,-4(fp)
8110c530:	1085883a 	add	r2,r2,r2
8110c534:	1085883a 	add	r2,r2,r2
8110c538:	1007883a 	mov	r3,r2
8110c53c:	e0bffe17 	ldw	r2,-8(fp)
8110c540:	10c5883a 	add	r2,r2,r3
8110c544:	10800017 	ldw	r2,0(r2)
8110c548:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8110c54c:	e0bffd17 	ldw	r2,-12(fp)
}
8110c550:	e037883a 	mov	sp,fp
8110c554:	df000017 	ldw	fp,0(sp)
8110c558:	dec00104 	addi	sp,sp,4
8110c55c:	f800283a 	ret

8110c560 <v_spi_start>:

#ifdef DEBUG_ON
char cDebugBuffer[256];
#endif

void v_spi_start(void){
8110c560:	defffe04 	addi	sp,sp,-8
8110c564:	de00012e 	bgeu	sp,et,8110c56c <v_spi_start+0xc>
8110c568:	003b68fa 	trap	3
8110c56c:	dfc00115 	stw	ra,4(sp)
8110c570:	df000015 	stw	fp,0(sp)
8110c574:	d839883a 	mov	fp,sp
    //Pull CS_n Low to start communication
    SPI_SCK(0);
8110c578:	0007883a 	mov	r3,zero
8110c57c:	00a00034 	movhi	r2,32768
8110c580:	10823004 	addi	r2,r2,2240
8110c584:	10c00035 	stwio	r3,0(r2)
    SPI_CS_N(0);
8110c588:	0007883a 	mov	r3,zero
8110c58c:	00a00034 	movhi	r2,32768
8110c590:	10822c04 	addi	r2,r2,2224
8110c594:	10c00035 	stwio	r3,0(r2)
    SPI_DELAY;
8110c598:	01002584 	movi	r4,150
8110c59c:	11376bc0 	call	811376bc <usleep>
}
8110c5a0:	0001883a 	nop
8110c5a4:	e037883a 	mov	sp,fp
8110c5a8:	dfc00117 	ldw	ra,4(sp)
8110c5ac:	df000017 	ldw	fp,0(sp)
8110c5b0:	dec00204 	addi	sp,sp,8
8110c5b4:	f800283a 	ret

8110c5b8 <v_spi_send_byte>:

void v_spi_send_byte(alt_u8 uc_data){
8110c5b8:	defffc04 	addi	sp,sp,-16
8110c5bc:	de00012e 	bgeu	sp,et,8110c5c4 <v_spi_send_byte+0xc>
8110c5c0:	003b68fa 	trap	3
8110c5c4:	dfc00315 	stw	ra,12(sp)
8110c5c8:	df000215 	stw	fp,8(sp)
8110c5cc:	df000204 	addi	fp,sp,8
8110c5d0:	2005883a 	mov	r2,r4
8110c5d4:	e0bfff05 	stb	r2,-4(fp)

    alt_u8 i = 0;
8110c5d8:	e03ffe05 	stb	zero,-8(fp)
    alt_u8 uc_data_mask = 0x80;
8110c5dc:	00bfe004 	movi	r2,-128
8110c5e0:	e0bffe45 	stb	r2,-7(fp)

    for(i=0;i<8;i++)
8110c5e4:	e03ffe05 	stb	zero,-8(fp)
8110c5e8:	00001b06 	br	8110c658 <v_spi_send_byte+0xa0>
    {
        SPI_SDI((uc_data & uc_data_mask)?1:0);
8110c5ec:	e0ffff03 	ldbu	r3,-4(fp)
8110c5f0:	e0bffe43 	ldbu	r2,-7(fp)
8110c5f4:	1884703a 	and	r2,r3,r2
8110c5f8:	10803fcc 	andi	r2,r2,255
8110c5fc:	1004c03a 	cmpne	r2,r2,zero
8110c600:	10c03fcc 	andi	r3,r2,255
8110c604:	00a00034 	movhi	r2,32768
8110c608:	10823404 	addi	r2,r2,2256
8110c60c:	10c00035 	stwio	r3,0(r2)
        uc_data_mask >>= 1;
8110c610:	e0bffe43 	ldbu	r2,-7(fp)
8110c614:	1004d07a 	srli	r2,r2,1
8110c618:	e0bffe45 	stb	r2,-7(fp)

        SPI_SCK(1);//sck=1; // clock high
8110c61c:	00c00044 	movi	r3,1
8110c620:	00a00034 	movhi	r2,32768
8110c624:	10823004 	addi	r2,r2,2240
8110c628:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110c62c:	01002584 	movi	r4,150
8110c630:	11376bc0 	call	811376bc <usleep>
        SPI_SCK(0);//sck=0; // clock low
8110c634:	0007883a 	mov	r3,zero
8110c638:	00a00034 	movhi	r2,32768
8110c63c:	10823004 	addi	r2,r2,2240
8110c640:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110c644:	01002584 	movi	r4,150
8110c648:	11376bc0 	call	811376bc <usleep>
void v_spi_send_byte(alt_u8 uc_data){

    alt_u8 i = 0;
    alt_u8 uc_data_mask = 0x80;

    for(i=0;i<8;i++)
8110c64c:	e0bffe03 	ldbu	r2,-8(fp)
8110c650:	10800044 	addi	r2,r2,1
8110c654:	e0bffe05 	stb	r2,-8(fp)
8110c658:	e0bffe03 	ldbu	r2,-8(fp)
8110c65c:	10800230 	cmpltui	r2,r2,8
8110c660:	103fe21e 	bne	r2,zero,8110c5ec <__reset+0xfb0ec5ec>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }

}
8110c664:	0001883a 	nop
8110c668:	e037883a 	mov	sp,fp
8110c66c:	dfc00117 	ldw	ra,4(sp)
8110c670:	df000017 	ldw	fp,0(sp)
8110c674:	dec00204 	addi	sp,sp,8
8110c678:	f800283a 	ret

8110c67c <uc_spi_get_byte>:

alt_u8 uc_spi_get_byte(void){
8110c67c:	defffd04 	addi	sp,sp,-12
8110c680:	de00012e 	bgeu	sp,et,8110c688 <uc_spi_get_byte+0xc>
8110c684:	003b68fa 	trap	3
8110c688:	dfc00215 	stw	ra,8(sp)
8110c68c:	df000115 	stw	fp,4(sp)
8110c690:	df000104 	addi	fp,sp,4

    alt_u8 i = 0;
8110c694:	e03fff05 	stb	zero,-4(fp)
    alt_u8 uc_data = 0;
8110c698:	e03fff45 	stb	zero,-3(fp)

    for(i=0;i<8;i++) // read byte
8110c69c:	e03fff05 	stb	zero,-4(fp)
8110c6a0:	00001a06 	br	8110c70c <uc_spi_get_byte+0x90>
    {
        uc_data <<= 1;
8110c6a4:	e0bfff43 	ldbu	r2,-3(fp)
8110c6a8:	1085883a 	add	r2,r2,r2
8110c6ac:	e0bfff45 	stb	r2,-3(fp)
        uc_data |= SPI_SDO;
8110c6b0:	00a00034 	movhi	r2,32768
8110c6b4:	10823804 	addi	r2,r2,2272
8110c6b8:	10800037 	ldwio	r2,0(r2)
8110c6bc:	1080004c 	andi	r2,r2,1
8110c6c0:	1007883a 	mov	r3,r2
8110c6c4:	e0bfff43 	ldbu	r2,-3(fp)
8110c6c8:	1884b03a 	or	r2,r3,r2
8110c6cc:	e0bfff45 	stb	r2,-3(fp)

        SPI_SCK(1);//sck=1; // clock high
8110c6d0:	00c00044 	movi	r3,1
8110c6d4:	00a00034 	movhi	r2,32768
8110c6d8:	10823004 	addi	r2,r2,2240
8110c6dc:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110c6e0:	01002584 	movi	r4,150
8110c6e4:	11376bc0 	call	811376bc <usleep>
        SPI_SCK(0);//sck=0; // clock low
8110c6e8:	0007883a 	mov	r3,zero
8110c6ec:	00a00034 	movhi	r2,32768
8110c6f0:	10823004 	addi	r2,r2,2240
8110c6f4:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110c6f8:	01002584 	movi	r4,150
8110c6fc:	11376bc0 	call	811376bc <usleep>
alt_u8 uc_spi_get_byte(void){

    alt_u8 i = 0;
    alt_u8 uc_data = 0;

    for(i=0;i<8;i++) // read byte
8110c700:	e0bfff03 	ldbu	r2,-4(fp)
8110c704:	10800044 	addi	r2,r2,1
8110c708:	e0bfff05 	stb	r2,-4(fp)
8110c70c:	e0bfff03 	ldbu	r2,-4(fp)
8110c710:	10800230 	cmpltui	r2,r2,8
8110c714:	103fe31e 	bne	r2,zero,8110c6a4 <__reset+0xfb0ec6a4>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }

    return uc_data;
8110c718:	e0bfff43 	ldbu	r2,-3(fp)
}
8110c71c:	e037883a 	mov	sp,fp
8110c720:	dfc00117 	ldw	ra,4(sp)
8110c724:	df000017 	ldw	fp,0(sp)
8110c728:	dec00204 	addi	sp,sp,8
8110c72c:	f800283a 	ret

8110c730 <v_spi_end>:

void v_spi_end(void){
8110c730:	defffe04 	addi	sp,sp,-8
8110c734:	de00012e 	bgeu	sp,et,8110c73c <v_spi_end+0xc>
8110c738:	003b68fa 	trap	3
8110c73c:	dfc00115 	stw	ra,4(sp)
8110c740:	df000015 	stw	fp,0(sp)
8110c744:	d839883a 	mov	fp,sp
    //Set CS_n to end communication
    SPI_SCK(0);
8110c748:	0007883a 	mov	r3,zero
8110c74c:	00a00034 	movhi	r2,32768
8110c750:	10823004 	addi	r2,r2,2240
8110c754:	10c00035 	stwio	r3,0(r2)
    SPI_DELAY;
8110c758:	01002584 	movi	r4,150
8110c75c:	11376bc0 	call	811376bc <usleep>
    SPI_CS_N(1);
8110c760:	00c00044 	movi	r3,1
8110c764:	00a00034 	movhi	r2,32768
8110c768:	10822c04 	addi	r2,r2,2224
8110c76c:	10c00035 	stwio	r3,0(r2)
}
8110c770:	0001883a 	nop
8110c774:	e037883a 	mov	sp,fp
8110c778:	dfc00117 	ldw	ra,4(sp)
8110c77c:	df000017 	ldw	fp,0(sp)
8110c780:	dec00204 	addi	sp,sp,8
8110c784:	f800283a 	ret

8110c788 <RTCC_SPI_R_MAC>:

// Note. SCK: typical 19.2KHZ (53 ms)
bool RTCC_SPI_R_MAC(alt_u8 uc_EUI48_array[6])
{
8110c788:	defff604 	addi	sp,sp,-40
8110c78c:	de00012e 	bgeu	sp,et,8110c794 <RTCC_SPI_R_MAC+0xc>
8110c790:	003b68fa 	trap	3
8110c794:	dfc00915 	stw	ra,36(sp)
8110c798:	df000815 	stw	fp,32(sp)
8110c79c:	df000804 	addi	fp,sp,32
8110c7a0:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8110c7a4:	e03ffc15 	stw	zero,-16(fp)

    alt_u8 uc_EUI48_B0 = 0;
8110c7a8:	e03ffd05 	stb	zero,-12(fp)
    alt_u8 uc_EUI48_B1 = 0;
8110c7ac:	e03ffd45 	stb	zero,-11(fp)
    alt_u8 uc_EUI48_B2 = 0;
8110c7b0:	e03ffd85 	stb	zero,-10(fp)
    alt_u8 uc_EUI48_B3 = 0;
8110c7b4:	e03ffdc5 	stb	zero,-9(fp)
    alt_u8 uc_EUI48_B4 = 0;
8110c7b8:	e03ffe05 	stb	zero,-8(fp)
    alt_u8 uc_EUI48_B5 = 0;
8110c7bc:	e03ffe45 	stb	zero,-7(fp)

//    alt_u8 uc_sdi_mask;

    const alt_u8 uc_EUI48_B0_addr = 0x02;
8110c7c0:	00800084 	movi	r2,2
8110c7c4:	e0bffe85 	stb	r2,-6(fp)
//    const alt_u8 uc_EUI48_B2_addr = 0x04;
//    const alt_u8 uc_EUI48_B3_addr = 0x05;
//    const alt_u8 uc_EUI48_B4_addr = 0x06;
//    const alt_u8 uc_EUI48_B5_addr = 0x07;

    const alt_u8 uc_IDREAD_cmd = 0x33;
8110c7c8:	00800cc4 	movi	r2,51
8110c7cc:	e0bffec5 	stb	r2,-5(fp)

//    int i = 0;
    
    // Start Communication
    v_spi_start();
8110c7d0:	110c5600 	call	8110c560 <v_spi_start>

    //Send IDREAD (0011 0011)
    v_spi_send_byte(uc_IDREAD_cmd);
8110c7d4:	e0bffec3 	ldbu	r2,-5(fp)
8110c7d8:	1009883a 	mov	r4,r2
8110c7dc:	110c5b80 	call	8110c5b8 <v_spi_send_byte>

    //Send Address (0x02 - 0x07)
    v_spi_send_byte(uc_EUI48_B0_addr);
8110c7e0:	e0bffe83 	ldbu	r2,-6(fp)
8110c7e4:	1009883a 	mov	r4,r2
8110c7e8:	110c5b80 	call	8110c5b8 <v_spi_send_byte>

    //Read MAC (EUI-48, 6 bytes)
    uc_EUI48_B0 = uc_spi_get_byte();
8110c7ec:	110c67c0 	call	8110c67c <uc_spi_get_byte>
8110c7f0:	e0bffd05 	stb	r2,-12(fp)
    uc_EUI48_B1 = uc_spi_get_byte();
8110c7f4:	110c67c0 	call	8110c67c <uc_spi_get_byte>
8110c7f8:	e0bffd45 	stb	r2,-11(fp)
    uc_EUI48_B2 = uc_spi_get_byte();
8110c7fc:	110c67c0 	call	8110c67c <uc_spi_get_byte>
8110c800:	e0bffd85 	stb	r2,-10(fp)
    uc_EUI48_B3 = uc_spi_get_byte();
8110c804:	110c67c0 	call	8110c67c <uc_spi_get_byte>
8110c808:	e0bffdc5 	stb	r2,-9(fp)
    uc_EUI48_B4 = uc_spi_get_byte();
8110c80c:	110c67c0 	call	8110c67c <uc_spi_get_byte>
8110c810:	e0bffe05 	stb	r2,-8(fp)
    uc_EUI48_B5 = uc_spi_get_byte();
8110c814:	110c67c0 	call	8110c67c <uc_spi_get_byte>
8110c818:	e0bffe45 	stb	r2,-7(fp)

    // End communication
    v_spi_end();
8110c81c:	110c7300 	call	8110c730 <v_spi_end>

    bSuccess = TRUE;
8110c820:	00800044 	movi	r2,1
8110c824:	e0bffc15 	stw	r2,-16(fp)
    
    uc_EUI48_array[0] = uc_EUI48_B0;
8110c828:	e0bfff17 	ldw	r2,-4(fp)
8110c82c:	e0fffd03 	ldbu	r3,-12(fp)
8110c830:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[1] = uc_EUI48_B1;
8110c834:	e0bfff17 	ldw	r2,-4(fp)
8110c838:	10800044 	addi	r2,r2,1
8110c83c:	e0fffd43 	ldbu	r3,-11(fp)
8110c840:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[2] = uc_EUI48_B2;
8110c844:	e0bfff17 	ldw	r2,-4(fp)
8110c848:	10800084 	addi	r2,r2,2
8110c84c:	e0fffd83 	ldbu	r3,-10(fp)
8110c850:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[3] = uc_EUI48_B3;
8110c854:	e0bfff17 	ldw	r2,-4(fp)
8110c858:	108000c4 	addi	r2,r2,3
8110c85c:	e0fffdc3 	ldbu	r3,-9(fp)
8110c860:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[4] = uc_EUI48_B4;
8110c864:	e0bfff17 	ldw	r2,-4(fp)
8110c868:	10800104 	addi	r2,r2,4
8110c86c:	e0fffe03 	ldbu	r3,-8(fp)
8110c870:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[5] = uc_EUI48_B5;
8110c874:	e0bfff17 	ldw	r2,-4(fp)
8110c878:	10800144 	addi	r2,r2,5
8110c87c:	e0fffe43 	ldbu	r3,-7(fp)
8110c880:	10c00005 	stb	r3,0(r2)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "RTCC EUI-48 MAC Address: 0x%02x:%02x:%02x:%02x:%02x:%02x \n", uc_EUI48_B0, uc_EUI48_B1, uc_EUI48_B2, uc_EUI48_B3, uc_EUI48_B4, uc_EUI48_B5);
8110c884:	e1bffd03 	ldbu	r6,-12(fp)
8110c888:	e1fffd43 	ldbu	r7,-11(fp)
8110c88c:	e0bffd83 	ldbu	r2,-10(fp)
8110c890:	e0fffdc3 	ldbu	r3,-9(fp)
8110c894:	e13ffe03 	ldbu	r4,-8(fp)
8110c898:	e17ffe43 	ldbu	r5,-7(fp)
8110c89c:	d9400315 	stw	r5,12(sp)
8110c8a0:	d9000215 	stw	r4,8(sp)
8110c8a4:	d8c00115 	stw	r3,4(sp)
8110c8a8:	d8800015 	stw	r2,0(sp)
8110c8ac:	01604574 	movhi	r5,33045
8110c8b0:	296fe604 	addi	r5,r5,-16488
8110c8b4:	01204574 	movhi	r4,33045
8110c8b8:	210be504 	addi	r4,r4,12180
8110c8bc:	11229340 	call	81122934 <sprintf>
	debug(fp, cDebugBuffer);
8110c8c0:	d0a06217 	ldw	r2,-32376(gp)
8110c8c4:	01604574 	movhi	r5,33045
8110c8c8:	294be504 	addi	r5,r5,12180
8110c8cc:	1009883a 	mov	r4,r2
8110c8d0:	1120fa40 	call	81120fa4 <fprintf>
#endif

    return bSuccess;
8110c8d4:	e0bffc17 	ldw	r2,-16(fp)
}
8110c8d8:	e037883a 	mov	sp,fp
8110c8dc:	dfc00117 	ldw	ra,4(sp)
8110c8e0:	df000017 	ldw	fp,0(sp)
8110c8e4:	dec00204 	addi	sp,sp,8
8110c8e8:	f800283a 	ret

8110c8ec <bSSDisplayConfig>:
 *
 * @retval TRUE : Sucesso
 * @retval FALSE : Configurao no especificada
 *
 */
bool bSSDisplayConfig(alt_u8 SsdpConfig){
8110c8ec:	defffd04 	addi	sp,sp,-12
8110c8f0:	de00012e 	bgeu	sp,et,8110c8f8 <bSSDisplayConfig+0xc>
8110c8f4:	003b68fa 	trap	3
8110c8f8:	df000215 	stw	fp,8(sp)
8110c8fc:	df000204 	addi	fp,sp,8
8110c900:	2005883a 	mov	r2,r4
8110c904:	e0bfff05 	stb	r2,-4(fp)

    switch(SsdpConfig){
8110c908:	e0bfff03 	ldbu	r2,-4(fp)
8110c90c:	10c00168 	cmpgeui	r3,r2,5
8110c910:	18001c1e 	bne	r3,zero,8110c984 <bSSDisplayConfig+0x98>
8110c914:	100690ba 	slli	r3,r2,2
8110c918:	00a04474 	movhi	r2,33041
8110c91c:	10b24b04 	addi	r2,r2,-14036
8110c920:	1885883a 	add	r2,r3,r2
8110c924:	10800017 	ldw	r2,0(r2)
8110c928:	1000683a 	jmp	r2
8110c92c:	8110c940 	call	88110c94 <__reset+0x20f0c94>
8110c930:	8110c94c 	andi	r4,r16,17189
8110c934:	8110c958 	cmpnei	r4,r16,17189
8110c938:	8110c96c 	andhi	r4,r16,17189
8110c93c:	8110c97c 	xorhi	r4,r16,17189
	    case SSDP_NORMAL_MODE:
	        SspdConfigControl = (SSDP_ON_MASK | SSDP_UNLOCK_MASK);
8110c940:	00800cc4 	movi	r2,51
8110c944:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110c948:	00001006 	br	8110c98c <bSSDisplayConfig+0xa0>
		
	    case SSDP_TEST_MODE:
	        SspdConfigControl = (SSDP_ON_MASK | SSDP_TEST_MASK);
8110c94c:	00801544 	movi	r2,85
8110c950:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110c954:	00000d06 	br	8110c98c <bSSDisplayConfig+0xa0>
		
	    case SSDP_LOCK:
	        SspdConfigControl &= (~SSDP_UNLOCK_MASK);
8110c958:	d0e05043 	ldbu	r3,-32447(gp)
8110c95c:	00bff744 	movi	r2,-35
8110c960:	1884703a 	and	r2,r3,r2
8110c964:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110c968:	00000806 	br	8110c98c <bSSDisplayConfig+0xa0>
		
	    case SSDP_UNLOCK:
	        SspdConfigControl |= SSDP_UNLOCK_MASK;
8110c96c:	d0a05043 	ldbu	r2,-32447(gp)
8110c970:	10800894 	ori	r2,r2,34
8110c974:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110c978:	00000406 	br	8110c98c <bSSDisplayConfig+0xa0>
		
	    case SSDP_OFF:
	        SspdConfigControl = SSDP_OFF_MASK;
8110c97c:	d0205045 	stb	zero,-32447(gp)
	    break;
8110c980:	00000206 	br	8110c98c <bSSDisplayConfig+0xa0>
		
		default:
		    return FALSE;
8110c984:	0005883a 	mov	r2,zero
8110c988:	00000806 	br	8110c9ac <bSSDisplayConfig+0xc0>
	}

	alt_u32 *pSsdpAddr = (alt_u32 *)SSDP_BASE;
8110c98c:	00a00034 	movhi	r2,32768
8110c990:	10828404 	addi	r2,r2,2576
8110c994:	e0bffe15 	stw	r2,-8(fp)
	*(pSsdpAddr + SSDP_CONTROL_REG_OFFSET) = (alt_u32) SspdConfigControl;
8110c998:	d0a05043 	ldbu	r2,-32447(gp)
8110c99c:	10c03fcc 	andi	r3,r2,255
8110c9a0:	e0bffe17 	ldw	r2,-8(fp)
8110c9a4:	10c00015 	stw	r3,0(r2)
	
	return TRUE;
8110c9a8:	00800044 	movi	r2,1
}
8110c9ac:	e037883a 	mov	sp,fp
8110c9b0:	df000017 	ldw	fp,0(sp)
8110c9b4:	dec00104 	addi	sp,sp,4
8110c9b8:	f800283a 	ret

8110c9bc <bSSDisplayUpdate>:
 * @param [in] SsdpData Dado a ser colocado no display de sete segmentos, do tipo unsigned char (alt_u8)
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSSDisplayUpdate(alt_u8 SsdpData){
8110c9bc:	defffd04 	addi	sp,sp,-12
8110c9c0:	de00012e 	bgeu	sp,et,8110c9c8 <bSSDisplayUpdate+0xc>
8110c9c4:	003b68fa 	trap	3
8110c9c8:	df000215 	stw	fp,8(sp)
8110c9cc:	df000204 	addi	fp,sp,8
8110c9d0:	2005883a 	mov	r2,r4
8110c9d4:	e0bfff05 	stb	r2,-4(fp)

	alt_u32 *pSsdpAddr = (alt_u32 *)SSDP_BASE;
8110c9d8:	00a00034 	movhi	r2,32768
8110c9dc:	10828404 	addi	r2,r2,2576
8110c9e0:	e0bffe15 	stw	r2,-8(fp)
	*(pSsdpAddr + SSDP_DATA_REG_OFFSET) = (alt_u32) SsdpData;
8110c9e4:	e0bffe17 	ldw	r2,-8(fp)
8110c9e8:	10800104 	addi	r2,r2,4
8110c9ec:	e0ffff03 	ldbu	r3,-4(fp)
8110c9f0:	10c00015 	stw	r3,0(r2)
	
	return TRUE;
8110c9f4:	00800044 	movi	r2,1
}
8110c9f8:	e037883a 	mov	sp,fp
8110c9fc:	df000017 	ldw	fp,0(sp)
8110ca00:	dec00104 	addi	sp,sp,4
8110ca04:	f800283a 	ret

8110ca08 <vSyncHandleIrq>:
 *
 * @param [in] void* context
 *
 * @retval void
 */
void vSyncHandleIrq(void* pvContext) {
8110ca08:	defff904 	addi	sp,sp,-28
8110ca0c:	de00012e 	bgeu	sp,et,8110ca14 <vSyncHandleIrq+0xc>
8110ca10:	003b68fa 	trap	3
8110ca14:	dfc00615 	stw	ra,24(sp)
8110ca18:	df000515 	stw	fp,20(sp)
8110ca1c:	df000504 	addi	fp,sp,20
8110ca20:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucIL;
	unsigned char ucSyncL;
	unsigned char error_codel;
	tQMask uiCmdtoSend;

	volatile int* pviHoldContext = (volatile int*) pvContext;
8110ca24:	e0bfff17 	ldw	r2,-4(fp)
8110ca28:	e0bffc15 	stw	r2,-16(fp)


	uiCmdtoSend.ulWord = 0;
8110ca2c:	e03ffe15 	stw	zero,-8(fp)
	/* MasterSync? */
	ucSyncL = (vucN % 4);
8110ca30:	d0a05203 	ldbu	r2,-32440(gp)
8110ca34:	108000cc 	andi	r2,r2,3
8110ca38:	e0bffd05 	stb	r2,-12(fp)
	if ( ucSyncL == 0 )
8110ca3c:	e0bffd03 	ldbu	r2,-12(fp)
8110ca40:	1000031e 	bne	r2,zero,8110ca50 <vSyncHandleIrq+0x48>
		uiCmdtoSend.ucByte[2] = M_MASTER_SYNC;
8110ca44:	00bff804 	movi	r2,-32
8110ca48:	e0bffe85 	stb	r2,-6(fp)
8110ca4c:	00000206 	br	8110ca58 <vSyncHandleIrq+0x50>
	else
		uiCmdtoSend.ucByte[2] = M_SYNC;
8110ca50:	00bff844 	movi	r2,-31
8110ca54:	e0bffe85 	stb	r2,-6(fp)

	uiCmdtoSend.ucByte[3] = M_MEB_ADDR;
8110ca58:	00800044 	movi	r2,1
8110ca5c:	e0bffec5 	stb	r2,-5(fp)

	/* Send Priority message to the Meb Task to indicate the Master Sync */
	error_codel = OSQPostFront(xMebQ, (void *)uiCmdtoSend.ulWord);
8110ca60:	d0a06917 	ldw	r2,-32348(gp)
8110ca64:	e0fffe17 	ldw	r3,-8(fp)
8110ca68:	180b883a 	mov	r5,r3
8110ca6c:	1009883a 	mov	r4,r2
8110ca70:	113db400 	call	8113db40 <OSQPostFront>
8110ca74:	e0bffd45 	stb	r2,-11(fp)
	if ( error_codel != OS_ERR_NONE ) {
8110ca78:	e0bffd43 	ldbu	r2,-11(fp)
8110ca7c:	10000126 	beq	r2,zero,8110ca84 <vSyncHandleIrq+0x7c>
		vFailSendMsgMasterSyncMeb( );
8110ca80:	111d0840 	call	8111d084 <vFailSendMsgMasterSyncMeb>
	}

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
8110ca84:	e03ffb05 	stb	zero,-20(fp)
8110ca88:	00001606 	br	8110cae4 <vSyncHandleIrq+0xdc>
		uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucIL;
8110ca8c:	e0bffb03 	ldbu	r2,-20(fp)
8110ca90:	10800444 	addi	r2,r2,17
8110ca94:	e0bffec5 	stb	r2,-5(fp)
		error_codel = OSQPostFront(xFeeQ[ ucIL ], (void *)uiCmdtoSend.ulWord);
8110ca98:	e0bffb03 	ldbu	r2,-20(fp)
8110ca9c:	1085883a 	add	r2,r2,r2
8110caa0:	1087883a 	add	r3,r2,r2
8110caa4:	d0a06a04 	addi	r2,gp,-32344
8110caa8:	1885883a 	add	r2,r3,r2
8110caac:	10800017 	ldw	r2,0(r2)
8110cab0:	e0fffe17 	ldw	r3,-8(fp)
8110cab4:	180b883a 	mov	r5,r3
8110cab8:	1009883a 	mov	r4,r2
8110cabc:	113db400 	call	8113db40 <OSQPostFront>
8110cac0:	e0bffd45 	stb	r2,-11(fp)
		if ( error_codel != OS_ERR_NONE ) {
8110cac4:	e0bffd43 	ldbu	r2,-11(fp)
8110cac8:	10000326 	beq	r2,zero,8110cad8 <vSyncHandleIrq+0xd0>
			vFailSendMsgSync( ucIL );
8110cacc:	e0bffb03 	ldbu	r2,-20(fp)
8110cad0:	1009883a 	mov	r4,r2
8110cad4:	111cfdc0 	call	8111cfdc <vFailSendMsgSync>
	error_codel = OSQPostFront(xMebQ, (void *)uiCmdtoSend.ulWord);
	if ( error_codel != OS_ERR_NONE ) {
		vFailSendMsgMasterSyncMeb( );
	}

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
8110cad8:	e0bffb03 	ldbu	r2,-20(fp)
8110cadc:	10800044 	addi	r2,r2,1
8110cae0:	e0bffb05 	stb	r2,-20(fp)
8110cae4:	e0bffb03 	ldbu	r2,-20(fp)
8110cae8:	103fe826 	beq	r2,zero,8110ca8c <__reset+0xfb0eca8c>
		if ( error_codel != OS_ERR_NONE ) {
			vFailSendMsgSync( ucIL );
		}
	}

	vucN += 1;
8110caec:	d0a05203 	ldbu	r2,-32440(gp)
8110caf0:	10800044 	addi	r2,r2,1
8110caf4:	d0a05205 	stb	r2,-32440(gp)

	#ifdef DEBUG_ON
		fprintf(fp,"Sync %hu \n", ucSyncL);
8110caf8:	d0a06217 	ldw	r2,-32376(gp)
8110cafc:	e0fffd03 	ldbu	r3,-12(fp)
8110cb00:	180d883a 	mov	r6,r3
8110cb04:	01604574 	movhi	r5,33045
8110cb08:	296ff504 	addi	r5,r5,-16428
8110cb0c:	1009883a 	mov	r4,r2
8110cb10:	1120fa40 	call	81120fa4 <fprintf>
	#endif

	vSyncIrqFlagClrSync();
8110cb14:	110cba80 	call	8110cba8 <vSyncIrqFlagClrSync>
}
8110cb18:	0001883a 	nop
8110cb1c:	e037883a 	mov	sp,fp
8110cb20:	dfc00117 	ldw	ra,4(sp)
8110cb24:	df000017 	ldw	fp,0(sp)
8110cb28:	dec00204 	addi	sp,sp,8
8110cb2c:	f800283a 	ret

8110cb30 <vSyncClearCounter>:

void vSyncClearCounter(void) {
8110cb30:	deffff04 	addi	sp,sp,-4
8110cb34:	de00012e 	bgeu	sp,et,8110cb3c <vSyncClearCounter+0xc>
8110cb38:	003b68fa 	trap	3
8110cb3c:	df000015 	stw	fp,0(sp)
8110cb40:	d839883a 	mov	fp,sp
	// Recast the viHoldContext pointer to match the alt_irq_register() function
	// prototype.
	vucN = 0;
8110cb44:	d0205205 	stb	zero,-32440(gp)
}
8110cb48:	0001883a 	nop
8110cb4c:	e037883a 	mov	sp,fp
8110cb50:	df000017 	ldw	fp,0(sp)
8110cb54:	dec00104 	addi	sp,sp,4
8110cb58:	f800283a 	ret

8110cb5c <vSyncInitIrq>:
 *
 * @param [in] void
 *
 * @retval void
 */
void vSyncInitIrq(void) {
8110cb5c:	defffd04 	addi	sp,sp,-12
8110cb60:	de00012e 	bgeu	sp,et,8110cb68 <vSyncInitIrq+0xc>
8110cb64:	003b68fa 	trap	3
8110cb68:	dfc00215 	stw	ra,8(sp)
8110cb6c:	df000115 	stw	fp,4(sp)
8110cb70:	df000104 	addi	fp,sp,4
	// Recast the viHoldContext pointer to match the alt_irq_register() function
	// prototype.
	void* hold_context_ptr = (void*) &viHoldContext;
8110cb74:	d0a05104 	addi	r2,gp,-32444
8110cb78:	e0bfff15 	stw	r2,-4(fp)
	// Register the interrupt handler
	alt_irq_register(SYNC_IRQ, hold_context_ptr, vSyncHandleIrq);
8110cb7c:	01a04474 	movhi	r6,33041
8110cb80:	31b28204 	addi	r6,r6,-13816
8110cb84:	e17fff17 	ldw	r5,-4(fp)
8110cb88:	01000284 	movi	r4,10
8110cb8c:	1135fec0 	call	81135fec <alt_irq_register>
}
8110cb90:	0001883a 	nop
8110cb94:	e037883a 	mov	sp,fp
8110cb98:	dfc00117 	ldw	ra,4(sp)
8110cb9c:	df000017 	ldw	fp,0(sp)
8110cba0:	dec00204 	addi	sp,sp,8
8110cba4:	f800283a 	ret

8110cba8 <vSyncIrqFlagClrSync>:

void vSyncIrqFlagClrSync(void) {
8110cba8:	defffe04 	addi	sp,sp,-8
8110cbac:	de00012e 	bgeu	sp,et,8110cbb4 <vSyncIrqFlagClrSync+0xc>
8110cbb0:	003b68fa 	trap	3
8110cbb4:	dfc00115 	stw	ra,4(sp)
8110cbb8:	df000015 	stw	fp,0(sp)
8110cbbc:	d839883a 	mov	fp,sp
	bSyncWriteReg(SYNC_IRQ_FG_CLR_REG_OFFSET, (alt_u32) SYNC_IRQ_FG_CLR_MSK);
8110cbc0:	01400044 	movi	r5,1
8110cbc4:	010002c4 	movi	r4,11
8110cbc8:	110d9880 	call	8110d988 <bSyncWriteReg>
}
8110cbcc:	0001883a 	nop
8110cbd0:	e037883a 	mov	sp,fp
8110cbd4:	dfc00117 	ldw	ra,4(sp)
8110cbd8:	df000017 	ldw	fp,0(sp)
8110cbdc:	dec00204 	addi	sp,sp,8
8110cbe0:	f800283a 	ret

8110cbe4 <bSyncIrqFlagSync>:

bool bSyncIrqFlagSync(void) {
8110cbe4:	defffd04 	addi	sp,sp,-12
8110cbe8:	de00012e 	bgeu	sp,et,8110cbf0 <bSyncIrqFlagSync+0xc>
8110cbec:	003b68fa 	trap	3
8110cbf0:	dfc00215 	stw	ra,8(sp)
8110cbf4:	df000115 	stw	fp,4(sp)
8110cbf8:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliSyncReadReg(SYNC_IRQ_FG_REG_OFFSET) & SYNC_IRQ_FG_MSK) {
8110cbfc:	01000304 	movi	r4,12
8110cc00:	110d9e40 	call	8110d9e4 <uliSyncReadReg>
8110cc04:	1080004c 	andi	r2,r2,1
8110cc08:	10000326 	beq	r2,zero,8110cc18 <bSyncIrqFlagSync+0x34>
		bFlag = TRUE;
8110cc0c:	00800044 	movi	r2,1
8110cc10:	e0bfff15 	stw	r2,-4(fp)
8110cc14:	00000106 	br	8110cc1c <bSyncIrqFlagSync+0x38>
	} else {
		bFlag = FALSE;
8110cc18:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110cc1c:	e0bfff17 	ldw	r2,-4(fp)
}
8110cc20:	e037883a 	mov	sp,fp
8110cc24:	dfc00117 	ldw	ra,4(sp)
8110cc28:	df000017 	ldw	fp,0(sp)
8110cc2c:	dec00204 	addi	sp,sp,8
8110cc30:	f800283a 	ret

8110cc34 <bSyncStatusExtnIrq>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncStatusExtnIrq(void) {
8110cc34:	defffc04 	addi	sp,sp,-16
8110cc38:	de00012e 	bgeu	sp,et,8110cc40 <bSyncStatusExtnIrq+0xc>
8110cc3c:	003b68fa 	trap	3
8110cc40:	dfc00315 	stw	ra,12(sp)
8110cc44:	df000215 	stw	fp,8(sp)
8110cc48:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110cc4c:	0009883a 	mov	r4,zero
8110cc50:	110d9e40 	call	8110d9e4 <uliSyncReadReg>
8110cc54:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_STAT_EXTN_IRQ_MSK) {
8110cc58:	e0bfff17 	ldw	r2,-4(fp)
8110cc5c:	1000030e 	bge	r2,zero,8110cc6c <bSyncStatusExtnIrq+0x38>
		bResult = TRUE;
8110cc60:	00800044 	movi	r2,1
8110cc64:	e0bffe15 	stw	r2,-8(fp)
8110cc68:	00000106 	br	8110cc70 <bSyncStatusExtnIrq+0x3c>
	} else {
		bResult = FALSE;
8110cc6c:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110cc70:	e0bffe17 	ldw	r2,-8(fp)
}
8110cc74:	e037883a 	mov	sp,fp
8110cc78:	dfc00117 	ldw	ra,4(sp)
8110cc7c:	df000017 	ldw	fp,0(sp)
8110cc80:	dec00204 	addi	sp,sp,8
8110cc84:	f800283a 	ret

8110cc88 <ucSyncStatusState>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusState(void) {
8110cc88:	defffc04 	addi	sp,sp,-16
8110cc8c:	de00012e 	bgeu	sp,et,8110cc94 <ucSyncStatusState+0xc>
8110cc90:	003b68fa 	trap	3
8110cc94:	dfc00315 	stw	ra,12(sp)
8110cc98:	df000215 	stw	fp,8(sp)
8110cc9c:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110cca0:	0009883a 	mov	r4,zero
8110cca4:	110d9e40 	call	8110d9e4 <uliSyncReadReg>
8110cca8:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_STATE_MSK) >> 16);
8110ccac:	e0bffe17 	ldw	r2,-8(fp)
8110ccb0:	10803fec 	andhi	r2,r2,255
8110ccb4:	1004d43a 	srli	r2,r2,16
8110ccb8:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110ccbc:	e0bfff03 	ldbu	r2,-4(fp)
}
8110ccc0:	e037883a 	mov	sp,fp
8110ccc4:	dfc00117 	ldw	ra,4(sp)
8110ccc8:	df000017 	ldw	fp,0(sp)
8110cccc:	dec00204 	addi	sp,sp,8
8110ccd0:	f800283a 	ret

8110ccd4 <ucSyncStatusErrorCode>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusErrorCode(void) {
8110ccd4:	defffc04 	addi	sp,sp,-16
8110ccd8:	de00012e 	bgeu	sp,et,8110cce0 <ucSyncStatusErrorCode+0xc>
8110ccdc:	003b68fa 	trap	3
8110cce0:	dfc00315 	stw	ra,12(sp)
8110cce4:	df000215 	stw	fp,8(sp)
8110cce8:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110ccec:	0009883a 	mov	r4,zero
8110ccf0:	110d9e40 	call	8110d9e4 <uliSyncReadReg>
8110ccf4:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_ERROR_CODE_MSK) >> 8);
8110ccf8:	e0bffe17 	ldw	r2,-8(fp)
8110ccfc:	10bfc00c 	andi	r2,r2,65280
8110cd00:	1004d23a 	srli	r2,r2,8
8110cd04:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110cd08:	e0bfff03 	ldbu	r2,-4(fp)
}
8110cd0c:	e037883a 	mov	sp,fp
8110cd10:	dfc00117 	ldw	ra,4(sp)
8110cd14:	df000017 	ldw	fp,0(sp)
8110cd18:	dec00204 	addi	sp,sp,8
8110cd1c:	f800283a 	ret

8110cd20 <ucSyncStatusCycleNumber>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusCycleNumber(void) {
8110cd20:	defffc04 	addi	sp,sp,-16
8110cd24:	de00012e 	bgeu	sp,et,8110cd2c <ucSyncStatusCycleNumber+0xc>
8110cd28:	003b68fa 	trap	3
8110cd2c:	dfc00315 	stw	ra,12(sp)
8110cd30:	df000215 	stw	fp,8(sp)
8110cd34:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110cd38:	0009883a 	mov	r4,zero
8110cd3c:	110d9e40 	call	8110d9e4 <uliSyncReadReg>
8110cd40:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_CYCLE_NUMBER_MSK) >> 0);
8110cd44:	e0bffe17 	ldw	r2,-8(fp)
8110cd48:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110cd4c:	e0bfff03 	ldbu	r2,-4(fp)
}
8110cd50:	e037883a 	mov	sp,fp
8110cd54:	dfc00117 	ldw	ra,4(sp)
8110cd58:	df000017 	ldw	fp,0(sp)
8110cd5c:	dec00204 	addi	sp,sp,8
8110cd60:	f800283a 	ret

8110cd64 <bSyncSetMbt>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetMbt(alt_u32 uliValue) {
8110cd64:	defffd04 	addi	sp,sp,-12
8110cd68:	de00012e 	bgeu	sp,et,8110cd70 <bSyncSetMbt+0xc>
8110cd6c:	003b68fa 	trap	3
8110cd70:	dfc00215 	stw	ra,8(sp)
8110cd74:	df000115 	stw	fp,4(sp)
8110cd78:	df000104 	addi	fp,sp,4
8110cd7c:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_MBT_REG_OFFSET, uliValue);
8110cd80:	e17fff17 	ldw	r5,-4(fp)
8110cd84:	01000104 	movi	r4,4
8110cd88:	110d9880 	call	8110d988 <bSyncWriteReg>
	return TRUE;
8110cd8c:	00800044 	movi	r2,1
}
8110cd90:	e037883a 	mov	sp,fp
8110cd94:	dfc00117 	ldw	ra,4(sp)
8110cd98:	df000017 	ldw	fp,0(sp)
8110cd9c:	dec00204 	addi	sp,sp,8
8110cda0:	f800283a 	ret

8110cda4 <bSyncSetBt>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetBt(alt_u32 uliValue) {
8110cda4:	defffd04 	addi	sp,sp,-12
8110cda8:	de00012e 	bgeu	sp,et,8110cdb0 <bSyncSetBt+0xc>
8110cdac:	003b68fa 	trap	3
8110cdb0:	dfc00215 	stw	ra,8(sp)
8110cdb4:	df000115 	stw	fp,4(sp)
8110cdb8:	df000104 	addi	fp,sp,4
8110cdbc:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_BT_REG_OFFSET, uliValue);
8110cdc0:	e17fff17 	ldw	r5,-4(fp)
8110cdc4:	01000144 	movi	r4,5
8110cdc8:	110d9880 	call	8110d988 <bSyncWriteReg>
	return TRUE;
8110cdcc:	00800044 	movi	r2,1
}
8110cdd0:	e037883a 	mov	sp,fp
8110cdd4:	dfc00117 	ldw	ra,4(sp)
8110cdd8:	df000017 	ldw	fp,0(sp)
8110cddc:	dec00204 	addi	sp,sp,8
8110cde0:	f800283a 	ret

8110cde4 <bSyncSetPer>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetPer(alt_u32 uliValue) {
8110cde4:	defffd04 	addi	sp,sp,-12
8110cde8:	de00012e 	bgeu	sp,et,8110cdf0 <bSyncSetPer+0xc>
8110cdec:	003b68fa 	trap	3
8110cdf0:	dfc00215 	stw	ra,8(sp)
8110cdf4:	df000115 	stw	fp,4(sp)
8110cdf8:	df000104 	addi	fp,sp,4
8110cdfc:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_PER_REG_OFFSET, uliValue);
8110ce00:	e17fff17 	ldw	r5,-4(fp)
8110ce04:	01000184 	movi	r4,6
8110ce08:	110d9880 	call	8110d988 <bSyncWriteReg>
	return TRUE;
8110ce0c:	00800044 	movi	r2,1
}
8110ce10:	e037883a 	mov	sp,fp
8110ce14:	dfc00117 	ldw	ra,4(sp)
8110ce18:	df000017 	ldw	fp,0(sp)
8110ce1c:	dec00204 	addi	sp,sp,8
8110ce20:	f800283a 	ret

8110ce24 <bSyncSetOst>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetOst(alt_u32 uliValue) {
8110ce24:	defffd04 	addi	sp,sp,-12
8110ce28:	de00012e 	bgeu	sp,et,8110ce30 <bSyncSetOst+0xc>
8110ce2c:	003b68fa 	trap	3
8110ce30:	dfc00215 	stw	ra,8(sp)
8110ce34:	df000115 	stw	fp,4(sp)
8110ce38:	df000104 	addi	fp,sp,4
8110ce3c:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_OST_REG_OFFSET, uliValue);
8110ce40:	e17fff17 	ldw	r5,-4(fp)
8110ce44:	010001c4 	movi	r4,7
8110ce48:	110d9880 	call	8110d988 <bSyncWriteReg>
	return TRUE;
8110ce4c:	00800044 	movi	r2,1
}
8110ce50:	e037883a 	mov	sp,fp
8110ce54:	dfc00117 	ldw	ra,4(sp)
8110ce58:	df000017 	ldw	fp,0(sp)
8110ce5c:	dec00204 	addi	sp,sp,8
8110ce60:	f800283a 	ret

8110ce64 <bSyncSetPolarity>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncSetPolarity(bool bValue) {
8110ce64:	defffc04 	addi	sp,sp,-16
8110ce68:	de00012e 	bgeu	sp,et,8110ce70 <bSyncSetPolarity+0xc>
8110ce6c:	003b68fa 	trap	3
8110ce70:	dfc00315 	stw	ra,12(sp)
8110ce74:	df000215 	stw	fp,8(sp)
8110ce78:	df000204 	addi	fp,sp,8
8110ce7c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110ce80:	01000204 	movi	r4,8
8110ce84:	110d9e40 	call	8110d9e4 <uliSyncReadReg>
8110ce88:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110ce8c:	e0bfff17 	ldw	r2,-4(fp)
8110ce90:	1000051e 	bne	r2,zero,8110cea8 <bSyncSetPolarity+0x44>
		uliAux &= ~SYNC_CONFIG_GEN_POLARITY_MSK;
8110ce94:	e0fffe17 	ldw	r3,-8(fp)
8110ce98:	00bfbfc4 	movi	r2,-257
8110ce9c:	1884703a 	and	r2,r3,r2
8110cea0:	e0bffe15 	stw	r2,-8(fp)
8110cea4:	00000306 	br	8110ceb4 <bSyncSetPolarity+0x50>
	} else {
		uliAux |= SYNC_CONFIG_GEN_POLARITY_MSK;
8110cea8:	e0bffe17 	ldw	r2,-8(fp)
8110ceac:	10804014 	ori	r2,r2,256
8110ceb0:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CONFIG_GENERAL_REG_OFFSET, uliAux);
8110ceb4:	e17ffe17 	ldw	r5,-8(fp)
8110ceb8:	01000204 	movi	r4,8
8110cebc:	110d9880 	call	8110d988 <bSyncWriteReg>
	return TRUE;
8110cec0:	00800044 	movi	r2,1
}
8110cec4:	e037883a 	mov	sp,fp
8110cec8:	dfc00117 	ldw	ra,4(sp)
8110cecc:	df000017 	ldw	fp,0(sp)
8110ced0:	dec00204 	addi	sp,sp,8
8110ced4:	f800283a 	ret

8110ced8 <bSyncSetNCycles>:
 *
 * @param [in] alt_u8 value
 *
 * @retval bool TRUE
 */
bool bSyncSetNCycles(alt_u8 ucValue) {
8110ced8:	defffc04 	addi	sp,sp,-16
8110cedc:	de00012e 	bgeu	sp,et,8110cee4 <bSyncSetNCycles+0xc>
8110cee0:	003b68fa 	trap	3
8110cee4:	dfc00315 	stw	ra,12(sp)
8110cee8:	df000215 	stw	fp,8(sp)
8110ceec:	df000204 	addi	fp,sp,8
8110cef0:	2005883a 	mov	r2,r4
8110cef4:	e0bfff05 	stb	r2,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110cef8:	01000204 	movi	r4,8
8110cefc:	110d9e40 	call	8110d9e4 <uliSyncReadReg>
8110cf00:	e0bffe15 	stw	r2,-8(fp)
	uliAux &= ~SYNC_CONFIG_GEN_N_CYCLES_MSK;
8110cf04:	e0fffe17 	ldw	r3,-8(fp)
8110cf08:	00bfc004 	movi	r2,-256
8110cf0c:	1884703a 	and	r2,r3,r2
8110cf10:	e0bffe15 	stw	r2,-8(fp)
	uliAux |= (alt_u32) ucValue;
8110cf14:	e0bfff03 	ldbu	r2,-4(fp)
8110cf18:	e0fffe17 	ldw	r3,-8(fp)
8110cf1c:	1884b03a 	or	r2,r3,r2
8110cf20:	e0bffe15 	stw	r2,-8(fp)

	bSyncWriteReg(SYNC_CONFIG_GENERAL_REG_OFFSET, uliAux);
8110cf24:	e17ffe17 	ldw	r5,-8(fp)
8110cf28:	01000204 	movi	r4,8
8110cf2c:	110d9880 	call	8110d988 <bSyncWriteReg>
	return TRUE;
8110cf30:	00800044 	movi	r2,1
}
8110cf34:	e037883a 	mov	sp,fp
8110cf38:	dfc00117 	ldw	ra,4(sp)
8110cf3c:	df000017 	ldw	fp,0(sp)
8110cf40:	dec00204 	addi	sp,sp,8
8110cf44:	f800283a 	ret

8110cf48 <uliSyncGetMbt>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetMbt(void) {
8110cf48:	defffd04 	addi	sp,sp,-12
8110cf4c:	de00012e 	bgeu	sp,et,8110cf54 <uliSyncGetMbt+0xc>
8110cf50:	003b68fa 	trap	3
8110cf54:	dfc00215 	stw	ra,8(sp)
8110cf58:	df000115 	stw	fp,4(sp)
8110cf5c:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_MBT_REG_OFFSET);
8110cf60:	01000104 	movi	r4,4
8110cf64:	110d9e40 	call	8110d9e4 <uliSyncReadReg>
8110cf68:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110cf6c:	e0bfff17 	ldw	r2,-4(fp)
}
8110cf70:	e037883a 	mov	sp,fp
8110cf74:	dfc00117 	ldw	ra,4(sp)
8110cf78:	df000017 	ldw	fp,0(sp)
8110cf7c:	dec00204 	addi	sp,sp,8
8110cf80:	f800283a 	ret

8110cf84 <uliSyncGetBt>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetBt(void) {
8110cf84:	defffd04 	addi	sp,sp,-12
8110cf88:	de00012e 	bgeu	sp,et,8110cf90 <uliSyncGetBt+0xc>
8110cf8c:	003b68fa 	trap	3
8110cf90:	dfc00215 	stw	ra,8(sp)
8110cf94:	df000115 	stw	fp,4(sp)
8110cf98:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_BT_REG_OFFSET);
8110cf9c:	01000144 	movi	r4,5
8110cfa0:	110d9e40 	call	8110d9e4 <uliSyncReadReg>
8110cfa4:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110cfa8:	e0bfff17 	ldw	r2,-4(fp)
}
8110cfac:	e037883a 	mov	sp,fp
8110cfb0:	dfc00117 	ldw	ra,4(sp)
8110cfb4:	df000017 	ldw	fp,0(sp)
8110cfb8:	dec00204 	addi	sp,sp,8
8110cfbc:	f800283a 	ret

8110cfc0 <uliSyncGetPer>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetPer(void) {
8110cfc0:	defffd04 	addi	sp,sp,-12
8110cfc4:	de00012e 	bgeu	sp,et,8110cfcc <uliSyncGetPer+0xc>
8110cfc8:	003b68fa 	trap	3
8110cfcc:	dfc00215 	stw	ra,8(sp)
8110cfd0:	df000115 	stw	fp,4(sp)
8110cfd4:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_PER_REG_OFFSET);
8110cfd8:	01000184 	movi	r4,6
8110cfdc:	110d9e40 	call	8110d9e4 <uliSyncReadReg>
8110cfe0:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110cfe4:	e0bfff17 	ldw	r2,-4(fp)
}
8110cfe8:	e037883a 	mov	sp,fp
8110cfec:	dfc00117 	ldw	ra,4(sp)
8110cff0:	df000017 	ldw	fp,0(sp)
8110cff4:	dec00204 	addi	sp,sp,8
8110cff8:	f800283a 	ret

8110cffc <uliSyncGetOst>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetOst(void) {
8110cffc:	defffd04 	addi	sp,sp,-12
8110d000:	de00012e 	bgeu	sp,et,8110d008 <uliSyncGetOst+0xc>
8110d004:	003b68fa 	trap	3
8110d008:	dfc00215 	stw	ra,8(sp)
8110d00c:	df000115 	stw	fp,4(sp)
8110d010:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_OST_REG_OFFSET);
8110d014:	010001c4 	movi	r4,7
8110d018:	110d9e40 	call	8110d9e4 <uliSyncReadReg>
8110d01c:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110d020:	e0bfff17 	ldw	r2,-4(fp)
}
8110d024:	e037883a 	mov	sp,fp
8110d028:	dfc00117 	ldw	ra,4(sp)
8110d02c:	df000017 	ldw	fp,0(sp)
8110d030:	dec00204 	addi	sp,sp,8
8110d034:	f800283a 	ret

8110d038 <uliSyncGetGeneral>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetGeneral(void) {
8110d038:	defffd04 	addi	sp,sp,-12
8110d03c:	de00012e 	bgeu	sp,et,8110d044 <uliSyncGetGeneral+0xc>
8110d040:	003b68fa 	trap	3
8110d044:	dfc00215 	stw	ra,8(sp)
8110d048:	df000115 	stw	fp,4(sp)
8110d04c:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110d050:	01000204 	movi	r4,8
8110d054:	110d9e40 	call	8110d9e4 <uliSyncReadReg>
8110d058:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110d05c:	e0bfff17 	ldw	r2,-4(fp)
}
8110d060:	e037883a 	mov	sp,fp
8110d064:	dfc00117 	ldw	ra,4(sp)
8110d068:	df000017 	ldw	fp,0(sp)
8110d06c:	dec00204 	addi	sp,sp,8
8110d070:	f800283a 	ret

8110d074 <bSyncErrInj>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncErrInj(alt_u32 uliValue) {
8110d074:	defffd04 	addi	sp,sp,-12
8110d078:	de00012e 	bgeu	sp,et,8110d080 <bSyncErrInj+0xc>
8110d07c:	003b68fa 	trap	3
8110d080:	dfc00215 	stw	ra,8(sp)
8110d084:	df000115 	stw	fp,4(sp)
8110d088:	df000104 	addi	fp,sp,4
8110d08c:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_ERR_INJ_REG_OFFSET, uliValue);
8110d090:	e17fff17 	ldw	r5,-4(fp)
8110d094:	01000244 	movi	r4,9
8110d098:	110d9880 	call	8110d988 <bSyncWriteReg>
	return TRUE;
8110d09c:	00800044 	movi	r2,1
}
8110d0a0:	e037883a 	mov	sp,fp
8110d0a4:	dfc00117 	ldw	ra,4(sp)
8110d0a8:	df000017 	ldw	fp,0(sp)
8110d0ac:	dec00204 	addi	sp,sp,8
8110d0b0:	f800283a 	ret

8110d0b4 <bSyncCtrExtnIrq>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrExtnIrq(bool bValue) {
8110d0b4:	defffc04 	addi	sp,sp,-16
8110d0b8:	de00012e 	bgeu	sp,et,8110d0c0 <bSyncCtrExtnIrq+0xc>
8110d0bc:	003b68fa 	trap	3
8110d0c0:	dfc00315 	stw	ra,12(sp)
8110d0c4:	df000215 	stw	fp,8(sp)
8110d0c8:	df000204 	addi	fp,sp,8
8110d0cc:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d0d0:	01000284 	movi	r4,10
8110d0d4:	110d9e40 	call	8110d9e4 <uliSyncReadReg>
8110d0d8:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d0dc:	e0bfff17 	ldw	r2,-4(fp)
8110d0e0:	1000061e 	bne	r2,zero,8110d0fc <bSyncCtrExtnIrq+0x48>
		uliAux &= ~SYNC_CTR_EXTN_INT_MSK;
8110d0e4:	e0fffe17 	ldw	r3,-8(fp)
8110d0e8:	00a00034 	movhi	r2,32768
8110d0ec:	10bfffc4 	addi	r2,r2,-1
8110d0f0:	1884703a 	and	r2,r3,r2
8110d0f4:	e0bffe15 	stw	r2,-8(fp)
8110d0f8:	00000306 	br	8110d108 <bSyncCtrExtnIrq+0x54>
	} else {
		uliAux |= SYNC_CTR_EXTN_INT_MSK;
8110d0fc:	e0bffe17 	ldw	r2,-8(fp)
8110d100:	10a00034 	orhi	r2,r2,32768
8110d104:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d108:	e17ffe17 	ldw	r5,-8(fp)
8110d10c:	01000284 	movi	r4,10
8110d110:	110d9880 	call	8110d988 <bSyncWriteReg>
	return TRUE;
8110d114:	00800044 	movi	r2,1
}
8110d118:	e037883a 	mov	sp,fp
8110d11c:	dfc00117 	ldw	ra,4(sp)
8110d120:	df000017 	ldw	fp,0(sp)
8110d124:	dec00204 	addi	sp,sp,8
8110d128:	f800283a 	ret

8110d12c <bSyncCtrStart>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrStart(void) {
8110d12c:	defffd04 	addi	sp,sp,-12
8110d130:	de00012e 	bgeu	sp,et,8110d138 <bSyncCtrStart+0xc>
8110d134:	003b68fa 	trap	3
8110d138:	dfc00215 	stw	ra,8(sp)
8110d13c:	df000115 	stw	fp,4(sp)
8110d140:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d144:	01000284 	movi	r4,10
8110d148:	110d9e40 	call	8110d9e4 <uliSyncReadReg>
8110d14c:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_START_MSK;
8110d150:	e0bfff17 	ldw	r2,-4(fp)
8110d154:	10800234 	orhi	r2,r2,8
8110d158:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d15c:	e17fff17 	ldw	r5,-4(fp)
8110d160:	01000284 	movi	r4,10
8110d164:	110d9880 	call	8110d988 <bSyncWriteReg>
	return TRUE;
8110d168:	00800044 	movi	r2,1
}
8110d16c:	e037883a 	mov	sp,fp
8110d170:	dfc00117 	ldw	ra,4(sp)
8110d174:	df000017 	ldw	fp,0(sp)
8110d178:	dec00204 	addi	sp,sp,8
8110d17c:	f800283a 	ret

8110d180 <bSyncCtrReset>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrReset(void) {
8110d180:	defffd04 	addi	sp,sp,-12
8110d184:	de00012e 	bgeu	sp,et,8110d18c <bSyncCtrReset+0xc>
8110d188:	003b68fa 	trap	3
8110d18c:	dfc00215 	stw	ra,8(sp)
8110d190:	df000115 	stw	fp,4(sp)
8110d194:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d198:	01000284 	movi	r4,10
8110d19c:	110d9e40 	call	8110d9e4 <uliSyncReadReg>
8110d1a0:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_RESET_MSK;
8110d1a4:	e0bfff17 	ldw	r2,-4(fp)
8110d1a8:	10800134 	orhi	r2,r2,4
8110d1ac:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d1b0:	e17fff17 	ldw	r5,-4(fp)
8110d1b4:	01000284 	movi	r4,10
8110d1b8:	110d9880 	call	8110d988 <bSyncWriteReg>
	return TRUE;
8110d1bc:	00800044 	movi	r2,1
}
8110d1c0:	e037883a 	mov	sp,fp
8110d1c4:	dfc00117 	ldw	ra,4(sp)
8110d1c8:	df000017 	ldw	fp,0(sp)
8110d1cc:	dec00204 	addi	sp,sp,8
8110d1d0:	f800283a 	ret

8110d1d4 <bSyncCtrOneShot>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrOneShot(void) {
8110d1d4:	defffd04 	addi	sp,sp,-12
8110d1d8:	de00012e 	bgeu	sp,et,8110d1e0 <bSyncCtrOneShot+0xc>
8110d1dc:	003b68fa 	trap	3
8110d1e0:	dfc00215 	stw	ra,8(sp)
8110d1e4:	df000115 	stw	fp,4(sp)
8110d1e8:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d1ec:	01000284 	movi	r4,10
8110d1f0:	110d9e40 	call	8110d9e4 <uliSyncReadReg>
8110d1f4:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_ONE_SHOT_MSK;
8110d1f8:	e0bfff17 	ldw	r2,-4(fp)
8110d1fc:	108000b4 	orhi	r2,r2,2
8110d200:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d204:	e17fff17 	ldw	r5,-4(fp)
8110d208:	01000284 	movi	r4,10
8110d20c:	110d9880 	call	8110d988 <bSyncWriteReg>
	return TRUE;
8110d210:	00800044 	movi	r2,1
}
8110d214:	e037883a 	mov	sp,fp
8110d218:	dfc00117 	ldw	ra,4(sp)
8110d21c:	df000017 	ldw	fp,0(sp)
8110d220:	dec00204 	addi	sp,sp,8
8110d224:	f800283a 	ret

8110d228 <bSyncCtrErrInj>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrErrInj(void) {
8110d228:	defffd04 	addi	sp,sp,-12
8110d22c:	de00012e 	bgeu	sp,et,8110d234 <bSyncCtrErrInj+0xc>
8110d230:	003b68fa 	trap	3
8110d234:	dfc00215 	stw	ra,8(sp)
8110d238:	df000115 	stw	fp,4(sp)
8110d23c:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d240:	01000284 	movi	r4,10
8110d244:	110d9e40 	call	8110d9e4 <uliSyncReadReg>
8110d248:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_ERR_INJ_MSK;
8110d24c:	e0bfff17 	ldw	r2,-4(fp)
8110d250:	10800074 	orhi	r2,r2,1
8110d254:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d258:	e17fff17 	ldw	r5,-4(fp)
8110d25c:	01000284 	movi	r4,10
8110d260:	110d9880 	call	8110d988 <bSyncWriteReg>
	return TRUE;
8110d264:	00800044 	movi	r2,1
}
8110d268:	e037883a 	mov	sp,fp
8110d26c:	dfc00117 	ldw	ra,4(sp)
8110d270:	df000017 	ldw	fp,0(sp)
8110d274:	dec00204 	addi	sp,sp,8
8110d278:	f800283a 	ret

8110d27c <bSyncCtrSyncOutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrSyncOutEnable(bool bValue) {
8110d27c:	defffc04 	addi	sp,sp,-16
8110d280:	de00012e 	bgeu	sp,et,8110d288 <bSyncCtrSyncOutEnable+0xc>
8110d284:	003b68fa 	trap	3
8110d288:	dfc00315 	stw	ra,12(sp)
8110d28c:	df000215 	stw	fp,8(sp)
8110d290:	df000204 	addi	fp,sp,8
8110d294:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d298:	01000284 	movi	r4,10
8110d29c:	110d9e40 	call	8110d9e4 <uliSyncReadReg>
8110d2a0:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d2a4:	e0bfff17 	ldw	r2,-4(fp)
8110d2a8:	1000051e 	bne	r2,zero,8110d2c0 <bSyncCtrSyncOutEnable+0x44>
		uliAux &= ~SYNC_CTR_SYNC_OUT_EN_MSK;
8110d2ac:	e0fffe17 	ldw	r3,-8(fp)
8110d2b0:	00bfbfc4 	movi	r2,-257
8110d2b4:	1884703a 	and	r2,r3,r2
8110d2b8:	e0bffe15 	stw	r2,-8(fp)
8110d2bc:	00000306 	br	8110d2cc <bSyncCtrSyncOutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_SYNC_OUT_EN_MSK;
8110d2c0:	e0bffe17 	ldw	r2,-8(fp)
8110d2c4:	10804014 	ori	r2,r2,256
8110d2c8:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d2cc:	e17ffe17 	ldw	r5,-8(fp)
8110d2d0:	01000284 	movi	r4,10
8110d2d4:	110d9880 	call	8110d988 <bSyncWriteReg>
	return TRUE;
8110d2d8:	00800044 	movi	r2,1
}
8110d2dc:	e037883a 	mov	sp,fp
8110d2e0:	dfc00117 	ldw	ra,4(sp)
8110d2e4:	df000017 	ldw	fp,0(sp)
8110d2e8:	dec00204 	addi	sp,sp,8
8110d2ec:	f800283a 	ret

8110d2f0 <bSyncCtrCh1OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh1OutEnable(bool bValue) {
8110d2f0:	defffc04 	addi	sp,sp,-16
8110d2f4:	de00012e 	bgeu	sp,et,8110d2fc <bSyncCtrCh1OutEnable+0xc>
8110d2f8:	003b68fa 	trap	3
8110d2fc:	dfc00315 	stw	ra,12(sp)
8110d300:	df000215 	stw	fp,8(sp)
8110d304:	df000204 	addi	fp,sp,8
8110d308:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d30c:	01000284 	movi	r4,10
8110d310:	110d9e40 	call	8110d9e4 <uliSyncReadReg>
8110d314:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d318:	e0bfff17 	ldw	r2,-4(fp)
8110d31c:	1000051e 	bne	r2,zero,8110d334 <bSyncCtrCh1OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHA_EN_MSK;
8110d320:	e0fffe17 	ldw	r3,-8(fp)
8110d324:	00bfff84 	movi	r2,-2
8110d328:	1884703a 	and	r2,r3,r2
8110d32c:	e0bffe15 	stw	r2,-8(fp)
8110d330:	00000306 	br	8110d340 <bSyncCtrCh1OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHA_EN_MSK;
8110d334:	e0bffe17 	ldw	r2,-8(fp)
8110d338:	10800054 	ori	r2,r2,1
8110d33c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d340:	e17ffe17 	ldw	r5,-8(fp)
8110d344:	01000284 	movi	r4,10
8110d348:	110d9880 	call	8110d988 <bSyncWriteReg>
	return TRUE;
8110d34c:	00800044 	movi	r2,1
}
8110d350:	e037883a 	mov	sp,fp
8110d354:	dfc00117 	ldw	ra,4(sp)
8110d358:	df000017 	ldw	fp,0(sp)
8110d35c:	dec00204 	addi	sp,sp,8
8110d360:	f800283a 	ret

8110d364 <bSyncCtrCh2OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh2OutEnable(bool bValue) {
8110d364:	defffc04 	addi	sp,sp,-16
8110d368:	de00012e 	bgeu	sp,et,8110d370 <bSyncCtrCh2OutEnable+0xc>
8110d36c:	003b68fa 	trap	3
8110d370:	dfc00315 	stw	ra,12(sp)
8110d374:	df000215 	stw	fp,8(sp)
8110d378:	df000204 	addi	fp,sp,8
8110d37c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d380:	01000284 	movi	r4,10
8110d384:	110d9e40 	call	8110d9e4 <uliSyncReadReg>
8110d388:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d38c:	e0bfff17 	ldw	r2,-4(fp)
8110d390:	1000051e 	bne	r2,zero,8110d3a8 <bSyncCtrCh2OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHB_EN_MSK;
8110d394:	e0fffe17 	ldw	r3,-8(fp)
8110d398:	00bfff44 	movi	r2,-3
8110d39c:	1884703a 	and	r2,r3,r2
8110d3a0:	e0bffe15 	stw	r2,-8(fp)
8110d3a4:	00000306 	br	8110d3b4 <bSyncCtrCh2OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHB_EN_MSK;
8110d3a8:	e0bffe17 	ldw	r2,-8(fp)
8110d3ac:	10800094 	ori	r2,r2,2
8110d3b0:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d3b4:	e17ffe17 	ldw	r5,-8(fp)
8110d3b8:	01000284 	movi	r4,10
8110d3bc:	110d9880 	call	8110d988 <bSyncWriteReg>
	return TRUE;
8110d3c0:	00800044 	movi	r2,1
}
8110d3c4:	e037883a 	mov	sp,fp
8110d3c8:	dfc00117 	ldw	ra,4(sp)
8110d3cc:	df000017 	ldw	fp,0(sp)
8110d3d0:	dec00204 	addi	sp,sp,8
8110d3d4:	f800283a 	ret

8110d3d8 <bSyncCtrCh3OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh3OutEnable(bool bValue) {
8110d3d8:	defffc04 	addi	sp,sp,-16
8110d3dc:	de00012e 	bgeu	sp,et,8110d3e4 <bSyncCtrCh3OutEnable+0xc>
8110d3e0:	003b68fa 	trap	3
8110d3e4:	dfc00315 	stw	ra,12(sp)
8110d3e8:	df000215 	stw	fp,8(sp)
8110d3ec:	df000204 	addi	fp,sp,8
8110d3f0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d3f4:	01000284 	movi	r4,10
8110d3f8:	110d9e40 	call	8110d9e4 <uliSyncReadReg>
8110d3fc:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d400:	e0bfff17 	ldw	r2,-4(fp)
8110d404:	1000051e 	bne	r2,zero,8110d41c <bSyncCtrCh3OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHC_EN_MSK;
8110d408:	e0fffe17 	ldw	r3,-8(fp)
8110d40c:	00bffec4 	movi	r2,-5
8110d410:	1884703a 	and	r2,r3,r2
8110d414:	e0bffe15 	stw	r2,-8(fp)
8110d418:	00000306 	br	8110d428 <bSyncCtrCh3OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHC_EN_MSK;
8110d41c:	e0bffe17 	ldw	r2,-8(fp)
8110d420:	10800114 	ori	r2,r2,4
8110d424:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d428:	e17ffe17 	ldw	r5,-8(fp)
8110d42c:	01000284 	movi	r4,10
8110d430:	110d9880 	call	8110d988 <bSyncWriteReg>
	return TRUE;
8110d434:	00800044 	movi	r2,1
}
8110d438:	e037883a 	mov	sp,fp
8110d43c:	dfc00117 	ldw	ra,4(sp)
8110d440:	df000017 	ldw	fp,0(sp)
8110d444:	dec00204 	addi	sp,sp,8
8110d448:	f800283a 	ret

8110d44c <bSyncCtrCh4OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh4OutEnable(bool bValue) {
8110d44c:	defffc04 	addi	sp,sp,-16
8110d450:	de00012e 	bgeu	sp,et,8110d458 <bSyncCtrCh4OutEnable+0xc>
8110d454:	003b68fa 	trap	3
8110d458:	dfc00315 	stw	ra,12(sp)
8110d45c:	df000215 	stw	fp,8(sp)
8110d460:	df000204 	addi	fp,sp,8
8110d464:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d468:	01000284 	movi	r4,10
8110d46c:	110d9e40 	call	8110d9e4 <uliSyncReadReg>
8110d470:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d474:	e0bfff17 	ldw	r2,-4(fp)
8110d478:	1000051e 	bne	r2,zero,8110d490 <bSyncCtrCh4OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHD_EN_MSK;
8110d47c:	e0fffe17 	ldw	r3,-8(fp)
8110d480:	00bffdc4 	movi	r2,-9
8110d484:	1884703a 	and	r2,r3,r2
8110d488:	e0bffe15 	stw	r2,-8(fp)
8110d48c:	00000306 	br	8110d49c <bSyncCtrCh4OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHD_EN_MSK;
8110d490:	e0bffe17 	ldw	r2,-8(fp)
8110d494:	10800214 	ori	r2,r2,8
8110d498:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d49c:	e17ffe17 	ldw	r5,-8(fp)
8110d4a0:	01000284 	movi	r4,10
8110d4a4:	110d9880 	call	8110d988 <bSyncWriteReg>
	return TRUE;
8110d4a8:	00800044 	movi	r2,1
}
8110d4ac:	e037883a 	mov	sp,fp
8110d4b0:	dfc00117 	ldw	ra,4(sp)
8110d4b4:	df000017 	ldw	fp,0(sp)
8110d4b8:	dec00204 	addi	sp,sp,8
8110d4bc:	f800283a 	ret

8110d4c0 <bSyncCtrCh5OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh5OutEnable(bool bValue) {
8110d4c0:	defffc04 	addi	sp,sp,-16
8110d4c4:	de00012e 	bgeu	sp,et,8110d4cc <bSyncCtrCh5OutEnable+0xc>
8110d4c8:	003b68fa 	trap	3
8110d4cc:	dfc00315 	stw	ra,12(sp)
8110d4d0:	df000215 	stw	fp,8(sp)
8110d4d4:	df000204 	addi	fp,sp,8
8110d4d8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d4dc:	01000284 	movi	r4,10
8110d4e0:	110d9e40 	call	8110d9e4 <uliSyncReadReg>
8110d4e4:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d4e8:	e0bfff17 	ldw	r2,-4(fp)
8110d4ec:	1000051e 	bne	r2,zero,8110d504 <bSyncCtrCh5OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHE_EN_MSK;
8110d4f0:	e0fffe17 	ldw	r3,-8(fp)
8110d4f4:	00bffbc4 	movi	r2,-17
8110d4f8:	1884703a 	and	r2,r3,r2
8110d4fc:	e0bffe15 	stw	r2,-8(fp)
8110d500:	00000306 	br	8110d510 <bSyncCtrCh5OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHE_EN_MSK;
8110d504:	e0bffe17 	ldw	r2,-8(fp)
8110d508:	10800414 	ori	r2,r2,16
8110d50c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d510:	e17ffe17 	ldw	r5,-8(fp)
8110d514:	01000284 	movi	r4,10
8110d518:	110d9880 	call	8110d988 <bSyncWriteReg>
	return TRUE;
8110d51c:	00800044 	movi	r2,1
}
8110d520:	e037883a 	mov	sp,fp
8110d524:	dfc00117 	ldw	ra,4(sp)
8110d528:	df000017 	ldw	fp,0(sp)
8110d52c:	dec00204 	addi	sp,sp,8
8110d530:	f800283a 	ret

8110d534 <bSyncCtrCh6OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh6OutEnable(bool bValue) {
8110d534:	defffc04 	addi	sp,sp,-16
8110d538:	de00012e 	bgeu	sp,et,8110d540 <bSyncCtrCh6OutEnable+0xc>
8110d53c:	003b68fa 	trap	3
8110d540:	dfc00315 	stw	ra,12(sp)
8110d544:	df000215 	stw	fp,8(sp)
8110d548:	df000204 	addi	fp,sp,8
8110d54c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d550:	01000284 	movi	r4,10
8110d554:	110d9e40 	call	8110d9e4 <uliSyncReadReg>
8110d558:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d55c:	e0bfff17 	ldw	r2,-4(fp)
8110d560:	1000051e 	bne	r2,zero,8110d578 <bSyncCtrCh6OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHF_EN_MSK;
8110d564:	e0fffe17 	ldw	r3,-8(fp)
8110d568:	00bff7c4 	movi	r2,-33
8110d56c:	1884703a 	and	r2,r3,r2
8110d570:	e0bffe15 	stw	r2,-8(fp)
8110d574:	00000306 	br	8110d584 <bSyncCtrCh6OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHF_EN_MSK;
8110d578:	e0bffe17 	ldw	r2,-8(fp)
8110d57c:	10800814 	ori	r2,r2,32
8110d580:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d584:	e17ffe17 	ldw	r5,-8(fp)
8110d588:	01000284 	movi	r4,10
8110d58c:	110d9880 	call	8110d988 <bSyncWriteReg>
	return TRUE;
8110d590:	00800044 	movi	r2,1
}
8110d594:	e037883a 	mov	sp,fp
8110d598:	dfc00117 	ldw	ra,4(sp)
8110d59c:	df000017 	ldw	fp,0(sp)
8110d5a0:	dec00204 	addi	sp,sp,8
8110d5a4:	f800283a 	ret

8110d5a8 <bSyncCtrCh7OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh7OutEnable(bool bValue) {
8110d5a8:	defffc04 	addi	sp,sp,-16
8110d5ac:	de00012e 	bgeu	sp,et,8110d5b4 <bSyncCtrCh7OutEnable+0xc>
8110d5b0:	003b68fa 	trap	3
8110d5b4:	dfc00315 	stw	ra,12(sp)
8110d5b8:	df000215 	stw	fp,8(sp)
8110d5bc:	df000204 	addi	fp,sp,8
8110d5c0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d5c4:	01000284 	movi	r4,10
8110d5c8:	110d9e40 	call	8110d9e4 <uliSyncReadReg>
8110d5cc:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d5d0:	e0bfff17 	ldw	r2,-4(fp)
8110d5d4:	1000051e 	bne	r2,zero,8110d5ec <bSyncCtrCh7OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHG_EN_MSK;
8110d5d8:	e0fffe17 	ldw	r3,-8(fp)
8110d5dc:	00bfefc4 	movi	r2,-65
8110d5e0:	1884703a 	and	r2,r3,r2
8110d5e4:	e0bffe15 	stw	r2,-8(fp)
8110d5e8:	00000306 	br	8110d5f8 <bSyncCtrCh7OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHG_EN_MSK;
8110d5ec:	e0bffe17 	ldw	r2,-8(fp)
8110d5f0:	10801014 	ori	r2,r2,64
8110d5f4:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d5f8:	e17ffe17 	ldw	r5,-8(fp)
8110d5fc:	01000284 	movi	r4,10
8110d600:	110d9880 	call	8110d988 <bSyncWriteReg>
	return TRUE;
8110d604:	00800044 	movi	r2,1
}
8110d608:	e037883a 	mov	sp,fp
8110d60c:	dfc00117 	ldw	ra,4(sp)
8110d610:	df000017 	ldw	fp,0(sp)
8110d614:	dec00204 	addi	sp,sp,8
8110d618:	f800283a 	ret

8110d61c <bSyncCtrCh8OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh8OutEnable(bool bValue) {
8110d61c:	defffc04 	addi	sp,sp,-16
8110d620:	de00012e 	bgeu	sp,et,8110d628 <bSyncCtrCh8OutEnable+0xc>
8110d624:	003b68fa 	trap	3
8110d628:	dfc00315 	stw	ra,12(sp)
8110d62c:	df000215 	stw	fp,8(sp)
8110d630:	df000204 	addi	fp,sp,8
8110d634:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d638:	01000284 	movi	r4,10
8110d63c:	110d9e40 	call	8110d9e4 <uliSyncReadReg>
8110d640:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d644:	e0bfff17 	ldw	r2,-4(fp)
8110d648:	1000051e 	bne	r2,zero,8110d660 <bSyncCtrCh8OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHH_EN_MSK;
8110d64c:	e0fffe17 	ldw	r3,-8(fp)
8110d650:	00bfdfc4 	movi	r2,-129
8110d654:	1884703a 	and	r2,r3,r2
8110d658:	e0bffe15 	stw	r2,-8(fp)
8110d65c:	00000306 	br	8110d66c <bSyncCtrCh8OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHH_EN_MSK;
8110d660:	e0bffe17 	ldw	r2,-8(fp)
8110d664:	10802014 	ori	r2,r2,128
8110d668:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d66c:	e17ffe17 	ldw	r5,-8(fp)
8110d670:	01000284 	movi	r4,10
8110d674:	110d9880 	call	8110d988 <bSyncWriteReg>
	return TRUE;
8110d678:	00800044 	movi	r2,1
}
8110d67c:	e037883a 	mov	sp,fp
8110d680:	dfc00117 	ldw	ra,4(sp)
8110d684:	df000017 	ldw	fp,0(sp)
8110d688:	dec00204 	addi	sp,sp,8
8110d68c:	f800283a 	ret

8110d690 <bSyncIrqEnableError>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqEnableError(bool bValue) {
8110d690:	defffc04 	addi	sp,sp,-16
8110d694:	de00012e 	bgeu	sp,et,8110d69c <bSyncIrqEnableError+0xc>
8110d698:	003b68fa 	trap	3
8110d69c:	dfc00315 	stw	ra,12(sp)
8110d6a0:	df000215 	stw	fp,8(sp)
8110d6a4:	df000204 	addi	fp,sp,8
8110d6a8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_ENABLE_REG_OFFSET);
8110d6ac:	01000044 	movi	r4,1
8110d6b0:	110d9e40 	call	8110d9e4 <uliSyncReadReg>
8110d6b4:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d6b8:	e0bfff17 	ldw	r2,-4(fp)
8110d6bc:	1000051e 	bne	r2,zero,8110d6d4 <bSyncIrqEnableError+0x44>
		uliAux &= ~SYNC_IRQ_ENABLE_ERROR_MSK;
8110d6c0:	e0fffe17 	ldw	r3,-8(fp)
8110d6c4:	00bfff44 	movi	r2,-3
8110d6c8:	1884703a 	and	r2,r3,r2
8110d6cc:	e0bffe15 	stw	r2,-8(fp)
8110d6d0:	00000306 	br	8110d6e0 <bSyncIrqEnableError+0x50>
	} else {
		uliAux |= SYNC_IRQ_ENABLE_ERROR_MSK;
8110d6d4:	e0bffe17 	ldw	r2,-8(fp)
8110d6d8:	10800094 	ori	r2,r2,2
8110d6dc:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_ENABLE_REG_OFFSET, uliAux);
8110d6e0:	e17ffe17 	ldw	r5,-8(fp)
8110d6e4:	01000044 	movi	r4,1
8110d6e8:	110d9880 	call	8110d988 <bSyncWriteReg>
	return TRUE;
8110d6ec:	00800044 	movi	r2,1
}
8110d6f0:	e037883a 	mov	sp,fp
8110d6f4:	dfc00117 	ldw	ra,4(sp)
8110d6f8:	df000017 	ldw	fp,0(sp)
8110d6fc:	dec00204 	addi	sp,sp,8
8110d700:	f800283a 	ret

8110d704 <bSyncIrqEnableBlank>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqEnableBlank(bool bValue) {
8110d704:	defffc04 	addi	sp,sp,-16
8110d708:	de00012e 	bgeu	sp,et,8110d710 <bSyncIrqEnableBlank+0xc>
8110d70c:	003b68fa 	trap	3
8110d710:	dfc00315 	stw	ra,12(sp)
8110d714:	df000215 	stw	fp,8(sp)
8110d718:	df000204 	addi	fp,sp,8
8110d71c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_ENABLE_REG_OFFSET);
8110d720:	01000044 	movi	r4,1
8110d724:	110d9e40 	call	8110d9e4 <uliSyncReadReg>
8110d728:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d72c:	e0bfff17 	ldw	r2,-4(fp)
8110d730:	1000051e 	bne	r2,zero,8110d748 <bSyncIrqEnableBlank+0x44>
		uliAux &= ~SYNC_IRQ_ENABLE_BLANK_MSK;
8110d734:	e0fffe17 	ldw	r3,-8(fp)
8110d738:	00bfff84 	movi	r2,-2
8110d73c:	1884703a 	and	r2,r3,r2
8110d740:	e0bffe15 	stw	r2,-8(fp)
8110d744:	00000306 	br	8110d754 <bSyncIrqEnableBlank+0x50>
	} else {
		uliAux |= SYNC_IRQ_ENABLE_BLANK_MSK;
8110d748:	e0bffe17 	ldw	r2,-8(fp)
8110d74c:	10800054 	ori	r2,r2,1
8110d750:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_ENABLE_REG_OFFSET, uliAux);
8110d754:	e17ffe17 	ldw	r5,-8(fp)
8110d758:	01000044 	movi	r4,1
8110d75c:	110d9880 	call	8110d988 <bSyncWriteReg>
	return TRUE;
8110d760:	00800044 	movi	r2,1
}
8110d764:	e037883a 	mov	sp,fp
8110d768:	dfc00117 	ldw	ra,4(sp)
8110d76c:	df000017 	ldw	fp,0(sp)
8110d770:	dec00204 	addi	sp,sp,8
8110d774:	f800283a 	ret

8110d778 <bSyncIrqFlagClrError>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqFlagClrError(bool bValue) {
8110d778:	defffc04 	addi	sp,sp,-16
8110d77c:	de00012e 	bgeu	sp,et,8110d784 <bSyncIrqFlagClrError+0xc>
8110d780:	003b68fa 	trap	3
8110d784:	dfc00315 	stw	ra,12(sp)
8110d788:	df000215 	stw	fp,8(sp)
8110d78c:	df000204 	addi	fp,sp,8
8110d790:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET);
8110d794:	01000084 	movi	r4,2
8110d798:	110d9e40 	call	8110d9e4 <uliSyncReadReg>
8110d79c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d7a0:	e0bfff17 	ldw	r2,-4(fp)
8110d7a4:	1000051e 	bne	r2,zero,8110d7bc <bSyncIrqFlagClrError+0x44>
		uliAux &= ~SYNC_IRQ_FLAG_CLR_ERROR_MSK;
8110d7a8:	e0fffe17 	ldw	r3,-8(fp)
8110d7ac:	00bfff44 	movi	r2,-3
8110d7b0:	1884703a 	and	r2,r3,r2
8110d7b4:	e0bffe15 	stw	r2,-8(fp)
8110d7b8:	00000306 	br	8110d7c8 <bSyncIrqFlagClrError+0x50>
	} else {
		uliAux |= SYNC_IRQ_FLAG_CLR_ERROR_MSK;
8110d7bc:	e0bffe17 	ldw	r2,-8(fp)
8110d7c0:	10800094 	ori	r2,r2,2
8110d7c4:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET, uliAux);
8110d7c8:	e17ffe17 	ldw	r5,-8(fp)
8110d7cc:	01000084 	movi	r4,2
8110d7d0:	110d9880 	call	8110d988 <bSyncWriteReg>
	return TRUE;
8110d7d4:	00800044 	movi	r2,1
}
8110d7d8:	e037883a 	mov	sp,fp
8110d7dc:	dfc00117 	ldw	ra,4(sp)
8110d7e0:	df000017 	ldw	fp,0(sp)
8110d7e4:	dec00204 	addi	sp,sp,8
8110d7e8:	f800283a 	ret

8110d7ec <bSyncIrqFlagClrBlank>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqFlagClrBlank(bool bValue) {
8110d7ec:	defffc04 	addi	sp,sp,-16
8110d7f0:	de00012e 	bgeu	sp,et,8110d7f8 <bSyncIrqFlagClrBlank+0xc>
8110d7f4:	003b68fa 	trap	3
8110d7f8:	dfc00315 	stw	ra,12(sp)
8110d7fc:	df000215 	stw	fp,8(sp)
8110d800:	df000204 	addi	fp,sp,8
8110d804:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET);
8110d808:	01000084 	movi	r4,2
8110d80c:	110d9e40 	call	8110d9e4 <uliSyncReadReg>
8110d810:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d814:	e0bfff17 	ldw	r2,-4(fp)
8110d818:	1000051e 	bne	r2,zero,8110d830 <bSyncIrqFlagClrBlank+0x44>
		uliAux &= ~SYNC_IRQ_FLAG_CLR_BLANK_MSK;
8110d81c:	e0fffe17 	ldw	r3,-8(fp)
8110d820:	00bfff84 	movi	r2,-2
8110d824:	1884703a 	and	r2,r3,r2
8110d828:	e0bffe15 	stw	r2,-8(fp)
8110d82c:	00000306 	br	8110d83c <bSyncIrqFlagClrBlank+0x50>
	} else {
		uliAux |= SYNC_IRQ_FLAG_CLR_BLANK_MSK;
8110d830:	e0bffe17 	ldw	r2,-8(fp)
8110d834:	10800054 	ori	r2,r2,1
8110d838:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET, uliAux);
8110d83c:	e17ffe17 	ldw	r5,-8(fp)
8110d840:	01000084 	movi	r4,2
8110d844:	110d9880 	call	8110d988 <bSyncWriteReg>
	return TRUE;
8110d848:	00800044 	movi	r2,1
}
8110d84c:	e037883a 	mov	sp,fp
8110d850:	dfc00117 	ldw	ra,4(sp)
8110d854:	df000017 	ldw	fp,0(sp)
8110d858:	dec00204 	addi	sp,sp,8
8110d85c:	f800283a 	ret

8110d860 <bSyncIrqFlagError>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncIrqFlagError(void) {
8110d860:	defffc04 	addi	sp,sp,-16
8110d864:	de00012e 	bgeu	sp,et,8110d86c <bSyncIrqFlagError+0xc>
8110d868:	003b68fa 	trap	3
8110d86c:	dfc00315 	stw	ra,12(sp)
8110d870:	df000215 	stw	fp,8(sp)
8110d874:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_REG_OFFSET);
8110d878:	010000c4 	movi	r4,3
8110d87c:	110d9e40 	call	8110d9e4 <uliSyncReadReg>
8110d880:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_IRQ_FLAG_ERROR_MSK) {
8110d884:	e0bfff17 	ldw	r2,-4(fp)
8110d888:	1080008c 	andi	r2,r2,2
8110d88c:	10000326 	beq	r2,zero,8110d89c <bSyncIrqFlagError+0x3c>
		bResult = TRUE;
8110d890:	00800044 	movi	r2,1
8110d894:	e0bffe15 	stw	r2,-8(fp)
8110d898:	00000106 	br	8110d8a0 <bSyncIrqFlagError+0x40>
	} else {
		bResult = FALSE;
8110d89c:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110d8a0:	e0bffe17 	ldw	r2,-8(fp)
}
8110d8a4:	e037883a 	mov	sp,fp
8110d8a8:	dfc00117 	ldw	ra,4(sp)
8110d8ac:	df000017 	ldw	fp,0(sp)
8110d8b0:	dec00204 	addi	sp,sp,8
8110d8b4:	f800283a 	ret

8110d8b8 <bSyncIrqFlagBlank>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncIrqFlagBlank(void) {
8110d8b8:	defffc04 	addi	sp,sp,-16
8110d8bc:	de00012e 	bgeu	sp,et,8110d8c4 <bSyncIrqFlagBlank+0xc>
8110d8c0:	003b68fa 	trap	3
8110d8c4:	dfc00315 	stw	ra,12(sp)
8110d8c8:	df000215 	stw	fp,8(sp)
8110d8cc:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_REG_OFFSET);
8110d8d0:	010000c4 	movi	r4,3
8110d8d4:	110d9e40 	call	8110d9e4 <uliSyncReadReg>
8110d8d8:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_IRQ_FLAG_BLANK_MSK) {
8110d8dc:	e0bfff17 	ldw	r2,-4(fp)
8110d8e0:	1080004c 	andi	r2,r2,1
8110d8e4:	10000326 	beq	r2,zero,8110d8f4 <bSyncIrqFlagBlank+0x3c>
		bResult = TRUE;
8110d8e8:	00800044 	movi	r2,1
8110d8ec:	e0bffe15 	stw	r2,-8(fp)
8110d8f0:	00000106 	br	8110d8f8 <bSyncIrqFlagBlank+0x40>
	} else {
		bResult = FALSE;
8110d8f4:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110d8f8:	e0bffe17 	ldw	r2,-8(fp)
}
8110d8fc:	e037883a 	mov	sp,fp
8110d900:	dfc00117 	ldw	ra,4(sp)
8110d904:	df000017 	ldw	fp,0(sp)
8110d908:	dec00204 	addi	sp,sp,8
8110d90c:	f800283a 	ret

8110d910 <uliSyncGetCtr>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetCtr(void) {
8110d910:	defffd04 	addi	sp,sp,-12
8110d914:	de00012e 	bgeu	sp,et,8110d91c <uliSyncGetCtr+0xc>
8110d918:	003b68fa 	trap	3
8110d91c:	dfc00215 	stw	ra,8(sp)
8110d920:	df000115 	stw	fp,4(sp)
8110d924:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d928:	01000284 	movi	r4,10
8110d92c:	110d9e40 	call	8110d9e4 <uliSyncReadReg>
8110d930:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110d934:	e0bfff17 	ldw	r2,-4(fp)
}
8110d938:	e037883a 	mov	sp,fp
8110d93c:	dfc00117 	ldw	ra,4(sp)
8110d940:	df000017 	ldw	fp,0(sp)
8110d944:	dec00204 	addi	sp,sp,8
8110d948:	f800283a 	ret

8110d94c <uliSyncReadStatus>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncReadStatus(void) {
8110d94c:	defffd04 	addi	sp,sp,-12
8110d950:	de00012e 	bgeu	sp,et,8110d958 <uliSyncReadStatus+0xc>
8110d954:	003b68fa 	trap	3
8110d958:	dfc00215 	stw	ra,8(sp)
8110d95c:	df000115 	stw	fp,4(sp)
8110d960:	df000104 	addi	fp,sp,4
	alt_u32 aux;

	aux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110d964:	0009883a 	mov	r4,zero
8110d968:	110d9e40 	call	8110d9e4 <uliSyncReadReg>
8110d96c:	e0bfff15 	stw	r2,-4(fp)
	return aux;
8110d970:	e0bfff17 	ldw	r2,-4(fp)
}
8110d974:	e037883a 	mov	sp,fp
8110d978:	dfc00117 	ldw	ra,4(sp)
8110d97c:	df000017 	ldw	fp,0(sp)
8110d980:	dec00204 	addi	sp,sp,8
8110d984:	f800283a 	ret

8110d988 <bSyncWriteReg>:
 * @param [in] alt_u32 offset
 * @param [in] alt_u32 value
 *
 * @retval TRUE -> success
 */
bool bSyncWriteReg(alt_u32 uliOffset, alt_u32 uliValue) {
8110d988:	defffc04 	addi	sp,sp,-16
8110d98c:	de00012e 	bgeu	sp,et,8110d994 <bSyncWriteReg+0xc>
8110d990:	003b68fa 	trap	3
8110d994:	df000315 	stw	fp,12(sp)
8110d998:	df000304 	addi	fp,sp,12
8110d99c:	e13ffe15 	stw	r4,-8(fp)
8110d9a0:	e17fff15 	stw	r5,-4(fp)
	alt_u32 *p_addr = (alt_u32 *) SYNC_BASE_ADDR;
8110d9a4:	00a00034 	movhi	r2,32768
8110d9a8:	10810004 	addi	r2,r2,1024
8110d9ac:	e0bffd15 	stw	r2,-12(fp)
	*(p_addr + uliOffset) = uliValue;
8110d9b0:	e0bffe17 	ldw	r2,-8(fp)
8110d9b4:	1085883a 	add	r2,r2,r2
8110d9b8:	1085883a 	add	r2,r2,r2
8110d9bc:	1007883a 	mov	r3,r2
8110d9c0:	e0bffd17 	ldw	r2,-12(fp)
8110d9c4:	10c5883a 	add	r2,r2,r3
8110d9c8:	e0ffff17 	ldw	r3,-4(fp)
8110d9cc:	10c00015 	stw	r3,0(r2)
	return TRUE;
8110d9d0:	00800044 	movi	r2,1
}
8110d9d4:	e037883a 	mov	sp,fp
8110d9d8:	df000017 	ldw	fp,0(sp)
8110d9dc:	dec00104 	addi	sp,sp,4
8110d9e0:	f800283a 	ret

8110d9e4 <uliSyncReadReg>:
 *
 * @param [in] alt_u32 offset
 *
 * @retval alt_u32 value -> reg
 */
alt_u32 uliSyncReadReg(alt_u32 uliOffset) {
8110d9e4:	defffc04 	addi	sp,sp,-16
8110d9e8:	de00012e 	bgeu	sp,et,8110d9f0 <uliSyncReadReg+0xc>
8110d9ec:	003b68fa 	trap	3
8110d9f0:	df000315 	stw	fp,12(sp)
8110d9f4:	df000304 	addi	fp,sp,12
8110d9f8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 value;

	alt_u32 *p_addr = (alt_u32 *) SYNC_BASE_ADDR;
8110d9fc:	00a00034 	movhi	r2,32768
8110da00:	10810004 	addi	r2,r2,1024
8110da04:	e0bffd15 	stw	r2,-12(fp)
	value = *(p_addr + uliOffset);
8110da08:	e0bfff17 	ldw	r2,-4(fp)
8110da0c:	1085883a 	add	r2,r2,r2
8110da10:	1085883a 	add	r2,r2,r2
8110da14:	1007883a 	mov	r3,r2
8110da18:	e0bffd17 	ldw	r2,-12(fp)
8110da1c:	10c5883a 	add	r2,r2,r3
8110da20:	10800017 	ldw	r2,0(r2)
8110da24:	e0bffe15 	stw	r2,-8(fp)
	return value;
8110da28:	e0bffe17 	ldw	r2,-8(fp)
}
8110da2c:	e037883a 	mov	sp,fp
8110da30:	df000017 	ldw	fp,0(sp)
8110da34:	dec00104 	addi	sp,sp,4
8110da38:	f800283a 	ret

8110da3c <uliPerCalcPeriodMs>:

/*
 * Return the necessary PER value for a
 * Sync Signal period in usiPeriodMs ms.
 */
alt_u32 uliPerCalcPeriodMs(alt_u16 usiPeriodMs) {
8110da3c:	defffc04 	addi	sp,sp,-16
8110da40:	de00012e 	bgeu	sp,et,8110da48 <uliPerCalcPeriodMs+0xc>
8110da44:	003b68fa 	trap	3
8110da48:	dfc00315 	stw	ra,12(sp)
8110da4c:	df000215 	stw	fp,8(sp)
8110da50:	df000204 	addi	fp,sp,8
8110da54:	2005883a 	mov	r2,r4
8110da58:	e0bfff0d 	sth	r2,-4(fp)
	 * Period[ms] / 20e-6 = Period[ms] * 5e+4
	 * PER = Period[ms] * 5e+4
	 */

	alt_u32 uliPer;
	uliPer = usiPeriodMs * 5e+4;
8110da5c:	e0bfff0b 	ldhu	r2,-4(fp)
8110da60:	1009883a 	mov	r4,r2
8110da64:	1120a400 	call	81120a40 <__floatsidf>
8110da68:	1011883a 	mov	r8,r2
8110da6c:	1813883a 	mov	r9,r3
8110da70:	000d883a 	mov	r6,zero
8110da74:	01d03a34 	movhi	r7,16616
8110da78:	39da8004 	addi	r7,r7,27136
8110da7c:	4009883a 	mov	r4,r8
8110da80:	480b883a 	mov	r5,r9
8110da84:	111f99c0 	call	8111f99c <__muldf3>
8110da88:	1009883a 	mov	r4,r2
8110da8c:	180b883a 	mov	r5,r3
8110da90:	2005883a 	mov	r2,r4
8110da94:	2807883a 	mov	r3,r5
8110da98:	1009883a 	mov	r4,r2
8110da9c:	180b883a 	mov	r5,r3
8110daa0:	111edd40 	call	8111edd4 <__fixunsdfsi>
8110daa4:	e0bffe15 	stw	r2,-8(fp)

	return uliPer;
8110daa8:	e0bffe17 	ldw	r2,-8(fp)
}
8110daac:	e037883a 	mov	sp,fp
8110dab0:	dfc00117 	ldw	ra,4(sp)
8110dab4:	df000017 	ldw	fp,0(sp)
8110dab8:	dec00204 	addi	sp,sp,8
8110dabc:	f800283a 	ret

8110dac0 <vDataControlTask>:


#include "data_control_task.h"

/* 0% Ready! */
void vDataControlTask(void *task_data) {
8110dac0:	defff804 	addi	sp,sp,-32
8110dac4:	de00012e 	bgeu	sp,et,8110dacc <vDataControlTask+0xc>
8110dac8:	003b68fa 	trap	3
8110dacc:	dfc00715 	stw	ra,28(sp)
8110dad0:	df000615 	stw	fp,24(sp)
8110dad4:	df000604 	addi	fp,sp,24
8110dad8:	e13ffd15 	stw	r4,-12(fp)
	tQMask uiCmdDTC;
	INT8U error_code;
	TNData_Control *pxDataC;


	pxDataC = (TNData_Control *) task_data;
8110dadc:	e0bffd17 	ldw	r2,-12(fp)
8110dae0:	e0bffa15 	stw	r2,-24(fp)

	#ifdef DEBUG_ON
        debug(fp,"Data Controller Task. (Task on)\n");
8110dae4:	d0a06217 	ldw	r2,-32376(gp)
8110dae8:	100f883a 	mov	r7,r2
8110daec:	01800804 	movi	r6,32
8110daf0:	01400044 	movi	r5,1
8110daf4:	01204574 	movhi	r4,33045
8110daf8:	212ff804 	addi	r4,r4,-16416
8110dafc:	11216400 	call	81121640 <fwrite>
    #endif

    pxDataC->bUpdateComplete = TRUE;
8110db00:	e0bffa17 	ldw	r2,-24(fp)
8110db04:	00c00044 	movi	r3,1
8110db08:	10c00515 	stw	r3,20(r2)

    error_code = OSQFlush(xQMaskDataCtrl);
8110db0c:	d0a05f17 	ldw	r2,-32388(gp)
8110db10:	1009883a 	mov	r4,r2
8110db14:	113d5080 	call	8113d508 <OSQFlush>
8110db18:	e0bffc05 	stb	r2,-16(fp)
	if ( error_code != OS_NO_ERR ) {
8110db1c:	e0bffc03 	ldbu	r2,-16(fp)
8110db20:	10803fcc 	andi	r2,r2,255
8110db24:	10000126 	beq	r2,zero,8110db2c <vDataControlTask+0x6c>
		vFailFlushQueueData();
8110db28:	111d1b40 	call	8111d1b4 <vFailFlushQueueData>
	}

	for (;;) {

		uiCmdDTC.ulWord = (unsigned int)OSQPend(xQMaskCMDNDataCtrlTBL, 0, &error_code); /* Blocking operation */
8110db2c:	e0bffc04 	addi	r2,fp,-16
8110db30:	100d883a 	mov	r6,r2
8110db34:	000b883a 	mov	r5,zero
8110db38:	012045b4 	movhi	r4,33046
8110db3c:	212dbf04 	addi	r4,r4,-18692
8110db40:	113d5c80 	call	8113d5c8 <OSQPend>
8110db44:	e0bffb15 	stw	r2,-20(fp)
			} else {

				/* todo: For now, do nothing */
			}
		}
		OSTimeDlyHMSM(0, 0, 5, 0); /*todo:Tirar depois do debug*/
8110db48:	000f883a 	mov	r7,zero
8110db4c:	01800144 	movi	r6,5
8110db50:	000b883a 	mov	r5,zero
8110db54:	0009883a 	mov	r4,zero
8110db58:	11404580 	call	81140458 <OSTimeDlyHMSM>
	}
8110db5c:	003ff306 	br	8110db2c <__reset+0xfb0edb2c>

8110db60 <vFeeTask>:

const char *cTemp[64];
unsigned char ucIterationSide;


void vFeeTask(void *task_data) {
8110db60:	deffef04 	addi	sp,sp,-68
8110db64:	de00012e 	bgeu	sp,et,8110db6c <vFeeTask+0xc>
8110db68:	003b68fa 	trap	3
8110db6c:	dfc01015 	stw	ra,64(sp)
8110db70:	df000f15 	stw	fp,60(sp)
8110db74:	df000f04 	addi	fp,sp,60
8110db78:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess = FALSE;
8110db7c:	e03ffb15 	stw	zero,-20(fp)
	alt_u16 *pusiHK;
	alt_u32 *pusiHK32;
	unsigned char ucIL;


	pxNFee = ( TNFee * ) task_data;
8110db80:	e0bfff17 	ldw	r2,-4(fp)
8110db84:	d0a05315 	stw	r2,-32436(gp)

	#ifdef DEBUG_ON
		fprintf(fp,"NFEE %hhu Task. (Task on)\n", pxNFee->ucId);
8110db88:	d0e06217 	ldw	r3,-32376(gp)
8110db8c:	d0a05317 	ldw	r2,-32436(gp)
8110db90:	10800003 	ldbu	r2,0(r2)
8110db94:	10803fcc 	andi	r2,r2,255
8110db98:	100d883a 	mov	r6,r2
8110db9c:	01604574 	movhi	r5,33045
8110dba0:	29700104 	addi	r5,r5,-16380
8110dba4:	1809883a 	mov	r4,r3
8110dba8:	1120fa40 	call	81120fa4 <fprintf>
	#endif

	#ifdef DEBUG_ON
		vPrintConsoleNFee( pxNFee );
8110dbac:	d0a05317 	ldw	r2,-32436(gp)
8110dbb0:	1009883a 	mov	r4,r2
8110dbb4:	1110af80 	call	81110af8 <vPrintConsoleNFee>
	#endif


	for(;;){

		switch ( pxNFee->xControl.eMode ) {
8110dbb8:	d0a05317 	ldw	r2,-32436(gp)
8110dbbc:	10802c17 	ldw	r2,176(r2)
8110dbc0:	10c00368 	cmpgeui	r3,r2,13
8110dbc4:	1805791e 	bne	r3,zero,8110f1ac <vFeeTask+0x164c>
8110dbc8:	100690ba 	slli	r3,r2,2
8110dbcc:	00a04474 	movhi	r2,33041
8110dbd0:	10b6f804 	addi	r2,r2,-9248
8110dbd4:	1885883a 	add	r2,r3,r2
8110dbd8:	10800017 	ldw	r2,0(r2)
8110dbdc:	1000683a 	jmp	r2
8110dbe0:	8110dc14 	ori	r4,r16,17264
8110dbe4:	8110e394 	ori	r4,r16,17294
8110dbe8:	8110e418 	cmpnei	r4,r16,17296
8110dbec:	8110e578 	rdprs	r4,r16,17301
8110dbf0:	8110ed28 	cmpgeui	r4,r16,17332
8110dbf4:	8110e1cc 	andi	r4,r16,17287
8110dbf8:	8110e428 	cmpgeui	r4,r16,17296
8110dbfc:	8110ec90 	cmplti	r4,r16,17330
8110dc00:	8110f1ac 	andhi	r4,r16,17350
8110dc04:	8110f1ac 	andhi	r4,r16,17350
8110dc08:	8110e5fc 	xorhi	r4,r16,17303
8110dc0c:	8110f078 	rdprs	r4,r16,17345
8110dc10:	8110f104 	addi	r4,r16,17348
			case sFeeInit:

				error_code = OSQFlush( xFeeQ[ pxNFee->ucId ] );
8110dc14:	d0a05317 	ldw	r2,-32436(gp)
8110dc18:	10800003 	ldbu	r2,0(r2)
8110dc1c:	10803fcc 	andi	r2,r2,255
8110dc20:	1085883a 	add	r2,r2,r2
8110dc24:	1087883a 	add	r3,r2,r2
8110dc28:	d0a06a04 	addi	r2,gp,-32344
8110dc2c:	1885883a 	add	r2,r3,r2
8110dc30:	10800017 	ldw	r2,0(r2)
8110dc34:	1009883a 	mov	r4,r2
8110dc38:	113d5080 	call	8113d508 <OSQFlush>
8110dc3c:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110dc40:	e0bffd03 	ldbu	r2,-12(fp)
8110dc44:	10803fcc 	andi	r2,r2,255
8110dc48:	10000126 	beq	r2,zero,8110dc50 <vFeeTask+0xf0>
					vFailFlushNFEEQueue();
8110dc4c:	111d24c0 	call	8111d24c <vFailFlushNFEEQueue>
				}

				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110dc50:	d0a05317 	ldw	r2,-32436(gp)
8110dc54:	10800003 	ldbu	r2,0(r2)
8110dc58:	10803fcc 	andi	r2,r2,255
8110dc5c:	1085883a 	add	r2,r2,r2
8110dc60:	1087883a 	add	r3,r2,r2
8110dc64:	d0a05c04 	addi	r2,gp,-32400
8110dc68:	1885883a 	add	r2,r3,r2
8110dc6c:	10800017 	ldw	r2,0(r2)
8110dc70:	1009883a 	mov	r4,r2
8110dc74:	113d5080 	call	8113d508 <OSQFlush>
8110dc78:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110dc7c:	e0bffd03 	ldbu	r2,-12(fp)
8110dc80:	10803fcc 	andi	r2,r2,255
8110dc84:	10000126 	beq	r2,zero,8110dc8c <vFeeTask+0x12c>
					vFailFlushNFEEQueue();
8110dc88:	111d24c0 	call	8111d24c <vFailFlushNFEEQueue>
				}				

				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110dc8c:	d0a05317 	ldw	r2,-32436(gp)
8110dc90:	10803304 	addi	r2,r2,204
8110dc94:	1009883a 	mov	r4,r2
8110dc98:	1104a680 	call	81104a68 <bDpktGetPacketConfig>
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdXSize = pxNFee->xCcdInfo.usiHalfWidth + pxNFee->xCcdInfo.usiSPrescanN + pxNFee->xCcdInfo.usiSOverscanN;
8110dc9c:	d0a05317 	ldw	r2,-32436(gp)
8110dca0:	d0e05317 	ldw	r3,-32436(gp)
8110dca4:	1900308b 	ldhu	r4,194(r3)
8110dca8:	d0e05317 	ldw	r3,-32436(gp)
8110dcac:	18c02f0b 	ldhu	r3,188(r3)
8110dcb0:	20c7883a 	add	r3,r4,r3
8110dcb4:	1809883a 	mov	r4,r3
8110dcb8:	d0e05317 	ldw	r3,-32436(gp)
8110dcbc:	18c02f8b 	ldhu	r3,190(r3)
8110dcc0:	20c7883a 	add	r3,r4,r3
8110dcc4:	10c0340d 	sth	r3,208(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdYSize = pxNFee->xCcdInfo.usiHeight + pxNFee->xCcdInfo.usiOLN;
8110dcc8:	d0a05317 	ldw	r2,-32436(gp)
8110dccc:	d0e05317 	ldw	r3,-32436(gp)
8110dcd0:	1900310b 	ldhu	r4,196(r3)
8110dcd4:	d0e05317 	ldw	r3,-32436(gp)
8110dcd8:	18c0300b 	ldhu	r3,192(r3)
8110dcdc:	20c7883a 	add	r3,r4,r3
8110dce0:	10c0348d 	sth	r3,210(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiDataYSize = pxNFee->xCcdInfo.usiHeight;
8110dce4:	d0a05317 	ldw	r2,-32436(gp)
8110dce8:	d0e05317 	ldw	r3,-32436(gp)
8110dcec:	18c0310b 	ldhu	r3,196(r3)
8110dcf0:	10c0350d 	sth	r3,212(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiOverscanYSize = pxNFee->xCcdInfo.usiOLN;
8110dcf4:	d0a05317 	ldw	r2,-32436(gp)
8110dcf8:	d0e05317 	ldw	r3,-32436(gp)
8110dcfc:	18c0300b 	ldhu	r3,192(r3)
8110dd00:	10c0358d 	sth	r3,214(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiPacketLength = 32768;
8110dd04:	d0a05317 	ldw	r2,-32436(gp)
8110dd08:	00e00004 	movi	r3,-32768
8110dd0c:	10c0360d 	sth	r3,216(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber = 0; /* 32 KB */
8110dd10:	d0a05317 	ldw	r2,-32436(gp)
8110dd14:	100036c5 	stb	zero,219(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktFullImagePattern; /* todo:No esquecer de atualizar para o ENUM  */
8110dd18:	d0a05317 	ldw	r2,-32436(gp)
8110dd1c:	00c00044 	movi	r3,1
8110dd20:	10c03685 	stb	r3,218(r2)
				bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110dd24:	d0a05317 	ldw	r2,-32436(gp)
8110dd28:	10803304 	addi	r2,r2,204
8110dd2c:	1009883a 	mov	r4,r2
8110dd30:	110483c0 	call	8110483c <bDpktSetPacketConfig>

				bRmapGetRmapMemHKArea(&pxNFee->xChannel.xRmap);
8110dd34:	d0a05317 	ldw	r2,-32436(gp)
8110dd38:	10804304 	addi	r2,r2,268
8110dd3c:	1009883a 	mov	r4,r2
8110dd40:	11095340 	call	81109534 <bRmapGetRmapMemHKArea>
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodE = 0xFF00;
8110dd44:	d0a05317 	ldw	r2,-32436(gp)
8110dd48:	00ffc004 	movi	r3,-256
8110dd4c:	10c0690d 	sth	r3,420(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodF = 0xFF01;
8110dd50:	d0a05317 	ldw	r2,-32436(gp)
8110dd54:	00ffc044 	movi	r3,-255
8110dd58:	10c0698d 	sth	r3,422(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VrdMon = 0xFF02;
8110dd5c:	d0a05317 	ldw	r2,-32436(gp)
8110dd60:	00ffc084 	movi	r3,-254
8110dd64:	10c06a0d 	sth	r3,424(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2VodE = 0xFF03;
8110dd68:	d0a05317 	ldw	r2,-32436(gp)
8110dd6c:	00ffc0c4 	movi	r3,-253
8110dd70:	10c06a8d 	sth	r3,426(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2VodF = 0xFF04;
8110dd74:	d0a05317 	ldw	r2,-32436(gp)
8110dd78:	00ffc104 	movi	r3,-252
8110dd7c:	10c06b0d 	sth	r3,428(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2VrdMon = 0xFF05;
8110dd80:	d0a05317 	ldw	r2,-32436(gp)
8110dd84:	00ffc144 	movi	r3,-251
8110dd88:	10c06b8d 	sth	r3,430(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3VodE = 0xFF06;
8110dd8c:	d0a05317 	ldw	r2,-32436(gp)
8110dd90:	00ffc184 	movi	r3,-250
8110dd94:	10c06c0d 	sth	r3,432(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3VodF = 0xFF07;
8110dd98:	d0a05317 	ldw	r2,-32436(gp)
8110dd9c:	00ffc1c4 	movi	r3,-249
8110dda0:	10c06c8d 	sth	r3,434(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3VrdMon = 0xFF08;
8110dda4:	d0a05317 	ldw	r2,-32436(gp)
8110dda8:	00ffc204 	movi	r3,-248
8110ddac:	10c06d0d 	sth	r3,436(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4VodE  = 0xFF09;
8110ddb0:	d0a05317 	ldw	r2,-32436(gp)
8110ddb4:	00ffc244 	movi	r3,-247
8110ddb8:	10c06d8d 	sth	r3,438(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4VodF = 0xFF0A;
8110ddbc:	d0a05317 	ldw	r2,-32436(gp)
8110ddc0:	00ffc284 	movi	r3,-246
8110ddc4:	10c06e0d 	sth	r3,440(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4VrdMon = 0xFF0B;
8110ddc8:	d0a05317 	ldw	r2,-32436(gp)
8110ddcc:	00ffc2c4 	movi	r3,-245
8110ddd0:	10c06e8d 	sth	r3,442(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVccd = 0xFF0C;
8110ddd4:	d0a05317 	ldw	r2,-32436(gp)
8110ddd8:	00ffc304 	movi	r3,-244
8110dddc:	10c06f0d 	sth	r3,444(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVrclk = 0xFF0D;
8110dde0:	d0a05317 	ldw	r2,-32436(gp)
8110dde4:	00ffc344 	movi	r3,-243
8110dde8:	10c06f8d 	sth	r3,446(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkViclk = 0xFF0E;
8110ddec:	d0a05317 	ldw	r2,-32436(gp)
8110ddf0:	00ffc384 	movi	r3,-242
8110ddf4:	10c0700d 	sth	r3,448(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVrclkLow = 0xFF0F;
8110ddf8:	d0a05317 	ldw	r2,-32436(gp)
8110ddfc:	00ffc3c4 	movi	r3,-241
8110de00:	10c0708d 	sth	r3,450(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk5vbPos = 0xFF10;
8110de04:	d0a05317 	ldw	r2,-32436(gp)
8110de08:	00ffc404 	movi	r3,-240
8110de0c:	10c0710d 	sth	r3,452(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk5vbNeg = 0xFF11;
8110de10:	d0a05317 	ldw	r2,-32436(gp)
8110de14:	00ffc444 	movi	r3,-239
8110de18:	10c0718d 	sth	r3,454(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk33vbPos = 0xFF12;
8110de1c:	d0a05317 	ldw	r2,-32436(gp)
8110de20:	00ffc484 	movi	r3,-238
8110de24:	10c0720d 	sth	r3,456(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk25vaPos = 0xFF13;
8110de28:	d0a05317 	ldw	r2,-32436(gp)
8110de2c:	00ffc4c4 	movi	r3,-237
8110de30:	10c0728d 	sth	r3,458(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk33vdPos = 0xFF14;
8110de34:	d0a05317 	ldw	r2,-32436(gp)
8110de38:	00ffc504 	movi	r3,-236
8110de3c:	10c0730d 	sth	r3,460(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk25vdPos = 0xFF15;
8110de40:	d0a05317 	ldw	r2,-32436(gp)
8110de44:	00ffc544 	movi	r3,-235
8110de48:	10c0738d 	sth	r3,462(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk15vdPos = 0xFF16;
8110de4c:	d0a05317 	ldw	r2,-32436(gp)
8110de50:	00ffc584 	movi	r3,-234
8110de54:	10c0740d 	sth	r3,464(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk5vref = 0xFF17;
8110de58:	d0a05317 	ldw	r2,-32436(gp)
8110de5c:	00ffc5c4 	movi	r3,-233
8110de60:	10c0748d 	sth	r3,466(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVccdPosRaw = 0xFF18;
8110de64:	d0a05317 	ldw	r2,-32436(gp)
8110de68:	00ffc604 	movi	r3,-232
8110de6c:	10c0750d 	sth	r3,468(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVclkPosRaw = 0xFF19;
8110de70:	d0a05317 	ldw	r2,-32436(gp)
8110de74:	00ffc644 	movi	r3,-231
8110de78:	10c0758d 	sth	r3,470(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVan1PosRaw = 0xFF1A;
8110de7c:	d0a05317 	ldw	r2,-32436(gp)
8110de80:	00ffc684 	movi	r3,-230
8110de84:	10c0760d 	sth	r3,472(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVan3NegRaw = 0xFF1B;
8110de88:	d0a05317 	ldw	r2,-32436(gp)
8110de8c:	00ffc6c4 	movi	r3,-229
8110de90:	10c0768d 	sth	r3,474(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVan2PosRaw = 0xFF1C;
8110de94:	d0a05317 	ldw	r2,-32436(gp)
8110de98:	00ffc704 	movi	r3,-228
8110de9c:	10c0770d 	sth	r3,476(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVdigFpgaRaw = 0xFF1D;
8110dea0:	d0a05317 	ldw	r2,-32436(gp)
8110dea4:	00ffc744 	movi	r3,-227
8110dea8:	10c0778d 	sth	r3,478(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVdigSpwRaw = 0xFF1E;
8110deac:	d0a05317 	ldw	r2,-32436(gp)
8110deb0:	00ffc784 	movi	r3,-226
8110deb4:	10c0780d 	sth	r3,480(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkViclkLow = 0xFF1F;
8110deb8:	d0a05317 	ldw	r2,-32436(gp)
8110debc:	00ffc7c4 	movi	r3,-225
8110dec0:	10c0788d 	sth	r3,482(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkAdcTempAE = 0xFF20;
8110dec4:	d0a05317 	ldw	r2,-32436(gp)
8110dec8:	00ffc804 	movi	r3,-224
8110decc:	10c0790d 	sth	r3,484(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkAdcTempAF = 0xFF21;
8110ded0:	d0a05317 	ldw	r2,-32436(gp)
8110ded4:	00ffc844 	movi	r3,-223
8110ded8:	10c0798d 	sth	r3,486(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1Temp = 0xFF22;
8110dedc:	d0a05317 	ldw	r2,-32436(gp)
8110dee0:	00ffc884 	movi	r3,-222
8110dee4:	10c07a0d 	sth	r3,488(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2Temp = 0xFF23;
8110dee8:	d0a05317 	ldw	r2,-32436(gp)
8110deec:	00ffc8c4 	movi	r3,-221
8110def0:	10c07a8d 	sth	r3,490(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3Temp = 0xFF24;
8110def4:	d0a05317 	ldw	r2,-32436(gp)
8110def8:	00ffc904 	movi	r3,-220
8110defc:	10c07b0d 	sth	r3,492(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4Temp = 0xFF25;
8110df00:	d0a05317 	ldw	r2,-32436(gp)
8110df04:	00ffc944 	movi	r3,-219
8110df08:	10c07b8d 	sth	r3,494(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkWp605Spare = 0xFF26;
8110df0c:	d0a05317 	ldw	r2,-32436(gp)
8110df10:	00ffc984 	movi	r3,-218
8110df14:	10c07c0d 	sth	r3,496(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA0 = 0xFF27;
8110df18:	d0a05317 	ldw	r2,-32436(gp)
8110df1c:	00ffc9c4 	movi	r3,-217
8110df20:	10c07c8d 	sth	r3,498(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA1 = 0xFF28;
8110df24:	d0a05317 	ldw	r2,-32436(gp)
8110df28:	00ffca04 	movi	r3,-216
8110df2c:	10c07d0d 	sth	r3,500(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA2 = 0xFF29;
8110df30:	d0a05317 	ldw	r2,-32436(gp)
8110df34:	00ffca44 	movi	r3,-215
8110df38:	10c07d8d 	sth	r3,502(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA3 = 0xFF2A;
8110df3c:	d0a05317 	ldw	r2,-32436(gp)
8110df40:	00ffca84 	movi	r3,-214
8110df44:	10c07e0d 	sth	r3,504(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA4 = 0xFF2B;
8110df48:	d0a05317 	ldw	r2,-32436(gp)
8110df4c:	00ffcac4 	movi	r3,-213
8110df50:	10c07e8d 	sth	r3,506(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA5 = 0xFF2C;
8110df54:	d0a05317 	ldw	r2,-32436(gp)
8110df58:	00ffcb04 	movi	r3,-212
8110df5c:	10c07f0d 	sth	r3,508(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA6 = 0xFF2D;
8110df60:	d0a05317 	ldw	r2,-32436(gp)
8110df64:	00ffcb44 	movi	r3,-211
8110df68:	10c07f8d 	sth	r3,510(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA7 = 0xFF2E;
8110df6c:	d0a05317 	ldw	r2,-32436(gp)
8110df70:	00ffcb84 	movi	r3,-210
8110df74:	10c0800d 	sth	r3,512(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA8 = 0xFF2F;
8110df78:	d0a05317 	ldw	r2,-32436(gp)
8110df7c:	00ffcbc4 	movi	r3,-209
8110df80:	10c0808d 	sth	r3,514(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA9 = 0xFF30;
8110df84:	d0a05317 	ldw	r2,-32436(gp)
8110df88:	00ffcc04 	movi	r3,-208
8110df8c:	10c0810d 	sth	r3,516(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA10 = 0xFF31;
8110df90:	d0a05317 	ldw	r2,-32436(gp)
8110df94:	00ffcc44 	movi	r3,-207
8110df98:	10c0818d 	sth	r3,518(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA11 = 0xFF32;
8110df9c:	d0a05317 	ldw	r2,-32436(gp)
8110dfa0:	00ffcc84 	movi	r3,-206
8110dfa4:	10c0820d 	sth	r3,520(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA12 = 0xFF33;
8110dfa8:	d0a05317 	ldw	r2,-32436(gp)
8110dfac:	00ffccc4 	movi	r3,-205
8110dfb0:	10c0828d 	sth	r3,522(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA13 = 0xFF34;
8110dfb4:	d0a05317 	ldw	r2,-32436(gp)
8110dfb8:	00ffcd04 	movi	r3,-204
8110dfbc:	10c0830d 	sth	r3,524(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA14 = 0xFF35;
8110dfc0:	d0a05317 	ldw	r2,-32436(gp)
8110dfc4:	00ffcd44 	movi	r3,-203
8110dfc8:	10c0838d 	sth	r3,526(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA15 = 0xFF36;
8110dfcc:	d0a05317 	ldw	r2,-32436(gp)
8110dfd0:	00ffcd84 	movi	r3,-202
8110dfd4:	10c0840d 	sth	r3,528(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt0 = 0xFF37;
8110dfd8:	d0a05317 	ldw	r2,-32436(gp)
8110dfdc:	00ffcdc4 	movi	r3,-201
8110dfe0:	10c0848d 	sth	r3,530(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt1 = 0xFF38;
8110dfe4:	d0a05317 	ldw	r2,-32436(gp)
8110dfe8:	00ffce04 	movi	r3,-200
8110dfec:	10c0850d 	sth	r3,532(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt2 = 0xFF39;
8110dff0:	d0a05317 	ldw	r2,-32436(gp)
8110dff4:	00ffce44 	movi	r3,-199
8110dff8:	10c0858d 	sth	r3,534(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt3 = 0xFF3A;
8110dffc:	d0a05317 	ldw	r2,-32436(gp)
8110e000:	00ffce84 	movi	r3,-198
8110e004:	10c0860d 	sth	r3,536(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt4 = 0xFF3B;
8110e008:	d0a05317 	ldw	r2,-32436(gp)
8110e00c:	00ffcec4 	movi	r3,-197
8110e010:	10c0868d 	sth	r3,538(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt5 = 0xFF3C;
8110e014:	d0a05317 	ldw	r2,-32436(gp)
8110e018:	00ffcf04 	movi	r3,-196
8110e01c:	10c0870d 	sth	r3,540(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt6 = 0xFF3D;
8110e020:	d0a05317 	ldw	r2,-32436(gp)
8110e024:	00ffcf44 	movi	r3,-195
8110e028:	10c0878d 	sth	r3,542(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt7 = 0xFF3E;
8110e02c:	d0a05317 	ldw	r2,-32436(gp)
8110e030:	00ffcf84 	movi	r3,-194
8110e034:	10c0880d 	sth	r3,544(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiZeroHiresAmp = 0xFF3F;
8110e038:	d0a05317 	ldw	r2,-32436(gp)
8110e03c:	00ffcfc4 	movi	r3,-193
8110e040:	10c0888d 	sth	r3,546(r2)
				bRmapSetRmapMemHKArea(&pxNFee->xChannel.xRmap);
8110e044:	d0a05317 	ldw	r2,-32436(gp)
8110e048:	10804304 	addi	r2,r2,268
8110e04c:	1009883a 	mov	r4,r2
8110e050:	11084e80 	call	811084e8 <bRmapSetRmapMemHKArea>


				vLoadCtemp();
8110e054:	11116640 	call	81111664 <vLoadCtemp>

				bRmapGetRmapMemHKArea(&pxNFee->xChannel.xRmap);
8110e058:	d0a05317 	ldw	r2,-32436(gp)
8110e05c:	10804304 	addi	r2,r2,268
8110e060:	1009883a 	mov	r4,r2
8110e064:	11095340 	call	81109534 <bRmapGetRmapMemHKArea>
				pusiHK = &pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodE;
8110e068:	d0a05317 	ldw	r2,-32436(gp)
8110e06c:	10806904 	addi	r2,r2,420
8110e070:	e0bff915 	stw	r2,-28(fp)

				#ifdef DEBUG_ON
					fprintf(fp,"\n\n================= H  K ==================\n");
8110e074:	d0a06217 	ldw	r2,-32376(gp)
8110e078:	100f883a 	mov	r7,r2
8110e07c:	01800b04 	movi	r6,44
8110e080:	01400044 	movi	r5,1
8110e084:	01204574 	movhi	r4,33045
8110e088:	21300804 	addi	r4,r4,-16352
8110e08c:	11216400 	call	81121640 <fwrite>

					for (ucIL = 0; ucIL < 64; ++ucIL) {
8110e090:	e03ffa05 	stb	zero,-24(fp)
8110e094:	00001606 	br	8110e0f0 <vFeeTask+0x590>
						fprintf(fp,"   - %s = %04x \n", cTemp[ucIL] , *pusiHK);
8110e098:	d1206217 	ldw	r4,-32376(gp)
8110e09c:	e0fffa03 	ldbu	r3,-24(fp)
8110e0a0:	00a04574 	movhi	r2,33045
8110e0a4:	108d6b04 	addi	r2,r2,13740
8110e0a8:	18c7883a 	add	r3,r3,r3
8110e0ac:	18c7883a 	add	r3,r3,r3
8110e0b0:	10c5883a 	add	r2,r2,r3
8110e0b4:	10c00017 	ldw	r3,0(r2)
8110e0b8:	e0bff917 	ldw	r2,-28(fp)
8110e0bc:	1080000b 	ldhu	r2,0(r2)
8110e0c0:	10bfffcc 	andi	r2,r2,65535
8110e0c4:	100f883a 	mov	r7,r2
8110e0c8:	180d883a 	mov	r6,r3
8110e0cc:	01604574 	movhi	r5,33045
8110e0d0:	29701404 	addi	r5,r5,-16304
8110e0d4:	1120fa40 	call	81120fa4 <fprintf>
						pusiHK++;
8110e0d8:	e0bff917 	ldw	r2,-28(fp)
8110e0dc:	10800084 	addi	r2,r2,2
8110e0e0:	e0bff915 	stw	r2,-28(fp)
				pusiHK = &pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodE;

				#ifdef DEBUG_ON
					fprintf(fp,"\n\n================= H  K ==================\n");

					for (ucIL = 0; ucIL < 64; ++ucIL) {
8110e0e4:	e0bffa03 	ldbu	r2,-24(fp)
8110e0e8:	10800044 	addi	r2,r2,1
8110e0ec:	e0bffa05 	stb	r2,-24(fp)
8110e0f0:	e0bffa03 	ldbu	r2,-24(fp)
8110e0f4:	10801030 	cmpltui	r2,r2,64
8110e0f8:	103fe71e 	bne	r2,zero,8110e098 <__reset+0xfb0ee098>
						fprintf(fp,"   - %s = %04x \n", cTemp[ucIL] , *pusiHK);
						pusiHK++;
					}
					fprintf(fp,"\n================= H  K ==================\n\n");
8110e0fc:	d0a06217 	ldw	r2,-32376(gp)
8110e100:	100f883a 	mov	r7,r2
8110e104:	01800b04 	movi	r6,44
8110e108:	01400044 	movi	r5,1
8110e10c:	01204574 	movhi	r4,33045
8110e110:	21301904 	addi	r4,r4,-16284
8110e114:	11216400 	call	81121640 <fwrite>
				#endif

				/* Change the configuration */
				bRmapGetCodecConfig( &pxNFee->xChannel.xRmap );
8110e118:	d0a05317 	ldw	r2,-32436(gp)
8110e11c:	10804304 	addi	r2,r2,268
8110e120:	1009883a 	mov	r4,r2
8110e124:	1107b480 	call	81107b48 <bRmapGetCodecConfig>
				pxNFee->xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char) xDefaults.ucRmapKey ;
8110e128:	d0e05317 	ldw	r3,-32436(gp)
8110e12c:	00a045b4 	movhi	r2,33046
8110e130:	1099c904 	addi	r2,r2,26404
8110e134:	10800c0b 	ldhu	r2,48(r2)
8110e138:	18804405 	stb	r2,272(r3)
				pxNFee->xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char) xDefaults.ucLogicalAddr;
8110e13c:	d0e05317 	ldw	r3,-32436(gp)
8110e140:	00a045b4 	movhi	r2,33046
8110e144:	1099c904 	addi	r2,r2,26404
8110e148:	10800c8b 	ldhu	r2,50(r2)
8110e14c:	18804445 	stb	r2,273(r3)
				bRmapSetCodecConfig( &pxNFee->xChannel.xRmap );
8110e150:	d0a05317 	ldw	r2,-32436(gp)
8110e154:	10804304 	addi	r2,r2,268
8110e158:	1009883a 	mov	r4,r2
8110e15c:	1107a700 	call	81107a70 <bRmapSetCodecConfig>

				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task. RMAP KEY = %hu\n", xDefaults.ucRmapKey );
8110e160:	d0e06217 	ldw	r3,-32376(gp)
8110e164:	00a045b4 	movhi	r2,33046
8110e168:	1099c904 	addi	r2,r2,26404
8110e16c:	10800c0b 	ldhu	r2,48(r2)
8110e170:	10bfffcc 	andi	r2,r2,65535
8110e174:	100d883a 	mov	r6,r2
8110e178:	01604574 	movhi	r5,33045
8110e17c:	29702504 	addi	r5,r5,-16236
8110e180:	1809883a 	mov	r4,r3
8110e184:	1120fa40 	call	81120fa4 <fprintf>
					fprintf(fp,"NFEE %hhu Task. Log. Addr. = %hu \n", xDefaults.ucLogicalAddr);
8110e188:	d0e06217 	ldw	r3,-32376(gp)
8110e18c:	00a045b4 	movhi	r2,33046
8110e190:	1099c904 	addi	r2,r2,26404
8110e194:	10800c8b 	ldhu	r2,50(r2)
8110e198:	10bfffcc 	andi	r2,r2,65535
8110e19c:	100d883a 	mov	r6,r2
8110e1a0:	01604574 	movhi	r5,33045
8110e1a4:	29702d04 	addi	r5,r5,-16204
8110e1a8:	1809883a 	mov	r4,r3
8110e1ac:	1120fa40 	call	81120fa4 <fprintf>
				#endif

				pxNFee->xControl.eMode = sToFeeConfig;
8110e1b0:	d0a05317 	ldw	r2,-32436(gp)
8110e1b4:	00c00144 	movi	r3,5
8110e1b8:	10c02c15 	stw	r3,176(r2)
				ucIterationSide = pxNFee->xControl.eSide;
8110e1bc:	d0a05317 	ldw	r2,-32436(gp)
8110e1c0:	10802e17 	ldw	r2,184(r2)
8110e1c4:	d0a05605 	stb	r2,-32424(gp)

				break;
8110e1c8:	00040606 	br	8110f1e4 <vFeeTask+0x1684>
			case sToFeeConfig: /* Transition */

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8110e1cc:	d0a05317 	ldw	r2,-32436(gp)
8110e1d0:	10804304 	addi	r2,r2,268
8110e1d4:	1009883a 	mov	r4,r2
8110e1d8:	11081800 	call	81108180 <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x06; /*Off*/
8110e1dc:	d0a05317 	ldw	r2,-32436(gp)
8110e1e0:	00c00184 	movi	r3,6
8110e1e4:	10c06615 	stw	r3,408(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8110e1e8:	d0a05317 	ldw	r2,-32436(gp)
8110e1ec:	10804304 	addi	r2,r2,268
8110e1f0:	1009883a 	mov	r4,r2
8110e1f4:	1107e940 	call	81107e94 <bRmapSetMemConfigArea>

				/* Disable the link SPW */
				bDisableSPWChannel( &pxNFee->xChannel.xSpacewire );
8110e1f8:	d0a05317 	ldw	r2,-32436(gp)
8110e1fc:	10808904 	addi	r2,r2,548
8110e200:	1009883a 	mov	r4,r2
8110e204:	11107fc0 	call	811107fc <bDisableSPWChannel>
				pxNFee->xControl.bChannelEnable = FALSE;
8110e208:	d0a05317 	ldw	r2,-32436(gp)
8110e20c:	10002615 	stw	zero,152(r2)

				/* Disable RMAP interrupts */
				bDisableRmapIRQ(&pxNFee->xChannel.xRmap, pxNFee->ucId);
8110e210:	d0a05317 	ldw	r2,-32436(gp)
8110e214:	10c04304 	addi	r3,r2,268
8110e218:	d0a05317 	ldw	r2,-32436(gp)
8110e21c:	10800003 	ldbu	r2,0(r2)
8110e220:	10803fcc 	andi	r2,r2,255
8110e224:	100b883a 	mov	r5,r2
8110e228:	1809883a 	mov	r4,r3
8110e22c:	11107500 	call	81110750 <bDisableRmapIRQ>

				/* Disable IRQ and clear the Double Buffer */
				bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110e230:	d0a05317 	ldw	r2,-32436(gp)
8110e234:	10803b04 	addi	r2,r2,236
8110e238:	1009883a 	mov	r4,r2
8110e23c:	111094c0 	call	8111094c <bDisAndClrDbBuffer>

				#ifdef DEBUG_ON
					fprintf(fp,"NFEE-%hu Task: Config Mode\n", pxNFee->ucId);
8110e240:	d0e06217 	ldw	r3,-32376(gp)
8110e244:	d0a05317 	ldw	r2,-32436(gp)
8110e248:	10800003 	ldbu	r2,0(r2)
8110e24c:	10803fcc 	andi	r2,r2,255
8110e250:	100d883a 	mov	r6,r2
8110e254:	01604574 	movhi	r5,33045
8110e258:	29703604 	addi	r5,r5,-16168
8110e25c:	1809883a 	mov	r4,r3
8110e260:	1120fa40 	call	81120fa4 <fprintf>
				#endif

				/* Complete when MUTEX were created */
				if ( pxNFee->xControl.bDMALocked == TRUE ) {
8110e264:	d0a05317 	ldw	r2,-32436(gp)
8110e268:	10802217 	ldw	r2,136(r2)
8110e26c:	10800058 	cmpnei	r2,r2,1
8110e270:	10000a1e 	bne	r2,zero,8110e29c <vFeeTask+0x73c>
					/* If is with the Mutex, should release */
					OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110e274:	e0fff303 	ldbu	r3,-52(fp)
8110e278:	00a045b4 	movhi	r2,33046
8110e27c:	108d0d04 	addi	r2,r2,13364
8110e280:	180690fa 	slli	r3,r3,3
8110e284:	10c5883a 	add	r2,r2,r3
8110e288:	10800017 	ldw	r2,0(r2)
8110e28c:	1009883a 	mov	r4,r2
8110e290:	113ca580 	call	8113ca58 <OSMutexPost>
					pxNFee->xControl.bDMALocked = FALSE;
8110e294:	d0a05317 	ldw	r2,-32436(gp)
8110e298:	10002215 	stw	zero,136(r2)
				}

				/* Cleaning other syncs that maybe in the queue */
				pxNFee->xControl.bWatingSync = FALSE;
8110e29c:	d0a05317 	ldw	r2,-32436(gp)
8110e2a0:	10002815 	stw	zero,160(r2)
				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110e2a4:	d0a05317 	ldw	r2,-32436(gp)
8110e2a8:	10800003 	ldbu	r2,0(r2)
8110e2ac:	10803fcc 	andi	r2,r2,255
8110e2b0:	1085883a 	add	r2,r2,r2
8110e2b4:	1087883a 	add	r3,r2,r2
8110e2b8:	d0a05c04 	addi	r2,gp,-32400
8110e2bc:	1885883a 	add	r2,r3,r2
8110e2c0:	10800017 	ldw	r2,0(r2)
8110e2c4:	1009883a 	mov	r4,r2
8110e2c8:	113d5080 	call	8113d508 <OSQFlush>
8110e2cc:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110e2d0:	e0bffd03 	ldbu	r2,-12(fp)
8110e2d4:	10803fcc 	andi	r2,r2,255
8110e2d8:	10000126 	beq	r2,zero,8110e2e0 <vFeeTask+0x780>
					vFailFlushNFEEQueue();
8110e2dc:	111d24c0 	call	8111d24c <vFailFlushNFEEQueue>
				}

				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
8110e2e0:	d0a05317 	ldw	r2,-32436(gp)
8110e2e4:	10800003 	ldbu	r2,0(r2)
8110e2e8:	10803fcc 	andi	r2,r2,255
8110e2ec:	100d883a 	mov	r6,r2
8110e2f0:	000b883a 	mov	r5,zero
8110e2f4:	01002044 	movi	r4,129
8110e2f8:	1110a540 	call	81110a54 <bSendGiveBackNFeeCtrl>

				/* End of simulation! Clear everything that is possible */
				pxNFee->xControl.bWatingSync = FALSE;
8110e2fc:	d0a05317 	ldw	r2,-32436(gp)
8110e300:	10002815 	stw	zero,160(r2)
				pxNFee->xControl.bSimulating = FALSE;
8110e304:	d0a05317 	ldw	r2,-32436(gp)
8110e308:	10002715 	stw	zero,156(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110e30c:	d0a05317 	ldw	r2,-32436(gp)
8110e310:	10002315 	stw	zero,140(r2)
				pxNFee->xControl.bEnabled = TRUE;
8110e314:	d0a05317 	ldw	r2,-32436(gp)
8110e318:	00c00044 	movi	r3,1
8110e31c:	10c02115 	stw	r3,132(r2)

				vResetMemCCDFEE(pxNFee);
8110e320:	d0a05317 	ldw	r2,-32436(gp)
8110e324:	1009883a 	mov	r4,r2
8110e328:	111d8800 	call	8111d880 <vResetMemCCDFEE>

				error_code = OSQFlush( xFeeQ[ pxNFee->ucId ] );
8110e32c:	d0a05317 	ldw	r2,-32436(gp)
8110e330:	10800003 	ldbu	r2,0(r2)
8110e334:	10803fcc 	andi	r2,r2,255
8110e338:	1085883a 	add	r2,r2,r2
8110e33c:	1087883a 	add	r3,r2,r2
8110e340:	d0a06a04 	addi	r2,gp,-32344
8110e344:	1885883a 	add	r2,r3,r2
8110e348:	10800017 	ldw	r2,0(r2)
8110e34c:	1009883a 	mov	r4,r2
8110e350:	113d5080 	call	8113d508 <OSQFlush>
8110e354:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110e358:	e0bffd03 	ldbu	r2,-12(fp)
8110e35c:	10803fcc 	andi	r2,r2,255
8110e360:	10000126 	beq	r2,zero,8110e368 <vFeeTask+0x808>
					vFailFlushNFEEQueue();
8110e364:	111d24c0 	call	8111d24c <vFailFlushNFEEQueue>
				}

				pxNFee->xControl.bWatingSync = TRUE;
8110e368:	d0a05317 	ldw	r2,-32436(gp)
8110e36c:	00c00044 	movi	r3,1
8110e370:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.eMode = sFeeConfig;
8110e374:	d0a05317 	ldw	r2,-32436(gp)
8110e378:	00c00044 	movi	r3,1
8110e37c:	10c02c15 	stw	r3,176(r2)
				ucIterationSide = pxNFee->xControl.eSide;
8110e380:	d0a05317 	ldw	r2,-32436(gp)
8110e384:	10802e17 	ldw	r2,184(r2)
8110e388:	d0a05605 	stb	r2,-32424(gp)
				bFinal = FALSE;
8110e38c:	e03ff815 	stw	zero,-32(fp)
				break;
8110e390:	00039406 	br	8110f1e4 <vFeeTask+0x1684>


			case sFeeConfig: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110e394:	d0a05317 	ldw	r2,-32436(gp)
8110e398:	10800003 	ldbu	r2,0(r2)
8110e39c:	10803fcc 	andi	r2,r2,255
8110e3a0:	1085883a 	add	r2,r2,r2
8110e3a4:	1087883a 	add	r3,r2,r2
8110e3a8:	d0a06a04 	addi	r2,gp,-32344
8110e3ac:	1885883a 	add	r2,r3,r2
8110e3b0:	10800017 	ldw	r2,0(r2)
8110e3b4:	e0fffd04 	addi	r3,fp,-12
8110e3b8:	180d883a 	mov	r6,r3
8110e3bc:	000b883a 	mov	r5,zero
8110e3c0:	1009883a 	mov	r4,r2
8110e3c4:	113d5c80 	call	8113d5c8 <OSQPend>
8110e3c8:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110e3cc:	e0bffd03 	ldbu	r2,-12(fp)
8110e3d0:	10803fcc 	andi	r2,r2,255
8110e3d4:	1000061e 	bne	r2,zero,8110e3f0 <vFeeTask+0x890>
					vQCmdFEEinConfig( pxNFee, uiCmdFEE.ulWord );
8110e3d8:	d0a05317 	ldw	r2,-32436(gp)
8110e3dc:	e0fffe17 	ldw	r3,-8(fp)
8110e3e0:	180b883a 	mov	r5,r3
8110e3e4:	1009883a 	mov	r4,r2
8110e3e8:	110f3d00 	call	8110f3d0 <vQCmdFEEinConfig>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110e3ec:	00037d06 	br	8110f1e4 <vFeeTask+0x1684>
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
				if ( error_code == OS_ERR_NONE ) {
					vQCmdFEEinConfig( pxNFee, uiCmdFEE.ulWord );
				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110e3f0:	d0e06217 	ldw	r3,-32376(gp)
8110e3f4:	d0a05317 	ldw	r2,-32436(gp)
8110e3f8:	10800003 	ldbu	r2,0(r2)
8110e3fc:	10803fcc 	andi	r2,r2,255
8110e400:	100d883a 	mov	r6,r2
8110e404:	01604574 	movhi	r5,33045
8110e408:	29703d04 	addi	r5,r5,-16140
8110e40c:	1809883a 	mov	r4,r3
8110e410:	1120fa40 	call	81120fa4 <fprintf>
					#endif
				}

				break;
8110e414:	00037306 	br	8110f1e4 <vFeeTask+0x1684>
			case sFeeOn: /* Not implemented yet */

				pxNFee->xControl.eMode = sToFeeStandBy;
8110e418:	d0a05317 	ldw	r2,-32436(gp)
8110e41c:	00c00184 	movi	r3,6
8110e420:	10c02c15 	stw	r3,176(r2)
				break;
8110e424:	00036f06 	br	8110f1e4 <vFeeTask+0x1684>
			case sToFeeStandBy: /* Transition */

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8110e428:	d0a05317 	ldw	r2,-32436(gp)
8110e42c:	10804304 	addi	r2,r2,268
8110e430:	1009883a 	mov	r4,r2
8110e434:	11081800 	call	81108180 <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x00; /*sToFeeStandBy*/
8110e438:	d0a05317 	ldw	r2,-32436(gp)
8110e43c:	10006615 	stw	zero,408(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8110e440:	d0a05317 	ldw	r2,-32436(gp)
8110e444:	10804304 	addi	r2,r2,268
8110e448:	1009883a 	mov	r4,r2
8110e44c:	1107e940 	call	81107e94 <bRmapSetMemConfigArea>

				/* Disable IRQ and clear the Double Buffer */
				bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110e450:	d0a05317 	ldw	r2,-32436(gp)
8110e454:	10803b04 	addi	r2,r2,236
8110e458:	1009883a 	mov	r4,r2
8110e45c:	111094c0 	call	8111094c <bDisAndClrDbBuffer>

				/* Disable RMAP interrupts */
				bEnableRmapIRQ(&pxNFee->xChannel.xRmap, pxNFee->ucId);
8110e460:	d0a05317 	ldw	r2,-32436(gp)
8110e464:	10c04304 	addi	r3,r2,268
8110e468:	d0a05317 	ldw	r2,-32436(gp)
8110e46c:	10800003 	ldbu	r2,0(r2)
8110e470:	10803fcc 	andi	r2,r2,255
8110e474:	100b883a 	mov	r5,r2
8110e478:	1809883a 	mov	r4,r3
8110e47c:	11107a40 	call	811107a4 <bEnableRmapIRQ>

				/* Disable the link SPW */
				bEnableSPWChannel( &pxNFee->xChannel.xSpacewire );
8110e480:	d0a05317 	ldw	r2,-32436(gp)
8110e484:	10808904 	addi	r2,r2,548
8110e488:	1009883a 	mov	r4,r2
8110e48c:	111085c0 	call	8111085c <bEnableSPWChannel>
				pxNFee->xControl.bChannelEnable = TRUE;
8110e490:	d0a05317 	ldw	r2,-32436(gp)
8110e494:	00c00044 	movi	r3,1
8110e498:	10c02615 	stw	r3,152(r2)

				pxNFee->xControl.bSimulating = TRUE;
8110e49c:	d0a05317 	ldw	r2,-32436(gp)
8110e4a0:	00c00044 	movi	r3,1
8110e4a4:	10c02715 	stw	r3,156(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110e4a8:	d0a05317 	ldw	r2,-32436(gp)
8110e4ac:	10002315 	stw	zero,140(r2)
				pxNFee->xControl.bEnabled = TRUE;
8110e4b0:	d0a05317 	ldw	r2,-32436(gp)
8110e4b4:	00c00044 	movi	r3,1
8110e4b8:	10c02115 	stw	r3,132(r2)

				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
8110e4bc:	d0a05317 	ldw	r2,-32436(gp)
8110e4c0:	10800003 	ldbu	r2,0(r2)
8110e4c4:	10803fcc 	andi	r2,r2,255
8110e4c8:	100d883a 	mov	r6,r2
8110e4cc:	000b883a 	mov	r5,zero
8110e4d0:	01002044 	movi	r4,129
8110e4d4:	1110a540 	call	81110a54 <bSendGiveBackNFeeCtrl>

				/* Cleaning other syncs that maybe in the queue */
				pxNFee->xControl.bWatingSync = FALSE;
8110e4d8:	d0a05317 	ldw	r2,-32436(gp)
8110e4dc:	10002815 	stw	zero,160(r2)
				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110e4e0:	d0a05317 	ldw	r2,-32436(gp)
8110e4e4:	10800003 	ldbu	r2,0(r2)
8110e4e8:	10803fcc 	andi	r2,r2,255
8110e4ec:	1085883a 	add	r2,r2,r2
8110e4f0:	1087883a 	add	r3,r2,r2
8110e4f4:	d0a05c04 	addi	r2,gp,-32400
8110e4f8:	1885883a 	add	r2,r3,r2
8110e4fc:	10800017 	ldw	r2,0(r2)
8110e500:	1009883a 	mov	r4,r2
8110e504:	113d5080 	call	8113d508 <OSQFlush>
8110e508:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110e50c:	e0bffd03 	ldbu	r2,-12(fp)
8110e510:	10803fcc 	andi	r2,r2,255
8110e514:	10000126 	beq	r2,zero,8110e51c <vFeeTask+0x9bc>
					vFailFlushNFEEQueue();
8110e518:	111d24c0 	call	8111d24c <vFailFlushNFEEQueue>
				}

				#ifdef DEBUG_ON
					fprintf(fp,"NFEE-%hu Task: Standby Mode\n", pxNFee->ucId);
8110e51c:	d0e06217 	ldw	r3,-32376(gp)
8110e520:	d0a05317 	ldw	r2,-32436(gp)
8110e524:	10800003 	ldbu	r2,0(r2)
8110e528:	10803fcc 	andi	r2,r2,255
8110e52c:	100d883a 	mov	r6,r2
8110e530:	01604574 	movhi	r5,33045
8110e534:	29704904 	addi	r5,r5,-16092
8110e538:	1809883a 	mov	r4,r3
8110e53c:	1120fa40 	call	81120fa4 <fprintf>
				#endif

				/* Reset the memory addr variables thats is used in the transmission*/
				vResetMemCCDFEE(pxNFee);
8110e540:	d0a05317 	ldw	r2,-32436(gp)
8110e544:	1009883a 	mov	r4,r2
8110e548:	111d8800 	call	8111d880 <vResetMemCCDFEE>

				incrementador = 0;
8110e54c:	d0205415 	stw	zero,-32432(gp)

				pxNFee->xControl.bWatingSync = TRUE;
8110e550:	d0a05317 	ldw	r2,-32436(gp)
8110e554:	00c00044 	movi	r3,1
8110e558:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.eMode = sFeeStandBy;
8110e55c:	d0a05317 	ldw	r2,-32436(gp)
8110e560:	00c000c4 	movi	r3,3
8110e564:	10c02c15 	stw	r3,176(r2)
				ucIterationSide = pxNFee->xControl.eSide;
8110e568:	d0a05317 	ldw	r2,-32436(gp)
8110e56c:	10802e17 	ldw	r2,184(r2)
8110e570:	d0a05605 	stb	r2,-32424(gp)
				break;
8110e574:	00031b06 	br	8110f1e4 <vFeeTask+0x1684>


			case sFeeStandBy: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110e578:	d0a05317 	ldw	r2,-32436(gp)
8110e57c:	10800003 	ldbu	r2,0(r2)
8110e580:	10803fcc 	andi	r2,r2,255
8110e584:	1085883a 	add	r2,r2,r2
8110e588:	1087883a 	add	r3,r2,r2
8110e58c:	d0a06a04 	addi	r2,gp,-32344
8110e590:	1885883a 	add	r2,r3,r2
8110e594:	10800017 	ldw	r2,0(r2)
8110e598:	e0fffd04 	addi	r3,fp,-12
8110e59c:	180d883a 	mov	r6,r3
8110e5a0:	000b883a 	mov	r5,zero
8110e5a4:	1009883a 	mov	r4,r2
8110e5a8:	113d5c80 	call	8113d5c8 <OSQPend>
8110e5ac:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110e5b0:	e0bffd03 	ldbu	r2,-12(fp)
8110e5b4:	10803fcc 	andi	r2,r2,255
8110e5b8:	1000061e 	bne	r2,zero,8110e5d4 <vFeeTask+0xa74>
					vQCmdFEEinStandBy( pxNFee, uiCmdFEE.ulWord );
8110e5bc:	d0a05317 	ldw	r2,-32436(gp)
8110e5c0:	e0fffe17 	ldw	r3,-8(fp)
8110e5c4:	180b883a 	mov	r5,r3
8110e5c8:	1009883a 	mov	r4,r2
8110e5cc:	110f5940 	call	8110f594 <vQCmdFEEinStandBy>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110e5d0:	00030406 	br	8110f1e4 <vFeeTask+0x1684>
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
				if ( error_code == OS_ERR_NONE ) {
					vQCmdFEEinStandBy( pxNFee, uiCmdFEE.ulWord );
				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110e5d4:	d0e06217 	ldw	r3,-32376(gp)
8110e5d8:	d0a05317 	ldw	r2,-32436(gp)
8110e5dc:	10800003 	ldbu	r2,0(r2)
8110e5e0:	10803fcc 	andi	r2,r2,255
8110e5e4:	100d883a 	mov	r6,r2
8110e5e8:	01604574 	movhi	r5,33045
8110e5ec:	29703d04 	addi	r5,r5,-16140
8110e5f0:	1809883a 	mov	r4,r3
8110e5f4:	1120fa40 	call	81120fa4 <fprintf>
					#endif
				}

				break;
8110e5f8:	0002fa06 	br	8110f1e4 <vFeeTask+0x1684>


			case sNextPatternIteration:


				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110e5fc:	d0a05317 	ldw	r2,-32436(gp)
8110e600:	10800003 	ldbu	r2,0(r2)
8110e604:	10803fcc 	andi	r2,r2,255
8110e608:	1085883a 	add	r2,r2,r2
8110e60c:	1087883a 	add	r3,r2,r2
8110e610:	d0a05c04 	addi	r2,gp,-32400
8110e614:	1885883a 	add	r2,r3,r2
8110e618:	10800017 	ldw	r2,0(r2)
8110e61c:	1009883a 	mov	r4,r2
8110e620:	113d5080 	call	8113d508 <OSQFlush>
8110e624:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110e628:	e0bffd03 	ldbu	r2,-12(fp)
8110e62c:	10803fcc 	andi	r2,r2,255
8110e630:	10000126 	beq	r2,zero,8110e638 <vFeeTask+0xad8>
					vFailFlushNFEEQueue();
8110e634:	111d24c0 	call	8111d24c <vFailFlushNFEEQueue>
				}

				pxNFee->xControl.bUsingDMA = TRUE;
8110e638:	d0a05317 	ldw	r2,-32436(gp)
8110e63c:	00c00044 	movi	r3,1
8110e640:	10c02315 	stw	r3,140(r2)
				pxNFee->xControl.bSimulating = TRUE;
8110e644:	d0a05317 	ldw	r2,-32436(gp)
8110e648:	00c00044 	movi	r3,1
8110e64c:	10c02715 	stw	r3,156(r2)

				vResetMemCCDFEE(pxNFee);
8110e650:	d0a05317 	ldw	r2,-32436(gp)
8110e654:	1009883a 	mov	r4,r2
8110e658:	111d8800 	call	8111d880 <vResetMemCCDFEE>

				bFeebCh1SetBufferSize(SDMA_MAX_BLOCKS,0);
8110e65c:	000b883a 	mov	r5,zero
8110e660:	01000404 	movi	r4,16
8110e664:	11059c80 	call	811059c8 <bFeebCh1SetBufferSize>
				bFeebCh1SetBufferSize(SDMA_MAX_BLOCKS,1);
8110e668:	01400044 	movi	r5,1
8110e66c:	01000404 	movi	r4,16
8110e670:	11059c80 	call	811059c8 <bFeebCh1SetBufferSize>

				/* Enable IRQ and clear the Double Buffer */
				bEnableDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110e674:	d0a05317 	ldw	r2,-32436(gp)
8110e678:	10803b04 	addi	r2,r2,236
8110e67c:	1009883a 	mov	r4,r2
8110e680:	11108bc0 	call	811108bc <bEnableDbBuffer>


				bSpwcGetTimecode(&pxNFee->xChannel.xSpacewire);
8110e684:	d0a05317 	ldw	r2,-32436(gp)
8110e688:	10808904 	addi	r2,r2,548
8110e68c:	1009883a 	mov	r4,r2
8110e690:	110a58c0 	call	8110a58c <bSpwcGetTimecode>
				tCodFeeTask = pxNFee->xChannel.xSpacewire.xTimecode.ucCounter;
8110e694:	d0a05317 	ldw	r2,-32436(gp)
8110e698:	10809543 	ldbu	r2,597(r2)
8110e69c:	10803fcc 	andi	r2,r2,255
8110e6a0:	d0a05515 	stw	r2,-32428(gp)
				tCodeNext = ( tCodFeeTask + 1) % 4;
8110e6a4:	d0a05517 	ldw	r2,-32428(gp)
8110e6a8:	10800044 	addi	r2,r2,1
8110e6ac:	108000cc 	andi	r2,r2,3
8110e6b0:	e0bffc15 	stw	r2,-16(fp)
				if ( tCodeNext == 0 ) {
8110e6b4:	e0bffc17 	ldw	r2,-16(fp)
8110e6b8:	10000e1e 	bne	r2,zero,8110e6f4 <vFeeTask+0xb94>
					/* Should get Data from the another memory, because is a cicle start */
					ucMemUsing = (unsigned char) (( *pxNFee->xControl.pActualMem + 1 ) % 2) ; /* Select the other memory*/
8110e6bc:	d0a05317 	ldw	r2,-32436(gp)
8110e6c0:	10802917 	ldw	r2,164(r2)
8110e6c4:	10800003 	ldbu	r2,0(r2)
8110e6c8:	10803fcc 	andi	r2,r2,255
8110e6cc:	10c00044 	addi	r3,r2,1
8110e6d0:	00a00034 	movhi	r2,32768
8110e6d4:	10800044 	addi	r2,r2,1
8110e6d8:	1884703a 	and	r2,r3,r2
8110e6dc:	1000040e 	bge	r2,zero,8110e6f0 <vFeeTask+0xb90>
8110e6e0:	10bfffc4 	addi	r2,r2,-1
8110e6e4:	00ffff84 	movi	r3,-2
8110e6e8:	10c4b03a 	or	r2,r2,r3
8110e6ec:	10800044 	addi	r2,r2,1
8110e6f0:	e0bff305 	stb	r2,-52(fp)
				}

				ucReadout = pxNFee->xControl.ucROutOrder[tCodeNext];
8110e6f4:	d0e05317 	ldw	r3,-32436(gp)
8110e6f8:	e0bffc17 	ldw	r2,-16(fp)
8110e6fc:	1885883a 	add	r2,r3,r2
8110e700:	10802a44 	addi	r2,r2,169
8110e704:	10800003 	ldbu	r2,0(r2)
8110e708:	e0bff505 	stb	r2,-44(fp)

				if ( pxNFee->xControl.eSide == sLeft )
8110e70c:	d0a05317 	ldw	r2,-32436(gp)
8110e710:	10802e17 	ldw	r2,184(r2)
8110e714:	1000071e 	bne	r2,zero,8110e734 <vFeeTask+0xbd4>
					xCcdMapLocal = &pxNFee->xMemMap.xCcd[ucReadout].xLeft;
8110e718:	d0e05317 	ldw	r3,-32436(gp)
8110e71c:	e0bff503 	ldbu	r2,-44(fp)
8110e720:	10800624 	muli	r2,r2,24
8110e724:	10800904 	addi	r2,r2,36
8110e728:	1885883a 	add	r2,r3,r2
8110e72c:	e0bff415 	stw	r2,-48(fp)
8110e730:	00000606 	br	8110e74c <vFeeTask+0xbec>
				else
					xCcdMapLocal = &pxNFee->xMemMap.xCcd[ucReadout].xRight;
8110e734:	d0e05317 	ldw	r3,-32436(gp)
8110e738:	e0bff503 	ldbu	r2,-44(fp)
8110e73c:	10800624 	muli	r2,r2,24
8110e740:	10800c04 	addi	r2,r2,48
8110e744:	1885883a 	add	r2,r3,r2
8110e748:	e0bff415 	stw	r2,-48(fp)

				ucIterationSide = pxNFee->xControl.eSide;
8110e74c:	d0a05317 	ldw	r2,-32436(gp)
8110e750:	10802e17 	ldw	r2,184(r2)
8110e754:	d0a05605 	stb	r2,-32424(gp)


				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110e758:	d0a05317 	ldw	r2,-32436(gp)
8110e75c:	10803304 	addi	r2,r2,204
8110e760:	1009883a 	mov	r4,r2
8110e764:	1104a680 	call	81104a68 <bDpktGetPacketConfig>
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber = ucReadout;
8110e768:	d0a05317 	ldw	r2,-32436(gp)
8110e76c:	e0fff503 	ldbu	r3,-44(fp)
8110e770:	10c036c5 	stb	r3,219(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktFullImagePattern; /* todo:No esquecer de atualizar para o ENUM  */
8110e774:	d0a05317 	ldw	r2,-32436(gp)
8110e778:	00c00044 	movi	r3,1
8110e77c:	10c03685 	stb	r3,218(r2)
				bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110e780:	d0a05317 	ldw	r2,-32436(gp)
8110e784:	10803304 	addi	r2,r2,204
8110e788:	1009883a 	mov	r4,r2
8110e78c:	110483c0 	call	8110483c <bDpktSetPacketConfig>


				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110e790:	d0a05317 	ldw	r2,-32436(gp)
8110e794:	10803304 	addi	r2,r2,204
8110e798:	1009883a 	mov	r4,r2
8110e79c:	1104a680 	call	81104a68 <bDpktGetPacketConfig>
				#ifdef DEBUG_ON
					//fprintf(fp,"\n    i: %u ",incrementador);
					fprintf(fp,"\n\n=========DATA PACKET=============\n");
8110e7a0:	d0a06217 	ldw	r2,-32376(gp)
8110e7a4:	100f883a 	mov	r7,r2
8110e7a8:	01800904 	movi	r6,36
8110e7ac:	01400044 	movi	r5,1
8110e7b0:	01204574 	movhi	r4,33045
8110e7b4:	21305104 	addi	r4,r4,-16060
8110e7b8:	11216400 	call	81121640 <fwrite>
					fprintf(fp,"usiCcdXSize %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdXSize);
8110e7bc:	d0e06217 	ldw	r3,-32376(gp)
8110e7c0:	d0a05317 	ldw	r2,-32436(gp)
8110e7c4:	1080340b 	ldhu	r2,208(r2)
8110e7c8:	10bfffcc 	andi	r2,r2,65535
8110e7cc:	100d883a 	mov	r6,r2
8110e7d0:	01604574 	movhi	r5,33045
8110e7d4:	29705b04 	addi	r5,r5,-16020
8110e7d8:	1809883a 	mov	r4,r3
8110e7dc:	1120fa40 	call	81120fa4 <fprintf>
					fprintf(fp,"usiCcdYSize %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdYSize);
8110e7e0:	d0e06217 	ldw	r3,-32376(gp)
8110e7e4:	d0a05317 	ldw	r2,-32436(gp)
8110e7e8:	1080348b 	ldhu	r2,210(r2)
8110e7ec:	10bfffcc 	andi	r2,r2,65535
8110e7f0:	100d883a 	mov	r6,r2
8110e7f4:	01604574 	movhi	r5,33045
8110e7f8:	29706004 	addi	r5,r5,-16000
8110e7fc:	1809883a 	mov	r4,r3
8110e800:	1120fa40 	call	81120fa4 <fprintf>
					fprintf(fp,"usiDataYSize %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiDataYSize);
8110e804:	d0e06217 	ldw	r3,-32376(gp)
8110e808:	d0a05317 	ldw	r2,-32436(gp)
8110e80c:	1080350b 	ldhu	r2,212(r2)
8110e810:	10bfffcc 	andi	r2,r2,65535
8110e814:	100d883a 	mov	r6,r2
8110e818:	01604574 	movhi	r5,33045
8110e81c:	29706504 	addi	r5,r5,-15980
8110e820:	1809883a 	mov	r4,r3
8110e824:	1120fa40 	call	81120fa4 <fprintf>
					fprintf(fp,"usiOverscanYSize %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiOverscanYSize);
8110e828:	d0e06217 	ldw	r3,-32376(gp)
8110e82c:	d0a05317 	ldw	r2,-32436(gp)
8110e830:	1080358b 	ldhu	r2,214(r2)
8110e834:	10bfffcc 	andi	r2,r2,65535
8110e838:	100d883a 	mov	r6,r2
8110e83c:	01604574 	movhi	r5,33045
8110e840:	29706a04 	addi	r5,r5,-15960
8110e844:	1809883a 	mov	r4,r3
8110e848:	1120fa40 	call	81120fa4 <fprintf>
					fprintf(fp,"usiPacketLength %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiPacketLength);
8110e84c:	d0e06217 	ldw	r3,-32376(gp)
8110e850:	d0a05317 	ldw	r2,-32436(gp)
8110e854:	1080360b 	ldhu	r2,216(r2)
8110e858:	10bfffcc 	andi	r2,r2,65535
8110e85c:	100d883a 	mov	r6,r2
8110e860:	01604574 	movhi	r5,33045
8110e864:	29707004 	addi	r5,r5,-15936
8110e868:	1809883a 	mov	r4,r3
8110e86c:	1120fa40 	call	81120fa4 <fprintf>
					fprintf(fp,"ucCcdNumber %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber);
8110e870:	d0e06217 	ldw	r3,-32376(gp)
8110e874:	d0a05317 	ldw	r2,-32436(gp)
8110e878:	108036c3 	ldbu	r2,219(r2)
8110e87c:	10803fcc 	andi	r2,r2,255
8110e880:	100d883a 	mov	r6,r2
8110e884:	01604574 	movhi	r5,33045
8110e888:	29707604 	addi	r5,r5,-15912
8110e88c:	1809883a 	mov	r4,r3
8110e890:	1120fa40 	call	81120fa4 <fprintf>
					fprintf(fp,"ucFeeMode %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode);
8110e894:	d0e06217 	ldw	r3,-32376(gp)
8110e898:	d0a05317 	ldw	r2,-32436(gp)
8110e89c:	10803683 	ldbu	r2,218(r2)
8110e8a0:	10803fcc 	andi	r2,r2,255
8110e8a4:	100d883a 	mov	r6,r2
8110e8a8:	01604574 	movhi	r5,33045
8110e8ac:	29707b04 	addi	r5,r5,-15892
8110e8b0:	1809883a 	mov	r4,r3
8110e8b4:	1120fa40 	call	81120fa4 <fprintf>
					fprintf(fp,"=========DATA PACKET=============\n");
8110e8b8:	d0a06217 	ldw	r2,-32376(gp)
8110e8bc:	100f883a 	mov	r7,r2
8110e8c0:	01800884 	movi	r6,34
8110e8c4:	01400044 	movi	r5,1
8110e8c8:	01204574 	movhi	r4,33045
8110e8cc:	21307f04 	addi	r4,r4,-15876
8110e8d0:	11216400 	call	81121640 <fwrite>
				#endif

				/* Make one requests for the Double buffer */
				bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId);
8110e8d4:	d0a05317 	ldw	r2,-32436(gp)
8110e8d8:	10800003 	ldbu	r2,0(r2)
8110e8dc:	10803fcc 	andi	r2,r2,255
8110e8e0:	100d883a 	mov	r6,r2
8110e8e4:	000b883a 	mov	r5,zero
8110e8e8:	01002004 	movi	r4,128
8110e8ec:	11109b00 	call	811109b0 <bSendRequestNFeeCtrl>
				bDmaReturn = FALSE;
8110e8f0:	e03ff715 	stw	zero,-36(fp)
				/* When get the mutex, perform two DMA writes in order to fill the "double" part of the double buffer */
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110e8f4:	d0a05317 	ldw	r2,-32436(gp)
8110e8f8:	10800003 	ldbu	r2,0(r2)
8110e8fc:	10803fcc 	andi	r2,r2,255
8110e900:	1085883a 	add	r2,r2,r2
8110e904:	1087883a 	add	r3,r2,r2
8110e908:	d0a06a04 	addi	r2,gp,-32344
8110e90c:	1885883a 	add	r2,r3,r2
8110e910:	10800017 	ldw	r2,0(r2)
8110e914:	e0fffd04 	addi	r3,fp,-12
8110e918:	180d883a 	mov	r6,r3
8110e91c:	000b883a 	mov	r5,zero
8110e920:	1009883a 	mov	r4,r2
8110e924:	113d5c80 	call	8113d5c8 <OSQPend>
8110e928:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110e92c:	e0bffd03 	ldbu	r2,-12(fp)
8110e930:	10803fcc 	andi	r2,r2,255
8110e934:	1000c91e 	bne	r2,zero,8110ec5c <vFeeTask+0x10fc>

					/* First Check if is access to the DMA (priority) */
					if ( uiCmdFEE.ucByte[2] == M_FEE_DMA_ACCESS ) {
8110e938:	e0bffe83 	ldbu	r2,-6(fp)
8110e93c:	10803fcc 	andi	r2,r2,255
8110e940:	108023d8 	cmpnei	r2,r2,143
8110e944:	1000bf1e 	bne	r2,zero,8110ec44 <vFeeTask+0x10e4>

						/* Try to get the Mutex */
	                    OSMutexPend(xDma[ucMemUsing].xMutexDMA, 0, &error_code); /* Blocking way */
8110e948:	e0fff303 	ldbu	r3,-52(fp)
8110e94c:	00a045b4 	movhi	r2,33046
8110e950:	108d0d04 	addi	r2,r2,13364
8110e954:	180690fa 	slli	r3,r3,3
8110e958:	10c5883a 	add	r2,r2,r3
8110e95c:	10800017 	ldw	r2,0(r2)
8110e960:	e0fffd04 	addi	r3,fp,-12
8110e964:	180d883a 	mov	r6,r3
8110e968:	000b883a 	mov	r5,zero
8110e96c:	1009883a 	mov	r4,r2
8110e970:	113c4b40 	call	8113c4b4 <OSMutexPend>
	                    if ( error_code == OS_ERR_NONE ) {
8110e974:	e0bffd03 	ldbu	r2,-12(fp)
8110e978:	10803fcc 	andi	r2,r2,255
8110e97c:	1000c01e 	bne	r2,zero,8110ec80 <vFeeTask+0x1120>
	                    	pxNFee->xControl.bDMALocked = TRUE;
8110e980:	d0a05317 	ldw	r2,-32436(gp)
8110e984:	00c00044 	movi	r3,1
8110e988:	10c02215 	stw	r3,136(r2)

							if (  ucMemUsing == 0  ) {
8110e98c:	e0bff303 	ldbu	r2,-52(fp)
8110e990:	1000451e 	bne	r2,zero,8110eaa8 <vFeeTask+0xf48>
								/* Initializing the addr */
								xCcdMapLocal->ulBlockI = 0;
8110e994:	e0bff417 	ldw	r2,-48(fp)
8110e998:	10000115 	stw	zero,4(r2)
								xCcdMapLocal->ulAddrI = xCcdMapLocal->ulOffsetAddr;
8110e99c:	e0bff417 	ldw	r2,-48(fp)
8110e9a0:	10c00017 	ldw	r3,0(r2)
8110e9a4:	e0bff417 	ldw	r2,-48(fp)
8110e9a8:	10c00215 	stw	r3,8(r2)

								bDmaReturn = bSdmaDmaM1Transfer(xCcdMapLocal->ulAddrI, SDMA_MAX_BLOCKS, ucIterationSide, pxNFee->ucId);
8110e9ac:	e0bff417 	ldw	r2,-48(fp)
8110e9b0:	10800217 	ldw	r2,8(r2)
8110e9b4:	1009883a 	mov	r4,r2
8110e9b8:	d0a05603 	ldbu	r2,-32424(gp)
8110e9bc:	10c03fcc 	andi	r3,r2,255
8110e9c0:	d0a05317 	ldw	r2,-32436(gp)
8110e9c4:	10800003 	ldbu	r2,0(r2)
8110e9c8:	10803fcc 	andi	r2,r2,255
8110e9cc:	100f883a 	mov	r7,r2
8110e9d0:	180d883a 	mov	r6,r3
8110e9d4:	01400404 	movi	r5,16
8110e9d8:	1103c900 	call	81103c90 <bSdmaDmaM1Transfer>
8110e9dc:	e0bff715 	stw	r2,-36(fp)
								if ( bDmaReturn == TRUE ) {
8110e9e0:	e0bff717 	ldw	r2,-36(fp)
8110e9e4:	10800058 	cmpnei	r2,r2,1
8110e9e8:	1000241e 	bne	r2,zero,8110ea7c <vFeeTask+0xf1c>
									//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
									xCcdMapLocal->ulAddrI += SDMA_BUFFER_SIZE_BYTES;
8110e9ec:	e0bff417 	ldw	r2,-48(fp)
8110e9f0:	10800217 	ldw	r2,8(r2)
8110e9f4:	10c22004 	addi	r3,r2,2176
8110e9f8:	e0bff417 	ldw	r2,-48(fp)
8110e9fc:	10c00215 	stw	r3,8(r2)
									xCcdMapLocal->ulBlockI += SDMA_MAX_BLOCKS;
8110ea00:	e0bff417 	ldw	r2,-48(fp)
8110ea04:	10800117 	ldw	r2,4(r2)
8110ea08:	10c00404 	addi	r3,r2,16
8110ea0c:	e0bff417 	ldw	r2,-48(fp)
8110ea10:	10c00115 	stw	r3,4(r2)
									bDmaReturn = bSdmaDmaM1Transfer(xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, ucIterationSide, pxNFee->ucId);
8110ea14:	e0bff417 	ldw	r2,-48(fp)
8110ea18:	10800217 	ldw	r2,8(r2)
8110ea1c:	1009883a 	mov	r4,r2
8110ea20:	d0a05603 	ldbu	r2,-32424(gp)
8110ea24:	10c03fcc 	andi	r3,r2,255
8110ea28:	d0a05317 	ldw	r2,-32436(gp)
8110ea2c:	10800003 	ldbu	r2,0(r2)
8110ea30:	10803fcc 	andi	r2,r2,255
8110ea34:	100f883a 	mov	r7,r2
8110ea38:	180d883a 	mov	r6,r3
8110ea3c:	01400404 	movi	r5,16
8110ea40:	1103c900 	call	81103c90 <bSdmaDmaM1Transfer>
8110ea44:	e0bff715 	stw	r2,-36(fp)
									if ( bDmaReturn == TRUE ) {
8110ea48:	e0bff717 	ldw	r2,-36(fp)
8110ea4c:	10800058 	cmpnei	r2,r2,1
8110ea50:	10000a1e 	bne	r2,zero,8110ea7c <vFeeTask+0xf1c>
										//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
										xCcdMapLocal->ulAddrI += SDMA_BUFFER_SIZE_BYTES;
8110ea54:	e0bff417 	ldw	r2,-48(fp)
8110ea58:	10800217 	ldw	r2,8(r2)
8110ea5c:	10c22004 	addi	r3,r2,2176
8110ea60:	e0bff417 	ldw	r2,-48(fp)
8110ea64:	10c00215 	stw	r3,8(r2)
										xCcdMapLocal->ulBlockI += SDMA_MAX_BLOCKS;
8110ea68:	e0bff417 	ldw	r2,-48(fp)
8110ea6c:	10800117 	ldw	r2,4(r2)
8110ea70:	10c00404 	addi	r3,r2,16
8110ea74:	e0bff417 	ldw	r2,-48(fp)
8110ea78:	10c00115 	stw	r3,4(r2)
									}
								}
								OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110ea7c:	e0fff303 	ldbu	r3,-52(fp)
8110ea80:	00a045b4 	movhi	r2,33046
8110ea84:	108d0d04 	addi	r2,r2,13364
8110ea88:	180690fa 	slli	r3,r3,3
8110ea8c:	10c5883a 	add	r2,r2,r3
8110ea90:	10800017 	ldw	r2,0(r2)
8110ea94:	1009883a 	mov	r4,r2
8110ea98:	113ca580 	call	8113ca58 <OSMutexPost>
								pxNFee->xControl.bDMALocked = FALSE;
8110ea9c:	d0a05317 	ldw	r2,-32436(gp)
8110eaa0:	10002215 	stw	zero,136(r2)
8110eaa4:	00004406 	br	8110ebb8 <vFeeTask+0x1058>
							} else {
								xCcdMapLocal->ulBlockI = 0;
8110eaa8:	e0bff417 	ldw	r2,-48(fp)
8110eaac:	10000115 	stw	zero,4(r2)
								xCcdMapLocal->ulAddrI = xCcdMapLocal->ulOffsetAddr;
8110eab0:	e0bff417 	ldw	r2,-48(fp)
8110eab4:	10c00017 	ldw	r3,0(r2)
8110eab8:	e0bff417 	ldw	r2,-48(fp)
8110eabc:	10c00215 	stw	r3,8(r2)
								bDmaReturn = bSdmaDmaM2Transfer(xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, ucIterationSide, pxNFee->ucId);
8110eac0:	e0bff417 	ldw	r2,-48(fp)
8110eac4:	10800217 	ldw	r2,8(r2)
8110eac8:	1009883a 	mov	r4,r2
8110eacc:	d0a05603 	ldbu	r2,-32424(gp)
8110ead0:	10c03fcc 	andi	r3,r2,255
8110ead4:	d0a05317 	ldw	r2,-32436(gp)
8110ead8:	10800003 	ldbu	r2,0(r2)
8110eadc:	10803fcc 	andi	r2,r2,255
8110eae0:	100f883a 	mov	r7,r2
8110eae4:	180d883a 	mov	r6,r3
8110eae8:	01400404 	movi	r5,16
8110eaec:	11040ec0 	call	811040ec <bSdmaDmaM2Transfer>
8110eaf0:	e0bff715 	stw	r2,-36(fp)
								if ( bDmaReturn == TRUE ) {
8110eaf4:	e0bff717 	ldw	r2,-36(fp)
8110eaf8:	10800058 	cmpnei	r2,r2,1
8110eafc:	1000241e 	bne	r2,zero,8110eb90 <vFeeTask+0x1030>
									//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
									xCcdMapLocal->ulAddrI += SDMA_BUFFER_SIZE_BYTES;
8110eb00:	e0bff417 	ldw	r2,-48(fp)
8110eb04:	10800217 	ldw	r2,8(r2)
8110eb08:	10c22004 	addi	r3,r2,2176
8110eb0c:	e0bff417 	ldw	r2,-48(fp)
8110eb10:	10c00215 	stw	r3,8(r2)
									xCcdMapLocal->ulBlockI += SDMA_MAX_BLOCKS;
8110eb14:	e0bff417 	ldw	r2,-48(fp)
8110eb18:	10800117 	ldw	r2,4(r2)
8110eb1c:	10c00404 	addi	r3,r2,16
8110eb20:	e0bff417 	ldw	r2,-48(fp)
8110eb24:	10c00115 	stw	r3,4(r2)
									bDmaReturn = bSdmaDmaM2Transfer(xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, ucIterationSide, pxNFee->ucId);
8110eb28:	e0bff417 	ldw	r2,-48(fp)
8110eb2c:	10800217 	ldw	r2,8(r2)
8110eb30:	1009883a 	mov	r4,r2
8110eb34:	d0a05603 	ldbu	r2,-32424(gp)
8110eb38:	10c03fcc 	andi	r3,r2,255
8110eb3c:	d0a05317 	ldw	r2,-32436(gp)
8110eb40:	10800003 	ldbu	r2,0(r2)
8110eb44:	10803fcc 	andi	r2,r2,255
8110eb48:	100f883a 	mov	r7,r2
8110eb4c:	180d883a 	mov	r6,r3
8110eb50:	01400404 	movi	r5,16
8110eb54:	11040ec0 	call	811040ec <bSdmaDmaM2Transfer>
8110eb58:	e0bff715 	stw	r2,-36(fp)
									if ( bDmaReturn == TRUE ) {
8110eb5c:	e0bff717 	ldw	r2,-36(fp)
8110eb60:	10800058 	cmpnei	r2,r2,1
8110eb64:	10000a1e 	bne	r2,zero,8110eb90 <vFeeTask+0x1030>
										//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
										xCcdMapLocal->ulAddrI += SDMA_BUFFER_SIZE_BYTES;
8110eb68:	e0bff417 	ldw	r2,-48(fp)
8110eb6c:	10800217 	ldw	r2,8(r2)
8110eb70:	10c22004 	addi	r3,r2,2176
8110eb74:	e0bff417 	ldw	r2,-48(fp)
8110eb78:	10c00215 	stw	r3,8(r2)
										xCcdMapLocal->ulBlockI += SDMA_MAX_BLOCKS;
8110eb7c:	e0bff417 	ldw	r2,-48(fp)
8110eb80:	10800117 	ldw	r2,4(r2)
8110eb84:	10c00404 	addi	r3,r2,16
8110eb88:	e0bff417 	ldw	r2,-48(fp)
8110eb8c:	10c00115 	stw	r3,4(r2)

									}
								}
								OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110eb90:	e0fff303 	ldbu	r3,-52(fp)
8110eb94:	00a045b4 	movhi	r2,33046
8110eb98:	108d0d04 	addi	r2,r2,13364
8110eb9c:	180690fa 	slli	r3,r3,3
8110eba0:	10c5883a 	add	r2,r2,r3
8110eba4:	10800017 	ldw	r2,0(r2)
8110eba8:	1009883a 	mov	r4,r2
8110ebac:	113ca580 	call	8113ca58 <OSMutexPost>
								pxNFee->xControl.bDMALocked = FALSE;
8110ebb0:	d0a05317 	ldw	r2,-32436(gp)
8110ebb4:	10002215 	stw	zero,136(r2)
							}
	                        /* Send message telling to controller that is not using the DMA any more */
							bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);							
8110ebb8:	d0a05317 	ldw	r2,-32436(gp)
8110ebbc:	10800003 	ldbu	r2,0(r2)
8110ebc0:	10803fcc 	andi	r2,r2,255
8110ebc4:	100d883a 	mov	r6,r2
8110ebc8:	000b883a 	mov	r5,zero
8110ebcc:	01002044 	movi	r4,129
8110ebd0:	1110a540 	call	81110a54 <bSendGiveBackNFeeCtrl>

							if ( bDmaReturn == TRUE ) {
8110ebd4:	e0bff717 	ldw	r2,-36(fp)
8110ebd8:	10800058 	cmpnei	r2,r2,1
8110ebdc:	1000111e 	bne	r2,zero,8110ec24 <vFeeTask+0x10c4>
								if (pxNFee->xControl.bWatingSync==TRUE) {
8110ebe0:	d0a05317 	ldw	r2,-32436(gp)
8110ebe4:	10802817 	ldw	r2,160(r2)
8110ebe8:	10800058 	cmpnei	r2,r2,1
8110ebec:	1000071e 	bne	r2,zero,8110ec0c <vFeeTask+0x10ac>
									pxNFee->xControl.eNextMode = sToTestFullPattern;
8110ebf0:	d0a05317 	ldw	r2,-32436(gp)
8110ebf4:	00c001c4 	movi	r3,7
8110ebf8:	10c02d15 	stw	r3,180(r2)
									pxNFee->xControl.eMode = sFeeWaitingSync;
8110ebfc:	d0a05317 	ldw	r2,-32436(gp)
8110ec00:	00c00304 	movi	r3,12
8110ec04:	10c02c15 	stw	r3,176(r2)
8110ec08:	00000606 	br	8110ec24 <vFeeTask+0x10c4>
								} else {
									pxNFee->xControl.eNextMode = sToTestFullPattern;
8110ec0c:	d0a05317 	ldw	r2,-32436(gp)
8110ec10:	00c001c4 	movi	r3,7
8110ec14:	10c02d15 	stw	r3,180(r2)
									pxNFee->xControl.eMode = sToTestFullPattern;
8110ec18:	d0a05317 	ldw	r2,-32436(gp)
8110ec1c:	00c001c4 	movi	r3,7
8110ec20:	10c02c15 	stw	r3,176(r2)
								}
							}


							#ifdef DEBUG_ON
								fprintf(fp,"\nFEE TASK:  Double buffer prepared\n ");
8110ec24:	d0a06217 	ldw	r2,-32376(gp)
8110ec28:	100f883a 	mov	r7,r2
8110ec2c:	01800904 	movi	r6,36
8110ec30:	01400044 	movi	r5,1
8110ec34:	01204574 	movhi	r4,33045
8110ec38:	21308804 	addi	r4,r4,-15840
8110ec3c:	11216400 	call	81121640 <fwrite>
8110ec40:	00000f06 	br	8110ec80 <vFeeTask+0x1120>
							#endif							
	                    }
					} else {

						vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
8110ec44:	d0a05317 	ldw	r2,-32436(gp)
8110ec48:	e0fffe17 	ldw	r3,-8(fp)
8110ec4c:	180b883a 	mov	r5,r3
8110ec50:	1009883a 	mov	r4,r2
8110ec54:	110f7900 	call	8110f790 <vQCmdFEEinFullPattern>
8110ec58:	00000906 	br	8110ec80 <vFeeTask+0x1120>
					}
				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110ec5c:	d0e06217 	ldw	r3,-32376(gp)
8110ec60:	d0a05317 	ldw	r2,-32436(gp)
8110ec64:	10800003 	ldbu	r2,0(r2)
8110ec68:	10803fcc 	andi	r2,r2,255
8110ec6c:	100d883a 	mov	r6,r2
8110ec70:	01604574 	movhi	r5,33045
8110ec74:	29703d04 	addi	r5,r5,-16140
8110ec78:	1809883a 	mov	r4,r3
8110ec7c:	1120fa40 	call	81120fa4 <fprintf>
					#endif
				}

				incrementador++;
8110ec80:	d0a05417 	ldw	r2,-32432(gp)
8110ec84:	10800044 	addi	r2,r2,1
8110ec88:	d0a05415 	stw	r2,-32432(gp)
				break;
8110ec8c:	00015506 	br	8110f1e4 <vFeeTask+0x1684>


			case sToTestFullPattern: /* Transition */
				bFinal = FALSE;
8110ec90:	e03ff815 	stw	zero,-32(fp)

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8110ec94:	d0a05317 	ldw	r2,-32436(gp)
8110ec98:	10804304 	addi	r2,r2,268
8110ec9c:	1009883a 	mov	r4,r2
8110eca0:	11081800 	call	81108180 <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x02; /*Pattern Full Image*/
8110eca4:	d0a05317 	ldw	r2,-32436(gp)
8110eca8:	00c00084 	movi	r3,2
8110ecac:	10c06615 	stw	r3,408(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8110ecb0:	d0a05317 	ldw	r2,-32436(gp)
8110ecb4:	10804304 	addi	r2,r2,268
8110ecb8:	1009883a 	mov	r4,r2
8110ecbc:	1107e940 	call	81107e94 <bRmapSetMemConfigArea>

				#ifdef DEBUG_ON
				//	fprintf(fp,"NFEE-%hu Task: Full Image Pattern Mode\n", pxNFee->ucId);
				#endif

				pxNFee->xControl.bUsingDMA = TRUE;
8110ecc0:	d0a05317 	ldw	r2,-32436(gp)
8110ecc4:	00c00044 	movi	r3,1
8110ecc8:	10c02315 	stw	r3,140(r2)
				pxNFee->xControl.eMode = sFeeTestFullPattern;
8110eccc:	d0a05317 	ldw	r2,-32436(gp)
8110ecd0:	00c00104 	movi	r3,4
8110ecd4:	10c02c15 	stw	r3,176(r2)
				pxNFee->xControl.eNextMode = sFeeTestFullPattern;
8110ecd8:	d0a05317 	ldw	r2,-32436(gp)
8110ecdc:	00c00104 	movi	r3,4
8110ece0:	10c02d15 	stw	r3,180(r2)
				pxNFee->xControl.bWatingSync = TRUE;
8110ece4:	d0a05317 	ldw	r2,-32436(gp)
8110ece8:	00c00044 	movi	r3,1
8110ecec:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.bSimulating = TRUE;
8110ecf0:	d0a05317 	ldw	r2,-32436(gp)
8110ecf4:	00c00044 	movi	r3,1
8110ecf8:	10c02715 	stw	r3,156(r2)
				pxNFee->xControl.bEnabled = TRUE;
8110ecfc:	d0a05317 	ldw	r2,-32436(gp)
8110ed00:	00c00044 	movi	r3,1
8110ed04:	10c02115 	stw	r3,132(r2)
				bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
8110ed08:	d0a05317 	ldw	r2,-32436(gp)
8110ed0c:	10800003 	ldbu	r2,0(r2)
8110ed10:	10803fcc 	andi	r2,r2,255
8110ed14:	100d883a 	mov	r6,r2
8110ed18:	000b883a 	mov	r5,zero
8110ed1c:	01002004 	movi	r4,128
8110ed20:	11109b00 	call	811109b0 <bSendRequestNFeeCtrl>

				break;
8110ed24:	00012f06 	br	8110f1e4 <vFeeTask+0x1684>


			case sFeeTestFullPattern: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110ed28:	d0a05317 	ldw	r2,-32436(gp)
8110ed2c:	10800003 	ldbu	r2,0(r2)
8110ed30:	10803fcc 	andi	r2,r2,255
8110ed34:	1085883a 	add	r2,r2,r2
8110ed38:	1087883a 	add	r3,r2,r2
8110ed3c:	d0a06a04 	addi	r2,gp,-32344
8110ed40:	1885883a 	add	r2,r3,r2
8110ed44:	10800017 	ldw	r2,0(r2)
8110ed48:	e0fffd04 	addi	r3,fp,-12
8110ed4c:	180d883a 	mov	r6,r3
8110ed50:	000b883a 	mov	r5,zero
8110ed54:	1009883a 	mov	r4,r2
8110ed58:	113d5c80 	call	8113d5c8 <OSQPend>
8110ed5c:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110ed60:	e0bffd03 	ldbu	r2,-12(fp)
8110ed64:	10803fcc 	andi	r2,r2,255
8110ed68:	1000b91e 	bne	r2,zero,8110f050 <vFeeTask+0x14f0>

					/* First Check if is access to the DMA (priority) */
						if ( uiCmdFEE.ucByte[2] == M_FEE_DMA_ACCESS ) {
8110ed6c:	e0bffe83 	ldbu	r2,-6(fp)
8110ed70:	10803fcc 	andi	r2,r2,255
8110ed74:	108023d8 	cmpnei	r2,r2,143
8110ed78:	1000a81e 	bne	r2,zero,8110f01c <vFeeTask+0x14bc>

							/* Try to get the Mutex */
		                    OSMutexPend(xDma[ucMemUsing].xMutexDMA, 0, &error_code); /* Blocking way */
8110ed7c:	e0fff303 	ldbu	r3,-52(fp)
8110ed80:	00a045b4 	movhi	r2,33046
8110ed84:	108d0d04 	addi	r2,r2,13364
8110ed88:	180690fa 	slli	r3,r3,3
8110ed8c:	10c5883a 	add	r2,r2,r3
8110ed90:	10800017 	ldw	r2,0(r2)
8110ed94:	e0fffd04 	addi	r3,fp,-12
8110ed98:	180d883a 	mov	r6,r3
8110ed9c:	000b883a 	mov	r5,zero
8110eda0:	1009883a 	mov	r4,r2
8110eda4:	113c4b40 	call	8113c4b4 <OSMutexPend>
		                    if ( error_code == OS_ERR_NONE ) {
8110eda8:	e0bffd03 	ldbu	r2,-12(fp)
8110edac:	10803fcc 	andi	r2,r2,255
8110edb0:	10010b1e 	bne	r2,zero,8110f1e0 <vFeeTask+0x1680>
		                    	pxNFee->xControl.bDMALocked = TRUE;
8110edb4:	d0a05317 	ldw	r2,-32436(gp)
8110edb8:	00c00044 	movi	r3,1
8110edbc:	10c02215 	stw	r3,136(r2)

		                    	/* Is this the last block? */
		                    	if ( (xCcdMapLocal->ulBlockI + SDMA_MAX_BLOCKS) >= pxNFee->xMemMap.xCommon.usiNTotalBlocks ) {
8110edc0:	e0bff417 	ldw	r2,-48(fp)
8110edc4:	10800117 	ldw	r2,4(r2)
8110edc8:	10c00404 	addi	r3,r2,16
8110edcc:	d0a05317 	ldw	r2,-32436(gp)
8110edd0:	10800417 	ldw	r2,16(r2)
8110edd4:	18803036 	bltu	r3,r2,8110ee98 <vFeeTask+0x1338>


									#ifdef DEBUG_ON
										//fprintf(fp,"\n    i: %u ",incrementador);
										fprintf(fp,"\nEnd of transmission NFEE-%hhu -> CCD %hhu  -> Time Code Ref. used -> %hu   total = %lu\n", pxNFee->ucId, ucReadout, tCodFeeTask, incrementador);
8110edd8:	d1206217 	ldw	r4,-32376(gp)
8110eddc:	d0a05317 	ldw	r2,-32436(gp)
8110ede0:	10800003 	ldbu	r2,0(r2)
8110ede4:	11403fcc 	andi	r5,r2,255
8110ede8:	e1bff503 	ldbu	r6,-44(fp)
8110edec:	d0a05517 	ldw	r2,-32428(gp)
8110edf0:	d0e05417 	ldw	r3,-32432(gp)
8110edf4:	d8c00115 	stw	r3,4(sp)
8110edf8:	d8800015 	stw	r2,0(sp)
8110edfc:	300f883a 	mov	r7,r6
8110ee00:	280d883a 	mov	r6,r5
8110ee04:	01604574 	movhi	r5,33045
8110ee08:	29709204 	addi	r5,r5,-15800
8110ee0c:	1120fa40 	call	81120fa4 <fprintf>
										fprintf(fp,"\nMemory used: %u ", ucMemUsing);
8110ee10:	d0a06217 	ldw	r2,-32376(gp)
8110ee14:	e0fff303 	ldbu	r3,-52(fp)
8110ee18:	180d883a 	mov	r6,r3
8110ee1c:	01604574 	movhi	r5,33045
8110ee20:	2970a904 	addi	r5,r5,-15708
8110ee24:	1009883a 	mov	r4,r2
8110ee28:	1120fa40 	call	81120fa4 <fprintf>
										fprintf(fp,"\nTotal blocks transmitted: %lu ",xCcdMapLocal->ulBlockI);
8110ee2c:	d0e06217 	ldw	r3,-32376(gp)
8110ee30:	e0bff417 	ldw	r2,-48(fp)
8110ee34:	10800117 	ldw	r2,4(r2)
8110ee38:	100d883a 	mov	r6,r2
8110ee3c:	01604574 	movhi	r5,33045
8110ee40:	2970ae04 	addi	r5,r5,-15688
8110ee44:	1809883a 	mov	r4,r3
8110ee48:	1120fa40 	call	81120fa4 <fprintf>
									#endif

		                    		/*Define the size of the data in the double buffer (need this to create the interrupt riht)*/

									usiLengthBlocks = pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI;
8110ee4c:	d0a05317 	ldw	r2,-32436(gp)
8110ee50:	10c00417 	ldw	r3,16(r2)
8110ee54:	e0bff417 	ldw	r2,-48(fp)
8110ee58:	10800117 	ldw	r2,4(r2)
8110ee5c:	1885c83a 	sub	r2,r3,r2
8110ee60:	e0bff615 	stw	r2,-40(fp)
		                    		bFeebCh1SetBufferSize( (usiLengthBlocks), 0 );
8110ee64:	e0bff617 	ldw	r2,-40(fp)
8110ee68:	10803fcc 	andi	r2,r2,255
8110ee6c:	000b883a 	mov	r5,zero
8110ee70:	1009883a 	mov	r4,r2
8110ee74:	11059c80 	call	811059c8 <bFeebCh1SetBufferSize>
		                    		bFeebCh1SetBufferSize( (usiLengthBlocks), 1 );
8110ee78:	e0bff617 	ldw	r2,-40(fp)
8110ee7c:	10803fcc 	andi	r2,r2,255
8110ee80:	01400044 	movi	r5,1
8110ee84:	1009883a 	mov	r4,r2
8110ee88:	11059c80 	call	811059c8 <bFeebCh1SetBufferSize>

		                    		bFinal = TRUE;
8110ee8c:	00800044 	movi	r2,1
8110ee90:	e0bff815 	stw	r2,-32(fp)
8110ee94:	00000306 	br	8110eea4 <vFeeTask+0x1344>

		                    	} else {

		                    		bFinal = FALSE;
8110ee98:	e03ff815 	stw	zero,-32(fp)
		                    		usiLengthBlocks = SDMA_MAX_BLOCKS;
8110ee9c:	00800404 	movi	r2,16
8110eea0:	e0bff615 	stw	r2,-40(fp)
		                    	}

		                    	if ( ucMemUsing == 0  ) {
8110eea4:	e0bff303 	ldbu	r2,-52(fp)
8110eea8:	1000111e 	bne	r2,zero,8110eef0 <vFeeTask+0x1390>
		                    		//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
		                    		bDmaReturn = bSdmaDmaM1Transfer(xCcdMapLocal->ulAddrI, usiLengthBlocks, ucIterationSide, pxNFee->ucId);
8110eeac:	e0bff417 	ldw	r2,-48(fp)
8110eeb0:	10800217 	ldw	r2,8(r2)
8110eeb4:	1011883a 	mov	r8,r2
8110eeb8:	e0bff617 	ldw	r2,-40(fp)
8110eebc:	10ffffcc 	andi	r3,r2,65535
8110eec0:	d0a05603 	ldbu	r2,-32424(gp)
8110eec4:	11003fcc 	andi	r4,r2,255
8110eec8:	d0a05317 	ldw	r2,-32436(gp)
8110eecc:	10800003 	ldbu	r2,0(r2)
8110eed0:	10803fcc 	andi	r2,r2,255
8110eed4:	100f883a 	mov	r7,r2
8110eed8:	200d883a 	mov	r6,r4
8110eedc:	180b883a 	mov	r5,r3
8110eee0:	4009883a 	mov	r4,r8
8110eee4:	1103c900 	call	81103c90 <bSdmaDmaM1Transfer>
8110eee8:	e0bff715 	stw	r2,-36(fp)
8110eeec:	00001006 	br	8110ef30 <vFeeTask+0x13d0>
		                    	} else {

		                    		//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
		                    		bDmaReturn = bSdmaDmaM2Transfer(xCcdMapLocal->ulAddrI, usiLengthBlocks, ucIterationSide, pxNFee->ucId);
8110eef0:	e0bff417 	ldw	r2,-48(fp)
8110eef4:	10800217 	ldw	r2,8(r2)
8110eef8:	1011883a 	mov	r8,r2
8110eefc:	e0bff617 	ldw	r2,-40(fp)
8110ef00:	10ffffcc 	andi	r3,r2,65535
8110ef04:	d0a05603 	ldbu	r2,-32424(gp)
8110ef08:	11003fcc 	andi	r4,r2,255
8110ef0c:	d0a05317 	ldw	r2,-32436(gp)
8110ef10:	10800003 	ldbu	r2,0(r2)
8110ef14:	10803fcc 	andi	r2,r2,255
8110ef18:	100f883a 	mov	r7,r2
8110ef1c:	200d883a 	mov	r6,r4
8110ef20:	180b883a 	mov	r5,r3
8110ef24:	4009883a 	mov	r4,r8
8110ef28:	11040ec0 	call	811040ec <bSdmaDmaM2Transfer>
8110ef2c:	e0bff715 	stw	r2,-36(fp)
		                    	}


		                    	if ( bDmaReturn = TRUE ) {
8110ef30:	00800044 	movi	r2,1
8110ef34:	e0bff715 	stw	r2,-36(fp)

									/* Value of xCcdMapLocal->ulAddrI already set in the last iteration */
									xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*usiLengthBlocks;
8110ef38:	e0bff417 	ldw	r2,-48(fp)
8110ef3c:	10c00217 	ldw	r3,8(r2)
8110ef40:	e0bff617 	ldw	r2,-40(fp)
8110ef44:	10802224 	muli	r2,r2,136
8110ef48:	1887883a 	add	r3,r3,r2
8110ef4c:	e0bff417 	ldw	r2,-48(fp)
8110ef50:	10c00215 	stw	r3,8(r2)
									xCcdMapLocal->ulBlockI += usiLengthBlocks;
8110ef54:	e0bff417 	ldw	r2,-48(fp)
8110ef58:	10c00117 	ldw	r3,4(r2)
8110ef5c:	e0bff617 	ldw	r2,-40(fp)
8110ef60:	1887883a 	add	r3,r3,r2
8110ef64:	e0bff417 	ldw	r2,-48(fp)
8110ef68:	10c00115 	stw	r3,4(r2)
										fprintf(fp,"\n-- Can't write ib the DMA \n ");
									#endif
									bFinal = FALSE;
		                    	}

		                    	OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110ef6c:	e0fff303 	ldbu	r3,-52(fp)
8110ef70:	00a045b4 	movhi	r2,33046
8110ef74:	108d0d04 	addi	r2,r2,13364
8110ef78:	180690fa 	slli	r3,r3,3
8110ef7c:	10c5883a 	add	r2,r2,r3
8110ef80:	10800017 	ldw	r2,0(r2)
8110ef84:	1009883a 	mov	r4,r2
8110ef88:	113ca580 	call	8113ca58 <OSMutexPost>
		                    	pxNFee->xControl.bDMALocked = FALSE;
8110ef8c:	d0a05317 	ldw	r2,-32436(gp)
8110ef90:	10002215 	stw	zero,136(r2)
		                        /* Send message telling to controller that is not using the DMA any more */
								bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
8110ef94:	d0a05317 	ldw	r2,-32436(gp)
8110ef98:	10800003 	ldbu	r2,0(r2)
8110ef9c:	10803fcc 	andi	r2,r2,255
8110efa0:	100d883a 	mov	r6,r2
8110efa4:	000b883a 	mov	r5,zero
8110efa8:	01002044 	movi	r4,129
8110efac:	1110a540 	call	81110a54 <bSendGiveBackNFeeCtrl>

								/* Just to see the progress */
								if ( ((xCcdMapLocal->ulBlockI) % 16384 == 0) ) {
8110efb0:	e0bff417 	ldw	r2,-48(fp)
8110efb4:	10800117 	ldw	r2,4(r2)
8110efb8:	108fffcc 	andi	r2,r2,16383
8110efbc:	1000081e 	bne	r2,zero,8110efe0 <vFeeTask+0x1480>

									#ifdef DEBUG_ON
										fprintf(fp,"\nblock: %u ", xCcdMapLocal->ulBlockI);
8110efc0:	d0e06217 	ldw	r3,-32376(gp)
8110efc4:	e0bff417 	ldw	r2,-48(fp)
8110efc8:	10800117 	ldw	r2,4(r2)
8110efcc:	100d883a 	mov	r6,r2
8110efd0:	01604574 	movhi	r5,33045
8110efd4:	2970b604 	addi	r5,r5,-15656
8110efd8:	1809883a 	mov	r4,r3
8110efdc:	1120fa40 	call	81120fa4 <fprintf>
									#endif
								}


								if ( bFinal == TRUE ) {
8110efe0:	e0bff817 	ldw	r2,-32(fp)
8110efe4:	10800058 	cmpnei	r2,r2,1
8110efe8:	1000041e 	bne	r2,zero,8110effc <vFeeTask+0x149c>
									pxNFee->xControl.eMode = sEndTransmission;
8110efec:	d0a05317 	ldw	r2,-32436(gp)
8110eff0:	00c002c4 	movi	r3,11
8110eff4:	10c02c15 	stw	r3,176(r2)
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110eff8:	00007906 	br	8110f1e0 <vFeeTask+0x1680>


								if ( bFinal == TRUE ) {
									pxNFee->xControl.eMode = sEndTransmission;
								} else {
									bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
8110effc:	d0a05317 	ldw	r2,-32436(gp)
8110f000:	10800003 	ldbu	r2,0(r2)
8110f004:	10803fcc 	andi	r2,r2,255
8110f008:	100d883a 	mov	r6,r2
8110f00c:	000b883a 	mov	r5,zero
8110f010:	01002004 	movi	r4,128
8110f014:	11109b00 	call	811109b0 <bSendRequestNFeeCtrl>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110f018:	00007106 	br	8110f1e0 <vFeeTask+0x1680>
									bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
								}

		                    }
						} else {
							vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
8110f01c:	d0a05317 	ldw	r2,-32436(gp)
8110f020:	e0fffe17 	ldw	r3,-8(fp)
8110f024:	180b883a 	mov	r5,r3
8110f028:	1009883a 	mov	r4,r2
8110f02c:	110f7900 	call	8110f790 <vQCmdFEEinFullPattern>

							if ( pxNFee->xControl.bWatingSync == FALSE ) {
8110f030:	d0a05317 	ldw	r2,-32436(gp)
8110f034:	10802817 	ldw	r2,160(r2)
8110f038:	1000691e 	bne	r2,zero,8110f1e0 <vFeeTask+0x1680>
								pxNFee->xControl.eMode = pxNFee->xControl.eNextMode;
8110f03c:	d0a05317 	ldw	r2,-32436(gp)
8110f040:	d0e05317 	ldw	r3,-32436(gp)
8110f044:	18c02d17 	ldw	r3,180(r3)
8110f048:	10c02c15 	stw	r3,176(r2)
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110f04c:	00006406 	br	8110f1e0 <vFeeTask+0x1680>
							}
						}

				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110f050:	d0e06217 	ldw	r3,-32376(gp)
8110f054:	d0a05317 	ldw	r2,-32436(gp)
8110f058:	10800003 	ldbu	r2,0(r2)
8110f05c:	10803fcc 	andi	r2,r2,255
8110f060:	100d883a 	mov	r6,r2
8110f064:	01604574 	movhi	r5,33045
8110f068:	29703d04 	addi	r5,r5,-16140
8110f06c:	1809883a 	mov	r4,r3
8110f070:	1120fa40 	call	81120fa4 <fprintf>
					#endif
				}

				break;
8110f074:	00005a06 	br	8110f1e0 <vFeeTask+0x1680>

			case sEndTransmission:

				pxNFee->xControl.bWatingSync = TRUE;
8110f078:	d0a05317 	ldw	r2,-32436(gp)
8110f07c:	00c00044 	movi	r3,1
8110f080:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110f084:	d0a05317 	ldw	r2,-32436(gp)
8110f088:	10002315 	stw	zero,140(r2)

				if ( xDefaults.bDataPacket == TRUE ) {
8110f08c:	00a045b4 	movhi	r2,33046
8110f090:	1099c904 	addi	r2,r2,26404
8110f094:	10800817 	ldw	r2,32(r2)
8110f098:	10800058 	cmpnei	r2,r2,1
8110f09c:	1000121e 	bne	r2,zero,8110f0e8 <vFeeTask+0x1588>

					if ( pxNFee->xControl.eNextMode == sToFeeStandBy ) {
8110f0a0:	d0a05317 	ldw	r2,-32436(gp)
8110f0a4:	10802d17 	ldw	r2,180(r2)
8110f0a8:	10800198 	cmpnei	r2,r2,6
8110f0ac:	1000071e 	bne	r2,zero,8110f0cc <vFeeTask+0x156c>
						pxNFee->xControl.eMode =  sFeeWaitingSync;
8110f0b0:	d0a05317 	ldw	r2,-32436(gp)
8110f0b4:	00c00304 	movi	r3,12
8110f0b8:	10c02c15 	stw	r3,176(r2)
						pxNFee->xControl.eNextMode =  sToFeeStandBy;
8110f0bc:	d0a05317 	ldw	r2,-32436(gp)
8110f0c0:	00c00184 	movi	r3,6
8110f0c4:	10c02d15 	stw	r3,180(r2)
					pxNFee->xControl.eNextMode =  sToFeeStandBy;
				}


				bFinal == FALSE;
				break;
8110f0c8:	00004606 	br	8110f1e4 <vFeeTask+0x1684>

					if ( pxNFee->xControl.eNextMode == sToFeeStandBy ) {
						pxNFee->xControl.eMode =  sFeeWaitingSync;
						pxNFee->xControl.eNextMode =  sToFeeStandBy;
					} else {
						pxNFee->xControl.eMode =  sNextPatternIteration;
8110f0cc:	d0a05317 	ldw	r2,-32436(gp)
8110f0d0:	00c00284 	movi	r3,10
8110f0d4:	10c02c15 	stw	r3,176(r2)
						pxNFee->xControl.eNextMode =  sFeeWaitingSync;
8110f0d8:	d0a05317 	ldw	r2,-32436(gp)
8110f0dc:	00c00304 	movi	r3,12
8110f0e0:	10c02d15 	stw	r3,180(r2)
					pxNFee->xControl.eNextMode =  sToFeeStandBy;
				}


				bFinal == FALSE;
				break;
8110f0e4:	00003f06 	br	8110f1e4 <vFeeTask+0x1684>
						pxNFee->xControl.eMode =  sNextPatternIteration;
						pxNFee->xControl.eNextMode =  sFeeWaitingSync;
					}

				} else {
					pxNFee->xControl.eMode =  sFeeWaitingSync;
8110f0e8:	d0a05317 	ldw	r2,-32436(gp)
8110f0ec:	00c00304 	movi	r3,12
8110f0f0:	10c02c15 	stw	r3,176(r2)
					pxNFee->xControl.eNextMode =  sToFeeStandBy;
8110f0f4:	d0a05317 	ldw	r2,-32436(gp)
8110f0f8:	00c00184 	movi	r3,6
8110f0fc:	10c02d15 	stw	r3,180(r2)
				}


				bFinal == FALSE;
				break;
8110f100:	00003806 	br	8110f1e4 <vFeeTask+0x1684>

			case sFeeWaitingSync:

				#ifdef DEBUG_ON
					fprintf(fp,"NFEE-%hu Task: (sFeeWaitingSync)\n", pxNFee->ucId);
8110f104:	d0e06217 	ldw	r3,-32376(gp)
8110f108:	d0a05317 	ldw	r2,-32436(gp)
8110f10c:	10800003 	ldbu	r2,0(r2)
8110f110:	10803fcc 	andi	r2,r2,255
8110f114:	100d883a 	mov	r6,r2
8110f118:	01604574 	movhi	r5,33045
8110f11c:	2970b904 	addi	r5,r5,-15644
8110f120:	1809883a 	mov	r4,r3
8110f124:	1120fa40 	call	81120fa4 <fprintf>
				#endif

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110f128:	d0a05317 	ldw	r2,-32436(gp)
8110f12c:	10800003 	ldbu	r2,0(r2)
8110f130:	10803fcc 	andi	r2,r2,255
8110f134:	1085883a 	add	r2,r2,r2
8110f138:	1087883a 	add	r3,r2,r2
8110f13c:	d0a06a04 	addi	r2,gp,-32344
8110f140:	1885883a 	add	r2,r3,r2
8110f144:	10800017 	ldw	r2,0(r2)
8110f148:	e0fffd04 	addi	r3,fp,-12
8110f14c:	180d883a 	mov	r6,r3
8110f150:	000b883a 	mov	r5,zero
8110f154:	1009883a 	mov	r4,r2
8110f158:	113d5c80 	call	8113d5c8 <OSQPend>
8110f15c:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code != OS_ERR_NONE ) {
8110f160:	e0bffd03 	ldbu	r2,-12(fp)
8110f164:	10803fcc 	andi	r2,r2,255
8110f168:	10000a26 	beq	r2,zero,8110f194 <vFeeTask+0x1634>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ (sFeeWaitingSync)\n", pxNFee->ucId);
8110f16c:	d0e06217 	ldw	r3,-32376(gp)
8110f170:	d0a05317 	ldw	r2,-32436(gp)
8110f174:	10800003 	ldbu	r2,0(r2)
8110f178:	10803fcc 	andi	r2,r2,255
8110f17c:	100d883a 	mov	r6,r2
8110f180:	01604574 	movhi	r5,33045
8110f184:	2970c204 	addi	r5,r5,-15608
8110f188:	1809883a 	mov	r4,r3
8110f18c:	1120fa40 	call	81120fa4 <fprintf>
					#endif
				} else {
					vQCmdFEEinWaitingSync( pxNFee, uiCmdFEE.ulWord  );
				}

				break;
8110f190:	00001406 	br	8110f1e4 <vFeeTask+0x1684>
				if ( error_code != OS_ERR_NONE ) {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ (sFeeWaitingSync)\n", pxNFee->ucId);
					#endif
				} else {
					vQCmdFEEinWaitingSync( pxNFee, uiCmdFEE.ulWord  );
8110f194:	d0a05317 	ldw	r2,-32436(gp)
8110f198:	e0fffe17 	ldw	r3,-8(fp)
8110f19c:	180b883a 	mov	r5,r3
8110f1a0:	1009883a 	mov	r4,r2
8110f1a4:	110f1e80 	call	8110f1e8 <vQCmdFEEinWaitingSync>
				}

				break;
8110f1a8:	00000e06 	br	8110f1e4 <vFeeTask+0x1684>


			default:
				pxNFee->xControl.eMode = sToFeeConfig;
8110f1ac:	d0a05317 	ldw	r2,-32436(gp)
8110f1b0:	00c00144 	movi	r3,5
8110f1b4:	10c02c15 	stw	r3,176(r2)
				#ifdef DEBUG_ON
					fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
8110f1b8:	d0e06217 	ldw	r3,-32376(gp)
8110f1bc:	d0a05317 	ldw	r2,-32436(gp)
8110f1c0:	10800003 	ldbu	r2,0(r2)
8110f1c4:	10803fcc 	andi	r2,r2,255
8110f1c8:	100d883a 	mov	r6,r2
8110f1cc:	01604574 	movhi	r5,33045
8110f1d0:	2970d304 	addi	r5,r5,-15540
8110f1d4:	1809883a 	mov	r4,r3
8110f1d8:	1120fa40 	call	81120fa4 <fprintf>
				#endif
				break;
8110f1dc:	00000106 	br	8110f1e4 <vFeeTask+0x1684>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110f1e0:	0001883a 	nop
					fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
				#endif
				break;
		}

	}
8110f1e4:	003a7406 	br	8110dbb8 <__reset+0xfb0edbb8>

8110f1e8 <vQCmdFEEinWaitingSync>:

}

void vQCmdFEEinWaitingSync( TNFee *pxNFeeP, unsigned int cmd ) {
8110f1e8:	defffb04 	addi	sp,sp,-20
8110f1ec:	de00012e 	bgeu	sp,et,8110f1f4 <vQCmdFEEinWaitingSync+0xc>
8110f1f0:	003b68fa 	trap	3
8110f1f4:	dfc00415 	stw	ra,16(sp)
8110f1f8:	df000315 	stw	fp,12(sp)
8110f1fc:	df000304 	addi	fp,sp,12
8110f200:	e13ffe15 	stw	r4,-8(fp)
8110f204:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110f208:	e0bfff17 	ldw	r2,-4(fp)
8110f20c:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110f210:	e0bffdc3 	ldbu	r2,-9(fp)
8110f214:	10c03fcc 	andi	r3,r2,255
8110f218:	e0bffe17 	ldw	r2,-8(fp)
8110f21c:	10800003 	ldbu	r2,0(r2)
8110f220:	10803fcc 	andi	r2,r2,255
8110f224:	10800444 	addi	r2,r2,17
8110f228:	1880631e 	bne	r3,r2,8110f3b8 <vQCmdFEEinWaitingSync+0x1d0>

		switch (uiCmdFEEL.ucByte[2]) {
8110f22c:	e0bffd83 	ldbu	r2,-10(fp)
8110f230:	10803fcc 	andi	r2,r2,255
8110f234:	10c02860 	cmpeqi	r3,r2,161
8110f238:	18001a1e 	bne	r3,zero,8110f2a4 <vQCmdFEEinWaitingSync+0xbc>
8110f23c:	10c02888 	cmpgei	r3,r2,162
8110f240:	18000c1e 	bne	r3,zero,8110f274 <vQCmdFEEinWaitingSync+0x8c>
8110f244:	10c00120 	cmpeqi	r3,r2,4
8110f248:	18001f1e 	bne	r3,zero,8110f2c8 <vQCmdFEEinWaitingSync+0xe0>
8110f24c:	10c00148 	cmpgei	r3,r2,5
8110f250:	1800031e 	bne	r3,zero,8110f260 <vQCmdFEEinWaitingSync+0x78>
8110f254:	10800060 	cmpeqi	r2,r2,1
8110f258:	1000121e 	bne	r2,zero,8110f2a4 <vQCmdFEEinWaitingSync+0xbc>
8110f25c:	00004c06 	br	8110f390 <vQCmdFEEinWaitingSync+0x1a8>
8110f260:	10c00220 	cmpeqi	r3,r2,8
8110f264:	1800221e 	bne	r3,zero,8110f2f0 <vQCmdFEEinWaitingSync+0x108>
8110f268:	108023e0 	cmpeqi	r2,r2,143
8110f26c:	10003e1e 	bne	r2,zero,8110f368 <vQCmdFEEinWaitingSync+0x180>
8110f270:	00004706 	br	8110f390 <vQCmdFEEinWaitingSync+0x1a8>
8110f274:	10c03888 	cmpgei	r3,r2,226
8110f278:	1800071e 	bne	r3,zero,8110f298 <vQCmdFEEinWaitingSync+0xb0>
8110f27c:	10c03808 	cmpgei	r3,r2,224
8110f280:	1800321e 	bne	r3,zero,8110f34c <vQCmdFEEinWaitingSync+0x164>
8110f284:	10c02920 	cmpeqi	r3,r2,164
8110f288:	18000f1e 	bne	r3,zero,8110f2c8 <vQCmdFEEinWaitingSync+0xe0>
8110f28c:	10802a20 	cmpeqi	r2,r2,168
8110f290:	1000171e 	bne	r2,zero,8110f2f0 <vQCmdFEEinWaitingSync+0x108>
8110f294:	00003e06 	br	8110f390 <vQCmdFEEinWaitingSync+0x1a8>
8110f298:	10803c20 	cmpeqi	r2,r2,240
8110f29c:	10001e1e 	bne	r2,zero,8110f318 <vQCmdFEEinWaitingSync+0x130>
8110f2a0:	00003b06 	br	8110f390 <vQCmdFEEinWaitingSync+0x1a8>
			case M_FEE_CONFIG:
			case M_FEE_CONFIG_FORCED: /* Standby to Config is always forced mode */
				pxNFeeP->xControl.bWatingSync = FALSE;
8110f2a4:	e0bffe17 	ldw	r2,-8(fp)
8110f2a8:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8110f2ac:	e0bffe17 	ldw	r2,-8(fp)
8110f2b0:	00c00144 	movi	r3,5
8110f2b4:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
8110f2b8:	e0bffe17 	ldw	r2,-8(fp)
8110f2bc:	00c00144 	movi	r3,5
8110f2c0:	10c02d15 	stw	r3,180(r2)
				break;
8110f2c4:	00003c06 	br	8110f3b8 <vQCmdFEEinWaitingSync+0x1d0>
			case M_FEE_STANDBY_FORCED:
			case M_FEE_STANDBY:
				pxNFeeP->xControl.bWatingSync = TRUE;
8110f2c8:	e0bffe17 	ldw	r2,-8(fp)
8110f2cc:	00c00044 	movi	r3,1
8110f2d0:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync; /*sSIMTestFullPattern*/
8110f2d4:	e0bffe17 	ldw	r2,-8(fp)
8110f2d8:	00c00304 	movi	r3,12
8110f2dc:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110f2e0:	e0bffe17 	ldw	r2,-8(fp)
8110f2e4:	00c00184 	movi	r3,6
8110f2e8:	10c02d15 	stw	r3,180(r2)
				break;
8110f2ec:	00003206 	br	8110f3b8 <vQCmdFEEinWaitingSync+0x1d0>
			case M_FEE_FULL_PATTERN:
			case M_FEE_FULL_PATTERN_FORCED: /* There are no forced mode to go to the Pattern Mode */
				pxNFeeP->xControl.bWatingSync = TRUE;
8110f2f0:	e0bffe17 	ldw	r2,-8(fp)
8110f2f4:	00c00044 	movi	r3,1
8110f2f8:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
8110f2fc:	e0bffe17 	ldw	r2,-8(fp)
8110f300:	00c00284 	movi	r3,10
8110f304:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
8110f308:	e0bffe17 	ldw	r2,-8(fp)
8110f30c:	00c00304 	movi	r3,12
8110f310:	10c02d15 	stw	r3,180(r2)
				break;
8110f314:	00002806 	br	8110f3b8 <vQCmdFEEinWaitingSync+0x1d0>
			case M_FEE_RMAP:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: RMAP Message Received\n", pxNFeeP->ucId);
8110f318:	d0e06217 	ldw	r3,-32376(gp)
8110f31c:	e0bffe17 	ldw	r2,-8(fp)
8110f320:	10800003 	ldbu	r2,0(r2)
8110f324:	10803fcc 	andi	r2,r2,255
8110f328:	100d883a 	mov	r6,r2
8110f32c:	01604574 	movhi	r5,33045
8110f330:	2970de04 	addi	r5,r5,-15496
8110f334:	1809883a 	mov	r4,r3
8110f338:	1120fa40 	call	81120fa4 <fprintf>
				#endif
				/* Perform some actions, check if is a valid command for this mode of operation  */
				vQCmdFeeRMAPWaitingSync( pxNFeeP, cmd );
8110f33c:	e17fff17 	ldw	r5,-4(fp)
8110f340:	e13ffe17 	ldw	r4,-8(fp)
8110f344:	111032c0 	call	8111032c <vQCmdFeeRMAPWaitingSync>
				break;
8110f348:	00001b06 	br	8110f3b8 <vQCmdFEEinWaitingSync+0x1d0>
			case M_SYNC:
			case M_MASTER_SYNC:
				/* Warning */
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
8110f34c:	e0bffe17 	ldw	r2,-8(fp)
8110f350:	10c02d17 	ldw	r3,180(r2)
8110f354:	e0bffe17 	ldw	r2,-8(fp)
8110f358:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.bWatingSync = FALSE;
8110f35c:	e0bffe17 	ldw	r2,-8(fp)
8110f360:	10002815 	stw	zero,160(r2)

				break;
8110f364:	00001406 	br	8110f3b8 <vQCmdFEEinWaitingSync+0x1d0>
			case M_FEE_DMA_ACCESS:
				pxNFeeP->xControl.bUsingDMA = FALSE;
8110f368:	e0bffe17 	ldw	r2,-8(fp)
8110f36c:	10002315 	stw	zero,140(r2)
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
8110f370:	e0bffe17 	ldw	r2,-8(fp)
8110f374:	10800003 	ldbu	r2,0(r2)
8110f378:	10803fcc 	andi	r2,r2,255
8110f37c:	100d883a 	mov	r6,r2
8110f380:	000b883a 	mov	r5,zero
8110f384:	01002044 	movi	r4,129
8110f388:	1110a540 	call	81110a54 <bSendGiveBackNFeeCtrl>
				break;
8110f38c:	00000a06 	br	8110f3b8 <vQCmdFEEinWaitingSync+0x1d0>
			default:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
8110f390:	d0e06217 	ldw	r3,-32376(gp)
8110f394:	e0bffe17 	ldw	r2,-8(fp)
8110f398:	10800003 	ldbu	r2,0(r2)
8110f39c:	10803fcc 	andi	r2,r2,255
8110f3a0:	100d883a 	mov	r6,r2
8110f3a4:	01604574 	movhi	r5,33045
8110f3a8:	2970e804 	addi	r5,r5,-15456
8110f3ac:	1809883a 	mov	r4,r3
8110f3b0:	1120fa40 	call	81120fa4 <fprintf>
				#endif
				break;
8110f3b4:	0001883a 	nop
		}
	}
}
8110f3b8:	0001883a 	nop
8110f3bc:	e037883a 	mov	sp,fp
8110f3c0:	dfc00117 	ldw	ra,4(sp)
8110f3c4:	df000017 	ldw	fp,0(sp)
8110f3c8:	dec00204 	addi	sp,sp,8
8110f3cc:	f800283a 	ret

8110f3d0 <vQCmdFEEinConfig>:


void vQCmdFEEinConfig( TNFee *pxNFeeP, unsigned int cmd ) {
8110f3d0:	defffb04 	addi	sp,sp,-20
8110f3d4:	de00012e 	bgeu	sp,et,8110f3dc <vQCmdFEEinConfig+0xc>
8110f3d8:	003b68fa 	trap	3
8110f3dc:	dfc00415 	stw	ra,16(sp)
8110f3e0:	df000315 	stw	fp,12(sp)
8110f3e4:	df000304 	addi	fp,sp,12
8110f3e8:	e13ffe15 	stw	r4,-8(fp)
8110f3ec:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110f3f0:	e0bfff17 	ldw	r2,-4(fp)
8110f3f4:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110f3f8:	e0bffdc3 	ldbu	r2,-9(fp)
8110f3fc:	10c03fcc 	andi	r3,r2,255
8110f400:	e0bffe17 	ldw	r2,-8(fp)
8110f404:	10800003 	ldbu	r2,0(r2)
8110f408:	10803fcc 	andi	r2,r2,255
8110f40c:	10800444 	addi	r2,r2,17
8110f410:	18805a1e 	bne	r3,r2,8110f57c <vQCmdFEEinConfig+0x1ac>

		switch (uiCmdFEEL.ucByte[2]) {
8110f414:	e0bffd83 	ldbu	r2,-10(fp)
8110f418:	10803fcc 	andi	r2,r2,255
8110f41c:	10c02860 	cmpeqi	r3,r2,161
8110f420:	18001a1e 	bne	r3,zero,8110f48c <vQCmdFEEinConfig+0xbc>
8110f424:	10c02888 	cmpgei	r3,r2,162
8110f428:	18000c1e 	bne	r3,zero,8110f45c <vQCmdFEEinConfig+0x8c>
8110f42c:	10c00120 	cmpeqi	r3,r2,4
8110f430:	1800201e 	bne	r3,zero,8110f4b4 <vQCmdFEEinConfig+0xe4>
8110f434:	10c00148 	cmpgei	r3,r2,5
8110f438:	1800031e 	bne	r3,zero,8110f448 <vQCmdFEEinConfig+0x78>
8110f43c:	10800060 	cmpeqi	r2,r2,1
8110f440:	1000121e 	bne	r2,zero,8110f48c <vQCmdFEEinConfig+0xbc>
8110f444:	00004206 	br	8110f550 <vQCmdFEEinConfig+0x180>
8110f448:	10c00220 	cmpeqi	r3,r2,8
8110f44c:	1800221e 	bne	r3,zero,8110f4d8 <vQCmdFEEinConfig+0x108>
8110f450:	108023e0 	cmpeqi	r2,r2,143
8110f454:	1000341e 	bne	r2,zero,8110f528 <vQCmdFEEinConfig+0x158>
8110f458:	00003d06 	br	8110f550 <vQCmdFEEinConfig+0x180>
8110f45c:	10c03888 	cmpgei	r3,r2,226
8110f460:	1800071e 	bne	r3,zero,8110f480 <vQCmdFEEinConfig+0xb0>
8110f464:	10c03808 	cmpgei	r3,r2,224
8110f468:	1800431e 	bne	r3,zero,8110f578 <vQCmdFEEinConfig+0x1a8>
8110f46c:	10c02920 	cmpeqi	r3,r2,164
8110f470:	1800101e 	bne	r3,zero,8110f4b4 <vQCmdFEEinConfig+0xe4>
8110f474:	10802a20 	cmpeqi	r2,r2,168
8110f478:	1000171e 	bne	r2,zero,8110f4d8 <vQCmdFEEinConfig+0x108>
8110f47c:	00003406 	br	8110f550 <vQCmdFEEinConfig+0x180>
8110f480:	10803c20 	cmpeqi	r2,r2,240
8110f484:	10001e1e 	bne	r2,zero,8110f500 <vQCmdFEEinConfig+0x130>
8110f488:	00003106 	br	8110f550 <vQCmdFEEinConfig+0x180>
			case M_FEE_CONFIG_FORCED:
			case M_FEE_CONFIG:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Already in Config mode\n", pxNFeeP->ucId);
8110f48c:	d0e06217 	ldw	r3,-32376(gp)
8110f490:	e0bffe17 	ldw	r2,-8(fp)
8110f494:	10800003 	ldbu	r2,0(r2)
8110f498:	10803fcc 	andi	r2,r2,255
8110f49c:	100d883a 	mov	r6,r2
8110f4a0:	01604574 	movhi	r5,33045
8110f4a4:	2970f904 	addi	r5,r5,-15388
8110f4a8:	1809883a 	mov	r4,r3
8110f4ac:	1120fa40 	call	81120fa4 <fprintf>
				#endif
				break;
8110f4b0:	00003206 	br	8110f57c <vQCmdFEEinConfig+0x1ac>
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
				break;*/
			case M_FEE_STANDBY: /* Config -> StandBy is always forced mode (don't need sync) */
			case M_FEE_STANDBY_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110f4b4:	e0bffe17 	ldw	r2,-8(fp)
8110f4b8:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeStandBy;
8110f4bc:	e0bffe17 	ldw	r2,-8(fp)
8110f4c0:	00c00184 	movi	r3,6
8110f4c4:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110f4c8:	e0bffe17 	ldw	r2,-8(fp)
8110f4cc:	00c00184 	movi	r3,6
8110f4d0:	10c02d15 	stw	r3,180(r2)
				break;				
8110f4d4:	00002906 	br	8110f57c <vQCmdFEEinConfig+0x1ac>
			case M_FEE_FULL_PATTERN_FORCED:
			case M_FEE_FULL_PATTERN:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: Can't go to Full Image Pattern from Config mode\n", pxNFeeP->ucId);
8110f4d8:	d0e06217 	ldw	r3,-32376(gp)
8110f4dc:	e0bffe17 	ldw	r2,-8(fp)
8110f4e0:	10800003 	ldbu	r2,0(r2)
8110f4e4:	10803fcc 	andi	r2,r2,255
8110f4e8:	100d883a 	mov	r6,r2
8110f4ec:	01604574 	movhi	r5,33045
8110f4f0:	29710404 	addi	r5,r5,-15344
8110f4f4:	1809883a 	mov	r4,r3
8110f4f8:	1120fa40 	call	81120fa4 <fprintf>
				#endif
				break;
8110f4fc:	00001f06 	br	8110f57c <vQCmdFEEinConfig+0x1ac>
			case M_FEE_RMAP:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: Shouldn't receive RMAP Messages in this mode (Config Mode)\n", pxNFeeP->ucId);
8110f500:	d0e06217 	ldw	r3,-32376(gp)
8110f504:	e0bffe17 	ldw	r2,-8(fp)
8110f508:	10800003 	ldbu	r2,0(r2)
8110f50c:	10803fcc 	andi	r2,r2,255
8110f510:	100d883a 	mov	r6,r2
8110f514:	01604574 	movhi	r5,33045
8110f518:	29711504 	addi	r5,r5,-15276
8110f51c:	1809883a 	mov	r4,r3
8110f520:	1120fa40 	call	81120fa4 <fprintf>
				#endif
				break;
8110f524:	00001506 	br	8110f57c <vQCmdFEEinConfig+0x1ac>
			case M_FEE_DMA_ACCESS:
				pxNFeeP->xControl.bUsingDMA = FALSE;
8110f528:	e0bffe17 	ldw	r2,-8(fp)
8110f52c:	10002315 	stw	zero,140(r2)
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
8110f530:	e0bffe17 	ldw	r2,-8(fp)
8110f534:	10800003 	ldbu	r2,0(r2)
8110f538:	10803fcc 	andi	r2,r2,255
8110f53c:	100d883a 	mov	r6,r2
8110f540:	000b883a 	mov	r5,zero
8110f544:	01002044 	movi	r4,129
8110f548:	1110a540 	call	81110a54 <bSendGiveBackNFeeCtrl>
				break;
8110f54c:	00000b06 	br	8110f57c <vQCmdFEEinConfig+0x1ac>
			case M_SYNC:
			case M_MASTER_SYNC:
				break;
			default:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
8110f550:	d0e06217 	ldw	r3,-32376(gp)
8110f554:	e0bffe17 	ldw	r2,-8(fp)
8110f558:	10800003 	ldbu	r2,0(r2)
8110f55c:	10803fcc 	andi	r2,r2,255
8110f560:	100d883a 	mov	r6,r2
8110f564:	01604574 	movhi	r5,33045
8110f568:	29712804 	addi	r5,r5,-15200
8110f56c:	1809883a 	mov	r4,r3
8110f570:	1120fa40 	call	81120fa4 <fprintf>
				#endif
				break;
8110f574:	00000106 	br	8110f57c <vQCmdFEEinConfig+0x1ac>
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
				break;
			case M_SYNC:
			case M_MASTER_SYNC:
				break;
8110f578:	0001883a 	nop
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				#endif
				break;
		}
	}
}
8110f57c:	0001883a 	nop
8110f580:	e037883a 	mov	sp,fp
8110f584:	dfc00117 	ldw	ra,4(sp)
8110f588:	df000017 	ldw	fp,0(sp)
8110f58c:	dec00204 	addi	sp,sp,8
8110f590:	f800283a 	ret

8110f594 <vQCmdFEEinStandBy>:

void vQCmdFEEinStandBy( TNFee *pxNFeeP, unsigned int cmd ) {
8110f594:	defffb04 	addi	sp,sp,-20
8110f598:	de00012e 	bgeu	sp,et,8110f5a0 <vQCmdFEEinStandBy+0xc>
8110f59c:	003b68fa 	trap	3
8110f5a0:	dfc00415 	stw	ra,16(sp)
8110f5a4:	df000315 	stw	fp,12(sp)
8110f5a8:	df000304 	addi	fp,sp,12
8110f5ac:	e13ffe15 	stw	r4,-8(fp)
8110f5b0:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110f5b4:	e0bfff17 	ldw	r2,-4(fp)
8110f5b8:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110f5bc:	e0bffdc3 	ldbu	r2,-9(fp)
8110f5c0:	10c03fcc 	andi	r3,r2,255
8110f5c4:	e0bffe17 	ldw	r2,-8(fp)
8110f5c8:	10800003 	ldbu	r2,0(r2)
8110f5cc:	10803fcc 	andi	r2,r2,255
8110f5d0:	10800444 	addi	r2,r2,17
8110f5d4:	1880681e 	bne	r3,r2,8110f778 <vQCmdFEEinStandBy+0x1e4>

		switch (uiCmdFEEL.ucByte[2]) {
8110f5d8:	e0bffd83 	ldbu	r2,-10(fp)
8110f5dc:	10803fcc 	andi	r2,r2,255
8110f5e0:	10c02860 	cmpeqi	r3,r2,161
8110f5e4:	18001a1e 	bne	r3,zero,8110f650 <vQCmdFEEinStandBy+0xbc>
8110f5e8:	10c02888 	cmpgei	r3,r2,162
8110f5ec:	18000c1e 	bne	r3,zero,8110f620 <vQCmdFEEinStandBy+0x8c>
8110f5f0:	10c00120 	cmpeqi	r3,r2,4
8110f5f4:	18001f1e 	bne	r3,zero,8110f674 <vQCmdFEEinStandBy+0xe0>
8110f5f8:	10c00148 	cmpgei	r3,r2,5
8110f5fc:	1800031e 	bne	r3,zero,8110f60c <vQCmdFEEinStandBy+0x78>
8110f600:	10800060 	cmpeqi	r2,r2,1
8110f604:	1000121e 	bne	r2,zero,8110f650 <vQCmdFEEinStandBy+0xbc>
8110f608:	00005006 	br	8110f74c <vQCmdFEEinStandBy+0x1b8>
8110f60c:	10c00220 	cmpeqi	r3,r2,8
8110f610:	1800221e 	bne	r3,zero,8110f69c <vQCmdFEEinStandBy+0x108>
8110f614:	108023e0 	cmpeqi	r2,r2,143
8110f618:	1000421e 	bne	r2,zero,8110f724 <vQCmdFEEinStandBy+0x190>
8110f61c:	00004b06 	br	8110f74c <vQCmdFEEinStandBy+0x1b8>
8110f620:	10c03888 	cmpgei	r3,r2,226
8110f624:	1800071e 	bne	r3,zero,8110f644 <vQCmdFEEinStandBy+0xb0>
8110f628:	10c03808 	cmpgei	r3,r2,224
8110f62c:	1800321e 	bne	r3,zero,8110f6f8 <vQCmdFEEinStandBy+0x164>
8110f630:	10c02920 	cmpeqi	r3,r2,164
8110f634:	18000f1e 	bne	r3,zero,8110f674 <vQCmdFEEinStandBy+0xe0>
8110f638:	10802a20 	cmpeqi	r2,r2,168
8110f63c:	1000171e 	bne	r2,zero,8110f69c <vQCmdFEEinStandBy+0x108>
8110f640:	00004206 	br	8110f74c <vQCmdFEEinStandBy+0x1b8>
8110f644:	10803c20 	cmpeqi	r2,r2,240
8110f648:	10001e1e 	bne	r2,zero,8110f6c4 <vQCmdFEEinStandBy+0x130>
8110f64c:	00003f06 	br	8110f74c <vQCmdFEEinStandBy+0x1b8>
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
				break;*/
			case M_FEE_CONFIG:
			case M_FEE_CONFIG_FORCED: /* Standby to Config is always forced mode */
				pxNFeeP->xControl.bWatingSync = FALSE;
8110f650:	e0bffe17 	ldw	r2,-8(fp)
8110f654:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8110f658:	e0bffe17 	ldw	r2,-8(fp)
8110f65c:	00c00144 	movi	r3,5
8110f660:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
8110f664:	e0bffe17 	ldw	r2,-8(fp)
8110f668:	00c00144 	movi	r3,5
8110f66c:	10c02d15 	stw	r3,180(r2)
				break;				
8110f670:	00004106 	br	8110f778 <vQCmdFEEinStandBy+0x1e4>
			case M_FEE_STANDBY_FORCED:
			case M_FEE_STANDBY:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Already in Stand by mode\n", pxNFeeP->ucId);
8110f674:	d0e06217 	ldw	r3,-32376(gp)
8110f678:	e0bffe17 	ldw	r2,-8(fp)
8110f67c:	10800003 	ldbu	r2,0(r2)
8110f680:	10803fcc 	andi	r2,r2,255
8110f684:	100d883a 	mov	r6,r2
8110f688:	01604574 	movhi	r5,33045
8110f68c:	29713904 	addi	r5,r5,-15132
8110f690:	1809883a 	mov	r4,r3
8110f694:	1120fa40 	call	81120fa4 <fprintf>
				#endif
				break;
8110f698:	00003706 	br	8110f778 <vQCmdFEEinStandBy+0x1e4>
			case M_FEE_FULL_PATTERN:
			case M_FEE_FULL_PATTERN_FORCED: /* There are no forced mode to go to the Pattern Mode */
				pxNFeeP->xControl.bWatingSync = TRUE;
8110f69c:	e0bffe17 	ldw	r2,-8(fp)
8110f6a0:	00c00044 	movi	r3,1
8110f6a4:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
8110f6a8:	e0bffe17 	ldw	r2,-8(fp)
8110f6ac:	00c00284 	movi	r3,10
8110f6b0:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
8110f6b4:	e0bffe17 	ldw	r2,-8(fp)
8110f6b8:	00c00304 	movi	r3,12
8110f6bc:	10c02d15 	stw	r3,180(r2)
				break;
8110f6c0:	00002d06 	br	8110f778 <vQCmdFEEinStandBy+0x1e4>

			case M_FEE_RMAP:
				vQCmdFeeRMAPinStandBy( pxNFeeP, cmd );
8110f6c4:	e17fff17 	ldw	r5,-4(fp)
8110f6c8:	e13ffe17 	ldw	r4,-8(fp)
8110f6cc:	110f9c00 	call	8110f9c0 <vQCmdFeeRMAPinStandBy>

				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: RMAP Message Received\n", pxNFeeP->ucId);
8110f6d0:	d0e06217 	ldw	r3,-32376(gp)
8110f6d4:	e0bffe17 	ldw	r2,-8(fp)
8110f6d8:	10800003 	ldbu	r2,0(r2)
8110f6dc:	10803fcc 	andi	r2,r2,255
8110f6e0:	100d883a 	mov	r6,r2
8110f6e4:	01604574 	movhi	r5,33045
8110f6e8:	2970de04 	addi	r5,r5,-15496
8110f6ec:	1809883a 	mov	r4,r3
8110f6f0:	1120fa40 	call	81120fa4 <fprintf>
				#endif
				/* Perform some actions, check if is a valid command for this mode of operation  */

				break;
8110f6f4:	00002006 	br	8110f778 <vQCmdFEEinStandBy+0x1e4>


			case M_SYNC:
			case M_MASTER_SYNC:
				/* Warning */
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
8110f6f8:	e0bffe17 	ldw	r2,-8(fp)
8110f6fc:	10802c17 	ldw	r2,176(r2)
8110f700:	10800318 	cmpnei	r2,r2,12
8110f704:	10001b1e 	bne	r2,zero,8110f774 <vQCmdFEEinStandBy+0x1e0>
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
8110f708:	e0bffe17 	ldw	r2,-8(fp)
8110f70c:	10c02d17 	ldw	r3,180(r2)
8110f710:	e0bffe17 	ldw	r2,-8(fp)
8110f714:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.bWatingSync = FALSE;
8110f718:	e0bffe17 	ldw	r2,-8(fp)
8110f71c:	10002815 	stw	zero,160(r2)
				}
				break;
8110f720:	00001406 	br	8110f774 <vQCmdFEEinStandBy+0x1e0>
			case M_FEE_DMA_ACCESS:
				pxNFeeP->xControl.bUsingDMA = FALSE;
8110f724:	e0bffe17 	ldw	r2,-8(fp)
8110f728:	10002315 	stw	zero,140(r2)
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
8110f72c:	e0bffe17 	ldw	r2,-8(fp)
8110f730:	10800003 	ldbu	r2,0(r2)
8110f734:	10803fcc 	andi	r2,r2,255
8110f738:	100d883a 	mov	r6,r2
8110f73c:	000b883a 	mov	r5,zero
8110f740:	01002044 	movi	r4,129
8110f744:	1110a540 	call	81110a54 <bSendGiveBackNFeeCtrl>
				break;
8110f748:	00000b06 	br	8110f778 <vQCmdFEEinStandBy+0x1e4>
			default:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
8110f74c:	d0e06217 	ldw	r3,-32376(gp)
8110f750:	e0bffe17 	ldw	r2,-8(fp)
8110f754:	10800003 	ldbu	r2,0(r2)
8110f758:	10803fcc 	andi	r2,r2,255
8110f75c:	100d883a 	mov	r6,r2
8110f760:	01604574 	movhi	r5,33045
8110f764:	2970e804 	addi	r5,r5,-15456
8110f768:	1809883a 	mov	r4,r3
8110f76c:	1120fa40 	call	81120fa4 <fprintf>
				#endif
				break;
8110f770:	00000106 	br	8110f778 <vQCmdFEEinStandBy+0x1e4>
				/* Warning */
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
					pxNFeeP->xControl.bWatingSync = FALSE;
				}
				break;
8110f774:	0001883a 	nop
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
				#endif
				break;
		}
	}
}
8110f778:	0001883a 	nop
8110f77c:	e037883a 	mov	sp,fp
8110f780:	dfc00117 	ldw	ra,4(sp)
8110f784:	df000017 	ldw	fp,0(sp)
8110f788:	dec00204 	addi	sp,sp,8
8110f78c:	f800283a 	ret

8110f790 <vQCmdFEEinFullPattern>:



void vQCmdFEEinFullPattern( TNFee *pxNFeeP, unsigned int cmd ){
8110f790:	defffb04 	addi	sp,sp,-20
8110f794:	de00012e 	bgeu	sp,et,8110f79c <vQCmdFEEinFullPattern+0xc>
8110f798:	003b68fa 	trap	3
8110f79c:	dfc00415 	stw	ra,16(sp)
8110f7a0:	df000315 	stw	fp,12(sp)
8110f7a4:	df000304 	addi	fp,sp,12
8110f7a8:	e13ffe15 	stw	r4,-8(fp)
8110f7ac:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110f7b0:	e0bfff17 	ldw	r2,-4(fp)
8110f7b4:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110f7b8:	e0bffdc3 	ldbu	r2,-9(fp)
8110f7bc:	10c03fcc 	andi	r3,r2,255
8110f7c0:	e0bffe17 	ldw	r2,-8(fp)
8110f7c4:	10800003 	ldbu	r2,0(r2)
8110f7c8:	10803fcc 	andi	r2,r2,255
8110f7cc:	10800444 	addi	r2,r2,17
8110f7d0:	1880751e 	bne	r3,r2,8110f9a8 <vQCmdFEEinFullPattern+0x218>

		switch (uiCmdFEEL.ucByte[2]) {
8110f7d4:	e0bffd83 	ldbu	r2,-10(fp)
8110f7d8:	10803fcc 	andi	r2,r2,255
8110f7dc:	10c02860 	cmpeqi	r3,r2,161
8110f7e0:	1800181e 	bne	r3,zero,8110f844 <vQCmdFEEinFullPattern+0xb4>
8110f7e4:	10c02888 	cmpgei	r3,r2,162
8110f7e8:	18000c1e 	bne	r3,zero,8110f81c <vQCmdFEEinFullPattern+0x8c>
8110f7ec:	10c000a0 	cmpeqi	r3,r2,2
8110f7f0:	18006a1e 	bne	r3,zero,8110f99c <vQCmdFEEinFullPattern+0x20c>
8110f7f4:	10c000c8 	cmpgei	r3,r2,3
8110f7f8:	1800031e 	bne	r3,zero,8110f808 <vQCmdFEEinFullPattern+0x78>
8110f7fc:	10800060 	cmpeqi	r2,r2,1
8110f800:	1000101e 	bne	r2,zero,8110f844 <vQCmdFEEinFullPattern+0xb4>
8110f804:	00005b06 	br	8110f974 <vQCmdFEEinFullPattern+0x1e4>
8110f808:	10c00120 	cmpeqi	r3,r2,4
8110f80c:	1800161e 	bne	r3,zero,8110f868 <vQCmdFEEinFullPattern+0xd8>
8110f810:	10800220 	cmpeqi	r2,r2,8
8110f814:	1000351e 	bne	r2,zero,8110f8ec <vQCmdFEEinFullPattern+0x15c>
8110f818:	00005606 	br	8110f974 <vQCmdFEEinFullPattern+0x1e4>
8110f81c:	10c03888 	cmpgei	r3,r2,226
8110f820:	1800051e 	bne	r3,zero,8110f838 <vQCmdFEEinFullPattern+0xa8>
8110f824:	10c03808 	cmpgei	r3,r2,224
8110f828:	1800471e 	bne	r3,zero,8110f948 <vQCmdFEEinFullPattern+0x1b8>
8110f82c:	10802920 	cmpeqi	r2,r2,164
8110f830:	1000251e 	bne	r2,zero,8110f8c8 <vQCmdFEEinFullPattern+0x138>
8110f834:	00004f06 	br	8110f974 <vQCmdFEEinFullPattern+0x1e4>
8110f838:	10803c20 	cmpeqi	r2,r2,240
8110f83c:	1000351e 	bne	r2,zero,8110f914 <vQCmdFEEinFullPattern+0x184>
8110f840:	00004c06 	br	8110f974 <vQCmdFEEinFullPattern+0x1e4>
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
				break;*/
			case M_FEE_CONFIG:
			case M_FEE_CONFIG_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110f844:	e0bffe17 	ldw	r2,-8(fp)
8110f848:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8110f84c:	e0bffe17 	ldw	r2,-8(fp)
8110f850:	00c00144 	movi	r3,5
8110f854:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
8110f858:	e0bffe17 	ldw	r2,-8(fp)
8110f85c:	00c00144 	movi	r3,5
8110f860:	10c02d15 	stw	r3,180(r2)
				break;				
8110f864:	00005006 	br	8110f9a8 <vQCmdFEEinFullPattern+0x218>
				break;
			case M_FEE_STANDBY:
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;*/ /* To finish the actual transfer only when sync comes */
				if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
8110f868:	e0bffe17 	ldw	r2,-8(fp)
8110f86c:	10802c17 	ldw	r2,176(r2)
8110f870:	10800298 	cmpnei	r2,r2,10
8110f874:	10000a1e 	bne	r2,zero,8110f8a0 <vQCmdFEEinFullPattern+0x110>
					pxNFeeP->xControl.bWatingSync = TRUE;
8110f878:	e0bffe17 	ldw	r2,-8(fp)
8110f87c:	00c00044 	movi	r3,1
8110f880:	10c02815 	stw	r3,160(r2)
					pxNFeeP->xControl.eMode = sFeeWaitingSync;
8110f884:	e0bffe17 	ldw	r2,-8(fp)
8110f888:	00c00304 	movi	r3,12
8110f88c:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110f890:	e0bffe17 	ldw	r2,-8(fp)
8110f894:	00c00184 	movi	r3,6
8110f898:	10c02d15 	stw	r3,180(r2)
					pxNFeeP->xControl.bWatingSync = TRUE;
					pxNFeeP->xControl.eMode = sFeeTestFullPattern;
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
				}

				break;
8110f89c:	00004206 	br	8110f9a8 <vQCmdFEEinFullPattern+0x218>
				if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
					pxNFeeP->xControl.bWatingSync = TRUE;
					pxNFeeP->xControl.eMode = sFeeWaitingSync;
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
				} else {
					pxNFeeP->xControl.bWatingSync = TRUE;
8110f8a0:	e0bffe17 	ldw	r2,-8(fp)
8110f8a4:	00c00044 	movi	r3,1
8110f8a8:	10c02815 	stw	r3,160(r2)
					pxNFeeP->xControl.eMode = sFeeTestFullPattern;
8110f8ac:	e0bffe17 	ldw	r2,-8(fp)
8110f8b0:	00c00104 	movi	r3,4
8110f8b4:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110f8b8:	e0bffe17 	ldw	r2,-8(fp)
8110f8bc:	00c00184 	movi	r3,6
8110f8c0:	10c02d15 	stw	r3,180(r2)
				}

				break;
8110f8c4:	00003806 	br	8110f9a8 <vQCmdFEEinFullPattern+0x218>
			case M_FEE_STANDBY_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110f8c8:	e0bffe17 	ldw	r2,-8(fp)
8110f8cc:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeStandBy;
8110f8d0:	e0bffe17 	ldw	r2,-8(fp)
8110f8d4:	00c00184 	movi	r3,6
8110f8d8:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */
8110f8dc:	e0bffe17 	ldw	r2,-8(fp)
8110f8e0:	00c00184 	movi	r3,6
8110f8e4:	10c02d15 	stw	r3,180(r2)
				break;				
8110f8e8:	00002f06 	br	8110f9a8 <vQCmdFEEinFullPattern+0x218>
			case M_FEE_FULL_PATTERN:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
8110f8ec:	d0e06217 	ldw	r3,-32376(gp)
8110f8f0:	e0bffe17 	ldw	r2,-8(fp)
8110f8f4:	10800003 	ldbu	r2,0(r2)
8110f8f8:	10803fcc 	andi	r2,r2,255
8110f8fc:	100d883a 	mov	r6,r2
8110f900:	01604574 	movhi	r5,33045
8110f904:	29714404 	addi	r5,r5,-15088
8110f908:	1809883a 	mov	r4,r3
8110f90c:	1120fa40 	call	81120fa4 <fprintf>
				#endif
				break;
8110f910:	00002506 	br	8110f9a8 <vQCmdFEEinFullPattern+0x218>
			case M_FEE_RMAP:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: RMAP Message Received\n", pxNFeeP->ucId);
8110f914:	d0e06217 	ldw	r3,-32376(gp)
8110f918:	e0bffe17 	ldw	r2,-8(fp)
8110f91c:	10800003 	ldbu	r2,0(r2)
8110f920:	10803fcc 	andi	r2,r2,255
8110f924:	100d883a 	mov	r6,r2
8110f928:	01604574 	movhi	r5,33045
8110f92c:	2970de04 	addi	r5,r5,-15496
8110f930:	1809883a 	mov	r4,r3
8110f934:	1120fa40 	call	81120fa4 <fprintf>
				#endif

				/* Perform some actions, check if is a valid command for this mode of operation  */
				vQCmdFeeRMAPinFullPattern( pxNFeeP, cmd );
8110f938:	e17fff17 	ldw	r5,-4(fp)
8110f93c:	e13ffe17 	ldw	r4,-8(fp)
8110f940:	110fed40 	call	8110fed4 <vQCmdFeeRMAPinFullPattern>

				break;
8110f944:	00001806 	br	8110f9a8 <vQCmdFEEinFullPattern+0x218>

			case M_SYNC:
			case M_MASTER_SYNC:
				/* Warning */
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
8110f948:	e0bffe17 	ldw	r2,-8(fp)
8110f94c:	10802c17 	ldw	r2,176(r2)
8110f950:	10800318 	cmpnei	r2,r2,12
8110f954:	1000131e 	bne	r2,zero,8110f9a4 <vQCmdFEEinFullPattern+0x214>
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
8110f958:	e0bffe17 	ldw	r2,-8(fp)
8110f95c:	10c02d17 	ldw	r3,180(r2)
8110f960:	e0bffe17 	ldw	r2,-8(fp)
8110f964:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.bWatingSync = FALSE;
8110f968:	e0bffe17 	ldw	r2,-8(fp)
8110f96c:	10002815 	stw	zero,160(r2)
				}

				break;
8110f970:	00000c06 	br	8110f9a4 <vQCmdFEEinFullPattern+0x214>
			default:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
8110f974:	d0e06217 	ldw	r3,-32376(gp)
8110f978:	e0bffe17 	ldw	r2,-8(fp)
8110f97c:	10800003 	ldbu	r2,0(r2)
8110f980:	10803fcc 	andi	r2,r2,255
8110f984:	100d883a 	mov	r6,r2
8110f988:	01604574 	movhi	r5,33045
8110f98c:	29712804 	addi	r5,r5,-15200
8110f990:	1809883a 	mov	r4,r3
8110f994:	1120fa40 	call	81120fa4 <fprintf>
				#endif
				break;
8110f998:	00000306 	br	8110f9a8 <vQCmdFEEinFullPattern+0x218>
				break;				
			case M_FEE_RUN:
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
8110f99c:	0001883a 	nop
8110f9a0:	00000106 	br	8110f9a8 <vQCmdFEEinFullPattern+0x218>
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
					pxNFeeP->xControl.bWatingSync = FALSE;
				}

				break;
8110f9a4:	0001883a 	nop
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				#endif
				break;
		}
	}
}
8110f9a8:	0001883a 	nop
8110f9ac:	e037883a 	mov	sp,fp
8110f9b0:	dfc00117 	ldw	ra,4(sp)
8110f9b4:	df000017 	ldw	fp,0(sp)
8110f9b8:	dec00204 	addi	sp,sp,8
8110f9bc:	f800283a 	ret

8110f9c0 <vQCmdFeeRMAPinStandBy>:



void vQCmdFeeRMAPinStandBy( TNFee *pxNFeeP, unsigned int cmd ){
8110f9c0:	defff704 	addi	sp,sp,-36
8110f9c4:	de00012e 	bgeu	sp,et,8110f9cc <vQCmdFeeRMAPinStandBy+0xc>
8110f9c8:	003b68fa 	trap	3
8110f9cc:	dfc00815 	stw	ra,32(sp)
8110f9d0:	df000715 	stw	fp,28(sp)
8110f9d4:	df000704 	addi	fp,sp,28
8110f9d8:	e13ffe15 	stw	r4,-8(fp)
8110f9dc:	e17fff15 	stw	r5,-4(fp)
	INT32U ucValueMasked;
	INT32U ucValueMasked2;


#ifdef DEBUG_ON
	fprintf(fp,"\nNFEE %hhu Task: RMAP msg received (StandBy)\n", pxNFeeP->ucId);
8110f9e0:	d0e06217 	ldw	r3,-32376(gp)
8110f9e4:	e0bffe17 	ldw	r2,-8(fp)
8110f9e8:	10800003 	ldbu	r2,0(r2)
8110f9ec:	10803fcc 	andi	r2,r2,255
8110f9f0:	100d883a 	mov	r6,r2
8110f9f4:	01604574 	movhi	r5,33045
8110f9f8:	29715204 	addi	r5,r5,-15032
8110f9fc:	1809883a 	mov	r4,r3
8110fa00:	1120fa40 	call	81120fa4 <fprintf>
#endif


	uiCmdFEEL.ulWord = cmd;
8110fa04:	e0bfff17 	ldw	r2,-4(fp)
8110fa08:	e0bffd15 	stw	r2,-12(fp)

	ucADDRReg = uiCmdFEEL.ucByte[1];
8110fa0c:	e0bffd43 	ldbu	r2,-11(fp)
8110fa10:	e0bff905 	stb	r2,-28(fp)
	ucValueReg = uliRmapReadReg(pxNFeeP->xChannel.xRmap.puliRmapChAddr,  ucADDRReg);
8110fa14:	e0bffe17 	ldw	r2,-8(fp)
8110fa18:	10804317 	ldw	r2,268(r2)
8110fa1c:	e0fff903 	ldbu	r3,-28(fp)
8110fa20:	180b883a 	mov	r5,r3
8110fa24:	1009883a 	mov	r4,r2
8110fa28:	1109ef80 	call	81109ef8 <uliRmapReadReg>
8110fa2c:	e0bffa15 	stw	r2,-24(fp)

	switch (ucADDRReg) {
8110fa30:	e0bff903 	ldbu	r2,-28(fp)
8110fa34:	10bff004 	addi	r2,r2,-64
8110fa38:	10c003a8 	cmpgeui	r3,r2,14
8110fa3c:	1801141e 	bne	r3,zero,8110fe90 <vQCmdFeeRMAPinStandBy+0x4d0>
8110fa40:	100690ba 	slli	r3,r2,2
8110fa44:	00a04474 	movhi	r2,33041
8110fa48:	10be9604 	addi	r2,r2,-1448
8110fa4c:	1885883a 	add	r2,r3,r2
8110fa50:	10800017 	ldw	r2,0(r2)
8110fa54:	1000683a 	jmp	r2
8110fa58:	8110fa90 	cmplti	r4,r16,17386
8110fa5c:	8110feb0 	cmpltui	r4,r16,17402
8110fa60:	8110fb98 	cmpnei	r4,r16,17390
8110fa64:	8110fd30 	cmpltui	r4,r16,17396
8110fa68:	8110fd30 	cmpltui	r4,r16,17396
8110fa6c:	8110fd30 	cmpltui	r4,r16,17396
8110fa70:	8110fd30 	cmpltui	r4,r16,17396
8110fa74:	8110fd30 	cmpltui	r4,r16,17396
8110fa78:	8110fd30 	cmpltui	r4,r16,17396
8110fa7c:	8110fd30 	cmpltui	r4,r16,17396
8110fa80:	8110fd30 	cmpltui	r4,r16,17396
8110fa84:	8110fd30 	cmpltui	r4,r16,17396
8110fa88:	8110fd4c 	andi	r4,r16,17397
8110fa8c:	8110fe20 	cmpeqi	r4,r16,17400
		case 0x40://0x00000000: ccd_seq_1_config
			ucValueMasked = (COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK & ucValueReg) >> 4; /* Number of rows */
8110fa90:	e0fffa17 	ldw	r3,-24(fp)
8110fa94:	00800434 	movhi	r2,16
8110fa98:	10bffc04 	addi	r2,r2,-16
8110fa9c:	1884703a 	and	r2,r3,r2
8110faa0:	1004d13a 	srli	r2,r2,4
8110faa4:	e0bffb15 	stw	r2,-20(fp)
			ucValueMasked2 = (COMM_RMAP_REGCLK_TRCNT_CTRL_MSK & ucValueReg) >> 20; /* Number of columns */
8110faa8:	e0bffa17 	ldw	r2,-24(fp)
8110faac:	1004d53a 	srli	r2,r2,20
8110fab0:	e0bffc15 	stw	r2,-16(fp)


			pxNFeeP->xCcdInfo.usiHeight = ucValueMasked - pxNFeeP->xCcdInfo.usiOLN;
8110fab4:	e0bffb17 	ldw	r2,-20(fp)
8110fab8:	1007883a 	mov	r3,r2
8110fabc:	e0bffe17 	ldw	r2,-8(fp)
8110fac0:	1080300b 	ldhu	r2,192(r2)
8110fac4:	1885c83a 	sub	r2,r3,r2
8110fac8:	1007883a 	mov	r3,r2
8110facc:	e0bffe17 	ldw	r2,-8(fp)
8110fad0:	10c0310d 	sth	r3,196(r2)
			pxNFeeP->xCcdInfo.usiHalfWidth = ucValueMasked2 - (pxNFeeP->xCcdInfo.usiSOverscanN + pxNFeeP->xCcdInfo.usiSPrescanN);
8110fad4:	e0bffc17 	ldw	r2,-16(fp)
8110fad8:	1009883a 	mov	r4,r2
8110fadc:	e0bffe17 	ldw	r2,-8(fp)
8110fae0:	10c02f8b 	ldhu	r3,190(r2)
8110fae4:	e0bffe17 	ldw	r2,-8(fp)
8110fae8:	10802f0b 	ldhu	r2,188(r2)
8110faec:	1885883a 	add	r2,r3,r2
8110faf0:	2085c83a 	sub	r2,r4,r2
8110faf4:	1007883a 	mov	r3,r2
8110faf8:	e0bffe17 	ldw	r2,-8(fp)
8110fafc:	10c0308d 	sth	r3,194(r2)
			vUpdateMemMapFEE(pxNFeeP);
8110fb00:	e13ffe17 	ldw	r4,-8(fp)
8110fb04:	111d5400 	call	8111d540 <vUpdateMemMapFEE>

			bDpktGetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8110fb08:	e0bffe17 	ldw	r2,-8(fp)
8110fb0c:	10803304 	addi	r2,r2,204
8110fb10:	1009883a 	mov	r4,r2
8110fb14:	1104a680 	call	81104a68 <bDpktGetPacketConfig>
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiOverscanYSize = pxNFeeP->xCcdInfo.usiOLN;
8110fb18:	e0bffe17 	ldw	r2,-8(fp)
8110fb1c:	10c0300b 	ldhu	r3,192(r2)
8110fb20:	e0bffe17 	ldw	r2,-8(fp)
8110fb24:	10c0358d 	sth	r3,214(r2)
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdXSize = ucValueMasked2 ;
8110fb28:	e0bffc17 	ldw	r2,-16(fp)
8110fb2c:	1007883a 	mov	r3,r2
8110fb30:	e0bffe17 	ldw	r2,-8(fp)
8110fb34:	10c0340d 	sth	r3,208(r2)
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdYSize = ucValueMasked;
8110fb38:	e0bffb17 	ldw	r2,-20(fp)
8110fb3c:	1007883a 	mov	r3,r2
8110fb40:	e0bffe17 	ldw	r2,-8(fp)
8110fb44:	10c0348d 	sth	r3,210(r2)
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiDataYSize = ucValueMasked - pxNFeeP->xCcdInfo.usiOLN;
8110fb48:	e0bffb17 	ldw	r2,-20(fp)
8110fb4c:	1007883a 	mov	r3,r2
8110fb50:	e0bffe17 	ldw	r2,-8(fp)
8110fb54:	1080300b 	ldhu	r2,192(r2)
8110fb58:	1885c83a 	sub	r2,r3,r2
8110fb5c:	1007883a 	mov	r3,r2
8110fb60:	e0bffe17 	ldw	r2,-8(fp)
8110fb64:	10c0350d 	sth	r3,212(r2)
		
			bDpktSetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8110fb68:	e0bffe17 	ldw	r2,-8(fp)
8110fb6c:	10803304 	addi	r2,r2,204
8110fb70:	1009883a 	mov	r4,r2
8110fb74:	110483c0 	call	8110483c <bDpktSetPacketConfig>

			#ifdef DEBUG_ON
				fprintf(fp,"- Rows: %u\n - Columns: %u\n", ucValueMasked, ucValueMasked2);
8110fb78:	d0a06217 	ldw	r2,-32376(gp)
8110fb7c:	e1fffc17 	ldw	r7,-16(fp)
8110fb80:	e1bffb17 	ldw	r6,-20(fp)
8110fb84:	01604574 	movhi	r5,33045
8110fb88:	29715e04 	addi	r5,r5,-14984
8110fb8c:	1009883a 	mov	r4,r2
8110fb90:	1120fa40 	call	81120fa4 <fprintf>
			#endif

			break;
8110fb94:	0000c906 	br	8110febc <vQCmdFeeRMAPinStandBy+0x4fc>
		case 0x041://0x00000004:ccd_seq_2_config
			break;
		case 0x042://0x00000008:spw_packet_1_config

			ucValueMasked = (ucValueReg & COMM_RMAP_PACKET_SIZE_CTRL_MSK) >> 4;
8110fb98:	e0fffa17 	ldw	r3,-24(fp)
8110fb9c:	00800434 	movhi	r2,16
8110fba0:	10bffc04 	addi	r2,r2,-16
8110fba4:	1884703a 	and	r2,r3,r2
8110fba8:	1004d13a 	srli	r2,r2,4
8110fbac:	e0bffb15 	stw	r2,-20(fp)
			bDpktGetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8110fbb0:	e0bffe17 	ldw	r2,-8(fp)
8110fbb4:	10803304 	addi	r2,r2,204
8110fbb8:	1009883a 	mov	r4,r2
8110fbbc:	1104a680 	call	81104a68 <bDpktGetPacketConfig>
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiPacketLength = ucValueMasked;
8110fbc0:	e0bffb17 	ldw	r2,-20(fp)
8110fbc4:	1007883a 	mov	r3,r2
8110fbc8:	e0bffe17 	ldw	r2,-8(fp)
8110fbcc:	10c0360d 	sth	r3,216(r2)
			bDpktSetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8110fbd0:	e0bffe17 	ldw	r2,-8(fp)
8110fbd4:	10803304 	addi	r2,r2,204
8110fbd8:	1009883a 	mov	r4,r2
8110fbdc:	110483c0 	call	8110483c <bDpktSetPacketConfig>

			#ifdef DEBUG_ON
				fprintf(fp,"- Pckt Length: %u\n", ucValueMasked);
8110fbe0:	d0a06217 	ldw	r2,-32376(gp)
8110fbe4:	e1bffb17 	ldw	r6,-20(fp)
8110fbe8:	01604574 	movhi	r5,33045
8110fbec:	29716504 	addi	r5,r5,-14956
8110fbf0:	1009883a 	mov	r4,r2
8110fbf4:	1120fa40 	call	81120fa4 <fprintf>
			#endif

			ucValueMasked2 = (ucValueReg & COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK) >> 2;
8110fbf8:	e0bffa17 	ldw	r2,-24(fp)
8110fbfc:	1080030c 	andi	r2,r2,12
8110fc00:	1004d0ba 	srli	r2,r2,2
8110fc04:	e0bffc15 	stw	r2,-16(fp)

			switch (ucValueMasked2) {
8110fc08:	e0bffc17 	ldw	r2,-16(fp)
8110fc0c:	10c000a0 	cmpeqi	r3,r2,2
8110fc10:	18000e1e 	bne	r3,zero,8110fc4c <vQCmdFeeRMAPinStandBy+0x28c>
8110fc14:	10c000e0 	cmpeqi	r3,r2,3
8110fc18:	1800171e 	bne	r3,zero,8110fc78 <vQCmdFeeRMAPinStandBy+0x2b8>
8110fc1c:	10800060 	cmpeqi	r2,r2,1
8110fc20:	10001e26 	beq	r2,zero,8110fc9c <vQCmdFeeRMAPinStandBy+0x2dc>
				case 0b01:
					pxNFeeP->xControl.eSide = sLeft;
8110fc24:	e0bffe17 	ldw	r2,-8(fp)
8110fc28:	10002e15 	stw	zero,184(r2)
					#ifdef DEBUG_ON
						fprintf(fp," - Left side\n");
8110fc2c:	d0a06217 	ldw	r2,-32376(gp)
8110fc30:	100f883a 	mov	r7,r2
8110fc34:	01800344 	movi	r6,13
8110fc38:	01400044 	movi	r5,1
8110fc3c:	01204574 	movhi	r4,33045
8110fc40:	21316a04 	addi	r4,r4,-14936
8110fc44:	11216400 	call	81121640 <fwrite>
					#endif
					break;
8110fc48:	00002c06 	br	8110fcfc <vQCmdFeeRMAPinStandBy+0x33c>
				case 0b10:
					pxNFeeP->xControl.eSide = sRight;
8110fc4c:	e0bffe17 	ldw	r2,-8(fp)
8110fc50:	00c00044 	movi	r3,1
8110fc54:	10c02e15 	stw	r3,184(r2)
					#ifdef DEBUG_ON
						fprintf(fp," - Right side\n");
8110fc58:	d0a06217 	ldw	r2,-32376(gp)
8110fc5c:	100f883a 	mov	r7,r2
8110fc60:	01800384 	movi	r6,14
8110fc64:	01400044 	movi	r5,1
8110fc68:	01204574 	movhi	r4,33045
8110fc6c:	21316e04 	addi	r4,r4,-14920
8110fc70:	11216400 	call	81121640 <fwrite>
					#endif
					break;
8110fc74:	00002106 	br	8110fcfc <vQCmdFeeRMAPinStandBy+0x33c>
				case 0b11:
					pxNFeeP->xControl.eSide = sLeft;
8110fc78:	e0bffe17 	ldw	r2,-8(fp)
8110fc7c:	10002e15 	stw	zero,184(r2)
					#ifdef DEBUG_ON
						fprintf(fp," - Both sides, but not supported yet. Switching to Left side\n");
8110fc80:	d0a06217 	ldw	r2,-32376(gp)
8110fc84:	100f883a 	mov	r7,r2
8110fc88:	01800f44 	movi	r6,61
8110fc8c:	01400044 	movi	r5,1
8110fc90:	01204574 	movhi	r4,33045
8110fc94:	21317204 	addi	r4,r4,-14904
8110fc98:	11216400 	call	81121640 <fwrite>
					#endif
				default:
					pxNFeeP->xControl.eSide = sLeft;
8110fc9c:	e0bffe17 	ldw	r2,-8(fp)
8110fca0:	10002e15 	stw	zero,184(r2)

					bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110fca4:	e0bffe17 	ldw	r2,-8(fp)
8110fca8:	10804304 	addi	r2,r2,268
8110fcac:	1009883a 	mov	r4,r2
8110fcb0:	11081800 	call	81108180 <bRmapGetMemConfigArea>
					pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config & 0xFFFFFFF7);
8110fcb4:	e0bffe17 	ldw	r2,-8(fp)
8110fcb8:	10c05717 	ldw	r3,348(r2)
8110fcbc:	00bffdc4 	movi	r2,-9
8110fcc0:	1886703a 	and	r3,r3,r2
8110fcc4:	e0bffe17 	ldw	r2,-8(fp)
8110fcc8:	10c05715 	stw	r3,348(r2)
					bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110fccc:	e0bffe17 	ldw	r2,-8(fp)
8110fcd0:	10804304 	addi	r2,r2,268
8110fcd4:	1009883a 	mov	r4,r2
8110fcd8:	1107e940 	call	81107e94 <bRmapSetMemConfigArea>
					#ifdef DEBUG_ON
						fprintf(fp," - Switching to Left side\n");
8110fcdc:	d0a06217 	ldw	r2,-32376(gp)
8110fce0:	100f883a 	mov	r7,r2
8110fce4:	01800684 	movi	r6,26
8110fce8:	01400044 	movi	r5,1
8110fcec:	01204574 	movhi	r4,33045
8110fcf0:	21318204 	addi	r4,r4,-14840
8110fcf4:	11216400 	call	81121640 <fwrite>
					#endif
					break;
8110fcf8:	0001883a 	nop
				}
			#ifdef DEBUG_ON
				fprintf(fp,"\nNFEE %hhu Task: Side changed (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
8110fcfc:	d0e06217 	ldw	r3,-32376(gp)
8110fd00:	e0bffe17 	ldw	r2,-8(fp)
8110fd04:	10800003 	ldbu	r2,0(r2)
8110fd08:	11003fcc 	andi	r4,r2,255
8110fd0c:	e0bffe17 	ldw	r2,-8(fp)
8110fd10:	10802e17 	ldw	r2,184(r2)
8110fd14:	100f883a 	mov	r7,r2
8110fd18:	200d883a 	mov	r6,r4
8110fd1c:	01604574 	movhi	r5,33045
8110fd20:	29718904 	addi	r5,r5,-14812
8110fd24:	1809883a 	mov	r4,r3
8110fd28:	1120fa40 	call	81120fa4 <fprintf>
			#endif
			break;
8110fd2c:	00006306 	br	8110febc <vQCmdFeeRMAPinStandBy+0x4fc>
		case 0x48://0x00000020:CCD_3_windowing_1_config
		case 0x49://0x00000024:CCD_3_windowing_2_config
		case 0x4A://0x00000028:CCD_4_windowing_1_config
		case 0x4B://0x0000002C:CCD_4_windowing_2_config
			#ifdef DEBUG_ON
				fprintf(fp,"Command not allowed yet ( %hhu )\n", ucValueMasked);
8110fd30:	d0a06217 	ldw	r2,-32376(gp)
8110fd34:	e1bffb17 	ldw	r6,-20(fp)
8110fd38:	01604574 	movhi	r5,33045
8110fd3c:	29719704 	addi	r5,r5,-14756
8110fd40:	1009883a 	mov	r4,r2
8110fd44:	1120fa40 	call	81120fa4 <fprintf>
			#endif
				break;
8110fd48:	00005c06 	br	8110febc <vQCmdFeeRMAPinStandBy+0x4fc>
		case 0x0000004C://0x00000038:operation_mode_config
			/* Mode Selection */
			ucValueMasked = (COMM_RMAP_MODE_SEL_CTRL_MSK & ucValueReg) >>4;
8110fd4c:	e0bffa17 	ldw	r2,-24(fp)
8110fd50:	10803c0c 	andi	r2,r2,240
8110fd54:	1004d13a 	srli	r2,r2,4
8110fd58:	e0bffb15 	stw	r2,-20(fp)

			switch (ucValueMasked) {
8110fd5c:	e0bffb17 	ldw	r2,-20(fp)
8110fd60:	10c000a0 	cmpeqi	r3,r2,2
8110fd64:	18000d1e 	bne	r3,zero,8110fd9c <vQCmdFeeRMAPinStandBy+0x3dc>
8110fd68:	10c001a0 	cmpeqi	r3,r2,6
8110fd6c:	18001c1e 	bne	r3,zero,8110fde0 <vQCmdFeeRMAPinStandBy+0x420>
8110fd70:	1000231e 	bne	r2,zero,8110fe00 <vQCmdFeeRMAPinStandBy+0x440>
				case 0: /* Standby */

				#ifdef DEBUG_ON
					fprintf(fp,"- already in Stand by mode\n", pxNFeeP->ucId);
8110fd74:	d0e06217 	ldw	r3,-32376(gp)
8110fd78:	e0bffe17 	ldw	r2,-8(fp)
8110fd7c:	10800003 	ldbu	r2,0(r2)
8110fd80:	10803fcc 	andi	r2,r2,255
8110fd84:	100d883a 	mov	r6,r2
8110fd88:	01604574 	movhi	r5,33045
8110fd8c:	2971a004 	addi	r5,r5,-14720
8110fd90:	1809883a 	mov	r4,r3
8110fd94:	1120fa40 	call	81120fa4 <fprintf>
				#endif

					break;
8110fd98:	00002006 	br	8110fe1c <vQCmdFeeRMAPinStandBy+0x45c>
				case 2: /* PAttern Full image */
				#ifdef DEBUG_ON
					fprintf(fp,"- to Full-Image-Pattern\n");
8110fd9c:	d0a06217 	ldw	r2,-32376(gp)
8110fda0:	100f883a 	mov	r7,r2
8110fda4:	01800604 	movi	r6,24
8110fda8:	01400044 	movi	r5,1
8110fdac:	01204574 	movhi	r4,33045
8110fdb0:	2131a704 	addi	r4,r4,-14692
8110fdb4:	11216400 	call	81121640 <fwrite>
				#endif

					pxNFeeP->xControl.bWatingSync = TRUE;
8110fdb8:	e0bffe17 	ldw	r2,-8(fp)
8110fdbc:	00c00044 	movi	r3,1
8110fdc0:	10c02815 	stw	r3,160(r2)
					pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
8110fdc4:	e0bffe17 	ldw	r2,-8(fp)
8110fdc8:	00c00284 	movi	r3,10
8110fdcc:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
8110fdd0:	e0bffe17 	ldw	r2,-8(fp)
8110fdd4:	00c00304 	movi	r3,12
8110fdd8:	10c02d15 	stw	r3,180(r2)

					break;
8110fddc:	00000f06 	br	8110fe1c <vQCmdFeeRMAPinStandBy+0x45c>
				case 6:
				#ifdef DEBUG_ON
					fprintf(fp,"- Off-Mode not allowed.\n");
8110fde0:	d0a06217 	ldw	r2,-32376(gp)
8110fde4:	100f883a 	mov	r7,r2
8110fde8:	01800604 	movi	r6,24
8110fdec:	01400044 	movi	r5,1
8110fdf0:	01204574 	movhi	r4,33045
8110fdf4:	2131ae04 	addi	r4,r4,-14664
8110fdf8:	11216400 	call	81121640 <fwrite>
				#endif
					break;
8110fdfc:	00000706 	br	8110fe1c <vQCmdFeeRMAPinStandBy+0x45c>
				case 3:
				case 4:
				case 5:
				default:
					#ifdef DEBUG_ON
						fprintf(fp,"- mode not allowed yet ( %hhu )\n", ucValueMasked);
8110fe00:	d0a06217 	ldw	r2,-32376(gp)
8110fe04:	e1bffb17 	ldw	r6,-20(fp)
8110fe08:	01604574 	movhi	r5,33045
8110fe0c:	2971b504 	addi	r5,r5,-14636
8110fe10:	1009883a 	mov	r4,r2
8110fe14:	1120fa40 	call	81120fa4 <fprintf>
					#endif
					break;
8110fe18:	0001883a 	nop
			}

			break;
8110fe1c:	00002706 	br	8110febc <vQCmdFeeRMAPinStandBy+0x4fc>
		case 0x0000004D://0x0000003C:sync_config

			ucValueMasked = (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & ucValueReg) >> 2; /* Number of rows */
8110fe20:	e0bffa17 	ldw	r2,-24(fp)
8110fe24:	1080010c 	andi	r2,r2,4
8110fe28:	1004d0ba 	srli	r2,r2,2
8110fe2c:	e0bffb15 	stw	r2,-20(fp)

			/* Cannot perform this operation */
			if ( ucValueMasked ) {
8110fe30:	e0bffb17 	ldw	r2,-20(fp)
8110fe34:	10002026 	beq	r2,zero,8110feb8 <vQCmdFeeRMAPinStandBy+0x4f8>
				#ifdef DEBUG_ON
					fprintf(fp," - operation not allowed (StandBy-Mode)\n");
8110fe38:	d0a06217 	ldw	r2,-32376(gp)
8110fe3c:	100f883a 	mov	r7,r2
8110fe40:	01800a04 	movi	r6,40
8110fe44:	01400044 	movi	r5,1
8110fe48:	01204574 	movhi	r4,33045
8110fe4c:	2131be04 	addi	r4,r4,-14600
8110fe50:	11216400 	call	81121640 <fwrite>
				#endif
				/* Clear the trigger */
				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110fe54:	e0bffe17 	ldw	r2,-8(fp)
8110fe58:	10804304 	addi	r2,r2,268
8110fe5c:	1009883a 	mov	r4,r2
8110fe60:	11081800 	call	81108180 <bRmapGetMemConfigArea>
				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
8110fe64:	e0bffe17 	ldw	r2,-8(fp)
8110fe68:	10c06217 	ldw	r3,392(r2)
8110fe6c:	00bffec4 	movi	r2,-5
8110fe70:	1886703a 	and	r3,r3,r2
8110fe74:	e0bffe17 	ldw	r2,-8(fp)
8110fe78:	10c06215 	stw	r3,392(r2)
				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110fe7c:	e0bffe17 	ldw	r2,-8(fp)
8110fe80:	10804304 	addi	r2,r2,268
8110fe84:	1009883a 	mov	r4,r2
8110fe88:	1107e940 	call	81107e94 <bRmapSetMemConfigArea>
			}

			break;
8110fe8c:	00000a06 	br	8110feb8 <vQCmdFeeRMAPinStandBy+0x4f8>
		case 0x0000004F://0x00000044:clock_source_control
		case 0x00000050://0x00000048:frame_number
		case 0x00000051://0x0000004C:current_mode
		default:
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
8110fe90:	d0a06217 	ldw	r2,-32376(gp)
8110fe94:	e0fff903 	ldbu	r3,-28(fp)
8110fe98:	180d883a 	mov	r6,r3
8110fe9c:	01604574 	movhi	r5,33045
8110fea0:	2971c904 	addi	r5,r5,-14556
8110fea4:	1009883a 	mov	r4,r2
8110fea8:	1120fa40 	call	81120fa4 <fprintf>
			#endif
			break;
8110feac:	00000306 	br	8110febc <vQCmdFeeRMAPinStandBy+0x4fc>
				fprintf(fp,"- Rows: %u\n - Columns: %u\n", ucValueMasked, ucValueMasked2);
			#endif

			break;
		case 0x041://0x00000004:ccd_seq_2_config
			break;
8110feb0:	0001883a 	nop
8110feb4:	00000106 	br	8110febc <vQCmdFeeRMAPinStandBy+0x4fc>
				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
			}

			break;
8110feb8:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			#endif
			break;
		}
}
8110febc:	0001883a 	nop
8110fec0:	e037883a 	mov	sp,fp
8110fec4:	dfc00117 	ldw	ra,4(sp)
8110fec8:	df000017 	ldw	fp,0(sp)
8110fecc:	dec00204 	addi	sp,sp,8
8110fed0:	f800283a 	ret

8110fed4 <vQCmdFeeRMAPinFullPattern>:

void vQCmdFeeRMAPinFullPattern( TNFee *pxNFeeP, unsigned int cmd ) {
8110fed4:	defff804 	addi	sp,sp,-32
8110fed8:	de00012e 	bgeu	sp,et,8110fee0 <vQCmdFeeRMAPinFullPattern+0xc>
8110fedc:	003b68fa 	trap	3
8110fee0:	dfc00715 	stw	ra,28(sp)
8110fee4:	df000615 	stw	fp,24(sp)
8110fee8:	df000604 	addi	fp,sp,24
8110feec:	e13ffe15 	stw	r4,-8(fp)
8110fef0:	e17fff15 	stw	r5,-4(fp)
	INT8U ucValueReg;
	INT32U ucValueMasked;
	INT32U ucValueMasked2;

	#ifdef DEBUG_ON
		fprintf(fp,"\nNFEE %hhu Task: RMAP msg received (FullPattern)\n", pxNFeeP->ucId);
8110fef4:	d0e06217 	ldw	r3,-32376(gp)
8110fef8:	e0bffe17 	ldw	r2,-8(fp)
8110fefc:	10800003 	ldbu	r2,0(r2)
8110ff00:	10803fcc 	andi	r2,r2,255
8110ff04:	100d883a 	mov	r6,r2
8110ff08:	01604574 	movhi	r5,33045
8110ff0c:	2971d204 	addi	r5,r5,-14520
8110ff10:	1809883a 	mov	r4,r3
8110ff14:	1120fa40 	call	81120fa4 <fprintf>
	#endif

	uiCmdFEEL.ulWord = cmd;
8110ff18:	e0bfff17 	ldw	r2,-4(fp)
8110ff1c:	e0bffd15 	stw	r2,-12(fp)

	ucADDRReg = uiCmdFEEL.ucByte[1];
8110ff20:	e0bffd43 	ldbu	r2,-11(fp)
8110ff24:	e0bffa05 	stb	r2,-24(fp)
	ucValueReg = uliRmapReadReg(pxNFeeP->xChannel.xRmap.puliRmapChAddr,  ucADDRReg);
8110ff28:	e0bffe17 	ldw	r2,-8(fp)
8110ff2c:	10804317 	ldw	r2,268(r2)
8110ff30:	e0fffa03 	ldbu	r3,-24(fp)
8110ff34:	180b883a 	mov	r5,r3
8110ff38:	1009883a 	mov	r4,r2
8110ff3c:	1109ef80 	call	81109ef8 <uliRmapReadReg>
8110ff40:	e0bffa45 	stb	r2,-23(fp)


	switch (ucADDRReg) {
8110ff44:	e0bffa03 	ldbu	r2,-24(fp)
8110ff48:	10bff004 	addi	r2,r2,-64
8110ff4c:	10c003a8 	cmpgeui	r3,r2,14
8110ff50:	1800e51e 	bne	r3,zero,811102e8 <vQCmdFeeRMAPinFullPattern+0x414>
8110ff54:	100690ba 	slli	r3,r2,2
8110ff58:	00a04474 	movhi	r2,33041
8110ff5c:	10bfdb04 	addi	r2,r2,-148
8110ff60:	1885883a 	add	r2,r3,r2
8110ff64:	10800017 	ldw	r2,0(r2)
8110ff68:	1000683a 	jmp	r2
8110ff6c:	8110ffa4 	muli	r4,r16,17406
8110ff70:	8110ffa4 	muli	r4,r16,17406
8110ff74:	8110ffa4 	muli	r4,r16,17406
8110ff78:	81110158 	cmpnei	r4,r16,17413
8110ff7c:	81110158 	cmpnei	r4,r16,17413
8110ff80:	81110158 	cmpnei	r4,r16,17413
8110ff84:	81110158 	cmpnei	r4,r16,17413
8110ff88:	81110158 	cmpnei	r4,r16,17413
8110ff8c:	81110158 	cmpnei	r4,r16,17413
8110ff90:	81110158 	cmpnei	r4,r16,17413
8110ff94:	81110158 	cmpnei	r4,r16,17413
8110ff98:	81110158 	cmpnei	r4,r16,17413
8110ff9c:	81110174 	orhi	r4,r16,17413
8110ffa0:	81110280 	call	88111028 <__reset+0x20f1028>
		case 0x40://0x00000000: ccd_seq_1_config
		case 0x041://0x00000004:ccd_seq_2_config
		case 0x042://0x00000008:spw_packet_1_config
			if ( (pxNFeeP->xControl.eNextMode == sToTestFullPattern) || (pxNFeeP->xControl.eNextMode == sFeeWaitingSync) )
8110ffa4:	e0bffe17 	ldw	r2,-8(fp)
8110ffa8:	10802d17 	ldw	r2,180(r2)
8110ffac:	108001e0 	cmpeqi	r2,r2,7
8110ffb0:	1000041e 	bne	r2,zero,8110ffc4 <vQCmdFeeRMAPinFullPattern+0xf0>
8110ffb4:	e0bffe17 	ldw	r2,-8(fp)
8110ffb8:	10802d17 	ldw	r2,180(r2)
8110ffbc:	10800318 	cmpnei	r2,r2,12
8110ffc0:	1000541e 	bne	r2,zero,81110114 <vQCmdFeeRMAPinFullPattern+0x240>
			{

				ucValueMasked2 = (ucValueReg & COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK) >> 2;
8110ffc4:	e0bffa43 	ldbu	r2,-23(fp)
8110ffc8:	1080030c 	andi	r2,r2,12
8110ffcc:	1005d0ba 	srai	r2,r2,2
8110ffd0:	e0bffb15 	stw	r2,-20(fp)

				switch (ucValueMasked2) {
8110ffd4:	e0bffb17 	ldw	r2,-20(fp)
8110ffd8:	10c000a0 	cmpeqi	r3,r2,2
8110ffdc:	18000e1e 	bne	r3,zero,81110018 <vQCmdFeeRMAPinFullPattern+0x144>
8110ffe0:	10c000e0 	cmpeqi	r3,r2,3
8110ffe4:	1800171e 	bne	r3,zero,81110044 <vQCmdFeeRMAPinFullPattern+0x170>
8110ffe8:	10800060 	cmpeqi	r2,r2,1
8110ffec:	10001e26 	beq	r2,zero,81110068 <vQCmdFeeRMAPinFullPattern+0x194>
					case 0b01:
						pxNFeeP->xControl.eSide = sLeft;
8110fff0:	e0bffe17 	ldw	r2,-8(fp)
8110fff4:	10002e15 	stw	zero,184(r2)
						#ifdef DEBUG_ON
							fprintf(fp," - Left side\n");
8110fff8:	d0a06217 	ldw	r2,-32376(gp)
8110fffc:	100f883a 	mov	r7,r2
81110000:	01800344 	movi	r6,13
81110004:	01400044 	movi	r5,1
81110008:	01204574 	movhi	r4,33045
8111000c:	21316a04 	addi	r4,r4,-14936
81110010:	11216400 	call	81121640 <fwrite>
						#endif
						break;
81110014:	00002c06 	br	811100c8 <vQCmdFeeRMAPinFullPattern+0x1f4>
					case 0b10:
						pxNFeeP->xControl.eSide = sRight;
81110018:	e0bffe17 	ldw	r2,-8(fp)
8111001c:	00c00044 	movi	r3,1
81110020:	10c02e15 	stw	r3,184(r2)
						#ifdef DEBUG_ON
							fprintf(fp," - Right side\n");
81110024:	d0a06217 	ldw	r2,-32376(gp)
81110028:	100f883a 	mov	r7,r2
8111002c:	01800384 	movi	r6,14
81110030:	01400044 	movi	r5,1
81110034:	01204574 	movhi	r4,33045
81110038:	21316e04 	addi	r4,r4,-14920
8111003c:	11216400 	call	81121640 <fwrite>
						#endif
						break;
81110040:	00002106 	br	811100c8 <vQCmdFeeRMAPinFullPattern+0x1f4>
					case 0b11:
						pxNFeeP->xControl.eSide = sLeft;
81110044:	e0bffe17 	ldw	r2,-8(fp)
81110048:	10002e15 	stw	zero,184(r2)
						#ifdef DEBUG_ON
							fprintf(fp," - Both sides, but not supported yet. Switching to Left side\n");
8111004c:	d0a06217 	ldw	r2,-32376(gp)
81110050:	100f883a 	mov	r7,r2
81110054:	01800f44 	movi	r6,61
81110058:	01400044 	movi	r5,1
8111005c:	01204574 	movhi	r4,33045
81110060:	21317204 	addi	r4,r4,-14904
81110064:	11216400 	call	81121640 <fwrite>
						#endif
					default:
						pxNFeeP->xControl.eSide = sLeft;
81110068:	e0bffe17 	ldw	r2,-8(fp)
8111006c:	10002e15 	stw	zero,184(r2)

						bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
81110070:	e0bffe17 	ldw	r2,-8(fp)
81110074:	10804304 	addi	r2,r2,268
81110078:	1009883a 	mov	r4,r2
8111007c:	11081800 	call	81108180 <bRmapGetMemConfigArea>
						pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config & 0xFFFFFFF7);
81110080:	e0bffe17 	ldw	r2,-8(fp)
81110084:	10c05717 	ldw	r3,348(r2)
81110088:	00bffdc4 	movi	r2,-9
8111008c:	1886703a 	and	r3,r3,r2
81110090:	e0bffe17 	ldw	r2,-8(fp)
81110094:	10c05715 	stw	r3,348(r2)
						bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
81110098:	e0bffe17 	ldw	r2,-8(fp)
8111009c:	10804304 	addi	r2,r2,268
811100a0:	1009883a 	mov	r4,r2
811100a4:	1107e940 	call	81107e94 <bRmapSetMemConfigArea>
						#ifdef DEBUG_ON
							fprintf(fp," - Switching to Left side\n");
811100a8:	d0a06217 	ldw	r2,-32376(gp)
811100ac:	100f883a 	mov	r7,r2
811100b0:	01800684 	movi	r6,26
811100b4:	01400044 	movi	r5,1
811100b8:	01204574 	movhi	r4,33045
811100bc:	21318204 	addi	r4,r4,-14840
811100c0:	11216400 	call	81121640 <fwrite>
						#endif
					break;
811100c4:	0001883a 	nop
				}
				#ifdef DEBUG_ON
					fprintf(fp,"\nNFEE %hhu Task: Side changed (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
811100c8:	d0e06217 	ldw	r3,-32376(gp)
811100cc:	e0bffe17 	ldw	r2,-8(fp)
811100d0:	10800003 	ldbu	r2,0(r2)
811100d4:	11003fcc 	andi	r4,r2,255
811100d8:	e0bffe17 	ldw	r2,-8(fp)
811100dc:	10802e17 	ldw	r2,184(r2)
811100e0:	100f883a 	mov	r7,r2
811100e4:	200d883a 	mov	r6,r4
811100e8:	01604574 	movhi	r5,33045
811100ec:	29718904 	addi	r5,r5,-14812
811100f0:	1809883a 	mov	r4,r3
811100f4:	1120fa40 	call	81120fa4 <fprintf>
				#endif


				pxNFeeP->xControl.eMode =  sNextPatternIteration;
811100f8:	e0bffe17 	ldw	r2,-8(fp)
811100fc:	00c00284 	movi	r3,10
81110100:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode =  sFeeWaitingSync;
81110104:	e0bffe17 	ldw	r2,-8(fp)
81110108:	00c00304 	movi	r3,12
8111010c:	10c02d15 	stw	r3,180(r2)
				}
			}



			break;
81110110:	00007d06 	br	81110308 <vQCmdFeeRMAPinFullPattern+0x434>


				pxNFeeP->xControl.eMode =  sNextPatternIteration;
				pxNFeeP->xControl.eNextMode =  sFeeWaitingSync;
			} else {
				if (pxNFeeP->xControl.eNextMode == sFeeTestFullPattern) {
81110114:	e0bffe17 	ldw	r2,-8(fp)
81110118:	10802d17 	ldw	r2,180(r2)
8111011c:	10800118 	cmpnei	r2,r2,4
81110120:	1000791e 	bne	r2,zero,81110308 <vQCmdFeeRMAPinFullPattern+0x434>
					#ifdef DEBUG_ON
						fprintf(fp,"\nNFEE %hhu Task: Can't change the CCD side while in transmission (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
81110124:	d0e06217 	ldw	r3,-32376(gp)
81110128:	e0bffe17 	ldw	r2,-8(fp)
8111012c:	10800003 	ldbu	r2,0(r2)
81110130:	11003fcc 	andi	r4,r2,255
81110134:	e0bffe17 	ldw	r2,-8(fp)
81110138:	10802e17 	ldw	r2,184(r2)
8111013c:	100f883a 	mov	r7,r2
81110140:	200d883a 	mov	r6,r4
81110144:	01604574 	movhi	r5,33045
81110148:	2971df04 	addi	r5,r5,-14468
8111014c:	1809883a 	mov	r4,r3
81110150:	1120fa40 	call	81120fa4 <fprintf>
				}
			}



			break;
81110154:	00006c06 	br	81110308 <vQCmdFeeRMAPinFullPattern+0x434>
		case 0x48://0x00000020:CCD_3_windowing_1_config
		case 0x49://0x00000024:CCD_3_windowing_2_config
		case 0x4A://0x00000028:CCD_4_windowing_1_config
		case 0x4B://0x0000002C:CCD_4_windowing_2_config
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucValueMasked);
81110158:	d0a06217 	ldw	r2,-32376(gp)
8111015c:	e1bffc17 	ldw	r6,-16(fp)
81110160:	01604574 	movhi	r5,33045
81110164:	2971c904 	addi	r5,r5,-14556
81110168:	1009883a 	mov	r4,r2
8111016c:	1120fa40 	call	81120fa4 <fprintf>
			#endif
				break;
81110170:	00006806 	br	81110314 <vQCmdFeeRMAPinFullPattern+0x440>

		case 0x0000004C://0x00000038:operation_mode_config
			/* Mode Selection */
			ucValueMasked = (COMM_RMAP_MODE_SEL_CTRL_MSK & ucValueReg) >>4;
81110174:	e0bffa43 	ldbu	r2,-23(fp)
81110178:	1004d13a 	srli	r2,r2,4
8111017c:	10803fcc 	andi	r2,r2,255
81110180:	e0bffc15 	stw	r2,-16(fp)

			switch (ucValueMasked) {
81110184:	e0bffc17 	ldw	r2,-16(fp)
81110188:	10c000a0 	cmpeqi	r3,r2,2
8111018c:	1800221e 	bne	r3,zero,81110218 <vQCmdFeeRMAPinFullPattern+0x344>
81110190:	10c001a0 	cmpeqi	r3,r2,6
81110194:	18002a1e 	bne	r3,zero,81110240 <vQCmdFeeRMAPinFullPattern+0x36c>
81110198:	1000311e 	bne	r2,zero,81110260 <vQCmdFeeRMAPinFullPattern+0x38c>
				case 0: /* Standby */
				#ifdef DEBUG_ON
					fprintf(fp,"- to Stand-By\n");
8111019c:	d0a06217 	ldw	r2,-32376(gp)
811101a0:	100f883a 	mov	r7,r2
811101a4:	01800384 	movi	r6,14
811101a8:	01400044 	movi	r5,1
811101ac:	01204574 	movhi	r4,33045
811101b0:	2131f604 	addi	r4,r4,-14376
811101b4:	11216400 	call	81121640 <fwrite>
				#endif

					if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
811101b8:	e0bffe17 	ldw	r2,-8(fp)
811101bc:	10802c17 	ldw	r2,176(r2)
811101c0:	10800298 	cmpnei	r2,r2,10
811101c4:	10000a1e 	bne	r2,zero,811101f0 <vQCmdFeeRMAPinFullPattern+0x31c>
						pxNFeeP->xControl.bWatingSync = TRUE;
811101c8:	e0bffe17 	ldw	r2,-8(fp)
811101cc:	00c00044 	movi	r3,1
811101d0:	10c02815 	stw	r3,160(r2)
						pxNFeeP->xControl.eMode = sFeeWaitingSync;
811101d4:	e0bffe17 	ldw	r2,-8(fp)
811101d8:	00c00304 	movi	r3,12
811101dc:	10c02c15 	stw	r3,176(r2)
						pxNFeeP->xControl.eNextMode = sToFeeStandBy;
811101e0:	e0bffe17 	ldw	r2,-8(fp)
811101e4:	00c00184 	movi	r3,6
811101e8:	10c02d15 	stw	r3,180(r2)

					//pxNFeeP->xControl.bWatingSync = TRUE;
					//pxNFeeP->xControl.eMode = sFeeTestFullPattern;
					//pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */

					break;
811101ec:	00002306 	br	8111027c <vQCmdFeeRMAPinFullPattern+0x3a8>
					if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
						pxNFeeP->xControl.bWatingSync = TRUE;
						pxNFeeP->xControl.eMode = sFeeWaitingSync;
						pxNFeeP->xControl.eNextMode = sToFeeStandBy;
					} else {
						pxNFeeP->xControl.bWatingSync = TRUE;
811101f0:	e0bffe17 	ldw	r2,-8(fp)
811101f4:	00c00044 	movi	r3,1
811101f8:	10c02815 	stw	r3,160(r2)
						pxNFeeP->xControl.eMode = sFeeTestFullPattern;
811101fc:	e0bffe17 	ldw	r2,-8(fp)
81110200:	00c00104 	movi	r3,4
81110204:	10c02c15 	stw	r3,176(r2)
						pxNFeeP->xControl.eNextMode = sToFeeStandBy;
81110208:	e0bffe17 	ldw	r2,-8(fp)
8111020c:	00c00184 	movi	r3,6
81110210:	10c02d15 	stw	r3,180(r2)

					//pxNFeeP->xControl.bWatingSync = TRUE;
					//pxNFeeP->xControl.eMode = sFeeTestFullPattern;
					//pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */

					break;
81110214:	00001906 	br	8111027c <vQCmdFeeRMAPinFullPattern+0x3a8>
				case 2: /* PAttern Full image */
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
81110218:	d0e06217 	ldw	r3,-32376(gp)
8111021c:	e0bffe17 	ldw	r2,-8(fp)
81110220:	10800003 	ldbu	r2,0(r2)
81110224:	10803fcc 	andi	r2,r2,255
81110228:	100d883a 	mov	r6,r2
8111022c:	01604574 	movhi	r5,33045
81110230:	29714404 	addi	r5,r5,-15088
81110234:	1809883a 	mov	r4,r3
81110238:	1120fa40 	call	81120fa4 <fprintf>
					#endif

					break;
8111023c:	00000f06 	br	8111027c <vQCmdFeeRMAPinFullPattern+0x3a8>
				case 6:
				#ifdef DEBUG_ON
					fprintf(fp," Off-Mode not allowed.\n");
81110240:	d0a06217 	ldw	r2,-32376(gp)
81110244:	100f883a 	mov	r7,r2
81110248:	018005c4 	movi	r6,23
8111024c:	01400044 	movi	r5,1
81110250:	01204574 	movhi	r4,33045
81110254:	2131fa04 	addi	r4,r4,-14360
81110258:	11216400 	call	81121640 <fwrite>
				#endif
					break;
8111025c:	00000706 	br	8111027c <vQCmdFeeRMAPinFullPattern+0x3a8>
				case 3:
				case 4:
				case 5:
				default:
					#ifdef DEBUG_ON
						fprintf(fp," mode not allowed yet ( %hhu )\n", ucValueMasked);
81110260:	d0a06217 	ldw	r2,-32376(gp)
81110264:	e1bffc17 	ldw	r6,-16(fp)
81110268:	01604574 	movhi	r5,33045
8111026c:	29720004 	addi	r5,r5,-14336
81110270:	1009883a 	mov	r4,r2
81110274:	1120fa40 	call	81120fa4 <fprintf>
					#endif
					break;
81110278:	0001883a 	nop
			}

			break;
8111027c:	00002506 	br	81110314 <vQCmdFeeRMAPinFullPattern+0x440>
		case 0x0000004D://0x0000003C:sync_config

			ucValueMasked = (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & ucValueReg) >> 2; /* Number of rows */
81110280:	e0bffa43 	ldbu	r2,-23(fp)
81110284:	1080010c 	andi	r2,r2,4
81110288:	10803fcc 	andi	r2,r2,255
8111028c:	1004d0ba 	srli	r2,r2,2
81110290:	10803fcc 	andi	r2,r2,255
81110294:	e0bffc15 	stw	r2,-16(fp)

			if ( ucValueMasked ) {
81110298:	e0bffc17 	ldw	r2,-16(fp)
8111029c:	10001c26 	beq	r2,zero,81110310 <vQCmdFeeRMAPinFullPattern+0x43c>

				if ( pxNFeeP->xControl.eNextMode == sToFeeStandBy ) {
811102a0:	e0bffe17 	ldw	r2,-8(fp)
811102a4:	10802d17 	ldw	r2,180(r2)
811102a8:	10800198 	cmpnei	r2,r2,6
811102ac:	1000181e 	bne	r2,zero,81110310 <vQCmdFeeRMAPinFullPattern+0x43c>
					pxNFeeP->xControl.bWatingSync = FALSE;
811102b0:	e0bffe17 	ldw	r2,-8(fp)
811102b4:	10002815 	stw	zero,160(r2)
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
811102b8:	e0bffe17 	ldw	r2,-8(fp)
811102bc:	10c02d17 	ldw	r3,180(r2)
811102c0:	e0bffe17 	ldw	r2,-8(fp)
811102c4:	10c02c15 	stw	r3,176(r2)
					#ifdef DEBUG_ON
						fprintf(fp," - Mode Forced.\n");
811102c8:	d0a06217 	ldw	r2,-32376(gp)
811102cc:	100f883a 	mov	r7,r2
811102d0:	01800404 	movi	r6,16
811102d4:	01400044 	movi	r5,1
811102d8:	01204574 	movhi	r4,33045
811102dc:	21320804 	addi	r4,r4,-14304
811102e0:	11216400 	call	81121640 <fwrite>
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);

			}

			break;
811102e4:	00000a06 	br	81110310 <vQCmdFeeRMAPinFullPattern+0x43c>
		case 0x0000004F://0x00000044:clock_source_control
		case 0x00000050://0x00000048:frame_number
		case 0x00000051://0x0000004C:current_mode
		default:
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
811102e8:	d0a06217 	ldw	r2,-32376(gp)
811102ec:	e0fffa03 	ldbu	r3,-24(fp)
811102f0:	180d883a 	mov	r6,r3
811102f4:	01604574 	movhi	r5,33045
811102f8:	2971c904 	addi	r5,r5,-14556
811102fc:	1009883a 	mov	r4,r2
81110300:	1120fa40 	call	81120fa4 <fprintf>
			#endif
			break;
81110304:	00000306 	br	81110314 <vQCmdFeeRMAPinFullPattern+0x440>
				}
			}



			break;
81110308:	0001883a 	nop
8111030c:	00000106 	br	81110314 <vQCmdFeeRMAPinFullPattern+0x440>
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);

			}

			break;
81110310:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			#endif
			break;
		}
}
81110314:	0001883a 	nop
81110318:	e037883a 	mov	sp,fp
8111031c:	dfc00117 	ldw	ra,4(sp)
81110320:	df000017 	ldw	fp,0(sp)
81110324:	dec00204 	addi	sp,sp,8
81110328:	f800283a 	ret

8111032c <vQCmdFeeRMAPWaitingSync>:


void vQCmdFeeRMAPWaitingSync( TNFee *pxNFeeP, unsigned int cmd ){
8111032c:	defff804 	addi	sp,sp,-32
81110330:	de00012e 	bgeu	sp,et,81110338 <vQCmdFeeRMAPWaitingSync+0xc>
81110334:	003b68fa 	trap	3
81110338:	dfc00715 	stw	ra,28(sp)
8111033c:	df000615 	stw	fp,24(sp)
81110340:	df000604 	addi	fp,sp,24
81110344:	e13ffe15 	stw	r4,-8(fp)
81110348:	e17fff15 	stw	r5,-4(fp)
	INT8U ucValueReg;
	INT32U ucValueMasked;
	INT32U ucValueMasked2;

	#ifdef DEBUG_ON
		fprintf(fp,"\nNFEE %hhu Task: RMAP msg received (WaitingSync)\n", pxNFeeP->ucId);
8111034c:	d0e06217 	ldw	r3,-32376(gp)
81110350:	e0bffe17 	ldw	r2,-8(fp)
81110354:	10800003 	ldbu	r2,0(r2)
81110358:	10803fcc 	andi	r2,r2,255
8111035c:	100d883a 	mov	r6,r2
81110360:	01604574 	movhi	r5,33045
81110364:	29720d04 	addi	r5,r5,-14284
81110368:	1809883a 	mov	r4,r3
8111036c:	1120fa40 	call	81120fa4 <fprintf>
	#endif

	uiCmdFEEL.ulWord = cmd;
81110370:	e0bfff17 	ldw	r2,-4(fp)
81110374:	e0bffd15 	stw	r2,-12(fp)

	ucADDRReg = uiCmdFEEL.ucByte[1];
81110378:	e0bffd43 	ldbu	r2,-11(fp)
8111037c:	e0bffa05 	stb	r2,-24(fp)
	ucValueReg = uliRmapReadReg(pxNFeeP->xChannel.xRmap.puliRmapChAddr,  ucADDRReg);
81110380:	e0bffe17 	ldw	r2,-8(fp)
81110384:	10804317 	ldw	r2,268(r2)
81110388:	e0fffa03 	ldbu	r3,-24(fp)
8111038c:	180b883a 	mov	r5,r3
81110390:	1009883a 	mov	r4,r2
81110394:	1109ef80 	call	81109ef8 <uliRmapReadReg>
81110398:	e0bffa45 	stb	r2,-23(fp)


	switch (ucADDRReg) {
8111039c:	e0bffa03 	ldbu	r2,-24(fp)
811103a0:	10c010c8 	cmpgei	r3,r2,67
811103a4:	1800051e 	bne	r3,zero,811103bc <vQCmdFeeRMAPWaitingSync+0x90>
811103a8:	10c01008 	cmpgei	r3,r2,64
811103ac:	1800081e 	bne	r3,zero,811103d0 <vQCmdFeeRMAPWaitingSync+0xa4>
811103b0:	108000a0 	cmpeqi	r2,r2,2
811103b4:	1000a81e 	bne	r2,zero,81110658 <vQCmdFeeRMAPWaitingSync+0x32c>
811103b8:	0000d406 	br	8111070c <vQCmdFeeRMAPWaitingSync+0x3e0>
811103bc:	10c01350 	cmplti	r3,r2,77
811103c0:	1800701e 	bne	r3,zero,81110584 <vQCmdFeeRMAPWaitingSync+0x258>
811103c4:	10801360 	cmpeqi	r2,r2,77
811103c8:	1000b61e 	bne	r2,zero,811106a4 <vQCmdFeeRMAPWaitingSync+0x378>
811103cc:	0000cf06 	br	8111070c <vQCmdFeeRMAPWaitingSync+0x3e0>
		case 0x40://0x00000000: ccd_seq_1_config
		case 0x041://0x00000004:ccd_seq_2_config
		case 0x042://0x00000008:spw_packet_1_config

			if ( (pxNFeeP->xControl.eNextMode == sToTestFullPattern) || (pxNFeeP->xControl.eNextMode == sFeeWaitingSync) )
811103d0:	e0bffe17 	ldw	r2,-8(fp)
811103d4:	10802d17 	ldw	r2,180(r2)
811103d8:	108001e0 	cmpeqi	r2,r2,7
811103dc:	1000041e 	bne	r2,zero,811103f0 <vQCmdFeeRMAPWaitingSync+0xc4>
811103e0:	e0bffe17 	ldw	r2,-8(fp)
811103e4:	10802d17 	ldw	r2,180(r2)
811103e8:	10800318 	cmpnei	r2,r2,12
811103ec:	1000541e 	bne	r2,zero,81110540 <vQCmdFeeRMAPWaitingSync+0x214>
			{

				ucValueMasked2 = (ucValueReg & COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK) >> 2;
811103f0:	e0bffa43 	ldbu	r2,-23(fp)
811103f4:	1080030c 	andi	r2,r2,12
811103f8:	1005d0ba 	srai	r2,r2,2
811103fc:	e0bffb15 	stw	r2,-20(fp)

				switch (ucValueMasked2) {
81110400:	e0bffb17 	ldw	r2,-20(fp)
81110404:	10c000a0 	cmpeqi	r3,r2,2
81110408:	18000e1e 	bne	r3,zero,81110444 <vQCmdFeeRMAPWaitingSync+0x118>
8111040c:	10c000e0 	cmpeqi	r3,r2,3
81110410:	1800171e 	bne	r3,zero,81110470 <vQCmdFeeRMAPWaitingSync+0x144>
81110414:	10800060 	cmpeqi	r2,r2,1
81110418:	10001e26 	beq	r2,zero,81110494 <vQCmdFeeRMAPWaitingSync+0x168>
					case 0b01:
						pxNFeeP->xControl.eSide = sLeft;
8111041c:	e0bffe17 	ldw	r2,-8(fp)
81110420:	10002e15 	stw	zero,184(r2)
						#ifdef DEBUG_ON
							fprintf(fp," - Left side\n");
81110424:	d0a06217 	ldw	r2,-32376(gp)
81110428:	100f883a 	mov	r7,r2
8111042c:	01800344 	movi	r6,13
81110430:	01400044 	movi	r5,1
81110434:	01204574 	movhi	r4,33045
81110438:	21316a04 	addi	r4,r4,-14936
8111043c:	11216400 	call	81121640 <fwrite>
						#endif
						break;
81110440:	00002c06 	br	811104f4 <vQCmdFeeRMAPWaitingSync+0x1c8>
					case 0b10:
						pxNFeeP->xControl.eSide = sRight;
81110444:	e0bffe17 	ldw	r2,-8(fp)
81110448:	00c00044 	movi	r3,1
8111044c:	10c02e15 	stw	r3,184(r2)
						#ifdef DEBUG_ON
							fprintf(fp," - Right side\n");
81110450:	d0a06217 	ldw	r2,-32376(gp)
81110454:	100f883a 	mov	r7,r2
81110458:	01800384 	movi	r6,14
8111045c:	01400044 	movi	r5,1
81110460:	01204574 	movhi	r4,33045
81110464:	21316e04 	addi	r4,r4,-14920
81110468:	11216400 	call	81121640 <fwrite>
						#endif
						break;
8111046c:	00002106 	br	811104f4 <vQCmdFeeRMAPWaitingSync+0x1c8>
					case 0b11:
						pxNFeeP->xControl.eSide = sLeft;
81110470:	e0bffe17 	ldw	r2,-8(fp)
81110474:	10002e15 	stw	zero,184(r2)
						#ifdef DEBUG_ON
							fprintf(fp," - Both sides, but not supported yet. Switching to Left side\n");
81110478:	d0a06217 	ldw	r2,-32376(gp)
8111047c:	100f883a 	mov	r7,r2
81110480:	01800f44 	movi	r6,61
81110484:	01400044 	movi	r5,1
81110488:	01204574 	movhi	r4,33045
8111048c:	21317204 	addi	r4,r4,-14904
81110490:	11216400 	call	81121640 <fwrite>
						#endif
					default:
						pxNFeeP->xControl.eSide = sLeft;
81110494:	e0bffe17 	ldw	r2,-8(fp)
81110498:	10002e15 	stw	zero,184(r2)

						bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8111049c:	e0bffe17 	ldw	r2,-8(fp)
811104a0:	10804304 	addi	r2,r2,268
811104a4:	1009883a 	mov	r4,r2
811104a8:	11081800 	call	81108180 <bRmapGetMemConfigArea>
						pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config & 0xFFFFFFF7);
811104ac:	e0bffe17 	ldw	r2,-8(fp)
811104b0:	10c05717 	ldw	r3,348(r2)
811104b4:	00bffdc4 	movi	r2,-9
811104b8:	1886703a 	and	r3,r3,r2
811104bc:	e0bffe17 	ldw	r2,-8(fp)
811104c0:	10c05715 	stw	r3,348(r2)
						bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
811104c4:	e0bffe17 	ldw	r2,-8(fp)
811104c8:	10804304 	addi	r2,r2,268
811104cc:	1009883a 	mov	r4,r2
811104d0:	1107e940 	call	81107e94 <bRmapSetMemConfigArea>
						#ifdef DEBUG_ON
							fprintf(fp," - Switching to Left side\n");
811104d4:	d0a06217 	ldw	r2,-32376(gp)
811104d8:	100f883a 	mov	r7,r2
811104dc:	01800684 	movi	r6,26
811104e0:	01400044 	movi	r5,1
811104e4:	01204574 	movhi	r4,33045
811104e8:	21318204 	addi	r4,r4,-14840
811104ec:	11216400 	call	81121640 <fwrite>
						#endif
					break;
811104f0:	0001883a 	nop
				}
				#ifdef DEBUG_ON
					fprintf(fp,"\nNFEE %hhu Task: Side changed (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
811104f4:	d0e06217 	ldw	r3,-32376(gp)
811104f8:	e0bffe17 	ldw	r2,-8(fp)
811104fc:	10800003 	ldbu	r2,0(r2)
81110500:	11003fcc 	andi	r4,r2,255
81110504:	e0bffe17 	ldw	r2,-8(fp)
81110508:	10802e17 	ldw	r2,184(r2)
8111050c:	100f883a 	mov	r7,r2
81110510:	200d883a 	mov	r6,r4
81110514:	01604574 	movhi	r5,33045
81110518:	29718904 	addi	r5,r5,-14812
8111051c:	1809883a 	mov	r4,r3
81110520:	1120fa40 	call	81120fa4 <fprintf>
				#endif


				pxNFeeP->xControl.eMode =  sNextPatternIteration;
81110524:	e0bffe17 	ldw	r2,-8(fp)
81110528:	00c00284 	movi	r3,10
8111052c:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode =  sFeeWaitingSync;
81110530:	e0bffe17 	ldw	r2,-8(fp)
81110534:	00c00304 	movi	r3,12
81110538:	10c02d15 	stw	r3,180(r2)
					#ifdef DEBUG_ON
						fprintf(fp,"\nNFEE %hhu Task: Can't change the CCD side while in transmission (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
					#endif
				}
			}
			break;
8111053c:	00007b06 	br	8111072c <vQCmdFeeRMAPWaitingSync+0x400>


				pxNFeeP->xControl.eMode =  sNextPatternIteration;
				pxNFeeP->xControl.eNextMode =  sFeeWaitingSync;
			} else {
				if (pxNFeeP->xControl.eNextMode == sFeeTestFullPattern) {
81110540:	e0bffe17 	ldw	r2,-8(fp)
81110544:	10802d17 	ldw	r2,180(r2)
81110548:	10800118 	cmpnei	r2,r2,4
8111054c:	1000771e 	bne	r2,zero,8111072c <vQCmdFeeRMAPWaitingSync+0x400>
					#ifdef DEBUG_ON
						fprintf(fp,"\nNFEE %hhu Task: Can't change the CCD side while in transmission (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
81110550:	d0e06217 	ldw	r3,-32376(gp)
81110554:	e0bffe17 	ldw	r2,-8(fp)
81110558:	10800003 	ldbu	r2,0(r2)
8111055c:	11003fcc 	andi	r4,r2,255
81110560:	e0bffe17 	ldw	r2,-8(fp)
81110564:	10802e17 	ldw	r2,184(r2)
81110568:	100f883a 	mov	r7,r2
8111056c:	200d883a 	mov	r6,r4
81110570:	01604574 	movhi	r5,33045
81110574:	2971df04 	addi	r5,r5,-14468
81110578:	1809883a 	mov	r4,r3
8111057c:	1120fa40 	call	81120fa4 <fprintf>
					#endif
				}
			}
			break;
81110580:	00006a06 	br	8111072c <vQCmdFeeRMAPWaitingSync+0x400>
		case 0x49://0x00000024:CCD_3_windowing_2_config
		case 0x4A://0x00000028:CCD_4_windowing_1_config
		case 0x4B://0x0000002C:CCD_4_windowing_2_config
		case 0x0000004C://0x00000038:operation_mode_config

		ucValueMasked = (COMM_RMAP_MODE_SEL_CTRL_MSK & ucValueReg) >>4;
81110584:	e0bffa43 	ldbu	r2,-23(fp)
81110588:	1004d13a 	srli	r2,r2,4
8111058c:	10803fcc 	andi	r2,r2,255
81110590:	e0bffc15 	stw	r2,-16(fp)

		switch (ucValueMasked) {
81110594:	e0bffc17 	ldw	r2,-16(fp)
81110598:	10c000a0 	cmpeqi	r3,r2,2
8111059c:	1800141e 	bne	r3,zero,811105f0 <vQCmdFeeRMAPWaitingSync+0x2c4>
811105a0:	10c001a0 	cmpeqi	r3,r2,6
811105a4:	18001c1e 	bne	r3,zero,81110618 <vQCmdFeeRMAPWaitingSync+0x2ec>
811105a8:	1000231e 	bne	r2,zero,81110638 <vQCmdFeeRMAPWaitingSync+0x30c>
			case 0: /* Standby */
			#ifdef DEBUG_ON
				fprintf(fp,"- to Stand-By\n");
811105ac:	d0a06217 	ldw	r2,-32376(gp)
811105b0:	100f883a 	mov	r7,r2
811105b4:	01800384 	movi	r6,14
811105b8:	01400044 	movi	r5,1
811105bc:	01204574 	movhi	r4,33045
811105c0:	2131f604 	addi	r4,r4,-14376
811105c4:	11216400 	call	81121640 <fwrite>
			#endif

				pxNFeeP->xControl.bWatingSync = TRUE;
811105c8:	e0bffe17 	ldw	r2,-8(fp)
811105cc:	00c00044 	movi	r3,1
811105d0:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
811105d4:	e0bffe17 	ldw	r2,-8(fp)
811105d8:	00c00304 	movi	r3,12
811105dc:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
811105e0:	e0bffe17 	ldw	r2,-8(fp)
811105e4:	00c00184 	movi	r3,6
811105e8:	10c02d15 	stw	r3,180(r2)


				break;
811105ec:	00001906 	br	81110654 <vQCmdFeeRMAPWaitingSync+0x328>
			case 2: /* PAttern Full image */

				pxNFeeP->xControl.bWatingSync = TRUE;
811105f0:	e0bffe17 	ldw	r2,-8(fp)
811105f4:	00c00044 	movi	r3,1
811105f8:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync; /*sSIMTestFullPattern*/
811105fc:	e0bffe17 	ldw	r2,-8(fp)
81110600:	00c00304 	movi	r3,12
81110604:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sNextPatternIteration;
81110608:	e0bffe17 	ldw	r2,-8(fp)
8111060c:	00c00284 	movi	r3,10
81110610:	10c02d15 	stw	r3,180(r2)

				break;
81110614:	00000f06 	br	81110654 <vQCmdFeeRMAPWaitingSync+0x328>
			case 6:
			#ifdef DEBUG_ON
				fprintf(fp," Off-Mode not allowed.\n");
81110618:	d0a06217 	ldw	r2,-32376(gp)
8111061c:	100f883a 	mov	r7,r2
81110620:	018005c4 	movi	r6,23
81110624:	01400044 	movi	r5,1
81110628:	01204574 	movhi	r4,33045
8111062c:	2131fa04 	addi	r4,r4,-14360
81110630:	11216400 	call	81121640 <fwrite>
			#endif
				break;
81110634:	00000706 	br	81110654 <vQCmdFeeRMAPWaitingSync+0x328>
			case 3:
			case 4:
			case 5:
			default:
				#ifdef DEBUG_ON
					fprintf(fp," mode not allowed yet ( %hhu )\n", ucValueMasked);
81110638:	d0a06217 	ldw	r2,-32376(gp)
8111063c:	e1bffc17 	ldw	r6,-16(fp)
81110640:	01604574 	movhi	r5,33045
81110644:	29720004 	addi	r5,r5,-14336
81110648:	1009883a 	mov	r4,r2
8111064c:	1120fa40 	call	81120fa4 <fprintf>
				#endif
				break;
81110650:	0001883a 	nop
		}

			break;
81110654:	00003806 	br	81110738 <vQCmdFeeRMAPWaitingSync+0x40c>
		case 2: /* PAttern Full image */
			#ifdef DEBUG_ON
				fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
81110658:	d0e06217 	ldw	r3,-32376(gp)
8111065c:	e0bffe17 	ldw	r2,-8(fp)
81110660:	10800003 	ldbu	r2,0(r2)
81110664:	10803fcc 	andi	r2,r2,255
81110668:	100d883a 	mov	r6,r2
8111066c:	01604574 	movhi	r5,33045
81110670:	29714404 	addi	r5,r5,-15088
81110674:	1809883a 	mov	r4,r3
81110678:	1120fa40 	call	81120fa4 <fprintf>
			#endif

			pxNFeeP->xControl.bWatingSync = TRUE;
8111067c:	e0bffe17 	ldw	r2,-8(fp)
81110680:	00c00044 	movi	r3,1
81110684:	10c02815 	stw	r3,160(r2)
			pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
81110688:	e0bffe17 	ldw	r2,-8(fp)
8111068c:	00c00284 	movi	r3,10
81110690:	10c02c15 	stw	r3,176(r2)
			pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
81110694:	e0bffe17 	ldw	r2,-8(fp)
81110698:	00c00304 	movi	r3,12
8111069c:	10c02d15 	stw	r3,180(r2)

			break;
811106a0:	00002506 	br	81110738 <vQCmdFeeRMAPWaitingSync+0x40c>
		case 0x0000004D://0x0000003C:sync_config

			ucValueMasked = (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & ucValueReg) >> 2; /* Number of rows */
811106a4:	e0bffa43 	ldbu	r2,-23(fp)
811106a8:	1080010c 	andi	r2,r2,4
811106ac:	10803fcc 	andi	r2,r2,255
811106b0:	1004d0ba 	srli	r2,r2,2
811106b4:	10803fcc 	andi	r2,r2,255
811106b8:	e0bffc15 	stw	r2,-16(fp)

			if ( ucValueMasked ) {
811106bc:	e0bffc17 	ldw	r2,-16(fp)
811106c0:	10001c26 	beq	r2,zero,81110734 <vQCmdFeeRMAPWaitingSync+0x408>

				if ( pxNFeeP->xControl.eNextMode == sToFeeStandBy ) {
811106c4:	e0bffe17 	ldw	r2,-8(fp)
811106c8:	10802d17 	ldw	r2,180(r2)
811106cc:	10800198 	cmpnei	r2,r2,6
811106d0:	1000181e 	bne	r2,zero,81110734 <vQCmdFeeRMAPWaitingSync+0x408>
					pxNFeeP->xControl.bWatingSync = FALSE;
811106d4:	e0bffe17 	ldw	r2,-8(fp)
811106d8:	10002815 	stw	zero,160(r2)
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
811106dc:	e0bffe17 	ldw	r2,-8(fp)
811106e0:	10c02d17 	ldw	r3,180(r2)
811106e4:	e0bffe17 	ldw	r2,-8(fp)
811106e8:	10c02c15 	stw	r3,176(r2)
					#ifdef DEBUG_ON
						fprintf(fp," - Mode Forced.\n");
811106ec:	d0a06217 	ldw	r2,-32376(gp)
811106f0:	100f883a 	mov	r7,r2
811106f4:	01800404 	movi	r6,16
811106f8:	01400044 	movi	r5,1
811106fc:	01204574 	movhi	r4,33045
81110700:	21320804 	addi	r4,r4,-14304
81110704:	11216400 	call	81121640 <fwrite>
//				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
			}

			break;
81110708:	00000a06 	br	81110734 <vQCmdFeeRMAPWaitingSync+0x408>
		case 0x0000004F://0x00000044:clock_source_control
		case 0x00000050://0x00000048:frame_number
		case 0x00000051://0x0000004C:current_mode
		default:
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
8111070c:	d0a06217 	ldw	r2,-32376(gp)
81110710:	e0fffa03 	ldbu	r3,-24(fp)
81110714:	180d883a 	mov	r6,r3
81110718:	01604574 	movhi	r5,33045
8111071c:	2971c904 	addi	r5,r5,-14556
81110720:	1009883a 	mov	r4,r2
81110724:	1120fa40 	call	81120fa4 <fprintf>
			#endif
			break;
81110728:	00000306 	br	81110738 <vQCmdFeeRMAPWaitingSync+0x40c>
					#ifdef DEBUG_ON
						fprintf(fp,"\nNFEE %hhu Task: Can't change the CCD side while in transmission (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
					#endif
				}
			}
			break;
8111072c:	0001883a 	nop
81110730:	00000106 	br	81110738 <vQCmdFeeRMAPWaitingSync+0x40c>
//				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
			}

			break;
81110734:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			#endif
			break;
		}
}
81110738:	0001883a 	nop
8111073c:	e037883a 	mov	sp,fp
81110740:	dfc00117 	ldw	ra,4(sp)
81110744:	df000017 	ldw	fp,0(sp)
81110748:	dec00204 	addi	sp,sp,8
8111074c:	f800283a 	ret

81110750 <bDisableRmapIRQ>:


bool bDisableRmapIRQ( TRmapChannel *pxRmapCh, unsigned char ucId ) {
81110750:	defffc04 	addi	sp,sp,-16
81110754:	de00012e 	bgeu	sp,et,8111075c <bDisableRmapIRQ+0xc>
81110758:	003b68fa 	trap	3
8111075c:	dfc00315 	stw	ra,12(sp)
81110760:	df000215 	stw	fp,8(sp)
81110764:	df000204 	addi	fp,sp,8
81110768:	e13ffe15 	stw	r4,-8(fp)
8111076c:	2805883a 	mov	r2,r5
81110770:	e0bfff05 	stb	r2,-4(fp)
	/* Disable RMAP channel */
	bRmapGetIrqControl(pxRmapCh);
81110774:	e13ffe17 	ldw	r4,-8(fp)
81110778:	11079600 	call	81107960 <bRmapGetIrqControl>
	pxRmapCh->xRmapIrqControl.bWriteCmdEn = FALSE;
8111077c:	e0bffe17 	ldw	r2,-8(fp)
81110780:	10001015 	stw	zero,64(r2)
	bRmapSetIrqControl(pxRmapCh);
81110784:	e13ffe17 	ldw	r4,-8(fp)
81110788:	11078b80 	call	811078b8 <bRmapSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
8111078c:	00800044 	movi	r2,1
}
81110790:	e037883a 	mov	sp,fp
81110794:	dfc00117 	ldw	ra,4(sp)
81110798:	df000017 	ldw	fp,0(sp)
8111079c:	dec00204 	addi	sp,sp,8
811107a0:	f800283a 	ret

811107a4 <bEnableRmapIRQ>:

bool bEnableRmapIRQ( TRmapChannel *pxRmapCh, unsigned char ucId ) {
811107a4:	defffc04 	addi	sp,sp,-16
811107a8:	de00012e 	bgeu	sp,et,811107b0 <bEnableRmapIRQ+0xc>
811107ac:	003b68fa 	trap	3
811107b0:	dfc00315 	stw	ra,12(sp)
811107b4:	df000215 	stw	fp,8(sp)
811107b8:	df000204 	addi	fp,sp,8
811107bc:	e13ffe15 	stw	r4,-8(fp)
811107c0:	2805883a 	mov	r2,r5
811107c4:	e0bfff05 	stb	r2,-4(fp)
	/* Enable RMAP */
	/* Before Enable the IRQ for Rmap, make a copy for compare when some command arrive */
	//bRmapGetMemConfigArea(&xRmap[ucId]);

	bRmapGetIrqControl(pxRmapCh);
811107c8:	e13ffe17 	ldw	r4,-8(fp)
811107cc:	11079600 	call	81107960 <bRmapGetIrqControl>
	pxRmapCh->xRmapIrqControl.bWriteCmdEn = TRUE;
811107d0:	e0bffe17 	ldw	r2,-8(fp)
811107d4:	00c00044 	movi	r3,1
811107d8:	10c01015 	stw	r3,64(r2)
	bRmapSetIrqControl(pxRmapCh);
811107dc:	e13ffe17 	ldw	r4,-8(fp)
811107e0:	11078b80 	call	811078b8 <bRmapSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
811107e4:	00800044 	movi	r2,1
}
811107e8:	e037883a 	mov	sp,fp
811107ec:	dfc00117 	ldw	ra,4(sp)
811107f0:	df000017 	ldw	fp,0(sp)
811107f4:	dec00204 	addi	sp,sp,8
811107f8:	f800283a 	ret

811107fc <bDisableSPWChannel>:

bool bDisableSPWChannel( TSpwcChannel *xSPW ) {
811107fc:	defffd04 	addi	sp,sp,-12
81110800:	de00012e 	bgeu	sp,et,81110808 <bDisableSPWChannel+0xc>
81110804:	003b68fa 	trap	3
81110808:	dfc00215 	stw	ra,8(sp)
8111080c:	df000115 	stw	fp,4(sp)
81110810:	df000104 	addi	fp,sp,4
81110814:	e13fff15 	stw	r4,-4(fp)
	/* Disable SPW channel */
	bSpwcGetLink(xSPW);
81110818:	e13fff17 	ldw	r4,-4(fp)
8111081c:	110a2e40 	call	8110a2e4 <bSpwcGetLink>
	xSPW->xLinkConfig.bLinkStart = FALSE;
81110820:	e0bfff17 	ldw	r2,-4(fp)
81110824:	10000215 	stw	zero,8(r2)
	xSPW->xLinkConfig.bAutostart = FALSE;
81110828:	e0bfff17 	ldw	r2,-4(fp)
8111082c:	10000115 	stw	zero,4(r2)
	xSPW->xLinkConfig.bDisconnect = TRUE;
81110830:	e0bfff17 	ldw	r2,-4(fp)
81110834:	00c00044 	movi	r3,1
81110838:	10c00315 	stw	r3,12(r2)
	bSpwcSetLink(xSPW);
8111083c:	e13fff17 	ldw	r4,-4(fp)
81110840:	110a1b00 	call	8110a1b0 <bSpwcSetLink>

	/*todo: No treatment for now  */
	return TRUE;
81110844:	00800044 	movi	r2,1
}
81110848:	e037883a 	mov	sp,fp
8111084c:	dfc00117 	ldw	ra,4(sp)
81110850:	df000017 	ldw	fp,0(sp)
81110854:	dec00204 	addi	sp,sp,8
81110858:	f800283a 	ret

8111085c <bEnableSPWChannel>:

bool bEnableSPWChannel( TSpwcChannel *xSPW ) {
8111085c:	defffd04 	addi	sp,sp,-12
81110860:	de00012e 	bgeu	sp,et,81110868 <bEnableSPWChannel+0xc>
81110864:	003b68fa 	trap	3
81110868:	dfc00215 	stw	ra,8(sp)
8111086c:	df000115 	stw	fp,4(sp)
81110870:	df000104 	addi	fp,sp,4
81110874:	e13fff15 	stw	r4,-4(fp)
	/* Enable SPW channel */
	bSpwcGetLink(xSPW);
81110878:	e13fff17 	ldw	r4,-4(fp)
8111087c:	110a2e40 	call	8110a2e4 <bSpwcGetLink>
	xSPW->xLinkConfig.bLinkStart = FALSE;
81110880:	e0bfff17 	ldw	r2,-4(fp)
81110884:	10000215 	stw	zero,8(r2)
	xSPW->xLinkConfig.bAutostart = TRUE;
81110888:	e0bfff17 	ldw	r2,-4(fp)
8111088c:	00c00044 	movi	r3,1
81110890:	10c00115 	stw	r3,4(r2)
	xSPW->xLinkConfig.bDisconnect = FALSE;
81110894:	e0bfff17 	ldw	r2,-4(fp)
81110898:	10000315 	stw	zero,12(r2)
	bSpwcSetLink(xSPW);
8111089c:	e13fff17 	ldw	r4,-4(fp)
811108a0:	110a1b00 	call	8110a1b0 <bSpwcSetLink>

	/*todo: No treatment for now  */
	return TRUE;
811108a4:	00800044 	movi	r2,1
}
811108a8:	e037883a 	mov	sp,fp
811108ac:	dfc00117 	ldw	ra,4(sp)
811108b0:	df000017 	ldw	fp,0(sp)
811108b4:	dec00204 	addi	sp,sp,8
811108b8:	f800283a 	ret

811108bc <bEnableDbBuffer>:

bool bEnableDbBuffer( TFeebChannel *pxFeebCh ) {
811108bc:	defffd04 	addi	sp,sp,-12
811108c0:	de00012e 	bgeu	sp,et,811108c8 <bEnableDbBuffer+0xc>
811108c4:	003b68fa 	trap	3
811108c8:	dfc00215 	stw	ra,8(sp)
811108cc:	df000115 	stw	fp,4(sp)
811108d0:	df000104 	addi	fp,sp,4
811108d4:	e13fff15 	stw	r4,-4(fp)

	/* Clear all buffer form the Double Buffer */
	bFeebClrCh(pxFeebCh);
811108d8:	e13fff17 	ldw	r4,-4(fp)
811108dc:	1106aa80 	call	81106aa8 <bFeebClrCh>

	/* Start the module Double Buffer */
	bFeebStartCh(pxFeebCh);
811108e0:	e13fff17 	ldw	r4,-4(fp)
811108e4:	11069980 	call	81106998 <bFeebStartCh>

	/*Enable IRQ of FEE Buffer*/
	bFeebGetWindowing(pxFeebCh);
811108e8:	e13fff17 	ldw	r4,-4(fp)
811108ec:	11069100 	call	81106910 <bFeebGetWindowing>
	//pxFeebCh->xWindowingConfig.bMasking = DATA_PACKET;/* True= data packet;    FALSE= Transparent mode */
	pxFeebCh->xWindowingConfig.bMasking = xDefaults.bDataPacket;
811108f0:	00a045b4 	movhi	r2,33046
811108f4:	1099c904 	addi	r2,r2,26404
811108f8:	10c00817 	ldw	r3,32(r2)
811108fc:	e0bfff17 	ldw	r2,-4(fp)
81110900:	10c00115 	stw	r3,4(r2)
	bFeebSetWindowing(pxFeebCh);
81110904:	e13fff17 	ldw	r4,-4(fp)
81110908:	11068680 	call	81106868 <bFeebSetWindowing>

	/*Enable IRQ of FEE Buffer*/
	bFeebGetIrqControl(pxFeebCh);
8111090c:	e13fff17 	ldw	r4,-4(fp)
81110910:	11062b80 	call	811062b8 <bFeebGetIrqControl>
	pxFeebCh->xIrqControl.bLeftBufferEmptyEn = TRUE;
81110914:	e0bfff17 	ldw	r2,-4(fp)
81110918:	00c00044 	movi	r3,1
8111091c:	10c00215 	stw	r3,8(r2)
	pxFeebCh->xIrqControl.bRightBufferEmptyEn = TRUE;
81110920:	e0bfff17 	ldw	r2,-4(fp)
81110924:	00c00044 	movi	r3,1
81110928:	10c00315 	stw	r3,12(r2)
	bFeebSetIrqControl(pxFeebCh);
8111092c:	e13fff17 	ldw	r4,-4(fp)
81110930:	11061e40 	call	811061e4 <bFeebSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
81110934:	00800044 	movi	r2,1
}
81110938:	e037883a 	mov	sp,fp
8111093c:	dfc00117 	ldw	ra,4(sp)
81110940:	df000017 	ldw	fp,0(sp)
81110944:	dec00204 	addi	sp,sp,8
81110948:	f800283a 	ret

8111094c <bDisAndClrDbBuffer>:


bool bDisAndClrDbBuffer( TFeebChannel *pxFeebCh ) {
8111094c:	defffd04 	addi	sp,sp,-12
81110950:	de00012e 	bgeu	sp,et,81110958 <bDisAndClrDbBuffer+0xc>
81110954:	003b68fa 	trap	3
81110958:	dfc00215 	stw	ra,8(sp)
8111095c:	df000115 	stw	fp,4(sp)
81110960:	df000104 	addi	fp,sp,4
81110964:	e13fff15 	stw	r4,-4(fp)

	/*Disable IRQ of FEE Buffer*/
	bFeebGetIrqControl(pxFeebCh);
81110968:	e13fff17 	ldw	r4,-4(fp)
8111096c:	11062b80 	call	811062b8 <bFeebGetIrqControl>
	pxFeebCh->xIrqControl.bLeftBufferEmptyEn = FALSE;
81110970:	e0bfff17 	ldw	r2,-4(fp)
81110974:	10000215 	stw	zero,8(r2)
	pxFeebCh->xIrqControl.bRightBufferEmptyEn = FALSE;
81110978:	e0bfff17 	ldw	r2,-4(fp)
8111097c:	10000315 	stw	zero,12(r2)
	bFeebSetIrqControl(pxFeebCh);
81110980:	e13fff17 	ldw	r4,-4(fp)
81110984:	11061e40 	call	811061e4 <bFeebSetIrqControl>

	/* Stop the module Double Buffer */
	bFeebStopCh(pxFeebCh);
81110988:	e13fff17 	ldw	r4,-4(fp)
8111098c:	1106a200 	call	81106a20 <bFeebStopCh>

	/* Clear all buffer form the Double Buffer */
	bFeebClrCh(pxFeebCh);
81110990:	e13fff17 	ldw	r4,-4(fp)
81110994:	1106aa80 	call	81106aa8 <bFeebClrCh>

	/*todo: No treatment for now  */
	return TRUE;
81110998:	00800044 	movi	r2,1
}
8111099c:	e037883a 	mov	sp,fp
811109a0:	dfc00117 	ldw	ra,4(sp)
811109a4:	df000017 	ldw	fp,0(sp)
811109a8:	dec00204 	addi	sp,sp,8
811109ac:	f800283a 	ret

811109b0 <bSendRequestNFeeCtrl>:

bool bSendRequestNFeeCtrl( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
811109b0:	defff804 	addi	sp,sp,-32
811109b4:	de00012e 	bgeu	sp,et,811109bc <bSendRequestNFeeCtrl+0xc>
811109b8:	003b68fa 	trap	3
811109bc:	dfc00715 	stw	ra,28(sp)
811109c0:	df000615 	stw	fp,24(sp)
811109c4:	df000604 	addi	fp,sp,24
811109c8:	2807883a 	mov	r3,r5
811109cc:	3005883a 	mov	r2,r6
811109d0:	e13ffd05 	stb	r4,-12(fp)
811109d4:	e0fffe05 	stb	r3,-8(fp)
811109d8:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
811109dc:	00800404 	movi	r2,16
811109e0:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
811109e4:	e0bffd03 	ldbu	r2,-12(fp)
811109e8:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
811109ec:	e0bffe03 	ldbu	r2,-8(fp)
811109f0:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
811109f4:	e0bfff03 	ldbu	r2,-4(fp)
811109f8:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
811109fc:	e03ffa15 	stw	zero,-24(fp)
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
81110a00:	d0a05d17 	ldw	r2,-32396(gp)
81110a04:	e0fffc17 	ldw	r3,-16(fp)
81110a08:	180b883a 	mov	r5,r3
81110a0c:	1009883a 	mov	r4,r2
81110a10:	113d9d00 	call	8113d9d0 <OSQPost>
81110a14:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81110a18:	e0bffb03 	ldbu	r2,-20(fp)
81110a1c:	10000526 	beq	r2,zero,81110a34 <bSendRequestNFeeCtrl+0x84>
		vFailRequestDMA( ucValue );
81110a20:	e0bfff03 	ldbu	r2,-4(fp)
81110a24:	1009883a 	mov	r4,r2
81110a28:	111cee00 	call	8111cee0 <vFailRequestDMA>
		bSuccesL = FALSE;
81110a2c:	e03ffa15 	stw	zero,-24(fp)
81110a30:	00000206 	br	81110a3c <bSendRequestNFeeCtrl+0x8c>
	} else {
		bSuccesL =  TRUE;
81110a34:	00800044 	movi	r2,1
81110a38:	e0bffa15 	stw	r2,-24(fp)
	}

	return bSuccesL;
81110a3c:	e0bffa17 	ldw	r2,-24(fp)
}
81110a40:	e037883a 	mov	sp,fp
81110a44:	dfc00117 	ldw	ra,4(sp)
81110a48:	df000017 	ldw	fp,0(sp)
81110a4c:	dec00204 	addi	sp,sp,8
81110a50:	f800283a 	ret

81110a54 <bSendGiveBackNFeeCtrl>:


bool bSendGiveBackNFeeCtrl( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81110a54:	defff804 	addi	sp,sp,-32
81110a58:	de00012e 	bgeu	sp,et,81110a60 <bSendGiveBackNFeeCtrl+0xc>
81110a5c:	003b68fa 	trap	3
81110a60:	dfc00715 	stw	ra,28(sp)
81110a64:	df000615 	stw	fp,24(sp)
81110a68:	df000604 	addi	fp,sp,24
81110a6c:	2807883a 	mov	r3,r5
81110a70:	3005883a 	mov	r2,r6
81110a74:	e13ffd05 	stb	r4,-12(fp)
81110a78:	e0fffe05 	stb	r3,-8(fp)
81110a7c:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81110a80:	00800404 	movi	r2,16
81110a84:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81110a88:	e0bffd03 	ldbu	r2,-12(fp)
81110a8c:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81110a90:	e0bffe03 	ldbu	r2,-8(fp)
81110a94:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81110a98:	e0bfff03 	ldbu	r2,-4(fp)
81110a9c:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
81110aa0:	e03ffa15 	stw	zero,-24(fp)
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
81110aa4:	d0a07017 	ldw	r2,-32320(gp)
81110aa8:	e0fffc17 	ldw	r3,-16(fp)
81110aac:	180b883a 	mov	r5,r3
81110ab0:	1009883a 	mov	r4,r2
81110ab4:	113d9d00 	call	8113d9d0 <OSQPost>
81110ab8:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81110abc:	e0bffb03 	ldbu	r2,-20(fp)
81110ac0:	10000526 	beq	r2,zero,81110ad8 <bSendGiveBackNFeeCtrl+0x84>
		vFailRequestDMA( ucValue );
81110ac4:	e0bfff03 	ldbu	r2,-4(fp)
81110ac8:	1009883a 	mov	r4,r2
81110acc:	111cee00 	call	8111cee0 <vFailRequestDMA>
		bSuccesL = FALSE;
81110ad0:	e03ffa15 	stw	zero,-24(fp)
81110ad4:	00000206 	br	81110ae0 <bSendGiveBackNFeeCtrl+0x8c>
	} else {
		bSuccesL =  TRUE;
81110ad8:	00800044 	movi	r2,1
81110adc:	e0bffa15 	stw	r2,-24(fp)
	}

	return bSuccesL;
81110ae0:	e0bffa17 	ldw	r2,-24(fp)
}
81110ae4:	e037883a 	mov	sp,fp
81110ae8:	dfc00117 	ldw	ra,4(sp)
81110aec:	df000017 	ldw	fp,0(sp)
81110af0:	dec00204 	addi	sp,sp,8
81110af4:	f800283a 	ret

81110af8 <vPrintConsoleNFee>:




#ifdef DEBUG_ON
	void vPrintConsoleNFee( TNFee *pxNFeeI ) {
81110af8:	defffa04 	addi	sp,sp,-24
81110afc:	de00012e 	bgeu	sp,et,81110b04 <vPrintConsoleNFee+0xc>
81110b00:	003b68fa 	trap	3
81110b04:	dfc00515 	stw	ra,20(sp)
81110b08:	df000415 	stw	fp,16(sp)
81110b0c:	df000404 	addi	fp,sp,16
81110b10:	e13fff15 	stw	r4,-4(fp)
		TNFee *pxNFee;

		pxNFee = pxNFeeI;
81110b14:	e0bfff17 	ldw	r2,-4(fp)
81110b18:	e0bffe15 	stw	r2,-8(fp)

		fprintf(fp,"=================================NFEE %hhu=====================================\n", pxNFee->ucId);
81110b1c:	d0e06217 	ldw	r3,-32376(gp)
81110b20:	e0bffe17 	ldw	r2,-8(fp)
81110b24:	10800003 	ldbu	r2,0(r2)
81110b28:	10803fcc 	andi	r2,r2,255
81110b2c:	100d883a 	mov	r6,r2
81110b30:	01604574 	movhi	r5,33045
81110b34:	29721a04 	addi	r5,r5,-14232
81110b38:	1809883a 	mov	r4,r3
81110b3c:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"\n");
81110b40:	d0a06217 	ldw	r2,-32376(gp)
81110b44:	100b883a 	mov	r5,r2
81110b48:	01000284 	movi	r4,10
81110b4c:	112101c0 	call	8112101c <fputc>
		fprintf(fp,"NFEE %hhu CCD infos: \n", pxNFee->ucId);
81110b50:	d0e06217 	ldw	r3,-32376(gp)
81110b54:	e0bffe17 	ldw	r2,-8(fp)
81110b58:	10800003 	ldbu	r2,0(r2)
81110b5c:	10803fcc 	andi	r2,r2,255
81110b60:	100d883a 	mov	r6,r2
81110b64:	01604574 	movhi	r5,33045
81110b68:	29722f04 	addi	r5,r5,-14148
81110b6c:	1809883a 	mov	r4,r3
81110b70:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"    PreScan = %hu \n", pxNFee->xCcdInfo.usiSPrescanN);
81110b74:	d0e06217 	ldw	r3,-32376(gp)
81110b78:	e0bffe17 	ldw	r2,-8(fp)
81110b7c:	10802f0b 	ldhu	r2,188(r2)
81110b80:	10bfffcc 	andi	r2,r2,65535
81110b84:	100d883a 	mov	r6,r2
81110b88:	01604574 	movhi	r5,33045
81110b8c:	29723504 	addi	r5,r5,-14124
81110b90:	1809883a 	mov	r4,r3
81110b94:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"    OverScan = %hu \n", pxNFee->xCcdInfo.usiSOverscanN);
81110b98:	d0e06217 	ldw	r3,-32376(gp)
81110b9c:	e0bffe17 	ldw	r2,-8(fp)
81110ba0:	10802f8b 	ldhu	r2,190(r2)
81110ba4:	10bfffcc 	andi	r2,r2,65535
81110ba8:	100d883a 	mov	r6,r2
81110bac:	01604574 	movhi	r5,33045
81110bb0:	29723a04 	addi	r5,r5,-14104
81110bb4:	1809883a 	mov	r4,r3
81110bb8:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"    OLN = %hu \n", pxNFee->xCcdInfo.usiOLN);
81110bbc:	d0e06217 	ldw	r3,-32376(gp)
81110bc0:	e0bffe17 	ldw	r2,-8(fp)
81110bc4:	1080300b 	ldhu	r2,192(r2)
81110bc8:	10bfffcc 	andi	r2,r2,65535
81110bcc:	100d883a 	mov	r6,r2
81110bd0:	01604574 	movhi	r5,33045
81110bd4:	29724004 	addi	r5,r5,-14080
81110bd8:	1809883a 	mov	r4,r3
81110bdc:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"    Half Width = %hu \n", pxNFee->xCcdInfo.usiHalfWidth);
81110be0:	d0e06217 	ldw	r3,-32376(gp)
81110be4:	e0bffe17 	ldw	r2,-8(fp)
81110be8:	1080308b 	ldhu	r2,194(r2)
81110bec:	10bfffcc 	andi	r2,r2,65535
81110bf0:	100d883a 	mov	r6,r2
81110bf4:	01604574 	movhi	r5,33045
81110bf8:	29724404 	addi	r5,r5,-14064
81110bfc:	1809883a 	mov	r4,r3
81110c00:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"    Height = %hu \n", pxNFee->xCcdInfo.usiHeight);
81110c04:	d0e06217 	ldw	r3,-32376(gp)
81110c08:	e0bffe17 	ldw	r2,-8(fp)
81110c0c:	1080310b 	ldhu	r2,196(r2)
81110c10:	10bfffcc 	andi	r2,r2,65535
81110c14:	100d883a 	mov	r6,r2
81110c18:	01604574 	movhi	r5,33045
81110c1c:	29724a04 	addi	r5,r5,-14040
81110c20:	1809883a 	mov	r4,r3
81110c24:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"\n");
81110c28:	d0a06217 	ldw	r2,-32376(gp)
81110c2c:	100b883a 	mov	r5,r2
81110c30:	01000284 	movi	r4,10
81110c34:	112101c0 	call	8112101c <fputc>
		fprintf(fp,"NFEE %hhu Control: \n", pxNFee->ucId);
81110c38:	d0e06217 	ldw	r3,-32376(gp)
81110c3c:	e0bffe17 	ldw	r2,-8(fp)
81110c40:	10800003 	ldbu	r2,0(r2)
81110c44:	10803fcc 	andi	r2,r2,255
81110c48:	100d883a 	mov	r6,r2
81110c4c:	01604574 	movhi	r5,33045
81110c50:	29724f04 	addi	r5,r5,-14020
81110c54:	1809883a 	mov	r4,r3
81110c58:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"    NFEE State 	= %hu \n", pxNFee->xControl.eMode);
81110c5c:	d0e06217 	ldw	r3,-32376(gp)
81110c60:	e0bffe17 	ldw	r2,-8(fp)
81110c64:	10802c17 	ldw	r2,176(r2)
81110c68:	100d883a 	mov	r6,r2
81110c6c:	01604574 	movhi	r5,33045
81110c70:	29725504 	addi	r5,r5,-13996
81110c74:	1809883a 	mov	r4,r3
81110c78:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"    NFEE Enable? = %hu \n", pxNFee->xControl.bEnabled);
81110c7c:	d0e06217 	ldw	r3,-32376(gp)
81110c80:	e0bffe17 	ldw	r2,-8(fp)
81110c84:	10802117 	ldw	r2,132(r2)
81110c88:	100d883a 	mov	r6,r2
81110c8c:	01604574 	movhi	r5,33045
81110c90:	29725b04 	addi	r5,r5,-13972
81110c94:	1809883a 	mov	r4,r3
81110c98:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"    Using DMA?   = %hu \n", pxNFee->xControl.bUsingDMA);
81110c9c:	d0e06217 	ldw	r3,-32376(gp)
81110ca0:	e0bffe17 	ldw	r2,-8(fp)
81110ca4:	10802317 	ldw	r2,140(r2)
81110ca8:	100d883a 	mov	r6,r2
81110cac:	01604574 	movhi	r5,33045
81110cb0:	29726204 	addi	r5,r5,-13944
81110cb4:	1809883a 	mov	r4,r3
81110cb8:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"    Logging?     = %hu \n", pxNFee->xControl.bLogging);
81110cbc:	d0e06217 	ldw	r3,-32376(gp)
81110cc0:	e0bffe17 	ldw	r2,-8(fp)
81110cc4:	10802417 	ldw	r2,144(r2)
81110cc8:	100d883a 	mov	r6,r2
81110ccc:	01604574 	movhi	r5,33045
81110cd0:	29726904 	addi	r5,r5,-13916
81110cd4:	1809883a 	mov	r4,r3
81110cd8:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"    Echoing?     = %hu \n", pxNFee->xControl.bEchoing);
81110cdc:	d0e06217 	ldw	r3,-32376(gp)
81110ce0:	e0bffe17 	ldw	r2,-8(fp)
81110ce4:	10802517 	ldw	r2,148(r2)
81110ce8:	100d883a 	mov	r6,r2
81110cec:	01604574 	movhi	r5,33045
81110cf0:	29727004 	addi	r5,r5,-13888
81110cf4:	1809883a 	mov	r4,r3
81110cf8:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"    Channel Enable? = %hu \n", pxNFee->xControl.bChannelEnable);
81110cfc:	d0e06217 	ldw	r3,-32376(gp)
81110d00:	e0bffe17 	ldw	r2,-8(fp)
81110d04:	10802617 	ldw	r2,152(r2)
81110d08:	100d883a 	mov	r6,r2
81110d0c:	01604574 	movhi	r5,33045
81110d10:	29727704 	addi	r5,r5,-13860
81110d14:	1809883a 	mov	r4,r3
81110d18:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"    Readout order = [ %hhu , %hhu , %hhu , %hhu ] \n", pxNFee->xControl.ucROutOrder[0], pxNFee->xControl.ucROutOrder[1], pxNFee->xControl.ucROutOrder[2], pxNFee->xControl.ucROutOrder[3]);
81110d1c:	d1206217 	ldw	r4,-32376(gp)
81110d20:	e0bffe17 	ldw	r2,-8(fp)
81110d24:	10802a43 	ldbu	r2,169(r2)
81110d28:	11403fcc 	andi	r5,r2,255
81110d2c:	e0bffe17 	ldw	r2,-8(fp)
81110d30:	10802a83 	ldbu	r2,170(r2)
81110d34:	11803fcc 	andi	r6,r2,255
81110d38:	e0bffe17 	ldw	r2,-8(fp)
81110d3c:	10802ac3 	ldbu	r2,171(r2)
81110d40:	10803fcc 	andi	r2,r2,255
81110d44:	e0fffe17 	ldw	r3,-8(fp)
81110d48:	18c02b03 	ldbu	r3,172(r3)
81110d4c:	18c03fcc 	andi	r3,r3,255
81110d50:	d8c00115 	stw	r3,4(sp)
81110d54:	d8800015 	stw	r2,0(sp)
81110d58:	300f883a 	mov	r7,r6
81110d5c:	280d883a 	mov	r6,r5
81110d60:	01604574 	movhi	r5,33045
81110d64:	29727e04 	addi	r5,r5,-13832
81110d68:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"    CCD Side = = %hu \n", pxNFee->xControl.eSide);
81110d6c:	d0e06217 	ldw	r3,-32376(gp)
81110d70:	e0bffe17 	ldw	r2,-8(fp)
81110d74:	10802e17 	ldw	r2,184(r2)
81110d78:	100d883a 	mov	r6,r2
81110d7c:	01604574 	movhi	r5,33045
81110d80:	29728b04 	addi	r5,r5,-13780
81110d84:	1809883a 	mov	r4,r3
81110d88:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"\n\n");
81110d8c:	d0a06217 	ldw	r2,-32376(gp)
81110d90:	100f883a 	mov	r7,r2
81110d94:	01800084 	movi	r6,2
81110d98:	01400044 	movi	r5,1
81110d9c:	01204574 	movhi	r4,33045
81110da0:	21329104 	addi	r4,r4,-13756
81110da4:	11216400 	call	81121640 <fwrite>
		fprintf(fp,"NFEE %hhu MEMORY MAP: \n", pxNFee->ucId);
81110da8:	d0e06217 	ldw	r3,-32376(gp)
81110dac:	e0bffe17 	ldw	r2,-8(fp)
81110db0:	10800003 	ldbu	r2,0(r2)
81110db4:	10803fcc 	andi	r2,r2,255
81110db8:	100d883a 	mov	r6,r2
81110dbc:	01604574 	movhi	r5,33045
81110dc0:	29729204 	addi	r5,r5,-13752
81110dc4:	1809883a 	mov	r4,r3
81110dc8:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"    General Info: \n");
81110dcc:	d0a06217 	ldw	r2,-32376(gp)
81110dd0:	100f883a 	mov	r7,r2
81110dd4:	018004c4 	movi	r6,19
81110dd8:	01400044 	movi	r5,1
81110ddc:	01204574 	movhi	r4,33045
81110de0:	21329804 	addi	r4,r4,-13728
81110de4:	11216400 	call	81121640 <fwrite>
		fprintf(fp,"        Offset root 	= %lu \n", pxNFee->xMemMap.ulOffsetRoot);
81110de8:	d0e06217 	ldw	r3,-32376(gp)
81110dec:	e0bffe17 	ldw	r2,-8(fp)
81110df0:	10800117 	ldw	r2,4(r2)
81110df4:	100d883a 	mov	r6,r2
81110df8:	01604574 	movhi	r5,33045
81110dfc:	29729d04 	addi	r5,r5,-13708
81110e00:	1809883a 	mov	r4,r3
81110e04:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"        Total Bytes 	= %lu \n", pxNFee->xMemMap.ulTotalBytes);
81110e08:	d0e06217 	ldw	r3,-32376(gp)
81110e0c:	e0bffe17 	ldw	r2,-8(fp)
81110e10:	10800217 	ldw	r2,8(r2)
81110e14:	100d883a 	mov	r6,r2
81110e18:	01604574 	movhi	r5,33045
81110e1c:	2972a504 	addi	r5,r5,-13676
81110e20:	1809883a 	mov	r4,r3
81110e24:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"        LUT ADDR 	= %lu \n", pxNFee->xMemMap.ulLUTAddr);
81110e28:	d0e06217 	ldw	r3,-32376(gp)
81110e2c:	e0bffe17 	ldw	r2,-8(fp)
81110e30:	10800317 	ldw	r2,12(r2)
81110e34:	100d883a 	mov	r6,r2
81110e38:	01604574 	movhi	r5,33045
81110e3c:	2972ad04 	addi	r5,r5,-13644
81110e40:	1809883a 	mov	r4,r3
81110e44:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"    Common to all CCDs: \n");
81110e48:	d0a06217 	ldw	r2,-32376(gp)
81110e4c:	100f883a 	mov	r7,r2
81110e50:	01800644 	movi	r6,25
81110e54:	01400044 	movi	r5,1
81110e58:	01204574 	movhi	r4,33045
81110e5c:	2132b404 	addi	r4,r4,-13616
81110e60:	11216400 	call	81121640 <fwrite>
		fprintf(fp,"        Total Bytes 	= %hu \n", pxNFee->xMemMap.xCommon.usiTotalBytes);
81110e64:	d0e06217 	ldw	r3,-32376(gp)
81110e68:	e0bffe17 	ldw	r2,-8(fp)
81110e6c:	10800517 	ldw	r2,20(r2)
81110e70:	100d883a 	mov	r6,r2
81110e74:	01604574 	movhi	r5,33045
81110e78:	2972bb04 	addi	r5,r5,-13588
81110e7c:	1809883a 	mov	r4,r3
81110e80:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"        Total of Blocks = %hu \n", pxNFee->xMemMap.xCommon.usiNTotalBlocks);
81110e84:	d0e06217 	ldw	r3,-32376(gp)
81110e88:	e0bffe17 	ldw	r2,-8(fp)
81110e8c:	10800417 	ldw	r2,16(r2)
81110e90:	100d883a 	mov	r6,r2
81110e94:	01604574 	movhi	r5,33045
81110e98:	2972c304 	addi	r5,r5,-13556
81110e9c:	1809883a 	mov	r4,r3
81110ea0:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"        Padding Bytes 	= %hhu\n", pxNFee->xMemMap.xCommon.ucPaddingBytes);
81110ea4:	d0e06217 	ldw	r3,-32376(gp)
81110ea8:	e0bffe17 	ldw	r2,-8(fp)
81110eac:	10800603 	ldbu	r2,24(r2)
81110eb0:	10803fcc 	andi	r2,r2,255
81110eb4:	100d883a 	mov	r6,r2
81110eb8:	01604574 	movhi	r5,33045
81110ebc:	2972cb04 	addi	r5,r5,-13524
81110ec0:	1809883a 	mov	r4,r3
81110ec4:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"        Padding MASK 	= %llu\n", pxNFee->xMemMap.xCommon.ucPaddingMask.ullWord);
81110ec8:	d2206217 	ldw	r8,-32376(gp)
81110ecc:	e13ffe17 	ldw	r4,-8(fp)
81110ed0:	20800717 	ldw	r2,28(r4)
81110ed4:	20c00817 	ldw	r3,32(r4)
81110ed8:	100d883a 	mov	r6,r2
81110edc:	180f883a 	mov	r7,r3
81110ee0:	01604574 	movhi	r5,33045
81110ee4:	2972d304 	addi	r5,r5,-13492
81110ee8:	4009883a 	mov	r4,r8
81110eec:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"\n");
81110ef0:	d0a06217 	ldw	r2,-32376(gp)
81110ef4:	100b883a 	mov	r5,r2
81110ef8:	01000284 	movi	r4,10
81110efc:	112101c0 	call	8112101c <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 0 , pxNFee->ucId);
81110f00:	d0e06217 	ldw	r3,-32376(gp)
81110f04:	e0bffe17 	ldw	r2,-8(fp)
81110f08:	10800003 	ldbu	r2,0(r2)
81110f0c:	10803fcc 	andi	r2,r2,255
81110f10:	100f883a 	mov	r7,r2
81110f14:	000d883a 	mov	r6,zero
81110f18:	01604574 	movhi	r5,33045
81110f1c:	2972db04 	addi	r5,r5,-13460
81110f20:	1809883a 	mov	r4,r3
81110f24:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"        Left side \n");
81110f28:	d0a06217 	ldw	r2,-32376(gp)
81110f2c:	100f883a 	mov	r7,r2
81110f30:	018004c4 	movi	r6,19
81110f34:	01400044 	movi	r5,1
81110f38:	01204574 	movhi	r4,33045
81110f3c:	2132e504 	addi	r4,r4,-13420
81110f40:	11216400 	call	81121640 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulOffsetAddr);
81110f44:	d0e06217 	ldw	r3,-32376(gp)
81110f48:	e0bffe17 	ldw	r2,-8(fp)
81110f4c:	10800917 	ldw	r2,36(r2)
81110f50:	100d883a 	mov	r6,r2
81110f54:	01604574 	movhi	r5,33045
81110f58:	2972ea04 	addi	r5,r5,-13400
81110f5c:	1809883a 	mov	r4,r3
81110f60:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulBlockI);
81110f64:	d0e06217 	ldw	r3,-32376(gp)
81110f68:	e0bffe17 	ldw	r2,-8(fp)
81110f6c:	10800a17 	ldw	r2,40(r2)
81110f70:	100d883a 	mov	r6,r2
81110f74:	01604574 	movhi	r5,33045
81110f78:	2972f304 	addi	r5,r5,-13364
81110f7c:	1809883a 	mov	r4,r3
81110f80:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulAddrI);
81110f84:	d0e06217 	ldw	r3,-32376(gp)
81110f88:	e0bffe17 	ldw	r2,-8(fp)
81110f8c:	10800b17 	ldw	r2,44(r2)
81110f90:	100d883a 	mov	r6,r2
81110f94:	01604574 	movhi	r5,33045
81110f98:	2972fe04 	addi	r5,r5,-13320
81110f9c:	1809883a 	mov	r4,r3
81110fa0:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"        Right side \n");
81110fa4:	d0a06217 	ldw	r2,-32376(gp)
81110fa8:	100f883a 	mov	r7,r2
81110fac:	01800504 	movi	r6,20
81110fb0:	01400044 	movi	r5,1
81110fb4:	01204574 	movhi	r4,33045
81110fb8:	21330a04 	addi	r4,r4,-13272
81110fbc:	11216400 	call	81121640 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulOffsetAddr);
81110fc0:	d0e06217 	ldw	r3,-32376(gp)
81110fc4:	e0bffe17 	ldw	r2,-8(fp)
81110fc8:	10800c17 	ldw	r2,48(r2)
81110fcc:	100d883a 	mov	r6,r2
81110fd0:	01604574 	movhi	r5,33045
81110fd4:	2972ea04 	addi	r5,r5,-13400
81110fd8:	1809883a 	mov	r4,r3
81110fdc:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulBlockI);
81110fe0:	d0e06217 	ldw	r3,-32376(gp)
81110fe4:	e0bffe17 	ldw	r2,-8(fp)
81110fe8:	10800d17 	ldw	r2,52(r2)
81110fec:	100d883a 	mov	r6,r2
81110ff0:	01604574 	movhi	r5,33045
81110ff4:	2972f304 	addi	r5,r5,-13364
81110ff8:	1809883a 	mov	r4,r3
81110ffc:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulAddrI);
81111000:	d0e06217 	ldw	r3,-32376(gp)
81111004:	e0bffe17 	ldw	r2,-8(fp)
81111008:	10800e17 	ldw	r2,56(r2)
8111100c:	100d883a 	mov	r6,r2
81111010:	01604574 	movhi	r5,33045
81111014:	2972fe04 	addi	r5,r5,-13320
81111018:	1809883a 	mov	r4,r3
8111101c:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"\n");
81111020:	d0a06217 	ldw	r2,-32376(gp)
81111024:	100b883a 	mov	r5,r2
81111028:	01000284 	movi	r4,10
8111102c:	112101c0 	call	8112101c <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 1 , pxNFee->ucId);
81111030:	d0e06217 	ldw	r3,-32376(gp)
81111034:	e0bffe17 	ldw	r2,-8(fp)
81111038:	10800003 	ldbu	r2,0(r2)
8111103c:	10803fcc 	andi	r2,r2,255
81111040:	100f883a 	mov	r7,r2
81111044:	01800044 	movi	r6,1
81111048:	01604574 	movhi	r5,33045
8111104c:	2972db04 	addi	r5,r5,-13460
81111050:	1809883a 	mov	r4,r3
81111054:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"        Left side \n");
81111058:	d0a06217 	ldw	r2,-32376(gp)
8111105c:	100f883a 	mov	r7,r2
81111060:	018004c4 	movi	r6,19
81111064:	01400044 	movi	r5,1
81111068:	01204574 	movhi	r4,33045
8111106c:	2132e504 	addi	r4,r4,-13420
81111070:	11216400 	call	81121640 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulOffsetAddr);
81111074:	d0e06217 	ldw	r3,-32376(gp)
81111078:	e0bffe17 	ldw	r2,-8(fp)
8111107c:	10800f17 	ldw	r2,60(r2)
81111080:	100d883a 	mov	r6,r2
81111084:	01604574 	movhi	r5,33045
81111088:	2972ea04 	addi	r5,r5,-13400
8111108c:	1809883a 	mov	r4,r3
81111090:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulBlockI);
81111094:	d0e06217 	ldw	r3,-32376(gp)
81111098:	e0bffe17 	ldw	r2,-8(fp)
8111109c:	10801017 	ldw	r2,64(r2)
811110a0:	100d883a 	mov	r6,r2
811110a4:	01604574 	movhi	r5,33045
811110a8:	2972f304 	addi	r5,r5,-13364
811110ac:	1809883a 	mov	r4,r3
811110b0:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulAddrI);
811110b4:	d0e06217 	ldw	r3,-32376(gp)
811110b8:	e0bffe17 	ldw	r2,-8(fp)
811110bc:	10801117 	ldw	r2,68(r2)
811110c0:	100d883a 	mov	r6,r2
811110c4:	01604574 	movhi	r5,33045
811110c8:	2972fe04 	addi	r5,r5,-13320
811110cc:	1809883a 	mov	r4,r3
811110d0:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"        Right side \n");
811110d4:	d0a06217 	ldw	r2,-32376(gp)
811110d8:	100f883a 	mov	r7,r2
811110dc:	01800504 	movi	r6,20
811110e0:	01400044 	movi	r5,1
811110e4:	01204574 	movhi	r4,33045
811110e8:	21330a04 	addi	r4,r4,-13272
811110ec:	11216400 	call	81121640 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulOffsetAddr);
811110f0:	d0e06217 	ldw	r3,-32376(gp)
811110f4:	e0bffe17 	ldw	r2,-8(fp)
811110f8:	10801217 	ldw	r2,72(r2)
811110fc:	100d883a 	mov	r6,r2
81111100:	01604574 	movhi	r5,33045
81111104:	2972ea04 	addi	r5,r5,-13400
81111108:	1809883a 	mov	r4,r3
8111110c:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulBlockI);
81111110:	d0e06217 	ldw	r3,-32376(gp)
81111114:	e0bffe17 	ldw	r2,-8(fp)
81111118:	10801317 	ldw	r2,76(r2)
8111111c:	100d883a 	mov	r6,r2
81111120:	01604574 	movhi	r5,33045
81111124:	2972f304 	addi	r5,r5,-13364
81111128:	1809883a 	mov	r4,r3
8111112c:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulAddrI);
81111130:	d0e06217 	ldw	r3,-32376(gp)
81111134:	e0bffe17 	ldw	r2,-8(fp)
81111138:	10801417 	ldw	r2,80(r2)
8111113c:	100d883a 	mov	r6,r2
81111140:	01604574 	movhi	r5,33045
81111144:	2972fe04 	addi	r5,r5,-13320
81111148:	1809883a 	mov	r4,r3
8111114c:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"\n");
81111150:	d0a06217 	ldw	r2,-32376(gp)
81111154:	100b883a 	mov	r5,r2
81111158:	01000284 	movi	r4,10
8111115c:	112101c0 	call	8112101c <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 2 , pxNFee->ucId);
81111160:	d0e06217 	ldw	r3,-32376(gp)
81111164:	e0bffe17 	ldw	r2,-8(fp)
81111168:	10800003 	ldbu	r2,0(r2)
8111116c:	10803fcc 	andi	r2,r2,255
81111170:	100f883a 	mov	r7,r2
81111174:	01800084 	movi	r6,2
81111178:	01604574 	movhi	r5,33045
8111117c:	2972db04 	addi	r5,r5,-13460
81111180:	1809883a 	mov	r4,r3
81111184:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"        Left side \n");
81111188:	d0a06217 	ldw	r2,-32376(gp)
8111118c:	100f883a 	mov	r7,r2
81111190:	018004c4 	movi	r6,19
81111194:	01400044 	movi	r5,1
81111198:	01204574 	movhi	r4,33045
8111119c:	2132e504 	addi	r4,r4,-13420
811111a0:	11216400 	call	81121640 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulOffsetAddr);
811111a4:	d0e06217 	ldw	r3,-32376(gp)
811111a8:	e0bffe17 	ldw	r2,-8(fp)
811111ac:	10801517 	ldw	r2,84(r2)
811111b0:	100d883a 	mov	r6,r2
811111b4:	01604574 	movhi	r5,33045
811111b8:	2972ea04 	addi	r5,r5,-13400
811111bc:	1809883a 	mov	r4,r3
811111c0:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulBlockI);
811111c4:	d0e06217 	ldw	r3,-32376(gp)
811111c8:	e0bffe17 	ldw	r2,-8(fp)
811111cc:	10801617 	ldw	r2,88(r2)
811111d0:	100d883a 	mov	r6,r2
811111d4:	01604574 	movhi	r5,33045
811111d8:	2972f304 	addi	r5,r5,-13364
811111dc:	1809883a 	mov	r4,r3
811111e0:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulAddrI);
811111e4:	d0e06217 	ldw	r3,-32376(gp)
811111e8:	e0bffe17 	ldw	r2,-8(fp)
811111ec:	10801717 	ldw	r2,92(r2)
811111f0:	100d883a 	mov	r6,r2
811111f4:	01604574 	movhi	r5,33045
811111f8:	2972fe04 	addi	r5,r5,-13320
811111fc:	1809883a 	mov	r4,r3
81111200:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"        Right side \n");
81111204:	d0a06217 	ldw	r2,-32376(gp)
81111208:	100f883a 	mov	r7,r2
8111120c:	01800504 	movi	r6,20
81111210:	01400044 	movi	r5,1
81111214:	01204574 	movhi	r4,33045
81111218:	21330a04 	addi	r4,r4,-13272
8111121c:	11216400 	call	81121640 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulOffsetAddr);
81111220:	d0e06217 	ldw	r3,-32376(gp)
81111224:	e0bffe17 	ldw	r2,-8(fp)
81111228:	10801817 	ldw	r2,96(r2)
8111122c:	100d883a 	mov	r6,r2
81111230:	01604574 	movhi	r5,33045
81111234:	2972ea04 	addi	r5,r5,-13400
81111238:	1809883a 	mov	r4,r3
8111123c:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulBlockI);
81111240:	d0e06217 	ldw	r3,-32376(gp)
81111244:	e0bffe17 	ldw	r2,-8(fp)
81111248:	10801917 	ldw	r2,100(r2)
8111124c:	100d883a 	mov	r6,r2
81111250:	01604574 	movhi	r5,33045
81111254:	2972f304 	addi	r5,r5,-13364
81111258:	1809883a 	mov	r4,r3
8111125c:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulAddrI);
81111260:	d0e06217 	ldw	r3,-32376(gp)
81111264:	e0bffe17 	ldw	r2,-8(fp)
81111268:	10801a17 	ldw	r2,104(r2)
8111126c:	100d883a 	mov	r6,r2
81111270:	01604574 	movhi	r5,33045
81111274:	2972fe04 	addi	r5,r5,-13320
81111278:	1809883a 	mov	r4,r3
8111127c:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"\n");
81111280:	d0a06217 	ldw	r2,-32376(gp)
81111284:	100b883a 	mov	r5,r2
81111288:	01000284 	movi	r4,10
8111128c:	112101c0 	call	8112101c <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 3 , pxNFee->ucId);
81111290:	d0e06217 	ldw	r3,-32376(gp)
81111294:	e0bffe17 	ldw	r2,-8(fp)
81111298:	10800003 	ldbu	r2,0(r2)
8111129c:	10803fcc 	andi	r2,r2,255
811112a0:	100f883a 	mov	r7,r2
811112a4:	018000c4 	movi	r6,3
811112a8:	01604574 	movhi	r5,33045
811112ac:	2972db04 	addi	r5,r5,-13460
811112b0:	1809883a 	mov	r4,r3
811112b4:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"        Left side \n");
811112b8:	d0a06217 	ldw	r2,-32376(gp)
811112bc:	100f883a 	mov	r7,r2
811112c0:	018004c4 	movi	r6,19
811112c4:	01400044 	movi	r5,1
811112c8:	01204574 	movhi	r4,33045
811112cc:	2132e504 	addi	r4,r4,-13420
811112d0:	11216400 	call	81121640 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulOffsetAddr);
811112d4:	d0e06217 	ldw	r3,-32376(gp)
811112d8:	e0bffe17 	ldw	r2,-8(fp)
811112dc:	10801b17 	ldw	r2,108(r2)
811112e0:	100d883a 	mov	r6,r2
811112e4:	01604574 	movhi	r5,33045
811112e8:	2972ea04 	addi	r5,r5,-13400
811112ec:	1809883a 	mov	r4,r3
811112f0:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulBlockI);
811112f4:	d0e06217 	ldw	r3,-32376(gp)
811112f8:	e0bffe17 	ldw	r2,-8(fp)
811112fc:	10801c17 	ldw	r2,112(r2)
81111300:	100d883a 	mov	r6,r2
81111304:	01604574 	movhi	r5,33045
81111308:	2972f304 	addi	r5,r5,-13364
8111130c:	1809883a 	mov	r4,r3
81111310:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulAddrI);
81111314:	d0e06217 	ldw	r3,-32376(gp)
81111318:	e0bffe17 	ldw	r2,-8(fp)
8111131c:	10801d17 	ldw	r2,116(r2)
81111320:	100d883a 	mov	r6,r2
81111324:	01604574 	movhi	r5,33045
81111328:	2972fe04 	addi	r5,r5,-13320
8111132c:	1809883a 	mov	r4,r3
81111330:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"        Right side \n");
81111334:	d0a06217 	ldw	r2,-32376(gp)
81111338:	100f883a 	mov	r7,r2
8111133c:	01800504 	movi	r6,20
81111340:	01400044 	movi	r5,1
81111344:	01204574 	movhi	r4,33045
81111348:	21330a04 	addi	r4,r4,-13272
8111134c:	11216400 	call	81121640 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulOffsetAddr);
81111350:	d0e06217 	ldw	r3,-32376(gp)
81111354:	e0bffe17 	ldw	r2,-8(fp)
81111358:	10801e17 	ldw	r2,120(r2)
8111135c:	100d883a 	mov	r6,r2
81111360:	01604574 	movhi	r5,33045
81111364:	2972ea04 	addi	r5,r5,-13400
81111368:	1809883a 	mov	r4,r3
8111136c:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulBlockI);
81111370:	d0e06217 	ldw	r3,-32376(gp)
81111374:	e0bffe17 	ldw	r2,-8(fp)
81111378:	10801f17 	ldw	r2,124(r2)
8111137c:	100d883a 	mov	r6,r2
81111380:	01604574 	movhi	r5,33045
81111384:	2972f304 	addi	r5,r5,-13364
81111388:	1809883a 	mov	r4,r3
8111138c:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulAddrI);
81111390:	d0e06217 	ldw	r3,-32376(gp)
81111394:	e0bffe17 	ldw	r2,-8(fp)
81111398:	10802017 	ldw	r2,128(r2)
8111139c:	100d883a 	mov	r6,r2
811113a0:	01604574 	movhi	r5,33045
811113a4:	2972fe04 	addi	r5,r5,-13320
811113a8:	1809883a 	mov	r4,r3
811113ac:	1120fa40 	call	81120fa4 <fprintf>
		fprintf(fp,"\n");
811113b0:	d0a06217 	ldw	r2,-32376(gp)
811113b4:	100b883a 	mov	r5,r2
811113b8:	01000284 	movi	r4,10
811113bc:	112101c0 	call	8112101c <fputc>
		fprintf(fp,"==============================================================================\n");
811113c0:	d0a06217 	ldw	r2,-32376(gp)
811113c4:	100f883a 	mov	r7,r2
811113c8:	018013c4 	movi	r6,79
811113cc:	01400044 	movi	r5,1
811113d0:	01204574 	movhi	r4,33045
811113d4:	21331004 	addi	r4,r4,-13248
811113d8:	11216400 	call	81121640 <fwrite>
		fprintf(fp,"==============================================================================\n");
811113dc:	d0a06217 	ldw	r2,-32376(gp)
811113e0:	100f883a 	mov	r7,r2
811113e4:	018013c4 	movi	r6,79
811113e8:	01400044 	movi	r5,1
811113ec:	01204574 	movhi	r4,33045
811113f0:	21331004 	addi	r4,r4,-13248
811113f4:	11216400 	call	81121640 <fwrite>
		fprintf(fp,"\n");
811113f8:	d0a06217 	ldw	r2,-32376(gp)
811113fc:	100b883a 	mov	r5,r2
81111400:	01000284 	movi	r4,10
81111404:	112101c0 	call	8112101c <fputc>
		fprintf(fp,"\n");
81111408:	d0a06217 	ldw	r2,-32376(gp)
8111140c:	100b883a 	mov	r5,r2
81111410:	01000284 	movi	r4,10
81111414:	112101c0 	call	8112101c <fputc>
		fprintf(fp,"\n");
81111418:	d0a06217 	ldw	r2,-32376(gp)
8111141c:	100b883a 	mov	r5,r2
81111420:	01000284 	movi	r4,10
81111424:	112101c0 	call	8112101c <fputc>
		fprintf(fp,"\n");
81111428:	d0a06217 	ldw	r2,-32376(gp)
8111142c:	100b883a 	mov	r5,r2
81111430:	01000284 	movi	r4,10
81111434:	112101c0 	call	8112101c <fputc>
		fprintf(fp,"\n");
81111438:	d0a06217 	ldw	r2,-32376(gp)
8111143c:	100b883a 	mov	r5,r2
81111440:	01000284 	movi	r4,10
81111444:	112101c0 	call	8112101c <fputc>
	}
81111448:	0001883a 	nop
8111144c:	e037883a 	mov	sp,fp
81111450:	dfc00117 	ldw	ra,4(sp)
81111454:	df000017 	ldw	fp,0(sp)
81111458:	dec00204 	addi	sp,sp,8
8111145c:	f800283a 	ret

81111460 <bPrepareDoubleBuffer>:

*/



bool bPrepareDoubleBuffer( TCcdMemMap *xCcdMapLocal, unsigned char ucMem, unsigned char ucID  ) {
81111460:	defffa04 	addi	sp,sp,-24
81111464:	de00012e 	bgeu	sp,et,8111146c <bPrepareDoubleBuffer+0xc>
81111468:	003b68fa 	trap	3
8111146c:	dfc00515 	stw	ra,20(sp)
81111470:	df000415 	stw	fp,16(sp)
81111474:	df000404 	addi	fp,sp,16
81111478:	e13ffd15 	stw	r4,-12(fp)
8111147c:	2807883a 	mov	r3,r5
81111480:	3005883a 	mov	r2,r6
81111484:	e0fffe05 	stb	r3,-8(fp)
81111488:	e0bfff05 	stb	r2,-4(fp)
	bool  bDmaReturn;

	bDmaReturn = FALSE;
8111148c:	e03ffc15 	stw	zero,-16(fp)


	}
	*/

	if (  ucMem == 0  ) {
81111490:	e0bffe03 	ldbu	r2,-8(fp)
81111494:	1000371e 	bne	r2,zero,81111574 <bPrepareDoubleBuffer+0x114>
		/* Initializing the addr */
		xCcdMapLocal->ulBlockI = 0;
81111498:	e0bffd17 	ldw	r2,-12(fp)
8111149c:	10000115 	stw	zero,4(r2)
		xCcdMapLocal->ulAddrI = xCcdMapLocal->ulOffsetAddr;
811114a0:	e0bffd17 	ldw	r2,-12(fp)
811114a4:	10c00017 	ldw	r3,0(r2)
811114a8:	e0bffd17 	ldw	r2,-12(fp)
811114ac:	10c00215 	stw	r3,8(r2)

		bDmaReturn = bSdmaDmaM1Transfer(xCcdMapLocal->ulAddrI, SDMA_MAX_BLOCKS, ucIterationSide, ucID);
811114b0:	e0bffd17 	ldw	r2,-12(fp)
811114b4:	10800217 	ldw	r2,8(r2)
811114b8:	1009883a 	mov	r4,r2
811114bc:	d0a05603 	ldbu	r2,-32424(gp)
811114c0:	10803fcc 	andi	r2,r2,255
811114c4:	e0ffff03 	ldbu	r3,-4(fp)
811114c8:	180f883a 	mov	r7,r3
811114cc:	100d883a 	mov	r6,r2
811114d0:	01400404 	movi	r5,16
811114d4:	1103c900 	call	81103c90 <bSdmaDmaM1Transfer>
811114d8:	e0bffc15 	stw	r2,-16(fp)
		if ( bDmaReturn == TRUE ) {
811114dc:	e0bffc17 	ldw	r2,-16(fp)
811114e0:	10800058 	cmpnei	r2,r2,1
811114e4:	1000591e 	bne	r2,zero,8111164c <bPrepareDoubleBuffer+0x1ec>
			//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
			xCcdMapLocal->ulAddrI += SDMA_BUFFER_SIZE_BYTES;
811114e8:	e0bffd17 	ldw	r2,-12(fp)
811114ec:	10800217 	ldw	r2,8(r2)
811114f0:	10c22004 	addi	r3,r2,2176
811114f4:	e0bffd17 	ldw	r2,-12(fp)
811114f8:	10c00215 	stw	r3,8(r2)
			xCcdMapLocal->ulBlockI += SDMA_MAX_BLOCKS;
811114fc:	e0bffd17 	ldw	r2,-12(fp)
81111500:	10800117 	ldw	r2,4(r2)
81111504:	10c00404 	addi	r3,r2,16
81111508:	e0bffd17 	ldw	r2,-12(fp)
8111150c:	10c00115 	stw	r3,4(r2)
			bDmaReturn = bSdmaDmaM1Transfer(xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, ucIterationSide, ucID);
81111510:	e0bffd17 	ldw	r2,-12(fp)
81111514:	10800217 	ldw	r2,8(r2)
81111518:	1009883a 	mov	r4,r2
8111151c:	d0a05603 	ldbu	r2,-32424(gp)
81111520:	10803fcc 	andi	r2,r2,255
81111524:	e0ffff03 	ldbu	r3,-4(fp)
81111528:	180f883a 	mov	r7,r3
8111152c:	100d883a 	mov	r6,r2
81111530:	01400404 	movi	r5,16
81111534:	1103c900 	call	81103c90 <bSdmaDmaM1Transfer>
81111538:	e0bffc15 	stw	r2,-16(fp)
			if ( bDmaReturn == TRUE ) {
8111153c:	e0bffc17 	ldw	r2,-16(fp)
81111540:	10800058 	cmpnei	r2,r2,1
81111544:	1000411e 	bne	r2,zero,8111164c <bPrepareDoubleBuffer+0x1ec>
				//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
				xCcdMapLocal->ulAddrI += SDMA_BUFFER_SIZE_BYTES;
81111548:	e0bffd17 	ldw	r2,-12(fp)
8111154c:	10800217 	ldw	r2,8(r2)
81111550:	10c22004 	addi	r3,r2,2176
81111554:	e0bffd17 	ldw	r2,-12(fp)
81111558:	10c00215 	stw	r3,8(r2)
				xCcdMapLocal->ulBlockI += SDMA_MAX_BLOCKS;
8111155c:	e0bffd17 	ldw	r2,-12(fp)
81111560:	10800117 	ldw	r2,4(r2)
81111564:	10c00404 	addi	r3,r2,16
81111568:	e0bffd17 	ldw	r2,-12(fp)
8111156c:	10c00115 	stw	r3,4(r2)
81111570:	00003606 	br	8111164c <bPrepareDoubleBuffer+0x1ec>
			}
		}
	} else {
		xCcdMapLocal->ulBlockI = 0;
81111574:	e0bffd17 	ldw	r2,-12(fp)
81111578:	10000115 	stw	zero,4(r2)
		xCcdMapLocal->ulAddrI = xCcdMapLocal->ulOffsetAddr;
8111157c:	e0bffd17 	ldw	r2,-12(fp)
81111580:	10c00017 	ldw	r3,0(r2)
81111584:	e0bffd17 	ldw	r2,-12(fp)
81111588:	10c00215 	stw	r3,8(r2)
		bDmaReturn = bSdmaDmaM2Transfer(xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, ucIterationSide, ucID);
8111158c:	e0bffd17 	ldw	r2,-12(fp)
81111590:	10800217 	ldw	r2,8(r2)
81111594:	1009883a 	mov	r4,r2
81111598:	d0a05603 	ldbu	r2,-32424(gp)
8111159c:	10803fcc 	andi	r2,r2,255
811115a0:	e0ffff03 	ldbu	r3,-4(fp)
811115a4:	180f883a 	mov	r7,r3
811115a8:	100d883a 	mov	r6,r2
811115ac:	01400404 	movi	r5,16
811115b0:	11040ec0 	call	811040ec <bSdmaDmaM2Transfer>
811115b4:	e0bffc15 	stw	r2,-16(fp)
		if ( bDmaReturn == TRUE ) {
811115b8:	e0bffc17 	ldw	r2,-16(fp)
811115bc:	10800058 	cmpnei	r2,r2,1
811115c0:	1000221e 	bne	r2,zero,8111164c <bPrepareDoubleBuffer+0x1ec>
			//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
			xCcdMapLocal->ulAddrI += SDMA_BUFFER_SIZE_BYTES;
811115c4:	e0bffd17 	ldw	r2,-12(fp)
811115c8:	10800217 	ldw	r2,8(r2)
811115cc:	10c22004 	addi	r3,r2,2176
811115d0:	e0bffd17 	ldw	r2,-12(fp)
811115d4:	10c00215 	stw	r3,8(r2)
			xCcdMapLocal->ulBlockI += SDMA_MAX_BLOCKS;
811115d8:	e0bffd17 	ldw	r2,-12(fp)
811115dc:	10800117 	ldw	r2,4(r2)
811115e0:	10c00404 	addi	r3,r2,16
811115e4:	e0bffd17 	ldw	r2,-12(fp)
811115e8:	10c00115 	stw	r3,4(r2)
			bDmaReturn = bSdmaDmaM2Transfer(xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, ucIterationSide, ucID);
811115ec:	e0bffd17 	ldw	r2,-12(fp)
811115f0:	10800217 	ldw	r2,8(r2)
811115f4:	1009883a 	mov	r4,r2
811115f8:	d0a05603 	ldbu	r2,-32424(gp)
811115fc:	10803fcc 	andi	r2,r2,255
81111600:	e0ffff03 	ldbu	r3,-4(fp)
81111604:	180f883a 	mov	r7,r3
81111608:	100d883a 	mov	r6,r2
8111160c:	01400404 	movi	r5,16
81111610:	11040ec0 	call	811040ec <bSdmaDmaM2Transfer>
81111614:	e0bffc15 	stw	r2,-16(fp)
			if ( bDmaReturn == TRUE ) {
81111618:	e0bffc17 	ldw	r2,-16(fp)
8111161c:	10800058 	cmpnei	r2,r2,1
81111620:	10000a1e 	bne	r2,zero,8111164c <bPrepareDoubleBuffer+0x1ec>
				//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
				xCcdMapLocal->ulAddrI += SDMA_BUFFER_SIZE_BYTES;
81111624:	e0bffd17 	ldw	r2,-12(fp)
81111628:	10800217 	ldw	r2,8(r2)
8111162c:	10c22004 	addi	r3,r2,2176
81111630:	e0bffd17 	ldw	r2,-12(fp)
81111634:	10c00215 	stw	r3,8(r2)
				xCcdMapLocal->ulBlockI += SDMA_MAX_BLOCKS;
81111638:	e0bffd17 	ldw	r2,-12(fp)
8111163c:	10800117 	ldw	r2,4(r2)
81111640:	10c00404 	addi	r3,r2,16
81111644:	e0bffd17 	ldw	r2,-12(fp)
81111648:	10c00115 	stw	r3,4(r2)

			}
		}
	}

	return bDmaReturn;
8111164c:	e0bffc17 	ldw	r2,-16(fp)

}
81111650:	e037883a 	mov	sp,fp
81111654:	dfc00117 	ldw	ra,4(sp)
81111658:	df000017 	ldw	fp,0(sp)
8111165c:	dec00204 	addi	sp,sp,8
81111660:	f800283a 	ret

81111664 <vLoadCtemp>:


void vLoadCtemp(void) {
81111664:	deffff04 	addi	sp,sp,-4
81111668:	de00012e 	bgeu	sp,et,81111670 <vLoadCtemp+0xc>
8111166c:	003b68fa 	trap	3
81111670:	df000015 	stw	fp,0(sp)
81111674:	d839883a 	mov	fp,sp
	cTemp[0]="usiHkCcd1VodE";
81111678:	00a04574 	movhi	r2,33045
8111167c:	108d6b04 	addi	r2,r2,13740
81111680:	00e04574 	movhi	r3,33045
81111684:	18f32404 	addi	r3,r3,-13168
81111688:	10c00015 	stw	r3,0(r2)
	cTemp[1]="usiHkCcd1VodF";
8111168c:	00a04574 	movhi	r2,33045
81111690:	108d6b04 	addi	r2,r2,13740
81111694:	00e04574 	movhi	r3,33045
81111698:	18f32804 	addi	r3,r3,-13152
8111169c:	10c00115 	stw	r3,4(r2)
	cTemp[2]="usiHkCcd1VrdMon";
811116a0:	00a04574 	movhi	r2,33045
811116a4:	108d6b04 	addi	r2,r2,13740
811116a8:	00e04574 	movhi	r3,33045
811116ac:	18f32c04 	addi	r3,r3,-13136
811116b0:	10c00215 	stw	r3,8(r2)
	cTemp[3]="usiHkCcd2VodE";
811116b4:	00a04574 	movhi	r2,33045
811116b8:	108d6b04 	addi	r2,r2,13740
811116bc:	00e04574 	movhi	r3,33045
811116c0:	18f33004 	addi	r3,r3,-13120
811116c4:	10c00315 	stw	r3,12(r2)
	cTemp[4]="usiHkCcd2VodF";
811116c8:	00a04574 	movhi	r2,33045
811116cc:	108d6b04 	addi	r2,r2,13740
811116d0:	00e04574 	movhi	r3,33045
811116d4:	18f33404 	addi	r3,r3,-13104
811116d8:	10c00415 	stw	r3,16(r2)
	cTemp[5]="usiHkCcd2VrdMon";
811116dc:	00a04574 	movhi	r2,33045
811116e0:	108d6b04 	addi	r2,r2,13740
811116e4:	00e04574 	movhi	r3,33045
811116e8:	18f33804 	addi	r3,r3,-13088
811116ec:	10c00515 	stw	r3,20(r2)
	cTemp[6]="usiHkCcd3VodE";
811116f0:	00a04574 	movhi	r2,33045
811116f4:	108d6b04 	addi	r2,r2,13740
811116f8:	00e04574 	movhi	r3,33045
811116fc:	18f33c04 	addi	r3,r3,-13072
81111700:	10c00615 	stw	r3,24(r2)
	cTemp[7]="usiHkCcd3VodF";
81111704:	00a04574 	movhi	r2,33045
81111708:	108d6b04 	addi	r2,r2,13740
8111170c:	00e04574 	movhi	r3,33045
81111710:	18f34004 	addi	r3,r3,-13056
81111714:	10c00715 	stw	r3,28(r2)
	cTemp[8]="usiHkCcd3VrdMon";
81111718:	00a04574 	movhi	r2,33045
8111171c:	108d6b04 	addi	r2,r2,13740
81111720:	00e04574 	movhi	r3,33045
81111724:	18f34404 	addi	r3,r3,-13040
81111728:	10c00815 	stw	r3,32(r2)
	cTemp[9]="usiHkCcd4VodE";
8111172c:	00a04574 	movhi	r2,33045
81111730:	108d6b04 	addi	r2,r2,13740
81111734:	00e04574 	movhi	r3,33045
81111738:	18f34804 	addi	r3,r3,-13024
8111173c:	10c00915 	stw	r3,36(r2)
	cTemp[10]="usiHkCcd4VodF";
81111740:	00a04574 	movhi	r2,33045
81111744:	108d6b04 	addi	r2,r2,13740
81111748:	00e04574 	movhi	r3,33045
8111174c:	18f34c04 	addi	r3,r3,-13008
81111750:	10c00a15 	stw	r3,40(r2)
	cTemp[11]="usiHkCcd4VrdMon";
81111754:	00a04574 	movhi	r2,33045
81111758:	108d6b04 	addi	r2,r2,13740
8111175c:	00e04574 	movhi	r3,33045
81111760:	18f35004 	addi	r3,r3,-12992
81111764:	10c00b15 	stw	r3,44(r2)
	cTemp[12]="usiHkVccd";
81111768:	00a04574 	movhi	r2,33045
8111176c:	108d6b04 	addi	r2,r2,13740
81111770:	00e04574 	movhi	r3,33045
81111774:	18f35404 	addi	r3,r3,-12976
81111778:	10c00c15 	stw	r3,48(r2)
	cTemp[13]="usiHkVrclk";
8111177c:	00a04574 	movhi	r2,33045
81111780:	108d6b04 	addi	r2,r2,13740
81111784:	00e04574 	movhi	r3,33045
81111788:	18f35704 	addi	r3,r3,-12964
8111178c:	10c00d15 	stw	r3,52(r2)
	cTemp[14]="usiHkViclk";
81111790:	00a04574 	movhi	r2,33045
81111794:	108d6b04 	addi	r2,r2,13740
81111798:	00e04574 	movhi	r3,33045
8111179c:	18f35a04 	addi	r3,r3,-12952
811117a0:	10c00e15 	stw	r3,56(r2)
	cTemp[15]="usiHkVrclkLow";
811117a4:	00a04574 	movhi	r2,33045
811117a8:	108d6b04 	addi	r2,r2,13740
811117ac:	00e04574 	movhi	r3,33045
811117b0:	18f35d04 	addi	r3,r3,-12940
811117b4:	10c00f15 	stw	r3,60(r2)
	cTemp[16]="usiHk5vbPos";
811117b8:	00a04574 	movhi	r2,33045
811117bc:	108d6b04 	addi	r2,r2,13740
811117c0:	00e04574 	movhi	r3,33045
811117c4:	18f36104 	addi	r3,r3,-12924
811117c8:	10c01015 	stw	r3,64(r2)
	cTemp[17]="usiHk5vbNeg";
811117cc:	00a04574 	movhi	r2,33045
811117d0:	108d6b04 	addi	r2,r2,13740
811117d4:	00e04574 	movhi	r3,33045
811117d8:	18f36404 	addi	r3,r3,-12912
811117dc:	10c01115 	stw	r3,68(r2)
	cTemp[18]="usiHk33vbPos";
811117e0:	00a04574 	movhi	r2,33045
811117e4:	108d6b04 	addi	r2,r2,13740
811117e8:	00e04574 	movhi	r3,33045
811117ec:	18f36704 	addi	r3,r3,-12900
811117f0:	10c01215 	stw	r3,72(r2)
	cTemp[19]="usiHk25vaPos";
811117f4:	00a04574 	movhi	r2,33045
811117f8:	108d6b04 	addi	r2,r2,13740
811117fc:	00e04574 	movhi	r3,33045
81111800:	18f36b04 	addi	r3,r3,-12884
81111804:	10c01315 	stw	r3,76(r2)
	cTemp[20]="usiHk33vdPos";
81111808:	00a04574 	movhi	r2,33045
8111180c:	108d6b04 	addi	r2,r2,13740
81111810:	00e04574 	movhi	r3,33045
81111814:	18f36f04 	addi	r3,r3,-12868
81111818:	10c01415 	stw	r3,80(r2)
	cTemp[21]="usiHk25vdPos";
8111181c:	00a04574 	movhi	r2,33045
81111820:	108d6b04 	addi	r2,r2,13740
81111824:	00e04574 	movhi	r3,33045
81111828:	18f37304 	addi	r3,r3,-12852
8111182c:	10c01515 	stw	r3,84(r2)
	cTemp[22]="usiHk15vdPos";
81111830:	00a04574 	movhi	r2,33045
81111834:	108d6b04 	addi	r2,r2,13740
81111838:	00e04574 	movhi	r3,33045
8111183c:	18f37704 	addi	r3,r3,-12836
81111840:	10c01615 	stw	r3,88(r2)
	cTemp[23]="usiHk5vref";
81111844:	00a04574 	movhi	r2,33045
81111848:	108d6b04 	addi	r2,r2,13740
8111184c:	00e04574 	movhi	r3,33045
81111850:	18f37b04 	addi	r3,r3,-12820
81111854:	10c01715 	stw	r3,92(r2)
	cTemp[24]="usiHkVccdPosRaw";
81111858:	00a04574 	movhi	r2,33045
8111185c:	108d6b04 	addi	r2,r2,13740
81111860:	00e04574 	movhi	r3,33045
81111864:	18f37e04 	addi	r3,r3,-12808
81111868:	10c01815 	stw	r3,96(r2)
	cTemp[25]="usiHkVclkPosRaw";
8111186c:	00a04574 	movhi	r2,33045
81111870:	108d6b04 	addi	r2,r2,13740
81111874:	00e04574 	movhi	r3,33045
81111878:	18f38204 	addi	r3,r3,-12792
8111187c:	10c01915 	stw	r3,100(r2)
	cTemp[26]="usiHkVan1PosRaw";
81111880:	00a04574 	movhi	r2,33045
81111884:	108d6b04 	addi	r2,r2,13740
81111888:	00e04574 	movhi	r3,33045
8111188c:	18f38604 	addi	r3,r3,-12776
81111890:	10c01a15 	stw	r3,104(r2)
	cTemp[27]="usiHkVan3NegRaw";
81111894:	00a04574 	movhi	r2,33045
81111898:	108d6b04 	addi	r2,r2,13740
8111189c:	00e04574 	movhi	r3,33045
811118a0:	18f38a04 	addi	r3,r3,-12760
811118a4:	10c01b15 	stw	r3,108(r2)
	cTemp[28]="usiHkVan2PosRaw";
811118a8:	00a04574 	movhi	r2,33045
811118ac:	108d6b04 	addi	r2,r2,13740
811118b0:	00e04574 	movhi	r3,33045
811118b4:	18f38e04 	addi	r3,r3,-12744
811118b8:	10c01c15 	stw	r3,112(r2)
	cTemp[29]="usiHkVdigFpgaRaw";
811118bc:	00a04574 	movhi	r2,33045
811118c0:	108d6b04 	addi	r2,r2,13740
811118c4:	00e04574 	movhi	r3,33045
811118c8:	18f39204 	addi	r3,r3,-12728
811118cc:	10c01d15 	stw	r3,116(r2)
	cTemp[30]="usiHkVdigSpwRaw";
811118d0:	00a04574 	movhi	r2,33045
811118d4:	108d6b04 	addi	r2,r2,13740
811118d8:	00e04574 	movhi	r3,33045
811118dc:	18f39704 	addi	r3,r3,-12708
811118e0:	10c01e15 	stw	r3,120(r2)
	cTemp[31]="usiHkViclkLow";
811118e4:	00a04574 	movhi	r2,33045
811118e8:	108d6b04 	addi	r2,r2,13740
811118ec:	00e04574 	movhi	r3,33045
811118f0:	18f39b04 	addi	r3,r3,-12692
811118f4:	10c01f15 	stw	r3,124(r2)
	cTemp[32]="usiHkAdcTempAE";
811118f8:	00a04574 	movhi	r2,33045
811118fc:	108d6b04 	addi	r2,r2,13740
81111900:	00e04574 	movhi	r3,33045
81111904:	18f39f04 	addi	r3,r3,-12676
81111908:	10c02015 	stw	r3,128(r2)
	cTemp[33]="usiHkAdcTempAF";
8111190c:	00a04574 	movhi	r2,33045
81111910:	108d6b04 	addi	r2,r2,13740
81111914:	00e04574 	movhi	r3,33045
81111918:	18f3a304 	addi	r3,r3,-12660
8111191c:	10c02115 	stw	r3,132(r2)
	cTemp[34]="usiHkCcd1Temp";
81111920:	00a04574 	movhi	r2,33045
81111924:	108d6b04 	addi	r2,r2,13740
81111928:	00e04574 	movhi	r3,33045
8111192c:	18f3a704 	addi	r3,r3,-12644
81111930:	10c02215 	stw	r3,136(r2)
	cTemp[35]="usiHkCcd2Temp";
81111934:	00a04574 	movhi	r2,33045
81111938:	108d6b04 	addi	r2,r2,13740
8111193c:	00e04574 	movhi	r3,33045
81111940:	18f3ab04 	addi	r3,r3,-12628
81111944:	10c02315 	stw	r3,140(r2)
	cTemp[36]="usiHkCcd3Temp";
81111948:	00a04574 	movhi	r2,33045
8111194c:	108d6b04 	addi	r2,r2,13740
81111950:	00e04574 	movhi	r3,33045
81111954:	18f3af04 	addi	r3,r3,-12612
81111958:	10c02415 	stw	r3,144(r2)
	cTemp[37]="usiHkCcd4Temp";
8111195c:	00a04574 	movhi	r2,33045
81111960:	108d6b04 	addi	r2,r2,13740
81111964:	00e04574 	movhi	r3,33045
81111968:	18f3b304 	addi	r3,r3,-12596
8111196c:	10c02515 	stw	r3,148(r2)
	cTemp[38]="usiHkWp605Spare";
81111970:	00a04574 	movhi	r2,33045
81111974:	108d6b04 	addi	r2,r2,13740
81111978:	00e04574 	movhi	r3,33045
8111197c:	18f3b704 	addi	r3,r3,-12580
81111980:	10c02615 	stw	r3,152(r2)
	cTemp[39]="usiLowresPrtA0";
81111984:	00a04574 	movhi	r2,33045
81111988:	108d6b04 	addi	r2,r2,13740
8111198c:	00e04574 	movhi	r3,33045
81111990:	18f3bb04 	addi	r3,r3,-12564
81111994:	10c02715 	stw	r3,156(r2)
	cTemp[40]="usiLowresPrtA1";
81111998:	00a04574 	movhi	r2,33045
8111199c:	108d6b04 	addi	r2,r2,13740
811119a0:	00e04574 	movhi	r3,33045
811119a4:	18f3bf04 	addi	r3,r3,-12548
811119a8:	10c02815 	stw	r3,160(r2)
	cTemp[41]="usiLowresPrtA2";
811119ac:	00a04574 	movhi	r2,33045
811119b0:	108d6b04 	addi	r2,r2,13740
811119b4:	00e04574 	movhi	r3,33045
811119b8:	18f3c304 	addi	r3,r3,-12532
811119bc:	10c02915 	stw	r3,164(r2)
	cTemp[42]="usiLowresPrtA3";
811119c0:	00a04574 	movhi	r2,33045
811119c4:	108d6b04 	addi	r2,r2,13740
811119c8:	00e04574 	movhi	r3,33045
811119cc:	18f3c704 	addi	r3,r3,-12516
811119d0:	10c02a15 	stw	r3,168(r2)
	cTemp[43]="usiLowresPrtA4";
811119d4:	00a04574 	movhi	r2,33045
811119d8:	108d6b04 	addi	r2,r2,13740
811119dc:	00e04574 	movhi	r3,33045
811119e0:	18f3cb04 	addi	r3,r3,-12500
811119e4:	10c02b15 	stw	r3,172(r2)
	cTemp[44]="usiLowresPrtA5";
811119e8:	00a04574 	movhi	r2,33045
811119ec:	108d6b04 	addi	r2,r2,13740
811119f0:	00e04574 	movhi	r3,33045
811119f4:	18f3cf04 	addi	r3,r3,-12484
811119f8:	10c02c15 	stw	r3,176(r2)
	cTemp[45]="usiLowresPrtA6";
811119fc:	00a04574 	movhi	r2,33045
81111a00:	108d6b04 	addi	r2,r2,13740
81111a04:	00e04574 	movhi	r3,33045
81111a08:	18f3d304 	addi	r3,r3,-12468
81111a0c:	10c02d15 	stw	r3,180(r2)
	cTemp[46]="usiLowresPrtA7";
81111a10:	00a04574 	movhi	r2,33045
81111a14:	108d6b04 	addi	r2,r2,13740
81111a18:	00e04574 	movhi	r3,33045
81111a1c:	18f3d704 	addi	r3,r3,-12452
81111a20:	10c02e15 	stw	r3,184(r2)
	cTemp[47]="usiLowresPrtA8";
81111a24:	00a04574 	movhi	r2,33045
81111a28:	108d6b04 	addi	r2,r2,13740
81111a2c:	00e04574 	movhi	r3,33045
81111a30:	18f3db04 	addi	r3,r3,-12436
81111a34:	10c02f15 	stw	r3,188(r2)
	cTemp[48]="usiLowresPrtA9";
81111a38:	00a04574 	movhi	r2,33045
81111a3c:	108d6b04 	addi	r2,r2,13740
81111a40:	00e04574 	movhi	r3,33045
81111a44:	18f3df04 	addi	r3,r3,-12420
81111a48:	10c03015 	stw	r3,192(r2)
	cTemp[49]="usiLowresPrtA10";
81111a4c:	00a04574 	movhi	r2,33045
81111a50:	108d6b04 	addi	r2,r2,13740
81111a54:	00e04574 	movhi	r3,33045
81111a58:	18f3e304 	addi	r3,r3,-12404
81111a5c:	10c03115 	stw	r3,196(r2)
	cTemp[50]="usiLowresPrtA11";
81111a60:	00a04574 	movhi	r2,33045
81111a64:	108d6b04 	addi	r2,r2,13740
81111a68:	00e04574 	movhi	r3,33045
81111a6c:	18f3e704 	addi	r3,r3,-12388
81111a70:	10c03215 	stw	r3,200(r2)
	cTemp[51]="usiLowresPrtA12";
81111a74:	00a04574 	movhi	r2,33045
81111a78:	108d6b04 	addi	r2,r2,13740
81111a7c:	00e04574 	movhi	r3,33045
81111a80:	18f3eb04 	addi	r3,r3,-12372
81111a84:	10c03315 	stw	r3,204(r2)
	cTemp[52]="usiLowresPrtA13";
81111a88:	00a04574 	movhi	r2,33045
81111a8c:	108d6b04 	addi	r2,r2,13740
81111a90:	00e04574 	movhi	r3,33045
81111a94:	18f3ef04 	addi	r3,r3,-12356
81111a98:	10c03415 	stw	r3,208(r2)
	cTemp[53]="usiLowresPrtA14";
81111a9c:	00a04574 	movhi	r2,33045
81111aa0:	108d6b04 	addi	r2,r2,13740
81111aa4:	00e04574 	movhi	r3,33045
81111aa8:	18f3f304 	addi	r3,r3,-12340
81111aac:	10c03515 	stw	r3,212(r2)
	cTemp[54]="usiLowresPrtA15";
81111ab0:	00a04574 	movhi	r2,33045
81111ab4:	108d6b04 	addi	r2,r2,13740
81111ab8:	00e04574 	movhi	r3,33045
81111abc:	18f3f704 	addi	r3,r3,-12324
81111ac0:	10c03615 	stw	r3,216(r2)
	cTemp[55]="usiSelHiresPrt0";
81111ac4:	00a04574 	movhi	r2,33045
81111ac8:	108d6b04 	addi	r2,r2,13740
81111acc:	00e04574 	movhi	r3,33045
81111ad0:	18f3fb04 	addi	r3,r3,-12308
81111ad4:	10c03715 	stw	r3,220(r2)
	cTemp[56]="usiSelHiresPrt1";
81111ad8:	00a04574 	movhi	r2,33045
81111adc:	108d6b04 	addi	r2,r2,13740
81111ae0:	00e04574 	movhi	r3,33045
81111ae4:	18f3ff04 	addi	r3,r3,-12292
81111ae8:	10c03815 	stw	r3,224(r2)
	cTemp[57]="usiSelHiresPrt2";
81111aec:	00a04574 	movhi	r2,33045
81111af0:	108d6b04 	addi	r2,r2,13740
81111af4:	00e04574 	movhi	r3,33045
81111af8:	18f40304 	addi	r3,r3,-12276
81111afc:	10c03915 	stw	r3,228(r2)
	cTemp[58]="usiSelHiresPrt3";
81111b00:	00a04574 	movhi	r2,33045
81111b04:	108d6b04 	addi	r2,r2,13740
81111b08:	00e04574 	movhi	r3,33045
81111b0c:	18f40704 	addi	r3,r3,-12260
81111b10:	10c03a15 	stw	r3,232(r2)
	cTemp[59]="usiSelHiresPrt4";
81111b14:	00a04574 	movhi	r2,33045
81111b18:	108d6b04 	addi	r2,r2,13740
81111b1c:	00e04574 	movhi	r3,33045
81111b20:	18f40b04 	addi	r3,r3,-12244
81111b24:	10c03b15 	stw	r3,236(r2)
	cTemp[60]="usiSelHiresPrt5";
81111b28:	00a04574 	movhi	r2,33045
81111b2c:	108d6b04 	addi	r2,r2,13740
81111b30:	00e04574 	movhi	r3,33045
81111b34:	18f40f04 	addi	r3,r3,-12228
81111b38:	10c03c15 	stw	r3,240(r2)
	cTemp[61]="usiSelHiresPrt6";
81111b3c:	00a04574 	movhi	r2,33045
81111b40:	108d6b04 	addi	r2,r2,13740
81111b44:	00e04574 	movhi	r3,33045
81111b48:	18f41304 	addi	r3,r3,-12212
81111b4c:	10c03d15 	stw	r3,244(r2)
	cTemp[62]="usiSelHiresPrt7";
81111b50:	00a04574 	movhi	r2,33045
81111b54:	108d6b04 	addi	r2,r2,13740
81111b58:	00e04574 	movhi	r3,33045
81111b5c:	18f41704 	addi	r3,r3,-12196
81111b60:	10c03e15 	stw	r3,248(r2)
	cTemp[63]="usiZeroHiresAmp";
81111b64:	00a04574 	movhi	r2,33045
81111b68:	108d6b04 	addi	r2,r2,13740
81111b6c:	00e04574 	movhi	r3,33045
81111b70:	18f41b04 	addi	r3,r3,-12180
81111b74:	10c03f15 	stw	r3,252(r2)
}
81111b78:	0001883a 	nop
81111b7c:	e037883a 	mov	sp,fp
81111b80:	df000017 	ldw	fp,0(sp)
81111b84:	dec00104 	addi	sp,sp,4
81111b88:	f800283a 	ret

81111b8c <vInAckHandlerTaskV2>:


#include "in_ack_handler_task.h"


void vInAckHandlerTaskV2(void *task_data) {
81111b8c:	defff604 	addi	sp,sp,-40
81111b90:	de00012e 	bgeu	sp,et,81111b98 <vInAckHandlerTaskV2+0xc>
81111b94:	003b68fa 	trap	3
81111b98:	dfc00915 	stw	ra,36(sp)
81111b9c:	df000815 	stw	fp,32(sp)
81111ba0:	df000804 	addi	fp,sp,32
81111ba4:	e13fff15 	stw	r4,-4(fp)

	bool bFound = FALSE;
81111ba8:	e03ff815 	stw	zero,-32(fp)
    bool bFinished32 = FALSE;
81111bac:	e03ffb15 	stw	zero,-20(fp)
    bool bFinished64 = FALSE;
81111bb0:	e03ffc15 	stw	zero,-16(fp)
    bool bFinished128 = FALSE;
81111bb4:	e03ffd15 	stw	zero,-12(fp)
	INT8U error_code;
	tReceiverACKState eReceiverAckState;
	static txReceivedACK xRAckLocal;
    unsigned char ucHashVerification = 0;
81111bb8:	e03ffa85 	stb	zero,-22(fp)
    unsigned char ucCountRetries = 0;
81111bbc:	e03ffa05 	stb	zero,-24(fp)
    unsigned char i = 0;
81111bc0:	e03ffa45 	stb	zero,-23(fp)

    #ifdef DEBUG_ON
        debug(fp,"In Ack Handler Task. (Task on)\n");
81111bc4:	d0a06217 	ldw	r2,-32376(gp)
81111bc8:	100f883a 	mov	r7,r2
81111bcc:	018007c4 	movi	r6,31
81111bd0:	01400044 	movi	r5,1
81111bd4:	01204574 	movhi	r4,33045
81111bd8:	21341f04 	addi	r4,r4,-12164
81111bdc:	11216400 	call	81121640 <fwrite>
    #endif

	eReceiverAckState = sRAConfiguring;
81111be0:	e03ff915 	stw	zero,-28(fp)

	for(;;){

		switch (eReceiverAckState) {
81111be4:	e0bff917 	ldw	r2,-28(fp)
81111be8:	10c00060 	cmpeqi	r3,r2,1
81111bec:	1800071e 	bne	r3,zero,81111c0c <vInAckHandlerTaskV2+0x80>
81111bf0:	0080032e 	bgeu	zero,r2,81111c00 <vInAckHandlerTaskV2+0x74>
81111bf4:	108000a0 	cmpeqi	r2,r2,2
81111bf8:	10004a1e 	bne	r2,zero,81111d24 <vInAckHandlerTaskV2+0x198>
81111bfc:	0000ac06 	br	81111eb0 <vInAckHandlerTaskV2+0x324>
			case sRAConfiguring:
                /*For future implementations*/
                eReceiverAckState = sRAGettingACK;
81111c00:	00800044 	movi	r2,1
81111c04:	e0bff915 	stw	r2,-28(fp)
				break;
81111c08:	0000b306 	br	81111ed8 <vInAckHandlerTaskV2+0x34c>
            case sRAGettingACK:
                eReceiverAckState = sRAGettingACK;
81111c0c:	00800044 	movi	r2,1
81111c10:	e0bff915 	stw	r2,-28(fp)
                /* Waits the semaphore that indicates there are some ack message was received*/
                OSSemPend(xSemCountReceivedACK, 0, &error_code);
81111c14:	d0a06617 	ldw	r2,-32360(gp)
81111c18:	e0fffe04 	addi	r3,fp,-8
81111c1c:	180d883a 	mov	r6,r3
81111c20:	000b883a 	mov	r5,zero
81111c24:	1009883a 	mov	r4,r2
81111c28:	113e4c00 	call	8113e4c0 <OSSemPend>
                if ( error_code == OS_ERR_NONE ) {
81111c2c:	e0bffe03 	ldbu	r2,-8(fp)
81111c30:	10803fcc 	andi	r2,r2,255
81111c34:	1000391e 	bne	r2,zero,81111d1c <vInAckHandlerTaskV2+0x190>

                    OSMutexPend(xMutexReceivedACK, 0, &error_code);
81111c38:	d0a06517 	ldw	r2,-32364(gp)
81111c3c:	e0fffe04 	addi	r3,fp,-8
81111c40:	180d883a 	mov	r6,r3
81111c44:	000b883a 	mov	r5,zero
81111c48:	1009883a 	mov	r4,r2
81111c4c:	113c4b40 	call	8113c4b4 <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
81111c50:	e0bffe03 	ldbu	r2,-8(fp)
81111c54:	10803fcc 	andi	r2,r2,255
81111c58:	10002b1e 	bne	r2,zero,81111d08 <vInAckHandlerTaskV2+0x17c>

                        /*Search for the ack*/
                        for(i = 0; i < N_ACKS_RECEIVED; i++)
81111c5c:	e03ffa45 	stb	zero,-23(fp)
81111c60:	00002206 	br	81111cec <vInAckHandlerTaskV2+0x160>
                        {
                            if ( xReceivedACK[i].cType != 0 ) {
81111c64:	e0fffa43 	ldbu	r3,-23(fp)
81111c68:	00a045b4 	movhi	r2,33046
81111c6c:	10830704 	addi	r2,r2,3100
81111c70:	18c7883a 	add	r3,r3,r3
81111c74:	18c7883a 	add	r3,r3,r3
81111c78:	10c5883a 	add	r2,r2,r3
81111c7c:	10800003 	ldbu	r2,0(r2)
81111c80:	10803fcc 	andi	r2,r2,255
81111c84:	1080201c 	xori	r2,r2,128
81111c88:	10bfe004 	addi	r2,r2,-128
81111c8c:	10001426 	beq	r2,zero,81111ce0 <vInAckHandlerTaskV2+0x154>

                                /*  Nack don't get here */
                                xRAckLocal = xReceivedACK[i];
81111c90:	e0fffa43 	ldbu	r3,-23(fp)
81111c94:	00a045b4 	movhi	r2,33046
81111c98:	10830704 	addi	r2,r2,3100
81111c9c:	18c7883a 	add	r3,r3,r3
81111ca0:	18c7883a 	add	r3,r3,r3
81111ca4:	10c5883a 	add	r2,r2,r3
81111ca8:	10c0000b 	ldhu	r3,0(r2)
81111cac:	d0e0568d 	sth	r3,-32422(gp)
81111cb0:	1080008b 	ldhu	r2,2(r2)
81111cb4:	d0a0570d 	sth	r2,-32420(gp)
                                xReceivedACK[i].cType = 0; /* indicates that this position now can be used by other message*/
81111cb8:	e0fffa43 	ldbu	r3,-23(fp)
81111cbc:	00a045b4 	movhi	r2,33046
81111cc0:	10830704 	addi	r2,r2,3100
81111cc4:	18c7883a 	add	r3,r3,r3
81111cc8:	18c7883a 	add	r3,r3,r3
81111ccc:	10c5883a 	add	r2,r2,r3
81111cd0:	10000005 	stb	zero,0(r2)
                                eReceiverAckState = sRACleanningBuffer;
81111cd4:	00800084 	movi	r2,2
81111cd8:	e0bff915 	stw	r2,-28(fp)
                                break;                                
81111cdc:	00000606 	br	81111cf8 <vInAckHandlerTaskV2+0x16c>

                    OSMutexPend(xMutexReceivedACK, 0, &error_code);
                    if ( error_code == OS_ERR_NONE ) {

                        /*Search for the ack*/
                        for(i = 0; i < N_ACKS_RECEIVED; i++)
81111ce0:	e0bffa43 	ldbu	r2,-23(fp)
81111ce4:	10800044 	addi	r2,r2,1
81111ce8:	e0bffa45 	stb	r2,-23(fp)
81111cec:	e0bffa43 	ldbu	r2,-23(fp)
81111cf0:	108001b0 	cmpltui	r2,r2,6
81111cf4:	103fdb1e 	bne	r2,zero,81111c64 <__reset+0xfb0f1c64>
                                xReceivedACK[i].cType = 0; /* indicates that this position now can be used by other message*/
                                eReceiverAckState = sRACleanningBuffer;
                                break;                                
                            }
                        }
                        OSMutexPost(xMutexReceivedACK);
81111cf8:	d0a06517 	ldw	r2,-32364(gp)
81111cfc:	1009883a 	mov	r4,r2
81111d00:	113ca580 	call	8113ca58 <OSMutexPost>
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
                }
                break;
81111d04:	00007406 	br	81111ed8 <vInAckHandlerTaskV2+0x34c>
                        OSMutexPost(xMutexReceivedACK);

                    } else {
                        /*  Should never get here, will wait without timeout for the semaphore.
                            But if some error accours we will do nothing but print in the console */
                    	OSSemPost(xSemCountReceivedACK);
81111d08:	d0a06617 	ldw	r2,-32360(gp)
81111d0c:	1009883a 	mov	r4,r2
81111d10:	113e8480 	call	8113e848 <OSSemPost>
                    	vFailGetMutexReceiverTask();
81111d14:	111b7700 	call	8111b770 <vFailGetMutexReceiverTask>
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
                }
                break;
81111d18:	00006f06 	br	81111ed8 <vInAckHandlerTaskV2+0x34c>
                    	vFailGetMutexReceiverTask();
                    }
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
81111d1c:	111b7080 	call	8111b708 <vFailGetCountSemaphoreReceiverTask>
                }
                break;
81111d20:	00006d06 	br	81111ed8 <vInAckHandlerTaskV2+0x34c>
			case sRACleanningBuffer:
                /* Now a search will be performed in the three output buffer in order to find
                   the (re)transmission buffer identified by the id and erase it. */
                
                ucHashVerification = 0;
81111d24:	e03ffa85 	stb	zero,-22(fp)
                ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);
81111d28:	d0a06883 	ldbu	r2,-32350(gp)
81111d2c:	10803fcc 	andi	r2,r2,255
81111d30:	10800218 	cmpnei	r2,r2,8
81111d34:	1000021e 	bne	r2,zero,81111d40 <vInAckHandlerTaskV2+0x1b4>
81111d38:	00c00104 	movi	r3,4
81111d3c:	00000106 	br	81111d44 <vInAckHandlerTaskV2+0x1b8>
81111d40:	0007883a 	mov	r3,zero
81111d44:	d0a07503 	ldbu	r2,-32300(gp)
81111d48:	10803fcc 	andi	r2,r2,255
81111d4c:	10800218 	cmpnei	r2,r2,8
81111d50:	1000021e 	bne	r2,zero,81111d5c <vInAckHandlerTaskV2+0x1d0>
81111d54:	00800084 	movi	r2,2
81111d58:	00000106 	br	81111d60 <vInAckHandlerTaskV2+0x1d4>
81111d5c:	0005883a 	mov	r2,zero
81111d60:	1884b03a 	or	r2,r3,r2
81111d64:	1007883a 	mov	r3,r2
81111d68:	d0a07543 	ldbu	r2,-32299(gp)
81111d6c:	10803fcc 	andi	r2,r2,255
81111d70:	108001a0 	cmpeqi	r2,r2,6
81111d74:	1884b03a 	or	r2,r3,r2
81111d78:	1007883a 	mov	r3,r2
81111d7c:	e0bffa83 	ldbu	r2,-22(fp)
81111d80:	1884b03a 	or	r2,r3,r2
81111d84:	e0bffa85 	stb	r2,-22(fp)

                bFound = FALSE;
81111d88:	e03ff815 	stw	zero,-32(fp)
                bFinished32=FALSE;
81111d8c:	e03ffb15 	stw	zero,-20(fp)
                bFinished64=FALSE;
81111d90:	e03ffc15 	stw	zero,-16(fp)
                bFinished128=FALSE;
81111d94:	e03ffd15 	stw	zero,-12(fp)
                ucCountRetries = 0;
81111d98:	e03ffa05 	stb	zero,-24(fp)
                do
                {
                    ucCountRetries++;
81111d9c:	e0bffa03 	ldbu	r2,-24(fp)
81111da0:	10800044 	addi	r2,r2,1
81111da4:	e0bffa05 	stb	r2,-24(fp)

                    /* There are any spot used in the xBuffer128? */
                    if ( 0b00000001 != (0b00000001 & ucHashVerification ) )
81111da8:	e0bffa83 	ldbu	r2,-22(fp)
81111dac:	1080004c 	andi	r2,r2,1
81111db0:	10803fcc 	andi	r2,r2,255
81111db4:	1000061e 	bne	r2,zero,81111dd0 <vInAckHandlerTaskV2+0x244>
                        bFound = bCheckInAck128( &xRAckLocal, &bFinished128  );
81111db8:	e0bffd04 	addi	r2,fp,-12
81111dbc:	100b883a 	mov	r5,r2
81111dc0:	d1205684 	addi	r4,gp,-32422
81111dc4:	1111edc0 	call	81111edc <bCheckInAck128>
81111dc8:	e0bff815 	stw	r2,-32(fp)
81111dcc:	00000206 	br	81111dd8 <vInAckHandlerTaskV2+0x24c>
                    else
                        bFinished128 = TRUE;
81111dd0:	00800044 	movi	r2,1
81111dd4:	e0bffd15 	stw	r2,-12(fp)

                    /* There are any spot used in the xBuffer64? */
                    if ( (0b00000010 != (0b00000010 & ucHashVerification )) && (bFound ==FALSE ) )
81111dd8:	e0bffa83 	ldbu	r2,-22(fp)
81111ddc:	1080008c 	andi	r2,r2,2
81111de0:	10803fcc 	andi	r2,r2,255
81111de4:	1000081e 	bne	r2,zero,81111e08 <vInAckHandlerTaskV2+0x27c>
81111de8:	e0bff817 	ldw	r2,-32(fp)
81111dec:	1000061e 	bne	r2,zero,81111e08 <vInAckHandlerTaskV2+0x27c>
                        bFound = bCheckInAck64( &xRAckLocal, &bFinished64 );
81111df0:	e0bffc04 	addi	r2,fp,-16
81111df4:	100b883a 	mov	r5,r2
81111df8:	d1205684 	addi	r4,gp,-32422
81111dfc:	11120240 	call	81112024 <bCheckInAck64>
81111e00:	e0bff815 	stw	r2,-32(fp)
81111e04:	00000206 	br	81111e10 <vInAckHandlerTaskV2+0x284>
                    else
                        bFinished64 = TRUE;
81111e08:	00800044 	movi	r2,1
81111e0c:	e0bffc15 	stw	r2,-16(fp)

                    /* There are any spot used in the xBuffer32? */
                    if ( (0b00000100 != (0b00000100 & ucHashVerification ) ) && (bFound ==FALSE ) )
81111e10:	e0bffa83 	ldbu	r2,-22(fp)
81111e14:	1080010c 	andi	r2,r2,4
81111e18:	10803fcc 	andi	r2,r2,255
81111e1c:	1000081e 	bne	r2,zero,81111e40 <vInAckHandlerTaskV2+0x2b4>
81111e20:	e0bff817 	ldw	r2,-32(fp)
81111e24:	1000061e 	bne	r2,zero,81111e40 <vInAckHandlerTaskV2+0x2b4>
                        bFound = bCheckInAck32( &xRAckLocal, &bFinished32  );
81111e28:	e0bffb04 	addi	r2,fp,-20
81111e2c:	100b883a 	mov	r5,r2
81111e30:	d1205684 	addi	r4,gp,-32422
81111e34:	11121700 	call	81112170 <bCheckInAck32>
81111e38:	e0bff815 	stw	r2,-32(fp)
81111e3c:	00000206 	br	81111e48 <vInAckHandlerTaskV2+0x2bc>
                    else
                        bFinished32 = TRUE;
81111e40:	00800044 	movi	r2,1
81111e44:	e0bffb15 	stw	r2,-20(fp)

                } while ( ((ucCountRetries++ < MAX_RETRIES_ACK_IN) && (bFound == FALSE) && ((bFinished32 == FALSE) | (bFinished64 == FALSE) | (bFinished128 == FALSE))) );
81111e48:	e0bffa03 	ldbu	r2,-24(fp)
81111e4c:	10c00044 	addi	r3,r2,1
81111e50:	e0fffa05 	stb	r3,-24(fp)
81111e54:	10803fcc 	andi	r2,r2,255
81111e58:	10800ca8 	cmpgeui	r2,r2,50
81111e5c:	10000e1e 	bne	r2,zero,81111e98 <vInAckHandlerTaskV2+0x30c>
81111e60:	e0bff817 	ldw	r2,-32(fp)
81111e64:	10000c1e 	bne	r2,zero,81111e98 <vInAckHandlerTaskV2+0x30c>
81111e68:	e0bffb17 	ldw	r2,-20(fp)
81111e6c:	1005003a 	cmpeq	r2,r2,zero
81111e70:	1007883a 	mov	r3,r2
81111e74:	e0bffc17 	ldw	r2,-16(fp)
81111e78:	1005003a 	cmpeq	r2,r2,zero
81111e7c:	1884b03a 	or	r2,r3,r2
81111e80:	10c03fcc 	andi	r3,r2,255
81111e84:	e0bffd17 	ldw	r2,-12(fp)
81111e88:	1005003a 	cmpeq	r2,r2,zero
81111e8c:	10803fcc 	andi	r2,r2,255
81111e90:	1884b03a 	or	r2,r3,r2
81111e94:	103fc11e 	bne	r2,zero,81111d9c <__reset+0xfb0f1d9c>
                
                if (bFound == FALSE) {
81111e98:	e0bff817 	ldw	r2,-32(fp)
81111e9c:	1000011e 	bne	r2,zero,81111ea4 <vInAckHandlerTaskV2+0x318>
                    /* Could not found the buffer with the id received in the ack packet*/
                    vFailFoundBufferRetransmission();
81111ea0:	111bc2c0 	call	8111bc2c <vFailFoundBufferRetransmission>
                }

                eReceiverAckState = sRAGettingACK;
81111ea4:	00800044 	movi	r2,1
81111ea8:	e0bff915 	stw	r2,-28(fp)
				break;
81111eac:	00000a06 	br	81111ed8 <vInAckHandlerTaskV2+0x34c>
			default:
                #ifdef DEBUG_ON
		            debug(fp,"Critical: Default State. Should never get here.(vInAckHandlerTaskV2)\n");
81111eb0:	d0a06217 	ldw	r2,-32376(gp)
81111eb4:	100f883a 	mov	r7,r2
81111eb8:	01801144 	movi	r6,69
81111ebc:	01400044 	movi	r5,1
81111ec0:	01204574 	movhi	r4,33045
81111ec4:	21342704 	addi	r4,r4,-12132
81111ec8:	11216400 	call	81121640 <fwrite>
	            #endif
                eReceiverAckState = sRAGettingACK;
81111ecc:	00800044 	movi	r2,1
81111ed0:	e0bff915 	stw	r2,-28(fp)
				break;
81111ed4:	0001883a 	nop
		}
	}
81111ed8:	003f4206 	br	81111be4 <__reset+0xfb0f1be4>

81111edc <bCheckInAck128>:
}


bool bCheckInAck128( txReceivedACK *xRecAckL , bool *bFinished ) {
81111edc:	defffa04 	addi	sp,sp,-24
81111ee0:	de00012e 	bgeu	sp,et,81111ee8 <bCheckInAck128+0xc>
81111ee4:	003b68fa 	trap	3
81111ee8:	dfc00515 	stw	ra,20(sp)
81111eec:	df000415 	stw	fp,16(sp)
81111ef0:	df000404 	addi	fp,sp,16
81111ef4:	e13ffe15 	stw	r4,-8(fp)
81111ef8:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
81111efc:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
81111f00:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
81111f04:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
81111f08:	e0bfff17 	ldw	r2,-4(fp)
81111f0c:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer128, 5, &error_code); /* Mas wait 1 tick = 1 ms */
81111f10:	d0a06e17 	ldw	r2,-32328(gp)
81111f14:	e0fffd44 	addi	r3,fp,-11
81111f18:	180d883a 	mov	r6,r3
81111f1c:	01400144 	movi	r5,5
81111f20:	1009883a 	mov	r4,r2
81111f24:	113c4b40 	call	8113c4b4 <OSMutexPend>
    if ( error_code != OS_NO_ERR )
81111f28:	e0bffd43 	ldbu	r2,-11(fp)
81111f2c:	10803fcc 	andi	r2,r2,255
81111f30:	10000226 	beq	r2,zero,81111f3c <bCheckInAck128+0x60>
        return bFound;
81111f34:	e0bffc17 	ldw	r2,-16(fp)
81111f38:	00003506 	br	81112010 <bCheckInAck128+0x134>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_128; ucIL++)
81111f3c:	e03ffd05 	stb	zero,-12(fp)
81111f40:	00002706 	br	81111fe0 <bCheckInAck128+0x104>
    {
        if ( xBuffer128[ucIL].usiId == xRecAckL->usiId ) {
81111f44:	e0fffd03 	ldbu	r3,-12(fp)
81111f48:	00a045b4 	movhi	r2,33046
81111f4c:	10ba0504 	addi	r2,r2,-6124
81111f50:	18c02324 	muli	r3,r3,140
81111f54:	10c5883a 	add	r2,r2,r3
81111f58:	10802104 	addi	r2,r2,132
81111f5c:	10c0000b 	ldhu	r3,0(r2)
81111f60:	e0bffe17 	ldw	r2,-8(fp)
81111f64:	1080008b 	ldhu	r2,2(r2)
81111f68:	18ffffcc 	andi	r3,r3,65535
81111f6c:	10bfffcc 	andi	r2,r2,65535
81111f70:	1880181e 	bne	r3,r2,81111fd4 <bCheckInAck128+0xf8>
            bFound = TRUE;
81111f74:	00800044 	movi	r2,1
81111f78:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b128[ucIL] = FALSE;
81111f7c:	e0fffd03 	ldbu	r3,-12(fp)
81111f80:	00a045b4 	movhi	r2,33046
81111f84:	10b9e704 	addi	r2,r2,-6244
81111f88:	18c7883a 	add	r3,r3,r3
81111f8c:	18c7883a 	add	r3,r3,r3
81111f90:	10c5883a 	add	r2,r2,r3
81111f94:	10000015 	stw	zero,0(r2)
            SemCount128++;
81111f98:	d0a07543 	ldbu	r2,-32299(gp)
81111f9c:	10800044 	addi	r2,r2,1
81111fa0:	d0a07545 	stb	r2,-32299(gp)
            error_code = OSSemPost(xSemCountBuffer128);
81111fa4:	d0a06317 	ldw	r2,-32372(gp)
81111fa8:	1009883a 	mov	r4,r2
81111fac:	113e8480 	call	8113e848 <OSSemPost>
81111fb0:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
81111fb4:	e0bffd43 	ldbu	r2,-11(fp)
81111fb8:	10803fcc 	andi	r2,r2,255
81111fbc:	10000c26 	beq	r2,zero,81111ff0 <bCheckInAck128+0x114>
                SemCount128--;
81111fc0:	d0a07543 	ldbu	r2,-32299(gp)
81111fc4:	10bfffc4 	addi	r2,r2,-1
81111fc8:	d0a07545 	stb	r2,-32299(gp)
                vFailSetCountSemaphorexBuffer128();
81111fcc:	111ba8c0 	call	8111ba8c <vFailSetCountSemaphorexBuffer128>
            }
            break;
81111fd0:	00000706 	br	81111ff0 <bCheckInAck128+0x114>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_128; ucIL++)
81111fd4:	e0bffd03 	ldbu	r2,-12(fp)
81111fd8:	10800044 	addi	r2,r2,1
81111fdc:	e0bffd05 	stb	r2,-12(fp)
81111fe0:	e0bffd03 	ldbu	r2,-12(fp)
81111fe4:	108001b0 	cmpltui	r2,r2,6
81111fe8:	103fd61e 	bne	r2,zero,81111f44 <__reset+0xfb0f1f44>
81111fec:	00000106 	br	81111ff4 <bCheckInAck128+0x118>
            error_code = OSSemPost(xSemCountBuffer128);
            if ( error_code != OS_ERR_NONE ) {
                SemCount128--;
                vFailSetCountSemaphorexBuffer128();
            }
            break;
81111ff0:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer128); /* Free the Mutex after use the xBuffer128*/
81111ff4:	d0a06e17 	ldw	r2,-32328(gp)
81111ff8:	1009883a 	mov	r4,r2
81111ffc:	113ca580 	call	8113ca58 <OSMutexPost>
    (*bFinished) = TRUE;
81112000:	e0bfff17 	ldw	r2,-4(fp)
81112004:	00c00044 	movi	r3,1
81112008:	10c00015 	stw	r3,0(r2)

    return bFound;
8111200c:	e0bffc17 	ldw	r2,-16(fp)
}
81112010:	e037883a 	mov	sp,fp
81112014:	dfc00117 	ldw	ra,4(sp)
81112018:	df000017 	ldw	fp,0(sp)
8111201c:	dec00204 	addi	sp,sp,8
81112020:	f800283a 	ret

81112024 <bCheckInAck64>:


bool bCheckInAck64( txReceivedACK *xRecAckL , bool *bFinished ) {
81112024:	defffa04 	addi	sp,sp,-24
81112028:	de00012e 	bgeu	sp,et,81112030 <bCheckInAck64+0xc>
8111202c:	003b68fa 	trap	3
81112030:	dfc00515 	stw	ra,20(sp)
81112034:	df000415 	stw	fp,16(sp)
81112038:	df000404 	addi	fp,sp,16
8111203c:	e13ffe15 	stw	r4,-8(fp)
81112040:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
81112044:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
81112048:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
8111204c:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
81112050:	e0bfff17 	ldw	r2,-4(fp)
81112054:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer64, 1, &error_code); /* Mas wait 1 tick = 1 ms */
81112058:	d0a07117 	ldw	r2,-32316(gp)
8111205c:	e0fffd44 	addi	r3,fp,-11
81112060:	180d883a 	mov	r6,r3
81112064:	01400044 	movi	r5,1
81112068:	1009883a 	mov	r4,r2
8111206c:	113c4b40 	call	8113c4b4 <OSMutexPend>
    if ( error_code != OS_NO_ERR )
81112070:	e0bffd43 	ldbu	r2,-11(fp)
81112074:	10803fcc 	andi	r2,r2,255
81112078:	10000226 	beq	r2,zero,81112084 <bCheckInAck64+0x60>
        return bFound;
8111207c:	e0bffc17 	ldw	r2,-16(fp)
81112080:	00003606 	br	8111215c <bCheckInAck64+0x138>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_64; ucIL++)
81112084:	e03ffd05 	stb	zero,-12(fp)
81112088:	00002806 	br	8111212c <bCheckInAck64+0x108>
    {
        if ( xBuffer64[ucIL].usiId == xRecAckL->usiId ) {
8111208c:	e0fffd03 	ldbu	r3,-12(fp)
81112090:	00a04574 	movhi	r2,33045
81112094:	1095ab04 	addi	r2,r2,22188
81112098:	18c01324 	muli	r3,r3,76
8111209c:	10c5883a 	add	r2,r2,r3
811120a0:	10801104 	addi	r2,r2,68
811120a4:	10c0000b 	ldhu	r3,0(r2)
811120a8:	e0bffe17 	ldw	r2,-8(fp)
811120ac:	1080008b 	ldhu	r2,2(r2)
811120b0:	18ffffcc 	andi	r3,r3,65535
811120b4:	10bfffcc 	andi	r2,r2,65535
811120b8:	1880191e 	bne	r3,r2,81112120 <bCheckInAck64+0xfc>
            bFound = TRUE;
811120bc:	00800044 	movi	r2,1
811120c0:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b64[ucIL] = FALSE;
811120c4:	e0fffd03 	ldbu	r3,-12(fp)
811120c8:	00a045b4 	movhi	r2,33046
811120cc:	10b9e704 	addi	r2,r2,-6244
811120d0:	18c00184 	addi	r3,r3,6
811120d4:	18c7883a 	add	r3,r3,r3
811120d8:	18c7883a 	add	r3,r3,r3
811120dc:	10c5883a 	add	r2,r2,r3
811120e0:	10000015 	stw	zero,0(r2)
            SemCount64++;
811120e4:	d0a07503 	ldbu	r2,-32300(gp)
811120e8:	10800044 	addi	r2,r2,1
811120ec:	d0a07505 	stb	r2,-32300(gp)
            error_code = OSSemPost(xSemCountBuffer64);
811120f0:	d0a05e17 	ldw	r2,-32392(gp)
811120f4:	1009883a 	mov	r4,r2
811120f8:	113e8480 	call	8113e848 <OSSemPost>
811120fc:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
81112100:	e0bffd43 	ldbu	r2,-11(fp)
81112104:	10803fcc 	andi	r2,r2,255
81112108:	10000c26 	beq	r2,zero,8111213c <bCheckInAck64+0x118>
                SemCount64--;
8111210c:	d0a07503 	ldbu	r2,-32300(gp)
81112110:	10bfffc4 	addi	r2,r2,-1
81112114:	d0a07505 	stb	r2,-32300(gp)
                vFailSetCountSemaphorexBuffer64();
81112118:	111ba240 	call	8111ba24 <vFailSetCountSemaphorexBuffer64>
            }
            break;
8111211c:	00000706 	br	8111213c <bCheckInAck64+0x118>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_64; ucIL++)
81112120:	e0bffd03 	ldbu	r2,-12(fp)
81112124:	10800044 	addi	r2,r2,1
81112128:	e0bffd05 	stb	r2,-12(fp)
8111212c:	e0bffd03 	ldbu	r2,-12(fp)
81112130:	10800230 	cmpltui	r2,r2,8
81112134:	103fd51e 	bne	r2,zero,8111208c <__reset+0xfb0f208c>
81112138:	00000106 	br	81112140 <bCheckInAck64+0x11c>
            error_code = OSSemPost(xSemCountBuffer64);
            if ( error_code != OS_ERR_NONE ) {
                SemCount64--;
                vFailSetCountSemaphorexBuffer64();
            }
            break;
8111213c:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer64); /* Free the Mutex after use the xBuffer128*/
81112140:	d0a07117 	ldw	r2,-32316(gp)
81112144:	1009883a 	mov	r4,r2
81112148:	113ca580 	call	8113ca58 <OSMutexPost>
    (*bFinished) = TRUE;
8111214c:	e0bfff17 	ldw	r2,-4(fp)
81112150:	00c00044 	movi	r3,1
81112154:	10c00015 	stw	r3,0(r2)

    return bFound;
81112158:	e0bffc17 	ldw	r2,-16(fp)
}
8111215c:	e037883a 	mov	sp,fp
81112160:	dfc00117 	ldw	ra,4(sp)
81112164:	df000017 	ldw	fp,0(sp)
81112168:	dec00204 	addi	sp,sp,8
8111216c:	f800283a 	ret

81112170 <bCheckInAck32>:



bool bCheckInAck32( txReceivedACK *xRecAckL , bool *bFinished ) {
81112170:	defffa04 	addi	sp,sp,-24
81112174:	de00012e 	bgeu	sp,et,8111217c <bCheckInAck32+0xc>
81112178:	003b68fa 	trap	3
8111217c:	dfc00515 	stw	ra,20(sp)
81112180:	df000415 	stw	fp,16(sp)
81112184:	df000404 	addi	fp,sp,16
81112188:	e13ffe15 	stw	r4,-8(fp)
8111218c:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
81112190:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
81112194:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
81112198:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
8111219c:	e0bfff17 	ldw	r2,-4(fp)
811121a0:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer32, 1, &error_code); /* Mas wait 1 tick = 1 ms */
811121a4:	d0a06c17 	ldw	r2,-32336(gp)
811121a8:	e0fffd44 	addi	r3,fp,-11
811121ac:	180d883a 	mov	r6,r3
811121b0:	01400044 	movi	r5,1
811121b4:	1009883a 	mov	r4,r2
811121b8:	113c4b40 	call	8113c4b4 <OSMutexPend>
    if ( error_code != OS_NO_ERR )
811121bc:	e0bffd43 	ldbu	r2,-11(fp)
811121c0:	10803fcc 	andi	r2,r2,255
811121c4:	10000226 	beq	r2,zero,811121d0 <bCheckInAck32+0x60>
        return bFound;
811121c8:	e0bffc17 	ldw	r2,-16(fp)
811121cc:	00003606 	br	811122a8 <bCheckInAck32+0x138>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_32; ucIL++)
811121d0:	e03ffd05 	stb	zero,-12(fp)
811121d4:	00002806 	br	81112278 <bCheckInAck32+0x108>
    {
        if ( xBuffer32[ucIL].usiId == xRecAckL->usiId ) {
811121d8:	e0fffd03 	ldbu	r3,-12(fp)
811121dc:	00a045b4 	movhi	r2,33046
811121e0:	10a76704 	addi	r2,r2,-25188
811121e4:	18c00b24 	muli	r3,r3,44
811121e8:	10c5883a 	add	r2,r2,r3
811121ec:	10800904 	addi	r2,r2,36
811121f0:	10c0000b 	ldhu	r3,0(r2)
811121f4:	e0bffe17 	ldw	r2,-8(fp)
811121f8:	1080008b 	ldhu	r2,2(r2)
811121fc:	18ffffcc 	andi	r3,r3,65535
81112200:	10bfffcc 	andi	r2,r2,65535
81112204:	1880191e 	bne	r3,r2,8111226c <bCheckInAck32+0xfc>
            bFound = TRUE;
81112208:	00800044 	movi	r2,1
8111220c:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b32[ucIL] = FALSE;
81112210:	e0fffd03 	ldbu	r3,-12(fp)
81112214:	00a045b4 	movhi	r2,33046
81112218:	10b9e704 	addi	r2,r2,-6244
8111221c:	18c00384 	addi	r3,r3,14
81112220:	18c7883a 	add	r3,r3,r3
81112224:	18c7883a 	add	r3,r3,r3
81112228:	10c5883a 	add	r2,r2,r3
8111222c:	10000015 	stw	zero,0(r2)
            SemCount32++;
81112230:	d0a06883 	ldbu	r2,-32350(gp)
81112234:	10800044 	addi	r2,r2,1
81112238:	d0a06885 	stb	r2,-32350(gp)
            error_code = OSSemPost(xSemCountBuffer32);
8111223c:	d0a06f17 	ldw	r2,-32324(gp)
81112240:	1009883a 	mov	r4,r2
81112244:	113e8480 	call	8113e848 <OSSemPost>
81112248:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
8111224c:	e0bffd43 	ldbu	r2,-11(fp)
81112250:	10803fcc 	andi	r2,r2,255
81112254:	10000c26 	beq	r2,zero,81112288 <bCheckInAck32+0x118>
                SemCount32--;
81112258:	d0a06883 	ldbu	r2,-32350(gp)
8111225c:	10bfffc4 	addi	r2,r2,-1
81112260:	d0a06885 	stb	r2,-32350(gp)
                vFailSetCountSemaphorexBuffer32();
81112264:	111b9bc0 	call	8111b9bc <vFailSetCountSemaphorexBuffer32>
            }
            break;
81112268:	00000706 	br	81112288 <bCheckInAck32+0x118>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_32; ucIL++)
8111226c:	e0bffd03 	ldbu	r2,-12(fp)
81112270:	10800044 	addi	r2,r2,1
81112274:	e0bffd05 	stb	r2,-12(fp)
81112278:	e0bffd03 	ldbu	r2,-12(fp)
8111227c:	10800230 	cmpltui	r2,r2,8
81112280:	103fd51e 	bne	r2,zero,811121d8 <__reset+0xfb0f21d8>
81112284:	00000106 	br	8111228c <bCheckInAck32+0x11c>
            error_code = OSSemPost(xSemCountBuffer32);
            if ( error_code != OS_ERR_NONE ) {
                SemCount32--;
                vFailSetCountSemaphorexBuffer32();
            }
            break;
81112288:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer32); /* Free the Mutex after use the xMutexBuffer32*/
8111228c:	d0a06c17 	ldw	r2,-32336(gp)
81112290:	1009883a 	mov	r4,r2
81112294:	113ca580 	call	8113ca58 <OSMutexPost>
    (*bFinished) = TRUE;
81112298:	e0bfff17 	ldw	r2,-4(fp)
8111229c:	00c00044 	movi	r3,1
811122a0:	10c00015 	stw	r3,0(r2)

    return bFound;
811122a4:	e0bffc17 	ldw	r2,-16(fp)
}
811122a8:	e037883a 	mov	sp,fp
811122ac:	dfc00117 	ldw	ra,4(sp)
811122b0:	df000017 	ldw	fp,0(sp)
811122b4:	dec00204 	addi	sp,sp,8
811122b8:	f800283a 	ret

811122bc <vInitialTask>:

#include "initialization_task.h"


void vInitialTask(void *task_data)
{
811122bc:	defff704 	addi	sp,sp,-36
811122c0:	de00012e 	bgeu	sp,et,811122c8 <vInitialTask+0xc>
811122c4:	003b68fa 	trap	3
811122c8:	dfc00815 	stw	ra,32(sp)
811122cc:	df000715 	stw	fp,28(sp)
811122d0:	df000704 	addi	fp,sp,28
811122d4:	e13fff15 	stw	r4,-4(fp)
  INT8U error_code = OS_ERR_NONE;
811122d8:	e03ffe05 	stb	zero,-8(fp)
									vFeeTask0_stk,
									FEES_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vFeeTask,
811122dc:	d8000415 	stw	zero,16(sp)
811122e0:	d8000315 	stw	zero,12(sp)
811122e4:	00810004 	movi	r2,1024
811122e8:	d8800215 	stw	r2,8(sp)
811122ec:	00a04574 	movhi	r2,33045
811122f0:	108dab04 	addi	r2,r2,13996
811122f4:	d8800115 	stw	r2,4(sp)
811122f8:	008002c4 	movi	r2,11
811122fc:	d8800015 	stw	r2,0(sp)
81112300:	01c002c4 	movi	r7,11
81112304:	01a04574 	movhi	r6,33045
81112308:	3191aa04 	addi	r6,r6,18088
8111230c:	016045b4 	movhi	r5,33046
81112310:	2962cb04 	addi	r5,r5,-29908
81112314:	01204474 	movhi	r4,33041
81112318:	2136d804 	addi	r4,r4,-9376
8111231c:	113f22c0 	call	8113f22c <OSTaskCreateExt>
81112320:	e0bffe05 	stb	r2,-8(fp)
									FEES_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81112324:	e0bffe03 	ldbu	r2,-8(fp)
81112328:	10803fcc 	andi	r2,r2,255
8111232c:	10000526 	beq	r2,zero,81112344 <vInitialTask+0x88>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81112330:	e0bffe03 	ldbu	r2,-8(fp)
81112334:	10803fcc 	andi	r2,r2,255
81112338:	1009883a 	mov	r4,r2
8111233c:	111b3380 	call	8111b338 <printErrorTask>
		#endif
			vCoudlNotCreateNFee0Task();
81112340:	111c7e40 	call	8111c7e4 <vCoudlNotCreateNFee0Task>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
81112344:	01c17704 	movi	r7,1500
81112348:	000d883a 	mov	r6,zero
8111234c:	000b883a 	mov	r5,zero
81112350:	0009883a 	mov	r4,zero
81112354:	11404580 	call	81140458 <OSTimeDlyHMSM>
									vDataControlTask_stk,
									DATA_CONTROL_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vDataControlTask,
81112358:	d8000415 	stw	zero,16(sp)
8111235c:	d8000315 	stw	zero,12(sp)
81112360:	00810004 	movi	r2,1024
81112364:	d8800215 	stw	r2,8(sp)
81112368:	00a04574 	movhi	r2,33045
8111236c:	109eb904 	addi	r2,r2,31460
81112370:	d8800115 	stw	r2,4(sp)
81112374:	00800284 	movi	r2,10
81112378:	d8800015 	stw	r2,0(sp)
8111237c:	01c00284 	movi	r7,10
81112380:	01a045b4 	movhi	r6,33046
81112384:	31a2b804 	addi	r6,r6,-29984
81112388:	016045b4 	movhi	r5,33046
8111238c:	2962c304 	addi	r5,r5,-29940
81112390:	01204474 	movhi	r4,33041
81112394:	2136b004 	addi	r4,r4,-9536
81112398:	113f22c0 	call	8113f22c <OSTaskCreateExt>
8111239c:	e0bffe05 	stb	r2,-8(fp)
									DATA_CONTROL_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
811123a0:	e0bffe03 	ldbu	r2,-8(fp)
811123a4:	10803fcc 	andi	r2,r2,255
811123a8:	10000526 	beq	r2,zero,811123c0 <vInitialTask+0x104>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
811123ac:	e0bffe03 	ldbu	r2,-8(fp)
811123b0:	10803fcc 	andi	r2,r2,255
811123b4:	1009883a 	mov	r4,r2
811123b8:	111b3380 	call	8111b338 <printErrorTask>
		#endif
			vCoudlNotCreateDataControllerTask();
811123bc:	111cabc0 	call	8111cabc <vCoudlNotCreateDataControllerTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
811123c0:	01c17704 	movi	r7,1500
811123c4:	000d883a 	mov	r6,zero
811123c8:	000b883a 	mov	r5,zero
811123cc:	0009883a 	mov	r4,zero
811123d0:	11404580 	call	81140458 <OSTimeDlyHMSM>
									vNFeeControlTask_stk,
									FEE_CONTROL_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vNFeeControlTask,
811123d4:	d8000415 	stw	zero,16(sp)
811123d8:	d8000315 	stw	zero,12(sp)
811123dc:	00810004 	movi	r2,1024
811123e0:	d8800215 	stw	r2,8(sp)
811123e4:	00a045b4 	movhi	r2,33046
811123e8:	10baef04 	addi	r2,r2,-5188
811123ec:	d8800115 	stw	r2,4(sp)
811123f0:	00800244 	movi	r2,9
811123f4:	d8800015 	stw	r2,0(sp)
811123f8:	01c00244 	movi	r7,9
811123fc:	01a045b4 	movhi	r6,33046
81112400:	31beee04 	addi	r6,r6,-1096
81112404:	016045b4 	movhi	r5,33046
81112408:	2962cb04 	addi	r5,r5,-29908
8111240c:	01204474 	movhi	r4,33041
81112410:	210a1004 	addi	r4,r4,10304
81112414:	113f22c0 	call	8113f22c <OSTaskCreateExt>
81112418:	e0bffe05 	stb	r2,-8(fp)
									FEE_CONTROL_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8111241c:	e0bffe03 	ldbu	r2,-8(fp)
81112420:	10803fcc 	andi	r2,r2,255
81112424:	10000526 	beq	r2,zero,8111243c <vInitialTask+0x180>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81112428:	e0bffe03 	ldbu	r2,-8(fp)
8111242c:	10803fcc 	andi	r2,r2,255
81112430:	1009883a 	mov	r4,r2
81112434:	111b3380 	call	8111b338 <printErrorTask>
		#endif
			vCoudlNotCreateNFeeControllerTask();
81112438:	111ca540 	call	8111ca54 <vCoudlNotCreateNFeeControllerTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
8111243c:	01c17704 	movi	r7,1500
81112440:	000d883a 	mov	r6,zero
81112444:	000b883a 	mov	r5,zero
81112448:	0009883a 	mov	r4,zero
8111244c:	11404580 	call	81140458 <OSTimeDlyHMSM>
									vSimMebTask_stk,
									MEB_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vSimMebTask,
81112450:	d8000415 	stw	zero,16(sp)
81112454:	d8000315 	stw	zero,12(sp)
81112458:	00810004 	movi	r2,1024
8111245c:	d8800215 	stw	r2,8(sp)
81112460:	00a045b4 	movhi	r2,33046
81112464:	108d1104 	addi	r2,r2,13380
81112468:	d8800115 	stw	r2,4(sp)
8111246c:	00800204 	movi	r2,8
81112470:	d8800015 	stw	r2,0(sp)
81112474:	01c00204 	movi	r7,8
81112478:	01a045b4 	movhi	r6,33046
8111247c:	31911004 	addi	r6,r6,17472
81112480:	016045b4 	movhi	r5,33046
81112484:	2962b904 	addi	r5,r5,-29980
81112488:	01204474 	movhi	r4,33041
8111248c:	2113b304 	addi	r4,r4,20172
81112490:	113f22c0 	call	8113f22c <OSTaskCreateExt>
81112494:	e0bffe05 	stb	r2,-8(fp)
									MEB_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81112498:	e0bffe03 	ldbu	r2,-8(fp)
8111249c:	10803fcc 	andi	r2,r2,255
811124a0:	10000526 	beq	r2,zero,811124b8 <vInitialTask+0x1fc>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
811124a4:	e0bffe03 	ldbu	r2,-8(fp)
811124a8:	10803fcc 	andi	r2,r2,255
811124ac:	1009883a 	mov	r4,r2
811124b0:	111b3380 	call	8111b338 <printErrorTask>
		#endif
			vCoudlNotCreateMebTask();
811124b4:	111cb240 	call	8111cb24 <vCoudlNotCreateMebTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
811124b8:	01c17704 	movi	r7,1500
811124bc:	000d883a 	mov	r6,zero
811124c0:	000b883a 	mov	r5,zero
811124c4:	0009883a 	mov	r4,zero
811124c8:	11404580 	call	81140458 <OSTimeDlyHMSM>
									vTimeoutCheckerTask_stk,
									TIMEOUT_CHECKER_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vTimeoutCheckerTaskv2,
811124cc:	d8000415 	stw	zero,16(sp)
811124d0:	d8000315 	stw	zero,12(sp)
811124d4:	00810004 	movi	r2,1024
811124d8:	d8800215 	stw	r2,8(sp)
811124dc:	00a04574 	movhi	r2,33045
811124e0:	109ab904 	addi	r2,r2,27364
811124e4:	d8800115 	stw	r2,4(sp)
811124e8:	00800784 	movi	r2,30
811124ec:	d8800015 	stw	r2,0(sp)
811124f0:	01c00784 	movi	r7,30
811124f4:	01a04574 	movhi	r6,33045
811124f8:	319eb804 	addi	r6,r6,31456
811124fc:	000b883a 	mov	r5,zero
81112500:	01204474 	movhi	r4,33041
81112504:	211a7f04 	addi	r4,r4,27132
81112508:	113f22c0 	call	8113f22c <OSTaskCreateExt>
8111250c:	e0bffe05 	stb	r2,-8(fp)
									TIMEOUT_CHECKER_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81112510:	e0bffe03 	ldbu	r2,-8(fp)
81112514:	10803fcc 	andi	r2,r2,255
81112518:	10000526 	beq	r2,zero,81112530 <vInitialTask+0x274>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8111251c:	e0bffe03 	ldbu	r2,-8(fp)
81112520:	10803fcc 	andi	r2,r2,255
81112524:	1009883a 	mov	r4,r2
81112528:	111b3380 	call	8111b338 <printErrorTask>
		#endif
		vFailTimeoutCheckerTaskCreate();
8111252c:	111c1500 	call	8111c150 <vFailTimeoutCheckerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
81112530:	01c03204 	movi	r7,200
81112534:	000d883a 	mov	r6,zero
81112538:	000b883a 	mov	r5,zero
8111253c:	0009883a 	mov	r4,zero
81112540:	11404580 	call	81140458 <OSTimeDlyHMSM>
									vOutAckHandlerTask_stk,
									OUT_ACK_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vOutAckHandlerTask,
81112544:	d8000415 	stw	zero,16(sp)
81112548:	d8000315 	stw	zero,12(sp)
8111254c:	00810004 	movi	r2,1024
81112550:	d8800215 	stw	r2,8(sp)
81112554:	00a045b4 	movhi	r2,33046
81112558:	10adcf04 	addi	r2,r2,-18628
8111255c:	d8800115 	stw	r2,4(sp)
81112560:	008006c4 	movi	r2,27
81112564:	d8800015 	stw	r2,0(sp)
81112568:	01c006c4 	movi	r7,27
8111256c:	01a045b4 	movhi	r6,33046
81112570:	31b1ce04 	addi	r6,r6,-14536
81112574:	000b883a 	mov	r5,zero
81112578:	01204474 	movhi	r4,33041
8111257c:	210bf904 	addi	r4,r4,12260
81112580:	113f22c0 	call	8113f22c <OSTaskCreateExt>
81112584:	e0bffe05 	stb	r2,-8(fp)
									OUT_ACK_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81112588:	e0bffe03 	ldbu	r2,-8(fp)
8111258c:	10803fcc 	andi	r2,r2,255
81112590:	10000526 	beq	r2,zero,811125a8 <vInitialTask+0x2ec>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81112594:	e0bffe03 	ldbu	r2,-8(fp)
81112598:	10803fcc 	andi	r2,r2,255
8111259c:	1009883a 	mov	r4,r2
811125a0:	111b3380 	call	8111b338 <printErrorTask>
		#endif
		vFailOutAckHandlerTaskCreate();
811125a4:	111c06c0 	call	8111c06c <vFailOutAckHandlerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
811125a8:	01c03204 	movi	r7,200
811125ac:	000d883a 	mov	r6,zero
811125b0:	000b883a 	mov	r5,zero
811125b4:	0009883a 	mov	r4,zero
811125b8:	11404580 	call	81140458 <OSTimeDlyHMSM>
									vInAckHandlerTask_stk,
									IN_ACK_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vInAckHandlerTaskV2,
811125bc:	d8000415 	stw	zero,16(sp)
811125c0:	d8000315 	stw	zero,12(sp)
811125c4:	00810004 	movi	r2,1024
811125c8:	d8800215 	stw	r2,8(sp)
811125cc:	00a04574 	movhi	r2,33045
811125d0:	1091ab04 	addi	r2,r2,18092
811125d4:	d8800115 	stw	r2,4(sp)
811125d8:	00800644 	movi	r2,25
811125dc:	d8800015 	stw	r2,0(sp)
811125e0:	01c00644 	movi	r7,25
811125e4:	01a04574 	movhi	r6,33045
811125e8:	3195aa04 	addi	r6,r6,22184
811125ec:	000b883a 	mov	r5,zero
811125f0:	01204474 	movhi	r4,33041
811125f4:	2106e304 	addi	r4,r4,7052
811125f8:	113f22c0 	call	8113f22c <OSTaskCreateExt>
811125fc:	e0bffe05 	stb	r2,-8(fp)
									IN_ACK_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81112600:	e0bffe03 	ldbu	r2,-8(fp)
81112604:	10803fcc 	andi	r2,r2,255
81112608:	10000526 	beq	r2,zero,81112620 <vInitialTask+0x364>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8111260c:	e0bffe03 	ldbu	r2,-8(fp)
81112610:	10803fcc 	andi	r2,r2,255
81112614:	1009883a 	mov	r4,r2
81112618:	111b3380 	call	8111b338 <printErrorTask>
		#endif
		vFailInAckHandlerTaskCreate();
8111261c:	111c0200 	call	8111c020 <vFailInAckHandlerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
81112620:	01c03204 	movi	r7,200
81112624:	000d883a 	mov	r6,zero
81112628:	000b883a 	mov	r5,zero
8111262c:	0009883a 	mov	r4,zero
81112630:	11404580 	call	81140458 <OSTimeDlyHMSM>
									vParserCommTask_stk,
									PARSER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CHK + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vParserCommTask,
81112634:	d8000415 	stw	zero,16(sp)
81112638:	d8000315 	stw	zero,12(sp)
8111263c:	00818004 	movi	r2,1536
81112640:	d8800215 	stw	r2,8(sp)
81112644:	00a045b4 	movhi	r2,33046
81112648:	10870d04 	addi	r2,r2,7220
8111264c:	d8800115 	stw	r2,4(sp)
81112650:	00800704 	movi	r2,28
81112654:	d8800015 	stw	r2,0(sp)
81112658:	01c00704 	movi	r7,28
8111265c:	01a045b4 	movhi	r6,33046
81112660:	318d0c04 	addi	r6,r6,13360
81112664:	000b883a 	mov	r5,zero
81112668:	01204474 	movhi	r4,33041
8111266c:	210cb704 	addi	r4,r4,13020
81112670:	113f22c0 	call	8113f22c <OSTaskCreateExt>
81112674:	e0bffe05 	stb	r2,-8(fp)
									PARSER_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81112678:	e0bffe03 	ldbu	r2,-8(fp)
8111267c:	10803fcc 	andi	r2,r2,255
81112680:	10000526 	beq	r2,zero,81112698 <vInitialTask+0x3dc>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81112684:	e0bffe03 	ldbu	r2,-8(fp)
81112688:	10803fcc 	andi	r2,r2,255
8111268c:	1009883a 	mov	r4,r2
81112690:	111b3380 	call	8111b338 <printErrorTask>
		#endif
		vFailParserCommTaskCreate();
81112694:	111bfd40 	call	8111bfd4 <vFailParserCommTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
81112698:	01c03204 	movi	r7,200
8111269c:	000d883a 	mov	r6,zero
811126a0:	000b883a 	mov	r5,zero
811126a4:	0009883a 	mov	r4,zero
811126a8:	11404580 	call	81140458 <OSTimeDlyHMSM>
									vReceiverUartTask_stk,
									RECEIVER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CHK + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vReceiverUartTask,
811126ac:	d8000415 	stw	zero,16(sp)
811126b0:	d8000315 	stw	zero,12(sp)
811126b4:	00818004 	movi	r2,1536
811126b8:	d8800215 	stw	r2,8(sp)
811126bc:	00a045b4 	movhi	r2,33046
811126c0:	10a7bf04 	addi	r2,r2,-24836
811126c4:	d8800115 	stw	r2,4(sp)
811126c8:	00800804 	movi	r2,32
811126cc:	d8800015 	stw	r2,0(sp)
811126d0:	01c00804 	movi	r7,32
811126d4:	01a045b4 	movhi	r6,33046
811126d8:	31adbe04 	addi	r6,r6,-18696
811126dc:	000b883a 	mov	r5,zero
811126e0:	01204474 	movhi	r4,33041
811126e4:	2110d304 	addi	r4,r4,17228
811126e8:	113f22c0 	call	8113f22c <OSTaskCreateExt>
811126ec:	e0bffe05 	stb	r2,-8(fp)
									RECEIVER_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
811126f0:	e0bffe03 	ldbu	r2,-8(fp)
811126f4:	10803fcc 	andi	r2,r2,255
811126f8:	10000526 	beq	r2,zero,81112710 <vInitialTask+0x454>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
811126fc:	e0bffe03 	ldbu	r2,-8(fp)
81112700:	10803fcc 	andi	r2,r2,255
81112704:	1009883a 	mov	r4,r2
81112708:	111b3380 	call	8111b338 <printErrorTask>
		#endif
		vFailReceiverCreate();
8111270c:	111b8d80 	call	8111b8d8 <vFailReceiverCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
81112710:	01c03204 	movi	r7,200
81112714:	000d883a 	mov	r6,zero
81112718:	000b883a 	mov	r5,zero
8111271c:	0009883a 	mov	r4,zero
81112720:	11404580 	call	81140458 <OSTimeDlyHMSM>
									senderTask_stk,
									SENDER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vSenderComTask,
81112724:	d8000415 	stw	zero,16(sp)
81112728:	d8000315 	stw	zero,12(sp)
8111272c:	00810004 	movi	r2,1024
81112730:	d8800215 	stw	r2,8(sp)
81112734:	00a04574 	movhi	r2,33045
81112738:	1096a704 	addi	r2,r2,23196
8111273c:	d8800115 	stw	r2,4(sp)
81112740:	00800684 	movi	r2,26
81112744:	d8800015 	stw	r2,0(sp)
81112748:	01c00684 	movi	r7,26
8111274c:	01a04574 	movhi	r6,33045
81112750:	319aa604 	addi	r6,r6,27288
81112754:	000b883a 	mov	r5,zero
81112758:	01204474 	movhi	r4,33041
8111275c:	21135504 	addi	r4,r4,19796
81112760:	113f22c0 	call	8113f22c <OSTaskCreateExt>
81112764:	e0bffe05 	stb	r2,-8(fp)
									0);
	#endif



	OSTimeDlyHMSM(0, 0, 0, 200);
81112768:	01c03204 	movi	r7,200
8111276c:	000d883a 	mov	r6,zero
81112770:	000b883a 	mov	r5,zero
81112774:	0009883a 	mov	r4,zero
81112778:	11404580 	call	81140458 <OSTimeDlyHMSM>
									OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK);
	#endif



	if ( error_code != OS_ERR_NONE) {
8111277c:	e0bffe03 	ldbu	r2,-8(fp)
81112780:	10803fcc 	andi	r2,r2,255
81112784:	10000526 	beq	r2,zero,8111279c <vInitialTask+0x4e0>
		/* Can't create Task for sender comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
81112788:	e0bffe03 	ldbu	r2,-8(fp)
8111278c:	10803fcc 	andi	r2,r2,255
81112790:	1009883a 	mov	r4,r2
81112794:	111b3380 	call	8111b338 <printErrorTask>
		#endif
		vFailSenderCreate();
81112798:	111b9240 	call	8111b924 <vFailSenderCreate>
	}

	/*	This is the timer that's trigger the task that implements the timeout/retransmission logic*/
	OSTmrStart ((OS_TMR *)xTimerRetransmission, (INT8U  *)&error_code);
8111279c:	d0a06d17 	ldw	r2,-32332(gp)
811127a0:	e17ffe04 	addi	r5,fp,-8
811127a4:	1009883a 	mov	r4,r2
811127a8:	1140f4c0 	call	81140f4c <OSTmrStart>
	if ( error_code != OS_ERR_NONE) {
811127ac:	e0bffe03 	ldbu	r2,-8(fp)
811127b0:	10803fcc 	andi	r2,r2,255
811127b4:	10000126 	beq	r2,zero,811127bc <vInitialTask+0x500>
		/*	Could not create the timer that syncs the task that is responsible to retransmit the packets*/
		vFailStartTimerRetransmission();
811127b8:	111c40c0 	call	8111c40c <vFailStartTimerRetransmission>
	}


	OSTimeDlyHMSM(0, 0, 30, 2); /* todo:debug REMOVER*/
811127bc:	01c00084 	movi	r7,2
811127c0:	01800784 	movi	r6,30
811127c4:	000b883a 	mov	r5,zero
811127c8:	0009883a 	mov	r4,zero
811127cc:	11404580 	call	81140458 <OSTimeDlyHMSM>


	/* Delete the Initialization Task  */
	error_code = OSTaskDel(OS_PRIO_SELF); /* OS_PRIO_SELF = Means task self priority */
811127d0:	01003fc4 	movi	r4,255
811127d4:	113f4180 	call	8113f418 <OSTaskDel>
811127d8:	e0bffe05 	stb	r2,-8(fp)
	if ( error_code != OS_ERR_NONE) {
811127dc:	e0bffe03 	ldbu	r2,-8(fp)
811127e0:	10803fcc 	andi	r2,r2,255
811127e4:	10001026 	beq	r2,zero,81112828 <vInitialTask+0x56c>
		/*	Can't delete the initialization task, the problem is that the priority of this
			is that the PRIO is so high that will cause starvation if not deleted */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
811127e8:	e0bffe03 	ldbu	r2,-8(fp)
811127ec:	10803fcc 	andi	r2,r2,255
811127f0:	1009883a 	mov	r4,r2
811127f4:	111b3380 	call	8111b338 <printErrorTask>
		#endif
		vFailDeleteInitialization();
811127f8:	111b9700 	call	8111b970 <vFailDeleteInitialization>
		/*	To not exit the intire application, the PRIO of this task will be lowered*/
		OSTaskChangePrio( INITIALIZATION_TASK_PRIO , INITIALIZATION_TASK_PRIO_FAIL );
811127fc:	014009c4 	movi	r5,39
81112800:	01000044 	movi	r4,1
81112804:	113eb800 	call	8113eb80 <OSTaskChangePrio>

		for(;;) { /* Correct Program Flow should never get here */
			OSTaskDel(OS_PRIO_SELF); /* Try to delete it self */
81112808:	01003fc4 	movi	r4,255
8111280c:	113f4180 	call	8113f418 <OSTaskDel>
			OSTimeDlyHMSM(0,0,10,0); /* 1 sec */
81112810:	000f883a 	mov	r7,zero
81112814:	01800284 	movi	r6,10
81112818:	000b883a 	mov	r5,zero
8111281c:	0009883a 	mov	r4,zero
81112820:	11404580 	call	81140458 <OSTimeDlyHMSM>
		}
81112824:	003ff806 	br	81112808 <__reset+0xfb0f2808>
	}

}
81112828:	0001883a 	nop
8111282c:	e037883a 	mov	sp,fp
81112830:	dfc00117 	ldw	ra,4(sp)
81112834:	df000017 	ldw	fp,0(sp)
81112838:	dec00204 	addi	sp,sp,8
8111283c:	f800283a 	ret

81112840 <vNFeeControlTask>:


#include "nfee_control_task.h"


void vNFeeControlTask(void *task_data) {
81112840:	defff804 	addi	sp,sp,-32
81112844:	de00012e 	bgeu	sp,et,8111284c <vNFeeControlTask+0xc>
81112848:	003b68fa 	trap	3
8111284c:	dfc00715 	stw	ra,28(sp)
81112850:	df000615 	stw	fp,24(sp)
81112854:	df000604 	addi	fp,sp,24
81112858:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucFeeInstL;
	static bool bDmaBack;
	static unsigned char ucWhoGetDMA;
	unsigned char ucIL;

	pxFeeC = (TNFee_Control *) task_data;
8111285c:	e0bfff17 	ldw	r2,-4(fp)
81112860:	e0bffb15 	stw	r2,-20(fp)

	#ifdef DEBUG_ON
        debug(fp,"NFee Controller Task. (Task on)\n");
81112864:	d0a06217 	ldw	r2,-32376(gp)
81112868:	100f883a 	mov	r7,r2
8111286c:	01800804 	movi	r6,32
81112870:	01400044 	movi	r5,1
81112874:	01204574 	movhi	r4,33045
81112878:	21343904 	addi	r4,r4,-12060
8111287c:	11216400 	call	81121640 <fwrite>
    #endif

	for (;;) {

		switch (pxFeeC->sMode)
81112880:	e0bffb17 	ldw	r2,-20(fp)
81112884:	10809a17 	ldw	r2,616(r2)
81112888:	10c00168 	cmpgeui	r3,r2,5
8111288c:	1800e81e 	bne	r3,zero,81112c30 <vNFeeControlTask+0x3f0>
81112890:	100690ba 	slli	r3,r2,2
81112894:	00a04474 	movhi	r2,33041
81112898:	108a2a04 	addi	r2,r2,10408
8111289c:	1885883a 	add	r2,r3,r2
811128a0:	10800017 	ldw	r2,0(r2)
811128a4:	1000683a 	jmp	r2
811128a8:	811128bc 	xorhi	r4,r16,17570
811128ac:	811128ec 	andhi	r4,r16,17571
811128b0:	8111294c 	andi	r4,r16,17573
811128b4:	81112a00 	call	881112a0 <__reset+0x20f12a0>
811128b8:	81112a60 	cmpeqi	r4,r16,17577
		{
			case sMebInit:
				/* Starting the NFEE Controller */

				/* Clear in CMD Queue  */
				error_codeCtrl = OSQFlush(xQMaskFeeCtrl);
811128bc:	d0a07017 	ldw	r2,-32320(gp)
811128c0:	1009883a 	mov	r4,r2
811128c4:	113d5080 	call	8113d508 <OSQFlush>
811128c8:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
811128cc:	e0bffe03 	ldbu	r2,-8(fp)
811128d0:	10803fcc 	andi	r2,r2,255
811128d4:	10000126 	beq	r2,zero,811128dc <vNFeeControlTask+0x9c>
					vFailFlushQueue();
811128d8:	111d1680 	call	8111d168 <vFailFlushQueue>
				}

				pxFeeC->sMode = sMebToConfig;
811128dc:	e0bffb17 	ldw	r2,-20(fp)
811128e0:	00c00044 	movi	r3,1
811128e4:	10c09a15 	stw	r3,616(r2)
				break;
811128e8:	0000dd06 	br	81112c60 <vNFeeControlTask+0x420>


			case sMebToConfig:
				/* Transition state */
				#ifdef DEBUG_ON
					debug(fp,"NFEE Controller Task:: Config Mode\n");
811128ec:	d0a06217 	ldw	r2,-32376(gp)
811128f0:	100f883a 	mov	r7,r2
811128f4:	018008c4 	movi	r6,35
811128f8:	01400044 	movi	r5,1
811128fc:	01204574 	movhi	r4,33045
81112900:	21344204 	addi	r4,r4,-12024
81112904:	11216400 	call	81121640 <fwrite>
				#endif

				/* Clear Queue that is responsible to schedule the DMA access */
				error_codeCtrl = OSQFlush(xNfeeSchedule);
81112908:	d0a05d17 	ldw	r2,-32396(gp)
8111290c:	1009883a 	mov	r4,r2
81112910:	113d5080 	call	8113d508 <OSQFlush>
81112914:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
81112918:	e0bffe03 	ldbu	r2,-8(fp)
8111291c:	10803fcc 	andi	r2,r2,255
81112920:	10000126 	beq	r2,zero,81112928 <vNFeeControlTask+0xe8>
					vFailFlushQueue();
81112924:	111d1680 	call	8111d168 <vFailFlushQueue>
				}

				bCmdSent = FALSE;
81112928:	e03ffc15 	stw	zero,-16(fp)
				bDmaBack = TRUE;
8111292c:	00800044 	movi	r2,1
81112930:	d0a05815 	stw	r2,-32416(gp)
				ucWhoGetDMA = 255;
81112934:	00bfffc4 	movi	r2,-1
81112938:	d0a05905 	stb	r2,-32412(gp)
				pxFeeC->sMode = sMebConfig;
8111293c:	e0bffb17 	ldw	r2,-20(fp)
81112940:	00c000c4 	movi	r3,3
81112944:	10c09a15 	stw	r3,616(r2)
				break;
81112948:	0000c506 	br	81112c60 <vNFeeControlTask+0x420>


			case sMebToRun:
				/* Transition state */
				vEvtChangeFeeControllerMode();
8111294c:	111d2c00 	call	8111d2c0 <vEvtChangeFeeControllerMode>
				#ifdef DEBUG_ON
					debug(fp,"NFEE Controller Task:: RUN Mode\n");
81112950:	d0a06217 	ldw	r2,-32376(gp)
81112954:	100f883a 	mov	r7,r2
81112958:	01800804 	movi	r6,32
8111295c:	01400044 	movi	r5,1
81112960:	01204574 	movhi	r4,33045
81112964:	21344b04 	addi	r4,r4,-11988
81112968:	11216400 	call	81121640 <fwrite>
				#endif

				/* Clear Queue that is responsible to schedule the DMA access */
				error_codeCtrl = OSQFlush(xNfeeSchedule);
8111296c:	d0a05d17 	ldw	r2,-32396(gp)
81112970:	1009883a 	mov	r4,r2
81112974:	113d5080 	call	8113d508 <OSQFlush>
81112978:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
8111297c:	e0bffe03 	ldbu	r2,-8(fp)
81112980:	10803fcc 	andi	r2,r2,255
81112984:	10000126 	beq	r2,zero,8111298c <vNFeeControlTask+0x14c>
					vFailFlushQueue();
81112988:	111d1680 	call	8111d168 <vFailFlushQueue>
				}

				/* Clear message that maybe is in the FEEs Queues */
				for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++)
8111298c:	e03ffa45 	stb	zero,-23(fp)
81112990:	00001006 	br	811129d4 <vNFeeControlTask+0x194>
				{
					error_codeCtrl = OSQFlush( xFeeQ[ ucIL ] );
81112994:	e0bffa43 	ldbu	r2,-23(fp)
81112998:	1085883a 	add	r2,r2,r2
8111299c:	1087883a 	add	r3,r2,r2
811129a0:	d0a06a04 	addi	r2,gp,-32344
811129a4:	1885883a 	add	r2,r3,r2
811129a8:	10800017 	ldw	r2,0(r2)
811129ac:	1009883a 	mov	r4,r2
811129b0:	113d5080 	call	8113d508 <OSQFlush>
811129b4:	e0bffe05 	stb	r2,-8(fp)
					if ( error_codeCtrl != OS_NO_ERR ) {
811129b8:	e0bffe03 	ldbu	r2,-8(fp)
811129bc:	10803fcc 	andi	r2,r2,255
811129c0:	10000126 	beq	r2,zero,811129c8 <vNFeeControlTask+0x188>
						vFailFlushQueue();
811129c4:	111d1680 	call	8111d168 <vFailFlushQueue>
				if ( error_codeCtrl != OS_NO_ERR ) {
					vFailFlushQueue();
				}

				/* Clear message that maybe is in the FEEs Queues */
				for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++)
811129c8:	e0bffa43 	ldbu	r2,-23(fp)
811129cc:	10800044 	addi	r2,r2,1
811129d0:	e0bffa45 	stb	r2,-23(fp)
811129d4:	e0bffa43 	ldbu	r2,-23(fp)
811129d8:	103fee26 	beq	r2,zero,81112994 <__reset+0xfb0f2994>
					if ( error_codeCtrl != OS_NO_ERR ) {
						vFailFlushQueue();
					}
				}

				bCmdSent = FALSE;
811129dc:	e03ffc15 	stw	zero,-16(fp)
				bDmaBack = TRUE;
811129e0:	00800044 	movi	r2,1
811129e4:	d0a05815 	stw	r2,-32416(gp)
				ucWhoGetDMA = 255;
811129e8:	00bfffc4 	movi	r2,-1
811129ec:	d0a05905 	stb	r2,-32412(gp)
				pxFeeC->sMode = sMebRun;
811129f0:	e0bffb17 	ldw	r2,-20(fp)
811129f4:	00c00104 	movi	r3,4
811129f8:	10c09a15 	stw	r3,616(r2)
				break;
811129fc:	00009806 	br	81112c60 <vNFeeControlTask+0x420>


			case sMebConfig:
				
				uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 0, &error_codeCtrl); /* Blocking operation */
81112a00:	d0a07017 	ldw	r2,-32320(gp)
81112a04:	e0fffe04 	addi	r3,fp,-8
81112a08:	180d883a 	mov	r6,r3
81112a0c:	000b883a 	mov	r5,zero
81112a10:	1009883a 	mov	r4,r2
81112a14:	113d5c80 	call	8113d5c8 <OSQPend>
81112a18:	e0bffd15 	stw	r2,-12(fp)
				if ( error_codeCtrl == OS_ERR_NONE ) {
81112a1c:	e0bffe03 	ldbu	r2,-8(fp)
81112a20:	10803fcc 	andi	r2,r2,255
81112a24:	10000c1e 	bne	r2,zero,81112a58 <vNFeeControlTask+0x218>

					/* Check if the command is for NFEE Controller */
					if ( uiCmdNFC.ucByte[3] == M_FEE_CTRL_ADDR ) {
81112a28:	e0bffdc3 	ldbu	r2,-9(fp)
81112a2c:	10803fcc 	andi	r2,r2,255
81112a30:	10800418 	cmpnei	r2,r2,16
81112a34:	1000041e 	bne	r2,zero,81112a48 <vNFeeControlTask+0x208>
						
						vPerformActionNFCConfig(uiCmdNFC.ulWord, pxFeeC);
81112a38:	e0bffd17 	ldw	r2,-12(fp)
81112a3c:	e17ffb17 	ldw	r5,-20(fp)
81112a40:	1009883a 	mov	r4,r2
81112a44:	1112c640 	call	81112c64 <vPerformActionNFCConfig>

					};
					bCmdSent = FALSE;
81112a48:	e03ffc15 	stw	zero,-16(fp)
					bDmaBack = TRUE;
81112a4c:	00800044 	movi	r2,1
81112a50:	d0a05815 	stw	r2,-32416(gp)
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetQueueMaskNfeeCtrl();
				}
				break;
81112a54:	00008206 	br	81112c60 <vNFeeControlTask+0x420>
					};
					bCmdSent = FALSE;
					bDmaBack = TRUE;
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetQueueMaskNfeeCtrl();
81112a58:	111cdbc0 	call	8111cdbc <vCouldNotGetQueueMaskNfeeCtrl>
				}
				break;
81112a5c:	00008006 	br	81112c60 <vNFeeControlTask+0x420>
					xQMaskFeeCtrl is How NFEE Controller receive Commands in a fat way and 
					xNfeeSchedule that has the schedule of access to the DMA (this has priority)*/
				

				/* Get the id of the FEE that wants DMA access */
				if ( bDmaBack == TRUE ) {
81112a60:	d0a05817 	ldw	r2,-32416(gp)
81112a64:	10800058 	cmpnei	r2,r2,1
81112a68:	1000221e 	bne	r2,zero,81112af4 <vNFeeControlTask+0x2b4>

					uiCmdNFC.ulWord = (unsigned int)OSQPend(xNfeeSchedule, 4, &error_codeCtrl);
81112a6c:	d0a05d17 	ldw	r2,-32396(gp)
81112a70:	e0fffe04 	addi	r3,fp,-8
81112a74:	180d883a 	mov	r6,r3
81112a78:	01400104 	movi	r5,4
81112a7c:	1009883a 	mov	r4,r2
81112a80:	113d5c80 	call	8113d5c8 <OSQPend>
81112a84:	e0bffd15 	stw	r2,-12(fp)
					if ( error_codeCtrl == OS_ERR_NONE ) {
81112a88:	e0bffe03 	ldbu	r2,-8(fp)
81112a8c:	10803fcc 	andi	r2,r2,255
81112a90:	1000181e 	bne	r2,zero,81112af4 <vNFeeControlTask+0x2b4>
						ucFeeInstL = uiCmdNFC.ucByte[0];
81112a94:	e0bffd03 	ldbu	r2,-12(fp)
81112a98:	e0bffa05 	stb	r2,-24(fp)


						if (  pxFeeC->xNfee[ucFeeInstL].xControl.bUsingDMA == TRUE ) {
81112a9c:	e0bffa03 	ldbu	r2,-24(fp)
81112aa0:	e0fffb17 	ldw	r3,-20(fp)
81112aa4:	10809624 	muli	r2,r2,600
81112aa8:	1885883a 	add	r2,r3,r2
81112aac:	10802304 	addi	r2,r2,140
81112ab0:	10800017 	ldw	r2,0(r2)
81112ab4:	10800058 	cmpnei	r2,r2,1
81112ab8:	10000e1e 	bne	r2,zero,81112af4 <vNFeeControlTask+0x2b4>
							bCmdSent = bSendCmdQToNFeeInst( ucFeeInstL, M_FEE_DMA_ACCESS, 0, ucFeeInstL );
81112abc:	e0bffa03 	ldbu	r2,-24(fp)
81112ac0:	e0fffa03 	ldbu	r3,-24(fp)
81112ac4:	180f883a 	mov	r7,r3
81112ac8:	000d883a 	mov	r6,zero
81112acc:	014023c4 	movi	r5,143
81112ad0:	1009883a 	mov	r4,r2
81112ad4:	1112e540 	call	81112e54 <bSendCmdQToNFeeInst>
81112ad8:	e0bffc15 	stw	r2,-16(fp)
							if ( bCmdSent == TRUE ) {
81112adc:	e0bffc17 	ldw	r2,-16(fp)
81112ae0:	10800058 	cmpnei	r2,r2,1
81112ae4:	1000031e 	bne	r2,zero,81112af4 <vNFeeControlTask+0x2b4>
								bDmaBack = FALSE;
81112ae8:	d0205815 	stw	zero,-32416(gp)
								ucWhoGetDMA = ucFeeInstL;
81112aec:	e0bffa03 	ldbu	r2,-24(fp)
81112af0:	d0a05905 	stb	r2,-32412(gp)
							}
						}
					}
				} 

				if ( bDmaBack == FALSE ) {
81112af4:	d0a05817 	ldw	r2,-32416(gp)
81112af8:	1000081e 	bne	r2,zero,81112b1c <vNFeeControlTask+0x2dc>

					/* DMA with some NFEE instance */
					uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 0, &error_codeCtrl);
81112afc:	d0a07017 	ldw	r2,-32320(gp)
81112b00:	e0fffe04 	addi	r3,fp,-8
81112b04:	180d883a 	mov	r6,r3
81112b08:	000b883a 	mov	r5,zero
81112b0c:	1009883a 	mov	r4,r2
81112b10:	113d5c80 	call	8113d5c8 <OSQPend>
81112b14:	e0bffd15 	stw	r2,-12(fp)
81112b18:	00000706 	br	81112b38 <vNFeeControlTask+0x2f8>
				} else {
					/* If No FEE has the DMA */

					uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 4, &error_codeCtrl);
81112b1c:	d0a07017 	ldw	r2,-32320(gp)
81112b20:	e0fffe04 	addi	r3,fp,-8
81112b24:	180d883a 	mov	r6,r3
81112b28:	01400104 	movi	r5,4
81112b2c:	1009883a 	mov	r4,r2
81112b30:	113d5c80 	call	8113d5c8 <OSQPend>
81112b34:	e0bffd15 	stw	r2,-12(fp)
				}

				if ( error_codeCtrl == OS_ERR_NONE ){
81112b38:	e0bffe03 	ldbu	r2,-8(fp)
81112b3c:	10803fcc 	andi	r2,r2,255
81112b40:	10002c1e 	bne	r2,zero,81112bf4 <vNFeeControlTask+0x3b4>
					/* Check if is some FEE giving the DMA back */
					if ( uiCmdNFC.ucByte[2] == M_NFC_DMA_GIVEBACK ) {
81112b44:	e0bffd83 	ldbu	r2,-10(fp)
81112b48:	10803fcc 	andi	r2,r2,255
81112b4c:	10802058 	cmpnei	r2,r2,129
81112b50:	1000091e 	bne	r2,zero,81112b78 <vNFeeControlTask+0x338>
						if ( uiCmdNFC.ucByte[0] == ucFeeInstL ){
81112b54:	e0bffd03 	ldbu	r2,-12(fp)
81112b58:	10c03fcc 	andi	r3,r2,255
81112b5c:	e0bffa03 	ldbu	r2,-24(fp)
81112b60:	1880241e 	bne	r3,r2,81112bf4 <vNFeeControlTask+0x3b4>
							bDmaBack = TRUE;
81112b64:	00800044 	movi	r2,1
81112b68:	d0a05815 	stw	r2,-32416(gp)
							ucFeeInstL = 255;
81112b6c:	00bfffc4 	movi	r2,-1
81112b70:	e0bffa05 	stb	r2,-24(fp)
81112b74:	00001f06 	br	81112bf4 <vNFeeControlTask+0x3b4>
						}

					} else {

						/* Check if the command is for NFEE Controller */
						if ( uiCmdNFC.ucByte[3] == M_FEE_CTRL_ADDR ) {
81112b78:	e0bffdc3 	ldbu	r2,-9(fp)
81112b7c:	10803fcc 	andi	r2,r2,255
81112b80:	10800418 	cmpnei	r2,r2,16
81112b84:	1000051e 	bne	r2,zero,81112b9c <vNFeeControlTask+0x35c>
							
							vPerformActionNFCRunning(uiCmdNFC.ulWord, pxFeeC);
81112b88:	e0bffd17 	ldw	r2,-12(fp)
81112b8c:	e17ffb17 	ldw	r5,-20(fp)
81112b90:	1009883a 	mov	r4,r2
81112b94:	1112d2c0 	call	81112d2c <vPerformActionNFCRunning>
81112b98:	00001606 	br	81112bf4 <vNFeeControlTask+0x3b4>

						} else {
							/* Check if the message if for any one of the instances of NFEE */
							if ( (uiCmdNFC.ucByte[3] >= M_NFEE_BASE_ADDR) && ( uiCmdNFC.ucByte[3] <= (M_NFEE_BASE_ADDR+N_OF_NFEE) ) ) {
81112b9c:	e0bffdc3 	ldbu	r2,-9(fp)
81112ba0:	10803fcc 	andi	r2,r2,255
81112ba4:	10800470 	cmpltui	r2,r2,17
81112ba8:	1000121e 	bne	r2,zero,81112bf4 <vNFeeControlTask+0x3b4>
81112bac:	e0bffdc3 	ldbu	r2,-9(fp)
81112bb0:	10803fcc 	andi	r2,r2,255
81112bb4:	108004e8 	cmpgeui	r2,r2,19
81112bb8:	10000e1e 	bne	r2,zero,81112bf4 <vNFeeControlTask+0x3b4>

								//todo: tratar retorno
								bSendCmdQToNFeeInst( (uiCmdNFC.ucByte[3]-M_NFEE_BASE_ADDR), uiCmdNFC.ucByte[2], uiCmdNFC.ucByte[1], uiCmdNFC.ucByte[0] );
81112bbc:	e0bffdc3 	ldbu	r2,-9(fp)
81112bc0:	10bffbc4 	addi	r2,r2,-17
81112bc4:	10803fcc 	andi	r2,r2,255
81112bc8:	e0fffd83 	ldbu	r3,-10(fp)
81112bcc:	18c03fcc 	andi	r3,r3,255
81112bd0:	e13ffd43 	ldbu	r4,-11(fp)
81112bd4:	21003fcc 	andi	r4,r4,255
81112bd8:	e17ffd03 	ldbu	r5,-12(fp)
81112bdc:	29403fcc 	andi	r5,r5,255
81112be0:	280f883a 	mov	r7,r5
81112be4:	200d883a 	mov	r6,r4
81112be8:	180b883a 	mov	r5,r3
81112bec:	1009883a 	mov	r4,r2
81112bf0:	1112e540 	call	81112e54 <bSendCmdQToNFeeInst>

							}
						}
					}
				}
				if ( xDefaults.usiDelay == 0 ) {
81112bf4:	00a045b4 	movhi	r2,33046
81112bf8:	1099c904 	addi	r2,r2,26404
81112bfc:	1080070b 	ldhu	r2,28(r2)
81112c00:	10bfffcc 	andi	r2,r2,65535
81112c04:	1000151e 	bne	r2,zero,81112c5c <vNFeeControlTask+0x41c>
					OSTimeDlyHMSM(0,0,0,xDefaults.usiDelay); /*remover depois dos testes !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
81112c08:	00a045b4 	movhi	r2,33046
81112c0c:	1099c904 	addi	r2,r2,26404
81112c10:	1080070b 	ldhu	r2,28(r2)
81112c14:	10bfffcc 	andi	r2,r2,65535
81112c18:	100f883a 	mov	r7,r2
81112c1c:	000d883a 	mov	r6,zero
81112c20:	000b883a 	mov	r5,zero
81112c24:	0009883a 	mov	r4,zero
81112c28:	11404580 	call	81140458 <OSTimeDlyHMSM>
				}
				
				break;		
81112c2c:	00000b06 	br	81112c5c <vNFeeControlTask+0x41c>
			default:
				#ifdef DEBUG_ON
					debug(fp,"NFEE Controller Task: Unknown state, backing to Config Mode.\n");
81112c30:	d0a06217 	ldw	r2,-32376(gp)
81112c34:	100f883a 	mov	r7,r2
81112c38:	01800f44 	movi	r6,61
81112c3c:	01400044 	movi	r5,1
81112c40:	01204574 	movhi	r4,33045
81112c44:	21345404 	addi	r4,r4,-11952
81112c48:	11216400 	call	81121640 <fwrite>
				#endif
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxFeeC->sMode = sMebConfig;
81112c4c:	e0bffb17 	ldw	r2,-20(fp)
81112c50:	00c000c4 	movi	r3,3
81112c54:	10c09a15 	stw	r3,616(r2)
				break;
81112c58:	00000106 	br	81112c60 <vNFeeControlTask+0x420>
				}
				if ( xDefaults.usiDelay == 0 ) {
					OSTimeDlyHMSM(0,0,0,xDefaults.usiDelay); /*remover depois dos testes !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
				}
				
				break;		
81112c5c:	0001883a 	nop
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxFeeC->sMode = sMebConfig;
				break;
		}
	}
81112c60:	003f0706 	br	81112880 <__reset+0xfb0f2880>

81112c64 <vPerformActionNFCConfig>:
}


void vPerformActionNFCConfig( unsigned int uiCmdParam, TNFee_Control *pxFeeCP ) {
81112c64:	defffb04 	addi	sp,sp,-20
81112c68:	de00012e 	bgeu	sp,et,81112c70 <vPerformActionNFCConfig+0xc>
81112c6c:	003b68fa 	trap	3
81112c70:	dfc00415 	stw	ra,16(sp)
81112c74:	df000315 	stw	fp,12(sp)
81112c78:	df000304 	addi	fp,sp,12
81112c7c:	e13ffe15 	stw	r4,-8(fp)
81112c80:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdLocal;
	INT8U errorCodeL;
	unsigned char i;

	uiCmdLocal.ulWord = uiCmdParam;
81112c84:	e0bffe17 	ldw	r2,-8(fp)
81112c88:	e0bffd15 	stw	r2,-12(fp)

	switch (uiCmdLocal.ucByte[2]) {
81112c8c:	e0bffd83 	ldbu	r2,-10(fp)
81112c90:	10803fcc 	andi	r2,r2,255
81112c94:	10c000a0 	cmpeqi	r3,r2,2
81112c98:	1800121e 	bne	r3,zero,81112ce4 <vPerformActionNFCConfig+0x80>
81112c9c:	10c000c8 	cmpgei	r3,r2,3
81112ca0:	1800031e 	bne	r3,zero,81112cb0 <vPerformActionNFCConfig+0x4c>
81112ca4:	10800060 	cmpeqi	r2,r2,1
81112ca8:	1000061e 	bne	r2,zero,81112cc4 <vPerformActionNFCConfig+0x60>
81112cac:	00001106 	br	81112cf4 <vPerformActionNFCConfig+0x90>
81112cb0:	10c02860 	cmpeqi	r3,r2,161
81112cb4:	1800031e 	bne	r3,zero,81112cc4 <vPerformActionNFCConfig+0x60>
81112cb8:	108028a0 	cmpeqi	r2,r2,162
81112cbc:	1000091e 	bne	r2,zero,81112ce4 <vPerformActionNFCConfig+0x80>
81112cc0:	00000c06 	br	81112cf4 <vPerformActionNFCConfig+0x90>
		case M_NFC_CONFIG_FORCED:
		case M_NFC_CONFIG:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: NFC already in the Config Mode\n");
81112cc4:	d0a06217 	ldw	r2,-32376(gp)
81112cc8:	100f883a 	mov	r7,r2
81112ccc:	01800d44 	movi	r6,53
81112cd0:	01400044 	movi	r5,1
81112cd4:	01204574 	movhi	r4,33045
81112cd8:	21346404 	addi	r4,r4,-11888
81112cdc:	11216400 	call	81121640 <fwrite>
			#endif
			/* Do nothing for now */
			break;
81112ce0:	00000c06 	br	81112d14 <vPerformActionNFCConfig+0xb0>

		case M_NFC_RUN_FORCED:
		case M_NFC_RUN:
			pxFeeCP->sMode = sMebToRun;
81112ce4:	e0bfff17 	ldw	r2,-4(fp)
81112ce8:	00c00084 	movi	r3,2
81112cec:	10c09a15 	stw	r3,616(r2)
			break;
81112cf0:	00000806 	br	81112d14 <vPerformActionNFCConfig+0xb0>
		case M_NFC_DMA_GIVEBACK:
		case M_NFC_DMA_REQUEST:

		default:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
81112cf4:	d0a06217 	ldw	r2,-32376(gp)
81112cf8:	100f883a 	mov	r7,r2
81112cfc:	018009c4 	movi	r6,39
81112d00:	01400044 	movi	r5,1
81112d04:	01204574 	movhi	r4,33045
81112d08:	21347204 	addi	r4,r4,-11832
81112d0c:	11216400 	call	81121640 <fwrite>
			#endif	
			break;
81112d10:	0001883a 	nop
	}

}
81112d14:	0001883a 	nop
81112d18:	e037883a 	mov	sp,fp
81112d1c:	dfc00117 	ldw	ra,4(sp)
81112d20:	df000017 	ldw	fp,0(sp)
81112d24:	dec00204 	addi	sp,sp,8
81112d28:	f800283a 	ret

81112d2c <vPerformActionNFCRunning>:

void vPerformActionNFCRunning( unsigned int uiCmdParam, TNFee_Control *pxFeeCP ) {
81112d2c:	defffa04 	addi	sp,sp,-24
81112d30:	de00012e 	bgeu	sp,et,81112d38 <vPerformActionNFCRunning+0xc>
81112d34:	003b68fa 	trap	3
81112d38:	dfc00515 	stw	ra,20(sp)
81112d3c:	df000415 	stw	fp,16(sp)
81112d40:	df000404 	addi	fp,sp,16
81112d44:	e13ffe15 	stw	r4,-8(fp)
81112d48:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdLocal;
	unsigned char i;
	bool bCheckSimulation;

	uiCmdLocal.ulWord = uiCmdParam;
81112d4c:	e0bffe17 	ldw	r2,-8(fp)
81112d50:	e0bffd15 	stw	r2,-12(fp)

	switch (uiCmdLocal.ucByte[2]) {
81112d54:	e0bffd83 	ldbu	r2,-10(fp)
81112d58:	10803fcc 	andi	r2,r2,255
81112d5c:	10c02088 	cmpgei	r3,r2,130
81112d60:	1800071e 	bne	r3,zero,81112d80 <vPerformActionNFCRunning+0x54>
81112d64:	10c02008 	cmpgei	r3,r2,128
81112d68:	1800331e 	bne	r3,zero,81112e38 <vPerformActionNFCRunning+0x10c>
81112d6c:	10c00060 	cmpeqi	r3,r2,1
81112d70:	1800051e 	bne	r3,zero,81112d88 <vPerformActionNFCRunning+0x5c>
81112d74:	108000a0 	cmpeqi	r2,r2,2
81112d78:	10001f1e 	bne	r2,zero,81112df8 <vPerformActionNFCRunning+0xcc>
81112d7c:	00002606 	br	81112e18 <vPerformActionNFCRunning+0xec>
81112d80:	10802860 	cmpeqi	r2,r2,161
81112d84:	10002426 	beq	r2,zero,81112e18 <vPerformActionNFCRunning+0xec>
		case M_NFC_CONFIG:
		case M_NFC_CONFIG_FORCED:

			pxFeeCP->sMode = sMebToConfig;
81112d88:	e0bfff17 	ldw	r2,-4(fp)
81112d8c:	00c00044 	movi	r3,1
81112d90:	10c09a15 	stw	r3,616(r2)

			/* Change all NFEEs to Config mode */
			for( i = 0; i < N_OF_NFEE; i++)
81112d94:	e03ffc05 	stb	zero,-16(fp)
81112d98:	00001406 	br	81112dec <vPerformActionNFCRunning+0xc0>
			{
				if ( (*pxFeeCP->pbEnabledNFEEs[i]) == TRUE ) {
81112d9c:	e0bffc03 	ldbu	r2,-16(fp)
81112da0:	e0ffff17 	ldw	r3,-4(fp)
81112da4:	108025c4 	addi	r2,r2,151
81112da8:	1085883a 	add	r2,r2,r2
81112dac:	1085883a 	add	r2,r2,r2
81112db0:	1885883a 	add	r2,r3,r2
81112db4:	10800017 	ldw	r2,0(r2)
81112db8:	10800017 	ldw	r2,0(r2)
81112dbc:	10800058 	cmpnei	r2,r2,1
81112dc0:	1000071e 	bne	r2,zero,81112de0 <vPerformActionNFCRunning+0xb4>
					bSendCmdQToNFeeInst_Prio( i, M_FEE_CONFIG_FORCED, 0, i  );
81112dc4:	e0bffc03 	ldbu	r2,-16(fp)
81112dc8:	e0fffc03 	ldbu	r3,-16(fp)
81112dcc:	180f883a 	mov	r7,r3
81112dd0:	000d883a 	mov	r6,zero
81112dd4:	01402844 	movi	r5,161
81112dd8:	1009883a 	mov	r4,r2
81112ddc:	1112f1c0 	call	81112f1c <bSendCmdQToNFeeInst_Prio>
		case M_NFC_CONFIG_FORCED:

			pxFeeCP->sMode = sMebToConfig;

			/* Change all NFEEs to Config mode */
			for( i = 0; i < N_OF_NFEE; i++)
81112de0:	e0bffc03 	ldbu	r2,-16(fp)
81112de4:	10800044 	addi	r2,r2,1
81112de8:	e0bffc05 	stb	r2,-16(fp)
81112dec:	e0bffc03 	ldbu	r2,-16(fp)
81112df0:	103fea26 	beq	r2,zero,81112d9c <__reset+0xfb0f2d9c>
				if ( (*pxFeeCP->pbEnabledNFEEs[i]) == TRUE ) {
					bSendCmdQToNFeeInst_Prio( i, M_FEE_CONFIG_FORCED, 0, i  );
				}
			}

			break;
81112df4:	00001106 	br	81112e3c <vPerformActionNFCRunning+0x110>
		case M_NFC_RUN:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: NFC already in the Running Mode\n");
81112df8:	d0a06217 	ldw	r2,-32376(gp)
81112dfc:	100f883a 	mov	r7,r2
81112e00:	01800d84 	movi	r6,54
81112e04:	01400044 	movi	r5,1
81112e08:	01204574 	movhi	r4,33045
81112e0c:	21347c04 	addi	r4,r4,-11792
81112e10:	11216400 	call	81121640 <fwrite>
			#endif		
			/* Do nothing for now */

			break;
81112e14:	00000906 	br	81112e3c <vPerformActionNFCRunning+0x110>
		case M_NFC_DMA_GIVEBACK:
		case M_NFC_DMA_REQUEST:
			break;
		default:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
81112e18:	d0a06217 	ldw	r2,-32376(gp)
81112e1c:	100f883a 	mov	r7,r2
81112e20:	018009c4 	movi	r6,39
81112e24:	01400044 	movi	r5,1
81112e28:	01204574 	movhi	r4,33045
81112e2c:	21347204 	addi	r4,r4,-11832
81112e30:	11216400 	call	81121640 <fwrite>
			#endif	
			break;
81112e34:	00000106 	br	81112e3c <vPerformActionNFCRunning+0x110>
			/* Do nothing for now */

			break;
		case M_NFC_DMA_GIVEBACK:
		case M_NFC_DMA_REQUEST:
			break;
81112e38:	0001883a 	nop
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
			#endif	
			break;
	}
}
81112e3c:	0001883a 	nop
81112e40:	e037883a 	mov	sp,fp
81112e44:	dfc00117 	ldw	ra,4(sp)
81112e48:	df000017 	ldw	fp,0(sp)
81112e4c:	dec00204 	addi	sp,sp,8
81112e50:	f800283a 	ret

81112e54 <bSendCmdQToNFeeInst>:


bool bSendCmdQToNFeeInst( unsigned char ucFeeInstP, unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81112e54:	defff704 	addi	sp,sp,-36
81112e58:	de00012e 	bgeu	sp,et,81112e60 <bSendCmdQToNFeeInst+0xc>
81112e5c:	003b68fa 	trap	3
81112e60:	dfc00815 	stw	ra,32(sp)
81112e64:	df000715 	stw	fp,28(sp)
81112e68:	df000704 	addi	fp,sp,28
81112e6c:	2011883a 	mov	r8,r4
81112e70:	2809883a 	mov	r4,r5
81112e74:	3007883a 	mov	r3,r6
81112e78:	3805883a 	mov	r2,r7
81112e7c:	e23ffc05 	stb	r8,-16(fp)
81112e80:	e13ffd05 	stb	r4,-12(fp)
81112e84:	e0fffe05 	stb	r3,-8(fp)
81112e88:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucFeeInstP;
81112e8c:	e0bffc03 	ldbu	r2,-16(fp)
81112e90:	10800444 	addi	r2,r2,17
81112e94:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81112e98:	e0bffd03 	ldbu	r2,-12(fp)
81112e9c:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81112ea0:	e0bffe03 	ldbu	r2,-8(fp)
81112ea4:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81112ea8:	e0bfff03 	ldbu	r2,-4(fp)
81112eac:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
81112eb0:	e03ff915 	stw	zero,-28(fp)
	error_codel = OSQPost(xFeeQ[ ucFeeInstP ], (void *)uiCmdtoSend.ulWord);
81112eb4:	e0bffc03 	ldbu	r2,-16(fp)
81112eb8:	1085883a 	add	r2,r2,r2
81112ebc:	1087883a 	add	r3,r2,r2
81112ec0:	d0a06a04 	addi	r2,gp,-32344
81112ec4:	1885883a 	add	r2,r3,r2
81112ec8:	10800017 	ldw	r2,0(r2)
81112ecc:	e0fffb17 	ldw	r3,-20(fp)
81112ed0:	180b883a 	mov	r5,r3
81112ed4:	1009883a 	mov	r4,r2
81112ed8:	113d9d00 	call	8113d9d0 <OSQPost>
81112edc:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
81112ee0:	e0bffa03 	ldbu	r2,-24(fp)
81112ee4:	10000526 	beq	r2,zero,81112efc <bSendCmdQToNFeeInst+0xa8>
		vFailSendMsgAccessDMA( ucFeeInstP );
81112ee8:	e0bffc03 	ldbu	r2,-16(fp)
81112eec:	1009883a 	mov	r4,r2
81112ef0:	111ce8c0 	call	8111ce8c <vFailSendMsgAccessDMA>
		bSuccesL = FALSE;
81112ef4:	e03ff915 	stw	zero,-28(fp)
81112ef8:	00000206 	br	81112f04 <bSendCmdQToNFeeInst+0xb0>
	} else {
		bSuccesL =  TRUE;
81112efc:	00800044 	movi	r2,1
81112f00:	e0bff915 	stw	r2,-28(fp)
	}

	return bSuccesL;
81112f04:	e0bff917 	ldw	r2,-28(fp)
}
81112f08:	e037883a 	mov	sp,fp
81112f0c:	dfc00117 	ldw	ra,4(sp)
81112f10:	df000017 	ldw	fp,0(sp)
81112f14:	dec00204 	addi	sp,sp,8
81112f18:	f800283a 	ret

81112f1c <bSendCmdQToNFeeInst_Prio>:


bool bSendCmdQToNFeeInst_Prio( unsigned char ucFeeInstP, unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81112f1c:	defff704 	addi	sp,sp,-36
81112f20:	de00012e 	bgeu	sp,et,81112f28 <bSendCmdQToNFeeInst_Prio+0xc>
81112f24:	003b68fa 	trap	3
81112f28:	dfc00815 	stw	ra,32(sp)
81112f2c:	df000715 	stw	fp,28(sp)
81112f30:	df000704 	addi	fp,sp,28
81112f34:	2011883a 	mov	r8,r4
81112f38:	2809883a 	mov	r4,r5
81112f3c:	3007883a 	mov	r3,r6
81112f40:	3805883a 	mov	r2,r7
81112f44:	e23ffc05 	stb	r8,-16(fp)
81112f48:	e13ffd05 	stb	r4,-12(fp)
81112f4c:	e0fffe05 	stb	r3,-8(fp)
81112f50:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucFeeInstP;
81112f54:	e0bffc03 	ldbu	r2,-16(fp)
81112f58:	10800444 	addi	r2,r2,17
81112f5c:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81112f60:	e0bffd03 	ldbu	r2,-12(fp)
81112f64:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81112f68:	e0bffe03 	ldbu	r2,-8(fp)
81112f6c:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81112f70:	e0bfff03 	ldbu	r2,-4(fp)
81112f74:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
81112f78:	e03ff915 	stw	zero,-28(fp)
	error_codel = OSQPostFront(xFeeQ[ ucFeeInstP ], (void *)uiCmdtoSend.ulWord);
81112f7c:	e0bffc03 	ldbu	r2,-16(fp)
81112f80:	1085883a 	add	r2,r2,r2
81112f84:	1087883a 	add	r3,r2,r2
81112f88:	d0a06a04 	addi	r2,gp,-32344
81112f8c:	1885883a 	add	r2,r3,r2
81112f90:	10800017 	ldw	r2,0(r2)
81112f94:	e0fffb17 	ldw	r3,-20(fp)
81112f98:	180b883a 	mov	r5,r3
81112f9c:	1009883a 	mov	r4,r2
81112fa0:	113db400 	call	8113db40 <OSQPostFront>
81112fa4:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
81112fa8:	e0bffa03 	ldbu	r2,-24(fp)
81112fac:	10000526 	beq	r2,zero,81112fc4 <bSendCmdQToNFeeInst_Prio+0xa8>
		vFailSendMsgAccessDMA( ucFeeInstP );
81112fb0:	e0bffc03 	ldbu	r2,-16(fp)
81112fb4:	1009883a 	mov	r4,r2
81112fb8:	111ce8c0 	call	8111ce8c <vFailSendMsgAccessDMA>
		bSuccesL = FALSE;
81112fbc:	e03ff915 	stw	zero,-28(fp)
81112fc0:	00000206 	br	81112fcc <bSendCmdQToNFeeInst_Prio+0xb0>
	} else {
		bSuccesL =  TRUE;
81112fc4:	00800044 	movi	r2,1
81112fc8:	e0bff915 	stw	r2,-28(fp)
	}

	return bSuccesL;
81112fcc:	e0bff917 	ldw	r2,-28(fp)
}
81112fd0:	e037883a 	mov	sp,fp
81112fd4:	dfc00117 	ldw	ra,4(sp)
81112fd8:	df000017 	ldw	fp,0(sp)
81112fdc:	dec00204 	addi	sp,sp,8
81112fe0:	f800283a 	ret

81112fe4 <vOutAckHandlerTask>:
 */

#include "out_ack_handler_task.h"


void vOutAckHandlerTask(void *task_data) {
81112fe4:	defff704 	addi	sp,sp,-36
81112fe8:	de00012e 	bgeu	sp,et,81112ff0 <vOutAckHandlerTask+0xc>
81112fec:	003b68fa 	trap	3
81112ff0:	dfc00815 	stw	ra,32(sp)
81112ff4:	df000715 	stw	fp,28(sp)
81112ff8:	df000704 	addi	fp,sp,28
81112ffc:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;
	tSerderACKState eSenderAckState;
	static txSenderACKs xSAckLocal;
    char cBufferAck[16] = "";
81113000:	e03ffac5 	stb	zero,-21(fp)
81113004:	e03ffb05 	stb	zero,-20(fp)
81113008:	e03ffb45 	stb	zero,-19(fp)
8111300c:	e03ffb85 	stb	zero,-18(fp)
81113010:	e03ffbc5 	stb	zero,-17(fp)
81113014:	e03ffc05 	stb	zero,-16(fp)
81113018:	e03ffc45 	stb	zero,-15(fp)
8111301c:	e03ffc85 	stb	zero,-14(fp)
81113020:	e03ffcc5 	stb	zero,-13(fp)
81113024:	e03ffd05 	stb	zero,-12(fp)
81113028:	e03ffd45 	stb	zero,-11(fp)
8111302c:	e03ffd85 	stb	zero,-10(fp)
81113030:	e03ffdc5 	stb	zero,-9(fp)
81113034:	e03ffe05 	stb	zero,-8(fp)
81113038:	e03ffe45 	stb	zero,-7(fp)
8111303c:	e03ffe85 	stb	zero,-6(fp)
    unsigned char crc = 0;
81113040:	e03ffa45 	stb	zero,-23(fp)

	#ifdef DEBUG_ON
		debug(fp,"Out Ack Handler Task. (Task on)\n");
81113044:	d0a06217 	ldw	r2,-32376(gp)
81113048:	100f883a 	mov	r7,r2
8111304c:	01800804 	movi	r6,32
81113050:	01400044 	movi	r5,1
81113054:	01204574 	movhi	r4,33045
81113058:	21348a04 	addi	r4,r4,-11736
8111305c:	11216400 	call	81121640 <fwrite>
	#endif

	eSenderAckState = sSAConfiguring;
81113060:	e03ff915 	stw	zero,-28(fp)

	for(;;){

		switch (eSenderAckState) {
81113064:	e0bff917 	ldw	r2,-28(fp)
81113068:	10c00060 	cmpeqi	r3,r2,1
8111306c:	1800071e 	bne	r3,zero,8111308c <vOutAckHandlerTask+0xa8>
81113070:	0080032e 	bgeu	zero,r2,81113080 <vOutAckHandlerTask+0x9c>
81113074:	108000a0 	cmpeqi	r2,r2,2
81113078:	1000471e 	bne	r2,zero,81113198 <vOutAckHandlerTask+0x1b4>
8111307c:	00008c06 	br	811132b0 <vOutAckHandlerTask+0x2cc>
			case sSAConfiguring:
                /*For future implementations*/
                eSenderAckState = sSAGettingACK;
81113080:	00800044 	movi	r2,1
81113084:	e0bff915 	stw	r2,-28(fp)
				break;
81113088:	00009306 	br	811132d8 <vOutAckHandlerTask+0x2f4>
            case sSAGettingACK:
                /* Waits the semaphore that indicates there are some ack message to send*/
                eSenderAckState = sSAGettingACK;
8111308c:	00800044 	movi	r2,1
81113090:	e0bff915 	stw	r2,-28(fp)
                OSSemPend(xSemCountSenderACK, 0, &error_code);
81113094:	d0a06117 	ldw	r2,-32380(gp)
81113098:	e0fffa84 	addi	r3,fp,-22
8111309c:	180d883a 	mov	r6,r3
811130a0:	000b883a 	mov	r5,zero
811130a4:	1009883a 	mov	r4,r2
811130a8:	113e4c00 	call	8113e4c0 <OSSemPend>
                if ( error_code == OS_ERR_NONE ) {
811130ac:	e0bffa83 	ldbu	r2,-22(fp)
811130b0:	10803fcc 	andi	r2,r2,255
811130b4:	1000361e 	bne	r2,zero,81113190 <vOutAckHandlerTask+0x1ac>

                    OSMutexPend(xMutexSenderACK, 0, &error_code);
811130b8:	d0a07217 	ldw	r2,-32312(gp)
811130bc:	e0fffa84 	addi	r3,fp,-22
811130c0:	180d883a 	mov	r6,r3
811130c4:	000b883a 	mov	r5,zero
811130c8:	1009883a 	mov	r4,r2
811130cc:	113c4b40 	call	8113c4b4 <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
811130d0:	e0bffa83 	ldbu	r2,-22(fp)
811130d4:	10803fcc 	andi	r2,r2,255
811130d8:	10002b1e 	bne	r2,zero,81113188 <vOutAckHandlerTask+0x1a4>
                        /*Search for the ack*/
                        for(unsigned char i = 0; i < N_ACKS_SENDER; i++)
811130dc:	e03ffa05 	stb	zero,-24(fp)
811130e0:	00002206 	br	8111316c <vOutAckHandlerTask+0x188>
                        {
                            if ( xSenderACK[i].cType != 0 ) {
811130e4:	e0fffa03 	ldbu	r3,-24(fp)
811130e8:	00a045b4 	movhi	r2,33046
811130ec:	10991904 	addi	r2,r2,25700
811130f0:	18c7883a 	add	r3,r3,r3
811130f4:	18c7883a 	add	r3,r3,r3
811130f8:	10c5883a 	add	r2,r2,r3
811130fc:	10800003 	ldbu	r2,0(r2)
81113100:	10803fcc 	andi	r2,r2,255
81113104:	1080201c 	xori	r2,r2,128
81113108:	10bfe004 	addi	r2,r2,-128
8111310c:	10001426 	beq	r2,zero,81113160 <vOutAckHandlerTask+0x17c>
                                /* Locate the message, copy for the local variable in order to free the mutex. */
                                xSAckLocal = xSenderACK[i];
81113110:	e0fffa03 	ldbu	r3,-24(fp)
81113114:	00a045b4 	movhi	r2,33046
81113118:	10991904 	addi	r2,r2,25700
8111311c:	18c7883a 	add	r3,r3,r3
81113120:	18c7883a 	add	r3,r3,r3
81113124:	10c5883a 	add	r2,r2,r3
81113128:	10c0000b 	ldhu	r3,0(r2)
8111312c:	d0e0598d 	sth	r3,-32410(gp)
81113130:	1080008b 	ldhu	r2,2(r2)
81113134:	d0a05a0d 	sth	r2,-32408(gp)
                                eSenderAckState = sSASending;
81113138:	00800084 	movi	r2,2
8111313c:	e0bff915 	stw	r2,-28(fp)
                                xSenderACK[i].cType = 0; /* indicates that this position now can be used by other message*/
81113140:	e0fffa03 	ldbu	r3,-24(fp)
81113144:	00a045b4 	movhi	r2,33046
81113148:	10991904 	addi	r2,r2,25700
8111314c:	18c7883a 	add	r3,r3,r3
81113150:	18c7883a 	add	r3,r3,r3
81113154:	10c5883a 	add	r2,r2,r3
81113158:	10000005 	stb	zero,0(r2)
                                break;
8111315c:	00000606 	br	81113178 <vOutAckHandlerTask+0x194>
                if ( error_code == OS_ERR_NONE ) {

                    OSMutexPend(xMutexSenderACK, 0, &error_code);
                    if ( error_code == OS_ERR_NONE ) {
                        /*Search for the ack*/
                        for(unsigned char i = 0; i < N_ACKS_SENDER; i++)
81113160:	e0bffa03 	ldbu	r2,-24(fp)
81113164:	10800044 	addi	r2,r2,1
81113168:	e0bffa05 	stb	r2,-24(fp)
8111316c:	e0bffa03 	ldbu	r2,-24(fp)
81113170:	10800230 	cmpltui	r2,r2,8
81113174:	103fdb1e 	bne	r2,zero,811130e4 <__reset+0xfb0f30e4>
                                eSenderAckState = sSASending;
                                xSenderACK[i].cType = 0; /* indicates that this position now can be used by other message*/
                                break;
                            }
                        }
                        OSMutexPost(xMutexSenderACK);
81113178:	d0a07217 	ldw	r2,-32312(gp)
8111317c:	1009883a 	mov	r4,r2
81113180:	113ca580 	call	8113ca58 <OSMutexPost>
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
                }

                break;
81113184:	00005406 	br	811132d8 <vOutAckHandlerTask+0x2f4>
                        }
                        OSMutexPost(xMutexSenderACK);
                    } else {
                        /*  Should never get here, will wait without timeout for the semaphore.
                            But if some error accours we will do nothing but print in the console */
                        vFailGetMutexSenderTask();
81113188:	111b6a00 	call	8111b6a0 <vFailGetMutexSenderTask>
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
                }

                break;
8111318c:	00005206 	br	811132d8 <vOutAckHandlerTask+0x2f4>
                    }

                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
81113190:	111b6380 	call	8111b638 <vFailGetCountSemaphoreSenderTask>
                }

                break;
81113194:	00005006 	br	811132d8 <vOutAckHandlerTask+0x2f4>
			case sSASending:
                
                /* First check if is an NACK packet that should be sent */
                if ( xSAckLocal.cType != '#' ) {
81113198:	d0a05983 	ldbu	r2,-32410(gp)
8111319c:	10803fcc 	andi	r2,r2,255
811131a0:	1080201c 	xori	r2,r2,128
811131a4:	10bfe004 	addi	r2,r2,-128
811131a8:	108008e0 	cmpeqi	r2,r2,35
811131ac:	1000201e 	bne	r2,zero,81113230 <vOutAckHandlerTask+0x24c>
                    /* In this state has a parsed ack packet in the variable xSAckLocal
                    we just need to calc the crc8 and create the uart packet to send. */
                    sprintf(cBufferAck, ACK_SPRINTF, xSAckLocal.cCommand, xSAckLocal.usiId);
811131b0:	d0a059c3 	ldbu	r2,-32409(gp)
811131b4:	10c03fcc 	andi	r3,r2,255
811131b8:	18c0201c 	xori	r3,r3,128
811131bc:	18ffe004 	addi	r3,r3,-128
811131c0:	d0a05a0b 	ldhu	r2,-32408(gp)
811131c4:	113fffcc 	andi	r4,r2,65535
811131c8:	e0bffac4 	addi	r2,fp,-21
811131cc:	200f883a 	mov	r7,r4
811131d0:	180d883a 	mov	r6,r3
811131d4:	01604574 	movhi	r5,33045
811131d8:	29749304 	addi	r5,r5,-11700
811131dc:	1009883a 	mov	r4,r2
811131e0:	11229340 	call	81122934 <sprintf>
                    crc = ucCrc8wInit( cBufferAck , strlen(cBufferAck));
811131e4:	e0bffac4 	addi	r2,fp,-21
811131e8:	1009883a 	mov	r4,r2
811131ec:	1122b480 	call	81122b48 <strlen>
811131f0:	1007883a 	mov	r3,r2
811131f4:	e0bffac4 	addi	r2,fp,-21
811131f8:	180b883a 	mov	r5,r3
811131fc:	1009883a 	mov	r4,r2
81113200:	111b1fc0 	call	8111b1fc <ucCrc8wInit>
81113204:	e0bffa45 	stb	r2,-23(fp)
                    sprintf(cBufferAck, "%s|%hhu;", cBufferAck, crc);
81113208:	e13ffa43 	ldbu	r4,-23(fp)
8111320c:	e0fffac4 	addi	r3,fp,-21
81113210:	e0bffac4 	addi	r2,fp,-21
81113214:	200f883a 	mov	r7,r4
81113218:	180d883a 	mov	r6,r3
8111321c:	01604574 	movhi	r5,33045
81113220:	29749504 	addi	r5,r5,-11692
81113224:	1009883a 	mov	r4,r2
81113228:	11229340 	call	81122934 <sprintf>
8111322c:	00000c06 	br	81113260 <vOutAckHandlerTask+0x27c>
                } else {
                    /* Nack */
                    sprintf(cBufferAck, "%s", NACK_SEQUENCE);
81113230:	e0bffac4 	addi	r2,fp,-21
81113234:	00c008c4 	movi	r3,35
81113238:	10c00005 	stb	r3,0(r2)
8111323c:	00c01f04 	movi	r3,124
81113240:	10c00045 	stb	r3,1(r2)
81113244:	00c00d44 	movi	r3,53
81113248:	10c00085 	stb	r3,2(r2)
8111324c:	00c00d04 	movi	r3,52
81113250:	10c000c5 	stb	r3,3(r2)
81113254:	00c00ec4 	movi	r3,59
81113258:	10c00105 	stb	r3,4(r2)
8111325c:	10000145 	stb	zero,5(r2)
                }


                OSMutexPend(xTxUARTMutex, 100, &error_code); /* Wait max 100 ticks = 100 ms */
81113260:	d0a07417 	ldw	r2,-32304(gp)
81113264:	e0fffa84 	addi	r3,fp,-22
81113268:	180d883a 	mov	r6,r3
8111326c:	01401904 	movi	r5,100
81113270:	1009883a 	mov	r4,r2
81113274:	113c4b40 	call	8113c4b4 <OSMutexPend>
                if ( error_code == OS_NO_ERR ) {
81113278:	e0bffa83 	ldbu	r2,-22(fp)
8111327c:	10803fcc 	andi	r2,r2,255
81113280:	1000071e 	bne	r2,zero,811132a0 <vOutAckHandlerTask+0x2bc>
                    puts(cBufferAck);
81113284:	e0bffac4 	addi	r2,fp,-21
81113288:	1009883a 	mov	r4,r2
8111328c:	11225f00 	call	811225f0 <puts>
                    OSMutexPost(xTxUARTMutex);
81113290:	d0a07417 	ldw	r2,-32304(gp)
81113294:	1009883a 	mov	r4,r2
81113298:	113ca580 	call	8113ca58 <OSMutexPost>
8111329c:	00000106 	br	811132a4 <vOutAckHandlerTask+0x2c0>
                } else
                    vFailGetMutexTxUARTSenderTask(); /* Could not use the uart tx buffer to send the ack*/
811132a0:	111b7d80 	call	8111b7d8 <vFailGetMutexTxUARTSenderTask>

                eSenderAckState = sSAGettingACK;
811132a4:	00800044 	movi	r2,1
811132a8:	e0bff915 	stw	r2,-28(fp)
                
				break;
811132ac:	00000a06 	br	811132d8 <vOutAckHandlerTask+0x2f4>
			default:
            	#ifdef DEBUG_ON
		            debug(fp,"Critical: Default State. Should never get here.(vOutAckHandlerTask)\n");
811132b0:	d0a06217 	ldw	r2,-32376(gp)
811132b4:	100f883a 	mov	r7,r2
811132b8:	01801104 	movi	r6,68
811132bc:	01400044 	movi	r5,1
811132c0:	01204574 	movhi	r4,33045
811132c4:	21349804 	addi	r4,r4,-11680
811132c8:	11216400 	call	81121640 <fwrite>
	            #endif
                eSenderAckState = sSAGettingACK;
811132cc:	00800044 	movi	r2,1
811132d0:	e0bff915 	stw	r2,-28(fp)
				break;
811132d4:	0001883a 	nop
		}
	}
811132d8:	003f6206 	br	81113064 <__reset+0xfb0f3064>

811132dc <vParserCommTask>:


#include "parser_comm_task.h"


void vParserCommTask(void *task_data) {
811132dc:	deffd704 	addi	sp,sp,-164
811132e0:	de00012e 	bgeu	sp,et,811132e8 <vParserCommTask+0xc>
811132e4:	003b68fa 	trap	3
811132e8:	dfc02815 	stw	ra,160(sp)
811132ec:	df002715 	stw	fp,156(sp)
811132f0:	df002704 	addi	fp,sp,156
811132f4:	e13fff15 	stw	r4,-4(fp)
	unsigned short int usiFeeInstL;
	bool bSuccess = FALSE;
811132f8:	e03fdd15 	stw	zero,-140(fp)
	#ifdef DEBUG_ON
		char cPUSDebug[128];
	#endif

    #ifdef DEBUG_ON
        debug(fp,"Parser Comm Task. (Task on)\n");
811132fc:	d0a06217 	ldw	r2,-32376(gp)
81113300:	100f883a 	mov	r7,r2
81113304:	01800704 	movi	r6,28
81113308:	01400044 	movi	r5,1
8111330c:	01204574 	movhi	r4,33045
81113310:	2134aa04 	addi	r4,r4,-11608
81113314:	11216400 	call	81121640 <fwrite>
    #endif

	eParserMode = sConfiguring;
81113318:	e03fdc15 	stw	zero,-144(fp)

	for(;;){

		switch (eParserMode) {
8111331c:	e0bfdc17 	ldw	r2,-144(fp)
81113320:	10800168 	cmpgeui	r2,r2,5
81113324:	1003651e 	bne	r2,zero,811140bc <vParserCommTask+0xde0>
81113328:	e0bfdc17 	ldw	r2,-144(fp)
8111332c:	100690ba 	slli	r3,r2,2
81113330:	00a04474 	movhi	r2,33041
81113334:	108cd104 	addi	r2,r2,13124
81113338:	1885883a 	add	r2,r3,r2
8111333c:	10800017 	ldw	r2,0(r2)
81113340:	1000683a 	jmp	r2
81113344:	81113358 	cmpnei	r4,r16,17613
81113348:	81113364 	muli	r4,r16,17613
8111334c:	811133f8 	rdprs	r4,r16,17615
81113350:	8111355c 	xori	r4,r16,17621
81113354:	811135a0 	cmpeqi	r4,r16,17622
			case sConfiguring:
				/*For future implementations*/
				eParserMode = sWaitingMessage;
81113358:	00800044 	movi	r2,1
8111335c:	e0bfdc15 	stw	r2,-144(fp)
				break;
81113360:	00035906 	br	811140c8 <vParserCommTask+0xdec>
			case sWaitingMessage:

				bSuccess = FALSE;
81113364:	e03fdd15 	stw	zero,-140(fp)
				eParserMode = sWaitingMessage;
81113368:	00800044 	movi	r2,1
8111336c:	e0bfdc15 	stw	r2,-144(fp)

				OSSemPend(xSemCountPreParsed, 0, &error_code); /*Blocking*/
81113370:	d0a06417 	ldw	r2,-32368(gp)
81113374:	e0ffde84 	addi	r3,fp,-134
81113378:	180d883a 	mov	r6,r3
8111337c:	000b883a 	mov	r5,zero
81113380:	1009883a 	mov	r4,r2
81113384:	113e4c00 	call	8113e4c0 <OSSemPend>
				if ( error_code == OS_ERR_NONE ) {
81113388:	e0bfde83 	ldbu	r2,-134(fp)
8111338c:	10803fcc 	andi	r2,r2,255
81113390:	1000171e 	bne	r2,zero,811133f0 <vParserCommTask+0x114>
					/* There's command waiting to be threat */

					bSuccess = getPreParsedPacket(&PreParsedLocal); /*Blocking*/
81113394:	01204574 	movhi	r4,33045
81113398:	210b8b04 	addi	r4,r4,11820
8111339c:	11140cc0 	call	811140cc <getPreParsedPacket>
811133a0:	e0bfdd15 	stw	r2,-140(fp)
					if (bSuccess == TRUE) {
811133a4:	e0bfdd17 	ldw	r2,-140(fp)
811133a8:	10800058 	cmpnei	r2,r2,1
811133ac:	10000e1e 	bne	r2,zero,811133e8 <vParserCommTask+0x10c>
						/* PreParsed Content copied to the local variable */
						if ( PreParsedLocal.cType == START_REPLY_CHAR )
811133b0:	00a04574 	movhi	r2,33045
811133b4:	108b8b04 	addi	r2,r2,11820
811133b8:	10800103 	ldbu	r2,4(r2)
811133bc:	10803fcc 	andi	r2,r2,255
811133c0:	1080201c 	xori	r2,r2,128
811133c4:	10bfe004 	addi	r2,r2,-128
811133c8:	10800858 	cmpnei	r2,r2,33
811133cc:	1000031e 	bne	r2,zero,811133dc <vParserCommTask+0x100>
							eParserMode = sReplyParsing;
811133d0:	008000c4 	movi	r2,3
811133d4:	e0bfdc15 	stw	r2,-144(fp)
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
811133d8:	00033b06 	br	811140c8 <vParserCommTask+0xdec>
					if (bSuccess == TRUE) {
						/* PreParsed Content copied to the local variable */
						if ( PreParsedLocal.cType == START_REPLY_CHAR )
							eParserMode = sReplyParsing;
						else
							eParserMode = sRequestParsing;
811133dc:	00800084 	movi	r2,2
811133e0:	e0bfdc15 	stw	r2,-144(fp)
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
811133e4:	00033806 	br	811140c8 <vParserCommTask+0xdec>
							eParserMode = sReplyParsing;
						else
							eParserMode = sRequestParsing;
					} else {
						/* Semaphore was post by some task but has no message in the PreParsedBuffer*/
						vNoContentInPreParsedBuffer();
811133e8:	111bd640 	call	8111bd64 <vNoContentInPreParsedBuffer>
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
811133ec:	00033606 	br	811140c8 <vParserCommTask+0xdec>
						/* Semaphore was post by some task but has no message in the PreParsedBuffer*/
						vNoContentInPreParsedBuffer();
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
811133f0:	111bc940 	call	8111bc94 <vFailGetCountSemaphorePreParsedBuffer>
				}
				break;
811133f4:	00033406 	br	811140c8 <vParserCommTask+0xdec>
			case sRequestParsing:
				/* Final parssing after identify that is a request packet */
				/* ATTENTION: In order to avoid overhead of process the response to NUC of simple Requests
				   will be threat here, and send from here the parser_rx.*/
			   	switch (PreParsedLocal.cCommand)
811133f8:	00a04574 	movhi	r2,33045
811133fc:	108b8b04 	addi	r2,r2,11820
81113400:	10800143 	ldbu	r2,5(r2)
81113404:	10803fcc 	andi	r2,r2,255
81113408:	1080201c 	xori	r2,r2,128
8111340c:	10bfe004 	addi	r2,r2,-128
81113410:	10c010e0 	cmpeqi	r3,r2,67
81113414:	1800031e 	bne	r3,zero,81113424 <vParserCommTask+0x148>
81113418:	10801420 	cmpeqi	r2,r2,80
8111341c:	1000051e 	bne	r2,zero,81113434 <vParserCommTask+0x158>
81113420:	00004a06 	br	8111354c <vParserCommTask+0x270>
				{
					case ETH_CMD: /*NUC requested the ETH Configuration*/
						vSendEthConf();
81113424:	1118c840 	call	81118c84 <vSendEthConf>
						eParserMode = sWaitingMessage;
81113428:	00800044 	movi	r2,1
8111342c:	e0bfdc15 	stw	r2,-144(fp)
						break;
81113430:	00004906 	br	81113558 <vParserCommTask+0x27c>
                    case PUS_CMD: /*PUS command to MEB - TC*/

						#ifdef DEBUG_ON
							memset(cPUSDebug,0,128);
81113434:	e0bfdec4 	addi	r2,fp,-133
81113438:	01802004 	movi	r6,128
8111343c:	000b883a 	mov	r5,zero
81113440:	1009883a 	mov	r4,r2
81113444:	11221a40 	call	811221a4 <memset>
							sprintf(cPUSDebug, "\nParser Task: TC-> pid: %hu; pcat: %hu; srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", PreParsedLocal.usiValues[1], PreParsedLocal.usiValues[2], PreParsedLocal.usiValues[3], PreParsedLocal.usiValues[4], PreParsedLocal.usiValues[5]);
81113448:	00a04574 	movhi	r2,33045
8111344c:	108b8b04 	addi	r2,r2,11820
81113450:	1080028b 	ldhu	r2,10(r2)
81113454:	117fffcc 	andi	r5,r2,65535
81113458:	00a04574 	movhi	r2,33045
8111345c:	108b8b04 	addi	r2,r2,11820
81113460:	1080030b 	ldhu	r2,12(r2)
81113464:	11bfffcc 	andi	r6,r2,65535
81113468:	00a04574 	movhi	r2,33045
8111346c:	108b8b04 	addi	r2,r2,11820
81113470:	1080038b 	ldhu	r2,14(r2)
81113474:	10ffffcc 	andi	r3,r2,65535
81113478:	00a04574 	movhi	r2,33045
8111347c:	108b8b04 	addi	r2,r2,11820
81113480:	1080040b 	ldhu	r2,16(r2)
81113484:	113fffcc 	andi	r4,r2,65535
81113488:	00a04574 	movhi	r2,33045
8111348c:	108b8b04 	addi	r2,r2,11820
81113490:	1080048b 	ldhu	r2,18(r2)
81113494:	10bfffcc 	andi	r2,r2,65535
81113498:	e23fdec4 	addi	r8,fp,-133
8111349c:	d8800215 	stw	r2,8(sp)
811134a0:	d9000115 	stw	r4,4(sp)
811134a4:	d8c00015 	stw	r3,0(sp)
811134a8:	300f883a 	mov	r7,r6
811134ac:	280d883a 	mov	r6,r5
811134b0:	01604574 	movhi	r5,33045
811134b4:	2974b204 	addi	r5,r5,-11576
811134b8:	4009883a 	mov	r4,r8
811134bc:	11229340 	call	81122934 <sprintf>
							debug(fp, cPUSDebug );
811134c0:	d0a06217 	ldw	r2,-32376(gp)
811134c4:	e0ffdec4 	addi	r3,fp,-133
811134c8:	180b883a 	mov	r5,r3
811134cc:	1009883a 	mov	r4,r2
811134d0:	1120fa40 	call	81120fa4 <fprintf>
						#endif
	
						xTcPusL.usiCat	= PreParsedLocal.usiValues[2];
811134d4:	00a04574 	movhi	r2,33045
811134d8:	108b8b04 	addi	r2,r2,11820
811134dc:	10c0030b 	ldhu	r3,12(r2)
811134e0:	00a04574 	movhi	r2,33045
811134e4:	108b9e04 	addi	r2,r2,11896
811134e8:	10c0028d 	sth	r3,10(r2)
						xTcPusL.usiType = PreParsedLocal.usiValues[3];
811134ec:	00a04574 	movhi	r2,33045
811134f0:	108b8b04 	addi	r2,r2,11820
811134f4:	10c0038b 	ldhu	r3,14(r2)
811134f8:	00a04574 	movhi	r2,33045
811134fc:	108b9e04 	addi	r2,r2,11896
81113500:	10c0030d 	sth	r3,12(r2)
						xTcPusL.usiSubType = PreParsedLocal.usiValues[4];
81113504:	00a04574 	movhi	r2,33045
81113508:	108b8b04 	addi	r2,r2,11820
8111350c:	10c0040b 	ldhu	r3,16(r2)
81113510:	00a04574 	movhi	r2,33045
81113514:	108b9e04 	addi	r2,r2,11896
81113518:	10c0038d 	sth	r3,14(r2)
						xTcPusL.usiPusId = PreParsedLocal.usiValues[5];
8111351c:	00a04574 	movhi	r2,33045
81113520:	108b8b04 	addi	r2,r2,11820
81113524:	10c0048b 	ldhu	r3,18(r2)
81113528:	00a04574 	movhi	r2,33045
8111352c:	108b9e04 	addi	r2,r2,11896
81113530:	10c0040d 	sth	r3,16(r2)
						xTcPusL.ucNofValues = 0; /* Don't assume that has values */
81113534:	00a04574 	movhi	r2,33045
81113538:	108b9e04 	addi	r2,r2,11896
8111353c:	10000485 	stb	zero,18(r2)

						eParserMode = sPusHandling;
81113540:	00800104 	movi	r2,4
81113544:	e0bfdc15 	stw	r2,-144(fp)
                        break;						
81113548:	00000306 	br	81113558 <vParserCommTask+0x27c>
					default:
						eParserMode = sWaitingMessage;
8111354c:	00800044 	movi	r2,1
81113550:	e0bfdc15 	stw	r2,-144(fp)
						break;
81113554:	0001883a 	nop
				}
				break;
81113558:	0002db06 	br	811140c8 <vParserCommTask+0xdec>
			case sReplyParsing:
				eParserMode = sWaitingMessage;
8111355c:	00800044 	movi	r2,1
81113560:	e0bfdc15 	stw	r2,-144(fp)
                switch ( xTcPusL.usiType )
81113564:	00a04574 	movhi	r2,33045
81113568:	108b9e04 	addi	r2,r2,11896
8111356c:	1080030b 	ldhu	r2,12(r2)
81113570:	10bfffcc 	andi	r2,r2,65535
81113574:	10c01220 	cmpeqi	r3,r2,72
81113578:	1800051e 	bne	r3,zero,81113590 <vParserCommTask+0x2b4>
8111357c:	108014e0 	cmpeqi	r2,r2,83
81113580:	1000051e 	bne	r2,zero,81113598 <vParserCommTask+0x2bc>
                    case HEART_BEAT_CMD: /*Heart beating (NUC are you there?)*/

						
                        break;
                    default:
						eParserMode = sWaitingMessage;
81113584:	00800044 	movi	r2,1
81113588:	e0bfdc15 	stw	r2,-144(fp)
                        break;
8111358c:	00000306 	br	8111359c <vParserCommTask+0x2c0>
						
                        break;
                    case HEART_BEAT_CMD: /*Heart beating (NUC are you there?)*/

						
                        break;
81113590:	0001883a 	nop
81113594:	0002cc06 	br	811140c8 <vParserCommTask+0xdec>
                switch ( xTcPusL.usiType )
                {
                    case NUC_STATUS_CMD: /*Status from NUC*/

						
                        break;
81113598:	0001883a 	nop
                        break;
                    default:
						eParserMode = sWaitingMessage;
                        break;
                }
				break;
8111359c:	0002ca06 	br	811140c8 <vParserCommTask+0xdec>
			case sPusHandling:
				eParserMode = sWaitingMessage;
811135a0:	00800044 	movi	r2,1
811135a4:	e0bfdc15 	stw	r2,-144(fp)
				
                switch ( xTcPusL.usiType )
811135a8:	00a04574 	movhi	r2,33045
811135ac:	108b9e04 	addi	r2,r2,11896
811135b0:	1080030b 	ldhu	r2,12(r2)
811135b4:	10bfffcc 	andi	r2,r2,65535
811135b8:	10c03ea0 	cmpeqi	r3,r2,250
811135bc:	1800401e 	bne	r3,zero,811136c0 <vParserCommTask+0x3e4>
811135c0:	10c03ec8 	cmpgei	r3,r2,251
811135c4:	1800031e 	bne	r3,zero,811135d4 <vParserCommTask+0x2f8>
811135c8:	10800460 	cmpeqi	r2,r2,17
811135cc:	1000061e 	bne	r2,zero,811135e8 <vParserCommTask+0x30c>
811135d0:	0002b606 	br	811140ac <vParserCommTask+0xdd0>
811135d4:	10c03ee0 	cmpeqi	r3,r2,251
811135d8:	18009d1e 	bne	r3,zero,81113850 <vParserCommTask+0x574>
811135dc:	10803f20 	cmpeqi	r2,r2,252
811135e0:	1001321e 	bne	r2,zero,81113aac <vParserCommTask+0x7d0>
811135e4:	0002b106 	br	811140ac <vParserCommTask+0xdd0>
                {
                    case 17: /* srv-Type = 17 */
						switch ( xTcPusL.usiSubType )
811135e8:	00a04574 	movhi	r2,33045
811135ec:	108b9e04 	addi	r2,r2,11896
811135f0:	1080038b 	ldhu	r2,14(r2)
811135f4:	10bfffcc 	andi	r2,r2,65535
811135f8:	10800060 	cmpeqi	r2,r2,1
811135fc:	10000e26 	beq	r2,zero,81113638 <vParserCommTask+0x35c>
						{
							case 1: /* TC_SCAM_TEST_CONNECTION */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_TEST_CONNECTION\n");
81113600:	d0a06217 	ldw	r2,-32376(gp)
81113604:	100f883a 	mov	r7,r2
81113608:	01800944 	movi	r6,37
8111360c:	01400044 	movi	r5,1
81113610:	01204574 	movhi	r4,33045
81113614:	2134c804 	addi	r4,r4,-11488
81113618:	11216400 	call	81121640 <fwrite>
								#endif

								/* Reply with the TM os connection */
								vTMPusTestConnection( xTcPusL.usiPusId );
8111361c:	00a04574 	movhi	r2,33045
81113620:	108b9e04 	addi	r2,r2,11896
81113624:	1080040b 	ldhu	r2,16(r2)
81113628:	10bfffcc 	andi	r2,r2,65535
8111362c:	1009883a 	mov	r4,r2
81113630:	11196840 	call	81119684 <vTMPusTestConnection>

								break;
81113634:	00002106 	br	811136bc <vParserCommTask+0x3e0>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81113638:	e0bfdec4 	addi	r2,fp,-133
8111363c:	01802004 	movi	r6,128
81113640:	000b883a 	mov	r5,zero
81113644:	1009883a 	mov	r4,r2
81113648:	11221a40 	call	811221a4 <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
8111364c:	00a04574 	movhi	r2,33045
81113650:	108b9e04 	addi	r2,r2,11896
81113654:	1080030b 	ldhu	r2,12(r2)
81113658:	113fffcc 	andi	r4,r2,65535
8111365c:	00a04574 	movhi	r2,33045
81113660:	108b9e04 	addi	r2,r2,11896
81113664:	1080038b 	ldhu	r2,14(r2)
81113668:	117fffcc 	andi	r5,r2,65535
8111366c:	00a04574 	movhi	r2,33045
81113670:	108b9e04 	addi	r2,r2,11896
81113674:	1080040b 	ldhu	r2,16(r2)
81113678:	10bfffcc 	andi	r2,r2,65535
8111367c:	e0ffdec4 	addi	r3,fp,-133
81113680:	d8800015 	stw	r2,0(sp)
81113684:	280f883a 	mov	r7,r5
81113688:	200d883a 	mov	r6,r4
8111368c:	01604574 	movhi	r5,33045
81113690:	2974d204 	addi	r5,r5,-11448
81113694:	1809883a 	mov	r4,r3
81113698:	11229340 	call	81122934 <sprintf>
									debug(fp, cPUSDebug );
8111369c:	d0a06217 	ldw	r2,-32376(gp)
811136a0:	e0ffdec4 	addi	r3,fp,-133
811136a4:	180b883a 	mov	r5,r3
811136a8:	1009883a 	mov	r4,r2
811136ac:	1120fa40 	call	81120fa4 <fprintf>
								#endif
								eParserMode = sWaitingMessage;
811136b0:	00800044 	movi	r2,1
811136b4:	e0bfdc15 	stw	r2,-144(fp)
								break;
811136b8:	0001883a 	nop
						}
                        break;
811136bc:	00027e06 	br	811140b8 <vParserCommTask+0xddc>


                    case 250: /* srv-Type = 250 */
						switch ( xTcPusL.usiSubType )
811136c0:	00a04574 	movhi	r2,33045
811136c4:	108b9e04 	addi	r2,r2,11896
811136c8:	1080038b 	ldhu	r2,14(r2)
811136cc:	10bfffcc 	andi	r2,r2,65535
811136d0:	10c00f20 	cmpeqi	r3,r2,60
811136d4:	18001a1e 	bne	r3,zero,81113740 <vParserCommTask+0x464>
811136d8:	10c00f48 	cmpgei	r3,r2,61
811136dc:	1800031e 	bne	r3,zero,811136ec <vParserCommTask+0x410>
811136e0:	10800ee0 	cmpeqi	r2,r2,59
811136e4:	1000061e 	bne	r2,zero,81113700 <vParserCommTask+0x424>
811136e8:	00003706 	br	811137c8 <vParserCommTask+0x4ec>
811136ec:	10c00f60 	cmpeqi	r3,r2,61
811136f0:	18001e1e 	bne	r3,zero,8111376c <vParserCommTask+0x490>
811136f4:	10800fa0 	cmpeqi	r2,r2,62
811136f8:	1000271e 	bne	r2,zero,81113798 <vParserCommTask+0x4bc>
811136fc:	00003206 	br	811137c8 <vParserCommTask+0x4ec>
						{
							case 59: /* TC_SCAM_RESET */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_RESET\n");
81113700:	d0a06217 	ldw	r2,-32376(gp)
81113704:	100f883a 	mov	r7,r2
81113708:	018006c4 	movi	r6,27
8111370c:	01400044 	movi	r5,1
81113710:	01204574 	movhi	r4,33045
81113714:	2134e504 	addi	r4,r4,-11372
81113718:	11216400 	call	81121640 <fwrite>
								#endif
								vSendReset();
8111371c:	111902c0 	call	8111902c <vSendReset>
								/*Just Reset the Simucam, what do with the NUC?*/
								OSTimeDlyHMSM(0,0,3,0);
81113720:	000f883a 	mov	r7,zero
81113724:	018000c4 	movi	r6,3
81113728:	000b883a 	mov	r5,zero
8111372c:	0009883a 	mov	r4,zero
81113730:	11404580 	call	81140458 <OSTimeDlyHMSM>
								vRstcSimucamReset( 5000 );
81113734:	0104e204 	movi	r4,5000
81113738:	110c36c0 	call	8110c36c <vRstcSimucamReset>

								break;
8111373c:	00004306 	br	8111384c <vParserCommTask+0x570>
							case 60: /* TC_SCAM_CONFIG */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_CONFIG\n");
81113740:	d0a06217 	ldw	r2,-32376(gp)
81113744:	100f883a 	mov	r7,r2
81113748:	01800704 	movi	r6,28
8111374c:	01400044 	movi	r5,1
81113750:	01204574 	movhi	r4,33045
81113754:	2134ec04 	addi	r4,r4,-11344
81113758:	11216400 	call	81121640 <fwrite>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
8111375c:	01204574 	movhi	r4,33045
81113760:	210b9e04 	addi	r4,r4,11896
81113764:	11141e40 	call	811141e4 <bSendMessagePUStoMebTask>

								break;
81113768:	00003806 	br	8111384c <vParserCommTask+0x570>
							case 61: /* TC_SCAM_RUN */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_RUN\n");
8111376c:	d0a06217 	ldw	r2,-32376(gp)
81113770:	100f883a 	mov	r7,r2
81113774:	01800644 	movi	r6,25
81113778:	01400044 	movi	r5,1
8111377c:	01204574 	movhi	r4,33045
81113780:	2134f404 	addi	r4,r4,-11312
81113784:	11216400 	call	81121640 <fwrite>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
81113788:	01204574 	movhi	r4,33045
8111378c:	210b9e04 	addi	r4,r4,11896
81113790:	11141e40 	call	811141e4 <bSendMessagePUStoMebTask>

								break;
81113794:	00002d06 	br	8111384c <vParserCommTask+0x570>
							case 62: /* TC_SCAM_TURNOFF */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_TURNOFF\n");
81113798:	d0a06217 	ldw	r2,-32376(gp)
8111379c:	100f883a 	mov	r7,r2
811137a0:	01800744 	movi	r6,29
811137a4:	01400044 	movi	r5,1
811137a8:	01204574 	movhi	r4,33045
811137ac:	2134fb04 	addi	r4,r4,-11284
811137b0:	11216400 	call	81121640 <fwrite>
								#endif
								vSendTurnOff();
811137b4:	1118f140 	call	81118f14 <vSendTurnOff>

								/* Send to Meb the shutdown command */
								bSendMessagePUStoMebTask(&xTcPusL);
811137b8:	01204574 	movhi	r4,33045
811137bc:	210b9e04 	addi	r4,r4,11896
811137c0:	11141e40 	call	811141e4 <bSendMessagePUStoMebTask>

								break;
811137c4:	00002106 	br	8111384c <vParserCommTask+0x570>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
811137c8:	e0bfdec4 	addi	r2,fp,-133
811137cc:	01802004 	movi	r6,128
811137d0:	000b883a 	mov	r5,zero
811137d4:	1009883a 	mov	r4,r2
811137d8:	11221a40 	call	811221a4 <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
811137dc:	00a04574 	movhi	r2,33045
811137e0:	108b9e04 	addi	r2,r2,11896
811137e4:	1080030b 	ldhu	r2,12(r2)
811137e8:	113fffcc 	andi	r4,r2,65535
811137ec:	00a04574 	movhi	r2,33045
811137f0:	108b9e04 	addi	r2,r2,11896
811137f4:	1080038b 	ldhu	r2,14(r2)
811137f8:	117fffcc 	andi	r5,r2,65535
811137fc:	00a04574 	movhi	r2,33045
81113800:	108b9e04 	addi	r2,r2,11896
81113804:	1080040b 	ldhu	r2,16(r2)
81113808:	10bfffcc 	andi	r2,r2,65535
8111380c:	e0ffdec4 	addi	r3,fp,-133
81113810:	d8800015 	stw	r2,0(sp)
81113814:	280f883a 	mov	r7,r5
81113818:	200d883a 	mov	r6,r4
8111381c:	01604574 	movhi	r5,33045
81113820:	2974d204 	addi	r5,r5,-11448
81113824:	1809883a 	mov	r4,r3
81113828:	11229340 	call	81122934 <sprintf>
									debug(fp, cPUSDebug );
8111382c:	d0a06217 	ldw	r2,-32376(gp)
81113830:	e0ffdec4 	addi	r3,fp,-133
81113834:	180b883a 	mov	r5,r3
81113838:	1009883a 	mov	r4,r2
8111383c:	1120fa40 	call	81120fa4 <fprintf>
								#endif							
								eParserMode = sWaitingMessage;
81113840:	00800044 	movi	r2,1
81113844:	e0bfdc15 	stw	r2,-144(fp)
								break;
81113848:	0001883a 	nop
						}
                        break;
8111384c:	00021a06 	br	811140b8 <vParserCommTask+0xddc>


                    case 251: /* srv-Type = 251 */
						usiFeeInstL = PreParsedLocal.usiValues[6];
81113850:	00a04574 	movhi	r2,33045
81113854:	108b8b04 	addi	r2,r2,11820
81113858:	1080050b 	ldhu	r2,20(r2)
8111385c:	e0bfde0d 	sth	r2,-136(fp)

						if ( usiFeeInstL > N_OF_NFEE ) {
81113860:	e0bfde0b 	ldhu	r2,-136(fp)
81113864:	108000b0 	cmpltui	r2,r2,2
81113868:	1000121e 	bne	r2,zero,811138b4 <vParserCommTask+0x5d8>
							#ifdef DEBUG_ON
								memset(cPUSDebug,0,128);
8111386c:	e0bfdec4 	addi	r2,fp,-133
81113870:	01802004 	movi	r6,128
81113874:	000b883a 	mov	r5,zero
81113878:	1009883a 	mov	r4,r2
8111387c:	11221a40 	call	811221a4 <memset>
								sprintf(cPUSDebug, "Parser Task: Doesn't exist the Fee Instance number: %hu;\n", usiFeeInstL );
81113880:	e0ffde0b 	ldhu	r3,-136(fp)
81113884:	e0bfdec4 	addi	r2,fp,-133
81113888:	180d883a 	mov	r6,r3
8111388c:	01604574 	movhi	r5,33045
81113890:	29750304 	addi	r5,r5,-11252
81113894:	1009883a 	mov	r4,r2
81113898:	11229340 	call	81122934 <sprintf>
								debug(fp, cPUSDebug );
8111389c:	d0a06217 	ldw	r2,-32376(gp)
811138a0:	e0ffdec4 	addi	r3,fp,-133
811138a4:	180b883a 	mov	r5,r3
811138a8:	1009883a 	mov	r4,r2
811138ac:	1120fa40 	call	81120fa4 <fprintf>
									#endif							
									eParserMode = sWaitingMessage;
									break;
							}
						}
                        break;
811138b0:	00020106 	br	811140b8 <vParserCommTask+0xddc>
								sprintf(cPUSDebug, "Parser Task: Doesn't exist the Fee Instance number: %hu;\n", usiFeeInstL );
								debug(fp, cPUSDebug );
							#endif
							/* todo: Enviar mensagem de erro se aplicavel */
						} else {
							xTcPusL.usiValues[xTcPusL.ucNofValues] = usiFeeInstL;
811138b4:	00a04574 	movhi	r2,33045
811138b8:	108b9e04 	addi	r2,r2,11896
811138bc:	10800483 	ldbu	r2,18(r2)
811138c0:	10c03fcc 	andi	r3,r2,255
811138c4:	00a04574 	movhi	r2,33045
811138c8:	108b9e04 	addi	r2,r2,11896
811138cc:	18c00284 	addi	r3,r3,10
811138d0:	18c7883a 	add	r3,r3,r3
811138d4:	10c5883a 	add	r2,r2,r3
811138d8:	e0ffde0b 	ldhu	r3,-136(fp)
811138dc:	10c0000d 	sth	r3,0(r2)
							xTcPusL.ucNofValues++;
811138e0:	00a04574 	movhi	r2,33045
811138e4:	108b9e04 	addi	r2,r2,11896
811138e8:	10800483 	ldbu	r2,18(r2)
811138ec:	10800044 	addi	r2,r2,1
811138f0:	1007883a 	mov	r3,r2
811138f4:	00a04574 	movhi	r2,33045
811138f8:	108b9e04 	addi	r2,r2,11896
811138fc:	10c00485 	stb	r3,18(r2)

							switch ( xTcPusL.usiSubType )
81113900:	00a04574 	movhi	r2,33045
81113904:	108b9e04 	addi	r2,r2,11896
81113908:	1080038b 	ldhu	r2,14(r2)
8111390c:	10bfffcc 	andi	r2,r2,65535
81113910:	10c000a0 	cmpeqi	r3,r2,2
81113914:	1800191e 	bne	r3,zero,8111397c <vParserCommTask+0x6a0>
81113918:	10c00160 	cmpeqi	r3,r2,5
8111391c:	18002c1e 	bne	r3,zero,811139d0 <vParserCommTask+0x6f4>
81113920:	10800060 	cmpeqi	r2,r2,1
81113924:	10003f26 	beq	r2,zero,81113a24 <vParserCommTask+0x748>
							{
								case 1: /* TC_SCAM_FEE_CONFIG_ENTER */
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
81113928:	e0bfdec4 	addi	r2,fp,-133
8111392c:	01802004 	movi	r6,128
81113930:	000b883a 	mov	r5,zero
81113934:	1009883a 	mov	r4,r2
81113938:	11221a40 	call	811221a4 <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_CONFIG_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
8111393c:	e0ffde0b 	ldhu	r3,-136(fp)
81113940:	e0bfdec4 	addi	r2,fp,-133
81113944:	180d883a 	mov	r6,r3
81113948:	01604574 	movhi	r5,33045
8111394c:	29751204 	addi	r5,r5,-11192
81113950:	1009883a 	mov	r4,r2
81113954:	11229340 	call	81122934 <sprintf>
										debug(fp, cPUSDebug );
81113958:	d0a06217 	ldw	r2,-32376(gp)
8111395c:	e0ffdec4 	addi	r3,fp,-133
81113960:	180b883a 	mov	r5,r3
81113964:	1009883a 	mov	r4,r2
81113968:	1120fa40 	call	81120fa4 <fprintf>
									#endif							
									bSendMessagePUStoMebTask(&xTcPusL);
8111396c:	01204574 	movhi	r4,33045
81113970:	210b9e04 	addi	r4,r4,11896
81113974:	11141e40 	call	811141e4 <bSendMessagePUStoMebTask>

									break;
81113978:	00004b06 	br	81113aa8 <vParserCommTask+0x7cc>
								case 2: /* TC_SCAM_FEE_STANDBY_ENTER */
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
8111397c:	e0bfdec4 	addi	r2,fp,-133
81113980:	01802004 	movi	r6,128
81113984:	000b883a 	mov	r5,zero
81113988:	1009883a 	mov	r4,r2
8111398c:	11221a40 	call	811221a4 <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_STANDBY_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81113990:	e0ffde0b 	ldhu	r3,-136(fp)
81113994:	e0bfdec4 	addi	r2,fp,-133
81113998:	180d883a 	mov	r6,r3
8111399c:	01604574 	movhi	r5,33045
811139a0:	29752204 	addi	r5,r5,-11128
811139a4:	1009883a 	mov	r4,r2
811139a8:	11229340 	call	81122934 <sprintf>
										debug(fp, cPUSDebug );
811139ac:	d0a06217 	ldw	r2,-32376(gp)
811139b0:	e0ffdec4 	addi	r3,fp,-133
811139b4:	180b883a 	mov	r5,r3
811139b8:	1009883a 	mov	r4,r2
811139bc:	1120fa40 	call	81120fa4 <fprintf>
									#endif
									bSendMessagePUStoMebTask(&xTcPusL);
811139c0:	01204574 	movhi	r4,33045
811139c4:	210b9e04 	addi	r4,r4,11896
811139c8:	11141e40 	call	811141e4 <bSendMessagePUStoMebTask>

									break;
811139cc:	00003606 	br	81113aa8 <vParserCommTask+0x7cc>
								case 5: /* TC_SCAM_FEE_CALIBRATION_TEST_ENTER */
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
811139d0:	e0bfdec4 	addi	r2,fp,-133
811139d4:	01802004 	movi	r6,128
811139d8:	000b883a 	mov	r5,zero
811139dc:	1009883a 	mov	r4,r2
811139e0:	11221a40 	call	811221a4 <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_CALIBRATION_TEST_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
811139e4:	e0ffde0b 	ldhu	r3,-136(fp)
811139e8:	e0bfdec4 	addi	r2,fp,-133
811139ec:	180d883a 	mov	r6,r3
811139f0:	01604574 	movhi	r5,33045
811139f4:	29753204 	addi	r5,r5,-11064
811139f8:	1009883a 	mov	r4,r2
811139fc:	11229340 	call	81122934 <sprintf>
										debug(fp, cPUSDebug );
81113a00:	d0a06217 	ldw	r2,-32376(gp)
81113a04:	e0ffdec4 	addi	r3,fp,-133
81113a08:	180b883a 	mov	r5,r3
81113a0c:	1009883a 	mov	r4,r2
81113a10:	1120fa40 	call	81120fa4 <fprintf>
									#endif
									bSendMessagePUStoMebTask(&xTcPusL);
81113a14:	01204574 	movhi	r4,33045
81113a18:	210b9e04 	addi	r4,r4,11896
81113a1c:	11141e40 	call	811141e4 <bSendMessagePUStoMebTask>

									break;
81113a20:	00002106 	br	81113aa8 <vParserCommTask+0x7cc>
								default:
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
81113a24:	e0bfdec4 	addi	r2,fp,-133
81113a28:	01802004 	movi	r6,128
81113a2c:	000b883a 	mov	r5,zero
81113a30:	1009883a 	mov	r4,r2
81113a34:	11221a40 	call	811221a4 <memset>
										sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
81113a38:	00a04574 	movhi	r2,33045
81113a3c:	108b9e04 	addi	r2,r2,11896
81113a40:	1080030b 	ldhu	r2,12(r2)
81113a44:	113fffcc 	andi	r4,r2,65535
81113a48:	00a04574 	movhi	r2,33045
81113a4c:	108b9e04 	addi	r2,r2,11896
81113a50:	1080038b 	ldhu	r2,14(r2)
81113a54:	117fffcc 	andi	r5,r2,65535
81113a58:	00a04574 	movhi	r2,33045
81113a5c:	108b9e04 	addi	r2,r2,11896
81113a60:	1080040b 	ldhu	r2,16(r2)
81113a64:	10bfffcc 	andi	r2,r2,65535
81113a68:	e0ffdec4 	addi	r3,fp,-133
81113a6c:	d8800015 	stw	r2,0(sp)
81113a70:	280f883a 	mov	r7,r5
81113a74:	200d883a 	mov	r6,r4
81113a78:	01604574 	movhi	r5,33045
81113a7c:	2974d204 	addi	r5,r5,-11448
81113a80:	1809883a 	mov	r4,r3
81113a84:	11229340 	call	81122934 <sprintf>
										debug(fp, cPUSDebug );
81113a88:	d0a06217 	ldw	r2,-32376(gp)
81113a8c:	e0ffdec4 	addi	r3,fp,-133
81113a90:	180b883a 	mov	r5,r3
81113a94:	1009883a 	mov	r4,r2
81113a98:	1120fa40 	call	81120fa4 <fprintf>
									#endif							
									eParserMode = sWaitingMessage;
81113a9c:	00800044 	movi	r2,1
81113aa0:	e0bfdc15 	stw	r2,-144(fp)
									break;
81113aa4:	0001883a 	nop
							}
						}
                        break;
81113aa8:	00018306 	br	811140b8 <vParserCommTask+0xddc>


					case 252: /* srv-Type = 252 */
						usiFeeInstL = PreParsedLocal.usiValues[6];
81113aac:	00a04574 	movhi	r2,33045
81113ab0:	108b8b04 	addi	r2,r2,11820
81113ab4:	1080050b 	ldhu	r2,20(r2)
81113ab8:	e0bfde0d 	sth	r2,-136(fp)
						xTcPusL.usiValues[xTcPusL.ucNofValues] = usiFeeInstL;
81113abc:	00a04574 	movhi	r2,33045
81113ac0:	108b9e04 	addi	r2,r2,11896
81113ac4:	10800483 	ldbu	r2,18(r2)
81113ac8:	10c03fcc 	andi	r3,r2,255
81113acc:	00a04574 	movhi	r2,33045
81113ad0:	108b9e04 	addi	r2,r2,11896
81113ad4:	18c00284 	addi	r3,r3,10
81113ad8:	18c7883a 	add	r3,r3,r3
81113adc:	10c5883a 	add	r2,r2,r3
81113ae0:	e0ffde0b 	ldhu	r3,-136(fp)
81113ae4:	10c0000d 	sth	r3,0(r2)
						xTcPusL.ucNofValues++;
81113ae8:	00a04574 	movhi	r2,33045
81113aec:	108b9e04 	addi	r2,r2,11896
81113af0:	10800483 	ldbu	r2,18(r2)
81113af4:	10800044 	addi	r2,r2,1
81113af8:	1007883a 	mov	r3,r2
81113afc:	00a04574 	movhi	r2,33045
81113b00:	108b9e04 	addi	r2,r2,11896
81113b04:	10c00485 	stb	r3,18(r2)

						switch ( xTcPusL.usiSubType )
81113b08:	00a04574 	movhi	r2,33045
81113b0c:	108b9e04 	addi	r2,r2,11896
81113b10:	1080038b 	ldhu	r2,14(r2)
81113b14:	10bfffcc 	andi	r2,r2,65535
81113b18:	10c000e0 	cmpeqi	r3,r2,3
81113b1c:	18000a1e 	bne	r3,zero,81113b48 <vParserCommTask+0x86c>
81113b20:	10c00108 	cmpgei	r3,r2,4
81113b24:	1800031e 	bne	r3,zero,81113b34 <vParserCommTask+0x858>
81113b28:	108000a0 	cmpeqi	r2,r2,2
81113b2c:	1000451e 	bne	r2,zero,81113c44 <vParserCommTask+0x968>
81113b30:	00013c06 	br	81114024 <vParserCommTask+0xd48>
81113b34:	10c00120 	cmpeqi	r3,r2,4
81113b38:	1800181e 	bne	r3,zero,81113b9c <vParserCommTask+0x8c0>
81113b3c:	10800160 	cmpeqi	r2,r2,5
81113b40:	10002b1e 	bne	r2,zero,81113bf0 <vParserCommTask+0x914>
81113b44:	00013706 	br	81114024 <vParserCommTask+0xd48>
						{					
							case 3: /* TC_SCAM_SPW_LINK_ENABLE */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81113b48:	e0bfdec4 	addi	r2,fp,-133
81113b4c:	01802004 	movi	r6,128
81113b50:	000b883a 	mov	r5,zero
81113b54:	1009883a 	mov	r4,r2
81113b58:	11221a40 	call	811221a4 <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_ENABLE (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81113b5c:	e0ffde0b 	ldhu	r3,-136(fp)
81113b60:	e0bfdec4 	addi	r2,fp,-133
81113b64:	180d883a 	mov	r6,r3
81113b68:	01604574 	movhi	r5,33045
81113b6c:	29754404 	addi	r5,r5,-10992
81113b70:	1009883a 	mov	r4,r2
81113b74:	11229340 	call	81122934 <sprintf>
									debug(fp, cPUSDebug );
81113b78:	d0a06217 	ldw	r2,-32376(gp)
81113b7c:	e0ffdec4 	addi	r3,fp,-133
81113b80:	180b883a 	mov	r5,r3
81113b84:	1009883a 	mov	r4,r2
81113b88:	1120fa40 	call	81120fa4 <fprintf>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
81113b8c:	01204574 	movhi	r4,33045
81113b90:	210b9e04 	addi	r4,r4,11896
81113b94:	11141e40 	call	811141e4 <bSendMessagePUStoMebTask>

								break;
81113b98:	00014306 	br	811140a8 <vParserCommTask+0xdcc>
							case 4: /* TC_SCAM_SPW_LINK_DISABLE */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81113b9c:	e0bfdec4 	addi	r2,fp,-133
81113ba0:	01802004 	movi	r6,128
81113ba4:	000b883a 	mov	r5,zero
81113ba8:	1009883a 	mov	r4,r2
81113bac:	11221a40 	call	811221a4 <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_DISABLE (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81113bb0:	e0ffde0b 	ldhu	r3,-136(fp)
81113bb4:	e0bfdec4 	addi	r2,fp,-133
81113bb8:	180d883a 	mov	r6,r3
81113bbc:	01604574 	movhi	r5,33045
81113bc0:	29755404 	addi	r5,r5,-10928
81113bc4:	1009883a 	mov	r4,r2
81113bc8:	11229340 	call	81122934 <sprintf>
									debug(fp, cPUSDebug );
81113bcc:	d0a06217 	ldw	r2,-32376(gp)
81113bd0:	e0ffdec4 	addi	r3,fp,-133
81113bd4:	180b883a 	mov	r5,r3
81113bd8:	1009883a 	mov	r4,r2
81113bdc:	1120fa40 	call	81120fa4 <fprintf>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
81113be0:	01204574 	movhi	r4,33045
81113be4:	210b9e04 	addi	r4,r4,11896
81113be8:	11141e40 	call	811141e4 <bSendMessagePUStoMebTask>

								break;
81113bec:	00012e06 	br	811140a8 <vParserCommTask+0xdcc>
							case 5: /* TC_SCAM_SPW_LINK_RESET */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81113bf0:	e0bfdec4 	addi	r2,fp,-133
81113bf4:	01802004 	movi	r6,128
81113bf8:	000b883a 	mov	r5,zero
81113bfc:	1009883a 	mov	r4,r2
81113c00:	11221a40 	call	811221a4 <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_RESET (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81113c04:	e0ffde0b 	ldhu	r3,-136(fp)
81113c08:	e0bfdec4 	addi	r2,fp,-133
81113c0c:	180d883a 	mov	r6,r3
81113c10:	01604574 	movhi	r5,33045
81113c14:	29756404 	addi	r5,r5,-10864
81113c18:	1009883a 	mov	r4,r2
81113c1c:	11229340 	call	81122934 <sprintf>
									debug(fp, cPUSDebug );
81113c20:	d0a06217 	ldw	r2,-32376(gp)
81113c24:	e0ffdec4 	addi	r3,fp,-133
81113c28:	180b883a 	mov	r5,r3
81113c2c:	1009883a 	mov	r4,r2
81113c30:	1120fa40 	call	81120fa4 <fprintf>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
81113c34:	01204574 	movhi	r4,33045
81113c38:	210b9e04 	addi	r4,r4,11896
81113c3c:	11141e40 	call	811141e4 <bSendMessagePUStoMebTask>

								break;
81113c40:	00011906 	br	811140a8 <vParserCommTask+0xdcc>
							case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[7];
81113c44:	00a04574 	movhi	r2,33045
81113c48:	108b9e04 	addi	r2,r2,11896
81113c4c:	10800483 	ldbu	r2,18(r2)
81113c50:	10c03fcc 	andi	r3,r2,255
81113c54:	00a04574 	movhi	r2,33045
81113c58:	108b8b04 	addi	r2,r2,11820
81113c5c:	1100058b 	ldhu	r4,22(r2)
81113c60:	00a04574 	movhi	r2,33045
81113c64:	108b9e04 	addi	r2,r2,11896
81113c68:	18c00284 	addi	r3,r3,10
81113c6c:	18c7883a 	add	r3,r3,r3
81113c70:	10c5883a 	add	r2,r2,r3
81113c74:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81113c78:	00a04574 	movhi	r2,33045
81113c7c:	108b9e04 	addi	r2,r2,11896
81113c80:	10800483 	ldbu	r2,18(r2)
81113c84:	10800044 	addi	r2,r2,1
81113c88:	1007883a 	mov	r3,r2
81113c8c:	00a04574 	movhi	r2,33045
81113c90:	108b9e04 	addi	r2,r2,11896
81113c94:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[8];
81113c98:	00a04574 	movhi	r2,33045
81113c9c:	108b9e04 	addi	r2,r2,11896
81113ca0:	10800483 	ldbu	r2,18(r2)
81113ca4:	10c03fcc 	andi	r3,r2,255
81113ca8:	00a04574 	movhi	r2,33045
81113cac:	108b8b04 	addi	r2,r2,11820
81113cb0:	1100060b 	ldhu	r4,24(r2)
81113cb4:	00a04574 	movhi	r2,33045
81113cb8:	108b9e04 	addi	r2,r2,11896
81113cbc:	18c00284 	addi	r3,r3,10
81113cc0:	18c7883a 	add	r3,r3,r3
81113cc4:	10c5883a 	add	r2,r2,r3
81113cc8:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81113ccc:	00a04574 	movhi	r2,33045
81113cd0:	108b9e04 	addi	r2,r2,11896
81113cd4:	10800483 	ldbu	r2,18(r2)
81113cd8:	10800044 	addi	r2,r2,1
81113cdc:	1007883a 	mov	r3,r2
81113ce0:	00a04574 	movhi	r2,33045
81113ce4:	108b9e04 	addi	r2,r2,11896
81113ce8:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[9];
81113cec:	00a04574 	movhi	r2,33045
81113cf0:	108b9e04 	addi	r2,r2,11896
81113cf4:	10800483 	ldbu	r2,18(r2)
81113cf8:	10c03fcc 	andi	r3,r2,255
81113cfc:	00a04574 	movhi	r2,33045
81113d00:	108b8b04 	addi	r2,r2,11820
81113d04:	1100068b 	ldhu	r4,26(r2)
81113d08:	00a04574 	movhi	r2,33045
81113d0c:	108b9e04 	addi	r2,r2,11896
81113d10:	18c00284 	addi	r3,r3,10
81113d14:	18c7883a 	add	r3,r3,r3
81113d18:	10c5883a 	add	r2,r2,r3
81113d1c:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81113d20:	00a04574 	movhi	r2,33045
81113d24:	108b9e04 	addi	r2,r2,11896
81113d28:	10800483 	ldbu	r2,18(r2)
81113d2c:	10800044 	addi	r2,r2,1
81113d30:	1007883a 	mov	r3,r2
81113d34:	00a04574 	movhi	r2,33045
81113d38:	108b9e04 	addi	r2,r2,11896
81113d3c:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[10];
81113d40:	00a04574 	movhi	r2,33045
81113d44:	108b9e04 	addi	r2,r2,11896
81113d48:	10800483 	ldbu	r2,18(r2)
81113d4c:	10c03fcc 	andi	r3,r2,255
81113d50:	00a04574 	movhi	r2,33045
81113d54:	108b8b04 	addi	r2,r2,11820
81113d58:	1100070b 	ldhu	r4,28(r2)
81113d5c:	00a04574 	movhi	r2,33045
81113d60:	108b9e04 	addi	r2,r2,11896
81113d64:	18c00284 	addi	r3,r3,10
81113d68:	18c7883a 	add	r3,r3,r3
81113d6c:	10c5883a 	add	r2,r2,r3
81113d70:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81113d74:	00a04574 	movhi	r2,33045
81113d78:	108b9e04 	addi	r2,r2,11896
81113d7c:	10800483 	ldbu	r2,18(r2)
81113d80:	10800044 	addi	r2,r2,1
81113d84:	1007883a 	mov	r3,r2
81113d88:	00a04574 	movhi	r2,33045
81113d8c:	108b9e04 	addi	r2,r2,11896
81113d90:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[11];
81113d94:	00a04574 	movhi	r2,33045
81113d98:	108b9e04 	addi	r2,r2,11896
81113d9c:	10800483 	ldbu	r2,18(r2)
81113da0:	10c03fcc 	andi	r3,r2,255
81113da4:	00a04574 	movhi	r2,33045
81113da8:	108b8b04 	addi	r2,r2,11820
81113dac:	1100078b 	ldhu	r4,30(r2)
81113db0:	00a04574 	movhi	r2,33045
81113db4:	108b9e04 	addi	r2,r2,11896
81113db8:	18c00284 	addi	r3,r3,10
81113dbc:	18c7883a 	add	r3,r3,r3
81113dc0:	10c5883a 	add	r2,r2,r3
81113dc4:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81113dc8:	00a04574 	movhi	r2,33045
81113dcc:	108b9e04 	addi	r2,r2,11896
81113dd0:	10800483 	ldbu	r2,18(r2)
81113dd4:	10800044 	addi	r2,r2,1
81113dd8:	1007883a 	mov	r3,r2
81113ddc:	00a04574 	movhi	r2,33045
81113de0:	108b9e04 	addi	r2,r2,11896
81113de4:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[12];
81113de8:	00a04574 	movhi	r2,33045
81113dec:	108b9e04 	addi	r2,r2,11896
81113df0:	10800483 	ldbu	r2,18(r2)
81113df4:	10c03fcc 	andi	r3,r2,255
81113df8:	00a04574 	movhi	r2,33045
81113dfc:	108b8b04 	addi	r2,r2,11820
81113e00:	1100080b 	ldhu	r4,32(r2)
81113e04:	00a04574 	movhi	r2,33045
81113e08:	108b9e04 	addi	r2,r2,11896
81113e0c:	18c00284 	addi	r3,r3,10
81113e10:	18c7883a 	add	r3,r3,r3
81113e14:	10c5883a 	add	r2,r2,r3
81113e18:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81113e1c:	00a04574 	movhi	r2,33045
81113e20:	108b9e04 	addi	r2,r2,11896
81113e24:	10800483 	ldbu	r2,18(r2)
81113e28:	10800044 	addi	r2,r2,1
81113e2c:	1007883a 	mov	r3,r2
81113e30:	00a04574 	movhi	r2,33045
81113e34:	108b9e04 	addi	r2,r2,11896
81113e38:	10c00485 	stb	r3,18(r2)


								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81113e3c:	e0bfdec4 	addi	r2,fp,-133
81113e40:	01802004 	movi	r6,128
81113e44:	000b883a 	mov	r5,zero
81113e48:	1009883a 	mov	r4,r2
81113e4c:	11221a40 	call	811221a4 <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_RMAP_CONFIG_UPDATE:\n");
81113e50:	e0ffdec4 	addi	r3,fp,-133
81113e54:	00a04574 	movhi	r2,33045
81113e58:	10b57304 	addi	r2,r2,-10804
81113e5c:	1009883a 	mov	r4,r2
81113e60:	00800b84 	movi	r2,46
81113e64:	100d883a 	mov	r6,r2
81113e68:	200b883a 	mov	r5,r4
81113e6c:	1809883a 	mov	r4,r3
81113e70:	11220540 	call	81122054 <memcpy>
									debug(fp, cPUSDebug );
81113e74:	d0a06217 	ldw	r2,-32376(gp)
81113e78:	e0ffdec4 	addi	r3,fp,-133
81113e7c:	180b883a 	mov	r5,r3
81113e80:	1009883a 	mov	r4,r2
81113e84:	1120fa40 	call	81120fa4 <fprintf>
									sprintf(cPUSDebug, "- FEESIM_INSTANCE: %hu;\n", usiFeeInstL );
81113e88:	e0ffde0b 	ldhu	r3,-136(fp)
81113e8c:	e0bfdec4 	addi	r2,fp,-133
81113e90:	180d883a 	mov	r6,r3
81113e94:	01604574 	movhi	r5,33045
81113e98:	29757f04 	addi	r5,r5,-10756
81113e9c:	1009883a 	mov	r4,r2
81113ea0:	11229340 	call	81122934 <sprintf>
									debug(fp, cPUSDebug );
81113ea4:	d0a06217 	ldw	r2,-32376(gp)
81113ea8:	e0ffdec4 	addi	r3,fp,-133
81113eac:	180b883a 	mov	r5,r3
81113eb0:	1009883a 	mov	r4,r2
81113eb4:	1120fa40 	call	81120fa4 <fprintf>
									sprintf(cPUSDebug, "- MODE: %hu;\n", PreParsedLocal.usiValues[7] );
81113eb8:	00a04574 	movhi	r2,33045
81113ebc:	108b8b04 	addi	r2,r2,11820
81113ec0:	1080058b 	ldhu	r2,22(r2)
81113ec4:	10ffffcc 	andi	r3,r2,65535
81113ec8:	e0bfdec4 	addi	r2,fp,-133
81113ecc:	180d883a 	mov	r6,r3
81113ed0:	01604574 	movhi	r5,33045
81113ed4:	29758604 	addi	r5,r5,-10728
81113ed8:	1009883a 	mov	r4,r2
81113edc:	11229340 	call	81122934 <sprintf>
									debug(fp, cPUSDebug );
81113ee0:	d0a06217 	ldw	r2,-32376(gp)
81113ee4:	e0ffdec4 	addi	r3,fp,-133
81113ee8:	180b883a 	mov	r5,r3
81113eec:	1009883a 	mov	r4,r2
81113ef0:	1120fa40 	call	81120fa4 <fprintf>
									sprintf(cPUSDebug, "- LINK_SPEED: %hu;\n", PreParsedLocal.usiValues[8] );
81113ef4:	00a04574 	movhi	r2,33045
81113ef8:	108b8b04 	addi	r2,r2,11820
81113efc:	1080060b 	ldhu	r2,24(r2)
81113f00:	10ffffcc 	andi	r3,r2,65535
81113f04:	e0bfdec4 	addi	r2,fp,-133
81113f08:	180d883a 	mov	r6,r3
81113f0c:	01604574 	movhi	r5,33045
81113f10:	29758a04 	addi	r5,r5,-10712
81113f14:	1009883a 	mov	r4,r2
81113f18:	11229340 	call	81122934 <sprintf>
									debug(fp, cPUSDebug );
81113f1c:	d0a06217 	ldw	r2,-32376(gp)
81113f20:	e0ffdec4 	addi	r3,fp,-133
81113f24:	180b883a 	mov	r5,r3
81113f28:	1009883a 	mov	r4,r2
81113f2c:	1120fa40 	call	81120fa4 <fprintf>
									sprintf(cPUSDebug, "- LOGICAL_ADDR: 0x%02X;\n", PreParsedLocal.usiValues[9] );
81113f30:	00a04574 	movhi	r2,33045
81113f34:	108b8b04 	addi	r2,r2,11820
81113f38:	1080068b 	ldhu	r2,26(r2)
81113f3c:	10ffffcc 	andi	r3,r2,65535
81113f40:	e0bfdec4 	addi	r2,fp,-133
81113f44:	180d883a 	mov	r6,r3
81113f48:	01604574 	movhi	r5,33045
81113f4c:	29758f04 	addi	r5,r5,-10692
81113f50:	1009883a 	mov	r4,r2
81113f54:	11229340 	call	81122934 <sprintf>
									debug(fp, cPUSDebug );
81113f58:	d0a06217 	ldw	r2,-32376(gp)
81113f5c:	e0ffdec4 	addi	r3,fp,-133
81113f60:	180b883a 	mov	r5,r3
81113f64:	1009883a 	mov	r4,r2
81113f68:	1120fa40 	call	81120fa4 <fprintf>
									sprintf(cPUSDebug, "- DEST_NODE_ADDR: 0x%02X;\n", PreParsedLocal.usiValues[10] );
81113f6c:	00a04574 	movhi	r2,33045
81113f70:	108b8b04 	addi	r2,r2,11820
81113f74:	1080070b 	ldhu	r2,28(r2)
81113f78:	10ffffcc 	andi	r3,r2,65535
81113f7c:	e0bfdec4 	addi	r2,fp,-133
81113f80:	180d883a 	mov	r6,r3
81113f84:	01604574 	movhi	r5,33045
81113f88:	29759604 	addi	r5,r5,-10664
81113f8c:	1009883a 	mov	r4,r2
81113f90:	11229340 	call	81122934 <sprintf>
									debug(fp, cPUSDebug );
81113f94:	d0a06217 	ldw	r2,-32376(gp)
81113f98:	e0ffdec4 	addi	r3,fp,-133
81113f9c:	180b883a 	mov	r5,r3
81113fa0:	1009883a 	mov	r4,r2
81113fa4:	1120fa40 	call	81120fa4 <fprintf>
									sprintf(cPUSDebug, "- TIME_CODE_GEN: %hu;\n", PreParsedLocal.usiValues[11] );
81113fa8:	00a04574 	movhi	r2,33045
81113fac:	108b8b04 	addi	r2,r2,11820
81113fb0:	1080078b 	ldhu	r2,30(r2)
81113fb4:	10ffffcc 	andi	r3,r2,65535
81113fb8:	e0bfdec4 	addi	r2,fp,-133
81113fbc:	180d883a 	mov	r6,r3
81113fc0:	01604574 	movhi	r5,33045
81113fc4:	29759d04 	addi	r5,r5,-10636
81113fc8:	1009883a 	mov	r4,r2
81113fcc:	11229340 	call	81122934 <sprintf>
									debug(fp, cPUSDebug );
81113fd0:	d0a06217 	ldw	r2,-32376(gp)
81113fd4:	e0ffdec4 	addi	r3,fp,-133
81113fd8:	180b883a 	mov	r5,r3
81113fdc:	1009883a 	mov	r4,r2
81113fe0:	1120fa40 	call	81120fa4 <fprintf>
									sprintf(cPUSDebug, "- RMAP_KEY: 0x%02X;\n", PreParsedLocal.usiValues[12] );
81113fe4:	00a04574 	movhi	r2,33045
81113fe8:	108b8b04 	addi	r2,r2,11820
81113fec:	1080080b 	ldhu	r2,32(r2)
81113ff0:	10ffffcc 	andi	r3,r2,65535
81113ff4:	e0bfdec4 	addi	r2,fp,-133
81113ff8:	180d883a 	mov	r6,r3
81113ffc:	01604574 	movhi	r5,33045
81114000:	2975a304 	addi	r5,r5,-10612
81114004:	1009883a 	mov	r4,r2
81114008:	11229340 	call	81122934 <sprintf>
									debug(fp, cPUSDebug );
8111400c:	d0a06217 	ldw	r2,-32376(gp)
81114010:	e0ffdec4 	addi	r3,fp,-133
81114014:	180b883a 	mov	r5,r3
81114018:	1009883a 	mov	r4,r2
8111401c:	1120fa40 	call	81120fa4 <fprintf>
								#endif

								break;
81114020:	00002106 	br	811140a8 <vParserCommTask+0xdcc>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81114024:	e0bfdec4 	addi	r2,fp,-133
81114028:	01802004 	movi	r6,128
8111402c:	000b883a 	mov	r5,zero
81114030:	1009883a 	mov	r4,r2
81114034:	11221a40 	call	811221a4 <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
81114038:	00a04574 	movhi	r2,33045
8111403c:	108b9e04 	addi	r2,r2,11896
81114040:	1080030b 	ldhu	r2,12(r2)
81114044:	113fffcc 	andi	r4,r2,65535
81114048:	00a04574 	movhi	r2,33045
8111404c:	108b9e04 	addi	r2,r2,11896
81114050:	1080038b 	ldhu	r2,14(r2)
81114054:	117fffcc 	andi	r5,r2,65535
81114058:	00a04574 	movhi	r2,33045
8111405c:	108b9e04 	addi	r2,r2,11896
81114060:	1080040b 	ldhu	r2,16(r2)
81114064:	10bfffcc 	andi	r2,r2,65535
81114068:	e0ffdec4 	addi	r3,fp,-133
8111406c:	d8800015 	stw	r2,0(sp)
81114070:	280f883a 	mov	r7,r5
81114074:	200d883a 	mov	r6,r4
81114078:	01604574 	movhi	r5,33045
8111407c:	2974d204 	addi	r5,r5,-11448
81114080:	1809883a 	mov	r4,r3
81114084:	11229340 	call	81122934 <sprintf>
									debug(fp, cPUSDebug );
81114088:	d0a06217 	ldw	r2,-32376(gp)
8111408c:	e0ffdec4 	addi	r3,fp,-133
81114090:	180b883a 	mov	r5,r3
81114094:	1009883a 	mov	r4,r2
81114098:	1120fa40 	call	81120fa4 <fprintf>
								#endif							
								eParserMode = sWaitingMessage;
8111409c:	00800044 	movi	r2,1
811140a0:	e0bfdc15 	stw	r2,-144(fp)
								break;
811140a4:	0001883a 	nop
						}
                        break;
811140a8:	00000306 	br	811140b8 <vParserCommTask+0xddc>
                    default:
						eParserMode = sWaitingMessage;
811140ac:	00800044 	movi	r2,1
811140b0:	e0bfdc15 	stw	r2,-144(fp)
                        break;
811140b4:	0001883a 	nop
                }
				break;				
811140b8:	00000306 	br	811140c8 <vParserCommTask+0xdec>
			default:
				eParserMode = sWaitingMessage;
811140bc:	00800044 	movi	r2,1
811140c0:	e0bfdc15 	stw	r2,-144(fp)
				break;
811140c4:	0001883a 	nop
		}
	}
811140c8:	003c9406 	br	8111331c <__reset+0xfb0f331c>

811140cc <getPreParsedPacket>:
}

bool getPreParsedPacket( tPreParsed *xPreParsedParser ) {
811140cc:	defffb04 	addi	sp,sp,-20
811140d0:	de00012e 	bgeu	sp,et,811140d8 <getPreParsedPacket+0xc>
811140d4:	003b68fa 	trap	3
811140d8:	dfc00415 	stw	ra,16(sp)
811140dc:	df000315 	stw	fp,12(sp)
811140e0:	df000304 	addi	fp,sp,12
811140e4:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
811140e8:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i;

	OSMutexPend(xMutexPreParsed, 0, &error_code); /*Blocking*/
811140ec:	d0a06b17 	ldw	r2,-32340(gp)
811140f0:	e0fffe44 	addi	r3,fp,-7
811140f4:	180d883a 	mov	r6,r3
811140f8:	000b883a 	mov	r5,zero
811140fc:	1009883a 	mov	r4,r2
81114100:	113c4b40 	call	8113c4b4 <OSMutexPend>
	if (error_code == OS_ERR_NONE) {
81114104:	e0bffe43 	ldbu	r2,-7(fp)
81114108:	10803fcc 	andi	r2,r2,255
8111410c:	10002e1e 	bne	r2,zero,811141c8 <getPreParsedPacket+0xfc>
		/* Got the Mutex */
		/*For now, will only get the first, not the packet that is waiting for longer time*/
		for( i = 0; i < N_PREPARSED_ENTRIES; i++)
81114110:	e03ffe05 	stb	zero,-8(fp)
81114114:	00002506 	br	811141ac <getPreParsedPacket+0xe0>
		{

            if ( xPreParsed[i].cType != 0 ) {
81114118:	e0fffe03 	ldbu	r3,-8(fp)
8111411c:	00a045b4 	movhi	r2,33046
81114120:	10992104 	addi	r2,r2,25732
81114124:	18c01324 	muli	r3,r3,76
81114128:	10c5883a 	add	r2,r2,r3
8111412c:	10800104 	addi	r2,r2,4
81114130:	10800003 	ldbu	r2,0(r2)
81114134:	10803fcc 	andi	r2,r2,255
81114138:	1080201c 	xori	r2,r2,128
8111413c:	10bfe004 	addi	r2,r2,-128
81114140:	10001726 	beq	r2,zero,811141a0 <getPreParsedPacket+0xd4>
                /* Locate a filled PreParsed variable in the array*/
            	/* Perform a copy to a local variable */
            	(*xPreParsedParser) = xPreParsed[i];
81114144:	e0fffe03 	ldbu	r3,-8(fp)
81114148:	e13fff17 	ldw	r4,-4(fp)
8111414c:	00a045b4 	movhi	r2,33046
81114150:	10992104 	addi	r2,r2,25732
81114154:	18c01324 	muli	r3,r3,76
81114158:	10c5883a 	add	r2,r2,r3
8111415c:	2007883a 	mov	r3,r4
81114160:	1009883a 	mov	r4,r2
81114164:	00801304 	movi	r2,76
81114168:	100d883a 	mov	r6,r2
8111416c:	200b883a 	mov	r5,r4
81114170:	1809883a 	mov	r4,r3
81114174:	11220540 	call	81122054 <memcpy>
                bSuccess = TRUE;
81114178:	00800044 	movi	r2,1
8111417c:	e0bffd15 	stw	r2,-12(fp)
                xPreParsed[i].cType = 0;
81114180:	e0fffe03 	ldbu	r3,-8(fp)
81114184:	00a045b4 	movhi	r2,33046
81114188:	10992104 	addi	r2,r2,25732
8111418c:	18c01324 	muli	r3,r3,76
81114190:	10c5883a 	add	r2,r2,r3
81114194:	10800104 	addi	r2,r2,4
81114198:	10000005 	stb	zero,0(r2)
                break;
8111419c:	00000606 	br	811141b8 <getPreParsedPacket+0xec>

	OSMutexPend(xMutexPreParsed, 0, &error_code); /*Blocking*/
	if (error_code == OS_ERR_NONE) {
		/* Got the Mutex */
		/*For now, will only get the first, not the packet that is waiting for longer time*/
		for( i = 0; i < N_PREPARSED_ENTRIES; i++)
811141a0:	e0bffe03 	ldbu	r2,-8(fp)
811141a4:	10800044 	addi	r2,r2,1
811141a8:	e0bffe05 	stb	r2,-8(fp)
811141ac:	e0bffe03 	ldbu	r2,-8(fp)
811141b0:	10800230 	cmpltui	r2,r2,8
811141b4:	103fd81e 	bne	r2,zero,81114118 <__reset+0xfb0f4118>
                bSuccess = TRUE;
                xPreParsed[i].cType = 0;
                break;
            }
		}
		OSMutexPost(xMutexPreParsed);
811141b8:	d0a06b17 	ldw	r2,-32340(gp)
811141bc:	1009883a 	mov	r4,r2
811141c0:	113ca580 	call	8113ca58 <OSMutexPost>
811141c4:	00000106 	br	811141cc <getPreParsedPacket+0x100>
	} else {
		/* Couldn't get Mutex. (Should not get here since is a blocking call without timeout)*/
		vFailGetxMutexPreParsedParserRxTask();
811141c8:	111bcfc0 	call	8111bcfc <vFailGetxMutexPreParsedParserRxTask>
	}
	return bSuccess;
811141cc:	e0bffd17 	ldw	r2,-12(fp)
}
811141d0:	e037883a 	mov	sp,fp
811141d4:	dfc00117 	ldw	ra,4(sp)
811141d8:	df000017 	ldw	fp,0(sp)
811141dc:	dec00204 	addi	sp,sp,8
811141e0:	f800283a 	ret

811141e4 <bSendMessagePUStoMebTask>:

/* Search for some free location in the xPus array to put the full command to send to the meb task */
bool bSendMessagePUStoMebTask( tTMPus *xPusL ) {
811141e4:	defffa04 	addi	sp,sp,-24
811141e8:	de00012e 	bgeu	sp,et,811141f0 <bSendMessagePUStoMebTask+0xc>
811141ec:	003b68fa 	trap	3
811141f0:	dfc00515 	stw	ra,20(sp)
811141f4:	df000415 	stw	fp,16(sp)
811141f8:	df000404 	addi	fp,sp,16
811141fc:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81114200:	e03ffc15 	stw	zero,-16(fp)
    INT8U error_code;
    tQMask xCdmLocal;
    unsigned char i = 0;
81114204:	e03ffd05 	stb	zero,-12(fp)

    bSuccess = FALSE;
81114208:	e03ffc15 	stw	zero,-16(fp)
    xCdmLocal.ulWord = 0;
8111420c:	e03ffe15 	stw	zero,-8(fp)
    OSMutexPend(xMutexPus, 10, &error_code); /* Try to get mutex that protects the xPus buffer. Wait max 10 ticks = 10 ms */
81114210:	d0a07317 	ldw	r2,-32308(gp)
81114214:	e0fffd44 	addi	r3,fp,-11
81114218:	180d883a 	mov	r6,r3
8111421c:	01400284 	movi	r5,10
81114220:	1009883a 	mov	r4,r2
81114224:	113c4b40 	call	8113c4b4 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
81114228:	e0bffd43 	ldbu	r2,-11(fp)
8111422c:	10803fcc 	andi	r2,r2,255
81114230:	1000401e 	bne	r2,zero,81114334 <bSendMessagePUStoMebTask+0x150>

        for(i = 0; i < N_PUS_PIPE; i++)
81114234:	e03ffd05 	stb	zero,-12(fp)
81114238:	00003806 	br	8111431c <bSendMessagePUStoMebTask+0x138>
        {
            if ( xPus[i].bInUse == FALSE ) {
8111423c:	e0fffd03 	ldbu	r3,-12(fp)
81114240:	00a04574 	movhi	r2,33045
81114244:	10964304 	addi	r2,r2,22796
81114248:	18c01524 	muli	r3,r3,84
8111424c:	10c5883a 	add	r2,r2,r3
81114250:	10800104 	addi	r2,r2,4
81114254:	10800017 	ldw	r2,0(r2)
81114258:	10002d1e 	bne	r2,zero,81114310 <bSendMessagePUStoMebTask+0x12c>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
            	xPus[i] = (*xPusL);
8111425c:	e0fffd03 	ldbu	r3,-12(fp)
81114260:	00a04574 	movhi	r2,33045
81114264:	10964304 	addi	r2,r2,22796
81114268:	18c01524 	muli	r3,r3,84
8111426c:	10c7883a 	add	r3,r2,r3
81114270:	e0bfff17 	ldw	r2,-4(fp)
81114274:	1009883a 	mov	r4,r2
81114278:	00801504 	movi	r2,84
8111427c:	100d883a 	mov	r6,r2
81114280:	200b883a 	mov	r5,r4
81114284:	1809883a 	mov	r4,r3
81114288:	11220540 	call	81122054 <memcpy>
            	xPus[i].bInUse = TRUE;
8111428c:	e0fffd03 	ldbu	r3,-12(fp)
81114290:	00a04574 	movhi	r2,33045
81114294:	10964304 	addi	r2,r2,22796
81114298:	18c01524 	muli	r3,r3,84
8111429c:	10c5883a 	add	r2,r2,r3
811142a0:	10800104 	addi	r2,r2,4
811142a4:	00c00044 	movi	r3,1
811142a8:	10c00015 	stw	r3,0(r2)

            	/* Build the command to Meb using the Mask Queue */
            	xCdmLocal.ucByte[3] = M_MEB_ADDR;
811142ac:	00800044 	movi	r2,1
811142b0:	e0bffec5 	stb	r2,-5(fp)
            	xCdmLocal.ucByte[2] = Q_MEB_PUS;
811142b4:	00800044 	movi	r2,1
811142b8:	e0bffe85 	stb	r2,-6(fp)

            	/* Sync the Meb task and tell that has a PUS command waiting */
            	error_code = OSQPost(xMebQ, (void *)xCdmLocal.ulWord);
811142bc:	d0a06917 	ldw	r2,-32348(gp)
811142c0:	e0fffe17 	ldw	r3,-8(fp)
811142c4:	180b883a 	mov	r5,r3
811142c8:	1009883a 	mov	r4,r2
811142cc:	113d9d00 	call	8113d9d0 <OSQPost>
811142d0:	e0bffd45 	stb	r2,-11(fp)
                if ( error_code != OS_ERR_NONE ) {
811142d4:	e0bffd43 	ldbu	r2,-11(fp)
811142d8:	10803fcc 	andi	r2,r2,255
811142dc:	10000926 	beq	r2,zero,81114304 <bSendMessagePUStoMebTask+0x120>
                	vFailSendPUStoMebTask();
811142e0:	111cbec0 	call	8111cbec <vFailSendPUStoMebTask>
                	xPus[i].bInUse = FALSE;
811142e4:	e0fffd03 	ldbu	r3,-12(fp)
811142e8:	00a04574 	movhi	r2,33045
811142ec:	10964304 	addi	r2,r2,22796
811142f0:	18c01524 	muli	r3,r3,84
811142f4:	10c5883a 	add	r2,r2,r3
811142f8:	10800104 	addi	r2,r2,4
811142fc:	10000015 	stw	zero,0(r2)
                } else
                    bSuccess = TRUE;
                break;
81114300:	00000906 	br	81114328 <bSendMessagePUStoMebTask+0x144>
            	error_code = OSQPost(xMebQ, (void *)xCdmLocal.ulWord);
                if ( error_code != OS_ERR_NONE ) {
                	vFailSendPUStoMebTask();
                	xPus[i].bInUse = FALSE;
                } else
                    bSuccess = TRUE;
81114304:	00800044 	movi	r2,1
81114308:	e0bffc15 	stw	r2,-16(fp)
                break;
8111430c:	00000606 	br	81114328 <bSendMessagePUStoMebTask+0x144>
    bSuccess = FALSE;
    xCdmLocal.ulWord = 0;
    OSMutexPend(xMutexPus, 10, &error_code); /* Try to get mutex that protects the xPus buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {

        for(i = 0; i < N_PUS_PIPE; i++)
81114310:	e0bffd03 	ldbu	r2,-12(fp)
81114314:	10800044 	addi	r2,r2,1
81114318:	e0bffd05 	stb	r2,-12(fp)
8111431c:	e0bffd03 	ldbu	r2,-12(fp)
81114320:	10800130 	cmpltui	r2,r2,4
81114324:	103fc51e 	bne	r2,zero,8111423c <__reset+0xfb0f423c>
                } else
                    bSuccess = TRUE;
                break;
            }
        }
        OSMutexPost(xMutexPus);
81114328:	d0a07317 	ldw	r2,-32308(gp)
8111432c:	1009883a 	mov	r4,r2
81114330:	113ca580 	call	8113ca58 <OSMutexPost>
    }

    return bSuccess;
81114334:	e0bffc17 	ldw	r2,-16(fp)
}
81114338:	e037883a 	mov	sp,fp
8111433c:	dfc00117 	ldw	ra,4(sp)
81114340:	df000017 	ldw	fp,0(sp)
81114344:	dec00204 	addi	sp,sp,8
81114348:	f800283a 	ret

8111434c <vReceiverUartTask>:


#include "receiver_uart_task.h"


void vReceiverUartTask(void *task_data) {
8111434c:	deffab04 	addi	sp,sp,-340
81114350:	de00012e 	bgeu	sp,et,81114358 <vReceiverUartTask+0xc>
81114354:	003b68fa 	trap	3
81114358:	dfc05415 	stw	ra,336(sp)
8111435c:	df005315 	stw	fp,332(sp)
81114360:	df005304 	addi	fp,sp,332
81114364:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81114368:	e03fae15 	stw	zero,-328(fp)
    char cReceive[SIZE_RCV_BUFFER+64];
    tReaderStates eReaderRXMode;
    static tPreParsed xPreParsedReader;

    #ifdef DEBUG_ON
        debug(fp,"Receiver UART Task. (Task on)\n");
8111436c:	d0a06217 	ldw	r2,-32376(gp)
81114370:	100f883a 	mov	r7,r2
81114374:	01800784 	movi	r6,30
81114378:	01400044 	movi	r5,1
8111437c:	01204574 	movhi	r4,33045
81114380:	2135a904 	addi	r4,r4,-10588
81114384:	11216400 	call	81121640 <fwrite>
    #endif

    eReaderRXMode = sRConfiguring;
81114388:	e03fad15 	stw	zero,-332(fp)

    for(;;) {

        switch (eReaderRXMode)
8111438c:	e0bfad17 	ldw	r2,-332(fp)
81114390:	10c00060 	cmpeqi	r3,r2,1
81114394:	1800091e 	bne	r3,zero,811143bc <vReceiverUartTask+0x70>
81114398:	0080052e 	bgeu	zero,r2,811143b0 <vReceiverUartTask+0x64>
8111439c:	10c000a0 	cmpeqi	r3,r2,2
811143a0:	18005d1e 	bne	r3,zero,81114518 <vReceiverUartTask+0x1cc>
811143a4:	108000e0 	cmpeqi	r2,r2,3
811143a8:	10006e1e 	bne	r2,zero,81114564 <vReceiverUartTask+0x218>
811143ac:	00007706 	br	8111458c <vReceiverUartTask+0x240>
        {
            case sRConfiguring:
                /* For future implementations */
                eReaderRXMode = sGetRxUart;
811143b0:	00800044 	movi	r2,1
811143b4:	e0bfad15 	stw	r2,-332(fp)
                break;
811143b8:	00007706 	br	81114598 <vReceiverUartTask+0x24c>
            case sGetRxUart:

                memset(cReceiveBuffer, 0, SIZE_RCV_BUFFER);
811143bc:	e0bfaf04 	addi	r2,fp,-324
811143c0:	01802004 	movi	r6,128
811143c4:	000b883a 	mov	r5,zero
811143c8:	1009883a 	mov	r4,r2
811143cc:	11221a40 	call	811221a4 <memset>
                scanf("%s", cReceive);
811143d0:	e0bfcf04 	addi	r2,fp,-196
811143d4:	100b883a 	mov	r5,r2
811143d8:	01204574 	movhi	r4,33045
811143dc:	2135b104 	addi	r4,r4,-10556
811143e0:	11228580 	call	81122858 <scanf>
                memcpy(cReceiveBuffer, cReceive, (SIZE_RCV_BUFFER -1) ); /* Make that there's a zero terminator */
811143e4:	e0ffcf04 	addi	r3,fp,-196
811143e8:	e0bfaf04 	addi	r2,fp,-324
811143ec:	01801fc4 	movi	r6,127
811143f0:	180b883a 	mov	r5,r3
811143f4:	1009883a 	mov	r4,r2
811143f8:	11220540 	call	81122054 <memcpy>
                bSuccess = bPreParserV2( cReceiveBuffer , &xPreParsedReader );
811143fc:	e0bfaf04 	addi	r2,fp,-324
81114400:	01604574 	movhi	r5,33045
81114404:	294bb304 	addi	r5,r5,11980
81114408:	1009883a 	mov	r4,r2
8111440c:	11149f00 	call	811149f0 <bPreParserV2>
81114410:	e0bfae15 	stw	r2,-328(fp)

                if ( bSuccess == TRUE ) {
81114414:	e0bfae17 	ldw	r2,-328(fp)
81114418:	10800058 	cmpnei	r2,r2,1
8111441c:	1000281e 	bne	r2,zero,811144c0 <vReceiverUartTask+0x174>

                    if ( (xPreParsedReader.cType == START_REQUEST_CHAR) || (xPreParsedReader.cType == START_REPLY_CHAR) ) {
81114420:	00a04574 	movhi	r2,33045
81114424:	108bb304 	addi	r2,r2,11980
81114428:	10800103 	ldbu	r2,4(r2)
8111442c:	10803fcc 	andi	r2,r2,255
81114430:	1080201c 	xori	r2,r2,128
81114434:	10bfe004 	addi	r2,r2,-128
81114438:	10800fe0 	cmpeqi	r2,r2,63
8111443c:	1000081e 	bne	r2,zero,81114460 <vReceiverUartTask+0x114>
81114440:	00a04574 	movhi	r2,33045
81114444:	108bb304 	addi	r2,r2,11980
81114448:	10800103 	ldbu	r2,4(r2)
8111444c:	10803fcc 	andi	r2,r2,255
81114450:	1080201c 	xori	r2,r2,128
81114454:	10bfe004 	addi	r2,r2,-128
81114458:	10800858 	cmpnei	r2,r2,33
8111445c:	1000031e 	bne	r2,zero,8111446c <vReceiverUartTask+0x120>
                        /* The packet is a request or reply sent by the NUC*/
                        eReaderRXMode = sSendToParser;
81114460:	00800084 	movi	r2,2
81114464:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
81114468:	00004b06 	br	81114598 <vReceiverUartTask+0x24c>
                        /* The packet is a request or reply sent by the NUC*/
                        eReaderRXMode = sSendToParser;
                    } else {
                        /* The packet is an ACK or NACK sent by the NUC*/
                        /* If is a Nack, do nothing. The packet will be retransmited by the timeout checker. */
                        if ( xPreParsedReader.cType == NACK_CHAR ) {
8111446c:	00a04574 	movhi	r2,33045
81114470:	108bb304 	addi	r2,r2,11980
81114474:	10800103 	ldbu	r2,4(r2)
81114478:	10803fcc 	andi	r2,r2,255
8111447c:	1080201c 	xori	r2,r2,128
81114480:	10bfe004 	addi	r2,r2,-128
81114484:	108008d8 	cmpnei	r2,r2,35
81114488:	10000a1e 	bne	r2,zero,811144b4 <vReceiverUartTask+0x168>
                            eReaderRXMode = sGetRxUart;
8111448c:	00800044 	movi	r2,1
81114490:	e0bfad15 	stw	r2,-332(fp)
                            #ifdef DEBUG_ON
                                debug(fp,"Nack Received. Do nothing!\n");
81114494:	d0a06217 	ldw	r2,-32376(gp)
81114498:	100f883a 	mov	r7,r2
8111449c:	018006c4 	movi	r6,27
811144a0:	01400044 	movi	r5,1
811144a4:	01204574 	movhi	r4,33045
811144a8:	2135b204 	addi	r4,r4,-10552
811144ac:	11216400 	call	81121640 <fwrite>
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
811144b0:	00003906 	br	81114598 <vReceiverUartTask+0x24c>
                            eReaderRXMode = sGetRxUart;
                            #ifdef DEBUG_ON
                                debug(fp,"Nack Received. Do nothing!\n");
                            #endif
                        } else
                            eReaderRXMode = sSendToACKReceiver;
811144b4:	008000c4 	movi	r2,3
811144b8:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
811144bc:	00003606 	br	81114598 <vReceiverUartTask+0x24c>

                    }

                } else {
                    /*Should Send NACK - Mocking value the only parte that metters is the "cType = '#'" part */
                    xPreParsedReader.cType = '#';
811144c0:	00a04574 	movhi	r2,33045
811144c4:	108bb304 	addi	r2,r2,11980
811144c8:	00c008c4 	movi	r3,35
811144cc:	10c00105 	stb	r3,4(r2)
                    xPreParsedReader.cCommand = '.';
811144d0:	00a04574 	movhi	r2,33045
811144d4:	108bb304 	addi	r2,r2,11980
811144d8:	00c00b84 	movi	r3,46
811144dc:	10c00145 	stb	r3,5(r2)
                    xPreParsedReader.usiValues[0] = 1;
811144e0:	00a04574 	movhi	r2,33045
811144e4:	108bb304 	addi	r2,r2,11980
811144e8:	00c00044 	movi	r3,1
811144ec:	10c0020d 	sth	r3,8(r2)

                    /*Try to send ack to the Ack Sender Task*/
                    bSuccess = setPreAckSenderFreePos( &xPreParsedReader );
811144f0:	01204574 	movhi	r4,33045
811144f4:	210bb304 	addi	r4,r4,11980
811144f8:	11146d80 	call	811146d8 <setPreAckSenderFreePos>
811144fc:	e0bfae15 	stw	r2,-328(fp)
                    if ( bSuccess == FALSE ) {
81114500:	e0bfae17 	ldw	r2,-328(fp)
81114504:	1000011e 	bne	r2,zero,8111450c <vReceiverUartTask+0x1c0>
                        vFailSendNack();
81114508:	111be340 	call	8111be34 <vFailSendNack>
                    }
                    eReaderRXMode = sGetRxUart;
8111450c:	00800044 	movi	r2,1
81114510:	e0bfad15 	stw	r2,-332(fp)
                }

                break;
81114514:	00002006 	br	81114598 <vReceiverUartTask+0x24c>
            case sSendToParser:

                /* Try to send ack to the Ack Sender Task*/
                bSuccess = setPreAckSenderFreePos( &xPreParsedReader );
81114518:	01204574 	movhi	r4,33045
8111451c:	210bb304 	addi	r4,r4,11980
81114520:	11146d80 	call	811146d8 <setPreAckSenderFreePos>
81114524:	e0bfae15 	stw	r2,-328(fp)
                if ( bSuccess == TRUE ) {
81114528:	e0bfae17 	ldw	r2,-328(fp)
8111452c:	10800058 	cmpnei	r2,r2,1
81114530:	1000081e 	bne	r2,zero,81114554 <vReceiverUartTask+0x208>
                    /* If was possible to send ack, then try to send the command to the Parser Task*/
                    bSuccess = setPreParsedFreePos( &xPreParsedReader );
81114534:	01204574 	movhi	r4,33045
81114538:	210bb304 	addi	r4,r4,11980
8111453c:	111459c0 	call	8111459c <setPreParsedFreePos>
81114540:	e0bfae15 	stw	r2,-328(fp)
                    if ( bSuccess == FALSE ) {
81114544:	e0bfae17 	ldw	r2,-328(fp)
81114548:	1000031e 	bne	r2,zero,81114558 <vReceiverUartTask+0x20c>
                        //TODO
                        /* At this point ack was sent but the command was not sent to the Parser task
                           should sent an error message for the NUC and maye to the SGSE*/
                        vFailSetPreParsedBuffer();
8111454c:	111bf040 	call	8111bf04 <vFailSetPreParsedBuffer>
81114550:	00000106 	br	81114558 <vReceiverUartTask+0x20c>
                    }
                } else {
                    vFailSetPreAckSenderBuffer();
81114554:	111be9c0 	call	8111be9c <vFailSetPreAckSenderBuffer>
                }
                /* If is not possible to send the ACK for this command then we don't process the command,
                   because it will be sent again by the NUC and we won't wast processing performing the command twice.*/
                eReaderRXMode = sGetRxUart;
81114558:	00800044 	movi	r2,1
8111455c:	e0bfad15 	stw	r2,-332(fp)
                break;
81114560:	00000d06 	br	81114598 <vReceiverUartTask+0x24c>
            case sSendToACKReceiver:

                bSuccess = setPreAckReceiverFreePos( &xPreParsedReader );
81114564:	01204574 	movhi	r4,33045
81114568:	210bb304 	addi	r4,r4,11980
8111456c:	11148540 	call	81114854 <setPreAckReceiverFreePos>
81114570:	e0bfae15 	stw	r2,-328(fp)
                if ( bSuccess == FALSE ) {
81114574:	e0bfae17 	ldw	r2,-328(fp)
81114578:	1000011e 	bne	r2,zero,81114580 <vReceiverUartTask+0x234>
                    /*If was not possible to receive the ack do nothing.*/
                    vFailSetPreAckReceiverBuffer();
8111457c:	111bf6c0 	call	8111bf6c <vFailSetPreAckReceiverBuffer>
                }
                eReaderRXMode = sGetRxUart;
81114580:	00800044 	movi	r2,1
81114584:	e0bfad15 	stw	r2,-332(fp)
                break;
81114588:	00000306 	br	81114598 <vReceiverUartTask+0x24c>
            default:
                eReaderRXMode = sGetRxUart;
8111458c:	00800044 	movi	r2,1
81114590:	e0bfad15 	stw	r2,-332(fp)
                break;
81114594:	0001883a 	nop
        }

    }
81114598:	003f7c06 	br	8111438c <__reset+0xfb0f438c>

8111459c <setPreParsedFreePos>:
}


/* Search for a Free location to put the pre parsed packet in the pipe for the ParserTask */
bool setPreParsedFreePos( tPreParsed *xPrePReader ) {
8111459c:	defffb04 	addi	sp,sp,-20
811145a0:	de00012e 	bgeu	sp,et,811145a8 <setPreParsedFreePos+0xc>
811145a4:	003b68fa 	trap	3
811145a8:	dfc00415 	stw	ra,16(sp)
811145ac:	df000315 	stw	fp,12(sp)
811145b0:	df000304 	addi	fp,sp,12
811145b4:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
811145b8:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
811145bc:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
811145c0:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexPreParsed, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
811145c4:	d0a06b17 	ldw	r2,-32340(gp)
811145c8:	e0fffe44 	addi	r3,fp,-7
811145cc:	180d883a 	mov	r6,r3
811145d0:	01400284 	movi	r5,10
811145d4:	1009883a 	mov	r4,r2
811145d8:	113c4b40 	call	8113c4b4 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
811145dc:	e0bffe43 	ldbu	r2,-7(fp)
811145e0:	10803fcc 	andi	r2,r2,255
811145e4:	1000361e 	bne	r2,zero,811146c0 <setPreParsedFreePos+0x124>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_PREPARSED_ENTRIES; i++ )
811145e8:	e03ffe05 	stb	zero,-8(fp)
811145ec:	00002e06 	br	811146a8 <setPreParsedFreePos+0x10c>
        {
            if ( xPreParsed[i].cType == 0 ) {
811145f0:	e0fffe03 	ldbu	r3,-8(fp)
811145f4:	00a045b4 	movhi	r2,33046
811145f8:	10992104 	addi	r2,r2,25732
811145fc:	18c01324 	muli	r3,r3,76
81114600:	10c5883a 	add	r2,r2,r3
81114604:	10800104 	addi	r2,r2,4
81114608:	10800003 	ldbu	r2,0(r2)
8111460c:	10803fcc 	andi	r2,r2,255
81114610:	1080201c 	xori	r2,r2,128
81114614:	10bfe004 	addi	r2,r2,-128
81114618:	1000201e 	bne	r2,zero,8111469c <setPreParsedFreePos+0x100>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xPreParsed[i] = (*xPrePReader);
8111461c:	e0fffe03 	ldbu	r3,-8(fp)
81114620:	00a045b4 	movhi	r2,33046
81114624:	10992104 	addi	r2,r2,25732
81114628:	18c01324 	muli	r3,r3,76
8111462c:	10c7883a 	add	r3,r2,r3
81114630:	e0bfff17 	ldw	r2,-4(fp)
81114634:	1009883a 	mov	r4,r2
81114638:	00801304 	movi	r2,76
8111463c:	100d883a 	mov	r6,r2
81114640:	200b883a 	mov	r5,r4
81114644:	1809883a 	mov	r4,r3
81114648:	11220540 	call	81122054 <memcpy>
                error_code = OSSemPost(xSemCountPreParsed);
8111464c:	d0a06417 	ldw	r2,-32368(gp)
81114650:	1009883a 	mov	r4,r2
81114654:	113e8480 	call	8113e848 <OSSemPost>
81114658:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code == OS_ERR_NONE ) {
8111465c:	e0bffe43 	ldbu	r2,-7(fp)
81114660:	10803fcc 	andi	r2,r2,255
81114664:	1000031e 	bne	r2,zero,81114674 <setPreParsedFreePos+0xd8>
                    bSuccess = TRUE;
81114668:	00800044 	movi	r2,1
8111466c:	e0bffd15 	stw	r2,-12(fp)
                } else {
                    vFailSendPreParsedSemaphore();
                    xPreParsed[i].cType = 0;
                    bSuccess = FALSE;
                }
                break;
81114670:	00001006 	br	811146b4 <setPreParsedFreePos+0x118>
                xPreParsed[i] = (*xPrePReader);
                error_code = OSSemPost(xSemCountPreParsed);
                if ( error_code == OS_ERR_NONE ) {
                    bSuccess = TRUE;
                } else {
                    vFailSendPreParsedSemaphore();
81114674:	111b5540 	call	8111b554 <vFailSendPreParsedSemaphore>
                    xPreParsed[i].cType = 0;
81114678:	e0fffe03 	ldbu	r3,-8(fp)
8111467c:	00a045b4 	movhi	r2,33046
81114680:	10992104 	addi	r2,r2,25732
81114684:	18c01324 	muli	r3,r3,76
81114688:	10c5883a 	add	r2,r2,r3
8111468c:	10800104 	addi	r2,r2,4
81114690:	10000005 	stb	zero,0(r2)
                    bSuccess = FALSE;
81114694:	e03ffd15 	stw	zero,-12(fp)
                }
                break;
81114698:	00000606 	br	811146b4 <setPreParsedFreePos+0x118>
    bSuccess = FALSE;
    OSMutexPend(xMutexPreParsed, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_PREPARSED_ENTRIES; i++ )
8111469c:	e0bffe03 	ldbu	r2,-8(fp)
811146a0:	10800044 	addi	r2,r2,1
811146a4:	e0bffe05 	stb	r2,-8(fp)
811146a8:	e0bffe03 	ldbu	r2,-8(fp)
811146ac:	10800230 	cmpltui	r2,r2,8
811146b0:	103fcf1e 	bne	r2,zero,811145f0 <__reset+0xfb0f45f0>
                    bSuccess = FALSE;
                }
                break;
            }
        }
        OSMutexPost(xMutexPreParsed);
811146b4:	d0a06b17 	ldw	r2,-32340(gp)
811146b8:	1009883a 	mov	r4,r2
811146bc:	113ca580 	call	8113ca58 <OSMutexPost>
    }
    return bSuccess;
811146c0:	e0bffd17 	ldw	r2,-12(fp)
}
811146c4:	e037883a 	mov	sp,fp
811146c8:	dfc00117 	ldw	ra,4(sp)
811146cc:	df000017 	ldw	fp,0(sp)
811146d0:	dec00204 	addi	sp,sp,8
811146d4:	f800283a 	ret

811146d8 <setPreAckSenderFreePos>:



/* Search for some free location in the xSenderACK array, that comunicates with the AckSenderTask */
bool setPreAckSenderFreePos( tPreParsed *xPrePReader ) {
811146d8:	defffb04 	addi	sp,sp,-20
811146dc:	de00012e 	bgeu	sp,et,811146e4 <setPreAckSenderFreePos+0xc>
811146e0:	003b68fa 	trap	3
811146e4:	dfc00415 	stw	ra,16(sp)
811146e8:	df000315 	stw	fp,12(sp)
811146ec:	df000304 	addi	fp,sp,12
811146f0:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
811146f4:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
811146f8:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
811146fc:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexSenderACK, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
81114700:	d0a07217 	ldw	r2,-32312(gp)
81114704:	e0fffe44 	addi	r3,fp,-7
81114708:	180d883a 	mov	r6,r3
8111470c:	01400284 	movi	r5,10
81114710:	1009883a 	mov	r4,r2
81114714:	113c4b40 	call	8113c4b4 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
81114718:	e0bffe43 	ldbu	r2,-7(fp)
8111471c:	10803fcc 	andi	r2,r2,255
81114720:	1000461e 	bne	r2,zero,8111483c <setPreAckSenderFreePos+0x164>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for(i = 0; i < N_ACKS_SENDER; i++)
81114724:	e03ffe05 	stb	zero,-8(fp)
81114728:	00003e06 	br	81114824 <setPreAckSenderFreePos+0x14c>
        {
            if ( xSenderACK[i].cType == 0 ) {
8111472c:	e0fffe03 	ldbu	r3,-8(fp)
81114730:	00a045b4 	movhi	r2,33046
81114734:	10991904 	addi	r2,r2,25700
81114738:	18c7883a 	add	r3,r3,r3
8111473c:	18c7883a 	add	r3,r3,r3
81114740:	10c5883a 	add	r2,r2,r3
81114744:	10800003 	ldbu	r2,0(r2)
81114748:	10803fcc 	andi	r2,r2,255
8111474c:	1080201c 	xori	r2,r2,128
81114750:	10bfe004 	addi	r2,r2,-128
81114754:	1000301e 	bne	r2,zero,81114818 <setPreAckSenderFreePos+0x140>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xSenderACK[i].cType = xPrePReader->cType;
81114758:	e0fffe03 	ldbu	r3,-8(fp)
8111475c:	e0bfff17 	ldw	r2,-4(fp)
81114760:	11000103 	ldbu	r4,4(r2)
81114764:	00a045b4 	movhi	r2,33046
81114768:	10991904 	addi	r2,r2,25700
8111476c:	18c7883a 	add	r3,r3,r3
81114770:	18c7883a 	add	r3,r3,r3
81114774:	10c5883a 	add	r2,r2,r3
81114778:	11000005 	stb	r4,0(r2)
                xSenderACK[i].cCommand = xPrePReader->cCommand;
8111477c:	e0fffe03 	ldbu	r3,-8(fp)
81114780:	e0bfff17 	ldw	r2,-4(fp)
81114784:	11000143 	ldbu	r4,5(r2)
81114788:	00a045b4 	movhi	r2,33046
8111478c:	10991904 	addi	r2,r2,25700
81114790:	18c7883a 	add	r3,r3,r3
81114794:	18c7883a 	add	r3,r3,r3
81114798:	10c5883a 	add	r2,r2,r3
8111479c:	10800044 	addi	r2,r2,1
811147a0:	11000005 	stb	r4,0(r2)
                xSenderACK[i].usiId = xPrePReader->usiValues[0]; /*The first value is always the command id*/
811147a4:	e0fffe03 	ldbu	r3,-8(fp)
811147a8:	e0bfff17 	ldw	r2,-4(fp)
811147ac:	1100020b 	ldhu	r4,8(r2)
811147b0:	00a045b4 	movhi	r2,33046
811147b4:	10991904 	addi	r2,r2,25700
811147b8:	18c7883a 	add	r3,r3,r3
811147bc:	18c7883a 	add	r3,r3,r3
811147c0:	10c5883a 	add	r2,r2,r3
811147c4:	10800084 	addi	r2,r2,2
811147c8:	1100000d 	sth	r4,0(r2)

                error_code = OSSemPost(xSemCountSenderACK);
811147cc:	d0a06117 	ldw	r2,-32380(gp)
811147d0:	1009883a 	mov	r4,r2
811147d4:	113e8480 	call	8113e848 <OSSemPost>
811147d8:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code != OS_ERR_NONE ) {
811147dc:	e0bffe43 	ldbu	r2,-7(fp)
811147e0:	10803fcc 	andi	r2,r2,255
811147e4:	10000926 	beq	r2,zero,8111480c <setPreAckSenderFreePos+0x134>
                    vFailSendPreAckSenderSemaphore();
811147e8:	111b5ec0 	call	8111b5ec <vFailSendPreAckSenderSemaphore>
                    xSenderACK[i].cType = 0;
811147ec:	e0fffe03 	ldbu	r3,-8(fp)
811147f0:	00a045b4 	movhi	r2,33046
811147f4:	10991904 	addi	r2,r2,25700
811147f8:	18c7883a 	add	r3,r3,r3
811147fc:	18c7883a 	add	r3,r3,r3
81114800:	10c5883a 	add	r2,r2,r3
81114804:	10000005 	stb	zero,0(r2)
                } else
                    bSuccess = TRUE;
                break;
81114808:	00000906 	br	81114830 <setPreAckSenderFreePos+0x158>
                error_code = OSSemPost(xSemCountSenderACK);
                if ( error_code != OS_ERR_NONE ) {
                    vFailSendPreAckSenderSemaphore();
                    xSenderACK[i].cType = 0;
                } else
                    bSuccess = TRUE;
8111480c:	00800044 	movi	r2,1
81114810:	e0bffd15 	stw	r2,-12(fp)
                break;
81114814:	00000606 	br	81114830 <setPreAckSenderFreePos+0x158>
    bSuccess = FALSE;
    OSMutexPend(xMutexSenderACK, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for(i = 0; i < N_ACKS_SENDER; i++)
81114818:	e0bffe03 	ldbu	r2,-8(fp)
8111481c:	10800044 	addi	r2,r2,1
81114820:	e0bffe05 	stb	r2,-8(fp)
81114824:	e0bffe03 	ldbu	r2,-8(fp)
81114828:	10800230 	cmpltui	r2,r2,8
8111482c:	103fbf1e 	bne	r2,zero,8111472c <__reset+0xfb0f472c>
                } else
                    bSuccess = TRUE;
                break;
            }
        }
        OSMutexPost(xMutexSenderACK);
81114830:	d0a07217 	ldw	r2,-32312(gp)
81114834:	1009883a 	mov	r4,r2
81114838:	113ca580 	call	8113ca58 <OSMutexPost>
    }

    return bSuccess;
8111483c:	e0bffd17 	ldw	r2,-12(fp)
}
81114840:	e037883a 	mov	sp,fp
81114844:	dfc00117 	ldw	ra,4(sp)
81114848:	df000017 	ldw	fp,0(sp)
8111484c:	dec00204 	addi	sp,sp,8
81114850:	f800283a 	ret

81114854 <setPreAckReceiverFreePos>:

/* Search for some free location in the xSenderACK array, that comunicates with the AckSenderTask */
bool setPreAckReceiverFreePos( tPreParsed *xPrePReader ) {
81114854:	defffb04 	addi	sp,sp,-20
81114858:	de00012e 	bgeu	sp,et,81114860 <setPreAckReceiverFreePos+0xc>
8111485c:	003b68fa 	trap	3
81114860:	dfc00415 	stw	ra,16(sp)
81114864:	df000315 	stw	fp,12(sp)
81114868:	df000304 	addi	fp,sp,12
8111486c:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81114870:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
81114874:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
81114878:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexReceivedACK, 20, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait 20 ticks = 20 ms */
8111487c:	d0a06517 	ldw	r2,-32364(gp)
81114880:	e0fffe44 	addi	r3,fp,-7
81114884:	180d883a 	mov	r6,r3
81114888:	01400504 	movi	r5,20
8111488c:	1009883a 	mov	r4,r2
81114890:	113c4b40 	call	8113c4b4 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
81114894:	e0bffe43 	ldbu	r2,-7(fp)
81114898:	10803fcc 	andi	r2,r2,255
8111489c:	1000471e 	bne	r2,zero,811149bc <setPreAckReceiverFreePos+0x168>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_ACKS_RECEIVED; i++ )
811148a0:	e03ffe05 	stb	zero,-8(fp)
811148a4:	00003e06 	br	811149a0 <setPreAckReceiverFreePos+0x14c>
        {
            if ( xReceivedACK[i].cType == 0 ) {
811148a8:	e0fffe03 	ldbu	r3,-8(fp)
811148ac:	00a045b4 	movhi	r2,33046
811148b0:	10830704 	addi	r2,r2,3100
811148b4:	18c7883a 	add	r3,r3,r3
811148b8:	18c7883a 	add	r3,r3,r3
811148bc:	10c5883a 	add	r2,r2,r3
811148c0:	10800003 	ldbu	r2,0(r2)
811148c4:	10803fcc 	andi	r2,r2,255
811148c8:	1080201c 	xori	r2,r2,128
811148cc:	10bfe004 	addi	r2,r2,-128
811148d0:	1000301e 	bne	r2,zero,81114994 <setPreAckReceiverFreePos+0x140>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xReceivedACK[i].cType = xPrePReader->cType;
811148d4:	e0fffe03 	ldbu	r3,-8(fp)
811148d8:	e0bfff17 	ldw	r2,-4(fp)
811148dc:	11000103 	ldbu	r4,4(r2)
811148e0:	00a045b4 	movhi	r2,33046
811148e4:	10830704 	addi	r2,r2,3100
811148e8:	18c7883a 	add	r3,r3,r3
811148ec:	18c7883a 	add	r3,r3,r3
811148f0:	10c5883a 	add	r2,r2,r3
811148f4:	11000005 	stb	r4,0(r2)
                xReceivedACK[i].cCommand = xPrePReader->cCommand;
811148f8:	e0fffe03 	ldbu	r3,-8(fp)
811148fc:	e0bfff17 	ldw	r2,-4(fp)
81114900:	11000143 	ldbu	r4,5(r2)
81114904:	00a045b4 	movhi	r2,33046
81114908:	10830704 	addi	r2,r2,3100
8111490c:	18c7883a 	add	r3,r3,r3
81114910:	18c7883a 	add	r3,r3,r3
81114914:	10c5883a 	add	r2,r2,r3
81114918:	10800044 	addi	r2,r2,1
8111491c:	11000005 	stb	r4,0(r2)
                xReceivedACK[i].usiId = xPrePReader->usiValues[0];
81114920:	e0fffe03 	ldbu	r3,-8(fp)
81114924:	e0bfff17 	ldw	r2,-4(fp)
81114928:	1100020b 	ldhu	r4,8(r2)
8111492c:	00a045b4 	movhi	r2,33046
81114930:	10830704 	addi	r2,r2,3100
81114934:	18c7883a 	add	r3,r3,r3
81114938:	18c7883a 	add	r3,r3,r3
8111493c:	10c5883a 	add	r2,r2,r3
81114940:	10800084 	addi	r2,r2,2
81114944:	1100000d 	sth	r4,0(r2)

                error_code = OSSemPost(xSemCountReceivedACK);
81114948:	d0a06617 	ldw	r2,-32360(gp)
8111494c:	1009883a 	mov	r4,r2
81114950:	113e8480 	call	8113e848 <OSSemPost>
81114954:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code == OS_ERR_NONE ) {
81114958:	e0bffe43 	ldbu	r2,-7(fp)
8111495c:	10803fcc 	andi	r2,r2,255
81114960:	1000031e 	bne	r2,zero,81114970 <setPreAckReceiverFreePos+0x11c>
                    bSuccess = TRUE;
81114964:	00800044 	movi	r2,1
81114968:	e0bffd15 	stw	r2,-12(fp)
                } else {
                    vFailSendPreAckReceiverSemaphore();
                    xReceivedACK[i].cType = 0;
                }
                break;
8111496c:	00000f06 	br	811149ac <setPreAckReceiverFreePos+0x158>

                error_code = OSSemPost(xSemCountReceivedACK);
                if ( error_code == OS_ERR_NONE ) {
                    bSuccess = TRUE;
                } else {
                    vFailSendPreAckReceiverSemaphore();
81114970:	111b5a00 	call	8111b5a0 <vFailSendPreAckReceiverSemaphore>
                    xReceivedACK[i].cType = 0;
81114974:	e0fffe03 	ldbu	r3,-8(fp)
81114978:	00a045b4 	movhi	r2,33046
8111497c:	10830704 	addi	r2,r2,3100
81114980:	18c7883a 	add	r3,r3,r3
81114984:	18c7883a 	add	r3,r3,r3
81114988:	10c5883a 	add	r2,r2,r3
8111498c:	10000005 	stb	zero,0(r2)
                }
                break;
81114990:	00000606 	br	811149ac <setPreAckReceiverFreePos+0x158>
    bSuccess = FALSE;
    OSMutexPend(xMutexReceivedACK, 20, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait 20 ticks = 20 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_ACKS_RECEIVED; i++ )
81114994:	e0bffe03 	ldbu	r2,-8(fp)
81114998:	10800044 	addi	r2,r2,1
8111499c:	e0bffe05 	stb	r2,-8(fp)
811149a0:	e0bffe03 	ldbu	r2,-8(fp)
811149a4:	108001b0 	cmpltui	r2,r2,6
811149a8:	103fbf1e 	bne	r2,zero,811148a8 <__reset+0xfb0f48a8>
                    xReceivedACK[i].cType = 0;
                }
                break;
            }
        }
        OSMutexPost(xMutexReceivedACK);
811149ac:	d0a06517 	ldw	r2,-32364(gp)
811149b0:	1009883a 	mov	r4,r2
811149b4:	113ca580 	call	8113ca58 <OSMutexPost>
811149b8:	00000706 	br	811149d8 <setPreAckReceiverFreePos+0x184>
    } else {
        /* Could not  */
        #ifdef DEBUG_ON
            debug(fp,"Could not put the ack packet receiveid in the queue. (setPreAckReceiverFreePos)\n");
811149bc:	d0a06217 	ldw	r2,-32376(gp)
811149c0:	100f883a 	mov	r7,r2
811149c4:	01801404 	movi	r6,80
811149c8:	01400044 	movi	r5,1
811149cc:	01204574 	movhi	r4,33045
811149d0:	2135b904 	addi	r4,r4,-10524
811149d4:	11216400 	call	81121640 <fwrite>
        #endif
    }

    return bSuccess;
811149d8:	e0bffd17 	ldw	r2,-12(fp)
}
811149dc:	e037883a 	mov	sp,fp
811149e0:	dfc00117 	ldw	ra,4(sp)
811149e4:	df000017 	ldw	fp,0(sp)
811149e8:	dec00204 	addi	sp,sp,8
811149ec:	f800283a 	ret

811149f0 <bPreParserV2>:
/*  This function will parse the buffer into a command, will identify if is an request or reply
    also will separate all the values separated by ':'. If the command isn't complete (';' in the final)
    it will return false. */
    /* Max size of parsed value is 6 digits, for now*/
bool bPreParserV2( char *buffer, tPreParsed *xPerParcedBuffer )
{
811149f0:	defff404 	addi	sp,sp,-48
811149f4:	de00012e 	bgeu	sp,et,811149fc <bPreParserV2+0xc>
811149f8:	003b68fa 	trap	3
811149fc:	dfc00b15 	stw	ra,44(sp)
81114a00:	df000a15 	stw	fp,40(sp)
81114a04:	dc000915 	stw	r16,36(sp)
81114a08:	df000a04 	addi	fp,sp,40
81114a0c:	e13ffd15 	stw	r4,-12(fp)
81114a10:	e17ffe15 	stw	r5,-8(fp)
    bool bSuccess = FALSE;
81114a14:	e03ff615 	stw	zero,-40(fp)
    unsigned char i;
	char c, *p_inteiro;
	char inteiro[6]; /* Max size of parsed value is 6 digits, for now */


    bSuccess = FALSE;
81114a18:	e03ff615 	stw	zero,-40(fp)

    siStrLen = strnlen(buffer, SIZE_RCV_BUFFER);
81114a1c:	01402004 	movi	r5,128
81114a20:	e13ffd17 	ldw	r4,-12(fp)
81114a24:	1122be00 	call	81122be0 <strnlen>
81114a28:	e0bff90d 	sth	r2,-28(fp)
    siTeminador = siPosStr(buffer, FINAL_CHAR);
81114a2c:	01400ec4 	movi	r5,59
81114a30:	e13ffd17 	ldw	r4,-12(fp)
81114a34:	11192940 	call	81119294 <siPosStr>
81114a38:	e0bff98d 	sth	r2,-26(fp)

    /* Check the protocol terminator char ';' */
    if ( (siTeminador != (siStrLen-1)) )
81114a3c:	e0fff98f 	ldh	r3,-26(fp)
81114a40:	e0bff90f 	ldh	r2,-28(fp)
81114a44:	10bfffc4 	addi	r2,r2,-1
81114a48:	18800226 	beq	r3,r2,81114a54 <bPreParserV2+0x64>
        return bSuccess;
81114a4c:	e0bff617 	ldw	r2,-40(fp)
81114a50:	0000ba06 	br	81114d3c <bPreParserV2+0x34c>

    siCRC = siPosStr(buffer, SEPARATOR_CRC);
81114a54:	01401f04 	movi	r5,124
81114a58:	e13ffd17 	ldw	r4,-12(fp)
81114a5c:	11192940 	call	81119294 <siPosStr>
81114a60:	e0bffa0d 	sth	r2,-24(fp)

    /* Check if there's an CRC char */
    if ( siCRC > siTeminador )
81114a64:	e0bffa0f 	ldh	r2,-24(fp)
81114a68:	e0fff98f 	ldh	r3,-26(fp)
81114a6c:	1880020e 	bge	r3,r2,81114a78 <bPreParserV2+0x88>
        return bSuccess;
81114a70:	e0bff617 	ldw	r2,-40(fp)
81114a74:	0000b106 	br	81114d3c <bPreParserV2+0x34c>

    siIni = strcspn( buffer , ALL_INI_CHAR ); /* Verify if there's any one of the initial characters */
81114a78:	01604574 	movhi	r5,33045
81114a7c:	2975ce04 	addi	r5,r5,-10440
81114a80:	e13ffd17 	ldw	r4,-12(fp)
81114a84:	1122afc0 	call	81122afc <strcspn>
81114a88:	e0bffa8d 	sth	r2,-22(fp)

    /* Check if there's any initial char protocol and if is before the crc char */
    if ( siIni > siCRC)
81114a8c:	e0bffa8f 	ldh	r2,-22(fp)
81114a90:	e0fffa0f 	ldh	r3,-24(fp)
81114a94:	1880020e 	bge	r3,r2,81114aa0 <bPreParserV2+0xb0>
        return bSuccess;
81114a98:	e0bff617 	ldw	r2,-40(fp)
81114a9c:	0000a706 	br	81114d3c <bPreParserV2+0x34c>

    
    /*" ---> At this point we validate the existence and position of all characters in for the protocol in the message "*/


    xPerParcedBuffer->cType = buffer[siIni];
81114aa0:	e0bffa8f 	ldh	r2,-22(fp)
81114aa4:	e0fffd17 	ldw	r3,-12(fp)
81114aa8:	1885883a 	add	r2,r3,r2
81114aac:	10c00003 	ldbu	r3,0(r2)
81114ab0:	e0bffe17 	ldw	r2,-8(fp)
81114ab4:	10c00105 	stb	r3,4(r2)
    if (xPerParcedBuffer->cType == NACK_CHAR ) {
81114ab8:	e0bffe17 	ldw	r2,-8(fp)
81114abc:	10800103 	ldbu	r2,4(r2)
81114ac0:	10803fcc 	andi	r2,r2,255
81114ac4:	1080201c 	xori	r2,r2,128
81114ac8:	10bfe004 	addi	r2,r2,-128
81114acc:	108008d8 	cmpnei	r2,r2,35
81114ad0:	1000041e 	bne	r2,zero,81114ae4 <bPreParserV2+0xf4>
        bSuccess = TRUE;
81114ad4:	00800044 	movi	r2,1
81114ad8:	e0bff615 	stw	r2,-40(fp)
        return bSuccess;
81114adc:	e0bff617 	ldw	r2,-40(fp)
81114ae0:	00009606 	br	81114d3c <bPreParserV2+0x34c>


    /*" ---> At this point the packet is a Resquest, Reply or ACK packet"*/


    xPerParcedBuffer->ucCalculatedCRC8 = ucCrc8wInit( &buffer[siIni] , (siCRC - siIni) );
81114ae4:	e0bffa8f 	ldh	r2,-22(fp)
81114ae8:	e0fffd17 	ldw	r3,-12(fp)
81114aec:	1889883a 	add	r4,r3,r2
81114af0:	e0fffa0f 	ldh	r3,-24(fp)
81114af4:	e0bffa8f 	ldh	r2,-22(fp)
81114af8:	1885c83a 	sub	r2,r3,r2
81114afc:	100b883a 	mov	r5,r2
81114b00:	111b1fc0 	call	8111b1fc <ucCrc8wInit>
81114b04:	1007883a 	mov	r3,r2
81114b08:	e0bffe17 	ldw	r2,-8(fp)
81114b0c:	10c01205 	stb	r3,72(r2)

    xPerParcedBuffer->cCommand = buffer[siIni+1];
81114b10:	e0bffa8f 	ldh	r2,-22(fp)
81114b14:	10800044 	addi	r2,r2,1
81114b18:	e0fffd17 	ldw	r3,-12(fp)
81114b1c:	1885883a 	add	r2,r3,r2
81114b20:	10c00003 	ldbu	r3,0(r2)
81114b24:	e0bffe17 	ldw	r2,-8(fp)
81114b28:	10c00145 	stb	r3,5(r2)
    xPerParcedBuffer->ucNofBytes = 0;
81114b2c:	e0bffe17 	ldw	r2,-8(fp)
81114b30:	10000185 	stb	zero,6(r2)

    memset( xPerParcedBuffer->usiValues , 0x00 , sizeof(xPerParcedBuffer->usiValues) );
81114b34:	e0bffe17 	ldw	r2,-8(fp)
81114b38:	10800204 	addi	r2,r2,8
81114b3c:	01801004 	movi	r6,64
81114b40:	000b883a 	mov	r5,zero
81114b44:	1009883a 	mov	r4,r2
81114b48:	11221a40 	call	811221a4 <memset>

    i = siIni + 3; /* "?C:i..." */
81114b4c:	e0bffa8b 	ldhu	r2,-22(fp)
81114b50:	108000c4 	addi	r2,r2,3
81114b54:	e0bff705 	stb	r2,-36(fp)
    do {
        p_inteiro = inteiro;
81114b58:	e0bffb44 	addi	r2,fp,-19
81114b5c:	e0bff815 	stw	r2,-32(fp)
        memset( &(inteiro) , 0 , sizeof( inteiro ) );
81114b60:	e0bffb44 	addi	r2,fp,-19
81114b64:	01800184 	movi	r6,6
81114b68:	000b883a 	mov	r5,zero
81114b6c:	1009883a 	mov	r4,r2
81114b70:	11221a40 	call	811221a4 <memset>
        do {
            c = buffer[i];
81114b74:	e0bff703 	ldbu	r2,-36(fp)
81114b78:	e0fffd17 	ldw	r3,-12(fp)
81114b7c:	1885883a 	add	r2,r3,r2
81114b80:	10800003 	ldbu	r2,0(r2)
81114b84:	e0bffb05 	stb	r2,-20(fp)
            if ( isdigit( c ) ) {
81114b88:	d0e00317 	ldw	r3,-32756(gp)
81114b8c:	e0bffb07 	ldb	r2,-20(fp)
81114b90:	10800044 	addi	r2,r2,1
81114b94:	1885883a 	add	r2,r3,r2
81114b98:	10800003 	ldbu	r2,0(r2)
81114b9c:	10803fcc 	andi	r2,r2,255
81114ba0:	1080010c 	andi	r2,r2,4
81114ba4:	10000626 	beq	r2,zero,81114bc0 <bPreParserV2+0x1d0>
                (*p_inteiro) = c;
81114ba8:	e0bff817 	ldw	r2,-32(fp)
81114bac:	e0fffb03 	ldbu	r3,-20(fp)
81114bb0:	10c00005 	stb	r3,0(r2)
                p_inteiro++;
81114bb4:	e0bff817 	ldw	r2,-32(fp)
81114bb8:	10800044 	addi	r2,r2,1
81114bbc:	e0bff815 	stw	r2,-32(fp)
            }
            i++;
81114bc0:	e0bff703 	ldbu	r2,-36(fp)
81114bc4:	10800044 	addi	r2,r2,1
81114bc8:	e0bff705 	stb	r2,-36(fp)
        } while ( (siStrLen>i) && ( ( c != SEPARATOR_CHAR ) && ( c != FINAL_CHAR ) && ( c != SEPARATOR_CRC )) ); //ASCII: 58 = ':' 59 = ';' and '|'
81114bcc:	e0bff90f 	ldh	r2,-28(fp)
81114bd0:	e0fff703 	ldbu	r3,-36(fp)
81114bd4:	1880090e 	bge	r3,r2,81114bfc <bPreParserV2+0x20c>
81114bd8:	e0bffb07 	ldb	r2,-20(fp)
81114bdc:	10800ea0 	cmpeqi	r2,r2,58
81114be0:	1000061e 	bne	r2,zero,81114bfc <bPreParserV2+0x20c>
81114be4:	e0bffb07 	ldb	r2,-20(fp)
81114be8:	10800ee0 	cmpeqi	r2,r2,59
81114bec:	1000031e 	bne	r2,zero,81114bfc <bPreParserV2+0x20c>
81114bf0:	e0bffb07 	ldb	r2,-20(fp)
81114bf4:	10801f18 	cmpnei	r2,r2,124
81114bf8:	103fde1e 	bne	r2,zero,81114b74 <__reset+0xfb0f4b74>
        (*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81114bfc:	e0bff817 	ldw	r2,-32(fp)
81114c00:	00c00284 	movi	r3,10
81114c04:	10c00005 	stb	r3,0(r2)

        if ( ( c == SEPARATOR_CHAR ) || ( c == SEPARATOR_CRC ) ) {
81114c08:	e0bffb07 	ldb	r2,-20(fp)
81114c0c:	10800ea0 	cmpeqi	r2,r2,58
81114c10:	1000031e 	bne	r2,zero,81114c20 <bPreParserV2+0x230>
81114c14:	e0bffb07 	ldb	r2,-20(fp)
81114c18:	10801f18 	cmpnei	r2,r2,124
81114c1c:	10001a1e 	bne	r2,zero,81114c88 <bPreParserV2+0x298>
            xPerParcedBuffer->usiValues[min_sim(xPerParcedBuffer->ucNofBytes,SIZE_UCVALUES)] = (unsigned short int)atoi( inteiro );
81114c20:	e0bffe17 	ldw	r2,-8(fp)
81114c24:	10800183 	ldbu	r2,6(r2)
81114c28:	10803fcc 	andi	r2,r2,255
81114c2c:	10800828 	cmpgeui	r2,r2,32
81114c30:	1000041e 	bne	r2,zero,81114c44 <bPreParserV2+0x254>
81114c34:	e0bffe17 	ldw	r2,-8(fp)
81114c38:	10800183 	ldbu	r2,6(r2)
81114c3c:	14003fcc 	andi	r16,r2,255
81114c40:	00000106 	br	81114c48 <bPreParserV2+0x258>
81114c44:	04000804 	movi	r16,32
81114c48:	e0bffb44 	addi	r2,fp,-19
81114c4c:	1009883a 	mov	r4,r2
81114c50:	1120e480 	call	81120e48 <atoi>
81114c54:	1009883a 	mov	r4,r2
81114c58:	e0fffe17 	ldw	r3,-8(fp)
81114c5c:	80800104 	addi	r2,r16,4
81114c60:	1085883a 	add	r2,r2,r2
81114c64:	1885883a 	add	r2,r3,r2
81114c68:	1100000d 	sth	r4,0(r2)
            xPerParcedBuffer->ucNofBytes++;
81114c6c:	e0bffe17 	ldw	r2,-8(fp)
81114c70:	10800183 	ldbu	r2,6(r2)
81114c74:	10800044 	addi	r2,r2,1
81114c78:	1007883a 	mov	r3,r2
81114c7c:	e0bffe17 	ldw	r2,-8(fp)
81114c80:	10c00185 	stb	r3,6(r2)
81114c84:	00000906 	br	81114cac <bPreParserV2+0x2bc>
        }
        else if ( c == FINAL_CHAR )
81114c88:	e0bffb07 	ldb	r2,-20(fp)
81114c8c:	10800ed8 	cmpnei	r2,r2,59
81114c90:	1000061e 	bne	r2,zero,81114cac <bPreParserV2+0x2bc>
        {
            xPerParcedBuffer->ucMessageCRC8 = (unsigned char)atoi( inteiro );
81114c94:	e0bffb44 	addi	r2,fp,-19
81114c98:	1009883a 	mov	r4,r2
81114c9c:	1120e480 	call	81120e48 <atoi>
81114ca0:	1007883a 	mov	r3,r2
81114ca4:	e0bffe17 	ldw	r2,-8(fp)
81114ca8:	10c01245 	stb	r3,73(r2)
        }

    } while ( (c != FINAL_CHAR) && (siStrLen>i) );
81114cac:	e0bffb07 	ldb	r2,-20(fp)
81114cb0:	10800ee0 	cmpeqi	r2,r2,59
81114cb4:	1000031e 	bne	r2,zero,81114cc4 <bPreParserV2+0x2d4>
81114cb8:	e0bff90f 	ldh	r2,-28(fp)
81114cbc:	e0fff703 	ldbu	r3,-36(fp)
81114cc0:	18bfa516 	blt	r3,r2,81114b58 <__reset+0xfb0f4b58>


    if ( c == FINAL_CHAR )
81114cc4:	e0bffb07 	ldb	r2,-20(fp)
81114cc8:	10800ed8 	cmpnei	r2,r2,59
81114ccc:	1000191e 	bne	r2,zero,81114d34 <bPreParserV2+0x344>
        if ( xPerParcedBuffer->ucMessageCRC8 == xPerParcedBuffer->ucCalculatedCRC8 ){
81114cd0:	e0bffe17 	ldw	r2,-8(fp)
81114cd4:	10c01243 	ldbu	r3,73(r2)
81114cd8:	e0bffe17 	ldw	r2,-8(fp)
81114cdc:	10801203 	ldbu	r2,72(r2)
81114ce0:	18c03fcc 	andi	r3,r3,255
81114ce4:	10803fcc 	andi	r2,r2,255
81114ce8:	1880031e 	bne	r3,r2,81114cf8 <bPreParserV2+0x308>
            bSuccess = TRUE;
81114cec:	00800044 	movi	r2,1
81114cf0:	e0bff615 	stw	r2,-40(fp)
81114cf4:	00001006 	br	81114d38 <bPreParserV2+0x348>
        } else {
            /* Wrong CRC */
            #ifdef DEBUG_ON
                fprintf(fp,"Wrong CRC. Expected = %hhu, received = %hhu\n", xPerParcedBuffer->ucCalculatedCRC8, xPerParcedBuffer->ucMessageCRC8 );
81114cf8:	d0e06217 	ldw	r3,-32376(gp)
81114cfc:	e0bffe17 	ldw	r2,-8(fp)
81114d00:	10801203 	ldbu	r2,72(r2)
81114d04:	11003fcc 	andi	r4,r2,255
81114d08:	e0bffe17 	ldw	r2,-8(fp)
81114d0c:	10801243 	ldbu	r2,73(r2)
81114d10:	10803fcc 	andi	r2,r2,255
81114d14:	100f883a 	mov	r7,r2
81114d18:	200d883a 	mov	r6,r4
81114d1c:	01604574 	movhi	r5,33045
81114d20:	2975d004 	addi	r5,r5,-10432
81114d24:	1809883a 	mov	r4,r3
81114d28:	1120fa40 	call	81120fa4 <fprintf>
            #endif
            bSuccess = FALSE;
81114d2c:	e03ff615 	stw	zero,-40(fp)
81114d30:	00000106 	br	81114d38 <bPreParserV2+0x348>
        }
    else
        bSuccess = FALSE; /* Index overflow in the buffer */
81114d34:	e03ff615 	stw	zero,-40(fp)


    return bSuccess;
81114d38:	e0bff617 	ldw	r2,-40(fp)
}
81114d3c:	e6ffff04 	addi	sp,fp,-4
81114d40:	dfc00217 	ldw	ra,8(sp)
81114d44:	df000117 	ldw	fp,4(sp)
81114d48:	dc000017 	ldw	r16,0(sp)
81114d4c:	dec00304 	addi	sp,sp,12
81114d50:	f800283a 	ret

81114d54 <vSenderComTask>:


OS_STK_DATA *pdata;

void vSenderComTask(void *task_data)
{
81114d54:	defffb04 	addi	sp,sp,-20
81114d58:	de00012e 	bgeu	sp,et,81114d60 <vSenderComTask+0xc>
81114d5c:	003b68fa 	trap	3
81114d60:	dfc00415 	stw	ra,16(sp)
81114d64:	df000315 	stw	fp,12(sp)
81114d68:	df000304 	addi	fp,sp,12
81114d6c:	e13fff15 	stw	r4,-4(fp)
    tSenderStates eSenderMode;
    bool bSuccess;

    eSenderMode = sConfiguringSender;
81114d70:	e03ffd15 	stw	zero,-12(fp)

    #ifdef DEBUG_ON
        debug(fp,"Sender Comm Task. (Task on)\n");
81114d74:	d0a06217 	ldw	r2,-32376(gp)
81114d78:	100f883a 	mov	r7,r2
81114d7c:	01800704 	movi	r6,28
81114d80:	01400044 	movi	r5,1
81114d84:	01204574 	movhi	r4,33045
81114d88:	2135dc04 	addi	r4,r4,-10384
81114d8c:	11216400 	call	81121640 <fwrite>
    #endif

    for (;;){
        
        switch (eSenderMode)
81114d90:	e0bffd17 	ldw	r2,-12(fp)
81114d94:	10c00060 	cmpeqi	r3,r2,1
81114d98:	1800091e 	bne	r3,zero,81114dc0 <vSenderComTask+0x6c>
81114d9c:	0080052e 	bgeu	zero,r2,81114db4 <vSenderComTask+0x60>
81114da0:	10c000a0 	cmpeqi	r3,r2,2
81114da4:	1800471e 	bne	r3,zero,81114ec4 <vSenderComTask+0x170>
81114da8:	10800160 	cmpeqi	r2,r2,5
81114dac:	10002c1e 	bne	r2,zero,81114e60 <vSenderComTask+0x10c>
81114db0:	00003a06 	br	81114e9c <vSenderComTask+0x148>
        {
            case sConfiguringSender:
                /* For future implementations. */
                eSenderMode = sStartingConnSender;
81114db4:	00800044 	movi	r2,1
81114db8:	e0bffd15 	stw	r2,-12(fp)
                break;
81114dbc:	00004206 	br	81114ec8 <vSenderComTask+0x174>
                /*  This semaphore will return a non-zero value if the NUC communicate with the MEB 
                    vReceiverComTask is responsible to send this semaphore.
                    OSSemAccept -> Non blocking Pend*/

                #ifdef DEBUG_ON
                    debug(fp,"Preparing the Start Sequence.\n");
81114dc0:	d0a06217 	ldw	r2,-32376(gp)
81114dc4:	100f883a 	mov	r7,r2
81114dc8:	01800784 	movi	r6,30
81114dcc:	01400044 	movi	r5,1
81114dd0:	01204574 	movhi	r4,33045
81114dd4:	2135e404 	addi	r4,r4,-10352
81114dd8:	11216400 	call	81121640 <fwrite>
                #endif

                /* id of the first message will be 1 */
                bSuccess = bSendUART32v2(START_STATUS_SEQUENCE, 1);
81114ddc:	01400044 	movi	r5,1
81114de0:	01204574 	movhi	r4,33045
81114de4:	2135ec04 	addi	r4,r4,-10320
81114de8:	111898c0 	call	8111898c <bSendUART32v2>
81114dec:	e0bffe15 	stw	r2,-8(fp)
                if ( bSuccess == TRUE ) {
81114df0:	e0bffe17 	ldw	r2,-8(fp)
81114df4:	10800058 	cmpnei	r2,r2,1
81114df8:	10000a1e 	bne	r2,zero,81114e24 <vSenderComTask+0xd0>
                    eSenderMode = sDummySender;
81114dfc:	00800144 	movi	r2,5
81114e00:	e0bffd15 	stw	r2,-12(fp)
                    #ifdef DEBUG_ON
                        debug(fp,"Success, start message in the retransmission buffer.\n");
81114e04:	d0a06217 	ldw	r2,-32376(gp)
81114e08:	100f883a 	mov	r7,r2
81114e0c:	01800d44 	movi	r6,53
81114e10:	01400044 	movi	r5,1
81114e14:	01204574 	movhi	r4,33045
81114e18:	2135ef04 	addi	r4,r4,-10308
81114e1c:	11216400 	call	81121640 <fwrite>
                        debug(fp,"Fail, try again in 5 seconds.\n");
                    #endif 
                    eSenderMode = sStartingConnSender;
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
                }
                break;
81114e20:	00002906 	br	81114ec8 <vSenderComTask+0x174>
                    #ifdef DEBUG_ON
                        debug(fp,"Success, start message in the retransmission buffer.\n");
                    #endif                    
                } else {
                    #ifdef DEBUG_ON
                        debug(fp,"Fail, try again in 5 seconds.\n");
81114e24:	d0a06217 	ldw	r2,-32376(gp)
81114e28:	100f883a 	mov	r7,r2
81114e2c:	01800784 	movi	r6,30
81114e30:	01400044 	movi	r5,1
81114e34:	01204574 	movhi	r4,33045
81114e38:	2135fd04 	addi	r4,r4,-10252
81114e3c:	11216400 	call	81121640 <fwrite>
                    #endif 
                    eSenderMode = sStartingConnSender;
81114e40:	00800044 	movi	r2,1
81114e44:	e0bffd15 	stw	r2,-12(fp)
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
81114e48:	000f883a 	mov	r7,zero
81114e4c:	01800144 	movi	r6,5
81114e50:	000b883a 	mov	r5,zero
81114e54:	0009883a 	mov	r4,zero
81114e58:	11404580 	call	81140458 <OSTimeDlyHMSM>
                }
                break;
81114e5c:	00001a06 	br	81114ec8 <vSenderComTask+0x174>
                

                break;
            case sDummySender:
                /* code */
                eSenderMode = sDummySender;
81114e60:	00800144 	movi	r2,5
81114e64:	e0bffd15 	stw	r2,-12(fp)

                #ifdef DEBUG_ON
                    debug(fp,"Working...\n");
81114e68:	d0a06217 	ldw	r2,-32376(gp)
81114e6c:	100f883a 	mov	r7,r2
81114e70:	018002c4 	movi	r6,11
81114e74:	01400044 	movi	r5,1
81114e78:	01204574 	movhi	r4,33045
81114e7c:	21360504 	addi	r4,r4,-10220
81114e80:	11216400 	call	81121640 <fwrite>
                #endif

				OSTimeDlyHMSM(0, 0, 25, 0); /*Sleeps for 3 second*/
81114e84:	000f883a 	mov	r7,zero
81114e88:	01800644 	movi	r6,25
81114e8c:	000b883a 	mov	r5,zero
81114e90:	0009883a 	mov	r4,zero
81114e94:	11404580 	call	81140458 <OSTimeDlyHMSM>

                break;
81114e98:	00000b06 	br	81114ec8 <vSenderComTask+0x174>
            default:
                #ifdef DEBUG_ON
                    debug(fp,"Sender default\n");
81114e9c:	d0a06217 	ldw	r2,-32376(gp)
81114ea0:	100f883a 	mov	r7,r2
81114ea4:	018003c4 	movi	r6,15
81114ea8:	01400044 	movi	r5,1
81114eac:	01204574 	movhi	r4,33045
81114eb0:	21360804 	addi	r4,r4,-10208
81114eb4:	11216400 	call	81121640 <fwrite>
                #endif
                eSenderMode = sDummySender;
81114eb8:	00800144 	movi	r2,5
81114ebc:	e0bffd15 	stw	r2,-12(fp)
                break;
81114ec0:	00000106 	br	81114ec8 <vSenderComTask+0x174>

                //pPointer = OSQPend(xQSenderTask, 0, &error_code);

                

                break;
81114ec4:	0001883a 	nop
                #endif
                eSenderMode = sDummySender;
                break;
        }

    }
81114ec8:	003fb106 	br	81114d90 <__reset+0xfb0f4d90>

81114ecc <vSimMebTask>:

#include "sim_meb_task.h"

/* All commands should pass through the MEB, it is the instance that hould know everything, and also know the self state and what is allowed to be performed or not */

void vSimMebTask(void *task_data) {
81114ecc:	defff804 	addi	sp,sp,-32
81114ed0:	de00012e 	bgeu	sp,et,81114ed8 <vSimMebTask+0xc>
81114ed4:	003b68fa 	trap	3
81114ed8:	dfc00715 	stw	ra,28(sp)
81114edc:	df000615 	stw	fp,24(sp)
81114ee0:	df000604 	addi	fp,sp,24
81114ee4:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucIL;
	tQMask uiCmdMeb;
	INT8U error_code;
	INT8U ucFrameNumber;

	pxMebC = (TSimucam_MEB *) task_data;
81114ee8:	e0bfff17 	ldw	r2,-4(fp)
81114eec:	e0bffb15 	stw	r2,-20(fp)

	#ifdef DEBUG_ON
        debug(fp,"Sim-Meb Controller Task. (Task on)\n");
81114ef0:	d0a06217 	ldw	r2,-32376(gp)
81114ef4:	100f883a 	mov	r7,r2
81114ef8:	018008c4 	movi	r6,35
81114efc:	01400044 	movi	r5,1
81114f00:	01204574 	movhi	r4,33045
81114f04:	21360c04 	addi	r4,r4,-10192
81114f08:	11216400 	call	81121640 <fwrite>
    #endif


	for (;;) {
		switch ( pxMebC->eMode ) {
81114f0c:	e0bffb17 	ldw	r2,-20(fp)
81114f10:	10800117 	ldw	r2,4(r2)
81114f14:	10c00168 	cmpgeui	r3,r2,5
81114f18:	1800ed1e 	bne	r3,zero,811152d0 <vSimMebTask+0x404>
81114f1c:	100690ba 	slli	r3,r2,2
81114f20:	00a04474 	movhi	r2,33041
81114f24:	1093cd04 	addi	r2,r2,20276
81114f28:	1885883a 	add	r2,r3,r2
81114f2c:	10800017 	ldw	r2,0(r2)
81114f30:	1000683a 	jmp	r2
81114f34:	81114f48 	cmpgei	r4,r16,17725
81114f38:	81114f60 	cmpeqi	r4,r16,17725
81114f3c:	81114fe0 	cmpeqi	r4,r16,17727
81114f40:	811150ac 	andhi	r4,r16,17730
81114f44:	81115184 	addi	r4,r16,17734
			case sMebInit:
				/* Turn on Meb */
				vMebInit( pxMebC );
81114f48:	e13ffb17 	ldw	r4,-20(fp)
81114f4c:	11160740 	call	81116074 <vMebInit>
				pxMebC->eMode = sMebToConfig;
81114f50:	e0bffb17 	ldw	r2,-20(fp)
81114f54:	00c00044 	movi	r3,1
81114f58:	10c00115 	stw	r3,4(r2)
				break;
81114f5c:	0000e706 	br	811152fc <vSimMebTask+0x430>


			case sMebToConfig:
				#ifdef DEBUG_ON
					debug(fp,"MEB Task: Config Mode\n");
81114f60:	d0a06217 	ldw	r2,-32376(gp)
81114f64:	100f883a 	mov	r7,r2
81114f68:	01800584 	movi	r6,22
81114f6c:	01400044 	movi	r5,1
81114f70:	01204574 	movhi	r4,33045
81114f74:	21361504 	addi	r4,r4,-10156
81114f78:	11216400 	call	81121640 <fwrite>
				#endif

				/* Stop the Sync (Stopping the simulation) */
				bStopSync();
81114f7c:	111e88c0 	call	8111e88c <bStopSync>
				vSyncClearCounter();
81114f80:	110cb300 	call	8110cb30 <vSyncClearCounter>

				/* If any Task is locked waiting Sync, should be released */
				vReleaseSyncMessages();
81114f84:	111617c0 	call	8111617c <vReleaseSyncMessages>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, 10);
81114f88:	01c00284 	movi	r7,10
81114f8c:	000d883a 	mov	r6,zero
81114f90:	000b883a 	mov	r5,zero
81114f94:	0009883a 	mov	r4,zero
81114f98:	11404580 	call	81140458 <OSTimeDlyHMSM>

				/* Transition to Config Mode (Ending the simulation) */
				/* Send a message to the NFEE Controller forcing the mode */
				vSendCmdQToNFeeCTRL_PRIO( M_NFC_CONFIG_FORCED, 0, 0 );
81114f9c:	000d883a 	mov	r6,zero
81114fa0:	000b883a 	mov	r5,zero
81114fa4:	01002844 	movi	r4,161
81114fa8:	1115e480 	call	81115e48 <vSendCmdQToNFeeCTRL_PRIO>
				vSendCmdQToDataCTRL_PRIO( M_DATA_CONFIG_FORCED, 0, 0 );
81114fac:	000d883a 	mov	r6,zero
81114fb0:	000b883a 	mov	r5,zero
81114fb4:	01002844 	movi	r4,161
81114fb8:	1115fec0 	call	81115fec <vSendCmdQToDataCTRL_PRIO>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, 250);
81114fbc:	01c03e84 	movi	r7,250
81114fc0:	000d883a 	mov	r6,zero
81114fc4:	000b883a 	mov	r5,zero
81114fc8:	0009883a 	mov	r4,zero
81114fcc:	11404580 	call	81140458 <OSTimeDlyHMSM>

				pxMebC->eMode = sMebConfig;
81114fd0:	e0bffb17 	ldw	r2,-20(fp)
81114fd4:	00c000c4 	movi	r3,3
81114fd8:	10c00115 	stw	r3,4(r2)
				break;
81114fdc:	0000c706 	br	811152fc <vSimMebTask+0x430>


			case sMebToRun:
				#ifdef DEBUG_ON
					debug(fp,"MEB Task: Run Mode\n");
81114fe0:	d0a06217 	ldw	r2,-32376(gp)
81114fe4:	100f883a 	mov	r7,r2
81114fe8:	018004c4 	movi	r6,19
81114fec:	01400044 	movi	r5,1
81114ff0:	01204574 	movhi	r4,33045
81114ff4:	21361b04 	addi	r4,r4,-10132
81114ff8:	11216400 	call	81121640 <fwrite>
				#endif
				/* Transition to Run Mode (Starting the Simulation) */
				vSendCmdQToNFeeCTRL_PRIO( M_NFC_RUN_FORCED, 0, 0 );
81114ffc:	000d883a 	mov	r6,zero
81115000:	000b883a 	mov	r5,zero
81115004:	01002884 	movi	r4,162
81115008:	1115e480 	call	81115e48 <vSendCmdQToNFeeCTRL_PRIO>
				vSendCmdQToDataCTRL_PRIO( M_DATA_RUN_FORCED, 0, 0 );
8111500c:	000d883a 	mov	r6,zero
81115010:	000b883a 	mov	r5,zero
81115014:	01002884 	movi	r4,162
81115018:	1115fec0 	call	81115fec <vSendCmdQToDataCTRL_PRIO>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, pxMebC->usiDelaySyncReset);
8111501c:	e0bffb17 	ldw	r2,-20(fp)
81115020:	1080050b 	ldhu	r2,20(r2)
81115024:	10bfffcc 	andi	r2,r2,65535
81115028:	100f883a 	mov	r7,r2
8111502c:	000d883a 	mov	r6,zero
81115030:	000b883a 	mov	r5,zero
81115034:	0009883a 	mov	r4,zero
81115038:	11404580 	call	81140458 <OSTimeDlyHMSM>


				/* Clear the timecode of the channel SPW (for now is for spw channel) */
				for (ucIL = 0; ucIL < N_OF_NFEE; ++ucIL) {
8111503c:	e03ffa05 	stb	zero,-24(fp)
81115040:	00001006 	br	81115084 <vSimMebTask+0x1b8>
					bSpwcClearTimecode(&pxMebC->xFeeControl.xNfee[ucIL].xChannel.xSpacewire);
81115044:	e0bffa03 	ldbu	r2,-24(fp)
81115048:	10809624 	muli	r2,r2,600
8111504c:	10809b04 	addi	r2,r2,620
81115050:	e0fffb17 	ldw	r3,-20(fp)
81115054:	1885883a 	add	r2,r3,r2
81115058:	1009883a 	mov	r4,r2
8111505c:	110a61c0 	call	8110a61c <bSpwcClearTimecode>
					pxMebC->xFeeControl.xNfee[ucIL].xControl.ucTimeCode = 0;
81115060:	e0bffa03 	ldbu	r2,-24(fp)
81115064:	e0fffb17 	ldw	r3,-20(fp)
81115068:	10809624 	muli	r2,r2,600
8111506c:	1885883a 	add	r2,r3,r2
81115070:	10803c04 	addi	r2,r2,240
81115074:	10000005 	stb	zero,0(r2)
				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, pxMebC->usiDelaySyncReset);


				/* Clear the timecode of the channel SPW (for now is for spw channel) */
				for (ucIL = 0; ucIL < N_OF_NFEE; ++ucIL) {
81115078:	e0bffa03 	ldbu	r2,-24(fp)
8111507c:	10800044 	addi	r2,r2,1
81115080:	e0bffa05 	stb	r2,-24(fp)
81115084:	e0bffa03 	ldbu	r2,-24(fp)
81115088:	103fee26 	beq	r2,zero,81115044 <__reset+0xfb0f5044>
					bSpwcClearTimecode(&pxMebC->xFeeControl.xNfee[ucIL].xChannel.xSpacewire);
					pxMebC->xFeeControl.xNfee[ucIL].xControl.ucTimeCode = 0;
				}

				bSyncCtrReset();
8111508c:	110d1800 	call	8110d180 <bSyncCtrReset>
				vSyncClearCounter();
81115090:	110cb300 	call	8110cb30 <vSyncClearCounter>
				bStartSync();
81115094:	111e8500 	call	8111e850 <bStartSync>

				vEvtChangeMebMode();
81115098:	111d2980 	call	8111d298 <vEvtChangeMebMode>
				pxMebC->eMode = sMebRun;
8111509c:	e0bffb17 	ldw	r2,-20(fp)
811150a0:	00c00104 	movi	r3,4
811150a4:	10c00115 	stw	r3,4(r2)
				break;
811150a8:	00009406 	br	811152fc <vSimMebTask+0x430>


			case sMebConfig:

				uiCmdMeb.ulWord = (unsigned int)OSQPend(xMebQ, 0, &error_code); /* Blocking operation */
811150ac:	d0a06917 	ldw	r2,-32348(gp)
811150b0:	e0fffe04 	addi	r3,fp,-8
811150b4:	180d883a 	mov	r6,r3
811150b8:	000b883a 	mov	r5,zero
811150bc:	1009883a 	mov	r4,r2
811150c0:	113d5c80 	call	8113d5c8 <OSQPend>
811150c4:	e0bffd15 	stw	r2,-12(fp)
				if ( error_code == OS_ERR_NONE ) {
811150c8:	e0bffe03 	ldbu	r2,-8(fp)
811150cc:	10803fcc 	andi	r2,r2,255
811150d0:	1000291e 	bne	r2,zero,81115178 <vSimMebTask+0x2ac>

					/* Check if the command is for MEB */
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
811150d4:	e0bffdc3 	ldbu	r2,-9(fp)
811150d8:	10803fcc 	andi	r2,r2,255
811150dc:	10800058 	cmpnei	r2,r2,1
811150e0:	10001c1e 	bne	r2,zero,81115154 <vSimMebTask+0x288>
						/* Parse the cmd that comes in the Queue */
						switch ( uiCmdMeb.ucByte[2] ) {
811150e4:	e0bffd83 	ldbu	r2,-10(fp)
811150e8:	10803fcc 	andi	r2,r2,255
811150ec:	10c00060 	cmpeqi	r3,r2,1
811150f0:	1800031e 	bne	r3,zero,81115100 <vSimMebTask+0x234>
811150f4:	10803820 	cmpeqi	r2,r2,224
811150f8:	1000041e 	bne	r2,zero,8111510c <vSimMebTask+0x240>
811150fc:	00000b06 	br	8111512c <vSimMebTask+0x260>
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebTask( pxMebC );
81115100:	e13ffb17 	ldw	r4,-20(fp)
81115104:	11153000 	call	81115300 <vPusMebTask>
								break;
81115108:	00001d06 	br	81115180 <vSimMebTask+0x2b4>
							case M_MASTER_SYNC:
								#ifdef DEBUG_ON
									fprintf(fp,"MEB Task: WARNING Should not have sync in Meb Config Mode (Check it please)");
8111510c:	d0a06217 	ldw	r2,-32376(gp)
81115110:	100f883a 	mov	r7,r2
81115114:	018012c4 	movi	r6,75
81115118:	01400044 	movi	r5,1
8111511c:	01204574 	movhi	r4,33045
81115120:	21362004 	addi	r4,r4,-10112
81115124:	11216400 	call	81121640 <fwrite>
								#endif
								break;
81115128:	00001506 	br	81115180 <vSimMebTask+0x2b4>
							default:
								#ifdef DEBUG_ON
									fprintf(fp,"MEB Task: Unknown command for the Config Mode (Queue xMebQ, cmd= %hhu)\n", uiCmdMeb.ucByte[2]);
8111512c:	d0a06217 	ldw	r2,-32376(gp)
81115130:	e0fffd83 	ldbu	r3,-10(fp)
81115134:	18c03fcc 	andi	r3,r3,255
81115138:	180d883a 	mov	r6,r3
8111513c:	01604574 	movhi	r5,33045
81115140:	29763304 	addi	r5,r5,-10036
81115144:	1009883a 	mov	r4,r2
81115148:	1120fa40 	call	81120fa4 <fprintf>
								#endif
								break;
8111514c:	0001883a 	nop
81115150:	00000b06 	br	81115180 <vSimMebTask+0x2b4>
						}
					} else {
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: Command Ignored wrong address (ADDR= %hhu)\n", uiCmdMeb.ucByte[3]);
81115154:	d0a06217 	ldw	r2,-32376(gp)
81115158:	e0fffdc3 	ldbu	r3,-9(fp)
8111515c:	18c03fcc 	andi	r3,r3,255
81115160:	180d883a 	mov	r6,r3
81115164:	01604574 	movhi	r5,33045
81115168:	29764504 	addi	r5,r5,-9964
8111516c:	1009883a 	mov	r4,r2
81115170:	1120fa40 	call	81120fa4 <fprintf>
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}

				break;
81115174:	00006106 	br	811152fc <vSimMebTask+0x430>
							fprintf(fp,"MEB Task: Command Ignored wrong address (ADDR= %hhu)\n", uiCmdMeb.ucByte[3]);
						#endif
					}
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
81115178:	111cc380 	call	8111cc38 <vCouldNotGetCmdQueueMeb>
				}

				break;
8111517c:	00005f06 	br	811152fc <vSimMebTask+0x430>
81115180:	00005e06 	br	811152fc <vSimMebTask+0x430>

			case sMebRun:
				uiCmdMeb.ulWord = (unsigned int)OSQPend(xMebQ, 0, &error_code); /* Blocking operation */
81115184:	d0a06917 	ldw	r2,-32348(gp)
81115188:	e0fffe04 	addi	r3,fp,-8
8111518c:	180d883a 	mov	r6,r3
81115190:	000b883a 	mov	r5,zero
81115194:	1009883a 	mov	r4,r2
81115198:	113d5c80 	call	8113d5c8 <OSQPend>
8111519c:	e0bffd15 	stw	r2,-12(fp)
				if ( error_code == OS_ERR_NONE ) {
811151a0:	e0bffe03 	ldbu	r2,-8(fp)
811151a4:	10803fcc 	andi	r2,r2,255
811151a8:	1000461e 	bne	r2,zero,811152c4 <vSimMebTask+0x3f8>

					/* Check if the command is for MEB */
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
811151ac:	e0bffdc3 	ldbu	r2,-9(fp)
811151b0:	10803fcc 	andi	r2,r2,255
811151b4:	10800058 	cmpnei	r2,r2,1
811151b8:	1000391e 	bne	r2,zero,811152a0 <vSimMebTask+0x3d4>
						/* Parse the cmd that comes in the Queue */
						switch (uiCmdMeb.ucByte[2]) {
811151bc:	e0bffd83 	ldbu	r2,-10(fp)
811151c0:	10803fcc 	andi	r2,r2,255
811151c4:	10c03820 	cmpeqi	r3,r2,224
811151c8:	1800071e 	bne	r3,zero,811151e8 <vSimMebTask+0x31c>
811151cc:	10c03860 	cmpeqi	r3,r2,225
811151d0:	1800071e 	bne	r3,zero,811151f0 <vSimMebTask+0x324>
811151d4:	10800060 	cmpeqi	r2,r2,1
811151d8:	10002726 	beq	r2,zero,81115278 <vSimMebTask+0x3ac>
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebTask( pxMebC );
811151dc:	e13ffb17 	ldw	r4,-20(fp)
811151e0:	11153000 	call	81115300 <vPusMebTask>
								break;
811151e4:	00003906 	br	811152cc <vSimMebTask+0x400>
							case M_MASTER_SYNC:
								/* Perform memory SWAP */
								vSwapMemmory(pxMebC);
811151e8:	e13ffb17 	ldw	r4,-20(fp)
811151ec:	11160d80 	call	811160d8 <vSwapMemmory>
							case M_SYNC:
								#ifdef DEBUG_ON
									bSpwcGetTimecode(&pxMebC->xFeeControl.xNfee[0].xChannel.xSpacewire);
811151f0:	e0bffb17 	ldw	r2,-20(fp)
811151f4:	10809b04 	addi	r2,r2,620
811151f8:	1009883a 	mov	r4,r2
811151fc:	110a58c0 	call	8110a58c <bSpwcGetTimecode>
									tCode = ( pxMebC->xFeeControl.xNfee[0].xChannel.xSpacewire.xTimecode.ucCounter);
81115200:	e0bffb17 	ldw	r2,-20(fp)
81115204:	1080a743 	ldbu	r2,669(r2)
81115208:	e0bffc05 	stb	r2,-16(fp)
									tCodeNext = ( tCode ) % 4;
8111520c:	e0bffc03 	ldbu	r2,-16(fp)
81115210:	108000cc 	andi	r2,r2,3
81115214:	e0bffc45 	stb	r2,-15(fp)

									fprintf(fp,"\n\nMEB TASK:  TC: %hhu ( %hhu )\n ", tCode, tCodeNext);
81115218:	d0a06217 	ldw	r2,-32376(gp)
8111521c:	e0fffc03 	ldbu	r3,-16(fp)
81115220:	e13ffc43 	ldbu	r4,-15(fp)
81115224:	200f883a 	mov	r7,r4
81115228:	180d883a 	mov	r6,r3
8111522c:	01604574 	movhi	r5,33045
81115230:	29765304 	addi	r5,r5,-9908
81115234:	1009883a 	mov	r4,r2
81115238:	1120fa40 	call	81120fa4 <fprintf>


									bRmapGetMemConfigArea(&pxMebC->xFeeControl.xNfee[0].xChannel.xRmap);
8111523c:	e0bffb17 	ldw	r2,-20(fp)
81115240:	10805504 	addi	r2,r2,340
81115244:	1009883a 	mov	r4,r2
81115248:	11081800 	call	81108180 <bRmapGetMemConfigArea>
									ucFrameNumber = pxMebC->xFeeControl.xNfee[0].xChannel.xRmap.xRmapMemConfigArea.uliFrameNumber;
8111524c:	e0bffb17 	ldw	r2,-20(fp)
81115250:	10807717 	ldw	r2,476(r2)
81115254:	e0bffc85 	stb	r2,-14(fp)

									//bRmapSetMemConfigArea(&pxMebC->xFeeControl.xNfee[0].xChannel.xRmap);

									fprintf(fp,"MEB TASK:  Frame Number: %hhu \n ", ucFrameNumber);
81115258:	d0a06217 	ldw	r2,-32376(gp)
8111525c:	e0fffc83 	ldbu	r3,-14(fp)
81115260:	180d883a 	mov	r6,r3
81115264:	01604574 	movhi	r5,33045
81115268:	29765c04 	addi	r5,r5,-9872
8111526c:	1009883a 	mov	r4,r2
81115270:	1120fa40 	call	81120fa4 <fprintf>

								#endif

								break;
81115274:	00001506 	br	811152cc <vSimMebTask+0x400>
							default:
								#ifdef DEBUG_ON
									fprintf(fp,"MEB Task: Unknown command (%hhu)\n", uiCmdMeb.ucByte[2]);
81115278:	d0a06217 	ldw	r2,-32376(gp)
8111527c:	e0fffd83 	ldbu	r3,-10(fp)
81115280:	18c03fcc 	andi	r3,r3,255
81115284:	180d883a 	mov	r6,r3
81115288:	01604574 	movhi	r5,33045
8111528c:	29766504 	addi	r5,r5,-9836
81115290:	1009883a 	mov	r4,r2
81115294:	1120fa40 	call	81120fa4 <fprintf>
								#endif
								break;
81115298:	0001883a 	nop
8111529c:	00000b06 	br	811152cc <vSimMebTask+0x400>
						}
					} else {
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: Command Ignored wrong address (ADDR= %hhu)\n", uiCmdMeb.ucByte[3]);
811152a0:	d0a06217 	ldw	r2,-32376(gp)
811152a4:	e0fffdc3 	ldbu	r3,-9(fp)
811152a8:	18c03fcc 	andi	r3,r3,255
811152ac:	180d883a 	mov	r6,r3
811152b0:	01604574 	movhi	r5,33045
811152b4:	29764504 	addi	r5,r5,-9964
811152b8:	1009883a 	mov	r4,r2
811152bc:	1120fa40 	call	81120fa4 <fprintf>

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}			
				break;
811152c0:	00000e06 	br	811152fc <vSimMebTask+0x430>
						#endif
					}

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
811152c4:	111cc380 	call	8111cc38 <vCouldNotGetCmdQueueMeb>
				}			
				break;
811152c8:	00000c06 	br	811152fc <vSimMebTask+0x430>
811152cc:	00000b06 	br	811152fc <vSimMebTask+0x430>

			default:
				#ifdef DEBUG_ON
					debug(fp,"MEB Task: Unknow state, backing to Config Mode\n");
811152d0:	d0a06217 	ldw	r2,-32376(gp)
811152d4:	100f883a 	mov	r7,r2
811152d8:	01800bc4 	movi	r6,47
811152dc:	01400044 	movi	r5,1
811152e0:	01204574 	movhi	r4,33045
811152e4:	21366e04 	addi	r4,r4,-9800
811152e8:	11216400 	call	81121640 <fwrite>
				#endif
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxMebC->eMode = sMebToConfig;
811152ec:	e0bffb17 	ldw	r2,-20(fp)
811152f0:	00c00044 	movi	r3,1
811152f4:	10c00115 	stw	r3,4(r2)
				break;
811152f8:	0001883a 	nop
		}
	}
811152fc:	003f0306 	br	81114f0c <__reset+0xfb0f4f0c>

81115300 <vPusMebTask>:
}

void vPusMebTask( TSimucam_MEB *pxMebCLocal ) {
81115300:	defffb04 	addi	sp,sp,-20
81115304:	de00012e 	bgeu	sp,et,8111530c <vPusMebTask+0xc>
81115308:	003b68fa 	trap	3
8111530c:	dfc00415 	stw	ra,16(sp)
81115310:	df000315 	stw	fp,12(sp)
81115314:	df000304 	addi	fp,sp,12
81115318:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess;
	INT8U error_code;
	unsigned char ucIL;
	static tTMPus xPusLocal;

	bSuccess = FALSE;
8111531c:	e03ffd15 	stw	zero,-12(fp)
	OSMutexPend(xMutexPus, 2, &error_code);
81115320:	d0a07317 	ldw	r2,-32308(gp)
81115324:	e0fffe44 	addi	r3,fp,-7
81115328:	180d883a 	mov	r6,r3
8111532c:	01400084 	movi	r5,2
81115330:	1009883a 	mov	r4,r2
81115334:	113c4b40 	call	8113c4b4 <OSMutexPend>
	if ( error_code == OS_ERR_NONE ) {
81115338:	e0bffe43 	ldbu	r2,-7(fp)
8111533c:	10803fcc 	andi	r2,r2,255
81115340:	10002c1e 	bne	r2,zero,811153f4 <vPusMebTask+0xf4>

	    /*Search for the PUS command*/
	    for(ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
81115344:	e03ffe05 	stb	zero,-8(fp)
81115348:	00002306 	br	811153d8 <vPusMebTask+0xd8>
	    {
            if ( xPus[ucIL].bInUse == TRUE ) {
8111534c:	e0fffe03 	ldbu	r3,-8(fp)
81115350:	00a04574 	movhi	r2,33045
81115354:	10964304 	addi	r2,r2,22796
81115358:	18c01524 	muli	r3,r3,84
8111535c:	10c5883a 	add	r2,r2,r3
81115360:	10800104 	addi	r2,r2,4
81115364:	10800017 	ldw	r2,0(r2)
81115368:	10800058 	cmpnei	r2,r2,1
8111536c:	1000171e 	bne	r2,zero,811153cc <vPusMebTask+0xcc>
                /* Need to check if the performance is the same as memcpy*/
            	xPusLocal = xPus[ucIL];
81115370:	e13ffe03 	ldbu	r4,-8(fp)
81115374:	00e04574 	movhi	r3,33045
81115378:	18cbc604 	addi	r3,r3,12056
8111537c:	00a04574 	movhi	r2,33045
81115380:	10964304 	addi	r2,r2,22796
81115384:	21001524 	muli	r4,r4,84
81115388:	1105883a 	add	r2,r2,r4
8111538c:	1009883a 	mov	r4,r2
81115390:	00801504 	movi	r2,84
81115394:	100d883a 	mov	r6,r2
81115398:	200b883a 	mov	r5,r4
8111539c:	1809883a 	mov	r4,r3
811153a0:	11220540 	call	81122054 <memcpy>
            	xPus[ucIL].bInUse = FALSE;
811153a4:	e0fffe03 	ldbu	r3,-8(fp)
811153a8:	00a04574 	movhi	r2,33045
811153ac:	10964304 	addi	r2,r2,22796
811153b0:	18c01524 	muli	r3,r3,84
811153b4:	10c5883a 	add	r2,r2,r3
811153b8:	10800104 	addi	r2,r2,4
811153bc:	10000015 	stw	zero,0(r2)
            	bSuccess = TRUE;
811153c0:	00800044 	movi	r2,1
811153c4:	e0bffd15 	stw	r2,-12(fp)
                break;
811153c8:	00000606 	br	811153e4 <vPusMebTask+0xe4>
	bSuccess = FALSE;
	OSMutexPend(xMutexPus, 2, &error_code);
	if ( error_code == OS_ERR_NONE ) {

	    /*Search for the PUS command*/
	    for(ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
811153cc:	e0bffe03 	ldbu	r2,-8(fp)
811153d0:	10800044 	addi	r2,r2,1
811153d4:	e0bffe05 	stb	r2,-8(fp)
811153d8:	e0bffe03 	ldbu	r2,-8(fp)
811153dc:	10800130 	cmpltui	r2,r2,4
811153e0:	103fda1e 	bne	r2,zero,8111534c <__reset+0xfb0f534c>
            	xPus[ucIL].bInUse = FALSE;
            	bSuccess = TRUE;
                break;
            }
	    }
	    OSMutexPost(xMutexPus);
811153e4:	d0a07317 	ldw	r2,-32308(gp)
811153e8:	1009883a 	mov	r4,r2
811153ec:	113ca580 	call	8113ca58 <OSMutexPost>
811153f0:	00000106 	br	811153f8 <vPusMebTask+0xf8>
	} else {
		vCouldNotGetMutexMebPus();
811153f4:	111cca00 	call	8111cca0 <vCouldNotGetMutexMebPus>
	}

	if ( bSuccess ) {
811153f8:	e0bffd17 	ldw	r2,-12(fp)
811153fc:	10001126 	beq	r2,zero,81115444 <vPusMebTask+0x144>

		switch (pxMebCLocal->eMode) {
81115400:	e0bfff17 	ldw	r2,-4(fp)
81115404:	10800117 	ldw	r2,4(r2)
81115408:	10c000e0 	cmpeqi	r3,r2,3
8111540c:	1800031e 	bne	r3,zero,8111541c <vPusMebTask+0x11c>
81115410:	10800120 	cmpeqi	r2,r2,4
81115414:	1000061e 	bne	r2,zero,81115430 <vPusMebTask+0x130>
				break;
			case sMebRun:
				vPusMebInTaskRunningMode(pxMebCLocal, &xPusLocal);
				break;
			default:
				break;
81115418:	00000a06 	br	81115444 <vPusMebTask+0x144>

	if ( bSuccess ) {

		switch (pxMebCLocal->eMode) {
			case sMebConfig:
				vPusMebInTaskConfigMode(pxMebCLocal, &xPusLocal);
8111541c:	01604574 	movhi	r5,33045
81115420:	294bc604 	addi	r5,r5,12056
81115424:	e13fff17 	ldw	r4,-4(fp)
81115428:	111545c0 	call	8111545c <vPusMebInTaskConfigMode>
				break;
8111542c:	00000506 	br	81115444 <vPusMebTask+0x144>
			case sMebRun:
				vPusMebInTaskRunningMode(pxMebCLocal, &xPusLocal);
81115430:	01604574 	movhi	r5,33045
81115434:	294bc604 	addi	r5,r5,12056
81115438:	e13fff17 	ldw	r4,-4(fp)
8111543c:	11157ec0 	call	811157ec <vPusMebInTaskRunningMode>
				break;
81115440:	0001883a 	nop
			default:
				break;
		}
	}
}
81115444:	0001883a 	nop
81115448:	e037883a 	mov	sp,fp
8111544c:	dfc00117 	ldw	ra,4(sp)
81115450:	df000017 	ldw	fp,0(sp)
81115454:	dec00204 	addi	sp,sp,8
81115458:	f800283a 	ret

8111545c <vPusMebInTaskConfigMode>:


/* This function should treat the PUS command in the Config Mode, need check all the things that is possible to update in this mode */
/* In the Config Mode the MEb takes control and change all values freely */
void vPusMebInTaskConfigMode( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
8111545c:	defffc04 	addi	sp,sp,-16
81115460:	de00012e 	bgeu	sp,et,81115468 <vPusMebInTaskConfigMode+0xc>
81115464:	003b68fa 	trap	3
81115468:	dfc00315 	stw	ra,12(sp)
8111546c:	df000215 	stw	fp,8(sp)
81115470:	df000204 	addi	fp,sp,8
81115474:	e13ffe15 	stw	r4,-8(fp)
81115478:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiType) {
8111547c:	e0bfff17 	ldw	r2,-4(fp)
81115480:	1080030b 	ldhu	r2,12(r2)
81115484:	10bfffcc 	andi	r2,r2,65535
81115488:	10c03ee0 	cmpeqi	r3,r2,251
8111548c:	1800081e 	bne	r3,zero,811154b0 <vPusMebInTaskConfigMode+0x54>
81115490:	10c03f20 	cmpeqi	r3,r2,252
81115494:	18000a1e 	bne	r3,zero,811154c0 <vPusMebInTaskConfigMode+0x64>
81115498:	10803ea0 	cmpeqi	r2,r2,250
8111549c:	10000c26 	beq	r2,zero,811154d0 <vPusMebInTaskConfigMode+0x74>
		/* srv-Type = 250 */
		case 250:
			vPusType250conf(pxMebCLocal, xPusL);
811154a0:	e17fff17 	ldw	r5,-4(fp)
811154a4:	e13ffe17 	ldw	r4,-8(fp)
811154a8:	11155080 	call	81115508 <vPusType250conf>
			break;
811154ac:	00001006 	br	811154f0 <vPusMebInTaskConfigMode+0x94>
		/* srv-Type = 251 */
		case 251:
			vPusType251conf(pxMebCLocal, xPusL);
811154b0:	e17fff17 	ldw	r5,-4(fp)
811154b4:	e13ffe17 	ldw	r4,-8(fp)
811154b8:	11155940 	call	81115594 <vPusType251conf>
			break;
811154bc:	00000c06 	br	811154f0 <vPusMebInTaskConfigMode+0x94>
		/* srv-Type = 252 */
		case 252:
			vPusType252conf(pxMebCLocal, xPusL);
811154c0:	e17fff17 	ldw	r5,-4(fp)
811154c4:	e13ffe17 	ldw	r4,-8(fp)
811154c8:	11155e80 	call	811155e8 <vPusType252conf>
			break;
811154cc:	00000806 	br	811154f0 <vPusMebInTaskConfigMode+0x94>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Srv-Type not allowed in this mode (CONFIG)\n\n" );
811154d0:	d0a06217 	ldw	r2,-32376(gp)
811154d4:	100f883a 	mov	r7,r2
811154d8:	01800d84 	movi	r6,54
811154dc:	01400044 	movi	r5,1
811154e0:	01204574 	movhi	r4,33045
811154e4:	21367a04 	addi	r4,r4,-9752
811154e8:	11216400 	call	81121640 <fwrite>
			#endif
			break;
811154ec:	0001883a 	nop
	}
}
811154f0:	0001883a 	nop
811154f4:	e037883a 	mov	sp,fp
811154f8:	dfc00117 	ldw	ra,4(sp)
811154fc:	df000017 	ldw	fp,0(sp)
81115500:	dec00204 	addi	sp,sp,8
81115504:	f800283a 	ret

81115508 <vPusType250conf>:

void vPusType250conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81115508:	defffc04 	addi	sp,sp,-16
8111550c:	de00012e 	bgeu	sp,et,81115514 <vPusType250conf+0xc>
81115510:	003b68fa 	trap	3
81115514:	dfc00315 	stw	ra,12(sp)
81115518:	df000215 	stw	fp,8(sp)
8111551c:	df000204 	addi	fp,sp,8
81115520:	e13ffe15 	stw	r4,-8(fp)
81115524:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiSubType) {
81115528:	e0bfff17 	ldw	r2,-4(fp)
8111552c:	1080038b 	ldhu	r2,14(r2)
81115530:	10bfffcc 	andi	r2,r2,65535
81115534:	10c00f60 	cmpeqi	r3,r2,61
81115538:	1800031e 	bne	r3,zero,81115548 <vPusType250conf+0x40>
8111553c:	10800fa0 	cmpeqi	r2,r2,62
81115540:	10000d1e 	bne	r2,zero,81115578 <vPusType250conf+0x70>
81115544:	00000406 	br	81115558 <vPusType250conf+0x50>
		/* TC_SCAM_RUN */
		case 61:
			pxMebCLocal->eMode = sMebToRun;
81115548:	e0bffe17 	ldw	r2,-8(fp)
8111554c:	00c00084 	movi	r3,2
81115550:	10c00115 	stw	r3,4(r2)
			break;
81115554:	00000906 	br	8111557c <vPusType250conf+0x74>
			break;
		/* TC_SCAM_CONFIG */
		case 60:
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
81115558:	d0a06217 	ldw	r2,-32376(gp)
8111555c:	100f883a 	mov	r7,r2
81115560:	01800b04 	movi	r6,44
81115564:	01400044 	movi	r5,1
81115568:	01204574 	movhi	r4,33045
8111556c:	21368804 	addi	r4,r4,-9696
81115570:	11216400 	call	81121640 <fwrite>
			#endif
			break;
81115574:	00000106 	br	8111557c <vPusType250conf+0x74>
			pxMebCLocal->eMode = sMebToRun;
			break;
		/* TC_SCAM_TURNOFF */
		case 62:
			/*todo: Do nothing for now */
			break;
81115578:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
			#endif
			break;
	}
}
8111557c:	0001883a 	nop
81115580:	e037883a 	mov	sp,fp
81115584:	dfc00117 	ldw	ra,4(sp)
81115588:	df000017 	ldw	fp,0(sp)
8111558c:	dec00204 	addi	sp,sp,8
81115590:	f800283a 	ret

81115594 <vPusType251conf>:

void vPusType251conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81115594:	defffc04 	addi	sp,sp,-16
81115598:	de00012e 	bgeu	sp,et,811155a0 <vPusType251conf+0xc>
8111559c:	003b68fa 	trap	3
811155a0:	dfc00315 	stw	ra,12(sp)
811155a4:	df000215 	stw	fp,8(sp)
811155a8:	df000204 	addi	fp,sp,8
811155ac:	e13ffe15 	stw	r4,-8(fp)
811155b0:	e17fff15 	stw	r5,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp, "MEB Task: Can't change the mode of the NFEE while MEB is Config mode\n\n" );
811155b4:	d0a06217 	ldw	r2,-32376(gp)
811155b8:	100f883a 	mov	r7,r2
811155bc:	01801184 	movi	r6,70
811155c0:	01400044 	movi	r5,1
811155c4:	01204574 	movhi	r4,33045
811155c8:	21369404 	addi	r4,r4,-9648
811155cc:	11216400 	call	81121640 <fwrite>
	#endif
}
811155d0:	0001883a 	nop
811155d4:	e037883a 	mov	sp,fp
811155d8:	dfc00117 	ldw	ra,4(sp)
811155dc:	df000017 	ldw	fp,0(sp)
811155e0:	dec00204 	addi	sp,sp,8
811155e4:	f800283a 	ret

811155e8 <vPusType252conf>:

void vPusType252conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
811155e8:	defffb04 	addi	sp,sp,-20
811155ec:	de00012e 	bgeu	sp,et,811155f4 <vPusType252conf+0xc>
811155f0:	003b68fa 	trap	3
811155f4:	dfc00415 	stw	ra,16(sp)
811155f8:	df000315 	stw	fp,12(sp)
811155fc:	df000304 	addi	fp,sp,12
81115600:	e13ffe15 	stw	r4,-8(fp)
81115604:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
81115608:	e0bfff17 	ldw	r2,-4(fp)
8111560c:	1080050b 	ldhu	r2,20(r2)
81115610:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
81115614:	e0bfff17 	ldw	r2,-4(fp)
81115618:	1080038b 	ldhu	r2,14(r2)
8111561c:	10bfffcc 	andi	r2,r2,65535
81115620:	10c000a0 	cmpeqi	r3,r2,2
81115624:	18000c1e 	bne	r3,zero,81115658 <vPusType252conf+0x70>
81115628:	10c00090 	cmplti	r3,r2,2
8111562c:	1800611e 	bne	r3,zero,811157b4 <vPusType252conf+0x1cc>
81115630:	10800188 	cmpgei	r2,r2,6
81115634:	10005f1e 	bne	r2,zero,811157b4 <vPusType252conf+0x1cc>
		case 3: /* TC_SCAM_SPW_LINK_ENABLE */
		case 4: /* TC_SCAM_SPW_LINK_DISABLE */
		case 5: /* TC_SCAM_SPW_LINK_RESET */
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: Can't perform this operation in the Link while Meb is Config mode \n\n");
81115638:	d0a06217 	ldw	r2,-32376(gp)
8111563c:	100f883a 	mov	r7,r2
81115640:	01801384 	movi	r6,78
81115644:	01400044 	movi	r5,1
81115648:	01204574 	movhi	r4,33045
8111564c:	2136a604 	addi	r4,r4,-9576
81115650:	11216400 	call	81121640 <fwrite>
			#endif
			break;
81115654:	00005f06 	br	811157d4 <vPusType252conf+0x1ec>
		case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */

			/* todo: For now we can only update the Logical Address and the RAMP Key */

			/* Disable the RMAP interrupt */
			bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81115658:	e0bffd0b 	ldhu	r2,-12(fp)
8111565c:	10809624 	muli	r2,r2,600
81115660:	10805504 	addi	r2,r2,340
81115664:	e0fffe17 	ldw	r3,-8(fp)
81115668:	1885883a 	add	r2,r3,r2
8111566c:	1009883a 	mov	r4,r2
81115670:	11079600 	call	81107960 <bRmapGetIrqControl>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = FALSE;
81115674:	e0bffd0b 	ldhu	r2,-12(fp)
81115678:	e0fffe17 	ldw	r3,-8(fp)
8111567c:	10809624 	muli	r2,r2,600
81115680:	1885883a 	add	r2,r3,r2
81115684:	10806504 	addi	r2,r2,404
81115688:	10000015 	stw	zero,0(r2)
			bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
8111568c:	e0bffd0b 	ldhu	r2,-12(fp)
81115690:	10809624 	muli	r2,r2,600
81115694:	10805504 	addi	r2,r2,340
81115698:	e0fffe17 	ldw	r3,-8(fp)
8111569c:	1885883a 	add	r2,r3,r2
811156a0:	1009883a 	mov	r4,r2
811156a4:	11078b80 	call	811078b8 <bRmapSetIrqControl>

			/* Change the configuration */
			bRmapGetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
811156a8:	e0bffd0b 	ldhu	r2,-12(fp)
811156ac:	10809624 	muli	r2,r2,600
811156b0:	10805504 	addi	r2,r2,340
811156b4:	e0fffe17 	ldw	r3,-8(fp)
811156b8:	1885883a 	add	r2,r3,r2
811156bc:	1009883a 	mov	r4,r2
811156c0:	1107b480 	call	81107b48 <bRmapGetCodecConfig>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char)xPusL->usiValues[12];
811156c4:	e0bffd0b 	ldhu	r2,-12(fp)
811156c8:	e0ffff17 	ldw	r3,-4(fp)
811156cc:	18c00b0b 	ldhu	r3,44(r3)
811156d0:	1809883a 	mov	r4,r3
811156d4:	e0fffe17 	ldw	r3,-8(fp)
811156d8:	10809624 	muli	r2,r2,600
811156dc:	1885883a 	add	r2,r3,r2
811156e0:	10805604 	addi	r2,r2,344
811156e4:	11000005 	stb	r4,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char)xPusL->usiValues[9];
811156e8:	e0bffd0b 	ldhu	r2,-12(fp)
811156ec:	e0ffff17 	ldw	r3,-4(fp)
811156f0:	18c0098b 	ldhu	r3,38(r3)
811156f4:	1809883a 	mov	r4,r3
811156f8:	e0fffe17 	ldw	r3,-8(fp)
811156fc:	10809624 	muli	r2,r2,600
81115700:	1885883a 	add	r2,r3,r2
81115704:	10805644 	addi	r2,r2,345
81115708:	11000005 	stb	r4,0(r2)
			bRmapSetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
8111570c:	e0bffd0b 	ldhu	r2,-12(fp)
81115710:	10809624 	muli	r2,r2,600
81115714:	10805504 	addi	r2,r2,340
81115718:	e0fffe17 	ldw	r3,-8(fp)
8111571c:	1885883a 	add	r2,r3,r2
81115720:	1009883a 	mov	r4,r2
81115724:	1107a700 	call	81107a70 <bRmapSetCodecConfig>


			/* Enable the RMAP interrupt */
			bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81115728:	e0bffd0b 	ldhu	r2,-12(fp)
8111572c:	10809624 	muli	r2,r2,600
81115730:	10805504 	addi	r2,r2,340
81115734:	e0fffe17 	ldw	r3,-8(fp)
81115738:	1885883a 	add	r2,r3,r2
8111573c:	1009883a 	mov	r4,r2
81115740:	11079600 	call	81107960 <bRmapGetIrqControl>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = TRUE;
81115744:	e0bffd0b 	ldhu	r2,-12(fp)
81115748:	e0fffe17 	ldw	r3,-8(fp)
8111574c:	10809624 	muli	r2,r2,600
81115750:	1885883a 	add	r2,r3,r2
81115754:	10806504 	addi	r2,r2,404
81115758:	00c00044 	movi	r3,1
8111575c:	10c00015 	stw	r3,0(r2)
			bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81115760:	e0bffd0b 	ldhu	r2,-12(fp)
81115764:	10809624 	muli	r2,r2,600
81115768:	10805504 	addi	r2,r2,340
8111576c:	e0fffe17 	ldw	r3,-8(fp)
81115770:	1885883a 	add	r2,r3,r2
81115774:	1009883a 	mov	r4,r2
81115778:	11078b80 	call	811078b8 <bRmapSetIrqControl>

			/* todo: Need to treat all the returns */
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
8111577c:	d0e06217 	ldw	r3,-32376(gp)
81115780:	e0bfff17 	ldw	r2,-4(fp)
81115784:	10800b0b 	ldhu	r2,44(r2)
81115788:	113fffcc 	andi	r4,r2,65535
8111578c:	e0bfff17 	ldw	r2,-4(fp)
81115790:	1080098b 	ldhu	r2,38(r2)
81115794:	10bfffcc 	andi	r2,r2,65535
81115798:	100f883a 	mov	r7,r2
8111579c:	200d883a 	mov	r6,r4
811157a0:	01604574 	movhi	r5,33045
811157a4:	2976ba04 	addi	r5,r5,-9496
811157a8:	1809883a 	mov	r4,r3
811157ac:	1120fa40 	call	81120fa4 <fprintf>
			#endif

			break;
811157b0:	00000806 	br	811157d4 <vPusType252conf+0x1ec>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
811157b4:	d0a06217 	ldw	r2,-32376(gp)
811157b8:	100f883a 	mov	r7,r2
811157bc:	01800b04 	movi	r6,44
811157c0:	01400044 	movi	r5,1
811157c4:	01204574 	movhi	r4,33045
811157c8:	21368804 	addi	r4,r4,-9696
811157cc:	11216400 	call	81121640 <fwrite>
			#endif
			break;
811157d0:	0001883a 	nop
	}
}
811157d4:	0001883a 	nop
811157d8:	e037883a 	mov	sp,fp
811157dc:	dfc00117 	ldw	ra,4(sp)
811157e0:	df000017 	ldw	fp,0(sp)
811157e4:	dec00204 	addi	sp,sp,8
811157e8:	f800283a 	ret

811157ec <vPusMebInTaskRunningMode>:




/* This function should treat the PUS command in the Running Mode, need check all the things that is possible to update in this mode */
void vPusMebInTaskRunningMode( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
811157ec:	defffc04 	addi	sp,sp,-16
811157f0:	de00012e 	bgeu	sp,et,811157f8 <vPusMebInTaskRunningMode+0xc>
811157f4:	003b68fa 	trap	3
811157f8:	dfc00315 	stw	ra,12(sp)
811157fc:	df000215 	stw	fp,8(sp)
81115800:	df000204 	addi	fp,sp,8
81115804:	e13ffe15 	stw	r4,-8(fp)
81115808:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiType) {
8111580c:	e0bfff17 	ldw	r2,-4(fp)
81115810:	1080030b 	ldhu	r2,12(r2)
81115814:	10bfffcc 	andi	r2,r2,65535
81115818:	10c03ee0 	cmpeqi	r3,r2,251
8111581c:	1800081e 	bne	r3,zero,81115840 <vPusMebInTaskRunningMode+0x54>
81115820:	10c03f20 	cmpeqi	r3,r2,252
81115824:	18000a1e 	bne	r3,zero,81115850 <vPusMebInTaskRunningMode+0x64>
81115828:	10803ea0 	cmpeqi	r2,r2,250
8111582c:	10000c26 	beq	r2,zero,81115860 <vPusMebInTaskRunningMode+0x74>
		/* srv-Type = 250 */
		case 250:
			vPusType250run(pxMebCLocal, xPusL);
81115830:	e17fff17 	ldw	r5,-4(fp)
81115834:	e13ffe17 	ldw	r4,-8(fp)
81115838:	11158980 	call	81115898 <vPusType250run>
			break;
8111583c:	00001006 	br	81115880 <vPusMebInTaskRunningMode+0x94>
		/* srv-Type = 251 */
		case 251:
			vPusType251run(pxMebCLocal, xPusL);
81115840:	e17fff17 	ldw	r5,-4(fp)
81115844:	e13ffe17 	ldw	r4,-8(fp)
81115848:	11159240 	call	81115924 <vPusType251run>
			break;
8111584c:	00000c06 	br	81115880 <vPusMebInTaskRunningMode+0x94>
		/* srv-Type = 252 */
		case 252:
			vPusType252run(pxMebCLocal, xPusL);
81115850:	e17fff17 	ldw	r5,-4(fp)
81115854:	e13ffe17 	ldw	r4,-8(fp)
81115858:	1115a380 	call	81115a38 <vPusType252run>
			break;
8111585c:	00000806 	br	81115880 <vPusMebInTaskRunningMode+0x94>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Srv-Type not allowed in this mode (RUN)\n\n" );
81115860:	d0a06217 	ldw	r2,-32376(gp)
81115864:	100f883a 	mov	r7,r2
81115868:	01800cc4 	movi	r6,51
8111586c:	01400044 	movi	r5,1
81115870:	01204574 	movhi	r4,33045
81115874:	2136ca04 	addi	r4,r4,-9432
81115878:	11216400 	call	81121640 <fwrite>
			#endif
			break;
8111587c:	0001883a 	nop
	}
}
81115880:	0001883a 	nop
81115884:	e037883a 	mov	sp,fp
81115888:	dfc00117 	ldw	ra,4(sp)
8111588c:	df000017 	ldw	fp,0(sp)
81115890:	dec00204 	addi	sp,sp,8
81115894:	f800283a 	ret

81115898 <vPusType250run>:


void vPusType250run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81115898:	defffc04 	addi	sp,sp,-16
8111589c:	de00012e 	bgeu	sp,et,811158a4 <vPusType250run+0xc>
811158a0:	003b68fa 	trap	3
811158a4:	dfc00315 	stw	ra,12(sp)
811158a8:	df000215 	stw	fp,8(sp)
811158ac:	df000204 	addi	fp,sp,8
811158b0:	e13ffe15 	stw	r4,-8(fp)
811158b4:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiSubType) {
811158b8:	e0bfff17 	ldw	r2,-4(fp)
811158bc:	1080038b 	ldhu	r2,14(r2)
811158c0:	10bfffcc 	andi	r2,r2,65535
811158c4:	10c00f20 	cmpeqi	r3,r2,60
811158c8:	1800031e 	bne	r3,zero,811158d8 <vPusType250run+0x40>
811158cc:	10800fa0 	cmpeqi	r2,r2,62
811158d0:	10000d1e 	bne	r2,zero,81115908 <vPusType250run+0x70>
811158d4:	00000406 	br	811158e8 <vPusType250run+0x50>
		/* TC_SCAM_CONFIG */
		case 60:
			pxMebCLocal->eMode = sMebToConfig;
811158d8:	e0bffe17 	ldw	r2,-8(fp)
811158dc:	00c00044 	movi	r3,1
811158e0:	10c00115 	stw	r3,4(r2)
			break;
811158e4:	00000906 	br	8111590c <vPusType250run+0x74>
			break;
		/* TC_SCAM_RUN */
		case 61:
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
811158e8:	d0a06217 	ldw	r2,-32376(gp)
811158ec:	100f883a 	mov	r7,r2
811158f0:	01800c84 	movi	r6,50
811158f4:	01400044 	movi	r5,1
811158f8:	01204574 	movhi	r4,33045
811158fc:	2136d704 	addi	r4,r4,-9380
81115900:	11216400 	call	81121640 <fwrite>
			#endif
			break;
81115904:	00000106 	br	8111590c <vPusType250run+0x74>
			pxMebCLocal->eMode = sMebToConfig;
			break;
		/* TC_SCAM_TURNOFF */
		case 62:
			/*todo: Do nothing for now */
			break;
81115908:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
			#endif
			break;
	}
}
8111590c:	0001883a 	nop
81115910:	e037883a 	mov	sp,fp
81115914:	dfc00117 	ldw	ra,4(sp)
81115918:	df000017 	ldw	fp,0(sp)
8111591c:	dec00204 	addi	sp,sp,8
81115920:	f800283a 	ret

81115924 <vPusType251run>:

void vPusType251run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81115924:	defffb04 	addi	sp,sp,-20
81115928:	de00012e 	bgeu	sp,et,81115930 <vPusType251run+0xc>
8111592c:	003b68fa 	trap	3
81115930:	dfc00415 	stw	ra,16(sp)
81115934:	df000315 	stw	fp,12(sp)
81115938:	df000304 	addi	fp,sp,12
8111593c:	e13ffe15 	stw	r4,-8(fp)
81115940:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
81115944:	e0bfff17 	ldw	r2,-4(fp)
81115948:	1080050b 	ldhu	r2,20(r2)
8111594c:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
81115950:	e0bfff17 	ldw	r2,-4(fp)
81115954:	1080038b 	ldhu	r2,14(r2)
81115958:	10bfffcc 	andi	r2,r2,65535
8111595c:	10c000a0 	cmpeqi	r3,r2,2
81115960:	18000f1e 	bne	r3,zero,811159a0 <vPusType251run+0x7c>
81115964:	10c00160 	cmpeqi	r3,r2,5
81115968:	1800181e 	bne	r3,zero,811159cc <vPusType251run+0xa8>
8111596c:	10800060 	cmpeqi	r2,r2,1
81115970:	10002126 	beq	r2,zero,811159f8 <vPusType251run+0xd4>
		/* TC_SCAM_FEE_CONFIG_ENTER */
		case 1:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_CONFIG, 0, usiFeeInstL );
81115974:	e0bffd0b 	ldhu	r2,-12(fp)
81115978:	10800444 	addi	r2,r2,17
8111597c:	10803fcc 	andi	r2,r2,255
81115980:	e0fffd0b 	ldhu	r3,-12(fp)
81115984:	18c03fcc 	andi	r3,r3,255
81115988:	180f883a 	mov	r7,r3
8111598c:	000d883a 	mov	r6,zero
81115990:	01400044 	movi	r5,1
81115994:	1009883a 	mov	r4,r2
81115998:	1115ed00 	call	81115ed0 <vSendCmdQToNFeeCTRL_GEN>
			break;
8111599c:	00002006 	br	81115a20 <vPusType251run+0xfc>
		/* TC_SCAM_FEE_STANDBY_ENTER */
		case 2:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_STANDBY, 0, usiFeeInstL );
811159a0:	e0bffd0b 	ldhu	r2,-12(fp)
811159a4:	10800444 	addi	r2,r2,17
811159a8:	10803fcc 	andi	r2,r2,255
811159ac:	e0fffd0b 	ldhu	r3,-12(fp)
811159b0:	18c03fcc 	andi	r3,r3,255
811159b4:	180f883a 	mov	r7,r3
811159b8:	000d883a 	mov	r6,zero
811159bc:	01400104 	movi	r5,4
811159c0:	1009883a 	mov	r4,r2
811159c4:	1115ed00 	call	81115ed0 <vSendCmdQToNFeeCTRL_GEN>
			break;
811159c8:	00001506 	br	81115a20 <vPusType251run+0xfc>
		/* TC_SCAM_FEE_CALIBRATION_TEST_ENTER */
		case 5:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_FULL_PATTERN, 0, usiFeeInstL );
811159cc:	e0bffd0b 	ldhu	r2,-12(fp)
811159d0:	10800444 	addi	r2,r2,17
811159d4:	10803fcc 	andi	r2,r2,255
811159d8:	e0fffd0b 	ldhu	r3,-12(fp)
811159dc:	18c03fcc 	andi	r3,r3,255
811159e0:	180f883a 	mov	r7,r3
811159e4:	000d883a 	mov	r6,zero
811159e8:	01400204 	movi	r5,8
811159ec:	1009883a 	mov	r4,r2
811159f0:	1115ed00 	call	81115ed0 <vSendCmdQToNFeeCTRL_GEN>
			break;
811159f4:	00000a06 	br	81115a20 <vPusType251run+0xfc>
		case 3:
		case 4:
		case 6:
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not implemented yet (SubType:%hu)\n\n",xPusL->usiSubType );
811159f8:	d0e06217 	ldw	r3,-32376(gp)
811159fc:	e0bfff17 	ldw	r2,-4(fp)
81115a00:	1080038b 	ldhu	r2,14(r2)
81115a04:	10bfffcc 	andi	r2,r2,65535
81115a08:	100d883a 	mov	r6,r2
81115a0c:	01604574 	movhi	r5,33045
81115a10:	2976e404 	addi	r5,r5,-9328
81115a14:	1809883a 	mov	r4,r3
81115a18:	1120fa40 	call	81120fa4 <fprintf>
			#endif
			break;
81115a1c:	0001883a 	nop
	}
}
81115a20:	0001883a 	nop
81115a24:	e037883a 	mov	sp,fp
81115a28:	dfc00117 	ldw	ra,4(sp)
81115a2c:	df000017 	ldw	fp,0(sp)
81115a30:	dec00204 	addi	sp,sp,8
81115a34:	f800283a 	ret

81115a38 <vPusType252run>:

void vPusType252run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81115a38:	defffb04 	addi	sp,sp,-20
81115a3c:	de00012e 	bgeu	sp,et,81115a44 <vPusType252run+0xc>
81115a40:	003b68fa 	trap	3
81115a44:	dfc00415 	stw	ra,16(sp)
81115a48:	df000315 	stw	fp,12(sp)
81115a4c:	df000304 	addi	fp,sp,12
81115a50:	e13ffe15 	stw	r4,-8(fp)
81115a54:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
81115a58:	e0bfff17 	ldw	r2,-4(fp)
81115a5c:	1080050b 	ldhu	r2,20(r2)
81115a60:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
81115a64:	e0bfff17 	ldw	r2,-4(fp)
81115a68:	1080038b 	ldhu	r2,14(r2)
81115a6c:	10bfffcc 	andi	r2,r2,65535
81115a70:	10c000e0 	cmpeqi	r3,r2,3
81115a74:	18000a1e 	bne	r3,zero,81115aa0 <vPusType252run+0x68>
81115a78:	10c00108 	cmpgei	r3,r2,4
81115a7c:	1800031e 	bne	r3,zero,81115a8c <vPusType252run+0x54>
81115a80:	108000a0 	cmpeqi	r2,r2,2
81115a84:	1000581e 	bne	r2,zero,81115be8 <vPusType252run+0x1b0>
81115a88:	0000be06 	br	81115d84 <vPusType252run+0x34c>
81115a8c:	10c00120 	cmpeqi	r3,r2,4
81115a90:	18002c1e 	bne	r3,zero,81115b44 <vPusType252run+0x10c>
81115a94:	10800160 	cmpeqi	r2,r2,5
81115a98:	1000c21e 	bne	r2,zero,81115da4 <vPusType252run+0x36c>
81115a9c:	0000b906 	br	81115d84 <vPusType252run+0x34c>
		case 3: /* TC_SCAM_SPW_LINK_ENABLE */
			bSpwcGetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81115aa0:	e0bffd0b 	ldhu	r2,-12(fp)
81115aa4:	10809624 	muli	r2,r2,600
81115aa8:	10809b04 	addi	r2,r2,620
81115aac:	e0fffe17 	ldw	r3,-8(fp)
81115ab0:	1885883a 	add	r2,r3,r2
81115ab4:	1009883a 	mov	r4,r2
81115ab8:	110a2e40 	call	8110a2e4 <bSpwcGetLink>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bLinkStart = FALSE;
81115abc:	e0bffd0b 	ldhu	r2,-12(fp)
81115ac0:	e0fffe17 	ldw	r3,-8(fp)
81115ac4:	10809624 	muli	r2,r2,600
81115ac8:	1885883a 	add	r2,r3,r2
81115acc:	10809d04 	addi	r2,r2,628
81115ad0:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bAutostart = TRUE;
81115ad4:	e0bffd0b 	ldhu	r2,-12(fp)
81115ad8:	e0fffe17 	ldw	r3,-8(fp)
81115adc:	10809624 	muli	r2,r2,600
81115ae0:	1885883a 	add	r2,r3,r2
81115ae4:	10809c04 	addi	r2,r2,624
81115ae8:	00c00044 	movi	r3,1
81115aec:	10c00015 	stw	r3,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bDisconnect = FALSE;
81115af0:	e0bffd0b 	ldhu	r2,-12(fp)
81115af4:	e0fffe17 	ldw	r3,-8(fp)
81115af8:	10809624 	muli	r2,r2,600
81115afc:	1885883a 	add	r2,r3,r2
81115b00:	10809e04 	addi	r2,r2,632
81115b04:	10000015 	stw	zero,0(r2)
			bSpwcSetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81115b08:	e0bffd0b 	ldhu	r2,-12(fp)
81115b0c:	10809624 	muli	r2,r2,600
81115b10:	10809b04 	addi	r2,r2,620
81115b14:	e0fffe17 	ldw	r3,-8(fp)
81115b18:	1885883a 	add	r2,r3,r2
81115b1c:	1009883a 	mov	r4,r2
81115b20:	110a1b00 	call	8110a1b0 <bSpwcSetLink>
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: Link enable (NFEE-%hu)\n\n", usiFeeInstL);
81115b24:	d0a06217 	ldw	r2,-32376(gp)
81115b28:	e0fffd0b 	ldhu	r3,-12(fp)
81115b2c:	180d883a 	mov	r6,r3
81115b30:	01604574 	movhi	r5,33045
81115b34:	2976f204 	addi	r5,r5,-9272
81115b38:	1009883a 	mov	r4,r2
81115b3c:	1120fa40 	call	81120fa4 <fprintf>
			#endif

			break;
81115b40:	00009906 	br	81115da8 <vPusType252run+0x370>

		case 4: /* TC_SCAM_SPW_LINK_DISABLE */
			bSpwcGetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81115b44:	e0bffd0b 	ldhu	r2,-12(fp)
81115b48:	10809624 	muli	r2,r2,600
81115b4c:	10809b04 	addi	r2,r2,620
81115b50:	e0fffe17 	ldw	r3,-8(fp)
81115b54:	1885883a 	add	r2,r3,r2
81115b58:	1009883a 	mov	r4,r2
81115b5c:	110a2e40 	call	8110a2e4 <bSpwcGetLink>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bLinkStart = FALSE;
81115b60:	e0bffd0b 	ldhu	r2,-12(fp)
81115b64:	e0fffe17 	ldw	r3,-8(fp)
81115b68:	10809624 	muli	r2,r2,600
81115b6c:	1885883a 	add	r2,r3,r2
81115b70:	10809d04 	addi	r2,r2,628
81115b74:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bAutostart = FALSE;
81115b78:	e0bffd0b 	ldhu	r2,-12(fp)
81115b7c:	e0fffe17 	ldw	r3,-8(fp)
81115b80:	10809624 	muli	r2,r2,600
81115b84:	1885883a 	add	r2,r3,r2
81115b88:	10809c04 	addi	r2,r2,624
81115b8c:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bDisconnect = TRUE;
81115b90:	e0bffd0b 	ldhu	r2,-12(fp)
81115b94:	e0fffe17 	ldw	r3,-8(fp)
81115b98:	10809624 	muli	r2,r2,600
81115b9c:	1885883a 	add	r2,r3,r2
81115ba0:	10809e04 	addi	r2,r2,632
81115ba4:	00c00044 	movi	r3,1
81115ba8:	10c00015 	stw	r3,0(r2)
			bSpwcSetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81115bac:	e0bffd0b 	ldhu	r2,-12(fp)
81115bb0:	10809624 	muli	r2,r2,600
81115bb4:	10809b04 	addi	r2,r2,620
81115bb8:	e0fffe17 	ldw	r3,-8(fp)
81115bbc:	1885883a 	add	r2,r3,r2
81115bc0:	1009883a 	mov	r4,r2
81115bc4:	110a1b00 	call	8110a1b0 <bSpwcSetLink>
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: Link disable (NFEE-%hu)\n\n", usiFeeInstL);
81115bc8:	d0a06217 	ldw	r2,-32376(gp)
81115bcc:	e0fffd0b 	ldhu	r3,-12(fp)
81115bd0:	180d883a 	mov	r6,r3
81115bd4:	01604574 	movhi	r5,33045
81115bd8:	2976fb04 	addi	r5,r5,-9236
81115bdc:	1009883a 	mov	r4,r2
81115be0:	1120fa40 	call	81120fa4 <fprintf>
			#endif

			break;
81115be4:	00007006 	br	81115da8 <vPusType252run+0x370>
			break;

		case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */

			/* todo: For now we can only update the Logical Address and the RAMP Key */
			if ( pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xControl.eMode == sFeeConfig ) {
81115be8:	e0bffd0b 	ldhu	r2,-12(fp)
81115bec:	e0fffe17 	ldw	r3,-8(fp)
81115bf0:	10809624 	muli	r2,r2,600
81115bf4:	1885883a 	add	r2,r3,r2
81115bf8:	10803e04 	addi	r2,r2,248
81115bfc:	10800017 	ldw	r2,0(r2)
81115c00:	10800058 	cmpnei	r2,r2,1
81115c04:	10004a1e 	bne	r2,zero,81115d30 <vPusType252run+0x2f8>
				/* Disable the RMAP interrupt */
				bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81115c08:	e0bffd0b 	ldhu	r2,-12(fp)
81115c0c:	10809624 	muli	r2,r2,600
81115c10:	10805504 	addi	r2,r2,340
81115c14:	e0fffe17 	ldw	r3,-8(fp)
81115c18:	1885883a 	add	r2,r3,r2
81115c1c:	1009883a 	mov	r4,r2
81115c20:	11079600 	call	81107960 <bRmapGetIrqControl>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = FALSE;
81115c24:	e0bffd0b 	ldhu	r2,-12(fp)
81115c28:	e0fffe17 	ldw	r3,-8(fp)
81115c2c:	10809624 	muli	r2,r2,600
81115c30:	1885883a 	add	r2,r3,r2
81115c34:	10806504 	addi	r2,r2,404
81115c38:	10000015 	stw	zero,0(r2)
				bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81115c3c:	e0bffd0b 	ldhu	r2,-12(fp)
81115c40:	10809624 	muli	r2,r2,600
81115c44:	10805504 	addi	r2,r2,340
81115c48:	e0fffe17 	ldw	r3,-8(fp)
81115c4c:	1885883a 	add	r2,r3,r2
81115c50:	1009883a 	mov	r4,r2
81115c54:	11078b80 	call	811078b8 <bRmapSetIrqControl>

				/* Change the configuration */
				bRmapGetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
81115c58:	e0bffd0b 	ldhu	r2,-12(fp)
81115c5c:	10809624 	muli	r2,r2,600
81115c60:	10805504 	addi	r2,r2,340
81115c64:	e0fffe17 	ldw	r3,-8(fp)
81115c68:	1885883a 	add	r2,r3,r2
81115c6c:	1009883a 	mov	r4,r2
81115c70:	1107b480 	call	81107b48 <bRmapGetCodecConfig>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char)xPusL->usiValues[12];
81115c74:	e0bffd0b 	ldhu	r2,-12(fp)
81115c78:	e0ffff17 	ldw	r3,-4(fp)
81115c7c:	18c00b0b 	ldhu	r3,44(r3)
81115c80:	1809883a 	mov	r4,r3
81115c84:	e0fffe17 	ldw	r3,-8(fp)
81115c88:	10809624 	muli	r2,r2,600
81115c8c:	1885883a 	add	r2,r3,r2
81115c90:	10805604 	addi	r2,r2,344
81115c94:	11000005 	stb	r4,0(r2)
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char)xPusL->usiValues[9];
81115c98:	e0bffd0b 	ldhu	r2,-12(fp)
81115c9c:	e0ffff17 	ldw	r3,-4(fp)
81115ca0:	18c0098b 	ldhu	r3,38(r3)
81115ca4:	1809883a 	mov	r4,r3
81115ca8:	e0fffe17 	ldw	r3,-8(fp)
81115cac:	10809624 	muli	r2,r2,600
81115cb0:	1885883a 	add	r2,r3,r2
81115cb4:	10805644 	addi	r2,r2,345
81115cb8:	11000005 	stb	r4,0(r2)
				bRmapSetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
81115cbc:	e0bffd0b 	ldhu	r2,-12(fp)
81115cc0:	10809624 	muli	r2,r2,600
81115cc4:	10805504 	addi	r2,r2,340
81115cc8:	e0fffe17 	ldw	r3,-8(fp)
81115ccc:	1885883a 	add	r2,r3,r2
81115cd0:	1009883a 	mov	r4,r2
81115cd4:	1107a700 	call	81107a70 <bRmapSetCodecConfig>


				/* Enable the RMAP interrupt */
				bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81115cd8:	e0bffd0b 	ldhu	r2,-12(fp)
81115cdc:	10809624 	muli	r2,r2,600
81115ce0:	10805504 	addi	r2,r2,340
81115ce4:	e0fffe17 	ldw	r3,-8(fp)
81115ce8:	1885883a 	add	r2,r3,r2
81115cec:	1009883a 	mov	r4,r2
81115cf0:	11079600 	call	81107960 <bRmapGetIrqControl>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = TRUE;
81115cf4:	e0bffd0b 	ldhu	r2,-12(fp)
81115cf8:	e0fffe17 	ldw	r3,-8(fp)
81115cfc:	10809624 	muli	r2,r2,600
81115d00:	1885883a 	add	r2,r3,r2
81115d04:	10806504 	addi	r2,r2,404
81115d08:	00c00044 	movi	r3,1
81115d0c:	10c00015 	stw	r3,0(r2)
				bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81115d10:	e0bffd0b 	ldhu	r2,-12(fp)
81115d14:	10809624 	muli	r2,r2,600
81115d18:	10805504 	addi	r2,r2,340
81115d1c:	e0fffe17 	ldw	r3,-8(fp)
81115d20:	1885883a 	add	r2,r3,r2
81115d24:	1009883a 	mov	r4,r2
81115d28:	11078b80 	call	811078b8 <bRmapSetIrqControl>
81115d2c:	00000706 	br	81115d4c <vPusType252run+0x314>
			} else {
				#ifdef DEBUG_ON
					fprintf(fp,"MEB Task: NFEE-%hu is not in the Config Mode ( Changes not performed )\n\n", usiFeeInstL);
81115d30:	d0a06217 	ldw	r2,-32376(gp)
81115d34:	e0fffd0b 	ldhu	r3,-12(fp)
81115d38:	180d883a 	mov	r6,r3
81115d3c:	01604574 	movhi	r5,33045
81115d40:	29770404 	addi	r5,r5,-9200
81115d44:	1009883a 	mov	r4,r2
81115d48:	1120fa40 	call	81120fa4 <fprintf>
				#endif
			}

			/* todo: Need to treat all the returns */
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
81115d4c:	d0e06217 	ldw	r3,-32376(gp)
81115d50:	e0bfff17 	ldw	r2,-4(fp)
81115d54:	10800b0b 	ldhu	r2,44(r2)
81115d58:	113fffcc 	andi	r4,r2,65535
81115d5c:	e0bfff17 	ldw	r2,-4(fp)
81115d60:	1080098b 	ldhu	r2,38(r2)
81115d64:	10bfffcc 	andi	r2,r2,65535
81115d68:	100f883a 	mov	r7,r2
81115d6c:	200d883a 	mov	r6,r4
81115d70:	01604574 	movhi	r5,33045
81115d74:	2976ba04 	addi	r5,r5,-9496
81115d78:	1809883a 	mov	r4,r3
81115d7c:	1120fa40 	call	81120fa4 <fprintf>
			#endif
			break;
81115d80:	00000906 	br	81115da8 <vPusType252run+0x370>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
81115d84:	d0a06217 	ldw	r2,-32376(gp)
81115d88:	100f883a 	mov	r7,r2
81115d8c:	01800c84 	movi	r6,50
81115d90:	01400044 	movi	r5,1
81115d94:	01204574 	movhi	r4,33045
81115d98:	2136d704 	addi	r4,r4,-9380
81115d9c:	11216400 	call	81121640 <fwrite>
			#endif
			break;
81115da0:	00000106 	br	81115da8 <vPusType252run+0x370>

			break;

		case 5: /* TC_SCAM_SPW_LINK_RESET */
			/* todo:Do nothing, don't know what is reset spw link */
			break;
81115da4:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
			#endif
			break;
	}
}
81115da8:	0001883a 	nop
81115dac:	e037883a 	mov	sp,fp
81115db0:	dfc00117 	ldw	ra,4(sp)
81115db4:	df000017 	ldw	fp,0(sp)
81115db8:	dec00204 	addi	sp,sp,8
81115dbc:	f800283a 	ret

81115dc0 <vSendCmdQToNFeeCTRL>:



void vSendCmdQToNFeeCTRL( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81115dc0:	defff904 	addi	sp,sp,-28
81115dc4:	de00012e 	bgeu	sp,et,81115dcc <vSendCmdQToNFeeCTRL+0xc>
81115dc8:	003b68fa 	trap	3
81115dcc:	dfc00615 	stw	ra,24(sp)
81115dd0:	df000515 	stw	fp,20(sp)
81115dd4:	df000504 	addi	fp,sp,20
81115dd8:	2807883a 	mov	r3,r5
81115ddc:	3005883a 	mov	r2,r6
81115de0:	e13ffd05 	stb	r4,-12(fp)
81115de4:	e0fffe05 	stb	r3,-8(fp)
81115de8:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81115dec:	00800404 	movi	r2,16
81115df0:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81115df4:	e0bffd03 	ldbu	r2,-12(fp)
81115df8:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81115dfc:	e0bffe03 	ldbu	r2,-8(fp)
81115e00:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81115e04:	e0bfff03 	ldbu	r2,-4(fp)
81115e08:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
81115e0c:	d0a07017 	ldw	r2,-32320(gp)
81115e10:	e0fffc17 	ldw	r3,-16(fp)
81115e14:	180b883a 	mov	r5,r3
81115e18:	1009883a 	mov	r4,r2
81115e1c:	113d9d00 	call	8113d9d0 <OSQPost>
81115e20:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81115e24:	e0bffb03 	ldbu	r2,-20(fp)
81115e28:	10000126 	beq	r2,zero,81115e30 <vSendCmdQToNFeeCTRL+0x70>
		vFailSendMsgFeeCTRL();
81115e2c:	111d0d00 	call	8111d0d0 <vFailSendMsgFeeCTRL>
	}
}
81115e30:	0001883a 	nop
81115e34:	e037883a 	mov	sp,fp
81115e38:	dfc00117 	ldw	ra,4(sp)
81115e3c:	df000017 	ldw	fp,0(sp)
81115e40:	dec00204 	addi	sp,sp,8
81115e44:	f800283a 	ret

81115e48 <vSendCmdQToNFeeCTRL_PRIO>:

void vSendCmdQToNFeeCTRL_PRIO( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81115e48:	defff904 	addi	sp,sp,-28
81115e4c:	de00012e 	bgeu	sp,et,81115e54 <vSendCmdQToNFeeCTRL_PRIO+0xc>
81115e50:	003b68fa 	trap	3
81115e54:	dfc00615 	stw	ra,24(sp)
81115e58:	df000515 	stw	fp,20(sp)
81115e5c:	df000504 	addi	fp,sp,20
81115e60:	2807883a 	mov	r3,r5
81115e64:	3005883a 	mov	r2,r6
81115e68:	e13ffd05 	stb	r4,-12(fp)
81115e6c:	e0fffe05 	stb	r3,-8(fp)
81115e70:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81115e74:	00800404 	movi	r2,16
81115e78:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81115e7c:	e0bffd03 	ldbu	r2,-12(fp)
81115e80:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81115e84:	e0bffe03 	ldbu	r2,-8(fp)
81115e88:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81115e8c:	e0bfff03 	ldbu	r2,-4(fp)
81115e90:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPostFront(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
81115e94:	d0a07017 	ldw	r2,-32320(gp)
81115e98:	e0fffc17 	ldw	r3,-16(fp)
81115e9c:	180b883a 	mov	r5,r3
81115ea0:	1009883a 	mov	r4,r2
81115ea4:	113db400 	call	8113db40 <OSQPostFront>
81115ea8:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81115eac:	e0bffb03 	ldbu	r2,-20(fp)
81115eb0:	10000126 	beq	r2,zero,81115eb8 <vSendCmdQToNFeeCTRL_PRIO+0x70>
		vFailSendMsgFeeCTRL();
81115eb4:	111d0d00 	call	8111d0d0 <vFailSendMsgFeeCTRL>
	}
}
81115eb8:	0001883a 	nop
81115ebc:	e037883a 	mov	sp,fp
81115ec0:	dfc00117 	ldw	ra,4(sp)
81115ec4:	df000017 	ldw	fp,0(sp)
81115ec8:	dec00204 	addi	sp,sp,8
81115ecc:	f800283a 	ret

81115ed0 <vSendCmdQToNFeeCTRL_GEN>:


/* Send to FEEs using the NFEE Controller */
void vSendCmdQToNFeeCTRL_GEN( unsigned char ADDR,unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81115ed0:	defff804 	addi	sp,sp,-32
81115ed4:	de00012e 	bgeu	sp,et,81115edc <vSendCmdQToNFeeCTRL_GEN+0xc>
81115ed8:	003b68fa 	trap	3
81115edc:	dfc00715 	stw	ra,28(sp)
81115ee0:	df000615 	stw	fp,24(sp)
81115ee4:	df000604 	addi	fp,sp,24
81115ee8:	2011883a 	mov	r8,r4
81115eec:	2809883a 	mov	r4,r5
81115ef0:	3007883a 	mov	r3,r6
81115ef4:	3805883a 	mov	r2,r7
81115ef8:	e23ffc05 	stb	r8,-16(fp)
81115efc:	e13ffd05 	stb	r4,-12(fp)
81115f00:	e0fffe05 	stb	r3,-8(fp)
81115f04:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = ADDR;
81115f08:	e0bffc03 	ldbu	r2,-16(fp)
81115f0c:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81115f10:	e0bffd03 	ldbu	r2,-12(fp)
81115f14:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81115f18:	e0bffe03 	ldbu	r2,-8(fp)
81115f1c:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81115f20:	e0bfff03 	ldbu	r2,-4(fp)
81115f24:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
81115f28:	d0a07017 	ldw	r2,-32320(gp)
81115f2c:	e0fffb17 	ldw	r3,-20(fp)
81115f30:	180b883a 	mov	r5,r3
81115f34:	1009883a 	mov	r4,r2
81115f38:	113d9d00 	call	8113d9d0 <OSQPost>
81115f3c:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
81115f40:	e0bffa03 	ldbu	r2,-24(fp)
81115f44:	10000126 	beq	r2,zero,81115f4c <vSendCmdQToNFeeCTRL_GEN+0x7c>
		vFailSendMsgFeeCTRL();
81115f48:	111d0d00 	call	8111d0d0 <vFailSendMsgFeeCTRL>
	}
}
81115f4c:	0001883a 	nop
81115f50:	e037883a 	mov	sp,fp
81115f54:	dfc00117 	ldw	ra,4(sp)
81115f58:	df000017 	ldw	fp,0(sp)
81115f5c:	dec00204 	addi	sp,sp,8
81115f60:	f800283a 	ret

81115f64 <vSendCmdQToDataCTRL>:


void vSendCmdQToDataCTRL( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81115f64:	defff904 	addi	sp,sp,-28
81115f68:	de00012e 	bgeu	sp,et,81115f70 <vSendCmdQToDataCTRL+0xc>
81115f6c:	003b68fa 	trap	3
81115f70:	dfc00615 	stw	ra,24(sp)
81115f74:	df000515 	stw	fp,20(sp)
81115f78:	df000504 	addi	fp,sp,20
81115f7c:	2807883a 	mov	r3,r5
81115f80:	3005883a 	mov	r2,r6
81115f84:	e13ffd05 	stb	r4,-12(fp)
81115f88:	e0fffe05 	stb	r3,-8(fp)
81115f8c:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_DATA_CTRL_ADDR;
81115f90:	00800804 	movi	r2,32
81115f94:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81115f98:	e0bffd03 	ldbu	r2,-12(fp)
81115f9c:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81115fa0:	e0bffe03 	ldbu	r2,-8(fp)
81115fa4:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81115fa8:	e0bfff03 	ldbu	r2,-4(fp)
81115fac:	e0bffc05 	stb	r2,-16(fp)

	/*Send a command to other entities (Data Controller) */
	error_codel = OSQPost(xQMaskDataCtrl, (void *)uiCmdtoSend.ulWord);
81115fb0:	d0a05f17 	ldw	r2,-32388(gp)
81115fb4:	e0fffc17 	ldw	r3,-16(fp)
81115fb8:	180b883a 	mov	r5,r3
81115fbc:	1009883a 	mov	r4,r2
81115fc0:	113d9d00 	call	8113d9d0 <OSQPost>
81115fc4:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81115fc8:	e0bffb03 	ldbu	r2,-20(fp)
81115fcc:	10000126 	beq	r2,zero,81115fd4 <vSendCmdQToDataCTRL+0x70>
		vFailSendMsgDataCTRL();
81115fd0:	111d11c0 	call	8111d11c <vFailSendMsgDataCTRL>
	}
}
81115fd4:	0001883a 	nop
81115fd8:	e037883a 	mov	sp,fp
81115fdc:	dfc00117 	ldw	ra,4(sp)
81115fe0:	df000017 	ldw	fp,0(sp)
81115fe4:	dec00204 	addi	sp,sp,8
81115fe8:	f800283a 	ret

81115fec <vSendCmdQToDataCTRL_PRIO>:

void vSendCmdQToDataCTRL_PRIO( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81115fec:	defff904 	addi	sp,sp,-28
81115ff0:	de00012e 	bgeu	sp,et,81115ff8 <vSendCmdQToDataCTRL_PRIO+0xc>
81115ff4:	003b68fa 	trap	3
81115ff8:	dfc00615 	stw	ra,24(sp)
81115ffc:	df000515 	stw	fp,20(sp)
81116000:	df000504 	addi	fp,sp,20
81116004:	2807883a 	mov	r3,r5
81116008:	3005883a 	mov	r2,r6
8111600c:	e13ffd05 	stb	r4,-12(fp)
81116010:	e0fffe05 	stb	r3,-8(fp)
81116014:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81116018:	00800404 	movi	r2,16
8111601c:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81116020:	e0bffd03 	ldbu	r2,-12(fp)
81116024:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81116028:	e0bffe03 	ldbu	r2,-8(fp)
8111602c:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81116030:	e0bfff03 	ldbu	r2,-4(fp)
81116034:	e0bffc05 	stb	r2,-16(fp)

	/*Send a command to other entities (Data Controller) */
	error_codel = OSQPostFront(xQMaskDataCtrl, (void *)uiCmdtoSend.ulWord);
81116038:	d0a05f17 	ldw	r2,-32388(gp)
8111603c:	e0fffc17 	ldw	r3,-16(fp)
81116040:	180b883a 	mov	r5,r3
81116044:	1009883a 	mov	r4,r2
81116048:	113db400 	call	8113db40 <OSQPostFront>
8111604c:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81116050:	e0bffb03 	ldbu	r2,-20(fp)
81116054:	10000126 	beq	r2,zero,8111605c <vSendCmdQToDataCTRL_PRIO+0x70>
		vFailSendMsgFeeCTRL();
81116058:	111d0d00 	call	8111d0d0 <vFailSendMsgFeeCTRL>
	}
}
8111605c:	0001883a 	nop
81116060:	e037883a 	mov	sp,fp
81116064:	dfc00117 	ldw	ra,4(sp)
81116068:	df000017 	ldw	fp,0(sp)
8111606c:	dec00204 	addi	sp,sp,8
81116070:	f800283a 	ret

81116074 <vMebInit>:


void vMebInit(TSimucam_MEB *pxMebCLocal) {
81116074:	defffc04 	addi	sp,sp,-16
81116078:	de00012e 	bgeu	sp,et,81116080 <vMebInit+0xc>
8111607c:	003b68fa 	trap	3
81116080:	dfc00315 	stw	ra,12(sp)
81116084:	df000215 	stw	fp,8(sp)
81116088:	df000204 	addi	fp,sp,8
8111608c:	e13fff15 	stw	r4,-4(fp)
	INT8U errorCodeL;

	pxMebCLocal->ucActualDDR = 0;
81116090:	e0bfff17 	ldw	r2,-4(fp)
81116094:	10000205 	stb	zero,8(r2)
	pxMebCLocal->ucNextDDR = 1;
81116098:	e0bfff17 	ldw	r2,-4(fp)
8111609c:	00c00044 	movi	r3,1
811160a0:	10c00245 	stb	r3,9(r2)
	/* Flush all communication Queues */
	errorCodeL = OSQFlush(xMebQ);
811160a4:	d0a06917 	ldw	r2,-32348(gp)
811160a8:	1009883a 	mov	r4,r2
811160ac:	113d5080 	call	8113d508 <OSQFlush>
811160b0:	e0bffe05 	stb	r2,-8(fp)
	if ( errorCodeL != OS_NO_ERR ) {
811160b4:	e0bffe03 	ldbu	r2,-8(fp)
811160b8:	10000126 	beq	r2,zero,811160c0 <vMebInit+0x4c>
		vFailFlushMEBQueue();
811160bc:	111d2000 	call	8111d200 <vFailFlushMEBQueue>
	}
}
811160c0:	0001883a 	nop
811160c4:	e037883a 	mov	sp,fp
811160c8:	dfc00117 	ldw	ra,4(sp)
811160cc:	df000017 	ldw	fp,0(sp)
811160d0:	dec00204 	addi	sp,sp,8
811160d4:	f800283a 	ret

811160d8 <vSwapMemmory>:

/* Swap memory reference */
void vSwapMemmory(TSimucam_MEB *pxMebCLocal) {
811160d8:	defffe04 	addi	sp,sp,-8
811160dc:	de00012e 	bgeu	sp,et,811160e4 <vSwapMemmory+0xc>
811160e0:	003b68fa 	trap	3
811160e4:	df000115 	stw	fp,4(sp)
811160e8:	df000104 	addi	fp,sp,4
811160ec:	e13fff15 	stw	r4,-4(fp)

	pxMebCLocal->ucActualDDR = (pxMebCLocal->ucActualDDR + 1) % 2 ;
811160f0:	e0bfff17 	ldw	r2,-4(fp)
811160f4:	10800203 	ldbu	r2,8(r2)
811160f8:	10803fcc 	andi	r2,r2,255
811160fc:	10c00044 	addi	r3,r2,1
81116100:	00a00034 	movhi	r2,32768
81116104:	10800044 	addi	r2,r2,1
81116108:	1884703a 	and	r2,r3,r2
8111610c:	1000040e 	bge	r2,zero,81116120 <vSwapMemmory+0x48>
81116110:	10bfffc4 	addi	r2,r2,-1
81116114:	00ffff84 	movi	r3,-2
81116118:	10c4b03a 	or	r2,r2,r3
8111611c:	10800044 	addi	r2,r2,1
81116120:	1007883a 	mov	r3,r2
81116124:	e0bfff17 	ldw	r2,-4(fp)
81116128:	10c00205 	stb	r3,8(r2)
	pxMebCLocal->ucNextDDR = (pxMebCLocal->ucNextDDR + 1) % 2 ;
8111612c:	e0bfff17 	ldw	r2,-4(fp)
81116130:	10800243 	ldbu	r2,9(r2)
81116134:	10803fcc 	andi	r2,r2,255
81116138:	10c00044 	addi	r3,r2,1
8111613c:	00a00034 	movhi	r2,32768
81116140:	10800044 	addi	r2,r2,1
81116144:	1884703a 	and	r2,r3,r2
81116148:	1000040e 	bge	r2,zero,8111615c <vSwapMemmory+0x84>
8111614c:	10bfffc4 	addi	r2,r2,-1
81116150:	00ffff84 	movi	r3,-2
81116154:	10c4b03a 	or	r2,r2,r3
81116158:	10800044 	addi	r2,r2,1
8111615c:	1007883a 	mov	r3,r2
81116160:	e0bfff17 	ldw	r2,-4(fp)
81116164:	10c00245 	stb	r3,9(r2)

}
81116168:	0001883a 	nop
8111616c:	e037883a 	mov	sp,fp
81116170:	df000017 	ldw	fp,0(sp)
81116174:	dec00104 	addi	sp,sp,4
81116178:	f800283a 	ret

8111617c <vReleaseSyncMessages>:

/* After stop the Sync signal generation, maybe some FEE task could be locked waiting for this signal. So we send to everyone, and after that they will flush the queue */
void vReleaseSyncMessages(void) {
8111617c:	defffc04 	addi	sp,sp,-16
81116180:	de00012e 	bgeu	sp,et,81116188 <vReleaseSyncMessages+0xc>
81116184:	003b68fa 	trap	3
81116188:	dfc00315 	stw	ra,12(sp)
8111618c:	df000215 	stw	fp,8(sp)
81116190:	df000204 	addi	fp,sp,8
	unsigned char ucIL;
	unsigned char error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ulWord = 0;
81116194:	e03fff15 	stw	zero,-4(fp)
	uiCmdtoSend.ucByte[2] = M_SYNC;
81116198:	00bff844 	movi	r2,-31
8111619c:	e0bfff85 	stb	r2,-2(fp)
	/* MasterSync? */

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
811161a0:	e03ffe05 	stb	zero,-8(fp)
811161a4:	00001606 	br	81116200 <vReleaseSyncMessages+0x84>
		uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucIL;
811161a8:	e0bffe03 	ldbu	r2,-8(fp)
811161ac:	10800444 	addi	r2,r2,17
811161b0:	e0bfffc5 	stb	r2,-1(fp)
		error_codel = OSQPost(xWaitSyncQFee[ ucIL ], (void *)uiCmdtoSend.ulWord);
811161b4:	e0bffe03 	ldbu	r2,-8(fp)
811161b8:	1085883a 	add	r2,r2,r2
811161bc:	1087883a 	add	r3,r2,r2
811161c0:	d0a05c04 	addi	r2,gp,-32400
811161c4:	1885883a 	add	r2,r3,r2
811161c8:	10800017 	ldw	r2,0(r2)
811161cc:	e0ffff17 	ldw	r3,-4(fp)
811161d0:	180b883a 	mov	r5,r3
811161d4:	1009883a 	mov	r4,r2
811161d8:	113d9d00 	call	8113d9d0 <OSQPost>
811161dc:	e0bffe45 	stb	r2,-7(fp)
		if ( error_codel != OS_ERR_NONE ) {
811161e0:	e0bffe43 	ldbu	r2,-7(fp)
811161e4:	10000326 	beq	r2,zero,811161f4 <vReleaseSyncMessages+0x78>
			vFailSendMsgSync( ucIL );
811161e8:	e0bffe03 	ldbu	r2,-8(fp)
811161ec:	1009883a 	mov	r4,r2
811161f0:	111cfdc0 	call	8111cfdc <vFailSendMsgSync>

	uiCmdtoSend.ulWord = 0;
	uiCmdtoSend.ucByte[2] = M_SYNC;
	/* MasterSync? */

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
811161f4:	e0bffe03 	ldbu	r2,-8(fp)
811161f8:	10800044 	addi	r2,r2,1
811161fc:	e0bffe05 	stb	r2,-8(fp)
81116200:	e0bffe03 	ldbu	r2,-8(fp)
81116204:	103fe826 	beq	r2,zero,811161a8 <__reset+0xfb0f61a8>
		error_codel = OSQPost(xWaitSyncQFee[ ucIL ], (void *)uiCmdtoSend.ulWord);
		if ( error_codel != OS_ERR_NONE ) {
			vFailSendMsgSync( ucIL );
		}
	}
}
81116208:	0001883a 	nop
8111620c:	e037883a 	mov	sp,fp
81116210:	dfc00117 	ldw	ra,4(sp)
81116214:	df000017 	ldw	fp,0(sp)
81116218:	dec00204 	addi	sp,sp,8
8111621c:	f800283a 	ret

81116220 <vStackMonitor>:
    }
}

#else
#ifdef DEBUG_ON
void vStackMonitor(void *task_data) {
81116220:	defff804 	addi	sp,sp,-32
81116224:	de00012e 	bgeu	sp,et,8111622c <vStackMonitor+0xc>
81116228:	003b68fa 	trap	3
8111622c:	dfc00715 	stw	ra,28(sp)
81116230:	df000615 	stw	fp,24(sp)
81116234:	df000604 	addi	fp,sp,24
81116238:	e13fff15 	stw	r4,-4(fp)
	INT8U ucErrorCode = 0;
8111623c:	e03ffc05 	stb	zero,-16(fp)
	OS_STK_DATA data;


        debug(fp,"vStackMonitor, enter task.\n");
81116240:	d0a06217 	ldw	r2,-32376(gp)
81116244:	100f883a 	mov	r7,r2
81116248:	018006c4 	movi	r6,27
8111624c:	01400044 	movi	r5,1
81116250:	01204574 	movhi	r4,33045
81116254:	21371704 	addi	r4,r4,-9124
81116258:	11216400 	call	81121640 <fwrite>


    for (;;) {

    	fprintf(fp, "=========== STACK MONITOR =================\n" );
8111625c:	d0a06217 	ldw	r2,-32376(gp)
81116260:	100f883a 	mov	r7,r2
81116264:	01800b04 	movi	r6,44
81116268:	01400044 	movi	r5,1
8111626c:	01204574 	movhi	r4,33045
81116270:	21371e04 	addi	r4,r4,-9096
81116274:	11216400 	call	81121640 <fwrite>
    	fprintf(fp, " Task           Total               Free             In use  \n" );
81116278:	d0a06217 	ldw	r2,-32376(gp)
8111627c:	100f883a 	mov	r7,r2
81116280:	01800f84 	movi	r6,62
81116284:	01400044 	movi	r5,1
81116288:	01204574 	movhi	r4,33045
8111628c:	21372a04 	addi	r4,r4,-9048
81116290:	11216400 	call	81121640 <fwrite>

    	ucErrorCode = OSTaskStkChk( RECEIVER_TASK_PRIO , &data);
81116294:	e0bffd04 	addi	r2,fp,-12
81116298:	100b883a 	mov	r5,r2
8111629c:	01000804 	movi	r4,32
811162a0:	113fdf40 	call	8113fdf4 <OSTaskStkChk>
811162a4:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE ) {
811162a8:	e0bffc03 	ldbu	r2,-16(fp)
811162ac:	10000f1e 	bne	r2,zero,811162ec <vStackMonitor+0xcc>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811162b0:	d1206217 	ldw	r4,-32376(gp)
    				"RECEIVER_TASK",
    				data.OSFree + data.OSUsed,
811162b4:	e0fffd17 	ldw	r3,-12(fp)
811162b8:	e0bffe17 	ldw	r2,-8(fp)
    	fprintf(fp, " Task           Total               Free             In use  \n" );

    	ucErrorCode = OSTaskStkChk( RECEIVER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811162bc:	188b883a 	add	r5,r3,r2
811162c0:	e0bffd17 	ldw	r2,-12(fp)
811162c4:	e0fffe17 	ldw	r3,-8(fp)
811162c8:	d8c00115 	stw	r3,4(sp)
811162cc:	d8800015 	stw	r2,0(sp)
811162d0:	280f883a 	mov	r7,r5
811162d4:	01a04574 	movhi	r6,33045
811162d8:	31b73a04 	addi	r6,r6,-8984
811162dc:	01604574 	movhi	r5,33045
811162e0:	29773e04 	addi	r5,r5,-8968
811162e4:	1120fa40 	call	81120fa4 <fprintf>
811162e8:	00000706 	br	81116308 <vStackMonitor+0xe8>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get RECEIVER_TASK stack \n" );
811162ec:	d0a06217 	ldw	r2,-32376(gp)
811162f0:	100f883a 	mov	r7,r2
811162f4:	01800904 	movi	r6,36
811162f8:	01400044 	movi	r5,1
811162fc:	01204574 	movhi	r4,33045
81116300:	21374d04 	addi	r4,r4,-8908
81116304:	11216400 	call	81121640 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( TIMEOUT_CHECKER_PRIO , &data);
81116308:	e0bffd04 	addi	r2,fp,-12
8111630c:	100b883a 	mov	r5,r2
81116310:	01000784 	movi	r4,30
81116314:	113fdf40 	call	8113fdf4 <OSTaskStkChk>
81116318:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8111631c:	e0bffc03 	ldbu	r2,-16(fp)
81116320:	10000f1e 	bne	r2,zero,81116360 <vStackMonitor+0x140>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116324:	d1206217 	ldw	r4,-32376(gp)
    				"TIMEOUT_CHECKER",
    				data.OSFree + data.OSUsed,
81116328:	e0fffd17 	ldw	r3,-12(fp)
8111632c:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( TIMEOUT_CHECKER_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116330:	188b883a 	add	r5,r3,r2
81116334:	e0bffd17 	ldw	r2,-12(fp)
81116338:	e0fffe17 	ldw	r3,-8(fp)
8111633c:	d8c00115 	stw	r3,4(sp)
81116340:	d8800015 	stw	r2,0(sp)
81116344:	280f883a 	mov	r7,r5
81116348:	01a04574 	movhi	r6,33045
8111634c:	31b75704 	addi	r6,r6,-8868
81116350:	01604574 	movhi	r5,33045
81116354:	29773e04 	addi	r5,r5,-8968
81116358:	1120fa40 	call	81120fa4 <fprintf>
8111635c:	00000706 	br	8111637c <vStackMonitor+0x15c>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get TIMEOUT_CHECKER stack \n" );
81116360:	d0a06217 	ldw	r2,-32376(gp)
81116364:	100f883a 	mov	r7,r2
81116368:	01800984 	movi	r6,38
8111636c:	01400044 	movi	r5,1
81116370:	01204574 	movhi	r4,33045
81116374:	21375b04 	addi	r4,r4,-8852
81116378:	11216400 	call	81121640 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( PARSER_TASK_PRIO , &data);
8111637c:	e0bffd04 	addi	r2,fp,-12
81116380:	100b883a 	mov	r5,r2
81116384:	01000704 	movi	r4,28
81116388:	113fdf40 	call	8113fdf4 <OSTaskStkChk>
8111638c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81116390:	e0bffc03 	ldbu	r2,-16(fp)
81116394:	10000f1e 	bne	r2,zero,811163d4 <vStackMonitor+0x1b4>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116398:	d1206217 	ldw	r4,-32376(gp)
    				"PARSER_TASK",
    				data.OSFree + data.OSUsed,
8111639c:	e0fffd17 	ldw	r3,-12(fp)
811163a0:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( PARSER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811163a4:	188b883a 	add	r5,r3,r2
811163a8:	e0bffd17 	ldw	r2,-12(fp)
811163ac:	e0fffe17 	ldw	r3,-8(fp)
811163b0:	d8c00115 	stw	r3,4(sp)
811163b4:	d8800015 	stw	r2,0(sp)
811163b8:	280f883a 	mov	r7,r5
811163bc:	01a04574 	movhi	r6,33045
811163c0:	31b76504 	addi	r6,r6,-8812
811163c4:	01604574 	movhi	r5,33045
811163c8:	29773e04 	addi	r5,r5,-8968
811163cc:	1120fa40 	call	81120fa4 <fprintf>
811163d0:	00000706 	br	811163f0 <vStackMonitor+0x1d0>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get PARSER_TASK stack \n" );
811163d4:	d0a06217 	ldw	r2,-32376(gp)
811163d8:	100f883a 	mov	r7,r2
811163dc:	01800884 	movi	r6,34
811163e0:	01400044 	movi	r5,1
811163e4:	01204574 	movhi	r4,33045
811163e8:	21376804 	addi	r4,r4,-8800
811163ec:	11216400 	call	81121640 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( OUT_ACK_TASK_PRIO , &data);
811163f0:	e0bffd04 	addi	r2,fp,-12
811163f4:	100b883a 	mov	r5,r2
811163f8:	010006c4 	movi	r4,27
811163fc:	113fdf40 	call	8113fdf4 <OSTaskStkChk>
81116400:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81116404:	e0bffc03 	ldbu	r2,-16(fp)
81116408:	10000f1e 	bne	r2,zero,81116448 <vStackMonitor+0x228>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111640c:	d1206217 	ldw	r4,-32376(gp)
    				"OUT_ACK_TASK",
    				data.OSFree + data.OSUsed,
81116410:	e0fffd17 	ldw	r3,-12(fp)
81116414:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( OUT_ACK_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116418:	188b883a 	add	r5,r3,r2
8111641c:	e0bffd17 	ldw	r2,-12(fp)
81116420:	e0fffe17 	ldw	r3,-8(fp)
81116424:	d8c00115 	stw	r3,4(sp)
81116428:	d8800015 	stw	r2,0(sp)
8111642c:	280f883a 	mov	r7,r5
81116430:	01a04574 	movhi	r6,33045
81116434:	31b77104 	addi	r6,r6,-8764
81116438:	01604574 	movhi	r5,33045
8111643c:	29773e04 	addi	r5,r5,-8968
81116440:	1120fa40 	call	81120fa4 <fprintf>
81116444:	00000706 	br	81116464 <vStackMonitor+0x244>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get OUT_ACK_TASK stack \n" );
81116448:	d0a06217 	ldw	r2,-32376(gp)
8111644c:	100f883a 	mov	r7,r2
81116450:	018008c4 	movi	r6,35
81116454:	01400044 	movi	r5,1
81116458:	01204574 	movhi	r4,33045
8111645c:	21377504 	addi	r4,r4,-8748
81116460:	11216400 	call	81121640 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( SENDER_TASK_PRIO , &data);
81116464:	e0bffd04 	addi	r2,fp,-12
81116468:	100b883a 	mov	r5,r2
8111646c:	01000684 	movi	r4,26
81116470:	113fdf40 	call	8113fdf4 <OSTaskStkChk>
81116474:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81116478:	e0bffc03 	ldbu	r2,-16(fp)
8111647c:	10000f1e 	bne	r2,zero,811164bc <vStackMonitor+0x29c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116480:	d1206217 	ldw	r4,-32376(gp)
    				"SENDER_TASK",
    				data.OSFree + data.OSUsed,
81116484:	e0fffd17 	ldw	r3,-12(fp)
81116488:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( SENDER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111648c:	188b883a 	add	r5,r3,r2
81116490:	e0bffd17 	ldw	r2,-12(fp)
81116494:	e0fffe17 	ldw	r3,-8(fp)
81116498:	d8c00115 	stw	r3,4(sp)
8111649c:	d8800015 	stw	r2,0(sp)
811164a0:	280f883a 	mov	r7,r5
811164a4:	01a04574 	movhi	r6,33045
811164a8:	31b77e04 	addi	r6,r6,-8712
811164ac:	01604574 	movhi	r5,33045
811164b0:	29773e04 	addi	r5,r5,-8968
811164b4:	1120fa40 	call	81120fa4 <fprintf>
811164b8:	00000706 	br	811164d8 <vStackMonitor+0x2b8>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get SENDER_TASK stack \n" );
811164bc:	d0a06217 	ldw	r2,-32376(gp)
811164c0:	100f883a 	mov	r7,r2
811164c4:	01800884 	movi	r6,34
811164c8:	01400044 	movi	r5,1
811164cc:	01204574 	movhi	r4,33045
811164d0:	21378104 	addi	r4,r4,-8700
811164d4:	11216400 	call	81121640 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( IN_ACK_TASK_PRIO , &data);
811164d8:	e0bffd04 	addi	r2,fp,-12
811164dc:	100b883a 	mov	r5,r2
811164e0:	01000644 	movi	r4,25
811164e4:	113fdf40 	call	8113fdf4 <OSTaskStkChk>
811164e8:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811164ec:	e0bffc03 	ldbu	r2,-16(fp)
811164f0:	10000f1e 	bne	r2,zero,81116530 <vStackMonitor+0x310>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811164f4:	d1206217 	ldw	r4,-32376(gp)
    				"IN_ACK_TASK",
    				data.OSFree + data.OSUsed,
811164f8:	e0fffd17 	ldw	r3,-12(fp)
811164fc:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( IN_ACK_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116500:	188b883a 	add	r5,r3,r2
81116504:	e0bffd17 	ldw	r2,-12(fp)
81116508:	e0fffe17 	ldw	r3,-8(fp)
8111650c:	d8c00115 	stw	r3,4(sp)
81116510:	d8800015 	stw	r2,0(sp)
81116514:	280f883a 	mov	r7,r5
81116518:	01a04574 	movhi	r6,33045
8111651c:	31b78a04 	addi	r6,r6,-8664
81116520:	01604574 	movhi	r5,33045
81116524:	29773e04 	addi	r5,r5,-8968
81116528:	1120fa40 	call	81120fa4 <fprintf>
8111652c:	00000706 	br	8111654c <vStackMonitor+0x32c>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get IN_ACK_TASK stack \n" );
81116530:	d0a06217 	ldw	r2,-32376(gp)
81116534:	100f883a 	mov	r7,r2
81116538:	01800884 	movi	r6,34
8111653c:	01400044 	movi	r5,1
81116540:	01204574 	movhi	r4,33045
81116544:	21378d04 	addi	r4,r4,-8652
81116548:	11216400 	call	81121640 <fwrite>
    	}

 
    	ucErrorCode = OSTaskStkChk( INITIALIZATION_TASK_PRIO , &data);
8111654c:	e0bffd04 	addi	r2,fp,-12
81116550:	100b883a 	mov	r5,r2
81116554:	01000044 	movi	r4,1
81116558:	113fdf40 	call	8113fdf4 <OSTaskStkChk>
8111655c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81116560:	e0bffc03 	ldbu	r2,-16(fp)
81116564:	10000f1e 	bne	r2,zero,811165a4 <vStackMonitor+0x384>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116568:	d1206217 	ldw	r4,-32376(gp)
    				"INITI_TASK",
    				data.OSFree + data.OSUsed,
8111656c:	e0fffd17 	ldw	r3,-12(fp)
81116570:	e0bffe17 	ldw	r2,-8(fp)

 
    	ucErrorCode = OSTaskStkChk( INITIALIZATION_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116574:	188b883a 	add	r5,r3,r2
81116578:	e0bffd17 	ldw	r2,-12(fp)
8111657c:	e0fffe17 	ldw	r3,-8(fp)
81116580:	d8c00115 	stw	r3,4(sp)
81116584:	d8800015 	stw	r2,0(sp)
81116588:	280f883a 	mov	r7,r5
8111658c:	01a04574 	movhi	r6,33045
81116590:	31b79604 	addi	r6,r6,-8616
81116594:	01604574 	movhi	r5,33045
81116598:	29773e04 	addi	r5,r5,-8968
8111659c:	1120fa40 	call	81120fa4 <fprintf>
811165a0:	00000706 	br	811165c0 <vStackMonitor+0x3a0>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get INIT_TASK stack \n" );
811165a4:	d0a06217 	ldw	r2,-32376(gp)
811165a8:	100f883a 	mov	r7,r2
811165ac:	01800804 	movi	r6,32
811165b0:	01400044 	movi	r5,1
811165b4:	01204574 	movhi	r4,33045
811165b8:	21379904 	addi	r4,r4,-8604
811165bc:	11216400 	call	81121640 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO , &data);
811165c0:	e0bffd04 	addi	r2,fp,-12
811165c4:	100b883a 	mov	r5,r2
811165c8:	010002c4 	movi	r4,11
811165cc:	113fdf40 	call	8113fdf4 <OSTaskStkChk>
811165d0:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811165d4:	e0bffc03 	ldbu	r2,-16(fp)
811165d8:	10000f1e 	bne	r2,zero,81116618 <vStackMonitor+0x3f8>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811165dc:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-0",
    				data.OSFree + data.OSUsed,
811165e0:	e0fffd17 	ldw	r3,-12(fp)
811165e4:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811165e8:	188b883a 	add	r5,r3,r2
811165ec:	e0bffd17 	ldw	r2,-12(fp)
811165f0:	e0fffe17 	ldw	r3,-8(fp)
811165f4:	d8c00115 	stw	r3,4(sp)
811165f8:	d8800015 	stw	r2,0(sp)
811165fc:	280f883a 	mov	r7,r5
81116600:	01a04574 	movhi	r6,33045
81116604:	31b7a204 	addi	r6,r6,-8568
81116608:	01604574 	movhi	r5,33045
8111660c:	29773e04 	addi	r5,r5,-8968
81116610:	1120fa40 	call	81120fa4 <fprintf>
81116614:	00000706 	br	81116634 <vStackMonitor+0x414>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 0 stack \n" );
81116618:	d0a06217 	ldw	r2,-32376(gp)
8111661c:	100f883a 	mov	r7,r2
81116620:	018008c4 	movi	r6,35
81116624:	01400044 	movi	r5,1
81116628:	01204574 	movhi	r4,33045
8111662c:	2137a504 	addi	r4,r4,-8556
81116630:	11216400 	call	81121640 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+1 , &data);
81116634:	e0bffd04 	addi	r2,fp,-12
81116638:	100b883a 	mov	r5,r2
8111663c:	01000304 	movi	r4,12
81116640:	113fdf40 	call	8113fdf4 <OSTaskStkChk>
81116644:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81116648:	e0bffc03 	ldbu	r2,-16(fp)
8111664c:	10000f1e 	bne	r2,zero,8111668c <vStackMonitor+0x46c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116650:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-1",
    				data.OSFree + data.OSUsed,
81116654:	e0fffd17 	ldw	r3,-12(fp)
81116658:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+1 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111665c:	188b883a 	add	r5,r3,r2
81116660:	e0bffd17 	ldw	r2,-12(fp)
81116664:	e0fffe17 	ldw	r3,-8(fp)
81116668:	d8c00115 	stw	r3,4(sp)
8111666c:	d8800015 	stw	r2,0(sp)
81116670:	280f883a 	mov	r7,r5
81116674:	01a04574 	movhi	r6,33045
81116678:	31b7ae04 	addi	r6,r6,-8520
8111667c:	01604574 	movhi	r5,33045
81116680:	29773e04 	addi	r5,r5,-8968
81116684:	1120fa40 	call	81120fa4 <fprintf>
81116688:	00000706 	br	811166a8 <vStackMonitor+0x488>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 1 stack \n" );
8111668c:	d0a06217 	ldw	r2,-32376(gp)
81116690:	100f883a 	mov	r7,r2
81116694:	018008c4 	movi	r6,35
81116698:	01400044 	movi	r5,1
8111669c:	01204574 	movhi	r4,33045
811166a0:	2137b104 	addi	r4,r4,-8508
811166a4:	11216400 	call	81121640 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+2 , &data);
811166a8:	e0bffd04 	addi	r2,fp,-12
811166ac:	100b883a 	mov	r5,r2
811166b0:	01000344 	movi	r4,13
811166b4:	113fdf40 	call	8113fdf4 <OSTaskStkChk>
811166b8:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811166bc:	e0bffc03 	ldbu	r2,-16(fp)
811166c0:	10000f1e 	bne	r2,zero,81116700 <vStackMonitor+0x4e0>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811166c4:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-2",
    				data.OSFree + data.OSUsed,
811166c8:	e0fffd17 	ldw	r3,-12(fp)
811166cc:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+2 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811166d0:	188b883a 	add	r5,r3,r2
811166d4:	e0bffd17 	ldw	r2,-12(fp)
811166d8:	e0fffe17 	ldw	r3,-8(fp)
811166dc:	d8c00115 	stw	r3,4(sp)
811166e0:	d8800015 	stw	r2,0(sp)
811166e4:	280f883a 	mov	r7,r5
811166e8:	01a04574 	movhi	r6,33045
811166ec:	31b7ba04 	addi	r6,r6,-8472
811166f0:	01604574 	movhi	r5,33045
811166f4:	29773e04 	addi	r5,r5,-8968
811166f8:	1120fa40 	call	81120fa4 <fprintf>
811166fc:	00000706 	br	8111671c <vStackMonitor+0x4fc>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 2 stack \n" );
81116700:	d0a06217 	ldw	r2,-32376(gp)
81116704:	100f883a 	mov	r7,r2
81116708:	018008c4 	movi	r6,35
8111670c:	01400044 	movi	r5,1
81116710:	01204574 	movhi	r4,33045
81116714:	2137bd04 	addi	r4,r4,-8460
81116718:	11216400 	call	81121640 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+3 , &data);
8111671c:	e0bffd04 	addi	r2,fp,-12
81116720:	100b883a 	mov	r5,r2
81116724:	01000384 	movi	r4,14
81116728:	113fdf40 	call	8113fdf4 <OSTaskStkChk>
8111672c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81116730:	e0bffc03 	ldbu	r2,-16(fp)
81116734:	10000f1e 	bne	r2,zero,81116774 <vStackMonitor+0x554>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116738:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-3",
    				data.OSFree + data.OSUsed,
8111673c:	e0fffd17 	ldw	r3,-12(fp)
81116740:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+3 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116744:	188b883a 	add	r5,r3,r2
81116748:	e0bffd17 	ldw	r2,-12(fp)
8111674c:	e0fffe17 	ldw	r3,-8(fp)
81116750:	d8c00115 	stw	r3,4(sp)
81116754:	d8800015 	stw	r2,0(sp)
81116758:	280f883a 	mov	r7,r5
8111675c:	01a04574 	movhi	r6,33045
81116760:	31b7c604 	addi	r6,r6,-8424
81116764:	01604574 	movhi	r5,33045
81116768:	29773e04 	addi	r5,r5,-8968
8111676c:	1120fa40 	call	81120fa4 <fprintf>
81116770:	00000706 	br	81116790 <vStackMonitor+0x570>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 3 stack \n" );
81116774:	d0a06217 	ldw	r2,-32376(gp)
81116778:	100f883a 	mov	r7,r2
8111677c:	018008c4 	movi	r6,35
81116780:	01400044 	movi	r5,1
81116784:	01204574 	movhi	r4,33045
81116788:	2137c904 	addi	r4,r4,-8412
8111678c:	11216400 	call	81121640 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+4 , &data);
81116790:	e0bffd04 	addi	r2,fp,-12
81116794:	100b883a 	mov	r5,r2
81116798:	010003c4 	movi	r4,15
8111679c:	113fdf40 	call	8113fdf4 <OSTaskStkChk>
811167a0:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811167a4:	e0bffc03 	ldbu	r2,-16(fp)
811167a8:	10000f1e 	bne	r2,zero,811167e8 <vStackMonitor+0x5c8>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811167ac:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-4",
    				data.OSFree + data.OSUsed,
811167b0:	e0fffd17 	ldw	r3,-12(fp)
811167b4:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+4 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811167b8:	188b883a 	add	r5,r3,r2
811167bc:	e0bffd17 	ldw	r2,-12(fp)
811167c0:	e0fffe17 	ldw	r3,-8(fp)
811167c4:	d8c00115 	stw	r3,4(sp)
811167c8:	d8800015 	stw	r2,0(sp)
811167cc:	280f883a 	mov	r7,r5
811167d0:	01a04574 	movhi	r6,33045
811167d4:	31b7d204 	addi	r6,r6,-8376
811167d8:	01604574 	movhi	r5,33045
811167dc:	29773e04 	addi	r5,r5,-8968
811167e0:	1120fa40 	call	81120fa4 <fprintf>
811167e4:	00000706 	br	81116804 <vStackMonitor+0x5e4>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 4 stack \n" );
811167e8:	d0a06217 	ldw	r2,-32376(gp)
811167ec:	100f883a 	mov	r7,r2
811167f0:	018008c4 	movi	r6,35
811167f4:	01400044 	movi	r5,1
811167f8:	01204574 	movhi	r4,33045
811167fc:	2137d504 	addi	r4,r4,-8364
81116800:	11216400 	call	81121640 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+5 , &data);
81116804:	e0bffd04 	addi	r2,fp,-12
81116808:	100b883a 	mov	r5,r2
8111680c:	01000404 	movi	r4,16
81116810:	113fdf40 	call	8113fdf4 <OSTaskStkChk>
81116814:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81116818:	e0bffc03 	ldbu	r2,-16(fp)
8111681c:	10000f1e 	bne	r2,zero,8111685c <vStackMonitor+0x63c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116820:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-5",
    				data.OSFree + data.OSUsed,
81116824:	e0fffd17 	ldw	r3,-12(fp)
81116828:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+5 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111682c:	188b883a 	add	r5,r3,r2
81116830:	e0bffd17 	ldw	r2,-12(fp)
81116834:	e0fffe17 	ldw	r3,-8(fp)
81116838:	d8c00115 	stw	r3,4(sp)
8111683c:	d8800015 	stw	r2,0(sp)
81116840:	280f883a 	mov	r7,r5
81116844:	01a04574 	movhi	r6,33045
81116848:	31b7de04 	addi	r6,r6,-8328
8111684c:	01604574 	movhi	r5,33045
81116850:	29773e04 	addi	r5,r5,-8968
81116854:	1120fa40 	call	81120fa4 <fprintf>
81116858:	00000706 	br	81116878 <vStackMonitor+0x658>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 5 stack \n" );
8111685c:	d0a06217 	ldw	r2,-32376(gp)
81116860:	100f883a 	mov	r7,r2
81116864:	018008c4 	movi	r6,35
81116868:	01400044 	movi	r5,1
8111686c:	01204574 	movhi	r4,33045
81116870:	2137e104 	addi	r4,r4,-8316
81116874:	11216400 	call	81121640 <fwrite>
    	}

    	ucErrorCode = OSTaskStkChk( DATA_COTROL_TASK_PRIO , &data);
81116878:	e0bffd04 	addi	r2,fp,-12
8111687c:	100b883a 	mov	r5,r2
81116880:	01000284 	movi	r4,10
81116884:	113fdf40 	call	8113fdf4 <OSTaskStkChk>
81116888:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8111688c:	e0bffc03 	ldbu	r2,-16(fp)
81116890:	10000f1e 	bne	r2,zero,811168d0 <vStackMonitor+0x6b0>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116894:	d1206217 	ldw	r4,-32376(gp)
    				"DATA_COTROL",
    				data.OSFree + data.OSUsed,
81116898:	e0fffd17 	ldw	r3,-12(fp)
8111689c:	e0bffe17 	ldw	r2,-8(fp)
    	}

    	ucErrorCode = OSTaskStkChk( DATA_COTROL_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811168a0:	188b883a 	add	r5,r3,r2
811168a4:	e0bffd17 	ldw	r2,-12(fp)
811168a8:	e0fffe17 	ldw	r3,-8(fp)
811168ac:	d8c00115 	stw	r3,4(sp)
811168b0:	d8800015 	stw	r2,0(sp)
811168b4:	280f883a 	mov	r7,r5
811168b8:	01a04574 	movhi	r6,33045
811168bc:	31b7ea04 	addi	r6,r6,-8280
811168c0:	01604574 	movhi	r5,33045
811168c4:	29773e04 	addi	r5,r5,-8968
811168c8:	1120fa40 	call	81120fa4 <fprintf>
811168cc:	00000706 	br	811168ec <vStackMonitor+0x6cc>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get DATA_COTROL stack \n" );
811168d0:	d0a06217 	ldw	r2,-32376(gp)
811168d4:	100f883a 	mov	r7,r2
811168d8:	01800884 	movi	r6,34
811168dc:	01400044 	movi	r5,1
811168e0:	01204574 	movhi	r4,33045
811168e4:	2137ed04 	addi	r4,r4,-8268
811168e8:	11216400 	call	81121640 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( FEE_COTROL_TASK_PRIO , &data);
811168ec:	e0bffd04 	addi	r2,fp,-12
811168f0:	100b883a 	mov	r5,r2
811168f4:	01000244 	movi	r4,9
811168f8:	113fdf40 	call	8113fdf4 <OSTaskStkChk>
811168fc:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81116900:	e0bffc03 	ldbu	r2,-16(fp)
81116904:	10000f1e 	bne	r2,zero,81116944 <vStackMonitor+0x724>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116908:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_COTROL",
    				data.OSFree + data.OSUsed,
8111690c:	e0fffd17 	ldw	r3,-12(fp)
81116910:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( FEE_COTROL_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116914:	188b883a 	add	r5,r3,r2
81116918:	e0bffd17 	ldw	r2,-12(fp)
8111691c:	e0fffe17 	ldw	r3,-8(fp)
81116920:	d8c00115 	stw	r3,4(sp)
81116924:	d8800015 	stw	r2,0(sp)
81116928:	280f883a 	mov	r7,r5
8111692c:	01a04574 	movhi	r6,33045
81116930:	31b7f604 	addi	r6,r6,-8232
81116934:	01604574 	movhi	r5,33045
81116938:	29773e04 	addi	r5,r5,-8968
8111693c:	1120fa40 	call	81120fa4 <fprintf>
81116940:	00000706 	br	81116960 <vStackMonitor+0x740>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_COTROL stack \n" );
81116944:	d0a06217 	ldw	r2,-32376(gp)
81116948:	100f883a 	mov	r7,r2
8111694c:	01800844 	movi	r6,33
81116950:	01400044 	movi	r5,1
81116954:	01204574 	movhi	r4,33045
81116958:	2137f904 	addi	r4,r4,-8220
8111695c:	11216400 	call	81121640 <fwrite>
    	}

    	ucErrorCode = OSTaskStkChk( MEB_TASK_PRIO , &data);
81116960:	e0bffd04 	addi	r2,fp,-12
81116964:	100b883a 	mov	r5,r2
81116968:	01000204 	movi	r4,8
8111696c:	113fdf40 	call	8113fdf4 <OSTaskStkChk>
81116970:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81116974:	e0bffc03 	ldbu	r2,-16(fp)
81116978:	10000f1e 	bne	r2,zero,811169b8 <vStackMonitor+0x798>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111697c:	d1206217 	ldw	r4,-32376(gp)
    				"MEB_TASK",
    				data.OSFree + data.OSUsed,
81116980:	e0fffd17 	ldw	r3,-12(fp)
81116984:	e0bffe17 	ldw	r2,-8(fp)
    	}

    	ucErrorCode = OSTaskStkChk( MEB_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116988:	188b883a 	add	r5,r3,r2
8111698c:	e0bffd17 	ldw	r2,-12(fp)
81116990:	e0fffe17 	ldw	r3,-8(fp)
81116994:	d8c00115 	stw	r3,4(sp)
81116998:	d8800015 	stw	r2,0(sp)
8111699c:	280f883a 	mov	r7,r5
811169a0:	01a04574 	movhi	r6,33045
811169a4:	31b80204 	addi	r6,r6,-8184
811169a8:	01604574 	movhi	r5,33045
811169ac:	29773e04 	addi	r5,r5,-8968
811169b0:	1120fa40 	call	81120fa4 <fprintf>
811169b4:	00000706 	br	811169d4 <vStackMonitor+0x7b4>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get MEB_TASK stack \n" );
811169b8:	d0a06217 	ldw	r2,-32376(gp)
811169bc:	100f883a 	mov	r7,r2
811169c0:	018007c4 	movi	r6,31
811169c4:	01400044 	movi	r5,1
811169c8:	01204574 	movhi	r4,33045
811169cc:	21380504 	addi	r4,r4,-8172
811169d0:	11216400 	call	81121640 <fwrite>
    	}		


    	fprintf(fp, "\n" );
811169d4:	d0a06217 	ldw	r2,-32376(gp)
811169d8:	100b883a 	mov	r5,r2
811169dc:	01000284 	movi	r4,10
811169e0:	112101c0 	call	8112101c <fputc>

    	OSTimeDlyHMSM(0, 0, 10, 0);
811169e4:	000f883a 	mov	r7,zero
811169e8:	01800284 	movi	r6,10
811169ec:	000b883a 	mov	r5,zero
811169f0:	0009883a 	mov	r4,zero
811169f4:	11404580 	call	81140458 <OSTimeDlyHMSM>
    }
811169f8:	003e1806 	br	8111625c <__reset+0xfb0f625c>

811169fc <vTimeoutCheckerTaskv2>:

#include "timeout_checker_ack_task.h"



void vTimeoutCheckerTaskv2(void *task_data) {
811169fc:	defffc04 	addi	sp,sp,-16
81116a00:	de00012e 	bgeu	sp,et,81116a08 <vTimeoutCheckerTaskv2+0xc>
81116a04:	003b68fa 	trap	3
81116a08:	dfc00315 	stw	ra,12(sp)
81116a0c:	df000215 	stw	fp,8(sp)
81116a10:	df000204 	addi	fp,sp,8
81116a14:	e13fff15 	stw	r4,-4(fp)
	INT8U ucErrorCode = 0;
81116a18:	e03ffe05 	stb	zero,-8(fp)

    #ifdef DEBUG_ON
        debug(fp,"vTimeoutCheckerTask, enter task.\n");
81116a1c:	d0a06217 	ldw	r2,-32376(gp)
81116a20:	100f883a 	mov	r7,r2
81116a24:	01800844 	movi	r6,33
81116a28:	01400044 	movi	r5,1
81116a2c:	01204574 	movhi	r4,33045
81116a30:	21380d04 	addi	r4,r4,-8140
81116a34:	11216400 	call	81121640 <fwrite>
    #endif   

    for (;;) {
        OSSemPend(xSemTimeoutChecker, 0, &ucErrorCode);
81116a38:	d0a06717 	ldw	r2,-32356(gp)
81116a3c:	e1bffe04 	addi	r6,fp,-8
81116a40:	000b883a 	mov	r5,zero
81116a44:	1009883a 	mov	r4,r2
81116a48:	113e4c00 	call	8113e4c0 <OSSemPend>
        if ( ucErrorCode == OS_NO_ERR ) {
81116a4c:	e0bffe03 	ldbu	r2,-8(fp)
81116a50:	10803fcc 	andi	r2,r2,255
81116a54:	1000021e 	bne	r2,zero,81116a60 <vTimeoutCheckerTaskv2+0x64>
            /* Just check the restransmission buffer */
            vCheck();
81116a58:	1116a680 	call	81116a68 <vCheck>
81116a5c:	003ff606 	br	81116a38 <__reset+0xfb0f6a38>
        } else {
            /* Should not get here, is a blocking semaphore for sync.*/
            vFailGetBlockingSemTimeoutTask();
81116a60:	111c19c0 	call	8111c19c <vFailGetBlockingSemTimeoutTask>
        }
    }
81116a64:	003ff406 	br	81116a38 <__reset+0xfb0f6a38>

81116a68 <vCheck>:
}


void vCheck( void ) {
81116a68:	defffd04 	addi	sp,sp,-12
81116a6c:	de00012e 	bgeu	sp,et,81116a74 <vCheck+0xc>
81116a70:	003b68fa 	trap	3
81116a74:	dfc00215 	stw	ra,8(sp)
81116a78:	df000115 	stw	fp,4(sp)
81116a7c:	df000104 	addi	fp,sp,4
	INT8U ucErrorCode = 0;
81116a80:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucHashVerification = 0;
81116a84:	e03fff05 	stb	zero,-4(fp)

    ucHashVerification = 0;
81116a88:	e03fff05 	stb	zero,-4(fp)
    ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);
81116a8c:	d0a06883 	ldbu	r2,-32350(gp)
81116a90:	10803fcc 	andi	r2,r2,255
81116a94:	10800218 	cmpnei	r2,r2,8
81116a98:	1000021e 	bne	r2,zero,81116aa4 <vCheck+0x3c>
81116a9c:	00c00104 	movi	r3,4
81116aa0:	00000106 	br	81116aa8 <vCheck+0x40>
81116aa4:	0007883a 	mov	r3,zero
81116aa8:	d0a07503 	ldbu	r2,-32300(gp)
81116aac:	10803fcc 	andi	r2,r2,255
81116ab0:	10800218 	cmpnei	r2,r2,8
81116ab4:	1000021e 	bne	r2,zero,81116ac0 <vCheck+0x58>
81116ab8:	00800084 	movi	r2,2
81116abc:	00000106 	br	81116ac4 <vCheck+0x5c>
81116ac0:	0005883a 	mov	r2,zero
81116ac4:	1884b03a 	or	r2,r3,r2
81116ac8:	1007883a 	mov	r3,r2
81116acc:	d0a07543 	ldbu	r2,-32299(gp)
81116ad0:	10803fcc 	andi	r2,r2,255
81116ad4:	108001a0 	cmpeqi	r2,r2,6
81116ad8:	1884b03a 	or	r2,r3,r2
81116adc:	1007883a 	mov	r3,r2
81116ae0:	e0bfff03 	ldbu	r2,-4(fp)
81116ae4:	1884b03a 	or	r2,r3,r2
81116ae8:	e0bfff05 	stb	r2,-4(fp)

    /* Nothing in the (re)transmission buffer */
    if ( ucHashVerification == 0b00000111 )
81116aec:	e0bfff03 	ldbu	r2,-4(fp)
81116af0:	108001d8 	cmpnei	r2,r2,7
81116af4:	10003726 	beq	r2,zero,81116bd4 <vCheck+0x16c>
        return;

    /* Try to get the Mutex of the UART */
	OSMutexPend(xTxUARTMutex, 0, &ucErrorCode); /* Blocking */
81116af8:	d0a07417 	ldw	r2,-32304(gp)
81116afc:	e0ffff44 	addi	r3,fp,-3
81116b00:	180d883a 	mov	r6,r3
81116b04:	000b883a 	mov	r5,zero
81116b08:	1009883a 	mov	r4,r2
81116b0c:	113c4b40 	call	8113c4b4 <OSMutexPend>
    if ( ucErrorCode != OS_NO_ERR ) {
81116b10:	e0bfff43 	ldbu	r2,-3(fp)
81116b14:	10803fcc 	andi	r2,r2,255
81116b18:	10000826 	beq	r2,zero,81116b3c <vCheck+0xd4>
        /* Should never get here, is a blocking operation */
		#ifdef DEBUG_ON
			debug(fp,"Should never get here. Trying to get xTxUARTMutex. (vCheck)\n");
81116b1c:	d0a06217 	ldw	r2,-32376(gp)
81116b20:	100f883a 	mov	r7,r2
81116b24:	01800f04 	movi	r6,60
81116b28:	01400044 	movi	r5,1
81116b2c:	01204574 	movhi	r4,33045
81116b30:	21381604 	addi	r4,r4,-8104
81116b34:	11216400 	call	81121640 <fwrite>
		#endif
        return;
81116b38:	00002706 	br	81116bd8 <vCheck+0x170>

    /* ---> At this point we have the Mutex of TX UART, let's try to get the mutex of all retransmission buffer. */


    /* There are any spot used in the xBuffer128? */
    if ( 0b00000001 != (0b00000001 & ucHashVerification ) )
81116b3c:	e0bfff03 	ldbu	r2,-4(fp)
81116b40:	1080004c 	andi	r2,r2,1
81116b44:	10803fcc 	andi	r2,r2,255
81116b48:	1000021e 	bne	r2,zero,81116b54 <vCheck+0xec>
        vCheckRetransmission128();
81116b4c:	1116bec0 	call	81116bec <vCheckRetransmission128>
81116b50:	00000506 	br	81116b68 <vCheck+0x100>
    else
    	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128)); /* For consistency with SemCount128 */
81116b54:	01800604 	movi	r6,24
81116b58:	000b883a 	mov	r5,zero
81116b5c:	012045b4 	movhi	r4,33046
81116b60:	2139e704 	addi	r4,r4,-6244
81116b64:	11221a40 	call	811221a4 <memset>


        /* There are any spot used in the xBuffer64? */
    if ( 0b00000010 != (0b00000010 & ucHashVerification ) )
81116b68:	e0bfff03 	ldbu	r2,-4(fp)
81116b6c:	1080008c 	andi	r2,r2,2
81116b70:	10803fcc 	andi	r2,r2,255
81116b74:	1000021e 	bne	r2,zero,81116b80 <vCheck+0x118>
        vCheckRetransmission64();
81116b78:	1116e700 	call	81116e70 <vCheckRetransmission64>
81116b7c:	00000506 	br	81116b94 <vCheck+0x12c>
    else
        memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64)); /* For consistency with SemCount64 */
81116b80:	01800804 	movi	r6,32
81116b84:	000b883a 	mov	r5,zero
81116b88:	012045b4 	movhi	r4,33046
81116b8c:	2139ed04 	addi	r4,r4,-6220
81116b90:	11221a40 	call	811221a4 <memset>

    /* There are any spot used in the xBuffer32? */
    if ( 0b00000100 != (0b00000100 & ucHashVerification ) )
81116b94:	e0bfff03 	ldbu	r2,-4(fp)
81116b98:	1080010c 	andi	r2,r2,4
81116b9c:	10803fcc 	andi	r2,r2,255
81116ba0:	1000021e 	bne	r2,zero,81116bac <vCheck+0x144>
        vCheckRetransmission32();
81116ba4:	11170fc0 	call	811170fc <vCheckRetransmission32>
81116ba8:	00000506 	br	81116bc0 <vCheck+0x158>
    else
    	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32)); /* For consistency with SemCount32 */
81116bac:	01800804 	movi	r6,32
81116bb0:	000b883a 	mov	r5,zero
81116bb4:	012045b4 	movhi	r4,33046
81116bb8:	2139f504 	addi	r4,r4,-6188
81116bbc:	11221a40 	call	811221a4 <memset>


    OSMutexPost(xTxUARTMutex);
81116bc0:	d0a07417 	ldw	r2,-32304(gp)
81116bc4:	1009883a 	mov	r4,r2
81116bc8:	113ca580 	call	8113ca58 <OSMutexPost>

    return;
81116bcc:	0001883a 	nop
81116bd0:	00000106 	br	81116bd8 <vCheck+0x170>
    ucHashVerification = 0;
    ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);

    /* Nothing in the (re)transmission buffer */
    if ( ucHashVerification == 0b00000111 )
        return;
81116bd4:	0001883a 	nop


    OSMutexPost(xTxUARTMutex);

    return;
}
81116bd8:	e037883a 	mov	sp,fp
81116bdc:	dfc00117 	ldw	ra,4(sp)
81116be0:	df000017 	ldw	fp,0(sp)
81116be4:	dec00204 	addi	sp,sp,8
81116be8:	f800283a 	ret

81116bec <vCheckRetransmission128>:

inline void vCheckRetransmission128( void ) {
81116bec:	defffd04 	addi	sp,sp,-12
81116bf0:	de00012e 	bgeu	sp,et,81116bf8 <vCheckRetransmission128+0xc>
81116bf4:	003b68fa 	trap	3
81116bf8:	dfc00215 	stw	ra,8(sp)
81116bfc:	df000115 	stw	fp,4(sp)
81116c00:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
81116c04:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucIL = 0;
81116c08:	e03fff05 	stb	zero,-4(fp)

    OSMutexAccept(xMutexBuffer128, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
81116c0c:	d0a06e17 	ldw	r2,-32328(gp)
81116c10:	e0ffff44 	addi	r3,fp,-3
81116c14:	180b883a 	mov	r5,r3
81116c18:	1009883a 	mov	r4,r2
81116c1c:	113be340 	call	8113be34 <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
81116c20:	e0bfff43 	ldbu	r2,-3(fp)
81116c24:	10803fcc 	andi	r2,r2,255
81116c28:	10008b1e 	bne	r2,zero,81116e58 <vCheckRetransmission128+0x26c>
    

    /* ---> At this point we have access to the xBuffer128*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_128; ucIL++) {
81116c2c:	e03fff05 	stb	zero,-4(fp)
81116c30:	00008106 	br	81116e38 <vCheckRetransmission128+0x24c>
        /* Check if in use */
        if ( xInUseRetrans.b128[ucIL] == TRUE ) {
81116c34:	e0ffff03 	ldbu	r3,-4(fp)
81116c38:	00a045b4 	movhi	r2,33046
81116c3c:	10b9e704 	addi	r2,r2,-6244
81116c40:	18c7883a 	add	r3,r3,r3
81116c44:	18c7883a 	add	r3,r3,r3
81116c48:	10c5883a 	add	r2,r2,r3
81116c4c:	10800017 	ldw	r2,0(r2)
81116c50:	10800058 	cmpnei	r2,r2,1
81116c54:	1000751e 	bne	r2,zero,81116e2c <vCheckRetransmission128+0x240>

            if ( xBuffer128[ucIL].bSent == TRUE )
81116c58:	e0ffff03 	ldbu	r3,-4(fp)
81116c5c:	00a045b4 	movhi	r2,33046
81116c60:	10ba0504 	addi	r2,r2,-6124
81116c64:	18c02324 	muli	r3,r3,140
81116c68:	10c5883a 	add	r2,r2,r3
81116c6c:	10802004 	addi	r2,r2,128
81116c70:	10800017 	ldw	r2,0(r2)
81116c74:	10800058 	cmpnei	r2,r2,1
81116c78:	1000211e 	bne	r2,zero,81116d00 <vCheckRetransmission128+0x114>
                if ( ++xBuffer128[ucIL].usiTimeOut > TIMEOUT_COUNT )
81116c7c:	e0ffff03 	ldbu	r3,-4(fp)
81116c80:	00a045b4 	movhi	r2,33046
81116c84:	10ba0504 	addi	r2,r2,-6124
81116c88:	19002324 	muli	r4,r3,140
81116c8c:	1105883a 	add	r2,r2,r4
81116c90:	10802184 	addi	r2,r2,134
81116c94:	1080000b 	ldhu	r2,0(r2)
81116c98:	10800044 	addi	r2,r2,1
81116c9c:	100b883a 	mov	r5,r2
81116ca0:	00a045b4 	movhi	r2,33046
81116ca4:	10ba0504 	addi	r2,r2,-6124
81116ca8:	19002324 	muli	r4,r3,140
81116cac:	1105883a 	add	r2,r2,r4
81116cb0:	10802184 	addi	r2,r2,134
81116cb4:	1140000d 	sth	r5,0(r2)
81116cb8:	00a045b4 	movhi	r2,33046
81116cbc:	10ba0504 	addi	r2,r2,-6124
81116cc0:	18c02324 	muli	r3,r3,140
81116cc4:	10c5883a 	add	r2,r2,r3
81116cc8:	10802184 	addi	r2,r2,134
81116ccc:	1080000b 	ldhu	r2,0(r2)
81116cd0:	10bfffcc 	andi	r2,r2,65535
81116cd4:	10a0001c 	xori	r2,r2,32768
81116cd8:	10a00004 	addi	r2,r2,-32768
81116cdc:	10800090 	cmplti	r2,r2,2
81116ce0:	1000071e 	bne	r2,zero,81116d00 <vCheckRetransmission128+0x114>
                    xBuffer128[ucIL].bSent = FALSE;
81116ce4:	e0ffff03 	ldbu	r3,-4(fp)
81116ce8:	00a045b4 	movhi	r2,33046
81116cec:	10ba0504 	addi	r2,r2,-6124
81116cf0:	18c02324 	muli	r3,r3,140
81116cf4:	10c5883a 	add	r2,r2,r3
81116cf8:	10802004 	addi	r2,r2,128
81116cfc:	10000015 	stw	zero,0(r2)

            if ( xBuffer128[ucIL].bSent == FALSE ) {
81116d00:	e0ffff03 	ldbu	r3,-4(fp)
81116d04:	00a045b4 	movhi	r2,33046
81116d08:	10ba0504 	addi	r2,r2,-6124
81116d0c:	18c02324 	muli	r3,r3,140
81116d10:	10c5883a 	add	r2,r2,r3
81116d14:	10802004 	addi	r2,r2,128
81116d18:	10800017 	ldw	r2,0(r2)
81116d1c:	1000431e 	bne	r2,zero,81116e2c <vCheckRetransmission128+0x240>
                puts(xBuffer128[ucIL].buffer);
81116d20:	e0bfff03 	ldbu	r2,-4(fp)
81116d24:	10c02324 	muli	r3,r2,140
81116d28:	00a045b4 	movhi	r2,33046
81116d2c:	10ba0504 	addi	r2,r2,-6124
81116d30:	1885883a 	add	r2,r3,r2
81116d34:	1009883a 	mov	r4,r2
81116d38:	11225f00 	call	811225f0 <puts>
                xBuffer128[ucIL].bSent = TRUE;
81116d3c:	e0ffff03 	ldbu	r3,-4(fp)
81116d40:	00a045b4 	movhi	r2,33046
81116d44:	10ba0504 	addi	r2,r2,-6124
81116d48:	18c02324 	muli	r3,r3,140
81116d4c:	10c5883a 	add	r2,r2,r3
81116d50:	10802004 	addi	r2,r2,128
81116d54:	00c00044 	movi	r3,1
81116d58:	10c00015 	stw	r3,0(r2)
                xBuffer128[ucIL].usiTimeOut = 0;
81116d5c:	e0ffff03 	ldbu	r3,-4(fp)
81116d60:	00a045b4 	movhi	r2,33046
81116d64:	10ba0504 	addi	r2,r2,-6124
81116d68:	18c02324 	muli	r3,r3,140
81116d6c:	10c5883a 	add	r2,r2,r3
81116d70:	10802184 	addi	r2,r2,134
81116d74:	1000000d 	sth	zero,0(r2)

                /* Check if already tried all the times */
                if ( ++xBuffer128[ucIL].ucNofRetries > N_RETRIES_COMM ) {
81116d78:	e0ffff03 	ldbu	r3,-4(fp)
81116d7c:	00a045b4 	movhi	r2,33046
81116d80:	10ba0504 	addi	r2,r2,-6124
81116d84:	19002324 	muli	r4,r3,140
81116d88:	1105883a 	add	r2,r2,r4
81116d8c:	10802204 	addi	r2,r2,136
81116d90:	10800003 	ldbu	r2,0(r2)
81116d94:	10800044 	addi	r2,r2,1
81116d98:	100b883a 	mov	r5,r2
81116d9c:	00a045b4 	movhi	r2,33046
81116da0:	10ba0504 	addi	r2,r2,-6124
81116da4:	19002324 	muli	r4,r3,140
81116da8:	1105883a 	add	r2,r2,r4
81116dac:	10802204 	addi	r2,r2,136
81116db0:	11400005 	stb	r5,0(r2)
81116db4:	00a045b4 	movhi	r2,33046
81116db8:	10ba0504 	addi	r2,r2,-6124
81116dbc:	18c02324 	muli	r3,r3,140
81116dc0:	10c5883a 	add	r2,r2,r3
81116dc4:	10802204 	addi	r2,r2,136
81116dc8:	10800003 	ldbu	r2,0(r2)
81116dcc:	10803fcc 	andi	r2,r2,255
81116dd0:	108000b0 	cmpltui	r2,r2,2
81116dd4:	1000151e 	bne	r2,zero,81116e2c <vCheckRetransmission128+0x240>
                    /* Now it is a Free place */
                    xInUseRetrans.b128[ucIL] = FALSE;
81116dd8:	e0ffff03 	ldbu	r3,-4(fp)
81116ddc:	00a045b4 	movhi	r2,33046
81116de0:	10b9e704 	addi	r2,r2,-6244
81116de4:	18c7883a 	add	r3,r3,r3
81116de8:	18c7883a 	add	r3,r3,r3
81116dec:	10c5883a 	add	r2,r2,r3
81116df0:	10000015 	stw	zero,0(r2)
                    SemCount128++;
81116df4:	d0a07543 	ldbu	r2,-32299(gp)
81116df8:	10800044 	addi	r2,r2,1
81116dfc:	d0a07545 	stb	r2,-32299(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer128);
81116e00:	d0a06317 	ldw	r2,-32372(gp)
81116e04:	1009883a 	mov	r4,r2
81116e08:	113e8480 	call	8113e848 <OSSemPost>
81116e0c:	e0bfff45 	stb	r2,-3(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
81116e10:	e0bfff43 	ldbu	r2,-3(fp)
81116e14:	10803fcc 	andi	r2,r2,255
81116e18:	10000426 	beq	r2,zero,81116e2c <vCheckRetransmission128+0x240>
                        SemCount128--;
81116e1c:	d0a07543 	ldbu	r2,-32299(gp)
81116e20:	10bfffc4 	addi	r2,r2,-1
81116e24:	d0a07545 	stb	r2,-32299(gp)
                        vFailSetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
81116e28:	111ba8c0 	call	8111ba8c <vFailSetCountSemaphorexBuffer128>
    

    /* ---> At this point we have access to the xBuffer128*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_128; ucIL++) {
81116e2c:	e0bfff03 	ldbu	r2,-4(fp)
81116e30:	10800044 	addi	r2,r2,1
81116e34:	e0bfff05 	stb	r2,-4(fp)
81116e38:	e0bfff03 	ldbu	r2,-4(fp)
81116e3c:	108001b0 	cmpltui	r2,r2,6
81116e40:	103f7c1e 	bne	r2,zero,81116c34 <__reset+0xfb0f6c34>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer128);
81116e44:	d0a06e17 	ldw	r2,-32328(gp)
81116e48:	1009883a 	mov	r4,r2
81116e4c:	113ca580 	call	8113ca58 <OSMutexPost>

    return;
81116e50:	0001883a 	nop
81116e54:	00000106 	br	81116e5c <vCheckRetransmission128+0x270>
    unsigned char ucIL = 0;

    OSMutexAccept(xMutexBuffer128, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
81116e58:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer128);

    return;
}
81116e5c:	e037883a 	mov	sp,fp
81116e60:	dfc00117 	ldw	ra,4(sp)
81116e64:	df000017 	ldw	fp,0(sp)
81116e68:	dec00204 	addi	sp,sp,8
81116e6c:	f800283a 	ret

81116e70 <vCheckRetransmission64>:

inline void vCheckRetransmission64( void ) {
81116e70:	defffd04 	addi	sp,sp,-12
81116e74:	de00012e 	bgeu	sp,et,81116e7c <vCheckRetransmission64+0xc>
81116e78:	003b68fa 	trap	3
81116e7c:	dfc00215 	stw	ra,8(sp)
81116e80:	df000115 	stw	fp,4(sp)
81116e84:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
81116e88:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucIL = 0;
81116e8c:	e03fff05 	stb	zero,-4(fp)

    OSMutexAccept(xMutexBuffer64, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
81116e90:	d0a07117 	ldw	r2,-32316(gp)
81116e94:	e0ffff44 	addi	r3,fp,-3
81116e98:	180b883a 	mov	r5,r3
81116e9c:	1009883a 	mov	r4,r2
81116ea0:	113be340 	call	8113be34 <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
81116ea4:	e0bfff43 	ldbu	r2,-3(fp)
81116ea8:	10803fcc 	andi	r2,r2,255
81116eac:	10008d1e 	bne	r2,zero,811170e4 <vCheckRetransmission64+0x274>
    

    /* ---> At this point we have access to the xBuffer64*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_64; ucIL++) {
81116eb0:	e03fff05 	stb	zero,-4(fp)
81116eb4:	00008306 	br	811170c4 <vCheckRetransmission64+0x254>
        /* Check if in use */
        if ( xInUseRetrans.b64[ucIL] == TRUE ) {
81116eb8:	e0ffff03 	ldbu	r3,-4(fp)
81116ebc:	00a045b4 	movhi	r2,33046
81116ec0:	10b9e704 	addi	r2,r2,-6244
81116ec4:	18c00184 	addi	r3,r3,6
81116ec8:	18c7883a 	add	r3,r3,r3
81116ecc:	18c7883a 	add	r3,r3,r3
81116ed0:	10c5883a 	add	r2,r2,r3
81116ed4:	10800017 	ldw	r2,0(r2)
81116ed8:	10800058 	cmpnei	r2,r2,1
81116edc:	1000761e 	bne	r2,zero,811170b8 <vCheckRetransmission64+0x248>

            if ( xBuffer64[ucIL].bSent == TRUE )
81116ee0:	e0ffff03 	ldbu	r3,-4(fp)
81116ee4:	00a04574 	movhi	r2,33045
81116ee8:	1095ab04 	addi	r2,r2,22188
81116eec:	18c01324 	muli	r3,r3,76
81116ef0:	10c5883a 	add	r2,r2,r3
81116ef4:	10801004 	addi	r2,r2,64
81116ef8:	10800017 	ldw	r2,0(r2)
81116efc:	10800058 	cmpnei	r2,r2,1
81116f00:	1000211e 	bne	r2,zero,81116f88 <vCheckRetransmission64+0x118>
                if ( ++xBuffer64[ucIL].usiTimeOut > TIMEOUT_COUNT )
81116f04:	e0ffff03 	ldbu	r3,-4(fp)
81116f08:	00a04574 	movhi	r2,33045
81116f0c:	1095ab04 	addi	r2,r2,22188
81116f10:	19001324 	muli	r4,r3,76
81116f14:	1105883a 	add	r2,r2,r4
81116f18:	10801184 	addi	r2,r2,70
81116f1c:	1080000b 	ldhu	r2,0(r2)
81116f20:	10800044 	addi	r2,r2,1
81116f24:	100b883a 	mov	r5,r2
81116f28:	00a04574 	movhi	r2,33045
81116f2c:	1095ab04 	addi	r2,r2,22188
81116f30:	19001324 	muli	r4,r3,76
81116f34:	1105883a 	add	r2,r2,r4
81116f38:	10801184 	addi	r2,r2,70
81116f3c:	1140000d 	sth	r5,0(r2)
81116f40:	00a04574 	movhi	r2,33045
81116f44:	1095ab04 	addi	r2,r2,22188
81116f48:	18c01324 	muli	r3,r3,76
81116f4c:	10c5883a 	add	r2,r2,r3
81116f50:	10801184 	addi	r2,r2,70
81116f54:	1080000b 	ldhu	r2,0(r2)
81116f58:	10bfffcc 	andi	r2,r2,65535
81116f5c:	10a0001c 	xori	r2,r2,32768
81116f60:	10a00004 	addi	r2,r2,-32768
81116f64:	10800090 	cmplti	r2,r2,2
81116f68:	1000071e 	bne	r2,zero,81116f88 <vCheckRetransmission64+0x118>
                    xBuffer64[ucIL].bSent = FALSE;
81116f6c:	e0ffff03 	ldbu	r3,-4(fp)
81116f70:	00a04574 	movhi	r2,33045
81116f74:	1095ab04 	addi	r2,r2,22188
81116f78:	18c01324 	muli	r3,r3,76
81116f7c:	10c5883a 	add	r2,r2,r3
81116f80:	10801004 	addi	r2,r2,64
81116f84:	10000015 	stw	zero,0(r2)

            if ( xBuffer64[ucIL].bSent == FALSE ) {
81116f88:	e0ffff03 	ldbu	r3,-4(fp)
81116f8c:	00a04574 	movhi	r2,33045
81116f90:	1095ab04 	addi	r2,r2,22188
81116f94:	18c01324 	muli	r3,r3,76
81116f98:	10c5883a 	add	r2,r2,r3
81116f9c:	10801004 	addi	r2,r2,64
81116fa0:	10800017 	ldw	r2,0(r2)
81116fa4:	1000441e 	bne	r2,zero,811170b8 <vCheckRetransmission64+0x248>
                puts(xBuffer64[ucIL].buffer);
81116fa8:	e0bfff03 	ldbu	r2,-4(fp)
81116fac:	10c01324 	muli	r3,r2,76
81116fb0:	00a04574 	movhi	r2,33045
81116fb4:	1095ab04 	addi	r2,r2,22188
81116fb8:	1885883a 	add	r2,r3,r2
81116fbc:	1009883a 	mov	r4,r2
81116fc0:	11225f00 	call	811225f0 <puts>
                xBuffer64[ucIL].bSent = TRUE;
81116fc4:	e0ffff03 	ldbu	r3,-4(fp)
81116fc8:	00a04574 	movhi	r2,33045
81116fcc:	1095ab04 	addi	r2,r2,22188
81116fd0:	18c01324 	muli	r3,r3,76
81116fd4:	10c5883a 	add	r2,r2,r3
81116fd8:	10801004 	addi	r2,r2,64
81116fdc:	00c00044 	movi	r3,1
81116fe0:	10c00015 	stw	r3,0(r2)
                xBuffer64[ucIL].usiTimeOut = 0;
81116fe4:	e0ffff03 	ldbu	r3,-4(fp)
81116fe8:	00a04574 	movhi	r2,33045
81116fec:	1095ab04 	addi	r2,r2,22188
81116ff0:	18c01324 	muli	r3,r3,76
81116ff4:	10c5883a 	add	r2,r2,r3
81116ff8:	10801184 	addi	r2,r2,70
81116ffc:	1000000d 	sth	zero,0(r2)
                /* Check if already tried all the times */
                if ( ++xBuffer64[ucIL].ucNofRetries > N_RETRIES_COMM ) {
81117000:	e0ffff03 	ldbu	r3,-4(fp)
81117004:	00a04574 	movhi	r2,33045
81117008:	1095ab04 	addi	r2,r2,22188
8111700c:	19001324 	muli	r4,r3,76
81117010:	1105883a 	add	r2,r2,r4
81117014:	10801204 	addi	r2,r2,72
81117018:	10800003 	ldbu	r2,0(r2)
8111701c:	10800044 	addi	r2,r2,1
81117020:	100b883a 	mov	r5,r2
81117024:	00a04574 	movhi	r2,33045
81117028:	1095ab04 	addi	r2,r2,22188
8111702c:	19001324 	muli	r4,r3,76
81117030:	1105883a 	add	r2,r2,r4
81117034:	10801204 	addi	r2,r2,72
81117038:	11400005 	stb	r5,0(r2)
8111703c:	00a04574 	movhi	r2,33045
81117040:	1095ab04 	addi	r2,r2,22188
81117044:	18c01324 	muli	r3,r3,76
81117048:	10c5883a 	add	r2,r2,r3
8111704c:	10801204 	addi	r2,r2,72
81117050:	10800003 	ldbu	r2,0(r2)
81117054:	10803fcc 	andi	r2,r2,255
81117058:	108000b0 	cmpltui	r2,r2,2
8111705c:	1000161e 	bne	r2,zero,811170b8 <vCheckRetransmission64+0x248>
                    /* Now it is a Free place */
                    xInUseRetrans.b64[ucIL] = FALSE;
81117060:	e0ffff03 	ldbu	r3,-4(fp)
81117064:	00a045b4 	movhi	r2,33046
81117068:	10b9e704 	addi	r2,r2,-6244
8111706c:	18c00184 	addi	r3,r3,6
81117070:	18c7883a 	add	r3,r3,r3
81117074:	18c7883a 	add	r3,r3,r3
81117078:	10c5883a 	add	r2,r2,r3
8111707c:	10000015 	stw	zero,0(r2)
                    SemCount64++;
81117080:	d0a07503 	ldbu	r2,-32300(gp)
81117084:	10800044 	addi	r2,r2,1
81117088:	d0a07505 	stb	r2,-32300(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer64);
8111708c:	d0a05e17 	ldw	r2,-32392(gp)
81117090:	1009883a 	mov	r4,r2
81117094:	113e8480 	call	8113e848 <OSSemPost>
81117098:	e0bfff45 	stb	r2,-3(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
8111709c:	e0bfff43 	ldbu	r2,-3(fp)
811170a0:	10803fcc 	andi	r2,r2,255
811170a4:	10000426 	beq	r2,zero,811170b8 <vCheckRetransmission64+0x248>
                        SemCount64--;
811170a8:	d0a07503 	ldbu	r2,-32300(gp)
811170ac:	10bfffc4 	addi	r2,r2,-1
811170b0:	d0a07505 	stb	r2,-32300(gp)
                        vFailSetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
811170b4:	111ba240 	call	8111ba24 <vFailSetCountSemaphorexBuffer64>
    

    /* ---> At this point we have access to the xBuffer64*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_64; ucIL++) {
811170b8:	e0bfff03 	ldbu	r2,-4(fp)
811170bc:	10800044 	addi	r2,r2,1
811170c0:	e0bfff05 	stb	r2,-4(fp)
811170c4:	e0bfff03 	ldbu	r2,-4(fp)
811170c8:	10800230 	cmpltui	r2,r2,8
811170cc:	103f7a1e 	bne	r2,zero,81116eb8 <__reset+0xfb0f6eb8>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer64);
811170d0:	d0a07117 	ldw	r2,-32316(gp)
811170d4:	1009883a 	mov	r4,r2
811170d8:	113ca580 	call	8113ca58 <OSMutexPost>

    return;
811170dc:	0001883a 	nop
811170e0:	00000106 	br	811170e8 <vCheckRetransmission64+0x278>
    unsigned char ucIL = 0;

    OSMutexAccept(xMutexBuffer64, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
811170e4:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer64);

    return;
}
811170e8:	e037883a 	mov	sp,fp
811170ec:	dfc00117 	ldw	ra,4(sp)
811170f0:	df000017 	ldw	fp,0(sp)
811170f4:	dec00204 	addi	sp,sp,8
811170f8:	f800283a 	ret

811170fc <vCheckRetransmission32>:


inline void vCheckRetransmission32( void ) {
811170fc:	defffd04 	addi	sp,sp,-12
81117100:	de00012e 	bgeu	sp,et,81117108 <vCheckRetransmission32+0xc>
81117104:	003b68fa 	trap	3
81117108:	dfc00215 	stw	ra,8(sp)
8111710c:	df000115 	stw	fp,4(sp)
81117110:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
81117114:	e03fff85 	stb	zero,-2(fp)
    unsigned char ucIL = 0;
81117118:	e03fff05 	stb	zero,-4(fp)
    unsigned char ucMax = 0;
8111711c:	e03fff45 	stb	zero,-3(fp)

    OSMutexAccept(xMutexBuffer32, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
81117120:	d0a06c17 	ldw	r2,-32336(gp)
81117124:	e0ffff84 	addi	r3,fp,-2
81117128:	180b883a 	mov	r5,r3
8111712c:	1009883a 	mov	r4,r2
81117130:	113be340 	call	8113be34 <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
81117134:	e0bfff83 	ldbu	r2,-2(fp)
81117138:	10803fcc 	andi	r2,r2,255
8111713c:	10009b1e 	bne	r2,zero,811173ac <vCheckRetransmission32+0x2b0>
    

    /* ---> At this point we have access to the xBuffer32*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_32; ucIL++) {
81117140:	e03fff05 	stb	zero,-4(fp)
81117144:	00009106 	br	8111738c <vCheckRetransmission32+0x290>
        /* Check if in use */
        if ( xInUseRetrans.b32[ucIL] == TRUE ) {
81117148:	e0ffff03 	ldbu	r3,-4(fp)
8111714c:	00a045b4 	movhi	r2,33046
81117150:	10b9e704 	addi	r2,r2,-6244
81117154:	18c00384 	addi	r3,r3,14
81117158:	18c7883a 	add	r3,r3,r3
8111715c:	18c7883a 	add	r3,r3,r3
81117160:	10c5883a 	add	r2,r2,r3
81117164:	10800017 	ldw	r2,0(r2)
81117168:	10800058 	cmpnei	r2,r2,1
8111716c:	1000841e 	bne	r2,zero,81117380 <vCheckRetransmission32+0x284>

            if ( xBuffer32[ucIL].bSent == TRUE )
81117170:	e0ffff03 	ldbu	r3,-4(fp)
81117174:	00a045b4 	movhi	r2,33046
81117178:	10a76704 	addi	r2,r2,-25188
8111717c:	18c00b24 	muli	r3,r3,44
81117180:	10c5883a 	add	r2,r2,r3
81117184:	10800804 	addi	r2,r2,32
81117188:	10800017 	ldw	r2,0(r2)
8111718c:	10800058 	cmpnei	r2,r2,1
81117190:	1000211e 	bne	r2,zero,81117218 <vCheckRetransmission32+0x11c>
                if ( ++xBuffer32[ucIL].usiTimeOut > TIMEOUT_COUNT )
81117194:	e0ffff03 	ldbu	r3,-4(fp)
81117198:	00a045b4 	movhi	r2,33046
8111719c:	10a76704 	addi	r2,r2,-25188
811171a0:	19000b24 	muli	r4,r3,44
811171a4:	1105883a 	add	r2,r2,r4
811171a8:	10800984 	addi	r2,r2,38
811171ac:	1080000b 	ldhu	r2,0(r2)
811171b0:	10800044 	addi	r2,r2,1
811171b4:	100b883a 	mov	r5,r2
811171b8:	00a045b4 	movhi	r2,33046
811171bc:	10a76704 	addi	r2,r2,-25188
811171c0:	19000b24 	muli	r4,r3,44
811171c4:	1105883a 	add	r2,r2,r4
811171c8:	10800984 	addi	r2,r2,38
811171cc:	1140000d 	sth	r5,0(r2)
811171d0:	00a045b4 	movhi	r2,33046
811171d4:	10a76704 	addi	r2,r2,-25188
811171d8:	18c00b24 	muli	r3,r3,44
811171dc:	10c5883a 	add	r2,r2,r3
811171e0:	10800984 	addi	r2,r2,38
811171e4:	1080000b 	ldhu	r2,0(r2)
811171e8:	10bfffcc 	andi	r2,r2,65535
811171ec:	10a0001c 	xori	r2,r2,32768
811171f0:	10a00004 	addi	r2,r2,-32768
811171f4:	10800090 	cmplti	r2,r2,2
811171f8:	1000071e 	bne	r2,zero,81117218 <vCheckRetransmission32+0x11c>
                    xBuffer32[ucIL].bSent = FALSE;
811171fc:	e0ffff03 	ldbu	r3,-4(fp)
81117200:	00a045b4 	movhi	r2,33046
81117204:	10a76704 	addi	r2,r2,-25188
81117208:	18c00b24 	muli	r3,r3,44
8111720c:	10c5883a 	add	r2,r2,r3
81117210:	10800804 	addi	r2,r2,32
81117214:	10000015 	stw	zero,0(r2)

            if ( xBuffer32[ucIL].bSent == FALSE ) {
81117218:	e0ffff03 	ldbu	r3,-4(fp)
8111721c:	00a045b4 	movhi	r2,33046
81117220:	10a76704 	addi	r2,r2,-25188
81117224:	18c00b24 	muli	r3,r3,44
81117228:	10c5883a 	add	r2,r2,r3
8111722c:	10800804 	addi	r2,r2,32
81117230:	10800017 	ldw	r2,0(r2)
81117234:	1000521e 	bne	r2,zero,81117380 <vCheckRetransmission32+0x284>
                puts(xBuffer32[ucIL].buffer);
81117238:	e0bfff03 	ldbu	r2,-4(fp)
8111723c:	10c00b24 	muli	r3,r2,44
81117240:	00a045b4 	movhi	r2,33046
81117244:	10a76704 	addi	r2,r2,-25188
81117248:	1885883a 	add	r2,r3,r2
8111724c:	1009883a 	mov	r4,r2
81117250:	11225f00 	call	811225f0 <puts>
                xBuffer32[ucIL].bSent = TRUE;
81117254:	e0ffff03 	ldbu	r3,-4(fp)
81117258:	00a045b4 	movhi	r2,33046
8111725c:	10a76704 	addi	r2,r2,-25188
81117260:	18c00b24 	muli	r3,r3,44
81117264:	10c5883a 	add	r2,r2,r3
81117268:	10800804 	addi	r2,r2,32
8111726c:	00c00044 	movi	r3,1
81117270:	10c00015 	stw	r3,0(r2)
                xBuffer32[ucIL].usiTimeOut = 0;
81117274:	e0ffff03 	ldbu	r3,-4(fp)
81117278:	00a045b4 	movhi	r2,33046
8111727c:	10a76704 	addi	r2,r2,-25188
81117280:	18c00b24 	muli	r3,r3,44
81117284:	10c5883a 	add	r2,r2,r3
81117288:	10800984 	addi	r2,r2,38
8111728c:	1000000d 	sth	zero,0(r2)
                /* Check if already tried all the times */

                ucMax = ( xBuffer32[ucIL].usiId == 1 ) ? N_RETRIES_INI_INF : N_RETRIES_COMM;
81117290:	e0ffff03 	ldbu	r3,-4(fp)
81117294:	00a045b4 	movhi	r2,33046
81117298:	10a76704 	addi	r2,r2,-25188
8111729c:	18c00b24 	muli	r3,r3,44
811172a0:	10c5883a 	add	r2,r2,r3
811172a4:	10800904 	addi	r2,r2,36
811172a8:	1080000b 	ldhu	r2,0(r2)
811172ac:	10bfffcc 	andi	r2,r2,65535
811172b0:	10800058 	cmpnei	r2,r2,1
811172b4:	1000021e 	bne	r2,zero,811172c0 <vCheckRetransmission32+0x1c4>
811172b8:	00bffe84 	movi	r2,-6
811172bc:	00000106 	br	811172c4 <vCheckRetransmission32+0x1c8>
811172c0:	00800044 	movi	r2,1
811172c4:	e0bfff45 	stb	r2,-3(fp)

                if ( ++xBuffer32[ucIL].ucNofRetries > ucMax ) {
811172c8:	e0ffff03 	ldbu	r3,-4(fp)
811172cc:	00a045b4 	movhi	r2,33046
811172d0:	10a76704 	addi	r2,r2,-25188
811172d4:	19000b24 	muli	r4,r3,44
811172d8:	1105883a 	add	r2,r2,r4
811172dc:	10800a04 	addi	r2,r2,40
811172e0:	10800003 	ldbu	r2,0(r2)
811172e4:	10800044 	addi	r2,r2,1
811172e8:	100b883a 	mov	r5,r2
811172ec:	00a045b4 	movhi	r2,33046
811172f0:	10a76704 	addi	r2,r2,-25188
811172f4:	19000b24 	muli	r4,r3,44
811172f8:	1105883a 	add	r2,r2,r4
811172fc:	10800a04 	addi	r2,r2,40
81117300:	11400005 	stb	r5,0(r2)
81117304:	00a045b4 	movhi	r2,33046
81117308:	10a76704 	addi	r2,r2,-25188
8111730c:	18c00b24 	muli	r3,r3,44
81117310:	10c5883a 	add	r2,r2,r3
81117314:	10800a04 	addi	r2,r2,40
81117318:	10800003 	ldbu	r2,0(r2)
8111731c:	10803fcc 	andi	r2,r2,255
81117320:	e0ffff43 	ldbu	r3,-3(fp)
81117324:	1880162e 	bgeu	r3,r2,81117380 <vCheckRetransmission32+0x284>
                    /* Now it is a Free place */
                    xInUseRetrans.b32[ucIL] = FALSE;
81117328:	e0ffff03 	ldbu	r3,-4(fp)
8111732c:	00a045b4 	movhi	r2,33046
81117330:	10b9e704 	addi	r2,r2,-6244
81117334:	18c00384 	addi	r3,r3,14
81117338:	18c7883a 	add	r3,r3,r3
8111733c:	18c7883a 	add	r3,r3,r3
81117340:	10c5883a 	add	r2,r2,r3
81117344:	10000015 	stw	zero,0(r2)
                    SemCount32++;
81117348:	d0a06883 	ldbu	r2,-32350(gp)
8111734c:	10800044 	addi	r2,r2,1
81117350:	d0a06885 	stb	r2,-32350(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer32);
81117354:	d0a06f17 	ldw	r2,-32324(gp)
81117358:	1009883a 	mov	r4,r2
8111735c:	113e8480 	call	8113e848 <OSSemPost>
81117360:	e0bfff85 	stb	r2,-2(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
81117364:	e0bfff83 	ldbu	r2,-2(fp)
81117368:	10803fcc 	andi	r2,r2,255
8111736c:	10000426 	beq	r2,zero,81117380 <vCheckRetransmission32+0x284>
                        SemCount32--;
81117370:	d0a06883 	ldbu	r2,-32350(gp)
81117374:	10bfffc4 	addi	r2,r2,-1
81117378:	d0a06885 	stb	r2,-32350(gp)
                        vFailSetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
8111737c:	111b9bc0 	call	8111b9bc <vFailSetCountSemaphorexBuffer32>
    

    /* ---> At this point we have access to the xBuffer32*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_32; ucIL++) {
81117380:	e0bfff03 	ldbu	r2,-4(fp)
81117384:	10800044 	addi	r2,r2,1
81117388:	e0bfff05 	stb	r2,-4(fp)
8111738c:	e0bfff03 	ldbu	r2,-4(fp)
81117390:	10800230 	cmpltui	r2,r2,8
81117394:	103f6c1e 	bne	r2,zero,81117148 <__reset+0xfb0f7148>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer32);
81117398:	d0a06c17 	ldw	r2,-32336(gp)
8111739c:	1009883a 	mov	r4,r2
811173a0:	113ca580 	call	8113ca58 <OSMutexPost>

    return;
811173a4:	0001883a 	nop
811173a8:	00000106 	br	811173b0 <vCheckRetransmission32+0x2b4>
    unsigned char ucMax = 0;

    OSMutexAccept(xMutexBuffer32, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
811173ac:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer32);

    return;
}
811173b0:	e037883a 	mov	sp,fp
811173b4:	dfc00117 	ldw	ra,4(sp)
811173b8:	df000017 	ldw	fp,0(sp)
811173bc:	dec00204 	addi	sp,sp,8
811173c0:	f800283a 	ret

811173c4 <bResourcesInitRTOS>:
 */
TSimucam_MEB xSimMeb; /* Struct */
tDmaSim xDma[2];		  /* Control of the DMA */

/* Instanceatin and Initialization of the resources for the RTOS */
bool bResourcesInitRTOS( void ) {
811173c4:	defff904 	addi	sp,sp,-28
811173c8:	de00012e 	bgeu	sp,et,811173d0 <bResourcesInitRTOS+0xc>
811173cc:	003b68fa 	trap	3
811173d0:	dfc00615 	stw	ra,24(sp)
811173d4:	df000515 	stw	fp,20(sp)
811173d8:	df000504 	addi	fp,sp,20
	bool bSuccess = TRUE;
811173dc:	00800044 	movi	r2,1
811173e0:	e0bffe15 	stw	r2,-8(fp)
	INT8U err;

	/* This semaphore in the sincronization of the task receiver_com_task with sender_com_task*/
	xSemCommInit = OSSemCreate(0);
811173e4:	0009883a 	mov	r4,zero
811173e8:	113e1980 	call	8113e198 <OSSemCreate>
811173ec:	d0a06015 	stw	r2,-32384(gp)
	if (!xSemCommInit) {
811173f0:	d0a06017 	ldw	r2,-32384(gp)
811173f4:	1000021e 	bne	r2,zero,81117400 <bResourcesInitRTOS+0x3c>
		vFailCreateSemaphoreResources();
811173f8:	111b4540 	call	8111b454 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
811173fc:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of tx buffer, between SenderTask and Acks from ReceiverTask*/
	xTxUARTMutex = OSMutexCreate(PCP_MUTEX_TX_UART_PRIO, &err);
81117400:	e0bfff04 	addi	r2,fp,-4
81117404:	100b883a 	mov	r5,r2
81117408:	01000444 	movi	r4,17
8111740c:	113bfe00 	call	8113bfe0 <OSMutexCreate>
81117410:	d0a07415 	stw	r2,-32304(gp)
	if ( err != OS_ERR_NONE ) {
81117414:	e0bfff03 	ldbu	r2,-4(fp)
81117418:	10803fcc 	andi	r2,r2,255
8111741c:	10000526 	beq	r2,zero,81117434 <bResourcesInitRTOS+0x70>
		vFailCreateMutexSResources(err);
81117420:	e0bfff03 	ldbu	r2,-4(fp)
81117424:	10803fcc 	andi	r2,r2,255
81117428:	1009883a 	mov	r4,r2
8111742c:	111b3a80 	call	8111b3a8 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81117430:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "big" buffer of 128 characters*/
	xMutexBuffer128 = OSMutexCreate(PCP_MUTEX_B128_PRIO, &err);
81117434:	e0bfff04 	addi	r2,fp,-4
81117438:	100b883a 	mov	r5,r2
8111743c:	01000504 	movi	r4,20
81117440:	113bfe00 	call	8113bfe0 <OSMutexCreate>
81117444:	d0a06e15 	stw	r2,-32328(gp)
	if ( err != OS_ERR_NONE ) {
81117448:	e0bfff03 	ldbu	r2,-4(fp)
8111744c:	10803fcc 	andi	r2,r2,255
81117450:	10000526 	beq	r2,zero,81117468 <bResourcesInitRTOS+0xa4>
		vFailCreateMutexSResources(err);
81117454:	e0bfff03 	ldbu	r2,-4(fp)
81117458:	10803fcc 	andi	r2,r2,255
8111745c:	1009883a 	mov	r4,r2
81117460:	111b3a80 	call	8111b3a8 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81117464:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "medium" buffer of 64 characters*/
	xMutexBuffer64 = OSMutexCreate(PCP_MUTEX_B64_PRIO, &err);
81117468:	e0bfff04 	addi	r2,fp,-4
8111746c:	100b883a 	mov	r5,r2
81117470:	01000544 	movi	r4,21
81117474:	113bfe00 	call	8113bfe0 <OSMutexCreate>
81117478:	d0a07115 	stw	r2,-32316(gp)
	if ( err != OS_ERR_NONE ) {
8111747c:	e0bfff03 	ldbu	r2,-4(fp)
81117480:	10803fcc 	andi	r2,r2,255
81117484:	10000526 	beq	r2,zero,8111749c <bResourcesInitRTOS+0xd8>
		vFailCreateMutexSResources(err);
81117488:	e0bfff03 	ldbu	r2,-4(fp)
8111748c:	10803fcc 	andi	r2,r2,255
81117490:	1009883a 	mov	r4,r2
81117494:	111b3a80 	call	8111b3a8 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81117498:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "small" buffer of 32 characters*/
	xMutexBuffer32 = OSMutexCreate(PCP_MUTEX_B32_PRIO, &err);
8111749c:	e0bfff04 	addi	r2,fp,-4
811174a0:	100b883a 	mov	r5,r2
811174a4:	01000584 	movi	r4,22
811174a8:	113bfe00 	call	8113bfe0 <OSMutexCreate>
811174ac:	d0a06c15 	stw	r2,-32336(gp)
	if ( err != OS_ERR_NONE ) {
811174b0:	e0bfff03 	ldbu	r2,-4(fp)
811174b4:	10803fcc 	andi	r2,r2,255
811174b8:	10000526 	beq	r2,zero,811174d0 <bResourcesInitRTOS+0x10c>
		vFailCreateMutexSResources(err);
811174bc:	e0bfff03 	ldbu	r2,-4(fp)
811174c0:	10803fcc 	andi	r2,r2,255
811174c4:	1009883a 	mov	r4,r2
811174c8:	111b3a80 	call	8111b3a8 <vFailCreateMutexSResources>
		bSuccess = FALSE;
811174cc:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "big" buffer of 128 characters*/
	SemCount128 = N_128;
811174d0:	00800184 	movi	r2,6
811174d4:	d0a07545 	stb	r2,-32299(gp)
	xSemCountBuffer128 = OSSemCreate(N_128);
811174d8:	01000184 	movi	r4,6
811174dc:	113e1980 	call	8113e198 <OSSemCreate>
811174e0:	d0a06315 	stw	r2,-32372(gp)
	if (!xSemCountBuffer128) {
811174e4:	d0a06317 	ldw	r2,-32372(gp)
811174e8:	1000031e 	bne	r2,zero,811174f8 <bResourcesInitRTOS+0x134>
		SemCount128 = 0;
811174ec:	d0207545 	stb	zero,-32299(gp)
		vFailCreateSemaphoreResources();
811174f0:	111b4540 	call	8111b454 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
811174f4:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "medium" buffer of 64 characters*/
	SemCount64 = N_64;
811174f8:	00800204 	movi	r2,8
811174fc:	d0a07505 	stb	r2,-32300(gp)
	xSemCountBuffer64 = OSSemCreate(N_64);
81117500:	01000204 	movi	r4,8
81117504:	113e1980 	call	8113e198 <OSSemCreate>
81117508:	d0a05e15 	stw	r2,-32392(gp)
	if (!xSemCountBuffer64) {
8111750c:	d0a05e17 	ldw	r2,-32392(gp)
81117510:	1000031e 	bne	r2,zero,81117520 <bResourcesInitRTOS+0x15c>
		SemCount64 = 0;
81117514:	d0207505 	stb	zero,-32300(gp)
		vFailCreateSemaphoreResources();
81117518:	111b4540 	call	8111b454 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
8111751c:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "small" buffer of 32 characters*/
	SemCount32 = N_32;
81117520:	00800204 	movi	r2,8
81117524:	d0a06885 	stb	r2,-32350(gp)
	xSemCountBuffer32 = OSSemCreate(N_32);
81117528:	01000204 	movi	r4,8
8111752c:	113e1980 	call	8113e198 <OSSemCreate>
81117530:	d0a06f15 	stw	r2,-32324(gp)
	if (!xSemCountBuffer32) {
81117534:	d0a06f17 	ldw	r2,-32324(gp)
81117538:	1000031e 	bne	r2,zero,81117548 <bResourcesInitRTOS+0x184>
		SemCount32 = 0;
8111753c:	d0206885 	stb	zero,-32350(gp)
		vFailCreateSemaphoreResources();
81117540:	111b4540 	call	8111b454 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81117544:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Mutex and Semaphores to control the communication of FastReaderTask */
	xMutexReceivedACK = OSMutexCreate(PCP_MUTEX_RECEIVER_ACK, &err);
81117548:	e0bfff04 	addi	r2,fp,-4
8111754c:	100b883a 	mov	r5,r2
81117550:	010004c4 	movi	r4,19
81117554:	113bfe00 	call	8113bfe0 <OSMutexCreate>
81117558:	d0a06515 	stw	r2,-32364(gp)
	if ( err != OS_ERR_NONE ) {
8111755c:	e0bfff03 	ldbu	r2,-4(fp)
81117560:	10803fcc 	andi	r2,r2,255
81117564:	10000526 	beq	r2,zero,8111757c <bResourcesInitRTOS+0x1b8>
		vFailCreateMutexSResources(err);
81117568:	e0bfff03 	ldbu	r2,-4(fp)
8111756c:	10803fcc 	andi	r2,r2,255
81117570:	1009883a 	mov	r4,r2
81117574:	111b3a80 	call	8111b3a8 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81117578:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex for Reader -> Parser*/
	xMutexPreParsed = OSMutexCreate(PCP_MUTEX_PrePareseds, &err);
8111757c:	e0bfff04 	addi	r2,fp,-4
81117580:	100b883a 	mov	r5,r2
81117584:	010005c4 	movi	r4,23
81117588:	113bfe00 	call	8113bfe0 <OSMutexCreate>
8111758c:	d0a06b15 	stw	r2,-32340(gp)
	if ( err != OS_ERR_NONE ) {
81117590:	e0bfff03 	ldbu	r2,-4(fp)
81117594:	10803fcc 	andi	r2,r2,255
81117598:	10000526 	beq	r2,zero,811175b0 <bResourcesInitRTOS+0x1ec>
		vFailCreateMutexSResources(err);
8111759c:	e0bfff03 	ldbu	r2,-4(fp)
811175a0:	10803fcc 	andi	r2,r2,255
811175a4:	1009883a 	mov	r4,r2
811175a8:	111b3a80 	call	8111b3a8 <vFailCreateMutexSResources>
		bSuccess = FALSE;
811175ac:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemCountReceivedACK = OSSemCreate(0);
811175b0:	0009883a 	mov	r4,zero
811175b4:	113e1980 	call	8113e198 <OSSemCreate>
811175b8:	d0a06615 	stw	r2,-32360(gp)
	if (!xSemCountReceivedACK) {
811175bc:	d0a06617 	ldw	r2,-32360(gp)
811175c0:	1000021e 	bne	r2,zero,811175cc <bResourcesInitRTOS+0x208>
		vFailCreateSemaphoreResources();
811175c4:	111b4540 	call	8111b454 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
811175c8:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemCountPreParsed = OSSemCreate(0);
811175cc:	0009883a 	mov	r4,zero
811175d0:	113e1980 	call	8113e198 <OSSemCreate>
811175d4:	d0a06415 	stw	r2,-32368(gp)
	if (!xSemCountPreParsed) {
811175d8:	d0a06417 	ldw	r2,-32368(gp)
811175dc:	1000021e 	bne	r2,zero,811175e8 <bResourcesInitRTOS+0x224>
		vFailCreateSemaphoreResources();
811175e0:	111b4540 	call	8111b454 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
811175e4:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex and Semaphore to AckSenderTask*/
	xSemCountSenderACK = OSSemCreate(0);
811175e8:	0009883a 	mov	r4,zero
811175ec:	113e1980 	call	8113e198 <OSSemCreate>
811175f0:	d0a06115 	stw	r2,-32380(gp)
	if (!xSemCountSenderACK) {
811175f4:	d0a06117 	ldw	r2,-32380(gp)
811175f8:	1000021e 	bne	r2,zero,81117604 <bResourcesInitRTOS+0x240>
		vFailCreateSemaphoreResources();
811175fc:	111b4540 	call	8111b454 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81117600:	e03ffe15 	stw	zero,-8(fp)
	}

	xMutexSenderACK = OSMutexCreate(PCP_MUTEX_SENDER_ACK, &err);
81117604:	e0bfff04 	addi	r2,fp,-4
81117608:	100b883a 	mov	r5,r2
8111760c:	01000484 	movi	r4,18
81117610:	113bfe00 	call	8113bfe0 <OSMutexCreate>
81117614:	d0a07215 	stw	r2,-32312(gp)
	if ( err != OS_ERR_NONE ) {
81117618:	e0bfff03 	ldbu	r2,-4(fp)
8111761c:	10803fcc 	andi	r2,r2,255
81117620:	10000526 	beq	r2,zero,81117638 <bResourcesInitRTOS+0x274>
		vFailCreateMutexSResources(err);
81117624:	e0bfff03 	ldbu	r2,-4(fp)
81117628:	10803fcc 	andi	r2,r2,255
8111762c:	1009883a 	mov	r4,r2
81117630:	111b3a80 	call	8111b3a8 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81117634:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemTimeoutChecker = OSSemCreate(0);
81117638:	0009883a 	mov	r4,zero
8111763c:	113e1980 	call	8113e198 <OSSemCreate>
81117640:	d0a06715 	stw	r2,-32356(gp)
	if (!xSemTimeoutChecker) {
81117644:	d0a06717 	ldw	r2,-32356(gp)
81117648:	1000021e 	bne	r2,zero,81117654 <bResourcesInitRTOS+0x290>
		vFailCreateSemaphoreResources();
8111764c:	111b4540 	call	8111b454 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81117650:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Create the timer that will be used to count the timeout for the retransmission*/
	xTimerRetransmission = OSTmrCreate(	(INT32U         )DLY_TIMER,  /* 200 ticks = 200 millisec */
81117654:	e0bfff04 	addi	r2,fp,-4
81117658:	d8800215 	stw	r2,8(sp)
8111765c:	00a04574 	movhi	r2,33045
81117660:	10b82604 	addi	r2,r2,-8040
81117664:	d8800115 	stw	r2,4(sp)
81117668:	d8000015 	stw	zero,0(sp)
8111766c:	01e044b4 	movhi	r7,33042
81117670:	39e4b904 	addi	r7,r7,-27932
81117674:	01800084 	movi	r6,2
81117678:	01400104 	movi	r5,4
8111767c:	01000284 	movi	r4,10
81117680:	11408640 	call	81140864 <OSTmrCreate>
81117684:	d0a06d15 	stw	r2,-32332(gp)
										(INT8U          )OS_TMR_OPT_PERIODIC,
										(OS_TMR_CALLBACK)vTimeoutCheck,
										(void          *)0,
										(INT8U         *)"timer timeout",
										(INT8U         *)&err);	
	if ( err != OS_ERR_NONE ) {
81117688:	e0bfff03 	ldbu	r2,-4(fp)
8111768c:	10803fcc 	andi	r2,r2,255
81117690:	10000226 	beq	r2,zero,8111769c <bResourcesInitRTOS+0x2d8>
		vFailCreateTimerRetransmisison();
81117694:	111c0b80 	call	8111c0b8 <vFailCreateTimerRetransmisison>
		bSuccess = FALSE;
81117698:	e03ffe15 	stw	zero,-8(fp)
	}

	xNfeeSchedule = OSQCreate(&xNfeeScheduleTBL[0], N_OF_MSG_QUEUE);
8111769c:	01400484 	movi	r5,18
811176a0:	01204574 	movhi	r4,33045
811176a4:	211aa704 	addi	r4,r4,27292
811176a8:	113d0cc0 	call	8113d0cc <OSQCreate>
811176ac:	d0a05d15 	stw	r2,-32396(gp)
	if ( xNfeeSchedule == NULL ) {
811176b0:	d0a05d17 	ldw	r2,-32396(gp)
811176b4:	1000021e 	bne	r2,zero,811176c0 <bResourcesInitRTOS+0x2fc>
		vFailCreateScheduleQueue();
811176b8:	111c69c0 	call	8111c69c <vFailCreateScheduleQueue>
		bSuccess = FALSE;		
811176bc:	e03ffe15 	stw	zero,-8(fp)
	}

	xFeeQ[0] = OSQCreate(&xFeeQueueTBL0[0], N_MSG_FEE);
811176c0:	01400204 	movi	r5,8
811176c4:	012045b4 	movhi	r4,33046
811176c8:	2119b904 	addi	r4,r4,26340
811176cc:	113d0cc0 	call	8113d0cc <OSQCreate>
811176d0:	d0a06a15 	stw	r2,-32344(gp)
	if ( xFeeQ[0] == NULL ) {
811176d4:	d0a06a17 	ldw	r2,-32344(gp)
811176d8:	1000031e 	bne	r2,zero,811176e8 <bResourcesInitRTOS+0x324>
		vFailCreateNFEEQueue( 0 );
811176dc:	0009883a 	mov	r4,zero
811176e0:	111c7040 	call	8111c704 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
811176e4:	e03ffe15 	stw	zero,-8(fp)
		bSuccess = FALSE;		
	}
*/


	xWaitSyncQFee[0] = OSQCreate(&SyncTBL0[0], N_MSG_SYNC);
811176e8:	01400204 	movi	r5,8
811176ec:	012045b4 	movhi	r4,33046
811176f0:	213eff04 	addi	r4,r4,-1028
811176f4:	113d0cc0 	call	8113d0cc <OSQCreate>
811176f8:	d0a05c15 	stw	r2,-32400(gp)
	if ( xWaitSyncQFee[0] == NULL ) {
811176fc:	d0a05c17 	ldw	r2,-32400(gp)
81117700:	1000031e 	bne	r2,zero,81117710 <bResourcesInitRTOS+0x34c>
		vFailCreateNFEESyncQueue( 0 );
81117704:	0009883a 	mov	r4,zero
81117708:	111c7740 	call	8111c774 <vFailCreateNFEESyncQueue>
		bSuccess = FALSE;
8111770c:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Syncronization (no THE sync) of the meb and signalization that has to wakeup */
	xMebQ = OSQCreate(&xMebQTBL[0], N_OF_MEB_MSG_QUEUE);
81117710:	01400204 	movi	r5,8
81117714:	012045b4 	movhi	r4,33046
81117718:	2139fd04 	addi	r4,r4,-6156
8111771c:	113d0cc0 	call	8113d0cc <OSQCreate>
81117720:	d0a06915 	stw	r2,-32348(gp)
	if ( xMebQ == NULL ) {
81117724:	d0a06917 	ldw	r2,-32348(gp)
81117728:	1000031e 	bne	r2,zero,81117738 <bResourcesInitRTOS+0x374>
		vFailCreateNFEEQueue( 5 );
8111772c:	01000144 	movi	r4,5
81117730:	111c7040 	call	8111c704 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
81117734:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex and Semaphores to control the communication of FastReaderTask */
	xMutexPus = OSMutexCreate(PCP_MUTEX_PUS_QUEUE, &err);
81117738:	e0bfff04 	addi	r2,fp,-4
8111773c:	100b883a 	mov	r5,r2
81117740:	010001c4 	movi	r4,7
81117744:	113bfe00 	call	8113bfe0 <OSMutexCreate>
81117748:	d0a07315 	stw	r2,-32308(gp)
	if ( err != OS_ERR_NONE ) {
8111774c:	e0bfff03 	ldbu	r2,-4(fp)
81117750:	10803fcc 	andi	r2,r2,255
81117754:	10000526 	beq	r2,zero,8111776c <bResourcesInitRTOS+0x3a8>
		vFailCreateMutexSPUSQueueMeb(err);
81117758:	e0bfff03 	ldbu	r2,-4(fp)
8111775c:	10803fcc 	andi	r2,r2,255
81117760:	1009883a 	mov	r4,r2
81117764:	111cb8c0 	call	8111cb8c <vFailCreateMutexSPUSQueueMeb>
		bSuccess = FALSE;
81117768:	e03ffe15 	stw	zero,-8(fp)
	}


	/* This Queue is the fast way to comunicate with NFEE Controller task, the communication will be done by sending ints using MASKs*/
	xQMaskFeeCtrl = OSQCreate(&xQMaskCMDNFeeCtrlTBL[0], N_OF_MSG_QUEUE_MASK);
8111776c:	01400404 	movi	r5,16
81117770:	012045b4 	movhi	r4,33046
81117774:	213ad704 	addi	r4,r4,-5284
81117778:	113d0cc0 	call	8113d0cc <OSQCreate>
8111777c:	d0a07015 	stw	r2,-32320(gp)
	if ( xQMaskFeeCtrl == NULL ) {
81117780:	d0a07017 	ldw	r2,-32320(gp)
81117784:	1000021e 	bne	r2,zero,81117790 <bResourcesInitRTOS+0x3cc>
		vCouldNotCreateQueueMaskNfeeCtrl( );
81117788:	111ccec0 	call	8111ccec <vCouldNotCreateQueueMaskNfeeCtrl>
		bSuccess = FALSE;		
8111778c:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This Queue is the fast way to comunicate with NFEE Controller task, the communication will be done by sending ints using MASKs*/
	xQMaskDataCtrl = OSQCreate(&xQMaskCMDNDataCtrlTBL[0], N_OF_MSG_QUEUE_MASK);
81117790:	01400404 	movi	r5,16
81117794:	012045b4 	movhi	r4,33046
81117798:	212dbf04 	addi	r4,r4,-18692
8111779c:	113d0cc0 	call	8113d0cc <OSQCreate>
811177a0:	d0a05f15 	stw	r2,-32388(gp)
	if ( xQMaskDataCtrl == NULL ) {
811177a4:	d0a05f17 	ldw	r2,-32388(gp)
811177a8:	1000021e 	bne	r2,zero,811177b4 <bResourcesInitRTOS+0x3f0>
		vCouldNotCreateQueueMaskDataCtrl( );
811177ac:	111cd540 	call	8111cd54 <vCouldNotCreateQueueMaskDataCtrl>
		bSuccess = FALSE;		
811177b0:	e03ffe15 	stw	zero,-8(fp)
	}

	xDma[0].xMutexDMA = OSMutexCreate(PCP_MUTEX_DMA_0, &err);
811177b4:	e0bfff04 	addi	r2,fp,-4
811177b8:	100b883a 	mov	r5,r2
811177bc:	01000104 	movi	r4,4
811177c0:	113bfe00 	call	8113bfe0 <OSMutexCreate>
811177c4:	1007883a 	mov	r3,r2
811177c8:	00a045b4 	movhi	r2,33046
811177cc:	108d0d04 	addi	r2,r2,13364
811177d0:	10c00015 	stw	r3,0(r2)
	if ( err != OS_ERR_NONE ) {
811177d4:	e0bfff03 	ldbu	r2,-4(fp)
811177d8:	10803fcc 	andi	r2,r2,255
811177dc:	10000226 	beq	r2,zero,811177e8 <bResourcesInitRTOS+0x424>
		vFailCreateMutexDMA();
811177e0:	111b4080 	call	8111b408 <vFailCreateMutexDMA>
		bSuccess = FALSE;
811177e4:	e03ffe15 	stw	zero,-8(fp)
	}

	xDma[1].xMutexDMA = OSMutexCreate(PCP_MUTEX_DMA_1, &err);
811177e8:	e0bfff04 	addi	r2,fp,-4
811177ec:	100b883a 	mov	r5,r2
811177f0:	01000184 	movi	r4,6
811177f4:	113bfe00 	call	8113bfe0 <OSMutexCreate>
811177f8:	1007883a 	mov	r3,r2
811177fc:	00a045b4 	movhi	r2,33046
81117800:	108d0d04 	addi	r2,r2,13364
81117804:	10c00215 	stw	r3,8(r2)
	if ( err != OS_ERR_NONE ) {
81117808:	e0bfff03 	ldbu	r2,-4(fp)
8111780c:	10803fcc 	andi	r2,r2,255
81117810:	10000226 	beq	r2,zero,8111781c <bResourcesInitRTOS+0x458>
		vFailCreateMutexDMA();
81117814:	111b4080 	call	8111b408 <vFailCreateMutexDMA>
		bSuccess = FALSE;
81117818:	e03ffe15 	stw	zero,-8(fp)
	}	

	return bSuccess;
8111781c:	e0bffe17 	ldw	r2,-8(fp)
}
81117820:	e037883a 	mov	sp,fp
81117824:	dfc00117 	ldw	ra,4(sp)
81117828:	df000017 	ldw	fp,0(sp)
8111782c:	dec00204 	addi	sp,sp,8
81117830:	f800283a 	ret

81117834 <vVariablesInitialization>:

/* Global variables already initialized with zero. But better safe than I'm sorry. */
void vVariablesInitialization ( void ) {
81117834:	defffd04 	addi	sp,sp,-12
81117838:	de00012e 	bgeu	sp,et,81117840 <vVariablesInitialization+0xc>
8111783c:	003b68fa 	trap	3
81117840:	dfc00215 	stw	ra,8(sp)
81117844:	df000115 	stw	fp,4(sp)
81117848:	df000104 	addi	fp,sp,4
	unsigned char ucIL = 0;
8111784c:	e03fff05 	stb	zero,-4(fp)

	usiIdCMD = 2;
81117850:	00800084 	movi	r2,2
81117854:	d0a0680d 	sth	r2,-32352(gp)

	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128));
81117858:	01800604 	movi	r6,24
8111785c:	000b883a 	mov	r5,zero
81117860:	012045b4 	movhi	r4,33046
81117864:	2139e704 	addi	r4,r4,-6244
81117868:	11221a40 	call	811221a4 <memset>
	memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64));
8111786c:	01800804 	movi	r6,32
81117870:	000b883a 	mov	r5,zero
81117874:	012045b4 	movhi	r4,33046
81117878:	2139ed04 	addi	r4,r4,-6220
8111787c:	11221a40 	call	811221a4 <memset>
	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32));
81117880:	01800804 	movi	r6,32
81117884:	000b883a 	mov	r5,zero
81117888:	012045b4 	movhi	r4,33046
8111788c:	2139f504 	addi	r4,r4,-6188
81117890:	11221a40 	call	811221a4 <memset>
	
	for( ucIL = 0; ucIL < N_128; ucIL++)
81117894:	e03fff05 	stb	zero,-4(fp)
81117898:	00002806 	br	8111793c <vVariablesInitialization+0x108>
	{
		memset( xBuffer128[ucIL].buffer, 0, 128);
8111789c:	e0bfff03 	ldbu	r2,-4(fp)
811178a0:	10c02324 	muli	r3,r2,140
811178a4:	00a045b4 	movhi	r2,33046
811178a8:	10ba0504 	addi	r2,r2,-6124
811178ac:	1885883a 	add	r2,r3,r2
811178b0:	01802004 	movi	r6,128
811178b4:	000b883a 	mov	r5,zero
811178b8:	1009883a 	mov	r4,r2
811178bc:	11221a40 	call	811221a4 <memset>
		xBuffer128[ucIL].bSent = FALSE;
811178c0:	e0ffff03 	ldbu	r3,-4(fp)
811178c4:	00a045b4 	movhi	r2,33046
811178c8:	10ba0504 	addi	r2,r2,-6124
811178cc:	18c02324 	muli	r3,r3,140
811178d0:	10c5883a 	add	r2,r2,r3
811178d4:	10802004 	addi	r2,r2,128
811178d8:	10000015 	stw	zero,0(r2)
		xBuffer128[ucIL].usiId = 0;
811178dc:	e0ffff03 	ldbu	r3,-4(fp)
811178e0:	00a045b4 	movhi	r2,33046
811178e4:	10ba0504 	addi	r2,r2,-6124
811178e8:	18c02324 	muli	r3,r3,140
811178ec:	10c5883a 	add	r2,r2,r3
811178f0:	10802104 	addi	r2,r2,132
811178f4:	1000000d 	sth	zero,0(r2)
		xBuffer128[ucIL].usiTimeOut = 0;
811178f8:	e0ffff03 	ldbu	r3,-4(fp)
811178fc:	00a045b4 	movhi	r2,33046
81117900:	10ba0504 	addi	r2,r2,-6124
81117904:	18c02324 	muli	r3,r3,140
81117908:	10c5883a 	add	r2,r2,r3
8111790c:	10802184 	addi	r2,r2,134
81117910:	1000000d 	sth	zero,0(r2)
		xBuffer128[ucIL].ucNofRetries = 0;
81117914:	e0ffff03 	ldbu	r3,-4(fp)
81117918:	00a045b4 	movhi	r2,33046
8111791c:	10ba0504 	addi	r2,r2,-6124
81117920:	18c02324 	muli	r3,r3,140
81117924:	10c5883a 	add	r2,r2,r3
81117928:	10802204 	addi	r2,r2,136
8111792c:	10000005 	stb	zero,0(r2)

	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128));
	memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64));
	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32));
	
	for( ucIL = 0; ucIL < N_128; ucIL++)
81117930:	e0bfff03 	ldbu	r2,-4(fp)
81117934:	10800044 	addi	r2,r2,1
81117938:	e0bfff05 	stb	r2,-4(fp)
8111793c:	e0bfff03 	ldbu	r2,-4(fp)
81117940:	108001b0 	cmpltui	r2,r2,6
81117944:	103fd51e 	bne	r2,zero,8111789c <__reset+0xfb0f789c>
		xBuffer128[ucIL].usiId = 0;
		xBuffer128[ucIL].usiTimeOut = 0;
		xBuffer128[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_64; ucIL++)
81117948:	e03fff05 	stb	zero,-4(fp)
8111794c:	00002806 	br	811179f0 <vVariablesInitialization+0x1bc>
	{
		memset( xBuffer64[ucIL].buffer, 0, 64);
81117950:	e0bfff03 	ldbu	r2,-4(fp)
81117954:	10c01324 	muli	r3,r2,76
81117958:	00a04574 	movhi	r2,33045
8111795c:	1095ab04 	addi	r2,r2,22188
81117960:	1885883a 	add	r2,r3,r2
81117964:	01801004 	movi	r6,64
81117968:	000b883a 	mov	r5,zero
8111796c:	1009883a 	mov	r4,r2
81117970:	11221a40 	call	811221a4 <memset>
		xBuffer64[ucIL].bSent = FALSE;
81117974:	e0ffff03 	ldbu	r3,-4(fp)
81117978:	00a04574 	movhi	r2,33045
8111797c:	1095ab04 	addi	r2,r2,22188
81117980:	18c01324 	muli	r3,r3,76
81117984:	10c5883a 	add	r2,r2,r3
81117988:	10801004 	addi	r2,r2,64
8111798c:	10000015 	stw	zero,0(r2)
		xBuffer64[ucIL].usiId = 0;
81117990:	e0ffff03 	ldbu	r3,-4(fp)
81117994:	00a04574 	movhi	r2,33045
81117998:	1095ab04 	addi	r2,r2,22188
8111799c:	18c01324 	muli	r3,r3,76
811179a0:	10c5883a 	add	r2,r2,r3
811179a4:	10801104 	addi	r2,r2,68
811179a8:	1000000d 	sth	zero,0(r2)
		xBuffer64[ucIL].usiTimeOut = 0;
811179ac:	e0ffff03 	ldbu	r3,-4(fp)
811179b0:	00a04574 	movhi	r2,33045
811179b4:	1095ab04 	addi	r2,r2,22188
811179b8:	18c01324 	muli	r3,r3,76
811179bc:	10c5883a 	add	r2,r2,r3
811179c0:	10801184 	addi	r2,r2,70
811179c4:	1000000d 	sth	zero,0(r2)
		xBuffer64[ucIL].ucNofRetries = 0;
811179c8:	e0ffff03 	ldbu	r3,-4(fp)
811179cc:	00a04574 	movhi	r2,33045
811179d0:	1095ab04 	addi	r2,r2,22188
811179d4:	18c01324 	muli	r3,r3,76
811179d8:	10c5883a 	add	r2,r2,r3
811179dc:	10801204 	addi	r2,r2,72
811179e0:	10000005 	stb	zero,0(r2)
		xBuffer128[ucIL].usiId = 0;
		xBuffer128[ucIL].usiTimeOut = 0;
		xBuffer128[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_64; ucIL++)
811179e4:	e0bfff03 	ldbu	r2,-4(fp)
811179e8:	10800044 	addi	r2,r2,1
811179ec:	e0bfff05 	stb	r2,-4(fp)
811179f0:	e0bfff03 	ldbu	r2,-4(fp)
811179f4:	10800230 	cmpltui	r2,r2,8
811179f8:	103fd51e 	bne	r2,zero,81117950 <__reset+0xfb0f7950>
		xBuffer64[ucIL].usiId = 0;
		xBuffer64[ucIL].usiTimeOut = 0;
		xBuffer64[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_32; ucIL++)
811179fc:	e03fff05 	stb	zero,-4(fp)
81117a00:	00002806 	br	81117aa4 <vVariablesInitialization+0x270>
	{
		memset( xBuffer32[ucIL].buffer, 0, 32);
81117a04:	e0bfff03 	ldbu	r2,-4(fp)
81117a08:	10c00b24 	muli	r3,r2,44
81117a0c:	00a045b4 	movhi	r2,33046
81117a10:	10a76704 	addi	r2,r2,-25188
81117a14:	1885883a 	add	r2,r3,r2
81117a18:	01800804 	movi	r6,32
81117a1c:	000b883a 	mov	r5,zero
81117a20:	1009883a 	mov	r4,r2
81117a24:	11221a40 	call	811221a4 <memset>
		xBuffer32[ucIL].bSent = FALSE;
81117a28:	e0ffff03 	ldbu	r3,-4(fp)
81117a2c:	00a045b4 	movhi	r2,33046
81117a30:	10a76704 	addi	r2,r2,-25188
81117a34:	18c00b24 	muli	r3,r3,44
81117a38:	10c5883a 	add	r2,r2,r3
81117a3c:	10800804 	addi	r2,r2,32
81117a40:	10000015 	stw	zero,0(r2)
		xBuffer32[ucIL].usiId = 0;
81117a44:	e0ffff03 	ldbu	r3,-4(fp)
81117a48:	00a045b4 	movhi	r2,33046
81117a4c:	10a76704 	addi	r2,r2,-25188
81117a50:	18c00b24 	muli	r3,r3,44
81117a54:	10c5883a 	add	r2,r2,r3
81117a58:	10800904 	addi	r2,r2,36
81117a5c:	1000000d 	sth	zero,0(r2)
		xBuffer32[ucIL].usiTimeOut = 0;
81117a60:	e0ffff03 	ldbu	r3,-4(fp)
81117a64:	00a045b4 	movhi	r2,33046
81117a68:	10a76704 	addi	r2,r2,-25188
81117a6c:	18c00b24 	muli	r3,r3,44
81117a70:	10c5883a 	add	r2,r2,r3
81117a74:	10800984 	addi	r2,r2,38
81117a78:	1000000d 	sth	zero,0(r2)
		xBuffer32[ucIL].ucNofRetries = 0;
81117a7c:	e0ffff03 	ldbu	r3,-4(fp)
81117a80:	00a045b4 	movhi	r2,33046
81117a84:	10a76704 	addi	r2,r2,-25188
81117a88:	18c00b24 	muli	r3,r3,44
81117a8c:	10c5883a 	add	r2,r2,r3
81117a90:	10800a04 	addi	r2,r2,40
81117a94:	10000005 	stb	zero,0(r2)
		xBuffer64[ucIL].usiId = 0;
		xBuffer64[ucIL].usiTimeOut = 0;
		xBuffer64[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_32; ucIL++)
81117a98:	e0bfff03 	ldbu	r2,-4(fp)
81117a9c:	10800044 	addi	r2,r2,1
81117aa0:	e0bfff05 	stb	r2,-4(fp)
81117aa4:	e0bfff03 	ldbu	r2,-4(fp)
81117aa8:	10800230 	cmpltui	r2,r2,8
81117aac:	103fd51e 	bne	r2,zero,81117a04 <__reset+0xfb0f7a04>
		xBuffer32[ucIL].usiTimeOut = 0;
		xBuffer32[ucIL].ucNofRetries = 0;
	}


	for( ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
81117ab0:	e03fff05 	stb	zero,-4(fp)
81117ab4:	00001b06 	br	81117b24 <vVariablesInitialization+0x2f0>
	{
		xPus[ucIL].bInUse = FALSE;
81117ab8:	e0ffff03 	ldbu	r3,-4(fp)
81117abc:	00a04574 	movhi	r2,33045
81117ac0:	10964304 	addi	r2,r2,22796
81117ac4:	18c01524 	muli	r3,r3,84
81117ac8:	10c5883a 	add	r2,r2,r3
81117acc:	10800104 	addi	r2,r2,4
81117ad0:	10000015 	stw	zero,0(r2)
		xPus[ucIL].ucNofValues = 0;
81117ad4:	e0ffff03 	ldbu	r3,-4(fp)
81117ad8:	00a04574 	movhi	r2,33045
81117adc:	10964304 	addi	r2,r2,22796
81117ae0:	18c01524 	muli	r3,r3,84
81117ae4:	10c5883a 	add	r2,r2,r3
81117ae8:	10800484 	addi	r2,r2,18
81117aec:	10000005 	stb	zero,0(r2)
		memset( xPus[ucIL].usiValues, 0, sizeof(xPus[ucIL].usiValues));
81117af0:	e0bfff03 	ldbu	r2,-4(fp)
81117af4:	10801524 	muli	r2,r2,84
81117af8:	10c00504 	addi	r3,r2,20
81117afc:	00a04574 	movhi	r2,33045
81117b00:	10964304 	addi	r2,r2,22796
81117b04:	1885883a 	add	r2,r3,r2
81117b08:	01801004 	movi	r6,64
81117b0c:	000b883a 	mov	r5,zero
81117b10:	1009883a 	mov	r4,r2
81117b14:	11221a40 	call	811221a4 <memset>
		xBuffer32[ucIL].usiTimeOut = 0;
		xBuffer32[ucIL].ucNofRetries = 0;
	}


	for( ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
81117b18:	e0bfff03 	ldbu	r2,-4(fp)
81117b1c:	10800044 	addi	r2,r2,1
81117b20:	e0bfff05 	stb	r2,-4(fp)
81117b24:	e0bfff03 	ldbu	r2,-4(fp)
81117b28:	10800130 	cmpltui	r2,r2,4
81117b2c:	103fe21e 	bne	r2,zero,81117ab8 <__reset+0xfb0f7ab8>

txSenderACKs xSenderACK[N_ACKS_SENDER];

*/

}
81117b30:	0001883a 	nop
81117b34:	e037883a 	mov	sp,fp
81117b38:	dfc00117 	ldw	ra,4(sp)
81117b3c:	df000017 	ldw	fp,0(sp)
81117b40:	dec00204 	addi	sp,sp,8
81117b44:	f800283a 	ret

81117b48 <main>:
void vPrintMemmoryPattern( TSimucam_MEB *xSimMebL );


/* Entry point */
int main(void)
{
81117b48:	defff704 	addi	sp,sp,-36
81117b4c:	de00012e 	bgeu	sp,et,81117b54 <main+0xc>
81117b50:	003b68fa 	trap	3
81117b54:	dfc00815 	stw	ra,32(sp)
81117b58:	df000715 	stw	fp,28(sp)
81117b5c:	df000704 	addi	fp,sp,28
	INT8U error_code;
	bool bIniSimucamStatus = FALSE;
81117b60:	e03ffe15 	stw	zero,-8(fp)
	
	OSInit();
81117b64:	113847c0 	call	8113847c <OSInit>

	/* Debug device initialization - JTAG USB */
	#ifdef DEBUG_ON
		fp = fopen(JTAG_UART_0_NAME, "r+");
81117b68:	01604574 	movhi	r5,33045
81117b6c:	29782a04 	addi	r5,r5,-8024
81117b70:	01204574 	movhi	r4,33045
81117b74:	21382b04 	addi	r4,r4,-8020
81117b78:	1120f5c0 	call	81120f5c <fopen>
81117b7c:	d0a06215 	stw	r2,-32376(gp)
	#endif	

	#ifdef DEBUG_ON
		debug(fp, "Main entry point.\n");
81117b80:	d0a06217 	ldw	r2,-32376(gp)
81117b84:	100f883a 	mov	r7,r2
81117b88:	01800484 	movi	r6,18
81117b8c:	01400044 	movi	r5,1
81117b90:	01204574 	movhi	r4,33045
81117b94:	21383004 	addi	r4,r4,-8000
81117b98:	11216400 	call	81121640 <fwrite>
	#endif

	/* Initialization of basic HW */
	vInitSimucamBasicHW();
81117b9c:	111dd380 	call	8111dd38 <vInitSimucamBasicHW>

	/* Test of some critical IPCores HW interfaces in the Simucam */
	bIniSimucamStatus = bTestSimucamCriticalHW();
81117ba0:	111e8f00 	call	8111e8f0 <bTestSimucamCriticalHW>
81117ba4:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81117ba8:	e0bffe17 	ldw	r2,-8(fp)
81117bac:	1000031e 	bne	r2,zero,81117bbc <main+0x74>
		vFailTestCriticasParts();
81117bb0:	111b4a00 	call	8111b4a0 <vFailTestCriticasParts>
		return -1;
81117bb4:	00bfffc4 	movi	r2,-1
81117bb8:	00004e06 	br	81117cf4 <main+0x1ac>
	}


	/* Log file Initialization in the SDCard */
	bIniSimucamStatus = bInitializeSDCard();
81117bbc:	111e4180 	call	8111e418 <bInitializeSDCard>
81117bc0:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81117bc4:	e0bffe17 	ldw	r2,-8(fp)
81117bc8:	1000031e 	bne	r2,zero,81117bd8 <main+0x90>
		vFailTestCriticasParts();
81117bcc:	111b4a00 	call	8111b4a0 <vFailTestCriticasParts>
		return -1;
81117bd0:	00bfffc4 	movi	r2,-1
81117bd4:	00004706 	br	81117cf4 <main+0x1ac>
	}

	bIniSimucamStatus = vLoadDefaultETHConf();
81117bd8:	111970c0 	call	8111970c <vLoadDefaultETHConf>
81117bdc:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81117be0:	e0bffe17 	ldw	r2,-8(fp)
81117be4:	1000091e 	bne	r2,zero,81117c0c <main+0xc4>
		/* Default configuration for eth connection loaded */
		#ifdef DEBUG_ON
			debug(fp, "Didn't load ETH configuration from SDCard. Default configuration will be loaded. \n");
81117be8:	d0a06217 	ldw	r2,-32376(gp)
81117bec:	100f883a 	mov	r7,r2
81117bf0:	01801484 	movi	r6,82
81117bf4:	01400044 	movi	r5,1
81117bf8:	01204574 	movhi	r4,33045
81117bfc:	21383504 	addi	r4,r4,-7980
81117c00:	11216400 	call	81121640 <fwrite>
		#endif
		return -1;
81117c04:	00bfffc4 	movi	r2,-1
81117c08:	00003a06 	br	81117cf4 <main+0x1ac>
	}

	bIniSimucamStatus = vLoadDebugConfs();
81117c0c:	111a4140 	call	8111a414 <vLoadDebugConfs>
81117c10:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81117c14:	e0bffe17 	ldw	r2,-8(fp)
81117c18:	1000091e 	bne	r2,zero,81117c40 <main+0xf8>
		/* Default configuration for eth connection loaded */
		#ifdef DEBUG_ON
			debug(fp, "Didn't load DEBUG configuration from SDCard. Default configuration will be loaded. \n");
81117c1c:	d0a06217 	ldw	r2,-32376(gp)
81117c20:	100f883a 	mov	r7,r2
81117c24:	01801504 	movi	r6,84
81117c28:	01400044 	movi	r5,1
81117c2c:	01204574 	movhi	r4,33045
81117c30:	21384a04 	addi	r4,r4,-7896
81117c34:	11216400 	call	81121640 <fwrite>
		#endif
		return -1;
81117c38:	00bfffc4 	movi	r2,-1
81117c3c:	00002d06 	br	81117cf4 <main+0x1ac>



	/* If debug is enable, will print the eth configuration in the*/
	#ifdef DEBUG_ON
		vShowEthConfig();
81117c40:	111a0e40 	call	8111a0e4 <vShowEthConfig>
	#endif


	/* This function creates all resources needed by the RTOS*/
	bIniSimucamStatus = bResourcesInitRTOS();
81117c44:	11173c40 	call	811173c4 <bResourcesInitRTOS>
81117c48:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81117c4c:	e0bffe17 	ldw	r2,-8(fp)
81117c50:	1000091e 	bne	r2,zero,81117c78 <main+0x130>
		/* Default configuration for eth connection loaded */
		debug(fp, "Can't allocate resources for RTOS. (exit) \n");
81117c54:	d0a06217 	ldw	r2,-32376(gp)
81117c58:	100f883a 	mov	r7,r2
81117c5c:	01800ac4 	movi	r6,43
81117c60:	01400044 	movi	r5,1
81117c64:	01204574 	movhi	r4,33045
81117c68:	21386004 	addi	r4,r4,-7808
81117c6c:	11216400 	call	81121640 <fwrite>
		return -1;
81117c70:	00bfffc4 	movi	r2,-1
81117c74:	00001f06 	br	81117cf4 <main+0x1ac>
	}

	/* Start the structure of control of the Simucam Application, including all FEEs instances */
	vSimucamStructureInit( &xSimMeb );
81117c78:	012045b4 	movhi	r4,33046
81117c7c:	2122b904 	addi	r4,r4,-29980
81117c80:	111de780 	call	8111de78 <vSimucamStructureInit>

	vVariablesInitialization();
81117c84:	11178340 	call	81117834 <vVariablesInitialization>

	bInitSync();
81117c88:	111e5cc0 	call	8111e5cc <bInitSync>

	vFillMemmoryPattern( &xSimMeb );
81117c8c:	012045b4 	movhi	r4,33046
81117c90:	2122b904 	addi	r4,r4,-29980
81117c94:	1117d080 	call	81117d08 <vFillMemmoryPattern>
									vInitialTask_stk,
									INITIALIZATION_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vInitialTask,
81117c98:	d8000415 	stw	zero,16(sp)
81117c9c:	d8000315 	stw	zero,12(sp)
81117ca0:	00810004 	movi	r2,1024
81117ca4:	d8800215 	stw	r2,8(sp)
81117ca8:	00a045b4 	movhi	r2,33046
81117cac:	10b1df04 	addi	r2,r2,-14468
81117cb0:	d8800115 	stw	r2,4(sp)
81117cb4:	00800044 	movi	r2,1
81117cb8:	d8800015 	stw	r2,0(sp)
81117cbc:	01c00044 	movi	r7,1
81117cc0:	01a045b4 	movhi	r6,33046
81117cc4:	31b5de04 	addi	r6,r6,-10376
81117cc8:	000b883a 	mov	r5,zero
81117ccc:	01204474 	movhi	r4,33041
81117cd0:	2108af04 	addi	r4,r4,8892
81117cd4:	113f22c0 	call	8113f22c <OSTaskCreateExt>
81117cd8:	e0bfff05 	stb	r2,-4(fp)
									NULL,
									0);
	#endif


	if ( error_code == OS_ERR_NONE ) {
81117cdc:	e0bfff03 	ldbu	r2,-4(fp)
81117ce0:	1000021e 	bne	r2,zero,81117cec <main+0x1a4>
		/* Start the scheduler (start the Real Time Application) */
		OSStart();
81117ce4:	11387ac0 	call	811387ac <OSStart>
81117ce8:	00000106 	br	81117cf0 <main+0x1a8>
	} else {
		/* Some error occurs in the creation of the Initialization Task */
		vFailInitialization();
81117cec:	111b88c0 	call	8111b88c <vFailInitialization>
	}
  
	return 0;
81117cf0:	0005883a 	mov	r2,zero
}
81117cf4:	e037883a 	mov	sp,fp
81117cf8:	dfc00117 	ldw	ra,4(sp)
81117cfc:	df000017 	ldw	fp,0(sp)
81117d00:	dec00204 	addi	sp,sp,8
81117d04:	f800283a 	ret

81117d08 <vFillMemmoryPattern>:


void vFillMemmoryPattern( TSimucam_MEB *xSimMebL ) {
81117d08:	defff604 	addi	sp,sp,-40
81117d0c:	de00012e 	bgeu	sp,et,81117d14 <vFillMemmoryPattern+0xc>
81117d10:	003b68fa 	trap	3
81117d14:	dfc00915 	stw	ra,36(sp)
81117d18:	df000815 	stw	fp,32(sp)
81117d1c:	df000804 	addi	fp,sp,32
81117d20:	e13fff15 	stw	r4,-4(fp)
	alt_u32 width_cols;
	alt_u32 height_rows;
	alt_u8 n_of_NFEE_in_mem;
	alt_u8 NFee_i;

	n_of_NFEE_in_mem = 1;
81117d24:	00800044 	movi	r2,1
81117d28:	e0bffcc5 	stb	r2,-13(fp)

#ifdef DEBUG_ON
	debug(fp, "Start to fill the memory with Pattern.\n");
81117d2c:	d0a06217 	ldw	r2,-32376(gp)
81117d30:	100f883a 	mov	r7,r2
81117d34:	018009c4 	movi	r6,39
81117d38:	01400044 	movi	r5,1
81117d3c:	01204574 	movhi	r4,33045
81117d40:	21386b04 	addi	r4,r4,-7764
81117d44:	11216400 	call	81121640 <fwrite>
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
81117d48:	e03ffa05 	stb	zero,-24(fp)
81117d4c:	00007606 	br	81117f28 <vFillMemmoryPattern+0x220>
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
81117d50:	e03ffc85 	stb	zero,-14(fp)
81117d54:	00006706 	br	81117ef4 <vFillMemmoryPattern+0x1ec>
			/* 4 CCDs */
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
81117d58:	e0bffc83 	ldbu	r2,-14(fp)
81117d5c:	e0ffff17 	ldw	r3,-4(fp)
81117d60:	10809624 	muli	r2,r2,600
81117d64:	1885883a 	add	r2,r3,r2
81117d68:	10804304 	addi	r2,r2,268
81117d6c:	1080000b 	ldhu	r2,0(r2)
81117d70:	10ffffcc 	andi	r3,r2,65535
81117d74:	e0bffc83 	ldbu	r2,-14(fp)
81117d78:	e13fff17 	ldw	r4,-4(fp)
81117d7c:	10809624 	muli	r2,r2,600
81117d80:	2085883a 	add	r2,r4,r2
81117d84:	10804204 	addi	r2,r2,264
81117d88:	1080000b 	ldhu	r2,0(r2)
81117d8c:	10bfffcc 	andi	r2,r2,65535
81117d90:	1885883a 	add	r2,r3,r2
81117d94:	e0bffd15 	stw	r2,-12(fp)
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
81117d98:	e0bffc83 	ldbu	r2,-14(fp)
81117d9c:	e0ffff17 	ldw	r3,-4(fp)
81117da0:	10809624 	muli	r2,r2,600
81117da4:	1885883a 	add	r2,r3,r2
81117da8:	10804284 	addi	r2,r2,266
81117dac:	1080000b 	ldhu	r2,0(r2)
81117db0:	10ffffcc 	andi	r3,r2,65535
81117db4:	e0bffc83 	ldbu	r2,-14(fp)
81117db8:	e13fff17 	ldw	r4,-4(fp)
81117dbc:	10809624 	muli	r2,r2,600
81117dc0:	2085883a 	add	r2,r4,r2
81117dc4:	10804184 	addi	r2,r2,262
81117dc8:	1080000b 	ldhu	r2,0(r2)
81117dcc:	10bfffcc 	andi	r2,r2,65535
81117dd0:	1887883a 	add	r3,r3,r2
81117dd4:	e0bffc83 	ldbu	r2,-14(fp)
81117dd8:	e13fff17 	ldw	r4,-4(fp)
81117ddc:	10809624 	muli	r2,r2,600
81117de0:	2085883a 	add	r2,r4,r2
81117de4:	10804104 	addi	r2,r2,260
81117de8:	1080000b 	ldhu	r2,0(r2)
81117dec:	10bfffcc 	andi	r2,r2,65535
81117df0:	1885883a 	add	r2,r3,r2
81117df4:	e0bffe15 	stw	r2,-8(fp)
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
81117df8:	e03ffc05 	stb	zero,-16(fp)
81117dfc:	00003706 	br	81117edc <vFillMemmoryPattern+0x1d4>

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
81117e00:	e03ffc45 	stb	zero,-15(fp)
81117e04:	00002606 	br	81117ea0 <vFillMemmoryPattern+0x198>
					if (ccd_side == 0){
81117e08:	e0bffc43 	ldbu	r2,-15(fp)
81117e0c:	10000b1e 	bne	r2,zero,81117e3c <vFillMemmoryPattern+0x134>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xLeft.ulOffsetAddr;
81117e10:	e0bffc83 	ldbu	r2,-14(fp)
81117e14:	e13ffc03 	ldbu	r4,-16(fp)
81117e18:	e0ffff17 	ldw	r3,-4(fp)
81117e1c:	21000624 	muli	r4,r4,24
81117e20:	10809624 	muli	r2,r2,600
81117e24:	2085883a 	add	r2,r4,r2
81117e28:	1885883a 	add	r2,r3,r2
81117e2c:	10801b04 	addi	r2,r2,108
81117e30:	10800017 	ldw	r2,0(r2)
81117e34:	e0bffb15 	stw	r2,-20(fp)
81117e38:	00000a06 	br	81117e64 <vFillMemmoryPattern+0x15c>
					} else {
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
81117e3c:	e0bffc83 	ldbu	r2,-14(fp)
81117e40:	e13ffc03 	ldbu	r4,-16(fp)
81117e44:	e0ffff17 	ldw	r3,-4(fp)
81117e48:	21000624 	muli	r4,r4,24
81117e4c:	10809624 	muli	r2,r2,600
81117e50:	2085883a 	add	r2,r4,r2
81117e54:	1885883a 	add	r2,r3,r2
81117e58:	10801e04 	addi	r2,r2,120
81117e5c:	10800017 	ldw	r2,0(r2)
81117e60:	e0bffb15 	stw	r2,-20(fp)
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
81117e64:	e0fffa03 	ldbu	r3,-24(fp)
81117e68:	e13ffc03 	ldbu	r4,-16(fp)
81117e6c:	e17ffc43 	ldbu	r5,-15(fp)
81117e70:	e0bffd17 	ldw	r2,-12(fp)
81117e74:	d8800115 	stw	r2,4(sp)
81117e78:	e0bffe17 	ldw	r2,-8(fp)
81117e7c:	d8800015 	stw	r2,0(sp)
81117e80:	280f883a 	mov	r7,r5
81117e84:	200d883a 	mov	r6,r4
81117e88:	e17ffb17 	ldw	r5,-20(fp)
81117e8c:	1809883a 	mov	r4,r3
81117e90:	111e23c0 	call	8111e23c <pattern_createPattern>
			/* 4 CCDs */
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
81117e94:	e0bffc43 	ldbu	r2,-15(fp)
81117e98:	10800044 	addi	r2,r2,1
81117e9c:	e0bffc45 	stb	r2,-15(fp)
81117ea0:	e0bffc43 	ldbu	r2,-15(fp)
81117ea4:	108000b0 	cmpltui	r2,r2,2
81117ea8:	103fd71e 	bne	r2,zero,81117e08 <__reset+0xfb0f7e08>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
				}
				#ifdef DEBUG_ON
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
81117eac:	d0a06217 	ldw	r2,-32376(gp)
81117eb0:	e0fffc83 	ldbu	r3,-14(fp)
81117eb4:	e13ffc03 	ldbu	r4,-16(fp)
81117eb8:	200f883a 	mov	r7,r4
81117ebc:	180d883a 	mov	r6,r3
81117ec0:	01604574 	movhi	r5,33045
81117ec4:	29787504 	addi	r5,r5,-7724
81117ec8:	1009883a 	mov	r4,r2
81117ecc:	1120fa40 	call	81120fa4 <fprintf>

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
			/* 4 CCDs */
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
81117ed0:	e0bffc03 	ldbu	r2,-16(fp)
81117ed4:	10800044 	addi	r2,r2,1
81117ed8:	e0bffc05 	stb	r2,-16(fp)
81117edc:	e0bffc03 	ldbu	r2,-16(fp)
81117ee0:	10800130 	cmpltui	r2,r2,4
81117ee4:	103fc61e 	bne	r2,zero,81117e00 <__reset+0xfb0f7e00>

	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
81117ee8:	e0bffc83 	ldbu	r2,-14(fp)
81117eec:	10800044 	addi	r2,r2,1
81117ef0:	e0bffc85 	stb	r2,-14(fp)
81117ef4:	e0fffc83 	ldbu	r3,-14(fp)
81117ef8:	e0bffcc3 	ldbu	r2,-13(fp)
81117efc:	18bf9636 	bltu	r3,r2,81117d58 <__reset+0xfb0f7d58>
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
				#endif
			}
		}
		#ifdef DEBUG_ON
			fprintf(fp, "Memory %i. \n",mem_number);
81117f00:	d0a06217 	ldw	r2,-32376(gp)
81117f04:	e0fffa03 	ldbu	r3,-24(fp)
81117f08:	180d883a 	mov	r6,r3
81117f0c:	01604574 	movhi	r5,33045
81117f10:	29787a04 	addi	r5,r5,-7704
81117f14:	1009883a 	mov	r4,r2
81117f18:	1120fa40 	call	81120fa4 <fprintf>
	debug(fp, "Start to fill the memory with Pattern.\n");
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
81117f1c:	e0bffa03 	ldbu	r2,-24(fp)
81117f20:	10800044 	addi	r2,r2,1
81117f24:	e0bffa05 	stb	r2,-24(fp)
81117f28:	e0bffa03 	ldbu	r2,-24(fp)
81117f2c:	108000b0 	cmpltui	r2,r2,2
81117f30:	103f871e 	bne	r2,zero,81117d50 <__reset+0xfb0f7d50>
			fprintf(fp, "Memory %i. \n",mem_number);
		#endif
	}

#ifdef DEBUG_ON
	debug(fp, "Memory Filled. \n");
81117f34:	d0a06217 	ldw	r2,-32376(gp)
81117f38:	100f883a 	mov	r7,r2
81117f3c:	01800404 	movi	r6,16
81117f40:	01400044 	movi	r5,1
81117f44:	01204574 	movhi	r4,33045
81117f48:	21387e04 	addi	r4,r4,-7688
81117f4c:	11216400 	call	81121640 <fwrite>
#endif


}
81117f50:	0001883a 	nop
81117f54:	e037883a 	mov	sp,fp
81117f58:	dfc00117 	ldw	ra,4(sp)
81117f5c:	df000017 	ldw	fp,0(sp)
81117f60:	dec00204 	addi	sp,sp,8
81117f64:	f800283a 	ret

81117f68 <vPrintMemmoryPattern>:

void vPrintMemmoryPattern( TSimucam_MEB *xSimMebL ) {
81117f68:	defff604 	addi	sp,sp,-40
81117f6c:	de00012e 	bgeu	sp,et,81117f74 <vPrintMemmoryPattern+0xc>
81117f70:	003b68fa 	trap	3
81117f74:	dfc00915 	stw	ra,36(sp)
81117f78:	df000815 	stw	fp,32(sp)
81117f7c:	df000804 	addi	fp,sp,32
81117f80:	e13fff15 	stw	r4,-4(fp)
	alt_u32 width_cols;
	alt_u32 height_rows;
	alt_u8 n_of_NFEE_in_mem;
	alt_u8 NFee_i;

	n_of_NFEE_in_mem = 1;
81117f84:	00800044 	movi	r2,1
81117f88:	e0bffcc5 	stb	r2,-13(fp)

#ifdef DEBUG_ON
	debug(fp, "Start to fill the memory with Pattern.\n");
81117f8c:	d0a06217 	ldw	r2,-32376(gp)
81117f90:	100f883a 	mov	r7,r2
81117f94:	018009c4 	movi	r6,39
81117f98:	01400044 	movi	r5,1
81117f9c:	01204574 	movhi	r4,33045
81117fa0:	21386b04 	addi	r4,r4,-7764
81117fa4:	11216400 	call	81121640 <fwrite>
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
81117fa8:	e03ffa05 	stb	zero,-24(fp)
81117fac:	00007606 	br	81118188 <vPrintMemmoryPattern+0x220>
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
81117fb0:	e03ffc85 	stb	zero,-14(fp)
81117fb4:	00006706 	br	81118154 <vPrintMemmoryPattern+0x1ec>
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
81117fb8:	e0bffc83 	ldbu	r2,-14(fp)
81117fbc:	e0ffff17 	ldw	r3,-4(fp)
81117fc0:	10809624 	muli	r2,r2,600
81117fc4:	1885883a 	add	r2,r3,r2
81117fc8:	10804304 	addi	r2,r2,268
81117fcc:	1080000b 	ldhu	r2,0(r2)
81117fd0:	10ffffcc 	andi	r3,r2,65535
81117fd4:	e0bffc83 	ldbu	r2,-14(fp)
81117fd8:	e13fff17 	ldw	r4,-4(fp)
81117fdc:	10809624 	muli	r2,r2,600
81117fe0:	2085883a 	add	r2,r4,r2
81117fe4:	10804204 	addi	r2,r2,264
81117fe8:	1080000b 	ldhu	r2,0(r2)
81117fec:	10bfffcc 	andi	r2,r2,65535
81117ff0:	1885883a 	add	r2,r3,r2
81117ff4:	e0bffd15 	stw	r2,-12(fp)
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
81117ff8:	e0bffc83 	ldbu	r2,-14(fp)
81117ffc:	e0ffff17 	ldw	r3,-4(fp)
81118000:	10809624 	muli	r2,r2,600
81118004:	1885883a 	add	r2,r3,r2
81118008:	10804284 	addi	r2,r2,266
8111800c:	1080000b 	ldhu	r2,0(r2)
81118010:	10ffffcc 	andi	r3,r2,65535
81118014:	e0bffc83 	ldbu	r2,-14(fp)
81118018:	e13fff17 	ldw	r4,-4(fp)
8111801c:	10809624 	muli	r2,r2,600
81118020:	2085883a 	add	r2,r4,r2
81118024:	10804184 	addi	r2,r2,262
81118028:	1080000b 	ldhu	r2,0(r2)
8111802c:	10bfffcc 	andi	r2,r2,65535
81118030:	1887883a 	add	r3,r3,r2
81118034:	e0bffc83 	ldbu	r2,-14(fp)
81118038:	e13fff17 	ldw	r4,-4(fp)
8111803c:	10809624 	muli	r2,r2,600
81118040:	2085883a 	add	r2,r4,r2
81118044:	10804104 	addi	r2,r2,260
81118048:	1080000b 	ldhu	r2,0(r2)
8111804c:	10bfffcc 	andi	r2,r2,65535
81118050:	1885883a 	add	r2,r3,r2
81118054:	e0bffe15 	stw	r2,-8(fp)
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
81118058:	e03ffc05 	stb	zero,-16(fp)
8111805c:	00003706 	br	8111813c <vPrintMemmoryPattern+0x1d4>

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
81118060:	e03ffc45 	stb	zero,-15(fp)
81118064:	00002606 	br	81118100 <vPrintMemmoryPattern+0x198>
					if (ccd_side == 0){
81118068:	e0bffc43 	ldbu	r2,-15(fp)
8111806c:	10000b1e 	bne	r2,zero,8111809c <vPrintMemmoryPattern+0x134>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xLeft.ulOffsetAddr;
81118070:	e0bffc83 	ldbu	r2,-14(fp)
81118074:	e13ffc03 	ldbu	r4,-16(fp)
81118078:	e0ffff17 	ldw	r3,-4(fp)
8111807c:	21000624 	muli	r4,r4,24
81118080:	10809624 	muli	r2,r2,600
81118084:	2085883a 	add	r2,r4,r2
81118088:	1885883a 	add	r2,r3,r2
8111808c:	10801b04 	addi	r2,r2,108
81118090:	10800017 	ldw	r2,0(r2)
81118094:	e0bffb15 	stw	r2,-20(fp)
81118098:	00000a06 	br	811180c4 <vPrintMemmoryPattern+0x15c>
					} else {
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
8111809c:	e0bffc83 	ldbu	r2,-14(fp)
811180a0:	e13ffc03 	ldbu	r4,-16(fp)
811180a4:	e0ffff17 	ldw	r3,-4(fp)
811180a8:	21000624 	muli	r4,r4,24
811180ac:	10809624 	muli	r2,r2,600
811180b0:	2085883a 	add	r2,r4,r2
811180b4:	1885883a 	add	r2,r3,r2
811180b8:	10801e04 	addi	r2,r2,120
811180bc:	10800017 	ldw	r2,0(r2)
811180c0:	e0bffb15 	stw	r2,-20(fp)
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
811180c4:	e0fffa03 	ldbu	r3,-24(fp)
811180c8:	e13ffc03 	ldbu	r4,-16(fp)
811180cc:	e17ffc43 	ldbu	r5,-15(fp)
811180d0:	e0bffe17 	ldw	r2,-8(fp)
811180d4:	d8800115 	stw	r2,4(sp)
811180d8:	e0bffd17 	ldw	r2,-12(fp)
811180dc:	d8800015 	stw	r2,0(sp)
811180e0:	280f883a 	mov	r7,r5
811180e4:	200d883a 	mov	r6,r4
811180e8:	e17ffb17 	ldw	r5,-20(fp)
811180ec:	1809883a 	mov	r4,r3
811180f0:	111e23c0 	call	8111e23c <pattern_createPattern>
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
811180f4:	e0bffc43 	ldbu	r2,-15(fp)
811180f8:	10800044 	addi	r2,r2,1
811180fc:	e0bffc45 	stb	r2,-15(fp)
81118100:	e0bffc43 	ldbu	r2,-15(fp)
81118104:	108000b0 	cmpltui	r2,r2,2
81118108:	103fd71e 	bne	r2,zero,81118068 <__reset+0xfb0f8068>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
				}
				#ifdef DEBUG_ON
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
8111810c:	d0a06217 	ldw	r2,-32376(gp)
81118110:	e0fffc83 	ldbu	r3,-14(fp)
81118114:	e13ffc03 	ldbu	r4,-16(fp)
81118118:	200f883a 	mov	r7,r4
8111811c:	180d883a 	mov	r6,r3
81118120:	01604574 	movhi	r5,33045
81118124:	29787504 	addi	r5,r5,-7724
81118128:	1009883a 	mov	r4,r2
8111812c:	1120fa40 	call	81120fa4 <fprintf>

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
81118130:	e0bffc03 	ldbu	r2,-16(fp)
81118134:	10800044 	addi	r2,r2,1
81118138:	e0bffc05 	stb	r2,-16(fp)
8111813c:	e0bffc03 	ldbu	r2,-16(fp)
81118140:	10800130 	cmpltui	r2,r2,4
81118144:	103fc61e 	bne	r2,zero,81118060 <__reset+0xfb0f8060>

	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
81118148:	e0bffc83 	ldbu	r2,-14(fp)
8111814c:	10800044 	addi	r2,r2,1
81118150:	e0bffc85 	stb	r2,-14(fp)
81118154:	e0fffc83 	ldbu	r3,-14(fp)
81118158:	e0bffcc3 	ldbu	r2,-13(fp)
8111815c:	18bf9636 	bltu	r3,r2,81117fb8 <__reset+0xfb0f7fb8>
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
				#endif
			}
		}
		#ifdef DEBUG_ON
			fprintf(fp, "Memory %i. \n",mem_number);
81118160:	d0a06217 	ldw	r2,-32376(gp)
81118164:	e0fffa03 	ldbu	r3,-24(fp)
81118168:	180d883a 	mov	r6,r3
8111816c:	01604574 	movhi	r5,33045
81118170:	29787a04 	addi	r5,r5,-7704
81118174:	1009883a 	mov	r4,r2
81118178:	1120fa40 	call	81120fa4 <fprintf>
	debug(fp, "Start to fill the memory with Pattern.\n");
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
8111817c:	e0bffa03 	ldbu	r2,-24(fp)
81118180:	10800044 	addi	r2,r2,1
81118184:	e0bffa05 	stb	r2,-24(fp)
81118188:	e0bffa03 	ldbu	r2,-24(fp)
8111818c:	108000b0 	cmpltui	r2,r2,2
81118190:	103f871e 	bne	r2,zero,81117fb0 <__reset+0xfb0f7fb0>
			fprintf(fp, "Memory %i. \n",mem_number);
		#endif
	}

#ifdef DEBUG_ON
	debug(fp, "Memory Filled. \n");
81118194:	d0a06217 	ldw	r2,-32376(gp)
81118198:	100f883a 	mov	r7,r2
8111819c:	01800404 	movi	r6,16
811181a0:	01400044 	movi	r5,1
811181a4:	01204574 	movhi	r4,33045
811181a8:	21387e04 	addi	r4,r4,-7688
811181ac:	11216400 	call	81121640 <fwrite>
#endif


}
811181b0:	0001883a 	nop
811181b4:	e037883a 	mov	sp,fp
811181b8:	dfc00117 	ldw	ra,4(sp)
811181bc:	df000017 	ldw	fp,0(sp)
811181c0:	dec00204 	addi	sp,sp,8
811181c4:	f800283a 	ret

811181c8 <vCCDLoadDefaultValues>:
 */

#include "ccd.h"


void vCCDLoadDefaultValues( TCcdInfos *ccdDef ) {
811181c8:	defffd04 	addi	sp,sp,-12
811181cc:	de00012e 	bgeu	sp,et,811181d4 <vCCDLoadDefaultValues+0xc>
811181d0:	003b68fa 	trap	3
811181d4:	dfc00215 	stw	ra,8(sp)
811181d8:	df000115 	stw	fp,4(sp)
811181dc:	df000104 	addi	fp,sp,4
811181e0:	e13fff15 	stw	r4,-4(fp)
	ccdDef->usiOLN = 30;
	ccdDef->usiHalfWidth = 2255;
	ccdDef->usiSOverscanN = 15;
	ccdDef->usiSPrescanN = 25;
*/
	ccdDef->usiHeight = xDefaults.usiRows;
811181e4:	00a045b4 	movhi	r2,33046
811181e8:	1099c904 	addi	r2,r2,26404
811181ec:	10c0060b 	ldhu	r3,24(r2)
811181f0:	e0bfff17 	ldw	r2,-4(fp)
811181f4:	10c0020d 	sth	r3,8(r2)
	ccdDef->usiOLN = xDefaults.usiOLN;
811181f8:	00a045b4 	movhi	r2,33046
811181fc:	1099c904 	addi	r2,r2,26404
81118200:	10c0050b 	ldhu	r3,20(r2)
81118204:	e0bfff17 	ldw	r2,-4(fp)
81118208:	10c0010d 	sth	r3,4(r2)
	ccdDef->usiHalfWidth = xDefaults.usiCols;
8111820c:	00a045b4 	movhi	r2,33046
81118210:	1099c904 	addi	r2,r2,26404
81118214:	10c0058b 	ldhu	r3,22(r2)
81118218:	e0bfff17 	ldw	r2,-4(fp)
8111821c:	10c0018d 	sth	r3,6(r2)
	ccdDef->usiSOverscanN = xDefaults.usiOverScanSerial;
81118220:	00a045b4 	movhi	r2,33046
81118224:	1099c904 	addi	r2,r2,26404
81118228:	10c0040b 	ldhu	r3,16(r2)
8111822c:	e0bfff17 	ldw	r2,-4(fp)
81118230:	10c0008d 	sth	r3,2(r2)
	ccdDef->usiSPrescanN = xDefaults.usiPreScanSerial;
81118234:	00a045b4 	movhi	r2,33046
81118238:	1099c904 	addi	r2,r2,26404
8111823c:	10c0048b 	ldhu	r3,18(r2)
81118240:	e0bfff17 	ldw	r2,-4(fp)
81118244:	10c0000d 	sth	r3,0(r2)

#ifdef DEBUG_ON
	//fprintf(fp,"\n    i: %u ",incrementador);
	fprintf(fp,"\nusiHeight %hu\n", ccdDef->usiHeight);
81118248:	d0e06217 	ldw	r3,-32376(gp)
8111824c:	e0bfff17 	ldw	r2,-4(fp)
81118250:	1080020b 	ldhu	r2,8(r2)
81118254:	10bfffcc 	andi	r2,r2,65535
81118258:	100d883a 	mov	r6,r2
8111825c:	01604574 	movhi	r5,33045
81118260:	29788304 	addi	r5,r5,-7668
81118264:	1809883a 	mov	r4,r3
81118268:	1120fa40 	call	81120fa4 <fprintf>
	fprintf(fp,"usiOLN %hu\n", ccdDef->usiOLN);
8111826c:	d0e06217 	ldw	r3,-32376(gp)
81118270:	e0bfff17 	ldw	r2,-4(fp)
81118274:	1080010b 	ldhu	r2,4(r2)
81118278:	10bfffcc 	andi	r2,r2,65535
8111827c:	100d883a 	mov	r6,r2
81118280:	01604574 	movhi	r5,33045
81118284:	29788704 	addi	r5,r5,-7652
81118288:	1809883a 	mov	r4,r3
8111828c:	1120fa40 	call	81120fa4 <fprintf>
	fprintf(fp,"usiHalfWidth %hu\n", ccdDef->usiHalfWidth);
81118290:	d0e06217 	ldw	r3,-32376(gp)
81118294:	e0bfff17 	ldw	r2,-4(fp)
81118298:	1080018b 	ldhu	r2,6(r2)
8111829c:	10bfffcc 	andi	r2,r2,65535
811182a0:	100d883a 	mov	r6,r2
811182a4:	01604574 	movhi	r5,33045
811182a8:	29788a04 	addi	r5,r5,-7640
811182ac:	1809883a 	mov	r4,r3
811182b0:	1120fa40 	call	81120fa4 <fprintf>
	fprintf(fp,"usiSOverscanN %hu\n", ccdDef->usiSOverscanN);
811182b4:	d0e06217 	ldw	r3,-32376(gp)
811182b8:	e0bfff17 	ldw	r2,-4(fp)
811182bc:	1080008b 	ldhu	r2,2(r2)
811182c0:	10bfffcc 	andi	r2,r2,65535
811182c4:	100d883a 	mov	r6,r2
811182c8:	01604574 	movhi	r5,33045
811182cc:	29788f04 	addi	r5,r5,-7620
811182d0:	1809883a 	mov	r4,r3
811182d4:	1120fa40 	call	81120fa4 <fprintf>
	fprintf(fp,"usiSPrescanN %hu\n",  ccdDef->usiSPrescanN);
811182d8:	d0e06217 	ldw	r3,-32376(gp)
811182dc:	e0bfff17 	ldw	r2,-4(fp)
811182e0:	1080000b 	ldhu	r2,0(r2)
811182e4:	10bfffcc 	andi	r2,r2,65535
811182e8:	100d883a 	mov	r6,r2
811182ec:	01604574 	movhi	r5,33045
811182f0:	29789404 	addi	r5,r5,-7600
811182f4:	1809883a 	mov	r4,r3
811182f8:	1120fa40 	call	81120fa4 <fprintf>
#endif

}
811182fc:	0001883a 	nop
81118300:	e037883a 	mov	sp,fp
81118304:	dfc00117 	ldw	ra,4(sp)
81118308:	df000017 	ldw	fp,0(sp)
8111830c:	dec00204 	addi	sp,sp,8
81118310:	f800283a 	ret

81118314 <vCCDChangeValues>:

/* Only in NFEE_CONFIG of NFEE_STAND_BY */
/* Used to change de values of the CCD definitions from any source */
void vCCDChangeValues( TCcdInfos *ccdDef, unsigned short int usiHeight, unsigned short int usiOLN, unsigned short int usiHalfWidth,
                                unsigned short int usiSOverscanN, unsigned short int usiSPrescanN  ) {
81118314:	defff904 	addi	sp,sp,-28
81118318:	de00012e 	bgeu	sp,et,81118320 <vCCDChangeValues+0xc>
8111831c:	003b68fa 	trap	3
81118320:	df000615 	stw	fp,24(sp)
81118324:	df000604 	addi	fp,sp,24
81118328:	e13ffa15 	stw	r4,-24(fp)
8111832c:	2811883a 	mov	r8,r5
81118330:	300b883a 	mov	r5,r6
81118334:	3809883a 	mov	r4,r7
81118338:	e0c00117 	ldw	r3,4(fp)
8111833c:	e0800217 	ldw	r2,8(fp)
81118340:	e23ffb0d 	sth	r8,-20(fp)
81118344:	e17ffc0d 	sth	r5,-16(fp)
81118348:	e13ffd0d 	sth	r4,-12(fp)
8111834c:	e0fffe0d 	sth	r3,-8(fp)
81118350:	e0bfff0d 	sth	r2,-4(fp)

	ccdDef->usiHeight = usiHeight;
81118354:	e0bffa17 	ldw	r2,-24(fp)
81118358:	e0fffb0b 	ldhu	r3,-20(fp)
8111835c:	10c0020d 	sth	r3,8(r2)
	ccdDef->usiOLN = usiOLN;
81118360:	e0bffa17 	ldw	r2,-24(fp)
81118364:	e0fffc0b 	ldhu	r3,-16(fp)
81118368:	10c0010d 	sth	r3,4(r2)
	ccdDef->usiHalfWidth = usiHalfWidth;
8111836c:	e0bffa17 	ldw	r2,-24(fp)
81118370:	e0fffd0b 	ldhu	r3,-12(fp)
81118374:	10c0018d 	sth	r3,6(r2)
	ccdDef->usiSOverscanN = usiSOverscanN;
81118378:	e0bffa17 	ldw	r2,-24(fp)
8111837c:	e0fffe0b 	ldhu	r3,-8(fp)
81118380:	10c0008d 	sth	r3,2(r2)
	ccdDef->usiSPrescanN = usiSPrescanN;
81118384:	e0bffa17 	ldw	r2,-24(fp)
81118388:	e0ffff0b 	ldhu	r3,-4(fp)
8111838c:	10c0000d 	sth	r3,0(r2)
}
81118390:	0001883a 	nop
81118394:	e037883a 	mov	sp,fp
81118398:	df000017 	ldw	fp,0(sp)
8111839c:	dec00104 	addi	sp,sp,4
811183a0:	f800283a 	ret

811183a4 <bSendUART128v2>:
#include "communication_utils.h"


/* Make sure that there is only 127 characters to send */
/* Always, ALWAYS send only an char[128] that you first did a memset(cBuffer,0,128), before put some string on it. */
bool bSendUART128v2 ( char *cBuffer, short int siIdMessage ) {
811183a4:	defff904 	addi	sp,sp,-28
811183a8:	de00012e 	bgeu	sp,et,811183b0 <bSendUART128v2+0xc>
811183ac:	003b68fa 	trap	3
811183b0:	dfc00615 	stw	ra,24(sp)
811183b4:	df000515 	stw	fp,20(sp)
811183b8:	df000504 	addi	fp,sp,20
811183bc:	e13ffe15 	stw	r4,-8(fp)
811183c0:	2805883a 	mov	r2,r5
811183c4:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;;
811183c8:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
811183cc:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
811183d0:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
811183d4:	e03ffc15 	stw	zero,-16(fp)

	OSSemPend(xSemCountBuffer128, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
811183d8:	d0a06317 	ldw	r2,-32372(gp)
811183dc:	e0fffd04 	addi	r3,fp,-12
811183e0:	180d883a 	mov	r6,r3
811183e4:	01400504 	movi	r5,20
811183e8:	1009883a 	mov	r4,r2
811183ec:	113e4c00 	call	8113e4c0 <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
811183f0:	e0bffd03 	ldbu	r2,-12(fp)
811183f4:	10803fcc 	andi	r2,r2,255
811183f8:	10000326 	beq	r2,zero,81118408 <bSendUART128v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
811183fc:	111baf40 	call	8111baf4 <vFailGetCountSemaphorexBuffer128>
		return bSuccessL;
81118400:	e0bffc17 	ldw	r2,-16(fp)
81118404:	00009e06 	br	81118680 <bSendUART128v2+0x2dc>

	/* ---> At this point we know that there is some space in the buffer */


	/* Need to get the Mutex that protects xBuffer128 */
	OSMutexPend(xMutexBuffer128, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
81118408:	d0a06e17 	ldw	r2,-32328(gp)
8111840c:	e0fffd04 	addi	r3,fp,-12
81118410:	180d883a 	mov	r6,r3
81118414:	01400104 	movi	r5,4
81118418:	1009883a 	mov	r4,r2
8111841c:	113c4b40 	call	8113c4b4 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81118420:	e0bffd03 	ldbu	r2,-12(fp)
81118424:	10803fcc 	andi	r2,r2,255
81118428:	10001126 	beq	r2,zero,81118470 <bSendUART128v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer128 that protect xBuffer128. (bSendUART128v2)\n");
8111842c:	d0a06217 	ldw	r2,-32376(gp)
81118430:	100f883a 	mov	r7,r2
81118434:	01801484 	movi	r6,82
81118438:	01400044 	movi	r5,1
8111843c:	01204574 	movhi	r4,33045
81118440:	21389904 	addi	r4,r4,-7580
81118444:	11216400 	call	81121640 <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer128);
81118448:	d0a06317 	ldw	r2,-32372(gp)
8111844c:	1009883a 	mov	r4,r2
81118450:	113e8480 	call	8113e848 <OSSemPost>
81118454:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
81118458:	e0bffd03 	ldbu	r2,-12(fp)
8111845c:	10803fcc 	andi	r2,r2,255
81118460:	10000126 	beq	r2,zero,81118468 <bSendUART128v2+0xc4>
			vFailSetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
81118464:	111ba8c0 	call	8111ba8c <vFailSetCountSemaphorexBuffer128>
		}

		return bSuccessL;
81118468:	e0bffc17 	ldw	r2,-16(fp)
8111846c:	00008406 	br	81118680 <bSendUART128v2+0x2dc>
	/* ---> At this point we Have the mutex of the xBuffer128, and we can use it freely */


	
	/* Search for space */
	for( ucIL = 0; ucIL < N_128; ucIL++)
81118470:	e03ffb05 	stb	zero,-20(fp)
81118474:	00004306 	br	81118584 <bSendUART128v2+0x1e0>
	{
		if ( xInUseRetrans.b128[ucIL] == FALSE ) {
81118478:	e0fffb03 	ldbu	r3,-20(fp)
8111847c:	00a045b4 	movhi	r2,33046
81118480:	10b9e704 	addi	r2,r2,-6244
81118484:	18c7883a 	add	r3,r3,r3
81118488:	18c7883a 	add	r3,r3,r3
8111848c:	10c5883a 	add	r2,r2,r3
81118490:	10800017 	ldw	r2,0(r2)
81118494:	1000381e 	bne	r2,zero,81118578 <bSendUART128v2+0x1d4>
			/* Clear the buffer */
			memset(xBuffer128[ucIL].buffer, 0, 128);
81118498:	e0bffb03 	ldbu	r2,-20(fp)
8111849c:	10c02324 	muli	r3,r2,140
811184a0:	00a045b4 	movhi	r2,33046
811184a4:	10ba0504 	addi	r2,r2,-6124
811184a8:	1885883a 	add	r2,r3,r2
811184ac:	01802004 	movi	r6,128
811184b0:	000b883a 	mov	r5,zero
811184b4:	1009883a 	mov	r4,r2
811184b8:	11221a40 	call	811221a4 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer128[ucIL].buffer, cBuffer, 127);
811184bc:	e0bffb03 	ldbu	r2,-20(fp)
811184c0:	10c02324 	muli	r3,r2,140
811184c4:	00a045b4 	movhi	r2,33046
811184c8:	10ba0504 	addi	r2,r2,-6124
811184cc:	1885883a 	add	r2,r3,r2
811184d0:	01801fc4 	movi	r6,127
811184d4:	e17ffe17 	ldw	r5,-8(fp)
811184d8:	1009883a 	mov	r4,r2
811184dc:	11220540 	call	81122054 <memcpy>
			xBuffer128[ucIL].usiId = siIdMessage;
811184e0:	e13ffb03 	ldbu	r4,-20(fp)
811184e4:	e0ffff0b 	ldhu	r3,-4(fp)
811184e8:	00a045b4 	movhi	r2,33046
811184ec:	10ba0504 	addi	r2,r2,-6124
811184f0:	21002324 	muli	r4,r4,140
811184f4:	1105883a 	add	r2,r2,r4
811184f8:	10802104 	addi	r2,r2,132
811184fc:	10c0000d 	sth	r3,0(r2)
			xBuffer128[ucIL].ucNofRetries = 0;
81118500:	e0fffb03 	ldbu	r3,-20(fp)
81118504:	00a045b4 	movhi	r2,33046
81118508:	10ba0504 	addi	r2,r2,-6124
8111850c:	18c02324 	muli	r3,r3,140
81118510:	10c5883a 	add	r2,r2,r3
81118514:	10802204 	addi	r2,r2,136
81118518:	10000005 	stb	zero,0(r2)
			xBuffer128[ucIL].usiTimeOut = 0;
8111851c:	e0fffb03 	ldbu	r3,-20(fp)
81118520:	00a045b4 	movhi	r2,33046
81118524:	10ba0504 	addi	r2,r2,-6124
81118528:	18c02324 	muli	r3,r3,140
8111852c:	10c5883a 	add	r2,r2,r3
81118530:	10802184 	addi	r2,r2,134
81118534:	1000000d 	sth	zero,0(r2)
			xBuffer128[ucIL].bSent = FALSE;
81118538:	e0fffb03 	ldbu	r3,-20(fp)
8111853c:	00a045b4 	movhi	r2,33046
81118540:	10ba0504 	addi	r2,r2,-6124
81118544:	18c02324 	muli	r3,r3,140
81118548:	10c5883a 	add	r2,r2,r3
8111854c:	10802004 	addi	r2,r2,128
81118550:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b128[ucIL] = TRUE;
81118554:	e0fffb03 	ldbu	r3,-20(fp)
81118558:	00a045b4 	movhi	r2,33046
8111855c:	10b9e704 	addi	r2,r2,-6244
81118560:	18c7883a 	add	r3,r3,r3
81118564:	18c7883a 	add	r3,r3,r3
81118568:	10c5883a 	add	r2,r2,r3
8111856c:	00c00044 	movi	r3,1
81118570:	10c00015 	stw	r3,0(r2)
			break;
81118574:	00000606 	br	81118590 <bSendUART128v2+0x1ec>
	/* ---> At this point we Have the mutex of the xBuffer128, and we can use it freely */


	
	/* Search for space */
	for( ucIL = 0; ucIL < N_128; ucIL++)
81118578:	e0bffb03 	ldbu	r2,-20(fp)
8111857c:	10800044 	addi	r2,r2,1
81118580:	e0bffb05 	stb	r2,-20(fp)
81118584:	e0bffb03 	ldbu	r2,-20(fp)
81118588:	108001b0 	cmpltui	r2,r2,6
8111858c:	103fba1e 	bne	r2,zero,81118478 <__reset+0xfb0f8478>
			xInUseRetrans.b128[ucIL] = TRUE;
			break;
		}
	}

	if ( ucIL >= N_128 ) {
81118590:	e0bffb03 	ldbu	r2,-20(fp)
81118594:	108001b0 	cmpltui	r2,r2,6
81118598:	1000091e 	bne	r2,zero,811185c0 <bSendUART128v2+0x21c>
		ucErrorCode = OSSemPost(xSemCountBuffer128);
8111859c:	d0a06317 	ldw	r2,-32372(gp)
811185a0:	1009883a 	mov	r4,r2
811185a4:	113e8480 	call	8113e848 <OSSemPost>
811185a8:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer128);
811185ac:	d0a06e17 	ldw	r2,-32328(gp)
811185b0:	1009883a 	mov	r4,r2
811185b4:	113ca580 	call	8113ca58 <OSMutexPost>
		return bSuccessL;
811185b8:	e0bffc17 	ldw	r2,-16(fp)
811185bc:	00003006 	br	81118680 <bSendUART128v2+0x2dc>
	}

	bSuccessL = TRUE;
811185c0:	00800044 	movi	r2,1
811185c4:	e0bffc15 	stw	r2,-16(fp)
	SemCount128--; /* Sure that you get the semaphore */
811185c8:	d0a07543 	ldbu	r2,-32299(gp)
811185cc:	10bfffc4 	addi	r2,r2,-1
811185d0:	d0a07545 	stb	r2,-32299(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
811185d4:	d0a07417 	ldw	r2,-32304(gp)
811185d8:	e0fffd04 	addi	r3,fp,-12
811185dc:	180d883a 	mov	r6,r3
811185e0:	01400084 	movi	r5,2
811185e4:	1009883a 	mov	r4,r2
811185e8:	113c4b40 	call	8113c4b4 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
811185ec:	e0bffd03 	ldbu	r2,-12(fp)
811185f0:	10803fcc 	andi	r2,r2,255
811185f4:	10000c26 	beq	r2,zero,81118628 <bSendUART128v2+0x284>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART128v2)\n");
811185f8:	d0a06217 	ldw	r2,-32376(gp)
811185fc:	100f883a 	mov	r7,r2
81118600:	01801c04 	movi	r6,112
81118604:	01400044 	movi	r5,1
81118608:	01204574 	movhi	r4,33045
8111860c:	2138ae04 	addi	r4,r4,-7496
81118610:	11216400 	call	81121640 <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer128 */
		OSMutexPost(xMutexBuffer128); /* Free the Mutex after use the xBuffer128*/
81118614:	d0a06e17 	ldw	r2,-32328(gp)
81118618:	1009883a 	mov	r4,r2
8111861c:	113ca580 	call	8113ca58 <OSMutexPost>
		return bSuccessL;
81118620:	e0bffc17 	ldw	r2,-16(fp)
81118624:	00001606 	br	81118680 <bSendUART128v2+0x2dc>


	/* ---> At this point we have all resources to send the message */


	puts(xBuffer128[ucIL].buffer);
81118628:	e0bffb03 	ldbu	r2,-20(fp)
8111862c:	10c02324 	muli	r3,r2,140
81118630:	00a045b4 	movhi	r2,33046
81118634:	10ba0504 	addi	r2,r2,-6124
81118638:	1885883a 	add	r2,r3,r2
8111863c:	1009883a 	mov	r4,r2
81118640:	11225f00 	call	811225f0 <puts>
	xBuffer128[ucIL].bSent = TRUE;
81118644:	e0fffb03 	ldbu	r3,-20(fp)
81118648:	00a045b4 	movhi	r2,33046
8111864c:	10ba0504 	addi	r2,r2,-6124
81118650:	18c02324 	muli	r3,r3,140
81118654:	10c5883a 	add	r2,r2,r3
81118658:	10802004 	addi	r2,r2,128
8111865c:	00c00044 	movi	r3,1
81118660:	10c00015 	stw	r3,0(r2)


	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */

	OSMutexPost(xTxUARTMutex);
81118664:	d0a07417 	ldw	r2,-32304(gp)
81118668:	1009883a 	mov	r4,r2
8111866c:	113ca580 	call	8113ca58 <OSMutexPost>
	OSMutexPost(xMutexBuffer128);
81118670:	d0a06e17 	ldw	r2,-32328(gp)
81118674:	1009883a 	mov	r4,r2
81118678:	113ca580 	call	8113ca58 <OSMutexPost>

	return bSuccessL;
8111867c:	e0bffc17 	ldw	r2,-16(fp)
}
81118680:	e037883a 	mov	sp,fp
81118684:	dfc00117 	ldw	ra,4(sp)
81118688:	df000017 	ldw	fp,0(sp)
8111868c:	dec00204 	addi	sp,sp,8
81118690:	f800283a 	ret

81118694 <bSendUART64v2>:



/* Make sure that there is only 63 characters to send */
/* Always, ALWAYS send only an char[64] that you first did a memset(cBuffer,0,64), before put some string on it. */
bool bSendUART64v2 ( char *cBuffer, short int siIdMessage ) {
81118694:	defff904 	addi	sp,sp,-28
81118698:	de00012e 	bgeu	sp,et,811186a0 <bSendUART64v2+0xc>
8111869c:	003b68fa 	trap	3
811186a0:	dfc00615 	stw	ra,24(sp)
811186a4:	df000515 	stw	fp,20(sp)
811186a8:	df000504 	addi	fp,sp,20
811186ac:	e13ffe15 	stw	r4,-8(fp)
811186b0:	2805883a 	mov	r2,r5
811186b4:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;
811186b8:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
811186bc:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
811186c0:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
811186c4:	e03ffc15 	stw	zero,-16(fp)

	OSSemPend(xSemCountBuffer64, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
811186c8:	d0a05e17 	ldw	r2,-32392(gp)
811186cc:	e0fffd04 	addi	r3,fp,-12
811186d0:	180d883a 	mov	r6,r3
811186d4:	01400504 	movi	r5,20
811186d8:	1009883a 	mov	r4,r2
811186dc:	113e4c00 	call	8113e4c0 <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
811186e0:	e0bffd03 	ldbu	r2,-12(fp)
811186e4:	10803fcc 	andi	r2,r2,255
811186e8:	10000326 	beq	r2,zero,811186f8 <bSendUART64v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
811186ec:	111bb5c0 	call	8111bb5c <vFailGetCountSemaphorexBuffer64>
		return bSuccessL;
811186f0:	e0bffc17 	ldw	r2,-16(fp)
811186f4:	0000a006 	br	81118978 <bSendUART64v2+0x2e4>
	/* ---> At this point we know that there is some space in the buffer */

	
	
	/* Need to get the Mutex that protects xBuffer64 */
	OSMutexPend(xMutexBuffer64, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
811186f8:	d0a07117 	ldw	r2,-32316(gp)
811186fc:	e0fffd04 	addi	r3,fp,-12
81118700:	180d883a 	mov	r6,r3
81118704:	01400104 	movi	r5,4
81118708:	1009883a 	mov	r4,r2
8111870c:	113c4b40 	call	8113c4b4 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81118710:	e0bffd03 	ldbu	r2,-12(fp)
81118714:	10803fcc 	andi	r2,r2,255
81118718:	10001126 	beq	r2,zero,81118760 <bSendUART64v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer64 that protect xBuffer64. (bSendUART64v2)\n");
8111871c:	d0a06217 	ldw	r2,-32376(gp)
81118720:	100f883a 	mov	r7,r2
81118724:	018013c4 	movi	r6,79
81118728:	01400044 	movi	r5,1
8111872c:	01204574 	movhi	r4,33045
81118730:	2138cb04 	addi	r4,r4,-7380
81118734:	11216400 	call	81121640 <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer64);
81118738:	d0a05e17 	ldw	r2,-32392(gp)
8111873c:	1009883a 	mov	r4,r2
81118740:	113e8480 	call	8113e848 <OSSemPost>
81118744:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
81118748:	e0bffd03 	ldbu	r2,-12(fp)
8111874c:	10803fcc 	andi	r2,r2,255
81118750:	10000126 	beq	r2,zero,81118758 <bSendUART64v2+0xc4>
			vFailSetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
81118754:	111ba240 	call	8111ba24 <vFailSetCountSemaphorexBuffer64>
		}

		return bSuccessL;
81118758:	e0bffc17 	ldw	r2,-16(fp)
8111875c:	00008606 	br	81118978 <bSendUART64v2+0x2e4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_64; ucIL++)
81118760:	e03ffb05 	stb	zero,-20(fp)
81118764:	00004506 	br	8111887c <bSendUART64v2+0x1e8>
	{
		if ( xInUseRetrans.b64[ucIL] == FALSE ) {
81118768:	e0fffb03 	ldbu	r3,-20(fp)
8111876c:	00a045b4 	movhi	r2,33046
81118770:	10b9e704 	addi	r2,r2,-6244
81118774:	18c00184 	addi	r3,r3,6
81118778:	18c7883a 	add	r3,r3,r3
8111877c:	18c7883a 	add	r3,r3,r3
81118780:	10c5883a 	add	r2,r2,r3
81118784:	10800017 	ldw	r2,0(r2)
81118788:	1000391e 	bne	r2,zero,81118870 <bSendUART64v2+0x1dc>
			/* Clear the buffer */
			memset(xBuffer64[ucIL].buffer, 0, 64);
8111878c:	e0bffb03 	ldbu	r2,-20(fp)
81118790:	10c01324 	muli	r3,r2,76
81118794:	00a04574 	movhi	r2,33045
81118798:	1095ab04 	addi	r2,r2,22188
8111879c:	1885883a 	add	r2,r3,r2
811187a0:	01801004 	movi	r6,64
811187a4:	000b883a 	mov	r5,zero
811187a8:	1009883a 	mov	r4,r2
811187ac:	11221a40 	call	811221a4 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer64[ucIL].buffer, cBuffer, 63);
811187b0:	e0bffb03 	ldbu	r2,-20(fp)
811187b4:	10c01324 	muli	r3,r2,76
811187b8:	00a04574 	movhi	r2,33045
811187bc:	1095ab04 	addi	r2,r2,22188
811187c0:	1885883a 	add	r2,r3,r2
811187c4:	01800fc4 	movi	r6,63
811187c8:	e17ffe17 	ldw	r5,-8(fp)
811187cc:	1009883a 	mov	r4,r2
811187d0:	11220540 	call	81122054 <memcpy>
			xBuffer64[ucIL].usiId = siIdMessage;
811187d4:	e13ffb03 	ldbu	r4,-20(fp)
811187d8:	e0ffff0b 	ldhu	r3,-4(fp)
811187dc:	00a04574 	movhi	r2,33045
811187e0:	1095ab04 	addi	r2,r2,22188
811187e4:	21001324 	muli	r4,r4,76
811187e8:	1105883a 	add	r2,r2,r4
811187ec:	10801104 	addi	r2,r2,68
811187f0:	10c0000d 	sth	r3,0(r2)
			xBuffer64[ucIL].ucNofRetries = 0;
811187f4:	e0fffb03 	ldbu	r3,-20(fp)
811187f8:	00a04574 	movhi	r2,33045
811187fc:	1095ab04 	addi	r2,r2,22188
81118800:	18c01324 	muli	r3,r3,76
81118804:	10c5883a 	add	r2,r2,r3
81118808:	10801204 	addi	r2,r2,72
8111880c:	10000005 	stb	zero,0(r2)
			xBuffer64[ucIL].usiTimeOut = 0;
81118810:	e0fffb03 	ldbu	r3,-20(fp)
81118814:	00a04574 	movhi	r2,33045
81118818:	1095ab04 	addi	r2,r2,22188
8111881c:	18c01324 	muli	r3,r3,76
81118820:	10c5883a 	add	r2,r2,r3
81118824:	10801184 	addi	r2,r2,70
81118828:	1000000d 	sth	zero,0(r2)
			xBuffer64[ucIL].bSent = FALSE;
8111882c:	e0fffb03 	ldbu	r3,-20(fp)
81118830:	00a04574 	movhi	r2,33045
81118834:	1095ab04 	addi	r2,r2,22188
81118838:	18c01324 	muli	r3,r3,76
8111883c:	10c5883a 	add	r2,r2,r3
81118840:	10801004 	addi	r2,r2,64
81118844:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b64[ucIL] = TRUE;
81118848:	e0fffb03 	ldbu	r3,-20(fp)
8111884c:	00a045b4 	movhi	r2,33046
81118850:	10b9e704 	addi	r2,r2,-6244
81118854:	18c00184 	addi	r3,r3,6
81118858:	18c7883a 	add	r3,r3,r3
8111885c:	18c7883a 	add	r3,r3,r3
81118860:	10c5883a 	add	r2,r2,r3
81118864:	00c00044 	movi	r3,1
81118868:	10c00015 	stw	r3,0(r2)
			break;
8111886c:	00000606 	br	81118888 <bSendUART64v2+0x1f4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_64; ucIL++)
81118870:	e0bffb03 	ldbu	r2,-20(fp)
81118874:	10800044 	addi	r2,r2,1
81118878:	e0bffb05 	stb	r2,-20(fp)
8111887c:	e0bffb03 	ldbu	r2,-20(fp)
81118880:	10800230 	cmpltui	r2,r2,8
81118884:	103fb81e 	bne	r2,zero,81118768 <__reset+0xfb0f8768>
			break;
		}
	}


	if ( ucIL >= N_64 ) {
81118888:	e0bffb03 	ldbu	r2,-20(fp)
8111888c:	10800230 	cmpltui	r2,r2,8
81118890:	1000091e 	bne	r2,zero,811188b8 <bSendUART64v2+0x224>
		ucErrorCode = OSSemPost(xSemCountBuffer64);
81118894:	d0a05e17 	ldw	r2,-32392(gp)
81118898:	1009883a 	mov	r4,r2
8111889c:	113e8480 	call	8113e848 <OSSemPost>
811188a0:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer64);
811188a4:	d0a07117 	ldw	r2,-32316(gp)
811188a8:	1009883a 	mov	r4,r2
811188ac:	113ca580 	call	8113ca58 <OSMutexPost>
		return bSuccessL;
811188b0:	e0bffc17 	ldw	r2,-16(fp)
811188b4:	00003006 	br	81118978 <bSendUART64v2+0x2e4>
	}

	bSuccessL = TRUE;
811188b8:	00800044 	movi	r2,1
811188bc:	e0bffc15 	stw	r2,-16(fp)
	SemCount64--; /* Sure that you get the semaphore */
811188c0:	d0a07503 	ldbu	r2,-32300(gp)
811188c4:	10bfffc4 	addi	r2,r2,-1
811188c8:	d0a07505 	stb	r2,-32300(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
811188cc:	d0a07417 	ldw	r2,-32304(gp)
811188d0:	e0fffd04 	addi	r3,fp,-12
811188d4:	180d883a 	mov	r6,r3
811188d8:	01400084 	movi	r5,2
811188dc:	1009883a 	mov	r4,r2
811188e0:	113c4b40 	call	8113c4b4 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
811188e4:	e0bffd03 	ldbu	r2,-12(fp)
811188e8:	10803fcc 	andi	r2,r2,255
811188ec:	10000c26 	beq	r2,zero,81118920 <bSendUART64v2+0x28c>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART64v2)\n");
811188f0:	d0a06217 	ldw	r2,-32376(gp)
811188f4:	100f883a 	mov	r7,r2
811188f8:	01801bc4 	movi	r6,111
811188fc:	01400044 	movi	r5,1
81118900:	01204574 	movhi	r4,33045
81118904:	2138df04 	addi	r4,r4,-7300
81118908:	11216400 	call	81121640 <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer64 */
		OSMutexPost(xMutexBuffer64); /* Free the Mutex after use the xBuffer64 */
8111890c:	d0a07117 	ldw	r2,-32316(gp)
81118910:	1009883a 	mov	r4,r2
81118914:	113ca580 	call	8113ca58 <OSMutexPost>
		return bSuccessL;
81118918:	e0bffc17 	ldw	r2,-16(fp)
8111891c:	00001606 	br	81118978 <bSendUART64v2+0x2e4>


	/* ---> At this point we have all resources to send the message */


	puts(xBuffer64[ucIL].buffer);
81118920:	e0bffb03 	ldbu	r2,-20(fp)
81118924:	10c01324 	muli	r3,r2,76
81118928:	00a04574 	movhi	r2,33045
8111892c:	1095ab04 	addi	r2,r2,22188
81118930:	1885883a 	add	r2,r3,r2
81118934:	1009883a 	mov	r4,r2
81118938:	11225f00 	call	811225f0 <puts>
	xBuffer64[ucIL].bSent = TRUE;
8111893c:	e0fffb03 	ldbu	r3,-20(fp)
81118940:	00a04574 	movhi	r2,33045
81118944:	1095ab04 	addi	r2,r2,22188
81118948:	18c01324 	muli	r3,r3,76
8111894c:	10c5883a 	add	r2,r2,r3
81118950:	10801004 	addi	r2,r2,64
81118954:	00c00044 	movi	r3,1
81118958:	10c00015 	stw	r3,0(r2)


	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */
	OSMutexPost(xTxUARTMutex);
8111895c:	d0a07417 	ldw	r2,-32304(gp)
81118960:	1009883a 	mov	r4,r2
81118964:	113ca580 	call	8113ca58 <OSMutexPost>
	OSMutexPost(xMutexBuffer64);
81118968:	d0a07117 	ldw	r2,-32316(gp)
8111896c:	1009883a 	mov	r4,r2
81118970:	113ca580 	call	8113ca58 <OSMutexPost>

	return bSuccessL;
81118974:	e0bffc17 	ldw	r2,-16(fp)
}
81118978:	e037883a 	mov	sp,fp
8111897c:	dfc00117 	ldw	ra,4(sp)
81118980:	df000017 	ldw	fp,0(sp)
81118984:	dec00204 	addi	sp,sp,8
81118988:	f800283a 	ret

8111898c <bSendUART32v2>:



/* Make sure that there is only 31 characters to send */
/* Always, ALWAYS send only an char[32] that you first did a memset(cBuffer,0,32), before put some string on it. */
bool bSendUART32v2 ( char *cBuffer, short int siIdMessage ) {
8111898c:	defff904 	addi	sp,sp,-28
81118990:	de00012e 	bgeu	sp,et,81118998 <bSendUART32v2+0xc>
81118994:	003b68fa 	trap	3
81118998:	dfc00615 	stw	ra,24(sp)
8111899c:	df000515 	stw	fp,20(sp)
811189a0:	df000504 	addi	fp,sp,20
811189a4:	e13ffe15 	stw	r4,-8(fp)
811189a8:	2805883a 	mov	r2,r5
811189ac:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;
811189b0:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
811189b4:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
811189b8:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
811189bc:	e03ffc15 	stw	zero,-16(fp)
	
	OSSemPend(xSemCountBuffer32, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
811189c0:	d0a06f17 	ldw	r2,-32324(gp)
811189c4:	e0fffd04 	addi	r3,fp,-12
811189c8:	180d883a 	mov	r6,r3
811189cc:	01400504 	movi	r5,20
811189d0:	1009883a 	mov	r4,r2
811189d4:	113e4c00 	call	8113e4c0 <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
811189d8:	e0bffd03 	ldbu	r2,-12(fp)
811189dc:	10803fcc 	andi	r2,r2,255
811189e0:	10000326 	beq	r2,zero,811189f0 <bSendUART32v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
811189e4:	111bbc40 	call	8111bbc4 <vFailGetCountSemaphorexBuffer32>
		return bSuccessL;
811189e8:	e0bffc17 	ldw	r2,-16(fp)
811189ec:	0000a006 	br	81118c70 <bSendUART32v2+0x2e4>

	/* ---> At this point we know that there is some space in the buffer */


	/* Need to get the Mutex that protects xBuffer32 */
	OSMutexPend(xMutexBuffer32, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
811189f0:	d0a06c17 	ldw	r2,-32336(gp)
811189f4:	e0fffd04 	addi	r3,fp,-12
811189f8:	180d883a 	mov	r6,r3
811189fc:	01400104 	movi	r5,4
81118a00:	1009883a 	mov	r4,r2
81118a04:	113c4b40 	call	8113c4b4 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81118a08:	e0bffd03 	ldbu	r2,-12(fp)
81118a0c:	10803fcc 	andi	r2,r2,255
81118a10:	10001126 	beq	r2,zero,81118a58 <bSendUART32v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer32 that protect xBuffer32. (bSendUART32v2)\n");
81118a14:	d0a06217 	ldw	r2,-32376(gp)
81118a18:	100f883a 	mov	r7,r2
81118a1c:	018013c4 	movi	r6,79
81118a20:	01400044 	movi	r5,1
81118a24:	01204574 	movhi	r4,33045
81118a28:	2138fb04 	addi	r4,r4,-7188
81118a2c:	11216400 	call	81121640 <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer32);
81118a30:	d0a06f17 	ldw	r2,-32324(gp)
81118a34:	1009883a 	mov	r4,r2
81118a38:	113e8480 	call	8113e848 <OSSemPost>
81118a3c:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
81118a40:	e0bffd03 	ldbu	r2,-12(fp)
81118a44:	10803fcc 	andi	r2,r2,255
81118a48:	10000126 	beq	r2,zero,81118a50 <bSendUART32v2+0xc4>
			vFailSetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
81118a4c:	111b9bc0 	call	8111b9bc <vFailSetCountSemaphorexBuffer32>
		}

		return bSuccessL;
81118a50:	e0bffc17 	ldw	r2,-16(fp)
81118a54:	00008606 	br	81118c70 <bSendUART32v2+0x2e4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_32; ucIL++)
81118a58:	e03ffb05 	stb	zero,-20(fp)
81118a5c:	00004506 	br	81118b74 <bSendUART32v2+0x1e8>
	{
		if ( xInUseRetrans.b32[ucIL] == FALSE ) {
81118a60:	e0fffb03 	ldbu	r3,-20(fp)
81118a64:	00a045b4 	movhi	r2,33046
81118a68:	10b9e704 	addi	r2,r2,-6244
81118a6c:	18c00384 	addi	r3,r3,14
81118a70:	18c7883a 	add	r3,r3,r3
81118a74:	18c7883a 	add	r3,r3,r3
81118a78:	10c5883a 	add	r2,r2,r3
81118a7c:	10800017 	ldw	r2,0(r2)
81118a80:	1000391e 	bne	r2,zero,81118b68 <bSendUART32v2+0x1dc>
			/* Clear the buffer */
			memset(xBuffer32[ucIL].buffer, 0, 32);
81118a84:	e0bffb03 	ldbu	r2,-20(fp)
81118a88:	10c00b24 	muli	r3,r2,44
81118a8c:	00a045b4 	movhi	r2,33046
81118a90:	10a76704 	addi	r2,r2,-25188
81118a94:	1885883a 	add	r2,r3,r2
81118a98:	01800804 	movi	r6,32
81118a9c:	000b883a 	mov	r5,zero
81118aa0:	1009883a 	mov	r4,r2
81118aa4:	11221a40 	call	811221a4 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer32[ucIL].buffer, cBuffer, 31);
81118aa8:	e0bffb03 	ldbu	r2,-20(fp)
81118aac:	10c00b24 	muli	r3,r2,44
81118ab0:	00a045b4 	movhi	r2,33046
81118ab4:	10a76704 	addi	r2,r2,-25188
81118ab8:	1885883a 	add	r2,r3,r2
81118abc:	018007c4 	movi	r6,31
81118ac0:	e17ffe17 	ldw	r5,-8(fp)
81118ac4:	1009883a 	mov	r4,r2
81118ac8:	11220540 	call	81122054 <memcpy>
			xBuffer32[ucIL].usiId = siIdMessage;
81118acc:	e13ffb03 	ldbu	r4,-20(fp)
81118ad0:	e0ffff0b 	ldhu	r3,-4(fp)
81118ad4:	00a045b4 	movhi	r2,33046
81118ad8:	10a76704 	addi	r2,r2,-25188
81118adc:	21000b24 	muli	r4,r4,44
81118ae0:	1105883a 	add	r2,r2,r4
81118ae4:	10800904 	addi	r2,r2,36
81118ae8:	10c0000d 	sth	r3,0(r2)
			xBuffer32[ucIL].ucNofRetries = 0;
81118aec:	e0fffb03 	ldbu	r3,-20(fp)
81118af0:	00a045b4 	movhi	r2,33046
81118af4:	10a76704 	addi	r2,r2,-25188
81118af8:	18c00b24 	muli	r3,r3,44
81118afc:	10c5883a 	add	r2,r2,r3
81118b00:	10800a04 	addi	r2,r2,40
81118b04:	10000005 	stb	zero,0(r2)
			xBuffer32[ucIL].usiTimeOut = 0;
81118b08:	e0fffb03 	ldbu	r3,-20(fp)
81118b0c:	00a045b4 	movhi	r2,33046
81118b10:	10a76704 	addi	r2,r2,-25188
81118b14:	18c00b24 	muli	r3,r3,44
81118b18:	10c5883a 	add	r2,r2,r3
81118b1c:	10800984 	addi	r2,r2,38
81118b20:	1000000d 	sth	zero,0(r2)
			xBuffer32[ucIL].bSent = FALSE;
81118b24:	e0fffb03 	ldbu	r3,-20(fp)
81118b28:	00a045b4 	movhi	r2,33046
81118b2c:	10a76704 	addi	r2,r2,-25188
81118b30:	18c00b24 	muli	r3,r3,44
81118b34:	10c5883a 	add	r2,r2,r3
81118b38:	10800804 	addi	r2,r2,32
81118b3c:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b32[ucIL] = TRUE;
81118b40:	e0fffb03 	ldbu	r3,-20(fp)
81118b44:	00a045b4 	movhi	r2,33046
81118b48:	10b9e704 	addi	r2,r2,-6244
81118b4c:	18c00384 	addi	r3,r3,14
81118b50:	18c7883a 	add	r3,r3,r3
81118b54:	18c7883a 	add	r3,r3,r3
81118b58:	10c5883a 	add	r2,r2,r3
81118b5c:	00c00044 	movi	r3,1
81118b60:	10c00015 	stw	r3,0(r2)
			break;
81118b64:	00000606 	br	81118b80 <bSendUART32v2+0x1f4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_32; ucIL++)
81118b68:	e0bffb03 	ldbu	r2,-20(fp)
81118b6c:	10800044 	addi	r2,r2,1
81118b70:	e0bffb05 	stb	r2,-20(fp)
81118b74:	e0bffb03 	ldbu	r2,-20(fp)
81118b78:	10800230 	cmpltui	r2,r2,8
81118b7c:	103fb81e 	bne	r2,zero,81118a60 <__reset+0xfb0f8a60>
			xInUseRetrans.b32[ucIL] = TRUE;
			break;
		}
	}	

	if ( ucIL >= N_32 ) {
81118b80:	e0bffb03 	ldbu	r2,-20(fp)
81118b84:	10800230 	cmpltui	r2,r2,8
81118b88:	1000091e 	bne	r2,zero,81118bb0 <bSendUART32v2+0x224>
		ucErrorCode = OSSemPost(xSemCountBuffer32);
81118b8c:	d0a06f17 	ldw	r2,-32324(gp)
81118b90:	1009883a 	mov	r4,r2
81118b94:	113e8480 	call	8113e848 <OSSemPost>
81118b98:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer32);
81118b9c:	d0a06c17 	ldw	r2,-32336(gp)
81118ba0:	1009883a 	mov	r4,r2
81118ba4:	113ca580 	call	8113ca58 <OSMutexPost>
		return bSuccessL;
81118ba8:	e0bffc17 	ldw	r2,-16(fp)
81118bac:	00003006 	br	81118c70 <bSendUART32v2+0x2e4>
	}
	
	bSuccessL = TRUE;
81118bb0:	00800044 	movi	r2,1
81118bb4:	e0bffc15 	stw	r2,-16(fp)
	SemCount32--; /* Sure that you get the semaphore */
81118bb8:	d0a06883 	ldbu	r2,-32350(gp)
81118bbc:	10bfffc4 	addi	r2,r2,-1
81118bc0:	d0a06885 	stb	r2,-32350(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
81118bc4:	d0a07417 	ldw	r2,-32304(gp)
81118bc8:	e0fffd04 	addi	r3,fp,-12
81118bcc:	180d883a 	mov	r6,r3
81118bd0:	01400084 	movi	r5,2
81118bd4:	1009883a 	mov	r4,r2
81118bd8:	113c4b40 	call	8113c4b4 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81118bdc:	e0bffd03 	ldbu	r2,-12(fp)
81118be0:	10803fcc 	andi	r2,r2,255
81118be4:	10000c26 	beq	r2,zero,81118c18 <bSendUART32v2+0x28c>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART32v2)\n");
81118be8:	d0a06217 	ldw	r2,-32376(gp)
81118bec:	100f883a 	mov	r7,r2
81118bf0:	01801bc4 	movi	r6,111
81118bf4:	01400044 	movi	r5,1
81118bf8:	01204574 	movhi	r4,33045
81118bfc:	21390f04 	addi	r4,r4,-7108
81118c00:	11216400 	call	81121640 <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer64 */
		OSMutexPost(xMutexBuffer32); /* Free the Mutex after use the xMutexBuffer32 */
81118c04:	d0a06c17 	ldw	r2,-32336(gp)
81118c08:	1009883a 	mov	r4,r2
81118c0c:	113ca580 	call	8113ca58 <OSMutexPost>
		return bSuccessL;
81118c10:	e0bffc17 	ldw	r2,-16(fp)
81118c14:	00001606 	br	81118c70 <bSendUART32v2+0x2e4>
	}


	/* ---> At this point we have all resources to send the message */

	puts(xBuffer32[ucIL].buffer);
81118c18:	e0bffb03 	ldbu	r2,-20(fp)
81118c1c:	10c00b24 	muli	r3,r2,44
81118c20:	00a045b4 	movhi	r2,33046
81118c24:	10a76704 	addi	r2,r2,-25188
81118c28:	1885883a 	add	r2,r3,r2
81118c2c:	1009883a 	mov	r4,r2
81118c30:	11225f00 	call	811225f0 <puts>
	xBuffer32[ucIL].bSent = TRUE;
81118c34:	e0fffb03 	ldbu	r3,-20(fp)
81118c38:	00a045b4 	movhi	r2,33046
81118c3c:	10a76704 	addi	r2,r2,-25188
81118c40:	18c00b24 	muli	r3,r3,44
81118c44:	10c5883a 	add	r2,r2,r3
81118c48:	10800804 	addi	r2,r2,32
81118c4c:	00c00044 	movi	r3,1
81118c50:	10c00015 	stw	r3,0(r2)

	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */


	OSMutexPost(xTxUARTMutex);
81118c54:	d0a07417 	ldw	r2,-32304(gp)
81118c58:	1009883a 	mov	r4,r2
81118c5c:	113ca580 	call	8113ca58 <OSMutexPost>
	OSMutexPost(xMutexBuffer32);
81118c60:	d0a06c17 	ldw	r2,-32336(gp)
81118c64:	1009883a 	mov	r4,r2
81118c68:	113ca580 	call	8113ca58 <OSMutexPost>

	return bSuccessL;
81118c6c:	e0bffc17 	ldw	r2,-16(fp)
}
81118c70:	e037883a 	mov	sp,fp
81118c74:	dfc00117 	ldw	ra,4(sp)
81118c78:	df000017 	ldw	fp,0(sp)
81118c7c:	dec00204 	addi	sp,sp,8
81118c80:	f800283a 	ret

81118c84 <vSendEthConf>:


void vSendEthConf ( void ) {
81118c84:	deffc304 	addi	sp,sp,-244
81118c88:	de00012e 	bgeu	sp,et,81118c90 <vSendEthConf+0xc>
81118c8c:	003b68fa 	trap	3
81118c90:	dfc03c15 	stw	ra,240(sp)
81118c94:	df003b15 	stw	fp,236(sp)
81118c98:	dd403a15 	stw	r21,232(sp)
81118c9c:	dd003915 	stw	r20,228(sp)
81118ca0:	dcc03815 	stw	r19,224(sp)
81118ca4:	dc803715 	stw	r18,220(sp)
81118ca8:	dc403615 	stw	r17,216(sp)
81118cac:	dc003515 	stw	r16,212(sp)
81118cb0:	df003b04 	addi	fp,sp,236
    char cBufferETH[128] = "";
81118cb4:	e03fd98d 	sth	zero,-154(fp)
81118cb8:	e03fda0d 	sth	zero,-152(fp)
81118cbc:	e0bfda84 	addi	r2,fp,-150
81118cc0:	00c01f04 	movi	r3,124
81118cc4:	180d883a 	mov	r6,r3
81118cc8:	000b883a 	mov	r5,zero
81118ccc:	1009883a 	mov	r4,r2
81118cd0:	11221a40 	call	811221a4 <memset>
    unsigned char crc = 0;
81118cd4:	e03fd705 	stb	zero,-164(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81118cd8:	e03fd815 	stw	zero,-160(fp)

    usiIdCMDLocal = usiGetIdCMD();
81118cdc:	11192440 	call	81119244 <usiGetIdCMD>
81118ce0:	e0bfd90d 	sth	r2,-156(fp)

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118ce4:	e57fd90b 	ldhu	r21,-156(fp)
81118ce8:	00a045b4 	movhi	r2,33046
81118cec:	1099d604 	addi	r2,r2,26456
81118cf0:	10c00617 	ldw	r3,24(r2)
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81118cf4:	00a045b4 	movhi	r2,33046
81118cf8:	1099d604 	addi	r2,r2,26456
81118cfc:	10800003 	ldbu	r2,0(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118d00:	11003fcc 	andi	r4,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81118d04:	00a045b4 	movhi	r2,33046
81118d08:	1099d604 	addi	r2,r2,26456
81118d0c:	10800043 	ldbu	r2,1(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118d10:	11403fcc 	andi	r5,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81118d14:	00a045b4 	movhi	r2,33046
81118d18:	1099d604 	addi	r2,r2,26456
81118d1c:	10800083 	ldbu	r2,2(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118d20:	11803fcc 	andi	r6,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81118d24:	00a045b4 	movhi	r2,33046
81118d28:	1099d604 	addi	r2,r2,26456
81118d2c:	108000c3 	ldbu	r2,3(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118d30:	11c03fcc 	andi	r7,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81118d34:	00a045b4 	movhi	r2,33046
81118d38:	1099d604 	addi	r2,r2,26456
81118d3c:	10800203 	ldbu	r2,8(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118d40:	12003fcc 	andi	r8,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81118d44:	00a045b4 	movhi	r2,33046
81118d48:	1099d604 	addi	r2,r2,26456
81118d4c:	10800243 	ldbu	r2,9(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118d50:	12403fcc 	andi	r9,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81118d54:	00a045b4 	movhi	r2,33046
81118d58:	1099d604 	addi	r2,r2,26456
81118d5c:	10800283 	ldbu	r2,10(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118d60:	12803fcc 	andi	r10,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81118d64:	00a045b4 	movhi	r2,33046
81118d68:	1099d604 	addi	r2,r2,26456
81118d6c:	108002c3 	ldbu	r2,11(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118d70:	12c03fcc 	andi	r11,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81118d74:	00a045b4 	movhi	r2,33046
81118d78:	1099d604 	addi	r2,r2,26456
81118d7c:	10800103 	ldbu	r2,4(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118d80:	13003fcc 	andi	r12,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81118d84:	00a045b4 	movhi	r2,33046
81118d88:	1099d604 	addi	r2,r2,26456
81118d8c:	10800143 	ldbu	r2,5(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118d90:	13403fcc 	andi	r13,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81118d94:	00a045b4 	movhi	r2,33046
81118d98:	1099d604 	addi	r2,r2,26456
81118d9c:	10800183 	ldbu	r2,6(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118da0:	13803fcc 	andi	r14,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81118da4:	00a045b4 	movhi	r2,33046
81118da8:	1099d604 	addi	r2,r2,26456
81118dac:	108001c3 	ldbu	r2,7(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118db0:	13c03fcc 	andi	r15,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
81118db4:	00a045b4 	movhi	r2,33046
81118db8:	1099d604 	addi	r2,r2,26456
81118dbc:	10800303 	ldbu	r2,12(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118dc0:	14003fcc 	andi	r16,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
81118dc4:	00a045b4 	movhi	r2,33046
81118dc8:	1099d604 	addi	r2,r2,26456
81118dcc:	10800343 	ldbu	r2,13(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118dd0:	14403fcc 	andi	r17,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
81118dd4:	00a045b4 	movhi	r2,33046
81118dd8:	1099d604 	addi	r2,r2,26456
81118ddc:	10800383 	ldbu	r2,14(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118de0:	14803fcc 	andi	r18,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
81118de4:	00a045b4 	movhi	r2,33046
81118de8:	1099d604 	addi	r2,r2,26456
81118dec:	108003c3 	ldbu	r2,15(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118df0:	14c03fcc 	andi	r19,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
                        xConfEth.siPortPUS);
81118df4:	00a045b4 	movhi	r2,33046
81118df8:	1099d604 	addi	r2,r2,26456
81118dfc:	1080058b 	ldhu	r2,22(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118e00:	10bfffcc 	andi	r2,r2,65535
81118e04:	e53fd984 	addi	r20,fp,-154
81118e08:	d8801115 	stw	r2,68(sp)
81118e0c:	dcc01015 	stw	r19,64(sp)
81118e10:	dc800f15 	stw	r18,60(sp)
81118e14:	dc400e15 	stw	r17,56(sp)
81118e18:	dc000d15 	stw	r16,52(sp)
81118e1c:	dbc00c15 	stw	r15,48(sp)
81118e20:	db800b15 	stw	r14,44(sp)
81118e24:	db400a15 	stw	r13,40(sp)
81118e28:	db000915 	stw	r12,36(sp)
81118e2c:	dac00815 	stw	r11,32(sp)
81118e30:	da800715 	stw	r10,28(sp)
81118e34:	da400615 	stw	r9,24(sp)
81118e38:	da000515 	stw	r8,20(sp)
81118e3c:	d9c00415 	stw	r7,16(sp)
81118e40:	d9800315 	stw	r6,12(sp)
81118e44:	d9400215 	stw	r5,8(sp)
81118e48:	d9000115 	stw	r4,4(sp)
81118e4c:	d8c00015 	stw	r3,0(sp)
81118e50:	a80f883a 	mov	r7,r21
81118e54:	018010c4 	movi	r6,67
81118e58:	01604574 	movhi	r5,33045
81118e5c:	29792b04 	addi	r5,r5,-6996
81118e60:	a009883a 	mov	r4,r20
81118e64:	11229340 	call	81122934 <sprintf>
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
                        xConfEth.siPortPUS);
    crc = ucCrc8wInit( cBufferETH , strlen(cBufferETH));
81118e68:	e0bfd984 	addi	r2,fp,-154
81118e6c:	1009883a 	mov	r4,r2
81118e70:	1122b480 	call	81122b48 <strlen>
81118e74:	1007883a 	mov	r3,r2
81118e78:	e0bfd984 	addi	r2,fp,-154
81118e7c:	180b883a 	mov	r5,r3
81118e80:	1009883a 	mov	r4,r2
81118e84:	111b1fc0 	call	8111b1fc <ucCrc8wInit>
81118e88:	e0bfd705 	stb	r2,-164(fp)
    sprintf(cBufferETH, "%s|%hhu;", cBufferETH, crc );
81118e8c:	e13fd703 	ldbu	r4,-164(fp)
81118e90:	e0ffd984 	addi	r3,fp,-154
81118e94:	e0bfd984 	addi	r2,fp,-154
81118e98:	200f883a 	mov	r7,r4
81118e9c:	180d883a 	mov	r6,r3
81118ea0:	01604574 	movhi	r5,33045
81118ea4:	29794304 	addi	r5,r5,-6900
81118ea8:	1009883a 	mov	r4,r2
81118eac:	11229340 	call	81122934 <sprintf>

	bSuccees = bSendUART128v2(cBufferETH, usiIdCMDLocal);
81118eb0:	e0bfd90b 	ldhu	r2,-156(fp)
81118eb4:	10ffffcc 	andi	r3,r2,65535
81118eb8:	18e0001c 	xori	r3,r3,32768
81118ebc:	18e00004 	addi	r3,r3,-32768
81118ec0:	e0bfd984 	addi	r2,fp,-154
81118ec4:	180b883a 	mov	r5,r3
81118ec8:	1009883a 	mov	r4,r2
81118ecc:	11183a40 	call	811183a4 <bSendUART128v2>
81118ed0:	e0bfd815 	stw	r2,-160(fp)

	if ( bSuccees != TRUE ) {
81118ed4:	e0bfd817 	ldw	r2,-160(fp)
81118ed8:	10800060 	cmpeqi	r2,r2,1
81118edc:	1000011e 	bne	r2,zero,81118ee4 <vSendEthConf+0x260>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendEthConfUART();
81118ee0:	111bdcc0 	call	8111bdcc <vCouldNotSendEthConfUART>
	}
}
81118ee4:	0001883a 	nop
81118ee8:	e6fffa04 	addi	sp,fp,-24
81118eec:	dfc00717 	ldw	ra,28(sp)
81118ef0:	df000617 	ldw	fp,24(sp)
81118ef4:	dd400517 	ldw	r21,20(sp)
81118ef8:	dd000417 	ldw	r20,16(sp)
81118efc:	dcc00317 	ldw	r19,12(sp)
81118f00:	dc800217 	ldw	r18,8(sp)
81118f04:	dc400117 	ldw	r17,4(sp)
81118f08:	dc000017 	ldw	r16,0(sp)
81118f0c:	dec00804 	addi	sp,sp,32
81118f10:	f800283a 	ret

81118f14 <vSendTurnOff>:


void vSendTurnOff ( void ) {
81118f14:	defff304 	addi	sp,sp,-52
81118f18:	de00012e 	bgeu	sp,et,81118f20 <vSendTurnOff+0xc>
81118f1c:	003b68fa 	trap	3
81118f20:	dfc00c15 	stw	ra,48(sp)
81118f24:	df000b15 	stw	fp,44(sp)
81118f28:	df000b04 	addi	fp,sp,44
    char cBufferTurnOff[32] = "";
81118f2c:	e03ff78d 	sth	zero,-34(fp)
81118f30:	e03ff80d 	sth	zero,-32(fp)
81118f34:	e03ff88d 	sth	zero,-30(fp)
81118f38:	e03ff90d 	sth	zero,-28(fp)
81118f3c:	e03ff98d 	sth	zero,-26(fp)
81118f40:	e03ffa0d 	sth	zero,-24(fp)
81118f44:	e03ffa8d 	sth	zero,-22(fp)
81118f48:	e03ffb0d 	sth	zero,-20(fp)
81118f4c:	e03ffb8d 	sth	zero,-18(fp)
81118f50:	e03ffc0d 	sth	zero,-16(fp)
81118f54:	e03ffc8d 	sth	zero,-14(fp)
81118f58:	e03ffd0d 	sth	zero,-12(fp)
81118f5c:	e03ffd8d 	sth	zero,-10(fp)
81118f60:	e03ffe0d 	sth	zero,-8(fp)
81118f64:	e03ffe8d 	sth	zero,-6(fp)
81118f68:	e03fff0d 	sth	zero,-4(fp)
    unsigned char crc = 0;
81118f6c:	e03ff505 	stb	zero,-44(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81118f70:	e03ff615 	stw	zero,-40(fp)

    usiIdCMDLocal = usiGetIdCMD();
81118f74:	11192440 	call	81119244 <usiGetIdCMD>
81118f78:	e0bff70d 	sth	r2,-36(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferTurnOff, TURNOFF_SPRINTF, usiIdCMDLocal);
81118f7c:	e0fff70b 	ldhu	r3,-36(fp)
81118f80:	e0bff784 	addi	r2,fp,-34
81118f84:	180d883a 	mov	r6,r3
81118f88:	01604574 	movhi	r5,33045
81118f8c:	29794604 	addi	r5,r5,-6888
81118f90:	1009883a 	mov	r4,r2
81118f94:	11229340 	call	81122934 <sprintf>
    crc = ucCrc8wInit( cBufferTurnOff , strlen(cBufferTurnOff));
81118f98:	e0bff784 	addi	r2,fp,-34
81118f9c:	1009883a 	mov	r4,r2
81118fa0:	1122b480 	call	81122b48 <strlen>
81118fa4:	1007883a 	mov	r3,r2
81118fa8:	e0bff784 	addi	r2,fp,-34
81118fac:	180b883a 	mov	r5,r3
81118fb0:	1009883a 	mov	r4,r2
81118fb4:	111b1fc0 	call	8111b1fc <ucCrc8wInit>
81118fb8:	e0bff505 	stb	r2,-44(fp)
    sprintf(cBufferTurnOff, "%s|%hhu;", cBufferTurnOff, crc );
81118fbc:	e13ff503 	ldbu	r4,-44(fp)
81118fc0:	e0fff784 	addi	r3,fp,-34
81118fc4:	e0bff784 	addi	r2,fp,-34
81118fc8:	200f883a 	mov	r7,r4
81118fcc:	180d883a 	mov	r6,r3
81118fd0:	01604574 	movhi	r5,33045
81118fd4:	29794304 	addi	r5,r5,-6900
81118fd8:	1009883a 	mov	r4,r2
81118fdc:	11229340 	call	81122934 <sprintf>

	bSuccees = bSendUART32v2(cBufferTurnOff, usiIdCMDLocal);
81118fe0:	e0bff70b 	ldhu	r2,-36(fp)
81118fe4:	10ffffcc 	andi	r3,r2,65535
81118fe8:	18e0001c 	xori	r3,r3,32768
81118fec:	18e00004 	addi	r3,r3,-32768
81118ff0:	e0bff784 	addi	r2,fp,-34
81118ff4:	180b883a 	mov	r5,r3
81118ff8:	1009883a 	mov	r4,r2
81118ffc:	111898c0 	call	8111898c <bSendUART32v2>
81119000:	e0bff615 	stw	r2,-40(fp)

	if ( bSuccees != TRUE ) {
81119004:	e0bff617 	ldw	r2,-40(fp)
81119008:	10800060 	cmpeqi	r2,r2,1
8111900c:	1000011e 	bne	r2,zero,81119014 <vSendTurnOff+0x100>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTurnOff();
81119010:	111c4740 	call	8111c474 <vCouldNotSendTurnOff>
	}
}
81119014:	0001883a 	nop
81119018:	e037883a 	mov	sp,fp
8111901c:	dfc00117 	ldw	ra,4(sp)
81119020:	df000017 	ldw	fp,0(sp)
81119024:	dec00204 	addi	sp,sp,8
81119028:	f800283a 	ret

8111902c <vSendReset>:

void vSendReset ( void ) {
8111902c:	defff304 	addi	sp,sp,-52
81119030:	de00012e 	bgeu	sp,et,81119038 <vSendReset+0xc>
81119034:	003b68fa 	trap	3
81119038:	dfc00c15 	stw	ra,48(sp)
8111903c:	df000b15 	stw	fp,44(sp)
81119040:	df000b04 	addi	fp,sp,44
    char cBufferTurnOff[32] = "";
81119044:	e03ff78d 	sth	zero,-34(fp)
81119048:	e03ff80d 	sth	zero,-32(fp)
8111904c:	e03ff88d 	sth	zero,-30(fp)
81119050:	e03ff90d 	sth	zero,-28(fp)
81119054:	e03ff98d 	sth	zero,-26(fp)
81119058:	e03ffa0d 	sth	zero,-24(fp)
8111905c:	e03ffa8d 	sth	zero,-22(fp)
81119060:	e03ffb0d 	sth	zero,-20(fp)
81119064:	e03ffb8d 	sth	zero,-18(fp)
81119068:	e03ffc0d 	sth	zero,-16(fp)
8111906c:	e03ffc8d 	sth	zero,-14(fp)
81119070:	e03ffd0d 	sth	zero,-12(fp)
81119074:	e03ffd8d 	sth	zero,-10(fp)
81119078:	e03ffe0d 	sth	zero,-8(fp)
8111907c:	e03ffe8d 	sth	zero,-6(fp)
81119080:	e03fff0d 	sth	zero,-4(fp)
    unsigned char crc = 0;
81119084:	e03ff505 	stb	zero,-44(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81119088:	e03ff615 	stw	zero,-40(fp)

    usiIdCMDLocal = usiGetIdCMD();
8111908c:	11192440 	call	81119244 <usiGetIdCMD>
81119090:	e0bff70d 	sth	r2,-36(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferTurnOff, RESET_SPRINTF, usiIdCMDLocal);
81119094:	e0fff70b 	ldhu	r3,-36(fp)
81119098:	e0bff784 	addi	r2,fp,-34
8111909c:	180d883a 	mov	r6,r3
811190a0:	01604574 	movhi	r5,33045
811190a4:	29794804 	addi	r5,r5,-6880
811190a8:	1009883a 	mov	r4,r2
811190ac:	11229340 	call	81122934 <sprintf>
    crc = ucCrc8wInit( cBufferTurnOff , strlen(cBufferTurnOff));
811190b0:	e0bff784 	addi	r2,fp,-34
811190b4:	1009883a 	mov	r4,r2
811190b8:	1122b480 	call	81122b48 <strlen>
811190bc:	1007883a 	mov	r3,r2
811190c0:	e0bff784 	addi	r2,fp,-34
811190c4:	180b883a 	mov	r5,r3
811190c8:	1009883a 	mov	r4,r2
811190cc:	111b1fc0 	call	8111b1fc <ucCrc8wInit>
811190d0:	e0bff505 	stb	r2,-44(fp)
    sprintf(cBufferTurnOff, "%s|%hhu;", cBufferTurnOff, crc );
811190d4:	e13ff503 	ldbu	r4,-44(fp)
811190d8:	e0fff784 	addi	r3,fp,-34
811190dc:	e0bff784 	addi	r2,fp,-34
811190e0:	200f883a 	mov	r7,r4
811190e4:	180d883a 	mov	r6,r3
811190e8:	01604574 	movhi	r5,33045
811190ec:	29794304 	addi	r5,r5,-6900
811190f0:	1009883a 	mov	r4,r2
811190f4:	11229340 	call	81122934 <sprintf>

	bSuccees = bSendUART32v2(cBufferTurnOff, usiIdCMDLocal);
811190f8:	e0bff70b 	ldhu	r2,-36(fp)
811190fc:	10ffffcc 	andi	r3,r2,65535
81119100:	18e0001c 	xori	r3,r3,32768
81119104:	18e00004 	addi	r3,r3,-32768
81119108:	e0bff784 	addi	r2,fp,-34
8111910c:	180b883a 	mov	r5,r3
81119110:	1009883a 	mov	r4,r2
81119114:	111898c0 	call	8111898c <bSendUART32v2>
81119118:	e0bff615 	stw	r2,-40(fp)

	if ( bSuccees != TRUE ) {
8111911c:	e0bff617 	ldw	r2,-40(fp)
81119120:	10800060 	cmpeqi	r2,r2,1
81119124:	1000011e 	bne	r2,zero,8111912c <vSendReset+0x100>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTurnOff();
81119128:	111c4740 	call	8111c474 <vCouldNotSendTurnOff>
	}
}
8111912c:	0001883a 	nop
81119130:	e037883a 	mov	sp,fp
81119134:	dfc00117 	ldw	ra,4(sp)
81119138:	df000017 	ldw	fp,0(sp)
8111913c:	dec00204 	addi	sp,sp,8
81119140:	f800283a 	ret

81119144 <vSendLog>:

void vSendLog ( const char * cDataIn ) {
81119144:	deffda04 	addi	sp,sp,-152
81119148:	de00012e 	bgeu	sp,et,81119150 <vSendLog+0xc>
8111914c:	003b68fa 	trap	3
81119150:	dfc02515 	stw	ra,148(sp)
81119154:	df002415 	stw	fp,144(sp)
81119158:	df002404 	addi	fp,sp,144
8111915c:	e13fff15 	stw	r4,-4(fp)
    char cBufferLog[128] = "";
81119160:	e03fde8d 	sth	zero,-134(fp)
81119164:	e03fdf0d 	sth	zero,-132(fp)
81119168:	e0bfdf84 	addi	r2,fp,-130
8111916c:	00c01f04 	movi	r3,124
81119170:	180d883a 	mov	r6,r3
81119174:	000b883a 	mov	r5,zero
81119178:	1009883a 	mov	r4,r2
8111917c:	11221a40 	call	811221a4 <memset>
    unsigned char crc = 0;
81119180:	e03fdc05 	stb	zero,-144(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81119184:	e03fdd15 	stw	zero,-140(fp)

    usiIdCMDLocal = usiGetIdCMD();
81119188:	11192440 	call	81119244 <usiGetIdCMD>
8111918c:	e0bfde0d 	sth	r2,-136(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferLog, LOG_SPRINTF, usiIdCMDLocal, cDataIn);
81119190:	e0ffde0b 	ldhu	r3,-136(fp)
81119194:	e0bfde84 	addi	r2,fp,-134
81119198:	e1ffff17 	ldw	r7,-4(fp)
8111919c:	180d883a 	mov	r6,r3
811191a0:	01604574 	movhi	r5,33045
811191a4:	29794a04 	addi	r5,r5,-6872
811191a8:	1009883a 	mov	r4,r2
811191ac:	11229340 	call	81122934 <sprintf>
    crc = ucCrc8wInit( cBufferLog , strlen(cBufferLog));
811191b0:	e0bfde84 	addi	r2,fp,-134
811191b4:	1009883a 	mov	r4,r2
811191b8:	1122b480 	call	81122b48 <strlen>
811191bc:	1007883a 	mov	r3,r2
811191c0:	e0bfde84 	addi	r2,fp,-134
811191c4:	180b883a 	mov	r5,r3
811191c8:	1009883a 	mov	r4,r2
811191cc:	111b1fc0 	call	8111b1fc <ucCrc8wInit>
811191d0:	e0bfdc05 	stb	r2,-144(fp)
    sprintf(cBufferLog, "%s|%hhu;", cBufferLog, crc );
811191d4:	e13fdc03 	ldbu	r4,-144(fp)
811191d8:	e0ffde84 	addi	r3,fp,-134
811191dc:	e0bfde84 	addi	r2,fp,-134
811191e0:	200f883a 	mov	r7,r4
811191e4:	180d883a 	mov	r6,r3
811191e8:	01604574 	movhi	r5,33045
811191ec:	29794304 	addi	r5,r5,-6900
811191f0:	1009883a 	mov	r4,r2
811191f4:	11229340 	call	81122934 <sprintf>

	bSuccees = bSendUART128v2(cBufferLog, usiIdCMDLocal);
811191f8:	e0bfde0b 	ldhu	r2,-136(fp)
811191fc:	10ffffcc 	andi	r3,r2,65535
81119200:	18e0001c 	xori	r3,r3,32768
81119204:	18e00004 	addi	r3,r3,-32768
81119208:	e0bfde84 	addi	r2,fp,-134
8111920c:	180b883a 	mov	r5,r3
81119210:	1009883a 	mov	r4,r2
81119214:	11183a40 	call	811183a4 <bSendUART128v2>
81119218:	e0bfdd15 	stw	r2,-140(fp)

	if ( bSuccees != TRUE ) {
8111921c:	e0bfdd17 	ldw	r2,-140(fp)
81119220:	10800060 	cmpeqi	r2,r2,1
81119224:	1000011e 	bne	r2,zero,8111922c <vSendLog+0xe8>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendLog();
81119228:	111c5440 	call	8111c544 <vCouldNotSendLog>
	}
}
8111922c:	0001883a 	nop
81119230:	e037883a 	mov	sp,fp
81119234:	dfc00117 	ldw	ra,4(sp)
81119238:	df000017 	ldw	fp,0(sp)
8111923c:	dec00204 	addi	sp,sp,8
81119240:	f800283a 	ret

81119244 <usiGetIdCMD>:

unsigned short int usiGetIdCMD ( void ) {
81119244:	deffff04 	addi	sp,sp,-4
81119248:	de00012e 	bgeu	sp,et,81119250 <usiGetIdCMD+0xc>
8111924c:	003b68fa 	trap	3
81119250:	df000015 	stw	fp,0(sp)
81119254:	d839883a 	mov	fp,sp
    if ( usiIdCMD > 65534 )
81119258:	d0a0680b 	ldhu	r2,-32352(gp)
8111925c:	10ffffcc 	andi	r3,r2,65535
81119260:	00bfffd4 	movui	r2,65535
81119264:	1880031e 	bne	r3,r2,81119274 <usiGetIdCMD+0x30>
        usiIdCMD = 2;
81119268:	00800084 	movi	r2,2
8111926c:	d0a0680d 	sth	r2,-32352(gp)
81119270:	00000306 	br	81119280 <usiGetIdCMD+0x3c>
    else
        usiIdCMD++;
81119274:	d0a0680b 	ldhu	r2,-32352(gp)
81119278:	10800044 	addi	r2,r2,1
8111927c:	d0a0680d 	sth	r2,-32352(gp)

    return usiIdCMD;
81119280:	d0a0680b 	ldhu	r2,-32352(gp)
}
81119284:	e037883a 	mov	sp,fp
81119288:	df000017 	ldw	fp,0(sp)
8111928c:	dec00104 	addi	sp,sp,4
81119290:	f800283a 	ret

81119294 <siPosStr>:

inline short int siPosStr( char *buffer, char cValue) {
81119294:	defffb04 	addi	sp,sp,-20
81119298:	de00012e 	bgeu	sp,et,811192a0 <siPosStr+0xc>
8111929c:	003b68fa 	trap	3
811192a0:	dfc00415 	stw	ra,16(sp)
811192a4:	df000315 	stw	fp,12(sp)
811192a8:	df000304 	addi	fp,sp,12
811192ac:	e13ffe15 	stw	r4,-8(fp)
811192b0:	2805883a 	mov	r2,r5
811192b4:	e0bfff05 	stb	r2,-4(fp)
    char cTempChar[2] = "";
811192b8:	e03ffd0d 	sth	zero,-12(fp)
    cTempChar[0] = cValue; /* This step was add for performance. The command strcspn needs "" (const char *) */
811192bc:	e0bfff03 	ldbu	r2,-4(fp)
811192c0:	e0bffd05 	stb	r2,-12(fp)
    return strcspn(buffer, cTempChar);
811192c4:	e17ffd04 	addi	r5,fp,-12
811192c8:	e13ffe17 	ldw	r4,-8(fp)
811192cc:	1122afc0 	call	81122afc <strcspn>
}
811192d0:	e037883a 	mov	sp,fp
811192d4:	dfc00117 	ldw	ra,4(sp)
811192d8:	df000017 	ldw	fp,0(sp)
811192dc:	dec00204 	addi	sp,sp,8
811192e0:	f800283a 	ret

811192e4 <vTimeoutCheck>:


void vTimeoutCheck (void *p_arg)
{
811192e4:	defffc04 	addi	sp,sp,-16
811192e8:	de00012e 	bgeu	sp,et,811192f0 <vTimeoutCheck+0xc>
811192ec:	003b68fa 	trap	3
811192f0:	dfc00315 	stw	ra,12(sp)
811192f4:	df000215 	stw	fp,8(sp)
811192f8:	df000204 	addi	fp,sp,8
811192fc:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;

	/* Time to check the (re)transmission buffers, posting a semaphore to sync the task that will threat timeout logic (vTimeoutCheckerTask) */
	error_code = OSSemPost(xSemTimeoutChecker);
81119300:	d0a06717 	ldw	r2,-32356(gp)
81119304:	1009883a 	mov	r4,r2
81119308:	113e8480 	call	8113e848 <OSSemPost>
8111930c:	e0bffe05 	stb	r2,-8(fp)
	if ( error_code != OS_ERR_NONE ) {
81119310:	e0bffe03 	ldbu	r2,-8(fp)
81119314:	10000126 	beq	r2,zero,8111931c <vTimeoutCheck+0x38>
		vFailPostBlockingSemTimeoutTask();
81119318:	111c2040 	call	8111c204 <vFailPostBlockingSemTimeoutTask>
	}
}
8111931c:	0001883a 	nop
81119320:	e037883a 	mov	sp,fp
81119324:	dfc00117 	ldw	ra,4(sp)
81119328:	df000017 	ldw	fp,0(sp)
8111932c:	dec00204 	addi	sp,sp,8
81119330:	f800283a 	ret

81119334 <vSendPusTM64>:


/* Send through a medium buffer */
void vSendPusTM64 ( tTMPus xPcktPus ) {
81119334:	deffe304 	addi	sp,sp,-116
81119338:	de00012e 	bgeu	sp,et,81119340 <vSendPusTM64+0xc>
8111933c:	003b68fa 	trap	3
81119340:	dfc01815 	stw	ra,96(sp)
81119344:	df001715 	stw	fp,92(sp)
81119348:	df001704 	addi	fp,sp,92
8111934c:	e1000215 	stw	r4,8(fp)
81119350:	e1400315 	stw	r5,12(fp)
81119354:	e1800415 	stw	r6,16(fp)
81119358:	e1c00515 	stw	r7,20(fp)
    char cBufferPus[64] = "";
8111935c:	e03fef8d 	sth	zero,-66(fp)
81119360:	e03ff00d 	sth	zero,-64(fp)
81119364:	e0bff084 	addi	r2,fp,-62
81119368:	00c00f04 	movi	r3,60
8111936c:	180d883a 	mov	r6,r3
81119370:	000b883a 	mov	r5,zero
81119374:	1009883a 	mov	r4,r2
81119378:	11221a40 	call	811221a4 <memset>
    unsigned char crc = 0;
8111937c:	e03fed45 	stb	zero,-75(fp)
	unsigned char ucIL = 0;
81119380:	e03fed05 	stb	zero,-76(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81119384:	e03fee15 	stw	zero,-72(fp)

    usiIdCMDLocal = usiGetIdCMD();
81119388:	11192440 	call	81119244 <usiGetIdCMD>
8111938c:	e0bfef0d 	sth	r2,-68(fp)

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
81119390:	e1bfef0b 	ldhu	r6,-68(fp)
81119394:	e080040b 	ldhu	r2,16(fp)
81119398:	11ffffcc 	andi	r7,r2,65535
8111939c:	e080048b 	ldhu	r2,18(fp)
811193a0:	10bfffcc 	andi	r2,r2,65535
811193a4:	e0c0050b 	ldhu	r3,20(fp)
811193a8:	18ffffcc 	andi	r3,r3,65535
811193ac:	e100058b 	ldhu	r4,22(fp)
811193b0:	213fffcc 	andi	r4,r4,65535
811193b4:	e140060b 	ldhu	r5,24(fp)
811193b8:	297fffcc 	andi	r5,r5,65535
811193bc:	e23fef84 	addi	r8,fp,-66
811193c0:	d9400315 	stw	r5,12(sp)
811193c4:	d9000215 	stw	r4,8(sp)
811193c8:	d8c00115 	stw	r3,4(sp)
811193cc:	d8800015 	stw	r2,0(sp)
811193d0:	01604574 	movhi	r5,33045
811193d4:	29794d04 	addi	r5,r5,-6860
811193d8:	4009883a 	mov	r4,r8
811193dc:	11229340 	call	81122934 <sprintf>
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
811193e0:	e03fed05 	stb	zero,-76(fp)
811193e4:	00001206 	br	81119430 <vSendPusTM64+0xfc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
811193e8:	e0bfed03 	ldbu	r2,-76(fp)
811193ec:	10800284 	addi	r2,r2,10
811193f0:	1085883a 	add	r2,r2,r2
811193f4:	e0c00204 	addi	r3,fp,8
811193f8:	1885883a 	add	r2,r3,r2
811193fc:	1080000b 	ldhu	r2,0(r2)
81119400:	113fffcc 	andi	r4,r2,65535
81119404:	e0ffef84 	addi	r3,fp,-66
81119408:	e0bfef84 	addi	r2,fp,-66
8111940c:	200f883a 	mov	r7,r4
81119410:	180d883a 	mov	r6,r3
81119414:	01604574 	movhi	r5,33045
81119418:	29795404 	addi	r5,r5,-6832
8111941c:	1009883a 	mov	r4,r2
81119420:	11229340 	call	81122934 <sprintf>
    usiIdCMDLocal = usiGetIdCMD();

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
81119424:	e0bfed03 	ldbu	r2,-76(fp)
81119428:	10800044 	addi	r2,r2,1
8111942c:	e0bfed05 	stb	r2,-76(fp)
81119430:	e0800683 	ldbu	r2,26(fp)
81119434:	10803fcc 	andi	r2,r2,255
81119438:	e0ffed03 	ldbu	r3,-76(fp)
8111943c:	18bfea36 	bltu	r3,r2,811193e8 <__reset+0xfb0f93e8>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
	}
	/* Calculate the crc, append it and finish the string with ";" character */
    crc = ucCrc8wInit( cBufferPus , strlen(cBufferPus));
81119440:	e0bfef84 	addi	r2,fp,-66
81119444:	1009883a 	mov	r4,r2
81119448:	1122b480 	call	81122b48 <strlen>
8111944c:	1007883a 	mov	r3,r2
81119450:	e0bfef84 	addi	r2,fp,-66
81119454:	180b883a 	mov	r5,r3
81119458:	1009883a 	mov	r4,r2
8111945c:	111b1fc0 	call	8111b1fc <ucCrc8wInit>
81119460:	e0bfed45 	stb	r2,-75(fp)
    sprintf(cBufferPus, "%s|%hhu;", cBufferPus, crc );
81119464:	e13fed43 	ldbu	r4,-75(fp)
81119468:	e0ffef84 	addi	r3,fp,-66
8111946c:	e0bfef84 	addi	r2,fp,-66
81119470:	200f883a 	mov	r7,r4
81119474:	180d883a 	mov	r6,r3
81119478:	01604574 	movhi	r5,33045
8111947c:	29794304 	addi	r5,r5,-6900
81119480:	1009883a 	mov	r4,r2
81119484:	11229340 	call	81122934 <sprintf>

	bSuccees = bSendUART64v2(cBufferPus, usiIdCMDLocal);
81119488:	e0bfef0b 	ldhu	r2,-68(fp)
8111948c:	10ffffcc 	andi	r3,r2,65535
81119490:	18e0001c 	xori	r3,r3,32768
81119494:	18e00004 	addi	r3,r3,-32768
81119498:	e0bfef84 	addi	r2,fp,-66
8111949c:	180b883a 	mov	r5,r3
811194a0:	1009883a 	mov	r4,r2
811194a4:	11186940 	call	81118694 <bSendUART64v2>
811194a8:	e0bfee15 	stw	r2,-72(fp)

	if ( bSuccees != TRUE ) {
811194ac:	e0bfee17 	ldw	r2,-72(fp)
811194b0:	10800060 	cmpeqi	r2,r2,1
811194b4:	1000031e 	bne	r2,zero,811194c4 <vSendPusTM64+0x190>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTMPusCommand( cBufferPus );
811194b8:	e0bfef84 	addi	r2,fp,-66
811194bc:	1009883a 	mov	r4,r2
811194c0:	111c5ac0 	call	8111c5ac <vCouldNotSendTMPusCommand>
	}
}
811194c4:	0001883a 	nop
811194c8:	e037883a 	mov	sp,fp
811194cc:	dfc00117 	ldw	ra,4(sp)
811194d0:	df000017 	ldw	fp,0(sp)
811194d4:	dec00604 	addi	sp,sp,24
811194d8:	f800283a 	ret

811194dc <vSendPusTM128>:

/* Send through a big buffer */
void vSendPusTM128 ( tTMPus xPcktPus ) {
811194dc:	deffd304 	addi	sp,sp,-180
811194e0:	de00012e 	bgeu	sp,et,811194e8 <vSendPusTM128+0xc>
811194e4:	003b68fa 	trap	3
811194e8:	dfc02815 	stw	ra,160(sp)
811194ec:	df002715 	stw	fp,156(sp)
811194f0:	df002704 	addi	fp,sp,156
811194f4:	e1000215 	stw	r4,8(fp)
811194f8:	e1400315 	stw	r5,12(fp)
811194fc:	e1800415 	stw	r6,16(fp)
81119500:	e1c00515 	stw	r7,20(fp)
    char cBufferPus[128] = "";
81119504:	e03fdf8d 	sth	zero,-130(fp)
81119508:	e03fe00d 	sth	zero,-128(fp)
8111950c:	e0bfe084 	addi	r2,fp,-126
81119510:	00c01f04 	movi	r3,124
81119514:	180d883a 	mov	r6,r3
81119518:	000b883a 	mov	r5,zero
8111951c:	1009883a 	mov	r4,r2
81119520:	11221a40 	call	811221a4 <memset>
    unsigned char crc = 0;
81119524:	e03fdd45 	stb	zero,-139(fp)
	unsigned char ucIL = 0;
81119528:	e03fdd05 	stb	zero,-140(fp)
    unsigned short int usiIdCMDLocal;
	bool bSuccees = FALSE;
8111952c:	e03fde15 	stw	zero,-136(fp)

    usiIdCMDLocal = usiGetIdCMD();
81119530:	11192440 	call	81119244 <usiGetIdCMD>
81119534:	e0bfdf0d 	sth	r2,-132(fp)

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
81119538:	e1bfdf0b 	ldhu	r6,-132(fp)
8111953c:	e080040b 	ldhu	r2,16(fp)
81119540:	11ffffcc 	andi	r7,r2,65535
81119544:	e080048b 	ldhu	r2,18(fp)
81119548:	10bfffcc 	andi	r2,r2,65535
8111954c:	e0c0050b 	ldhu	r3,20(fp)
81119550:	18ffffcc 	andi	r3,r3,65535
81119554:	e100058b 	ldhu	r4,22(fp)
81119558:	213fffcc 	andi	r4,r4,65535
8111955c:	e140060b 	ldhu	r5,24(fp)
81119560:	297fffcc 	andi	r5,r5,65535
81119564:	e23fdf84 	addi	r8,fp,-130
81119568:	d9400315 	stw	r5,12(sp)
8111956c:	d9000215 	stw	r4,8(sp)
81119570:	d8c00115 	stw	r3,4(sp)
81119574:	d8800015 	stw	r2,0(sp)
81119578:	01604574 	movhi	r5,33045
8111957c:	29794d04 	addi	r5,r5,-6860
81119580:	4009883a 	mov	r4,r8
81119584:	11229340 	call	81122934 <sprintf>
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
81119588:	e03fdd05 	stb	zero,-140(fp)
8111958c:	00001206 	br	811195d8 <vSendPusTM128+0xfc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
81119590:	e0bfdd03 	ldbu	r2,-140(fp)
81119594:	10800284 	addi	r2,r2,10
81119598:	1085883a 	add	r2,r2,r2
8111959c:	e0c00204 	addi	r3,fp,8
811195a0:	1885883a 	add	r2,r3,r2
811195a4:	1080000b 	ldhu	r2,0(r2)
811195a8:	113fffcc 	andi	r4,r2,65535
811195ac:	e0ffdf84 	addi	r3,fp,-130
811195b0:	e0bfdf84 	addi	r2,fp,-130
811195b4:	200f883a 	mov	r7,r4
811195b8:	180d883a 	mov	r6,r3
811195bc:	01604574 	movhi	r5,33045
811195c0:	29795404 	addi	r5,r5,-6832
811195c4:	1009883a 	mov	r4,r2
811195c8:	11229340 	call	81122934 <sprintf>
    usiIdCMDLocal = usiGetIdCMD();

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
811195cc:	e0bfdd03 	ldbu	r2,-140(fp)
811195d0:	10800044 	addi	r2,r2,1
811195d4:	e0bfdd05 	stb	r2,-140(fp)
811195d8:	e0800683 	ldbu	r2,26(fp)
811195dc:	10803fcc 	andi	r2,r2,255
811195e0:	e0ffdd03 	ldbu	r3,-140(fp)
811195e4:	18bfea36 	bltu	r3,r2,81119590 <__reset+0xfb0f9590>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
	}
	/* Calculate the crc, append it and finish the string with ";" character */
    crc = ucCrc8wInit( cBufferPus , strlen(cBufferPus));
811195e8:	e0bfdf84 	addi	r2,fp,-130
811195ec:	1009883a 	mov	r4,r2
811195f0:	1122b480 	call	81122b48 <strlen>
811195f4:	1007883a 	mov	r3,r2
811195f8:	e0bfdf84 	addi	r2,fp,-130
811195fc:	180b883a 	mov	r5,r3
81119600:	1009883a 	mov	r4,r2
81119604:	111b1fc0 	call	8111b1fc <ucCrc8wInit>
81119608:	e0bfdd45 	stb	r2,-139(fp)
    sprintf(cBufferPus, "%s|%hhu;", cBufferPus, crc );
8111960c:	e13fdd43 	ldbu	r4,-139(fp)
81119610:	e0ffdf84 	addi	r3,fp,-130
81119614:	e0bfdf84 	addi	r2,fp,-130
81119618:	200f883a 	mov	r7,r4
8111961c:	180d883a 	mov	r6,r3
81119620:	01604574 	movhi	r5,33045
81119624:	29794304 	addi	r5,r5,-6900
81119628:	1009883a 	mov	r4,r2
8111962c:	11229340 	call	81122934 <sprintf>

	bSuccees = bSendUART128v2(cBufferPus, usiIdCMDLocal);
81119630:	e0bfdf0b 	ldhu	r2,-132(fp)
81119634:	10ffffcc 	andi	r3,r2,65535
81119638:	18e0001c 	xori	r3,r3,32768
8111963c:	18e00004 	addi	r3,r3,-32768
81119640:	e0bfdf84 	addi	r2,fp,-130
81119644:	180b883a 	mov	r5,r3
81119648:	1009883a 	mov	r4,r2
8111964c:	11183a40 	call	811183a4 <bSendUART128v2>
81119650:	e0bfde15 	stw	r2,-136(fp)

	if ( bSuccees != TRUE ) {
81119654:	e0bfde17 	ldw	r2,-136(fp)
81119658:	10800060 	cmpeqi	r2,r2,1
8111965c:	1000031e 	bne	r2,zero,8111966c <vSendPusTM128+0x190>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTMPusCommand( cBufferPus );
81119660:	e0bfdf84 	addi	r2,fp,-130
81119664:	1009883a 	mov	r4,r2
81119668:	111c5ac0 	call	8111c5ac <vCouldNotSendTMPusCommand>
	}
}
8111966c:	0001883a 	nop
81119670:	e037883a 	mov	sp,fp
81119674:	dfc00117 	ldw	ra,4(sp)
81119678:	df000017 	ldw	fp,0(sp)
8111967c:	dec00604 	addi	sp,sp,24
81119680:	f800283a 	ret

81119684 <vTMPusTestConnection>:
/* TM_SCAM_TEST_CONNECTION */
/* 
hp-pck-type		hp-pid		hp-pcat		hp-srv-type		hp-srv-subtype
0				112			0			17				2
*/
void vTMPusTestConnection( unsigned short int usiPusId ) {
81119684:	deffd704 	addi	sp,sp,-164
81119688:	de00012e 	bgeu	sp,et,81119690 <vTMPusTestConnection+0xc>
8111968c:	003b68fa 	trap	3
81119690:	dfc02815 	stw	ra,160(sp)
81119694:	df002715 	stw	fp,156(sp)
81119698:	df002704 	addi	fp,sp,156
8111969c:	2005883a 	mov	r2,r4
811196a0:	e0bfff0d 	sth	r2,-4(fp)
	tTMPus xTmPusL;

	/* For now is hardcoded after full release of the pus I will create defines */
	xTmPusL.usiPusId = usiPusId;
811196a4:	e0bfff0b 	ldhu	r2,-4(fp)
811196a8:	e0bfee0d 	sth	r2,-72(fp)
	xTmPusL.usiPid = 112;
811196ac:	00801c04 	movi	r2,112
811196b0:	e0bfec0d 	sth	r2,-80(fp)
	xTmPusL.usiCat = 0;
811196b4:	e03fec8d 	sth	zero,-78(fp)
	xTmPusL.usiType = 17;
811196b8:	00800444 	movi	r2,17
811196bc:	e0bfed0d 	sth	r2,-76(fp)
	xTmPusL.usiSubType = 2;
811196c0:	00800084 	movi	r2,2
811196c4:	e0bfed8d 	sth	r2,-74(fp)

	vSendPusTM64( xTmPusL );
811196c8:	d809883a 	mov	r4,sp
811196cc:	e0bfee04 	addi	r2,fp,-72
811196d0:	00c01104 	movi	r3,68
811196d4:	180d883a 	mov	r6,r3
811196d8:	100b883a 	mov	r5,r2
811196dc:	11220540 	call	81122054 <memcpy>
811196e0:	e13fea17 	ldw	r4,-88(fp)
811196e4:	e17feb17 	ldw	r5,-84(fp)
811196e8:	e1bfec17 	ldw	r6,-80(fp)
811196ec:	e1ffed17 	ldw	r7,-76(fp)
811196f0:	11193340 	call	81119334 <vSendPusTM64>
}
811196f4:	0001883a 	nop
811196f8:	e037883a 	mov	sp,fp
811196fc:	dfc00117 	ldw	ra,4(sp)
81119700:	df000017 	ldw	fp,0(sp)
81119704:	dec00204 	addi	sp,sp,8
81119708:	f800283a 	ret

8111970c <vLoadDefaultETHConf>:
/*Configuration related to the eth connection*/
TConfEth xConfEth;
TDefaults xDefaults;


bool vLoadDefaultETHConf( void ){
8111970c:	defff504 	addi	sp,sp,-44
81119710:	de00012e 	bgeu	sp,et,81119718 <vLoadDefaultETHConf+0xc>
81119714:	003b68fa 	trap	3
81119718:	dfc00a15 	stw	ra,40(sp)
8111971c:	df000915 	stw	fp,36(sp)
81119720:	dc000815 	stw	r16,32(sp)
81119724:	df000904 	addi	fp,sp,36
	short int siFile, sidhcpTemp;
	bool bSuccess = FALSE;
81119728:	e03ff715 	stw	zero,-36(fp)
	bool bEOF = FALSE;
8111972c:	e03ff815 	stw	zero,-32(fp)
	bool close = FALSE;
81119730:	e03ffb15 	stw	zero,-20(fp)
	unsigned char ucParser;
	char c, *p_inteiro;
	char inteiro[8];


	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){
81119734:	d0a07617 	ldw	r2,-32296(gp)
81119738:	10800058 	cmpnei	r2,r2,1
8111973c:	1002051e 	bne	r2,zero,81119f54 <vLoadDefaultETHConf+0x848>
81119740:	111e3b80 	call	8111e3b8 <bSDcardIsPresent>
81119744:	10020326 	beq	r2,zero,81119f54 <vLoadDefaultETHConf+0x848>
81119748:	111e3e80 	call	8111e3e8 <bSDcardFAT16Check>
8111974c:	10020126 	beq	r2,zero,81119f54 <vLoadDefaultETHConf+0x848>

		siFile = siOpenFile( ETH_FILE_NAME );
81119750:	01204574 	movhi	r4,33045
81119754:	21395604 	addi	r4,r4,-6824
81119758:	111e5100 	call	8111e510 <siOpenFile>
8111975c:	e0bffc0d 	sth	r2,-16(fp)

		if ( siFile >= 0 ){
81119760:	e0bffc0f 	ldh	r2,-16(fp)
81119764:	1001f316 	blt	r2,zero,81119f34 <vLoadDefaultETHConf+0x828>

			memset( &(inteiro) , 10 , sizeof( inteiro ) );
81119768:	e0bffd04 	addi	r2,fp,-12
8111976c:	01800204 	movi	r6,8
81119770:	01400284 	movi	r5,10
81119774:	1009883a 	mov	r4,r2
81119778:	11221a40 	call	811221a4 <memset>
			p_inteiro = inteiro;
8111977c:	e0bffd04 	addi	r2,fp,-12
81119780:	e0bffa15 	stw	r2,-24(fp)

			do {
				c = cGetNextChar(siFile);
81119784:	e0bffc0f 	ldh	r2,-16(fp)
81119788:	1009883a 	mov	r4,r2
8111978c:	111e58c0 	call	8111e58c <cGetNextChar>
81119790:	e0bff945 	stb	r2,-27(fp)
				//printf("%c \n", c);
				switch (c) {
81119794:	e0bff947 	ldb	r2,-27(fp)
81119798:	10800084 	addi	r2,r2,2
8111979c:	10c015a8 	cmpgeui	r3,r2,86
811197a0:	1801d81e 	bne	r3,zero,81119f04 <vLoadDefaultETHConf+0x7f8>
811197a4:	100690ba 	slli	r3,r2,2
811197a8:	00a044b4 	movhi	r2,33042
811197ac:	10a5ef04 	addi	r2,r2,-26692
811197b0:	1885883a 	add	r2,r3,r2
811197b4:	10800017 	ldw	r2,0(r2)
811197b8:	1000683a 	jmp	r2
811197bc:	81119954 	ori	r4,r16,18021
811197c0:	81119948 	cmpgei	r4,r16,18021
811197c4:	81119f04 	addi	r4,r16,18044
811197c8:	81119f04 	addi	r4,r16,18044
811197cc:	81119f04 	addi	r4,r16,18044
811197d0:	81119f04 	addi	r4,r16,18044
811197d4:	81119f04 	addi	r4,r16,18044
811197d8:	81119f04 	addi	r4,r16,18044
811197dc:	81119f04 	addi	r4,r16,18044
811197e0:	81119f04 	addi	r4,r16,18044
811197e4:	81119f04 	addi	r4,r16,18044
811197e8:	81119f04 	addi	r4,r16,18044
811197ec:	81119f24 	muli	r4,r16,18044
811197f0:	81119f04 	addi	r4,r16,18044
811197f4:	81119f04 	addi	r4,r16,18044
811197f8:	81119f24 	muli	r4,r16,18044
811197fc:	81119f04 	addi	r4,r16,18044
81119800:	81119f04 	addi	r4,r16,18044
81119804:	81119f04 	addi	r4,r16,18044
81119808:	81119f04 	addi	r4,r16,18044
8111980c:	81119f04 	addi	r4,r16,18044
81119810:	81119f04 	addi	r4,r16,18044
81119814:	81119f04 	addi	r4,r16,18044
81119818:	81119f04 	addi	r4,r16,18044
8111981c:	81119f04 	addi	r4,r16,18044
81119820:	81119f04 	addi	r4,r16,18044
81119824:	81119f04 	addi	r4,r16,18044
81119828:	81119f04 	addi	r4,r16,18044
8111982c:	81119f04 	addi	r4,r16,18044
81119830:	81119f04 	addi	r4,r16,18044
81119834:	81119f04 	addi	r4,r16,18044
81119838:	81119f04 	addi	r4,r16,18044
8111983c:	81119f04 	addi	r4,r16,18044
81119840:	81119f04 	addi	r4,r16,18044
81119844:	81119f24 	muli	r4,r16,18044
81119848:	81119f04 	addi	r4,r16,18044
8111984c:	81119f04 	addi	r4,r16,18044
81119850:	81119f04 	addi	r4,r16,18044
81119854:	81119f04 	addi	r4,r16,18044
81119858:	81119f04 	addi	r4,r16,18044
8111985c:	81119f04 	addi	r4,r16,18044
81119860:	81119914 	ori	r4,r16,18020
81119864:	81119f04 	addi	r4,r16,18044
81119868:	81119f04 	addi	r4,r16,18044
8111986c:	81119f04 	addi	r4,r16,18044
81119870:	81119f04 	addi	r4,r16,18044
81119874:	81119f04 	addi	r4,r16,18044
81119878:	81119f04 	addi	r4,r16,18044
8111987c:	81119f04 	addi	r4,r16,18044
81119880:	81119f04 	addi	r4,r16,18044
81119884:	81119f04 	addi	r4,r16,18044
81119888:	81119f04 	addi	r4,r16,18044
8111988c:	81119f04 	addi	r4,r16,18044
81119890:	81119f04 	addi	r4,r16,18044
81119894:	81119f04 	addi	r4,r16,18044
81119898:	81119f04 	addi	r4,r16,18044
8111989c:	81119f04 	addi	r4,r16,18044
811198a0:	81119f04 	addi	r4,r16,18044
811198a4:	81119f04 	addi	r4,r16,18044
811198a8:	81119f04 	addi	r4,r16,18044
811198ac:	81119f04 	addi	r4,r16,18044
811198b0:	81119f04 	addi	r4,r16,18044
811198b4:	81119ebc 	xorhi	r4,r16,18042
811198b8:	81119f04 	addi	r4,r16,18044
811198bc:	81119f04 	addi	r4,r16,18044
811198c0:	81119f04 	addi	r4,r16,18044
811198c4:	81119f04 	addi	r4,r16,18044
811198c8:	81119f04 	addi	r4,r16,18044
811198cc:	81119f04 	addi	r4,r16,18044
811198d0:	81119f04 	addi	r4,r16,18044
811198d4:	81119dec 	andhi	r4,r16,18039
811198d8:	81119f04 	addi	r4,r16,18044
811198dc:	81119f04 	addi	r4,r16,18044
811198e0:	81119b18 	cmpnei	r4,r16,18028
811198e4:	81119c74 	orhi	r4,r16,18033
811198e8:	81119a4c 	andi	r4,r16,18025
811198ec:	81119f04 	addi	r4,r16,18044
811198f0:	81119f04 	addi	r4,r16,18044
811198f4:	81119f04 	addi	r4,r16,18044
811198f8:	8111997c 	xorhi	r4,r16,18021
811198fc:	81119f04 	addi	r4,r16,18044
81119900:	81119f04 	addi	r4,r16,18044
81119904:	81119be8 	cmpgeui	r4,r16,18031
81119908:	81119f04 	addi	r4,r16,18044
8111990c:	81119f04 	addi	r4,r16,18044
81119910:	81119d1c 	xori	r4,r16,18036
					case 39:// single quote '
						c = cGetNextChar(siFile);
81119914:	e0bffc0f 	ldh	r2,-16(fp)
81119918:	1009883a 	mov	r4,r2
8111991c:	111e58c0 	call	8111e58c <cGetNextChar>
81119920:	e0bff945 	stb	r2,-27(fp)
						while ( c != 39 ){
81119924:	00000406 	br	81119938 <vLoadDefaultETHConf+0x22c>
							c = cGetNextChar(siFile);
81119928:	e0bffc0f 	ldh	r2,-16(fp)
8111992c:	1009883a 	mov	r4,r2
81119930:	111e58c0 	call	8111e58c <cGetNextChar>
81119934:	e0bff945 	stb	r2,-27(fp)
				c = cGetNextChar(siFile);
				//printf("%c \n", c);
				switch (c) {
					case 39:// single quote '
						c = cGetNextChar(siFile);
						while ( c != 39 ){
81119938:	e0bff947 	ldb	r2,-27(fp)
8111993c:	108009d8 	cmpnei	r2,r2,39
81119940:	103ff91e 	bne	r2,zero,81119928 <__reset+0xfb0f9928>
							c = cGetNextChar(siFile);
						}
						break;
81119944:	00017806 	br	81119f28 <vLoadDefaultETHConf+0x81c>
					case -1: 	//EOF
						bEOF = TRUE;
81119948:	00800044 	movi	r2,1
8111994c:	e0bff815 	stw	r2,-32(fp)
						break;
81119950:	00017506 	br	81119f28 <vLoadDefaultETHConf+0x81c>
					case -2: 	//EOF
						#ifdef DEBUG_ON
							debug(fp,"SDCard: Problem with SDCard");
81119954:	d0a06217 	ldw	r2,-32376(gp)
81119958:	100f883a 	mov	r7,r2
8111995c:	018006c4 	movi	r6,27
81119960:	01400044 	movi	r5,1
81119964:	01204574 	movhi	r4,33045
81119968:	21395804 	addi	r4,r4,-6816
8111996c:	11216400 	call	81121640 <fwrite>
						#endif
						bEOF = TRUE;
81119970:	00800044 	movi	r2,1
81119974:	e0bff815 	stw	r2,-32(fp)
						break;
81119978:	00016b06 	br	81119f28 <vLoadDefaultETHConf+0x81c>
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
					case 'M':

						ucParser = 0;
8111997c:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81119980:	e0bffc0f 	ldh	r2,-16(fp)
81119984:	1009883a 	mov	r4,r2
81119988:	111e58c0 	call	8111e58c <cGetNextChar>
8111998c:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81119990:	d0e00317 	ldw	r3,-32756(gp)
81119994:	e0bff947 	ldb	r2,-27(fp)
81119998:	10800044 	addi	r2,r2,1
8111999c:	1885883a 	add	r2,r3,r2
811199a0:	10800003 	ldbu	r2,0(r2)
811199a4:	10803fcc 	andi	r2,r2,255
811199a8:	1080010c 	andi	r2,r2,4
811199ac:	10000626 	beq	r2,zero,811199c8 <vLoadDefaultETHConf+0x2bc>
									(*p_inteiro) = c;
811199b0:	e0bffa17 	ldw	r2,-24(fp)
811199b4:	e0fff943 	ldbu	r3,-27(fp)
811199b8:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
811199bc:	e0bffa17 	ldw	r2,-24(fp)
811199c0:	10800044 	addi	r2,r2,1
811199c4:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=58) && (c !=59) ); //ASCII: 58 = ':' 59 = ';'
811199c8:	e0bff947 	ldb	r2,-27(fp)
811199cc:	10800ea0 	cmpeqi	r2,r2,58
811199d0:	1000031e 	bne	r2,zero,811199e0 <vLoadDefaultETHConf+0x2d4>
811199d4:	e0bff947 	ldb	r2,-27(fp)
811199d8:	10800ed8 	cmpnei	r2,r2,59
811199dc:	103fe81e 	bne	r2,zero,81119980 <__reset+0xfb0f9980>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
811199e0:	e0bffa17 	ldw	r2,-24(fp)
811199e4:	00c00284 	movi	r3,10
811199e8:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucMAC[min_sim(ucParser,5)] = atoi( inteiro );
811199ec:	e0bff903 	ldbu	r2,-28(fp)
811199f0:	10800168 	cmpgeui	r2,r2,5
811199f4:	1000021e 	bne	r2,zero,81119a00 <vLoadDefaultETHConf+0x2f4>
811199f8:	e43ff903 	ldbu	r16,-28(fp)
811199fc:	00000106 	br	81119a04 <vLoadDefaultETHConf+0x2f8>
81119a00:	04000144 	movi	r16,5
81119a04:	e0bffd04 	addi	r2,fp,-12
81119a08:	1009883a 	mov	r4,r2
81119a0c:	1120e480 	call	81120e48 <atoi>
81119a10:	1007883a 	mov	r3,r2
81119a14:	00a045b4 	movhi	r2,33046
81119a18:	1099d604 	addi	r2,r2,26456
81119a1c:	1405883a 	add	r2,r2,r16
81119a20:	10800404 	addi	r2,r2,16
81119a24:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81119a28:	e0bffd04 	addi	r2,fp,-12
81119a2c:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81119a30:	e0bff903 	ldbu	r2,-28(fp)
81119a34:	10800044 	addi	r2,r2,1
81119a38:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81119a3c:	e0bff947 	ldb	r2,-27(fp)
81119a40:	10800ed8 	cmpnei	r2,r2,59
81119a44:	103fce1e 	bne	r2,zero,81119980 <__reset+0xfb0f9980>

						break;
81119a48:	00013706 	br	81119f28 <vLoadDefaultETHConf+0x81c>
					case 'I':

						ucParser = 0;
81119a4c:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81119a50:	e0bffc0f 	ldh	r2,-16(fp)
81119a54:	1009883a 	mov	r4,r2
81119a58:	111e58c0 	call	8111e58c <cGetNextChar>
81119a5c:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81119a60:	d0e00317 	ldw	r3,-32756(gp)
81119a64:	e0bff947 	ldb	r2,-27(fp)
81119a68:	10800044 	addi	r2,r2,1
81119a6c:	1885883a 	add	r2,r3,r2
81119a70:	10800003 	ldbu	r2,0(r2)
81119a74:	10803fcc 	andi	r2,r2,255
81119a78:	1080010c 	andi	r2,r2,4
81119a7c:	10000626 	beq	r2,zero,81119a98 <vLoadDefaultETHConf+0x38c>
									(*p_inteiro) = c;
81119a80:	e0bffa17 	ldw	r2,-24(fp)
81119a84:	e0fff943 	ldbu	r3,-27(fp)
81119a88:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81119a8c:	e0bffa17 	ldw	r2,-24(fp)
81119a90:	10800044 	addi	r2,r2,1
81119a94:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81119a98:	e0bff947 	ldb	r2,-27(fp)
81119a9c:	10800ba0 	cmpeqi	r2,r2,46
81119aa0:	1000031e 	bne	r2,zero,81119ab0 <vLoadDefaultETHConf+0x3a4>
81119aa4:	e0bff947 	ldb	r2,-27(fp)
81119aa8:	10800ed8 	cmpnei	r2,r2,59
81119aac:	103fe81e 	bne	r2,zero,81119a50 <__reset+0xfb0f9a50>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81119ab0:	e0bffa17 	ldw	r2,-24(fp)
81119ab4:	00c00284 	movi	r3,10
81119ab8:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucIP[min_sim(ucParser,3)] = atoi( inteiro );
81119abc:	e0bff903 	ldbu	r2,-28(fp)
81119ac0:	108000e8 	cmpgeui	r2,r2,3
81119ac4:	1000021e 	bne	r2,zero,81119ad0 <vLoadDefaultETHConf+0x3c4>
81119ac8:	e43ff903 	ldbu	r16,-28(fp)
81119acc:	00000106 	br	81119ad4 <vLoadDefaultETHConf+0x3c8>
81119ad0:	040000c4 	movi	r16,3
81119ad4:	e0bffd04 	addi	r2,fp,-12
81119ad8:	1009883a 	mov	r4,r2
81119adc:	1120e480 	call	81120e48 <atoi>
81119ae0:	1007883a 	mov	r3,r2
81119ae4:	00a045b4 	movhi	r2,33046
81119ae8:	1099d604 	addi	r2,r2,26456
81119aec:	1405883a 	add	r2,r2,r16
81119af0:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81119af4:	e0bffd04 	addi	r2,fp,-12
81119af8:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81119afc:	e0bff903 	ldbu	r2,-28(fp)
81119b00:	10800044 	addi	r2,r2,1
81119b04:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81119b08:	e0bff947 	ldb	r2,-27(fp)
81119b0c:	10800ed8 	cmpnei	r2,r2,59
81119b10:	103fcf1e 	bne	r2,zero,81119a50 <__reset+0xfb0f9a50>

						break;
81119b14:	00010406 	br	81119f28 <vLoadDefaultETHConf+0x81c>
					case 'G':

						ucParser = 0;
81119b18:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81119b1c:	e0bffc0f 	ldh	r2,-16(fp)
81119b20:	1009883a 	mov	r4,r2
81119b24:	111e58c0 	call	8111e58c <cGetNextChar>
81119b28:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81119b2c:	d0e00317 	ldw	r3,-32756(gp)
81119b30:	e0bff947 	ldb	r2,-27(fp)
81119b34:	10800044 	addi	r2,r2,1
81119b38:	1885883a 	add	r2,r3,r2
81119b3c:	10800003 	ldbu	r2,0(r2)
81119b40:	10803fcc 	andi	r2,r2,255
81119b44:	1080010c 	andi	r2,r2,4
81119b48:	10000626 	beq	r2,zero,81119b64 <vLoadDefaultETHConf+0x458>
									(*p_inteiro) = c;
81119b4c:	e0bffa17 	ldw	r2,-24(fp)
81119b50:	e0fff943 	ldbu	r3,-27(fp)
81119b54:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81119b58:	e0bffa17 	ldw	r2,-24(fp)
81119b5c:	10800044 	addi	r2,r2,1
81119b60:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81119b64:	e0bff947 	ldb	r2,-27(fp)
81119b68:	10800ba0 	cmpeqi	r2,r2,46
81119b6c:	1000031e 	bne	r2,zero,81119b7c <vLoadDefaultETHConf+0x470>
81119b70:	e0bff947 	ldb	r2,-27(fp)
81119b74:	10800ed8 	cmpnei	r2,r2,59
81119b78:	103fe81e 	bne	r2,zero,81119b1c <__reset+0xfb0f9b1c>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81119b7c:	e0bffa17 	ldw	r2,-24(fp)
81119b80:	00c00284 	movi	r3,10
81119b84:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucGTW[min_sim(ucParser,3)] = atoi( inteiro );
81119b88:	e0bff903 	ldbu	r2,-28(fp)
81119b8c:	108000e8 	cmpgeui	r2,r2,3
81119b90:	1000021e 	bne	r2,zero,81119b9c <vLoadDefaultETHConf+0x490>
81119b94:	e43ff903 	ldbu	r16,-28(fp)
81119b98:	00000106 	br	81119ba0 <vLoadDefaultETHConf+0x494>
81119b9c:	040000c4 	movi	r16,3
81119ba0:	e0bffd04 	addi	r2,fp,-12
81119ba4:	1009883a 	mov	r4,r2
81119ba8:	1120e480 	call	81120e48 <atoi>
81119bac:	1007883a 	mov	r3,r2
81119bb0:	00a045b4 	movhi	r2,33046
81119bb4:	1099d604 	addi	r2,r2,26456
81119bb8:	1405883a 	add	r2,r2,r16
81119bbc:	10800104 	addi	r2,r2,4
81119bc0:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81119bc4:	e0bffd04 	addi	r2,fp,-12
81119bc8:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81119bcc:	e0bff903 	ldbu	r2,-28(fp)
81119bd0:	10800044 	addi	r2,r2,1
81119bd4:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81119bd8:	e0bff947 	ldb	r2,-27(fp)
81119bdc:	10800ed8 	cmpnei	r2,r2,59
81119be0:	103fce1e 	bne	r2,zero,81119b1c <__reset+0xfb0f9b1c>

						break;
81119be4:	0000d006 	br	81119f28 <vLoadDefaultETHConf+0x81c>
					case 'P':
						ucParser = 0;
81119be8:	e03ff905 	stb	zero,-28(fp)
						do {
							c = cGetNextChar(siFile);
81119bec:	e0bffc0f 	ldh	r2,-16(fp)
81119bf0:	1009883a 	mov	r4,r2
81119bf4:	111e58c0 	call	8111e58c <cGetNextChar>
81119bf8:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
81119bfc:	d0e00317 	ldw	r3,-32756(gp)
81119c00:	e0bff947 	ldb	r2,-27(fp)
81119c04:	10800044 	addi	r2,r2,1
81119c08:	1885883a 	add	r2,r3,r2
81119c0c:	10800003 	ldbu	r2,0(r2)
81119c10:	10803fcc 	andi	r2,r2,255
81119c14:	1080010c 	andi	r2,r2,4
81119c18:	10000626 	beq	r2,zero,81119c34 <vLoadDefaultETHConf+0x528>
								(*p_inteiro) = c;
81119c1c:	e0bffa17 	ldw	r2,-24(fp)
81119c20:	e0fff943 	ldbu	r3,-27(fp)
81119c24:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
81119c28:	e0bffa17 	ldw	r2,-24(fp)
81119c2c:	10800044 	addi	r2,r2,1
81119c30:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
81119c34:	e0bff947 	ldb	r2,-27(fp)
81119c38:	10800ed8 	cmpnei	r2,r2,59
81119c3c:	103feb1e 	bne	r2,zero,81119bec <__reset+0xfb0f9bec>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81119c40:	e0bffa17 	ldw	r2,-24(fp)
81119c44:	00c00284 	movi	r3,10
81119c48:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xConfEth.siPortPUS = atoi( inteiro );
81119c4c:	e0bffd04 	addi	r2,fp,-12
81119c50:	1009883a 	mov	r4,r2
81119c54:	1120e480 	call	81120e48 <atoi>
81119c58:	1007883a 	mov	r3,r2
81119c5c:	00a045b4 	movhi	r2,33046
81119c60:	1099d604 	addi	r2,r2,26456
81119c64:	10c0058d 	sth	r3,22(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
81119c68:	e0bffd04 	addi	r2,fp,-12
81119c6c:	e0bffa15 	stw	r2,-24(fp)

						break;
81119c70:	0000ad06 	br	81119f28 <vLoadDefaultETHConf+0x81c>
					case 'H':

						do {
							c = cGetNextChar(siFile);
81119c74:	e0bffc0f 	ldh	r2,-16(fp)
81119c78:	1009883a 	mov	r4,r2
81119c7c:	111e58c0 	call	8111e58c <cGetNextChar>
81119c80:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
81119c84:	d0e00317 	ldw	r3,-32756(gp)
81119c88:	e0bff947 	ldb	r2,-27(fp)
81119c8c:	10800044 	addi	r2,r2,1
81119c90:	1885883a 	add	r2,r3,r2
81119c94:	10800003 	ldbu	r2,0(r2)
81119c98:	10803fcc 	andi	r2,r2,255
81119c9c:	1080010c 	andi	r2,r2,4
81119ca0:	10000626 	beq	r2,zero,81119cbc <vLoadDefaultETHConf+0x5b0>
								(*p_inteiro) = c;
81119ca4:	e0bffa17 	ldw	r2,-24(fp)
81119ca8:	e0fff943 	ldbu	r3,-27(fp)
81119cac:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
81119cb0:	e0bffa17 	ldw	r2,-24(fp)
81119cb4:	10800044 	addi	r2,r2,1
81119cb8:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
81119cbc:	e0bff947 	ldb	r2,-27(fp)
81119cc0:	10800ed8 	cmpnei	r2,r2,59
81119cc4:	103feb1e 	bne	r2,zero,81119c74 <__reset+0xfb0f9c74>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81119cc8:	e0bffa17 	ldw	r2,-24(fp)
81119ccc:	00c00284 	movi	r3,10
81119cd0:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						sidhcpTemp = atoi( inteiro );
81119cd4:	e0bffd04 	addi	r2,fp,-12
81119cd8:	1009883a 	mov	r4,r2
81119cdc:	1120e480 	call	81120e48 <atoi>
81119ce0:	e0bffc8d 	sth	r2,-14(fp)
						if (sidhcpTemp == 1)
81119ce4:	e0bffc8f 	ldh	r2,-14(fp)
81119ce8:	10800058 	cmpnei	r2,r2,1
81119cec:	1000051e 	bne	r2,zero,81119d04 <vLoadDefaultETHConf+0x5f8>
							xConfEth.bDHCP = TRUE;
81119cf0:	00a045b4 	movhi	r2,33046
81119cf4:	1099d604 	addi	r2,r2,26456
81119cf8:	00c00044 	movi	r3,1
81119cfc:	10c00615 	stw	r3,24(r2)
81119d00:	00000306 	br	81119d10 <vLoadDefaultETHConf+0x604>
						else
							xConfEth.bDHCP = FALSE;
81119d04:	00a045b4 	movhi	r2,33046
81119d08:	1099d604 	addi	r2,r2,26456
81119d0c:	10000615 	stw	zero,24(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
81119d10:	e0bffd04 	addi	r2,fp,-12
81119d14:	e0bffa15 	stw	r2,-24(fp)

						break;
81119d18:	00008306 	br	81119f28 <vLoadDefaultETHConf+0x81c>

					case 'S':

						ucParser = 0;
81119d1c:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81119d20:	e0bffc0f 	ldh	r2,-16(fp)
81119d24:	1009883a 	mov	r4,r2
81119d28:	111e58c0 	call	8111e58c <cGetNextChar>
81119d2c:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81119d30:	d0e00317 	ldw	r3,-32756(gp)
81119d34:	e0bff947 	ldb	r2,-27(fp)
81119d38:	10800044 	addi	r2,r2,1
81119d3c:	1885883a 	add	r2,r3,r2
81119d40:	10800003 	ldbu	r2,0(r2)
81119d44:	10803fcc 	andi	r2,r2,255
81119d48:	1080010c 	andi	r2,r2,4
81119d4c:	10000626 	beq	r2,zero,81119d68 <vLoadDefaultETHConf+0x65c>
									(*p_inteiro) = c;
81119d50:	e0bffa17 	ldw	r2,-24(fp)
81119d54:	e0fff943 	ldbu	r3,-27(fp)
81119d58:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81119d5c:	e0bffa17 	ldw	r2,-24(fp)
81119d60:	10800044 	addi	r2,r2,1
81119d64:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81119d68:	e0bff947 	ldb	r2,-27(fp)
81119d6c:	10800ba0 	cmpeqi	r2,r2,46
81119d70:	1000031e 	bne	r2,zero,81119d80 <vLoadDefaultETHConf+0x674>
81119d74:	e0bff947 	ldb	r2,-27(fp)
81119d78:	10800ed8 	cmpnei	r2,r2,59
81119d7c:	103fe81e 	bne	r2,zero,81119d20 <__reset+0xfb0f9d20>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81119d80:	e0bffa17 	ldw	r2,-24(fp)
81119d84:	00c00284 	movi	r3,10
81119d88:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucSubNet[min_sim(ucParser,3)] = atoi( inteiro );
81119d8c:	e0bff903 	ldbu	r2,-28(fp)
81119d90:	108000e8 	cmpgeui	r2,r2,3
81119d94:	1000021e 	bne	r2,zero,81119da0 <vLoadDefaultETHConf+0x694>
81119d98:	e43ff903 	ldbu	r16,-28(fp)
81119d9c:	00000106 	br	81119da4 <vLoadDefaultETHConf+0x698>
81119da0:	040000c4 	movi	r16,3
81119da4:	e0bffd04 	addi	r2,fp,-12
81119da8:	1009883a 	mov	r4,r2
81119dac:	1120e480 	call	81120e48 <atoi>
81119db0:	1007883a 	mov	r3,r2
81119db4:	00a045b4 	movhi	r2,33046
81119db8:	1099d604 	addi	r2,r2,26456
81119dbc:	1405883a 	add	r2,r2,r16
81119dc0:	10800204 	addi	r2,r2,8
81119dc4:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81119dc8:	e0bffd04 	addi	r2,fp,-12
81119dcc:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81119dd0:	e0bff903 	ldbu	r2,-28(fp)
81119dd4:	10800044 	addi	r2,r2,1
81119dd8:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81119ddc:	e0bff947 	ldb	r2,-27(fp)
81119de0:	10800ed8 	cmpnei	r2,r2,59
81119de4:	103fce1e 	bne	r2,zero,81119d20 <__reset+0xfb0f9d20>

						break;
81119de8:	00004f06 	br	81119f28 <vLoadDefaultETHConf+0x81c>
					case 'D':

						ucParser = 0;
81119dec:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81119df0:	e0bffc0f 	ldh	r2,-16(fp)
81119df4:	1009883a 	mov	r4,r2
81119df8:	111e58c0 	call	8111e58c <cGetNextChar>
81119dfc:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81119e00:	d0e00317 	ldw	r3,-32756(gp)
81119e04:	e0bff947 	ldb	r2,-27(fp)
81119e08:	10800044 	addi	r2,r2,1
81119e0c:	1885883a 	add	r2,r3,r2
81119e10:	10800003 	ldbu	r2,0(r2)
81119e14:	10803fcc 	andi	r2,r2,255
81119e18:	1080010c 	andi	r2,r2,4
81119e1c:	10000626 	beq	r2,zero,81119e38 <vLoadDefaultETHConf+0x72c>
									(*p_inteiro) = c;
81119e20:	e0bffa17 	ldw	r2,-24(fp)
81119e24:	e0fff943 	ldbu	r3,-27(fp)
81119e28:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81119e2c:	e0bffa17 	ldw	r2,-24(fp)
81119e30:	10800044 	addi	r2,r2,1
81119e34:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81119e38:	e0bff947 	ldb	r2,-27(fp)
81119e3c:	10800ba0 	cmpeqi	r2,r2,46
81119e40:	1000031e 	bne	r2,zero,81119e50 <vLoadDefaultETHConf+0x744>
81119e44:	e0bff947 	ldb	r2,-27(fp)
81119e48:	10800ed8 	cmpnei	r2,r2,59
81119e4c:	103fe81e 	bne	r2,zero,81119df0 <__reset+0xfb0f9df0>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81119e50:	e0bffa17 	ldw	r2,-24(fp)
81119e54:	00c00284 	movi	r3,10
81119e58:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucDNS[min_sim(ucParser,3)] = atoi( inteiro );
81119e5c:	e0bff903 	ldbu	r2,-28(fp)
81119e60:	108000e8 	cmpgeui	r2,r2,3
81119e64:	1000021e 	bne	r2,zero,81119e70 <vLoadDefaultETHConf+0x764>
81119e68:	e43ff903 	ldbu	r16,-28(fp)
81119e6c:	00000106 	br	81119e74 <vLoadDefaultETHConf+0x768>
81119e70:	040000c4 	movi	r16,3
81119e74:	e0bffd04 	addi	r2,fp,-12
81119e78:	1009883a 	mov	r4,r2
81119e7c:	1120e480 	call	81120e48 <atoi>
81119e80:	1007883a 	mov	r3,r2
81119e84:	00a045b4 	movhi	r2,33046
81119e88:	1099d604 	addi	r2,r2,26456
81119e8c:	1405883a 	add	r2,r2,r16
81119e90:	10800304 	addi	r2,r2,12
81119e94:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81119e98:	e0bffd04 	addi	r2,fp,-12
81119e9c:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81119ea0:	e0bff903 	ldbu	r2,-28(fp)
81119ea4:	10800044 	addi	r2,r2,1
81119ea8:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81119eac:	e0bff947 	ldb	r2,-27(fp)
81119eb0:	10800ed8 	cmpnei	r2,r2,59
81119eb4:	103fce1e 	bne	r2,zero,81119df0 <__reset+0xfb0f9df0>

						break;						
81119eb8:	00001b06 	br	81119f28 <vLoadDefaultETHConf+0x81c>
					case 0x3C: //"<"
						close = siCloseFile(siFile);
81119ebc:	e0bffc0f 	ldh	r2,-16(fp)
81119ec0:	1009883a 	mov	r4,r2
81119ec4:	111e54c0 	call	8111e54c <siCloseFile>
81119ec8:	e0bffb15 	stw	r2,-20(fp)
						if (close == FALSE){
81119ecc:	e0bffb17 	ldw	r2,-20(fp)
81119ed0:	1000071e 	bne	r2,zero,81119ef0 <vLoadDefaultETHConf+0x7e4>
							#ifdef DEBUG_ON
								debug(fp,"SDCard: Can't close the file.\n");
81119ed4:	d0a06217 	ldw	r2,-32376(gp)
81119ed8:	100f883a 	mov	r7,r2
81119edc:	01800784 	movi	r6,30
81119ee0:	01400044 	movi	r5,1
81119ee4:	01204574 	movhi	r4,33045
81119ee8:	21395f04 	addi	r4,r4,-6788
81119eec:	11216400 	call	81121640 <fwrite>
							#endif
						}
						/* End of Parser File */
						bEOF = TRUE;
81119ef0:	00800044 	movi	r2,1
81119ef4:	e0bff815 	stw	r2,-32(fp)
						bSuccess = TRUE; //pensar melhor
81119ef8:	00800044 	movi	r2,1
81119efc:	e0bff715 	stw	r2,-36(fp)
						break;
81119f00:	00000906 	br	81119f28 <vLoadDefaultETHConf+0x81c>
					default:
						#ifdef DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
81119f04:	d0a06217 	ldw	r2,-32376(gp)
81119f08:	100f883a 	mov	r7,r2
81119f0c:	01800844 	movi	r6,33
81119f10:	01400044 	movi	r5,1
81119f14:	01204574 	movhi	r4,33045
81119f18:	21396704 	addi	r4,r4,-6756
81119f1c:	11216400 	call	81121640 <fwrite>
						#endif
						break;
81119f20:	00000106 	br	81119f28 <vLoadDefaultETHConf+0x81c>
						bEOF = TRUE;
						break;
					case 0x20: 	//ASCII: 0x20 = space
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
81119f24:	0001883a 	nop
						#ifdef DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
						#endif
						break;
				}
			} while ( bEOF == FALSE );
81119f28:	e0bff817 	ldw	r2,-32(fp)
81119f2c:	103e1526 	beq	r2,zero,81119784 <__reset+0xfb0f9784>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( ETH_FILE_NAME );

		if ( siFile >= 0 ){
81119f30:	00000f06 	br	81119f70 <vLoadDefaultETHConf+0x864>
						break;
				}
			} while ( bEOF == FALSE );
		} else {
			#ifdef DEBUG_ON
				fprintf(fp,"SDCard: File not found.\n");
81119f34:	d0a06217 	ldw	r2,-32376(gp)
81119f38:	100f883a 	mov	r7,r2
81119f3c:	01800604 	movi	r6,24
81119f40:	01400044 	movi	r5,1
81119f44:	01204574 	movhi	r4,33045
81119f48:	21397004 	addi	r4,r4,-6720
81119f4c:	11216400 	call	81121640 <fwrite>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( ETH_FILE_NAME );

		if ( siFile >= 0 ){
81119f50:	00000706 	br	81119f70 <vLoadDefaultETHConf+0x864>
				fprintf(fp,"SDCard: File not found.\n");
			#endif
		}
	} else {
		#ifdef DEBUG_ON
			fprintf(fp,"SDCard: No SDCard.\n");
81119f54:	d0a06217 	ldw	r2,-32376(gp)
81119f58:	100f883a 	mov	r7,r2
81119f5c:	018004c4 	movi	r6,19
81119f60:	01400044 	movi	r5,1
81119f64:	01204574 	movhi	r4,33045
81119f68:	21397704 	addi	r4,r4,-6692
81119f6c:	11216400 	call	81121640 <fwrite>
		#endif
	}
	/* Load the default configuration if not successful in read the SDCard */
	if ( bSuccess == FALSE ) {
81119f70:	e0bff717 	ldw	r2,-36(fp)
81119f74:	1000541e 	bne	r2,zero,8111a0c8 <vLoadDefaultETHConf+0x9bc>
		/*Enviar mensagem que e gravar log que no encontrou o arquivo e comeara a utilizar o padrao*/
		printf("Ateno: Arquivo de conexo no foi encontrado. Carregando conf padrao\n");
81119f78:	01204574 	movhi	r4,33045
81119f7c:	21397c04 	addi	r4,r4,-6672
81119f80:	11225f00 	call	811225f0 <puts>
		printf("No encontrou:'%s'.\n", ETH_FILE_NAME);
81119f84:	01604574 	movhi	r5,33045
81119f88:	29795604 	addi	r5,r5,-6824
81119f8c:	01204574 	movhi	r4,33045
81119f90:	21399004 	addi	r4,r4,-6592
81119f94:	112236c0 	call	8112236c <printf>


		xConfEth.siPortPUS = 17000;
81119f98:	00a045b4 	movhi	r2,33046
81119f9c:	1099d604 	addi	r2,r2,26456
81119fa0:	00d09a04 	movi	r3,17000
81119fa4:	10c0058d 	sth	r3,22(r2)
		/*ucIP[0].ucIP[1].ucIP[2].ucIP[3]
		 *192.168.0.5*/
		xConfEth.ucIP[0] = 192;
81119fa8:	00a045b4 	movhi	r2,33046
81119fac:	1099d604 	addi	r2,r2,26456
81119fb0:	00fff004 	movi	r3,-64
81119fb4:	10c00005 	stb	r3,0(r2)
		xConfEth.ucIP[1] = 168;
81119fb8:	00a045b4 	movhi	r2,33046
81119fbc:	1099d604 	addi	r2,r2,26456
81119fc0:	00ffea04 	movi	r3,-88
81119fc4:	10c00045 	stb	r3,1(r2)
		xConfEth.ucIP[2] = 0;
81119fc8:	00a045b4 	movhi	r2,33046
81119fcc:	1099d604 	addi	r2,r2,26456
81119fd0:	10000085 	stb	zero,2(r2)
		xConfEth.ucIP[3] = 5;
81119fd4:	00a045b4 	movhi	r2,33046
81119fd8:	1099d604 	addi	r2,r2,26456
81119fdc:	00c00144 	movi	r3,5
81119fe0:	10c000c5 	stb	r3,3(r2)

		/*ucGTW[0].ucGTW[1].ucGTW[2].ucGTW[3]
		 *192.168.0.1*/
		xConfEth.ucGTW[0] = 192;
81119fe4:	00a045b4 	movhi	r2,33046
81119fe8:	1099d604 	addi	r2,r2,26456
81119fec:	00fff004 	movi	r3,-64
81119ff0:	10c00105 	stb	r3,4(r2)
		xConfEth.ucGTW[1] = 168;
81119ff4:	00a045b4 	movhi	r2,33046
81119ff8:	1099d604 	addi	r2,r2,26456
81119ffc:	00ffea04 	movi	r3,-88
8111a000:	10c00145 	stb	r3,5(r2)
		xConfEth.ucGTW[2] = 0;
8111a004:	00a045b4 	movhi	r2,33046
8111a008:	1099d604 	addi	r2,r2,26456
8111a00c:	10000185 	stb	zero,6(r2)
		xConfEth.ucGTW[3] = 1;
8111a010:	00a045b4 	movhi	r2,33046
8111a014:	1099d604 	addi	r2,r2,26456
8111a018:	00c00044 	movi	r3,1
8111a01c:	10c001c5 	stb	r3,7(r2)

		/*ucSubNet[0].ucSubNet[1].ucSubNet[2].ucSubNet[3]
		 *192.168.0.5*/
		xConfEth.ucSubNet[0] = 255;
8111a020:	00a045b4 	movhi	r2,33046
8111a024:	1099d604 	addi	r2,r2,26456
8111a028:	00ffffc4 	movi	r3,-1
8111a02c:	10c00205 	stb	r3,8(r2)
		xConfEth.ucSubNet[1] = 255;
8111a030:	00a045b4 	movhi	r2,33046
8111a034:	1099d604 	addi	r2,r2,26456
8111a038:	00ffffc4 	movi	r3,-1
8111a03c:	10c00245 	stb	r3,9(r2)
		xConfEth.ucSubNet[2] = 255;
8111a040:	00a045b4 	movhi	r2,33046
8111a044:	1099d604 	addi	r2,r2,26456
8111a048:	00ffffc4 	movi	r3,-1
8111a04c:	10c00285 	stb	r3,10(r2)
		xConfEth.ucSubNet[3] = 0;
8111a050:	00a045b4 	movhi	r2,33046
8111a054:	1099d604 	addi	r2,r2,26456
8111a058:	100002c5 	stb	zero,11(r2)


		/*ucMAC[0]:ucMAC[1]:ucMAC[2]:ucMAC[3]:ucMAC[4]:ucMAC[5]
		 *fc:f7:63:4d:1f:42*/
		xConfEth.ucMAC[0] = 0xFC;
8111a05c:	00a045b4 	movhi	r2,33046
8111a060:	1099d604 	addi	r2,r2,26456
8111a064:	00ffff04 	movi	r3,-4
8111a068:	10c00405 	stb	r3,16(r2)
		xConfEth.ucMAC[1] = 0xF7;
8111a06c:	00a045b4 	movhi	r2,33046
8111a070:	1099d604 	addi	r2,r2,26456
8111a074:	00fffdc4 	movi	r3,-9
8111a078:	10c00445 	stb	r3,17(r2)
		xConfEth.ucMAC[2] = 0x63;
8111a07c:	00a045b4 	movhi	r2,33046
8111a080:	1099d604 	addi	r2,r2,26456
8111a084:	00c018c4 	movi	r3,99
8111a088:	10c00485 	stb	r3,18(r2)
		xConfEth.ucMAC[3] = 0x4D;
8111a08c:	00a045b4 	movhi	r2,33046
8111a090:	1099d604 	addi	r2,r2,26456
8111a094:	00c01344 	movi	r3,77
8111a098:	10c004c5 	stb	r3,19(r2)
		xConfEth.ucMAC[4] = 0x1F;
8111a09c:	00a045b4 	movhi	r2,33046
8111a0a0:	1099d604 	addi	r2,r2,26456
8111a0a4:	00c007c4 	movi	r3,31
8111a0a8:	10c00505 	stb	r3,20(r2)
		xConfEth.ucMAC[5] = 0x42;
8111a0ac:	00a045b4 	movhi	r2,33046
8111a0b0:	1099d604 	addi	r2,r2,26456
8111a0b4:	00c01084 	movi	r3,66
8111a0b8:	10c00545 	stb	r3,21(r2)

		xConfEth.bDHCP = FALSE;
8111a0bc:	00a045b4 	movhi	r2,33046
8111a0c0:	1099d604 	addi	r2,r2,26456
8111a0c4:	10000615 	stw	zero,24(r2)

	}

	return bSuccess;
8111a0c8:	e0bff717 	ldw	r2,-36(fp)
}
8111a0cc:	e6ffff04 	addi	sp,fp,-4
8111a0d0:	dfc00217 	ldw	ra,8(sp)
8111a0d4:	df000117 	ldw	fp,4(sp)
8111a0d8:	dc000017 	ldw	r16,0(sp)
8111a0dc:	dec00304 	addi	sp,sp,12
8111a0e0:	f800283a 	ret

8111a0e4 <vShowEthConfig>:

#ifdef DEBUG_ON
	void vShowEthConfig( void ) {
8111a0e4:	defff004 	addi	sp,sp,-64
8111a0e8:	de00012e 	bgeu	sp,et,8111a0f0 <vShowEthConfig+0xc>
8111a0ec:	003b68fa 	trap	3
8111a0f0:	dfc00f15 	stw	ra,60(sp)
8111a0f4:	df000e15 	stw	fp,56(sp)
8111a0f8:	df000e04 	addi	fp,sp,56
		char buffer[40];

		debug(fp, "Ethernet loaded configuration.\n");
8111a0fc:	d0a06217 	ldw	r2,-32376(gp)
8111a100:	100f883a 	mov	r7,r2
8111a104:	018007c4 	movi	r6,31
8111a108:	01400044 	movi	r5,1
8111a10c:	01204574 	movhi	r4,33045
8111a110:	21399604 	addi	r4,r4,-6568
8111a114:	11216400 	call	81121640 <fwrite>

		memset(buffer,0,40);
8111a118:	01800a04 	movi	r6,40
8111a11c:	000b883a 	mov	r5,zero
8111a120:	e13ff604 	addi	r4,fp,-40
8111a124:	11221a40 	call	811221a4 <memset>
		sprintf(buffer, "MAC: %x : %x : %x : %x : %x : %x \n", xConfEth.ucMAC[0], xConfEth.ucMAC[1], xConfEth.ucMAC[2], xConfEth.ucMAC[3], xConfEth.ucMAC[4], xConfEth.ucMAC[5]);
8111a128:	00a045b4 	movhi	r2,33046
8111a12c:	1099d604 	addi	r2,r2,26456
8111a130:	10800403 	ldbu	r2,16(r2)
8111a134:	11803fcc 	andi	r6,r2,255
8111a138:	00a045b4 	movhi	r2,33046
8111a13c:	1099d604 	addi	r2,r2,26456
8111a140:	10800443 	ldbu	r2,17(r2)
8111a144:	11c03fcc 	andi	r7,r2,255
8111a148:	00a045b4 	movhi	r2,33046
8111a14c:	1099d604 	addi	r2,r2,26456
8111a150:	10800483 	ldbu	r2,18(r2)
8111a154:	10c03fcc 	andi	r3,r2,255
8111a158:	00a045b4 	movhi	r2,33046
8111a15c:	1099d604 	addi	r2,r2,26456
8111a160:	108004c3 	ldbu	r2,19(r2)
8111a164:	11003fcc 	andi	r4,r2,255
8111a168:	00a045b4 	movhi	r2,33046
8111a16c:	1099d604 	addi	r2,r2,26456
8111a170:	10800503 	ldbu	r2,20(r2)
8111a174:	11403fcc 	andi	r5,r2,255
8111a178:	00a045b4 	movhi	r2,33046
8111a17c:	1099d604 	addi	r2,r2,26456
8111a180:	10800543 	ldbu	r2,21(r2)
8111a184:	10803fcc 	andi	r2,r2,255
8111a188:	d8800315 	stw	r2,12(sp)
8111a18c:	d9400215 	stw	r5,8(sp)
8111a190:	d9000115 	stw	r4,4(sp)
8111a194:	d8c00015 	stw	r3,0(sp)
8111a198:	01604574 	movhi	r5,33045
8111a19c:	29799e04 	addi	r5,r5,-6536
8111a1a0:	e13ff604 	addi	r4,fp,-40
8111a1a4:	11229340 	call	81122934 <sprintf>
		debug(fp, buffer );
8111a1a8:	d0a06217 	ldw	r2,-32376(gp)
8111a1ac:	e17ff604 	addi	r5,fp,-40
8111a1b0:	1009883a 	mov	r4,r2
8111a1b4:	1120fa40 	call	81120fa4 <fprintf>

		memset(buffer,0,40);
8111a1b8:	01800a04 	movi	r6,40
8111a1bc:	000b883a 	mov	r5,zero
8111a1c0:	e13ff604 	addi	r4,fp,-40
8111a1c4:	11221a40 	call	811221a4 <memset>
		sprintf(buffer, "IP: %i . %i . %i . %i \n",xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3] );
8111a1c8:	00a045b4 	movhi	r2,33046
8111a1cc:	1099d604 	addi	r2,r2,26456
8111a1d0:	10800003 	ldbu	r2,0(r2)
8111a1d4:	11003fcc 	andi	r4,r2,255
8111a1d8:	00a045b4 	movhi	r2,33046
8111a1dc:	1099d604 	addi	r2,r2,26456
8111a1e0:	10800043 	ldbu	r2,1(r2)
8111a1e4:	11403fcc 	andi	r5,r2,255
8111a1e8:	00a045b4 	movhi	r2,33046
8111a1ec:	1099d604 	addi	r2,r2,26456
8111a1f0:	10800083 	ldbu	r2,2(r2)
8111a1f4:	10c03fcc 	andi	r3,r2,255
8111a1f8:	00a045b4 	movhi	r2,33046
8111a1fc:	1099d604 	addi	r2,r2,26456
8111a200:	108000c3 	ldbu	r2,3(r2)
8111a204:	10803fcc 	andi	r2,r2,255
8111a208:	d8800115 	stw	r2,4(sp)
8111a20c:	d8c00015 	stw	r3,0(sp)
8111a210:	280f883a 	mov	r7,r5
8111a214:	200d883a 	mov	r6,r4
8111a218:	01604574 	movhi	r5,33045
8111a21c:	2979a704 	addi	r5,r5,-6500
8111a220:	e13ff604 	addi	r4,fp,-40
8111a224:	11229340 	call	81122934 <sprintf>
		debug(fp, buffer );
8111a228:	d0a06217 	ldw	r2,-32376(gp)
8111a22c:	e17ff604 	addi	r5,fp,-40
8111a230:	1009883a 	mov	r4,r2
8111a234:	1120fa40 	call	81120fa4 <fprintf>

		memset(buffer,0,40);
8111a238:	01800a04 	movi	r6,40
8111a23c:	000b883a 	mov	r5,zero
8111a240:	e13ff604 	addi	r4,fp,-40
8111a244:	11221a40 	call	811221a4 <memset>
		sprintf(buffer, "GTW: %i . %i . %i . %i \n",xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3] );
8111a248:	00a045b4 	movhi	r2,33046
8111a24c:	1099d604 	addi	r2,r2,26456
8111a250:	10800103 	ldbu	r2,4(r2)
8111a254:	11003fcc 	andi	r4,r2,255
8111a258:	00a045b4 	movhi	r2,33046
8111a25c:	1099d604 	addi	r2,r2,26456
8111a260:	10800143 	ldbu	r2,5(r2)
8111a264:	11403fcc 	andi	r5,r2,255
8111a268:	00a045b4 	movhi	r2,33046
8111a26c:	1099d604 	addi	r2,r2,26456
8111a270:	10800183 	ldbu	r2,6(r2)
8111a274:	10c03fcc 	andi	r3,r2,255
8111a278:	00a045b4 	movhi	r2,33046
8111a27c:	1099d604 	addi	r2,r2,26456
8111a280:	108001c3 	ldbu	r2,7(r2)
8111a284:	10803fcc 	andi	r2,r2,255
8111a288:	d8800115 	stw	r2,4(sp)
8111a28c:	d8c00015 	stw	r3,0(sp)
8111a290:	280f883a 	mov	r7,r5
8111a294:	200d883a 	mov	r6,r4
8111a298:	01604574 	movhi	r5,33045
8111a29c:	2979ad04 	addi	r5,r5,-6476
8111a2a0:	e13ff604 	addi	r4,fp,-40
8111a2a4:	11229340 	call	81122934 <sprintf>
		debug(fp, buffer );
8111a2a8:	d0a06217 	ldw	r2,-32376(gp)
8111a2ac:	e17ff604 	addi	r5,fp,-40
8111a2b0:	1009883a 	mov	r4,r2
8111a2b4:	1120fa40 	call	81120fa4 <fprintf>

		memset(buffer,0,40);
8111a2b8:	01800a04 	movi	r6,40
8111a2bc:	000b883a 	mov	r5,zero
8111a2c0:	e13ff604 	addi	r4,fp,-40
8111a2c4:	11221a40 	call	811221a4 <memset>
		sprintf(buffer, "Sub: %i . %i . %i . %i \n",xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3] );
8111a2c8:	00a045b4 	movhi	r2,33046
8111a2cc:	1099d604 	addi	r2,r2,26456
8111a2d0:	10800203 	ldbu	r2,8(r2)
8111a2d4:	11003fcc 	andi	r4,r2,255
8111a2d8:	00a045b4 	movhi	r2,33046
8111a2dc:	1099d604 	addi	r2,r2,26456
8111a2e0:	10800243 	ldbu	r2,9(r2)
8111a2e4:	11403fcc 	andi	r5,r2,255
8111a2e8:	00a045b4 	movhi	r2,33046
8111a2ec:	1099d604 	addi	r2,r2,26456
8111a2f0:	10800283 	ldbu	r2,10(r2)
8111a2f4:	10c03fcc 	andi	r3,r2,255
8111a2f8:	00a045b4 	movhi	r2,33046
8111a2fc:	1099d604 	addi	r2,r2,26456
8111a300:	108002c3 	ldbu	r2,11(r2)
8111a304:	10803fcc 	andi	r2,r2,255
8111a308:	d8800115 	stw	r2,4(sp)
8111a30c:	d8c00015 	stw	r3,0(sp)
8111a310:	280f883a 	mov	r7,r5
8111a314:	200d883a 	mov	r6,r4
8111a318:	01604574 	movhi	r5,33045
8111a31c:	2979b404 	addi	r5,r5,-6448
8111a320:	e13ff604 	addi	r4,fp,-40
8111a324:	11229340 	call	81122934 <sprintf>
		debug(fp, buffer );
8111a328:	d0a06217 	ldw	r2,-32376(gp)
8111a32c:	e17ff604 	addi	r5,fp,-40
8111a330:	1009883a 	mov	r4,r2
8111a334:	1120fa40 	call	81120fa4 <fprintf>

		memset(buffer,0,40);
8111a338:	01800a04 	movi	r6,40
8111a33c:	000b883a 	mov	r5,zero
8111a340:	e13ff604 	addi	r4,fp,-40
8111a344:	11221a40 	call	811221a4 <memset>
		sprintf(buffer, "DNS: %i . %i . %i . %i \n",xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3] );
8111a348:	00a045b4 	movhi	r2,33046
8111a34c:	1099d604 	addi	r2,r2,26456
8111a350:	10800303 	ldbu	r2,12(r2)
8111a354:	11003fcc 	andi	r4,r2,255
8111a358:	00a045b4 	movhi	r2,33046
8111a35c:	1099d604 	addi	r2,r2,26456
8111a360:	10800343 	ldbu	r2,13(r2)
8111a364:	11403fcc 	andi	r5,r2,255
8111a368:	00a045b4 	movhi	r2,33046
8111a36c:	1099d604 	addi	r2,r2,26456
8111a370:	10800383 	ldbu	r2,14(r2)
8111a374:	10c03fcc 	andi	r3,r2,255
8111a378:	00a045b4 	movhi	r2,33046
8111a37c:	1099d604 	addi	r2,r2,26456
8111a380:	108003c3 	ldbu	r2,15(r2)
8111a384:	10803fcc 	andi	r2,r2,255
8111a388:	d8800115 	stw	r2,4(sp)
8111a38c:	d8c00015 	stw	r3,0(sp)
8111a390:	280f883a 	mov	r7,r5
8111a394:	200d883a 	mov	r6,r4
8111a398:	01604574 	movhi	r5,33045
8111a39c:	2979bb04 	addi	r5,r5,-6420
8111a3a0:	e13ff604 	addi	r4,fp,-40
8111a3a4:	11229340 	call	81122934 <sprintf>
		debug(fp, buffer );
8111a3a8:	d0a06217 	ldw	r2,-32376(gp)
8111a3ac:	e17ff604 	addi	r5,fp,-40
8111a3b0:	1009883a 	mov	r4,r2
8111a3b4:	1120fa40 	call	81120fa4 <fprintf>

		memset(buffer,0,40);
8111a3b8:	01800a04 	movi	r6,40
8111a3bc:	000b883a 	mov	r5,zero
8111a3c0:	e13ff604 	addi	r4,fp,-40
8111a3c4:	11221a40 	call	811221a4 <memset>
		sprintf(buffer, "Porta PUS: %i\n", xConfEth.siPortPUS );
8111a3c8:	00a045b4 	movhi	r2,33046
8111a3cc:	1099d604 	addi	r2,r2,26456
8111a3d0:	1080058b 	ldhu	r2,22(r2)
8111a3d4:	10bfffcc 	andi	r2,r2,65535
8111a3d8:	100d883a 	mov	r6,r2
8111a3dc:	01604574 	movhi	r5,33045
8111a3e0:	2979c204 	addi	r5,r5,-6392
8111a3e4:	e13ff604 	addi	r4,fp,-40
8111a3e8:	11229340 	call	81122934 <sprintf>
		debug(fp, buffer );
8111a3ec:	d0a06217 	ldw	r2,-32376(gp)
8111a3f0:	e17ff604 	addi	r5,fp,-40
8111a3f4:	1009883a 	mov	r4,r2
8111a3f8:	1120fa40 	call	81120fa4 <fprintf>

	}
8111a3fc:	0001883a 	nop
8111a400:	e037883a 	mov	sp,fp
8111a404:	dfc00117 	ldw	ra,4(sp)
8111a408:	df000017 	ldw	fp,0(sp)
8111a40c:	dec00204 	addi	sp,sp,8
8111a410:	f800283a 	ret

8111a414 <vLoadDebugConfs>:
#endif




bool vLoadDebugConfs( void ){
8111a414:	defff504 	addi	sp,sp,-44
8111a418:	de00012e 	bgeu	sp,et,8111a420 <vLoadDebugConfs+0xc>
8111a41c:	003b68fa 	trap	3
8111a420:	dfc00a15 	stw	ra,40(sp)
8111a424:	df000915 	stw	fp,36(sp)
8111a428:	dc000815 	stw	r16,32(sp)
8111a42c:	df000904 	addi	fp,sp,36
	short int siFile, sidhcpTemp;
	bool bSuccess = FALSE;
8111a430:	e03ff715 	stw	zero,-36(fp)
	bool bEOF = FALSE;
8111a434:	e03ff815 	stw	zero,-32(fp)
	bool close = FALSE;
8111a438:	e03ffb15 	stw	zero,-20(fp)
	unsigned char ucParser;
	char c, *p_inteiro;
	char inteiro[8];


	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){
8111a43c:	d0a07617 	ldw	r2,-32296(gp)
8111a440:	10800058 	cmpnei	r2,r2,1
8111a444:	1002fb1e 	bne	r2,zero,8111b034 <vLoadDebugConfs+0xc20>
8111a448:	111e3b80 	call	8111e3b8 <bSDcardIsPresent>
8111a44c:	1002f926 	beq	r2,zero,8111b034 <vLoadDebugConfs+0xc20>
8111a450:	111e3e80 	call	8111e3e8 <bSDcardFAT16Check>
8111a454:	1002f726 	beq	r2,zero,8111b034 <vLoadDebugConfs+0xc20>

		siFile = siOpenFile( DEBUG_FILE_NAME );
8111a458:	01204574 	movhi	r4,33045
8111a45c:	2139c604 	addi	r4,r4,-6376
8111a460:	111e5100 	call	8111e510 <siOpenFile>
8111a464:	e0bffc0d 	sth	r2,-16(fp)

		if ( siFile >= 0 ){
8111a468:	e0bffc0f 	ldh	r2,-16(fp)
8111a46c:	1002e916 	blt	r2,zero,8111b014 <vLoadDebugConfs+0xc00>

			memset( &(inteiro) , 10 , sizeof( inteiro ) );
8111a470:	e0bffd04 	addi	r2,fp,-12
8111a474:	01800204 	movi	r6,8
8111a478:	01400284 	movi	r5,10
8111a47c:	1009883a 	mov	r4,r2
8111a480:	11221a40 	call	811221a4 <memset>
			p_inteiro = inteiro;
8111a484:	e0bffd04 	addi	r2,fp,-12
8111a488:	e0bffa15 	stw	r2,-24(fp)

			do {
				c = cGetNextChar(siFile);
8111a48c:	e0bffc0f 	ldh	r2,-16(fp)
8111a490:	1009883a 	mov	r4,r2
8111a494:	111e58c0 	call	8111e58c <cGetNextChar>
8111a498:	e0bff945 	stb	r2,-27(fp)
				//printf("%c \n", c);
				switch (c) {
8111a49c:	e0bff947 	ldb	r2,-27(fp)
8111a4a0:	10800084 	addi	r2,r2,2
8111a4a4:	10c015e8 	cmpgeui	r3,r2,87
8111a4a8:	1802ce1e 	bne	r3,zero,8111afe4 <vLoadDebugConfs+0xbd0>
8111a4ac:	100690ba 	slli	r3,r2,2
8111a4b0:	00a044b4 	movhi	r2,33042
8111a4b4:	10a93104 	addi	r2,r2,-23356
8111a4b8:	1885883a 	add	r2,r3,r2
8111a4bc:	10800017 	ldw	r2,0(r2)
8111a4c0:	1000683a 	jmp	r2
8111a4c4:	8111a660 	cmpeqi	r4,r16,18073
8111a4c8:	8111a654 	ori	r4,r16,18073
8111a4cc:	8111afe4 	muli	r4,r16,18111
8111a4d0:	8111afe4 	muli	r4,r16,18111
8111a4d4:	8111afe4 	muli	r4,r16,18111
8111a4d8:	8111afe4 	muli	r4,r16,18111
8111a4dc:	8111afe4 	muli	r4,r16,18111
8111a4e0:	8111afe4 	muli	r4,r16,18111
8111a4e4:	8111afe4 	muli	r4,r16,18111
8111a4e8:	8111afe4 	muli	r4,r16,18111
8111a4ec:	8111afe4 	muli	r4,r16,18111
8111a4f0:	8111afe4 	muli	r4,r16,18111
8111a4f4:	8111b004 	addi	r4,r16,18112
8111a4f8:	8111afe4 	muli	r4,r16,18111
8111a4fc:	8111afe4 	muli	r4,r16,18111
8111a500:	8111b004 	addi	r4,r16,18112
8111a504:	8111afe4 	muli	r4,r16,18111
8111a508:	8111afe4 	muli	r4,r16,18111
8111a50c:	8111afe4 	muli	r4,r16,18111
8111a510:	8111afe4 	muli	r4,r16,18111
8111a514:	8111afe4 	muli	r4,r16,18111
8111a518:	8111afe4 	muli	r4,r16,18111
8111a51c:	8111afe4 	muli	r4,r16,18111
8111a520:	8111afe4 	muli	r4,r16,18111
8111a524:	8111afe4 	muli	r4,r16,18111
8111a528:	8111afe4 	muli	r4,r16,18111
8111a52c:	8111afe4 	muli	r4,r16,18111
8111a530:	8111afe4 	muli	r4,r16,18111
8111a534:	8111afe4 	muli	r4,r16,18111
8111a538:	8111afe4 	muli	r4,r16,18111
8111a53c:	8111afe4 	muli	r4,r16,18111
8111a540:	8111afe4 	muli	r4,r16,18111
8111a544:	8111afe4 	muli	r4,r16,18111
8111a548:	8111afe4 	muli	r4,r16,18111
8111a54c:	8111b004 	addi	r4,r16,18112
8111a550:	8111afe4 	muli	r4,r16,18111
8111a554:	8111afe4 	muli	r4,r16,18111
8111a558:	8111afe4 	muli	r4,r16,18111
8111a55c:	8111afe4 	muli	r4,r16,18111
8111a560:	8111afe4 	muli	r4,r16,18111
8111a564:	8111afe4 	muli	r4,r16,18111
8111a568:	8111a620 	cmpeqi	r4,r16,18072
8111a56c:	8111afe4 	muli	r4,r16,18111
8111a570:	8111afe4 	muli	r4,r16,18111
8111a574:	8111afe4 	muli	r4,r16,18111
8111a578:	8111afe4 	muli	r4,r16,18111
8111a57c:	8111afe4 	muli	r4,r16,18111
8111a580:	8111afe4 	muli	r4,r16,18111
8111a584:	8111afe4 	muli	r4,r16,18111
8111a588:	8111afe4 	muli	r4,r16,18111
8111a58c:	8111afe4 	muli	r4,r16,18111
8111a590:	8111afe4 	muli	r4,r16,18111
8111a594:	8111afe4 	muli	r4,r16,18111
8111a598:	8111afe4 	muli	r4,r16,18111
8111a59c:	8111afe4 	muli	r4,r16,18111
8111a5a0:	8111afe4 	muli	r4,r16,18111
8111a5a4:	8111afe4 	muli	r4,r16,18111
8111a5a8:	8111afe4 	muli	r4,r16,18111
8111a5ac:	8111afe4 	muli	r4,r16,18111
8111a5b0:	8111afe4 	muli	r4,r16,18111
8111a5b4:	8111afe4 	muli	r4,r16,18111
8111a5b8:	8111afe4 	muli	r4,r16,18111
8111a5bc:	8111af9c 	xori	r4,r16,18110
8111a5c0:	8111afe4 	muli	r4,r16,18111
8111a5c4:	8111afe4 	muli	r4,r16,18111
8111a5c8:	8111afe4 	muli	r4,r16,18111
8111a5cc:	8111afe4 	muli	r4,r16,18111
8111a5d0:	8111a948 	cmpgei	r4,r16,18085
8111a5d4:	8111afe4 	muli	r4,r16,18111
8111a5d8:	8111ab58 	cmpnei	r4,r16,18093
8111a5dc:	8111acd4 	ori	r4,r16,18099
8111a5e0:	8111afe4 	muli	r4,r16,18111
8111a5e4:	8111afe4 	muli	r4,r16,18111
8111a5e8:	8111afe4 	muli	r4,r16,18111
8111a5ec:	8111ac08 	cmpgei	r4,r16,18096
8111a5f0:	8111afe4 	muli	r4,r16,18111
8111a5f4:	8111ae6c 	andhi	r4,r16,18105
8111a5f8:	8111ad5c 	xori	r4,r16,18101
8111a5fc:	8111a9f8 	rdprs	r4,r16,18087
8111a600:	8111ade4 	muli	r4,r16,18103
8111a604:	8111a7e8 	cmpgeui	r4,r16,18079
8111a608:	8111aaa8 	cmpgeui	r4,r16,18090
8111a60c:	8111a738 	rdprs	r4,r16,18076
8111a610:	8111afe4 	muli	r4,r16,18111
8111a614:	8111a898 	cmpnei	r4,r16,18082
8111a618:	8111a688 	cmpgei	r4,r16,18074
8111a61c:	8111aef4 	orhi	r4,r16,18107
					case 39:// single quote '
						c = cGetNextChar(siFile);
8111a620:	e0bffc0f 	ldh	r2,-16(fp)
8111a624:	1009883a 	mov	r4,r2
8111a628:	111e58c0 	call	8111e58c <cGetNextChar>
8111a62c:	e0bff945 	stb	r2,-27(fp)
						while ( c != 39 ){
8111a630:	00000406 	br	8111a644 <vLoadDebugConfs+0x230>
							c = cGetNextChar(siFile);
8111a634:	e0bffc0f 	ldh	r2,-16(fp)
8111a638:	1009883a 	mov	r4,r2
8111a63c:	111e58c0 	call	8111e58c <cGetNextChar>
8111a640:	e0bff945 	stb	r2,-27(fp)
				c = cGetNextChar(siFile);
				//printf("%c \n", c);
				switch (c) {
					case 39:// single quote '
						c = cGetNextChar(siFile);
						while ( c != 39 ){
8111a644:	e0bff947 	ldb	r2,-27(fp)
8111a648:	108009d8 	cmpnei	r2,r2,39
8111a64c:	103ff91e 	bne	r2,zero,8111a634 <__reset+0xfb0fa634>
							c = cGetNextChar(siFile);
						}
						break;
8111a650:	00026d06 	br	8111b008 <vLoadDebugConfs+0xbf4>
					case -1: 	//EOF
						bEOF = TRUE;
8111a654:	00800044 	movi	r2,1
8111a658:	e0bff815 	stw	r2,-32(fp)
						break;
8111a65c:	00026a06 	br	8111b008 <vLoadDebugConfs+0xbf4>
					case -2: 	//EOF
						#ifdef DEBUG_ON
							debug(fp,"SDCard: Problem with SDCard");
8111a660:	d0a06217 	ldw	r2,-32376(gp)
8111a664:	100f883a 	mov	r7,r2
8111a668:	018006c4 	movi	r6,27
8111a66c:	01400044 	movi	r5,1
8111a670:	01204574 	movhi	r4,33045
8111a674:	21395804 	addi	r4,r4,-6816
8111a678:	11216400 	call	81121640 <fwrite>
						#endif
						bEOF = TRUE;
8111a67c:	00800044 	movi	r2,1
8111a680:	e0bff815 	stw	r2,-32(fp)
						break;
8111a684:	00026006 	br	8111b008 <vLoadDebugConfs+0xbf4>
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;

					case 'S':
						ucParser = 0;
8111a688:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111a68c:	e0bffc0f 	ldh	r2,-16(fp)
8111a690:	1009883a 	mov	r4,r2
8111a694:	111e58c0 	call	8111e58c <cGetNextChar>
8111a698:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8111a69c:	d0e00317 	ldw	r3,-32756(gp)
8111a6a0:	e0bff947 	ldb	r2,-27(fp)
8111a6a4:	10800044 	addi	r2,r2,1
8111a6a8:	1885883a 	add	r2,r3,r2
8111a6ac:	10800003 	ldbu	r2,0(r2)
8111a6b0:	10803fcc 	andi	r2,r2,255
8111a6b4:	1080010c 	andi	r2,r2,4
8111a6b8:	10000626 	beq	r2,zero,8111a6d4 <vLoadDebugConfs+0x2c0>
									(*p_inteiro) = c;
8111a6bc:	e0bffa17 	ldw	r2,-24(fp)
8111a6c0:	e0fff943 	ldbu	r3,-27(fp)
8111a6c4:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111a6c8:	e0bffa17 	ldw	r2,-24(fp)
8111a6cc:	10800044 	addi	r2,r2,1
8111a6d0:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111a6d4:	e0bff947 	ldb	r2,-27(fp)
8111a6d8:	10800ba0 	cmpeqi	r2,r2,46
8111a6dc:	1000031e 	bne	r2,zero,8111a6ec <vLoadDebugConfs+0x2d8>
8111a6e0:	e0bff947 	ldb	r2,-27(fp)
8111a6e4:	10800ed8 	cmpnei	r2,r2,59
8111a6e8:	103fe81e 	bne	r2,zero,8111a68c <__reset+0xfb0fa68c>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111a6ec:	e0bffa17 	ldw	r2,-24(fp)
8111a6f0:	00c00284 	movi	r3,10
8111a6f4:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiSyncPeriod = atoi( inteiro );
8111a6f8:	e0bffd04 	addi	r2,fp,-12
8111a6fc:	1009883a 	mov	r4,r2
8111a700:	1120e480 	call	81120e48 <atoi>
8111a704:	1007883a 	mov	r3,r2
8111a708:	00a045b4 	movhi	r2,33046
8111a70c:	1099c904 	addi	r2,r2,26404
8111a710:	10c0068d 	sth	r3,26(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111a714:	e0bffd04 	addi	r2,fp,-12
8111a718:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111a71c:	e0bff903 	ldbu	r2,-28(fp)
8111a720:	10800044 	addi	r2,r2,1
8111a724:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111a728:	e0bff947 	ldb	r2,-27(fp)
8111a72c:	10800ed8 	cmpnei	r2,r2,59
8111a730:	103fd61e 	bne	r2,zero,8111a68c <__reset+0xfb0fa68c>

						break;
8111a734:	00023406 	br	8111b008 <vLoadDebugConfs+0xbf4>
					case 'P':
						ucParser = 0;
8111a738:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111a73c:	e0bffc0f 	ldh	r2,-16(fp)
8111a740:	1009883a 	mov	r4,r2
8111a744:	111e58c0 	call	8111e58c <cGetNextChar>
8111a748:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8111a74c:	d0e00317 	ldw	r3,-32756(gp)
8111a750:	e0bff947 	ldb	r2,-27(fp)
8111a754:	10800044 	addi	r2,r2,1
8111a758:	1885883a 	add	r2,r3,r2
8111a75c:	10800003 	ldbu	r2,0(r2)
8111a760:	10803fcc 	andi	r2,r2,255
8111a764:	1080010c 	andi	r2,r2,4
8111a768:	10000626 	beq	r2,zero,8111a784 <vLoadDebugConfs+0x370>
									(*p_inteiro) = c;
8111a76c:	e0bffa17 	ldw	r2,-24(fp)
8111a770:	e0fff943 	ldbu	r3,-27(fp)
8111a774:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111a778:	e0bffa17 	ldw	r2,-24(fp)
8111a77c:	10800044 	addi	r2,r2,1
8111a780:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111a784:	e0bff947 	ldb	r2,-27(fp)
8111a788:	10800ba0 	cmpeqi	r2,r2,46
8111a78c:	1000031e 	bne	r2,zero,8111a79c <vLoadDebugConfs+0x388>
8111a790:	e0bff947 	ldb	r2,-27(fp)
8111a794:	10800ed8 	cmpnei	r2,r2,59
8111a798:	103fe81e 	bne	r2,zero,8111a73c <__reset+0xfb0fa73c>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111a79c:	e0bffa17 	ldw	r2,-24(fp)
8111a7a0:	00c00284 	movi	r3,10
8111a7a4:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiPreScanSerial = atoi( inteiro );
8111a7a8:	e0bffd04 	addi	r2,fp,-12
8111a7ac:	1009883a 	mov	r4,r2
8111a7b0:	1120e480 	call	81120e48 <atoi>
8111a7b4:	1007883a 	mov	r3,r2
8111a7b8:	00a045b4 	movhi	r2,33046
8111a7bc:	1099c904 	addi	r2,r2,26404
8111a7c0:	10c0048d 	sth	r3,18(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111a7c4:	e0bffd04 	addi	r2,fp,-12
8111a7c8:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111a7cc:	e0bff903 	ldbu	r2,-28(fp)
8111a7d0:	10800044 	addi	r2,r2,1
8111a7d4:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111a7d8:	e0bff947 	ldb	r2,-27(fp)
8111a7dc:	10800ed8 	cmpnei	r2,r2,59
8111a7e0:	103fd61e 	bne	r2,zero,8111a73c <__reset+0xfb0fa73c>

						break;
8111a7e4:	00020806 	br	8111b008 <vLoadDebugConfs+0xbf4>
					case 'N':
						ucParser = 0;
8111a7e8:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111a7ec:	e0bffc0f 	ldh	r2,-16(fp)
8111a7f0:	1009883a 	mov	r4,r2
8111a7f4:	111e58c0 	call	8111e58c <cGetNextChar>
8111a7f8:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8111a7fc:	d0e00317 	ldw	r3,-32756(gp)
8111a800:	e0bff947 	ldb	r2,-27(fp)
8111a804:	10800044 	addi	r2,r2,1
8111a808:	1885883a 	add	r2,r3,r2
8111a80c:	10800003 	ldbu	r2,0(r2)
8111a810:	10803fcc 	andi	r2,r2,255
8111a814:	1080010c 	andi	r2,r2,4
8111a818:	10000626 	beq	r2,zero,8111a834 <vLoadDebugConfs+0x420>
									(*p_inteiro) = c;
8111a81c:	e0bffa17 	ldw	r2,-24(fp)
8111a820:	e0fff943 	ldbu	r3,-27(fp)
8111a824:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111a828:	e0bffa17 	ldw	r2,-24(fp)
8111a82c:	10800044 	addi	r2,r2,1
8111a830:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111a834:	e0bff947 	ldb	r2,-27(fp)
8111a838:	10800ba0 	cmpeqi	r2,r2,46
8111a83c:	1000031e 	bne	r2,zero,8111a84c <vLoadDebugConfs+0x438>
8111a840:	e0bff947 	ldb	r2,-27(fp)
8111a844:	10800ed8 	cmpnei	r2,r2,59
8111a848:	103fe81e 	bne	r2,zero,8111a7ec <__reset+0xfb0fa7ec>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111a84c:	e0bffa17 	ldw	r2,-24(fp)
8111a850:	00c00284 	movi	r3,10
8111a854:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiOverScanSerial = atoi( inteiro );
8111a858:	e0bffd04 	addi	r2,fp,-12
8111a85c:	1009883a 	mov	r4,r2
8111a860:	1120e480 	call	81120e48 <atoi>
8111a864:	1007883a 	mov	r3,r2
8111a868:	00a045b4 	movhi	r2,33046
8111a86c:	1099c904 	addi	r2,r2,26404
8111a870:	10c0040d 	sth	r3,16(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111a874:	e0bffd04 	addi	r2,fp,-12
8111a878:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111a87c:	e0bff903 	ldbu	r2,-28(fp)
8111a880:	10800044 	addi	r2,r2,1
8111a884:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111a888:	e0bff947 	ldb	r2,-27(fp)
8111a88c:	10800ed8 	cmpnei	r2,r2,59
8111a890:	103fd61e 	bne	r2,zero,8111a7ec <__reset+0xfb0fa7ec>

						break;
8111a894:	0001dc06 	br	8111b008 <vLoadDebugConfs+0xbf4>
					case 'R':
						ucParser = 0;
8111a898:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111a89c:	e0bffc0f 	ldh	r2,-16(fp)
8111a8a0:	1009883a 	mov	r4,r2
8111a8a4:	111e58c0 	call	8111e58c <cGetNextChar>
8111a8a8:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8111a8ac:	d0e00317 	ldw	r3,-32756(gp)
8111a8b0:	e0bff947 	ldb	r2,-27(fp)
8111a8b4:	10800044 	addi	r2,r2,1
8111a8b8:	1885883a 	add	r2,r3,r2
8111a8bc:	10800003 	ldbu	r2,0(r2)
8111a8c0:	10803fcc 	andi	r2,r2,255
8111a8c4:	1080010c 	andi	r2,r2,4
8111a8c8:	10000626 	beq	r2,zero,8111a8e4 <vLoadDebugConfs+0x4d0>
									(*p_inteiro) = c;
8111a8cc:	e0bffa17 	ldw	r2,-24(fp)
8111a8d0:	e0fff943 	ldbu	r3,-27(fp)
8111a8d4:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111a8d8:	e0bffa17 	ldw	r2,-24(fp)
8111a8dc:	10800044 	addi	r2,r2,1
8111a8e0:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111a8e4:	e0bff947 	ldb	r2,-27(fp)
8111a8e8:	10800ba0 	cmpeqi	r2,r2,46
8111a8ec:	1000031e 	bne	r2,zero,8111a8fc <vLoadDebugConfs+0x4e8>
8111a8f0:	e0bff947 	ldb	r2,-27(fp)
8111a8f4:	10800ed8 	cmpnei	r2,r2,59
8111a8f8:	103fe81e 	bne	r2,zero,8111a89c <__reset+0xfb0fa89c>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111a8fc:	e0bffa17 	ldw	r2,-24(fp)
8111a900:	00c00284 	movi	r3,10
8111a904:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.ucRmapKey = atoi( inteiro );
8111a908:	e0bffd04 	addi	r2,fp,-12
8111a90c:	1009883a 	mov	r4,r2
8111a910:	1120e480 	call	81120e48 <atoi>
8111a914:	1007883a 	mov	r3,r2
8111a918:	00a045b4 	movhi	r2,33046
8111a91c:	1099c904 	addi	r2,r2,26404
8111a920:	10c00c0d 	sth	r3,48(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111a924:	e0bffd04 	addi	r2,fp,-12
8111a928:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111a92c:	e0bff903 	ldbu	r2,-28(fp)
8111a930:	10800044 	addi	r2,r2,1
8111a934:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111a938:	e0bff947 	ldb	r2,-27(fp)
8111a93c:	10800ed8 	cmpnei	r2,r2,59
8111a940:	103fd61e 	bne	r2,zero,8111a89c <__reset+0xfb0fa89c>

						break;
8111a944:	0001b006 	br	8111b008 <vLoadDebugConfs+0xbf4>
					case 'A':
						ucParser = 0;
8111a948:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111a94c:	e0bffc0f 	ldh	r2,-16(fp)
8111a950:	1009883a 	mov	r4,r2
8111a954:	111e58c0 	call	8111e58c <cGetNextChar>
8111a958:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8111a95c:	d0e00317 	ldw	r3,-32756(gp)
8111a960:	e0bff947 	ldb	r2,-27(fp)
8111a964:	10800044 	addi	r2,r2,1
8111a968:	1885883a 	add	r2,r3,r2
8111a96c:	10800003 	ldbu	r2,0(r2)
8111a970:	10803fcc 	andi	r2,r2,255
8111a974:	1080010c 	andi	r2,r2,4
8111a978:	10000626 	beq	r2,zero,8111a994 <vLoadDebugConfs+0x580>
									(*p_inteiro) = c;
8111a97c:	e0bffa17 	ldw	r2,-24(fp)
8111a980:	e0fff943 	ldbu	r3,-27(fp)
8111a984:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111a988:	e0bffa17 	ldw	r2,-24(fp)
8111a98c:	10800044 	addi	r2,r2,1
8111a990:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111a994:	e0bff947 	ldb	r2,-27(fp)
8111a998:	10800ba0 	cmpeqi	r2,r2,46
8111a99c:	1000031e 	bne	r2,zero,8111a9ac <vLoadDebugConfs+0x598>
8111a9a0:	e0bff947 	ldb	r2,-27(fp)
8111a9a4:	10800ed8 	cmpnei	r2,r2,59
8111a9a8:	103fe81e 	bne	r2,zero,8111a94c <__reset+0xfb0fa94c>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111a9ac:	e0bffa17 	ldw	r2,-24(fp)
8111a9b0:	00c00284 	movi	r3,10
8111a9b4:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.ucLogicalAddr = atoi( inteiro );
8111a9b8:	e0bffd04 	addi	r2,fp,-12
8111a9bc:	1009883a 	mov	r4,r2
8111a9c0:	1120e480 	call	81120e48 <atoi>
8111a9c4:	1007883a 	mov	r3,r2
8111a9c8:	00a045b4 	movhi	r2,33046
8111a9cc:	1099c904 	addi	r2,r2,26404
8111a9d0:	10c00c8d 	sth	r3,50(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111a9d4:	e0bffd04 	addi	r2,fp,-12
8111a9d8:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111a9dc:	e0bff903 	ldbu	r2,-28(fp)
8111a9e0:	10800044 	addi	r2,r2,1
8111a9e4:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111a9e8:	e0bff947 	ldb	r2,-27(fp)
8111a9ec:	10800ed8 	cmpnei	r2,r2,59
8111a9f0:	103fd61e 	bne	r2,zero,8111a94c <__reset+0xfb0fa94c>

						break;
8111a9f4:	00018406 	br	8111b008 <vLoadDebugConfs+0xbf4>
					case 'L':
						ucParser = 0;
8111a9f8:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111a9fc:	e0bffc0f 	ldh	r2,-16(fp)
8111aa00:	1009883a 	mov	r4,r2
8111aa04:	111e58c0 	call	8111e58c <cGetNextChar>
8111aa08:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8111aa0c:	d0e00317 	ldw	r3,-32756(gp)
8111aa10:	e0bff947 	ldb	r2,-27(fp)
8111aa14:	10800044 	addi	r2,r2,1
8111aa18:	1885883a 	add	r2,r3,r2
8111aa1c:	10800003 	ldbu	r2,0(r2)
8111aa20:	10803fcc 	andi	r2,r2,255
8111aa24:	1080010c 	andi	r2,r2,4
8111aa28:	10000626 	beq	r2,zero,8111aa44 <vLoadDebugConfs+0x630>
									(*p_inteiro) = c;
8111aa2c:	e0bffa17 	ldw	r2,-24(fp)
8111aa30:	e0fff943 	ldbu	r3,-27(fp)
8111aa34:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111aa38:	e0bffa17 	ldw	r2,-24(fp)
8111aa3c:	10800044 	addi	r2,r2,1
8111aa40:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111aa44:	e0bff947 	ldb	r2,-27(fp)
8111aa48:	10800ba0 	cmpeqi	r2,r2,46
8111aa4c:	1000031e 	bne	r2,zero,8111aa5c <vLoadDebugConfs+0x648>
8111aa50:	e0bff947 	ldb	r2,-27(fp)
8111aa54:	10800ed8 	cmpnei	r2,r2,59
8111aa58:	103fe81e 	bne	r2,zero,8111a9fc <__reset+0xfb0fa9fc>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111aa5c:	e0bffa17 	ldw	r2,-24(fp)
8111aa60:	00c00284 	movi	r3,10
8111aa64:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiRows = atoi( inteiro );
8111aa68:	e0bffd04 	addi	r2,fp,-12
8111aa6c:	1009883a 	mov	r4,r2
8111aa70:	1120e480 	call	81120e48 <atoi>
8111aa74:	1007883a 	mov	r3,r2
8111aa78:	00a045b4 	movhi	r2,33046
8111aa7c:	1099c904 	addi	r2,r2,26404
8111aa80:	10c0060d 	sth	r3,24(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111aa84:	e0bffd04 	addi	r2,fp,-12
8111aa88:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111aa8c:	e0bff903 	ldbu	r2,-28(fp)
8111aa90:	10800044 	addi	r2,r2,1
8111aa94:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111aa98:	e0bff947 	ldb	r2,-27(fp)
8111aa9c:	10800ed8 	cmpnei	r2,r2,59
8111aaa0:	103fd61e 	bne	r2,zero,8111a9fc <__reset+0xfb0fa9fc>

						break;
8111aaa4:	00015806 	br	8111b008 <vLoadDebugConfs+0xbf4>

					case 'O':
						ucParser = 0;
8111aaa8:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111aaac:	e0bffc0f 	ldh	r2,-16(fp)
8111aab0:	1009883a 	mov	r4,r2
8111aab4:	111e58c0 	call	8111e58c <cGetNextChar>
8111aab8:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8111aabc:	d0e00317 	ldw	r3,-32756(gp)
8111aac0:	e0bff947 	ldb	r2,-27(fp)
8111aac4:	10800044 	addi	r2,r2,1
8111aac8:	1885883a 	add	r2,r3,r2
8111aacc:	10800003 	ldbu	r2,0(r2)
8111aad0:	10803fcc 	andi	r2,r2,255
8111aad4:	1080010c 	andi	r2,r2,4
8111aad8:	10000626 	beq	r2,zero,8111aaf4 <vLoadDebugConfs+0x6e0>
									(*p_inteiro) = c;
8111aadc:	e0bffa17 	ldw	r2,-24(fp)
8111aae0:	e0fff943 	ldbu	r3,-27(fp)
8111aae4:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111aae8:	e0bffa17 	ldw	r2,-24(fp)
8111aaec:	10800044 	addi	r2,r2,1
8111aaf0:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111aaf4:	e0bff947 	ldb	r2,-27(fp)
8111aaf8:	10800ba0 	cmpeqi	r2,r2,46
8111aafc:	1000031e 	bne	r2,zero,8111ab0c <vLoadDebugConfs+0x6f8>
8111ab00:	e0bff947 	ldb	r2,-27(fp)
8111ab04:	10800ed8 	cmpnei	r2,r2,59
8111ab08:	103fe81e 	bne	r2,zero,8111aaac <__reset+0xfb0faaac>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111ab0c:	e0bffa17 	ldw	r2,-24(fp)
8111ab10:	00c00284 	movi	r3,10
8111ab14:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiOLN = atoi( inteiro );
8111ab18:	e0bffd04 	addi	r2,fp,-12
8111ab1c:	1009883a 	mov	r4,r2
8111ab20:	1120e480 	call	81120e48 <atoi>
8111ab24:	1007883a 	mov	r3,r2
8111ab28:	00a045b4 	movhi	r2,33046
8111ab2c:	1099c904 	addi	r2,r2,26404
8111ab30:	10c0050d 	sth	r3,20(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111ab34:	e0bffd04 	addi	r2,fp,-12
8111ab38:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111ab3c:	e0bff903 	ldbu	r2,-28(fp)
8111ab40:	10800044 	addi	r2,r2,1
8111ab44:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111ab48:	e0bff947 	ldb	r2,-27(fp)
8111ab4c:	10800ed8 	cmpnei	r2,r2,59
8111ab50:	103fd61e 	bne	r2,zero,8111aaac <__reset+0xfb0faaac>

						break;
8111ab54:	00012c06 	br	8111b008 <vLoadDebugConfs+0xbf4>
					case 'C':
						ucParser = 0;
8111ab58:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111ab5c:	e0bffc0f 	ldh	r2,-16(fp)
8111ab60:	1009883a 	mov	r4,r2
8111ab64:	111e58c0 	call	8111e58c <cGetNextChar>
8111ab68:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8111ab6c:	d0e00317 	ldw	r3,-32756(gp)
8111ab70:	e0bff947 	ldb	r2,-27(fp)
8111ab74:	10800044 	addi	r2,r2,1
8111ab78:	1885883a 	add	r2,r3,r2
8111ab7c:	10800003 	ldbu	r2,0(r2)
8111ab80:	10803fcc 	andi	r2,r2,255
8111ab84:	1080010c 	andi	r2,r2,4
8111ab88:	10000626 	beq	r2,zero,8111aba4 <vLoadDebugConfs+0x790>
									(*p_inteiro) = c;
8111ab8c:	e0bffa17 	ldw	r2,-24(fp)
8111ab90:	e0fff943 	ldbu	r3,-27(fp)
8111ab94:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111ab98:	e0bffa17 	ldw	r2,-24(fp)
8111ab9c:	10800044 	addi	r2,r2,1
8111aba0:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111aba4:	e0bff947 	ldb	r2,-27(fp)
8111aba8:	10800ba0 	cmpeqi	r2,r2,46
8111abac:	1000031e 	bne	r2,zero,8111abbc <vLoadDebugConfs+0x7a8>
8111abb0:	e0bff947 	ldb	r2,-27(fp)
8111abb4:	10800ed8 	cmpnei	r2,r2,59
8111abb8:	103fe81e 	bne	r2,zero,8111ab5c <__reset+0xfb0fab5c>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111abbc:	e0bffa17 	ldw	r2,-24(fp)
8111abc0:	00c00284 	movi	r3,10
8111abc4:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiCols = atoi( inteiro );
8111abc8:	e0bffd04 	addi	r2,fp,-12
8111abcc:	1009883a 	mov	r4,r2
8111abd0:	1120e480 	call	81120e48 <atoi>
8111abd4:	1007883a 	mov	r3,r2
8111abd8:	00a045b4 	movhi	r2,33046
8111abdc:	1099c904 	addi	r2,r2,26404
8111abe0:	10c0058d 	sth	r3,22(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111abe4:	e0bffd04 	addi	r2,fp,-12
8111abe8:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111abec:	e0bff903 	ldbu	r2,-28(fp)
8111abf0:	10800044 	addi	r2,r2,1
8111abf4:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111abf8:	e0bff947 	ldb	r2,-27(fp)
8111abfc:	10800ed8 	cmpnei	r2,r2,59
8111ac00:	103fd61e 	bne	r2,zero,8111ab5c <__reset+0xfb0fab5c>

						break;
8111ac04:	00010006 	br	8111b008 <vLoadDebugConfs+0xbf4>
					case 'H':

						ucParser = 0;
8111ac08:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111ac0c:	e0bffc0f 	ldh	r2,-16(fp)
8111ac10:	1009883a 	mov	r4,r2
8111ac14:	111e58c0 	call	8111e58c <cGetNextChar>
8111ac18:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8111ac1c:	d0e00317 	ldw	r3,-32756(gp)
8111ac20:	e0bff947 	ldb	r2,-27(fp)
8111ac24:	10800044 	addi	r2,r2,1
8111ac28:	1885883a 	add	r2,r3,r2
8111ac2c:	10800003 	ldbu	r2,0(r2)
8111ac30:	10803fcc 	andi	r2,r2,255
8111ac34:	1080010c 	andi	r2,r2,4
8111ac38:	10000626 	beq	r2,zero,8111ac54 <vLoadDebugConfs+0x840>
									(*p_inteiro) = c;
8111ac3c:	e0bffa17 	ldw	r2,-24(fp)
8111ac40:	e0fff943 	ldbu	r3,-27(fp)
8111ac44:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111ac48:	e0bffa17 	ldw	r2,-24(fp)
8111ac4c:	10800044 	addi	r2,r2,1
8111ac50:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111ac54:	e0bff947 	ldb	r2,-27(fp)
8111ac58:	10800ba0 	cmpeqi	r2,r2,46
8111ac5c:	1000031e 	bne	r2,zero,8111ac6c <vLoadDebugConfs+0x858>
8111ac60:	e0bff947 	ldb	r2,-27(fp)
8111ac64:	10800ed8 	cmpnei	r2,r2,59
8111ac68:	103fe81e 	bne	r2,zero,8111ac0c <__reset+0xfb0fac0c>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111ac6c:	e0bffa17 	ldw	r2,-24(fp)
8111ac70:	00c00284 	movi	r3,10
8111ac74:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.HK[min_sim(ucParser,15)] = atoi( inteiro );
8111ac78:	e0bff903 	ldbu	r2,-28(fp)
8111ac7c:	108003e8 	cmpgeui	r2,r2,15
8111ac80:	1000021e 	bne	r2,zero,8111ac8c <vLoadDebugConfs+0x878>
8111ac84:	e43ff903 	ldbu	r16,-28(fp)
8111ac88:	00000106 	br	8111ac90 <vLoadDebugConfs+0x87c>
8111ac8c:	040003c4 	movi	r16,15
8111ac90:	e0bffd04 	addi	r2,fp,-12
8111ac94:	1009883a 	mov	r4,r2
8111ac98:	1120e480 	call	81120e48 <atoi>
8111ac9c:	1007883a 	mov	r3,r2
8111aca0:	00a045b4 	movhi	r2,33046
8111aca4:	1099c904 	addi	r2,r2,26404
8111aca8:	1405883a 	add	r2,r2,r16
8111acac:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111acb0:	e0bffd04 	addi	r2,fp,-12
8111acb4:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111acb8:	e0bff903 	ldbu	r2,-28(fp)
8111acbc:	10800044 	addi	r2,r2,1
8111acc0:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111acc4:	e0bff947 	ldb	r2,-27(fp)
8111acc8:	10800ed8 	cmpnei	r2,r2,59
8111accc:	103fcf1e 	bne	r2,zero,8111ac0c <__reset+0xfb0fac0c>

						break;
8111acd0:	0000cd06 	br	8111b008 <vLoadDebugConfs+0xbf4>
					case 'D':

						do {
							c = cGetNextChar(siFile);
8111acd4:	e0bffc0f 	ldh	r2,-16(fp)
8111acd8:	1009883a 	mov	r4,r2
8111acdc:	111e58c0 	call	8111e58c <cGetNextChar>
8111ace0:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
8111ace4:	d0e00317 	ldw	r3,-32756(gp)
8111ace8:	e0bff947 	ldb	r2,-27(fp)
8111acec:	10800044 	addi	r2,r2,1
8111acf0:	1885883a 	add	r2,r3,r2
8111acf4:	10800003 	ldbu	r2,0(r2)
8111acf8:	10803fcc 	andi	r2,r2,255
8111acfc:	1080010c 	andi	r2,r2,4
8111ad00:	10000626 	beq	r2,zero,8111ad1c <vLoadDebugConfs+0x908>
								(*p_inteiro) = c;
8111ad04:	e0bffa17 	ldw	r2,-24(fp)
8111ad08:	e0fff943 	ldbu	r3,-27(fp)
8111ad0c:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111ad10:	e0bffa17 	ldw	r2,-24(fp)
8111ad14:	10800044 	addi	r2,r2,1
8111ad18:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111ad1c:	e0bff947 	ldb	r2,-27(fp)
8111ad20:	10800ed8 	cmpnei	r2,r2,59
8111ad24:	103feb1e 	bne	r2,zero,8111acd4 <__reset+0xfb0facd4>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111ad28:	e0bffa17 	ldw	r2,-24(fp)
8111ad2c:	00c00284 	movi	r3,10
8111ad30:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.usiDelay = atoi( inteiro );
8111ad34:	e0bffd04 	addi	r2,fp,-12
8111ad38:	1009883a 	mov	r4,r2
8111ad3c:	1120e480 	call	81120e48 <atoi>
8111ad40:	1007883a 	mov	r3,r2
8111ad44:	00a045b4 	movhi	r2,33046
8111ad48:	1099c904 	addi	r2,r2,26404
8111ad4c:	10c0070d 	sth	r3,28(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111ad50:	e0bffd04 	addi	r2,fp,-12
8111ad54:	e0bffa15 	stw	r2,-24(fp)

						break;
8111ad58:	0000ab06 	br	8111b008 <vLoadDebugConfs+0xbf4>
					case 'K':

						do {
							c = cGetNextChar(siFile);
8111ad5c:	e0bffc0f 	ldh	r2,-16(fp)
8111ad60:	1009883a 	mov	r4,r2
8111ad64:	111e58c0 	call	8111e58c <cGetNextChar>
8111ad68:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
8111ad6c:	d0e00317 	ldw	r3,-32756(gp)
8111ad70:	e0bff947 	ldb	r2,-27(fp)
8111ad74:	10800044 	addi	r2,r2,1
8111ad78:	1885883a 	add	r2,r3,r2
8111ad7c:	10800003 	ldbu	r2,0(r2)
8111ad80:	10803fcc 	andi	r2,r2,255
8111ad84:	1080010c 	andi	r2,r2,4
8111ad88:	10000626 	beq	r2,zero,8111ada4 <vLoadDebugConfs+0x990>
								(*p_inteiro) = c;
8111ad8c:	e0bffa17 	ldw	r2,-24(fp)
8111ad90:	e0fff943 	ldbu	r3,-27(fp)
8111ad94:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111ad98:	e0bffa17 	ldw	r2,-24(fp)
8111ad9c:	10800044 	addi	r2,r2,1
8111ada0:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111ada4:	e0bff947 	ldb	r2,-27(fp)
8111ada8:	10800ed8 	cmpnei	r2,r2,59
8111adac:	103feb1e 	bne	r2,zero,8111ad5c <__reset+0xfb0fad5c>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111adb0:	e0bffa17 	ldw	r2,-24(fp)
8111adb4:	00c00284 	movi	r3,10
8111adb8:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.ulColDelay = atoi( inteiro );
8111adbc:	e0bffd04 	addi	r2,fp,-12
8111adc0:	1009883a 	mov	r4,r2
8111adc4:	1120e480 	call	81120e48 <atoi>
8111adc8:	1007883a 	mov	r3,r2
8111adcc:	00a045b4 	movhi	r2,33046
8111add0:	1099c904 	addi	r2,r2,26404
8111add4:	10c00a15 	stw	r3,40(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111add8:	e0bffd04 	addi	r2,fp,-12
8111addc:	e0bffa15 	stw	r2,-24(fp)

						break;
8111ade0:	00008906 	br	8111b008 <vLoadDebugConfs+0xbf4>
					case 'M':

						do {
							c = cGetNextChar(siFile);
8111ade4:	e0bffc0f 	ldh	r2,-16(fp)
8111ade8:	1009883a 	mov	r4,r2
8111adec:	111e58c0 	call	8111e58c <cGetNextChar>
8111adf0:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
8111adf4:	d0e00317 	ldw	r3,-32756(gp)
8111adf8:	e0bff947 	ldb	r2,-27(fp)
8111adfc:	10800044 	addi	r2,r2,1
8111ae00:	1885883a 	add	r2,r3,r2
8111ae04:	10800003 	ldbu	r2,0(r2)
8111ae08:	10803fcc 	andi	r2,r2,255
8111ae0c:	1080010c 	andi	r2,r2,4
8111ae10:	10000626 	beq	r2,zero,8111ae2c <vLoadDebugConfs+0xa18>
								(*p_inteiro) = c;
8111ae14:	e0bffa17 	ldw	r2,-24(fp)
8111ae18:	e0fff943 	ldbu	r3,-27(fp)
8111ae1c:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111ae20:	e0bffa17 	ldw	r2,-24(fp)
8111ae24:	10800044 	addi	r2,r2,1
8111ae28:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111ae2c:	e0bff947 	ldb	r2,-27(fp)
8111ae30:	10800ed8 	cmpnei	r2,r2,59
8111ae34:	103feb1e 	bne	r2,zero,8111ade4 <__reset+0xfb0fade4>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111ae38:	e0bffa17 	ldw	r2,-24(fp)
8111ae3c:	00c00284 	movi	r3,10
8111ae40:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.ulADCPixelDelay = atoi( inteiro );
8111ae44:	e0bffd04 	addi	r2,fp,-12
8111ae48:	1009883a 	mov	r4,r2
8111ae4c:	1120e480 	call	81120e48 <atoi>
8111ae50:	1007883a 	mov	r3,r2
8111ae54:	00a045b4 	movhi	r2,33046
8111ae58:	1099c904 	addi	r2,r2,26404
8111ae5c:	10c00b15 	stw	r3,44(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111ae60:	e0bffd04 	addi	r2,fp,-12
8111ae64:	e0bffa15 	stw	r2,-24(fp)

						break;
8111ae68:	00006706 	br	8111b008 <vLoadDebugConfs+0xbf4>
					case 'J':

						do {
							c = cGetNextChar(siFile);
8111ae6c:	e0bffc0f 	ldh	r2,-16(fp)
8111ae70:	1009883a 	mov	r4,r2
8111ae74:	111e58c0 	call	8111e58c <cGetNextChar>
8111ae78:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
8111ae7c:	d0e00317 	ldw	r3,-32756(gp)
8111ae80:	e0bff947 	ldb	r2,-27(fp)
8111ae84:	10800044 	addi	r2,r2,1
8111ae88:	1885883a 	add	r2,r3,r2
8111ae8c:	10800003 	ldbu	r2,0(r2)
8111ae90:	10803fcc 	andi	r2,r2,255
8111ae94:	1080010c 	andi	r2,r2,4
8111ae98:	10000626 	beq	r2,zero,8111aeb4 <vLoadDebugConfs+0xaa0>
								(*p_inteiro) = c;
8111ae9c:	e0bffa17 	ldw	r2,-24(fp)
8111aea0:	e0fff943 	ldbu	r3,-27(fp)
8111aea4:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111aea8:	e0bffa17 	ldw	r2,-24(fp)
8111aeac:	10800044 	addi	r2,r2,1
8111aeb0:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111aeb4:	e0bff947 	ldb	r2,-27(fp)
8111aeb8:	10800ed8 	cmpnei	r2,r2,59
8111aebc:	103feb1e 	bne	r2,zero,8111ae6c <__reset+0xfb0fae6c>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111aec0:	e0bffa17 	ldw	r2,-24(fp)
8111aec4:	00c00284 	movi	r3,10
8111aec8:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.ulLineDelay = atoi( inteiro );
8111aecc:	e0bffd04 	addi	r2,fp,-12
8111aed0:	1009883a 	mov	r4,r2
8111aed4:	1120e480 	call	81120e48 <atoi>
8111aed8:	1007883a 	mov	r3,r2
8111aedc:	00a045b4 	movhi	r2,33046
8111aee0:	1099c904 	addi	r2,r2,26404
8111aee4:	10c00915 	stw	r3,36(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111aee8:	e0bffd04 	addi	r2,fp,-12
8111aeec:	e0bffa15 	stw	r2,-24(fp)

						break;
8111aef0:	00004506 	br	8111b008 <vLoadDebugConfs+0xbf4>
					case 'T':

						do {
							c = cGetNextChar(siFile);
8111aef4:	e0bffc0f 	ldh	r2,-16(fp)
8111aef8:	1009883a 	mov	r4,r2
8111aefc:	111e58c0 	call	8111e58c <cGetNextChar>
8111af00:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
8111af04:	d0e00317 	ldw	r3,-32756(gp)
8111af08:	e0bff947 	ldb	r2,-27(fp)
8111af0c:	10800044 	addi	r2,r2,1
8111af10:	1885883a 	add	r2,r3,r2
8111af14:	10800003 	ldbu	r2,0(r2)
8111af18:	10803fcc 	andi	r2,r2,255
8111af1c:	1080010c 	andi	r2,r2,4
8111af20:	10000626 	beq	r2,zero,8111af3c <vLoadDebugConfs+0xb28>
								(*p_inteiro) = c;
8111af24:	e0bffa17 	ldw	r2,-24(fp)
8111af28:	e0fff943 	ldbu	r3,-27(fp)
8111af2c:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111af30:	e0bffa17 	ldw	r2,-24(fp)
8111af34:	10800044 	addi	r2,r2,1
8111af38:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111af3c:	e0bff947 	ldb	r2,-27(fp)
8111af40:	10800ed8 	cmpnei	r2,r2,59
8111af44:	103feb1e 	bne	r2,zero,8111aef4 <__reset+0xfb0faef4>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111af48:	e0bffa17 	ldw	r2,-24(fp)
8111af4c:	00c00284 	movi	r3,10
8111af50:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						sidhcpTemp = atoi( inteiro );
8111af54:	e0bffd04 	addi	r2,fp,-12
8111af58:	1009883a 	mov	r4,r2
8111af5c:	1120e480 	call	81120e48 <atoi>
8111af60:	e0bffc8d 	sth	r2,-14(fp)
						if (sidhcpTemp == 1)
8111af64:	e0bffc8f 	ldh	r2,-14(fp)
8111af68:	10800058 	cmpnei	r2,r2,1
8111af6c:	1000051e 	bne	r2,zero,8111af84 <vLoadDebugConfs+0xb70>
							xDefaults.bDataPacket = TRUE;
8111af70:	00a045b4 	movhi	r2,33046
8111af74:	1099c904 	addi	r2,r2,26404
8111af78:	00c00044 	movi	r3,1
8111af7c:	10c00815 	stw	r3,32(r2)
8111af80:	00000306 	br	8111af90 <vLoadDebugConfs+0xb7c>
						else
							xDefaults.bDataPacket = FALSE;
8111af84:	00a045b4 	movhi	r2,33046
8111af88:	1099c904 	addi	r2,r2,26404
8111af8c:	10000815 	stw	zero,32(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111af90:	e0bffd04 	addi	r2,fp,-12
8111af94:	e0bffa15 	stw	r2,-24(fp)

						break;
8111af98:	00001b06 	br	8111b008 <vLoadDebugConfs+0xbf4>
					case 0x3C: //"<"
						close = siCloseFile(siFile);
8111af9c:	e0bffc0f 	ldh	r2,-16(fp)
8111afa0:	1009883a 	mov	r4,r2
8111afa4:	111e54c0 	call	8111e54c <siCloseFile>
8111afa8:	e0bffb15 	stw	r2,-20(fp)
						if (close == FALSE){
8111afac:	e0bffb17 	ldw	r2,-20(fp)
8111afb0:	1000071e 	bne	r2,zero,8111afd0 <vLoadDebugConfs+0xbbc>
							#ifdef DEBUG_ON
								debug(fp,"SDCard: Can't close the file.\n");
8111afb4:	d0a06217 	ldw	r2,-32376(gp)
8111afb8:	100f883a 	mov	r7,r2
8111afbc:	01800784 	movi	r6,30
8111afc0:	01400044 	movi	r5,1
8111afc4:	01204574 	movhi	r4,33045
8111afc8:	21395f04 	addi	r4,r4,-6788
8111afcc:	11216400 	call	81121640 <fwrite>
							#endif
						}
						/* End of Parser File */
						bEOF = TRUE;
8111afd0:	00800044 	movi	r2,1
8111afd4:	e0bff815 	stw	r2,-32(fp)
						bSuccess = TRUE; //pensar melhor
8111afd8:	00800044 	movi	r2,1
8111afdc:	e0bff715 	stw	r2,-36(fp)
						break;
8111afe0:	00000906 	br	8111b008 <vLoadDebugConfs+0xbf4>
					default:
						#ifdef DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
8111afe4:	d0a06217 	ldw	r2,-32376(gp)
8111afe8:	100f883a 	mov	r7,r2
8111afec:	01800844 	movi	r6,33
8111aff0:	01400044 	movi	r5,1
8111aff4:	01204574 	movhi	r4,33045
8111aff8:	21396704 	addi	r4,r4,-6756
8111affc:	11216400 	call	81121640 <fwrite>
						#endif
						break;
8111b000:	00000106 	br	8111b008 <vLoadDebugConfs+0xbf4>
						bEOF = TRUE;
						break;
					case 0x20: 	//ASCII: 0x20 = space
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
8111b004:	0001883a 	nop
						#ifdef DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
						#endif
						break;
				}
			} while ( bEOF == FALSE );
8111b008:	e0bff817 	ldw	r2,-32(fp)
8111b00c:	103d1f26 	beq	r2,zero,8111a48c <__reset+0xfb0fa48c>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( DEBUG_FILE_NAME );

		if ( siFile >= 0 ){
8111b010:	00000f06 	br	8111b050 <vLoadDebugConfs+0xc3c>
						break;
				}
			} while ( bEOF == FALSE );
		} else {
			#ifdef DEBUG_ON
				fprintf(fp,"SDCard: File not found.\n");
8111b014:	d0a06217 	ldw	r2,-32376(gp)
8111b018:	100f883a 	mov	r7,r2
8111b01c:	01800604 	movi	r6,24
8111b020:	01400044 	movi	r5,1
8111b024:	01204574 	movhi	r4,33045
8111b028:	21397004 	addi	r4,r4,-6720
8111b02c:	11216400 	call	81121640 <fwrite>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( DEBUG_FILE_NAME );

		if ( siFile >= 0 ){
8111b030:	00000706 	br	8111b050 <vLoadDebugConfs+0xc3c>
				fprintf(fp,"SDCard: File not found.\n");
			#endif
		}
	} else {
		#ifdef DEBUG_ON
			fprintf(fp,"SDCard: No SDCard.\n");
8111b034:	d0a06217 	ldw	r2,-32376(gp)
8111b038:	100f883a 	mov	r7,r2
8111b03c:	018004c4 	movi	r6,19
8111b040:	01400044 	movi	r5,1
8111b044:	01204574 	movhi	r4,33045
8111b048:	21397704 	addi	r4,r4,-6692
8111b04c:	11216400 	call	81121640 <fwrite>
		#endif
	}
	/* Load the default configuration if not successful in read the SDCard */
	if ( bSuccess == FALSE ) {
8111b050:	e0bff717 	ldw	r2,-36(fp)
8111b054:	1000391e 	bne	r2,zero,8111b13c <vLoadDebugConfs+0xd28>
		/*Enviar mensagem que e gravar log que no encontrou o arquivo e comeara a utilizar o padrao*/
		printf("Debug Configs: Could not load the default values from SDCard\n");
8111b058:	01204574 	movhi	r4,33045
8111b05c:	2139c904 	addi	r4,r4,-6364
8111b060:	11225f00 	call	811225f0 <puts>
		printf("Can't find the file:'%s'.\n", ETH_FILE_NAME);
8111b064:	01604574 	movhi	r5,33045
8111b068:	29795604 	addi	r5,r5,-6824
8111b06c:	01204574 	movhi	r4,33045
8111b070:	2139d904 	addi	r4,r4,-6300
8111b074:	112236c0 	call	8112236c <printf>



		xDefaults.usiRows = 4510;
8111b078:	00a045b4 	movhi	r2,33046
8111b07c:	1099c904 	addi	r2,r2,26404
8111b080:	00c46784 	movi	r3,4510
8111b084:	10c0060d 	sth	r3,24(r2)
		xDefaults.usiCols = 2255;
8111b088:	00a045b4 	movhi	r2,33046
8111b08c:	1099c904 	addi	r2,r2,26404
8111b090:	00c233c4 	movi	r3,2255
8111b094:	10c0058d 	sth	r3,22(r2)
		xDefaults.usiOLN = 30;
8111b098:	00a045b4 	movhi	r2,33046
8111b09c:	1099c904 	addi	r2,r2,26404
8111b0a0:	00c00784 	movi	r3,30
8111b0a4:	10c0050d 	sth	r3,20(r2)
		xDefaults.usiPreScanSerial = 25;
8111b0a8:	00a045b4 	movhi	r2,33046
8111b0ac:	1099c904 	addi	r2,r2,26404
8111b0b0:	00c00644 	movi	r3,25
8111b0b4:	10c0048d 	sth	r3,18(r2)
		xDefaults.usiOverScanSerial = 15;
8111b0b8:	00a045b4 	movhi	r2,33046
8111b0bc:	1099c904 	addi	r2,r2,26404
8111b0c0:	00c003c4 	movi	r3,15
8111b0c4:	10c0040d 	sth	r3,16(r2)
		xDefaults.usiSyncPeriod = 6250;
8111b0c8:	00a045b4 	movhi	r2,33046
8111b0cc:	1099c904 	addi	r2,r2,26404
8111b0d0:	00c61a84 	movi	r3,6250
8111b0d4:	10c0068d 	sth	r3,26(r2)
		xDefaults.usiDelay = 20;
8111b0d8:	00a045b4 	movhi	r2,33046
8111b0dc:	1099c904 	addi	r2,r2,26404
8111b0e0:	00c00504 	movi	r3,20
8111b0e4:	10c0070d 	sth	r3,28(r2)
		xDefaults.bDataPacket = TRUE;
8111b0e8:	00a045b4 	movhi	r2,33046
8111b0ec:	1099c904 	addi	r2,r2,26404
8111b0f0:	00c00044 	movi	r3,1
8111b0f4:	10c00815 	stw	r3,32(r2)
		xDefaults.ulLineDelay = 0;
8111b0f8:	00a045b4 	movhi	r2,33046
8111b0fc:	1099c904 	addi	r2,r2,26404
8111b100:	10000915 	stw	zero,36(r2)
		xDefaults.ulColDelay = 0;
8111b104:	00a045b4 	movhi	r2,33046
8111b108:	1099c904 	addi	r2,r2,26404
8111b10c:	10000a15 	stw	zero,40(r2)
		xDefaults.ulADCPixelDelay = 0;
8111b110:	00a045b4 	movhi	r2,33046
8111b114:	1099c904 	addi	r2,r2,26404
8111b118:	10000b15 	stw	zero,44(r2)
		xDefaults.ucLogicalAddr = 0x51;
8111b11c:	00a045b4 	movhi	r2,33046
8111b120:	1099c904 	addi	r2,r2,26404
8111b124:	00c01444 	movi	r3,81
8111b128:	10c00c8d 	sth	r3,50(r2)
		xDefaults.ucRmapKey = 0xD1;
8111b12c:	00a045b4 	movhi	r2,33046
8111b130:	1099c904 	addi	r2,r2,26404
8111b134:	00c03444 	movi	r3,209
8111b138:	10c00c0d 	sth	r3,48(r2)

	}

	return bSuccess;
8111b13c:	e0bff717 	ldw	r2,-36(fp)
}
8111b140:	e6ffff04 	addi	sp,fp,-4
8111b144:	dfc00217 	ldw	ra,8(sp)
8111b148:	df000117 	ldw	fp,4(sp)
8111b14c:	dc000017 	ldw	r16,0(sp)
8111b150:	dec00304 	addi	sp,sp,12
8111b154:	f800283a 	ret

8111b158 <ucCrc8>:

#include "crc8.h"


unsigned char ucCrc8(unsigned crc, unsigned char const *data, size_t len)
{
8111b158:	defffb04 	addi	sp,sp,-20
8111b15c:	de00012e 	bgeu	sp,et,8111b164 <ucCrc8+0xc>
8111b160:	003b68fa 	trap	3
8111b164:	df000415 	stw	fp,16(sp)
8111b168:	df000404 	addi	fp,sp,16
8111b16c:	e13ffd15 	stw	r4,-12(fp)
8111b170:	e17ffe15 	stw	r5,-8(fp)
8111b174:	e1bfff15 	stw	r6,-4(fp)
    if (data == NULL)
8111b178:	e0bffe17 	ldw	r2,-8(fp)
8111b17c:	1000021e 	bne	r2,zero,8111b188 <ucCrc8+0x30>
        return 0;
8111b180:	0005883a 	mov	r2,zero
8111b184:	00001906 	br	8111b1ec <ucCrc8+0x94>
    crc &= 0xff;
8111b188:	e0bffd17 	ldw	r2,-12(fp)
8111b18c:	10803fcc 	andi	r2,r2,255
8111b190:	e0bffd15 	stw	r2,-12(fp)
    unsigned char const *end = data + len;
8111b194:	e0fffe17 	ldw	r3,-8(fp)
8111b198:	e0bfff17 	ldw	r2,-4(fp)
8111b19c:	1885883a 	add	r2,r3,r2
8111b1a0:	e0bffc15 	stw	r2,-16(fp)
    while (data < end)
8111b1a4:	00000d06 	br	8111b1dc <ucCrc8+0x84>
        crc = crc8_table[crc ^ *data++];
8111b1a8:	e0bffe17 	ldw	r2,-8(fp)
8111b1ac:	10c00044 	addi	r3,r2,1
8111b1b0:	e0fffe15 	stw	r3,-8(fp)
8111b1b4:	10800003 	ldbu	r2,0(r2)
8111b1b8:	10c03fcc 	andi	r3,r2,255
8111b1bc:	e0bffd17 	ldw	r2,-12(fp)
8111b1c0:	1886f03a 	xor	r3,r3,r2
8111b1c4:	00a04574 	movhi	r2,33045
8111b1c8:	10b9dfc4 	addi	r2,r2,-6273
8111b1cc:	10c5883a 	add	r2,r2,r3
8111b1d0:	10800003 	ldbu	r2,0(r2)
8111b1d4:	10803fcc 	andi	r2,r2,255
8111b1d8:	e0bffd15 	stw	r2,-12(fp)
{
    if (data == NULL)
        return 0;
    crc &= 0xff;
    unsigned char const *end = data + len;
    while (data < end)
8111b1dc:	e0fffe17 	ldw	r3,-8(fp)
8111b1e0:	e0bffc17 	ldw	r2,-16(fp)
8111b1e4:	18bff036 	bltu	r3,r2,8111b1a8 <__reset+0xfb0fb1a8>
        crc = crc8_table[crc ^ *data++];
    return crc;
8111b1e8:	e0bffd17 	ldw	r2,-12(fp)
}
8111b1ec:	e037883a 	mov	sp,fp
8111b1f0:	df000017 	ldw	fp,0(sp)
8111b1f4:	dec00104 	addi	sp,sp,4
8111b1f8:	f800283a 	ret

8111b1fc <ucCrc8wInit>:

unsigned char ucCrc8wInit(char const *data, size_t len)
{
8111b1fc:	defffb04 	addi	sp,sp,-20
8111b200:	de00012e 	bgeu	sp,et,8111b208 <ucCrc8wInit+0xc>
8111b204:	003b68fa 	trap	3
8111b208:	dfc00415 	stw	ra,16(sp)
8111b20c:	df000315 	stw	fp,12(sp)
8111b210:	df000304 	addi	fp,sp,12
8111b214:	e13ffe15 	stw	r4,-8(fp)
8111b218:	e17fff15 	stw	r5,-4(fp)
	unsigned char crc;

	crc = ucCrc8(0, NULL, 0);
8111b21c:	000d883a 	mov	r6,zero
8111b220:	000b883a 	mov	r5,zero
8111b224:	0009883a 	mov	r4,zero
8111b228:	111b1580 	call	8111b158 <ucCrc8>
8111b22c:	e0bffd05 	stb	r2,-12(fp)
	return ucCrc8(crc, (unsigned char const *)data, len);
8111b230:	e0bffd03 	ldbu	r2,-12(fp)
8111b234:	e1bfff17 	ldw	r6,-4(fp)
8111b238:	e17ffe17 	ldw	r5,-8(fp)
8111b23c:	1009883a 	mov	r4,r2
8111b240:	111b1580 	call	8111b158 <ucCrc8>
}
8111b244:	e037883a 	mov	sp,fp
8111b248:	dfc00117 	ldw	ra,4(sp)
8111b24c:	df000017 	ldw	fp,0(sp)
8111b250:	dec00204 	addi	sp,sp,8
8111b254:	f800283a 	ret

8111b258 <vDataControllerInit>:


#include "data_controller.h"


void vDataControllerInit( TNData_Control *xDataControlL, TNFee_Control *xNfeeCOntrolL ) {
8111b258:	defffc04 	addi	sp,sp,-16
8111b25c:	de00012e 	bgeu	sp,et,8111b264 <vDataControllerInit+0xc>
8111b260:	003b68fa 	trap	3
8111b264:	df000315 	stw	fp,12(sp)
8111b268:	df000304 	addi	fp,sp,12
8111b26c:	e13ffe15 	stw	r4,-8(fp)
8111b270:	e17fff15 	stw	r5,-4(fp)
	unsigned char ucIL;

	xDataControlL->sMode = sMebInit;
8111b274:	e0bffe17 	ldw	r2,-8(fp)
8111b278:	10000615 	stw	zero,24(r2)

	for ( ucIL = 0 ; ucIL < N_OF_NFEE; ucIL++ ) {
8111b27c:	e03ffd05 	stb	zero,-12(fp)
8111b280:	00001c06 	br	8111b2f4 <vDataControllerInit+0x9c>
		xDataControlL->xReadOnlyFeeControl.xNfee[ucIL] = &xNfeeCOntrolL->xNfee[ucIL];
8111b284:	e0bffd03 	ldbu	r2,-12(fp)
8111b288:	e0fffd03 	ldbu	r3,-12(fp)
8111b28c:	18c09624 	muli	r3,r3,600
8111b290:	e13fff17 	ldw	r4,-4(fp)
8111b294:	20c7883a 	add	r3,r4,r3
8111b298:	e13ffe17 	ldw	r4,-8(fp)
8111b29c:	10800084 	addi	r2,r2,2
8111b2a0:	1085883a 	add	r2,r2,r2
8111b2a4:	1085883a 	add	r2,r2,r2
8111b2a8:	2085883a 	add	r2,r4,r2
8111b2ac:	10c00015 	stw	r3,0(r2)
		xDataControlL->xReadOnlyFeeControl.pbEnabledNFEEs[ucIL] = xNfeeCOntrolL->pbEnabledNFEEs[ucIL];
8111b2b0:	e17ffd03 	ldbu	r5,-12(fp)
8111b2b4:	e0bffd03 	ldbu	r2,-12(fp)
8111b2b8:	e0ffff17 	ldw	r3,-4(fp)
8111b2bc:	108025c4 	addi	r2,r2,151
8111b2c0:	1085883a 	add	r2,r2,r2
8111b2c4:	1085883a 	add	r2,r2,r2
8111b2c8:	1885883a 	add	r2,r3,r2
8111b2cc:	10c00017 	ldw	r3,0(r2)
8111b2d0:	e13ffe17 	ldw	r4,-8(fp)
8111b2d4:	288000c4 	addi	r2,r5,3
8111b2d8:	1085883a 	add	r2,r2,r2
8111b2dc:	1085883a 	add	r2,r2,r2
8111b2e0:	2085883a 	add	r2,r4,r2
8111b2e4:	10c00015 	stw	r3,0(r2)
void vDataControllerInit( TNData_Control *xDataControlL, TNFee_Control *xNfeeCOntrolL ) {
	unsigned char ucIL;

	xDataControlL->sMode = sMebInit;

	for ( ucIL = 0 ; ucIL < N_OF_NFEE; ucIL++ ) {
8111b2e8:	e0bffd03 	ldbu	r2,-12(fp)
8111b2ec:	10800044 	addi	r2,r2,1
8111b2f0:	e0bffd05 	stb	r2,-12(fp)
8111b2f4:	e0bffd03 	ldbu	r2,-12(fp)
8111b2f8:	103fe226 	beq	r2,zero,8111b284 <__reset+0xfb0fb284>
		xDataControlL->xReadOnlyFeeControl.xNfee[ucIL] = &xNfeeCOntrolL->xNfee[ucIL];
		xDataControlL->xReadOnlyFeeControl.pbEnabledNFEEs[ucIL] = xNfeeCOntrolL->pbEnabledNFEEs[ucIL];
	}
	
	xDataControlL->xReadOnlyFeeControl.ucTimeCode = &xNfeeCOntrolL->ucTimeCode;
8111b2fc:	e0bfff17 	ldw	r2,-4(fp)
8111b300:	10c09904 	addi	r3,r2,612
8111b304:	e0bffe17 	ldw	r2,-8(fp)
8111b308:	10c00415 	stw	r3,16(r2)
	xDataControlL->bUpdateComplete = FALSE;
8111b30c:	e0bffe17 	ldw	r2,-8(fp)
8111b310:	10000515 	stw	zero,20(r2)


	/* The only inverse attribution */
	/* This variable indicates when the DataControl finishs to use the RAM, then FeeControl can start fill the buffer to the next MasterSync */
	xNfeeCOntrolL->pbUpdateCReadOnly = &xDataControlL->bUpdateComplete;
8111b314:	e0bffe17 	ldw	r2,-8(fp)
8111b318:	10c00504 	addi	r3,r2,20
8111b31c:	e0bfff17 	ldw	r2,-4(fp)
8111b320:	10c09b15 	stw	r3,620(r2)
}
8111b324:	0001883a 	nop
8111b328:	e037883a 	mov	sp,fp
8111b32c:	df000017 	ldw	fp,0(sp)
8111b330:	dec00104 	addi	sp,sp,4
8111b334:	f800283a 	ret

8111b338 <printErrorTask>:

#include "error_handler_simucam.h"


#ifdef DEBUG_ON
    void printErrorTask( INT8U error_code ) {
8111b338:	defff904 	addi	sp,sp,-28
8111b33c:	de00012e 	bgeu	sp,et,8111b344 <printErrorTask+0xc>
8111b340:	003b68fa 	trap	3
8111b344:	dfc00615 	stw	ra,24(sp)
8111b348:	df000515 	stw	fp,20(sp)
8111b34c:	df000504 	addi	fp,sp,20
8111b350:	2005883a 	mov	r2,r4
8111b354:	e0bfff05 	stb	r2,-4(fp)
		char buffer[16] = "";
8111b358:	e03ffb15 	stw	zero,-20(fp)
8111b35c:	e03ffc15 	stw	zero,-16(fp)
8111b360:	e03ffd15 	stw	zero,-12(fp)
8111b364:	e03ffe15 	stw	zero,-8(fp)
		
		sprintf(buffer, "Err: %d\n", error_code);
8111b368:	e0bfff03 	ldbu	r2,-4(fp)
8111b36c:	100d883a 	mov	r6,r2
8111b370:	01604574 	movhi	r5,33045
8111b374:	297a2004 	addi	r5,r5,-6016
8111b378:	e13ffb04 	addi	r4,fp,-20
8111b37c:	11229340 	call	81122934 <sprintf>
		debug(fp, buffer);
8111b380:	d0a06217 	ldw	r2,-32376(gp)
8111b384:	e17ffb04 	addi	r5,fp,-20
8111b388:	1009883a 	mov	r4,r2
8111b38c:	1120fa40 	call	81120fa4 <fprintf>
	}
8111b390:	0001883a 	nop
8111b394:	e037883a 	mov	sp,fp
8111b398:	dfc00117 	ldw	ra,4(sp)
8111b39c:	df000017 	ldw	fp,0(sp)
8111b3a0:	dec00204 	addi	sp,sp,8
8111b3a4:	f800283a 	ret

8111b3a8 <vFailCreateMutexSResources>:
#endif

void vFailCreateMutexSResources( INT8U error_code )
{
8111b3a8:	defffd04 	addi	sp,sp,-12
8111b3ac:	de00012e 	bgeu	sp,et,8111b3b4 <vFailCreateMutexSResources+0xc>
8111b3b0:	003b68fa 	trap	3
8111b3b4:	dfc00215 	stw	ra,8(sp)
8111b3b8:	df000115 	stw	fp,4(sp)
8111b3bc:	df000104 	addi	fp,sp,4
8111b3c0:	2005883a 	mov	r2,r4
8111b3c4:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateMutexSResources. (exit)\n");
8111b3c8:	d0a06217 	ldw	r2,-32376(gp)
8111b3cc:	100f883a 	mov	r7,r2
8111b3d0:	018008c4 	movi	r6,35
8111b3d4:	01400044 	movi	r5,1
8111b3d8:	01204574 	movhi	r4,33045
8111b3dc:	213a2304 	addi	r4,r4,-6004
8111b3e0:	11216400 	call	81121640 <fwrite>
	#endif
	#ifdef DEBUG_ON
		printErrorTask(error_code);
8111b3e4:	e0bfff03 	ldbu	r2,-4(fp)
8111b3e8:	1009883a 	mov	r4,r2
8111b3ec:	111b3380 	call	8111b338 <printErrorTask>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b3f0:	0001883a 	nop
8111b3f4:	e037883a 	mov	sp,fp
8111b3f8:	dfc00117 	ldw	ra,4(sp)
8111b3fc:	df000017 	ldw	fp,0(sp)
8111b400:	dec00204 	addi	sp,sp,8
8111b404:	f800283a 	ret

8111b408 <vFailCreateMutexDMA>:

void vFailCreateMutexDMA( void )
{
8111b408:	defffe04 	addi	sp,sp,-8
8111b40c:	de00012e 	bgeu	sp,et,8111b414 <vFailCreateMutexDMA+0xc>
8111b410:	003b68fa 	trap	3
8111b414:	dfc00115 	stw	ra,4(sp)
8111b418:	df000015 	stw	fp,0(sp)
8111b41c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp," CRITICAL: vFailCreateMutexDMA. (exit)\n");
8111b420:	d0a06217 	ldw	r2,-32376(gp)
8111b424:	100f883a 	mov	r7,r2
8111b428:	018009c4 	movi	r6,39
8111b42c:	01400044 	movi	r5,1
8111b430:	01204574 	movhi	r4,33045
8111b434:	213a2c04 	addi	r4,r4,-5968
8111b438:	11216400 	call	81121640 <fwrite>

	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b43c:	0001883a 	nop
8111b440:	e037883a 	mov	sp,fp
8111b444:	dfc00117 	ldw	ra,4(sp)
8111b448:	df000017 	ldw	fp,0(sp)
8111b44c:	dec00204 	addi	sp,sp,8
8111b450:	f800283a 	ret

8111b454 <vFailCreateSemaphoreResources>:

void vFailCreateSemaphoreResources( void )
{
8111b454:	defffe04 	addi	sp,sp,-8
8111b458:	de00012e 	bgeu	sp,et,8111b460 <vFailCreateSemaphoreResources+0xc>
8111b45c:	003b68fa 	trap	3
8111b460:	dfc00115 	stw	ra,4(sp)
8111b464:	df000015 	stw	fp,0(sp)
8111b468:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateSemaphoreResources. (exit)\n");
8111b46c:	d0a06217 	ldw	r2,-32376(gp)
8111b470:	100f883a 	mov	r7,r2
8111b474:	01800984 	movi	r6,38
8111b478:	01400044 	movi	r5,1
8111b47c:	01204574 	movhi	r4,33045
8111b480:	213a3604 	addi	r4,r4,-5928
8111b484:	11216400 	call	81121640 <fwrite>

	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b488:	0001883a 	nop
8111b48c:	e037883a 	mov	sp,fp
8111b490:	dfc00117 	ldw	ra,4(sp)
8111b494:	df000017 	ldw	fp,0(sp)
8111b498:	dec00204 	addi	sp,sp,8
8111b49c:	f800283a 	ret

8111b4a0 <vFailTestCriticasParts>:


void vFailTestCriticasParts( void )
{
8111b4a0:	defffe04 	addi	sp,sp,-8
8111b4a4:	de00012e 	bgeu	sp,et,8111b4ac <vFailTestCriticasParts+0xc>
8111b4a8:	003b68fa 	trap	3
8111b4ac:	dfc00115 	stw	ra,4(sp)
8111b4b0:	df000015 	stw	fp,0(sp)
8111b4b4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailTestCriticasParts. (exit)\n");
8111b4b8:	d0a06217 	ldw	r2,-32376(gp)
8111b4bc:	100f883a 	mov	r7,r2
8111b4c0:	018007c4 	movi	r6,31
8111b4c4:	01400044 	movi	r5,1
8111b4c8:	01204574 	movhi	r4,33045
8111b4cc:	213a4004 	addi	r4,r4,-5888
8111b4d0:	11216400 	call	81121640 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b4d4:	0001883a 	nop
8111b4d8:	e037883a 	mov	sp,fp
8111b4dc:	dfc00117 	ldw	ra,4(sp)
8111b4e0:	df000017 	ldw	fp,0(sp)
8111b4e4:	dec00204 	addi	sp,sp,8
8111b4e8:	f800283a 	ret

8111b4ec <vFailSendxSemCommInit>:


void vFailSendxSemCommInit( void )
{
8111b4ec:	defffe04 	addi	sp,sp,-8
8111b4f0:	de00012e 	bgeu	sp,et,8111b4f8 <vFailSendxSemCommInit+0xc>
8111b4f4:	003b68fa 	trap	3
8111b4f8:	dfc00115 	stw	ra,4(sp)
8111b4fc:	df000015 	stw	fp,0(sp)
8111b500:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendxSemCommInit. (exit)");
8111b504:	d0a06217 	ldw	r2,-32376(gp)
8111b508:	100f883a 	mov	r7,r2
8111b50c:	01800744 	movi	r6,29
8111b510:	01400044 	movi	r5,1
8111b514:	01204574 	movhi	r4,33045
8111b518:	213a4804 	addi	r4,r4,-5856
8111b51c:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the vParserRXTask. (exit)\n");
8111b520:	d0a06217 	ldw	r2,-32376(gp)
8111b524:	100f883a 	mov	r7,r2
8111b528:	01800a44 	movi	r6,41
8111b52c:	01400044 	movi	r5,1
8111b530:	01204574 	movhi	r4,33045
8111b534:	213a5004 	addi	r4,r4,-5824
8111b538:	11216400 	call	81121640 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b53c:	0001883a 	nop
8111b540:	e037883a 	mov	sp,fp
8111b544:	dfc00117 	ldw	ra,4(sp)
8111b548:	df000017 	ldw	fp,0(sp)
8111b54c:	dec00204 	addi	sp,sp,8
8111b550:	f800283a 	ret

8111b554 <vFailSendPreParsedSemaphore>:

void vFailSendPreParsedSemaphore( void )
{
8111b554:	defffe04 	addi	sp,sp,-8
8111b558:	de00012e 	bgeu	sp,et,8111b560 <vFailSendPreParsedSemaphore+0xc>
8111b55c:	003b68fa 	trap	3
8111b560:	dfc00115 	stw	ra,4(sp)
8111b564:	df000015 	stw	fp,0(sp)
8111b568:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreParsedSemaphore. (exit)\n");
8111b56c:	d0a06217 	ldw	r2,-32376(gp)
8111b570:	100f883a 	mov	r7,r2
8111b574:	01800904 	movi	r6,36
8111b578:	01400044 	movi	r5,1
8111b57c:	01204574 	movhi	r4,33045
8111b580:	213a5b04 	addi	r4,r4,-5780
8111b584:	11216400 	call	81121640 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b588:	0001883a 	nop
8111b58c:	e037883a 	mov	sp,fp
8111b590:	dfc00117 	ldw	ra,4(sp)
8111b594:	df000017 	ldw	fp,0(sp)
8111b598:	dec00204 	addi	sp,sp,8
8111b59c:	f800283a 	ret

8111b5a0 <vFailSendPreAckReceiverSemaphore>:

void vFailSendPreAckReceiverSemaphore( void )
{
8111b5a0:	defffe04 	addi	sp,sp,-8
8111b5a4:	de00012e 	bgeu	sp,et,8111b5ac <vFailSendPreAckReceiverSemaphore+0xc>
8111b5a8:	003b68fa 	trap	3
8111b5ac:	dfc00115 	stw	ra,4(sp)
8111b5b0:	df000015 	stw	fp,0(sp)
8111b5b4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreAckReceiverSemaphore. (exit)\n");
8111b5b8:	d0a06217 	ldw	r2,-32376(gp)
8111b5bc:	100f883a 	mov	r7,r2
8111b5c0:	01800a44 	movi	r6,41
8111b5c4:	01400044 	movi	r5,1
8111b5c8:	01204574 	movhi	r4,33045
8111b5cc:	213a6504 	addi	r4,r4,-5740
8111b5d0:	11216400 	call	81121640 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b5d4:	0001883a 	nop
8111b5d8:	e037883a 	mov	sp,fp
8111b5dc:	dfc00117 	ldw	ra,4(sp)
8111b5e0:	df000017 	ldw	fp,0(sp)
8111b5e4:	dec00204 	addi	sp,sp,8
8111b5e8:	f800283a 	ret

8111b5ec <vFailSendPreAckSenderSemaphore>:


void vFailSendPreAckSenderSemaphore( void )
{
8111b5ec:	defffe04 	addi	sp,sp,-8
8111b5f0:	de00012e 	bgeu	sp,et,8111b5f8 <vFailSendPreAckSenderSemaphore+0xc>
8111b5f4:	003b68fa 	trap	3
8111b5f8:	dfc00115 	stw	ra,4(sp)
8111b5fc:	df000015 	stw	fp,0(sp)
8111b600:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreAckSenderSemaphore. (exit)\n");
8111b604:	d0a06217 	ldw	r2,-32376(gp)
8111b608:	100f883a 	mov	r7,r2
8111b60c:	018009c4 	movi	r6,39
8111b610:	01400044 	movi	r5,1
8111b614:	01204574 	movhi	r4,33045
8111b618:	213a7004 	addi	r4,r4,-5696
8111b61c:	11216400 	call	81121640 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b620:	0001883a 	nop
8111b624:	e037883a 	mov	sp,fp
8111b628:	dfc00117 	ldw	ra,4(sp)
8111b62c:	df000017 	ldw	fp,0(sp)
8111b630:	dec00204 	addi	sp,sp,8
8111b634:	f800283a 	ret

8111b638 <vFailGetCountSemaphoreSenderTask>:


void vFailGetCountSemaphoreSenderTask( void )
{
8111b638:	defffe04 	addi	sp,sp,-8
8111b63c:	de00012e 	bgeu	sp,et,8111b644 <vFailGetCountSemaphoreSenderTask+0xc>
8111b640:	003b68fa 	trap	3
8111b644:	dfc00115 	stw	ra,4(sp)
8111b648:	df000015 	stw	fp,0(sp)
8111b64c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphoreSenderTask. (exit)\n");
8111b650:	d0a06217 	ldw	r2,-32376(gp)
8111b654:	100f883a 	mov	r7,r2
8111b658:	01800a44 	movi	r6,41
8111b65c:	01400044 	movi	r5,1
8111b660:	01204574 	movhi	r4,33045
8111b664:	213a7a04 	addi	r4,r4,-5656
8111b668:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vSenderAckTask)\n");
8111b66c:	d0a06217 	ldw	r2,-32376(gp)
8111b670:	100f883a 	mov	r7,r2
8111b674:	01801104 	movi	r6,68
8111b678:	01400044 	movi	r5,1
8111b67c:	01204574 	movhi	r4,33045
8111b680:	213a8504 	addi	r4,r4,-5612
8111b684:	11216400 	call	81121640 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b688:	0001883a 	nop
8111b68c:	e037883a 	mov	sp,fp
8111b690:	dfc00117 	ldw	ra,4(sp)
8111b694:	df000017 	ldw	fp,0(sp)
8111b698:	dec00204 	addi	sp,sp,8
8111b69c:	f800283a 	ret

8111b6a0 <vFailGetMutexSenderTask>:

void vFailGetMutexSenderTask( void )
{
8111b6a0:	defffe04 	addi	sp,sp,-8
8111b6a4:	de00012e 	bgeu	sp,et,8111b6ac <vFailGetMutexSenderTask+0xc>
8111b6a8:	003b68fa 	trap	3
8111b6ac:	dfc00115 	stw	ra,4(sp)
8111b6b0:	df000015 	stw	fp,0(sp)
8111b6b4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexSenderTask. (exit)\n");
8111b6b8:	d0a06217 	ldw	r2,-32376(gp)
8111b6bc:	100f883a 	mov	r7,r2
8111b6c0:	01800804 	movi	r6,32
8111b6c4:	01400044 	movi	r5,1
8111b6c8:	01204574 	movhi	r4,33045
8111b6cc:	213a9704 	addi	r4,r4,-5540
8111b6d0:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the xSenderACK.(vSenderAckTask)\n");
8111b6d4:	d0a06217 	ldw	r2,-32376(gp)
8111b6d8:	100f883a 	mov	r7,r2
8111b6dc:	01801084 	movi	r6,66
8111b6e0:	01400044 	movi	r5,1
8111b6e4:	01204574 	movhi	r4,33045
8111b6e8:	213aa004 	addi	r4,r4,-5504
8111b6ec:	11216400 	call	81121640 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b6f0:	0001883a 	nop
8111b6f4:	e037883a 	mov	sp,fp
8111b6f8:	dfc00117 	ldw	ra,4(sp)
8111b6fc:	df000017 	ldw	fp,0(sp)
8111b700:	dec00204 	addi	sp,sp,8
8111b704:	f800283a 	ret

8111b708 <vFailGetCountSemaphoreReceiverTask>:


void vFailGetCountSemaphoreReceiverTask( void )
{
8111b708:	defffe04 	addi	sp,sp,-8
8111b70c:	de00012e 	bgeu	sp,et,8111b714 <vFailGetCountSemaphoreReceiverTask+0xc>
8111b710:	003b68fa 	trap	3
8111b714:	dfc00115 	stw	ra,4(sp)
8111b718:	df000015 	stw	fp,0(sp)
8111b71c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphoreReceiverTask. (exit)\n");
8111b720:	d0a06217 	ldw	r2,-32376(gp)
8111b724:	100f883a 	mov	r7,r2
8111b728:	01800ac4 	movi	r6,43
8111b72c:	01400044 	movi	r5,1
8111b730:	01204574 	movhi	r4,33045
8111b734:	213ab104 	addi	r4,r4,-5436
8111b738:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vReceiverAckTask)\n");
8111b73c:	d0a06217 	ldw	r2,-32376(gp)
8111b740:	100f883a 	mov	r7,r2
8111b744:	01801184 	movi	r6,70
8111b748:	01400044 	movi	r5,1
8111b74c:	01204574 	movhi	r4,33045
8111b750:	213abc04 	addi	r4,r4,-5392
8111b754:	11216400 	call	81121640 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b758:	0001883a 	nop
8111b75c:	e037883a 	mov	sp,fp
8111b760:	dfc00117 	ldw	ra,4(sp)
8111b764:	df000017 	ldw	fp,0(sp)
8111b768:	dec00204 	addi	sp,sp,8
8111b76c:	f800283a 	ret

8111b770 <vFailGetMutexReceiverTask>:

void vFailGetMutexReceiverTask( void )
{
8111b770:	defffe04 	addi	sp,sp,-8
8111b774:	de00012e 	bgeu	sp,et,8111b77c <vFailGetMutexReceiverTask+0xc>
8111b778:	003b68fa 	trap	3
8111b77c:	dfc00115 	stw	ra,4(sp)
8111b780:	df000015 	stw	fp,0(sp)
8111b784:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexReceiverTask. (exit)\n");
8111b788:	d0a06217 	ldw	r2,-32376(gp)
8111b78c:	100f883a 	mov	r7,r2
8111b790:	01800884 	movi	r6,34
8111b794:	01400044 	movi	r5,1
8111b798:	01204574 	movhi	r4,33045
8111b79c:	213ace04 	addi	r4,r4,-5320
8111b7a0:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the xSenderACK.(vReceiverAckTask)\n");
8111b7a4:	d0a06217 	ldw	r2,-32376(gp)
8111b7a8:	100f883a 	mov	r7,r2
8111b7ac:	01801104 	movi	r6,68
8111b7b0:	01400044 	movi	r5,1
8111b7b4:	01204574 	movhi	r4,33045
8111b7b8:	213ad704 	addi	r4,r4,-5284
8111b7bc:	11216400 	call	81121640 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b7c0:	0001883a 	nop
8111b7c4:	e037883a 	mov	sp,fp
8111b7c8:	dfc00117 	ldw	ra,4(sp)
8111b7cc:	df000017 	ldw	fp,0(sp)
8111b7d0:	dec00204 	addi	sp,sp,8
8111b7d4:	f800283a 	ret

8111b7d8 <vFailGetMutexTxUARTSenderTask>:


void vFailGetMutexTxUARTSenderTask( void )
{
8111b7d8:	defffe04 	addi	sp,sp,-8
8111b7dc:	de00012e 	bgeu	sp,et,8111b7e4 <vFailGetMutexTxUARTSenderTask+0xc>
8111b7e0:	003b68fa 	trap	3
8111b7e4:	dfc00115 	stw	ra,4(sp)
8111b7e8:	df000015 	stw	fp,0(sp)
8111b7ec:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexTxUARTSenderTask. (exit)\n");
8111b7f0:	d0a06217 	ldw	r2,-32376(gp)
8111b7f4:	100f883a 	mov	r7,r2
8111b7f8:	01800984 	movi	r6,38
8111b7fc:	01400044 	movi	r5,1
8111b800:	01204574 	movhi	r4,33045
8111b804:	213ae904 	addi	r4,r4,-5212
8111b808:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the tx buffer.(vSenderAckTask)\n");
8111b80c:	d0a06217 	ldw	r2,-32376(gp)
8111b810:	100f883a 	mov	r7,r2
8111b814:	01801044 	movi	r6,65
8111b818:	01400044 	movi	r5,1
8111b81c:	01204574 	movhi	r4,33045
8111b820:	213af304 	addi	r4,r4,-5172
8111b824:	11216400 	call	81121640 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b828:	0001883a 	nop
8111b82c:	e037883a 	mov	sp,fp
8111b830:	dfc00117 	ldw	ra,4(sp)
8111b834:	df000017 	ldw	fp,0(sp)
8111b838:	dec00204 	addi	sp,sp,8
8111b83c:	f800283a 	ret

8111b840 <vFailGetMacRTC>:


void vFailGetMacRTC( void )
{
8111b840:	defffe04 	addi	sp,sp,-8
8111b844:	de00012e 	bgeu	sp,et,8111b84c <vFailGetMacRTC+0xc>
8111b848:	003b68fa 	trap	3
8111b84c:	dfc00115 	stw	ra,4(sp)
8111b850:	df000015 	stw	fp,0(sp)
8111b854:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMacRTC\n");
8111b858:	d0a06217 	ldw	r2,-32376(gp)
8111b85c:	100f883a 	mov	r7,r2
8111b860:	018003c4 	movi	r6,15
8111b864:	01400044 	movi	r5,1
8111b868:	01204574 	movhi	r4,33045
8111b86c:	213b0404 	addi	r4,r4,-5104
8111b870:	11216400 	call	81121640 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b874:	0001883a 	nop
8111b878:	e037883a 	mov	sp,fp
8111b87c:	dfc00117 	ldw	ra,4(sp)
8111b880:	df000017 	ldw	fp,0(sp)
8111b884:	dec00204 	addi	sp,sp,8
8111b888:	f800283a 	ret

8111b88c <vFailInitialization>:


void vFailInitialization( void )
{
8111b88c:	defffe04 	addi	sp,sp,-8
8111b890:	de00012e 	bgeu	sp,et,8111b898 <vFailInitialization+0xc>
8111b894:	003b68fa 	trap	3
8111b898:	dfc00115 	stw	ra,4(sp)
8111b89c:	df000015 	stw	fp,0(sp)
8111b8a0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInitialization\n");
8111b8a4:	d0a06217 	ldw	r2,-32376(gp)
8111b8a8:	100f883a 	mov	r7,r2
8111b8ac:	01800504 	movi	r6,20
8111b8b0:	01400044 	movi	r5,1
8111b8b4:	01204574 	movhi	r4,33045
8111b8b8:	213b0804 	addi	r4,r4,-5088
8111b8bc:	11216400 	call	81121640 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b8c0:	0001883a 	nop
8111b8c4:	e037883a 	mov	sp,fp
8111b8c8:	dfc00117 	ldw	ra,4(sp)
8111b8cc:	df000017 	ldw	fp,0(sp)
8111b8d0:	dec00204 	addi	sp,sp,8
8111b8d4:	f800283a 	ret

8111b8d8 <vFailReceiverCreate>:


void vFailReceiverCreate( void )
{
8111b8d8:	defffe04 	addi	sp,sp,-8
8111b8dc:	de00012e 	bgeu	sp,et,8111b8e4 <vFailReceiverCreate+0xc>
8111b8e0:	003b68fa 	trap	3
8111b8e4:	dfc00115 	stw	ra,4(sp)
8111b8e8:	df000015 	stw	fp,0(sp)
8111b8ec:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vReceiverUartTask\n");
8111b8f0:	d0a06217 	ldw	r2,-32376(gp)
8111b8f4:	100f883a 	mov	r7,r2
8111b8f8:	01800484 	movi	r6,18
8111b8fc:	01400044 	movi	r5,1
8111b900:	01204574 	movhi	r4,33045
8111b904:	213b0e04 	addi	r4,r4,-5064
8111b908:	11216400 	call	81121640 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b90c:	0001883a 	nop
8111b910:	e037883a 	mov	sp,fp
8111b914:	dfc00117 	ldw	ra,4(sp)
8111b918:	df000017 	ldw	fp,0(sp)
8111b91c:	dec00204 	addi	sp,sp,8
8111b920:	f800283a 	ret

8111b924 <vFailSenderCreate>:


void vFailSenderCreate( void )
{
8111b924:	defffe04 	addi	sp,sp,-8
8111b928:	de00012e 	bgeu	sp,et,8111b930 <vFailSenderCreate+0xc>
8111b92c:	003b68fa 	trap	3
8111b930:	dfc00115 	stw	ra,4(sp)
8111b934:	df000015 	stw	fp,0(sp)
8111b938:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSenderCreate\n");
8111b93c:	d0a06217 	ldw	r2,-32376(gp)
8111b940:	100f883a 	mov	r7,r2
8111b944:	01800484 	movi	r6,18
8111b948:	01400044 	movi	r5,1
8111b94c:	01204574 	movhi	r4,33045
8111b950:	213b1304 	addi	r4,r4,-5044
8111b954:	11216400 	call	81121640 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b958:	0001883a 	nop
8111b95c:	e037883a 	mov	sp,fp
8111b960:	dfc00117 	ldw	ra,4(sp)
8111b964:	df000017 	ldw	fp,0(sp)
8111b968:	dec00204 	addi	sp,sp,8
8111b96c:	f800283a 	ret

8111b970 <vFailDeleteInitialization>:


void vFailDeleteInitialization( void )
{
8111b970:	defffe04 	addi	sp,sp,-8
8111b974:	de00012e 	bgeu	sp,et,8111b97c <vFailDeleteInitialization+0xc>
8111b978:	003b68fa 	trap	3
8111b97c:	dfc00115 	stw	ra,4(sp)
8111b980:	df000015 	stw	fp,0(sp)
8111b984:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailDeleteInitialization\n");
8111b988:	d0a06217 	ldw	r2,-32376(gp)
8111b98c:	100f883a 	mov	r7,r2
8111b990:	01800684 	movi	r6,26
8111b994:	01400044 	movi	r5,1
8111b998:	01204574 	movhi	r4,33045
8111b99c:	213b1804 	addi	r4,r4,-5024
8111b9a0:	11216400 	call	81121640 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b9a4:	0001883a 	nop
8111b9a8:	e037883a 	mov	sp,fp
8111b9ac:	dfc00117 	ldw	ra,4(sp)
8111b9b0:	df000017 	ldw	fp,0(sp)
8111b9b4:	dec00204 	addi	sp,sp,8
8111b9b8:	f800283a 	ret

8111b9bc <vFailSetCountSemaphorexBuffer32>:


void vFailSetCountSemaphorexBuffer32( void )
{
8111b9bc:	defffe04 	addi	sp,sp,-8
8111b9c0:	de00012e 	bgeu	sp,et,8111b9c8 <vFailSetCountSemaphorexBuffer32+0xc>
8111b9c4:	003b68fa 	trap	3
8111b9c8:	dfc00115 	stw	ra,4(sp)
8111b9cc:	df000015 	stw	fp,0(sp)
8111b9d0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer32. (exit)\n");
8111b9d4:	d0a06217 	ldw	r2,-32376(gp)
8111b9d8:	100f883a 	mov	r7,r2
8111b9dc:	01800a04 	movi	r6,40
8111b9e0:	01400044 	movi	r5,1
8111b9e4:	01204574 	movhi	r4,33045
8111b9e8:	213b1f04 	addi	r4,r4,-4996
8111b9ec:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
8111b9f0:	d0a06217 	ldw	r2,-32376(gp)
8111b9f4:	100f883a 	mov	r7,r2
8111b9f8:	018008c4 	movi	r6,35
8111b9fc:	01400044 	movi	r5,1
8111ba00:	01204574 	movhi	r4,33045
8111ba04:	213b2a04 	addi	r4,r4,-4952
8111ba08:	11216400 	call	81121640 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ba0c:	0001883a 	nop
8111ba10:	e037883a 	mov	sp,fp
8111ba14:	dfc00117 	ldw	ra,4(sp)
8111ba18:	df000017 	ldw	fp,0(sp)
8111ba1c:	dec00204 	addi	sp,sp,8
8111ba20:	f800283a 	ret

8111ba24 <vFailSetCountSemaphorexBuffer64>:

void vFailSetCountSemaphorexBuffer64( void )
{
8111ba24:	defffe04 	addi	sp,sp,-8
8111ba28:	de00012e 	bgeu	sp,et,8111ba30 <vFailSetCountSemaphorexBuffer64+0xc>
8111ba2c:	003b68fa 	trap	3
8111ba30:	dfc00115 	stw	ra,4(sp)
8111ba34:	df000015 	stw	fp,0(sp)
8111ba38:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer64. (exit)\n");
8111ba3c:	d0a06217 	ldw	r2,-32376(gp)
8111ba40:	100f883a 	mov	r7,r2
8111ba44:	01800a04 	movi	r6,40
8111ba48:	01400044 	movi	r5,1
8111ba4c:	01204574 	movhi	r4,33045
8111ba50:	213b3304 	addi	r4,r4,-4916
8111ba54:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
8111ba58:	d0a06217 	ldw	r2,-32376(gp)
8111ba5c:	100f883a 	mov	r7,r2
8111ba60:	018008c4 	movi	r6,35
8111ba64:	01400044 	movi	r5,1
8111ba68:	01204574 	movhi	r4,33045
8111ba6c:	213b2a04 	addi	r4,r4,-4952
8111ba70:	11216400 	call	81121640 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ba74:	0001883a 	nop
8111ba78:	e037883a 	mov	sp,fp
8111ba7c:	dfc00117 	ldw	ra,4(sp)
8111ba80:	df000017 	ldw	fp,0(sp)
8111ba84:	dec00204 	addi	sp,sp,8
8111ba88:	f800283a 	ret

8111ba8c <vFailSetCountSemaphorexBuffer128>:

/*CRITICAL*/
void vFailSetCountSemaphorexBuffer128( void )
{
8111ba8c:	defffe04 	addi	sp,sp,-8
8111ba90:	de00012e 	bgeu	sp,et,8111ba98 <vFailSetCountSemaphorexBuffer128+0xc>
8111ba94:	003b68fa 	trap	3
8111ba98:	dfc00115 	stw	ra,4(sp)
8111ba9c:	df000015 	stw	fp,0(sp)
8111baa0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer128. (exit)\n");
8111baa4:	d0a06217 	ldw	r2,-32376(gp)
8111baa8:	100f883a 	mov	r7,r2
8111baac:	01800a44 	movi	r6,41
8111bab0:	01400044 	movi	r5,1
8111bab4:	01204574 	movhi	r4,33045
8111bab8:	213b3e04 	addi	r4,r4,-4872
8111babc:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
8111bac0:	d0a06217 	ldw	r2,-32376(gp)
8111bac4:	100f883a 	mov	r7,r2
8111bac8:	018008c4 	movi	r6,35
8111bacc:	01400044 	movi	r5,1
8111bad0:	01204574 	movhi	r4,33045
8111bad4:	213b2a04 	addi	r4,r4,-4952
8111bad8:	11216400 	call	81121640 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111badc:	0001883a 	nop
8111bae0:	e037883a 	mov	sp,fp
8111bae4:	dfc00117 	ldw	ra,4(sp)
8111bae8:	df000017 	ldw	fp,0(sp)
8111baec:	dec00204 	addi	sp,sp,8
8111baf0:	f800283a 	ret

8111baf4 <vFailGetCountSemaphorexBuffer128>:

void vFailGetCountSemaphorexBuffer128( void )
{
8111baf4:	defffe04 	addi	sp,sp,-8
8111baf8:	de00012e 	bgeu	sp,et,8111bb00 <vFailGetCountSemaphorexBuffer128+0xc>
8111bafc:	003b68fa 	trap	3
8111bb00:	dfc00115 	stw	ra,4(sp)
8111bb04:	df000015 	stw	fp,0(sp)
8111bb08:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer128. (exit)\n");
8111bb0c:	d0a06217 	ldw	r2,-32376(gp)
8111bb10:	100f883a 	mov	r7,r2
8111bb14:	01800a44 	movi	r6,41
8111bb18:	01400044 	movi	r5,1
8111bb1c:	01204574 	movhi	r4,33045
8111bb20:	213b4904 	addi	r4,r4,-4828
8111bb24:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
8111bb28:	d0a06217 	ldw	r2,-32376(gp)
8111bb2c:	100f883a 	mov	r7,r2
8111bb30:	01800884 	movi	r6,34
8111bb34:	01400044 	movi	r5,1
8111bb38:	01204574 	movhi	r4,33045
8111bb3c:	213b5404 	addi	r4,r4,-4784
8111bb40:	11216400 	call	81121640 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bb44:	0001883a 	nop
8111bb48:	e037883a 	mov	sp,fp
8111bb4c:	dfc00117 	ldw	ra,4(sp)
8111bb50:	df000017 	ldw	fp,0(sp)
8111bb54:	dec00204 	addi	sp,sp,8
8111bb58:	f800283a 	ret

8111bb5c <vFailGetCountSemaphorexBuffer64>:

void vFailGetCountSemaphorexBuffer64( void )
{
8111bb5c:	defffe04 	addi	sp,sp,-8
8111bb60:	de00012e 	bgeu	sp,et,8111bb68 <vFailGetCountSemaphorexBuffer64+0xc>
8111bb64:	003b68fa 	trap	3
8111bb68:	dfc00115 	stw	ra,4(sp)
8111bb6c:	df000015 	stw	fp,0(sp)
8111bb70:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer64. (exit)\n");
8111bb74:	d0a06217 	ldw	r2,-32376(gp)
8111bb78:	100f883a 	mov	r7,r2
8111bb7c:	01800a04 	movi	r6,40
8111bb80:	01400044 	movi	r5,1
8111bb84:	01204574 	movhi	r4,33045
8111bb88:	213b5d04 	addi	r4,r4,-4748
8111bb8c:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
8111bb90:	d0a06217 	ldw	r2,-32376(gp)
8111bb94:	100f883a 	mov	r7,r2
8111bb98:	01800884 	movi	r6,34
8111bb9c:	01400044 	movi	r5,1
8111bba0:	01204574 	movhi	r4,33045
8111bba4:	213b5404 	addi	r4,r4,-4784
8111bba8:	11216400 	call	81121640 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bbac:	0001883a 	nop
8111bbb0:	e037883a 	mov	sp,fp
8111bbb4:	dfc00117 	ldw	ra,4(sp)
8111bbb8:	df000017 	ldw	fp,0(sp)
8111bbbc:	dec00204 	addi	sp,sp,8
8111bbc0:	f800283a 	ret

8111bbc4 <vFailGetCountSemaphorexBuffer32>:

void vFailGetCountSemaphorexBuffer32( void )
{
8111bbc4:	defffe04 	addi	sp,sp,-8
8111bbc8:	de00012e 	bgeu	sp,et,8111bbd0 <vFailGetCountSemaphorexBuffer32+0xc>
8111bbcc:	003b68fa 	trap	3
8111bbd0:	dfc00115 	stw	ra,4(sp)
8111bbd4:	df000015 	stw	fp,0(sp)
8111bbd8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer32. (exit)\n");
8111bbdc:	d0a06217 	ldw	r2,-32376(gp)
8111bbe0:	100f883a 	mov	r7,r2
8111bbe4:	01800a04 	movi	r6,40
8111bbe8:	01400044 	movi	r5,1
8111bbec:	01204574 	movhi	r4,33045
8111bbf0:	213b6804 	addi	r4,r4,-4704
8111bbf4:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
8111bbf8:	d0a06217 	ldw	r2,-32376(gp)
8111bbfc:	100f883a 	mov	r7,r2
8111bc00:	01800884 	movi	r6,34
8111bc04:	01400044 	movi	r5,1
8111bc08:	01204574 	movhi	r4,33045
8111bc0c:	213b5404 	addi	r4,r4,-4784
8111bc10:	11216400 	call	81121640 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bc14:	0001883a 	nop
8111bc18:	e037883a 	mov	sp,fp
8111bc1c:	dfc00117 	ldw	ra,4(sp)
8111bc20:	df000017 	ldw	fp,0(sp)
8111bc24:	dec00204 	addi	sp,sp,8
8111bc28:	f800283a 	ret

8111bc2c <vFailFoundBufferRetransmission>:

void vFailFoundBufferRetransmission( void )
{
8111bc2c:	defffe04 	addi	sp,sp,-8
8111bc30:	de00012e 	bgeu	sp,et,8111bc38 <vFailFoundBufferRetransmission+0xc>
8111bc34:	003b68fa 	trap	3
8111bc38:	dfc00115 	stw	ra,4(sp)
8111bc3c:	df000015 	stw	fp,0(sp)
8111bc40:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"Warning: Incomming Ack id doesn't exists.\n");
8111bc44:	d0a06217 	ldw	r2,-32376(gp)
8111bc48:	100f883a 	mov	r7,r2
8111bc4c:	01800a84 	movi	r6,42
8111bc50:	01400044 	movi	r5,1
8111bc54:	01204574 	movhi	r4,33045
8111bc58:	213b7304 	addi	r4,r4,-4660
8111bc5c:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not found the id in the (re)transmission buffers.(In Ack Handler)\n");
8111bc60:	d0a06217 	ldw	r2,-32376(gp)
8111bc64:	100f883a 	mov	r7,r2
8111bc68:	01801204 	movi	r6,72
8111bc6c:	01400044 	movi	r5,1
8111bc70:	01204574 	movhi	r4,33045
8111bc74:	213b7e04 	addi	r4,r4,-4616
8111bc78:	11216400 	call	81121640 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bc7c:	0001883a 	nop
8111bc80:	e037883a 	mov	sp,fp
8111bc84:	dfc00117 	ldw	ra,4(sp)
8111bc88:	df000017 	ldw	fp,0(sp)
8111bc8c:	dec00204 	addi	sp,sp,8
8111bc90:	f800283a 	ret

8111bc94 <vFailGetCountSemaphorePreParsedBuffer>:


void vFailGetCountSemaphorePreParsedBuffer( void )
{
8111bc94:	defffe04 	addi	sp,sp,-8
8111bc98:	de00012e 	bgeu	sp,et,8111bca0 <vFailGetCountSemaphorePreParsedBuffer+0xc>
8111bc9c:	003b68fa 	trap	3
8111bca0:	dfc00115 	stw	ra,4(sp)
8111bca4:	df000015 	stw	fp,0(sp)
8111bca8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorePreParsedBuffer. (exit)\n");
8111bcac:	d0a06217 	ldw	r2,-32376(gp)
8111bcb0:	100f883a 	mov	r7,r2
8111bcb4:	01800b84 	movi	r6,46
8111bcb8:	01400044 	movi	r5,1
8111bcbc:	01204574 	movhi	r4,33045
8111bcc0:	213b9104 	addi	r4,r4,-4540
8111bcc4:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vParserRXTask)\n");
8111bcc8:	d0a06217 	ldw	r2,-32376(gp)
8111bccc:	100f883a 	mov	r7,r2
8111bcd0:	018010c4 	movi	r6,67
8111bcd4:	01400044 	movi	r5,1
8111bcd8:	01204574 	movhi	r4,33045
8111bcdc:	213b9d04 	addi	r4,r4,-4492
8111bce0:	11216400 	call	81121640 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bce4:	0001883a 	nop
8111bce8:	e037883a 	mov	sp,fp
8111bcec:	dfc00117 	ldw	ra,4(sp)
8111bcf0:	df000017 	ldw	fp,0(sp)
8111bcf4:	dec00204 	addi	sp,sp,8
8111bcf8:	f800283a 	ret

8111bcfc <vFailGetxMutexPreParsedParserRxTask>:


void vFailGetxMutexPreParsedParserRxTask( void )
{
8111bcfc:	defffe04 	addi	sp,sp,-8
8111bd00:	de00012e 	bgeu	sp,et,8111bd08 <vFailGetxMutexPreParsedParserRxTask+0xc>
8111bd04:	003b68fa 	trap	3
8111bd08:	dfc00115 	stw	ra,4(sp)
8111bd0c:	df000015 	stw	fp,0(sp)
8111bd10:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetxMutexPreParsedParserRxTask. (exit)\n");
8111bd14:	d0a06217 	ldw	r2,-32376(gp)
8111bd18:	100f883a 	mov	r7,r2
8111bd1c:	01800b04 	movi	r6,44
8111bd20:	01400044 	movi	r5,1
8111bd24:	01204574 	movhi	r4,33045
8111bd28:	213bae04 	addi	r4,r4,-4424
8111bd2c:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the mutex and some error happens.(vParserRXTask)\n");
8111bd30:	d0a06217 	ldw	r2,-32376(gp)
8111bd34:	100f883a 	mov	r7,r2
8111bd38:	01800fc4 	movi	r6,63
8111bd3c:	01400044 	movi	r5,1
8111bd40:	01204574 	movhi	r4,33045
8111bd44:	213bba04 	addi	r4,r4,-4376
8111bd48:	11216400 	call	81121640 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bd4c:	0001883a 	nop
8111bd50:	e037883a 	mov	sp,fp
8111bd54:	dfc00117 	ldw	ra,4(sp)
8111bd58:	df000017 	ldw	fp,0(sp)
8111bd5c:	dec00204 	addi	sp,sp,8
8111bd60:	f800283a 	ret

8111bd64 <vNoContentInPreParsedBuffer>:


void vNoContentInPreParsedBuffer( void )
{
8111bd64:	defffe04 	addi	sp,sp,-8
8111bd68:	de00012e 	bgeu	sp,et,8111bd70 <vNoContentInPreParsedBuffer+0xc>
8111bd6c:	003b68fa 	trap	3
8111bd70:	dfc00115 	stw	ra,4(sp)
8111bd74:	df000015 	stw	fp,0(sp)
8111bd78:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vNoContentInPreParsedBuffer. (exit)\n");
8111bd7c:	d0a06217 	ldw	r2,-32376(gp)
8111bd80:	100f883a 	mov	r7,r2
8111bd84:	01800904 	movi	r6,36
8111bd88:	01400044 	movi	r5,1
8111bd8c:	01204574 	movhi	r4,33045
8111bd90:	213bca04 	addi	r4,r4,-4312
8111bd94:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Semaphore was post by some task but has no message in the PreParsedBuffer.(vParserRXTask)\n");
8111bd98:	d0a06217 	ldw	r2,-32376(gp)
8111bd9c:	100f883a 	mov	r7,r2
8111bda0:	01801684 	movi	r6,90
8111bda4:	01400044 	movi	r5,1
8111bda8:	01204574 	movhi	r4,33045
8111bdac:	213bd404 	addi	r4,r4,-4272
8111bdb0:	11216400 	call	81121640 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bdb4:	0001883a 	nop
8111bdb8:	e037883a 	mov	sp,fp
8111bdbc:	dfc00117 	ldw	ra,4(sp)
8111bdc0:	df000017 	ldw	fp,0(sp)
8111bdc4:	dec00204 	addi	sp,sp,8
8111bdc8:	f800283a 	ret

8111bdcc <vCouldNotSendEthConfUART>:


void vCouldNotSendEthConfUART( void )
{
8111bdcc:	defffe04 	addi	sp,sp,-8
8111bdd0:	de00012e 	bgeu	sp,et,8111bdd8 <vCouldNotSendEthConfUART+0xc>
8111bdd4:	003b68fa 	trap	3
8111bdd8:	dfc00115 	stw	ra,4(sp)
8111bddc:	df000015 	stw	fp,0(sp)
8111bde0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendEthConfUART. (exit)\n");
8111bde4:	d0a06217 	ldw	r2,-32376(gp)
8111bde8:	100f883a 	mov	r7,r2
8111bdec:	01800844 	movi	r6,33
8111bdf0:	01400044 	movi	r5,1
8111bdf4:	01204574 	movhi	r4,33045
8111bdf8:	213beb04 	addi	r4,r4,-4180
8111bdfc:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send or not write ETH conf of the NUC in the (re)transmission buffer.(vSendEthConf)\n");
8111be00:	d0a06217 	ldw	r2,-32376(gp)
8111be04:	100f883a 	mov	r7,r2
8111be08:	01801784 	movi	r6,94
8111be0c:	01400044 	movi	r5,1
8111be10:	01204574 	movhi	r4,33045
8111be14:	213bf404 	addi	r4,r4,-4144
8111be18:	11216400 	call	81121640 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111be1c:	0001883a 	nop
8111be20:	e037883a 	mov	sp,fp
8111be24:	dfc00117 	ldw	ra,4(sp)
8111be28:	df000017 	ldw	fp,0(sp)
8111be2c:	dec00204 	addi	sp,sp,8
8111be30:	f800283a 	ret

8111be34 <vFailSendNack>:

void vFailSendNack( void )
{
8111be34:	defffe04 	addi	sp,sp,-8
8111be38:	de00012e 	bgeu	sp,et,8111be40 <vFailSendNack+0xc>
8111be3c:	003b68fa 	trap	3
8111be40:	dfc00115 	stw	ra,4(sp)
8111be44:	df000015 	stw	fp,0(sp)
8111be48:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendNack. (exit)\n");
8111be4c:	d0a06217 	ldw	r2,-32376(gp)
8111be50:	100f883a 	mov	r7,r2
8111be54:	01800584 	movi	r6,22
8111be58:	01400044 	movi	r5,1
8111be5c:	01204574 	movhi	r4,33045
8111be60:	213c0c04 	addi	r4,r4,-4048
8111be64:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Send Nack using the PreAckSender buffer. \n");
8111be68:	d0a06217 	ldw	r2,-32376(gp)
8111be6c:	100f883a 	mov	r7,r2
8111be70:	01800a84 	movi	r6,42
8111be74:	01400044 	movi	r5,1
8111be78:	01204574 	movhi	r4,33045
8111be7c:	213c1204 	addi	r4,r4,-4024
8111be80:	11216400 	call	81121640 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111be84:	0001883a 	nop
8111be88:	e037883a 	mov	sp,fp
8111be8c:	dfc00117 	ldw	ra,4(sp)
8111be90:	df000017 	ldw	fp,0(sp)
8111be94:	dec00204 	addi	sp,sp,8
8111be98:	f800283a 	ret

8111be9c <vFailSetPreAckSenderBuffer>:

void vFailSetPreAckSenderBuffer( void )
{
8111be9c:	defffe04 	addi	sp,sp,-8
8111bea0:	de00012e 	bgeu	sp,et,8111bea8 <vFailSetPreAckSenderBuffer+0xc>
8111bea4:	003b68fa 	trap	3
8111bea8:	dfc00115 	stw	ra,4(sp)
8111beac:	df000015 	stw	fp,0(sp)
8111beb0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreAckSenderBuffer. (exit)\n");
8111beb4:	d0a06217 	ldw	r2,-32376(gp)
8111beb8:	100f883a 	mov	r7,r2
8111bebc:	018008c4 	movi	r6,35
8111bec0:	01400044 	movi	r5,1
8111bec4:	01204574 	movhi	r4,33045
8111bec8:	213c1d04 	addi	r4,r4,-3980
8111becc:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task out_ack_handler using the PreAckSender buffer.\n");
8111bed0:	d0a06217 	ldw	r2,-32376(gp)
8111bed4:	100f883a 	mov	r7,r2
8111bed8:	01801584 	movi	r6,86
8111bedc:	01400044 	movi	r5,1
8111bee0:	01204574 	movhi	r4,33045
8111bee4:	213c2604 	addi	r4,r4,-3944
8111bee8:	11216400 	call	81121640 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111beec:	0001883a 	nop
8111bef0:	e037883a 	mov	sp,fp
8111bef4:	dfc00117 	ldw	ra,4(sp)
8111bef8:	df000017 	ldw	fp,0(sp)
8111befc:	dec00204 	addi	sp,sp,8
8111bf00:	f800283a 	ret

8111bf04 <vFailSetPreParsedBuffer>:

void vFailSetPreParsedBuffer( void )
{
8111bf04:	defffe04 	addi	sp,sp,-8
8111bf08:	de00012e 	bgeu	sp,et,8111bf10 <vFailSetPreParsedBuffer+0xc>
8111bf0c:	003b68fa 	trap	3
8111bf10:	dfc00115 	stw	ra,4(sp)
8111bf14:	df000015 	stw	fp,0(sp)
8111bf18:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreParsedBuffer. (exit)\n");
8111bf1c:	d0a06217 	ldw	r2,-32376(gp)
8111bf20:	100f883a 	mov	r7,r2
8111bf24:	01800804 	movi	r6,32
8111bf28:	01400044 	movi	r5,1
8111bf2c:	01204574 	movhi	r4,33045
8111bf30:	213c3c04 	addi	r4,r4,-3856
8111bf34:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task parser_comm using the PreParsed buffer.\n");
8111bf38:	d0a06217 	ldw	r2,-32376(gp)
8111bf3c:	100f883a 	mov	r7,r2
8111bf40:	018013c4 	movi	r6,79
8111bf44:	01400044 	movi	r5,1
8111bf48:	01204574 	movhi	r4,33045
8111bf4c:	213c4504 	addi	r4,r4,-3820
8111bf50:	11216400 	call	81121640 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bf54:	0001883a 	nop
8111bf58:	e037883a 	mov	sp,fp
8111bf5c:	dfc00117 	ldw	ra,4(sp)
8111bf60:	df000017 	ldw	fp,0(sp)
8111bf64:	dec00204 	addi	sp,sp,8
8111bf68:	f800283a 	ret

8111bf6c <vFailSetPreAckReceiverBuffer>:


void vFailSetPreAckReceiverBuffer( void )
{
8111bf6c:	defffe04 	addi	sp,sp,-8
8111bf70:	de00012e 	bgeu	sp,et,8111bf78 <vFailSetPreAckReceiverBuffer+0xc>
8111bf74:	003b68fa 	trap	3
8111bf78:	dfc00115 	stw	ra,4(sp)
8111bf7c:	df000015 	stw	fp,0(sp)
8111bf80:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreAckReceiverBuffer. (exit)\n");
8111bf84:	d0a06217 	ldw	r2,-32376(gp)
8111bf88:	100f883a 	mov	r7,r2
8111bf8c:	01800944 	movi	r6,37
8111bf90:	01400044 	movi	r5,1
8111bf94:	01204574 	movhi	r4,33045
8111bf98:	213c5904 	addi	r4,r4,-3740
8111bf9c:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task in_out_handler using the PreAckReceiver buffer.\n");
8111bfa0:	d0a06217 	ldw	r2,-32376(gp)
8111bfa4:	100f883a 	mov	r7,r2
8111bfa8:	018015c4 	movi	r6,87
8111bfac:	01400044 	movi	r5,1
8111bfb0:	01204574 	movhi	r4,33045
8111bfb4:	213c6304 	addi	r4,r4,-3700
8111bfb8:	11216400 	call	81121640 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bfbc:	0001883a 	nop
8111bfc0:	e037883a 	mov	sp,fp
8111bfc4:	dfc00117 	ldw	ra,4(sp)
8111bfc8:	df000017 	ldw	fp,0(sp)
8111bfcc:	dec00204 	addi	sp,sp,8
8111bfd0:	f800283a 	ret

8111bfd4 <vFailParserCommTaskCreate>:


void vFailParserCommTaskCreate( void )
{
8111bfd4:	defffe04 	addi	sp,sp,-8
8111bfd8:	de00012e 	bgeu	sp,et,8111bfe0 <vFailParserCommTaskCreate+0xc>
8111bfdc:	003b68fa 	trap	3
8111bfe0:	dfc00115 	stw	ra,4(sp)
8111bfe4:	df000015 	stw	fp,0(sp)
8111bfe8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailParserCommTaskCreate\n");
8111bfec:	d0a06217 	ldw	r2,-32376(gp)
8111bff0:	100f883a 	mov	r7,r2
8111bff4:	01800684 	movi	r6,26
8111bff8:	01400044 	movi	r5,1
8111bffc:	01204574 	movhi	r4,33045
8111c000:	213c7904 	addi	r4,r4,-3612
8111c004:	11216400 	call	81121640 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c008:	0001883a 	nop
8111c00c:	e037883a 	mov	sp,fp
8111c010:	dfc00117 	ldw	ra,4(sp)
8111c014:	df000017 	ldw	fp,0(sp)
8111c018:	dec00204 	addi	sp,sp,8
8111c01c:	f800283a 	ret

8111c020 <vFailInAckHandlerTaskCreate>:

void vFailInAckHandlerTaskCreate( void )
{
8111c020:	defffe04 	addi	sp,sp,-8
8111c024:	de00012e 	bgeu	sp,et,8111c02c <vFailInAckHandlerTaskCreate+0xc>
8111c028:	003b68fa 	trap	3
8111c02c:	dfc00115 	stw	ra,4(sp)
8111c030:	df000015 	stw	fp,0(sp)
8111c034:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInAckHandlerTaskCreate\n");
8111c038:	d0a06217 	ldw	r2,-32376(gp)
8111c03c:	100f883a 	mov	r7,r2
8111c040:	01800704 	movi	r6,28
8111c044:	01400044 	movi	r5,1
8111c048:	01204574 	movhi	r4,33045
8111c04c:	213c8004 	addi	r4,r4,-3584
8111c050:	11216400 	call	81121640 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c054:	0001883a 	nop
8111c058:	e037883a 	mov	sp,fp
8111c05c:	dfc00117 	ldw	ra,4(sp)
8111c060:	df000017 	ldw	fp,0(sp)
8111c064:	dec00204 	addi	sp,sp,8
8111c068:	f800283a 	ret

8111c06c <vFailOutAckHandlerTaskCreate>:

void vFailOutAckHandlerTaskCreate( void )
{
8111c06c:	defffe04 	addi	sp,sp,-8
8111c070:	de00012e 	bgeu	sp,et,8111c078 <vFailOutAckHandlerTaskCreate+0xc>
8111c074:	003b68fa 	trap	3
8111c078:	dfc00115 	stw	ra,4(sp)
8111c07c:	df000015 	stw	fp,0(sp)
8111c080:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInAckHandlerTaskCreate\n");
8111c084:	d0a06217 	ldw	r2,-32376(gp)
8111c088:	100f883a 	mov	r7,r2
8111c08c:	01800704 	movi	r6,28
8111c090:	01400044 	movi	r5,1
8111c094:	01204574 	movhi	r4,33045
8111c098:	213c8004 	addi	r4,r4,-3584
8111c09c:	11216400 	call	81121640 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c0a0:	0001883a 	nop
8111c0a4:	e037883a 	mov	sp,fp
8111c0a8:	dfc00117 	ldw	ra,4(sp)
8111c0ac:	df000017 	ldw	fp,0(sp)
8111c0b0:	dec00204 	addi	sp,sp,8
8111c0b4:	f800283a 	ret

8111c0b8 <vFailCreateTimerRetransmisison>:


void vFailCreateTimerRetransmisison( void )
{
8111c0b8:	defffe04 	addi	sp,sp,-8
8111c0bc:	de00012e 	bgeu	sp,et,8111c0c4 <vFailCreateTimerRetransmisison+0xc>
8111c0c0:	003b68fa 	trap	3
8111c0c4:	dfc00115 	stw	ra,4(sp)
8111c0c8:	df000015 	stw	fp,0(sp)
8111c0cc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateTimerRetransmisison\n");
8111c0d0:	d0a06217 	ldw	r2,-32376(gp)
8111c0d4:	100f883a 	mov	r7,r2
8111c0d8:	018007c4 	movi	r6,31
8111c0dc:	01400044 	movi	r5,1
8111c0e0:	01204574 	movhi	r4,33045
8111c0e4:	213c8804 	addi	r4,r4,-3552
8111c0e8:	11216400 	call	81121640 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c0ec:	0001883a 	nop
8111c0f0:	e037883a 	mov	sp,fp
8111c0f4:	dfc00117 	ldw	ra,4(sp)
8111c0f8:	df000017 	ldw	fp,0(sp)
8111c0fc:	dec00204 	addi	sp,sp,8
8111c100:	f800283a 	ret

8111c104 <vCouldNotCheckBufferTimeOutFunction>:


void vCouldNotCheckBufferTimeOutFunction( void )
{
8111c104:	defffe04 	addi	sp,sp,-8
8111c108:	de00012e 	bgeu	sp,et,8111c110 <vCouldNotCheckBufferTimeOutFunction+0xc>
8111c10c:	003b68fa 	trap	3
8111c110:	dfc00115 	stw	ra,4(sp)
8111c114:	df000015 	stw	fp,0(sp)
8111c118:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotCheckBufferTimeOutFunction\n");
8111c11c:	d0a06217 	ldw	r2,-32376(gp)
8111c120:	100f883a 	mov	r7,r2
8111c124:	01800904 	movi	r6,36
8111c128:	01400044 	movi	r5,1
8111c12c:	01204574 	movhi	r4,33045
8111c130:	213c9004 	addi	r4,r4,-3520
8111c134:	11216400 	call	81121640 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c138:	0001883a 	nop
8111c13c:	e037883a 	mov	sp,fp
8111c140:	dfc00117 	ldw	ra,4(sp)
8111c144:	df000017 	ldw	fp,0(sp)
8111c148:	dec00204 	addi	sp,sp,8
8111c14c:	f800283a 	ret

8111c150 <vFailTimeoutCheckerTaskCreate>:

/* Critico */
void vFailTimeoutCheckerTaskCreate( void )
{
8111c150:	defffe04 	addi	sp,sp,-8
8111c154:	de00012e 	bgeu	sp,et,8111c15c <vFailTimeoutCheckerTaskCreate+0xc>
8111c158:	003b68fa 	trap	3
8111c15c:	dfc00115 	stw	ra,4(sp)
8111c160:	df000015 	stw	fp,0(sp)
8111c164:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailTimeoutCheckerTaskCreate (Critico)\n");
8111c168:	d0a06217 	ldw	r2,-32376(gp)
8111c16c:	100f883a 	mov	r7,r2
8111c170:	01800a04 	movi	r6,40
8111c174:	01400044 	movi	r5,1
8111c178:	01204574 	movhi	r4,33045
8111c17c:	213c9a04 	addi	r4,r4,-3480
8111c180:	11216400 	call	81121640 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c184:	0001883a 	nop
8111c188:	e037883a 	mov	sp,fp
8111c18c:	dfc00117 	ldw	ra,4(sp)
8111c190:	df000017 	ldw	fp,0(sp)
8111c194:	dec00204 	addi	sp,sp,8
8111c198:	f800283a 	ret

8111c19c <vFailGetBlockingSemTimeoutTask>:


void vFailGetBlockingSemTimeoutTask( void )
{
8111c19c:	defffe04 	addi	sp,sp,-8
8111c1a0:	de00012e 	bgeu	sp,et,8111c1a8 <vFailGetBlockingSemTimeoutTask+0xc>
8111c1a4:	003b68fa 	trap	3
8111c1a8:	dfc00115 	stw	ra,4(sp)
8111c1ac:	df000015 	stw	fp,0(sp)
8111c1b0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetBlockingSemTimeoutTask. (exit)\n");
8111c1b4:	d0a06217 	ldw	r2,-32376(gp)
8111c1b8:	100f883a 	mov	r7,r2
8111c1bc:	018009c4 	movi	r6,39
8111c1c0:	01400044 	movi	r5,1
8111c1c4:	01204574 	movhi	r4,33045
8111c1c8:	213ca504 	addi	r4,r4,-3436
8111c1cc:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Retrun from a blocking (0) OSSemPend with a error.\n");
8111c1d0:	d0a06217 	ldw	r2,-32376(gp)
8111c1d4:	100f883a 	mov	r7,r2
8111c1d8:	01800cc4 	movi	r6,51
8111c1dc:	01400044 	movi	r5,1
8111c1e0:	01204574 	movhi	r4,33045
8111c1e4:	213caf04 	addi	r4,r4,-3396
8111c1e8:	11216400 	call	81121640 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c1ec:	0001883a 	nop
8111c1f0:	e037883a 	mov	sp,fp
8111c1f4:	dfc00117 	ldw	ra,4(sp)
8111c1f8:	df000017 	ldw	fp,0(sp)
8111c1fc:	dec00204 	addi	sp,sp,8
8111c200:	f800283a 	ret

8111c204 <vFailPostBlockingSemTimeoutTask>:

void vFailPostBlockingSemTimeoutTask( void )
{
8111c204:	defffe04 	addi	sp,sp,-8
8111c208:	de00012e 	bgeu	sp,et,8111c210 <vFailPostBlockingSemTimeoutTask+0xc>
8111c20c:	003b68fa 	trap	3
8111c210:	dfc00115 	stw	ra,4(sp)
8111c214:	df000015 	stw	fp,0(sp)
8111c218:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailPostBlockingSemTimeoutTask. (exit)\n");
8111c21c:	d0a06217 	ldw	r2,-32376(gp)
8111c220:	100f883a 	mov	r7,r2
8111c224:	01800a04 	movi	r6,40
8111c228:	01400044 	movi	r5,1
8111c22c:	01204574 	movhi	r4,33045
8111c230:	213cbc04 	addi	r4,r4,-3344
8111c234:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not Post the semaphore for the TimeoutTask.\n");
8111c238:	d0a06217 	ldw	r2,-32376(gp)
8111c23c:	100f883a 	mov	r7,r2
8111c240:	01800c84 	movi	r6,50
8111c244:	01400044 	movi	r5,1
8111c248:	01204574 	movhi	r4,33045
8111c24c:	213cc704 	addi	r4,r4,-3300
8111c250:	11216400 	call	81121640 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c254:	0001883a 	nop
8111c258:	e037883a 	mov	sp,fp
8111c25c:	dfc00117 	ldw	ra,4(sp)
8111c260:	df000017 	ldw	fp,0(sp)
8111c264:	dec00204 	addi	sp,sp,8
8111c268:	f800283a 	ret

8111c26c <vFailCouldNotRetransmitTimeoutTask>:


void vFailCouldNotRetransmitTimeoutTask( void )
{
8111c26c:	defffe04 	addi	sp,sp,-8
8111c270:	de00012e 	bgeu	sp,et,8111c278 <vFailCouldNotRetransmitTimeoutTask+0xc>
8111c274:	003b68fa 	trap	3
8111c278:	dfc00115 	stw	ra,4(sp)
8111c27c:	df000015 	stw	fp,0(sp)
8111c280:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCouldNotRetransmitTimeoutTask. (exit)\n");
8111c284:	d0a06217 	ldw	r2,-32376(gp)
8111c288:	100f883a 	mov	r7,r2
8111c28c:	01800ac4 	movi	r6,43
8111c290:	01400044 	movi	r5,1
8111c294:	01204574 	movhi	r4,33045
8111c298:	213cd404 	addi	r4,r4,-3248
8111c29c:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"After sleep for 50 ticks, could not get access to the tx uart. No retransmission occurs.\n");
8111c2a0:	d0a06217 	ldw	r2,-32376(gp)
8111c2a4:	100f883a 	mov	r7,r2
8111c2a8:	01801644 	movi	r6,89
8111c2ac:	01400044 	movi	r5,1
8111c2b0:	01204574 	movhi	r4,33045
8111c2b4:	213cdf04 	addi	r4,r4,-3204
8111c2b8:	11216400 	call	81121640 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c2bc:	0001883a 	nop
8111c2c0:	e037883a 	mov	sp,fp
8111c2c4:	dfc00117 	ldw	ra,4(sp)
8111c2c8:	df000017 	ldw	fp,0(sp)
8111c2cc:	dec00204 	addi	sp,sp,8
8111c2d0:	f800283a 	ret

8111c2d4 <vCouldNotRetransmitB32TimeoutTask>:


void vCouldNotRetransmitB32TimeoutTask( void )
{
8111c2d4:	defffe04 	addi	sp,sp,-8
8111c2d8:	de00012e 	bgeu	sp,et,8111c2e0 <vCouldNotRetransmitB32TimeoutTask+0xc>
8111c2dc:	003b68fa 	trap	3
8111c2e0:	dfc00115 	stw	ra,4(sp)
8111c2e4:	df000015 	stw	fp,0(sp)
8111c2e8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB32TimeoutTask. (exit)\n");
8111c2ec:	d0a06217 	ldw	r2,-32376(gp)
8111c2f0:	100f883a 	mov	r7,r2
8111c2f4:	01800a84 	movi	r6,42
8111c2f8:	01400044 	movi	r5,1
8111c2fc:	01204574 	movhi	r4,33045
8111c300:	213cf604 	addi	r4,r4,-3112
8111c304:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (32).\n");
8111c308:	d0a06217 	ldw	r2,-32376(gp)
8111c30c:	100f883a 	mov	r7,r2
8111c310:	01801444 	movi	r6,81
8111c314:	01400044 	movi	r5,1
8111c318:	01204574 	movhi	r4,33045
8111c31c:	213d0104 	addi	r4,r4,-3068
8111c320:	11216400 	call	81121640 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c324:	0001883a 	nop
8111c328:	e037883a 	mov	sp,fp
8111c32c:	dfc00117 	ldw	ra,4(sp)
8111c330:	df000017 	ldw	fp,0(sp)
8111c334:	dec00204 	addi	sp,sp,8
8111c338:	f800283a 	ret

8111c33c <vCouldNotRetransmitB64TimeoutTask>:

void vCouldNotRetransmitB64TimeoutTask( void )
{
8111c33c:	defffe04 	addi	sp,sp,-8
8111c340:	de00012e 	bgeu	sp,et,8111c348 <vCouldNotRetransmitB64TimeoutTask+0xc>
8111c344:	003b68fa 	trap	3
8111c348:	dfc00115 	stw	ra,4(sp)
8111c34c:	df000015 	stw	fp,0(sp)
8111c350:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB64TimeoutTask. (exit)\n");
8111c354:	d0a06217 	ldw	r2,-32376(gp)
8111c358:	100f883a 	mov	r7,r2
8111c35c:	01800a84 	movi	r6,42
8111c360:	01400044 	movi	r5,1
8111c364:	01204574 	movhi	r4,33045
8111c368:	213d1604 	addi	r4,r4,-2984
8111c36c:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (64).\n");
8111c370:	d0a06217 	ldw	r2,-32376(gp)
8111c374:	100f883a 	mov	r7,r2
8111c378:	01801444 	movi	r6,81
8111c37c:	01400044 	movi	r5,1
8111c380:	01204574 	movhi	r4,33045
8111c384:	213d2104 	addi	r4,r4,-2940
8111c388:	11216400 	call	81121640 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c38c:	0001883a 	nop
8111c390:	e037883a 	mov	sp,fp
8111c394:	dfc00117 	ldw	ra,4(sp)
8111c398:	df000017 	ldw	fp,0(sp)
8111c39c:	dec00204 	addi	sp,sp,8
8111c3a0:	f800283a 	ret

8111c3a4 <vCouldNotRetransmitB128TimeoutTask>:

void vCouldNotRetransmitB128TimeoutTask( void )
{
8111c3a4:	defffe04 	addi	sp,sp,-8
8111c3a8:	de00012e 	bgeu	sp,et,8111c3b0 <vCouldNotRetransmitB128TimeoutTask+0xc>
8111c3ac:	003b68fa 	trap	3
8111c3b0:	dfc00115 	stw	ra,4(sp)
8111c3b4:	df000015 	stw	fp,0(sp)
8111c3b8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB128TimeoutTask. (exit)\n");
8111c3bc:	d0a06217 	ldw	r2,-32376(gp)
8111c3c0:	100f883a 	mov	r7,r2
8111c3c4:	01800ac4 	movi	r6,43
8111c3c8:	01400044 	movi	r5,1
8111c3cc:	01204574 	movhi	r4,33045
8111c3d0:	213d3604 	addi	r4,r4,-2856
8111c3d4:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (128).\n");
8111c3d8:	d0a06217 	ldw	r2,-32376(gp)
8111c3dc:	100f883a 	mov	r7,r2
8111c3e0:	01801484 	movi	r6,82
8111c3e4:	01400044 	movi	r5,1
8111c3e8:	01204574 	movhi	r4,33045
8111c3ec:	213d4104 	addi	r4,r4,-2812
8111c3f0:	11216400 	call	81121640 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c3f4:	0001883a 	nop
8111c3f8:	e037883a 	mov	sp,fp
8111c3fc:	dfc00117 	ldw	ra,4(sp)
8111c400:	df000017 	ldw	fp,0(sp)
8111c404:	dec00204 	addi	sp,sp,8
8111c408:	f800283a 	ret

8111c40c <vFailStartTimerRetransmission>:


void vFailStartTimerRetransmission( void )
{
8111c40c:	defffe04 	addi	sp,sp,-8
8111c410:	de00012e 	bgeu	sp,et,8111c418 <vFailStartTimerRetransmission+0xc>
8111c414:	003b68fa 	trap	3
8111c418:	dfc00115 	stw	ra,4(sp)
8111c41c:	df000015 	stw	fp,0(sp)
8111c420:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailStartTimerRetransmission. (exit)\n");
8111c424:	d0a06217 	ldw	r2,-32376(gp)
8111c428:	100f883a 	mov	r7,r2
8111c42c:	01800984 	movi	r6,38
8111c430:	01400044 	movi	r5,1
8111c434:	01204574 	movhi	r4,33045
8111c438:	213d5604 	addi	r4,r4,-2728
8111c43c:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Fail trying to start the timer xTimerRetransmission.\n");
8111c440:	d0a06217 	ldw	r2,-32376(gp)
8111c444:	100f883a 	mov	r7,r2
8111c448:	01800d44 	movi	r6,53
8111c44c:	01400044 	movi	r5,1
8111c450:	01204574 	movhi	r4,33045
8111c454:	213d6004 	addi	r4,r4,-2688
8111c458:	11216400 	call	81121640 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c45c:	0001883a 	nop
8111c460:	e037883a 	mov	sp,fp
8111c464:	dfc00117 	ldw	ra,4(sp)
8111c468:	df000017 	ldw	fp,0(sp)
8111c46c:	dec00204 	addi	sp,sp,8
8111c470:	f800283a 	ret

8111c474 <vCouldNotSendTurnOff>:


void vCouldNotSendTurnOff( void )
{
8111c474:	defffe04 	addi	sp,sp,-8
8111c478:	de00012e 	bgeu	sp,et,8111c480 <vCouldNotSendTurnOff+0xc>
8111c47c:	003b68fa 	trap	3
8111c480:	dfc00115 	stw	ra,4(sp)
8111c484:	df000015 	stw	fp,0(sp)
8111c488:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendTurnOff. (exit)\n");
8111c48c:	d0a06217 	ldw	r2,-32376(gp)
8111c490:	100f883a 	mov	r7,r2
8111c494:	01800744 	movi	r6,29
8111c498:	01400044 	movi	r5,1
8111c49c:	01204574 	movhi	r4,33045
8111c4a0:	213d6e04 	addi	r4,r4,-2632
8111c4a4:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the turn off command. \n");
8111c4a8:	d0a06217 	ldw	r2,-32376(gp)
8111c4ac:	100f883a 	mov	r7,r2
8111c4b0:	01800984 	movi	r6,38
8111c4b4:	01400044 	movi	r5,1
8111c4b8:	01204574 	movhi	r4,33045
8111c4bc:	213d7604 	addi	r4,r4,-2600
8111c4c0:	11216400 	call	81121640 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c4c4:	0001883a 	nop
8111c4c8:	e037883a 	mov	sp,fp
8111c4cc:	dfc00117 	ldw	ra,4(sp)
8111c4d0:	df000017 	ldw	fp,0(sp)
8111c4d4:	dec00204 	addi	sp,sp,8
8111c4d8:	f800283a 	ret

8111c4dc <vCouldNotSendReset>:

void vCouldNotSendReset( void )
{
8111c4dc:	defffe04 	addi	sp,sp,-8
8111c4e0:	de00012e 	bgeu	sp,et,8111c4e8 <vCouldNotSendReset+0xc>
8111c4e4:	003b68fa 	trap	3
8111c4e8:	dfc00115 	stw	ra,4(sp)
8111c4ec:	df000015 	stw	fp,0(sp)
8111c4f0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendReset. (exit)\n");
8111c4f4:	d0a06217 	ldw	r2,-32376(gp)
8111c4f8:	100f883a 	mov	r7,r2
8111c4fc:	018006c4 	movi	r6,27
8111c500:	01400044 	movi	r5,1
8111c504:	01204574 	movhi	r4,33045
8111c508:	213d8004 	addi	r4,r4,-2560
8111c50c:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the reset command. \n");
8111c510:	d0a06217 	ldw	r2,-32376(gp)
8111c514:	100f883a 	mov	r7,r2
8111c518:	018008c4 	movi	r6,35
8111c51c:	01400044 	movi	r5,1
8111c520:	01204574 	movhi	r4,33045
8111c524:	213d8704 	addi	r4,r4,-2532
8111c528:	11216400 	call	81121640 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c52c:	0001883a 	nop
8111c530:	e037883a 	mov	sp,fp
8111c534:	dfc00117 	ldw	ra,4(sp)
8111c538:	df000017 	ldw	fp,0(sp)
8111c53c:	dec00204 	addi	sp,sp,8
8111c540:	f800283a 	ret

8111c544 <vCouldNotSendLog>:

void vCouldNotSendLog( void )
{
8111c544:	defffe04 	addi	sp,sp,-8
8111c548:	de00012e 	bgeu	sp,et,8111c550 <vCouldNotSendLog+0xc>
8111c54c:	003b68fa 	trap	3
8111c550:	dfc00115 	stw	ra,4(sp)
8111c554:	df000015 	stw	fp,0(sp)
8111c558:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendLog. (exit)\n");
8111c55c:	d0a06217 	ldw	r2,-32376(gp)
8111c560:	100f883a 	mov	r7,r2
8111c564:	01800644 	movi	r6,25
8111c568:	01400044 	movi	r5,1
8111c56c:	01204574 	movhi	r4,33045
8111c570:	213d9004 	addi	r4,r4,-2496
8111c574:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send log packet to NUC. \n");
8111c578:	d0a06217 	ldw	r2,-32376(gp)
8111c57c:	100f883a 	mov	r7,r2
8111c580:	018008c4 	movi	r6,35
8111c584:	01400044 	movi	r5,1
8111c588:	01204574 	movhi	r4,33045
8111c58c:	213d9704 	addi	r4,r4,-2468
8111c590:	11216400 	call	81121640 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c594:	0001883a 	nop
8111c598:	e037883a 	mov	sp,fp
8111c59c:	dfc00117 	ldw	ra,4(sp)
8111c5a0:	df000017 	ldw	fp,0(sp)
8111c5a4:	dec00204 	addi	sp,sp,8
8111c5a8:	f800283a 	ret

8111c5ac <vCouldNotSendTMPusCommand>:


void vCouldNotSendTMPusCommand( const char *cData )
{
8111c5ac:	defffd04 	addi	sp,sp,-12
8111c5b0:	de00012e 	bgeu	sp,et,8111c5b8 <vCouldNotSendTMPusCommand+0xc>
8111c5b4:	003b68fa 	trap	3
8111c5b8:	dfc00215 	stw	ra,8(sp)
8111c5bc:	df000115 	stw	fp,4(sp)
8111c5c0:	df000104 	addi	fp,sp,4
8111c5c4:	e13fff15 	stw	r4,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendTMPusCommand. (exit)\n");
8111c5c8:	d0a06217 	ldw	r2,-32376(gp)
8111c5cc:	100f883a 	mov	r7,r2
8111c5d0:	01800884 	movi	r6,34
8111c5d4:	01400044 	movi	r5,1
8111c5d8:	01204574 	movhi	r4,33045
8111c5dc:	213da004 	addi	r4,r4,-2432
8111c5e0:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the TM PUS command to NUC. \n");
8111c5e4:	d0a06217 	ldw	r2,-32376(gp)
8111c5e8:	100f883a 	mov	r7,r2
8111c5ec:	01800ac4 	movi	r6,43
8111c5f0:	01400044 	movi	r5,1
8111c5f4:	01204574 	movhi	r4,33045
8111c5f8:	213da904 	addi	r4,r4,-2396
8111c5fc:	11216400 	call	81121640 <fwrite>
		debug(fp,"cData");
8111c600:	d0a06217 	ldw	r2,-32376(gp)
8111c604:	100f883a 	mov	r7,r2
8111c608:	01800144 	movi	r6,5
8111c60c:	01400044 	movi	r5,1
8111c610:	01204574 	movhi	r4,33045
8111c614:	213db404 	addi	r4,r4,-2352
8111c618:	11216400 	call	81121640 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c61c:	0001883a 	nop
8111c620:	e037883a 	mov	sp,fp
8111c624:	dfc00117 	ldw	ra,4(sp)
8111c628:	df000017 	ldw	fp,0(sp)
8111c62c:	dec00204 	addi	sp,sp,8
8111c630:	f800283a 	ret

8111c634 <vWarnCouldNotgetMutexRetrans128>:

/* Not send message is bad but the Simucam will continue to work. */
void vWarnCouldNotgetMutexRetrans128( void )
{
8111c634:	defffe04 	addi	sp,sp,-8
8111c638:	de00012e 	bgeu	sp,et,8111c640 <vWarnCouldNotgetMutexRetrans128+0xc>
8111c63c:	003b68fa 	trap	3
8111c640:	dfc00115 	stw	ra,4(sp)
8111c644:	df000015 	stw	fp,0(sp)
8111c648:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vWarnCouldNotgetMutexRetrans128. (exit)\n");
8111c64c:	d0a06217 	ldw	r2,-32376(gp)
8111c650:	100f883a 	mov	r7,r2
8111c654:	01800a04 	movi	r6,40
8111c658:	01400044 	movi	r5,1
8111c65c:	01204574 	movhi	r4,33045
8111c660:	213db604 	addi	r4,r4,-2344
8111c664:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Warning: Could not get the mutex for the retransmission. The message will be lost.\n");
8111c668:	d0a06217 	ldw	r2,-32376(gp)
8111c66c:	100f883a 	mov	r7,r2
8111c670:	018014c4 	movi	r6,83
8111c674:	01400044 	movi	r5,1
8111c678:	01204574 	movhi	r4,33045
8111c67c:	213dc104 	addi	r4,r4,-2300
8111c680:	11216400 	call	81121640 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c684:	0001883a 	nop
8111c688:	e037883a 	mov	sp,fp
8111c68c:	dfc00117 	ldw	ra,4(sp)
8111c690:	df000017 	ldw	fp,0(sp)
8111c694:	dec00204 	addi	sp,sp,8
8111c698:	f800283a 	ret

8111c69c <vFailCreateScheduleQueue>:


/* CRITICAL. */
void vFailCreateScheduleQueue( void )
{
8111c69c:	defffe04 	addi	sp,sp,-8
8111c6a0:	de00012e 	bgeu	sp,et,8111c6a8 <vFailCreateScheduleQueue+0xc>
8111c6a4:	003b68fa 	trap	3
8111c6a8:	dfc00115 	stw	ra,4(sp)
8111c6ac:	df000015 	stw	fp,0(sp)
8111c6b0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateScheduleQueue. (exit)\n");
8111c6b4:	d0a06217 	ldw	r2,-32376(gp)
8111c6b8:	100f883a 	mov	r7,r2
8111c6bc:	01800844 	movi	r6,33
8111c6c0:	01400044 	movi	r5,1
8111c6c4:	01204574 	movhi	r4,33045
8111c6c8:	213dd604 	addi	r4,r4,-2216
8111c6cc:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: Could not create the Queue to shcedule the access to the DMA.\n");
8111c6d0:	d0a06217 	ldw	r2,-32376(gp)
8111c6d4:	100f883a 	mov	r7,r2
8111c6d8:	01801204 	movi	r6,72
8111c6dc:	01400044 	movi	r5,1
8111c6e0:	01204574 	movhi	r4,33045
8111c6e4:	213ddf04 	addi	r4,r4,-2180
8111c6e8:	11216400 	call	81121640 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c6ec:	0001883a 	nop
8111c6f0:	e037883a 	mov	sp,fp
8111c6f4:	dfc00117 	ldw	ra,4(sp)
8111c6f8:	df000017 	ldw	fp,0(sp)
8111c6fc:	dec00204 	addi	sp,sp,8
8111c700:	f800283a 	ret

8111c704 <vFailCreateNFEEQueue>:

/* CRITICAL. */
void vFailCreateNFEEQueue( unsigned char ucID )
{
8111c704:	defffd04 	addi	sp,sp,-12
8111c708:	de00012e 	bgeu	sp,et,8111c710 <vFailCreateNFEEQueue+0xc>
8111c70c:	003b68fa 	trap	3
8111c710:	dfc00215 	stw	ra,8(sp)
8111c714:	df000115 	stw	fp,4(sp)
8111c718:	df000104 	addi	fp,sp,4
8111c71c:	2005883a 	mov	r2,r4
8111c720:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateNFEEQueue. (exit)\n");
8111c724:	d0a06217 	ldw	r2,-32376(gp)
8111c728:	100f883a 	mov	r7,r2
8111c72c:	01800744 	movi	r6,29
8111c730:	01400044 	movi	r5,1
8111c734:	01204574 	movhi	r4,33045
8111c738:	213df204 	addi	r4,r4,-2104
8111c73c:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		printf(fp,"CRITICAL: Could not create the Queue to the NSEE %hhu.\n",ucID);
8111c740:	d0a06217 	ldw	r2,-32376(gp)
8111c744:	e0ffff03 	ldbu	r3,-4(fp)
8111c748:	180d883a 	mov	r6,r3
8111c74c:	01604574 	movhi	r5,33045
8111c750:	297dfa04 	addi	r5,r5,-2072
8111c754:	1009883a 	mov	r4,r2
8111c758:	112236c0 	call	8112236c <printf>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c75c:	0001883a 	nop
8111c760:	e037883a 	mov	sp,fp
8111c764:	dfc00117 	ldw	ra,4(sp)
8111c768:	df000017 	ldw	fp,0(sp)
8111c76c:	dec00204 	addi	sp,sp,8
8111c770:	f800283a 	ret

8111c774 <vFailCreateNFEESyncQueue>:

/* CRITICAL. */
void vFailCreateNFEESyncQueue( unsigned char ucID )
{
8111c774:	defffd04 	addi	sp,sp,-12
8111c778:	de00012e 	bgeu	sp,et,8111c780 <vFailCreateNFEESyncQueue+0xc>
8111c77c:	003b68fa 	trap	3
8111c780:	dfc00215 	stw	ra,8(sp)
8111c784:	df000115 	stw	fp,4(sp)
8111c788:	df000104 	addi	fp,sp,4
8111c78c:	2005883a 	mov	r2,r4
8111c790:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateNFEESyncQueue. (exit)\n");
8111c794:	d0a06217 	ldw	r2,-32376(gp)
8111c798:	100f883a 	mov	r7,r2
8111c79c:	01800844 	movi	r6,33
8111c7a0:	01400044 	movi	r5,1
8111c7a4:	01204574 	movhi	r4,33045
8111c7a8:	213e0804 	addi	r4,r4,-2016
8111c7ac:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		printf(fp,"CRITICAL: Could not create the Queue to the NFEE %hhu.\n",ucID);
8111c7b0:	d0a06217 	ldw	r2,-32376(gp)
8111c7b4:	e0ffff03 	ldbu	r3,-4(fp)
8111c7b8:	180d883a 	mov	r6,r3
8111c7bc:	01604574 	movhi	r5,33045
8111c7c0:	297e1104 	addi	r5,r5,-1980
8111c7c4:	1009883a 	mov	r4,r2
8111c7c8:	112236c0 	call	8112236c <printf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c7cc:	0001883a 	nop
8111c7d0:	e037883a 	mov	sp,fp
8111c7d4:	dfc00117 	ldw	ra,4(sp)
8111c7d8:	df000017 	ldw	fp,0(sp)
8111c7dc:	dec00204 	addi	sp,sp,8
8111c7e0:	f800283a 	ret

8111c7e4 <vCoudlNotCreateNFee0Task>:

void vCoudlNotCreateNFee0Task( void )
{
8111c7e4:	defffe04 	addi	sp,sp,-8
8111c7e8:	de00012e 	bgeu	sp,et,8111c7f0 <vCoudlNotCreateNFee0Task+0xc>
8111c7ec:	003b68fa 	trap	3
8111c7f0:	dfc00115 	stw	ra,4(sp)
8111c7f4:	df000015 	stw	fp,0(sp)
8111c7f8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee0Task. (exit)\n");
8111c7fc:	d0a06217 	ldw	r2,-32376(gp)
8111c800:	100f883a 	mov	r7,r2
8111c804:	01800844 	movi	r6,33
8111c808:	01400044 	movi	r5,1
8111c80c:	01204574 	movhi	r4,33045
8111c810:	213e1f04 	addi	r4,r4,-1924
8111c814:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 0 Task.\n");
8111c818:	d0a06217 	ldw	r2,-32376(gp)
8111c81c:	100f883a 	mov	r7,r2
8111c820:	01800784 	movi	r6,30
8111c824:	01400044 	movi	r5,1
8111c828:	01204574 	movhi	r4,33045
8111c82c:	213e2804 	addi	r4,r4,-1888
8111c830:	11216400 	call	81121640 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c834:	0001883a 	nop
8111c838:	e037883a 	mov	sp,fp
8111c83c:	dfc00117 	ldw	ra,4(sp)
8111c840:	df000017 	ldw	fp,0(sp)
8111c844:	dec00204 	addi	sp,sp,8
8111c848:	f800283a 	ret

8111c84c <vCoudlNotCreateNFee1Task>:


void vCoudlNotCreateNFee1Task( void )
{
8111c84c:	defffe04 	addi	sp,sp,-8
8111c850:	de00012e 	bgeu	sp,et,8111c858 <vCoudlNotCreateNFee1Task+0xc>
8111c854:	003b68fa 	trap	3
8111c858:	dfc00115 	stw	ra,4(sp)
8111c85c:	df000015 	stw	fp,0(sp)
8111c860:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee1Task. (exit)\n");
8111c864:	d0a06217 	ldw	r2,-32376(gp)
8111c868:	100f883a 	mov	r7,r2
8111c86c:	01800844 	movi	r6,33
8111c870:	01400044 	movi	r5,1
8111c874:	01204574 	movhi	r4,33045
8111c878:	213e3004 	addi	r4,r4,-1856
8111c87c:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 1 Task.\n");
8111c880:	d0a06217 	ldw	r2,-32376(gp)
8111c884:	100f883a 	mov	r7,r2
8111c888:	01800784 	movi	r6,30
8111c88c:	01400044 	movi	r5,1
8111c890:	01204574 	movhi	r4,33045
8111c894:	213e3904 	addi	r4,r4,-1820
8111c898:	11216400 	call	81121640 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c89c:	0001883a 	nop
8111c8a0:	e037883a 	mov	sp,fp
8111c8a4:	dfc00117 	ldw	ra,4(sp)
8111c8a8:	df000017 	ldw	fp,0(sp)
8111c8ac:	dec00204 	addi	sp,sp,8
8111c8b0:	f800283a 	ret

8111c8b4 <vCoudlNotCreateNFee2Task>:

void vCoudlNotCreateNFee2Task( void )
{
8111c8b4:	defffe04 	addi	sp,sp,-8
8111c8b8:	de00012e 	bgeu	sp,et,8111c8c0 <vCoudlNotCreateNFee2Task+0xc>
8111c8bc:	003b68fa 	trap	3
8111c8c0:	dfc00115 	stw	ra,4(sp)
8111c8c4:	df000015 	stw	fp,0(sp)
8111c8c8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee2Task. (exit)\n");
8111c8cc:	d0a06217 	ldw	r2,-32376(gp)
8111c8d0:	100f883a 	mov	r7,r2
8111c8d4:	01800844 	movi	r6,33
8111c8d8:	01400044 	movi	r5,1
8111c8dc:	01204574 	movhi	r4,33045
8111c8e0:	213e4104 	addi	r4,r4,-1788
8111c8e4:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 2 Task.\n");
8111c8e8:	d0a06217 	ldw	r2,-32376(gp)
8111c8ec:	100f883a 	mov	r7,r2
8111c8f0:	01800784 	movi	r6,30
8111c8f4:	01400044 	movi	r5,1
8111c8f8:	01204574 	movhi	r4,33045
8111c8fc:	213e4a04 	addi	r4,r4,-1752
8111c900:	11216400 	call	81121640 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c904:	0001883a 	nop
8111c908:	e037883a 	mov	sp,fp
8111c90c:	dfc00117 	ldw	ra,4(sp)
8111c910:	df000017 	ldw	fp,0(sp)
8111c914:	dec00204 	addi	sp,sp,8
8111c918:	f800283a 	ret

8111c91c <vCoudlNotCreateNFee3Task>:

void vCoudlNotCreateNFee3Task( void )
{
8111c91c:	defffe04 	addi	sp,sp,-8
8111c920:	de00012e 	bgeu	sp,et,8111c928 <vCoudlNotCreateNFee3Task+0xc>
8111c924:	003b68fa 	trap	3
8111c928:	dfc00115 	stw	ra,4(sp)
8111c92c:	df000015 	stw	fp,0(sp)
8111c930:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee3Task. (exit)\n");
8111c934:	d0a06217 	ldw	r2,-32376(gp)
8111c938:	100f883a 	mov	r7,r2
8111c93c:	01800844 	movi	r6,33
8111c940:	01400044 	movi	r5,1
8111c944:	01204574 	movhi	r4,33045
8111c948:	213e5204 	addi	r4,r4,-1720
8111c94c:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 3 Task.\n");
8111c950:	d0a06217 	ldw	r2,-32376(gp)
8111c954:	100f883a 	mov	r7,r2
8111c958:	01800784 	movi	r6,30
8111c95c:	01400044 	movi	r5,1
8111c960:	01204574 	movhi	r4,33045
8111c964:	213e5b04 	addi	r4,r4,-1684
8111c968:	11216400 	call	81121640 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c96c:	0001883a 	nop
8111c970:	e037883a 	mov	sp,fp
8111c974:	dfc00117 	ldw	ra,4(sp)
8111c978:	df000017 	ldw	fp,0(sp)
8111c97c:	dec00204 	addi	sp,sp,8
8111c980:	f800283a 	ret

8111c984 <vCoudlNotCreateNFee4Task>:

void vCoudlNotCreateNFee4Task( void )
{
8111c984:	defffe04 	addi	sp,sp,-8
8111c988:	de00012e 	bgeu	sp,et,8111c990 <vCoudlNotCreateNFee4Task+0xc>
8111c98c:	003b68fa 	trap	3
8111c990:	dfc00115 	stw	ra,4(sp)
8111c994:	df000015 	stw	fp,0(sp)
8111c998:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee4Task. (exit)\n");
8111c99c:	d0a06217 	ldw	r2,-32376(gp)
8111c9a0:	100f883a 	mov	r7,r2
8111c9a4:	01800844 	movi	r6,33
8111c9a8:	01400044 	movi	r5,1
8111c9ac:	01204574 	movhi	r4,33045
8111c9b0:	213e6304 	addi	r4,r4,-1652
8111c9b4:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 4 Task.\n");
8111c9b8:	d0a06217 	ldw	r2,-32376(gp)
8111c9bc:	100f883a 	mov	r7,r2
8111c9c0:	01800784 	movi	r6,30
8111c9c4:	01400044 	movi	r5,1
8111c9c8:	01204574 	movhi	r4,33045
8111c9cc:	213e6c04 	addi	r4,r4,-1616
8111c9d0:	11216400 	call	81121640 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c9d4:	0001883a 	nop
8111c9d8:	e037883a 	mov	sp,fp
8111c9dc:	dfc00117 	ldw	ra,4(sp)
8111c9e0:	df000017 	ldw	fp,0(sp)
8111c9e4:	dec00204 	addi	sp,sp,8
8111c9e8:	f800283a 	ret

8111c9ec <vCoudlNotCreateNFee5Task>:

void vCoudlNotCreateNFee5Task( void )
{
8111c9ec:	defffe04 	addi	sp,sp,-8
8111c9f0:	de00012e 	bgeu	sp,et,8111c9f8 <vCoudlNotCreateNFee5Task+0xc>
8111c9f4:	003b68fa 	trap	3
8111c9f8:	dfc00115 	stw	ra,4(sp)
8111c9fc:	df000015 	stw	fp,0(sp)
8111ca00:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee5Task. (exit)\n");
8111ca04:	d0a06217 	ldw	r2,-32376(gp)
8111ca08:	100f883a 	mov	r7,r2
8111ca0c:	01800844 	movi	r6,33
8111ca10:	01400044 	movi	r5,1
8111ca14:	01204574 	movhi	r4,33045
8111ca18:	213e7404 	addi	r4,r4,-1584
8111ca1c:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 5 Task.\n");
8111ca20:	d0a06217 	ldw	r2,-32376(gp)
8111ca24:	100f883a 	mov	r7,r2
8111ca28:	01800784 	movi	r6,30
8111ca2c:	01400044 	movi	r5,1
8111ca30:	01204574 	movhi	r4,33045
8111ca34:	213e7d04 	addi	r4,r4,-1548
8111ca38:	11216400 	call	81121640 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ca3c:	0001883a 	nop
8111ca40:	e037883a 	mov	sp,fp
8111ca44:	dfc00117 	ldw	ra,4(sp)
8111ca48:	df000017 	ldw	fp,0(sp)
8111ca4c:	dec00204 	addi	sp,sp,8
8111ca50:	f800283a 	ret

8111ca54 <vCoudlNotCreateNFeeControllerTask>:


void vCoudlNotCreateNFeeControllerTask( void )
{
8111ca54:	defffe04 	addi	sp,sp,-8
8111ca58:	de00012e 	bgeu	sp,et,8111ca60 <vCoudlNotCreateNFeeControllerTask+0xc>
8111ca5c:	003b68fa 	trap	3
8111ca60:	dfc00115 	stw	ra,4(sp)
8111ca64:	df000015 	stw	fp,0(sp)
8111ca68:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFeeControllerTask. (exit)\n");
8111ca6c:	d0a06217 	ldw	r2,-32376(gp)
8111ca70:	100f883a 	mov	r7,r2
8111ca74:	01800a84 	movi	r6,42
8111ca78:	01400044 	movi	r5,1
8111ca7c:	01204574 	movhi	r4,33045
8111ca80:	213e8504 	addi	r4,r4,-1516
8111ca84:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE Controller Task.\n");
8111ca88:	d0a06217 	ldw	r2,-32376(gp)
8111ca8c:	100f883a 	mov	r7,r2
8111ca90:	018009c4 	movi	r6,39
8111ca94:	01400044 	movi	r5,1
8111ca98:	01204574 	movhi	r4,33045
8111ca9c:	213e9004 	addi	r4,r4,-1472
8111caa0:	11216400 	call	81121640 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111caa4:	0001883a 	nop
8111caa8:	e037883a 	mov	sp,fp
8111caac:	dfc00117 	ldw	ra,4(sp)
8111cab0:	df000017 	ldw	fp,0(sp)
8111cab4:	dec00204 	addi	sp,sp,8
8111cab8:	f800283a 	ret

8111cabc <vCoudlNotCreateDataControllerTask>:


void vCoudlNotCreateDataControllerTask( void )
{
8111cabc:	defffe04 	addi	sp,sp,-8
8111cac0:	de00012e 	bgeu	sp,et,8111cac8 <vCoudlNotCreateDataControllerTask+0xc>
8111cac4:	003b68fa 	trap	3
8111cac8:	dfc00115 	stw	ra,4(sp)
8111cacc:	df000015 	stw	fp,0(sp)
8111cad0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateDataControllerTask. (exit)\n");
8111cad4:	d0a06217 	ldw	r2,-32376(gp)
8111cad8:	100f883a 	mov	r7,r2
8111cadc:	01800a84 	movi	r6,42
8111cae0:	01400044 	movi	r5,1
8111cae4:	01204574 	movhi	r4,33045
8111cae8:	213e9a04 	addi	r4,r4,-1432
8111caec:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create Data Controller Task.\n");
8111caf0:	d0a06217 	ldw	r2,-32376(gp)
8111caf4:	100f883a 	mov	r7,r2
8111caf8:	018009c4 	movi	r6,39
8111cafc:	01400044 	movi	r5,1
8111cb00:	01204574 	movhi	r4,33045
8111cb04:	213ea504 	addi	r4,r4,-1388
8111cb08:	11216400 	call	81121640 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cb0c:	0001883a 	nop
8111cb10:	e037883a 	mov	sp,fp
8111cb14:	dfc00117 	ldw	ra,4(sp)
8111cb18:	df000017 	ldw	fp,0(sp)
8111cb1c:	dec00204 	addi	sp,sp,8
8111cb20:	f800283a 	ret

8111cb24 <vCoudlNotCreateMebTask>:


void vCoudlNotCreateMebTask( void )
{
8111cb24:	defffe04 	addi	sp,sp,-8
8111cb28:	de00012e 	bgeu	sp,et,8111cb30 <vCoudlNotCreateMebTask+0xc>
8111cb2c:	003b68fa 	trap	3
8111cb30:	dfc00115 	stw	ra,4(sp)
8111cb34:	df000015 	stw	fp,0(sp)
8111cb38:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateMebTask. (exit)\n");
8111cb3c:	d0a06217 	ldw	r2,-32376(gp)
8111cb40:	100f883a 	mov	r7,r2
8111cb44:	018007c4 	movi	r6,31
8111cb48:	01400044 	movi	r5,1
8111cb4c:	01204574 	movhi	r4,33045
8111cb50:	213eaf04 	addi	r4,r4,-1348
8111cb54:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create Meb Task.\n");
8111cb58:	d0a06217 	ldw	r2,-32376(gp)
8111cb5c:	100f883a 	mov	r7,r2
8111cb60:	018006c4 	movi	r6,27
8111cb64:	01400044 	movi	r5,1
8111cb68:	01204574 	movhi	r4,33045
8111cb6c:	213eb704 	addi	r4,r4,-1316
8111cb70:	11216400 	call	81121640 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cb74:	0001883a 	nop
8111cb78:	e037883a 	mov	sp,fp
8111cb7c:	dfc00117 	ldw	ra,4(sp)
8111cb80:	df000017 	ldw	fp,0(sp)
8111cb84:	dec00204 	addi	sp,sp,8
8111cb88:	f800283a 	ret

8111cb8c <vFailCreateMutexSPUSQueueMeb>:


void vFailCreateMutexSPUSQueueMeb( INT8U error_code )
{
8111cb8c:	defffd04 	addi	sp,sp,-12
8111cb90:	de00012e 	bgeu	sp,et,8111cb98 <vFailCreateMutexSPUSQueueMeb+0xc>
8111cb94:	003b68fa 	trap	3
8111cb98:	dfc00215 	stw	ra,8(sp)
8111cb9c:	df000115 	stw	fp,4(sp)
8111cba0:	df000104 	addi	fp,sp,4
8111cba4:	2005883a 	mov	r2,r4
8111cba8:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateMutexSPUSQueueMeb. (exit)\n");
8111cbac:	d0a06217 	ldw	r2,-32376(gp)
8111cbb0:	100f883a 	mov	r7,r2
8111cbb4:	01800944 	movi	r6,37
8111cbb8:	01400044 	movi	r5,1
8111cbbc:	01204574 	movhi	r4,33045
8111cbc0:	213ebe04 	addi	r4,r4,-1288
8111cbc4:	11216400 	call	81121640 <fwrite>
	#endif
	#ifdef DEBUG_ON
		printErrorTask(error_code);
8111cbc8:	e0bfff03 	ldbu	r2,-4(fp)
8111cbcc:	1009883a 	mov	r4,r2
8111cbd0:	111b3380 	call	8111b338 <printErrorTask>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cbd4:	0001883a 	nop
8111cbd8:	e037883a 	mov	sp,fp
8111cbdc:	dfc00117 	ldw	ra,4(sp)
8111cbe0:	df000017 	ldw	fp,0(sp)
8111cbe4:	dec00204 	addi	sp,sp,8
8111cbe8:	f800283a 	ret

8111cbec <vFailSendPUStoMebTask>:

void vFailSendPUStoMebTask( void )
{
8111cbec:	defffe04 	addi	sp,sp,-8
8111cbf0:	de00012e 	bgeu	sp,et,8111cbf8 <vFailSendPUStoMebTask+0xc>
8111cbf4:	003b68fa 	trap	3
8111cbf8:	dfc00115 	stw	ra,4(sp)
8111cbfc:	df000015 	stw	fp,0(sp)
8111cc00:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPUStoMebTask. (exit)\n");
8111cc04:	d0a06217 	ldw	r2,-32376(gp)
8111cc08:	100f883a 	mov	r7,r2
8111cc0c:	01800784 	movi	r6,30
8111cc10:	01400044 	movi	r5,1
8111cc14:	01204574 	movhi	r4,33045
8111cc18:	213ec804 	addi	r4,r4,-1248
8111cc1c:	11216400 	call	81121640 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cc20:	0001883a 	nop
8111cc24:	e037883a 	mov	sp,fp
8111cc28:	dfc00117 	ldw	ra,4(sp)
8111cc2c:	df000017 	ldw	fp,0(sp)
8111cc30:	dec00204 	addi	sp,sp,8
8111cc34:	f800283a 	ret

8111cc38 <vCouldNotGetCmdQueueMeb>:

void vCouldNotGetCmdQueueMeb( void )
{
8111cc38:	defffe04 	addi	sp,sp,-8
8111cc3c:	de00012e 	bgeu	sp,et,8111cc44 <vCouldNotGetCmdQueueMeb+0xc>
8111cc40:	003b68fa 	trap	3
8111cc44:	dfc00115 	stw	ra,4(sp)
8111cc48:	df000015 	stw	fp,0(sp)
8111cc4c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vCouldNotGetCmdQueueMeb. (exit)\n");
8111cc50:	d0a06217 	ldw	r2,-32376(gp)
8111cc54:	100f883a 	mov	r7,r2
8111cc58:	01800a84 	movi	r6,42
8111cc5c:	01400044 	movi	r5,1
8111cc60:	01204574 	movhi	r4,33045
8111cc64:	213ed004 	addi	r4,r4,-1216
8111cc68:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get COmmand from Queue in the Meb Task. \n");
8111cc6c:	d0a06217 	ldw	r2,-32376(gp)
8111cc70:	100f883a 	mov	r7,r2
8111cc74:	01800cc4 	movi	r6,51
8111cc78:	01400044 	movi	r5,1
8111cc7c:	01204574 	movhi	r4,33045
8111cc80:	213edb04 	addi	r4,r4,-1172
8111cc84:	11216400 	call	81121640 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cc88:	0001883a 	nop
8111cc8c:	e037883a 	mov	sp,fp
8111cc90:	dfc00117 	ldw	ra,4(sp)
8111cc94:	df000017 	ldw	fp,0(sp)
8111cc98:	dec00204 	addi	sp,sp,8
8111cc9c:	f800283a 	ret

8111cca0 <vCouldNotGetMutexMebPus>:


void vCouldNotGetMutexMebPus( void )
{
8111cca0:	defffe04 	addi	sp,sp,-8
8111cca4:	de00012e 	bgeu	sp,et,8111ccac <vCouldNotGetMutexMebPus+0xc>
8111cca8:	003b68fa 	trap	3
8111ccac:	dfc00115 	stw	ra,4(sp)
8111ccb0:	df000015 	stw	fp,0(sp)
8111ccb4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetMutexMebPus. (exit)\n");
8111ccb8:	d0a06217 	ldw	r2,-32376(gp)
8111ccbc:	100f883a 	mov	r7,r2
8111ccc0:	01800804 	movi	r6,32
8111ccc4:	01400044 	movi	r5,1
8111ccc8:	01204574 	movhi	r4,33045
8111cccc:	213ee804 	addi	r4,r4,-1120
8111ccd0:	11216400 	call	81121640 <fwrite>
	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ccd4:	0001883a 	nop
8111ccd8:	e037883a 	mov	sp,fp
8111ccdc:	dfc00117 	ldw	ra,4(sp)
8111cce0:	df000017 	ldw	fp,0(sp)
8111cce4:	dec00204 	addi	sp,sp,8
8111cce8:	f800283a 	ret

8111ccec <vCouldNotCreateQueueMaskNfeeCtrl>:

void vCouldNotCreateQueueMaskNfeeCtrl( void )
{
8111ccec:	defffe04 	addi	sp,sp,-8
8111ccf0:	de00012e 	bgeu	sp,et,8111ccf8 <vCouldNotCreateQueueMaskNfeeCtrl+0xc>
8111ccf4:	003b68fa 	trap	3
8111ccf8:	dfc00115 	stw	ra,4(sp)
8111ccfc:	df000015 	stw	fp,0(sp)
8111cd00:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotCreateQueueMaskNfeeCtrl. (exit)\n");
8111cd04:	d0a06217 	ldw	r2,-32376(gp)
8111cd08:	100f883a 	mov	r7,r2
8111cd0c:	01800a44 	movi	r6,41
8111cd10:	01400044 	movi	r5,1
8111cd14:	01204574 	movhi	r4,33045
8111cd18:	213ef104 	addi	r4,r4,-1084
8111cd1c:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not Create Queue Mask for NFEE Controller. \n");
8111cd20:	d0a06217 	ldw	r2,-32376(gp)
8111cd24:	100f883a 	mov	r7,r2
8111cd28:	01800c84 	movi	r6,50
8111cd2c:	01400044 	movi	r5,1
8111cd30:	01204574 	movhi	r4,33045
8111cd34:	213efc04 	addi	r4,r4,-1040
8111cd38:	11216400 	call	81121640 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cd3c:	0001883a 	nop
8111cd40:	e037883a 	mov	sp,fp
8111cd44:	dfc00117 	ldw	ra,4(sp)
8111cd48:	df000017 	ldw	fp,0(sp)
8111cd4c:	dec00204 	addi	sp,sp,8
8111cd50:	f800283a 	ret

8111cd54 <vCouldNotCreateQueueMaskDataCtrl>:

void vCouldNotCreateQueueMaskDataCtrl( void )
{
8111cd54:	defffe04 	addi	sp,sp,-8
8111cd58:	de00012e 	bgeu	sp,et,8111cd60 <vCouldNotCreateQueueMaskDataCtrl+0xc>
8111cd5c:	003b68fa 	trap	3
8111cd60:	dfc00115 	stw	ra,4(sp)
8111cd64:	df000015 	stw	fp,0(sp)
8111cd68:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotCreateQueueMaskDataCtrl. (exit)\n");
8111cd6c:	d0a06217 	ldw	r2,-32376(gp)
8111cd70:	100f883a 	mov	r7,r2
8111cd74:	01800a44 	movi	r6,41
8111cd78:	01400044 	movi	r5,1
8111cd7c:	01204574 	movhi	r4,33045
8111cd80:	213f0904 	addi	r4,r4,-988
8111cd84:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not Create Queue Mask for Data Controller. \n");
8111cd88:	d0a06217 	ldw	r2,-32376(gp)
8111cd8c:	100f883a 	mov	r7,r2
8111cd90:	01800c84 	movi	r6,50
8111cd94:	01400044 	movi	r5,1
8111cd98:	01204574 	movhi	r4,33045
8111cd9c:	213f1404 	addi	r4,r4,-944
8111cda0:	11216400 	call	81121640 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cda4:	0001883a 	nop
8111cda8:	e037883a 	mov	sp,fp
8111cdac:	dfc00117 	ldw	ra,4(sp)
8111cdb0:	df000017 	ldw	fp,0(sp)
8111cdb4:	dec00204 	addi	sp,sp,8
8111cdb8:	f800283a 	ret

8111cdbc <vCouldNotGetQueueMaskNfeeCtrl>:

void vCouldNotGetQueueMaskNfeeCtrl( void )
{
8111cdbc:	defffe04 	addi	sp,sp,-8
8111cdc0:	de00012e 	bgeu	sp,et,8111cdc8 <vCouldNotGetQueueMaskNfeeCtrl+0xc>
8111cdc4:	003b68fa 	trap	3
8111cdc8:	dfc00115 	stw	ra,4(sp)
8111cdcc:	df000015 	stw	fp,0(sp)
8111cdd0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetQueueMaskNfeeCtrl. (exit)\n");
8111cdd4:	d0a06217 	ldw	r2,-32376(gp)
8111cdd8:	100f883a 	mov	r7,r2
8111cddc:	01800984 	movi	r6,38
8111cde0:	01400044 	movi	r5,1
8111cde4:	01204574 	movhi	r4,33045
8111cde8:	213f2104 	addi	r4,r4,-892
8111cdec:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get Queue Mask for NFEE Controller. \n");
8111cdf0:	d0a06217 	ldw	r2,-32376(gp)
8111cdf4:	100f883a 	mov	r7,r2
8111cdf8:	01800bc4 	movi	r6,47
8111cdfc:	01400044 	movi	r5,1
8111ce00:	01204574 	movhi	r4,33045
8111ce04:	213f2b04 	addi	r4,r4,-852
8111ce08:	11216400 	call	81121640 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ce0c:	0001883a 	nop
8111ce10:	e037883a 	mov	sp,fp
8111ce14:	dfc00117 	ldw	ra,4(sp)
8111ce18:	df000017 	ldw	fp,0(sp)
8111ce1c:	dec00204 	addi	sp,sp,8
8111ce20:	f800283a 	ret

8111ce24 <vCouldNotGetQueueMaskDataCtrl>:

void vCouldNotGetQueueMaskDataCtrl( void )
{
8111ce24:	defffe04 	addi	sp,sp,-8
8111ce28:	de00012e 	bgeu	sp,et,8111ce30 <vCouldNotGetQueueMaskDataCtrl+0xc>
8111ce2c:	003b68fa 	trap	3
8111ce30:	dfc00115 	stw	ra,4(sp)
8111ce34:	df000015 	stw	fp,0(sp)
8111ce38:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetQueueMaskDataCtrl. (exit)\n");
8111ce3c:	d0a06217 	ldw	r2,-32376(gp)
8111ce40:	100f883a 	mov	r7,r2
8111ce44:	01800984 	movi	r6,38
8111ce48:	01400044 	movi	r5,1
8111ce4c:	01204574 	movhi	r4,33045
8111ce50:	213f3704 	addi	r4,r4,-804
8111ce54:	11216400 	call	81121640 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get Queue Mask for Data Controller. \n");
8111ce58:	d0a06217 	ldw	r2,-32376(gp)
8111ce5c:	100f883a 	mov	r7,r2
8111ce60:	01800bc4 	movi	r6,47
8111ce64:	01400044 	movi	r5,1
8111ce68:	01204574 	movhi	r4,33045
8111ce6c:	213f4104 	addi	r4,r4,-764
8111ce70:	11216400 	call	81121640 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ce74:	0001883a 	nop
8111ce78:	e037883a 	mov	sp,fp
8111ce7c:	dfc00117 	ldw	ra,4(sp)
8111ce80:	df000017 	ldw	fp,0(sp)
8111ce84:	dec00204 	addi	sp,sp,8
8111ce88:	f800283a 	ret

8111ce8c <vFailSendMsgAccessDMA>:


void vFailSendMsgAccessDMA( unsigned char ucTemp)
{
8111ce8c:	defffd04 	addi	sp,sp,-12
8111ce90:	de00012e 	bgeu	sp,et,8111ce98 <vFailSendMsgAccessDMA+0xc>
8111ce94:	003b68fa 	trap	3
8111ce98:	dfc00215 	stw	ra,8(sp)
8111ce9c:	df000115 	stw	fp,4(sp)
8111cea0:	df000104 	addi	fp,sp,4
8111cea4:	2005883a 	mov	r2,r4
8111cea8:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendMsgAccessDMA. FEE n: \n", ucTemp);
8111ceac:	d0a06217 	ldw	r2,-32376(gp)
8111ceb0:	e0ffff03 	ldbu	r3,-4(fp)
8111ceb4:	180d883a 	mov	r6,r3
8111ceb8:	01604574 	movhi	r5,33045
8111cebc:	297f4d04 	addi	r5,r5,-716
8111cec0:	1009883a 	mov	r4,r2
8111cec4:	1120fa40 	call	81120fa4 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cec8:	0001883a 	nop
8111cecc:	e037883a 	mov	sp,fp
8111ced0:	dfc00117 	ldw	ra,4(sp)
8111ced4:	df000017 	ldw	fp,0(sp)
8111ced8:	dec00204 	addi	sp,sp,8
8111cedc:	f800283a 	ret

8111cee0 <vFailRequestDMA>:

void vFailRequestDMA( unsigned char ucTemp)
{
8111cee0:	defffd04 	addi	sp,sp,-12
8111cee4:	de00012e 	bgeu	sp,et,8111ceec <vFailRequestDMA+0xc>
8111cee8:	003b68fa 	trap	3
8111ceec:	dfc00215 	stw	ra,8(sp)
8111cef0:	df000115 	stw	fp,4(sp)
8111cef4:	df000104 	addi	fp,sp,4
8111cef8:	2005883a 	mov	r2,r4
8111cefc:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailRequestDMA. FEE n: \n", ucTemp);
8111cf00:	d0a06217 	ldw	r2,-32376(gp)
8111cf04:	e0ffff03 	ldbu	r3,-4(fp)
8111cf08:	180d883a 	mov	r6,r3
8111cf0c:	01604574 	movhi	r5,33045
8111cf10:	297f5504 	addi	r5,r5,-684
8111cf14:	1009883a 	mov	r4,r2
8111cf18:	1120fa40 	call	81120fa4 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cf1c:	0001883a 	nop
8111cf20:	e037883a 	mov	sp,fp
8111cf24:	dfc00117 	ldw	ra,4(sp)
8111cf28:	df000017 	ldw	fp,0(sp)
8111cf2c:	dec00204 	addi	sp,sp,8
8111cf30:	f800283a 	ret

8111cf34 <vFailRequestDMAFromIRQ>:

void vFailRequestDMAFromIRQ( unsigned char ucTemp)
{
8111cf34:	defffd04 	addi	sp,sp,-12
8111cf38:	de00012e 	bgeu	sp,et,8111cf40 <vFailRequestDMAFromIRQ+0xc>
8111cf3c:	003b68fa 	trap	3
8111cf40:	dfc00215 	stw	ra,8(sp)
8111cf44:	df000115 	stw	fp,4(sp)
8111cf48:	df000104 	addi	fp,sp,4
8111cf4c:	2005883a 	mov	r2,r4
8111cf50:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailRequestDMA. FEE n: \n", ucTemp);
8111cf54:	d0a06217 	ldw	r2,-32376(gp)
8111cf58:	e0ffff03 	ldbu	r3,-4(fp)
8111cf5c:	180d883a 	mov	r6,r3
8111cf60:	01604574 	movhi	r5,33045
8111cf64:	297f5504 	addi	r5,r5,-684
8111cf68:	1009883a 	mov	r4,r2
8111cf6c:	1120fa40 	call	81120fa4 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cf70:	0001883a 	nop
8111cf74:	e037883a 	mov	sp,fp
8111cf78:	dfc00117 	ldw	ra,4(sp)
8111cf7c:	df000017 	ldw	fp,0(sp)
8111cf80:	dec00204 	addi	sp,sp,8
8111cf84:	f800283a 	ret

8111cf88 <vFailSendRMAPFromIRQ>:


void vFailSendRMAPFromIRQ( unsigned char ucTemp)
{
8111cf88:	defffd04 	addi	sp,sp,-12
8111cf8c:	de00012e 	bgeu	sp,et,8111cf94 <vFailSendRMAPFromIRQ+0xc>
8111cf90:	003b68fa 	trap	3
8111cf94:	dfc00215 	stw	ra,8(sp)
8111cf98:	df000115 	stw	fp,4(sp)
8111cf9c:	df000104 	addi	fp,sp,4
8111cfa0:	2005883a 	mov	r2,r4
8111cfa4:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendRMAPFromIRQ. FEE n: \n", ucTemp);
8111cfa8:	d0a06217 	ldw	r2,-32376(gp)
8111cfac:	e0ffff03 	ldbu	r3,-4(fp)
8111cfb0:	180d883a 	mov	r6,r3
8111cfb4:	01604574 	movhi	r5,33045
8111cfb8:	297f5c04 	addi	r5,r5,-656
8111cfbc:	1009883a 	mov	r4,r2
8111cfc0:	1120fa40 	call	81120fa4 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cfc4:	0001883a 	nop
8111cfc8:	e037883a 	mov	sp,fp
8111cfcc:	dfc00117 	ldw	ra,4(sp)
8111cfd0:	df000017 	ldw	fp,0(sp)
8111cfd4:	dec00204 	addi	sp,sp,8
8111cfd8:	f800283a 	ret

8111cfdc <vFailSendMsgSync>:


void vFailSendMsgSync( unsigned char ucTemp)
{
8111cfdc:	defffd04 	addi	sp,sp,-12
8111cfe0:	de00012e 	bgeu	sp,et,8111cfe8 <vFailSendMsgSync+0xc>
8111cfe4:	003b68fa 	trap	3
8111cfe8:	dfc00215 	stw	ra,8(sp)
8111cfec:	df000115 	stw	fp,4(sp)
8111cff0:	df000104 	addi	fp,sp,4
8111cff4:	2005883a 	mov	r2,r4
8111cff8:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendMsgSync. FEE n: \n", ucTemp);
8111cffc:	d0a06217 	ldw	r2,-32376(gp)
8111d000:	e0ffff03 	ldbu	r3,-4(fp)
8111d004:	180d883a 	mov	r6,r3
8111d008:	01604574 	movhi	r5,33045
8111d00c:	297f6404 	addi	r5,r5,-624
8111d010:	1009883a 	mov	r4,r2
8111d014:	1120fa40 	call	81120fa4 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d018:	0001883a 	nop
8111d01c:	e037883a 	mov	sp,fp
8111d020:	dfc00117 	ldw	ra,4(sp)
8111d024:	df000017 	ldw	fp,0(sp)
8111d028:	dec00204 	addi	sp,sp,8
8111d02c:	f800283a 	ret

8111d030 <vFailSendMsgSyncRMAPTRIGGER>:

void vFailSendMsgSyncRMAPTRIGGER( unsigned char ucTemp)
{
8111d030:	defffd04 	addi	sp,sp,-12
8111d034:	de00012e 	bgeu	sp,et,8111d03c <vFailSendMsgSyncRMAPTRIGGER+0xc>
8111d038:	003b68fa 	trap	3
8111d03c:	dfc00215 	stw	ra,8(sp)
8111d040:	df000115 	stw	fp,4(sp)
8111d044:	df000104 	addi	fp,sp,4
8111d048:	2005883a 	mov	r2,r4
8111d04c:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendMsgSyncRMAPTRIGGER (FORCED MODE). FEE n: \n", ucTemp);
8111d050:	d0a06217 	ldw	r2,-32376(gp)
8111d054:	e0ffff03 	ldbu	r3,-4(fp)
8111d058:	180d883a 	mov	r6,r3
8111d05c:	01604574 	movhi	r5,33045
8111d060:	297f6b04 	addi	r5,r5,-596
8111d064:	1009883a 	mov	r4,r2
8111d068:	1120fa40 	call	81120fa4 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d06c:	0001883a 	nop
8111d070:	e037883a 	mov	sp,fp
8111d074:	dfc00117 	ldw	ra,4(sp)
8111d078:	df000017 	ldw	fp,0(sp)
8111d07c:	dec00204 	addi	sp,sp,8
8111d080:	f800283a 	ret

8111d084 <vFailSendMsgMasterSyncMeb>:

void vFailSendMsgMasterSyncMeb( void )
{
8111d084:	defffe04 	addi	sp,sp,-8
8111d088:	de00012e 	bgeu	sp,et,8111d090 <vFailSendMsgMasterSyncMeb+0xc>
8111d08c:	003b68fa 	trap	3
8111d090:	dfc00115 	stw	ra,4(sp)
8111d094:	df000015 	stw	fp,0(sp)
8111d098:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendMsgMasterSyncMeb \n");
8111d09c:	d0a06217 	ldw	r2,-32376(gp)
8111d0a0:	100f883a 	mov	r7,r2
8111d0a4:	018006c4 	movi	r6,27
8111d0a8:	01400044 	movi	r5,1
8111d0ac:	01204574 	movhi	r4,33045
8111d0b0:	213f7804 	addi	r4,r4,-544
8111d0b4:	11216400 	call	81121640 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d0b8:	0001883a 	nop
8111d0bc:	e037883a 	mov	sp,fp
8111d0c0:	dfc00117 	ldw	ra,4(sp)
8111d0c4:	df000017 	ldw	fp,0(sp)
8111d0c8:	dec00204 	addi	sp,sp,8
8111d0cc:	f800283a 	ret

8111d0d0 <vFailSendMsgFeeCTRL>:

void vFailSendMsgFeeCTRL( void )
{
8111d0d0:	defffe04 	addi	sp,sp,-8
8111d0d4:	de00012e 	bgeu	sp,et,8111d0dc <vFailSendMsgFeeCTRL+0xc>
8111d0d8:	003b68fa 	trap	3
8111d0dc:	dfc00115 	stw	ra,4(sp)
8111d0e0:	df000015 	stw	fp,0(sp)
8111d0e4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendMsgFeeCTRL.  \n");
8111d0e8:	d0a06217 	ldw	r2,-32376(gp)
8111d0ec:	100f883a 	mov	r7,r2
8111d0f0:	018005c4 	movi	r6,23
8111d0f4:	01400044 	movi	r5,1
8111d0f8:	01204574 	movhi	r4,33045
8111d0fc:	213f7f04 	addi	r4,r4,-516
8111d100:	11216400 	call	81121640 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d104:	0001883a 	nop
8111d108:	e037883a 	mov	sp,fp
8111d10c:	dfc00117 	ldw	ra,4(sp)
8111d110:	df000017 	ldw	fp,0(sp)
8111d114:	dec00204 	addi	sp,sp,8
8111d118:	f800283a 	ret

8111d11c <vFailSendMsgDataCTRL>:

void vFailSendMsgDataCTRL( void )
{
8111d11c:	defffe04 	addi	sp,sp,-8
8111d120:	de00012e 	bgeu	sp,et,8111d128 <vFailSendMsgDataCTRL+0xc>
8111d124:	003b68fa 	trap	3
8111d128:	dfc00115 	stw	ra,4(sp)
8111d12c:	df000015 	stw	fp,0(sp)
8111d130:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendMsgDataCTRL.  \n");
8111d134:	d0a06217 	ldw	r2,-32376(gp)
8111d138:	100f883a 	mov	r7,r2
8111d13c:	01800604 	movi	r6,24
8111d140:	01400044 	movi	r5,1
8111d144:	01204574 	movhi	r4,33045
8111d148:	213f8504 	addi	r4,r4,-492
8111d14c:	11216400 	call	81121640 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d150:	0001883a 	nop
8111d154:	e037883a 	mov	sp,fp
8111d158:	dfc00117 	ldw	ra,4(sp)
8111d15c:	df000017 	ldw	fp,0(sp)
8111d160:	dec00204 	addi	sp,sp,8
8111d164:	f800283a 	ret

8111d168 <vFailFlushQueue>:

void vFailFlushQueue( void )
{
8111d168:	defffe04 	addi	sp,sp,-8
8111d16c:	de00012e 	bgeu	sp,et,8111d174 <vFailFlushQueue+0xc>
8111d170:	003b68fa 	trap	3
8111d174:	dfc00115 	stw	ra,4(sp)
8111d178:	df000015 	stw	fp,0(sp)
8111d17c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushQueue.  \n");
8111d180:	d0a06217 	ldw	r2,-32376(gp)
8111d184:	100f883a 	mov	r7,r2
8111d188:	01800744 	movi	r6,29
8111d18c:	01400044 	movi	r5,1
8111d190:	01204574 	movhi	r4,33045
8111d194:	213f8c04 	addi	r4,r4,-464
8111d198:	11216400 	call	81121640 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d19c:	0001883a 	nop
8111d1a0:	e037883a 	mov	sp,fp
8111d1a4:	dfc00117 	ldw	ra,4(sp)
8111d1a8:	df000017 	ldw	fp,0(sp)
8111d1ac:	dec00204 	addi	sp,sp,8
8111d1b0:	f800283a 	ret

8111d1b4 <vFailFlushQueueData>:

void vFailFlushQueueData( void )
{
8111d1b4:	defffe04 	addi	sp,sp,-8
8111d1b8:	de00012e 	bgeu	sp,et,8111d1c0 <vFailFlushQueueData+0xc>
8111d1bc:	003b68fa 	trap	3
8111d1c0:	dfc00115 	stw	ra,4(sp)
8111d1c4:	df000015 	stw	fp,0(sp)
8111d1c8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushQueueData.  \n");
8111d1cc:	d0a06217 	ldw	r2,-32376(gp)
8111d1d0:	100f883a 	mov	r7,r2
8111d1d4:	01800844 	movi	r6,33
8111d1d8:	01400044 	movi	r5,1
8111d1dc:	01204574 	movhi	r4,33045
8111d1e0:	213f9404 	addi	r4,r4,-432
8111d1e4:	11216400 	call	81121640 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d1e8:	0001883a 	nop
8111d1ec:	e037883a 	mov	sp,fp
8111d1f0:	dfc00117 	ldw	ra,4(sp)
8111d1f4:	df000017 	ldw	fp,0(sp)
8111d1f8:	dec00204 	addi	sp,sp,8
8111d1fc:	f800283a 	ret

8111d200 <vFailFlushMEBQueue>:


void vFailFlushMEBQueue( void )
{
8111d200:	defffe04 	addi	sp,sp,-8
8111d204:	de00012e 	bgeu	sp,et,8111d20c <vFailFlushMEBQueue+0xc>
8111d208:	003b68fa 	trap	3
8111d20c:	dfc00115 	stw	ra,4(sp)
8111d210:	df000015 	stw	fp,0(sp)
8111d214:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushMEBQueue.  \n");
8111d218:	d0a06217 	ldw	r2,-32376(gp)
8111d21c:	100f883a 	mov	r7,r2
8111d220:	01800804 	movi	r6,32
8111d224:	01400044 	movi	r5,1
8111d228:	01204574 	movhi	r4,33045
8111d22c:	213f9d04 	addi	r4,r4,-396
8111d230:	11216400 	call	81121640 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d234:	0001883a 	nop
8111d238:	e037883a 	mov	sp,fp
8111d23c:	dfc00117 	ldw	ra,4(sp)
8111d240:	df000017 	ldw	fp,0(sp)
8111d244:	dec00204 	addi	sp,sp,8
8111d248:	f800283a 	ret

8111d24c <vFailFlushNFEEQueue>:

void vFailFlushNFEEQueue( void )
{
8111d24c:	defffe04 	addi	sp,sp,-8
8111d250:	de00012e 	bgeu	sp,et,8111d258 <vFailFlushNFEEQueue+0xc>
8111d254:	003b68fa 	trap	3
8111d258:	dfc00115 	stw	ra,4(sp)
8111d25c:	df000015 	stw	fp,0(sp)
8111d260:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushNFEEQueue.  \n");
8111d264:	d0a06217 	ldw	r2,-32376(gp)
8111d268:	100f883a 	mov	r7,r2
8111d26c:	01800844 	movi	r6,33
8111d270:	01400044 	movi	r5,1
8111d274:	01204574 	movhi	r4,33045
8111d278:	213fa604 	addi	r4,r4,-360
8111d27c:	11216400 	call	81121640 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d280:	0001883a 	nop
8111d284:	e037883a 	mov	sp,fp
8111d288:	dfc00117 	ldw	ra,4(sp)
8111d28c:	df000017 	ldw	fp,0(sp)
8111d290:	dec00204 	addi	sp,sp,8
8111d294:	f800283a 	ret

8111d298 <vEvtChangeMebMode>:


#include "events_handler.h"


void vEvtChangeMebMode( void ) {
8111d298:	deffff04 	addi	sp,sp,-4
8111d29c:	de00012e 	bgeu	sp,et,8111d2a4 <vEvtChangeMebMode+0xc>
8111d2a0:	003b68fa 	trap	3
8111d2a4:	df000015 	stw	fp,0(sp)
8111d2a8:	d839883a 	mov	fp,sp

	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
8111d2ac:	0001883a 	nop
8111d2b0:	e037883a 	mov	sp,fp
8111d2b4:	df000017 	ldw	fp,0(sp)
8111d2b8:	dec00104 	addi	sp,sp,4
8111d2bc:	f800283a 	ret

8111d2c0 <vEvtChangeFeeControllerMode>:


void vEvtChangeFeeControllerMode( void ) {
8111d2c0:	deffff04 	addi	sp,sp,-4
8111d2c4:	de00012e 	bgeu	sp,et,8111d2cc <vEvtChangeFeeControllerMode+0xc>
8111d2c8:	003b68fa 	trap	3
8111d2cc:	df000015 	stw	fp,0(sp)
8111d2d0:	d839883a 	mov	fp,sp


	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
8111d2d4:	0001883a 	nop
8111d2d8:	e037883a 	mov	sp,fp
8111d2dc:	df000017 	ldw	fp,0(sp)
8111d2e0:	dec00104 	addi	sp,sp,4
8111d2e4:	f800283a 	ret

8111d2e8 <vEvtChangeDataControllerMode>:


void vEvtChangeDataControllerMode( void ) {
8111d2e8:	deffff04 	addi	sp,sp,-4
8111d2ec:	de00012e 	bgeu	sp,et,8111d2f4 <vEvtChangeDataControllerMode+0xc>
8111d2f0:	003b68fa 	trap	3
8111d2f4:	df000015 	stw	fp,0(sp)
8111d2f8:	d839883a 	mov	fp,sp


	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
8111d2fc:	0001883a 	nop
8111d300:	e037883a 	mov	sp,fp
8111d304:	df000017 	ldw	fp,0(sp)
8111d308:	dec00104 	addi	sp,sp,4
8111d30c:	f800283a 	ret

8111d310 <vNFeeNotInUse>:
 *      Author: Tiago-Low
 */

#include "fee.h"

void vNFeeNotInUse( TNFee *pxNfeeL, unsigned char ucIdNFEE ) {
8111d310:	defffd04 	addi	sp,sp,-12
8111d314:	de00012e 	bgeu	sp,et,8111d31c <vNFeeNotInUse+0xc>
8111d318:	003b68fa 	trap	3
8111d31c:	df000215 	stw	fp,8(sp)
8111d320:	df000204 	addi	fp,sp,8
8111d324:	e13ffe15 	stw	r4,-8(fp)
8111d328:	2805883a 	mov	r2,r5
8111d32c:	e0bfff05 	stb	r2,-4(fp)

    /* NFEE id [0..7] */
    pxNfeeL->ucId = ucIdNFEE;
8111d330:	e0bffe17 	ldw	r2,-8(fp)
8111d334:	e0ffff03 	ldbu	r3,-4(fp)
8111d338:	10c00005 	stb	r3,0(r2)
    pxNfeeL->xControl.bEnabled = FALSE;
8111d33c:	e0bffe17 	ldw	r2,-8(fp)
8111d340:	10002115 	stw	zero,132(r2)
    pxNfeeL->xControl.bUsingDMA = FALSE;
8111d344:	e0bffe17 	ldw	r2,-8(fp)
8111d348:	10002315 	stw	zero,140(r2)
}
8111d34c:	0001883a 	nop
8111d350:	e037883a 	mov	sp,fp
8111d354:	df000017 	ldw	fp,0(sp)
8111d358:	dec00104 	addi	sp,sp,4
8111d35c:	f800283a 	ret

8111d360 <vNFeeStructureInit>:


/* Initialize the structure of control of NFEE with the default Configurations */
void vNFeeStructureInit( TNFee *pxNfeeL, unsigned char ucIdNFEE ) {
8111d360:	defffb04 	addi	sp,sp,-20
8111d364:	de00012e 	bgeu	sp,et,8111d36c <vNFeeStructureInit+0xc>
8111d368:	003b68fa 	trap	3
8111d36c:	dfc00415 	stw	ra,16(sp)
8111d370:	df000315 	stw	fp,12(sp)
8111d374:	df000304 	addi	fp,sp,12
8111d378:	e13ffe15 	stw	r4,-8(fp)
8111d37c:	2805883a 	mov	r2,r5
8111d380:	e0bfff05 	stb	r2,-4(fp)
    unsigned char ucIL = 0;
8111d384:	e03ffd05 	stb	zero,-12(fp)

    /* NFEE id [0..5] */
    pxNfeeL->ucId = ucIdNFEE;
8111d388:	e0bffe17 	ldw	r2,-8(fp)
8111d38c:	e0ffff03 	ldbu	r3,-4(fp)
8111d390:	10c00005 	stb	r3,0(r2)

    /* Load the default values of the CCDs regarding pixels configuration */
    vCCDLoadDefaultValues(&pxNfeeL->xCcdInfo);
8111d394:	e0bffe17 	ldw	r2,-8(fp)
8111d398:	10802f04 	addi	r2,r2,188
8111d39c:	1009883a 	mov	r4,r2
8111d3a0:	11181c80 	call	811181c8 <vCCDLoadDefaultValues>

    /* Update the values of memory mapping for this FEE */
    vUpdateMemMapFEE(pxNfeeL);
8111d3a4:	e13ffe17 	ldw	r4,-8(fp)
8111d3a8:	111d5400 	call	8111d540 <vUpdateMemMapFEE>

    /* Initilizing control variables */
    pxNfeeL->xControl.bEnabled = TRUE;
8111d3ac:	e0bffe17 	ldw	r2,-8(fp)
8111d3b0:	00c00044 	movi	r3,1
8111d3b4:	10c02115 	stw	r3,132(r2)
    pxNfeeL->xControl.bUsingDMA = FALSE;
8111d3b8:	e0bffe17 	ldw	r2,-8(fp)
8111d3bc:	10002315 	stw	zero,140(r2)
    pxNfeeL->xControl.bChannelEnable = FALSE;
8111d3c0:	e0bffe17 	ldw	r2,-8(fp)
8111d3c4:	10002615 	stw	zero,152(r2)
    pxNfeeL->xControl.bSimulating = FALSE;
8111d3c8:	e0bffe17 	ldw	r2,-8(fp)
8111d3cc:	10002715 	stw	zero,156(r2)
    pxNfeeL->xControl.bWatingSync = FALSE;
8111d3d0:	e0bffe17 	ldw	r2,-8(fp)
8111d3d4:	10002815 	stw	zero,160(r2)
    pxNfeeL->xControl.bEchoing = FALSE;
8111d3d8:	e0bffe17 	ldw	r2,-8(fp)
8111d3dc:	10002515 	stw	zero,148(r2)
    pxNfeeL->xControl.bLogging = FALSE;
8111d3e0:	e0bffe17 	ldw	r2,-8(fp)
8111d3e4:	10002415 	stw	zero,144(r2)
    pxNfeeL->xControl.bDMALocked = FALSE;
8111d3e8:	e0bffe17 	ldw	r2,-8(fp)
8111d3ec:	10002215 	stw	zero,136(r2)
    /* The default side is left */
    pxNfeeL->xControl.eSide = sLeft;
8111d3f0:	e0bffe17 	ldw	r2,-8(fp)
8111d3f4:	10002e15 	stw	zero,184(r2)
    pxNfeeL->xControl.ucTimeCode = 0;
8111d3f8:	e0bffe17 	ldw	r2,-8(fp)
8111d3fc:	10002a05 	stb	zero,168(r2)
    

    /* The NFEE initialize in the Config mode by default */
    pxNfeeL->xControl.eMode = sFeeInit;
8111d400:	e0bffe17 	ldw	r2,-8(fp)
8111d404:	10002c15 	stw	zero,176(r2)
    pxNfeeL->xControl.eNextMode = sFeeInit;
8111d408:	e0bffe17 	ldw	r2,-8(fp)
8111d40c:	10002d15 	stw	zero,180(r2)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadNFEEDefsSDCard(); !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* Set the default redout order [ 0, 1, 2, 3 ] */
    for ( ucIL = 0; ucIL < 4; ucIL++) 
8111d410:	e03ffd05 	stb	zero,-12(fp)
8111d414:	00000906 	br	8111d43c <vNFeeStructureInit+0xdc>
        pxNfeeL->xControl.ucROutOrder[ucIL] = ucIL;
8111d418:	e0bffd03 	ldbu	r2,-12(fp)
8111d41c:	e0fffe17 	ldw	r3,-8(fp)
8111d420:	1885883a 	add	r2,r3,r2
8111d424:	10802a44 	addi	r2,r2,169
8111d428:	e0fffd03 	ldbu	r3,-12(fp)
8111d42c:	10c00005 	stb	r3,0(r2)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadNFEEDefsSDCard(); !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* Set the default redout order [ 0, 1, 2, 3 ] */
    for ( ucIL = 0; ucIL < 4; ucIL++) 
8111d430:	e0bffd03 	ldbu	r2,-12(fp)
8111d434:	10800044 	addi	r2,r2,1
8111d438:	e0bffd05 	stb	r2,-12(fp)
8111d43c:	e0bffd03 	ldbu	r2,-12(fp)
8111d440:	10800130 	cmpltui	r2,r2,4
8111d444:	103ff41e 	bne	r2,zero,8111d418 <__reset+0xfb0fd418>
        pxNfeeL->xControl.ucROutOrder[ucIL] = ucIL;

    /* Initialize the structs of the Channel, Double Buffer, RMAP and Data packet */
    if ( bCommInitCh(&pxNfeeL->xChannel, ucIdNFEE ) == FALSE ) {
8111d448:	e0bffe17 	ldw	r2,-8(fp)
8111d44c:	10803204 	addi	r2,r2,200
8111d450:	e0ffff03 	ldbu	r3,-4(fp)
8111d454:	180b883a 	mov	r5,r3
8111d458:	1009883a 	mov	r4,r2
8111d45c:	11046bc0 	call	811046bc <bCommInitCh>
8111d460:	1000091e 	bne	r2,zero,8111d488 <vNFeeStructureInit+0x128>
		#ifdef DEBUG_ON
			fprintf(fp, "\n CRITICAL! Can't Initialized SPW Channel %i \n", pxNfeeL->ucId);
8111d464:	d0e06217 	ldw	r3,-32376(gp)
8111d468:	e0bffe17 	ldw	r2,-8(fp)
8111d46c:	10800003 	ldbu	r2,0(r2)
8111d470:	10803fcc 	andi	r2,r2,255
8111d474:	100d883a 	mov	r6,r2
8111d478:	01604574 	movhi	r5,33045
8111d47c:	297faf04 	addi	r5,r5,-324
8111d480:	1809883a 	mov	r4,r3
8111d484:	1120fa40 	call	81120fa4 <fprintf>
		#endif
    }

    if ( bCommSetGlobalIrqEn( TRUE, ucIdNFEE ) == FALSE ) {
8111d488:	e0bfff03 	ldbu	r2,-4(fp)
8111d48c:	100b883a 	mov	r5,r2
8111d490:	01000044 	movi	r4,1
8111d494:	11045500 	call	81104550 <bCommSetGlobalIrqEn>
8111d498:	1000091e 	bne	r2,zero,8111d4c0 <vNFeeStructureInit+0x160>
		#ifdef DEBUG_ON
			fprintf(fp, "\n CRITICAL! Can't Enable global interrupt for the channel %i \n", pxNfeeL->ucId);
8111d49c:	d0e06217 	ldw	r3,-32376(gp)
8111d4a0:	e0bffe17 	ldw	r2,-8(fp)
8111d4a4:	10800003 	ldbu	r2,0(r2)
8111d4a8:	10803fcc 	andi	r2,r2,255
8111d4ac:	100d883a 	mov	r6,r2
8111d4b0:	01604574 	movhi	r5,33045
8111d4b4:	297fbb04 	addi	r5,r5,-276
8111d4b8:	1809883a 	mov	r4,r3
8111d4bc:	1120fa40 	call	81120fa4 <fprintf>
		#endif
    }

    bDpktGetPixelDelay(&pxNfeeL->xChannel.xDataPacket);
8111d4c0:	e0bffe17 	ldw	r2,-8(fp)
8111d4c4:	10803304 	addi	r2,r2,204
8111d4c8:	1009883a 	mov	r4,r2
8111d4cc:	1104da00 	call	81104da0 <bDpktGetPixelDelay>
    pxNfeeL->xChannel.xDataPacket.xDpktPixelDelay.usiAdcDelay = usiAdcPxDelayCalcPeriodNs(xDefaults.ulADCPixelDelay);
8111d4d0:	00a045b4 	movhi	r2,33046
8111d4d4:	1099c904 	addi	r2,r2,26404
8111d4d8:	10800b17 	ldw	r2,44(r2)
8111d4dc:	1009883a 	mov	r4,r2
8111d4e0:	110507c0 	call	8110507c <usiAdcPxDelayCalcPeriodNs>
8111d4e4:	1007883a 	mov	r3,r2
8111d4e8:	e0bffe17 	ldw	r2,-8(fp)
8111d4ec:	10c03a0d 	sth	r3,232(r2)
    pxNfeeL->xChannel.xDataPacket.xDpktPixelDelay.usiColumnDelay = 0 ;
8111d4f0:	e0bffe17 	ldw	r2,-8(fp)
8111d4f4:	1000398d 	sth	zero,230(r2)
    pxNfeeL->xChannel.xDataPacket.xDpktPixelDelay.usiLineDelay = usiLineTrDelayCalcPeriodNs(xDefaults.ulLineDelay);
8111d4f8:	00a045b4 	movhi	r2,33046
8111d4fc:	1099c904 	addi	r2,r2,26404
8111d500:	10800917 	ldw	r2,36(r2)
8111d504:	1009883a 	mov	r4,r2
8111d508:	11051080 	call	81105108 <usiLineTrDelayCalcPeriodNs>
8111d50c:	1007883a 	mov	r3,r2
8111d510:	e0bffe17 	ldw	r2,-8(fp)
8111d514:	10c0390d 	sth	r3,228(r2)
    bDpktSetPixelDelay(&pxNfeeL->xChannel.xDataPacket);
8111d518:	e0bffe17 	ldw	r2,-8(fp)
8111d51c:	10803304 	addi	r2,r2,204
8111d520:	1009883a 	mov	r4,r2
8111d524:	1104c580 	call	81104c58 <bDpktSetPixelDelay>


}
8111d528:	0001883a 	nop
8111d52c:	e037883a 	mov	sp,fp
8111d530:	dfc00117 	ldw	ra,4(sp)
8111d534:	df000017 	ldw	fp,0(sp)
8111d538:	dec00204 	addi	sp,sp,8
8111d53c:	f800283a 	ret

8111d540 <vUpdateMemMapFEE>:

/* Update the memory mapping for the FEE due to the CCD informations */
void vUpdateMemMapFEE( TNFee *pxNfeeL ) {
8111d540:	defff404 	addi	sp,sp,-48
8111d544:	de00012e 	bgeu	sp,et,8111d54c <vUpdateMemMapFEE+0xc>
8111d548:	003b68fa 	trap	3
8111d54c:	df000b15 	stw	fp,44(sp)
8111d550:	df000b04 	addi	fp,sp,44
8111d554:	e13fff15 	stw	r4,-4(fp)
    unsigned long ulTotalSizeL = 0; /* pixels */
8111d558:	e03ffa15 	stw	zero,-24(fp)
    unsigned long ulMemLinesL = 0; /* mem lines */
8111d55c:	e03ff515 	stw	zero,-44(fp)
    unsigned long ulTotalMemLinesL = 0;
8111d560:	e03ff615 	stw	zero,-40(fp)
    unsigned long ulMemLeftBytesL = 0; /* bytes */
8111d564:	e03ffb15 	stw	zero,-20(fp)
    unsigned long ulMemLeftLinesL = 0; /* mem lines */
8111d568:	e03ffc15 	stw	zero,-16(fp)
    unsigned long ulMaskMemLinesL = 0; /* mem lines */
8111d56c:	e03ff715 	stw	zero,-36(fp)
    unsigned char ucPixelsInLastBlockL = 0;
8111d570:	e03ff805 	stb	zero,-32(fp)
    unsigned char ucShiftsL = 0;
8111d574:	e03ffd05 	stb	zero,-12(fp)
    unsigned char ucIL = 0;
8111d578:	e03ff845 	stb	zero,-31(fp)
    unsigned long ulLastOffset = 0;
8111d57c:	e03ff915 	stw	zero,-28(fp)
    unsigned long ulStepHalfCCD = 0;
8111d580:	e03ffe15 	stw	zero,-8(fp)


    /* Size of the footprint of the CCD in the DDR memory */
    pxNfeeL->xMemMap.ulTotalBytes = ( OFFSET_STEP_FEE );
8111d584:	e17fff17 	ldw	r5,-4(fp)
8111d588:	01035a34 	movhi	r4,3432
8111d58c:	21348c04 	addi	r4,r4,-11728
8111d590:	29000215 	stw	r4,8(r5)

    /* Offset of the FEE in the DDR memory */
    pxNfeeL->xMemMap.ulOffsetRoot = OFFSET_STEP_FEE * pxNfeeL->ucId;
8111d594:	e13fff17 	ldw	r4,-4(fp)
8111d598:	21000003 	ldbu	r4,0(r4)
8111d59c:	21403fcc 	andi	r5,r4,255
8111d5a0:	01035a34 	movhi	r4,3432
8111d5a4:	21348c04 	addi	r4,r4,-11728
8111d5a8:	2909383a 	mul	r4,r5,r4
8111d5ac:	200b883a 	mov	r5,r4
8111d5b0:	e13fff17 	ldw	r4,-4(fp)
8111d5b4:	21400115 	stw	r5,4(r4)

    /* LUT Addrs */
    pxNfeeL->xMemMap.ulLUTAddr = LUT_INITIAL_ADDR + pxNfeeL->xMemMap.ulOffsetRoot;
8111d5b8:	e13fff17 	ldw	r4,-4(fp)
8111d5bc:	21400117 	ldw	r5,4(r4)
8111d5c0:	01033234 	movhi	r4,3272
8111d5c4:	21348c04 	addi	r4,r4,-11728
8111d5c8:	290b883a 	add	r5,r5,r4
8111d5cc:	e13fff17 	ldw	r4,-4(fp)
8111d5d0:	21400315 	stw	r5,12(r4)

    /* (HEIGHT + usiOLN)*(usiSPrescanN + usiSOverscanN + usiHalfWidth) */
    ulTotalSizeL =  ( pxNfeeL->xCcdInfo.usiHeight + pxNfeeL->xCcdInfo.usiOLN ) *
8111d5d4:	e13fff17 	ldw	r4,-4(fp)
8111d5d8:	2100310b 	ldhu	r4,196(r4)
8111d5dc:	217fffcc 	andi	r5,r4,65535
8111d5e0:	e13fff17 	ldw	r4,-4(fp)
8111d5e4:	2100300b 	ldhu	r4,192(r4)
8111d5e8:	213fffcc 	andi	r4,r4,65535
8111d5ec:	290b883a 	add	r5,r5,r4
                    ( pxNfeeL->xCcdInfo.usiHalfWidth + pxNfeeL->xCcdInfo.usiSOverscanN + pxNfeeL->xCcdInfo.usiSPrescanN );
8111d5f0:	e13fff17 	ldw	r4,-4(fp)
8111d5f4:	2100308b 	ldhu	r4,194(r4)
8111d5f8:	21bfffcc 	andi	r6,r4,65535
8111d5fc:	e13fff17 	ldw	r4,-4(fp)
8111d600:	21002f8b 	ldhu	r4,190(r4)
8111d604:	213fffcc 	andi	r4,r4,65535
8111d608:	310d883a 	add	r6,r6,r4
8111d60c:	e13fff17 	ldw	r4,-4(fp)
8111d610:	21002f0b 	ldhu	r4,188(r4)
8111d614:	213fffcc 	andi	r4,r4,65535
8111d618:	3109883a 	add	r4,r6,r4

    /* LUT Addrs */
    pxNfeeL->xMemMap.ulLUTAddr = LUT_INITIAL_ADDR + pxNfeeL->xMemMap.ulOffsetRoot;

    /* (HEIGHT + usiOLN)*(usiSPrescanN + usiSOverscanN + usiHalfWidth) */
    ulTotalSizeL =  ( pxNfeeL->xCcdInfo.usiHeight + pxNfeeL->xCcdInfo.usiOLN ) *
8111d61c:	2909383a 	mul	r4,r5,r4
8111d620:	e13ffa15 	stw	r4,-24(fp)
                    ( pxNfeeL->xCcdInfo.usiHalfWidth + pxNfeeL->xCcdInfo.usiSOverscanN + pxNfeeL->xCcdInfo.usiSPrescanN );

    /* Total size in Bytes of a half CCD */
    pxNfeeL->xMemMap.xCommon.usiTotalBytes = ulTotalSizeL * BYTES_PER_PIXEL;
8111d624:	e13ffa17 	ldw	r4,-24(fp)
8111d628:	2109883a 	add	r4,r4,r4
8111d62c:	200b883a 	mov	r5,r4
8111d630:	e13fff17 	ldw	r4,-4(fp)
8111d634:	21400515 	stw	r5,20(r4)

    /* Total of Memory lines (64 bits memory) */
    ulMemLinesL = (unsigned long) pxNfeeL->xMemMap.xCommon.usiTotalBytes / BYTES_PER_MEM_LINE;
8111d638:	e13fff17 	ldw	r4,-4(fp)
8111d63c:	21000517 	ldw	r4,20(r4)
8111d640:	2008d0fa 	srli	r4,r4,3
8111d644:	e13ff515 	stw	r4,-44(fp)
    ulMemLeftBytesL = pxNfeeL->xMemMap.xCommon.usiTotalBytes % BYTES_PER_MEM_LINE;   /* Word memory Alignment check: how much bytes left not align in the last word of the memory */
8111d648:	e13fff17 	ldw	r4,-4(fp)
8111d64c:	21000517 	ldw	r4,20(r4)
8111d650:	210001cc 	andi	r4,r4,7
8111d654:	e13ffb15 	stw	r4,-20(fp)
    if ( ulMemLeftBytesL > 0 ) {
8111d658:	e13ffb17 	ldw	r4,-20(fp)
8111d65c:	20001226 	beq	r4,zero,8111d6a8 <vUpdateMemMapFEE+0x168>
        ulMemLinesL = ulMemLinesL + 1;
8111d660:	e13ff517 	ldw	r4,-44(fp)
8111d664:	21000044 	addi	r4,r4,1
8111d668:	e13ff515 	stw	r4,-44(fp)
        pxNfeeL->xMemMap.xCommon.usiTotalBytes = pxNfeeL->xMemMap.xCommon.usiTotalBytes - ulMemLeftBytesL + BYTES_PER_MEM_LINE; /* Add a full line, after will be filled with zero padding */
8111d66c:	e13fff17 	ldw	r4,-4(fp)
8111d670:	21400517 	ldw	r5,20(r4)
8111d674:	e13ffb17 	ldw	r4,-20(fp)
8111d678:	2909c83a 	sub	r4,r5,r4
8111d67c:	21400204 	addi	r5,r4,8
8111d680:	e13fff17 	ldw	r4,-4(fp)
8111d684:	21400515 	stw	r5,20(r4)
        pxNfeeL->xMemMap.xCommon.ucPaddingBytes = BYTES_PER_MEM_LINE - ulMemLeftBytesL;
8111d688:	e13ffb17 	ldw	r4,-20(fp)
8111d68c:	200b883a 	mov	r5,r4
8111d690:	01000204 	movi	r4,8
8111d694:	2149c83a 	sub	r4,r4,r5
8111d698:	200b883a 	mov	r5,r4
8111d69c:	e13fff17 	ldw	r4,-4(fp)
8111d6a0:	21400605 	stb	r5,24(r4)
8111d6a4:	00000206 	br	8111d6b0 <vUpdateMemMapFEE+0x170>
    } else {
        pxNfeeL->xMemMap.xCommon.ucPaddingBytes = 0;
8111d6a8:	e13fff17 	ldw	r4,-4(fp)
8111d6ac:	20000605 	stb	zero,24(r4)
    }

    /* At this point we have mapping the pixel in the CCD and calculate the zero padding for the last WORD of the line memory of the half ccd */

    /* For every 16 mem line will be 1 mask mem line */
    ulMaskMemLinesL = (unsigned long) ulMemLinesL / BLOCK_MEM_SIZE;
8111d6b0:	e13ff517 	ldw	r4,-44(fp)
8111d6b4:	2008d13a 	srli	r4,r4,4
8111d6b8:	e13ff715 	stw	r4,-36(fp)
    ulMemLeftLinesL = ulMemLinesL % BLOCK_MEM_SIZE;
8111d6bc:	e13ff517 	ldw	r4,-44(fp)
8111d6c0:	210003cc 	andi	r4,r4,15
8111d6c4:	e13ffc15 	stw	r4,-16(fp)
    if ( ulMemLeftLinesL >= 1 ) {
8111d6c8:	e13ffc17 	ldw	r4,-16(fp)
8111d6cc:	20000b26 	beq	r4,zero,8111d6fc <vUpdateMemMapFEE+0x1bc>
        ulMaskMemLinesL = ulMaskMemLinesL + 1;
8111d6d0:	e13ff717 	ldw	r4,-36(fp)
8111d6d4:	21000044 	addi	r4,r4,1
8111d6d8:	e13ff715 	stw	r4,-36(fp)
        ulTotalMemLinesL = ( ulMemLinesL - ulMemLeftLinesL + BLOCK_MEM_SIZE ) + ulMaskMemLinesL; /* One extra 16 sized block, will be filled with zero padding the ret os spare lines */
8111d6dc:	e17ff517 	ldw	r5,-44(fp)
8111d6e0:	e13ffc17 	ldw	r4,-16(fp)
8111d6e4:	290bc83a 	sub	r5,r5,r4
8111d6e8:	e13ff717 	ldw	r4,-36(fp)
8111d6ec:	2909883a 	add	r4,r5,r4
8111d6f0:	21000404 	addi	r4,r4,16
8111d6f4:	e13ff615 	stw	r4,-40(fp)
8111d6f8:	00000406 	br	8111d70c <vUpdateMemMapFEE+0x1cc>
    } else {
        ulTotalMemLinesL = ulMemLinesL + ulMaskMemLinesL;
8111d6fc:	e17ff517 	ldw	r5,-44(fp)
8111d700:	e13ff717 	ldw	r4,-36(fp)
8111d704:	2909883a 	add	r4,r5,r4
8111d708:	e13ff615 	stw	r4,-40(fp)
    }

    pxNfeeL->xMemMap.xCommon.usiTotalBytes = ulTotalMemLinesL * BYTES_PER_MEM_LINE;
8111d70c:	e13ff617 	ldw	r4,-40(fp)
8111d710:	200a90fa 	slli	r5,r4,3
8111d714:	e13fff17 	ldw	r4,-4(fp)
8111d718:	21400515 	stw	r5,20(r4)


    /* Calculating how is the final mask with zero padding */
    if ( ulMemLeftBytesL >= 1 ) {
8111d71c:	e13ffb17 	ldw	r4,-20(fp)
8111d720:	20000926 	beq	r4,zero,8111d748 <vUpdateMemMapFEE+0x208>
        ucPixelsInLastBlockL = (unsigned char) (( ulMemLeftLinesL * PIXEL_PER_MEM_LINE ) + (unsigned int) ( ulMemLeftBytesL / BYTES_PER_PIXEL ));
8111d724:	e13ffc17 	ldw	r4,-16(fp)
8111d728:	2109883a 	add	r4,r4,r4
8111d72c:	2109883a 	add	r4,r4,r4
8111d730:	200b883a 	mov	r5,r4
8111d734:	e13ffb17 	ldw	r4,-20(fp)
8111d738:	2008d07a 	srli	r4,r4,1
8111d73c:	2909883a 	add	r4,r5,r4
8111d740:	e13ff805 	stb	r4,-32(fp)
8111d744:	00000406 	br	8111d758 <vUpdateMemMapFEE+0x218>
    } else {
        ucPixelsInLastBlockL = (unsigned char) ( ulMemLeftLinesL * PIXEL_PER_MEM_LINE );
8111d748:	e13ffc17 	ldw	r4,-16(fp)
8111d74c:	2109883a 	add	r4,r4,r4
8111d750:	2109883a 	add	r4,r4,r4
8111d754:	e13ff805 	stb	r4,-32(fp)
    }

    /* 16 * 4 = 64 - (number of pixels in the last block)) */
    ucShiftsL = ( BLOCK_MEM_SIZE * PIXEL_PER_MEM_LINE ) - ucPixelsInLastBlockL;
8111d758:	e13ff803 	ldbu	r4,-32(fp)
8111d75c:	01401004 	movi	r5,64
8111d760:	2909c83a 	sub	r4,r5,r4
8111d764:	e13ffd05 	stb	r4,-12(fp)

    /* WARNING: Verify the memory alocation (endianess) */
    pxNfeeL->xMemMap.xCommon.ucPaddingMask.ullWord = (unsigned long long)(0xFFFFFFFFFFFFFFFF >> ucShiftsL);
8111d768:	e13ffd03 	ldbu	r4,-12(fp)
8111d76c:	217ff804 	addi	r5,r4,-32
8111d770:	28000416 	blt	r5,zero,8111d784 <vUpdateMemMapFEE+0x244>
8111d774:	013fffc4 	movi	r4,-1
8111d778:	2144d83a 	srl	r2,r4,r5
8111d77c:	0007883a 	mov	r3,zero
8111d780:	00000a06 	br	8111d7ac <vUpdateMemMapFEE+0x26c>
8111d784:	017fffc4 	movi	r5,-1
8111d788:	280c907a 	slli	r6,r5,1
8111d78c:	014007c4 	movi	r5,31
8111d790:	290bc83a 	sub	r5,r5,r4
8111d794:	314a983a 	sll	r5,r6,r5
8111d798:	01bfffc4 	movi	r6,-1
8111d79c:	3104d83a 	srl	r2,r6,r4
8111d7a0:	2884b03a 	or	r2,r5,r2
8111d7a4:	017fffc4 	movi	r5,-1
8111d7a8:	2906d83a 	srl	r3,r5,r4
8111d7ac:	e13fff17 	ldw	r4,-4(fp)
8111d7b0:	20800715 	stw	r2,28(r4)
8111d7b4:	20c00815 	stw	r3,32(r4)
    //pxNfeeL->xMemMap.xCommon.ucPaddingMask.ullWord = (unsigned long long)(0xFFFFFFFFFFFFFFFF << ucShiftsL);

    /* Number of block is te same as the number of line masks in the memory */
    pxNfeeL->xMemMap.xCommon.usiNTotalBlocks = ulMaskMemLinesL;
8111d7b8:	e0bfff17 	ldw	r2,-4(fp)
8111d7bc:	e0fff717 	ldw	r3,-36(fp)
8111d7c0:	10c00415 	stw	r3,16(r2)

    /* Set the addr for every CCD of the FEE, left and right sides */
    ulLastOffset = pxNfeeL->xMemMap.ulOffsetRoot + RESERVED_FEE_X + RESERVED_HALF_CCD_X;
8111d7c4:	e0bfff17 	ldw	r2,-4(fp)
8111d7c8:	10c00117 	ldw	r3,4(r2)
8111d7cc:	008004b4 	movhi	r2,18
8111d7d0:	10a40004 	addi	r2,r2,-28672
8111d7d4:	1885883a 	add	r2,r3,r2
8111d7d8:	e0bff915 	stw	r2,-28(fp)
    ulStepHalfCCD = RESERVED_HALF_CCD_X + pxNfeeL->xMemMap.xCommon.usiTotalBytes;
8111d7dc:	e0bfff17 	ldw	r2,-4(fp)
8111d7e0:	10c00517 	ldw	r3,20(r2)
8111d7e4:	008000b4 	movhi	r2,2
8111d7e8:	10a40004 	addi	r2,r2,-28672
8111d7ec:	1885883a 	add	r2,r3,r2
8111d7f0:	e0bffe15 	stw	r2,-8(fp)
    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8111d7f4:	e03ff845 	stb	zero,-31(fp)
8111d7f8:	00001906 	br	8111d860 <vUpdateMemMapFEE+0x320>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulOffsetAddr = ulLastOffset;
8111d7fc:	e0bff843 	ldbu	r2,-31(fp)
8111d800:	e0ffff17 	ldw	r3,-4(fp)
8111d804:	10800624 	muli	r2,r2,24
8111d808:	1885883a 	add	r2,r3,r2
8111d80c:	10800904 	addi	r2,r2,36
8111d810:	e0fff917 	ldw	r3,-28(fp)
8111d814:	10c00015 	stw	r3,0(r2)
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
8111d818:	e0fff917 	ldw	r3,-28(fp)
8111d81c:	e0bffe17 	ldw	r2,-8(fp)
8111d820:	1885883a 	add	r2,r3,r2
8111d824:	e0bff915 	stw	r2,-28(fp)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulOffsetAddr = ulLastOffset; 
8111d828:	e0bff843 	ldbu	r2,-31(fp)
8111d82c:	e0ffff17 	ldw	r3,-4(fp)
8111d830:	10800624 	muli	r2,r2,24
8111d834:	1885883a 	add	r2,r3,r2
8111d838:	10800c04 	addi	r2,r2,48
8111d83c:	e0fff917 	ldw	r3,-28(fp)
8111d840:	10c00015 	stw	r3,0(r2)
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
8111d844:	e0fff917 	ldw	r3,-28(fp)
8111d848:	e0bffe17 	ldw	r2,-8(fp)
8111d84c:	1885883a 	add	r2,r3,r2
8111d850:	e0bff915 	stw	r2,-28(fp)
    pxNfeeL->xMemMap.xCommon.usiNTotalBlocks = ulMaskMemLinesL;

    /* Set the addr for every CCD of the FEE, left and right sides */
    ulLastOffset = pxNfeeL->xMemMap.ulOffsetRoot + RESERVED_FEE_X + RESERVED_HALF_CCD_X;
    ulStepHalfCCD = RESERVED_HALF_CCD_X + pxNfeeL->xMemMap.xCommon.usiTotalBytes;
    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8111d854:	e0bff843 	ldbu	r2,-31(fp)
8111d858:	10800044 	addi	r2,r2,1
8111d85c:	e0bff845 	stb	r2,-31(fp)
8111d860:	e0bff843 	ldbu	r2,-31(fp)
8111d864:	10800130 	cmpltui	r2,r2,4
8111d868:	103fe41e 	bne	r2,zero,8111d7fc <__reset+0xfb0fd7fc>
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulOffsetAddr = ulLastOffset; 
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
    }

}
8111d86c:	0001883a 	nop
8111d870:	e037883a 	mov	sp,fp
8111d874:	df000017 	ldw	fp,0(sp)
8111d878:	dec00104 	addi	sp,sp,4
8111d87c:	f800283a 	ret

8111d880 <vResetMemCCDFEE>:

/* Update the memory mapping for the FEE due to the CCD informations */
void vResetMemCCDFEE( TNFee *pxNfeeL ) {
8111d880:	defffd04 	addi	sp,sp,-12
8111d884:	de00012e 	bgeu	sp,et,8111d88c <vResetMemCCDFEE+0xc>
8111d888:	003b68fa 	trap	3
8111d88c:	df000215 	stw	fp,8(sp)
8111d890:	df000204 	addi	fp,sp,8
8111d894:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucIL = 0;
8111d898:	e03ffe05 	stb	zero,-8(fp)

    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8111d89c:	e03ffe05 	stb	zero,-8(fp)
8111d8a0:	00001b06 	br	8111d910 <vResetMemCCDFEE+0x90>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulAddrI = 0;
8111d8a4:	e0bffe03 	ldbu	r2,-8(fp)
8111d8a8:	e0ffff17 	ldw	r3,-4(fp)
8111d8ac:	10800624 	muli	r2,r2,24
8111d8b0:	1885883a 	add	r2,r3,r2
8111d8b4:	10800b04 	addi	r2,r2,44
8111d8b8:	10000015 	stw	zero,0(r2)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulBlockI = 0;
8111d8bc:	e0bffe03 	ldbu	r2,-8(fp)
8111d8c0:	e0ffff17 	ldw	r3,-4(fp)
8111d8c4:	10800624 	muli	r2,r2,24
8111d8c8:	1885883a 	add	r2,r3,r2
8111d8cc:	10800a04 	addi	r2,r2,40
8111d8d0:	10000015 	stw	zero,0(r2)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulAddrI = 0;
8111d8d4:	e0bffe03 	ldbu	r2,-8(fp)
8111d8d8:	e0ffff17 	ldw	r3,-4(fp)
8111d8dc:	10800624 	muli	r2,r2,24
8111d8e0:	1885883a 	add	r2,r3,r2
8111d8e4:	10800e04 	addi	r2,r2,56
8111d8e8:	10000015 	stw	zero,0(r2)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulBlockI = 0;
8111d8ec:	e0bffe03 	ldbu	r2,-8(fp)
8111d8f0:	e0ffff17 	ldw	r3,-4(fp)
8111d8f4:	10800624 	muli	r2,r2,24
8111d8f8:	1885883a 	add	r2,r3,r2
8111d8fc:	10800d04 	addi	r2,r2,52
8111d900:	10000015 	stw	zero,0(r2)

/* Update the memory mapping for the FEE due to the CCD informations */
void vResetMemCCDFEE( TNFee *pxNfeeL ) {
	unsigned char ucIL = 0;

    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8111d904:	e0bffe03 	ldbu	r2,-8(fp)
8111d908:	10800044 	addi	r2,r2,1
8111d90c:	e0bffe05 	stb	r2,-8(fp)
8111d910:	e0bffe03 	ldbu	r2,-8(fp)
8111d914:	10800130 	cmpltui	r2,r2,4
8111d918:	103fe21e 	bne	r2,zero,8111d8a4 <__reset+0xfb0fd8a4>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulAddrI = 0;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulBlockI = 0;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulAddrI = 0;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulBlockI = 0;
    }
}
8111d91c:	0001883a 	nop
8111d920:	e037883a 	mov	sp,fp
8111d924:	df000017 	ldw	fp,0(sp)
8111d928:	dec00104 	addi	sp,sp,4
8111d92c:	f800283a 	ret

8111d930 <vFeeSpwRMAPLoadDefault>:



/* Load the default configuration of the SPW/RMAP */
void vFeeSpwRMAPLoadDefault( TNFee *pxNfeeL ) {
8111d930:	defffe04 	addi	sp,sp,-8
8111d934:	de00012e 	bgeu	sp,et,8111d93c <vFeeSpwRMAPLoadDefault+0xc>
8111d938:	003b68fa 	trap	3
8111d93c:	df000115 	stw	fp,4(sp)
8111d940:	df000104 	addi	fp,sp,4
8111d944:	e13fff15 	stw	r4,-4(fp)
    //bGetSpwRmapSDCard();
    //todo: For now is hardcoded
    //todo: Verificar qual a estrutura usar para as configuraes
}
8111d948:	0001883a 	nop
8111d94c:	e037883a 	mov	sp,fp
8111d950:	df000017 	ldw	fp,0(sp)
8111d954:	dec00104 	addi	sp,sp,4
8111d958:	f800283a 	ret

8111d95c <vFeeSpwRMAPChangeConfig>:

/* Only in NFEE_CONFIG */
/* Change the active configuration of the SPW/RMAP */
void vFeeSpwRMAPChangeConfig( TNFee *pxNfeeL ) {
8111d95c:	defffe04 	addi	sp,sp,-8
8111d960:	de00012e 	bgeu	sp,et,8111d968 <vFeeSpwRMAPChangeConfig+0xc>
8111d964:	003b68fa 	trap	3
8111d968:	df000115 	stw	fp,4(sp)
8111d96c:	df000104 	addi	fp,sp,4
8111d970:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar qual a estrutura usar para as configuraes
}
8111d974:	0001883a 	nop
8111d978:	e037883a 	mov	sp,fp
8111d97c:	df000017 	ldw	fp,0(sp)
8111d980:	dec00104 	addi	sp,sp,4
8111d984:	f800283a 	ret

8111d988 <vFeeSpwRMAPChangeDefault>:

/* Only in NFEE_CONFIG */
/* Change the default configuration of the SPW/RMAP */
void vFeeSpwRMAPChangeDefault( TNFee *pxNfeeL ) {
8111d988:	defffe04 	addi	sp,sp,-8
8111d98c:	de00012e 	bgeu	sp,et,8111d994 <vFeeSpwRMAPChangeDefault+0xc>
8111d990:	003b68fa 	trap	3
8111d994:	df000115 	stw	fp,4(sp)
8111d998:	df000104 	addi	fp,sp,4
8111d99c:	e13fff15 	stw	r4,-4(fp)
    //bSaveSpwRmapSDCard();
    //todo: Verificar qual a estrutura usar para as configuraes, enviar o numero do FEE tbm
}
8111d9a0:	0001883a 	nop
8111d9a4:	e037883a 	mov	sp,fp
8111d9a8:	df000017 	ldw	fp,0(sp)
8111d9ac:	dec00104 	addi	sp,sp,4
8111d9b0:	f800283a 	ret

8111d9b4 <cFeeSpwChannelEnable>:

/* Any mode */
/* Enable SPW channel for the FEE */
void cFeeSpwChannelEnable( TNFee *pxNfeeL ) {
8111d9b4:	defffe04 	addi	sp,sp,-8
8111d9b8:	de00012e 	bgeu	sp,et,8111d9c0 <cFeeSpwChannelEnable+0xc>
8111d9bc:	003b68fa 	trap	3
8111d9c0:	df000115 	stw	fp,4(sp)
8111d9c4:	df000104 	addi	fp,sp,4
8111d9c8:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar com o Frana
}
8111d9cc:	0001883a 	nop
8111d9d0:	e037883a 	mov	sp,fp
8111d9d4:	df000017 	ldw	fp,0(sp)
8111d9d8:	dec00104 	addi	sp,sp,4
8111d9dc:	f800283a 	ret

8111d9e0 <cFeeSpwChannelDisable>:

/* Any mode */
/* Disable SPW channel for the FEE */
void cFeeSpwChannelDisable( TNFee *pxNfeeL ) {
8111d9e0:	defffe04 	addi	sp,sp,-8
8111d9e4:	de00012e 	bgeu	sp,et,8111d9ec <cFeeSpwChannelDisable+0xc>
8111d9e8:	003b68fa 	trap	3
8111d9ec:	df000115 	stw	fp,4(sp)
8111d9f0:	df000104 	addi	fp,sp,4
8111d9f4:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar com o Frana
}
8111d9f8:	0001883a 	nop
8111d9fc:	e037883a 	mov	sp,fp
8111da00:	df000017 	ldw	fp,0(sp)
8111da04:	dec00104 	addi	sp,sp,4
8111da08:	f800283a 	ret

8111da0c <cFeeRMAPDump>:

/* Any mode */
/* Dump and send using PUS the RMAP Configuration areas [NFEESIM-UR-699] */
void cFeeRMAPDump( TNFee *pxNfeeL ) {
8111da0c:	defffe04 	addi	sp,sp,-8
8111da10:	de00012e 	bgeu	sp,et,8111da18 <cFeeRMAPDump+0xc>
8111da14:	003b68fa 	trap	3
8111da18:	df000115 	stw	fp,4(sp)
8111da1c:	df000104 	addi	fp,sp,4
8111da20:	e13fff15 	stw	r4,-4(fp)

    //todo: ler as areas de memoria do RMAP e enviar via ethernet

}
8111da24:	0001883a 	nop
8111da28:	e037883a 	mov	sp,fp
8111da2c:	df000017 	ldw	fp,0(sp)
8111da30:	dec00104 	addi	sp,sp,4
8111da34:	f800283a 	ret

8111da38 <cFeeRMAPEchoingEnable>:

/* Any mode */
/* Allow the user to activate the echo mode for RMAP [NFEESIM-UR-588]  */
void cFeeRMAPEchoingEnable( TNFee *pxNfeeL ) {
8111da38:	defffe04 	addi	sp,sp,-8
8111da3c:	de00012e 	bgeu	sp,et,8111da44 <cFeeRMAPEchoingEnable+0xc>
8111da40:	003b68fa 	trap	3
8111da44:	df000115 	stw	fp,4(sp)
8111da48:	df000104 	addi	fp,sp,4
8111da4c:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bEchoing = TRUE;
8111da50:	e0bfff17 	ldw	r2,-4(fp)
8111da54:	00c00044 	movi	r3,1
8111da58:	10c02515 	stw	r3,148(r2)
}
8111da5c:	0001883a 	nop
8111da60:	e037883a 	mov	sp,fp
8111da64:	df000017 	ldw	fp,0(sp)
8111da68:	dec00104 	addi	sp,sp,4
8111da6c:	f800283a 	ret

8111da70 <cFeeRMAPEchoingDisable>:

/* Any mode */
/* Allow the user to disable the echo mode for RMAP [NFEESIM-UR-589]  */
void cFeeRMAPEchoingDisable( TNFee *pxNfeeL ) {
8111da70:	defffe04 	addi	sp,sp,-8
8111da74:	de00012e 	bgeu	sp,et,8111da7c <cFeeRMAPEchoingDisable+0xc>
8111da78:	003b68fa 	trap	3
8111da7c:	df000115 	stw	fp,4(sp)
8111da80:	df000104 	addi	fp,sp,4
8111da84:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bEchoing = FALSE;
8111da88:	e0bfff17 	ldw	r2,-4(fp)
8111da8c:	10002515 	stw	zero,148(r2)
}
8111da90:	0001883a 	nop
8111da94:	e037883a 	mov	sp,fp
8111da98:	df000017 	ldw	fp,0(sp)
8111da9c:	dec00104 	addi	sp,sp,4
8111daa0:	f800283a 	ret

8111daa4 <cFeeRMAPLogEnable>:

/* Any mode */
/* Allow the user to activate the log of RMAP [NFEESIM-UR-588]  */
void cFeeRMAPLogEnable( TNFee *pxNfeeL ) {
8111daa4:	defffe04 	addi	sp,sp,-8
8111daa8:	de00012e 	bgeu	sp,et,8111dab0 <cFeeRMAPLogEnable+0xc>
8111daac:	003b68fa 	trap	3
8111dab0:	df000115 	stw	fp,4(sp)
8111dab4:	df000104 	addi	fp,sp,4
8111dab8:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bLogging = TRUE;
8111dabc:	e0bfff17 	ldw	r2,-4(fp)
8111dac0:	00c00044 	movi	r3,1
8111dac4:	10c02415 	stw	r3,144(r2)
}
8111dac8:	0001883a 	nop
8111dacc:	e037883a 	mov	sp,fp
8111dad0:	df000017 	ldw	fp,0(sp)
8111dad4:	dec00104 	addi	sp,sp,4
8111dad8:	f800283a 	ret

8111dadc <cFeeRMAPLogDisable>:

/* Any mode */
/* Allow the user to disable the log of RMAP [NFEESIM-UR-589]  */
void cFeeRMAPLogDisable( TNFee *pxNfeeL ) {
8111dadc:	defffe04 	addi	sp,sp,-8
8111dae0:	de00012e 	bgeu	sp,et,8111dae8 <cFeeRMAPLogDisable+0xc>
8111dae4:	003b68fa 	trap	3
8111dae8:	df000115 	stw	fp,4(sp)
8111daec:	df000104 	addi	fp,sp,4
8111daf0:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bLogging = FALSE;
8111daf4:	e0bfff17 	ldw	r2,-4(fp)
8111daf8:	10002415 	stw	zero,144(r2)
}
8111dafc:	0001883a 	nop
8111db00:	e037883a 	mov	sp,fp
8111db04:	df000017 	ldw	fp,0(sp)
8111db08:	dec00104 	addi	sp,sp,4
8111db0c:	f800283a 	ret

8111db10 <vNFeeControlInit>:
 */


#include "fee_controller.h"

void vNFeeControlInit( TNFee_Control *xFeeControlL ) {
8111db10:	defffc04 	addi	sp,sp,-16
8111db14:	de00012e 	bgeu	sp,et,8111db1c <vNFeeControlInit+0xc>
8111db18:	003b68fa 	trap	3
8111db1c:	dfc00315 	stw	ra,12(sp)
8111db20:	df000215 	stw	fp,8(sp)
8111db24:	df000204 	addi	fp,sp,8
8111db28:	e13fff15 	stw	r4,-4(fp)
    unsigned char ucIL = 0;
8111db2c:	e03ffe05 	stb	zero,-8(fp)
    
    /* Reset TimeCode */
    vResetTimeCode( xFeeControlL );
8111db30:	e13fff17 	ldw	r4,-4(fp)
8111db34:	111dc5c0 	call	8111dc5c <vResetTimeCode>
    /* Load Default Id for NFEE master */
    vLoadDefaultIdNFEEMaster( xFeeControlL );
8111db38:	e13fff17 	ldw	r4,-4(fp)
8111db3c:	111dc900 	call	8111dc90 <vLoadDefaultIdNFEEMaster>

    xFeeControlL->sMode = sMebInit;
8111db40:	e0bfff17 	ldw	r2,-4(fp)
8111db44:	10009a15 	stw	zero,616(r2)

    /* Calculate the */
    for ( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ) {
8111db48:	e03ffe05 	stb	zero,-8(fp)
8111db4c:	00002b06 	br	8111dbfc <vNFeeControlInit+0xec>
        vNFeeStructureInit( &xFeeControlL->xNfee[ ucIL ], ucIL);
8111db50:	e0bffe03 	ldbu	r2,-8(fp)
8111db54:	10809624 	muli	r2,r2,600
8111db58:	e0ffff17 	ldw	r3,-4(fp)
8111db5c:	1885883a 	add	r2,r3,r2
8111db60:	e0fffe03 	ldbu	r3,-8(fp)
8111db64:	180b883a 	mov	r5,r3
8111db68:	1009883a 	mov	r4,r2
8111db6c:	111d3600 	call	8111d360 <vNFeeStructureInit>
        xFeeControlL->pbEnabledNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bEnabled;
8111db70:	e0bffe03 	ldbu	r2,-8(fp)
8111db74:	e0fffe03 	ldbu	r3,-8(fp)
8111db78:	18c09624 	muli	r3,r3,600
8111db7c:	18c02104 	addi	r3,r3,132
8111db80:	e13fff17 	ldw	r4,-4(fp)
8111db84:	20c7883a 	add	r3,r4,r3
8111db88:	e13fff17 	ldw	r4,-4(fp)
8111db8c:	108025c4 	addi	r2,r2,151
8111db90:	1085883a 	add	r2,r2,r2
8111db94:	1085883a 	add	r2,r2,r2
8111db98:	2085883a 	add	r2,r4,r2
8111db9c:	10c00015 	stw	r3,0(r2)
        xFeeControlL->pbSimulatingNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bSimulating;
8111dba0:	e0bffe03 	ldbu	r2,-8(fp)
8111dba4:	e0fffe03 	ldbu	r3,-8(fp)
8111dba8:	18c09624 	muli	r3,r3,600
8111dbac:	18c02704 	addi	r3,r3,156
8111dbb0:	e13fff17 	ldw	r4,-4(fp)
8111dbb4:	20c7883a 	add	r3,r4,r3
8111dbb8:	e13fff17 	ldw	r4,-4(fp)
8111dbbc:	10802604 	addi	r2,r2,152
8111dbc0:	1085883a 	add	r2,r2,r2
8111dbc4:	1085883a 	add	r2,r2,r2
8111dbc8:	2085883a 	add	r2,r4,r2
8111dbcc:	10c00015 	stw	r3,0(r2)
        xFeeControlL->xNfee[ ucIL ].xControl.pActualMem = xFeeControlL->pActualMem;
8111dbd0:	e0bffe03 	ldbu	r2,-8(fp)
8111dbd4:	e0ffff17 	ldw	r3,-4(fp)
8111dbd8:	18c09617 	ldw	r3,600(r3)
8111dbdc:	e13fff17 	ldw	r4,-4(fp)
8111dbe0:	10809624 	muli	r2,r2,600
8111dbe4:	2085883a 	add	r2,r4,r2
8111dbe8:	10802904 	addi	r2,r2,164
8111dbec:	10c00015 	stw	r3,0(r2)
    vLoadDefaultIdNFEEMaster( xFeeControlL );

    xFeeControlL->sMode = sMebInit;

    /* Calculate the */
    for ( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ) {
8111dbf0:	e0bffe03 	ldbu	r2,-8(fp)
8111dbf4:	10800044 	addi	r2,r2,1
8111dbf8:	e0bffe05 	stb	r2,-8(fp)
8111dbfc:	e0bffe03 	ldbu	r2,-8(fp)
8111dc00:	103fd326 	beq	r2,zero,8111db50 <__reset+0xfb0fdb50>
        xFeeControlL->pbEnabledNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bEnabled;
        xFeeControlL->pbSimulatingNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bSimulating;
        xFeeControlL->xNfee[ ucIL ].xControl.pActualMem = xFeeControlL->pActualMem;
    }

}
8111dc04:	0001883a 	nop
8111dc08:	e037883a 	mov	sp,fp
8111dc0c:	dfc00117 	ldw	ra,4(sp)
8111dc10:	df000017 	ldw	fp,0(sp)
8111dc14:	dec00204 	addi	sp,sp,8
8111dc18:	f800283a 	ret

8111dc1c <vSetTimeCode>:

/* Any mode */
/* Set the time code of the Simucam */
void vSetTimeCode( TNFee_Control *xFeeControlL, unsigned char ucTime ) {
8111dc1c:	defffd04 	addi	sp,sp,-12
8111dc20:	de00012e 	bgeu	sp,et,8111dc28 <vSetTimeCode+0xc>
8111dc24:	003b68fa 	trap	3
8111dc28:	df000215 	stw	fp,8(sp)
8111dc2c:	df000204 	addi	fp,sp,8
8111dc30:	e13ffe15 	stw	r4,-8(fp)
8111dc34:	2805883a 	mov	r2,r5
8111dc38:	e0bfff05 	stb	r2,-4(fp)
    xFeeControlL->ucTimeCode = ucTime;
8111dc3c:	e0bffe17 	ldw	r2,-8(fp)
8111dc40:	e0ffff03 	ldbu	r3,-4(fp)
8111dc44:	10c09905 	stb	r3,612(r2)
}
8111dc48:	0001883a 	nop
8111dc4c:	e037883a 	mov	sp,fp
8111dc50:	df000017 	ldw	fp,0(sp)
8111dc54:	dec00104 	addi	sp,sp,4
8111dc58:	f800283a 	ret

8111dc5c <vResetTimeCode>:

/* Reset the time code of the Simucam */
void vResetTimeCode( TNFee_Control *xFeeControlL ) {
8111dc5c:	defffe04 	addi	sp,sp,-8
8111dc60:	de00012e 	bgeu	sp,et,8111dc68 <vResetTimeCode+0xc>
8111dc64:	003b68fa 	trap	3
8111dc68:	df000115 	stw	fp,4(sp)
8111dc6c:	df000104 	addi	fp,sp,4
8111dc70:	e13fff15 	stw	r4,-4(fp)
    xFeeControlL->ucTimeCode = 0;
8111dc74:	e0bfff17 	ldw	r2,-4(fp)
8111dc78:	10009905 	stb	zero,612(r2)
}
8111dc7c:	0001883a 	nop
8111dc80:	e037883a 	mov	sp,fp
8111dc84:	df000017 	ldw	fp,0(sp)
8111dc88:	dec00104 	addi	sp,sp,4
8111dc8c:	f800283a 	ret

8111dc90 <vLoadDefaultIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Load Default Config for IdNFEEMaster */
void vLoadDefaultIdNFEEMaster( TNFee_Control *xFeeControlL ) {
8111dc90:	defffe04 	addi	sp,sp,-8
8111dc94:	de00012e 	bgeu	sp,et,8111dc9c <vLoadDefaultIdNFEEMaster+0xc>
8111dc98:	003b68fa 	trap	3
8111dc9c:	df000115 	stw	fp,4(sp)
8111dca0:	df000104 	addi	fp,sp,4
8111dca4:	e13fff15 	stw	r4,-4(fp)
    //bGetIdNFEEMasterSDCard();
    //todo: For now is hardcoded
    xFeeControlL->ucIdNFEEMaster = 0;
8111dca8:	e0bfff17 	ldw	r2,-4(fp)
8111dcac:	10009945 	stb	zero,613(r2)
}
8111dcb0:	0001883a 	nop
8111dcb4:	e037883a 	mov	sp,fp
8111dcb8:	df000017 	ldw	fp,0(sp)
8111dcbc:	dec00104 	addi	sp,sp,4
8111dcc0:	f800283a 	ret

8111dcc4 <vChangeIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Change the Config for IdNFEEMaster*/
void vChangeIdNFEEMaster( TNFee_Control *xFeeControlL, unsigned char ucIdMaster ) {
8111dcc4:	defffd04 	addi	sp,sp,-12
8111dcc8:	de00012e 	bgeu	sp,et,8111dcd0 <vChangeIdNFEEMaster+0xc>
8111dccc:	003b68fa 	trap	3
8111dcd0:	df000215 	stw	fp,8(sp)
8111dcd4:	df000204 	addi	fp,sp,8
8111dcd8:	e13ffe15 	stw	r4,-8(fp)
8111dcdc:	2805883a 	mov	r2,r5
8111dce0:	e0bfff05 	stb	r2,-4(fp)
    xFeeControlL->ucIdNFEEMaster = ucIdMaster;
8111dce4:	e0bffe17 	ldw	r2,-8(fp)
8111dce8:	e0ffff03 	ldbu	r3,-4(fp)
8111dcec:	10c09945 	stb	r3,613(r2)
}
8111dcf0:	0001883a 	nop
8111dcf4:	e037883a 	mov	sp,fp
8111dcf8:	df000017 	ldw	fp,0(sp)
8111dcfc:	dec00104 	addi	sp,sp,4
8111dd00:	f800283a 	ret

8111dd04 <vChangeDefaultIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Change the Default Config for IdNFEEMaster */
void vChangeDefaultIdNFEEMaster( TNFee_Control *xFeeControlL, unsigned char ucIdMaster ) {
8111dd04:	defffd04 	addi	sp,sp,-12
8111dd08:	de00012e 	bgeu	sp,et,8111dd10 <vChangeDefaultIdNFEEMaster+0xc>
8111dd0c:	003b68fa 	trap	3
8111dd10:	df000215 	stw	fp,8(sp)
8111dd14:	df000204 	addi	fp,sp,8
8111dd18:	e13ffe15 	stw	r4,-8(fp)
8111dd1c:	2805883a 	mov	r2,r5
8111dd20:	e0bfff05 	stb	r2,-4(fp)
    //bSaveIdNFEEMasterSDCard(ucIdMaster);
}
8111dd24:	0001883a 	nop
8111dd28:	e037883a 	mov	sp,fp
8111dd2c:	df000017 	ldw	fp,0(sp)
8111dd30:	dec00104 	addi	sp,sp,4
8111dd34:	f800283a 	ret

8111dd38 <vInitSimucamBasicHW>:

#include "initialization_simucam.h"


void vInitSimucamBasicHW(void)
{
8111dd38:	defffe04 	addi	sp,sp,-8
8111dd3c:	de00012e 	bgeu	sp,et,8111dd44 <vInitSimucamBasicHW+0xc>
8111dd40:	003b68fa 	trap	3
8111dd44:	dfc00115 	stw	ra,4(sp)
8111dd48:	df000015 	stw	fp,0(sp)
8111dd4c:	d839883a 	mov	fp,sp

	/* Turn Off all LEDs */
	bSetBoardLeds(LEDS_OFF, LEDS_BOARD_ALL_MASK);
8111dd50:	01403fc4 	movi	r5,255
8111dd54:	0009883a 	mov	r4,zero
8111dd58:	110b2740 	call	8110b274 <bSetBoardLeds>
	bSetPainelLeds(LEDS_OFF, LEDS_PAINEL_ALL_MASK);
8111dd5c:	01400834 	movhi	r5,32
8111dd60:	297fffc4 	addi	r5,r5,-1
8111dd64:	0009883a 	mov	r4,zero
8111dd68:	110b2f40 	call	8110b2f4 <bSetPainelLeds>

	/* Turn On Power LED */
	bSetPainelLeds(LEDS_ON, LEDS_POWER_MASK);
8111dd6c:	01400074 	movhi	r5,1
8111dd70:	01000044 	movi	r4,1
8111dd74:	110b2f40 	call	8110b2f4 <bSetPainelLeds>

	/* Configure Seven Segments Display */
	bSSDisplayConfig(SSDP_NORMAL_MODE);
8111dd78:	0009883a 	mov	r4,zero
8111dd7c:	110c8ec0 	call	8110c8ec <bSSDisplayConfig>
	bSSDisplayUpdate(0);
8111dd80:	0009883a 	mov	r4,zero
8111dd84:	110c9bc0 	call	8110c9bc <bSSDisplayUpdate>

	vRstcHoldDeviceReset(RSTC_DEV_RS232_RST_CTRL_MSK);
8111dd88:	01008004 	movi	r4,512
8111dd8c:	110c44c0 	call	8110c44c <vRstcHoldDeviceReset>
	vRstcReleaseDeviceReset(RSTC_DEV_RS232_RST_CTRL_MSK);
8111dd90:	01008004 	movi	r4,512
8111dd94:	110c3d80 	call	8110c3d8 <vRstcReleaseDeviceReset>

}
8111dd98:	0001883a 	nop
8111dd9c:	e037883a 	mov	sp,fp
8111dda0:	dfc00117 	ldw	ra,4(sp)
8111dda4:	df000017 	ldw	fp,0(sp)
8111dda8:	dec00204 	addi	sp,sp,8
8111ddac:	f800283a 	ret

8111ddb0 <bLogWriteSDCard>:

#include "log_manager_simucam.h"


bool bLogWriteSDCard ( const char * cDataIn, const char * cFilename )
{
8111ddb0:	defffd04 	addi	sp,sp,-12
8111ddb4:	de00012e 	bgeu	sp,et,8111ddbc <bLogWriteSDCard+0xc>
8111ddb8:	003b68fa 	trap	3
8111ddbc:	df000215 	stw	fp,8(sp)
8111ddc0:	df000204 	addi	fp,sp,8
8111ddc4:	e13ffe15 	stw	r4,-8(fp)
8111ddc8:	e17fff15 	stw	r5,-4(fp)

	return TRUE;
8111ddcc:	00800044 	movi	r2,1
}
8111ddd0:	e037883a 	mov	sp,fp
8111ddd4:	df000017 	ldw	fp,0(sp)
8111ddd8:	dec00104 	addi	sp,sp,4
8111dddc:	f800283a 	ret

8111dde0 <vLogWriteNUC>:

/* Prefer to use directly vSendLog, if there's any error use this function */
void vLogWriteNUC ( const char * cDataIn )
{
8111dde0:	deffe004 	addi	sp,sp,-128
8111dde4:	de00012e 	bgeu	sp,et,8111ddec <vLogWriteNUC+0xc>
8111dde8:	003b68fa 	trap	3
8111ddec:	dfc01f15 	stw	ra,124(sp)
8111ddf0:	df001e15 	stw	fp,120(sp)
8111ddf4:	df001e04 	addi	fp,sp,120
8111ddf8:	e13fff15 	stw	r4,-4(fp)
	char cTemp[114] = "";
8111ddfc:	e03fe215 	stw	zero,-120(fp)
8111de00:	e0bfe304 	addi	r2,fp,-116
8111de04:	00c01b84 	movi	r3,110
8111de08:	180d883a 	mov	r6,r3
8111de0c:	000b883a 	mov	r5,zero
8111de10:	1009883a 	mov	r4,r2
8111de14:	11221a40 	call	811221a4 <memset>
	memset(cTemp,0,114);
8111de18:	01801c84 	movi	r6,114
8111de1c:	000b883a 	mov	r5,zero
8111de20:	e13fe204 	addi	r4,fp,-120
8111de24:	11221a40 	call	811221a4 <memset>
	memcpy(cTemp,cDataIn, min_sim( strlen(cDataIn), 113 ) ); /* 113 to let a zero terminator in the worst case (truc the message) */
8111de28:	e13fff17 	ldw	r4,-4(fp)
8111de2c:	1122b480 	call	81122b48 <strlen>
8111de30:	10801c68 	cmpgeui	r2,r2,113
8111de34:	1000031e 	bne	r2,zero,8111de44 <vLogWriteNUC+0x64>
8111de38:	e13fff17 	ldw	r4,-4(fp)
8111de3c:	1122b480 	call	81122b48 <strlen>
8111de40:	00000106 	br	8111de48 <vLogWriteNUC+0x68>
8111de44:	00801c44 	movi	r2,113
8111de48:	100d883a 	mov	r6,r2
8111de4c:	e17fff17 	ldw	r5,-4(fp)
8111de50:	e13fe204 	addi	r4,fp,-120
8111de54:	11220540 	call	81122054 <memcpy>
	vSendLog ( cDataIn );
8111de58:	e13fff17 	ldw	r4,-4(fp)
8111de5c:	11191440 	call	81119144 <vSendLog>
}
8111de60:	0001883a 	nop
8111de64:	e037883a 	mov	sp,fp
8111de68:	dfc00117 	ldw	ra,4(sp)
8111de6c:	df000017 	ldw	fp,0(sp)
8111de70:	dec00204 	addi	sp,sp,8
8111de74:	f800283a 	ret

8111de78 <vSimucamStructureInit>:
 */


#include "meb.h"

void vSimucamStructureInit( TSimucam_MEB *xMeb ) {
8111de78:	defffd04 	addi	sp,sp,-12
8111de7c:	de00012e 	bgeu	sp,et,8111de84 <vSimucamStructureInit+0xc>
8111de80:	003b68fa 	trap	3
8111de84:	dfc00215 	stw	ra,8(sp)
8111de88:	df000115 	stw	fp,4(sp)
8111de8c:	df000104 	addi	fp,sp,4
8111de90:	e13fff15 	stw	r4,-4(fp)
    // LoadTypeOfFeeSDCard();
    // todo: Load from SDCard for now is Hardcoded to Normal FEE
    xMeb->eType = sNormalFEE;
8111de94:	e0bfff17 	ldw	r2,-4(fp)
8111de98:	10000015 	stw	zero,0(r2)
    
    /* Simucam start in the Meb Config Mode */
    xMeb->eMode = sMebInit;
8111de9c:	e0bfff17 	ldw	r2,-4(fp)
8111dea0:	10000115 	stw	zero,4(r2)

    /* Load EP */
    vLoadDefaultEPValue( xMeb );
8111dea4:	e13fff17 	ldw	r4,-4(fp)
8111dea8:	111df640 	call	8111df64 <vLoadDefaultEPValue>
    /* Load RT */
    vLoadDefaultRTValue( xMeb );
8111deac:	e13fff17 	ldw	r4,-4(fp)
8111deb0:	111e0080 	call	8111e008 <vLoadDefaultRTValue>
    /* Load SyncSource */
    vLoadDefaultSyncSource( xMeb );
8111deb4:	e13fff17 	ldw	r4,-4(fp)
8111deb8:	111e0b00 	call	8111e0b0 <vLoadDefaultSyncSource>
    /* Load Default Config for Auto Reset Mode */
    vLoadDefaultAutoResetSync( xMeb );
8111debc:	e13fff17 	ldw	r4,-4(fp)
8111dec0:	111e1500 	call	8111e150 <vLoadDefaultAutoResetSync>

    /* todo: Change for change functions */
    xMeb->fLineTransferTime = 0;
8111dec4:	e0bfff17 	ldw	r2,-4(fp)
8111dec8:	10000615 	stw	zero,24(r2)
    xMeb->fPixelTransferTime = 0;
8111decc:	e0bfff17 	ldw	r2,-4(fp)
8111ded0:	10000715 	stw	zero,28(r2)
    xMeb->usiDelaySyncReset = 500; /* milliseconds */
8111ded4:	e0bfff17 	ldw	r2,-4(fp)
8111ded8:	00c07d04 	movi	r3,500
8111dedc:	10c0050d 	sth	r3,20(r2)

    /* Reseting swap memory mechanism */
    xMeb->ucActualDDR = 0;
8111dee0:	e0bfff17 	ldw	r2,-4(fp)
8111dee4:	10000205 	stb	zero,8(r2)
    xMeb->ucNextDDR = 1;
8111dee8:	e0bfff17 	ldw	r2,-4(fp)
8111deec:	00c00044 	movi	r3,1
8111def0:	10c00245 	stb	r3,9(r2)

    xMeb->xFeeControl.pActualMem = &xMeb->ucActualDDR;
8111def4:	e0bfff17 	ldw	r2,-4(fp)
8111def8:	10c00204 	addi	r3,r2,8
8111defc:	e0bfff17 	ldw	r2,-4(fp)
8111df00:	10c0a815 	stw	r3,672(r2)
    xMeb->xDataControl.pNextMem = &xMeb->ucNextDDR;
8111df04:	e0bfff17 	ldw	r2,-4(fp)
8111df08:	10c00244 	addi	r3,r2,9
8111df0c:	e0bfff17 	ldw	r2,-4(fp)
8111df10:	10c01115 	stw	r3,68(r2)

    /* Verify if if a Fast or Normal */
    if ( xMeb->eType == sNormalFEE ) {
8111df14:	e0bfff17 	ldw	r2,-4(fp)
8111df18:	10800017 	ldw	r2,0(r2)
8111df1c:	10000b1e 	bne	r2,zero,8111df4c <vSimucamStructureInit+0xd4>
        /* Are Normal Fee instances */
    	vNFeeControlInit( &xMeb->xFeeControl );
8111df20:	e0bfff17 	ldw	r2,-4(fp)
8111df24:	10801204 	addi	r2,r2,72
8111df28:	1009883a 	mov	r4,r2
8111df2c:	111db100 	call	8111db10 <vNFeeControlInit>
        vDataControllerInit( &xMeb->xDataControl, &xMeb->xFeeControl );
8111df30:	e0bfff17 	ldw	r2,-4(fp)
8111df34:	10c00a04 	addi	r3,r2,40
8111df38:	e0bfff17 	ldw	r2,-4(fp)
8111df3c:	10801204 	addi	r2,r2,72
8111df40:	100b883a 	mov	r5,r2
8111df44:	1809883a 	mov	r4,r3
8111df48:	111b2580 	call	8111b258 <vDataControllerInit>


    /* At this point all structures that manage the aplication of Simucam and FEE are initialized, the tasks could start now */


}
8111df4c:	0001883a 	nop
8111df50:	e037883a 	mov	sp,fp
8111df54:	dfc00117 	ldw	ra,4(sp)
8111df58:	df000017 	ldw	fp,0(sp)
8111df5c:	dec00204 	addi	sp,sp,8
8111df60:	f800283a 	ret

8111df64 <vLoadDefaultEPValue>:

/* Only in MEB_CONFIG */
/* Load Default value of EP - Exposure period [NFEESIM-UR-447] */
void vLoadDefaultEPValue( TSimucam_MEB *xMeb ) {
8111df64:	defffe04 	addi	sp,sp,-8
8111df68:	de00012e 	bgeu	sp,et,8111df70 <vLoadDefaultEPValue+0xc>
8111df6c:	003b68fa 	trap	3
8111df70:	df000115 	stw	fp,4(sp)
8111df74:	df000104 	addi	fp,sp,4
8111df78:	e13fff15 	stw	r4,-4(fp)
    //bGetEPSDCard();
    //todo: For now is hardcoded
    xMeb->ucEP = 25;
8111df7c:	e0bfff17 	ldw	r2,-4(fp)
8111df80:	00d07234 	movhi	r3,16840
8111df84:	10c00315 	stw	r3,12(r2)
}
8111df88:	0001883a 	nop
8111df8c:	e037883a 	mov	sp,fp
8111df90:	df000017 	ldw	fp,0(sp)
8111df94:	dec00104 	addi	sp,sp,4
8111df98:	f800283a 	ret

8111df9c <vChangeEPValue>:

/* Only in MEB_CONFIG */
/* Change the active value of EP - Exposure period [NFEESIM-UR-447] */
void vChangeEPValue( TSimucam_MEB *xMeb, float ucValue ) {
8111df9c:	defffd04 	addi	sp,sp,-12
8111dfa0:	de00012e 	bgeu	sp,et,8111dfa8 <vChangeEPValue+0xc>
8111dfa4:	003b68fa 	trap	3
8111dfa8:	df000215 	stw	fp,8(sp)
8111dfac:	df000204 	addi	fp,sp,8
8111dfb0:	e13ffe15 	stw	r4,-8(fp)
8111dfb4:	e17fff15 	stw	r5,-4(fp)
    xMeb->ucEP = ucValue;
8111dfb8:	e0bffe17 	ldw	r2,-8(fp)
8111dfbc:	e0ffff17 	ldw	r3,-4(fp)
8111dfc0:	10c00315 	stw	r3,12(r2)
}
8111dfc4:	0001883a 	nop
8111dfc8:	e037883a 	mov	sp,fp
8111dfcc:	df000017 	ldw	fp,0(sp)
8111dfd0:	dec00104 	addi	sp,sp,4
8111dfd4:	f800283a 	ret

8111dfd8 <vChangeDefaultEPValue>:

/* Only in MEB_CONFIG */
/* Change the default value of EP - Exposure period [NFEESIM-UR-447] */
void vChangeDefaultEPValue( TSimucam_MEB *xMeb, float ucValue ) {
8111dfd8:	defffd04 	addi	sp,sp,-12
8111dfdc:	de00012e 	bgeu	sp,et,8111dfe4 <vChangeDefaultEPValue+0xc>
8111dfe0:	003b68fa 	trap	3
8111dfe4:	df000215 	stw	fp,8(sp)
8111dfe8:	df000204 	addi	fp,sp,8
8111dfec:	e13ffe15 	stw	r4,-8(fp)
8111dff0:	e17fff15 	stw	r5,-4(fp)
    //bSaveEPSDCard(ucValue);
}
8111dff4:	0001883a 	nop
8111dff8:	e037883a 	mov	sp,fp
8111dffc:	df000017 	ldw	fp,0(sp)
8111e000:	dec00104 	addi	sp,sp,4
8111e004:	f800283a 	ret

8111e008 <vLoadDefaultRTValue>:

/* Only in MEB_CONFIG */
/* Load Default value of EP - Exposure period [NFEESIM-UR-447] */
void vLoadDefaultRTValue( TSimucam_MEB *xMeb ) {
8111e008:	defffe04 	addi	sp,sp,-8
8111e00c:	de00012e 	bgeu	sp,et,8111e014 <vLoadDefaultRTValue+0xc>
8111e010:	003b68fa 	trap	3
8111e014:	df000115 	stw	fp,4(sp)
8111e018:	df000104 	addi	fp,sp,4
8111e01c:	e13fff15 	stw	r4,-4(fp)
    //bGetEPSDCard();
    //todo: For now is hardcoded
    xMeb->ucRT = 3.9;
8111e020:	e0ffff17 	ldw	r3,-4(fp)
8111e024:	00901eb4 	movhi	r2,16506
8111e028:	10a66684 	addi	r2,r2,-26214
8111e02c:	18800415 	stw	r2,16(r3)
}
8111e030:	0001883a 	nop
8111e034:	e037883a 	mov	sp,fp
8111e038:	df000017 	ldw	fp,0(sp)
8111e03c:	dec00104 	addi	sp,sp,4
8111e040:	f800283a 	ret

8111e044 <vChangeRTValue>:

/* Only in MEB_CONFIG */
/* Change the active value of RT - CCD readout time [NFEESIM-UR-447] */
void vChangeRTValue( TSimucam_MEB *xMeb, float ucValue ) {
8111e044:	defffd04 	addi	sp,sp,-12
8111e048:	de00012e 	bgeu	sp,et,8111e050 <vChangeRTValue+0xc>
8111e04c:	003b68fa 	trap	3
8111e050:	df000215 	stw	fp,8(sp)
8111e054:	df000204 	addi	fp,sp,8
8111e058:	e13ffe15 	stw	r4,-8(fp)
8111e05c:	e17fff15 	stw	r5,-4(fp)
    xMeb->ucRT = ucValue;
8111e060:	e0bffe17 	ldw	r2,-8(fp)
8111e064:	e0ffff17 	ldw	r3,-4(fp)
8111e068:	10c00415 	stw	r3,16(r2)
}
8111e06c:	0001883a 	nop
8111e070:	e037883a 	mov	sp,fp
8111e074:	df000017 	ldw	fp,0(sp)
8111e078:	dec00104 	addi	sp,sp,4
8111e07c:	f800283a 	ret

8111e080 <vChangeDefaultRTValue>:

/* Only in MEB_CONFIG */
/* Change the default value of RT - CCD readout time [NFEESIM-UR-447] */
void vChangeDefaultRTValue( TSimucam_MEB *xMeb, float ucValue ) {
8111e080:	defffd04 	addi	sp,sp,-12
8111e084:	de00012e 	bgeu	sp,et,8111e08c <vChangeDefaultRTValue+0xc>
8111e088:	003b68fa 	trap	3
8111e08c:	df000215 	stw	fp,8(sp)
8111e090:	df000204 	addi	fp,sp,8
8111e094:	e13ffe15 	stw	r4,-8(fp)
8111e098:	e17fff15 	stw	r5,-4(fp)
    //bSaveRTSDCard(ucValue);
}
8111e09c:	0001883a 	nop
8111e0a0:	e037883a 	mov	sp,fp
8111e0a4:	df000017 	ldw	fp,0(sp)
8111e0a8:	dec00104 	addi	sp,sp,4
8111e0ac:	f800283a 	ret

8111e0b0 <vLoadDefaultSyncSource>:

/* Only in MEB_CONFIG */
/* Load Default Config Sync - Internal or external */
void vLoadDefaultSyncSource( TSimucam_MEB *xMeb ) {
8111e0b0:	defffe04 	addi	sp,sp,-8
8111e0b4:	de00012e 	bgeu	sp,et,8111e0bc <vLoadDefaultSyncSource+0xc>
8111e0b8:	003b68fa 	trap	3
8111e0bc:	df000115 	stw	fp,4(sp)
8111e0c0:	df000104 	addi	fp,sp,4
8111e0c4:	e13fff15 	stw	r4,-4(fp)
    //bGetSyncSourceSDCard();
    //todo: For now is hardcoded
    xMeb->eSync = sInternal;
8111e0c8:	e0bfff17 	ldw	r2,-4(fp)
8111e0cc:	10000815 	stw	zero,32(r2)
}
8111e0d0:	0001883a 	nop
8111e0d4:	e037883a 	mov	sp,fp
8111e0d8:	df000017 	ldw	fp,0(sp)
8111e0dc:	dec00104 	addi	sp,sp,4
8111e0e0:	f800283a 	ret

8111e0e4 <vChangeSyncSource>:

/* Only in MEB_CONFIG */
/* Change the Active Config Sync - Internal or external */
void vChangeSyncSource( TSimucam_MEB *xMeb, tSimucamSync eSource ) {
8111e0e4:	defffd04 	addi	sp,sp,-12
8111e0e8:	de00012e 	bgeu	sp,et,8111e0f0 <vChangeSyncSource+0xc>
8111e0ec:	003b68fa 	trap	3
8111e0f0:	df000215 	stw	fp,8(sp)
8111e0f4:	df000204 	addi	fp,sp,8
8111e0f8:	e13ffe15 	stw	r4,-8(fp)
8111e0fc:	e17fff15 	stw	r5,-4(fp)
    xMeb->eSync = eSource;
8111e100:	e0bffe17 	ldw	r2,-8(fp)
8111e104:	e0ffff17 	ldw	r3,-4(fp)
8111e108:	10c00815 	stw	r3,32(r2)
}
8111e10c:	0001883a 	nop
8111e110:	e037883a 	mov	sp,fp
8111e114:	df000017 	ldw	fp,0(sp)
8111e118:	dec00104 	addi	sp,sp,4
8111e11c:	f800283a 	ret

8111e120 <vChangeDefaultSyncSource>:

/* Only in MEB_CONFIG */
/* Change the Default Config Sync - Internal or external */
void vChangeDefaultSyncSource( TSimucam_MEB *xMeb, tSimucamSync eSource ) {
8111e120:	defffd04 	addi	sp,sp,-12
8111e124:	de00012e 	bgeu	sp,et,8111e12c <vChangeDefaultSyncSource+0xc>
8111e128:	003b68fa 	trap	3
8111e12c:	df000215 	stw	fp,8(sp)
8111e130:	df000204 	addi	fp,sp,8
8111e134:	e13ffe15 	stw	r4,-8(fp)
8111e138:	e17fff15 	stw	r5,-4(fp)
    //bSaveSyncSourceSDCard(eSource);
}
8111e13c:	0001883a 	nop
8111e140:	e037883a 	mov	sp,fp
8111e144:	df000017 	ldw	fp,0(sp)
8111e148:	dec00104 	addi	sp,sp,4
8111e14c:	f800283a 	ret

8111e150 <vLoadDefaultAutoResetSync>:


/* Only in MEB_CONFIG */
/* Load Default Config for AutoResetSync */
void vLoadDefaultAutoResetSync( TSimucam_MEB *xMeb ) {
8111e150:	defffe04 	addi	sp,sp,-8
8111e154:	de00012e 	bgeu	sp,et,8111e15c <vLoadDefaultAutoResetSync+0xc>
8111e158:	003b68fa 	trap	3
8111e15c:	df000115 	stw	fp,4(sp)
8111e160:	df000104 	addi	fp,sp,4
8111e164:	e13fff15 	stw	r4,-4(fp)
    //bGetAutoResetSyncSDCard();
    //todo: For now is hardcoded
    xMeb->bAutoResetSyncMode = TRUE;
8111e168:	e0bfff17 	ldw	r2,-4(fp)
8111e16c:	00c00044 	movi	r3,1
8111e170:	10c00915 	stw	r3,36(r2)
}
8111e174:	0001883a 	nop
8111e178:	e037883a 	mov	sp,fp
8111e17c:	df000017 	ldw	fp,0(sp)
8111e180:	dec00104 	addi	sp,sp,4
8111e184:	f800283a 	ret

8111e188 <vChangeAutoResetSync>:

/* Only in MEB_CONFIG */
/* Change the Config for AutoResetSync*/
void vChangeAutoResetSync( TSimucam_MEB *xMeb, bool bAutoReset ) {
8111e188:	defffd04 	addi	sp,sp,-12
8111e18c:	de00012e 	bgeu	sp,et,8111e194 <vChangeAutoResetSync+0xc>
8111e190:	003b68fa 	trap	3
8111e194:	df000215 	stw	fp,8(sp)
8111e198:	df000204 	addi	fp,sp,8
8111e19c:	e13ffe15 	stw	r4,-8(fp)
8111e1a0:	e17fff15 	stw	r5,-4(fp)
    xMeb->bAutoResetSyncMode = bAutoReset;
8111e1a4:	e0bffe17 	ldw	r2,-8(fp)
8111e1a8:	e0ffff17 	ldw	r3,-4(fp)
8111e1ac:	10c00915 	stw	r3,36(r2)
}
8111e1b0:	0001883a 	nop
8111e1b4:	e037883a 	mov	sp,fp
8111e1b8:	df000017 	ldw	fp,0(sp)
8111e1bc:	dec00104 	addi	sp,sp,4
8111e1c0:	f800283a 	ret

8111e1c4 <vChangeDefaultAutoResetSync>:

/* Only in MEB_CONFIG */
/* Change the Default Config for AutoResetSync */
void vChangeDefaultAutoResetSync( TSimucam_MEB *xMeb, bool bAutoReset ) {
8111e1c4:	defffd04 	addi	sp,sp,-12
8111e1c8:	de00012e 	bgeu	sp,et,8111e1d0 <vChangeDefaultAutoResetSync+0xc>
8111e1cc:	003b68fa 	trap	3
8111e1d0:	df000215 	stw	fp,8(sp)
8111e1d4:	df000204 	addi	fp,sp,8
8111e1d8:	e13ffe15 	stw	r4,-8(fp)
8111e1dc:	e17fff15 	stw	r5,-4(fp)
    //bSaveAutoResetSyncSDCard(bAutoReset);
}
8111e1e0:	0001883a 	nop
8111e1e4:	e037883a 	mov	sp,fp
8111e1e8:	df000017 	ldw	fp,0(sp)
8111e1ec:	dec00104 	addi	sp,sp,4
8111e1f0:	f800283a 	ret

8111e1f4 <vSyncReset>:


/* Any mode */
/* Synchronization Reset */
void vSyncReset( TSimucam_MEB *xMeb, float ufSynchDelay ) {
8111e1f4:	defffc04 	addi	sp,sp,-16
8111e1f8:	de00012e 	bgeu	sp,et,8111e200 <vSyncReset+0xc>
8111e1fc:	003b68fa 	trap	3
8111e200:	dfc00315 	stw	ra,12(sp)
8111e204:	df000215 	stw	fp,8(sp)
8111e208:	df000204 	addi	fp,sp,8
8111e20c:	e13ffe15 	stw	r4,-8(fp)
8111e210:	e17fff15 	stw	r5,-4(fp)
    // Stop all transmission

    // Put all NFEE in Stand-by mode, if not in Config mode

    // Reset the time code
    vResetTimeCode(&xMeb->xFeeControl);
8111e214:	e0bffe17 	ldw	r2,-8(fp)
8111e218:	10801204 	addi	r2,r2,72
8111e21c:	1009883a 	mov	r4,r2
8111e220:	111dc5c0 	call	8111dc5c <vResetTimeCode>

    // Release a synchronization signal

    // Start new cycle

}
8111e224:	0001883a 	nop
8111e228:	e037883a 	mov	sp,fp
8111e22c:	dfc00117 	ldw	ra,4(sp)
8111e230:	df000017 	ldw	fp,0(sp)
8111e234:	dec00204 	addi	sp,sp,8
8111e238:	f800283a 	ret

8111e23c <pattern_createPattern>:
#include "pattern.h"

alt_u32 pattern_createPattern(alt_u8 mem_number, alt_u32 mem_offset, alt_u8 ccd_number, alt_u8 ccd_side, alt_u32 width_cols, alt_u32 height_rows)
{
8111e23c:	defff504 	addi	sp,sp,-44
8111e240:	de00012e 	bgeu	sp,et,8111e248 <pattern_createPattern+0xc>
8111e244:	003b68fa 	trap	3
8111e248:	dfc00a15 	stw	ra,40(sp)
8111e24c:	df000915 	stw	fp,36(sp)
8111e250:	df000904 	addi	fp,sp,36
8111e254:	e17ffd15 	stw	r5,-12(fp)
8111e258:	3007883a 	mov	r3,r6
8111e25c:	3805883a 	mov	r2,r7
8111e260:	e13ffc05 	stb	r4,-16(fp)
8111e264:	e0fffe05 	stb	r3,-8(fp)
8111e268:	e0bfff05 	stb	r2,-4(fp)
	unsigned long long a0;
	unsigned long long a1;

	bDdr2SwitchMemory(mem_number); // Switch to the desired memory
8111e26c:	e0bffc03 	ldbu	r2,-16(fp)
8111e270:	1009883a 	mov	r4,r2
8111e274:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
	alt_u32 offset = mem_offset;
8111e278:	e0bffd17 	ldw	r2,-12(fp)
8111e27c:	e0bff715 	stw	r2,-36(fp)
	alt_u8 i = 0;
8111e280:	e03ff805 	stb	zero,-32(fp)
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
8111e284:	e0bff717 	ldw	r2,-36(fp)
8111e288:	e0bff915 	stw	r2,-28(fp)
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
8111e28c:	e03ffa15 	stw	zero,-24(fp)
8111e290:	00003606 	br	8111e36c <pattern_createPattern+0x130>
	{
		for (alt_u32 col = 0; col < width_cols; col++) // column sweep
8111e294:	e03ffb15 	stw	zero,-20(fp)
8111e298:	00002e06 	br	8111e354 <pattern_createPattern+0x118>
		{
			if (i == 64) // filled one block of memory, time to save full pattern and readress the structure
8111e29c:	e0bff803 	ldbu	r2,-32(fp)
8111e2a0:	10801018 	cmpnei	r2,r2,64
8111e2a4:	10000b1e 	bne	r2,zero,8111e2d4 <pattern_createPattern+0x98>
			{
				pxPixelData->ulliMask = PATTERN_MEMORY_FULLMASK;
8111e2a8:	e0bff917 	ldw	r2,-28(fp)
8111e2ac:	00ffffc4 	movi	r3,-1
8111e2b0:	10c02015 	stw	r3,128(r2)
8111e2b4:	00ffffc4 	movi	r3,-1
8111e2b8:	10c02115 	stw	r3,132(r2)
				offset += sizeof(TSdmaPixelDataBlock);
8111e2bc:	e0bff717 	ldw	r2,-36(fp)
8111e2c0:	10802204 	addi	r2,r2,136
8111e2c4:	e0bff715 	stw	r2,-36(fp)
				pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset);
8111e2c8:	e0bff717 	ldw	r2,-36(fp)
8111e2cc:	e0bff915 	stw	r2,-28(fp)
				i = 0;
8111e2d0:	e03ff805 	stb	zero,-32(fp)
			}
			// Generate pattern pixel (16-bits)
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
8111e2d4:	e0bff803 	ldbu	r2,-32(fp)
8111e2d8:	10c00044 	addi	r3,r2,1
8111e2dc:	e0fff805 	stb	r3,-32(fp)
8111e2e0:	10803fcc 	andi	r2,r2,255
8111e2e4:	e0fffe03 	ldbu	r3,-8(fp)
8111e2e8:	18c000cc 	andi	r3,r3,3
8111e2ec:	180692fa 	slli	r3,r3,11
8111e2f0:	1809883a 	mov	r4,r3
8111e2f4:	00f80004 	movi	r3,-8192
8111e2f8:	20c6b03a 	or	r3,r4,r3
8111e2fc:	1809883a 	mov	r4,r3
8111e300:	e0ffff03 	ldbu	r3,-4(fp)
8111e304:	18c0004c 	andi	r3,r3,1
8111e308:	180692ba 	slli	r3,r3,10
8111e30c:	20c6b03a 	or	r3,r4,r3
8111e310:	1809883a 	mov	r4,r3
8111e314:	e0fffa17 	ldw	r3,-24(fp)
8111e318:	18c007cc 	andi	r3,r3,31
8111e31c:	1806917a 	slli	r3,r3,5
8111e320:	20c6b03a 	or	r3,r4,r3
8111e324:	1809883a 	mov	r4,r3
8111e328:	e0fffb17 	ldw	r3,-20(fp)
8111e32c:	18c007cc 	andi	r3,r3,31
8111e330:	20c6b03a 	or	r3,r4,r3
8111e334:	1809883a 	mov	r4,r3
8111e338:	e0fff917 	ldw	r3,-28(fp)
8111e33c:	1085883a 	add	r2,r2,r2
8111e340:	1885883a 	add	r2,r3,r2
8111e344:	1100000d 	sth	r4,0(r2)
	alt_u32 offset = mem_offset;
	alt_u8 i = 0;
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
	{
		for (alt_u32 col = 0; col < width_cols; col++) // column sweep
8111e348:	e0bffb17 	ldw	r2,-20(fp)
8111e34c:	10800044 	addi	r2,r2,1
8111e350:	e0bffb15 	stw	r2,-20(fp)
8111e354:	e0fffb17 	ldw	r3,-20(fp)
8111e358:	e0800217 	ldw	r2,8(fp)
8111e35c:	18bfcf36 	bltu	r3,r2,8111e29c <__reset+0xfb0fe29c>

	bDdr2SwitchMemory(mem_number); // Switch to the desired memory
	alt_u32 offset = mem_offset;
	alt_u8 i = 0;
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
8111e360:	e0bffa17 	ldw	r2,-24(fp)
8111e364:	10800044 	addi	r2,r2,1
8111e368:	e0bffa15 	stw	r2,-24(fp)
8111e36c:	e0fffa17 	ldw	r3,-24(fp)
8111e370:	e0800317 	ldw	r2,12(fp)
8111e374:	18bfc736 	bltu	r3,r2,8111e294 <__reset+0xfb0fe294>
			// Generate pattern pixel (16-bits)
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
		}
	}

	pxPixelData->ulliMask = xSimMeb.xFeeControl.xNfee[0].xMemMap.xCommon.ucPaddingMask.ullWord;
8111e378:	012045b4 	movhi	r4,33046
8111e37c:	2122b904 	addi	r4,r4,-29980
8111e380:	20801917 	ldw	r2,100(r4)
8111e384:	20c01a17 	ldw	r3,104(r4)
8111e388:	e13ff917 	ldw	r4,-28(fp)
8111e38c:	20802015 	stw	r2,128(r4)
8111e390:	20c02115 	stw	r3,132(r4)

	offset += sizeof(TSdmaPixelDataBlock); // increment offset so we return the next available memory block
8111e394:	e0bff717 	ldw	r2,-36(fp)
8111e398:	10802204 	addi	r2,r2,136
8111e39c:	e0bff715 	stw	r2,-36(fp)
	return offset;
8111e3a0:	e0bff717 	ldw	r2,-36(fp)
}
8111e3a4:	e037883a 	mov	sp,fp
8111e3a8:	dfc00117 	ldw	ra,4(sp)
8111e3ac:	df000017 	ldw	fp,0(sp)
8111e3b0:	dec00204 	addi	sp,sp,8
8111e3b4:	f800283a 	ret

8111e3b8 <bSDcardIsPresent>:
#include "sdcard_file_manager.h"


TSDHandle xSdHandle;

bool bSDcardIsPresent( void ){
8111e3b8:	defffe04 	addi	sp,sp,-8
8111e3bc:	de00012e 	bgeu	sp,et,8111e3c4 <bSDcardIsPresent+0xc>
8111e3c0:	003b68fa 	trap	3
8111e3c4:	dfc00115 	stw	ra,4(sp)
8111e3c8:	df000015 	stw	fp,0(sp)
8111e3cc:	d839883a 	mov	fp,sp
	return alt_up_sd_card_is_Present();
8111e3d0:	11449000 	call	81144900 <alt_up_sd_card_is_Present>
}
8111e3d4:	e037883a 	mov	sp,fp
8111e3d8:	dfc00117 	ldw	ra,4(sp)
8111e3dc:	df000017 	ldw	fp,0(sp)
8111e3e0:	dec00204 	addi	sp,sp,8
8111e3e4:	f800283a 	ret

8111e3e8 <bSDcardFAT16Check>:

bool bSDcardFAT16Check( void ){
8111e3e8:	defffe04 	addi	sp,sp,-8
8111e3ec:	de00012e 	bgeu	sp,et,8111e3f4 <bSDcardFAT16Check+0xc>
8111e3f0:	003b68fa 	trap	3
8111e3f4:	dfc00115 	stw	ra,4(sp)
8111e3f8:	df000015 	stw	fp,0(sp)
8111e3fc:	d839883a 	mov	fp,sp
	return alt_up_sd_card_is_FAT16();
8111e400:	11449cc0 	call	811449cc <alt_up_sd_card_is_FAT16>
}
8111e404:	e037883a 	mov	sp,fp
8111e408:	dfc00117 	ldw	ra,4(sp)
8111e40c:	df000017 	ldw	fp,0(sp)
8111e410:	dec00204 	addi	sp,sp,8
8111e414:	f800283a 	ret

8111e418 <bInitializeSDCard>:

bool bInitializeSDCard( void ){
8111e418:	defffd04 	addi	sp,sp,-12
8111e41c:	de00012e 	bgeu	sp,et,8111e424 <bInitializeSDCard+0xc>
8111e420:	003b68fa 	trap	3
8111e424:	dfc00215 	stw	ra,8(sp)
8111e428:	df000115 	stw	fp,4(sp)
8111e42c:	df000104 	addi	fp,sp,4
	bool bSucess = FALSE;
8111e430:	e03fff15 	stw	zero,-4(fp)
	xSdHandle.deviceHandle = NULL;
8111e434:	d0207715 	stw	zero,-32292(gp)

	xSdHandle.deviceHandle = alt_up_sd_card_open_dev(ALTERA_UP_SD_CARD_AVALON_INTERFACE_0_NAME);
8111e438:	01204574 	movhi	r4,33045
8111e43c:	213fcb04 	addi	r4,r4,-212
8111e440:	114483c0 	call	8114483c <alt_up_sd_card_open_dev>
8111e444:	d0a07715 	stw	r2,-32292(gp)
	if ( xSdHandle.deviceHandle != NULL ) {
8111e448:	d0a07717 	ldw	r2,-32292(gp)
8111e44c:	10002226 	beq	r2,zero,8111e4d8 <bInitializeSDCard+0xc0>

		bSucess = bSDcardIsPresent();
8111e450:	111e3b80 	call	8111e3b8 <bSDcardIsPresent>
8111e454:	e0bfff15 	stw	r2,-4(fp)
		if ( bSucess ) {
8111e458:	e0bfff17 	ldw	r2,-4(fp)
8111e45c:	10001626 	beq	r2,zero,8111e4b8 <bInitializeSDCard+0xa0>
			bSucess = bSDcardFAT16Check();
8111e460:	111e3e80 	call	8111e3e8 <bSDcardFAT16Check>
8111e464:	e0bfff15 	stw	r2,-4(fp)
			if ( bSucess ) {
8111e468:	e0bfff17 	ldw	r2,-4(fp)
8111e46c:	10000a26 	beq	r2,zero,8111e498 <bInitializeSDCard+0x80>
				xSdHandle.connected = TRUE;
8111e470:	00800044 	movi	r2,1
8111e474:	d0a07615 	stw	r2,-32296(gp)
				debug(fp, "SD is up.\r\n");
8111e478:	d0a06217 	ldw	r2,-32376(gp)
8111e47c:	100f883a 	mov	r7,r2
8111e480:	018002c4 	movi	r6,11
8111e484:	01400044 	movi	r5,1
8111e488:	01204574 	movhi	r4,33045
8111e48c:	213fd604 	addi	r4,r4,-168
8111e490:	11216400 	call	81121640 <fwrite>
8111e494:	00001806 	br	8111e4f8 <bInitializeSDCard+0xe0>
			} else {
				/* SD isn't in FAT16 format*/
				debug(fp, "SD Card should be formated in FAT16.\r\n");
8111e498:	d0a06217 	ldw	r2,-32376(gp)
8111e49c:	100f883a 	mov	r7,r2
8111e4a0:	01800984 	movi	r6,38
8111e4a4:	01400044 	movi	r5,1
8111e4a8:	01204574 	movhi	r4,33045
8111e4ac:	213fd904 	addi	r4,r4,-156
8111e4b0:	11216400 	call	81121640 <fwrite>
8111e4b4:	00001006 	br	8111e4f8 <bInitializeSDCard+0xe0>
			}
		} else {
			/* There's no SDCard in the slot */
			debug(fp, "There is no SD in the slot.\r\n");
8111e4b8:	d0a06217 	ldw	r2,-32376(gp)
8111e4bc:	100f883a 	mov	r7,r2
8111e4c0:	01800744 	movi	r6,29
8111e4c4:	01400044 	movi	r5,1
8111e4c8:	01204574 	movhi	r4,33045
8111e4cc:	213fe304 	addi	r4,r4,-116
8111e4d0:	11216400 	call	81121640 <fwrite>
8111e4d4:	00000806 	br	8111e4f8 <bInitializeSDCard+0xe0>
		}

	} else {
		/* Unable to open the SDCard device. */
		bSucess = FALSE;
8111e4d8:	e03fff15 	stw	zero,-4(fp)
		debug(fp, "Unable to open the SDCard device.\r\n");
8111e4dc:	d0a06217 	ldw	r2,-32376(gp)
8111e4e0:	100f883a 	mov	r7,r2
8111e4e4:	018008c4 	movi	r6,35
8111e4e8:	01400044 	movi	r5,1
8111e4ec:	01204574 	movhi	r4,33045
8111e4f0:	213feb04 	addi	r4,r4,-84
8111e4f4:	11216400 	call	81121640 <fwrite>
	}

	return bSucess;
8111e4f8:	e0bfff17 	ldw	r2,-4(fp)
}
8111e4fc:	e037883a 	mov	sp,fp
8111e500:	dfc00117 	ldw	ra,4(sp)
8111e504:	df000017 	ldw	fp,0(sp)
8111e508:	dec00204 	addi	sp,sp,8
8111e50c:	f800283a 	ret

8111e510 <siOpenFile>:
	}
	return (char)readCharacter;
}
*/

short int siOpenFile( char *filename ) {
8111e510:	defffd04 	addi	sp,sp,-12
8111e514:	de00012e 	bgeu	sp,et,8111e51c <siOpenFile+0xc>
8111e518:	003b68fa 	trap	3
8111e51c:	dfc00215 	stw	ra,8(sp)
8111e520:	df000115 	stw	fp,4(sp)
8111e524:	df000104 	addi	fp,sp,4
8111e528:	e13fff15 	stw	r4,-4(fp)
	return alt_up_sd_card_fopen( filename, FALSE );
8111e52c:	000b883a 	mov	r5,zero
8111e530:	e13fff17 	ldw	r4,-4(fp)
8111e534:	1144ed80 	call	81144ed8 <alt_up_sd_card_fopen>
}
8111e538:	e037883a 	mov	sp,fp
8111e53c:	dfc00117 	ldw	ra,4(sp)
8111e540:	df000017 	ldw	fp,0(sp)
8111e544:	dec00204 	addi	sp,sp,8
8111e548:	f800283a 	ret

8111e54c <siCloseFile>:

bool siCloseFile( short int file_handle ) {
8111e54c:	defffd04 	addi	sp,sp,-12
8111e550:	de00012e 	bgeu	sp,et,8111e558 <siCloseFile+0xc>
8111e554:	003b68fa 	trap	3
8111e558:	dfc00215 	stw	ra,8(sp)
8111e55c:	df000115 	stw	fp,4(sp)
8111e560:	df000104 	addi	fp,sp,4
8111e564:	2005883a 	mov	r2,r4
8111e568:	e0bfff0d 	sth	r2,-4(fp)
	return alt_up_sd_card_fclose( file_handle );
8111e56c:	e0bfff0f 	ldh	r2,-4(fp)
8111e570:	1009883a 	mov	r4,r2
8111e574:	1145d240 	call	81145d24 <alt_up_sd_card_fclose>
}
8111e578:	e037883a 	mov	sp,fp
8111e57c:	dfc00117 	ldw	ra,4(sp)
8111e580:	df000017 	ldw	fp,0(sp)
8111e584:	dec00204 	addi	sp,sp,8
8111e588:	f800283a 	ret

8111e58c <cGetNextChar>:

char cGetNextChar( short int file_handle ) {
8111e58c:	defffd04 	addi	sp,sp,-12
8111e590:	de00012e 	bgeu	sp,et,8111e598 <cGetNextChar+0xc>
8111e594:	003b68fa 	trap	3
8111e598:	dfc00215 	stw	ra,8(sp)
8111e59c:	df000115 	stw	fp,4(sp)
8111e5a0:	df000104 	addi	fp,sp,4
8111e5a4:	2005883a 	mov	r2,r4
8111e5a8:	e0bfff0d 	sth	r2,-4(fp)
	return (char)alt_up_sd_card_read( file_handle );
8111e5ac:	e0bfff0f 	ldh	r2,-4(fp)
8111e5b0:	1009883a 	mov	r4,r2
8111e5b4:	114537c0 	call	8114537c <alt_up_sd_card_read>
}
8111e5b8:	e037883a 	mov	sp,fp
8111e5bc:	dfc00117 	ldw	ra,4(sp)
8111e5c0:	df000017 	ldw	fp,0(sp)
8111e5c4:	dec00204 	addi	sp,sp,8
8111e5c8:	f800283a 	ret

8111e5cc <bInitSync>:

#include "sync_handler.h"

/* todo: Create a struct that will contain all config, and pass as parameter to the functions */

bool bInitSync( void ) {
8111e5cc:	defffc04 	addi	sp,sp,-16
8111e5d0:	de00012e 	bgeu	sp,et,8111e5d8 <bInitSync+0xc>
8111e5d4:	003b68fa 	trap	3
8111e5d8:	dfc00315 	stw	ra,12(sp)
8111e5dc:	df000215 	stw	fp,8(sp)
8111e5e0:	df000204 	addi	fp,sp,8
	bool	bSuccess;
	alt_u32	aux_32;

	vSyncInitIrq();
8111e5e4:	110cb5c0 	call	8110cb5c <vSyncInitIrq>

	#ifdef DEBUG_ON
		debug(fp, "Initializing Sync Module.\n");
8111e5e8:	d0a06217 	ldw	r2,-32376(gp)
8111e5ec:	100f883a 	mov	r7,r2
8111e5f0:	01800684 	movi	r6,26
8111e5f4:	01400044 	movi	r5,1
8111e5f8:	01204574 	movhi	r4,33045
8111e5fc:	213ff404 	addi	r4,r4,-48
8111e600:	11216400 	call	81121640 <fwrite>
	#endif

	// Configura um padro de sync interno
	// MBT => 400 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetMbt(MBT);
8111e604:	01004c74 	movhi	r4,305
8111e608:	210b4004 	addi	r4,r4,11520
8111e60c:	110cd640 	call	8110cd64 <bSyncSetMbt>
8111e610:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111e614:	e0bffe17 	ldw	r2,-8(fp)
8111e618:	1000091e 	bne	r2,zero,8111e640 <bInitSync+0x74>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111e61c:	d0a06217 	ldw	r2,-32376(gp)
8111e620:	100f883a 	mov	r7,r2
8111e624:	018005c4 	movi	r6,23
8111e628:	01400044 	movi	r5,1
8111e62c:	01204574 	movhi	r4,33045
8111e630:	213ffb04 	addi	r4,r4,-20
8111e634:	11216400 	call	81121640 <fwrite>
		#endif
		return bSuccess;
8111e638:	e0bffe17 	ldw	r2,-8(fp)
8111e63c:	00007f06 	br	8111e83c <bInitSync+0x270>
	}

	// BT => 200 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetBt(BT);
8111e640:	01002674 	movhi	r4,153
8111e644:	2125a004 	addi	r4,r4,-27008
8111e648:	110cda40 	call	8110cda4 <bSyncSetBt>
8111e64c:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111e650:	e0bffe17 	ldw	r2,-8(fp)
8111e654:	1000091e 	bne	r2,zero,8111e67c <bInitSync+0xb0>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111e658:	d0a06217 	ldw	r2,-32376(gp)
8111e65c:	100f883a 	mov	r7,r2
8111e660:	018005c4 	movi	r6,23
8111e664:	01400044 	movi	r5,1
8111e668:	01204574 	movhi	r4,33045
8111e66c:	213ffb04 	addi	r4,r4,-20
8111e670:	11216400 	call	81121640 <fwrite>
		#endif
		return bSuccess;
8111e674:	e0bffe17 	ldw	r2,-8(fp)
8111e678:	00007006 	br	8111e83c <bInitSync+0x270>
	}

	// PER => 6,25s @ 20 ns (50 MHz)
	bSuccess = bSyncSetPer(  uliPerCalcPeriodMs( xDefaults.usiSyncPeriod ) );
8111e67c:	00a045b4 	movhi	r2,33046
8111e680:	1099c904 	addi	r2,r2,26404
8111e684:	1080068b 	ldhu	r2,26(r2)
8111e688:	10bfffcc 	andi	r2,r2,65535
8111e68c:	1009883a 	mov	r4,r2
8111e690:	110da3c0 	call	8110da3c <uliPerCalcPeriodMs>
8111e694:	1009883a 	mov	r4,r2
8111e698:	110cde40 	call	8110cde4 <bSyncSetPer>
8111e69c:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111e6a0:	e0bffe17 	ldw	r2,-8(fp)
8111e6a4:	1000091e 	bne	r2,zero,8111e6cc <bInitSync+0x100>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111e6a8:	d0a06217 	ldw	r2,-32376(gp)
8111e6ac:	100f883a 	mov	r7,r2
8111e6b0:	018005c4 	movi	r6,23
8111e6b4:	01400044 	movi	r5,1
8111e6b8:	01204574 	movhi	r4,33045
8111e6bc:	213ffb04 	addi	r4,r4,-20
8111e6c0:	11216400 	call	81121640 <fwrite>
		#endif
		return bSuccess;
8111e6c4:	e0bffe17 	ldw	r2,-8(fp)
8111e6c8:	00005c06 	br	8111e83c <bInitSync+0x270>
	}

	// OST => 500 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetOst(OST);
8111e6cc:	01005f74 	movhi	r4,381
8111e6d0:	211e1004 	addi	r4,r4,30784
8111e6d4:	110ce240 	call	8110ce24 <bSyncSetOst>
8111e6d8:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111e6dc:	e0bffe17 	ldw	r2,-8(fp)
8111e6e0:	1000091e 	bne	r2,zero,8111e708 <bInitSync+0x13c>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111e6e4:	d0a06217 	ldw	r2,-32376(gp)
8111e6e8:	100f883a 	mov	r7,r2
8111e6ec:	018005c4 	movi	r6,23
8111e6f0:	01400044 	movi	r5,1
8111e6f4:	01204574 	movhi	r4,33045
8111e6f8:	213ffb04 	addi	r4,r4,-20
8111e6fc:	11216400 	call	81121640 <fwrite>
		#endif
		return bSuccess;
8111e700:	e0bffe17 	ldw	r2,-8(fp)
8111e704:	00004d06 	br	8111e83c <bInitSync+0x270>
	}


	// Polaridade
	bSuccess = bSyncSetPolarity(POL);
8111e708:	0009883a 	mov	r4,zero
8111e70c:	110ce640 	call	8110ce64 <bSyncSetPolarity>
8111e710:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111e714:	e0bffe17 	ldw	r2,-8(fp)
8111e718:	1000091e 	bne	r2,zero,8111e740 <bInitSync+0x174>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111e71c:	d0a06217 	ldw	r2,-32376(gp)
8111e720:	100f883a 	mov	r7,r2
8111e724:	018005c4 	movi	r6,23
8111e728:	01400044 	movi	r5,1
8111e72c:	01204574 	movhi	r4,33045
8111e730:	213ffb04 	addi	r4,r4,-20
8111e734:	11216400 	call	81121640 <fwrite>
		#endif
		return bSuccess;
8111e738:	e0bffe17 	ldw	r2,-8(fp)
8111e73c:	00003f06 	br	8111e83c <bInitSync+0x270>
	}

	// N. de ciclos
	bSuccess = bSyncSetNCycles(N_CICLOS);
8111e740:	01000104 	movi	r4,4
8111e744:	110ced80 	call	8110ced8 <bSyncSetNCycles>
8111e748:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111e74c:	e0bffe17 	ldw	r2,-8(fp)
8111e750:	1000091e 	bne	r2,zero,8111e778 <bInitSync+0x1ac>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111e754:	d0a06217 	ldw	r2,-32376(gp)
8111e758:	100f883a 	mov	r7,r2
8111e75c:	018005c4 	movi	r6,23
8111e760:	01400044 	movi	r5,1
8111e764:	01204574 	movhi	r4,33045
8111e768:	213ffb04 	addi	r4,r4,-20
8111e76c:	11216400 	call	81121640 <fwrite>
		#endif
		return bSuccess;
8111e770:	e0bffe17 	ldw	r2,-8(fp)
8111e774:	00003106 	br	8111e83c <bInitSync+0x270>
	}

	// Altera mux para sync interno
	bSuccess = bSyncCtrExtnIrq(TRUE);
8111e778:	01000044 	movi	r4,1
8111e77c:	110d0b40 	call	8110d0b4 <bSyncCtrExtnIrq>
8111e780:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111e784:	e0bffe17 	ldw	r2,-8(fp)
8111e788:	1000091e 	bne	r2,zero,8111e7b0 <bInitSync+0x1e4>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111e78c:	d0a06217 	ldw	r2,-32376(gp)
8111e790:	100f883a 	mov	r7,r2
8111e794:	018005c4 	movi	r6,23
8111e798:	01400044 	movi	r5,1
8111e79c:	01204574 	movhi	r4,33045
8111e7a0:	213ffb04 	addi	r4,r4,-20
8111e7a4:	11216400 	call	81121640 <fwrite>
		#endif
		return bSuccess;
8111e7a8:	e0bffe17 	ldw	r2,-8(fp)
8111e7ac:	00002306 	br	8111e83c <bInitSync+0x270>
	}

	// Habilita sync_out enable (deve aparecer na sada o sync int.)
	bSuccess = bSyncCtrSyncOutEnable(TRUE);
8111e7b0:	01000044 	movi	r4,1
8111e7b4:	110d27c0 	call	8110d27c <bSyncCtrSyncOutEnable>
8111e7b8:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111e7bc:	e0bffe17 	ldw	r2,-8(fp)
8111e7c0:	1000091e 	bne	r2,zero,8111e7e8 <bInitSync+0x21c>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111e7c4:	d0a06217 	ldw	r2,-32376(gp)
8111e7c8:	100f883a 	mov	r7,r2
8111e7cc:	018005c4 	movi	r6,23
8111e7d0:	01400044 	movi	r5,1
8111e7d4:	01204574 	movhi	r4,33045
8111e7d8:	213ffb04 	addi	r4,r4,-20
8111e7dc:	11216400 	call	81121640 <fwrite>
		#endif
		return bSuccess;
8111e7e0:	e0bffe17 	ldw	r2,-8(fp)
8111e7e4:	00001506 	br	8111e83c <bInitSync+0x270>
	}

	// Habilita sync_out_ch1 enable (libera sync para o Ch 1)
	bSuccess = bSyncCtrCh1OutEnable(TRUE);
8111e7e8:	01000044 	movi	r4,1
8111e7ec:	110d2f00 	call	8110d2f0 <bSyncCtrCh1OutEnable>
8111e7f0:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111e7f4:	e0bffe17 	ldw	r2,-8(fp)
8111e7f8:	1000091e 	bne	r2,zero,8111e820 <bInitSync+0x254>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111e7fc:	d0a06217 	ldw	r2,-32376(gp)
8111e800:	100f883a 	mov	r7,r2
8111e804:	018005c4 	movi	r6,23
8111e808:	01400044 	movi	r5,1
8111e80c:	01204574 	movhi	r4,33045
8111e810:	213ffb04 	addi	r4,r4,-20
8111e814:	11216400 	call	81121640 <fwrite>
		#endif
		return bSuccess;
8111e818:	e0bffe17 	ldw	r2,-8(fp)
8111e81c:	00000706 	br	8111e83c <bInitSync+0x270>
	}

	bSuccess = bSyncCtrStart();
8111e820:	110d12c0 	call	8110d12c <bSyncCtrStart>
8111e824:	e0bffe15 	stw	r2,-8(fp)
	bSyncCtrReset();
8111e828:	110d1800 	call	8110d180 <bSyncCtrReset>
	aux_32 = bSyncIrqEnableBlank(TRUE);
8111e82c:	01000044 	movi	r4,1
8111e830:	110d7040 	call	8110d704 <bSyncIrqEnableBlank>
8111e834:	e0bfff15 	stw	r2,-4(fp)


	return bSuccess;
8111e838:	e0bffe17 	ldw	r2,-8(fp)
}
8111e83c:	e037883a 	mov	sp,fp
8111e840:	dfc00117 	ldw	ra,4(sp)
8111e844:	df000017 	ldw	fp,0(sp)
8111e848:	dec00204 	addi	sp,sp,8
8111e84c:	f800283a 	ret

8111e850 <bStartSync>:


bool bStartSync(void) {
8111e850:	defffd04 	addi	sp,sp,-12
8111e854:	de00012e 	bgeu	sp,et,8111e85c <bStartSync+0xc>
8111e858:	003b68fa 	trap	3
8111e85c:	dfc00215 	stw	ra,8(sp)
8111e860:	df000115 	stw	fp,4(sp)
8111e864:	df000104 	addi	fp,sp,4

	bool bSuccess;
	bSyncCtrReset();
8111e868:	110d1800 	call	8110d180 <bSyncCtrReset>
	bSuccess = bSyncCtrStart();
8111e86c:	110d12c0 	call	8110d12c <bSyncCtrStart>
8111e870:	e0bfff15 	stw	r2,-4(fp)

	return bSuccess;
8111e874:	e0bfff17 	ldw	r2,-4(fp)
}
8111e878:	e037883a 	mov	sp,fp
8111e87c:	dfc00117 	ldw	ra,4(sp)
8111e880:	df000017 	ldw	fp,0(sp)
8111e884:	dec00204 	addi	sp,sp,8
8111e888:	f800283a 	ret

8111e88c <bStopSync>:

bool bStopSync(void) {
8111e88c:	defffe04 	addi	sp,sp,-8
8111e890:	de00012e 	bgeu	sp,et,8111e898 <bStopSync+0xc>
8111e894:	003b68fa 	trap	3
8111e898:	dfc00115 	stw	ra,4(sp)
8111e89c:	df000015 	stw	fp,0(sp)
8111e8a0:	d839883a 	mov	fp,sp
	return bSyncCtrReset();
8111e8a4:	110d1800 	call	8110d180 <bSyncCtrReset>
}
8111e8a8:	e037883a 	mov	sp,fp
8111e8ac:	dfc00117 	ldw	ra,4(sp)
8111e8b0:	df000017 	ldw	fp,0(sp)
8111e8b4:	dec00204 	addi	sp,sp,8
8111e8b8:	f800283a 	ret

8111e8bc <bClearCounterSync>:

void bClearCounterSync(void) {
8111e8bc:	defffe04 	addi	sp,sp,-8
8111e8c0:	de00012e 	bgeu	sp,et,8111e8c8 <bClearCounterSync+0xc>
8111e8c4:	003b68fa 	trap	3
8111e8c8:	dfc00115 	stw	ra,4(sp)
8111e8cc:	df000015 	stw	fp,0(sp)
8111e8d0:	d839883a 	mov	fp,sp

	vSyncClearCounter();
8111e8d4:	110cb300 	call	8110cb30 <vSyncClearCounter>
}
8111e8d8:	0001883a 	nop
8111e8dc:	e037883a 	mov	sp,fp
8111e8e0:	dfc00117 	ldw	ra,4(sp)
8111e8e4:	df000017 	ldw	fp,0(sp)
8111e8e8:	dec00204 	addi	sp,sp,8
8111e8ec:	f800283a 	ret

8111e8f0 <bTestSimucamCriticalHW>:
 */


#include "test_module_simucam.h"

bool bTestSimucamCriticalHW( void ) {
8111e8f0:	defffd04 	addi	sp,sp,-12
8111e8f4:	de00012e 	bgeu	sp,et,8111e8fc <bTestSimucamCriticalHW+0xc>
8111e8f8:	003b68fa 	trap	3
8111e8fc:	dfc00215 	stw	ra,8(sp)
8111e900:	df000115 	stw	fp,4(sp)
8111e904:	df000104 	addi	fp,sp,4
	/*
	 * Verificar com Frana quais testes podemos realizar aqui
	 * SDcard para criar logs e pegar defaults
	 */

	bSuccess = bSdmaInitM1Dma();
8111e908:	1103b300 	call	81103b30 <bSdmaInitM1Dma>
8111e90c:	e0bfff15 	stw	r2,-4(fp)
	if (bSuccess==FALSE) {
8111e910:	e0bfff17 	ldw	r2,-4(fp)
8111e914:	1000021e 	bne	r2,zero,8111e920 <bTestSimucamCriticalHW+0x30>
		return bSuccess;
8111e918:	e0bfff17 	ldw	r2,-4(fp)
8111e91c:	00001106 	br	8111e964 <bTestSimucamCriticalHW+0x74>
	}

	bSuccess = bSdmaInitM2Dma();
8111e920:	1103be00 	call	81103be0 <bSdmaInitM2Dma>
8111e924:	e0bfff15 	stw	r2,-4(fp)
	if (bSuccess==FALSE) {
8111e928:	e0bfff17 	ldw	r2,-4(fp)
8111e92c:	1000021e 	bne	r2,zero,8111e938 <bTestSimucamCriticalHW+0x48>
		return bSuccess;
8111e930:	e0bfff17 	ldw	r2,-4(fp)
8111e934:	00000b06 	br	8111e964 <bTestSimucamCriticalHW+0x74>
	}

	xDma[0].pDmaTranfer = bSdmaDmaM1Transfer;
8111e938:	00a045b4 	movhi	r2,33046
8111e93c:	108d0d04 	addi	r2,r2,13364
8111e940:	00e04434 	movhi	r3,33040
8111e944:	18cf2404 	addi	r3,r3,15504
8111e948:	10c00115 	stw	r3,4(r2)
	xDma[0].pDmaTranfer = bSdmaDmaM2Transfer;
8111e94c:	00a045b4 	movhi	r2,33046
8111e950:	108d0d04 	addi	r2,r2,13364
8111e954:	00e04434 	movhi	r3,33040
8111e958:	18d03b04 	addi	r3,r3,16620
8111e95c:	10c00115 	stw	r3,4(r2)


	return TRUE;
8111e960:	00800044 	movi	r2,1
}
8111e964:	e037883a 	mov	sp,fp
8111e968:	dfc00117 	ldw	ra,4(sp)
8111e96c:	df000017 	ldw	fp,0(sp)
8111e970:	dec00204 	addi	sp,sp,8
8111e974:	f800283a 	ret

8111e978 <_reg_write>:
 *
 * @retval 1 : Sucesso 
 *
 */

alt_32 _reg_write(int BASE_ADD, alt_32 REG_ADD, alt_32 REG_Dado) {
8111e978:	defffc04 	addi	sp,sp,-16
8111e97c:	de00012e 	bgeu	sp,et,8111e984 <_reg_write+0xc>
8111e980:	003b68fa 	trap	3
8111e984:	df000315 	stw	fp,12(sp)
8111e988:	df000304 	addi	fp,sp,12
8111e98c:	e13ffd15 	stw	r4,-12(fp)
8111e990:	e17ffe15 	stw	r5,-8(fp)
8111e994:	e1bfff15 	stw	r6,-4(fp)

	IOWR_32DIRECT(BASE_ADD, REG_ADD << 2, REG_Dado);
8111e998:	e0bffe17 	ldw	r2,-8(fp)
8111e99c:	1085883a 	add	r2,r2,r2
8111e9a0:	1085883a 	add	r2,r2,r2
8111e9a4:	1007883a 	mov	r3,r2
8111e9a8:	e0bffd17 	ldw	r2,-12(fp)
8111e9ac:	1885883a 	add	r2,r3,r2
8111e9b0:	1007883a 	mov	r3,r2
8111e9b4:	e0bfff17 	ldw	r2,-4(fp)
8111e9b8:	18800035 	stwio	r2,0(r3)
	return 1;
8111e9bc:	00800044 	movi	r2,1

}
8111e9c0:	e037883a 	mov	sp,fp
8111e9c4:	df000017 	ldw	fp,0(sp)
8111e9c8:	dec00104 	addi	sp,sp,4
8111e9cc:	f800283a 	ret

8111e9d0 <_reg_read>:
 *
 * @retval 1 : Sucesso 
 *
 */

alt_32 _reg_read(int BASE_ADD, alt_32 REG_ADD, alt_32 *REG_Dado) {
8111e9d0:	defffc04 	addi	sp,sp,-16
8111e9d4:	de00012e 	bgeu	sp,et,8111e9dc <_reg_read+0xc>
8111e9d8:	003b68fa 	trap	3
8111e9dc:	df000315 	stw	fp,12(sp)
8111e9e0:	df000304 	addi	fp,sp,12
8111e9e4:	e13ffd15 	stw	r4,-12(fp)
8111e9e8:	e17ffe15 	stw	r5,-8(fp)
8111e9ec:	e1bfff15 	stw	r6,-4(fp)

	*REG_Dado = IORD_32DIRECT(BASE_ADD, REG_ADD << 2);
8111e9f0:	e0bffe17 	ldw	r2,-8(fp)
8111e9f4:	1085883a 	add	r2,r2,r2
8111e9f8:	1085883a 	add	r2,r2,r2
8111e9fc:	1007883a 	mov	r3,r2
8111ea00:	e0bffd17 	ldw	r2,-12(fp)
8111ea04:	1885883a 	add	r2,r3,r2
8111ea08:	10c00037 	ldwio	r3,0(r2)
8111ea0c:	e0bfff17 	ldw	r2,-4(fp)
8111ea10:	10c00015 	stw	r3,0(r2)
	return 1;
8111ea14:	00800044 	movi	r2,1

}
8111ea18:	e037883a 	mov	sp,fp
8111ea1c:	df000017 	ldw	fp,0(sp)
8111ea20:	dec00104 	addi	sp,sp,4
8111ea24:	f800283a 	ret

8111ea28 <_print_codec_status>:
 * @param [in] codec_status
 * *
 * @retval 1 : Sucesso
 *
 */
void _print_codec_status(int codec_status) {
8111ea28:	defffa04 	addi	sp,sp,-24
8111ea2c:	de00012e 	bgeu	sp,et,8111ea34 <_print_codec_status+0xc>
8111ea30:	003b68fa 	trap	3
8111ea34:	dfc00515 	stw	ra,20(sp)
8111ea38:	df000415 	stw	fp,16(sp)
8111ea3c:	df000404 	addi	fp,sp,16
8111ea40:	e13fff15 	stw	r4,-4(fp)
	int started = (int) ((codec_status >> 6) & 1);
8111ea44:	e0bfff17 	ldw	r2,-4(fp)
8111ea48:	1005d1ba 	srai	r2,r2,6
8111ea4c:	1080004c 	andi	r2,r2,1
8111ea50:	e0bffc15 	stw	r2,-16(fp)
	int connecting = (int) ((codec_status >> 5) & 1);
8111ea54:	e0bfff17 	ldw	r2,-4(fp)
8111ea58:	1005d17a 	srai	r2,r2,5
8111ea5c:	1080004c 	andi	r2,r2,1
8111ea60:	e0bffd15 	stw	r2,-12(fp)
	int running = (int) ((codec_status >> 4) & 1);
8111ea64:	e0bfff17 	ldw	r2,-4(fp)
8111ea68:	1005d13a 	srai	r2,r2,4
8111ea6c:	1080004c 	andi	r2,r2,1
8111ea70:	e0bffe15 	stw	r2,-8(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "-------- link status \n");
8111ea74:	00e04574 	movhi	r3,33045
8111ea78:	18cbe504 	addi	r3,r3,12180
8111ea7c:	00a04574 	movhi	r2,33045
8111ea80:	10800104 	addi	r2,r2,4
8111ea84:	1009883a 	mov	r4,r2
8111ea88:	008005c4 	movi	r2,23
8111ea8c:	100d883a 	mov	r6,r2
8111ea90:	200b883a 	mov	r5,r4
8111ea94:	1809883a 	mov	r4,r3
8111ea98:	11220540 	call	81122054 <memcpy>
	debug(fp, cDebugBuffer);
8111ea9c:	d0a06217 	ldw	r2,-32376(gp)
8111eaa0:	01604574 	movhi	r5,33045
8111eaa4:	294be504 	addi	r5,r5,12180
8111eaa8:	1009883a 	mov	r4,r2
8111eaac:	1120fa40 	call	81120fa4 <fprintf>
	sprintf(cDebugBuffer, "Link started    : %s \n", (started == 1) ? "S" : "N");
8111eab0:	e0bffc17 	ldw	r2,-16(fp)
8111eab4:	10800058 	cmpnei	r2,r2,1
8111eab8:	1000031e 	bne	r2,zero,8111eac8 <_print_codec_status+0xa0>
8111eabc:	00a04574 	movhi	r2,33045
8111eac0:	10800704 	addi	r2,r2,28
8111eac4:	00000206 	br	8111ead0 <_print_codec_status+0xa8>
8111eac8:	00a04574 	movhi	r2,33045
8111eacc:	10800804 	addi	r2,r2,32
8111ead0:	100d883a 	mov	r6,r2
8111ead4:	01604574 	movhi	r5,33045
8111ead8:	29400904 	addi	r5,r5,36
8111eadc:	01204574 	movhi	r4,33045
8111eae0:	210be504 	addi	r4,r4,12180
8111eae4:	11229340 	call	81122934 <sprintf>
	debug(fp, cDebugBuffer);
8111eae8:	d0a06217 	ldw	r2,-32376(gp)
8111eaec:	01604574 	movhi	r5,33045
8111eaf0:	294be504 	addi	r5,r5,12180
8111eaf4:	1009883a 	mov	r4,r2
8111eaf8:	1120fa40 	call	81120fa4 <fprintf>
	sprintf(cDebugBuffer, "Link connecting : %s \n", (connecting == 1) ? "S" : "N");
8111eafc:	e0bffd17 	ldw	r2,-12(fp)
8111eb00:	10800058 	cmpnei	r2,r2,1
8111eb04:	1000031e 	bne	r2,zero,8111eb14 <_print_codec_status+0xec>
8111eb08:	00a04574 	movhi	r2,33045
8111eb0c:	10800704 	addi	r2,r2,28
8111eb10:	00000206 	br	8111eb1c <_print_codec_status+0xf4>
8111eb14:	00a04574 	movhi	r2,33045
8111eb18:	10800804 	addi	r2,r2,32
8111eb1c:	100d883a 	mov	r6,r2
8111eb20:	01604574 	movhi	r5,33045
8111eb24:	29400f04 	addi	r5,r5,60
8111eb28:	01204574 	movhi	r4,33045
8111eb2c:	210be504 	addi	r4,r4,12180
8111eb30:	11229340 	call	81122934 <sprintf>
	debug(fp, cDebugBuffer);
8111eb34:	d0a06217 	ldw	r2,-32376(gp)
8111eb38:	01604574 	movhi	r5,33045
8111eb3c:	294be504 	addi	r5,r5,12180
8111eb40:	1009883a 	mov	r4,r2
8111eb44:	1120fa40 	call	81120fa4 <fprintf>
	sprintf(cDebugBuffer, "Link running    : %s \n", (running == 1) ? "S" : "N");
8111eb48:	e0bffe17 	ldw	r2,-8(fp)
8111eb4c:	10800058 	cmpnei	r2,r2,1
8111eb50:	1000031e 	bne	r2,zero,8111eb60 <_print_codec_status+0x138>
8111eb54:	00a04574 	movhi	r2,33045
8111eb58:	10800704 	addi	r2,r2,28
8111eb5c:	00000206 	br	8111eb68 <_print_codec_status+0x140>
8111eb60:	00a04574 	movhi	r2,33045
8111eb64:	10800804 	addi	r2,r2,32
8111eb68:	100d883a 	mov	r6,r2
8111eb6c:	01604574 	movhi	r5,33045
8111eb70:	29401504 	addi	r5,r5,84
8111eb74:	01204574 	movhi	r4,33045
8111eb78:	210be504 	addi	r4,r4,12180
8111eb7c:	11229340 	call	81122934 <sprintf>
	debug(fp, cDebugBuffer);
8111eb80:	d0a06217 	ldw	r2,-32376(gp)
8111eb84:	01604574 	movhi	r5,33045
8111eb88:	294be504 	addi	r5,r5,12180
8111eb8c:	1009883a 	mov	r4,r2
8111eb90:	1120fa40 	call	81120fa4 <fprintf>
	sprintf(cDebugBuffer, "--------  \n");
8111eb94:	00a04574 	movhi	r2,33045
8111eb98:	108be504 	addi	r2,r2,12180
8111eb9c:	00c00b44 	movi	r3,45
8111eba0:	10c00005 	stb	r3,0(r2)
8111eba4:	00c00b44 	movi	r3,45
8111eba8:	10c00045 	stb	r3,1(r2)
8111ebac:	00c00b44 	movi	r3,45
8111ebb0:	10c00085 	stb	r3,2(r2)
8111ebb4:	00c00b44 	movi	r3,45
8111ebb8:	10c000c5 	stb	r3,3(r2)
8111ebbc:	00c00b44 	movi	r3,45
8111ebc0:	10c00105 	stb	r3,4(r2)
8111ebc4:	00c00b44 	movi	r3,45
8111ebc8:	10c00145 	stb	r3,5(r2)
8111ebcc:	00c00b44 	movi	r3,45
8111ebd0:	10c00185 	stb	r3,6(r2)
8111ebd4:	00c00b44 	movi	r3,45
8111ebd8:	10c001c5 	stb	r3,7(r2)
8111ebdc:	00c00804 	movi	r3,32
8111ebe0:	10c00205 	stb	r3,8(r2)
8111ebe4:	00c00804 	movi	r3,32
8111ebe8:	10c00245 	stb	r3,9(r2)
8111ebec:	00c00284 	movi	r3,10
8111ebf0:	10c00285 	stb	r3,10(r2)
8111ebf4:	100002c5 	stb	zero,11(r2)
	debug(fp, cDebugBuffer);
8111ebf8:	d0a06217 	ldw	r2,-32376(gp)
8111ebfc:	01604574 	movhi	r5,33045
8111ec00:	294be504 	addi	r5,r5,12180
8111ec04:	1009883a 	mov	r4,r2
8111ec08:	1120fa40 	call	81120fa4 <fprintf>
#endif
}
8111ec0c:	0001883a 	nop
8111ec10:	e037883a 	mov	sp,fp
8111ec14:	dfc00117 	ldw	ra,4(sp)
8111ec18:	df000017 	ldw	fp,0(sp)
8111ec1c:	dec00204 	addi	sp,sp,8
8111ec20:	f800283a 	ret

8111ec24 <_split_codec_status>:
 * *
 * @retval 1 : Sucesso
 *
 */
void _split_codec_status(int codec_status, int *started, int *connecting,
		int *running) {
8111ec24:	defffb04 	addi	sp,sp,-20
8111ec28:	de00012e 	bgeu	sp,et,8111ec30 <_split_codec_status+0xc>
8111ec2c:	003b68fa 	trap	3
8111ec30:	df000415 	stw	fp,16(sp)
8111ec34:	df000404 	addi	fp,sp,16
8111ec38:	e13ffc15 	stw	r4,-16(fp)
8111ec3c:	e17ffd15 	stw	r5,-12(fp)
8111ec40:	e1bffe15 	stw	r6,-8(fp)
8111ec44:	e1ffff15 	stw	r7,-4(fp)
	*started = (int) ((codec_status >> 6) & 1);
8111ec48:	e0bffc17 	ldw	r2,-16(fp)
8111ec4c:	1005d1ba 	srai	r2,r2,6
8111ec50:	10c0004c 	andi	r3,r2,1
8111ec54:	e0bffd17 	ldw	r2,-12(fp)
8111ec58:	10c00015 	stw	r3,0(r2)
	*connecting = (int) ((codec_status >> 5) & 1);
8111ec5c:	e0bffc17 	ldw	r2,-16(fp)
8111ec60:	1005d17a 	srai	r2,r2,5
8111ec64:	10c0004c 	andi	r3,r2,1
8111ec68:	e0bffe17 	ldw	r2,-8(fp)
8111ec6c:	10c00015 	stw	r3,0(r2)
	*running = (int) ((codec_status >> 4) & 1);
8111ec70:	e0bffc17 	ldw	r2,-16(fp)
8111ec74:	1005d13a 	srai	r2,r2,4
8111ec78:	10c0004c 	andi	r3,r2,1
8111ec7c:	e0bfff17 	ldw	r2,-4(fp)
8111ec80:	10c00015 	stw	r3,0(r2)
}
8111ec84:	0001883a 	nop
8111ec88:	e037883a 	mov	sp,fp
8111ec8c:	df000017 	ldw	fp,0(sp)
8111ec90:	dec00104 	addi	sp,sp,4
8111ec94:	f800283a 	ret

8111ec98 <aatoh>:
 * @param [in] &char[n]
 * *
 * @retval INT8U of hecadecimal value
 *
 */
alt_u8 aatoh(alt_u8 *buffer) {
8111ec98:	defffc04 	addi	sp,sp,-16
8111ec9c:	de00012e 	bgeu	sp,et,8111eca4 <aatoh+0xc>
8111eca0:	003b68fa 	trap	3
8111eca4:	df000315 	stw	fp,12(sp)
8111eca8:	df000304 	addi	fp,sp,12
8111ecac:	e13fff15 	stw	r4,-4(fp)
	alt_u8* a;
	alt_u8 v;
	a = buffer;
8111ecb0:	e0bfff17 	ldw	r2,-4(fp)
8111ecb4:	e0bffd15 	stw	r2,-12(fp)
	v = ((a[0] - (48 + 7 * (a[0] > 57))) << 4)
8111ecb8:	e0bffd17 	ldw	r2,-12(fp)
8111ecbc:	10c00003 	ldbu	r3,0(r2)
8111ecc0:	e0bffd17 	ldw	r2,-12(fp)
8111ecc4:	10800003 	ldbu	r2,0(r2)
8111ecc8:	10803fcc 	andi	r2,r2,255
8111eccc:	10800eb0 	cmpltui	r2,r2,58
8111ecd0:	1000021e 	bne	r2,zero,8111ecdc <aatoh+0x44>
8111ecd4:	00800dc4 	movi	r2,55
8111ecd8:	00000106 	br	8111ece0 <aatoh+0x48>
8111ecdc:	00800c04 	movi	r2,48
8111ece0:	1885c83a 	sub	r2,r3,r2
8111ece4:	1004913a 	slli	r2,r2,4
8111ece8:	1009883a 	mov	r4,r2
			+ (a[1] - (48 + 7 * (a[1] > 57)));
8111ecec:	e0bffd17 	ldw	r2,-12(fp)
8111ecf0:	10800044 	addi	r2,r2,1
8111ecf4:	10c00003 	ldbu	r3,0(r2)
8111ecf8:	e0bffd17 	ldw	r2,-12(fp)
8111ecfc:	10800044 	addi	r2,r2,1
8111ed00:	10800003 	ldbu	r2,0(r2)
 */
alt_u8 aatoh(alt_u8 *buffer) {
	alt_u8* a;
	alt_u8 v;
	a = buffer;
	v = ((a[0] - (48 + 7 * (a[0] > 57))) << 4)
8111ed04:	10803fcc 	andi	r2,r2,255
8111ed08:	10800eb0 	cmpltui	r2,r2,58
8111ed0c:	1000021e 	bne	r2,zero,8111ed18 <aatoh+0x80>
8111ed10:	00800dc4 	movi	r2,55
8111ed14:	00000106 	br	8111ed1c <aatoh+0x84>
8111ed18:	00800c04 	movi	r2,48
8111ed1c:	1885c83a 	sub	r2,r3,r2
8111ed20:	2085883a 	add	r2,r4,r2
8111ed24:	e0bffe05 	stb	r2,-8(fp)
			+ (a[1] - (48 + 7 * (a[1] > 57)));
	return v;
8111ed28:	e0bffe03 	ldbu	r2,-8(fp)
}
8111ed2c:	e037883a 	mov	sp,fp
8111ed30:	df000017 	ldw	fp,0(sp)
8111ed34:	dec00104 	addi	sp,sp,4
8111ed38:	f800283a 	ret

8111ed3c <Verif_Error>:
 * *
 * @retval int
 *
 */

alt_u8 Verif_Error(alt_u8 error_code) {
8111ed3c:	defffd04 	addi	sp,sp,-12
8111ed40:	de00012e 	bgeu	sp,et,8111ed48 <Verif_Error+0xc>
8111ed44:	003b68fa 	trap	3
8111ed48:	dfc00215 	stw	ra,8(sp)
8111ed4c:	df000115 	stw	fp,4(sp)
8111ed50:	df000104 	addi	fp,sp,4
8111ed54:	2005883a 	mov	r2,r4
8111ed58:	e0bfff05 	stb	r2,-4(fp)
	if (!error_code) {
8111ed5c:	e0bfff03 	ldbu	r2,-4(fp)
8111ed60:	1000091e 	bne	r2,zero,8111ed88 <Verif_Error+0x4c>
#ifdef DEBUG_ON
	debug(fp, "ERROR\n\r");
8111ed64:	d0a06217 	ldw	r2,-32376(gp)
8111ed68:	100f883a 	mov	r7,r2
8111ed6c:	018001c4 	movi	r6,7
8111ed70:	01400044 	movi	r5,1
8111ed74:	01204574 	movhi	r4,33045
8111ed78:	21001b04 	addi	r4,r4,108
8111ed7c:	11216400 	call	81121640 <fwrite>
#endif
		return 0;
8111ed80:	0005883a 	mov	r2,zero
8111ed84:	00000106 	br	8111ed8c <Verif_Error+0x50>
	} else
		return 1;
8111ed88:	00800044 	movi	r2,1
}
8111ed8c:	e037883a 	mov	sp,fp
8111ed90:	dfc00117 	ldw	ra,4(sp)
8111ed94:	df000017 	ldw	fp,0(sp)
8111ed98:	dec00204 	addi	sp,sp,8
8111ed9c:	f800283a 	ret

8111eda0 <toInt>:
 * *
 * @retval int
 *
 */

alt_u8 toInt(alt_u8 ascii) {
8111eda0:	defffe04 	addi	sp,sp,-8
8111eda4:	de00012e 	bgeu	sp,et,8111edac <toInt+0xc>
8111eda8:	003b68fa 	trap	3
8111edac:	df000115 	stw	fp,4(sp)
8111edb0:	df000104 	addi	fp,sp,4
8111edb4:	2005883a 	mov	r2,r4
8111edb8:	e0bfff05 	stb	r2,-4(fp)
	return (int) ascii - 48;
8111edbc:	e0bfff03 	ldbu	r2,-4(fp)
8111edc0:	10bff404 	addi	r2,r2,-48
}
8111edc4:	e037883a 	mov	sp,fp
8111edc8:	df000017 	ldw	fp,0(sp)
8111edcc:	dec00104 	addi	sp,sp,4
8111edd0:	f800283a 	ret

8111edd4 <__fixunsdfsi>:
8111edd4:	defffd04 	addi	sp,sp,-12
8111edd8:	000d883a 	mov	r6,zero
8111eddc:	01d07834 	movhi	r7,16864
8111ede0:	de00012e 	bgeu	sp,et,8111ede8 <__fixunsdfsi+0x14>
8111ede4:	003b68fa 	trap	3
8111ede8:	dc400115 	stw	r17,4(sp)
8111edec:	dc000015 	stw	r16,0(sp)
8111edf0:	dfc00215 	stw	ra,8(sp)
8111edf4:	2023883a 	mov	r17,r4
8111edf8:	2821883a 	mov	r16,r5
8111edfc:	111f8c00 	call	8111f8c0 <__gedf2>
8111ee00:	1000080e 	bge	r2,zero,8111ee24 <__fixunsdfsi+0x50>
8111ee04:	8809883a 	mov	r4,r17
8111ee08:	800b883a 	mov	r5,r16
8111ee0c:	11209c00 	call	811209c0 <__fixdfsi>
8111ee10:	dfc00217 	ldw	ra,8(sp)
8111ee14:	dc400117 	ldw	r17,4(sp)
8111ee18:	dc000017 	ldw	r16,0(sp)
8111ee1c:	dec00304 	addi	sp,sp,12
8111ee20:	f800283a 	ret
8111ee24:	000d883a 	mov	r6,zero
8111ee28:	01d07834 	movhi	r7,16864
8111ee2c:	8809883a 	mov	r4,r17
8111ee30:	800b883a 	mov	r5,r16
8111ee34:	11200bc0 	call	811200bc <__subdf3>
8111ee38:	180b883a 	mov	r5,r3
8111ee3c:	1009883a 	mov	r4,r2
8111ee40:	11209c00 	call	811209c0 <__fixdfsi>
8111ee44:	00e00034 	movhi	r3,32768
8111ee48:	10c5883a 	add	r2,r2,r3
8111ee4c:	003ff006 	br	8111ee10 <__reset+0xfb0fee10>

8111ee50 <__divsf3>:
8111ee50:	defff504 	addi	sp,sp,-44
8111ee54:	200cd5fa 	srli	r6,r4,23
8111ee58:	de00012e 	bgeu	sp,et,8111ee60 <__divsf3+0x10>
8111ee5c:	003b68fa 	trap	3
8111ee60:	dcc00415 	stw	r19,16(sp)
8111ee64:	2026d7fa 	srli	r19,r4,31
8111ee68:	00c02034 	movhi	r3,128
8111ee6c:	dd800715 	stw	r22,28(sp)
8111ee70:	dd000515 	stw	r20,20(sp)
8111ee74:	dc800315 	stw	r18,12(sp)
8111ee78:	18ffffc4 	addi	r3,r3,-1
8111ee7c:	dfc00a15 	stw	ra,40(sp)
8111ee80:	df000915 	stw	fp,36(sp)
8111ee84:	ddc00815 	stw	r23,32(sp)
8111ee88:	dd400615 	stw	r21,24(sp)
8111ee8c:	dc400215 	stw	r17,8(sp)
8111ee90:	dc000115 	stw	r16,4(sp)
8111ee94:	35003fcc 	andi	r20,r6,255
8111ee98:	1924703a 	and	r18,r3,r4
8111ee9c:	9d803fcc 	andi	r22,r19,255
8111eea0:	a0005226 	beq	r20,zero,8111efec <__divsf3+0x19c>
8111eea4:	00803fc4 	movi	r2,255
8111eea8:	a0802e26 	beq	r20,r2,8111ef64 <__divsf3+0x114>
8111eeac:	91002034 	orhi	r4,r18,128
8111eeb0:	202490fa 	slli	r18,r4,3
8111eeb4:	a53fe044 	addi	r20,r20,-127
8111eeb8:	0021883a 	mov	r16,zero
8111eebc:	002f883a 	mov	r23,zero
8111eec0:	280cd5fa 	srli	r6,r5,23
8111eec4:	282ad7fa 	srli	r21,r5,31
8111eec8:	00c02034 	movhi	r3,128
8111eecc:	18ffffc4 	addi	r3,r3,-1
8111eed0:	31803fcc 	andi	r6,r6,255
8111eed4:	1962703a 	and	r17,r3,r5
8111eed8:	af003fcc 	andi	fp,r21,255
8111eedc:	30004a26 	beq	r6,zero,8111f008 <__divsf3+0x1b8>
8111eee0:	00803fc4 	movi	r2,255
8111eee4:	30804526 	beq	r6,r2,8111effc <__divsf3+0x1ac>
8111eee8:	89402034 	orhi	r5,r17,128
8111eeec:	282290fa 	slli	r17,r5,3
8111eef0:	31bfe044 	addi	r6,r6,-127
8111eef4:	000b883a 	mov	r5,zero
8111eef8:	2c20b03a 	or	r16,r5,r16
8111eefc:	802090ba 	slli	r16,r16,2
8111ef00:	00a044b4 	movhi	r2,33042
8111ef04:	10bbc904 	addi	r2,r2,-4316
8111ef08:	80a1883a 	add	r16,r16,r2
8111ef0c:	81000017 	ldw	r4,0(r16)
8111ef10:	9d46f03a 	xor	r3,r19,r21
8111ef14:	180f883a 	mov	r7,r3
8111ef18:	18803fcc 	andi	r2,r3,255
8111ef1c:	a18dc83a 	sub	r6,r20,r6
8111ef20:	2000683a 	jmp	r4
8111ef24:	8111f108 	cmpgei	r4,r16,18372
8111ef28:	8111ef8c 	andi	r4,r16,18366
8111ef2c:	8111f0fc 	xorhi	r4,r16,18371
8111ef30:	8111ef78 	rdprs	r4,r16,18365
8111ef34:	8111f0fc 	xorhi	r4,r16,18371
8111ef38:	8111f0d4 	ori	r4,r16,18371
8111ef3c:	8111f0fc 	xorhi	r4,r16,18371
8111ef40:	8111ef78 	rdprs	r4,r16,18365
8111ef44:	8111ef8c 	andi	r4,r16,18366
8111ef48:	8111ef8c 	andi	r4,r16,18366
8111ef4c:	8111f0d4 	ori	r4,r16,18371
8111ef50:	8111ef78 	rdprs	r4,r16,18365
8111ef54:	8111f1e8 	cmpgeui	r4,r16,18375
8111ef58:	8111f1e8 	cmpgeui	r4,r16,18375
8111ef5c:	8111f1e8 	cmpgeui	r4,r16,18375
8111ef60:	8111f19c 	xori	r4,r16,18374
8111ef64:	9000581e 	bne	r18,zero,8111f0c8 <__divsf3+0x278>
8111ef68:	04000204 	movi	r16,8
8111ef6c:	05c00084 	movi	r23,2
8111ef70:	003fd306 	br	8111eec0 <__reset+0xfb0feec0>
8111ef74:	0023883a 	mov	r17,zero
8111ef78:	e02d883a 	mov	r22,fp
8111ef7c:	282f883a 	mov	r23,r5
8111ef80:	00800084 	movi	r2,2
8111ef84:	b8808f1e 	bne	r23,r2,8111f1c4 <__divsf3+0x374>
8111ef88:	b005883a 	mov	r2,r22
8111ef8c:	11c0004c 	andi	r7,r2,1
8111ef90:	013fffc4 	movi	r4,-1
8111ef94:	000d883a 	mov	r6,zero
8111ef98:	21003fcc 	andi	r4,r4,255
8111ef9c:	200895fa 	slli	r4,r4,23
8111efa0:	38803fcc 	andi	r2,r7,255
8111efa4:	00c02034 	movhi	r3,128
8111efa8:	100497fa 	slli	r2,r2,31
8111efac:	18ffffc4 	addi	r3,r3,-1
8111efb0:	30c6703a 	and	r3,r6,r3
8111efb4:	1906b03a 	or	r3,r3,r4
8111efb8:	1884b03a 	or	r2,r3,r2
8111efbc:	dfc00a17 	ldw	ra,40(sp)
8111efc0:	df000917 	ldw	fp,36(sp)
8111efc4:	ddc00817 	ldw	r23,32(sp)
8111efc8:	dd800717 	ldw	r22,28(sp)
8111efcc:	dd400617 	ldw	r21,24(sp)
8111efd0:	dd000517 	ldw	r20,20(sp)
8111efd4:	dcc00417 	ldw	r19,16(sp)
8111efd8:	dc800317 	ldw	r18,12(sp)
8111efdc:	dc400217 	ldw	r17,8(sp)
8111efe0:	dc000117 	ldw	r16,4(sp)
8111efe4:	dec00b04 	addi	sp,sp,44
8111efe8:	f800283a 	ret
8111efec:	90002b1e 	bne	r18,zero,8111f09c <__divsf3+0x24c>
8111eff0:	04000104 	movi	r16,4
8111eff4:	05c00044 	movi	r23,1
8111eff8:	003fb106 	br	8111eec0 <__reset+0xfb0feec0>
8111effc:	8800251e 	bne	r17,zero,8111f094 <__divsf3+0x244>
8111f000:	01400084 	movi	r5,2
8111f004:	00000206 	br	8111f010 <__divsf3+0x1c0>
8111f008:	88001a1e 	bne	r17,zero,8111f074 <__divsf3+0x224>
8111f00c:	01400044 	movi	r5,1
8111f010:	8160b03a 	or	r16,r16,r5
8111f014:	802090ba 	slli	r16,r16,2
8111f018:	00e044b4 	movhi	r3,33042
8111f01c:	18fc0d04 	addi	r3,r3,-4044
8111f020:	80e1883a 	add	r16,r16,r3
8111f024:	80c00017 	ldw	r3,0(r16)
8111f028:	9d44f03a 	xor	r2,r19,r21
8111f02c:	a18dc83a 	sub	r6,r20,r6
8111f030:	1800683a 	jmp	r3
8111f034:	8111ef8c 	andi	r4,r16,18366
8111f038:	8111ef8c 	andi	r4,r16,18366
8111f03c:	8111f1d8 	cmpnei	r4,r16,18375
8111f040:	8111ef74 	orhi	r4,r16,18365
8111f044:	8111f1d8 	cmpnei	r4,r16,18375
8111f048:	8111f0d4 	ori	r4,r16,18371
8111f04c:	8111f1d8 	cmpnei	r4,r16,18375
8111f050:	8111ef74 	orhi	r4,r16,18365
8111f054:	8111ef8c 	andi	r4,r16,18366
8111f058:	8111ef8c 	andi	r4,r16,18366
8111f05c:	8111f0d4 	ori	r4,r16,18371
8111f060:	8111ef74 	orhi	r4,r16,18365
8111f064:	8111f1e8 	cmpgeui	r4,r16,18375
8111f068:	8111f1e8 	cmpgeui	r4,r16,18375
8111f06c:	8111f1e8 	cmpgeui	r4,r16,18375
8111f070:	8111f200 	call	88111f20 <__reset+0x20f1f20>
8111f074:	8809883a 	mov	r4,r17
8111f078:	1120de40 	call	81120de4 <__clzsi2>
8111f07c:	10fffec4 	addi	r3,r2,-5
8111f080:	10801d84 	addi	r2,r2,118
8111f084:	88e2983a 	sll	r17,r17,r3
8111f088:	008dc83a 	sub	r6,zero,r2
8111f08c:	000b883a 	mov	r5,zero
8111f090:	003f9906 	br	8111eef8 <__reset+0xfb0feef8>
8111f094:	014000c4 	movi	r5,3
8111f098:	003f9706 	br	8111eef8 <__reset+0xfb0feef8>
8111f09c:	9009883a 	mov	r4,r18
8111f0a0:	d9400015 	stw	r5,0(sp)
8111f0a4:	1120de40 	call	81120de4 <__clzsi2>
8111f0a8:	10fffec4 	addi	r3,r2,-5
8111f0ac:	11801d84 	addi	r6,r2,118
8111f0b0:	90e4983a 	sll	r18,r18,r3
8111f0b4:	01a9c83a 	sub	r20,zero,r6
8111f0b8:	0021883a 	mov	r16,zero
8111f0bc:	002f883a 	mov	r23,zero
8111f0c0:	d9400017 	ldw	r5,0(sp)
8111f0c4:	003f7e06 	br	8111eec0 <__reset+0xfb0feec0>
8111f0c8:	04000304 	movi	r16,12
8111f0cc:	05c000c4 	movi	r23,3
8111f0d0:	003f7b06 	br	8111eec0 <__reset+0xfb0feec0>
8111f0d4:	01802034 	movhi	r6,128
8111f0d8:	000f883a 	mov	r7,zero
8111f0dc:	31bfffc4 	addi	r6,r6,-1
8111f0e0:	013fffc4 	movi	r4,-1
8111f0e4:	003fac06 	br	8111ef98 <__reset+0xfb0fef98>
8111f0e8:	01400044 	movi	r5,1
8111f0ec:	2909c83a 	sub	r4,r5,r4
8111f0f0:	00c006c4 	movi	r3,27
8111f0f4:	19004b0e 	bge	r3,r4,8111f224 <__divsf3+0x3d4>
8111f0f8:	114e703a 	and	r7,r2,r5
8111f0fc:	0009883a 	mov	r4,zero
8111f100:	000d883a 	mov	r6,zero
8111f104:	003fa406 	br	8111ef98 <__reset+0xfb0fef98>
8111f108:	9006917a 	slli	r3,r18,5
8111f10c:	8822917a 	slli	r17,r17,5
8111f110:	1c40372e 	bgeu	r3,r17,8111f1f0 <__divsf3+0x3a0>
8111f114:	31bfffc4 	addi	r6,r6,-1
8111f118:	010006c4 	movi	r4,27
8111f11c:	000b883a 	mov	r5,zero
8111f120:	180f883a 	mov	r7,r3
8111f124:	294b883a 	add	r5,r5,r5
8111f128:	18c7883a 	add	r3,r3,r3
8111f12c:	38000116 	blt	r7,zero,8111f134 <__divsf3+0x2e4>
8111f130:	1c400236 	bltu	r3,r17,8111f13c <__divsf3+0x2ec>
8111f134:	1c47c83a 	sub	r3,r3,r17
8111f138:	29400054 	ori	r5,r5,1
8111f13c:	213fffc4 	addi	r4,r4,-1
8111f140:	203ff71e 	bne	r4,zero,8111f120 <__reset+0xfb0ff120>
8111f144:	1806c03a 	cmpne	r3,r3,zero
8111f148:	1962b03a 	or	r17,r3,r5
8111f14c:	31001fc4 	addi	r4,r6,127
8111f150:	013fe50e 	bge	zero,r4,8111f0e8 <__reset+0xfb0ff0e8>
8111f154:	88c001cc 	andi	r3,r17,7
8111f158:	18000426 	beq	r3,zero,8111f16c <__divsf3+0x31c>
8111f15c:	88c003cc 	andi	r3,r17,15
8111f160:	01400104 	movi	r5,4
8111f164:	19400126 	beq	r3,r5,8111f16c <__divsf3+0x31c>
8111f168:	8963883a 	add	r17,r17,r5
8111f16c:	88c2002c 	andhi	r3,r17,2048
8111f170:	18000426 	beq	r3,zero,8111f184 <__divsf3+0x334>
8111f174:	00fe0034 	movhi	r3,63488
8111f178:	18ffffc4 	addi	r3,r3,-1
8111f17c:	31002004 	addi	r4,r6,128
8111f180:	88e2703a 	and	r17,r17,r3
8111f184:	00c03f84 	movi	r3,254
8111f188:	193f8016 	blt	r3,r4,8111ef8c <__reset+0xfb0fef8c>
8111f18c:	880c91ba 	slli	r6,r17,6
8111f190:	11c0004c 	andi	r7,r2,1
8111f194:	300cd27a 	srli	r6,r6,9
8111f198:	003f7f06 	br	8111ef98 <__reset+0xfb0fef98>
8111f19c:	9080102c 	andhi	r2,r18,64
8111f1a0:	10000226 	beq	r2,zero,8111f1ac <__divsf3+0x35c>
8111f1a4:	8880102c 	andhi	r2,r17,64
8111f1a8:	10001826 	beq	r2,zero,8111f20c <__divsf3+0x3bc>
8111f1ac:	00802034 	movhi	r2,128
8111f1b0:	91801034 	orhi	r6,r18,64
8111f1b4:	10bfffc4 	addi	r2,r2,-1
8111f1b8:	980f883a 	mov	r7,r19
8111f1bc:	308c703a 	and	r6,r6,r2
8111f1c0:	003fc706 	br	8111f0e0 <__reset+0xfb0ff0e0>
8111f1c4:	008000c4 	movi	r2,3
8111f1c8:	b8802d26 	beq	r23,r2,8111f280 <__divsf3+0x430>
8111f1cc:	00c00044 	movi	r3,1
8111f1d0:	b005883a 	mov	r2,r22
8111f1d4:	b8ffdd1e 	bne	r23,r3,8111f14c <__reset+0xfb0ff14c>
8111f1d8:	11c0004c 	andi	r7,r2,1
8111f1dc:	0009883a 	mov	r4,zero
8111f1e0:	000d883a 	mov	r6,zero
8111f1e4:	003f6c06 	br	8111ef98 <__reset+0xfb0fef98>
8111f1e8:	9023883a 	mov	r17,r18
8111f1ec:	003f6406 	br	8111ef80 <__reset+0xfb0fef80>
8111f1f0:	1c47c83a 	sub	r3,r3,r17
8111f1f4:	01000684 	movi	r4,26
8111f1f8:	01400044 	movi	r5,1
8111f1fc:	003fc806 	br	8111f120 <__reset+0xfb0ff120>
8111f200:	9080102c 	andhi	r2,r18,64
8111f204:	103fe926 	beq	r2,zero,8111f1ac <__reset+0xfb0ff1ac>
8111f208:	0023883a 	mov	r17,zero
8111f20c:	00802034 	movhi	r2,128
8111f210:	89801034 	orhi	r6,r17,64
8111f214:	10bfffc4 	addi	r2,r2,-1
8111f218:	a80f883a 	mov	r7,r21
8111f21c:	308c703a 	and	r6,r6,r2
8111f220:	003faf06 	br	8111f0e0 <__reset+0xfb0ff0e0>
8111f224:	01c00804 	movi	r7,32
8111f228:	390fc83a 	sub	r7,r7,r4
8111f22c:	89ce983a 	sll	r7,r17,r7
8111f230:	890ad83a 	srl	r5,r17,r4
8111f234:	380ec03a 	cmpne	r7,r7,zero
8111f238:	29cab03a 	or	r5,r5,r7
8111f23c:	28c001cc 	andi	r3,r5,7
8111f240:	18000426 	beq	r3,zero,8111f254 <__divsf3+0x404>
8111f244:	28c003cc 	andi	r3,r5,15
8111f248:	01000104 	movi	r4,4
8111f24c:	19000126 	beq	r3,r4,8111f254 <__divsf3+0x404>
8111f250:	290b883a 	add	r5,r5,r4
8111f254:	28c1002c 	andhi	r3,r5,1024
8111f258:	18000426 	beq	r3,zero,8111f26c <__divsf3+0x41c>
8111f25c:	11c0004c 	andi	r7,r2,1
8111f260:	01000044 	movi	r4,1
8111f264:	000d883a 	mov	r6,zero
8111f268:	003f4b06 	br	8111ef98 <__reset+0xfb0fef98>
8111f26c:	280a91ba 	slli	r5,r5,6
8111f270:	11c0004c 	andi	r7,r2,1
8111f274:	0009883a 	mov	r4,zero
8111f278:	280cd27a 	srli	r6,r5,9
8111f27c:	003f4606 	br	8111ef98 <__reset+0xfb0fef98>
8111f280:	00802034 	movhi	r2,128
8111f284:	89801034 	orhi	r6,r17,64
8111f288:	10bfffc4 	addi	r2,r2,-1
8111f28c:	b00f883a 	mov	r7,r22
8111f290:	308c703a 	and	r6,r6,r2
8111f294:	003f9206 	br	8111f0e0 <__reset+0xfb0ff0e0>

8111f298 <__mulsf3>:
8111f298:	defff504 	addi	sp,sp,-44
8111f29c:	de00012e 	bgeu	sp,et,8111f2a4 <__mulsf3+0xc>
8111f2a0:	003b68fa 	trap	3
8111f2a4:	dc000115 	stw	r16,4(sp)
8111f2a8:	2020d5fa 	srli	r16,r4,23
8111f2ac:	dd400615 	stw	r21,24(sp)
8111f2b0:	202ad7fa 	srli	r21,r4,31
8111f2b4:	dc800315 	stw	r18,12(sp)
8111f2b8:	04802034 	movhi	r18,128
8111f2bc:	df000915 	stw	fp,36(sp)
8111f2c0:	dd000515 	stw	r20,20(sp)
8111f2c4:	94bfffc4 	addi	r18,r18,-1
8111f2c8:	dfc00a15 	stw	ra,40(sp)
8111f2cc:	ddc00815 	stw	r23,32(sp)
8111f2d0:	dd800715 	stw	r22,28(sp)
8111f2d4:	dcc00415 	stw	r19,16(sp)
8111f2d8:	dc400215 	stw	r17,8(sp)
8111f2dc:	84003fcc 	andi	r16,r16,255
8111f2e0:	9124703a 	and	r18,r18,r4
8111f2e4:	a829883a 	mov	r20,r21
8111f2e8:	af003fcc 	andi	fp,r21,255
8111f2ec:	80005426 	beq	r16,zero,8111f440 <__mulsf3+0x1a8>
8111f2f0:	00803fc4 	movi	r2,255
8111f2f4:	80802f26 	beq	r16,r2,8111f3b4 <__mulsf3+0x11c>
8111f2f8:	91002034 	orhi	r4,r18,128
8111f2fc:	202490fa 	slli	r18,r4,3
8111f300:	843fe044 	addi	r16,r16,-127
8111f304:	0023883a 	mov	r17,zero
8111f308:	002f883a 	mov	r23,zero
8111f30c:	2804d5fa 	srli	r2,r5,23
8111f310:	282cd7fa 	srli	r22,r5,31
8111f314:	01002034 	movhi	r4,128
8111f318:	213fffc4 	addi	r4,r4,-1
8111f31c:	10803fcc 	andi	r2,r2,255
8111f320:	2166703a 	and	r19,r4,r5
8111f324:	b1803fcc 	andi	r6,r22,255
8111f328:	10004c26 	beq	r2,zero,8111f45c <__mulsf3+0x1c4>
8111f32c:	00c03fc4 	movi	r3,255
8111f330:	10c04726 	beq	r2,r3,8111f450 <__mulsf3+0x1b8>
8111f334:	99002034 	orhi	r4,r19,128
8111f338:	202690fa 	slli	r19,r4,3
8111f33c:	10bfe044 	addi	r2,r2,-127
8111f340:	0007883a 	mov	r3,zero
8111f344:	80a1883a 	add	r16,r16,r2
8111f348:	010003c4 	movi	r4,15
8111f34c:	1c44b03a 	or	r2,r3,r17
8111f350:	b56af03a 	xor	r21,r22,r21
8111f354:	81c00044 	addi	r7,r16,1
8111f358:	20806b36 	bltu	r4,r2,8111f508 <__mulsf3+0x270>
8111f35c:	100490ba 	slli	r2,r2,2
8111f360:	012044b4 	movhi	r4,33042
8111f364:	213cdd04 	addi	r4,r4,-3212
8111f368:	1105883a 	add	r2,r2,r4
8111f36c:	10800017 	ldw	r2,0(r2)
8111f370:	1000683a 	jmp	r2
8111f374:	8111f508 	cmpgei	r4,r16,18388
8111f378:	8111f3c8 	cmpgei	r4,r16,18383
8111f37c:	8111f3c8 	cmpgei	r4,r16,18383
8111f380:	8111f3c4 	addi	r4,r16,18383
8111f384:	8111f4ec 	andhi	r4,r16,18387
8111f388:	8111f4ec 	andhi	r4,r16,18387
8111f38c:	8111f4d8 	cmpnei	r4,r16,18387
8111f390:	8111f3c4 	addi	r4,r16,18383
8111f394:	8111f4ec 	andhi	r4,r16,18387
8111f398:	8111f4d8 	cmpnei	r4,r16,18387
8111f39c:	8111f4ec 	andhi	r4,r16,18387
8111f3a0:	8111f3c4 	addi	r4,r16,18383
8111f3a4:	8111f4f8 	rdprs	r4,r16,18387
8111f3a8:	8111f4f8 	rdprs	r4,r16,18387
8111f3ac:	8111f4f8 	rdprs	r4,r16,18387
8111f3b0:	8111f5d4 	ori	r4,r16,18391
8111f3b4:	90003b1e 	bne	r18,zero,8111f4a4 <__mulsf3+0x20c>
8111f3b8:	04400204 	movi	r17,8
8111f3bc:	05c00084 	movi	r23,2
8111f3c0:	003fd206 	br	8111f30c <__reset+0xfb0ff30c>
8111f3c4:	302b883a 	mov	r21,r6
8111f3c8:	00800084 	movi	r2,2
8111f3cc:	18802626 	beq	r3,r2,8111f468 <__mulsf3+0x1d0>
8111f3d0:	008000c4 	movi	r2,3
8111f3d4:	1880ab26 	beq	r3,r2,8111f684 <__mulsf3+0x3ec>
8111f3d8:	00800044 	movi	r2,1
8111f3dc:	1880a21e 	bne	r3,r2,8111f668 <__mulsf3+0x3d0>
8111f3e0:	a829883a 	mov	r20,r21
8111f3e4:	0007883a 	mov	r3,zero
8111f3e8:	0009883a 	mov	r4,zero
8111f3ec:	18803fcc 	andi	r2,r3,255
8111f3f0:	100695fa 	slli	r3,r2,23
8111f3f4:	a0803fcc 	andi	r2,r20,255
8111f3f8:	100a97fa 	slli	r5,r2,31
8111f3fc:	00802034 	movhi	r2,128
8111f400:	10bfffc4 	addi	r2,r2,-1
8111f404:	2084703a 	and	r2,r4,r2
8111f408:	10c4b03a 	or	r2,r2,r3
8111f40c:	1144b03a 	or	r2,r2,r5
8111f410:	dfc00a17 	ldw	ra,40(sp)
8111f414:	df000917 	ldw	fp,36(sp)
8111f418:	ddc00817 	ldw	r23,32(sp)
8111f41c:	dd800717 	ldw	r22,28(sp)
8111f420:	dd400617 	ldw	r21,24(sp)
8111f424:	dd000517 	ldw	r20,20(sp)
8111f428:	dcc00417 	ldw	r19,16(sp)
8111f42c:	dc800317 	ldw	r18,12(sp)
8111f430:	dc400217 	ldw	r17,8(sp)
8111f434:	dc000117 	ldw	r16,4(sp)
8111f438:	dec00b04 	addi	sp,sp,44
8111f43c:	f800283a 	ret
8111f440:	90000d1e 	bne	r18,zero,8111f478 <__mulsf3+0x1e0>
8111f444:	04400104 	movi	r17,4
8111f448:	05c00044 	movi	r23,1
8111f44c:	003faf06 	br	8111f30c <__reset+0xfb0ff30c>
8111f450:	9806c03a 	cmpne	r3,r19,zero
8111f454:	18c00084 	addi	r3,r3,2
8111f458:	003fba06 	br	8111f344 <__reset+0xfb0ff344>
8111f45c:	9800141e 	bne	r19,zero,8111f4b0 <__mulsf3+0x218>
8111f460:	00c00044 	movi	r3,1
8111f464:	003fb706 	br	8111f344 <__reset+0xfb0ff344>
8111f468:	a829883a 	mov	r20,r21
8111f46c:	00ffffc4 	movi	r3,-1
8111f470:	0009883a 	mov	r4,zero
8111f474:	003fdd06 	br	8111f3ec <__reset+0xfb0ff3ec>
8111f478:	9009883a 	mov	r4,r18
8111f47c:	d9400015 	stw	r5,0(sp)
8111f480:	1120de40 	call	81120de4 <__clzsi2>
8111f484:	10fffec4 	addi	r3,r2,-5
8111f488:	10801d84 	addi	r2,r2,118
8111f48c:	90e4983a 	sll	r18,r18,r3
8111f490:	00a1c83a 	sub	r16,zero,r2
8111f494:	0023883a 	mov	r17,zero
8111f498:	002f883a 	mov	r23,zero
8111f49c:	d9400017 	ldw	r5,0(sp)
8111f4a0:	003f9a06 	br	8111f30c <__reset+0xfb0ff30c>
8111f4a4:	04400304 	movi	r17,12
8111f4a8:	05c000c4 	movi	r23,3
8111f4ac:	003f9706 	br	8111f30c <__reset+0xfb0ff30c>
8111f4b0:	9809883a 	mov	r4,r19
8111f4b4:	d9800015 	stw	r6,0(sp)
8111f4b8:	1120de40 	call	81120de4 <__clzsi2>
8111f4bc:	10fffec4 	addi	r3,r2,-5
8111f4c0:	10801d84 	addi	r2,r2,118
8111f4c4:	98e6983a 	sll	r19,r19,r3
8111f4c8:	0085c83a 	sub	r2,zero,r2
8111f4cc:	0007883a 	mov	r3,zero
8111f4d0:	d9800017 	ldw	r6,0(sp)
8111f4d4:	003f9b06 	br	8111f344 <__reset+0xfb0ff344>
8111f4d8:	01002034 	movhi	r4,128
8111f4dc:	0029883a 	mov	r20,zero
8111f4e0:	213fffc4 	addi	r4,r4,-1
8111f4e4:	00ffffc4 	movi	r3,-1
8111f4e8:	003fc006 	br	8111f3ec <__reset+0xfb0ff3ec>
8111f4ec:	9027883a 	mov	r19,r18
8111f4f0:	b807883a 	mov	r3,r23
8111f4f4:	003fb406 	br	8111f3c8 <__reset+0xfb0ff3c8>
8111f4f8:	9027883a 	mov	r19,r18
8111f4fc:	e02b883a 	mov	r21,fp
8111f500:	b807883a 	mov	r3,r23
8111f504:	003fb006 	br	8111f3c8 <__reset+0xfb0ff3c8>
8111f508:	9004d43a 	srli	r2,r18,16
8111f50c:	9810d43a 	srli	r8,r19,16
8111f510:	94bfffcc 	andi	r18,r18,65535
8111f514:	993fffcc 	andi	r4,r19,65535
8111f518:	910d383a 	mul	r6,r18,r4
8111f51c:	20a7383a 	mul	r19,r4,r2
8111f520:	9225383a 	mul	r18,r18,r8
8111f524:	3006d43a 	srli	r3,r6,16
8111f528:	1211383a 	mul	r8,r2,r8
8111f52c:	94e5883a 	add	r18,r18,r19
8111f530:	1c87883a 	add	r3,r3,r18
8111f534:	1cc0022e 	bgeu	r3,r19,8111f540 <__mulsf3+0x2a8>
8111f538:	00800074 	movhi	r2,1
8111f53c:	4091883a 	add	r8,r8,r2
8111f540:	1804943a 	slli	r2,r3,16
8111f544:	31bfffcc 	andi	r6,r6,65535
8111f548:	1806d43a 	srli	r3,r3,16
8111f54c:	1185883a 	add	r2,r2,r6
8111f550:	102691ba 	slli	r19,r2,6
8111f554:	1a07883a 	add	r3,r3,r8
8111f558:	1004d6ba 	srli	r2,r2,26
8111f55c:	180891ba 	slli	r4,r3,6
8111f560:	9826c03a 	cmpne	r19,r19,zero
8111f564:	9884b03a 	or	r2,r19,r2
8111f568:	1126b03a 	or	r19,r2,r4
8111f56c:	9882002c 	andhi	r2,r19,2048
8111f570:	10000426 	beq	r2,zero,8111f584 <__mulsf3+0x2ec>
8111f574:	9804d07a 	srli	r2,r19,1
8111f578:	9900004c 	andi	r4,r19,1
8111f57c:	3821883a 	mov	r16,r7
8111f580:	1126b03a 	or	r19,r2,r4
8111f584:	80c01fc4 	addi	r3,r16,127
8111f588:	00c0210e 	bge	zero,r3,8111f610 <__mulsf3+0x378>
8111f58c:	988001cc 	andi	r2,r19,7
8111f590:	10000426 	beq	r2,zero,8111f5a4 <__mulsf3+0x30c>
8111f594:	988003cc 	andi	r2,r19,15
8111f598:	01000104 	movi	r4,4
8111f59c:	11000126 	beq	r2,r4,8111f5a4 <__mulsf3+0x30c>
8111f5a0:	9927883a 	add	r19,r19,r4
8111f5a4:	9882002c 	andhi	r2,r19,2048
8111f5a8:	10000426 	beq	r2,zero,8111f5bc <__mulsf3+0x324>
8111f5ac:	00be0034 	movhi	r2,63488
8111f5b0:	10bfffc4 	addi	r2,r2,-1
8111f5b4:	80c02004 	addi	r3,r16,128
8111f5b8:	98a6703a 	and	r19,r19,r2
8111f5bc:	00803f84 	movi	r2,254
8111f5c0:	10ffa916 	blt	r2,r3,8111f468 <__reset+0xfb0ff468>
8111f5c4:	980891ba 	slli	r4,r19,6
8111f5c8:	a829883a 	mov	r20,r21
8111f5cc:	2008d27a 	srli	r4,r4,9
8111f5d0:	003f8606 	br	8111f3ec <__reset+0xfb0ff3ec>
8111f5d4:	9080102c 	andhi	r2,r18,64
8111f5d8:	10000826 	beq	r2,zero,8111f5fc <__mulsf3+0x364>
8111f5dc:	9880102c 	andhi	r2,r19,64
8111f5e0:	1000061e 	bne	r2,zero,8111f5fc <__mulsf3+0x364>
8111f5e4:	00802034 	movhi	r2,128
8111f5e8:	99001034 	orhi	r4,r19,64
8111f5ec:	10bfffc4 	addi	r2,r2,-1
8111f5f0:	b029883a 	mov	r20,r22
8111f5f4:	2088703a 	and	r4,r4,r2
8111f5f8:	003fba06 	br	8111f4e4 <__reset+0xfb0ff4e4>
8111f5fc:	00802034 	movhi	r2,128
8111f600:	91001034 	orhi	r4,r18,64
8111f604:	10bfffc4 	addi	r2,r2,-1
8111f608:	2088703a 	and	r4,r4,r2
8111f60c:	003fb506 	br	8111f4e4 <__reset+0xfb0ff4e4>
8111f610:	00800044 	movi	r2,1
8111f614:	10c7c83a 	sub	r3,r2,r3
8111f618:	008006c4 	movi	r2,27
8111f61c:	10ff7016 	blt	r2,r3,8111f3e0 <__reset+0xfb0ff3e0>
8111f620:	00800804 	movi	r2,32
8111f624:	10c5c83a 	sub	r2,r2,r3
8111f628:	9884983a 	sll	r2,r19,r2
8111f62c:	98c6d83a 	srl	r3,r19,r3
8111f630:	1004c03a 	cmpne	r2,r2,zero
8111f634:	1884b03a 	or	r2,r3,r2
8111f638:	10c001cc 	andi	r3,r2,7
8111f63c:	18000426 	beq	r3,zero,8111f650 <__mulsf3+0x3b8>
8111f640:	10c003cc 	andi	r3,r2,15
8111f644:	01000104 	movi	r4,4
8111f648:	19000126 	beq	r3,r4,8111f650 <__mulsf3+0x3b8>
8111f64c:	1105883a 	add	r2,r2,r4
8111f650:	10c1002c 	andhi	r3,r2,1024
8111f654:	18000626 	beq	r3,zero,8111f670 <__mulsf3+0x3d8>
8111f658:	a829883a 	mov	r20,r21
8111f65c:	00c00044 	movi	r3,1
8111f660:	0009883a 	mov	r4,zero
8111f664:	003f6106 	br	8111f3ec <__reset+0xfb0ff3ec>
8111f668:	3821883a 	mov	r16,r7
8111f66c:	003fc506 	br	8111f584 <__reset+0xfb0ff584>
8111f670:	100491ba 	slli	r2,r2,6
8111f674:	a829883a 	mov	r20,r21
8111f678:	0007883a 	mov	r3,zero
8111f67c:	1008d27a 	srli	r4,r2,9
8111f680:	003f5a06 	br	8111f3ec <__reset+0xfb0ff3ec>
8111f684:	00802034 	movhi	r2,128
8111f688:	99001034 	orhi	r4,r19,64
8111f68c:	10bfffc4 	addi	r2,r2,-1
8111f690:	a829883a 	mov	r20,r21
8111f694:	2088703a 	and	r4,r4,r2
8111f698:	003f9206 	br	8111f4e4 <__reset+0xfb0ff4e4>

8111f69c <__floatsisf>:
8111f69c:	defffd04 	addi	sp,sp,-12
8111f6a0:	de00012e 	bgeu	sp,et,8111f6a8 <__floatsisf+0xc>
8111f6a4:	003b68fa 	trap	3
8111f6a8:	dfc00215 	stw	ra,8(sp)
8111f6ac:	dc400115 	stw	r17,4(sp)
8111f6b0:	dc000015 	stw	r16,0(sp)
8111f6b4:	20003526 	beq	r4,zero,8111f78c <__floatsisf+0xf0>
8111f6b8:	2021883a 	mov	r16,r4
8111f6bc:	2022d7fa 	srli	r17,r4,31
8111f6c0:	20003616 	blt	r4,zero,8111f79c <__floatsisf+0x100>
8111f6c4:	8009883a 	mov	r4,r16
8111f6c8:	1120de40 	call	81120de4 <__clzsi2>
8111f6cc:	00c02784 	movi	r3,158
8111f6d0:	1887c83a 	sub	r3,r3,r2
8111f6d4:	01002584 	movi	r4,150
8111f6d8:	20c01416 	blt	r4,r3,8111f72c <__floatsisf+0x90>
8111f6dc:	20c9c83a 	sub	r4,r4,r3
8111f6e0:	8120983a 	sll	r16,r16,r4
8111f6e4:	00802034 	movhi	r2,128
8111f6e8:	10bfffc4 	addi	r2,r2,-1
8111f6ec:	8809883a 	mov	r4,r17
8111f6f0:	80a0703a 	and	r16,r16,r2
8111f6f4:	18803fcc 	andi	r2,r3,255
8111f6f8:	100695fa 	slli	r3,r2,23
8111f6fc:	20803fcc 	andi	r2,r4,255
8111f700:	100897fa 	slli	r4,r2,31
8111f704:	00802034 	movhi	r2,128
8111f708:	10bfffc4 	addi	r2,r2,-1
8111f70c:	8084703a 	and	r2,r16,r2
8111f710:	10c4b03a 	or	r2,r2,r3
8111f714:	1104b03a 	or	r2,r2,r4
8111f718:	dfc00217 	ldw	ra,8(sp)
8111f71c:	dc400117 	ldw	r17,4(sp)
8111f720:	dc000017 	ldw	r16,0(sp)
8111f724:	dec00304 	addi	sp,sp,12
8111f728:	f800283a 	ret
8111f72c:	01002644 	movi	r4,153
8111f730:	20c01c16 	blt	r4,r3,8111f7a4 <__floatsisf+0x108>
8111f734:	20c9c83a 	sub	r4,r4,r3
8111f738:	8120983a 	sll	r16,r16,r4
8111f73c:	013f0034 	movhi	r4,64512
8111f740:	213fffc4 	addi	r4,r4,-1
8111f744:	814001cc 	andi	r5,r16,7
8111f748:	8108703a 	and	r4,r16,r4
8111f74c:	28000426 	beq	r5,zero,8111f760 <__floatsisf+0xc4>
8111f750:	840003cc 	andi	r16,r16,15
8111f754:	01400104 	movi	r5,4
8111f758:	81400126 	beq	r16,r5,8111f760 <__floatsisf+0xc4>
8111f75c:	2149883a 	add	r4,r4,r5
8111f760:	2141002c 	andhi	r5,r4,1024
8111f764:	28000526 	beq	r5,zero,8111f77c <__floatsisf+0xe0>
8111f768:	00c027c4 	movi	r3,159
8111f76c:	1887c83a 	sub	r3,r3,r2
8111f770:	00bf0034 	movhi	r2,64512
8111f774:	10bfffc4 	addi	r2,r2,-1
8111f778:	2088703a 	and	r4,r4,r2
8111f77c:	202091ba 	slli	r16,r4,6
8111f780:	8809883a 	mov	r4,r17
8111f784:	8020d27a 	srli	r16,r16,9
8111f788:	003fda06 	br	8111f6f4 <__reset+0xfb0ff6f4>
8111f78c:	0009883a 	mov	r4,zero
8111f790:	0007883a 	mov	r3,zero
8111f794:	0021883a 	mov	r16,zero
8111f798:	003fd606 	br	8111f6f4 <__reset+0xfb0ff6f4>
8111f79c:	0121c83a 	sub	r16,zero,r4
8111f7a0:	003fc806 	br	8111f6c4 <__reset+0xfb0ff6c4>
8111f7a4:	01002e44 	movi	r4,185
8111f7a8:	20c9c83a 	sub	r4,r4,r3
8111f7ac:	01400144 	movi	r5,5
8111f7b0:	8108983a 	sll	r4,r16,r4
8111f7b4:	288bc83a 	sub	r5,r5,r2
8111f7b8:	8160d83a 	srl	r16,r16,r5
8111f7bc:	2008c03a 	cmpne	r4,r4,zero
8111f7c0:	8120b03a 	or	r16,r16,r4
8111f7c4:	003fdd06 	br	8111f73c <__reset+0xfb0ff73c>

8111f7c8 <__floatunsisf>:
8111f7c8:	defffe04 	addi	sp,sp,-8
8111f7cc:	de00012e 	bgeu	sp,et,8111f7d4 <__floatunsisf+0xc>
8111f7d0:	003b68fa 	trap	3
8111f7d4:	dfc00115 	stw	ra,4(sp)
8111f7d8:	dc000015 	stw	r16,0(sp)
8111f7dc:	20002c26 	beq	r4,zero,8111f890 <__floatunsisf+0xc8>
8111f7e0:	2021883a 	mov	r16,r4
8111f7e4:	1120de40 	call	81120de4 <__clzsi2>
8111f7e8:	00c02784 	movi	r3,158
8111f7ec:	1887c83a 	sub	r3,r3,r2
8111f7f0:	01002584 	movi	r4,150
8111f7f4:	20c00f16 	blt	r4,r3,8111f834 <__floatunsisf+0x6c>
8111f7f8:	20c9c83a 	sub	r4,r4,r3
8111f7fc:	8108983a 	sll	r4,r16,r4
8111f800:	00802034 	movhi	r2,128
8111f804:	10bfffc4 	addi	r2,r2,-1
8111f808:	2088703a 	and	r4,r4,r2
8111f80c:	18803fcc 	andi	r2,r3,255
8111f810:	100695fa 	slli	r3,r2,23
8111f814:	00802034 	movhi	r2,128
8111f818:	10bfffc4 	addi	r2,r2,-1
8111f81c:	2084703a 	and	r2,r4,r2
8111f820:	10c4b03a 	or	r2,r2,r3
8111f824:	dfc00117 	ldw	ra,4(sp)
8111f828:	dc000017 	ldw	r16,0(sp)
8111f82c:	dec00204 	addi	sp,sp,8
8111f830:	f800283a 	ret
8111f834:	01002644 	movi	r4,153
8111f838:	20c01816 	blt	r4,r3,8111f89c <__floatunsisf+0xd4>
8111f83c:	20c9c83a 	sub	r4,r4,r3
8111f840:	8108983a 	sll	r4,r16,r4
8111f844:	017f0034 	movhi	r5,64512
8111f848:	297fffc4 	addi	r5,r5,-1
8111f84c:	218001cc 	andi	r6,r4,7
8111f850:	214a703a 	and	r5,r4,r5
8111f854:	30000426 	beq	r6,zero,8111f868 <__floatunsisf+0xa0>
8111f858:	210003cc 	andi	r4,r4,15
8111f85c:	01800104 	movi	r6,4
8111f860:	21800126 	beq	r4,r6,8111f868 <__floatunsisf+0xa0>
8111f864:	298b883a 	add	r5,r5,r6
8111f868:	2901002c 	andhi	r4,r5,1024
8111f86c:	20000526 	beq	r4,zero,8111f884 <__floatunsisf+0xbc>
8111f870:	00c027c4 	movi	r3,159
8111f874:	1887c83a 	sub	r3,r3,r2
8111f878:	00bf0034 	movhi	r2,64512
8111f87c:	10bfffc4 	addi	r2,r2,-1
8111f880:	288a703a 	and	r5,r5,r2
8111f884:	280891ba 	slli	r4,r5,6
8111f888:	2008d27a 	srli	r4,r4,9
8111f88c:	003fdf06 	br	8111f80c <__reset+0xfb0ff80c>
8111f890:	0007883a 	mov	r3,zero
8111f894:	0009883a 	mov	r4,zero
8111f898:	003fdc06 	br	8111f80c <__reset+0xfb0ff80c>
8111f89c:	01402e44 	movi	r5,185
8111f8a0:	28cbc83a 	sub	r5,r5,r3
8111f8a4:	01000144 	movi	r4,5
8111f8a8:	2089c83a 	sub	r4,r4,r2
8111f8ac:	814a983a 	sll	r5,r16,r5
8111f8b0:	8108d83a 	srl	r4,r16,r4
8111f8b4:	2820c03a 	cmpne	r16,r5,zero
8111f8b8:	2408b03a 	or	r4,r4,r16
8111f8bc:	003fe106 	br	8111f844 <__reset+0xfb0ff844>

8111f8c0 <__gedf2>:
8111f8c0:	2804d53a 	srli	r2,r5,20
8111f8c4:	3806d53a 	srli	r3,r7,20
8111f8c8:	02000434 	movhi	r8,16
8111f8cc:	423fffc4 	addi	r8,r8,-1
8111f8d0:	1081ffcc 	andi	r2,r2,2047
8111f8d4:	0241ffc4 	movi	r9,2047
8111f8d8:	2a14703a 	and	r10,r5,r8
8111f8dc:	18c1ffcc 	andi	r3,r3,2047
8111f8e0:	3a10703a 	and	r8,r7,r8
8111f8e4:	280ad7fa 	srli	r5,r5,31
8111f8e8:	380ed7fa 	srli	r7,r7,31
8111f8ec:	12401d26 	beq	r2,r9,8111f964 <__gedf2+0xa4>
8111f8f0:	0241ffc4 	movi	r9,2047
8111f8f4:	1a401226 	beq	r3,r9,8111f940 <__gedf2+0x80>
8111f8f8:	1000081e 	bne	r2,zero,8111f91c <__gedf2+0x5c>
8111f8fc:	2296b03a 	or	r11,r4,r10
8111f900:	5813003a 	cmpeq	r9,r11,zero
8111f904:	1800091e 	bne	r3,zero,8111f92c <__gedf2+0x6c>
8111f908:	3218b03a 	or	r12,r6,r8
8111f90c:	6000071e 	bne	r12,zero,8111f92c <__gedf2+0x6c>
8111f910:	0005883a 	mov	r2,zero
8111f914:	5800101e 	bne	r11,zero,8111f958 <__gedf2+0x98>
8111f918:	f800283a 	ret
8111f91c:	18000c1e 	bne	r3,zero,8111f950 <__gedf2+0x90>
8111f920:	3212b03a 	or	r9,r6,r8
8111f924:	48000c26 	beq	r9,zero,8111f958 <__gedf2+0x98>
8111f928:	0013883a 	mov	r9,zero
8111f92c:	39c03fcc 	andi	r7,r7,255
8111f930:	48000826 	beq	r9,zero,8111f954 <__gedf2+0x94>
8111f934:	38000926 	beq	r7,zero,8111f95c <__gedf2+0x9c>
8111f938:	00800044 	movi	r2,1
8111f93c:	f800283a 	ret
8111f940:	3212b03a 	or	r9,r6,r8
8111f944:	483fec26 	beq	r9,zero,8111f8f8 <__reset+0xfb0ff8f8>
8111f948:	00bfff84 	movi	r2,-2
8111f94c:	f800283a 	ret
8111f950:	39c03fcc 	andi	r7,r7,255
8111f954:	29c00626 	beq	r5,r7,8111f970 <__gedf2+0xb0>
8111f958:	283ff726 	beq	r5,zero,8111f938 <__reset+0xfb0ff938>
8111f95c:	00bfffc4 	movi	r2,-1
8111f960:	f800283a 	ret
8111f964:	2292b03a 	or	r9,r4,r10
8111f968:	483fe126 	beq	r9,zero,8111f8f0 <__reset+0xfb0ff8f0>
8111f96c:	003ff606 	br	8111f948 <__reset+0xfb0ff948>
8111f970:	18bff916 	blt	r3,r2,8111f958 <__reset+0xfb0ff958>
8111f974:	10c00316 	blt	r2,r3,8111f984 <__gedf2+0xc4>
8111f978:	42bff736 	bltu	r8,r10,8111f958 <__reset+0xfb0ff958>
8111f97c:	52000326 	beq	r10,r8,8111f98c <__gedf2+0xcc>
8111f980:	5200042e 	bgeu	r10,r8,8111f994 <__gedf2+0xd4>
8111f984:	283fec1e 	bne	r5,zero,8111f938 <__reset+0xfb0ff938>
8111f988:	003ff406 	br	8111f95c <__reset+0xfb0ff95c>
8111f98c:	313ff236 	bltu	r6,r4,8111f958 <__reset+0xfb0ff958>
8111f990:	21bffc36 	bltu	r4,r6,8111f984 <__reset+0xfb0ff984>
8111f994:	0005883a 	mov	r2,zero
8111f998:	f800283a 	ret

8111f99c <__muldf3>:
8111f99c:	defff304 	addi	sp,sp,-52
8111f9a0:	2804d53a 	srli	r2,r5,20
8111f9a4:	de00012e 	bgeu	sp,et,8111f9ac <__muldf3+0x10>
8111f9a8:	003b68fa 	trap	3
8111f9ac:	dd800915 	stw	r22,36(sp)
8111f9b0:	282cd7fa 	srli	r22,r5,31
8111f9b4:	dc000315 	stw	r16,12(sp)
8111f9b8:	04000434 	movhi	r16,16
8111f9bc:	dd400815 	stw	r21,32(sp)
8111f9c0:	dc800515 	stw	r18,20(sp)
8111f9c4:	843fffc4 	addi	r16,r16,-1
8111f9c8:	dfc00c15 	stw	ra,48(sp)
8111f9cc:	df000b15 	stw	fp,44(sp)
8111f9d0:	ddc00a15 	stw	r23,40(sp)
8111f9d4:	dd000715 	stw	r20,28(sp)
8111f9d8:	dcc00615 	stw	r19,24(sp)
8111f9dc:	dc400415 	stw	r17,16(sp)
8111f9e0:	1481ffcc 	andi	r18,r2,2047
8111f9e4:	2c20703a 	and	r16,r5,r16
8111f9e8:	b02b883a 	mov	r21,r22
8111f9ec:	b2403fcc 	andi	r9,r22,255
8111f9f0:	90006026 	beq	r18,zero,8111fb74 <__muldf3+0x1d8>
8111f9f4:	0081ffc4 	movi	r2,2047
8111f9f8:	2029883a 	mov	r20,r4
8111f9fc:	90803626 	beq	r18,r2,8111fad8 <__muldf3+0x13c>
8111fa00:	80800434 	orhi	r2,r16,16
8111fa04:	100490fa 	slli	r2,r2,3
8111fa08:	2020d77a 	srli	r16,r4,29
8111fa0c:	202890fa 	slli	r20,r4,3
8111fa10:	94bf0044 	addi	r18,r18,-1023
8111fa14:	80a0b03a 	or	r16,r16,r2
8111fa18:	0027883a 	mov	r19,zero
8111fa1c:	0039883a 	mov	fp,zero
8111fa20:	3804d53a 	srli	r2,r7,20
8111fa24:	382ed7fa 	srli	r23,r7,31
8111fa28:	04400434 	movhi	r17,16
8111fa2c:	8c7fffc4 	addi	r17,r17,-1
8111fa30:	1081ffcc 	andi	r2,r2,2047
8111fa34:	3011883a 	mov	r8,r6
8111fa38:	3c62703a 	and	r17,r7,r17
8111fa3c:	ba803fcc 	andi	r10,r23,255
8111fa40:	10006d26 	beq	r2,zero,8111fbf8 <__muldf3+0x25c>
8111fa44:	00c1ffc4 	movi	r3,2047
8111fa48:	10c06526 	beq	r2,r3,8111fbe0 <__muldf3+0x244>
8111fa4c:	88c00434 	orhi	r3,r17,16
8111fa50:	180690fa 	slli	r3,r3,3
8111fa54:	3022d77a 	srli	r17,r6,29
8111fa58:	301090fa 	slli	r8,r6,3
8111fa5c:	10bf0044 	addi	r2,r2,-1023
8111fa60:	88e2b03a 	or	r17,r17,r3
8111fa64:	000b883a 	mov	r5,zero
8111fa68:	9085883a 	add	r2,r18,r2
8111fa6c:	2cc8b03a 	or	r4,r5,r19
8111fa70:	00c003c4 	movi	r3,15
8111fa74:	bdacf03a 	xor	r22,r23,r22
8111fa78:	12c00044 	addi	r11,r2,1
8111fa7c:	19009936 	bltu	r3,r4,8111fce4 <__muldf3+0x348>
8111fa80:	200890ba 	slli	r4,r4,2
8111fa84:	00e044b4 	movhi	r3,33042
8111fa88:	18fea604 	addi	r3,r3,-1384
8111fa8c:	20c9883a 	add	r4,r4,r3
8111fa90:	20c00017 	ldw	r3,0(r4)
8111fa94:	1800683a 	jmp	r3
8111fa98:	8111fce4 	muli	r4,r16,18419
8111fa9c:	8111faf8 	rdprs	r4,r16,18411
8111faa0:	8111faf8 	rdprs	r4,r16,18411
8111faa4:	8111faf4 	orhi	r4,r16,18411
8111faa8:	8111fcc0 	call	88111fcc <__reset+0x20f1fcc>
8111faac:	8111fcc0 	call	88111fcc <__reset+0x20f1fcc>
8111fab0:	8111fca8 	cmpgeui	r4,r16,18418
8111fab4:	8111faf4 	orhi	r4,r16,18411
8111fab8:	8111fcc0 	call	88111fcc <__reset+0x20f1fcc>
8111fabc:	8111fca8 	cmpgeui	r4,r16,18418
8111fac0:	8111fcc0 	call	88111fcc <__reset+0x20f1fcc>
8111fac4:	8111faf4 	orhi	r4,r16,18411
8111fac8:	8111fcd0 	cmplti	r4,r16,18419
8111facc:	8111fcd0 	cmplti	r4,r16,18419
8111fad0:	8111fcd0 	cmplti	r4,r16,18419
8111fad4:	8111feec 	andhi	r4,r16,18427
8111fad8:	2404b03a 	or	r2,r4,r16
8111fadc:	10006f1e 	bne	r2,zero,8111fc9c <__muldf3+0x300>
8111fae0:	04c00204 	movi	r19,8
8111fae4:	0021883a 	mov	r16,zero
8111fae8:	0029883a 	mov	r20,zero
8111faec:	07000084 	movi	fp,2
8111faf0:	003fcb06 	br	8111fa20 <__reset+0xfb0ffa20>
8111faf4:	502d883a 	mov	r22,r10
8111faf8:	00800084 	movi	r2,2
8111fafc:	28805726 	beq	r5,r2,8111fc5c <__muldf3+0x2c0>
8111fb00:	008000c4 	movi	r2,3
8111fb04:	28816626 	beq	r5,r2,811200a0 <__muldf3+0x704>
8111fb08:	00800044 	movi	r2,1
8111fb0c:	2881411e 	bne	r5,r2,81120014 <__muldf3+0x678>
8111fb10:	b02b883a 	mov	r21,r22
8111fb14:	0005883a 	mov	r2,zero
8111fb18:	000b883a 	mov	r5,zero
8111fb1c:	0029883a 	mov	r20,zero
8111fb20:	1004953a 	slli	r2,r2,20
8111fb24:	a8c03fcc 	andi	r3,r21,255
8111fb28:	04400434 	movhi	r17,16
8111fb2c:	8c7fffc4 	addi	r17,r17,-1
8111fb30:	180697fa 	slli	r3,r3,31
8111fb34:	2c4a703a 	and	r5,r5,r17
8111fb38:	288ab03a 	or	r5,r5,r2
8111fb3c:	28c6b03a 	or	r3,r5,r3
8111fb40:	a005883a 	mov	r2,r20
8111fb44:	dfc00c17 	ldw	ra,48(sp)
8111fb48:	df000b17 	ldw	fp,44(sp)
8111fb4c:	ddc00a17 	ldw	r23,40(sp)
8111fb50:	dd800917 	ldw	r22,36(sp)
8111fb54:	dd400817 	ldw	r21,32(sp)
8111fb58:	dd000717 	ldw	r20,28(sp)
8111fb5c:	dcc00617 	ldw	r19,24(sp)
8111fb60:	dc800517 	ldw	r18,20(sp)
8111fb64:	dc400417 	ldw	r17,16(sp)
8111fb68:	dc000317 	ldw	r16,12(sp)
8111fb6c:	dec00d04 	addi	sp,sp,52
8111fb70:	f800283a 	ret
8111fb74:	2404b03a 	or	r2,r4,r16
8111fb78:	2027883a 	mov	r19,r4
8111fb7c:	10004226 	beq	r2,zero,8111fc88 <__muldf3+0x2ec>
8111fb80:	8000fc26 	beq	r16,zero,8111ff74 <__muldf3+0x5d8>
8111fb84:	8009883a 	mov	r4,r16
8111fb88:	d9800215 	stw	r6,8(sp)
8111fb8c:	d9c00015 	stw	r7,0(sp)
8111fb90:	da400115 	stw	r9,4(sp)
8111fb94:	1120de40 	call	81120de4 <__clzsi2>
8111fb98:	d9800217 	ldw	r6,8(sp)
8111fb9c:	d9c00017 	ldw	r7,0(sp)
8111fba0:	da400117 	ldw	r9,4(sp)
8111fba4:	113ffd44 	addi	r4,r2,-11
8111fba8:	00c00704 	movi	r3,28
8111fbac:	1900ed16 	blt	r3,r4,8111ff64 <__muldf3+0x5c8>
8111fbb0:	00c00744 	movi	r3,29
8111fbb4:	147ffe04 	addi	r17,r2,-8
8111fbb8:	1907c83a 	sub	r3,r3,r4
8111fbbc:	8460983a 	sll	r16,r16,r17
8111fbc0:	98c6d83a 	srl	r3,r19,r3
8111fbc4:	9c68983a 	sll	r20,r19,r17
8111fbc8:	1c20b03a 	or	r16,r3,r16
8111fbcc:	1080fcc4 	addi	r2,r2,1011
8111fbd0:	00a5c83a 	sub	r18,zero,r2
8111fbd4:	0027883a 	mov	r19,zero
8111fbd8:	0039883a 	mov	fp,zero
8111fbdc:	003f9006 	br	8111fa20 <__reset+0xfb0ffa20>
8111fbe0:	3446b03a 	or	r3,r6,r17
8111fbe4:	1800261e 	bne	r3,zero,8111fc80 <__muldf3+0x2e4>
8111fbe8:	0023883a 	mov	r17,zero
8111fbec:	0011883a 	mov	r8,zero
8111fbf0:	01400084 	movi	r5,2
8111fbf4:	003f9c06 	br	8111fa68 <__reset+0xfb0ffa68>
8111fbf8:	3446b03a 	or	r3,r6,r17
8111fbfc:	18001c26 	beq	r3,zero,8111fc70 <__muldf3+0x2d4>
8111fc00:	8800ce26 	beq	r17,zero,8111ff3c <__muldf3+0x5a0>
8111fc04:	8809883a 	mov	r4,r17
8111fc08:	d9800215 	stw	r6,8(sp)
8111fc0c:	da400115 	stw	r9,4(sp)
8111fc10:	da800015 	stw	r10,0(sp)
8111fc14:	1120de40 	call	81120de4 <__clzsi2>
8111fc18:	d9800217 	ldw	r6,8(sp)
8111fc1c:	da400117 	ldw	r9,4(sp)
8111fc20:	da800017 	ldw	r10,0(sp)
8111fc24:	113ffd44 	addi	r4,r2,-11
8111fc28:	00c00704 	movi	r3,28
8111fc2c:	1900bf16 	blt	r3,r4,8111ff2c <__muldf3+0x590>
8111fc30:	00c00744 	movi	r3,29
8111fc34:	123ffe04 	addi	r8,r2,-8
8111fc38:	1907c83a 	sub	r3,r3,r4
8111fc3c:	8a22983a 	sll	r17,r17,r8
8111fc40:	30c6d83a 	srl	r3,r6,r3
8111fc44:	3210983a 	sll	r8,r6,r8
8111fc48:	1c62b03a 	or	r17,r3,r17
8111fc4c:	1080fcc4 	addi	r2,r2,1011
8111fc50:	0085c83a 	sub	r2,zero,r2
8111fc54:	000b883a 	mov	r5,zero
8111fc58:	003f8306 	br	8111fa68 <__reset+0xfb0ffa68>
8111fc5c:	b02b883a 	mov	r21,r22
8111fc60:	0081ffc4 	movi	r2,2047
8111fc64:	000b883a 	mov	r5,zero
8111fc68:	0029883a 	mov	r20,zero
8111fc6c:	003fac06 	br	8111fb20 <__reset+0xfb0ffb20>
8111fc70:	0023883a 	mov	r17,zero
8111fc74:	0011883a 	mov	r8,zero
8111fc78:	01400044 	movi	r5,1
8111fc7c:	003f7a06 	br	8111fa68 <__reset+0xfb0ffa68>
8111fc80:	014000c4 	movi	r5,3
8111fc84:	003f7806 	br	8111fa68 <__reset+0xfb0ffa68>
8111fc88:	04c00104 	movi	r19,4
8111fc8c:	0021883a 	mov	r16,zero
8111fc90:	0029883a 	mov	r20,zero
8111fc94:	07000044 	movi	fp,1
8111fc98:	003f6106 	br	8111fa20 <__reset+0xfb0ffa20>
8111fc9c:	04c00304 	movi	r19,12
8111fca0:	070000c4 	movi	fp,3
8111fca4:	003f5e06 	br	8111fa20 <__reset+0xfb0ffa20>
8111fca8:	01400434 	movhi	r5,16
8111fcac:	002b883a 	mov	r21,zero
8111fcb0:	297fffc4 	addi	r5,r5,-1
8111fcb4:	053fffc4 	movi	r20,-1
8111fcb8:	0081ffc4 	movi	r2,2047
8111fcbc:	003f9806 	br	8111fb20 <__reset+0xfb0ffb20>
8111fcc0:	8023883a 	mov	r17,r16
8111fcc4:	a011883a 	mov	r8,r20
8111fcc8:	e00b883a 	mov	r5,fp
8111fccc:	003f8a06 	br	8111faf8 <__reset+0xfb0ffaf8>
8111fcd0:	8023883a 	mov	r17,r16
8111fcd4:	a011883a 	mov	r8,r20
8111fcd8:	482d883a 	mov	r22,r9
8111fcdc:	e00b883a 	mov	r5,fp
8111fce0:	003f8506 	br	8111faf8 <__reset+0xfb0ffaf8>
8111fce4:	a00ad43a 	srli	r5,r20,16
8111fce8:	401ad43a 	srli	r13,r8,16
8111fcec:	a53fffcc 	andi	r20,r20,65535
8111fcf0:	423fffcc 	andi	r8,r8,65535
8111fcf4:	4519383a 	mul	r12,r8,r20
8111fcf8:	4147383a 	mul	r3,r8,r5
8111fcfc:	6d09383a 	mul	r4,r13,r20
8111fd00:	600cd43a 	srli	r6,r12,16
8111fd04:	2b5d383a 	mul	r14,r5,r13
8111fd08:	20c9883a 	add	r4,r4,r3
8111fd0c:	310d883a 	add	r6,r6,r4
8111fd10:	30c0022e 	bgeu	r6,r3,8111fd1c <__muldf3+0x380>
8111fd14:	00c00074 	movhi	r3,1
8111fd18:	70dd883a 	add	r14,r14,r3
8111fd1c:	8826d43a 	srli	r19,r17,16
8111fd20:	8bffffcc 	andi	r15,r17,65535
8111fd24:	7d23383a 	mul	r17,r15,r20
8111fd28:	7949383a 	mul	r4,r15,r5
8111fd2c:	9d29383a 	mul	r20,r19,r20
8111fd30:	8814d43a 	srli	r10,r17,16
8111fd34:	3012943a 	slli	r9,r6,16
8111fd38:	a129883a 	add	r20,r20,r4
8111fd3c:	633fffcc 	andi	r12,r12,65535
8111fd40:	5515883a 	add	r10,r10,r20
8111fd44:	3006d43a 	srli	r3,r6,16
8111fd48:	4b13883a 	add	r9,r9,r12
8111fd4c:	2ccb383a 	mul	r5,r5,r19
8111fd50:	5100022e 	bgeu	r10,r4,8111fd5c <__muldf3+0x3c0>
8111fd54:	01000074 	movhi	r4,1
8111fd58:	290b883a 	add	r5,r5,r4
8111fd5c:	802ad43a 	srli	r21,r16,16
8111fd60:	843fffcc 	andi	r16,r16,65535
8111fd64:	440d383a 	mul	r6,r8,r16
8111fd68:	4565383a 	mul	r18,r8,r21
8111fd6c:	8349383a 	mul	r4,r16,r13
8111fd70:	500e943a 	slli	r7,r10,16
8111fd74:	3010d43a 	srli	r8,r6,16
8111fd78:	5028d43a 	srli	r20,r10,16
8111fd7c:	2489883a 	add	r4,r4,r18
8111fd80:	8abfffcc 	andi	r10,r17,65535
8111fd84:	3a95883a 	add	r10,r7,r10
8111fd88:	4119883a 	add	r12,r8,r4
8111fd8c:	a169883a 	add	r20,r20,r5
8111fd90:	1a87883a 	add	r3,r3,r10
8111fd94:	6d5b383a 	mul	r13,r13,r21
8111fd98:	6480022e 	bgeu	r12,r18,8111fda4 <__muldf3+0x408>
8111fd9c:	01000074 	movhi	r4,1
8111fda0:	691b883a 	add	r13,r13,r4
8111fda4:	7c25383a 	mul	r18,r15,r16
8111fda8:	7d4b383a 	mul	r5,r15,r21
8111fdac:	84cf383a 	mul	r7,r16,r19
8111fdb0:	901ed43a 	srli	r15,r18,16
8111fdb4:	6008d43a 	srli	r4,r12,16
8111fdb8:	6010943a 	slli	r8,r12,16
8111fdbc:	394f883a 	add	r7,r7,r5
8111fdc0:	333fffcc 	andi	r12,r6,65535
8111fdc4:	79df883a 	add	r15,r15,r7
8111fdc8:	235b883a 	add	r13,r4,r13
8111fdcc:	9d63383a 	mul	r17,r19,r21
8111fdd0:	4309883a 	add	r4,r8,r12
8111fdd4:	7940022e 	bgeu	r15,r5,8111fde0 <__muldf3+0x444>
8111fdd8:	01400074 	movhi	r5,1
8111fddc:	8963883a 	add	r17,r17,r5
8111fde0:	780a943a 	slli	r5,r15,16
8111fde4:	91bfffcc 	andi	r6,r18,65535
8111fde8:	70c7883a 	add	r3,r14,r3
8111fdec:	298d883a 	add	r6,r5,r6
8111fdf0:	1a8f803a 	cmpltu	r7,r3,r10
8111fdf4:	350b883a 	add	r5,r6,r20
8111fdf8:	20c7883a 	add	r3,r4,r3
8111fdfc:	3955883a 	add	r10,r7,r5
8111fe00:	1909803a 	cmpltu	r4,r3,r4
8111fe04:	6a91883a 	add	r8,r13,r10
8111fe08:	780cd43a 	srli	r6,r15,16
8111fe0c:	2219883a 	add	r12,r4,r8
8111fe10:	2d0b803a 	cmpltu	r5,r5,r20
8111fe14:	51cf803a 	cmpltu	r7,r10,r7
8111fe18:	29ceb03a 	or	r7,r5,r7
8111fe1c:	4351803a 	cmpltu	r8,r8,r13
8111fe20:	610b803a 	cmpltu	r5,r12,r4
8111fe24:	4148b03a 	or	r4,r8,r5
8111fe28:	398f883a 	add	r7,r7,r6
8111fe2c:	3909883a 	add	r4,r7,r4
8111fe30:	1810927a 	slli	r8,r3,9
8111fe34:	2449883a 	add	r4,r4,r17
8111fe38:	2008927a 	slli	r4,r4,9
8111fe3c:	6022d5fa 	srli	r17,r12,23
8111fe40:	1806d5fa 	srli	r3,r3,23
8111fe44:	4252b03a 	or	r9,r8,r9
8111fe48:	600a927a 	slli	r5,r12,9
8111fe4c:	4810c03a 	cmpne	r8,r9,zero
8111fe50:	2462b03a 	or	r17,r4,r17
8111fe54:	40c6b03a 	or	r3,r8,r3
8111fe58:	8900402c 	andhi	r4,r17,256
8111fe5c:	1950b03a 	or	r8,r3,r5
8111fe60:	20000726 	beq	r4,zero,8111fe80 <__muldf3+0x4e4>
8111fe64:	4006d07a 	srli	r3,r8,1
8111fe68:	880497fa 	slli	r2,r17,31
8111fe6c:	4200004c 	andi	r8,r8,1
8111fe70:	8822d07a 	srli	r17,r17,1
8111fe74:	1a10b03a 	or	r8,r3,r8
8111fe78:	1210b03a 	or	r8,r2,r8
8111fe7c:	5805883a 	mov	r2,r11
8111fe80:	1140ffc4 	addi	r5,r2,1023
8111fe84:	0140440e 	bge	zero,r5,8111ff98 <__muldf3+0x5fc>
8111fe88:	40c001cc 	andi	r3,r8,7
8111fe8c:	18000726 	beq	r3,zero,8111feac <__muldf3+0x510>
8111fe90:	40c003cc 	andi	r3,r8,15
8111fe94:	01000104 	movi	r4,4
8111fe98:	19000426 	beq	r3,r4,8111feac <__muldf3+0x510>
8111fe9c:	4107883a 	add	r3,r8,r4
8111fea0:	1a11803a 	cmpltu	r8,r3,r8
8111fea4:	8a23883a 	add	r17,r17,r8
8111fea8:	1811883a 	mov	r8,r3
8111feac:	88c0402c 	andhi	r3,r17,256
8111feb0:	18000426 	beq	r3,zero,8111fec4 <__muldf3+0x528>
8111feb4:	11410004 	addi	r5,r2,1024
8111feb8:	00bfc034 	movhi	r2,65280
8111febc:	10bfffc4 	addi	r2,r2,-1
8111fec0:	88a2703a 	and	r17,r17,r2
8111fec4:	0081ff84 	movi	r2,2046
8111fec8:	117f6416 	blt	r2,r5,8111fc5c <__reset+0xfb0ffc5c>
8111fecc:	8828977a 	slli	r20,r17,29
8111fed0:	4010d0fa 	srli	r8,r8,3
8111fed4:	8822927a 	slli	r17,r17,9
8111fed8:	2881ffcc 	andi	r2,r5,2047
8111fedc:	a228b03a 	or	r20,r20,r8
8111fee0:	880ad33a 	srli	r5,r17,12
8111fee4:	b02b883a 	mov	r21,r22
8111fee8:	003f0d06 	br	8111fb20 <__reset+0xfb0ffb20>
8111feec:	8080022c 	andhi	r2,r16,8
8111fef0:	10000926 	beq	r2,zero,8111ff18 <__muldf3+0x57c>
8111fef4:	8880022c 	andhi	r2,r17,8
8111fef8:	1000071e 	bne	r2,zero,8111ff18 <__muldf3+0x57c>
8111fefc:	00800434 	movhi	r2,16
8111ff00:	89400234 	orhi	r5,r17,8
8111ff04:	10bfffc4 	addi	r2,r2,-1
8111ff08:	b82b883a 	mov	r21,r23
8111ff0c:	288a703a 	and	r5,r5,r2
8111ff10:	4029883a 	mov	r20,r8
8111ff14:	003f6806 	br	8111fcb8 <__reset+0xfb0ffcb8>
8111ff18:	00800434 	movhi	r2,16
8111ff1c:	81400234 	orhi	r5,r16,8
8111ff20:	10bfffc4 	addi	r2,r2,-1
8111ff24:	288a703a 	and	r5,r5,r2
8111ff28:	003f6306 	br	8111fcb8 <__reset+0xfb0ffcb8>
8111ff2c:	147ff604 	addi	r17,r2,-40
8111ff30:	3462983a 	sll	r17,r6,r17
8111ff34:	0011883a 	mov	r8,zero
8111ff38:	003f4406 	br	8111fc4c <__reset+0xfb0ffc4c>
8111ff3c:	3009883a 	mov	r4,r6
8111ff40:	d9800215 	stw	r6,8(sp)
8111ff44:	da400115 	stw	r9,4(sp)
8111ff48:	da800015 	stw	r10,0(sp)
8111ff4c:	1120de40 	call	81120de4 <__clzsi2>
8111ff50:	10800804 	addi	r2,r2,32
8111ff54:	da800017 	ldw	r10,0(sp)
8111ff58:	da400117 	ldw	r9,4(sp)
8111ff5c:	d9800217 	ldw	r6,8(sp)
8111ff60:	003f3006 	br	8111fc24 <__reset+0xfb0ffc24>
8111ff64:	143ff604 	addi	r16,r2,-40
8111ff68:	9c20983a 	sll	r16,r19,r16
8111ff6c:	0029883a 	mov	r20,zero
8111ff70:	003f1606 	br	8111fbcc <__reset+0xfb0ffbcc>
8111ff74:	d9800215 	stw	r6,8(sp)
8111ff78:	d9c00015 	stw	r7,0(sp)
8111ff7c:	da400115 	stw	r9,4(sp)
8111ff80:	1120de40 	call	81120de4 <__clzsi2>
8111ff84:	10800804 	addi	r2,r2,32
8111ff88:	da400117 	ldw	r9,4(sp)
8111ff8c:	d9c00017 	ldw	r7,0(sp)
8111ff90:	d9800217 	ldw	r6,8(sp)
8111ff94:	003f0306 	br	8111fba4 <__reset+0xfb0ffba4>
8111ff98:	00c00044 	movi	r3,1
8111ff9c:	1947c83a 	sub	r3,r3,r5
8111ffa0:	00800e04 	movi	r2,56
8111ffa4:	10feda16 	blt	r2,r3,8111fb10 <__reset+0xfb0ffb10>
8111ffa8:	008007c4 	movi	r2,31
8111ffac:	10c01b16 	blt	r2,r3,8112001c <__muldf3+0x680>
8111ffb0:	00800804 	movi	r2,32
8111ffb4:	10c5c83a 	sub	r2,r2,r3
8111ffb8:	888a983a 	sll	r5,r17,r2
8111ffbc:	40c8d83a 	srl	r4,r8,r3
8111ffc0:	4084983a 	sll	r2,r8,r2
8111ffc4:	88e2d83a 	srl	r17,r17,r3
8111ffc8:	2906b03a 	or	r3,r5,r4
8111ffcc:	1004c03a 	cmpne	r2,r2,zero
8111ffd0:	1886b03a 	or	r3,r3,r2
8111ffd4:	188001cc 	andi	r2,r3,7
8111ffd8:	10000726 	beq	r2,zero,8111fff8 <__muldf3+0x65c>
8111ffdc:	188003cc 	andi	r2,r3,15
8111ffe0:	01000104 	movi	r4,4
8111ffe4:	11000426 	beq	r2,r4,8111fff8 <__muldf3+0x65c>
8111ffe8:	1805883a 	mov	r2,r3
8111ffec:	10c00104 	addi	r3,r2,4
8111fff0:	1885803a 	cmpltu	r2,r3,r2
8111fff4:	88a3883a 	add	r17,r17,r2
8111fff8:	8880202c 	andhi	r2,r17,128
8111fffc:	10001c26 	beq	r2,zero,81120070 <__muldf3+0x6d4>
81120000:	b02b883a 	mov	r21,r22
81120004:	00800044 	movi	r2,1
81120008:	000b883a 	mov	r5,zero
8112000c:	0029883a 	mov	r20,zero
81120010:	003ec306 	br	8111fb20 <__reset+0xfb0ffb20>
81120014:	5805883a 	mov	r2,r11
81120018:	003f9906 	br	8111fe80 <__reset+0xfb0ffe80>
8112001c:	00bff844 	movi	r2,-31
81120020:	1145c83a 	sub	r2,r2,r5
81120024:	8888d83a 	srl	r4,r17,r2
81120028:	00800804 	movi	r2,32
8112002c:	18801a26 	beq	r3,r2,81120098 <__muldf3+0x6fc>
81120030:	00801004 	movi	r2,64
81120034:	10c5c83a 	sub	r2,r2,r3
81120038:	8884983a 	sll	r2,r17,r2
8112003c:	1204b03a 	or	r2,r2,r8
81120040:	1004c03a 	cmpne	r2,r2,zero
81120044:	2084b03a 	or	r2,r4,r2
81120048:	144001cc 	andi	r17,r2,7
8112004c:	88000d1e 	bne	r17,zero,81120084 <__muldf3+0x6e8>
81120050:	000b883a 	mov	r5,zero
81120054:	1028d0fa 	srli	r20,r2,3
81120058:	b02b883a 	mov	r21,r22
8112005c:	0005883a 	mov	r2,zero
81120060:	a468b03a 	or	r20,r20,r17
81120064:	003eae06 	br	8111fb20 <__reset+0xfb0ffb20>
81120068:	1007883a 	mov	r3,r2
8112006c:	0023883a 	mov	r17,zero
81120070:	880a927a 	slli	r5,r17,9
81120074:	1805883a 	mov	r2,r3
81120078:	8822977a 	slli	r17,r17,29
8112007c:	280ad33a 	srli	r5,r5,12
81120080:	003ff406 	br	81120054 <__reset+0xfb100054>
81120084:	10c003cc 	andi	r3,r2,15
81120088:	01000104 	movi	r4,4
8112008c:	193ff626 	beq	r3,r4,81120068 <__reset+0xfb100068>
81120090:	0023883a 	mov	r17,zero
81120094:	003fd506 	br	8111ffec <__reset+0xfb0fffec>
81120098:	0005883a 	mov	r2,zero
8112009c:	003fe706 	br	8112003c <__reset+0xfb10003c>
811200a0:	00800434 	movhi	r2,16
811200a4:	89400234 	orhi	r5,r17,8
811200a8:	10bfffc4 	addi	r2,r2,-1
811200ac:	b02b883a 	mov	r21,r22
811200b0:	288a703a 	and	r5,r5,r2
811200b4:	4029883a 	mov	r20,r8
811200b8:	003eff06 	br	8111fcb8 <__reset+0xfb0ffcb8>

811200bc <__subdf3>:
811200bc:	02000434 	movhi	r8,16
811200c0:	423fffc4 	addi	r8,r8,-1
811200c4:	defffb04 	addi	sp,sp,-20
811200c8:	2a14703a 	and	r10,r5,r8
811200cc:	3812d53a 	srli	r9,r7,20
811200d0:	3a10703a 	and	r8,r7,r8
811200d4:	de00012e 	bgeu	sp,et,811200dc <__subdf3+0x20>
811200d8:	003b68fa 	trap	3
811200dc:	2006d77a 	srli	r3,r4,29
811200e0:	3004d77a 	srli	r2,r6,29
811200e4:	dc000015 	stw	r16,0(sp)
811200e8:	501490fa 	slli	r10,r10,3
811200ec:	2820d53a 	srli	r16,r5,20
811200f0:	401090fa 	slli	r8,r8,3
811200f4:	dc800215 	stw	r18,8(sp)
811200f8:	dc400115 	stw	r17,4(sp)
811200fc:	dfc00415 	stw	ra,16(sp)
81120100:	202290fa 	slli	r17,r4,3
81120104:	dcc00315 	stw	r19,12(sp)
81120108:	4a41ffcc 	andi	r9,r9,2047
8112010c:	0101ffc4 	movi	r4,2047
81120110:	2824d7fa 	srli	r18,r5,31
81120114:	8401ffcc 	andi	r16,r16,2047
81120118:	50c6b03a 	or	r3,r10,r3
8112011c:	380ed7fa 	srli	r7,r7,31
81120120:	408ab03a 	or	r5,r8,r2
81120124:	300c90fa 	slli	r6,r6,3
81120128:	49009626 	beq	r9,r4,81120384 <__subdf3+0x2c8>
8112012c:	39c0005c 	xori	r7,r7,1
81120130:	8245c83a 	sub	r2,r16,r9
81120134:	3c807426 	beq	r7,r18,81120308 <__subdf3+0x24c>
81120138:	0080af0e 	bge	zero,r2,811203f8 <__subdf3+0x33c>
8112013c:	48002a1e 	bne	r9,zero,811201e8 <__subdf3+0x12c>
81120140:	2988b03a 	or	r4,r5,r6
81120144:	20009a1e 	bne	r4,zero,811203b0 <__subdf3+0x2f4>
81120148:	888001cc 	andi	r2,r17,7
8112014c:	10000726 	beq	r2,zero,8112016c <__subdf3+0xb0>
81120150:	888003cc 	andi	r2,r17,15
81120154:	01000104 	movi	r4,4
81120158:	11000426 	beq	r2,r4,8112016c <__subdf3+0xb0>
8112015c:	890b883a 	add	r5,r17,r4
81120160:	2c63803a 	cmpltu	r17,r5,r17
81120164:	1c47883a 	add	r3,r3,r17
81120168:	2823883a 	mov	r17,r5
8112016c:	1880202c 	andhi	r2,r3,128
81120170:	10005926 	beq	r2,zero,811202d8 <__subdf3+0x21c>
81120174:	84000044 	addi	r16,r16,1
81120178:	0081ffc4 	movi	r2,2047
8112017c:	8080be26 	beq	r16,r2,81120478 <__subdf3+0x3bc>
81120180:	017fe034 	movhi	r5,65408
81120184:	297fffc4 	addi	r5,r5,-1
81120188:	1946703a 	and	r3,r3,r5
8112018c:	1804977a 	slli	r2,r3,29
81120190:	1806927a 	slli	r3,r3,9
81120194:	8822d0fa 	srli	r17,r17,3
81120198:	8401ffcc 	andi	r16,r16,2047
8112019c:	180ad33a 	srli	r5,r3,12
811201a0:	9100004c 	andi	r4,r18,1
811201a4:	1444b03a 	or	r2,r2,r17
811201a8:	80c1ffcc 	andi	r3,r16,2047
811201ac:	1820953a 	slli	r16,r3,20
811201b0:	20c03fcc 	andi	r3,r4,255
811201b4:	180897fa 	slli	r4,r3,31
811201b8:	00c00434 	movhi	r3,16
811201bc:	18ffffc4 	addi	r3,r3,-1
811201c0:	28c6703a 	and	r3,r5,r3
811201c4:	1c06b03a 	or	r3,r3,r16
811201c8:	1906b03a 	or	r3,r3,r4
811201cc:	dfc00417 	ldw	ra,16(sp)
811201d0:	dcc00317 	ldw	r19,12(sp)
811201d4:	dc800217 	ldw	r18,8(sp)
811201d8:	dc400117 	ldw	r17,4(sp)
811201dc:	dc000017 	ldw	r16,0(sp)
811201e0:	dec00504 	addi	sp,sp,20
811201e4:	f800283a 	ret
811201e8:	0101ffc4 	movi	r4,2047
811201ec:	813fd626 	beq	r16,r4,81120148 <__reset+0xfb100148>
811201f0:	29402034 	orhi	r5,r5,128
811201f4:	01000e04 	movi	r4,56
811201f8:	2080a316 	blt	r4,r2,81120488 <__subdf3+0x3cc>
811201fc:	010007c4 	movi	r4,31
81120200:	2080c616 	blt	r4,r2,8112051c <__subdf3+0x460>
81120204:	01000804 	movi	r4,32
81120208:	2089c83a 	sub	r4,r4,r2
8112020c:	2910983a 	sll	r8,r5,r4
81120210:	308ed83a 	srl	r7,r6,r2
81120214:	3108983a 	sll	r4,r6,r4
81120218:	2884d83a 	srl	r2,r5,r2
8112021c:	41ccb03a 	or	r6,r8,r7
81120220:	2008c03a 	cmpne	r4,r4,zero
81120224:	310cb03a 	or	r6,r6,r4
81120228:	898dc83a 	sub	r6,r17,r6
8112022c:	89a3803a 	cmpltu	r17,r17,r6
81120230:	1887c83a 	sub	r3,r3,r2
81120234:	1c47c83a 	sub	r3,r3,r17
81120238:	3023883a 	mov	r17,r6
8112023c:	1880202c 	andhi	r2,r3,128
81120240:	10002326 	beq	r2,zero,811202d0 <__subdf3+0x214>
81120244:	04c02034 	movhi	r19,128
81120248:	9cffffc4 	addi	r19,r19,-1
8112024c:	1ce6703a 	and	r19,r3,r19
81120250:	98007a26 	beq	r19,zero,8112043c <__subdf3+0x380>
81120254:	9809883a 	mov	r4,r19
81120258:	1120de40 	call	81120de4 <__clzsi2>
8112025c:	113ffe04 	addi	r4,r2,-8
81120260:	00c007c4 	movi	r3,31
81120264:	19007b16 	blt	r3,r4,81120454 <__subdf3+0x398>
81120268:	00800804 	movi	r2,32
8112026c:	1105c83a 	sub	r2,r2,r4
81120270:	8884d83a 	srl	r2,r17,r2
81120274:	9906983a 	sll	r3,r19,r4
81120278:	8922983a 	sll	r17,r17,r4
8112027c:	10c4b03a 	or	r2,r2,r3
81120280:	24007816 	blt	r4,r16,81120464 <__subdf3+0x3a8>
81120284:	2421c83a 	sub	r16,r4,r16
81120288:	80c00044 	addi	r3,r16,1
8112028c:	010007c4 	movi	r4,31
81120290:	20c09516 	blt	r4,r3,811204e8 <__subdf3+0x42c>
81120294:	01400804 	movi	r5,32
81120298:	28cbc83a 	sub	r5,r5,r3
8112029c:	88c8d83a 	srl	r4,r17,r3
811202a0:	8962983a 	sll	r17,r17,r5
811202a4:	114a983a 	sll	r5,r2,r5
811202a8:	10c6d83a 	srl	r3,r2,r3
811202ac:	8804c03a 	cmpne	r2,r17,zero
811202b0:	290ab03a 	or	r5,r5,r4
811202b4:	28a2b03a 	or	r17,r5,r2
811202b8:	0021883a 	mov	r16,zero
811202bc:	003fa206 	br	81120148 <__reset+0xfb100148>
811202c0:	2090b03a 	or	r8,r4,r2
811202c4:	40018e26 	beq	r8,zero,81120900 <__subdf3+0x844>
811202c8:	1007883a 	mov	r3,r2
811202cc:	2023883a 	mov	r17,r4
811202d0:	888001cc 	andi	r2,r17,7
811202d4:	103f9e1e 	bne	r2,zero,81120150 <__reset+0xfb100150>
811202d8:	1804977a 	slli	r2,r3,29
811202dc:	8822d0fa 	srli	r17,r17,3
811202e0:	1810d0fa 	srli	r8,r3,3
811202e4:	9100004c 	andi	r4,r18,1
811202e8:	1444b03a 	or	r2,r2,r17
811202ec:	00c1ffc4 	movi	r3,2047
811202f0:	80c02826 	beq	r16,r3,81120394 <__subdf3+0x2d8>
811202f4:	01400434 	movhi	r5,16
811202f8:	297fffc4 	addi	r5,r5,-1
811202fc:	80e0703a 	and	r16,r16,r3
81120300:	414a703a 	and	r5,r8,r5
81120304:	003fa806 	br	811201a8 <__reset+0xfb1001a8>
81120308:	0080630e 	bge	zero,r2,81120498 <__subdf3+0x3dc>
8112030c:	48003026 	beq	r9,zero,811203d0 <__subdf3+0x314>
81120310:	0101ffc4 	movi	r4,2047
81120314:	813f8c26 	beq	r16,r4,81120148 <__reset+0xfb100148>
81120318:	29402034 	orhi	r5,r5,128
8112031c:	01000e04 	movi	r4,56
81120320:	2080a90e 	bge	r4,r2,811205c8 <__subdf3+0x50c>
81120324:	298cb03a 	or	r6,r5,r6
81120328:	3012c03a 	cmpne	r9,r6,zero
8112032c:	0005883a 	mov	r2,zero
81120330:	4c53883a 	add	r9,r9,r17
81120334:	4c63803a 	cmpltu	r17,r9,r17
81120338:	10c7883a 	add	r3,r2,r3
8112033c:	88c7883a 	add	r3,r17,r3
81120340:	4823883a 	mov	r17,r9
81120344:	1880202c 	andhi	r2,r3,128
81120348:	1000d026 	beq	r2,zero,8112068c <__subdf3+0x5d0>
8112034c:	84000044 	addi	r16,r16,1
81120350:	0081ffc4 	movi	r2,2047
81120354:	8080fe26 	beq	r16,r2,81120750 <__subdf3+0x694>
81120358:	00bfe034 	movhi	r2,65408
8112035c:	10bfffc4 	addi	r2,r2,-1
81120360:	1886703a 	and	r3,r3,r2
81120364:	880ad07a 	srli	r5,r17,1
81120368:	180497fa 	slli	r2,r3,31
8112036c:	8900004c 	andi	r4,r17,1
81120370:	2922b03a 	or	r17,r5,r4
81120374:	1806d07a 	srli	r3,r3,1
81120378:	1462b03a 	or	r17,r2,r17
8112037c:	3825883a 	mov	r18,r7
81120380:	003f7106 	br	81120148 <__reset+0xfb100148>
81120384:	2984b03a 	or	r2,r5,r6
81120388:	103f6826 	beq	r2,zero,8112012c <__reset+0xfb10012c>
8112038c:	39c03fcc 	andi	r7,r7,255
81120390:	003f6706 	br	81120130 <__reset+0xfb100130>
81120394:	4086b03a 	or	r3,r8,r2
81120398:	18015226 	beq	r3,zero,811208e4 <__subdf3+0x828>
8112039c:	00c00434 	movhi	r3,16
811203a0:	41400234 	orhi	r5,r8,8
811203a4:	18ffffc4 	addi	r3,r3,-1
811203a8:	28ca703a 	and	r5,r5,r3
811203ac:	003f7e06 	br	811201a8 <__reset+0xfb1001a8>
811203b0:	10bfffc4 	addi	r2,r2,-1
811203b4:	1000491e 	bne	r2,zero,811204dc <__subdf3+0x420>
811203b8:	898fc83a 	sub	r7,r17,r6
811203bc:	89e3803a 	cmpltu	r17,r17,r7
811203c0:	1947c83a 	sub	r3,r3,r5
811203c4:	1c47c83a 	sub	r3,r3,r17
811203c8:	3823883a 	mov	r17,r7
811203cc:	003f9b06 	br	8112023c <__reset+0xfb10023c>
811203d0:	2988b03a 	or	r4,r5,r6
811203d4:	203f5c26 	beq	r4,zero,81120148 <__reset+0xfb100148>
811203d8:	10bfffc4 	addi	r2,r2,-1
811203dc:	1000931e 	bne	r2,zero,8112062c <__subdf3+0x570>
811203e0:	898d883a 	add	r6,r17,r6
811203e4:	3463803a 	cmpltu	r17,r6,r17
811203e8:	1947883a 	add	r3,r3,r5
811203ec:	88c7883a 	add	r3,r17,r3
811203f0:	3023883a 	mov	r17,r6
811203f4:	003fd306 	br	81120344 <__reset+0xfb100344>
811203f8:	1000541e 	bne	r2,zero,8112054c <__subdf3+0x490>
811203fc:	80800044 	addi	r2,r16,1
81120400:	1081ffcc 	andi	r2,r2,2047
81120404:	01000044 	movi	r4,1
81120408:	2080a20e 	bge	r4,r2,81120694 <__subdf3+0x5d8>
8112040c:	8989c83a 	sub	r4,r17,r6
81120410:	8905803a 	cmpltu	r2,r17,r4
81120414:	1967c83a 	sub	r19,r3,r5
81120418:	98a7c83a 	sub	r19,r19,r2
8112041c:	9880202c 	andhi	r2,r19,128
81120420:	10006326 	beq	r2,zero,811205b0 <__subdf3+0x4f4>
81120424:	3463c83a 	sub	r17,r6,r17
81120428:	28c7c83a 	sub	r3,r5,r3
8112042c:	344d803a 	cmpltu	r6,r6,r17
81120430:	19a7c83a 	sub	r19,r3,r6
81120434:	3825883a 	mov	r18,r7
81120438:	983f861e 	bne	r19,zero,81120254 <__reset+0xfb100254>
8112043c:	8809883a 	mov	r4,r17
81120440:	1120de40 	call	81120de4 <__clzsi2>
81120444:	10800804 	addi	r2,r2,32
81120448:	113ffe04 	addi	r4,r2,-8
8112044c:	00c007c4 	movi	r3,31
81120450:	193f850e 	bge	r3,r4,81120268 <__reset+0xfb100268>
81120454:	10bff604 	addi	r2,r2,-40
81120458:	8884983a 	sll	r2,r17,r2
8112045c:	0023883a 	mov	r17,zero
81120460:	243f880e 	bge	r4,r16,81120284 <__reset+0xfb100284>
81120464:	00ffe034 	movhi	r3,65408
81120468:	18ffffc4 	addi	r3,r3,-1
8112046c:	8121c83a 	sub	r16,r16,r4
81120470:	10c6703a 	and	r3,r2,r3
81120474:	003f3406 	br	81120148 <__reset+0xfb100148>
81120478:	9100004c 	andi	r4,r18,1
8112047c:	000b883a 	mov	r5,zero
81120480:	0005883a 	mov	r2,zero
81120484:	003f4806 	br	811201a8 <__reset+0xfb1001a8>
81120488:	298cb03a 	or	r6,r5,r6
8112048c:	300cc03a 	cmpne	r6,r6,zero
81120490:	0005883a 	mov	r2,zero
81120494:	003f6406 	br	81120228 <__reset+0xfb100228>
81120498:	10009a1e 	bne	r2,zero,81120704 <__subdf3+0x648>
8112049c:	82400044 	addi	r9,r16,1
811204a0:	4881ffcc 	andi	r2,r9,2047
811204a4:	02800044 	movi	r10,1
811204a8:	5080670e 	bge	r10,r2,81120648 <__subdf3+0x58c>
811204ac:	0081ffc4 	movi	r2,2047
811204b0:	4880af26 	beq	r9,r2,81120770 <__subdf3+0x6b4>
811204b4:	898d883a 	add	r6,r17,r6
811204b8:	1945883a 	add	r2,r3,r5
811204bc:	3447803a 	cmpltu	r3,r6,r17
811204c0:	1887883a 	add	r3,r3,r2
811204c4:	182297fa 	slli	r17,r3,31
811204c8:	300cd07a 	srli	r6,r6,1
811204cc:	1806d07a 	srli	r3,r3,1
811204d0:	4821883a 	mov	r16,r9
811204d4:	89a2b03a 	or	r17,r17,r6
811204d8:	003f1b06 	br	81120148 <__reset+0xfb100148>
811204dc:	0101ffc4 	movi	r4,2047
811204e0:	813f441e 	bne	r16,r4,811201f4 <__reset+0xfb1001f4>
811204e4:	003f1806 	br	81120148 <__reset+0xfb100148>
811204e8:	843ff844 	addi	r16,r16,-31
811204ec:	01400804 	movi	r5,32
811204f0:	1408d83a 	srl	r4,r2,r16
811204f4:	19405026 	beq	r3,r5,81120638 <__subdf3+0x57c>
811204f8:	01401004 	movi	r5,64
811204fc:	28c7c83a 	sub	r3,r5,r3
81120500:	10c4983a 	sll	r2,r2,r3
81120504:	88a2b03a 	or	r17,r17,r2
81120508:	8822c03a 	cmpne	r17,r17,zero
8112050c:	2462b03a 	or	r17,r4,r17
81120510:	0007883a 	mov	r3,zero
81120514:	0021883a 	mov	r16,zero
81120518:	003f6d06 	br	811202d0 <__reset+0xfb1002d0>
8112051c:	11fff804 	addi	r7,r2,-32
81120520:	01000804 	movi	r4,32
81120524:	29ced83a 	srl	r7,r5,r7
81120528:	11004526 	beq	r2,r4,81120640 <__subdf3+0x584>
8112052c:	01001004 	movi	r4,64
81120530:	2089c83a 	sub	r4,r4,r2
81120534:	2904983a 	sll	r2,r5,r4
81120538:	118cb03a 	or	r6,r2,r6
8112053c:	300cc03a 	cmpne	r6,r6,zero
81120540:	398cb03a 	or	r6,r7,r6
81120544:	0005883a 	mov	r2,zero
81120548:	003f3706 	br	81120228 <__reset+0xfb100228>
8112054c:	80002a26 	beq	r16,zero,811205f8 <__subdf3+0x53c>
81120550:	0101ffc4 	movi	r4,2047
81120554:	49006626 	beq	r9,r4,811206f0 <__subdf3+0x634>
81120558:	0085c83a 	sub	r2,zero,r2
8112055c:	18c02034 	orhi	r3,r3,128
81120560:	01000e04 	movi	r4,56
81120564:	20807e16 	blt	r4,r2,81120760 <__subdf3+0x6a4>
81120568:	010007c4 	movi	r4,31
8112056c:	2080e716 	blt	r4,r2,8112090c <__subdf3+0x850>
81120570:	01000804 	movi	r4,32
81120574:	2089c83a 	sub	r4,r4,r2
81120578:	1914983a 	sll	r10,r3,r4
8112057c:	8890d83a 	srl	r8,r17,r2
81120580:	8908983a 	sll	r4,r17,r4
81120584:	1884d83a 	srl	r2,r3,r2
81120588:	5222b03a 	or	r17,r10,r8
8112058c:	2006c03a 	cmpne	r3,r4,zero
81120590:	88e2b03a 	or	r17,r17,r3
81120594:	3463c83a 	sub	r17,r6,r17
81120598:	2885c83a 	sub	r2,r5,r2
8112059c:	344d803a 	cmpltu	r6,r6,r17
811205a0:	1187c83a 	sub	r3,r2,r6
811205a4:	4821883a 	mov	r16,r9
811205a8:	3825883a 	mov	r18,r7
811205ac:	003f2306 	br	8112023c <__reset+0xfb10023c>
811205b0:	24d0b03a 	or	r8,r4,r19
811205b4:	40001b1e 	bne	r8,zero,81120624 <__subdf3+0x568>
811205b8:	0005883a 	mov	r2,zero
811205bc:	0009883a 	mov	r4,zero
811205c0:	0021883a 	mov	r16,zero
811205c4:	003f4906 	br	811202ec <__reset+0xfb1002ec>
811205c8:	010007c4 	movi	r4,31
811205cc:	20803a16 	blt	r4,r2,811206b8 <__subdf3+0x5fc>
811205d0:	01000804 	movi	r4,32
811205d4:	2089c83a 	sub	r4,r4,r2
811205d8:	2912983a 	sll	r9,r5,r4
811205dc:	3090d83a 	srl	r8,r6,r2
811205e0:	3108983a 	sll	r4,r6,r4
811205e4:	2884d83a 	srl	r2,r5,r2
811205e8:	4a12b03a 	or	r9,r9,r8
811205ec:	2008c03a 	cmpne	r4,r4,zero
811205f0:	4912b03a 	or	r9,r9,r4
811205f4:	003f4e06 	br	81120330 <__reset+0xfb100330>
811205f8:	1c48b03a 	or	r4,r3,r17
811205fc:	20003c26 	beq	r4,zero,811206f0 <__subdf3+0x634>
81120600:	0084303a 	nor	r2,zero,r2
81120604:	1000381e 	bne	r2,zero,811206e8 <__subdf3+0x62c>
81120608:	3463c83a 	sub	r17,r6,r17
8112060c:	28c5c83a 	sub	r2,r5,r3
81120610:	344d803a 	cmpltu	r6,r6,r17
81120614:	1187c83a 	sub	r3,r2,r6
81120618:	4821883a 	mov	r16,r9
8112061c:	3825883a 	mov	r18,r7
81120620:	003f0606 	br	8112023c <__reset+0xfb10023c>
81120624:	2023883a 	mov	r17,r4
81120628:	003f0906 	br	81120250 <__reset+0xfb100250>
8112062c:	0101ffc4 	movi	r4,2047
81120630:	813f3a1e 	bne	r16,r4,8112031c <__reset+0xfb10031c>
81120634:	003ec406 	br	81120148 <__reset+0xfb100148>
81120638:	0005883a 	mov	r2,zero
8112063c:	003fb106 	br	81120504 <__reset+0xfb100504>
81120640:	0005883a 	mov	r2,zero
81120644:	003fbc06 	br	81120538 <__reset+0xfb100538>
81120648:	1c44b03a 	or	r2,r3,r17
8112064c:	80008e1e 	bne	r16,zero,81120888 <__subdf3+0x7cc>
81120650:	1000c826 	beq	r2,zero,81120974 <__subdf3+0x8b8>
81120654:	2984b03a 	or	r2,r5,r6
81120658:	103ebb26 	beq	r2,zero,81120148 <__reset+0xfb100148>
8112065c:	8989883a 	add	r4,r17,r6
81120660:	1945883a 	add	r2,r3,r5
81120664:	2447803a 	cmpltu	r3,r4,r17
81120668:	1887883a 	add	r3,r3,r2
8112066c:	1880202c 	andhi	r2,r3,128
81120670:	2023883a 	mov	r17,r4
81120674:	103f1626 	beq	r2,zero,811202d0 <__reset+0xfb1002d0>
81120678:	00bfe034 	movhi	r2,65408
8112067c:	10bfffc4 	addi	r2,r2,-1
81120680:	5021883a 	mov	r16,r10
81120684:	1886703a 	and	r3,r3,r2
81120688:	003eaf06 	br	81120148 <__reset+0xfb100148>
8112068c:	3825883a 	mov	r18,r7
81120690:	003f0f06 	br	811202d0 <__reset+0xfb1002d0>
81120694:	1c44b03a 	or	r2,r3,r17
81120698:	8000251e 	bne	r16,zero,81120730 <__subdf3+0x674>
8112069c:	1000661e 	bne	r2,zero,81120838 <__subdf3+0x77c>
811206a0:	2990b03a 	or	r8,r5,r6
811206a4:	40009626 	beq	r8,zero,81120900 <__subdf3+0x844>
811206a8:	2807883a 	mov	r3,r5
811206ac:	3023883a 	mov	r17,r6
811206b0:	3825883a 	mov	r18,r7
811206b4:	003ea406 	br	81120148 <__reset+0xfb100148>
811206b8:	127ff804 	addi	r9,r2,-32
811206bc:	01000804 	movi	r4,32
811206c0:	2a52d83a 	srl	r9,r5,r9
811206c4:	11008c26 	beq	r2,r4,811208f8 <__subdf3+0x83c>
811206c8:	01001004 	movi	r4,64
811206cc:	2085c83a 	sub	r2,r4,r2
811206d0:	2884983a 	sll	r2,r5,r2
811206d4:	118cb03a 	or	r6,r2,r6
811206d8:	300cc03a 	cmpne	r6,r6,zero
811206dc:	4992b03a 	or	r9,r9,r6
811206e0:	0005883a 	mov	r2,zero
811206e4:	003f1206 	br	81120330 <__reset+0xfb100330>
811206e8:	0101ffc4 	movi	r4,2047
811206ec:	493f9c1e 	bne	r9,r4,81120560 <__reset+0xfb100560>
811206f0:	2807883a 	mov	r3,r5
811206f4:	3023883a 	mov	r17,r6
811206f8:	4821883a 	mov	r16,r9
811206fc:	3825883a 	mov	r18,r7
81120700:	003e9106 	br	81120148 <__reset+0xfb100148>
81120704:	80001f1e 	bne	r16,zero,81120784 <__subdf3+0x6c8>
81120708:	1c48b03a 	or	r4,r3,r17
8112070c:	20005a26 	beq	r4,zero,81120878 <__subdf3+0x7bc>
81120710:	0084303a 	nor	r2,zero,r2
81120714:	1000561e 	bne	r2,zero,81120870 <__subdf3+0x7b4>
81120718:	89a3883a 	add	r17,r17,r6
8112071c:	1945883a 	add	r2,r3,r5
81120720:	898d803a 	cmpltu	r6,r17,r6
81120724:	3087883a 	add	r3,r6,r2
81120728:	4821883a 	mov	r16,r9
8112072c:	003f0506 	br	81120344 <__reset+0xfb100344>
81120730:	10002b1e 	bne	r2,zero,811207e0 <__subdf3+0x724>
81120734:	2984b03a 	or	r2,r5,r6
81120738:	10008026 	beq	r2,zero,8112093c <__subdf3+0x880>
8112073c:	2807883a 	mov	r3,r5
81120740:	3023883a 	mov	r17,r6
81120744:	3825883a 	mov	r18,r7
81120748:	0401ffc4 	movi	r16,2047
8112074c:	003e7e06 	br	81120148 <__reset+0xfb100148>
81120750:	3809883a 	mov	r4,r7
81120754:	0011883a 	mov	r8,zero
81120758:	0005883a 	mov	r2,zero
8112075c:	003ee306 	br	811202ec <__reset+0xfb1002ec>
81120760:	1c62b03a 	or	r17,r3,r17
81120764:	8822c03a 	cmpne	r17,r17,zero
81120768:	0005883a 	mov	r2,zero
8112076c:	003f8906 	br	81120594 <__reset+0xfb100594>
81120770:	3809883a 	mov	r4,r7
81120774:	4821883a 	mov	r16,r9
81120778:	0011883a 	mov	r8,zero
8112077c:	0005883a 	mov	r2,zero
81120780:	003eda06 	br	811202ec <__reset+0xfb1002ec>
81120784:	0101ffc4 	movi	r4,2047
81120788:	49003b26 	beq	r9,r4,81120878 <__subdf3+0x7bc>
8112078c:	0085c83a 	sub	r2,zero,r2
81120790:	18c02034 	orhi	r3,r3,128
81120794:	01000e04 	movi	r4,56
81120798:	20806e16 	blt	r4,r2,81120954 <__subdf3+0x898>
8112079c:	010007c4 	movi	r4,31
811207a0:	20807716 	blt	r4,r2,81120980 <__subdf3+0x8c4>
811207a4:	01000804 	movi	r4,32
811207a8:	2089c83a 	sub	r4,r4,r2
811207ac:	1914983a 	sll	r10,r3,r4
811207b0:	8890d83a 	srl	r8,r17,r2
811207b4:	8908983a 	sll	r4,r17,r4
811207b8:	1884d83a 	srl	r2,r3,r2
811207bc:	5222b03a 	or	r17,r10,r8
811207c0:	2006c03a 	cmpne	r3,r4,zero
811207c4:	88e2b03a 	or	r17,r17,r3
811207c8:	89a3883a 	add	r17,r17,r6
811207cc:	1145883a 	add	r2,r2,r5
811207d0:	898d803a 	cmpltu	r6,r17,r6
811207d4:	3087883a 	add	r3,r6,r2
811207d8:	4821883a 	mov	r16,r9
811207dc:	003ed906 	br	81120344 <__reset+0xfb100344>
811207e0:	2984b03a 	or	r2,r5,r6
811207e4:	10004226 	beq	r2,zero,811208f0 <__subdf3+0x834>
811207e8:	1808d0fa 	srli	r4,r3,3
811207ec:	8822d0fa 	srli	r17,r17,3
811207f0:	1806977a 	slli	r3,r3,29
811207f4:	2080022c 	andhi	r2,r4,8
811207f8:	1c62b03a 	or	r17,r3,r17
811207fc:	10000826 	beq	r2,zero,81120820 <__subdf3+0x764>
81120800:	2812d0fa 	srli	r9,r5,3
81120804:	4880022c 	andhi	r2,r9,8
81120808:	1000051e 	bne	r2,zero,81120820 <__subdf3+0x764>
8112080c:	300cd0fa 	srli	r6,r6,3
81120810:	2804977a 	slli	r2,r5,29
81120814:	4809883a 	mov	r4,r9
81120818:	3825883a 	mov	r18,r7
8112081c:	11a2b03a 	or	r17,r2,r6
81120820:	8806d77a 	srli	r3,r17,29
81120824:	200890fa 	slli	r4,r4,3
81120828:	882290fa 	slli	r17,r17,3
8112082c:	0401ffc4 	movi	r16,2047
81120830:	1906b03a 	or	r3,r3,r4
81120834:	003e4406 	br	81120148 <__reset+0xfb100148>
81120838:	2984b03a 	or	r2,r5,r6
8112083c:	103e4226 	beq	r2,zero,81120148 <__reset+0xfb100148>
81120840:	8989c83a 	sub	r4,r17,r6
81120844:	8911803a 	cmpltu	r8,r17,r4
81120848:	1945c83a 	sub	r2,r3,r5
8112084c:	1205c83a 	sub	r2,r2,r8
81120850:	1200202c 	andhi	r8,r2,128
81120854:	403e9a26 	beq	r8,zero,811202c0 <__reset+0xfb1002c0>
81120858:	3463c83a 	sub	r17,r6,r17
8112085c:	28c5c83a 	sub	r2,r5,r3
81120860:	344d803a 	cmpltu	r6,r6,r17
81120864:	1187c83a 	sub	r3,r2,r6
81120868:	3825883a 	mov	r18,r7
8112086c:	003e3606 	br	81120148 <__reset+0xfb100148>
81120870:	0101ffc4 	movi	r4,2047
81120874:	493fc71e 	bne	r9,r4,81120794 <__reset+0xfb100794>
81120878:	2807883a 	mov	r3,r5
8112087c:	3023883a 	mov	r17,r6
81120880:	4821883a 	mov	r16,r9
81120884:	003e3006 	br	81120148 <__reset+0xfb100148>
81120888:	10003626 	beq	r2,zero,81120964 <__subdf3+0x8a8>
8112088c:	2984b03a 	or	r2,r5,r6
81120890:	10001726 	beq	r2,zero,811208f0 <__subdf3+0x834>
81120894:	1808d0fa 	srli	r4,r3,3
81120898:	8822d0fa 	srli	r17,r17,3
8112089c:	1806977a 	slli	r3,r3,29
811208a0:	2080022c 	andhi	r2,r4,8
811208a4:	1c62b03a 	or	r17,r3,r17
811208a8:	10000726 	beq	r2,zero,811208c8 <__subdf3+0x80c>
811208ac:	2812d0fa 	srli	r9,r5,3
811208b0:	4880022c 	andhi	r2,r9,8
811208b4:	1000041e 	bne	r2,zero,811208c8 <__subdf3+0x80c>
811208b8:	300cd0fa 	srli	r6,r6,3
811208bc:	2804977a 	slli	r2,r5,29
811208c0:	4809883a 	mov	r4,r9
811208c4:	11a2b03a 	or	r17,r2,r6
811208c8:	8806d77a 	srli	r3,r17,29
811208cc:	200890fa 	slli	r4,r4,3
811208d0:	882290fa 	slli	r17,r17,3
811208d4:	3825883a 	mov	r18,r7
811208d8:	1906b03a 	or	r3,r3,r4
811208dc:	0401ffc4 	movi	r16,2047
811208e0:	003e1906 	br	81120148 <__reset+0xfb100148>
811208e4:	000b883a 	mov	r5,zero
811208e8:	0005883a 	mov	r2,zero
811208ec:	003e2e06 	br	811201a8 <__reset+0xfb1001a8>
811208f0:	0401ffc4 	movi	r16,2047
811208f4:	003e1406 	br	81120148 <__reset+0xfb100148>
811208f8:	0005883a 	mov	r2,zero
811208fc:	003f7506 	br	811206d4 <__reset+0xfb1006d4>
81120900:	0005883a 	mov	r2,zero
81120904:	0009883a 	mov	r4,zero
81120908:	003e7806 	br	811202ec <__reset+0xfb1002ec>
8112090c:	123ff804 	addi	r8,r2,-32
81120910:	01000804 	movi	r4,32
81120914:	1a10d83a 	srl	r8,r3,r8
81120918:	11002526 	beq	r2,r4,811209b0 <__subdf3+0x8f4>
8112091c:	01001004 	movi	r4,64
81120920:	2085c83a 	sub	r2,r4,r2
81120924:	1884983a 	sll	r2,r3,r2
81120928:	1444b03a 	or	r2,r2,r17
8112092c:	1004c03a 	cmpne	r2,r2,zero
81120930:	40a2b03a 	or	r17,r8,r2
81120934:	0005883a 	mov	r2,zero
81120938:	003f1606 	br	81120594 <__reset+0xfb100594>
8112093c:	02000434 	movhi	r8,16
81120940:	0009883a 	mov	r4,zero
81120944:	423fffc4 	addi	r8,r8,-1
81120948:	00bfffc4 	movi	r2,-1
8112094c:	0401ffc4 	movi	r16,2047
81120950:	003e6606 	br	811202ec <__reset+0xfb1002ec>
81120954:	1c62b03a 	or	r17,r3,r17
81120958:	8822c03a 	cmpne	r17,r17,zero
8112095c:	0005883a 	mov	r2,zero
81120960:	003f9906 	br	811207c8 <__reset+0xfb1007c8>
81120964:	2807883a 	mov	r3,r5
81120968:	3023883a 	mov	r17,r6
8112096c:	0401ffc4 	movi	r16,2047
81120970:	003df506 	br	81120148 <__reset+0xfb100148>
81120974:	2807883a 	mov	r3,r5
81120978:	3023883a 	mov	r17,r6
8112097c:	003df206 	br	81120148 <__reset+0xfb100148>
81120980:	123ff804 	addi	r8,r2,-32
81120984:	01000804 	movi	r4,32
81120988:	1a10d83a 	srl	r8,r3,r8
8112098c:	11000a26 	beq	r2,r4,811209b8 <__subdf3+0x8fc>
81120990:	01001004 	movi	r4,64
81120994:	2085c83a 	sub	r2,r4,r2
81120998:	1884983a 	sll	r2,r3,r2
8112099c:	1444b03a 	or	r2,r2,r17
811209a0:	1004c03a 	cmpne	r2,r2,zero
811209a4:	40a2b03a 	or	r17,r8,r2
811209a8:	0005883a 	mov	r2,zero
811209ac:	003f8606 	br	811207c8 <__reset+0xfb1007c8>
811209b0:	0005883a 	mov	r2,zero
811209b4:	003fdc06 	br	81120928 <__reset+0xfb100928>
811209b8:	0005883a 	mov	r2,zero
811209bc:	003ff706 	br	8112099c <__reset+0xfb10099c>

811209c0 <__fixdfsi>:
811209c0:	280cd53a 	srli	r6,r5,20
811209c4:	00c00434 	movhi	r3,16
811209c8:	18ffffc4 	addi	r3,r3,-1
811209cc:	3181ffcc 	andi	r6,r6,2047
811209d0:	01c0ff84 	movi	r7,1022
811209d4:	28c6703a 	and	r3,r5,r3
811209d8:	280ad7fa 	srli	r5,r5,31
811209dc:	3980120e 	bge	r7,r6,81120a28 <__fixdfsi+0x68>
811209e0:	00810744 	movi	r2,1053
811209e4:	11800c16 	blt	r2,r6,81120a18 <__fixdfsi+0x58>
811209e8:	00810cc4 	movi	r2,1075
811209ec:	1185c83a 	sub	r2,r2,r6
811209f0:	01c007c4 	movi	r7,31
811209f4:	18c00434 	orhi	r3,r3,16
811209f8:	38800d16 	blt	r7,r2,81120a30 <__fixdfsi+0x70>
811209fc:	31befb44 	addi	r6,r6,-1043
81120a00:	2084d83a 	srl	r2,r4,r2
81120a04:	1986983a 	sll	r3,r3,r6
81120a08:	1884b03a 	or	r2,r3,r2
81120a0c:	28000726 	beq	r5,zero,81120a2c <__fixdfsi+0x6c>
81120a10:	0085c83a 	sub	r2,zero,r2
81120a14:	f800283a 	ret
81120a18:	00a00034 	movhi	r2,32768
81120a1c:	10bfffc4 	addi	r2,r2,-1
81120a20:	2885883a 	add	r2,r5,r2
81120a24:	f800283a 	ret
81120a28:	0005883a 	mov	r2,zero
81120a2c:	f800283a 	ret
81120a30:	008104c4 	movi	r2,1043
81120a34:	1185c83a 	sub	r2,r2,r6
81120a38:	1884d83a 	srl	r2,r3,r2
81120a3c:	003ff306 	br	81120a0c <__reset+0xfb100a0c>

81120a40 <__floatsidf>:
81120a40:	defffd04 	addi	sp,sp,-12
81120a44:	de00012e 	bgeu	sp,et,81120a4c <__floatsidf+0xc>
81120a48:	003b68fa 	trap	3
81120a4c:	dfc00215 	stw	ra,8(sp)
81120a50:	dc400115 	stw	r17,4(sp)
81120a54:	dc000015 	stw	r16,0(sp)
81120a58:	20002b26 	beq	r4,zero,81120b08 <__floatsidf+0xc8>
81120a5c:	2023883a 	mov	r17,r4
81120a60:	2020d7fa 	srli	r16,r4,31
81120a64:	20002d16 	blt	r4,zero,81120b1c <__floatsidf+0xdc>
81120a68:	8809883a 	mov	r4,r17
81120a6c:	1120de40 	call	81120de4 <__clzsi2>
81120a70:	01410784 	movi	r5,1054
81120a74:	288bc83a 	sub	r5,r5,r2
81120a78:	01010cc4 	movi	r4,1075
81120a7c:	2149c83a 	sub	r4,r4,r5
81120a80:	00c007c4 	movi	r3,31
81120a84:	1900160e 	bge	r3,r4,81120ae0 <__floatsidf+0xa0>
81120a88:	00c104c4 	movi	r3,1043
81120a8c:	1947c83a 	sub	r3,r3,r5
81120a90:	88c6983a 	sll	r3,r17,r3
81120a94:	00800434 	movhi	r2,16
81120a98:	10bfffc4 	addi	r2,r2,-1
81120a9c:	1886703a 	and	r3,r3,r2
81120aa0:	2941ffcc 	andi	r5,r5,2047
81120aa4:	800d883a 	mov	r6,r16
81120aa8:	0005883a 	mov	r2,zero
81120aac:	280a953a 	slli	r5,r5,20
81120ab0:	31803fcc 	andi	r6,r6,255
81120ab4:	01000434 	movhi	r4,16
81120ab8:	300c97fa 	slli	r6,r6,31
81120abc:	213fffc4 	addi	r4,r4,-1
81120ac0:	1906703a 	and	r3,r3,r4
81120ac4:	1946b03a 	or	r3,r3,r5
81120ac8:	1986b03a 	or	r3,r3,r6
81120acc:	dfc00217 	ldw	ra,8(sp)
81120ad0:	dc400117 	ldw	r17,4(sp)
81120ad4:	dc000017 	ldw	r16,0(sp)
81120ad8:	dec00304 	addi	sp,sp,12
81120adc:	f800283a 	ret
81120ae0:	00c002c4 	movi	r3,11
81120ae4:	1887c83a 	sub	r3,r3,r2
81120ae8:	88c6d83a 	srl	r3,r17,r3
81120aec:	8904983a 	sll	r2,r17,r4
81120af0:	01000434 	movhi	r4,16
81120af4:	213fffc4 	addi	r4,r4,-1
81120af8:	2941ffcc 	andi	r5,r5,2047
81120afc:	1906703a 	and	r3,r3,r4
81120b00:	800d883a 	mov	r6,r16
81120b04:	003fe906 	br	81120aac <__reset+0xfb100aac>
81120b08:	000d883a 	mov	r6,zero
81120b0c:	000b883a 	mov	r5,zero
81120b10:	0007883a 	mov	r3,zero
81120b14:	0005883a 	mov	r2,zero
81120b18:	003fe406 	br	81120aac <__reset+0xfb100aac>
81120b1c:	0123c83a 	sub	r17,zero,r4
81120b20:	003fd106 	br	81120a68 <__reset+0xfb100a68>

81120b24 <__extendsfdf2>:
81120b24:	200ad5fa 	srli	r5,r4,23
81120b28:	defffd04 	addi	sp,sp,-12
81120b2c:	de00012e 	bgeu	sp,et,81120b34 <__extendsfdf2+0x10>
81120b30:	003b68fa 	trap	3
81120b34:	29403fcc 	andi	r5,r5,255
81120b38:	dc400115 	stw	r17,4(sp)
81120b3c:	29800044 	addi	r6,r5,1
81120b40:	04402034 	movhi	r17,128
81120b44:	dc000015 	stw	r16,0(sp)
81120b48:	8c7fffc4 	addi	r17,r17,-1
81120b4c:	dfc00215 	stw	ra,8(sp)
81120b50:	31803fcc 	andi	r6,r6,255
81120b54:	00800044 	movi	r2,1
81120b58:	8922703a 	and	r17,r17,r4
81120b5c:	2020d7fa 	srli	r16,r4,31
81120b60:	1180110e 	bge	r2,r6,81120ba8 <__extendsfdf2+0x84>
81120b64:	880cd0fa 	srli	r6,r17,3
81120b68:	8822977a 	slli	r17,r17,29
81120b6c:	2940e004 	addi	r5,r5,896
81120b70:	2941ffcc 	andi	r5,r5,2047
81120b74:	2804953a 	slli	r2,r5,20
81120b78:	01400434 	movhi	r5,16
81120b7c:	800697fa 	slli	r3,r16,31
81120b80:	297fffc4 	addi	r5,r5,-1
81120b84:	314a703a 	and	r5,r6,r5
81120b88:	288ab03a 	or	r5,r5,r2
81120b8c:	28c6b03a 	or	r3,r5,r3
81120b90:	8805883a 	mov	r2,r17
81120b94:	dfc00217 	ldw	ra,8(sp)
81120b98:	dc400117 	ldw	r17,4(sp)
81120b9c:	dc000017 	ldw	r16,0(sp)
81120ba0:	dec00304 	addi	sp,sp,12
81120ba4:	f800283a 	ret
81120ba8:	2800111e 	bne	r5,zero,81120bf0 <__extendsfdf2+0xcc>
81120bac:	88001c26 	beq	r17,zero,81120c20 <__extendsfdf2+0xfc>
81120bb0:	8809883a 	mov	r4,r17
81120bb4:	1120de40 	call	81120de4 <__clzsi2>
81120bb8:	00c00284 	movi	r3,10
81120bbc:	18801b16 	blt	r3,r2,81120c2c <__extendsfdf2+0x108>
81120bc0:	018002c4 	movi	r6,11
81120bc4:	308dc83a 	sub	r6,r6,r2
81120bc8:	11000544 	addi	r4,r2,21
81120bcc:	8986d83a 	srl	r3,r17,r6
81120bd0:	8922983a 	sll	r17,r17,r4
81120bd4:	0180e244 	movi	r6,905
81120bd8:	01400434 	movhi	r5,16
81120bdc:	3085c83a 	sub	r2,r6,r2
81120be0:	297fffc4 	addi	r5,r5,-1
81120be4:	194c703a 	and	r6,r3,r5
81120be8:	1141ffcc 	andi	r5,r2,2047
81120bec:	003fe006 	br	81120b70 <__reset+0xfb100b70>
81120bf0:	88000826 	beq	r17,zero,81120c14 <__extendsfdf2+0xf0>
81120bf4:	880cd0fa 	srli	r6,r17,3
81120bf8:	00800434 	movhi	r2,16
81120bfc:	10bfffc4 	addi	r2,r2,-1
81120c00:	31800234 	orhi	r6,r6,8
81120c04:	8822977a 	slli	r17,r17,29
81120c08:	308c703a 	and	r6,r6,r2
81120c0c:	0141ffc4 	movi	r5,2047
81120c10:	003fd706 	br	81120b70 <__reset+0xfb100b70>
81120c14:	0141ffc4 	movi	r5,2047
81120c18:	000d883a 	mov	r6,zero
81120c1c:	003fd406 	br	81120b70 <__reset+0xfb100b70>
81120c20:	000b883a 	mov	r5,zero
81120c24:	000d883a 	mov	r6,zero
81120c28:	003fd106 	br	81120b70 <__reset+0xfb100b70>
81120c2c:	11bffd44 	addi	r6,r2,-11
81120c30:	8986983a 	sll	r3,r17,r6
81120c34:	0023883a 	mov	r17,zero
81120c38:	003fe606 	br	81120bd4 <__reset+0xfb100bd4>

81120c3c <__truncdfsf2>:
81120c3c:	2810d53a 	srli	r8,r5,20
81120c40:	01c00434 	movhi	r7,16
81120c44:	39ffffc4 	addi	r7,r7,-1
81120c48:	29ce703a 	and	r7,r5,r7
81120c4c:	4201ffcc 	andi	r8,r8,2047
81120c50:	380e90fa 	slli	r7,r7,3
81120c54:	200cd77a 	srli	r6,r4,29
81120c58:	42400044 	addi	r9,r8,1
81120c5c:	4a41ffcc 	andi	r9,r9,2047
81120c60:	00c00044 	movi	r3,1
81120c64:	280ad7fa 	srli	r5,r5,31
81120c68:	31ceb03a 	or	r7,r6,r7
81120c6c:	200490fa 	slli	r2,r4,3
81120c70:	1a40230e 	bge	r3,r9,81120d00 <__truncdfsf2+0xc4>
81120c74:	40ff2004 	addi	r3,r8,-896
81120c78:	01803f84 	movi	r6,254
81120c7c:	30c01516 	blt	r6,r3,81120cd4 <__truncdfsf2+0x98>
81120c80:	00c0380e 	bge	zero,r3,81120d64 <__truncdfsf2+0x128>
81120c84:	200c91ba 	slli	r6,r4,6
81120c88:	380e90fa 	slli	r7,r7,3
81120c8c:	1004d77a 	srli	r2,r2,29
81120c90:	300cc03a 	cmpne	r6,r6,zero
81120c94:	31ccb03a 	or	r6,r6,r7
81120c98:	308cb03a 	or	r6,r6,r2
81120c9c:	308001cc 	andi	r2,r6,7
81120ca0:	10000426 	beq	r2,zero,81120cb4 <__truncdfsf2+0x78>
81120ca4:	308003cc 	andi	r2,r6,15
81120ca8:	01000104 	movi	r4,4
81120cac:	11000126 	beq	r2,r4,81120cb4 <__truncdfsf2+0x78>
81120cb0:	31800104 	addi	r6,r6,4
81120cb4:	3081002c 	andhi	r2,r6,1024
81120cb8:	10001626 	beq	r2,zero,81120d14 <__truncdfsf2+0xd8>
81120cbc:	18c00044 	addi	r3,r3,1
81120cc0:	00803fc4 	movi	r2,255
81120cc4:	18800326 	beq	r3,r2,81120cd4 <__truncdfsf2+0x98>
81120cc8:	300c91ba 	slli	r6,r6,6
81120ccc:	300cd27a 	srli	r6,r6,9
81120cd0:	00000206 	br	81120cdc <__truncdfsf2+0xa0>
81120cd4:	00ffffc4 	movi	r3,-1
81120cd8:	000d883a 	mov	r6,zero
81120cdc:	18c03fcc 	andi	r3,r3,255
81120ce0:	180895fa 	slli	r4,r3,23
81120ce4:	00c02034 	movhi	r3,128
81120ce8:	280a97fa 	slli	r5,r5,31
81120cec:	18ffffc4 	addi	r3,r3,-1
81120cf0:	30c6703a 	and	r3,r6,r3
81120cf4:	1906b03a 	or	r3,r3,r4
81120cf8:	1944b03a 	or	r2,r3,r5
81120cfc:	f800283a 	ret
81120d00:	40000b1e 	bne	r8,zero,81120d30 <__truncdfsf2+0xf4>
81120d04:	388cb03a 	or	r6,r7,r2
81120d08:	0007883a 	mov	r3,zero
81120d0c:	30000426 	beq	r6,zero,81120d20 <__truncdfsf2+0xe4>
81120d10:	01800144 	movi	r6,5
81120d14:	00803fc4 	movi	r2,255
81120d18:	300cd0fa 	srli	r6,r6,3
81120d1c:	18800a26 	beq	r3,r2,81120d48 <__truncdfsf2+0x10c>
81120d20:	00802034 	movhi	r2,128
81120d24:	10bfffc4 	addi	r2,r2,-1
81120d28:	308c703a 	and	r6,r6,r2
81120d2c:	003feb06 	br	81120cdc <__reset+0xfb100cdc>
81120d30:	3888b03a 	or	r4,r7,r2
81120d34:	203fe726 	beq	r4,zero,81120cd4 <__reset+0xfb100cd4>
81120d38:	380c90fa 	slli	r6,r7,3
81120d3c:	00c03fc4 	movi	r3,255
81120d40:	31808034 	orhi	r6,r6,512
81120d44:	003fd506 	br	81120c9c <__reset+0xfb100c9c>
81120d48:	303fe226 	beq	r6,zero,81120cd4 <__reset+0xfb100cd4>
81120d4c:	00802034 	movhi	r2,128
81120d50:	31801034 	orhi	r6,r6,64
81120d54:	10bfffc4 	addi	r2,r2,-1
81120d58:	00ffffc4 	movi	r3,-1
81120d5c:	308c703a 	and	r6,r6,r2
81120d60:	003fde06 	br	81120cdc <__reset+0xfb100cdc>
81120d64:	013ffa44 	movi	r4,-23
81120d68:	19000e16 	blt	r3,r4,81120da4 <__truncdfsf2+0x168>
81120d6c:	01000784 	movi	r4,30
81120d70:	20c9c83a 	sub	r4,r4,r3
81120d74:	018007c4 	movi	r6,31
81120d78:	39c02034 	orhi	r7,r7,128
81120d7c:	31000b16 	blt	r6,r4,81120dac <__truncdfsf2+0x170>
81120d80:	423f2084 	addi	r8,r8,-894
81120d84:	120c983a 	sll	r6,r2,r8
81120d88:	3a0e983a 	sll	r7,r7,r8
81120d8c:	1104d83a 	srl	r2,r2,r4
81120d90:	300cc03a 	cmpne	r6,r6,zero
81120d94:	31ceb03a 	or	r7,r6,r7
81120d98:	388cb03a 	or	r6,r7,r2
81120d9c:	0007883a 	mov	r3,zero
81120da0:	003fbe06 	br	81120c9c <__reset+0xfb100c9c>
81120da4:	0007883a 	mov	r3,zero
81120da8:	003fd906 	br	81120d10 <__reset+0xfb100d10>
81120dac:	01bfff84 	movi	r6,-2
81120db0:	30cdc83a 	sub	r6,r6,r3
81120db4:	00c00804 	movi	r3,32
81120db8:	398cd83a 	srl	r6,r7,r6
81120dbc:	20c00726 	beq	r4,r3,81120ddc <__truncdfsf2+0x1a0>
81120dc0:	423f2884 	addi	r8,r8,-862
81120dc4:	3a0e983a 	sll	r7,r7,r8
81120dc8:	3884b03a 	or	r2,r7,r2
81120dcc:	1004c03a 	cmpne	r2,r2,zero
81120dd0:	118cb03a 	or	r6,r2,r6
81120dd4:	0007883a 	mov	r3,zero
81120dd8:	003fb006 	br	81120c9c <__reset+0xfb100c9c>
81120ddc:	000f883a 	mov	r7,zero
81120de0:	003ff906 	br	81120dc8 <__reset+0xfb100dc8>

81120de4 <__clzsi2>:
81120de4:	00bfffd4 	movui	r2,65535
81120de8:	11000536 	bltu	r2,r4,81120e00 <__clzsi2+0x1c>
81120dec:	00803fc4 	movi	r2,255
81120df0:	11000f36 	bltu	r2,r4,81120e30 <__clzsi2+0x4c>
81120df4:	00800804 	movi	r2,32
81120df8:	0007883a 	mov	r3,zero
81120dfc:	00000506 	br	81120e14 <__clzsi2+0x30>
81120e00:	00804034 	movhi	r2,256
81120e04:	10bfffc4 	addi	r2,r2,-1
81120e08:	11000c2e 	bgeu	r2,r4,81120e3c <__clzsi2+0x58>
81120e0c:	00800204 	movi	r2,8
81120e10:	00c00604 	movi	r3,24
81120e14:	20c8d83a 	srl	r4,r4,r3
81120e18:	00e04574 	movhi	r3,33045
81120e1c:	18c01d04 	addi	r3,r3,116
81120e20:	1909883a 	add	r4,r3,r4
81120e24:	20c00003 	ldbu	r3,0(r4)
81120e28:	10c5c83a 	sub	r2,r2,r3
81120e2c:	f800283a 	ret
81120e30:	00800604 	movi	r2,24
81120e34:	00c00204 	movi	r3,8
81120e38:	003ff606 	br	81120e14 <__reset+0xfb100e14>
81120e3c:	00800404 	movi	r2,16
81120e40:	1007883a 	mov	r3,r2
81120e44:	003ff306 	br	81120e14 <__reset+0xfb100e14>

81120e48 <atoi>:
81120e48:	01800284 	movi	r6,10
81120e4c:	000b883a 	mov	r5,zero
81120e50:	1122e641 	jmpi	81122e64 <strtol>

81120e54 <_atoi_r>:
81120e54:	01c00284 	movi	r7,10
81120e58:	000d883a 	mov	r6,zero
81120e5c:	1122c241 	jmpi	81122c24 <_strtol_r>

81120e60 <_fopen_r>:
81120e60:	defffa04 	addi	sp,sp,-24
81120e64:	3005883a 	mov	r2,r6
81120e68:	de00012e 	bgeu	sp,et,81120e70 <_fopen_r+0x10>
81120e6c:	003b68fa 	trap	3
81120e70:	d80d883a 	mov	r6,sp
81120e74:	dcc00415 	stw	r19,16(sp)
81120e78:	2827883a 	mov	r19,r5
81120e7c:	100b883a 	mov	r5,r2
81120e80:	dc800315 	stw	r18,12(sp)
81120e84:	dfc00515 	stw	ra,20(sp)
81120e88:	dc400215 	stw	r17,8(sp)
81120e8c:	dc000115 	stw	r16,4(sp)
81120e90:	2025883a 	mov	r18,r4
81120e94:	112ae6c0 	call	8112ae6c <__sflags>
81120e98:	10002726 	beq	r2,zero,81120f38 <_fopen_r+0xd8>
81120e9c:	9009883a 	mov	r4,r18
81120ea0:	1023883a 	mov	r17,r2
81120ea4:	112ace40 	call	8112ace4 <__sfp>
81120ea8:	1021883a 	mov	r16,r2
81120eac:	10002226 	beq	r2,zero,81120f38 <_fopen_r+0xd8>
81120eb0:	d9800017 	ldw	r6,0(sp)
81120eb4:	01c06d84 	movi	r7,438
81120eb8:	980b883a 	mov	r5,r19
81120ebc:	9009883a 	mov	r4,r18
81120ec0:	11222cc0 	call	811222cc <_open_r>
81120ec4:	10001916 	blt	r2,zero,81120f2c <_fopen_r+0xcc>
81120ec8:	8080038d 	sth	r2,14(r16)
81120ecc:	00a044b4 	movhi	r2,33042
81120ed0:	108a6a04 	addi	r2,r2,10664
81120ed4:	80800815 	stw	r2,32(r16)
81120ed8:	00a044b4 	movhi	r2,33042
81120edc:	108a8304 	addi	r2,r2,10764
81120ee0:	80800915 	stw	r2,36(r16)
81120ee4:	00a044b4 	movhi	r2,33042
81120ee8:	108aa404 	addi	r2,r2,10896
81120eec:	80800a15 	stw	r2,40(r16)
81120ef0:	00a044b4 	movhi	r2,33042
81120ef4:	108abd04 	addi	r2,r2,10996
81120ef8:	8440030d 	sth	r17,12(r16)
81120efc:	84000715 	stw	r16,28(r16)
81120f00:	80800b15 	stw	r2,44(r16)
81120f04:	8c40400c 	andi	r17,r17,256
81120f08:	88000d1e 	bne	r17,zero,81120f40 <_fopen_r+0xe0>
81120f0c:	8005883a 	mov	r2,r16
81120f10:	dfc00517 	ldw	ra,20(sp)
81120f14:	dcc00417 	ldw	r19,16(sp)
81120f18:	dc800317 	ldw	r18,12(sp)
81120f1c:	dc400217 	ldw	r17,8(sp)
81120f20:	dc000117 	ldw	r16,4(sp)
81120f24:	dec00604 	addi	sp,sp,24
81120f28:	f800283a 	ret
81120f2c:	112ae2c0 	call	8112ae2c <__sfp_lock_acquire>
81120f30:	8000030d 	sth	zero,12(r16)
81120f34:	112ae300 	call	8112ae30 <__sfp_lock_release>
81120f38:	0005883a 	mov	r2,zero
81120f3c:	003ff406 	br	81120f10 <__reset+0xfb100f10>
81120f40:	01c00084 	movi	r7,2
81120f44:	000d883a 	mov	r6,zero
81120f48:	800b883a 	mov	r5,r16
81120f4c:	9009883a 	mov	r4,r18
81120f50:	11210800 	call	81121080 <_fseek_r>
81120f54:	8005883a 	mov	r2,r16
81120f58:	003fed06 	br	81120f10 <__reset+0xfb100f10>

81120f5c <fopen>:
81120f5c:	00a04574 	movhi	r2,33045
81120f60:	108ad804 	addi	r2,r2,11104
81120f64:	280d883a 	mov	r6,r5
81120f68:	200b883a 	mov	r5,r4
81120f6c:	11000017 	ldw	r4,0(r2)
81120f70:	1120e601 	jmpi	81120e60 <_fopen_r>

81120f74 <_fprintf_r>:
81120f74:	defffe04 	addi	sp,sp,-8
81120f78:	2809883a 	mov	r4,r5
81120f7c:	300b883a 	mov	r5,r6
81120f80:	de00012e 	bgeu	sp,et,81120f88 <_fprintf_r+0x14>
81120f84:	003b68fa 	trap	3
81120f88:	dfc00015 	stw	ra,0(sp)
81120f8c:	d9c00115 	stw	r7,4(sp)
81120f90:	d9800104 	addi	r6,sp,4
81120f94:	11272600 	call	81127260 <__vfprintf_internal>
81120f98:	dfc00017 	ldw	ra,0(sp)
81120f9c:	dec00204 	addi	sp,sp,8
81120fa0:	f800283a 	ret

81120fa4 <fprintf>:
81120fa4:	defffd04 	addi	sp,sp,-12
81120fa8:	de00012e 	bgeu	sp,et,81120fb0 <fprintf+0xc>
81120fac:	003b68fa 	trap	3
81120fb0:	dfc00015 	stw	ra,0(sp)
81120fb4:	d9800115 	stw	r6,4(sp)
81120fb8:	d9c00215 	stw	r7,8(sp)
81120fbc:	d9800104 	addi	r6,sp,4
81120fc0:	11272600 	call	81127260 <__vfprintf_internal>
81120fc4:	dfc00017 	ldw	ra,0(sp)
81120fc8:	dec00304 	addi	sp,sp,12
81120fcc:	f800283a 	ret

81120fd0 <_fputc_r>:
81120fd0:	defffc04 	addi	sp,sp,-16
81120fd4:	de00012e 	bgeu	sp,et,81120fdc <_fputc_r+0xc>
81120fd8:	003b68fa 	trap	3
81120fdc:	dc000215 	stw	r16,8(sp)
81120fe0:	dfc00315 	stw	ra,12(sp)
81120fe4:	2021883a 	mov	r16,r4
81120fe8:	20000726 	beq	r4,zero,81121008 <_fputc_r+0x38>
81120fec:	20800e17 	ldw	r2,56(r4)
81120ff0:	1000051e 	bne	r2,zero,81121008 <_fputc_r+0x38>
81120ff4:	d9400015 	stw	r5,0(sp)
81120ff8:	d9800115 	stw	r6,4(sp)
81120ffc:	112ae1c0 	call	8112ae1c <__sinit>
81121000:	d9800117 	ldw	r6,4(sp)
81121004:	d9400017 	ldw	r5,0(sp)
81121008:	8009883a 	mov	r4,r16
8112100c:	dfc00317 	ldw	ra,12(sp)
81121010:	dc000217 	ldw	r16,8(sp)
81121014:	dec00404 	addi	sp,sp,16
81121018:	11223b01 	jmpi	811223b0 <_putc_r>

8112101c <fputc>:
8112101c:	00a04574 	movhi	r2,33045
81121020:	defffc04 	addi	sp,sp,-16
81121024:	108ad804 	addi	r2,r2,11104
81121028:	de00012e 	bgeu	sp,et,81121030 <fputc+0x14>
8112102c:	003b68fa 	trap	3
81121030:	dc000115 	stw	r16,4(sp)
81121034:	14000017 	ldw	r16,0(r2)
81121038:	dc400215 	stw	r17,8(sp)
8112103c:	dfc00315 	stw	ra,12(sp)
81121040:	2023883a 	mov	r17,r4
81121044:	80000626 	beq	r16,zero,81121060 <fputc+0x44>
81121048:	80800e17 	ldw	r2,56(r16)
8112104c:	1000041e 	bne	r2,zero,81121060 <fputc+0x44>
81121050:	8009883a 	mov	r4,r16
81121054:	d9400015 	stw	r5,0(sp)
81121058:	112ae1c0 	call	8112ae1c <__sinit>
8112105c:	d9400017 	ldw	r5,0(sp)
81121060:	280d883a 	mov	r6,r5
81121064:	8009883a 	mov	r4,r16
81121068:	880b883a 	mov	r5,r17
8112106c:	dfc00317 	ldw	ra,12(sp)
81121070:	dc400217 	ldw	r17,8(sp)
81121074:	dc000117 	ldw	r16,4(sp)
81121078:	dec00404 	addi	sp,sp,16
8112107c:	11223b01 	jmpi	811223b0 <_putc_r>

81121080 <_fseek_r>:
81121080:	11210a01 	jmpi	811210a0 <_fseeko_r>

81121084 <fseek>:
81121084:	00a04574 	movhi	r2,33045
81121088:	108ad804 	addi	r2,r2,11104
8112108c:	300f883a 	mov	r7,r6
81121090:	280d883a 	mov	r6,r5
81121094:	200b883a 	mov	r5,r4
81121098:	11000017 	ldw	r4,0(r2)
8112109c:	11210a01 	jmpi	811210a0 <_fseeko_r>

811210a0 <_fseeko_r>:
811210a0:	deffe804 	addi	sp,sp,-96
811210a4:	de00012e 	bgeu	sp,et,811210ac <_fseeko_r+0xc>
811210a8:	003b68fa 	trap	3
811210ac:	dd401415 	stw	r21,80(sp)
811210b0:	dc801115 	stw	r18,68(sp)
811210b4:	dc401015 	stw	r17,64(sp)
811210b8:	dc000f15 	stw	r16,60(sp)
811210bc:	dfc01715 	stw	ra,92(sp)
811210c0:	ddc01615 	stw	r23,88(sp)
811210c4:	dd801515 	stw	r22,84(sp)
811210c8:	dd001315 	stw	r20,76(sp)
811210cc:	dcc01215 	stw	r19,72(sp)
811210d0:	2023883a 	mov	r17,r4
811210d4:	2821883a 	mov	r16,r5
811210d8:	302b883a 	mov	r21,r6
811210dc:	3825883a 	mov	r18,r7
811210e0:	20000226 	beq	r4,zero,811210ec <_fseeko_r+0x4c>
811210e4:	20800e17 	ldw	r2,56(r4)
811210e8:	10005a26 	beq	r2,zero,81121254 <_fseeko_r+0x1b4>
811210ec:	8080030b 	ldhu	r2,12(r16)
811210f0:	00c04204 	movi	r3,264
811210f4:	1080420c 	andi	r2,r2,264
811210f8:	10c05b26 	beq	r2,r3,81121268 <_fseeko_r+0x1c8>
811210fc:	85000a17 	ldw	r20,40(r16)
81121100:	a000f626 	beq	r20,zero,811214dc <_fseeko_r+0x43c>
81121104:	00800044 	movi	r2,1
81121108:	90803e26 	beq	r18,r2,81121204 <_fseeko_r+0x164>
8112110c:	00800084 	movi	r2,2
81121110:	90801026 	beq	r18,r2,81121154 <_fseeko_r+0xb4>
81121114:	90000f26 	beq	r18,zero,81121154 <_fseeko_r+0xb4>
81121118:	00800584 	movi	r2,22
8112111c:	88800015 	stw	r2,0(r17)
81121120:	04ffffc4 	movi	r19,-1
81121124:	9805883a 	mov	r2,r19
81121128:	dfc01717 	ldw	ra,92(sp)
8112112c:	ddc01617 	ldw	r23,88(sp)
81121130:	dd801517 	ldw	r22,84(sp)
81121134:	dd401417 	ldw	r21,80(sp)
81121138:	dd001317 	ldw	r20,76(sp)
8112113c:	dcc01217 	ldw	r19,72(sp)
81121140:	dc801117 	ldw	r18,68(sp)
81121144:	dc401017 	ldw	r17,64(sp)
81121148:	dc000f17 	ldw	r16,60(sp)
8112114c:	dec01804 	addi	sp,sp,96
81121150:	f800283a 	ret
81121154:	80800417 	ldw	r2,16(r16)
81121158:	002f883a 	mov	r23,zero
8112115c:	0027883a 	mov	r19,zero
81121160:	1000cb26 	beq	r2,zero,81121490 <_fseeko_r+0x3f0>
81121164:	8080030b 	ldhu	r2,12(r16)
81121168:	10c2068c 	andi	r3,r2,2074
8112116c:	1800071e 	bne	r3,zero,8112118c <_fseeko_r+0xec>
81121170:	10c1000c 	andi	r3,r2,1024
81121174:	1800451e 	bne	r3,zero,8112128c <_fseeko_r+0x1ec>
81121178:	00e044b4 	movhi	r3,33042
8112117c:	18caa404 	addi	r3,r3,10896
81121180:	a0c0b726 	beq	r20,r3,81121460 <_fseeko_r+0x3c0>
81121184:	10820014 	ori	r2,r2,2048
81121188:	8080030d 	sth	r2,12(r16)
8112118c:	800b883a 	mov	r5,r16
81121190:	8809883a 	mov	r4,r17
81121194:	112aa200 	call	8112aa20 <_fflush_r>
81121198:	1027883a 	mov	r19,r2
8112119c:	103fe01e 	bne	r2,zero,81121120 <__reset+0xfb101120>
811211a0:	81400717 	ldw	r5,28(r16)
811211a4:	900f883a 	mov	r7,r18
811211a8:	a80d883a 	mov	r6,r21
811211ac:	8809883a 	mov	r4,r17
811211b0:	a03ee83a 	callr	r20
811211b4:	00ffffc4 	movi	r3,-1
811211b8:	10ffd926 	beq	r2,r3,81121120 <__reset+0xfb101120>
811211bc:	81400c17 	ldw	r5,48(r16)
811211c0:	28000526 	beq	r5,zero,811211d8 <_fseeko_r+0x138>
811211c4:	80801004 	addi	r2,r16,64
811211c8:	28800226 	beq	r5,r2,811211d4 <_fseeko_r+0x134>
811211cc:	8809883a 	mov	r4,r17
811211d0:	112b2b40 	call	8112b2b4 <_free_r>
811211d4:	80000c15 	stw	zero,48(r16)
811211d8:	8080030b 	ldhu	r2,12(r16)
811211dc:	80c00417 	ldw	r3,16(r16)
811211e0:	80000115 	stw	zero,4(r16)
811211e4:	10bdf7cc 	andi	r2,r2,63455
811211e8:	80c00015 	stw	r3,0(r16)
811211ec:	8080030d 	sth	r2,12(r16)
811211f0:	01800204 	movi	r6,8
811211f4:	000b883a 	mov	r5,zero
811211f8:	81001704 	addi	r4,r16,92
811211fc:	11221a40 	call	811221a4 <memset>
81121200:	003fc806 	br	81121124 <__reset+0xfb101124>
81121204:	800b883a 	mov	r5,r16
81121208:	8809883a 	mov	r4,r17
8112120c:	112aa200 	call	8112aa20 <_fflush_r>
81121210:	8080030b 	ldhu	r2,12(r16)
81121214:	10c4000c 	andi	r3,r2,4096
81121218:	18008726 	beq	r3,zero,81121438 <_fseeko_r+0x398>
8112121c:	84c01417 	ldw	r19,80(r16)
81121220:	10c0010c 	andi	r3,r2,4
81121224:	1800431e 	bne	r3,zero,81121334 <_fseeko_r+0x294>
81121228:	1080020c 	andi	r2,r2,8
8112122c:	10008026 	beq	r2,zero,81121430 <_fseeko_r+0x390>
81121230:	80c00017 	ldw	r3,0(r16)
81121234:	80800417 	ldw	r2,16(r16)
81121238:	18000226 	beq	r3,zero,81121244 <_fseeko_r+0x1a4>
8112123c:	1887c83a 	sub	r3,r3,r2
81121240:	98e7883a 	add	r19,r19,r3
81121244:	aceb883a 	add	r21,r21,r19
81121248:	05c00044 	movi	r23,1
8112124c:	0025883a 	mov	r18,zero
81121250:	003fc306 	br	81121160 <__reset+0xfb101160>
81121254:	112ae1c0 	call	8112ae1c <__sinit>
81121258:	8080030b 	ldhu	r2,12(r16)
8112125c:	00c04204 	movi	r3,264
81121260:	1080420c 	andi	r2,r2,264
81121264:	10ffa51e 	bne	r2,r3,811210fc <__reset+0xfb1010fc>
81121268:	800b883a 	mov	r5,r16
8112126c:	8809883a 	mov	r4,r17
81121270:	112aa200 	call	8112aa20 <_fflush_r>
81121274:	003fa106 	br	811210fc <__reset+0xfb1010fc>
81121278:	8080030b 	ldhu	r2,12(r16)
8112127c:	00c10004 	movi	r3,1024
81121280:	80c01315 	stw	r3,76(r16)
81121284:	10c4b03a 	or	r2,r2,r3
81121288:	8080030d 	sth	r2,12(r16)
8112128c:	9000311e 	bne	r18,zero,81121354 <_fseeko_r+0x2b4>
81121290:	a82d883a 	mov	r22,r21
81121294:	b800371e 	bne	r23,zero,81121374 <_fseeko_r+0x2d4>
81121298:	8080030b 	ldhu	r2,12(r16)
8112129c:	1084000c 	andi	r2,r2,4096
811212a0:	10007f26 	beq	r2,zero,811214a0 <_fseeko_r+0x400>
811212a4:	80801417 	ldw	r2,80(r16)
811212a8:	81800117 	ldw	r6,4(r16)
811212ac:	81400c17 	ldw	r5,48(r16)
811212b0:	11a7c83a 	sub	r19,r2,r6
811212b4:	28008226 	beq	r5,zero,811214c0 <_fseeko_r+0x420>
811212b8:	81c00f17 	ldw	r7,60(r16)
811212bc:	99e7c83a 	sub	r19,r19,r7
811212c0:	81000e17 	ldw	r4,56(r16)
811212c4:	80800417 	ldw	r2,16(r16)
811212c8:	99a7883a 	add	r19,r19,r6
811212cc:	2087c83a 	sub	r3,r4,r2
811212d0:	98e7c83a 	sub	r19,r19,r3
811212d4:	38c7883a 	add	r3,r7,r3
811212d8:	b4c02b16 	blt	r22,r19,81121388 <_fseeko_r+0x2e8>
811212dc:	98c9883a 	add	r4,r19,r3
811212e0:	b100292e 	bgeu	r22,r4,81121388 <_fseeko_r+0x2e8>
811212e4:	b4e7c83a 	sub	r19,r22,r19
811212e8:	14c5883a 	add	r2,r2,r19
811212ec:	1ce7c83a 	sub	r19,r3,r19
811212f0:	80800015 	stw	r2,0(r16)
811212f4:	84c00115 	stw	r19,4(r16)
811212f8:	28000526 	beq	r5,zero,81121310 <_fseeko_r+0x270>
811212fc:	80801004 	addi	r2,r16,64
81121300:	28800226 	beq	r5,r2,8112130c <_fseeko_r+0x26c>
81121304:	8809883a 	mov	r4,r17
81121308:	112b2b40 	call	8112b2b4 <_free_r>
8112130c:	80000c15 	stw	zero,48(r16)
81121310:	8080030b 	ldhu	r2,12(r16)
81121314:	01800204 	movi	r6,8
81121318:	000b883a 	mov	r5,zero
8112131c:	10bff7cc 	andi	r2,r2,65503
81121320:	8080030d 	sth	r2,12(r16)
81121324:	81001704 	addi	r4,r16,92
81121328:	11221a40 	call	811221a4 <memset>
8112132c:	0027883a 	mov	r19,zero
81121330:	003f7c06 	br	81121124 <__reset+0xfb101124>
81121334:	80c00117 	ldw	r3,4(r16)
81121338:	80800c17 	ldw	r2,48(r16)
8112133c:	98e7c83a 	sub	r19,r19,r3
81121340:	10003b26 	beq	r2,zero,81121430 <_fseeko_r+0x390>
81121344:	80c00f17 	ldw	r3,60(r16)
81121348:	80800417 	ldw	r2,16(r16)
8112134c:	98e7c83a 	sub	r19,r19,r3
81121350:	003fbc06 	br	81121244 <__reset+0xfb101244>
81121354:	8140038f 	ldh	r5,14(r16)
81121358:	d80d883a 	mov	r6,sp
8112135c:	8809883a 	mov	r4,r17
81121360:	11215080 	call	81121508 <_fstat_r>
81121364:	103f891e 	bne	r2,zero,8112118c <__reset+0xfb10118c>
81121368:	dd800417 	ldw	r22,16(sp)
8112136c:	adad883a 	add	r22,r21,r22
81121370:	b83fc926 	beq	r23,zero,81121298 <__reset+0xfb101298>
81121374:	81400c17 	ldw	r5,48(r16)
81121378:	81800117 	ldw	r6,4(r16)
8112137c:	28005026 	beq	r5,zero,811214c0 <_fseeko_r+0x420>
81121380:	81c00f17 	ldw	r7,60(r16)
81121384:	003fce06 	br	811212c0 <__reset+0xfb1012c0>
81121388:	84c01317 	ldw	r19,76(r16)
8112138c:	81400717 	ldw	r5,28(r16)
81121390:	000f883a 	mov	r7,zero
81121394:	04e7c83a 	sub	r19,zero,r19
81121398:	9da6703a 	and	r19,r19,r22
8112139c:	980d883a 	mov	r6,r19
811213a0:	8809883a 	mov	r4,r17
811213a4:	a03ee83a 	callr	r20
811213a8:	00ffffc4 	movi	r3,-1
811213ac:	10ff7726 	beq	r2,r3,8112118c <__reset+0xfb10118c>
811213b0:	80800417 	ldw	r2,16(r16)
811213b4:	81400c17 	ldw	r5,48(r16)
811213b8:	80000115 	stw	zero,4(r16)
811213bc:	80800015 	stw	r2,0(r16)
811213c0:	28000526 	beq	r5,zero,811213d8 <_fseeko_r+0x338>
811213c4:	80801004 	addi	r2,r16,64
811213c8:	28800226 	beq	r5,r2,811213d4 <_fseeko_r+0x334>
811213cc:	8809883a 	mov	r4,r17
811213d0:	112b2b40 	call	8112b2b4 <_free_r>
811213d4:	80000c15 	stw	zero,48(r16)
811213d8:	8080030b 	ldhu	r2,12(r16)
811213dc:	b4e7c83a 	sub	r19,r22,r19
811213e0:	10bff7cc 	andi	r2,r2,65503
811213e4:	8080030d 	sth	r2,12(r16)
811213e8:	98000b26 	beq	r19,zero,81121418 <_fseeko_r+0x378>
811213ec:	800b883a 	mov	r5,r16
811213f0:	8809883a 	mov	r4,r17
811213f4:	11226200 	call	81122620 <__srefill_r>
811213f8:	103f641e 	bne	r2,zero,8112118c <__reset+0xfb10118c>
811213fc:	80800117 	ldw	r2,4(r16)
81121400:	14ff6236 	bltu	r2,r19,8112118c <__reset+0xfb10118c>
81121404:	80c00017 	ldw	r3,0(r16)
81121408:	14c5c83a 	sub	r2,r2,r19
8112140c:	80800115 	stw	r2,4(r16)
81121410:	1ce7883a 	add	r19,r3,r19
81121414:	84c00015 	stw	r19,0(r16)
81121418:	01800204 	movi	r6,8
8112141c:	000b883a 	mov	r5,zero
81121420:	81001704 	addi	r4,r16,92
81121424:	11221a40 	call	811221a4 <memset>
81121428:	0027883a 	mov	r19,zero
8112142c:	003f3d06 	br	81121124 <__reset+0xfb101124>
81121430:	80800417 	ldw	r2,16(r16)
81121434:	003f8306 	br	81121244 <__reset+0xfb101244>
81121438:	81400717 	ldw	r5,28(r16)
8112143c:	900f883a 	mov	r7,r18
81121440:	000d883a 	mov	r6,zero
81121444:	8809883a 	mov	r4,r17
81121448:	a03ee83a 	callr	r20
8112144c:	1027883a 	mov	r19,r2
81121450:	00bfffc4 	movi	r2,-1
81121454:	98bf3226 	beq	r19,r2,81121120 <__reset+0xfb101120>
81121458:	8080030b 	ldhu	r2,12(r16)
8112145c:	003f7006 	br	81121220 <__reset+0xfb101220>
81121460:	8140038f 	ldh	r5,14(r16)
81121464:	283f4716 	blt	r5,zero,81121184 <__reset+0xfb101184>
81121468:	d80d883a 	mov	r6,sp
8112146c:	8809883a 	mov	r4,r17
81121470:	11215080 	call	81121508 <_fstat_r>
81121474:	1000041e 	bne	r2,zero,81121488 <_fseeko_r+0x3e8>
81121478:	d8800117 	ldw	r2,4(sp)
8112147c:	00e00014 	movui	r3,32768
81121480:	10bc000c 	andi	r2,r2,61440
81121484:	10ff7c26 	beq	r2,r3,81121278 <__reset+0xfb101278>
81121488:	8080030b 	ldhu	r2,12(r16)
8112148c:	003f3d06 	br	81121184 <__reset+0xfb101184>
81121490:	800b883a 	mov	r5,r16
81121494:	8809883a 	mov	r4,r17
81121498:	112167c0 	call	8112167c <__smakebuf_r>
8112149c:	003f3106 	br	81121164 <__reset+0xfb101164>
811214a0:	81400717 	ldw	r5,28(r16)
811214a4:	01c00044 	movi	r7,1
811214a8:	000d883a 	mov	r6,zero
811214ac:	8809883a 	mov	r4,r17
811214b0:	a03ee83a 	callr	r20
811214b4:	00ffffc4 	movi	r3,-1
811214b8:	10ff7b1e 	bne	r2,r3,811212a8 <__reset+0xfb1012a8>
811214bc:	003f3306 	br	8112118c <__reset+0xfb10118c>
811214c0:	80c00017 	ldw	r3,0(r16)
811214c4:	80800417 	ldw	r2,16(r16)
811214c8:	000b883a 	mov	r5,zero
811214cc:	1887c83a 	sub	r3,r3,r2
811214d0:	98e7c83a 	sub	r19,r19,r3
811214d4:	30c7883a 	add	r3,r6,r3
811214d8:	003f7f06 	br	811212d8 <__reset+0xfb1012d8>
811214dc:	00800744 	movi	r2,29
811214e0:	88800015 	stw	r2,0(r17)
811214e4:	04ffffc4 	movi	r19,-1
811214e8:	003f0e06 	br	81121124 <__reset+0xfb101124>

811214ec <fseeko>:
811214ec:	00a04574 	movhi	r2,33045
811214f0:	108ad804 	addi	r2,r2,11104
811214f4:	300f883a 	mov	r7,r6
811214f8:	280d883a 	mov	r6,r5
811214fc:	200b883a 	mov	r5,r4
81121500:	11000017 	ldw	r4,0(r2)
81121504:	11210a01 	jmpi	811210a0 <_fseeko_r>

81121508 <_fstat_r>:
81121508:	defffd04 	addi	sp,sp,-12
8112150c:	de00012e 	bgeu	sp,et,81121514 <_fstat_r+0xc>
81121510:	003b68fa 	trap	3
81121514:	2805883a 	mov	r2,r5
81121518:	dc000015 	stw	r16,0(sp)
8112151c:	04204574 	movhi	r16,33045
81121520:	dc400115 	stw	r17,4(sp)
81121524:	840b4b04 	addi	r16,r16,11564
81121528:	2023883a 	mov	r17,r4
8112152c:	300b883a 	mov	r5,r6
81121530:	1009883a 	mov	r4,r2
81121534:	dfc00215 	stw	ra,8(sp)
81121538:	80000015 	stw	zero,0(r16)
8112153c:	1135f340 	call	81135f34 <fstat>
81121540:	00ffffc4 	movi	r3,-1
81121544:	10c00526 	beq	r2,r3,8112155c <_fstat_r+0x54>
81121548:	dfc00217 	ldw	ra,8(sp)
8112154c:	dc400117 	ldw	r17,4(sp)
81121550:	dc000017 	ldw	r16,0(sp)
81121554:	dec00304 	addi	sp,sp,12
81121558:	f800283a 	ret
8112155c:	80c00017 	ldw	r3,0(r16)
81121560:	183ff926 	beq	r3,zero,81121548 <__reset+0xfb101548>
81121564:	88c00015 	stw	r3,0(r17)
81121568:	003ff706 	br	81121548 <__reset+0xfb101548>

8112156c <_fwrite_r>:
8112156c:	defff504 	addi	sp,sp,-44
81121570:	de00012e 	bgeu	sp,et,81121578 <_fwrite_r+0xc>
81121574:	003b68fa 	trap	3
81121578:	dc800815 	stw	r18,32(sp)
8112157c:	39a5383a 	mul	r18,r7,r6
81121580:	d8800304 	addi	r2,sp,12
81121584:	d8800015 	stw	r2,0(sp)
81121588:	00800044 	movi	r2,1
8112158c:	dcc00915 	stw	r19,36(sp)
81121590:	dc400715 	stw	r17,28(sp)
81121594:	dc000615 	stw	r16,24(sp)
81121598:	d9400315 	stw	r5,12(sp)
8112159c:	dfc00a15 	stw	ra,40(sp)
811215a0:	dc800415 	stw	r18,16(sp)
811215a4:	dc800215 	stw	r18,8(sp)
811215a8:	d8800115 	stw	r2,4(sp)
811215ac:	3027883a 	mov	r19,r6
811215b0:	3821883a 	mov	r16,r7
811215b4:	2023883a 	mov	r17,r4
811215b8:	d9400b17 	ldw	r5,44(sp)
811215bc:	20000226 	beq	r4,zero,811215c8 <_fwrite_r+0x5c>
811215c0:	20800e17 	ldw	r2,56(r4)
811215c4:	10001a26 	beq	r2,zero,81121630 <_fwrite_r+0xc4>
811215c8:	2880030b 	ldhu	r2,12(r5)
811215cc:	10c8000c 	andi	r3,r2,8192
811215d0:	1800061e 	bne	r3,zero,811215ec <_fwrite_r+0x80>
811215d4:	29001917 	ldw	r4,100(r5)
811215d8:	00f7ffc4 	movi	r3,-8193
811215dc:	10880014 	ori	r2,r2,8192
811215e0:	20c6703a 	and	r3,r4,r3
811215e4:	2880030d 	sth	r2,12(r5)
811215e8:	28c01915 	stw	r3,100(r5)
811215ec:	d80d883a 	mov	r6,sp
811215f0:	8809883a 	mov	r4,r17
811215f4:	112b5cc0 	call	8112b5cc <__sfvwrite_r>
811215f8:	10000b26 	beq	r2,zero,81121628 <_fwrite_r+0xbc>
811215fc:	d9000217 	ldw	r4,8(sp)
81121600:	980b883a 	mov	r5,r19
81121604:	9109c83a 	sub	r4,r18,r4
81121608:	11345c00 	call	811345c0 <__udivsi3>
8112160c:	dfc00a17 	ldw	ra,40(sp)
81121610:	dcc00917 	ldw	r19,36(sp)
81121614:	dc800817 	ldw	r18,32(sp)
81121618:	dc400717 	ldw	r17,28(sp)
8112161c:	dc000617 	ldw	r16,24(sp)
81121620:	dec00b04 	addi	sp,sp,44
81121624:	f800283a 	ret
81121628:	8005883a 	mov	r2,r16
8112162c:	003ff706 	br	8112160c <__reset+0xfb10160c>
81121630:	d9400515 	stw	r5,20(sp)
81121634:	112ae1c0 	call	8112ae1c <__sinit>
81121638:	d9400517 	ldw	r5,20(sp)
8112163c:	003fe206 	br	811215c8 <__reset+0xfb1015c8>

81121640 <fwrite>:
81121640:	defffe04 	addi	sp,sp,-8
81121644:	00a04574 	movhi	r2,33045
81121648:	de00012e 	bgeu	sp,et,81121650 <fwrite+0x10>
8112164c:	003b68fa 	trap	3
81121650:	108ad804 	addi	r2,r2,11104
81121654:	d9c00015 	stw	r7,0(sp)
81121658:	300f883a 	mov	r7,r6
8112165c:	280d883a 	mov	r6,r5
81121660:	200b883a 	mov	r5,r4
81121664:	11000017 	ldw	r4,0(r2)
81121668:	dfc00115 	stw	ra,4(sp)
8112166c:	112156c0 	call	8112156c <_fwrite_r>
81121670:	dfc00117 	ldw	ra,4(sp)
81121674:	dec00204 	addi	sp,sp,8
81121678:	f800283a 	ret

8112167c <__smakebuf_r>:
8112167c:	2880030b 	ldhu	r2,12(r5)
81121680:	10c0008c 	andi	r3,r2,2
81121684:	1800431e 	bne	r3,zero,81121794 <__smakebuf_r+0x118>
81121688:	deffec04 	addi	sp,sp,-80
8112168c:	de00012e 	bgeu	sp,et,81121694 <__smakebuf_r+0x18>
81121690:	003b68fa 	trap	3
81121694:	dc000f15 	stw	r16,60(sp)
81121698:	2821883a 	mov	r16,r5
8112169c:	2940038f 	ldh	r5,14(r5)
811216a0:	dc401015 	stw	r17,64(sp)
811216a4:	dfc01315 	stw	ra,76(sp)
811216a8:	dcc01215 	stw	r19,72(sp)
811216ac:	dc801115 	stw	r18,68(sp)
811216b0:	2023883a 	mov	r17,r4
811216b4:	28001c16 	blt	r5,zero,81121728 <__smakebuf_r+0xac>
811216b8:	d80d883a 	mov	r6,sp
811216bc:	11215080 	call	81121508 <_fstat_r>
811216c0:	10001816 	blt	r2,zero,81121724 <__smakebuf_r+0xa8>
811216c4:	d8800117 	ldw	r2,4(sp)
811216c8:	00e00014 	movui	r3,32768
811216cc:	10bc000c 	andi	r2,r2,61440
811216d0:	14c80020 	cmpeqi	r19,r2,8192
811216d4:	10c03726 	beq	r2,r3,811217b4 <__smakebuf_r+0x138>
811216d8:	80c0030b 	ldhu	r3,12(r16)
811216dc:	18c20014 	ori	r3,r3,2048
811216e0:	80c0030d 	sth	r3,12(r16)
811216e4:	00c80004 	movi	r3,8192
811216e8:	10c0521e 	bne	r2,r3,81121834 <__smakebuf_r+0x1b8>
811216ec:	8140038f 	ldh	r5,14(r16)
811216f0:	8809883a 	mov	r4,r17
811216f4:	112bc280 	call	8112bc28 <_isatty_r>
811216f8:	10004c26 	beq	r2,zero,8112182c <__smakebuf_r+0x1b0>
811216fc:	8080030b 	ldhu	r2,12(r16)
81121700:	80c010c4 	addi	r3,r16,67
81121704:	80c00015 	stw	r3,0(r16)
81121708:	10800054 	ori	r2,r2,1
8112170c:	8080030d 	sth	r2,12(r16)
81121710:	00800044 	movi	r2,1
81121714:	80c00415 	stw	r3,16(r16)
81121718:	80800515 	stw	r2,20(r16)
8112171c:	04810004 	movi	r18,1024
81121720:	00000706 	br	81121740 <__smakebuf_r+0xc4>
81121724:	8080030b 	ldhu	r2,12(r16)
81121728:	10c0200c 	andi	r3,r2,128
8112172c:	18001f1e 	bne	r3,zero,811217ac <__smakebuf_r+0x130>
81121730:	04810004 	movi	r18,1024
81121734:	10820014 	ori	r2,r2,2048
81121738:	8080030d 	sth	r2,12(r16)
8112173c:	0027883a 	mov	r19,zero
81121740:	900b883a 	mov	r5,r18
81121744:	8809883a 	mov	r4,r17
81121748:	11218400 	call	81121840 <_malloc_r>
8112174c:	10002c26 	beq	r2,zero,81121800 <__smakebuf_r+0x184>
81121750:	80c0030b 	ldhu	r3,12(r16)
81121754:	012044f4 	movhi	r4,33043
81121758:	212aaf04 	addi	r4,r4,-21828
8112175c:	89000f15 	stw	r4,60(r17)
81121760:	18c02014 	ori	r3,r3,128
81121764:	80c0030d 	sth	r3,12(r16)
81121768:	80800015 	stw	r2,0(r16)
8112176c:	80800415 	stw	r2,16(r16)
81121770:	84800515 	stw	r18,20(r16)
81121774:	98001a1e 	bne	r19,zero,811217e0 <__smakebuf_r+0x164>
81121778:	dfc01317 	ldw	ra,76(sp)
8112177c:	dcc01217 	ldw	r19,72(sp)
81121780:	dc801117 	ldw	r18,68(sp)
81121784:	dc401017 	ldw	r17,64(sp)
81121788:	dc000f17 	ldw	r16,60(sp)
8112178c:	dec01404 	addi	sp,sp,80
81121790:	f800283a 	ret
81121794:	288010c4 	addi	r2,r5,67
81121798:	28800015 	stw	r2,0(r5)
8112179c:	28800415 	stw	r2,16(r5)
811217a0:	00800044 	movi	r2,1
811217a4:	28800515 	stw	r2,20(r5)
811217a8:	f800283a 	ret
811217ac:	04801004 	movi	r18,64
811217b0:	003fe006 	br	81121734 <__reset+0xfb101734>
811217b4:	81000a17 	ldw	r4,40(r16)
811217b8:	00e044b4 	movhi	r3,33042
811217bc:	18caa404 	addi	r3,r3,10896
811217c0:	20ffc51e 	bne	r4,r3,811216d8 <__reset+0xfb1016d8>
811217c4:	8080030b 	ldhu	r2,12(r16)
811217c8:	04810004 	movi	r18,1024
811217cc:	84801315 	stw	r18,76(r16)
811217d0:	1484b03a 	or	r2,r2,r18
811217d4:	8080030d 	sth	r2,12(r16)
811217d8:	0027883a 	mov	r19,zero
811217dc:	003fd806 	br	81121740 <__reset+0xfb101740>
811217e0:	8140038f 	ldh	r5,14(r16)
811217e4:	8809883a 	mov	r4,r17
811217e8:	112bc280 	call	8112bc28 <_isatty_r>
811217ec:	103fe226 	beq	r2,zero,81121778 <__reset+0xfb101778>
811217f0:	8080030b 	ldhu	r2,12(r16)
811217f4:	10800054 	ori	r2,r2,1
811217f8:	8080030d 	sth	r2,12(r16)
811217fc:	003fde06 	br	81121778 <__reset+0xfb101778>
81121800:	8080030b 	ldhu	r2,12(r16)
81121804:	10c0800c 	andi	r3,r2,512
81121808:	183fdb1e 	bne	r3,zero,81121778 <__reset+0xfb101778>
8112180c:	10800094 	ori	r2,r2,2
81121810:	80c010c4 	addi	r3,r16,67
81121814:	8080030d 	sth	r2,12(r16)
81121818:	00800044 	movi	r2,1
8112181c:	80c00015 	stw	r3,0(r16)
81121820:	80c00415 	stw	r3,16(r16)
81121824:	80800515 	stw	r2,20(r16)
81121828:	003fd306 	br	81121778 <__reset+0xfb101778>
8112182c:	04810004 	movi	r18,1024
81121830:	003fc306 	br	81121740 <__reset+0xfb101740>
81121834:	0027883a 	mov	r19,zero
81121838:	04810004 	movi	r18,1024
8112183c:	003fc006 	br	81121740 <__reset+0xfb101740>

81121840 <_malloc_r>:
81121840:	defff504 	addi	sp,sp,-44
81121844:	de00012e 	bgeu	sp,et,8112184c <_malloc_r+0xc>
81121848:	003b68fa 	trap	3
8112184c:	288002c4 	addi	r2,r5,11
81121850:	dc800315 	stw	r18,12(sp)
81121854:	dfc00a15 	stw	ra,40(sp)
81121858:	df000915 	stw	fp,36(sp)
8112185c:	ddc00815 	stw	r23,32(sp)
81121860:	dd800715 	stw	r22,28(sp)
81121864:	dd400615 	stw	r21,24(sp)
81121868:	dd000515 	stw	r20,20(sp)
8112186c:	dcc00415 	stw	r19,16(sp)
81121870:	dc400215 	stw	r17,8(sp)
81121874:	dc000115 	stw	r16,4(sp)
81121878:	00c00584 	movi	r3,22
8112187c:	2025883a 	mov	r18,r4
81121880:	18807f2e 	bgeu	r3,r2,81121a80 <_malloc_r+0x240>
81121884:	047ffe04 	movi	r17,-8
81121888:	1462703a 	and	r17,r2,r17
8112188c:	8800a316 	blt	r17,zero,81121b1c <_malloc_r+0x2dc>
81121890:	8940a236 	bltu	r17,r5,81121b1c <_malloc_r+0x2dc>
81121894:	1137a7c0 	call	81137a7c <__malloc_lock>
81121898:	00807dc4 	movi	r2,503
8112189c:	1441e92e 	bgeu	r2,r17,81122044 <_malloc_r+0x804>
811218a0:	8804d27a 	srli	r2,r17,9
811218a4:	1000a126 	beq	r2,zero,81121b2c <_malloc_r+0x2ec>
811218a8:	00c00104 	movi	r3,4
811218ac:	18811e36 	bltu	r3,r2,81121d28 <_malloc_r+0x4e8>
811218b0:	8804d1ba 	srli	r2,r17,6
811218b4:	12000e44 	addi	r8,r2,57
811218b8:	11c00e04 	addi	r7,r2,56
811218bc:	4209883a 	add	r4,r8,r8
811218c0:	04e04574 	movhi	r19,33045
811218c4:	2109883a 	add	r4,r4,r4
811218c8:	9cc49604 	addi	r19,r19,4696
811218cc:	2109883a 	add	r4,r4,r4
811218d0:	9909883a 	add	r4,r19,r4
811218d4:	24000117 	ldw	r16,4(r4)
811218d8:	213ffe04 	addi	r4,r4,-8
811218dc:	24009726 	beq	r4,r16,81121b3c <_malloc_r+0x2fc>
811218e0:	80800117 	ldw	r2,4(r16)
811218e4:	01bfff04 	movi	r6,-4
811218e8:	014003c4 	movi	r5,15
811218ec:	1184703a 	and	r2,r2,r6
811218f0:	1447c83a 	sub	r3,r2,r17
811218f4:	28c00716 	blt	r5,r3,81121914 <_malloc_r+0xd4>
811218f8:	1800920e 	bge	r3,zero,81121b44 <_malloc_r+0x304>
811218fc:	84000317 	ldw	r16,12(r16)
81121900:	24008e26 	beq	r4,r16,81121b3c <_malloc_r+0x2fc>
81121904:	80800117 	ldw	r2,4(r16)
81121908:	1184703a 	and	r2,r2,r6
8112190c:	1447c83a 	sub	r3,r2,r17
81121910:	28fff90e 	bge	r5,r3,811218f8 <__reset+0xfb1018f8>
81121914:	3809883a 	mov	r4,r7
81121918:	01a04574 	movhi	r6,33045
8112191c:	9c000417 	ldw	r16,16(r19)
81121920:	31849604 	addi	r6,r6,4696
81121924:	32000204 	addi	r8,r6,8
81121928:	82013426 	beq	r16,r8,81121dfc <_malloc_r+0x5bc>
8112192c:	80c00117 	ldw	r3,4(r16)
81121930:	00bfff04 	movi	r2,-4
81121934:	188e703a 	and	r7,r3,r2
81121938:	3c45c83a 	sub	r2,r7,r17
8112193c:	00c003c4 	movi	r3,15
81121940:	18811f16 	blt	r3,r2,81121dc0 <_malloc_r+0x580>
81121944:	32000515 	stw	r8,20(r6)
81121948:	32000415 	stw	r8,16(r6)
8112194c:	10007f0e 	bge	r2,zero,81121b4c <_malloc_r+0x30c>
81121950:	00807fc4 	movi	r2,511
81121954:	11c0fd36 	bltu	r2,r7,81121d4c <_malloc_r+0x50c>
81121958:	3806d0fa 	srli	r3,r7,3
8112195c:	01c00044 	movi	r7,1
81121960:	30800117 	ldw	r2,4(r6)
81121964:	19400044 	addi	r5,r3,1
81121968:	294b883a 	add	r5,r5,r5
8112196c:	1807d0ba 	srai	r3,r3,2
81121970:	294b883a 	add	r5,r5,r5
81121974:	294b883a 	add	r5,r5,r5
81121978:	298b883a 	add	r5,r5,r6
8112197c:	38c6983a 	sll	r3,r7,r3
81121980:	29c00017 	ldw	r7,0(r5)
81121984:	2a7ffe04 	addi	r9,r5,-8
81121988:	1886b03a 	or	r3,r3,r2
8112198c:	82400315 	stw	r9,12(r16)
81121990:	81c00215 	stw	r7,8(r16)
81121994:	30c00115 	stw	r3,4(r6)
81121998:	2c000015 	stw	r16,0(r5)
8112199c:	3c000315 	stw	r16,12(r7)
811219a0:	2005d0ba 	srai	r2,r4,2
811219a4:	01400044 	movi	r5,1
811219a8:	288a983a 	sll	r5,r5,r2
811219ac:	19406f36 	bltu	r3,r5,81121b6c <_malloc_r+0x32c>
811219b0:	28c4703a 	and	r2,r5,r3
811219b4:	10000a1e 	bne	r2,zero,811219e0 <_malloc_r+0x1a0>
811219b8:	00bfff04 	movi	r2,-4
811219bc:	294b883a 	add	r5,r5,r5
811219c0:	2088703a 	and	r4,r4,r2
811219c4:	28c4703a 	and	r2,r5,r3
811219c8:	21000104 	addi	r4,r4,4
811219cc:	1000041e 	bne	r2,zero,811219e0 <_malloc_r+0x1a0>
811219d0:	294b883a 	add	r5,r5,r5
811219d4:	28c4703a 	and	r2,r5,r3
811219d8:	21000104 	addi	r4,r4,4
811219dc:	103ffc26 	beq	r2,zero,811219d0 <__reset+0xfb1019d0>
811219e0:	02bfff04 	movi	r10,-4
811219e4:	024003c4 	movi	r9,15
811219e8:	21800044 	addi	r6,r4,1
811219ec:	318d883a 	add	r6,r6,r6
811219f0:	318d883a 	add	r6,r6,r6
811219f4:	318d883a 	add	r6,r6,r6
811219f8:	998d883a 	add	r6,r19,r6
811219fc:	333ffe04 	addi	r12,r6,-8
81121a00:	2017883a 	mov	r11,r4
81121a04:	31800104 	addi	r6,r6,4
81121a08:	34000017 	ldw	r16,0(r6)
81121a0c:	31fffd04 	addi	r7,r6,-12
81121a10:	81c0041e 	bne	r16,r7,81121a24 <_malloc_r+0x1e4>
81121a14:	0000fb06 	br	81121e04 <_malloc_r+0x5c4>
81121a18:	1801030e 	bge	r3,zero,81121e28 <_malloc_r+0x5e8>
81121a1c:	84000317 	ldw	r16,12(r16)
81121a20:	81c0f826 	beq	r16,r7,81121e04 <_malloc_r+0x5c4>
81121a24:	80800117 	ldw	r2,4(r16)
81121a28:	1284703a 	and	r2,r2,r10
81121a2c:	1447c83a 	sub	r3,r2,r17
81121a30:	48fff90e 	bge	r9,r3,81121a18 <__reset+0xfb101a18>
81121a34:	80800317 	ldw	r2,12(r16)
81121a38:	81000217 	ldw	r4,8(r16)
81121a3c:	89400054 	ori	r5,r17,1
81121a40:	81400115 	stw	r5,4(r16)
81121a44:	20800315 	stw	r2,12(r4)
81121a48:	11000215 	stw	r4,8(r2)
81121a4c:	8463883a 	add	r17,r16,r17
81121a50:	9c400515 	stw	r17,20(r19)
81121a54:	9c400415 	stw	r17,16(r19)
81121a58:	18800054 	ori	r2,r3,1
81121a5c:	88800115 	stw	r2,4(r17)
81121a60:	8a000315 	stw	r8,12(r17)
81121a64:	8a000215 	stw	r8,8(r17)
81121a68:	88e3883a 	add	r17,r17,r3
81121a6c:	88c00015 	stw	r3,0(r17)
81121a70:	9009883a 	mov	r4,r18
81121a74:	1137ba40 	call	81137ba4 <__malloc_unlock>
81121a78:	80800204 	addi	r2,r16,8
81121a7c:	00001b06 	br	81121aec <_malloc_r+0x2ac>
81121a80:	04400404 	movi	r17,16
81121a84:	89402536 	bltu	r17,r5,81121b1c <_malloc_r+0x2dc>
81121a88:	1137a7c0 	call	81137a7c <__malloc_lock>
81121a8c:	00800184 	movi	r2,6
81121a90:	01000084 	movi	r4,2
81121a94:	04e04574 	movhi	r19,33045
81121a98:	1085883a 	add	r2,r2,r2
81121a9c:	9cc49604 	addi	r19,r19,4696
81121aa0:	1085883a 	add	r2,r2,r2
81121aa4:	9885883a 	add	r2,r19,r2
81121aa8:	14000117 	ldw	r16,4(r2)
81121aac:	10fffe04 	addi	r3,r2,-8
81121ab0:	80c0d926 	beq	r16,r3,81121e18 <_malloc_r+0x5d8>
81121ab4:	80c00117 	ldw	r3,4(r16)
81121ab8:	81000317 	ldw	r4,12(r16)
81121abc:	00bfff04 	movi	r2,-4
81121ac0:	1884703a 	and	r2,r3,r2
81121ac4:	81400217 	ldw	r5,8(r16)
81121ac8:	8085883a 	add	r2,r16,r2
81121acc:	10c00117 	ldw	r3,4(r2)
81121ad0:	29000315 	stw	r4,12(r5)
81121ad4:	21400215 	stw	r5,8(r4)
81121ad8:	18c00054 	ori	r3,r3,1
81121adc:	10c00115 	stw	r3,4(r2)
81121ae0:	9009883a 	mov	r4,r18
81121ae4:	1137ba40 	call	81137ba4 <__malloc_unlock>
81121ae8:	80800204 	addi	r2,r16,8
81121aec:	dfc00a17 	ldw	ra,40(sp)
81121af0:	df000917 	ldw	fp,36(sp)
81121af4:	ddc00817 	ldw	r23,32(sp)
81121af8:	dd800717 	ldw	r22,28(sp)
81121afc:	dd400617 	ldw	r21,24(sp)
81121b00:	dd000517 	ldw	r20,20(sp)
81121b04:	dcc00417 	ldw	r19,16(sp)
81121b08:	dc800317 	ldw	r18,12(sp)
81121b0c:	dc400217 	ldw	r17,8(sp)
81121b10:	dc000117 	ldw	r16,4(sp)
81121b14:	dec00b04 	addi	sp,sp,44
81121b18:	f800283a 	ret
81121b1c:	00800304 	movi	r2,12
81121b20:	90800015 	stw	r2,0(r18)
81121b24:	0005883a 	mov	r2,zero
81121b28:	003ff006 	br	81121aec <__reset+0xfb101aec>
81121b2c:	01002004 	movi	r4,128
81121b30:	02001004 	movi	r8,64
81121b34:	01c00fc4 	movi	r7,63
81121b38:	003f6106 	br	811218c0 <__reset+0xfb1018c0>
81121b3c:	4009883a 	mov	r4,r8
81121b40:	003f7506 	br	81121918 <__reset+0xfb101918>
81121b44:	81000317 	ldw	r4,12(r16)
81121b48:	003fde06 	br	81121ac4 <__reset+0xfb101ac4>
81121b4c:	81c5883a 	add	r2,r16,r7
81121b50:	11400117 	ldw	r5,4(r2)
81121b54:	9009883a 	mov	r4,r18
81121b58:	29400054 	ori	r5,r5,1
81121b5c:	11400115 	stw	r5,4(r2)
81121b60:	1137ba40 	call	81137ba4 <__malloc_unlock>
81121b64:	80800204 	addi	r2,r16,8
81121b68:	003fe006 	br	81121aec <__reset+0xfb101aec>
81121b6c:	9c000217 	ldw	r16,8(r19)
81121b70:	00bfff04 	movi	r2,-4
81121b74:	85800117 	ldw	r22,4(r16)
81121b78:	b0ac703a 	and	r22,r22,r2
81121b7c:	b4400336 	bltu	r22,r17,81121b8c <_malloc_r+0x34c>
81121b80:	b445c83a 	sub	r2,r22,r17
81121b84:	00c003c4 	movi	r3,15
81121b88:	18805d16 	blt	r3,r2,81121d00 <_malloc_r+0x4c0>
81121b8c:	05e04574 	movhi	r23,33045
81121b90:	00a04574 	movhi	r2,33045
81121b94:	108b4e04 	addi	r2,r2,11576
81121b98:	bdcad904 	addi	r23,r23,11108
81121b9c:	15400017 	ldw	r21,0(r2)
81121ba0:	b8c00017 	ldw	r3,0(r23)
81121ba4:	00bfffc4 	movi	r2,-1
81121ba8:	858d883a 	add	r6,r16,r22
81121bac:	8d6b883a 	add	r21,r17,r21
81121bb0:	1880ea26 	beq	r3,r2,81121f5c <_malloc_r+0x71c>
81121bb4:	ad4403c4 	addi	r21,r21,4111
81121bb8:	00bc0004 	movi	r2,-4096
81121bbc:	a8aa703a 	and	r21,r21,r2
81121bc0:	a80b883a 	mov	r5,r21
81121bc4:	9009883a 	mov	r4,r18
81121bc8:	d9800015 	stw	r6,0(sp)
81121bcc:	11227fc0 	call	811227fc <_sbrk_r>
81121bd0:	1029883a 	mov	r20,r2
81121bd4:	00bfffc4 	movi	r2,-1
81121bd8:	d9800017 	ldw	r6,0(sp)
81121bdc:	a080e826 	beq	r20,r2,81121f80 <_malloc_r+0x740>
81121be0:	a180a636 	bltu	r20,r6,81121e7c <_malloc_r+0x63c>
81121be4:	07204574 	movhi	fp,33045
81121be8:	e70bdb04 	addi	fp,fp,12140
81121bec:	e0800017 	ldw	r2,0(fp)
81121bf0:	a887883a 	add	r3,r21,r2
81121bf4:	e0c00015 	stw	r3,0(fp)
81121bf8:	3500e626 	beq	r6,r20,81121f94 <_malloc_r+0x754>
81121bfc:	b9000017 	ldw	r4,0(r23)
81121c00:	00bfffc4 	movi	r2,-1
81121c04:	2080ee26 	beq	r4,r2,81121fc0 <_malloc_r+0x780>
81121c08:	a185c83a 	sub	r2,r20,r6
81121c0c:	10c5883a 	add	r2,r2,r3
81121c10:	e0800015 	stw	r2,0(fp)
81121c14:	a0c001cc 	andi	r3,r20,7
81121c18:	1800bc26 	beq	r3,zero,81121f0c <_malloc_r+0x6cc>
81121c1c:	a0e9c83a 	sub	r20,r20,r3
81121c20:	00840204 	movi	r2,4104
81121c24:	a5000204 	addi	r20,r20,8
81121c28:	10c7c83a 	sub	r3,r2,r3
81121c2c:	a545883a 	add	r2,r20,r21
81121c30:	1083ffcc 	andi	r2,r2,4095
81121c34:	18abc83a 	sub	r21,r3,r2
81121c38:	a80b883a 	mov	r5,r21
81121c3c:	9009883a 	mov	r4,r18
81121c40:	11227fc0 	call	811227fc <_sbrk_r>
81121c44:	00ffffc4 	movi	r3,-1
81121c48:	10c0e126 	beq	r2,r3,81121fd0 <_malloc_r+0x790>
81121c4c:	1505c83a 	sub	r2,r2,r20
81121c50:	1545883a 	add	r2,r2,r21
81121c54:	10800054 	ori	r2,r2,1
81121c58:	e0c00017 	ldw	r3,0(fp)
81121c5c:	9d000215 	stw	r20,8(r19)
81121c60:	a0800115 	stw	r2,4(r20)
81121c64:	a8c7883a 	add	r3,r21,r3
81121c68:	e0c00015 	stw	r3,0(fp)
81121c6c:	84c00e26 	beq	r16,r19,81121ca8 <_malloc_r+0x468>
81121c70:	018003c4 	movi	r6,15
81121c74:	3580a72e 	bgeu	r6,r22,81121f14 <_malloc_r+0x6d4>
81121c78:	81400117 	ldw	r5,4(r16)
81121c7c:	013ffe04 	movi	r4,-8
81121c80:	b0bffd04 	addi	r2,r22,-12
81121c84:	1104703a 	and	r2,r2,r4
81121c88:	2900004c 	andi	r4,r5,1
81121c8c:	2088b03a 	or	r4,r4,r2
81121c90:	81000115 	stw	r4,4(r16)
81121c94:	01400144 	movi	r5,5
81121c98:	8089883a 	add	r4,r16,r2
81121c9c:	21400115 	stw	r5,4(r4)
81121ca0:	21400215 	stw	r5,8(r4)
81121ca4:	3080cd36 	bltu	r6,r2,81121fdc <_malloc_r+0x79c>
81121ca8:	00a04574 	movhi	r2,33045
81121cac:	108b4d04 	addi	r2,r2,11572
81121cb0:	11000017 	ldw	r4,0(r2)
81121cb4:	20c0012e 	bgeu	r4,r3,81121cbc <_malloc_r+0x47c>
81121cb8:	10c00015 	stw	r3,0(r2)
81121cbc:	00a04574 	movhi	r2,33045
81121cc0:	108b4c04 	addi	r2,r2,11568
81121cc4:	11000017 	ldw	r4,0(r2)
81121cc8:	9c000217 	ldw	r16,8(r19)
81121ccc:	20c0012e 	bgeu	r4,r3,81121cd4 <_malloc_r+0x494>
81121cd0:	10c00015 	stw	r3,0(r2)
81121cd4:	80c00117 	ldw	r3,4(r16)
81121cd8:	00bfff04 	movi	r2,-4
81121cdc:	1886703a 	and	r3,r3,r2
81121ce0:	1c45c83a 	sub	r2,r3,r17
81121ce4:	1c400236 	bltu	r3,r17,81121cf0 <_malloc_r+0x4b0>
81121ce8:	00c003c4 	movi	r3,15
81121cec:	18800416 	blt	r3,r2,81121d00 <_malloc_r+0x4c0>
81121cf0:	9009883a 	mov	r4,r18
81121cf4:	1137ba40 	call	81137ba4 <__malloc_unlock>
81121cf8:	0005883a 	mov	r2,zero
81121cfc:	003f7b06 	br	81121aec <__reset+0xfb101aec>
81121d00:	88c00054 	ori	r3,r17,1
81121d04:	80c00115 	stw	r3,4(r16)
81121d08:	8463883a 	add	r17,r16,r17
81121d0c:	10800054 	ori	r2,r2,1
81121d10:	9c400215 	stw	r17,8(r19)
81121d14:	88800115 	stw	r2,4(r17)
81121d18:	9009883a 	mov	r4,r18
81121d1c:	1137ba40 	call	81137ba4 <__malloc_unlock>
81121d20:	80800204 	addi	r2,r16,8
81121d24:	003f7106 	br	81121aec <__reset+0xfb101aec>
81121d28:	00c00504 	movi	r3,20
81121d2c:	18804a2e 	bgeu	r3,r2,81121e58 <_malloc_r+0x618>
81121d30:	00c01504 	movi	r3,84
81121d34:	18806e36 	bltu	r3,r2,81121ef0 <_malloc_r+0x6b0>
81121d38:	8804d33a 	srli	r2,r17,12
81121d3c:	12001bc4 	addi	r8,r2,111
81121d40:	11c01b84 	addi	r7,r2,110
81121d44:	4209883a 	add	r4,r8,r8
81121d48:	003edd06 	br	811218c0 <__reset+0xfb1018c0>
81121d4c:	3804d27a 	srli	r2,r7,9
81121d50:	00c00104 	movi	r3,4
81121d54:	1880442e 	bgeu	r3,r2,81121e68 <_malloc_r+0x628>
81121d58:	00c00504 	movi	r3,20
81121d5c:	18808136 	bltu	r3,r2,81121f64 <_malloc_r+0x724>
81121d60:	11401704 	addi	r5,r2,92
81121d64:	10c016c4 	addi	r3,r2,91
81121d68:	294b883a 	add	r5,r5,r5
81121d6c:	294b883a 	add	r5,r5,r5
81121d70:	294b883a 	add	r5,r5,r5
81121d74:	994b883a 	add	r5,r19,r5
81121d78:	28800017 	ldw	r2,0(r5)
81121d7c:	01a04574 	movhi	r6,33045
81121d80:	297ffe04 	addi	r5,r5,-8
81121d84:	31849604 	addi	r6,r6,4696
81121d88:	28806526 	beq	r5,r2,81121f20 <_malloc_r+0x6e0>
81121d8c:	01bfff04 	movi	r6,-4
81121d90:	10c00117 	ldw	r3,4(r2)
81121d94:	1986703a 	and	r3,r3,r6
81121d98:	38c0022e 	bgeu	r7,r3,81121da4 <_malloc_r+0x564>
81121d9c:	10800217 	ldw	r2,8(r2)
81121da0:	28bffb1e 	bne	r5,r2,81121d90 <__reset+0xfb101d90>
81121da4:	11400317 	ldw	r5,12(r2)
81121da8:	98c00117 	ldw	r3,4(r19)
81121dac:	81400315 	stw	r5,12(r16)
81121db0:	80800215 	stw	r2,8(r16)
81121db4:	2c000215 	stw	r16,8(r5)
81121db8:	14000315 	stw	r16,12(r2)
81121dbc:	003ef806 	br	811219a0 <__reset+0xfb1019a0>
81121dc0:	88c00054 	ori	r3,r17,1
81121dc4:	80c00115 	stw	r3,4(r16)
81121dc8:	8463883a 	add	r17,r16,r17
81121dcc:	34400515 	stw	r17,20(r6)
81121dd0:	34400415 	stw	r17,16(r6)
81121dd4:	10c00054 	ori	r3,r2,1
81121dd8:	8a000315 	stw	r8,12(r17)
81121ddc:	8a000215 	stw	r8,8(r17)
81121de0:	88c00115 	stw	r3,4(r17)
81121de4:	88a3883a 	add	r17,r17,r2
81121de8:	88800015 	stw	r2,0(r17)
81121dec:	9009883a 	mov	r4,r18
81121df0:	1137ba40 	call	81137ba4 <__malloc_unlock>
81121df4:	80800204 	addi	r2,r16,8
81121df8:	003f3c06 	br	81121aec <__reset+0xfb101aec>
81121dfc:	30c00117 	ldw	r3,4(r6)
81121e00:	003ee706 	br	811219a0 <__reset+0xfb1019a0>
81121e04:	5ac00044 	addi	r11,r11,1
81121e08:	588000cc 	andi	r2,r11,3
81121e0c:	31800204 	addi	r6,r6,8
81121e10:	103efd1e 	bne	r2,zero,81121a08 <__reset+0xfb101a08>
81121e14:	00002406 	br	81121ea8 <_malloc_r+0x668>
81121e18:	14000317 	ldw	r16,12(r2)
81121e1c:	143f251e 	bne	r2,r16,81121ab4 <__reset+0xfb101ab4>
81121e20:	21000084 	addi	r4,r4,2
81121e24:	003ebc06 	br	81121918 <__reset+0xfb101918>
81121e28:	8085883a 	add	r2,r16,r2
81121e2c:	10c00117 	ldw	r3,4(r2)
81121e30:	81000317 	ldw	r4,12(r16)
81121e34:	81400217 	ldw	r5,8(r16)
81121e38:	18c00054 	ori	r3,r3,1
81121e3c:	10c00115 	stw	r3,4(r2)
81121e40:	29000315 	stw	r4,12(r5)
81121e44:	21400215 	stw	r5,8(r4)
81121e48:	9009883a 	mov	r4,r18
81121e4c:	1137ba40 	call	81137ba4 <__malloc_unlock>
81121e50:	80800204 	addi	r2,r16,8
81121e54:	003f2506 	br	81121aec <__reset+0xfb101aec>
81121e58:	12001704 	addi	r8,r2,92
81121e5c:	11c016c4 	addi	r7,r2,91
81121e60:	4209883a 	add	r4,r8,r8
81121e64:	003e9606 	br	811218c0 <__reset+0xfb1018c0>
81121e68:	3804d1ba 	srli	r2,r7,6
81121e6c:	11400e44 	addi	r5,r2,57
81121e70:	10c00e04 	addi	r3,r2,56
81121e74:	294b883a 	add	r5,r5,r5
81121e78:	003fbc06 	br	81121d6c <__reset+0xfb101d6c>
81121e7c:	84ff5926 	beq	r16,r19,81121be4 <__reset+0xfb101be4>
81121e80:	00a04574 	movhi	r2,33045
81121e84:	10849604 	addi	r2,r2,4696
81121e88:	14000217 	ldw	r16,8(r2)
81121e8c:	00bfff04 	movi	r2,-4
81121e90:	80c00117 	ldw	r3,4(r16)
81121e94:	1886703a 	and	r3,r3,r2
81121e98:	003f9106 	br	81121ce0 <__reset+0xfb101ce0>
81121e9c:	60800217 	ldw	r2,8(r12)
81121ea0:	213fffc4 	addi	r4,r4,-1
81121ea4:	1300651e 	bne	r2,r12,8112203c <_malloc_r+0x7fc>
81121ea8:	208000cc 	andi	r2,r4,3
81121eac:	633ffe04 	addi	r12,r12,-8
81121eb0:	103ffa1e 	bne	r2,zero,81121e9c <__reset+0xfb101e9c>
81121eb4:	98800117 	ldw	r2,4(r19)
81121eb8:	0146303a 	nor	r3,zero,r5
81121ebc:	1884703a 	and	r2,r3,r2
81121ec0:	98800115 	stw	r2,4(r19)
81121ec4:	294b883a 	add	r5,r5,r5
81121ec8:	117f2836 	bltu	r2,r5,81121b6c <__reset+0xfb101b6c>
81121ecc:	283f2726 	beq	r5,zero,81121b6c <__reset+0xfb101b6c>
81121ed0:	2886703a 	and	r3,r5,r2
81121ed4:	5809883a 	mov	r4,r11
81121ed8:	183ec31e 	bne	r3,zero,811219e8 <__reset+0xfb1019e8>
81121edc:	294b883a 	add	r5,r5,r5
81121ee0:	2886703a 	and	r3,r5,r2
81121ee4:	21000104 	addi	r4,r4,4
81121ee8:	183ffc26 	beq	r3,zero,81121edc <__reset+0xfb101edc>
81121eec:	003ebe06 	br	811219e8 <__reset+0xfb1019e8>
81121ef0:	00c05504 	movi	r3,340
81121ef4:	18801236 	bltu	r3,r2,81121f40 <_malloc_r+0x700>
81121ef8:	8804d3fa 	srli	r2,r17,15
81121efc:	12001e04 	addi	r8,r2,120
81121f00:	11c01dc4 	addi	r7,r2,119
81121f04:	4209883a 	add	r4,r8,r8
81121f08:	003e6d06 	br	811218c0 <__reset+0xfb1018c0>
81121f0c:	00c40004 	movi	r3,4096
81121f10:	003f4606 	br	81121c2c <__reset+0xfb101c2c>
81121f14:	00800044 	movi	r2,1
81121f18:	a0800115 	stw	r2,4(r20)
81121f1c:	003f7406 	br	81121cf0 <__reset+0xfb101cf0>
81121f20:	1805d0ba 	srai	r2,r3,2
81121f24:	01c00044 	movi	r7,1
81121f28:	30c00117 	ldw	r3,4(r6)
81121f2c:	388e983a 	sll	r7,r7,r2
81121f30:	2805883a 	mov	r2,r5
81121f34:	38c6b03a 	or	r3,r7,r3
81121f38:	30c00115 	stw	r3,4(r6)
81121f3c:	003f9b06 	br	81121dac <__reset+0xfb101dac>
81121f40:	00c15504 	movi	r3,1364
81121f44:	18801a36 	bltu	r3,r2,81121fb0 <_malloc_r+0x770>
81121f48:	8804d4ba 	srli	r2,r17,18
81121f4c:	12001f44 	addi	r8,r2,125
81121f50:	11c01f04 	addi	r7,r2,124
81121f54:	4209883a 	add	r4,r8,r8
81121f58:	003e5906 	br	811218c0 <__reset+0xfb1018c0>
81121f5c:	ad400404 	addi	r21,r21,16
81121f60:	003f1706 	br	81121bc0 <__reset+0xfb101bc0>
81121f64:	00c01504 	movi	r3,84
81121f68:	18802336 	bltu	r3,r2,81121ff8 <_malloc_r+0x7b8>
81121f6c:	3804d33a 	srli	r2,r7,12
81121f70:	11401bc4 	addi	r5,r2,111
81121f74:	10c01b84 	addi	r3,r2,110
81121f78:	294b883a 	add	r5,r5,r5
81121f7c:	003f7b06 	br	81121d6c <__reset+0xfb101d6c>
81121f80:	9c000217 	ldw	r16,8(r19)
81121f84:	00bfff04 	movi	r2,-4
81121f88:	80c00117 	ldw	r3,4(r16)
81121f8c:	1886703a 	and	r3,r3,r2
81121f90:	003f5306 	br	81121ce0 <__reset+0xfb101ce0>
81121f94:	3083ffcc 	andi	r2,r6,4095
81121f98:	103f181e 	bne	r2,zero,81121bfc <__reset+0xfb101bfc>
81121f9c:	99000217 	ldw	r4,8(r19)
81121fa0:	b545883a 	add	r2,r22,r21
81121fa4:	10800054 	ori	r2,r2,1
81121fa8:	20800115 	stw	r2,4(r4)
81121fac:	003f3e06 	br	81121ca8 <__reset+0xfb101ca8>
81121fb0:	01003f84 	movi	r4,254
81121fb4:	02001fc4 	movi	r8,127
81121fb8:	01c01f84 	movi	r7,126
81121fbc:	003e4006 	br	811218c0 <__reset+0xfb1018c0>
81121fc0:	00a04574 	movhi	r2,33045
81121fc4:	108ad904 	addi	r2,r2,11108
81121fc8:	15000015 	stw	r20,0(r2)
81121fcc:	003f1106 	br	81121c14 <__reset+0xfb101c14>
81121fd0:	00800044 	movi	r2,1
81121fd4:	002b883a 	mov	r21,zero
81121fd8:	003f1f06 	br	81121c58 <__reset+0xfb101c58>
81121fdc:	81400204 	addi	r5,r16,8
81121fe0:	9009883a 	mov	r4,r18
81121fe4:	112b2b40 	call	8112b2b4 <_free_r>
81121fe8:	00a04574 	movhi	r2,33045
81121fec:	108bdb04 	addi	r2,r2,12140
81121ff0:	10c00017 	ldw	r3,0(r2)
81121ff4:	003f2c06 	br	81121ca8 <__reset+0xfb101ca8>
81121ff8:	00c05504 	movi	r3,340
81121ffc:	18800536 	bltu	r3,r2,81122014 <_malloc_r+0x7d4>
81122000:	3804d3fa 	srli	r2,r7,15
81122004:	11401e04 	addi	r5,r2,120
81122008:	10c01dc4 	addi	r3,r2,119
8112200c:	294b883a 	add	r5,r5,r5
81122010:	003f5606 	br	81121d6c <__reset+0xfb101d6c>
81122014:	00c15504 	movi	r3,1364
81122018:	18800536 	bltu	r3,r2,81122030 <_malloc_r+0x7f0>
8112201c:	3804d4ba 	srli	r2,r7,18
81122020:	11401f44 	addi	r5,r2,125
81122024:	10c01f04 	addi	r3,r2,124
81122028:	294b883a 	add	r5,r5,r5
8112202c:	003f4f06 	br	81121d6c <__reset+0xfb101d6c>
81122030:	01403f84 	movi	r5,254
81122034:	00c01f84 	movi	r3,126
81122038:	003f4c06 	br	81121d6c <__reset+0xfb101d6c>
8112203c:	98800117 	ldw	r2,4(r19)
81122040:	003fa006 	br	81121ec4 <__reset+0xfb101ec4>
81122044:	8808d0fa 	srli	r4,r17,3
81122048:	20800044 	addi	r2,r4,1
8112204c:	1085883a 	add	r2,r2,r2
81122050:	003e9006 	br	81121a94 <__reset+0xfb101a94>

81122054 <memcpy>:
81122054:	defffd04 	addi	sp,sp,-12
81122058:	de00012e 	bgeu	sp,et,81122060 <memcpy+0xc>
8112205c:	003b68fa 	trap	3
81122060:	00c003c4 	movi	r3,15
81122064:	dfc00215 	stw	ra,8(sp)
81122068:	dc400115 	stw	r17,4(sp)
8112206c:	dc000015 	stw	r16,0(sp)
81122070:	2005883a 	mov	r2,r4
81122074:	1980452e 	bgeu	r3,r6,8112218c <memcpy+0x138>
81122078:	2906b03a 	or	r3,r5,r4
8112207c:	18c000cc 	andi	r3,r3,3
81122080:	1800441e 	bne	r3,zero,81122194 <memcpy+0x140>
81122084:	347ffc04 	addi	r17,r6,-16
81122088:	8822d13a 	srli	r17,r17,4
8112208c:	28c00104 	addi	r3,r5,4
81122090:	23400104 	addi	r13,r4,4
81122094:	8820913a 	slli	r16,r17,4
81122098:	2b000204 	addi	r12,r5,8
8112209c:	22c00204 	addi	r11,r4,8
811220a0:	84000504 	addi	r16,r16,20
811220a4:	2a800304 	addi	r10,r5,12
811220a8:	22400304 	addi	r9,r4,12
811220ac:	2c21883a 	add	r16,r5,r16
811220b0:	2811883a 	mov	r8,r5
811220b4:	200f883a 	mov	r7,r4
811220b8:	41000017 	ldw	r4,0(r8)
811220bc:	1fc00017 	ldw	ra,0(r3)
811220c0:	63c00017 	ldw	r15,0(r12)
811220c4:	39000015 	stw	r4,0(r7)
811220c8:	53800017 	ldw	r14,0(r10)
811220cc:	6fc00015 	stw	ra,0(r13)
811220d0:	5bc00015 	stw	r15,0(r11)
811220d4:	4b800015 	stw	r14,0(r9)
811220d8:	18c00404 	addi	r3,r3,16
811220dc:	39c00404 	addi	r7,r7,16
811220e0:	42000404 	addi	r8,r8,16
811220e4:	6b400404 	addi	r13,r13,16
811220e8:	63000404 	addi	r12,r12,16
811220ec:	5ac00404 	addi	r11,r11,16
811220f0:	52800404 	addi	r10,r10,16
811220f4:	4a400404 	addi	r9,r9,16
811220f8:	1c3fef1e 	bne	r3,r16,811220b8 <__reset+0xfb1020b8>
811220fc:	89c00044 	addi	r7,r17,1
81122100:	380e913a 	slli	r7,r7,4
81122104:	310003cc 	andi	r4,r6,15
81122108:	02c000c4 	movi	r11,3
8112210c:	11c7883a 	add	r3,r2,r7
81122110:	29cb883a 	add	r5,r5,r7
81122114:	5900212e 	bgeu	r11,r4,8112219c <memcpy+0x148>
81122118:	1813883a 	mov	r9,r3
8112211c:	2811883a 	mov	r8,r5
81122120:	200f883a 	mov	r7,r4
81122124:	42800017 	ldw	r10,0(r8)
81122128:	4a400104 	addi	r9,r9,4
8112212c:	39ffff04 	addi	r7,r7,-4
81122130:	4abfff15 	stw	r10,-4(r9)
81122134:	42000104 	addi	r8,r8,4
81122138:	59fffa36 	bltu	r11,r7,81122124 <__reset+0xfb102124>
8112213c:	213fff04 	addi	r4,r4,-4
81122140:	2008d0ba 	srli	r4,r4,2
81122144:	318000cc 	andi	r6,r6,3
81122148:	21000044 	addi	r4,r4,1
8112214c:	2109883a 	add	r4,r4,r4
81122150:	2109883a 	add	r4,r4,r4
81122154:	1907883a 	add	r3,r3,r4
81122158:	290b883a 	add	r5,r5,r4
8112215c:	30000626 	beq	r6,zero,81122178 <memcpy+0x124>
81122160:	198d883a 	add	r6,r3,r6
81122164:	29c00003 	ldbu	r7,0(r5)
81122168:	18c00044 	addi	r3,r3,1
8112216c:	29400044 	addi	r5,r5,1
81122170:	19ffffc5 	stb	r7,-1(r3)
81122174:	19bffb1e 	bne	r3,r6,81122164 <__reset+0xfb102164>
81122178:	dfc00217 	ldw	ra,8(sp)
8112217c:	dc400117 	ldw	r17,4(sp)
81122180:	dc000017 	ldw	r16,0(sp)
81122184:	dec00304 	addi	sp,sp,12
81122188:	f800283a 	ret
8112218c:	2007883a 	mov	r3,r4
81122190:	003ff206 	br	8112215c <__reset+0xfb10215c>
81122194:	2007883a 	mov	r3,r4
81122198:	003ff106 	br	81122160 <__reset+0xfb102160>
8112219c:	200d883a 	mov	r6,r4
811221a0:	003fee06 	br	8112215c <__reset+0xfb10215c>

811221a4 <memset>:
811221a4:	20c000cc 	andi	r3,r4,3
811221a8:	2005883a 	mov	r2,r4
811221ac:	18004426 	beq	r3,zero,811222c0 <memset+0x11c>
811221b0:	31ffffc4 	addi	r7,r6,-1
811221b4:	30004026 	beq	r6,zero,811222b8 <memset+0x114>
811221b8:	2813883a 	mov	r9,r5
811221bc:	200d883a 	mov	r6,r4
811221c0:	2007883a 	mov	r3,r4
811221c4:	00000406 	br	811221d8 <memset+0x34>
811221c8:	3a3fffc4 	addi	r8,r7,-1
811221cc:	31800044 	addi	r6,r6,1
811221d0:	38003926 	beq	r7,zero,811222b8 <memset+0x114>
811221d4:	400f883a 	mov	r7,r8
811221d8:	18c00044 	addi	r3,r3,1
811221dc:	32400005 	stb	r9,0(r6)
811221e0:	1a0000cc 	andi	r8,r3,3
811221e4:	403ff81e 	bne	r8,zero,811221c8 <__reset+0xfb1021c8>
811221e8:	010000c4 	movi	r4,3
811221ec:	21c02d2e 	bgeu	r4,r7,811222a4 <memset+0x100>
811221f0:	29003fcc 	andi	r4,r5,255
811221f4:	200c923a 	slli	r6,r4,8
811221f8:	3108b03a 	or	r4,r6,r4
811221fc:	200c943a 	slli	r6,r4,16
81122200:	218cb03a 	or	r6,r4,r6
81122204:	010003c4 	movi	r4,15
81122208:	21c0182e 	bgeu	r4,r7,8112226c <memset+0xc8>
8112220c:	3b3ffc04 	addi	r12,r7,-16
81122210:	6018d13a 	srli	r12,r12,4
81122214:	1a000104 	addi	r8,r3,4
81122218:	1ac00204 	addi	r11,r3,8
8112221c:	6008913a 	slli	r4,r12,4
81122220:	1a800304 	addi	r10,r3,12
81122224:	1813883a 	mov	r9,r3
81122228:	21000504 	addi	r4,r4,20
8112222c:	1909883a 	add	r4,r3,r4
81122230:	49800015 	stw	r6,0(r9)
81122234:	41800015 	stw	r6,0(r8)
81122238:	59800015 	stw	r6,0(r11)
8112223c:	51800015 	stw	r6,0(r10)
81122240:	42000404 	addi	r8,r8,16
81122244:	4a400404 	addi	r9,r9,16
81122248:	5ac00404 	addi	r11,r11,16
8112224c:	52800404 	addi	r10,r10,16
81122250:	413ff71e 	bne	r8,r4,81122230 <__reset+0xfb102230>
81122254:	63000044 	addi	r12,r12,1
81122258:	6018913a 	slli	r12,r12,4
8112225c:	39c003cc 	andi	r7,r7,15
81122260:	010000c4 	movi	r4,3
81122264:	1b07883a 	add	r3,r3,r12
81122268:	21c00e2e 	bgeu	r4,r7,811222a4 <memset+0x100>
8112226c:	1813883a 	mov	r9,r3
81122270:	3811883a 	mov	r8,r7
81122274:	010000c4 	movi	r4,3
81122278:	49800015 	stw	r6,0(r9)
8112227c:	423fff04 	addi	r8,r8,-4
81122280:	4a400104 	addi	r9,r9,4
81122284:	223ffc36 	bltu	r4,r8,81122278 <__reset+0xfb102278>
81122288:	393fff04 	addi	r4,r7,-4
8112228c:	2008d0ba 	srli	r4,r4,2
81122290:	39c000cc 	andi	r7,r7,3
81122294:	21000044 	addi	r4,r4,1
81122298:	2109883a 	add	r4,r4,r4
8112229c:	2109883a 	add	r4,r4,r4
811222a0:	1907883a 	add	r3,r3,r4
811222a4:	38000526 	beq	r7,zero,811222bc <memset+0x118>
811222a8:	19cf883a 	add	r7,r3,r7
811222ac:	19400005 	stb	r5,0(r3)
811222b0:	18c00044 	addi	r3,r3,1
811222b4:	38fffd1e 	bne	r7,r3,811222ac <__reset+0xfb1022ac>
811222b8:	f800283a 	ret
811222bc:	f800283a 	ret
811222c0:	2007883a 	mov	r3,r4
811222c4:	300f883a 	mov	r7,r6
811222c8:	003fc706 	br	811221e8 <__reset+0xfb1021e8>

811222cc <_open_r>:
811222cc:	defffd04 	addi	sp,sp,-12
811222d0:	de00012e 	bgeu	sp,et,811222d8 <_open_r+0xc>
811222d4:	003b68fa 	trap	3
811222d8:	2805883a 	mov	r2,r5
811222dc:	dc000015 	stw	r16,0(sp)
811222e0:	04204574 	movhi	r16,33045
811222e4:	dc400115 	stw	r17,4(sp)
811222e8:	300b883a 	mov	r5,r6
811222ec:	840b4b04 	addi	r16,r16,11564
811222f0:	2023883a 	mov	r17,r4
811222f4:	380d883a 	mov	r6,r7
811222f8:	1009883a 	mov	r4,r2
811222fc:	dfc00215 	stw	ra,8(sp)
81122300:	80000015 	stw	zero,0(r16)
81122304:	11370fc0 	call	811370fc <open>
81122308:	00ffffc4 	movi	r3,-1
8112230c:	10c00526 	beq	r2,r3,81122324 <_open_r+0x58>
81122310:	dfc00217 	ldw	ra,8(sp)
81122314:	dc400117 	ldw	r17,4(sp)
81122318:	dc000017 	ldw	r16,0(sp)
8112231c:	dec00304 	addi	sp,sp,12
81122320:	f800283a 	ret
81122324:	80c00017 	ldw	r3,0(r16)
81122328:	183ff926 	beq	r3,zero,81122310 <__reset+0xfb102310>
8112232c:	88c00015 	stw	r3,0(r17)
81122330:	003ff706 	br	81122310 <__reset+0xfb102310>

81122334 <_printf_r>:
81122334:	defffd04 	addi	sp,sp,-12
81122338:	2805883a 	mov	r2,r5
8112233c:	de00012e 	bgeu	sp,et,81122344 <_printf_r+0x10>
81122340:	003b68fa 	trap	3
81122344:	dfc00015 	stw	ra,0(sp)
81122348:	d9800115 	stw	r6,4(sp)
8112234c:	d9c00215 	stw	r7,8(sp)
81122350:	21400217 	ldw	r5,8(r4)
81122354:	d9c00104 	addi	r7,sp,4
81122358:	100d883a 	mov	r6,r2
8112235c:	11250600 	call	81125060 <___vfprintf_internal_r>
81122360:	dfc00017 	ldw	ra,0(sp)
81122364:	dec00304 	addi	sp,sp,12
81122368:	f800283a 	ret

8112236c <printf>:
8112236c:	defffc04 	addi	sp,sp,-16
81122370:	de00012e 	bgeu	sp,et,81122378 <printf+0xc>
81122374:	003b68fa 	trap	3
81122378:	dfc00015 	stw	ra,0(sp)
8112237c:	d9400115 	stw	r5,4(sp)
81122380:	d9800215 	stw	r6,8(sp)
81122384:	d9c00315 	stw	r7,12(sp)
81122388:	00a04574 	movhi	r2,33045
8112238c:	108ad804 	addi	r2,r2,11104
81122390:	10800017 	ldw	r2,0(r2)
81122394:	200b883a 	mov	r5,r4
81122398:	d9800104 	addi	r6,sp,4
8112239c:	11000217 	ldw	r4,8(r2)
811223a0:	11272600 	call	81127260 <__vfprintf_internal>
811223a4:	dfc00017 	ldw	ra,0(sp)
811223a8:	dec00404 	addi	sp,sp,16
811223ac:	f800283a 	ret

811223b0 <_putc_r>:
811223b0:	defffc04 	addi	sp,sp,-16
811223b4:	de00012e 	bgeu	sp,et,811223bc <_putc_r+0xc>
811223b8:	003b68fa 	trap	3
811223bc:	dc000215 	stw	r16,8(sp)
811223c0:	dfc00315 	stw	ra,12(sp)
811223c4:	2021883a 	mov	r16,r4
811223c8:	20000226 	beq	r4,zero,811223d4 <_putc_r+0x24>
811223cc:	20800e17 	ldw	r2,56(r4)
811223d0:	10001b26 	beq	r2,zero,81122440 <_putc_r+0x90>
811223d4:	30800217 	ldw	r2,8(r6)
811223d8:	10bfffc4 	addi	r2,r2,-1
811223dc:	30800215 	stw	r2,8(r6)
811223e0:	10000a16 	blt	r2,zero,8112240c <_putc_r+0x5c>
811223e4:	30800017 	ldw	r2,0(r6)
811223e8:	11400005 	stb	r5,0(r2)
811223ec:	30800017 	ldw	r2,0(r6)
811223f0:	10c00044 	addi	r3,r2,1
811223f4:	30c00015 	stw	r3,0(r6)
811223f8:	10800003 	ldbu	r2,0(r2)
811223fc:	dfc00317 	ldw	ra,12(sp)
81122400:	dc000217 	ldw	r16,8(sp)
81122404:	dec00404 	addi	sp,sp,16
81122408:	f800283a 	ret
8112240c:	30c00617 	ldw	r3,24(r6)
81122410:	10c00616 	blt	r2,r3,8112242c <_putc_r+0x7c>
81122414:	30800017 	ldw	r2,0(r6)
81122418:	00c00284 	movi	r3,10
8112241c:	11400005 	stb	r5,0(r2)
81122420:	30800017 	ldw	r2,0(r6)
81122424:	11400003 	ldbu	r5,0(r2)
81122428:	28fff11e 	bne	r5,r3,811223f0 <__reset+0xfb1023f0>
8112242c:	8009883a 	mov	r4,r16
81122430:	dfc00317 	ldw	ra,12(sp)
81122434:	dc000217 	ldw	r16,8(sp)
81122438:	dec00404 	addi	sp,sp,16
8112243c:	1128be41 	jmpi	81128be4 <__swbuf_r>
81122440:	d9400015 	stw	r5,0(sp)
81122444:	d9800115 	stw	r6,4(sp)
81122448:	112ae1c0 	call	8112ae1c <__sinit>
8112244c:	d9800117 	ldw	r6,4(sp)
81122450:	d9400017 	ldw	r5,0(sp)
81122454:	003fdf06 	br	811223d4 <__reset+0xfb1023d4>

81122458 <putc>:
81122458:	00a04574 	movhi	r2,33045
8112245c:	defffc04 	addi	sp,sp,-16
81122460:	108ad804 	addi	r2,r2,11104
81122464:	de00012e 	bgeu	sp,et,8112246c <putc+0x14>
81122468:	003b68fa 	trap	3
8112246c:	dc000115 	stw	r16,4(sp)
81122470:	14000017 	ldw	r16,0(r2)
81122474:	dc400215 	stw	r17,8(sp)
81122478:	dfc00315 	stw	ra,12(sp)
8112247c:	2023883a 	mov	r17,r4
81122480:	80000226 	beq	r16,zero,8112248c <putc+0x34>
81122484:	80800e17 	ldw	r2,56(r16)
81122488:	10001a26 	beq	r2,zero,811224f4 <putc+0x9c>
8112248c:	28800217 	ldw	r2,8(r5)
81122490:	10bfffc4 	addi	r2,r2,-1
81122494:	28800215 	stw	r2,8(r5)
81122498:	10000b16 	blt	r2,zero,811224c8 <putc+0x70>
8112249c:	28800017 	ldw	r2,0(r5)
811224a0:	14400005 	stb	r17,0(r2)
811224a4:	28800017 	ldw	r2,0(r5)
811224a8:	10c00044 	addi	r3,r2,1
811224ac:	28c00015 	stw	r3,0(r5)
811224b0:	10800003 	ldbu	r2,0(r2)
811224b4:	dfc00317 	ldw	ra,12(sp)
811224b8:	dc400217 	ldw	r17,8(sp)
811224bc:	dc000117 	ldw	r16,4(sp)
811224c0:	dec00404 	addi	sp,sp,16
811224c4:	f800283a 	ret
811224c8:	28c00617 	ldw	r3,24(r5)
811224cc:	10c00e16 	blt	r2,r3,81122508 <putc+0xb0>
811224d0:	28800017 	ldw	r2,0(r5)
811224d4:	01000284 	movi	r4,10
811224d8:	14400005 	stb	r17,0(r2)
811224dc:	28800017 	ldw	r2,0(r5)
811224e0:	10c00003 	ldbu	r3,0(r2)
811224e4:	193ff01e 	bne	r3,r4,811224a8 <__reset+0xfb1024a8>
811224e8:	280d883a 	mov	r6,r5
811224ec:	180b883a 	mov	r5,r3
811224f0:	00000706 	br	81122510 <putc+0xb8>
811224f4:	8009883a 	mov	r4,r16
811224f8:	d9400015 	stw	r5,0(sp)
811224fc:	112ae1c0 	call	8112ae1c <__sinit>
81122500:	d9400017 	ldw	r5,0(sp)
81122504:	003fe106 	br	8112248c <__reset+0xfb10248c>
81122508:	280d883a 	mov	r6,r5
8112250c:	880b883a 	mov	r5,r17
81122510:	8009883a 	mov	r4,r16
81122514:	dfc00317 	ldw	ra,12(sp)
81122518:	dc400217 	ldw	r17,8(sp)
8112251c:	dc000117 	ldw	r16,4(sp)
81122520:	dec00404 	addi	sp,sp,16
81122524:	1128be41 	jmpi	81128be4 <__swbuf_r>

81122528 <_puts_r>:
81122528:	defff604 	addi	sp,sp,-40
8112252c:	de00012e 	bgeu	sp,et,81122534 <_puts_r+0xc>
81122530:	003b68fa 	trap	3
81122534:	dc000715 	stw	r16,28(sp)
81122538:	2021883a 	mov	r16,r4
8112253c:	2809883a 	mov	r4,r5
81122540:	dc400815 	stw	r17,32(sp)
81122544:	dfc00915 	stw	ra,36(sp)
81122548:	2823883a 	mov	r17,r5
8112254c:	1122b480 	call	81122b48 <strlen>
81122550:	10c00044 	addi	r3,r2,1
81122554:	d8800115 	stw	r2,4(sp)
81122558:	00a04574 	movhi	r2,33045
8112255c:	1080ff04 	addi	r2,r2,1020
81122560:	d8800215 	stw	r2,8(sp)
81122564:	00800044 	movi	r2,1
81122568:	d8800315 	stw	r2,12(sp)
8112256c:	00800084 	movi	r2,2
81122570:	dc400015 	stw	r17,0(sp)
81122574:	d8c00615 	stw	r3,24(sp)
81122578:	dec00415 	stw	sp,16(sp)
8112257c:	d8800515 	stw	r2,20(sp)
81122580:	80000226 	beq	r16,zero,8112258c <_puts_r+0x64>
81122584:	80800e17 	ldw	r2,56(r16)
81122588:	10001426 	beq	r2,zero,811225dc <_puts_r+0xb4>
8112258c:	81400217 	ldw	r5,8(r16)
81122590:	2880030b 	ldhu	r2,12(r5)
81122594:	10c8000c 	andi	r3,r2,8192
81122598:	1800061e 	bne	r3,zero,811225b4 <_puts_r+0x8c>
8112259c:	29001917 	ldw	r4,100(r5)
811225a0:	00f7ffc4 	movi	r3,-8193
811225a4:	10880014 	ori	r2,r2,8192
811225a8:	20c6703a 	and	r3,r4,r3
811225ac:	2880030d 	sth	r2,12(r5)
811225b0:	28c01915 	stw	r3,100(r5)
811225b4:	d9800404 	addi	r6,sp,16
811225b8:	8009883a 	mov	r4,r16
811225bc:	112b5cc0 	call	8112b5cc <__sfvwrite_r>
811225c0:	1000091e 	bne	r2,zero,811225e8 <_puts_r+0xc0>
811225c4:	00800284 	movi	r2,10
811225c8:	dfc00917 	ldw	ra,36(sp)
811225cc:	dc400817 	ldw	r17,32(sp)
811225d0:	dc000717 	ldw	r16,28(sp)
811225d4:	dec00a04 	addi	sp,sp,40
811225d8:	f800283a 	ret
811225dc:	8009883a 	mov	r4,r16
811225e0:	112ae1c0 	call	8112ae1c <__sinit>
811225e4:	003fe906 	br	8112258c <__reset+0xfb10258c>
811225e8:	00bfffc4 	movi	r2,-1
811225ec:	003ff606 	br	811225c8 <__reset+0xfb1025c8>

811225f0 <puts>:
811225f0:	00a04574 	movhi	r2,33045
811225f4:	108ad804 	addi	r2,r2,11104
811225f8:	200b883a 	mov	r5,r4
811225fc:	11000017 	ldw	r4,0(r2)
81122600:	11225281 	jmpi	81122528 <_puts_r>

81122604 <lflush>:
81122604:	2080030b 	ldhu	r2,12(r4)
81122608:	00c00244 	movi	r3,9
8112260c:	1080024c 	andi	r2,r2,9
81122610:	10c00226 	beq	r2,r3,8112261c <lflush+0x18>
81122614:	0005883a 	mov	r2,zero
81122618:	f800283a 	ret
8112261c:	112aa841 	jmpi	8112aa84 <fflush>

81122620 <__srefill_r>:
81122620:	defffc04 	addi	sp,sp,-16
81122624:	de00012e 	bgeu	sp,et,8112262c <__srefill_r+0xc>
81122628:	003b68fa 	trap	3
8112262c:	dc400115 	stw	r17,4(sp)
81122630:	dc000015 	stw	r16,0(sp)
81122634:	dfc00315 	stw	ra,12(sp)
81122638:	dc800215 	stw	r18,8(sp)
8112263c:	2023883a 	mov	r17,r4
81122640:	2821883a 	mov	r16,r5
81122644:	20000226 	beq	r4,zero,81122650 <__srefill_r+0x30>
81122648:	20800e17 	ldw	r2,56(r4)
8112264c:	10003c26 	beq	r2,zero,81122740 <__srefill_r+0x120>
81122650:	80c0030b 	ldhu	r3,12(r16)
81122654:	1908000c 	andi	r4,r3,8192
81122658:	1805883a 	mov	r2,r3
8112265c:	2000071e 	bne	r4,zero,8112267c <__srefill_r+0x5c>
81122660:	81001917 	ldw	r4,100(r16)
81122664:	18880014 	ori	r2,r3,8192
81122668:	00f7ffc4 	movi	r3,-8193
8112266c:	20c8703a 	and	r4,r4,r3
81122670:	8080030d 	sth	r2,12(r16)
81122674:	1007883a 	mov	r3,r2
81122678:	81001915 	stw	r4,100(r16)
8112267c:	80000115 	stw	zero,4(r16)
81122680:	1100080c 	andi	r4,r2,32
81122684:	2000571e 	bne	r4,zero,811227e4 <__srefill_r+0x1c4>
81122688:	1100010c 	andi	r4,r2,4
8112268c:	20001f26 	beq	r4,zero,8112270c <__srefill_r+0xec>
81122690:	81400c17 	ldw	r5,48(r16)
81122694:	28000826 	beq	r5,zero,811226b8 <__srefill_r+0x98>
81122698:	80801004 	addi	r2,r16,64
8112269c:	28800226 	beq	r5,r2,811226a8 <__srefill_r+0x88>
811226a0:	8809883a 	mov	r4,r17
811226a4:	112b2b40 	call	8112b2b4 <_free_r>
811226a8:	80800f17 	ldw	r2,60(r16)
811226ac:	80000c15 	stw	zero,48(r16)
811226b0:	80800115 	stw	r2,4(r16)
811226b4:	1000391e 	bne	r2,zero,8112279c <__srefill_r+0x17c>
811226b8:	80800417 	ldw	r2,16(r16)
811226bc:	10004b26 	beq	r2,zero,811227ec <__srefill_r+0x1cc>
811226c0:	8480030b 	ldhu	r18,12(r16)
811226c4:	908000cc 	andi	r2,r18,3
811226c8:	10001f1e 	bne	r2,zero,81122748 <__srefill_r+0x128>
811226cc:	81800417 	ldw	r6,16(r16)
811226d0:	80800817 	ldw	r2,32(r16)
811226d4:	81c00517 	ldw	r7,20(r16)
811226d8:	81400717 	ldw	r5,28(r16)
811226dc:	81800015 	stw	r6,0(r16)
811226e0:	8809883a 	mov	r4,r17
811226e4:	103ee83a 	callr	r2
811226e8:	80800115 	stw	r2,4(r16)
811226ec:	00800e0e 	bge	zero,r2,81122728 <__srefill_r+0x108>
811226f0:	0005883a 	mov	r2,zero
811226f4:	dfc00317 	ldw	ra,12(sp)
811226f8:	dc800217 	ldw	r18,8(sp)
811226fc:	dc400117 	ldw	r17,4(sp)
81122700:	dc000017 	ldw	r16,0(sp)
81122704:	dec00404 	addi	sp,sp,16
81122708:	f800283a 	ret
8112270c:	1100040c 	andi	r4,r2,16
81122710:	20003026 	beq	r4,zero,811227d4 <__srefill_r+0x1b4>
81122714:	1080020c 	andi	r2,r2,8
81122718:	1000241e 	bne	r2,zero,811227ac <__srefill_r+0x18c>
8112271c:	18c00114 	ori	r3,r3,4
81122720:	80c0030d 	sth	r3,12(r16)
81122724:	003fe406 	br	811226b8 <__reset+0xfb1026b8>
81122728:	80c0030b 	ldhu	r3,12(r16)
8112272c:	1000161e 	bne	r2,zero,81122788 <__srefill_r+0x168>
81122730:	18c00814 	ori	r3,r3,32
81122734:	00bfffc4 	movi	r2,-1
81122738:	80c0030d 	sth	r3,12(r16)
8112273c:	003fed06 	br	811226f4 <__reset+0xfb1026f4>
81122740:	112ae1c0 	call	8112ae1c <__sinit>
81122744:	003fc206 	br	81122650 <__reset+0xfb102650>
81122748:	00a04574 	movhi	r2,33045
8112274c:	108ad704 	addi	r2,r2,11100
81122750:	11000017 	ldw	r4,0(r2)
81122754:	016044b4 	movhi	r5,33042
81122758:	00800044 	movi	r2,1
8112275c:	29498104 	addi	r5,r5,9732
81122760:	8080030d 	sth	r2,12(r16)
81122764:	112ba900 	call	8112ba90 <_fwalk>
81122768:	00800244 	movi	r2,9
8112276c:	8480030d 	sth	r18,12(r16)
81122770:	9480024c 	andi	r18,r18,9
81122774:	90bfd51e 	bne	r18,r2,811226cc <__reset+0xfb1026cc>
81122778:	800b883a 	mov	r5,r16
8112277c:	8809883a 	mov	r4,r17
81122780:	112a7fc0 	call	8112a7fc <__sflush_r>
81122784:	003fd106 	br	811226cc <__reset+0xfb1026cc>
81122788:	18c01014 	ori	r3,r3,64
8112278c:	80000115 	stw	zero,4(r16)
81122790:	00bfffc4 	movi	r2,-1
81122794:	80c0030d 	sth	r3,12(r16)
81122798:	003fd606 	br	811226f4 <__reset+0xfb1026f4>
8112279c:	80c00e17 	ldw	r3,56(r16)
811227a0:	0005883a 	mov	r2,zero
811227a4:	80c00015 	stw	r3,0(r16)
811227a8:	003fd206 	br	811226f4 <__reset+0xfb1026f4>
811227ac:	800b883a 	mov	r5,r16
811227b0:	8809883a 	mov	r4,r17
811227b4:	112aa200 	call	8112aa20 <_fflush_r>
811227b8:	10000a1e 	bne	r2,zero,811227e4 <__srefill_r+0x1c4>
811227bc:	8080030b 	ldhu	r2,12(r16)
811227c0:	00fffdc4 	movi	r3,-9
811227c4:	80000215 	stw	zero,8(r16)
811227c8:	1886703a 	and	r3,r3,r2
811227cc:	80000615 	stw	zero,24(r16)
811227d0:	003fd206 	br	8112271c <__reset+0xfb10271c>
811227d4:	00800244 	movi	r2,9
811227d8:	88800015 	stw	r2,0(r17)
811227dc:	18c01014 	ori	r3,r3,64
811227e0:	80c0030d 	sth	r3,12(r16)
811227e4:	00bfffc4 	movi	r2,-1
811227e8:	003fc206 	br	811226f4 <__reset+0xfb1026f4>
811227ec:	800b883a 	mov	r5,r16
811227f0:	8809883a 	mov	r4,r17
811227f4:	112167c0 	call	8112167c <__smakebuf_r>
811227f8:	003fb106 	br	811226c0 <__reset+0xfb1026c0>

811227fc <_sbrk_r>:
811227fc:	defffd04 	addi	sp,sp,-12
81122800:	de00012e 	bgeu	sp,et,81122808 <_sbrk_r+0xc>
81122804:	003b68fa 	trap	3
81122808:	dc000015 	stw	r16,0(sp)
8112280c:	04204574 	movhi	r16,33045
81122810:	dc400115 	stw	r17,4(sp)
81122814:	840b4b04 	addi	r16,r16,11564
81122818:	2023883a 	mov	r17,r4
8112281c:	2809883a 	mov	r4,r5
81122820:	dfc00215 	stw	ra,8(sp)
81122824:	80000015 	stw	zero,0(r16)
81122828:	113740c0 	call	8113740c <sbrk>
8112282c:	00ffffc4 	movi	r3,-1
81122830:	10c00526 	beq	r2,r3,81122848 <_sbrk_r+0x4c>
81122834:	dfc00217 	ldw	ra,8(sp)
81122838:	dc400117 	ldw	r17,4(sp)
8112283c:	dc000017 	ldw	r16,0(sp)
81122840:	dec00304 	addi	sp,sp,12
81122844:	f800283a 	ret
81122848:	80c00017 	ldw	r3,0(r16)
8112284c:	183ff926 	beq	r3,zero,81122834 <__reset+0xfb102834>
81122850:	88c00015 	stw	r3,0(r17)
81122854:	003ff706 	br	81122834 <__reset+0xfb102834>

81122858 <scanf>:
81122858:	defffc04 	addi	sp,sp,-16
8112285c:	de00012e 	bgeu	sp,et,81122864 <scanf+0xc>
81122860:	003b68fa 	trap	3
81122864:	dfc00015 	stw	ra,0(sp)
81122868:	d9400115 	stw	r5,4(sp)
8112286c:	d9800215 	stw	r6,8(sp)
81122870:	d9c00315 	stw	r7,12(sp)
81122874:	00a04574 	movhi	r2,33045
81122878:	108ad804 	addi	r2,r2,11104
8112287c:	200d883a 	mov	r6,r4
81122880:	11000017 	ldw	r4,0(r2)
81122884:	d9c00104 	addi	r7,sp,4
81122888:	21400117 	ldw	r5,4(r4)
8112288c:	1128b900 	call	81128b90 <_vfscanf_r>
81122890:	dfc00017 	ldw	ra,0(sp)
81122894:	dec00404 	addi	sp,sp,16
81122898:	f800283a 	ret

8112289c <_scanf_r>:
8112289c:	defffd04 	addi	sp,sp,-12
811228a0:	2805883a 	mov	r2,r5
811228a4:	de00012e 	bgeu	sp,et,811228ac <_scanf_r+0x10>
811228a8:	003b68fa 	trap	3
811228ac:	dfc00015 	stw	ra,0(sp)
811228b0:	d9800115 	stw	r6,4(sp)
811228b4:	d9c00215 	stw	r7,8(sp)
811228b8:	21400117 	ldw	r5,4(r4)
811228bc:	d9c00104 	addi	r7,sp,4
811228c0:	100d883a 	mov	r6,r2
811228c4:	1128b900 	call	81128b90 <_vfscanf_r>
811228c8:	dfc00017 	ldw	ra,0(sp)
811228cc:	dec00304 	addi	sp,sp,12
811228d0:	f800283a 	ret

811228d4 <_sprintf_r>:
811228d4:	deffe404 	addi	sp,sp,-112
811228d8:	2807883a 	mov	r3,r5
811228dc:	de00012e 	bgeu	sp,et,811228e4 <_sprintf_r+0x10>
811228e0:	003b68fa 	trap	3
811228e4:	dfc01a15 	stw	ra,104(sp)
811228e8:	d9c01b15 	stw	r7,108(sp)
811228ec:	00a00034 	movhi	r2,32768
811228f0:	10bfffc4 	addi	r2,r2,-1
811228f4:	02008204 	movi	r8,520
811228f8:	d8800215 	stw	r2,8(sp)
811228fc:	d8800515 	stw	r2,20(sp)
81122900:	d9c01b04 	addi	r7,sp,108
81122904:	d80b883a 	mov	r5,sp
81122908:	00bfffc4 	movi	r2,-1
8112290c:	d8c00015 	stw	r3,0(sp)
81122910:	d8c00415 	stw	r3,16(sp)
81122914:	da00030d 	sth	r8,12(sp)
81122918:	d880038d 	sth	r2,14(sp)
8112291c:	1122e800 	call	81122e80 <___svfprintf_internal_r>
81122920:	d8c00017 	ldw	r3,0(sp)
81122924:	18000005 	stb	zero,0(r3)
81122928:	dfc01a17 	ldw	ra,104(sp)
8112292c:	dec01c04 	addi	sp,sp,112
81122930:	f800283a 	ret

81122934 <sprintf>:
81122934:	deffe304 	addi	sp,sp,-116
81122938:	2007883a 	mov	r3,r4
8112293c:	de00012e 	bgeu	sp,et,81122944 <sprintf+0x10>
81122940:	003b68fa 	trap	3
81122944:	dfc01a15 	stw	ra,104(sp)
81122948:	d9801b15 	stw	r6,108(sp)
8112294c:	d9c01c15 	stw	r7,112(sp)
81122950:	01204574 	movhi	r4,33045
81122954:	210ad804 	addi	r4,r4,11104
81122958:	21000017 	ldw	r4,0(r4)
8112295c:	00a00034 	movhi	r2,32768
81122960:	10bfffc4 	addi	r2,r2,-1
81122964:	280d883a 	mov	r6,r5
81122968:	02008204 	movi	r8,520
8112296c:	d8800215 	stw	r2,8(sp)
81122970:	d8800515 	stw	r2,20(sp)
81122974:	d9c01b04 	addi	r7,sp,108
81122978:	d80b883a 	mov	r5,sp
8112297c:	00bfffc4 	movi	r2,-1
81122980:	d8c00015 	stw	r3,0(sp)
81122984:	d8c00415 	stw	r3,16(sp)
81122988:	da00030d 	sth	r8,12(sp)
8112298c:	d880038d 	sth	r2,14(sp)
81122990:	1122e800 	call	81122e80 <___svfprintf_internal_r>
81122994:	d8c00017 	ldw	r3,0(sp)
81122998:	18000005 	stb	zero,0(r3)
8112299c:	dfc01a17 	ldw	ra,104(sp)
811229a0:	dec01d04 	addi	sp,sp,116
811229a4:	f800283a 	ret

811229a8 <__sread>:
811229a8:	defffe04 	addi	sp,sp,-8
811229ac:	de00012e 	bgeu	sp,et,811229b4 <__sread+0xc>
811229b0:	003b68fa 	trap	3
811229b4:	dc000015 	stw	r16,0(sp)
811229b8:	2821883a 	mov	r16,r5
811229bc:	2940038f 	ldh	r5,14(r5)
811229c0:	dfc00115 	stw	ra,4(sp)
811229c4:	112d2e00 	call	8112d2e0 <_read_r>
811229c8:	10000716 	blt	r2,zero,811229e8 <__sread+0x40>
811229cc:	80c01417 	ldw	r3,80(r16)
811229d0:	1887883a 	add	r3,r3,r2
811229d4:	80c01415 	stw	r3,80(r16)
811229d8:	dfc00117 	ldw	ra,4(sp)
811229dc:	dc000017 	ldw	r16,0(sp)
811229e0:	dec00204 	addi	sp,sp,8
811229e4:	f800283a 	ret
811229e8:	80c0030b 	ldhu	r3,12(r16)
811229ec:	18fbffcc 	andi	r3,r3,61439
811229f0:	80c0030d 	sth	r3,12(r16)
811229f4:	dfc00117 	ldw	ra,4(sp)
811229f8:	dc000017 	ldw	r16,0(sp)
811229fc:	dec00204 	addi	sp,sp,8
81122a00:	f800283a 	ret

81122a04 <__seofread>:
81122a04:	0005883a 	mov	r2,zero
81122a08:	f800283a 	ret

81122a0c <__swrite>:
81122a0c:	defffb04 	addi	sp,sp,-20
81122a10:	de00012e 	bgeu	sp,et,81122a18 <__swrite+0xc>
81122a14:	003b68fa 	trap	3
81122a18:	2880030b 	ldhu	r2,12(r5)
81122a1c:	dcc00315 	stw	r19,12(sp)
81122a20:	dc800215 	stw	r18,8(sp)
81122a24:	dc400115 	stw	r17,4(sp)
81122a28:	dc000015 	stw	r16,0(sp)
81122a2c:	dfc00415 	stw	ra,16(sp)
81122a30:	10c0400c 	andi	r3,r2,256
81122a34:	2821883a 	mov	r16,r5
81122a38:	2023883a 	mov	r17,r4
81122a3c:	3025883a 	mov	r18,r6
81122a40:	3827883a 	mov	r19,r7
81122a44:	18000526 	beq	r3,zero,81122a5c <__swrite+0x50>
81122a48:	2940038f 	ldh	r5,14(r5)
81122a4c:	01c00084 	movi	r7,2
81122a50:	000d883a 	mov	r6,zero
81122a54:	112bd980 	call	8112bd98 <_lseek_r>
81122a58:	8080030b 	ldhu	r2,12(r16)
81122a5c:	8140038f 	ldh	r5,14(r16)
81122a60:	10bbffcc 	andi	r2,r2,61439
81122a64:	980f883a 	mov	r7,r19
81122a68:	900d883a 	mov	r6,r18
81122a6c:	8809883a 	mov	r4,r17
81122a70:	8080030d 	sth	r2,12(r16)
81122a74:	dfc00417 	ldw	ra,16(sp)
81122a78:	dcc00317 	ldw	r19,12(sp)
81122a7c:	dc800217 	ldw	r18,8(sp)
81122a80:	dc400117 	ldw	r17,4(sp)
81122a84:	dc000017 	ldw	r16,0(sp)
81122a88:	dec00504 	addi	sp,sp,20
81122a8c:	1128d441 	jmpi	81128d44 <_write_r>

81122a90 <__sseek>:
81122a90:	defffe04 	addi	sp,sp,-8
81122a94:	de00012e 	bgeu	sp,et,81122a9c <__sseek+0xc>
81122a98:	003b68fa 	trap	3
81122a9c:	dc000015 	stw	r16,0(sp)
81122aa0:	2821883a 	mov	r16,r5
81122aa4:	2940038f 	ldh	r5,14(r5)
81122aa8:	dfc00115 	stw	ra,4(sp)
81122aac:	112bd980 	call	8112bd98 <_lseek_r>
81122ab0:	00ffffc4 	movi	r3,-1
81122ab4:	10c00826 	beq	r2,r3,81122ad8 <__sseek+0x48>
81122ab8:	80c0030b 	ldhu	r3,12(r16)
81122abc:	80801415 	stw	r2,80(r16)
81122ac0:	18c40014 	ori	r3,r3,4096
81122ac4:	80c0030d 	sth	r3,12(r16)
81122ac8:	dfc00117 	ldw	ra,4(sp)
81122acc:	dc000017 	ldw	r16,0(sp)
81122ad0:	dec00204 	addi	sp,sp,8
81122ad4:	f800283a 	ret
81122ad8:	80c0030b 	ldhu	r3,12(r16)
81122adc:	18fbffcc 	andi	r3,r3,61439
81122ae0:	80c0030d 	sth	r3,12(r16)
81122ae4:	dfc00117 	ldw	ra,4(sp)
81122ae8:	dc000017 	ldw	r16,0(sp)
81122aec:	dec00204 	addi	sp,sp,8
81122af0:	f800283a 	ret

81122af4 <__sclose>:
81122af4:	2940038f 	ldh	r5,14(r5)
81122af8:	1128f081 	jmpi	81128f08 <_close_r>

81122afc <strcspn>:
81122afc:	21c00007 	ldb	r7,0(r4)
81122b00:	38000f26 	beq	r7,zero,81122b40 <strcspn+0x44>
81122b04:	2a000007 	ldb	r8,0(r5)
81122b08:	2005883a 	mov	r2,r4
81122b0c:	40000726 	beq	r8,zero,81122b2c <strcspn+0x30>
81122b10:	3a000926 	beq	r7,r8,81122b38 <strcspn+0x3c>
81122b14:	2807883a 	mov	r3,r5
81122b18:	00000106 	br	81122b20 <strcspn+0x24>
81122b1c:	31c00626 	beq	r6,r7,81122b38 <strcspn+0x3c>
81122b20:	18c00044 	addi	r3,r3,1
81122b24:	19800007 	ldb	r6,0(r3)
81122b28:	303ffc1e 	bne	r6,zero,81122b1c <__reset+0xfb102b1c>
81122b2c:	10800044 	addi	r2,r2,1
81122b30:	11c00007 	ldb	r7,0(r2)
81122b34:	383ff51e 	bne	r7,zero,81122b0c <__reset+0xfb102b0c>
81122b38:	1105c83a 	sub	r2,r2,r4
81122b3c:	f800283a 	ret
81122b40:	0005883a 	mov	r2,zero
81122b44:	f800283a 	ret

81122b48 <strlen>:
81122b48:	208000cc 	andi	r2,r4,3
81122b4c:	10002026 	beq	r2,zero,81122bd0 <strlen+0x88>
81122b50:	20800007 	ldb	r2,0(r4)
81122b54:	10002026 	beq	r2,zero,81122bd8 <strlen+0x90>
81122b58:	2005883a 	mov	r2,r4
81122b5c:	00000206 	br	81122b68 <strlen+0x20>
81122b60:	10c00007 	ldb	r3,0(r2)
81122b64:	18001826 	beq	r3,zero,81122bc8 <strlen+0x80>
81122b68:	10800044 	addi	r2,r2,1
81122b6c:	10c000cc 	andi	r3,r2,3
81122b70:	183ffb1e 	bne	r3,zero,81122b60 <__reset+0xfb102b60>
81122b74:	10c00017 	ldw	r3,0(r2)
81122b78:	01ffbff4 	movhi	r7,65279
81122b7c:	39ffbfc4 	addi	r7,r7,-257
81122b80:	00ca303a 	nor	r5,zero,r3
81122b84:	01a02074 	movhi	r6,32897
81122b88:	19c7883a 	add	r3,r3,r7
81122b8c:	31a02004 	addi	r6,r6,-32640
81122b90:	1946703a 	and	r3,r3,r5
81122b94:	1986703a 	and	r3,r3,r6
81122b98:	1800091e 	bne	r3,zero,81122bc0 <strlen+0x78>
81122b9c:	10800104 	addi	r2,r2,4
81122ba0:	10c00017 	ldw	r3,0(r2)
81122ba4:	19cb883a 	add	r5,r3,r7
81122ba8:	00c6303a 	nor	r3,zero,r3
81122bac:	28c6703a 	and	r3,r5,r3
81122bb0:	1986703a 	and	r3,r3,r6
81122bb4:	183ff926 	beq	r3,zero,81122b9c <__reset+0xfb102b9c>
81122bb8:	00000106 	br	81122bc0 <strlen+0x78>
81122bbc:	10800044 	addi	r2,r2,1
81122bc0:	10c00007 	ldb	r3,0(r2)
81122bc4:	183ffd1e 	bne	r3,zero,81122bbc <__reset+0xfb102bbc>
81122bc8:	1105c83a 	sub	r2,r2,r4
81122bcc:	f800283a 	ret
81122bd0:	2005883a 	mov	r2,r4
81122bd4:	003fe706 	br	81122b74 <__reset+0xfb102b74>
81122bd8:	0005883a 	mov	r2,zero
81122bdc:	f800283a 	ret

81122be0 <strnlen>:
81122be0:	28000e26 	beq	r5,zero,81122c1c <strnlen+0x3c>
81122be4:	20800007 	ldb	r2,0(r4)
81122be8:	10000c26 	beq	r2,zero,81122c1c <strnlen+0x3c>
81122bec:	20c00044 	addi	r3,r4,1
81122bf0:	214b883a 	add	r5,r4,r5
81122bf4:	28c00526 	beq	r5,r3,81122c0c <strnlen+0x2c>
81122bf8:	19800007 	ldb	r6,0(r3)
81122bfc:	19c00044 	addi	r7,r3,1
81122c00:	30000426 	beq	r6,zero,81122c14 <strnlen+0x34>
81122c04:	3807883a 	mov	r3,r7
81122c08:	28fffb1e 	bne	r5,r3,81122bf8 <__reset+0xfb102bf8>
81122c0c:	2905c83a 	sub	r2,r5,r4
81122c10:	f800283a 	ret
81122c14:	1905c83a 	sub	r2,r3,r4
81122c18:	f800283a 	ret
81122c1c:	0005883a 	mov	r2,zero
81122c20:	f800283a 	ret

81122c24 <_strtol_r>:
81122c24:	00a04574 	movhi	r2,33045
81122c28:	defff404 	addi	sp,sp,-48
81122c2c:	108ad604 	addi	r2,r2,11096
81122c30:	de00012e 	bgeu	sp,et,81122c38 <_strtol_r+0x14>
81122c34:	003b68fa 	trap	3
81122c38:	dd400715 	stw	r21,28(sp)
81122c3c:	15400017 	ldw	r21,0(r2)
81122c40:	dd800815 	stw	r22,32(sp)
81122c44:	dd000615 	stw	r20,24(sp)
81122c48:	dcc00515 	stw	r19,20(sp)
81122c4c:	d9000015 	stw	r4,0(sp)
81122c50:	dfc00b15 	stw	ra,44(sp)
81122c54:	df000a15 	stw	fp,40(sp)
81122c58:	ddc00915 	stw	r23,36(sp)
81122c5c:	dc800415 	stw	r18,16(sp)
81122c60:	dc400315 	stw	r17,12(sp)
81122c64:	dc000215 	stw	r16,8(sp)
81122c68:	2829883a 	mov	r20,r5
81122c6c:	3027883a 	mov	r19,r6
81122c70:	382d883a 	mov	r22,r7
81122c74:	2809883a 	mov	r4,r5
81122c78:	24000003 	ldbu	r16,0(r4)
81122c7c:	24400044 	addi	r17,r4,1
81122c80:	2007883a 	mov	r3,r4
81122c84:	ac05883a 	add	r2,r21,r16
81122c88:	10800043 	ldbu	r2,1(r2)
81122c8c:	8809883a 	mov	r4,r17
81122c90:	1080020c 	andi	r2,r2,8
81122c94:	103ff81e 	bne	r2,zero,81122c78 <__reset+0xfb102c78>
81122c98:	00800b44 	movi	r2,45
81122c9c:	80805826 	beq	r16,r2,81122e00 <_strtol_r+0x1dc>
81122ca0:	00800ac4 	movi	r2,43
81122ca4:	80805a26 	beq	r16,r2,81122e10 <_strtol_r+0x1ec>
81122ca8:	0039883a 	mov	fp,zero
81122cac:	b0004426 	beq	r22,zero,81122dc0 <_strtol_r+0x19c>
81122cb0:	00800404 	movi	r2,16
81122cb4:	b0806026 	beq	r22,r2,81122e38 <_strtol_r+0x214>
81122cb8:	b02f883a 	mov	r23,r22
81122cbc:	00a00034 	movhi	r2,32768
81122cc0:	e025003a 	cmpeq	r18,fp,zero
81122cc4:	14a5c83a 	sub	r18,r2,r18
81122cc8:	b80b883a 	mov	r5,r23
81122ccc:	9009883a 	mov	r4,r18
81122cd0:	11346240 	call	81134624 <__umodsi3>
81122cd4:	b80b883a 	mov	r5,r23
81122cd8:	9009883a 	mov	r4,r18
81122cdc:	d8800115 	stw	r2,4(sp)
81122ce0:	11345c00 	call	811345c0 <__udivsi3>
81122ce4:	ac07883a 	add	r3,r21,r16
81122ce8:	18c00043 	ldbu	r3,1(r3)
81122cec:	880b883a 	mov	r5,r17
81122cf0:	000d883a 	mov	r6,zero
81122cf4:	1a00010c 	andi	r8,r3,4
81122cf8:	0009883a 	mov	r4,zero
81122cfc:	02800044 	movi	r10,1
81122d00:	027fffc4 	movi	r9,-1
81122d04:	d9c00117 	ldw	r7,4(sp)
81122d08:	40000e26 	beq	r8,zero,81122d44 <_strtol_r+0x120>
81122d0c:	843ff404 	addi	r16,r16,-48
81122d10:	8580120e 	bge	r16,r22,81122d5c <_strtol_r+0x138>
81122d14:	32400526 	beq	r6,r9,81122d2c <_strtol_r+0x108>
81122d18:	11002536 	bltu	r2,r4,81122db0 <_strtol_r+0x18c>
81122d1c:	20802326 	beq	r4,r2,81122dac <_strtol_r+0x188>
81122d20:	25c9383a 	mul	r4,r4,r23
81122d24:	01800044 	movi	r6,1
81122d28:	8109883a 	add	r4,r16,r4
81122d2c:	2c000003 	ldbu	r16,0(r5)
81122d30:	29400044 	addi	r5,r5,1
81122d34:	ac07883a 	add	r3,r21,r16
81122d38:	18c00043 	ldbu	r3,1(r3)
81122d3c:	1a00010c 	andi	r8,r3,4
81122d40:	403ff21e 	bne	r8,zero,81122d0c <__reset+0xfb102d0c>
81122d44:	18c000cc 	andi	r3,r3,3
81122d48:	18000426 	beq	r3,zero,81122d5c <_strtol_r+0x138>
81122d4c:	1a801a26 	beq	r3,r10,81122db8 <_strtol_r+0x194>
81122d50:	00c015c4 	movi	r3,87
81122d54:	80e1c83a 	sub	r16,r16,r3
81122d58:	85bfee16 	blt	r16,r22,81122d14 <__reset+0xfb102d14>
81122d5c:	00bfffc4 	movi	r2,-1
81122d60:	30801e26 	beq	r6,r2,81122ddc <_strtol_r+0x1b8>
81122d64:	e0001b1e 	bne	fp,zero,81122dd4 <_strtol_r+0x1b0>
81122d68:	2005883a 	mov	r2,r4
81122d6c:	98000326 	beq	r19,zero,81122d7c <_strtol_r+0x158>
81122d70:	3000211e 	bne	r6,zero,81122df8 <_strtol_r+0x1d4>
81122d74:	a00b883a 	mov	r5,r20
81122d78:	99400015 	stw	r5,0(r19)
81122d7c:	dfc00b17 	ldw	ra,44(sp)
81122d80:	df000a17 	ldw	fp,40(sp)
81122d84:	ddc00917 	ldw	r23,36(sp)
81122d88:	dd800817 	ldw	r22,32(sp)
81122d8c:	dd400717 	ldw	r21,28(sp)
81122d90:	dd000617 	ldw	r20,24(sp)
81122d94:	dcc00517 	ldw	r19,20(sp)
81122d98:	dc800417 	ldw	r18,16(sp)
81122d9c:	dc400317 	ldw	r17,12(sp)
81122da0:	dc000217 	ldw	r16,8(sp)
81122da4:	dec00c04 	addi	sp,sp,48
81122da8:	f800283a 	ret
81122dac:	3c3fdc0e 	bge	r7,r16,81122d20 <__reset+0xfb102d20>
81122db0:	01bfffc4 	movi	r6,-1
81122db4:	003fdd06 	br	81122d2c <__reset+0xfb102d2c>
81122db8:	00c00dc4 	movi	r3,55
81122dbc:	003fe506 	br	81122d54 <__reset+0xfb102d54>
81122dc0:	00800c04 	movi	r2,48
81122dc4:	80801626 	beq	r16,r2,81122e20 <_strtol_r+0x1fc>
81122dc8:	05800284 	movi	r22,10
81122dcc:	b02f883a 	mov	r23,r22
81122dd0:	003fba06 	br	81122cbc <__reset+0xfb102cbc>
81122dd4:	0109c83a 	sub	r4,zero,r4
81122dd8:	003fe306 	br	81122d68 <__reset+0xfb102d68>
81122ddc:	d9000017 	ldw	r4,0(sp)
81122de0:	00c00884 	movi	r3,34
81122de4:	e005003a 	cmpeq	r2,fp,zero
81122de8:	20c00015 	stw	r3,0(r4)
81122dec:	00e00034 	movhi	r3,32768
81122df0:	1885c83a 	sub	r2,r3,r2
81122df4:	983fe126 	beq	r19,zero,81122d7c <__reset+0xfb102d7c>
81122df8:	297fffc4 	addi	r5,r5,-1
81122dfc:	003fde06 	br	81122d78 <__reset+0xfb102d78>
81122e00:	1c400084 	addi	r17,r3,2
81122e04:	1c000043 	ldbu	r16,1(r3)
81122e08:	07000044 	movi	fp,1
81122e0c:	003fa706 	br	81122cac <__reset+0xfb102cac>
81122e10:	1c400084 	addi	r17,r3,2
81122e14:	1c000043 	ldbu	r16,1(r3)
81122e18:	0039883a 	mov	fp,zero
81122e1c:	003fa306 	br	81122cac <__reset+0xfb102cac>
81122e20:	88800003 	ldbu	r2,0(r17)
81122e24:	00c01604 	movi	r3,88
81122e28:	108037cc 	andi	r2,r2,223
81122e2c:	10c00826 	beq	r2,r3,81122e50 <_strtol_r+0x22c>
81122e30:	05800204 	movi	r22,8
81122e34:	003fa006 	br	81122cb8 <__reset+0xfb102cb8>
81122e38:	00800c04 	movi	r2,48
81122e3c:	80bf9e1e 	bne	r16,r2,81122cb8 <__reset+0xfb102cb8>
81122e40:	88800003 	ldbu	r2,0(r17)
81122e44:	00c01604 	movi	r3,88
81122e48:	108037cc 	andi	r2,r2,223
81122e4c:	10ff9a1e 	bne	r2,r3,81122cb8 <__reset+0xfb102cb8>
81122e50:	05c00404 	movi	r23,16
81122e54:	8c000043 	ldbu	r16,1(r17)
81122e58:	b82d883a 	mov	r22,r23
81122e5c:	8c400084 	addi	r17,r17,2
81122e60:	003f9606 	br	81122cbc <__reset+0xfb102cbc>

81122e64 <strtol>:
81122e64:	00a04574 	movhi	r2,33045
81122e68:	108ad804 	addi	r2,r2,11104
81122e6c:	300f883a 	mov	r7,r6
81122e70:	280d883a 	mov	r6,r5
81122e74:	200b883a 	mov	r5,r4
81122e78:	11000017 	ldw	r4,0(r2)
81122e7c:	1122c241 	jmpi	81122c24 <_strtol_r>

81122e80 <___svfprintf_internal_r>:
81122e80:	deffb704 	addi	sp,sp,-292
81122e84:	de00012e 	bgeu	sp,et,81122e8c <___svfprintf_internal_r+0xc>
81122e88:	003b68fa 	trap	3
81122e8c:	dfc04815 	stw	ra,288(sp)
81122e90:	ddc04615 	stw	r23,280(sp)
81122e94:	d9402c15 	stw	r5,176(sp)
81122e98:	d9003915 	stw	r4,228(sp)
81122e9c:	302f883a 	mov	r23,r6
81122ea0:	d9c02d15 	stw	r7,180(sp)
81122ea4:	df004715 	stw	fp,284(sp)
81122ea8:	dd804515 	stw	r22,276(sp)
81122eac:	dd404415 	stw	r21,272(sp)
81122eb0:	dd004315 	stw	r20,268(sp)
81122eb4:	dcc04215 	stw	r19,264(sp)
81122eb8:	dc804115 	stw	r18,260(sp)
81122ebc:	dc404015 	stw	r17,256(sp)
81122ec0:	dc003f15 	stw	r16,252(sp)
81122ec4:	112bd680 	call	8112bd68 <_localeconv_r>
81122ec8:	10800017 	ldw	r2,0(r2)
81122ecc:	1009883a 	mov	r4,r2
81122ed0:	d8803415 	stw	r2,208(sp)
81122ed4:	1122b480 	call	81122b48 <strlen>
81122ed8:	d8c02c17 	ldw	r3,176(sp)
81122edc:	d8803815 	stw	r2,224(sp)
81122ee0:	1880030b 	ldhu	r2,12(r3)
81122ee4:	1080200c 	andi	r2,r2,128
81122ee8:	10000226 	beq	r2,zero,81122ef4 <___svfprintf_internal_r+0x74>
81122eec:	18800417 	ldw	r2,16(r3)
81122ef0:	10067f26 	beq	r2,zero,811248f0 <___svfprintf_internal_r+0x1a70>
81122ef4:	dcc03917 	ldw	r19,228(sp)
81122ef8:	d8c00404 	addi	r3,sp,16
81122efc:	05604574 	movhi	r21,33045
81122f00:	d9001e04 	addi	r4,sp,120
81122f04:	ad411084 	addi	r21,r21,1090
81122f08:	d8c01e15 	stw	r3,120(sp)
81122f0c:	d8002015 	stw	zero,128(sp)
81122f10:	d8001f15 	stw	zero,124(sp)
81122f14:	d8003315 	stw	zero,204(sp)
81122f18:	d8003615 	stw	zero,216(sp)
81122f1c:	d8003715 	stw	zero,220(sp)
81122f20:	1811883a 	mov	r8,r3
81122f24:	d8003a15 	stw	zero,232(sp)
81122f28:	d8003b15 	stw	zero,236(sp)
81122f2c:	d8002f15 	stw	zero,188(sp)
81122f30:	d9002815 	stw	r4,160(sp)
81122f34:	b8800007 	ldb	r2,0(r23)
81122f38:	10026726 	beq	r2,zero,811238d8 <___svfprintf_internal_r+0xa58>
81122f3c:	00c00944 	movi	r3,37
81122f40:	b821883a 	mov	r16,r23
81122f44:	10c0021e 	bne	r2,r3,81122f50 <___svfprintf_internal_r+0xd0>
81122f48:	00001406 	br	81122f9c <___svfprintf_internal_r+0x11c>
81122f4c:	10c00326 	beq	r2,r3,81122f5c <___svfprintf_internal_r+0xdc>
81122f50:	84000044 	addi	r16,r16,1
81122f54:	80800007 	ldb	r2,0(r16)
81122f58:	103ffc1e 	bne	r2,zero,81122f4c <__reset+0xfb102f4c>
81122f5c:	85e3c83a 	sub	r17,r16,r23
81122f60:	88000e26 	beq	r17,zero,81122f9c <___svfprintf_internal_r+0x11c>
81122f64:	d8c02017 	ldw	r3,128(sp)
81122f68:	d8801f17 	ldw	r2,124(sp)
81122f6c:	45c00015 	stw	r23,0(r8)
81122f70:	1c47883a 	add	r3,r3,r17
81122f74:	10800044 	addi	r2,r2,1
81122f78:	d8c02015 	stw	r3,128(sp)
81122f7c:	44400115 	stw	r17,4(r8)
81122f80:	d8801f15 	stw	r2,124(sp)
81122f84:	00c001c4 	movi	r3,7
81122f88:	18809716 	blt	r3,r2,811231e8 <___svfprintf_internal_r+0x368>
81122f8c:	42000204 	addi	r8,r8,8
81122f90:	d9402f17 	ldw	r5,188(sp)
81122f94:	2c4b883a 	add	r5,r5,r17
81122f98:	d9402f15 	stw	r5,188(sp)
81122f9c:	80800007 	ldb	r2,0(r16)
81122fa0:	10009826 	beq	r2,zero,81123204 <___svfprintf_internal_r+0x384>
81122fa4:	84400047 	ldb	r17,1(r16)
81122fa8:	00bfffc4 	movi	r2,-1
81122fac:	85c00044 	addi	r23,r16,1
81122fb0:	d8002785 	stb	zero,158(sp)
81122fb4:	0007883a 	mov	r3,zero
81122fb8:	000f883a 	mov	r7,zero
81122fbc:	d8802915 	stw	r2,164(sp)
81122fc0:	d8003115 	stw	zero,196(sp)
81122fc4:	0025883a 	mov	r18,zero
81122fc8:	01401604 	movi	r5,88
81122fcc:	01800244 	movi	r6,9
81122fd0:	02800a84 	movi	r10,42
81122fd4:	02401b04 	movi	r9,108
81122fd8:	bdc00044 	addi	r23,r23,1
81122fdc:	88bff804 	addi	r2,r17,-32
81122fe0:	2882f036 	bltu	r5,r2,81123ba4 <___svfprintf_internal_r+0xd24>
81122fe4:	100490ba 	slli	r2,r2,2
81122fe8:	012044b4 	movhi	r4,33042
81122fec:	210bff04 	addi	r4,r4,12284
81122ff0:	1105883a 	add	r2,r2,r4
81122ff4:	10800017 	ldw	r2,0(r2)
81122ff8:	1000683a 	jmp	r2
81122ffc:	81123b0c 	andi	r4,r16,18668
81123000:	81123ba4 	muli	r4,r16,18670
81123004:	81123ba4 	muli	r4,r16,18670
81123008:	81123b00 	call	881123b0 <__reset+0x20f23b0>
8112300c:	81123ba4 	muli	r4,r16,18670
81123010:	81123ba4 	muli	r4,r16,18670
81123014:	81123ba4 	muli	r4,r16,18670
81123018:	81123ba4 	muli	r4,r16,18670
8112301c:	81123ba4 	muli	r4,r16,18670
81123020:	81123ba4 	muli	r4,r16,18670
81123024:	81123260 	cmpeqi	r4,r16,18633
81123028:	81123a3c 	xorhi	r4,r16,18664
8112302c:	81123ba4 	muli	r4,r16,18670
81123030:	81123170 	cmpltui	r4,r16,18629
81123034:	81123288 	cmpgei	r4,r16,18634
81123038:	81123ba4 	muli	r4,r16,18670
8112303c:	811232fc 	xorhi	r4,r16,18635
81123040:	811232c8 	cmpgei	r4,r16,18635
81123044:	811232c8 	cmpgei	r4,r16,18635
81123048:	811232c8 	cmpgei	r4,r16,18635
8112304c:	811232c8 	cmpgei	r4,r16,18635
81123050:	811232c8 	cmpgei	r4,r16,18635
81123054:	811232c8 	cmpgei	r4,r16,18635
81123058:	811232c8 	cmpgei	r4,r16,18635
8112305c:	811232c8 	cmpgei	r4,r16,18635
81123060:	811232c8 	cmpgei	r4,r16,18635
81123064:	81123ba4 	muli	r4,r16,18670
81123068:	81123ba4 	muli	r4,r16,18670
8112306c:	81123ba4 	muli	r4,r16,18670
81123070:	81123ba4 	muli	r4,r16,18670
81123074:	81123ba4 	muli	r4,r16,18670
81123078:	81123ba4 	muli	r4,r16,18670
8112307c:	81123ba4 	muli	r4,r16,18670
81123080:	81123ba4 	muli	r4,r16,18670
81123084:	81123ba4 	muli	r4,r16,18670
81123088:	81123ba4 	muli	r4,r16,18670
8112308c:	811233b4 	orhi	r4,r16,18638
81123090:	81123308 	cmpgei	r4,r16,18636
81123094:	81123ba4 	muli	r4,r16,18670
81123098:	81123308 	cmpgei	r4,r16,18636
8112309c:	81123ba4 	muli	r4,r16,18670
811230a0:	81123ba4 	muli	r4,r16,18670
811230a4:	81123ba4 	muli	r4,r16,18670
811230a8:	81123ba4 	muli	r4,r16,18670
811230ac:	811233a8 	cmpgeui	r4,r16,18638
811230b0:	81123ba4 	muli	r4,r16,18670
811230b4:	81123ba4 	muli	r4,r16,18670
811230b8:	81123470 	cmpltui	r4,r16,18641
811230bc:	81123ba4 	muli	r4,r16,18670
811230c0:	81123ba4 	muli	r4,r16,18670
811230c4:	81123ba4 	muli	r4,r16,18670
811230c8:	81123ba4 	muli	r4,r16,18670
811230cc:	81123ba4 	muli	r4,r16,18670
811230d0:	811238e0 	cmpeqi	r4,r16,18659
811230d4:	81123ba4 	muli	r4,r16,18670
811230d8:	81123ba4 	muli	r4,r16,18670
811230dc:	81123940 	call	88112394 <__reset+0x20f2394>
811230e0:	81123ba4 	muli	r4,r16,18670
811230e4:	81123ba4 	muli	r4,r16,18670
811230e8:	81123ba4 	muli	r4,r16,18670
811230ec:	81123ba4 	muli	r4,r16,18670
811230f0:	81123ba4 	muli	r4,r16,18670
811230f4:	81123ba4 	muli	r4,r16,18670
811230f8:	81123ba4 	muli	r4,r16,18670
811230fc:	81123ba4 	muli	r4,r16,18670
81123100:	81123ba4 	muli	r4,r16,18670
81123104:	81123ba4 	muli	r4,r16,18670
81123108:	811239f0 	cmpltui	r4,r16,18663
8112310c:	81123b2c 	andhi	r4,r16,18668
81123110:	81123308 	cmpgei	r4,r16,18636
81123114:	81123308 	cmpgei	r4,r16,18636
81123118:	81123308 	cmpgei	r4,r16,18636
8112311c:	81123b80 	call	881123b8 <__reset+0x20f23b8>
81123120:	81123b2c 	andhi	r4,r16,18668
81123124:	81123ba4 	muli	r4,r16,18670
81123128:	81123ba4 	muli	r4,r16,18670
8112312c:	81123b3c 	xorhi	r4,r16,18668
81123130:	81123ba4 	muli	r4,r16,18670
81123134:	81123b4c 	andi	r4,r16,18669
81123138:	81123a2c 	andhi	r4,r16,18664
8112313c:	8112317c 	xorhi	r4,r16,18629
81123140:	81123a4c 	andi	r4,r16,18665
81123144:	81123ba4 	muli	r4,r16,18670
81123148:	81123a58 	cmpnei	r4,r16,18665
8112314c:	81123ba4 	muli	r4,r16,18670
81123150:	81123ab4 	orhi	r4,r16,18666
81123154:	81123ba4 	muli	r4,r16,18670
81123158:	81123ba4 	muli	r4,r16,18670
8112315c:	81123ac4 	addi	r4,r16,18667
81123160:	d9003117 	ldw	r4,196(sp)
81123164:	d8802d15 	stw	r2,180(sp)
81123168:	0109c83a 	sub	r4,zero,r4
8112316c:	d9003115 	stw	r4,196(sp)
81123170:	94800114 	ori	r18,r18,4
81123174:	bc400007 	ldb	r17,0(r23)
81123178:	003f9706 	br	81122fd8 <__reset+0xfb102fd8>
8112317c:	00800c04 	movi	r2,48
81123180:	d9002d17 	ldw	r4,180(sp)
81123184:	d9402917 	ldw	r5,164(sp)
81123188:	d8802705 	stb	r2,156(sp)
8112318c:	00801e04 	movi	r2,120
81123190:	d8802745 	stb	r2,157(sp)
81123194:	d8002785 	stb	zero,158(sp)
81123198:	20c00104 	addi	r3,r4,4
8112319c:	25000017 	ldw	r20,0(r4)
811231a0:	002d883a 	mov	r22,zero
811231a4:	90800094 	ori	r2,r18,2
811231a8:	28028616 	blt	r5,zero,81123bc4 <___svfprintf_internal_r+0xd44>
811231ac:	00bfdfc4 	movi	r2,-129
811231b0:	90a4703a 	and	r18,r18,r2
811231b4:	d8c02d15 	stw	r3,180(sp)
811231b8:	94800094 	ori	r18,r18,2
811231bc:	a002731e 	bne	r20,zero,81123b8c <___svfprintf_internal_r+0xd0c>
811231c0:	00a04574 	movhi	r2,33045
811231c4:	10810904 	addi	r2,r2,1060
811231c8:	d8803a15 	stw	r2,232(sp)
811231cc:	04401e04 	movi	r17,120
811231d0:	d8c02917 	ldw	r3,164(sp)
811231d4:	0039883a 	mov	fp,zero
811231d8:	1801d526 	beq	r3,zero,81123930 <___svfprintf_internal_r+0xab0>
811231dc:	0029883a 	mov	r20,zero
811231e0:	002d883a 	mov	r22,zero
811231e4:	0001f106 	br	811239ac <___svfprintf_internal_r+0xb2c>
811231e8:	d9402c17 	ldw	r5,176(sp)
811231ec:	d9801e04 	addi	r6,sp,120
811231f0:	9809883a 	mov	r4,r19
811231f4:	112faa00 	call	8112faa0 <__ssprint_r>
811231f8:	1000081e 	bne	r2,zero,8112321c <___svfprintf_internal_r+0x39c>
811231fc:	da000404 	addi	r8,sp,16
81123200:	003f6306 	br	81122f90 <__reset+0xfb102f90>
81123204:	d8802017 	ldw	r2,128(sp)
81123208:	10000426 	beq	r2,zero,8112321c <___svfprintf_internal_r+0x39c>
8112320c:	d9402c17 	ldw	r5,176(sp)
81123210:	d9003917 	ldw	r4,228(sp)
81123214:	d9801e04 	addi	r6,sp,120
81123218:	112faa00 	call	8112faa0 <__ssprint_r>
8112321c:	d8802c17 	ldw	r2,176(sp)
81123220:	10c0030b 	ldhu	r3,12(r2)
81123224:	d8802f17 	ldw	r2,188(sp)
81123228:	18c0100c 	andi	r3,r3,64
8112322c:	1805f51e 	bne	r3,zero,81124a04 <___svfprintf_internal_r+0x1b84>
81123230:	dfc04817 	ldw	ra,288(sp)
81123234:	df004717 	ldw	fp,284(sp)
81123238:	ddc04617 	ldw	r23,280(sp)
8112323c:	dd804517 	ldw	r22,276(sp)
81123240:	dd404417 	ldw	r21,272(sp)
81123244:	dd004317 	ldw	r20,268(sp)
81123248:	dcc04217 	ldw	r19,264(sp)
8112324c:	dc804117 	ldw	r18,260(sp)
81123250:	dc404017 	ldw	r17,256(sp)
81123254:	dc003f17 	ldw	r16,252(sp)
81123258:	dec04904 	addi	sp,sp,292
8112325c:	f800283a 	ret
81123260:	d8802d17 	ldw	r2,180(sp)
81123264:	d9002d17 	ldw	r4,180(sp)
81123268:	10800017 	ldw	r2,0(r2)
8112326c:	d8803115 	stw	r2,196(sp)
81123270:	20800104 	addi	r2,r4,4
81123274:	d9003117 	ldw	r4,196(sp)
81123278:	203fb916 	blt	r4,zero,81123160 <__reset+0xfb103160>
8112327c:	d8802d15 	stw	r2,180(sp)
81123280:	bc400007 	ldb	r17,0(r23)
81123284:	003f5406 	br	81122fd8 <__reset+0xfb102fd8>
81123288:	bc400007 	ldb	r17,0(r23)
8112328c:	bac00044 	addi	r11,r23,1
81123290:	8a873926 	beq	r17,r10,81124f78 <___svfprintf_internal_r+0x20f8>
81123294:	88bff404 	addi	r2,r17,-48
81123298:	0009883a 	mov	r4,zero
8112329c:	30868836 	bltu	r6,r2,81124cc0 <___svfprintf_internal_r+0x1e40>
811232a0:	5c400007 	ldb	r17,0(r11)
811232a4:	210002a4 	muli	r4,r4,10
811232a8:	5dc00044 	addi	r23,r11,1
811232ac:	b817883a 	mov	r11,r23
811232b0:	2089883a 	add	r4,r4,r2
811232b4:	88bff404 	addi	r2,r17,-48
811232b8:	30bff92e 	bgeu	r6,r2,811232a0 <__reset+0xfb1032a0>
811232bc:	2005d716 	blt	r4,zero,81124a1c <___svfprintf_internal_r+0x1b9c>
811232c0:	d9002915 	stw	r4,164(sp)
811232c4:	003f4506 	br	81122fdc <__reset+0xfb102fdc>
811232c8:	b809883a 	mov	r4,r23
811232cc:	d8003115 	stw	zero,196(sp)
811232d0:	88bff404 	addi	r2,r17,-48
811232d4:	0017883a 	mov	r11,zero
811232d8:	24400007 	ldb	r17,0(r4)
811232dc:	5ac002a4 	muli	r11,r11,10
811232e0:	bdc00044 	addi	r23,r23,1
811232e4:	b809883a 	mov	r4,r23
811232e8:	12d7883a 	add	r11,r2,r11
811232ec:	88bff404 	addi	r2,r17,-48
811232f0:	30bff92e 	bgeu	r6,r2,811232d8 <__reset+0xfb1032d8>
811232f4:	dac03115 	stw	r11,196(sp)
811232f8:	003f3806 	br	81122fdc <__reset+0xfb102fdc>
811232fc:	94802014 	ori	r18,r18,128
81123300:	bc400007 	ldb	r17,0(r23)
81123304:	003f3406 	br	81122fd8 <__reset+0xfb102fd8>
81123308:	18c03fcc 	andi	r3,r3,255
8112330c:	1807471e 	bne	r3,zero,8112502c <___svfprintf_internal_r+0x21ac>
81123310:	9080020c 	andi	r2,r18,8
81123314:	10047d26 	beq	r2,zero,8112450c <___svfprintf_internal_r+0x168c>
81123318:	d8c02d17 	ldw	r3,180(sp)
8112331c:	d9002d17 	ldw	r4,180(sp)
81123320:	d9402d17 	ldw	r5,180(sp)
81123324:	18c00017 	ldw	r3,0(r3)
81123328:	21000117 	ldw	r4,4(r4)
8112332c:	29400204 	addi	r5,r5,8
81123330:	d8c03615 	stw	r3,216(sp)
81123334:	d9003715 	stw	r4,220(sp)
81123338:	d9402d15 	stw	r5,180(sp)
8112333c:	d9003617 	ldw	r4,216(sp)
81123340:	d9403717 	ldw	r5,220(sp)
81123344:	da003e15 	stw	r8,248(sp)
81123348:	04000044 	movi	r16,1
8112334c:	112d8b40 	call	8112d8b4 <__fpclassifyd>
81123350:	da003e17 	ldw	r8,248(sp)
81123354:	14044b1e 	bne	r2,r16,81124484 <___svfprintf_internal_r+0x1604>
81123358:	d9003617 	ldw	r4,216(sp)
8112335c:	d9403717 	ldw	r5,220(sp)
81123360:	000d883a 	mov	r6,zero
81123364:	000f883a 	mov	r7,zero
81123368:	1135aa40 	call	81135aa4 <__ledf2>
8112336c:	da003e17 	ldw	r8,248(sp)
81123370:	1005f316 	blt	r2,zero,81124b40 <___svfprintf_internal_r+0x1cc0>
81123374:	df002783 	ldbu	fp,158(sp)
81123378:	008011c4 	movi	r2,71
8112337c:	1445590e 	bge	r2,r17,811248e4 <___svfprintf_internal_r+0x1a64>
81123380:	04204574 	movhi	r16,33045
81123384:	84010104 	addi	r16,r16,1028
81123388:	00c000c4 	movi	r3,3
8112338c:	00bfdfc4 	movi	r2,-129
81123390:	d8c02a15 	stw	r3,168(sp)
81123394:	90a4703a 	and	r18,r18,r2
81123398:	d8c02e15 	stw	r3,184(sp)
8112339c:	d8002915 	stw	zero,164(sp)
811233a0:	d8003215 	stw	zero,200(sp)
811233a4:	00006606 	br	81123540 <___svfprintf_internal_r+0x6c0>
811233a8:	94800214 	ori	r18,r18,8
811233ac:	bc400007 	ldb	r17,0(r23)
811233b0:	003f0906 	br	81122fd8 <__reset+0xfb102fd8>
811233b4:	18c03fcc 	andi	r3,r3,255
811233b8:	1807181e 	bne	r3,zero,8112501c <___svfprintf_internal_r+0x219c>
811233bc:	94800414 	ori	r18,r18,16
811233c0:	9080080c 	andi	r2,r18,32
811233c4:	10039626 	beq	r2,zero,81124220 <___svfprintf_internal_r+0x13a0>
811233c8:	d9402d17 	ldw	r5,180(sp)
811233cc:	28800117 	ldw	r2,4(r5)
811233d0:	2d000017 	ldw	r20,0(r5)
811233d4:	29400204 	addi	r5,r5,8
811233d8:	d9402d15 	stw	r5,180(sp)
811233dc:	102d883a 	mov	r22,r2
811233e0:	10039816 	blt	r2,zero,81124244 <___svfprintf_internal_r+0x13c4>
811233e4:	d9402917 	ldw	r5,164(sp)
811233e8:	df002783 	ldbu	fp,158(sp)
811233ec:	2803ab16 	blt	r5,zero,8112429c <___svfprintf_internal_r+0x141c>
811233f0:	00ffdfc4 	movi	r3,-129
811233f4:	a584b03a 	or	r2,r20,r22
811233f8:	90e4703a 	and	r18,r18,r3
811233fc:	10014a26 	beq	r2,zero,81123928 <___svfprintf_internal_r+0xaa8>
81123400:	b0034b26 	beq	r22,zero,81124130 <___svfprintf_internal_r+0x12b0>
81123404:	dc402a15 	stw	r17,168(sp)
81123408:	dc001e04 	addi	r16,sp,120
8112340c:	b023883a 	mov	r17,r22
81123410:	402d883a 	mov	r22,r8
81123414:	a009883a 	mov	r4,r20
81123418:	880b883a 	mov	r5,r17
8112341c:	01800284 	movi	r6,10
81123420:	000f883a 	mov	r7,zero
81123424:	1133f880 	call	81133f88 <__umoddi3>
81123428:	10800c04 	addi	r2,r2,48
8112342c:	843fffc4 	addi	r16,r16,-1
81123430:	a009883a 	mov	r4,r20
81123434:	880b883a 	mov	r5,r17
81123438:	80800005 	stb	r2,0(r16)
8112343c:	01800284 	movi	r6,10
81123440:	000f883a 	mov	r7,zero
81123444:	1133a080 	call	81133a08 <__udivdi3>
81123448:	1029883a 	mov	r20,r2
8112344c:	10c4b03a 	or	r2,r2,r3
81123450:	1823883a 	mov	r17,r3
81123454:	103fef1e 	bne	r2,zero,81123414 <__reset+0xfb103414>
81123458:	d8c02817 	ldw	r3,160(sp)
8112345c:	dc402a17 	ldw	r17,168(sp)
81123460:	b011883a 	mov	r8,r22
81123464:	1c07c83a 	sub	r3,r3,r16
81123468:	d8c02e15 	stw	r3,184(sp)
8112346c:	00002e06 	br	81123528 <___svfprintf_internal_r+0x6a8>
81123470:	18c03fcc 	andi	r3,r3,255
81123474:	1806e71e 	bne	r3,zero,81125014 <___svfprintf_internal_r+0x2194>
81123478:	94800414 	ori	r18,r18,16
8112347c:	9080080c 	andi	r2,r18,32
81123480:	1002d426 	beq	r2,zero,81123fd4 <___svfprintf_internal_r+0x1154>
81123484:	d9402d17 	ldw	r5,180(sp)
81123488:	d8c02917 	ldw	r3,164(sp)
8112348c:	d8002785 	stb	zero,158(sp)
81123490:	28800204 	addi	r2,r5,8
81123494:	2d000017 	ldw	r20,0(r5)
81123498:	2d800117 	ldw	r22,4(r5)
8112349c:	18041516 	blt	r3,zero,811244f4 <___svfprintf_internal_r+0x1674>
811234a0:	013fdfc4 	movi	r4,-129
811234a4:	a586b03a 	or	r3,r20,r22
811234a8:	d8802d15 	stw	r2,180(sp)
811234ac:	9124703a 	and	r18,r18,r4
811234b0:	1802d51e 	bne	r3,zero,81124008 <___svfprintf_internal_r+0x1188>
811234b4:	d9402917 	ldw	r5,164(sp)
811234b8:	0039883a 	mov	fp,zero
811234bc:	2806be26 	beq	r5,zero,81124fb8 <___svfprintf_internal_r+0x2138>
811234c0:	0029883a 	mov	r20,zero
811234c4:	002d883a 	mov	r22,zero
811234c8:	dc001e04 	addi	r16,sp,120
811234cc:	a006d0fa 	srli	r3,r20,3
811234d0:	b008977a 	slli	r4,r22,29
811234d4:	b02cd0fa 	srli	r22,r22,3
811234d8:	a50001cc 	andi	r20,r20,7
811234dc:	a0800c04 	addi	r2,r20,48
811234e0:	843fffc4 	addi	r16,r16,-1
811234e4:	20e8b03a 	or	r20,r4,r3
811234e8:	80800005 	stb	r2,0(r16)
811234ec:	a586b03a 	or	r3,r20,r22
811234f0:	183ff61e 	bne	r3,zero,811234cc <__reset+0xfb1034cc>
811234f4:	90c0004c 	andi	r3,r18,1
811234f8:	18013926 	beq	r3,zero,811239e0 <___svfprintf_internal_r+0xb60>
811234fc:	10803fcc 	andi	r2,r2,255
81123500:	1080201c 	xori	r2,r2,128
81123504:	10bfe004 	addi	r2,r2,-128
81123508:	00c00c04 	movi	r3,48
8112350c:	10c13426 	beq	r2,r3,811239e0 <___svfprintf_internal_r+0xb60>
81123510:	80ffffc5 	stb	r3,-1(r16)
81123514:	d8c02817 	ldw	r3,160(sp)
81123518:	80bfffc4 	addi	r2,r16,-1
8112351c:	1021883a 	mov	r16,r2
81123520:	1887c83a 	sub	r3,r3,r2
81123524:	d8c02e15 	stw	r3,184(sp)
81123528:	d8802e17 	ldw	r2,184(sp)
8112352c:	d9002917 	ldw	r4,164(sp)
81123530:	1100010e 	bge	r2,r4,81123538 <___svfprintf_internal_r+0x6b8>
81123534:	2005883a 	mov	r2,r4
81123538:	d8802a15 	stw	r2,168(sp)
8112353c:	d8003215 	stw	zero,200(sp)
81123540:	e7003fcc 	andi	fp,fp,255
81123544:	e700201c 	xori	fp,fp,128
81123548:	e73fe004 	addi	fp,fp,-128
8112354c:	e0000326 	beq	fp,zero,8112355c <___svfprintf_internal_r+0x6dc>
81123550:	d8c02a17 	ldw	r3,168(sp)
81123554:	18c00044 	addi	r3,r3,1
81123558:	d8c02a15 	stw	r3,168(sp)
8112355c:	90c0008c 	andi	r3,r18,2
81123560:	d8c02b15 	stw	r3,172(sp)
81123564:	18000326 	beq	r3,zero,81123574 <___svfprintf_internal_r+0x6f4>
81123568:	d8c02a17 	ldw	r3,168(sp)
8112356c:	18c00084 	addi	r3,r3,2
81123570:	d8c02a15 	stw	r3,168(sp)
81123574:	90c0210c 	andi	r3,r18,132
81123578:	d8c03015 	stw	r3,192(sp)
8112357c:	1801a11e 	bne	r3,zero,81123c04 <___svfprintf_internal_r+0xd84>
81123580:	d9003117 	ldw	r4,196(sp)
81123584:	d8c02a17 	ldw	r3,168(sp)
81123588:	20e9c83a 	sub	r20,r4,r3
8112358c:	05019d0e 	bge	zero,r20,81123c04 <___svfprintf_internal_r+0xd84>
81123590:	02400404 	movi	r9,16
81123594:	d8c02017 	ldw	r3,128(sp)
81123598:	d8801f17 	ldw	r2,124(sp)
8112359c:	4d051b0e 	bge	r9,r20,81124a0c <___svfprintf_internal_r+0x1b8c>
811235a0:	01604574 	movhi	r5,33045
811235a4:	29411484 	addi	r5,r5,1106
811235a8:	dc403c15 	stw	r17,240(sp)
811235ac:	d9403515 	stw	r5,212(sp)
811235b0:	a023883a 	mov	r17,r20
811235b4:	482d883a 	mov	r22,r9
811235b8:	9029883a 	mov	r20,r18
811235bc:	070001c4 	movi	fp,7
811235c0:	8025883a 	mov	r18,r16
811235c4:	dc002c17 	ldw	r16,176(sp)
811235c8:	00000306 	br	811235d8 <___svfprintf_internal_r+0x758>
811235cc:	8c7ffc04 	addi	r17,r17,-16
811235d0:	42000204 	addi	r8,r8,8
811235d4:	b440130e 	bge	r22,r17,81123624 <___svfprintf_internal_r+0x7a4>
811235d8:	01204574 	movhi	r4,33045
811235dc:	18c00404 	addi	r3,r3,16
811235e0:	10800044 	addi	r2,r2,1
811235e4:	21011484 	addi	r4,r4,1106
811235e8:	41000015 	stw	r4,0(r8)
811235ec:	45800115 	stw	r22,4(r8)
811235f0:	d8c02015 	stw	r3,128(sp)
811235f4:	d8801f15 	stw	r2,124(sp)
811235f8:	e0bff40e 	bge	fp,r2,811235cc <__reset+0xfb1035cc>
811235fc:	d9801e04 	addi	r6,sp,120
81123600:	800b883a 	mov	r5,r16
81123604:	9809883a 	mov	r4,r19
81123608:	112faa00 	call	8112faa0 <__ssprint_r>
8112360c:	103f031e 	bne	r2,zero,8112321c <__reset+0xfb10321c>
81123610:	8c7ffc04 	addi	r17,r17,-16
81123614:	d8c02017 	ldw	r3,128(sp)
81123618:	d8801f17 	ldw	r2,124(sp)
8112361c:	da000404 	addi	r8,sp,16
81123620:	b47fed16 	blt	r22,r17,811235d8 <__reset+0xfb1035d8>
81123624:	9021883a 	mov	r16,r18
81123628:	a025883a 	mov	r18,r20
8112362c:	8829883a 	mov	r20,r17
81123630:	dc403c17 	ldw	r17,240(sp)
81123634:	d9403517 	ldw	r5,212(sp)
81123638:	a0c7883a 	add	r3,r20,r3
8112363c:	10800044 	addi	r2,r2,1
81123640:	41400015 	stw	r5,0(r8)
81123644:	45000115 	stw	r20,4(r8)
81123648:	d8c02015 	stw	r3,128(sp)
8112364c:	d8801f15 	stw	r2,124(sp)
81123650:	010001c4 	movi	r4,7
81123654:	20829f16 	blt	r4,r2,811240d4 <___svfprintf_internal_r+0x1254>
81123658:	df002787 	ldb	fp,158(sp)
8112365c:	42000204 	addi	r8,r8,8
81123660:	e0000c26 	beq	fp,zero,81123694 <___svfprintf_internal_r+0x814>
81123664:	d8801f17 	ldw	r2,124(sp)
81123668:	d9002784 	addi	r4,sp,158
8112366c:	18c00044 	addi	r3,r3,1
81123670:	10800044 	addi	r2,r2,1
81123674:	41000015 	stw	r4,0(r8)
81123678:	01000044 	movi	r4,1
8112367c:	41000115 	stw	r4,4(r8)
81123680:	d8c02015 	stw	r3,128(sp)
81123684:	d8801f15 	stw	r2,124(sp)
81123688:	010001c4 	movi	r4,7
8112368c:	20823816 	blt	r4,r2,81123f70 <___svfprintf_internal_r+0x10f0>
81123690:	42000204 	addi	r8,r8,8
81123694:	d8802b17 	ldw	r2,172(sp)
81123698:	10000c26 	beq	r2,zero,811236cc <___svfprintf_internal_r+0x84c>
8112369c:	d8801f17 	ldw	r2,124(sp)
811236a0:	d9002704 	addi	r4,sp,156
811236a4:	18c00084 	addi	r3,r3,2
811236a8:	10800044 	addi	r2,r2,1
811236ac:	41000015 	stw	r4,0(r8)
811236b0:	01000084 	movi	r4,2
811236b4:	41000115 	stw	r4,4(r8)
811236b8:	d8c02015 	stw	r3,128(sp)
811236bc:	d8801f15 	stw	r2,124(sp)
811236c0:	010001c4 	movi	r4,7
811236c4:	20823216 	blt	r4,r2,81123f90 <___svfprintf_internal_r+0x1110>
811236c8:	42000204 	addi	r8,r8,8
811236cc:	d9003017 	ldw	r4,192(sp)
811236d0:	00802004 	movi	r2,128
811236d4:	20819726 	beq	r4,r2,81123d34 <___svfprintf_internal_r+0xeb4>
811236d8:	d9402917 	ldw	r5,164(sp)
811236dc:	d8802e17 	ldw	r2,184(sp)
811236e0:	28adc83a 	sub	r22,r5,r2
811236e4:	05802f0e 	bge	zero,r22,811237a4 <___svfprintf_internal_r+0x924>
811236e8:	07000404 	movi	fp,16
811236ec:	d8801f17 	ldw	r2,124(sp)
811236f0:	e583c00e 	bge	fp,r22,811245f4 <___svfprintf_internal_r+0x1774>
811236f4:	01604574 	movhi	r5,33045
811236f8:	29411084 	addi	r5,r5,1090
811236fc:	dc402915 	stw	r17,164(sp)
81123700:	d9402b15 	stw	r5,172(sp)
81123704:	b023883a 	mov	r17,r22
81123708:	050001c4 	movi	r20,7
8112370c:	902d883a 	mov	r22,r18
81123710:	8025883a 	mov	r18,r16
81123714:	dc002c17 	ldw	r16,176(sp)
81123718:	00000306 	br	81123728 <___svfprintf_internal_r+0x8a8>
8112371c:	8c7ffc04 	addi	r17,r17,-16
81123720:	42000204 	addi	r8,r8,8
81123724:	e440110e 	bge	fp,r17,8112376c <___svfprintf_internal_r+0x8ec>
81123728:	18c00404 	addi	r3,r3,16
8112372c:	10800044 	addi	r2,r2,1
81123730:	45400015 	stw	r21,0(r8)
81123734:	47000115 	stw	fp,4(r8)
81123738:	d8c02015 	stw	r3,128(sp)
8112373c:	d8801f15 	stw	r2,124(sp)
81123740:	a0bff60e 	bge	r20,r2,8112371c <__reset+0xfb10371c>
81123744:	d9801e04 	addi	r6,sp,120
81123748:	800b883a 	mov	r5,r16
8112374c:	9809883a 	mov	r4,r19
81123750:	112faa00 	call	8112faa0 <__ssprint_r>
81123754:	103eb11e 	bne	r2,zero,8112321c <__reset+0xfb10321c>
81123758:	8c7ffc04 	addi	r17,r17,-16
8112375c:	d8c02017 	ldw	r3,128(sp)
81123760:	d8801f17 	ldw	r2,124(sp)
81123764:	da000404 	addi	r8,sp,16
81123768:	e47fef16 	blt	fp,r17,81123728 <__reset+0xfb103728>
8112376c:	9021883a 	mov	r16,r18
81123770:	b025883a 	mov	r18,r22
81123774:	882d883a 	mov	r22,r17
81123778:	dc402917 	ldw	r17,164(sp)
8112377c:	d9002b17 	ldw	r4,172(sp)
81123780:	1d87883a 	add	r3,r3,r22
81123784:	10800044 	addi	r2,r2,1
81123788:	41000015 	stw	r4,0(r8)
8112378c:	45800115 	stw	r22,4(r8)
81123790:	d8c02015 	stw	r3,128(sp)
81123794:	d8801f15 	stw	r2,124(sp)
81123798:	010001c4 	movi	r4,7
8112379c:	2081ec16 	blt	r4,r2,81123f50 <___svfprintf_internal_r+0x10d0>
811237a0:	42000204 	addi	r8,r8,8
811237a4:	9080400c 	andi	r2,r18,256
811237a8:	1001181e 	bne	r2,zero,81123c0c <___svfprintf_internal_r+0xd8c>
811237ac:	d9402e17 	ldw	r5,184(sp)
811237b0:	d8801f17 	ldw	r2,124(sp)
811237b4:	44000015 	stw	r16,0(r8)
811237b8:	1947883a 	add	r3,r3,r5
811237bc:	10800044 	addi	r2,r2,1
811237c0:	41400115 	stw	r5,4(r8)
811237c4:	d8c02015 	stw	r3,128(sp)
811237c8:	d8801f15 	stw	r2,124(sp)
811237cc:	010001c4 	movi	r4,7
811237d0:	2081d116 	blt	r4,r2,81123f18 <___svfprintf_internal_r+0x1098>
811237d4:	42000204 	addi	r8,r8,8
811237d8:	9480010c 	andi	r18,r18,4
811237dc:	90003226 	beq	r18,zero,811238a8 <___svfprintf_internal_r+0xa28>
811237e0:	d9403117 	ldw	r5,196(sp)
811237e4:	d8802a17 	ldw	r2,168(sp)
811237e8:	28a1c83a 	sub	r16,r5,r2
811237ec:	04002e0e 	bge	zero,r16,811238a8 <___svfprintf_internal_r+0xa28>
811237f0:	04400404 	movi	r17,16
811237f4:	d8801f17 	ldw	r2,124(sp)
811237f8:	8c04b90e 	bge	r17,r16,81124ae0 <___svfprintf_internal_r+0x1c60>
811237fc:	01604574 	movhi	r5,33045
81123800:	29411484 	addi	r5,r5,1106
81123804:	d9403515 	stw	r5,212(sp)
81123808:	048001c4 	movi	r18,7
8112380c:	dd002c17 	ldw	r20,176(sp)
81123810:	00000306 	br	81123820 <___svfprintf_internal_r+0x9a0>
81123814:	843ffc04 	addi	r16,r16,-16
81123818:	42000204 	addi	r8,r8,8
8112381c:	8c00130e 	bge	r17,r16,8112386c <___svfprintf_internal_r+0x9ec>
81123820:	01204574 	movhi	r4,33045
81123824:	18c00404 	addi	r3,r3,16
81123828:	10800044 	addi	r2,r2,1
8112382c:	21011484 	addi	r4,r4,1106
81123830:	41000015 	stw	r4,0(r8)
81123834:	44400115 	stw	r17,4(r8)
81123838:	d8c02015 	stw	r3,128(sp)
8112383c:	d8801f15 	stw	r2,124(sp)
81123840:	90bff40e 	bge	r18,r2,81123814 <__reset+0xfb103814>
81123844:	d9801e04 	addi	r6,sp,120
81123848:	a00b883a 	mov	r5,r20
8112384c:	9809883a 	mov	r4,r19
81123850:	112faa00 	call	8112faa0 <__ssprint_r>
81123854:	103e711e 	bne	r2,zero,8112321c <__reset+0xfb10321c>
81123858:	843ffc04 	addi	r16,r16,-16
8112385c:	d8c02017 	ldw	r3,128(sp)
81123860:	d8801f17 	ldw	r2,124(sp)
81123864:	da000404 	addi	r8,sp,16
81123868:	8c3fed16 	blt	r17,r16,81123820 <__reset+0xfb103820>
8112386c:	d9403517 	ldw	r5,212(sp)
81123870:	1c07883a 	add	r3,r3,r16
81123874:	10800044 	addi	r2,r2,1
81123878:	41400015 	stw	r5,0(r8)
8112387c:	44000115 	stw	r16,4(r8)
81123880:	d8c02015 	stw	r3,128(sp)
81123884:	d8801f15 	stw	r2,124(sp)
81123888:	010001c4 	movi	r4,7
8112388c:	2080060e 	bge	r4,r2,811238a8 <___svfprintf_internal_r+0xa28>
81123890:	d9402c17 	ldw	r5,176(sp)
81123894:	d9801e04 	addi	r6,sp,120
81123898:	9809883a 	mov	r4,r19
8112389c:	112faa00 	call	8112faa0 <__ssprint_r>
811238a0:	103e5e1e 	bne	r2,zero,8112321c <__reset+0xfb10321c>
811238a4:	d8c02017 	ldw	r3,128(sp)
811238a8:	d8803117 	ldw	r2,196(sp)
811238ac:	d9002a17 	ldw	r4,168(sp)
811238b0:	1100010e 	bge	r2,r4,811238b8 <___svfprintf_internal_r+0xa38>
811238b4:	2005883a 	mov	r2,r4
811238b8:	d9402f17 	ldw	r5,188(sp)
811238bc:	288b883a 	add	r5,r5,r2
811238c0:	d9402f15 	stw	r5,188(sp)
811238c4:	18019c1e 	bne	r3,zero,81123f38 <___svfprintf_internal_r+0x10b8>
811238c8:	b8800007 	ldb	r2,0(r23)
811238cc:	d8001f15 	stw	zero,124(sp)
811238d0:	da000404 	addi	r8,sp,16
811238d4:	103d991e 	bne	r2,zero,81122f3c <__reset+0xfb102f3c>
811238d8:	b821883a 	mov	r16,r23
811238dc:	003daf06 	br	81122f9c <__reset+0xfb102f9c>
811238e0:	18c03fcc 	andi	r3,r3,255
811238e4:	1805c71e 	bne	r3,zero,81125004 <___svfprintf_internal_r+0x2184>
811238e8:	94800414 	ori	r18,r18,16
811238ec:	9080080c 	andi	r2,r18,32
811238f0:	10020126 	beq	r2,zero,811240f8 <___svfprintf_internal_r+0x1278>
811238f4:	d8802d17 	ldw	r2,180(sp)
811238f8:	d9002917 	ldw	r4,164(sp)
811238fc:	d8002785 	stb	zero,158(sp)
81123900:	10c00204 	addi	r3,r2,8
81123904:	15000017 	ldw	r20,0(r2)
81123908:	15800117 	ldw	r22,4(r2)
8112390c:	20038e16 	blt	r4,zero,81124748 <___svfprintf_internal_r+0x18c8>
81123910:	013fdfc4 	movi	r4,-129
81123914:	a584b03a 	or	r2,r20,r22
81123918:	d8c02d15 	stw	r3,180(sp)
8112391c:	9124703a 	and	r18,r18,r4
81123920:	0039883a 	mov	fp,zero
81123924:	103eb61e 	bne	r2,zero,81123400 <__reset+0xfb103400>
81123928:	d8802917 	ldw	r2,164(sp)
8112392c:	1002c81e 	bne	r2,zero,81124450 <___svfprintf_internal_r+0x15d0>
81123930:	d8002915 	stw	zero,164(sp)
81123934:	d8002e15 	stw	zero,184(sp)
81123938:	dc001e04 	addi	r16,sp,120
8112393c:	003efa06 	br	81123528 <__reset+0xfb103528>
81123940:	18c03fcc 	andi	r3,r3,255
81123944:	1805ad1e 	bne	r3,zero,81124ffc <___svfprintf_internal_r+0x217c>
81123948:	01604574 	movhi	r5,33045
8112394c:	29410404 	addi	r5,r5,1040
81123950:	d9403a15 	stw	r5,232(sp)
81123954:	9080080c 	andi	r2,r18,32
81123958:	10006126 	beq	r2,zero,81123ae0 <___svfprintf_internal_r+0xc60>
8112395c:	d8802d17 	ldw	r2,180(sp)
81123960:	15000017 	ldw	r20,0(r2)
81123964:	15800117 	ldw	r22,4(r2)
81123968:	10800204 	addi	r2,r2,8
8112396c:	d8802d15 	stw	r2,180(sp)
81123970:	9080004c 	andi	r2,r18,1
81123974:	10018e26 	beq	r2,zero,81123fb0 <___svfprintf_internal_r+0x1130>
81123978:	a584b03a 	or	r2,r20,r22
8112397c:	10030926 	beq	r2,zero,811245a4 <___svfprintf_internal_r+0x1724>
81123980:	d8c02917 	ldw	r3,164(sp)
81123984:	00800c04 	movi	r2,48
81123988:	d8802705 	stb	r2,156(sp)
8112398c:	dc402745 	stb	r17,157(sp)
81123990:	d8002785 	stb	zero,158(sp)
81123994:	90800094 	ori	r2,r18,2
81123998:	18048716 	blt	r3,zero,81124bb8 <___svfprintf_internal_r+0x1d38>
8112399c:	00bfdfc4 	movi	r2,-129
811239a0:	90a4703a 	and	r18,r18,r2
811239a4:	94800094 	ori	r18,r18,2
811239a8:	0039883a 	mov	fp,zero
811239ac:	d9003a17 	ldw	r4,232(sp)
811239b0:	dc001e04 	addi	r16,sp,120
811239b4:	a08003cc 	andi	r2,r20,15
811239b8:	b006973a 	slli	r3,r22,28
811239bc:	2085883a 	add	r2,r4,r2
811239c0:	a028d13a 	srli	r20,r20,4
811239c4:	10800003 	ldbu	r2,0(r2)
811239c8:	b02cd13a 	srli	r22,r22,4
811239cc:	843fffc4 	addi	r16,r16,-1
811239d0:	1d28b03a 	or	r20,r3,r20
811239d4:	80800005 	stb	r2,0(r16)
811239d8:	a584b03a 	or	r2,r20,r22
811239dc:	103ff51e 	bne	r2,zero,811239b4 <__reset+0xfb1039b4>
811239e0:	d8c02817 	ldw	r3,160(sp)
811239e4:	1c07c83a 	sub	r3,r3,r16
811239e8:	d8c02e15 	stw	r3,184(sp)
811239ec:	003ece06 	br	81123528 <__reset+0xfb103528>
811239f0:	d8c02d17 	ldw	r3,180(sp)
811239f4:	d9002d17 	ldw	r4,180(sp)
811239f8:	d8002785 	stb	zero,158(sp)
811239fc:	18800017 	ldw	r2,0(r3)
81123a00:	21000104 	addi	r4,r4,4
81123a04:	00c00044 	movi	r3,1
81123a08:	d8c02a15 	stw	r3,168(sp)
81123a0c:	d8801405 	stb	r2,80(sp)
81123a10:	d9002d15 	stw	r4,180(sp)
81123a14:	d8c02e15 	stw	r3,184(sp)
81123a18:	d8002915 	stw	zero,164(sp)
81123a1c:	d8003215 	stw	zero,200(sp)
81123a20:	dc001404 	addi	r16,sp,80
81123a24:	0039883a 	mov	fp,zero
81123a28:	003ecc06 	br	8112355c <__reset+0xfb10355c>
81123a2c:	18c03fcc 	andi	r3,r3,255
81123a30:	183e9226 	beq	r3,zero,8112347c <__reset+0xfb10347c>
81123a34:	d9c02785 	stb	r7,158(sp)
81123a38:	003e9006 	br	8112347c <__reset+0xfb10347c>
81123a3c:	00c00044 	movi	r3,1
81123a40:	01c00ac4 	movi	r7,43
81123a44:	bc400007 	ldb	r17,0(r23)
81123a48:	003d6306 	br	81122fd8 <__reset+0xfb102fd8>
81123a4c:	94800814 	ori	r18,r18,32
81123a50:	bc400007 	ldb	r17,0(r23)
81123a54:	003d6006 	br	81122fd8 <__reset+0xfb102fd8>
81123a58:	d8c02d17 	ldw	r3,180(sp)
81123a5c:	d8002785 	stb	zero,158(sp)
81123a60:	1c000017 	ldw	r16,0(r3)
81123a64:	1d000104 	addi	r20,r3,4
81123a68:	80040f26 	beq	r16,zero,81124aa8 <___svfprintf_internal_r+0x1c28>
81123a6c:	d9002917 	ldw	r4,164(sp)
81123a70:	2003dc16 	blt	r4,zero,811249e4 <___svfprintf_internal_r+0x1b64>
81123a74:	200d883a 	mov	r6,r4
81123a78:	000b883a 	mov	r5,zero
81123a7c:	8009883a 	mov	r4,r16
81123a80:	da003e15 	stw	r8,248(sp)
81123a84:	112c0440 	call	8112c044 <memchr>
81123a88:	da003e17 	ldw	r8,248(sp)
81123a8c:	10045826 	beq	r2,zero,81124bf0 <___svfprintf_internal_r+0x1d70>
81123a90:	1405c83a 	sub	r2,r2,r16
81123a94:	d8802e15 	stw	r2,184(sp)
81123a98:	1003d816 	blt	r2,zero,811249fc <___svfprintf_internal_r+0x1b7c>
81123a9c:	df002783 	ldbu	fp,158(sp)
81123aa0:	d8802a15 	stw	r2,168(sp)
81123aa4:	dd002d15 	stw	r20,180(sp)
81123aa8:	d8002915 	stw	zero,164(sp)
81123aac:	d8003215 	stw	zero,200(sp)
81123ab0:	003ea306 	br	81123540 <__reset+0xfb103540>
81123ab4:	18c03fcc 	andi	r3,r3,255
81123ab8:	183f8c26 	beq	r3,zero,811238ec <__reset+0xfb1038ec>
81123abc:	d9c02785 	stb	r7,158(sp)
81123ac0:	003f8a06 	br	811238ec <__reset+0xfb1038ec>
81123ac4:	18c03fcc 	andi	r3,r3,255
81123ac8:	1805631e 	bne	r3,zero,81125058 <___svfprintf_internal_r+0x21d8>
81123acc:	01604574 	movhi	r5,33045
81123ad0:	29410904 	addi	r5,r5,1060
81123ad4:	d9403a15 	stw	r5,232(sp)
81123ad8:	9080080c 	andi	r2,r18,32
81123adc:	103f9f1e 	bne	r2,zero,8112395c <__reset+0xfb10395c>
81123ae0:	9080040c 	andi	r2,r18,16
81123ae4:	10029c26 	beq	r2,zero,81124558 <___svfprintf_internal_r+0x16d8>
81123ae8:	d8c02d17 	ldw	r3,180(sp)
81123aec:	002d883a 	mov	r22,zero
81123af0:	1d000017 	ldw	r20,0(r3)
81123af4:	18c00104 	addi	r3,r3,4
81123af8:	d8c02d15 	stw	r3,180(sp)
81123afc:	003f9c06 	br	81123970 <__reset+0xfb103970>
81123b00:	94800054 	ori	r18,r18,1
81123b04:	bc400007 	ldb	r17,0(r23)
81123b08:	003d3306 	br	81122fd8 <__reset+0xfb102fd8>
81123b0c:	38803fcc 	andi	r2,r7,255
81123b10:	1080201c 	xori	r2,r2,128
81123b14:	10bfe004 	addi	r2,r2,-128
81123b18:	1002971e 	bne	r2,zero,81124578 <___svfprintf_internal_r+0x16f8>
81123b1c:	00c00044 	movi	r3,1
81123b20:	01c00804 	movi	r7,32
81123b24:	bc400007 	ldb	r17,0(r23)
81123b28:	003d2b06 	br	81122fd8 <__reset+0xfb102fd8>
81123b2c:	18c03fcc 	andi	r3,r3,255
81123b30:	183e2326 	beq	r3,zero,811233c0 <__reset+0xfb1033c0>
81123b34:	d9c02785 	stb	r7,158(sp)
81123b38:	003e2106 	br	811233c0 <__reset+0xfb1033c0>
81123b3c:	bc400007 	ldb	r17,0(r23)
81123b40:	8a430426 	beq	r17,r9,81124754 <___svfprintf_internal_r+0x18d4>
81123b44:	94800414 	ori	r18,r18,16
81123b48:	003d2306 	br	81122fd8 <__reset+0xfb102fd8>
81123b4c:	18c03fcc 	andi	r3,r3,255
81123b50:	18053f1e 	bne	r3,zero,81125050 <___svfprintf_internal_r+0x21d0>
81123b54:	9080080c 	andi	r2,r18,32
81123b58:	10028926 	beq	r2,zero,81124580 <___svfprintf_internal_r+0x1700>
81123b5c:	d9402d17 	ldw	r5,180(sp)
81123b60:	d9002f17 	ldw	r4,188(sp)
81123b64:	28800017 	ldw	r2,0(r5)
81123b68:	2007d7fa 	srai	r3,r4,31
81123b6c:	29400104 	addi	r5,r5,4
81123b70:	d9402d15 	stw	r5,180(sp)
81123b74:	11000015 	stw	r4,0(r2)
81123b78:	10c00115 	stw	r3,4(r2)
81123b7c:	003ced06 	br	81122f34 <__reset+0xfb102f34>
81123b80:	94801014 	ori	r18,r18,64
81123b84:	bc400007 	ldb	r17,0(r23)
81123b88:	003d1306 	br	81122fd8 <__reset+0xfb102fd8>
81123b8c:	01204574 	movhi	r4,33045
81123b90:	21010904 	addi	r4,r4,1060
81123b94:	0039883a 	mov	fp,zero
81123b98:	d9003a15 	stw	r4,232(sp)
81123b9c:	04401e04 	movi	r17,120
81123ba0:	003f8206 	br	811239ac <__reset+0xfb1039ac>
81123ba4:	18c03fcc 	andi	r3,r3,255
81123ba8:	1805221e 	bne	r3,zero,81125034 <___svfprintf_internal_r+0x21b4>
81123bac:	883d9526 	beq	r17,zero,81123204 <__reset+0xfb103204>
81123bb0:	00c00044 	movi	r3,1
81123bb4:	d8c02a15 	stw	r3,168(sp)
81123bb8:	dc401405 	stb	r17,80(sp)
81123bbc:	d8002785 	stb	zero,158(sp)
81123bc0:	003f9406 	br	81123a14 <__reset+0xfb103a14>
81123bc4:	01204574 	movhi	r4,33045
81123bc8:	21010904 	addi	r4,r4,1060
81123bcc:	d9003a15 	stw	r4,232(sp)
81123bd0:	d8c02d15 	stw	r3,180(sp)
81123bd4:	1025883a 	mov	r18,r2
81123bd8:	04401e04 	movi	r17,120
81123bdc:	a584b03a 	or	r2,r20,r22
81123be0:	1000fa1e 	bne	r2,zero,81123fcc <___svfprintf_internal_r+0x114c>
81123be4:	0039883a 	mov	fp,zero
81123be8:	00800084 	movi	r2,2
81123bec:	10803fcc 	andi	r2,r2,255
81123bf0:	00c00044 	movi	r3,1
81123bf4:	10c21626 	beq	r2,r3,81124450 <___svfprintf_internal_r+0x15d0>
81123bf8:	00c00084 	movi	r3,2
81123bfc:	10fe301e 	bne	r2,r3,811234c0 <__reset+0xfb1034c0>
81123c00:	003d7606 	br	811231dc <__reset+0xfb1031dc>
81123c04:	d8c02017 	ldw	r3,128(sp)
81123c08:	003e9506 	br	81123660 <__reset+0xfb103660>
81123c0c:	00801944 	movi	r2,101
81123c10:	14407c0e 	bge	r2,r17,81123e04 <___svfprintf_internal_r+0xf84>
81123c14:	d9003617 	ldw	r4,216(sp)
81123c18:	d9403717 	ldw	r5,220(sp)
81123c1c:	000d883a 	mov	r6,zero
81123c20:	000f883a 	mov	r7,zero
81123c24:	d8c03d15 	stw	r3,244(sp)
81123c28:	da003e15 	stw	r8,248(sp)
81123c2c:	1135a1c0 	call	81135a1c <__eqdf2>
81123c30:	d8c03d17 	ldw	r3,244(sp)
81123c34:	da003e17 	ldw	r8,248(sp)
81123c38:	1000f51e 	bne	r2,zero,81124010 <___svfprintf_internal_r+0x1190>
81123c3c:	d8801f17 	ldw	r2,124(sp)
81123c40:	01204574 	movhi	r4,33045
81123c44:	21011004 	addi	r4,r4,1088
81123c48:	18c00044 	addi	r3,r3,1
81123c4c:	10800044 	addi	r2,r2,1
81123c50:	41000015 	stw	r4,0(r8)
81123c54:	01000044 	movi	r4,1
81123c58:	41000115 	stw	r4,4(r8)
81123c5c:	d8c02015 	stw	r3,128(sp)
81123c60:	d8801f15 	stw	r2,124(sp)
81123c64:	010001c4 	movi	r4,7
81123c68:	20826616 	blt	r4,r2,81124604 <___svfprintf_internal_r+0x1784>
81123c6c:	42000204 	addi	r8,r8,8
81123c70:	d8802617 	ldw	r2,152(sp)
81123c74:	d9403317 	ldw	r5,204(sp)
81123c78:	11400216 	blt	r2,r5,81123c84 <___svfprintf_internal_r+0xe04>
81123c7c:	9080004c 	andi	r2,r18,1
81123c80:	103ed526 	beq	r2,zero,811237d8 <__reset+0xfb1037d8>
81123c84:	d8803817 	ldw	r2,224(sp)
81123c88:	d9003417 	ldw	r4,208(sp)
81123c8c:	d9403817 	ldw	r5,224(sp)
81123c90:	1887883a 	add	r3,r3,r2
81123c94:	d8801f17 	ldw	r2,124(sp)
81123c98:	41000015 	stw	r4,0(r8)
81123c9c:	41400115 	stw	r5,4(r8)
81123ca0:	10800044 	addi	r2,r2,1
81123ca4:	d8c02015 	stw	r3,128(sp)
81123ca8:	d8801f15 	stw	r2,124(sp)
81123cac:	010001c4 	movi	r4,7
81123cb0:	2082af16 	blt	r4,r2,81124770 <___svfprintf_internal_r+0x18f0>
81123cb4:	42000204 	addi	r8,r8,8
81123cb8:	d8803317 	ldw	r2,204(sp)
81123cbc:	143fffc4 	addi	r16,r2,-1
81123cc0:	043ec50e 	bge	zero,r16,811237d8 <__reset+0xfb1037d8>
81123cc4:	04400404 	movi	r17,16
81123cc8:	d8801f17 	ldw	r2,124(sp)
81123ccc:	8c00860e 	bge	r17,r16,81123ee8 <___svfprintf_internal_r+0x1068>
81123cd0:	01604574 	movhi	r5,33045
81123cd4:	29411084 	addi	r5,r5,1090
81123cd8:	d9402b15 	stw	r5,172(sp)
81123cdc:	058001c4 	movi	r22,7
81123ce0:	dd002c17 	ldw	r20,176(sp)
81123ce4:	00000306 	br	81123cf4 <___svfprintf_internal_r+0xe74>
81123ce8:	42000204 	addi	r8,r8,8
81123cec:	843ffc04 	addi	r16,r16,-16
81123cf0:	8c00800e 	bge	r17,r16,81123ef4 <___svfprintf_internal_r+0x1074>
81123cf4:	18c00404 	addi	r3,r3,16
81123cf8:	10800044 	addi	r2,r2,1
81123cfc:	45400015 	stw	r21,0(r8)
81123d00:	44400115 	stw	r17,4(r8)
81123d04:	d8c02015 	stw	r3,128(sp)
81123d08:	d8801f15 	stw	r2,124(sp)
81123d0c:	b0bff60e 	bge	r22,r2,81123ce8 <__reset+0xfb103ce8>
81123d10:	d9801e04 	addi	r6,sp,120
81123d14:	a00b883a 	mov	r5,r20
81123d18:	9809883a 	mov	r4,r19
81123d1c:	112faa00 	call	8112faa0 <__ssprint_r>
81123d20:	103d3e1e 	bne	r2,zero,8112321c <__reset+0xfb10321c>
81123d24:	d8c02017 	ldw	r3,128(sp)
81123d28:	d8801f17 	ldw	r2,124(sp)
81123d2c:	da000404 	addi	r8,sp,16
81123d30:	003fee06 	br	81123cec <__reset+0xfb103cec>
81123d34:	d9403117 	ldw	r5,196(sp)
81123d38:	d8802a17 	ldw	r2,168(sp)
81123d3c:	28adc83a 	sub	r22,r5,r2
81123d40:	05be650e 	bge	zero,r22,811236d8 <__reset+0xfb1036d8>
81123d44:	07000404 	movi	fp,16
81123d48:	d8801f17 	ldw	r2,124(sp)
81123d4c:	e583a20e 	bge	fp,r22,81124bd8 <___svfprintf_internal_r+0x1d58>
81123d50:	01604574 	movhi	r5,33045
81123d54:	29411084 	addi	r5,r5,1090
81123d58:	dc403015 	stw	r17,192(sp)
81123d5c:	d9402b15 	stw	r5,172(sp)
81123d60:	b023883a 	mov	r17,r22
81123d64:	050001c4 	movi	r20,7
81123d68:	902d883a 	mov	r22,r18
81123d6c:	8025883a 	mov	r18,r16
81123d70:	dc002c17 	ldw	r16,176(sp)
81123d74:	00000306 	br	81123d84 <___svfprintf_internal_r+0xf04>
81123d78:	8c7ffc04 	addi	r17,r17,-16
81123d7c:	42000204 	addi	r8,r8,8
81123d80:	e440110e 	bge	fp,r17,81123dc8 <___svfprintf_internal_r+0xf48>
81123d84:	18c00404 	addi	r3,r3,16
81123d88:	10800044 	addi	r2,r2,1
81123d8c:	45400015 	stw	r21,0(r8)
81123d90:	47000115 	stw	fp,4(r8)
81123d94:	d8c02015 	stw	r3,128(sp)
81123d98:	d8801f15 	stw	r2,124(sp)
81123d9c:	a0bff60e 	bge	r20,r2,81123d78 <__reset+0xfb103d78>
81123da0:	d9801e04 	addi	r6,sp,120
81123da4:	800b883a 	mov	r5,r16
81123da8:	9809883a 	mov	r4,r19
81123dac:	112faa00 	call	8112faa0 <__ssprint_r>
81123db0:	103d1a1e 	bne	r2,zero,8112321c <__reset+0xfb10321c>
81123db4:	8c7ffc04 	addi	r17,r17,-16
81123db8:	d8c02017 	ldw	r3,128(sp)
81123dbc:	d8801f17 	ldw	r2,124(sp)
81123dc0:	da000404 	addi	r8,sp,16
81123dc4:	e47fef16 	blt	fp,r17,81123d84 <__reset+0xfb103d84>
81123dc8:	9021883a 	mov	r16,r18
81123dcc:	b025883a 	mov	r18,r22
81123dd0:	882d883a 	mov	r22,r17
81123dd4:	dc403017 	ldw	r17,192(sp)
81123dd8:	d9002b17 	ldw	r4,172(sp)
81123ddc:	1d87883a 	add	r3,r3,r22
81123de0:	10800044 	addi	r2,r2,1
81123de4:	41000015 	stw	r4,0(r8)
81123de8:	45800115 	stw	r22,4(r8)
81123dec:	d8c02015 	stw	r3,128(sp)
81123df0:	d8801f15 	stw	r2,124(sp)
81123df4:	010001c4 	movi	r4,7
81123df8:	20819a16 	blt	r4,r2,81124464 <___svfprintf_internal_r+0x15e4>
81123dfc:	42000204 	addi	r8,r8,8
81123e00:	003e3506 	br	811236d8 <__reset+0xfb1036d8>
81123e04:	d9403317 	ldw	r5,204(sp)
81123e08:	00800044 	movi	r2,1
81123e0c:	18c00044 	addi	r3,r3,1
81123e10:	1141710e 	bge	r2,r5,811243d8 <___svfprintf_internal_r+0x1558>
81123e14:	dc401f17 	ldw	r17,124(sp)
81123e18:	00800044 	movi	r2,1
81123e1c:	40800115 	stw	r2,4(r8)
81123e20:	8c400044 	addi	r17,r17,1
81123e24:	44000015 	stw	r16,0(r8)
81123e28:	d8c02015 	stw	r3,128(sp)
81123e2c:	dc401f15 	stw	r17,124(sp)
81123e30:	008001c4 	movi	r2,7
81123e34:	14417416 	blt	r2,r17,81124408 <___svfprintf_internal_r+0x1588>
81123e38:	42000204 	addi	r8,r8,8
81123e3c:	d8803817 	ldw	r2,224(sp)
81123e40:	d9003417 	ldw	r4,208(sp)
81123e44:	8c400044 	addi	r17,r17,1
81123e48:	10c7883a 	add	r3,r2,r3
81123e4c:	40800115 	stw	r2,4(r8)
81123e50:	41000015 	stw	r4,0(r8)
81123e54:	d8c02015 	stw	r3,128(sp)
81123e58:	dc401f15 	stw	r17,124(sp)
81123e5c:	008001c4 	movi	r2,7
81123e60:	14417216 	blt	r2,r17,8112442c <___svfprintf_internal_r+0x15ac>
81123e64:	45800204 	addi	r22,r8,8
81123e68:	d9003617 	ldw	r4,216(sp)
81123e6c:	d9403717 	ldw	r5,220(sp)
81123e70:	000d883a 	mov	r6,zero
81123e74:	000f883a 	mov	r7,zero
81123e78:	d8c03d15 	stw	r3,244(sp)
81123e7c:	1135a1c0 	call	81135a1c <__eqdf2>
81123e80:	d8c03d17 	ldw	r3,244(sp)
81123e84:	1000b326 	beq	r2,zero,81124154 <___svfprintf_internal_r+0x12d4>
81123e88:	d9403317 	ldw	r5,204(sp)
81123e8c:	84000044 	addi	r16,r16,1
81123e90:	8c400044 	addi	r17,r17,1
81123e94:	28bfffc4 	addi	r2,r5,-1
81123e98:	1887883a 	add	r3,r3,r2
81123e9c:	b0800115 	stw	r2,4(r22)
81123ea0:	b4000015 	stw	r16,0(r22)
81123ea4:	d8c02015 	stw	r3,128(sp)
81123ea8:	dc401f15 	stw	r17,124(sp)
81123eac:	008001c4 	movi	r2,7
81123eb0:	1440d216 	blt	r2,r17,811241fc <___svfprintf_internal_r+0x137c>
81123eb4:	b5800204 	addi	r22,r22,8
81123eb8:	d9003b17 	ldw	r4,236(sp)
81123ebc:	df0022c4 	addi	fp,sp,139
81123ec0:	8c400044 	addi	r17,r17,1
81123ec4:	20c7883a 	add	r3,r4,r3
81123ec8:	b7000015 	stw	fp,0(r22)
81123ecc:	b1000115 	stw	r4,4(r22)
81123ed0:	d8c02015 	stw	r3,128(sp)
81123ed4:	dc401f15 	stw	r17,124(sp)
81123ed8:	008001c4 	movi	r2,7
81123edc:	14400e16 	blt	r2,r17,81123f18 <___svfprintf_internal_r+0x1098>
81123ee0:	b2000204 	addi	r8,r22,8
81123ee4:	003e3c06 	br	811237d8 <__reset+0xfb1037d8>
81123ee8:	01204574 	movhi	r4,33045
81123eec:	21011084 	addi	r4,r4,1090
81123ef0:	d9002b15 	stw	r4,172(sp)
81123ef4:	d9002b17 	ldw	r4,172(sp)
81123ef8:	1c07883a 	add	r3,r3,r16
81123efc:	44000115 	stw	r16,4(r8)
81123f00:	41000015 	stw	r4,0(r8)
81123f04:	10800044 	addi	r2,r2,1
81123f08:	d8c02015 	stw	r3,128(sp)
81123f0c:	d8801f15 	stw	r2,124(sp)
81123f10:	010001c4 	movi	r4,7
81123f14:	20be2f0e 	bge	r4,r2,811237d4 <__reset+0xfb1037d4>
81123f18:	d9402c17 	ldw	r5,176(sp)
81123f1c:	d9801e04 	addi	r6,sp,120
81123f20:	9809883a 	mov	r4,r19
81123f24:	112faa00 	call	8112faa0 <__ssprint_r>
81123f28:	103cbc1e 	bne	r2,zero,8112321c <__reset+0xfb10321c>
81123f2c:	d8c02017 	ldw	r3,128(sp)
81123f30:	da000404 	addi	r8,sp,16
81123f34:	003e2806 	br	811237d8 <__reset+0xfb1037d8>
81123f38:	d9402c17 	ldw	r5,176(sp)
81123f3c:	d9801e04 	addi	r6,sp,120
81123f40:	9809883a 	mov	r4,r19
81123f44:	112faa00 	call	8112faa0 <__ssprint_r>
81123f48:	103e5f26 	beq	r2,zero,811238c8 <__reset+0xfb1038c8>
81123f4c:	003cb306 	br	8112321c <__reset+0xfb10321c>
81123f50:	d9402c17 	ldw	r5,176(sp)
81123f54:	d9801e04 	addi	r6,sp,120
81123f58:	9809883a 	mov	r4,r19
81123f5c:	112faa00 	call	8112faa0 <__ssprint_r>
81123f60:	103cae1e 	bne	r2,zero,8112321c <__reset+0xfb10321c>
81123f64:	d8c02017 	ldw	r3,128(sp)
81123f68:	da000404 	addi	r8,sp,16
81123f6c:	003e0d06 	br	811237a4 <__reset+0xfb1037a4>
81123f70:	d9402c17 	ldw	r5,176(sp)
81123f74:	d9801e04 	addi	r6,sp,120
81123f78:	9809883a 	mov	r4,r19
81123f7c:	112faa00 	call	8112faa0 <__ssprint_r>
81123f80:	103ca61e 	bne	r2,zero,8112321c <__reset+0xfb10321c>
81123f84:	d8c02017 	ldw	r3,128(sp)
81123f88:	da000404 	addi	r8,sp,16
81123f8c:	003dc106 	br	81123694 <__reset+0xfb103694>
81123f90:	d9402c17 	ldw	r5,176(sp)
81123f94:	d9801e04 	addi	r6,sp,120
81123f98:	9809883a 	mov	r4,r19
81123f9c:	112faa00 	call	8112faa0 <__ssprint_r>
81123fa0:	103c9e1e 	bne	r2,zero,8112321c <__reset+0xfb10321c>
81123fa4:	d8c02017 	ldw	r3,128(sp)
81123fa8:	da000404 	addi	r8,sp,16
81123fac:	003dc706 	br	811236cc <__reset+0xfb1036cc>
81123fb0:	d8802917 	ldw	r2,164(sp)
81123fb4:	d8002785 	stb	zero,158(sp)
81123fb8:	103f0816 	blt	r2,zero,81123bdc <__reset+0xfb103bdc>
81123fbc:	00ffdfc4 	movi	r3,-129
81123fc0:	a584b03a 	or	r2,r20,r22
81123fc4:	90e4703a 	and	r18,r18,r3
81123fc8:	103c8126 	beq	r2,zero,811231d0 <__reset+0xfb1031d0>
81123fcc:	0039883a 	mov	fp,zero
81123fd0:	003e7606 	br	811239ac <__reset+0xfb1039ac>
81123fd4:	9080040c 	andi	r2,r18,16
81123fd8:	10013d26 	beq	r2,zero,811244d0 <___svfprintf_internal_r+0x1650>
81123fdc:	d9002d17 	ldw	r4,180(sp)
81123fe0:	d9402917 	ldw	r5,164(sp)
81123fe4:	d8002785 	stb	zero,158(sp)
81123fe8:	20800104 	addi	r2,r4,4
81123fec:	25000017 	ldw	r20,0(r4)
81123ff0:	002d883a 	mov	r22,zero
81123ff4:	28013f16 	blt	r5,zero,811244f4 <___svfprintf_internal_r+0x1674>
81123ff8:	00ffdfc4 	movi	r3,-129
81123ffc:	d8802d15 	stw	r2,180(sp)
81124000:	90e4703a 	and	r18,r18,r3
81124004:	a03d2b26 	beq	r20,zero,811234b4 <__reset+0xfb1034b4>
81124008:	0039883a 	mov	fp,zero
8112400c:	003d2e06 	br	811234c8 <__reset+0xfb1034c8>
81124010:	dc402617 	ldw	r17,152(sp)
81124014:	0441830e 	bge	zero,r17,81124624 <___svfprintf_internal_r+0x17a4>
81124018:	dc403217 	ldw	r17,200(sp)
8112401c:	d8803317 	ldw	r2,204(sp)
81124020:	1440010e 	bge	r2,r17,81124028 <___svfprintf_internal_r+0x11a8>
81124024:	1023883a 	mov	r17,r2
81124028:	04400a0e 	bge	zero,r17,81124054 <___svfprintf_internal_r+0x11d4>
8112402c:	d8801f17 	ldw	r2,124(sp)
81124030:	1c47883a 	add	r3,r3,r17
81124034:	44000015 	stw	r16,0(r8)
81124038:	10800044 	addi	r2,r2,1
8112403c:	44400115 	stw	r17,4(r8)
81124040:	d8c02015 	stw	r3,128(sp)
81124044:	d8801f15 	stw	r2,124(sp)
81124048:	010001c4 	movi	r4,7
8112404c:	20827516 	blt	r4,r2,81124a24 <___svfprintf_internal_r+0x1ba4>
81124050:	42000204 	addi	r8,r8,8
81124054:	88027b16 	blt	r17,zero,81124a44 <___svfprintf_internal_r+0x1bc4>
81124058:	d9003217 	ldw	r4,200(sp)
8112405c:	2463c83a 	sub	r17,r4,r17
81124060:	0440990e 	bge	zero,r17,811242c8 <___svfprintf_internal_r+0x1448>
81124064:	05800404 	movi	r22,16
81124068:	d8801f17 	ldw	r2,124(sp)
8112406c:	b441530e 	bge	r22,r17,811245bc <___svfprintf_internal_r+0x173c>
81124070:	01204574 	movhi	r4,33045
81124074:	21011084 	addi	r4,r4,1090
81124078:	d9002b15 	stw	r4,172(sp)
8112407c:	070001c4 	movi	fp,7
81124080:	dd002c17 	ldw	r20,176(sp)
81124084:	00000306 	br	81124094 <___svfprintf_internal_r+0x1214>
81124088:	42000204 	addi	r8,r8,8
8112408c:	8c7ffc04 	addi	r17,r17,-16
81124090:	b4414d0e 	bge	r22,r17,811245c8 <___svfprintf_internal_r+0x1748>
81124094:	18c00404 	addi	r3,r3,16
81124098:	10800044 	addi	r2,r2,1
8112409c:	45400015 	stw	r21,0(r8)
811240a0:	45800115 	stw	r22,4(r8)
811240a4:	d8c02015 	stw	r3,128(sp)
811240a8:	d8801f15 	stw	r2,124(sp)
811240ac:	e0bff60e 	bge	fp,r2,81124088 <__reset+0xfb104088>
811240b0:	d9801e04 	addi	r6,sp,120
811240b4:	a00b883a 	mov	r5,r20
811240b8:	9809883a 	mov	r4,r19
811240bc:	112faa00 	call	8112faa0 <__ssprint_r>
811240c0:	103c561e 	bne	r2,zero,8112321c <__reset+0xfb10321c>
811240c4:	d8c02017 	ldw	r3,128(sp)
811240c8:	d8801f17 	ldw	r2,124(sp)
811240cc:	da000404 	addi	r8,sp,16
811240d0:	003fee06 	br	8112408c <__reset+0xfb10408c>
811240d4:	d9402c17 	ldw	r5,176(sp)
811240d8:	d9801e04 	addi	r6,sp,120
811240dc:	9809883a 	mov	r4,r19
811240e0:	112faa00 	call	8112faa0 <__ssprint_r>
811240e4:	103c4d1e 	bne	r2,zero,8112321c <__reset+0xfb10321c>
811240e8:	d8c02017 	ldw	r3,128(sp)
811240ec:	df002787 	ldb	fp,158(sp)
811240f0:	da000404 	addi	r8,sp,16
811240f4:	003d5a06 	br	81123660 <__reset+0xfb103660>
811240f8:	9080040c 	andi	r2,r18,16
811240fc:	10005c26 	beq	r2,zero,81124270 <___svfprintf_internal_r+0x13f0>
81124100:	d9402d17 	ldw	r5,180(sp)
81124104:	d8c02917 	ldw	r3,164(sp)
81124108:	d8002785 	stb	zero,158(sp)
8112410c:	28800104 	addi	r2,r5,4
81124110:	2d000017 	ldw	r20,0(r5)
81124114:	002d883a 	mov	r22,zero
81124118:	18005e16 	blt	r3,zero,81124294 <___svfprintf_internal_r+0x1414>
8112411c:	00ffdfc4 	movi	r3,-129
81124120:	d8802d15 	stw	r2,180(sp)
81124124:	90e4703a 	and	r18,r18,r3
81124128:	0039883a 	mov	fp,zero
8112412c:	a03dfe26 	beq	r20,zero,81123928 <__reset+0xfb103928>
81124130:	00800244 	movi	r2,9
81124134:	153cb336 	bltu	r2,r20,81123404 <__reset+0xfb103404>
81124138:	a5000c04 	addi	r20,r20,48
8112413c:	dc001dc4 	addi	r16,sp,119
81124140:	dd001dc5 	stb	r20,119(sp)
81124144:	d8c02817 	ldw	r3,160(sp)
81124148:	1c07c83a 	sub	r3,r3,r16
8112414c:	d8c02e15 	stw	r3,184(sp)
81124150:	003cf506 	br	81123528 <__reset+0xfb103528>
81124154:	d8803317 	ldw	r2,204(sp)
81124158:	143fffc4 	addi	r16,r2,-1
8112415c:	043f560e 	bge	zero,r16,81123eb8 <__reset+0xfb103eb8>
81124160:	07000404 	movi	fp,16
81124164:	e403530e 	bge	fp,r16,81124eb4 <___svfprintf_internal_r+0x2034>
81124168:	01604574 	movhi	r5,33045
8112416c:	29411084 	addi	r5,r5,1090
81124170:	d9402b15 	stw	r5,172(sp)
81124174:	01c001c4 	movi	r7,7
81124178:	dd002c17 	ldw	r20,176(sp)
8112417c:	00000306 	br	8112418c <___svfprintf_internal_r+0x130c>
81124180:	843ffc04 	addi	r16,r16,-16
81124184:	b5800204 	addi	r22,r22,8
81124188:	e400130e 	bge	fp,r16,811241d8 <___svfprintf_internal_r+0x1358>
8112418c:	18c00404 	addi	r3,r3,16
81124190:	8c400044 	addi	r17,r17,1
81124194:	b5400015 	stw	r21,0(r22)
81124198:	b7000115 	stw	fp,4(r22)
8112419c:	d8c02015 	stw	r3,128(sp)
811241a0:	dc401f15 	stw	r17,124(sp)
811241a4:	3c7ff60e 	bge	r7,r17,81124180 <__reset+0xfb104180>
811241a8:	d9801e04 	addi	r6,sp,120
811241ac:	a00b883a 	mov	r5,r20
811241b0:	9809883a 	mov	r4,r19
811241b4:	d9c03d15 	stw	r7,244(sp)
811241b8:	112faa00 	call	8112faa0 <__ssprint_r>
811241bc:	d9c03d17 	ldw	r7,244(sp)
811241c0:	103c161e 	bne	r2,zero,8112321c <__reset+0xfb10321c>
811241c4:	843ffc04 	addi	r16,r16,-16
811241c8:	d8c02017 	ldw	r3,128(sp)
811241cc:	dc401f17 	ldw	r17,124(sp)
811241d0:	dd800404 	addi	r22,sp,16
811241d4:	e43fed16 	blt	fp,r16,8112418c <__reset+0xfb10418c>
811241d8:	d8802b17 	ldw	r2,172(sp)
811241dc:	1c07883a 	add	r3,r3,r16
811241e0:	8c400044 	addi	r17,r17,1
811241e4:	b0800015 	stw	r2,0(r22)
811241e8:	b4000115 	stw	r16,4(r22)
811241ec:	d8c02015 	stw	r3,128(sp)
811241f0:	dc401f15 	stw	r17,124(sp)
811241f4:	008001c4 	movi	r2,7
811241f8:	147f2e0e 	bge	r2,r17,81123eb4 <__reset+0xfb103eb4>
811241fc:	d9402c17 	ldw	r5,176(sp)
81124200:	d9801e04 	addi	r6,sp,120
81124204:	9809883a 	mov	r4,r19
81124208:	112faa00 	call	8112faa0 <__ssprint_r>
8112420c:	103c031e 	bne	r2,zero,8112321c <__reset+0xfb10321c>
81124210:	d8c02017 	ldw	r3,128(sp)
81124214:	dc401f17 	ldw	r17,124(sp)
81124218:	dd800404 	addi	r22,sp,16
8112421c:	003f2606 	br	81123eb8 <__reset+0xfb103eb8>
81124220:	9080040c 	andi	r2,r18,16
81124224:	1000c326 	beq	r2,zero,81124534 <___svfprintf_internal_r+0x16b4>
81124228:	d8802d17 	ldw	r2,180(sp)
8112422c:	15000017 	ldw	r20,0(r2)
81124230:	10800104 	addi	r2,r2,4
81124234:	d8802d15 	stw	r2,180(sp)
81124238:	a02dd7fa 	srai	r22,r20,31
8112423c:	b005883a 	mov	r2,r22
81124240:	103c680e 	bge	r2,zero,811233e4 <__reset+0xfb1033e4>
81124244:	0529c83a 	sub	r20,zero,r20
81124248:	a004c03a 	cmpne	r2,r20,zero
8112424c:	05adc83a 	sub	r22,zero,r22
81124250:	b0adc83a 	sub	r22,r22,r2
81124254:	d8802917 	ldw	r2,164(sp)
81124258:	07000b44 	movi	fp,45
8112425c:	df002785 	stb	fp,158(sp)
81124260:	10022e16 	blt	r2,zero,81124b1c <___svfprintf_internal_r+0x1c9c>
81124264:	00bfdfc4 	movi	r2,-129
81124268:	90a4703a 	and	r18,r18,r2
8112426c:	003c6406 	br	81123400 <__reset+0xfb103400>
81124270:	9080100c 	andi	r2,r18,64
81124274:	d8002785 	stb	zero,158(sp)
81124278:	10012526 	beq	r2,zero,81124710 <___svfprintf_internal_r+0x1890>
8112427c:	d9002d17 	ldw	r4,180(sp)
81124280:	d9402917 	ldw	r5,164(sp)
81124284:	002d883a 	mov	r22,zero
81124288:	20800104 	addi	r2,r4,4
8112428c:	2500000b 	ldhu	r20,0(r4)
81124290:	283fa20e 	bge	r5,zero,8112411c <__reset+0xfb10411c>
81124294:	d8802d15 	stw	r2,180(sp)
81124298:	0039883a 	mov	fp,zero
8112429c:	a584b03a 	or	r2,r20,r22
811242a0:	103c571e 	bne	r2,zero,81123400 <__reset+0xfb103400>
811242a4:	00800044 	movi	r2,1
811242a8:	003e5006 	br	81123bec <__reset+0xfb103bec>
811242ac:	d9402c17 	ldw	r5,176(sp)
811242b0:	d9801e04 	addi	r6,sp,120
811242b4:	9809883a 	mov	r4,r19
811242b8:	112faa00 	call	8112faa0 <__ssprint_r>
811242bc:	103bd71e 	bne	r2,zero,8112321c <__reset+0xfb10321c>
811242c0:	d8c02017 	ldw	r3,128(sp)
811242c4:	da000404 	addi	r8,sp,16
811242c8:	d9003217 	ldw	r4,200(sp)
811242cc:	d8802617 	ldw	r2,152(sp)
811242d0:	d9403317 	ldw	r5,204(sp)
811242d4:	8123883a 	add	r17,r16,r4
811242d8:	11400216 	blt	r2,r5,811242e4 <___svfprintf_internal_r+0x1464>
811242dc:	9100004c 	andi	r4,r18,1
811242e0:	20000d26 	beq	r4,zero,81124318 <___svfprintf_internal_r+0x1498>
811242e4:	d9003817 	ldw	r4,224(sp)
811242e8:	d9403417 	ldw	r5,208(sp)
811242ec:	1907883a 	add	r3,r3,r4
811242f0:	d9001f17 	ldw	r4,124(sp)
811242f4:	41400015 	stw	r5,0(r8)
811242f8:	d9403817 	ldw	r5,224(sp)
811242fc:	21000044 	addi	r4,r4,1
81124300:	d8c02015 	stw	r3,128(sp)
81124304:	41400115 	stw	r5,4(r8)
81124308:	d9001f15 	stw	r4,124(sp)
8112430c:	014001c4 	movi	r5,7
81124310:	2901dc16 	blt	r5,r4,81124a84 <___svfprintf_internal_r+0x1c04>
81124314:	42000204 	addi	r8,r8,8
81124318:	d9003317 	ldw	r4,204(sp)
8112431c:	8121883a 	add	r16,r16,r4
81124320:	2085c83a 	sub	r2,r4,r2
81124324:	8461c83a 	sub	r16,r16,r17
81124328:	1400010e 	bge	r2,r16,81124330 <___svfprintf_internal_r+0x14b0>
8112432c:	1021883a 	mov	r16,r2
81124330:	04000a0e 	bge	zero,r16,8112435c <___svfprintf_internal_r+0x14dc>
81124334:	d9001f17 	ldw	r4,124(sp)
81124338:	1c07883a 	add	r3,r3,r16
8112433c:	44400015 	stw	r17,0(r8)
81124340:	21000044 	addi	r4,r4,1
81124344:	44000115 	stw	r16,4(r8)
81124348:	d8c02015 	stw	r3,128(sp)
8112434c:	d9001f15 	stw	r4,124(sp)
81124350:	014001c4 	movi	r5,7
81124354:	2901e616 	blt	r5,r4,81124af0 <___svfprintf_internal_r+0x1c70>
81124358:	42000204 	addi	r8,r8,8
8112435c:	8001f616 	blt	r16,zero,81124b38 <___svfprintf_internal_r+0x1cb8>
81124360:	1421c83a 	sub	r16,r2,r16
81124364:	043d1c0e 	bge	zero,r16,811237d8 <__reset+0xfb1037d8>
81124368:	04400404 	movi	r17,16
8112436c:	d8801f17 	ldw	r2,124(sp)
81124370:	8c3edd0e 	bge	r17,r16,81123ee8 <__reset+0xfb103ee8>
81124374:	01604574 	movhi	r5,33045
81124378:	29411084 	addi	r5,r5,1090
8112437c:	d9402b15 	stw	r5,172(sp)
81124380:	058001c4 	movi	r22,7
81124384:	dd002c17 	ldw	r20,176(sp)
81124388:	00000306 	br	81124398 <___svfprintf_internal_r+0x1518>
8112438c:	42000204 	addi	r8,r8,8
81124390:	843ffc04 	addi	r16,r16,-16
81124394:	8c3ed70e 	bge	r17,r16,81123ef4 <__reset+0xfb103ef4>
81124398:	18c00404 	addi	r3,r3,16
8112439c:	10800044 	addi	r2,r2,1
811243a0:	45400015 	stw	r21,0(r8)
811243a4:	44400115 	stw	r17,4(r8)
811243a8:	d8c02015 	stw	r3,128(sp)
811243ac:	d8801f15 	stw	r2,124(sp)
811243b0:	b0bff60e 	bge	r22,r2,8112438c <__reset+0xfb10438c>
811243b4:	d9801e04 	addi	r6,sp,120
811243b8:	a00b883a 	mov	r5,r20
811243bc:	9809883a 	mov	r4,r19
811243c0:	112faa00 	call	8112faa0 <__ssprint_r>
811243c4:	103b951e 	bne	r2,zero,8112321c <__reset+0xfb10321c>
811243c8:	d8c02017 	ldw	r3,128(sp)
811243cc:	d8801f17 	ldw	r2,124(sp)
811243d0:	da000404 	addi	r8,sp,16
811243d4:	003fee06 	br	81124390 <__reset+0xfb104390>
811243d8:	9088703a 	and	r4,r18,r2
811243dc:	203e8d1e 	bne	r4,zero,81123e14 <__reset+0xfb103e14>
811243e0:	dc401f17 	ldw	r17,124(sp)
811243e4:	40800115 	stw	r2,4(r8)
811243e8:	44000015 	stw	r16,0(r8)
811243ec:	8c400044 	addi	r17,r17,1
811243f0:	d8c02015 	stw	r3,128(sp)
811243f4:	dc401f15 	stw	r17,124(sp)
811243f8:	008001c4 	movi	r2,7
811243fc:	147f7f16 	blt	r2,r17,811241fc <__reset+0xfb1041fc>
81124400:	45800204 	addi	r22,r8,8
81124404:	003eac06 	br	81123eb8 <__reset+0xfb103eb8>
81124408:	d9402c17 	ldw	r5,176(sp)
8112440c:	d9801e04 	addi	r6,sp,120
81124410:	9809883a 	mov	r4,r19
81124414:	112faa00 	call	8112faa0 <__ssprint_r>
81124418:	103b801e 	bne	r2,zero,8112321c <__reset+0xfb10321c>
8112441c:	d8c02017 	ldw	r3,128(sp)
81124420:	dc401f17 	ldw	r17,124(sp)
81124424:	da000404 	addi	r8,sp,16
81124428:	003e8406 	br	81123e3c <__reset+0xfb103e3c>
8112442c:	d9402c17 	ldw	r5,176(sp)
81124430:	d9801e04 	addi	r6,sp,120
81124434:	9809883a 	mov	r4,r19
81124438:	112faa00 	call	8112faa0 <__ssprint_r>
8112443c:	103b771e 	bne	r2,zero,8112321c <__reset+0xfb10321c>
81124440:	d8c02017 	ldw	r3,128(sp)
81124444:	dc401f17 	ldw	r17,124(sp)
81124448:	dd800404 	addi	r22,sp,16
8112444c:	003e8606 	br	81123e68 <__reset+0xfb103e68>
81124450:	0029883a 	mov	r20,zero
81124454:	a5000c04 	addi	r20,r20,48
81124458:	dc001dc4 	addi	r16,sp,119
8112445c:	dd001dc5 	stb	r20,119(sp)
81124460:	003f3806 	br	81124144 <__reset+0xfb104144>
81124464:	d9402c17 	ldw	r5,176(sp)
81124468:	d9801e04 	addi	r6,sp,120
8112446c:	9809883a 	mov	r4,r19
81124470:	112faa00 	call	8112faa0 <__ssprint_r>
81124474:	103b691e 	bne	r2,zero,8112321c <__reset+0xfb10321c>
81124478:	d8c02017 	ldw	r3,128(sp)
8112447c:	da000404 	addi	r8,sp,16
81124480:	003c9506 	br	811236d8 <__reset+0xfb1036d8>
81124484:	d9003617 	ldw	r4,216(sp)
81124488:	d9403717 	ldw	r5,220(sp)
8112448c:	da003e15 	stw	r8,248(sp)
81124490:	112d8b40 	call	8112d8b4 <__fpclassifyd>
81124494:	da003e17 	ldw	r8,248(sp)
81124498:	1000bd1e 	bne	r2,zero,81124790 <___svfprintf_internal_r+0x1910>
8112449c:	008011c4 	movi	r2,71
811244a0:	14411e0e 	bge	r2,r17,8112491c <___svfprintf_internal_r+0x1a9c>
811244a4:	04204574 	movhi	r16,33045
811244a8:	84010304 	addi	r16,r16,1036
811244ac:	00c000c4 	movi	r3,3
811244b0:	00bfdfc4 	movi	r2,-129
811244b4:	d8c02a15 	stw	r3,168(sp)
811244b8:	90a4703a 	and	r18,r18,r2
811244bc:	df002783 	ldbu	fp,158(sp)
811244c0:	d8c02e15 	stw	r3,184(sp)
811244c4:	d8002915 	stw	zero,164(sp)
811244c8:	d8003215 	stw	zero,200(sp)
811244cc:	003c1c06 	br	81123540 <__reset+0xfb103540>
811244d0:	9080100c 	andi	r2,r18,64
811244d4:	d8002785 	stb	zero,158(sp)
811244d8:	10009426 	beq	r2,zero,8112472c <___svfprintf_internal_r+0x18ac>
811244dc:	d8c02d17 	ldw	r3,180(sp)
811244e0:	d9002917 	ldw	r4,164(sp)
811244e4:	002d883a 	mov	r22,zero
811244e8:	18800104 	addi	r2,r3,4
811244ec:	1d00000b 	ldhu	r20,0(r3)
811244f0:	203ec10e 	bge	r4,zero,81123ff8 <__reset+0xfb103ff8>
811244f4:	a586b03a 	or	r3,r20,r22
811244f8:	d8802d15 	stw	r2,180(sp)
811244fc:	183ec21e 	bne	r3,zero,81124008 <__reset+0xfb104008>
81124500:	0039883a 	mov	fp,zero
81124504:	0005883a 	mov	r2,zero
81124508:	003db806 	br	81123bec <__reset+0xfb103bec>
8112450c:	d8802d17 	ldw	r2,180(sp)
81124510:	d8c02d17 	ldw	r3,180(sp)
81124514:	d9002d17 	ldw	r4,180(sp)
81124518:	10800017 	ldw	r2,0(r2)
8112451c:	18c00117 	ldw	r3,4(r3)
81124520:	21000204 	addi	r4,r4,8
81124524:	d8803615 	stw	r2,216(sp)
81124528:	d8c03715 	stw	r3,220(sp)
8112452c:	d9002d15 	stw	r4,180(sp)
81124530:	003b8206 	br	8112333c <__reset+0xfb10333c>
81124534:	9080100c 	andi	r2,r18,64
81124538:	10010726 	beq	r2,zero,81124958 <___svfprintf_internal_r+0x1ad8>
8112453c:	d8c02d17 	ldw	r3,180(sp)
81124540:	1d00000f 	ldh	r20,0(r3)
81124544:	18c00104 	addi	r3,r3,4
81124548:	d8c02d15 	stw	r3,180(sp)
8112454c:	a02dd7fa 	srai	r22,r20,31
81124550:	b005883a 	mov	r2,r22
81124554:	003ba206 	br	811233e0 <__reset+0xfb1033e0>
81124558:	9080100c 	andi	r2,r18,64
8112455c:	10010526 	beq	r2,zero,81124974 <___svfprintf_internal_r+0x1af4>
81124560:	d9002d17 	ldw	r4,180(sp)
81124564:	002d883a 	mov	r22,zero
81124568:	2500000b 	ldhu	r20,0(r4)
8112456c:	21000104 	addi	r4,r4,4
81124570:	d9002d15 	stw	r4,180(sp)
81124574:	003cfe06 	br	81123970 <__reset+0xfb103970>
81124578:	bc400007 	ldb	r17,0(r23)
8112457c:	003a9606 	br	81122fd8 <__reset+0xfb102fd8>
81124580:	9080040c 	andi	r2,r18,16
81124584:	10010126 	beq	r2,zero,8112498c <___svfprintf_internal_r+0x1b0c>
81124588:	d9402d17 	ldw	r5,180(sp)
8112458c:	d8c02f17 	ldw	r3,188(sp)
81124590:	28800017 	ldw	r2,0(r5)
81124594:	29400104 	addi	r5,r5,4
81124598:	d9402d15 	stw	r5,180(sp)
8112459c:	10c00015 	stw	r3,0(r2)
811245a0:	003a6406 	br	81122f34 <__reset+0xfb102f34>
811245a4:	d9002917 	ldw	r4,164(sp)
811245a8:	d8002785 	stb	zero,158(sp)
811245ac:	203d8d16 	blt	r4,zero,81123be4 <__reset+0xfb103be4>
811245b0:	00bfdfc4 	movi	r2,-129
811245b4:	90a4703a 	and	r18,r18,r2
811245b8:	003b0506 	br	811231d0 <__reset+0xfb1031d0>
811245bc:	01604574 	movhi	r5,33045
811245c0:	29411084 	addi	r5,r5,1090
811245c4:	d9402b15 	stw	r5,172(sp)
811245c8:	d9402b17 	ldw	r5,172(sp)
811245cc:	1c47883a 	add	r3,r3,r17
811245d0:	10800044 	addi	r2,r2,1
811245d4:	41400015 	stw	r5,0(r8)
811245d8:	44400115 	stw	r17,4(r8)
811245dc:	d8c02015 	stw	r3,128(sp)
811245e0:	d8801f15 	stw	r2,124(sp)
811245e4:	010001c4 	movi	r4,7
811245e8:	20bf3016 	blt	r4,r2,811242ac <__reset+0xfb1042ac>
811245ec:	42000204 	addi	r8,r8,8
811245f0:	003f3506 	br	811242c8 <__reset+0xfb1042c8>
811245f4:	01204574 	movhi	r4,33045
811245f8:	21011084 	addi	r4,r4,1090
811245fc:	d9002b15 	stw	r4,172(sp)
81124600:	003c5e06 	br	8112377c <__reset+0xfb10377c>
81124604:	d9402c17 	ldw	r5,176(sp)
81124608:	d9801e04 	addi	r6,sp,120
8112460c:	9809883a 	mov	r4,r19
81124610:	112faa00 	call	8112faa0 <__ssprint_r>
81124614:	103b011e 	bne	r2,zero,8112321c <__reset+0xfb10321c>
81124618:	d8c02017 	ldw	r3,128(sp)
8112461c:	da000404 	addi	r8,sp,16
81124620:	003d9306 	br	81123c70 <__reset+0xfb103c70>
81124624:	d8801f17 	ldw	r2,124(sp)
81124628:	01604574 	movhi	r5,33045
8112462c:	01000044 	movi	r4,1
81124630:	18c00044 	addi	r3,r3,1
81124634:	10800044 	addi	r2,r2,1
81124638:	29411004 	addi	r5,r5,1088
8112463c:	41000115 	stw	r4,4(r8)
81124640:	41400015 	stw	r5,0(r8)
81124644:	d8c02015 	stw	r3,128(sp)
81124648:	d8801f15 	stw	r2,124(sp)
8112464c:	010001c4 	movi	r4,7
81124650:	2080b516 	blt	r4,r2,81124928 <___svfprintf_internal_r+0x1aa8>
81124654:	42000204 	addi	r8,r8,8
81124658:	8800041e 	bne	r17,zero,8112466c <___svfprintf_internal_r+0x17ec>
8112465c:	d8803317 	ldw	r2,204(sp)
81124660:	1000021e 	bne	r2,zero,8112466c <___svfprintf_internal_r+0x17ec>
81124664:	9080004c 	andi	r2,r18,1
81124668:	103c5b26 	beq	r2,zero,811237d8 <__reset+0xfb1037d8>
8112466c:	d9003817 	ldw	r4,224(sp)
81124670:	d8801f17 	ldw	r2,124(sp)
81124674:	d9403417 	ldw	r5,208(sp)
81124678:	20c7883a 	add	r3,r4,r3
8112467c:	10800044 	addi	r2,r2,1
81124680:	41000115 	stw	r4,4(r8)
81124684:	41400015 	stw	r5,0(r8)
81124688:	d8c02015 	stw	r3,128(sp)
8112468c:	d8801f15 	stw	r2,124(sp)
81124690:	010001c4 	movi	r4,7
81124694:	20818016 	blt	r4,r2,81124c98 <___svfprintf_internal_r+0x1e18>
81124698:	42000204 	addi	r8,r8,8
8112469c:	0463c83a 	sub	r17,zero,r17
811246a0:	0440cb0e 	bge	zero,r17,811249d0 <___svfprintf_internal_r+0x1b50>
811246a4:	05800404 	movi	r22,16
811246a8:	b440e80e 	bge	r22,r17,81124a4c <___svfprintf_internal_r+0x1bcc>
811246ac:	01604574 	movhi	r5,33045
811246b0:	29411084 	addi	r5,r5,1090
811246b4:	d9402b15 	stw	r5,172(sp)
811246b8:	070001c4 	movi	fp,7
811246bc:	dd002c17 	ldw	r20,176(sp)
811246c0:	00000306 	br	811246d0 <___svfprintf_internal_r+0x1850>
811246c4:	42000204 	addi	r8,r8,8
811246c8:	8c7ffc04 	addi	r17,r17,-16
811246cc:	b440e20e 	bge	r22,r17,81124a58 <___svfprintf_internal_r+0x1bd8>
811246d0:	18c00404 	addi	r3,r3,16
811246d4:	10800044 	addi	r2,r2,1
811246d8:	45400015 	stw	r21,0(r8)
811246dc:	45800115 	stw	r22,4(r8)
811246e0:	d8c02015 	stw	r3,128(sp)
811246e4:	d8801f15 	stw	r2,124(sp)
811246e8:	e0bff60e 	bge	fp,r2,811246c4 <__reset+0xfb1046c4>
811246ec:	d9801e04 	addi	r6,sp,120
811246f0:	a00b883a 	mov	r5,r20
811246f4:	9809883a 	mov	r4,r19
811246f8:	112faa00 	call	8112faa0 <__ssprint_r>
811246fc:	103ac71e 	bne	r2,zero,8112321c <__reset+0xfb10321c>
81124700:	d8c02017 	ldw	r3,128(sp)
81124704:	d8801f17 	ldw	r2,124(sp)
81124708:	da000404 	addi	r8,sp,16
8112470c:	003fee06 	br	811246c8 <__reset+0xfb1046c8>
81124710:	d8c02d17 	ldw	r3,180(sp)
81124714:	d9002917 	ldw	r4,164(sp)
81124718:	002d883a 	mov	r22,zero
8112471c:	18800104 	addi	r2,r3,4
81124720:	1d000017 	ldw	r20,0(r3)
81124724:	203e7d0e 	bge	r4,zero,8112411c <__reset+0xfb10411c>
81124728:	003eda06 	br	81124294 <__reset+0xfb104294>
8112472c:	d9402d17 	ldw	r5,180(sp)
81124730:	d8c02917 	ldw	r3,164(sp)
81124734:	002d883a 	mov	r22,zero
81124738:	28800104 	addi	r2,r5,4
8112473c:	2d000017 	ldw	r20,0(r5)
81124740:	183e2d0e 	bge	r3,zero,81123ff8 <__reset+0xfb103ff8>
81124744:	003f6b06 	br	811244f4 <__reset+0xfb1044f4>
81124748:	d8c02d15 	stw	r3,180(sp)
8112474c:	0039883a 	mov	fp,zero
81124750:	003ed206 	br	8112429c <__reset+0xfb10429c>
81124754:	bc400043 	ldbu	r17,1(r23)
81124758:	94800814 	ori	r18,r18,32
8112475c:	bdc00044 	addi	r23,r23,1
81124760:	8c403fcc 	andi	r17,r17,255
81124764:	8c40201c 	xori	r17,r17,128
81124768:	8c7fe004 	addi	r17,r17,-128
8112476c:	003a1a06 	br	81122fd8 <__reset+0xfb102fd8>
81124770:	d9402c17 	ldw	r5,176(sp)
81124774:	d9801e04 	addi	r6,sp,120
81124778:	9809883a 	mov	r4,r19
8112477c:	112faa00 	call	8112faa0 <__ssprint_r>
81124780:	103aa61e 	bne	r2,zero,8112321c <__reset+0xfb10321c>
81124784:	d8c02017 	ldw	r3,128(sp)
81124788:	da000404 	addi	r8,sp,16
8112478c:	003d4a06 	br	81123cb8 <__reset+0xfb103cb8>
81124790:	d9002917 	ldw	r4,164(sp)
81124794:	05bff7c4 	movi	r22,-33
81124798:	00bfffc4 	movi	r2,-1
8112479c:	8dac703a 	and	r22,r17,r22
811247a0:	20806a26 	beq	r4,r2,8112494c <___svfprintf_internal_r+0x1acc>
811247a4:	008011c4 	movi	r2,71
811247a8:	b0813726 	beq	r22,r2,81124c88 <___svfprintf_internal_r+0x1e08>
811247ac:	d9003717 	ldw	r4,220(sp)
811247b0:	90c04014 	ori	r3,r18,256
811247b4:	d8c02b15 	stw	r3,172(sp)
811247b8:	20015d16 	blt	r4,zero,81124d30 <___svfprintf_internal_r+0x1eb0>
811247bc:	dd003717 	ldw	r20,220(sp)
811247c0:	d8002a05 	stb	zero,168(sp)
811247c4:	00801984 	movi	r2,102
811247c8:	88814026 	beq	r17,r2,81124ccc <___svfprintf_internal_r+0x1e4c>
811247cc:	00801184 	movi	r2,70
811247d0:	88817126 	beq	r17,r2,81124d98 <___svfprintf_internal_r+0x1f18>
811247d4:	00801144 	movi	r2,69
811247d8:	b0816226 	beq	r22,r2,81124d64 <___svfprintf_internal_r+0x1ee4>
811247dc:	d8c02917 	ldw	r3,164(sp)
811247e0:	d8802104 	addi	r2,sp,132
811247e4:	d8800315 	stw	r2,12(sp)
811247e8:	d9403617 	ldw	r5,216(sp)
811247ec:	d8802504 	addi	r2,sp,148
811247f0:	d8800215 	stw	r2,8(sp)
811247f4:	d8802604 	addi	r2,sp,152
811247f8:	d8c00015 	stw	r3,0(sp)
811247fc:	d8800115 	stw	r2,4(sp)
81124800:	01c00084 	movi	r7,2
81124804:	a00d883a 	mov	r6,r20
81124808:	9809883a 	mov	r4,r19
8112480c:	d8c03d15 	stw	r3,244(sp)
81124810:	da003e15 	stw	r8,248(sp)
81124814:	112916c0 	call	8112916c <_dtoa_r>
81124818:	1021883a 	mov	r16,r2
8112481c:	008019c4 	movi	r2,103
81124820:	d8c03d17 	ldw	r3,244(sp)
81124824:	da003e17 	ldw	r8,248(sp)
81124828:	8880e726 	beq	r17,r2,81124bc8 <___svfprintf_internal_r+0x1d48>
8112482c:	008011c4 	movi	r2,71
81124830:	8880d426 	beq	r17,r2,81124b84 <___svfprintf_internal_r+0x1d04>
81124834:	80f9883a 	add	fp,r16,r3
81124838:	d9003617 	ldw	r4,216(sp)
8112483c:	000d883a 	mov	r6,zero
81124840:	000f883a 	mov	r7,zero
81124844:	a00b883a 	mov	r5,r20
81124848:	da003e15 	stw	r8,248(sp)
8112484c:	1135a1c0 	call	81135a1c <__eqdf2>
81124850:	da003e17 	ldw	r8,248(sp)
81124854:	1000e426 	beq	r2,zero,81124be8 <___svfprintf_internal_r+0x1d68>
81124858:	d8802117 	ldw	r2,132(sp)
8112485c:	1700062e 	bgeu	r2,fp,81124878 <___svfprintf_internal_r+0x19f8>
81124860:	01000c04 	movi	r4,48
81124864:	10c00044 	addi	r3,r2,1
81124868:	d8c02115 	stw	r3,132(sp)
8112486c:	11000005 	stb	r4,0(r2)
81124870:	d8802117 	ldw	r2,132(sp)
81124874:	173ffb36 	bltu	r2,fp,81124864 <__reset+0xfb104864>
81124878:	1405c83a 	sub	r2,r2,r16
8112487c:	d8803315 	stw	r2,204(sp)
81124880:	008011c4 	movi	r2,71
81124884:	b080c526 	beq	r22,r2,81124b9c <___svfprintf_internal_r+0x1d1c>
81124888:	00801944 	movi	r2,101
8112488c:	1441d90e 	bge	r2,r17,81124ff4 <___svfprintf_internal_r+0x2174>
81124890:	d8c02617 	ldw	r3,152(sp)
81124894:	00801984 	movi	r2,102
81124898:	d8c03215 	stw	r3,200(sp)
8112489c:	88813426 	beq	r17,r2,81124d70 <___svfprintf_internal_r+0x1ef0>
811248a0:	d8c03217 	ldw	r3,200(sp)
811248a4:	d9003317 	ldw	r4,204(sp)
811248a8:	19012516 	blt	r3,r4,81124d40 <___svfprintf_internal_r+0x1ec0>
811248ac:	9480004c 	andi	r18,r18,1
811248b0:	9001841e 	bne	r18,zero,81124ec4 <___svfprintf_internal_r+0x2044>
811248b4:	1805883a 	mov	r2,r3
811248b8:	1801cc16 	blt	r3,zero,81124fec <___svfprintf_internal_r+0x216c>
811248bc:	d8c03217 	ldw	r3,200(sp)
811248c0:	044019c4 	movi	r17,103
811248c4:	d8c02e15 	stw	r3,184(sp)
811248c8:	df002a07 	ldb	fp,168(sp)
811248cc:	e000a61e 	bne	fp,zero,81124b68 <___svfprintf_internal_r+0x1ce8>
811248d0:	df002783 	ldbu	fp,158(sp)
811248d4:	d8802a15 	stw	r2,168(sp)
811248d8:	dc802b17 	ldw	r18,172(sp)
811248dc:	d8002915 	stw	zero,164(sp)
811248e0:	003b1706 	br	81123540 <__reset+0xfb103540>
811248e4:	04204574 	movhi	r16,33045
811248e8:	84010004 	addi	r16,r16,1024
811248ec:	003aa606 	br	81123388 <__reset+0xfb103388>
811248f0:	d9003917 	ldw	r4,228(sp)
811248f4:	04001004 	movi	r16,64
811248f8:	800b883a 	mov	r5,r16
811248fc:	11218400 	call	81121840 <_malloc_r>
81124900:	d9002c17 	ldw	r4,176(sp)
81124904:	20800015 	stw	r2,0(r4)
81124908:	20800415 	stw	r2,16(r4)
8112490c:	1001cb26 	beq	r2,zero,8112503c <___svfprintf_internal_r+0x21bc>
81124910:	d8802c17 	ldw	r2,176(sp)
81124914:	14000515 	stw	r16,20(r2)
81124918:	00397606 	br	81122ef4 <__reset+0xfb102ef4>
8112491c:	04204574 	movhi	r16,33045
81124920:	84010204 	addi	r16,r16,1032
81124924:	003ee106 	br	811244ac <__reset+0xfb1044ac>
81124928:	d9402c17 	ldw	r5,176(sp)
8112492c:	d9801e04 	addi	r6,sp,120
81124930:	9809883a 	mov	r4,r19
81124934:	112faa00 	call	8112faa0 <__ssprint_r>
81124938:	103a381e 	bne	r2,zero,8112321c <__reset+0xfb10321c>
8112493c:	dc402617 	ldw	r17,152(sp)
81124940:	d8c02017 	ldw	r3,128(sp)
81124944:	da000404 	addi	r8,sp,16
81124948:	003f4306 	br	81124658 <__reset+0xfb104658>
8112494c:	01400184 	movi	r5,6
81124950:	d9402915 	stw	r5,164(sp)
81124954:	003f9506 	br	811247ac <__reset+0xfb1047ac>
81124958:	d9002d17 	ldw	r4,180(sp)
8112495c:	25000017 	ldw	r20,0(r4)
81124960:	21000104 	addi	r4,r4,4
81124964:	d9002d15 	stw	r4,180(sp)
81124968:	a02dd7fa 	srai	r22,r20,31
8112496c:	b005883a 	mov	r2,r22
81124970:	003a9b06 	br	811233e0 <__reset+0xfb1033e0>
81124974:	d9402d17 	ldw	r5,180(sp)
81124978:	002d883a 	mov	r22,zero
8112497c:	2d000017 	ldw	r20,0(r5)
81124980:	29400104 	addi	r5,r5,4
81124984:	d9402d15 	stw	r5,180(sp)
81124988:	003bf906 	br	81123970 <__reset+0xfb103970>
8112498c:	9480100c 	andi	r18,r18,64
81124990:	90006e26 	beq	r18,zero,81124b4c <___svfprintf_internal_r+0x1ccc>
81124994:	d9002d17 	ldw	r4,180(sp)
81124998:	d9402f17 	ldw	r5,188(sp)
8112499c:	20800017 	ldw	r2,0(r4)
811249a0:	21000104 	addi	r4,r4,4
811249a4:	d9002d15 	stw	r4,180(sp)
811249a8:	1140000d 	sth	r5,0(r2)
811249ac:	00396106 	br	81122f34 <__reset+0xfb102f34>
811249b0:	d9402c17 	ldw	r5,176(sp)
811249b4:	d9801e04 	addi	r6,sp,120
811249b8:	9809883a 	mov	r4,r19
811249bc:	112faa00 	call	8112faa0 <__ssprint_r>
811249c0:	103a161e 	bne	r2,zero,8112321c <__reset+0xfb10321c>
811249c4:	d8c02017 	ldw	r3,128(sp)
811249c8:	d8801f17 	ldw	r2,124(sp)
811249cc:	da000404 	addi	r8,sp,16
811249d0:	d9403317 	ldw	r5,204(sp)
811249d4:	10800044 	addi	r2,r2,1
811249d8:	44000015 	stw	r16,0(r8)
811249dc:	28c7883a 	add	r3,r5,r3
811249e0:	003b7706 	br	811237c0 <__reset+0xfb1037c0>
811249e4:	8009883a 	mov	r4,r16
811249e8:	da003e15 	stw	r8,248(sp)
811249ec:	1122b480 	call	81122b48 <strlen>
811249f0:	d8802e15 	stw	r2,184(sp)
811249f4:	da003e17 	ldw	r8,248(sp)
811249f8:	103c280e 	bge	r2,zero,81123a9c <__reset+0xfb103a9c>
811249fc:	0005883a 	mov	r2,zero
81124a00:	003c2606 	br	81123a9c <__reset+0xfb103a9c>
81124a04:	00bfffc4 	movi	r2,-1
81124a08:	003a0906 	br	81123230 <__reset+0xfb103230>
81124a0c:	01204574 	movhi	r4,33045
81124a10:	21011484 	addi	r4,r4,1106
81124a14:	d9003515 	stw	r4,212(sp)
81124a18:	003b0606 	br	81123634 <__reset+0xfb103634>
81124a1c:	013fffc4 	movi	r4,-1
81124a20:	003a2706 	br	811232c0 <__reset+0xfb1032c0>
81124a24:	d9402c17 	ldw	r5,176(sp)
81124a28:	d9801e04 	addi	r6,sp,120
81124a2c:	9809883a 	mov	r4,r19
81124a30:	112faa00 	call	8112faa0 <__ssprint_r>
81124a34:	1039f91e 	bne	r2,zero,8112321c <__reset+0xfb10321c>
81124a38:	d8c02017 	ldw	r3,128(sp)
81124a3c:	da000404 	addi	r8,sp,16
81124a40:	003d8406 	br	81124054 <__reset+0xfb104054>
81124a44:	0023883a 	mov	r17,zero
81124a48:	003d8306 	br	81124058 <__reset+0xfb104058>
81124a4c:	01204574 	movhi	r4,33045
81124a50:	21011084 	addi	r4,r4,1090
81124a54:	d9002b15 	stw	r4,172(sp)
81124a58:	d9002b17 	ldw	r4,172(sp)
81124a5c:	1c47883a 	add	r3,r3,r17
81124a60:	10800044 	addi	r2,r2,1
81124a64:	41000015 	stw	r4,0(r8)
81124a68:	44400115 	stw	r17,4(r8)
81124a6c:	d8c02015 	stw	r3,128(sp)
81124a70:	d8801f15 	stw	r2,124(sp)
81124a74:	010001c4 	movi	r4,7
81124a78:	20bfcd16 	blt	r4,r2,811249b0 <__reset+0xfb1049b0>
81124a7c:	42000204 	addi	r8,r8,8
81124a80:	003fd306 	br	811249d0 <__reset+0xfb1049d0>
81124a84:	d9402c17 	ldw	r5,176(sp)
81124a88:	d9801e04 	addi	r6,sp,120
81124a8c:	9809883a 	mov	r4,r19
81124a90:	112faa00 	call	8112faa0 <__ssprint_r>
81124a94:	1039e11e 	bne	r2,zero,8112321c <__reset+0xfb10321c>
81124a98:	d8802617 	ldw	r2,152(sp)
81124a9c:	d8c02017 	ldw	r3,128(sp)
81124aa0:	da000404 	addi	r8,sp,16
81124aa4:	003e1c06 	br	81124318 <__reset+0xfb104318>
81124aa8:	d8802917 	ldw	r2,164(sp)
81124aac:	00c00184 	movi	r3,6
81124ab0:	1880012e 	bgeu	r3,r2,81124ab8 <___svfprintf_internal_r+0x1c38>
81124ab4:	1805883a 	mov	r2,r3
81124ab8:	d8802e15 	stw	r2,184(sp)
81124abc:	1000f316 	blt	r2,zero,81124e8c <___svfprintf_internal_r+0x200c>
81124ac0:	04204574 	movhi	r16,33045
81124ac4:	d8802a15 	stw	r2,168(sp)
81124ac8:	dd002d15 	stw	r20,180(sp)
81124acc:	d8002915 	stw	zero,164(sp)
81124ad0:	d8003215 	stw	zero,200(sp)
81124ad4:	84010e04 	addi	r16,r16,1080
81124ad8:	0039883a 	mov	fp,zero
81124adc:	003a9f06 	br	8112355c <__reset+0xfb10355c>
81124ae0:	01204574 	movhi	r4,33045
81124ae4:	21011484 	addi	r4,r4,1106
81124ae8:	d9003515 	stw	r4,212(sp)
81124aec:	003b5f06 	br	8112386c <__reset+0xfb10386c>
81124af0:	d9402c17 	ldw	r5,176(sp)
81124af4:	d9801e04 	addi	r6,sp,120
81124af8:	9809883a 	mov	r4,r19
81124afc:	112faa00 	call	8112faa0 <__ssprint_r>
81124b00:	1039c61e 	bne	r2,zero,8112321c <__reset+0xfb10321c>
81124b04:	d8802617 	ldw	r2,152(sp)
81124b08:	d9403317 	ldw	r5,204(sp)
81124b0c:	d8c02017 	ldw	r3,128(sp)
81124b10:	da000404 	addi	r8,sp,16
81124b14:	2885c83a 	sub	r2,r5,r2
81124b18:	003e1006 	br	8112435c <__reset+0xfb10435c>
81124b1c:	00800044 	movi	r2,1
81124b20:	10803fcc 	andi	r2,r2,255
81124b24:	00c00044 	movi	r3,1
81124b28:	10fa3526 	beq	r2,r3,81123400 <__reset+0xfb103400>
81124b2c:	00c00084 	movi	r3,2
81124b30:	10fb9e26 	beq	r2,r3,811239ac <__reset+0xfb1039ac>
81124b34:	003a6406 	br	811234c8 <__reset+0xfb1034c8>
81124b38:	0021883a 	mov	r16,zero
81124b3c:	003e0806 	br	81124360 <__reset+0xfb104360>
81124b40:	07000b44 	movi	fp,45
81124b44:	df002785 	stb	fp,158(sp)
81124b48:	003a0b06 	br	81123378 <__reset+0xfb103378>
81124b4c:	d8c02d17 	ldw	r3,180(sp)
81124b50:	d9002f17 	ldw	r4,188(sp)
81124b54:	18800017 	ldw	r2,0(r3)
81124b58:	18c00104 	addi	r3,r3,4
81124b5c:	d8c02d15 	stw	r3,180(sp)
81124b60:	11000015 	stw	r4,0(r2)
81124b64:	0038f306 	br	81122f34 <__reset+0xfb102f34>
81124b68:	00c00b44 	movi	r3,45
81124b6c:	d8c02785 	stb	r3,158(sp)
81124b70:	d8802a15 	stw	r2,168(sp)
81124b74:	dc802b17 	ldw	r18,172(sp)
81124b78:	d8002915 	stw	zero,164(sp)
81124b7c:	07000b44 	movi	fp,45
81124b80:	003a7306 	br	81123550 <__reset+0xfb103550>
81124b84:	9080004c 	andi	r2,r18,1
81124b88:	1000941e 	bne	r2,zero,81124ddc <___svfprintf_internal_r+0x1f5c>
81124b8c:	d8802117 	ldw	r2,132(sp)
81124b90:	1405c83a 	sub	r2,r2,r16
81124b94:	d8803315 	stw	r2,204(sp)
81124b98:	b441161e 	bne	r22,r17,81124ff4 <___svfprintf_internal_r+0x2174>
81124b9c:	dd802617 	ldw	r22,152(sp)
81124ba0:	00bfff44 	movi	r2,-3
81124ba4:	b0801a16 	blt	r22,r2,81124c10 <___svfprintf_internal_r+0x1d90>
81124ba8:	d9402917 	ldw	r5,164(sp)
81124bac:	2d801816 	blt	r5,r22,81124c10 <___svfprintf_internal_r+0x1d90>
81124bb0:	dd803215 	stw	r22,200(sp)
81124bb4:	003f3a06 	br	811248a0 <__reset+0xfb1048a0>
81124bb8:	1025883a 	mov	r18,r2
81124bbc:	0039883a 	mov	fp,zero
81124bc0:	00800084 	movi	r2,2
81124bc4:	003fd606 	br	81124b20 <__reset+0xfb104b20>
81124bc8:	9080004c 	andi	r2,r18,1
81124bcc:	103f191e 	bne	r2,zero,81124834 <__reset+0xfb104834>
81124bd0:	d8802117 	ldw	r2,132(sp)
81124bd4:	003f2806 	br	81124878 <__reset+0xfb104878>
81124bd8:	01204574 	movhi	r4,33045
81124bdc:	21011084 	addi	r4,r4,1090
81124be0:	d9002b15 	stw	r4,172(sp)
81124be4:	003c7c06 	br	81123dd8 <__reset+0xfb103dd8>
81124be8:	e005883a 	mov	r2,fp
81124bec:	003f2206 	br	81124878 <__reset+0xfb104878>
81124bf0:	d9402917 	ldw	r5,164(sp)
81124bf4:	df002783 	ldbu	fp,158(sp)
81124bf8:	dd002d15 	stw	r20,180(sp)
81124bfc:	d9402a15 	stw	r5,168(sp)
81124c00:	d9402e15 	stw	r5,184(sp)
81124c04:	d8002915 	stw	zero,164(sp)
81124c08:	d8003215 	stw	zero,200(sp)
81124c0c:	003a4c06 	br	81123540 <__reset+0xfb103540>
81124c10:	8c7fff84 	addi	r17,r17,-2
81124c14:	b5bfffc4 	addi	r22,r22,-1
81124c18:	dd802615 	stw	r22,152(sp)
81124c1c:	dc4022c5 	stb	r17,139(sp)
81124c20:	b000c316 	blt	r22,zero,81124f30 <___svfprintf_internal_r+0x20b0>
81124c24:	00800ac4 	movi	r2,43
81124c28:	d8802305 	stb	r2,140(sp)
81124c2c:	00800244 	movi	r2,9
81124c30:	15806e16 	blt	r2,r22,81124dec <___svfprintf_internal_r+0x1f6c>
81124c34:	00800c04 	movi	r2,48
81124c38:	b5800c04 	addi	r22,r22,48
81124c3c:	d8802345 	stb	r2,141(sp)
81124c40:	dd802385 	stb	r22,142(sp)
81124c44:	d88023c4 	addi	r2,sp,143
81124c48:	df0022c4 	addi	fp,sp,139
81124c4c:	d8c03317 	ldw	r3,204(sp)
81124c50:	1739c83a 	sub	fp,r2,fp
81124c54:	d9003317 	ldw	r4,204(sp)
81124c58:	e0c7883a 	add	r3,fp,r3
81124c5c:	df003b15 	stw	fp,236(sp)
81124c60:	d8c02e15 	stw	r3,184(sp)
81124c64:	00800044 	movi	r2,1
81124c68:	1100b70e 	bge	r2,r4,81124f48 <___svfprintf_internal_r+0x20c8>
81124c6c:	d8c02e17 	ldw	r3,184(sp)
81124c70:	18c00044 	addi	r3,r3,1
81124c74:	d8c02e15 	stw	r3,184(sp)
81124c78:	1805883a 	mov	r2,r3
81124c7c:	1800b016 	blt	r3,zero,81124f40 <___svfprintf_internal_r+0x20c0>
81124c80:	d8003215 	stw	zero,200(sp)
81124c84:	003f1006 	br	811248c8 <__reset+0xfb1048c8>
81124c88:	d8802917 	ldw	r2,164(sp)
81124c8c:	103ec71e 	bne	r2,zero,811247ac <__reset+0xfb1047ac>
81124c90:	dc002915 	stw	r16,164(sp)
81124c94:	003ec506 	br	811247ac <__reset+0xfb1047ac>
81124c98:	d9402c17 	ldw	r5,176(sp)
81124c9c:	d9801e04 	addi	r6,sp,120
81124ca0:	9809883a 	mov	r4,r19
81124ca4:	112faa00 	call	8112faa0 <__ssprint_r>
81124ca8:	10395c1e 	bne	r2,zero,8112321c <__reset+0xfb10321c>
81124cac:	dc402617 	ldw	r17,152(sp)
81124cb0:	d8c02017 	ldw	r3,128(sp)
81124cb4:	d8801f17 	ldw	r2,124(sp)
81124cb8:	da000404 	addi	r8,sp,16
81124cbc:	003e7706 	br	8112469c <__reset+0xfb10469c>
81124cc0:	582f883a 	mov	r23,r11
81124cc4:	d8002915 	stw	zero,164(sp)
81124cc8:	0038c406 	br	81122fdc <__reset+0xfb102fdc>
81124ccc:	d8c02917 	ldw	r3,164(sp)
81124cd0:	d8802104 	addi	r2,sp,132
81124cd4:	d8800315 	stw	r2,12(sp)
81124cd8:	d9403617 	ldw	r5,216(sp)
81124cdc:	d8802504 	addi	r2,sp,148
81124ce0:	d8800215 	stw	r2,8(sp)
81124ce4:	d8802604 	addi	r2,sp,152
81124ce8:	d8c00015 	stw	r3,0(sp)
81124cec:	9809883a 	mov	r4,r19
81124cf0:	d8800115 	stw	r2,4(sp)
81124cf4:	01c000c4 	movi	r7,3
81124cf8:	a00d883a 	mov	r6,r20
81124cfc:	da003e15 	stw	r8,248(sp)
81124d00:	112916c0 	call	8112916c <_dtoa_r>
81124d04:	d9002917 	ldw	r4,164(sp)
81124d08:	da003e17 	ldw	r8,248(sp)
81124d0c:	1021883a 	mov	r16,r2
81124d10:	1139883a 	add	fp,r2,r4
81124d14:	2007883a 	mov	r3,r4
81124d18:	81000007 	ldb	r4,0(r16)
81124d1c:	00800c04 	movi	r2,48
81124d20:	20806f26 	beq	r4,r2,81124ee0 <___svfprintf_internal_r+0x2060>
81124d24:	d8c02617 	ldw	r3,152(sp)
81124d28:	e0f9883a 	add	fp,fp,r3
81124d2c:	003ec206 	br	81124838 <__reset+0xfb104838>
81124d30:	00c00b44 	movi	r3,45
81124d34:	2520003c 	xorhi	r20,r4,32768
81124d38:	d8c02a05 	stb	r3,168(sp)
81124d3c:	003ea106 	br	811247c4 <__reset+0xfb1047c4>
81124d40:	d8c03217 	ldw	r3,200(sp)
81124d44:	00c0890e 	bge	zero,r3,81124f6c <___svfprintf_internal_r+0x20ec>
81124d48:	00800044 	movi	r2,1
81124d4c:	d9003317 	ldw	r4,204(sp)
81124d50:	1105883a 	add	r2,r2,r4
81124d54:	d8802e15 	stw	r2,184(sp)
81124d58:	10005f16 	blt	r2,zero,81124ed8 <___svfprintf_internal_r+0x2058>
81124d5c:	044019c4 	movi	r17,103
81124d60:	003ed906 	br	811248c8 <__reset+0xfb1048c8>
81124d64:	d9002917 	ldw	r4,164(sp)
81124d68:	20c00044 	addi	r3,r4,1
81124d6c:	003e9c06 	br	811247e0 <__reset+0xfb1047e0>
81124d70:	d9002917 	ldw	r4,164(sp)
81124d74:	00c0680e 	bge	zero,r3,81124f18 <___svfprintf_internal_r+0x2098>
81124d78:	2000461e 	bne	r4,zero,81124e94 <___svfprintf_internal_r+0x2014>
81124d7c:	9480004c 	andi	r18,r18,1
81124d80:	9000441e 	bne	r18,zero,81124e94 <___svfprintf_internal_r+0x2014>
81124d84:	1805883a 	mov	r2,r3
81124d88:	1800a016 	blt	r3,zero,8112500c <___svfprintf_internal_r+0x218c>
81124d8c:	d8c03217 	ldw	r3,200(sp)
81124d90:	d8c02e15 	stw	r3,184(sp)
81124d94:	003ecc06 	br	811248c8 <__reset+0xfb1048c8>
81124d98:	d9402917 	ldw	r5,164(sp)
81124d9c:	d8802104 	addi	r2,sp,132
81124da0:	d8800315 	stw	r2,12(sp)
81124da4:	d9400015 	stw	r5,0(sp)
81124da8:	d8802504 	addi	r2,sp,148
81124dac:	d9403617 	ldw	r5,216(sp)
81124db0:	d8800215 	stw	r2,8(sp)
81124db4:	d8802604 	addi	r2,sp,152
81124db8:	d8800115 	stw	r2,4(sp)
81124dbc:	01c000c4 	movi	r7,3
81124dc0:	a00d883a 	mov	r6,r20
81124dc4:	9809883a 	mov	r4,r19
81124dc8:	da003e15 	stw	r8,248(sp)
81124dcc:	112916c0 	call	8112916c <_dtoa_r>
81124dd0:	d8c02917 	ldw	r3,164(sp)
81124dd4:	da003e17 	ldw	r8,248(sp)
81124dd8:	1021883a 	mov	r16,r2
81124ddc:	00801184 	movi	r2,70
81124de0:	80f9883a 	add	fp,r16,r3
81124de4:	88bfcc26 	beq	r17,r2,81124d18 <__reset+0xfb104d18>
81124de8:	003e9306 	br	81124838 <__reset+0xfb104838>
81124dec:	df0022c4 	addi	fp,sp,139
81124df0:	dc002915 	stw	r16,164(sp)
81124df4:	9829883a 	mov	r20,r19
81124df8:	e021883a 	mov	r16,fp
81124dfc:	4027883a 	mov	r19,r8
81124e00:	b009883a 	mov	r4,r22
81124e04:	01400284 	movi	r5,10
81124e08:	113454c0 	call	8113454c <__modsi3>
81124e0c:	10800c04 	addi	r2,r2,48
81124e10:	843fffc4 	addi	r16,r16,-1
81124e14:	b009883a 	mov	r4,r22
81124e18:	01400284 	movi	r5,10
81124e1c:	80800005 	stb	r2,0(r16)
81124e20:	11344c80 	call	811344c8 <__divsi3>
81124e24:	102d883a 	mov	r22,r2
81124e28:	00800244 	movi	r2,9
81124e2c:	15bff416 	blt	r2,r22,81124e00 <__reset+0xfb104e00>
81124e30:	9811883a 	mov	r8,r19
81124e34:	b0800c04 	addi	r2,r22,48
81124e38:	a027883a 	mov	r19,r20
81124e3c:	8029883a 	mov	r20,r16
81124e40:	a17fffc4 	addi	r5,r20,-1
81124e44:	a0bfffc5 	stb	r2,-1(r20)
81124e48:	dc002917 	ldw	r16,164(sp)
81124e4c:	2f00752e 	bgeu	r5,fp,81125024 <___svfprintf_internal_r+0x21a4>
81124e50:	d9c02384 	addi	r7,sp,142
81124e54:	3d0fc83a 	sub	r7,r7,r20
81124e58:	d9002344 	addi	r4,sp,141
81124e5c:	e1cf883a 	add	r7,fp,r7
81124e60:	00000106 	br	81124e68 <___svfprintf_internal_r+0x1fe8>
81124e64:	28800003 	ldbu	r2,0(r5)
81124e68:	20800005 	stb	r2,0(r4)
81124e6c:	21000044 	addi	r4,r4,1
81124e70:	29400044 	addi	r5,r5,1
81124e74:	21fffb1e 	bne	r4,r7,81124e64 <__reset+0xfb104e64>
81124e78:	d8802304 	addi	r2,sp,140
81124e7c:	1505c83a 	sub	r2,r2,r20
81124e80:	d8c02344 	addi	r3,sp,141
81124e84:	1885883a 	add	r2,r3,r2
81124e88:	003f7006 	br	81124c4c <__reset+0xfb104c4c>
81124e8c:	0005883a 	mov	r2,zero
81124e90:	003f0b06 	br	81124ac0 <__reset+0xfb104ac0>
81124e94:	d9002917 	ldw	r4,164(sp)
81124e98:	d8c03217 	ldw	r3,200(sp)
81124e9c:	20800044 	addi	r2,r4,1
81124ea0:	1885883a 	add	r2,r3,r2
81124ea4:	d8802e15 	stw	r2,184(sp)
81124ea8:	103e870e 	bge	r2,zero,811248c8 <__reset+0xfb1048c8>
81124eac:	0005883a 	mov	r2,zero
81124eb0:	003e8506 	br	811248c8 <__reset+0xfb1048c8>
81124eb4:	01204574 	movhi	r4,33045
81124eb8:	21011084 	addi	r4,r4,1090
81124ebc:	d9002b15 	stw	r4,172(sp)
81124ec0:	003cc506 	br	811241d8 <__reset+0xfb1041d8>
81124ec4:	d8c03217 	ldw	r3,200(sp)
81124ec8:	18c00044 	addi	r3,r3,1
81124ecc:	d8c02e15 	stw	r3,184(sp)
81124ed0:	1805883a 	mov	r2,r3
81124ed4:	183fa10e 	bge	r3,zero,81124d5c <__reset+0xfb104d5c>
81124ed8:	0005883a 	mov	r2,zero
81124edc:	003f9f06 	br	81124d5c <__reset+0xfb104d5c>
81124ee0:	d9003617 	ldw	r4,216(sp)
81124ee4:	000d883a 	mov	r6,zero
81124ee8:	000f883a 	mov	r7,zero
81124eec:	a00b883a 	mov	r5,r20
81124ef0:	d8c03d15 	stw	r3,244(sp)
81124ef4:	da003e15 	stw	r8,248(sp)
81124ef8:	1135a1c0 	call	81135a1c <__eqdf2>
81124efc:	d8c03d17 	ldw	r3,244(sp)
81124f00:	da003e17 	ldw	r8,248(sp)
81124f04:	103f8726 	beq	r2,zero,81124d24 <__reset+0xfb104d24>
81124f08:	00800044 	movi	r2,1
81124f0c:	10c7c83a 	sub	r3,r2,r3
81124f10:	d8c02615 	stw	r3,152(sp)
81124f14:	003f8406 	br	81124d28 <__reset+0xfb104d28>
81124f18:	20000e1e 	bne	r4,zero,81124f54 <___svfprintf_internal_r+0x20d4>
81124f1c:	9480004c 	andi	r18,r18,1
81124f20:	90000c1e 	bne	r18,zero,81124f54 <___svfprintf_internal_r+0x20d4>
81124f24:	00800044 	movi	r2,1
81124f28:	d8802e15 	stw	r2,184(sp)
81124f2c:	003e6606 	br	811248c8 <__reset+0xfb1048c8>
81124f30:	00800b44 	movi	r2,45
81124f34:	05adc83a 	sub	r22,zero,r22
81124f38:	d8802305 	stb	r2,140(sp)
81124f3c:	003f3b06 	br	81124c2c <__reset+0xfb104c2c>
81124f40:	0005883a 	mov	r2,zero
81124f44:	003f4e06 	br	81124c80 <__reset+0xfb104c80>
81124f48:	90a4703a 	and	r18,r18,r2
81124f4c:	903f4a26 	beq	r18,zero,81124c78 <__reset+0xfb104c78>
81124f50:	003f4606 	br	81124c6c <__reset+0xfb104c6c>
81124f54:	d8c02917 	ldw	r3,164(sp)
81124f58:	18c00084 	addi	r3,r3,2
81124f5c:	d8c02e15 	stw	r3,184(sp)
81124f60:	1805883a 	mov	r2,r3
81124f64:	183e580e 	bge	r3,zero,811248c8 <__reset+0xfb1048c8>
81124f68:	003fd006 	br	81124eac <__reset+0xfb104eac>
81124f6c:	00800084 	movi	r2,2
81124f70:	10c5c83a 	sub	r2,r2,r3
81124f74:	003f7506 	br	81124d4c <__reset+0xfb104d4c>
81124f78:	d8802d17 	ldw	r2,180(sp)
81124f7c:	d9002d17 	ldw	r4,180(sp)
81124f80:	bc400043 	ldbu	r17,1(r23)
81124f84:	10800017 	ldw	r2,0(r2)
81124f88:	582f883a 	mov	r23,r11
81124f8c:	d8802915 	stw	r2,164(sp)
81124f90:	20800104 	addi	r2,r4,4
81124f94:	d9002917 	ldw	r4,164(sp)
81124f98:	d8802d15 	stw	r2,180(sp)
81124f9c:	203df00e 	bge	r4,zero,81124760 <__reset+0xfb104760>
81124fa0:	8c403fcc 	andi	r17,r17,255
81124fa4:	00bfffc4 	movi	r2,-1
81124fa8:	8c40201c 	xori	r17,r17,128
81124fac:	d8802915 	stw	r2,164(sp)
81124fb0:	8c7fe004 	addi	r17,r17,-128
81124fb4:	00380806 	br	81122fd8 <__reset+0xfb102fd8>
81124fb8:	9080004c 	andi	r2,r18,1
81124fbc:	0039883a 	mov	fp,zero
81124fc0:	10000726 	beq	r2,zero,81124fe0 <___svfprintf_internal_r+0x2160>
81124fc4:	d8c02817 	ldw	r3,160(sp)
81124fc8:	dc001dc4 	addi	r16,sp,119
81124fcc:	00800c04 	movi	r2,48
81124fd0:	1c07c83a 	sub	r3,r3,r16
81124fd4:	d8801dc5 	stb	r2,119(sp)
81124fd8:	d8c02e15 	stw	r3,184(sp)
81124fdc:	00395206 	br	81123528 <__reset+0xfb103528>
81124fe0:	d8002e15 	stw	zero,184(sp)
81124fe4:	dc001e04 	addi	r16,sp,120
81124fe8:	00394f06 	br	81123528 <__reset+0xfb103528>
81124fec:	0005883a 	mov	r2,zero
81124ff0:	003e3206 	br	811248bc <__reset+0xfb1048bc>
81124ff4:	dd802617 	ldw	r22,152(sp)
81124ff8:	003f0606 	br	81124c14 <__reset+0xfb104c14>
81124ffc:	d9c02785 	stb	r7,158(sp)
81125000:	003a5106 	br	81123948 <__reset+0xfb103948>
81125004:	d9c02785 	stb	r7,158(sp)
81125008:	003a3706 	br	811238e8 <__reset+0xfb1038e8>
8112500c:	0005883a 	mov	r2,zero
81125010:	003f5e06 	br	81124d8c <__reset+0xfb104d8c>
81125014:	d9c02785 	stb	r7,158(sp)
81125018:	00391706 	br	81123478 <__reset+0xfb103478>
8112501c:	d9c02785 	stb	r7,158(sp)
81125020:	0038e606 	br	811233bc <__reset+0xfb1033bc>
81125024:	d8802344 	addi	r2,sp,141
81125028:	003f0806 	br	81124c4c <__reset+0xfb104c4c>
8112502c:	d9c02785 	stb	r7,158(sp)
81125030:	0038b706 	br	81123310 <__reset+0xfb103310>
81125034:	d9c02785 	stb	r7,158(sp)
81125038:	003adc06 	br	81123bac <__reset+0xfb103bac>
8112503c:	d9403917 	ldw	r5,228(sp)
81125040:	00800304 	movi	r2,12
81125044:	28800015 	stw	r2,0(r5)
81125048:	00bfffc4 	movi	r2,-1
8112504c:	00387806 	br	81123230 <__reset+0xfb103230>
81125050:	d9c02785 	stb	r7,158(sp)
81125054:	003abf06 	br	81123b54 <__reset+0xfb103b54>
81125058:	d9c02785 	stb	r7,158(sp)
8112505c:	003a9b06 	br	81123acc <__reset+0xfb103acc>

81125060 <___vfprintf_internal_r>:
81125060:	deffb804 	addi	sp,sp,-288
81125064:	de00012e 	bgeu	sp,et,8112506c <___vfprintf_internal_r+0xc>
81125068:	003b68fa 	trap	3
8112506c:	dfc04715 	stw	ra,284(sp)
81125070:	ddc04515 	stw	r23,276(sp)
81125074:	dd404315 	stw	r21,268(sp)
81125078:	d9002c15 	stw	r4,176(sp)
8112507c:	282f883a 	mov	r23,r5
81125080:	302b883a 	mov	r21,r6
81125084:	d9c02d15 	stw	r7,180(sp)
81125088:	df004615 	stw	fp,280(sp)
8112508c:	dd804415 	stw	r22,272(sp)
81125090:	dd004215 	stw	r20,264(sp)
81125094:	dcc04115 	stw	r19,260(sp)
81125098:	dc804015 	stw	r18,256(sp)
8112509c:	dc403f15 	stw	r17,252(sp)
811250a0:	dc003e15 	stw	r16,248(sp)
811250a4:	112bd680 	call	8112bd68 <_localeconv_r>
811250a8:	10800017 	ldw	r2,0(r2)
811250ac:	1009883a 	mov	r4,r2
811250b0:	d8803415 	stw	r2,208(sp)
811250b4:	1122b480 	call	81122b48 <strlen>
811250b8:	d8803715 	stw	r2,220(sp)
811250bc:	d8802c17 	ldw	r2,176(sp)
811250c0:	10000226 	beq	r2,zero,811250cc <___vfprintf_internal_r+0x6c>
811250c4:	10800e17 	ldw	r2,56(r2)
811250c8:	1000f926 	beq	r2,zero,811254b0 <___vfprintf_internal_r+0x450>
811250cc:	b880030b 	ldhu	r2,12(r23)
811250d0:	10c8000c 	andi	r3,r2,8192
811250d4:	1800061e 	bne	r3,zero,811250f0 <___vfprintf_internal_r+0x90>
811250d8:	b9001917 	ldw	r4,100(r23)
811250dc:	00f7ffc4 	movi	r3,-8193
811250e0:	10880014 	ori	r2,r2,8192
811250e4:	20c6703a 	and	r3,r4,r3
811250e8:	b880030d 	sth	r2,12(r23)
811250ec:	b8c01915 	stw	r3,100(r23)
811250f0:	10c0020c 	andi	r3,r2,8
811250f4:	1800c126 	beq	r3,zero,811253fc <___vfprintf_internal_r+0x39c>
811250f8:	b8c00417 	ldw	r3,16(r23)
811250fc:	1800bf26 	beq	r3,zero,811253fc <___vfprintf_internal_r+0x39c>
81125100:	1080068c 	andi	r2,r2,26
81125104:	00c00284 	movi	r3,10
81125108:	10c0c426 	beq	r2,r3,8112541c <___vfprintf_internal_r+0x3bc>
8112510c:	d8c00404 	addi	r3,sp,16
81125110:	05204574 	movhi	r20,33045
81125114:	d9001e04 	addi	r4,sp,120
81125118:	a5011884 	addi	r20,r20,1122
8112511c:	d8c01e15 	stw	r3,120(sp)
81125120:	d8002015 	stw	zero,128(sp)
81125124:	d8001f15 	stw	zero,124(sp)
81125128:	d8003315 	stw	zero,204(sp)
8112512c:	d8003615 	stw	zero,216(sp)
81125130:	d8003815 	stw	zero,224(sp)
81125134:	1811883a 	mov	r8,r3
81125138:	d8003915 	stw	zero,228(sp)
8112513c:	d8003a15 	stw	zero,232(sp)
81125140:	d8002f15 	stw	zero,188(sp)
81125144:	d9002815 	stw	r4,160(sp)
81125148:	a8800007 	ldb	r2,0(r21)
8112514c:	10027b26 	beq	r2,zero,81125b3c <___vfprintf_internal_r+0xadc>
81125150:	00c00944 	movi	r3,37
81125154:	a821883a 	mov	r16,r21
81125158:	10c0021e 	bne	r2,r3,81125164 <___vfprintf_internal_r+0x104>
8112515c:	00001406 	br	811251b0 <___vfprintf_internal_r+0x150>
81125160:	10c00326 	beq	r2,r3,81125170 <___vfprintf_internal_r+0x110>
81125164:	84000044 	addi	r16,r16,1
81125168:	80800007 	ldb	r2,0(r16)
8112516c:	103ffc1e 	bne	r2,zero,81125160 <__reset+0xfb105160>
81125170:	8563c83a 	sub	r17,r16,r21
81125174:	88000e26 	beq	r17,zero,811251b0 <___vfprintf_internal_r+0x150>
81125178:	d8c02017 	ldw	r3,128(sp)
8112517c:	d8801f17 	ldw	r2,124(sp)
81125180:	45400015 	stw	r21,0(r8)
81125184:	1c47883a 	add	r3,r3,r17
81125188:	10800044 	addi	r2,r2,1
8112518c:	d8c02015 	stw	r3,128(sp)
81125190:	44400115 	stw	r17,4(r8)
81125194:	d8801f15 	stw	r2,124(sp)
81125198:	00c001c4 	movi	r3,7
8112519c:	1880a716 	blt	r3,r2,8112543c <___vfprintf_internal_r+0x3dc>
811251a0:	42000204 	addi	r8,r8,8
811251a4:	d9402f17 	ldw	r5,188(sp)
811251a8:	2c4b883a 	add	r5,r5,r17
811251ac:	d9402f15 	stw	r5,188(sp)
811251b0:	80800007 	ldb	r2,0(r16)
811251b4:	1000a826 	beq	r2,zero,81125458 <___vfprintf_internal_r+0x3f8>
811251b8:	84400047 	ldb	r17,1(r16)
811251bc:	00bfffc4 	movi	r2,-1
811251c0:	85400044 	addi	r21,r16,1
811251c4:	d8002785 	stb	zero,158(sp)
811251c8:	0007883a 	mov	r3,zero
811251cc:	000f883a 	mov	r7,zero
811251d0:	d8802915 	stw	r2,164(sp)
811251d4:	d8003115 	stw	zero,196(sp)
811251d8:	0025883a 	mov	r18,zero
811251dc:	01401604 	movi	r5,88
811251e0:	01800244 	movi	r6,9
811251e4:	02800a84 	movi	r10,42
811251e8:	02401b04 	movi	r9,108
811251ec:	ad400044 	addi	r21,r21,1
811251f0:	88bff804 	addi	r2,r17,-32
811251f4:	28830436 	bltu	r5,r2,81125e08 <___vfprintf_internal_r+0xda8>
811251f8:	100490ba 	slli	r2,r2,2
811251fc:	012044b4 	movhi	r4,33042
81125200:	21148404 	addi	r4,r4,21008
81125204:	1105883a 	add	r2,r2,r4
81125208:	10800017 	ldw	r2,0(r2)
8112520c:	1000683a 	jmp	r2
81125210:	81125d28 	cmpgeui	r4,r16,18804
81125214:	81125e08 	cmpgei	r4,r16,18808
81125218:	81125e08 	cmpgei	r4,r16,18808
8112521c:	81125d48 	cmpgei	r4,r16,18805
81125220:	81125e08 	cmpgei	r4,r16,18808
81125224:	81125e08 	cmpgei	r4,r16,18808
81125228:	81125e08 	cmpgei	r4,r16,18808
8112522c:	81125e08 	cmpgei	r4,r16,18808
81125230:	81125e08 	cmpgei	r4,r16,18808
81125234:	81125e08 	cmpgei	r4,r16,18808
81125238:	811254bc 	xorhi	r4,r16,18770
8112523c:	81125c64 	muli	r4,r16,18801
81125240:	81125e08 	cmpgei	r4,r16,18808
81125244:	81125384 	addi	r4,r16,18766
81125248:	811254e4 	muli	r4,r16,18771
8112524c:	81125e08 	cmpgei	r4,r16,18808
81125250:	81125524 	muli	r4,r16,18772
81125254:	81125530 	cmpltui	r4,r16,18772
81125258:	81125530 	cmpltui	r4,r16,18772
8112525c:	81125530 	cmpltui	r4,r16,18772
81125260:	81125530 	cmpltui	r4,r16,18772
81125264:	81125530 	cmpltui	r4,r16,18772
81125268:	81125530 	cmpltui	r4,r16,18772
8112526c:	81125530 	cmpltui	r4,r16,18772
81125270:	81125530 	cmpltui	r4,r16,18772
81125274:	81125530 	cmpltui	r4,r16,18772
81125278:	81125e08 	cmpgei	r4,r16,18808
8112527c:	81125e08 	cmpgei	r4,r16,18808
81125280:	81125e08 	cmpgei	r4,r16,18808
81125284:	81125e08 	cmpgei	r4,r16,18808
81125288:	81125e08 	cmpgei	r4,r16,18808
8112528c:	81125e08 	cmpgei	r4,r16,18808
81125290:	81125e08 	cmpgei	r4,r16,18808
81125294:	81125e08 	cmpgei	r4,r16,18808
81125298:	81125e08 	cmpgei	r4,r16,18808
8112529c:	81125e08 	cmpgei	r4,r16,18808
811252a0:	81125564 	muli	r4,r16,18773
811252a4:	81125620 	cmpeqi	r4,r16,18776
811252a8:	81125e08 	cmpgei	r4,r16,18808
811252ac:	81125620 	cmpeqi	r4,r16,18776
811252b0:	81125e08 	cmpgei	r4,r16,18808
811252b4:	81125e08 	cmpgei	r4,r16,18808
811252b8:	81125e08 	cmpgei	r4,r16,18808
811252bc:	81125e08 	cmpgei	r4,r16,18808
811252c0:	811256c0 	call	8811256c <__reset+0x20f256c>
811252c4:	81125e08 	cmpgei	r4,r16,18808
811252c8:	81125e08 	cmpgei	r4,r16,18808
811252cc:	811256cc 	andi	r4,r16,18779
811252d0:	81125e08 	cmpgei	r4,r16,18808
811252d4:	81125e08 	cmpgei	r4,r16,18808
811252d8:	81125e08 	cmpgei	r4,r16,18808
811252dc:	81125e08 	cmpgei	r4,r16,18808
811252e0:	81125e08 	cmpgei	r4,r16,18808
811252e4:	81125b44 	addi	r4,r16,18797
811252e8:	81125e08 	cmpgei	r4,r16,18808
811252ec:	81125e08 	cmpgei	r4,r16,18808
811252f0:	81125ba4 	muli	r4,r16,18798
811252f4:	81125e08 	cmpgei	r4,r16,18808
811252f8:	81125e08 	cmpgei	r4,r16,18808
811252fc:	81125e08 	cmpgei	r4,r16,18808
81125300:	81125e08 	cmpgei	r4,r16,18808
81125304:	81125e08 	cmpgei	r4,r16,18808
81125308:	81125e08 	cmpgei	r4,r16,18808
8112530c:	81125e08 	cmpgei	r4,r16,18808
81125310:	81125e08 	cmpgei	r4,r16,18808
81125314:	81125e08 	cmpgei	r4,r16,18808
81125318:	81125e08 	cmpgei	r4,r16,18808
8112531c:	81125db4 	orhi	r4,r16,18806
81125320:	81125d54 	ori	r4,r16,18805
81125324:	81125620 	cmpeqi	r4,r16,18776
81125328:	81125620 	cmpeqi	r4,r16,18776
8112532c:	81125620 	cmpeqi	r4,r16,18776
81125330:	81125d64 	muli	r4,r16,18805
81125334:	81125d54 	ori	r4,r16,18805
81125338:	81125e08 	cmpgei	r4,r16,18808
8112533c:	81125e08 	cmpgei	r4,r16,18808
81125340:	81125d70 	cmpltui	r4,r16,18805
81125344:	81125e08 	cmpgei	r4,r16,18808
81125348:	81125d80 	call	881125d8 <__reset+0x20f25d8>
8112534c:	81125c54 	ori	r4,r16,18801
81125350:	81125390 	cmplti	r4,r16,18766
81125354:	81125c74 	orhi	r4,r16,18801
81125358:	81125e08 	cmpgei	r4,r16,18808
8112535c:	81125c80 	call	881125c8 <__reset+0x20f25c8>
81125360:	81125e08 	cmpgei	r4,r16,18808
81125364:	81125cdc 	xori	r4,r16,18803
81125368:	81125e08 	cmpgei	r4,r16,18808
8112536c:	81125e08 	cmpgei	r4,r16,18808
81125370:	81125cec 	andhi	r4,r16,18803
81125374:	d9003117 	ldw	r4,196(sp)
81125378:	d8802d15 	stw	r2,180(sp)
8112537c:	0109c83a 	sub	r4,zero,r4
81125380:	d9003115 	stw	r4,196(sp)
81125384:	94800114 	ori	r18,r18,4
81125388:	ac400007 	ldb	r17,0(r21)
8112538c:	003f9706 	br	811251ec <__reset+0xfb1051ec>
81125390:	00800c04 	movi	r2,48
81125394:	d9002d17 	ldw	r4,180(sp)
81125398:	d9402917 	ldw	r5,164(sp)
8112539c:	d8802705 	stb	r2,156(sp)
811253a0:	00801e04 	movi	r2,120
811253a4:	d8802745 	stb	r2,157(sp)
811253a8:	d8002785 	stb	zero,158(sp)
811253ac:	20c00104 	addi	r3,r4,4
811253b0:	24c00017 	ldw	r19,0(r4)
811253b4:	002d883a 	mov	r22,zero
811253b8:	90800094 	ori	r2,r18,2
811253bc:	28029a16 	blt	r5,zero,81125e28 <___vfprintf_internal_r+0xdc8>
811253c0:	00bfdfc4 	movi	r2,-129
811253c4:	90a4703a 	and	r18,r18,r2
811253c8:	d8c02d15 	stw	r3,180(sp)
811253cc:	94800094 	ori	r18,r18,2
811253d0:	9802871e 	bne	r19,zero,81125df0 <___vfprintf_internal_r+0xd90>
811253d4:	00a04574 	movhi	r2,33045
811253d8:	10810904 	addi	r2,r2,1060
811253dc:	d8803915 	stw	r2,228(sp)
811253e0:	04401e04 	movi	r17,120
811253e4:	d8802917 	ldw	r2,164(sp)
811253e8:	0039883a 	mov	fp,zero
811253ec:	1001e926 	beq	r2,zero,81125b94 <___vfprintf_internal_r+0xb34>
811253f0:	0027883a 	mov	r19,zero
811253f4:	002d883a 	mov	r22,zero
811253f8:	00020506 	br	81125c10 <___vfprintf_internal_r+0xbb0>
811253fc:	d9002c17 	ldw	r4,176(sp)
81125400:	b80b883a 	mov	r5,r23
81125404:	1128dac0 	call	81128dac <__swsetup_r>
81125408:	1005ac1e 	bne	r2,zero,81126abc <___vfprintf_internal_r+0x1a5c>
8112540c:	b880030b 	ldhu	r2,12(r23)
81125410:	00c00284 	movi	r3,10
81125414:	1080068c 	andi	r2,r2,26
81125418:	10ff3c1e 	bne	r2,r3,8112510c <__reset+0xfb10510c>
8112541c:	b880038f 	ldh	r2,14(r23)
81125420:	103f3a16 	blt	r2,zero,8112510c <__reset+0xfb10510c>
81125424:	d9c02d17 	ldw	r7,180(sp)
81125428:	d9002c17 	ldw	r4,176(sp)
8112542c:	a80d883a 	mov	r6,r21
81125430:	b80b883a 	mov	r5,r23
81125434:	112727c0 	call	8112727c <__sbprintf>
81125438:	00001106 	br	81125480 <___vfprintf_internal_r+0x420>
8112543c:	d9002c17 	ldw	r4,176(sp)
81125440:	d9801e04 	addi	r6,sp,120
81125444:	b80b883a 	mov	r5,r23
81125448:	11312500 	call	81131250 <__sprint_r>
8112544c:	1000081e 	bne	r2,zero,81125470 <___vfprintf_internal_r+0x410>
81125450:	da000404 	addi	r8,sp,16
81125454:	003f5306 	br	811251a4 <__reset+0xfb1051a4>
81125458:	d8802017 	ldw	r2,128(sp)
8112545c:	10000426 	beq	r2,zero,81125470 <___vfprintf_internal_r+0x410>
81125460:	d9002c17 	ldw	r4,176(sp)
81125464:	d9801e04 	addi	r6,sp,120
81125468:	b80b883a 	mov	r5,r23
8112546c:	11312500 	call	81131250 <__sprint_r>
81125470:	b880030b 	ldhu	r2,12(r23)
81125474:	1080100c 	andi	r2,r2,64
81125478:	1005901e 	bne	r2,zero,81126abc <___vfprintf_internal_r+0x1a5c>
8112547c:	d8802f17 	ldw	r2,188(sp)
81125480:	dfc04717 	ldw	ra,284(sp)
81125484:	df004617 	ldw	fp,280(sp)
81125488:	ddc04517 	ldw	r23,276(sp)
8112548c:	dd804417 	ldw	r22,272(sp)
81125490:	dd404317 	ldw	r21,268(sp)
81125494:	dd004217 	ldw	r20,264(sp)
81125498:	dcc04117 	ldw	r19,260(sp)
8112549c:	dc804017 	ldw	r18,256(sp)
811254a0:	dc403f17 	ldw	r17,252(sp)
811254a4:	dc003e17 	ldw	r16,248(sp)
811254a8:	dec04804 	addi	sp,sp,288
811254ac:	f800283a 	ret
811254b0:	d9002c17 	ldw	r4,176(sp)
811254b4:	112ae1c0 	call	8112ae1c <__sinit>
811254b8:	003f0406 	br	811250cc <__reset+0xfb1050cc>
811254bc:	d8802d17 	ldw	r2,180(sp)
811254c0:	d9002d17 	ldw	r4,180(sp)
811254c4:	10800017 	ldw	r2,0(r2)
811254c8:	d8803115 	stw	r2,196(sp)
811254cc:	20800104 	addi	r2,r4,4
811254d0:	d9003117 	ldw	r4,196(sp)
811254d4:	203fa716 	blt	r4,zero,81125374 <__reset+0xfb105374>
811254d8:	d8802d15 	stw	r2,180(sp)
811254dc:	ac400007 	ldb	r17,0(r21)
811254e0:	003f4206 	br	811251ec <__reset+0xfb1051ec>
811254e4:	ac400007 	ldb	r17,0(r21)
811254e8:	aac00044 	addi	r11,r21,1
811254ec:	8a872826 	beq	r17,r10,81127190 <___vfprintf_internal_r+0x2130>
811254f0:	88bff404 	addi	r2,r17,-48
811254f4:	0009883a 	mov	r4,zero
811254f8:	30867d36 	bltu	r6,r2,81126ef0 <___vfprintf_internal_r+0x1e90>
811254fc:	5c400007 	ldb	r17,0(r11)
81125500:	210002a4 	muli	r4,r4,10
81125504:	5d400044 	addi	r21,r11,1
81125508:	a817883a 	mov	r11,r21
8112550c:	2089883a 	add	r4,r4,r2
81125510:	88bff404 	addi	r2,r17,-48
81125514:	30bff92e 	bgeu	r6,r2,811254fc <__reset+0xfb1054fc>
81125518:	2005c916 	blt	r4,zero,81126c40 <___vfprintf_internal_r+0x1be0>
8112551c:	d9002915 	stw	r4,164(sp)
81125520:	003f3306 	br	811251f0 <__reset+0xfb1051f0>
81125524:	94802014 	ori	r18,r18,128
81125528:	ac400007 	ldb	r17,0(r21)
8112552c:	003f2f06 	br	811251ec <__reset+0xfb1051ec>
81125530:	a809883a 	mov	r4,r21
81125534:	d8003115 	stw	zero,196(sp)
81125538:	88bff404 	addi	r2,r17,-48
8112553c:	0017883a 	mov	r11,zero
81125540:	24400007 	ldb	r17,0(r4)
81125544:	5ac002a4 	muli	r11,r11,10
81125548:	ad400044 	addi	r21,r21,1
8112554c:	a809883a 	mov	r4,r21
81125550:	12d7883a 	add	r11,r2,r11
81125554:	88bff404 	addi	r2,r17,-48
81125558:	30bff92e 	bgeu	r6,r2,81125540 <__reset+0xfb105540>
8112555c:	dac03115 	stw	r11,196(sp)
81125560:	003f2306 	br	811251f0 <__reset+0xfb1051f0>
81125564:	18c03fcc 	andi	r3,r3,255
81125568:	18072b1e 	bne	r3,zero,81127218 <___vfprintf_internal_r+0x21b8>
8112556c:	94800414 	ori	r18,r18,16
81125570:	9080080c 	andi	r2,r18,32
81125574:	10037b26 	beq	r2,zero,81126364 <___vfprintf_internal_r+0x1304>
81125578:	d9402d17 	ldw	r5,180(sp)
8112557c:	28800117 	ldw	r2,4(r5)
81125580:	2cc00017 	ldw	r19,0(r5)
81125584:	29400204 	addi	r5,r5,8
81125588:	d9402d15 	stw	r5,180(sp)
8112558c:	102d883a 	mov	r22,r2
81125590:	10044b16 	blt	r2,zero,811266c0 <___vfprintf_internal_r+0x1660>
81125594:	d9402917 	ldw	r5,164(sp)
81125598:	df002783 	ldbu	fp,158(sp)
8112559c:	2803bc16 	blt	r5,zero,81126490 <___vfprintf_internal_r+0x1430>
811255a0:	00ffdfc4 	movi	r3,-129
811255a4:	9d84b03a 	or	r2,r19,r22
811255a8:	90e4703a 	and	r18,r18,r3
811255ac:	10017726 	beq	r2,zero,81125b8c <___vfprintf_internal_r+0xb2c>
811255b0:	b0038326 	beq	r22,zero,811263c0 <___vfprintf_internal_r+0x1360>
811255b4:	dc402a15 	stw	r17,168(sp)
811255b8:	dc001e04 	addi	r16,sp,120
811255bc:	b023883a 	mov	r17,r22
811255c0:	402d883a 	mov	r22,r8
811255c4:	9809883a 	mov	r4,r19
811255c8:	880b883a 	mov	r5,r17
811255cc:	01800284 	movi	r6,10
811255d0:	000f883a 	mov	r7,zero
811255d4:	1133f880 	call	81133f88 <__umoddi3>
811255d8:	10800c04 	addi	r2,r2,48
811255dc:	843fffc4 	addi	r16,r16,-1
811255e0:	9809883a 	mov	r4,r19
811255e4:	880b883a 	mov	r5,r17
811255e8:	80800005 	stb	r2,0(r16)
811255ec:	01800284 	movi	r6,10
811255f0:	000f883a 	mov	r7,zero
811255f4:	1133a080 	call	81133a08 <__udivdi3>
811255f8:	1027883a 	mov	r19,r2
811255fc:	10c4b03a 	or	r2,r2,r3
81125600:	1823883a 	mov	r17,r3
81125604:	103fef1e 	bne	r2,zero,811255c4 <__reset+0xfb1055c4>
81125608:	d8c02817 	ldw	r3,160(sp)
8112560c:	dc402a17 	ldw	r17,168(sp)
81125610:	b011883a 	mov	r8,r22
81125614:	1c07c83a 	sub	r3,r3,r16
81125618:	d8c02e15 	stw	r3,184(sp)
8112561c:	00005906 	br	81125784 <___vfprintf_internal_r+0x724>
81125620:	18c03fcc 	andi	r3,r3,255
81125624:	1806fa1e 	bne	r3,zero,81127210 <___vfprintf_internal_r+0x21b0>
81125628:	9080020c 	andi	r2,r18,8
8112562c:	10048a26 	beq	r2,zero,81126858 <___vfprintf_internal_r+0x17f8>
81125630:	d8c02d17 	ldw	r3,180(sp)
81125634:	d9002d17 	ldw	r4,180(sp)
81125638:	d9402d17 	ldw	r5,180(sp)
8112563c:	18c00017 	ldw	r3,0(r3)
81125640:	21000117 	ldw	r4,4(r4)
81125644:	29400204 	addi	r5,r5,8
81125648:	d8c03615 	stw	r3,216(sp)
8112564c:	d9003815 	stw	r4,224(sp)
81125650:	d9402d15 	stw	r5,180(sp)
81125654:	d9003617 	ldw	r4,216(sp)
81125658:	d9403817 	ldw	r5,224(sp)
8112565c:	da003d15 	stw	r8,244(sp)
81125660:	04000044 	movi	r16,1
81125664:	112d8b40 	call	8112d8b4 <__fpclassifyd>
81125668:	da003d17 	ldw	r8,244(sp)
8112566c:	14041f1e 	bne	r2,r16,811266ec <___vfprintf_internal_r+0x168c>
81125670:	d9003617 	ldw	r4,216(sp)
81125674:	d9403817 	ldw	r5,224(sp)
81125678:	000d883a 	mov	r6,zero
8112567c:	000f883a 	mov	r7,zero
81125680:	1135aa40 	call	81135aa4 <__ledf2>
81125684:	da003d17 	ldw	r8,244(sp)
81125688:	1005be16 	blt	r2,zero,81126d84 <___vfprintf_internal_r+0x1d24>
8112568c:	df002783 	ldbu	fp,158(sp)
81125690:	008011c4 	movi	r2,71
81125694:	1445330e 	bge	r2,r17,81126b64 <___vfprintf_internal_r+0x1b04>
81125698:	04204574 	movhi	r16,33045
8112569c:	84010104 	addi	r16,r16,1028
811256a0:	00c000c4 	movi	r3,3
811256a4:	00bfdfc4 	movi	r2,-129
811256a8:	d8c02a15 	stw	r3,168(sp)
811256ac:	90a4703a 	and	r18,r18,r2
811256b0:	d8c02e15 	stw	r3,184(sp)
811256b4:	d8002915 	stw	zero,164(sp)
811256b8:	d8003215 	stw	zero,200(sp)
811256bc:	00003706 	br	8112579c <___vfprintf_internal_r+0x73c>
811256c0:	94800214 	ori	r18,r18,8
811256c4:	ac400007 	ldb	r17,0(r21)
811256c8:	003ec806 	br	811251ec <__reset+0xfb1051ec>
811256cc:	18c03fcc 	andi	r3,r3,255
811256d0:	1806db1e 	bne	r3,zero,81127240 <___vfprintf_internal_r+0x21e0>
811256d4:	94800414 	ori	r18,r18,16
811256d8:	9080080c 	andi	r2,r18,32
811256dc:	1002d826 	beq	r2,zero,81126240 <___vfprintf_internal_r+0x11e0>
811256e0:	d9402d17 	ldw	r5,180(sp)
811256e4:	d8c02917 	ldw	r3,164(sp)
811256e8:	d8002785 	stb	zero,158(sp)
811256ec:	28800204 	addi	r2,r5,8
811256f0:	2cc00017 	ldw	r19,0(r5)
811256f4:	2d800117 	ldw	r22,4(r5)
811256f8:	18048f16 	blt	r3,zero,81126938 <___vfprintf_internal_r+0x18d8>
811256fc:	013fdfc4 	movi	r4,-129
81125700:	9d86b03a 	or	r3,r19,r22
81125704:	d8802d15 	stw	r2,180(sp)
81125708:	9124703a 	and	r18,r18,r4
8112570c:	1802d91e 	bne	r3,zero,81126274 <___vfprintf_internal_r+0x1214>
81125710:	d8c02917 	ldw	r3,164(sp)
81125714:	0039883a 	mov	fp,zero
81125718:	1805c326 	beq	r3,zero,81126e28 <___vfprintf_internal_r+0x1dc8>
8112571c:	0027883a 	mov	r19,zero
81125720:	002d883a 	mov	r22,zero
81125724:	dc001e04 	addi	r16,sp,120
81125728:	9806d0fa 	srli	r3,r19,3
8112572c:	b008977a 	slli	r4,r22,29
81125730:	b02cd0fa 	srli	r22,r22,3
81125734:	9cc001cc 	andi	r19,r19,7
81125738:	98800c04 	addi	r2,r19,48
8112573c:	843fffc4 	addi	r16,r16,-1
81125740:	20e6b03a 	or	r19,r4,r3
81125744:	80800005 	stb	r2,0(r16)
81125748:	9d86b03a 	or	r3,r19,r22
8112574c:	183ff61e 	bne	r3,zero,81125728 <__reset+0xfb105728>
81125750:	90c0004c 	andi	r3,r18,1
81125754:	18013b26 	beq	r3,zero,81125c44 <___vfprintf_internal_r+0xbe4>
81125758:	10803fcc 	andi	r2,r2,255
8112575c:	1080201c 	xori	r2,r2,128
81125760:	10bfe004 	addi	r2,r2,-128
81125764:	00c00c04 	movi	r3,48
81125768:	10c13626 	beq	r2,r3,81125c44 <___vfprintf_internal_r+0xbe4>
8112576c:	80ffffc5 	stb	r3,-1(r16)
81125770:	d8c02817 	ldw	r3,160(sp)
81125774:	80bfffc4 	addi	r2,r16,-1
81125778:	1021883a 	mov	r16,r2
8112577c:	1887c83a 	sub	r3,r3,r2
81125780:	d8c02e15 	stw	r3,184(sp)
81125784:	d8802e17 	ldw	r2,184(sp)
81125788:	d9002917 	ldw	r4,164(sp)
8112578c:	1100010e 	bge	r2,r4,81125794 <___vfprintf_internal_r+0x734>
81125790:	2005883a 	mov	r2,r4
81125794:	d8802a15 	stw	r2,168(sp)
81125798:	d8003215 	stw	zero,200(sp)
8112579c:	e7003fcc 	andi	fp,fp,255
811257a0:	e700201c 	xori	fp,fp,128
811257a4:	e73fe004 	addi	fp,fp,-128
811257a8:	e0000326 	beq	fp,zero,811257b8 <___vfprintf_internal_r+0x758>
811257ac:	d8c02a17 	ldw	r3,168(sp)
811257b0:	18c00044 	addi	r3,r3,1
811257b4:	d8c02a15 	stw	r3,168(sp)
811257b8:	90c0008c 	andi	r3,r18,2
811257bc:	d8c02b15 	stw	r3,172(sp)
811257c0:	18000326 	beq	r3,zero,811257d0 <___vfprintf_internal_r+0x770>
811257c4:	d8c02a17 	ldw	r3,168(sp)
811257c8:	18c00084 	addi	r3,r3,2
811257cc:	d8c02a15 	stw	r3,168(sp)
811257d0:	90c0210c 	andi	r3,r18,132
811257d4:	d8c03015 	stw	r3,192(sp)
811257d8:	1801a31e 	bne	r3,zero,81125e68 <___vfprintf_internal_r+0xe08>
811257dc:	d9003117 	ldw	r4,196(sp)
811257e0:	d8c02a17 	ldw	r3,168(sp)
811257e4:	20e7c83a 	sub	r19,r4,r3
811257e8:	04c19f0e 	bge	zero,r19,81125e68 <___vfprintf_internal_r+0xe08>
811257ec:	02400404 	movi	r9,16
811257f0:	d8c02017 	ldw	r3,128(sp)
811257f4:	d8801f17 	ldw	r2,124(sp)
811257f8:	4cc50d0e 	bge	r9,r19,81126c30 <___vfprintf_internal_r+0x1bd0>
811257fc:	01604574 	movhi	r5,33045
81125800:	29411c84 	addi	r5,r5,1138
81125804:	dc403b15 	stw	r17,236(sp)
81125808:	d9403515 	stw	r5,212(sp)
8112580c:	9823883a 	mov	r17,r19
81125810:	482d883a 	mov	r22,r9
81125814:	9027883a 	mov	r19,r18
81125818:	070001c4 	movi	fp,7
8112581c:	8025883a 	mov	r18,r16
81125820:	dc002c17 	ldw	r16,176(sp)
81125824:	00000306 	br	81125834 <___vfprintf_internal_r+0x7d4>
81125828:	8c7ffc04 	addi	r17,r17,-16
8112582c:	42000204 	addi	r8,r8,8
81125830:	b440130e 	bge	r22,r17,81125880 <___vfprintf_internal_r+0x820>
81125834:	01204574 	movhi	r4,33045
81125838:	18c00404 	addi	r3,r3,16
8112583c:	10800044 	addi	r2,r2,1
81125840:	21011c84 	addi	r4,r4,1138
81125844:	41000015 	stw	r4,0(r8)
81125848:	45800115 	stw	r22,4(r8)
8112584c:	d8c02015 	stw	r3,128(sp)
81125850:	d8801f15 	stw	r2,124(sp)
81125854:	e0bff40e 	bge	fp,r2,81125828 <__reset+0xfb105828>
81125858:	d9801e04 	addi	r6,sp,120
8112585c:	b80b883a 	mov	r5,r23
81125860:	8009883a 	mov	r4,r16
81125864:	11312500 	call	81131250 <__sprint_r>
81125868:	103f011e 	bne	r2,zero,81125470 <__reset+0xfb105470>
8112586c:	8c7ffc04 	addi	r17,r17,-16
81125870:	d8c02017 	ldw	r3,128(sp)
81125874:	d8801f17 	ldw	r2,124(sp)
81125878:	da000404 	addi	r8,sp,16
8112587c:	b47fed16 	blt	r22,r17,81125834 <__reset+0xfb105834>
81125880:	9021883a 	mov	r16,r18
81125884:	9825883a 	mov	r18,r19
81125888:	8827883a 	mov	r19,r17
8112588c:	dc403b17 	ldw	r17,236(sp)
81125890:	d9403517 	ldw	r5,212(sp)
81125894:	98c7883a 	add	r3,r19,r3
81125898:	10800044 	addi	r2,r2,1
8112589c:	41400015 	stw	r5,0(r8)
811258a0:	44c00115 	stw	r19,4(r8)
811258a4:	d8c02015 	stw	r3,128(sp)
811258a8:	d8801f15 	stw	r2,124(sp)
811258ac:	010001c4 	movi	r4,7
811258b0:	2082a316 	blt	r4,r2,81126340 <___vfprintf_internal_r+0x12e0>
811258b4:	df002787 	ldb	fp,158(sp)
811258b8:	42000204 	addi	r8,r8,8
811258bc:	e0000c26 	beq	fp,zero,811258f0 <___vfprintf_internal_r+0x890>
811258c0:	d8801f17 	ldw	r2,124(sp)
811258c4:	d9002784 	addi	r4,sp,158
811258c8:	18c00044 	addi	r3,r3,1
811258cc:	10800044 	addi	r2,r2,1
811258d0:	41000015 	stw	r4,0(r8)
811258d4:	01000044 	movi	r4,1
811258d8:	41000115 	stw	r4,4(r8)
811258dc:	d8c02015 	stw	r3,128(sp)
811258e0:	d8801f15 	stw	r2,124(sp)
811258e4:	010001c4 	movi	r4,7
811258e8:	20823c16 	blt	r4,r2,811261dc <___vfprintf_internal_r+0x117c>
811258ec:	42000204 	addi	r8,r8,8
811258f0:	d8802b17 	ldw	r2,172(sp)
811258f4:	10000c26 	beq	r2,zero,81125928 <___vfprintf_internal_r+0x8c8>
811258f8:	d8801f17 	ldw	r2,124(sp)
811258fc:	d9002704 	addi	r4,sp,156
81125900:	18c00084 	addi	r3,r3,2
81125904:	10800044 	addi	r2,r2,1
81125908:	41000015 	stw	r4,0(r8)
8112590c:	01000084 	movi	r4,2
81125910:	41000115 	stw	r4,4(r8)
81125914:	d8c02015 	stw	r3,128(sp)
81125918:	d8801f15 	stw	r2,124(sp)
8112591c:	010001c4 	movi	r4,7
81125920:	20823616 	blt	r4,r2,811261fc <___vfprintf_internal_r+0x119c>
81125924:	42000204 	addi	r8,r8,8
81125928:	d9003017 	ldw	r4,192(sp)
8112592c:	00802004 	movi	r2,128
81125930:	20819926 	beq	r4,r2,81125f98 <___vfprintf_internal_r+0xf38>
81125934:	d9402917 	ldw	r5,164(sp)
81125938:	d8802e17 	ldw	r2,184(sp)
8112593c:	28adc83a 	sub	r22,r5,r2
81125940:	0580310e 	bge	zero,r22,81125a08 <___vfprintf_internal_r+0x9a8>
81125944:	07000404 	movi	fp,16
81125948:	d8801f17 	ldw	r2,124(sp)
8112594c:	e584140e 	bge	fp,r22,811269a0 <___vfprintf_internal_r+0x1940>
81125950:	01604574 	movhi	r5,33045
81125954:	29411884 	addi	r5,r5,1122
81125958:	dc402915 	stw	r17,164(sp)
8112595c:	d9402b15 	stw	r5,172(sp)
81125960:	b023883a 	mov	r17,r22
81125964:	04c001c4 	movi	r19,7
81125968:	a82d883a 	mov	r22,r21
8112596c:	902b883a 	mov	r21,r18
81125970:	8025883a 	mov	r18,r16
81125974:	dc002c17 	ldw	r16,176(sp)
81125978:	00000306 	br	81125988 <___vfprintf_internal_r+0x928>
8112597c:	8c7ffc04 	addi	r17,r17,-16
81125980:	42000204 	addi	r8,r8,8
81125984:	e440110e 	bge	fp,r17,811259cc <___vfprintf_internal_r+0x96c>
81125988:	18c00404 	addi	r3,r3,16
8112598c:	10800044 	addi	r2,r2,1
81125990:	45000015 	stw	r20,0(r8)
81125994:	47000115 	stw	fp,4(r8)
81125998:	d8c02015 	stw	r3,128(sp)
8112599c:	d8801f15 	stw	r2,124(sp)
811259a0:	98bff60e 	bge	r19,r2,8112597c <__reset+0xfb10597c>
811259a4:	d9801e04 	addi	r6,sp,120
811259a8:	b80b883a 	mov	r5,r23
811259ac:	8009883a 	mov	r4,r16
811259b0:	11312500 	call	81131250 <__sprint_r>
811259b4:	103eae1e 	bne	r2,zero,81125470 <__reset+0xfb105470>
811259b8:	8c7ffc04 	addi	r17,r17,-16
811259bc:	d8c02017 	ldw	r3,128(sp)
811259c0:	d8801f17 	ldw	r2,124(sp)
811259c4:	da000404 	addi	r8,sp,16
811259c8:	e47fef16 	blt	fp,r17,81125988 <__reset+0xfb105988>
811259cc:	9021883a 	mov	r16,r18
811259d0:	a825883a 	mov	r18,r21
811259d4:	b02b883a 	mov	r21,r22
811259d8:	882d883a 	mov	r22,r17
811259dc:	dc402917 	ldw	r17,164(sp)
811259e0:	d9002b17 	ldw	r4,172(sp)
811259e4:	1d87883a 	add	r3,r3,r22
811259e8:	10800044 	addi	r2,r2,1
811259ec:	41000015 	stw	r4,0(r8)
811259f0:	45800115 	stw	r22,4(r8)
811259f4:	d8c02015 	stw	r3,128(sp)
811259f8:	d8801f15 	stw	r2,124(sp)
811259fc:	010001c4 	movi	r4,7
81125a00:	2081ee16 	blt	r4,r2,811261bc <___vfprintf_internal_r+0x115c>
81125a04:	42000204 	addi	r8,r8,8
81125a08:	9080400c 	andi	r2,r18,256
81125a0c:	1001181e 	bne	r2,zero,81125e70 <___vfprintf_internal_r+0xe10>
81125a10:	d9402e17 	ldw	r5,184(sp)
81125a14:	d8801f17 	ldw	r2,124(sp)
81125a18:	44000015 	stw	r16,0(r8)
81125a1c:	1947883a 	add	r3,r3,r5
81125a20:	10800044 	addi	r2,r2,1
81125a24:	41400115 	stw	r5,4(r8)
81125a28:	d8c02015 	stw	r3,128(sp)
81125a2c:	d8801f15 	stw	r2,124(sp)
81125a30:	010001c4 	movi	r4,7
81125a34:	2081d316 	blt	r4,r2,81126184 <___vfprintf_internal_r+0x1124>
81125a38:	42000204 	addi	r8,r8,8
81125a3c:	9480010c 	andi	r18,r18,4
81125a40:	90003226 	beq	r18,zero,81125b0c <___vfprintf_internal_r+0xaac>
81125a44:	d9403117 	ldw	r5,196(sp)
81125a48:	d8802a17 	ldw	r2,168(sp)
81125a4c:	28a1c83a 	sub	r16,r5,r2
81125a50:	04002e0e 	bge	zero,r16,81125b0c <___vfprintf_internal_r+0xaac>
81125a54:	04400404 	movi	r17,16
81125a58:	d8801f17 	ldw	r2,124(sp)
81125a5c:	8c04a20e 	bge	r17,r16,81126ce8 <___vfprintf_internal_r+0x1c88>
81125a60:	01604574 	movhi	r5,33045
81125a64:	29411c84 	addi	r5,r5,1138
81125a68:	d9403515 	stw	r5,212(sp)
81125a6c:	048001c4 	movi	r18,7
81125a70:	dcc02c17 	ldw	r19,176(sp)
81125a74:	00000306 	br	81125a84 <___vfprintf_internal_r+0xa24>
81125a78:	843ffc04 	addi	r16,r16,-16
81125a7c:	42000204 	addi	r8,r8,8
81125a80:	8c00130e 	bge	r17,r16,81125ad0 <___vfprintf_internal_r+0xa70>
81125a84:	01204574 	movhi	r4,33045
81125a88:	18c00404 	addi	r3,r3,16
81125a8c:	10800044 	addi	r2,r2,1
81125a90:	21011c84 	addi	r4,r4,1138
81125a94:	41000015 	stw	r4,0(r8)
81125a98:	44400115 	stw	r17,4(r8)
81125a9c:	d8c02015 	stw	r3,128(sp)
81125aa0:	d8801f15 	stw	r2,124(sp)
81125aa4:	90bff40e 	bge	r18,r2,81125a78 <__reset+0xfb105a78>
81125aa8:	d9801e04 	addi	r6,sp,120
81125aac:	b80b883a 	mov	r5,r23
81125ab0:	9809883a 	mov	r4,r19
81125ab4:	11312500 	call	81131250 <__sprint_r>
81125ab8:	103e6d1e 	bne	r2,zero,81125470 <__reset+0xfb105470>
81125abc:	843ffc04 	addi	r16,r16,-16
81125ac0:	d8c02017 	ldw	r3,128(sp)
81125ac4:	d8801f17 	ldw	r2,124(sp)
81125ac8:	da000404 	addi	r8,sp,16
81125acc:	8c3fed16 	blt	r17,r16,81125a84 <__reset+0xfb105a84>
81125ad0:	d9403517 	ldw	r5,212(sp)
81125ad4:	1c07883a 	add	r3,r3,r16
81125ad8:	10800044 	addi	r2,r2,1
81125adc:	41400015 	stw	r5,0(r8)
81125ae0:	44000115 	stw	r16,4(r8)
81125ae4:	d8c02015 	stw	r3,128(sp)
81125ae8:	d8801f15 	stw	r2,124(sp)
81125aec:	010001c4 	movi	r4,7
81125af0:	2080060e 	bge	r4,r2,81125b0c <___vfprintf_internal_r+0xaac>
81125af4:	d9002c17 	ldw	r4,176(sp)
81125af8:	d9801e04 	addi	r6,sp,120
81125afc:	b80b883a 	mov	r5,r23
81125b00:	11312500 	call	81131250 <__sprint_r>
81125b04:	103e5a1e 	bne	r2,zero,81125470 <__reset+0xfb105470>
81125b08:	d8c02017 	ldw	r3,128(sp)
81125b0c:	d8803117 	ldw	r2,196(sp)
81125b10:	d9002a17 	ldw	r4,168(sp)
81125b14:	1100010e 	bge	r2,r4,81125b1c <___vfprintf_internal_r+0xabc>
81125b18:	2005883a 	mov	r2,r4
81125b1c:	d9402f17 	ldw	r5,188(sp)
81125b20:	288b883a 	add	r5,r5,r2
81125b24:	d9402f15 	stw	r5,188(sp)
81125b28:	18019e1e 	bne	r3,zero,811261a4 <___vfprintf_internal_r+0x1144>
81125b2c:	a8800007 	ldb	r2,0(r21)
81125b30:	d8001f15 	stw	zero,124(sp)
81125b34:	da000404 	addi	r8,sp,16
81125b38:	103d851e 	bne	r2,zero,81125150 <__reset+0xfb105150>
81125b3c:	a821883a 	mov	r16,r21
81125b40:	003d9b06 	br	811251b0 <__reset+0xfb1051b0>
81125b44:	18c03fcc 	andi	r3,r3,255
81125b48:	1805c11e 	bne	r3,zero,81127250 <___vfprintf_internal_r+0x21f0>
81125b4c:	94800414 	ori	r18,r18,16
81125b50:	9080080c 	andi	r2,r18,32
81125b54:	10020c26 	beq	r2,zero,81126388 <___vfprintf_internal_r+0x1328>
81125b58:	d8802d17 	ldw	r2,180(sp)
81125b5c:	d9002917 	ldw	r4,164(sp)
81125b60:	d8002785 	stb	zero,158(sp)
81125b64:	10c00204 	addi	r3,r2,8
81125b68:	14c00017 	ldw	r19,0(r2)
81125b6c:	15800117 	ldw	r22,4(r2)
81125b70:	20040f16 	blt	r4,zero,81126bb0 <___vfprintf_internal_r+0x1b50>
81125b74:	013fdfc4 	movi	r4,-129
81125b78:	9d84b03a 	or	r2,r19,r22
81125b7c:	d8c02d15 	stw	r3,180(sp)
81125b80:	9124703a 	and	r18,r18,r4
81125b84:	0039883a 	mov	fp,zero
81125b88:	103e891e 	bne	r2,zero,811255b0 <__reset+0xfb1055b0>
81125b8c:	d9002917 	ldw	r4,164(sp)
81125b90:	2002c11e 	bne	r4,zero,81126698 <___vfprintf_internal_r+0x1638>
81125b94:	d8002915 	stw	zero,164(sp)
81125b98:	d8002e15 	stw	zero,184(sp)
81125b9c:	dc001e04 	addi	r16,sp,120
81125ba0:	003ef806 	br	81125784 <__reset+0xfb105784>
81125ba4:	18c03fcc 	andi	r3,r3,255
81125ba8:	18059d1e 	bne	r3,zero,81127220 <___vfprintf_internal_r+0x21c0>
81125bac:	01604574 	movhi	r5,33045
81125bb0:	29410404 	addi	r5,r5,1040
81125bb4:	d9403915 	stw	r5,228(sp)
81125bb8:	9080080c 	andi	r2,r18,32
81125bbc:	10005226 	beq	r2,zero,81125d08 <___vfprintf_internal_r+0xca8>
81125bc0:	d8802d17 	ldw	r2,180(sp)
81125bc4:	14c00017 	ldw	r19,0(r2)
81125bc8:	15800117 	ldw	r22,4(r2)
81125bcc:	10800204 	addi	r2,r2,8
81125bd0:	d8802d15 	stw	r2,180(sp)
81125bd4:	9080004c 	andi	r2,r18,1
81125bd8:	10019026 	beq	r2,zero,8112621c <___vfprintf_internal_r+0x11bc>
81125bdc:	9d84b03a 	or	r2,r19,r22
81125be0:	10036926 	beq	r2,zero,81126988 <___vfprintf_internal_r+0x1928>
81125be4:	d8c02917 	ldw	r3,164(sp)
81125be8:	00800c04 	movi	r2,48
81125bec:	d8802705 	stb	r2,156(sp)
81125bf0:	dc402745 	stb	r17,157(sp)
81125bf4:	d8002785 	stb	zero,158(sp)
81125bf8:	90800094 	ori	r2,r18,2
81125bfc:	18045d16 	blt	r3,zero,81126d74 <___vfprintf_internal_r+0x1d14>
81125c00:	00bfdfc4 	movi	r2,-129
81125c04:	90a4703a 	and	r18,r18,r2
81125c08:	94800094 	ori	r18,r18,2
81125c0c:	0039883a 	mov	fp,zero
81125c10:	d9003917 	ldw	r4,228(sp)
81125c14:	dc001e04 	addi	r16,sp,120
81125c18:	988003cc 	andi	r2,r19,15
81125c1c:	b006973a 	slli	r3,r22,28
81125c20:	2085883a 	add	r2,r4,r2
81125c24:	9826d13a 	srli	r19,r19,4
81125c28:	10800003 	ldbu	r2,0(r2)
81125c2c:	b02cd13a 	srli	r22,r22,4
81125c30:	843fffc4 	addi	r16,r16,-1
81125c34:	1ce6b03a 	or	r19,r3,r19
81125c38:	80800005 	stb	r2,0(r16)
81125c3c:	9d84b03a 	or	r2,r19,r22
81125c40:	103ff51e 	bne	r2,zero,81125c18 <__reset+0xfb105c18>
81125c44:	d8c02817 	ldw	r3,160(sp)
81125c48:	1c07c83a 	sub	r3,r3,r16
81125c4c:	d8c02e15 	stw	r3,184(sp)
81125c50:	003ecc06 	br	81125784 <__reset+0xfb105784>
81125c54:	18c03fcc 	andi	r3,r3,255
81125c58:	183e9f26 	beq	r3,zero,811256d8 <__reset+0xfb1056d8>
81125c5c:	d9c02785 	stb	r7,158(sp)
81125c60:	003e9d06 	br	811256d8 <__reset+0xfb1056d8>
81125c64:	00c00044 	movi	r3,1
81125c68:	01c00ac4 	movi	r7,43
81125c6c:	ac400007 	ldb	r17,0(r21)
81125c70:	003d5e06 	br	811251ec <__reset+0xfb1051ec>
81125c74:	94800814 	ori	r18,r18,32
81125c78:	ac400007 	ldb	r17,0(r21)
81125c7c:	003d5b06 	br	811251ec <__reset+0xfb1051ec>
81125c80:	d8c02d17 	ldw	r3,180(sp)
81125c84:	d8002785 	stb	zero,158(sp)
81125c88:	1c000017 	ldw	r16,0(r3)
81125c8c:	1cc00104 	addi	r19,r3,4
81125c90:	80041926 	beq	r16,zero,81126cf8 <___vfprintf_internal_r+0x1c98>
81125c94:	d9002917 	ldw	r4,164(sp)
81125c98:	2003d016 	blt	r4,zero,81126bdc <___vfprintf_internal_r+0x1b7c>
81125c9c:	200d883a 	mov	r6,r4
81125ca0:	000b883a 	mov	r5,zero
81125ca4:	8009883a 	mov	r4,r16
81125ca8:	da003d15 	stw	r8,244(sp)
81125cac:	112c0440 	call	8112c044 <memchr>
81125cb0:	da003d17 	ldw	r8,244(sp)
81125cb4:	10045426 	beq	r2,zero,81126e08 <___vfprintf_internal_r+0x1da8>
81125cb8:	1405c83a 	sub	r2,r2,r16
81125cbc:	d8802e15 	stw	r2,184(sp)
81125cc0:	1003cc16 	blt	r2,zero,81126bf4 <___vfprintf_internal_r+0x1b94>
81125cc4:	df002783 	ldbu	fp,158(sp)
81125cc8:	d8802a15 	stw	r2,168(sp)
81125ccc:	dcc02d15 	stw	r19,180(sp)
81125cd0:	d8002915 	stw	zero,164(sp)
81125cd4:	d8003215 	stw	zero,200(sp)
81125cd8:	003eb006 	br	8112579c <__reset+0xfb10579c>
81125cdc:	18c03fcc 	andi	r3,r3,255
81125ce0:	183f9b26 	beq	r3,zero,81125b50 <__reset+0xfb105b50>
81125ce4:	d9c02785 	stb	r7,158(sp)
81125ce8:	003f9906 	br	81125b50 <__reset+0xfb105b50>
81125cec:	18c03fcc 	andi	r3,r3,255
81125cf0:	1805551e 	bne	r3,zero,81127248 <___vfprintf_internal_r+0x21e8>
81125cf4:	01604574 	movhi	r5,33045
81125cf8:	29410904 	addi	r5,r5,1060
81125cfc:	d9403915 	stw	r5,228(sp)
81125d00:	9080080c 	andi	r2,r18,32
81125d04:	103fae1e 	bne	r2,zero,81125bc0 <__reset+0xfb105bc0>
81125d08:	9080040c 	andi	r2,r18,16
81125d0c:	1002de26 	beq	r2,zero,81126888 <___vfprintf_internal_r+0x1828>
81125d10:	d8c02d17 	ldw	r3,180(sp)
81125d14:	002d883a 	mov	r22,zero
81125d18:	1cc00017 	ldw	r19,0(r3)
81125d1c:	18c00104 	addi	r3,r3,4
81125d20:	d8c02d15 	stw	r3,180(sp)
81125d24:	003fab06 	br	81125bd4 <__reset+0xfb105bd4>
81125d28:	38803fcc 	andi	r2,r7,255
81125d2c:	1080201c 	xori	r2,r2,128
81125d30:	10bfe004 	addi	r2,r2,-128
81125d34:	1002d21e 	bne	r2,zero,81126880 <___vfprintf_internal_r+0x1820>
81125d38:	00c00044 	movi	r3,1
81125d3c:	01c00804 	movi	r7,32
81125d40:	ac400007 	ldb	r17,0(r21)
81125d44:	003d2906 	br	811251ec <__reset+0xfb1051ec>
81125d48:	94800054 	ori	r18,r18,1
81125d4c:	ac400007 	ldb	r17,0(r21)
81125d50:	003d2606 	br	811251ec <__reset+0xfb1051ec>
81125d54:	18c03fcc 	andi	r3,r3,255
81125d58:	183e0526 	beq	r3,zero,81125570 <__reset+0xfb105570>
81125d5c:	d9c02785 	stb	r7,158(sp)
81125d60:	003e0306 	br	81125570 <__reset+0xfb105570>
81125d64:	94801014 	ori	r18,r18,64
81125d68:	ac400007 	ldb	r17,0(r21)
81125d6c:	003d1f06 	br	811251ec <__reset+0xfb1051ec>
81125d70:	ac400007 	ldb	r17,0(r21)
81125d74:	8a438726 	beq	r17,r9,81126b94 <___vfprintf_internal_r+0x1b34>
81125d78:	94800414 	ori	r18,r18,16
81125d7c:	003d1b06 	br	811251ec <__reset+0xfb1051ec>
81125d80:	18c03fcc 	andi	r3,r3,255
81125d84:	1805341e 	bne	r3,zero,81127258 <___vfprintf_internal_r+0x21f8>
81125d88:	9080080c 	andi	r2,r18,32
81125d8c:	1002cd26 	beq	r2,zero,811268c4 <___vfprintf_internal_r+0x1864>
81125d90:	d9402d17 	ldw	r5,180(sp)
81125d94:	d9002f17 	ldw	r4,188(sp)
81125d98:	28800017 	ldw	r2,0(r5)
81125d9c:	2007d7fa 	srai	r3,r4,31
81125da0:	29400104 	addi	r5,r5,4
81125da4:	d9402d15 	stw	r5,180(sp)
81125da8:	11000015 	stw	r4,0(r2)
81125dac:	10c00115 	stw	r3,4(r2)
81125db0:	003ce506 	br	81125148 <__reset+0xfb105148>
81125db4:	d8c02d17 	ldw	r3,180(sp)
81125db8:	d9002d17 	ldw	r4,180(sp)
81125dbc:	d8002785 	stb	zero,158(sp)
81125dc0:	18800017 	ldw	r2,0(r3)
81125dc4:	21000104 	addi	r4,r4,4
81125dc8:	00c00044 	movi	r3,1
81125dcc:	d8c02a15 	stw	r3,168(sp)
81125dd0:	d8801405 	stb	r2,80(sp)
81125dd4:	d9002d15 	stw	r4,180(sp)
81125dd8:	d8c02e15 	stw	r3,184(sp)
81125ddc:	d8002915 	stw	zero,164(sp)
81125de0:	d8003215 	stw	zero,200(sp)
81125de4:	dc001404 	addi	r16,sp,80
81125de8:	0039883a 	mov	fp,zero
81125dec:	003e7206 	br	811257b8 <__reset+0xfb1057b8>
81125df0:	01204574 	movhi	r4,33045
81125df4:	21010904 	addi	r4,r4,1060
81125df8:	0039883a 	mov	fp,zero
81125dfc:	d9003915 	stw	r4,228(sp)
81125e00:	04401e04 	movi	r17,120
81125e04:	003f8206 	br	81125c10 <__reset+0xfb105c10>
81125e08:	18c03fcc 	andi	r3,r3,255
81125e0c:	1805061e 	bne	r3,zero,81127228 <___vfprintf_internal_r+0x21c8>
81125e10:	883d9126 	beq	r17,zero,81125458 <__reset+0xfb105458>
81125e14:	00c00044 	movi	r3,1
81125e18:	d8c02a15 	stw	r3,168(sp)
81125e1c:	dc401405 	stb	r17,80(sp)
81125e20:	d8002785 	stb	zero,158(sp)
81125e24:	003fec06 	br	81125dd8 <__reset+0xfb105dd8>
81125e28:	01604574 	movhi	r5,33045
81125e2c:	29410904 	addi	r5,r5,1060
81125e30:	d9403915 	stw	r5,228(sp)
81125e34:	d8c02d15 	stw	r3,180(sp)
81125e38:	1025883a 	mov	r18,r2
81125e3c:	04401e04 	movi	r17,120
81125e40:	9d84b03a 	or	r2,r19,r22
81125e44:	1000fc1e 	bne	r2,zero,81126238 <___vfprintf_internal_r+0x11d8>
81125e48:	0039883a 	mov	fp,zero
81125e4c:	00800084 	movi	r2,2
81125e50:	10803fcc 	andi	r2,r2,255
81125e54:	00c00044 	movi	r3,1
81125e58:	10c20f26 	beq	r2,r3,81126698 <___vfprintf_internal_r+0x1638>
81125e5c:	00c00084 	movi	r3,2
81125e60:	10fd6326 	beq	r2,r3,811253f0 <__reset+0xfb1053f0>
81125e64:	003e2d06 	br	8112571c <__reset+0xfb10571c>
81125e68:	d8c02017 	ldw	r3,128(sp)
81125e6c:	003e9306 	br	811258bc <__reset+0xfb1058bc>
81125e70:	00801944 	movi	r2,101
81125e74:	14407e0e 	bge	r2,r17,81126070 <___vfprintf_internal_r+0x1010>
81125e78:	d9003617 	ldw	r4,216(sp)
81125e7c:	d9403817 	ldw	r5,224(sp)
81125e80:	000d883a 	mov	r6,zero
81125e84:	000f883a 	mov	r7,zero
81125e88:	d8c03c15 	stw	r3,240(sp)
81125e8c:	da003d15 	stw	r8,244(sp)
81125e90:	1135a1c0 	call	81135a1c <__eqdf2>
81125e94:	d8c03c17 	ldw	r3,240(sp)
81125e98:	da003d17 	ldw	r8,244(sp)
81125e9c:	1000f71e 	bne	r2,zero,8112627c <___vfprintf_internal_r+0x121c>
81125ea0:	d8801f17 	ldw	r2,124(sp)
81125ea4:	01204574 	movhi	r4,33045
81125ea8:	21011004 	addi	r4,r4,1088
81125eac:	18c00044 	addi	r3,r3,1
81125eb0:	10800044 	addi	r2,r2,1
81125eb4:	41000015 	stw	r4,0(r8)
81125eb8:	01000044 	movi	r4,1
81125ebc:	41000115 	stw	r4,4(r8)
81125ec0:	d8c02015 	stw	r3,128(sp)
81125ec4:	d8801f15 	stw	r2,124(sp)
81125ec8:	010001c4 	movi	r4,7
81125ecc:	2082b816 	blt	r4,r2,811269b0 <___vfprintf_internal_r+0x1950>
81125ed0:	42000204 	addi	r8,r8,8
81125ed4:	d8802617 	ldw	r2,152(sp)
81125ed8:	d9403317 	ldw	r5,204(sp)
81125edc:	11400216 	blt	r2,r5,81125ee8 <___vfprintf_internal_r+0xe88>
81125ee0:	9080004c 	andi	r2,r18,1
81125ee4:	103ed526 	beq	r2,zero,81125a3c <__reset+0xfb105a3c>
81125ee8:	d8803717 	ldw	r2,220(sp)
81125eec:	d9003417 	ldw	r4,208(sp)
81125ef0:	d9403717 	ldw	r5,220(sp)
81125ef4:	1887883a 	add	r3,r3,r2
81125ef8:	d8801f17 	ldw	r2,124(sp)
81125efc:	41000015 	stw	r4,0(r8)
81125f00:	41400115 	stw	r5,4(r8)
81125f04:	10800044 	addi	r2,r2,1
81125f08:	d8c02015 	stw	r3,128(sp)
81125f0c:	d8801f15 	stw	r2,124(sp)
81125f10:	010001c4 	movi	r4,7
81125f14:	20832916 	blt	r4,r2,81126bbc <___vfprintf_internal_r+0x1b5c>
81125f18:	42000204 	addi	r8,r8,8
81125f1c:	d8803317 	ldw	r2,204(sp)
81125f20:	143fffc4 	addi	r16,r2,-1
81125f24:	043ec50e 	bge	zero,r16,81125a3c <__reset+0xfb105a3c>
81125f28:	04400404 	movi	r17,16
81125f2c:	d8801f17 	ldw	r2,124(sp)
81125f30:	8c00880e 	bge	r17,r16,81126154 <___vfprintf_internal_r+0x10f4>
81125f34:	01604574 	movhi	r5,33045
81125f38:	29411884 	addi	r5,r5,1122
81125f3c:	d9402b15 	stw	r5,172(sp)
81125f40:	058001c4 	movi	r22,7
81125f44:	dcc02c17 	ldw	r19,176(sp)
81125f48:	00000306 	br	81125f58 <___vfprintf_internal_r+0xef8>
81125f4c:	42000204 	addi	r8,r8,8
81125f50:	843ffc04 	addi	r16,r16,-16
81125f54:	8c00820e 	bge	r17,r16,81126160 <___vfprintf_internal_r+0x1100>
81125f58:	18c00404 	addi	r3,r3,16
81125f5c:	10800044 	addi	r2,r2,1
81125f60:	45000015 	stw	r20,0(r8)
81125f64:	44400115 	stw	r17,4(r8)
81125f68:	d8c02015 	stw	r3,128(sp)
81125f6c:	d8801f15 	stw	r2,124(sp)
81125f70:	b0bff60e 	bge	r22,r2,81125f4c <__reset+0xfb105f4c>
81125f74:	d9801e04 	addi	r6,sp,120
81125f78:	b80b883a 	mov	r5,r23
81125f7c:	9809883a 	mov	r4,r19
81125f80:	11312500 	call	81131250 <__sprint_r>
81125f84:	103d3a1e 	bne	r2,zero,81125470 <__reset+0xfb105470>
81125f88:	d8c02017 	ldw	r3,128(sp)
81125f8c:	d8801f17 	ldw	r2,124(sp)
81125f90:	da000404 	addi	r8,sp,16
81125f94:	003fee06 	br	81125f50 <__reset+0xfb105f50>
81125f98:	d9403117 	ldw	r5,196(sp)
81125f9c:	d8802a17 	ldw	r2,168(sp)
81125fa0:	28adc83a 	sub	r22,r5,r2
81125fa4:	05be630e 	bge	zero,r22,81125934 <__reset+0xfb105934>
81125fa8:	07000404 	movi	fp,16
81125fac:	d8801f17 	ldw	r2,124(sp)
81125fb0:	e5838f0e 	bge	fp,r22,81126df0 <___vfprintf_internal_r+0x1d90>
81125fb4:	01604574 	movhi	r5,33045
81125fb8:	29411884 	addi	r5,r5,1122
81125fbc:	dc403015 	stw	r17,192(sp)
81125fc0:	d9402b15 	stw	r5,172(sp)
81125fc4:	b023883a 	mov	r17,r22
81125fc8:	04c001c4 	movi	r19,7
81125fcc:	a82d883a 	mov	r22,r21
81125fd0:	902b883a 	mov	r21,r18
81125fd4:	8025883a 	mov	r18,r16
81125fd8:	dc002c17 	ldw	r16,176(sp)
81125fdc:	00000306 	br	81125fec <___vfprintf_internal_r+0xf8c>
81125fe0:	8c7ffc04 	addi	r17,r17,-16
81125fe4:	42000204 	addi	r8,r8,8
81125fe8:	e440110e 	bge	fp,r17,81126030 <___vfprintf_internal_r+0xfd0>
81125fec:	18c00404 	addi	r3,r3,16
81125ff0:	10800044 	addi	r2,r2,1
81125ff4:	45000015 	stw	r20,0(r8)
81125ff8:	47000115 	stw	fp,4(r8)
81125ffc:	d8c02015 	stw	r3,128(sp)
81126000:	d8801f15 	stw	r2,124(sp)
81126004:	98bff60e 	bge	r19,r2,81125fe0 <__reset+0xfb105fe0>
81126008:	d9801e04 	addi	r6,sp,120
8112600c:	b80b883a 	mov	r5,r23
81126010:	8009883a 	mov	r4,r16
81126014:	11312500 	call	81131250 <__sprint_r>
81126018:	103d151e 	bne	r2,zero,81125470 <__reset+0xfb105470>
8112601c:	8c7ffc04 	addi	r17,r17,-16
81126020:	d8c02017 	ldw	r3,128(sp)
81126024:	d8801f17 	ldw	r2,124(sp)
81126028:	da000404 	addi	r8,sp,16
8112602c:	e47fef16 	blt	fp,r17,81125fec <__reset+0xfb105fec>
81126030:	9021883a 	mov	r16,r18
81126034:	a825883a 	mov	r18,r21
81126038:	b02b883a 	mov	r21,r22
8112603c:	882d883a 	mov	r22,r17
81126040:	dc403017 	ldw	r17,192(sp)
81126044:	d9002b17 	ldw	r4,172(sp)
81126048:	1d87883a 	add	r3,r3,r22
8112604c:	10800044 	addi	r2,r2,1
81126050:	41000015 	stw	r4,0(r8)
81126054:	45800115 	stw	r22,4(r8)
81126058:	d8c02015 	stw	r3,128(sp)
8112605c:	d8801f15 	stw	r2,124(sp)
81126060:	010001c4 	movi	r4,7
81126064:	20818e16 	blt	r4,r2,811266a0 <___vfprintf_internal_r+0x1640>
81126068:	42000204 	addi	r8,r8,8
8112606c:	003e3106 	br	81125934 <__reset+0xfb105934>
81126070:	d9403317 	ldw	r5,204(sp)
81126074:	00800044 	movi	r2,1
81126078:	18c00044 	addi	r3,r3,1
8112607c:	1141530e 	bge	r2,r5,811265cc <___vfprintf_internal_r+0x156c>
81126080:	dc401f17 	ldw	r17,124(sp)
81126084:	00800044 	movi	r2,1
81126088:	40800115 	stw	r2,4(r8)
8112608c:	8c400044 	addi	r17,r17,1
81126090:	44000015 	stw	r16,0(r8)
81126094:	d8c02015 	stw	r3,128(sp)
81126098:	dc401f15 	stw	r17,124(sp)
8112609c:	008001c4 	movi	r2,7
811260a0:	14416b16 	blt	r2,r17,81126650 <___vfprintf_internal_r+0x15f0>
811260a4:	42000204 	addi	r8,r8,8
811260a8:	d8803717 	ldw	r2,220(sp)
811260ac:	d9003417 	ldw	r4,208(sp)
811260b0:	8c400044 	addi	r17,r17,1
811260b4:	10c7883a 	add	r3,r2,r3
811260b8:	40800115 	stw	r2,4(r8)
811260bc:	41000015 	stw	r4,0(r8)
811260c0:	d8c02015 	stw	r3,128(sp)
811260c4:	dc401f15 	stw	r17,124(sp)
811260c8:	008001c4 	movi	r2,7
811260cc:	14416916 	blt	r2,r17,81126674 <___vfprintf_internal_r+0x1614>
811260d0:	45800204 	addi	r22,r8,8
811260d4:	d9003617 	ldw	r4,216(sp)
811260d8:	d9403817 	ldw	r5,224(sp)
811260dc:	000d883a 	mov	r6,zero
811260e0:	000f883a 	mov	r7,zero
811260e4:	d8c03c15 	stw	r3,240(sp)
811260e8:	1135a1c0 	call	81135a1c <__eqdf2>
811260ec:	d8c03c17 	ldw	r3,240(sp)
811260f0:	1000bc26 	beq	r2,zero,811263e4 <___vfprintf_internal_r+0x1384>
811260f4:	d9403317 	ldw	r5,204(sp)
811260f8:	84000044 	addi	r16,r16,1
811260fc:	8c400044 	addi	r17,r17,1
81126100:	28bfffc4 	addi	r2,r5,-1
81126104:	1887883a 	add	r3,r3,r2
81126108:	b0800115 	stw	r2,4(r22)
8112610c:	b4000015 	stw	r16,0(r22)
81126110:	d8c02015 	stw	r3,128(sp)
81126114:	dc401f15 	stw	r17,124(sp)
81126118:	008001c4 	movi	r2,7
8112611c:	14414316 	blt	r2,r17,8112662c <___vfprintf_internal_r+0x15cc>
81126120:	b5800204 	addi	r22,r22,8
81126124:	d9003a17 	ldw	r4,232(sp)
81126128:	df0022c4 	addi	fp,sp,139
8112612c:	8c400044 	addi	r17,r17,1
81126130:	20c7883a 	add	r3,r4,r3
81126134:	b7000015 	stw	fp,0(r22)
81126138:	b1000115 	stw	r4,4(r22)
8112613c:	d8c02015 	stw	r3,128(sp)
81126140:	dc401f15 	stw	r17,124(sp)
81126144:	008001c4 	movi	r2,7
81126148:	14400e16 	blt	r2,r17,81126184 <___vfprintf_internal_r+0x1124>
8112614c:	b2000204 	addi	r8,r22,8
81126150:	003e3a06 	br	81125a3c <__reset+0xfb105a3c>
81126154:	01204574 	movhi	r4,33045
81126158:	21011884 	addi	r4,r4,1122
8112615c:	d9002b15 	stw	r4,172(sp)
81126160:	d9002b17 	ldw	r4,172(sp)
81126164:	1c07883a 	add	r3,r3,r16
81126168:	44000115 	stw	r16,4(r8)
8112616c:	41000015 	stw	r4,0(r8)
81126170:	10800044 	addi	r2,r2,1
81126174:	d8c02015 	stw	r3,128(sp)
81126178:	d8801f15 	stw	r2,124(sp)
8112617c:	010001c4 	movi	r4,7
81126180:	20be2d0e 	bge	r4,r2,81125a38 <__reset+0xfb105a38>
81126184:	d9002c17 	ldw	r4,176(sp)
81126188:	d9801e04 	addi	r6,sp,120
8112618c:	b80b883a 	mov	r5,r23
81126190:	11312500 	call	81131250 <__sprint_r>
81126194:	103cb61e 	bne	r2,zero,81125470 <__reset+0xfb105470>
81126198:	d8c02017 	ldw	r3,128(sp)
8112619c:	da000404 	addi	r8,sp,16
811261a0:	003e2606 	br	81125a3c <__reset+0xfb105a3c>
811261a4:	d9002c17 	ldw	r4,176(sp)
811261a8:	d9801e04 	addi	r6,sp,120
811261ac:	b80b883a 	mov	r5,r23
811261b0:	11312500 	call	81131250 <__sprint_r>
811261b4:	103e5d26 	beq	r2,zero,81125b2c <__reset+0xfb105b2c>
811261b8:	003cad06 	br	81125470 <__reset+0xfb105470>
811261bc:	d9002c17 	ldw	r4,176(sp)
811261c0:	d9801e04 	addi	r6,sp,120
811261c4:	b80b883a 	mov	r5,r23
811261c8:	11312500 	call	81131250 <__sprint_r>
811261cc:	103ca81e 	bne	r2,zero,81125470 <__reset+0xfb105470>
811261d0:	d8c02017 	ldw	r3,128(sp)
811261d4:	da000404 	addi	r8,sp,16
811261d8:	003e0b06 	br	81125a08 <__reset+0xfb105a08>
811261dc:	d9002c17 	ldw	r4,176(sp)
811261e0:	d9801e04 	addi	r6,sp,120
811261e4:	b80b883a 	mov	r5,r23
811261e8:	11312500 	call	81131250 <__sprint_r>
811261ec:	103ca01e 	bne	r2,zero,81125470 <__reset+0xfb105470>
811261f0:	d8c02017 	ldw	r3,128(sp)
811261f4:	da000404 	addi	r8,sp,16
811261f8:	003dbd06 	br	811258f0 <__reset+0xfb1058f0>
811261fc:	d9002c17 	ldw	r4,176(sp)
81126200:	d9801e04 	addi	r6,sp,120
81126204:	b80b883a 	mov	r5,r23
81126208:	11312500 	call	81131250 <__sprint_r>
8112620c:	103c981e 	bne	r2,zero,81125470 <__reset+0xfb105470>
81126210:	d8c02017 	ldw	r3,128(sp)
81126214:	da000404 	addi	r8,sp,16
81126218:	003dc306 	br	81125928 <__reset+0xfb105928>
8112621c:	d8802917 	ldw	r2,164(sp)
81126220:	d8002785 	stb	zero,158(sp)
81126224:	103f0616 	blt	r2,zero,81125e40 <__reset+0xfb105e40>
81126228:	00ffdfc4 	movi	r3,-129
8112622c:	9d84b03a 	or	r2,r19,r22
81126230:	90e4703a 	and	r18,r18,r3
81126234:	103c6b26 	beq	r2,zero,811253e4 <__reset+0xfb1053e4>
81126238:	0039883a 	mov	fp,zero
8112623c:	003e7406 	br	81125c10 <__reset+0xfb105c10>
81126240:	9080040c 	andi	r2,r18,16
81126244:	1001b326 	beq	r2,zero,81126914 <___vfprintf_internal_r+0x18b4>
81126248:	d9002d17 	ldw	r4,180(sp)
8112624c:	d9402917 	ldw	r5,164(sp)
81126250:	d8002785 	stb	zero,158(sp)
81126254:	20800104 	addi	r2,r4,4
81126258:	24c00017 	ldw	r19,0(r4)
8112625c:	002d883a 	mov	r22,zero
81126260:	2801b516 	blt	r5,zero,81126938 <___vfprintf_internal_r+0x18d8>
81126264:	00ffdfc4 	movi	r3,-129
81126268:	d8802d15 	stw	r2,180(sp)
8112626c:	90e4703a 	and	r18,r18,r3
81126270:	983d2726 	beq	r19,zero,81125710 <__reset+0xfb105710>
81126274:	0039883a 	mov	fp,zero
81126278:	003d2a06 	br	81125724 <__reset+0xfb105724>
8112627c:	dc402617 	ldw	r17,152(sp)
81126280:	0441d30e 	bge	zero,r17,811269d0 <___vfprintf_internal_r+0x1970>
81126284:	dc403217 	ldw	r17,200(sp)
81126288:	d8803317 	ldw	r2,204(sp)
8112628c:	1440010e 	bge	r2,r17,81126294 <___vfprintf_internal_r+0x1234>
81126290:	1023883a 	mov	r17,r2
81126294:	04400a0e 	bge	zero,r17,811262c0 <___vfprintf_internal_r+0x1260>
81126298:	d8801f17 	ldw	r2,124(sp)
8112629c:	1c47883a 	add	r3,r3,r17
811262a0:	44000015 	stw	r16,0(r8)
811262a4:	10800044 	addi	r2,r2,1
811262a8:	44400115 	stw	r17,4(r8)
811262ac:	d8c02015 	stw	r3,128(sp)
811262b0:	d8801f15 	stw	r2,124(sp)
811262b4:	010001c4 	movi	r4,7
811262b8:	20826516 	blt	r4,r2,81126c50 <___vfprintf_internal_r+0x1bf0>
811262bc:	42000204 	addi	r8,r8,8
811262c0:	88026116 	blt	r17,zero,81126c48 <___vfprintf_internal_r+0x1be8>
811262c4:	d9003217 	ldw	r4,200(sp)
811262c8:	2463c83a 	sub	r17,r4,r17
811262cc:	04407b0e 	bge	zero,r17,811264bc <___vfprintf_internal_r+0x145c>
811262d0:	05800404 	movi	r22,16
811262d4:	d8801f17 	ldw	r2,124(sp)
811262d8:	b4419d0e 	bge	r22,r17,81126950 <___vfprintf_internal_r+0x18f0>
811262dc:	01204574 	movhi	r4,33045
811262e0:	21011884 	addi	r4,r4,1122
811262e4:	d9002b15 	stw	r4,172(sp)
811262e8:	070001c4 	movi	fp,7
811262ec:	dcc02c17 	ldw	r19,176(sp)
811262f0:	00000306 	br	81126300 <___vfprintf_internal_r+0x12a0>
811262f4:	42000204 	addi	r8,r8,8
811262f8:	8c7ffc04 	addi	r17,r17,-16
811262fc:	b441970e 	bge	r22,r17,8112695c <___vfprintf_internal_r+0x18fc>
81126300:	18c00404 	addi	r3,r3,16
81126304:	10800044 	addi	r2,r2,1
81126308:	45000015 	stw	r20,0(r8)
8112630c:	45800115 	stw	r22,4(r8)
81126310:	d8c02015 	stw	r3,128(sp)
81126314:	d8801f15 	stw	r2,124(sp)
81126318:	e0bff60e 	bge	fp,r2,811262f4 <__reset+0xfb1062f4>
8112631c:	d9801e04 	addi	r6,sp,120
81126320:	b80b883a 	mov	r5,r23
81126324:	9809883a 	mov	r4,r19
81126328:	11312500 	call	81131250 <__sprint_r>
8112632c:	103c501e 	bne	r2,zero,81125470 <__reset+0xfb105470>
81126330:	d8c02017 	ldw	r3,128(sp)
81126334:	d8801f17 	ldw	r2,124(sp)
81126338:	da000404 	addi	r8,sp,16
8112633c:	003fee06 	br	811262f8 <__reset+0xfb1062f8>
81126340:	d9002c17 	ldw	r4,176(sp)
81126344:	d9801e04 	addi	r6,sp,120
81126348:	b80b883a 	mov	r5,r23
8112634c:	11312500 	call	81131250 <__sprint_r>
81126350:	103c471e 	bne	r2,zero,81125470 <__reset+0xfb105470>
81126354:	d8c02017 	ldw	r3,128(sp)
81126358:	df002787 	ldb	fp,158(sp)
8112635c:	da000404 	addi	r8,sp,16
81126360:	003d5606 	br	811258bc <__reset+0xfb1058bc>
81126364:	9080040c 	andi	r2,r18,16
81126368:	10016126 	beq	r2,zero,811268f0 <___vfprintf_internal_r+0x1890>
8112636c:	d8802d17 	ldw	r2,180(sp)
81126370:	14c00017 	ldw	r19,0(r2)
81126374:	10800104 	addi	r2,r2,4
81126378:	d8802d15 	stw	r2,180(sp)
8112637c:	982dd7fa 	srai	r22,r19,31
81126380:	b005883a 	mov	r2,r22
81126384:	003c8206 	br	81125590 <__reset+0xfb105590>
81126388:	9080040c 	andi	r2,r18,16
8112638c:	10003526 	beq	r2,zero,81126464 <___vfprintf_internal_r+0x1404>
81126390:	d9402d17 	ldw	r5,180(sp)
81126394:	d8c02917 	ldw	r3,164(sp)
81126398:	d8002785 	stb	zero,158(sp)
8112639c:	28800104 	addi	r2,r5,4
811263a0:	2cc00017 	ldw	r19,0(r5)
811263a4:	002d883a 	mov	r22,zero
811263a8:	18003716 	blt	r3,zero,81126488 <___vfprintf_internal_r+0x1428>
811263ac:	00ffdfc4 	movi	r3,-129
811263b0:	d8802d15 	stw	r2,180(sp)
811263b4:	90e4703a 	and	r18,r18,r3
811263b8:	0039883a 	mov	fp,zero
811263bc:	983df326 	beq	r19,zero,81125b8c <__reset+0xfb105b8c>
811263c0:	00800244 	movi	r2,9
811263c4:	14fc7b36 	bltu	r2,r19,811255b4 <__reset+0xfb1055b4>
811263c8:	d8c02817 	ldw	r3,160(sp)
811263cc:	dc001dc4 	addi	r16,sp,119
811263d0:	9cc00c04 	addi	r19,r19,48
811263d4:	1c07c83a 	sub	r3,r3,r16
811263d8:	dcc01dc5 	stb	r19,119(sp)
811263dc:	d8c02e15 	stw	r3,184(sp)
811263e0:	003ce806 	br	81125784 <__reset+0xfb105784>
811263e4:	d8803317 	ldw	r2,204(sp)
811263e8:	143fffc4 	addi	r16,r2,-1
811263ec:	043f4d0e 	bge	zero,r16,81126124 <__reset+0xfb106124>
811263f0:	07000404 	movi	fp,16
811263f4:	e400810e 	bge	fp,r16,811265fc <___vfprintf_internal_r+0x159c>
811263f8:	01604574 	movhi	r5,33045
811263fc:	29411884 	addi	r5,r5,1122
81126400:	d9402b15 	stw	r5,172(sp)
81126404:	01c001c4 	movi	r7,7
81126408:	dcc02c17 	ldw	r19,176(sp)
8112640c:	00000306 	br	8112641c <___vfprintf_internal_r+0x13bc>
81126410:	b5800204 	addi	r22,r22,8
81126414:	843ffc04 	addi	r16,r16,-16
81126418:	e4007b0e 	bge	fp,r16,81126608 <___vfprintf_internal_r+0x15a8>
8112641c:	18c00404 	addi	r3,r3,16
81126420:	8c400044 	addi	r17,r17,1
81126424:	b5000015 	stw	r20,0(r22)
81126428:	b7000115 	stw	fp,4(r22)
8112642c:	d8c02015 	stw	r3,128(sp)
81126430:	dc401f15 	stw	r17,124(sp)
81126434:	3c7ff60e 	bge	r7,r17,81126410 <__reset+0xfb106410>
81126438:	d9801e04 	addi	r6,sp,120
8112643c:	b80b883a 	mov	r5,r23
81126440:	9809883a 	mov	r4,r19
81126444:	d9c03c15 	stw	r7,240(sp)
81126448:	11312500 	call	81131250 <__sprint_r>
8112644c:	d9c03c17 	ldw	r7,240(sp)
81126450:	103c071e 	bne	r2,zero,81125470 <__reset+0xfb105470>
81126454:	d8c02017 	ldw	r3,128(sp)
81126458:	dc401f17 	ldw	r17,124(sp)
8112645c:	dd800404 	addi	r22,sp,16
81126460:	003fec06 	br	81126414 <__reset+0xfb106414>
81126464:	9080100c 	andi	r2,r18,64
81126468:	d8002785 	stb	zero,158(sp)
8112646c:	10010e26 	beq	r2,zero,811268a8 <___vfprintf_internal_r+0x1848>
81126470:	d9002d17 	ldw	r4,180(sp)
81126474:	d9402917 	ldw	r5,164(sp)
81126478:	002d883a 	mov	r22,zero
8112647c:	20800104 	addi	r2,r4,4
81126480:	24c0000b 	ldhu	r19,0(r4)
81126484:	283fc90e 	bge	r5,zero,811263ac <__reset+0xfb1063ac>
81126488:	d8802d15 	stw	r2,180(sp)
8112648c:	0039883a 	mov	fp,zero
81126490:	9d84b03a 	or	r2,r19,r22
81126494:	103c461e 	bne	r2,zero,811255b0 <__reset+0xfb1055b0>
81126498:	00800044 	movi	r2,1
8112649c:	003e6c06 	br	81125e50 <__reset+0xfb105e50>
811264a0:	d9002c17 	ldw	r4,176(sp)
811264a4:	d9801e04 	addi	r6,sp,120
811264a8:	b80b883a 	mov	r5,r23
811264ac:	11312500 	call	81131250 <__sprint_r>
811264b0:	103bef1e 	bne	r2,zero,81125470 <__reset+0xfb105470>
811264b4:	d8c02017 	ldw	r3,128(sp)
811264b8:	da000404 	addi	r8,sp,16
811264bc:	d9003217 	ldw	r4,200(sp)
811264c0:	d8802617 	ldw	r2,152(sp)
811264c4:	d9403317 	ldw	r5,204(sp)
811264c8:	8123883a 	add	r17,r16,r4
811264cc:	11400216 	blt	r2,r5,811264d8 <___vfprintf_internal_r+0x1478>
811264d0:	9100004c 	andi	r4,r18,1
811264d4:	20000d26 	beq	r4,zero,8112650c <___vfprintf_internal_r+0x14ac>
811264d8:	d9003717 	ldw	r4,220(sp)
811264dc:	d9403417 	ldw	r5,208(sp)
811264e0:	1907883a 	add	r3,r3,r4
811264e4:	d9001f17 	ldw	r4,124(sp)
811264e8:	41400015 	stw	r5,0(r8)
811264ec:	d9403717 	ldw	r5,220(sp)
811264f0:	21000044 	addi	r4,r4,1
811264f4:	d8c02015 	stw	r3,128(sp)
811264f8:	41400115 	stw	r5,4(r8)
811264fc:	d9001f15 	stw	r4,124(sp)
81126500:	014001c4 	movi	r5,7
81126504:	2901e816 	blt	r5,r4,81126ca8 <___vfprintf_internal_r+0x1c48>
81126508:	42000204 	addi	r8,r8,8
8112650c:	d9003317 	ldw	r4,204(sp)
81126510:	8121883a 	add	r16,r16,r4
81126514:	2085c83a 	sub	r2,r4,r2
81126518:	8461c83a 	sub	r16,r16,r17
8112651c:	1400010e 	bge	r2,r16,81126524 <___vfprintf_internal_r+0x14c4>
81126520:	1021883a 	mov	r16,r2
81126524:	04000a0e 	bge	zero,r16,81126550 <___vfprintf_internal_r+0x14f0>
81126528:	d9001f17 	ldw	r4,124(sp)
8112652c:	1c07883a 	add	r3,r3,r16
81126530:	44400015 	stw	r17,0(r8)
81126534:	21000044 	addi	r4,r4,1
81126538:	44000115 	stw	r16,4(r8)
8112653c:	d8c02015 	stw	r3,128(sp)
81126540:	d9001f15 	stw	r4,124(sp)
81126544:	014001c4 	movi	r5,7
81126548:	2901fb16 	blt	r5,r4,81126d38 <___vfprintf_internal_r+0x1cd8>
8112654c:	42000204 	addi	r8,r8,8
81126550:	8001f716 	blt	r16,zero,81126d30 <___vfprintf_internal_r+0x1cd0>
81126554:	1421c83a 	sub	r16,r2,r16
81126558:	043d380e 	bge	zero,r16,81125a3c <__reset+0xfb105a3c>
8112655c:	04400404 	movi	r17,16
81126560:	d8801f17 	ldw	r2,124(sp)
81126564:	8c3efb0e 	bge	r17,r16,81126154 <__reset+0xfb106154>
81126568:	01604574 	movhi	r5,33045
8112656c:	29411884 	addi	r5,r5,1122
81126570:	d9402b15 	stw	r5,172(sp)
81126574:	058001c4 	movi	r22,7
81126578:	dcc02c17 	ldw	r19,176(sp)
8112657c:	00000306 	br	8112658c <___vfprintf_internal_r+0x152c>
81126580:	42000204 	addi	r8,r8,8
81126584:	843ffc04 	addi	r16,r16,-16
81126588:	8c3ef50e 	bge	r17,r16,81126160 <__reset+0xfb106160>
8112658c:	18c00404 	addi	r3,r3,16
81126590:	10800044 	addi	r2,r2,1
81126594:	45000015 	stw	r20,0(r8)
81126598:	44400115 	stw	r17,4(r8)
8112659c:	d8c02015 	stw	r3,128(sp)
811265a0:	d8801f15 	stw	r2,124(sp)
811265a4:	b0bff60e 	bge	r22,r2,81126580 <__reset+0xfb106580>
811265a8:	d9801e04 	addi	r6,sp,120
811265ac:	b80b883a 	mov	r5,r23
811265b0:	9809883a 	mov	r4,r19
811265b4:	11312500 	call	81131250 <__sprint_r>
811265b8:	103bad1e 	bne	r2,zero,81125470 <__reset+0xfb105470>
811265bc:	d8c02017 	ldw	r3,128(sp)
811265c0:	d8801f17 	ldw	r2,124(sp)
811265c4:	da000404 	addi	r8,sp,16
811265c8:	003fee06 	br	81126584 <__reset+0xfb106584>
811265cc:	9088703a 	and	r4,r18,r2
811265d0:	203eab1e 	bne	r4,zero,81126080 <__reset+0xfb106080>
811265d4:	dc401f17 	ldw	r17,124(sp)
811265d8:	40800115 	stw	r2,4(r8)
811265dc:	44000015 	stw	r16,0(r8)
811265e0:	8c400044 	addi	r17,r17,1
811265e4:	d8c02015 	stw	r3,128(sp)
811265e8:	dc401f15 	stw	r17,124(sp)
811265ec:	008001c4 	movi	r2,7
811265f0:	14400e16 	blt	r2,r17,8112662c <___vfprintf_internal_r+0x15cc>
811265f4:	45800204 	addi	r22,r8,8
811265f8:	003eca06 	br	81126124 <__reset+0xfb106124>
811265fc:	01204574 	movhi	r4,33045
81126600:	21011884 	addi	r4,r4,1122
81126604:	d9002b15 	stw	r4,172(sp)
81126608:	d8802b17 	ldw	r2,172(sp)
8112660c:	1c07883a 	add	r3,r3,r16
81126610:	8c400044 	addi	r17,r17,1
81126614:	b0800015 	stw	r2,0(r22)
81126618:	b4000115 	stw	r16,4(r22)
8112661c:	d8c02015 	stw	r3,128(sp)
81126620:	dc401f15 	stw	r17,124(sp)
81126624:	008001c4 	movi	r2,7
81126628:	147ebd0e 	bge	r2,r17,81126120 <__reset+0xfb106120>
8112662c:	d9002c17 	ldw	r4,176(sp)
81126630:	d9801e04 	addi	r6,sp,120
81126634:	b80b883a 	mov	r5,r23
81126638:	11312500 	call	81131250 <__sprint_r>
8112663c:	103b8c1e 	bne	r2,zero,81125470 <__reset+0xfb105470>
81126640:	d8c02017 	ldw	r3,128(sp)
81126644:	dc401f17 	ldw	r17,124(sp)
81126648:	dd800404 	addi	r22,sp,16
8112664c:	003eb506 	br	81126124 <__reset+0xfb106124>
81126650:	d9002c17 	ldw	r4,176(sp)
81126654:	d9801e04 	addi	r6,sp,120
81126658:	b80b883a 	mov	r5,r23
8112665c:	11312500 	call	81131250 <__sprint_r>
81126660:	103b831e 	bne	r2,zero,81125470 <__reset+0xfb105470>
81126664:	d8c02017 	ldw	r3,128(sp)
81126668:	dc401f17 	ldw	r17,124(sp)
8112666c:	da000404 	addi	r8,sp,16
81126670:	003e8d06 	br	811260a8 <__reset+0xfb1060a8>
81126674:	d9002c17 	ldw	r4,176(sp)
81126678:	d9801e04 	addi	r6,sp,120
8112667c:	b80b883a 	mov	r5,r23
81126680:	11312500 	call	81131250 <__sprint_r>
81126684:	103b7a1e 	bne	r2,zero,81125470 <__reset+0xfb105470>
81126688:	d8c02017 	ldw	r3,128(sp)
8112668c:	dc401f17 	ldw	r17,124(sp)
81126690:	dd800404 	addi	r22,sp,16
81126694:	003e8f06 	br	811260d4 <__reset+0xfb1060d4>
81126698:	0027883a 	mov	r19,zero
8112669c:	003f4a06 	br	811263c8 <__reset+0xfb1063c8>
811266a0:	d9002c17 	ldw	r4,176(sp)
811266a4:	d9801e04 	addi	r6,sp,120
811266a8:	b80b883a 	mov	r5,r23
811266ac:	11312500 	call	81131250 <__sprint_r>
811266b0:	103b6f1e 	bne	r2,zero,81125470 <__reset+0xfb105470>
811266b4:	d8c02017 	ldw	r3,128(sp)
811266b8:	da000404 	addi	r8,sp,16
811266bc:	003c9d06 	br	81125934 <__reset+0xfb105934>
811266c0:	04e7c83a 	sub	r19,zero,r19
811266c4:	9804c03a 	cmpne	r2,r19,zero
811266c8:	05adc83a 	sub	r22,zero,r22
811266cc:	b0adc83a 	sub	r22,r22,r2
811266d0:	d8802917 	ldw	r2,164(sp)
811266d4:	07000b44 	movi	fp,45
811266d8:	df002785 	stb	fp,158(sp)
811266dc:	10017b16 	blt	r2,zero,81126ccc <___vfprintf_internal_r+0x1c6c>
811266e0:	00bfdfc4 	movi	r2,-129
811266e4:	90a4703a 	and	r18,r18,r2
811266e8:	003bb106 	br	811255b0 <__reset+0xfb1055b0>
811266ec:	d9003617 	ldw	r4,216(sp)
811266f0:	d9403817 	ldw	r5,224(sp)
811266f4:	da003d15 	stw	r8,244(sp)
811266f8:	112d8b40 	call	8112d8b4 <__fpclassifyd>
811266fc:	da003d17 	ldw	r8,244(sp)
81126700:	1000f026 	beq	r2,zero,81126ac4 <___vfprintf_internal_r+0x1a64>
81126704:	d9002917 	ldw	r4,164(sp)
81126708:	05bff7c4 	movi	r22,-33
8112670c:	00bfffc4 	movi	r2,-1
81126710:	8dac703a 	and	r22,r17,r22
81126714:	20820026 	beq	r4,r2,81126f18 <___vfprintf_internal_r+0x1eb8>
81126718:	008011c4 	movi	r2,71
8112671c:	b081f726 	beq	r22,r2,81126efc <___vfprintf_internal_r+0x1e9c>
81126720:	d9003817 	ldw	r4,224(sp)
81126724:	90c04014 	ori	r3,r18,256
81126728:	d8c02b15 	stw	r3,172(sp)
8112672c:	20021516 	blt	r4,zero,81126f84 <___vfprintf_internal_r+0x1f24>
81126730:	dcc03817 	ldw	r19,224(sp)
81126734:	d8002a05 	stb	zero,168(sp)
81126738:	00801984 	movi	r2,102
8112673c:	8881f926 	beq	r17,r2,81126f24 <___vfprintf_internal_r+0x1ec4>
81126740:	00801184 	movi	r2,70
81126744:	88821c26 	beq	r17,r2,81126fb8 <___vfprintf_internal_r+0x1f58>
81126748:	00801144 	movi	r2,69
8112674c:	b081ef26 	beq	r22,r2,81126f0c <___vfprintf_internal_r+0x1eac>
81126750:	d8c02917 	ldw	r3,164(sp)
81126754:	d8802104 	addi	r2,sp,132
81126758:	d8800315 	stw	r2,12(sp)
8112675c:	d9403617 	ldw	r5,216(sp)
81126760:	d8802504 	addi	r2,sp,148
81126764:	d9002c17 	ldw	r4,176(sp)
81126768:	d8800215 	stw	r2,8(sp)
8112676c:	d8802604 	addi	r2,sp,152
81126770:	d8c00015 	stw	r3,0(sp)
81126774:	d8800115 	stw	r2,4(sp)
81126778:	01c00084 	movi	r7,2
8112677c:	980d883a 	mov	r6,r19
81126780:	d8c03c15 	stw	r3,240(sp)
81126784:	da003d15 	stw	r8,244(sp)
81126788:	112916c0 	call	8112916c <_dtoa_r>
8112678c:	1021883a 	mov	r16,r2
81126790:	008019c4 	movi	r2,103
81126794:	d8c03c17 	ldw	r3,240(sp)
81126798:	da003d17 	ldw	r8,244(sp)
8112679c:	88817126 	beq	r17,r2,81126d64 <___vfprintf_internal_r+0x1d04>
811267a0:	008011c4 	movi	r2,71
811267a4:	88829226 	beq	r17,r2,811271f0 <___vfprintf_internal_r+0x2190>
811267a8:	80f9883a 	add	fp,r16,r3
811267ac:	d9003617 	ldw	r4,216(sp)
811267b0:	000d883a 	mov	r6,zero
811267b4:	000f883a 	mov	r7,zero
811267b8:	980b883a 	mov	r5,r19
811267bc:	da003d15 	stw	r8,244(sp)
811267c0:	1135a1c0 	call	81135a1c <__eqdf2>
811267c4:	da003d17 	ldw	r8,244(sp)
811267c8:	10018d26 	beq	r2,zero,81126e00 <___vfprintf_internal_r+0x1da0>
811267cc:	d8802117 	ldw	r2,132(sp)
811267d0:	1700062e 	bgeu	r2,fp,811267ec <___vfprintf_internal_r+0x178c>
811267d4:	01000c04 	movi	r4,48
811267d8:	10c00044 	addi	r3,r2,1
811267dc:	d8c02115 	stw	r3,132(sp)
811267e0:	11000005 	stb	r4,0(r2)
811267e4:	d8802117 	ldw	r2,132(sp)
811267e8:	173ffb36 	bltu	r2,fp,811267d8 <__reset+0xfb1067d8>
811267ec:	1405c83a 	sub	r2,r2,r16
811267f0:	d8803315 	stw	r2,204(sp)
811267f4:	008011c4 	movi	r2,71
811267f8:	b0817626 	beq	r22,r2,81126dd4 <___vfprintf_internal_r+0x1d74>
811267fc:	00801944 	movi	r2,101
81126800:	1442810e 	bge	r2,r17,81127208 <___vfprintf_internal_r+0x21a8>
81126804:	d8c02617 	ldw	r3,152(sp)
81126808:	00801984 	movi	r2,102
8112680c:	d8c03215 	stw	r3,200(sp)
81126810:	8881fe26 	beq	r17,r2,8112700c <___vfprintf_internal_r+0x1fac>
81126814:	d8c03217 	ldw	r3,200(sp)
81126818:	d9003317 	ldw	r4,204(sp)
8112681c:	1901dd16 	blt	r3,r4,81126f94 <___vfprintf_internal_r+0x1f34>
81126820:	9480004c 	andi	r18,r18,1
81126824:	90022b1e 	bne	r18,zero,811270d4 <___vfprintf_internal_r+0x2074>
81126828:	1805883a 	mov	r2,r3
8112682c:	18028016 	blt	r3,zero,81127230 <___vfprintf_internal_r+0x21d0>
81126830:	d8c03217 	ldw	r3,200(sp)
81126834:	044019c4 	movi	r17,103
81126838:	d8c02e15 	stw	r3,184(sp)
8112683c:	df002a07 	ldb	fp,168(sp)
81126840:	e001531e 	bne	fp,zero,81126d90 <___vfprintf_internal_r+0x1d30>
81126844:	df002783 	ldbu	fp,158(sp)
81126848:	d8802a15 	stw	r2,168(sp)
8112684c:	dc802b17 	ldw	r18,172(sp)
81126850:	d8002915 	stw	zero,164(sp)
81126854:	003bd106 	br	8112579c <__reset+0xfb10579c>
81126858:	d8802d17 	ldw	r2,180(sp)
8112685c:	d8c02d17 	ldw	r3,180(sp)
81126860:	d9002d17 	ldw	r4,180(sp)
81126864:	10800017 	ldw	r2,0(r2)
81126868:	18c00117 	ldw	r3,4(r3)
8112686c:	21000204 	addi	r4,r4,8
81126870:	d8803615 	stw	r2,216(sp)
81126874:	d8c03815 	stw	r3,224(sp)
81126878:	d9002d15 	stw	r4,180(sp)
8112687c:	003b7506 	br	81125654 <__reset+0xfb105654>
81126880:	ac400007 	ldb	r17,0(r21)
81126884:	003a5906 	br	811251ec <__reset+0xfb1051ec>
81126888:	9080100c 	andi	r2,r18,64
8112688c:	1000a826 	beq	r2,zero,81126b30 <___vfprintf_internal_r+0x1ad0>
81126890:	d9002d17 	ldw	r4,180(sp)
81126894:	002d883a 	mov	r22,zero
81126898:	24c0000b 	ldhu	r19,0(r4)
8112689c:	21000104 	addi	r4,r4,4
811268a0:	d9002d15 	stw	r4,180(sp)
811268a4:	003ccb06 	br	81125bd4 <__reset+0xfb105bd4>
811268a8:	d8c02d17 	ldw	r3,180(sp)
811268ac:	d9002917 	ldw	r4,164(sp)
811268b0:	002d883a 	mov	r22,zero
811268b4:	18800104 	addi	r2,r3,4
811268b8:	1cc00017 	ldw	r19,0(r3)
811268bc:	203ebb0e 	bge	r4,zero,811263ac <__reset+0xfb1063ac>
811268c0:	003ef106 	br	81126488 <__reset+0xfb106488>
811268c4:	9080040c 	andi	r2,r18,16
811268c8:	1000921e 	bne	r2,zero,81126b14 <___vfprintf_internal_r+0x1ab4>
811268cc:	9480100c 	andi	r18,r18,64
811268d0:	90013926 	beq	r18,zero,81126db8 <___vfprintf_internal_r+0x1d58>
811268d4:	d9002d17 	ldw	r4,180(sp)
811268d8:	d9402f17 	ldw	r5,188(sp)
811268dc:	20800017 	ldw	r2,0(r4)
811268e0:	21000104 	addi	r4,r4,4
811268e4:	d9002d15 	stw	r4,180(sp)
811268e8:	1140000d 	sth	r5,0(r2)
811268ec:	003a1606 	br	81125148 <__reset+0xfb105148>
811268f0:	9080100c 	andi	r2,r18,64
811268f4:	10008026 	beq	r2,zero,81126af8 <___vfprintf_internal_r+0x1a98>
811268f8:	d8c02d17 	ldw	r3,180(sp)
811268fc:	1cc0000f 	ldh	r19,0(r3)
81126900:	18c00104 	addi	r3,r3,4
81126904:	d8c02d15 	stw	r3,180(sp)
81126908:	982dd7fa 	srai	r22,r19,31
8112690c:	b005883a 	mov	r2,r22
81126910:	003b1f06 	br	81125590 <__reset+0xfb105590>
81126914:	9080100c 	andi	r2,r18,64
81126918:	d8002785 	stb	zero,158(sp)
8112691c:	10008a1e 	bne	r2,zero,81126b48 <___vfprintf_internal_r+0x1ae8>
81126920:	d9402d17 	ldw	r5,180(sp)
81126924:	d8c02917 	ldw	r3,164(sp)
81126928:	002d883a 	mov	r22,zero
8112692c:	28800104 	addi	r2,r5,4
81126930:	2cc00017 	ldw	r19,0(r5)
81126934:	183e4b0e 	bge	r3,zero,81126264 <__reset+0xfb106264>
81126938:	9d86b03a 	or	r3,r19,r22
8112693c:	d8802d15 	stw	r2,180(sp)
81126940:	183e4c1e 	bne	r3,zero,81126274 <__reset+0xfb106274>
81126944:	0039883a 	mov	fp,zero
81126948:	0005883a 	mov	r2,zero
8112694c:	003d4006 	br	81125e50 <__reset+0xfb105e50>
81126950:	01604574 	movhi	r5,33045
81126954:	29411884 	addi	r5,r5,1122
81126958:	d9402b15 	stw	r5,172(sp)
8112695c:	d9402b17 	ldw	r5,172(sp)
81126960:	1c47883a 	add	r3,r3,r17
81126964:	10800044 	addi	r2,r2,1
81126968:	41400015 	stw	r5,0(r8)
8112696c:	44400115 	stw	r17,4(r8)
81126970:	d8c02015 	stw	r3,128(sp)
81126974:	d8801f15 	stw	r2,124(sp)
81126978:	010001c4 	movi	r4,7
8112697c:	20bec816 	blt	r4,r2,811264a0 <__reset+0xfb1064a0>
81126980:	42000204 	addi	r8,r8,8
81126984:	003ecd06 	br	811264bc <__reset+0xfb1064bc>
81126988:	d9002917 	ldw	r4,164(sp)
8112698c:	d8002785 	stb	zero,158(sp)
81126990:	203d2d16 	blt	r4,zero,81125e48 <__reset+0xfb105e48>
81126994:	00bfdfc4 	movi	r2,-129
81126998:	90a4703a 	and	r18,r18,r2
8112699c:	003a9106 	br	811253e4 <__reset+0xfb1053e4>
811269a0:	01204574 	movhi	r4,33045
811269a4:	21011884 	addi	r4,r4,1122
811269a8:	d9002b15 	stw	r4,172(sp)
811269ac:	003c0c06 	br	811259e0 <__reset+0xfb1059e0>
811269b0:	d9002c17 	ldw	r4,176(sp)
811269b4:	d9801e04 	addi	r6,sp,120
811269b8:	b80b883a 	mov	r5,r23
811269bc:	11312500 	call	81131250 <__sprint_r>
811269c0:	103aab1e 	bne	r2,zero,81125470 <__reset+0xfb105470>
811269c4:	d8c02017 	ldw	r3,128(sp)
811269c8:	da000404 	addi	r8,sp,16
811269cc:	003d4106 	br	81125ed4 <__reset+0xfb105ed4>
811269d0:	d8801f17 	ldw	r2,124(sp)
811269d4:	01604574 	movhi	r5,33045
811269d8:	01000044 	movi	r4,1
811269dc:	18c00044 	addi	r3,r3,1
811269e0:	10800044 	addi	r2,r2,1
811269e4:	29411004 	addi	r5,r5,1088
811269e8:	41000115 	stw	r4,4(r8)
811269ec:	41400015 	stw	r5,0(r8)
811269f0:	d8c02015 	stw	r3,128(sp)
811269f4:	d8801f15 	stw	r2,124(sp)
811269f8:	010001c4 	movi	r4,7
811269fc:	20805c16 	blt	r4,r2,81126b70 <___vfprintf_internal_r+0x1b10>
81126a00:	42000204 	addi	r8,r8,8
81126a04:	8800041e 	bne	r17,zero,81126a18 <___vfprintf_internal_r+0x19b8>
81126a08:	d8803317 	ldw	r2,204(sp)
81126a0c:	1000021e 	bne	r2,zero,81126a18 <___vfprintf_internal_r+0x19b8>
81126a10:	9080004c 	andi	r2,r18,1
81126a14:	103c0926 	beq	r2,zero,81125a3c <__reset+0xfb105a3c>
81126a18:	d9003717 	ldw	r4,220(sp)
81126a1c:	d8801f17 	ldw	r2,124(sp)
81126a20:	d9403417 	ldw	r5,208(sp)
81126a24:	20c7883a 	add	r3,r4,r3
81126a28:	10800044 	addi	r2,r2,1
81126a2c:	41000115 	stw	r4,4(r8)
81126a30:	41400015 	stw	r5,0(r8)
81126a34:	d8c02015 	stw	r3,128(sp)
81126a38:	d8801f15 	stw	r2,124(sp)
81126a3c:	010001c4 	movi	r4,7
81126a40:	20812116 	blt	r4,r2,81126ec8 <___vfprintf_internal_r+0x1e68>
81126a44:	42000204 	addi	r8,r8,8
81126a48:	0463c83a 	sub	r17,zero,r17
81126a4c:	0440730e 	bge	zero,r17,81126c1c <___vfprintf_internal_r+0x1bbc>
81126a50:	05800404 	movi	r22,16
81126a54:	b440860e 	bge	r22,r17,81126c70 <___vfprintf_internal_r+0x1c10>
81126a58:	01604574 	movhi	r5,33045
81126a5c:	29411884 	addi	r5,r5,1122
81126a60:	d9402b15 	stw	r5,172(sp)
81126a64:	070001c4 	movi	fp,7
81126a68:	dcc02c17 	ldw	r19,176(sp)
81126a6c:	00000306 	br	81126a7c <___vfprintf_internal_r+0x1a1c>
81126a70:	42000204 	addi	r8,r8,8
81126a74:	8c7ffc04 	addi	r17,r17,-16
81126a78:	b440800e 	bge	r22,r17,81126c7c <___vfprintf_internal_r+0x1c1c>
81126a7c:	18c00404 	addi	r3,r3,16
81126a80:	10800044 	addi	r2,r2,1
81126a84:	45000015 	stw	r20,0(r8)
81126a88:	45800115 	stw	r22,4(r8)
81126a8c:	d8c02015 	stw	r3,128(sp)
81126a90:	d8801f15 	stw	r2,124(sp)
81126a94:	e0bff60e 	bge	fp,r2,81126a70 <__reset+0xfb106a70>
81126a98:	d9801e04 	addi	r6,sp,120
81126a9c:	b80b883a 	mov	r5,r23
81126aa0:	9809883a 	mov	r4,r19
81126aa4:	11312500 	call	81131250 <__sprint_r>
81126aa8:	103a711e 	bne	r2,zero,81125470 <__reset+0xfb105470>
81126aac:	d8c02017 	ldw	r3,128(sp)
81126ab0:	d8801f17 	ldw	r2,124(sp)
81126ab4:	da000404 	addi	r8,sp,16
81126ab8:	003fee06 	br	81126a74 <__reset+0xfb106a74>
81126abc:	00bfffc4 	movi	r2,-1
81126ac0:	003a6f06 	br	81125480 <__reset+0xfb105480>
81126ac4:	008011c4 	movi	r2,71
81126ac8:	1440b816 	blt	r2,r17,81126dac <___vfprintf_internal_r+0x1d4c>
81126acc:	04204574 	movhi	r16,33045
81126ad0:	84010204 	addi	r16,r16,1032
81126ad4:	00c000c4 	movi	r3,3
81126ad8:	00bfdfc4 	movi	r2,-129
81126adc:	d8c02a15 	stw	r3,168(sp)
81126ae0:	90a4703a 	and	r18,r18,r2
81126ae4:	df002783 	ldbu	fp,158(sp)
81126ae8:	d8c02e15 	stw	r3,184(sp)
81126aec:	d8002915 	stw	zero,164(sp)
81126af0:	d8003215 	stw	zero,200(sp)
81126af4:	003b2906 	br	8112579c <__reset+0xfb10579c>
81126af8:	d9002d17 	ldw	r4,180(sp)
81126afc:	24c00017 	ldw	r19,0(r4)
81126b00:	21000104 	addi	r4,r4,4
81126b04:	d9002d15 	stw	r4,180(sp)
81126b08:	982dd7fa 	srai	r22,r19,31
81126b0c:	b005883a 	mov	r2,r22
81126b10:	003a9f06 	br	81125590 <__reset+0xfb105590>
81126b14:	d9402d17 	ldw	r5,180(sp)
81126b18:	d8c02f17 	ldw	r3,188(sp)
81126b1c:	28800017 	ldw	r2,0(r5)
81126b20:	29400104 	addi	r5,r5,4
81126b24:	d9402d15 	stw	r5,180(sp)
81126b28:	10c00015 	stw	r3,0(r2)
81126b2c:	00398606 	br	81125148 <__reset+0xfb105148>
81126b30:	d9402d17 	ldw	r5,180(sp)
81126b34:	002d883a 	mov	r22,zero
81126b38:	2cc00017 	ldw	r19,0(r5)
81126b3c:	29400104 	addi	r5,r5,4
81126b40:	d9402d15 	stw	r5,180(sp)
81126b44:	003c2306 	br	81125bd4 <__reset+0xfb105bd4>
81126b48:	d8c02d17 	ldw	r3,180(sp)
81126b4c:	d9002917 	ldw	r4,164(sp)
81126b50:	002d883a 	mov	r22,zero
81126b54:	18800104 	addi	r2,r3,4
81126b58:	1cc0000b 	ldhu	r19,0(r3)
81126b5c:	203dc10e 	bge	r4,zero,81126264 <__reset+0xfb106264>
81126b60:	003f7506 	br	81126938 <__reset+0xfb106938>
81126b64:	04204574 	movhi	r16,33045
81126b68:	84010004 	addi	r16,r16,1024
81126b6c:	003acc06 	br	811256a0 <__reset+0xfb1056a0>
81126b70:	d9002c17 	ldw	r4,176(sp)
81126b74:	d9801e04 	addi	r6,sp,120
81126b78:	b80b883a 	mov	r5,r23
81126b7c:	11312500 	call	81131250 <__sprint_r>
81126b80:	103a3b1e 	bne	r2,zero,81125470 <__reset+0xfb105470>
81126b84:	dc402617 	ldw	r17,152(sp)
81126b88:	d8c02017 	ldw	r3,128(sp)
81126b8c:	da000404 	addi	r8,sp,16
81126b90:	003f9c06 	br	81126a04 <__reset+0xfb106a04>
81126b94:	ac400043 	ldbu	r17,1(r21)
81126b98:	94800814 	ori	r18,r18,32
81126b9c:	ad400044 	addi	r21,r21,1
81126ba0:	8c403fcc 	andi	r17,r17,255
81126ba4:	8c40201c 	xori	r17,r17,128
81126ba8:	8c7fe004 	addi	r17,r17,-128
81126bac:	00398f06 	br	811251ec <__reset+0xfb1051ec>
81126bb0:	d8c02d15 	stw	r3,180(sp)
81126bb4:	0039883a 	mov	fp,zero
81126bb8:	003e3506 	br	81126490 <__reset+0xfb106490>
81126bbc:	d9002c17 	ldw	r4,176(sp)
81126bc0:	d9801e04 	addi	r6,sp,120
81126bc4:	b80b883a 	mov	r5,r23
81126bc8:	11312500 	call	81131250 <__sprint_r>
81126bcc:	103a281e 	bne	r2,zero,81125470 <__reset+0xfb105470>
81126bd0:	d8c02017 	ldw	r3,128(sp)
81126bd4:	da000404 	addi	r8,sp,16
81126bd8:	003cd006 	br	81125f1c <__reset+0xfb105f1c>
81126bdc:	8009883a 	mov	r4,r16
81126be0:	da003d15 	stw	r8,244(sp)
81126be4:	1122b480 	call	81122b48 <strlen>
81126be8:	d8802e15 	stw	r2,184(sp)
81126bec:	da003d17 	ldw	r8,244(sp)
81126bf0:	103c340e 	bge	r2,zero,81125cc4 <__reset+0xfb105cc4>
81126bf4:	0005883a 	mov	r2,zero
81126bf8:	003c3206 	br	81125cc4 <__reset+0xfb105cc4>
81126bfc:	d9002c17 	ldw	r4,176(sp)
81126c00:	d9801e04 	addi	r6,sp,120
81126c04:	b80b883a 	mov	r5,r23
81126c08:	11312500 	call	81131250 <__sprint_r>
81126c0c:	103a181e 	bne	r2,zero,81125470 <__reset+0xfb105470>
81126c10:	d8c02017 	ldw	r3,128(sp)
81126c14:	d8801f17 	ldw	r2,124(sp)
81126c18:	da000404 	addi	r8,sp,16
81126c1c:	d9403317 	ldw	r5,204(sp)
81126c20:	10800044 	addi	r2,r2,1
81126c24:	44000015 	stw	r16,0(r8)
81126c28:	28c7883a 	add	r3,r5,r3
81126c2c:	003b7d06 	br	81125a24 <__reset+0xfb105a24>
81126c30:	01204574 	movhi	r4,33045
81126c34:	21011c84 	addi	r4,r4,1138
81126c38:	d9003515 	stw	r4,212(sp)
81126c3c:	003b1406 	br	81125890 <__reset+0xfb105890>
81126c40:	013fffc4 	movi	r4,-1
81126c44:	003a3506 	br	8112551c <__reset+0xfb10551c>
81126c48:	0023883a 	mov	r17,zero
81126c4c:	003d9d06 	br	811262c4 <__reset+0xfb1062c4>
81126c50:	d9002c17 	ldw	r4,176(sp)
81126c54:	d9801e04 	addi	r6,sp,120
81126c58:	b80b883a 	mov	r5,r23
81126c5c:	11312500 	call	81131250 <__sprint_r>
81126c60:	103a031e 	bne	r2,zero,81125470 <__reset+0xfb105470>
81126c64:	d8c02017 	ldw	r3,128(sp)
81126c68:	da000404 	addi	r8,sp,16
81126c6c:	003d9406 	br	811262c0 <__reset+0xfb1062c0>
81126c70:	01204574 	movhi	r4,33045
81126c74:	21011884 	addi	r4,r4,1122
81126c78:	d9002b15 	stw	r4,172(sp)
81126c7c:	d9002b17 	ldw	r4,172(sp)
81126c80:	1c47883a 	add	r3,r3,r17
81126c84:	10800044 	addi	r2,r2,1
81126c88:	41000015 	stw	r4,0(r8)
81126c8c:	44400115 	stw	r17,4(r8)
81126c90:	d8c02015 	stw	r3,128(sp)
81126c94:	d8801f15 	stw	r2,124(sp)
81126c98:	010001c4 	movi	r4,7
81126c9c:	20bfd716 	blt	r4,r2,81126bfc <__reset+0xfb106bfc>
81126ca0:	42000204 	addi	r8,r8,8
81126ca4:	003fdd06 	br	81126c1c <__reset+0xfb106c1c>
81126ca8:	d9002c17 	ldw	r4,176(sp)
81126cac:	d9801e04 	addi	r6,sp,120
81126cb0:	b80b883a 	mov	r5,r23
81126cb4:	11312500 	call	81131250 <__sprint_r>
81126cb8:	1039ed1e 	bne	r2,zero,81125470 <__reset+0xfb105470>
81126cbc:	d8802617 	ldw	r2,152(sp)
81126cc0:	d8c02017 	ldw	r3,128(sp)
81126cc4:	da000404 	addi	r8,sp,16
81126cc8:	003e1006 	br	8112650c <__reset+0xfb10650c>
81126ccc:	00800044 	movi	r2,1
81126cd0:	10803fcc 	andi	r2,r2,255
81126cd4:	00c00044 	movi	r3,1
81126cd8:	10fa3526 	beq	r2,r3,811255b0 <__reset+0xfb1055b0>
81126cdc:	00c00084 	movi	r3,2
81126ce0:	10fbcb26 	beq	r2,r3,81125c10 <__reset+0xfb105c10>
81126ce4:	003a8f06 	br	81125724 <__reset+0xfb105724>
81126ce8:	01204574 	movhi	r4,33045
81126cec:	21011c84 	addi	r4,r4,1138
81126cf0:	d9003515 	stw	r4,212(sp)
81126cf4:	003b7606 	br	81125ad0 <__reset+0xfb105ad0>
81126cf8:	d8802917 	ldw	r2,164(sp)
81126cfc:	00c00184 	movi	r3,6
81126d00:	1880012e 	bgeu	r3,r2,81126d08 <___vfprintf_internal_r+0x1ca8>
81126d04:	1805883a 	mov	r2,r3
81126d08:	d8802e15 	stw	r2,184(sp)
81126d0c:	1000ef16 	blt	r2,zero,811270cc <___vfprintf_internal_r+0x206c>
81126d10:	04204574 	movhi	r16,33045
81126d14:	d8802a15 	stw	r2,168(sp)
81126d18:	dcc02d15 	stw	r19,180(sp)
81126d1c:	d8002915 	stw	zero,164(sp)
81126d20:	d8003215 	stw	zero,200(sp)
81126d24:	84010e04 	addi	r16,r16,1080
81126d28:	0039883a 	mov	fp,zero
81126d2c:	003aa206 	br	811257b8 <__reset+0xfb1057b8>
81126d30:	0021883a 	mov	r16,zero
81126d34:	003e0706 	br	81126554 <__reset+0xfb106554>
81126d38:	d9002c17 	ldw	r4,176(sp)
81126d3c:	d9801e04 	addi	r6,sp,120
81126d40:	b80b883a 	mov	r5,r23
81126d44:	11312500 	call	81131250 <__sprint_r>
81126d48:	1039c91e 	bne	r2,zero,81125470 <__reset+0xfb105470>
81126d4c:	d8802617 	ldw	r2,152(sp)
81126d50:	d9403317 	ldw	r5,204(sp)
81126d54:	d8c02017 	ldw	r3,128(sp)
81126d58:	da000404 	addi	r8,sp,16
81126d5c:	2885c83a 	sub	r2,r5,r2
81126d60:	003dfb06 	br	81126550 <__reset+0xfb106550>
81126d64:	9080004c 	andi	r2,r18,1
81126d68:	103e8f1e 	bne	r2,zero,811267a8 <__reset+0xfb1067a8>
81126d6c:	d8802117 	ldw	r2,132(sp)
81126d70:	003e9e06 	br	811267ec <__reset+0xfb1067ec>
81126d74:	1025883a 	mov	r18,r2
81126d78:	0039883a 	mov	fp,zero
81126d7c:	00800084 	movi	r2,2
81126d80:	003fd306 	br	81126cd0 <__reset+0xfb106cd0>
81126d84:	07000b44 	movi	fp,45
81126d88:	df002785 	stb	fp,158(sp)
81126d8c:	003a4006 	br	81125690 <__reset+0xfb105690>
81126d90:	00c00b44 	movi	r3,45
81126d94:	d8c02785 	stb	r3,158(sp)
81126d98:	d8802a15 	stw	r2,168(sp)
81126d9c:	dc802b17 	ldw	r18,172(sp)
81126da0:	d8002915 	stw	zero,164(sp)
81126da4:	07000b44 	movi	fp,45
81126da8:	003a8006 	br	811257ac <__reset+0xfb1057ac>
81126dac:	04204574 	movhi	r16,33045
81126db0:	84010304 	addi	r16,r16,1036
81126db4:	003f4706 	br	81126ad4 <__reset+0xfb106ad4>
81126db8:	d8c02d17 	ldw	r3,180(sp)
81126dbc:	d9002f17 	ldw	r4,188(sp)
81126dc0:	18800017 	ldw	r2,0(r3)
81126dc4:	18c00104 	addi	r3,r3,4
81126dc8:	d8c02d15 	stw	r3,180(sp)
81126dcc:	11000015 	stw	r4,0(r2)
81126dd0:	0038dd06 	br	81125148 <__reset+0xfb105148>
81126dd4:	dd802617 	ldw	r22,152(sp)
81126dd8:	00bfff44 	movi	r2,-3
81126ddc:	b0801c16 	blt	r22,r2,81126e50 <___vfprintf_internal_r+0x1df0>
81126de0:	d9402917 	ldw	r5,164(sp)
81126de4:	2d801a16 	blt	r5,r22,81126e50 <___vfprintf_internal_r+0x1df0>
81126de8:	dd803215 	stw	r22,200(sp)
81126dec:	003e8906 	br	81126814 <__reset+0xfb106814>
81126df0:	01204574 	movhi	r4,33045
81126df4:	21011884 	addi	r4,r4,1122
81126df8:	d9002b15 	stw	r4,172(sp)
81126dfc:	003c9106 	br	81126044 <__reset+0xfb106044>
81126e00:	e005883a 	mov	r2,fp
81126e04:	003e7906 	br	811267ec <__reset+0xfb1067ec>
81126e08:	d9402917 	ldw	r5,164(sp)
81126e0c:	df002783 	ldbu	fp,158(sp)
81126e10:	dcc02d15 	stw	r19,180(sp)
81126e14:	d9402a15 	stw	r5,168(sp)
81126e18:	d9402e15 	stw	r5,184(sp)
81126e1c:	d8002915 	stw	zero,164(sp)
81126e20:	d8003215 	stw	zero,200(sp)
81126e24:	003a5d06 	br	8112579c <__reset+0xfb10579c>
81126e28:	9080004c 	andi	r2,r18,1
81126e2c:	0039883a 	mov	fp,zero
81126e30:	10000426 	beq	r2,zero,81126e44 <___vfprintf_internal_r+0x1de4>
81126e34:	00800c04 	movi	r2,48
81126e38:	dc001dc4 	addi	r16,sp,119
81126e3c:	d8801dc5 	stb	r2,119(sp)
81126e40:	003b8006 	br	81125c44 <__reset+0xfb105c44>
81126e44:	d8002e15 	stw	zero,184(sp)
81126e48:	dc001e04 	addi	r16,sp,120
81126e4c:	003a4d06 	br	81125784 <__reset+0xfb105784>
81126e50:	8c7fff84 	addi	r17,r17,-2
81126e54:	b5bfffc4 	addi	r22,r22,-1
81126e58:	dd802615 	stw	r22,152(sp)
81126e5c:	dc4022c5 	stb	r17,139(sp)
81126e60:	b000bf16 	blt	r22,zero,81127160 <___vfprintf_internal_r+0x2100>
81126e64:	00800ac4 	movi	r2,43
81126e68:	d8802305 	stb	r2,140(sp)
81126e6c:	00800244 	movi	r2,9
81126e70:	15807016 	blt	r2,r22,81127034 <___vfprintf_internal_r+0x1fd4>
81126e74:	00800c04 	movi	r2,48
81126e78:	b5800c04 	addi	r22,r22,48
81126e7c:	d8802345 	stb	r2,141(sp)
81126e80:	dd802385 	stb	r22,142(sp)
81126e84:	d88023c4 	addi	r2,sp,143
81126e88:	df0022c4 	addi	fp,sp,139
81126e8c:	d8c03317 	ldw	r3,204(sp)
81126e90:	1739c83a 	sub	fp,r2,fp
81126e94:	d9003317 	ldw	r4,204(sp)
81126e98:	e0c7883a 	add	r3,fp,r3
81126e9c:	df003a15 	stw	fp,232(sp)
81126ea0:	d8c02e15 	stw	r3,184(sp)
81126ea4:	00800044 	movi	r2,1
81126ea8:	1100b30e 	bge	r2,r4,81127178 <___vfprintf_internal_r+0x2118>
81126eac:	d8c02e17 	ldw	r3,184(sp)
81126eb0:	18c00044 	addi	r3,r3,1
81126eb4:	d8c02e15 	stw	r3,184(sp)
81126eb8:	1805883a 	mov	r2,r3
81126ebc:	1800ac16 	blt	r3,zero,81127170 <___vfprintf_internal_r+0x2110>
81126ec0:	d8003215 	stw	zero,200(sp)
81126ec4:	003e5d06 	br	8112683c <__reset+0xfb10683c>
81126ec8:	d9002c17 	ldw	r4,176(sp)
81126ecc:	d9801e04 	addi	r6,sp,120
81126ed0:	b80b883a 	mov	r5,r23
81126ed4:	11312500 	call	81131250 <__sprint_r>
81126ed8:	1039651e 	bne	r2,zero,81125470 <__reset+0xfb105470>
81126edc:	dc402617 	ldw	r17,152(sp)
81126ee0:	d8c02017 	ldw	r3,128(sp)
81126ee4:	d8801f17 	ldw	r2,124(sp)
81126ee8:	da000404 	addi	r8,sp,16
81126eec:	003ed606 	br	81126a48 <__reset+0xfb106a48>
81126ef0:	582b883a 	mov	r21,r11
81126ef4:	d8002915 	stw	zero,164(sp)
81126ef8:	0038bd06 	br	811251f0 <__reset+0xfb1051f0>
81126efc:	d8802917 	ldw	r2,164(sp)
81126f00:	103e071e 	bne	r2,zero,81126720 <__reset+0xfb106720>
81126f04:	dc002915 	stw	r16,164(sp)
81126f08:	003e0506 	br	81126720 <__reset+0xfb106720>
81126f0c:	d9002917 	ldw	r4,164(sp)
81126f10:	20c00044 	addi	r3,r4,1
81126f14:	003e0f06 	br	81126754 <__reset+0xfb106754>
81126f18:	01400184 	movi	r5,6
81126f1c:	d9402915 	stw	r5,164(sp)
81126f20:	003dff06 	br	81126720 <__reset+0xfb106720>
81126f24:	d8802104 	addi	r2,sp,132
81126f28:	d8800315 	stw	r2,12(sp)
81126f2c:	d8802504 	addi	r2,sp,148
81126f30:	d8800215 	stw	r2,8(sp)
81126f34:	d8802604 	addi	r2,sp,152
81126f38:	d8800115 	stw	r2,4(sp)
81126f3c:	d8802917 	ldw	r2,164(sp)
81126f40:	d9403617 	ldw	r5,216(sp)
81126f44:	d9002c17 	ldw	r4,176(sp)
81126f48:	d8800015 	stw	r2,0(sp)
81126f4c:	01c000c4 	movi	r7,3
81126f50:	980d883a 	mov	r6,r19
81126f54:	da003d15 	stw	r8,244(sp)
81126f58:	112916c0 	call	8112916c <_dtoa_r>
81126f5c:	d8c02917 	ldw	r3,164(sp)
81126f60:	da003d17 	ldw	r8,244(sp)
81126f64:	1021883a 	mov	r16,r2
81126f68:	10f9883a 	add	fp,r2,r3
81126f6c:	81000007 	ldb	r4,0(r16)
81126f70:	00800c04 	movi	r2,48
81126f74:	20805e26 	beq	r4,r2,811270f0 <___vfprintf_internal_r+0x2090>
81126f78:	d8c02617 	ldw	r3,152(sp)
81126f7c:	e0f9883a 	add	fp,fp,r3
81126f80:	003e0a06 	br	811267ac <__reset+0xfb1067ac>
81126f84:	00c00b44 	movi	r3,45
81126f88:	24e0003c 	xorhi	r19,r4,32768
81126f8c:	d8c02a05 	stb	r3,168(sp)
81126f90:	003de906 	br	81126738 <__reset+0xfb106738>
81126f94:	d8c03217 	ldw	r3,200(sp)
81126f98:	00c07a0e 	bge	zero,r3,81127184 <___vfprintf_internal_r+0x2124>
81126f9c:	00800044 	movi	r2,1
81126fa0:	d9003317 	ldw	r4,204(sp)
81126fa4:	1105883a 	add	r2,r2,r4
81126fa8:	d8802e15 	stw	r2,184(sp)
81126fac:	10004e16 	blt	r2,zero,811270e8 <___vfprintf_internal_r+0x2088>
81126fb0:	044019c4 	movi	r17,103
81126fb4:	003e2106 	br	8112683c <__reset+0xfb10683c>
81126fb8:	d9002917 	ldw	r4,164(sp)
81126fbc:	d8802104 	addi	r2,sp,132
81126fc0:	d8800315 	stw	r2,12(sp)
81126fc4:	d9000015 	stw	r4,0(sp)
81126fc8:	d8802504 	addi	r2,sp,148
81126fcc:	d9403617 	ldw	r5,216(sp)
81126fd0:	d9002c17 	ldw	r4,176(sp)
81126fd4:	d8800215 	stw	r2,8(sp)
81126fd8:	d8802604 	addi	r2,sp,152
81126fdc:	d8800115 	stw	r2,4(sp)
81126fe0:	01c000c4 	movi	r7,3
81126fe4:	980d883a 	mov	r6,r19
81126fe8:	da003d15 	stw	r8,244(sp)
81126fec:	112916c0 	call	8112916c <_dtoa_r>
81126ff0:	d8c02917 	ldw	r3,164(sp)
81126ff4:	da003d17 	ldw	r8,244(sp)
81126ff8:	1021883a 	mov	r16,r2
81126ffc:	00801184 	movi	r2,70
81127000:	80f9883a 	add	fp,r16,r3
81127004:	88bfd926 	beq	r17,r2,81126f6c <__reset+0xfb106f6c>
81127008:	003de806 	br	811267ac <__reset+0xfb1067ac>
8112700c:	d9002917 	ldw	r4,164(sp)
81127010:	00c04d0e 	bge	zero,r3,81127148 <___vfprintf_internal_r+0x20e8>
81127014:	2000441e 	bne	r4,zero,81127128 <___vfprintf_internal_r+0x20c8>
81127018:	9480004c 	andi	r18,r18,1
8112701c:	9000421e 	bne	r18,zero,81127128 <___vfprintf_internal_r+0x20c8>
81127020:	1805883a 	mov	r2,r3
81127024:	18007016 	blt	r3,zero,811271e8 <___vfprintf_internal_r+0x2188>
81127028:	d8c03217 	ldw	r3,200(sp)
8112702c:	d8c02e15 	stw	r3,184(sp)
81127030:	003e0206 	br	8112683c <__reset+0xfb10683c>
81127034:	df0022c4 	addi	fp,sp,139
81127038:	dc002915 	stw	r16,164(sp)
8112703c:	4027883a 	mov	r19,r8
81127040:	e021883a 	mov	r16,fp
81127044:	b009883a 	mov	r4,r22
81127048:	01400284 	movi	r5,10
8112704c:	113454c0 	call	8113454c <__modsi3>
81127050:	10800c04 	addi	r2,r2,48
81127054:	843fffc4 	addi	r16,r16,-1
81127058:	b009883a 	mov	r4,r22
8112705c:	01400284 	movi	r5,10
81127060:	80800005 	stb	r2,0(r16)
81127064:	11344c80 	call	811344c8 <__divsi3>
81127068:	102d883a 	mov	r22,r2
8112706c:	00800244 	movi	r2,9
81127070:	15bff416 	blt	r2,r22,81127044 <__reset+0xfb107044>
81127074:	9811883a 	mov	r8,r19
81127078:	b0800c04 	addi	r2,r22,48
8112707c:	8027883a 	mov	r19,r16
81127080:	997fffc4 	addi	r5,r19,-1
81127084:	98bfffc5 	stb	r2,-1(r19)
81127088:	dc002917 	ldw	r16,164(sp)
8112708c:	2f006a2e 	bgeu	r5,fp,81127238 <___vfprintf_internal_r+0x21d8>
81127090:	d9c02384 	addi	r7,sp,142
81127094:	3ccfc83a 	sub	r7,r7,r19
81127098:	d9002344 	addi	r4,sp,141
8112709c:	e1cf883a 	add	r7,fp,r7
811270a0:	00000106 	br	811270a8 <___vfprintf_internal_r+0x2048>
811270a4:	28800003 	ldbu	r2,0(r5)
811270a8:	20800005 	stb	r2,0(r4)
811270ac:	21000044 	addi	r4,r4,1
811270b0:	29400044 	addi	r5,r5,1
811270b4:	393ffb1e 	bne	r7,r4,811270a4 <__reset+0xfb1070a4>
811270b8:	d8802304 	addi	r2,sp,140
811270bc:	14c5c83a 	sub	r2,r2,r19
811270c0:	d8c02344 	addi	r3,sp,141
811270c4:	1885883a 	add	r2,r3,r2
811270c8:	003f7006 	br	81126e8c <__reset+0xfb106e8c>
811270cc:	0005883a 	mov	r2,zero
811270d0:	003f0f06 	br	81126d10 <__reset+0xfb106d10>
811270d4:	d8c03217 	ldw	r3,200(sp)
811270d8:	18c00044 	addi	r3,r3,1
811270dc:	d8c02e15 	stw	r3,184(sp)
811270e0:	1805883a 	mov	r2,r3
811270e4:	183fb20e 	bge	r3,zero,81126fb0 <__reset+0xfb106fb0>
811270e8:	0005883a 	mov	r2,zero
811270ec:	003fb006 	br	81126fb0 <__reset+0xfb106fb0>
811270f0:	d9003617 	ldw	r4,216(sp)
811270f4:	000d883a 	mov	r6,zero
811270f8:	000f883a 	mov	r7,zero
811270fc:	980b883a 	mov	r5,r19
81127100:	d8c03c15 	stw	r3,240(sp)
81127104:	da003d15 	stw	r8,244(sp)
81127108:	1135a1c0 	call	81135a1c <__eqdf2>
8112710c:	d8c03c17 	ldw	r3,240(sp)
81127110:	da003d17 	ldw	r8,244(sp)
81127114:	103f9826 	beq	r2,zero,81126f78 <__reset+0xfb106f78>
81127118:	00800044 	movi	r2,1
8112711c:	10c7c83a 	sub	r3,r2,r3
81127120:	d8c02615 	stw	r3,152(sp)
81127124:	003f9506 	br	81126f7c <__reset+0xfb106f7c>
81127128:	d9002917 	ldw	r4,164(sp)
8112712c:	d8c03217 	ldw	r3,200(sp)
81127130:	20800044 	addi	r2,r4,1
81127134:	1885883a 	add	r2,r3,r2
81127138:	d8802e15 	stw	r2,184(sp)
8112713c:	103dbf0e 	bge	r2,zero,8112683c <__reset+0xfb10683c>
81127140:	0005883a 	mov	r2,zero
81127144:	003dbd06 	br	8112683c <__reset+0xfb10683c>
81127148:	2000211e 	bne	r4,zero,811271d0 <___vfprintf_internal_r+0x2170>
8112714c:	9480004c 	andi	r18,r18,1
81127150:	90001f1e 	bne	r18,zero,811271d0 <___vfprintf_internal_r+0x2170>
81127154:	00800044 	movi	r2,1
81127158:	d8802e15 	stw	r2,184(sp)
8112715c:	003db706 	br	8112683c <__reset+0xfb10683c>
81127160:	00800b44 	movi	r2,45
81127164:	05adc83a 	sub	r22,zero,r22
81127168:	d8802305 	stb	r2,140(sp)
8112716c:	003f3f06 	br	81126e6c <__reset+0xfb106e6c>
81127170:	0005883a 	mov	r2,zero
81127174:	003f5206 	br	81126ec0 <__reset+0xfb106ec0>
81127178:	90a4703a 	and	r18,r18,r2
8112717c:	903f4e26 	beq	r18,zero,81126eb8 <__reset+0xfb106eb8>
81127180:	003f4a06 	br	81126eac <__reset+0xfb106eac>
81127184:	00800084 	movi	r2,2
81127188:	10c5c83a 	sub	r2,r2,r3
8112718c:	003f8406 	br	81126fa0 <__reset+0xfb106fa0>
81127190:	d8802d17 	ldw	r2,180(sp)
81127194:	d9002d17 	ldw	r4,180(sp)
81127198:	ac400043 	ldbu	r17,1(r21)
8112719c:	10800017 	ldw	r2,0(r2)
811271a0:	582b883a 	mov	r21,r11
811271a4:	d8802915 	stw	r2,164(sp)
811271a8:	20800104 	addi	r2,r4,4
811271ac:	d9002917 	ldw	r4,164(sp)
811271b0:	d8802d15 	stw	r2,180(sp)
811271b4:	203e7a0e 	bge	r4,zero,81126ba0 <__reset+0xfb106ba0>
811271b8:	8c403fcc 	andi	r17,r17,255
811271bc:	00bfffc4 	movi	r2,-1
811271c0:	8c40201c 	xori	r17,r17,128
811271c4:	d8802915 	stw	r2,164(sp)
811271c8:	8c7fe004 	addi	r17,r17,-128
811271cc:	00380706 	br	811251ec <__reset+0xfb1051ec>
811271d0:	d8c02917 	ldw	r3,164(sp)
811271d4:	18c00084 	addi	r3,r3,2
811271d8:	d8c02e15 	stw	r3,184(sp)
811271dc:	1805883a 	mov	r2,r3
811271e0:	183d960e 	bge	r3,zero,8112683c <__reset+0xfb10683c>
811271e4:	003fd606 	br	81127140 <__reset+0xfb107140>
811271e8:	0005883a 	mov	r2,zero
811271ec:	003f8e06 	br	81127028 <__reset+0xfb107028>
811271f0:	9080004c 	andi	r2,r18,1
811271f4:	103f811e 	bne	r2,zero,81126ffc <__reset+0xfb106ffc>
811271f8:	d8802117 	ldw	r2,132(sp)
811271fc:	1405c83a 	sub	r2,r2,r16
81127200:	d8803315 	stw	r2,204(sp)
81127204:	b47ef326 	beq	r22,r17,81126dd4 <__reset+0xfb106dd4>
81127208:	dd802617 	ldw	r22,152(sp)
8112720c:	003f1106 	br	81126e54 <__reset+0xfb106e54>
81127210:	d9c02785 	stb	r7,158(sp)
81127214:	00390406 	br	81125628 <__reset+0xfb105628>
81127218:	d9c02785 	stb	r7,158(sp)
8112721c:	0038d306 	br	8112556c <__reset+0xfb10556c>
81127220:	d9c02785 	stb	r7,158(sp)
81127224:	003a6106 	br	81125bac <__reset+0xfb105bac>
81127228:	d9c02785 	stb	r7,158(sp)
8112722c:	003af806 	br	81125e10 <__reset+0xfb105e10>
81127230:	0005883a 	mov	r2,zero
81127234:	003d7e06 	br	81126830 <__reset+0xfb106830>
81127238:	d8802344 	addi	r2,sp,141
8112723c:	003f1306 	br	81126e8c <__reset+0xfb106e8c>
81127240:	d9c02785 	stb	r7,158(sp)
81127244:	00392306 	br	811256d4 <__reset+0xfb1056d4>
81127248:	d9c02785 	stb	r7,158(sp)
8112724c:	003aa906 	br	81125cf4 <__reset+0xfb105cf4>
81127250:	d9c02785 	stb	r7,158(sp)
81127254:	003a3d06 	br	81125b4c <__reset+0xfb105b4c>
81127258:	d9c02785 	stb	r7,158(sp)
8112725c:	003aca06 	br	81125d88 <__reset+0xfb105d88>

81127260 <__vfprintf_internal>:
81127260:	00a04574 	movhi	r2,33045
81127264:	108ad804 	addi	r2,r2,11104
81127268:	300f883a 	mov	r7,r6
8112726c:	280d883a 	mov	r6,r5
81127270:	200b883a 	mov	r5,r4
81127274:	11000017 	ldw	r4,0(r2)
81127278:	11250601 	jmpi	81125060 <___vfprintf_internal_r>

8112727c <__sbprintf>:
8112727c:	defee204 	addi	sp,sp,-1144
81127280:	de00012e 	bgeu	sp,et,81127288 <__sbprintf+0xc>
81127284:	003b68fa 	trap	3
81127288:	2880030b 	ldhu	r2,12(r5)
8112728c:	2ac01917 	ldw	r11,100(r5)
81127290:	2a80038b 	ldhu	r10,14(r5)
81127294:	2a400717 	ldw	r9,28(r5)
81127298:	2a000917 	ldw	r8,36(r5)
8112729c:	00c10004 	movi	r3,1024
811272a0:	dc011a15 	stw	r16,1128(sp)
811272a4:	10bfff4c 	andi	r2,r2,65533
811272a8:	2821883a 	mov	r16,r5
811272ac:	d8cb883a 	add	r5,sp,r3
811272b0:	dc811c15 	stw	r18,1136(sp)
811272b4:	dc411b15 	stw	r17,1132(sp)
811272b8:	dfc11d15 	stw	ra,1140(sp)
811272bc:	2025883a 	mov	r18,r4
811272c0:	d881030d 	sth	r2,1036(sp)
811272c4:	dac11915 	stw	r11,1124(sp)
811272c8:	da81038d 	sth	r10,1038(sp)
811272cc:	da410715 	stw	r9,1052(sp)
811272d0:	da010915 	stw	r8,1060(sp)
811272d4:	dec10015 	stw	sp,1024(sp)
811272d8:	dec10415 	stw	sp,1040(sp)
811272dc:	d8c10215 	stw	r3,1032(sp)
811272e0:	d8c10515 	stw	r3,1044(sp)
811272e4:	d8010615 	stw	zero,1048(sp)
811272e8:	11250600 	call	81125060 <___vfprintf_internal_r>
811272ec:	1023883a 	mov	r17,r2
811272f0:	10000416 	blt	r2,zero,81127304 <__sbprintf+0x88>
811272f4:	d9410004 	addi	r5,sp,1024
811272f8:	9009883a 	mov	r4,r18
811272fc:	112aa200 	call	8112aa20 <_fflush_r>
81127300:	10000d1e 	bne	r2,zero,81127338 <__sbprintf+0xbc>
81127304:	d881030b 	ldhu	r2,1036(sp)
81127308:	1080100c 	andi	r2,r2,64
8112730c:	10000326 	beq	r2,zero,8112731c <__sbprintf+0xa0>
81127310:	8080030b 	ldhu	r2,12(r16)
81127314:	10801014 	ori	r2,r2,64
81127318:	8080030d 	sth	r2,12(r16)
8112731c:	8805883a 	mov	r2,r17
81127320:	dfc11d17 	ldw	ra,1140(sp)
81127324:	dc811c17 	ldw	r18,1136(sp)
81127328:	dc411b17 	ldw	r17,1132(sp)
8112732c:	dc011a17 	ldw	r16,1128(sp)
81127330:	dec11e04 	addi	sp,sp,1144
81127334:	f800283a 	ret
81127338:	047fffc4 	movi	r17,-1
8112733c:	003ff106 	br	81127304 <__reset+0xfb107304>

81127340 <__svfscanf_r>:
81127340:	deff4b04 	addi	sp,sp,-724
81127344:	de00012e 	bgeu	sp,et,8112734c <__svfscanf_r+0xc>
81127348:	003b68fa 	trap	3
8112734c:	2880030b 	ldhu	r2,12(r5)
81127350:	df00b315 	stw	fp,716(sp)
81127354:	dd80b115 	stw	r22,708(sp)
81127358:	dfc0b415 	stw	ra,720(sp)
8112735c:	ddc0b215 	stw	r23,712(sp)
81127360:	dd40b015 	stw	r21,704(sp)
81127364:	dd00af15 	stw	r20,700(sp)
81127368:	dcc0ae15 	stw	r19,696(sp)
8112736c:	dc80ad15 	stw	r18,692(sp)
81127370:	dc40ac15 	stw	r17,688(sp)
81127374:	dc00ab15 	stw	r16,684(sp)
81127378:	10c8000c 	andi	r3,r2,8192
8112737c:	d9c09c15 	stw	r7,624(sp)
81127380:	2839883a 	mov	fp,r5
81127384:	202d883a 	mov	r22,r4
81127388:	1800061e 	bne	r3,zero,811273a4 <__svfscanf_r+0x64>
8112738c:	29001917 	ldw	r4,100(r5)
81127390:	00f7ffc4 	movi	r3,-8193
81127394:	10880014 	ori	r2,r2,8192
81127398:	20c6703a 	and	r3,r4,r3
8112739c:	2880030d 	sth	r2,12(r5)
811273a0:	28c01915 	stw	r3,100(r5)
811273a4:	30800003 	ldbu	r2,0(r6)
811273a8:	0021883a 	mov	r16,zero
811273ac:	05e04574 	movhi	r23,33045
811273b0:	d800a115 	stw	zero,644(sp)
811273b4:	d8009e15 	stw	zero,632(sp)
811273b8:	d800a015 	stw	zero,640(sp)
811273bc:	d8809b15 	stw	r2,620(sp)
811273c0:	bdcad604 	addi	r23,r23,11096
811273c4:	8025883a 	mov	r18,r16
811273c8:	35000044 	addi	r20,r6,1
811273cc:	10001e26 	beq	r2,zero,81127448 <__svfscanf_r+0x108>
811273d0:	b9c00017 	ldw	r7,0(r23)
811273d4:	3887883a 	add	r3,r7,r2
811273d8:	18c00043 	ldbu	r3,1(r3)
811273dc:	18c0020c 	andi	r3,r3,8
811273e0:	18001b26 	beq	r3,zero,81127450 <__svfscanf_r+0x110>
811273e4:	e0800117 	ldw	r2,4(fp)
811273e8:	00800e0e 	bge	zero,r2,81127424 <__svfscanf_r+0xe4>
811273ec:	e0c00017 	ldw	r3,0(fp)
811273f0:	b9000017 	ldw	r4,0(r23)
811273f4:	18800003 	ldbu	r2,0(r3)
811273f8:	2085883a 	add	r2,r4,r2
811273fc:	10800043 	ldbu	r2,1(r2)
81127400:	1080020c 	andi	r2,r2,8
81127404:	10000b26 	beq	r2,zero,81127434 <__svfscanf_r+0xf4>
81127408:	e0800117 	ldw	r2,4(fp)
8112740c:	18c00044 	addi	r3,r3,1
81127410:	e0c00015 	stw	r3,0(fp)
81127414:	10bfffc4 	addi	r2,r2,-1
81127418:	e0800115 	stw	r2,4(fp)
8112741c:	94800044 	addi	r18,r18,1
81127420:	00bff216 	blt	zero,r2,811273ec <__reset+0xfb1073ec>
81127424:	e00b883a 	mov	r5,fp
81127428:	b009883a 	mov	r4,r22
8112742c:	11226200 	call	81122620 <__srefill_r>
81127430:	103fee26 	beq	r2,zero,811273ec <__reset+0xfb1073ec>
81127434:	a00d883a 	mov	r6,r20
81127438:	30800003 	ldbu	r2,0(r6)
8112743c:	35000044 	addi	r20,r6,1
81127440:	d8809b15 	stw	r2,620(sp)
81127444:	103fe21e 	bne	r2,zero,811273d0 <__reset+0xfb1073d0>
81127448:	d880a017 	ldw	r2,640(sp)
8112744c:	00009906 	br	811276b4 <__svfscanf_r+0x374>
81127450:	00c00944 	movi	r3,37
81127454:	10c0881e 	bne	r2,r3,81127678 <__svfscanf_r+0x338>
81127458:	30c00043 	ldbu	r3,1(r6)
8112745c:	0023883a 	mov	r17,zero
81127460:	0027883a 	mov	r19,zero
81127464:	01001e04 	movi	r4,120
81127468:	01401b04 	movi	r5,108
8112746c:	a1800044 	addi	r6,r20,1
81127470:	20c0a236 	bltu	r4,r3,811276fc <__svfscanf_r+0x3bc>
81127474:	180490ba 	slli	r2,r3,2
81127478:	022044b4 	movhi	r8,33042
8112747c:	421d2304 	addi	r8,r8,29836
81127480:	1205883a 	add	r2,r2,r8
81127484:	10800017 	ldw	r2,0(r2)
81127488:	1000683a 	jmp	r2
8112748c:	811276b0 	cmpltui	r4,r16,18906
81127490:	811276fc 	xorhi	r4,r16,18907
81127494:	811276fc 	xorhi	r4,r16,18907
81127498:	811276fc 	xorhi	r4,r16,18907
8112749c:	811276fc 	xorhi	r4,r16,18907
811274a0:	811276fc 	xorhi	r4,r16,18907
811274a4:	811276fc 	xorhi	r4,r16,18907
811274a8:	811276fc 	xorhi	r4,r16,18907
811274ac:	811276fc 	xorhi	r4,r16,18907
811274b0:	811276fc 	xorhi	r4,r16,18907
811274b4:	811276fc 	xorhi	r4,r16,18907
811274b8:	811276fc 	xorhi	r4,r16,18907
811274bc:	811276fc 	xorhi	r4,r16,18907
811274c0:	811276fc 	xorhi	r4,r16,18907
811274c4:	811276fc 	xorhi	r4,r16,18907
811274c8:	811276fc 	xorhi	r4,r16,18907
811274cc:	811276fc 	xorhi	r4,r16,18907
811274d0:	811276fc 	xorhi	r4,r16,18907
811274d4:	811276fc 	xorhi	r4,r16,18907
811274d8:	811276fc 	xorhi	r4,r16,18907
811274dc:	811276fc 	xorhi	r4,r16,18907
811274e0:	811276fc 	xorhi	r4,r16,18907
811274e4:	811276fc 	xorhi	r4,r16,18907
811274e8:	811276fc 	xorhi	r4,r16,18907
811274ec:	811276fc 	xorhi	r4,r16,18907
811274f0:	811276fc 	xorhi	r4,r16,18907
811274f4:	811276fc 	xorhi	r4,r16,18907
811274f8:	811276fc 	xorhi	r4,r16,18907
811274fc:	811276fc 	xorhi	r4,r16,18907
81127500:	811276fc 	xorhi	r4,r16,18907
81127504:	811276fc 	xorhi	r4,r16,18907
81127508:	811276fc 	xorhi	r4,r16,18907
8112750c:	811276fc 	xorhi	r4,r16,18907
81127510:	811276fc 	xorhi	r4,r16,18907
81127514:	811276fc 	xorhi	r4,r16,18907
81127518:	811276fc 	xorhi	r4,r16,18907
8112751c:	811276fc 	xorhi	r4,r16,18907
81127520:	81127670 	cmpltui	r4,r16,18905
81127524:	811276fc 	xorhi	r4,r16,18907
81127528:	811276fc 	xorhi	r4,r16,18907
8112752c:	811276fc 	xorhi	r4,r16,18907
81127530:	811276fc 	xorhi	r4,r16,18907
81127534:	811276e4 	muli	r4,r16,18907
81127538:	811276fc 	xorhi	r4,r16,18907
8112753c:	811276fc 	xorhi	r4,r16,18907
81127540:	811276fc 	xorhi	r4,r16,18907
81127544:	811276fc 	xorhi	r4,r16,18907
81127548:	811276fc 	xorhi	r4,r16,18907
8112754c:	81127818 	cmpnei	r4,r16,18912
81127550:	81127818 	cmpnei	r4,r16,18912
81127554:	81127818 	cmpnei	r4,r16,18912
81127558:	81127818 	cmpnei	r4,r16,18912
8112755c:	81127818 	cmpnei	r4,r16,18912
81127560:	81127818 	cmpnei	r4,r16,18912
81127564:	81127818 	cmpnei	r4,r16,18912
81127568:	81127818 	cmpnei	r4,r16,18912
8112756c:	81127818 	cmpnei	r4,r16,18912
81127570:	81127818 	cmpnei	r4,r16,18912
81127574:	811276fc 	xorhi	r4,r16,18907
81127578:	811276fc 	xorhi	r4,r16,18907
8112757c:	811276fc 	xorhi	r4,r16,18907
81127580:	811276fc 	xorhi	r4,r16,18907
81127584:	811276fc 	xorhi	r4,r16,18907
81127588:	811276fc 	xorhi	r4,r16,18907
8112758c:	811276fc 	xorhi	r4,r16,18907
81127590:	811276fc 	xorhi	r4,r16,18907
81127594:	811276fc 	xorhi	r4,r16,18907
81127598:	811276fc 	xorhi	r4,r16,18907
8112759c:	811277ec 	andhi	r4,r16,18911
811275a0:	8112789c 	xori	r4,r16,18914
811275a4:	811276fc 	xorhi	r4,r16,18907
811275a8:	8112789c 	xori	r4,r16,18914
811275ac:	811276fc 	xorhi	r4,r16,18907
811275b0:	811276fc 	xorhi	r4,r16,18907
811275b4:	811276fc 	xorhi	r4,r16,18907
811275b8:	811276fc 	xorhi	r4,r16,18907
811275bc:	81127888 	cmpgei	r4,r16,18914
811275c0:	811276fc 	xorhi	r4,r16,18907
811275c4:	811276fc 	xorhi	r4,r16,18907
811275c8:	8112785c 	xori	r4,r16,18913
811275cc:	811276fc 	xorhi	r4,r16,18907
811275d0:	811276fc 	xorhi	r4,r16,18907
811275d4:	811276fc 	xorhi	r4,r16,18907
811275d8:	811276fc 	xorhi	r4,r16,18907
811275dc:	811276fc 	xorhi	r4,r16,18907
811275e0:	811276fc 	xorhi	r4,r16,18907
811275e4:	811276fc 	xorhi	r4,r16,18907
811275e8:	811276fc 	xorhi	r4,r16,18907
811275ec:	81127834 	orhi	r4,r16,18912
811275f0:	811276fc 	xorhi	r4,r16,18907
811275f4:	811276fc 	xorhi	r4,r16,18907
811275f8:	811279d0 	cmplti	r4,r16,18919
811275fc:	811276fc 	xorhi	r4,r16,18907
81127600:	811276fc 	xorhi	r4,r16,18907
81127604:	811276fc 	xorhi	r4,r16,18907
81127608:	811276fc 	xorhi	r4,r16,18907
8112760c:	811276fc 	xorhi	r4,r16,18907
81127610:	811276fc 	xorhi	r4,r16,18907
81127614:	811276fc 	xorhi	r4,r16,18907
81127618:	81127954 	ori	r4,r16,18917
8112761c:	8112792c 	andhi	r4,r16,18916
81127620:	8112789c 	xori	r4,r16,18914
81127624:	8112789c 	xori	r4,r16,18914
81127628:	8112789c 	xori	r4,r16,18914
8112762c:	81127918 	cmpnei	r4,r16,18916
81127630:	81127a5c 	xori	r4,r16,18921
81127634:	811276fc 	xorhi	r4,r16,18907
81127638:	811276fc 	xorhi	r4,r16,18907
8112763c:	81127904 	addi	r4,r16,18916
81127640:	811276fc 	xorhi	r4,r16,18907
81127644:	811278d4 	ori	r4,r16,18915
81127648:	811278b0 	cmpltui	r4,r16,18914
8112764c:	811277c0 	call	8811277c <__reset+0x20f277c>
81127650:	811276fc 	xorhi	r4,r16,18907
81127654:	811276fc 	xorhi	r4,r16,18907
81127658:	811277ac 	andhi	r4,r16,18910
8112765c:	811276fc 	xorhi	r4,r16,18907
81127660:	81127734 	orhi	r4,r16,18908
81127664:	811276fc 	xorhi	r4,r16,18907
81127668:	811276fc 	xorhi	r4,r16,18907
8112766c:	81127834 	orhi	r4,r16,18912
81127670:	d9809d15 	stw	r6,628(sp)
81127674:	3029883a 	mov	r20,r6
81127678:	e0800117 	ldw	r2,4(fp)
8112767c:	0081aa0e 	bge	zero,r2,81127d28 <__svfscanf_r+0x9e8>
81127680:	e0800017 	ldw	r2,0(fp)
81127684:	a0ffffc3 	ldbu	r3,-1(r20)
81127688:	11000003 	ldbu	r4,0(r2)
8112768c:	20ff6e1e 	bne	r4,r3,81127448 <__reset+0xfb107448>
81127690:	e0c00117 	ldw	r3,4(fp)
81127694:	10800044 	addi	r2,r2,1
81127698:	e0800015 	stw	r2,0(fp)
8112769c:	18bfffc4 	addi	r2,r3,-1
811276a0:	e0800115 	stw	r2,4(fp)
811276a4:	94800044 	addi	r18,r18,1
811276a8:	a00d883a 	mov	r6,r20
811276ac:	003f6206 	br	81127438 <__reset+0xfb107438>
811276b0:	00bfffc4 	movi	r2,-1
811276b4:	dfc0b417 	ldw	ra,720(sp)
811276b8:	df00b317 	ldw	fp,716(sp)
811276bc:	ddc0b217 	ldw	r23,712(sp)
811276c0:	dd80b117 	ldw	r22,708(sp)
811276c4:	dd40b017 	ldw	r21,704(sp)
811276c8:	dd00af17 	ldw	r20,700(sp)
811276cc:	dcc0ae17 	ldw	r19,696(sp)
811276d0:	dc80ad17 	ldw	r18,692(sp)
811276d4:	dc40ac17 	ldw	r17,688(sp)
811276d8:	dc00ab17 	ldw	r16,684(sp)
811276dc:	dec0b504 	addi	sp,sp,724
811276e0:	f800283a 	ret
811276e4:	a0800043 	ldbu	r2,1(r20)
811276e8:	3029883a 	mov	r20,r6
811276ec:	8c400414 	ori	r17,r17,16
811276f0:	10c03fcc 	andi	r3,r2,255
811276f4:	a1800044 	addi	r6,r20,1
811276f8:	20ff5e2e 	bgeu	r4,r3,81127474 <__reset+0xfb107474>
811276fc:	38c7883a 	add	r3,r7,r3
81127700:	18800043 	ldbu	r2,1(r3)
81127704:	d9809d15 	stw	r6,628(sp)
81127708:	00c00044 	movi	r3,1
8112770c:	108000cc 	andi	r2,r2,3
81127710:	10c18f26 	beq	r2,r3,81127d50 <__svfscanf_r+0xa10>
81127714:	e0800117 	ldw	r2,4(fp)
81127718:	00808716 	blt	zero,r2,81127938 <__svfscanf_r+0x5f8>
8112771c:	e00b883a 	mov	r5,fp
81127720:	b009883a 	mov	r4,r22
81127724:	11226200 	call	81122620 <__srefill_r>
81127728:	1001431e 	bne	r2,zero,81127c38 <__svfscanf_r+0x8f8>
8112772c:	b9c00017 	ldw	r7,0(r23)
81127730:	00008106 	br	81127938 <__svfscanf_r+0x5f8>
81127734:	e0800117 	ldw	r2,4(fp)
81127738:	d9809d15 	stw	r6,628(sp)
8112773c:	0081a30e 	bge	zero,r2,81127dcc <__svfscanf_r+0xa8c>
81127740:	00a044f4 	movhi	r2,33043
81127744:	10bd5404 	addi	r2,r2,-2736
81127748:	02000284 	movi	r8,10
8112774c:	d880a115 	stw	r2,644(sp)
81127750:	da009e15 	stw	r8,632(sp)
81127754:	050000c4 	movi	r20,3
81127758:	e0c00017 	ldw	r3,0(fp)
8112775c:	00000206 	br	81127768 <__svfscanf_r+0x428>
81127760:	18c00044 	addi	r3,r3,1
81127764:	e0c00015 	stw	r3,0(fp)
81127768:	19000003 	ldbu	r4,0(r3)
8112776c:	20803fcc 	andi	r2,r4,255
81127770:	3885883a 	add	r2,r7,r2
81127774:	10800043 	ldbu	r2,1(r2)
81127778:	1140020c 	andi	r5,r2,8
8112777c:	2801ab26 	beq	r5,zero,81127e2c <__svfscanf_r+0xaec>
81127780:	e0800117 	ldw	r2,4(fp)
81127784:	94800044 	addi	r18,r18,1
81127788:	10bfffc4 	addi	r2,r2,-1
8112778c:	e0800115 	stw	r2,4(fp)
81127790:	00bff316 	blt	zero,r2,81127760 <__reset+0xfb107760>
81127794:	e00b883a 	mov	r5,fp
81127798:	b009883a 	mov	r4,r22
8112779c:	11226200 	call	81122620 <__srefill_r>
811277a0:	1001251e 	bne	r2,zero,81127c38 <__svfscanf_r+0x8f8>
811277a4:	b9c00017 	ldw	r7,0(r23)
811277a8:	003feb06 	br	81127758 <__reset+0xfb107758>
811277ac:	e0800117 	ldw	r2,4(fp)
811277b0:	d9809d15 	stw	r6,628(sp)
811277b4:	00818b0e 	bge	zero,r2,81127de4 <__svfscanf_r+0xaa4>
811277b8:	05000084 	movi	r20,2
811277bc:	003fe606 	br	81127758 <__reset+0xfb107758>
811277c0:	e0800117 	ldw	r2,4(fp)
811277c4:	d9809d15 	stw	r6,628(sp)
811277c8:	8c408814 	ori	r17,r17,544
811277cc:	00801d0e 	bge	zero,r2,81127844 <__svfscanf_r+0x504>
811277d0:	00a044f4 	movhi	r2,33043
811277d4:	10bd5404 	addi	r2,r2,-2736
811277d8:	02000404 	movi	r8,16
811277dc:	d880a115 	stw	r2,644(sp)
811277e0:	da009e15 	stw	r8,632(sp)
811277e4:	050000c4 	movi	r20,3
811277e8:	003fdb06 	br	81127758 <__reset+0xfb107758>
811277ec:	e0800117 	ldw	r2,4(fp)
811277f0:	d9809d15 	stw	r6,628(sp)
811277f4:	8c400054 	ori	r17,r17,1
811277f8:	00bfc80e 	bge	zero,r2,8112771c <__reset+0xfb10771c>
811277fc:	00e044b4 	movhi	r3,33042
81127800:	18cb0904 	addi	r3,r3,11300
81127804:	02000284 	movi	r8,10
81127808:	d8c0a115 	stw	r3,644(sp)
8112780c:	da009e15 	stw	r8,632(sp)
81127810:	050000c4 	movi	r20,3
81127814:	003fd006 	br	81127758 <__reset+0xfb107758>
81127818:	9cc002a4 	muli	r19,r19,10
8112781c:	a0800043 	ldbu	r2,1(r20)
81127820:	3029883a 	mov	r20,r6
81127824:	98e7883a 	add	r19,r19,r3
81127828:	9cfff404 	addi	r19,r19,-48
8112782c:	10c03fcc 	andi	r3,r2,255
81127830:	003f0e06 	br	8112746c <__reset+0xfb10746c>
81127834:	e0800117 	ldw	r2,4(fp)
81127838:	d9809d15 	stw	r6,628(sp)
8112783c:	8c408014 	ori	r17,r17,512
81127840:	00bfe316 	blt	zero,r2,811277d0 <__reset+0xfb1077d0>
81127844:	e00b883a 	mov	r5,fp
81127848:	b009883a 	mov	r4,r22
8112784c:	11226200 	call	81122620 <__srefill_r>
81127850:	1000f91e 	bne	r2,zero,81127c38 <__svfscanf_r+0x8f8>
81127854:	b9c00017 	ldw	r7,0(r23)
81127858:	003fdd06 	br	811277d0 <__reset+0xfb1077d0>
8112785c:	e0800117 	ldw	r2,4(fp)
81127860:	d9809d15 	stw	r6,628(sp)
81127864:	8c400054 	ori	r17,r17,1
81127868:	0080140e 	bge	zero,r2,811278bc <__svfscanf_r+0x57c>
8112786c:	00a044f4 	movhi	r2,33043
81127870:	10bd5404 	addi	r2,r2,-2736
81127874:	02000204 	movi	r8,8
81127878:	d880a115 	stw	r2,644(sp)
8112787c:	da009e15 	stw	r8,632(sp)
81127880:	050000c4 	movi	r20,3
81127884:	003fb406 	br	81127758 <__reset+0xfb107758>
81127888:	a0800043 	ldbu	r2,1(r20)
8112788c:	8c400094 	ori	r17,r17,2
81127890:	3029883a 	mov	r20,r6
81127894:	10c03fcc 	andi	r3,r2,255
81127898:	003ef406 	br	8112746c <__reset+0xfb10746c>
8112789c:	e0800117 	ldw	r2,4(fp)
811278a0:	d9809d15 	stw	r6,628(sp)
811278a4:	0081420e 	bge	zero,r2,81127db0 <__svfscanf_r+0xa70>
811278a8:	05000104 	movi	r20,4
811278ac:	003faa06 	br	81127758 <__reset+0xfb107758>
811278b0:	e0800117 	ldw	r2,4(fp)
811278b4:	d9809d15 	stw	r6,628(sp)
811278b8:	00bfec16 	blt	zero,r2,8112786c <__reset+0xfb10786c>
811278bc:	e00b883a 	mov	r5,fp
811278c0:	b009883a 	mov	r4,r22
811278c4:	11226200 	call	81122620 <__srefill_r>
811278c8:	1000db1e 	bne	r2,zero,81127c38 <__svfscanf_r+0x8f8>
811278cc:	b9c00017 	ldw	r7,0(r23)
811278d0:	003fe606 	br	8112786c <__reset+0xfb10786c>
811278d4:	d9809d15 	stw	r6,628(sp)
811278d8:	8880040c 	andi	r2,r17,16
811278dc:	10009c1e 	bne	r2,zero,81127b50 <__svfscanf_r+0x810>
811278e0:	8880010c 	andi	r2,r17,4
811278e4:	10011e26 	beq	r2,zero,81127d60 <__svfscanf_r+0xa20>
811278e8:	da009c17 	ldw	r8,624(sp)
811278ec:	3029883a 	mov	r20,r6
811278f0:	40800017 	ldw	r2,0(r8)
811278f4:	42000104 	addi	r8,r8,4
811278f8:	da009c15 	stw	r8,624(sp)
811278fc:	1480000d 	sth	r18,0(r2)
81127900:	003ecc06 	br	81127434 <__reset+0xfb107434>
81127904:	a0c00043 	ldbu	r3,1(r20)
81127908:	19410c26 	beq	r3,r5,81127d3c <__svfscanf_r+0x9fc>
8112790c:	8c400054 	ori	r17,r17,1
81127910:	3029883a 	mov	r20,r6
81127914:	003ed506 	br	8112746c <__reset+0xfb10746c>
81127918:	a0800043 	ldbu	r2,1(r20)
8112791c:	8c400114 	ori	r17,r17,4
81127920:	3029883a 	mov	r20,r6
81127924:	10c03fcc 	andi	r3,r2,255
81127928:	003ed006 	br	8112746c <__reset+0xfb10746c>
8112792c:	e0800117 	ldw	r2,4(fp)
81127930:	d9809d15 	stw	r6,628(sp)
81127934:	00bf790e 	bge	zero,r2,8112771c <__reset+0xfb10771c>
81127938:	00a044b4 	movhi	r2,33042
8112793c:	108b0904 	addi	r2,r2,11300
81127940:	02000284 	movi	r8,10
81127944:	d880a115 	stw	r2,644(sp)
81127948:	da009e15 	stw	r8,632(sp)
8112794c:	050000c4 	movi	r20,3
81127950:	003f8106 	br	81127758 <__reset+0xfb107758>
81127954:	e0800117 	ldw	r2,4(fp)
81127958:	d9809d15 	stw	r6,628(sp)
8112795c:	0080c40e 	bge	zero,r2,81127c70 <__svfscanf_r+0x930>
81127960:	9800011e 	bne	r19,zero,81127968 <__svfscanf_r+0x628>
81127964:	04c00044 	movi	r19,1
81127968:	8880004c 	andi	r2,r17,1
8112796c:	1000441e 	bne	r2,zero,81127a80 <__svfscanf_r+0x740>
81127970:	8c40040c 	andi	r17,r17,16
81127974:	8800da26 	beq	r17,zero,81127ce0 <__svfscanf_r+0x9a0>
81127978:	0021883a 	mov	r16,zero
8112797c:	00000806 	br	811279a0 <__svfscanf_r+0x660>
81127980:	1887883a 	add	r3,r3,r2
81127984:	e00b883a 	mov	r5,fp
81127988:	b009883a 	mov	r4,r22
8112798c:	e0c00015 	stw	r3,0(fp)
81127990:	80a1883a 	add	r16,r16,r2
81127994:	98a7c83a 	sub	r19,r19,r2
81127998:	11226200 	call	81122620 <__srefill_r>
8112799c:	1000ca1e 	bne	r2,zero,81127cc8 <__svfscanf_r+0x988>
811279a0:	e0800117 	ldw	r2,4(fp)
811279a4:	e0c00017 	ldw	r3,0(fp)
811279a8:	14fff516 	blt	r2,r19,81127980 <__reset+0xfb107980>
811279ac:	14c5c83a 	sub	r2,r2,r19
811279b0:	1cd5883a 	add	r10,r3,r19
811279b4:	84e1883a 	add	r16,r16,r19
811279b8:	e0800115 	stw	r2,4(fp)
811279bc:	e2800015 	stw	r10,0(fp)
811279c0:	dd009d17 	ldw	r20,628(sp)
811279c4:	9425883a 	add	r18,r18,r16
811279c8:	a00d883a 	mov	r6,r20
811279cc:	003e9a06 	br	81127438 <__reset+0xfb107438>
811279d0:	300b883a 	mov	r5,r6
811279d4:	d9005884 	addi	r4,sp,354
811279d8:	d9809d15 	stw	r6,628(sp)
811279dc:	112d9280 	call	8112d928 <__sccl>
811279e0:	1029883a 	mov	r20,r2
811279e4:	e0800117 	ldw	r2,4(fp)
811279e8:	0081050e 	bge	zero,r2,81127e00 <__svfscanf_r+0xac0>
811279ec:	e1000017 	ldw	r4,0(fp)
811279f0:	20800003 	ldbu	r2,0(r4)
811279f4:	98005926 	beq	r19,zero,81127b5c <__svfscanf_r+0x81c>
811279f8:	8c40040c 	andi	r17,r17,16
811279fc:	88005a26 	beq	r17,zero,81127b68 <__svfscanf_r+0x828>
81127a00:	9823883a 	mov	r17,r19
81127a04:	0021883a 	mov	r16,zero
81127a08:	00000106 	br	81127a10 <__svfscanf_r+0x6d0>
81127a0c:	20800003 	ldbu	r2,0(r4)
81127a10:	10803fcc 	andi	r2,r2,255
81127a14:	d8c05884 	addi	r3,sp,354
81127a18:	1885883a 	add	r2,r3,r2
81127a1c:	10800007 	ldb	r2,0(r2)
81127a20:	1000ad26 	beq	r2,zero,81127cd8 <__svfscanf_r+0x998>
81127a24:	e0800117 	ldw	r2,4(fp)
81127a28:	21000044 	addi	r4,r4,1
81127a2c:	84000044 	addi	r16,r16,1
81127a30:	10bfffc4 	addi	r2,r2,-1
81127a34:	e0800115 	stw	r2,4(fp)
81127a38:	e1000015 	stw	r4,0(fp)
81127a3c:	84c0a026 	beq	r16,r19,81127cc0 <__svfscanf_r+0x980>
81127a40:	00bff216 	blt	zero,r2,81127a0c <__reset+0xfb107a0c>
81127a44:	e00b883a 	mov	r5,fp
81127a48:	b009883a 	mov	r4,r22
81127a4c:	11226200 	call	81122620 <__srefill_r>
81127a50:	10009a1e 	bne	r2,zero,81127cbc <__svfscanf_r+0x97c>
81127a54:	e1000017 	ldw	r4,0(fp)
81127a58:	003fec06 	br	81127a0c <__reset+0xfb107a0c>
81127a5c:	e0800117 	ldw	r2,4(fp)
81127a60:	d9809d15 	stw	r6,628(sp)
81127a64:	0080eb0e 	bge	zero,r2,81127e14 <__svfscanf_r+0xad4>
81127a68:	00a044b4 	movhi	r2,33042
81127a6c:	108b0904 	addi	r2,r2,11300
81127a70:	d880a115 	stw	r2,644(sp)
81127a74:	d8009e15 	stw	zero,632(sp)
81127a78:	050000c4 	movi	r20,3
81127a7c:	003f3606 	br	81127758 <__reset+0xfb107758>
81127a80:	dd409904 	addi	r21,sp,612
81127a84:	8c40040c 	andi	r17,r17,16
81127a88:	01800204 	movi	r6,8
81127a8c:	000b883a 	mov	r5,zero
81127a90:	a809883a 	mov	r4,r21
81127a94:	dc409f15 	stw	r17,636(sp)
81127a98:	11221a40 	call	811221a4 <memset>
81127a9c:	dc409f17 	ldw	r17,636(sp)
81127aa0:	88006e26 	beq	r17,zero,81127c5c <__svfscanf_r+0x91c>
81127aa4:	0029883a 	mov	r20,zero
81127aa8:	0023883a 	mov	r17,zero
81127aac:	112bd440 	call	8112bd44 <__locale_mb_cur_max>
81127ab0:	14406126 	beq	r2,r17,81127c38 <__svfscanf_r+0x8f8>
81127ab4:	e0800017 	ldw	r2,0(fp)
81127ab8:	e0c00117 	ldw	r3,4(fp)
81127abc:	d9000104 	addi	r4,sp,4
81127ac0:	12000003 	ldbu	r8,0(r2)
81127ac4:	18ffffc4 	addi	r3,r3,-1
81127ac8:	10800044 	addi	r2,r2,1
81127acc:	e0c00115 	stw	r3,4(fp)
81127ad0:	e0800015 	stw	r2,0(fp)
81127ad4:	8c000044 	addi	r16,r17,1
81127ad8:	dd400015 	stw	r21,0(sp)
81127adc:	2463883a 	add	r17,r4,r17
81127ae0:	200d883a 	mov	r6,r4
81127ae4:	a00b883a 	mov	r5,r20
81127ae8:	800f883a 	mov	r7,r16
81127aec:	b009883a 	mov	r4,r22
81127af0:	8a000005 	stb	r8,0(r17)
81127af4:	112be000 	call	8112be00 <_mbrtowc_r>
81127af8:	017fffc4 	movi	r5,-1
81127afc:	11404e26 	beq	r2,r5,81127c38 <__svfscanf_r+0x8f8>
81127b00:	1000601e 	bne	r2,zero,81127c84 <__svfscanf_r+0x944>
81127b04:	da009f17 	ldw	r8,636(sp)
81127b08:	4000641e 	bne	r8,zero,81127c9c <__svfscanf_r+0x95c>
81127b0c:	a0000015 	stw	zero,0(r20)
81127b10:	9425883a 	add	r18,r18,r16
81127b14:	9967883a 	add	r19,r19,r5
81127b18:	a5000104 	addi	r20,r20,4
81127b1c:	e0800117 	ldw	r2,4(fp)
81127b20:	0023883a 	mov	r17,zero
81127b24:	00804b16 	blt	zero,r2,81127c54 <__svfscanf_r+0x914>
81127b28:	e00b883a 	mov	r5,fp
81127b2c:	b009883a 	mov	r4,r22
81127b30:	11226200 	call	81122620 <__srefill_r>
81127b34:	10004726 	beq	r2,zero,81127c54 <__svfscanf_r+0x914>
81127b38:	88003f1e 	bne	r17,zero,81127c38 <__svfscanf_r+0x8f8>
81127b3c:	d8c09f17 	ldw	r3,636(sp)
81127b40:	1800031e 	bne	r3,zero,81127b50 <__svfscanf_r+0x810>
81127b44:	da00a017 	ldw	r8,640(sp)
81127b48:	42000044 	addi	r8,r8,1
81127b4c:	da00a015 	stw	r8,640(sp)
81127b50:	dd009d17 	ldw	r20,628(sp)
81127b54:	a00d883a 	mov	r6,r20
81127b58:	003e3706 	br	81127438 <__reset+0xfb107438>
81127b5c:	8c40040c 	andi	r17,r17,16
81127b60:	04ffffc4 	movi	r19,-1
81127b64:	883fa61e 	bne	r17,zero,81127a00 <__reset+0xfb107a00>
81127b68:	da009c17 	ldw	r8,624(sp)
81127b6c:	9abfffc4 	addi	r10,r19,-1
81127b70:	44000017 	ldw	r16,0(r8)
81127b74:	44400104 	addi	r17,r8,4
81127b78:	8007883a 	mov	r3,r16
81127b7c:	82ab883a 	add	r21,r16,r10
81127b80:	00000306 	br	81127b90 <__svfscanf_r+0x850>
81127b84:	e1000017 	ldw	r4,0(fp)
81127b88:	9807883a 	mov	r3,r19
81127b8c:	20800003 	ldbu	r2,0(r4)
81127b90:	10803fcc 	andi	r2,r2,255
81127b94:	d9405884 	addi	r5,sp,354
81127b98:	2885883a 	add	r2,r5,r2
81127b9c:	10800007 	ldb	r2,0(r2)
81127ba0:	10004b26 	beq	r2,zero,81127cd0 <__svfscanf_r+0x990>
81127ba4:	e0800117 	ldw	r2,4(fp)
81127ba8:	21400044 	addi	r5,r4,1
81127bac:	e1400015 	stw	r5,0(fp)
81127bb0:	10bfffc4 	addi	r2,r2,-1
81127bb4:	e0800115 	stw	r2,4(fp)
81127bb8:	20800003 	ldbu	r2,0(r4)
81127bbc:	1cc00044 	addi	r19,r3,1
81127bc0:	18800005 	stb	r2,0(r3)
81127bc4:	1d400726 	beq	r3,r21,81127be4 <__svfscanf_r+0x8a4>
81127bc8:	e0800117 	ldw	r2,4(fp)
81127bcc:	00bfed16 	blt	zero,r2,81127b84 <__reset+0xfb107b84>
81127bd0:	e00b883a 	mov	r5,fp
81127bd4:	b009883a 	mov	r4,r22
81127bd8:	11226200 	call	81122620 <__srefill_r>
81127bdc:	103fe926 	beq	r2,zero,81127b84 <__reset+0xfb107b84>
81127be0:	84c01526 	beq	r16,r19,81127c38 <__svfscanf_r+0x8f8>
81127be4:	9c21c83a 	sub	r16,r19,r16
81127be8:	803e1726 	beq	r16,zero,81127448 <__reset+0xfb107448>
81127bec:	da00a017 	ldw	r8,640(sp)
81127bf0:	98000005 	stb	zero,0(r19)
81127bf4:	dc409c15 	stw	r17,624(sp)
81127bf8:	42000044 	addi	r8,r8,1
81127bfc:	da00a015 	stw	r8,640(sp)
81127c00:	9425883a 	add	r18,r18,r16
81127c04:	a00d883a 	mov	r6,r20
81127c08:	003e0b06 	br	81127438 <__reset+0xfb107438>
81127c0c:	017fff84 	movi	r5,-2
81127c10:	11439b1e 	bne	r2,r5,81128a80 <__svfscanf_r+0x1740>
81127c14:	8821883a 	mov	r16,r17
81127c18:	e0800117 	ldw	r2,4(fp)
81127c1c:	0082e516 	blt	zero,r2,811287b4 <__svfscanf_r+0x1474>
81127c20:	e00b883a 	mov	r5,fp
81127c24:	b009883a 	mov	r4,r22
81127c28:	11226200 	call	81122620 <__srefill_r>
81127c2c:	1002e126 	beq	r2,zero,811287b4 <__svfscanf_r+0x1474>
81127c30:	dc409f17 	ldw	r17,636(sp)
81127c34:	8002e826 	beq	r16,zero,811287d8 <__svfscanf_r+0x1498>
81127c38:	da00a017 	ldw	r8,640(sp)
81127c3c:	403e9c26 	beq	r8,zero,811276b0 <__reset+0xfb1076b0>
81127c40:	e080030b 	ldhu	r2,12(fp)
81127c44:	1080100c 	andi	r2,r2,64
81127c48:	103e991e 	bne	r2,zero,811276b0 <__reset+0xfb1076b0>
81127c4c:	4005883a 	mov	r2,r8
81127c50:	003e9806 	br	811276b4 <__reset+0xfb1076b4>
81127c54:	983f951e 	bne	r19,zero,81127aac <__reset+0xfb107aac>
81127c58:	003fb806 	br	81127b3c <__reset+0xfb107b3c>
81127c5c:	da009c17 	ldw	r8,624(sp)
81127c60:	45000017 	ldw	r20,0(r8)
81127c64:	42000104 	addi	r8,r8,4
81127c68:	da009c15 	stw	r8,624(sp)
81127c6c:	003f8e06 	br	81127aa8 <__reset+0xfb107aa8>
81127c70:	e00b883a 	mov	r5,fp
81127c74:	b009883a 	mov	r4,r22
81127c78:	11226200 	call	81122620 <__srefill_r>
81127c7c:	103f3826 	beq	r2,zero,81127960 <__reset+0xfb107960>
81127c80:	003fed06 	br	81127c38 <__reset+0xfb107c38>
81127c84:	00ffff84 	movi	r3,-2
81127c88:	10c0071e 	bne	r2,r3,81127ca8 <__svfscanf_r+0x968>
81127c8c:	e0800117 	ldw	r2,4(fp)
81127c90:	8023883a 	mov	r17,r16
81127c94:	00bf8516 	blt	zero,r2,81127aac <__reset+0xfb107aac>
81127c98:	003fa306 	br	81127b28 <__reset+0xfb107b28>
81127c9c:	9425883a 	add	r18,r18,r16
81127ca0:	9cffffc4 	addi	r19,r19,-1
81127ca4:	003f9d06 	br	81127b1c <__reset+0xfb107b1c>
81127ca8:	da009f17 	ldw	r8,636(sp)
81127cac:	9425883a 	add	r18,r18,r16
81127cb0:	9cffffc4 	addi	r19,r19,-1
81127cb4:	403f9826 	beq	r8,zero,81127b18 <__reset+0xfb107b18>
81127cb8:	003f9806 	br	81127b1c <__reset+0xfb107b1c>
81127cbc:	8023883a 	mov	r17,r16
81127cc0:	8821883a 	mov	r16,r17
81127cc4:	003fce06 	br	81127c00 <__reset+0xfb107c00>
81127cc8:	803f3d1e 	bne	r16,zero,811279c0 <__reset+0xfb1079c0>
81127ccc:	003fda06 	br	81127c38 <__reset+0xfb107c38>
81127cd0:	1827883a 	mov	r19,r3
81127cd4:	003fc306 	br	81127be4 <__reset+0xfb107be4>
81127cd8:	803fc91e 	bne	r16,zero,81127c00 <__reset+0xfb107c00>
81127cdc:	003dda06 	br	81127448 <__reset+0xfb107448>
81127ce0:	da009c17 	ldw	r8,624(sp)
81127ce4:	df000015 	stw	fp,0(sp)
81127ce8:	980f883a 	mov	r7,r19
81127cec:	41400017 	ldw	r5,0(r8)
81127cf0:	01800044 	movi	r6,1
81127cf4:	b009883a 	mov	r4,r22
81127cf8:	112af180 	call	8112af18 <_fread_r>
81127cfc:	da009c17 	ldw	r8,624(sp)
81127d00:	40c00104 	addi	r3,r8,4
81127d04:	103fcc26 	beq	r2,zero,81127c38 <__reset+0xfb107c38>
81127d08:	da00a017 	ldw	r8,640(sp)
81127d0c:	dd009d17 	ldw	r20,628(sp)
81127d10:	90a5883a 	add	r18,r18,r2
81127d14:	42000044 	addi	r8,r8,1
81127d18:	da00a015 	stw	r8,640(sp)
81127d1c:	d8c09c15 	stw	r3,624(sp)
81127d20:	a00d883a 	mov	r6,r20
81127d24:	003dc406 	br	81127438 <__reset+0xfb107438>
81127d28:	e00b883a 	mov	r5,fp
81127d2c:	b009883a 	mov	r4,r22
81127d30:	11226200 	call	81122620 <__srefill_r>
81127d34:	103e5226 	beq	r2,zero,81127680 <__reset+0xfb107680>
81127d38:	003fbf06 	br	81127c38 <__reset+0xfb107c38>
81127d3c:	a0800083 	ldbu	r2,2(r20)
81127d40:	8c400094 	ori	r17,r17,2
81127d44:	a5000084 	addi	r20,r20,2
81127d48:	10c03fcc 	andi	r3,r2,255
81127d4c:	003dc706 	br	8112746c <__reset+0xfb10746c>
81127d50:	e0800117 	ldw	r2,4(fp)
81127d54:	88e2b03a 	or	r17,r17,r3
81127d58:	00bef716 	blt	zero,r2,81127938 <__reset+0xfb107938>
81127d5c:	003e6f06 	br	8112771c <__reset+0xfb10771c>
81127d60:	8880004c 	andi	r2,r17,1
81127d64:	10000b1e 	bne	r2,zero,81127d94 <__svfscanf_r+0xa54>
81127d68:	8c40008c 	andi	r17,r17,2
81127d6c:	88000926 	beq	r17,zero,81127d94 <__svfscanf_r+0xa54>
81127d70:	da009c17 	ldw	r8,624(sp)
81127d74:	9007d7fa 	srai	r3,r18,31
81127d78:	dd009d17 	ldw	r20,628(sp)
81127d7c:	40800017 	ldw	r2,0(r8)
81127d80:	42000104 	addi	r8,r8,4
81127d84:	da009c15 	stw	r8,624(sp)
81127d88:	14800015 	stw	r18,0(r2)
81127d8c:	10c00115 	stw	r3,4(r2)
81127d90:	003da806 	br	81127434 <__reset+0xfb107434>
81127d94:	da009c17 	ldw	r8,624(sp)
81127d98:	dd009d17 	ldw	r20,628(sp)
81127d9c:	40800017 	ldw	r2,0(r8)
81127da0:	42000104 	addi	r8,r8,4
81127da4:	da009c15 	stw	r8,624(sp)
81127da8:	14800015 	stw	r18,0(r2)
81127dac:	003da106 	br	81127434 <__reset+0xfb107434>
81127db0:	e00b883a 	mov	r5,fp
81127db4:	b009883a 	mov	r4,r22
81127db8:	11226200 	call	81122620 <__srefill_r>
81127dbc:	103f9e1e 	bne	r2,zero,81127c38 <__reset+0xfb107c38>
81127dc0:	b9c00017 	ldw	r7,0(r23)
81127dc4:	05000104 	movi	r20,4
81127dc8:	003e6306 	br	81127758 <__reset+0xfb107758>
81127dcc:	e00b883a 	mov	r5,fp
81127dd0:	b009883a 	mov	r4,r22
81127dd4:	11226200 	call	81122620 <__srefill_r>
81127dd8:	103f971e 	bne	r2,zero,81127c38 <__reset+0xfb107c38>
81127ddc:	b9c00017 	ldw	r7,0(r23)
81127de0:	003e5706 	br	81127740 <__reset+0xfb107740>
81127de4:	e00b883a 	mov	r5,fp
81127de8:	b009883a 	mov	r4,r22
81127dec:	11226200 	call	81122620 <__srefill_r>
81127df0:	103f911e 	bne	r2,zero,81127c38 <__reset+0xfb107c38>
81127df4:	b9c00017 	ldw	r7,0(r23)
81127df8:	05000084 	movi	r20,2
81127dfc:	003e5606 	br	81127758 <__reset+0xfb107758>
81127e00:	e00b883a 	mov	r5,fp
81127e04:	b009883a 	mov	r4,r22
81127e08:	11226200 	call	81122620 <__srefill_r>
81127e0c:	103ef726 	beq	r2,zero,811279ec <__reset+0xfb1079ec>
81127e10:	003f8906 	br	81127c38 <__reset+0xfb107c38>
81127e14:	e00b883a 	mov	r5,fp
81127e18:	b009883a 	mov	r4,r22
81127e1c:	11226200 	call	81122620 <__srefill_r>
81127e20:	103f851e 	bne	r2,zero,81127c38 <__reset+0xfb107c38>
81127e24:	b9c00017 	ldw	r7,0(r23)
81127e28:	003f0f06 	br	81127a68 <__reset+0xfb107a68>
81127e2c:	014000c4 	movi	r5,3
81127e30:	a1414a26 	beq	r20,r5,8112835c <__svfscanf_r+0x101c>
81127e34:	01000104 	movi	r4,4
81127e38:	a101f11e 	bne	r20,r4,81128600 <__svfscanf_r+0x12c0>
81127e3c:	b009883a 	mov	r4,r22
81127e40:	112bd680 	call	8112bd68 <_localeconv_r>
81127e44:	10800017 	ldw	r2,0(r2)
81127e48:	98ffffc4 	addi	r3,r19,-1
81127e4c:	d880a315 	stw	r2,652(sp)
81127e50:	00805704 	movi	r2,348
81127e54:	10c21e2e 	bgeu	r2,r3,811286d0 <__svfscanf_r+0x1390>
81127e58:	9cffa8c4 	addi	r19,r19,-349
81127e5c:	dcc0a215 	stw	r19,648(sp)
81127e60:	04c05744 	movi	r19,349
81127e64:	8d01e014 	ori	r20,r17,1920
81127e68:	0023883a 	mov	r17,zero
81127e6c:	dc000104 	addi	r16,sp,4
81127e70:	8805883a 	mov	r2,r17
81127e74:	0019883a 	mov	r12,zero
81127e78:	8023883a 	mov	r17,r16
81127e7c:	b007883a 	mov	r3,r22
81127e80:	9821883a 	mov	r16,r19
81127e84:	002b883a 	mov	r21,zero
81127e88:	d800a515 	stw	zero,660(sp)
81127e8c:	d800a415 	stw	zero,656(sp)
81127e90:	d8009f15 	stw	zero,636(sp)
81127e94:	01c01384 	movi	r7,78
81127e98:	602d883a 	mov	r22,r12
81127e9c:	1027883a 	mov	r19,r2
81127ea0:	e1000017 	ldw	r4,0(fp)
81127ea4:	21400003 	ldbu	r5,0(r4)
81127ea8:	28bff544 	addi	r2,r5,-43
81127eac:	10803fcc 	andi	r2,r2,255
81127eb0:	38810e36 	bltu	r7,r2,811282ec <__svfscanf_r+0xfac>
81127eb4:	100490ba 	slli	r2,r2,2
81127eb8:	01a044b4 	movhi	r6,33042
81127ebc:	319fb304 	addi	r6,r6,32460
81127ec0:	1185883a 	add	r2,r2,r6
81127ec4:	10800017 	ldw	r2,0(r2)
81127ec8:	1000683a 	jmp	r2
81127ecc:	811281c4 	addi	r4,r16,18951
81127ed0:	811282ec 	andhi	r4,r16,18955
81127ed4:	811281c4 	addi	r4,r16,18951
81127ed8:	811282ec 	andhi	r4,r16,18955
81127edc:	811282ec 	andhi	r4,r16,18955
81127ee0:	81128198 	cmpnei	r4,r16,18950
81127ee4:	81128008 	cmpgei	r4,r16,18944
81127ee8:	81128008 	cmpgei	r4,r16,18944
81127eec:	81128008 	cmpgei	r4,r16,18944
81127ef0:	81128008 	cmpgei	r4,r16,18944
81127ef4:	81128008 	cmpgei	r4,r16,18944
81127ef8:	81128008 	cmpgei	r4,r16,18944
81127efc:	81128008 	cmpgei	r4,r16,18944
81127f00:	81128008 	cmpgei	r4,r16,18944
81127f04:	81128008 	cmpgei	r4,r16,18944
81127f08:	811282ec 	andhi	r4,r16,18955
81127f0c:	811282ec 	andhi	r4,r16,18955
81127f10:	811282ec 	andhi	r4,r16,18955
81127f14:	811282ec 	andhi	r4,r16,18955
81127f18:	811282ec 	andhi	r4,r16,18955
81127f1c:	811282ec 	andhi	r4,r16,18955
81127f20:	811282ec 	andhi	r4,r16,18955
81127f24:	811282dc 	xori	r4,r16,18955
81127f28:	811282ec 	andhi	r4,r16,18955
81127f2c:	811282ec 	andhi	r4,r16,18955
81127f30:	811282ec 	andhi	r4,r16,18955
81127f34:	81128298 	cmpnei	r4,r16,18954
81127f38:	8112827c 	xorhi	r4,r16,18953
81127f3c:	811282ec 	andhi	r4,r16,18955
81127f40:	811282ec 	andhi	r4,r16,18955
81127f44:	81128248 	cmpgei	r4,r16,18953
81127f48:	811282ec 	andhi	r4,r16,18955
81127f4c:	811282ec 	andhi	r4,r16,18955
81127f50:	811282ec 	andhi	r4,r16,18955
81127f54:	811282ec 	andhi	r4,r16,18955
81127f58:	81128210 	cmplti	r4,r16,18952
81127f5c:	811282ec 	andhi	r4,r16,18955
81127f60:	811282ec 	andhi	r4,r16,18955
81127f64:	811282ec 	andhi	r4,r16,18955
81127f68:	811282ec 	andhi	r4,r16,18955
81127f6c:	811282ec 	andhi	r4,r16,18955
81127f70:	811281f4 	orhi	r4,r16,18951
81127f74:	811282ec 	andhi	r4,r16,18955
81127f78:	811282ec 	andhi	r4,r16,18955
81127f7c:	811282ec 	andhi	r4,r16,18955
81127f80:	811282ec 	andhi	r4,r16,18955
81127f84:	811281d8 	cmpnei	r4,r16,18951
81127f88:	811282ec 	andhi	r4,r16,18955
81127f8c:	811282ec 	andhi	r4,r16,18955
81127f90:	811282ec 	andhi	r4,r16,18955
81127f94:	811282ec 	andhi	r4,r16,18955
81127f98:	811282ec 	andhi	r4,r16,18955
81127f9c:	811282ec 	andhi	r4,r16,18955
81127fa0:	811282ec 	andhi	r4,r16,18955
81127fa4:	811282dc 	xori	r4,r16,18955
81127fa8:	811282ec 	andhi	r4,r16,18955
81127fac:	811282ec 	andhi	r4,r16,18955
81127fb0:	811282ec 	andhi	r4,r16,18955
81127fb4:	81128298 	cmpnei	r4,r16,18954
81127fb8:	8112827c 	xorhi	r4,r16,18953
81127fbc:	811282ec 	andhi	r4,r16,18955
81127fc0:	811282ec 	andhi	r4,r16,18955
81127fc4:	81128248 	cmpgei	r4,r16,18953
81127fc8:	811282ec 	andhi	r4,r16,18955
81127fcc:	811282ec 	andhi	r4,r16,18955
81127fd0:	811282ec 	andhi	r4,r16,18955
81127fd4:	811282ec 	andhi	r4,r16,18955
81127fd8:	81128210 	cmplti	r4,r16,18952
81127fdc:	811282ec 	andhi	r4,r16,18955
81127fe0:	811282ec 	andhi	r4,r16,18955
81127fe4:	811282ec 	andhi	r4,r16,18955
81127fe8:	811282ec 	andhi	r4,r16,18955
81127fec:	811282ec 	andhi	r4,r16,18955
81127ff0:	811281f4 	orhi	r4,r16,18951
81127ff4:	811282ec 	andhi	r4,r16,18955
81127ff8:	811282ec 	andhi	r4,r16,18955
81127ffc:	811282ec 	andhi	r4,r16,18955
81128000:	811282ec 	andhi	r4,r16,18955
81128004:	811281d8 	cmpnei	r4,r16,18951
81128008:	a8803fcc 	andi	r2,r21,255
8112800c:	1080201c 	xori	r2,r2,128
81128010:	10bfe004 	addi	r2,r2,-128
81128014:	b085883a 	add	r2,r22,r2
81128018:	10000d1e 	bne	r2,zero,81128050 <__svfscanf_r+0xd10>
8112801c:	00bf9fc4 	movi	r2,-385
81128020:	a0a8703a 	and	r20,r20,r2
81128024:	89400005 	stb	r5,0(r17)
81128028:	8c400044 	addi	r17,r17,1
8112802c:	e0800117 	ldw	r2,4(fp)
81128030:	843fffc4 	addi	r16,r16,-1
81128034:	94800044 	addi	r18,r18,1
81128038:	10bfffc4 	addi	r2,r2,-1
8112803c:	e0800115 	stw	r2,4(fp)
81128040:	0080b40e 	bge	zero,r2,81128314 <__svfscanf_r+0xfd4>
81128044:	21000044 	addi	r4,r4,1
81128048:	e1000015 	stw	r4,0(fp)
8112804c:	803f941e 	bne	r16,zero,81127ea0 <__reset+0xfb107ea0>
81128050:	8821883a 	mov	r16,r17
81128054:	b019883a 	mov	r12,r22
81128058:	9823883a 	mov	r17,r19
8112805c:	182d883a 	mov	r22,r3
81128060:	9801961e 	bne	r19,zero,811286bc <__svfscanf_r+0x137c>
81128064:	633fffc4 	addi	r12,r12,-1
81128068:	00800044 	movi	r2,1
8112806c:	1302882e 	bgeu	r2,r12,81128a90 <__svfscanf_r+0x1750>
81128070:	a8803fcc 	andi	r2,r21,255
81128074:	1080201c 	xori	r2,r2,128
81128078:	10bfe004 	addi	r2,r2,-128
8112807c:	113fffc4 	addi	r4,r2,-1
81128080:	01400184 	movi	r5,6
81128084:	29001136 	bltu	r5,r4,811280cc <__svfscanf_r+0xd8c>
81128088:	01000084 	movi	r4,2
8112808c:	2082900e 	bge	r4,r2,81128ad0 <__svfscanf_r+0x1790>
81128090:	00c000c4 	movi	r3,3
81128094:	10c00d26 	beq	r2,r3,811280cc <__svfscanf_r+0xd8c>
81128098:	9425c83a 	sub	r18,r18,r16
8112809c:	1827883a 	mov	r19,r3
811280a0:	843fffc4 	addi	r16,r16,-1
811280a4:	81400007 	ldb	r5,0(r16)
811280a8:	e00d883a 	mov	r6,fp
811280ac:	b009883a 	mov	r4,r22
811280b0:	1130f980 	call	81130f98 <_ungetc_r>
811280b4:	a8bfffc4 	addi	r2,r21,-1
811280b8:	10c03fcc 	andi	r3,r2,255
811280bc:	8493883a 	add	r9,r16,r18
811280c0:	102b883a 	mov	r21,r2
811280c4:	98fff636 	bltu	r19,r3,811280a0 <__reset+0xfb1080a0>
811280c8:	4825883a 	mov	r18,r9
811280cc:	a080400c 	andi	r2,r20,256
811280d0:	10001426 	beq	r2,zero,81128124 <__svfscanf_r+0xde4>
811280d4:	a081000c 	andi	r2,r20,1024
811280d8:	1002571e 	bne	r2,zero,81128a38 <__svfscanf_r+0x16f8>
811280dc:	817fffc7 	ldb	r5,-1(r16)
811280e0:	00801944 	movi	r2,101
811280e4:	84ffffc4 	addi	r19,r16,-1
811280e8:	957fffc4 	addi	r21,r18,-1
811280ec:	28800826 	beq	r5,r2,81128110 <__svfscanf_r+0xdd0>
811280f0:	00801144 	movi	r2,69
811280f4:	28800626 	beq	r5,r2,81128110 <__svfscanf_r+0xdd0>
811280f8:	e00d883a 	mov	r6,fp
811280fc:	b009883a 	mov	r4,r22
81128100:	1130f980 	call	81130f98 <_ungetc_r>
81128104:	817fff87 	ldb	r5,-2(r16)
81128108:	84ffff84 	addi	r19,r16,-2
8112810c:	957fff84 	addi	r21,r18,-2
81128110:	e00d883a 	mov	r6,fp
81128114:	b009883a 	mov	r4,r22
81128118:	1130f980 	call	81130f98 <_ungetc_r>
8112811c:	a825883a 	mov	r18,r21
81128120:	9821883a 	mov	r16,r19
81128124:	a080040c 	andi	r2,r20,16
81128128:	103e891e 	bne	r2,zero,81127b50 <__reset+0xfb107b50>
8112812c:	80000005 	stb	zero,0(r16)
81128130:	a081800c 	andi	r2,r20,1536
81128134:	01010004 	movi	r4,1024
81128138:	1101dd26 	beq	r2,r4,811288b0 <__svfscanf_r+0x1570>
8112813c:	da00a417 	ldw	r8,656(sp)
81128140:	4001e71e 	bne	r8,zero,811288e0 <__svfscanf_r+0x15a0>
81128144:	000d883a 	mov	r6,zero
81128148:	d9400104 	addi	r5,sp,4
8112814c:	b009883a 	mov	r4,r22
81128150:	112db480 	call	8112db48 <_strtod_r>
81128154:	1021883a 	mov	r16,r2
81128158:	a080004c 	andi	r2,r20,1
8112815c:	1000021e 	bne	r2,zero,81128168 <__svfscanf_r+0xe28>
81128160:	a2c0008c 	andi	r11,r20,2
81128164:	5801e826 	beq	r11,zero,81128908 <__svfscanf_r+0x15c8>
81128168:	da009c17 	ldw	r8,624(sp)
8112816c:	40800017 	ldw	r2,0(r8)
81128170:	42000104 	addi	r8,r8,4
81128174:	da009c15 	stw	r8,624(sp)
81128178:	14000015 	stw	r16,0(r2)
8112817c:	10c00115 	stw	r3,4(r2)
81128180:	da00a017 	ldw	r8,640(sp)
81128184:	dd009d17 	ldw	r20,628(sp)
81128188:	42000044 	addi	r8,r8,1
8112818c:	da00a015 	stw	r8,640(sp)
81128190:	a00d883a 	mov	r6,r20
81128194:	003ca806 	br	81127438 <__reset+0xfb107438>
81128198:	a080400c 	andi	r2,r20,256
8112819c:	103f9a26 	beq	r2,zero,81128008 <__reset+0xfb108008>
811281a0:	da00a217 	ldw	r8,648(sp)
811281a4:	00bfdfc4 	movi	r2,-129
811281a8:	a0a8703a 	and	r20,r20,r2
811281ac:	9cc00044 	addi	r19,r19,1
811281b0:	403f9e26 	beq	r8,zero,8112802c <__reset+0xfb10802c>
811281b4:	423fffc4 	addi	r8,r8,-1
811281b8:	da00a215 	stw	r8,648(sp)
811281bc:	84000044 	addi	r16,r16,1
811281c0:	003f9a06 	br	8112802c <__reset+0xfb10802c>
811281c4:	a080200c 	andi	r2,r20,128
811281c8:	103fa126 	beq	r2,zero,81128050 <__reset+0xfb108050>
811281cc:	00bfdfc4 	movi	r2,-129
811281d0:	a0a8703a 	and	r20,r20,r2
811281d4:	003f9306 	br	81128024 <__reset+0xfb108024>
811281d8:	a8803fcc 	andi	r2,r21,255
811281dc:	1080201c 	xori	r2,r2,128
811281e0:	10bfe004 	addi	r2,r2,-128
811281e4:	020001c4 	movi	r8,7
811281e8:	123f991e 	bne	r2,r8,81128050 <__reset+0xfb108050>
811281ec:	05400204 	movi	r21,8
811281f0:	003f8c06 	br	81128024 <__reset+0xfb108024>
811281f4:	a8803fcc 	andi	r2,r21,255
811281f8:	1080201c 	xori	r2,r2,128
811281fc:	10bfe004 	addi	r2,r2,-128
81128200:	01800184 	movi	r6,6
81128204:	11bf921e 	bne	r2,r6,81128050 <__reset+0xfb108050>
81128208:	054001c4 	movi	r21,7
8112820c:	003f8506 	br	81128024 <__reset+0xfb108024>
81128210:	b000491e 	bne	r22,zero,81128338 <__svfscanf_r+0xff8>
81128214:	9800031e 	bne	r19,zero,81128224 <__svfscanf_r+0xee4>
81128218:	a081c00c 	andi	r2,r20,1792
8112821c:	0181c004 	movi	r6,1792
81128220:	11819f26 	beq	r2,r6,811288a0 <__svfscanf_r+0x1560>
81128224:	a8803fcc 	andi	r2,r21,255
81128228:	1080201c 	xori	r2,r2,128
8112822c:	10bfe004 	addi	r2,r2,-128
81128230:	01800044 	movi	r6,1
81128234:	11800226 	beq	r2,r6,81128240 <__svfscanf_r+0xf00>
81128238:	01800104 	movi	r6,4
8112823c:	11bf841e 	bne	r2,r6,81128050 <__reset+0xfb108050>
81128240:	ad400044 	addi	r21,r21,1
81128244:	003f7706 	br	81128024 <__reset+0xfb108024>
81128248:	a8803fcc 	andi	r2,r21,255
8112824c:	1080201c 	xori	r2,r2,128
81128250:	10bfe004 	addi	r2,r2,-128
81128254:	10003c1e 	bne	r2,zero,81128348 <__svfscanf_r+0x1008>
81128258:	9801141e 	bne	r19,zero,811286ac <__svfscanf_r+0x136c>
8112825c:	a081c00c 	andi	r2,r20,1792
81128260:	0181c004 	movi	r6,1792
81128264:	11818226 	beq	r2,r6,81128870 <__svfscanf_r+0x1530>
81128268:	8821883a 	mov	r16,r17
8112826c:	b019883a 	mov	r12,r22
81128270:	9823883a 	mov	r17,r19
81128274:	182d883a 	mov	r22,r3
81128278:	003f7a06 	br	81128064 <__reset+0xfb108064>
8112827c:	a8803fcc 	andi	r2,r21,255
81128280:	1080201c 	xori	r2,r2,128
81128284:	10bfe004 	addi	r2,r2,-128
81128288:	01800084 	movi	r6,2
8112828c:	11bf701e 	bne	r2,r6,81128050 <__reset+0xfb108050>
81128290:	054000c4 	movi	r21,3
81128294:	003f6306 	br	81128024 <__reset+0xfb108024>
81128298:	a081400c 	andi	r2,r20,1280
8112829c:	01810004 	movi	r6,1024
811282a0:	11800326 	beq	r2,r6,811282b0 <__svfscanf_r+0xf70>
811282a4:	a184703a 	and	r2,r20,r6
811282a8:	103f6926 	beq	r2,zero,81128050 <__reset+0xfb108050>
811282ac:	983fee26 	beq	r19,zero,81128268 <__reset+0xfb108268>
811282b0:	a080800c 	andi	r2,r20,512
811282b4:	1000041e 	bne	r2,zero,811282c8 <__svfscanf_r+0xf88>
811282b8:	da009f17 	ldw	r8,636(sp)
811282bc:	dc40a515 	stw	r17,660(sp)
811282c0:	9a27c83a 	sub	r19,r19,r8
811282c4:	dcc0a415 	stw	r19,656(sp)
811282c8:	00be1fc4 	movi	r2,-1921
811282cc:	a0a8703a 	and	r20,r20,r2
811282d0:	a5006014 	ori	r20,r20,384
811282d4:	0027883a 	mov	r19,zero
811282d8:	003f5206 	br	81128024 <__reset+0xfb108024>
811282dc:	00800044 	movi	r2,1
811282e0:	b0bf5b1e 	bne	r22,r2,81128050 <__reset+0xfb108050>
811282e4:	05800084 	movi	r22,2
811282e8:	003f4e06 	br	81128024 <__reset+0xfb108024>
811282ec:	d980a317 	ldw	r6,652(sp)
811282f0:	30800003 	ldbu	r2,0(r6)
811282f4:	29803fcc 	andi	r6,r5,255
811282f8:	30bf551e 	bne	r6,r2,81128050 <__reset+0xfb108050>
811282fc:	a080800c 	andi	r2,r20,512
81128300:	103f5326 	beq	r2,zero,81128050 <__reset+0xfb108050>
81128304:	023f5fc4 	movi	r8,-641
81128308:	a228703a 	and	r20,r20,r8
8112830c:	dcc09f15 	stw	r19,636(sp)
81128310:	003f4406 	br	81128024 <__reset+0xfb108024>
81128314:	1809883a 	mov	r4,r3
81128318:	e00b883a 	mov	r5,fp
8112831c:	d8c0a615 	stw	r3,664(sp)
81128320:	d9c0aa15 	stw	r7,680(sp)
81128324:	11226200 	call	81122620 <__srefill_r>
81128328:	d8c0a617 	ldw	r3,664(sp)
8112832c:	d9c0aa17 	ldw	r7,680(sp)
81128330:	103f4626 	beq	r2,zero,8112804c <__reset+0xfb10804c>
81128334:	003f4606 	br	81128050 <__reset+0xfb108050>
81128338:	00800084 	movi	r2,2
8112833c:	b0bfb91e 	bne	r22,r2,81128224 <__reset+0xfb108224>
81128340:	058000c4 	movi	r22,3
81128344:	003f3706 	br	81128024 <__reset+0xfb108024>
81128348:	018000c4 	movi	r6,3
8112834c:	11bfbc26 	beq	r2,r6,81128240 <__reset+0xfb108240>
81128350:	01800144 	movi	r6,5
81128354:	11bfba26 	beq	r2,r6,81128240 <__reset+0xfb108240>
81128358:	003f3d06 	br	81128050 <__reset+0xfb108050>
8112835c:	98bfffc4 	addi	r2,r19,-1
81128360:	01405704 	movi	r5,348
81128364:	2880d82e 	bgeu	r5,r2,811286c8 <__svfscanf_r+0x1388>
81128368:	99ffa8c4 	addi	r7,r19,-349
8112836c:	04c05744 	movi	r19,349
81128370:	8c436014 	ori	r17,r17,3456
81128374:	9013883a 	mov	r9,r18
81128378:	8825883a 	mov	r18,r17
8112837c:	dc409e17 	ldw	r17,632(sp)
81128380:	0029883a 	mov	r20,zero
81128384:	dc000104 	addi	r16,sp,4
81128388:	05401344 	movi	r21,77
8112838c:	02c08004 	movi	r11,512
81128390:	01bf7fc4 	movi	r6,-513
81128394:	023fdfc4 	movi	r8,-129
81128398:	20bff544 	addi	r2,r4,-43
8112839c:	10803fcc 	andi	r2,r2,255
811283a0:	a8807236 	bltu	r21,r2,8112856c <__svfscanf_r+0x122c>
811283a4:	100490ba 	slli	r2,r2,2
811283a8:	016044f4 	movhi	r5,33043
811283ac:	2960ef04 	addi	r5,r5,-31812
811283b0:	1145883a 	add	r2,r2,r5
811283b4:	10800017 	ldw	r2,0(r2)
811283b8:	1000683a 	jmp	r2
811283bc:	811285f0 	cmpltui	r4,r16,18967
811283c0:	8112856c 	andhi	r4,r16,18965
811283c4:	811285f0 	cmpltui	r4,r16,18967
811283c8:	8112856c 	andhi	r4,r16,18965
811283cc:	8112856c 	andhi	r4,r16,18965
811283d0:	811285c8 	cmpgei	r4,r16,18967
811283d4:	811285a8 	cmpgeui	r4,r16,18966
811283d8:	811285a8 	cmpgeui	r4,r16,18966
811283dc:	811285a8 	cmpgeui	r4,r16,18966
811283e0:	811285a8 	cmpgeui	r4,r16,18966
811283e4:	811285a8 	cmpgeui	r4,r16,18966
811283e8:	811285a8 	cmpgeui	r4,r16,18966
811283ec:	811285a8 	cmpgeui	r4,r16,18966
811283f0:	81128550 	cmplti	r4,r16,18965
811283f4:	81128550 	cmplti	r4,r16,18965
811283f8:	8112856c 	andhi	r4,r16,18965
811283fc:	8112856c 	andhi	r4,r16,18965
81128400:	8112856c 	andhi	r4,r16,18965
81128404:	8112856c 	andhi	r4,r16,18965
81128408:	8112856c 	andhi	r4,r16,18965
8112840c:	8112856c 	andhi	r4,r16,18965
81128410:	8112856c 	andhi	r4,r16,18965
81128414:	8112853c 	xorhi	r4,r16,18964
81128418:	8112853c 	xorhi	r4,r16,18964
8112841c:	8112853c 	xorhi	r4,r16,18964
81128420:	8112853c 	xorhi	r4,r16,18964
81128424:	8112853c 	xorhi	r4,r16,18964
81128428:	8112853c 	xorhi	r4,r16,18964
8112842c:	8112856c 	andhi	r4,r16,18965
81128430:	8112856c 	andhi	r4,r16,18965
81128434:	8112856c 	andhi	r4,r16,18965
81128438:	8112856c 	andhi	r4,r16,18965
8112843c:	8112856c 	andhi	r4,r16,18965
81128440:	8112856c 	andhi	r4,r16,18965
81128444:	8112856c 	andhi	r4,r16,18965
81128448:	8112856c 	andhi	r4,r16,18965
8112844c:	8112856c 	andhi	r4,r16,18965
81128450:	8112856c 	andhi	r4,r16,18965
81128454:	8112856c 	andhi	r4,r16,18965
81128458:	8112856c 	andhi	r4,r16,18965
8112845c:	8112856c 	andhi	r4,r16,18965
81128460:	8112856c 	andhi	r4,r16,18965
81128464:	8112856c 	andhi	r4,r16,18965
81128468:	8112856c 	andhi	r4,r16,18965
8112846c:	8112856c 	andhi	r4,r16,18965
81128470:	811284f4 	orhi	r4,r16,18963
81128474:	8112856c 	andhi	r4,r16,18965
81128478:	8112856c 	andhi	r4,r16,18965
8112847c:	8112856c 	andhi	r4,r16,18965
81128480:	8112856c 	andhi	r4,r16,18965
81128484:	8112856c 	andhi	r4,r16,18965
81128488:	8112856c 	andhi	r4,r16,18965
8112848c:	8112856c 	andhi	r4,r16,18965
81128490:	8112856c 	andhi	r4,r16,18965
81128494:	8112853c 	xorhi	r4,r16,18964
81128498:	8112853c 	xorhi	r4,r16,18964
8112849c:	8112853c 	xorhi	r4,r16,18964
811284a0:	8112853c 	xorhi	r4,r16,18964
811284a4:	8112853c 	xorhi	r4,r16,18964
811284a8:	8112853c 	xorhi	r4,r16,18964
811284ac:	8112856c 	andhi	r4,r16,18965
811284b0:	8112856c 	andhi	r4,r16,18965
811284b4:	8112856c 	andhi	r4,r16,18965
811284b8:	8112856c 	andhi	r4,r16,18965
811284bc:	8112856c 	andhi	r4,r16,18965
811284c0:	8112856c 	andhi	r4,r16,18965
811284c4:	8112856c 	andhi	r4,r16,18965
811284c8:	8112856c 	andhi	r4,r16,18965
811284cc:	8112856c 	andhi	r4,r16,18965
811284d0:	8112856c 	andhi	r4,r16,18965
811284d4:	8112856c 	andhi	r4,r16,18965
811284d8:	8112856c 	andhi	r4,r16,18965
811284dc:	8112856c 	andhi	r4,r16,18965
811284e0:	8112856c 	andhi	r4,r16,18965
811284e4:	8112856c 	andhi	r4,r16,18965
811284e8:	8112856c 	andhi	r4,r16,18965
811284ec:	8112856c 	andhi	r4,r16,18965
811284f0:	811284f4 	orhi	r4,r16,18963
811284f4:	9081800c 	andi	r2,r18,1536
811284f8:	12c01c1e 	bne	r2,r11,8112856c <__svfscanf_r+0x122c>
811284fc:	91a4703a 	and	r18,r18,r6
81128500:	94814014 	ori	r18,r18,1280
81128504:	04400404 	movi	r17,16
81128508:	81000005 	stb	r4,0(r16)
8112850c:	84000044 	addi	r16,r16,1
81128510:	e0800117 	ldw	r2,4(fp)
81128514:	10bfffc4 	addi	r2,r2,-1
81128518:	e0800115 	stw	r2,4(fp)
8112851c:	0080540e 	bge	zero,r2,81128670 <__svfscanf_r+0x1330>
81128520:	18c00044 	addi	r3,r3,1
81128524:	e0c00015 	stw	r3,0(fp)
81128528:	9cffffc4 	addi	r19,r19,-1
8112852c:	98000f26 	beq	r19,zero,8112856c <__svfscanf_r+0x122c>
81128530:	e0c00017 	ldw	r3,0(fp)
81128534:	19000003 	ldbu	r4,0(r3)
81128538:	003f9706 	br	81128398 <__reset+0xfb108398>
8112853c:	00800284 	movi	r2,10
81128540:	14400a0e 	bge	r2,r17,8112856c <__svfscanf_r+0x122c>
81128544:	00bd1fc4 	movi	r2,-2945
81128548:	90a4703a 	and	r18,r18,r2
8112854c:	003fee06 	br	81128508 <__reset+0xfb108508>
81128550:	01604574 	movhi	r5,33045
81128554:	8c63883a 	add	r17,r17,r17
81128558:	29412284 	addi	r5,r5,1162
8112855c:	2c45883a 	add	r2,r5,r17
81128560:	1440000f 	ldh	r17,0(r2)
81128564:	00800204 	movi	r2,8
81128568:	147ff616 	blt	r2,r17,81128544 <__reset+0xfb108544>
8112856c:	dc409e15 	stw	r17,632(sp)
81128570:	9023883a 	mov	r17,r18
81128574:	8880400c 	andi	r2,r17,256
81128578:	4825883a 	mov	r18,r9
8112857c:	10000426 	beq	r2,zero,81128590 <__svfscanf_r+0x1250>
81128580:	d9800104 	addi	r6,sp,4
81128584:	3400be36 	bltu	r6,r16,81128880 <__svfscanf_r+0x1540>
81128588:	da000104 	addi	r8,sp,4
8112858c:	443bae26 	beq	r8,r16,81127448 <__reset+0xfb107448>
81128590:	8880040c 	andi	r2,r17,16
81128594:	10009326 	beq	r2,zero,811287e4 <__svfscanf_r+0x14a4>
81128598:	d8800104 	addi	r2,sp,4
8112859c:	80a1c83a 	sub	r16,r16,r2
811285a0:	8521883a 	add	r16,r16,r20
811285a4:	003d0606 	br	811279c0 <__reset+0xfb1079c0>
811285a8:	01604574 	movhi	r5,33045
811285ac:	8c63883a 	add	r17,r17,r17
811285b0:	29412284 	addi	r5,r5,1162
811285b4:	2c45883a 	add	r2,r5,r17
811285b8:	1440000f 	ldh	r17,0(r2)
811285bc:	00bd1fc4 	movi	r2,-2945
811285c0:	90a4703a 	and	r18,r18,r2
811285c4:	003fd006 	br	81128508 <__reset+0xfb108508>
811285c8:	9082000c 	andi	r2,r18,2048
811285cc:	103fce26 	beq	r2,zero,81128508 <__reset+0xfb108508>
811285d0:	8800021e 	bne	r17,zero,811285dc <__svfscanf_r+0x129c>
811285d4:	94808014 	ori	r18,r18,512
811285d8:	04400204 	movi	r17,8
811285dc:	9081000c 	andi	r2,r18,1024
811285e0:	10009426 	beq	r2,zero,81128834 <__svfscanf_r+0x14f4>
811285e4:	00be9fc4 	movi	r2,-1409
811285e8:	90a4703a 	and	r18,r18,r2
811285ec:	003fc606 	br	81128508 <__reset+0xfb108508>
811285f0:	9080200c 	andi	r2,r18,128
811285f4:	103fdd26 	beq	r2,zero,8112856c <__reset+0xfb10856c>
811285f8:	9224703a 	and	r18,r18,r8
811285fc:	003fc206 	br	81128508 <__reset+0xfb108508>
81128600:	9800011e 	bne	r19,zero,81128608 <__svfscanf_r+0x12c8>
81128604:	04ffffc4 	movi	r19,-1
81128608:	8900004c 	andi	r4,r17,1
8112860c:	20005b1e 	bne	r4,zero,8112877c <__svfscanf_r+0x143c>
81128610:	8c40040c 	andi	r17,r17,16
81128614:	88003026 	beq	r17,zero,811286d8 <__svfscanf_r+0x1398>
81128618:	0021883a 	mov	r16,zero
8112861c:	00000306 	br	8112862c <__svfscanf_r+0x12ec>
81128620:	18800003 	ldbu	r2,0(r3)
81128624:	3885883a 	add	r2,r7,r2
81128628:	10800043 	ldbu	r2,1(r2)
8112862c:	1080020c 	andi	r2,r2,8
81128630:	103ce31e 	bne	r2,zero,811279c0 <__reset+0xfb1079c0>
81128634:	e0800117 	ldw	r2,4(fp)
81128638:	18c00044 	addi	r3,r3,1
8112863c:	84000044 	addi	r16,r16,1
81128640:	10bfffc4 	addi	r2,r2,-1
81128644:	e0800115 	stw	r2,4(fp)
81128648:	e0c00015 	stw	r3,0(fp)
8112864c:	84fcdc26 	beq	r16,r19,811279c0 <__reset+0xfb1079c0>
81128650:	00bff316 	blt	zero,r2,81128620 <__reset+0xfb108620>
81128654:	e00b883a 	mov	r5,fp
81128658:	b009883a 	mov	r4,r22
8112865c:	11226200 	call	81122620 <__srefill_r>
81128660:	103cd71e 	bne	r2,zero,811279c0 <__reset+0xfb1079c0>
81128664:	b9c00017 	ldw	r7,0(r23)
81128668:	e0c00017 	ldw	r3,0(fp)
8112866c:	003fec06 	br	81128620 <__reset+0xfb108620>
81128670:	e00b883a 	mov	r5,fp
81128674:	b009883a 	mov	r4,r22
81128678:	d980a715 	stw	r6,668(sp)
8112867c:	d9c0aa15 	stw	r7,680(sp)
81128680:	da00a815 	stw	r8,672(sp)
81128684:	da40a915 	stw	r9,676(sp)
81128688:	dac0a615 	stw	r11,664(sp)
8112868c:	11226200 	call	81122620 <__srefill_r>
81128690:	d980a717 	ldw	r6,668(sp)
81128694:	d9c0aa17 	ldw	r7,680(sp)
81128698:	da00a817 	ldw	r8,672(sp)
8112869c:	da40a917 	ldw	r9,676(sp)
811286a0:	dac0a617 	ldw	r11,664(sp)
811286a4:	103fa026 	beq	r2,zero,81128528 <__reset+0xfb108528>
811286a8:	003fb006 	br	8112856c <__reset+0xfb10856c>
811286ac:	8821883a 	mov	r16,r17
811286b0:	b019883a 	mov	r12,r22
811286b4:	9823883a 	mov	r17,r19
811286b8:	182d883a 	mov	r22,r3
811286bc:	00bfbfc4 	movi	r2,-257
811286c0:	a0a8703a 	and	r20,r20,r2
811286c4:	003e6706 	br	81128064 <__reset+0xfb108064>
811286c8:	000f883a 	mov	r7,zero
811286cc:	003f2806 	br	81128370 <__reset+0xfb108370>
811286d0:	d800a215 	stw	zero,648(sp)
811286d4:	003de306 	br	81127e64 <__reset+0xfb107e64>
811286d8:	da009c17 	ldw	r8,624(sp)
811286dc:	9abfffc4 	addi	r10,r19,-1
811286e0:	44400017 	ldw	r17,0(r8)
811286e4:	44000104 	addi	r16,r8,4
811286e8:	880b883a 	mov	r5,r17
811286ec:	8aa9883a 	add	r20,r17,r10
811286f0:	00000606 	br	8112870c <__svfscanf_r+0x13cc>
811286f4:	e0c00017 	ldw	r3,0(fp)
811286f8:	b9000017 	ldw	r4,0(r23)
811286fc:	a80b883a 	mov	r5,r21
81128700:	18800003 	ldbu	r2,0(r3)
81128704:	2085883a 	add	r2,r4,r2
81128708:	10800043 	ldbu	r2,1(r2)
8112870c:	1080020c 	andi	r2,r2,8
81128710:	1000551e 	bne	r2,zero,81128868 <__svfscanf_r+0x1528>
81128714:	e0800117 	ldw	r2,4(fp)
81128718:	19000044 	addi	r4,r3,1
8112871c:	e1000015 	stw	r4,0(fp)
81128720:	10bfffc4 	addi	r2,r2,-1
81128724:	e0800115 	stw	r2,4(fp)
81128728:	18800003 	ldbu	r2,0(r3)
8112872c:	2d400044 	addi	r21,r5,1
81128730:	a827883a 	mov	r19,r21
81128734:	28800005 	stb	r2,0(r5)
81128738:	2d000626 	beq	r5,r20,81128754 <__svfscanf_r+0x1414>
8112873c:	e0800117 	ldw	r2,4(fp)
81128740:	00bfec16 	blt	zero,r2,811286f4 <__reset+0xfb1086f4>
81128744:	e00b883a 	mov	r5,fp
81128748:	b009883a 	mov	r4,r22
8112874c:	11226200 	call	81122620 <__srefill_r>
81128750:	103fe826 	beq	r2,zero,811286f4 <__reset+0xfb1086f4>
81128754:	da00a017 	ldw	r8,640(sp)
81128758:	dd009d17 	ldw	r20,628(sp)
8112875c:	9c63c83a 	sub	r17,r19,r17
81128760:	42000044 	addi	r8,r8,1
81128764:	98000005 	stb	zero,0(r19)
81128768:	9465883a 	add	r18,r18,r17
8112876c:	da00a015 	stw	r8,640(sp)
81128770:	dc009c15 	stw	r16,624(sp)
81128774:	a00d883a 	mov	r6,r20
81128778:	003b2f06 	br	81127438 <__reset+0xfb107438>
8112877c:	dd409904 	addi	r21,sp,612
81128780:	8c40040c 	andi	r17,r17,16
81128784:	01800204 	movi	r6,8
81128788:	000b883a 	mov	r5,zero
8112878c:	a809883a 	mov	r4,r21
81128790:	11221a40 	call	811221a4 <memset>
81128794:	8800401e 	bne	r17,zero,81128898 <__svfscanf_r+0x1558>
81128798:	da009c17 	ldw	r8,624(sp)
8112879c:	45000017 	ldw	r20,0(r8)
811287a0:	42000104 	addi	r8,r8,4
811287a4:	da009c15 	stw	r8,624(sp)
811287a8:	000d883a 	mov	r6,zero
811287ac:	3021883a 	mov	r16,r6
811287b0:	dc409f15 	stw	r17,636(sp)
811287b4:	e0800017 	ldw	r2,0(fp)
811287b8:	b8c00017 	ldw	r3,0(r23)
811287bc:	10800003 	ldbu	r2,0(r2)
811287c0:	1885883a 	add	r2,r3,r2
811287c4:	10800043 	ldbu	r2,1(r2)
811287c8:	1080020c 	andi	r2,r2,8
811287cc:	1000011e 	bne	r2,zero,811287d4 <__svfscanf_r+0x1494>
811287d0:	9800701e 	bne	r19,zero,81128994 <__svfscanf_r+0x1654>
811287d4:	dc409f17 	ldw	r17,636(sp)
811287d8:	883cdd1e 	bne	r17,zero,81127b50 <__reset+0xfb107b50>
811287dc:	a0000015 	stw	zero,0(r20)
811287e0:	003cd806 	br	81127b44 <__reset+0xfb107b44>
811287e4:	d9c09e17 	ldw	r7,632(sp)
811287e8:	da00a117 	ldw	r8,644(sp)
811287ec:	000d883a 	mov	r6,zero
811287f0:	d9400104 	addi	r5,sp,4
811287f4:	b009883a 	mov	r4,r22
811287f8:	80000005 	stb	zero,0(r16)
811287fc:	403ee83a 	callr	r8
81128800:	88c0080c 	andi	r3,r17,32
81128804:	1800121e 	bne	r3,zero,81128850 <__svfscanf_r+0x1510>
81128808:	88c0010c 	andi	r3,r17,4
8112880c:	18004d26 	beq	r3,zero,81128944 <__svfscanf_r+0x1604>
81128810:	da009c17 	ldw	r8,624(sp)
81128814:	40c00017 	ldw	r3,0(r8)
81128818:	42000104 	addi	r8,r8,4
8112881c:	da009c15 	stw	r8,624(sp)
81128820:	1880000d 	sth	r2,0(r3)
81128824:	da00a017 	ldw	r8,640(sp)
81128828:	42000044 	addi	r8,r8,1
8112882c:	da00a015 	stw	r8,640(sp)
81128830:	003f5906 	br	81128598 <__reset+0xfb108598>
81128834:	00bf1fc4 	movi	r2,-897
81128838:	90a4703a 	and	r18,r18,r2
8112883c:	38000226 	beq	r7,zero,81128848 <__svfscanf_r+0x1508>
81128840:	39ffffc4 	addi	r7,r7,-1
81128844:	9cc00044 	addi	r19,r19,1
81128848:	a5000044 	addi	r20,r20,1
8112884c:	003f3006 	br	81128510 <__reset+0xfb108510>
81128850:	da009c17 	ldw	r8,624(sp)
81128854:	40c00017 	ldw	r3,0(r8)
81128858:	42000104 	addi	r8,r8,4
8112885c:	da009c15 	stw	r8,624(sp)
81128860:	18800015 	stw	r2,0(r3)
81128864:	003fef06 	br	81128824 <__reset+0xfb108824>
81128868:	2827883a 	mov	r19,r5
8112886c:	003fb906 	br	81128754 <__reset+0xfb108754>
81128870:	01be1fc4 	movi	r6,-1921
81128874:	a1a8703a 	and	r20,r20,r6
81128878:	05400044 	movi	r21,1
8112887c:	003de906 	br	81128024 <__reset+0xfb108024>
81128880:	817fffc7 	ldb	r5,-1(r16)
81128884:	e00d883a 	mov	r6,fp
81128888:	b009883a 	mov	r4,r22
8112888c:	843fffc4 	addi	r16,r16,-1
81128890:	1130f980 	call	81130f98 <_ungetc_r>
81128894:	003f3c06 	br	81128588 <__reset+0xfb108588>
81128898:	dd009b04 	addi	r20,sp,620
8112889c:	003fc206 	br	811287a8 <__reset+0xfb1087a8>
811288a0:	00be1fc4 	movi	r2,-1921
811288a4:	a0a8703a 	and	r20,r20,r2
811288a8:	05800044 	movi	r22,1
811288ac:	003ddd06 	br	81128024 <__reset+0xfb108024>
811288b0:	d8c09f17 	ldw	r3,636(sp)
811288b4:	88e3c83a 	sub	r17,r17,r3
811288b8:	044dc83a 	sub	r6,zero,r17
811288bc:	883e2126 	beq	r17,zero,81128144 <__reset+0xfb108144>
811288c0:	d88055c4 	addi	r2,sp,343
811288c4:	80800136 	bltu	r16,r2,811288cc <__svfscanf_r+0x158c>
811288c8:	dc005584 	addi	r16,sp,342
811288cc:	01604574 	movhi	r5,33045
811288d0:	29412104 	addi	r5,r5,1156
811288d4:	8009883a 	mov	r4,r16
811288d8:	11229340 	call	81122934 <sprintf>
811288dc:	003e1906 	br	81128144 <__reset+0xfb108144>
811288e0:	d8c0a517 	ldw	r3,660(sp)
811288e4:	000d883a 	mov	r6,zero
811288e8:	01c00284 	movi	r7,10
811288ec:	19400044 	addi	r5,r3,1
811288f0:	b009883a 	mov	r4,r22
811288f4:	1122c240 	call	81122c24 <_strtol_r>
811288f8:	da00a417 	ldw	r8,656(sp)
811288fc:	dc00a517 	ldw	r16,660(sp)
81128900:	120dc83a 	sub	r6,r2,r8
81128904:	003fee06 	br	811288c0 <__reset+0xfb1088c0>
81128908:	da009c17 	ldw	r8,624(sp)
8112890c:	180b883a 	mov	r5,r3
81128910:	8009883a 	mov	r4,r16
81128914:	45000017 	ldw	r20,0(r8)
81128918:	44400104 	addi	r17,r8,4
8112891c:	d8c0a615 	stw	r3,664(sp)
81128920:	112d8b40 	call	8112d8b4 <__fpclassifyd>
81128924:	d8c0a617 	ldw	r3,664(sp)
81128928:	10006426 	beq	r2,zero,81128abc <__svfscanf_r+0x177c>
8112892c:	8009883a 	mov	r4,r16
81128930:	180b883a 	mov	r5,r3
81128934:	1120c3c0 	call	81120c3c <__truncdfsf2>
81128938:	a0800015 	stw	r2,0(r20)
8112893c:	dc409c15 	stw	r17,624(sp)
81128940:	003e0f06 	br	81128180 <__reset+0xfb108180>
81128944:	88c0004c 	andi	r3,r17,1
81128948:	183fc11e 	bne	r3,zero,81128850 <__reset+0xfb108850>
8112894c:	8c40008c 	andi	r17,r17,2
81128950:	883fbf26 	beq	r17,zero,81128850 <__reset+0xfb108850>
81128954:	da00a117 	ldw	r8,644(sp)
81128958:	00a044f4 	movhi	r2,33043
8112895c:	10bd5404 	addi	r2,r2,-2736
81128960:	d9c09e17 	ldw	r7,632(sp)
81128964:	000d883a 	mov	r6,zero
81128968:	d9400104 	addi	r5,sp,4
8112896c:	b009883a 	mov	r4,r22
81128970:	40806226 	beq	r8,r2,81128afc <__svfscanf_r+0x17bc>
81128974:	112f2680 	call	8112f268 <_strtoll_r>
81128978:	da009c17 	ldw	r8,624(sp)
8112897c:	41000017 	ldw	r4,0(r8)
81128980:	42000104 	addi	r8,r8,4
81128984:	da009c15 	stw	r8,624(sp)
81128988:	20800015 	stw	r2,0(r4)
8112898c:	20c00115 	stw	r3,4(r4)
81128990:	003fa406 	br	81128824 <__reset+0xfb108824>
81128994:	112bd440 	call	8112bd44 <__locale_mb_cur_max>
81128998:	80bca726 	beq	r16,r2,81127c38 <__reset+0xfb107c38>
8112899c:	e0800017 	ldw	r2,0(fp)
811289a0:	e1000117 	ldw	r4,4(fp)
811289a4:	d8c00104 	addi	r3,sp,4
811289a8:	12000003 	ldbu	r8,0(r2)
811289ac:	213fffc4 	addi	r4,r4,-1
811289b0:	10800044 	addi	r2,r2,1
811289b4:	e1000115 	stw	r4,4(fp)
811289b8:	e0800015 	stw	r2,0(fp)
811289bc:	84400044 	addi	r17,r16,1
811289c0:	dd400015 	stw	r21,0(sp)
811289c4:	1c21883a 	add	r16,r3,r16
811289c8:	b009883a 	mov	r4,r22
811289cc:	880f883a 	mov	r7,r17
811289d0:	180d883a 	mov	r6,r3
811289d4:	a00b883a 	mov	r5,r20
811289d8:	82000005 	stb	r8,0(r16)
811289dc:	112be000 	call	8112be00 <_mbrtowc_r>
811289e0:	013fffc4 	movi	r4,-1
811289e4:	113c9426 	beq	r2,r4,81127c38 <__reset+0xfb107c38>
811289e8:	103c881e 	bne	r2,zero,81127c0c <__reset+0xfb107c0c>
811289ec:	a0000015 	stw	zero,0(r20)
811289f0:	0009883a 	mov	r4,zero
811289f4:	112bc840 	call	8112bc84 <iswspace>
811289f8:	10001a26 	beq	r2,zero,81128a64 <__svfscanf_r+0x1724>
811289fc:	8821883a 	mov	r16,r17
81128a00:	dc409f17 	ldw	r17,636(sp)
81128a04:	803f7426 	beq	r16,zero,811287d8 <__reset+0xfb1087d8>
81128a08:	843fffc4 	addi	r16,r16,-1
81128a0c:	d9800104 	addi	r6,sp,4
81128a10:	342b883a 	add	r21,r6,r16
81128a14:	00000106 	br	81128a1c <__svfscanf_r+0x16dc>
81128a18:	843fffc4 	addi	r16,r16,-1
81128a1c:	a9400003 	ldbu	r5,0(r21)
81128a20:	e00d883a 	mov	r6,fp
81128a24:	b009883a 	mov	r4,r22
81128a28:	1130f980 	call	81130f98 <_ungetc_r>
81128a2c:	ad7fffc4 	addi	r21,r21,-1
81128a30:	803ff91e 	bne	r16,zero,81128a18 <__reset+0xfb108a18>
81128a34:	003f6806 	br	811287d8 <__reset+0xfb1087d8>
81128a38:	d9800104 	addi	r6,sp,4
81128a3c:	802b883a 	mov	r21,r16
81128a40:	343a812e 	bgeu	r6,r16,81127448 <__reset+0xfb107448>
81128a44:	ad7fffc4 	addi	r21,r21,-1
81128a48:	a9400007 	ldb	r5,0(r21)
81128a4c:	e00d883a 	mov	r6,fp
81128a50:	b009883a 	mov	r4,r22
81128a54:	1130f980 	call	81130f98 <_ungetc_r>
81128a58:	da000104 	addi	r8,sp,4
81128a5c:	457ff91e 	bne	r8,r21,81128a44 <__reset+0xfb108a44>
81128a60:	003a7906 	br	81127448 <__reset+0xfb107448>
81128a64:	da009f17 	ldw	r8,636(sp)
81128a68:	9465883a 	add	r18,r18,r17
81128a6c:	9cffffc4 	addi	r19,r19,-1
81128a70:	4000051e 	bne	r8,zero,81128a88 <__svfscanf_r+0x1748>
81128a74:	a5000104 	addi	r20,r20,4
81128a78:	0021883a 	mov	r16,zero
81128a7c:	003c6606 	br	81127c18 <__reset+0xfb107c18>
81128a80:	a1000017 	ldw	r4,0(r20)
81128a84:	003fdb06 	br	811289f4 <__reset+0xfb1089f4>
81128a88:	0021883a 	mov	r16,zero
81128a8c:	003c6206 	br	81127c18 <__reset+0xfb107c18>
81128a90:	d8800104 	addi	r2,sp,4
81128a94:	802b883a 	mov	r21,r16
81128a98:	143a6b2e 	bgeu	r2,r16,81127448 <__reset+0xfb107448>
81128a9c:	ad7fffc4 	addi	r21,r21,-1
81128aa0:	a9400007 	ldb	r5,0(r21)
81128aa4:	e00d883a 	mov	r6,fp
81128aa8:	b009883a 	mov	r4,r22
81128aac:	1130f980 	call	81130f98 <_ungetc_r>
81128ab0:	d8c00104 	addi	r3,sp,4
81128ab4:	1d7ff91e 	bne	r3,r21,81128a9c <__reset+0xfb108a9c>
81128ab8:	003a6306 	br	81127448 <__reset+0xfb107448>
81128abc:	0009883a 	mov	r4,zero
81128ac0:	112d9f80 	call	8112d9f8 <nanf>
81128ac4:	a0800015 	stw	r2,0(r20)
81128ac8:	dc409c15 	stw	r17,624(sp)
81128acc:	003dac06 	br	81128180 <__reset+0xfb108180>
81128ad0:	d9000104 	addi	r4,sp,4
81128ad4:	802b883a 	mov	r21,r16
81128ad8:	243a5b2e 	bgeu	r4,r16,81127448 <__reset+0xfb107448>
81128adc:	ad7fffc4 	addi	r21,r21,-1
81128ae0:	a9400007 	ldb	r5,0(r21)
81128ae4:	e00d883a 	mov	r6,fp
81128ae8:	b009883a 	mov	r4,r22
81128aec:	1130f980 	call	81130f98 <_ungetc_r>
81128af0:	d9400104 	addi	r5,sp,4
81128af4:	2d7ff91e 	bne	r5,r21,81128adc <__reset+0xfb108adc>
81128af8:	003a5306 	br	81127448 <__reset+0xfb107448>
81128afc:	112f7c00 	call	8112f7c0 <_strtoull_r>
81128b00:	003f9d06 	br	81128978 <__reset+0xfb108978>

81128b04 <vfscanf>:
81128b04:	00a04574 	movhi	r2,33045
81128b08:	defffb04 	addi	sp,sp,-20
81128b0c:	108ad804 	addi	r2,r2,11104
81128b10:	de00012e 	bgeu	sp,et,81128b18 <vfscanf+0x14>
81128b14:	003b68fa 	trap	3
81128b18:	dc000215 	stw	r16,8(sp)
81128b1c:	14000017 	ldw	r16,0(r2)
81128b20:	dc400315 	stw	r17,12(sp)
81128b24:	dfc00415 	stw	ra,16(sp)
81128b28:	2023883a 	mov	r17,r4
81128b2c:	80000826 	beq	r16,zero,81128b50 <vfscanf+0x4c>
81128b30:	80800e17 	ldw	r2,56(r16)
81128b34:	1000061e 	bne	r2,zero,81128b50 <vfscanf+0x4c>
81128b38:	8009883a 	mov	r4,r16
81128b3c:	d9400015 	stw	r5,0(sp)
81128b40:	d9800115 	stw	r6,4(sp)
81128b44:	112ae1c0 	call	8112ae1c <__sinit>
81128b48:	d9800117 	ldw	r6,4(sp)
81128b4c:	d9400017 	ldw	r5,0(sp)
81128b50:	300f883a 	mov	r7,r6
81128b54:	8009883a 	mov	r4,r16
81128b58:	280d883a 	mov	r6,r5
81128b5c:	880b883a 	mov	r5,r17
81128b60:	dfc00417 	ldw	ra,16(sp)
81128b64:	dc400317 	ldw	r17,12(sp)
81128b68:	dc000217 	ldw	r16,8(sp)
81128b6c:	dec00504 	addi	sp,sp,20
81128b70:	11273401 	jmpi	81127340 <__svfscanf_r>

81128b74 <__svfscanf>:
81128b74:	00a04574 	movhi	r2,33045
81128b78:	108ad804 	addi	r2,r2,11104
81128b7c:	300f883a 	mov	r7,r6
81128b80:	280d883a 	mov	r6,r5
81128b84:	200b883a 	mov	r5,r4
81128b88:	11000017 	ldw	r4,0(r2)
81128b8c:	11273401 	jmpi	81127340 <__svfscanf_r>

81128b90 <_vfscanf_r>:
81128b90:	defffb04 	addi	sp,sp,-20
81128b94:	de00012e 	bgeu	sp,et,81128b9c <_vfscanf_r+0xc>
81128b98:	003b68fa 	trap	3
81128b9c:	dc000315 	stw	r16,12(sp)
81128ba0:	dfc00415 	stw	ra,16(sp)
81128ba4:	2021883a 	mov	r16,r4
81128ba8:	20000926 	beq	r4,zero,81128bd0 <_vfscanf_r+0x40>
81128bac:	20800e17 	ldw	r2,56(r4)
81128bb0:	1000071e 	bne	r2,zero,81128bd0 <_vfscanf_r+0x40>
81128bb4:	d9400015 	stw	r5,0(sp)
81128bb8:	d9800115 	stw	r6,4(sp)
81128bbc:	d9c00215 	stw	r7,8(sp)
81128bc0:	112ae1c0 	call	8112ae1c <__sinit>
81128bc4:	d9c00217 	ldw	r7,8(sp)
81128bc8:	d9800117 	ldw	r6,4(sp)
81128bcc:	d9400017 	ldw	r5,0(sp)
81128bd0:	8009883a 	mov	r4,r16
81128bd4:	dfc00417 	ldw	ra,16(sp)
81128bd8:	dc000317 	ldw	r16,12(sp)
81128bdc:	dec00504 	addi	sp,sp,20
81128be0:	11273401 	jmpi	81127340 <__svfscanf_r>

81128be4 <__swbuf_r>:
81128be4:	defffb04 	addi	sp,sp,-20
81128be8:	de00012e 	bgeu	sp,et,81128bf0 <__swbuf_r+0xc>
81128bec:	003b68fa 	trap	3
81128bf0:	dcc00315 	stw	r19,12(sp)
81128bf4:	dc800215 	stw	r18,8(sp)
81128bf8:	dc000015 	stw	r16,0(sp)
81128bfc:	dfc00415 	stw	ra,16(sp)
81128c00:	dc400115 	stw	r17,4(sp)
81128c04:	2025883a 	mov	r18,r4
81128c08:	2827883a 	mov	r19,r5
81128c0c:	3021883a 	mov	r16,r6
81128c10:	20000226 	beq	r4,zero,81128c1c <__swbuf_r+0x38>
81128c14:	20800e17 	ldw	r2,56(r4)
81128c18:	10004226 	beq	r2,zero,81128d24 <__swbuf_r+0x140>
81128c1c:	80800617 	ldw	r2,24(r16)
81128c20:	8100030b 	ldhu	r4,12(r16)
81128c24:	80800215 	stw	r2,8(r16)
81128c28:	2080020c 	andi	r2,r4,8
81128c2c:	10003626 	beq	r2,zero,81128d08 <__swbuf_r+0x124>
81128c30:	80c00417 	ldw	r3,16(r16)
81128c34:	18003426 	beq	r3,zero,81128d08 <__swbuf_r+0x124>
81128c38:	2088000c 	andi	r2,r4,8192
81128c3c:	9c403fcc 	andi	r17,r19,255
81128c40:	10001a26 	beq	r2,zero,81128cac <__swbuf_r+0xc8>
81128c44:	80800017 	ldw	r2,0(r16)
81128c48:	81000517 	ldw	r4,20(r16)
81128c4c:	10c7c83a 	sub	r3,r2,r3
81128c50:	1900200e 	bge	r3,r4,81128cd4 <__swbuf_r+0xf0>
81128c54:	18c00044 	addi	r3,r3,1
81128c58:	81000217 	ldw	r4,8(r16)
81128c5c:	11400044 	addi	r5,r2,1
81128c60:	81400015 	stw	r5,0(r16)
81128c64:	213fffc4 	addi	r4,r4,-1
81128c68:	81000215 	stw	r4,8(r16)
81128c6c:	14c00005 	stb	r19,0(r2)
81128c70:	80800517 	ldw	r2,20(r16)
81128c74:	10c01e26 	beq	r2,r3,81128cf0 <__swbuf_r+0x10c>
81128c78:	8080030b 	ldhu	r2,12(r16)
81128c7c:	1080004c 	andi	r2,r2,1
81128c80:	10000226 	beq	r2,zero,81128c8c <__swbuf_r+0xa8>
81128c84:	00800284 	movi	r2,10
81128c88:	88801926 	beq	r17,r2,81128cf0 <__swbuf_r+0x10c>
81128c8c:	8805883a 	mov	r2,r17
81128c90:	dfc00417 	ldw	ra,16(sp)
81128c94:	dcc00317 	ldw	r19,12(sp)
81128c98:	dc800217 	ldw	r18,8(sp)
81128c9c:	dc400117 	ldw	r17,4(sp)
81128ca0:	dc000017 	ldw	r16,0(sp)
81128ca4:	dec00504 	addi	sp,sp,20
81128ca8:	f800283a 	ret
81128cac:	81401917 	ldw	r5,100(r16)
81128cb0:	00b7ffc4 	movi	r2,-8193
81128cb4:	21080014 	ori	r4,r4,8192
81128cb8:	2884703a 	and	r2,r5,r2
81128cbc:	80801915 	stw	r2,100(r16)
81128cc0:	80800017 	ldw	r2,0(r16)
81128cc4:	8100030d 	sth	r4,12(r16)
81128cc8:	81000517 	ldw	r4,20(r16)
81128ccc:	10c7c83a 	sub	r3,r2,r3
81128cd0:	193fe016 	blt	r3,r4,81128c54 <__reset+0xfb108c54>
81128cd4:	800b883a 	mov	r5,r16
81128cd8:	9009883a 	mov	r4,r18
81128cdc:	112aa200 	call	8112aa20 <_fflush_r>
81128ce0:	1000071e 	bne	r2,zero,81128d00 <__swbuf_r+0x11c>
81128ce4:	80800017 	ldw	r2,0(r16)
81128ce8:	00c00044 	movi	r3,1
81128cec:	003fda06 	br	81128c58 <__reset+0xfb108c58>
81128cf0:	800b883a 	mov	r5,r16
81128cf4:	9009883a 	mov	r4,r18
81128cf8:	112aa200 	call	8112aa20 <_fflush_r>
81128cfc:	103fe326 	beq	r2,zero,81128c8c <__reset+0xfb108c8c>
81128d00:	00bfffc4 	movi	r2,-1
81128d04:	003fe206 	br	81128c90 <__reset+0xfb108c90>
81128d08:	800b883a 	mov	r5,r16
81128d0c:	9009883a 	mov	r4,r18
81128d10:	1128dac0 	call	81128dac <__swsetup_r>
81128d14:	103ffa1e 	bne	r2,zero,81128d00 <__reset+0xfb108d00>
81128d18:	8100030b 	ldhu	r4,12(r16)
81128d1c:	80c00417 	ldw	r3,16(r16)
81128d20:	003fc506 	br	81128c38 <__reset+0xfb108c38>
81128d24:	112ae1c0 	call	8112ae1c <__sinit>
81128d28:	003fbc06 	br	81128c1c <__reset+0xfb108c1c>

81128d2c <__swbuf>:
81128d2c:	00a04574 	movhi	r2,33045
81128d30:	108ad804 	addi	r2,r2,11104
81128d34:	280d883a 	mov	r6,r5
81128d38:	200b883a 	mov	r5,r4
81128d3c:	11000017 	ldw	r4,0(r2)
81128d40:	1128be41 	jmpi	81128be4 <__swbuf_r>

81128d44 <_write_r>:
81128d44:	defffd04 	addi	sp,sp,-12
81128d48:	de00012e 	bgeu	sp,et,81128d50 <_write_r+0xc>
81128d4c:	003b68fa 	trap	3
81128d50:	2805883a 	mov	r2,r5
81128d54:	dc000015 	stw	r16,0(sp)
81128d58:	04204574 	movhi	r16,33045
81128d5c:	dc400115 	stw	r17,4(sp)
81128d60:	300b883a 	mov	r5,r6
81128d64:	840b4b04 	addi	r16,r16,11564
81128d68:	2023883a 	mov	r17,r4
81128d6c:	380d883a 	mov	r6,r7
81128d70:	1009883a 	mov	r4,r2
81128d74:	dfc00215 	stw	ra,8(sp)
81128d78:	80000015 	stw	zero,0(r16)
81128d7c:	113783c0 	call	8113783c <write>
81128d80:	00ffffc4 	movi	r3,-1
81128d84:	10c00526 	beq	r2,r3,81128d9c <_write_r+0x58>
81128d88:	dfc00217 	ldw	ra,8(sp)
81128d8c:	dc400117 	ldw	r17,4(sp)
81128d90:	dc000017 	ldw	r16,0(sp)
81128d94:	dec00304 	addi	sp,sp,12
81128d98:	f800283a 	ret
81128d9c:	80c00017 	ldw	r3,0(r16)
81128da0:	183ff926 	beq	r3,zero,81128d88 <__reset+0xfb108d88>
81128da4:	88c00015 	stw	r3,0(r17)
81128da8:	003ff706 	br	81128d88 <__reset+0xfb108d88>

81128dac <__swsetup_r>:
81128dac:	00a04574 	movhi	r2,33045
81128db0:	defffd04 	addi	sp,sp,-12
81128db4:	108ad804 	addi	r2,r2,11104
81128db8:	de00012e 	bgeu	sp,et,81128dc0 <__swsetup_r+0x14>
81128dbc:	003b68fa 	trap	3
81128dc0:	dc400115 	stw	r17,4(sp)
81128dc4:	2023883a 	mov	r17,r4
81128dc8:	11000017 	ldw	r4,0(r2)
81128dcc:	dc000015 	stw	r16,0(sp)
81128dd0:	dfc00215 	stw	ra,8(sp)
81128dd4:	2821883a 	mov	r16,r5
81128dd8:	20000226 	beq	r4,zero,81128de4 <__swsetup_r+0x38>
81128ddc:	20800e17 	ldw	r2,56(r4)
81128de0:	10003126 	beq	r2,zero,81128ea8 <__swsetup_r+0xfc>
81128de4:	8080030b 	ldhu	r2,12(r16)
81128de8:	10c0020c 	andi	r3,r2,8
81128dec:	1009883a 	mov	r4,r2
81128df0:	18000f26 	beq	r3,zero,81128e30 <__swsetup_r+0x84>
81128df4:	80c00417 	ldw	r3,16(r16)
81128df8:	18001526 	beq	r3,zero,81128e50 <__swsetup_r+0xa4>
81128dfc:	1100004c 	andi	r4,r2,1
81128e00:	20001c1e 	bne	r4,zero,81128e74 <__swsetup_r+0xc8>
81128e04:	1080008c 	andi	r2,r2,2
81128e08:	1000291e 	bne	r2,zero,81128eb0 <__swsetup_r+0x104>
81128e0c:	80800517 	ldw	r2,20(r16)
81128e10:	80800215 	stw	r2,8(r16)
81128e14:	18001c26 	beq	r3,zero,81128e88 <__swsetup_r+0xdc>
81128e18:	0005883a 	mov	r2,zero
81128e1c:	dfc00217 	ldw	ra,8(sp)
81128e20:	dc400117 	ldw	r17,4(sp)
81128e24:	dc000017 	ldw	r16,0(sp)
81128e28:	dec00304 	addi	sp,sp,12
81128e2c:	f800283a 	ret
81128e30:	2080040c 	andi	r2,r4,16
81128e34:	10002e26 	beq	r2,zero,81128ef0 <__swsetup_r+0x144>
81128e38:	2080010c 	andi	r2,r4,4
81128e3c:	10001e1e 	bne	r2,zero,81128eb8 <__swsetup_r+0x10c>
81128e40:	80c00417 	ldw	r3,16(r16)
81128e44:	20800214 	ori	r2,r4,8
81128e48:	8080030d 	sth	r2,12(r16)
81128e4c:	183feb1e 	bne	r3,zero,81128dfc <__reset+0xfb108dfc>
81128e50:	1100a00c 	andi	r4,r2,640
81128e54:	01408004 	movi	r5,512
81128e58:	217fe826 	beq	r4,r5,81128dfc <__reset+0xfb108dfc>
81128e5c:	800b883a 	mov	r5,r16
81128e60:	8809883a 	mov	r4,r17
81128e64:	112167c0 	call	8112167c <__smakebuf_r>
81128e68:	8080030b 	ldhu	r2,12(r16)
81128e6c:	80c00417 	ldw	r3,16(r16)
81128e70:	003fe206 	br	81128dfc <__reset+0xfb108dfc>
81128e74:	80800517 	ldw	r2,20(r16)
81128e78:	80000215 	stw	zero,8(r16)
81128e7c:	0085c83a 	sub	r2,zero,r2
81128e80:	80800615 	stw	r2,24(r16)
81128e84:	183fe41e 	bne	r3,zero,81128e18 <__reset+0xfb108e18>
81128e88:	80c0030b 	ldhu	r3,12(r16)
81128e8c:	0005883a 	mov	r2,zero
81128e90:	1900200c 	andi	r4,r3,128
81128e94:	203fe126 	beq	r4,zero,81128e1c <__reset+0xfb108e1c>
81128e98:	18c01014 	ori	r3,r3,64
81128e9c:	80c0030d 	sth	r3,12(r16)
81128ea0:	00bfffc4 	movi	r2,-1
81128ea4:	003fdd06 	br	81128e1c <__reset+0xfb108e1c>
81128ea8:	112ae1c0 	call	8112ae1c <__sinit>
81128eac:	003fcd06 	br	81128de4 <__reset+0xfb108de4>
81128eb0:	0005883a 	mov	r2,zero
81128eb4:	003fd606 	br	81128e10 <__reset+0xfb108e10>
81128eb8:	81400c17 	ldw	r5,48(r16)
81128ebc:	28000626 	beq	r5,zero,81128ed8 <__swsetup_r+0x12c>
81128ec0:	80801004 	addi	r2,r16,64
81128ec4:	28800326 	beq	r5,r2,81128ed4 <__swsetup_r+0x128>
81128ec8:	8809883a 	mov	r4,r17
81128ecc:	112b2b40 	call	8112b2b4 <_free_r>
81128ed0:	8100030b 	ldhu	r4,12(r16)
81128ed4:	80000c15 	stw	zero,48(r16)
81128ed8:	80c00417 	ldw	r3,16(r16)
81128edc:	00bff6c4 	movi	r2,-37
81128ee0:	1108703a 	and	r4,r2,r4
81128ee4:	80000115 	stw	zero,4(r16)
81128ee8:	80c00015 	stw	r3,0(r16)
81128eec:	003fd506 	br	81128e44 <__reset+0xfb108e44>
81128ef0:	00800244 	movi	r2,9
81128ef4:	88800015 	stw	r2,0(r17)
81128ef8:	20801014 	ori	r2,r4,64
81128efc:	8080030d 	sth	r2,12(r16)
81128f00:	00bfffc4 	movi	r2,-1
81128f04:	003fc506 	br	81128e1c <__reset+0xfb108e1c>

81128f08 <_close_r>:
81128f08:	defffd04 	addi	sp,sp,-12
81128f0c:	de00012e 	bgeu	sp,et,81128f14 <_close_r+0xc>
81128f10:	003b68fa 	trap	3
81128f14:	dc000015 	stw	r16,0(sp)
81128f18:	04204574 	movhi	r16,33045
81128f1c:	dc400115 	stw	r17,4(sp)
81128f20:	840b4b04 	addi	r16,r16,11564
81128f24:	2023883a 	mov	r17,r4
81128f28:	2809883a 	mov	r4,r5
81128f2c:	dfc00215 	stw	ra,8(sp)
81128f30:	80000015 	stw	zero,0(r16)
81128f34:	1135dbc0 	call	81135dbc <close>
81128f38:	00ffffc4 	movi	r3,-1
81128f3c:	10c00526 	beq	r2,r3,81128f54 <_close_r+0x4c>
81128f40:	dfc00217 	ldw	ra,8(sp)
81128f44:	dc400117 	ldw	r17,4(sp)
81128f48:	dc000017 	ldw	r16,0(sp)
81128f4c:	dec00304 	addi	sp,sp,12
81128f50:	f800283a 	ret
81128f54:	80c00017 	ldw	r3,0(r16)
81128f58:	183ff926 	beq	r3,zero,81128f40 <__reset+0xfb108f40>
81128f5c:	88c00015 	stw	r3,0(r17)
81128f60:	003ff706 	br	81128f40 <__reset+0xfb108f40>

81128f64 <quorem>:
81128f64:	defff704 	addi	sp,sp,-36
81128f68:	de00012e 	bgeu	sp,et,81128f70 <quorem+0xc>
81128f6c:	003b68fa 	trap	3
81128f70:	dc800215 	stw	r18,8(sp)
81128f74:	20800417 	ldw	r2,16(r4)
81128f78:	2c800417 	ldw	r18,16(r5)
81128f7c:	dfc00815 	stw	ra,32(sp)
81128f80:	ddc00715 	stw	r23,28(sp)
81128f84:	dd800615 	stw	r22,24(sp)
81128f88:	dd400515 	stw	r21,20(sp)
81128f8c:	dd000415 	stw	r20,16(sp)
81128f90:	dcc00315 	stw	r19,12(sp)
81128f94:	dc400115 	stw	r17,4(sp)
81128f98:	dc000015 	stw	r16,0(sp)
81128f9c:	14807116 	blt	r2,r18,81129164 <quorem+0x200>
81128fa0:	94bfffc4 	addi	r18,r18,-1
81128fa4:	94ad883a 	add	r22,r18,r18
81128fa8:	b5ad883a 	add	r22,r22,r22
81128fac:	2c400504 	addi	r17,r5,20
81128fb0:	8da9883a 	add	r20,r17,r22
81128fb4:	25400504 	addi	r21,r4,20
81128fb8:	282f883a 	mov	r23,r5
81128fbc:	adad883a 	add	r22,r21,r22
81128fc0:	a1400017 	ldw	r5,0(r20)
81128fc4:	2021883a 	mov	r16,r4
81128fc8:	b1000017 	ldw	r4,0(r22)
81128fcc:	29400044 	addi	r5,r5,1
81128fd0:	11345c00 	call	811345c0 <__udivsi3>
81128fd4:	1027883a 	mov	r19,r2
81128fd8:	10002c26 	beq	r2,zero,8112908c <quorem+0x128>
81128fdc:	a813883a 	mov	r9,r21
81128fe0:	880b883a 	mov	r5,r17
81128fe4:	0009883a 	mov	r4,zero
81128fe8:	000d883a 	mov	r6,zero
81128fec:	2a000017 	ldw	r8,0(r5)
81128ff0:	49c00017 	ldw	r7,0(r9)
81128ff4:	29400104 	addi	r5,r5,4
81128ff8:	40bfffcc 	andi	r2,r8,65535
81128ffc:	14c5383a 	mul	r2,r2,r19
81129000:	4010d43a 	srli	r8,r8,16
81129004:	38ffffcc 	andi	r3,r7,65535
81129008:	1105883a 	add	r2,r2,r4
8112900c:	1008d43a 	srli	r4,r2,16
81129010:	44d1383a 	mul	r8,r8,r19
81129014:	198d883a 	add	r6,r3,r6
81129018:	10ffffcc 	andi	r3,r2,65535
8112901c:	30c7c83a 	sub	r3,r6,r3
81129020:	380ed43a 	srli	r7,r7,16
81129024:	4105883a 	add	r2,r8,r4
81129028:	180dd43a 	srai	r6,r3,16
8112902c:	113fffcc 	andi	r4,r2,65535
81129030:	390fc83a 	sub	r7,r7,r4
81129034:	398d883a 	add	r6,r7,r6
81129038:	300e943a 	slli	r7,r6,16
8112903c:	18ffffcc 	andi	r3,r3,65535
81129040:	1008d43a 	srli	r4,r2,16
81129044:	38ceb03a 	or	r7,r7,r3
81129048:	49c00015 	stw	r7,0(r9)
8112904c:	300dd43a 	srai	r6,r6,16
81129050:	4a400104 	addi	r9,r9,4
81129054:	a17fe52e 	bgeu	r20,r5,81128fec <__reset+0xfb108fec>
81129058:	b0800017 	ldw	r2,0(r22)
8112905c:	10000b1e 	bne	r2,zero,8112908c <quorem+0x128>
81129060:	b0bfff04 	addi	r2,r22,-4
81129064:	a880082e 	bgeu	r21,r2,81129088 <quorem+0x124>
81129068:	b0ffff17 	ldw	r3,-4(r22)
8112906c:	18000326 	beq	r3,zero,8112907c <quorem+0x118>
81129070:	00000506 	br	81129088 <quorem+0x124>
81129074:	10c00017 	ldw	r3,0(r2)
81129078:	1800031e 	bne	r3,zero,81129088 <quorem+0x124>
8112907c:	10bfff04 	addi	r2,r2,-4
81129080:	94bfffc4 	addi	r18,r18,-1
81129084:	a8bffb36 	bltu	r21,r2,81129074 <__reset+0xfb109074>
81129088:	84800415 	stw	r18,16(r16)
8112908c:	b80b883a 	mov	r5,r23
81129090:	8009883a 	mov	r4,r16
81129094:	112cb840 	call	8112cb84 <__mcmp>
81129098:	10002616 	blt	r2,zero,81129134 <quorem+0x1d0>
8112909c:	9cc00044 	addi	r19,r19,1
811290a0:	a805883a 	mov	r2,r21
811290a4:	000b883a 	mov	r5,zero
811290a8:	11000017 	ldw	r4,0(r2)
811290ac:	89800017 	ldw	r6,0(r17)
811290b0:	10800104 	addi	r2,r2,4
811290b4:	20ffffcc 	andi	r3,r4,65535
811290b8:	194b883a 	add	r5,r3,r5
811290bc:	30ffffcc 	andi	r3,r6,65535
811290c0:	28c7c83a 	sub	r3,r5,r3
811290c4:	300cd43a 	srli	r6,r6,16
811290c8:	2008d43a 	srli	r4,r4,16
811290cc:	180bd43a 	srai	r5,r3,16
811290d0:	18ffffcc 	andi	r3,r3,65535
811290d4:	2189c83a 	sub	r4,r4,r6
811290d8:	2149883a 	add	r4,r4,r5
811290dc:	200c943a 	slli	r6,r4,16
811290e0:	8c400104 	addi	r17,r17,4
811290e4:	200bd43a 	srai	r5,r4,16
811290e8:	30c6b03a 	or	r3,r6,r3
811290ec:	10ffff15 	stw	r3,-4(r2)
811290f0:	a47fed2e 	bgeu	r20,r17,811290a8 <__reset+0xfb1090a8>
811290f4:	9485883a 	add	r2,r18,r18
811290f8:	1085883a 	add	r2,r2,r2
811290fc:	a887883a 	add	r3,r21,r2
81129100:	18800017 	ldw	r2,0(r3)
81129104:	10000b1e 	bne	r2,zero,81129134 <quorem+0x1d0>
81129108:	18bfff04 	addi	r2,r3,-4
8112910c:	a880082e 	bgeu	r21,r2,81129130 <quorem+0x1cc>
81129110:	18ffff17 	ldw	r3,-4(r3)
81129114:	18000326 	beq	r3,zero,81129124 <quorem+0x1c0>
81129118:	00000506 	br	81129130 <quorem+0x1cc>
8112911c:	10c00017 	ldw	r3,0(r2)
81129120:	1800031e 	bne	r3,zero,81129130 <quorem+0x1cc>
81129124:	10bfff04 	addi	r2,r2,-4
81129128:	94bfffc4 	addi	r18,r18,-1
8112912c:	a8bffb36 	bltu	r21,r2,8112911c <__reset+0xfb10911c>
81129130:	84800415 	stw	r18,16(r16)
81129134:	9805883a 	mov	r2,r19
81129138:	dfc00817 	ldw	ra,32(sp)
8112913c:	ddc00717 	ldw	r23,28(sp)
81129140:	dd800617 	ldw	r22,24(sp)
81129144:	dd400517 	ldw	r21,20(sp)
81129148:	dd000417 	ldw	r20,16(sp)
8112914c:	dcc00317 	ldw	r19,12(sp)
81129150:	dc800217 	ldw	r18,8(sp)
81129154:	dc400117 	ldw	r17,4(sp)
81129158:	dc000017 	ldw	r16,0(sp)
8112915c:	dec00904 	addi	sp,sp,36
81129160:	f800283a 	ret
81129164:	0005883a 	mov	r2,zero
81129168:	003ff306 	br	81129138 <__reset+0xfb109138>

8112916c <_dtoa_r>:
8112916c:	deffde04 	addi	sp,sp,-136
81129170:	de00012e 	bgeu	sp,et,81129178 <_dtoa_r+0xc>
81129174:	003b68fa 	trap	3
81129178:	20801017 	ldw	r2,64(r4)
8112917c:	df002015 	stw	fp,128(sp)
81129180:	dcc01b15 	stw	r19,108(sp)
81129184:	dc801a15 	stw	r18,104(sp)
81129188:	dc401915 	stw	r17,100(sp)
8112918c:	dc001815 	stw	r16,96(sp)
81129190:	dfc02115 	stw	ra,132(sp)
81129194:	ddc01f15 	stw	r23,124(sp)
81129198:	dd801e15 	stw	r22,120(sp)
8112919c:	dd401d15 	stw	r21,116(sp)
811291a0:	dd001c15 	stw	r20,112(sp)
811291a4:	d9c00315 	stw	r7,12(sp)
811291a8:	2039883a 	mov	fp,r4
811291ac:	3023883a 	mov	r17,r6
811291b0:	2825883a 	mov	r18,r5
811291b4:	dc002417 	ldw	r16,144(sp)
811291b8:	3027883a 	mov	r19,r6
811291bc:	10000826 	beq	r2,zero,811291e0 <_dtoa_r+0x74>
811291c0:	21801117 	ldw	r6,68(r4)
811291c4:	00c00044 	movi	r3,1
811291c8:	100b883a 	mov	r5,r2
811291cc:	1986983a 	sll	r3,r3,r6
811291d0:	11800115 	stw	r6,4(r2)
811291d4:	10c00215 	stw	r3,8(r2)
811291d8:	112c3340 	call	8112c334 <_Bfree>
811291dc:	e0001015 	stw	zero,64(fp)
811291e0:	88002e16 	blt	r17,zero,8112929c <_dtoa_r+0x130>
811291e4:	80000015 	stw	zero,0(r16)
811291e8:	889ffc2c 	andhi	r2,r17,32752
811291ec:	00dffc34 	movhi	r3,32752
811291f0:	10c01c26 	beq	r2,r3,81129264 <_dtoa_r+0xf8>
811291f4:	000d883a 	mov	r6,zero
811291f8:	000f883a 	mov	r7,zero
811291fc:	9009883a 	mov	r4,r18
81129200:	980b883a 	mov	r5,r19
81129204:	1135a1c0 	call	81135a1c <__eqdf2>
81129208:	10002b1e 	bne	r2,zero,811292b8 <_dtoa_r+0x14c>
8112920c:	d9c02317 	ldw	r7,140(sp)
81129210:	00800044 	movi	r2,1
81129214:	38800015 	stw	r2,0(r7)
81129218:	d8802517 	ldw	r2,148(sp)
8112921c:	10019e26 	beq	r2,zero,81129898 <_dtoa_r+0x72c>
81129220:	d8c02517 	ldw	r3,148(sp)
81129224:	00a04574 	movhi	r2,33045
81129228:	10811044 	addi	r2,r2,1089
8112922c:	18800015 	stw	r2,0(r3)
81129230:	10bfffc4 	addi	r2,r2,-1
81129234:	dfc02117 	ldw	ra,132(sp)
81129238:	df002017 	ldw	fp,128(sp)
8112923c:	ddc01f17 	ldw	r23,124(sp)
81129240:	dd801e17 	ldw	r22,120(sp)
81129244:	dd401d17 	ldw	r21,116(sp)
81129248:	dd001c17 	ldw	r20,112(sp)
8112924c:	dcc01b17 	ldw	r19,108(sp)
81129250:	dc801a17 	ldw	r18,104(sp)
81129254:	dc401917 	ldw	r17,100(sp)
81129258:	dc001817 	ldw	r16,96(sp)
8112925c:	dec02204 	addi	sp,sp,136
81129260:	f800283a 	ret
81129264:	d8c02317 	ldw	r3,140(sp)
81129268:	0089c3c4 	movi	r2,9999
8112926c:	18800015 	stw	r2,0(r3)
81129270:	90017726 	beq	r18,zero,81129850 <_dtoa_r+0x6e4>
81129274:	00a04574 	movhi	r2,33045
81129278:	10812e04 	addi	r2,r2,1208
8112927c:	d9002517 	ldw	r4,148(sp)
81129280:	203fec26 	beq	r4,zero,81129234 <__reset+0xfb109234>
81129284:	10c000c7 	ldb	r3,3(r2)
81129288:	1801781e 	bne	r3,zero,8112986c <_dtoa_r+0x700>
8112928c:	10c000c4 	addi	r3,r2,3
81129290:	d9802517 	ldw	r6,148(sp)
81129294:	30c00015 	stw	r3,0(r6)
81129298:	003fe606 	br	81129234 <__reset+0xfb109234>
8112929c:	04e00034 	movhi	r19,32768
811292a0:	9cffffc4 	addi	r19,r19,-1
811292a4:	00800044 	movi	r2,1
811292a8:	8ce6703a 	and	r19,r17,r19
811292ac:	80800015 	stw	r2,0(r16)
811292b0:	9823883a 	mov	r17,r19
811292b4:	003fcc06 	br	811291e8 <__reset+0xfb1091e8>
811292b8:	d8800204 	addi	r2,sp,8
811292bc:	d8800015 	stw	r2,0(sp)
811292c0:	d9c00104 	addi	r7,sp,4
811292c4:	900b883a 	mov	r5,r18
811292c8:	980d883a 	mov	r6,r19
811292cc:	e009883a 	mov	r4,fp
811292d0:	8820d53a 	srli	r16,r17,20
811292d4:	112cf600 	call	8112cf60 <__d2b>
811292d8:	d8800915 	stw	r2,36(sp)
811292dc:	8001651e 	bne	r16,zero,81129874 <_dtoa_r+0x708>
811292e0:	dd800217 	ldw	r22,8(sp)
811292e4:	dc000117 	ldw	r16,4(sp)
811292e8:	00800804 	movi	r2,32
811292ec:	b421883a 	add	r16,r22,r16
811292f0:	80c10c84 	addi	r3,r16,1074
811292f4:	10c2d10e 	bge	r2,r3,81129e3c <_dtoa_r+0xcd0>
811292f8:	00801004 	movi	r2,64
811292fc:	81010484 	addi	r4,r16,1042
81129300:	10c7c83a 	sub	r3,r2,r3
81129304:	9108d83a 	srl	r4,r18,r4
81129308:	88e2983a 	sll	r17,r17,r3
8112930c:	2448b03a 	or	r4,r4,r17
81129310:	1135b980 	call	81135b98 <__floatunsidf>
81129314:	017f8434 	movhi	r5,65040
81129318:	01800044 	movi	r6,1
8112931c:	1009883a 	mov	r4,r2
81129320:	194b883a 	add	r5,r3,r5
81129324:	843fffc4 	addi	r16,r16,-1
81129328:	d9801115 	stw	r6,68(sp)
8112932c:	000d883a 	mov	r6,zero
81129330:	01cffe34 	movhi	r7,16376
81129334:	11200bc0 	call	811200bc <__subdf3>
81129338:	0198dbf4 	movhi	r6,25455
8112933c:	01cff4f4 	movhi	r7,16339
81129340:	3190d844 	addi	r6,r6,17249
81129344:	39e1e9c4 	addi	r7,r7,-30809
81129348:	1009883a 	mov	r4,r2
8112934c:	180b883a 	mov	r5,r3
81129350:	111f99c0 	call	8111f99c <__muldf3>
81129354:	01a2d874 	movhi	r6,35681
81129358:	01cff1f4 	movhi	r7,16327
8112935c:	31b22cc4 	addi	r6,r6,-14157
81129360:	39e28a04 	addi	r7,r7,-30168
81129364:	180b883a 	mov	r5,r3
81129368:	1009883a 	mov	r4,r2
8112936c:	11348780 	call	81134878 <__adddf3>
81129370:	8009883a 	mov	r4,r16
81129374:	1029883a 	mov	r20,r2
81129378:	1823883a 	mov	r17,r3
8112937c:	1120a400 	call	81120a40 <__floatsidf>
81129380:	019427f4 	movhi	r6,20639
81129384:	01cff4f4 	movhi	r7,16339
81129388:	319e7ec4 	addi	r6,r6,31227
8112938c:	39d104c4 	addi	r7,r7,17427
81129390:	1009883a 	mov	r4,r2
81129394:	180b883a 	mov	r5,r3
81129398:	111f99c0 	call	8111f99c <__muldf3>
8112939c:	100d883a 	mov	r6,r2
811293a0:	180f883a 	mov	r7,r3
811293a4:	a009883a 	mov	r4,r20
811293a8:	880b883a 	mov	r5,r17
811293ac:	11348780 	call	81134878 <__adddf3>
811293b0:	1009883a 	mov	r4,r2
811293b4:	180b883a 	mov	r5,r3
811293b8:	1029883a 	mov	r20,r2
811293bc:	1823883a 	mov	r17,r3
811293c0:	11209c00 	call	811209c0 <__fixdfsi>
811293c4:	000d883a 	mov	r6,zero
811293c8:	000f883a 	mov	r7,zero
811293cc:	a009883a 	mov	r4,r20
811293d0:	880b883a 	mov	r5,r17
811293d4:	d8800515 	stw	r2,20(sp)
811293d8:	1135aa40 	call	81135aa4 <__ledf2>
811293dc:	10028716 	blt	r2,zero,81129dfc <_dtoa_r+0xc90>
811293e0:	d8c00517 	ldw	r3,20(sp)
811293e4:	00800584 	movi	r2,22
811293e8:	10c27536 	bltu	r2,r3,81129dc0 <_dtoa_r+0xc54>
811293ec:	180490fa 	slli	r2,r3,3
811293f0:	00e04574 	movhi	r3,33045
811293f4:	18c14904 	addi	r3,r3,1316
811293f8:	1885883a 	add	r2,r3,r2
811293fc:	11000017 	ldw	r4,0(r2)
81129400:	11400117 	ldw	r5,4(r2)
81129404:	900d883a 	mov	r6,r18
81129408:	980f883a 	mov	r7,r19
8112940c:	111f8c00 	call	8111f8c0 <__gedf2>
81129410:	00828d0e 	bge	zero,r2,81129e48 <_dtoa_r+0xcdc>
81129414:	d9000517 	ldw	r4,20(sp)
81129418:	d8000e15 	stw	zero,56(sp)
8112941c:	213fffc4 	addi	r4,r4,-1
81129420:	d9000515 	stw	r4,20(sp)
81129424:	b42dc83a 	sub	r22,r22,r16
81129428:	b5bfffc4 	addi	r22,r22,-1
8112942c:	b0026f16 	blt	r22,zero,81129dec <_dtoa_r+0xc80>
81129430:	d8000815 	stw	zero,32(sp)
81129434:	d9c00517 	ldw	r7,20(sp)
81129438:	38026416 	blt	r7,zero,81129dcc <_dtoa_r+0xc60>
8112943c:	b1ed883a 	add	r22,r22,r7
81129440:	d9c00d15 	stw	r7,52(sp)
81129444:	d8000a15 	stw	zero,40(sp)
81129448:	d9800317 	ldw	r6,12(sp)
8112944c:	00800244 	movi	r2,9
81129450:	11811436 	bltu	r2,r6,811298a4 <_dtoa_r+0x738>
81129454:	00800144 	movi	r2,5
81129458:	1184e10e 	bge	r2,r6,8112a7e0 <_dtoa_r+0x1674>
8112945c:	31bfff04 	addi	r6,r6,-4
81129460:	d9800315 	stw	r6,12(sp)
81129464:	0023883a 	mov	r17,zero
81129468:	d9800317 	ldw	r6,12(sp)
8112946c:	008000c4 	movi	r2,3
81129470:	30836726 	beq	r6,r2,8112a210 <_dtoa_r+0x10a4>
81129474:	1183410e 	bge	r2,r6,8112a17c <_dtoa_r+0x1010>
81129478:	d9c00317 	ldw	r7,12(sp)
8112947c:	00800104 	movi	r2,4
81129480:	38827c26 	beq	r7,r2,81129e74 <_dtoa_r+0xd08>
81129484:	00800144 	movi	r2,5
81129488:	3884c41e 	bne	r7,r2,8112a79c <_dtoa_r+0x1630>
8112948c:	00800044 	movi	r2,1
81129490:	d8800b15 	stw	r2,44(sp)
81129494:	d8c00517 	ldw	r3,20(sp)
81129498:	d9002217 	ldw	r4,136(sp)
8112949c:	1907883a 	add	r3,r3,r4
811294a0:	19800044 	addi	r6,r3,1
811294a4:	d8c00c15 	stw	r3,48(sp)
811294a8:	d9800615 	stw	r6,24(sp)
811294ac:	0183a40e 	bge	zero,r6,8112a340 <_dtoa_r+0x11d4>
811294b0:	d9800617 	ldw	r6,24(sp)
811294b4:	3021883a 	mov	r16,r6
811294b8:	e0001115 	stw	zero,68(fp)
811294bc:	008005c4 	movi	r2,23
811294c0:	1184c92e 	bgeu	r2,r6,8112a7e8 <_dtoa_r+0x167c>
811294c4:	00c00044 	movi	r3,1
811294c8:	00800104 	movi	r2,4
811294cc:	1085883a 	add	r2,r2,r2
811294d0:	11000504 	addi	r4,r2,20
811294d4:	180b883a 	mov	r5,r3
811294d8:	18c00044 	addi	r3,r3,1
811294dc:	313ffb2e 	bgeu	r6,r4,811294cc <__reset+0xfb1094cc>
811294e0:	e1401115 	stw	r5,68(fp)
811294e4:	e009883a 	mov	r4,fp
811294e8:	112c2840 	call	8112c284 <_Balloc>
811294ec:	d8800715 	stw	r2,28(sp)
811294f0:	e0801015 	stw	r2,64(fp)
811294f4:	00800384 	movi	r2,14
811294f8:	1400f736 	bltu	r2,r16,811298d8 <_dtoa_r+0x76c>
811294fc:	8800f626 	beq	r17,zero,811298d8 <_dtoa_r+0x76c>
81129500:	d9c00517 	ldw	r7,20(sp)
81129504:	01c39a0e 	bge	zero,r7,8112a370 <_dtoa_r+0x1204>
81129508:	388003cc 	andi	r2,r7,15
8112950c:	100490fa 	slli	r2,r2,3
81129510:	382bd13a 	srai	r21,r7,4
81129514:	00e04574 	movhi	r3,33045
81129518:	18c14904 	addi	r3,r3,1316
8112951c:	1885883a 	add	r2,r3,r2
81129520:	a8c0040c 	andi	r3,r21,16
81129524:	12400017 	ldw	r9,0(r2)
81129528:	12000117 	ldw	r8,4(r2)
8112952c:	18037926 	beq	r3,zero,8112a314 <_dtoa_r+0x11a8>
81129530:	00a04574 	movhi	r2,33045
81129534:	10813f04 	addi	r2,r2,1276
81129538:	11800817 	ldw	r6,32(r2)
8112953c:	11c00917 	ldw	r7,36(r2)
81129540:	9009883a 	mov	r4,r18
81129544:	980b883a 	mov	r5,r19
81129548:	da001715 	stw	r8,92(sp)
8112954c:	da401615 	stw	r9,88(sp)
81129550:	113512c0 	call	8113512c <__divdf3>
81129554:	da001717 	ldw	r8,92(sp)
81129558:	da401617 	ldw	r9,88(sp)
8112955c:	ad4003cc 	andi	r21,r21,15
81129560:	040000c4 	movi	r16,3
81129564:	1023883a 	mov	r17,r2
81129568:	1829883a 	mov	r20,r3
8112956c:	a8001126 	beq	r21,zero,811295b4 <_dtoa_r+0x448>
81129570:	05e04574 	movhi	r23,33045
81129574:	bdc13f04 	addi	r23,r23,1276
81129578:	4805883a 	mov	r2,r9
8112957c:	4007883a 	mov	r3,r8
81129580:	a980004c 	andi	r6,r21,1
81129584:	1009883a 	mov	r4,r2
81129588:	a82bd07a 	srai	r21,r21,1
8112958c:	180b883a 	mov	r5,r3
81129590:	30000426 	beq	r6,zero,811295a4 <_dtoa_r+0x438>
81129594:	b9800017 	ldw	r6,0(r23)
81129598:	b9c00117 	ldw	r7,4(r23)
8112959c:	84000044 	addi	r16,r16,1
811295a0:	111f99c0 	call	8111f99c <__muldf3>
811295a4:	bdc00204 	addi	r23,r23,8
811295a8:	a83ff51e 	bne	r21,zero,81129580 <__reset+0xfb109580>
811295ac:	1013883a 	mov	r9,r2
811295b0:	1811883a 	mov	r8,r3
811295b4:	480d883a 	mov	r6,r9
811295b8:	400f883a 	mov	r7,r8
811295bc:	8809883a 	mov	r4,r17
811295c0:	a00b883a 	mov	r5,r20
811295c4:	113512c0 	call	8113512c <__divdf3>
811295c8:	d8800f15 	stw	r2,60(sp)
811295cc:	d8c01015 	stw	r3,64(sp)
811295d0:	d8c00e17 	ldw	r3,56(sp)
811295d4:	18000626 	beq	r3,zero,811295f0 <_dtoa_r+0x484>
811295d8:	d9000f17 	ldw	r4,60(sp)
811295dc:	d9401017 	ldw	r5,64(sp)
811295e0:	000d883a 	mov	r6,zero
811295e4:	01cffc34 	movhi	r7,16368
811295e8:	1135aa40 	call	81135aa4 <__ledf2>
811295ec:	10040b16 	blt	r2,zero,8112a61c <_dtoa_r+0x14b0>
811295f0:	8009883a 	mov	r4,r16
811295f4:	1120a400 	call	81120a40 <__floatsidf>
811295f8:	d9800f17 	ldw	r6,60(sp)
811295fc:	d9c01017 	ldw	r7,64(sp)
81129600:	1009883a 	mov	r4,r2
81129604:	180b883a 	mov	r5,r3
81129608:	111f99c0 	call	8111f99c <__muldf3>
8112960c:	000d883a 	mov	r6,zero
81129610:	01d00734 	movhi	r7,16412
81129614:	1009883a 	mov	r4,r2
81129618:	180b883a 	mov	r5,r3
8112961c:	11348780 	call	81134878 <__adddf3>
81129620:	1021883a 	mov	r16,r2
81129624:	d8800617 	ldw	r2,24(sp)
81129628:	047f3034 	movhi	r17,64704
8112962c:	1c63883a 	add	r17,r3,r17
81129630:	10031826 	beq	r2,zero,8112a294 <_dtoa_r+0x1128>
81129634:	d8c00517 	ldw	r3,20(sp)
81129638:	db000617 	ldw	r12,24(sp)
8112963c:	d8c01315 	stw	r3,76(sp)
81129640:	d9000b17 	ldw	r4,44(sp)
81129644:	20038f26 	beq	r4,zero,8112a484 <_dtoa_r+0x1318>
81129648:	60bfffc4 	addi	r2,r12,-1
8112964c:	100490fa 	slli	r2,r2,3
81129650:	00e04574 	movhi	r3,33045
81129654:	18c14904 	addi	r3,r3,1316
81129658:	1885883a 	add	r2,r3,r2
8112965c:	11800017 	ldw	r6,0(r2)
81129660:	11c00117 	ldw	r7,4(r2)
81129664:	d8800717 	ldw	r2,28(sp)
81129668:	0009883a 	mov	r4,zero
8112966c:	014ff834 	movhi	r5,16352
81129670:	db001615 	stw	r12,88(sp)
81129674:	15c00044 	addi	r23,r2,1
81129678:	113512c0 	call	8113512c <__divdf3>
8112967c:	800d883a 	mov	r6,r16
81129680:	880f883a 	mov	r7,r17
81129684:	1009883a 	mov	r4,r2
81129688:	180b883a 	mov	r5,r3
8112968c:	11200bc0 	call	811200bc <__subdf3>
81129690:	d9401017 	ldw	r5,64(sp)
81129694:	d9000f17 	ldw	r4,60(sp)
81129698:	102b883a 	mov	r21,r2
8112969c:	d8c01215 	stw	r3,72(sp)
811296a0:	11209c00 	call	811209c0 <__fixdfsi>
811296a4:	1009883a 	mov	r4,r2
811296a8:	1029883a 	mov	r20,r2
811296ac:	1120a400 	call	81120a40 <__floatsidf>
811296b0:	d9000f17 	ldw	r4,60(sp)
811296b4:	d9401017 	ldw	r5,64(sp)
811296b8:	100d883a 	mov	r6,r2
811296bc:	180f883a 	mov	r7,r3
811296c0:	11200bc0 	call	811200bc <__subdf3>
811296c4:	1823883a 	mov	r17,r3
811296c8:	d8c00717 	ldw	r3,28(sp)
811296cc:	d9401217 	ldw	r5,72(sp)
811296d0:	a2000c04 	addi	r8,r20,48
811296d4:	1021883a 	mov	r16,r2
811296d8:	1a000005 	stb	r8,0(r3)
811296dc:	800d883a 	mov	r6,r16
811296e0:	880f883a 	mov	r7,r17
811296e4:	a809883a 	mov	r4,r21
811296e8:	4029883a 	mov	r20,r8
811296ec:	111f8c00 	call	8111f8c0 <__gedf2>
811296f0:	00841d16 	blt	zero,r2,8112a768 <_dtoa_r+0x15fc>
811296f4:	800d883a 	mov	r6,r16
811296f8:	880f883a 	mov	r7,r17
811296fc:	0009883a 	mov	r4,zero
81129700:	014ffc34 	movhi	r5,16368
81129704:	11200bc0 	call	811200bc <__subdf3>
81129708:	d9401217 	ldw	r5,72(sp)
8112970c:	100d883a 	mov	r6,r2
81129710:	180f883a 	mov	r7,r3
81129714:	a809883a 	mov	r4,r21
81129718:	111f8c00 	call	8111f8c0 <__gedf2>
8112971c:	db001617 	ldw	r12,88(sp)
81129720:	00840e16 	blt	zero,r2,8112a75c <_dtoa_r+0x15f0>
81129724:	00800044 	movi	r2,1
81129728:	13006b0e 	bge	r2,r12,811298d8 <_dtoa_r+0x76c>
8112972c:	d9000717 	ldw	r4,28(sp)
81129730:	dd800f15 	stw	r22,60(sp)
81129734:	dcc01015 	stw	r19,64(sp)
81129738:	2319883a 	add	r12,r4,r12
8112973c:	dcc01217 	ldw	r19,72(sp)
81129740:	602d883a 	mov	r22,r12
81129744:	dc801215 	stw	r18,72(sp)
81129748:	b825883a 	mov	r18,r23
8112974c:	00000906 	br	81129774 <_dtoa_r+0x608>
81129750:	11200bc0 	call	811200bc <__subdf3>
81129754:	a80d883a 	mov	r6,r21
81129758:	980f883a 	mov	r7,r19
8112975c:	1009883a 	mov	r4,r2
81129760:	180b883a 	mov	r5,r3
81129764:	1135aa40 	call	81135aa4 <__ledf2>
81129768:	1003e816 	blt	r2,zero,8112a70c <_dtoa_r+0x15a0>
8112976c:	b825883a 	mov	r18,r23
81129770:	bd83e926 	beq	r23,r22,8112a718 <_dtoa_r+0x15ac>
81129774:	a809883a 	mov	r4,r21
81129778:	980b883a 	mov	r5,r19
8112977c:	000d883a 	mov	r6,zero
81129780:	01d00934 	movhi	r7,16420
81129784:	111f99c0 	call	8111f99c <__muldf3>
81129788:	000d883a 	mov	r6,zero
8112978c:	01d00934 	movhi	r7,16420
81129790:	8009883a 	mov	r4,r16
81129794:	880b883a 	mov	r5,r17
81129798:	102b883a 	mov	r21,r2
8112979c:	1827883a 	mov	r19,r3
811297a0:	111f99c0 	call	8111f99c <__muldf3>
811297a4:	180b883a 	mov	r5,r3
811297a8:	1009883a 	mov	r4,r2
811297ac:	1821883a 	mov	r16,r3
811297b0:	1023883a 	mov	r17,r2
811297b4:	11209c00 	call	811209c0 <__fixdfsi>
811297b8:	1009883a 	mov	r4,r2
811297bc:	1029883a 	mov	r20,r2
811297c0:	1120a400 	call	81120a40 <__floatsidf>
811297c4:	8809883a 	mov	r4,r17
811297c8:	800b883a 	mov	r5,r16
811297cc:	100d883a 	mov	r6,r2
811297d0:	180f883a 	mov	r7,r3
811297d4:	11200bc0 	call	811200bc <__subdf3>
811297d8:	a5000c04 	addi	r20,r20,48
811297dc:	a80d883a 	mov	r6,r21
811297e0:	980f883a 	mov	r7,r19
811297e4:	1009883a 	mov	r4,r2
811297e8:	180b883a 	mov	r5,r3
811297ec:	95000005 	stb	r20,0(r18)
811297f0:	1021883a 	mov	r16,r2
811297f4:	1823883a 	mov	r17,r3
811297f8:	1135aa40 	call	81135aa4 <__ledf2>
811297fc:	bdc00044 	addi	r23,r23,1
81129800:	800d883a 	mov	r6,r16
81129804:	880f883a 	mov	r7,r17
81129808:	0009883a 	mov	r4,zero
8112980c:	014ffc34 	movhi	r5,16368
81129810:	103fcf0e 	bge	r2,zero,81129750 <__reset+0xfb109750>
81129814:	d8c01317 	ldw	r3,76(sp)
81129818:	d8c00515 	stw	r3,20(sp)
8112981c:	d9400917 	ldw	r5,36(sp)
81129820:	e009883a 	mov	r4,fp
81129824:	112c3340 	call	8112c334 <_Bfree>
81129828:	d9000517 	ldw	r4,20(sp)
8112982c:	d9802317 	ldw	r6,140(sp)
81129830:	d9c02517 	ldw	r7,148(sp)
81129834:	b8000005 	stb	zero,0(r23)
81129838:	20800044 	addi	r2,r4,1
8112983c:	30800015 	stw	r2,0(r6)
81129840:	3802aa26 	beq	r7,zero,8112a2ec <_dtoa_r+0x1180>
81129844:	3dc00015 	stw	r23,0(r7)
81129848:	d8800717 	ldw	r2,28(sp)
8112984c:	003e7906 	br	81129234 <__reset+0xfb109234>
81129850:	00800434 	movhi	r2,16
81129854:	10bfffc4 	addi	r2,r2,-1
81129858:	88a2703a 	and	r17,r17,r2
8112985c:	883e851e 	bne	r17,zero,81129274 <__reset+0xfb109274>
81129860:	00a04574 	movhi	r2,33045
81129864:	10812b04 	addi	r2,r2,1196
81129868:	003e8406 	br	8112927c <__reset+0xfb10927c>
8112986c:	10c00204 	addi	r3,r2,8
81129870:	003e8706 	br	81129290 <__reset+0xfb109290>
81129874:	01400434 	movhi	r5,16
81129878:	297fffc4 	addi	r5,r5,-1
8112987c:	994a703a 	and	r5,r19,r5
81129880:	9009883a 	mov	r4,r18
81129884:	843f0044 	addi	r16,r16,-1023
81129888:	294ffc34 	orhi	r5,r5,16368
8112988c:	dd800217 	ldw	r22,8(sp)
81129890:	d8001115 	stw	zero,68(sp)
81129894:	003ea506 	br	8112932c <__reset+0xfb10932c>
81129898:	00a04574 	movhi	r2,33045
8112989c:	10811004 	addi	r2,r2,1088
811298a0:	003e6406 	br	81129234 <__reset+0xfb109234>
811298a4:	e0001115 	stw	zero,68(fp)
811298a8:	000b883a 	mov	r5,zero
811298ac:	e009883a 	mov	r4,fp
811298b0:	112c2840 	call	8112c284 <_Balloc>
811298b4:	01bfffc4 	movi	r6,-1
811298b8:	01c00044 	movi	r7,1
811298bc:	d8800715 	stw	r2,28(sp)
811298c0:	d9800c15 	stw	r6,48(sp)
811298c4:	e0801015 	stw	r2,64(fp)
811298c8:	d8000315 	stw	zero,12(sp)
811298cc:	d9c00b15 	stw	r7,44(sp)
811298d0:	d9800615 	stw	r6,24(sp)
811298d4:	d8002215 	stw	zero,136(sp)
811298d8:	d8800117 	ldw	r2,4(sp)
811298dc:	10008916 	blt	r2,zero,81129b04 <_dtoa_r+0x998>
811298e0:	d9000517 	ldw	r4,20(sp)
811298e4:	00c00384 	movi	r3,14
811298e8:	19008616 	blt	r3,r4,81129b04 <_dtoa_r+0x998>
811298ec:	200490fa 	slli	r2,r4,3
811298f0:	00e04574 	movhi	r3,33045
811298f4:	d9802217 	ldw	r6,136(sp)
811298f8:	18c14904 	addi	r3,r3,1316
811298fc:	1885883a 	add	r2,r3,r2
81129900:	14000017 	ldw	r16,0(r2)
81129904:	14400117 	ldw	r17,4(r2)
81129908:	30016316 	blt	r6,zero,81129e98 <_dtoa_r+0xd2c>
8112990c:	800d883a 	mov	r6,r16
81129910:	880f883a 	mov	r7,r17
81129914:	9009883a 	mov	r4,r18
81129918:	980b883a 	mov	r5,r19
8112991c:	113512c0 	call	8113512c <__divdf3>
81129920:	180b883a 	mov	r5,r3
81129924:	1009883a 	mov	r4,r2
81129928:	11209c00 	call	811209c0 <__fixdfsi>
8112992c:	1009883a 	mov	r4,r2
81129930:	102b883a 	mov	r21,r2
81129934:	1120a400 	call	81120a40 <__floatsidf>
81129938:	800d883a 	mov	r6,r16
8112993c:	880f883a 	mov	r7,r17
81129940:	1009883a 	mov	r4,r2
81129944:	180b883a 	mov	r5,r3
81129948:	111f99c0 	call	8111f99c <__muldf3>
8112994c:	100d883a 	mov	r6,r2
81129950:	180f883a 	mov	r7,r3
81129954:	9009883a 	mov	r4,r18
81129958:	980b883a 	mov	r5,r19
8112995c:	11200bc0 	call	811200bc <__subdf3>
81129960:	d9c00717 	ldw	r7,28(sp)
81129964:	1009883a 	mov	r4,r2
81129968:	a8800c04 	addi	r2,r21,48
8112996c:	38800005 	stb	r2,0(r7)
81129970:	3dc00044 	addi	r23,r7,1
81129974:	d9c00617 	ldw	r7,24(sp)
81129978:	01800044 	movi	r6,1
8112997c:	180b883a 	mov	r5,r3
81129980:	2005883a 	mov	r2,r4
81129984:	39803826 	beq	r7,r6,81129a68 <_dtoa_r+0x8fc>
81129988:	000d883a 	mov	r6,zero
8112998c:	01d00934 	movhi	r7,16420
81129990:	111f99c0 	call	8111f99c <__muldf3>
81129994:	000d883a 	mov	r6,zero
81129998:	000f883a 	mov	r7,zero
8112999c:	1009883a 	mov	r4,r2
811299a0:	180b883a 	mov	r5,r3
811299a4:	1025883a 	mov	r18,r2
811299a8:	1827883a 	mov	r19,r3
811299ac:	1135a1c0 	call	81135a1c <__eqdf2>
811299b0:	103f9a26 	beq	r2,zero,8112981c <__reset+0xfb10981c>
811299b4:	d9c00617 	ldw	r7,24(sp)
811299b8:	d8c00717 	ldw	r3,28(sp)
811299bc:	b829883a 	mov	r20,r23
811299c0:	38bfffc4 	addi	r2,r7,-1
811299c4:	18ad883a 	add	r22,r3,r2
811299c8:	00000a06 	br	811299f4 <_dtoa_r+0x888>
811299cc:	111f99c0 	call	8111f99c <__muldf3>
811299d0:	000d883a 	mov	r6,zero
811299d4:	000f883a 	mov	r7,zero
811299d8:	1009883a 	mov	r4,r2
811299dc:	180b883a 	mov	r5,r3
811299e0:	1025883a 	mov	r18,r2
811299e4:	1827883a 	mov	r19,r3
811299e8:	b829883a 	mov	r20,r23
811299ec:	1135a1c0 	call	81135a1c <__eqdf2>
811299f0:	103f8a26 	beq	r2,zero,8112981c <__reset+0xfb10981c>
811299f4:	800d883a 	mov	r6,r16
811299f8:	880f883a 	mov	r7,r17
811299fc:	9009883a 	mov	r4,r18
81129a00:	980b883a 	mov	r5,r19
81129a04:	113512c0 	call	8113512c <__divdf3>
81129a08:	180b883a 	mov	r5,r3
81129a0c:	1009883a 	mov	r4,r2
81129a10:	11209c00 	call	811209c0 <__fixdfsi>
81129a14:	1009883a 	mov	r4,r2
81129a18:	102b883a 	mov	r21,r2
81129a1c:	1120a400 	call	81120a40 <__floatsidf>
81129a20:	800d883a 	mov	r6,r16
81129a24:	880f883a 	mov	r7,r17
81129a28:	1009883a 	mov	r4,r2
81129a2c:	180b883a 	mov	r5,r3
81129a30:	111f99c0 	call	8111f99c <__muldf3>
81129a34:	100d883a 	mov	r6,r2
81129a38:	180f883a 	mov	r7,r3
81129a3c:	9009883a 	mov	r4,r18
81129a40:	980b883a 	mov	r5,r19
81129a44:	11200bc0 	call	811200bc <__subdf3>
81129a48:	aa000c04 	addi	r8,r21,48
81129a4c:	a2000005 	stb	r8,0(r20)
81129a50:	000d883a 	mov	r6,zero
81129a54:	01d00934 	movhi	r7,16420
81129a58:	1009883a 	mov	r4,r2
81129a5c:	180b883a 	mov	r5,r3
81129a60:	a5c00044 	addi	r23,r20,1
81129a64:	b53fd91e 	bne	r22,r20,811299cc <__reset+0xfb1099cc>
81129a68:	100d883a 	mov	r6,r2
81129a6c:	180f883a 	mov	r7,r3
81129a70:	1009883a 	mov	r4,r2
81129a74:	180b883a 	mov	r5,r3
81129a78:	11348780 	call	81134878 <__adddf3>
81129a7c:	100d883a 	mov	r6,r2
81129a80:	180f883a 	mov	r7,r3
81129a84:	8009883a 	mov	r4,r16
81129a88:	880b883a 	mov	r5,r17
81129a8c:	1027883a 	mov	r19,r2
81129a90:	1825883a 	mov	r18,r3
81129a94:	1135aa40 	call	81135aa4 <__ledf2>
81129a98:	10000816 	blt	r2,zero,81129abc <_dtoa_r+0x950>
81129a9c:	980d883a 	mov	r6,r19
81129aa0:	900f883a 	mov	r7,r18
81129aa4:	8009883a 	mov	r4,r16
81129aa8:	880b883a 	mov	r5,r17
81129aac:	1135a1c0 	call	81135a1c <__eqdf2>
81129ab0:	103f5a1e 	bne	r2,zero,8112981c <__reset+0xfb10981c>
81129ab4:	ad40004c 	andi	r21,r21,1
81129ab8:	a83f5826 	beq	r21,zero,8112981c <__reset+0xfb10981c>
81129abc:	bd3fffc3 	ldbu	r20,-1(r23)
81129ac0:	b8bfffc4 	addi	r2,r23,-1
81129ac4:	1007883a 	mov	r3,r2
81129ac8:	01400e44 	movi	r5,57
81129acc:	d9800717 	ldw	r6,28(sp)
81129ad0:	00000506 	br	81129ae8 <_dtoa_r+0x97c>
81129ad4:	18ffffc4 	addi	r3,r3,-1
81129ad8:	11824726 	beq	r2,r6,8112a3f8 <_dtoa_r+0x128c>
81129adc:	1d000003 	ldbu	r20,0(r3)
81129ae0:	102f883a 	mov	r23,r2
81129ae4:	10bfffc4 	addi	r2,r2,-1
81129ae8:	a1003fcc 	andi	r4,r20,255
81129aec:	2100201c 	xori	r4,r4,128
81129af0:	213fe004 	addi	r4,r4,-128
81129af4:	217ff726 	beq	r4,r5,81129ad4 <__reset+0xfb109ad4>
81129af8:	a2000044 	addi	r8,r20,1
81129afc:	12000005 	stb	r8,0(r2)
81129b00:	003f4606 	br	8112981c <__reset+0xfb10981c>
81129b04:	d9000b17 	ldw	r4,44(sp)
81129b08:	2000c826 	beq	r4,zero,81129e2c <_dtoa_r+0xcc0>
81129b0c:	d9800317 	ldw	r6,12(sp)
81129b10:	00c00044 	movi	r3,1
81129b14:	1980f90e 	bge	r3,r6,81129efc <_dtoa_r+0xd90>
81129b18:	d8800617 	ldw	r2,24(sp)
81129b1c:	d8c00a17 	ldw	r3,40(sp)
81129b20:	157fffc4 	addi	r21,r2,-1
81129b24:	1d41f316 	blt	r3,r21,8112a2f4 <_dtoa_r+0x1188>
81129b28:	1d6bc83a 	sub	r21,r3,r21
81129b2c:	d9c00617 	ldw	r7,24(sp)
81129b30:	3802aa16 	blt	r7,zero,8112a5dc <_dtoa_r+0x1470>
81129b34:	dd000817 	ldw	r20,32(sp)
81129b38:	d8800617 	ldw	r2,24(sp)
81129b3c:	d8c00817 	ldw	r3,32(sp)
81129b40:	01400044 	movi	r5,1
81129b44:	e009883a 	mov	r4,fp
81129b48:	1887883a 	add	r3,r3,r2
81129b4c:	d8c00815 	stw	r3,32(sp)
81129b50:	b0ad883a 	add	r22,r22,r2
81129b54:	112c6a80 	call	8112c6a8 <__i2b>
81129b58:	1023883a 	mov	r17,r2
81129b5c:	a0000826 	beq	r20,zero,81129b80 <_dtoa_r+0xa14>
81129b60:	0580070e 	bge	zero,r22,81129b80 <_dtoa_r+0xa14>
81129b64:	a005883a 	mov	r2,r20
81129b68:	b500b916 	blt	r22,r20,81129e50 <_dtoa_r+0xce4>
81129b6c:	d9000817 	ldw	r4,32(sp)
81129b70:	a0a9c83a 	sub	r20,r20,r2
81129b74:	b0adc83a 	sub	r22,r22,r2
81129b78:	2089c83a 	sub	r4,r4,r2
81129b7c:	d9000815 	stw	r4,32(sp)
81129b80:	d9800a17 	ldw	r6,40(sp)
81129b84:	0181810e 	bge	zero,r6,8112a18c <_dtoa_r+0x1020>
81129b88:	d9c00b17 	ldw	r7,44(sp)
81129b8c:	3800b326 	beq	r7,zero,81129e5c <_dtoa_r+0xcf0>
81129b90:	a800b226 	beq	r21,zero,81129e5c <_dtoa_r+0xcf0>
81129b94:	880b883a 	mov	r5,r17
81129b98:	a80d883a 	mov	r6,r21
81129b9c:	e009883a 	mov	r4,fp
81129ba0:	112c8ec0 	call	8112c8ec <__pow5mult>
81129ba4:	d9800917 	ldw	r6,36(sp)
81129ba8:	100b883a 	mov	r5,r2
81129bac:	e009883a 	mov	r4,fp
81129bb0:	1023883a 	mov	r17,r2
81129bb4:	112c6ec0 	call	8112c6ec <__multiply>
81129bb8:	1021883a 	mov	r16,r2
81129bbc:	d8800a17 	ldw	r2,40(sp)
81129bc0:	d9400917 	ldw	r5,36(sp)
81129bc4:	e009883a 	mov	r4,fp
81129bc8:	1545c83a 	sub	r2,r2,r21
81129bcc:	d8800a15 	stw	r2,40(sp)
81129bd0:	112c3340 	call	8112c334 <_Bfree>
81129bd4:	d8c00a17 	ldw	r3,40(sp)
81129bd8:	18009f1e 	bne	r3,zero,81129e58 <_dtoa_r+0xcec>
81129bdc:	05c00044 	movi	r23,1
81129be0:	e009883a 	mov	r4,fp
81129be4:	b80b883a 	mov	r5,r23
81129be8:	112c6a80 	call	8112c6a8 <__i2b>
81129bec:	d9000d17 	ldw	r4,52(sp)
81129bf0:	102b883a 	mov	r21,r2
81129bf4:	2000ce26 	beq	r4,zero,81129f30 <_dtoa_r+0xdc4>
81129bf8:	200d883a 	mov	r6,r4
81129bfc:	100b883a 	mov	r5,r2
81129c00:	e009883a 	mov	r4,fp
81129c04:	112c8ec0 	call	8112c8ec <__pow5mult>
81129c08:	d9800317 	ldw	r6,12(sp)
81129c0c:	102b883a 	mov	r21,r2
81129c10:	b981810e 	bge	r23,r6,8112a218 <_dtoa_r+0x10ac>
81129c14:	0027883a 	mov	r19,zero
81129c18:	a8800417 	ldw	r2,16(r21)
81129c1c:	05c00804 	movi	r23,32
81129c20:	10800104 	addi	r2,r2,4
81129c24:	1085883a 	add	r2,r2,r2
81129c28:	1085883a 	add	r2,r2,r2
81129c2c:	a885883a 	add	r2,r21,r2
81129c30:	11000017 	ldw	r4,0(r2)
81129c34:	112c5900 	call	8112c590 <__hi0bits>
81129c38:	b885c83a 	sub	r2,r23,r2
81129c3c:	1585883a 	add	r2,r2,r22
81129c40:	108007cc 	andi	r2,r2,31
81129c44:	1000b326 	beq	r2,zero,81129f14 <_dtoa_r+0xda8>
81129c48:	00c00804 	movi	r3,32
81129c4c:	1887c83a 	sub	r3,r3,r2
81129c50:	01000104 	movi	r4,4
81129c54:	20c2cd0e 	bge	r4,r3,8112a78c <_dtoa_r+0x1620>
81129c58:	00c00704 	movi	r3,28
81129c5c:	1885c83a 	sub	r2,r3,r2
81129c60:	d8c00817 	ldw	r3,32(sp)
81129c64:	a0a9883a 	add	r20,r20,r2
81129c68:	b0ad883a 	add	r22,r22,r2
81129c6c:	1887883a 	add	r3,r3,r2
81129c70:	d8c00815 	stw	r3,32(sp)
81129c74:	d9800817 	ldw	r6,32(sp)
81129c78:	0180040e 	bge	zero,r6,81129c8c <_dtoa_r+0xb20>
81129c7c:	800b883a 	mov	r5,r16
81129c80:	e009883a 	mov	r4,fp
81129c84:	112ca340 	call	8112ca34 <__lshift>
81129c88:	1021883a 	mov	r16,r2
81129c8c:	0580050e 	bge	zero,r22,81129ca4 <_dtoa_r+0xb38>
81129c90:	a80b883a 	mov	r5,r21
81129c94:	b00d883a 	mov	r6,r22
81129c98:	e009883a 	mov	r4,fp
81129c9c:	112ca340 	call	8112ca34 <__lshift>
81129ca0:	102b883a 	mov	r21,r2
81129ca4:	d9c00e17 	ldw	r7,56(sp)
81129ca8:	3801211e 	bne	r7,zero,8112a130 <_dtoa_r+0xfc4>
81129cac:	d9800617 	ldw	r6,24(sp)
81129cb0:	0181380e 	bge	zero,r6,8112a194 <_dtoa_r+0x1028>
81129cb4:	d8c00b17 	ldw	r3,44(sp)
81129cb8:	1800ab1e 	bne	r3,zero,81129f68 <_dtoa_r+0xdfc>
81129cbc:	dc800717 	ldw	r18,28(sp)
81129cc0:	dcc00617 	ldw	r19,24(sp)
81129cc4:	9029883a 	mov	r20,r18
81129cc8:	00000206 	br	81129cd4 <_dtoa_r+0xb68>
81129ccc:	112c35c0 	call	8112c35c <__multadd>
81129cd0:	1021883a 	mov	r16,r2
81129cd4:	a80b883a 	mov	r5,r21
81129cd8:	8009883a 	mov	r4,r16
81129cdc:	1128f640 	call	81128f64 <quorem>
81129ce0:	10800c04 	addi	r2,r2,48
81129ce4:	90800005 	stb	r2,0(r18)
81129ce8:	94800044 	addi	r18,r18,1
81129cec:	9507c83a 	sub	r3,r18,r20
81129cf0:	000f883a 	mov	r7,zero
81129cf4:	01800284 	movi	r6,10
81129cf8:	800b883a 	mov	r5,r16
81129cfc:	e009883a 	mov	r4,fp
81129d00:	1cfff216 	blt	r3,r19,81129ccc <__reset+0xfb109ccc>
81129d04:	1011883a 	mov	r8,r2
81129d08:	d8800617 	ldw	r2,24(sp)
81129d0c:	0082370e 	bge	zero,r2,8112a5ec <_dtoa_r+0x1480>
81129d10:	d9000717 	ldw	r4,28(sp)
81129d14:	0025883a 	mov	r18,zero
81129d18:	20af883a 	add	r23,r4,r2
81129d1c:	01800044 	movi	r6,1
81129d20:	800b883a 	mov	r5,r16
81129d24:	e009883a 	mov	r4,fp
81129d28:	da001715 	stw	r8,92(sp)
81129d2c:	112ca340 	call	8112ca34 <__lshift>
81129d30:	a80b883a 	mov	r5,r21
81129d34:	1009883a 	mov	r4,r2
81129d38:	d8800915 	stw	r2,36(sp)
81129d3c:	112cb840 	call	8112cb84 <__mcmp>
81129d40:	da001717 	ldw	r8,92(sp)
81129d44:	0081800e 	bge	zero,r2,8112a348 <_dtoa_r+0x11dc>
81129d48:	b93fffc3 	ldbu	r4,-1(r23)
81129d4c:	b8bfffc4 	addi	r2,r23,-1
81129d50:	1007883a 	mov	r3,r2
81129d54:	01800e44 	movi	r6,57
81129d58:	d9c00717 	ldw	r7,28(sp)
81129d5c:	00000506 	br	81129d74 <_dtoa_r+0xc08>
81129d60:	18ffffc4 	addi	r3,r3,-1
81129d64:	11c12326 	beq	r2,r7,8112a1f4 <_dtoa_r+0x1088>
81129d68:	19000003 	ldbu	r4,0(r3)
81129d6c:	102f883a 	mov	r23,r2
81129d70:	10bfffc4 	addi	r2,r2,-1
81129d74:	21403fcc 	andi	r5,r4,255
81129d78:	2940201c 	xori	r5,r5,128
81129d7c:	297fe004 	addi	r5,r5,-128
81129d80:	29bff726 	beq	r5,r6,81129d60 <__reset+0xfb109d60>
81129d84:	21000044 	addi	r4,r4,1
81129d88:	11000005 	stb	r4,0(r2)
81129d8c:	a80b883a 	mov	r5,r21
81129d90:	e009883a 	mov	r4,fp
81129d94:	112c3340 	call	8112c334 <_Bfree>
81129d98:	883ea026 	beq	r17,zero,8112981c <__reset+0xfb10981c>
81129d9c:	90000426 	beq	r18,zero,81129db0 <_dtoa_r+0xc44>
81129da0:	94400326 	beq	r18,r17,81129db0 <_dtoa_r+0xc44>
81129da4:	900b883a 	mov	r5,r18
81129da8:	e009883a 	mov	r4,fp
81129dac:	112c3340 	call	8112c334 <_Bfree>
81129db0:	880b883a 	mov	r5,r17
81129db4:	e009883a 	mov	r4,fp
81129db8:	112c3340 	call	8112c334 <_Bfree>
81129dbc:	003e9706 	br	8112981c <__reset+0xfb10981c>
81129dc0:	01800044 	movi	r6,1
81129dc4:	d9800e15 	stw	r6,56(sp)
81129dc8:	003d9606 	br	81129424 <__reset+0xfb109424>
81129dcc:	d8800817 	ldw	r2,32(sp)
81129dd0:	d8c00517 	ldw	r3,20(sp)
81129dd4:	d8000d15 	stw	zero,52(sp)
81129dd8:	10c5c83a 	sub	r2,r2,r3
81129ddc:	00c9c83a 	sub	r4,zero,r3
81129de0:	d8800815 	stw	r2,32(sp)
81129de4:	d9000a15 	stw	r4,40(sp)
81129de8:	003d9706 	br	81129448 <__reset+0xfb109448>
81129dec:	05adc83a 	sub	r22,zero,r22
81129df0:	dd800815 	stw	r22,32(sp)
81129df4:	002d883a 	mov	r22,zero
81129df8:	003d8e06 	br	81129434 <__reset+0xfb109434>
81129dfc:	d9000517 	ldw	r4,20(sp)
81129e00:	1120a400 	call	81120a40 <__floatsidf>
81129e04:	100d883a 	mov	r6,r2
81129e08:	180f883a 	mov	r7,r3
81129e0c:	a009883a 	mov	r4,r20
81129e10:	880b883a 	mov	r5,r17
81129e14:	1135a1c0 	call	81135a1c <__eqdf2>
81129e18:	103d7126 	beq	r2,zero,811293e0 <__reset+0xfb1093e0>
81129e1c:	d9c00517 	ldw	r7,20(sp)
81129e20:	39ffffc4 	addi	r7,r7,-1
81129e24:	d9c00515 	stw	r7,20(sp)
81129e28:	003d6d06 	br	811293e0 <__reset+0xfb1093e0>
81129e2c:	dd400a17 	ldw	r21,40(sp)
81129e30:	dd000817 	ldw	r20,32(sp)
81129e34:	0023883a 	mov	r17,zero
81129e38:	003f4806 	br	81129b5c <__reset+0xfb109b5c>
81129e3c:	10e3c83a 	sub	r17,r2,r3
81129e40:	9448983a 	sll	r4,r18,r17
81129e44:	003d3206 	br	81129310 <__reset+0xfb109310>
81129e48:	d8000e15 	stw	zero,56(sp)
81129e4c:	003d7506 	br	81129424 <__reset+0xfb109424>
81129e50:	b005883a 	mov	r2,r22
81129e54:	003f4506 	br	81129b6c <__reset+0xfb109b6c>
81129e58:	dc000915 	stw	r16,36(sp)
81129e5c:	d9800a17 	ldw	r6,40(sp)
81129e60:	d9400917 	ldw	r5,36(sp)
81129e64:	e009883a 	mov	r4,fp
81129e68:	112c8ec0 	call	8112c8ec <__pow5mult>
81129e6c:	1021883a 	mov	r16,r2
81129e70:	003f5a06 	br	81129bdc <__reset+0xfb109bdc>
81129e74:	01c00044 	movi	r7,1
81129e78:	d9c00b15 	stw	r7,44(sp)
81129e7c:	d8802217 	ldw	r2,136(sp)
81129e80:	0081280e 	bge	zero,r2,8112a324 <_dtoa_r+0x11b8>
81129e84:	100d883a 	mov	r6,r2
81129e88:	1021883a 	mov	r16,r2
81129e8c:	d8800c15 	stw	r2,48(sp)
81129e90:	d8800615 	stw	r2,24(sp)
81129e94:	003d8806 	br	811294b8 <__reset+0xfb1094b8>
81129e98:	d8800617 	ldw	r2,24(sp)
81129e9c:	00be9b16 	blt	zero,r2,8112990c <__reset+0xfb10990c>
81129ea0:	10010f1e 	bne	r2,zero,8112a2e0 <_dtoa_r+0x1174>
81129ea4:	880b883a 	mov	r5,r17
81129ea8:	000d883a 	mov	r6,zero
81129eac:	01d00534 	movhi	r7,16404
81129eb0:	8009883a 	mov	r4,r16
81129eb4:	111f99c0 	call	8111f99c <__muldf3>
81129eb8:	900d883a 	mov	r6,r18
81129ebc:	980f883a 	mov	r7,r19
81129ec0:	1009883a 	mov	r4,r2
81129ec4:	180b883a 	mov	r5,r3
81129ec8:	111f8c00 	call	8111f8c0 <__gedf2>
81129ecc:	002b883a 	mov	r21,zero
81129ed0:	0023883a 	mov	r17,zero
81129ed4:	1000bf16 	blt	r2,zero,8112a1d4 <_dtoa_r+0x1068>
81129ed8:	d9802217 	ldw	r6,136(sp)
81129edc:	ddc00717 	ldw	r23,28(sp)
81129ee0:	018c303a 	nor	r6,zero,r6
81129ee4:	d9800515 	stw	r6,20(sp)
81129ee8:	a80b883a 	mov	r5,r21
81129eec:	e009883a 	mov	r4,fp
81129ef0:	112c3340 	call	8112c334 <_Bfree>
81129ef4:	883e4926 	beq	r17,zero,8112981c <__reset+0xfb10981c>
81129ef8:	003fad06 	br	81129db0 <__reset+0xfb109db0>
81129efc:	d9c01117 	ldw	r7,68(sp)
81129f00:	3801bc26 	beq	r7,zero,8112a5f4 <_dtoa_r+0x1488>
81129f04:	10810cc4 	addi	r2,r2,1075
81129f08:	dd400a17 	ldw	r21,40(sp)
81129f0c:	dd000817 	ldw	r20,32(sp)
81129f10:	003f0a06 	br	81129b3c <__reset+0xfb109b3c>
81129f14:	00800704 	movi	r2,28
81129f18:	d9000817 	ldw	r4,32(sp)
81129f1c:	a0a9883a 	add	r20,r20,r2
81129f20:	b0ad883a 	add	r22,r22,r2
81129f24:	2089883a 	add	r4,r4,r2
81129f28:	d9000815 	stw	r4,32(sp)
81129f2c:	003f5106 	br	81129c74 <__reset+0xfb109c74>
81129f30:	d8c00317 	ldw	r3,12(sp)
81129f34:	b8c1fc0e 	bge	r23,r3,8112a728 <_dtoa_r+0x15bc>
81129f38:	0027883a 	mov	r19,zero
81129f3c:	b805883a 	mov	r2,r23
81129f40:	003f3e06 	br	81129c3c <__reset+0xfb109c3c>
81129f44:	880b883a 	mov	r5,r17
81129f48:	e009883a 	mov	r4,fp
81129f4c:	000f883a 	mov	r7,zero
81129f50:	01800284 	movi	r6,10
81129f54:	112c35c0 	call	8112c35c <__multadd>
81129f58:	d9000c17 	ldw	r4,48(sp)
81129f5c:	1023883a 	mov	r17,r2
81129f60:	0102040e 	bge	zero,r4,8112a774 <_dtoa_r+0x1608>
81129f64:	d9000615 	stw	r4,24(sp)
81129f68:	0500050e 	bge	zero,r20,81129f80 <_dtoa_r+0xe14>
81129f6c:	880b883a 	mov	r5,r17
81129f70:	a00d883a 	mov	r6,r20
81129f74:	e009883a 	mov	r4,fp
81129f78:	112ca340 	call	8112ca34 <__lshift>
81129f7c:	1023883a 	mov	r17,r2
81129f80:	9801241e 	bne	r19,zero,8112a414 <_dtoa_r+0x12a8>
81129f84:	8829883a 	mov	r20,r17
81129f88:	d9000617 	ldw	r4,24(sp)
81129f8c:	dcc00717 	ldw	r19,28(sp)
81129f90:	9480004c 	andi	r18,r18,1
81129f94:	20bfffc4 	addi	r2,r4,-1
81129f98:	9885883a 	add	r2,r19,r2
81129f9c:	d8800415 	stw	r2,16(sp)
81129fa0:	dc800615 	stw	r18,24(sp)
81129fa4:	a80b883a 	mov	r5,r21
81129fa8:	8009883a 	mov	r4,r16
81129fac:	1128f640 	call	81128f64 <quorem>
81129fb0:	880b883a 	mov	r5,r17
81129fb4:	8009883a 	mov	r4,r16
81129fb8:	102f883a 	mov	r23,r2
81129fbc:	112cb840 	call	8112cb84 <__mcmp>
81129fc0:	a80b883a 	mov	r5,r21
81129fc4:	a00d883a 	mov	r6,r20
81129fc8:	e009883a 	mov	r4,fp
81129fcc:	102d883a 	mov	r22,r2
81129fd0:	112cbe40 	call	8112cbe4 <__mdiff>
81129fd4:	1007883a 	mov	r3,r2
81129fd8:	10800317 	ldw	r2,12(r2)
81129fdc:	bc800c04 	addi	r18,r23,48
81129fe0:	180b883a 	mov	r5,r3
81129fe4:	10004e1e 	bne	r2,zero,8112a120 <_dtoa_r+0xfb4>
81129fe8:	8009883a 	mov	r4,r16
81129fec:	d8c01615 	stw	r3,88(sp)
81129ff0:	112cb840 	call	8112cb84 <__mcmp>
81129ff4:	d8c01617 	ldw	r3,88(sp)
81129ff8:	e009883a 	mov	r4,fp
81129ffc:	d8801615 	stw	r2,88(sp)
8112a000:	180b883a 	mov	r5,r3
8112a004:	112c3340 	call	8112c334 <_Bfree>
8112a008:	d8801617 	ldw	r2,88(sp)
8112a00c:	1000041e 	bne	r2,zero,8112a020 <_dtoa_r+0xeb4>
8112a010:	d9800317 	ldw	r6,12(sp)
8112a014:	3000021e 	bne	r6,zero,8112a020 <_dtoa_r+0xeb4>
8112a018:	d8c00617 	ldw	r3,24(sp)
8112a01c:	18003726 	beq	r3,zero,8112a0fc <_dtoa_r+0xf90>
8112a020:	b0002016 	blt	r22,zero,8112a0a4 <_dtoa_r+0xf38>
8112a024:	b000041e 	bne	r22,zero,8112a038 <_dtoa_r+0xecc>
8112a028:	d9000317 	ldw	r4,12(sp)
8112a02c:	2000021e 	bne	r4,zero,8112a038 <_dtoa_r+0xecc>
8112a030:	d8c00617 	ldw	r3,24(sp)
8112a034:	18001b26 	beq	r3,zero,8112a0a4 <_dtoa_r+0xf38>
8112a038:	00810716 	blt	zero,r2,8112a458 <_dtoa_r+0x12ec>
8112a03c:	d8c00417 	ldw	r3,16(sp)
8112a040:	9d800044 	addi	r22,r19,1
8112a044:	9c800005 	stb	r18,0(r19)
8112a048:	b02f883a 	mov	r23,r22
8112a04c:	98c10626 	beq	r19,r3,8112a468 <_dtoa_r+0x12fc>
8112a050:	800b883a 	mov	r5,r16
8112a054:	000f883a 	mov	r7,zero
8112a058:	01800284 	movi	r6,10
8112a05c:	e009883a 	mov	r4,fp
8112a060:	112c35c0 	call	8112c35c <__multadd>
8112a064:	1021883a 	mov	r16,r2
8112a068:	000f883a 	mov	r7,zero
8112a06c:	01800284 	movi	r6,10
8112a070:	880b883a 	mov	r5,r17
8112a074:	e009883a 	mov	r4,fp
8112a078:	8d002526 	beq	r17,r20,8112a110 <_dtoa_r+0xfa4>
8112a07c:	112c35c0 	call	8112c35c <__multadd>
8112a080:	a00b883a 	mov	r5,r20
8112a084:	000f883a 	mov	r7,zero
8112a088:	01800284 	movi	r6,10
8112a08c:	e009883a 	mov	r4,fp
8112a090:	1023883a 	mov	r17,r2
8112a094:	112c35c0 	call	8112c35c <__multadd>
8112a098:	1029883a 	mov	r20,r2
8112a09c:	b027883a 	mov	r19,r22
8112a0a0:	003fc006 	br	81129fa4 <__reset+0xfb109fa4>
8112a0a4:	9011883a 	mov	r8,r18
8112a0a8:	00800e0e 	bge	zero,r2,8112a0e4 <_dtoa_r+0xf78>
8112a0ac:	800b883a 	mov	r5,r16
8112a0b0:	01800044 	movi	r6,1
8112a0b4:	e009883a 	mov	r4,fp
8112a0b8:	da001715 	stw	r8,92(sp)
8112a0bc:	112ca340 	call	8112ca34 <__lshift>
8112a0c0:	a80b883a 	mov	r5,r21
8112a0c4:	1009883a 	mov	r4,r2
8112a0c8:	1021883a 	mov	r16,r2
8112a0cc:	112cb840 	call	8112cb84 <__mcmp>
8112a0d0:	da001717 	ldw	r8,92(sp)
8112a0d4:	0081960e 	bge	zero,r2,8112a730 <_dtoa_r+0x15c4>
8112a0d8:	00800e44 	movi	r2,57
8112a0dc:	40817026 	beq	r8,r2,8112a6a0 <_dtoa_r+0x1534>
8112a0e0:	ba000c44 	addi	r8,r23,49
8112a0e4:	8825883a 	mov	r18,r17
8112a0e8:	9dc00044 	addi	r23,r19,1
8112a0ec:	9a000005 	stb	r8,0(r19)
8112a0f0:	a023883a 	mov	r17,r20
8112a0f4:	dc000915 	stw	r16,36(sp)
8112a0f8:	003f2406 	br	81129d8c <__reset+0xfb109d8c>
8112a0fc:	00800e44 	movi	r2,57
8112a100:	9011883a 	mov	r8,r18
8112a104:	90816626 	beq	r18,r2,8112a6a0 <_dtoa_r+0x1534>
8112a108:	05bff516 	blt	zero,r22,8112a0e0 <__reset+0xfb10a0e0>
8112a10c:	003ff506 	br	8112a0e4 <__reset+0xfb10a0e4>
8112a110:	112c35c0 	call	8112c35c <__multadd>
8112a114:	1023883a 	mov	r17,r2
8112a118:	1029883a 	mov	r20,r2
8112a11c:	003fdf06 	br	8112a09c <__reset+0xfb10a09c>
8112a120:	e009883a 	mov	r4,fp
8112a124:	112c3340 	call	8112c334 <_Bfree>
8112a128:	00800044 	movi	r2,1
8112a12c:	003fbc06 	br	8112a020 <__reset+0xfb10a020>
8112a130:	a80b883a 	mov	r5,r21
8112a134:	8009883a 	mov	r4,r16
8112a138:	112cb840 	call	8112cb84 <__mcmp>
8112a13c:	103edb0e 	bge	r2,zero,81129cac <__reset+0xfb109cac>
8112a140:	800b883a 	mov	r5,r16
8112a144:	000f883a 	mov	r7,zero
8112a148:	01800284 	movi	r6,10
8112a14c:	e009883a 	mov	r4,fp
8112a150:	112c35c0 	call	8112c35c <__multadd>
8112a154:	1021883a 	mov	r16,r2
8112a158:	d8800517 	ldw	r2,20(sp)
8112a15c:	d8c00b17 	ldw	r3,44(sp)
8112a160:	10bfffc4 	addi	r2,r2,-1
8112a164:	d8800515 	stw	r2,20(sp)
8112a168:	183f761e 	bne	r3,zero,81129f44 <__reset+0xfb109f44>
8112a16c:	d9000c17 	ldw	r4,48(sp)
8112a170:	0101730e 	bge	zero,r4,8112a740 <_dtoa_r+0x15d4>
8112a174:	d9000615 	stw	r4,24(sp)
8112a178:	003ed006 	br	81129cbc <__reset+0xfb109cbc>
8112a17c:	00800084 	movi	r2,2
8112a180:	3081861e 	bne	r6,r2,8112a79c <_dtoa_r+0x1630>
8112a184:	d8000b15 	stw	zero,44(sp)
8112a188:	003f3c06 	br	81129e7c <__reset+0xfb109e7c>
8112a18c:	dc000917 	ldw	r16,36(sp)
8112a190:	003e9206 	br	81129bdc <__reset+0xfb109bdc>
8112a194:	d9c00317 	ldw	r7,12(sp)
8112a198:	00800084 	movi	r2,2
8112a19c:	11fec50e 	bge	r2,r7,81129cb4 <__reset+0xfb109cb4>
8112a1a0:	d9000617 	ldw	r4,24(sp)
8112a1a4:	20013c1e 	bne	r4,zero,8112a698 <_dtoa_r+0x152c>
8112a1a8:	a80b883a 	mov	r5,r21
8112a1ac:	000f883a 	mov	r7,zero
8112a1b0:	01800144 	movi	r6,5
8112a1b4:	e009883a 	mov	r4,fp
8112a1b8:	112c35c0 	call	8112c35c <__multadd>
8112a1bc:	100b883a 	mov	r5,r2
8112a1c0:	8009883a 	mov	r4,r16
8112a1c4:	102b883a 	mov	r21,r2
8112a1c8:	112cb840 	call	8112cb84 <__mcmp>
8112a1cc:	dc000915 	stw	r16,36(sp)
8112a1d0:	00bf410e 	bge	zero,r2,81129ed8 <__reset+0xfb109ed8>
8112a1d4:	d9c00717 	ldw	r7,28(sp)
8112a1d8:	00800c44 	movi	r2,49
8112a1dc:	38800005 	stb	r2,0(r7)
8112a1e0:	d8800517 	ldw	r2,20(sp)
8112a1e4:	3dc00044 	addi	r23,r7,1
8112a1e8:	10800044 	addi	r2,r2,1
8112a1ec:	d8800515 	stw	r2,20(sp)
8112a1f0:	003f3d06 	br	81129ee8 <__reset+0xfb109ee8>
8112a1f4:	d9800517 	ldw	r6,20(sp)
8112a1f8:	d9c00717 	ldw	r7,28(sp)
8112a1fc:	00800c44 	movi	r2,49
8112a200:	31800044 	addi	r6,r6,1
8112a204:	d9800515 	stw	r6,20(sp)
8112a208:	38800005 	stb	r2,0(r7)
8112a20c:	003edf06 	br	81129d8c <__reset+0xfb109d8c>
8112a210:	d8000b15 	stw	zero,44(sp)
8112a214:	003c9f06 	br	81129494 <__reset+0xfb109494>
8112a218:	903e7e1e 	bne	r18,zero,81129c14 <__reset+0xfb109c14>
8112a21c:	00800434 	movhi	r2,16
8112a220:	10bfffc4 	addi	r2,r2,-1
8112a224:	9884703a 	and	r2,r19,r2
8112a228:	1000ea1e 	bne	r2,zero,8112a5d4 <_dtoa_r+0x1468>
8112a22c:	9cdffc2c 	andhi	r19,r19,32752
8112a230:	9800e826 	beq	r19,zero,8112a5d4 <_dtoa_r+0x1468>
8112a234:	d9c00817 	ldw	r7,32(sp)
8112a238:	b5800044 	addi	r22,r22,1
8112a23c:	04c00044 	movi	r19,1
8112a240:	39c00044 	addi	r7,r7,1
8112a244:	d9c00815 	stw	r7,32(sp)
8112a248:	d8800d17 	ldw	r2,52(sp)
8112a24c:	103e721e 	bne	r2,zero,81129c18 <__reset+0xfb109c18>
8112a250:	00800044 	movi	r2,1
8112a254:	003e7906 	br	81129c3c <__reset+0xfb109c3c>
8112a258:	8009883a 	mov	r4,r16
8112a25c:	1120a400 	call	81120a40 <__floatsidf>
8112a260:	d9800f17 	ldw	r6,60(sp)
8112a264:	d9c01017 	ldw	r7,64(sp)
8112a268:	1009883a 	mov	r4,r2
8112a26c:	180b883a 	mov	r5,r3
8112a270:	111f99c0 	call	8111f99c <__muldf3>
8112a274:	000d883a 	mov	r6,zero
8112a278:	01d00734 	movhi	r7,16412
8112a27c:	1009883a 	mov	r4,r2
8112a280:	180b883a 	mov	r5,r3
8112a284:	11348780 	call	81134878 <__adddf3>
8112a288:	047f3034 	movhi	r17,64704
8112a28c:	1021883a 	mov	r16,r2
8112a290:	1c63883a 	add	r17,r3,r17
8112a294:	d9000f17 	ldw	r4,60(sp)
8112a298:	d9401017 	ldw	r5,64(sp)
8112a29c:	000d883a 	mov	r6,zero
8112a2a0:	01d00534 	movhi	r7,16404
8112a2a4:	11200bc0 	call	811200bc <__subdf3>
8112a2a8:	800d883a 	mov	r6,r16
8112a2ac:	880f883a 	mov	r7,r17
8112a2b0:	1009883a 	mov	r4,r2
8112a2b4:	180b883a 	mov	r5,r3
8112a2b8:	102b883a 	mov	r21,r2
8112a2bc:	1829883a 	mov	r20,r3
8112a2c0:	111f8c00 	call	8111f8c0 <__gedf2>
8112a2c4:	00806c16 	blt	zero,r2,8112a478 <_dtoa_r+0x130c>
8112a2c8:	89e0003c 	xorhi	r7,r17,32768
8112a2cc:	800d883a 	mov	r6,r16
8112a2d0:	a809883a 	mov	r4,r21
8112a2d4:	a00b883a 	mov	r5,r20
8112a2d8:	1135aa40 	call	81135aa4 <__ledf2>
8112a2dc:	103d7e0e 	bge	r2,zero,811298d8 <__reset+0xfb1098d8>
8112a2e0:	002b883a 	mov	r21,zero
8112a2e4:	0023883a 	mov	r17,zero
8112a2e8:	003efb06 	br	81129ed8 <__reset+0xfb109ed8>
8112a2ec:	d8800717 	ldw	r2,28(sp)
8112a2f0:	003bd006 	br	81129234 <__reset+0xfb109234>
8112a2f4:	d9000a17 	ldw	r4,40(sp)
8112a2f8:	d9800d17 	ldw	r6,52(sp)
8112a2fc:	dd400a15 	stw	r21,40(sp)
8112a300:	a905c83a 	sub	r2,r21,r4
8112a304:	308d883a 	add	r6,r6,r2
8112a308:	d9800d15 	stw	r6,52(sp)
8112a30c:	002b883a 	mov	r21,zero
8112a310:	003e0606 	br	81129b2c <__reset+0xfb109b2c>
8112a314:	9023883a 	mov	r17,r18
8112a318:	9829883a 	mov	r20,r19
8112a31c:	04000084 	movi	r16,2
8112a320:	003c9206 	br	8112956c <__reset+0xfb10956c>
8112a324:	04000044 	movi	r16,1
8112a328:	dc000c15 	stw	r16,48(sp)
8112a32c:	dc000615 	stw	r16,24(sp)
8112a330:	dc002215 	stw	r16,136(sp)
8112a334:	e0001115 	stw	zero,68(fp)
8112a338:	000b883a 	mov	r5,zero
8112a33c:	003c6906 	br	811294e4 <__reset+0xfb1094e4>
8112a340:	3021883a 	mov	r16,r6
8112a344:	003ffb06 	br	8112a334 <__reset+0xfb10a334>
8112a348:	1000021e 	bne	r2,zero,8112a354 <_dtoa_r+0x11e8>
8112a34c:	4200004c 	andi	r8,r8,1
8112a350:	403e7d1e 	bne	r8,zero,81129d48 <__reset+0xfb109d48>
8112a354:	01000c04 	movi	r4,48
8112a358:	00000106 	br	8112a360 <_dtoa_r+0x11f4>
8112a35c:	102f883a 	mov	r23,r2
8112a360:	b8bfffc4 	addi	r2,r23,-1
8112a364:	10c00007 	ldb	r3,0(r2)
8112a368:	193ffc26 	beq	r3,r4,8112a35c <__reset+0xfb10a35c>
8112a36c:	003e8706 	br	81129d8c <__reset+0xfb109d8c>
8112a370:	d8800517 	ldw	r2,20(sp)
8112a374:	00a3c83a 	sub	r17,zero,r2
8112a378:	8800a426 	beq	r17,zero,8112a60c <_dtoa_r+0x14a0>
8112a37c:	888003cc 	andi	r2,r17,15
8112a380:	100490fa 	slli	r2,r2,3
8112a384:	00e04574 	movhi	r3,33045
8112a388:	18c14904 	addi	r3,r3,1316
8112a38c:	1885883a 	add	r2,r3,r2
8112a390:	11800017 	ldw	r6,0(r2)
8112a394:	11c00117 	ldw	r7,4(r2)
8112a398:	9009883a 	mov	r4,r18
8112a39c:	980b883a 	mov	r5,r19
8112a3a0:	8823d13a 	srai	r17,r17,4
8112a3a4:	111f99c0 	call	8111f99c <__muldf3>
8112a3a8:	d8800f15 	stw	r2,60(sp)
8112a3ac:	d8c01015 	stw	r3,64(sp)
8112a3b0:	8800e826 	beq	r17,zero,8112a754 <_dtoa_r+0x15e8>
8112a3b4:	05204574 	movhi	r20,33045
8112a3b8:	a5013f04 	addi	r20,r20,1276
8112a3bc:	04000084 	movi	r16,2
8112a3c0:	8980004c 	andi	r6,r17,1
8112a3c4:	1009883a 	mov	r4,r2
8112a3c8:	8823d07a 	srai	r17,r17,1
8112a3cc:	180b883a 	mov	r5,r3
8112a3d0:	30000426 	beq	r6,zero,8112a3e4 <_dtoa_r+0x1278>
8112a3d4:	a1800017 	ldw	r6,0(r20)
8112a3d8:	a1c00117 	ldw	r7,4(r20)
8112a3dc:	84000044 	addi	r16,r16,1
8112a3e0:	111f99c0 	call	8111f99c <__muldf3>
8112a3e4:	a5000204 	addi	r20,r20,8
8112a3e8:	883ff51e 	bne	r17,zero,8112a3c0 <__reset+0xfb10a3c0>
8112a3ec:	d8800f15 	stw	r2,60(sp)
8112a3f0:	d8c01015 	stw	r3,64(sp)
8112a3f4:	003c7606 	br	811295d0 <__reset+0xfb1095d0>
8112a3f8:	00c00c04 	movi	r3,48
8112a3fc:	10c00005 	stb	r3,0(r2)
8112a400:	d8c00517 	ldw	r3,20(sp)
8112a404:	bd3fffc3 	ldbu	r20,-1(r23)
8112a408:	18c00044 	addi	r3,r3,1
8112a40c:	d8c00515 	stw	r3,20(sp)
8112a410:	003db906 	br	81129af8 <__reset+0xfb109af8>
8112a414:	89400117 	ldw	r5,4(r17)
8112a418:	e009883a 	mov	r4,fp
8112a41c:	112c2840 	call	8112c284 <_Balloc>
8112a420:	89800417 	ldw	r6,16(r17)
8112a424:	89400304 	addi	r5,r17,12
8112a428:	11000304 	addi	r4,r2,12
8112a42c:	31800084 	addi	r6,r6,2
8112a430:	318d883a 	add	r6,r6,r6
8112a434:	318d883a 	add	r6,r6,r6
8112a438:	1027883a 	mov	r19,r2
8112a43c:	11220540 	call	81122054 <memcpy>
8112a440:	01800044 	movi	r6,1
8112a444:	980b883a 	mov	r5,r19
8112a448:	e009883a 	mov	r4,fp
8112a44c:	112ca340 	call	8112ca34 <__lshift>
8112a450:	1029883a 	mov	r20,r2
8112a454:	003ecc06 	br	81129f88 <__reset+0xfb109f88>
8112a458:	00800e44 	movi	r2,57
8112a45c:	90809026 	beq	r18,r2,8112a6a0 <_dtoa_r+0x1534>
8112a460:	92000044 	addi	r8,r18,1
8112a464:	003f1f06 	br	8112a0e4 <__reset+0xfb10a0e4>
8112a468:	9011883a 	mov	r8,r18
8112a46c:	8825883a 	mov	r18,r17
8112a470:	a023883a 	mov	r17,r20
8112a474:	003e2906 	br	81129d1c <__reset+0xfb109d1c>
8112a478:	002b883a 	mov	r21,zero
8112a47c:	0023883a 	mov	r17,zero
8112a480:	003f5406 	br	8112a1d4 <__reset+0xfb10a1d4>
8112a484:	61bfffc4 	addi	r6,r12,-1
8112a488:	300490fa 	slli	r2,r6,3
8112a48c:	00e04574 	movhi	r3,33045
8112a490:	18c14904 	addi	r3,r3,1316
8112a494:	1885883a 	add	r2,r3,r2
8112a498:	11000017 	ldw	r4,0(r2)
8112a49c:	11400117 	ldw	r5,4(r2)
8112a4a0:	d8800717 	ldw	r2,28(sp)
8112a4a4:	880f883a 	mov	r7,r17
8112a4a8:	d9801215 	stw	r6,72(sp)
8112a4ac:	800d883a 	mov	r6,r16
8112a4b0:	db001615 	stw	r12,88(sp)
8112a4b4:	15c00044 	addi	r23,r2,1
8112a4b8:	111f99c0 	call	8111f99c <__muldf3>
8112a4bc:	d9401017 	ldw	r5,64(sp)
8112a4c0:	d9000f17 	ldw	r4,60(sp)
8112a4c4:	d8c01515 	stw	r3,84(sp)
8112a4c8:	d8801415 	stw	r2,80(sp)
8112a4cc:	11209c00 	call	811209c0 <__fixdfsi>
8112a4d0:	1009883a 	mov	r4,r2
8112a4d4:	1021883a 	mov	r16,r2
8112a4d8:	1120a400 	call	81120a40 <__floatsidf>
8112a4dc:	d9000f17 	ldw	r4,60(sp)
8112a4e0:	d9401017 	ldw	r5,64(sp)
8112a4e4:	100d883a 	mov	r6,r2
8112a4e8:	180f883a 	mov	r7,r3
8112a4ec:	11200bc0 	call	811200bc <__subdf3>
8112a4f0:	1829883a 	mov	r20,r3
8112a4f4:	d8c00717 	ldw	r3,28(sp)
8112a4f8:	84000c04 	addi	r16,r16,48
8112a4fc:	1023883a 	mov	r17,r2
8112a500:	1c000005 	stb	r16,0(r3)
8112a504:	db001617 	ldw	r12,88(sp)
8112a508:	00800044 	movi	r2,1
8112a50c:	60802226 	beq	r12,r2,8112a598 <_dtoa_r+0x142c>
8112a510:	d9c00717 	ldw	r7,28(sp)
8112a514:	8805883a 	mov	r2,r17
8112a518:	b82b883a 	mov	r21,r23
8112a51c:	3b19883a 	add	r12,r7,r12
8112a520:	6023883a 	mov	r17,r12
8112a524:	a007883a 	mov	r3,r20
8112a528:	dc800f15 	stw	r18,60(sp)
8112a52c:	000d883a 	mov	r6,zero
8112a530:	01d00934 	movhi	r7,16420
8112a534:	1009883a 	mov	r4,r2
8112a538:	180b883a 	mov	r5,r3
8112a53c:	111f99c0 	call	8111f99c <__muldf3>
8112a540:	180b883a 	mov	r5,r3
8112a544:	1009883a 	mov	r4,r2
8112a548:	1829883a 	mov	r20,r3
8112a54c:	1025883a 	mov	r18,r2
8112a550:	11209c00 	call	811209c0 <__fixdfsi>
8112a554:	1009883a 	mov	r4,r2
8112a558:	1021883a 	mov	r16,r2
8112a55c:	1120a400 	call	81120a40 <__floatsidf>
8112a560:	100d883a 	mov	r6,r2
8112a564:	180f883a 	mov	r7,r3
8112a568:	9009883a 	mov	r4,r18
8112a56c:	a00b883a 	mov	r5,r20
8112a570:	84000c04 	addi	r16,r16,48
8112a574:	11200bc0 	call	811200bc <__subdf3>
8112a578:	ad400044 	addi	r21,r21,1
8112a57c:	ac3fffc5 	stb	r16,-1(r21)
8112a580:	ac7fea1e 	bne	r21,r17,8112a52c <__reset+0xfb10a52c>
8112a584:	1023883a 	mov	r17,r2
8112a588:	d8801217 	ldw	r2,72(sp)
8112a58c:	dc800f17 	ldw	r18,60(sp)
8112a590:	1829883a 	mov	r20,r3
8112a594:	b8af883a 	add	r23,r23,r2
8112a598:	d9001417 	ldw	r4,80(sp)
8112a59c:	d9401517 	ldw	r5,84(sp)
8112a5a0:	000d883a 	mov	r6,zero
8112a5a4:	01cff834 	movhi	r7,16352
8112a5a8:	11348780 	call	81134878 <__adddf3>
8112a5ac:	880d883a 	mov	r6,r17
8112a5b0:	a00f883a 	mov	r7,r20
8112a5b4:	1009883a 	mov	r4,r2
8112a5b8:	180b883a 	mov	r5,r3
8112a5bc:	1135aa40 	call	81135aa4 <__ledf2>
8112a5c0:	10003e0e 	bge	r2,zero,8112a6bc <_dtoa_r+0x1550>
8112a5c4:	d9001317 	ldw	r4,76(sp)
8112a5c8:	bd3fffc3 	ldbu	r20,-1(r23)
8112a5cc:	d9000515 	stw	r4,20(sp)
8112a5d0:	003d3b06 	br	81129ac0 <__reset+0xfb109ac0>
8112a5d4:	0027883a 	mov	r19,zero
8112a5d8:	003f1b06 	br	8112a248 <__reset+0xfb10a248>
8112a5dc:	d8800817 	ldw	r2,32(sp)
8112a5e0:	11e9c83a 	sub	r20,r2,r7
8112a5e4:	0005883a 	mov	r2,zero
8112a5e8:	003d5406 	br	81129b3c <__reset+0xfb109b3c>
8112a5ec:	00800044 	movi	r2,1
8112a5f0:	003dc706 	br	81129d10 <__reset+0xfb109d10>
8112a5f4:	d8c00217 	ldw	r3,8(sp)
8112a5f8:	00800d84 	movi	r2,54
8112a5fc:	dd400a17 	ldw	r21,40(sp)
8112a600:	10c5c83a 	sub	r2,r2,r3
8112a604:	dd000817 	ldw	r20,32(sp)
8112a608:	003d4c06 	br	81129b3c <__reset+0xfb109b3c>
8112a60c:	dc800f15 	stw	r18,60(sp)
8112a610:	dcc01015 	stw	r19,64(sp)
8112a614:	04000084 	movi	r16,2
8112a618:	003bed06 	br	811295d0 <__reset+0xfb1095d0>
8112a61c:	d9000617 	ldw	r4,24(sp)
8112a620:	203f0d26 	beq	r4,zero,8112a258 <__reset+0xfb10a258>
8112a624:	d9800c17 	ldw	r6,48(sp)
8112a628:	01bcab0e 	bge	zero,r6,811298d8 <__reset+0xfb1098d8>
8112a62c:	d9401017 	ldw	r5,64(sp)
8112a630:	d9000f17 	ldw	r4,60(sp)
8112a634:	000d883a 	mov	r6,zero
8112a638:	01d00934 	movhi	r7,16420
8112a63c:	111f99c0 	call	8111f99c <__muldf3>
8112a640:	81000044 	addi	r4,r16,1
8112a644:	d8800f15 	stw	r2,60(sp)
8112a648:	d8c01015 	stw	r3,64(sp)
8112a64c:	1120a400 	call	81120a40 <__floatsidf>
8112a650:	d9800f17 	ldw	r6,60(sp)
8112a654:	d9c01017 	ldw	r7,64(sp)
8112a658:	1009883a 	mov	r4,r2
8112a65c:	180b883a 	mov	r5,r3
8112a660:	111f99c0 	call	8111f99c <__muldf3>
8112a664:	01d00734 	movhi	r7,16412
8112a668:	000d883a 	mov	r6,zero
8112a66c:	1009883a 	mov	r4,r2
8112a670:	180b883a 	mov	r5,r3
8112a674:	11348780 	call	81134878 <__adddf3>
8112a678:	d9c00517 	ldw	r7,20(sp)
8112a67c:	047f3034 	movhi	r17,64704
8112a680:	1021883a 	mov	r16,r2
8112a684:	39ffffc4 	addi	r7,r7,-1
8112a688:	d9c01315 	stw	r7,76(sp)
8112a68c:	1c63883a 	add	r17,r3,r17
8112a690:	db000c17 	ldw	r12,48(sp)
8112a694:	003bea06 	br	81129640 <__reset+0xfb109640>
8112a698:	dc000915 	stw	r16,36(sp)
8112a69c:	003e0e06 	br	81129ed8 <__reset+0xfb109ed8>
8112a6a0:	01000e44 	movi	r4,57
8112a6a4:	8825883a 	mov	r18,r17
8112a6a8:	9dc00044 	addi	r23,r19,1
8112a6ac:	99000005 	stb	r4,0(r19)
8112a6b0:	a023883a 	mov	r17,r20
8112a6b4:	dc000915 	stw	r16,36(sp)
8112a6b8:	003da406 	br	81129d4c <__reset+0xfb109d4c>
8112a6bc:	d9801417 	ldw	r6,80(sp)
8112a6c0:	d9c01517 	ldw	r7,84(sp)
8112a6c4:	0009883a 	mov	r4,zero
8112a6c8:	014ff834 	movhi	r5,16352
8112a6cc:	11200bc0 	call	811200bc <__subdf3>
8112a6d0:	880d883a 	mov	r6,r17
8112a6d4:	a00f883a 	mov	r7,r20
8112a6d8:	1009883a 	mov	r4,r2
8112a6dc:	180b883a 	mov	r5,r3
8112a6e0:	111f8c00 	call	8111f8c0 <__gedf2>
8112a6e4:	00bc7c0e 	bge	zero,r2,811298d8 <__reset+0xfb1098d8>
8112a6e8:	01000c04 	movi	r4,48
8112a6ec:	00000106 	br	8112a6f4 <_dtoa_r+0x1588>
8112a6f0:	102f883a 	mov	r23,r2
8112a6f4:	b8bfffc4 	addi	r2,r23,-1
8112a6f8:	10c00007 	ldb	r3,0(r2)
8112a6fc:	193ffc26 	beq	r3,r4,8112a6f0 <__reset+0xfb10a6f0>
8112a700:	d9801317 	ldw	r6,76(sp)
8112a704:	d9800515 	stw	r6,20(sp)
8112a708:	003c4406 	br	8112981c <__reset+0xfb10981c>
8112a70c:	d9801317 	ldw	r6,76(sp)
8112a710:	d9800515 	stw	r6,20(sp)
8112a714:	003cea06 	br	81129ac0 <__reset+0xfb109ac0>
8112a718:	dd800f17 	ldw	r22,60(sp)
8112a71c:	dcc01017 	ldw	r19,64(sp)
8112a720:	dc801217 	ldw	r18,72(sp)
8112a724:	003c6c06 	br	811298d8 <__reset+0xfb1098d8>
8112a728:	903e031e 	bne	r18,zero,81129f38 <__reset+0xfb109f38>
8112a72c:	003ebb06 	br	8112a21c <__reset+0xfb10a21c>
8112a730:	103e6c1e 	bne	r2,zero,8112a0e4 <__reset+0xfb10a0e4>
8112a734:	4080004c 	andi	r2,r8,1
8112a738:	103e6a26 	beq	r2,zero,8112a0e4 <__reset+0xfb10a0e4>
8112a73c:	003e6606 	br	8112a0d8 <__reset+0xfb10a0d8>
8112a740:	d8c00317 	ldw	r3,12(sp)
8112a744:	00800084 	movi	r2,2
8112a748:	10c02916 	blt	r2,r3,8112a7f0 <_dtoa_r+0x1684>
8112a74c:	d9000c17 	ldw	r4,48(sp)
8112a750:	003e8806 	br	8112a174 <__reset+0xfb10a174>
8112a754:	04000084 	movi	r16,2
8112a758:	003b9d06 	br	811295d0 <__reset+0xfb1095d0>
8112a75c:	d9001317 	ldw	r4,76(sp)
8112a760:	d9000515 	stw	r4,20(sp)
8112a764:	003cd606 	br	81129ac0 <__reset+0xfb109ac0>
8112a768:	d8801317 	ldw	r2,76(sp)
8112a76c:	d8800515 	stw	r2,20(sp)
8112a770:	003c2a06 	br	8112981c <__reset+0xfb10981c>
8112a774:	d9800317 	ldw	r6,12(sp)
8112a778:	00800084 	movi	r2,2
8112a77c:	11801516 	blt	r2,r6,8112a7d4 <_dtoa_r+0x1668>
8112a780:	d9c00c17 	ldw	r7,48(sp)
8112a784:	d9c00615 	stw	r7,24(sp)
8112a788:	003df706 	br	81129f68 <__reset+0xfb109f68>
8112a78c:	193d3926 	beq	r3,r4,81129c74 <__reset+0xfb109c74>
8112a790:	00c00f04 	movi	r3,60
8112a794:	1885c83a 	sub	r2,r3,r2
8112a798:	003ddf06 	br	81129f18 <__reset+0xfb109f18>
8112a79c:	e009883a 	mov	r4,fp
8112a7a0:	e0001115 	stw	zero,68(fp)
8112a7a4:	000b883a 	mov	r5,zero
8112a7a8:	112c2840 	call	8112c284 <_Balloc>
8112a7ac:	d8800715 	stw	r2,28(sp)
8112a7b0:	d8c00717 	ldw	r3,28(sp)
8112a7b4:	00bfffc4 	movi	r2,-1
8112a7b8:	01000044 	movi	r4,1
8112a7bc:	d8800c15 	stw	r2,48(sp)
8112a7c0:	e0c01015 	stw	r3,64(fp)
8112a7c4:	d9000b15 	stw	r4,44(sp)
8112a7c8:	d8800615 	stw	r2,24(sp)
8112a7cc:	d8002215 	stw	zero,136(sp)
8112a7d0:	003c4106 	br	811298d8 <__reset+0xfb1098d8>
8112a7d4:	d8c00c17 	ldw	r3,48(sp)
8112a7d8:	d8c00615 	stw	r3,24(sp)
8112a7dc:	003e7006 	br	8112a1a0 <__reset+0xfb10a1a0>
8112a7e0:	04400044 	movi	r17,1
8112a7e4:	003b2006 	br	81129468 <__reset+0xfb109468>
8112a7e8:	000b883a 	mov	r5,zero
8112a7ec:	003b3d06 	br	811294e4 <__reset+0xfb1094e4>
8112a7f0:	d8800c17 	ldw	r2,48(sp)
8112a7f4:	d8800615 	stw	r2,24(sp)
8112a7f8:	003e6906 	br	8112a1a0 <__reset+0xfb10a1a0>

8112a7fc <__sflush_r>:
8112a7fc:	defffb04 	addi	sp,sp,-20
8112a800:	de00012e 	bgeu	sp,et,8112a808 <__sflush_r+0xc>
8112a804:	003b68fa 	trap	3
8112a808:	2880030b 	ldhu	r2,12(r5)
8112a80c:	dcc00315 	stw	r19,12(sp)
8112a810:	dc400115 	stw	r17,4(sp)
8112a814:	dfc00415 	stw	ra,16(sp)
8112a818:	dc800215 	stw	r18,8(sp)
8112a81c:	dc000015 	stw	r16,0(sp)
8112a820:	10c0020c 	andi	r3,r2,8
8112a824:	2823883a 	mov	r17,r5
8112a828:	2027883a 	mov	r19,r4
8112a82c:	1800311e 	bne	r3,zero,8112a8f4 <__sflush_r+0xf8>
8112a830:	28c00117 	ldw	r3,4(r5)
8112a834:	10820014 	ori	r2,r2,2048
8112a838:	2880030d 	sth	r2,12(r5)
8112a83c:	00c04b0e 	bge	zero,r3,8112a96c <__sflush_r+0x170>
8112a840:	8a000a17 	ldw	r8,40(r17)
8112a844:	40002326 	beq	r8,zero,8112a8d4 <__sflush_r+0xd8>
8112a848:	9c000017 	ldw	r16,0(r19)
8112a84c:	10c4000c 	andi	r3,r2,4096
8112a850:	98000015 	stw	zero,0(r19)
8112a854:	18004826 	beq	r3,zero,8112a978 <__sflush_r+0x17c>
8112a858:	89801417 	ldw	r6,80(r17)
8112a85c:	10c0010c 	andi	r3,r2,4
8112a860:	18000626 	beq	r3,zero,8112a87c <__sflush_r+0x80>
8112a864:	88c00117 	ldw	r3,4(r17)
8112a868:	88800c17 	ldw	r2,48(r17)
8112a86c:	30cdc83a 	sub	r6,r6,r3
8112a870:	10000226 	beq	r2,zero,8112a87c <__sflush_r+0x80>
8112a874:	88800f17 	ldw	r2,60(r17)
8112a878:	308dc83a 	sub	r6,r6,r2
8112a87c:	89400717 	ldw	r5,28(r17)
8112a880:	000f883a 	mov	r7,zero
8112a884:	9809883a 	mov	r4,r19
8112a888:	403ee83a 	callr	r8
8112a88c:	00ffffc4 	movi	r3,-1
8112a890:	10c04426 	beq	r2,r3,8112a9a4 <__sflush_r+0x1a8>
8112a894:	88c0030b 	ldhu	r3,12(r17)
8112a898:	89000417 	ldw	r4,16(r17)
8112a89c:	88000115 	stw	zero,4(r17)
8112a8a0:	197dffcc 	andi	r5,r3,63487
8112a8a4:	8940030d 	sth	r5,12(r17)
8112a8a8:	89000015 	stw	r4,0(r17)
8112a8ac:	18c4000c 	andi	r3,r3,4096
8112a8b0:	18002c1e 	bne	r3,zero,8112a964 <__sflush_r+0x168>
8112a8b4:	89400c17 	ldw	r5,48(r17)
8112a8b8:	9c000015 	stw	r16,0(r19)
8112a8bc:	28000526 	beq	r5,zero,8112a8d4 <__sflush_r+0xd8>
8112a8c0:	88801004 	addi	r2,r17,64
8112a8c4:	28800226 	beq	r5,r2,8112a8d0 <__sflush_r+0xd4>
8112a8c8:	9809883a 	mov	r4,r19
8112a8cc:	112b2b40 	call	8112b2b4 <_free_r>
8112a8d0:	88000c15 	stw	zero,48(r17)
8112a8d4:	0005883a 	mov	r2,zero
8112a8d8:	dfc00417 	ldw	ra,16(sp)
8112a8dc:	dcc00317 	ldw	r19,12(sp)
8112a8e0:	dc800217 	ldw	r18,8(sp)
8112a8e4:	dc400117 	ldw	r17,4(sp)
8112a8e8:	dc000017 	ldw	r16,0(sp)
8112a8ec:	dec00504 	addi	sp,sp,20
8112a8f0:	f800283a 	ret
8112a8f4:	2c800417 	ldw	r18,16(r5)
8112a8f8:	903ff626 	beq	r18,zero,8112a8d4 <__reset+0xfb10a8d4>
8112a8fc:	2c000017 	ldw	r16,0(r5)
8112a900:	108000cc 	andi	r2,r2,3
8112a904:	2c800015 	stw	r18,0(r5)
8112a908:	84a1c83a 	sub	r16,r16,r18
8112a90c:	1000131e 	bne	r2,zero,8112a95c <__sflush_r+0x160>
8112a910:	28800517 	ldw	r2,20(r5)
8112a914:	88800215 	stw	r2,8(r17)
8112a918:	04000316 	blt	zero,r16,8112a928 <__sflush_r+0x12c>
8112a91c:	003fed06 	br	8112a8d4 <__reset+0xfb10a8d4>
8112a920:	90a5883a 	add	r18,r18,r2
8112a924:	043feb0e 	bge	zero,r16,8112a8d4 <__reset+0xfb10a8d4>
8112a928:	88800917 	ldw	r2,36(r17)
8112a92c:	89400717 	ldw	r5,28(r17)
8112a930:	800f883a 	mov	r7,r16
8112a934:	900d883a 	mov	r6,r18
8112a938:	9809883a 	mov	r4,r19
8112a93c:	103ee83a 	callr	r2
8112a940:	80a1c83a 	sub	r16,r16,r2
8112a944:	00bff616 	blt	zero,r2,8112a920 <__reset+0xfb10a920>
8112a948:	88c0030b 	ldhu	r3,12(r17)
8112a94c:	00bfffc4 	movi	r2,-1
8112a950:	18c01014 	ori	r3,r3,64
8112a954:	88c0030d 	sth	r3,12(r17)
8112a958:	003fdf06 	br	8112a8d8 <__reset+0xfb10a8d8>
8112a95c:	0005883a 	mov	r2,zero
8112a960:	003fec06 	br	8112a914 <__reset+0xfb10a914>
8112a964:	88801415 	stw	r2,80(r17)
8112a968:	003fd206 	br	8112a8b4 <__reset+0xfb10a8b4>
8112a96c:	28c00f17 	ldw	r3,60(r5)
8112a970:	00ffb316 	blt	zero,r3,8112a840 <__reset+0xfb10a840>
8112a974:	003fd706 	br	8112a8d4 <__reset+0xfb10a8d4>
8112a978:	89400717 	ldw	r5,28(r17)
8112a97c:	000d883a 	mov	r6,zero
8112a980:	01c00044 	movi	r7,1
8112a984:	9809883a 	mov	r4,r19
8112a988:	403ee83a 	callr	r8
8112a98c:	100d883a 	mov	r6,r2
8112a990:	00bfffc4 	movi	r2,-1
8112a994:	30801426 	beq	r6,r2,8112a9e8 <__sflush_r+0x1ec>
8112a998:	8880030b 	ldhu	r2,12(r17)
8112a99c:	8a000a17 	ldw	r8,40(r17)
8112a9a0:	003fae06 	br	8112a85c <__reset+0xfb10a85c>
8112a9a4:	98c00017 	ldw	r3,0(r19)
8112a9a8:	183fba26 	beq	r3,zero,8112a894 <__reset+0xfb10a894>
8112a9ac:	01000744 	movi	r4,29
8112a9b0:	19000626 	beq	r3,r4,8112a9cc <__sflush_r+0x1d0>
8112a9b4:	01000584 	movi	r4,22
8112a9b8:	19000426 	beq	r3,r4,8112a9cc <__sflush_r+0x1d0>
8112a9bc:	88c0030b 	ldhu	r3,12(r17)
8112a9c0:	18c01014 	ori	r3,r3,64
8112a9c4:	88c0030d 	sth	r3,12(r17)
8112a9c8:	003fc306 	br	8112a8d8 <__reset+0xfb10a8d8>
8112a9cc:	8880030b 	ldhu	r2,12(r17)
8112a9d0:	88c00417 	ldw	r3,16(r17)
8112a9d4:	88000115 	stw	zero,4(r17)
8112a9d8:	10bdffcc 	andi	r2,r2,63487
8112a9dc:	8880030d 	sth	r2,12(r17)
8112a9e0:	88c00015 	stw	r3,0(r17)
8112a9e4:	003fb306 	br	8112a8b4 <__reset+0xfb10a8b4>
8112a9e8:	98800017 	ldw	r2,0(r19)
8112a9ec:	103fea26 	beq	r2,zero,8112a998 <__reset+0xfb10a998>
8112a9f0:	00c00744 	movi	r3,29
8112a9f4:	10c00226 	beq	r2,r3,8112aa00 <__sflush_r+0x204>
8112a9f8:	00c00584 	movi	r3,22
8112a9fc:	10c0031e 	bne	r2,r3,8112aa0c <__sflush_r+0x210>
8112aa00:	9c000015 	stw	r16,0(r19)
8112aa04:	0005883a 	mov	r2,zero
8112aa08:	003fb306 	br	8112a8d8 <__reset+0xfb10a8d8>
8112aa0c:	88c0030b 	ldhu	r3,12(r17)
8112aa10:	3005883a 	mov	r2,r6
8112aa14:	18c01014 	ori	r3,r3,64
8112aa18:	88c0030d 	sth	r3,12(r17)
8112aa1c:	003fae06 	br	8112a8d8 <__reset+0xfb10a8d8>

8112aa20 <_fflush_r>:
8112aa20:	defffd04 	addi	sp,sp,-12
8112aa24:	de00012e 	bgeu	sp,et,8112aa2c <_fflush_r+0xc>
8112aa28:	003b68fa 	trap	3
8112aa2c:	dc000115 	stw	r16,4(sp)
8112aa30:	dfc00215 	stw	ra,8(sp)
8112aa34:	2021883a 	mov	r16,r4
8112aa38:	20000226 	beq	r4,zero,8112aa44 <_fflush_r+0x24>
8112aa3c:	20800e17 	ldw	r2,56(r4)
8112aa40:	10000c26 	beq	r2,zero,8112aa74 <_fflush_r+0x54>
8112aa44:	2880030f 	ldh	r2,12(r5)
8112aa48:	1000051e 	bne	r2,zero,8112aa60 <_fflush_r+0x40>
8112aa4c:	0005883a 	mov	r2,zero
8112aa50:	dfc00217 	ldw	ra,8(sp)
8112aa54:	dc000117 	ldw	r16,4(sp)
8112aa58:	dec00304 	addi	sp,sp,12
8112aa5c:	f800283a 	ret
8112aa60:	8009883a 	mov	r4,r16
8112aa64:	dfc00217 	ldw	ra,8(sp)
8112aa68:	dc000117 	ldw	r16,4(sp)
8112aa6c:	dec00304 	addi	sp,sp,12
8112aa70:	112a7fc1 	jmpi	8112a7fc <__sflush_r>
8112aa74:	d9400015 	stw	r5,0(sp)
8112aa78:	112ae1c0 	call	8112ae1c <__sinit>
8112aa7c:	d9400017 	ldw	r5,0(sp)
8112aa80:	003ff006 	br	8112aa44 <__reset+0xfb10aa44>

8112aa84 <fflush>:
8112aa84:	20000526 	beq	r4,zero,8112aa9c <fflush+0x18>
8112aa88:	00a04574 	movhi	r2,33045
8112aa8c:	108ad804 	addi	r2,r2,11104
8112aa90:	200b883a 	mov	r5,r4
8112aa94:	11000017 	ldw	r4,0(r2)
8112aa98:	112aa201 	jmpi	8112aa20 <_fflush_r>
8112aa9c:	00a04574 	movhi	r2,33045
8112aaa0:	108ad704 	addi	r2,r2,11100
8112aaa4:	11000017 	ldw	r4,0(r2)
8112aaa8:	016044f4 	movhi	r5,33043
8112aaac:	296a8804 	addi	r5,r5,-21984
8112aab0:	112bb5c1 	jmpi	8112bb5c <_fwalk_reent>

8112aab4 <__fp_unlock>:
8112aab4:	0005883a 	mov	r2,zero
8112aab8:	f800283a 	ret

8112aabc <_cleanup_r>:
8112aabc:	016044f4 	movhi	r5,33043
8112aac0:	294a1e04 	addi	r5,r5,10360
8112aac4:	112bb5c1 	jmpi	8112bb5c <_fwalk_reent>

8112aac8 <__sinit.part.1>:
8112aac8:	defff704 	addi	sp,sp,-36
8112aacc:	00e044f4 	movhi	r3,33043
8112aad0:	de00012e 	bgeu	sp,et,8112aad8 <__sinit.part.1+0x10>
8112aad4:	003b68fa 	trap	3
8112aad8:	18eaaf04 	addi	r3,r3,-21828
8112aadc:	dfc00815 	stw	ra,32(sp)
8112aae0:	ddc00715 	stw	r23,28(sp)
8112aae4:	dd800615 	stw	r22,24(sp)
8112aae8:	dd400515 	stw	r21,20(sp)
8112aaec:	dd000415 	stw	r20,16(sp)
8112aaf0:	dcc00315 	stw	r19,12(sp)
8112aaf4:	dc800215 	stw	r18,8(sp)
8112aaf8:	dc400115 	stw	r17,4(sp)
8112aafc:	dc000015 	stw	r16,0(sp)
8112ab00:	24000117 	ldw	r16,4(r4)
8112ab04:	20c00f15 	stw	r3,60(r4)
8112ab08:	2080bb04 	addi	r2,r4,748
8112ab0c:	00c000c4 	movi	r3,3
8112ab10:	20c0b915 	stw	r3,740(r4)
8112ab14:	2080ba15 	stw	r2,744(r4)
8112ab18:	2000b815 	stw	zero,736(r4)
8112ab1c:	05c00204 	movi	r23,8
8112ab20:	00800104 	movi	r2,4
8112ab24:	2025883a 	mov	r18,r4
8112ab28:	b80d883a 	mov	r6,r23
8112ab2c:	81001704 	addi	r4,r16,92
8112ab30:	000b883a 	mov	r5,zero
8112ab34:	80000015 	stw	zero,0(r16)
8112ab38:	80000115 	stw	zero,4(r16)
8112ab3c:	80000215 	stw	zero,8(r16)
8112ab40:	8080030d 	sth	r2,12(r16)
8112ab44:	80001915 	stw	zero,100(r16)
8112ab48:	8000038d 	sth	zero,14(r16)
8112ab4c:	80000415 	stw	zero,16(r16)
8112ab50:	80000515 	stw	zero,20(r16)
8112ab54:	80000615 	stw	zero,24(r16)
8112ab58:	11221a40 	call	811221a4 <memset>
8112ab5c:	05a044b4 	movhi	r22,33042
8112ab60:	94400217 	ldw	r17,8(r18)
8112ab64:	056044b4 	movhi	r21,33042
8112ab68:	052044b4 	movhi	r20,33042
8112ab6c:	04e044b4 	movhi	r19,33042
8112ab70:	b58a6a04 	addi	r22,r22,10664
8112ab74:	ad4a8304 	addi	r21,r21,10764
8112ab78:	a50aa404 	addi	r20,r20,10896
8112ab7c:	9ccabd04 	addi	r19,r19,10996
8112ab80:	85800815 	stw	r22,32(r16)
8112ab84:	85400915 	stw	r21,36(r16)
8112ab88:	85000a15 	stw	r20,40(r16)
8112ab8c:	84c00b15 	stw	r19,44(r16)
8112ab90:	84000715 	stw	r16,28(r16)
8112ab94:	00800284 	movi	r2,10
8112ab98:	8880030d 	sth	r2,12(r17)
8112ab9c:	00800044 	movi	r2,1
8112aba0:	b80d883a 	mov	r6,r23
8112aba4:	89001704 	addi	r4,r17,92
8112aba8:	000b883a 	mov	r5,zero
8112abac:	88000015 	stw	zero,0(r17)
8112abb0:	88000115 	stw	zero,4(r17)
8112abb4:	88000215 	stw	zero,8(r17)
8112abb8:	88001915 	stw	zero,100(r17)
8112abbc:	8880038d 	sth	r2,14(r17)
8112abc0:	88000415 	stw	zero,16(r17)
8112abc4:	88000515 	stw	zero,20(r17)
8112abc8:	88000615 	stw	zero,24(r17)
8112abcc:	11221a40 	call	811221a4 <memset>
8112abd0:	94000317 	ldw	r16,12(r18)
8112abd4:	00800484 	movi	r2,18
8112abd8:	8c400715 	stw	r17,28(r17)
8112abdc:	8d800815 	stw	r22,32(r17)
8112abe0:	8d400915 	stw	r21,36(r17)
8112abe4:	8d000a15 	stw	r20,40(r17)
8112abe8:	8cc00b15 	stw	r19,44(r17)
8112abec:	8080030d 	sth	r2,12(r16)
8112abf0:	00800084 	movi	r2,2
8112abf4:	80000015 	stw	zero,0(r16)
8112abf8:	80000115 	stw	zero,4(r16)
8112abfc:	80000215 	stw	zero,8(r16)
8112ac00:	80001915 	stw	zero,100(r16)
8112ac04:	8080038d 	sth	r2,14(r16)
8112ac08:	80000415 	stw	zero,16(r16)
8112ac0c:	80000515 	stw	zero,20(r16)
8112ac10:	80000615 	stw	zero,24(r16)
8112ac14:	b80d883a 	mov	r6,r23
8112ac18:	000b883a 	mov	r5,zero
8112ac1c:	81001704 	addi	r4,r16,92
8112ac20:	11221a40 	call	811221a4 <memset>
8112ac24:	00800044 	movi	r2,1
8112ac28:	84000715 	stw	r16,28(r16)
8112ac2c:	85800815 	stw	r22,32(r16)
8112ac30:	85400915 	stw	r21,36(r16)
8112ac34:	85000a15 	stw	r20,40(r16)
8112ac38:	84c00b15 	stw	r19,44(r16)
8112ac3c:	90800e15 	stw	r2,56(r18)
8112ac40:	dfc00817 	ldw	ra,32(sp)
8112ac44:	ddc00717 	ldw	r23,28(sp)
8112ac48:	dd800617 	ldw	r22,24(sp)
8112ac4c:	dd400517 	ldw	r21,20(sp)
8112ac50:	dd000417 	ldw	r20,16(sp)
8112ac54:	dcc00317 	ldw	r19,12(sp)
8112ac58:	dc800217 	ldw	r18,8(sp)
8112ac5c:	dc400117 	ldw	r17,4(sp)
8112ac60:	dc000017 	ldw	r16,0(sp)
8112ac64:	dec00904 	addi	sp,sp,36
8112ac68:	f800283a 	ret

8112ac6c <__fp_lock>:
8112ac6c:	0005883a 	mov	r2,zero
8112ac70:	f800283a 	ret

8112ac74 <__sfmoreglue>:
8112ac74:	defffc04 	addi	sp,sp,-16
8112ac78:	de00012e 	bgeu	sp,et,8112ac80 <__sfmoreglue+0xc>
8112ac7c:	003b68fa 	trap	3
8112ac80:	dc400115 	stw	r17,4(sp)
8112ac84:	2c7fffc4 	addi	r17,r5,-1
8112ac88:	8c401a24 	muli	r17,r17,104
8112ac8c:	dc800215 	stw	r18,8(sp)
8112ac90:	2825883a 	mov	r18,r5
8112ac94:	89401d04 	addi	r5,r17,116
8112ac98:	dc000015 	stw	r16,0(sp)
8112ac9c:	dfc00315 	stw	ra,12(sp)
8112aca0:	11218400 	call	81121840 <_malloc_r>
8112aca4:	1021883a 	mov	r16,r2
8112aca8:	10000726 	beq	r2,zero,8112acc8 <__sfmoreglue+0x54>
8112acac:	11000304 	addi	r4,r2,12
8112acb0:	10000015 	stw	zero,0(r2)
8112acb4:	14800115 	stw	r18,4(r2)
8112acb8:	11000215 	stw	r4,8(r2)
8112acbc:	89801a04 	addi	r6,r17,104
8112acc0:	000b883a 	mov	r5,zero
8112acc4:	11221a40 	call	811221a4 <memset>
8112acc8:	8005883a 	mov	r2,r16
8112accc:	dfc00317 	ldw	ra,12(sp)
8112acd0:	dc800217 	ldw	r18,8(sp)
8112acd4:	dc400117 	ldw	r17,4(sp)
8112acd8:	dc000017 	ldw	r16,0(sp)
8112acdc:	dec00404 	addi	sp,sp,16
8112ace0:	f800283a 	ret

8112ace4 <__sfp>:
8112ace4:	defffb04 	addi	sp,sp,-20
8112ace8:	de00012e 	bgeu	sp,et,8112acf0 <__sfp+0xc>
8112acec:	003b68fa 	trap	3
8112acf0:	dc000015 	stw	r16,0(sp)
8112acf4:	04204574 	movhi	r16,33045
8112acf8:	840ad704 	addi	r16,r16,11100
8112acfc:	dcc00315 	stw	r19,12(sp)
8112ad00:	2027883a 	mov	r19,r4
8112ad04:	81000017 	ldw	r4,0(r16)
8112ad08:	dfc00415 	stw	ra,16(sp)
8112ad0c:	dc800215 	stw	r18,8(sp)
8112ad10:	20800e17 	ldw	r2,56(r4)
8112ad14:	dc400115 	stw	r17,4(sp)
8112ad18:	1000021e 	bne	r2,zero,8112ad24 <__sfp+0x40>
8112ad1c:	112aac80 	call	8112aac8 <__sinit.part.1>
8112ad20:	81000017 	ldw	r4,0(r16)
8112ad24:	2480b804 	addi	r18,r4,736
8112ad28:	047fffc4 	movi	r17,-1
8112ad2c:	91000117 	ldw	r4,4(r18)
8112ad30:	94000217 	ldw	r16,8(r18)
8112ad34:	213fffc4 	addi	r4,r4,-1
8112ad38:	20000a16 	blt	r4,zero,8112ad64 <__sfp+0x80>
8112ad3c:	8080030f 	ldh	r2,12(r16)
8112ad40:	10000c26 	beq	r2,zero,8112ad74 <__sfp+0x90>
8112ad44:	80c01d04 	addi	r3,r16,116
8112ad48:	00000206 	br	8112ad54 <__sfp+0x70>
8112ad4c:	18bfe60f 	ldh	r2,-104(r3)
8112ad50:	10000826 	beq	r2,zero,8112ad74 <__sfp+0x90>
8112ad54:	213fffc4 	addi	r4,r4,-1
8112ad58:	1c3ffd04 	addi	r16,r3,-12
8112ad5c:	18c01a04 	addi	r3,r3,104
8112ad60:	247ffa1e 	bne	r4,r17,8112ad4c <__reset+0xfb10ad4c>
8112ad64:	90800017 	ldw	r2,0(r18)
8112ad68:	10001d26 	beq	r2,zero,8112ade0 <__sfp+0xfc>
8112ad6c:	1025883a 	mov	r18,r2
8112ad70:	003fee06 	br	8112ad2c <__reset+0xfb10ad2c>
8112ad74:	00bfffc4 	movi	r2,-1
8112ad78:	8080038d 	sth	r2,14(r16)
8112ad7c:	00800044 	movi	r2,1
8112ad80:	8080030d 	sth	r2,12(r16)
8112ad84:	80001915 	stw	zero,100(r16)
8112ad88:	80000015 	stw	zero,0(r16)
8112ad8c:	80000215 	stw	zero,8(r16)
8112ad90:	80000115 	stw	zero,4(r16)
8112ad94:	80000415 	stw	zero,16(r16)
8112ad98:	80000515 	stw	zero,20(r16)
8112ad9c:	80000615 	stw	zero,24(r16)
8112ada0:	01800204 	movi	r6,8
8112ada4:	000b883a 	mov	r5,zero
8112ada8:	81001704 	addi	r4,r16,92
8112adac:	11221a40 	call	811221a4 <memset>
8112adb0:	8005883a 	mov	r2,r16
8112adb4:	80000c15 	stw	zero,48(r16)
8112adb8:	80000d15 	stw	zero,52(r16)
8112adbc:	80001115 	stw	zero,68(r16)
8112adc0:	80001215 	stw	zero,72(r16)
8112adc4:	dfc00417 	ldw	ra,16(sp)
8112adc8:	dcc00317 	ldw	r19,12(sp)
8112adcc:	dc800217 	ldw	r18,8(sp)
8112add0:	dc400117 	ldw	r17,4(sp)
8112add4:	dc000017 	ldw	r16,0(sp)
8112add8:	dec00504 	addi	sp,sp,20
8112addc:	f800283a 	ret
8112ade0:	01400104 	movi	r5,4
8112ade4:	9809883a 	mov	r4,r19
8112ade8:	112ac740 	call	8112ac74 <__sfmoreglue>
8112adec:	90800015 	stw	r2,0(r18)
8112adf0:	103fde1e 	bne	r2,zero,8112ad6c <__reset+0xfb10ad6c>
8112adf4:	00800304 	movi	r2,12
8112adf8:	98800015 	stw	r2,0(r19)
8112adfc:	0005883a 	mov	r2,zero
8112ae00:	003ff006 	br	8112adc4 <__reset+0xfb10adc4>

8112ae04 <_cleanup>:
8112ae04:	00a04574 	movhi	r2,33045
8112ae08:	108ad704 	addi	r2,r2,11100
8112ae0c:	11000017 	ldw	r4,0(r2)
8112ae10:	016044f4 	movhi	r5,33043
8112ae14:	294a1e04 	addi	r5,r5,10360
8112ae18:	112bb5c1 	jmpi	8112bb5c <_fwalk_reent>

8112ae1c <__sinit>:
8112ae1c:	20800e17 	ldw	r2,56(r4)
8112ae20:	10000126 	beq	r2,zero,8112ae28 <__sinit+0xc>
8112ae24:	f800283a 	ret
8112ae28:	112aac81 	jmpi	8112aac8 <__sinit.part.1>

8112ae2c <__sfp_lock_acquire>:
8112ae2c:	f800283a 	ret

8112ae30 <__sfp_lock_release>:
8112ae30:	f800283a 	ret

8112ae34 <__sinit_lock_acquire>:
8112ae34:	f800283a 	ret

8112ae38 <__sinit_lock_release>:
8112ae38:	f800283a 	ret

8112ae3c <__fp_lock_all>:
8112ae3c:	00a04574 	movhi	r2,33045
8112ae40:	108ad804 	addi	r2,r2,11104
8112ae44:	11000017 	ldw	r4,0(r2)
8112ae48:	016044f4 	movhi	r5,33043
8112ae4c:	296b1b04 	addi	r5,r5,-21396
8112ae50:	112ba901 	jmpi	8112ba90 <_fwalk>

8112ae54 <__fp_unlock_all>:
8112ae54:	00a04574 	movhi	r2,33045
8112ae58:	108ad804 	addi	r2,r2,11104
8112ae5c:	11000017 	ldw	r4,0(r2)
8112ae60:	016044f4 	movhi	r5,33043
8112ae64:	296aad04 	addi	r5,r5,-21836
8112ae68:	112ba901 	jmpi	8112ba90 <_fwalk>

8112ae6c <__sflags>:
8112ae6c:	28800007 	ldb	r2,0(r5)
8112ae70:	00c01c84 	movi	r3,114
8112ae74:	10c02426 	beq	r2,r3,8112af08 <__sflags+0x9c>
8112ae78:	00c01dc4 	movi	r3,119
8112ae7c:	10c01e26 	beq	r2,r3,8112aef8 <__sflags+0x8c>
8112ae80:	00c01844 	movi	r3,97
8112ae84:	10c00426 	beq	r2,r3,8112ae98 <__sflags+0x2c>
8112ae88:	00800584 	movi	r2,22
8112ae8c:	20800015 	stw	r2,0(r4)
8112ae90:	0005883a 	mov	r2,zero
8112ae94:	f800283a 	ret
8112ae98:	02c08204 	movi	r11,520
8112ae9c:	01000044 	movi	r4,1
8112aea0:	00804204 	movi	r2,264
8112aea4:	01c00ac4 	movi	r7,43
8112aea8:	02bff8c4 	movi	r10,-29
8112aeac:	027fff04 	movi	r9,-4
8112aeb0:	02001e04 	movi	r8,120
8112aeb4:	29400044 	addi	r5,r5,1
8112aeb8:	28c00007 	ldb	r3,0(r5)
8112aebc:	18000626 	beq	r3,zero,8112aed8 <__sflags+0x6c>
8112aec0:	19c00826 	beq	r3,r7,8112aee4 <__sflags+0x78>
8112aec4:	1a3ffb1e 	bne	r3,r8,8112aeb4 <__reset+0xfb10aeb4>
8112aec8:	29400044 	addi	r5,r5,1
8112aecc:	28c00007 	ldb	r3,0(r5)
8112aed0:	21020014 	ori	r4,r4,2048
8112aed4:	183ffa1e 	bne	r3,zero,8112aec0 <__reset+0xfb10aec0>
8112aed8:	22c8b03a 	or	r4,r4,r11
8112aedc:	31000015 	stw	r4,0(r6)
8112aee0:	f800283a 	ret
8112aee4:	1284703a 	and	r2,r2,r10
8112aee8:	2248703a 	and	r4,r4,r9
8112aeec:	10800414 	ori	r2,r2,16
8112aef0:	21000094 	ori	r4,r4,2
8112aef4:	003fef06 	br	8112aeb4 <__reset+0xfb10aeb4>
8112aef8:	02c18004 	movi	r11,1536
8112aefc:	01000044 	movi	r4,1
8112af00:	00800204 	movi	r2,8
8112af04:	003fe706 	br	8112aea4 <__reset+0xfb10aea4>
8112af08:	0017883a 	mov	r11,zero
8112af0c:	0009883a 	mov	r4,zero
8112af10:	00800104 	movi	r2,4
8112af14:	003fe306 	br	8112aea4 <__reset+0xfb10aea4>

8112af18 <_fread_r>:
8112af18:	defff404 	addi	sp,sp,-48
8112af1c:	de00012e 	bgeu	sp,et,8112af24 <_fread_r+0xc>
8112af20:	003b68fa 	trap	3
8112af24:	dd800815 	stw	r22,32(sp)
8112af28:	39ad383a 	mul	r22,r7,r6
8112af2c:	dc000215 	stw	r16,8(sp)
8112af30:	dfc00b15 	stw	ra,44(sp)
8112af34:	df000a15 	stw	fp,40(sp)
8112af38:	ddc00915 	stw	r23,36(sp)
8112af3c:	dd400715 	stw	r21,28(sp)
8112af40:	dd000615 	stw	r20,24(sp)
8112af44:	dcc00515 	stw	r19,20(sp)
8112af48:	dc800415 	stw	r18,16(sp)
8112af4c:	dc400315 	stw	r17,12(sp)
8112af50:	dc000c17 	ldw	r16,48(sp)
8112af54:	b0003b26 	beq	r22,zero,8112b044 <_fread_r+0x12c>
8112af58:	302f883a 	mov	r23,r6
8112af5c:	382b883a 	mov	r21,r7
8112af60:	2029883a 	mov	r20,r4
8112af64:	2827883a 	mov	r19,r5
8112af68:	20000226 	beq	r4,zero,8112af74 <_fread_r+0x5c>
8112af6c:	20800e17 	ldw	r2,56(r4)
8112af70:	10006e26 	beq	r2,zero,8112b12c <_fread_r+0x214>
8112af74:	8080030b 	ldhu	r2,12(r16)
8112af78:	10c8000c 	andi	r3,r2,8192
8112af7c:	1800061e 	bne	r3,zero,8112af98 <_fread_r+0x80>
8112af80:	81001917 	ldw	r4,100(r16)
8112af84:	00f7ffc4 	movi	r3,-8193
8112af88:	10880014 	ori	r2,r2,8192
8112af8c:	20c6703a 	and	r3,r4,r3
8112af90:	8080030d 	sth	r2,12(r16)
8112af94:	80c01915 	stw	r3,100(r16)
8112af98:	84400117 	ldw	r17,4(r16)
8112af9c:	88005f16 	blt	r17,zero,8112b11c <_fread_r+0x204>
8112afa0:	8809883a 	mov	r4,r17
8112afa4:	1080008c 	andi	r2,r2,2
8112afa8:	1000281e 	bne	r2,zero,8112b04c <_fread_r+0x134>
8112afac:	b025883a 	mov	r18,r22
8112afb0:	00000b06 	br	8112afe0 <_fread_r+0xc8>
8112afb4:	11220540 	call	81122054 <memcpy>
8112afb8:	80800017 	ldw	r2,0(r16)
8112afbc:	9c67883a 	add	r19,r19,r17
8112afc0:	9465c83a 	sub	r18,r18,r17
8112afc4:	1463883a 	add	r17,r2,r17
8112afc8:	800b883a 	mov	r5,r16
8112afcc:	a009883a 	mov	r4,r20
8112afd0:	84400015 	stw	r17,0(r16)
8112afd4:	11226200 	call	81122620 <__srefill_r>
8112afd8:	10004c1e 	bne	r2,zero,8112b10c <_fread_r+0x1f4>
8112afdc:	84400117 	ldw	r17,4(r16)
8112afe0:	880d883a 	mov	r6,r17
8112afe4:	9809883a 	mov	r4,r19
8112afe8:	81400017 	ldw	r5,0(r16)
8112afec:	8cbff136 	bltu	r17,r18,8112afb4 <__reset+0xfb10afb4>
8112aff0:	900d883a 	mov	r6,r18
8112aff4:	11220540 	call	81122054 <memcpy>
8112aff8:	80c00117 	ldw	r3,4(r16)
8112affc:	81000017 	ldw	r4,0(r16)
8112b000:	a805883a 	mov	r2,r21
8112b004:	1c87c83a 	sub	r3,r3,r18
8112b008:	24a5883a 	add	r18,r4,r18
8112b00c:	80c00115 	stw	r3,4(r16)
8112b010:	84800015 	stw	r18,0(r16)
8112b014:	dfc00b17 	ldw	ra,44(sp)
8112b018:	df000a17 	ldw	fp,40(sp)
8112b01c:	ddc00917 	ldw	r23,36(sp)
8112b020:	dd800817 	ldw	r22,32(sp)
8112b024:	dd400717 	ldw	r21,28(sp)
8112b028:	dd000617 	ldw	r20,24(sp)
8112b02c:	dcc00517 	ldw	r19,20(sp)
8112b030:	dc800417 	ldw	r18,16(sp)
8112b034:	dc400317 	ldw	r17,12(sp)
8112b038:	dc000217 	ldw	r16,8(sp)
8112b03c:	dec00c04 	addi	sp,sp,48
8112b040:	f800283a 	ret
8112b044:	0005883a 	mov	r2,zero
8112b048:	003ff206 	br	8112b014 <__reset+0xfb10b014>
8112b04c:	b007883a 	mov	r3,r22
8112b050:	2580012e 	bgeu	r4,r22,8112b058 <_fread_r+0x140>
8112b054:	2007883a 	mov	r3,r4
8112b058:	81400017 	ldw	r5,0(r16)
8112b05c:	180d883a 	mov	r6,r3
8112b060:	9809883a 	mov	r4,r19
8112b064:	d8c00115 	stw	r3,4(sp)
8112b068:	11220540 	call	81122054 <memcpy>
8112b06c:	d8c00117 	ldw	r3,4(sp)
8112b070:	84400017 	ldw	r17,0(r16)
8112b074:	80800117 	ldw	r2,4(r16)
8112b078:	81400c17 	ldw	r5,48(r16)
8112b07c:	88e3883a 	add	r17,r17,r3
8112b080:	10c5c83a 	sub	r2,r2,r3
8112b084:	84400015 	stw	r17,0(r16)
8112b088:	80800115 	stw	r2,4(r16)
8112b08c:	b0e5c83a 	sub	r18,r22,r3
8112b090:	28002b26 	beq	r5,zero,8112b140 <_fread_r+0x228>
8112b094:	90002b26 	beq	r18,zero,8112b144 <_fread_r+0x22c>
8112b098:	80801004 	addi	r2,r16,64
8112b09c:	28800526 	beq	r5,r2,8112b0b4 <_fread_r+0x19c>
8112b0a0:	a009883a 	mov	r4,r20
8112b0a4:	d8c00115 	stw	r3,4(sp)
8112b0a8:	112b2b40 	call	8112b2b4 <_free_r>
8112b0ac:	d8c00117 	ldw	r3,4(sp)
8112b0b0:	84400017 	ldw	r17,0(r16)
8112b0b4:	80000c15 	stw	zero,48(r16)
8112b0b8:	80800517 	ldw	r2,20(r16)
8112b0bc:	87000417 	ldw	fp,16(r16)
8112b0c0:	98e7883a 	add	r19,r19,r3
8112b0c4:	d8800015 	stw	r2,0(sp)
8112b0c8:	00000106 	br	8112b0d0 <_fread_r+0x1b8>
8112b0cc:	90001d26 	beq	r18,zero,8112b144 <_fread_r+0x22c>
8112b0d0:	84c00415 	stw	r19,16(r16)
8112b0d4:	84800515 	stw	r18,20(r16)
8112b0d8:	84c00015 	stw	r19,0(r16)
8112b0dc:	a009883a 	mov	r4,r20
8112b0e0:	800b883a 	mov	r5,r16
8112b0e4:	11226200 	call	81122620 <__srefill_r>
8112b0e8:	d9000017 	ldw	r4,0(sp)
8112b0ec:	80c00117 	ldw	r3,4(r16)
8112b0f0:	87000415 	stw	fp,16(r16)
8112b0f4:	81000515 	stw	r4,20(r16)
8112b0f8:	84400015 	stw	r17,0(r16)
8112b0fc:	80000115 	stw	zero,4(r16)
8112b100:	90e5c83a 	sub	r18,r18,r3
8112b104:	98e7883a 	add	r19,r19,r3
8112b108:	103ff026 	beq	r2,zero,8112b0cc <__reset+0xfb10b0cc>
8112b10c:	b80b883a 	mov	r5,r23
8112b110:	b489c83a 	sub	r4,r22,r18
8112b114:	11345c00 	call	811345c0 <__udivsi3>
8112b118:	003fbe06 	br	8112b014 <__reset+0xfb10b014>
8112b11c:	80000115 	stw	zero,4(r16)
8112b120:	0009883a 	mov	r4,zero
8112b124:	0023883a 	mov	r17,zero
8112b128:	003f9e06 	br	8112afa4 <__reset+0xfb10afa4>
8112b12c:	112ae1c0 	call	8112ae1c <__sinit>
8112b130:	8080030b 	ldhu	r2,12(r16)
8112b134:	10c8000c 	andi	r3,r2,8192
8112b138:	183f971e 	bne	r3,zero,8112af98 <__reset+0xfb10af98>
8112b13c:	003f9006 	br	8112af80 <__reset+0xfb10af80>
8112b140:	903fdd1e 	bne	r18,zero,8112b0b8 <__reset+0xfb10b0b8>
8112b144:	a805883a 	mov	r2,r21
8112b148:	003fb206 	br	8112b014 <__reset+0xfb10b014>

8112b14c <fread>:
8112b14c:	defffe04 	addi	sp,sp,-8
8112b150:	00a04574 	movhi	r2,33045
8112b154:	de00012e 	bgeu	sp,et,8112b15c <fread+0x10>
8112b158:	003b68fa 	trap	3
8112b15c:	108ad804 	addi	r2,r2,11104
8112b160:	d9c00015 	stw	r7,0(sp)
8112b164:	300f883a 	mov	r7,r6
8112b168:	280d883a 	mov	r6,r5
8112b16c:	200b883a 	mov	r5,r4
8112b170:	11000017 	ldw	r4,0(r2)
8112b174:	dfc00115 	stw	ra,4(sp)
8112b178:	112af180 	call	8112af18 <_fread_r>
8112b17c:	dfc00117 	ldw	ra,4(sp)
8112b180:	dec00204 	addi	sp,sp,8
8112b184:	f800283a 	ret

8112b188 <_malloc_trim_r>:
8112b188:	defffb04 	addi	sp,sp,-20
8112b18c:	de00012e 	bgeu	sp,et,8112b194 <_malloc_trim_r+0xc>
8112b190:	003b68fa 	trap	3
8112b194:	dcc00315 	stw	r19,12(sp)
8112b198:	04e04574 	movhi	r19,33045
8112b19c:	dc800215 	stw	r18,8(sp)
8112b1a0:	dc400115 	stw	r17,4(sp)
8112b1a4:	dc000015 	stw	r16,0(sp)
8112b1a8:	dfc00415 	stw	ra,16(sp)
8112b1ac:	2821883a 	mov	r16,r5
8112b1b0:	9cc49604 	addi	r19,r19,4696
8112b1b4:	2025883a 	mov	r18,r4
8112b1b8:	1137a7c0 	call	81137a7c <__malloc_lock>
8112b1bc:	98800217 	ldw	r2,8(r19)
8112b1c0:	14400117 	ldw	r17,4(r2)
8112b1c4:	00bfff04 	movi	r2,-4
8112b1c8:	88a2703a 	and	r17,r17,r2
8112b1cc:	8c21c83a 	sub	r16,r17,r16
8112b1d0:	8403fbc4 	addi	r16,r16,4079
8112b1d4:	8020d33a 	srli	r16,r16,12
8112b1d8:	0083ffc4 	movi	r2,4095
8112b1dc:	843fffc4 	addi	r16,r16,-1
8112b1e0:	8020933a 	slli	r16,r16,12
8112b1e4:	1400060e 	bge	r2,r16,8112b200 <_malloc_trim_r+0x78>
8112b1e8:	000b883a 	mov	r5,zero
8112b1ec:	9009883a 	mov	r4,r18
8112b1f0:	11227fc0 	call	811227fc <_sbrk_r>
8112b1f4:	98c00217 	ldw	r3,8(r19)
8112b1f8:	1c47883a 	add	r3,r3,r17
8112b1fc:	10c00a26 	beq	r2,r3,8112b228 <_malloc_trim_r+0xa0>
8112b200:	9009883a 	mov	r4,r18
8112b204:	1137ba40 	call	81137ba4 <__malloc_unlock>
8112b208:	0005883a 	mov	r2,zero
8112b20c:	dfc00417 	ldw	ra,16(sp)
8112b210:	dcc00317 	ldw	r19,12(sp)
8112b214:	dc800217 	ldw	r18,8(sp)
8112b218:	dc400117 	ldw	r17,4(sp)
8112b21c:	dc000017 	ldw	r16,0(sp)
8112b220:	dec00504 	addi	sp,sp,20
8112b224:	f800283a 	ret
8112b228:	040bc83a 	sub	r5,zero,r16
8112b22c:	9009883a 	mov	r4,r18
8112b230:	11227fc0 	call	811227fc <_sbrk_r>
8112b234:	00ffffc4 	movi	r3,-1
8112b238:	10c00d26 	beq	r2,r3,8112b270 <_malloc_trim_r+0xe8>
8112b23c:	00e04574 	movhi	r3,33045
8112b240:	18cbdb04 	addi	r3,r3,12140
8112b244:	18800017 	ldw	r2,0(r3)
8112b248:	99000217 	ldw	r4,8(r19)
8112b24c:	8c23c83a 	sub	r17,r17,r16
8112b250:	8c400054 	ori	r17,r17,1
8112b254:	1421c83a 	sub	r16,r2,r16
8112b258:	24400115 	stw	r17,4(r4)
8112b25c:	9009883a 	mov	r4,r18
8112b260:	1c000015 	stw	r16,0(r3)
8112b264:	1137ba40 	call	81137ba4 <__malloc_unlock>
8112b268:	00800044 	movi	r2,1
8112b26c:	003fe706 	br	8112b20c <__reset+0xfb10b20c>
8112b270:	000b883a 	mov	r5,zero
8112b274:	9009883a 	mov	r4,r18
8112b278:	11227fc0 	call	811227fc <_sbrk_r>
8112b27c:	99000217 	ldw	r4,8(r19)
8112b280:	014003c4 	movi	r5,15
8112b284:	1107c83a 	sub	r3,r2,r4
8112b288:	28ffdd0e 	bge	r5,r3,8112b200 <__reset+0xfb10b200>
8112b28c:	01604574 	movhi	r5,33045
8112b290:	294ad904 	addi	r5,r5,11108
8112b294:	29400017 	ldw	r5,0(r5)
8112b298:	18c00054 	ori	r3,r3,1
8112b29c:	20c00115 	stw	r3,4(r4)
8112b2a0:	00e04574 	movhi	r3,33045
8112b2a4:	1145c83a 	sub	r2,r2,r5
8112b2a8:	18cbdb04 	addi	r3,r3,12140
8112b2ac:	18800015 	stw	r2,0(r3)
8112b2b0:	003fd306 	br	8112b200 <__reset+0xfb10b200>

8112b2b4 <_free_r>:
8112b2b4:	28004326 	beq	r5,zero,8112b3c4 <_free_r+0x110>
8112b2b8:	defffd04 	addi	sp,sp,-12
8112b2bc:	de00012e 	bgeu	sp,et,8112b2c4 <_free_r+0x10>
8112b2c0:	003b68fa 	trap	3
8112b2c4:	dc400115 	stw	r17,4(sp)
8112b2c8:	dc000015 	stw	r16,0(sp)
8112b2cc:	2023883a 	mov	r17,r4
8112b2d0:	2821883a 	mov	r16,r5
8112b2d4:	dfc00215 	stw	ra,8(sp)
8112b2d8:	1137a7c0 	call	81137a7c <__malloc_lock>
8112b2dc:	81ffff17 	ldw	r7,-4(r16)
8112b2e0:	00bfff84 	movi	r2,-2
8112b2e4:	01204574 	movhi	r4,33045
8112b2e8:	81bffe04 	addi	r6,r16,-8
8112b2ec:	3884703a 	and	r2,r7,r2
8112b2f0:	21049604 	addi	r4,r4,4696
8112b2f4:	308b883a 	add	r5,r6,r2
8112b2f8:	2a400117 	ldw	r9,4(r5)
8112b2fc:	22000217 	ldw	r8,8(r4)
8112b300:	00ffff04 	movi	r3,-4
8112b304:	48c6703a 	and	r3,r9,r3
8112b308:	2a005726 	beq	r5,r8,8112b468 <_free_r+0x1b4>
8112b30c:	28c00115 	stw	r3,4(r5)
8112b310:	39c0004c 	andi	r7,r7,1
8112b314:	3800091e 	bne	r7,zero,8112b33c <_free_r+0x88>
8112b318:	823ffe17 	ldw	r8,-8(r16)
8112b31c:	22400204 	addi	r9,r4,8
8112b320:	320dc83a 	sub	r6,r6,r8
8112b324:	31c00217 	ldw	r7,8(r6)
8112b328:	1205883a 	add	r2,r2,r8
8112b32c:	3a406526 	beq	r7,r9,8112b4c4 <_free_r+0x210>
8112b330:	32000317 	ldw	r8,12(r6)
8112b334:	3a000315 	stw	r8,12(r7)
8112b338:	41c00215 	stw	r7,8(r8)
8112b33c:	28cf883a 	add	r7,r5,r3
8112b340:	39c00117 	ldw	r7,4(r7)
8112b344:	39c0004c 	andi	r7,r7,1
8112b348:	38003a26 	beq	r7,zero,8112b434 <_free_r+0x180>
8112b34c:	10c00054 	ori	r3,r2,1
8112b350:	30c00115 	stw	r3,4(r6)
8112b354:	3087883a 	add	r3,r6,r2
8112b358:	18800015 	stw	r2,0(r3)
8112b35c:	00c07fc4 	movi	r3,511
8112b360:	18801936 	bltu	r3,r2,8112b3c8 <_free_r+0x114>
8112b364:	1004d0fa 	srli	r2,r2,3
8112b368:	01c00044 	movi	r7,1
8112b36c:	21400117 	ldw	r5,4(r4)
8112b370:	10c00044 	addi	r3,r2,1
8112b374:	18c7883a 	add	r3,r3,r3
8112b378:	1005d0ba 	srai	r2,r2,2
8112b37c:	18c7883a 	add	r3,r3,r3
8112b380:	18c7883a 	add	r3,r3,r3
8112b384:	1907883a 	add	r3,r3,r4
8112b388:	3884983a 	sll	r2,r7,r2
8112b38c:	19c00017 	ldw	r7,0(r3)
8112b390:	1a3ffe04 	addi	r8,r3,-8
8112b394:	1144b03a 	or	r2,r2,r5
8112b398:	32000315 	stw	r8,12(r6)
8112b39c:	31c00215 	stw	r7,8(r6)
8112b3a0:	20800115 	stw	r2,4(r4)
8112b3a4:	19800015 	stw	r6,0(r3)
8112b3a8:	39800315 	stw	r6,12(r7)
8112b3ac:	8809883a 	mov	r4,r17
8112b3b0:	dfc00217 	ldw	ra,8(sp)
8112b3b4:	dc400117 	ldw	r17,4(sp)
8112b3b8:	dc000017 	ldw	r16,0(sp)
8112b3bc:	dec00304 	addi	sp,sp,12
8112b3c0:	1137ba41 	jmpi	81137ba4 <__malloc_unlock>
8112b3c4:	f800283a 	ret
8112b3c8:	100ad27a 	srli	r5,r2,9
8112b3cc:	00c00104 	movi	r3,4
8112b3d0:	19404a36 	bltu	r3,r5,8112b4fc <_free_r+0x248>
8112b3d4:	100ad1ba 	srli	r5,r2,6
8112b3d8:	28c00e44 	addi	r3,r5,57
8112b3dc:	18c7883a 	add	r3,r3,r3
8112b3e0:	29400e04 	addi	r5,r5,56
8112b3e4:	18c7883a 	add	r3,r3,r3
8112b3e8:	18c7883a 	add	r3,r3,r3
8112b3ec:	1909883a 	add	r4,r3,r4
8112b3f0:	20c00017 	ldw	r3,0(r4)
8112b3f4:	01e04574 	movhi	r7,33045
8112b3f8:	213ffe04 	addi	r4,r4,-8
8112b3fc:	39c49604 	addi	r7,r7,4696
8112b400:	20c04426 	beq	r4,r3,8112b514 <_free_r+0x260>
8112b404:	01ffff04 	movi	r7,-4
8112b408:	19400117 	ldw	r5,4(r3)
8112b40c:	29ca703a 	and	r5,r5,r7
8112b410:	1140022e 	bgeu	r2,r5,8112b41c <_free_r+0x168>
8112b414:	18c00217 	ldw	r3,8(r3)
8112b418:	20fffb1e 	bne	r4,r3,8112b408 <__reset+0xfb10b408>
8112b41c:	19000317 	ldw	r4,12(r3)
8112b420:	31000315 	stw	r4,12(r6)
8112b424:	30c00215 	stw	r3,8(r6)
8112b428:	21800215 	stw	r6,8(r4)
8112b42c:	19800315 	stw	r6,12(r3)
8112b430:	003fde06 	br	8112b3ac <__reset+0xfb10b3ac>
8112b434:	29c00217 	ldw	r7,8(r5)
8112b438:	10c5883a 	add	r2,r2,r3
8112b43c:	00e04574 	movhi	r3,33045
8112b440:	18c49804 	addi	r3,r3,4704
8112b444:	38c03b26 	beq	r7,r3,8112b534 <_free_r+0x280>
8112b448:	2a000317 	ldw	r8,12(r5)
8112b44c:	11400054 	ori	r5,r2,1
8112b450:	3087883a 	add	r3,r6,r2
8112b454:	3a000315 	stw	r8,12(r7)
8112b458:	41c00215 	stw	r7,8(r8)
8112b45c:	31400115 	stw	r5,4(r6)
8112b460:	18800015 	stw	r2,0(r3)
8112b464:	003fbd06 	br	8112b35c <__reset+0xfb10b35c>
8112b468:	39c0004c 	andi	r7,r7,1
8112b46c:	10c5883a 	add	r2,r2,r3
8112b470:	3800071e 	bne	r7,zero,8112b490 <_free_r+0x1dc>
8112b474:	81fffe17 	ldw	r7,-8(r16)
8112b478:	31cdc83a 	sub	r6,r6,r7
8112b47c:	30c00317 	ldw	r3,12(r6)
8112b480:	31400217 	ldw	r5,8(r6)
8112b484:	11c5883a 	add	r2,r2,r7
8112b488:	28c00315 	stw	r3,12(r5)
8112b48c:	19400215 	stw	r5,8(r3)
8112b490:	10c00054 	ori	r3,r2,1
8112b494:	30c00115 	stw	r3,4(r6)
8112b498:	00e04574 	movhi	r3,33045
8112b49c:	18cada04 	addi	r3,r3,11112
8112b4a0:	18c00017 	ldw	r3,0(r3)
8112b4a4:	21800215 	stw	r6,8(r4)
8112b4a8:	10ffc036 	bltu	r2,r3,8112b3ac <__reset+0xfb10b3ac>
8112b4ac:	00a04574 	movhi	r2,33045
8112b4b0:	108b4e04 	addi	r2,r2,11576
8112b4b4:	11400017 	ldw	r5,0(r2)
8112b4b8:	8809883a 	mov	r4,r17
8112b4bc:	112b1880 	call	8112b188 <_malloc_trim_r>
8112b4c0:	003fba06 	br	8112b3ac <__reset+0xfb10b3ac>
8112b4c4:	28c9883a 	add	r4,r5,r3
8112b4c8:	21000117 	ldw	r4,4(r4)
8112b4cc:	2100004c 	andi	r4,r4,1
8112b4d0:	2000391e 	bne	r4,zero,8112b5b8 <_free_r+0x304>
8112b4d4:	29c00217 	ldw	r7,8(r5)
8112b4d8:	29000317 	ldw	r4,12(r5)
8112b4dc:	1885883a 	add	r2,r3,r2
8112b4e0:	10c00054 	ori	r3,r2,1
8112b4e4:	39000315 	stw	r4,12(r7)
8112b4e8:	21c00215 	stw	r7,8(r4)
8112b4ec:	30c00115 	stw	r3,4(r6)
8112b4f0:	308d883a 	add	r6,r6,r2
8112b4f4:	30800015 	stw	r2,0(r6)
8112b4f8:	003fac06 	br	8112b3ac <__reset+0xfb10b3ac>
8112b4fc:	00c00504 	movi	r3,20
8112b500:	19401536 	bltu	r3,r5,8112b558 <_free_r+0x2a4>
8112b504:	28c01704 	addi	r3,r5,92
8112b508:	18c7883a 	add	r3,r3,r3
8112b50c:	294016c4 	addi	r5,r5,91
8112b510:	003fb406 	br	8112b3e4 <__reset+0xfb10b3e4>
8112b514:	280bd0ba 	srai	r5,r5,2
8112b518:	00c00044 	movi	r3,1
8112b51c:	38800117 	ldw	r2,4(r7)
8112b520:	194a983a 	sll	r5,r3,r5
8112b524:	2007883a 	mov	r3,r4
8112b528:	2884b03a 	or	r2,r5,r2
8112b52c:	38800115 	stw	r2,4(r7)
8112b530:	003fbb06 	br	8112b420 <__reset+0xfb10b420>
8112b534:	21800515 	stw	r6,20(r4)
8112b538:	21800415 	stw	r6,16(r4)
8112b53c:	10c00054 	ori	r3,r2,1
8112b540:	31c00315 	stw	r7,12(r6)
8112b544:	31c00215 	stw	r7,8(r6)
8112b548:	30c00115 	stw	r3,4(r6)
8112b54c:	308d883a 	add	r6,r6,r2
8112b550:	30800015 	stw	r2,0(r6)
8112b554:	003f9506 	br	8112b3ac <__reset+0xfb10b3ac>
8112b558:	00c01504 	movi	r3,84
8112b55c:	19400536 	bltu	r3,r5,8112b574 <_free_r+0x2c0>
8112b560:	100ad33a 	srli	r5,r2,12
8112b564:	28c01bc4 	addi	r3,r5,111
8112b568:	18c7883a 	add	r3,r3,r3
8112b56c:	29401b84 	addi	r5,r5,110
8112b570:	003f9c06 	br	8112b3e4 <__reset+0xfb10b3e4>
8112b574:	00c05504 	movi	r3,340
8112b578:	19400536 	bltu	r3,r5,8112b590 <_free_r+0x2dc>
8112b57c:	100ad3fa 	srli	r5,r2,15
8112b580:	28c01e04 	addi	r3,r5,120
8112b584:	18c7883a 	add	r3,r3,r3
8112b588:	29401dc4 	addi	r5,r5,119
8112b58c:	003f9506 	br	8112b3e4 <__reset+0xfb10b3e4>
8112b590:	00c15504 	movi	r3,1364
8112b594:	19400536 	bltu	r3,r5,8112b5ac <_free_r+0x2f8>
8112b598:	100ad4ba 	srli	r5,r2,18
8112b59c:	28c01f44 	addi	r3,r5,125
8112b5a0:	18c7883a 	add	r3,r3,r3
8112b5a4:	29401f04 	addi	r5,r5,124
8112b5a8:	003f8e06 	br	8112b3e4 <__reset+0xfb10b3e4>
8112b5ac:	00c03f84 	movi	r3,254
8112b5b0:	01401f84 	movi	r5,126
8112b5b4:	003f8b06 	br	8112b3e4 <__reset+0xfb10b3e4>
8112b5b8:	10c00054 	ori	r3,r2,1
8112b5bc:	30c00115 	stw	r3,4(r6)
8112b5c0:	308d883a 	add	r6,r6,r2
8112b5c4:	30800015 	stw	r2,0(r6)
8112b5c8:	003f7806 	br	8112b3ac <__reset+0xfb10b3ac>

8112b5cc <__sfvwrite_r>:
8112b5cc:	30800217 	ldw	r2,8(r6)
8112b5d0:	10006926 	beq	r2,zero,8112b778 <__sfvwrite_r+0x1ac>
8112b5d4:	defff404 	addi	sp,sp,-48
8112b5d8:	de00012e 	bgeu	sp,et,8112b5e0 <__sfvwrite_r+0x14>
8112b5dc:	003b68fa 	trap	3
8112b5e0:	28c0030b 	ldhu	r3,12(r5)
8112b5e4:	dd400715 	stw	r21,28(sp)
8112b5e8:	dd000615 	stw	r20,24(sp)
8112b5ec:	dc000215 	stw	r16,8(sp)
8112b5f0:	dfc00b15 	stw	ra,44(sp)
8112b5f4:	df000a15 	stw	fp,40(sp)
8112b5f8:	ddc00915 	stw	r23,36(sp)
8112b5fc:	dd800815 	stw	r22,32(sp)
8112b600:	dcc00515 	stw	r19,20(sp)
8112b604:	dc800415 	stw	r18,16(sp)
8112b608:	dc400315 	stw	r17,12(sp)
8112b60c:	1880020c 	andi	r2,r3,8
8112b610:	2821883a 	mov	r16,r5
8112b614:	202b883a 	mov	r21,r4
8112b618:	3029883a 	mov	r20,r6
8112b61c:	10002726 	beq	r2,zero,8112b6bc <__sfvwrite_r+0xf0>
8112b620:	28800417 	ldw	r2,16(r5)
8112b624:	10002526 	beq	r2,zero,8112b6bc <__sfvwrite_r+0xf0>
8112b628:	1880008c 	andi	r2,r3,2
8112b62c:	a4400017 	ldw	r17,0(r20)
8112b630:	10002a26 	beq	r2,zero,8112b6dc <__sfvwrite_r+0x110>
8112b634:	05a00034 	movhi	r22,32768
8112b638:	0027883a 	mov	r19,zero
8112b63c:	0025883a 	mov	r18,zero
8112b640:	b5bf0004 	addi	r22,r22,-1024
8112b644:	980d883a 	mov	r6,r19
8112b648:	a809883a 	mov	r4,r21
8112b64c:	90004626 	beq	r18,zero,8112b768 <__sfvwrite_r+0x19c>
8112b650:	900f883a 	mov	r7,r18
8112b654:	b480022e 	bgeu	r22,r18,8112b660 <__sfvwrite_r+0x94>
8112b658:	01e00034 	movhi	r7,32768
8112b65c:	39ff0004 	addi	r7,r7,-1024
8112b660:	80800917 	ldw	r2,36(r16)
8112b664:	81400717 	ldw	r5,28(r16)
8112b668:	103ee83a 	callr	r2
8112b66c:	0080570e 	bge	zero,r2,8112b7cc <__sfvwrite_r+0x200>
8112b670:	a0c00217 	ldw	r3,8(r20)
8112b674:	98a7883a 	add	r19,r19,r2
8112b678:	90a5c83a 	sub	r18,r18,r2
8112b67c:	1885c83a 	sub	r2,r3,r2
8112b680:	a0800215 	stw	r2,8(r20)
8112b684:	103fef1e 	bne	r2,zero,8112b644 <__reset+0xfb10b644>
8112b688:	0005883a 	mov	r2,zero
8112b68c:	dfc00b17 	ldw	ra,44(sp)
8112b690:	df000a17 	ldw	fp,40(sp)
8112b694:	ddc00917 	ldw	r23,36(sp)
8112b698:	dd800817 	ldw	r22,32(sp)
8112b69c:	dd400717 	ldw	r21,28(sp)
8112b6a0:	dd000617 	ldw	r20,24(sp)
8112b6a4:	dcc00517 	ldw	r19,20(sp)
8112b6a8:	dc800417 	ldw	r18,16(sp)
8112b6ac:	dc400317 	ldw	r17,12(sp)
8112b6b0:	dc000217 	ldw	r16,8(sp)
8112b6b4:	dec00c04 	addi	sp,sp,48
8112b6b8:	f800283a 	ret
8112b6bc:	800b883a 	mov	r5,r16
8112b6c0:	a809883a 	mov	r4,r21
8112b6c4:	1128dac0 	call	81128dac <__swsetup_r>
8112b6c8:	1000eb1e 	bne	r2,zero,8112ba78 <__sfvwrite_r+0x4ac>
8112b6cc:	80c0030b 	ldhu	r3,12(r16)
8112b6d0:	a4400017 	ldw	r17,0(r20)
8112b6d4:	1880008c 	andi	r2,r3,2
8112b6d8:	103fd61e 	bne	r2,zero,8112b634 <__reset+0xfb10b634>
8112b6dc:	1880004c 	andi	r2,r3,1
8112b6e0:	10003f1e 	bne	r2,zero,8112b7e0 <__sfvwrite_r+0x214>
8112b6e4:	0039883a 	mov	fp,zero
8112b6e8:	0025883a 	mov	r18,zero
8112b6ec:	90001a26 	beq	r18,zero,8112b758 <__sfvwrite_r+0x18c>
8112b6f0:	1880800c 	andi	r2,r3,512
8112b6f4:	84c00217 	ldw	r19,8(r16)
8112b6f8:	10002126 	beq	r2,zero,8112b780 <__sfvwrite_r+0x1b4>
8112b6fc:	982f883a 	mov	r23,r19
8112b700:	94c09336 	bltu	r18,r19,8112b950 <__sfvwrite_r+0x384>
8112b704:	1881200c 	andi	r2,r3,1152
8112b708:	10009e1e 	bne	r2,zero,8112b984 <__sfvwrite_r+0x3b8>
8112b70c:	81000017 	ldw	r4,0(r16)
8112b710:	b80d883a 	mov	r6,r23
8112b714:	e00b883a 	mov	r5,fp
8112b718:	112c1280 	call	8112c128 <memmove>
8112b71c:	80c00217 	ldw	r3,8(r16)
8112b720:	81000017 	ldw	r4,0(r16)
8112b724:	9005883a 	mov	r2,r18
8112b728:	1ce7c83a 	sub	r19,r3,r19
8112b72c:	25cf883a 	add	r7,r4,r23
8112b730:	84c00215 	stw	r19,8(r16)
8112b734:	81c00015 	stw	r7,0(r16)
8112b738:	a0c00217 	ldw	r3,8(r20)
8112b73c:	e0b9883a 	add	fp,fp,r2
8112b740:	90a5c83a 	sub	r18,r18,r2
8112b744:	18a7c83a 	sub	r19,r3,r2
8112b748:	a4c00215 	stw	r19,8(r20)
8112b74c:	983fce26 	beq	r19,zero,8112b688 <__reset+0xfb10b688>
8112b750:	80c0030b 	ldhu	r3,12(r16)
8112b754:	903fe61e 	bne	r18,zero,8112b6f0 <__reset+0xfb10b6f0>
8112b758:	8f000017 	ldw	fp,0(r17)
8112b75c:	8c800117 	ldw	r18,4(r17)
8112b760:	8c400204 	addi	r17,r17,8
8112b764:	003fe106 	br	8112b6ec <__reset+0xfb10b6ec>
8112b768:	8cc00017 	ldw	r19,0(r17)
8112b76c:	8c800117 	ldw	r18,4(r17)
8112b770:	8c400204 	addi	r17,r17,8
8112b774:	003fb306 	br	8112b644 <__reset+0xfb10b644>
8112b778:	0005883a 	mov	r2,zero
8112b77c:	f800283a 	ret
8112b780:	81000017 	ldw	r4,0(r16)
8112b784:	80800417 	ldw	r2,16(r16)
8112b788:	11005736 	bltu	r2,r4,8112b8e8 <__sfvwrite_r+0x31c>
8112b78c:	85c00517 	ldw	r23,20(r16)
8112b790:	95c05536 	bltu	r18,r23,8112b8e8 <__sfvwrite_r+0x31c>
8112b794:	00a00034 	movhi	r2,32768
8112b798:	10bfffc4 	addi	r2,r2,-1
8112b79c:	9009883a 	mov	r4,r18
8112b7a0:	1480012e 	bgeu	r2,r18,8112b7a8 <__sfvwrite_r+0x1dc>
8112b7a4:	1009883a 	mov	r4,r2
8112b7a8:	b80b883a 	mov	r5,r23
8112b7ac:	11344c80 	call	811344c8 <__divsi3>
8112b7b0:	15cf383a 	mul	r7,r2,r23
8112b7b4:	81400717 	ldw	r5,28(r16)
8112b7b8:	80800917 	ldw	r2,36(r16)
8112b7bc:	e00d883a 	mov	r6,fp
8112b7c0:	a809883a 	mov	r4,r21
8112b7c4:	103ee83a 	callr	r2
8112b7c8:	00bfdb16 	blt	zero,r2,8112b738 <__reset+0xfb10b738>
8112b7cc:	8080030b 	ldhu	r2,12(r16)
8112b7d0:	10801014 	ori	r2,r2,64
8112b7d4:	8080030d 	sth	r2,12(r16)
8112b7d8:	00bfffc4 	movi	r2,-1
8112b7dc:	003fab06 	br	8112b68c <__reset+0xfb10b68c>
8112b7e0:	0027883a 	mov	r19,zero
8112b7e4:	0011883a 	mov	r8,zero
8112b7e8:	0039883a 	mov	fp,zero
8112b7ec:	0025883a 	mov	r18,zero
8112b7f0:	90001f26 	beq	r18,zero,8112b870 <__sfvwrite_r+0x2a4>
8112b7f4:	40005a26 	beq	r8,zero,8112b960 <__sfvwrite_r+0x394>
8112b7f8:	982d883a 	mov	r22,r19
8112b7fc:	94c0012e 	bgeu	r18,r19,8112b804 <__sfvwrite_r+0x238>
8112b800:	902d883a 	mov	r22,r18
8112b804:	81000017 	ldw	r4,0(r16)
8112b808:	80800417 	ldw	r2,16(r16)
8112b80c:	b02f883a 	mov	r23,r22
8112b810:	81c00517 	ldw	r7,20(r16)
8112b814:	1100032e 	bgeu	r2,r4,8112b824 <__sfvwrite_r+0x258>
8112b818:	80c00217 	ldw	r3,8(r16)
8112b81c:	38c7883a 	add	r3,r7,r3
8112b820:	1d801816 	blt	r3,r22,8112b884 <__sfvwrite_r+0x2b8>
8112b824:	b1c03e16 	blt	r22,r7,8112b920 <__sfvwrite_r+0x354>
8112b828:	80800917 	ldw	r2,36(r16)
8112b82c:	81400717 	ldw	r5,28(r16)
8112b830:	e00d883a 	mov	r6,fp
8112b834:	da000115 	stw	r8,4(sp)
8112b838:	a809883a 	mov	r4,r21
8112b83c:	103ee83a 	callr	r2
8112b840:	102f883a 	mov	r23,r2
8112b844:	da000117 	ldw	r8,4(sp)
8112b848:	00bfe00e 	bge	zero,r2,8112b7cc <__reset+0xfb10b7cc>
8112b84c:	9de7c83a 	sub	r19,r19,r23
8112b850:	98001f26 	beq	r19,zero,8112b8d0 <__sfvwrite_r+0x304>
8112b854:	a0800217 	ldw	r2,8(r20)
8112b858:	e5f9883a 	add	fp,fp,r23
8112b85c:	95e5c83a 	sub	r18,r18,r23
8112b860:	15efc83a 	sub	r23,r2,r23
8112b864:	a5c00215 	stw	r23,8(r20)
8112b868:	b83f8726 	beq	r23,zero,8112b688 <__reset+0xfb10b688>
8112b86c:	903fe11e 	bne	r18,zero,8112b7f4 <__reset+0xfb10b7f4>
8112b870:	8f000017 	ldw	fp,0(r17)
8112b874:	8c800117 	ldw	r18,4(r17)
8112b878:	0011883a 	mov	r8,zero
8112b87c:	8c400204 	addi	r17,r17,8
8112b880:	003fdb06 	br	8112b7f0 <__reset+0xfb10b7f0>
8112b884:	180d883a 	mov	r6,r3
8112b888:	e00b883a 	mov	r5,fp
8112b88c:	da000115 	stw	r8,4(sp)
8112b890:	d8c00015 	stw	r3,0(sp)
8112b894:	112c1280 	call	8112c128 <memmove>
8112b898:	d8c00017 	ldw	r3,0(sp)
8112b89c:	80800017 	ldw	r2,0(r16)
8112b8a0:	800b883a 	mov	r5,r16
8112b8a4:	a809883a 	mov	r4,r21
8112b8a8:	10c5883a 	add	r2,r2,r3
8112b8ac:	80800015 	stw	r2,0(r16)
8112b8b0:	d8c00015 	stw	r3,0(sp)
8112b8b4:	112aa200 	call	8112aa20 <_fflush_r>
8112b8b8:	d8c00017 	ldw	r3,0(sp)
8112b8bc:	da000117 	ldw	r8,4(sp)
8112b8c0:	103fc21e 	bne	r2,zero,8112b7cc <__reset+0xfb10b7cc>
8112b8c4:	182f883a 	mov	r23,r3
8112b8c8:	9de7c83a 	sub	r19,r19,r23
8112b8cc:	983fe11e 	bne	r19,zero,8112b854 <__reset+0xfb10b854>
8112b8d0:	800b883a 	mov	r5,r16
8112b8d4:	a809883a 	mov	r4,r21
8112b8d8:	112aa200 	call	8112aa20 <_fflush_r>
8112b8dc:	103fbb1e 	bne	r2,zero,8112b7cc <__reset+0xfb10b7cc>
8112b8e0:	0011883a 	mov	r8,zero
8112b8e4:	003fdb06 	br	8112b854 <__reset+0xfb10b854>
8112b8e8:	94c0012e 	bgeu	r18,r19,8112b8f0 <__sfvwrite_r+0x324>
8112b8ec:	9027883a 	mov	r19,r18
8112b8f0:	980d883a 	mov	r6,r19
8112b8f4:	e00b883a 	mov	r5,fp
8112b8f8:	112c1280 	call	8112c128 <memmove>
8112b8fc:	80800217 	ldw	r2,8(r16)
8112b900:	80c00017 	ldw	r3,0(r16)
8112b904:	14c5c83a 	sub	r2,r2,r19
8112b908:	1cc7883a 	add	r3,r3,r19
8112b90c:	80800215 	stw	r2,8(r16)
8112b910:	80c00015 	stw	r3,0(r16)
8112b914:	10004326 	beq	r2,zero,8112ba24 <__sfvwrite_r+0x458>
8112b918:	9805883a 	mov	r2,r19
8112b91c:	003f8606 	br	8112b738 <__reset+0xfb10b738>
8112b920:	b00d883a 	mov	r6,r22
8112b924:	e00b883a 	mov	r5,fp
8112b928:	da000115 	stw	r8,4(sp)
8112b92c:	112c1280 	call	8112c128 <memmove>
8112b930:	80800217 	ldw	r2,8(r16)
8112b934:	80c00017 	ldw	r3,0(r16)
8112b938:	da000117 	ldw	r8,4(sp)
8112b93c:	1585c83a 	sub	r2,r2,r22
8112b940:	1dad883a 	add	r22,r3,r22
8112b944:	80800215 	stw	r2,8(r16)
8112b948:	85800015 	stw	r22,0(r16)
8112b94c:	003fbf06 	br	8112b84c <__reset+0xfb10b84c>
8112b950:	81000017 	ldw	r4,0(r16)
8112b954:	9027883a 	mov	r19,r18
8112b958:	902f883a 	mov	r23,r18
8112b95c:	003f6c06 	br	8112b710 <__reset+0xfb10b710>
8112b960:	900d883a 	mov	r6,r18
8112b964:	01400284 	movi	r5,10
8112b968:	e009883a 	mov	r4,fp
8112b96c:	112c0440 	call	8112c044 <memchr>
8112b970:	10003e26 	beq	r2,zero,8112ba6c <__sfvwrite_r+0x4a0>
8112b974:	10800044 	addi	r2,r2,1
8112b978:	1727c83a 	sub	r19,r2,fp
8112b97c:	02000044 	movi	r8,1
8112b980:	003f9d06 	br	8112b7f8 <__reset+0xfb10b7f8>
8112b984:	80800517 	ldw	r2,20(r16)
8112b988:	81400417 	ldw	r5,16(r16)
8112b98c:	81c00017 	ldw	r7,0(r16)
8112b990:	10a7883a 	add	r19,r2,r2
8112b994:	9885883a 	add	r2,r19,r2
8112b998:	1026d7fa 	srli	r19,r2,31
8112b99c:	396dc83a 	sub	r22,r7,r5
8112b9a0:	b1000044 	addi	r4,r22,1
8112b9a4:	9885883a 	add	r2,r19,r2
8112b9a8:	1027d07a 	srai	r19,r2,1
8112b9ac:	2485883a 	add	r2,r4,r18
8112b9b0:	980d883a 	mov	r6,r19
8112b9b4:	9880022e 	bgeu	r19,r2,8112b9c0 <__sfvwrite_r+0x3f4>
8112b9b8:	1027883a 	mov	r19,r2
8112b9bc:	100d883a 	mov	r6,r2
8112b9c0:	18c1000c 	andi	r3,r3,1024
8112b9c4:	18001c26 	beq	r3,zero,8112ba38 <__sfvwrite_r+0x46c>
8112b9c8:	300b883a 	mov	r5,r6
8112b9cc:	a809883a 	mov	r4,r21
8112b9d0:	11218400 	call	81121840 <_malloc_r>
8112b9d4:	102f883a 	mov	r23,r2
8112b9d8:	10002926 	beq	r2,zero,8112ba80 <__sfvwrite_r+0x4b4>
8112b9dc:	81400417 	ldw	r5,16(r16)
8112b9e0:	b00d883a 	mov	r6,r22
8112b9e4:	1009883a 	mov	r4,r2
8112b9e8:	11220540 	call	81122054 <memcpy>
8112b9ec:	8080030b 	ldhu	r2,12(r16)
8112b9f0:	00fedfc4 	movi	r3,-1153
8112b9f4:	10c4703a 	and	r2,r2,r3
8112b9f8:	10802014 	ori	r2,r2,128
8112b9fc:	8080030d 	sth	r2,12(r16)
8112ba00:	bd89883a 	add	r4,r23,r22
8112ba04:	9d8fc83a 	sub	r7,r19,r22
8112ba08:	85c00415 	stw	r23,16(r16)
8112ba0c:	84c00515 	stw	r19,20(r16)
8112ba10:	81000015 	stw	r4,0(r16)
8112ba14:	9027883a 	mov	r19,r18
8112ba18:	81c00215 	stw	r7,8(r16)
8112ba1c:	902f883a 	mov	r23,r18
8112ba20:	003f3b06 	br	8112b710 <__reset+0xfb10b710>
8112ba24:	800b883a 	mov	r5,r16
8112ba28:	a809883a 	mov	r4,r21
8112ba2c:	112aa200 	call	8112aa20 <_fflush_r>
8112ba30:	103fb926 	beq	r2,zero,8112b918 <__reset+0xfb10b918>
8112ba34:	003f6506 	br	8112b7cc <__reset+0xfb10b7cc>
8112ba38:	a809883a 	mov	r4,r21
8112ba3c:	112d3480 	call	8112d348 <_realloc_r>
8112ba40:	102f883a 	mov	r23,r2
8112ba44:	103fee1e 	bne	r2,zero,8112ba00 <__reset+0xfb10ba00>
8112ba48:	81400417 	ldw	r5,16(r16)
8112ba4c:	a809883a 	mov	r4,r21
8112ba50:	112b2b40 	call	8112b2b4 <_free_r>
8112ba54:	8080030b 	ldhu	r2,12(r16)
8112ba58:	00ffdfc4 	movi	r3,-129
8112ba5c:	1884703a 	and	r2,r3,r2
8112ba60:	00c00304 	movi	r3,12
8112ba64:	a8c00015 	stw	r3,0(r21)
8112ba68:	003f5906 	br	8112b7d0 <__reset+0xfb10b7d0>
8112ba6c:	94c00044 	addi	r19,r18,1
8112ba70:	02000044 	movi	r8,1
8112ba74:	003f6006 	br	8112b7f8 <__reset+0xfb10b7f8>
8112ba78:	00bfffc4 	movi	r2,-1
8112ba7c:	003f0306 	br	8112b68c <__reset+0xfb10b68c>
8112ba80:	00800304 	movi	r2,12
8112ba84:	a8800015 	stw	r2,0(r21)
8112ba88:	8080030b 	ldhu	r2,12(r16)
8112ba8c:	003f5006 	br	8112b7d0 <__reset+0xfb10b7d0>

8112ba90 <_fwalk>:
8112ba90:	defff704 	addi	sp,sp,-36
8112ba94:	de00012e 	bgeu	sp,et,8112ba9c <_fwalk+0xc>
8112ba98:	003b68fa 	trap	3
8112ba9c:	dd000415 	stw	r20,16(sp)
8112baa0:	dfc00815 	stw	ra,32(sp)
8112baa4:	ddc00715 	stw	r23,28(sp)
8112baa8:	dd800615 	stw	r22,24(sp)
8112baac:	dd400515 	stw	r21,20(sp)
8112bab0:	dcc00315 	stw	r19,12(sp)
8112bab4:	dc800215 	stw	r18,8(sp)
8112bab8:	dc400115 	stw	r17,4(sp)
8112babc:	dc000015 	stw	r16,0(sp)
8112bac0:	2500b804 	addi	r20,r4,736
8112bac4:	a0002326 	beq	r20,zero,8112bb54 <_fwalk+0xc4>
8112bac8:	282b883a 	mov	r21,r5
8112bacc:	002f883a 	mov	r23,zero
8112bad0:	05800044 	movi	r22,1
8112bad4:	04ffffc4 	movi	r19,-1
8112bad8:	a4400117 	ldw	r17,4(r20)
8112badc:	a4800217 	ldw	r18,8(r20)
8112bae0:	8c7fffc4 	addi	r17,r17,-1
8112bae4:	88000d16 	blt	r17,zero,8112bb1c <_fwalk+0x8c>
8112bae8:	94000304 	addi	r16,r18,12
8112baec:	94800384 	addi	r18,r18,14
8112baf0:	8080000b 	ldhu	r2,0(r16)
8112baf4:	8c7fffc4 	addi	r17,r17,-1
8112baf8:	813ffd04 	addi	r4,r16,-12
8112bafc:	b080042e 	bgeu	r22,r2,8112bb10 <_fwalk+0x80>
8112bb00:	9080000f 	ldh	r2,0(r18)
8112bb04:	14c00226 	beq	r2,r19,8112bb10 <_fwalk+0x80>
8112bb08:	a83ee83a 	callr	r21
8112bb0c:	b8aeb03a 	or	r23,r23,r2
8112bb10:	84001a04 	addi	r16,r16,104
8112bb14:	94801a04 	addi	r18,r18,104
8112bb18:	8cfff51e 	bne	r17,r19,8112baf0 <__reset+0xfb10baf0>
8112bb1c:	a5000017 	ldw	r20,0(r20)
8112bb20:	a03fed1e 	bne	r20,zero,8112bad8 <__reset+0xfb10bad8>
8112bb24:	b805883a 	mov	r2,r23
8112bb28:	dfc00817 	ldw	ra,32(sp)
8112bb2c:	ddc00717 	ldw	r23,28(sp)
8112bb30:	dd800617 	ldw	r22,24(sp)
8112bb34:	dd400517 	ldw	r21,20(sp)
8112bb38:	dd000417 	ldw	r20,16(sp)
8112bb3c:	dcc00317 	ldw	r19,12(sp)
8112bb40:	dc800217 	ldw	r18,8(sp)
8112bb44:	dc400117 	ldw	r17,4(sp)
8112bb48:	dc000017 	ldw	r16,0(sp)
8112bb4c:	dec00904 	addi	sp,sp,36
8112bb50:	f800283a 	ret
8112bb54:	002f883a 	mov	r23,zero
8112bb58:	003ff206 	br	8112bb24 <__reset+0xfb10bb24>

8112bb5c <_fwalk_reent>:
8112bb5c:	defff704 	addi	sp,sp,-36
8112bb60:	de00012e 	bgeu	sp,et,8112bb68 <_fwalk_reent+0xc>
8112bb64:	003b68fa 	trap	3
8112bb68:	dd000415 	stw	r20,16(sp)
8112bb6c:	dfc00815 	stw	ra,32(sp)
8112bb70:	ddc00715 	stw	r23,28(sp)
8112bb74:	dd800615 	stw	r22,24(sp)
8112bb78:	dd400515 	stw	r21,20(sp)
8112bb7c:	dcc00315 	stw	r19,12(sp)
8112bb80:	dc800215 	stw	r18,8(sp)
8112bb84:	dc400115 	stw	r17,4(sp)
8112bb88:	dc000015 	stw	r16,0(sp)
8112bb8c:	2500b804 	addi	r20,r4,736
8112bb90:	a0002326 	beq	r20,zero,8112bc20 <_fwalk_reent+0xc4>
8112bb94:	282b883a 	mov	r21,r5
8112bb98:	2027883a 	mov	r19,r4
8112bb9c:	002f883a 	mov	r23,zero
8112bba0:	05800044 	movi	r22,1
8112bba4:	04bfffc4 	movi	r18,-1
8112bba8:	a4400117 	ldw	r17,4(r20)
8112bbac:	a4000217 	ldw	r16,8(r20)
8112bbb0:	8c7fffc4 	addi	r17,r17,-1
8112bbb4:	88000c16 	blt	r17,zero,8112bbe8 <_fwalk_reent+0x8c>
8112bbb8:	84000304 	addi	r16,r16,12
8112bbbc:	8080000b 	ldhu	r2,0(r16)
8112bbc0:	8c7fffc4 	addi	r17,r17,-1
8112bbc4:	817ffd04 	addi	r5,r16,-12
8112bbc8:	b080052e 	bgeu	r22,r2,8112bbe0 <_fwalk_reent+0x84>
8112bbcc:	8080008f 	ldh	r2,2(r16)
8112bbd0:	9809883a 	mov	r4,r19
8112bbd4:	14800226 	beq	r2,r18,8112bbe0 <_fwalk_reent+0x84>
8112bbd8:	a83ee83a 	callr	r21
8112bbdc:	b8aeb03a 	or	r23,r23,r2
8112bbe0:	84001a04 	addi	r16,r16,104
8112bbe4:	8cbff51e 	bne	r17,r18,8112bbbc <__reset+0xfb10bbbc>
8112bbe8:	a5000017 	ldw	r20,0(r20)
8112bbec:	a03fee1e 	bne	r20,zero,8112bba8 <__reset+0xfb10bba8>
8112bbf0:	b805883a 	mov	r2,r23
8112bbf4:	dfc00817 	ldw	ra,32(sp)
8112bbf8:	ddc00717 	ldw	r23,28(sp)
8112bbfc:	dd800617 	ldw	r22,24(sp)
8112bc00:	dd400517 	ldw	r21,20(sp)
8112bc04:	dd000417 	ldw	r20,16(sp)
8112bc08:	dcc00317 	ldw	r19,12(sp)
8112bc0c:	dc800217 	ldw	r18,8(sp)
8112bc10:	dc400117 	ldw	r17,4(sp)
8112bc14:	dc000017 	ldw	r16,0(sp)
8112bc18:	dec00904 	addi	sp,sp,36
8112bc1c:	f800283a 	ret
8112bc20:	002f883a 	mov	r23,zero
8112bc24:	003ff206 	br	8112bbf0 <__reset+0xfb10bbf0>

8112bc28 <_isatty_r>:
8112bc28:	defffd04 	addi	sp,sp,-12
8112bc2c:	de00012e 	bgeu	sp,et,8112bc34 <_isatty_r+0xc>
8112bc30:	003b68fa 	trap	3
8112bc34:	dc000015 	stw	r16,0(sp)
8112bc38:	04204574 	movhi	r16,33045
8112bc3c:	dc400115 	stw	r17,4(sp)
8112bc40:	840b4b04 	addi	r16,r16,11564
8112bc44:	2023883a 	mov	r17,r4
8112bc48:	2809883a 	mov	r4,r5
8112bc4c:	dfc00215 	stw	ra,8(sp)
8112bc50:	80000015 	stw	zero,0(r16)
8112bc54:	11361b80 	call	811361b8 <isatty>
8112bc58:	00ffffc4 	movi	r3,-1
8112bc5c:	10c00526 	beq	r2,r3,8112bc74 <_isatty_r+0x4c>
8112bc60:	dfc00217 	ldw	ra,8(sp)
8112bc64:	dc400117 	ldw	r17,4(sp)
8112bc68:	dc000017 	ldw	r16,0(sp)
8112bc6c:	dec00304 	addi	sp,sp,12
8112bc70:	f800283a 	ret
8112bc74:	80c00017 	ldw	r3,0(r16)
8112bc78:	183ff926 	beq	r3,zero,8112bc60 <__reset+0xfb10bc60>
8112bc7c:	88c00015 	stw	r3,0(r17)
8112bc80:	003ff706 	br	8112bc60 <__reset+0xfb10bc60>

8112bc84 <iswspace>:
8112bc84:	00803fc4 	movi	r2,255
8112bc88:	11000836 	bltu	r2,r4,8112bcac <iswspace+0x28>
8112bc8c:	00a04574 	movhi	r2,33045
8112bc90:	108ad604 	addi	r2,r2,11096
8112bc94:	10800017 	ldw	r2,0(r2)
8112bc98:	1109883a 	add	r4,r2,r4
8112bc9c:	20800043 	ldbu	r2,1(r4)
8112bca0:	1080020c 	andi	r2,r2,8
8112bca4:	10803fcc 	andi	r2,r2,255
8112bca8:	f800283a 	ret
8112bcac:	0005883a 	mov	r2,zero
8112bcb0:	f800283a 	ret

8112bcb4 <_setlocale_r>:
8112bcb4:	30001d26 	beq	r6,zero,8112bd2c <_setlocale_r+0x78>
8112bcb8:	01604574 	movhi	r5,33045
8112bcbc:	defffe04 	addi	sp,sp,-8
8112bcc0:	29412f04 	addi	r5,r5,1212
8112bcc4:	3009883a 	mov	r4,r6
8112bcc8:	de00012e 	bgeu	sp,et,8112bcd0 <_setlocale_r+0x1c>
8112bccc:	003b68fa 	trap	3
8112bcd0:	dc000015 	stw	r16,0(sp)
8112bcd4:	dfc00115 	stw	ra,4(sp)
8112bcd8:	3021883a 	mov	r16,r6
8112bcdc:	112da000 	call	8112da00 <strcmp>
8112bce0:	1000061e 	bne	r2,zero,8112bcfc <_setlocale_r+0x48>
8112bce4:	00a04574 	movhi	r2,33045
8112bce8:	1080fe04 	addi	r2,r2,1016
8112bcec:	dfc00117 	ldw	ra,4(sp)
8112bcf0:	dc000017 	ldw	r16,0(sp)
8112bcf4:	dec00204 	addi	sp,sp,8
8112bcf8:	f800283a 	ret
8112bcfc:	01604574 	movhi	r5,33045
8112bd00:	2940fe04 	addi	r5,r5,1016
8112bd04:	8009883a 	mov	r4,r16
8112bd08:	112da000 	call	8112da00 <strcmp>
8112bd0c:	103ff526 	beq	r2,zero,8112bce4 <__reset+0xfb10bce4>
8112bd10:	01604574 	movhi	r5,33045
8112bd14:	29410804 	addi	r5,r5,1056
8112bd18:	8009883a 	mov	r4,r16
8112bd1c:	112da000 	call	8112da00 <strcmp>
8112bd20:	103ff026 	beq	r2,zero,8112bce4 <__reset+0xfb10bce4>
8112bd24:	0005883a 	mov	r2,zero
8112bd28:	003ff006 	br	8112bcec <__reset+0xfb10bcec>
8112bd2c:	00a04574 	movhi	r2,33045
8112bd30:	1080fe04 	addi	r2,r2,1016
8112bd34:	f800283a 	ret

8112bd38 <__locale_charset>:
8112bd38:	00a04574 	movhi	r2,33045
8112bd3c:	1085a004 	addi	r2,r2,5760
8112bd40:	f800283a 	ret

8112bd44 <__locale_mb_cur_max>:
8112bd44:	00a04574 	movhi	r2,33045
8112bd48:	108adb04 	addi	r2,r2,11116
8112bd4c:	10800017 	ldw	r2,0(r2)
8112bd50:	f800283a 	ret

8112bd54 <__locale_msgcharset>:
8112bd54:	00a04574 	movhi	r2,33045
8112bd58:	10859804 	addi	r2,r2,5728
8112bd5c:	f800283a 	ret

8112bd60 <__locale_cjk_lang>:
8112bd60:	0005883a 	mov	r2,zero
8112bd64:	f800283a 	ret

8112bd68 <_localeconv_r>:
8112bd68:	00a04574 	movhi	r2,33045
8112bd6c:	1085a804 	addi	r2,r2,5792
8112bd70:	f800283a 	ret

8112bd74 <setlocale>:
8112bd74:	00a04574 	movhi	r2,33045
8112bd78:	108ad804 	addi	r2,r2,11104
8112bd7c:	280d883a 	mov	r6,r5
8112bd80:	200b883a 	mov	r5,r4
8112bd84:	11000017 	ldw	r4,0(r2)
8112bd88:	112bcb41 	jmpi	8112bcb4 <_setlocale_r>

8112bd8c <localeconv>:
8112bd8c:	00a04574 	movhi	r2,33045
8112bd90:	1085a804 	addi	r2,r2,5792
8112bd94:	f800283a 	ret

8112bd98 <_lseek_r>:
8112bd98:	defffd04 	addi	sp,sp,-12
8112bd9c:	de00012e 	bgeu	sp,et,8112bda4 <_lseek_r+0xc>
8112bda0:	003b68fa 	trap	3
8112bda4:	2805883a 	mov	r2,r5
8112bda8:	dc000015 	stw	r16,0(sp)
8112bdac:	04204574 	movhi	r16,33045
8112bdb0:	dc400115 	stw	r17,4(sp)
8112bdb4:	300b883a 	mov	r5,r6
8112bdb8:	840b4b04 	addi	r16,r16,11564
8112bdbc:	2023883a 	mov	r17,r4
8112bdc0:	380d883a 	mov	r6,r7
8112bdc4:	1009883a 	mov	r4,r2
8112bdc8:	dfc00215 	stw	ra,8(sp)
8112bdcc:	80000015 	stw	zero,0(r16)
8112bdd0:	1136db40 	call	81136db4 <lseek>
8112bdd4:	00ffffc4 	movi	r3,-1
8112bdd8:	10c00526 	beq	r2,r3,8112bdf0 <_lseek_r+0x58>
8112bddc:	dfc00217 	ldw	ra,8(sp)
8112bde0:	dc400117 	ldw	r17,4(sp)
8112bde4:	dc000017 	ldw	r16,0(sp)
8112bde8:	dec00304 	addi	sp,sp,12
8112bdec:	f800283a 	ret
8112bdf0:	80c00017 	ldw	r3,0(r16)
8112bdf4:	183ff926 	beq	r3,zero,8112bddc <__reset+0xfb10bddc>
8112bdf8:	88c00015 	stw	r3,0(r17)
8112bdfc:	003ff706 	br	8112bddc <__reset+0xfb10bddc>

8112be00 <_mbrtowc_r>:
8112be00:	defff704 	addi	sp,sp,-36
8112be04:	00a04574 	movhi	r2,33045
8112be08:	de00012e 	bgeu	sp,et,8112be10 <_mbrtowc_r+0x10>
8112be0c:	003b68fa 	trap	3
8112be10:	108adc04 	addi	r2,r2,11120
8112be14:	dc800715 	stw	r18,28(sp)
8112be18:	dc400615 	stw	r17,24(sp)
8112be1c:	dc000515 	stw	r16,20(sp)
8112be20:	dfc00815 	stw	ra,32(sp)
8112be24:	2021883a 	mov	r16,r4
8112be28:	dc400917 	ldw	r17,36(sp)
8112be2c:	14800017 	ldw	r18,0(r2)
8112be30:	30001626 	beq	r6,zero,8112be8c <_mbrtowc_r+0x8c>
8112be34:	d9400215 	stw	r5,8(sp)
8112be38:	d9800315 	stw	r6,12(sp)
8112be3c:	d9c00415 	stw	r7,16(sp)
8112be40:	112bd380 	call	8112bd38 <__locale_charset>
8112be44:	d9c00417 	ldw	r7,16(sp)
8112be48:	d9800317 	ldw	r6,12(sp)
8112be4c:	d9400217 	ldw	r5,8(sp)
8112be50:	d8800015 	stw	r2,0(sp)
8112be54:	dc400115 	stw	r17,4(sp)
8112be58:	8009883a 	mov	r4,r16
8112be5c:	903ee83a 	callr	r18
8112be60:	00ffffc4 	movi	r3,-1
8112be64:	10c0031e 	bne	r2,r3,8112be74 <_mbrtowc_r+0x74>
8112be68:	88000015 	stw	zero,0(r17)
8112be6c:	00c02284 	movi	r3,138
8112be70:	80c00015 	stw	r3,0(r16)
8112be74:	dfc00817 	ldw	ra,32(sp)
8112be78:	dc800717 	ldw	r18,28(sp)
8112be7c:	dc400617 	ldw	r17,24(sp)
8112be80:	dc000517 	ldw	r16,20(sp)
8112be84:	dec00904 	addi	sp,sp,36
8112be88:	f800283a 	ret
8112be8c:	112bd380 	call	8112bd38 <__locale_charset>
8112be90:	01a04574 	movhi	r6,33045
8112be94:	31810804 	addi	r6,r6,1056
8112be98:	dc400115 	stw	r17,4(sp)
8112be9c:	d8800015 	stw	r2,0(sp)
8112bea0:	01c00044 	movi	r7,1
8112bea4:	000b883a 	mov	r5,zero
8112bea8:	8009883a 	mov	r4,r16
8112beac:	903ee83a 	callr	r18
8112beb0:	003feb06 	br	8112be60 <__reset+0xfb10be60>

8112beb4 <mbrtowc>:
8112beb4:	defff704 	addi	sp,sp,-36
8112beb8:	00a04574 	movhi	r2,33045
8112bebc:	de00012e 	bgeu	sp,et,8112bec4 <mbrtowc+0x10>
8112bec0:	003b68fa 	trap	3
8112bec4:	108ad804 	addi	r2,r2,11104
8112bec8:	dc800415 	stw	r18,16(sp)
8112becc:	dc400315 	stw	r17,12(sp)
8112bed0:	dfc00815 	stw	ra,32(sp)
8112bed4:	dd400715 	stw	r21,28(sp)
8112bed8:	dd000615 	stw	r20,24(sp)
8112bedc:	dcc00515 	stw	r19,20(sp)
8112bee0:	dc000215 	stw	r16,8(sp)
8112bee4:	3825883a 	mov	r18,r7
8112bee8:	14400017 	ldw	r17,0(r2)
8112beec:	28001c26 	beq	r5,zero,8112bf60 <mbrtowc+0xac>
8112bef0:	00a04574 	movhi	r2,33045
8112bef4:	108adc04 	addi	r2,r2,11120
8112bef8:	15400017 	ldw	r21,0(r2)
8112befc:	2821883a 	mov	r16,r5
8112bf00:	2027883a 	mov	r19,r4
8112bf04:	3029883a 	mov	r20,r6
8112bf08:	112bd380 	call	8112bd38 <__locale_charset>
8112bf0c:	d8800015 	stw	r2,0(sp)
8112bf10:	dc800115 	stw	r18,4(sp)
8112bf14:	a00f883a 	mov	r7,r20
8112bf18:	800d883a 	mov	r6,r16
8112bf1c:	980b883a 	mov	r5,r19
8112bf20:	8809883a 	mov	r4,r17
8112bf24:	a83ee83a 	callr	r21
8112bf28:	00ffffc4 	movi	r3,-1
8112bf2c:	10c0031e 	bne	r2,r3,8112bf3c <mbrtowc+0x88>
8112bf30:	90000015 	stw	zero,0(r18)
8112bf34:	00c02284 	movi	r3,138
8112bf38:	88c00015 	stw	r3,0(r17)
8112bf3c:	dfc00817 	ldw	ra,32(sp)
8112bf40:	dd400717 	ldw	r21,28(sp)
8112bf44:	dd000617 	ldw	r20,24(sp)
8112bf48:	dcc00517 	ldw	r19,20(sp)
8112bf4c:	dc800417 	ldw	r18,16(sp)
8112bf50:	dc400317 	ldw	r17,12(sp)
8112bf54:	dc000217 	ldw	r16,8(sp)
8112bf58:	dec00904 	addi	sp,sp,36
8112bf5c:	f800283a 	ret
8112bf60:	00a04574 	movhi	r2,33045
8112bf64:	108adc04 	addi	r2,r2,11120
8112bf68:	14000017 	ldw	r16,0(r2)
8112bf6c:	112bd380 	call	8112bd38 <__locale_charset>
8112bf70:	01a04574 	movhi	r6,33045
8112bf74:	31810804 	addi	r6,r6,1056
8112bf78:	dc800115 	stw	r18,4(sp)
8112bf7c:	d8800015 	stw	r2,0(sp)
8112bf80:	01c00044 	movi	r7,1
8112bf84:	000b883a 	mov	r5,zero
8112bf88:	8809883a 	mov	r4,r17
8112bf8c:	803ee83a 	callr	r16
8112bf90:	003fe506 	br	8112bf28 <__reset+0xfb10bf28>

8112bf94 <__ascii_mbtowc>:
8112bf94:	deffff04 	addi	sp,sp,-4
8112bf98:	de00012e 	bgeu	sp,et,8112bfa0 <__ascii_mbtowc+0xc>
8112bf9c:	003b68fa 	trap	3
8112bfa0:	28000826 	beq	r5,zero,8112bfc4 <__ascii_mbtowc+0x30>
8112bfa4:	30000926 	beq	r6,zero,8112bfcc <__ascii_mbtowc+0x38>
8112bfa8:	38000b26 	beq	r7,zero,8112bfd8 <__ascii_mbtowc+0x44>
8112bfac:	30800003 	ldbu	r2,0(r6)
8112bfb0:	28800015 	stw	r2,0(r5)
8112bfb4:	30800003 	ldbu	r2,0(r6)
8112bfb8:	1004c03a 	cmpne	r2,r2,zero
8112bfbc:	dec00104 	addi	sp,sp,4
8112bfc0:	f800283a 	ret
8112bfc4:	d80b883a 	mov	r5,sp
8112bfc8:	303ff71e 	bne	r6,zero,8112bfa8 <__reset+0xfb10bfa8>
8112bfcc:	0005883a 	mov	r2,zero
8112bfd0:	dec00104 	addi	sp,sp,4
8112bfd4:	f800283a 	ret
8112bfd8:	00bfff84 	movi	r2,-2
8112bfdc:	003ff706 	br	8112bfbc <__reset+0xfb10bfbc>

8112bfe0 <_mbtowc_r>:
8112bfe0:	00a04574 	movhi	r2,33045
8112bfe4:	defff804 	addi	sp,sp,-32
8112bfe8:	108adc04 	addi	r2,r2,11120
8112bfec:	de00012e 	bgeu	sp,et,8112bff4 <_mbtowc_r+0x14>
8112bff0:	003b68fa 	trap	3
8112bff4:	dfc00715 	stw	ra,28(sp)
8112bff8:	dc000615 	stw	r16,24(sp)
8112bffc:	14000017 	ldw	r16,0(r2)
8112c000:	d9000215 	stw	r4,8(sp)
8112c004:	d9400315 	stw	r5,12(sp)
8112c008:	d9800415 	stw	r6,16(sp)
8112c00c:	d9c00515 	stw	r7,20(sp)
8112c010:	112bd380 	call	8112bd38 <__locale_charset>
8112c014:	d8800015 	stw	r2,0(sp)
8112c018:	d8800817 	ldw	r2,32(sp)
8112c01c:	d9c00517 	ldw	r7,20(sp)
8112c020:	d9800417 	ldw	r6,16(sp)
8112c024:	d9400317 	ldw	r5,12(sp)
8112c028:	d9000217 	ldw	r4,8(sp)
8112c02c:	d8800115 	stw	r2,4(sp)
8112c030:	803ee83a 	callr	r16
8112c034:	dfc00717 	ldw	ra,28(sp)
8112c038:	dc000617 	ldw	r16,24(sp)
8112c03c:	dec00804 	addi	sp,sp,32
8112c040:	f800283a 	ret

8112c044 <memchr>:
8112c044:	208000cc 	andi	r2,r4,3
8112c048:	280f883a 	mov	r7,r5
8112c04c:	10003426 	beq	r2,zero,8112c120 <memchr+0xdc>
8112c050:	30bfffc4 	addi	r2,r6,-1
8112c054:	30001a26 	beq	r6,zero,8112c0c0 <memchr+0x7c>
8112c058:	20c00003 	ldbu	r3,0(r4)
8112c05c:	29803fcc 	andi	r6,r5,255
8112c060:	30c0051e 	bne	r6,r3,8112c078 <memchr+0x34>
8112c064:	00001806 	br	8112c0c8 <memchr+0x84>
8112c068:	10001526 	beq	r2,zero,8112c0c0 <memchr+0x7c>
8112c06c:	20c00003 	ldbu	r3,0(r4)
8112c070:	10bfffc4 	addi	r2,r2,-1
8112c074:	30c01426 	beq	r6,r3,8112c0c8 <memchr+0x84>
8112c078:	21000044 	addi	r4,r4,1
8112c07c:	20c000cc 	andi	r3,r4,3
8112c080:	183ff91e 	bne	r3,zero,8112c068 <__reset+0xfb10c068>
8112c084:	020000c4 	movi	r8,3
8112c088:	40801136 	bltu	r8,r2,8112c0d0 <memchr+0x8c>
8112c08c:	10000c26 	beq	r2,zero,8112c0c0 <memchr+0x7c>
8112c090:	20c00003 	ldbu	r3,0(r4)
8112c094:	29403fcc 	andi	r5,r5,255
8112c098:	28c00b26 	beq	r5,r3,8112c0c8 <memchr+0x84>
8112c09c:	20c00044 	addi	r3,r4,1
8112c0a0:	39803fcc 	andi	r6,r7,255
8112c0a4:	2089883a 	add	r4,r4,r2
8112c0a8:	00000306 	br	8112c0b8 <memchr+0x74>
8112c0ac:	18c00044 	addi	r3,r3,1
8112c0b0:	197fffc3 	ldbu	r5,-1(r3)
8112c0b4:	31400526 	beq	r6,r5,8112c0cc <memchr+0x88>
8112c0b8:	1805883a 	mov	r2,r3
8112c0bc:	20fffb1e 	bne	r4,r3,8112c0ac <__reset+0xfb10c0ac>
8112c0c0:	0005883a 	mov	r2,zero
8112c0c4:	f800283a 	ret
8112c0c8:	2005883a 	mov	r2,r4
8112c0cc:	f800283a 	ret
8112c0d0:	28c03fcc 	andi	r3,r5,255
8112c0d4:	1812923a 	slli	r9,r3,8
8112c0d8:	02ffbff4 	movhi	r11,65279
8112c0dc:	02a02074 	movhi	r10,32897
8112c0e0:	48d2b03a 	or	r9,r9,r3
8112c0e4:	4806943a 	slli	r3,r9,16
8112c0e8:	5affbfc4 	addi	r11,r11,-257
8112c0ec:	52a02004 	addi	r10,r10,-32640
8112c0f0:	48d2b03a 	or	r9,r9,r3
8112c0f4:	20c00017 	ldw	r3,0(r4)
8112c0f8:	48c6f03a 	xor	r3,r9,r3
8112c0fc:	1acd883a 	add	r6,r3,r11
8112c100:	00c6303a 	nor	r3,zero,r3
8112c104:	30c6703a 	and	r3,r6,r3
8112c108:	1a86703a 	and	r3,r3,r10
8112c10c:	183fe01e 	bne	r3,zero,8112c090 <__reset+0xfb10c090>
8112c110:	10bfff04 	addi	r2,r2,-4
8112c114:	21000104 	addi	r4,r4,4
8112c118:	40bff636 	bltu	r8,r2,8112c0f4 <__reset+0xfb10c0f4>
8112c11c:	003fdb06 	br	8112c08c <__reset+0xfb10c08c>
8112c120:	3005883a 	mov	r2,r6
8112c124:	003fd706 	br	8112c084 <__reset+0xfb10c084>

8112c128 <memmove>:
8112c128:	2005883a 	mov	r2,r4
8112c12c:	29000b2e 	bgeu	r5,r4,8112c15c <memmove+0x34>
8112c130:	298f883a 	add	r7,r5,r6
8112c134:	21c0092e 	bgeu	r4,r7,8112c15c <memmove+0x34>
8112c138:	2187883a 	add	r3,r4,r6
8112c13c:	198bc83a 	sub	r5,r3,r6
8112c140:	30004826 	beq	r6,zero,8112c264 <memmove+0x13c>
8112c144:	39ffffc4 	addi	r7,r7,-1
8112c148:	39000003 	ldbu	r4,0(r7)
8112c14c:	18ffffc4 	addi	r3,r3,-1
8112c150:	19000005 	stb	r4,0(r3)
8112c154:	28fffb1e 	bne	r5,r3,8112c144 <__reset+0xfb10c144>
8112c158:	f800283a 	ret
8112c15c:	00c003c4 	movi	r3,15
8112c160:	1980412e 	bgeu	r3,r6,8112c268 <memmove+0x140>
8112c164:	2886b03a 	or	r3,r5,r2
8112c168:	18c000cc 	andi	r3,r3,3
8112c16c:	1800401e 	bne	r3,zero,8112c270 <memmove+0x148>
8112c170:	33fffc04 	addi	r15,r6,-16
8112c174:	781ed13a 	srli	r15,r15,4
8112c178:	28c00104 	addi	r3,r5,4
8112c17c:	13400104 	addi	r13,r2,4
8112c180:	781c913a 	slli	r14,r15,4
8112c184:	2b000204 	addi	r12,r5,8
8112c188:	12c00204 	addi	r11,r2,8
8112c18c:	73800504 	addi	r14,r14,20
8112c190:	2a800304 	addi	r10,r5,12
8112c194:	12400304 	addi	r9,r2,12
8112c198:	2b9d883a 	add	r14,r5,r14
8112c19c:	2811883a 	mov	r8,r5
8112c1a0:	100f883a 	mov	r7,r2
8112c1a4:	41000017 	ldw	r4,0(r8)
8112c1a8:	39c00404 	addi	r7,r7,16
8112c1ac:	18c00404 	addi	r3,r3,16
8112c1b0:	393ffc15 	stw	r4,-16(r7)
8112c1b4:	193ffc17 	ldw	r4,-16(r3)
8112c1b8:	6b400404 	addi	r13,r13,16
8112c1bc:	5ac00404 	addi	r11,r11,16
8112c1c0:	693ffc15 	stw	r4,-16(r13)
8112c1c4:	61000017 	ldw	r4,0(r12)
8112c1c8:	4a400404 	addi	r9,r9,16
8112c1cc:	42000404 	addi	r8,r8,16
8112c1d0:	593ffc15 	stw	r4,-16(r11)
8112c1d4:	51000017 	ldw	r4,0(r10)
8112c1d8:	63000404 	addi	r12,r12,16
8112c1dc:	52800404 	addi	r10,r10,16
8112c1e0:	493ffc15 	stw	r4,-16(r9)
8112c1e4:	1bbfef1e 	bne	r3,r14,8112c1a4 <__reset+0xfb10c1a4>
8112c1e8:	79000044 	addi	r4,r15,1
8112c1ec:	2008913a 	slli	r4,r4,4
8112c1f0:	328003cc 	andi	r10,r6,15
8112c1f4:	02c000c4 	movi	r11,3
8112c1f8:	1107883a 	add	r3,r2,r4
8112c1fc:	290b883a 	add	r5,r5,r4
8112c200:	5a801e2e 	bgeu	r11,r10,8112c27c <memmove+0x154>
8112c204:	1813883a 	mov	r9,r3
8112c208:	2811883a 	mov	r8,r5
8112c20c:	500f883a 	mov	r7,r10
8112c210:	41000017 	ldw	r4,0(r8)
8112c214:	4a400104 	addi	r9,r9,4
8112c218:	39ffff04 	addi	r7,r7,-4
8112c21c:	493fff15 	stw	r4,-4(r9)
8112c220:	42000104 	addi	r8,r8,4
8112c224:	59fffa36 	bltu	r11,r7,8112c210 <__reset+0xfb10c210>
8112c228:	513fff04 	addi	r4,r10,-4
8112c22c:	2008d0ba 	srli	r4,r4,2
8112c230:	318000cc 	andi	r6,r6,3
8112c234:	21000044 	addi	r4,r4,1
8112c238:	2109883a 	add	r4,r4,r4
8112c23c:	2109883a 	add	r4,r4,r4
8112c240:	1907883a 	add	r3,r3,r4
8112c244:	290b883a 	add	r5,r5,r4
8112c248:	30000b26 	beq	r6,zero,8112c278 <memmove+0x150>
8112c24c:	198d883a 	add	r6,r3,r6
8112c250:	29c00003 	ldbu	r7,0(r5)
8112c254:	18c00044 	addi	r3,r3,1
8112c258:	29400044 	addi	r5,r5,1
8112c25c:	19ffffc5 	stb	r7,-1(r3)
8112c260:	19bffb1e 	bne	r3,r6,8112c250 <__reset+0xfb10c250>
8112c264:	f800283a 	ret
8112c268:	1007883a 	mov	r3,r2
8112c26c:	003ff606 	br	8112c248 <__reset+0xfb10c248>
8112c270:	1007883a 	mov	r3,r2
8112c274:	003ff506 	br	8112c24c <__reset+0xfb10c24c>
8112c278:	f800283a 	ret
8112c27c:	500d883a 	mov	r6,r10
8112c280:	003ff106 	br	8112c248 <__reset+0xfb10c248>

8112c284 <_Balloc>:
8112c284:	defffc04 	addi	sp,sp,-16
8112c288:	de00012e 	bgeu	sp,et,8112c290 <_Balloc+0xc>
8112c28c:	003b68fa 	trap	3
8112c290:	20801317 	ldw	r2,76(r4)
8112c294:	dc400115 	stw	r17,4(sp)
8112c298:	dc000015 	stw	r16,0(sp)
8112c29c:	dfc00315 	stw	ra,12(sp)
8112c2a0:	dc800215 	stw	r18,8(sp)
8112c2a4:	2023883a 	mov	r17,r4
8112c2a8:	2821883a 	mov	r16,r5
8112c2ac:	10000f26 	beq	r2,zero,8112c2ec <_Balloc+0x68>
8112c2b0:	8407883a 	add	r3,r16,r16
8112c2b4:	18c7883a 	add	r3,r3,r3
8112c2b8:	10c7883a 	add	r3,r2,r3
8112c2bc:	18800017 	ldw	r2,0(r3)
8112c2c0:	10001126 	beq	r2,zero,8112c308 <_Balloc+0x84>
8112c2c4:	11000017 	ldw	r4,0(r2)
8112c2c8:	19000015 	stw	r4,0(r3)
8112c2cc:	10000415 	stw	zero,16(r2)
8112c2d0:	10000315 	stw	zero,12(r2)
8112c2d4:	dfc00317 	ldw	ra,12(sp)
8112c2d8:	dc800217 	ldw	r18,8(sp)
8112c2dc:	dc400117 	ldw	r17,4(sp)
8112c2e0:	dc000017 	ldw	r16,0(sp)
8112c2e4:	dec00404 	addi	sp,sp,16
8112c2e8:	f800283a 	ret
8112c2ec:	01800844 	movi	r6,33
8112c2f0:	01400104 	movi	r5,4
8112c2f4:	11327ac0 	call	811327ac <_calloc_r>
8112c2f8:	88801315 	stw	r2,76(r17)
8112c2fc:	103fec1e 	bne	r2,zero,8112c2b0 <__reset+0xfb10c2b0>
8112c300:	0005883a 	mov	r2,zero
8112c304:	003ff306 	br	8112c2d4 <__reset+0xfb10c2d4>
8112c308:	01400044 	movi	r5,1
8112c30c:	2c24983a 	sll	r18,r5,r16
8112c310:	8809883a 	mov	r4,r17
8112c314:	91800144 	addi	r6,r18,5
8112c318:	318d883a 	add	r6,r6,r6
8112c31c:	318d883a 	add	r6,r6,r6
8112c320:	11327ac0 	call	811327ac <_calloc_r>
8112c324:	103ff626 	beq	r2,zero,8112c300 <__reset+0xfb10c300>
8112c328:	14000115 	stw	r16,4(r2)
8112c32c:	14800215 	stw	r18,8(r2)
8112c330:	003fe606 	br	8112c2cc <__reset+0xfb10c2cc>

8112c334 <_Bfree>:
8112c334:	28000826 	beq	r5,zero,8112c358 <_Bfree+0x24>
8112c338:	28c00117 	ldw	r3,4(r5)
8112c33c:	20801317 	ldw	r2,76(r4)
8112c340:	18c7883a 	add	r3,r3,r3
8112c344:	18c7883a 	add	r3,r3,r3
8112c348:	10c5883a 	add	r2,r2,r3
8112c34c:	10c00017 	ldw	r3,0(r2)
8112c350:	28c00015 	stw	r3,0(r5)
8112c354:	11400015 	stw	r5,0(r2)
8112c358:	f800283a 	ret

8112c35c <__multadd>:
8112c35c:	defffa04 	addi	sp,sp,-24
8112c360:	de00012e 	bgeu	sp,et,8112c368 <__multadd+0xc>
8112c364:	003b68fa 	trap	3
8112c368:	0011883a 	mov	r8,zero
8112c36c:	dc800315 	stw	r18,12(sp)
8112c370:	dc400215 	stw	r17,8(sp)
8112c374:	dc000115 	stw	r16,4(sp)
8112c378:	2823883a 	mov	r17,r5
8112c37c:	2c000417 	ldw	r16,16(r5)
8112c380:	dfc00515 	stw	ra,20(sp)
8112c384:	dcc00415 	stw	r19,16(sp)
8112c388:	2025883a 	mov	r18,r4
8112c38c:	29400504 	addi	r5,r5,20
8112c390:	28c00017 	ldw	r3,0(r5)
8112c394:	29400104 	addi	r5,r5,4
8112c398:	42000044 	addi	r8,r8,1
8112c39c:	18bfffcc 	andi	r2,r3,65535
8112c3a0:	1185383a 	mul	r2,r2,r6
8112c3a4:	1806d43a 	srli	r3,r3,16
8112c3a8:	11cf883a 	add	r7,r2,r7
8112c3ac:	3808d43a 	srli	r4,r7,16
8112c3b0:	1987383a 	mul	r3,r3,r6
8112c3b4:	38bfffcc 	andi	r2,r7,65535
8112c3b8:	1907883a 	add	r3,r3,r4
8112c3bc:	1808943a 	slli	r4,r3,16
8112c3c0:	180ed43a 	srli	r7,r3,16
8112c3c4:	2085883a 	add	r2,r4,r2
8112c3c8:	28bfff15 	stw	r2,-4(r5)
8112c3cc:	443ff016 	blt	r8,r16,8112c390 <__reset+0xfb10c390>
8112c3d0:	38000926 	beq	r7,zero,8112c3f8 <__multadd+0x9c>
8112c3d4:	88800217 	ldw	r2,8(r17)
8112c3d8:	80800f0e 	bge	r16,r2,8112c418 <__multadd+0xbc>
8112c3dc:	80800144 	addi	r2,r16,5
8112c3e0:	1085883a 	add	r2,r2,r2
8112c3e4:	1085883a 	add	r2,r2,r2
8112c3e8:	8885883a 	add	r2,r17,r2
8112c3ec:	11c00015 	stw	r7,0(r2)
8112c3f0:	84000044 	addi	r16,r16,1
8112c3f4:	8c000415 	stw	r16,16(r17)
8112c3f8:	8805883a 	mov	r2,r17
8112c3fc:	dfc00517 	ldw	ra,20(sp)
8112c400:	dcc00417 	ldw	r19,16(sp)
8112c404:	dc800317 	ldw	r18,12(sp)
8112c408:	dc400217 	ldw	r17,8(sp)
8112c40c:	dc000117 	ldw	r16,4(sp)
8112c410:	dec00604 	addi	sp,sp,24
8112c414:	f800283a 	ret
8112c418:	89400117 	ldw	r5,4(r17)
8112c41c:	9009883a 	mov	r4,r18
8112c420:	d9c00015 	stw	r7,0(sp)
8112c424:	29400044 	addi	r5,r5,1
8112c428:	112c2840 	call	8112c284 <_Balloc>
8112c42c:	89800417 	ldw	r6,16(r17)
8112c430:	89400304 	addi	r5,r17,12
8112c434:	11000304 	addi	r4,r2,12
8112c438:	31800084 	addi	r6,r6,2
8112c43c:	318d883a 	add	r6,r6,r6
8112c440:	318d883a 	add	r6,r6,r6
8112c444:	1027883a 	mov	r19,r2
8112c448:	11220540 	call	81122054 <memcpy>
8112c44c:	d9c00017 	ldw	r7,0(sp)
8112c450:	88000a26 	beq	r17,zero,8112c47c <__multadd+0x120>
8112c454:	88c00117 	ldw	r3,4(r17)
8112c458:	90801317 	ldw	r2,76(r18)
8112c45c:	18c7883a 	add	r3,r3,r3
8112c460:	18c7883a 	add	r3,r3,r3
8112c464:	10c5883a 	add	r2,r2,r3
8112c468:	10c00017 	ldw	r3,0(r2)
8112c46c:	88c00015 	stw	r3,0(r17)
8112c470:	14400015 	stw	r17,0(r2)
8112c474:	9823883a 	mov	r17,r19
8112c478:	003fd806 	br	8112c3dc <__reset+0xfb10c3dc>
8112c47c:	9823883a 	mov	r17,r19
8112c480:	003fd606 	br	8112c3dc <__reset+0xfb10c3dc>

8112c484 <__s2b>:
8112c484:	defff904 	addi	sp,sp,-28
8112c488:	de00012e 	bgeu	sp,et,8112c490 <__s2b+0xc>
8112c48c:	003b68fa 	trap	3
8112c490:	dc400115 	stw	r17,4(sp)
8112c494:	dc000015 	stw	r16,0(sp)
8112c498:	2023883a 	mov	r17,r4
8112c49c:	2821883a 	mov	r16,r5
8112c4a0:	39000204 	addi	r4,r7,8
8112c4a4:	01400244 	movi	r5,9
8112c4a8:	dcc00315 	stw	r19,12(sp)
8112c4ac:	dc800215 	stw	r18,8(sp)
8112c4b0:	dfc00615 	stw	ra,24(sp)
8112c4b4:	dd400515 	stw	r21,20(sp)
8112c4b8:	dd000415 	stw	r20,16(sp)
8112c4bc:	3825883a 	mov	r18,r7
8112c4c0:	3027883a 	mov	r19,r6
8112c4c4:	11344c80 	call	811344c8 <__divsi3>
8112c4c8:	00c00044 	movi	r3,1
8112c4cc:	000b883a 	mov	r5,zero
8112c4d0:	1880030e 	bge	r3,r2,8112c4e0 <__s2b+0x5c>
8112c4d4:	18c7883a 	add	r3,r3,r3
8112c4d8:	29400044 	addi	r5,r5,1
8112c4dc:	18bffd16 	blt	r3,r2,8112c4d4 <__reset+0xfb10c4d4>
8112c4e0:	8809883a 	mov	r4,r17
8112c4e4:	112c2840 	call	8112c284 <_Balloc>
8112c4e8:	d8c00717 	ldw	r3,28(sp)
8112c4ec:	10c00515 	stw	r3,20(r2)
8112c4f0:	00c00044 	movi	r3,1
8112c4f4:	10c00415 	stw	r3,16(r2)
8112c4f8:	00c00244 	movi	r3,9
8112c4fc:	1cc0210e 	bge	r3,r19,8112c584 <__s2b+0x100>
8112c500:	80eb883a 	add	r21,r16,r3
8112c504:	a829883a 	mov	r20,r21
8112c508:	84e1883a 	add	r16,r16,r19
8112c50c:	a1c00007 	ldb	r7,0(r20)
8112c510:	01800284 	movi	r6,10
8112c514:	a5000044 	addi	r20,r20,1
8112c518:	100b883a 	mov	r5,r2
8112c51c:	39fff404 	addi	r7,r7,-48
8112c520:	8809883a 	mov	r4,r17
8112c524:	112c35c0 	call	8112c35c <__multadd>
8112c528:	a43ff81e 	bne	r20,r16,8112c50c <__reset+0xfb10c50c>
8112c52c:	ace1883a 	add	r16,r21,r19
8112c530:	843ffe04 	addi	r16,r16,-8
8112c534:	9c800a0e 	bge	r19,r18,8112c560 <__s2b+0xdc>
8112c538:	94e5c83a 	sub	r18,r18,r19
8112c53c:	84a5883a 	add	r18,r16,r18
8112c540:	81c00007 	ldb	r7,0(r16)
8112c544:	01800284 	movi	r6,10
8112c548:	84000044 	addi	r16,r16,1
8112c54c:	100b883a 	mov	r5,r2
8112c550:	39fff404 	addi	r7,r7,-48
8112c554:	8809883a 	mov	r4,r17
8112c558:	112c35c0 	call	8112c35c <__multadd>
8112c55c:	84bff81e 	bne	r16,r18,8112c540 <__reset+0xfb10c540>
8112c560:	dfc00617 	ldw	ra,24(sp)
8112c564:	dd400517 	ldw	r21,20(sp)
8112c568:	dd000417 	ldw	r20,16(sp)
8112c56c:	dcc00317 	ldw	r19,12(sp)
8112c570:	dc800217 	ldw	r18,8(sp)
8112c574:	dc400117 	ldw	r17,4(sp)
8112c578:	dc000017 	ldw	r16,0(sp)
8112c57c:	dec00704 	addi	sp,sp,28
8112c580:	f800283a 	ret
8112c584:	84000284 	addi	r16,r16,10
8112c588:	1827883a 	mov	r19,r3
8112c58c:	003fe906 	br	8112c534 <__reset+0xfb10c534>

8112c590 <__hi0bits>:
8112c590:	20bfffec 	andhi	r2,r4,65535
8112c594:	1000141e 	bne	r2,zero,8112c5e8 <__hi0bits+0x58>
8112c598:	2008943a 	slli	r4,r4,16
8112c59c:	00800404 	movi	r2,16
8112c5a0:	20ffc02c 	andhi	r3,r4,65280
8112c5a4:	1800021e 	bne	r3,zero,8112c5b0 <__hi0bits+0x20>
8112c5a8:	2008923a 	slli	r4,r4,8
8112c5ac:	10800204 	addi	r2,r2,8
8112c5b0:	20fc002c 	andhi	r3,r4,61440
8112c5b4:	1800021e 	bne	r3,zero,8112c5c0 <__hi0bits+0x30>
8112c5b8:	2008913a 	slli	r4,r4,4
8112c5bc:	10800104 	addi	r2,r2,4
8112c5c0:	20f0002c 	andhi	r3,r4,49152
8112c5c4:	1800031e 	bne	r3,zero,8112c5d4 <__hi0bits+0x44>
8112c5c8:	2109883a 	add	r4,r4,r4
8112c5cc:	10800084 	addi	r2,r2,2
8112c5d0:	2109883a 	add	r4,r4,r4
8112c5d4:	20000316 	blt	r4,zero,8112c5e4 <__hi0bits+0x54>
8112c5d8:	2110002c 	andhi	r4,r4,16384
8112c5dc:	2000041e 	bne	r4,zero,8112c5f0 <__hi0bits+0x60>
8112c5e0:	00800804 	movi	r2,32
8112c5e4:	f800283a 	ret
8112c5e8:	0005883a 	mov	r2,zero
8112c5ec:	003fec06 	br	8112c5a0 <__reset+0xfb10c5a0>
8112c5f0:	10800044 	addi	r2,r2,1
8112c5f4:	f800283a 	ret

8112c5f8 <__lo0bits>:
8112c5f8:	20c00017 	ldw	r3,0(r4)
8112c5fc:	188001cc 	andi	r2,r3,7
8112c600:	10000826 	beq	r2,zero,8112c624 <__lo0bits+0x2c>
8112c604:	1880004c 	andi	r2,r3,1
8112c608:	1000211e 	bne	r2,zero,8112c690 <__lo0bits+0x98>
8112c60c:	1880008c 	andi	r2,r3,2
8112c610:	1000211e 	bne	r2,zero,8112c698 <__lo0bits+0xa0>
8112c614:	1806d0ba 	srli	r3,r3,2
8112c618:	00800084 	movi	r2,2
8112c61c:	20c00015 	stw	r3,0(r4)
8112c620:	f800283a 	ret
8112c624:	18bfffcc 	andi	r2,r3,65535
8112c628:	10001326 	beq	r2,zero,8112c678 <__lo0bits+0x80>
8112c62c:	0005883a 	mov	r2,zero
8112c630:	19403fcc 	andi	r5,r3,255
8112c634:	2800021e 	bne	r5,zero,8112c640 <__lo0bits+0x48>
8112c638:	1806d23a 	srli	r3,r3,8
8112c63c:	10800204 	addi	r2,r2,8
8112c640:	194003cc 	andi	r5,r3,15
8112c644:	2800021e 	bne	r5,zero,8112c650 <__lo0bits+0x58>
8112c648:	1806d13a 	srli	r3,r3,4
8112c64c:	10800104 	addi	r2,r2,4
8112c650:	194000cc 	andi	r5,r3,3
8112c654:	2800021e 	bne	r5,zero,8112c660 <__lo0bits+0x68>
8112c658:	1806d0ba 	srli	r3,r3,2
8112c65c:	10800084 	addi	r2,r2,2
8112c660:	1940004c 	andi	r5,r3,1
8112c664:	2800081e 	bne	r5,zero,8112c688 <__lo0bits+0x90>
8112c668:	1806d07a 	srli	r3,r3,1
8112c66c:	1800051e 	bne	r3,zero,8112c684 <__lo0bits+0x8c>
8112c670:	00800804 	movi	r2,32
8112c674:	f800283a 	ret
8112c678:	1806d43a 	srli	r3,r3,16
8112c67c:	00800404 	movi	r2,16
8112c680:	003feb06 	br	8112c630 <__reset+0xfb10c630>
8112c684:	10800044 	addi	r2,r2,1
8112c688:	20c00015 	stw	r3,0(r4)
8112c68c:	f800283a 	ret
8112c690:	0005883a 	mov	r2,zero
8112c694:	f800283a 	ret
8112c698:	1806d07a 	srli	r3,r3,1
8112c69c:	00800044 	movi	r2,1
8112c6a0:	20c00015 	stw	r3,0(r4)
8112c6a4:	f800283a 	ret

8112c6a8 <__i2b>:
8112c6a8:	defffd04 	addi	sp,sp,-12
8112c6ac:	de00012e 	bgeu	sp,et,8112c6b4 <__i2b+0xc>
8112c6b0:	003b68fa 	trap	3
8112c6b4:	dc000015 	stw	r16,0(sp)
8112c6b8:	04000044 	movi	r16,1
8112c6bc:	dc400115 	stw	r17,4(sp)
8112c6c0:	2823883a 	mov	r17,r5
8112c6c4:	800b883a 	mov	r5,r16
8112c6c8:	dfc00215 	stw	ra,8(sp)
8112c6cc:	112c2840 	call	8112c284 <_Balloc>
8112c6d0:	14400515 	stw	r17,20(r2)
8112c6d4:	14000415 	stw	r16,16(r2)
8112c6d8:	dfc00217 	ldw	ra,8(sp)
8112c6dc:	dc400117 	ldw	r17,4(sp)
8112c6e0:	dc000017 	ldw	r16,0(sp)
8112c6e4:	dec00304 	addi	sp,sp,12
8112c6e8:	f800283a 	ret

8112c6ec <__multiply>:
8112c6ec:	defffa04 	addi	sp,sp,-24
8112c6f0:	de00012e 	bgeu	sp,et,8112c6f8 <__multiply+0xc>
8112c6f4:	003b68fa 	trap	3
8112c6f8:	dcc00315 	stw	r19,12(sp)
8112c6fc:	dc800215 	stw	r18,8(sp)
8112c700:	34c00417 	ldw	r19,16(r6)
8112c704:	2c800417 	ldw	r18,16(r5)
8112c708:	dd000415 	stw	r20,16(sp)
8112c70c:	dc400115 	stw	r17,4(sp)
8112c710:	dfc00515 	stw	ra,20(sp)
8112c714:	dc000015 	stw	r16,0(sp)
8112c718:	2829883a 	mov	r20,r5
8112c71c:	3023883a 	mov	r17,r6
8112c720:	94c0050e 	bge	r18,r19,8112c738 <__multiply+0x4c>
8112c724:	9007883a 	mov	r3,r18
8112c728:	3029883a 	mov	r20,r6
8112c72c:	9825883a 	mov	r18,r19
8112c730:	2823883a 	mov	r17,r5
8112c734:	1827883a 	mov	r19,r3
8112c738:	a0800217 	ldw	r2,8(r20)
8112c73c:	94e1883a 	add	r16,r18,r19
8112c740:	a1400117 	ldw	r5,4(r20)
8112c744:	1400010e 	bge	r2,r16,8112c74c <__multiply+0x60>
8112c748:	29400044 	addi	r5,r5,1
8112c74c:	112c2840 	call	8112c284 <_Balloc>
8112c750:	8415883a 	add	r10,r16,r16
8112c754:	12c00504 	addi	r11,r2,20
8112c758:	5295883a 	add	r10,r10,r10
8112c75c:	5a95883a 	add	r10,r11,r10
8112c760:	5807883a 	mov	r3,r11
8112c764:	5a80032e 	bgeu	r11,r10,8112c774 <__multiply+0x88>
8112c768:	18000015 	stw	zero,0(r3)
8112c76c:	18c00104 	addi	r3,r3,4
8112c770:	1abffd36 	bltu	r3,r10,8112c768 <__reset+0xfb10c768>
8112c774:	9ce7883a 	add	r19,r19,r19
8112c778:	94a5883a 	add	r18,r18,r18
8112c77c:	89800504 	addi	r6,r17,20
8112c780:	9ce7883a 	add	r19,r19,r19
8112c784:	a3400504 	addi	r13,r20,20
8112c788:	94a5883a 	add	r18,r18,r18
8112c78c:	34d9883a 	add	r12,r6,r19
8112c790:	6c93883a 	add	r9,r13,r18
8112c794:	3300422e 	bgeu	r6,r12,8112c8a0 <__multiply+0x1b4>
8112c798:	37c00017 	ldw	ra,0(r6)
8112c79c:	fbffffcc 	andi	r15,ra,65535
8112c7a0:	78001b26 	beq	r15,zero,8112c810 <__multiply+0x124>
8112c7a4:	5811883a 	mov	r8,r11
8112c7a8:	681d883a 	mov	r14,r13
8112c7ac:	000f883a 	mov	r7,zero
8112c7b0:	71000017 	ldw	r4,0(r14)
8112c7b4:	40c00017 	ldw	r3,0(r8)
8112c7b8:	73800104 	addi	r14,r14,4
8112c7bc:	217fffcc 	andi	r5,r4,65535
8112c7c0:	2bcb383a 	mul	r5,r5,r15
8112c7c4:	2008d43a 	srli	r4,r4,16
8112c7c8:	1c7fffcc 	andi	r17,r3,65535
8112c7cc:	2c4b883a 	add	r5,r5,r17
8112c7d0:	29cb883a 	add	r5,r5,r7
8112c7d4:	23c9383a 	mul	r4,r4,r15
8112c7d8:	1806d43a 	srli	r3,r3,16
8112c7dc:	280ed43a 	srli	r7,r5,16
8112c7e0:	297fffcc 	andi	r5,r5,65535
8112c7e4:	20c7883a 	add	r3,r4,r3
8112c7e8:	19c7883a 	add	r3,r3,r7
8112c7ec:	1808943a 	slli	r4,r3,16
8112c7f0:	4023883a 	mov	r17,r8
8112c7f4:	180ed43a 	srli	r7,r3,16
8112c7f8:	214ab03a 	or	r5,r4,r5
8112c7fc:	41400015 	stw	r5,0(r8)
8112c800:	42000104 	addi	r8,r8,4
8112c804:	727fea36 	bltu	r14,r9,8112c7b0 <__reset+0xfb10c7b0>
8112c808:	89c00115 	stw	r7,4(r17)
8112c80c:	37c00017 	ldw	ra,0(r6)
8112c810:	f83ed43a 	srli	ra,ra,16
8112c814:	f8001f26 	beq	ra,zero,8112c894 <__multiply+0x1a8>
8112c818:	58c00017 	ldw	r3,0(r11)
8112c81c:	681d883a 	mov	r14,r13
8112c820:	581f883a 	mov	r15,r11
8112c824:	1811883a 	mov	r8,r3
8112c828:	5825883a 	mov	r18,r11
8112c82c:	000f883a 	mov	r7,zero
8112c830:	00000106 	br	8112c838 <__multiply+0x14c>
8112c834:	8825883a 	mov	r18,r17
8112c838:	7140000b 	ldhu	r5,0(r14)
8112c83c:	4010d43a 	srli	r8,r8,16
8112c840:	193fffcc 	andi	r4,r3,65535
8112c844:	2fcb383a 	mul	r5,r5,ra
8112c848:	7bc00104 	addi	r15,r15,4
8112c84c:	73800104 	addi	r14,r14,4
8112c850:	2a0b883a 	add	r5,r5,r8
8112c854:	29cb883a 	add	r5,r5,r7
8112c858:	2806943a 	slli	r3,r5,16
8112c85c:	94400104 	addi	r17,r18,4
8112c860:	280ad43a 	srli	r5,r5,16
8112c864:	1908b03a 	or	r4,r3,r4
8112c868:	793fff15 	stw	r4,-4(r15)
8112c86c:	70ffff17 	ldw	r3,-4(r14)
8112c870:	8a000017 	ldw	r8,0(r17)
8112c874:	1806d43a 	srli	r3,r3,16
8112c878:	413fffcc 	andi	r4,r8,65535
8112c87c:	1fc7383a 	mul	r3,r3,ra
8112c880:	1907883a 	add	r3,r3,r4
8112c884:	1947883a 	add	r3,r3,r5
8112c888:	180ed43a 	srli	r7,r3,16
8112c88c:	727fe936 	bltu	r14,r9,8112c834 <__reset+0xfb10c834>
8112c890:	90c00115 	stw	r3,4(r18)
8112c894:	31800104 	addi	r6,r6,4
8112c898:	5ac00104 	addi	r11,r11,4
8112c89c:	333fbe36 	bltu	r6,r12,8112c798 <__reset+0xfb10c798>
8112c8a0:	0400090e 	bge	zero,r16,8112c8c8 <__multiply+0x1dc>
8112c8a4:	50ffff17 	ldw	r3,-4(r10)
8112c8a8:	52bfff04 	addi	r10,r10,-4
8112c8ac:	18000326 	beq	r3,zero,8112c8bc <__multiply+0x1d0>
8112c8b0:	00000506 	br	8112c8c8 <__multiply+0x1dc>
8112c8b4:	50c00017 	ldw	r3,0(r10)
8112c8b8:	1800031e 	bne	r3,zero,8112c8c8 <__multiply+0x1dc>
8112c8bc:	843fffc4 	addi	r16,r16,-1
8112c8c0:	52bfff04 	addi	r10,r10,-4
8112c8c4:	803ffb1e 	bne	r16,zero,8112c8b4 <__reset+0xfb10c8b4>
8112c8c8:	14000415 	stw	r16,16(r2)
8112c8cc:	dfc00517 	ldw	ra,20(sp)
8112c8d0:	dd000417 	ldw	r20,16(sp)
8112c8d4:	dcc00317 	ldw	r19,12(sp)
8112c8d8:	dc800217 	ldw	r18,8(sp)
8112c8dc:	dc400117 	ldw	r17,4(sp)
8112c8e0:	dc000017 	ldw	r16,0(sp)
8112c8e4:	dec00604 	addi	sp,sp,24
8112c8e8:	f800283a 	ret

8112c8ec <__pow5mult>:
8112c8ec:	defffa04 	addi	sp,sp,-24
8112c8f0:	de00012e 	bgeu	sp,et,8112c8f8 <__pow5mult+0xc>
8112c8f4:	003b68fa 	trap	3
8112c8f8:	308000cc 	andi	r2,r6,3
8112c8fc:	dcc00315 	stw	r19,12(sp)
8112c900:	dc000015 	stw	r16,0(sp)
8112c904:	dfc00515 	stw	ra,20(sp)
8112c908:	dd000415 	stw	r20,16(sp)
8112c90c:	dc800215 	stw	r18,8(sp)
8112c910:	dc400115 	stw	r17,4(sp)
8112c914:	3021883a 	mov	r16,r6
8112c918:	2027883a 	mov	r19,r4
8112c91c:	10002f1e 	bne	r2,zero,8112c9dc <__pow5mult+0xf0>
8112c920:	2825883a 	mov	r18,r5
8112c924:	8021d0ba 	srai	r16,r16,2
8112c928:	80001a26 	beq	r16,zero,8112c994 <__pow5mult+0xa8>
8112c92c:	9c401217 	ldw	r17,72(r19)
8112c930:	8800061e 	bne	r17,zero,8112c94c <__pow5mult+0x60>
8112c934:	00003406 	br	8112ca08 <__pow5mult+0x11c>
8112c938:	8021d07a 	srai	r16,r16,1
8112c93c:	80001526 	beq	r16,zero,8112c994 <__pow5mult+0xa8>
8112c940:	88800017 	ldw	r2,0(r17)
8112c944:	10001c26 	beq	r2,zero,8112c9b8 <__pow5mult+0xcc>
8112c948:	1023883a 	mov	r17,r2
8112c94c:	8080004c 	andi	r2,r16,1
8112c950:	103ff926 	beq	r2,zero,8112c938 <__reset+0xfb10c938>
8112c954:	880d883a 	mov	r6,r17
8112c958:	900b883a 	mov	r5,r18
8112c95c:	9809883a 	mov	r4,r19
8112c960:	112c6ec0 	call	8112c6ec <__multiply>
8112c964:	90001b26 	beq	r18,zero,8112c9d4 <__pow5mult+0xe8>
8112c968:	91000117 	ldw	r4,4(r18)
8112c96c:	98c01317 	ldw	r3,76(r19)
8112c970:	8021d07a 	srai	r16,r16,1
8112c974:	2109883a 	add	r4,r4,r4
8112c978:	2109883a 	add	r4,r4,r4
8112c97c:	1907883a 	add	r3,r3,r4
8112c980:	19000017 	ldw	r4,0(r3)
8112c984:	91000015 	stw	r4,0(r18)
8112c988:	1c800015 	stw	r18,0(r3)
8112c98c:	1025883a 	mov	r18,r2
8112c990:	803feb1e 	bne	r16,zero,8112c940 <__reset+0xfb10c940>
8112c994:	9005883a 	mov	r2,r18
8112c998:	dfc00517 	ldw	ra,20(sp)
8112c99c:	dd000417 	ldw	r20,16(sp)
8112c9a0:	dcc00317 	ldw	r19,12(sp)
8112c9a4:	dc800217 	ldw	r18,8(sp)
8112c9a8:	dc400117 	ldw	r17,4(sp)
8112c9ac:	dc000017 	ldw	r16,0(sp)
8112c9b0:	dec00604 	addi	sp,sp,24
8112c9b4:	f800283a 	ret
8112c9b8:	880d883a 	mov	r6,r17
8112c9bc:	880b883a 	mov	r5,r17
8112c9c0:	9809883a 	mov	r4,r19
8112c9c4:	112c6ec0 	call	8112c6ec <__multiply>
8112c9c8:	88800015 	stw	r2,0(r17)
8112c9cc:	10000015 	stw	zero,0(r2)
8112c9d0:	003fdd06 	br	8112c948 <__reset+0xfb10c948>
8112c9d4:	1025883a 	mov	r18,r2
8112c9d8:	003fd706 	br	8112c938 <__reset+0xfb10c938>
8112c9dc:	10bfffc4 	addi	r2,r2,-1
8112c9e0:	1085883a 	add	r2,r2,r2
8112c9e4:	00e04574 	movhi	r3,33045
8112c9e8:	18c13204 	addi	r3,r3,1224
8112c9ec:	1085883a 	add	r2,r2,r2
8112c9f0:	1885883a 	add	r2,r3,r2
8112c9f4:	11800017 	ldw	r6,0(r2)
8112c9f8:	000f883a 	mov	r7,zero
8112c9fc:	112c35c0 	call	8112c35c <__multadd>
8112ca00:	1025883a 	mov	r18,r2
8112ca04:	003fc706 	br	8112c924 <__reset+0xfb10c924>
8112ca08:	05000044 	movi	r20,1
8112ca0c:	a00b883a 	mov	r5,r20
8112ca10:	9809883a 	mov	r4,r19
8112ca14:	112c2840 	call	8112c284 <_Balloc>
8112ca18:	1023883a 	mov	r17,r2
8112ca1c:	00809c44 	movi	r2,625
8112ca20:	88800515 	stw	r2,20(r17)
8112ca24:	8d000415 	stw	r20,16(r17)
8112ca28:	9c401215 	stw	r17,72(r19)
8112ca2c:	88000015 	stw	zero,0(r17)
8112ca30:	003fc606 	br	8112c94c <__reset+0xfb10c94c>

8112ca34 <__lshift>:
8112ca34:	defff904 	addi	sp,sp,-28
8112ca38:	de00012e 	bgeu	sp,et,8112ca40 <__lshift+0xc>
8112ca3c:	003b68fa 	trap	3
8112ca40:	dd400515 	stw	r21,20(sp)
8112ca44:	dcc00315 	stw	r19,12(sp)
8112ca48:	302bd17a 	srai	r21,r6,5
8112ca4c:	2cc00417 	ldw	r19,16(r5)
8112ca50:	28800217 	ldw	r2,8(r5)
8112ca54:	dd000415 	stw	r20,16(sp)
8112ca58:	ace7883a 	add	r19,r21,r19
8112ca5c:	dc800215 	stw	r18,8(sp)
8112ca60:	dc400115 	stw	r17,4(sp)
8112ca64:	dc000015 	stw	r16,0(sp)
8112ca68:	dfc00615 	stw	ra,24(sp)
8112ca6c:	9c000044 	addi	r16,r19,1
8112ca70:	2823883a 	mov	r17,r5
8112ca74:	3029883a 	mov	r20,r6
8112ca78:	2025883a 	mov	r18,r4
8112ca7c:	29400117 	ldw	r5,4(r5)
8112ca80:	1400030e 	bge	r2,r16,8112ca90 <__lshift+0x5c>
8112ca84:	1085883a 	add	r2,r2,r2
8112ca88:	29400044 	addi	r5,r5,1
8112ca8c:	143ffd16 	blt	r2,r16,8112ca84 <__reset+0xfb10ca84>
8112ca90:	9009883a 	mov	r4,r18
8112ca94:	112c2840 	call	8112c284 <_Balloc>
8112ca98:	10c00504 	addi	r3,r2,20
8112ca9c:	0540070e 	bge	zero,r21,8112cabc <__lshift+0x88>
8112caa0:	ad6b883a 	add	r21,r21,r21
8112caa4:	ad6b883a 	add	r21,r21,r21
8112caa8:	1809883a 	mov	r4,r3
8112caac:	1d47883a 	add	r3,r3,r21
8112cab0:	20000015 	stw	zero,0(r4)
8112cab4:	21000104 	addi	r4,r4,4
8112cab8:	193ffd1e 	bne	r3,r4,8112cab0 <__reset+0xfb10cab0>
8112cabc:	8a000417 	ldw	r8,16(r17)
8112cac0:	89000504 	addi	r4,r17,20
8112cac4:	a18007cc 	andi	r6,r20,31
8112cac8:	4211883a 	add	r8,r8,r8
8112cacc:	4211883a 	add	r8,r8,r8
8112cad0:	2211883a 	add	r8,r4,r8
8112cad4:	30002326 	beq	r6,zero,8112cb64 <__lshift+0x130>
8112cad8:	02400804 	movi	r9,32
8112cadc:	4993c83a 	sub	r9,r9,r6
8112cae0:	000b883a 	mov	r5,zero
8112cae4:	21c00017 	ldw	r7,0(r4)
8112cae8:	1815883a 	mov	r10,r3
8112caec:	18c00104 	addi	r3,r3,4
8112caf0:	398e983a 	sll	r7,r7,r6
8112caf4:	21000104 	addi	r4,r4,4
8112caf8:	394ab03a 	or	r5,r7,r5
8112cafc:	197fff15 	stw	r5,-4(r3)
8112cb00:	217fff17 	ldw	r5,-4(r4)
8112cb04:	2a4ad83a 	srl	r5,r5,r9
8112cb08:	223ff636 	bltu	r4,r8,8112cae4 <__reset+0xfb10cae4>
8112cb0c:	51400115 	stw	r5,4(r10)
8112cb10:	28001a1e 	bne	r5,zero,8112cb7c <__lshift+0x148>
8112cb14:	843fffc4 	addi	r16,r16,-1
8112cb18:	14000415 	stw	r16,16(r2)
8112cb1c:	88000826 	beq	r17,zero,8112cb40 <__lshift+0x10c>
8112cb20:	89000117 	ldw	r4,4(r17)
8112cb24:	90c01317 	ldw	r3,76(r18)
8112cb28:	2109883a 	add	r4,r4,r4
8112cb2c:	2109883a 	add	r4,r4,r4
8112cb30:	1907883a 	add	r3,r3,r4
8112cb34:	19000017 	ldw	r4,0(r3)
8112cb38:	89000015 	stw	r4,0(r17)
8112cb3c:	1c400015 	stw	r17,0(r3)
8112cb40:	dfc00617 	ldw	ra,24(sp)
8112cb44:	dd400517 	ldw	r21,20(sp)
8112cb48:	dd000417 	ldw	r20,16(sp)
8112cb4c:	dcc00317 	ldw	r19,12(sp)
8112cb50:	dc800217 	ldw	r18,8(sp)
8112cb54:	dc400117 	ldw	r17,4(sp)
8112cb58:	dc000017 	ldw	r16,0(sp)
8112cb5c:	dec00704 	addi	sp,sp,28
8112cb60:	f800283a 	ret
8112cb64:	21400017 	ldw	r5,0(r4)
8112cb68:	18c00104 	addi	r3,r3,4
8112cb6c:	21000104 	addi	r4,r4,4
8112cb70:	197fff15 	stw	r5,-4(r3)
8112cb74:	223ffb36 	bltu	r4,r8,8112cb64 <__reset+0xfb10cb64>
8112cb78:	003fe606 	br	8112cb14 <__reset+0xfb10cb14>
8112cb7c:	9c000084 	addi	r16,r19,2
8112cb80:	003fe406 	br	8112cb14 <__reset+0xfb10cb14>

8112cb84 <__mcmp>:
8112cb84:	20800417 	ldw	r2,16(r4)
8112cb88:	28c00417 	ldw	r3,16(r5)
8112cb8c:	10c5c83a 	sub	r2,r2,r3
8112cb90:	1000111e 	bne	r2,zero,8112cbd8 <__mcmp+0x54>
8112cb94:	18c7883a 	add	r3,r3,r3
8112cb98:	18c7883a 	add	r3,r3,r3
8112cb9c:	21000504 	addi	r4,r4,20
8112cba0:	29400504 	addi	r5,r5,20
8112cba4:	20c5883a 	add	r2,r4,r3
8112cba8:	28cb883a 	add	r5,r5,r3
8112cbac:	00000106 	br	8112cbb4 <__mcmp+0x30>
8112cbb0:	20800a2e 	bgeu	r4,r2,8112cbdc <__mcmp+0x58>
8112cbb4:	10bfff04 	addi	r2,r2,-4
8112cbb8:	297fff04 	addi	r5,r5,-4
8112cbbc:	11800017 	ldw	r6,0(r2)
8112cbc0:	28c00017 	ldw	r3,0(r5)
8112cbc4:	30fffa26 	beq	r6,r3,8112cbb0 <__reset+0xfb10cbb0>
8112cbc8:	30c00236 	bltu	r6,r3,8112cbd4 <__mcmp+0x50>
8112cbcc:	00800044 	movi	r2,1
8112cbd0:	f800283a 	ret
8112cbd4:	00bfffc4 	movi	r2,-1
8112cbd8:	f800283a 	ret
8112cbdc:	0005883a 	mov	r2,zero
8112cbe0:	f800283a 	ret

8112cbe4 <__mdiff>:
8112cbe4:	defffa04 	addi	sp,sp,-24
8112cbe8:	de00012e 	bgeu	sp,et,8112cbf0 <__mdiff+0xc>
8112cbec:	003b68fa 	trap	3
8112cbf0:	28c00417 	ldw	r3,16(r5)
8112cbf4:	30800417 	ldw	r2,16(r6)
8112cbf8:	dcc00315 	stw	r19,12(sp)
8112cbfc:	dc800215 	stw	r18,8(sp)
8112cc00:	dfc00515 	stw	ra,20(sp)
8112cc04:	dd000415 	stw	r20,16(sp)
8112cc08:	dc400115 	stw	r17,4(sp)
8112cc0c:	dc000015 	stw	r16,0(sp)
8112cc10:	1887c83a 	sub	r3,r3,r2
8112cc14:	2825883a 	mov	r18,r5
8112cc18:	3027883a 	mov	r19,r6
8112cc1c:	1800141e 	bne	r3,zero,8112cc70 <__mdiff+0x8c>
8112cc20:	1085883a 	add	r2,r2,r2
8112cc24:	1085883a 	add	r2,r2,r2
8112cc28:	2a000504 	addi	r8,r5,20
8112cc2c:	34000504 	addi	r16,r6,20
8112cc30:	4087883a 	add	r3,r8,r2
8112cc34:	8085883a 	add	r2,r16,r2
8112cc38:	00000106 	br	8112cc40 <__mdiff+0x5c>
8112cc3c:	40c0592e 	bgeu	r8,r3,8112cda4 <__mdiff+0x1c0>
8112cc40:	18ffff04 	addi	r3,r3,-4
8112cc44:	10bfff04 	addi	r2,r2,-4
8112cc48:	19c00017 	ldw	r7,0(r3)
8112cc4c:	11400017 	ldw	r5,0(r2)
8112cc50:	397ffa26 	beq	r7,r5,8112cc3c <__reset+0xfb10cc3c>
8112cc54:	3940592e 	bgeu	r7,r5,8112cdbc <__mdiff+0x1d8>
8112cc58:	9005883a 	mov	r2,r18
8112cc5c:	4023883a 	mov	r17,r8
8112cc60:	9825883a 	mov	r18,r19
8112cc64:	05000044 	movi	r20,1
8112cc68:	1027883a 	mov	r19,r2
8112cc6c:	00000406 	br	8112cc80 <__mdiff+0x9c>
8112cc70:	18005616 	blt	r3,zero,8112cdcc <__mdiff+0x1e8>
8112cc74:	34400504 	addi	r17,r6,20
8112cc78:	2c000504 	addi	r16,r5,20
8112cc7c:	0029883a 	mov	r20,zero
8112cc80:	91400117 	ldw	r5,4(r18)
8112cc84:	112c2840 	call	8112c284 <_Balloc>
8112cc88:	92400417 	ldw	r9,16(r18)
8112cc8c:	9b000417 	ldw	r12,16(r19)
8112cc90:	12c00504 	addi	r11,r2,20
8112cc94:	4a51883a 	add	r8,r9,r9
8112cc98:	6319883a 	add	r12,r12,r12
8112cc9c:	4211883a 	add	r8,r8,r8
8112cca0:	6319883a 	add	r12,r12,r12
8112cca4:	15000315 	stw	r20,12(r2)
8112cca8:	8211883a 	add	r8,r16,r8
8112ccac:	8b19883a 	add	r12,r17,r12
8112ccb0:	0007883a 	mov	r3,zero
8112ccb4:	81400017 	ldw	r5,0(r16)
8112ccb8:	89c00017 	ldw	r7,0(r17)
8112ccbc:	59800104 	addi	r6,r11,4
8112ccc0:	293fffcc 	andi	r4,r5,65535
8112ccc4:	20c7883a 	add	r3,r4,r3
8112ccc8:	393fffcc 	andi	r4,r7,65535
8112cccc:	1909c83a 	sub	r4,r3,r4
8112ccd0:	280ad43a 	srli	r5,r5,16
8112ccd4:	380ed43a 	srli	r7,r7,16
8112ccd8:	2007d43a 	srai	r3,r4,16
8112ccdc:	213fffcc 	andi	r4,r4,65535
8112cce0:	29cbc83a 	sub	r5,r5,r7
8112cce4:	28c7883a 	add	r3,r5,r3
8112cce8:	180a943a 	slli	r5,r3,16
8112ccec:	8c400104 	addi	r17,r17,4
8112ccf0:	84000104 	addi	r16,r16,4
8112ccf4:	2908b03a 	or	r4,r5,r4
8112ccf8:	59000015 	stw	r4,0(r11)
8112ccfc:	1807d43a 	srai	r3,r3,16
8112cd00:	3015883a 	mov	r10,r6
8112cd04:	3017883a 	mov	r11,r6
8112cd08:	8b3fea36 	bltu	r17,r12,8112ccb4 <__reset+0xfb10ccb4>
8112cd0c:	8200162e 	bgeu	r16,r8,8112cd68 <__mdiff+0x184>
8112cd10:	8017883a 	mov	r11,r16
8112cd14:	59400017 	ldw	r5,0(r11)
8112cd18:	31800104 	addi	r6,r6,4
8112cd1c:	5ac00104 	addi	r11,r11,4
8112cd20:	293fffcc 	andi	r4,r5,65535
8112cd24:	20c7883a 	add	r3,r4,r3
8112cd28:	280ed43a 	srli	r7,r5,16
8112cd2c:	180bd43a 	srai	r5,r3,16
8112cd30:	193fffcc 	andi	r4,r3,65535
8112cd34:	3947883a 	add	r3,r7,r5
8112cd38:	180a943a 	slli	r5,r3,16
8112cd3c:	1807d43a 	srai	r3,r3,16
8112cd40:	2908b03a 	or	r4,r5,r4
8112cd44:	313fff15 	stw	r4,-4(r6)
8112cd48:	5a3ff236 	bltu	r11,r8,8112cd14 <__reset+0xfb10cd14>
8112cd4c:	0406303a 	nor	r3,zero,r16
8112cd50:	1a07883a 	add	r3,r3,r8
8112cd54:	1806d0ba 	srli	r3,r3,2
8112cd58:	18c00044 	addi	r3,r3,1
8112cd5c:	18c7883a 	add	r3,r3,r3
8112cd60:	18c7883a 	add	r3,r3,r3
8112cd64:	50d5883a 	add	r10,r10,r3
8112cd68:	50ffff04 	addi	r3,r10,-4
8112cd6c:	2000041e 	bne	r4,zero,8112cd80 <__mdiff+0x19c>
8112cd70:	18ffff04 	addi	r3,r3,-4
8112cd74:	19000017 	ldw	r4,0(r3)
8112cd78:	4a7fffc4 	addi	r9,r9,-1
8112cd7c:	203ffc26 	beq	r4,zero,8112cd70 <__reset+0xfb10cd70>
8112cd80:	12400415 	stw	r9,16(r2)
8112cd84:	dfc00517 	ldw	ra,20(sp)
8112cd88:	dd000417 	ldw	r20,16(sp)
8112cd8c:	dcc00317 	ldw	r19,12(sp)
8112cd90:	dc800217 	ldw	r18,8(sp)
8112cd94:	dc400117 	ldw	r17,4(sp)
8112cd98:	dc000017 	ldw	r16,0(sp)
8112cd9c:	dec00604 	addi	sp,sp,24
8112cda0:	f800283a 	ret
8112cda4:	000b883a 	mov	r5,zero
8112cda8:	112c2840 	call	8112c284 <_Balloc>
8112cdac:	00c00044 	movi	r3,1
8112cdb0:	10c00415 	stw	r3,16(r2)
8112cdb4:	10000515 	stw	zero,20(r2)
8112cdb8:	003ff206 	br	8112cd84 <__reset+0xfb10cd84>
8112cdbc:	8023883a 	mov	r17,r16
8112cdc0:	0029883a 	mov	r20,zero
8112cdc4:	4021883a 	mov	r16,r8
8112cdc8:	003fad06 	br	8112cc80 <__reset+0xfb10cc80>
8112cdcc:	9005883a 	mov	r2,r18
8112cdd0:	94400504 	addi	r17,r18,20
8112cdd4:	9c000504 	addi	r16,r19,20
8112cdd8:	9825883a 	mov	r18,r19
8112cddc:	05000044 	movi	r20,1
8112cde0:	1027883a 	mov	r19,r2
8112cde4:	003fa606 	br	8112cc80 <__reset+0xfb10cc80>

8112cde8 <__ulp>:
8112cde8:	295ffc2c 	andhi	r5,r5,32752
8112cdec:	00bf3034 	movhi	r2,64704
8112cdf0:	2887883a 	add	r3,r5,r2
8112cdf4:	00c0020e 	bge	zero,r3,8112ce00 <__ulp+0x18>
8112cdf8:	0005883a 	mov	r2,zero
8112cdfc:	f800283a 	ret
8112ce00:	00c7c83a 	sub	r3,zero,r3
8112ce04:	1807d53a 	srai	r3,r3,20
8112ce08:	008004c4 	movi	r2,19
8112ce0c:	10c00b0e 	bge	r2,r3,8112ce3c <__ulp+0x54>
8112ce10:	18bffb04 	addi	r2,r3,-20
8112ce14:	01000784 	movi	r4,30
8112ce18:	0007883a 	mov	r3,zero
8112ce1c:	20800516 	blt	r4,r2,8112ce34 <__ulp+0x4c>
8112ce20:	010007c4 	movi	r4,31
8112ce24:	2089c83a 	sub	r4,r4,r2
8112ce28:	00800044 	movi	r2,1
8112ce2c:	1104983a 	sll	r2,r2,r4
8112ce30:	f800283a 	ret
8112ce34:	00800044 	movi	r2,1
8112ce38:	f800283a 	ret
8112ce3c:	01400234 	movhi	r5,8
8112ce40:	28c7d83a 	sra	r3,r5,r3
8112ce44:	0005883a 	mov	r2,zero
8112ce48:	f800283a 	ret

8112ce4c <__b2d>:
8112ce4c:	defffa04 	addi	sp,sp,-24
8112ce50:	de00012e 	bgeu	sp,et,8112ce58 <__b2d+0xc>
8112ce54:	003b68fa 	trap	3
8112ce58:	dc000015 	stw	r16,0(sp)
8112ce5c:	24000417 	ldw	r16,16(r4)
8112ce60:	dc400115 	stw	r17,4(sp)
8112ce64:	24400504 	addi	r17,r4,20
8112ce68:	8421883a 	add	r16,r16,r16
8112ce6c:	8421883a 	add	r16,r16,r16
8112ce70:	8c21883a 	add	r16,r17,r16
8112ce74:	dc800215 	stw	r18,8(sp)
8112ce78:	84bfff17 	ldw	r18,-4(r16)
8112ce7c:	dd000415 	stw	r20,16(sp)
8112ce80:	dcc00315 	stw	r19,12(sp)
8112ce84:	9009883a 	mov	r4,r18
8112ce88:	2829883a 	mov	r20,r5
8112ce8c:	dfc00515 	stw	ra,20(sp)
8112ce90:	112c5900 	call	8112c590 <__hi0bits>
8112ce94:	00c00804 	movi	r3,32
8112ce98:	1889c83a 	sub	r4,r3,r2
8112ce9c:	a1000015 	stw	r4,0(r20)
8112cea0:	01000284 	movi	r4,10
8112cea4:	84ffff04 	addi	r19,r16,-4
8112cea8:	20801216 	blt	r4,r2,8112cef4 <__b2d+0xa8>
8112ceac:	018002c4 	movi	r6,11
8112ceb0:	308dc83a 	sub	r6,r6,r2
8112ceb4:	9186d83a 	srl	r3,r18,r6
8112ceb8:	18cffc34 	orhi	r3,r3,16368
8112cebc:	8cc0212e 	bgeu	r17,r19,8112cf44 <__b2d+0xf8>
8112cec0:	813ffe17 	ldw	r4,-8(r16)
8112cec4:	218cd83a 	srl	r6,r4,r6
8112cec8:	10800544 	addi	r2,r2,21
8112cecc:	9084983a 	sll	r2,r18,r2
8112ced0:	1184b03a 	or	r2,r2,r6
8112ced4:	dfc00517 	ldw	ra,20(sp)
8112ced8:	dd000417 	ldw	r20,16(sp)
8112cedc:	dcc00317 	ldw	r19,12(sp)
8112cee0:	dc800217 	ldw	r18,8(sp)
8112cee4:	dc400117 	ldw	r17,4(sp)
8112cee8:	dc000017 	ldw	r16,0(sp)
8112ceec:	dec00604 	addi	sp,sp,24
8112cef0:	f800283a 	ret
8112cef4:	8cc00f2e 	bgeu	r17,r19,8112cf34 <__b2d+0xe8>
8112cef8:	117ffd44 	addi	r5,r2,-11
8112cefc:	80bffe17 	ldw	r2,-8(r16)
8112cf00:	28000e26 	beq	r5,zero,8112cf3c <__b2d+0xf0>
8112cf04:	1949c83a 	sub	r4,r3,r5
8112cf08:	9164983a 	sll	r18,r18,r5
8112cf0c:	1106d83a 	srl	r3,r2,r4
8112cf10:	81bffe04 	addi	r6,r16,-8
8112cf14:	948ffc34 	orhi	r18,r18,16368
8112cf18:	90c6b03a 	or	r3,r18,r3
8112cf1c:	89800e2e 	bgeu	r17,r6,8112cf58 <__b2d+0x10c>
8112cf20:	81bffd17 	ldw	r6,-12(r16)
8112cf24:	1144983a 	sll	r2,r2,r5
8112cf28:	310ad83a 	srl	r5,r6,r4
8112cf2c:	2884b03a 	or	r2,r5,r2
8112cf30:	003fe806 	br	8112ced4 <__reset+0xfb10ced4>
8112cf34:	10bffd44 	addi	r2,r2,-11
8112cf38:	1000041e 	bne	r2,zero,8112cf4c <__b2d+0x100>
8112cf3c:	90cffc34 	orhi	r3,r18,16368
8112cf40:	003fe406 	br	8112ced4 <__reset+0xfb10ced4>
8112cf44:	000d883a 	mov	r6,zero
8112cf48:	003fdf06 	br	8112cec8 <__reset+0xfb10cec8>
8112cf4c:	90a4983a 	sll	r18,r18,r2
8112cf50:	0005883a 	mov	r2,zero
8112cf54:	003ff906 	br	8112cf3c <__reset+0xfb10cf3c>
8112cf58:	1144983a 	sll	r2,r2,r5
8112cf5c:	003fdd06 	br	8112ced4 <__reset+0xfb10ced4>

8112cf60 <__d2b>:
8112cf60:	defff804 	addi	sp,sp,-32
8112cf64:	de00012e 	bgeu	sp,et,8112cf6c <__d2b+0xc>
8112cf68:	003b68fa 	trap	3
8112cf6c:	dc000215 	stw	r16,8(sp)
8112cf70:	3021883a 	mov	r16,r6
8112cf74:	dc400315 	stw	r17,12(sp)
8112cf78:	8022907a 	slli	r17,r16,1
8112cf7c:	dd000615 	stw	r20,24(sp)
8112cf80:	2829883a 	mov	r20,r5
8112cf84:	01400044 	movi	r5,1
8112cf88:	dcc00515 	stw	r19,20(sp)
8112cf8c:	dc800415 	stw	r18,16(sp)
8112cf90:	dfc00715 	stw	ra,28(sp)
8112cf94:	3825883a 	mov	r18,r7
8112cf98:	8822d57a 	srli	r17,r17,21
8112cf9c:	112c2840 	call	8112c284 <_Balloc>
8112cfa0:	1027883a 	mov	r19,r2
8112cfa4:	00800434 	movhi	r2,16
8112cfa8:	10bfffc4 	addi	r2,r2,-1
8112cfac:	808c703a 	and	r6,r16,r2
8112cfb0:	88000126 	beq	r17,zero,8112cfb8 <__d2b+0x58>
8112cfb4:	31800434 	orhi	r6,r6,16
8112cfb8:	d9800015 	stw	r6,0(sp)
8112cfbc:	a0002426 	beq	r20,zero,8112d050 <__d2b+0xf0>
8112cfc0:	d9000104 	addi	r4,sp,4
8112cfc4:	dd000115 	stw	r20,4(sp)
8112cfc8:	112c5f80 	call	8112c5f8 <__lo0bits>
8112cfcc:	d8c00017 	ldw	r3,0(sp)
8112cfd0:	10002f1e 	bne	r2,zero,8112d090 <__d2b+0x130>
8112cfd4:	d9000117 	ldw	r4,4(sp)
8112cfd8:	99000515 	stw	r4,20(r19)
8112cfdc:	1821003a 	cmpeq	r16,r3,zero
8112cfe0:	01000084 	movi	r4,2
8112cfe4:	2421c83a 	sub	r16,r4,r16
8112cfe8:	98c00615 	stw	r3,24(r19)
8112cfec:	9c000415 	stw	r16,16(r19)
8112cff0:	88001f1e 	bne	r17,zero,8112d070 <__d2b+0x110>
8112cff4:	10bef384 	addi	r2,r2,-1074
8112cff8:	90800015 	stw	r2,0(r18)
8112cffc:	00900034 	movhi	r2,16384
8112d000:	10bfffc4 	addi	r2,r2,-1
8112d004:	8085883a 	add	r2,r16,r2
8112d008:	1085883a 	add	r2,r2,r2
8112d00c:	1085883a 	add	r2,r2,r2
8112d010:	9885883a 	add	r2,r19,r2
8112d014:	11000517 	ldw	r4,20(r2)
8112d018:	8020917a 	slli	r16,r16,5
8112d01c:	112c5900 	call	8112c590 <__hi0bits>
8112d020:	d8c00817 	ldw	r3,32(sp)
8112d024:	8085c83a 	sub	r2,r16,r2
8112d028:	18800015 	stw	r2,0(r3)
8112d02c:	9805883a 	mov	r2,r19
8112d030:	dfc00717 	ldw	ra,28(sp)
8112d034:	dd000617 	ldw	r20,24(sp)
8112d038:	dcc00517 	ldw	r19,20(sp)
8112d03c:	dc800417 	ldw	r18,16(sp)
8112d040:	dc400317 	ldw	r17,12(sp)
8112d044:	dc000217 	ldw	r16,8(sp)
8112d048:	dec00804 	addi	sp,sp,32
8112d04c:	f800283a 	ret
8112d050:	d809883a 	mov	r4,sp
8112d054:	112c5f80 	call	8112c5f8 <__lo0bits>
8112d058:	d8c00017 	ldw	r3,0(sp)
8112d05c:	04000044 	movi	r16,1
8112d060:	9c000415 	stw	r16,16(r19)
8112d064:	98c00515 	stw	r3,20(r19)
8112d068:	10800804 	addi	r2,r2,32
8112d06c:	883fe126 	beq	r17,zero,8112cff4 <__reset+0xfb10cff4>
8112d070:	00c00d44 	movi	r3,53
8112d074:	8c7ef344 	addi	r17,r17,-1075
8112d078:	88a3883a 	add	r17,r17,r2
8112d07c:	1885c83a 	sub	r2,r3,r2
8112d080:	d8c00817 	ldw	r3,32(sp)
8112d084:	94400015 	stw	r17,0(r18)
8112d088:	18800015 	stw	r2,0(r3)
8112d08c:	003fe706 	br	8112d02c <__reset+0xfb10d02c>
8112d090:	01000804 	movi	r4,32
8112d094:	2089c83a 	sub	r4,r4,r2
8112d098:	1908983a 	sll	r4,r3,r4
8112d09c:	d9400117 	ldw	r5,4(sp)
8112d0a0:	1886d83a 	srl	r3,r3,r2
8112d0a4:	2148b03a 	or	r4,r4,r5
8112d0a8:	99000515 	stw	r4,20(r19)
8112d0ac:	d8c00015 	stw	r3,0(sp)
8112d0b0:	003fca06 	br	8112cfdc <__reset+0xfb10cfdc>

8112d0b4 <__ratio>:
8112d0b4:	defff904 	addi	sp,sp,-28
8112d0b8:	de00012e 	bgeu	sp,et,8112d0c0 <__ratio+0xc>
8112d0bc:	003b68fa 	trap	3
8112d0c0:	dc400315 	stw	r17,12(sp)
8112d0c4:	2823883a 	mov	r17,r5
8112d0c8:	d9400104 	addi	r5,sp,4
8112d0cc:	dfc00615 	stw	ra,24(sp)
8112d0d0:	dcc00515 	stw	r19,20(sp)
8112d0d4:	dc800415 	stw	r18,16(sp)
8112d0d8:	2027883a 	mov	r19,r4
8112d0dc:	dc000215 	stw	r16,8(sp)
8112d0e0:	112ce4c0 	call	8112ce4c <__b2d>
8112d0e4:	d80b883a 	mov	r5,sp
8112d0e8:	8809883a 	mov	r4,r17
8112d0ec:	1025883a 	mov	r18,r2
8112d0f0:	1821883a 	mov	r16,r3
8112d0f4:	112ce4c0 	call	8112ce4c <__b2d>
8112d0f8:	8a000417 	ldw	r8,16(r17)
8112d0fc:	99000417 	ldw	r4,16(r19)
8112d100:	d9400117 	ldw	r5,4(sp)
8112d104:	2209c83a 	sub	r4,r4,r8
8112d108:	2010917a 	slli	r8,r4,5
8112d10c:	d9000017 	ldw	r4,0(sp)
8112d110:	2909c83a 	sub	r4,r5,r4
8112d114:	4109883a 	add	r4,r8,r4
8112d118:	01000e0e 	bge	zero,r4,8112d154 <__ratio+0xa0>
8112d11c:	2008953a 	slli	r4,r4,20
8112d120:	2421883a 	add	r16,r4,r16
8112d124:	100d883a 	mov	r6,r2
8112d128:	180f883a 	mov	r7,r3
8112d12c:	9009883a 	mov	r4,r18
8112d130:	800b883a 	mov	r5,r16
8112d134:	113512c0 	call	8113512c <__divdf3>
8112d138:	dfc00617 	ldw	ra,24(sp)
8112d13c:	dcc00517 	ldw	r19,20(sp)
8112d140:	dc800417 	ldw	r18,16(sp)
8112d144:	dc400317 	ldw	r17,12(sp)
8112d148:	dc000217 	ldw	r16,8(sp)
8112d14c:	dec00704 	addi	sp,sp,28
8112d150:	f800283a 	ret
8112d154:	2008953a 	slli	r4,r4,20
8112d158:	1907c83a 	sub	r3,r3,r4
8112d15c:	003ff106 	br	8112d124 <__reset+0xfb10d124>

8112d160 <_mprec_log10>:
8112d160:	defffe04 	addi	sp,sp,-8
8112d164:	de00012e 	bgeu	sp,et,8112d16c <_mprec_log10+0xc>
8112d168:	003b68fa 	trap	3
8112d16c:	008005c4 	movi	r2,23
8112d170:	dc000015 	stw	r16,0(sp)
8112d174:	dfc00115 	stw	ra,4(sp)
8112d178:	2021883a 	mov	r16,r4
8112d17c:	11000d0e 	bge	r2,r4,8112d1b4 <_mprec_log10+0x54>
8112d180:	0005883a 	mov	r2,zero
8112d184:	00cffc34 	movhi	r3,16368
8112d188:	843fffc4 	addi	r16,r16,-1
8112d18c:	000d883a 	mov	r6,zero
8112d190:	01d00934 	movhi	r7,16420
8112d194:	1009883a 	mov	r4,r2
8112d198:	180b883a 	mov	r5,r3
8112d19c:	111f99c0 	call	8111f99c <__muldf3>
8112d1a0:	803ff91e 	bne	r16,zero,8112d188 <__reset+0xfb10d188>
8112d1a4:	dfc00117 	ldw	ra,4(sp)
8112d1a8:	dc000017 	ldw	r16,0(sp)
8112d1ac:	dec00204 	addi	sp,sp,8
8112d1b0:	f800283a 	ret
8112d1b4:	202090fa 	slli	r16,r4,3
8112d1b8:	00a04574 	movhi	r2,33045
8112d1bc:	10814904 	addi	r2,r2,1316
8112d1c0:	1421883a 	add	r16,r2,r16
8112d1c4:	80800017 	ldw	r2,0(r16)
8112d1c8:	80c00117 	ldw	r3,4(r16)
8112d1cc:	dfc00117 	ldw	ra,4(sp)
8112d1d0:	dc000017 	ldw	r16,0(sp)
8112d1d4:	dec00204 	addi	sp,sp,8
8112d1d8:	f800283a 	ret

8112d1dc <__copybits>:
8112d1dc:	297fffc4 	addi	r5,r5,-1
8112d1e0:	280fd17a 	srai	r7,r5,5
8112d1e4:	30c00417 	ldw	r3,16(r6)
8112d1e8:	30800504 	addi	r2,r6,20
8112d1ec:	39c00044 	addi	r7,r7,1
8112d1f0:	18c7883a 	add	r3,r3,r3
8112d1f4:	39cf883a 	add	r7,r7,r7
8112d1f8:	18c7883a 	add	r3,r3,r3
8112d1fc:	39cf883a 	add	r7,r7,r7
8112d200:	10c7883a 	add	r3,r2,r3
8112d204:	21cf883a 	add	r7,r4,r7
8112d208:	10c00d2e 	bgeu	r2,r3,8112d240 <__copybits+0x64>
8112d20c:	200b883a 	mov	r5,r4
8112d210:	12000017 	ldw	r8,0(r2)
8112d214:	29400104 	addi	r5,r5,4
8112d218:	10800104 	addi	r2,r2,4
8112d21c:	2a3fff15 	stw	r8,-4(r5)
8112d220:	10fffb36 	bltu	r2,r3,8112d210 <__reset+0xfb10d210>
8112d224:	1985c83a 	sub	r2,r3,r6
8112d228:	10bffac4 	addi	r2,r2,-21
8112d22c:	1004d0ba 	srli	r2,r2,2
8112d230:	10800044 	addi	r2,r2,1
8112d234:	1085883a 	add	r2,r2,r2
8112d238:	1085883a 	add	r2,r2,r2
8112d23c:	2089883a 	add	r4,r4,r2
8112d240:	21c0032e 	bgeu	r4,r7,8112d250 <__copybits+0x74>
8112d244:	20000015 	stw	zero,0(r4)
8112d248:	21000104 	addi	r4,r4,4
8112d24c:	21fffd36 	bltu	r4,r7,8112d244 <__reset+0xfb10d244>
8112d250:	f800283a 	ret

8112d254 <__any_on>:
8112d254:	20c00417 	ldw	r3,16(r4)
8112d258:	2805d17a 	srai	r2,r5,5
8112d25c:	21000504 	addi	r4,r4,20
8112d260:	18800d0e 	bge	r3,r2,8112d298 <__any_on+0x44>
8112d264:	18c7883a 	add	r3,r3,r3
8112d268:	18c7883a 	add	r3,r3,r3
8112d26c:	20c7883a 	add	r3,r4,r3
8112d270:	20c0192e 	bgeu	r4,r3,8112d2d8 <__any_on+0x84>
8112d274:	18bfff17 	ldw	r2,-4(r3)
8112d278:	18ffff04 	addi	r3,r3,-4
8112d27c:	1000041e 	bne	r2,zero,8112d290 <__any_on+0x3c>
8112d280:	20c0142e 	bgeu	r4,r3,8112d2d4 <__any_on+0x80>
8112d284:	18ffff04 	addi	r3,r3,-4
8112d288:	19400017 	ldw	r5,0(r3)
8112d28c:	283ffc26 	beq	r5,zero,8112d280 <__reset+0xfb10d280>
8112d290:	00800044 	movi	r2,1
8112d294:	f800283a 	ret
8112d298:	10c00a0e 	bge	r2,r3,8112d2c4 <__any_on+0x70>
8112d29c:	1085883a 	add	r2,r2,r2
8112d2a0:	1085883a 	add	r2,r2,r2
8112d2a4:	294007cc 	andi	r5,r5,31
8112d2a8:	2087883a 	add	r3,r4,r2
8112d2ac:	283ff026 	beq	r5,zero,8112d270 <__reset+0xfb10d270>
8112d2b0:	19800017 	ldw	r6,0(r3)
8112d2b4:	3144d83a 	srl	r2,r6,r5
8112d2b8:	114a983a 	sll	r5,r2,r5
8112d2bc:	317ff41e 	bne	r6,r5,8112d290 <__reset+0xfb10d290>
8112d2c0:	003feb06 	br	8112d270 <__reset+0xfb10d270>
8112d2c4:	1085883a 	add	r2,r2,r2
8112d2c8:	1085883a 	add	r2,r2,r2
8112d2cc:	2087883a 	add	r3,r4,r2
8112d2d0:	003fe706 	br	8112d270 <__reset+0xfb10d270>
8112d2d4:	f800283a 	ret
8112d2d8:	0005883a 	mov	r2,zero
8112d2dc:	f800283a 	ret

8112d2e0 <_read_r>:
8112d2e0:	defffd04 	addi	sp,sp,-12
8112d2e4:	de00012e 	bgeu	sp,et,8112d2ec <_read_r+0xc>
8112d2e8:	003b68fa 	trap	3
8112d2ec:	2805883a 	mov	r2,r5
8112d2f0:	dc000015 	stw	r16,0(sp)
8112d2f4:	04204574 	movhi	r16,33045
8112d2f8:	dc400115 	stw	r17,4(sp)
8112d2fc:	300b883a 	mov	r5,r6
8112d300:	840b4b04 	addi	r16,r16,11564
8112d304:	2023883a 	mov	r17,r4
8112d308:	380d883a 	mov	r6,r7
8112d30c:	1009883a 	mov	r4,r2
8112d310:	dfc00215 	stw	ra,8(sp)
8112d314:	80000015 	stw	zero,0(r16)
8112d318:	113729c0 	call	8113729c <read>
8112d31c:	00ffffc4 	movi	r3,-1
8112d320:	10c00526 	beq	r2,r3,8112d338 <_read_r+0x58>
8112d324:	dfc00217 	ldw	ra,8(sp)
8112d328:	dc400117 	ldw	r17,4(sp)
8112d32c:	dc000017 	ldw	r16,0(sp)
8112d330:	dec00304 	addi	sp,sp,12
8112d334:	f800283a 	ret
8112d338:	80c00017 	ldw	r3,0(r16)
8112d33c:	183ff926 	beq	r3,zero,8112d324 <__reset+0xfb10d324>
8112d340:	88c00015 	stw	r3,0(r17)
8112d344:	003ff706 	br	8112d324 <__reset+0xfb10d324>

8112d348 <_realloc_r>:
8112d348:	defff604 	addi	sp,sp,-40
8112d34c:	de00012e 	bgeu	sp,et,8112d354 <_realloc_r+0xc>
8112d350:	003b68fa 	trap	3
8112d354:	dc800215 	stw	r18,8(sp)
8112d358:	dfc00915 	stw	ra,36(sp)
8112d35c:	df000815 	stw	fp,32(sp)
8112d360:	ddc00715 	stw	r23,28(sp)
8112d364:	dd800615 	stw	r22,24(sp)
8112d368:	dd400515 	stw	r21,20(sp)
8112d36c:	dd000415 	stw	r20,16(sp)
8112d370:	dcc00315 	stw	r19,12(sp)
8112d374:	dc400115 	stw	r17,4(sp)
8112d378:	dc000015 	stw	r16,0(sp)
8112d37c:	3025883a 	mov	r18,r6
8112d380:	2800b726 	beq	r5,zero,8112d660 <_realloc_r+0x318>
8112d384:	282b883a 	mov	r21,r5
8112d388:	2029883a 	mov	r20,r4
8112d38c:	1137a7c0 	call	81137a7c <__malloc_lock>
8112d390:	a8bfff17 	ldw	r2,-4(r21)
8112d394:	043fff04 	movi	r16,-4
8112d398:	90c002c4 	addi	r3,r18,11
8112d39c:	01000584 	movi	r4,22
8112d3a0:	acfffe04 	addi	r19,r21,-8
8112d3a4:	1420703a 	and	r16,r2,r16
8112d3a8:	20c0332e 	bgeu	r4,r3,8112d478 <_realloc_r+0x130>
8112d3ac:	047ffe04 	movi	r17,-8
8112d3b0:	1c62703a 	and	r17,r3,r17
8112d3b4:	8807883a 	mov	r3,r17
8112d3b8:	88005816 	blt	r17,zero,8112d51c <_realloc_r+0x1d4>
8112d3bc:	8c805736 	bltu	r17,r18,8112d51c <_realloc_r+0x1d4>
8112d3c0:	80c0300e 	bge	r16,r3,8112d484 <_realloc_r+0x13c>
8112d3c4:	07204574 	movhi	fp,33045
8112d3c8:	e7049604 	addi	fp,fp,4696
8112d3cc:	e1c00217 	ldw	r7,8(fp)
8112d3d0:	9c09883a 	add	r4,r19,r16
8112d3d4:	22000117 	ldw	r8,4(r4)
8112d3d8:	21c06326 	beq	r4,r7,8112d568 <_realloc_r+0x220>
8112d3dc:	017fff84 	movi	r5,-2
8112d3e0:	414a703a 	and	r5,r8,r5
8112d3e4:	214b883a 	add	r5,r4,r5
8112d3e8:	29800117 	ldw	r6,4(r5)
8112d3ec:	3180004c 	andi	r6,r6,1
8112d3f0:	30003f26 	beq	r6,zero,8112d4f0 <_realloc_r+0x1a8>
8112d3f4:	1080004c 	andi	r2,r2,1
8112d3f8:	10008326 	beq	r2,zero,8112d608 <_realloc_r+0x2c0>
8112d3fc:	900b883a 	mov	r5,r18
8112d400:	a009883a 	mov	r4,r20
8112d404:	11218400 	call	81121840 <_malloc_r>
8112d408:	1025883a 	mov	r18,r2
8112d40c:	10011e26 	beq	r2,zero,8112d888 <_realloc_r+0x540>
8112d410:	a93fff17 	ldw	r4,-4(r21)
8112d414:	10fffe04 	addi	r3,r2,-8
8112d418:	00bfff84 	movi	r2,-2
8112d41c:	2084703a 	and	r2,r4,r2
8112d420:	9885883a 	add	r2,r19,r2
8112d424:	1880ee26 	beq	r3,r2,8112d7e0 <_realloc_r+0x498>
8112d428:	81bfff04 	addi	r6,r16,-4
8112d42c:	00800904 	movi	r2,36
8112d430:	1180b836 	bltu	r2,r6,8112d714 <_realloc_r+0x3cc>
8112d434:	00c004c4 	movi	r3,19
8112d438:	19809636 	bltu	r3,r6,8112d694 <_realloc_r+0x34c>
8112d43c:	9005883a 	mov	r2,r18
8112d440:	a807883a 	mov	r3,r21
8112d444:	19000017 	ldw	r4,0(r3)
8112d448:	11000015 	stw	r4,0(r2)
8112d44c:	19000117 	ldw	r4,4(r3)
8112d450:	11000115 	stw	r4,4(r2)
8112d454:	18c00217 	ldw	r3,8(r3)
8112d458:	10c00215 	stw	r3,8(r2)
8112d45c:	a80b883a 	mov	r5,r21
8112d460:	a009883a 	mov	r4,r20
8112d464:	112b2b40 	call	8112b2b4 <_free_r>
8112d468:	a009883a 	mov	r4,r20
8112d46c:	1137ba40 	call	81137ba4 <__malloc_unlock>
8112d470:	9005883a 	mov	r2,r18
8112d474:	00001206 	br	8112d4c0 <_realloc_r+0x178>
8112d478:	00c00404 	movi	r3,16
8112d47c:	1823883a 	mov	r17,r3
8112d480:	003fce06 	br	8112d3bc <__reset+0xfb10d3bc>
8112d484:	a825883a 	mov	r18,r21
8112d488:	8445c83a 	sub	r2,r16,r17
8112d48c:	00c003c4 	movi	r3,15
8112d490:	18802636 	bltu	r3,r2,8112d52c <_realloc_r+0x1e4>
8112d494:	99800117 	ldw	r6,4(r19)
8112d498:	9c07883a 	add	r3,r19,r16
8112d49c:	3180004c 	andi	r6,r6,1
8112d4a0:	3420b03a 	or	r16,r6,r16
8112d4a4:	9c000115 	stw	r16,4(r19)
8112d4a8:	18800117 	ldw	r2,4(r3)
8112d4ac:	10800054 	ori	r2,r2,1
8112d4b0:	18800115 	stw	r2,4(r3)
8112d4b4:	a009883a 	mov	r4,r20
8112d4b8:	1137ba40 	call	81137ba4 <__malloc_unlock>
8112d4bc:	9005883a 	mov	r2,r18
8112d4c0:	dfc00917 	ldw	ra,36(sp)
8112d4c4:	df000817 	ldw	fp,32(sp)
8112d4c8:	ddc00717 	ldw	r23,28(sp)
8112d4cc:	dd800617 	ldw	r22,24(sp)
8112d4d0:	dd400517 	ldw	r21,20(sp)
8112d4d4:	dd000417 	ldw	r20,16(sp)
8112d4d8:	dcc00317 	ldw	r19,12(sp)
8112d4dc:	dc800217 	ldw	r18,8(sp)
8112d4e0:	dc400117 	ldw	r17,4(sp)
8112d4e4:	dc000017 	ldw	r16,0(sp)
8112d4e8:	dec00a04 	addi	sp,sp,40
8112d4ec:	f800283a 	ret
8112d4f0:	017fff04 	movi	r5,-4
8112d4f4:	414a703a 	and	r5,r8,r5
8112d4f8:	814d883a 	add	r6,r16,r5
8112d4fc:	30c01f16 	blt	r6,r3,8112d57c <_realloc_r+0x234>
8112d500:	20800317 	ldw	r2,12(r4)
8112d504:	20c00217 	ldw	r3,8(r4)
8112d508:	a825883a 	mov	r18,r21
8112d50c:	3021883a 	mov	r16,r6
8112d510:	18800315 	stw	r2,12(r3)
8112d514:	10c00215 	stw	r3,8(r2)
8112d518:	003fdb06 	br	8112d488 <__reset+0xfb10d488>
8112d51c:	00800304 	movi	r2,12
8112d520:	a0800015 	stw	r2,0(r20)
8112d524:	0005883a 	mov	r2,zero
8112d528:	003fe506 	br	8112d4c0 <__reset+0xfb10d4c0>
8112d52c:	98c00117 	ldw	r3,4(r19)
8112d530:	9c4b883a 	add	r5,r19,r17
8112d534:	11000054 	ori	r4,r2,1
8112d538:	18c0004c 	andi	r3,r3,1
8112d53c:	1c62b03a 	or	r17,r3,r17
8112d540:	9c400115 	stw	r17,4(r19)
8112d544:	29000115 	stw	r4,4(r5)
8112d548:	2885883a 	add	r2,r5,r2
8112d54c:	10c00117 	ldw	r3,4(r2)
8112d550:	29400204 	addi	r5,r5,8
8112d554:	a009883a 	mov	r4,r20
8112d558:	18c00054 	ori	r3,r3,1
8112d55c:	10c00115 	stw	r3,4(r2)
8112d560:	112b2b40 	call	8112b2b4 <_free_r>
8112d564:	003fd306 	br	8112d4b4 <__reset+0xfb10d4b4>
8112d568:	017fff04 	movi	r5,-4
8112d56c:	414a703a 	and	r5,r8,r5
8112d570:	89800404 	addi	r6,r17,16
8112d574:	8151883a 	add	r8,r16,r5
8112d578:	4180590e 	bge	r8,r6,8112d6e0 <_realloc_r+0x398>
8112d57c:	1080004c 	andi	r2,r2,1
8112d580:	103f9e1e 	bne	r2,zero,8112d3fc <__reset+0xfb10d3fc>
8112d584:	adbffe17 	ldw	r22,-8(r21)
8112d588:	00bfff04 	movi	r2,-4
8112d58c:	9dadc83a 	sub	r22,r19,r22
8112d590:	b1800117 	ldw	r6,4(r22)
8112d594:	3084703a 	and	r2,r6,r2
8112d598:	20002026 	beq	r4,zero,8112d61c <_realloc_r+0x2d4>
8112d59c:	80af883a 	add	r23,r16,r2
8112d5a0:	b96f883a 	add	r23,r23,r5
8112d5a4:	21c05f26 	beq	r4,r7,8112d724 <_realloc_r+0x3dc>
8112d5a8:	b8c01c16 	blt	r23,r3,8112d61c <_realloc_r+0x2d4>
8112d5ac:	20800317 	ldw	r2,12(r4)
8112d5b0:	20c00217 	ldw	r3,8(r4)
8112d5b4:	81bfff04 	addi	r6,r16,-4
8112d5b8:	01000904 	movi	r4,36
8112d5bc:	18800315 	stw	r2,12(r3)
8112d5c0:	10c00215 	stw	r3,8(r2)
8112d5c4:	b0c00217 	ldw	r3,8(r22)
8112d5c8:	b0800317 	ldw	r2,12(r22)
8112d5cc:	b4800204 	addi	r18,r22,8
8112d5d0:	18800315 	stw	r2,12(r3)
8112d5d4:	10c00215 	stw	r3,8(r2)
8112d5d8:	21801b36 	bltu	r4,r6,8112d648 <_realloc_r+0x300>
8112d5dc:	008004c4 	movi	r2,19
8112d5e0:	1180352e 	bgeu	r2,r6,8112d6b8 <_realloc_r+0x370>
8112d5e4:	a8800017 	ldw	r2,0(r21)
8112d5e8:	b0800215 	stw	r2,8(r22)
8112d5ec:	a8800117 	ldw	r2,4(r21)
8112d5f0:	b0800315 	stw	r2,12(r22)
8112d5f4:	008006c4 	movi	r2,27
8112d5f8:	11807f36 	bltu	r2,r6,8112d7f8 <_realloc_r+0x4b0>
8112d5fc:	b0800404 	addi	r2,r22,16
8112d600:	ad400204 	addi	r21,r21,8
8112d604:	00002d06 	br	8112d6bc <_realloc_r+0x374>
8112d608:	adbffe17 	ldw	r22,-8(r21)
8112d60c:	00bfff04 	movi	r2,-4
8112d610:	9dadc83a 	sub	r22,r19,r22
8112d614:	b1000117 	ldw	r4,4(r22)
8112d618:	2084703a 	and	r2,r4,r2
8112d61c:	b03f7726 	beq	r22,zero,8112d3fc <__reset+0xfb10d3fc>
8112d620:	80af883a 	add	r23,r16,r2
8112d624:	b8ff7516 	blt	r23,r3,8112d3fc <__reset+0xfb10d3fc>
8112d628:	b0800317 	ldw	r2,12(r22)
8112d62c:	b0c00217 	ldw	r3,8(r22)
8112d630:	81bfff04 	addi	r6,r16,-4
8112d634:	01000904 	movi	r4,36
8112d638:	18800315 	stw	r2,12(r3)
8112d63c:	10c00215 	stw	r3,8(r2)
8112d640:	b4800204 	addi	r18,r22,8
8112d644:	21bfe52e 	bgeu	r4,r6,8112d5dc <__reset+0xfb10d5dc>
8112d648:	a80b883a 	mov	r5,r21
8112d64c:	9009883a 	mov	r4,r18
8112d650:	112c1280 	call	8112c128 <memmove>
8112d654:	b821883a 	mov	r16,r23
8112d658:	b027883a 	mov	r19,r22
8112d65c:	003f8a06 	br	8112d488 <__reset+0xfb10d488>
8112d660:	300b883a 	mov	r5,r6
8112d664:	dfc00917 	ldw	ra,36(sp)
8112d668:	df000817 	ldw	fp,32(sp)
8112d66c:	ddc00717 	ldw	r23,28(sp)
8112d670:	dd800617 	ldw	r22,24(sp)
8112d674:	dd400517 	ldw	r21,20(sp)
8112d678:	dd000417 	ldw	r20,16(sp)
8112d67c:	dcc00317 	ldw	r19,12(sp)
8112d680:	dc800217 	ldw	r18,8(sp)
8112d684:	dc400117 	ldw	r17,4(sp)
8112d688:	dc000017 	ldw	r16,0(sp)
8112d68c:	dec00a04 	addi	sp,sp,40
8112d690:	11218401 	jmpi	81121840 <_malloc_r>
8112d694:	a8c00017 	ldw	r3,0(r21)
8112d698:	90c00015 	stw	r3,0(r18)
8112d69c:	a8c00117 	ldw	r3,4(r21)
8112d6a0:	90c00115 	stw	r3,4(r18)
8112d6a4:	00c006c4 	movi	r3,27
8112d6a8:	19804536 	bltu	r3,r6,8112d7c0 <_realloc_r+0x478>
8112d6ac:	90800204 	addi	r2,r18,8
8112d6b0:	a8c00204 	addi	r3,r21,8
8112d6b4:	003f6306 	br	8112d444 <__reset+0xfb10d444>
8112d6b8:	9005883a 	mov	r2,r18
8112d6bc:	a8c00017 	ldw	r3,0(r21)
8112d6c0:	b821883a 	mov	r16,r23
8112d6c4:	b027883a 	mov	r19,r22
8112d6c8:	10c00015 	stw	r3,0(r2)
8112d6cc:	a8c00117 	ldw	r3,4(r21)
8112d6d0:	10c00115 	stw	r3,4(r2)
8112d6d4:	a8c00217 	ldw	r3,8(r21)
8112d6d8:	10c00215 	stw	r3,8(r2)
8112d6dc:	003f6a06 	br	8112d488 <__reset+0xfb10d488>
8112d6e0:	9c67883a 	add	r19,r19,r17
8112d6e4:	4445c83a 	sub	r2,r8,r17
8112d6e8:	e4c00215 	stw	r19,8(fp)
8112d6ec:	10800054 	ori	r2,r2,1
8112d6f0:	98800115 	stw	r2,4(r19)
8112d6f4:	a8bfff17 	ldw	r2,-4(r21)
8112d6f8:	a009883a 	mov	r4,r20
8112d6fc:	1080004c 	andi	r2,r2,1
8112d700:	1462b03a 	or	r17,r2,r17
8112d704:	ac7fff15 	stw	r17,-4(r21)
8112d708:	1137ba40 	call	81137ba4 <__malloc_unlock>
8112d70c:	a805883a 	mov	r2,r21
8112d710:	003f6b06 	br	8112d4c0 <__reset+0xfb10d4c0>
8112d714:	a80b883a 	mov	r5,r21
8112d718:	9009883a 	mov	r4,r18
8112d71c:	112c1280 	call	8112c128 <memmove>
8112d720:	003f4e06 	br	8112d45c <__reset+0xfb10d45c>
8112d724:	89000404 	addi	r4,r17,16
8112d728:	b93fbc16 	blt	r23,r4,8112d61c <__reset+0xfb10d61c>
8112d72c:	b0800317 	ldw	r2,12(r22)
8112d730:	b0c00217 	ldw	r3,8(r22)
8112d734:	81bfff04 	addi	r6,r16,-4
8112d738:	01000904 	movi	r4,36
8112d73c:	18800315 	stw	r2,12(r3)
8112d740:	10c00215 	stw	r3,8(r2)
8112d744:	b4800204 	addi	r18,r22,8
8112d748:	21804336 	bltu	r4,r6,8112d858 <_realloc_r+0x510>
8112d74c:	008004c4 	movi	r2,19
8112d750:	11803f2e 	bgeu	r2,r6,8112d850 <_realloc_r+0x508>
8112d754:	a8800017 	ldw	r2,0(r21)
8112d758:	b0800215 	stw	r2,8(r22)
8112d75c:	a8800117 	ldw	r2,4(r21)
8112d760:	b0800315 	stw	r2,12(r22)
8112d764:	008006c4 	movi	r2,27
8112d768:	11803f36 	bltu	r2,r6,8112d868 <_realloc_r+0x520>
8112d76c:	b0800404 	addi	r2,r22,16
8112d770:	ad400204 	addi	r21,r21,8
8112d774:	a8c00017 	ldw	r3,0(r21)
8112d778:	10c00015 	stw	r3,0(r2)
8112d77c:	a8c00117 	ldw	r3,4(r21)
8112d780:	10c00115 	stw	r3,4(r2)
8112d784:	a8c00217 	ldw	r3,8(r21)
8112d788:	10c00215 	stw	r3,8(r2)
8112d78c:	b447883a 	add	r3,r22,r17
8112d790:	bc45c83a 	sub	r2,r23,r17
8112d794:	e0c00215 	stw	r3,8(fp)
8112d798:	10800054 	ori	r2,r2,1
8112d79c:	18800115 	stw	r2,4(r3)
8112d7a0:	b0800117 	ldw	r2,4(r22)
8112d7a4:	a009883a 	mov	r4,r20
8112d7a8:	1080004c 	andi	r2,r2,1
8112d7ac:	1462b03a 	or	r17,r2,r17
8112d7b0:	b4400115 	stw	r17,4(r22)
8112d7b4:	1137ba40 	call	81137ba4 <__malloc_unlock>
8112d7b8:	9005883a 	mov	r2,r18
8112d7bc:	003f4006 	br	8112d4c0 <__reset+0xfb10d4c0>
8112d7c0:	a8c00217 	ldw	r3,8(r21)
8112d7c4:	90c00215 	stw	r3,8(r18)
8112d7c8:	a8c00317 	ldw	r3,12(r21)
8112d7cc:	90c00315 	stw	r3,12(r18)
8112d7d0:	30801126 	beq	r6,r2,8112d818 <_realloc_r+0x4d0>
8112d7d4:	90800404 	addi	r2,r18,16
8112d7d8:	a8c00404 	addi	r3,r21,16
8112d7dc:	003f1906 	br	8112d444 <__reset+0xfb10d444>
8112d7e0:	90ffff17 	ldw	r3,-4(r18)
8112d7e4:	00bfff04 	movi	r2,-4
8112d7e8:	a825883a 	mov	r18,r21
8112d7ec:	1884703a 	and	r2,r3,r2
8112d7f0:	80a1883a 	add	r16,r16,r2
8112d7f4:	003f2406 	br	8112d488 <__reset+0xfb10d488>
8112d7f8:	a8800217 	ldw	r2,8(r21)
8112d7fc:	b0800415 	stw	r2,16(r22)
8112d800:	a8800317 	ldw	r2,12(r21)
8112d804:	b0800515 	stw	r2,20(r22)
8112d808:	31000a26 	beq	r6,r4,8112d834 <_realloc_r+0x4ec>
8112d80c:	b0800604 	addi	r2,r22,24
8112d810:	ad400404 	addi	r21,r21,16
8112d814:	003fa906 	br	8112d6bc <__reset+0xfb10d6bc>
8112d818:	a9000417 	ldw	r4,16(r21)
8112d81c:	90800604 	addi	r2,r18,24
8112d820:	a8c00604 	addi	r3,r21,24
8112d824:	91000415 	stw	r4,16(r18)
8112d828:	a9000517 	ldw	r4,20(r21)
8112d82c:	91000515 	stw	r4,20(r18)
8112d830:	003f0406 	br	8112d444 <__reset+0xfb10d444>
8112d834:	a8c00417 	ldw	r3,16(r21)
8112d838:	ad400604 	addi	r21,r21,24
8112d83c:	b0800804 	addi	r2,r22,32
8112d840:	b0c00615 	stw	r3,24(r22)
8112d844:	a8ffff17 	ldw	r3,-4(r21)
8112d848:	b0c00715 	stw	r3,28(r22)
8112d84c:	003f9b06 	br	8112d6bc <__reset+0xfb10d6bc>
8112d850:	9005883a 	mov	r2,r18
8112d854:	003fc706 	br	8112d774 <__reset+0xfb10d774>
8112d858:	a80b883a 	mov	r5,r21
8112d85c:	9009883a 	mov	r4,r18
8112d860:	112c1280 	call	8112c128 <memmove>
8112d864:	003fc906 	br	8112d78c <__reset+0xfb10d78c>
8112d868:	a8800217 	ldw	r2,8(r21)
8112d86c:	b0800415 	stw	r2,16(r22)
8112d870:	a8800317 	ldw	r2,12(r21)
8112d874:	b0800515 	stw	r2,20(r22)
8112d878:	31000726 	beq	r6,r4,8112d898 <_realloc_r+0x550>
8112d87c:	b0800604 	addi	r2,r22,24
8112d880:	ad400404 	addi	r21,r21,16
8112d884:	003fbb06 	br	8112d774 <__reset+0xfb10d774>
8112d888:	a009883a 	mov	r4,r20
8112d88c:	1137ba40 	call	81137ba4 <__malloc_unlock>
8112d890:	0005883a 	mov	r2,zero
8112d894:	003f0a06 	br	8112d4c0 <__reset+0xfb10d4c0>
8112d898:	a8c00417 	ldw	r3,16(r21)
8112d89c:	ad400604 	addi	r21,r21,24
8112d8a0:	b0800804 	addi	r2,r22,32
8112d8a4:	b0c00615 	stw	r3,24(r22)
8112d8a8:	a8ffff17 	ldw	r3,-4(r21)
8112d8ac:	b0c00715 	stw	r3,28(r22)
8112d8b0:	003fb006 	br	8112d774 <__reset+0xfb10d774>

8112d8b4 <__fpclassifyd>:
8112d8b4:	00a00034 	movhi	r2,32768
8112d8b8:	10bfffc4 	addi	r2,r2,-1
8112d8bc:	2884703a 	and	r2,r5,r2
8112d8c0:	10000726 	beq	r2,zero,8112d8e0 <__fpclassifyd+0x2c>
8112d8c4:	00fffc34 	movhi	r3,65520
8112d8c8:	019ff834 	movhi	r6,32736
8112d8cc:	28c7883a 	add	r3,r5,r3
8112d8d0:	31bfffc4 	addi	r6,r6,-1
8112d8d4:	30c00536 	bltu	r6,r3,8112d8ec <__fpclassifyd+0x38>
8112d8d8:	00800104 	movi	r2,4
8112d8dc:	f800283a 	ret
8112d8e0:	2000021e 	bne	r4,zero,8112d8ec <__fpclassifyd+0x38>
8112d8e4:	00800084 	movi	r2,2
8112d8e8:	f800283a 	ret
8112d8ec:	00dffc34 	movhi	r3,32752
8112d8f0:	019ff834 	movhi	r6,32736
8112d8f4:	28cb883a 	add	r5,r5,r3
8112d8f8:	31bfffc4 	addi	r6,r6,-1
8112d8fc:	317ff62e 	bgeu	r6,r5,8112d8d8 <__reset+0xfb10d8d8>
8112d900:	01400434 	movhi	r5,16
8112d904:	297fffc4 	addi	r5,r5,-1
8112d908:	28800236 	bltu	r5,r2,8112d914 <__fpclassifyd+0x60>
8112d90c:	008000c4 	movi	r2,3
8112d910:	f800283a 	ret
8112d914:	10c00226 	beq	r2,r3,8112d920 <__fpclassifyd+0x6c>
8112d918:	0005883a 	mov	r2,zero
8112d91c:	f800283a 	ret
8112d920:	2005003a 	cmpeq	r2,r4,zero
8112d924:	f800283a 	ret

8112d928 <__sccl>:
8112d928:	2a000003 	ldbu	r8,0(r5)
8112d92c:	00801784 	movi	r2,94
8112d930:	40802a26 	beq	r8,r2,8112d9dc <__sccl+0xb4>
8112d934:	29400044 	addi	r5,r5,1
8112d938:	000f883a 	mov	r7,zero
8112d93c:	0013883a 	mov	r9,zero
8112d940:	2007883a 	mov	r3,r4
8112d944:	21804004 	addi	r6,r4,256
8112d948:	19c00005 	stb	r7,0(r3)
8112d94c:	18c00044 	addi	r3,r3,1
8112d950:	19bffd1e 	bne	r3,r6,8112d948 <__reset+0xfb10d948>
8112d954:	40001126 	beq	r8,zero,8112d99c <__sccl+0x74>
8112d958:	00800044 	movi	r2,1
8112d95c:	124fc83a 	sub	r7,r2,r9
8112d960:	02800b44 	movi	r10,45
8112d964:	02c01744 	movi	r11,93
8112d968:	2205883a 	add	r2,r4,r8
8112d96c:	11c00005 	stb	r7,0(r2)
8112d970:	28800044 	addi	r2,r5,1
8112d974:	28c00003 	ldbu	r3,0(r5)
8112d978:	1a800a26 	beq	r3,r10,8112d9a4 <__sccl+0x7c>
8112d97c:	1ac00426 	beq	r3,r11,8112d990 <__sccl+0x68>
8112d980:	18000426 	beq	r3,zero,8112d994 <__sccl+0x6c>
8112d984:	1811883a 	mov	r8,r3
8112d988:	100b883a 	mov	r5,r2
8112d98c:	003ff606 	br	8112d968 <__reset+0xfb10d968>
8112d990:	f800283a 	ret
8112d994:	2805883a 	mov	r2,r5
8112d998:	f800283a 	ret
8112d99c:	28bfffc4 	addi	r2,r5,-1
8112d9a0:	f800283a 	ret
8112d9a4:	12400003 	ldbu	r9,0(r2)
8112d9a8:	4ac01126 	beq	r9,r11,8112d9f0 <__sccl+0xc8>
8112d9ac:	4a001016 	blt	r9,r8,8112d9f0 <__sccl+0xc8>
8112d9b0:	41800044 	addi	r6,r8,1
8112d9b4:	29400084 	addi	r5,r5,2
8112d9b8:	2187883a 	add	r3,r4,r6
8112d9bc:	00000106 	br	8112d9c4 <__sccl+0x9c>
8112d9c0:	31800044 	addi	r6,r6,1
8112d9c4:	19c00005 	stb	r7,0(r3)
8112d9c8:	3011883a 	mov	r8,r6
8112d9cc:	18c00044 	addi	r3,r3,1
8112d9d0:	327ffb16 	blt	r6,r9,8112d9c0 <__reset+0xfb10d9c0>
8112d9d4:	10800084 	addi	r2,r2,2
8112d9d8:	003fe606 	br	8112d974 <__reset+0xfb10d974>
8112d9dc:	2a000043 	ldbu	r8,1(r5)
8112d9e0:	01c00044 	movi	r7,1
8112d9e4:	29400084 	addi	r5,r5,2
8112d9e8:	02400044 	movi	r9,1
8112d9ec:	003fd406 	br	8112d940 <__reset+0xfb10d940>
8112d9f0:	5011883a 	mov	r8,r10
8112d9f4:	003fe406 	br	8112d988 <__reset+0xfb10d988>

8112d9f8 <nanf>:
8112d9f8:	009ff034 	movhi	r2,32704
8112d9fc:	f800283a 	ret

8112da00 <strcmp>:
8112da00:	2144b03a 	or	r2,r4,r5
8112da04:	108000cc 	andi	r2,r2,3
8112da08:	1000171e 	bne	r2,zero,8112da68 <strcmp+0x68>
8112da0c:	20800017 	ldw	r2,0(r4)
8112da10:	28c00017 	ldw	r3,0(r5)
8112da14:	10c0141e 	bne	r2,r3,8112da68 <strcmp+0x68>
8112da18:	027fbff4 	movhi	r9,65279
8112da1c:	4a7fbfc4 	addi	r9,r9,-257
8112da20:	0086303a 	nor	r3,zero,r2
8112da24:	02202074 	movhi	r8,32897
8112da28:	1245883a 	add	r2,r2,r9
8112da2c:	42202004 	addi	r8,r8,-32640
8112da30:	10c4703a 	and	r2,r2,r3
8112da34:	1204703a 	and	r2,r2,r8
8112da38:	10000226 	beq	r2,zero,8112da44 <strcmp+0x44>
8112da3c:	00002306 	br	8112dacc <strcmp+0xcc>
8112da40:	1000221e 	bne	r2,zero,8112dacc <strcmp+0xcc>
8112da44:	21000104 	addi	r4,r4,4
8112da48:	20c00017 	ldw	r3,0(r4)
8112da4c:	29400104 	addi	r5,r5,4
8112da50:	29800017 	ldw	r6,0(r5)
8112da54:	1a4f883a 	add	r7,r3,r9
8112da58:	00c4303a 	nor	r2,zero,r3
8112da5c:	3884703a 	and	r2,r7,r2
8112da60:	1204703a 	and	r2,r2,r8
8112da64:	19bff626 	beq	r3,r6,8112da40 <__reset+0xfb10da40>
8112da68:	20800003 	ldbu	r2,0(r4)
8112da6c:	10c03fcc 	andi	r3,r2,255
8112da70:	18c0201c 	xori	r3,r3,128
8112da74:	18ffe004 	addi	r3,r3,-128
8112da78:	18000c26 	beq	r3,zero,8112daac <strcmp+0xac>
8112da7c:	29800007 	ldb	r6,0(r5)
8112da80:	19800326 	beq	r3,r6,8112da90 <strcmp+0x90>
8112da84:	00001306 	br	8112dad4 <strcmp+0xd4>
8112da88:	29800007 	ldb	r6,0(r5)
8112da8c:	11800b1e 	bne	r2,r6,8112dabc <strcmp+0xbc>
8112da90:	21000044 	addi	r4,r4,1
8112da94:	20c00003 	ldbu	r3,0(r4)
8112da98:	29400044 	addi	r5,r5,1
8112da9c:	18803fcc 	andi	r2,r3,255
8112daa0:	1080201c 	xori	r2,r2,128
8112daa4:	10bfe004 	addi	r2,r2,-128
8112daa8:	103ff71e 	bne	r2,zero,8112da88 <__reset+0xfb10da88>
8112daac:	0007883a 	mov	r3,zero
8112dab0:	28800003 	ldbu	r2,0(r5)
8112dab4:	1885c83a 	sub	r2,r3,r2
8112dab8:	f800283a 	ret
8112dabc:	28800003 	ldbu	r2,0(r5)
8112dac0:	18c03fcc 	andi	r3,r3,255
8112dac4:	1885c83a 	sub	r2,r3,r2
8112dac8:	f800283a 	ret
8112dacc:	0005883a 	mov	r2,zero
8112dad0:	f800283a 	ret
8112dad4:	10c03fcc 	andi	r3,r2,255
8112dad8:	003ff506 	br	8112dab0 <__reset+0xfb10dab0>

8112dadc <sulp>:
8112dadc:	defffd04 	addi	sp,sp,-12
8112dae0:	de00012e 	bgeu	sp,et,8112dae8 <sulp+0xc>
8112dae4:	003b68fa 	trap	3
8112dae8:	dc400115 	stw	r17,4(sp)
8112daec:	3023883a 	mov	r17,r6
8112daf0:	dc000015 	stw	r16,0(sp)
8112daf4:	dfc00215 	stw	ra,8(sp)
8112daf8:	2821883a 	mov	r16,r5
8112dafc:	112cde80 	call	8112cde8 <__ulp>
8112db00:	88000c26 	beq	r17,zero,8112db34 <sulp+0x58>
8112db04:	841ffc2c 	andhi	r16,r16,32752
8112db08:	8020d53a 	srli	r16,r16,20
8112db0c:	01c01ac4 	movi	r7,107
8112db10:	3c21c83a 	sub	r16,r7,r16
8112db14:	0400070e 	bge	zero,r16,8112db34 <sulp+0x58>
8112db18:	8020953a 	slli	r16,r16,20
8112db1c:	01cffc34 	movhi	r7,16368
8112db20:	000d883a 	mov	r6,zero
8112db24:	81cf883a 	add	r7,r16,r7
8112db28:	1009883a 	mov	r4,r2
8112db2c:	180b883a 	mov	r5,r3
8112db30:	111f99c0 	call	8111f99c <__muldf3>
8112db34:	dfc00217 	ldw	ra,8(sp)
8112db38:	dc400117 	ldw	r17,4(sp)
8112db3c:	dc000017 	ldw	r16,0(sp)
8112db40:	dec00304 	addi	sp,sp,12
8112db44:	f800283a 	ret

8112db48 <_strtod_r>:
8112db48:	deffe204 	addi	sp,sp,-120
8112db4c:	de00012e 	bgeu	sp,et,8112db54 <_strtod_r+0xc>
8112db50:	003b68fa 	trap	3
8112db54:	ddc01b15 	stw	r23,108(sp)
8112db58:	dd001815 	stw	r20,96(sp)
8112db5c:	dc801615 	stw	r18,88(sp)
8112db60:	dc401515 	stw	r17,84(sp)
8112db64:	dc001415 	stw	r16,80(sp)
8112db68:	d9400615 	stw	r5,24(sp)
8112db6c:	dfc01d15 	stw	ra,116(sp)
8112db70:	df001c15 	stw	fp,112(sp)
8112db74:	dd801a15 	stw	r22,104(sp)
8112db78:	dd401915 	stw	r21,100(sp)
8112db7c:	dcc01715 	stw	r19,92(sp)
8112db80:	2021883a 	mov	r16,r4
8112db84:	d8000515 	stw	zero,20(sp)
8112db88:	2809883a 	mov	r4,r5
8112db8c:	20800003 	ldbu	r2,0(r4)
8112db90:	01e044f4 	movhi	r7,33043
8112db94:	282f883a 	mov	r23,r5
8112db98:	10c03fcc 	andi	r3,r2,255
8112db9c:	01400b44 	movi	r5,45
8112dba0:	39f6f104 	addi	r7,r7,-9276
8112dba4:	3029883a 	mov	r20,r6
8112dba8:	0025883a 	mov	r18,zero
8112dbac:	0023883a 	mov	r17,zero
8112dbb0:	28c0ba36 	bltu	r5,r3,8112de9c <_strtod_r+0x354>
8112dbb4:	180690ba 	slli	r3,r3,2
8112dbb8:	19c7883a 	add	r3,r3,r7
8112dbbc:	18c00017 	ldw	r3,0(r3)
8112dbc0:	1800683a 	jmp	r3
8112dbc4:	8112dc84 	addi	r4,r16,19314
8112dbc8:	8112de9c 	xori	r4,r16,19322
8112dbcc:	8112de9c 	xori	r4,r16,19322
8112dbd0:	8112de9c 	xori	r4,r16,19322
8112dbd4:	8112de9c 	xori	r4,r16,19322
8112dbd8:	8112de9c 	xori	r4,r16,19322
8112dbdc:	8112de9c 	xori	r4,r16,19322
8112dbe0:	8112de9c 	xori	r4,r16,19322
8112dbe4:	8112de9c 	xori	r4,r16,19322
8112dbe8:	8112de88 	cmpgei	r4,r16,19322
8112dbec:	8112de88 	cmpgei	r4,r16,19322
8112dbf0:	8112de88 	cmpgei	r4,r16,19322
8112dbf4:	8112de88 	cmpgei	r4,r16,19322
8112dbf8:	8112de88 	cmpgei	r4,r16,19322
8112dbfc:	8112de9c 	xori	r4,r16,19322
8112dc00:	8112de9c 	xori	r4,r16,19322
8112dc04:	8112de9c 	xori	r4,r16,19322
8112dc08:	8112de9c 	xori	r4,r16,19322
8112dc0c:	8112de9c 	xori	r4,r16,19322
8112dc10:	8112de9c 	xori	r4,r16,19322
8112dc14:	8112de9c 	xori	r4,r16,19322
8112dc18:	8112de9c 	xori	r4,r16,19322
8112dc1c:	8112de9c 	xori	r4,r16,19322
8112dc20:	8112de9c 	xori	r4,r16,19322
8112dc24:	8112de9c 	xori	r4,r16,19322
8112dc28:	8112de9c 	xori	r4,r16,19322
8112dc2c:	8112de9c 	xori	r4,r16,19322
8112dc30:	8112de9c 	xori	r4,r16,19322
8112dc34:	8112de9c 	xori	r4,r16,19322
8112dc38:	8112de9c 	xori	r4,r16,19322
8112dc3c:	8112de9c 	xori	r4,r16,19322
8112dc40:	8112de9c 	xori	r4,r16,19322
8112dc44:	8112de88 	cmpgei	r4,r16,19322
8112dc48:	8112de9c 	xori	r4,r16,19322
8112dc4c:	8112de9c 	xori	r4,r16,19322
8112dc50:	8112de9c 	xori	r4,r16,19322
8112dc54:	8112de9c 	xori	r4,r16,19322
8112dc58:	8112de9c 	xori	r4,r16,19322
8112dc5c:	8112de9c 	xori	r4,r16,19322
8112dc60:	8112de9c 	xori	r4,r16,19322
8112dc64:	8112de9c 	xori	r4,r16,19322
8112dc68:	8112de9c 	xori	r4,r16,19322
8112dc6c:	8112de9c 	xori	r4,r16,19322
8112dc70:	8112dcdc 	xori	r4,r16,19315
8112dc74:	8112de9c 	xori	r4,r16,19322
8112dc78:	8112de7c 	xorhi	r4,r16,19321
8112dc7c:	00801244 	movi	r2,73
8112dc80:	88843526 	beq	r17,r2,8112ed58 <_strtod_r+0x1210>
8112dc84:	002b883a 	mov	r21,zero
8112dc88:	002d883a 	mov	r22,zero
8112dc8c:	a0000526 	beq	r20,zero,8112dca4 <_strtod_r+0x15c>
8112dc90:	d8000715 	stw	zero,28(sp)
8112dc94:	a5c00015 	stw	r23,0(r20)
8112dc98:	d9000717 	ldw	r4,28(sp)
8112dc9c:	20000126 	beq	r4,zero,8112dca4 <_strtod_r+0x15c>
8112dca0:	b5a0003c 	xorhi	r22,r22,32768
8112dca4:	a805883a 	mov	r2,r21
8112dca8:	b007883a 	mov	r3,r22
8112dcac:	dfc01d17 	ldw	ra,116(sp)
8112dcb0:	df001c17 	ldw	fp,112(sp)
8112dcb4:	ddc01b17 	ldw	r23,108(sp)
8112dcb8:	dd801a17 	ldw	r22,104(sp)
8112dcbc:	dd401917 	ldw	r21,100(sp)
8112dcc0:	dd001817 	ldw	r20,96(sp)
8112dcc4:	dcc01717 	ldw	r19,92(sp)
8112dcc8:	dc801617 	ldw	r18,88(sp)
8112dccc:	dc401517 	ldw	r17,84(sp)
8112dcd0:	dc001417 	ldw	r16,80(sp)
8112dcd4:	dec01e04 	addi	sp,sp,120
8112dcd8:	f800283a 	ret
8112dcdc:	d8000715 	stw	zero,28(sp)
8112dce0:	24c00044 	addi	r19,r4,1
8112dce4:	dcc00615 	stw	r19,24(sp)
8112dce8:	20800043 	ldbu	r2,1(r4)
8112dcec:	10c03fcc 	andi	r3,r2,255
8112dcf0:	18c0201c 	xori	r3,r3,128
8112dcf4:	18ffe004 	addi	r3,r3,-128
8112dcf8:	183fe226 	beq	r3,zero,8112dc84 <__reset+0xfb10dc84>
8112dcfc:	11403fcc 	andi	r5,r2,255
8112dd00:	2940201c 	xori	r5,r5,128
8112dd04:	297fe004 	addi	r5,r5,-128
8112dd08:	00c00c04 	movi	r3,48
8112dd0c:	28c0e526 	beq	r5,r3,8112e0a4 <_strtod_r+0x55c>
8112dd10:	dcc00815 	stw	r19,32(sp)
8112dd14:	0025883a 	mov	r18,zero
8112dd18:	10fff404 	addi	r3,r2,-48
8112dd1c:	18c03fcc 	andi	r3,r3,255
8112dd20:	01000244 	movi	r4,9
8112dd24:	20c37536 	bltu	r4,r3,8112eafc <_strtod_r+0xfb4>
8112dd28:	dd400817 	ldw	r21,32(sp)
8112dd2c:	0027883a 	mov	r19,zero
8112dd30:	0039883a 	mov	fp,zero
8112dd34:	002d883a 	mov	r22,zero
8112dd38:	01400204 	movi	r5,8
8112dd3c:	2d805a16 	blt	r5,r22,8112dea8 <_strtod_r+0x360>
8112dd40:	e70002a4 	muli	fp,fp,10
8112dd44:	10c03fcc 	andi	r3,r2,255
8112dd48:	18c0201c 	xori	r3,r3,128
8112dd4c:	18ffe004 	addi	r3,r3,-128
8112dd50:	e0f9883a 	add	fp,fp,r3
8112dd54:	e73ff404 	addi	fp,fp,-48
8112dd58:	ad400044 	addi	r21,r21,1
8112dd5c:	dd400615 	stw	r21,24(sp)
8112dd60:	a8800003 	ldbu	r2,0(r21)
8112dd64:	b5800044 	addi	r22,r22,1
8112dd68:	10fff404 	addi	r3,r2,-48
8112dd6c:	18c03fcc 	andi	r3,r3,255
8112dd70:	20fff22e 	bgeu	r4,r3,8112dd3c <__reset+0xfb10dd3c>
8112dd74:	14403fcc 	andi	r17,r2,255
8112dd78:	8c40201c 	xori	r17,r17,128
8112dd7c:	8c7fe004 	addi	r17,r17,-128
8112dd80:	8009883a 	mov	r4,r16
8112dd84:	112bd680 	call	8112bd68 <_localeconv_r>
8112dd88:	11400017 	ldw	r5,0(r2)
8112dd8c:	8009883a 	mov	r4,r16
8112dd90:	d9401315 	stw	r5,76(sp)
8112dd94:	112bd680 	call	8112bd68 <_localeconv_r>
8112dd98:	11000017 	ldw	r4,0(r2)
8112dd9c:	1122b480 	call	81122b48 <strlen>
8112dda0:	d9401317 	ldw	r5,76(sp)
8112dda4:	100d883a 	mov	r6,r2
8112dda8:	a809883a 	mov	r4,r21
8112ddac:	11337380 	call	81133738 <strncmp>
8112ddb0:	1000ce26 	beq	r2,zero,8112e0ec <_strtod_r+0x5a4>
8112ddb4:	b013883a 	mov	r9,r22
8112ddb8:	000b883a 	mov	r5,zero
8112ddbc:	0015883a 	mov	r10,zero
8112ddc0:	0017883a 	mov	r11,zero
8112ddc4:	00801944 	movi	r2,101
8112ddc8:	88807826 	beq	r17,r2,8112dfac <_strtod_r+0x464>
8112ddcc:	00801144 	movi	r2,69
8112ddd0:	88807626 	beq	r17,r2,8112dfac <_strtod_r+0x464>
8112ddd4:	002b883a 	mov	r21,zero
8112ddd8:	48003d1e 	bne	r9,zero,8112ded0 <_strtod_r+0x388>
8112dddc:	2800391e 	bne	r5,zero,8112dec4 <_strtod_r+0x37c>
8112dde0:	9000381e 	bne	r18,zero,8112dec4 <_strtod_r+0x37c>
8112dde4:	583fa71e 	bne	r11,zero,8112dc84 <__reset+0xfb10dc84>
8112dde8:	00801384 	movi	r2,78
8112ddec:	88800526 	beq	r17,r2,8112de04 <_strtod_r+0x2bc>
8112ddf0:	147fa20e 	bge	r2,r17,8112dc7c <__reset+0xfb10dc7c>
8112ddf4:	00801a44 	movi	r2,105
8112ddf8:	8883d726 	beq	r17,r2,8112ed58 <_strtod_r+0x1210>
8112ddfc:	00801b84 	movi	r2,110
8112de00:	88bfa01e 	bne	r17,r2,8112dc84 <__reset+0xfb10dc84>
8112de04:	01604574 	movhi	r5,33045
8112de08:	d9000617 	ldw	r4,24(sp)
8112de0c:	29417e04 	addi	r5,r5,1528
8112de10:	01c00644 	movi	r7,25
8112de14:	00000b06 	br	8112de44 <_strtod_r+0x2fc>
8112de18:	21000044 	addi	r4,r4,1
8112de1c:	20800003 	ldbu	r2,0(r4)
8112de20:	10ffefc4 	addi	r3,r2,-65
8112de24:	10803fcc 	andi	r2,r2,255
8112de28:	1080201c 	xori	r2,r2,128
8112de2c:	18c03fcc 	andi	r3,r3,255
8112de30:	10bfe004 	addi	r2,r2,-128
8112de34:	38c00136 	bltu	r7,r3,8112de3c <_strtod_r+0x2f4>
8112de38:	10800804 	addi	r2,r2,32
8112de3c:	29400044 	addi	r5,r5,1
8112de40:	11bf901e 	bne	r2,r6,8112dc84 <__reset+0xfb10dc84>
8112de44:	29800007 	ldb	r6,0(r5)
8112de48:	303ff31e 	bne	r6,zero,8112de18 <__reset+0xfb10de18>
8112de4c:	20800044 	addi	r2,r4,1
8112de50:	d8800615 	stw	r2,24(sp)
8112de54:	20c00047 	ldb	r3,1(r4)
8112de58:	00800a04 	movi	r2,40
8112de5c:	18849d26 	beq	r3,r2,8112f0d4 <_strtod_r+0x158c>
8112de60:	047ffe34 	movhi	r17,65528
8112de64:	0025883a 	mov	r18,zero
8112de68:	902b883a 	mov	r21,r18
8112de6c:	882d883a 	mov	r22,r17
8112de70:	a03f8926 	beq	r20,zero,8112dc98 <__reset+0xfb10dc98>
8112de74:	ddc00617 	ldw	r23,24(sp)
8112de78:	003f8606 	br	8112dc94 <__reset+0xfb10dc94>
8112de7c:	00800044 	movi	r2,1
8112de80:	d8800715 	stw	r2,28(sp)
8112de84:	003f9606 	br	8112dce0 <__reset+0xfb10dce0>
8112de88:	21000044 	addi	r4,r4,1
8112de8c:	d9000615 	stw	r4,24(sp)
8112de90:	20800003 	ldbu	r2,0(r4)
8112de94:	10c03fcc 	andi	r3,r2,255
8112de98:	28ff462e 	bgeu	r5,r3,8112dbb4 <__reset+0xfb10dbb4>
8112de9c:	2027883a 	mov	r19,r4
8112dea0:	d8000715 	stw	zero,28(sp)
8112dea4:	003f9506 	br	8112dcfc <__reset+0xfb10dcfc>
8112dea8:	9cc002a4 	muli	r19,r19,10
8112deac:	10803fcc 	andi	r2,r2,255
8112deb0:	1080201c 	xori	r2,r2,128
8112deb4:	10bfe004 	addi	r2,r2,-128
8112deb8:	9885883a 	add	r2,r19,r2
8112debc:	14fff404 	addi	r19,r2,-48
8112dec0:	003fa506 	br	8112dd58 <__reset+0xfb10dd58>
8112dec4:	002b883a 	mov	r21,zero
8112dec8:	002d883a 	mov	r22,zero
8112decc:	003fe806 	br	8112de70 <__reset+0xfb10de70>
8112ded0:	aaabc83a 	sub	r21,r21,r10
8112ded4:	b000011e 	bne	r22,zero,8112dedc <_strtod_r+0x394>
8112ded8:	482d883a 	mov	r22,r9
8112dedc:	00800404 	movi	r2,16
8112dee0:	482f883a 	mov	r23,r9
8112dee4:	1240010e 	bge	r2,r9,8112deec <_strtod_r+0x3a4>
8112dee8:	102f883a 	mov	r23,r2
8112deec:	e009883a 	mov	r4,fp
8112def0:	da401315 	stw	r9,76(sp)
8112def4:	1135b980 	call	81135b98 <__floatunsidf>
8112def8:	1025883a 	mov	r18,r2
8112defc:	00800244 	movi	r2,9
8112df00:	1823883a 	mov	r17,r3
8112df04:	da401317 	ldw	r9,76(sp)
8112df08:	15c0160e 	bge	r2,r23,8112df64 <_strtod_r+0x41c>
8112df0c:	b8bffdc4 	addi	r2,r23,-9
8112df10:	100490fa 	slli	r2,r2,3
8112df14:	180b883a 	mov	r5,r3
8112df18:	00e04574 	movhi	r3,33045
8112df1c:	18c14904 	addi	r3,r3,1316
8112df20:	1885883a 	add	r2,r3,r2
8112df24:	11800017 	ldw	r6,0(r2)
8112df28:	11c00117 	ldw	r7,4(r2)
8112df2c:	9009883a 	mov	r4,r18
8112df30:	111f99c0 	call	8111f99c <__muldf3>
8112df34:	9809883a 	mov	r4,r19
8112df38:	1025883a 	mov	r18,r2
8112df3c:	1823883a 	mov	r17,r3
8112df40:	1135b980 	call	81135b98 <__floatunsidf>
8112df44:	9009883a 	mov	r4,r18
8112df48:	880b883a 	mov	r5,r17
8112df4c:	100d883a 	mov	r6,r2
8112df50:	180f883a 	mov	r7,r3
8112df54:	11348780 	call	81134878 <__adddf3>
8112df58:	da401317 	ldw	r9,76(sp)
8112df5c:	1025883a 	mov	r18,r2
8112df60:	1823883a 	mov	r17,r3
8112df64:	008003c4 	movi	r2,15
8112df68:	12407b16 	blt	r2,r9,8112e158 <_strtod_r+0x610>
8112df6c:	a83fbe26 	beq	r21,zero,8112de68 <__reset+0xfb10de68>
8112df70:	0543670e 	bge	zero,r21,8112ed10 <_strtod_r+0x11c8>
8112df74:	00c00584 	movi	r3,22
8112df78:	1d42e816 	blt	r3,r21,8112eb1c <_strtod_r+0xfd4>
8112df7c:	a82a90fa 	slli	r21,r21,3
8112df80:	00a04574 	movhi	r2,33045
8112df84:	10814904 	addi	r2,r2,1316
8112df88:	1545883a 	add	r2,r2,r21
8112df8c:	11000017 	ldw	r4,0(r2)
8112df90:	11400117 	ldw	r5,4(r2)
8112df94:	900d883a 	mov	r6,r18
8112df98:	880f883a 	mov	r7,r17
8112df9c:	111f99c0 	call	8111f99c <__muldf3>
8112dfa0:	102b883a 	mov	r21,r2
8112dfa4:	182d883a 	mov	r22,r3
8112dfa8:	003fb106 	br	8112de70 <__reset+0xfb10de70>
8112dfac:	4801b526 	beq	r9,zero,8112e684 <_strtod_r+0xb3c>
8112dfb0:	ddc00617 	ldw	r23,24(sp)
8112dfb4:	00c00ac4 	movi	r3,43
8112dfb8:	b8800044 	addi	r2,r23,1
8112dfbc:	d8800615 	stw	r2,24(sp)
8112dfc0:	b8800047 	ldb	r2,1(r23)
8112dfc4:	10c1e926 	beq	r2,r3,8112e76c <_strtod_r+0xc24>
8112dfc8:	00c00b44 	movi	r3,45
8112dfcc:	10c1ec26 	beq	r2,r3,8112e780 <_strtod_r+0xc38>
8112dfd0:	1023883a 	mov	r17,r2
8112dfd4:	0019883a 	mov	r12,zero
8112dfd8:	88bff404 	addi	r2,r17,-48
8112dfdc:	00c00244 	movi	r3,9
8112dfe0:	1881b736 	bltu	r3,r2,8112e6c0 <_strtod_r+0xb78>
8112dfe4:	00800c04 	movi	r2,48
8112dfe8:	8880071e 	bne	r17,r2,8112e008 <_strtod_r+0x4c0>
8112dfec:	d8800617 	ldw	r2,24(sp)
8112dff0:	8807883a 	mov	r3,r17
8112dff4:	10800044 	addi	r2,r2,1
8112dff8:	d8800615 	stw	r2,24(sp)
8112dffc:	14400007 	ldb	r17,0(r2)
8112e000:	10800044 	addi	r2,r2,1
8112e004:	88fffc26 	beq	r17,r3,8112dff8 <__reset+0xfb10dff8>
8112e008:	88bff3c4 	addi	r2,r17,-49
8112e00c:	00c00204 	movi	r3,8
8112e010:	18bf7036 	bltu	r3,r2,8112ddd4 <__reset+0xfb10ddd4>
8112e014:	db800617 	ldw	r14,24(sp)
8112e018:	88bff404 	addi	r2,r17,-48
8112e01c:	03400244 	movi	r13,9
8112e020:	71c00044 	addi	r7,r14,1
8112e024:	d9c00615 	stw	r7,24(sp)
8112e028:	74400043 	ldbu	r17,1(r14)
8112e02c:	88fff404 	addi	r3,r17,-48
8112e030:	8c403fcc 	andi	r17,r17,255
8112e034:	8c40201c 	xori	r17,r17,128
8112e038:	18c03fcc 	andi	r3,r3,255
8112e03c:	8c7fe004 	addi	r17,r17,-128
8112e040:	68c00e36 	bltu	r13,r3,8112e07c <_strtod_r+0x534>
8112e044:	71000084 	addi	r4,r14,2
8112e048:	d9000615 	stw	r4,24(sp)
8112e04c:	108002a4 	muli	r2,r2,10
8112e050:	21800003 	ldbu	r6,0(r4)
8112e054:	200f883a 	mov	r7,r4
8112e058:	1463883a 	add	r17,r2,r17
8112e05c:	30fff404 	addi	r3,r6,-48
8112e060:	88bff404 	addi	r2,r17,-48
8112e064:	34403fcc 	andi	r17,r6,255
8112e068:	8c40201c 	xori	r17,r17,128
8112e06c:	18c03fcc 	andi	r3,r3,255
8112e070:	8c7fe004 	addi	r17,r17,-128
8112e074:	21000044 	addi	r4,r4,1
8112e078:	68fff32e 	bgeu	r13,r3,8112e048 <__reset+0xfb10e048>
8112e07c:	3b8fc83a 	sub	r7,r7,r14
8112e080:	00c00204 	movi	r3,8
8112e084:	19c29716 	blt	r3,r7,8112eae4 <_strtod_r+0xf9c>
8112e088:	102b883a 	mov	r21,r2
8112e08c:	009387c4 	movi	r2,19999
8112e090:	1540010e 	bge	r2,r21,8112e098 <_strtod_r+0x550>
8112e094:	102b883a 	mov	r21,r2
8112e098:	603f4f26 	beq	r12,zero,8112ddd8 <__reset+0xfb10ddd8>
8112e09c:	056bc83a 	sub	r21,zero,r21
8112e0a0:	003f4d06 	br	8112ddd8 <__reset+0xfb10ddd8>
8112e0a4:	98800047 	ldb	r2,1(r19)
8112e0a8:	00c01604 	movi	r3,88
8112e0ac:	10c1de26 	beq	r2,r3,8112e828 <_strtod_r+0xce0>
8112e0b0:	00c01e04 	movi	r3,120
8112e0b4:	10c1dc26 	beq	r2,r3,8112e828 <_strtod_r+0xce0>
8112e0b8:	98c00044 	addi	r3,r19,1
8112e0bc:	1827883a 	mov	r19,r3
8112e0c0:	d8c00615 	stw	r3,24(sp)
8112e0c4:	18c00044 	addi	r3,r3,1
8112e0c8:	18bfffc3 	ldbu	r2,-1(r3)
8112e0cc:	11003fcc 	andi	r4,r2,255
8112e0d0:	2100201c 	xori	r4,r4,128
8112e0d4:	213fe004 	addi	r4,r4,-128
8112e0d8:	217ff826 	beq	r4,r5,8112e0bc <__reset+0xfb10e0bc>
8112e0dc:	203f7926 	beq	r4,zero,8112dec4 <__reset+0xfb10dec4>
8112e0e0:	dcc00815 	stw	r19,32(sp)
8112e0e4:	04800044 	movi	r18,1
8112e0e8:	003f0b06 	br	8112dd18 <__reset+0xfb10dd18>
8112e0ec:	8009883a 	mov	r4,r16
8112e0f0:	112bd680 	call	8112bd68 <_localeconv_r>
8112e0f4:	11000017 	ldw	r4,0(r2)
8112e0f8:	1122b480 	call	81122b48 <strlen>
8112e0fc:	d8c00617 	ldw	r3,24(sp)
8112e100:	1885883a 	add	r2,r3,r2
8112e104:	d8800615 	stw	r2,24(sp)
8112e108:	14400007 	ldb	r17,0(r2)
8112e10c:	b001881e 	bne	r22,zero,8112e730 <_strtod_r+0xbe8>
8112e110:	00c00c04 	movi	r3,48
8112e114:	88c3391e 	bne	r17,r3,8112edfc <_strtod_r+0x12b4>
8112e118:	10c00044 	addi	r3,r2,1
8112e11c:	8809883a 	mov	r4,r17
8112e120:	d8c00615 	stw	r3,24(sp)
8112e124:	1c400007 	ldb	r17,0(r3)
8112e128:	188bc83a 	sub	r5,r3,r2
8112e12c:	18c00044 	addi	r3,r3,1
8112e130:	893ffb26 	beq	r17,r4,8112e120 <__reset+0xfb10e120>
8112e134:	88bff3c4 	addi	r2,r17,-49
8112e138:	00c00204 	movi	r3,8
8112e13c:	1882e72e 	bgeu	r3,r2,8112ecdc <_strtod_r+0x1194>
8112e140:	00801944 	movi	r2,101
8112e144:	88814d26 	beq	r17,r2,8112e67c <_strtod_r+0xb34>
8112e148:	0013883a 	mov	r9,zero
8112e14c:	0015883a 	mov	r10,zero
8112e150:	02c00044 	movi	r11,1
8112e154:	003f1d06 	br	8112ddcc <__reset+0xfb10ddcc>
8112e158:	4defc83a 	sub	r23,r9,r23
8112e15c:	bd6f883a 	add	r23,r23,r21
8112e160:	05c21e0e 	bge	zero,r23,8112e9dc <_strtod_r+0xe94>
8112e164:	b88003cc 	andi	r2,r23,15
8112e168:	10000d26 	beq	r2,zero,8112e1a0 <_strtod_r+0x658>
8112e16c:	100490fa 	slli	r2,r2,3
8112e170:	00e04574 	movhi	r3,33045
8112e174:	18c14904 	addi	r3,r3,1316
8112e178:	1885883a 	add	r2,r3,r2
8112e17c:	11000017 	ldw	r4,0(r2)
8112e180:	11400117 	ldw	r5,4(r2)
8112e184:	900d883a 	mov	r6,r18
8112e188:	880f883a 	mov	r7,r17
8112e18c:	da401315 	stw	r9,76(sp)
8112e190:	111f99c0 	call	8111f99c <__muldf3>
8112e194:	da401317 	ldw	r9,76(sp)
8112e198:	1025883a 	mov	r18,r2
8112e19c:	1823883a 	mov	r17,r3
8112e1a0:	023ffc04 	movi	r8,-16
8112e1a4:	ba10703a 	and	r8,r23,r8
8112e1a8:	40003c26 	beq	r8,zero,8112e29c <_strtod_r+0x754>
8112e1ac:	00804d04 	movi	r2,308
8112e1b0:	1201cd16 	blt	r2,r8,8112e8e8 <_strtod_r+0xda0>
8112e1b4:	4011d13a 	srai	r8,r8,4
8112e1b8:	03000044 	movi	r12,1
8112e1bc:	62037c0e 	bge	r12,r8,8112efb0 <_strtod_r+0x1468>
8112e1c0:	01204574 	movhi	r4,33045
8112e1c4:	21013f04 	addi	r4,r4,1276
8112e1c8:	2015883a 	mov	r10,r4
8112e1cc:	0027883a 	mov	r19,zero
8112e1d0:	d9000915 	stw	r4,36(sp)
8112e1d4:	9005883a 	mov	r2,r18
8112e1d8:	8807883a 	mov	r3,r17
8112e1dc:	dc000c15 	stw	r16,48(sp)
8112e1e0:	dc800e15 	stw	r18,56(sp)
8112e1e4:	9821883a 	mov	r16,r19
8112e1e8:	0009883a 	mov	r4,zero
8112e1ec:	8827883a 	mov	r19,r17
8112e1f0:	602f883a 	mov	r23,r12
8112e1f4:	da400a15 	stw	r9,40(sp)
8112e1f8:	5025883a 	mov	r18,r10
8112e1fc:	4023883a 	mov	r17,r8
8112e200:	8980004c 	andi	r6,r17,1
8112e204:	30000626 	beq	r6,zero,8112e220 <_strtod_r+0x6d8>
8112e208:	91800017 	ldw	r6,0(r18)
8112e20c:	91c00117 	ldw	r7,4(r18)
8112e210:	1009883a 	mov	r4,r2
8112e214:	180b883a 	mov	r5,r3
8112e218:	111f99c0 	call	8111f99c <__muldf3>
8112e21c:	01000044 	movi	r4,1
8112e220:	8823d07a 	srai	r17,r17,1
8112e224:	84000044 	addi	r16,r16,1
8112e228:	94800204 	addi	r18,r18,8
8112e22c:	8dfff41e 	bne	r17,r23,8112e200 <__reset+0xfb10e200>
8112e230:	21003fcc 	andi	r4,r4,255
8112e234:	9823883a 	mov	r17,r19
8112e238:	da400a17 	ldw	r9,40(sp)
8112e23c:	8027883a 	mov	r19,r16
8112e240:	dc800e17 	ldw	r18,56(sp)
8112e244:	dc000c17 	ldw	r16,48(sp)
8112e248:	2003b11e 	bne	r4,zero,8112f110 <_strtod_r+0x15c8>
8112e24c:	981690fa 	slli	r11,r19,3
8112e250:	d8800917 	ldw	r2,36(sp)
8112e254:	01ff2c34 	movhi	r7,64688
8112e258:	900d883a 	mov	r6,r18
8112e25c:	12ef883a 	add	r23,r2,r11
8112e260:	b9000017 	ldw	r4,0(r23)
8112e264:	b9400117 	ldw	r5,4(r23)
8112e268:	89cf883a 	add	r7,r17,r7
8112e26c:	da401315 	stw	r9,76(sp)
8112e270:	111f99c0 	call	8111f99c <__muldf3>
8112e274:	1025883a 	mov	r18,r2
8112e278:	011f2834 	movhi	r4,31904
8112e27c:	189ffc2c 	andhi	r2,r3,32752
8112e280:	da401317 	ldw	r9,76(sp)
8112e284:	20819836 	bltu	r4,r2,8112e8e8 <_strtod_r+0xda0>
8112e288:	011f2434 	movhi	r4,31888
8112e28c:	2083382e 	bgeu	r4,r2,8112ef70 <_strtod_r+0x1428>
8112e290:	045ffc34 	movhi	r17,32752
8112e294:	8c7fffc4 	addi	r17,r17,-1
8112e298:	04bfffc4 	movi	r18,-1
8112e29c:	d8000915 	stw	zero,36(sp)
8112e2a0:	d9400817 	ldw	r5,32(sp)
8112e2a4:	df000015 	stw	fp,0(sp)
8112e2a8:	480f883a 	mov	r7,r9
8112e2ac:	b00d883a 	mov	r6,r22
8112e2b0:	8009883a 	mov	r4,r16
8112e2b4:	112c4840 	call	8112c484 <__s2b>
8112e2b8:	d8800815 	stw	r2,32(sp)
8112e2bc:	10018a26 	beq	r2,zero,8112e8e8 <_strtod_r+0xda0>
8112e2c0:	a807d7fa 	srai	r3,r21,31
8112e2c4:	0545c83a 	sub	r2,zero,r21
8112e2c8:	dd400a15 	stw	r21,40(sp)
8112e2cc:	1886703a 	and	r3,r3,r2
8112e2d0:	d8c00c15 	stw	r3,48(sp)
8112e2d4:	a8013516 	blt	r21,zero,8112e7ac <_strtod_r+0xc64>
8112e2d8:	d9400817 	ldw	r5,32(sp)
8112e2dc:	0011883a 	mov	r8,zero
8112e2e0:	0027883a 	mov	r19,zero
8112e2e4:	29400304 	addi	r5,r5,12
8112e2e8:	d9400f15 	stw	r5,60(sp)
8112e2ec:	402b883a 	mov	r21,r8
8112e2f0:	dd001215 	stw	r20,72(sp)
8112e2f4:	d8800817 	ldw	r2,32(sp)
8112e2f8:	8009883a 	mov	r4,r16
8112e2fc:	11400117 	ldw	r5,4(r2)
8112e300:	112c2840 	call	8112c284 <_Balloc>
8112e304:	1029883a 	mov	r20,r2
8112e308:	10012d26 	beq	r2,zero,8112e7c0 <_strtod_r+0xc78>
8112e30c:	d8c00817 	ldw	r3,32(sp)
8112e310:	d9400f17 	ldw	r5,60(sp)
8112e314:	11000304 	addi	r4,r2,12
8112e318:	19800417 	ldw	r6,16(r3)
8112e31c:	31800084 	addi	r6,r6,2
8112e320:	318d883a 	add	r6,r6,r6
8112e324:	318d883a 	add	r6,r6,r6
8112e328:	11220540 	call	81122054 <memcpy>
8112e32c:	d9000204 	addi	r4,sp,8
8112e330:	d9000015 	stw	r4,0(sp)
8112e334:	d9c00404 	addi	r7,sp,16
8112e338:	900b883a 	mov	r5,r18
8112e33c:	880d883a 	mov	r6,r17
8112e340:	8009883a 	mov	r4,r16
8112e344:	112cf600 	call	8112cf60 <__d2b>
8112e348:	d8800515 	stw	r2,20(sp)
8112e34c:	dc801115 	stw	r18,68(sp)
8112e350:	dc401015 	stw	r17,64(sp)
8112e354:	10027c26 	beq	r2,zero,8112ed48 <_strtod_r+0x1200>
8112e358:	01400044 	movi	r5,1
8112e35c:	8009883a 	mov	r4,r16
8112e360:	112c6a80 	call	8112c6a8 <__i2b>
8112e364:	1027883a 	mov	r19,r2
8112e368:	10011526 	beq	r2,zero,8112e7c0 <_strtod_r+0xc78>
8112e36c:	d8800417 	ldw	r2,16(sp)
8112e370:	1000c816 	blt	r2,zero,8112e694 <_strtod_r+0xb4c>
8112e374:	d9400c17 	ldw	r5,48(sp)
8112e378:	d9000a17 	ldw	r4,40(sp)
8112e37c:	28ad883a 	add	r22,r5,r2
8112e380:	d9400917 	ldw	r5,36(sp)
8112e384:	df000217 	ldw	fp,8(sp)
8112e388:	05ff0084 	movi	r23,-1022
8112e38c:	1147c83a 	sub	r3,r2,r5
8112e390:	1f07883a 	add	r3,r3,fp
8112e394:	00800d84 	movi	r2,54
8112e398:	18ffffc4 	addi	r3,r3,-1
8112e39c:	1739c83a 	sub	fp,r2,fp
8112e3a0:	1dc0a50e 	bge	r3,r23,8112e638 <_strtod_r+0xaf0>
8112e3a4:	b8efc83a 	sub	r23,r23,r3
8112e3a8:	008007c4 	movi	r2,31
8112e3ac:	e5f9c83a 	sub	fp,fp,r23
8112e3b0:	15c0bc16 	blt	r2,r23,8112e6a4 <_strtod_r+0xb5c>
8112e3b4:	00800044 	movi	r2,1
8112e3b8:	15c4983a 	sll	r2,r2,r23
8112e3bc:	d8000b15 	stw	zero,44(sp)
8112e3c0:	d8800d15 	stw	r2,52(sp)
8112e3c4:	2707883a 	add	r3,r4,fp
8112e3c8:	d9000917 	ldw	r4,36(sp)
8112e3cc:	b739883a 	add	fp,r22,fp
8112e3d0:	20ef883a 	add	r23,r4,r3
8112e3d4:	b009883a 	mov	r4,r22
8112e3d8:	e580010e 	bge	fp,r22,8112e3e0 <_strtod_r+0x898>
8112e3dc:	e009883a 	mov	r4,fp
8112e3e0:	b805883a 	mov	r2,r23
8112e3e4:	25c0010e 	bge	r4,r23,8112e3ec <_strtod_r+0x8a4>
8112e3e8:	2005883a 	mov	r2,r4
8112e3ec:	0080030e 	bge	zero,r2,8112e3fc <_strtod_r+0x8b4>
8112e3f0:	e0b9c83a 	sub	fp,fp,r2
8112e3f4:	b8afc83a 	sub	r23,r23,r2
8112e3f8:	b0adc83a 	sub	r22,r22,r2
8112e3fc:	d9400c17 	ldw	r5,48(sp)
8112e400:	28001126 	beq	r5,zero,8112e448 <_strtod_r+0x900>
8112e404:	280d883a 	mov	r6,r5
8112e408:	8009883a 	mov	r4,r16
8112e40c:	980b883a 	mov	r5,r19
8112e410:	112c8ec0 	call	8112c8ec <__pow5mult>
8112e414:	1027883a 	mov	r19,r2
8112e418:	1000e926 	beq	r2,zero,8112e7c0 <_strtod_r+0xc78>
8112e41c:	d9800517 	ldw	r6,20(sp)
8112e420:	100b883a 	mov	r5,r2
8112e424:	8009883a 	mov	r4,r16
8112e428:	112c6ec0 	call	8112c6ec <__multiply>
8112e42c:	1000e426 	beq	r2,zero,8112e7c0 <_strtod_r+0xc78>
8112e430:	d9400517 	ldw	r5,20(sp)
8112e434:	8009883a 	mov	r4,r16
8112e438:	d8801315 	stw	r2,76(sp)
8112e43c:	112c3340 	call	8112c334 <_Bfree>
8112e440:	d8801317 	ldw	r2,76(sp)
8112e444:	d8800515 	stw	r2,20(sp)
8112e448:	0700060e 	bge	zero,fp,8112e464 <_strtod_r+0x91c>
8112e44c:	d9400517 	ldw	r5,20(sp)
8112e450:	e00d883a 	mov	r6,fp
8112e454:	8009883a 	mov	r4,r16
8112e458:	112ca340 	call	8112ca34 <__lshift>
8112e45c:	d8800515 	stw	r2,20(sp)
8112e460:	10023926 	beq	r2,zero,8112ed48 <_strtod_r+0x1200>
8112e464:	d8800a17 	ldw	r2,40(sp)
8112e468:	10000626 	beq	r2,zero,8112e484 <_strtod_r+0x93c>
8112e46c:	d9800a17 	ldw	r6,40(sp)
8112e470:	a00b883a 	mov	r5,r20
8112e474:	8009883a 	mov	r4,r16
8112e478:	112c8ec0 	call	8112c8ec <__pow5mult>
8112e47c:	1029883a 	mov	r20,r2
8112e480:	1000cf26 	beq	r2,zero,8112e7c0 <_strtod_r+0xc78>
8112e484:	05c0060e 	bge	zero,r23,8112e4a0 <_strtod_r+0x958>
8112e488:	a00b883a 	mov	r5,r20
8112e48c:	b80d883a 	mov	r6,r23
8112e490:	8009883a 	mov	r4,r16
8112e494:	112ca340 	call	8112ca34 <__lshift>
8112e498:	1029883a 	mov	r20,r2
8112e49c:	1000c826 	beq	r2,zero,8112e7c0 <_strtod_r+0xc78>
8112e4a0:	0580060e 	bge	zero,r22,8112e4bc <_strtod_r+0x974>
8112e4a4:	980b883a 	mov	r5,r19
8112e4a8:	b00d883a 	mov	r6,r22
8112e4ac:	8009883a 	mov	r4,r16
8112e4b0:	112ca340 	call	8112ca34 <__lshift>
8112e4b4:	1027883a 	mov	r19,r2
8112e4b8:	1000c126 	beq	r2,zero,8112e7c0 <_strtod_r+0xc78>
8112e4bc:	d9400517 	ldw	r5,20(sp)
8112e4c0:	a00d883a 	mov	r6,r20
8112e4c4:	8009883a 	mov	r4,r16
8112e4c8:	112cbe40 	call	8112cbe4 <__mdiff>
8112e4cc:	102b883a 	mov	r21,r2
8112e4d0:	1000bb26 	beq	r2,zero,8112e7c0 <_strtod_r+0xc78>
8112e4d4:	10c00317 	ldw	r3,12(r2)
8112e4d8:	980b883a 	mov	r5,r19
8112e4dc:	10000315 	stw	zero,12(r2)
8112e4e0:	1009883a 	mov	r4,r2
8112e4e4:	d8c00e15 	stw	r3,56(sp)
8112e4e8:	112cb840 	call	8112cb84 <__mcmp>
8112e4ec:	10027616 	blt	r2,zero,8112eec8 <_strtod_r+0x1380>
8112e4f0:	10024426 	beq	r2,zero,8112ee04 <_strtod_r+0x12bc>
8112e4f4:	980b883a 	mov	r5,r19
8112e4f8:	a809883a 	mov	r4,r21
8112e4fc:	112d0b40 	call	8112d0b4 <__ratio>
8112e500:	000d883a 	mov	r6,zero
8112e504:	01d00034 	movhi	r7,16384
8112e508:	1009883a 	mov	r4,r2
8112e50c:	180b883a 	mov	r5,r3
8112e510:	102f883a 	mov	r23,r2
8112e514:	182d883a 	mov	r22,r3
8112e518:	1135aa40 	call	81135aa4 <__ledf2>
8112e51c:	00804a16 	blt	zero,r2,8112e648 <_strtod_r+0xb00>
8112e520:	d9400e17 	ldw	r5,56(sp)
8112e524:	28006b26 	beq	r5,zero,8112e6d4 <_strtod_r+0xb8c>
8112e528:	058ffc34 	movhi	r22,16368
8112e52c:	d8000b15 	stw	zero,44(sp)
8112e530:	d8000d15 	stw	zero,52(sp)
8112e534:	b02f883a 	mov	r23,r22
8112e538:	8f1ffc2c 	andhi	fp,r17,32752
8112e53c:	009ff834 	movhi	r2,32736
8112e540:	e080cd26 	beq	fp,r2,8112e878 <_strtod_r+0xd30>
8112e544:	d9400917 	ldw	r5,36(sp)
8112e548:	28001a26 	beq	r5,zero,8112e5b4 <_strtod_r+0xa6c>
8112e54c:	0081a834 	movhi	r2,1696
8112e550:	17001836 	bltu	r2,fp,8112e5b4 <_strtod_r+0xa6c>
8112e554:	d9000d17 	ldw	r4,52(sp)
8112e558:	01d07834 	movhi	r7,16864
8112e55c:	39ffffc4 	addi	r7,r7,-1
8112e560:	01bff034 	movhi	r6,65472
8112e564:	b80b883a 	mov	r5,r23
8112e568:	1135aa40 	call	81135aa4 <__ledf2>
8112e56c:	00800e16 	blt	zero,r2,8112e5a8 <_strtod_r+0xa60>
8112e570:	d9000d17 	ldw	r4,52(sp)
8112e574:	b80b883a 	mov	r5,r23
8112e578:	111edd40 	call	8111edd4 <__fixunsdfsi>
8112e57c:	10018126 	beq	r2,zero,8112eb84 <_strtod_r+0x103c>
8112e580:	1009883a 	mov	r4,r2
8112e584:	1135b980 	call	81135b98 <__floatunsidf>
8112e588:	d8800d15 	stw	r2,52(sp)
8112e58c:	182f883a 	mov	r23,r3
8112e590:	d8800e17 	ldw	r2,56(sp)
8112e594:	1001791e 	bne	r2,zero,8112eb7c <_strtod_r+0x1034>
8112e598:	ba20003c 	xorhi	r8,r23,32768
8112e59c:	d8c00d17 	ldw	r3,52(sp)
8112e5a0:	402d883a 	mov	r22,r8
8112e5a4:	d8c00b15 	stw	r3,44(sp)
8112e5a8:	0081ac34 	movhi	r2,1712
8112e5ac:	b091883a 	add	r8,r22,r2
8112e5b0:	472dc83a 	sub	r22,r8,fp
8112e5b4:	9009883a 	mov	r4,r18
8112e5b8:	880b883a 	mov	r5,r17
8112e5bc:	112cde80 	call	8112cde8 <__ulp>
8112e5c0:	d9000b17 	ldw	r4,44(sp)
8112e5c4:	b00b883a 	mov	r5,r22
8112e5c8:	100d883a 	mov	r6,r2
8112e5cc:	180f883a 	mov	r7,r3
8112e5d0:	111f99c0 	call	8111f99c <__muldf3>
8112e5d4:	900d883a 	mov	r6,r18
8112e5d8:	880f883a 	mov	r7,r17
8112e5dc:	1009883a 	mov	r4,r2
8112e5e0:	180b883a 	mov	r5,r3
8112e5e4:	11348780 	call	81134878 <__adddf3>
8112e5e8:	1025883a 	mov	r18,r2
8112e5ec:	1823883a 	mov	r17,r3
8112e5f0:	182d883a 	mov	r22,r3
8112e5f4:	d9000917 	ldw	r4,36(sp)
8112e5f8:	2000021e 	bne	r4,zero,8112e604 <_strtod_r+0xabc>
8112e5fc:	b09ffc2c 	andhi	r2,r22,32752
8112e600:	e080be26 	beq	fp,r2,8112e8fc <_strtod_r+0xdb4>
8112e604:	d9400517 	ldw	r5,20(sp)
8112e608:	8009883a 	mov	r4,r16
8112e60c:	112c3340 	call	8112c334 <_Bfree>
8112e610:	a00b883a 	mov	r5,r20
8112e614:	8009883a 	mov	r4,r16
8112e618:	112c3340 	call	8112c334 <_Bfree>
8112e61c:	980b883a 	mov	r5,r19
8112e620:	8009883a 	mov	r4,r16
8112e624:	112c3340 	call	8112c334 <_Bfree>
8112e628:	a80b883a 	mov	r5,r21
8112e62c:	8009883a 	mov	r4,r16
8112e630:	112c3340 	call	8112c334 <_Bfree>
8112e634:	003f2f06 	br	8112e2f4 <__reset+0xfb10e2f4>
8112e638:	00c00044 	movi	r3,1
8112e63c:	d8000b15 	stw	zero,44(sp)
8112e640:	d8c00d15 	stw	r3,52(sp)
8112e644:	003f5f06 	br	8112e3c4 <__reset+0xfb10e3c4>
8112e648:	b809883a 	mov	r4,r23
8112e64c:	000d883a 	mov	r6,zero
8112e650:	01cff834 	movhi	r7,16352
8112e654:	b00b883a 	mov	r5,r22
8112e658:	111f99c0 	call	8111f99c <__muldf3>
8112e65c:	d9000e17 	ldw	r4,56(sp)
8112e660:	d8800d15 	stw	r2,52(sp)
8112e664:	182f883a 	mov	r23,r3
8112e668:	2000181e 	bne	r4,zero,8112e6cc <_strtod_r+0xb84>
8112e66c:	1a20003c 	xorhi	r8,r3,32768
8112e670:	d8800b15 	stw	r2,44(sp)
8112e674:	402d883a 	mov	r22,r8
8112e678:	003faf06 	br	8112e538 <__reset+0xfb10e538>
8112e67c:	0015883a 	mov	r10,zero
8112e680:	02c00044 	movi	r11,1
8112e684:	2800011e 	bne	r5,zero,8112e68c <_strtod_r+0xb44>
8112e688:	903d7e26 	beq	r18,zero,8112dc84 <__reset+0xfb10dc84>
8112e68c:	0013883a 	mov	r9,zero
8112e690:	003e4706 	br	8112dfb0 <__reset+0xfb10dfb0>
8112e694:	d8c00a17 	ldw	r3,40(sp)
8112e698:	dd800c17 	ldw	r22,48(sp)
8112e69c:	1889c83a 	sub	r4,r3,r2
8112e6a0:	003f3706 	br	8112e380 <__reset+0xfb10e380>
8112e6a4:	00bef884 	movi	r2,-1054
8112e6a8:	05c00044 	movi	r23,1
8112e6ac:	10c5c83a 	sub	r2,r2,r3
8112e6b0:	b884983a 	sll	r2,r23,r2
8112e6b4:	ddc00d15 	stw	r23,52(sp)
8112e6b8:	d8800b15 	stw	r2,44(sp)
8112e6bc:	003f4106 	br	8112e3c4 <__reset+0xfb10e3c4>
8112e6c0:	ddc00615 	stw	r23,24(sp)
8112e6c4:	002b883a 	mov	r21,zero
8112e6c8:	003dc306 	br	8112ddd8 <__reset+0xfb10ddd8>
8112e6cc:	1811883a 	mov	r8,r3
8112e6d0:	003fe706 	br	8112e670 <__reset+0xfb10e670>
8112e6d4:	90002e1e 	bne	r18,zero,8112e790 <_strtod_r+0xc48>
8112e6d8:	00c00434 	movhi	r3,16
8112e6dc:	18ffffc4 	addi	r3,r3,-1
8112e6e0:	88c4703a 	and	r2,r17,r3
8112e6e4:	10002c1e 	bne	r2,zero,8112e798 <_strtod_r+0xc50>
8112e6e8:	000d883a 	mov	r6,zero
8112e6ec:	01cffc34 	movhi	r7,16368
8112e6f0:	b809883a 	mov	r4,r23
8112e6f4:	b00b883a 	mov	r5,r22
8112e6f8:	1135aa40 	call	81135aa4 <__ledf2>
8112e6fc:	10021716 	blt	r2,zero,8112ef5c <_strtod_r+0x1414>
8112e700:	b809883a 	mov	r4,r23
8112e704:	b00b883a 	mov	r5,r22
8112e708:	000d883a 	mov	r6,zero
8112e70c:	01cff834 	movhi	r7,16352
8112e710:	111f99c0 	call	8111f99c <__muldf3>
8112e714:	d8800d15 	stw	r2,52(sp)
8112e718:	182f883a 	mov	r23,r3
8112e71c:	102d883a 	mov	r22,r2
8112e720:	1a20003c 	xorhi	r8,r3,32768
8112e724:	dd800b15 	stw	r22,44(sp)
8112e728:	402d883a 	mov	r22,r8
8112e72c:	003f8206 	br	8112e538 <__reset+0xfb10e538>
8112e730:	b013883a 	mov	r9,r22
8112e734:	000b883a 	mov	r5,zero
8112e738:	0015883a 	mov	r10,zero
8112e73c:	893ff404 	addi	r4,r17,-48
8112e740:	00800244 	movi	r2,9
8112e744:	11001036 	bltu	r2,r4,8112e788 <_strtod_r+0xc40>
8112e748:	28c00044 	addi	r3,r5,1
8112e74c:	2023883a 	mov	r17,r4
8112e750:	20014d1e 	bne	r4,zero,8112ec88 <_strtod_r+0x1140>
8112e754:	d9800617 	ldw	r6,24(sp)
8112e758:	180b883a 	mov	r5,r3
8112e75c:	30800044 	addi	r2,r6,1
8112e760:	d8800615 	stw	r2,24(sp)
8112e764:	34400047 	ldb	r17,1(r6)
8112e768:	003ff406 	br	8112e73c <__reset+0xfb10e73c>
8112e76c:	0019883a 	mov	r12,zero
8112e770:	b8800084 	addi	r2,r23,2
8112e774:	d8800615 	stw	r2,24(sp)
8112e778:	bc400087 	ldb	r17,2(r23)
8112e77c:	003e1606 	br	8112dfd8 <__reset+0xfb10dfd8>
8112e780:	03000044 	movi	r12,1
8112e784:	003ffa06 	br	8112e770 <__reset+0xfb10e770>
8112e788:	02c00044 	movi	r11,1
8112e78c:	003d8d06 	br	8112ddc4 <__reset+0xfb10ddc4>
8112e790:	00800044 	movi	r2,1
8112e794:	9080fe26 	beq	r18,r2,8112eb90 <_strtod_r+0x1048>
8112e798:	d8000b15 	stw	zero,44(sp)
8112e79c:	05affc34 	movhi	r22,49136
8112e7a0:	d8000d15 	stw	zero,52(sp)
8112e7a4:	05cffc34 	movhi	r23,16368
8112e7a8:	003f6306 	br	8112e538 <__reset+0xfb10e538>
8112e7ac:	d8000a15 	stw	zero,40(sp)
8112e7b0:	003ec906 	br	8112e2d8 <__reset+0xfb10e2d8>
8112e7b4:	d9001117 	ldw	r4,68(sp)
8112e7b8:	00bfffc4 	movi	r2,-1
8112e7bc:	2080461e 	bne	r4,r2,8112e8d8 <_strtod_r+0xd90>
8112e7c0:	dd000a15 	stw	r20,40(sp)
8112e7c4:	dd001217 	ldw	r20,72(sp)
8112e7c8:	a811883a 	mov	r8,r21
8112e7cc:	d8800517 	ldw	r2,20(sp)
8112e7d0:	00c00884 	movi	r3,34
8112e7d4:	80c00015 	stw	r3,0(r16)
8112e7d8:	002b883a 	mov	r21,zero
8112e7dc:	059ffc34 	movhi	r22,32752
8112e7e0:	100b883a 	mov	r5,r2
8112e7e4:	8009883a 	mov	r4,r16
8112e7e8:	da001315 	stw	r8,76(sp)
8112e7ec:	112c3340 	call	8112c334 <_Bfree>
8112e7f0:	d9400a17 	ldw	r5,40(sp)
8112e7f4:	8009883a 	mov	r4,r16
8112e7f8:	112c3340 	call	8112c334 <_Bfree>
8112e7fc:	980b883a 	mov	r5,r19
8112e800:	8009883a 	mov	r4,r16
8112e804:	112c3340 	call	8112c334 <_Bfree>
8112e808:	d9400817 	ldw	r5,32(sp)
8112e80c:	8009883a 	mov	r4,r16
8112e810:	112c3340 	call	8112c334 <_Bfree>
8112e814:	da001317 	ldw	r8,76(sp)
8112e818:	8009883a 	mov	r4,r16
8112e81c:	400b883a 	mov	r5,r8
8112e820:	112c3340 	call	8112c334 <_Bfree>
8112e824:	003d9206 	br	8112de70 <__reset+0xfb10de70>
8112e828:	d8c00717 	ldw	r3,28(sp)
8112e82c:	d8800504 	addi	r2,sp,20
8112e830:	01a04574 	movhi	r6,33045
8112e834:	31818404 	addi	r6,r6,1552
8112e838:	d8c00115 	stw	r3,4(sp)
8112e83c:	d8800015 	stw	r2,0(sp)
8112e840:	d9c00404 	addi	r7,sp,16
8112e844:	d9400604 	addi	r5,sp,24
8112e848:	8009883a 	mov	r4,r16
8112e84c:	1132c9c0 	call	81132c9c <__gethex>
8112e850:	154001cc 	andi	r21,r2,7
8112e854:	a83d9b26 	beq	r21,zero,8112dec4 <__reset+0xfb10dec4>
8112e858:	00c00184 	movi	r3,6
8112e85c:	a8c0d61e 	bne	r21,r3,8112ebb8 <_strtod_r+0x1070>
8112e860:	9cc00044 	addi	r19,r19,1
8112e864:	dcc00615 	stw	r19,24(sp)
8112e868:	002b883a 	mov	r21,zero
8112e86c:	002d883a 	mov	r22,zero
8112e870:	d8000715 	stw	zero,28(sp)
8112e874:	003d7e06 	br	8112de70 <__reset+0xfb10de70>
8112e878:	00bf2c34 	movhi	r2,64688
8112e87c:	88a3883a 	add	r17,r17,r2
8112e880:	9009883a 	mov	r4,r18
8112e884:	880b883a 	mov	r5,r17
8112e888:	112cde80 	call	8112cde8 <__ulp>
8112e88c:	d9000b17 	ldw	r4,44(sp)
8112e890:	100d883a 	mov	r6,r2
8112e894:	180f883a 	mov	r7,r3
8112e898:	b00b883a 	mov	r5,r22
8112e89c:	111f99c0 	call	8111f99c <__muldf3>
8112e8a0:	900d883a 	mov	r6,r18
8112e8a4:	180b883a 	mov	r5,r3
8112e8a8:	880f883a 	mov	r7,r17
8112e8ac:	1009883a 	mov	r4,r2
8112e8b0:	11348780 	call	81134878 <__adddf3>
8112e8b4:	015f2834 	movhi	r5,31904
8112e8b8:	1025883a 	mov	r18,r2
8112e8bc:	297fffc4 	addi	r5,r5,-1
8112e8c0:	189ffc2c 	andhi	r2,r3,32752
8112e8c4:	2880892e 	bgeu	r5,r2,8112eaec <_strtod_r+0xfa4>
8112e8c8:	d8801017 	ldw	r2,64(sp)
8112e8cc:	00dffc34 	movhi	r3,32752
8112e8d0:	18ffffc4 	addi	r3,r3,-1
8112e8d4:	10ffb726 	beq	r2,r3,8112e7b4 <__reset+0xfb10e7b4>
8112e8d8:	045ffc34 	movhi	r17,32752
8112e8dc:	8c7fffc4 	addi	r17,r17,-1
8112e8e0:	04bfffc4 	movi	r18,-1
8112e8e4:	003f4706 	br	8112e604 <__reset+0xfb10e604>
8112e8e8:	00800884 	movi	r2,34
8112e8ec:	80800015 	stw	r2,0(r16)
8112e8f0:	002b883a 	mov	r21,zero
8112e8f4:	059ffc34 	movhi	r22,32752
8112e8f8:	003d5d06 	br	8112de70 <__reset+0xfb10de70>
8112e8fc:	d9000d17 	ldw	r4,52(sp)
8112e900:	b80b883a 	mov	r5,r23
8112e904:	11209c00 	call	811209c0 <__fixdfsi>
8112e908:	1009883a 	mov	r4,r2
8112e90c:	1120a400 	call	81120a40 <__floatsidf>
8112e910:	d9000d17 	ldw	r4,52(sp)
8112e914:	b80b883a 	mov	r5,r23
8112e918:	100d883a 	mov	r6,r2
8112e91c:	180f883a 	mov	r7,r3
8112e920:	11200bc0 	call	811200bc <__subdf3>
8112e924:	d9400e17 	ldw	r5,56(sp)
8112e928:	1039883a 	mov	fp,r2
8112e92c:	182f883a 	mov	r23,r3
8112e930:	2800141e 	bne	r5,zero,8112e984 <_strtod_r+0xe3c>
8112e934:	9000131e 	bne	r18,zero,8112e984 <_strtod_r+0xe3c>
8112e938:	00800434 	movhi	r2,16
8112e93c:	10bfffc4 	addi	r2,r2,-1
8112e940:	b0ac703a 	and	r22,r22,r2
8112e944:	b0000f1e 	bne	r22,zero,8112e984 <_strtod_r+0xe3c>
8112e948:	01a52834 	movhi	r6,38048
8112e94c:	01cff434 	movhi	r7,16336
8112e950:	318d6544 	addi	r6,r6,13717
8112e954:	39ffffc4 	addi	r7,r7,-1
8112e958:	e009883a 	mov	r4,fp
8112e95c:	180b883a 	mov	r5,r3
8112e960:	1135aa40 	call	81135aa4 <__ledf2>
8112e964:	103f270e 	bge	r2,zero,8112e604 <__reset+0xfb10e604>
8112e968:	dd000a15 	stw	r20,40(sp)
8112e96c:	a811883a 	mov	r8,r21
8112e970:	dd001217 	ldw	r20,72(sp)
8112e974:	d8800517 	ldw	r2,20(sp)
8112e978:	002b883a 	mov	r21,zero
8112e97c:	882d883a 	mov	r22,r17
8112e980:	003f9706 	br	8112e7e0 <__reset+0xfb10e7e0>
8112e984:	01a52834 	movhi	r6,38048
8112e988:	01cff834 	movhi	r7,16352
8112e98c:	318d6544 	addi	r6,r6,13717
8112e990:	39ffffc4 	addi	r7,r7,-1
8112e994:	e009883a 	mov	r4,fp
8112e998:	b80b883a 	mov	r5,r23
8112e99c:	1135aa40 	call	81135aa4 <__ledf2>
8112e9a0:	10000716 	blt	r2,zero,8112e9c0 <_strtod_r+0xe78>
8112e9a4:	018d6c34 	movhi	r6,13744
8112e9a8:	31b94d44 	addi	r6,r6,-6859
8112e9ac:	01cff834 	movhi	r7,16352
8112e9b0:	e009883a 	mov	r4,fp
8112e9b4:	b80b883a 	mov	r5,r23
8112e9b8:	111f8c00 	call	8111f8c0 <__gedf2>
8112e9bc:	00bf110e 	bge	zero,r2,8112e604 <__reset+0xfb10e604>
8112e9c0:	dd000a15 	stw	r20,40(sp)
8112e9c4:	a811883a 	mov	r8,r21
8112e9c8:	dd001217 	ldw	r20,72(sp)
8112e9cc:	d8800517 	ldw	r2,20(sp)
8112e9d0:	902b883a 	mov	r21,r18
8112e9d4:	882d883a 	mov	r22,r17
8112e9d8:	003f8106 	br	8112e7e0 <__reset+0xfb10e7e0>
8112e9dc:	b83e2f26 	beq	r23,zero,8112e29c <__reset+0xfb10e29c>
8112e9e0:	05efc83a 	sub	r23,zero,r23
8112e9e4:	b88003cc 	andi	r2,r23,15
8112e9e8:	10000d26 	beq	r2,zero,8112ea20 <_strtod_r+0xed8>
8112e9ec:	100490fa 	slli	r2,r2,3
8112e9f0:	00e04574 	movhi	r3,33045
8112e9f4:	18c14904 	addi	r3,r3,1316
8112e9f8:	1885883a 	add	r2,r3,r2
8112e9fc:	11800017 	ldw	r6,0(r2)
8112ea00:	11c00117 	ldw	r7,4(r2)
8112ea04:	9009883a 	mov	r4,r18
8112ea08:	880b883a 	mov	r5,r17
8112ea0c:	da401315 	stw	r9,76(sp)
8112ea10:	113512c0 	call	8113512c <__divdf3>
8112ea14:	da401317 	ldw	r9,76(sp)
8112ea18:	1025883a 	mov	r18,r2
8112ea1c:	1823883a 	mov	r17,r3
8112ea20:	b82fd13a 	srai	r23,r23,4
8112ea24:	b83e1d26 	beq	r23,zero,8112e29c <__reset+0xfb10e29c>
8112ea28:	008007c4 	movi	r2,31
8112ea2c:	15c02816 	blt	r2,r23,8112ead0 <_strtod_r+0xf88>
8112ea30:	b880040c 	andi	r2,r23,16
8112ea34:	10019726 	beq	r2,zero,8112f094 <_strtod_r+0x154c>
8112ea38:	05c1880e 	bge	zero,r23,8112f05c <_strtod_r+0x1514>
8112ea3c:	00c01a84 	movi	r3,106
8112ea40:	d8c00915 	stw	r3,36(sp)
8112ea44:	04e04574 	movhi	r19,33045
8112ea48:	9cc18904 	addi	r19,r19,1572
8112ea4c:	8807883a 	mov	r3,r17
8112ea50:	9005883a 	mov	r2,r18
8112ea54:	8023883a 	mov	r17,r16
8112ea58:	0009883a 	mov	r4,zero
8112ea5c:	9821883a 	mov	r16,r19
8112ea60:	da400a15 	stw	r9,40(sp)
8112ea64:	1827883a 	mov	r19,r3
8112ea68:	b980004c 	andi	r6,r23,1
8112ea6c:	30000626 	beq	r6,zero,8112ea88 <_strtod_r+0xf40>
8112ea70:	81800017 	ldw	r6,0(r16)
8112ea74:	81c00117 	ldw	r7,4(r16)
8112ea78:	1009883a 	mov	r4,r2
8112ea7c:	180b883a 	mov	r5,r3
8112ea80:	111f99c0 	call	8111f99c <__muldf3>
8112ea84:	01000044 	movi	r4,1
8112ea88:	b82fd07a 	srai	r23,r23,1
8112ea8c:	84000204 	addi	r16,r16,8
8112ea90:	b83ff51e 	bne	r23,zero,8112ea68 <__reset+0xfb10ea68>
8112ea94:	21003fcc 	andi	r4,r4,255
8112ea98:	8821883a 	mov	r16,r17
8112ea9c:	da400a17 	ldw	r9,40(sp)
8112eaa0:	9823883a 	mov	r17,r19
8112eaa4:	2001a51e 	bne	r4,zero,8112f13c <_strtod_r+0x15f4>
8112eaa8:	d9000917 	ldw	r4,36(sp)
8112eaac:	20016d1e 	bne	r4,zero,8112f064 <_strtod_r+0x151c>
8112eab0:	000d883a 	mov	r6,zero
8112eab4:	000f883a 	mov	r7,zero
8112eab8:	9009883a 	mov	r4,r18
8112eabc:	880b883a 	mov	r5,r17
8112eac0:	da401315 	stw	r9,76(sp)
8112eac4:	1135a1c0 	call	81135a1c <__eqdf2>
8112eac8:	da401317 	ldw	r9,76(sp)
8112eacc:	103df41e 	bne	r2,zero,8112e2a0 <__reset+0xfb10e2a0>
8112ead0:	00800884 	movi	r2,34
8112ead4:	80800015 	stw	r2,0(r16)
8112ead8:	002b883a 	mov	r21,zero
8112eadc:	002d883a 	mov	r22,zero
8112eae0:	003ce306 	br	8112de70 <__reset+0xfb10de70>
8112eae4:	055387c4 	movi	r21,19999
8112eae8:	003d6b06 	br	8112e098 <__reset+0xfb10e098>
8112eaec:	0440d434 	movhi	r17,848
8112eaf0:	1c63883a 	add	r17,r3,r17
8112eaf4:	882d883a 	mov	r22,r17
8112eaf8:	003ebe06 	br	8112e5f4 <__reset+0xfb10e5f4>
8112eafc:	14403fcc 	andi	r17,r2,255
8112eb00:	8c40201c 	xori	r17,r17,128
8112eb04:	8c7fe004 	addi	r17,r17,-128
8112eb08:	dd400817 	ldw	r21,32(sp)
8112eb0c:	0027883a 	mov	r19,zero
8112eb10:	0039883a 	mov	fp,zero
8112eb14:	002d883a 	mov	r22,zero
8112eb18:	003c9906 	br	8112dd80 <__reset+0xfb10dd80>
8112eb1c:	00c00944 	movi	r3,37
8112eb20:	1a47c83a 	sub	r3,r3,r9
8112eb24:	1d7d8c16 	blt	r3,r21,8112e158 <__reset+0xfb10e158>
8112eb28:	1261c83a 	sub	r16,r2,r9
8112eb2c:	800490fa 	slli	r2,r16,3
8112eb30:	04e04574 	movhi	r19,33045
8112eb34:	9cc14904 	addi	r19,r19,1316
8112eb38:	9885883a 	add	r2,r19,r2
8112eb3c:	11000017 	ldw	r4,0(r2)
8112eb40:	11400117 	ldw	r5,4(r2)
8112eb44:	900d883a 	mov	r6,r18
8112eb48:	880f883a 	mov	r7,r17
8112eb4c:	111f99c0 	call	8111f99c <__muldf3>
8112eb50:	ac0dc83a 	sub	r6,r21,r16
8112eb54:	300c90fa 	slli	r6,r6,3
8112eb58:	1009883a 	mov	r4,r2
8112eb5c:	180b883a 	mov	r5,r3
8112eb60:	9985883a 	add	r2,r19,r6
8112eb64:	11800017 	ldw	r6,0(r2)
8112eb68:	11c00117 	ldw	r7,4(r2)
8112eb6c:	111f99c0 	call	8111f99c <__muldf3>
8112eb70:	102b883a 	mov	r21,r2
8112eb74:	182d883a 	mov	r22,r3
8112eb78:	003cbd06 	br	8112de70 <__reset+0xfb10de70>
8112eb7c:	b811883a 	mov	r8,r23
8112eb80:	003e8606 	br	8112e59c <__reset+0xfb10e59c>
8112eb84:	d8000d15 	stw	zero,52(sp)
8112eb88:	05cffc34 	movhi	r23,16368
8112eb8c:	003e8006 	br	8112e590 <__reset+0xfb10e590>
8112eb90:	883f011e 	bne	r17,zero,8112e798 <__reset+0xfb10e798>
8112eb94:	dd000a15 	stw	r20,40(sp)
8112eb98:	dd001217 	ldw	r20,72(sp)
8112eb9c:	a811883a 	mov	r8,r21
8112eba0:	00800884 	movi	r2,34
8112eba4:	80800015 	stw	r2,0(r16)
8112eba8:	002b883a 	mov	r21,zero
8112ebac:	d8800517 	ldw	r2,20(sp)
8112ebb0:	002d883a 	mov	r22,zero
8112ebb4:	003f0a06 	br	8112e7e0 <__reset+0xfb10e7e0>
8112ebb8:	d9800517 	ldw	r6,20(sp)
8112ebbc:	30000826 	beq	r6,zero,8112ebe0 <_strtod_r+0x1098>
8112ebc0:	01400d44 	movi	r5,53
8112ebc4:	d9000204 	addi	r4,sp,8
8112ebc8:	d8801315 	stw	r2,76(sp)
8112ebcc:	112d1dc0 	call	8112d1dc <__copybits>
8112ebd0:	d9400517 	ldw	r5,20(sp)
8112ebd4:	8009883a 	mov	r4,r16
8112ebd8:	112c3340 	call	8112c334 <_Bfree>
8112ebdc:	d8801317 	ldw	r2,76(sp)
8112ebe0:	00c00184 	movi	r3,6
8112ebe4:	1d400f36 	bltu	r3,r21,8112ec24 <_strtod_r+0x10dc>
8112ebe8:	a82a90ba 	slli	r21,r21,2
8112ebec:	00e044f4 	movhi	r3,33043
8112ebf0:	18fb0004 	addi	r3,r3,-5120
8112ebf4:	a8eb883a 	add	r21,r21,r3
8112ebf8:	a8c00017 	ldw	r3,0(r21)
8112ebfc:	1800683a 	jmp	r3
8112ec00:	8112ec7c 	xorhi	r4,r16,19377
8112ec04:	8112ec54 	ori	r4,r16,19377
8112ec08:	8112ec38 	rdprs	r4,r16,19376
8112ec0c:	8112ec1c 	xori	r4,r16,19376
8112ec10:	8112ec44 	addi	r4,r16,19377
8112ec14:	8112ec54 	ori	r4,r16,19377
8112ec18:	8112ec7c 	xorhi	r4,r16,19377
8112ec1c:	045ffc34 	movhi	r17,32752
8112ec20:	0025883a 	mov	r18,zero
8112ec24:	1080020c 	andi	r2,r2,8
8112ec28:	902b883a 	mov	r21,r18
8112ec2c:	103c8f26 	beq	r2,zero,8112de6c <__reset+0xfb10de6c>
8112ec30:	8da00034 	orhi	r22,r17,32768
8112ec34:	003c8e06 	br	8112de70 <__reset+0xfb10de70>
8112ec38:	dc800217 	ldw	r18,8(sp)
8112ec3c:	dc400317 	ldw	r17,12(sp)
8112ec40:	003ff806 	br	8112ec24 <__reset+0xfb10ec24>
8112ec44:	04600034 	movhi	r17,32768
8112ec48:	8c7fffc4 	addi	r17,r17,-1
8112ec4c:	04bfffc4 	movi	r18,-1
8112ec50:	003ff406 	br	8112ec24 <__reset+0xfb10ec24>
8112ec54:	d8c00417 	ldw	r3,16(sp)
8112ec58:	dc400317 	ldw	r17,12(sp)
8112ec5c:	013ffc34 	movhi	r4,65520
8112ec60:	18c10cc4 	addi	r3,r3,1075
8112ec64:	1806953a 	slli	r3,r3,20
8112ec68:	213fffc4 	addi	r4,r4,-1
8112ec6c:	8922703a 	and	r17,r17,r4
8112ec70:	dc800217 	ldw	r18,8(sp)
8112ec74:	88e2b03a 	or	r17,r17,r3
8112ec78:	003fea06 	br	8112ec24 <__reset+0xfb10ec24>
8112ec7c:	0023883a 	mov	r17,zero
8112ec80:	0025883a 	mov	r18,zero
8112ec84:	003fe706 	br	8112ec24 <__reset+0xfb10ec24>
8112ec88:	01800044 	movi	r6,1
8112ec8c:	50d5883a 	add	r10,r10,r3
8112ec90:	2a4b883a 	add	r5,r5,r9
8112ec94:	19811a26 	beq	r3,r6,8112f100 <_strtod_r+0x15b8>
8112ec98:	01800204 	movi	r6,8
8112ec9c:	01c00404 	movi	r7,16
8112eca0:	4a400044 	addi	r9,r9,1
8112eca4:	48bfffc4 	addi	r2,r9,-1
8112eca8:	30801616 	blt	r6,r2,8112ed04 <_strtod_r+0x11bc>
8112ecac:	e70002a4 	muli	fp,fp,10
8112ecb0:	497ffb1e 	bne	r9,r5,8112eca0 <__reset+0xfb10eca0>
8112ecb4:	d9800617 	ldw	r6,24(sp)
8112ecb8:	4a400044 	addi	r9,r9,1
8112ecbc:	00c00204 	movi	r3,8
8112ecc0:	19400c0e 	bge	r3,r5,8112ecf4 <_strtod_r+0x11ac>
8112ecc4:	00800404 	movi	r2,16
8112ecc8:	000b883a 	mov	r5,zero
8112eccc:	127ea316 	blt	r2,r9,8112e75c <__reset+0xfb10e75c>
8112ecd0:	988002a4 	muli	r2,r19,10
8112ecd4:	20a7883a 	add	r19,r4,r2
8112ecd8:	003ea006 	br	8112e75c <__reset+0xfb10e75c>
8112ecdc:	d8800617 	ldw	r2,24(sp)
8112ece0:	8c7ff404 	addi	r17,r17,-48
8112ece4:	2a800044 	addi	r10,r5,1
8112ece8:	d8800815 	stw	r2,32(sp)
8112ecec:	100d883a 	mov	r6,r2
8112ecf0:	02400044 	movi	r9,1
8112ecf4:	e08002a4 	muli	r2,fp,10
8112ecf8:	000b883a 	mov	r5,zero
8112ecfc:	88b9883a 	add	fp,r17,r2
8112ed00:	003e9606 	br	8112e75c <__reset+0xfb10e75c>
8112ed04:	3a7fea16 	blt	r7,r9,8112ecb0 <__reset+0xfb10ecb0>
8112ed08:	9cc002a4 	muli	r19,r19,10
8112ed0c:	003fe806 	br	8112ecb0 <__reset+0xfb10ecb0>
8112ed10:	00bffa84 	movi	r2,-22
8112ed14:	a8bd1016 	blt	r21,r2,8112e158 <__reset+0xfb10e158>
8112ed18:	a82a90fa 	slli	r21,r21,3
8112ed1c:	00a04574 	movhi	r2,33045
8112ed20:	10814904 	addi	r2,r2,1316
8112ed24:	1545c83a 	sub	r2,r2,r21
8112ed28:	11800017 	ldw	r6,0(r2)
8112ed2c:	11c00117 	ldw	r7,4(r2)
8112ed30:	9009883a 	mov	r4,r18
8112ed34:	880b883a 	mov	r5,r17
8112ed38:	113512c0 	call	8113512c <__divdf3>
8112ed3c:	102b883a 	mov	r21,r2
8112ed40:	182d883a 	mov	r22,r3
8112ed44:	003c4a06 	br	8112de70 <__reset+0xfb10de70>
8112ed48:	dd000a15 	stw	r20,40(sp)
8112ed4c:	a811883a 	mov	r8,r21
8112ed50:	dd001217 	ldw	r20,72(sp)
8112ed54:	003e9e06 	br	8112e7d0 <__reset+0xfb10e7d0>
8112ed58:	01604574 	movhi	r5,33045
8112ed5c:	d9000617 	ldw	r4,24(sp)
8112ed60:	29417b04 	addi	r5,r5,1516
8112ed64:	01c00644 	movi	r7,25
8112ed68:	00000b06 	br	8112ed98 <_strtod_r+0x1250>
8112ed6c:	21000044 	addi	r4,r4,1
8112ed70:	20800003 	ldbu	r2,0(r4)
8112ed74:	10ffefc4 	addi	r3,r2,-65
8112ed78:	10803fcc 	andi	r2,r2,255
8112ed7c:	1080201c 	xori	r2,r2,128
8112ed80:	18c03fcc 	andi	r3,r3,255
8112ed84:	10bfe004 	addi	r2,r2,-128
8112ed88:	38c00136 	bltu	r7,r3,8112ed90 <_strtod_r+0x1248>
8112ed8c:	10800804 	addi	r2,r2,32
8112ed90:	29400044 	addi	r5,r5,1
8112ed94:	11bbbb1e 	bne	r2,r6,8112dc84 <__reset+0xfb10dc84>
8112ed98:	29800007 	ldb	r6,0(r5)
8112ed9c:	303ff31e 	bne	r6,zero,8112ed6c <__reset+0xfb10ed6c>
8112eda0:	01a04574 	movhi	r6,33045
8112eda4:	d9000615 	stw	r4,24(sp)
8112eda8:	31817c04 	addi	r6,r6,1520
8112edac:	200b883a 	mov	r5,r4
8112edb0:	02000644 	movi	r8,25
8112edb4:	00000a06 	br	8112ede0 <_strtod_r+0x1298>
8112edb8:	28800003 	ldbu	r2,0(r5)
8112edbc:	10ffefc4 	addi	r3,r2,-65
8112edc0:	10803fcc 	andi	r2,r2,255
8112edc4:	1080201c 	xori	r2,r2,128
8112edc8:	18c03fcc 	andi	r3,r3,255
8112edcc:	10bfe004 	addi	r2,r2,-128
8112edd0:	40c00136 	bltu	r8,r3,8112edd8 <_strtod_r+0x1290>
8112edd4:	10800804 	addi	r2,r2,32
8112edd8:	31800044 	addi	r6,r6,1
8112eddc:	11c0711e 	bne	r2,r7,8112efa4 <_strtod_r+0x145c>
8112ede0:	31c00007 	ldb	r7,0(r6)
8112ede4:	29400044 	addi	r5,r5,1
8112ede8:	383ff31e 	bne	r7,zero,8112edb8 <__reset+0xfb10edb8>
8112edec:	d9400615 	stw	r5,24(sp)
8112edf0:	045ffc34 	movhi	r17,32752
8112edf4:	0025883a 	mov	r18,zero
8112edf8:	003c1b06 	br	8112de68 <__reset+0xfb10de68>
8112edfc:	000b883a 	mov	r5,zero
8112ee00:	003ccc06 	br	8112e134 <__reset+0xfb10e134>
8112ee04:	d9400e17 	ldw	r5,56(sp)
8112ee08:	dd000a15 	stw	r20,40(sp)
8112ee0c:	00800434 	movhi	r2,16
8112ee10:	a811883a 	mov	r8,r21
8112ee14:	dd001217 	ldw	r20,72(sp)
8112ee18:	dd401117 	ldw	r21,68(sp)
8112ee1c:	dd801017 	ldw	r22,64(sp)
8112ee20:	10bfffc4 	addi	r2,r2,-1
8112ee24:	28005626 	beq	r5,zero,8112ef80 <_strtod_r+0x1438>
8112ee28:	8886703a 	and	r3,r17,r2
8112ee2c:	18807826 	beq	r3,r2,8112f010 <_strtod_r+0x14c8>
8112ee30:	d8c00b17 	ldw	r3,44(sp)
8112ee34:	18005726 	beq	r3,zero,8112ef94 <_strtod_r+0x144c>
8112ee38:	1c44703a 	and	r2,r3,r17
8112ee3c:	10000f26 	beq	r2,zero,8112ee7c <_strtod_r+0x1334>
8112ee40:	d9000e17 	ldw	r4,56(sp)
8112ee44:	d9800917 	ldw	r6,36(sp)
8112ee48:	20005e26 	beq	r4,zero,8112efc4 <_strtod_r+0x147c>
8112ee4c:	9009883a 	mov	r4,r18
8112ee50:	880b883a 	mov	r5,r17
8112ee54:	da001315 	stw	r8,76(sp)
8112ee58:	112dadc0 	call	8112dadc <sulp>
8112ee5c:	100d883a 	mov	r6,r2
8112ee60:	180f883a 	mov	r7,r3
8112ee64:	9009883a 	mov	r4,r18
8112ee68:	880b883a 	mov	r5,r17
8112ee6c:	11348780 	call	81134878 <__adddf3>
8112ee70:	da001317 	ldw	r8,76(sp)
8112ee74:	102b883a 	mov	r21,r2
8112ee78:	182d883a 	mov	r22,r3
8112ee7c:	d8c00917 	ldw	r3,36(sp)
8112ee80:	18000f26 	beq	r3,zero,8112eec0 <_strtod_r+0x1378>
8112ee84:	a809883a 	mov	r4,r21
8112ee88:	b00b883a 	mov	r5,r22
8112ee8c:	000d883a 	mov	r6,zero
8112ee90:	01ce5434 	movhi	r7,14672
8112ee94:	da001315 	stw	r8,76(sp)
8112ee98:	111f99c0 	call	8111f99c <__muldf3>
8112ee9c:	102b883a 	mov	r21,r2
8112eea0:	182d883a 	mov	r22,r3
8112eea4:	da001317 	ldw	r8,76(sp)
8112eea8:	1800051e 	bne	r3,zero,8112eec0 <_strtod_r+0x1378>
8112eeac:	d8800517 	ldw	r2,20(sp)
8112eeb0:	a83e4b1e 	bne	r21,zero,8112e7e0 <__reset+0xfb10e7e0>
8112eeb4:	00c00884 	movi	r3,34
8112eeb8:	80c00015 	stw	r3,0(r16)
8112eebc:	003e4806 	br	8112e7e0 <__reset+0xfb10e7e0>
8112eec0:	d8800517 	ldw	r2,20(sp)
8112eec4:	003e4606 	br	8112e7e0 <__reset+0xfb10e7e0>
8112eec8:	d9000e17 	ldw	r4,56(sp)
8112eecc:	dd000a15 	stw	r20,40(sp)
8112eed0:	a811883a 	mov	r8,r21
8112eed4:	dd001217 	ldw	r20,72(sp)
8112eed8:	dd401117 	ldw	r21,68(sp)
8112eedc:	dd801017 	ldw	r22,64(sp)
8112eee0:	203fe61e 	bne	r4,zero,8112ee7c <__reset+0xfb10ee7c>
8112eee4:	903fe51e 	bne	r18,zero,8112ee7c <__reset+0xfb10ee7c>
8112eee8:	00800434 	movhi	r2,16
8112eeec:	10bfffc4 	addi	r2,r2,-1
8112eef0:	8884703a 	and	r2,r17,r2
8112eef4:	103fe11e 	bne	r2,zero,8112ee7c <__reset+0xfb10ee7c>
8112eef8:	8ddffc2c 	andhi	r23,r17,32752
8112eefc:	0081ac34 	movhi	r2,1712
8112ef00:	15ffde2e 	bgeu	r2,r23,8112ee7c <__reset+0xfb10ee7c>
8112ef04:	40800517 	ldw	r2,20(r8)
8112ef08:	1000031e 	bne	r2,zero,8112ef18 <_strtod_r+0x13d0>
8112ef0c:	40800417 	ldw	r2,16(r8)
8112ef10:	00c00044 	movi	r3,1
8112ef14:	18bfd90e 	bge	r3,r2,8112ee7c <__reset+0xfb10ee7c>
8112ef18:	400b883a 	mov	r5,r8
8112ef1c:	01800044 	movi	r6,1
8112ef20:	8009883a 	mov	r4,r16
8112ef24:	112ca340 	call	8112ca34 <__lshift>
8112ef28:	980b883a 	mov	r5,r19
8112ef2c:	1009883a 	mov	r4,r2
8112ef30:	d8801315 	stw	r2,76(sp)
8112ef34:	112cb840 	call	8112cb84 <__mcmp>
8112ef38:	da001317 	ldw	r8,76(sp)
8112ef3c:	00bfcf0e 	bge	zero,r2,8112ee7c <__reset+0xfb10ee7c>
8112ef40:	d8c00917 	ldw	r3,36(sp)
8112ef44:	18005c26 	beq	r3,zero,8112f0b8 <_strtod_r+0x1570>
8112ef48:	0081ac34 	movhi	r2,1712
8112ef4c:	15c05a16 	blt	r2,r23,8112f0b8 <_strtod_r+0x1570>
8112ef50:	0080dc34 	movhi	r2,880
8112ef54:	15ffcb16 	blt	r2,r23,8112ee84 <__reset+0xfb10ee84>
8112ef58:	003f1106 	br	8112eba0 <__reset+0xfb10eba0>
8112ef5c:	002d883a 	mov	r22,zero
8112ef60:	022ff834 	movhi	r8,49120
8112ef64:	d8000d15 	stw	zero,52(sp)
8112ef68:	05cff834 	movhi	r23,16352
8112ef6c:	003ded06 	br	8112e724 <__reset+0xfb10e724>
8112ef70:	0440d434 	movhi	r17,848
8112ef74:	1c63883a 	add	r17,r3,r17
8112ef78:	d8000915 	stw	zero,36(sp)
8112ef7c:	003cc806 	br	8112e2a0 <__reset+0xfb10e2a0>
8112ef80:	8884703a 	and	r2,r17,r2
8112ef84:	103faa1e 	bne	r2,zero,8112ee30 <__reset+0xfb10ee30>
8112ef88:	903fa91e 	bne	r18,zero,8112ee30 <__reset+0xfb10ee30>
8112ef8c:	8ddffc2c 	andhi	r23,r17,32752
8112ef90:	003feb06 	br	8112ef40 <__reset+0xfb10ef40>
8112ef94:	d8c00d17 	ldw	r3,52(sp)
8112ef98:	1cae703a 	and	r23,r3,r18
8112ef9c:	b83fb726 	beq	r23,zero,8112ee7c <__reset+0xfb10ee7c>
8112efa0:	003fa706 	br	8112ee40 <__reset+0xfb10ee40>
8112efa4:	21000044 	addi	r4,r4,1
8112efa8:	d9000615 	stw	r4,24(sp)
8112efac:	003f9006 	br	8112edf0 <__reset+0xfb10edf0>
8112efb0:	01604574 	movhi	r5,33045
8112efb4:	29413f04 	addi	r5,r5,1276
8112efb8:	d9400915 	stw	r5,36(sp)
8112efbc:	0027883a 	mov	r19,zero
8112efc0:	003ca206 	br	8112e24c <__reset+0xfb10e24c>
8112efc4:	9009883a 	mov	r4,r18
8112efc8:	880b883a 	mov	r5,r17
8112efcc:	da001315 	stw	r8,76(sp)
8112efd0:	112dadc0 	call	8112dadc <sulp>
8112efd4:	100d883a 	mov	r6,r2
8112efd8:	180f883a 	mov	r7,r3
8112efdc:	9009883a 	mov	r4,r18
8112efe0:	880b883a 	mov	r5,r17
8112efe4:	11200bc0 	call	811200bc <__subdf3>
8112efe8:	000d883a 	mov	r6,zero
8112efec:	000f883a 	mov	r7,zero
8112eff0:	1009883a 	mov	r4,r2
8112eff4:	180b883a 	mov	r5,r3
8112eff8:	102b883a 	mov	r21,r2
8112effc:	182d883a 	mov	r22,r3
8112f000:	1135a1c0 	call	81135a1c <__eqdf2>
8112f004:	da001317 	ldw	r8,76(sp)
8112f008:	103ee526 	beq	r2,zero,8112eba0 <__reset+0xfb10eba0>
8112f00c:	003f9b06 	br	8112ee7c <__reset+0xfb10ee7c>
8112f010:	d8800917 	ldw	r2,36(sp)
8112f014:	10002226 	beq	r2,zero,8112f0a0 <_strtod_r+0x1558>
8112f018:	889ffc2c 	andhi	r2,r17,32752
8112f01c:	00c1a834 	movhi	r3,1696
8112f020:	18801f36 	bltu	r3,r2,8112f0a0 <_strtod_r+0x1558>
8112f024:	1004d53a 	srli	r2,r2,20
8112f028:	00c01ac4 	movi	r3,107
8112f02c:	1887c83a 	sub	r3,r3,r2
8112f030:	00bfffc4 	movi	r2,-1
8112f034:	10c4983a 	sll	r2,r2,r3
8112f038:	14bf7d1e 	bne	r2,r18,8112ee30 <__reset+0xfb10ee30>
8112f03c:	00dffc34 	movhi	r3,32752
8112f040:	18ffffc4 	addi	r3,r3,-1
8112f044:	88c03526 	beq	r17,r3,8112f11c <_strtod_r+0x15d4>
8112f048:	8c5ffc2c 	andhi	r17,r17,32752
8112f04c:	00800434 	movhi	r2,16
8112f050:	002b883a 	mov	r21,zero
8112f054:	88ad883a 	add	r22,r17,r2
8112f058:	003f8806 	br	8112ee7c <__reset+0xfb10ee7c>
8112f05c:	01401a84 	movi	r5,106
8112f060:	d9400915 	stw	r5,36(sp)
8112f064:	8ddffc2c 	andhi	r23,r17,32752
8112f068:	b82ed53a 	srli	r23,r23,20
8112f06c:	00801ac4 	movi	r2,107
8112f070:	15c5c83a 	sub	r2,r2,r23
8112f074:	00be8e0e 	bge	zero,r2,8112eab0 <__reset+0xfb10eab0>
8112f078:	00c007c4 	movi	r3,31
8112f07c:	18800a0e 	bge	r3,r2,8112f0a8 <_strtod_r+0x1560>
8112f080:	00c00d04 	movi	r3,52
8112f084:	0025883a 	mov	r18,zero
8112f088:	1880270e 	bge	r3,r2,8112f128 <_strtod_r+0x15e0>
8112f08c:	0440dc34 	movhi	r17,880
8112f090:	003e8706 	br	8112eab0 <__reset+0xfb10eab0>
8112f094:	d8000915 	stw	zero,36(sp)
8112f098:	05fe6a16 	blt	zero,r23,8112ea44 <__reset+0xfb10ea44>
8112f09c:	003e8406 	br	8112eab0 <__reset+0xfb10eab0>
8112f0a0:	00bfffc4 	movi	r2,-1
8112f0a4:	003fe406 	br	8112f038 <__reset+0xfb10f038>
8112f0a8:	00ffffc4 	movi	r3,-1
8112f0ac:	1884983a 	sll	r2,r3,r2
8112f0b0:	14a4703a 	and	r18,r2,r18
8112f0b4:	003e7e06 	br	8112eab0 <__reset+0xfb10eab0>
8112f0b8:	00bffc34 	movhi	r2,65520
8112f0bc:	b8af883a 	add	r23,r23,r2
8112f0c0:	057fffc4 	movi	r21,-1
8112f0c4:	00800434 	movhi	r2,16
8112f0c8:	1545883a 	add	r2,r2,r21
8112f0cc:	b8acb03a 	or	r22,r23,r2
8112f0d0:	003f6a06 	br	8112ee7c <__reset+0xfb10ee7c>
8112f0d4:	01604574 	movhi	r5,33045
8112f0d8:	29417f04 	addi	r5,r5,1532
8112f0dc:	d9800204 	addi	r6,sp,8
8112f0e0:	d9000604 	addi	r4,sp,24
8112f0e4:	11334d40 	call	811334d4 <__hexnan>
8112f0e8:	00c00144 	movi	r3,5
8112f0ec:	10fb5c1e 	bne	r2,r3,8112de60 <__reset+0xfb10de60>
8112f0f0:	dc400317 	ldw	r17,12(sp)
8112f0f4:	dc800217 	ldw	r18,8(sp)
8112f0f8:	8c5ffc34 	orhi	r17,r17,32752
8112f0fc:	003b5a06 	br	8112de68 <__reset+0xfb10de68>
8112f100:	480b883a 	mov	r5,r9
8112f104:	d9800617 	ldw	r6,24(sp)
8112f108:	4a400044 	addi	r9,r9,1
8112f10c:	003eeb06 	br	8112ecbc <__reset+0xfb10ecbc>
8112f110:	1025883a 	mov	r18,r2
8112f114:	1823883a 	mov	r17,r3
8112f118:	003c4c06 	br	8112e24c <__reset+0xfb10e24c>
8112f11c:	00ffffc4 	movi	r3,-1
8112f120:	10ffc91e 	bne	r2,r3,8112f048 <__reset+0xfb10f048>
8112f124:	003da906 	br	8112e7cc <__reset+0xfb10e7cc>
8112f128:	10bff804 	addi	r2,r2,-32
8112f12c:	00ffffc4 	movi	r3,-1
8112f130:	1884983a 	sll	r2,r3,r2
8112f134:	1462703a 	and	r17,r2,r17
8112f138:	003e5d06 	br	8112eab0 <__reset+0xfb10eab0>
8112f13c:	1025883a 	mov	r18,r2
8112f140:	1823883a 	mov	r17,r3
8112f144:	003e5806 	br	8112eaa8 <__reset+0xfb10eaa8>

8112f148 <strtod>:
8112f148:	00a04574 	movhi	r2,33045
8112f14c:	108ad804 	addi	r2,r2,11104
8112f150:	280d883a 	mov	r6,r5
8112f154:	200b883a 	mov	r5,r4
8112f158:	11000017 	ldw	r4,0(r2)
8112f15c:	112db481 	jmpi	8112db48 <_strtod_r>

8112f160 <strtof>:
8112f160:	defffb04 	addi	sp,sp,-20
8112f164:	de00012e 	bgeu	sp,et,8112f16c <strtof+0xc>
8112f168:	003b68fa 	trap	3
8112f16c:	dcc00315 	stw	r19,12(sp)
8112f170:	04e04574 	movhi	r19,33045
8112f174:	9ccad804 	addi	r19,r19,11104
8112f178:	280d883a 	mov	r6,r5
8112f17c:	200b883a 	mov	r5,r4
8112f180:	99000017 	ldw	r4,0(r19)
8112f184:	dfc00415 	stw	ra,16(sp)
8112f188:	dc800215 	stw	r18,8(sp)
8112f18c:	dc400115 	stw	r17,4(sp)
8112f190:	dc000015 	stw	r16,0(sp)
8112f194:	112db480 	call	8112db48 <_strtod_r>
8112f198:	1009883a 	mov	r4,r2
8112f19c:	180b883a 	mov	r5,r3
8112f1a0:	1025883a 	mov	r18,r2
8112f1a4:	1823883a 	mov	r17,r3
8112f1a8:	1120c3c0 	call	81120c3c <__truncdfsf2>
8112f1ac:	000b883a 	mov	r5,zero
8112f1b0:	1009883a 	mov	r4,r2
8112f1b4:	1021883a 	mov	r16,r2
8112f1b8:	113467c0 	call	8113467c <__eqsf2>
8112f1bc:	1000111e 	bne	r2,zero,8112f204 <strtof+0xa4>
8112f1c0:	000d883a 	mov	r6,zero
8112f1c4:	000f883a 	mov	r7,zero
8112f1c8:	9009883a 	mov	r4,r18
8112f1cc:	880b883a 	mov	r5,r17
8112f1d0:	1135a1c0 	call	81135a1c <__eqdf2>
8112f1d4:	10000b26 	beq	r2,zero,8112f204 <strtof+0xa4>
8112f1d8:	98800017 	ldw	r2,0(r19)
8112f1dc:	00c00884 	movi	r3,34
8112f1e0:	10c00015 	stw	r3,0(r2)
8112f1e4:	8005883a 	mov	r2,r16
8112f1e8:	dfc00417 	ldw	ra,16(sp)
8112f1ec:	dcc00317 	ldw	r19,12(sp)
8112f1f0:	dc800217 	ldw	r18,8(sp)
8112f1f4:	dc400117 	ldw	r17,4(sp)
8112f1f8:	dc000017 	ldw	r16,0(sp)
8112f1fc:	dec00504 	addi	sp,sp,20
8112f200:	f800283a 	ret
8112f204:	015fe034 	movhi	r5,32640
8112f208:	297fffc4 	addi	r5,r5,-1
8112f20c:	8009883a 	mov	r4,r16
8112f210:	11346f40 	call	811346f4 <__gesf2>
8112f214:	0080070e 	bge	zero,r2,8112f234 <strtof+0xd4>
8112f218:	01dffc34 	movhi	r7,32752
8112f21c:	39ffffc4 	addi	r7,r7,-1
8112f220:	01bfffc4 	movi	r6,-1
8112f224:	9009883a 	mov	r4,r18
8112f228:	880b883a 	mov	r5,r17
8112f22c:	111f8c00 	call	8111f8c0 <__gedf2>
8112f230:	00bfe90e 	bge	zero,r2,8112f1d8 <__reset+0xfb10f1d8>
8112f234:	017fe034 	movhi	r5,65408
8112f238:	297fffc4 	addi	r5,r5,-1
8112f23c:	8009883a 	mov	r4,r16
8112f240:	11347b00 	call	811347b0 <__lesf2>
8112f244:	103fe70e 	bge	r2,zero,8112f1e4 <__reset+0xfb10f1e4>
8112f248:	01fffc34 	movhi	r7,65520
8112f24c:	39ffffc4 	addi	r7,r7,-1
8112f250:	01bfffc4 	movi	r6,-1
8112f254:	9009883a 	mov	r4,r18
8112f258:	880b883a 	mov	r5,r17
8112f25c:	1135aa40 	call	81135aa4 <__ledf2>
8112f260:	103fdd0e 	bge	r2,zero,8112f1d8 <__reset+0xfb10f1d8>
8112f264:	003fdf06 	br	8112f1e4 <__reset+0xfb10f1e4>

8112f268 <_strtoll_r>:
8112f268:	00a04574 	movhi	r2,33045
8112f26c:	defff304 	addi	sp,sp,-52
8112f270:	108ad604 	addi	r2,r2,11096
8112f274:	de00012e 	bgeu	sp,et,8112f27c <_strtoll_r+0x14>
8112f278:	003b68fa 	trap	3
8112f27c:	dc800515 	stw	r18,20(sp)
8112f280:	14800017 	ldw	r18,0(r2)
8112f284:	dd800915 	stw	r22,36(sp)
8112f288:	dd400815 	stw	r21,32(sp)
8112f28c:	dcc00615 	stw	r19,24(sp)
8112f290:	d9000015 	stw	r4,0(sp)
8112f294:	dfc00c15 	stw	ra,48(sp)
8112f298:	df000b15 	stw	fp,44(sp)
8112f29c:	ddc00a15 	stw	r23,40(sp)
8112f2a0:	dd000715 	stw	r20,28(sp)
8112f2a4:	dc400415 	stw	r17,16(sp)
8112f2a8:	dc000315 	stw	r16,12(sp)
8112f2ac:	282d883a 	mov	r22,r5
8112f2b0:	302b883a 	mov	r21,r6
8112f2b4:	3827883a 	mov	r19,r7
8112f2b8:	2809883a 	mov	r4,r5
8112f2bc:	24000003 	ldbu	r16,0(r4)
8112f2c0:	24400044 	addi	r17,r4,1
8112f2c4:	2007883a 	mov	r3,r4
8112f2c8:	9405883a 	add	r2,r18,r16
8112f2cc:	10800043 	ldbu	r2,1(r2)
8112f2d0:	8809883a 	mov	r4,r17
8112f2d4:	1080020c 	andi	r2,r2,8
8112f2d8:	103ff81e 	bne	r2,zero,8112f2bc <__reset+0xfb10f2bc>
8112f2dc:	00800b44 	movi	r2,45
8112f2e0:	80807826 	beq	r16,r2,8112f4c4 <_strtoll_r+0x25c>
8112f2e4:	00800ac4 	movi	r2,43
8112f2e8:	80807a26 	beq	r16,r2,8112f4d4 <_strtoll_r+0x26c>
8112f2ec:	0039883a 	mov	fp,zero
8112f2f0:	98004e26 	beq	r19,zero,8112f42c <_strtoll_r+0x1c4>
8112f2f4:	00800404 	movi	r2,16
8112f2f8:	98808226 	beq	r19,r2,8112f504 <_strtoll_r+0x29c>
8112f2fc:	982fd7fa 	srai	r23,r19,31
8112f300:	9829883a 	mov	r20,r19
8112f304:	e0004f26 	beq	fp,zero,8112f444 <_strtoll_r+0x1dc>
8112f308:	0017883a 	mov	r11,zero
8112f30c:	02a00034 	movhi	r10,32768
8112f310:	5809883a 	mov	r4,r11
8112f314:	500b883a 	mov	r5,r10
8112f318:	a00d883a 	mov	r6,r20
8112f31c:	b80f883a 	mov	r7,r23
8112f320:	da800215 	stw	r10,8(sp)
8112f324:	dac00115 	stw	r11,4(sp)
8112f328:	1133f880 	call	81133f88 <__umoddi3>
8112f32c:	dac00117 	ldw	r11,4(sp)
8112f330:	da800217 	ldw	r10,8(sp)
8112f334:	a00d883a 	mov	r6,r20
8112f338:	5809883a 	mov	r4,r11
8112f33c:	500b883a 	mov	r5,r10
8112f340:	b80f883a 	mov	r7,r23
8112f344:	d8800115 	stw	r2,4(sp)
8112f348:	1133a080 	call	81133a08 <__udivdi3>
8112f34c:	9409883a 	add	r4,r18,r16
8112f350:	21000043 	ldbu	r4,1(r4)
8112f354:	1019883a 	mov	r12,r2
8112f358:	880b883a 	mov	r5,r17
8112f35c:	2240010c 	andi	r9,r4,4
8112f360:	0015883a 	mov	r10,zero
8112f364:	000d883a 	mov	r6,zero
8112f368:	000f883a 	mov	r7,zero
8112f36c:	03400044 	movi	r13,1
8112f370:	02ffffc4 	movi	r11,-1
8112f374:	da000117 	ldw	r8,4(sp)
8112f378:	48000d26 	beq	r9,zero,8112f3b0 <_strtoll_r+0x148>
8112f37c:	843ff404 	addi	r16,r16,-48
8112f380:	84c0110e 	bge	r16,r19,8112f3c8 <_strtoll_r+0x160>
8112f384:	52c00426 	beq	r10,r11,8112f398 <_strtoll_r+0x130>
8112f388:	19c00236 	bltu	r3,r7,8112f394 <_strtoll_r+0x12c>
8112f38c:	38c0311e 	bne	r7,r3,8112f454 <_strtoll_r+0x1ec>
8112f390:	6180302e 	bgeu	r12,r6,8112f454 <_strtoll_r+0x1ec>
8112f394:	02bfffc4 	movi	r10,-1
8112f398:	2c000003 	ldbu	r16,0(r5)
8112f39c:	29400044 	addi	r5,r5,1
8112f3a0:	9409883a 	add	r4,r18,r16
8112f3a4:	21000043 	ldbu	r4,1(r4)
8112f3a8:	2240010c 	andi	r9,r4,4
8112f3ac:	483ff31e 	bne	r9,zero,8112f37c <__reset+0xfb10f37c>
8112f3b0:	210000cc 	andi	r4,r4,3
8112f3b4:	20000426 	beq	r4,zero,8112f3c8 <_strtoll_r+0x160>
8112f3b8:	23403426 	beq	r4,r13,8112f48c <_strtoll_r+0x224>
8112f3bc:	008015c4 	movi	r2,87
8112f3c0:	80a1c83a 	sub	r16,r16,r2
8112f3c4:	84ffef16 	blt	r16,r19,8112f384 <__reset+0xfb10f384>
8112f3c8:	00bfffc4 	movi	r2,-1
8112f3cc:	50803426 	beq	r10,r2,8112f4a0 <_strtoll_r+0x238>
8112f3d0:	e0000426 	beq	fp,zero,8112f3e4 <_strtoll_r+0x17c>
8112f3d4:	018dc83a 	sub	r6,zero,r6
8112f3d8:	3004c03a 	cmpne	r2,r6,zero
8112f3dc:	01e1c83a 	sub	r16,zero,r7
8112f3e0:	808fc83a 	sub	r7,r16,r2
8112f3e4:	3005883a 	mov	r2,r6
8112f3e8:	3807883a 	mov	r3,r7
8112f3ec:	a8000326 	beq	r21,zero,8112f3fc <_strtoll_r+0x194>
8112f3f0:	5000321e 	bne	r10,zero,8112f4bc <_strtoll_r+0x254>
8112f3f4:	b00b883a 	mov	r5,r22
8112f3f8:	a9400015 	stw	r5,0(r21)
8112f3fc:	dfc00c17 	ldw	ra,48(sp)
8112f400:	df000b17 	ldw	fp,44(sp)
8112f404:	ddc00a17 	ldw	r23,40(sp)
8112f408:	dd800917 	ldw	r22,36(sp)
8112f40c:	dd400817 	ldw	r21,32(sp)
8112f410:	dd000717 	ldw	r20,28(sp)
8112f414:	dcc00617 	ldw	r19,24(sp)
8112f418:	dc800517 	ldw	r18,20(sp)
8112f41c:	dc400417 	ldw	r17,16(sp)
8112f420:	dc000317 	ldw	r16,12(sp)
8112f424:	dec00d04 	addi	sp,sp,52
8112f428:	f800283a 	ret
8112f42c:	00800c04 	movi	r2,48
8112f430:	80802c26 	beq	r16,r2,8112f4e4 <_strtoll_r+0x27c>
8112f434:	05000284 	movi	r20,10
8112f438:	002f883a 	mov	r23,zero
8112f43c:	a027883a 	mov	r19,r20
8112f440:	e03fb11e 	bne	fp,zero,8112f308 <__reset+0xfb10f308>
8112f444:	02a00034 	movhi	r10,32768
8112f448:	52bfffc4 	addi	r10,r10,-1
8112f44c:	02ffffc4 	movi	r11,-1
8112f450:	003faf06 	br	8112f310 <__reset+0xfb10f310>
8112f454:	33000f26 	beq	r6,r12,8112f494 <_strtoll_r+0x22c>
8112f458:	b985383a 	mul	r2,r23,r6
8112f45c:	3d0f383a 	mul	r7,r7,r20
8112f460:	3508383a 	mulxuu	r4,r6,r20
8112f464:	350d383a 	mul	r6,r6,r20
8112f468:	8013d7fa 	srai	r9,r16,31
8112f46c:	388f883a 	add	r7,r7,r2
8112f470:	818d883a 	add	r6,r16,r6
8112f474:	390f883a 	add	r7,r7,r4
8112f478:	3421803a 	cmpltu	r16,r6,r16
8112f47c:	49cf883a 	add	r7,r9,r7
8112f480:	81cf883a 	add	r7,r16,r7
8112f484:	02800044 	movi	r10,1
8112f488:	003fc306 	br	8112f398 <__reset+0xfb10f398>
8112f48c:	00800dc4 	movi	r2,55
8112f490:	003fcb06 	br	8112f3c0 <__reset+0xfb10f3c0>
8112f494:	38fff01e 	bne	r7,r3,8112f458 <__reset+0xfb10f458>
8112f498:	443fbe16 	blt	r8,r16,8112f394 <__reset+0xfb10f394>
8112f49c:	003fee06 	br	8112f458 <__reset+0xfb10f458>
8112f4a0:	e0002426 	beq	fp,zero,8112f534 <_strtoll_r+0x2cc>
8112f4a4:	0005883a 	mov	r2,zero
8112f4a8:	00e00034 	movhi	r3,32768
8112f4ac:	d9800017 	ldw	r6,0(sp)
8112f4b0:	01000884 	movi	r4,34
8112f4b4:	31000015 	stw	r4,0(r6)
8112f4b8:	a83fd026 	beq	r21,zero,8112f3fc <__reset+0xfb10f3fc>
8112f4bc:	297fffc4 	addi	r5,r5,-1
8112f4c0:	003fcd06 	br	8112f3f8 <__reset+0xfb10f3f8>
8112f4c4:	1c400084 	addi	r17,r3,2
8112f4c8:	1c000043 	ldbu	r16,1(r3)
8112f4cc:	07000044 	movi	fp,1
8112f4d0:	003f8706 	br	8112f2f0 <__reset+0xfb10f2f0>
8112f4d4:	1c400084 	addi	r17,r3,2
8112f4d8:	1c000043 	ldbu	r16,1(r3)
8112f4dc:	0039883a 	mov	fp,zero
8112f4e0:	003f8306 	br	8112f2f0 <__reset+0xfb10f2f0>
8112f4e4:	88800003 	ldbu	r2,0(r17)
8112f4e8:	00c01604 	movi	r3,88
8112f4ec:	108037cc 	andi	r2,r2,223
8112f4f0:	10c00a26 	beq	r2,r3,8112f51c <_strtoll_r+0x2b4>
8112f4f4:	05000204 	movi	r20,8
8112f4f8:	002f883a 	mov	r23,zero
8112f4fc:	a027883a 	mov	r19,r20
8112f500:	003f8006 	br	8112f304 <__reset+0xfb10f304>
8112f504:	00800c04 	movi	r2,48
8112f508:	80800e1e 	bne	r16,r2,8112f544 <_strtoll_r+0x2dc>
8112f50c:	88800003 	ldbu	r2,0(r17)
8112f510:	00c01604 	movi	r3,88
8112f514:	108037cc 	andi	r2,r2,223
8112f518:	10c00a1e 	bne	r2,r3,8112f544 <_strtoll_r+0x2dc>
8112f51c:	05000404 	movi	r20,16
8112f520:	8c000043 	ldbu	r16,1(r17)
8112f524:	002f883a 	mov	r23,zero
8112f528:	8c400084 	addi	r17,r17,2
8112f52c:	a027883a 	mov	r19,r20
8112f530:	003f7406 	br	8112f304 <__reset+0xfb10f304>
8112f534:	00e00034 	movhi	r3,32768
8112f538:	18ffffc4 	addi	r3,r3,-1
8112f53c:	5005883a 	mov	r2,r10
8112f540:	003fda06 	br	8112f4ac <__reset+0xfb10f4ac>
8112f544:	9829883a 	mov	r20,r19
8112f548:	002f883a 	mov	r23,zero
8112f54c:	003f6d06 	br	8112f304 <__reset+0xfb10f304>

8112f550 <_strtoul_r>:
8112f550:	00a04574 	movhi	r2,33045
8112f554:	defff604 	addi	sp,sp,-40
8112f558:	108ad604 	addi	r2,r2,11096
8112f55c:	de00012e 	bgeu	sp,et,8112f564 <_strtoul_r+0x14>
8112f560:	003b68fa 	trap	3
8112f564:	dc800315 	stw	r18,12(sp)
8112f568:	14800017 	ldw	r18,0(r2)
8112f56c:	dd400615 	stw	r21,24(sp)
8112f570:	dd000515 	stw	r20,20(sp)
8112f574:	dcc00415 	stw	r19,16(sp)
8112f578:	2029883a 	mov	r20,r4
8112f57c:	dfc00915 	stw	ra,36(sp)
8112f580:	ddc00815 	stw	r23,32(sp)
8112f584:	dd800715 	stw	r22,28(sp)
8112f588:	dc400215 	stw	r17,8(sp)
8112f58c:	dc000115 	stw	r16,4(sp)
8112f590:	2827883a 	mov	r19,r5
8112f594:	382b883a 	mov	r21,r7
8112f598:	2809883a 	mov	r4,r5
8112f59c:	24000003 	ldbu	r16,0(r4)
8112f5a0:	24400044 	addi	r17,r4,1
8112f5a4:	2007883a 	mov	r3,r4
8112f5a8:	9405883a 	add	r2,r18,r16
8112f5ac:	10800043 	ldbu	r2,1(r2)
8112f5b0:	8809883a 	mov	r4,r17
8112f5b4:	1080020c 	andi	r2,r2,8
8112f5b8:	103ff81e 	bne	r2,zero,8112f59c <__reset+0xfb10f59c>
8112f5bc:	00800b44 	movi	r2,45
8112f5c0:	80805326 	beq	r16,r2,8112f710 <_strtoul_r+0x1c0>
8112f5c4:	00800ac4 	movi	r2,43
8112f5c8:	80805526 	beq	r16,r2,8112f720 <_strtoul_r+0x1d0>
8112f5cc:	002f883a 	mov	r23,zero
8112f5d0:	a8000f26 	beq	r21,zero,8112f610 <_strtoul_r+0xc0>
8112f5d4:	00800404 	movi	r2,16
8112f5d8:	a8805f26 	beq	r21,r2,8112f758 <_strtoul_r+0x208>
8112f5dc:	013fffc4 	movi	r4,-1
8112f5e0:	a80b883a 	mov	r5,r21
8112f5e4:	d9800015 	stw	r6,0(sp)
8112f5e8:	11345c00 	call	811345c0 <__udivsi3>
8112f5ec:	a80b883a 	mov	r5,r21
8112f5f0:	013fffc4 	movi	r4,-1
8112f5f4:	102d883a 	mov	r22,r2
8112f5f8:	11346240 	call	81134624 <__umodsi3>
8112f5fc:	d9800017 	ldw	r6,0(sp)
8112f600:	1019883a 	mov	r12,r2
8112f604:	a817883a 	mov	r11,r21
8112f608:	b00f883a 	mov	r7,r22
8112f60c:	00000706 	br	8112f62c <_strtoul_r+0xdc>
8112f610:	00800c04 	movi	r2,48
8112f614:	80804626 	beq	r16,r2,8112f730 <_strtoul_r+0x1e0>
8112f618:	05400284 	movi	r21,10
8112f61c:	01c666b4 	movhi	r7,6554
8112f620:	03000144 	movi	r12,5
8112f624:	39e66644 	addi	r7,r7,-26215
8112f628:	a817883a 	mov	r11,r21
8112f62c:	9407883a 	add	r3,r18,r16
8112f630:	18c00043 	ldbu	r3,1(r3)
8112f634:	8809883a 	mov	r4,r17
8112f638:	0011883a 	mov	r8,zero
8112f63c:	1940010c 	andi	r5,r3,4
8112f640:	0005883a 	mov	r2,zero
8112f644:	02800044 	movi	r10,1
8112f648:	027fffc4 	movi	r9,-1
8112f64c:	28000e26 	beq	r5,zero,8112f688 <_strtoul_r+0x138>
8112f650:	843ff404 	addi	r16,r16,-48
8112f654:	8540120e 	bge	r16,r21,8112f6a0 <_strtoul_r+0x150>
8112f658:	42400526 	beq	r8,r9,8112f670 <_strtoul_r+0x120>
8112f65c:	38802236 	bltu	r7,r2,8112f6e8 <_strtoul_r+0x198>
8112f660:	11c02026 	beq	r2,r7,8112f6e4 <_strtoul_r+0x194>
8112f664:	12c5383a 	mul	r2,r2,r11
8112f668:	02000044 	movi	r8,1
8112f66c:	8085883a 	add	r2,r16,r2
8112f670:	24000003 	ldbu	r16,0(r4)
8112f674:	21000044 	addi	r4,r4,1
8112f678:	9407883a 	add	r3,r18,r16
8112f67c:	18c00043 	ldbu	r3,1(r3)
8112f680:	1940010c 	andi	r5,r3,4
8112f684:	283ff21e 	bne	r5,zero,8112f650 <__reset+0xfb10f650>
8112f688:	18c000cc 	andi	r3,r3,3
8112f68c:	18000426 	beq	r3,zero,8112f6a0 <_strtoul_r+0x150>
8112f690:	1a801726 	beq	r3,r10,8112f6f0 <_strtoul_r+0x1a0>
8112f694:	00c015c4 	movi	r3,87
8112f698:	80e1c83a 	sub	r16,r16,r3
8112f69c:	857fee16 	blt	r16,r21,8112f658 <__reset+0xfb10f658>
8112f6a0:	40001516 	blt	r8,zero,8112f6f8 <_strtoul_r+0x1a8>
8112f6a4:	b8000126 	beq	r23,zero,8112f6ac <_strtoul_r+0x15c>
8112f6a8:	0085c83a 	sub	r2,zero,r2
8112f6ac:	30000226 	beq	r6,zero,8112f6b8 <_strtoul_r+0x168>
8112f6b0:	4000151e 	bne	r8,zero,8112f708 <_strtoul_r+0x1b8>
8112f6b4:	34c00015 	stw	r19,0(r6)
8112f6b8:	dfc00917 	ldw	ra,36(sp)
8112f6bc:	ddc00817 	ldw	r23,32(sp)
8112f6c0:	dd800717 	ldw	r22,28(sp)
8112f6c4:	dd400617 	ldw	r21,24(sp)
8112f6c8:	dd000517 	ldw	r20,20(sp)
8112f6cc:	dcc00417 	ldw	r19,16(sp)
8112f6d0:	dc800317 	ldw	r18,12(sp)
8112f6d4:	dc400217 	ldw	r17,8(sp)
8112f6d8:	dc000117 	ldw	r16,4(sp)
8112f6dc:	dec00a04 	addi	sp,sp,40
8112f6e0:	f800283a 	ret
8112f6e4:	643fdf0e 	bge	r12,r16,8112f664 <__reset+0xfb10f664>
8112f6e8:	023fffc4 	movi	r8,-1
8112f6ec:	003fe006 	br	8112f670 <__reset+0xfb10f670>
8112f6f0:	00c00dc4 	movi	r3,55
8112f6f4:	003fe806 	br	8112f698 <__reset+0xfb10f698>
8112f6f8:	00800884 	movi	r2,34
8112f6fc:	a0800015 	stw	r2,0(r20)
8112f700:	00bfffc4 	movi	r2,-1
8112f704:	303fec26 	beq	r6,zero,8112f6b8 <__reset+0xfb10f6b8>
8112f708:	24ffffc4 	addi	r19,r4,-1
8112f70c:	003fe906 	br	8112f6b4 <__reset+0xfb10f6b4>
8112f710:	1c400084 	addi	r17,r3,2
8112f714:	1c000043 	ldbu	r16,1(r3)
8112f718:	05c00044 	movi	r23,1
8112f71c:	003fac06 	br	8112f5d0 <__reset+0xfb10f5d0>
8112f720:	1c400084 	addi	r17,r3,2
8112f724:	1c000043 	ldbu	r16,1(r3)
8112f728:	002f883a 	mov	r23,zero
8112f72c:	003fa806 	br	8112f5d0 <__reset+0xfb10f5d0>
8112f730:	88800003 	ldbu	r2,0(r17)
8112f734:	00c01604 	movi	r3,88
8112f738:	108037cc 	andi	r2,r2,223
8112f73c:	10c00c26 	beq	r2,r3,8112f770 <_strtoul_r+0x220>
8112f740:	05400204 	movi	r21,8
8112f744:	01c80034 	movhi	r7,8192
8112f748:	030001c4 	movi	r12,7
8112f74c:	39ffffc4 	addi	r7,r7,-1
8112f750:	a817883a 	mov	r11,r21
8112f754:	003fb506 	br	8112f62c <__reset+0xfb10f62c>
8112f758:	00800c04 	movi	r2,48
8112f75c:	80800c1e 	bne	r16,r2,8112f790 <_strtoul_r+0x240>
8112f760:	88800003 	ldbu	r2,0(r17)
8112f764:	00c01604 	movi	r3,88
8112f768:	108037cc 	andi	r2,r2,223
8112f76c:	10c0081e 	bne	r2,r3,8112f790 <_strtoul_r+0x240>
8112f770:	02c00404 	movi	r11,16
8112f774:	05840034 	movhi	r22,4096
8112f778:	8c000043 	ldbu	r16,1(r17)
8112f77c:	030003c4 	movi	r12,15
8112f780:	8c400084 	addi	r17,r17,2
8112f784:	b5bfffc4 	addi	r22,r22,-1
8112f788:	582b883a 	mov	r21,r11
8112f78c:	003f9e06 	br	8112f608 <__reset+0xfb10f608>
8112f790:	01c40034 	movhi	r7,4096
8112f794:	030003c4 	movi	r12,15
8112f798:	39ffffc4 	addi	r7,r7,-1
8112f79c:	a817883a 	mov	r11,r21
8112f7a0:	003fa206 	br	8112f62c <__reset+0xfb10f62c>

8112f7a4 <strtoul>:
8112f7a4:	00a04574 	movhi	r2,33045
8112f7a8:	108ad804 	addi	r2,r2,11104
8112f7ac:	300f883a 	mov	r7,r6
8112f7b0:	280d883a 	mov	r6,r5
8112f7b4:	200b883a 	mov	r5,r4
8112f7b8:	11000017 	ldw	r4,0(r2)
8112f7bc:	112f5501 	jmpi	8112f550 <_strtoul_r>

8112f7c0 <_strtoull_r>:
8112f7c0:	00a04574 	movhi	r2,33045
8112f7c4:	defff404 	addi	sp,sp,-48
8112f7c8:	108ad604 	addi	r2,r2,11096
8112f7cc:	de00012e 	bgeu	sp,et,8112f7d4 <_strtoull_r+0x14>
8112f7d0:	003b68fa 	trap	3
8112f7d4:	dc400315 	stw	r17,12(sp)
8112f7d8:	14400017 	ldw	r17,0(r2)
8112f7dc:	dd400715 	stw	r21,28(sp)
8112f7e0:	dd000615 	stw	r20,24(sp)
8112f7e4:	dcc00515 	stw	r19,20(sp)
8112f7e8:	dc800415 	stw	r18,16(sp)
8112f7ec:	dfc00b15 	stw	ra,44(sp)
8112f7f0:	df000a15 	stw	fp,40(sp)
8112f7f4:	ddc00915 	stw	r23,36(sp)
8112f7f8:	dd800815 	stw	r22,32(sp)
8112f7fc:	dc000215 	stw	r16,8(sp)
8112f800:	2827883a 	mov	r19,r5
8112f804:	202b883a 	mov	r21,r4
8112f808:	3029883a 	mov	r20,r6
8112f80c:	3825883a 	mov	r18,r7
8112f810:	2807883a 	mov	r3,r5
8112f814:	1c000003 	ldbu	r16,0(r3)
8112f818:	1f000044 	addi	fp,r3,1
8112f81c:	1809883a 	mov	r4,r3
8112f820:	8c05883a 	add	r2,r17,r16
8112f824:	10800043 	ldbu	r2,1(r2)
8112f828:	e007883a 	mov	r3,fp
8112f82c:	1080020c 	andi	r2,r2,8
8112f830:	103ff81e 	bne	r2,zero,8112f814 <__reset+0xfb10f814>
8112f834:	00800b44 	movi	r2,45
8112f838:	80806e26 	beq	r16,r2,8112f9f4 <_strtoull_r+0x234>
8112f83c:	00800ac4 	movi	r2,43
8112f840:	80807026 	beq	r16,r2,8112fa04 <_strtoull_r+0x244>
8112f844:	002f883a 	mov	r23,zero
8112f848:	90001426 	beq	r18,zero,8112f89c <_strtoull_r+0xdc>
8112f84c:	00800404 	movi	r2,16
8112f850:	90807c26 	beq	r18,r2,8112fa44 <_strtoull_r+0x284>
8112f854:	902dd7fa 	srai	r22,r18,31
8112f858:	013fffc4 	movi	r4,-1
8112f85c:	200b883a 	mov	r5,r4
8112f860:	900d883a 	mov	r6,r18
8112f864:	b00f883a 	mov	r7,r22
8112f868:	1133a080 	call	81133a08 <__udivdi3>
8112f86c:	013fffc4 	movi	r4,-1
8112f870:	900d883a 	mov	r6,r18
8112f874:	b00f883a 	mov	r7,r22
8112f878:	200b883a 	mov	r5,r4
8112f87c:	d8c00115 	stw	r3,4(sp)
8112f880:	d8800015 	stw	r2,0(sp)
8112f884:	1133f880 	call	81133f88 <__umoddi3>
8112f888:	101b883a 	mov	r13,r2
8112f88c:	9015883a 	mov	r10,r18
8112f890:	dac00017 	ldw	r11,0(sp)
8112f894:	da000117 	ldw	r8,4(sp)
8112f898:	00000a06 	br	8112f8c4 <_strtoull_r+0x104>
8112f89c:	00800c04 	movi	r2,48
8112f8a0:	80805c26 	beq	r16,r2,8112fa14 <_strtoull_r+0x254>
8112f8a4:	02800284 	movi	r10,10
8112f8a8:	02e666b4 	movhi	r11,39322
8112f8ac:	020666b4 	movhi	r8,6554
8112f8b0:	03400144 	movi	r13,5
8112f8b4:	5ae66644 	addi	r11,r11,-26215
8112f8b8:	42266644 	addi	r8,r8,-26215
8112f8bc:	002d883a 	mov	r22,zero
8112f8c0:	5025883a 	mov	r18,r10
8112f8c4:	8c0b883a 	add	r5,r17,r16
8112f8c8:	29400043 	ldbu	r5,1(r5)
8112f8cc:	e009883a 	mov	r4,fp
8112f8d0:	000f883a 	mov	r7,zero
8112f8d4:	2980010c 	andi	r6,r5,4
8112f8d8:	0005883a 	mov	r2,zero
8112f8dc:	0007883a 	mov	r3,zero
8112f8e0:	03000044 	movi	r12,1
8112f8e4:	027fffc4 	movi	r9,-1
8112f8e8:	30000d26 	beq	r6,zero,8112f920 <_strtoull_r+0x160>
8112f8ec:	843ff404 	addi	r16,r16,-48
8112f8f0:	8480110e 	bge	r16,r18,8112f938 <_strtoull_r+0x178>
8112f8f4:	3a400426 	beq	r7,r9,8112f908 <_strtoull_r+0x148>
8112f8f8:	40c00236 	bltu	r8,r3,8112f904 <_strtoull_r+0x144>
8112f8fc:	1a00231e 	bne	r3,r8,8112f98c <_strtoull_r+0x1cc>
8112f900:	5880222e 	bgeu	r11,r2,8112f98c <_strtoull_r+0x1cc>
8112f904:	01ffffc4 	movi	r7,-1
8112f908:	24000003 	ldbu	r16,0(r4)
8112f90c:	21000044 	addi	r4,r4,1
8112f910:	8c0b883a 	add	r5,r17,r16
8112f914:	29400043 	ldbu	r5,1(r5)
8112f918:	2980010c 	andi	r6,r5,4
8112f91c:	303ff31e 	bne	r6,zero,8112f8ec <__reset+0xfb10f8ec>
8112f920:	294000cc 	andi	r5,r5,3
8112f924:	28000426 	beq	r5,zero,8112f938 <_strtoull_r+0x178>
8112f928:	2b002626 	beq	r5,r12,8112f9c4 <_strtoull_r+0x204>
8112f92c:	014015c4 	movi	r5,87
8112f930:	8161c83a 	sub	r16,r16,r5
8112f934:	84bfef16 	blt	r16,r18,8112f8f4 <__reset+0xfb10f8f4>
8112f938:	38002716 	blt	r7,zero,8112f9d8 <_strtoull_r+0x218>
8112f93c:	b8000426 	beq	r23,zero,8112f950 <_strtoull_r+0x190>
8112f940:	0085c83a 	sub	r2,zero,r2
8112f944:	100ac03a 	cmpne	r5,r2,zero
8112f948:	00e1c83a 	sub	r16,zero,r3
8112f94c:	8147c83a 	sub	r3,r16,r5
8112f950:	a0000226 	beq	r20,zero,8112f95c <_strtoull_r+0x19c>
8112f954:	3800251e 	bne	r7,zero,8112f9ec <_strtoull_r+0x22c>
8112f958:	a4c00015 	stw	r19,0(r20)
8112f95c:	dfc00b17 	ldw	ra,44(sp)
8112f960:	df000a17 	ldw	fp,40(sp)
8112f964:	ddc00917 	ldw	r23,36(sp)
8112f968:	dd800817 	ldw	r22,32(sp)
8112f96c:	dd400717 	ldw	r21,28(sp)
8112f970:	dd000617 	ldw	r20,24(sp)
8112f974:	dcc00517 	ldw	r19,20(sp)
8112f978:	dc800417 	ldw	r18,16(sp)
8112f97c:	dc400317 	ldw	r17,12(sp)
8112f980:	dc000217 	ldw	r16,8(sp)
8112f984:	dec00c04 	addi	sp,sp,48
8112f988:	f800283a 	ret
8112f98c:	12c00f26 	beq	r2,r11,8112f9cc <_strtoull_r+0x20c>
8112f990:	b08d383a 	mul	r6,r22,r2
8112f994:	1a87383a 	mul	r3,r3,r10
8112f998:	128a383a 	mulxuu	r5,r2,r10
8112f99c:	1285383a 	mul	r2,r2,r10
8112f9a0:	800fd7fa 	srai	r7,r16,31
8112f9a4:	1987883a 	add	r3,r3,r6
8112f9a8:	8085883a 	add	r2,r16,r2
8112f9ac:	1947883a 	add	r3,r3,r5
8112f9b0:	38c7883a 	add	r3,r7,r3
8112f9b4:	1421803a 	cmpltu	r16,r2,r16
8112f9b8:	80c7883a 	add	r3,r16,r3
8112f9bc:	01c00044 	movi	r7,1
8112f9c0:	003fd106 	br	8112f908 <__reset+0xfb10f908>
8112f9c4:	01400dc4 	movi	r5,55
8112f9c8:	003fd906 	br	8112f930 <__reset+0xfb10f930>
8112f9cc:	1a3ff01e 	bne	r3,r8,8112f990 <__reset+0xfb10f990>
8112f9d0:	6c3fcc16 	blt	r13,r16,8112f904 <__reset+0xfb10f904>
8112f9d4:	003fee06 	br	8112f990 <__reset+0xfb10f990>
8112f9d8:	00800884 	movi	r2,34
8112f9dc:	a8800015 	stw	r2,0(r21)
8112f9e0:	00bfffc4 	movi	r2,-1
8112f9e4:	1007883a 	mov	r3,r2
8112f9e8:	a03fdc26 	beq	r20,zero,8112f95c <__reset+0xfb10f95c>
8112f9ec:	24ffffc4 	addi	r19,r4,-1
8112f9f0:	003fd906 	br	8112f958 <__reset+0xfb10f958>
8112f9f4:	27000084 	addi	fp,r4,2
8112f9f8:	24000043 	ldbu	r16,1(r4)
8112f9fc:	05c00044 	movi	r23,1
8112fa00:	003f9106 	br	8112f848 <__reset+0xfb10f848>
8112fa04:	27000084 	addi	fp,r4,2
8112fa08:	24000043 	ldbu	r16,1(r4)
8112fa0c:	002f883a 	mov	r23,zero
8112fa10:	003f8d06 	br	8112f848 <__reset+0xfb10f848>
8112fa14:	e0800003 	ldbu	r2,0(fp)
8112fa18:	00c01604 	movi	r3,88
8112fa1c:	108037cc 	andi	r2,r2,223
8112fa20:	10c00e26 	beq	r2,r3,8112fa5c <_strtoull_r+0x29c>
8112fa24:	02800204 	movi	r10,8
8112fa28:	02ffffc4 	movi	r11,-1
8112fa2c:	02080034 	movhi	r8,8192
8112fa30:	034001c4 	movi	r13,7
8112fa34:	42d1883a 	add	r8,r8,r11
8112fa38:	002d883a 	mov	r22,zero
8112fa3c:	5025883a 	mov	r18,r10
8112fa40:	003fa006 	br	8112f8c4 <__reset+0xfb10f8c4>
8112fa44:	00800c04 	movi	r2,48
8112fa48:	80800e1e 	bne	r16,r2,8112fa84 <_strtoull_r+0x2c4>
8112fa4c:	e0800003 	ldbu	r2,0(fp)
8112fa50:	00c01604 	movi	r3,88
8112fa54:	108037cc 	andi	r2,r2,223
8112fa58:	10c00a1e 	bne	r2,r3,8112fa84 <_strtoull_r+0x2c4>
8112fa5c:	02800404 	movi	r10,16
8112fa60:	02ffffc4 	movi	r11,-1
8112fa64:	02040034 	movhi	r8,4096
8112fa68:	e4000043 	ldbu	r16,1(fp)
8112fa6c:	034003c4 	movi	r13,15
8112fa70:	e7000084 	addi	fp,fp,2
8112fa74:	42d1883a 	add	r8,r8,r11
8112fa78:	002d883a 	mov	r22,zero
8112fa7c:	5025883a 	mov	r18,r10
8112fa80:	003f9006 	br	8112f8c4 <__reset+0xfb10f8c4>
8112fa84:	02ffffc4 	movi	r11,-1
8112fa88:	02040034 	movhi	r8,4096
8112fa8c:	034003c4 	movi	r13,15
8112fa90:	42d1883a 	add	r8,r8,r11
8112fa94:	9015883a 	mov	r10,r18
8112fa98:	002d883a 	mov	r22,zero
8112fa9c:	003f8906 	br	8112f8c4 <__reset+0xfb10f8c4>

8112faa0 <__ssprint_r>:
8112faa0:	defff604 	addi	sp,sp,-40
8112faa4:	de00012e 	bgeu	sp,et,8112faac <__ssprint_r+0xc>
8112faa8:	003b68fa 	trap	3
8112faac:	30800217 	ldw	r2,8(r6)
8112fab0:	dc800215 	stw	r18,8(sp)
8112fab4:	dfc00915 	stw	ra,36(sp)
8112fab8:	df000815 	stw	fp,32(sp)
8112fabc:	ddc00715 	stw	r23,28(sp)
8112fac0:	dd800615 	stw	r22,24(sp)
8112fac4:	dd400515 	stw	r21,20(sp)
8112fac8:	dd000415 	stw	r20,16(sp)
8112facc:	dcc00315 	stw	r19,12(sp)
8112fad0:	dc400115 	stw	r17,4(sp)
8112fad4:	dc000015 	stw	r16,0(sp)
8112fad8:	3025883a 	mov	r18,r6
8112fadc:	10005826 	beq	r2,zero,8112fc40 <__ssprint_r+0x1a0>
8112fae0:	2027883a 	mov	r19,r4
8112fae4:	35c00017 	ldw	r23,0(r6)
8112fae8:	29000017 	ldw	r4,0(r5)
8112faec:	28800217 	ldw	r2,8(r5)
8112faf0:	2823883a 	mov	r17,r5
8112faf4:	0039883a 	mov	fp,zero
8112faf8:	0021883a 	mov	r16,zero
8112fafc:	80003926 	beq	r16,zero,8112fbe4 <__ssprint_r+0x144>
8112fb00:	102b883a 	mov	r21,r2
8112fb04:	102d883a 	mov	r22,r2
8112fb08:	80803a36 	bltu	r16,r2,8112fbf4 <__ssprint_r+0x154>
8112fb0c:	88c0030b 	ldhu	r3,12(r17)
8112fb10:	1881200c 	andi	r2,r3,1152
8112fb14:	10002626 	beq	r2,zero,8112fbb0 <__ssprint_r+0x110>
8112fb18:	88800517 	ldw	r2,20(r17)
8112fb1c:	89400417 	ldw	r5,16(r17)
8112fb20:	81800044 	addi	r6,r16,1
8112fb24:	108f883a 	add	r7,r2,r2
8112fb28:	3885883a 	add	r2,r7,r2
8112fb2c:	100ed7fa 	srli	r7,r2,31
8112fb30:	216dc83a 	sub	r22,r4,r5
8112fb34:	3589883a 	add	r4,r6,r22
8112fb38:	3885883a 	add	r2,r7,r2
8112fb3c:	102bd07a 	srai	r21,r2,1
8112fb40:	a80d883a 	mov	r6,r21
8112fb44:	a900022e 	bgeu	r21,r4,8112fb50 <__ssprint_r+0xb0>
8112fb48:	202b883a 	mov	r21,r4
8112fb4c:	200d883a 	mov	r6,r4
8112fb50:	18c1000c 	andi	r3,r3,1024
8112fb54:	18002a26 	beq	r3,zero,8112fc00 <__ssprint_r+0x160>
8112fb58:	300b883a 	mov	r5,r6
8112fb5c:	9809883a 	mov	r4,r19
8112fb60:	11218400 	call	81121840 <_malloc_r>
8112fb64:	1029883a 	mov	r20,r2
8112fb68:	10002c26 	beq	r2,zero,8112fc1c <__ssprint_r+0x17c>
8112fb6c:	89400417 	ldw	r5,16(r17)
8112fb70:	b00d883a 	mov	r6,r22
8112fb74:	1009883a 	mov	r4,r2
8112fb78:	11220540 	call	81122054 <memcpy>
8112fb7c:	8880030b 	ldhu	r2,12(r17)
8112fb80:	00fedfc4 	movi	r3,-1153
8112fb84:	10c4703a 	and	r2,r2,r3
8112fb88:	10802014 	ori	r2,r2,128
8112fb8c:	8880030d 	sth	r2,12(r17)
8112fb90:	a589883a 	add	r4,r20,r22
8112fb94:	adadc83a 	sub	r22,r21,r22
8112fb98:	8d400515 	stw	r21,20(r17)
8112fb9c:	8d800215 	stw	r22,8(r17)
8112fba0:	8d000415 	stw	r20,16(r17)
8112fba4:	89000015 	stw	r4,0(r17)
8112fba8:	802b883a 	mov	r21,r16
8112fbac:	802d883a 	mov	r22,r16
8112fbb0:	b00d883a 	mov	r6,r22
8112fbb4:	e00b883a 	mov	r5,fp
8112fbb8:	112c1280 	call	8112c128 <memmove>
8112fbbc:	88800217 	ldw	r2,8(r17)
8112fbc0:	89000017 	ldw	r4,0(r17)
8112fbc4:	90c00217 	ldw	r3,8(r18)
8112fbc8:	1545c83a 	sub	r2,r2,r21
8112fbcc:	2589883a 	add	r4,r4,r22
8112fbd0:	88800215 	stw	r2,8(r17)
8112fbd4:	89000015 	stw	r4,0(r17)
8112fbd8:	1c21c83a 	sub	r16,r3,r16
8112fbdc:	94000215 	stw	r16,8(r18)
8112fbe0:	80001726 	beq	r16,zero,8112fc40 <__ssprint_r+0x1a0>
8112fbe4:	bf000017 	ldw	fp,0(r23)
8112fbe8:	bc000117 	ldw	r16,4(r23)
8112fbec:	bdc00204 	addi	r23,r23,8
8112fbf0:	003fc206 	br	8112fafc <__reset+0xfb10fafc>
8112fbf4:	802b883a 	mov	r21,r16
8112fbf8:	802d883a 	mov	r22,r16
8112fbfc:	003fec06 	br	8112fbb0 <__reset+0xfb10fbb0>
8112fc00:	9809883a 	mov	r4,r19
8112fc04:	112d3480 	call	8112d348 <_realloc_r>
8112fc08:	1029883a 	mov	r20,r2
8112fc0c:	103fe01e 	bne	r2,zero,8112fb90 <__reset+0xfb10fb90>
8112fc10:	89400417 	ldw	r5,16(r17)
8112fc14:	9809883a 	mov	r4,r19
8112fc18:	112b2b40 	call	8112b2b4 <_free_r>
8112fc1c:	88c0030b 	ldhu	r3,12(r17)
8112fc20:	00800304 	movi	r2,12
8112fc24:	98800015 	stw	r2,0(r19)
8112fc28:	18c01014 	ori	r3,r3,64
8112fc2c:	88c0030d 	sth	r3,12(r17)
8112fc30:	00bfffc4 	movi	r2,-1
8112fc34:	90000215 	stw	zero,8(r18)
8112fc38:	90000115 	stw	zero,4(r18)
8112fc3c:	00000206 	br	8112fc48 <__ssprint_r+0x1a8>
8112fc40:	90000115 	stw	zero,4(r18)
8112fc44:	0005883a 	mov	r2,zero
8112fc48:	dfc00917 	ldw	ra,36(sp)
8112fc4c:	df000817 	ldw	fp,32(sp)
8112fc50:	ddc00717 	ldw	r23,28(sp)
8112fc54:	dd800617 	ldw	r22,24(sp)
8112fc58:	dd400517 	ldw	r21,20(sp)
8112fc5c:	dd000417 	ldw	r20,16(sp)
8112fc60:	dcc00317 	ldw	r19,12(sp)
8112fc64:	dc800217 	ldw	r18,8(sp)
8112fc68:	dc400117 	ldw	r17,4(sp)
8112fc6c:	dc000017 	ldw	r16,0(sp)
8112fc70:	dec00a04 	addi	sp,sp,40
8112fc74:	f800283a 	ret

8112fc78 <___svfiprintf_internal_r>:
8112fc78:	deffc804 	addi	sp,sp,-224
8112fc7c:	de00012e 	bgeu	sp,et,8112fc84 <___svfiprintf_internal_r+0xc>
8112fc80:	003b68fa 	trap	3
8112fc84:	2880030b 	ldhu	r2,12(r5)
8112fc88:	dcc03115 	stw	r19,196(sp)
8112fc8c:	dfc03715 	stw	ra,220(sp)
8112fc90:	df003615 	stw	fp,216(sp)
8112fc94:	ddc03515 	stw	r23,212(sp)
8112fc98:	dd803415 	stw	r22,208(sp)
8112fc9c:	dd403315 	stw	r21,204(sp)
8112fca0:	dd003215 	stw	r20,200(sp)
8112fca4:	dc803015 	stw	r18,192(sp)
8112fca8:	dc402f15 	stw	r17,188(sp)
8112fcac:	dc002e15 	stw	r16,184(sp)
8112fcb0:	d9402715 	stw	r5,156(sp)
8112fcb4:	d9002a15 	stw	r4,168(sp)
8112fcb8:	1080200c 	andi	r2,r2,128
8112fcbc:	d9c02315 	stw	r7,140(sp)
8112fcc0:	3027883a 	mov	r19,r6
8112fcc4:	10000226 	beq	r2,zero,8112fcd0 <___svfiprintf_internal_r+0x58>
8112fcc8:	28800417 	ldw	r2,16(r5)
8112fccc:	10041d26 	beq	r2,zero,81130d44 <___svfiprintf_internal_r+0x10cc>
8112fcd0:	dac01a04 	addi	r11,sp,104
8112fcd4:	dac01e15 	stw	r11,120(sp)
8112fcd8:	d8801e17 	ldw	r2,120(sp)
8112fcdc:	dac019c4 	addi	r11,sp,103
8112fce0:	dd402a17 	ldw	r21,168(sp)
8112fce4:	ddc02717 	ldw	r23,156(sp)
8112fce8:	05a04574 	movhi	r22,33045
8112fcec:	05204574 	movhi	r20,33045
8112fcf0:	dac01f15 	stw	r11,124(sp)
8112fcf4:	12d7c83a 	sub	r11,r2,r11
8112fcf8:	b5819704 	addi	r22,r22,1628
8112fcfc:	a5019304 	addi	r20,r20,1612
8112fd00:	dec01a15 	stw	sp,104(sp)
8112fd04:	d8001c15 	stw	zero,112(sp)
8112fd08:	d8001b15 	stw	zero,108(sp)
8112fd0c:	d811883a 	mov	r8,sp
8112fd10:	d8002915 	stw	zero,164(sp)
8112fd14:	d8002515 	stw	zero,148(sp)
8112fd18:	dac02b15 	stw	r11,172(sp)
8112fd1c:	98800007 	ldb	r2,0(r19)
8112fd20:	1002dd26 	beq	r2,zero,81130898 <___svfiprintf_internal_r+0xc20>
8112fd24:	00c00944 	movi	r3,37
8112fd28:	9823883a 	mov	r17,r19
8112fd2c:	10c0021e 	bne	r2,r3,8112fd38 <___svfiprintf_internal_r+0xc0>
8112fd30:	00001406 	br	8112fd84 <___svfiprintf_internal_r+0x10c>
8112fd34:	10c00326 	beq	r2,r3,8112fd44 <___svfiprintf_internal_r+0xcc>
8112fd38:	8c400044 	addi	r17,r17,1
8112fd3c:	88800007 	ldb	r2,0(r17)
8112fd40:	103ffc1e 	bne	r2,zero,8112fd34 <__reset+0xfb10fd34>
8112fd44:	8ce1c83a 	sub	r16,r17,r19
8112fd48:	80000e26 	beq	r16,zero,8112fd84 <___svfiprintf_internal_r+0x10c>
8112fd4c:	d8c01c17 	ldw	r3,112(sp)
8112fd50:	d8801b17 	ldw	r2,108(sp)
8112fd54:	44c00015 	stw	r19,0(r8)
8112fd58:	1c07883a 	add	r3,r3,r16
8112fd5c:	10800044 	addi	r2,r2,1
8112fd60:	d8c01c15 	stw	r3,112(sp)
8112fd64:	44000115 	stw	r16,4(r8)
8112fd68:	d8801b15 	stw	r2,108(sp)
8112fd6c:	00c001c4 	movi	r3,7
8112fd70:	18831e16 	blt	r3,r2,811309ec <___svfiprintf_internal_r+0xd74>
8112fd74:	42000204 	addi	r8,r8,8
8112fd78:	dac02517 	ldw	r11,148(sp)
8112fd7c:	5c17883a 	add	r11,r11,r16
8112fd80:	dac02515 	stw	r11,148(sp)
8112fd84:	88800007 	ldb	r2,0(r17)
8112fd88:	1002c526 	beq	r2,zero,811308a0 <___svfiprintf_internal_r+0xc28>
8112fd8c:	88c00047 	ldb	r3,1(r17)
8112fd90:	8cc00044 	addi	r19,r17,1
8112fd94:	d8001d85 	stb	zero,118(sp)
8112fd98:	0009883a 	mov	r4,zero
8112fd9c:	000f883a 	mov	r7,zero
8112fda0:	043fffc4 	movi	r16,-1
8112fda4:	d8002415 	stw	zero,144(sp)
8112fda8:	0025883a 	mov	r18,zero
8112fdac:	01401604 	movi	r5,88
8112fdb0:	01800244 	movi	r6,9
8112fdb4:	02800a84 	movi	r10,42
8112fdb8:	02401b04 	movi	r9,108
8112fdbc:	9cc00044 	addi	r19,r19,1
8112fdc0:	18bff804 	addi	r2,r3,-32
8112fdc4:	2881dd36 	bltu	r5,r2,8113053c <___svfiprintf_internal_r+0x8c4>
8112fdc8:	100490ba 	slli	r2,r2,2
8112fdcc:	02e044f4 	movhi	r11,33043
8112fdd0:	5aff7804 	addi	r11,r11,-544
8112fdd4:	12c5883a 	add	r2,r2,r11
8112fdd8:	10800017 	ldw	r2,0(r2)
8112fddc:	1000683a 	jmp	r2
8112fde0:	8112ffdc 	xori	r4,r16,19455
8112fde4:	8113053c 	xorhi	r4,r16,19476
8112fde8:	8113053c 	xorhi	r4,r16,19476
8112fdec:	8112ffd0 	cmplti	r4,r16,19455
8112fdf0:	8113053c 	xorhi	r4,r16,19476
8112fdf4:	8113053c 	xorhi	r4,r16,19476
8112fdf8:	8113053c 	xorhi	r4,r16,19476
8112fdfc:	8113053c 	xorhi	r4,r16,19476
8112fe00:	8113053c 	xorhi	r4,r16,19476
8112fe04:	8113053c 	xorhi	r4,r16,19476
8112fe08:	8112ff44 	addi	r4,r16,19453
8112fe0c:	81130120 	cmpeqi	r4,r16,19460
8112fe10:	8113053c 	xorhi	r4,r16,19476
8112fe14:	8112ff70 	cmpltui	r4,r16,19453
8112fe18:	81130570 	cmpltui	r4,r16,19477
8112fe1c:	8113053c 	xorhi	r4,r16,19476
8112fe20:	81130564 	muli	r4,r16,19477
8112fe24:	81130504 	addi	r4,r16,19476
8112fe28:	81130504 	addi	r4,r16,19476
8112fe2c:	81130504 	addi	r4,r16,19476
8112fe30:	81130504 	addi	r4,r16,19476
8112fe34:	81130504 	addi	r4,r16,19476
8112fe38:	81130504 	addi	r4,r16,19476
8112fe3c:	81130504 	addi	r4,r16,19476
8112fe40:	81130504 	addi	r4,r16,19476
8112fe44:	81130504 	addi	r4,r16,19476
8112fe48:	8113053c 	xorhi	r4,r16,19476
8112fe4c:	8113053c 	xorhi	r4,r16,19476
8112fe50:	8113053c 	xorhi	r4,r16,19476
8112fe54:	8113053c 	xorhi	r4,r16,19476
8112fe58:	8113053c 	xorhi	r4,r16,19476
8112fe5c:	8113053c 	xorhi	r4,r16,19476
8112fe60:	8113053c 	xorhi	r4,r16,19476
8112fe64:	8113053c 	xorhi	r4,r16,19476
8112fe68:	8113053c 	xorhi	r4,r16,19476
8112fe6c:	8113053c 	xorhi	r4,r16,19476
8112fe70:	811304a0 	cmpeqi	r4,r16,19474
8112fe74:	8113053c 	xorhi	r4,r16,19476
8112fe78:	8113053c 	xorhi	r4,r16,19476
8112fe7c:	8113053c 	xorhi	r4,r16,19476
8112fe80:	8113053c 	xorhi	r4,r16,19476
8112fe84:	8113053c 	xorhi	r4,r16,19476
8112fe88:	8113053c 	xorhi	r4,r16,19476
8112fe8c:	8113053c 	xorhi	r4,r16,19476
8112fe90:	8113053c 	xorhi	r4,r16,19476
8112fe94:	8113053c 	xorhi	r4,r16,19476
8112fe98:	8113053c 	xorhi	r4,r16,19476
8112fe9c:	81130618 	cmpnei	r4,r16,19480
8112fea0:	8113053c 	xorhi	r4,r16,19476
8112fea4:	8113053c 	xorhi	r4,r16,19476
8112fea8:	8113053c 	xorhi	r4,r16,19476
8112feac:	8113053c 	xorhi	r4,r16,19476
8112feb0:	8113053c 	xorhi	r4,r16,19476
8112feb4:	811305b0 	cmpltui	r4,r16,19478
8112feb8:	8113053c 	xorhi	r4,r16,19476
8112febc:	8113053c 	xorhi	r4,r16,19476
8112fec0:	811302e4 	muli	r4,r16,19467
8112fec4:	8113053c 	xorhi	r4,r16,19476
8112fec8:	8113053c 	xorhi	r4,r16,19476
8112fecc:	8113053c 	xorhi	r4,r16,19476
8112fed0:	8113053c 	xorhi	r4,r16,19476
8112fed4:	8113053c 	xorhi	r4,r16,19476
8112fed8:	8113053c 	xorhi	r4,r16,19476
8112fedc:	8113053c 	xorhi	r4,r16,19476
8112fee0:	8113053c 	xorhi	r4,r16,19476
8112fee4:	8113053c 	xorhi	r4,r16,19476
8112fee8:	8113053c 	xorhi	r4,r16,19476
8112feec:	811301d4 	ori	r4,r16,19463
8112fef0:	81130380 	call	88113038 <__reset+0x20f3038>
8112fef4:	8113053c 	xorhi	r4,r16,19476
8112fef8:	8113053c 	xorhi	r4,r16,19476
8112fefc:	8113053c 	xorhi	r4,r16,19476
8112ff00:	81130374 	orhi	r4,r16,19469
8112ff04:	81130380 	call	88113038 <__reset+0x20f3038>
8112ff08:	8113053c 	xorhi	r4,r16,19476
8112ff0c:	8113053c 	xorhi	r4,r16,19476
8112ff10:	81130364 	muli	r4,r16,19469
8112ff14:	8113053c 	xorhi	r4,r16,19476
8112ff18:	81130328 	cmpgeui	r4,r16,19468
8112ff1c:	81130130 	cmpltui	r4,r16,19460
8112ff20:	8112ff7c 	xorhi	r4,r16,19453
8112ff24:	81130494 	ori	r4,r16,19474
8112ff28:	8113053c 	xorhi	r4,r16,19476
8112ff2c:	81130448 	cmpgei	r4,r16,19473
8112ff30:	8113053c 	xorhi	r4,r16,19476
8112ff34:	811300a0 	cmpeqi	r4,r16,19458
8112ff38:	8113053c 	xorhi	r4,r16,19476
8112ff3c:	8113053c 	xorhi	r4,r16,19476
8112ff40:	8112fffc 	xorhi	r4,r16,19455
8112ff44:	dac02317 	ldw	r11,140(sp)
8112ff48:	5ac00017 	ldw	r11,0(r11)
8112ff4c:	dac02415 	stw	r11,144(sp)
8112ff50:	dac02317 	ldw	r11,140(sp)
8112ff54:	58800104 	addi	r2,r11,4
8112ff58:	dac02417 	ldw	r11,144(sp)
8112ff5c:	5802e90e 	bge	r11,zero,81130b04 <___svfiprintf_internal_r+0xe8c>
8112ff60:	dac02417 	ldw	r11,144(sp)
8112ff64:	d8802315 	stw	r2,140(sp)
8112ff68:	02d7c83a 	sub	r11,zero,r11
8112ff6c:	dac02415 	stw	r11,144(sp)
8112ff70:	94800114 	ori	r18,r18,4
8112ff74:	98c00007 	ldb	r3,0(r19)
8112ff78:	003f9006 	br	8112fdbc <__reset+0xfb10fdbc>
8112ff7c:	00800c04 	movi	r2,48
8112ff80:	dac02317 	ldw	r11,140(sp)
8112ff84:	d8801d05 	stb	r2,116(sp)
8112ff88:	00801e04 	movi	r2,120
8112ff8c:	d8801d45 	stb	r2,117(sp)
8112ff90:	d8001d85 	stb	zero,118(sp)
8112ff94:	58c00104 	addi	r3,r11,4
8112ff98:	5f000017 	ldw	fp,0(r11)
8112ff9c:	0013883a 	mov	r9,zero
8112ffa0:	90800094 	ori	r2,r18,2
8112ffa4:	80032b16 	blt	r16,zero,81130c54 <___svfiprintf_internal_r+0xfdc>
8112ffa8:	00bfdfc4 	movi	r2,-129
8112ffac:	90a4703a 	and	r18,r18,r2
8112ffb0:	d8c02315 	stw	r3,140(sp)
8112ffb4:	94800094 	ori	r18,r18,2
8112ffb8:	e002dc26 	beq	fp,zero,81130b2c <___svfiprintf_internal_r+0xeb4>
8112ffbc:	01204574 	movhi	r4,33045
8112ffc0:	21010904 	addi	r4,r4,1060
8112ffc4:	0015883a 	mov	r10,zero
8112ffc8:	d9002915 	stw	r4,164(sp)
8112ffcc:	00002306 	br	8113005c <___svfiprintf_internal_r+0x3e4>
8112ffd0:	94800054 	ori	r18,r18,1
8112ffd4:	98c00007 	ldb	r3,0(r19)
8112ffd8:	003f7806 	br	8112fdbc <__reset+0xfb10fdbc>
8112ffdc:	38803fcc 	andi	r2,r7,255
8112ffe0:	1080201c 	xori	r2,r2,128
8112ffe4:	10bfe004 	addi	r2,r2,-128
8112ffe8:	1002f31e 	bne	r2,zero,81130bb8 <___svfiprintf_internal_r+0xf40>
8112ffec:	01000044 	movi	r4,1
8112fff0:	01c00804 	movi	r7,32
8112fff4:	98c00007 	ldb	r3,0(r19)
8112fff8:	003f7006 	br	8112fdbc <__reset+0xfb10fdbc>
8112fffc:	21003fcc 	andi	r4,r4,255
81130000:	2003aa1e 	bne	r4,zero,81130eac <___svfiprintf_internal_r+0x1234>
81130004:	00a04574 	movhi	r2,33045
81130008:	10810904 	addi	r2,r2,1060
8113000c:	d8802915 	stw	r2,164(sp)
81130010:	9080080c 	andi	r2,r18,32
81130014:	1000ba26 	beq	r2,zero,81130300 <___svfiprintf_internal_r+0x688>
81130018:	dac02317 	ldw	r11,140(sp)
8113001c:	5f000017 	ldw	fp,0(r11)
81130020:	5a400117 	ldw	r9,4(r11)
81130024:	5ac00204 	addi	r11,r11,8
81130028:	dac02315 	stw	r11,140(sp)
8113002c:	9080004c 	andi	r2,r18,1
81130030:	10029026 	beq	r2,zero,81130a74 <___svfiprintf_internal_r+0xdfc>
81130034:	e244b03a 	or	r2,fp,r9
81130038:	1002d41e 	bne	r2,zero,81130b8c <___svfiprintf_internal_r+0xf14>
8113003c:	d8001d85 	stb	zero,118(sp)
81130040:	80030b16 	blt	r16,zero,81130c70 <___svfiprintf_internal_r+0xff8>
81130044:	00bfdfc4 	movi	r2,-129
81130048:	90a4703a 	and	r18,r18,r2
8113004c:	0015883a 	mov	r10,zero
81130050:	80002426 	beq	r16,zero,811300e4 <___svfiprintf_internal_r+0x46c>
81130054:	0039883a 	mov	fp,zero
81130058:	0013883a 	mov	r9,zero
8113005c:	d9002917 	ldw	r4,164(sp)
81130060:	dc401a04 	addi	r17,sp,104
81130064:	e08003cc 	andi	r2,fp,15
81130068:	4806973a 	slli	r3,r9,28
8113006c:	2085883a 	add	r2,r4,r2
81130070:	e038d13a 	srli	fp,fp,4
81130074:	10800003 	ldbu	r2,0(r2)
81130078:	4812d13a 	srli	r9,r9,4
8113007c:	8c7fffc4 	addi	r17,r17,-1
81130080:	1f38b03a 	or	fp,r3,fp
81130084:	88800005 	stb	r2,0(r17)
81130088:	e244b03a 	or	r2,fp,r9
8113008c:	103ff51e 	bne	r2,zero,81130064 <__reset+0xfb110064>
81130090:	dac01e17 	ldw	r11,120(sp)
81130094:	5c57c83a 	sub	r11,r11,r17
81130098:	dac02115 	stw	r11,132(sp)
8113009c:	00001406 	br	811300f0 <___svfiprintf_internal_r+0x478>
811300a0:	21003fcc 	andi	r4,r4,255
811300a4:	2003741e 	bne	r4,zero,81130e78 <___svfiprintf_internal_r+0x1200>
811300a8:	9080080c 	andi	r2,r18,32
811300ac:	10014526 	beq	r2,zero,811305c4 <___svfiprintf_internal_r+0x94c>
811300b0:	dac02317 	ldw	r11,140(sp)
811300b4:	d8001d85 	stb	zero,118(sp)
811300b8:	58c00204 	addi	r3,r11,8
811300bc:	5f000017 	ldw	fp,0(r11)
811300c0:	5a400117 	ldw	r9,4(r11)
811300c4:	8002d916 	blt	r16,zero,81130c2c <___svfiprintf_internal_r+0xfb4>
811300c8:	013fdfc4 	movi	r4,-129
811300cc:	e244b03a 	or	r2,fp,r9
811300d0:	d8c02315 	stw	r3,140(sp)
811300d4:	9124703a 	and	r18,r18,r4
811300d8:	0015883a 	mov	r10,zero
811300dc:	1000b91e 	bne	r2,zero,811303c4 <___svfiprintf_internal_r+0x74c>
811300e0:	8002e61e 	bne	r16,zero,81130c7c <___svfiprintf_internal_r+0x1004>
811300e4:	0021883a 	mov	r16,zero
811300e8:	d8002115 	stw	zero,132(sp)
811300ec:	dc401a04 	addi	r17,sp,104
811300f0:	d8c02117 	ldw	r3,132(sp)
811300f4:	dc002015 	stw	r16,128(sp)
811300f8:	80c0010e 	bge	r16,r3,81130100 <___svfiprintf_internal_r+0x488>
811300fc:	d8c02015 	stw	r3,128(sp)
81130100:	52803fcc 	andi	r10,r10,255
81130104:	5280201c 	xori	r10,r10,128
81130108:	52bfe004 	addi	r10,r10,-128
8113010c:	50003c26 	beq	r10,zero,81130200 <___svfiprintf_internal_r+0x588>
81130110:	dac02017 	ldw	r11,128(sp)
81130114:	5ac00044 	addi	r11,r11,1
81130118:	dac02015 	stw	r11,128(sp)
8113011c:	00003806 	br	81130200 <___svfiprintf_internal_r+0x588>
81130120:	01000044 	movi	r4,1
81130124:	01c00ac4 	movi	r7,43
81130128:	98c00007 	ldb	r3,0(r19)
8113012c:	003f2306 	br	8112fdbc <__reset+0xfb10fdbc>
81130130:	21003fcc 	andi	r4,r4,255
81130134:	2003481e 	bne	r4,zero,81130e58 <___svfiprintf_internal_r+0x11e0>
81130138:	9080080c 	andi	r2,r18,32
8113013c:	10013b26 	beq	r2,zero,8113062c <___svfiprintf_internal_r+0x9b4>
81130140:	dac02317 	ldw	r11,140(sp)
81130144:	d8001d85 	stb	zero,118(sp)
81130148:	58800204 	addi	r2,r11,8
8113014c:	5f000017 	ldw	fp,0(r11)
81130150:	5a400117 	ldw	r9,4(r11)
81130154:	8002a816 	blt	r16,zero,81130bf8 <___svfiprintf_internal_r+0xf80>
81130158:	013fdfc4 	movi	r4,-129
8113015c:	e246b03a 	or	r3,fp,r9
81130160:	d8802315 	stw	r2,140(sp)
81130164:	9124703a 	and	r18,r18,r4
81130168:	18013c26 	beq	r3,zero,8113065c <___svfiprintf_internal_r+0x9e4>
8113016c:	0015883a 	mov	r10,zero
81130170:	dc401a04 	addi	r17,sp,104
81130174:	e006d0fa 	srli	r3,fp,3
81130178:	4808977a 	slli	r4,r9,29
8113017c:	4812d0fa 	srli	r9,r9,3
81130180:	e70001cc 	andi	fp,fp,7
81130184:	e0800c04 	addi	r2,fp,48
81130188:	8c7fffc4 	addi	r17,r17,-1
8113018c:	20f8b03a 	or	fp,r4,r3
81130190:	88800005 	stb	r2,0(r17)
81130194:	e246b03a 	or	r3,fp,r9
81130198:	183ff61e 	bne	r3,zero,81130174 <__reset+0xfb110174>
8113019c:	90c0004c 	andi	r3,r18,1
811301a0:	1800a526 	beq	r3,zero,81130438 <___svfiprintf_internal_r+0x7c0>
811301a4:	10803fcc 	andi	r2,r2,255
811301a8:	1080201c 	xori	r2,r2,128
811301ac:	10bfe004 	addi	r2,r2,-128
811301b0:	00c00c04 	movi	r3,48
811301b4:	10ffb626 	beq	r2,r3,81130090 <__reset+0xfb110090>
811301b8:	88ffffc5 	stb	r3,-1(r17)
811301bc:	d8c01e17 	ldw	r3,120(sp)
811301c0:	88bfffc4 	addi	r2,r17,-1
811301c4:	1023883a 	mov	r17,r2
811301c8:	1887c83a 	sub	r3,r3,r2
811301cc:	d8c02115 	stw	r3,132(sp)
811301d0:	003fc706 	br	811300f0 <__reset+0xfb1100f0>
811301d4:	dac02317 	ldw	r11,140(sp)
811301d8:	00c00044 	movi	r3,1
811301dc:	d8c02015 	stw	r3,128(sp)
811301e0:	58800017 	ldw	r2,0(r11)
811301e4:	5ac00104 	addi	r11,r11,4
811301e8:	d8001d85 	stb	zero,118(sp)
811301ec:	d8801005 	stb	r2,64(sp)
811301f0:	dac02315 	stw	r11,140(sp)
811301f4:	d8c02115 	stw	r3,132(sp)
811301f8:	dc401004 	addi	r17,sp,64
811301fc:	0021883a 	mov	r16,zero
81130200:	90c0008c 	andi	r3,r18,2
81130204:	d8c02215 	stw	r3,136(sp)
81130208:	18000326 	beq	r3,zero,81130218 <___svfiprintf_internal_r+0x5a0>
8113020c:	dac02017 	ldw	r11,128(sp)
81130210:	5ac00084 	addi	r11,r11,2
81130214:	dac02015 	stw	r11,128(sp)
81130218:	90c0210c 	andi	r3,r18,132
8113021c:	d8c02615 	stw	r3,152(sp)
81130220:	1801131e 	bne	r3,zero,81130670 <___svfiprintf_internal_r+0x9f8>
81130224:	dac02417 	ldw	r11,144(sp)
81130228:	d8c02017 	ldw	r3,128(sp)
8113022c:	58f9c83a 	sub	fp,r11,r3
81130230:	07010f0e 	bge	zero,fp,81130670 <___svfiprintf_internal_r+0x9f8>
81130234:	02400404 	movi	r9,16
81130238:	d8c01c17 	ldw	r3,112(sp)
8113023c:	d8801b17 	ldw	r2,108(sp)
81130240:	4f02d60e 	bge	r9,fp,81130d9c <___svfiprintf_internal_r+0x1124>
81130244:	01604574 	movhi	r5,33045
81130248:	29419704 	addi	r5,r5,1628
8113024c:	d9402815 	stw	r5,160(sp)
81130250:	028001c4 	movi	r10,7
81130254:	00000306 	br	81130264 <___svfiprintf_internal_r+0x5ec>
81130258:	e73ffc04 	addi	fp,fp,-16
8113025c:	42000204 	addi	r8,r8,8
81130260:	4f00150e 	bge	r9,fp,811302b8 <___svfiprintf_internal_r+0x640>
81130264:	18c00404 	addi	r3,r3,16
81130268:	10800044 	addi	r2,r2,1
8113026c:	45800015 	stw	r22,0(r8)
81130270:	42400115 	stw	r9,4(r8)
81130274:	d8c01c15 	stw	r3,112(sp)
81130278:	d8801b15 	stw	r2,108(sp)
8113027c:	50bff60e 	bge	r10,r2,81130258 <__reset+0xfb110258>
81130280:	d9801a04 	addi	r6,sp,104
81130284:	b80b883a 	mov	r5,r23
81130288:	a809883a 	mov	r4,r21
8113028c:	da402c15 	stw	r9,176(sp)
81130290:	da802d15 	stw	r10,180(sp)
81130294:	112faa00 	call	8112faa0 <__ssprint_r>
81130298:	da402c17 	ldw	r9,176(sp)
8113029c:	da802d17 	ldw	r10,180(sp)
811302a0:	1001851e 	bne	r2,zero,811308b8 <___svfiprintf_internal_r+0xc40>
811302a4:	e73ffc04 	addi	fp,fp,-16
811302a8:	d8c01c17 	ldw	r3,112(sp)
811302ac:	d8801b17 	ldw	r2,108(sp)
811302b0:	d811883a 	mov	r8,sp
811302b4:	4f3feb16 	blt	r9,fp,81130264 <__reset+0xfb110264>
811302b8:	dac02817 	ldw	r11,160(sp)
811302bc:	e0c7883a 	add	r3,fp,r3
811302c0:	10800044 	addi	r2,r2,1
811302c4:	42c00015 	stw	r11,0(r8)
811302c8:	47000115 	stw	fp,4(r8)
811302cc:	d8c01c15 	stw	r3,112(sp)
811302d0:	d8801b15 	stw	r2,108(sp)
811302d4:	010001c4 	movi	r4,7
811302d8:	2081ee16 	blt	r4,r2,81130a94 <___svfiprintf_internal_r+0xe1c>
811302dc:	42000204 	addi	r8,r8,8
811302e0:	0000e506 	br	81130678 <___svfiprintf_internal_r+0xa00>
811302e4:	21003fcc 	andi	r4,r4,255
811302e8:	2002dd1e 	bne	r4,zero,81130e60 <___svfiprintf_internal_r+0x11e8>
811302ec:	00a04574 	movhi	r2,33045
811302f0:	10810404 	addi	r2,r2,1040
811302f4:	d8802915 	stw	r2,164(sp)
811302f8:	9080080c 	andi	r2,r18,32
811302fc:	103f461e 	bne	r2,zero,81130018 <__reset+0xfb110018>
81130300:	9080040c 	andi	r2,r18,16
81130304:	10022e1e 	bne	r2,zero,81130bc0 <___svfiprintf_internal_r+0xf48>
81130308:	9080100c 	andi	r2,r18,64
8113030c:	dac02317 	ldw	r11,140(sp)
81130310:	10027326 	beq	r2,zero,81130ce0 <___svfiprintf_internal_r+0x1068>
81130314:	5f00000b 	ldhu	fp,0(r11)
81130318:	5ac00104 	addi	r11,r11,4
8113031c:	0013883a 	mov	r9,zero
81130320:	dac02315 	stw	r11,140(sp)
81130324:	003f4106 	br	8113002c <__reset+0xfb11002c>
81130328:	21003fcc 	andi	r4,r4,255
8113032c:	2002e11e 	bne	r4,zero,81130eb4 <___svfiprintf_internal_r+0x123c>
81130330:	9080080c 	andi	r2,r18,32
81130334:	1002011e 	bne	r2,zero,81130b3c <___svfiprintf_internal_r+0xec4>
81130338:	9080040c 	andi	r2,r18,16
8113033c:	10023e1e 	bne	r2,zero,81130c38 <___svfiprintf_internal_r+0xfc0>
81130340:	9480100c 	andi	r18,r18,64
81130344:	90023c26 	beq	r18,zero,81130c38 <___svfiprintf_internal_r+0xfc0>
81130348:	dac02317 	ldw	r11,140(sp)
8113034c:	58800017 	ldw	r2,0(r11)
81130350:	5ac00104 	addi	r11,r11,4
81130354:	dac02315 	stw	r11,140(sp)
81130358:	dac02517 	ldw	r11,148(sp)
8113035c:	12c0000d 	sth	r11,0(r2)
81130360:	003e6e06 	br	8112fd1c <__reset+0xfb10fd1c>
81130364:	98c00007 	ldb	r3,0(r19)
81130368:	1a422926 	beq	r3,r9,81130c10 <___svfiprintf_internal_r+0xf98>
8113036c:	94800414 	ori	r18,r18,16
81130370:	003e9206 	br	8112fdbc <__reset+0xfb10fdbc>
81130374:	94801014 	ori	r18,r18,64
81130378:	98c00007 	ldb	r3,0(r19)
8113037c:	003e8f06 	br	8112fdbc <__reset+0xfb10fdbc>
81130380:	21003fcc 	andi	r4,r4,255
81130384:	2002c71e 	bne	r4,zero,81130ea4 <___svfiprintf_internal_r+0x122c>
81130388:	9080080c 	andi	r2,r18,32
8113038c:	10004926 	beq	r2,zero,811304b4 <___svfiprintf_internal_r+0x83c>
81130390:	dac02317 	ldw	r11,140(sp)
81130394:	58800117 	ldw	r2,4(r11)
81130398:	5f000017 	ldw	fp,0(r11)
8113039c:	5ac00204 	addi	r11,r11,8
811303a0:	dac02315 	stw	r11,140(sp)
811303a4:	1013883a 	mov	r9,r2
811303a8:	10004b16 	blt	r2,zero,811304d8 <___svfiprintf_internal_r+0x860>
811303ac:	da801d83 	ldbu	r10,118(sp)
811303b0:	8001cb16 	blt	r16,zero,81130ae0 <___svfiprintf_internal_r+0xe68>
811303b4:	00ffdfc4 	movi	r3,-129
811303b8:	e244b03a 	or	r2,fp,r9
811303bc:	90e4703a 	and	r18,r18,r3
811303c0:	103f4726 	beq	r2,zero,811300e0 <__reset+0xfb1100e0>
811303c4:	48008c26 	beq	r9,zero,811305f8 <___svfiprintf_internal_r+0x980>
811303c8:	dc802015 	stw	r18,128(sp)
811303cc:	dc002115 	stw	r16,132(sp)
811303d0:	dc401a04 	addi	r17,sp,104
811303d4:	e021883a 	mov	r16,fp
811303d8:	da002215 	stw	r8,136(sp)
811303dc:	5039883a 	mov	fp,r10
811303e0:	4825883a 	mov	r18,r9
811303e4:	8009883a 	mov	r4,r16
811303e8:	900b883a 	mov	r5,r18
811303ec:	01800284 	movi	r6,10
811303f0:	000f883a 	mov	r7,zero
811303f4:	1133f880 	call	81133f88 <__umoddi3>
811303f8:	10800c04 	addi	r2,r2,48
811303fc:	8c7fffc4 	addi	r17,r17,-1
81130400:	8009883a 	mov	r4,r16
81130404:	900b883a 	mov	r5,r18
81130408:	88800005 	stb	r2,0(r17)
8113040c:	01800284 	movi	r6,10
81130410:	000f883a 	mov	r7,zero
81130414:	1133a080 	call	81133a08 <__udivdi3>
81130418:	1021883a 	mov	r16,r2
8113041c:	10c4b03a 	or	r2,r2,r3
81130420:	1825883a 	mov	r18,r3
81130424:	103fef1e 	bne	r2,zero,811303e4 <__reset+0xfb1103e4>
81130428:	dc802017 	ldw	r18,128(sp)
8113042c:	dc002117 	ldw	r16,132(sp)
81130430:	da002217 	ldw	r8,136(sp)
81130434:	e015883a 	mov	r10,fp
81130438:	d8c01e17 	ldw	r3,120(sp)
8113043c:	1c47c83a 	sub	r3,r3,r17
81130440:	d8c02115 	stw	r3,132(sp)
81130444:	003f2a06 	br	811300f0 <__reset+0xfb1100f0>
81130448:	dac02317 	ldw	r11,140(sp)
8113044c:	d8001d85 	stb	zero,118(sp)
81130450:	5c400017 	ldw	r17,0(r11)
81130454:	5f000104 	addi	fp,r11,4
81130458:	88022f26 	beq	r17,zero,81130d18 <___svfiprintf_internal_r+0x10a0>
8113045c:	80022516 	blt	r16,zero,81130cf4 <___svfiprintf_internal_r+0x107c>
81130460:	800d883a 	mov	r6,r16
81130464:	000b883a 	mov	r5,zero
81130468:	8809883a 	mov	r4,r17
8113046c:	da002c15 	stw	r8,176(sp)
81130470:	112c0440 	call	8112c044 <memchr>
81130474:	da002c17 	ldw	r8,176(sp)
81130478:	10026426 	beq	r2,zero,81130e0c <___svfiprintf_internal_r+0x1194>
8113047c:	1445c83a 	sub	r2,r2,r17
81130480:	d8802115 	stw	r2,132(sp)
81130484:	da801d83 	ldbu	r10,118(sp)
81130488:	df002315 	stw	fp,140(sp)
8113048c:	0021883a 	mov	r16,zero
81130490:	003f1706 	br	811300f0 <__reset+0xfb1100f0>
81130494:	94800814 	ori	r18,r18,32
81130498:	98c00007 	ldb	r3,0(r19)
8113049c:	003e4706 	br	8112fdbc <__reset+0xfb10fdbc>
811304a0:	21003fcc 	andi	r4,r4,255
811304a4:	2002701e 	bne	r4,zero,81130e68 <___svfiprintf_internal_r+0x11f0>
811304a8:	94800414 	ori	r18,r18,16
811304ac:	9080080c 	andi	r2,r18,32
811304b0:	103fb71e 	bne	r2,zero,81130390 <__reset+0xfb110390>
811304b4:	9080040c 	andi	r2,r18,16
811304b8:	1001ab26 	beq	r2,zero,81130b68 <___svfiprintf_internal_r+0xef0>
811304bc:	dac02317 	ldw	r11,140(sp)
811304c0:	5f000017 	ldw	fp,0(r11)
811304c4:	5ac00104 	addi	r11,r11,4
811304c8:	dac02315 	stw	r11,140(sp)
811304cc:	e013d7fa 	srai	r9,fp,31
811304d0:	4805883a 	mov	r2,r9
811304d4:	103fb50e 	bge	r2,zero,811303ac <__reset+0xfb1103ac>
811304d8:	0739c83a 	sub	fp,zero,fp
811304dc:	02800b44 	movi	r10,45
811304e0:	e004c03a 	cmpne	r2,fp,zero
811304e4:	0253c83a 	sub	r9,zero,r9
811304e8:	da801d85 	stb	r10,118(sp)
811304ec:	4893c83a 	sub	r9,r9,r2
811304f0:	80023016 	blt	r16,zero,81130db4 <___svfiprintf_internal_r+0x113c>
811304f4:	00bfdfc4 	movi	r2,-129
811304f8:	90a4703a 	and	r18,r18,r2
811304fc:	483fb21e 	bne	r9,zero,811303c8 <__reset+0xfb1103c8>
81130500:	00003d06 	br	811305f8 <___svfiprintf_internal_r+0x980>
81130504:	9817883a 	mov	r11,r19
81130508:	d8002415 	stw	zero,144(sp)
8113050c:	18bff404 	addi	r2,r3,-48
81130510:	0019883a 	mov	r12,zero
81130514:	58c00007 	ldb	r3,0(r11)
81130518:	630002a4 	muli	r12,r12,10
8113051c:	9cc00044 	addi	r19,r19,1
81130520:	9817883a 	mov	r11,r19
81130524:	1319883a 	add	r12,r2,r12
81130528:	18bff404 	addi	r2,r3,-48
8113052c:	30bff92e 	bgeu	r6,r2,81130514 <__reset+0xfb110514>
81130530:	db002415 	stw	r12,144(sp)
81130534:	18bff804 	addi	r2,r3,-32
81130538:	28be232e 	bgeu	r5,r2,8112fdc8 <__reset+0xfb10fdc8>
8113053c:	21003fcc 	andi	r4,r4,255
81130540:	20024b1e 	bne	r4,zero,81130e70 <___svfiprintf_internal_r+0x11f8>
81130544:	1800d626 	beq	r3,zero,811308a0 <___svfiprintf_internal_r+0xc28>
81130548:	02c00044 	movi	r11,1
8113054c:	dac02015 	stw	r11,128(sp)
81130550:	d8c01005 	stb	r3,64(sp)
81130554:	d8001d85 	stb	zero,118(sp)
81130558:	dac02115 	stw	r11,132(sp)
8113055c:	dc401004 	addi	r17,sp,64
81130560:	003f2606 	br	811301fc <__reset+0xfb1101fc>
81130564:	94802014 	ori	r18,r18,128
81130568:	98c00007 	ldb	r3,0(r19)
8113056c:	003e1306 	br	8112fdbc <__reset+0xfb10fdbc>
81130570:	98c00007 	ldb	r3,0(r19)
81130574:	9ac00044 	addi	r11,r19,1
81130578:	1a822b26 	beq	r3,r10,81130e28 <___svfiprintf_internal_r+0x11b0>
8113057c:	18bff404 	addi	r2,r3,-48
81130580:	0021883a 	mov	r16,zero
81130584:	30821e36 	bltu	r6,r2,81130e00 <___svfiprintf_internal_r+0x1188>
81130588:	58c00007 	ldb	r3,0(r11)
8113058c:	840002a4 	muli	r16,r16,10
81130590:	5cc00044 	addi	r19,r11,1
81130594:	9817883a 	mov	r11,r19
81130598:	80a1883a 	add	r16,r16,r2
8113059c:	18bff404 	addi	r2,r3,-48
811305a0:	30bff92e 	bgeu	r6,r2,81130588 <__reset+0xfb110588>
811305a4:	803e060e 	bge	r16,zero,8112fdc0 <__reset+0xfb10fdc0>
811305a8:	043fffc4 	movi	r16,-1
811305ac:	003e0406 	br	8112fdc0 <__reset+0xfb10fdc0>
811305b0:	21003fcc 	andi	r4,r4,255
811305b4:	2002371e 	bne	r4,zero,81130e94 <___svfiprintf_internal_r+0x121c>
811305b8:	94800414 	ori	r18,r18,16
811305bc:	9080080c 	andi	r2,r18,32
811305c0:	103ebb1e 	bne	r2,zero,811300b0 <__reset+0xfb1100b0>
811305c4:	9080040c 	andi	r2,r18,16
811305c8:	10013b26 	beq	r2,zero,81130ab8 <___svfiprintf_internal_r+0xe40>
811305cc:	dac02317 	ldw	r11,140(sp)
811305d0:	d8001d85 	stb	zero,118(sp)
811305d4:	0013883a 	mov	r9,zero
811305d8:	58800104 	addi	r2,r11,4
811305dc:	5f000017 	ldw	fp,0(r11)
811305e0:	80013d16 	blt	r16,zero,81130ad8 <___svfiprintf_internal_r+0xe60>
811305e4:	00ffdfc4 	movi	r3,-129
811305e8:	d8802315 	stw	r2,140(sp)
811305ec:	90e4703a 	and	r18,r18,r3
811305f0:	0015883a 	mov	r10,zero
811305f4:	e03eba26 	beq	fp,zero,811300e0 <__reset+0xfb1100e0>
811305f8:	00800244 	movi	r2,9
811305fc:	173f7236 	bltu	r2,fp,811303c8 <__reset+0xfb1103c8>
81130600:	dac02b17 	ldw	r11,172(sp)
81130604:	e7000c04 	addi	fp,fp,48
81130608:	df0019c5 	stb	fp,103(sp)
8113060c:	dac02115 	stw	r11,132(sp)
81130610:	dc4019c4 	addi	r17,sp,103
81130614:	003eb606 	br	811300f0 <__reset+0xfb1100f0>
81130618:	21003fcc 	andi	r4,r4,255
8113061c:	20021f1e 	bne	r4,zero,81130e9c <___svfiprintf_internal_r+0x1224>
81130620:	94800414 	ori	r18,r18,16
81130624:	9080080c 	andi	r2,r18,32
81130628:	103ec51e 	bne	r2,zero,81130140 <__reset+0xfb110140>
8113062c:	9080040c 	andi	r2,r18,16
81130630:	10016926 	beq	r2,zero,81130bd8 <___svfiprintf_internal_r+0xf60>
81130634:	dac02317 	ldw	r11,140(sp)
81130638:	d8001d85 	stb	zero,118(sp)
8113063c:	0013883a 	mov	r9,zero
81130640:	58800104 	addi	r2,r11,4
81130644:	5f000017 	ldw	fp,0(r11)
81130648:	80016b16 	blt	r16,zero,81130bf8 <___svfiprintf_internal_r+0xf80>
8113064c:	00ffdfc4 	movi	r3,-129
81130650:	d8802315 	stw	r2,140(sp)
81130654:	90e4703a 	and	r18,r18,r3
81130658:	e03ec41e 	bne	fp,zero,8113016c <__reset+0xfb11016c>
8113065c:	0015883a 	mov	r10,zero
81130660:	8001c226 	beq	r16,zero,81130d6c <___svfiprintf_internal_r+0x10f4>
81130664:	0039883a 	mov	fp,zero
81130668:	0013883a 	mov	r9,zero
8113066c:	003ec006 	br	81130170 <__reset+0xfb110170>
81130670:	d8c01c17 	ldw	r3,112(sp)
81130674:	d8801b17 	ldw	r2,108(sp)
81130678:	d9001d87 	ldb	r4,118(sp)
8113067c:	20000b26 	beq	r4,zero,811306ac <___svfiprintf_internal_r+0xa34>
81130680:	d9001d84 	addi	r4,sp,118
81130684:	18c00044 	addi	r3,r3,1
81130688:	10800044 	addi	r2,r2,1
8113068c:	41000015 	stw	r4,0(r8)
81130690:	01000044 	movi	r4,1
81130694:	41000115 	stw	r4,4(r8)
81130698:	d8c01c15 	stw	r3,112(sp)
8113069c:	d8801b15 	stw	r2,108(sp)
811306a0:	010001c4 	movi	r4,7
811306a4:	2080e116 	blt	r4,r2,81130a2c <___svfiprintf_internal_r+0xdb4>
811306a8:	42000204 	addi	r8,r8,8
811306ac:	dac02217 	ldw	r11,136(sp)
811306b0:	58000b26 	beq	r11,zero,811306e0 <___svfiprintf_internal_r+0xa68>
811306b4:	d9001d04 	addi	r4,sp,116
811306b8:	18c00084 	addi	r3,r3,2
811306bc:	10800044 	addi	r2,r2,1
811306c0:	41000015 	stw	r4,0(r8)
811306c4:	01000084 	movi	r4,2
811306c8:	41000115 	stw	r4,4(r8)
811306cc:	d8c01c15 	stw	r3,112(sp)
811306d0:	d8801b15 	stw	r2,108(sp)
811306d4:	010001c4 	movi	r4,7
811306d8:	2080dd16 	blt	r4,r2,81130a50 <___svfiprintf_internal_r+0xdd8>
811306dc:	42000204 	addi	r8,r8,8
811306e0:	dac02617 	ldw	r11,152(sp)
811306e4:	01002004 	movi	r4,128
811306e8:	59008426 	beq	r11,r4,811308fc <___svfiprintf_internal_r+0xc84>
811306ec:	dac02117 	ldw	r11,132(sp)
811306f0:	82e1c83a 	sub	r16,r16,r11
811306f4:	0400270e 	bge	zero,r16,81130794 <___svfiprintf_internal_r+0xb1c>
811306f8:	01c00404 	movi	r7,16
811306fc:	3c016a0e 	bge	r7,r16,81130ca8 <___svfiprintf_internal_r+0x1030>
81130700:	01604574 	movhi	r5,33045
81130704:	29419304 	addi	r5,r5,1612
81130708:	d9402215 	stw	r5,136(sp)
8113070c:	070001c4 	movi	fp,7
81130710:	00000306 	br	81130720 <___svfiprintf_internal_r+0xaa8>
81130714:	843ffc04 	addi	r16,r16,-16
81130718:	42000204 	addi	r8,r8,8
8113071c:	3c00130e 	bge	r7,r16,8113076c <___svfiprintf_internal_r+0xaf4>
81130720:	18c00404 	addi	r3,r3,16
81130724:	10800044 	addi	r2,r2,1
81130728:	45000015 	stw	r20,0(r8)
8113072c:	41c00115 	stw	r7,4(r8)
81130730:	d8c01c15 	stw	r3,112(sp)
81130734:	d8801b15 	stw	r2,108(sp)
81130738:	e0bff60e 	bge	fp,r2,81130714 <__reset+0xfb110714>
8113073c:	d9801a04 	addi	r6,sp,104
81130740:	b80b883a 	mov	r5,r23
81130744:	a809883a 	mov	r4,r21
81130748:	d9c02c15 	stw	r7,176(sp)
8113074c:	112faa00 	call	8112faa0 <__ssprint_r>
81130750:	d9c02c17 	ldw	r7,176(sp)
81130754:	1000581e 	bne	r2,zero,811308b8 <___svfiprintf_internal_r+0xc40>
81130758:	843ffc04 	addi	r16,r16,-16
8113075c:	d8c01c17 	ldw	r3,112(sp)
81130760:	d8801b17 	ldw	r2,108(sp)
81130764:	d811883a 	mov	r8,sp
81130768:	3c3fed16 	blt	r7,r16,81130720 <__reset+0xfb110720>
8113076c:	dac02217 	ldw	r11,136(sp)
81130770:	1c07883a 	add	r3,r3,r16
81130774:	10800044 	addi	r2,r2,1
81130778:	42c00015 	stw	r11,0(r8)
8113077c:	44000115 	stw	r16,4(r8)
81130780:	d8c01c15 	stw	r3,112(sp)
81130784:	d8801b15 	stw	r2,108(sp)
81130788:	010001c4 	movi	r4,7
8113078c:	20809e16 	blt	r4,r2,81130a08 <___svfiprintf_internal_r+0xd90>
81130790:	42000204 	addi	r8,r8,8
81130794:	dac02117 	ldw	r11,132(sp)
81130798:	10800044 	addi	r2,r2,1
8113079c:	44400015 	stw	r17,0(r8)
811307a0:	58c7883a 	add	r3,r11,r3
811307a4:	42c00115 	stw	r11,4(r8)
811307a8:	d8c01c15 	stw	r3,112(sp)
811307ac:	d8801b15 	stw	r2,108(sp)
811307b0:	010001c4 	movi	r4,7
811307b4:	20807f16 	blt	r4,r2,811309b4 <___svfiprintf_internal_r+0xd3c>
811307b8:	42000204 	addi	r8,r8,8
811307bc:	9480010c 	andi	r18,r18,4
811307c0:	90002926 	beq	r18,zero,81130868 <___svfiprintf_internal_r+0xbf0>
811307c4:	dac02417 	ldw	r11,144(sp)
811307c8:	d8802017 	ldw	r2,128(sp)
811307cc:	58a1c83a 	sub	r16,r11,r2
811307d0:	0400250e 	bge	zero,r16,81130868 <___svfiprintf_internal_r+0xbf0>
811307d4:	04400404 	movi	r17,16
811307d8:	d8801b17 	ldw	r2,108(sp)
811307dc:	8c017c0e 	bge	r17,r16,81130dd0 <___svfiprintf_internal_r+0x1158>
811307e0:	01604574 	movhi	r5,33045
811307e4:	29419704 	addi	r5,r5,1628
811307e8:	d9402815 	stw	r5,160(sp)
811307ec:	048001c4 	movi	r18,7
811307f0:	00000306 	br	81130800 <___svfiprintf_internal_r+0xb88>
811307f4:	843ffc04 	addi	r16,r16,-16
811307f8:	42000204 	addi	r8,r8,8
811307fc:	8c00110e 	bge	r17,r16,81130844 <___svfiprintf_internal_r+0xbcc>
81130800:	18c00404 	addi	r3,r3,16
81130804:	10800044 	addi	r2,r2,1
81130808:	45800015 	stw	r22,0(r8)
8113080c:	44400115 	stw	r17,4(r8)
81130810:	d8c01c15 	stw	r3,112(sp)
81130814:	d8801b15 	stw	r2,108(sp)
81130818:	90bff60e 	bge	r18,r2,811307f4 <__reset+0xfb1107f4>
8113081c:	d9801a04 	addi	r6,sp,104
81130820:	b80b883a 	mov	r5,r23
81130824:	a809883a 	mov	r4,r21
81130828:	112faa00 	call	8112faa0 <__ssprint_r>
8113082c:	1000221e 	bne	r2,zero,811308b8 <___svfiprintf_internal_r+0xc40>
81130830:	843ffc04 	addi	r16,r16,-16
81130834:	d8c01c17 	ldw	r3,112(sp)
81130838:	d8801b17 	ldw	r2,108(sp)
8113083c:	d811883a 	mov	r8,sp
81130840:	8c3fef16 	blt	r17,r16,81130800 <__reset+0xfb110800>
81130844:	dac02817 	ldw	r11,160(sp)
81130848:	1c07883a 	add	r3,r3,r16
8113084c:	10800044 	addi	r2,r2,1
81130850:	42c00015 	stw	r11,0(r8)
81130854:	44000115 	stw	r16,4(r8)
81130858:	d8c01c15 	stw	r3,112(sp)
8113085c:	d8801b15 	stw	r2,108(sp)
81130860:	010001c4 	movi	r4,7
81130864:	2080aa16 	blt	r4,r2,81130b10 <___svfiprintf_internal_r+0xe98>
81130868:	d8802417 	ldw	r2,144(sp)
8113086c:	dac02017 	ldw	r11,128(sp)
81130870:	12c0010e 	bge	r2,r11,81130878 <___svfiprintf_internal_r+0xc00>
81130874:	5805883a 	mov	r2,r11
81130878:	dac02517 	ldw	r11,148(sp)
8113087c:	5897883a 	add	r11,r11,r2
81130880:	dac02515 	stw	r11,148(sp)
81130884:	1800531e 	bne	r3,zero,811309d4 <___svfiprintf_internal_r+0xd5c>
81130888:	98800007 	ldb	r2,0(r19)
8113088c:	d8001b15 	stw	zero,108(sp)
81130890:	d811883a 	mov	r8,sp
81130894:	103d231e 	bne	r2,zero,8112fd24 <__reset+0xfb10fd24>
81130898:	9823883a 	mov	r17,r19
8113089c:	003d3906 	br	8112fd84 <__reset+0xfb10fd84>
811308a0:	d8801c17 	ldw	r2,112(sp)
811308a4:	10000426 	beq	r2,zero,811308b8 <___svfiprintf_internal_r+0xc40>
811308a8:	d9402717 	ldw	r5,156(sp)
811308ac:	d9002a17 	ldw	r4,168(sp)
811308b0:	d9801a04 	addi	r6,sp,104
811308b4:	112faa00 	call	8112faa0 <__ssprint_r>
811308b8:	dac02717 	ldw	r11,156(sp)
811308bc:	d8802517 	ldw	r2,148(sp)
811308c0:	58c0030b 	ldhu	r3,12(r11)
811308c4:	18c0100c 	andi	r3,r3,64
811308c8:	1801381e 	bne	r3,zero,81130dac <___svfiprintf_internal_r+0x1134>
811308cc:	dfc03717 	ldw	ra,220(sp)
811308d0:	df003617 	ldw	fp,216(sp)
811308d4:	ddc03517 	ldw	r23,212(sp)
811308d8:	dd803417 	ldw	r22,208(sp)
811308dc:	dd403317 	ldw	r21,204(sp)
811308e0:	dd003217 	ldw	r20,200(sp)
811308e4:	dcc03117 	ldw	r19,196(sp)
811308e8:	dc803017 	ldw	r18,192(sp)
811308ec:	dc402f17 	ldw	r17,188(sp)
811308f0:	dc002e17 	ldw	r16,184(sp)
811308f4:	dec03804 	addi	sp,sp,224
811308f8:	f800283a 	ret
811308fc:	dac02417 	ldw	r11,144(sp)
81130900:	d9002017 	ldw	r4,128(sp)
81130904:	5939c83a 	sub	fp,r11,r4
81130908:	073f780e 	bge	zero,fp,811306ec <__reset+0xfb1106ec>
8113090c:	02400404 	movi	r9,16
81130910:	4f01370e 	bge	r9,fp,81130df0 <___svfiprintf_internal_r+0x1178>
81130914:	02e04574 	movhi	r11,33045
81130918:	5ac19304 	addi	r11,r11,1612
8113091c:	dac02215 	stw	r11,136(sp)
81130920:	028001c4 	movi	r10,7
81130924:	00000306 	br	81130934 <___svfiprintf_internal_r+0xcbc>
81130928:	e73ffc04 	addi	fp,fp,-16
8113092c:	42000204 	addi	r8,r8,8
81130930:	4f00150e 	bge	r9,fp,81130988 <___svfiprintf_internal_r+0xd10>
81130934:	18c00404 	addi	r3,r3,16
81130938:	10800044 	addi	r2,r2,1
8113093c:	45000015 	stw	r20,0(r8)
81130940:	42400115 	stw	r9,4(r8)
81130944:	d8c01c15 	stw	r3,112(sp)
81130948:	d8801b15 	stw	r2,108(sp)
8113094c:	50bff60e 	bge	r10,r2,81130928 <__reset+0xfb110928>
81130950:	d9801a04 	addi	r6,sp,104
81130954:	b80b883a 	mov	r5,r23
81130958:	a809883a 	mov	r4,r21
8113095c:	da402c15 	stw	r9,176(sp)
81130960:	da802d15 	stw	r10,180(sp)
81130964:	112faa00 	call	8112faa0 <__ssprint_r>
81130968:	da402c17 	ldw	r9,176(sp)
8113096c:	da802d17 	ldw	r10,180(sp)
81130970:	103fd11e 	bne	r2,zero,811308b8 <__reset+0xfb1108b8>
81130974:	e73ffc04 	addi	fp,fp,-16
81130978:	d8c01c17 	ldw	r3,112(sp)
8113097c:	d8801b17 	ldw	r2,108(sp)
81130980:	d811883a 	mov	r8,sp
81130984:	4f3feb16 	blt	r9,fp,81130934 <__reset+0xfb110934>
81130988:	dac02217 	ldw	r11,136(sp)
8113098c:	1f07883a 	add	r3,r3,fp
81130990:	10800044 	addi	r2,r2,1
81130994:	42c00015 	stw	r11,0(r8)
81130998:	47000115 	stw	fp,4(r8)
8113099c:	d8c01c15 	stw	r3,112(sp)
811309a0:	d8801b15 	stw	r2,108(sp)
811309a4:	010001c4 	movi	r4,7
811309a8:	2080b616 	blt	r4,r2,81130c84 <___svfiprintf_internal_r+0x100c>
811309ac:	42000204 	addi	r8,r8,8
811309b0:	003f4e06 	br	811306ec <__reset+0xfb1106ec>
811309b4:	d9801a04 	addi	r6,sp,104
811309b8:	b80b883a 	mov	r5,r23
811309bc:	a809883a 	mov	r4,r21
811309c0:	112faa00 	call	8112faa0 <__ssprint_r>
811309c4:	103fbc1e 	bne	r2,zero,811308b8 <__reset+0xfb1108b8>
811309c8:	d8c01c17 	ldw	r3,112(sp)
811309cc:	d811883a 	mov	r8,sp
811309d0:	003f7a06 	br	811307bc <__reset+0xfb1107bc>
811309d4:	d9801a04 	addi	r6,sp,104
811309d8:	b80b883a 	mov	r5,r23
811309dc:	a809883a 	mov	r4,r21
811309e0:	112faa00 	call	8112faa0 <__ssprint_r>
811309e4:	103fa826 	beq	r2,zero,81130888 <__reset+0xfb110888>
811309e8:	003fb306 	br	811308b8 <__reset+0xfb1108b8>
811309ec:	d9801a04 	addi	r6,sp,104
811309f0:	b80b883a 	mov	r5,r23
811309f4:	a809883a 	mov	r4,r21
811309f8:	112faa00 	call	8112faa0 <__ssprint_r>
811309fc:	103fae1e 	bne	r2,zero,811308b8 <__reset+0xfb1108b8>
81130a00:	d811883a 	mov	r8,sp
81130a04:	003cdc06 	br	8112fd78 <__reset+0xfb10fd78>
81130a08:	d9801a04 	addi	r6,sp,104
81130a0c:	b80b883a 	mov	r5,r23
81130a10:	a809883a 	mov	r4,r21
81130a14:	112faa00 	call	8112faa0 <__ssprint_r>
81130a18:	103fa71e 	bne	r2,zero,811308b8 <__reset+0xfb1108b8>
81130a1c:	d8c01c17 	ldw	r3,112(sp)
81130a20:	d8801b17 	ldw	r2,108(sp)
81130a24:	d811883a 	mov	r8,sp
81130a28:	003f5a06 	br	81130794 <__reset+0xfb110794>
81130a2c:	d9801a04 	addi	r6,sp,104
81130a30:	b80b883a 	mov	r5,r23
81130a34:	a809883a 	mov	r4,r21
81130a38:	112faa00 	call	8112faa0 <__ssprint_r>
81130a3c:	103f9e1e 	bne	r2,zero,811308b8 <__reset+0xfb1108b8>
81130a40:	d8c01c17 	ldw	r3,112(sp)
81130a44:	d8801b17 	ldw	r2,108(sp)
81130a48:	d811883a 	mov	r8,sp
81130a4c:	003f1706 	br	811306ac <__reset+0xfb1106ac>
81130a50:	d9801a04 	addi	r6,sp,104
81130a54:	b80b883a 	mov	r5,r23
81130a58:	a809883a 	mov	r4,r21
81130a5c:	112faa00 	call	8112faa0 <__ssprint_r>
81130a60:	103f951e 	bne	r2,zero,811308b8 <__reset+0xfb1108b8>
81130a64:	d8c01c17 	ldw	r3,112(sp)
81130a68:	d8801b17 	ldw	r2,108(sp)
81130a6c:	d811883a 	mov	r8,sp
81130a70:	003f1b06 	br	811306e0 <__reset+0xfb1106e0>
81130a74:	d8001d85 	stb	zero,118(sp)
81130a78:	80007b16 	blt	r16,zero,81130c68 <___svfiprintf_internal_r+0xff0>
81130a7c:	00ffdfc4 	movi	r3,-129
81130a80:	e244b03a 	or	r2,fp,r9
81130a84:	90e4703a 	and	r18,r18,r3
81130a88:	103d7026 	beq	r2,zero,8113004c <__reset+0xfb11004c>
81130a8c:	0015883a 	mov	r10,zero
81130a90:	003d7206 	br	8113005c <__reset+0xfb11005c>
81130a94:	d9801a04 	addi	r6,sp,104
81130a98:	b80b883a 	mov	r5,r23
81130a9c:	a809883a 	mov	r4,r21
81130aa0:	112faa00 	call	8112faa0 <__ssprint_r>
81130aa4:	103f841e 	bne	r2,zero,811308b8 <__reset+0xfb1108b8>
81130aa8:	d8c01c17 	ldw	r3,112(sp)
81130aac:	d8801b17 	ldw	r2,108(sp)
81130ab0:	d811883a 	mov	r8,sp
81130ab4:	003ef006 	br	81130678 <__reset+0xfb110678>
81130ab8:	9080100c 	andi	r2,r18,64
81130abc:	d8001d85 	stb	zero,118(sp)
81130ac0:	dac02317 	ldw	r11,140(sp)
81130ac4:	10008126 	beq	r2,zero,81130ccc <___svfiprintf_internal_r+0x1054>
81130ac8:	58800104 	addi	r2,r11,4
81130acc:	5f00000b 	ldhu	fp,0(r11)
81130ad0:	0013883a 	mov	r9,zero
81130ad4:	803ec30e 	bge	r16,zero,811305e4 <__reset+0xfb1105e4>
81130ad8:	d8802315 	stw	r2,140(sp)
81130adc:	0015883a 	mov	r10,zero
81130ae0:	e244b03a 	or	r2,fp,r9
81130ae4:	103e371e 	bne	r2,zero,811303c4 <__reset+0xfb1103c4>
81130ae8:	00800044 	movi	r2,1
81130aec:	10803fcc 	andi	r2,r2,255
81130af0:	00c00044 	movi	r3,1
81130af4:	10c06126 	beq	r2,r3,81130c7c <___svfiprintf_internal_r+0x1004>
81130af8:	00c00084 	movi	r3,2
81130afc:	10fd5526 	beq	r2,r3,81130054 <__reset+0xfb110054>
81130b00:	003ed806 	br	81130664 <__reset+0xfb110664>
81130b04:	d8802315 	stw	r2,140(sp)
81130b08:	98c00007 	ldb	r3,0(r19)
81130b0c:	003cab06 	br	8112fdbc <__reset+0xfb10fdbc>
81130b10:	d9801a04 	addi	r6,sp,104
81130b14:	b80b883a 	mov	r5,r23
81130b18:	a809883a 	mov	r4,r21
81130b1c:	112faa00 	call	8112faa0 <__ssprint_r>
81130b20:	103f651e 	bne	r2,zero,811308b8 <__reset+0xfb1108b8>
81130b24:	d8c01c17 	ldw	r3,112(sp)
81130b28:	003f4f06 	br	81130868 <__reset+0xfb110868>
81130b2c:	00a04574 	movhi	r2,33045
81130b30:	10810904 	addi	r2,r2,1060
81130b34:	d8802915 	stw	r2,164(sp)
81130b38:	003d4406 	br	8113004c <__reset+0xfb11004c>
81130b3c:	dac02317 	ldw	r11,140(sp)
81130b40:	58800017 	ldw	r2,0(r11)
81130b44:	dac02517 	ldw	r11,148(sp)
81130b48:	5807d7fa 	srai	r3,r11,31
81130b4c:	dac02317 	ldw	r11,140(sp)
81130b50:	10c00115 	stw	r3,4(r2)
81130b54:	5ac00104 	addi	r11,r11,4
81130b58:	dac02315 	stw	r11,140(sp)
81130b5c:	dac02517 	ldw	r11,148(sp)
81130b60:	12c00015 	stw	r11,0(r2)
81130b64:	003c6d06 	br	8112fd1c <__reset+0xfb10fd1c>
81130b68:	9080100c 	andi	r2,r18,64
81130b6c:	dac02317 	ldw	r11,140(sp)
81130b70:	103e5326 	beq	r2,zero,811304c0 <__reset+0xfb1104c0>
81130b74:	5f00000f 	ldh	fp,0(r11)
81130b78:	5ac00104 	addi	r11,r11,4
81130b7c:	dac02315 	stw	r11,140(sp)
81130b80:	e013d7fa 	srai	r9,fp,31
81130b84:	4805883a 	mov	r2,r9
81130b88:	003e0706 	br	811303a8 <__reset+0xfb1103a8>
81130b8c:	00800c04 	movi	r2,48
81130b90:	d8801d05 	stb	r2,116(sp)
81130b94:	d8c01d45 	stb	r3,117(sp)
81130b98:	d8001d85 	stb	zero,118(sp)
81130b9c:	90800094 	ori	r2,r18,2
81130ba0:	80008f16 	blt	r16,zero,81130de0 <___svfiprintf_internal_r+0x1168>
81130ba4:	00bfdfc4 	movi	r2,-129
81130ba8:	90a4703a 	and	r18,r18,r2
81130bac:	94800094 	ori	r18,r18,2
81130bb0:	0015883a 	mov	r10,zero
81130bb4:	003d2906 	br	8113005c <__reset+0xfb11005c>
81130bb8:	98c00007 	ldb	r3,0(r19)
81130bbc:	003c7f06 	br	8112fdbc <__reset+0xfb10fdbc>
81130bc0:	dac02317 	ldw	r11,140(sp)
81130bc4:	0013883a 	mov	r9,zero
81130bc8:	5f000017 	ldw	fp,0(r11)
81130bcc:	5ac00104 	addi	r11,r11,4
81130bd0:	dac02315 	stw	r11,140(sp)
81130bd4:	003d1506 	br	8113002c <__reset+0xfb11002c>
81130bd8:	9080100c 	andi	r2,r18,64
81130bdc:	d8001d85 	stb	zero,118(sp)
81130be0:	dac02317 	ldw	r11,140(sp)
81130be4:	10003426 	beq	r2,zero,81130cb8 <___svfiprintf_internal_r+0x1040>
81130be8:	58800104 	addi	r2,r11,4
81130bec:	5f00000b 	ldhu	fp,0(r11)
81130bf0:	0013883a 	mov	r9,zero
81130bf4:	803e950e 	bge	r16,zero,8113064c <__reset+0xfb11064c>
81130bf8:	e246b03a 	or	r3,fp,r9
81130bfc:	d8802315 	stw	r2,140(sp)
81130c00:	183d5a1e 	bne	r3,zero,8113016c <__reset+0xfb11016c>
81130c04:	0015883a 	mov	r10,zero
81130c08:	0005883a 	mov	r2,zero
81130c0c:	003fb706 	br	81130aec <__reset+0xfb110aec>
81130c10:	98c00043 	ldbu	r3,1(r19)
81130c14:	94800814 	ori	r18,r18,32
81130c18:	9cc00044 	addi	r19,r19,1
81130c1c:	18c03fcc 	andi	r3,r3,255
81130c20:	18c0201c 	xori	r3,r3,128
81130c24:	18ffe004 	addi	r3,r3,-128
81130c28:	003c6406 	br	8112fdbc <__reset+0xfb10fdbc>
81130c2c:	d8c02315 	stw	r3,140(sp)
81130c30:	0015883a 	mov	r10,zero
81130c34:	003faa06 	br	81130ae0 <__reset+0xfb110ae0>
81130c38:	dac02317 	ldw	r11,140(sp)
81130c3c:	58800017 	ldw	r2,0(r11)
81130c40:	5ac00104 	addi	r11,r11,4
81130c44:	dac02315 	stw	r11,140(sp)
81130c48:	dac02517 	ldw	r11,148(sp)
81130c4c:	12c00015 	stw	r11,0(r2)
81130c50:	003c3206 	br	8112fd1c <__reset+0xfb10fd1c>
81130c54:	01204574 	movhi	r4,33045
81130c58:	21010904 	addi	r4,r4,1060
81130c5c:	d9002915 	stw	r4,164(sp)
81130c60:	d8c02315 	stw	r3,140(sp)
81130c64:	1025883a 	mov	r18,r2
81130c68:	e244b03a 	or	r2,fp,r9
81130c6c:	103f871e 	bne	r2,zero,81130a8c <__reset+0xfb110a8c>
81130c70:	0015883a 	mov	r10,zero
81130c74:	00800084 	movi	r2,2
81130c78:	003f9c06 	br	81130aec <__reset+0xfb110aec>
81130c7c:	0039883a 	mov	fp,zero
81130c80:	003e5f06 	br	81130600 <__reset+0xfb110600>
81130c84:	d9801a04 	addi	r6,sp,104
81130c88:	b80b883a 	mov	r5,r23
81130c8c:	a809883a 	mov	r4,r21
81130c90:	112faa00 	call	8112faa0 <__ssprint_r>
81130c94:	103f081e 	bne	r2,zero,811308b8 <__reset+0xfb1108b8>
81130c98:	d8c01c17 	ldw	r3,112(sp)
81130c9c:	d8801b17 	ldw	r2,108(sp)
81130ca0:	d811883a 	mov	r8,sp
81130ca4:	003e9106 	br	811306ec <__reset+0xfb1106ec>
81130ca8:	01204574 	movhi	r4,33045
81130cac:	21019304 	addi	r4,r4,1612
81130cb0:	d9002215 	stw	r4,136(sp)
81130cb4:	003ead06 	br	8113076c <__reset+0xfb11076c>
81130cb8:	58800104 	addi	r2,r11,4
81130cbc:	5f000017 	ldw	fp,0(r11)
81130cc0:	0013883a 	mov	r9,zero
81130cc4:	803e610e 	bge	r16,zero,8113064c <__reset+0xfb11064c>
81130cc8:	003fcb06 	br	81130bf8 <__reset+0xfb110bf8>
81130ccc:	58800104 	addi	r2,r11,4
81130cd0:	5f000017 	ldw	fp,0(r11)
81130cd4:	0013883a 	mov	r9,zero
81130cd8:	803e420e 	bge	r16,zero,811305e4 <__reset+0xfb1105e4>
81130cdc:	003f7e06 	br	81130ad8 <__reset+0xfb110ad8>
81130ce0:	5f000017 	ldw	fp,0(r11)
81130ce4:	5ac00104 	addi	r11,r11,4
81130ce8:	0013883a 	mov	r9,zero
81130cec:	dac02315 	stw	r11,140(sp)
81130cf0:	003cce06 	br	8113002c <__reset+0xfb11002c>
81130cf4:	8809883a 	mov	r4,r17
81130cf8:	da002c15 	stw	r8,176(sp)
81130cfc:	1122b480 	call	81122b48 <strlen>
81130d00:	d8802115 	stw	r2,132(sp)
81130d04:	da801d83 	ldbu	r10,118(sp)
81130d08:	df002315 	stw	fp,140(sp)
81130d0c:	0021883a 	mov	r16,zero
81130d10:	da002c17 	ldw	r8,176(sp)
81130d14:	003cf606 	br	811300f0 <__reset+0xfb1100f0>
81130d18:	00800184 	movi	r2,6
81130d1c:	1400012e 	bgeu	r2,r16,81130d24 <___svfiprintf_internal_r+0x10ac>
81130d20:	1021883a 	mov	r16,r2
81130d24:	dc002115 	stw	r16,132(sp)
81130d28:	8005883a 	mov	r2,r16
81130d2c:	80003c16 	blt	r16,zero,81130e20 <___svfiprintf_internal_r+0x11a8>
81130d30:	04604574 	movhi	r17,33045
81130d34:	d8802015 	stw	r2,128(sp)
81130d38:	df002315 	stw	fp,140(sp)
81130d3c:	8c410e04 	addi	r17,r17,1080
81130d40:	003d2e06 	br	811301fc <__reset+0xfb1101fc>
81130d44:	04001004 	movi	r16,64
81130d48:	800b883a 	mov	r5,r16
81130d4c:	11218400 	call	81121840 <_malloc_r>
81130d50:	dac02717 	ldw	r11,156(sp)
81130d54:	58800015 	stw	r2,0(r11)
81130d58:	58800415 	stw	r2,16(r11)
81130d5c:	10004826 	beq	r2,zero,81130e80 <___svfiprintf_internal_r+0x1208>
81130d60:	dac02717 	ldw	r11,156(sp)
81130d64:	5c000515 	stw	r16,20(r11)
81130d68:	003bd906 	br	8112fcd0 <__reset+0xfb10fcd0>
81130d6c:	9080004c 	andi	r2,r18,1
81130d70:	0015883a 	mov	r10,zero
81130d74:	10000626 	beq	r2,zero,81130d90 <___svfiprintf_internal_r+0x1118>
81130d78:	dac02b17 	ldw	r11,172(sp)
81130d7c:	00800c04 	movi	r2,48
81130d80:	d88019c5 	stb	r2,103(sp)
81130d84:	dac02115 	stw	r11,132(sp)
81130d88:	dc4019c4 	addi	r17,sp,103
81130d8c:	003cd806 	br	811300f0 <__reset+0xfb1100f0>
81130d90:	d8002115 	stw	zero,132(sp)
81130d94:	dc401a04 	addi	r17,sp,104
81130d98:	003cd506 	br	811300f0 <__reset+0xfb1100f0>
81130d9c:	01204574 	movhi	r4,33045
81130da0:	21019704 	addi	r4,r4,1628
81130da4:	d9002815 	stw	r4,160(sp)
81130da8:	003d4306 	br	811302b8 <__reset+0xfb1102b8>
81130dac:	00bfffc4 	movi	r2,-1
81130db0:	003ec606 	br	811308cc <__reset+0xfb1108cc>
81130db4:	00800044 	movi	r2,1
81130db8:	10803fcc 	andi	r2,r2,255
81130dbc:	00c00044 	movi	r3,1
81130dc0:	10fd8026 	beq	r2,r3,811303c4 <__reset+0xfb1103c4>
81130dc4:	00c00084 	movi	r3,2
81130dc8:	10fca426 	beq	r2,r3,8113005c <__reset+0xfb11005c>
81130dcc:	003ce806 	br	81130170 <__reset+0xfb110170>
81130dd0:	01204574 	movhi	r4,33045
81130dd4:	21019704 	addi	r4,r4,1628
81130dd8:	d9002815 	stw	r4,160(sp)
81130ddc:	003e9906 	br	81130844 <__reset+0xfb110844>
81130de0:	1025883a 	mov	r18,r2
81130de4:	0015883a 	mov	r10,zero
81130de8:	00800084 	movi	r2,2
81130dec:	003ff206 	br	81130db8 <__reset+0xfb110db8>
81130df0:	01604574 	movhi	r5,33045
81130df4:	29419304 	addi	r5,r5,1612
81130df8:	d9402215 	stw	r5,136(sp)
81130dfc:	003ee206 	br	81130988 <__reset+0xfb110988>
81130e00:	5827883a 	mov	r19,r11
81130e04:	0021883a 	mov	r16,zero
81130e08:	003bed06 	br	8112fdc0 <__reset+0xfb10fdc0>
81130e0c:	dc002115 	stw	r16,132(sp)
81130e10:	da801d83 	ldbu	r10,118(sp)
81130e14:	df002315 	stw	fp,140(sp)
81130e18:	0021883a 	mov	r16,zero
81130e1c:	003cb406 	br	811300f0 <__reset+0xfb1100f0>
81130e20:	0005883a 	mov	r2,zero
81130e24:	003fc206 	br	81130d30 <__reset+0xfb110d30>
81130e28:	d8802317 	ldw	r2,140(sp)
81130e2c:	98c00043 	ldbu	r3,1(r19)
81130e30:	5827883a 	mov	r19,r11
81130e34:	14000017 	ldw	r16,0(r2)
81130e38:	10800104 	addi	r2,r2,4
81130e3c:	d8802315 	stw	r2,140(sp)
81130e40:	803f760e 	bge	r16,zero,81130c1c <__reset+0xfb110c1c>
81130e44:	18c03fcc 	andi	r3,r3,255
81130e48:	18c0201c 	xori	r3,r3,128
81130e4c:	043fffc4 	movi	r16,-1
81130e50:	18ffe004 	addi	r3,r3,-128
81130e54:	003bd906 	br	8112fdbc <__reset+0xfb10fdbc>
81130e58:	d9c01d85 	stb	r7,118(sp)
81130e5c:	003cb606 	br	81130138 <__reset+0xfb110138>
81130e60:	d9c01d85 	stb	r7,118(sp)
81130e64:	003d2106 	br	811302ec <__reset+0xfb1102ec>
81130e68:	d9c01d85 	stb	r7,118(sp)
81130e6c:	003d8e06 	br	811304a8 <__reset+0xfb1104a8>
81130e70:	d9c01d85 	stb	r7,118(sp)
81130e74:	003db306 	br	81130544 <__reset+0xfb110544>
81130e78:	d9c01d85 	stb	r7,118(sp)
81130e7c:	003c8a06 	br	811300a8 <__reset+0xfb1100a8>
81130e80:	dac02a17 	ldw	r11,168(sp)
81130e84:	00800304 	movi	r2,12
81130e88:	58800015 	stw	r2,0(r11)
81130e8c:	00bfffc4 	movi	r2,-1
81130e90:	003e8e06 	br	811308cc <__reset+0xfb1108cc>
81130e94:	d9c01d85 	stb	r7,118(sp)
81130e98:	003dc706 	br	811305b8 <__reset+0xfb1105b8>
81130e9c:	d9c01d85 	stb	r7,118(sp)
81130ea0:	003ddf06 	br	81130620 <__reset+0xfb110620>
81130ea4:	d9c01d85 	stb	r7,118(sp)
81130ea8:	003d3706 	br	81130388 <__reset+0xfb110388>
81130eac:	d9c01d85 	stb	r7,118(sp)
81130eb0:	003c5406 	br	81130004 <__reset+0xfb110004>
81130eb4:	d9c01d85 	stb	r7,118(sp)
81130eb8:	003d1d06 	br	81130330 <__reset+0xfb110330>

81130ebc <__submore>:
81130ebc:	defffa04 	addi	sp,sp,-24
81130ec0:	de00012e 	bgeu	sp,et,81130ec8 <__submore+0xc>
81130ec4:	003b68fa 	trap	3
81130ec8:	dc000015 	stw	r16,0(sp)
81130ecc:	2821883a 	mov	r16,r5
81130ed0:	29400c17 	ldw	r5,48(r5)
81130ed4:	dfc00515 	stw	ra,20(sp)
81130ed8:	dd000415 	stw	r20,16(sp)
81130edc:	dcc00315 	stw	r19,12(sp)
81130ee0:	dc800215 	stw	r18,8(sp)
81130ee4:	dc400115 	stw	r17,4(sp)
81130ee8:	80801004 	addi	r2,r16,64
81130eec:	28801726 	beq	r5,r2,81130f4c <__submore+0x90>
81130ef0:	84400d17 	ldw	r17,52(r16)
81130ef4:	8c67883a 	add	r19,r17,r17
81130ef8:	980d883a 	mov	r6,r19
81130efc:	112d3480 	call	8112d348 <_realloc_r>
81130f00:	1025883a 	mov	r18,r2
81130f04:	10002226 	beq	r2,zero,81130f90 <__submore+0xd4>
81130f08:	1469883a 	add	r20,r2,r17
81130f0c:	880d883a 	mov	r6,r17
81130f10:	100b883a 	mov	r5,r2
81130f14:	a009883a 	mov	r4,r20
81130f18:	11220540 	call	81122054 <memcpy>
81130f1c:	0005883a 	mov	r2,zero
81130f20:	85000015 	stw	r20,0(r16)
81130f24:	84800c15 	stw	r18,48(r16)
81130f28:	84c00d15 	stw	r19,52(r16)
81130f2c:	dfc00517 	ldw	ra,20(sp)
81130f30:	dd000417 	ldw	r20,16(sp)
81130f34:	dcc00317 	ldw	r19,12(sp)
81130f38:	dc800217 	ldw	r18,8(sp)
81130f3c:	dc400117 	ldw	r17,4(sp)
81130f40:	dc000017 	ldw	r16,0(sp)
81130f44:	dec00604 	addi	sp,sp,24
81130f48:	f800283a 	ret
81130f4c:	04410004 	movi	r17,1024
81130f50:	880b883a 	mov	r5,r17
81130f54:	11218400 	call	81121840 <_malloc_r>
81130f58:	1007883a 	mov	r3,r2
81130f5c:	10000c26 	beq	r2,zero,81130f90 <__submore+0xd4>
81130f60:	80801083 	ldbu	r2,66(r16)
81130f64:	80c00c15 	stw	r3,48(r16)
81130f68:	84400d15 	stw	r17,52(r16)
81130f6c:	1880ffc5 	stb	r2,1023(r3)
81130f70:	81401043 	ldbu	r5,65(r16)
81130f74:	1900ff44 	addi	r4,r3,1021
81130f78:	0005883a 	mov	r2,zero
81130f7c:	1940ff85 	stb	r5,1022(r3)
81130f80:	81401003 	ldbu	r5,64(r16)
81130f84:	1940ff45 	stb	r5,1021(r3)
81130f88:	81000015 	stw	r4,0(r16)
81130f8c:	003fe706 	br	81130f2c <__reset+0xfb110f2c>
81130f90:	00bfffc4 	movi	r2,-1
81130f94:	003fe506 	br	81130f2c <__reset+0xfb110f2c>

81130f98 <_ungetc_r>:
81130f98:	00bfffc4 	movi	r2,-1
81130f9c:	28806326 	beq	r5,r2,8113112c <_ungetc_r+0x194>
81130fa0:	defffb04 	addi	sp,sp,-20
81130fa4:	de00012e 	bgeu	sp,et,81130fac <_ungetc_r+0x14>
81130fa8:	003b68fa 	trap	3
81130fac:	dcc00315 	stw	r19,12(sp)
81130fb0:	dc400115 	stw	r17,4(sp)
81130fb4:	dc000015 	stw	r16,0(sp)
81130fb8:	dfc00415 	stw	ra,16(sp)
81130fbc:	dc800215 	stw	r18,8(sp)
81130fc0:	2023883a 	mov	r17,r4
81130fc4:	3021883a 	mov	r16,r6
81130fc8:	2827883a 	mov	r19,r5
81130fcc:	20000226 	beq	r4,zero,81130fd8 <_ungetc_r+0x40>
81130fd0:	20800e17 	ldw	r2,56(r4)
81130fd4:	10002e26 	beq	r2,zero,81131090 <_ungetc_r+0xf8>
81130fd8:	80c0030b 	ldhu	r3,12(r16)
81130fdc:	1888000c 	andi	r2,r3,8192
81130fe0:	1000051e 	bne	r2,zero,81130ff8 <_ungetc_r+0x60>
81130fe4:	81001917 	ldw	r4,100(r16)
81130fe8:	00b7ffc4 	movi	r2,-8193
81130fec:	18c80014 	ori	r3,r3,8192
81130ff0:	2084703a 	and	r2,r4,r2
81130ff4:	80801915 	stw	r2,100(r16)
81130ff8:	00bff7c4 	movi	r2,-33
81130ffc:	1884703a 	and	r2,r3,r2
81131000:	8080030d 	sth	r2,12(r16)
81131004:	1900010c 	andi	r4,r3,4
81131008:	2000061e 	bne	r4,zero,81131024 <_ungetc_r+0x8c>
8113100c:	1900040c 	andi	r4,r3,16
81131010:	20001d26 	beq	r4,zero,81131088 <_ungetc_r+0xf0>
81131014:	18c0020c 	andi	r3,r3,8
81131018:	1800331e 	bne	r3,zero,811310e8 <_ungetc_r+0x150>
8113101c:	10800114 	ori	r2,r2,4
81131020:	8080030d 	sth	r2,12(r16)
81131024:	80800c17 	ldw	r2,48(r16)
81131028:	9c803fcc 	andi	r18,r19,255
8113102c:	10001a26 	beq	r2,zero,81131098 <_ungetc_r+0x100>
81131030:	80c00117 	ldw	r3,4(r16)
81131034:	80800d17 	ldw	r2,52(r16)
81131038:	18800f0e 	bge	r3,r2,81131078 <_ungetc_r+0xe0>
8113103c:	80c00017 	ldw	r3,0(r16)
81131040:	9005883a 	mov	r2,r18
81131044:	193fffc4 	addi	r4,r3,-1
81131048:	81000015 	stw	r4,0(r16)
8113104c:	1cffffc5 	stb	r19,-1(r3)
81131050:	80c00117 	ldw	r3,4(r16)
81131054:	18c00044 	addi	r3,r3,1
81131058:	80c00115 	stw	r3,4(r16)
8113105c:	dfc00417 	ldw	ra,16(sp)
81131060:	dcc00317 	ldw	r19,12(sp)
81131064:	dc800217 	ldw	r18,8(sp)
81131068:	dc400117 	ldw	r17,4(sp)
8113106c:	dc000017 	ldw	r16,0(sp)
81131070:	dec00504 	addi	sp,sp,20
81131074:	f800283a 	ret
81131078:	800b883a 	mov	r5,r16
8113107c:	8809883a 	mov	r4,r17
81131080:	1130ebc0 	call	81130ebc <__submore>
81131084:	103fed26 	beq	r2,zero,8113103c <__reset+0xfb11103c>
81131088:	00bfffc4 	movi	r2,-1
8113108c:	003ff306 	br	8113105c <__reset+0xfb11105c>
81131090:	112ae1c0 	call	8112ae1c <__sinit>
81131094:	003fd006 	br	81130fd8 <__reset+0xfb110fd8>
81131098:	80c00417 	ldw	r3,16(r16)
8113109c:	80800017 	ldw	r2,0(r16)
811310a0:	18000326 	beq	r3,zero,811310b0 <_ungetc_r+0x118>
811310a4:	1880022e 	bgeu	r3,r2,811310b0 <_ungetc_r+0x118>
811310a8:	10ffffc3 	ldbu	r3,-1(r2)
811310ac:	90c01826 	beq	r18,r3,81131110 <_ungetc_r+0x178>
811310b0:	81400117 	ldw	r5,4(r16)
811310b4:	80800e15 	stw	r2,56(r16)
811310b8:	008000c4 	movi	r2,3
811310bc:	81001004 	addi	r4,r16,64
811310c0:	80c01084 	addi	r3,r16,66
811310c4:	80800d15 	stw	r2,52(r16)
811310c8:	00800044 	movi	r2,1
811310cc:	80800115 	stw	r2,4(r16)
811310d0:	81400f15 	stw	r5,60(r16)
811310d4:	81000c15 	stw	r4,48(r16)
811310d8:	84c01085 	stb	r19,66(r16)
811310dc:	80c00015 	stw	r3,0(r16)
811310e0:	9005883a 	mov	r2,r18
811310e4:	003fdd06 	br	8113105c <__reset+0xfb11105c>
811310e8:	800b883a 	mov	r5,r16
811310ec:	8809883a 	mov	r4,r17
811310f0:	112aa200 	call	8112aa20 <_fflush_r>
811310f4:	103fe41e 	bne	r2,zero,81131088 <__reset+0xfb111088>
811310f8:	8080030b 	ldhu	r2,12(r16)
811310fc:	00fffdc4 	movi	r3,-9
81131100:	80000215 	stw	zero,8(r16)
81131104:	1884703a 	and	r2,r3,r2
81131108:	80000615 	stw	zero,24(r16)
8113110c:	003fc306 	br	8113101c <__reset+0xfb11101c>
81131110:	80c00117 	ldw	r3,4(r16)
81131114:	10bfffc4 	addi	r2,r2,-1
81131118:	80800015 	stw	r2,0(r16)
8113111c:	18800044 	addi	r2,r3,1
81131120:	80800115 	stw	r2,4(r16)
81131124:	9005883a 	mov	r2,r18
81131128:	003fcc06 	br	8113105c <__reset+0xfb11105c>
8113112c:	00bfffc4 	movi	r2,-1
81131130:	f800283a 	ret

81131134 <ungetc>:
81131134:	00a04574 	movhi	r2,33045
81131138:	108ad804 	addi	r2,r2,11104
8113113c:	280d883a 	mov	r6,r5
81131140:	200b883a 	mov	r5,r4
81131144:	11000017 	ldw	r4,0(r2)
81131148:	1130f981 	jmpi	81130f98 <_ungetc_r>

8113114c <__sprint_r.part.0>:
8113114c:	defff604 	addi	sp,sp,-40
81131150:	de00012e 	bgeu	sp,et,81131158 <__sprint_r.part.0+0xc>
81131154:	003b68fa 	trap	3
81131158:	28801917 	ldw	r2,100(r5)
8113115c:	dd400515 	stw	r21,20(sp)
81131160:	dfc00915 	stw	ra,36(sp)
81131164:	df000815 	stw	fp,32(sp)
81131168:	ddc00715 	stw	r23,28(sp)
8113116c:	dd800615 	stw	r22,24(sp)
81131170:	dd000415 	stw	r20,16(sp)
81131174:	dcc00315 	stw	r19,12(sp)
81131178:	dc800215 	stw	r18,8(sp)
8113117c:	dc400115 	stw	r17,4(sp)
81131180:	dc000015 	stw	r16,0(sp)
81131184:	1088000c 	andi	r2,r2,8192
81131188:	302b883a 	mov	r21,r6
8113118c:	10002e26 	beq	r2,zero,81131248 <__sprint_r.part.0+0xfc>
81131190:	30800217 	ldw	r2,8(r6)
81131194:	35800017 	ldw	r22,0(r6)
81131198:	10002926 	beq	r2,zero,81131240 <__sprint_r.part.0+0xf4>
8113119c:	2827883a 	mov	r19,r5
811311a0:	2029883a 	mov	r20,r4
811311a4:	b5c00104 	addi	r23,r22,4
811311a8:	04bfffc4 	movi	r18,-1
811311ac:	bc400017 	ldw	r17,0(r23)
811311b0:	b4000017 	ldw	r16,0(r22)
811311b4:	0039883a 	mov	fp,zero
811311b8:	8822d0ba 	srli	r17,r17,2
811311bc:	8800031e 	bne	r17,zero,811311cc <__sprint_r.part.0+0x80>
811311c0:	00001806 	br	81131224 <__sprint_r.part.0+0xd8>
811311c4:	84000104 	addi	r16,r16,4
811311c8:	8f001526 	beq	r17,fp,81131220 <__sprint_r.part.0+0xd4>
811311cc:	81400017 	ldw	r5,0(r16)
811311d0:	980d883a 	mov	r6,r19
811311d4:	a009883a 	mov	r4,r20
811311d8:	1132af00 	call	81132af0 <_fputwc_r>
811311dc:	e7000044 	addi	fp,fp,1
811311e0:	14bff81e 	bne	r2,r18,811311c4 <__reset+0xfb1111c4>
811311e4:	9005883a 	mov	r2,r18
811311e8:	a8000215 	stw	zero,8(r21)
811311ec:	a8000115 	stw	zero,4(r21)
811311f0:	dfc00917 	ldw	ra,36(sp)
811311f4:	df000817 	ldw	fp,32(sp)
811311f8:	ddc00717 	ldw	r23,28(sp)
811311fc:	dd800617 	ldw	r22,24(sp)
81131200:	dd400517 	ldw	r21,20(sp)
81131204:	dd000417 	ldw	r20,16(sp)
81131208:	dcc00317 	ldw	r19,12(sp)
8113120c:	dc800217 	ldw	r18,8(sp)
81131210:	dc400117 	ldw	r17,4(sp)
81131214:	dc000017 	ldw	r16,0(sp)
81131218:	dec00a04 	addi	sp,sp,40
8113121c:	f800283a 	ret
81131220:	a8800217 	ldw	r2,8(r21)
81131224:	8c63883a 	add	r17,r17,r17
81131228:	8c63883a 	add	r17,r17,r17
8113122c:	1445c83a 	sub	r2,r2,r17
81131230:	a8800215 	stw	r2,8(r21)
81131234:	b5800204 	addi	r22,r22,8
81131238:	bdc00204 	addi	r23,r23,8
8113123c:	103fdb1e 	bne	r2,zero,811311ac <__reset+0xfb1111ac>
81131240:	0005883a 	mov	r2,zero
81131244:	003fe806 	br	811311e8 <__reset+0xfb1111e8>
81131248:	112b5cc0 	call	8112b5cc <__sfvwrite_r>
8113124c:	003fe606 	br	811311e8 <__reset+0xfb1111e8>

81131250 <__sprint_r>:
81131250:	30c00217 	ldw	r3,8(r6)
81131254:	18000126 	beq	r3,zero,8113125c <__sprint_r+0xc>
81131258:	113114c1 	jmpi	8113114c <__sprint_r.part.0>
8113125c:	30000115 	stw	zero,4(r6)
81131260:	0005883a 	mov	r2,zero
81131264:	f800283a 	ret

81131268 <___vfiprintf_internal_r>:
81131268:	deffc904 	addi	sp,sp,-220
8113126c:	de00012e 	bgeu	sp,et,81131274 <___vfiprintf_internal_r+0xc>
81131270:	003b68fa 	trap	3
81131274:	df003515 	stw	fp,212(sp)
81131278:	dd003115 	stw	r20,196(sp)
8113127c:	dfc03615 	stw	ra,216(sp)
81131280:	ddc03415 	stw	r23,208(sp)
81131284:	dd803315 	stw	r22,204(sp)
81131288:	dd403215 	stw	r21,200(sp)
8113128c:	dcc03015 	stw	r19,192(sp)
81131290:	dc802f15 	stw	r18,188(sp)
81131294:	dc402e15 	stw	r17,184(sp)
81131298:	dc002d15 	stw	r16,180(sp)
8113129c:	d9002015 	stw	r4,128(sp)
811312a0:	d9c02215 	stw	r7,136(sp)
811312a4:	2829883a 	mov	r20,r5
811312a8:	3039883a 	mov	fp,r6
811312ac:	20000226 	beq	r4,zero,811312b8 <___vfiprintf_internal_r+0x50>
811312b0:	20800e17 	ldw	r2,56(r4)
811312b4:	1000cf26 	beq	r2,zero,811315f4 <___vfiprintf_internal_r+0x38c>
811312b8:	a080030b 	ldhu	r2,12(r20)
811312bc:	10c8000c 	andi	r3,r2,8192
811312c0:	1800061e 	bne	r3,zero,811312dc <___vfiprintf_internal_r+0x74>
811312c4:	a1001917 	ldw	r4,100(r20)
811312c8:	00f7ffc4 	movi	r3,-8193
811312cc:	10880014 	ori	r2,r2,8192
811312d0:	20c6703a 	and	r3,r4,r3
811312d4:	a080030d 	sth	r2,12(r20)
811312d8:	a0c01915 	stw	r3,100(r20)
811312dc:	10c0020c 	andi	r3,r2,8
811312e0:	1800a926 	beq	r3,zero,81131588 <___vfiprintf_internal_r+0x320>
811312e4:	a0c00417 	ldw	r3,16(r20)
811312e8:	1800a726 	beq	r3,zero,81131588 <___vfiprintf_internal_r+0x320>
811312ec:	1080068c 	andi	r2,r2,26
811312f0:	00c00284 	movi	r3,10
811312f4:	10c0ac26 	beq	r2,r3,811315a8 <___vfiprintf_internal_r+0x340>
811312f8:	da801a04 	addi	r10,sp,104
811312fc:	da801e15 	stw	r10,120(sp)
81131300:	d8801e17 	ldw	r2,120(sp)
81131304:	da8019c4 	addi	r10,sp,103
81131308:	05a04574 	movhi	r22,33045
8113130c:	05e04574 	movhi	r23,33045
81131310:	da801f15 	stw	r10,124(sp)
81131314:	1295c83a 	sub	r10,r2,r10
81131318:	b5819f04 	addi	r22,r22,1660
8113131c:	bdc19b04 	addi	r23,r23,1644
81131320:	dec01a15 	stw	sp,104(sp)
81131324:	d8001c15 	stw	zero,112(sp)
81131328:	d8001b15 	stw	zero,108(sp)
8113132c:	d8002615 	stw	zero,152(sp)
81131330:	d8002315 	stw	zero,140(sp)
81131334:	da802715 	stw	r10,156(sp)
81131338:	d811883a 	mov	r8,sp
8113133c:	dd002115 	stw	r20,132(sp)
81131340:	e021883a 	mov	r16,fp
81131344:	80800007 	ldb	r2,0(r16)
81131348:	1003ea26 	beq	r2,zero,811322f4 <___vfiprintf_internal_r+0x108c>
8113134c:	00c00944 	movi	r3,37
81131350:	8025883a 	mov	r18,r16
81131354:	10c0021e 	bne	r2,r3,81131360 <___vfiprintf_internal_r+0xf8>
81131358:	00001606 	br	811313b4 <___vfiprintf_internal_r+0x14c>
8113135c:	10c00326 	beq	r2,r3,8113136c <___vfiprintf_internal_r+0x104>
81131360:	94800044 	addi	r18,r18,1
81131364:	90800007 	ldb	r2,0(r18)
81131368:	103ffc1e 	bne	r2,zero,8113135c <__reset+0xfb11135c>
8113136c:	9423c83a 	sub	r17,r18,r16
81131370:	88001026 	beq	r17,zero,811313b4 <___vfiprintf_internal_r+0x14c>
81131374:	d8c01c17 	ldw	r3,112(sp)
81131378:	d8801b17 	ldw	r2,108(sp)
8113137c:	44000015 	stw	r16,0(r8)
81131380:	88c7883a 	add	r3,r17,r3
81131384:	10800044 	addi	r2,r2,1
81131388:	44400115 	stw	r17,4(r8)
8113138c:	d8c01c15 	stw	r3,112(sp)
81131390:	d8801b15 	stw	r2,108(sp)
81131394:	010001c4 	movi	r4,7
81131398:	2080760e 	bge	r4,r2,81131574 <___vfiprintf_internal_r+0x30c>
8113139c:	1803821e 	bne	r3,zero,811321a8 <___vfiprintf_internal_r+0xf40>
811313a0:	da802317 	ldw	r10,140(sp)
811313a4:	d8001b15 	stw	zero,108(sp)
811313a8:	d811883a 	mov	r8,sp
811313ac:	5455883a 	add	r10,r10,r17
811313b0:	da802315 	stw	r10,140(sp)
811313b4:	90800007 	ldb	r2,0(r18)
811313b8:	10044626 	beq	r2,zero,811324d4 <___vfiprintf_internal_r+0x126c>
811313bc:	90c00047 	ldb	r3,1(r18)
811313c0:	94000044 	addi	r16,r18,1
811313c4:	d8001d85 	stb	zero,118(sp)
811313c8:	0009883a 	mov	r4,zero
811313cc:	000f883a 	mov	r7,zero
811313d0:	027fffc4 	movi	r9,-1
811313d4:	0023883a 	mov	r17,zero
811313d8:	0029883a 	mov	r20,zero
811313dc:	01401604 	movi	r5,88
811313e0:	01800244 	movi	r6,9
811313e4:	03400a84 	movi	r13,42
811313e8:	03001b04 	movi	r12,108
811313ec:	84000044 	addi	r16,r16,1
811313f0:	18bff804 	addi	r2,r3,-32
811313f4:	28827336 	bltu	r5,r2,81131dc4 <___vfiprintf_internal_r+0xb5c>
811313f8:	100490ba 	slli	r2,r2,2
811313fc:	02a044f4 	movhi	r10,33043
81131400:	52850404 	addi	r10,r10,5136
81131404:	1285883a 	add	r2,r2,r10
81131408:	10800017 	ldw	r2,0(r2)
8113140c:	1000683a 	jmp	r2
81131410:	81131af8 	rdprs	r4,r16,19563
81131414:	81131dc4 	addi	r4,r16,19575
81131418:	81131dc4 	addi	r4,r16,19575
8113141c:	81131b18 	cmpnei	r4,r16,19564
81131420:	81131dc4 	addi	r4,r16,19575
81131424:	81131dc4 	addi	r4,r16,19575
81131428:	81131dc4 	addi	r4,r16,19575
8113142c:	81131dc4 	addi	r4,r16,19575
81131430:	81131dc4 	addi	r4,r16,19575
81131434:	81131dc4 	addi	r4,r16,19575
81131438:	81131d00 	call	881131d0 <__reset+0x20f31d0>
8113143c:	81131d1c 	xori	r4,r16,19572
81131440:	81131dc4 	addi	r4,r16,19575
81131444:	81131604 	addi	r4,r16,19544
81131448:	81131d2c 	andhi	r4,r16,19572
8113144c:	81131dc4 	addi	r4,r16,19575
81131450:	81131b24 	muli	r4,r16,19564
81131454:	81131b30 	cmpltui	r4,r16,19564
81131458:	81131b30 	cmpltui	r4,r16,19564
8113145c:	81131b30 	cmpltui	r4,r16,19564
81131460:	81131b30 	cmpltui	r4,r16,19564
81131464:	81131b30 	cmpltui	r4,r16,19564
81131468:	81131b30 	cmpltui	r4,r16,19564
8113146c:	81131b30 	cmpltui	r4,r16,19564
81131470:	81131b30 	cmpltui	r4,r16,19564
81131474:	81131b30 	cmpltui	r4,r16,19564
81131478:	81131dc4 	addi	r4,r16,19575
8113147c:	81131dc4 	addi	r4,r16,19575
81131480:	81131dc4 	addi	r4,r16,19575
81131484:	81131dc4 	addi	r4,r16,19575
81131488:	81131dc4 	addi	r4,r16,19575
8113148c:	81131dc4 	addi	r4,r16,19575
81131490:	81131dc4 	addi	r4,r16,19575
81131494:	81131dc4 	addi	r4,r16,19575
81131498:	81131dc4 	addi	r4,r16,19575
8113149c:	81131dc4 	addi	r4,r16,19575
811314a0:	81131b5c 	xori	r4,r16,19565
811314a4:	81131dc4 	addi	r4,r16,19575
811314a8:	81131dc4 	addi	r4,r16,19575
811314ac:	81131dc4 	addi	r4,r16,19575
811314b0:	81131dc4 	addi	r4,r16,19575
811314b4:	81131dc4 	addi	r4,r16,19575
811314b8:	81131dc4 	addi	r4,r16,19575
811314bc:	81131dc4 	addi	r4,r16,19575
811314c0:	81131dc4 	addi	r4,r16,19575
811314c4:	81131dc4 	addi	r4,r16,19575
811314c8:	81131dc4 	addi	r4,r16,19575
811314cc:	81131b94 	ori	r4,r16,19566
811314d0:	81131dc4 	addi	r4,r16,19575
811314d4:	81131dc4 	addi	r4,r16,19575
811314d8:	81131dc4 	addi	r4,r16,19575
811314dc:	81131dc4 	addi	r4,r16,19575
811314e0:	81131dc4 	addi	r4,r16,19575
811314e4:	81131bec 	andhi	r4,r16,19567
811314e8:	81131dc4 	addi	r4,r16,19575
811314ec:	81131dc4 	addi	r4,r16,19575
811314f0:	81131c5c 	xori	r4,r16,19569
811314f4:	81131dc4 	addi	r4,r16,19575
811314f8:	81131dc4 	addi	r4,r16,19575
811314fc:	81131dc4 	addi	r4,r16,19575
81131500:	81131dc4 	addi	r4,r16,19575
81131504:	81131dc4 	addi	r4,r16,19575
81131508:	81131dc4 	addi	r4,r16,19575
8113150c:	81131dc4 	addi	r4,r16,19575
81131510:	81131dc4 	addi	r4,r16,19575
81131514:	81131dc4 	addi	r4,r16,19575
81131518:	81131dc4 	addi	r4,r16,19575
8113151c:	81131a08 	cmpgei	r4,r16,19560
81131520:	81131a34 	orhi	r4,r16,19560
81131524:	81131dc4 	addi	r4,r16,19575
81131528:	81131dc4 	addi	r4,r16,19575
8113152c:	81131dc4 	addi	r4,r16,19575
81131530:	81131d6c 	andhi	r4,r16,19573
81131534:	81131a34 	orhi	r4,r16,19560
81131538:	81131dc4 	addi	r4,r16,19575
8113153c:	81131dc4 	addi	r4,r16,19575
81131540:	811318c8 	cmpgei	r4,r16,19555
81131544:	81131dc4 	addi	r4,r16,19575
81131548:	811318d8 	cmpnei	r4,r16,19555
8113154c:	81131914 	ori	r4,r16,19556
81131550:	81131610 	cmplti	r4,r16,19544
81131554:	811318bc 	xorhi	r4,r16,19554
81131558:	81131dc4 	addi	r4,r16,19575
8113155c:	81131c98 	cmpnei	r4,r16,19570
81131560:	81131dc4 	addi	r4,r16,19575
81131564:	81131cf0 	cmpltui	r4,r16,19571
81131568:	81131dc4 	addi	r4,r16,19575
8113156c:	81131dc4 	addi	r4,r16,19575
81131570:	811319b4 	orhi	r4,r16,19558
81131574:	42000204 	addi	r8,r8,8
81131578:	da802317 	ldw	r10,140(sp)
8113157c:	5455883a 	add	r10,r10,r17
81131580:	da802315 	stw	r10,140(sp)
81131584:	003f8b06 	br	811313b4 <__reset+0xfb1113b4>
81131588:	d9002017 	ldw	r4,128(sp)
8113158c:	a00b883a 	mov	r5,r20
81131590:	1128dac0 	call	81128dac <__swsetup_r>
81131594:	1003b11e 	bne	r2,zero,8113245c <___vfiprintf_internal_r+0x11f4>
81131598:	a080030b 	ldhu	r2,12(r20)
8113159c:	00c00284 	movi	r3,10
811315a0:	1080068c 	andi	r2,r2,26
811315a4:	10ff541e 	bne	r2,r3,811312f8 <__reset+0xfb1112f8>
811315a8:	a080038f 	ldh	r2,14(r20)
811315ac:	103f5216 	blt	r2,zero,811312f8 <__reset+0xfb1112f8>
811315b0:	d9c02217 	ldw	r7,136(sp)
811315b4:	d9002017 	ldw	r4,128(sp)
811315b8:	e00d883a 	mov	r6,fp
811315bc:	a00b883a 	mov	r5,r20
811315c0:	11326e80 	call	811326e8 <__sbprintf>
811315c4:	dfc03617 	ldw	ra,216(sp)
811315c8:	df003517 	ldw	fp,212(sp)
811315cc:	ddc03417 	ldw	r23,208(sp)
811315d0:	dd803317 	ldw	r22,204(sp)
811315d4:	dd403217 	ldw	r21,200(sp)
811315d8:	dd003117 	ldw	r20,196(sp)
811315dc:	dcc03017 	ldw	r19,192(sp)
811315e0:	dc802f17 	ldw	r18,188(sp)
811315e4:	dc402e17 	ldw	r17,184(sp)
811315e8:	dc002d17 	ldw	r16,180(sp)
811315ec:	dec03704 	addi	sp,sp,220
811315f0:	f800283a 	ret
811315f4:	112ae1c0 	call	8112ae1c <__sinit>
811315f8:	003f2f06 	br	811312b8 <__reset+0xfb1112b8>
811315fc:	0463c83a 	sub	r17,zero,r17
81131600:	d8802215 	stw	r2,136(sp)
81131604:	a5000114 	ori	r20,r20,4
81131608:	80c00007 	ldb	r3,0(r16)
8113160c:	003f7706 	br	811313ec <__reset+0xfb1113ec>
81131610:	00800c04 	movi	r2,48
81131614:	da802217 	ldw	r10,136(sp)
81131618:	d8801d05 	stb	r2,116(sp)
8113161c:	00801e04 	movi	r2,120
81131620:	d8801d45 	stb	r2,117(sp)
81131624:	d8001d85 	stb	zero,118(sp)
81131628:	50c00104 	addi	r3,r10,4
8113162c:	54800017 	ldw	r18,0(r10)
81131630:	0027883a 	mov	r19,zero
81131634:	a0800094 	ori	r2,r20,2
81131638:	48030b16 	blt	r9,zero,81132268 <___vfiprintf_internal_r+0x1000>
8113163c:	00bfdfc4 	movi	r2,-129
81131640:	a096703a 	and	r11,r20,r2
81131644:	d8c02215 	stw	r3,136(sp)
81131648:	5d000094 	ori	r20,r11,2
8113164c:	90032b1e 	bne	r18,zero,811322fc <___vfiprintf_internal_r+0x1094>
81131650:	00a04574 	movhi	r2,33045
81131654:	10810904 	addi	r2,r2,1060
81131658:	d8802615 	stw	r2,152(sp)
8113165c:	0039883a 	mov	fp,zero
81131660:	48017b1e 	bne	r9,zero,81131c50 <___vfiprintf_internal_r+0x9e8>
81131664:	0013883a 	mov	r9,zero
81131668:	0027883a 	mov	r19,zero
8113166c:	dd401a04 	addi	r21,sp,104
81131670:	4825883a 	mov	r18,r9
81131674:	4cc0010e 	bge	r9,r19,8113167c <___vfiprintf_internal_r+0x414>
81131678:	9825883a 	mov	r18,r19
8113167c:	e7003fcc 	andi	fp,fp,255
81131680:	e700201c 	xori	fp,fp,128
81131684:	e73fe004 	addi	fp,fp,-128
81131688:	e0000126 	beq	fp,zero,81131690 <___vfiprintf_internal_r+0x428>
8113168c:	94800044 	addi	r18,r18,1
81131690:	a380008c 	andi	r14,r20,2
81131694:	70000126 	beq	r14,zero,8113169c <___vfiprintf_internal_r+0x434>
81131698:	94800084 	addi	r18,r18,2
8113169c:	a700210c 	andi	fp,r20,132
811316a0:	e001df1e 	bne	fp,zero,81131e20 <___vfiprintf_internal_r+0xbb8>
811316a4:	8c87c83a 	sub	r3,r17,r18
811316a8:	00c1dd0e 	bge	zero,r3,81131e20 <___vfiprintf_internal_r+0xbb8>
811316ac:	01c00404 	movi	r7,16
811316b0:	d8801c17 	ldw	r2,112(sp)
811316b4:	38c3ad0e 	bge	r7,r3,8113256c <___vfiprintf_internal_r+0x1304>
811316b8:	02a04574 	movhi	r10,33045
811316bc:	52819f04 	addi	r10,r10,1660
811316c0:	dc002915 	stw	r16,164(sp)
811316c4:	d9801b17 	ldw	r6,108(sp)
811316c8:	da802415 	stw	r10,144(sp)
811316cc:	03c001c4 	movi	r15,7
811316d0:	da402515 	stw	r9,148(sp)
811316d4:	db802815 	stw	r14,160(sp)
811316d8:	1821883a 	mov	r16,r3
811316dc:	00000506 	br	811316f4 <___vfiprintf_internal_r+0x48c>
811316e0:	31400084 	addi	r5,r6,2
811316e4:	42000204 	addi	r8,r8,8
811316e8:	200d883a 	mov	r6,r4
811316ec:	843ffc04 	addi	r16,r16,-16
811316f0:	3c000d0e 	bge	r7,r16,81131728 <___vfiprintf_internal_r+0x4c0>
811316f4:	10800404 	addi	r2,r2,16
811316f8:	31000044 	addi	r4,r6,1
811316fc:	45800015 	stw	r22,0(r8)
81131700:	41c00115 	stw	r7,4(r8)
81131704:	d8801c15 	stw	r2,112(sp)
81131708:	d9001b15 	stw	r4,108(sp)
8113170c:	793ff40e 	bge	r15,r4,811316e0 <__reset+0xfb1116e0>
81131710:	1001b51e 	bne	r2,zero,81131de8 <___vfiprintf_internal_r+0xb80>
81131714:	843ffc04 	addi	r16,r16,-16
81131718:	000d883a 	mov	r6,zero
8113171c:	01400044 	movi	r5,1
81131720:	d811883a 	mov	r8,sp
81131724:	3c3ff316 	blt	r7,r16,811316f4 <__reset+0xfb1116f4>
81131728:	8007883a 	mov	r3,r16
8113172c:	da402517 	ldw	r9,148(sp)
81131730:	db802817 	ldw	r14,160(sp)
81131734:	dc002917 	ldw	r16,164(sp)
81131738:	da802417 	ldw	r10,144(sp)
8113173c:	1885883a 	add	r2,r3,r2
81131740:	40c00115 	stw	r3,4(r8)
81131744:	42800015 	stw	r10,0(r8)
81131748:	d8801c15 	stw	r2,112(sp)
8113174c:	d9401b15 	stw	r5,108(sp)
81131750:	00c001c4 	movi	r3,7
81131754:	19426016 	blt	r3,r5,811320d8 <___vfiprintf_internal_r+0xe70>
81131758:	d8c01d87 	ldb	r3,118(sp)
8113175c:	42000204 	addi	r8,r8,8
81131760:	29000044 	addi	r4,r5,1
81131764:	1801b31e 	bne	r3,zero,81131e34 <___vfiprintf_internal_r+0xbcc>
81131768:	7001c026 	beq	r14,zero,81131e6c <___vfiprintf_internal_r+0xc04>
8113176c:	d8c01d04 	addi	r3,sp,116
81131770:	10800084 	addi	r2,r2,2
81131774:	40c00015 	stw	r3,0(r8)
81131778:	00c00084 	movi	r3,2
8113177c:	40c00115 	stw	r3,4(r8)
81131780:	d8801c15 	stw	r2,112(sp)
81131784:	d9001b15 	stw	r4,108(sp)
81131788:	00c001c4 	movi	r3,7
8113178c:	1902650e 	bge	r3,r4,81132124 <___vfiprintf_internal_r+0xebc>
81131790:	10029a1e 	bne	r2,zero,811321fc <___vfiprintf_internal_r+0xf94>
81131794:	00c02004 	movi	r3,128
81131798:	01000044 	movi	r4,1
8113179c:	000b883a 	mov	r5,zero
811317a0:	d811883a 	mov	r8,sp
811317a4:	e0c1b31e 	bne	fp,r3,81131e74 <___vfiprintf_internal_r+0xc0c>
811317a8:	8cb9c83a 	sub	fp,r17,r18
811317ac:	0701b10e 	bge	zero,fp,81131e74 <___vfiprintf_internal_r+0xc0c>
811317b0:	01c00404 	movi	r7,16
811317b4:	3f03890e 	bge	r7,fp,811325dc <___vfiprintf_internal_r+0x1374>
811317b8:	00e04574 	movhi	r3,33045
811317bc:	18c19b04 	addi	r3,r3,1644
811317c0:	d8c02415 	stw	r3,144(sp)
811317c4:	8007883a 	mov	r3,r16
811317c8:	034001c4 	movi	r13,7
811317cc:	e021883a 	mov	r16,fp
811317d0:	da402515 	stw	r9,148(sp)
811317d4:	1839883a 	mov	fp,r3
811317d8:	00000506 	br	811317f0 <___vfiprintf_internal_r+0x588>
811317dc:	29800084 	addi	r6,r5,2
811317e0:	42000204 	addi	r8,r8,8
811317e4:	180b883a 	mov	r5,r3
811317e8:	843ffc04 	addi	r16,r16,-16
811317ec:	3c000d0e 	bge	r7,r16,81131824 <___vfiprintf_internal_r+0x5bc>
811317f0:	10800404 	addi	r2,r2,16
811317f4:	28c00044 	addi	r3,r5,1
811317f8:	45c00015 	stw	r23,0(r8)
811317fc:	41c00115 	stw	r7,4(r8)
81131800:	d8801c15 	stw	r2,112(sp)
81131804:	d8c01b15 	stw	r3,108(sp)
81131808:	68fff40e 	bge	r13,r3,811317dc <__reset+0xfb1117dc>
8113180c:	1002241e 	bne	r2,zero,811320a0 <___vfiprintf_internal_r+0xe38>
81131810:	843ffc04 	addi	r16,r16,-16
81131814:	01800044 	movi	r6,1
81131818:	000b883a 	mov	r5,zero
8113181c:	d811883a 	mov	r8,sp
81131820:	3c3ff316 	blt	r7,r16,811317f0 <__reset+0xfb1117f0>
81131824:	da402517 	ldw	r9,148(sp)
81131828:	e007883a 	mov	r3,fp
8113182c:	8039883a 	mov	fp,r16
81131830:	1821883a 	mov	r16,r3
81131834:	d8c02417 	ldw	r3,144(sp)
81131838:	1705883a 	add	r2,r2,fp
8113183c:	47000115 	stw	fp,4(r8)
81131840:	40c00015 	stw	r3,0(r8)
81131844:	d8801c15 	stw	r2,112(sp)
81131848:	d9801b15 	stw	r6,108(sp)
8113184c:	00c001c4 	movi	r3,7
81131850:	19827616 	blt	r3,r6,8113222c <___vfiprintf_internal_r+0xfc4>
81131854:	4cf9c83a 	sub	fp,r9,r19
81131858:	42000204 	addi	r8,r8,8
8113185c:	31000044 	addi	r4,r6,1
81131860:	300b883a 	mov	r5,r6
81131864:	07018516 	blt	zero,fp,81131e7c <___vfiprintf_internal_r+0xc14>
81131868:	9885883a 	add	r2,r19,r2
8113186c:	45400015 	stw	r21,0(r8)
81131870:	44c00115 	stw	r19,4(r8)
81131874:	d8801c15 	stw	r2,112(sp)
81131878:	d9001b15 	stw	r4,108(sp)
8113187c:	00c001c4 	movi	r3,7
81131880:	1901dd0e 	bge	r3,r4,81131ff8 <___vfiprintf_internal_r+0xd90>
81131884:	1002401e 	bne	r2,zero,81132188 <___vfiprintf_internal_r+0xf20>
81131888:	d8001b15 	stw	zero,108(sp)
8113188c:	a2c0010c 	andi	r11,r20,4
81131890:	58000226 	beq	r11,zero,8113189c <___vfiprintf_internal_r+0x634>
81131894:	8ca7c83a 	sub	r19,r17,r18
81131898:	04c2f216 	blt	zero,r19,81132464 <___vfiprintf_internal_r+0x11fc>
8113189c:	8c80010e 	bge	r17,r18,811318a4 <___vfiprintf_internal_r+0x63c>
811318a0:	9023883a 	mov	r17,r18
811318a4:	da802317 	ldw	r10,140(sp)
811318a8:	5455883a 	add	r10,r10,r17
811318ac:	da802315 	stw	r10,140(sp)
811318b0:	d8001b15 	stw	zero,108(sp)
811318b4:	d811883a 	mov	r8,sp
811318b8:	003ea206 	br	81131344 <__reset+0xfb111344>
811318bc:	a5000814 	ori	r20,r20,32
811318c0:	80c00007 	ldb	r3,0(r16)
811318c4:	003ec906 	br	811313ec <__reset+0xfb1113ec>
811318c8:	80c00007 	ldb	r3,0(r16)
811318cc:	1b030926 	beq	r3,r12,811324f4 <___vfiprintf_internal_r+0x128c>
811318d0:	a5000414 	ori	r20,r20,16
811318d4:	003ec506 	br	811313ec <__reset+0xfb1113ec>
811318d8:	21003fcc 	andi	r4,r4,255
811318dc:	20035e1e 	bne	r4,zero,81132658 <___vfiprintf_internal_r+0x13f0>
811318e0:	a080080c 	andi	r2,r20,32
811318e4:	1002a526 	beq	r2,zero,8113237c <___vfiprintf_internal_r+0x1114>
811318e8:	da802217 	ldw	r10,136(sp)
811318ec:	50800017 	ldw	r2,0(r10)
811318f0:	da802317 	ldw	r10,140(sp)
811318f4:	5007d7fa 	srai	r3,r10,31
811318f8:	da802217 	ldw	r10,136(sp)
811318fc:	10c00115 	stw	r3,4(r2)
81131900:	52800104 	addi	r10,r10,4
81131904:	da802215 	stw	r10,136(sp)
81131908:	da802317 	ldw	r10,140(sp)
8113190c:	12800015 	stw	r10,0(r2)
81131910:	003e8c06 	br	81131344 <__reset+0xfb111344>
81131914:	21003fcc 	andi	r4,r4,255
81131918:	2003511e 	bne	r4,zero,81132660 <___vfiprintf_internal_r+0x13f8>
8113191c:	a080080c 	andi	r2,r20,32
81131920:	1000a126 	beq	r2,zero,81131ba8 <___vfiprintf_internal_r+0x940>
81131924:	da802217 	ldw	r10,136(sp)
81131928:	d8001d85 	stb	zero,118(sp)
8113192c:	50800204 	addi	r2,r10,8
81131930:	54800017 	ldw	r18,0(r10)
81131934:	54c00117 	ldw	r19,4(r10)
81131938:	4802b416 	blt	r9,zero,8113240c <___vfiprintf_internal_r+0x11a4>
8113193c:	013fdfc4 	movi	r4,-129
81131940:	94c6b03a 	or	r3,r18,r19
81131944:	d8802215 	stw	r2,136(sp)
81131948:	a128703a 	and	r20,r20,r4
8113194c:	1800a226 	beq	r3,zero,81131bd8 <___vfiprintf_internal_r+0x970>
81131950:	0039883a 	mov	fp,zero
81131954:	dd401a04 	addi	r21,sp,104
81131958:	9006d0fa 	srli	r3,r18,3
8113195c:	9808977a 	slli	r4,r19,29
81131960:	9826d0fa 	srli	r19,r19,3
81131964:	948001cc 	andi	r18,r18,7
81131968:	90800c04 	addi	r2,r18,48
8113196c:	ad7fffc4 	addi	r21,r21,-1
81131970:	20e4b03a 	or	r18,r4,r3
81131974:	a8800005 	stb	r2,0(r21)
81131978:	94c6b03a 	or	r3,r18,r19
8113197c:	183ff61e 	bne	r3,zero,81131958 <__reset+0xfb111958>
81131980:	a0c0004c 	andi	r3,r20,1
81131984:	18005926 	beq	r3,zero,81131aec <___vfiprintf_internal_r+0x884>
81131988:	10803fcc 	andi	r2,r2,255
8113198c:	1080201c 	xori	r2,r2,128
81131990:	10bfe004 	addi	r2,r2,-128
81131994:	00c00c04 	movi	r3,48
81131998:	10c05426 	beq	r2,r3,81131aec <___vfiprintf_internal_r+0x884>
8113199c:	da801e17 	ldw	r10,120(sp)
811319a0:	a8bfffc4 	addi	r2,r21,-1
811319a4:	a8ffffc5 	stb	r3,-1(r21)
811319a8:	50a7c83a 	sub	r19,r10,r2
811319ac:	102b883a 	mov	r21,r2
811319b0:	003f2f06 	br	81131670 <__reset+0xfb111670>
811319b4:	21003fcc 	andi	r4,r4,255
811319b8:	2003421e 	bne	r4,zero,811326c4 <___vfiprintf_internal_r+0x145c>
811319bc:	00a04574 	movhi	r2,33045
811319c0:	10810904 	addi	r2,r2,1060
811319c4:	d8802615 	stw	r2,152(sp)
811319c8:	a080080c 	andi	r2,r20,32
811319cc:	1000aa26 	beq	r2,zero,81131c78 <___vfiprintf_internal_r+0xa10>
811319d0:	da802217 	ldw	r10,136(sp)
811319d4:	54800017 	ldw	r18,0(r10)
811319d8:	54c00117 	ldw	r19,4(r10)
811319dc:	52800204 	addi	r10,r10,8
811319e0:	da802215 	stw	r10,136(sp)
811319e4:	a080004c 	andi	r2,r20,1
811319e8:	1001d226 	beq	r2,zero,81132134 <___vfiprintf_internal_r+0xecc>
811319ec:	94c4b03a 	or	r2,r18,r19
811319f0:	1002351e 	bne	r2,zero,811322c8 <___vfiprintf_internal_r+0x1060>
811319f4:	d8001d85 	stb	zero,118(sp)
811319f8:	48022216 	blt	r9,zero,81132284 <___vfiprintf_internal_r+0x101c>
811319fc:	00bfdfc4 	movi	r2,-129
81131a00:	a0a8703a 	and	r20,r20,r2
81131a04:	003f1506 	br	8113165c <__reset+0xfb11165c>
81131a08:	da802217 	ldw	r10,136(sp)
81131a0c:	04800044 	movi	r18,1
81131a10:	d8001d85 	stb	zero,118(sp)
81131a14:	50800017 	ldw	r2,0(r10)
81131a18:	52800104 	addi	r10,r10,4
81131a1c:	da802215 	stw	r10,136(sp)
81131a20:	d8801005 	stb	r2,64(sp)
81131a24:	9027883a 	mov	r19,r18
81131a28:	dd401004 	addi	r21,sp,64
81131a2c:	0013883a 	mov	r9,zero
81131a30:	003f1706 	br	81131690 <__reset+0xfb111690>
81131a34:	21003fcc 	andi	r4,r4,255
81131a38:	2003201e 	bne	r4,zero,811326bc <___vfiprintf_internal_r+0x1454>
81131a3c:	a080080c 	andi	r2,r20,32
81131a40:	10004b26 	beq	r2,zero,81131b70 <___vfiprintf_internal_r+0x908>
81131a44:	da802217 	ldw	r10,136(sp)
81131a48:	50800117 	ldw	r2,4(r10)
81131a4c:	54800017 	ldw	r18,0(r10)
81131a50:	52800204 	addi	r10,r10,8
81131a54:	da802215 	stw	r10,136(sp)
81131a58:	1027883a 	mov	r19,r2
81131a5c:	10022c16 	blt	r2,zero,81132310 <___vfiprintf_internal_r+0x10a8>
81131a60:	df001d83 	ldbu	fp,118(sp)
81131a64:	48007216 	blt	r9,zero,81131c30 <___vfiprintf_internal_r+0x9c8>
81131a68:	00ffdfc4 	movi	r3,-129
81131a6c:	94c4b03a 	or	r2,r18,r19
81131a70:	a0e8703a 	and	r20,r20,r3
81131a74:	1000cc26 	beq	r2,zero,81131da8 <___vfiprintf_internal_r+0xb40>
81131a78:	98021026 	beq	r19,zero,811322bc <___vfiprintf_internal_r+0x1054>
81131a7c:	dc402415 	stw	r17,144(sp)
81131a80:	dc002515 	stw	r16,148(sp)
81131a84:	9823883a 	mov	r17,r19
81131a88:	9021883a 	mov	r16,r18
81131a8c:	dd401a04 	addi	r21,sp,104
81131a90:	4825883a 	mov	r18,r9
81131a94:	4027883a 	mov	r19,r8
81131a98:	8009883a 	mov	r4,r16
81131a9c:	880b883a 	mov	r5,r17
81131aa0:	01800284 	movi	r6,10
81131aa4:	000f883a 	mov	r7,zero
81131aa8:	1133f880 	call	81133f88 <__umoddi3>
81131aac:	10800c04 	addi	r2,r2,48
81131ab0:	ad7fffc4 	addi	r21,r21,-1
81131ab4:	8009883a 	mov	r4,r16
81131ab8:	880b883a 	mov	r5,r17
81131abc:	a8800005 	stb	r2,0(r21)
81131ac0:	01800284 	movi	r6,10
81131ac4:	000f883a 	mov	r7,zero
81131ac8:	1133a080 	call	81133a08 <__udivdi3>
81131acc:	1021883a 	mov	r16,r2
81131ad0:	10c4b03a 	or	r2,r2,r3
81131ad4:	1823883a 	mov	r17,r3
81131ad8:	103fef1e 	bne	r2,zero,81131a98 <__reset+0xfb111a98>
81131adc:	dc402417 	ldw	r17,144(sp)
81131ae0:	dc002517 	ldw	r16,148(sp)
81131ae4:	9013883a 	mov	r9,r18
81131ae8:	9811883a 	mov	r8,r19
81131aec:	da801e17 	ldw	r10,120(sp)
81131af0:	5567c83a 	sub	r19,r10,r21
81131af4:	003ede06 	br	81131670 <__reset+0xfb111670>
81131af8:	38803fcc 	andi	r2,r7,255
81131afc:	1080201c 	xori	r2,r2,128
81131b00:	10bfe004 	addi	r2,r2,-128
81131b04:	1002371e 	bne	r2,zero,811323e4 <___vfiprintf_internal_r+0x117c>
81131b08:	01000044 	movi	r4,1
81131b0c:	01c00804 	movi	r7,32
81131b10:	80c00007 	ldb	r3,0(r16)
81131b14:	003e3506 	br	811313ec <__reset+0xfb1113ec>
81131b18:	a5000054 	ori	r20,r20,1
81131b1c:	80c00007 	ldb	r3,0(r16)
81131b20:	003e3206 	br	811313ec <__reset+0xfb1113ec>
81131b24:	a5002014 	ori	r20,r20,128
81131b28:	80c00007 	ldb	r3,0(r16)
81131b2c:	003e2f06 	br	811313ec <__reset+0xfb1113ec>
81131b30:	8015883a 	mov	r10,r16
81131b34:	0023883a 	mov	r17,zero
81131b38:	18bff404 	addi	r2,r3,-48
81131b3c:	50c00007 	ldb	r3,0(r10)
81131b40:	8c4002a4 	muli	r17,r17,10
81131b44:	84000044 	addi	r16,r16,1
81131b48:	8015883a 	mov	r10,r16
81131b4c:	1463883a 	add	r17,r2,r17
81131b50:	18bff404 	addi	r2,r3,-48
81131b54:	30bff92e 	bgeu	r6,r2,81131b3c <__reset+0xfb111b3c>
81131b58:	003e2506 	br	811313f0 <__reset+0xfb1113f0>
81131b5c:	21003fcc 	andi	r4,r4,255
81131b60:	2002d41e 	bne	r4,zero,811326b4 <___vfiprintf_internal_r+0x144c>
81131b64:	a5000414 	ori	r20,r20,16
81131b68:	a080080c 	andi	r2,r20,32
81131b6c:	103fb51e 	bne	r2,zero,81131a44 <__reset+0xfb111a44>
81131b70:	a080040c 	andi	r2,r20,16
81131b74:	1001f826 	beq	r2,zero,81132358 <___vfiprintf_internal_r+0x10f0>
81131b78:	da802217 	ldw	r10,136(sp)
81131b7c:	54800017 	ldw	r18,0(r10)
81131b80:	52800104 	addi	r10,r10,4
81131b84:	da802215 	stw	r10,136(sp)
81131b88:	9027d7fa 	srai	r19,r18,31
81131b8c:	9805883a 	mov	r2,r19
81131b90:	003fb206 	br	81131a5c <__reset+0xfb111a5c>
81131b94:	21003fcc 	andi	r4,r4,255
81131b98:	2002c41e 	bne	r4,zero,811326ac <___vfiprintf_internal_r+0x1444>
81131b9c:	a5000414 	ori	r20,r20,16
81131ba0:	a080080c 	andi	r2,r20,32
81131ba4:	103f5f1e 	bne	r2,zero,81131924 <__reset+0xfb111924>
81131ba8:	a080040c 	andi	r2,r20,16
81131bac:	10020f26 	beq	r2,zero,811323ec <___vfiprintf_internal_r+0x1184>
81131bb0:	da802217 	ldw	r10,136(sp)
81131bb4:	d8001d85 	stb	zero,118(sp)
81131bb8:	0027883a 	mov	r19,zero
81131bbc:	50800104 	addi	r2,r10,4
81131bc0:	54800017 	ldw	r18,0(r10)
81131bc4:	48021116 	blt	r9,zero,8113240c <___vfiprintf_internal_r+0x11a4>
81131bc8:	00ffdfc4 	movi	r3,-129
81131bcc:	d8802215 	stw	r2,136(sp)
81131bd0:	a0e8703a 	and	r20,r20,r3
81131bd4:	903f5e1e 	bne	r18,zero,81131950 <__reset+0xfb111950>
81131bd8:	0039883a 	mov	fp,zero
81131bdc:	4802a626 	beq	r9,zero,81132678 <___vfiprintf_internal_r+0x1410>
81131be0:	0025883a 	mov	r18,zero
81131be4:	0027883a 	mov	r19,zero
81131be8:	003f5a06 	br	81131954 <__reset+0xfb111954>
81131bec:	21003fcc 	andi	r4,r4,255
81131bf0:	20029f1e 	bne	r4,zero,81132670 <___vfiprintf_internal_r+0x1408>
81131bf4:	a5000414 	ori	r20,r20,16
81131bf8:	a080080c 	andi	r2,r20,32
81131bfc:	10005e1e 	bne	r2,zero,81131d78 <___vfiprintf_internal_r+0xb10>
81131c00:	a080040c 	andi	r2,r20,16
81131c04:	1001a21e 	bne	r2,zero,81132290 <___vfiprintf_internal_r+0x1028>
81131c08:	a080100c 	andi	r2,r20,64
81131c0c:	d8001d85 	stb	zero,118(sp)
81131c10:	da802217 	ldw	r10,136(sp)
81131c14:	1002231e 	bne	r2,zero,811324a4 <___vfiprintf_internal_r+0x123c>
81131c18:	50800104 	addi	r2,r10,4
81131c1c:	54800017 	ldw	r18,0(r10)
81131c20:	0027883a 	mov	r19,zero
81131c24:	4801a00e 	bge	r9,zero,811322a8 <___vfiprintf_internal_r+0x1040>
81131c28:	d8802215 	stw	r2,136(sp)
81131c2c:	0039883a 	mov	fp,zero
81131c30:	94c4b03a 	or	r2,r18,r19
81131c34:	103f901e 	bne	r2,zero,81131a78 <__reset+0xfb111a78>
81131c38:	00800044 	movi	r2,1
81131c3c:	10803fcc 	andi	r2,r2,255
81131c40:	00c00044 	movi	r3,1
81131c44:	10c05926 	beq	r2,r3,81131dac <___vfiprintf_internal_r+0xb44>
81131c48:	00c00084 	movi	r3,2
81131c4c:	10ffe41e 	bne	r2,r3,81131be0 <__reset+0xfb111be0>
81131c50:	0025883a 	mov	r18,zero
81131c54:	0027883a 	mov	r19,zero
81131c58:	00013d06 	br	81132150 <___vfiprintf_internal_r+0xee8>
81131c5c:	21003fcc 	andi	r4,r4,255
81131c60:	2002811e 	bne	r4,zero,81132668 <___vfiprintf_internal_r+0x1400>
81131c64:	00a04574 	movhi	r2,33045
81131c68:	10810404 	addi	r2,r2,1040
81131c6c:	d8802615 	stw	r2,152(sp)
81131c70:	a080080c 	andi	r2,r20,32
81131c74:	103f561e 	bne	r2,zero,811319d0 <__reset+0xfb1119d0>
81131c78:	a080040c 	andi	r2,r20,16
81131c7c:	1001d126 	beq	r2,zero,811323c4 <___vfiprintf_internal_r+0x115c>
81131c80:	da802217 	ldw	r10,136(sp)
81131c84:	0027883a 	mov	r19,zero
81131c88:	54800017 	ldw	r18,0(r10)
81131c8c:	52800104 	addi	r10,r10,4
81131c90:	da802215 	stw	r10,136(sp)
81131c94:	003f5306 	br	811319e4 <__reset+0xfb1119e4>
81131c98:	da802217 	ldw	r10,136(sp)
81131c9c:	d8001d85 	stb	zero,118(sp)
81131ca0:	55400017 	ldw	r21,0(r10)
81131ca4:	50c00104 	addi	r3,r10,4
81131ca8:	a8024226 	beq	r21,zero,811325b4 <___vfiprintf_internal_r+0x134c>
81131cac:	48021816 	blt	r9,zero,81132510 <___vfiprintf_internal_r+0x12a8>
81131cb0:	480d883a 	mov	r6,r9
81131cb4:	000b883a 	mov	r5,zero
81131cb8:	a809883a 	mov	r4,r21
81131cbc:	d8c02a15 	stw	r3,168(sp)
81131cc0:	da002b15 	stw	r8,172(sp)
81131cc4:	da402c15 	stw	r9,176(sp)
81131cc8:	112c0440 	call	8112c044 <memchr>
81131ccc:	d8c02a17 	ldw	r3,168(sp)
81131cd0:	da002b17 	ldw	r8,172(sp)
81131cd4:	da402c17 	ldw	r9,176(sp)
81131cd8:	10024826 	beq	r2,zero,811325fc <___vfiprintf_internal_r+0x1394>
81131cdc:	1567c83a 	sub	r19,r2,r21
81131ce0:	df001d83 	ldbu	fp,118(sp)
81131ce4:	d8c02215 	stw	r3,136(sp)
81131ce8:	0013883a 	mov	r9,zero
81131cec:	003e6006 	br	81131670 <__reset+0xfb111670>
81131cf0:	21003fcc 	andi	r4,r4,255
81131cf4:	203fc026 	beq	r4,zero,81131bf8 <__reset+0xfb111bf8>
81131cf8:	d9c01d85 	stb	r7,118(sp)
81131cfc:	003fbe06 	br	81131bf8 <__reset+0xfb111bf8>
81131d00:	da802217 	ldw	r10,136(sp)
81131d04:	54400017 	ldw	r17,0(r10)
81131d08:	50800104 	addi	r2,r10,4
81131d0c:	883e3b16 	blt	r17,zero,811315fc <__reset+0xfb1115fc>
81131d10:	d8802215 	stw	r2,136(sp)
81131d14:	80c00007 	ldb	r3,0(r16)
81131d18:	003db406 	br	811313ec <__reset+0xfb1113ec>
81131d1c:	01000044 	movi	r4,1
81131d20:	01c00ac4 	movi	r7,43
81131d24:	80c00007 	ldb	r3,0(r16)
81131d28:	003db006 	br	811313ec <__reset+0xfb1113ec>
81131d2c:	80c00007 	ldb	r3,0(r16)
81131d30:	82800044 	addi	r10,r16,1
81131d34:	1b423c26 	beq	r3,r13,81132628 <___vfiprintf_internal_r+0x13c0>
81131d38:	18bff404 	addi	r2,r3,-48
81131d3c:	0013883a 	mov	r9,zero
81131d40:	30822b36 	bltu	r6,r2,811325f0 <___vfiprintf_internal_r+0x1388>
81131d44:	50c00007 	ldb	r3,0(r10)
81131d48:	4a4002a4 	muli	r9,r9,10
81131d4c:	54000044 	addi	r16,r10,1
81131d50:	8015883a 	mov	r10,r16
81131d54:	4893883a 	add	r9,r9,r2
81131d58:	18bff404 	addi	r2,r3,-48
81131d5c:	30bff92e 	bgeu	r6,r2,81131d44 <__reset+0xfb111d44>
81131d60:	483da30e 	bge	r9,zero,811313f0 <__reset+0xfb1113f0>
81131d64:	027fffc4 	movi	r9,-1
81131d68:	003da106 	br	811313f0 <__reset+0xfb1113f0>
81131d6c:	a5001014 	ori	r20,r20,64
81131d70:	80c00007 	ldb	r3,0(r16)
81131d74:	003d9d06 	br	811313ec <__reset+0xfb1113ec>
81131d78:	da802217 	ldw	r10,136(sp)
81131d7c:	d8001d85 	stb	zero,118(sp)
81131d80:	50c00204 	addi	r3,r10,8
81131d84:	54800017 	ldw	r18,0(r10)
81131d88:	54c00117 	ldw	r19,4(r10)
81131d8c:	4801ca16 	blt	r9,zero,811324b8 <___vfiprintf_internal_r+0x1250>
81131d90:	013fdfc4 	movi	r4,-129
81131d94:	94c4b03a 	or	r2,r18,r19
81131d98:	d8c02215 	stw	r3,136(sp)
81131d9c:	a128703a 	and	r20,r20,r4
81131da0:	0039883a 	mov	fp,zero
81131da4:	103f341e 	bne	r2,zero,81131a78 <__reset+0xfb111a78>
81131da8:	483e2e26 	beq	r9,zero,81131664 <__reset+0xfb111664>
81131dac:	0025883a 	mov	r18,zero
81131db0:	94800c04 	addi	r18,r18,48
81131db4:	dc8019c5 	stb	r18,103(sp)
81131db8:	dcc02717 	ldw	r19,156(sp)
81131dbc:	dd4019c4 	addi	r21,sp,103
81131dc0:	003e2b06 	br	81131670 <__reset+0xfb111670>
81131dc4:	21003fcc 	andi	r4,r4,255
81131dc8:	2002361e 	bne	r4,zero,811326a4 <___vfiprintf_internal_r+0x143c>
81131dcc:	1801c126 	beq	r3,zero,811324d4 <___vfiprintf_internal_r+0x126c>
81131dd0:	04800044 	movi	r18,1
81131dd4:	d8c01005 	stb	r3,64(sp)
81131dd8:	d8001d85 	stb	zero,118(sp)
81131ddc:	9027883a 	mov	r19,r18
81131de0:	dd401004 	addi	r21,sp,64
81131de4:	003f1106 	br	81131a2c <__reset+0xfb111a2c>
81131de8:	d9402117 	ldw	r5,132(sp)
81131dec:	d9002017 	ldw	r4,128(sp)
81131df0:	d9801a04 	addi	r6,sp,104
81131df4:	d9c02b15 	stw	r7,172(sp)
81131df8:	dbc02a15 	stw	r15,168(sp)
81131dfc:	113114c0 	call	8113114c <__sprint_r.part.0>
81131e00:	d9c02b17 	ldw	r7,172(sp)
81131e04:	dbc02a17 	ldw	r15,168(sp)
81131e08:	10006d1e 	bne	r2,zero,81131fc0 <___vfiprintf_internal_r+0xd58>
81131e0c:	d9801b17 	ldw	r6,108(sp)
81131e10:	d8801c17 	ldw	r2,112(sp)
81131e14:	d811883a 	mov	r8,sp
81131e18:	31400044 	addi	r5,r6,1
81131e1c:	003e3306 	br	811316ec <__reset+0xfb1116ec>
81131e20:	d9401b17 	ldw	r5,108(sp)
81131e24:	d8801c17 	ldw	r2,112(sp)
81131e28:	29000044 	addi	r4,r5,1
81131e2c:	d8c01d87 	ldb	r3,118(sp)
81131e30:	183e4d26 	beq	r3,zero,81131768 <__reset+0xfb111768>
81131e34:	00c00044 	movi	r3,1
81131e38:	d9401d84 	addi	r5,sp,118
81131e3c:	10c5883a 	add	r2,r2,r3
81131e40:	41400015 	stw	r5,0(r8)
81131e44:	40c00115 	stw	r3,4(r8)
81131e48:	d8801c15 	stw	r2,112(sp)
81131e4c:	d9001b15 	stw	r4,108(sp)
81131e50:	014001c4 	movi	r5,7
81131e54:	2900a90e 	bge	r5,r4,811320fc <___vfiprintf_internal_r+0xe94>
81131e58:	1000da1e 	bne	r2,zero,811321c4 <___vfiprintf_internal_r+0xf5c>
81131e5c:	7000ab1e 	bne	r14,zero,8113210c <___vfiprintf_internal_r+0xea4>
81131e60:	000b883a 	mov	r5,zero
81131e64:	1809883a 	mov	r4,r3
81131e68:	d811883a 	mov	r8,sp
81131e6c:	00c02004 	movi	r3,128
81131e70:	e0fe4d26 	beq	fp,r3,811317a8 <__reset+0xfb1117a8>
81131e74:	4cf9c83a 	sub	fp,r9,r19
81131e78:	073e7b0e 	bge	zero,fp,81131868 <__reset+0xfb111868>
81131e7c:	01c00404 	movi	r7,16
81131e80:	3f01900e 	bge	r7,fp,811324c4 <___vfiprintf_internal_r+0x125c>
81131e84:	00e04574 	movhi	r3,33045
81131e88:	18c19b04 	addi	r3,r3,1644
81131e8c:	d8c02415 	stw	r3,144(sp)
81131e90:	034001c4 	movi	r13,7
81131e94:	00000506 	br	81131eac <___vfiprintf_internal_r+0xc44>
81131e98:	29000084 	addi	r4,r5,2
81131e9c:	42000204 	addi	r8,r8,8
81131ea0:	180b883a 	mov	r5,r3
81131ea4:	e73ffc04 	addi	fp,fp,-16
81131ea8:	3f000d0e 	bge	r7,fp,81131ee0 <___vfiprintf_internal_r+0xc78>
81131eac:	10800404 	addi	r2,r2,16
81131eb0:	28c00044 	addi	r3,r5,1
81131eb4:	45c00015 	stw	r23,0(r8)
81131eb8:	41c00115 	stw	r7,4(r8)
81131ebc:	d8801c15 	stw	r2,112(sp)
81131ec0:	d8c01b15 	stw	r3,108(sp)
81131ec4:	68fff40e 	bge	r13,r3,81131e98 <__reset+0xfb111e98>
81131ec8:	1000101e 	bne	r2,zero,81131f0c <___vfiprintf_internal_r+0xca4>
81131ecc:	e73ffc04 	addi	fp,fp,-16
81131ed0:	01000044 	movi	r4,1
81131ed4:	000b883a 	mov	r5,zero
81131ed8:	d811883a 	mov	r8,sp
81131edc:	3f3ff316 	blt	r7,fp,81131eac <__reset+0xfb111eac>
81131ee0:	da802417 	ldw	r10,144(sp)
81131ee4:	1705883a 	add	r2,r2,fp
81131ee8:	47000115 	stw	fp,4(r8)
81131eec:	42800015 	stw	r10,0(r8)
81131ef0:	d8801c15 	stw	r2,112(sp)
81131ef4:	d9001b15 	stw	r4,108(sp)
81131ef8:	00c001c4 	movi	r3,7
81131efc:	19003616 	blt	r3,r4,81131fd8 <___vfiprintf_internal_r+0xd70>
81131f00:	42000204 	addi	r8,r8,8
81131f04:	21000044 	addi	r4,r4,1
81131f08:	003e5706 	br	81131868 <__reset+0xfb111868>
81131f0c:	d9402117 	ldw	r5,132(sp)
81131f10:	d9002017 	ldw	r4,128(sp)
81131f14:	d9801a04 	addi	r6,sp,104
81131f18:	d9c02b15 	stw	r7,172(sp)
81131f1c:	db402a15 	stw	r13,168(sp)
81131f20:	113114c0 	call	8113114c <__sprint_r.part.0>
81131f24:	d9c02b17 	ldw	r7,172(sp)
81131f28:	db402a17 	ldw	r13,168(sp)
81131f2c:	1000241e 	bne	r2,zero,81131fc0 <___vfiprintf_internal_r+0xd58>
81131f30:	d9401b17 	ldw	r5,108(sp)
81131f34:	d8801c17 	ldw	r2,112(sp)
81131f38:	d811883a 	mov	r8,sp
81131f3c:	29000044 	addi	r4,r5,1
81131f40:	003fd806 	br	81131ea4 <__reset+0xfb111ea4>
81131f44:	d9401b17 	ldw	r5,108(sp)
81131f48:	00e04574 	movhi	r3,33045
81131f4c:	18c19f04 	addi	r3,r3,1660
81131f50:	d8c02415 	stw	r3,144(sp)
81131f54:	29400044 	addi	r5,r5,1
81131f58:	d8c02417 	ldw	r3,144(sp)
81131f5c:	14c5883a 	add	r2,r2,r19
81131f60:	44c00115 	stw	r19,4(r8)
81131f64:	40c00015 	stw	r3,0(r8)
81131f68:	d8801c15 	stw	r2,112(sp)
81131f6c:	d9401b15 	stw	r5,108(sp)
81131f70:	00c001c4 	movi	r3,7
81131f74:	1940070e 	bge	r3,r5,81131f94 <___vfiprintf_internal_r+0xd2c>
81131f78:	103e4826 	beq	r2,zero,8113189c <__reset+0xfb11189c>
81131f7c:	d9402117 	ldw	r5,132(sp)
81131f80:	d9002017 	ldw	r4,128(sp)
81131f84:	d9801a04 	addi	r6,sp,104
81131f88:	113114c0 	call	8113114c <__sprint_r.part.0>
81131f8c:	10000c1e 	bne	r2,zero,81131fc0 <___vfiprintf_internal_r+0xd58>
81131f90:	d8801c17 	ldw	r2,112(sp)
81131f94:	8c80010e 	bge	r17,r18,81131f9c <___vfiprintf_internal_r+0xd34>
81131f98:	9023883a 	mov	r17,r18
81131f9c:	da802317 	ldw	r10,140(sp)
81131fa0:	5455883a 	add	r10,r10,r17
81131fa4:	da802315 	stw	r10,140(sp)
81131fa8:	103e4126 	beq	r2,zero,811318b0 <__reset+0xfb1118b0>
81131fac:	d9402117 	ldw	r5,132(sp)
81131fb0:	d9002017 	ldw	r4,128(sp)
81131fb4:	d9801a04 	addi	r6,sp,104
81131fb8:	113114c0 	call	8113114c <__sprint_r.part.0>
81131fbc:	103e3c26 	beq	r2,zero,811318b0 <__reset+0xfb1118b0>
81131fc0:	dd002117 	ldw	r20,132(sp)
81131fc4:	a080030b 	ldhu	r2,12(r20)
81131fc8:	1080100c 	andi	r2,r2,64
81131fcc:	1001231e 	bne	r2,zero,8113245c <___vfiprintf_internal_r+0x11f4>
81131fd0:	d8802317 	ldw	r2,140(sp)
81131fd4:	003d7b06 	br	811315c4 <__reset+0xfb1115c4>
81131fd8:	1000991e 	bne	r2,zero,81132240 <___vfiprintf_internal_r+0xfd8>
81131fdc:	00c00044 	movi	r3,1
81131fe0:	9805883a 	mov	r2,r19
81131fe4:	dd400015 	stw	r21,0(sp)
81131fe8:	dcc00115 	stw	r19,4(sp)
81131fec:	dcc01c15 	stw	r19,112(sp)
81131ff0:	d8c01b15 	stw	r3,108(sp)
81131ff4:	d811883a 	mov	r8,sp
81131ff8:	42000204 	addi	r8,r8,8
81131ffc:	a2c0010c 	andi	r11,r20,4
81132000:	583fe426 	beq	r11,zero,81131f94 <__reset+0xfb111f94>
81132004:	8ca7c83a 	sub	r19,r17,r18
81132008:	04ffe20e 	bge	zero,r19,81131f94 <__reset+0xfb111f94>
8113200c:	01c00404 	movi	r7,16
81132010:	3cffcc0e 	bge	r7,r19,81131f44 <__reset+0xfb111f44>
81132014:	02a04574 	movhi	r10,33045
81132018:	52819f04 	addi	r10,r10,1660
8113201c:	d9001b17 	ldw	r4,108(sp)
81132020:	da802415 	stw	r10,144(sp)
81132024:	382b883a 	mov	r21,r7
81132028:	050001c4 	movi	r20,7
8113202c:	df002017 	ldw	fp,128(sp)
81132030:	00000506 	br	81132048 <___vfiprintf_internal_r+0xde0>
81132034:	21400084 	addi	r5,r4,2
81132038:	42000204 	addi	r8,r8,8
8113203c:	1809883a 	mov	r4,r3
81132040:	9cfffc04 	addi	r19,r19,-16
81132044:	acffc40e 	bge	r21,r19,81131f58 <__reset+0xfb111f58>
81132048:	10800404 	addi	r2,r2,16
8113204c:	20c00044 	addi	r3,r4,1
81132050:	45800015 	stw	r22,0(r8)
81132054:	45400115 	stw	r21,4(r8)
81132058:	d8801c15 	stw	r2,112(sp)
8113205c:	d8c01b15 	stw	r3,108(sp)
81132060:	a0fff40e 	bge	r20,r3,81132034 <__reset+0xfb112034>
81132064:	1000041e 	bne	r2,zero,81132078 <___vfiprintf_internal_r+0xe10>
81132068:	01400044 	movi	r5,1
8113206c:	0009883a 	mov	r4,zero
81132070:	d811883a 	mov	r8,sp
81132074:	003ff206 	br	81132040 <__reset+0xfb112040>
81132078:	d9402117 	ldw	r5,132(sp)
8113207c:	d9801a04 	addi	r6,sp,104
81132080:	e009883a 	mov	r4,fp
81132084:	113114c0 	call	8113114c <__sprint_r.part.0>
81132088:	103fcd1e 	bne	r2,zero,81131fc0 <__reset+0xfb111fc0>
8113208c:	d9001b17 	ldw	r4,108(sp)
81132090:	d8801c17 	ldw	r2,112(sp)
81132094:	d811883a 	mov	r8,sp
81132098:	21400044 	addi	r5,r4,1
8113209c:	003fe806 	br	81132040 <__reset+0xfb112040>
811320a0:	d9402117 	ldw	r5,132(sp)
811320a4:	d9002017 	ldw	r4,128(sp)
811320a8:	d9801a04 	addi	r6,sp,104
811320ac:	d9c02b15 	stw	r7,172(sp)
811320b0:	db402a15 	stw	r13,168(sp)
811320b4:	113114c0 	call	8113114c <__sprint_r.part.0>
811320b8:	d9c02b17 	ldw	r7,172(sp)
811320bc:	db402a17 	ldw	r13,168(sp)
811320c0:	103fbf1e 	bne	r2,zero,81131fc0 <__reset+0xfb111fc0>
811320c4:	d9401b17 	ldw	r5,108(sp)
811320c8:	d8801c17 	ldw	r2,112(sp)
811320cc:	d811883a 	mov	r8,sp
811320d0:	29800044 	addi	r6,r5,1
811320d4:	003dc406 	br	811317e8 <__reset+0xfb1117e8>
811320d8:	1000d21e 	bne	r2,zero,81132424 <___vfiprintf_internal_r+0x11bc>
811320dc:	d8c01d87 	ldb	r3,118(sp)
811320e0:	18009526 	beq	r3,zero,81132338 <___vfiprintf_internal_r+0x10d0>
811320e4:	00800044 	movi	r2,1
811320e8:	d8c01d84 	addi	r3,sp,118
811320ec:	1009883a 	mov	r4,r2
811320f0:	d8c00015 	stw	r3,0(sp)
811320f4:	d8800115 	stw	r2,4(sp)
811320f8:	d811883a 	mov	r8,sp
811320fc:	200b883a 	mov	r5,r4
81132100:	42000204 	addi	r8,r8,8
81132104:	21000044 	addi	r4,r4,1
81132108:	003d9706 	br	81131768 <__reset+0xfb111768>
8113210c:	d9001d04 	addi	r4,sp,116
81132110:	00800084 	movi	r2,2
81132114:	d9000015 	stw	r4,0(sp)
81132118:	d8800115 	stw	r2,4(sp)
8113211c:	1809883a 	mov	r4,r3
81132120:	d811883a 	mov	r8,sp
81132124:	200b883a 	mov	r5,r4
81132128:	42000204 	addi	r8,r8,8
8113212c:	21000044 	addi	r4,r4,1
81132130:	003f4e06 	br	81131e6c <__reset+0xfb111e6c>
81132134:	d8001d85 	stb	zero,118(sp)
81132138:	48005016 	blt	r9,zero,8113227c <___vfiprintf_internal_r+0x1014>
8113213c:	00ffdfc4 	movi	r3,-129
81132140:	94c4b03a 	or	r2,r18,r19
81132144:	a0e8703a 	and	r20,r20,r3
81132148:	103d4426 	beq	r2,zero,8113165c <__reset+0xfb11165c>
8113214c:	0039883a 	mov	fp,zero
81132150:	d9002617 	ldw	r4,152(sp)
81132154:	dd401a04 	addi	r21,sp,104
81132158:	908003cc 	andi	r2,r18,15
8113215c:	9806973a 	slli	r3,r19,28
81132160:	2085883a 	add	r2,r4,r2
81132164:	9024d13a 	srli	r18,r18,4
81132168:	10800003 	ldbu	r2,0(r2)
8113216c:	9826d13a 	srli	r19,r19,4
81132170:	ad7fffc4 	addi	r21,r21,-1
81132174:	1ca4b03a 	or	r18,r3,r18
81132178:	a8800005 	stb	r2,0(r21)
8113217c:	94c4b03a 	or	r2,r18,r19
81132180:	103ff51e 	bne	r2,zero,81132158 <__reset+0xfb112158>
81132184:	003e5906 	br	81131aec <__reset+0xfb111aec>
81132188:	d9402117 	ldw	r5,132(sp)
8113218c:	d9002017 	ldw	r4,128(sp)
81132190:	d9801a04 	addi	r6,sp,104
81132194:	113114c0 	call	8113114c <__sprint_r.part.0>
81132198:	103f891e 	bne	r2,zero,81131fc0 <__reset+0xfb111fc0>
8113219c:	d8801c17 	ldw	r2,112(sp)
811321a0:	d811883a 	mov	r8,sp
811321a4:	003f9506 	br	81131ffc <__reset+0xfb111ffc>
811321a8:	d9402117 	ldw	r5,132(sp)
811321ac:	d9002017 	ldw	r4,128(sp)
811321b0:	d9801a04 	addi	r6,sp,104
811321b4:	113114c0 	call	8113114c <__sprint_r.part.0>
811321b8:	103f811e 	bne	r2,zero,81131fc0 <__reset+0xfb111fc0>
811321bc:	d811883a 	mov	r8,sp
811321c0:	003ced06 	br	81131578 <__reset+0xfb111578>
811321c4:	d9402117 	ldw	r5,132(sp)
811321c8:	d9002017 	ldw	r4,128(sp)
811321cc:	d9801a04 	addi	r6,sp,104
811321d0:	da402c15 	stw	r9,176(sp)
811321d4:	db802a15 	stw	r14,168(sp)
811321d8:	113114c0 	call	8113114c <__sprint_r.part.0>
811321dc:	da402c17 	ldw	r9,176(sp)
811321e0:	db802a17 	ldw	r14,168(sp)
811321e4:	103f761e 	bne	r2,zero,81131fc0 <__reset+0xfb111fc0>
811321e8:	d9401b17 	ldw	r5,108(sp)
811321ec:	d8801c17 	ldw	r2,112(sp)
811321f0:	d811883a 	mov	r8,sp
811321f4:	29000044 	addi	r4,r5,1
811321f8:	003d5b06 	br	81131768 <__reset+0xfb111768>
811321fc:	d9402117 	ldw	r5,132(sp)
81132200:	d9002017 	ldw	r4,128(sp)
81132204:	d9801a04 	addi	r6,sp,104
81132208:	da402c15 	stw	r9,176(sp)
8113220c:	113114c0 	call	8113114c <__sprint_r.part.0>
81132210:	da402c17 	ldw	r9,176(sp)
81132214:	103f6a1e 	bne	r2,zero,81131fc0 <__reset+0xfb111fc0>
81132218:	d9401b17 	ldw	r5,108(sp)
8113221c:	d8801c17 	ldw	r2,112(sp)
81132220:	d811883a 	mov	r8,sp
81132224:	29000044 	addi	r4,r5,1
81132228:	003f1006 	br	81131e6c <__reset+0xfb111e6c>
8113222c:	1000c31e 	bne	r2,zero,8113253c <___vfiprintf_internal_r+0x12d4>
81132230:	01000044 	movi	r4,1
81132234:	000b883a 	mov	r5,zero
81132238:	d811883a 	mov	r8,sp
8113223c:	003f0d06 	br	81131e74 <__reset+0xfb111e74>
81132240:	d9402117 	ldw	r5,132(sp)
81132244:	d9002017 	ldw	r4,128(sp)
81132248:	d9801a04 	addi	r6,sp,104
8113224c:	113114c0 	call	8113114c <__sprint_r.part.0>
81132250:	103f5b1e 	bne	r2,zero,81131fc0 <__reset+0xfb111fc0>
81132254:	d9001b17 	ldw	r4,108(sp)
81132258:	d8801c17 	ldw	r2,112(sp)
8113225c:	d811883a 	mov	r8,sp
81132260:	21000044 	addi	r4,r4,1
81132264:	003d8006 	br	81131868 <__reset+0xfb111868>
81132268:	01204574 	movhi	r4,33045
8113226c:	21010904 	addi	r4,r4,1060
81132270:	d9002615 	stw	r4,152(sp)
81132274:	d8c02215 	stw	r3,136(sp)
81132278:	1029883a 	mov	r20,r2
8113227c:	94c4b03a 	or	r2,r18,r19
81132280:	103fb21e 	bne	r2,zero,8113214c <__reset+0xfb11214c>
81132284:	0039883a 	mov	fp,zero
81132288:	00800084 	movi	r2,2
8113228c:	003e6b06 	br	81131c3c <__reset+0xfb111c3c>
81132290:	da802217 	ldw	r10,136(sp)
81132294:	d8001d85 	stb	zero,118(sp)
81132298:	0027883a 	mov	r19,zero
8113229c:	50800104 	addi	r2,r10,4
811322a0:	54800017 	ldw	r18,0(r10)
811322a4:	483e6016 	blt	r9,zero,81131c28 <__reset+0xfb111c28>
811322a8:	00ffdfc4 	movi	r3,-129
811322ac:	d8802215 	stw	r2,136(sp)
811322b0:	a0e8703a 	and	r20,r20,r3
811322b4:	0039883a 	mov	fp,zero
811322b8:	903ebb26 	beq	r18,zero,81131da8 <__reset+0xfb111da8>
811322bc:	00800244 	movi	r2,9
811322c0:	14bdee36 	bltu	r2,r18,81131a7c <__reset+0xfb111a7c>
811322c4:	003eba06 	br	81131db0 <__reset+0xfb111db0>
811322c8:	00800c04 	movi	r2,48
811322cc:	d8c01d45 	stb	r3,117(sp)
811322d0:	d8801d05 	stb	r2,116(sp)
811322d4:	d8001d85 	stb	zero,118(sp)
811322d8:	a0c00094 	ori	r3,r20,2
811322dc:	4800a916 	blt	r9,zero,81132584 <___vfiprintf_internal_r+0x131c>
811322e0:	00bfdfc4 	movi	r2,-129
811322e4:	a096703a 	and	r11,r20,r2
811322e8:	5d000094 	ori	r20,r11,2
811322ec:	0039883a 	mov	fp,zero
811322f0:	003f9706 	br	81132150 <__reset+0xfb112150>
811322f4:	8025883a 	mov	r18,r16
811322f8:	003c2e06 	br	811313b4 <__reset+0xfb1113b4>
811322fc:	00a04574 	movhi	r2,33045
81132300:	10810904 	addi	r2,r2,1060
81132304:	0039883a 	mov	fp,zero
81132308:	d8802615 	stw	r2,152(sp)
8113230c:	003f9006 	br	81132150 <__reset+0xfb112150>
81132310:	04a5c83a 	sub	r18,zero,r18
81132314:	07000b44 	movi	fp,45
81132318:	9004c03a 	cmpne	r2,r18,zero
8113231c:	04e7c83a 	sub	r19,zero,r19
81132320:	df001d85 	stb	fp,118(sp)
81132324:	98a7c83a 	sub	r19,r19,r2
81132328:	48009f16 	blt	r9,zero,811325a8 <___vfiprintf_internal_r+0x1340>
8113232c:	00bfdfc4 	movi	r2,-129
81132330:	a0a8703a 	and	r20,r20,r2
81132334:	003dd006 	br	81131a78 <__reset+0xfb111a78>
81132338:	70004c26 	beq	r14,zero,8113246c <___vfiprintf_internal_r+0x1204>
8113233c:	00800084 	movi	r2,2
81132340:	d8c01d04 	addi	r3,sp,116
81132344:	d8c00015 	stw	r3,0(sp)
81132348:	d8800115 	stw	r2,4(sp)
8113234c:	01000044 	movi	r4,1
81132350:	d811883a 	mov	r8,sp
81132354:	003f7306 	br	81132124 <__reset+0xfb112124>
81132358:	a080100c 	andi	r2,r20,64
8113235c:	da802217 	ldw	r10,136(sp)
81132360:	103e0626 	beq	r2,zero,81131b7c <__reset+0xfb111b7c>
81132364:	5480000f 	ldh	r18,0(r10)
81132368:	52800104 	addi	r10,r10,4
8113236c:	da802215 	stw	r10,136(sp)
81132370:	9027d7fa 	srai	r19,r18,31
81132374:	9805883a 	mov	r2,r19
81132378:	003db806 	br	81131a5c <__reset+0xfb111a5c>
8113237c:	a080040c 	andi	r2,r20,16
81132380:	1000091e 	bne	r2,zero,811323a8 <___vfiprintf_internal_r+0x1140>
81132384:	a2c0100c 	andi	r11,r20,64
81132388:	58000726 	beq	r11,zero,811323a8 <___vfiprintf_internal_r+0x1140>
8113238c:	da802217 	ldw	r10,136(sp)
81132390:	50800017 	ldw	r2,0(r10)
81132394:	52800104 	addi	r10,r10,4
81132398:	da802215 	stw	r10,136(sp)
8113239c:	da802317 	ldw	r10,140(sp)
811323a0:	1280000d 	sth	r10,0(r2)
811323a4:	003be706 	br	81131344 <__reset+0xfb111344>
811323a8:	da802217 	ldw	r10,136(sp)
811323ac:	50800017 	ldw	r2,0(r10)
811323b0:	52800104 	addi	r10,r10,4
811323b4:	da802215 	stw	r10,136(sp)
811323b8:	da802317 	ldw	r10,140(sp)
811323bc:	12800015 	stw	r10,0(r2)
811323c0:	003be006 	br	81131344 <__reset+0xfb111344>
811323c4:	a080100c 	andi	r2,r20,64
811323c8:	da802217 	ldw	r10,136(sp)
811323cc:	10003026 	beq	r2,zero,81132490 <___vfiprintf_internal_r+0x1228>
811323d0:	5480000b 	ldhu	r18,0(r10)
811323d4:	52800104 	addi	r10,r10,4
811323d8:	0027883a 	mov	r19,zero
811323dc:	da802215 	stw	r10,136(sp)
811323e0:	003d8006 	br	811319e4 <__reset+0xfb1119e4>
811323e4:	80c00007 	ldb	r3,0(r16)
811323e8:	003c0006 	br	811313ec <__reset+0xfb1113ec>
811323ec:	a080100c 	andi	r2,r20,64
811323f0:	d8001d85 	stb	zero,118(sp)
811323f4:	da802217 	ldw	r10,136(sp)
811323f8:	1000201e 	bne	r2,zero,8113247c <___vfiprintf_internal_r+0x1214>
811323fc:	50800104 	addi	r2,r10,4
81132400:	54800017 	ldw	r18,0(r10)
81132404:	0027883a 	mov	r19,zero
81132408:	483def0e 	bge	r9,zero,81131bc8 <__reset+0xfb111bc8>
8113240c:	94c6b03a 	or	r3,r18,r19
81132410:	d8802215 	stw	r2,136(sp)
81132414:	183d4e1e 	bne	r3,zero,81131950 <__reset+0xfb111950>
81132418:	0039883a 	mov	fp,zero
8113241c:	0005883a 	mov	r2,zero
81132420:	003e0606 	br	81131c3c <__reset+0xfb111c3c>
81132424:	d9402117 	ldw	r5,132(sp)
81132428:	d9002017 	ldw	r4,128(sp)
8113242c:	d9801a04 	addi	r6,sp,104
81132430:	da402c15 	stw	r9,176(sp)
81132434:	db802a15 	stw	r14,168(sp)
81132438:	113114c0 	call	8113114c <__sprint_r.part.0>
8113243c:	da402c17 	ldw	r9,176(sp)
81132440:	db802a17 	ldw	r14,168(sp)
81132444:	103ede1e 	bne	r2,zero,81131fc0 <__reset+0xfb111fc0>
81132448:	d9401b17 	ldw	r5,108(sp)
8113244c:	d8801c17 	ldw	r2,112(sp)
81132450:	d811883a 	mov	r8,sp
81132454:	29000044 	addi	r4,r5,1
81132458:	003e7406 	br	81131e2c <__reset+0xfb111e2c>
8113245c:	00bfffc4 	movi	r2,-1
81132460:	003c5806 	br	811315c4 <__reset+0xfb1115c4>
81132464:	d811883a 	mov	r8,sp
81132468:	003ee806 	br	8113200c <__reset+0xfb11200c>
8113246c:	000b883a 	mov	r5,zero
81132470:	01000044 	movi	r4,1
81132474:	d811883a 	mov	r8,sp
81132478:	003e7c06 	br	81131e6c <__reset+0xfb111e6c>
8113247c:	50800104 	addi	r2,r10,4
81132480:	5480000b 	ldhu	r18,0(r10)
81132484:	0027883a 	mov	r19,zero
81132488:	483dcf0e 	bge	r9,zero,81131bc8 <__reset+0xfb111bc8>
8113248c:	003fdf06 	br	8113240c <__reset+0xfb11240c>
81132490:	54800017 	ldw	r18,0(r10)
81132494:	52800104 	addi	r10,r10,4
81132498:	0027883a 	mov	r19,zero
8113249c:	da802215 	stw	r10,136(sp)
811324a0:	003d5006 	br	811319e4 <__reset+0xfb1119e4>
811324a4:	50800104 	addi	r2,r10,4
811324a8:	5480000b 	ldhu	r18,0(r10)
811324ac:	0027883a 	mov	r19,zero
811324b0:	483f7d0e 	bge	r9,zero,811322a8 <__reset+0xfb1122a8>
811324b4:	003ddc06 	br	81131c28 <__reset+0xfb111c28>
811324b8:	d8c02215 	stw	r3,136(sp)
811324bc:	0039883a 	mov	fp,zero
811324c0:	003ddb06 	br	81131c30 <__reset+0xfb111c30>
811324c4:	02a04574 	movhi	r10,33045
811324c8:	52819b04 	addi	r10,r10,1644
811324cc:	da802415 	stw	r10,144(sp)
811324d0:	003e8306 	br	81131ee0 <__reset+0xfb111ee0>
811324d4:	d8801c17 	ldw	r2,112(sp)
811324d8:	dd002117 	ldw	r20,132(sp)
811324dc:	103eb926 	beq	r2,zero,81131fc4 <__reset+0xfb111fc4>
811324e0:	d9002017 	ldw	r4,128(sp)
811324e4:	d9801a04 	addi	r6,sp,104
811324e8:	a00b883a 	mov	r5,r20
811324ec:	113114c0 	call	8113114c <__sprint_r.part.0>
811324f0:	003eb406 	br	81131fc4 <__reset+0xfb111fc4>
811324f4:	80c00043 	ldbu	r3,1(r16)
811324f8:	a5000814 	ori	r20,r20,32
811324fc:	84000044 	addi	r16,r16,1
81132500:	18c03fcc 	andi	r3,r3,255
81132504:	18c0201c 	xori	r3,r3,128
81132508:	18ffe004 	addi	r3,r3,-128
8113250c:	003bb706 	br	811313ec <__reset+0xfb1113ec>
81132510:	a809883a 	mov	r4,r21
81132514:	d8c02a15 	stw	r3,168(sp)
81132518:	da002b15 	stw	r8,172(sp)
8113251c:	1122b480 	call	81122b48 <strlen>
81132520:	d8c02a17 	ldw	r3,168(sp)
81132524:	1027883a 	mov	r19,r2
81132528:	df001d83 	ldbu	fp,118(sp)
8113252c:	d8c02215 	stw	r3,136(sp)
81132530:	0013883a 	mov	r9,zero
81132534:	da002b17 	ldw	r8,172(sp)
81132538:	003c4d06 	br	81131670 <__reset+0xfb111670>
8113253c:	d9402117 	ldw	r5,132(sp)
81132540:	d9002017 	ldw	r4,128(sp)
81132544:	d9801a04 	addi	r6,sp,104
81132548:	da402c15 	stw	r9,176(sp)
8113254c:	113114c0 	call	8113114c <__sprint_r.part.0>
81132550:	da402c17 	ldw	r9,176(sp)
81132554:	103e9a1e 	bne	r2,zero,81131fc0 <__reset+0xfb111fc0>
81132558:	d9401b17 	ldw	r5,108(sp)
8113255c:	d8801c17 	ldw	r2,112(sp)
81132560:	d811883a 	mov	r8,sp
81132564:	29000044 	addi	r4,r5,1
81132568:	003e4206 	br	81131e74 <__reset+0xfb111e74>
8113256c:	d9401b17 	ldw	r5,108(sp)
81132570:	01204574 	movhi	r4,33045
81132574:	21019f04 	addi	r4,r4,1660
81132578:	d9002415 	stw	r4,144(sp)
8113257c:	29400044 	addi	r5,r5,1
81132580:	003c6d06 	br	81131738 <__reset+0xfb111738>
81132584:	0039883a 	mov	fp,zero
81132588:	00800084 	movi	r2,2
8113258c:	10803fcc 	andi	r2,r2,255
81132590:	01000044 	movi	r4,1
81132594:	11001e26 	beq	r2,r4,81132610 <___vfiprintf_internal_r+0x13a8>
81132598:	01000084 	movi	r4,2
8113259c:	11001e1e 	bne	r2,r4,81132618 <___vfiprintf_internal_r+0x13b0>
811325a0:	1829883a 	mov	r20,r3
811325a4:	003eea06 	br	81132150 <__reset+0xfb112150>
811325a8:	a007883a 	mov	r3,r20
811325ac:	00800044 	movi	r2,1
811325b0:	003ff606 	br	8113258c <__reset+0xfb11258c>
811325b4:	00800184 	movi	r2,6
811325b8:	1240012e 	bgeu	r2,r9,811325c0 <___vfiprintf_internal_r+0x1358>
811325bc:	1013883a 	mov	r9,r2
811325c0:	4827883a 	mov	r19,r9
811325c4:	4825883a 	mov	r18,r9
811325c8:	48001516 	blt	r9,zero,81132620 <___vfiprintf_internal_r+0x13b8>
811325cc:	05604574 	movhi	r21,33045
811325d0:	d8c02215 	stw	r3,136(sp)
811325d4:	ad410e04 	addi	r21,r21,1080
811325d8:	003d1406 	br	81131a2c <__reset+0xfb111a2c>
811325dc:	02a04574 	movhi	r10,33045
811325e0:	52819b04 	addi	r10,r10,1644
811325e4:	da802415 	stw	r10,144(sp)
811325e8:	200d883a 	mov	r6,r4
811325ec:	003c9106 	br	81131834 <__reset+0xfb111834>
811325f0:	5021883a 	mov	r16,r10
811325f4:	0013883a 	mov	r9,zero
811325f8:	003b7d06 	br	811313f0 <__reset+0xfb1113f0>
811325fc:	4827883a 	mov	r19,r9
81132600:	df001d83 	ldbu	fp,118(sp)
81132604:	d8c02215 	stw	r3,136(sp)
81132608:	0013883a 	mov	r9,zero
8113260c:	003c1806 	br	81131670 <__reset+0xfb111670>
81132610:	1829883a 	mov	r20,r3
81132614:	003d1806 	br	81131a78 <__reset+0xfb111a78>
81132618:	1829883a 	mov	r20,r3
8113261c:	003ccd06 	br	81131954 <__reset+0xfb111954>
81132620:	0025883a 	mov	r18,zero
81132624:	003fe906 	br	811325cc <__reset+0xfb1125cc>
81132628:	d8802217 	ldw	r2,136(sp)
8113262c:	80c00043 	ldbu	r3,1(r16)
81132630:	5021883a 	mov	r16,r10
81132634:	12400017 	ldw	r9,0(r2)
81132638:	10800104 	addi	r2,r2,4
8113263c:	d8802215 	stw	r2,136(sp)
81132640:	483faf0e 	bge	r9,zero,81132500 <__reset+0xfb112500>
81132644:	18c03fcc 	andi	r3,r3,255
81132648:	18c0201c 	xori	r3,r3,128
8113264c:	027fffc4 	movi	r9,-1
81132650:	18ffe004 	addi	r3,r3,-128
81132654:	003b6506 	br	811313ec <__reset+0xfb1113ec>
81132658:	d9c01d85 	stb	r7,118(sp)
8113265c:	003ca006 	br	811318e0 <__reset+0xfb1118e0>
81132660:	d9c01d85 	stb	r7,118(sp)
81132664:	003cad06 	br	8113191c <__reset+0xfb11191c>
81132668:	d9c01d85 	stb	r7,118(sp)
8113266c:	003d7d06 	br	81131c64 <__reset+0xfb111c64>
81132670:	d9c01d85 	stb	r7,118(sp)
81132674:	003d5f06 	br	81131bf4 <__reset+0xfb111bf4>
81132678:	a080004c 	andi	r2,r20,1
8113267c:	0039883a 	mov	fp,zero
81132680:	10000526 	beq	r2,zero,81132698 <___vfiprintf_internal_r+0x1430>
81132684:	00800c04 	movi	r2,48
81132688:	d88019c5 	stb	r2,103(sp)
8113268c:	dcc02717 	ldw	r19,156(sp)
81132690:	dd4019c4 	addi	r21,sp,103
81132694:	003bf606 	br	81131670 <__reset+0xfb111670>
81132698:	0027883a 	mov	r19,zero
8113269c:	dd401a04 	addi	r21,sp,104
811326a0:	003bf306 	br	81131670 <__reset+0xfb111670>
811326a4:	d9c01d85 	stb	r7,118(sp)
811326a8:	003dc806 	br	81131dcc <__reset+0xfb111dcc>
811326ac:	d9c01d85 	stb	r7,118(sp)
811326b0:	003d3a06 	br	81131b9c <__reset+0xfb111b9c>
811326b4:	d9c01d85 	stb	r7,118(sp)
811326b8:	003d2a06 	br	81131b64 <__reset+0xfb111b64>
811326bc:	d9c01d85 	stb	r7,118(sp)
811326c0:	003cde06 	br	81131a3c <__reset+0xfb111a3c>
811326c4:	d9c01d85 	stb	r7,118(sp)
811326c8:	003cbc06 	br	811319bc <__reset+0xfb1119bc>

811326cc <__vfiprintf_internal>:
811326cc:	00a04574 	movhi	r2,33045
811326d0:	108ad804 	addi	r2,r2,11104
811326d4:	300f883a 	mov	r7,r6
811326d8:	280d883a 	mov	r6,r5
811326dc:	200b883a 	mov	r5,r4
811326e0:	11000017 	ldw	r4,0(r2)
811326e4:	11312681 	jmpi	81131268 <___vfiprintf_internal_r>

811326e8 <__sbprintf>:
811326e8:	defee204 	addi	sp,sp,-1144
811326ec:	de00012e 	bgeu	sp,et,811326f4 <__sbprintf+0xc>
811326f0:	003b68fa 	trap	3
811326f4:	2880030b 	ldhu	r2,12(r5)
811326f8:	2ac01917 	ldw	r11,100(r5)
811326fc:	2a80038b 	ldhu	r10,14(r5)
81132700:	2a400717 	ldw	r9,28(r5)
81132704:	2a000917 	ldw	r8,36(r5)
81132708:	00c10004 	movi	r3,1024
8113270c:	dc011a15 	stw	r16,1128(sp)
81132710:	10bfff4c 	andi	r2,r2,65533
81132714:	2821883a 	mov	r16,r5
81132718:	d8cb883a 	add	r5,sp,r3
8113271c:	dc811c15 	stw	r18,1136(sp)
81132720:	dc411b15 	stw	r17,1132(sp)
81132724:	dfc11d15 	stw	ra,1140(sp)
81132728:	2025883a 	mov	r18,r4
8113272c:	d881030d 	sth	r2,1036(sp)
81132730:	dac11915 	stw	r11,1124(sp)
81132734:	da81038d 	sth	r10,1038(sp)
81132738:	da410715 	stw	r9,1052(sp)
8113273c:	da010915 	stw	r8,1060(sp)
81132740:	dec10015 	stw	sp,1024(sp)
81132744:	dec10415 	stw	sp,1040(sp)
81132748:	d8c10215 	stw	r3,1032(sp)
8113274c:	d8c10515 	stw	r3,1044(sp)
81132750:	d8010615 	stw	zero,1048(sp)
81132754:	11312680 	call	81131268 <___vfiprintf_internal_r>
81132758:	1023883a 	mov	r17,r2
8113275c:	10000416 	blt	r2,zero,81132770 <__sbprintf+0x88>
81132760:	d9410004 	addi	r5,sp,1024
81132764:	9009883a 	mov	r4,r18
81132768:	112aa200 	call	8112aa20 <_fflush_r>
8113276c:	10000d1e 	bne	r2,zero,811327a4 <__sbprintf+0xbc>
81132770:	d881030b 	ldhu	r2,1036(sp)
81132774:	1080100c 	andi	r2,r2,64
81132778:	10000326 	beq	r2,zero,81132788 <__sbprintf+0xa0>
8113277c:	8080030b 	ldhu	r2,12(r16)
81132780:	10801014 	ori	r2,r2,64
81132784:	8080030d 	sth	r2,12(r16)
81132788:	8805883a 	mov	r2,r17
8113278c:	dfc11d17 	ldw	ra,1140(sp)
81132790:	dc811c17 	ldw	r18,1136(sp)
81132794:	dc411b17 	ldw	r17,1132(sp)
81132798:	dc011a17 	ldw	r16,1128(sp)
8113279c:	dec11e04 	addi	sp,sp,1144
811327a0:	f800283a 	ret
811327a4:	047fffc4 	movi	r17,-1
811327a8:	003ff106 	br	81132770 <__reset+0xfb112770>

811327ac <_calloc_r>:
811327ac:	298b383a 	mul	r5,r5,r6
811327b0:	defffe04 	addi	sp,sp,-8
811327b4:	de00012e 	bgeu	sp,et,811327bc <_calloc_r+0x10>
811327b8:	003b68fa 	trap	3
811327bc:	dfc00115 	stw	ra,4(sp)
811327c0:	dc000015 	stw	r16,0(sp)
811327c4:	11218400 	call	81121840 <_malloc_r>
811327c8:	10002926 	beq	r2,zero,81132870 <_calloc_r+0xc4>
811327cc:	11bfff17 	ldw	r6,-4(r2)
811327d0:	1021883a 	mov	r16,r2
811327d4:	00bfff04 	movi	r2,-4
811327d8:	308c703a 	and	r6,r6,r2
811327dc:	00c00904 	movi	r3,36
811327e0:	308d883a 	add	r6,r6,r2
811327e4:	19801636 	bltu	r3,r6,81132840 <_calloc_r+0x94>
811327e8:	008004c4 	movi	r2,19
811327ec:	11800b2e 	bgeu	r2,r6,8113281c <_calloc_r+0x70>
811327f0:	80000015 	stw	zero,0(r16)
811327f4:	80000115 	stw	zero,4(r16)
811327f8:	008006c4 	movi	r2,27
811327fc:	11801a2e 	bgeu	r2,r6,81132868 <_calloc_r+0xbc>
81132800:	80000215 	stw	zero,8(r16)
81132804:	80000315 	stw	zero,12(r16)
81132808:	30c0151e 	bne	r6,r3,81132860 <_calloc_r+0xb4>
8113280c:	80000415 	stw	zero,16(r16)
81132810:	80800604 	addi	r2,r16,24
81132814:	80000515 	stw	zero,20(r16)
81132818:	00000106 	br	81132820 <_calloc_r+0x74>
8113281c:	8005883a 	mov	r2,r16
81132820:	10000015 	stw	zero,0(r2)
81132824:	10000115 	stw	zero,4(r2)
81132828:	10000215 	stw	zero,8(r2)
8113282c:	8005883a 	mov	r2,r16
81132830:	dfc00117 	ldw	ra,4(sp)
81132834:	dc000017 	ldw	r16,0(sp)
81132838:	dec00204 	addi	sp,sp,8
8113283c:	f800283a 	ret
81132840:	000b883a 	mov	r5,zero
81132844:	8009883a 	mov	r4,r16
81132848:	11221a40 	call	811221a4 <memset>
8113284c:	8005883a 	mov	r2,r16
81132850:	dfc00117 	ldw	ra,4(sp)
81132854:	dc000017 	ldw	r16,0(sp)
81132858:	dec00204 	addi	sp,sp,8
8113285c:	f800283a 	ret
81132860:	80800404 	addi	r2,r16,16
81132864:	003fee06 	br	81132820 <__reset+0xfb112820>
81132868:	80800204 	addi	r2,r16,8
8113286c:	003fec06 	br	81132820 <__reset+0xfb112820>
81132870:	0005883a 	mov	r2,zero
81132874:	003fee06 	br	81132830 <__reset+0xfb112830>

81132878 <_fclose_r>:
81132878:	28003b26 	beq	r5,zero,81132968 <_fclose_r+0xf0>
8113287c:	defffc04 	addi	sp,sp,-16
81132880:	de00012e 	bgeu	sp,et,81132888 <_fclose_r+0x10>
81132884:	003b68fa 	trap	3
81132888:	dc400115 	stw	r17,4(sp)
8113288c:	dc000015 	stw	r16,0(sp)
81132890:	dfc00315 	stw	ra,12(sp)
81132894:	dc800215 	stw	r18,8(sp)
81132898:	2023883a 	mov	r17,r4
8113289c:	2821883a 	mov	r16,r5
811328a0:	20000226 	beq	r4,zero,811328ac <_fclose_r+0x34>
811328a4:	20800e17 	ldw	r2,56(r4)
811328a8:	10002726 	beq	r2,zero,81132948 <_fclose_r+0xd0>
811328ac:	8080030f 	ldh	r2,12(r16)
811328b0:	1000071e 	bne	r2,zero,811328d0 <_fclose_r+0x58>
811328b4:	0005883a 	mov	r2,zero
811328b8:	dfc00317 	ldw	ra,12(sp)
811328bc:	dc800217 	ldw	r18,8(sp)
811328c0:	dc400117 	ldw	r17,4(sp)
811328c4:	dc000017 	ldw	r16,0(sp)
811328c8:	dec00404 	addi	sp,sp,16
811328cc:	f800283a 	ret
811328d0:	800b883a 	mov	r5,r16
811328d4:	8809883a 	mov	r4,r17
811328d8:	112a7fc0 	call	8112a7fc <__sflush_r>
811328dc:	1025883a 	mov	r18,r2
811328e0:	80800b17 	ldw	r2,44(r16)
811328e4:	10000426 	beq	r2,zero,811328f8 <_fclose_r+0x80>
811328e8:	81400717 	ldw	r5,28(r16)
811328ec:	8809883a 	mov	r4,r17
811328f0:	103ee83a 	callr	r2
811328f4:	10001616 	blt	r2,zero,81132950 <_fclose_r+0xd8>
811328f8:	8080030b 	ldhu	r2,12(r16)
811328fc:	1080200c 	andi	r2,r2,128
81132900:	1000151e 	bne	r2,zero,81132958 <_fclose_r+0xe0>
81132904:	81400c17 	ldw	r5,48(r16)
81132908:	28000526 	beq	r5,zero,81132920 <_fclose_r+0xa8>
8113290c:	80801004 	addi	r2,r16,64
81132910:	28800226 	beq	r5,r2,8113291c <_fclose_r+0xa4>
81132914:	8809883a 	mov	r4,r17
81132918:	112b2b40 	call	8112b2b4 <_free_r>
8113291c:	80000c15 	stw	zero,48(r16)
81132920:	81401117 	ldw	r5,68(r16)
81132924:	28000326 	beq	r5,zero,81132934 <_fclose_r+0xbc>
81132928:	8809883a 	mov	r4,r17
8113292c:	112b2b40 	call	8112b2b4 <_free_r>
81132930:	80001115 	stw	zero,68(r16)
81132934:	112ae2c0 	call	8112ae2c <__sfp_lock_acquire>
81132938:	8000030d 	sth	zero,12(r16)
8113293c:	112ae300 	call	8112ae30 <__sfp_lock_release>
81132940:	9005883a 	mov	r2,r18
81132944:	003fdc06 	br	811328b8 <__reset+0xfb1128b8>
81132948:	112ae1c0 	call	8112ae1c <__sinit>
8113294c:	003fd706 	br	811328ac <__reset+0xfb1128ac>
81132950:	04bfffc4 	movi	r18,-1
81132954:	003fe806 	br	811328f8 <__reset+0xfb1128f8>
81132958:	81400417 	ldw	r5,16(r16)
8113295c:	8809883a 	mov	r4,r17
81132960:	112b2b40 	call	8112b2b4 <_free_r>
81132964:	003fe706 	br	81132904 <__reset+0xfb112904>
81132968:	0005883a 	mov	r2,zero
8113296c:	f800283a 	ret

81132970 <fclose>:
81132970:	00a04574 	movhi	r2,33045
81132974:	108ad804 	addi	r2,r2,11104
81132978:	200b883a 	mov	r5,r4
8113297c:	11000017 	ldw	r4,0(r2)
81132980:	11328781 	jmpi	81132878 <_fclose_r>

81132984 <__fputwc>:
81132984:	defff804 	addi	sp,sp,-32
81132988:	de00012e 	bgeu	sp,et,81132990 <__fputwc+0xc>
8113298c:	003b68fa 	trap	3
81132990:	dcc00415 	stw	r19,16(sp)
81132994:	dc800315 	stw	r18,12(sp)
81132998:	dc000115 	stw	r16,4(sp)
8113299c:	dfc00715 	stw	ra,28(sp)
811329a0:	dd400615 	stw	r21,24(sp)
811329a4:	dd000515 	stw	r20,20(sp)
811329a8:	dc400215 	stw	r17,8(sp)
811329ac:	2027883a 	mov	r19,r4
811329b0:	2825883a 	mov	r18,r5
811329b4:	3021883a 	mov	r16,r6
811329b8:	112bd440 	call	8112bd44 <__locale_mb_cur_max>
811329bc:	00c00044 	movi	r3,1
811329c0:	10c03e26 	beq	r2,r3,81132abc <__fputwc+0x138>
811329c4:	81c01704 	addi	r7,r16,92
811329c8:	900d883a 	mov	r6,r18
811329cc:	d80b883a 	mov	r5,sp
811329d0:	9809883a 	mov	r4,r19
811329d4:	11338080 	call	81133808 <_wcrtomb_r>
811329d8:	1029883a 	mov	r20,r2
811329dc:	00bfffc4 	movi	r2,-1
811329e0:	a0802026 	beq	r20,r2,81132a64 <__fputwc+0xe0>
811329e4:	d9400003 	ldbu	r5,0(sp)
811329e8:	a0001c26 	beq	r20,zero,81132a5c <__fputwc+0xd8>
811329ec:	0023883a 	mov	r17,zero
811329f0:	05400284 	movi	r21,10
811329f4:	00000906 	br	81132a1c <__fputwc+0x98>
811329f8:	80800017 	ldw	r2,0(r16)
811329fc:	11400005 	stb	r5,0(r2)
81132a00:	80c00017 	ldw	r3,0(r16)
81132a04:	18c00044 	addi	r3,r3,1
81132a08:	80c00015 	stw	r3,0(r16)
81132a0c:	8c400044 	addi	r17,r17,1
81132a10:	dc45883a 	add	r2,sp,r17
81132a14:	8d00112e 	bgeu	r17,r20,81132a5c <__fputwc+0xd8>
81132a18:	11400003 	ldbu	r5,0(r2)
81132a1c:	80c00217 	ldw	r3,8(r16)
81132a20:	18ffffc4 	addi	r3,r3,-1
81132a24:	80c00215 	stw	r3,8(r16)
81132a28:	183ff30e 	bge	r3,zero,811329f8 <__reset+0xfb1129f8>
81132a2c:	80800617 	ldw	r2,24(r16)
81132a30:	18801916 	blt	r3,r2,81132a98 <__fputwc+0x114>
81132a34:	80800017 	ldw	r2,0(r16)
81132a38:	11400005 	stb	r5,0(r2)
81132a3c:	80800017 	ldw	r2,0(r16)
81132a40:	10c00003 	ldbu	r3,0(r2)
81132a44:	10800044 	addi	r2,r2,1
81132a48:	1d402326 	beq	r3,r21,81132ad8 <__fputwc+0x154>
81132a4c:	80800015 	stw	r2,0(r16)
81132a50:	8c400044 	addi	r17,r17,1
81132a54:	dc45883a 	add	r2,sp,r17
81132a58:	8d3fef36 	bltu	r17,r20,81132a18 <__reset+0xfb112a18>
81132a5c:	9005883a 	mov	r2,r18
81132a60:	00000406 	br	81132a74 <__fputwc+0xf0>
81132a64:	80c0030b 	ldhu	r3,12(r16)
81132a68:	a005883a 	mov	r2,r20
81132a6c:	18c01014 	ori	r3,r3,64
81132a70:	80c0030d 	sth	r3,12(r16)
81132a74:	dfc00717 	ldw	ra,28(sp)
81132a78:	dd400617 	ldw	r21,24(sp)
81132a7c:	dd000517 	ldw	r20,20(sp)
81132a80:	dcc00417 	ldw	r19,16(sp)
81132a84:	dc800317 	ldw	r18,12(sp)
81132a88:	dc400217 	ldw	r17,8(sp)
81132a8c:	dc000117 	ldw	r16,4(sp)
81132a90:	dec00804 	addi	sp,sp,32
81132a94:	f800283a 	ret
81132a98:	800d883a 	mov	r6,r16
81132a9c:	29403fcc 	andi	r5,r5,255
81132aa0:	9809883a 	mov	r4,r19
81132aa4:	1128be40 	call	81128be4 <__swbuf_r>
81132aa8:	10bfffe0 	cmpeqi	r2,r2,-1
81132aac:	10803fcc 	andi	r2,r2,255
81132ab0:	103fd626 	beq	r2,zero,81132a0c <__reset+0xfb112a0c>
81132ab4:	00bfffc4 	movi	r2,-1
81132ab8:	003fee06 	br	81132a74 <__reset+0xfb112a74>
81132abc:	90ffffc4 	addi	r3,r18,-1
81132ac0:	01003f84 	movi	r4,254
81132ac4:	20ffbf36 	bltu	r4,r3,811329c4 <__reset+0xfb1129c4>
81132ac8:	900b883a 	mov	r5,r18
81132acc:	dc800005 	stb	r18,0(sp)
81132ad0:	1029883a 	mov	r20,r2
81132ad4:	003fc506 	br	811329ec <__reset+0xfb1129ec>
81132ad8:	800d883a 	mov	r6,r16
81132adc:	a80b883a 	mov	r5,r21
81132ae0:	9809883a 	mov	r4,r19
81132ae4:	1128be40 	call	81128be4 <__swbuf_r>
81132ae8:	10bfffe0 	cmpeqi	r2,r2,-1
81132aec:	003fef06 	br	81132aac <__reset+0xfb112aac>

81132af0 <_fputwc_r>:
81132af0:	3080030b 	ldhu	r2,12(r6)
81132af4:	10c8000c 	andi	r3,r2,8192
81132af8:	1800051e 	bne	r3,zero,81132b10 <_fputwc_r+0x20>
81132afc:	30c01917 	ldw	r3,100(r6)
81132b00:	10880014 	ori	r2,r2,8192
81132b04:	3080030d 	sth	r2,12(r6)
81132b08:	18880014 	ori	r2,r3,8192
81132b0c:	30801915 	stw	r2,100(r6)
81132b10:	11329841 	jmpi	81132984 <__fputwc>

81132b14 <fputwc>:
81132b14:	00a04574 	movhi	r2,33045
81132b18:	defffc04 	addi	sp,sp,-16
81132b1c:	108ad804 	addi	r2,r2,11104
81132b20:	de00012e 	bgeu	sp,et,81132b28 <fputwc+0x14>
81132b24:	003b68fa 	trap	3
81132b28:	dc000115 	stw	r16,4(sp)
81132b2c:	14000017 	ldw	r16,0(r2)
81132b30:	dc400215 	stw	r17,8(sp)
81132b34:	dfc00315 	stw	ra,12(sp)
81132b38:	2023883a 	mov	r17,r4
81132b3c:	80000226 	beq	r16,zero,81132b48 <fputwc+0x34>
81132b40:	80800e17 	ldw	r2,56(r16)
81132b44:	10001026 	beq	r2,zero,81132b88 <fputwc+0x74>
81132b48:	2880030b 	ldhu	r2,12(r5)
81132b4c:	10c8000c 	andi	r3,r2,8192
81132b50:	1800051e 	bne	r3,zero,81132b68 <fputwc+0x54>
81132b54:	28c01917 	ldw	r3,100(r5)
81132b58:	10880014 	ori	r2,r2,8192
81132b5c:	2880030d 	sth	r2,12(r5)
81132b60:	18880014 	ori	r2,r3,8192
81132b64:	28801915 	stw	r2,100(r5)
81132b68:	280d883a 	mov	r6,r5
81132b6c:	8009883a 	mov	r4,r16
81132b70:	880b883a 	mov	r5,r17
81132b74:	dfc00317 	ldw	ra,12(sp)
81132b78:	dc400217 	ldw	r17,8(sp)
81132b7c:	dc000117 	ldw	r16,4(sp)
81132b80:	dec00404 	addi	sp,sp,16
81132b84:	11329841 	jmpi	81132984 <__fputwc>
81132b88:	8009883a 	mov	r4,r16
81132b8c:	d9400015 	stw	r5,0(sp)
81132b90:	112ae1c0 	call	8112ae1c <__sinit>
81132b94:	d9400017 	ldw	r5,0(sp)
81132b98:	003feb06 	br	81132b48 <__reset+0xfb112b48>

81132b9c <rshift>:
81132b9c:	2807d17a 	srai	r3,r5,5
81132ba0:	20800417 	ldw	r2,16(r4)
81132ba4:	22000504 	addi	r8,r4,20
81132ba8:	1880250e 	bge	r3,r2,81132c40 <rshift+0xa4>
81132bac:	1085883a 	add	r2,r2,r2
81132bb0:	18c7883a 	add	r3,r3,r3
81132bb4:	1085883a 	add	r2,r2,r2
81132bb8:	18c7883a 	add	r3,r3,r3
81132bbc:	294007cc 	andi	r5,r5,31
81132bc0:	4085883a 	add	r2,r8,r2
81132bc4:	40c7883a 	add	r3,r8,r3
81132bc8:	28002026 	beq	r5,zero,81132c4c <rshift+0xb0>
81132bcc:	19800017 	ldw	r6,0(r3)
81132bd0:	02c00804 	movi	r11,32
81132bd4:	19c00104 	addi	r7,r3,4
81132bd8:	5957c83a 	sub	r11,r11,r5
81132bdc:	314cd83a 	srl	r6,r6,r5
81132be0:	38802c2e 	bgeu	r7,r2,81132c94 <rshift+0xf8>
81132be4:	4015883a 	mov	r10,r8
81132be8:	3a400017 	ldw	r9,0(r7)
81132bec:	52800104 	addi	r10,r10,4
81132bf0:	39c00104 	addi	r7,r7,4
81132bf4:	4ad2983a 	sll	r9,r9,r11
81132bf8:	498cb03a 	or	r6,r9,r6
81132bfc:	51bfff15 	stw	r6,-4(r10)
81132c00:	39bfff17 	ldw	r6,-4(r7)
81132c04:	314cd83a 	srl	r6,r6,r5
81132c08:	38bff736 	bltu	r7,r2,81132be8 <__reset+0xfb112be8>
81132c0c:	10c7c83a 	sub	r3,r2,r3
81132c10:	18fffec4 	addi	r3,r3,-5
81132c14:	1806d0ba 	srli	r3,r3,2
81132c18:	18c00044 	addi	r3,r3,1
81132c1c:	18c7883a 	add	r3,r3,r3
81132c20:	18c7883a 	add	r3,r3,r3
81132c24:	40c7883a 	add	r3,r8,r3
81132c28:	19800015 	stw	r6,0(r3)
81132c2c:	30000126 	beq	r6,zero,81132c34 <rshift+0x98>
81132c30:	18c00104 	addi	r3,r3,4
81132c34:	1a05c83a 	sub	r2,r3,r8
81132c38:	1005d0ba 	srai	r2,r2,2
81132c3c:	00001206 	br	81132c88 <rshift+0xec>
81132c40:	20000415 	stw	zero,16(r4)
81132c44:	20000515 	stw	zero,20(r4)
81132c48:	f800283a 	ret
81132c4c:	18bffc2e 	bgeu	r3,r2,81132c40 <__reset+0xfb112c40>
81132c50:	180d883a 	mov	r6,r3
81132c54:	400b883a 	mov	r5,r8
81132c58:	31c00017 	ldw	r7,0(r6)
81132c5c:	29400104 	addi	r5,r5,4
81132c60:	31800104 	addi	r6,r6,4
81132c64:	29ffff15 	stw	r7,-4(r5)
81132c68:	30bffb36 	bltu	r6,r2,81132c58 <__reset+0xfb112c58>
81132c6c:	00c6303a 	nor	r3,zero,r3
81132c70:	1885883a 	add	r2,r3,r2
81132c74:	1004d0ba 	srli	r2,r2,2
81132c78:	10800044 	addi	r2,r2,1
81132c7c:	1085883a 	add	r2,r2,r2
81132c80:	1085883a 	add	r2,r2,r2
81132c84:	1005d0ba 	srai	r2,r2,2
81132c88:	20800415 	stw	r2,16(r4)
81132c8c:	103fed26 	beq	r2,zero,81132c44 <__reset+0xfb112c44>
81132c90:	f800283a 	ret
81132c94:	4007883a 	mov	r3,r8
81132c98:	003fe306 	br	81132c28 <__reset+0xfb112c28>

81132c9c <__gethex>:
81132c9c:	deffeb04 	addi	sp,sp,-84
81132ca0:	de00012e 	bgeu	sp,et,81132ca8 <__gethex+0xc>
81132ca4:	003b68fa 	trap	3
81132ca8:	dfc01415 	stw	ra,80(sp)
81132cac:	dd801115 	stw	r22,68(sp)
81132cb0:	dcc00e15 	stw	r19,56(sp)
81132cb4:	dc800d15 	stw	r18,52(sp)
81132cb8:	2827883a 	mov	r19,r5
81132cbc:	d9000115 	stw	r4,4(sp)
81132cc0:	d9800015 	stw	r6,0(sp)
81132cc4:	d9c00415 	stw	r7,16(sp)
81132cc8:	df001315 	stw	fp,76(sp)
81132ccc:	ddc01215 	stw	r23,72(sp)
81132cd0:	dd401015 	stw	r21,64(sp)
81132cd4:	dd000f15 	stw	r20,60(sp)
81132cd8:	dc400c15 	stw	r17,48(sp)
81132cdc:	dc000b15 	stw	r16,44(sp)
81132ce0:	112bd680 	call	8112bd68 <_localeconv_r>
81132ce4:	14800017 	ldw	r18,0(r2)
81132ce8:	9009883a 	mov	r4,r18
81132cec:	1122b480 	call	81122b48 <strlen>
81132cf0:	98c00017 	ldw	r3,0(r19)
81132cf4:	102d883a 	mov	r22,r2
81132cf8:	9085883a 	add	r2,r18,r2
81132cfc:	10bfffc3 	ldbu	r2,-1(r2)
81132d00:	19000083 	ldbu	r4,2(r3)
81132d04:	d8800305 	stb	r2,12(sp)
81132d08:	00800c04 	movi	r2,48
81132d0c:	2081521e 	bne	r4,r2,81133258 <__gethex+0x5bc>
81132d10:	017fff84 	movi	r5,-2
81132d14:	188000c4 	addi	r2,r3,3
81132d18:	28cbc83a 	sub	r5,r5,r3
81132d1c:	200d883a 	mov	r6,r4
81132d20:	28a3883a 	add	r17,r5,r2
81132d24:	102b883a 	mov	r21,r2
81132d28:	10800044 	addi	r2,r2,1
81132d2c:	113fffc3 	ldbu	r4,-1(r2)
81132d30:	21bffb26 	beq	r4,r6,81132d20 <__reset+0xfb112d20>
81132d34:	05204574 	movhi	r20,33045
81132d38:	a501a304 	addi	r20,r20,1676
81132d3c:	a109883a 	add	r4,r20,r4
81132d40:	20800003 	ldbu	r2,0(r4)
81132d44:	10008826 	beq	r2,zero,81132f68 <__gethex+0x2cc>
81132d48:	a8800003 	ldbu	r2,0(r21)
81132d4c:	0015883a 	mov	r10,zero
81132d50:	002f883a 	mov	r23,zero
81132d54:	a085883a 	add	r2,r20,r2
81132d58:	10800003 	ldbu	r2,0(r2)
81132d5c:	a821883a 	mov	r16,r21
81132d60:	10000526 	beq	r2,zero,81132d78 <__gethex+0xdc>
81132d64:	84000044 	addi	r16,r16,1
81132d68:	80800003 	ldbu	r2,0(r16)
81132d6c:	a085883a 	add	r2,r20,r2
81132d70:	10800003 	ldbu	r2,0(r2)
81132d74:	103ffb1e 	bne	r2,zero,81132d64 <__reset+0xfb112d64>
81132d78:	b00d883a 	mov	r6,r22
81132d7c:	900b883a 	mov	r5,r18
81132d80:	8009883a 	mov	r4,r16
81132d84:	da800a15 	stw	r10,40(sp)
81132d88:	11337380 	call	81133738 <strncmp>
81132d8c:	da800a17 	ldw	r10,40(sp)
81132d90:	1000031e 	bne	r2,zero,81132da0 <__gethex+0x104>
81132d94:	b8015226 	beq	r23,zero,811332e0 <__gethex+0x644>
81132d98:	80800003 	ldbu	r2,0(r16)
81132d9c:	00000206 	br	81132da8 <__gethex+0x10c>
81132da0:	80800003 	ldbu	r2,0(r16)
81132da4:	b8011f26 	beq	r23,zero,81133224 <__gethex+0x588>
81132da8:	85efc83a 	sub	r23,r16,r23
81132dac:	bdef883a 	add	r23,r23,r23
81132db0:	bdef883a 	add	r23,r23,r23
81132db4:	05efc83a 	sub	r23,zero,r23
81132db8:	10803fcc 	andi	r2,r2,255
81132dbc:	01001404 	movi	r4,80
81132dc0:	11008626 	beq	r2,r4,81132fdc <__gethex+0x340>
81132dc4:	01001c04 	movi	r4,112
81132dc8:	11008426 	beq	r2,r4,81132fdc <__gethex+0x340>
81132dcc:	8039883a 	mov	fp,r16
81132dd0:	9c000015 	stw	r16,0(r19)
81132dd4:	5000711e 	bne	r10,zero,81132f9c <__gethex+0x300>
81132dd8:	e545c83a 	sub	r2,fp,r21
81132ddc:	10bfffc4 	addi	r2,r2,-1
81132de0:	010001c4 	movi	r4,7
81132de4:	000b883a 	mov	r5,zero
81132de8:	2080030e 	bge	r4,r2,81132df8 <__gethex+0x15c>
81132dec:	1005d07a 	srai	r2,r2,1
81132df0:	29400044 	addi	r5,r5,1
81132df4:	20bffd16 	blt	r4,r2,81132dec <__reset+0xfb112dec>
81132df8:	d9000117 	ldw	r4,4(sp)
81132dfc:	112c2840 	call	8112c284 <_Balloc>
81132e00:	10c00504 	addi	r3,r2,20
81132e04:	d8c00215 	stw	r3,8(sp)
81132e08:	1021883a 	mov	r16,r2
81132e0c:	af01732e 	bgeu	r21,fp,811333dc <__gethex+0x740>
81132e10:	dc400303 	ldbu	r17,12(sp)
81132e14:	03400044 	movi	r13,1
81132e18:	1815883a 	mov	r10,r3
81132e1c:	0013883a 	mov	r9,zero
81132e20:	0027883a 	mov	r19,zero
81132e24:	6d9bc83a 	sub	r13,r13,r22
81132e28:	02c00804 	movi	r11,32
81132e2c:	e0bfffc3 	ldbu	r2,-1(fp)
81132e30:	e3bfffc4 	addi	r14,fp,-1
81132e34:	88803026 	beq	r17,r2,81132ef8 <__gethex+0x25c>
81132e38:	9ac04526 	beq	r19,r11,81132f50 <__gethex+0x2b4>
81132e3c:	980b883a 	mov	r5,r19
81132e40:	9cc00104 	addi	r19,r19,4
81132e44:	e13fffc3 	ldbu	r4,-1(fp)
81132e48:	7039883a 	mov	fp,r14
81132e4c:	a109883a 	add	r4,r20,r4
81132e50:	20800003 	ldbu	r2,0(r4)
81132e54:	108003cc 	andi	r2,r2,15
81132e58:	1144983a 	sll	r2,r2,r5
81132e5c:	4892b03a 	or	r9,r9,r2
81132e60:	af3ff236 	bltu	r21,fp,81132e2c <__reset+0xfb112e2c>
81132e64:	d8c00217 	ldw	r3,8(sp)
81132e68:	50800104 	addi	r2,r10,4
81132e6c:	52400015 	stw	r9,0(r10)
81132e70:	10c5c83a 	sub	r2,r2,r3
81132e74:	1005d0ba 	srai	r2,r2,2
81132e78:	4809883a 	mov	r4,r9
81132e7c:	80800415 	stw	r2,16(r16)
81132e80:	1022917a 	slli	r17,r2,5
81132e84:	112c5900 	call	8112c590 <__hi0bits>
81132e88:	d8c00017 	ldw	r3,0(sp)
81132e8c:	8885c83a 	sub	r2,r17,r2
81132e90:	1c800017 	ldw	r18,0(r3)
81132e94:	9080c716 	blt	r18,r2,811331b4 <__gethex+0x518>
81132e98:	1480e416 	blt	r2,r18,8113322c <__gethex+0x590>
81132e9c:	0027883a 	mov	r19,zero
81132ea0:	d8c00017 	ldw	r3,0(sp)
81132ea4:	18800217 	ldw	r2,8(r3)
81132ea8:	15c08d16 	blt	r2,r23,811330e0 <__gethex+0x444>
81132eac:	d8c00017 	ldw	r3,0(sp)
81132eb0:	18800117 	ldw	r2,4(r3)
81132eb4:	b880aa0e 	bge	r23,r2,81133160 <__gethex+0x4c4>
81132eb8:	15efc83a 	sub	r23,r2,r23
81132ebc:	bc80ed16 	blt	r23,r18,81133274 <__gethex+0x5d8>
81132ec0:	18c00317 	ldw	r3,12(r3)
81132ec4:	01000084 	movi	r4,2
81132ec8:	19014926 	beq	r3,r4,811333f0 <__gethex+0x754>
81132ecc:	010000c4 	movi	r4,3
81132ed0:	19012e26 	beq	r3,r4,8113338c <__gethex+0x6f0>
81132ed4:	01000044 	movi	r4,1
81132ed8:	19014826 	beq	r3,r4,811333fc <__gethex+0x760>
81132edc:	d9000117 	ldw	r4,4(sp)
81132ee0:	800b883a 	mov	r5,r16
81132ee4:	112c3340 	call	8112c334 <_Bfree>
81132ee8:	d8801517 	ldw	r2,84(sp)
81132eec:	10000015 	stw	zero,0(r2)
81132ef0:	00801404 	movi	r2,80
81132ef4:	00002b06 	br	81132fa4 <__gethex+0x308>
81132ef8:	735f883a 	add	r15,r14,r13
81132efc:	7d7fce36 	bltu	r15,r21,81132e38 <__reset+0xfb112e38>
81132f00:	7809883a 	mov	r4,r15
81132f04:	b00d883a 	mov	r6,r22
81132f08:	900b883a 	mov	r5,r18
81132f0c:	da400515 	stw	r9,20(sp)
81132f10:	da800a15 	stw	r10,40(sp)
81132f14:	dac00915 	stw	r11,36(sp)
81132f18:	db400815 	stw	r13,32(sp)
81132f1c:	db800615 	stw	r14,24(sp)
81132f20:	dbc00715 	stw	r15,28(sp)
81132f24:	11337380 	call	81133738 <strncmp>
81132f28:	da400517 	ldw	r9,20(sp)
81132f2c:	da800a17 	ldw	r10,40(sp)
81132f30:	dac00917 	ldw	r11,36(sp)
81132f34:	db400817 	ldw	r13,32(sp)
81132f38:	db800617 	ldw	r14,24(sp)
81132f3c:	dbc00717 	ldw	r15,28(sp)
81132f40:	103fbd1e 	bne	r2,zero,81132e38 <__reset+0xfb112e38>
81132f44:	7839883a 	mov	fp,r15
81132f48:	af3fb836 	bltu	r21,fp,81132e2c <__reset+0xfb112e2c>
81132f4c:	003fc506 	br	81132e64 <__reset+0xfb112e64>
81132f50:	04c00104 	movi	r19,4
81132f54:	52400015 	stw	r9,0(r10)
81132f58:	000b883a 	mov	r5,zero
81132f5c:	54d5883a 	add	r10,r10,r19
81132f60:	0013883a 	mov	r9,zero
81132f64:	003fb706 	br	81132e44 <__reset+0xfb112e44>
81132f68:	b00d883a 	mov	r6,r22
81132f6c:	900b883a 	mov	r5,r18
81132f70:	a809883a 	mov	r4,r21
81132f74:	11337380 	call	81133738 <strncmp>
81132f78:	10006426 	beq	r2,zero,8113310c <__gethex+0x470>
81132f7c:	a8800003 	ldbu	r2,0(r21)
81132f80:	a821883a 	mov	r16,r21
81132f84:	10803fcc 	andi	r2,r2,255
81132f88:	01001404 	movi	r4,80
81132f8c:	11001126 	beq	r2,r4,81132fd4 <__gethex+0x338>
81132f90:	01001c04 	movi	r4,112
81132f94:	11000f26 	beq	r2,r4,81132fd4 <__gethex+0x338>
81132f98:	9c000015 	stw	r16,0(r19)
81132f9c:	8800831e 	bne	r17,zero,811331ac <__gethex+0x510>
81132fa0:	00800184 	movi	r2,6
81132fa4:	dfc01417 	ldw	ra,80(sp)
81132fa8:	df001317 	ldw	fp,76(sp)
81132fac:	ddc01217 	ldw	r23,72(sp)
81132fb0:	dd801117 	ldw	r22,68(sp)
81132fb4:	dd401017 	ldw	r21,64(sp)
81132fb8:	dd000f17 	ldw	r20,60(sp)
81132fbc:	dcc00e17 	ldw	r19,56(sp)
81132fc0:	dc800d17 	ldw	r18,52(sp)
81132fc4:	dc400c17 	ldw	r17,48(sp)
81132fc8:	dc000b17 	ldw	r16,44(sp)
81132fcc:	dec01504 	addi	sp,sp,84
81132fd0:	f800283a 	ret
81132fd4:	002f883a 	mov	r23,zero
81132fd8:	02800044 	movi	r10,1
81132fdc:	80800043 	ldbu	r2,1(r16)
81132fe0:	01400ac4 	movi	r5,43
81132fe4:	11003fcc 	andi	r4,r2,255
81132fe8:	21406e26 	beq	r4,r5,811331a4 <__gethex+0x508>
81132fec:	01400b44 	movi	r5,45
81132ff0:	21404226 	beq	r4,r5,811330fc <__gethex+0x460>
81132ff4:	81400044 	addi	r5,r16,1
81132ff8:	000d883a 	mov	r6,zero
81132ffc:	10803fcc 	andi	r2,r2,255
81133000:	a085883a 	add	r2,r20,r2
81133004:	11000003 	ldbu	r4,0(r2)
81133008:	03000604 	movi	r12,24
8113300c:	20bfffc4 	addi	r2,r4,-1
81133010:	10803fcc 	andi	r2,r2,255
81133014:	60bf6d36 	bltu	r12,r2,81132dcc <__reset+0xfb112dcc>
81133018:	2ac00043 	ldbu	r11,1(r5)
8113301c:	20803fcc 	andi	r2,r4,255
81133020:	01204574 	movhi	r4,33045
81133024:	2101a304 	addi	r4,r4,1676
81133028:	22c9883a 	add	r4,r4,r11
8113302c:	23400003 	ldbu	r13,0(r4)
81133030:	10bffc04 	addi	r2,r2,-16
81133034:	29400044 	addi	r5,r5,1
81133038:	693fffc4 	addi	r4,r13,-1
8113303c:	21003fcc 	andi	r4,r4,255
81133040:	6b403fcc 	andi	r13,r13,255
81133044:	61000b36 	bltu	r12,r4,81133074 <__gethex+0x3d8>
81133048:	29400044 	addi	r5,r5,1
8113304c:	29000003 	ldbu	r4,0(r5)
81133050:	108002a4 	muli	r2,r2,10
81133054:	a109883a 	add	r4,r20,r4
81133058:	22c00003 	ldbu	r11,0(r4)
8113305c:	1345883a 	add	r2,r2,r13
81133060:	10bffc04 	addi	r2,r2,-16
81133064:	593fffc4 	addi	r4,r11,-1
81133068:	21003fcc 	andi	r4,r4,255
8113306c:	5b403fcc 	andi	r13,r11,255
81133070:	613ff52e 	bgeu	r12,r4,81133048 <__reset+0xfb113048>
81133074:	30000126 	beq	r6,zero,8113307c <__gethex+0x3e0>
81133078:	0085c83a 	sub	r2,zero,r2
8113307c:	8039883a 	mov	fp,r16
81133080:	b8af883a 	add	r23,r23,r2
81133084:	2821883a 	mov	r16,r5
81133088:	003f5106 	br	81132dd0 <__reset+0xfb112dd0>
8113308c:	80800217 	ldw	r2,8(r16)
81133090:	e080f00e 	bge	fp,r2,81133454 <__gethex+0x7b8>
81133094:	e007883a 	mov	r3,fp
81133098:	18800144 	addi	r2,r3,5
8113309c:	1085883a 	add	r2,r2,r2
811330a0:	18c00044 	addi	r3,r3,1
811330a4:	1085883a 	add	r2,r2,r2
811330a8:	8085883a 	add	r2,r16,r2
811330ac:	80c00415 	stw	r3,16(r16)
811330b0:	01000044 	movi	r4,1
811330b4:	11000015 	stw	r4,0(r2)
811330b8:	00800084 	movi	r2,2
811330bc:	8880d826 	beq	r17,r2,81133420 <__gethex+0x784>
811330c0:	e0c0ac0e 	bge	fp,r3,81133374 <__gethex+0x6d8>
811330c4:	01400044 	movi	r5,1
811330c8:	8009883a 	mov	r4,r16
811330cc:	1132b9c0 	call	81132b9c <rshift>
811330d0:	d8c00017 	ldw	r3,0(sp)
811330d4:	bdc00044 	addi	r23,r23,1
811330d8:	18800217 	ldw	r2,8(r3)
811330dc:	15c0a70e 	bge	r2,r23,8113337c <__gethex+0x6e0>
811330e0:	d9000117 	ldw	r4,4(sp)
811330e4:	800b883a 	mov	r5,r16
811330e8:	112c3340 	call	8112c334 <_Bfree>
811330ec:	d9001517 	ldw	r4,84(sp)
811330f0:	008028c4 	movi	r2,163
811330f4:	20000015 	stw	zero,0(r4)
811330f8:	003faa06 	br	81132fa4 <__reset+0xfb112fa4>
811330fc:	01800044 	movi	r6,1
81133100:	80800083 	ldbu	r2,2(r16)
81133104:	81400084 	addi	r5,r16,2
81133108:	003fbc06 	br	81132ffc <__reset+0xfb112ffc>
8113310c:	ada1883a 	add	r16,r21,r22
81133110:	81000003 	ldbu	r4,0(r16)
81133114:	21403fcc 	andi	r5,r4,255
81133118:	a145883a 	add	r2,r20,r5
8113311c:	10800003 	ldbu	r2,0(r2)
81133120:	11803fcc 	andi	r6,r2,255
81133124:	30004f26 	beq	r6,zero,81133264 <__gethex+0x5c8>
81133128:	00c00c04 	movi	r3,48
8113312c:	802b883a 	mov	r21,r16
81133130:	28c0061e 	bne	r5,r3,8113314c <__gethex+0x4b0>
81133134:	2809883a 	mov	r4,r5
81133138:	ad400044 	addi	r21,r21,1
8113313c:	a8800003 	ldbu	r2,0(r21)
81133140:	113ffd26 	beq	r2,r4,81133138 <__reset+0xfb113138>
81133144:	a085883a 	add	r2,r20,r2
81133148:	10800003 	ldbu	r2,0(r2)
8113314c:	10803fcc 	andi	r2,r2,255
81133150:	1015003a 	cmpeq	r10,r2,zero
81133154:	802f883a 	mov	r23,r16
81133158:	04400044 	movi	r17,1
8113315c:	003eff06 	br	81132d5c <__reset+0xfb112d5c>
81133160:	04400044 	movi	r17,1
81133164:	98000926 	beq	r19,zero,8113318c <__gethex+0x4f0>
81133168:	d8c00017 	ldw	r3,0(sp)
8113316c:	18800317 	ldw	r2,12(r3)
81133170:	00c00084 	movi	r3,2
81133174:	10c06826 	beq	r2,r3,81133318 <__gethex+0x67c>
81133178:	00c000c4 	movi	r3,3
8113317c:	10c06a26 	beq	r2,r3,81133328 <__gethex+0x68c>
81133180:	00c00044 	movi	r3,1
81133184:	10c08d26 	beq	r2,r3,811333bc <__gethex+0x720>
81133188:	8c400414 	ori	r17,r17,16
8113318c:	d9001517 	ldw	r4,84(sp)
81133190:	d8c00417 	ldw	r3,16(sp)
81133194:	8805883a 	mov	r2,r17
81133198:	24000015 	stw	r16,0(r4)
8113319c:	1dc00015 	stw	r23,0(r3)
811331a0:	003f8006 	br	81132fa4 <__reset+0xfb112fa4>
811331a4:	000d883a 	mov	r6,zero
811331a8:	003fd506 	br	81133100 <__reset+0xfb113100>
811331ac:	0005883a 	mov	r2,zero
811331b0:	003f7c06 	br	81132fa4 <__reset+0xfb112fa4>
811331b4:	14a3c83a 	sub	r17,r2,r18
811331b8:	880b883a 	mov	r5,r17
811331bc:	8009883a 	mov	r4,r16
811331c0:	112d2540 	call	8112d254 <__any_on>
811331c4:	10002926 	beq	r2,zero,8113326c <__gethex+0x5d0>
811331c8:	897fffc4 	addi	r5,r17,-1
811331cc:	2807d17a 	srai	r3,r5,5
811331d0:	d8800217 	ldw	r2,8(sp)
811331d4:	290007cc 	andi	r4,r5,31
811331d8:	18c7883a 	add	r3,r3,r3
811331dc:	18c7883a 	add	r3,r3,r3
811331e0:	04c00044 	movi	r19,1
811331e4:	10c7883a 	add	r3,r2,r3
811331e8:	9908983a 	sll	r4,r19,r4
811331ec:	18c00017 	ldw	r3,0(r3)
811331f0:	20c6703a 	and	r3,r4,r3
811331f4:	18000626 	beq	r3,zero,81133210 <__gethex+0x574>
811331f8:	99407b0e 	bge	r19,r5,811333e8 <__gethex+0x74c>
811331fc:	897fff84 	addi	r5,r17,-2
81133200:	8009883a 	mov	r4,r16
81133204:	112d2540 	call	8112d254 <__any_on>
81133208:	10007726 	beq	r2,zero,811333e8 <__gethex+0x74c>
8113320c:	04c000c4 	movi	r19,3
81133210:	880b883a 	mov	r5,r17
81133214:	8009883a 	mov	r4,r16
81133218:	1132b9c0 	call	81132b9c <rshift>
8113321c:	bc6f883a 	add	r23,r23,r17
81133220:	003f1f06 	br	81132ea0 <__reset+0xfb112ea0>
81133224:	002f883a 	mov	r23,zero
81133228:	003ee306 	br	81132db8 <__reset+0xfb112db8>
8113322c:	d9000117 	ldw	r4,4(sp)
81133230:	90a3c83a 	sub	r17,r18,r2
81133234:	800b883a 	mov	r5,r16
81133238:	880d883a 	mov	r6,r17
8113323c:	112ca340 	call	8112ca34 <__lshift>
81133240:	10c00504 	addi	r3,r2,20
81133244:	1021883a 	mov	r16,r2
81133248:	bc6fc83a 	sub	r23,r23,r17
8113324c:	d8c00215 	stw	r3,8(sp)
81133250:	0027883a 	mov	r19,zero
81133254:	003f1206 	br	81132ea0 <__reset+0xfb112ea0>
81133258:	1d400084 	addi	r21,r3,2
8113325c:	0023883a 	mov	r17,zero
81133260:	003eb406 	br	81132d34 <__reset+0xfb112d34>
81133264:	2005883a 	mov	r2,r4
81133268:	003f4606 	br	81132f84 <__reset+0xfb112f84>
8113326c:	0027883a 	mov	r19,zero
81133270:	003fe706 	br	81133210 <__reset+0xfb113210>
81133274:	bc7fffc4 	addi	r17,r23,-1
81133278:	9800421e 	bne	r19,zero,81133384 <__gethex+0x6e8>
8113327c:	88000426 	beq	r17,zero,81133290 <__gethex+0x5f4>
81133280:	880b883a 	mov	r5,r17
81133284:	8009883a 	mov	r4,r16
81133288:	112d2540 	call	8112d254 <__any_on>
8113328c:	1027883a 	mov	r19,r2
81133290:	8805d17a 	srai	r2,r17,5
81133294:	d8c00217 	ldw	r3,8(sp)
81133298:	8c4007cc 	andi	r17,r17,31
8113329c:	1085883a 	add	r2,r2,r2
811332a0:	1085883a 	add	r2,r2,r2
811332a4:	1885883a 	add	r2,r3,r2
811332a8:	00c00044 	movi	r3,1
811332ac:	1c62983a 	sll	r17,r3,r17
811332b0:	10800017 	ldw	r2,0(r2)
811332b4:	8884703a 	and	r2,r17,r2
811332b8:	10000126 	beq	r2,zero,811332c0 <__gethex+0x624>
811332bc:	9cc00094 	ori	r19,r19,2
811332c0:	b80b883a 	mov	r5,r23
811332c4:	8009883a 	mov	r4,r16
811332c8:	1132b9c0 	call	81132b9c <rshift>
811332cc:	d8c00017 	ldw	r3,0(sp)
811332d0:	95e5c83a 	sub	r18,r18,r23
811332d4:	04400084 	movi	r17,2
811332d8:	1dc00117 	ldw	r23,4(r3)
811332dc:	003fa106 	br	81133164 <__reset+0xfb113164>
811332e0:	85af883a 	add	r23,r16,r22
811332e4:	b8800003 	ldbu	r2,0(r23)
811332e8:	b821883a 	mov	r16,r23
811332ec:	11003fcc 	andi	r4,r2,255
811332f0:	a109883a 	add	r4,r20,r4
811332f4:	21000003 	ldbu	r4,0(r4)
811332f8:	203eaa26 	beq	r4,zero,81132da4 <__reset+0xfb112da4>
811332fc:	84000044 	addi	r16,r16,1
81133300:	80800003 	ldbu	r2,0(r16)
81133304:	11003fcc 	andi	r4,r2,255
81133308:	a109883a 	add	r4,r20,r4
8113330c:	21000003 	ldbu	r4,0(r4)
81133310:	203ffa1e 	bne	r4,zero,811332fc <__reset+0xfb1132fc>
81133314:	003ea306 	br	81132da4 <__reset+0xfb112da4>
81133318:	d9001617 	ldw	r4,88(sp)
8113331c:	00800044 	movi	r2,1
81133320:	1109c83a 	sub	r4,r2,r4
81133324:	d9001615 	stw	r4,88(sp)
81133328:	d8801617 	ldw	r2,88(sp)
8113332c:	103f9626 	beq	r2,zero,81133188 <__reset+0xfb113188>
81133330:	87000417 	ldw	fp,16(r16)
81133334:	d9800217 	ldw	r6,8(sp)
81133338:	013fffc4 	movi	r4,-1
8113333c:	e727883a 	add	r19,fp,fp
81133340:	9ce7883a 	add	r19,r19,r19
81133344:	3005883a 	mov	r2,r6
81133348:	34cb883a 	add	r5,r6,r19
8113334c:	00000306 	br	8113335c <__gethex+0x6c0>
81133350:	10000015 	stw	zero,0(r2)
81133354:	10800104 	addi	r2,r2,4
81133358:	117f4c2e 	bgeu	r2,r5,8113308c <__reset+0xfb11308c>
8113335c:	10c00017 	ldw	r3,0(r2)
81133360:	193ffb26 	beq	r3,r4,81133350 <__reset+0xfb113350>
81133364:	18c00044 	addi	r3,r3,1
81133368:	10c00015 	stw	r3,0(r2)
8113336c:	00800084 	movi	r2,2
81133370:	88802b26 	beq	r17,r2,81133420 <__gethex+0x784>
81133374:	948007cc 	andi	r18,r18,31
81133378:	90002f1e 	bne	r18,zero,81133438 <__gethex+0x79c>
8113337c:	04400844 	movi	r17,33
81133380:	003f8206 	br	8113318c <__reset+0xfb11318c>
81133384:	04c00044 	movi	r19,1
81133388:	003fc106 	br	81133290 <__reset+0xfb113290>
8113338c:	d8c01617 	ldw	r3,88(sp)
81133390:	183ed226 	beq	r3,zero,81132edc <__reset+0xfb112edc>
81133394:	d8c00417 	ldw	r3,16(sp)
81133398:	d9001517 	ldw	r4,84(sp)
8113339c:	18800015 	stw	r2,0(r3)
811333a0:	d8c00217 	ldw	r3,8(sp)
811333a4:	00800044 	movi	r2,1
811333a8:	80800415 	stw	r2,16(r16)
811333ac:	18800015 	stw	r2,0(r3)
811333b0:	24000015 	stw	r16,0(r4)
811333b4:	00801884 	movi	r2,98
811333b8:	003efa06 	br	81132fa4 <__reset+0xfb112fa4>
811333bc:	9880008c 	andi	r2,r19,2
811333c0:	103f7126 	beq	r2,zero,81133188 <__reset+0xfb113188>
811333c4:	d8c00217 	ldw	r3,8(sp)
811333c8:	18800017 	ldw	r2,0(r3)
811333cc:	9884b03a 	or	r2,r19,r2
811333d0:	1080004c 	andi	r2,r2,1
811333d4:	103fd61e 	bne	r2,zero,81133330 <__reset+0xfb113330>
811333d8:	003f6b06 	br	81133188 <__reset+0xfb113188>
811333dc:	da800217 	ldw	r10,8(sp)
811333e0:	0013883a 	mov	r9,zero
811333e4:	003e9f06 	br	81132e64 <__reset+0xfb112e64>
811333e8:	04c00084 	movi	r19,2
811333ec:	003f8806 	br	81133210 <__reset+0xfb113210>
811333f0:	d9001617 	ldw	r4,88(sp)
811333f4:	203fe726 	beq	r4,zero,81133394 <__reset+0xfb113394>
811333f8:	003eb806 	br	81132edc <__reset+0xfb112edc>
811333fc:	95feb71e 	bne	r18,r23,81132edc <__reset+0xfb112edc>
81133400:	1cbfe40e 	bge	r3,r18,81133394 <__reset+0xfb113394>
81133404:	917fffc4 	addi	r5,r18,-1
81133408:	8009883a 	mov	r4,r16
8113340c:	112d2540 	call	8112d254 <__any_on>
81133410:	103eb226 	beq	r2,zero,81132edc <__reset+0xfb112edc>
81133414:	d8c00017 	ldw	r3,0(sp)
81133418:	18800117 	ldw	r2,4(r3)
8113341c:	003fdd06 	br	81133394 <__reset+0xfb113394>
81133420:	d8c00017 	ldw	r3,0(sp)
81133424:	18800017 	ldw	r2,0(r3)
81133428:	10bfffc4 	addi	r2,r2,-1
8113342c:	90801c26 	beq	r18,r2,811334a0 <__gethex+0x804>
81133430:	04400884 	movi	r17,34
81133434:	003f5506 	br	8113318c <__reset+0xfb11318c>
81133438:	34c5883a 	add	r2,r6,r19
8113343c:	113fff17 	ldw	r4,-4(r2)
81133440:	112c5900 	call	8112c590 <__hi0bits>
81133444:	00c00804 	movi	r3,32
81133448:	1ca5c83a 	sub	r18,r3,r18
8113344c:	14bfcb0e 	bge	r2,r18,8113337c <__reset+0xfb11337c>
81133450:	003f1c06 	br	811330c4 <__reset+0xfb1130c4>
81133454:	81400117 	ldw	r5,4(r16)
81133458:	d9000117 	ldw	r4,4(sp)
8113345c:	29400044 	addi	r5,r5,1
81133460:	112c2840 	call	8112c284 <_Balloc>
81133464:	81800417 	ldw	r6,16(r16)
81133468:	81400304 	addi	r5,r16,12
8113346c:	11000304 	addi	r4,r2,12
81133470:	31800084 	addi	r6,r6,2
81133474:	318d883a 	add	r6,r6,r6
81133478:	318d883a 	add	r6,r6,r6
8113347c:	1029883a 	mov	r20,r2
81133480:	11220540 	call	81122054 <memcpy>
81133484:	d9000117 	ldw	r4,4(sp)
81133488:	800b883a 	mov	r5,r16
8113348c:	a021883a 	mov	r16,r20
81133490:	112c3340 	call	8112c334 <_Bfree>
81133494:	a0c00417 	ldw	r3,16(r20)
81133498:	a1800504 	addi	r6,r20,20
8113349c:	003efe06 	br	81133098 <__reset+0xfb113098>
811334a0:	9005d17a 	srai	r2,r18,5
811334a4:	944007cc 	andi	r17,r18,31
811334a8:	1085883a 	add	r2,r2,r2
811334ac:	1085883a 	add	r2,r2,r2
811334b0:	3087883a 	add	r3,r6,r2
811334b4:	00800044 	movi	r2,1
811334b8:	1462983a 	sll	r17,r2,r17
811334bc:	18800017 	ldw	r2,0(r3)
811334c0:	8884703a 	and	r2,r17,r2
811334c4:	1022c03a 	cmpne	r17,r2,zero
811334c8:	00800884 	movi	r2,34
811334cc:	1463c83a 	sub	r17,r2,r17
811334d0:	003f2e06 	br	8113318c <__reset+0xfb11318c>

811334d4 <__hexnan>:
811334d4:	defff904 	addi	sp,sp,-28
811334d8:	de00012e 	bgeu	sp,et,811334e0 <__hexnan+0xc>
811334dc:	003b68fa 	trap	3
811334e0:	dc800215 	stw	r18,8(sp)
811334e4:	2c800017 	ldw	r18,0(r5)
811334e8:	dfc00615 	stw	ra,24(sp)
811334ec:	dd400515 	stw	r21,20(sp)
811334f0:	901fd17a 	srai	r15,r18,5
811334f4:	dd000415 	stw	r20,16(sp)
811334f8:	dcc00315 	stw	r19,12(sp)
811334fc:	7bdf883a 	add	r15,r15,r15
81133500:	7bdf883a 	add	r15,r15,r15
81133504:	dc400115 	stw	r17,4(sp)
81133508:	dc000015 	stw	r16,0(sp)
8113350c:	948007cc 	andi	r18,r18,31
81133510:	33df883a 	add	r15,r6,r15
81133514:	90000126 	beq	r18,zero,8113351c <__hexnan+0x48>
81133518:	7bc00104 	addi	r15,r15,4
8113351c:	22000017 	ldw	r8,0(r4)
81133520:	7affff04 	addi	r11,r15,-4
81133524:	03a04574 	movhi	r14,33045
81133528:	783fff15 	stw	zero,-4(r15)
8113352c:	581b883a 	mov	r13,r11
81133530:	580b883a 	mov	r5,r11
81133534:	000f883a 	mov	r7,zero
81133538:	003f883a 	mov	ra,zero
8113353c:	0019883a 	mov	r12,zero
81133540:	7381a304 	addi	r14,r14,1676
81133544:	04400204 	movi	r17,8
81133548:	04000804 	movi	r16,32
8113354c:	04c001c4 	movi	r19,7
81133550:	42000044 	addi	r8,r8,1
81133554:	40c00003 	ldbu	r3,0(r8)
81133558:	18001d26 	beq	r3,zero,811335d0 <__hexnan+0xfc>
8113355c:	70c5883a 	add	r2,r14,r3
81133560:	10800003 	ldbu	r2,0(r2)
81133564:	12403fcc 	andi	r9,r2,255
81133568:	4800301e 	bne	r9,zero,8113362c <__hexnan+0x158>
8113356c:	80c04236 	bltu	r16,r3,81133678 <__hexnan+0x1a4>
81133570:	fb3ff70e 	bge	ra,r12,81133550 <__reset+0xfb113550>
81133574:	2b40112e 	bgeu	r5,r13,811335bc <__hexnan+0xe8>
81133578:	99c01016 	blt	r19,r7,811335bc <__hexnan+0xe8>
8113357c:	89e9c83a 	sub	r20,r17,r7
81133580:	a529883a 	add	r20,r20,r20
81133584:	2a800017 	ldw	r10,0(r5)
81133588:	a529883a 	add	r20,r20,r20
8113358c:	852bc83a 	sub	r21,r16,r20
81133590:	28c00104 	addi	r3,r5,4
81133594:	2805883a 	mov	r2,r5
81133598:	19c00017 	ldw	r7,0(r3)
8113359c:	10800104 	addi	r2,r2,4
811335a0:	18c00104 	addi	r3,r3,4
811335a4:	3d52983a 	sll	r9,r7,r21
811335a8:	4a92b03a 	or	r9,r9,r10
811335ac:	3d14d83a 	srl	r10,r7,r20
811335b0:	127fff15 	stw	r9,-4(r2)
811335b4:	1abfff15 	stw	r10,-4(r3)
811335b8:	137ff736 	bltu	r2,r13,81133598 <__reset+0xfb113598>
811335bc:	31402836 	bltu	r6,r5,81133660 <__hexnan+0x18c>
811335c0:	42000044 	addi	r8,r8,1
811335c4:	40c00003 	ldbu	r3,0(r8)
811335c8:	01c00204 	movi	r7,8
811335cc:	183fe31e 	bne	r3,zero,8113355c <__reset+0xfb11355c>
811335d0:	60002b26 	beq	r12,zero,81133680 <__hexnan+0x1ac>
811335d4:	2b40022e 	bgeu	r5,r13,811335e0 <__hexnan+0x10c>
811335d8:	008001c4 	movi	r2,7
811335dc:	11c0430e 	bge	r2,r7,811336ec <__hexnan+0x218>
811335e0:	3140312e 	bgeu	r6,r5,811336a8 <__hexnan+0x1d4>
811335e4:	3007883a 	mov	r3,r6
811335e8:	29000017 	ldw	r4,0(r5)
811335ec:	18800104 	addi	r2,r3,4
811335f0:	29400104 	addi	r5,r5,4
811335f4:	19000015 	stw	r4,0(r3)
811335f8:	1007883a 	mov	r3,r2
811335fc:	597ffa2e 	bgeu	r11,r5,811335e8 <__reset+0xfb1135e8>
81133600:	10000015 	stw	zero,0(r2)
81133604:	10800104 	addi	r2,r2,4
81133608:	58bffd2e 	bgeu	r11,r2,81133600 <__reset+0xfb113600>
8113360c:	78bfff17 	ldw	r2,-4(r15)
81133610:	1000041e 	bne	r2,zero,81133624 <__hexnan+0x150>
81133614:	32c02d26 	beq	r6,r11,811336cc <__hexnan+0x1f8>
81133618:	5affff04 	addi	r11,r11,-4
8113361c:	58800017 	ldw	r2,0(r11)
81133620:	103ffc26 	beq	r2,zero,81133614 <__reset+0xfb113614>
81133624:	00800144 	movi	r2,5
81133628:	00001606 	br	81133684 <__hexnan+0x1b0>
8113362c:	39c00044 	addi	r7,r7,1
81133630:	63000044 	addi	r12,r12,1
81133634:	89c0040e 	bge	r17,r7,81133648 <__hexnan+0x174>
81133638:	317fc52e 	bgeu	r6,r5,81133550 <__reset+0xfb113550>
8113363c:	283fff15 	stw	zero,-4(r5)
81133640:	01c00044 	movi	r7,1
81133644:	297fff04 	addi	r5,r5,-4
81133648:	28c00017 	ldw	r3,0(r5)
8113364c:	108003cc 	andi	r2,r2,15
81133650:	1806913a 	slli	r3,r3,4
81133654:	1884b03a 	or	r2,r3,r2
81133658:	28800015 	stw	r2,0(r5)
8113365c:	003fbc06 	br	81133550 <__reset+0xfb113550>
81133660:	2b7fff04 	addi	r13,r5,-4
81133664:	283fff15 	stw	zero,-4(r5)
81133668:	603f883a 	mov	ra,r12
8113366c:	680b883a 	mov	r5,r13
81133670:	000f883a 	mov	r7,zero
81133674:	003fb606 	br	81133550 <__reset+0xfb113550>
81133678:	00800a44 	movi	r2,41
8113367c:	18801726 	beq	r3,r2,811336dc <__hexnan+0x208>
81133680:	00800104 	movi	r2,4
81133684:	dfc00617 	ldw	ra,24(sp)
81133688:	dd400517 	ldw	r21,20(sp)
8113368c:	dd000417 	ldw	r20,16(sp)
81133690:	dcc00317 	ldw	r19,12(sp)
81133694:	dc800217 	ldw	r18,8(sp)
81133698:	dc400117 	ldw	r17,4(sp)
8113369c:	dc000017 	ldw	r16,0(sp)
811336a0:	dec00704 	addi	sp,sp,28
811336a4:	f800283a 	ret
811336a8:	903fd826 	beq	r18,zero,8113360c <__reset+0xfb11360c>
811336ac:	00c00804 	movi	r3,32
811336b0:	1ca5c83a 	sub	r18,r3,r18
811336b4:	00ffffc4 	movi	r3,-1
811336b8:	78bfff17 	ldw	r2,-4(r15)
811336bc:	1c86d83a 	srl	r3,r3,r18
811336c0:	1884703a 	and	r2,r3,r2
811336c4:	78bfff15 	stw	r2,-4(r15)
811336c8:	003fd106 	br	81133610 <__reset+0xfb113610>
811336cc:	00800044 	movi	r2,1
811336d0:	58800015 	stw	r2,0(r11)
811336d4:	00800144 	movi	r2,5
811336d8:	003fea06 	br	81133684 <__reset+0xfb113684>
811336dc:	42000044 	addi	r8,r8,1
811336e0:	22000015 	stw	r8,0(r4)
811336e4:	603fbb1e 	bne	r12,zero,811335d4 <__reset+0xfb1135d4>
811336e8:	003fe506 	br	81133680 <__reset+0xfb113680>
811336ec:	02400204 	movi	r9,8
811336f0:	49d3c83a 	sub	r9,r9,r7
811336f4:	4a53883a 	add	r9,r9,r9
811336f8:	2a000017 	ldw	r8,0(r5)
811336fc:	4a53883a 	add	r9,r9,r9
81133700:	02800804 	movi	r10,32
81133704:	5255c83a 	sub	r10,r10,r9
81133708:	28c00104 	addi	r3,r5,4
8113370c:	2805883a 	mov	r2,r5
81133710:	19c00017 	ldw	r7,0(r3)
81133714:	10800104 	addi	r2,r2,4
81133718:	18c00104 	addi	r3,r3,4
8113371c:	3a88983a 	sll	r4,r7,r10
81133720:	2208b03a 	or	r4,r4,r8
81133724:	3a50d83a 	srl	r8,r7,r9
81133728:	113fff15 	stw	r4,-4(r2)
8113372c:	1a3fff15 	stw	r8,-4(r3)
81133730:	137ff736 	bltu	r2,r13,81133710 <__reset+0xfb113710>
81133734:	003faa06 	br	811335e0 <__reset+0xfb1135e0>

81133738 <strncmp>:
81133738:	30003126 	beq	r6,zero,81133800 <strncmp+0xc8>
8113373c:	2144b03a 	or	r2,r4,r5
81133740:	108000cc 	andi	r2,r2,3
81133744:	10001e1e 	bne	r2,zero,811337c0 <strncmp+0x88>
81133748:	024000c4 	movi	r9,3
8113374c:	49801c2e 	bgeu	r9,r6,811337c0 <strncmp+0x88>
81133750:	20800017 	ldw	r2,0(r4)
81133754:	28c00017 	ldw	r3,0(r5)
81133758:	10c0191e 	bne	r2,r3,811337c0 <strncmp+0x88>
8113375c:	31bfff04 	addi	r6,r6,-4
81133760:	30002726 	beq	r6,zero,81133800 <strncmp+0xc8>
81133764:	02ffbff4 	movhi	r11,65279
81133768:	5affbfc4 	addi	r11,r11,-257
8113376c:	0086303a 	nor	r3,zero,r2
81133770:	02a02074 	movhi	r10,32897
81133774:	12c5883a 	add	r2,r2,r11
81133778:	52a02004 	addi	r10,r10,-32640
8113377c:	10c4703a 	and	r2,r2,r3
81133780:	1284703a 	and	r2,r2,r10
81133784:	10000b26 	beq	r2,zero,811337b4 <strncmp+0x7c>
81133788:	00001d06 	br	81133800 <strncmp+0xc8>
8113378c:	20c00017 	ldw	r3,0(r4)
81133790:	29c00017 	ldw	r7,0(r5)
81133794:	1ad1883a 	add	r8,r3,r11
81133798:	00c4303a 	nor	r2,zero,r3
8113379c:	4084703a 	and	r2,r8,r2
811337a0:	1284703a 	and	r2,r2,r10
811337a4:	19c0061e 	bne	r3,r7,811337c0 <strncmp+0x88>
811337a8:	31bfff04 	addi	r6,r6,-4
811337ac:	30001426 	beq	r6,zero,81133800 <strncmp+0xc8>
811337b0:	1000131e 	bne	r2,zero,81133800 <strncmp+0xc8>
811337b4:	21000104 	addi	r4,r4,4
811337b8:	29400104 	addi	r5,r5,4
811337bc:	49bff336 	bltu	r9,r6,8113378c <__reset+0xfb11378c>
811337c0:	28800007 	ldb	r2,0(r5)
811337c4:	20c00007 	ldb	r3,0(r4)
811337c8:	31bfffc4 	addi	r6,r6,-1
811337cc:	10c0081e 	bne	r2,r3,811337f0 <strncmp+0xb8>
811337d0:	30000b26 	beq	r6,zero,81133800 <strncmp+0xc8>
811337d4:	10000a26 	beq	r2,zero,81133800 <strncmp+0xc8>
811337d8:	21000044 	addi	r4,r4,1
811337dc:	29400044 	addi	r5,r5,1
811337e0:	20800007 	ldb	r2,0(r4)
811337e4:	28c00007 	ldb	r3,0(r5)
811337e8:	31bfffc4 	addi	r6,r6,-1
811337ec:	10fff826 	beq	r2,r3,811337d0 <__reset+0xfb1137d0>
811337f0:	20800003 	ldbu	r2,0(r4)
811337f4:	28c00003 	ldbu	r3,0(r5)
811337f8:	10c5c83a 	sub	r2,r2,r3
811337fc:	f800283a 	ret
81133800:	0005883a 	mov	r2,zero
81133804:	f800283a 	ret

81133808 <_wcrtomb_r>:
81133808:	defff604 	addi	sp,sp,-40
8113380c:	00a04574 	movhi	r2,33045
81133810:	de00012e 	bgeu	sp,et,81133818 <_wcrtomb_r+0x10>
81133814:	003b68fa 	trap	3
81133818:	108add04 	addi	r2,r2,11124
8113381c:	dc800815 	stw	r18,32(sp)
81133820:	dc400715 	stw	r17,28(sp)
81133824:	dc000615 	stw	r16,24(sp)
81133828:	dfc00915 	stw	ra,36(sp)
8113382c:	2021883a 	mov	r16,r4
81133830:	3823883a 	mov	r17,r7
81133834:	14800017 	ldw	r18,0(r2)
81133838:	28001426 	beq	r5,zero,8113388c <_wcrtomb_r+0x84>
8113383c:	d9400415 	stw	r5,16(sp)
81133840:	d9800515 	stw	r6,20(sp)
81133844:	112bd380 	call	8112bd38 <__locale_charset>
81133848:	d9800517 	ldw	r6,20(sp)
8113384c:	d9400417 	ldw	r5,16(sp)
81133850:	100f883a 	mov	r7,r2
81133854:	dc400015 	stw	r17,0(sp)
81133858:	8009883a 	mov	r4,r16
8113385c:	903ee83a 	callr	r18
81133860:	00ffffc4 	movi	r3,-1
81133864:	10c0031e 	bne	r2,r3,81133874 <_wcrtomb_r+0x6c>
81133868:	88000015 	stw	zero,0(r17)
8113386c:	00c02284 	movi	r3,138
81133870:	80c00015 	stw	r3,0(r16)
81133874:	dfc00917 	ldw	ra,36(sp)
81133878:	dc800817 	ldw	r18,32(sp)
8113387c:	dc400717 	ldw	r17,28(sp)
81133880:	dc000617 	ldw	r16,24(sp)
81133884:	dec00a04 	addi	sp,sp,40
81133888:	f800283a 	ret
8113388c:	112bd380 	call	8112bd38 <__locale_charset>
81133890:	100f883a 	mov	r7,r2
81133894:	dc400015 	stw	r17,0(sp)
81133898:	000d883a 	mov	r6,zero
8113389c:	d9400104 	addi	r5,sp,4
811338a0:	8009883a 	mov	r4,r16
811338a4:	903ee83a 	callr	r18
811338a8:	003fed06 	br	81133860 <__reset+0xfb113860>

811338ac <wcrtomb>:
811338ac:	defff604 	addi	sp,sp,-40
811338b0:	00a04574 	movhi	r2,33045
811338b4:	de00012e 	bgeu	sp,et,811338bc <wcrtomb+0x10>
811338b8:	003b68fa 	trap	3
811338bc:	108ad804 	addi	r2,r2,11104
811338c0:	dc800615 	stw	r18,24(sp)
811338c4:	dc400515 	stw	r17,20(sp)
811338c8:	dfc00915 	stw	ra,36(sp)
811338cc:	dd000815 	stw	r20,32(sp)
811338d0:	dcc00715 	stw	r19,28(sp)
811338d4:	dc000415 	stw	r16,16(sp)
811338d8:	3025883a 	mov	r18,r6
811338dc:	14400017 	ldw	r17,0(r2)
811338e0:	20001926 	beq	r4,zero,81133948 <wcrtomb+0x9c>
811338e4:	00a04574 	movhi	r2,33045
811338e8:	108add04 	addi	r2,r2,11124
811338ec:	15000017 	ldw	r20,0(r2)
811338f0:	2021883a 	mov	r16,r4
811338f4:	2827883a 	mov	r19,r5
811338f8:	112bd380 	call	8112bd38 <__locale_charset>
811338fc:	100f883a 	mov	r7,r2
81133900:	dc800015 	stw	r18,0(sp)
81133904:	980d883a 	mov	r6,r19
81133908:	800b883a 	mov	r5,r16
8113390c:	8809883a 	mov	r4,r17
81133910:	a03ee83a 	callr	r20
81133914:	00ffffc4 	movi	r3,-1
81133918:	10c0031e 	bne	r2,r3,81133928 <wcrtomb+0x7c>
8113391c:	90000015 	stw	zero,0(r18)
81133920:	00c02284 	movi	r3,138
81133924:	88c00015 	stw	r3,0(r17)
81133928:	dfc00917 	ldw	ra,36(sp)
8113392c:	dd000817 	ldw	r20,32(sp)
81133930:	dcc00717 	ldw	r19,28(sp)
81133934:	dc800617 	ldw	r18,24(sp)
81133938:	dc400517 	ldw	r17,20(sp)
8113393c:	dc000417 	ldw	r16,16(sp)
81133940:	dec00a04 	addi	sp,sp,40
81133944:	f800283a 	ret
81133948:	00a04574 	movhi	r2,33045
8113394c:	108add04 	addi	r2,r2,11124
81133950:	14000017 	ldw	r16,0(r2)
81133954:	112bd380 	call	8112bd38 <__locale_charset>
81133958:	100f883a 	mov	r7,r2
8113395c:	dc800015 	stw	r18,0(sp)
81133960:	000d883a 	mov	r6,zero
81133964:	d9400104 	addi	r5,sp,4
81133968:	8809883a 	mov	r4,r17
8113396c:	803ee83a 	callr	r16
81133970:	003fe806 	br	81133914 <__reset+0xfb113914>

81133974 <__ascii_wctomb>:
81133974:	28000526 	beq	r5,zero,8113398c <__ascii_wctomb+0x18>
81133978:	00803fc4 	movi	r2,255
8113397c:	11800536 	bltu	r2,r6,81133994 <__ascii_wctomb+0x20>
81133980:	29800005 	stb	r6,0(r5)
81133984:	00800044 	movi	r2,1
81133988:	f800283a 	ret
8113398c:	0005883a 	mov	r2,zero
81133990:	f800283a 	ret
81133994:	00802284 	movi	r2,138
81133998:	20800015 	stw	r2,0(r4)
8113399c:	00bfffc4 	movi	r2,-1
811339a0:	f800283a 	ret

811339a4 <_wctomb_r>:
811339a4:	00a04574 	movhi	r2,33045
811339a8:	defff904 	addi	sp,sp,-28
811339ac:	108add04 	addi	r2,r2,11124
811339b0:	de00012e 	bgeu	sp,et,811339b8 <_wctomb_r+0x14>
811339b4:	003b68fa 	trap	3
811339b8:	dfc00615 	stw	ra,24(sp)
811339bc:	dc400515 	stw	r17,20(sp)
811339c0:	dc000415 	stw	r16,16(sp)
811339c4:	3823883a 	mov	r17,r7
811339c8:	14000017 	ldw	r16,0(r2)
811339cc:	d9000115 	stw	r4,4(sp)
811339d0:	d9400215 	stw	r5,8(sp)
811339d4:	d9800315 	stw	r6,12(sp)
811339d8:	112bd380 	call	8112bd38 <__locale_charset>
811339dc:	d9800317 	ldw	r6,12(sp)
811339e0:	d9400217 	ldw	r5,8(sp)
811339e4:	d9000117 	ldw	r4,4(sp)
811339e8:	100f883a 	mov	r7,r2
811339ec:	dc400015 	stw	r17,0(sp)
811339f0:	803ee83a 	callr	r16
811339f4:	dfc00617 	ldw	ra,24(sp)
811339f8:	dc400517 	ldw	r17,20(sp)
811339fc:	dc000417 	ldw	r16,16(sp)
81133a00:	dec00704 	addi	sp,sp,28
81133a04:	f800283a 	ret

81133a08 <__udivdi3>:
81133a08:	defff504 	addi	sp,sp,-44
81133a0c:	de00012e 	bgeu	sp,et,81133a14 <__udivdi3+0xc>
81133a10:	003b68fa 	trap	3
81133a14:	dcc00415 	stw	r19,16(sp)
81133a18:	dc000115 	stw	r16,4(sp)
81133a1c:	dfc00a15 	stw	ra,40(sp)
81133a20:	df000915 	stw	fp,36(sp)
81133a24:	ddc00815 	stw	r23,32(sp)
81133a28:	dd800715 	stw	r22,28(sp)
81133a2c:	dd400615 	stw	r21,24(sp)
81133a30:	dd000515 	stw	r20,20(sp)
81133a34:	dc800315 	stw	r18,12(sp)
81133a38:	dc400215 	stw	r17,8(sp)
81133a3c:	2027883a 	mov	r19,r4
81133a40:	2821883a 	mov	r16,r5
81133a44:	3800411e 	bne	r7,zero,81133b4c <__udivdi3+0x144>
81133a48:	3023883a 	mov	r17,r6
81133a4c:	2025883a 	mov	r18,r4
81133a50:	2980522e 	bgeu	r5,r6,81133b9c <__udivdi3+0x194>
81133a54:	00bfffd4 	movui	r2,65535
81133a58:	282d883a 	mov	r22,r5
81133a5c:	1180a836 	bltu	r2,r6,81133d00 <__udivdi3+0x2f8>
81133a60:	00803fc4 	movi	r2,255
81133a64:	1185803a 	cmpltu	r2,r2,r6
81133a68:	100490fa 	slli	r2,r2,3
81133a6c:	3086d83a 	srl	r3,r6,r2
81133a70:	01204574 	movhi	r4,33045
81133a74:	21001d04 	addi	r4,r4,116
81133a78:	20c7883a 	add	r3,r4,r3
81133a7c:	18c00003 	ldbu	r3,0(r3)
81133a80:	1885883a 	add	r2,r3,r2
81133a84:	00c00804 	movi	r3,32
81133a88:	1887c83a 	sub	r3,r3,r2
81133a8c:	18000526 	beq	r3,zero,81133aa4 <__udivdi3+0x9c>
81133a90:	80e0983a 	sll	r16,r16,r3
81133a94:	9884d83a 	srl	r2,r19,r2
81133a98:	30e2983a 	sll	r17,r6,r3
81133a9c:	98e4983a 	sll	r18,r19,r3
81133aa0:	142cb03a 	or	r22,r2,r16
81133aa4:	882ad43a 	srli	r21,r17,16
81133aa8:	b009883a 	mov	r4,r22
81133aac:	8d3fffcc 	andi	r20,r17,65535
81133ab0:	a80b883a 	mov	r5,r21
81133ab4:	11346240 	call	81134624 <__umodsi3>
81133ab8:	b009883a 	mov	r4,r22
81133abc:	a80b883a 	mov	r5,r21
81133ac0:	1027883a 	mov	r19,r2
81133ac4:	11345c00 	call	811345c0 <__udivsi3>
81133ac8:	102d883a 	mov	r22,r2
81133acc:	9826943a 	slli	r19,r19,16
81133ad0:	9004d43a 	srli	r2,r18,16
81133ad4:	a5a1383a 	mul	r16,r20,r22
81133ad8:	14c4b03a 	or	r2,r2,r19
81133adc:	1400052e 	bgeu	r2,r16,81133af4 <__udivdi3+0xec>
81133ae0:	1445883a 	add	r2,r2,r17
81133ae4:	b0ffffc4 	addi	r3,r22,-1
81133ae8:	14400136 	bltu	r2,r17,81133af0 <__udivdi3+0xe8>
81133aec:	14012336 	bltu	r2,r16,81133f7c <__udivdi3+0x574>
81133af0:	182d883a 	mov	r22,r3
81133af4:	1421c83a 	sub	r16,r2,r16
81133af8:	a80b883a 	mov	r5,r21
81133afc:	8009883a 	mov	r4,r16
81133b00:	11346240 	call	81134624 <__umodsi3>
81133b04:	1027883a 	mov	r19,r2
81133b08:	a80b883a 	mov	r5,r21
81133b0c:	8009883a 	mov	r4,r16
81133b10:	11345c00 	call	811345c0 <__udivsi3>
81133b14:	9826943a 	slli	r19,r19,16
81133b18:	a0a9383a 	mul	r20,r20,r2
81133b1c:	94bfffcc 	andi	r18,r18,65535
81133b20:	94e4b03a 	or	r18,r18,r19
81133b24:	9500052e 	bgeu	r18,r20,81133b3c <__udivdi3+0x134>
81133b28:	8ca5883a 	add	r18,r17,r18
81133b2c:	10ffffc4 	addi	r3,r2,-1
81133b30:	9440f136 	bltu	r18,r17,81133ef8 <__udivdi3+0x4f0>
81133b34:	9500f02e 	bgeu	r18,r20,81133ef8 <__udivdi3+0x4f0>
81133b38:	10bfff84 	addi	r2,r2,-2
81133b3c:	b00c943a 	slli	r6,r22,16
81133b40:	0007883a 	mov	r3,zero
81133b44:	3084b03a 	or	r2,r6,r2
81133b48:	00005906 	br	81133cb0 <__udivdi3+0x2a8>
81133b4c:	29c05636 	bltu	r5,r7,81133ca8 <__udivdi3+0x2a0>
81133b50:	00bfffd4 	movui	r2,65535
81133b54:	11c0622e 	bgeu	r2,r7,81133ce0 <__udivdi3+0x2d8>
81133b58:	00804034 	movhi	r2,256
81133b5c:	10bfffc4 	addi	r2,r2,-1
81133b60:	11c0ee36 	bltu	r2,r7,81133f1c <__udivdi3+0x514>
81133b64:	00800404 	movi	r2,16
81133b68:	3886d83a 	srl	r3,r7,r2
81133b6c:	01204574 	movhi	r4,33045
81133b70:	21001d04 	addi	r4,r4,116
81133b74:	20c7883a 	add	r3,r4,r3
81133b78:	18c00003 	ldbu	r3,0(r3)
81133b7c:	05400804 	movi	r21,32
81133b80:	1885883a 	add	r2,r3,r2
81133b84:	a8abc83a 	sub	r21,r21,r2
81133b88:	a800621e 	bne	r21,zero,81133d14 <__udivdi3+0x30c>
81133b8c:	3c00e936 	bltu	r7,r16,81133f34 <__udivdi3+0x52c>
81133b90:	9985403a 	cmpgeu	r2,r19,r6
81133b94:	0007883a 	mov	r3,zero
81133b98:	00004506 	br	81133cb0 <__udivdi3+0x2a8>
81133b9c:	3000041e 	bne	r6,zero,81133bb0 <__udivdi3+0x1a8>
81133ba0:	000b883a 	mov	r5,zero
81133ba4:	01000044 	movi	r4,1
81133ba8:	11345c00 	call	811345c0 <__udivsi3>
81133bac:	1023883a 	mov	r17,r2
81133bb0:	00bfffd4 	movui	r2,65535
81133bb4:	14404e2e 	bgeu	r2,r17,81133cf0 <__udivdi3+0x2e8>
81133bb8:	00804034 	movhi	r2,256
81133bbc:	10bfffc4 	addi	r2,r2,-1
81133bc0:	1440d836 	bltu	r2,r17,81133f24 <__udivdi3+0x51c>
81133bc4:	00800404 	movi	r2,16
81133bc8:	8886d83a 	srl	r3,r17,r2
81133bcc:	01204574 	movhi	r4,33045
81133bd0:	21001d04 	addi	r4,r4,116
81133bd4:	20c7883a 	add	r3,r4,r3
81133bd8:	18c00003 	ldbu	r3,0(r3)
81133bdc:	1885883a 	add	r2,r3,r2
81133be0:	00c00804 	movi	r3,32
81133be4:	1887c83a 	sub	r3,r3,r2
81133be8:	18008f1e 	bne	r3,zero,81133e28 <__udivdi3+0x420>
81133bec:	882ad43a 	srli	r21,r17,16
81133bf0:	8461c83a 	sub	r16,r16,r17
81133bf4:	8d3fffcc 	andi	r20,r17,65535
81133bf8:	00c00044 	movi	r3,1
81133bfc:	8009883a 	mov	r4,r16
81133c00:	a80b883a 	mov	r5,r21
81133c04:	d8c00015 	stw	r3,0(sp)
81133c08:	11346240 	call	81134624 <__umodsi3>
81133c0c:	8009883a 	mov	r4,r16
81133c10:	a80b883a 	mov	r5,r21
81133c14:	1027883a 	mov	r19,r2
81133c18:	11345c00 	call	811345c0 <__udivsi3>
81133c1c:	9826943a 	slli	r19,r19,16
81133c20:	9008d43a 	srli	r4,r18,16
81133c24:	1521383a 	mul	r16,r2,r20
81133c28:	102d883a 	mov	r22,r2
81133c2c:	24c8b03a 	or	r4,r4,r19
81133c30:	d8c00017 	ldw	r3,0(sp)
81133c34:	2400052e 	bgeu	r4,r16,81133c4c <__udivdi3+0x244>
81133c38:	2449883a 	add	r4,r4,r17
81133c3c:	b0bfffc4 	addi	r2,r22,-1
81133c40:	24400136 	bltu	r4,r17,81133c48 <__udivdi3+0x240>
81133c44:	2400ca36 	bltu	r4,r16,81133f70 <__udivdi3+0x568>
81133c48:	102d883a 	mov	r22,r2
81133c4c:	2421c83a 	sub	r16,r4,r16
81133c50:	a80b883a 	mov	r5,r21
81133c54:	8009883a 	mov	r4,r16
81133c58:	d8c00015 	stw	r3,0(sp)
81133c5c:	11346240 	call	81134624 <__umodsi3>
81133c60:	1027883a 	mov	r19,r2
81133c64:	a80b883a 	mov	r5,r21
81133c68:	8009883a 	mov	r4,r16
81133c6c:	11345c00 	call	811345c0 <__udivsi3>
81133c70:	9826943a 	slli	r19,r19,16
81133c74:	1529383a 	mul	r20,r2,r20
81133c78:	94bfffcc 	andi	r18,r18,65535
81133c7c:	94e4b03a 	or	r18,r18,r19
81133c80:	d8c00017 	ldw	r3,0(sp)
81133c84:	9500052e 	bgeu	r18,r20,81133c9c <__udivdi3+0x294>
81133c88:	8ca5883a 	add	r18,r17,r18
81133c8c:	113fffc4 	addi	r4,r2,-1
81133c90:	94409736 	bltu	r18,r17,81133ef0 <__udivdi3+0x4e8>
81133c94:	9500962e 	bgeu	r18,r20,81133ef0 <__udivdi3+0x4e8>
81133c98:	10bfff84 	addi	r2,r2,-2
81133c9c:	b00c943a 	slli	r6,r22,16
81133ca0:	3084b03a 	or	r2,r6,r2
81133ca4:	00000206 	br	81133cb0 <__udivdi3+0x2a8>
81133ca8:	0007883a 	mov	r3,zero
81133cac:	0005883a 	mov	r2,zero
81133cb0:	dfc00a17 	ldw	ra,40(sp)
81133cb4:	df000917 	ldw	fp,36(sp)
81133cb8:	ddc00817 	ldw	r23,32(sp)
81133cbc:	dd800717 	ldw	r22,28(sp)
81133cc0:	dd400617 	ldw	r21,24(sp)
81133cc4:	dd000517 	ldw	r20,20(sp)
81133cc8:	dcc00417 	ldw	r19,16(sp)
81133ccc:	dc800317 	ldw	r18,12(sp)
81133cd0:	dc400217 	ldw	r17,8(sp)
81133cd4:	dc000117 	ldw	r16,4(sp)
81133cd8:	dec00b04 	addi	sp,sp,44
81133cdc:	f800283a 	ret
81133ce0:	00803fc4 	movi	r2,255
81133ce4:	11c5803a 	cmpltu	r2,r2,r7
81133ce8:	100490fa 	slli	r2,r2,3
81133cec:	003f9e06 	br	81133b68 <__reset+0xfb113b68>
81133cf0:	00803fc4 	movi	r2,255
81133cf4:	1445803a 	cmpltu	r2,r2,r17
81133cf8:	100490fa 	slli	r2,r2,3
81133cfc:	003fb206 	br	81133bc8 <__reset+0xfb113bc8>
81133d00:	00804034 	movhi	r2,256
81133d04:	10bfffc4 	addi	r2,r2,-1
81133d08:	11808836 	bltu	r2,r6,81133f2c <__udivdi3+0x524>
81133d0c:	00800404 	movi	r2,16
81133d10:	003f5606 	br	81133a6c <__reset+0xfb113a6c>
81133d14:	30aed83a 	srl	r23,r6,r2
81133d18:	3d4e983a 	sll	r7,r7,r21
81133d1c:	80acd83a 	srl	r22,r16,r2
81133d20:	9884d83a 	srl	r2,r19,r2
81133d24:	3deeb03a 	or	r23,r7,r23
81133d28:	b824d43a 	srli	r18,r23,16
81133d2c:	8560983a 	sll	r16,r16,r21
81133d30:	b009883a 	mov	r4,r22
81133d34:	900b883a 	mov	r5,r18
81133d38:	3568983a 	sll	r20,r6,r21
81133d3c:	1420b03a 	or	r16,r2,r16
81133d40:	11346240 	call	81134624 <__umodsi3>
81133d44:	b009883a 	mov	r4,r22
81133d48:	900b883a 	mov	r5,r18
81133d4c:	1023883a 	mov	r17,r2
81133d50:	11345c00 	call	811345c0 <__udivsi3>
81133d54:	8808943a 	slli	r4,r17,16
81133d58:	bf3fffcc 	andi	fp,r23,65535
81133d5c:	8006d43a 	srli	r3,r16,16
81133d60:	e0a3383a 	mul	r17,fp,r2
81133d64:	100d883a 	mov	r6,r2
81133d68:	1906b03a 	or	r3,r3,r4
81133d6c:	1c40042e 	bgeu	r3,r17,81133d80 <__udivdi3+0x378>
81133d70:	1dc7883a 	add	r3,r3,r23
81133d74:	10bfffc4 	addi	r2,r2,-1
81133d78:	1dc0752e 	bgeu	r3,r23,81133f50 <__udivdi3+0x548>
81133d7c:	100d883a 	mov	r6,r2
81133d80:	1c63c83a 	sub	r17,r3,r17
81133d84:	900b883a 	mov	r5,r18
81133d88:	8809883a 	mov	r4,r17
81133d8c:	d9800015 	stw	r6,0(sp)
81133d90:	11346240 	call	81134624 <__umodsi3>
81133d94:	102d883a 	mov	r22,r2
81133d98:	8809883a 	mov	r4,r17
81133d9c:	900b883a 	mov	r5,r18
81133da0:	11345c00 	call	811345c0 <__udivsi3>
81133da4:	b02c943a 	slli	r22,r22,16
81133da8:	e089383a 	mul	r4,fp,r2
81133dac:	843fffcc 	andi	r16,r16,65535
81133db0:	85a0b03a 	or	r16,r16,r22
81133db4:	d9800017 	ldw	r6,0(sp)
81133db8:	8100042e 	bgeu	r16,r4,81133dcc <__udivdi3+0x3c4>
81133dbc:	85e1883a 	add	r16,r16,r23
81133dc0:	10ffffc4 	addi	r3,r2,-1
81133dc4:	85c05e2e 	bgeu	r16,r23,81133f40 <__udivdi3+0x538>
81133dc8:	1805883a 	mov	r2,r3
81133dcc:	300c943a 	slli	r6,r6,16
81133dd0:	a17fffcc 	andi	r5,r20,65535
81133dd4:	a028d43a 	srli	r20,r20,16
81133dd8:	3084b03a 	or	r2,r6,r2
81133ddc:	10ffffcc 	andi	r3,r2,65535
81133de0:	100cd43a 	srli	r6,r2,16
81133de4:	194f383a 	mul	r7,r3,r5
81133de8:	1d07383a 	mul	r3,r3,r20
81133dec:	314b383a 	mul	r5,r6,r5
81133df0:	3810d43a 	srli	r8,r7,16
81133df4:	8121c83a 	sub	r16,r16,r4
81133df8:	1947883a 	add	r3,r3,r5
81133dfc:	40c7883a 	add	r3,r8,r3
81133e00:	350d383a 	mul	r6,r6,r20
81133e04:	1940022e 	bgeu	r3,r5,81133e10 <__udivdi3+0x408>
81133e08:	01000074 	movhi	r4,1
81133e0c:	310d883a 	add	r6,r6,r4
81133e10:	1828d43a 	srli	r20,r3,16
81133e14:	a18d883a 	add	r6,r20,r6
81133e18:	81803e36 	bltu	r16,r6,81133f14 <__udivdi3+0x50c>
81133e1c:	81803826 	beq	r16,r6,81133f00 <__udivdi3+0x4f8>
81133e20:	0007883a 	mov	r3,zero
81133e24:	003fa206 	br	81133cb0 <__reset+0xfb113cb0>
81133e28:	88e2983a 	sll	r17,r17,r3
81133e2c:	80a8d83a 	srl	r20,r16,r2
81133e30:	80e0983a 	sll	r16,r16,r3
81133e34:	882ad43a 	srli	r21,r17,16
81133e38:	9884d83a 	srl	r2,r19,r2
81133e3c:	a009883a 	mov	r4,r20
81133e40:	a80b883a 	mov	r5,r21
81133e44:	142eb03a 	or	r23,r2,r16
81133e48:	98e4983a 	sll	r18,r19,r3
81133e4c:	11346240 	call	81134624 <__umodsi3>
81133e50:	a009883a 	mov	r4,r20
81133e54:	a80b883a 	mov	r5,r21
81133e58:	1021883a 	mov	r16,r2
81133e5c:	11345c00 	call	811345c0 <__udivsi3>
81133e60:	1039883a 	mov	fp,r2
81133e64:	8d3fffcc 	andi	r20,r17,65535
81133e68:	8020943a 	slli	r16,r16,16
81133e6c:	b804d43a 	srli	r2,r23,16
81133e70:	a72d383a 	mul	r22,r20,fp
81133e74:	1404b03a 	or	r2,r2,r16
81133e78:	1580062e 	bgeu	r2,r22,81133e94 <__udivdi3+0x48c>
81133e7c:	1445883a 	add	r2,r2,r17
81133e80:	e0ffffc4 	addi	r3,fp,-1
81133e84:	14403836 	bltu	r2,r17,81133f68 <__udivdi3+0x560>
81133e88:	1580372e 	bgeu	r2,r22,81133f68 <__udivdi3+0x560>
81133e8c:	e73fff84 	addi	fp,fp,-2
81133e90:	1445883a 	add	r2,r2,r17
81133e94:	15adc83a 	sub	r22,r2,r22
81133e98:	a80b883a 	mov	r5,r21
81133e9c:	b009883a 	mov	r4,r22
81133ea0:	11346240 	call	81134624 <__umodsi3>
81133ea4:	1027883a 	mov	r19,r2
81133ea8:	b009883a 	mov	r4,r22
81133eac:	a80b883a 	mov	r5,r21
81133eb0:	11345c00 	call	811345c0 <__udivsi3>
81133eb4:	9826943a 	slli	r19,r19,16
81133eb8:	a0a1383a 	mul	r16,r20,r2
81133ebc:	b93fffcc 	andi	r4,r23,65535
81133ec0:	24c8b03a 	or	r4,r4,r19
81133ec4:	2400062e 	bgeu	r4,r16,81133ee0 <__udivdi3+0x4d8>
81133ec8:	2449883a 	add	r4,r4,r17
81133ecc:	10ffffc4 	addi	r3,r2,-1
81133ed0:	24402336 	bltu	r4,r17,81133f60 <__udivdi3+0x558>
81133ed4:	2400222e 	bgeu	r4,r16,81133f60 <__udivdi3+0x558>
81133ed8:	10bfff84 	addi	r2,r2,-2
81133edc:	2449883a 	add	r4,r4,r17
81133ee0:	e038943a 	slli	fp,fp,16
81133ee4:	2421c83a 	sub	r16,r4,r16
81133ee8:	e086b03a 	or	r3,fp,r2
81133eec:	003f4306 	br	81133bfc <__reset+0xfb113bfc>
81133ef0:	2005883a 	mov	r2,r4
81133ef4:	003f6906 	br	81133c9c <__reset+0xfb113c9c>
81133ef8:	1805883a 	mov	r2,r3
81133efc:	003f0f06 	br	81133b3c <__reset+0xfb113b3c>
81133f00:	1806943a 	slli	r3,r3,16
81133f04:	9d66983a 	sll	r19,r19,r21
81133f08:	39ffffcc 	andi	r7,r7,65535
81133f0c:	19c7883a 	add	r3,r3,r7
81133f10:	98ffc32e 	bgeu	r19,r3,81133e20 <__reset+0xfb113e20>
81133f14:	10bfffc4 	addi	r2,r2,-1
81133f18:	003fc106 	br	81133e20 <__reset+0xfb113e20>
81133f1c:	00800604 	movi	r2,24
81133f20:	003f1106 	br	81133b68 <__reset+0xfb113b68>
81133f24:	00800604 	movi	r2,24
81133f28:	003f2706 	br	81133bc8 <__reset+0xfb113bc8>
81133f2c:	00800604 	movi	r2,24
81133f30:	003ece06 	br	81133a6c <__reset+0xfb113a6c>
81133f34:	0007883a 	mov	r3,zero
81133f38:	00800044 	movi	r2,1
81133f3c:	003f5c06 	br	81133cb0 <__reset+0xfb113cb0>
81133f40:	813fa12e 	bgeu	r16,r4,81133dc8 <__reset+0xfb113dc8>
81133f44:	10bfff84 	addi	r2,r2,-2
81133f48:	85e1883a 	add	r16,r16,r23
81133f4c:	003f9f06 	br	81133dcc <__reset+0xfb113dcc>
81133f50:	1c7f8a2e 	bgeu	r3,r17,81133d7c <__reset+0xfb113d7c>
81133f54:	31bfff84 	addi	r6,r6,-2
81133f58:	1dc7883a 	add	r3,r3,r23
81133f5c:	003f8806 	br	81133d80 <__reset+0xfb113d80>
81133f60:	1805883a 	mov	r2,r3
81133f64:	003fde06 	br	81133ee0 <__reset+0xfb113ee0>
81133f68:	1839883a 	mov	fp,r3
81133f6c:	003fc906 	br	81133e94 <__reset+0xfb113e94>
81133f70:	b5bfff84 	addi	r22,r22,-2
81133f74:	2449883a 	add	r4,r4,r17
81133f78:	003f3406 	br	81133c4c <__reset+0xfb113c4c>
81133f7c:	b5bfff84 	addi	r22,r22,-2
81133f80:	1445883a 	add	r2,r2,r17
81133f84:	003edb06 	br	81133af4 <__reset+0xfb113af4>

81133f88 <__umoddi3>:
81133f88:	defff404 	addi	sp,sp,-48
81133f8c:	de00012e 	bgeu	sp,et,81133f94 <__umoddi3+0xc>
81133f90:	003b68fa 	trap	3
81133f94:	df000a15 	stw	fp,40(sp)
81133f98:	dc400315 	stw	r17,12(sp)
81133f9c:	dc000215 	stw	r16,8(sp)
81133fa0:	dfc00b15 	stw	ra,44(sp)
81133fa4:	ddc00915 	stw	r23,36(sp)
81133fa8:	dd800815 	stw	r22,32(sp)
81133fac:	dd400715 	stw	r21,28(sp)
81133fb0:	dd000615 	stw	r20,24(sp)
81133fb4:	dcc00515 	stw	r19,20(sp)
81133fb8:	dc800415 	stw	r18,16(sp)
81133fbc:	2021883a 	mov	r16,r4
81133fc0:	2823883a 	mov	r17,r5
81133fc4:	2839883a 	mov	fp,r5
81133fc8:	38003c1e 	bne	r7,zero,811340bc <__umoddi3+0x134>
81133fcc:	3027883a 	mov	r19,r6
81133fd0:	2029883a 	mov	r20,r4
81133fd4:	2980512e 	bgeu	r5,r6,8113411c <__umoddi3+0x194>
81133fd8:	00bfffd4 	movui	r2,65535
81133fdc:	11809a36 	bltu	r2,r6,81134248 <__umoddi3+0x2c0>
81133fe0:	01003fc4 	movi	r4,255
81133fe4:	2189803a 	cmpltu	r4,r4,r6
81133fe8:	200890fa 	slli	r4,r4,3
81133fec:	3104d83a 	srl	r2,r6,r4
81133ff0:	00e04574 	movhi	r3,33045
81133ff4:	18c01d04 	addi	r3,r3,116
81133ff8:	1885883a 	add	r2,r3,r2
81133ffc:	10c00003 	ldbu	r3,0(r2)
81134000:	00800804 	movi	r2,32
81134004:	1909883a 	add	r4,r3,r4
81134008:	1125c83a 	sub	r18,r2,r4
8113400c:	90000526 	beq	r18,zero,81134024 <__umoddi3+0x9c>
81134010:	8ca2983a 	sll	r17,r17,r18
81134014:	8108d83a 	srl	r4,r16,r4
81134018:	34a6983a 	sll	r19,r6,r18
8113401c:	84a8983a 	sll	r20,r16,r18
81134020:	2478b03a 	or	fp,r4,r17
81134024:	982ed43a 	srli	r23,r19,16
81134028:	e009883a 	mov	r4,fp
8113402c:	9dbfffcc 	andi	r22,r19,65535
81134030:	b80b883a 	mov	r5,r23
81134034:	11346240 	call	81134624 <__umodsi3>
81134038:	e009883a 	mov	r4,fp
8113403c:	b80b883a 	mov	r5,r23
81134040:	102b883a 	mov	r21,r2
81134044:	11345c00 	call	811345c0 <__udivsi3>
81134048:	a806943a 	slli	r3,r21,16
8113404c:	a008d43a 	srli	r4,r20,16
81134050:	b085383a 	mul	r2,r22,r2
81134054:	20c8b03a 	or	r4,r4,r3
81134058:	2080032e 	bgeu	r4,r2,81134068 <__umoddi3+0xe0>
8113405c:	24c9883a 	add	r4,r4,r19
81134060:	24c00136 	bltu	r4,r19,81134068 <__umoddi3+0xe0>
81134064:	20811036 	bltu	r4,r2,811344a8 <__umoddi3+0x520>
81134068:	20abc83a 	sub	r21,r4,r2
8113406c:	b80b883a 	mov	r5,r23
81134070:	a809883a 	mov	r4,r21
81134074:	11346240 	call	81134624 <__umodsi3>
81134078:	1023883a 	mov	r17,r2
8113407c:	b80b883a 	mov	r5,r23
81134080:	a809883a 	mov	r4,r21
81134084:	11345c00 	call	811345c0 <__udivsi3>
81134088:	8822943a 	slli	r17,r17,16
8113408c:	b085383a 	mul	r2,r22,r2
81134090:	a0ffffcc 	andi	r3,r20,65535
81134094:	1c46b03a 	or	r3,r3,r17
81134098:	1880042e 	bgeu	r3,r2,811340ac <__umoddi3+0x124>
8113409c:	1cc7883a 	add	r3,r3,r19
811340a0:	1cc00236 	bltu	r3,r19,811340ac <__umoddi3+0x124>
811340a4:	1880012e 	bgeu	r3,r2,811340ac <__umoddi3+0x124>
811340a8:	1cc7883a 	add	r3,r3,r19
811340ac:	1885c83a 	sub	r2,r3,r2
811340b0:	1484d83a 	srl	r2,r2,r18
811340b4:	0007883a 	mov	r3,zero
811340b8:	00004f06 	br	811341f8 <__umoddi3+0x270>
811340bc:	29c04c36 	bltu	r5,r7,811341f0 <__umoddi3+0x268>
811340c0:	00bfffd4 	movui	r2,65535
811340c4:	11c0582e 	bgeu	r2,r7,81134228 <__umoddi3+0x2a0>
811340c8:	00804034 	movhi	r2,256
811340cc:	10bfffc4 	addi	r2,r2,-1
811340d0:	11c0e736 	bltu	r2,r7,81134470 <__umoddi3+0x4e8>
811340d4:	01000404 	movi	r4,16
811340d8:	3904d83a 	srl	r2,r7,r4
811340dc:	00e04574 	movhi	r3,33045
811340e0:	18c01d04 	addi	r3,r3,116
811340e4:	1885883a 	add	r2,r3,r2
811340e8:	14c00003 	ldbu	r19,0(r2)
811340ec:	00c00804 	movi	r3,32
811340f0:	9927883a 	add	r19,r19,r4
811340f4:	1ce9c83a 	sub	r20,r3,r19
811340f8:	a000581e 	bne	r20,zero,8113425c <__umoddi3+0x2d4>
811340fc:	3c400136 	bltu	r7,r17,81134104 <__umoddi3+0x17c>
81134100:	8180eb36 	bltu	r16,r6,811344b0 <__umoddi3+0x528>
81134104:	8185c83a 	sub	r2,r16,r6
81134108:	89e3c83a 	sub	r17,r17,r7
8113410c:	8089803a 	cmpltu	r4,r16,r2
81134110:	8939c83a 	sub	fp,r17,r4
81134114:	e007883a 	mov	r3,fp
81134118:	00003706 	br	811341f8 <__umoddi3+0x270>
8113411c:	3000041e 	bne	r6,zero,81134130 <__umoddi3+0x1a8>
81134120:	000b883a 	mov	r5,zero
81134124:	01000044 	movi	r4,1
81134128:	11345c00 	call	811345c0 <__udivsi3>
8113412c:	1027883a 	mov	r19,r2
81134130:	00bfffd4 	movui	r2,65535
81134134:	14c0402e 	bgeu	r2,r19,81134238 <__umoddi3+0x2b0>
81134138:	00804034 	movhi	r2,256
8113413c:	10bfffc4 	addi	r2,r2,-1
81134140:	14c0cd36 	bltu	r2,r19,81134478 <__umoddi3+0x4f0>
81134144:	00800404 	movi	r2,16
81134148:	9886d83a 	srl	r3,r19,r2
8113414c:	01204574 	movhi	r4,33045
81134150:	21001d04 	addi	r4,r4,116
81134154:	20c7883a 	add	r3,r4,r3
81134158:	18c00003 	ldbu	r3,0(r3)
8113415c:	1887883a 	add	r3,r3,r2
81134160:	00800804 	movi	r2,32
81134164:	10e5c83a 	sub	r18,r2,r3
81134168:	9000901e 	bne	r18,zero,811343ac <__umoddi3+0x424>
8113416c:	982cd43a 	srli	r22,r19,16
81134170:	8ce3c83a 	sub	r17,r17,r19
81134174:	9d7fffcc 	andi	r21,r19,65535
81134178:	b00b883a 	mov	r5,r22
8113417c:	8809883a 	mov	r4,r17
81134180:	11346240 	call	81134624 <__umodsi3>
81134184:	8809883a 	mov	r4,r17
81134188:	b00b883a 	mov	r5,r22
8113418c:	1021883a 	mov	r16,r2
81134190:	11345c00 	call	811345c0 <__udivsi3>
81134194:	8006943a 	slli	r3,r16,16
81134198:	a008d43a 	srli	r4,r20,16
8113419c:	1545383a 	mul	r2,r2,r21
811341a0:	20c8b03a 	or	r4,r4,r3
811341a4:	2080042e 	bgeu	r4,r2,811341b8 <__umoddi3+0x230>
811341a8:	24c9883a 	add	r4,r4,r19
811341ac:	24c00236 	bltu	r4,r19,811341b8 <__umoddi3+0x230>
811341b0:	2080012e 	bgeu	r4,r2,811341b8 <__umoddi3+0x230>
811341b4:	24c9883a 	add	r4,r4,r19
811341b8:	20a1c83a 	sub	r16,r4,r2
811341bc:	b00b883a 	mov	r5,r22
811341c0:	8009883a 	mov	r4,r16
811341c4:	11346240 	call	81134624 <__umodsi3>
811341c8:	1023883a 	mov	r17,r2
811341cc:	b00b883a 	mov	r5,r22
811341d0:	8009883a 	mov	r4,r16
811341d4:	11345c00 	call	811345c0 <__udivsi3>
811341d8:	8822943a 	slli	r17,r17,16
811341dc:	1545383a 	mul	r2,r2,r21
811341e0:	a53fffcc 	andi	r20,r20,65535
811341e4:	a446b03a 	or	r3,r20,r17
811341e8:	18bfb02e 	bgeu	r3,r2,811340ac <__reset+0xfb1140ac>
811341ec:	003fab06 	br	8113409c <__reset+0xfb11409c>
811341f0:	2005883a 	mov	r2,r4
811341f4:	2807883a 	mov	r3,r5
811341f8:	dfc00b17 	ldw	ra,44(sp)
811341fc:	df000a17 	ldw	fp,40(sp)
81134200:	ddc00917 	ldw	r23,36(sp)
81134204:	dd800817 	ldw	r22,32(sp)
81134208:	dd400717 	ldw	r21,28(sp)
8113420c:	dd000617 	ldw	r20,24(sp)
81134210:	dcc00517 	ldw	r19,20(sp)
81134214:	dc800417 	ldw	r18,16(sp)
81134218:	dc400317 	ldw	r17,12(sp)
8113421c:	dc000217 	ldw	r16,8(sp)
81134220:	dec00c04 	addi	sp,sp,48
81134224:	f800283a 	ret
81134228:	04c03fc4 	movi	r19,255
8113422c:	99c9803a 	cmpltu	r4,r19,r7
81134230:	200890fa 	slli	r4,r4,3
81134234:	003fa806 	br	811340d8 <__reset+0xfb1140d8>
81134238:	00803fc4 	movi	r2,255
8113423c:	14c5803a 	cmpltu	r2,r2,r19
81134240:	100490fa 	slli	r2,r2,3
81134244:	003fc006 	br	81134148 <__reset+0xfb114148>
81134248:	00804034 	movhi	r2,256
8113424c:	10bfffc4 	addi	r2,r2,-1
81134250:	11808b36 	bltu	r2,r6,81134480 <__umoddi3+0x4f8>
81134254:	01000404 	movi	r4,16
81134258:	003f6406 	br	81133fec <__reset+0xfb113fec>
8113425c:	34c4d83a 	srl	r2,r6,r19
81134260:	3d0e983a 	sll	r7,r7,r20
81134264:	8cf8d83a 	srl	fp,r17,r19
81134268:	8d10983a 	sll	r8,r17,r20
8113426c:	38aab03a 	or	r21,r7,r2
81134270:	a82cd43a 	srli	r22,r21,16
81134274:	84e2d83a 	srl	r17,r16,r19
81134278:	e009883a 	mov	r4,fp
8113427c:	b00b883a 	mov	r5,r22
81134280:	8a22b03a 	or	r17,r17,r8
81134284:	3524983a 	sll	r18,r6,r20
81134288:	11346240 	call	81134624 <__umodsi3>
8113428c:	e009883a 	mov	r4,fp
81134290:	b00b883a 	mov	r5,r22
81134294:	102f883a 	mov	r23,r2
81134298:	11345c00 	call	811345c0 <__udivsi3>
8113429c:	100d883a 	mov	r6,r2
811342a0:	b808943a 	slli	r4,r23,16
811342a4:	aa3fffcc 	andi	r8,r21,65535
811342a8:	8804d43a 	srli	r2,r17,16
811342ac:	41af383a 	mul	r23,r8,r6
811342b0:	8520983a 	sll	r16,r16,r20
811342b4:	1104b03a 	or	r2,r2,r4
811342b8:	15c0042e 	bgeu	r2,r23,811342cc <__umoddi3+0x344>
811342bc:	1545883a 	add	r2,r2,r21
811342c0:	30ffffc4 	addi	r3,r6,-1
811342c4:	1540742e 	bgeu	r2,r21,81134498 <__umoddi3+0x510>
811342c8:	180d883a 	mov	r6,r3
811342cc:	15efc83a 	sub	r23,r2,r23
811342d0:	b00b883a 	mov	r5,r22
811342d4:	b809883a 	mov	r4,r23
811342d8:	d9800115 	stw	r6,4(sp)
811342dc:	da000015 	stw	r8,0(sp)
811342e0:	11346240 	call	81134624 <__umodsi3>
811342e4:	b00b883a 	mov	r5,r22
811342e8:	b809883a 	mov	r4,r23
811342ec:	1039883a 	mov	fp,r2
811342f0:	11345c00 	call	811345c0 <__udivsi3>
811342f4:	da000017 	ldw	r8,0(sp)
811342f8:	e038943a 	slli	fp,fp,16
811342fc:	100b883a 	mov	r5,r2
81134300:	4089383a 	mul	r4,r8,r2
81134304:	8a3fffcc 	andi	r8,r17,65535
81134308:	4710b03a 	or	r8,r8,fp
8113430c:	d9800117 	ldw	r6,4(sp)
81134310:	4100042e 	bgeu	r8,r4,81134324 <__umoddi3+0x39c>
81134314:	4551883a 	add	r8,r8,r21
81134318:	10bfffc4 	addi	r2,r2,-1
8113431c:	45405a2e 	bgeu	r8,r21,81134488 <__umoddi3+0x500>
81134320:	100b883a 	mov	r5,r2
81134324:	300c943a 	slli	r6,r6,16
81134328:	91ffffcc 	andi	r7,r18,65535
8113432c:	9004d43a 	srli	r2,r18,16
81134330:	314cb03a 	or	r6,r6,r5
81134334:	317fffcc 	andi	r5,r6,65535
81134338:	300cd43a 	srli	r6,r6,16
8113433c:	29d3383a 	mul	r9,r5,r7
81134340:	288b383a 	mul	r5,r5,r2
81134344:	31cf383a 	mul	r7,r6,r7
81134348:	4806d43a 	srli	r3,r9,16
8113434c:	4111c83a 	sub	r8,r8,r4
81134350:	29cb883a 	add	r5,r5,r7
81134354:	194b883a 	add	r5,r3,r5
81134358:	3085383a 	mul	r2,r6,r2
8113435c:	29c0022e 	bgeu	r5,r7,81134368 <__umoddi3+0x3e0>
81134360:	00c00074 	movhi	r3,1
81134364:	10c5883a 	add	r2,r2,r3
81134368:	2808d43a 	srli	r4,r5,16
8113436c:	280a943a 	slli	r5,r5,16
81134370:	4a7fffcc 	andi	r9,r9,65535
81134374:	2085883a 	add	r2,r4,r2
81134378:	2a4b883a 	add	r5,r5,r9
8113437c:	40803636 	bltu	r8,r2,81134458 <__umoddi3+0x4d0>
81134380:	40804d26 	beq	r8,r2,811344b8 <__umoddi3+0x530>
81134384:	4089c83a 	sub	r4,r8,r2
81134388:	280f883a 	mov	r7,r5
8113438c:	81cfc83a 	sub	r7,r16,r7
81134390:	81c7803a 	cmpltu	r3,r16,r7
81134394:	20c7c83a 	sub	r3,r4,r3
81134398:	1cc4983a 	sll	r2,r3,r19
8113439c:	3d0ed83a 	srl	r7,r7,r20
811343a0:	1d06d83a 	srl	r3,r3,r20
811343a4:	11c4b03a 	or	r2,r2,r7
811343a8:	003f9306 	br	811341f8 <__reset+0xfb1141f8>
811343ac:	9ca6983a 	sll	r19,r19,r18
811343b0:	88e8d83a 	srl	r20,r17,r3
811343b4:	80c4d83a 	srl	r2,r16,r3
811343b8:	982cd43a 	srli	r22,r19,16
811343bc:	8ca2983a 	sll	r17,r17,r18
811343c0:	a009883a 	mov	r4,r20
811343c4:	b00b883a 	mov	r5,r22
811343c8:	1478b03a 	or	fp,r2,r17
811343cc:	11346240 	call	81134624 <__umodsi3>
811343d0:	a009883a 	mov	r4,r20
811343d4:	b00b883a 	mov	r5,r22
811343d8:	1023883a 	mov	r17,r2
811343dc:	11345c00 	call	811345c0 <__udivsi3>
811343e0:	9d7fffcc 	andi	r21,r19,65535
811343e4:	880a943a 	slli	r5,r17,16
811343e8:	e008d43a 	srli	r4,fp,16
811343ec:	a885383a 	mul	r2,r21,r2
811343f0:	84a8983a 	sll	r20,r16,r18
811343f4:	2148b03a 	or	r4,r4,r5
811343f8:	2080042e 	bgeu	r4,r2,8113440c <__umoddi3+0x484>
811343fc:	24c9883a 	add	r4,r4,r19
81134400:	24c00236 	bltu	r4,r19,8113440c <__umoddi3+0x484>
81134404:	2080012e 	bgeu	r4,r2,8113440c <__umoddi3+0x484>
81134408:	24c9883a 	add	r4,r4,r19
8113440c:	20a3c83a 	sub	r17,r4,r2
81134410:	b00b883a 	mov	r5,r22
81134414:	8809883a 	mov	r4,r17
81134418:	11346240 	call	81134624 <__umodsi3>
8113441c:	102f883a 	mov	r23,r2
81134420:	8809883a 	mov	r4,r17
81134424:	b00b883a 	mov	r5,r22
81134428:	11345c00 	call	811345c0 <__udivsi3>
8113442c:	b82e943a 	slli	r23,r23,16
81134430:	a885383a 	mul	r2,r21,r2
81134434:	e13fffcc 	andi	r4,fp,65535
81134438:	25c8b03a 	or	r4,r4,r23
8113443c:	2080042e 	bgeu	r4,r2,81134450 <__umoddi3+0x4c8>
81134440:	24c9883a 	add	r4,r4,r19
81134444:	24c00236 	bltu	r4,r19,81134450 <__umoddi3+0x4c8>
81134448:	2080012e 	bgeu	r4,r2,81134450 <__umoddi3+0x4c8>
8113444c:	24c9883a 	add	r4,r4,r19
81134450:	20a3c83a 	sub	r17,r4,r2
81134454:	003f4806 	br	81134178 <__reset+0xfb114178>
81134458:	2c8fc83a 	sub	r7,r5,r18
8113445c:	1545c83a 	sub	r2,r2,r21
81134460:	29cb803a 	cmpltu	r5,r5,r7
81134464:	1145c83a 	sub	r2,r2,r5
81134468:	4089c83a 	sub	r4,r8,r2
8113446c:	003fc706 	br	8113438c <__reset+0xfb11438c>
81134470:	01000604 	movi	r4,24
81134474:	003f1806 	br	811340d8 <__reset+0xfb1140d8>
81134478:	00800604 	movi	r2,24
8113447c:	003f3206 	br	81134148 <__reset+0xfb114148>
81134480:	01000604 	movi	r4,24
81134484:	003ed906 	br	81133fec <__reset+0xfb113fec>
81134488:	413fa52e 	bgeu	r8,r4,81134320 <__reset+0xfb114320>
8113448c:	297fff84 	addi	r5,r5,-2
81134490:	4551883a 	add	r8,r8,r21
81134494:	003fa306 	br	81134324 <__reset+0xfb114324>
81134498:	15ff8b2e 	bgeu	r2,r23,811342c8 <__reset+0xfb1142c8>
8113449c:	31bfff84 	addi	r6,r6,-2
811344a0:	1545883a 	add	r2,r2,r21
811344a4:	003f8906 	br	811342cc <__reset+0xfb1142cc>
811344a8:	24c9883a 	add	r4,r4,r19
811344ac:	003eee06 	br	81134068 <__reset+0xfb114068>
811344b0:	8005883a 	mov	r2,r16
811344b4:	003f1706 	br	81134114 <__reset+0xfb114114>
811344b8:	817fe736 	bltu	r16,r5,81134458 <__reset+0xfb114458>
811344bc:	280f883a 	mov	r7,r5
811344c0:	0009883a 	mov	r4,zero
811344c4:	003fb106 	br	8113438c <__reset+0xfb11438c>

811344c8 <__divsi3>:
811344c8:	20001b16 	blt	r4,zero,81134538 <__divsi3+0x70>
811344cc:	000f883a 	mov	r7,zero
811344d0:	28001616 	blt	r5,zero,8113452c <__divsi3+0x64>
811344d4:	200d883a 	mov	r6,r4
811344d8:	29001a2e 	bgeu	r5,r4,81134544 <__divsi3+0x7c>
811344dc:	00800804 	movi	r2,32
811344e0:	00c00044 	movi	r3,1
811344e4:	00000106 	br	811344ec <__divsi3+0x24>
811344e8:	10000d26 	beq	r2,zero,81134520 <__divsi3+0x58>
811344ec:	294b883a 	add	r5,r5,r5
811344f0:	10bfffc4 	addi	r2,r2,-1
811344f4:	18c7883a 	add	r3,r3,r3
811344f8:	293ffb36 	bltu	r5,r4,811344e8 <__reset+0xfb1144e8>
811344fc:	0005883a 	mov	r2,zero
81134500:	18000726 	beq	r3,zero,81134520 <__divsi3+0x58>
81134504:	0005883a 	mov	r2,zero
81134508:	31400236 	bltu	r6,r5,81134514 <__divsi3+0x4c>
8113450c:	314dc83a 	sub	r6,r6,r5
81134510:	10c4b03a 	or	r2,r2,r3
81134514:	1806d07a 	srli	r3,r3,1
81134518:	280ad07a 	srli	r5,r5,1
8113451c:	183ffa1e 	bne	r3,zero,81134508 <__reset+0xfb114508>
81134520:	38000126 	beq	r7,zero,81134528 <__divsi3+0x60>
81134524:	0085c83a 	sub	r2,zero,r2
81134528:	f800283a 	ret
8113452c:	014bc83a 	sub	r5,zero,r5
81134530:	39c0005c 	xori	r7,r7,1
81134534:	003fe706 	br	811344d4 <__reset+0xfb1144d4>
81134538:	0109c83a 	sub	r4,zero,r4
8113453c:	01c00044 	movi	r7,1
81134540:	003fe306 	br	811344d0 <__reset+0xfb1144d0>
81134544:	00c00044 	movi	r3,1
81134548:	003fee06 	br	81134504 <__reset+0xfb114504>

8113454c <__modsi3>:
8113454c:	20001716 	blt	r4,zero,811345ac <__modsi3+0x60>
81134550:	000f883a 	mov	r7,zero
81134554:	2005883a 	mov	r2,r4
81134558:	28001216 	blt	r5,zero,811345a4 <__modsi3+0x58>
8113455c:	2900162e 	bgeu	r5,r4,811345b8 <__modsi3+0x6c>
81134560:	01800804 	movi	r6,32
81134564:	00c00044 	movi	r3,1
81134568:	00000106 	br	81134570 <__modsi3+0x24>
8113456c:	30000a26 	beq	r6,zero,81134598 <__modsi3+0x4c>
81134570:	294b883a 	add	r5,r5,r5
81134574:	31bfffc4 	addi	r6,r6,-1
81134578:	18c7883a 	add	r3,r3,r3
8113457c:	293ffb36 	bltu	r5,r4,8113456c <__reset+0xfb11456c>
81134580:	18000526 	beq	r3,zero,81134598 <__modsi3+0x4c>
81134584:	1806d07a 	srli	r3,r3,1
81134588:	11400136 	bltu	r2,r5,81134590 <__modsi3+0x44>
8113458c:	1145c83a 	sub	r2,r2,r5
81134590:	280ad07a 	srli	r5,r5,1
81134594:	183ffb1e 	bne	r3,zero,81134584 <__reset+0xfb114584>
81134598:	38000126 	beq	r7,zero,811345a0 <__modsi3+0x54>
8113459c:	0085c83a 	sub	r2,zero,r2
811345a0:	f800283a 	ret
811345a4:	014bc83a 	sub	r5,zero,r5
811345a8:	003fec06 	br	8113455c <__reset+0xfb11455c>
811345ac:	0109c83a 	sub	r4,zero,r4
811345b0:	01c00044 	movi	r7,1
811345b4:	003fe706 	br	81134554 <__reset+0xfb114554>
811345b8:	00c00044 	movi	r3,1
811345bc:	003ff106 	br	81134584 <__reset+0xfb114584>

811345c0 <__udivsi3>:
811345c0:	200d883a 	mov	r6,r4
811345c4:	2900152e 	bgeu	r5,r4,8113461c <__udivsi3+0x5c>
811345c8:	28001416 	blt	r5,zero,8113461c <__udivsi3+0x5c>
811345cc:	00800804 	movi	r2,32
811345d0:	00c00044 	movi	r3,1
811345d4:	00000206 	br	811345e0 <__udivsi3+0x20>
811345d8:	10000e26 	beq	r2,zero,81134614 <__udivsi3+0x54>
811345dc:	28000516 	blt	r5,zero,811345f4 <__udivsi3+0x34>
811345e0:	294b883a 	add	r5,r5,r5
811345e4:	10bfffc4 	addi	r2,r2,-1
811345e8:	18c7883a 	add	r3,r3,r3
811345ec:	293ffa36 	bltu	r5,r4,811345d8 <__reset+0xfb1145d8>
811345f0:	18000826 	beq	r3,zero,81134614 <__udivsi3+0x54>
811345f4:	0005883a 	mov	r2,zero
811345f8:	31400236 	bltu	r6,r5,81134604 <__udivsi3+0x44>
811345fc:	314dc83a 	sub	r6,r6,r5
81134600:	10c4b03a 	or	r2,r2,r3
81134604:	1806d07a 	srli	r3,r3,1
81134608:	280ad07a 	srli	r5,r5,1
8113460c:	183ffa1e 	bne	r3,zero,811345f8 <__reset+0xfb1145f8>
81134610:	f800283a 	ret
81134614:	0005883a 	mov	r2,zero
81134618:	f800283a 	ret
8113461c:	00c00044 	movi	r3,1
81134620:	003ff406 	br	811345f4 <__reset+0xfb1145f4>

81134624 <__umodsi3>:
81134624:	2005883a 	mov	r2,r4
81134628:	2900122e 	bgeu	r5,r4,81134674 <__umodsi3+0x50>
8113462c:	28001116 	blt	r5,zero,81134674 <__umodsi3+0x50>
81134630:	01800804 	movi	r6,32
81134634:	00c00044 	movi	r3,1
81134638:	00000206 	br	81134644 <__umodsi3+0x20>
8113463c:	30000c26 	beq	r6,zero,81134670 <__umodsi3+0x4c>
81134640:	28000516 	blt	r5,zero,81134658 <__umodsi3+0x34>
81134644:	294b883a 	add	r5,r5,r5
81134648:	31bfffc4 	addi	r6,r6,-1
8113464c:	18c7883a 	add	r3,r3,r3
81134650:	293ffa36 	bltu	r5,r4,8113463c <__reset+0xfb11463c>
81134654:	18000626 	beq	r3,zero,81134670 <__umodsi3+0x4c>
81134658:	1806d07a 	srli	r3,r3,1
8113465c:	11400136 	bltu	r2,r5,81134664 <__umodsi3+0x40>
81134660:	1145c83a 	sub	r2,r2,r5
81134664:	280ad07a 	srli	r5,r5,1
81134668:	183ffb1e 	bne	r3,zero,81134658 <__reset+0xfb114658>
8113466c:	f800283a 	ret
81134670:	f800283a 	ret
81134674:	00c00044 	movi	r3,1
81134678:	003ff706 	br	81134658 <__reset+0xfb114658>

8113467c <__eqsf2>:
8113467c:	2006d5fa 	srli	r3,r4,23
81134680:	280cd5fa 	srli	r6,r5,23
81134684:	01c02034 	movhi	r7,128
81134688:	39ffffc4 	addi	r7,r7,-1
8113468c:	18c03fcc 	andi	r3,r3,255
81134690:	02003fc4 	movi	r8,255
81134694:	3904703a 	and	r2,r7,r4
81134698:	31803fcc 	andi	r6,r6,255
8113469c:	394e703a 	and	r7,r7,r5
811346a0:	2008d7fa 	srli	r4,r4,31
811346a4:	280ad7fa 	srli	r5,r5,31
811346a8:	1a000d26 	beq	r3,r8,811346e0 <__eqsf2+0x64>
811346ac:	02003fc4 	movi	r8,255
811346b0:	32000826 	beq	r6,r8,811346d4 <__eqsf2+0x58>
811346b4:	19800226 	beq	r3,r6,811346c0 <__eqsf2+0x44>
811346b8:	00800044 	movi	r2,1
811346bc:	f800283a 	ret
811346c0:	11fffd1e 	bne	r2,r7,811346b8 <__reset+0xfb1146b8>
811346c4:	21400926 	beq	r4,r5,811346ec <__eqsf2+0x70>
811346c8:	183ffb1e 	bne	r3,zero,811346b8 <__reset+0xfb1146b8>
811346cc:	1004c03a 	cmpne	r2,r2,zero
811346d0:	f800283a 	ret
811346d4:	383ff726 	beq	r7,zero,811346b4 <__reset+0xfb1146b4>
811346d8:	00800044 	movi	r2,1
811346dc:	f800283a 	ret
811346e0:	103ff226 	beq	r2,zero,811346ac <__reset+0xfb1146ac>
811346e4:	00800044 	movi	r2,1
811346e8:	f800283a 	ret
811346ec:	0005883a 	mov	r2,zero
811346f0:	f800283a 	ret

811346f4 <__gesf2>:
811346f4:	2004d5fa 	srli	r2,r4,23
811346f8:	2806d5fa 	srli	r3,r5,23
811346fc:	01802034 	movhi	r6,128
81134700:	31bfffc4 	addi	r6,r6,-1
81134704:	10803fcc 	andi	r2,r2,255
81134708:	01c03fc4 	movi	r7,255
8113470c:	3110703a 	and	r8,r6,r4
81134710:	18c03fcc 	andi	r3,r3,255
81134714:	314c703a 	and	r6,r6,r5
81134718:	2008d7fa 	srli	r4,r4,31
8113471c:	280ad7fa 	srli	r5,r5,31
81134720:	11c01926 	beq	r2,r7,81134788 <__gesf2+0x94>
81134724:	01c03fc4 	movi	r7,255
81134728:	19c00f26 	beq	r3,r7,81134768 <__gesf2+0x74>
8113472c:	1000061e 	bne	r2,zero,81134748 <__gesf2+0x54>
81134730:	400f003a 	cmpeq	r7,r8,zero
81134734:	1800071e 	bne	r3,zero,81134754 <__gesf2+0x60>
81134738:	3000061e 	bne	r6,zero,81134754 <__gesf2+0x60>
8113473c:	0005883a 	mov	r2,zero
81134740:	40000e1e 	bne	r8,zero,8113477c <__gesf2+0x88>
81134744:	f800283a 	ret
81134748:	18000a1e 	bne	r3,zero,81134774 <__gesf2+0x80>
8113474c:	30000b26 	beq	r6,zero,8113477c <__gesf2+0x88>
81134750:	000f883a 	mov	r7,zero
81134754:	29403fcc 	andi	r5,r5,255
81134758:	38000726 	beq	r7,zero,81134778 <__gesf2+0x84>
8113475c:	28000826 	beq	r5,zero,81134780 <__gesf2+0x8c>
81134760:	00800044 	movi	r2,1
81134764:	f800283a 	ret
81134768:	303ff026 	beq	r6,zero,8113472c <__reset+0xfb11472c>
8113476c:	00bfff84 	movi	r2,-2
81134770:	f800283a 	ret
81134774:	29403fcc 	andi	r5,r5,255
81134778:	21400526 	beq	r4,r5,81134790 <__gesf2+0x9c>
8113477c:	203ff826 	beq	r4,zero,81134760 <__reset+0xfb114760>
81134780:	00bfffc4 	movi	r2,-1
81134784:	f800283a 	ret
81134788:	403fe626 	beq	r8,zero,81134724 <__reset+0xfb114724>
8113478c:	003ff706 	br	8113476c <__reset+0xfb11476c>
81134790:	18bffa16 	blt	r3,r2,8113477c <__reset+0xfb11477c>
81134794:	10c00216 	blt	r2,r3,811347a0 <__gesf2+0xac>
81134798:	323ff836 	bltu	r6,r8,8113477c <__reset+0xfb11477c>
8113479c:	4180022e 	bgeu	r8,r6,811347a8 <__gesf2+0xb4>
811347a0:	203fef1e 	bne	r4,zero,81134760 <__reset+0xfb114760>
811347a4:	003ff606 	br	81134780 <__reset+0xfb114780>
811347a8:	0005883a 	mov	r2,zero
811347ac:	f800283a 	ret

811347b0 <__lesf2>:
811347b0:	2004d5fa 	srli	r2,r4,23
811347b4:	280cd5fa 	srli	r6,r5,23
811347b8:	00c02034 	movhi	r3,128
811347bc:	18ffffc4 	addi	r3,r3,-1
811347c0:	10803fcc 	andi	r2,r2,255
811347c4:	01c03fc4 	movi	r7,255
811347c8:	1910703a 	and	r8,r3,r4
811347cc:	31803fcc 	andi	r6,r6,255
811347d0:	1946703a 	and	r3,r3,r5
811347d4:	2008d7fa 	srli	r4,r4,31
811347d8:	280ad7fa 	srli	r5,r5,31
811347dc:	11c01b26 	beq	r2,r7,8113484c <__lesf2+0x9c>
811347e0:	01c03fc4 	movi	r7,255
811347e4:	31c01126 	beq	r6,r7,8113482c <__lesf2+0x7c>
811347e8:	1000071e 	bne	r2,zero,81134808 <__lesf2+0x58>
811347ec:	400f003a 	cmpeq	r7,r8,zero
811347f0:	21003fcc 	andi	r4,r4,255
811347f4:	3000081e 	bne	r6,zero,81134818 <__lesf2+0x68>
811347f8:	1800071e 	bne	r3,zero,81134818 <__lesf2+0x68>
811347fc:	0005883a 	mov	r2,zero
81134800:	40000f1e 	bne	r8,zero,81134840 <__lesf2+0x90>
81134804:	f800283a 	ret
81134808:	21003fcc 	andi	r4,r4,255
8113480c:	30000a1e 	bne	r6,zero,81134838 <__lesf2+0x88>
81134810:	18000b26 	beq	r3,zero,81134840 <__lesf2+0x90>
81134814:	000f883a 	mov	r7,zero
81134818:	29403fcc 	andi	r5,r5,255
8113481c:	38000726 	beq	r7,zero,8113483c <__lesf2+0x8c>
81134820:	28000826 	beq	r5,zero,81134844 <__lesf2+0x94>
81134824:	00800044 	movi	r2,1
81134828:	f800283a 	ret
8113482c:	183fee26 	beq	r3,zero,811347e8 <__reset+0xfb1147e8>
81134830:	00800084 	movi	r2,2
81134834:	f800283a 	ret
81134838:	29403fcc 	andi	r5,r5,255
8113483c:	21400626 	beq	r4,r5,81134858 <__lesf2+0xa8>
81134840:	203ff826 	beq	r4,zero,81134824 <__reset+0xfb114824>
81134844:	00bfffc4 	movi	r2,-1
81134848:	f800283a 	ret
8113484c:	403fe426 	beq	r8,zero,811347e0 <__reset+0xfb1147e0>
81134850:	00800084 	movi	r2,2
81134854:	f800283a 	ret
81134858:	30bff916 	blt	r6,r2,81134840 <__reset+0xfb114840>
8113485c:	11800216 	blt	r2,r6,81134868 <__lesf2+0xb8>
81134860:	1a3ff736 	bltu	r3,r8,81134840 <__reset+0xfb114840>
81134864:	40c0022e 	bgeu	r8,r3,81134870 <__lesf2+0xc0>
81134868:	203fee1e 	bne	r4,zero,81134824 <__reset+0xfb114824>
8113486c:	003ff506 	br	81134844 <__reset+0xfb114844>
81134870:	0005883a 	mov	r2,zero
81134874:	f800283a 	ret

81134878 <__adddf3>:
81134878:	02c00434 	movhi	r11,16
8113487c:	5affffc4 	addi	r11,r11,-1
81134880:	2806d7fa 	srli	r3,r5,31
81134884:	2ad4703a 	and	r10,r5,r11
81134888:	3ad2703a 	and	r9,r7,r11
8113488c:	3804d53a 	srli	r2,r7,20
81134890:	3018d77a 	srli	r12,r6,29
81134894:	280ad53a 	srli	r5,r5,20
81134898:	501490fa 	slli	r10,r10,3
8113489c:	2010d77a 	srli	r8,r4,29
811348a0:	481290fa 	slli	r9,r9,3
811348a4:	380ed7fa 	srli	r7,r7,31
811348a8:	defffb04 	addi	sp,sp,-20
811348ac:	de00012e 	bgeu	sp,et,811348b4 <__adddf3+0x3c>
811348b0:	003b68fa 	trap	3
811348b4:	dc800215 	stw	r18,8(sp)
811348b8:	dc400115 	stw	r17,4(sp)
811348bc:	dc000015 	stw	r16,0(sp)
811348c0:	dfc00415 	stw	ra,16(sp)
811348c4:	dcc00315 	stw	r19,12(sp)
811348c8:	1c803fcc 	andi	r18,r3,255
811348cc:	2c01ffcc 	andi	r16,r5,2047
811348d0:	5210b03a 	or	r8,r10,r8
811348d4:	202290fa 	slli	r17,r4,3
811348d8:	1081ffcc 	andi	r2,r2,2047
811348dc:	4b12b03a 	or	r9,r9,r12
811348e0:	300c90fa 	slli	r6,r6,3
811348e4:	91c07526 	beq	r18,r7,81134abc <__adddf3+0x244>
811348e8:	8087c83a 	sub	r3,r16,r2
811348ec:	00c0ab0e 	bge	zero,r3,81134b9c <__adddf3+0x324>
811348f0:	10002a1e 	bne	r2,zero,8113499c <__adddf3+0x124>
811348f4:	4984b03a 	or	r2,r9,r6
811348f8:	1000961e 	bne	r2,zero,81134b54 <__adddf3+0x2dc>
811348fc:	888001cc 	andi	r2,r17,7
81134900:	10000726 	beq	r2,zero,81134920 <__adddf3+0xa8>
81134904:	888003cc 	andi	r2,r17,15
81134908:	00c00104 	movi	r3,4
8113490c:	10c00426 	beq	r2,r3,81134920 <__adddf3+0xa8>
81134910:	88c7883a 	add	r3,r17,r3
81134914:	1c63803a 	cmpltu	r17,r3,r17
81134918:	4451883a 	add	r8,r8,r17
8113491c:	1823883a 	mov	r17,r3
81134920:	4080202c 	andhi	r2,r8,128
81134924:	10005926 	beq	r2,zero,81134a8c <__adddf3+0x214>
81134928:	84000044 	addi	r16,r16,1
8113492c:	0081ffc4 	movi	r2,2047
81134930:	8080ba26 	beq	r16,r2,81134c1c <__adddf3+0x3a4>
81134934:	00bfe034 	movhi	r2,65408
81134938:	10bfffc4 	addi	r2,r2,-1
8113493c:	4090703a 	and	r8,r8,r2
81134940:	4004977a 	slli	r2,r8,29
81134944:	4010927a 	slli	r8,r8,9
81134948:	8822d0fa 	srli	r17,r17,3
8113494c:	8401ffcc 	andi	r16,r16,2047
81134950:	4010d33a 	srli	r8,r8,12
81134954:	9007883a 	mov	r3,r18
81134958:	1444b03a 	or	r2,r2,r17
8113495c:	8401ffcc 	andi	r16,r16,2047
81134960:	8020953a 	slli	r16,r16,20
81134964:	18c03fcc 	andi	r3,r3,255
81134968:	01000434 	movhi	r4,16
8113496c:	213fffc4 	addi	r4,r4,-1
81134970:	180697fa 	slli	r3,r3,31
81134974:	4110703a 	and	r8,r8,r4
81134978:	4410b03a 	or	r8,r8,r16
8113497c:	40c6b03a 	or	r3,r8,r3
81134980:	dfc00417 	ldw	ra,16(sp)
81134984:	dcc00317 	ldw	r19,12(sp)
81134988:	dc800217 	ldw	r18,8(sp)
8113498c:	dc400117 	ldw	r17,4(sp)
81134990:	dc000017 	ldw	r16,0(sp)
81134994:	dec00504 	addi	sp,sp,20
81134998:	f800283a 	ret
8113499c:	0081ffc4 	movi	r2,2047
811349a0:	80bfd626 	beq	r16,r2,811348fc <__reset+0xfb1148fc>
811349a4:	4a402034 	orhi	r9,r9,128
811349a8:	00800e04 	movi	r2,56
811349ac:	10c09f16 	blt	r2,r3,81134c2c <__adddf3+0x3b4>
811349b0:	008007c4 	movi	r2,31
811349b4:	10c0c216 	blt	r2,r3,81134cc0 <__adddf3+0x448>
811349b8:	00800804 	movi	r2,32
811349bc:	10c5c83a 	sub	r2,r2,r3
811349c0:	488a983a 	sll	r5,r9,r2
811349c4:	30c8d83a 	srl	r4,r6,r3
811349c8:	3084983a 	sll	r2,r6,r2
811349cc:	48c6d83a 	srl	r3,r9,r3
811349d0:	290cb03a 	or	r6,r5,r4
811349d4:	1004c03a 	cmpne	r2,r2,zero
811349d8:	308cb03a 	or	r6,r6,r2
811349dc:	898dc83a 	sub	r6,r17,r6
811349e0:	89a3803a 	cmpltu	r17,r17,r6
811349e4:	40d1c83a 	sub	r8,r8,r3
811349e8:	4451c83a 	sub	r8,r8,r17
811349ec:	3023883a 	mov	r17,r6
811349f0:	4080202c 	andhi	r2,r8,128
811349f4:	10002326 	beq	r2,zero,81134a84 <__adddf3+0x20c>
811349f8:	04c02034 	movhi	r19,128
811349fc:	9cffffc4 	addi	r19,r19,-1
81134a00:	44e6703a 	and	r19,r8,r19
81134a04:	98007626 	beq	r19,zero,81134be0 <__adddf3+0x368>
81134a08:	9809883a 	mov	r4,r19
81134a0c:	1120de40 	call	81120de4 <__clzsi2>
81134a10:	10fffe04 	addi	r3,r2,-8
81134a14:	010007c4 	movi	r4,31
81134a18:	20c07716 	blt	r4,r3,81134bf8 <__adddf3+0x380>
81134a1c:	00800804 	movi	r2,32
81134a20:	10c5c83a 	sub	r2,r2,r3
81134a24:	8884d83a 	srl	r2,r17,r2
81134a28:	98d0983a 	sll	r8,r19,r3
81134a2c:	88e2983a 	sll	r17,r17,r3
81134a30:	1204b03a 	or	r2,r2,r8
81134a34:	1c007416 	blt	r3,r16,81134c08 <__adddf3+0x390>
81134a38:	1c21c83a 	sub	r16,r3,r16
81134a3c:	82000044 	addi	r8,r16,1
81134a40:	00c007c4 	movi	r3,31
81134a44:	1a009116 	blt	r3,r8,81134c8c <__adddf3+0x414>
81134a48:	00c00804 	movi	r3,32
81134a4c:	1a07c83a 	sub	r3,r3,r8
81134a50:	8a08d83a 	srl	r4,r17,r8
81134a54:	88e2983a 	sll	r17,r17,r3
81134a58:	10c6983a 	sll	r3,r2,r3
81134a5c:	1210d83a 	srl	r8,r2,r8
81134a60:	8804c03a 	cmpne	r2,r17,zero
81134a64:	1906b03a 	or	r3,r3,r4
81134a68:	18a2b03a 	or	r17,r3,r2
81134a6c:	0021883a 	mov	r16,zero
81134a70:	003fa206 	br	811348fc <__reset+0xfb1148fc>
81134a74:	1890b03a 	or	r8,r3,r2
81134a78:	40017d26 	beq	r8,zero,81135070 <__adddf3+0x7f8>
81134a7c:	1011883a 	mov	r8,r2
81134a80:	1823883a 	mov	r17,r3
81134a84:	888001cc 	andi	r2,r17,7
81134a88:	103f9e1e 	bne	r2,zero,81134904 <__reset+0xfb114904>
81134a8c:	4004977a 	slli	r2,r8,29
81134a90:	8822d0fa 	srli	r17,r17,3
81134a94:	4010d0fa 	srli	r8,r8,3
81134a98:	9007883a 	mov	r3,r18
81134a9c:	1444b03a 	or	r2,r2,r17
81134aa0:	0101ffc4 	movi	r4,2047
81134aa4:	81002426 	beq	r16,r4,81134b38 <__adddf3+0x2c0>
81134aa8:	8120703a 	and	r16,r16,r4
81134aac:	01000434 	movhi	r4,16
81134ab0:	213fffc4 	addi	r4,r4,-1
81134ab4:	4110703a 	and	r8,r8,r4
81134ab8:	003fa806 	br	8113495c <__reset+0xfb11495c>
81134abc:	8089c83a 	sub	r4,r16,r2
81134ac0:	01005e0e 	bge	zero,r4,81134c3c <__adddf3+0x3c4>
81134ac4:	10002b26 	beq	r2,zero,81134b74 <__adddf3+0x2fc>
81134ac8:	0081ffc4 	movi	r2,2047
81134acc:	80bf8b26 	beq	r16,r2,811348fc <__reset+0xfb1148fc>
81134ad0:	4a402034 	orhi	r9,r9,128
81134ad4:	00800e04 	movi	r2,56
81134ad8:	1100a40e 	bge	r2,r4,81134d6c <__adddf3+0x4f4>
81134adc:	498cb03a 	or	r6,r9,r6
81134ae0:	300ac03a 	cmpne	r5,r6,zero
81134ae4:	0013883a 	mov	r9,zero
81134ae8:	2c4b883a 	add	r5,r5,r17
81134aec:	2c63803a 	cmpltu	r17,r5,r17
81134af0:	4a11883a 	add	r8,r9,r8
81134af4:	8a11883a 	add	r8,r17,r8
81134af8:	2823883a 	mov	r17,r5
81134afc:	4080202c 	andhi	r2,r8,128
81134b00:	103fe026 	beq	r2,zero,81134a84 <__reset+0xfb114a84>
81134b04:	84000044 	addi	r16,r16,1
81134b08:	0081ffc4 	movi	r2,2047
81134b0c:	8080d226 	beq	r16,r2,81134e58 <__adddf3+0x5e0>
81134b10:	00bfe034 	movhi	r2,65408
81134b14:	10bfffc4 	addi	r2,r2,-1
81134b18:	4090703a 	and	r8,r8,r2
81134b1c:	880ad07a 	srli	r5,r17,1
81134b20:	400897fa 	slli	r4,r8,31
81134b24:	88c0004c 	andi	r3,r17,1
81134b28:	28e2b03a 	or	r17,r5,r3
81134b2c:	4010d07a 	srli	r8,r8,1
81134b30:	2462b03a 	or	r17,r4,r17
81134b34:	003f7106 	br	811348fc <__reset+0xfb1148fc>
81134b38:	4088b03a 	or	r4,r8,r2
81134b3c:	20014526 	beq	r4,zero,81135054 <__adddf3+0x7dc>
81134b40:	01000434 	movhi	r4,16
81134b44:	42000234 	orhi	r8,r8,8
81134b48:	213fffc4 	addi	r4,r4,-1
81134b4c:	4110703a 	and	r8,r8,r4
81134b50:	003f8206 	br	8113495c <__reset+0xfb11495c>
81134b54:	18ffffc4 	addi	r3,r3,-1
81134b58:	1800491e 	bne	r3,zero,81134c80 <__adddf3+0x408>
81134b5c:	898bc83a 	sub	r5,r17,r6
81134b60:	8963803a 	cmpltu	r17,r17,r5
81134b64:	4251c83a 	sub	r8,r8,r9
81134b68:	4451c83a 	sub	r8,r8,r17
81134b6c:	2823883a 	mov	r17,r5
81134b70:	003f9f06 	br	811349f0 <__reset+0xfb1149f0>
81134b74:	4984b03a 	or	r2,r9,r6
81134b78:	103f6026 	beq	r2,zero,811348fc <__reset+0xfb1148fc>
81134b7c:	213fffc4 	addi	r4,r4,-1
81134b80:	2000931e 	bne	r4,zero,81134dd0 <__adddf3+0x558>
81134b84:	898d883a 	add	r6,r17,r6
81134b88:	3463803a 	cmpltu	r17,r6,r17
81134b8c:	4251883a 	add	r8,r8,r9
81134b90:	8a11883a 	add	r8,r17,r8
81134b94:	3023883a 	mov	r17,r6
81134b98:	003fd806 	br	81134afc <__reset+0xfb114afc>
81134b9c:	1800541e 	bne	r3,zero,81134cf0 <__adddf3+0x478>
81134ba0:	80800044 	addi	r2,r16,1
81134ba4:	1081ffcc 	andi	r2,r2,2047
81134ba8:	00c00044 	movi	r3,1
81134bac:	1880a00e 	bge	r3,r2,81134e30 <__adddf3+0x5b8>
81134bb0:	8989c83a 	sub	r4,r17,r6
81134bb4:	8905803a 	cmpltu	r2,r17,r4
81134bb8:	4267c83a 	sub	r19,r8,r9
81134bbc:	98a7c83a 	sub	r19,r19,r2
81134bc0:	9880202c 	andhi	r2,r19,128
81134bc4:	10006326 	beq	r2,zero,81134d54 <__adddf3+0x4dc>
81134bc8:	3463c83a 	sub	r17,r6,r17
81134bcc:	4a07c83a 	sub	r3,r9,r8
81134bd0:	344d803a 	cmpltu	r6,r6,r17
81134bd4:	19a7c83a 	sub	r19,r3,r6
81134bd8:	3825883a 	mov	r18,r7
81134bdc:	983f8a1e 	bne	r19,zero,81134a08 <__reset+0xfb114a08>
81134be0:	8809883a 	mov	r4,r17
81134be4:	1120de40 	call	81120de4 <__clzsi2>
81134be8:	10800804 	addi	r2,r2,32
81134bec:	10fffe04 	addi	r3,r2,-8
81134bf0:	010007c4 	movi	r4,31
81134bf4:	20ff890e 	bge	r4,r3,81134a1c <__reset+0xfb114a1c>
81134bf8:	10bff604 	addi	r2,r2,-40
81134bfc:	8884983a 	sll	r2,r17,r2
81134c00:	0023883a 	mov	r17,zero
81134c04:	1c3f8c0e 	bge	r3,r16,81134a38 <__reset+0xfb114a38>
81134c08:	023fe034 	movhi	r8,65408
81134c0c:	423fffc4 	addi	r8,r8,-1
81134c10:	80e1c83a 	sub	r16,r16,r3
81134c14:	1210703a 	and	r8,r2,r8
81134c18:	003f3806 	br	811348fc <__reset+0xfb1148fc>
81134c1c:	9007883a 	mov	r3,r18
81134c20:	0011883a 	mov	r8,zero
81134c24:	0005883a 	mov	r2,zero
81134c28:	003f4c06 	br	8113495c <__reset+0xfb11495c>
81134c2c:	498cb03a 	or	r6,r9,r6
81134c30:	300cc03a 	cmpne	r6,r6,zero
81134c34:	0007883a 	mov	r3,zero
81134c38:	003f6806 	br	811349dc <__reset+0xfb1149dc>
81134c3c:	20009c1e 	bne	r4,zero,81134eb0 <__adddf3+0x638>
81134c40:	80800044 	addi	r2,r16,1
81134c44:	1141ffcc 	andi	r5,r2,2047
81134c48:	01000044 	movi	r4,1
81134c4c:	2140670e 	bge	r4,r5,81134dec <__adddf3+0x574>
81134c50:	0101ffc4 	movi	r4,2047
81134c54:	11007f26 	beq	r2,r4,81134e54 <__adddf3+0x5dc>
81134c58:	898d883a 	add	r6,r17,r6
81134c5c:	4247883a 	add	r3,r8,r9
81134c60:	3451803a 	cmpltu	r8,r6,r17
81134c64:	40d1883a 	add	r8,r8,r3
81134c68:	402297fa 	slli	r17,r8,31
81134c6c:	300cd07a 	srli	r6,r6,1
81134c70:	4010d07a 	srli	r8,r8,1
81134c74:	1021883a 	mov	r16,r2
81134c78:	89a2b03a 	or	r17,r17,r6
81134c7c:	003f1f06 	br	811348fc <__reset+0xfb1148fc>
81134c80:	0081ffc4 	movi	r2,2047
81134c84:	80bf481e 	bne	r16,r2,811349a8 <__reset+0xfb1149a8>
81134c88:	003f1c06 	br	811348fc <__reset+0xfb1148fc>
81134c8c:	843ff844 	addi	r16,r16,-31
81134c90:	01000804 	movi	r4,32
81134c94:	1406d83a 	srl	r3,r2,r16
81134c98:	41005026 	beq	r8,r4,81134ddc <__adddf3+0x564>
81134c9c:	01001004 	movi	r4,64
81134ca0:	2211c83a 	sub	r8,r4,r8
81134ca4:	1204983a 	sll	r2,r2,r8
81134ca8:	88a2b03a 	or	r17,r17,r2
81134cac:	8822c03a 	cmpne	r17,r17,zero
81134cb0:	1c62b03a 	or	r17,r3,r17
81134cb4:	0011883a 	mov	r8,zero
81134cb8:	0021883a 	mov	r16,zero
81134cbc:	003f7106 	br	81134a84 <__reset+0xfb114a84>
81134cc0:	193ff804 	addi	r4,r3,-32
81134cc4:	00800804 	movi	r2,32
81134cc8:	4908d83a 	srl	r4,r9,r4
81134ccc:	18804526 	beq	r3,r2,81134de4 <__adddf3+0x56c>
81134cd0:	00801004 	movi	r2,64
81134cd4:	10c5c83a 	sub	r2,r2,r3
81134cd8:	4886983a 	sll	r3,r9,r2
81134cdc:	198cb03a 	or	r6,r3,r6
81134ce0:	300cc03a 	cmpne	r6,r6,zero
81134ce4:	218cb03a 	or	r6,r4,r6
81134ce8:	0007883a 	mov	r3,zero
81134cec:	003f3b06 	br	811349dc <__reset+0xfb1149dc>
81134cf0:	80002a26 	beq	r16,zero,81134d9c <__adddf3+0x524>
81134cf4:	0101ffc4 	movi	r4,2047
81134cf8:	11006826 	beq	r2,r4,81134e9c <__adddf3+0x624>
81134cfc:	00c7c83a 	sub	r3,zero,r3
81134d00:	42002034 	orhi	r8,r8,128
81134d04:	01000e04 	movi	r4,56
81134d08:	20c07c16 	blt	r4,r3,81134efc <__adddf3+0x684>
81134d0c:	010007c4 	movi	r4,31
81134d10:	20c0da16 	blt	r4,r3,8113507c <__adddf3+0x804>
81134d14:	01000804 	movi	r4,32
81134d18:	20c9c83a 	sub	r4,r4,r3
81134d1c:	4114983a 	sll	r10,r8,r4
81134d20:	88cad83a 	srl	r5,r17,r3
81134d24:	8908983a 	sll	r4,r17,r4
81134d28:	40c6d83a 	srl	r3,r8,r3
81134d2c:	5162b03a 	or	r17,r10,r5
81134d30:	2008c03a 	cmpne	r4,r4,zero
81134d34:	8922b03a 	or	r17,r17,r4
81134d38:	3463c83a 	sub	r17,r6,r17
81134d3c:	48c7c83a 	sub	r3,r9,r3
81134d40:	344d803a 	cmpltu	r6,r6,r17
81134d44:	1991c83a 	sub	r8,r3,r6
81134d48:	1021883a 	mov	r16,r2
81134d4c:	3825883a 	mov	r18,r7
81134d50:	003f2706 	br	811349f0 <__reset+0xfb1149f0>
81134d54:	24d0b03a 	or	r8,r4,r19
81134d58:	40001b1e 	bne	r8,zero,81134dc8 <__adddf3+0x550>
81134d5c:	0005883a 	mov	r2,zero
81134d60:	0007883a 	mov	r3,zero
81134d64:	0021883a 	mov	r16,zero
81134d68:	003f4d06 	br	81134aa0 <__reset+0xfb114aa0>
81134d6c:	008007c4 	movi	r2,31
81134d70:	11003c16 	blt	r2,r4,81134e64 <__adddf3+0x5ec>
81134d74:	00800804 	movi	r2,32
81134d78:	1105c83a 	sub	r2,r2,r4
81134d7c:	488e983a 	sll	r7,r9,r2
81134d80:	310ad83a 	srl	r5,r6,r4
81134d84:	3084983a 	sll	r2,r6,r2
81134d88:	4912d83a 	srl	r9,r9,r4
81134d8c:	394ab03a 	or	r5,r7,r5
81134d90:	1004c03a 	cmpne	r2,r2,zero
81134d94:	288ab03a 	or	r5,r5,r2
81134d98:	003f5306 	br	81134ae8 <__reset+0xfb114ae8>
81134d9c:	4448b03a 	or	r4,r8,r17
81134da0:	20003e26 	beq	r4,zero,81134e9c <__adddf3+0x624>
81134da4:	00c6303a 	nor	r3,zero,r3
81134da8:	18003a1e 	bne	r3,zero,81134e94 <__adddf3+0x61c>
81134dac:	3463c83a 	sub	r17,r6,r17
81134db0:	4a07c83a 	sub	r3,r9,r8
81134db4:	344d803a 	cmpltu	r6,r6,r17
81134db8:	1991c83a 	sub	r8,r3,r6
81134dbc:	1021883a 	mov	r16,r2
81134dc0:	3825883a 	mov	r18,r7
81134dc4:	003f0a06 	br	811349f0 <__reset+0xfb1149f0>
81134dc8:	2023883a 	mov	r17,r4
81134dcc:	003f0d06 	br	81134a04 <__reset+0xfb114a04>
81134dd0:	0081ffc4 	movi	r2,2047
81134dd4:	80bf3f1e 	bne	r16,r2,81134ad4 <__reset+0xfb114ad4>
81134dd8:	003ec806 	br	811348fc <__reset+0xfb1148fc>
81134ddc:	0005883a 	mov	r2,zero
81134de0:	003fb106 	br	81134ca8 <__reset+0xfb114ca8>
81134de4:	0007883a 	mov	r3,zero
81134de8:	003fbc06 	br	81134cdc <__reset+0xfb114cdc>
81134dec:	4444b03a 	or	r2,r8,r17
81134df0:	8000871e 	bne	r16,zero,81135010 <__adddf3+0x798>
81134df4:	1000ba26 	beq	r2,zero,811350e0 <__adddf3+0x868>
81134df8:	4984b03a 	or	r2,r9,r6
81134dfc:	103ebf26 	beq	r2,zero,811348fc <__reset+0xfb1148fc>
81134e00:	8985883a 	add	r2,r17,r6
81134e04:	4247883a 	add	r3,r8,r9
81134e08:	1451803a 	cmpltu	r8,r2,r17
81134e0c:	40d1883a 	add	r8,r8,r3
81134e10:	40c0202c 	andhi	r3,r8,128
81134e14:	1023883a 	mov	r17,r2
81134e18:	183f1a26 	beq	r3,zero,81134a84 <__reset+0xfb114a84>
81134e1c:	00bfe034 	movhi	r2,65408
81134e20:	10bfffc4 	addi	r2,r2,-1
81134e24:	2021883a 	mov	r16,r4
81134e28:	4090703a 	and	r8,r8,r2
81134e2c:	003eb306 	br	811348fc <__reset+0xfb1148fc>
81134e30:	4444b03a 	or	r2,r8,r17
81134e34:	8000291e 	bne	r16,zero,81134edc <__adddf3+0x664>
81134e38:	10004b1e 	bne	r2,zero,81134f68 <__adddf3+0x6f0>
81134e3c:	4990b03a 	or	r8,r9,r6
81134e40:	40008b26 	beq	r8,zero,81135070 <__adddf3+0x7f8>
81134e44:	4811883a 	mov	r8,r9
81134e48:	3023883a 	mov	r17,r6
81134e4c:	3825883a 	mov	r18,r7
81134e50:	003eaa06 	br	811348fc <__reset+0xfb1148fc>
81134e54:	1021883a 	mov	r16,r2
81134e58:	0011883a 	mov	r8,zero
81134e5c:	0005883a 	mov	r2,zero
81134e60:	003f0f06 	br	81134aa0 <__reset+0xfb114aa0>
81134e64:	217ff804 	addi	r5,r4,-32
81134e68:	00800804 	movi	r2,32
81134e6c:	494ad83a 	srl	r5,r9,r5
81134e70:	20807d26 	beq	r4,r2,81135068 <__adddf3+0x7f0>
81134e74:	00801004 	movi	r2,64
81134e78:	1109c83a 	sub	r4,r2,r4
81134e7c:	4912983a 	sll	r9,r9,r4
81134e80:	498cb03a 	or	r6,r9,r6
81134e84:	300cc03a 	cmpne	r6,r6,zero
81134e88:	298ab03a 	or	r5,r5,r6
81134e8c:	0013883a 	mov	r9,zero
81134e90:	003f1506 	br	81134ae8 <__reset+0xfb114ae8>
81134e94:	0101ffc4 	movi	r4,2047
81134e98:	113f9a1e 	bne	r2,r4,81134d04 <__reset+0xfb114d04>
81134e9c:	4811883a 	mov	r8,r9
81134ea0:	3023883a 	mov	r17,r6
81134ea4:	1021883a 	mov	r16,r2
81134ea8:	3825883a 	mov	r18,r7
81134eac:	003e9306 	br	811348fc <__reset+0xfb1148fc>
81134eb0:	8000161e 	bne	r16,zero,81134f0c <__adddf3+0x694>
81134eb4:	444ab03a 	or	r5,r8,r17
81134eb8:	28005126 	beq	r5,zero,81135000 <__adddf3+0x788>
81134ebc:	0108303a 	nor	r4,zero,r4
81134ec0:	20004d1e 	bne	r4,zero,81134ff8 <__adddf3+0x780>
81134ec4:	89a3883a 	add	r17,r17,r6
81134ec8:	4253883a 	add	r9,r8,r9
81134ecc:	898d803a 	cmpltu	r6,r17,r6
81134ed0:	3251883a 	add	r8,r6,r9
81134ed4:	1021883a 	mov	r16,r2
81134ed8:	003f0806 	br	81134afc <__reset+0xfb114afc>
81134edc:	1000301e 	bne	r2,zero,81134fa0 <__adddf3+0x728>
81134ee0:	4984b03a 	or	r2,r9,r6
81134ee4:	10007126 	beq	r2,zero,811350ac <__adddf3+0x834>
81134ee8:	4811883a 	mov	r8,r9
81134eec:	3023883a 	mov	r17,r6
81134ef0:	3825883a 	mov	r18,r7
81134ef4:	0401ffc4 	movi	r16,2047
81134ef8:	003e8006 	br	811348fc <__reset+0xfb1148fc>
81134efc:	4462b03a 	or	r17,r8,r17
81134f00:	8822c03a 	cmpne	r17,r17,zero
81134f04:	0007883a 	mov	r3,zero
81134f08:	003f8b06 	br	81134d38 <__reset+0xfb114d38>
81134f0c:	0141ffc4 	movi	r5,2047
81134f10:	11403b26 	beq	r2,r5,81135000 <__adddf3+0x788>
81134f14:	0109c83a 	sub	r4,zero,r4
81134f18:	42002034 	orhi	r8,r8,128
81134f1c:	01400e04 	movi	r5,56
81134f20:	29006716 	blt	r5,r4,811350c0 <__adddf3+0x848>
81134f24:	014007c4 	movi	r5,31
81134f28:	29007016 	blt	r5,r4,811350ec <__adddf3+0x874>
81134f2c:	01400804 	movi	r5,32
81134f30:	290bc83a 	sub	r5,r5,r4
81134f34:	4154983a 	sll	r10,r8,r5
81134f38:	890ed83a 	srl	r7,r17,r4
81134f3c:	894a983a 	sll	r5,r17,r5
81134f40:	4108d83a 	srl	r4,r8,r4
81134f44:	51e2b03a 	or	r17,r10,r7
81134f48:	280ac03a 	cmpne	r5,r5,zero
81134f4c:	8962b03a 	or	r17,r17,r5
81134f50:	89a3883a 	add	r17,r17,r6
81134f54:	2253883a 	add	r9,r4,r9
81134f58:	898d803a 	cmpltu	r6,r17,r6
81134f5c:	3251883a 	add	r8,r6,r9
81134f60:	1021883a 	mov	r16,r2
81134f64:	003ee506 	br	81134afc <__reset+0xfb114afc>
81134f68:	4984b03a 	or	r2,r9,r6
81134f6c:	103e6326 	beq	r2,zero,811348fc <__reset+0xfb1148fc>
81134f70:	8987c83a 	sub	r3,r17,r6
81134f74:	88c9803a 	cmpltu	r4,r17,r3
81134f78:	4245c83a 	sub	r2,r8,r9
81134f7c:	1105c83a 	sub	r2,r2,r4
81134f80:	1100202c 	andhi	r4,r2,128
81134f84:	203ebb26 	beq	r4,zero,81134a74 <__reset+0xfb114a74>
81134f88:	3463c83a 	sub	r17,r6,r17
81134f8c:	4a07c83a 	sub	r3,r9,r8
81134f90:	344d803a 	cmpltu	r6,r6,r17
81134f94:	1991c83a 	sub	r8,r3,r6
81134f98:	3825883a 	mov	r18,r7
81134f9c:	003e5706 	br	811348fc <__reset+0xfb1148fc>
81134fa0:	4984b03a 	or	r2,r9,r6
81134fa4:	10002e26 	beq	r2,zero,81135060 <__adddf3+0x7e8>
81134fa8:	4004d0fa 	srli	r2,r8,3
81134fac:	8822d0fa 	srli	r17,r17,3
81134fb0:	4010977a 	slli	r8,r8,29
81134fb4:	10c0022c 	andhi	r3,r2,8
81134fb8:	4462b03a 	or	r17,r8,r17
81134fbc:	18000826 	beq	r3,zero,81134fe0 <__adddf3+0x768>
81134fc0:	4808d0fa 	srli	r4,r9,3
81134fc4:	20c0022c 	andhi	r3,r4,8
81134fc8:	1800051e 	bne	r3,zero,81134fe0 <__adddf3+0x768>
81134fcc:	300cd0fa 	srli	r6,r6,3
81134fd0:	4806977a 	slli	r3,r9,29
81134fd4:	2005883a 	mov	r2,r4
81134fd8:	3825883a 	mov	r18,r7
81134fdc:	19a2b03a 	or	r17,r3,r6
81134fe0:	8810d77a 	srli	r8,r17,29
81134fe4:	100490fa 	slli	r2,r2,3
81134fe8:	882290fa 	slli	r17,r17,3
81134fec:	0401ffc4 	movi	r16,2047
81134ff0:	4090b03a 	or	r8,r8,r2
81134ff4:	003e4106 	br	811348fc <__reset+0xfb1148fc>
81134ff8:	0141ffc4 	movi	r5,2047
81134ffc:	117fc71e 	bne	r2,r5,81134f1c <__reset+0xfb114f1c>
81135000:	4811883a 	mov	r8,r9
81135004:	3023883a 	mov	r17,r6
81135008:	1021883a 	mov	r16,r2
8113500c:	003e3b06 	br	811348fc <__reset+0xfb1148fc>
81135010:	10002f26 	beq	r2,zero,811350d0 <__adddf3+0x858>
81135014:	4984b03a 	or	r2,r9,r6
81135018:	10001126 	beq	r2,zero,81135060 <__adddf3+0x7e8>
8113501c:	4004d0fa 	srli	r2,r8,3
81135020:	8822d0fa 	srli	r17,r17,3
81135024:	4010977a 	slli	r8,r8,29
81135028:	10c0022c 	andhi	r3,r2,8
8113502c:	4462b03a 	or	r17,r8,r17
81135030:	183feb26 	beq	r3,zero,81134fe0 <__reset+0xfb114fe0>
81135034:	4808d0fa 	srli	r4,r9,3
81135038:	20c0022c 	andhi	r3,r4,8
8113503c:	183fe81e 	bne	r3,zero,81134fe0 <__reset+0xfb114fe0>
81135040:	300cd0fa 	srli	r6,r6,3
81135044:	4806977a 	slli	r3,r9,29
81135048:	2005883a 	mov	r2,r4
8113504c:	19a2b03a 	or	r17,r3,r6
81135050:	003fe306 	br	81134fe0 <__reset+0xfb114fe0>
81135054:	0011883a 	mov	r8,zero
81135058:	0005883a 	mov	r2,zero
8113505c:	003e3f06 	br	8113495c <__reset+0xfb11495c>
81135060:	0401ffc4 	movi	r16,2047
81135064:	003e2506 	br	811348fc <__reset+0xfb1148fc>
81135068:	0013883a 	mov	r9,zero
8113506c:	003f8406 	br	81134e80 <__reset+0xfb114e80>
81135070:	0005883a 	mov	r2,zero
81135074:	0007883a 	mov	r3,zero
81135078:	003e8906 	br	81134aa0 <__reset+0xfb114aa0>
8113507c:	197ff804 	addi	r5,r3,-32
81135080:	01000804 	movi	r4,32
81135084:	414ad83a 	srl	r5,r8,r5
81135088:	19002426 	beq	r3,r4,8113511c <__adddf3+0x8a4>
8113508c:	01001004 	movi	r4,64
81135090:	20c7c83a 	sub	r3,r4,r3
81135094:	40c6983a 	sll	r3,r8,r3
81135098:	1c46b03a 	or	r3,r3,r17
8113509c:	1806c03a 	cmpne	r3,r3,zero
811350a0:	28e2b03a 	or	r17,r5,r3
811350a4:	0007883a 	mov	r3,zero
811350a8:	003f2306 	br	81134d38 <__reset+0xfb114d38>
811350ac:	0007883a 	mov	r3,zero
811350b0:	5811883a 	mov	r8,r11
811350b4:	00bfffc4 	movi	r2,-1
811350b8:	0401ffc4 	movi	r16,2047
811350bc:	003e7806 	br	81134aa0 <__reset+0xfb114aa0>
811350c0:	4462b03a 	or	r17,r8,r17
811350c4:	8822c03a 	cmpne	r17,r17,zero
811350c8:	0009883a 	mov	r4,zero
811350cc:	003fa006 	br	81134f50 <__reset+0xfb114f50>
811350d0:	4811883a 	mov	r8,r9
811350d4:	3023883a 	mov	r17,r6
811350d8:	0401ffc4 	movi	r16,2047
811350dc:	003e0706 	br	811348fc <__reset+0xfb1148fc>
811350e0:	4811883a 	mov	r8,r9
811350e4:	3023883a 	mov	r17,r6
811350e8:	003e0406 	br	811348fc <__reset+0xfb1148fc>
811350ec:	21fff804 	addi	r7,r4,-32
811350f0:	01400804 	movi	r5,32
811350f4:	41ced83a 	srl	r7,r8,r7
811350f8:	21400a26 	beq	r4,r5,81135124 <__adddf3+0x8ac>
811350fc:	01401004 	movi	r5,64
81135100:	2909c83a 	sub	r4,r5,r4
81135104:	4108983a 	sll	r4,r8,r4
81135108:	2448b03a 	or	r4,r4,r17
8113510c:	2008c03a 	cmpne	r4,r4,zero
81135110:	3922b03a 	or	r17,r7,r4
81135114:	0009883a 	mov	r4,zero
81135118:	003f8d06 	br	81134f50 <__reset+0xfb114f50>
8113511c:	0007883a 	mov	r3,zero
81135120:	003fdd06 	br	81135098 <__reset+0xfb115098>
81135124:	0009883a 	mov	r4,zero
81135128:	003ff706 	br	81135108 <__reset+0xfb115108>

8113512c <__divdf3>:
8113512c:	defff204 	addi	sp,sp,-56
81135130:	de00012e 	bgeu	sp,et,81135138 <__divdf3+0xc>
81135134:	003b68fa 	trap	3
81135138:	dd400915 	stw	r21,36(sp)
8113513c:	282ad53a 	srli	r21,r5,20
81135140:	dd000815 	stw	r20,32(sp)
81135144:	2828d7fa 	srli	r20,r5,31
81135148:	dc000415 	stw	r16,16(sp)
8113514c:	04000434 	movhi	r16,16
81135150:	df000c15 	stw	fp,48(sp)
81135154:	843fffc4 	addi	r16,r16,-1
81135158:	dfc00d15 	stw	ra,52(sp)
8113515c:	ddc00b15 	stw	r23,44(sp)
81135160:	dd800a15 	stw	r22,40(sp)
81135164:	dcc00715 	stw	r19,28(sp)
81135168:	dc800615 	stw	r18,24(sp)
8113516c:	dc400515 	stw	r17,20(sp)
81135170:	ad41ffcc 	andi	r21,r21,2047
81135174:	2c20703a 	and	r16,r5,r16
81135178:	a7003fcc 	andi	fp,r20,255
8113517c:	a8006126 	beq	r21,zero,81135304 <__divdf3+0x1d8>
81135180:	0081ffc4 	movi	r2,2047
81135184:	2025883a 	mov	r18,r4
81135188:	a8803726 	beq	r21,r2,81135268 <__divdf3+0x13c>
8113518c:	80800434 	orhi	r2,r16,16
81135190:	100490fa 	slli	r2,r2,3
81135194:	2020d77a 	srli	r16,r4,29
81135198:	202490fa 	slli	r18,r4,3
8113519c:	ad7f0044 	addi	r21,r21,-1023
811351a0:	80a0b03a 	or	r16,r16,r2
811351a4:	0027883a 	mov	r19,zero
811351a8:	0013883a 	mov	r9,zero
811351ac:	3804d53a 	srli	r2,r7,20
811351b0:	382cd7fa 	srli	r22,r7,31
811351b4:	04400434 	movhi	r17,16
811351b8:	8c7fffc4 	addi	r17,r17,-1
811351bc:	1081ffcc 	andi	r2,r2,2047
811351c0:	3011883a 	mov	r8,r6
811351c4:	3c62703a 	and	r17,r7,r17
811351c8:	b5c03fcc 	andi	r23,r22,255
811351cc:	10006c26 	beq	r2,zero,81135380 <__divdf3+0x254>
811351d0:	00c1ffc4 	movi	r3,2047
811351d4:	10c06426 	beq	r2,r3,81135368 <__divdf3+0x23c>
811351d8:	88c00434 	orhi	r3,r17,16
811351dc:	180690fa 	slli	r3,r3,3
811351e0:	3022d77a 	srli	r17,r6,29
811351e4:	301090fa 	slli	r8,r6,3
811351e8:	10bf0044 	addi	r2,r2,-1023
811351ec:	88e2b03a 	or	r17,r17,r3
811351f0:	000f883a 	mov	r7,zero
811351f4:	a58cf03a 	xor	r6,r20,r22
811351f8:	3cc8b03a 	or	r4,r7,r19
811351fc:	a8abc83a 	sub	r21,r21,r2
81135200:	008003c4 	movi	r2,15
81135204:	3007883a 	mov	r3,r6
81135208:	34c03fcc 	andi	r19,r6,255
8113520c:	11009036 	bltu	r2,r4,81135450 <__divdf3+0x324>
81135210:	200890ba 	slli	r4,r4,2
81135214:	00a044f4 	movhi	r2,33043
81135218:	10948a04 	addi	r2,r2,21032
8113521c:	2089883a 	add	r4,r4,r2
81135220:	20800017 	ldw	r2,0(r4)
81135224:	1000683a 	jmp	r2
81135228:	81135450 	cmplti	r4,r16,19793
8113522c:	811352a0 	cmpeqi	r4,r16,19786
81135230:	81135440 	call	88113544 <__reset+0x20f3544>
81135234:	81135294 	ori	r4,r16,19786
81135238:	81135440 	call	88113544 <__reset+0x20f3544>
8113523c:	81135414 	ori	r4,r16,19792
81135240:	81135440 	call	88113544 <__reset+0x20f3544>
81135244:	81135294 	ori	r4,r16,19786
81135248:	811352a0 	cmpeqi	r4,r16,19786
8113524c:	811352a0 	cmpeqi	r4,r16,19786
81135250:	81135414 	ori	r4,r16,19792
81135254:	81135294 	ori	r4,r16,19786
81135258:	81135284 	addi	r4,r16,19786
8113525c:	81135284 	addi	r4,r16,19786
81135260:	81135284 	addi	r4,r16,19786
81135264:	81135734 	orhi	r4,r16,19804
81135268:	2404b03a 	or	r2,r4,r16
8113526c:	1000661e 	bne	r2,zero,81135408 <__divdf3+0x2dc>
81135270:	04c00204 	movi	r19,8
81135274:	0021883a 	mov	r16,zero
81135278:	0025883a 	mov	r18,zero
8113527c:	02400084 	movi	r9,2
81135280:	003fca06 	br	811351ac <__reset+0xfb1151ac>
81135284:	8023883a 	mov	r17,r16
81135288:	9011883a 	mov	r8,r18
8113528c:	e02f883a 	mov	r23,fp
81135290:	480f883a 	mov	r7,r9
81135294:	00800084 	movi	r2,2
81135298:	3881311e 	bne	r7,r2,81135760 <__divdf3+0x634>
8113529c:	b827883a 	mov	r19,r23
811352a0:	98c0004c 	andi	r3,r19,1
811352a4:	0081ffc4 	movi	r2,2047
811352a8:	000b883a 	mov	r5,zero
811352ac:	0025883a 	mov	r18,zero
811352b0:	1004953a 	slli	r2,r2,20
811352b4:	18c03fcc 	andi	r3,r3,255
811352b8:	04400434 	movhi	r17,16
811352bc:	8c7fffc4 	addi	r17,r17,-1
811352c0:	180697fa 	slli	r3,r3,31
811352c4:	2c4a703a 	and	r5,r5,r17
811352c8:	288ab03a 	or	r5,r5,r2
811352cc:	28c6b03a 	or	r3,r5,r3
811352d0:	9005883a 	mov	r2,r18
811352d4:	dfc00d17 	ldw	ra,52(sp)
811352d8:	df000c17 	ldw	fp,48(sp)
811352dc:	ddc00b17 	ldw	r23,44(sp)
811352e0:	dd800a17 	ldw	r22,40(sp)
811352e4:	dd400917 	ldw	r21,36(sp)
811352e8:	dd000817 	ldw	r20,32(sp)
811352ec:	dcc00717 	ldw	r19,28(sp)
811352f0:	dc800617 	ldw	r18,24(sp)
811352f4:	dc400517 	ldw	r17,20(sp)
811352f8:	dc000417 	ldw	r16,16(sp)
811352fc:	dec00e04 	addi	sp,sp,56
81135300:	f800283a 	ret
81135304:	2404b03a 	or	r2,r4,r16
81135308:	2027883a 	mov	r19,r4
8113530c:	10003926 	beq	r2,zero,811353f4 <__divdf3+0x2c8>
81135310:	80012e26 	beq	r16,zero,811357cc <__divdf3+0x6a0>
81135314:	8009883a 	mov	r4,r16
81135318:	d9800315 	stw	r6,12(sp)
8113531c:	d9c00215 	stw	r7,8(sp)
81135320:	1120de40 	call	81120de4 <__clzsi2>
81135324:	d9800317 	ldw	r6,12(sp)
81135328:	d9c00217 	ldw	r7,8(sp)
8113532c:	113ffd44 	addi	r4,r2,-11
81135330:	00c00704 	movi	r3,28
81135334:	19012116 	blt	r3,r4,811357bc <__divdf3+0x690>
81135338:	00c00744 	movi	r3,29
8113533c:	147ffe04 	addi	r17,r2,-8
81135340:	1907c83a 	sub	r3,r3,r4
81135344:	8460983a 	sll	r16,r16,r17
81135348:	98c6d83a 	srl	r3,r19,r3
8113534c:	9c64983a 	sll	r18,r19,r17
81135350:	1c20b03a 	or	r16,r3,r16
81135354:	1080fcc4 	addi	r2,r2,1011
81135358:	00abc83a 	sub	r21,zero,r2
8113535c:	0027883a 	mov	r19,zero
81135360:	0013883a 	mov	r9,zero
81135364:	003f9106 	br	811351ac <__reset+0xfb1151ac>
81135368:	3446b03a 	or	r3,r6,r17
8113536c:	18001f1e 	bne	r3,zero,811353ec <__divdf3+0x2c0>
81135370:	0023883a 	mov	r17,zero
81135374:	0011883a 	mov	r8,zero
81135378:	01c00084 	movi	r7,2
8113537c:	003f9d06 	br	811351f4 <__reset+0xfb1151f4>
81135380:	3446b03a 	or	r3,r6,r17
81135384:	18001526 	beq	r3,zero,811353dc <__divdf3+0x2b0>
81135388:	88011b26 	beq	r17,zero,811357f8 <__divdf3+0x6cc>
8113538c:	8809883a 	mov	r4,r17
81135390:	d9800315 	stw	r6,12(sp)
81135394:	da400115 	stw	r9,4(sp)
81135398:	1120de40 	call	81120de4 <__clzsi2>
8113539c:	d9800317 	ldw	r6,12(sp)
811353a0:	da400117 	ldw	r9,4(sp)
811353a4:	113ffd44 	addi	r4,r2,-11
811353a8:	00c00704 	movi	r3,28
811353ac:	19010e16 	blt	r3,r4,811357e8 <__divdf3+0x6bc>
811353b0:	00c00744 	movi	r3,29
811353b4:	123ffe04 	addi	r8,r2,-8
811353b8:	1907c83a 	sub	r3,r3,r4
811353bc:	8a22983a 	sll	r17,r17,r8
811353c0:	30c6d83a 	srl	r3,r6,r3
811353c4:	3210983a 	sll	r8,r6,r8
811353c8:	1c62b03a 	or	r17,r3,r17
811353cc:	1080fcc4 	addi	r2,r2,1011
811353d0:	0085c83a 	sub	r2,zero,r2
811353d4:	000f883a 	mov	r7,zero
811353d8:	003f8606 	br	811351f4 <__reset+0xfb1151f4>
811353dc:	0023883a 	mov	r17,zero
811353e0:	0011883a 	mov	r8,zero
811353e4:	01c00044 	movi	r7,1
811353e8:	003f8206 	br	811351f4 <__reset+0xfb1151f4>
811353ec:	01c000c4 	movi	r7,3
811353f0:	003f8006 	br	811351f4 <__reset+0xfb1151f4>
811353f4:	04c00104 	movi	r19,4
811353f8:	0021883a 	mov	r16,zero
811353fc:	0025883a 	mov	r18,zero
81135400:	02400044 	movi	r9,1
81135404:	003f6906 	br	811351ac <__reset+0xfb1151ac>
81135408:	04c00304 	movi	r19,12
8113540c:	024000c4 	movi	r9,3
81135410:	003f6606 	br	811351ac <__reset+0xfb1151ac>
81135414:	01400434 	movhi	r5,16
81135418:	0007883a 	mov	r3,zero
8113541c:	297fffc4 	addi	r5,r5,-1
81135420:	04bfffc4 	movi	r18,-1
81135424:	0081ffc4 	movi	r2,2047
81135428:	003fa106 	br	811352b0 <__reset+0xfb1152b0>
8113542c:	00c00044 	movi	r3,1
81135430:	1887c83a 	sub	r3,r3,r2
81135434:	01000e04 	movi	r4,56
81135438:	20c1210e 	bge	r4,r3,811358c0 <__divdf3+0x794>
8113543c:	98c0004c 	andi	r3,r19,1
81135440:	0005883a 	mov	r2,zero
81135444:	000b883a 	mov	r5,zero
81135448:	0025883a 	mov	r18,zero
8113544c:	003f9806 	br	811352b0 <__reset+0xfb1152b0>
81135450:	8c00fd36 	bltu	r17,r16,81135848 <__divdf3+0x71c>
81135454:	8440fb26 	beq	r16,r17,81135844 <__divdf3+0x718>
81135458:	8007883a 	mov	r3,r16
8113545c:	ad7fffc4 	addi	r21,r21,-1
81135460:	0021883a 	mov	r16,zero
81135464:	4004d63a 	srli	r2,r8,24
81135468:	8822923a 	slli	r17,r17,8
8113546c:	1809883a 	mov	r4,r3
81135470:	402c923a 	slli	r22,r8,8
81135474:	88b8b03a 	or	fp,r17,r2
81135478:	e028d43a 	srli	r20,fp,16
8113547c:	d8c00015 	stw	r3,0(sp)
81135480:	e5ffffcc 	andi	r23,fp,65535
81135484:	a00b883a 	mov	r5,r20
81135488:	11345c00 	call	811345c0 <__udivsi3>
8113548c:	d8c00017 	ldw	r3,0(sp)
81135490:	a00b883a 	mov	r5,r20
81135494:	d8800315 	stw	r2,12(sp)
81135498:	1809883a 	mov	r4,r3
8113549c:	11346240 	call	81134624 <__umodsi3>
811354a0:	d9800317 	ldw	r6,12(sp)
811354a4:	1006943a 	slli	r3,r2,16
811354a8:	9004d43a 	srli	r2,r18,16
811354ac:	b9a3383a 	mul	r17,r23,r6
811354b0:	10c4b03a 	or	r2,r2,r3
811354b4:	1440062e 	bgeu	r2,r17,811354d0 <__divdf3+0x3a4>
811354b8:	1705883a 	add	r2,r2,fp
811354bc:	30ffffc4 	addi	r3,r6,-1
811354c0:	1700ee36 	bltu	r2,fp,8113587c <__divdf3+0x750>
811354c4:	1440ed2e 	bgeu	r2,r17,8113587c <__divdf3+0x750>
811354c8:	31bfff84 	addi	r6,r6,-2
811354cc:	1705883a 	add	r2,r2,fp
811354d0:	1463c83a 	sub	r17,r2,r17
811354d4:	a00b883a 	mov	r5,r20
811354d8:	8809883a 	mov	r4,r17
811354dc:	d9800315 	stw	r6,12(sp)
811354e0:	11345c00 	call	811345c0 <__udivsi3>
811354e4:	a00b883a 	mov	r5,r20
811354e8:	8809883a 	mov	r4,r17
811354ec:	d8800215 	stw	r2,8(sp)
811354f0:	11346240 	call	81134624 <__umodsi3>
811354f4:	d9c00217 	ldw	r7,8(sp)
811354f8:	1004943a 	slli	r2,r2,16
811354fc:	94bfffcc 	andi	r18,r18,65535
81135500:	b9d1383a 	mul	r8,r23,r7
81135504:	90a4b03a 	or	r18,r18,r2
81135508:	d9800317 	ldw	r6,12(sp)
8113550c:	9200062e 	bgeu	r18,r8,81135528 <__divdf3+0x3fc>
81135510:	9725883a 	add	r18,r18,fp
81135514:	38bfffc4 	addi	r2,r7,-1
81135518:	9700d636 	bltu	r18,fp,81135874 <__divdf3+0x748>
8113551c:	9200d52e 	bgeu	r18,r8,81135874 <__divdf3+0x748>
81135520:	39ffff84 	addi	r7,r7,-2
81135524:	9725883a 	add	r18,r18,fp
81135528:	3004943a 	slli	r2,r6,16
8113552c:	b012d43a 	srli	r9,r22,16
81135530:	b1bfffcc 	andi	r6,r22,65535
81135534:	11e2b03a 	or	r17,r2,r7
81135538:	8806d43a 	srli	r3,r17,16
8113553c:	893fffcc 	andi	r4,r17,65535
81135540:	218b383a 	mul	r5,r4,r6
81135544:	30c5383a 	mul	r2,r6,r3
81135548:	2249383a 	mul	r4,r4,r9
8113554c:	280ed43a 	srli	r7,r5,16
81135550:	9225c83a 	sub	r18,r18,r8
81135554:	2089883a 	add	r4,r4,r2
81135558:	3909883a 	add	r4,r7,r4
8113555c:	1a47383a 	mul	r3,r3,r9
81135560:	2080022e 	bgeu	r4,r2,8113556c <__divdf3+0x440>
81135564:	00800074 	movhi	r2,1
81135568:	1887883a 	add	r3,r3,r2
8113556c:	2004d43a 	srli	r2,r4,16
81135570:	2008943a 	slli	r4,r4,16
81135574:	297fffcc 	andi	r5,r5,65535
81135578:	10c7883a 	add	r3,r2,r3
8113557c:	2149883a 	add	r4,r4,r5
81135580:	90c0a536 	bltu	r18,r3,81135818 <__divdf3+0x6ec>
81135584:	90c0bf26 	beq	r18,r3,81135884 <__divdf3+0x758>
81135588:	90c7c83a 	sub	r3,r18,r3
8113558c:	810fc83a 	sub	r7,r16,r4
81135590:	81e5803a 	cmpltu	r18,r16,r7
81135594:	1ca5c83a 	sub	r18,r3,r18
81135598:	e480c126 	beq	fp,r18,811358a0 <__divdf3+0x774>
8113559c:	a00b883a 	mov	r5,r20
811355a0:	9009883a 	mov	r4,r18
811355a4:	d9800315 	stw	r6,12(sp)
811355a8:	d9c00215 	stw	r7,8(sp)
811355ac:	da400115 	stw	r9,4(sp)
811355b0:	11345c00 	call	811345c0 <__udivsi3>
811355b4:	a00b883a 	mov	r5,r20
811355b8:	9009883a 	mov	r4,r18
811355bc:	d8800015 	stw	r2,0(sp)
811355c0:	11346240 	call	81134624 <__umodsi3>
811355c4:	d9c00217 	ldw	r7,8(sp)
811355c8:	da000017 	ldw	r8,0(sp)
811355cc:	1006943a 	slli	r3,r2,16
811355d0:	3804d43a 	srli	r2,r7,16
811355d4:	ba21383a 	mul	r16,r23,r8
811355d8:	d9800317 	ldw	r6,12(sp)
811355dc:	10c4b03a 	or	r2,r2,r3
811355e0:	da400117 	ldw	r9,4(sp)
811355e4:	1400062e 	bgeu	r2,r16,81135600 <__divdf3+0x4d4>
811355e8:	1705883a 	add	r2,r2,fp
811355ec:	40ffffc4 	addi	r3,r8,-1
811355f0:	1700ad36 	bltu	r2,fp,811358a8 <__divdf3+0x77c>
811355f4:	1400ac2e 	bgeu	r2,r16,811358a8 <__divdf3+0x77c>
811355f8:	423fff84 	addi	r8,r8,-2
811355fc:	1705883a 	add	r2,r2,fp
81135600:	1421c83a 	sub	r16,r2,r16
81135604:	a00b883a 	mov	r5,r20
81135608:	8009883a 	mov	r4,r16
8113560c:	d9800315 	stw	r6,12(sp)
81135610:	d9c00215 	stw	r7,8(sp)
81135614:	da000015 	stw	r8,0(sp)
81135618:	da400115 	stw	r9,4(sp)
8113561c:	11345c00 	call	811345c0 <__udivsi3>
81135620:	8009883a 	mov	r4,r16
81135624:	a00b883a 	mov	r5,r20
81135628:	1025883a 	mov	r18,r2
8113562c:	11346240 	call	81134624 <__umodsi3>
81135630:	d9c00217 	ldw	r7,8(sp)
81135634:	1004943a 	slli	r2,r2,16
81135638:	bcaf383a 	mul	r23,r23,r18
8113563c:	393fffcc 	andi	r4,r7,65535
81135640:	2088b03a 	or	r4,r4,r2
81135644:	d9800317 	ldw	r6,12(sp)
81135648:	da000017 	ldw	r8,0(sp)
8113564c:	da400117 	ldw	r9,4(sp)
81135650:	25c0062e 	bgeu	r4,r23,8113566c <__divdf3+0x540>
81135654:	2709883a 	add	r4,r4,fp
81135658:	90bfffc4 	addi	r2,r18,-1
8113565c:	27009436 	bltu	r4,fp,811358b0 <__divdf3+0x784>
81135660:	25c0932e 	bgeu	r4,r23,811358b0 <__divdf3+0x784>
81135664:	94bfff84 	addi	r18,r18,-2
81135668:	2709883a 	add	r4,r4,fp
8113566c:	4004943a 	slli	r2,r8,16
81135670:	25efc83a 	sub	r23,r4,r23
81135674:	1490b03a 	or	r8,r2,r18
81135678:	4008d43a 	srli	r4,r8,16
8113567c:	40ffffcc 	andi	r3,r8,65535
81135680:	30c5383a 	mul	r2,r6,r3
81135684:	1a47383a 	mul	r3,r3,r9
81135688:	310d383a 	mul	r6,r6,r4
8113568c:	100ad43a 	srli	r5,r2,16
81135690:	4913383a 	mul	r9,r9,r4
81135694:	1987883a 	add	r3,r3,r6
81135698:	28c7883a 	add	r3,r5,r3
8113569c:	1980022e 	bgeu	r3,r6,811356a8 <__divdf3+0x57c>
811356a0:	01000074 	movhi	r4,1
811356a4:	4913883a 	add	r9,r9,r4
811356a8:	1808d43a 	srli	r4,r3,16
811356ac:	1806943a 	slli	r3,r3,16
811356b0:	10bfffcc 	andi	r2,r2,65535
811356b4:	2253883a 	add	r9,r4,r9
811356b8:	1887883a 	add	r3,r3,r2
811356bc:	ba403836 	bltu	r23,r9,811357a0 <__divdf3+0x674>
811356c0:	ba403626 	beq	r23,r9,8113579c <__divdf3+0x670>
811356c4:	42000054 	ori	r8,r8,1
811356c8:	a880ffc4 	addi	r2,r21,1023
811356cc:	00bf570e 	bge	zero,r2,8113542c <__reset+0xfb11542c>
811356d0:	40c001cc 	andi	r3,r8,7
811356d4:	18000726 	beq	r3,zero,811356f4 <__divdf3+0x5c8>
811356d8:	40c003cc 	andi	r3,r8,15
811356dc:	01000104 	movi	r4,4
811356e0:	19000426 	beq	r3,r4,811356f4 <__divdf3+0x5c8>
811356e4:	4107883a 	add	r3,r8,r4
811356e8:	1a11803a 	cmpltu	r8,r3,r8
811356ec:	8a23883a 	add	r17,r17,r8
811356f0:	1811883a 	mov	r8,r3
811356f4:	88c0402c 	andhi	r3,r17,256
811356f8:	18000426 	beq	r3,zero,8113570c <__divdf3+0x5e0>
811356fc:	00ffc034 	movhi	r3,65280
81135700:	18ffffc4 	addi	r3,r3,-1
81135704:	a8810004 	addi	r2,r21,1024
81135708:	88e2703a 	and	r17,r17,r3
8113570c:	00c1ff84 	movi	r3,2046
81135710:	18bee316 	blt	r3,r2,811352a0 <__reset+0xfb1152a0>
81135714:	8824977a 	slli	r18,r17,29
81135718:	4010d0fa 	srli	r8,r8,3
8113571c:	8822927a 	slli	r17,r17,9
81135720:	1081ffcc 	andi	r2,r2,2047
81135724:	9224b03a 	or	r18,r18,r8
81135728:	880ad33a 	srli	r5,r17,12
8113572c:	98c0004c 	andi	r3,r19,1
81135730:	003edf06 	br	811352b0 <__reset+0xfb1152b0>
81135734:	8080022c 	andhi	r2,r16,8
81135738:	10001226 	beq	r2,zero,81135784 <__divdf3+0x658>
8113573c:	8880022c 	andhi	r2,r17,8
81135740:	1000101e 	bne	r2,zero,81135784 <__divdf3+0x658>
81135744:	00800434 	movhi	r2,16
81135748:	89400234 	orhi	r5,r17,8
8113574c:	10bfffc4 	addi	r2,r2,-1
81135750:	b007883a 	mov	r3,r22
81135754:	288a703a 	and	r5,r5,r2
81135758:	4025883a 	mov	r18,r8
8113575c:	003f3106 	br	81135424 <__reset+0xfb115424>
81135760:	008000c4 	movi	r2,3
81135764:	3880a626 	beq	r7,r2,81135a00 <__divdf3+0x8d4>
81135768:	00800044 	movi	r2,1
8113576c:	3880521e 	bne	r7,r2,811358b8 <__divdf3+0x78c>
81135770:	b807883a 	mov	r3,r23
81135774:	0005883a 	mov	r2,zero
81135778:	000b883a 	mov	r5,zero
8113577c:	0025883a 	mov	r18,zero
81135780:	003ecb06 	br	811352b0 <__reset+0xfb1152b0>
81135784:	00800434 	movhi	r2,16
81135788:	81400234 	orhi	r5,r16,8
8113578c:	10bfffc4 	addi	r2,r2,-1
81135790:	a007883a 	mov	r3,r20
81135794:	288a703a 	and	r5,r5,r2
81135798:	003f2206 	br	81135424 <__reset+0xfb115424>
8113579c:	183fca26 	beq	r3,zero,811356c8 <__reset+0xfb1156c8>
811357a0:	e5ef883a 	add	r23,fp,r23
811357a4:	40bfffc4 	addi	r2,r8,-1
811357a8:	bf00392e 	bgeu	r23,fp,81135890 <__divdf3+0x764>
811357ac:	1011883a 	mov	r8,r2
811357b0:	ba7fc41e 	bne	r23,r9,811356c4 <__reset+0xfb1156c4>
811357b4:	b0ffc31e 	bne	r22,r3,811356c4 <__reset+0xfb1156c4>
811357b8:	003fc306 	br	811356c8 <__reset+0xfb1156c8>
811357bc:	143ff604 	addi	r16,r2,-40
811357c0:	9c20983a 	sll	r16,r19,r16
811357c4:	0025883a 	mov	r18,zero
811357c8:	003ee206 	br	81135354 <__reset+0xfb115354>
811357cc:	d9800315 	stw	r6,12(sp)
811357d0:	d9c00215 	stw	r7,8(sp)
811357d4:	1120de40 	call	81120de4 <__clzsi2>
811357d8:	10800804 	addi	r2,r2,32
811357dc:	d9c00217 	ldw	r7,8(sp)
811357e0:	d9800317 	ldw	r6,12(sp)
811357e4:	003ed106 	br	8113532c <__reset+0xfb11532c>
811357e8:	147ff604 	addi	r17,r2,-40
811357ec:	3462983a 	sll	r17,r6,r17
811357f0:	0011883a 	mov	r8,zero
811357f4:	003ef506 	br	811353cc <__reset+0xfb1153cc>
811357f8:	3009883a 	mov	r4,r6
811357fc:	d9800315 	stw	r6,12(sp)
81135800:	da400115 	stw	r9,4(sp)
81135804:	1120de40 	call	81120de4 <__clzsi2>
81135808:	10800804 	addi	r2,r2,32
8113580c:	da400117 	ldw	r9,4(sp)
81135810:	d9800317 	ldw	r6,12(sp)
81135814:	003ee306 	br	811353a4 <__reset+0xfb1153a4>
81135818:	85a1883a 	add	r16,r16,r22
8113581c:	8585803a 	cmpltu	r2,r16,r22
81135820:	1705883a 	add	r2,r2,fp
81135824:	14a5883a 	add	r18,r2,r18
81135828:	88bfffc4 	addi	r2,r17,-1
8113582c:	e4800c2e 	bgeu	fp,r18,81135860 <__divdf3+0x734>
81135830:	90c03e36 	bltu	r18,r3,8113592c <__divdf3+0x800>
81135834:	1c806926 	beq	r3,r18,811359dc <__divdf3+0x8b0>
81135838:	90c7c83a 	sub	r3,r18,r3
8113583c:	1023883a 	mov	r17,r2
81135840:	003f5206 	br	8113558c <__reset+0xfb11558c>
81135844:	923f0436 	bltu	r18,r8,81135458 <__reset+0xfb115458>
81135848:	800897fa 	slli	r4,r16,31
8113584c:	9004d07a 	srli	r2,r18,1
81135850:	8006d07a 	srli	r3,r16,1
81135854:	902097fa 	slli	r16,r18,31
81135858:	20a4b03a 	or	r18,r4,r2
8113585c:	003f0106 	br	81135464 <__reset+0xfb115464>
81135860:	e4bff51e 	bne	fp,r18,81135838 <__reset+0xfb115838>
81135864:	85bff22e 	bgeu	r16,r22,81135830 <__reset+0xfb115830>
81135868:	e0c7c83a 	sub	r3,fp,r3
8113586c:	1023883a 	mov	r17,r2
81135870:	003f4606 	br	8113558c <__reset+0xfb11558c>
81135874:	100f883a 	mov	r7,r2
81135878:	003f2b06 	br	81135528 <__reset+0xfb115528>
8113587c:	180d883a 	mov	r6,r3
81135880:	003f1306 	br	811354d0 <__reset+0xfb1154d0>
81135884:	813fe436 	bltu	r16,r4,81135818 <__reset+0xfb115818>
81135888:	0007883a 	mov	r3,zero
8113588c:	003f3f06 	br	8113558c <__reset+0xfb11558c>
81135890:	ba402c36 	bltu	r23,r9,81135944 <__divdf3+0x818>
81135894:	4dc05426 	beq	r9,r23,811359e8 <__divdf3+0x8bc>
81135898:	1011883a 	mov	r8,r2
8113589c:	003f8906 	br	811356c4 <__reset+0xfb1156c4>
811358a0:	023fffc4 	movi	r8,-1
811358a4:	003f8806 	br	811356c8 <__reset+0xfb1156c8>
811358a8:	1811883a 	mov	r8,r3
811358ac:	003f5406 	br	81135600 <__reset+0xfb115600>
811358b0:	1025883a 	mov	r18,r2
811358b4:	003f6d06 	br	8113566c <__reset+0xfb11566c>
811358b8:	b827883a 	mov	r19,r23
811358bc:	003f8206 	br	811356c8 <__reset+0xfb1156c8>
811358c0:	010007c4 	movi	r4,31
811358c4:	20c02616 	blt	r4,r3,81135960 <__divdf3+0x834>
811358c8:	00800804 	movi	r2,32
811358cc:	10c5c83a 	sub	r2,r2,r3
811358d0:	888a983a 	sll	r5,r17,r2
811358d4:	40c8d83a 	srl	r4,r8,r3
811358d8:	4084983a 	sll	r2,r8,r2
811358dc:	88e2d83a 	srl	r17,r17,r3
811358e0:	2906b03a 	or	r3,r5,r4
811358e4:	1004c03a 	cmpne	r2,r2,zero
811358e8:	1886b03a 	or	r3,r3,r2
811358ec:	188001cc 	andi	r2,r3,7
811358f0:	10000726 	beq	r2,zero,81135910 <__divdf3+0x7e4>
811358f4:	188003cc 	andi	r2,r3,15
811358f8:	01000104 	movi	r4,4
811358fc:	11000426 	beq	r2,r4,81135910 <__divdf3+0x7e4>
81135900:	1805883a 	mov	r2,r3
81135904:	10c00104 	addi	r3,r2,4
81135908:	1885803a 	cmpltu	r2,r3,r2
8113590c:	88a3883a 	add	r17,r17,r2
81135910:	8880202c 	andhi	r2,r17,128
81135914:	10002726 	beq	r2,zero,811359b4 <__divdf3+0x888>
81135918:	98c0004c 	andi	r3,r19,1
8113591c:	00800044 	movi	r2,1
81135920:	000b883a 	mov	r5,zero
81135924:	0025883a 	mov	r18,zero
81135928:	003e6106 	br	811352b0 <__reset+0xfb1152b0>
8113592c:	85a1883a 	add	r16,r16,r22
81135930:	8585803a 	cmpltu	r2,r16,r22
81135934:	1705883a 	add	r2,r2,fp
81135938:	14a5883a 	add	r18,r2,r18
8113593c:	8c7fff84 	addi	r17,r17,-2
81135940:	003f1106 	br	81135588 <__reset+0xfb115588>
81135944:	b589883a 	add	r4,r22,r22
81135948:	25ad803a 	cmpltu	r22,r4,r22
8113594c:	b739883a 	add	fp,r22,fp
81135950:	40bfff84 	addi	r2,r8,-2
81135954:	bf2f883a 	add	r23,r23,fp
81135958:	202d883a 	mov	r22,r4
8113595c:	003f9306 	br	811357ac <__reset+0xfb1157ac>
81135960:	013ff844 	movi	r4,-31
81135964:	2085c83a 	sub	r2,r4,r2
81135968:	8888d83a 	srl	r4,r17,r2
8113596c:	00800804 	movi	r2,32
81135970:	18802126 	beq	r3,r2,811359f8 <__divdf3+0x8cc>
81135974:	00801004 	movi	r2,64
81135978:	10c5c83a 	sub	r2,r2,r3
8113597c:	8884983a 	sll	r2,r17,r2
81135980:	1204b03a 	or	r2,r2,r8
81135984:	1004c03a 	cmpne	r2,r2,zero
81135988:	2084b03a 	or	r2,r4,r2
8113598c:	144001cc 	andi	r17,r2,7
81135990:	88000d1e 	bne	r17,zero,811359c8 <__divdf3+0x89c>
81135994:	000b883a 	mov	r5,zero
81135998:	1024d0fa 	srli	r18,r2,3
8113599c:	98c0004c 	andi	r3,r19,1
811359a0:	0005883a 	mov	r2,zero
811359a4:	9464b03a 	or	r18,r18,r17
811359a8:	003e4106 	br	811352b0 <__reset+0xfb1152b0>
811359ac:	1007883a 	mov	r3,r2
811359b0:	0023883a 	mov	r17,zero
811359b4:	880a927a 	slli	r5,r17,9
811359b8:	1805883a 	mov	r2,r3
811359bc:	8822977a 	slli	r17,r17,29
811359c0:	280ad33a 	srli	r5,r5,12
811359c4:	003ff406 	br	81135998 <__reset+0xfb115998>
811359c8:	10c003cc 	andi	r3,r2,15
811359cc:	01000104 	movi	r4,4
811359d0:	193ff626 	beq	r3,r4,811359ac <__reset+0xfb1159ac>
811359d4:	0023883a 	mov	r17,zero
811359d8:	003fca06 	br	81135904 <__reset+0xfb115904>
811359dc:	813fd336 	bltu	r16,r4,8113592c <__reset+0xfb11592c>
811359e0:	1023883a 	mov	r17,r2
811359e4:	003fa806 	br	81135888 <__reset+0xfb115888>
811359e8:	b0ffd636 	bltu	r22,r3,81135944 <__reset+0xfb115944>
811359ec:	1011883a 	mov	r8,r2
811359f0:	b0ff341e 	bne	r22,r3,811356c4 <__reset+0xfb1156c4>
811359f4:	003f3406 	br	811356c8 <__reset+0xfb1156c8>
811359f8:	0005883a 	mov	r2,zero
811359fc:	003fe006 	br	81135980 <__reset+0xfb115980>
81135a00:	00800434 	movhi	r2,16
81135a04:	89400234 	orhi	r5,r17,8
81135a08:	10bfffc4 	addi	r2,r2,-1
81135a0c:	b807883a 	mov	r3,r23
81135a10:	288a703a 	and	r5,r5,r2
81135a14:	4025883a 	mov	r18,r8
81135a18:	003e8206 	br	81135424 <__reset+0xfb115424>

81135a1c <__eqdf2>:
81135a1c:	2804d53a 	srli	r2,r5,20
81135a20:	3806d53a 	srli	r3,r7,20
81135a24:	02000434 	movhi	r8,16
81135a28:	423fffc4 	addi	r8,r8,-1
81135a2c:	1081ffcc 	andi	r2,r2,2047
81135a30:	0281ffc4 	movi	r10,2047
81135a34:	2a12703a 	and	r9,r5,r8
81135a38:	18c1ffcc 	andi	r3,r3,2047
81135a3c:	3a10703a 	and	r8,r7,r8
81135a40:	280ad7fa 	srli	r5,r5,31
81135a44:	380ed7fa 	srli	r7,r7,31
81135a48:	12801026 	beq	r2,r10,81135a8c <__eqdf2+0x70>
81135a4c:	0281ffc4 	movi	r10,2047
81135a50:	1a800a26 	beq	r3,r10,81135a7c <__eqdf2+0x60>
81135a54:	10c00226 	beq	r2,r3,81135a60 <__eqdf2+0x44>
81135a58:	00800044 	movi	r2,1
81135a5c:	f800283a 	ret
81135a60:	4a3ffd1e 	bne	r9,r8,81135a58 <__reset+0xfb115a58>
81135a64:	21bffc1e 	bne	r4,r6,81135a58 <__reset+0xfb115a58>
81135a68:	29c00c26 	beq	r5,r7,81135a9c <__eqdf2+0x80>
81135a6c:	103ffa1e 	bne	r2,zero,81135a58 <__reset+0xfb115a58>
81135a70:	2244b03a 	or	r2,r4,r9
81135a74:	1004c03a 	cmpne	r2,r2,zero
81135a78:	f800283a 	ret
81135a7c:	3214b03a 	or	r10,r6,r8
81135a80:	503ff426 	beq	r10,zero,81135a54 <__reset+0xfb115a54>
81135a84:	00800044 	movi	r2,1
81135a88:	f800283a 	ret
81135a8c:	2254b03a 	or	r10,r4,r9
81135a90:	503fee26 	beq	r10,zero,81135a4c <__reset+0xfb115a4c>
81135a94:	00800044 	movi	r2,1
81135a98:	f800283a 	ret
81135a9c:	0005883a 	mov	r2,zero
81135aa0:	f800283a 	ret

81135aa4 <__ledf2>:
81135aa4:	2804d53a 	srli	r2,r5,20
81135aa8:	3810d53a 	srli	r8,r7,20
81135aac:	00c00434 	movhi	r3,16
81135ab0:	18ffffc4 	addi	r3,r3,-1
81135ab4:	1081ffcc 	andi	r2,r2,2047
81135ab8:	0241ffc4 	movi	r9,2047
81135abc:	28d4703a 	and	r10,r5,r3
81135ac0:	4201ffcc 	andi	r8,r8,2047
81135ac4:	38c6703a 	and	r3,r7,r3
81135ac8:	280ad7fa 	srli	r5,r5,31
81135acc:	380ed7fa 	srli	r7,r7,31
81135ad0:	12401f26 	beq	r2,r9,81135b50 <__ledf2+0xac>
81135ad4:	0241ffc4 	movi	r9,2047
81135ad8:	42401426 	beq	r8,r9,81135b2c <__ledf2+0x88>
81135adc:	1000091e 	bne	r2,zero,81135b04 <__ledf2+0x60>
81135ae0:	2296b03a 	or	r11,r4,r10
81135ae4:	5813003a 	cmpeq	r9,r11,zero
81135ae8:	29403fcc 	andi	r5,r5,255
81135aec:	40000a1e 	bne	r8,zero,81135b18 <__ledf2+0x74>
81135af0:	30d8b03a 	or	r12,r6,r3
81135af4:	6000081e 	bne	r12,zero,81135b18 <__ledf2+0x74>
81135af8:	0005883a 	mov	r2,zero
81135afc:	5800111e 	bne	r11,zero,81135b44 <__ledf2+0xa0>
81135b00:	f800283a 	ret
81135b04:	29403fcc 	andi	r5,r5,255
81135b08:	40000c1e 	bne	r8,zero,81135b3c <__ledf2+0x98>
81135b0c:	30d2b03a 	or	r9,r6,r3
81135b10:	48000c26 	beq	r9,zero,81135b44 <__ledf2+0xa0>
81135b14:	0013883a 	mov	r9,zero
81135b18:	39c03fcc 	andi	r7,r7,255
81135b1c:	48000826 	beq	r9,zero,81135b40 <__ledf2+0x9c>
81135b20:	38001126 	beq	r7,zero,81135b68 <__ledf2+0xc4>
81135b24:	00800044 	movi	r2,1
81135b28:	f800283a 	ret
81135b2c:	30d2b03a 	or	r9,r6,r3
81135b30:	483fea26 	beq	r9,zero,81135adc <__reset+0xfb115adc>
81135b34:	00800084 	movi	r2,2
81135b38:	f800283a 	ret
81135b3c:	39c03fcc 	andi	r7,r7,255
81135b40:	39400726 	beq	r7,r5,81135b60 <__ledf2+0xbc>
81135b44:	2800081e 	bne	r5,zero,81135b68 <__ledf2+0xc4>
81135b48:	00800044 	movi	r2,1
81135b4c:	f800283a 	ret
81135b50:	2292b03a 	or	r9,r4,r10
81135b54:	483fdf26 	beq	r9,zero,81135ad4 <__reset+0xfb115ad4>
81135b58:	00800084 	movi	r2,2
81135b5c:	f800283a 	ret
81135b60:	4080030e 	bge	r8,r2,81135b70 <__ledf2+0xcc>
81135b64:	383fef26 	beq	r7,zero,81135b24 <__reset+0xfb115b24>
81135b68:	00bfffc4 	movi	r2,-1
81135b6c:	f800283a 	ret
81135b70:	123feb16 	blt	r2,r8,81135b20 <__reset+0xfb115b20>
81135b74:	1abff336 	bltu	r3,r10,81135b44 <__reset+0xfb115b44>
81135b78:	50c00326 	beq	r10,r3,81135b88 <__ledf2+0xe4>
81135b7c:	50c0042e 	bgeu	r10,r3,81135b90 <__ledf2+0xec>
81135b80:	283fe81e 	bne	r5,zero,81135b24 <__reset+0xfb115b24>
81135b84:	003ff806 	br	81135b68 <__reset+0xfb115b68>
81135b88:	313fee36 	bltu	r6,r4,81135b44 <__reset+0xfb115b44>
81135b8c:	21bffc36 	bltu	r4,r6,81135b80 <__reset+0xfb115b80>
81135b90:	0005883a 	mov	r2,zero
81135b94:	f800283a 	ret

81135b98 <__floatunsidf>:
81135b98:	defffe04 	addi	sp,sp,-8
81135b9c:	de00012e 	bgeu	sp,et,81135ba4 <__floatunsidf+0xc>
81135ba0:	003b68fa 	trap	3
81135ba4:	dc000015 	stw	r16,0(sp)
81135ba8:	dfc00115 	stw	ra,4(sp)
81135bac:	2021883a 	mov	r16,r4
81135bb0:	20002226 	beq	r4,zero,81135c3c <__floatunsidf+0xa4>
81135bb4:	1120de40 	call	81120de4 <__clzsi2>
81135bb8:	01010784 	movi	r4,1054
81135bbc:	2089c83a 	sub	r4,r4,r2
81135bc0:	01810cc4 	movi	r6,1075
81135bc4:	310dc83a 	sub	r6,r6,r4
81135bc8:	00c007c4 	movi	r3,31
81135bcc:	1980120e 	bge	r3,r6,81135c18 <__floatunsidf+0x80>
81135bd0:	00c104c4 	movi	r3,1043
81135bd4:	1907c83a 	sub	r3,r3,r4
81135bd8:	80ca983a 	sll	r5,r16,r3
81135bdc:	00800434 	movhi	r2,16
81135be0:	10bfffc4 	addi	r2,r2,-1
81135be4:	2101ffcc 	andi	r4,r4,2047
81135be8:	0021883a 	mov	r16,zero
81135bec:	288a703a 	and	r5,r5,r2
81135bf0:	2008953a 	slli	r4,r4,20
81135bf4:	00c00434 	movhi	r3,16
81135bf8:	18ffffc4 	addi	r3,r3,-1
81135bfc:	28c6703a 	and	r3,r5,r3
81135c00:	8005883a 	mov	r2,r16
81135c04:	1906b03a 	or	r3,r3,r4
81135c08:	dfc00117 	ldw	ra,4(sp)
81135c0c:	dc000017 	ldw	r16,0(sp)
81135c10:	dec00204 	addi	sp,sp,8
81135c14:	f800283a 	ret
81135c18:	00c002c4 	movi	r3,11
81135c1c:	188bc83a 	sub	r5,r3,r2
81135c20:	814ad83a 	srl	r5,r16,r5
81135c24:	00c00434 	movhi	r3,16
81135c28:	18ffffc4 	addi	r3,r3,-1
81135c2c:	81a0983a 	sll	r16,r16,r6
81135c30:	2101ffcc 	andi	r4,r4,2047
81135c34:	28ca703a 	and	r5,r5,r3
81135c38:	003fed06 	br	81135bf0 <__reset+0xfb115bf0>
81135c3c:	0009883a 	mov	r4,zero
81135c40:	000b883a 	mov	r5,zero
81135c44:	003fea06 	br	81135bf0 <__reset+0xfb115bf0>

81135c48 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
81135c48:	defffb04 	addi	sp,sp,-20
81135c4c:	de00012e 	bgeu	sp,et,81135c54 <alt_busy_sleep+0xc>
81135c50:	003b68fa 	trap	3
81135c54:	df000415 	stw	fp,16(sp)
81135c58:	df000404 	addi	fp,sp,16
81135c5c:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
81135c60:	008000c4 	movi	r2,3
81135c64:	e0bffd15 	stw	r2,-12(fp)
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
81135c68:	e0fffd17 	ldw	r3,-12(fp)
81135c6c:	008003f4 	movhi	r2,15
81135c70:	10909004 	addi	r2,r2,16960
81135c74:	1887383a 	mul	r3,r3,r2
81135c78:	00817db4 	movhi	r2,1526
81135c7c:	10b84004 	addi	r2,r2,-7936
81135c80:	10c7203a 	divu	r3,r2,r3
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
81135c84:	00a00034 	movhi	r2,32768
81135c88:	10bfffc4 	addi	r2,r2,-1
81135c8c:	10c5203a 	divu	r2,r2,r3
81135c90:	e0ffff17 	ldw	r3,-4(fp)
81135c94:	1885203a 	divu	r2,r3,r2
81135c98:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
81135c9c:	e0bffe17 	ldw	r2,-8(fp)
81135ca0:	10002526 	beq	r2,zero,81135d38 <alt_busy_sleep+0xf0>
  {
    for(i=0;i<big_loops;i++)
81135ca4:	e03ffc15 	stw	zero,-16(fp)
81135ca8:	00001406 	br	81135cfc <alt_busy_sleep+0xb4>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
81135cac:	00a00034 	movhi	r2,32768
81135cb0:	10bfffc4 	addi	r2,r2,-1
81135cb4:	10bfffc4 	addi	r2,r2,-1
81135cb8:	103ffe1e 	bne	r2,zero,81135cb4 <__reset+0xfb115cb4>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
81135cbc:	e0fffd17 	ldw	r3,-12(fp)
81135cc0:	008003f4 	movhi	r2,15
81135cc4:	10909004 	addi	r2,r2,16960
81135cc8:	1887383a 	mul	r3,r3,r2
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
81135ccc:	00817db4 	movhi	r2,1526
81135cd0:	10b84004 	addi	r2,r2,-7936
81135cd4:	10c7203a 	divu	r3,r2,r3
81135cd8:	00a00034 	movhi	r2,32768
81135cdc:	10bfffc4 	addi	r2,r2,-1
81135ce0:	10c5203a 	divu	r2,r2,r3
81135ce4:	e0ffff17 	ldw	r3,-4(fp)
81135ce8:	1885c83a 	sub	r2,r3,r2
81135cec:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
81135cf0:	e0bffc17 	ldw	r2,-16(fp)
81135cf4:	10800044 	addi	r2,r2,1
81135cf8:	e0bffc15 	stw	r2,-16(fp)
81135cfc:	e0fffc17 	ldw	r3,-16(fp)
81135d00:	e0bffe17 	ldw	r2,-8(fp)
81135d04:	18bfe916 	blt	r3,r2,81135cac <__reset+0xfb115cac>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
81135d08:	e0fffd17 	ldw	r3,-12(fp)
81135d0c:	008003f4 	movhi	r2,15
81135d10:	10909004 	addi	r2,r2,16960
81135d14:	1887383a 	mul	r3,r3,r2
81135d18:	00817db4 	movhi	r2,1526
81135d1c:	10b84004 	addi	r2,r2,-7936
81135d20:	10c7203a 	divu	r3,r2,r3
81135d24:	e0bfff17 	ldw	r2,-4(fp)
81135d28:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
81135d2c:	10bfffc4 	addi	r2,r2,-1
81135d30:	103ffe1e 	bne	r2,zero,81135d2c <__reset+0xfb115d2c>
81135d34:	00000b06 	br	81135d64 <alt_busy_sleep+0x11c>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
81135d38:	e0fffd17 	ldw	r3,-12(fp)
81135d3c:	008003f4 	movhi	r2,15
81135d40:	10909004 	addi	r2,r2,16960
81135d44:	1887383a 	mul	r3,r3,r2
81135d48:	00817db4 	movhi	r2,1526
81135d4c:	10b84004 	addi	r2,r2,-7936
81135d50:	10c7203a 	divu	r3,r2,r3
81135d54:	e0bfff17 	ldw	r2,-4(fp)
81135d58:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
81135d5c:	10bfffc4 	addi	r2,r2,-1
81135d60:	00bffe16 	blt	zero,r2,81135d5c <__reset+0xfb115d5c>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
81135d64:	0005883a 	mov	r2,zero
}
81135d68:	e037883a 	mov	sp,fp
81135d6c:	df000017 	ldw	fp,0(sp)
81135d70:	dec00104 	addi	sp,sp,4
81135d74:	f800283a 	ret

81135d78 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81135d78:	defffe04 	addi	sp,sp,-8
81135d7c:	de00012e 	bgeu	sp,et,81135d84 <alt_get_errno+0xc>
81135d80:	003b68fa 	trap	3
81135d84:	dfc00115 	stw	ra,4(sp)
81135d88:	df000015 	stw	fp,0(sp)
81135d8c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81135d90:	d0a01017 	ldw	r2,-32704(gp)
81135d94:	10000326 	beq	r2,zero,81135da4 <alt_get_errno+0x2c>
81135d98:	d0a01017 	ldw	r2,-32704(gp)
81135d9c:	103ee83a 	callr	r2
81135da0:	00000106 	br	81135da8 <alt_get_errno+0x30>
81135da4:	d0a07804 	addi	r2,gp,-32288
}
81135da8:	e037883a 	mov	sp,fp
81135dac:	dfc00117 	ldw	ra,4(sp)
81135db0:	df000017 	ldw	fp,0(sp)
81135db4:	dec00204 	addi	sp,sp,8
81135db8:	f800283a 	ret

81135dbc <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
81135dbc:	defffb04 	addi	sp,sp,-20
81135dc0:	de00012e 	bgeu	sp,et,81135dc8 <close+0xc>
81135dc4:	003b68fa 	trap	3
81135dc8:	dfc00415 	stw	ra,16(sp)
81135dcc:	df000315 	stw	fp,12(sp)
81135dd0:	df000304 	addi	fp,sp,12
81135dd4:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
81135dd8:	e0bfff17 	ldw	r2,-4(fp)
81135ddc:	10000616 	blt	r2,zero,81135df8 <close+0x3c>
81135de0:	e0bfff17 	ldw	r2,-4(fp)
81135de4:	10c00324 	muli	r3,r2,12
81135de8:	00a04574 	movhi	r2,33045
81135dec:	1085c004 	addi	r2,r2,5888
81135df0:	1885883a 	add	r2,r3,r2
81135df4:	00000106 	br	81135dfc <close+0x40>
81135df8:	0005883a 	mov	r2,zero
81135dfc:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
81135e00:	e0bffd17 	ldw	r2,-12(fp)
81135e04:	10001926 	beq	r2,zero,81135e6c <close+0xb0>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
81135e08:	e0bffd17 	ldw	r2,-12(fp)
81135e0c:	10800017 	ldw	r2,0(r2)
81135e10:	10800417 	ldw	r2,16(r2)
81135e14:	10000626 	beq	r2,zero,81135e30 <close+0x74>
81135e18:	e0bffd17 	ldw	r2,-12(fp)
81135e1c:	10800017 	ldw	r2,0(r2)
81135e20:	10800417 	ldw	r2,16(r2)
81135e24:	e13ffd17 	ldw	r4,-12(fp)
81135e28:	103ee83a 	callr	r2
81135e2c:	00000106 	br	81135e34 <close+0x78>
81135e30:	0005883a 	mov	r2,zero
81135e34:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
81135e38:	e13fff17 	ldw	r4,-4(fp)
81135e3c:	11373a00 	call	811373a0 <alt_release_fd>
    if (rval < 0)
81135e40:	e0bffe17 	ldw	r2,-8(fp)
81135e44:	1000070e 	bge	r2,zero,81135e64 <close+0xa8>
    {
      ALT_ERRNO = -rval;
81135e48:	1135d780 	call	81135d78 <alt_get_errno>
81135e4c:	1007883a 	mov	r3,r2
81135e50:	e0bffe17 	ldw	r2,-8(fp)
81135e54:	0085c83a 	sub	r2,zero,r2
81135e58:	18800015 	stw	r2,0(r3)
      return -1;
81135e5c:	00bfffc4 	movi	r2,-1
81135e60:	00000706 	br	81135e80 <close+0xc4>
    }
    return 0;
81135e64:	0005883a 	mov	r2,zero
81135e68:	00000506 	br	81135e80 <close+0xc4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
81135e6c:	1135d780 	call	81135d78 <alt_get_errno>
81135e70:	1007883a 	mov	r3,r2
81135e74:	00801444 	movi	r2,81
81135e78:	18800015 	stw	r2,0(r3)
    return -1;
81135e7c:	00bfffc4 	movi	r2,-1
  }
}
81135e80:	e037883a 	mov	sp,fp
81135e84:	dfc00117 	ldw	ra,4(sp)
81135e88:	df000017 	ldw	fp,0(sp)
81135e8c:	dec00204 	addi	sp,sp,8
81135e90:	f800283a 	ret

81135e94 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
81135e94:	deffff04 	addi	sp,sp,-4
81135e98:	de00012e 	bgeu	sp,et,81135ea0 <alt_dcache_flush_all+0xc>
81135e9c:	003b68fa 	trap	3
81135ea0:	df000015 	stw	fp,0(sp)
81135ea4:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
81135ea8:	0001883a 	nop
81135eac:	e037883a 	mov	sp,fp
81135eb0:	df000017 	ldw	fp,0(sp)
81135eb4:	dec00104 	addi	sp,sp,4
81135eb8:	f800283a 	ret

81135ebc <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
81135ebc:	defffc04 	addi	sp,sp,-16
81135ec0:	de00012e 	bgeu	sp,et,81135ec8 <alt_dev_null_write+0xc>
81135ec4:	003b68fa 	trap	3
81135ec8:	df000315 	stw	fp,12(sp)
81135ecc:	df000304 	addi	fp,sp,12
81135ed0:	e13ffd15 	stw	r4,-12(fp)
81135ed4:	e17ffe15 	stw	r5,-8(fp)
81135ed8:	e1bfff15 	stw	r6,-4(fp)
  return len;
81135edc:	e0bfff17 	ldw	r2,-4(fp)
}
81135ee0:	e037883a 	mov	sp,fp
81135ee4:	df000017 	ldw	fp,0(sp)
81135ee8:	dec00104 	addi	sp,sp,4
81135eec:	f800283a 	ret

81135ef0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81135ef0:	defffe04 	addi	sp,sp,-8
81135ef4:	de00012e 	bgeu	sp,et,81135efc <alt_get_errno+0xc>
81135ef8:	003b68fa 	trap	3
81135efc:	dfc00115 	stw	ra,4(sp)
81135f00:	df000015 	stw	fp,0(sp)
81135f04:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81135f08:	d0a01017 	ldw	r2,-32704(gp)
81135f0c:	10000326 	beq	r2,zero,81135f1c <alt_get_errno+0x2c>
81135f10:	d0a01017 	ldw	r2,-32704(gp)
81135f14:	103ee83a 	callr	r2
81135f18:	00000106 	br	81135f20 <alt_get_errno+0x30>
81135f1c:	d0a07804 	addi	r2,gp,-32288
}
81135f20:	e037883a 	mov	sp,fp
81135f24:	dfc00117 	ldw	ra,4(sp)
81135f28:	df000017 	ldw	fp,0(sp)
81135f2c:	dec00204 	addi	sp,sp,8
81135f30:	f800283a 	ret

81135f34 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
81135f34:	defffb04 	addi	sp,sp,-20
81135f38:	de00012e 	bgeu	sp,et,81135f40 <fstat+0xc>
81135f3c:	003b68fa 	trap	3
81135f40:	dfc00415 	stw	ra,16(sp)
81135f44:	df000315 	stw	fp,12(sp)
81135f48:	df000304 	addi	fp,sp,12
81135f4c:	e13ffe15 	stw	r4,-8(fp)
81135f50:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81135f54:	e0bffe17 	ldw	r2,-8(fp)
81135f58:	10000616 	blt	r2,zero,81135f74 <fstat+0x40>
81135f5c:	e0bffe17 	ldw	r2,-8(fp)
81135f60:	10c00324 	muli	r3,r2,12
81135f64:	00a04574 	movhi	r2,33045
81135f68:	1085c004 	addi	r2,r2,5888
81135f6c:	1885883a 	add	r2,r3,r2
81135f70:	00000106 	br	81135f78 <fstat+0x44>
81135f74:	0005883a 	mov	r2,zero
81135f78:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
81135f7c:	e0bffd17 	ldw	r2,-12(fp)
81135f80:	10001026 	beq	r2,zero,81135fc4 <fstat+0x90>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
81135f84:	e0bffd17 	ldw	r2,-12(fp)
81135f88:	10800017 	ldw	r2,0(r2)
81135f8c:	10800817 	ldw	r2,32(r2)
81135f90:	10000726 	beq	r2,zero,81135fb0 <fstat+0x7c>
    {
      return fd->dev->fstat(fd, st);
81135f94:	e0bffd17 	ldw	r2,-12(fp)
81135f98:	10800017 	ldw	r2,0(r2)
81135f9c:	10800817 	ldw	r2,32(r2)
81135fa0:	e17fff17 	ldw	r5,-4(fp)
81135fa4:	e13ffd17 	ldw	r4,-12(fp)
81135fa8:	103ee83a 	callr	r2
81135fac:	00000a06 	br	81135fd8 <fstat+0xa4>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
81135fb0:	e0bfff17 	ldw	r2,-4(fp)
81135fb4:	00c80004 	movi	r3,8192
81135fb8:	10c00115 	stw	r3,4(r2)
      return 0;
81135fbc:	0005883a 	mov	r2,zero
81135fc0:	00000506 	br	81135fd8 <fstat+0xa4>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
81135fc4:	1135ef00 	call	81135ef0 <alt_get_errno>
81135fc8:	1007883a 	mov	r3,r2
81135fcc:	00801444 	movi	r2,81
81135fd0:	18800015 	stw	r2,0(r3)
    return -1;
81135fd4:	00bfffc4 	movi	r2,-1
  }
}
81135fd8:	e037883a 	mov	sp,fp
81135fdc:	dfc00117 	ldw	ra,4(sp)
81135fe0:	df000017 	ldw	fp,0(sp)
81135fe4:	dec00204 	addi	sp,sp,8
81135fe8:	f800283a 	ret

81135fec <alt_irq_register>:
 */
 
int alt_irq_register (alt_u32 id, 
                      void* context, 
                      alt_isr_func handler)
{
81135fec:	defff004 	addi	sp,sp,-64
81135ff0:	de00012e 	bgeu	sp,et,81135ff8 <alt_irq_register+0xc>
81135ff4:	003b68fa 	trap	3
81135ff8:	df000f15 	stw	fp,60(sp)
81135ffc:	df000f04 	addi	fp,sp,60
81136000:	e13ffd15 	stw	r4,-12(fp)
81136004:	e17ffe15 	stw	r5,-8(fp)
81136008:	e1bfff15 	stw	r6,-4(fp)
  int rc = -EINVAL;  
8113600c:	00bffa84 	movi	r2,-22
81136010:	e0bff115 	stw	r2,-60(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
81136014:	e0bffd17 	ldw	r2,-12(fp)
81136018:	10800828 	cmpgeui	r2,r2,32
8113601c:	1000501e 	bne	r2,zero,81136160 <alt_irq_register+0x174>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136020:	0005303a 	rdctl	r2,status
81136024:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136028:	e0fff617 	ldw	r3,-40(fp)
8113602c:	00bfff84 	movi	r2,-2
81136030:	1884703a 	and	r2,r3,r2
81136034:	1001703a 	wrctl	status,r2
  
  return context;
81136038:	e0bff617 	ldw	r2,-40(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all ();
8113603c:	e0bff315 	stw	r2,-52(fp)

    alt_irq[id].handler = handler;
81136040:	00a045f4 	movhi	r2,33047
81136044:	10b36304 	addi	r2,r2,-12916
81136048:	e0fffd17 	ldw	r3,-12(fp)
8113604c:	180690fa 	slli	r3,r3,3
81136050:	10c5883a 	add	r2,r2,r3
81136054:	e0ffff17 	ldw	r3,-4(fp)
81136058:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = context;
8113605c:	00a045f4 	movhi	r2,33047
81136060:	10b36304 	addi	r2,r2,-12916
81136064:	e0fffd17 	ldw	r3,-12(fp)
81136068:	180690fa 	slli	r3,r3,3
8113606c:	10c5883a 	add	r2,r2,r3
81136070:	10800104 	addi	r2,r2,4
81136074:	e0fffe17 	ldw	r3,-8(fp)
81136078:	10c00015 	stw	r3,0(r2)

    rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
8113607c:	e0bfff17 	ldw	r2,-4(fp)
81136080:	10001926 	beq	r2,zero,811360e8 <alt_irq_register+0xfc>
81136084:	e0bffd17 	ldw	r2,-12(fp)
81136088:	e0bff215 	stw	r2,-56(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113608c:	0005303a 	rdctl	r2,status
81136090:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136094:	e0fff717 	ldw	r3,-36(fp)
81136098:	00bfff84 	movi	r2,-2
8113609c:	1884703a 	and	r2,r3,r2
811360a0:	1001703a 	wrctl	status,r2
  
  return context;
811360a4:	e0bff717 	ldw	r2,-36(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
811360a8:	e0bff815 	stw	r2,-32(fp)

  alt_irq_active |= (1 << id);
811360ac:	00c00044 	movi	r3,1
811360b0:	e0bff217 	ldw	r2,-56(fp)
811360b4:	1884983a 	sll	r2,r3,r2
811360b8:	1007883a 	mov	r3,r2
811360bc:	d0a08017 	ldw	r2,-32256(gp)
811360c0:	1884b03a 	or	r2,r3,r2
811360c4:	d0a08015 	stw	r2,-32256(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
811360c8:	d0a08017 	ldw	r2,-32256(gp)
811360cc:	100170fa 	wrctl	ienable,r2
811360d0:	e0bff817 	ldw	r2,-32(fp)
811360d4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811360d8:	e0bff917 	ldw	r2,-28(fp)
811360dc:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
811360e0:	0005883a 	mov	r2,zero
811360e4:	00001906 	br	8113614c <alt_irq_register+0x160>
811360e8:	e0bffd17 	ldw	r2,-12(fp)
811360ec:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811360f0:	0005303a 	rdctl	r2,status
811360f4:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811360f8:	e0fffa17 	ldw	r3,-24(fp)
811360fc:	00bfff84 	movi	r2,-2
81136100:	1884703a 	and	r2,r3,r2
81136104:	1001703a 	wrctl	status,r2
  
  return context;
81136108:	e0bffa17 	ldw	r2,-24(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
8113610c:	e0bffb15 	stw	r2,-20(fp)

  alt_irq_active &= ~(1 << id);
81136110:	00c00044 	movi	r3,1
81136114:	e0bff417 	ldw	r2,-48(fp)
81136118:	1884983a 	sll	r2,r3,r2
8113611c:	0084303a 	nor	r2,zero,r2
81136120:	1007883a 	mov	r3,r2
81136124:	d0a08017 	ldw	r2,-32256(gp)
81136128:	1884703a 	and	r2,r3,r2
8113612c:	d0a08015 	stw	r2,-32256(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
81136130:	d0a08017 	ldw	r2,-32256(gp)
81136134:	100170fa 	wrctl	ienable,r2
81136138:	e0bffb17 	ldw	r2,-20(fp)
8113613c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136140:	e0bffc17 	ldw	r2,-16(fp)
81136144:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
81136148:	0005883a 	mov	r2,zero
8113614c:	e0bff115 	stw	r2,-60(fp)
81136150:	e0bff317 	ldw	r2,-52(fp)
81136154:	e0bff515 	stw	r2,-44(fp)
81136158:	e0bff517 	ldw	r2,-44(fp)
8113615c:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }
  return rc; 
81136160:	e0bff117 	ldw	r2,-60(fp)
}
81136164:	e037883a 	mov	sp,fp
81136168:	df000017 	ldw	fp,0(sp)
8113616c:	dec00104 	addi	sp,sp,4
81136170:	f800283a 	ret

81136174 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81136174:	defffe04 	addi	sp,sp,-8
81136178:	de00012e 	bgeu	sp,et,81136180 <alt_get_errno+0xc>
8113617c:	003b68fa 	trap	3
81136180:	dfc00115 	stw	ra,4(sp)
81136184:	df000015 	stw	fp,0(sp)
81136188:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8113618c:	d0a01017 	ldw	r2,-32704(gp)
81136190:	10000326 	beq	r2,zero,811361a0 <alt_get_errno+0x2c>
81136194:	d0a01017 	ldw	r2,-32704(gp)
81136198:	103ee83a 	callr	r2
8113619c:	00000106 	br	811361a4 <alt_get_errno+0x30>
811361a0:	d0a07804 	addi	r2,gp,-32288
}
811361a4:	e037883a 	mov	sp,fp
811361a8:	dfc00117 	ldw	ra,4(sp)
811361ac:	df000017 	ldw	fp,0(sp)
811361b0:	dec00204 	addi	sp,sp,8
811361b4:	f800283a 	ret

811361b8 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
811361b8:	deffed04 	addi	sp,sp,-76
811361bc:	de00012e 	bgeu	sp,et,811361c4 <isatty+0xc>
811361c0:	003b68fa 	trap	3
811361c4:	dfc01215 	stw	ra,72(sp)
811361c8:	df001115 	stw	fp,68(sp)
811361cc:	df001104 	addi	fp,sp,68
811361d0:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
811361d4:	e0bfff17 	ldw	r2,-4(fp)
811361d8:	10000616 	blt	r2,zero,811361f4 <isatty+0x3c>
811361dc:	e0bfff17 	ldw	r2,-4(fp)
811361e0:	10c00324 	muli	r3,r2,12
811361e4:	00a04574 	movhi	r2,33045
811361e8:	1085c004 	addi	r2,r2,5888
811361ec:	1885883a 	add	r2,r3,r2
811361f0:	00000106 	br	811361f8 <isatty+0x40>
811361f4:	0005883a 	mov	r2,zero
811361f8:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
811361fc:	e0bfef17 	ldw	r2,-68(fp)
81136200:	10000e26 	beq	r2,zero,8113623c <isatty+0x84>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
81136204:	e0bfef17 	ldw	r2,-68(fp)
81136208:	10800017 	ldw	r2,0(r2)
8113620c:	10800817 	ldw	r2,32(r2)
81136210:	1000021e 	bne	r2,zero,8113621c <isatty+0x64>
    {
      return 1;
81136214:	00800044 	movi	r2,1
81136218:	00000d06 	br	81136250 <isatty+0x98>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
8113621c:	e0bff004 	addi	r2,fp,-64
81136220:	100b883a 	mov	r5,r2
81136224:	e13fff17 	ldw	r4,-4(fp)
81136228:	1135f340 	call	81135f34 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
8113622c:	e0bff117 	ldw	r2,-60(fp)
81136230:	10880020 	cmpeqi	r2,r2,8192
81136234:	10803fcc 	andi	r2,r2,255
81136238:	00000506 	br	81136250 <isatty+0x98>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
8113623c:	11361740 	call	81136174 <alt_get_errno>
81136240:	1007883a 	mov	r3,r2
81136244:	00801444 	movi	r2,81
81136248:	18800015 	stw	r2,0(r3)
    return 0;
8113624c:	0005883a 	mov	r2,zero
  }
}
81136250:	e037883a 	mov	sp,fp
81136254:	dfc00117 	ldw	ra,4(sp)
81136258:	df000017 	ldw	fp,0(sp)
8113625c:	dec00204 	addi	sp,sp,8
81136260:	f800283a 	ret

81136264 <tx_log_str>:
	#include "sys/alt_log_printf.h"

        .global tx_log_str
tx_log_str:
	/* load base uart / jtag uart address into r6 */
	movhi r6, %hiadj(ALT_LOG_PORT_BASE)
81136264:	01a04834 	movhi	r6,33056
	addi r6, r6, %lo(ALT_LOG_PORT_BASE)
81136268:	318c2404 	addi	r6,r6,12432

8113626c <tx_next_char>:
tx_next_char:
        /* if pointer points to null, return 
         * r4 is the pointer to the str to be printed, set by ALT_LOG_PUTS */
	ldb r7, (r4)
8113626c:	21c00007 	ldb	r7,0(r4)
	beq r0, r7, end_tx
81136270:	01c00826 	beq	zero,r7,81136294 <end_tx>

81136274 <wait_tx_ready_loop>:

	/* check device transmit ready  */
wait_tx_ready_loop:
        ldwio   r8, ALT_LOG_PRINT_REG_OFFSET(r6)
81136274:	32000137 	ldwio	r8,4(r6)
        /*UART, ALT_LOG_PRINT_MSK == 0x40
          JTAG UART, ALT_LOG_PRINT_MSK == 0xFFFF0000 */
        andhi   r5, r8, %hi(ALT_LOG_PRINT_MSK)
81136278:	417fffec 	andhi	r5,r8,65535
        andi    r8, r8, %lo(ALT_LOG_PRINT_MSK)
8113627c:	4200000c 	andi	r8,r8,0
        or      r5, r5, r8
81136280:	2a0ab03a 	or	r5,r5,r8
        beq     r5, r0, wait_tx_ready_loop	
81136284:	283ffb26 	beq	r5,zero,81136274 <__reset+0xfb116274>
	/* write char */
	stwio   r7, ALT_LOG_PRINT_TXDATA_REG_OFFSET (r6)		
81136288:	31c00035 	stwio	r7,0(r6)
	/* advance string pointer */
	addi r4, r4, 1
8113628c:	21000044 	addi	r4,r4,1
	br tx_next_char
81136290:	003ff606 	br	8113626c <__reset+0xfb11626c>

81136294 <end_tx>:
end_tx:	
        ret
81136294:	f800283a 	ret

81136298 <alt_log_txchar>:



/* Function to put one char onto the UART/JTAG UART txdata register. */
void alt_log_txchar(int c,char *base)
{
81136298:	defffd04 	addi	sp,sp,-12
8113629c:	de00012e 	bgeu	sp,et,811362a4 <alt_log_txchar+0xc>
811362a0:	003b68fa 	trap	3
811362a4:	df000215 	stw	fp,8(sp)
811362a8:	df000204 	addi	fp,sp,8
811362ac:	e13ffe15 	stw	r4,-8(fp)
811362b0:	e17fff15 	stw	r5,-4(fp)
  /* Wait until the device is ready for a character */
  while((ALT_LOG_PRINT_REG_RD(base) & ALT_LOG_PRINT_MSK) == 0)
811362b4:	0001883a 	nop
811362b8:	e0bfff17 	ldw	r2,-4(fp)
811362bc:	10800104 	addi	r2,r2,4
811362c0:	10800037 	ldwio	r2,0(r2)
811362c4:	10bfffec 	andhi	r2,r2,65535
811362c8:	103ffb26 	beq	r2,zero,811362b8 <__reset+0xfb1162b8>
    ;
  /* And pop the character into the register */
  ALT_LOG_PRINT_TXDATA_WR(base,c);
811362cc:	e0bfff17 	ldw	r2,-4(fp)
811362d0:	e0fffe17 	ldw	r3,-8(fp)
811362d4:	10c00035 	stwio	r3,0(r2)
}
811362d8:	0001883a 	nop
811362dc:	e037883a 	mov	sp,fp
811362e0:	df000017 	ldw	fp,0(sp)
811362e4:	dec00104 	addi	sp,sp,4
811362e8:	f800283a 	ret

811362ec <alt_log_repchar>:


/* Called by alt_log_private_printf to print out characters repeatedly */
void alt_log_repchar(char c,int r,int base)
{
811362ec:	defffb04 	addi	sp,sp,-20
811362f0:	de00012e 	bgeu	sp,et,811362f8 <alt_log_repchar+0xc>
811362f4:	003b68fa 	trap	3
811362f8:	dfc00415 	stw	ra,16(sp)
811362fc:	df000315 	stw	fp,12(sp)
81136300:	df000304 	addi	fp,sp,12
81136304:	2005883a 	mov	r2,r4
81136308:	e17ffe15 	stw	r5,-8(fp)
8113630c:	e1bfff15 	stw	r6,-4(fp)
81136310:	e0bffd05 	stb	r2,-12(fp)
  while(r-- > 0)
81136314:	00000506 	br	8113632c <alt_log_repchar+0x40>
    alt_log_txchar(c,(char*) base);
81136318:	e0bffd07 	ldb	r2,-12(fp)
8113631c:	e0ffff17 	ldw	r3,-4(fp)
81136320:	180b883a 	mov	r5,r3
81136324:	1009883a 	mov	r4,r2
81136328:	11362980 	call	81136298 <alt_log_txchar>


/* Called by alt_log_private_printf to print out characters repeatedly */
void alt_log_repchar(char c,int r,int base)
{
  while(r-- > 0)
8113632c:	e0bffe17 	ldw	r2,-8(fp)
81136330:	10ffffc4 	addi	r3,r2,-1
81136334:	e0fffe15 	stw	r3,-8(fp)
81136338:	00bff716 	blt	zero,r2,81136318 <__reset+0xfb116318>
    alt_log_txchar(c,(char*) base);
}
8113633c:	0001883a 	nop
81136340:	e037883a 	mov	sp,fp
81136344:	dfc00117 	ldw	ra,4(sp)
81136348:	df000017 	ldw	fp,0(sp)
8113634c:	dec00204 	addi	sp,sp,8
81136350:	f800283a 	ret

81136354 <alt_log_private_printf>:


/* Stripped down printf function */
void alt_log_private_printf(const char *fmt,int base,va_list args)
  {
81136354:	deffe904 	addi	sp,sp,-92
81136358:	de00012e 	bgeu	sp,et,81136360 <alt_log_private_printf+0xc>
8113635c:	003b68fa 	trap	3
81136360:	dfc01615 	stw	ra,88(sp)
81136364:	df001515 	stw	fp,84(sp)
81136368:	dc001415 	stw	r16,80(sp)
8113636c:	df001504 	addi	fp,sp,84
81136370:	e13ffc15 	stw	r4,-16(fp)
81136374:	e17ffd15 	stw	r5,-12(fp)
81136378:	e1bffe15 	stw	r6,-8(fp)
  const char *w;
  char c;
  int state;
  int fmtLeadingZero = 0; /* init these all to 0 for -W warnings. */
8113637c:	e03fed15 	stw	zero,-76(fp)
  int fmtLong = 0;
81136380:	e03fee15 	stw	zero,-72(fp)
  int fmtBeforeDecimal = 0;
81136384:	e03fef15 	stw	zero,-68(fp)
  int fmtAfterDecimal = 0;
81136388:	e03ff015 	stw	zero,-64(fp)
  int fmtBase = 0;
8113638c:	e03ff115 	stw	zero,-60(fp)
  int fmtSigned = 0;
81136390:	e03ff215 	stw	zero,-56(fp)
  int fmtCase = 0; /* For hex format, if 1, A-F, else a-f. */
81136394:	e03ff315 	stw	zero,-52(fp)

  w = fmt;
81136398:	e0bffc17 	ldw	r2,-16(fp)
8113639c:	e0bfeb15 	stw	r2,-84(fp)
  state = pfState_chars;
811363a0:	e03fec15 	stw	zero,-80(fp)

  while(0 != (c = *w++))
811363a4:	00014b06 	br	811368d4 <alt_log_private_printf+0x580>
    {
    switch(state)
811363a8:	e0bfec17 	ldw	r2,-80(fp)
811363ac:	10c00060 	cmpeqi	r3,r2,1
811363b0:	18001b1e 	bne	r3,zero,81136420 <alt_log_private_printf+0xcc>
811363b4:	10c000a0 	cmpeqi	r3,r2,2
811363b8:	18002d1e 	bne	r3,zero,81136470 <alt_log_private_printf+0x11c>
811363bc:	10000126 	beq	r2,zero,811363c4 <alt_log_private_printf+0x70>
811363c0:	00014406 	br	811368d4 <alt_log_private_printf+0x580>
      {
      case pfState_chars:
        if(c == '%')
811363c4:	e0bffb07 	ldb	r2,-20(fp)
811363c8:	10800958 	cmpnei	r2,r2,37
811363cc:	10000e1e 	bne	r2,zero,81136408 <alt_log_private_printf+0xb4>
        {
          fmtLeadingZero = 0;
811363d0:	e03fed15 	stw	zero,-76(fp)
          fmtLong = 0;
811363d4:	e03fee15 	stw	zero,-72(fp)
          fmtBase = 10;
811363d8:	00800284 	movi	r2,10
811363dc:	e0bff115 	stw	r2,-60(fp)
          fmtSigned = 1;
811363e0:	00800044 	movi	r2,1
811363e4:	e0bff215 	stw	r2,-56(fp)
          fmtCase = 0; /* Only %X sets this. */
811363e8:	e03ff315 	stw	zero,-52(fp)
          fmtBeforeDecimal = -1;
811363ec:	00bfffc4 	movi	r2,-1
811363f0:	e0bfef15 	stw	r2,-68(fp)
          fmtAfterDecimal = -1;
811363f4:	00bfffc4 	movi	r2,-1
811363f8:	e0bff015 	stw	r2,-64(fp)
          state = pfState_firstFmtChar;
811363fc:	00800044 	movi	r2,1
81136400:	e0bfec15 	stw	r2,-80(fp)
81136404:	00013306 	br	811368d4 <alt_log_private_printf+0x580>
        }
        else
        {
          alt_log_txchar(c,(char*)base);
81136408:	e0bffb07 	ldb	r2,-20(fp)
8113640c:	e0fffd17 	ldw	r3,-12(fp)
81136410:	180b883a 	mov	r5,r3
81136414:	1009883a 	mov	r4,r2
81136418:	11362980 	call	81136298 <alt_log_txchar>
        }
        break;
8113641c:	00012d06 	br	811368d4 <alt_log_private_printf+0x580>

      case pfState_firstFmtChar:
        if(c == '0')
81136420:	e0bffb07 	ldb	r2,-20(fp)
81136424:	10800c18 	cmpnei	r2,r2,48
81136428:	1000051e 	bne	r2,zero,81136440 <alt_log_private_printf+0xec>
        {
          fmtLeadingZero = 1;
8113642c:	00800044 	movi	r2,1
81136430:	e0bfed15 	stw	r2,-76(fp)
          state = pfState_otherFmtChar;
81136434:	00800084 	movi	r2,2
81136438:	e0bfec15 	stw	r2,-80(fp)
8113643c:	00012506 	br	811368d4 <alt_log_private_printf+0x580>
        }
        else if(c == '%')
81136440:	e0bffb07 	ldb	r2,-20(fp)
81136444:	10800958 	cmpnei	r2,r2,37
81136448:	1000071e 	bne	r2,zero,81136468 <alt_log_private_printf+0x114>
        {
          alt_log_txchar(c,(char*)base);
8113644c:	e0bffb07 	ldb	r2,-20(fp)
81136450:	e0fffd17 	ldw	r3,-12(fp)
81136454:	180b883a 	mov	r5,r3
81136458:	1009883a 	mov	r4,r2
8113645c:	11362980 	call	81136298 <alt_log_txchar>
          state = pfState_chars;
81136460:	e03fec15 	stw	zero,-80(fp)
81136464:	00011b06 	br	811368d4 <alt_log_private_printf+0x580>
        }
        else
        {
          state = pfState_otherFmtChar;
81136468:	00800084 	movi	r2,2
8113646c:	e0bfec15 	stw	r2,-80(fp)
        }
        break;

      case pfState_otherFmtChar:
otherFmtChar:
        if(c == '.')
81136470:	e0bffb07 	ldb	r2,-20(fp)
81136474:	10800b98 	cmpnei	r2,r2,46
81136478:	1000021e 	bne	r2,zero,81136484 <alt_log_private_printf+0x130>
        {
          fmtAfterDecimal = 0;
8113647c:	e03ff015 	stw	zero,-64(fp)
81136480:	00011306 	br	811368d0 <alt_log_private_printf+0x57c>
        }
        else if('0' <= c && c <= '9')
81136484:	e0bffb07 	ldb	r2,-20(fp)
81136488:	10800c10 	cmplti	r2,r2,48
8113648c:	10001a1e 	bne	r2,zero,811364f8 <alt_log_private_printf+0x1a4>
81136490:	e0bffb07 	ldb	r2,-20(fp)
81136494:	10800e88 	cmpgei	r2,r2,58
81136498:	1000171e 	bne	r2,zero,811364f8 <alt_log_private_printf+0x1a4>
        {
          c -= '0';
8113649c:	e0bffb03 	ldbu	r2,-20(fp)
811364a0:	10bff404 	addi	r2,r2,-48
811364a4:	e0bffb05 	stb	r2,-20(fp)
          if(fmtAfterDecimal < 0)     /* still before decimal */
811364a8:	e0bff017 	ldw	r2,-64(fp)
811364ac:	10000c0e 	bge	r2,zero,811364e0 <alt_log_private_printf+0x18c>
          {
            if(fmtBeforeDecimal < 0)
811364b0:	e0bfef17 	ldw	r2,-68(fp)
811364b4:	1000020e 	bge	r2,zero,811364c0 <alt_log_private_printf+0x16c>
            {
              fmtBeforeDecimal = 0;
811364b8:	e03fef15 	stw	zero,-68(fp)
811364bc:	00000306 	br	811364cc <alt_log_private_printf+0x178>
            }
            else
            {
              fmtBeforeDecimal *= 10;
811364c0:	e0bfef17 	ldw	r2,-68(fp)
811364c4:	108002a4 	muli	r2,r2,10
811364c8:	e0bfef15 	stw	r2,-68(fp)
            }
            fmtBeforeDecimal += c;
811364cc:	e0bffb07 	ldb	r2,-20(fp)
811364d0:	e0ffef17 	ldw	r3,-68(fp)
811364d4:	1885883a 	add	r2,r3,r2
811364d8:	e0bfef15 	stw	r2,-68(fp)
          fmtAfterDecimal = 0;
        }
        else if('0' <= c && c <= '9')
        {
          c -= '0';
          if(fmtAfterDecimal < 0)     /* still before decimal */
811364dc:	0000fc06 	br	811368d0 <alt_log_private_printf+0x57c>
            }
            fmtBeforeDecimal += c;
          }
          else
          {
            fmtAfterDecimal = (fmtAfterDecimal * 10) + c;
811364e0:	e0bff017 	ldw	r2,-64(fp)
811364e4:	10c002a4 	muli	r3,r2,10
811364e8:	e0bffb07 	ldb	r2,-20(fp)
811364ec:	1885883a 	add	r2,r3,r2
811364f0:	e0bff015 	stw	r2,-64(fp)
          fmtAfterDecimal = 0;
        }
        else if('0' <= c && c <= '9')
        {
          c -= '0';
          if(fmtAfterDecimal < 0)     /* still before decimal */
811364f4:	0000f606 	br	811368d0 <alt_log_private_printf+0x57c>
          else
          {
            fmtAfterDecimal = (fmtAfterDecimal * 10) + c;
          }
        }
        else if(c == 'l')
811364f8:	e0bffb07 	ldb	r2,-20(fp)
811364fc:	10801b18 	cmpnei	r2,r2,108
81136500:	1000031e 	bne	r2,zero,81136510 <alt_log_private_printf+0x1bc>
        {
          fmtLong = 1;
81136504:	00800044 	movi	r2,1
81136508:	e0bfee15 	stw	r2,-72(fp)
8113650c:	0000f006 	br	811368d0 <alt_log_private_printf+0x57c>
        }
        else                  /* we're up to the letter which determines type */
        {
          switch(c)
81136510:	e0bffb07 	ldb	r2,-20(fp)
81136514:	10bfea04 	addi	r2,r2,-88
81136518:	10c00868 	cmpgeui	r3,r2,33
8113651c:	1800eb1e 	bne	r3,zero,811368cc <alt_log_private_printf+0x578>
81136520:	100690ba 	slli	r3,r2,2
81136524:	00a044f4 	movhi	r2,33043
81136528:	10994e04 	addi	r2,r2,25912
8113652c:	1885883a 	add	r2,r3,r2
81136530:	10800017 	ldw	r2,0(r2)
81136534:	1000683a 	jmp	r2
81136538:	811367f8 	rdprs	r4,r16,19871
8113653c:	811368cc 	andi	r4,r16,19875
81136540:	811368cc 	andi	r4,r16,19875
81136544:	811368cc 	andi	r4,r16,19875
81136548:	811368cc 	andi	r4,r16,19875
8113654c:	811368cc 	andi	r4,r16,19875
81136550:	811368cc 	andi	r4,r16,19875
81136554:	811368cc 	andi	r4,r16,19875
81136558:	811368cc 	andi	r4,r16,19875
8113655c:	811368cc 	andi	r4,r16,19875
81136560:	811368cc 	andi	r4,r16,19875
81136564:	81136810 	cmplti	r4,r16,19872
81136568:	811365bc 	xorhi	r4,r16,19862
8113656c:	811368cc 	andi	r4,r16,19875
81136570:	811368cc 	andi	r4,r16,19875
81136574:	811368cc 	andi	r4,r16,19875
81136578:	811368cc 	andi	r4,r16,19875
8113657c:	811365bc 	xorhi	r4,r16,19862
81136580:	811368cc 	andi	r4,r16,19875
81136584:	811368cc 	andi	r4,r16,19875
81136588:	811368cc 	andi	r4,r16,19875
8113658c:	811368cc 	andi	r4,r16,19875
81136590:	811368cc 	andi	r4,r16,19875
81136594:	811367d8 	cmpnei	r4,r16,19871
81136598:	811368cc 	andi	r4,r16,19875
8113659c:	811368cc 	andi	r4,r16,19875
811365a0:	811368cc 	andi	r4,r16,19875
811365a4:	8113684c 	andi	r4,r16,19873
811365a8:	811368cc 	andi	r4,r16,19875
811365ac:	811367d0 	cmplti	r4,r16,19871
811365b0:	811368cc 	andi	r4,r16,19875
811365b4:	811368cc 	andi	r4,r16,19875
811365b8:	811367e8 	cmpgeui	r4,r16,19871
                unsigned long vShrink;  /* used to count digits */
                int sign;
                int digitCount;

                /* Get the value */
                if(fmtLong)
811365bc:	e0bfee17 	ldw	r2,-72(fp)
811365c0:	10000e26 	beq	r2,zero,811365fc <alt_log_private_printf+0x2a8>
                {
                  if (fmtSigned)
811365c4:	e0bff217 	ldw	r2,-56(fp)
811365c8:	10000626 	beq	r2,zero,811365e4 <alt_log_private_printf+0x290>
                  {
                    v = va_arg(args,long);
811365cc:	e0bffe17 	ldw	r2,-8(fp)
811365d0:	10c00104 	addi	r3,r2,4
811365d4:	e0fffe15 	stw	r3,-8(fp)
811365d8:	10800017 	ldw	r2,0(r2)
811365dc:	e0bff415 	stw	r2,-48(fp)
811365e0:	00001306 	br	81136630 <alt_log_private_printf+0x2dc>
                  }
                  else
                  {
                    v = va_arg(args,unsigned long);
811365e4:	e0bffe17 	ldw	r2,-8(fp)
811365e8:	10c00104 	addi	r3,r2,4
811365ec:	e0fffe15 	stw	r3,-8(fp)
811365f0:	10800017 	ldw	r2,0(r2)
811365f4:	e0bff415 	stw	r2,-48(fp)
811365f8:	00000d06 	br	81136630 <alt_log_private_printf+0x2dc>
                  }
                }
                else
                {
                  if (fmtSigned)
811365fc:	e0bff217 	ldw	r2,-56(fp)
81136600:	10000626 	beq	r2,zero,8113661c <alt_log_private_printf+0x2c8>
                  {
                    v = va_arg(args,int);
81136604:	e0bffe17 	ldw	r2,-8(fp)
81136608:	10c00104 	addi	r3,r2,4
8113660c:	e0fffe15 	stw	r3,-8(fp)
81136610:	10800017 	ldw	r2,0(r2)
81136614:	e0bff415 	stw	r2,-48(fp)
81136618:	00000506 	br	81136630 <alt_log_private_printf+0x2dc>
                  }
                  else
                  {
                    v = va_arg(args,unsigned int);
8113661c:	e0bffe17 	ldw	r2,-8(fp)
81136620:	10c00104 	addi	r3,r2,4
81136624:	e0fffe15 	stw	r3,-8(fp)
81136628:	10800017 	ldw	r2,0(r2)
8113662c:	e0bff415 	stw	r2,-48(fp)
                  }
                }

                /* Strip sign */
                sign = 0;
81136630:	e03ff715 	stw	zero,-36(fp)
                  /* (assumes sign bit is #31) */
                if( fmtSigned && (v & (0x80000000)) )
81136634:	e0bff217 	ldw	r2,-56(fp)
81136638:	10000726 	beq	r2,zero,81136658 <alt_log_private_printf+0x304>
8113663c:	e0bff417 	ldw	r2,-48(fp)
81136640:	1000050e 	bge	r2,zero,81136658 <alt_log_private_printf+0x304>
                  {
                  v = ~v + 1;
81136644:	e0bff417 	ldw	r2,-48(fp)
81136648:	0085c83a 	sub	r2,zero,r2
8113664c:	e0bff415 	stw	r2,-48(fp)
                  sign = 1;
81136650:	00800044 	movi	r2,1
81136654:	e0bff715 	stw	r2,-36(fp)
                  }

                /* Count digits, and get largest place value */
                vShrink = v;
81136658:	e0bff417 	ldw	r2,-48(fp)
8113665c:	e0bff615 	stw	r2,-40(fp)
                p = 1;
81136660:	00800044 	movi	r2,1
81136664:	e0bff515 	stw	r2,-44(fp)
                digitCount = 1;
81136668:	00800044 	movi	r2,1
8113666c:	e0bff815 	stw	r2,-32(fp)
                while( (vShrink = vShrink / fmtBase) > 0 )
81136670:	00000706 	br	81136690 <alt_log_private_printf+0x33c>
                  {
                  digitCount++;
81136674:	e0bff817 	ldw	r2,-32(fp)
81136678:	10800044 	addi	r2,r2,1
8113667c:	e0bff815 	stw	r2,-32(fp)
                  p *= fmtBase;
81136680:	e0bff117 	ldw	r2,-60(fp)
81136684:	e0fff517 	ldw	r3,-44(fp)
81136688:	1885383a 	mul	r2,r3,r2
8113668c:	e0bff515 	stw	r2,-44(fp)

                /* Count digits, and get largest place value */
                vShrink = v;
                p = 1;
                digitCount = 1;
                while( (vShrink = vShrink / fmtBase) > 0 )
81136690:	e0bff117 	ldw	r2,-60(fp)
81136694:	e0fff617 	ldw	r3,-40(fp)
81136698:	1885203a 	divu	r2,r3,r2
8113669c:	e0bff615 	stw	r2,-40(fp)
811366a0:	e0bff617 	ldw	r2,-40(fp)
811366a4:	103ff31e 	bne	r2,zero,81136674 <__reset+0xfb116674>
                  digitCount++;
                  p *= fmtBase;
                  }

                /* Print leading characters & sign */
                fmtBeforeDecimal -= digitCount;
811366a8:	e0ffef17 	ldw	r3,-68(fp)
811366ac:	e0bff817 	ldw	r2,-32(fp)
811366b0:	1885c83a 	sub	r2,r3,r2
811366b4:	e0bfef15 	stw	r2,-68(fp)
                if(fmtLeadingZero)
811366b8:	e0bfed17 	ldw	r2,-76(fp)
811366bc:	10000e26 	beq	r2,zero,811366f8 <alt_log_private_printf+0x3a4>
                  {
                  if(sign)
811366c0:	e0bff717 	ldw	r2,-36(fp)
811366c4:	10000726 	beq	r2,zero,811366e4 <alt_log_private_printf+0x390>
                    {
                    alt_log_txchar('-',(char*)base);
811366c8:	e0bffd17 	ldw	r2,-12(fp)
811366cc:	100b883a 	mov	r5,r2
811366d0:	01000b44 	movi	r4,45
811366d4:	11362980 	call	81136298 <alt_log_txchar>
                    fmtBeforeDecimal--;
811366d8:	e0bfef17 	ldw	r2,-68(fp)
811366dc:	10bfffc4 	addi	r2,r2,-1
811366e0:	e0bfef15 	stw	r2,-68(fp)
                    }
                  alt_log_repchar('0',fmtBeforeDecimal,base);
811366e4:	e1bffd17 	ldw	r6,-12(fp)
811366e8:	e17fef17 	ldw	r5,-68(fp)
811366ec:	01000c04 	movi	r4,48
811366f0:	11362ec0 	call	811362ec <alt_log_repchar>
811366f4:	00003206 	br	811367c0 <alt_log_private_printf+0x46c>
                  }
                else
                  {
                    if(sign)
811366f8:	e0bff717 	ldw	r2,-36(fp)
811366fc:	10000326 	beq	r2,zero,8113670c <alt_log_private_printf+0x3b8>
                    {
                      fmtBeforeDecimal--;
81136700:	e0bfef17 	ldw	r2,-68(fp)
81136704:	10bfffc4 	addi	r2,r2,-1
81136708:	e0bfef15 	stw	r2,-68(fp)
                    }
                    alt_log_repchar(' ',fmtBeforeDecimal,base);
8113670c:	e1bffd17 	ldw	r6,-12(fp)
81136710:	e17fef17 	ldw	r5,-68(fp)
81136714:	01000804 	movi	r4,32
81136718:	11362ec0 	call	811362ec <alt_log_repchar>
                    if(sign)
8113671c:	e0bff717 	ldw	r2,-36(fp)
81136720:	10002726 	beq	r2,zero,811367c0 <alt_log_private_printf+0x46c>
                    {
                      alt_log_txchar('-',(char*)base);
81136724:	e0bffd17 	ldw	r2,-12(fp)
81136728:	100b883a 	mov	r5,r2
8113672c:	01000b44 	movi	r4,45
81136730:	11362980 	call	81136298 <alt_log_txchar>
                    }
                  }

                /* Print numbery parts */
                while(p)
81136734:	00002206 	br	811367c0 <alt_log_private_printf+0x46c>
                  {
                  unsigned char d;

                  d = v / p;
81136738:	e0fff417 	ldw	r3,-48(fp)
8113673c:	e0bff517 	ldw	r2,-44(fp)
81136740:	1885203a 	divu	r2,r3,r2
81136744:	e0bff905 	stb	r2,-28(fp)
                  d += '0';
81136748:	e0bff903 	ldbu	r2,-28(fp)
8113674c:	10800c04 	addi	r2,r2,48
81136750:	e0bff905 	stb	r2,-28(fp)
                  if(d > '9')
81136754:	e0bff903 	ldbu	r2,-28(fp)
81136758:	10800eb0 	cmpltui	r2,r2,58
8113675c:	1000081e 	bne	r2,zero,81136780 <alt_log_private_printf+0x42c>
                  {
                    d += (fmtCase ? 'A' : 'a') - '0' - 10;
81136760:	e0bff317 	ldw	r2,-52(fp)
81136764:	10000226 	beq	r2,zero,81136770 <alt_log_private_printf+0x41c>
81136768:	008001c4 	movi	r2,7
8113676c:	00000106 	br	81136774 <alt_log_private_printf+0x420>
81136770:	008009c4 	movi	r2,39
81136774:	e0fff903 	ldbu	r3,-28(fp)
81136778:	10c5883a 	add	r2,r2,r3
8113677c:	e0bff905 	stb	r2,-28(fp)
                  }
                  alt_log_txchar(d,(char*)base);
81136780:	e0bff903 	ldbu	r2,-28(fp)
81136784:	e0fffd17 	ldw	r3,-12(fp)
81136788:	180b883a 	mov	r5,r3
8113678c:	1009883a 	mov	r4,r2
81136790:	11362980 	call	81136298 <alt_log_txchar>

                  v = v % p;
81136794:	e0bff417 	ldw	r2,-48(fp)
81136798:	e0fff517 	ldw	r3,-44(fp)
8113679c:	10c9203a 	divu	r4,r2,r3
811367a0:	e0fff517 	ldw	r3,-44(fp)
811367a4:	20c7383a 	mul	r3,r4,r3
811367a8:	10c5c83a 	sub	r2,r2,r3
811367ac:	e0bff415 	stw	r2,-48(fp)
                  p = p / fmtBase;
811367b0:	e0bff117 	ldw	r2,-60(fp)
811367b4:	e0fff517 	ldw	r3,-44(fp)
811367b8:	1885203a 	divu	r2,r3,r2
811367bc:	e0bff515 	stw	r2,-44(fp)
                      alt_log_txchar('-',(char*)base);
                    }
                  }

                /* Print numbery parts */
                while(p)
811367c0:	e0bff517 	ldw	r2,-44(fp)
811367c4:	103fdc1e 	bne	r2,zero,81136738 <__reset+0xfb116738>
                  v = v % p;
                  p = p / fmtBase;
                  }
                }

              state = pfState_chars;
811367c8:	e03fec15 	stw	zero,-80(fp)
              break;
811367cc:	00003f06 	br	811368cc <alt_log_private_printf+0x578>

            case 'u':
              fmtSigned = 0;
811367d0:	e03ff215 	stw	zero,-56(fp)
              goto doIntegerPrint;
811367d4:	003f7906 	br	811365bc <__reset+0xfb1165bc>
            case 'o':
              fmtSigned = 0;
811367d8:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 8;
811367dc:	00800204 	movi	r2,8
811367e0:	e0bff115 	stw	r2,-60(fp)
              goto doIntegerPrint;
811367e4:	003f7506 	br	811365bc <__reset+0xfb1165bc>
            case 'x':
              fmtSigned = 0;
811367e8:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 16;
811367ec:	00800404 	movi	r2,16
811367f0:	e0bff115 	stw	r2,-60(fp)
              goto doIntegerPrint;
811367f4:	003f7106 	br	811365bc <__reset+0xfb1165bc>
            case 'X':
              fmtSigned = 0;
811367f8:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 16;
811367fc:	00800404 	movi	r2,16
81136800:	e0bff115 	stw	r2,-60(fp)
              fmtCase = 1;
81136804:	00800044 	movi	r2,1
81136808:	e0bff315 	stw	r2,-52(fp)
              goto doIntegerPrint;
8113680c:	003f6b06 	br	811365bc <__reset+0xfb1165bc>

            case 'c':
              alt_log_repchar(' ',fmtBeforeDecimal-1,base);
81136810:	e0bfef17 	ldw	r2,-68(fp)
81136814:	10bfffc4 	addi	r2,r2,-1
81136818:	e1bffd17 	ldw	r6,-12(fp)
8113681c:	100b883a 	mov	r5,r2
81136820:	01000804 	movi	r4,32
81136824:	11362ec0 	call	811362ec <alt_log_repchar>
              alt_log_txchar(va_arg(args,int),(char*)base);
81136828:	e0bffe17 	ldw	r2,-8(fp)
8113682c:	10c00104 	addi	r3,r2,4
81136830:	e0fffe15 	stw	r3,-8(fp)
81136834:	10800017 	ldw	r2,0(r2)
81136838:	e0fffd17 	ldw	r3,-12(fp)
8113683c:	180b883a 	mov	r5,r3
81136840:	1009883a 	mov	r4,r2
81136844:	11362980 	call	81136298 <alt_log_txchar>
              break;
81136848:	00002006 	br	811368cc <alt_log_private_printf+0x578>

            case 's':
                {
                char *s;

                s = va_arg(args,char *);
8113684c:	e0bffe17 	ldw	r2,-8(fp)
81136850:	10c00104 	addi	r3,r2,4
81136854:	e0fffe15 	stw	r3,-8(fp)
81136858:	10800017 	ldw	r2,0(r2)
8113685c:	e0bffa15 	stw	r2,-24(fp)
                alt_log_repchar(' ',fmtBeforeDecimal-strlen(s),base);
81136860:	e43fef17 	ldw	r16,-68(fp)
81136864:	e13ffa17 	ldw	r4,-24(fp)
81136868:	1122b480 	call	81122b48 <strlen>
8113686c:	8085c83a 	sub	r2,r16,r2
81136870:	e1bffd17 	ldw	r6,-12(fp)
81136874:	100b883a 	mov	r5,r2
81136878:	01000804 	movi	r4,32
8113687c:	11362ec0 	call	811362ec <alt_log_repchar>

                while(*s)
81136880:	00000b06 	br	811368b0 <alt_log_private_printf+0x55c>
                  alt_log_txchar(*s++,(char*)base);
81136884:	e0bffa17 	ldw	r2,-24(fp)
81136888:	10c00044 	addi	r3,r2,1
8113688c:	e0fffa15 	stw	r3,-24(fp)
81136890:	10800003 	ldbu	r2,0(r2)
81136894:	10803fcc 	andi	r2,r2,255
81136898:	1080201c 	xori	r2,r2,128
8113689c:	10bfe004 	addi	r2,r2,-128
811368a0:	e0fffd17 	ldw	r3,-12(fp)
811368a4:	180b883a 	mov	r5,r3
811368a8:	1009883a 	mov	r4,r2
811368ac:	11362980 	call	81136298 <alt_log_txchar>
                char *s;

                s = va_arg(args,char *);
                alt_log_repchar(' ',fmtBeforeDecimal-strlen(s),base);

                while(*s)
811368b0:	e0bffa17 	ldw	r2,-24(fp)
811368b4:	10800003 	ldbu	r2,0(r2)
811368b8:	10803fcc 	andi	r2,r2,255
811368bc:	1080201c 	xori	r2,r2,128
811368c0:	10bfe004 	addi	r2,r2,-128
811368c4:	103fef1e 	bne	r2,zero,81136884 <__reset+0xfb116884>
                  alt_log_txchar(*s++,(char*)base);
                }
              break;
811368c8:	0001883a 	nop
            } /* switch last letter of fmt */
          state=pfState_chars;
811368cc:	e03fec15 	stw	zero,-80(fp)
          }
        break;
811368d0:	0001883a 	nop
  int fmtCase = 0; /* For hex format, if 1, A-F, else a-f. */

  w = fmt;
  state = pfState_chars;

  while(0 != (c = *w++))
811368d4:	e0bfeb17 	ldw	r2,-84(fp)
811368d8:	10c00044 	addi	r3,r2,1
811368dc:	e0ffeb15 	stw	r3,-84(fp)
811368e0:	10800003 	ldbu	r2,0(r2)
811368e4:	e0bffb05 	stb	r2,-20(fp)
811368e8:	e0bffb07 	ldb	r2,-20(fp)
811368ec:	103eae1e 	bne	r2,zero,811363a8 <__reset+0xfb1163a8>
          state=pfState_chars;
          }
        break;
      } /* switch */
    } /* while chars left */
  } /* printf */
811368f0:	0001883a 	nop
811368f4:	e6ffff04 	addi	sp,fp,-4
811368f8:	dfc00217 	ldw	ra,8(sp)
811368fc:	df000117 	ldw	fp,4(sp)
81136900:	dc000017 	ldw	r16,0(sp)
81136904:	dec00304 	addi	sp,sp,12
81136908:	f800283a 	ret

8113690c <alt_log_printf_proc>:

/* Main logging printf function */
int alt_log_printf_proc(const char *fmt, ... )
{
8113690c:	defff904 	addi	sp,sp,-28
81136910:	de00012e 	bgeu	sp,et,81136918 <alt_log_printf_proc+0xc>
81136914:	003b68fa 	trap	3
81136918:	dfc00315 	stw	ra,12(sp)
8113691c:	df000215 	stw	fp,8(sp)
81136920:	df000204 	addi	fp,sp,8
81136924:	e13fff15 	stw	r4,-4(fp)
81136928:	e1400215 	stw	r5,8(fp)
8113692c:	e1800315 	stw	r6,12(fp)
81136930:	e1c00415 	stw	r7,16(fp)
    va_list args;

    va_start (args, fmt);
81136934:	e0800204 	addi	r2,fp,8
81136938:	e0bffe15 	stw	r2,-8(fp)
    alt_log_private_printf(fmt,ALT_LOG_PORT_BASE,args);
8113693c:	e0bffe17 	ldw	r2,-8(fp)
81136940:	100d883a 	mov	r6,r2
81136944:	01604834 	movhi	r5,33056
81136948:	294c2404 	addi	r5,r5,12432
8113694c:	e13fff17 	ldw	r4,-4(fp)
81136950:	11363540 	call	81136354 <alt_log_private_printf>
    return (0);
81136954:	0005883a 	mov	r2,zero
}
81136958:	e037883a 	mov	sp,fp
8113695c:	dfc00117 	ldw	ra,4(sp)
81136960:	df000017 	ldw	fp,0(sp)
81136964:	dec00504 	addi	sp,sp,20
81136968:	f800283a 	ret

8113696c <altera_avalon_jtag_uart_report_log>:
 * This function, when turned on, prints out the status
 * of the JTAG UART Control register, every ALT_LOG_JTAG_UART_TICKS.
 * If the flag is off, the alarm should never be registered, and this
 * function should never run */
alt_u32 altera_avalon_jtag_uart_report_log(void * context)
{
8113696c:	defff904 	addi	sp,sp,-28
81136970:	de00012e 	bgeu	sp,et,81136978 <altera_avalon_jtag_uart_report_log+0xc>
81136974:	003b68fa 	trap	3
81136978:	dfc00615 	stw	ra,24(sp)
8113697c:	df000515 	stw	fp,20(sp)
81136980:	dc400415 	stw	r17,16(sp)
81136984:	dc000315 	stw	r16,12(sp)
81136988:	df000504 	addi	fp,sp,20
8113698c:	e13ffd15 	stw	r4,-12(fp)
    if (alt_log_jtag_uart_alarm_on_flag) {
81136990:	d0a08183 	ldbu	r2,-32250(gp)
81136994:	10803fcc 	andi	r2,r2,255
81136998:	10001426 	beq	r2,zero,811369ec <altera_avalon_jtag_uart_report_log+0x80>
    altera_avalon_jtag_uart_state* dev = (altera_avalon_jtag_uart_state*) context;
8113699c:	e0bffd17 	ldw	r2,-12(fp)
811369a0:	e0bffb15 	stw	r2,-20(fp)
        const char* header="JTAG Alarm:";
811369a4:	00a04574 	movhi	r2,33045
811369a8:	1081e604 	addi	r2,r2,1944
811369ac:	e0bffc15 	stw	r2,-16(fp)
        alt_log_jtag_uart_print_control_reg(dev, dev->base, header);
811369b0:	e0bffb17 	ldw	r2,-20(fp)
811369b4:	10800017 	ldw	r2,0(r2)
811369b8:	e1bffc17 	ldw	r6,-16(fp)
811369bc:	100b883a 	mov	r5,r2
811369c0:	e13ffb17 	ldw	r4,-20(fp)
811369c4:	1136a0c0 	call	81136a0c <alt_log_jtag_uart_print_control_reg>
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
811369c8:	d0e08817 	ldw	r3,-32224(gp)
        return ALT_LOG_JTAG_UART_TICKS;
811369cc:	00b33374 	movhi	r2,52429
811369d0:	10b33344 	addi	r2,r2,-13107
811369d4:	1888383a 	mulxuu	r4,r3,r2
811369d8:	1885383a 	mul	r2,r3,r2
811369dc:	1021883a 	mov	r16,r2
811369e0:	2023883a 	mov	r17,r4
811369e4:	8804d0fa 	srli	r2,r17,3
811369e8:	00000106 	br	811369f0 <altera_avalon_jtag_uart_report_log+0x84>
    }
    else 
    {  
        /* If flag is not on, return 0 to disable future alarms.
        * Should never be here, alarm should not be enabled at all. */
        return 0;
811369ec:	0005883a 	mov	r2,zero
    }
}
811369f0:	e6fffe04 	addi	sp,fp,-8
811369f4:	dfc00317 	ldw	ra,12(sp)
811369f8:	df000217 	ldw	fp,8(sp)
811369fc:	dc400117 	ldw	r17,4(sp)
81136a00:	dc000017 	ldw	r16,0(sp)
81136a04:	dec00404 	addi	sp,sp,16
81136a08:	f800283a 	ret

81136a0c <alt_log_jtag_uart_print_control_reg>:

void alt_log_jtag_uart_print_control_reg(altera_avalon_jtag_uart_state* dev, int base, const char* header)
{
81136a0c:	deffef04 	addi	sp,sp,-68
81136a10:	de00012e 	bgeu	sp,et,81136a18 <alt_log_jtag_uart_print_control_reg+0xc>
81136a14:	003b68fa 	trap	3
81136a18:	dfc01015 	stw	ra,64(sp)
81136a1c:	df000f15 	stw	fp,60(sp)
81136a20:	df000f04 	addi	fp,sp,60
81136a24:	e13ffd15 	stw	r4,-12(fp)
81136a28:	e17ffe15 	stw	r5,-8(fp)
81136a2c:	e1bfff15 	stw	r6,-4(fp)
     unsigned int control, space, ac, wi, ri, we, re;
     control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
81136a30:	e0bffe17 	ldw	r2,-8(fp)
81136a34:	10800104 	addi	r2,r2,4
81136a38:	10800037 	ldwio	r2,0(r2)
81136a3c:	e0bff615 	stw	r2,-40(fp)
     space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >>
81136a40:	e0bff617 	ldw	r2,-40(fp)
81136a44:	1004d43a 	srli	r2,r2,16
81136a48:	e0bff715 	stw	r2,-36(fp)
             ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
     we= (control & ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK) >>
81136a4c:	e0bff617 	ldw	r2,-40(fp)
81136a50:	1080008c 	andi	r2,r2,2
81136a54:	1004d07a 	srli	r2,r2,1
81136a58:	e0bff815 	stw	r2,-32(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_WE_OFST;
     re= (control & ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK) >>
81136a5c:	e0bff617 	ldw	r2,-40(fp)
81136a60:	1080004c 	andi	r2,r2,1
81136a64:	e0bff915 	stw	r2,-28(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_RE_OFST;
     ri= (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK) >>
81136a68:	e0bff617 	ldw	r2,-40(fp)
81136a6c:	1080400c 	andi	r2,r2,256
81136a70:	1004d23a 	srli	r2,r2,8
81136a74:	e0bffa15 	stw	r2,-24(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_RI_OFST;
     wi= (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK) >>
81136a78:	e0bff617 	ldw	r2,-40(fp)
81136a7c:	1080800c 	andi	r2,r2,512
81136a80:	1004d27a 	srli	r2,r2,9
81136a84:	e0bffb15 	stw	r2,-20(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_WI_OFST;
     ac= (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK) >>
81136a88:	e0bff617 	ldw	r2,-40(fp)
81136a8c:	1081000c 	andi	r2,r2,1024
81136a90:	1004d2ba 	srli	r2,r2,10
81136a94:	e0bffc15 	stw	r2,-16(fp)
#ifdef ALTERA_AVALON_JTAG_UART_SMALL
    ALT_LOG_PRINTF(
     "%s HW FIFO wspace=%d AC=%d WI=%d RI=%d WE=%d RE=%d\r\n",
         header,space,ac,wi,ri,we,re);
#else
    ALT_LOG_PRINTF(
81136a98:	e0bffd17 	ldw	r2,-12(fp)
81136a9c:	10c01017 	ldw	r3,64(r2)
81136aa0:	e0bffd17 	ldw	r2,-12(fp)
81136aa4:	10800f17 	ldw	r2,60(r2)
81136aa8:	1887c83a 	sub	r3,r3,r2
81136aac:	e0bff917 	ldw	r2,-28(fp)
81136ab0:	d8800415 	stw	r2,16(sp)
81136ab4:	e0bff817 	ldw	r2,-32(fp)
81136ab8:	d8800315 	stw	r2,12(sp)
81136abc:	e0bffa17 	ldw	r2,-24(fp)
81136ac0:	d8800215 	stw	r2,8(sp)
81136ac4:	e0bffb17 	ldw	r2,-20(fp)
81136ac8:	d8800115 	stw	r2,4(sp)
81136acc:	e0bffc17 	ldw	r2,-16(fp)
81136ad0:	d8800015 	stw	r2,0(sp)
81136ad4:	e1fff717 	ldw	r7,-36(fp)
81136ad8:	180d883a 	mov	r6,r3
81136adc:	e17fff17 	ldw	r5,-4(fp)
81136ae0:	01204574 	movhi	r4,33045
81136ae4:	2101e904 	addi	r4,r4,1956
81136ae8:	113690c0 	call	8113690c <alt_log_printf_proc>
     "%s SW CirBuf = %d, HW FIFO wspace=%d AC=%d WI=%d RI=%d WE=%d RE=%d\r\n",
         header,(dev->tx_out-dev->tx_in),space,ac,wi,ri,we,re);
#endif   
         
     return;
81136aec:	0001883a 	nop

}
81136af0:	e037883a 	mov	sp,fp
81136af4:	dfc00117 	ldw	ra,4(sp)
81136af8:	df000017 	ldw	fp,0(sp)
81136afc:	dec00204 	addi	sp,sp,8
81136b00:	f800283a 	ret

81136b04 <alt_log_jtag_uart_startup_info>:
/* In altera_avalon_jtag_uart.c
 * Same output as the alarm function above, but this is called in the driver
 * init function.  Hence, it gives the status of the JTAG UART control register
 * right at the initialization of the driver */ 
void alt_log_jtag_uart_startup_info(altera_avalon_jtag_uart_state* dev, int base)
{
81136b04:	defffb04 	addi	sp,sp,-20
81136b08:	de00012e 	bgeu	sp,et,81136b10 <alt_log_jtag_uart_startup_info+0xc>
81136b0c:	003b68fa 	trap	3
81136b10:	dfc00415 	stw	ra,16(sp)
81136b14:	df000315 	stw	fp,12(sp)
81136b18:	df000304 	addi	fp,sp,12
81136b1c:	e13ffe15 	stw	r4,-8(fp)
81136b20:	e17fff15 	stw	r5,-4(fp)
     const char* header="JTAG Startup Info:";
81136b24:	00a04574 	movhi	r2,33045
81136b28:	1081fb04 	addi	r2,r2,2028
81136b2c:	e0bffd15 	stw	r2,-12(fp)
     alt_log_jtag_uart_print_control_reg(dev, base, header);
81136b30:	e1bffd17 	ldw	r6,-12(fp)
81136b34:	e17fff17 	ldw	r5,-4(fp)
81136b38:	e13ffe17 	ldw	r4,-8(fp)
81136b3c:	1136a0c0 	call	81136a0c <alt_log_jtag_uart_print_control_reg>
     return;
81136b40:	0001883a 	nop
}
81136b44:	e037883a 	mov	sp,fp
81136b48:	dfc00117 	ldw	ra,4(sp)
81136b4c:	df000017 	ldw	fp,0(sp)
81136b50:	dec00204 	addi	sp,sp,8
81136b54:	f800283a 	ret

81136b58 <alt_log_jtag_uart_isr_proc>:

/* In altera_avalon_jtag_uart.c
 * When turned on, this function will print out the status of the jtag uart
 * control register every time there is a jtag uart "almost-empty" interrupt. */
void alt_log_jtag_uart_isr_proc(int base, altera_avalon_jtag_uart_state* dev) 
{
81136b58:	defffb04 	addi	sp,sp,-20
81136b5c:	de00012e 	bgeu	sp,et,81136b64 <alt_log_jtag_uart_isr_proc+0xc>
81136b60:	003b68fa 	trap	3
81136b64:	dfc00415 	stw	ra,16(sp)
81136b68:	df000315 	stw	fp,12(sp)
81136b6c:	df000304 	addi	fp,sp,12
81136b70:	e13ffe15 	stw	r4,-8(fp)
81136b74:	e17fff15 	stw	r5,-4(fp)
    if (alt_log_jtag_uart_isr_on_flag) {
81136b78:	d0a081c3 	ldbu	r2,-32249(gp)
81136b7c:	10803fcc 	andi	r2,r2,255
81136b80:	10000826 	beq	r2,zero,81136ba4 <alt_log_jtag_uart_isr_proc+0x4c>
        const char* header="JTAG IRQ:";
81136b84:	00a04574 	movhi	r2,33045
81136b88:	10820004 	addi	r2,r2,2048
81136b8c:	e0bffd15 	stw	r2,-12(fp)
        alt_log_jtag_uart_print_control_reg(dev, base, header);
81136b90:	e1bffd17 	ldw	r6,-12(fp)
81136b94:	e17ffe17 	ldw	r5,-8(fp)
81136b98:	e13fff17 	ldw	r4,-4(fp)
81136b9c:	1136a0c0 	call	81136a0c <alt_log_jtag_uart_print_control_reg>
    }
    return;
81136ba0:	0001883a 	nop
81136ba4:	0001883a 	nop
}
81136ba8:	e037883a 	mov	sp,fp
81136bac:	dfc00117 	ldw	ra,4(sp)
81136bb0:	df000017 	ldw	fp,0(sp)
81136bb4:	dec00204 	addi	sp,sp,8
81136bb8:	f800283a 	ret

81136bbc <alt_log_write>:
 * When the alt_log_write_on_flag is turned on, this function gets called
 * every time alt_write gets called.  The first 
 * ALT_LOG_WRITE_ECHO_LEN characters of every printf command (or any command
 * that eventually calls write()) gets echoed to the alt_log output. */
void alt_log_write(const void *ptr, size_t len)
{
81136bbc:	defffa04 	addi	sp,sp,-24
81136bc0:	de00012e 	bgeu	sp,et,81136bc8 <alt_log_write+0xc>
81136bc4:	003b68fa 	trap	3
81136bc8:	dfc00515 	stw	ra,20(sp)
81136bcc:	df000415 	stw	fp,16(sp)
81136bd0:	df000404 	addi	fp,sp,16
81136bd4:	e13ffe15 	stw	r4,-8(fp)
81136bd8:	e17fff15 	stw	r5,-4(fp)
    if (alt_log_write_on_flag) {
81136bdc:	d0a08103 	ldbu	r2,-32252(gp)
81136be0:	10803fcc 	andi	r2,r2,255
81136be4:	10004026 	beq	r2,zero,81136ce8 <alt_log_write+0x12c>
    int temp_cnt;
        int length=(ALT_LOG_WRITE_ECHO_LEN>len) ? len : ALT_LOG_WRITE_ECHO_LEN;
81136be8:	e0bfff17 	ldw	r2,-4(fp)
81136bec:	10c00430 	cmpltui	r3,r2,16
81136bf0:	1800011e 	bne	r3,zero,81136bf8 <alt_log_write+0x3c>
81136bf4:	008003c4 	movi	r2,15
81136bf8:	e0bffd15 	stw	r2,-12(fp)

        if (length < 2) return;
81136bfc:	e0bffd17 	ldw	r2,-12(fp)
81136c00:	10800088 	cmpgei	r2,r2,2
81136c04:	10003726 	beq	r2,zero,81136ce4 <alt_log_write+0x128>

        strncpy (alt_log_write_buf,ptr,length);
81136c08:	e0bffd17 	ldw	r2,-12(fp)
81136c0c:	100d883a 	mov	r6,r2
81136c10:	e17ffe17 	ldw	r5,-8(fp)
81136c14:	012045b4 	movhi	r4,33046
81136c18:	2119dd04 	addi	r4,r4,26484
81136c1c:	114ab880 	call	8114ab88 <strncpy>
    alt_log_write_buf[length-1]='\n';
81136c20:	e0bffd17 	ldw	r2,-12(fp)
81136c24:	10ffffc4 	addi	r3,r2,-1
81136c28:	00a045b4 	movhi	r2,33046
81136c2c:	1099dd04 	addi	r2,r2,26484
81136c30:	10c5883a 	add	r2,r2,r3
81136c34:	00c00284 	movi	r3,10
81136c38:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length]='\r';
81136c3c:	00a045b4 	movhi	r2,33046
81136c40:	1099dd04 	addi	r2,r2,26484
81136c44:	e0fffd17 	ldw	r3,-12(fp)
81136c48:	10c5883a 	add	r2,r2,r3
81136c4c:	00c00344 	movi	r3,13
81136c50:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length+1]='\0';
81136c54:	e0bffd17 	ldw	r2,-12(fp)
81136c58:	10c00044 	addi	r3,r2,1
81136c5c:	00a045b4 	movhi	r2,33046
81136c60:	1099dd04 	addi	r2,r2,26484
81136c64:	10c5883a 	add	r2,r2,r3
81136c68:	10000005 	stb	zero,0(r2)

    /* Escape Ctrl-D's. If the Ctrl-D gets sent it might kill the terminal
         * connection of alt_log. It will get replaced by 'D'. */
        for (temp_cnt=0;temp_cnt < length; temp_cnt++) {
81136c6c:	e03ffc15 	stw	zero,-16(fp)
81136c70:	00001306 	br	81136cc0 <alt_log_write+0x104>
        if (alt_log_write_buf[temp_cnt]== 0x4) {
81136c74:	00a045b4 	movhi	r2,33046
81136c78:	1099dd04 	addi	r2,r2,26484
81136c7c:	e0fffc17 	ldw	r3,-16(fp)
81136c80:	10c5883a 	add	r2,r2,r3
81136c84:	10800003 	ldbu	r2,0(r2)
81136c88:	10803fcc 	andi	r2,r2,255
81136c8c:	1080201c 	xori	r2,r2,128
81136c90:	10bfe004 	addi	r2,r2,-128
81136c94:	10800118 	cmpnei	r2,r2,4
81136c98:	1000061e 	bne	r2,zero,81136cb4 <alt_log_write+0xf8>
            alt_log_write_buf[temp_cnt]='D';
81136c9c:	00a045b4 	movhi	r2,33046
81136ca0:	1099dd04 	addi	r2,r2,26484
81136ca4:	e0fffc17 	ldw	r3,-16(fp)
81136ca8:	10c5883a 	add	r2,r2,r3
81136cac:	00c01104 	movi	r3,68
81136cb0:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length]='\r';
    alt_log_write_buf[length+1]='\0';

    /* Escape Ctrl-D's. If the Ctrl-D gets sent it might kill the terminal
         * connection of alt_log. It will get replaced by 'D'. */
        for (temp_cnt=0;temp_cnt < length; temp_cnt++) {
81136cb4:	e0bffc17 	ldw	r2,-16(fp)
81136cb8:	10800044 	addi	r2,r2,1
81136cbc:	e0bffc15 	stw	r2,-16(fp)
81136cc0:	e0fffc17 	ldw	r3,-16(fp)
81136cc4:	e0bffd17 	ldw	r2,-12(fp)
81136cc8:	18bfea16 	blt	r3,r2,81136c74 <__reset+0xfb116c74>
        if (alt_log_write_buf[temp_cnt]== 0x4) {
            alt_log_write_buf[temp_cnt]='D';
        }
    }
        ALT_LOG_PRINTF("Write Echo: %s",alt_log_write_buf);
81136ccc:	016045b4 	movhi	r5,33046
81136cd0:	2959dd04 	addi	r5,r5,26484
81136cd4:	01204574 	movhi	r4,33045
81136cd8:	21020304 	addi	r4,r4,2060
81136cdc:	113690c0 	call	8113690c <alt_log_printf_proc>
81136ce0:	00000106 	br	81136ce8 <alt_log_write+0x12c>
{
    if (alt_log_write_on_flag) {
    int temp_cnt;
        int length=(ALT_LOG_WRITE_ECHO_LEN>len) ? len : ALT_LOG_WRITE_ECHO_LEN;

        if (length < 2) return;
81136ce4:	0001883a 	nop
            alt_log_write_buf[temp_cnt]='D';
        }
    }
        ALT_LOG_PRINTF("Write Echo: %s",alt_log_write_buf);
    }
}
81136ce8:	e037883a 	mov	sp,fp
81136cec:	dfc00117 	ldw	ra,4(sp)
81136cf0:	df000017 	ldw	fp,0(sp)
81136cf4:	dec00204 	addi	sp,sp,8
81136cf8:	f800283a 	ret

81136cfc <alt_log_system_clock>:

/* In altera_avalon_timer_sc
 * This function prints out a system clock is alive message
 * every ALT_LOG_SYS_CLK_INTERVAL (in ticks).  */
void alt_log_system_clock()
{
81136cfc:	defffe04 	addi	sp,sp,-8
81136d00:	de00012e 	bgeu	sp,et,81136d08 <alt_log_system_clock+0xc>
81136d04:	003b68fa 	trap	3
81136d08:	dfc00115 	stw	ra,4(sp)
81136d0c:	df000015 	stw	fp,0(sp)
81136d10:	d839883a 	mov	fp,sp
    if (alt_log_sys_clk_on_flag) {
81136d14:	d0a08143 	ldbu	r2,-32251(gp)
81136d18:	10803fcc 	andi	r2,r2,255
81136d1c:	10000e26 	beq	r2,zero,81136d58 <alt_log_system_clock+0x5c>
    alt_log_sys_clk_count++;
81136d20:	d0a08417 	ldw	r2,-32240(gp)
81136d24:	10800044 	addi	r2,r2,1
81136d28:	d0a08415 	stw	r2,-32240(gp)
81136d2c:	d0a08817 	ldw	r2,-32224(gp)
        if (alt_log_sys_clk_count > ALT_LOG_SYS_CLK_INTERVAL) {
81136d30:	d0e08417 	ldw	r3,-32240(gp)
81136d34:	10c0082e 	bgeu	r2,r3,81136d58 <alt_log_system_clock+0x5c>
            alt_log_sys_clk_count = 0;
81136d38:	d0208415 	stw	zero,-32240(gp)
            ALT_LOG_PRINTF("System Clock On %u\r\n",alt_system_clock_in_sec++);
81136d3c:	d0a08317 	ldw	r2,-32244(gp)
81136d40:	10c00044 	addi	r3,r2,1
81136d44:	d0e08315 	stw	r3,-32244(gp)
81136d48:	100b883a 	mov	r5,r2
81136d4c:	01204574 	movhi	r4,33045
81136d50:	21020704 	addi	r4,r4,2076
81136d54:	113690c0 	call	8113690c <alt_log_printf_proc>
        }
    }
}
81136d58:	0001883a 	nop
81136d5c:	e037883a 	mov	sp,fp
81136d60:	dfc00117 	ldw	ra,4(sp)
81136d64:	df000017 	ldw	fp,0(sp)
81136d68:	dec00204 	addi	sp,sp,8
81136d6c:	f800283a 	ret

81136d70 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81136d70:	defffe04 	addi	sp,sp,-8
81136d74:	de00012e 	bgeu	sp,et,81136d7c <alt_get_errno+0xc>
81136d78:	003b68fa 	trap	3
81136d7c:	dfc00115 	stw	ra,4(sp)
81136d80:	df000015 	stw	fp,0(sp)
81136d84:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81136d88:	d0a01017 	ldw	r2,-32704(gp)
81136d8c:	10000326 	beq	r2,zero,81136d9c <alt_get_errno+0x2c>
81136d90:	d0a01017 	ldw	r2,-32704(gp)
81136d94:	103ee83a 	callr	r2
81136d98:	00000106 	br	81136da0 <alt_get_errno+0x30>
81136d9c:	d0a07804 	addi	r2,gp,-32288
}
81136da0:	e037883a 	mov	sp,fp
81136da4:	dfc00117 	ldw	ra,4(sp)
81136da8:	df000017 	ldw	fp,0(sp)
81136dac:	dec00204 	addi	sp,sp,8
81136db0:	f800283a 	ret

81136db4 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
81136db4:	defff904 	addi	sp,sp,-28
81136db8:	de00012e 	bgeu	sp,et,81136dc0 <lseek+0xc>
81136dbc:	003b68fa 	trap	3
81136dc0:	dfc00615 	stw	ra,24(sp)
81136dc4:	df000515 	stw	fp,20(sp)
81136dc8:	df000504 	addi	fp,sp,20
81136dcc:	e13ffd15 	stw	r4,-12(fp)
81136dd0:	e17ffe15 	stw	r5,-8(fp)
81136dd4:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
81136dd8:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81136ddc:	e0bffd17 	ldw	r2,-12(fp)
81136de0:	10000616 	blt	r2,zero,81136dfc <lseek+0x48>
81136de4:	e0bffd17 	ldw	r2,-12(fp)
81136de8:	10c00324 	muli	r3,r2,12
81136dec:	00a04574 	movhi	r2,33045
81136df0:	1085c004 	addi	r2,r2,5888
81136df4:	1885883a 	add	r2,r3,r2
81136df8:	00000106 	br	81136e00 <lseek+0x4c>
81136dfc:	0005883a 	mov	r2,zero
81136e00:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
81136e04:	e0bffc17 	ldw	r2,-16(fp)
81136e08:	10001026 	beq	r2,zero,81136e4c <lseek+0x98>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
81136e0c:	e0bffc17 	ldw	r2,-16(fp)
81136e10:	10800017 	ldw	r2,0(r2)
81136e14:	10800717 	ldw	r2,28(r2)
81136e18:	10000926 	beq	r2,zero,81136e40 <lseek+0x8c>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
81136e1c:	e0bffc17 	ldw	r2,-16(fp)
81136e20:	10800017 	ldw	r2,0(r2)
81136e24:	10800717 	ldw	r2,28(r2)
81136e28:	e1bfff17 	ldw	r6,-4(fp)
81136e2c:	e17ffe17 	ldw	r5,-8(fp)
81136e30:	e13ffc17 	ldw	r4,-16(fp)
81136e34:	103ee83a 	callr	r2
81136e38:	e0bffb15 	stw	r2,-20(fp)
81136e3c:	00000506 	br	81136e54 <lseek+0xa0>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
81136e40:	00bfde84 	movi	r2,-134
81136e44:	e0bffb15 	stw	r2,-20(fp)
81136e48:	00000206 	br	81136e54 <lseek+0xa0>
    }
  }
  else  
  {
    rc = -EBADFD;
81136e4c:	00bfebc4 	movi	r2,-81
81136e50:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
81136e54:	e0bffb17 	ldw	r2,-20(fp)
81136e58:	1000070e 	bge	r2,zero,81136e78 <lseek+0xc4>
  {
    ALT_ERRNO = -rc;
81136e5c:	1136d700 	call	81136d70 <alt_get_errno>
81136e60:	1007883a 	mov	r3,r2
81136e64:	e0bffb17 	ldw	r2,-20(fp)
81136e68:	0085c83a 	sub	r2,zero,r2
81136e6c:	18800015 	stw	r2,0(r3)
    rc = -1;
81136e70:	00bfffc4 	movi	r2,-1
81136e74:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
81136e78:	e0bffb17 	ldw	r2,-20(fp)
}
81136e7c:	e037883a 	mov	sp,fp
81136e80:	dfc00117 	ldw	ra,4(sp)
81136e84:	df000017 	ldw	fp,0(sp)
81136e88:	dec00204 	addi	sp,sp,8
81136e8c:	f800283a 	ret

81136e90 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
81136e90:	defff904 	addi	sp,sp,-28
81136e94:	de00012e 	bgeu	sp,et,81136e9c <alt_main+0xc>
81136e98:	003b68fa 	trap	3
81136e9c:	dfc00615 	stw	ra,24(sp)
81136ea0:	df000515 	stw	fp,20(sp)
81136ea4:	df000504 	addi	fp,sp,20
#ifndef ALT_NO_EXIT    
  int result;
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
81136ea8:	d0a01217 	ldw	r2,-32696(gp)
81136eac:	10800058 	cmpnei	r2,r2,1
81136eb0:	1000031e 	bne	r2,zero,81136ec0 <alt_main+0x30>
81136eb4:	01204574 	movhi	r4,33045
81136eb8:	21020d04 	addi	r4,r4,2100
81136ebc:	113690c0 	call	8113690c <alt_log_printf_proc>
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
81136ec0:	0009883a 	mov	r4,zero
81136ec4:	11419e80 	call	811419e8 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
81136ec8:	d0a01217 	ldw	r2,-32696(gp)
81136ecc:	10800058 	cmpnei	r2,r2,1
81136ed0:	1000031e 	bne	r2,zero,81136ee0 <alt_main+0x50>
81136ed4:	01204574 	movhi	r4,33045
81136ed8:	21021b04 	addi	r4,r4,2156
81136edc:	113690c0 	call	8113690c <alt_log_printf_proc>
  ALT_OS_INIT();
81136ee0:	113847c0 	call	8113847c <OSInit>
81136ee4:	01000044 	movi	r4,1
81136ee8:	113e1980 	call	8113e198 <OSSemCreate>
81136eec:	d0a08b15 	stw	r2,-32212(gp)
81136ef0:	01000044 	movi	r4,1
81136ef4:	113e1980 	call	8113e198 <OSSemCreate>
81136ef8:	d0a08d15 	stw	r2,-32204(gp)
  /*
   * Initialize the semaphore used to control access to the file descriptor
   * list.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
81136efc:	d0a01217 	ldw	r2,-32696(gp)
81136f00:	10800058 	cmpnei	r2,r2,1
81136f04:	1000031e 	bne	r2,zero,81136f14 <alt_main+0x84>
81136f08:	01204574 	movhi	r4,33045
81136f0c:	21022904 	addi	r4,r4,2212
81136f10:	113690c0 	call	8113690c <alt_log_printf_proc>
81136f14:	d0a07f04 	addi	r2,gp,-32260
81136f18:	e0bffc15 	stw	r2,-16(fp)
81136f1c:	00800044 	movi	r2,1
81136f20:	e0bffd0d 	sth	r2,-12(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
81136f24:	e0bffd0b 	ldhu	r2,-12(fp)
81136f28:	1009883a 	mov	r4,r2
81136f2c:	113e1980 	call	8113e198 <OSSemCreate>
81136f30:	1007883a 	mov	r3,r2
81136f34:	e0bffc17 	ldw	r2,-16(fp)
81136f38:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
81136f3c:	d0a01217 	ldw	r2,-32696(gp)
81136f40:	10800058 	cmpnei	r2,r2,1
81136f44:	1000031e 	bne	r2,zero,81136f54 <alt_main+0xc4>
81136f48:	01204574 	movhi	r4,33045
81136f4c:	21023704 	addi	r4,r4,2268
81136f50:	113690c0 	call	8113690c <alt_log_printf_proc>
  alt_sys_init();
81136f54:	1141a280 	call	81141a28 <alt_sys_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_sys_init.\r\n");
81136f58:	d0a01217 	ldw	r2,-32696(gp)
81136f5c:	10800058 	cmpnei	r2,r2,1
81136f60:	1000031e 	bne	r2,zero,81136f70 <alt_main+0xe0>
81136f64:	01204574 	movhi	r4,33045
81136f68:	21024104 	addi	r4,r4,2308
81136f6c:	113690c0 	call	8113690c <alt_log_printf_proc>
   * been initialized. This is only done if the user has requested these
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
81136f70:	d0a01217 	ldw	r2,-32696(gp)
81136f74:	10800058 	cmpnei	r2,r2,1
81136f78:	1000031e 	bne	r2,zero,81136f88 <alt_main+0xf8>
81136f7c:	01204574 	movhi	r4,33045
81136f80:	21024a04 	addi	r4,r4,2344
81136f84:	113690c0 	call	8113690c <alt_log_printf_proc>
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
81136f88:	01a04574 	movhi	r6,33045
81136f8c:	31825204 	addi	r6,r6,2376
81136f90:	01604574 	movhi	r5,33045
81136f94:	29425704 	addi	r5,r5,2396
81136f98:	01204574 	movhi	r4,33045
81136f9c:	21025704 	addi	r4,r4,2396
81136fa0:	114a3180 	call	8114a318 <alt_io_redirect>
  /*
   * Finally, call main(). The return code is then passed to a subsequent
   * call to exit() unless the application is never supposed to exit.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");
81136fa4:	d0a01217 	ldw	r2,-32696(gp)
81136fa8:	10800058 	cmpnei	r2,r2,1
81136fac:	1000031e 	bne	r2,zero,81136fbc <alt_main+0x12c>
81136fb0:	01204574 	movhi	r4,33045
81136fb4:	21025b04 	addi	r4,r4,2412
81136fb8:	113690c0 	call	8113690c <alt_log_printf_proc>

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
81136fbc:	d0a08517 	ldw	r2,-32236(gp)
81136fc0:	d0e08617 	ldw	r3,-32232(gp)
81136fc4:	d1208717 	ldw	r4,-32228(gp)
81136fc8:	200d883a 	mov	r6,r4
81136fcc:	180b883a 	mov	r5,r3
81136fd0:	1009883a 	mov	r4,r2
81136fd4:	1117b480 	call	81117b48 <main>
81136fd8:	e0bffb15 	stw	r2,-20(fp)
  close(STDOUT_FILENO);
81136fdc:	01000044 	movi	r4,1
81136fe0:	1135dbc0 	call	81135dbc <close>
  exit (result);
81136fe4:	e13ffb17 	ldw	r4,-20(fp)
81136fe8:	114aacc0 	call	8114aacc <exit>

81136fec <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81136fec:	defffe04 	addi	sp,sp,-8
81136ff0:	de00012e 	bgeu	sp,et,81136ff8 <alt_get_errno+0xc>
81136ff4:	003b68fa 	trap	3
81136ff8:	dfc00115 	stw	ra,4(sp)
81136ffc:	df000015 	stw	fp,0(sp)
81137000:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81137004:	d0a01017 	ldw	r2,-32704(gp)
81137008:	10000326 	beq	r2,zero,81137018 <alt_get_errno+0x2c>
8113700c:	d0a01017 	ldw	r2,-32704(gp)
81137010:	103ee83a 	callr	r2
81137014:	00000106 	br	8113701c <alt_get_errno+0x30>
81137018:	d0a07804 	addi	r2,gp,-32288
}
8113701c:	e037883a 	mov	sp,fp
81137020:	dfc00117 	ldw	ra,4(sp)
81137024:	df000017 	ldw	fp,0(sp)
81137028:	dec00204 	addi	sp,sp,8
8113702c:	f800283a 	ret

81137030 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
81137030:	defffd04 	addi	sp,sp,-12
81137034:	de00012e 	bgeu	sp,et,8113703c <alt_file_locked+0xc>
81137038:	003b68fa 	trap	3
8113703c:	df000215 	stw	fp,8(sp)
81137040:	df000204 	addi	fp,sp,8
81137044:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
81137048:	e0bfff17 	ldw	r2,-4(fp)
8113704c:	10800217 	ldw	r2,8(r2)
81137050:	10d00034 	orhi	r3,r2,16384
81137054:	e0bfff17 	ldw	r2,-4(fp)
81137058:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
8113705c:	e03ffe15 	stw	zero,-8(fp)
81137060:	00001d06 	br	811370d8 <alt_file_locked+0xa8>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
81137064:	00a04574 	movhi	r2,33045
81137068:	1085c004 	addi	r2,r2,5888
8113706c:	e0fffe17 	ldw	r3,-8(fp)
81137070:	18c00324 	muli	r3,r3,12
81137074:	10c5883a 	add	r2,r2,r3
81137078:	10c00017 	ldw	r3,0(r2)
8113707c:	e0bfff17 	ldw	r2,-4(fp)
81137080:	10800017 	ldw	r2,0(r2)
81137084:	1880111e 	bne	r3,r2,811370cc <alt_file_locked+0x9c>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
81137088:	00a04574 	movhi	r2,33045
8113708c:	1085c004 	addi	r2,r2,5888
81137090:	e0fffe17 	ldw	r3,-8(fp)
81137094:	18c00324 	muli	r3,r3,12
81137098:	10c5883a 	add	r2,r2,r3
8113709c:	10800204 	addi	r2,r2,8
811370a0:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
811370a4:	1000090e 	bge	r2,zero,811370cc <alt_file_locked+0x9c>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
811370a8:	e0bffe17 	ldw	r2,-8(fp)
811370ac:	10c00324 	muli	r3,r2,12
811370b0:	00a04574 	movhi	r2,33045
811370b4:	1085c004 	addi	r2,r2,5888
811370b8:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
811370bc:	e0bfff17 	ldw	r2,-4(fp)
811370c0:	18800226 	beq	r3,r2,811370cc <alt_file_locked+0x9c>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
811370c4:	00bffcc4 	movi	r2,-13
811370c8:	00000806 	br	811370ec <alt_file_locked+0xbc>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
811370cc:	e0bffe17 	ldw	r2,-8(fp)
811370d0:	10800044 	addi	r2,r2,1
811370d4:	e0bffe15 	stw	r2,-8(fp)
811370d8:	d0a00f17 	ldw	r2,-32708(gp)
811370dc:	1007883a 	mov	r3,r2
811370e0:	e0bffe17 	ldw	r2,-8(fp)
811370e4:	18bfdf2e 	bgeu	r3,r2,81137064 <__reset+0xfb117064>
    }
  }
  
  /* The device is not locked */
 
  return 0;
811370e8:	0005883a 	mov	r2,zero
}
811370ec:	e037883a 	mov	sp,fp
811370f0:	df000017 	ldw	fp,0(sp)
811370f4:	dec00104 	addi	sp,sp,4
811370f8:	f800283a 	ret

811370fc <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
811370fc:	defff604 	addi	sp,sp,-40
81137100:	de00012e 	bgeu	sp,et,81137108 <open+0xc>
81137104:	003b68fa 	trap	3
81137108:	dfc00915 	stw	ra,36(sp)
8113710c:	df000815 	stw	fp,32(sp)
81137110:	df000804 	addi	fp,sp,32
81137114:	e13ffd15 	stw	r4,-12(fp)
81137118:	e17ffe15 	stw	r5,-8(fp)
8113711c:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
81137120:	00bfffc4 	movi	r2,-1
81137124:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
81137128:	00bffb44 	movi	r2,-19
8113712c:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
81137130:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
81137134:	d1600d04 	addi	r5,gp,-32716
81137138:	e13ffd17 	ldw	r4,-12(fp)
8113713c:	1149cf80 	call	81149cf8 <alt_find_dev>
81137140:	e0bff815 	stw	r2,-32(fp)
81137144:	e0bff817 	ldw	r2,-32(fp)
81137148:	1000051e 	bne	r2,zero,81137160 <open+0x64>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
8113714c:	e13ffd17 	ldw	r4,-12(fp)
81137150:	1149d900 	call	81149d90 <alt_find_file>
81137154:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
81137158:	00800044 	movi	r2,1
8113715c:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
81137160:	e0bff817 	ldw	r2,-32(fp)
81137164:	10002926 	beq	r2,zero,8113720c <open+0x110>
  {
    if ((index = alt_get_fd (dev)) < 0)
81137168:	e13ff817 	ldw	r4,-32(fp)
8113716c:	1149ea00 	call	81149ea0 <alt_get_fd>
81137170:	e0bff915 	stw	r2,-28(fp)
81137174:	e0bff917 	ldw	r2,-28(fp)
81137178:	1000030e 	bge	r2,zero,81137188 <open+0x8c>
    {
      status = index;
8113717c:	e0bff917 	ldw	r2,-28(fp)
81137180:	e0bffa15 	stw	r2,-24(fp)
81137184:	00002306 	br	81137214 <open+0x118>
    }
    else
    {
      fd = &alt_fd_list[index];
81137188:	e0bff917 	ldw	r2,-28(fp)
8113718c:	10c00324 	muli	r3,r2,12
81137190:	00a04574 	movhi	r2,33045
81137194:	1085c004 	addi	r2,r2,5888
81137198:	1885883a 	add	r2,r3,r2
8113719c:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
811371a0:	e0fffe17 	ldw	r3,-8(fp)
811371a4:	00900034 	movhi	r2,16384
811371a8:	10bfffc4 	addi	r2,r2,-1
811371ac:	1886703a 	and	r3,r3,r2
811371b0:	e0bffc17 	ldw	r2,-16(fp)
811371b4:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
811371b8:	e0bffb17 	ldw	r2,-20(fp)
811371bc:	1000051e 	bne	r2,zero,811371d4 <open+0xd8>
811371c0:	e13ffc17 	ldw	r4,-16(fp)
811371c4:	11370300 	call	81137030 <alt_file_locked>
811371c8:	e0bffa15 	stw	r2,-24(fp)
811371cc:	e0bffa17 	ldw	r2,-24(fp)
811371d0:	10001016 	blt	r2,zero,81137214 <open+0x118>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
811371d4:	e0bff817 	ldw	r2,-32(fp)
811371d8:	10800317 	ldw	r2,12(r2)
811371dc:	10000826 	beq	r2,zero,81137200 <open+0x104>
811371e0:	e0bff817 	ldw	r2,-32(fp)
811371e4:	10800317 	ldw	r2,12(r2)
811371e8:	e1ffff17 	ldw	r7,-4(fp)
811371ec:	e1bffe17 	ldw	r6,-8(fp)
811371f0:	e17ffd17 	ldw	r5,-12(fp)
811371f4:	e13ffc17 	ldw	r4,-16(fp)
811371f8:	103ee83a 	callr	r2
811371fc:	00000106 	br	81137204 <open+0x108>
81137200:	0005883a 	mov	r2,zero
81137204:	e0bffa15 	stw	r2,-24(fp)
81137208:	00000206 	br	81137214 <open+0x118>
      }
    }
  }
  else
  {
    status = -ENODEV;
8113720c:	00bffb44 	movi	r2,-19
81137210:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
81137214:	e0bffa17 	ldw	r2,-24(fp)
81137218:	1000090e 	bge	r2,zero,81137240 <open+0x144>
  {
    alt_release_fd (index);  
8113721c:	e13ff917 	ldw	r4,-28(fp)
81137220:	11373a00 	call	811373a0 <alt_release_fd>
    ALT_ERRNO = -status;
81137224:	1136fec0 	call	81136fec <alt_get_errno>
81137228:	1007883a 	mov	r3,r2
8113722c:	e0bffa17 	ldw	r2,-24(fp)
81137230:	0085c83a 	sub	r2,zero,r2
81137234:	18800015 	stw	r2,0(r3)
    return -1;
81137238:	00bfffc4 	movi	r2,-1
8113723c:	00000106 	br	81137244 <open+0x148>
  }
  
  /* return the reference upon success */

  return index;
81137240:	e0bff917 	ldw	r2,-28(fp)
}
81137244:	e037883a 	mov	sp,fp
81137248:	dfc00117 	ldw	ra,4(sp)
8113724c:	df000017 	ldw	fp,0(sp)
81137250:	dec00204 	addi	sp,sp,8
81137254:	f800283a 	ret

81137258 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81137258:	defffe04 	addi	sp,sp,-8
8113725c:	de00012e 	bgeu	sp,et,81137264 <alt_get_errno+0xc>
81137260:	003b68fa 	trap	3
81137264:	dfc00115 	stw	ra,4(sp)
81137268:	df000015 	stw	fp,0(sp)
8113726c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81137270:	d0a01017 	ldw	r2,-32704(gp)
81137274:	10000326 	beq	r2,zero,81137284 <alt_get_errno+0x2c>
81137278:	d0a01017 	ldw	r2,-32704(gp)
8113727c:	103ee83a 	callr	r2
81137280:	00000106 	br	81137288 <alt_get_errno+0x30>
81137284:	d0a07804 	addi	r2,gp,-32288
}
81137288:	e037883a 	mov	sp,fp
8113728c:	dfc00117 	ldw	ra,4(sp)
81137290:	df000017 	ldw	fp,0(sp)
81137294:	dec00204 	addi	sp,sp,8
81137298:	f800283a 	ret

8113729c <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
8113729c:	defff904 	addi	sp,sp,-28
811372a0:	de00012e 	bgeu	sp,et,811372a8 <read+0xc>
811372a4:	003b68fa 	trap	3
811372a8:	dfc00615 	stw	ra,24(sp)
811372ac:	df000515 	stw	fp,20(sp)
811372b0:	df000504 	addi	fp,sp,20
811372b4:	e13ffd15 	stw	r4,-12(fp)
811372b8:	e17ffe15 	stw	r5,-8(fp)
811372bc:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
811372c0:	e0bffd17 	ldw	r2,-12(fp)
811372c4:	10000616 	blt	r2,zero,811372e0 <read+0x44>
811372c8:	e0bffd17 	ldw	r2,-12(fp)
811372cc:	10c00324 	muli	r3,r2,12
811372d0:	00a04574 	movhi	r2,33045
811372d4:	1085c004 	addi	r2,r2,5888
811372d8:	1885883a 	add	r2,r3,r2
811372dc:	00000106 	br	811372e4 <read+0x48>
811372e0:	0005883a 	mov	r2,zero
811372e4:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
811372e8:	e0bffb17 	ldw	r2,-20(fp)
811372ec:	10002226 	beq	r2,zero,81137378 <read+0xdc>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
811372f0:	e0bffb17 	ldw	r2,-20(fp)
811372f4:	10800217 	ldw	r2,8(r2)
811372f8:	108000cc 	andi	r2,r2,3
811372fc:	10800060 	cmpeqi	r2,r2,1
81137300:	1000181e 	bne	r2,zero,81137364 <read+0xc8>
        (fd->dev->read))
81137304:	e0bffb17 	ldw	r2,-20(fp)
81137308:	10800017 	ldw	r2,0(r2)
8113730c:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
81137310:	10001426 	beq	r2,zero,81137364 <read+0xc8>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
81137314:	e0bffb17 	ldw	r2,-20(fp)
81137318:	10800017 	ldw	r2,0(r2)
8113731c:	10800517 	ldw	r2,20(r2)
81137320:	e0ffff17 	ldw	r3,-4(fp)
81137324:	180d883a 	mov	r6,r3
81137328:	e17ffe17 	ldw	r5,-8(fp)
8113732c:	e13ffb17 	ldw	r4,-20(fp)
81137330:	103ee83a 	callr	r2
81137334:	e0bffc15 	stw	r2,-16(fp)
81137338:	e0bffc17 	ldw	r2,-16(fp)
8113733c:	1000070e 	bge	r2,zero,8113735c <read+0xc0>
        {
          ALT_ERRNO = -rval;
81137340:	11372580 	call	81137258 <alt_get_errno>
81137344:	1007883a 	mov	r3,r2
81137348:	e0bffc17 	ldw	r2,-16(fp)
8113734c:	0085c83a 	sub	r2,zero,r2
81137350:	18800015 	stw	r2,0(r3)
          return -1;
81137354:	00bfffc4 	movi	r2,-1
81137358:	00000c06 	br	8113738c <read+0xf0>
        }
        return rval;
8113735c:	e0bffc17 	ldw	r2,-16(fp)
81137360:	00000a06 	br	8113738c <read+0xf0>
      }
      else
      {
        ALT_ERRNO = EACCES;
81137364:	11372580 	call	81137258 <alt_get_errno>
81137368:	1007883a 	mov	r3,r2
8113736c:	00800344 	movi	r2,13
81137370:	18800015 	stw	r2,0(r3)
81137374:	00000406 	br	81137388 <read+0xec>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
81137378:	11372580 	call	81137258 <alt_get_errno>
8113737c:	1007883a 	mov	r3,r2
81137380:	00801444 	movi	r2,81
81137384:	18800015 	stw	r2,0(r3)
  }
  return -1;
81137388:	00bfffc4 	movi	r2,-1
}
8113738c:	e037883a 	mov	sp,fp
81137390:	dfc00117 	ldw	ra,4(sp)
81137394:	df000017 	ldw	fp,0(sp)
81137398:	dec00204 	addi	sp,sp,8
8113739c:	f800283a 	ret

811373a0 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
811373a0:	defffe04 	addi	sp,sp,-8
811373a4:	de00012e 	bgeu	sp,et,811373ac <alt_release_fd+0xc>
811373a8:	003b68fa 	trap	3
811373ac:	df000115 	stw	fp,4(sp)
811373b0:	df000104 	addi	fp,sp,4
811373b4:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
811373b8:	e0bfff17 	ldw	r2,-4(fp)
811373bc:	108000d0 	cmplti	r2,r2,3
811373c0:	10000d1e 	bne	r2,zero,811373f8 <alt_release_fd+0x58>
  {
    alt_fd_list[fd].fd_flags = 0;
811373c4:	00a04574 	movhi	r2,33045
811373c8:	1085c004 	addi	r2,r2,5888
811373cc:	e0ffff17 	ldw	r3,-4(fp)
811373d0:	18c00324 	muli	r3,r3,12
811373d4:	10c5883a 	add	r2,r2,r3
811373d8:	10800204 	addi	r2,r2,8
811373dc:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
811373e0:	00a04574 	movhi	r2,33045
811373e4:	1085c004 	addi	r2,r2,5888
811373e8:	e0ffff17 	ldw	r3,-4(fp)
811373ec:	18c00324 	muli	r3,r3,12
811373f0:	10c5883a 	add	r2,r2,r3
811373f4:	10000015 	stw	zero,0(r2)
  }
}
811373f8:	0001883a 	nop
811373fc:	e037883a 	mov	sp,fp
81137400:	df000017 	ldw	fp,0(sp)
81137404:	dec00104 	addi	sp,sp,4
81137408:	f800283a 	ret

8113740c <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
8113740c:	defff604 	addi	sp,sp,-40
81137410:	de00012e 	bgeu	sp,et,81137418 <sbrk+0xc>
81137414:	003b68fa 	trap	3
81137418:	df000915 	stw	fp,36(sp)
8113741c:	df000904 	addi	fp,sp,36
81137420:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137424:	0005303a 	rdctl	r2,status
81137428:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113742c:	e0fffe17 	ldw	r3,-8(fp)
81137430:	00bfff84 	movi	r2,-2
81137434:	1884703a 	and	r2,r3,r2
81137438:	1001703a 	wrctl	status,r2
  
  return context;
8113743c:	e0bffe17 	ldw	r2,-8(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
81137440:	e0bff815 	stw	r2,-32(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
81137444:	d0a01317 	ldw	r2,-32692(gp)
81137448:	10c000c4 	addi	r3,r2,3
8113744c:	00bfff04 	movi	r2,-4
81137450:	1884703a 	and	r2,r3,r2
81137454:	d0a01315 	stw	r2,-32692(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
81137458:	d0e01317 	ldw	r3,-32692(gp)
8113745c:	e0bfff17 	ldw	r2,-4(fp)
81137460:	1887883a 	add	r3,r3,r2
81137464:	00a04834 	movhi	r2,33056
81137468:	10a80004 	addi	r2,r2,-24576
8113746c:	10c0062e 	bgeu	r2,r3,81137488 <sbrk+0x7c>
81137470:	e0bff817 	ldw	r2,-32(fp)
81137474:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137478:	e0bff717 	ldw	r2,-36(fp)
8113747c:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
81137480:	00bfffc4 	movi	r2,-1
81137484:	00001c06 	br	811374f8 <sbrk+0xec>
  }
#endif

  prev_heap_end = heap_end; 
81137488:	d0a01317 	ldw	r2,-32692(gp)
8113748c:	e0bffa15 	stw	r2,-24(fp)
  heap_end += incr; 
81137490:	d0e01317 	ldw	r3,-32692(gp)
81137494:	e0bfff17 	ldw	r2,-4(fp)
81137498:	1885883a 	add	r2,r3,r2
8113749c:	d0a01315 	stw	r2,-32692(gp)
 */

static ALT_INLINE char * ALT_ALWAYS_INLINE alt_stack_limit (void)
{
  char * limit;
  NIOS2_READ_ET(limit);
811374a0:	c005883a 	mov	r2,et
811374a4:	e0bff915 	stw	r2,-28(fp)

  return limit; 
811374a8:	e0fff917 	ldw	r3,-28(fp)
   * pointer overflow. 
   * If the stack limit isn't pointing at the top of the heap then the code
   * is using a different stack so none of this needs to be done.
   */

  if (alt_stack_limit() == prev_heap_end)
811374ac:	e0bffa17 	ldw	r2,-24(fp)
811374b0:	18800c1e 	bne	r3,r2,811374e4 <sbrk+0xd8>
 */

static ALT_INLINE char * ALT_ALWAYS_INLINE alt_stack_pointer (void)
{
  char * pointer;
  NIOS2_READ_SP(pointer);
811374b4:	d805883a 	mov	r2,sp
811374b8:	e0bffb15 	stw	r2,-20(fp)

  return pointer; 
811374bc:	e0bffb17 	ldw	r2,-20(fp)
  {
    if (alt_stack_pointer() <= heap_end)
811374c0:	d0e01317 	ldw	r3,-32692(gp)
811374c4:	18800136 	bltu	r3,r2,811374cc <sbrk+0xc0>
 * alt_report_stack_overflow reports that a stack overflow happened.
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_report_stack_overflow (void)
{
  NIOS2_REPORT_STACK_OVERFLOW();
811374c8:	003da0fa 	break	3
      alt_report_stack_overflow();

    alt_set_stack_limit(heap_end);
811374cc:	d0a01317 	ldw	r2,-32692(gp)
811374d0:	e0bffc15 	stw	r2,-16(fp)
 * limit register.
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_set_stack_limit (char * limit)
{
  alt_stack_limit_value = limit;
811374d4:	e0bffc17 	ldw	r2,-16(fp)
811374d8:	d0a00015 	stw	r2,-32768(gp)
  NIOS2_WRITE_ET(limit);
811374dc:	e0bffc17 	ldw	r2,-16(fp)
811374e0:	1031883a 	mov	et,r2
811374e4:	e0bff817 	ldw	r2,-32(fp)
811374e8:	e0bffd15 	stw	r2,-12(fp)
811374ec:	e0bffd17 	ldw	r2,-12(fp)
811374f0:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
811374f4:	e0bffa17 	ldw	r2,-24(fp)
} 
811374f8:	e037883a 	mov	sp,fp
811374fc:	df000017 	ldw	fp,0(sp)
81137500:	dec00104 	addi	sp,sp,4
81137504:	f800283a 	ret

81137508 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
81137508:	defffa04 	addi	sp,sp,-24
8113750c:	de00012e 	bgeu	sp,et,81137514 <alt_alarm_stop+0xc>
81137510:	003b68fa 	trap	3
81137514:	df000515 	stw	fp,20(sp)
81137518:	df000504 	addi	fp,sp,20
8113751c:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137520:	0005303a 	rdctl	r2,status
81137524:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137528:	e0fffc17 	ldw	r3,-16(fp)
8113752c:	00bfff84 	movi	r2,-2
81137530:	1884703a 	and	r2,r3,r2
81137534:	1001703a 	wrctl	status,r2
  
  return context;
81137538:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
8113753c:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
81137540:	e0bfff17 	ldw	r2,-4(fp)
81137544:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
81137548:	e0bffd17 	ldw	r2,-12(fp)
8113754c:	10800017 	ldw	r2,0(r2)
81137550:	e0fffd17 	ldw	r3,-12(fp)
81137554:	18c00117 	ldw	r3,4(r3)
81137558:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
8113755c:	e0bffd17 	ldw	r2,-12(fp)
81137560:	10800117 	ldw	r2,4(r2)
81137564:	e0fffd17 	ldw	r3,-12(fp)
81137568:	18c00017 	ldw	r3,0(r3)
8113756c:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
81137570:	e0bffd17 	ldw	r2,-12(fp)
81137574:	e0fffd17 	ldw	r3,-12(fp)
81137578:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
8113757c:	e0bffd17 	ldw	r2,-12(fp)
81137580:	e0fffd17 	ldw	r3,-12(fp)
81137584:	10c00015 	stw	r3,0(r2)
81137588:	e0bffb17 	ldw	r2,-20(fp)
8113758c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137590:	e0bffe17 	ldw	r2,-8(fp)
81137594:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
81137598:	0001883a 	nop
8113759c:	e037883a 	mov	sp,fp
811375a0:	df000017 	ldw	fp,0(sp)
811375a4:	dec00104 	addi	sp,sp,4
811375a8:	f800283a 	ret

811375ac <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
811375ac:	defffb04 	addi	sp,sp,-20
811375b0:	de00012e 	bgeu	sp,et,811375b8 <alt_tick+0xc>
811375b4:	003b68fa 	trap	3
811375b8:	dfc00415 	stw	ra,16(sp)
811375bc:	df000315 	stw	fp,12(sp)
811375c0:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
811375c4:	d0a01417 	ldw	r2,-32688(gp)
811375c8:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
811375cc:	d0a08917 	ldw	r2,-32220(gp)
811375d0:	10800044 	addi	r2,r2,1
811375d4:	d0a08915 	stw	r2,-32220(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
811375d8:	00002e06 	br	81137694 <alt_tick+0xe8>
  {
    next = (alt_alarm*) alarm->llist.next;
811375dc:	e0bffd17 	ldw	r2,-12(fp)
811375e0:	10800017 	ldw	r2,0(r2)
811375e4:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
811375e8:	e0bffd17 	ldw	r2,-12(fp)
811375ec:	10800403 	ldbu	r2,16(r2)
811375f0:	10803fcc 	andi	r2,r2,255
811375f4:	10000426 	beq	r2,zero,81137608 <alt_tick+0x5c>
811375f8:	d0a08917 	ldw	r2,-32220(gp)
811375fc:	1000021e 	bne	r2,zero,81137608 <alt_tick+0x5c>
    {
      alarm->rollover = 0;
81137600:	e0bffd17 	ldw	r2,-12(fp)
81137604:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
81137608:	e0bffd17 	ldw	r2,-12(fp)
8113760c:	10800217 	ldw	r2,8(r2)
81137610:	d0e08917 	ldw	r3,-32220(gp)
81137614:	18801d36 	bltu	r3,r2,8113768c <alt_tick+0xe0>
81137618:	e0bffd17 	ldw	r2,-12(fp)
8113761c:	10800403 	ldbu	r2,16(r2)
81137620:	10803fcc 	andi	r2,r2,255
81137624:	1000191e 	bne	r2,zero,8113768c <alt_tick+0xe0>
    {
      next_callback = alarm->callback (alarm->context);
81137628:	e0bffd17 	ldw	r2,-12(fp)
8113762c:	10800317 	ldw	r2,12(r2)
81137630:	e0fffd17 	ldw	r3,-12(fp)
81137634:	18c00517 	ldw	r3,20(r3)
81137638:	1809883a 	mov	r4,r3
8113763c:	103ee83a 	callr	r2
81137640:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
81137644:	e0bfff17 	ldw	r2,-4(fp)
81137648:	1000031e 	bne	r2,zero,81137658 <alt_tick+0xac>
      {
        alt_alarm_stop (alarm);
8113764c:	e13ffd17 	ldw	r4,-12(fp)
81137650:	11375080 	call	81137508 <alt_alarm_stop>
81137654:	00000d06 	br	8113768c <alt_tick+0xe0>
      }
      else
      {
        alarm->time += next_callback;
81137658:	e0bffd17 	ldw	r2,-12(fp)
8113765c:	10c00217 	ldw	r3,8(r2)
81137660:	e0bfff17 	ldw	r2,-4(fp)
81137664:	1887883a 	add	r3,r3,r2
81137668:	e0bffd17 	ldw	r2,-12(fp)
8113766c:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
81137670:	e0bffd17 	ldw	r2,-12(fp)
81137674:	10c00217 	ldw	r3,8(r2)
81137678:	d0a08917 	ldw	r2,-32220(gp)
8113767c:	1880032e 	bgeu	r3,r2,8113768c <alt_tick+0xe0>
        {
          alarm->rollover = 1;
81137680:	e0bffd17 	ldw	r2,-12(fp)
81137684:	00c00044 	movi	r3,1
81137688:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
8113768c:	e0bffe17 	ldw	r2,-8(fp)
81137690:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
81137694:	e0fffd17 	ldw	r3,-12(fp)
81137698:	d0a01404 	addi	r2,gp,-32688
8113769c:	18bfcf1e 	bne	r3,r2,811375dc <__reset+0xfb1175dc>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
811376a0:	11388dc0 	call	811388dc <OSTimeTick>
}
811376a4:	0001883a 	nop
811376a8:	e037883a 	mov	sp,fp
811376ac:	dfc00117 	ldw	ra,4(sp)
811376b0:	df000017 	ldw	fp,0(sp)
811376b4:	dec00204 	addi	sp,sp,8
811376b8:	f800283a 	ret

811376bc <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
811376bc:	defffb04 	addi	sp,sp,-20
811376c0:	de00012e 	bgeu	sp,et,811376c8 <usleep+0xc>
811376c4:	003b68fa 	trap	3
811376c8:	dfc00415 	stw	ra,16(sp)
811376cc:	df000315 	stw	fp,12(sp)
811376d0:	df000304 	addi	fp,sp,12
811376d4:	e13fff15 	stw	r4,-4(fp)
   * If the O/S hasn't started yet, then we delay using a busy loop, rather than
   * OSTimeDly (since this would fail). The use of a busy loop is acceptable,
   * since the system is still running in a single-threaded mode.
   */ 

  if (OSRunning == OS_FALSE)
811376d8:	d0a09103 	ldbu	r2,-32188(gp)
811376dc:	10803fcc 	andi	r2,r2,255
811376e0:	1000031e 	bne	r2,zero,811376f0 <usleep+0x34>
  {
    return alt_busy_sleep (us);
811376e4:	e13fff17 	ldw	r4,-4(fp)
811376e8:	1135c480 	call	81135c48 <alt_busy_sleep>
811376ec:	00003d06 	br	811377e4 <usleep+0x128>
811376f0:	d0a08817 	ldw	r2,-32224(gp)

  /* 
   * Calculate the number of whole system clock ticks to delay.
   */

  tick_rate = alt_ticks_per_second ();
811376f4:	e0bffe15 	stw	r2,-8(fp)
  ticks     = (us/ALT_US)* tick_rate + ((us%ALT_US)*tick_rate)/ALT_US;
811376f8:	e0ffff17 	ldw	r3,-4(fp)
811376fc:	0090c734 	movhi	r2,17180
81137700:	10b7a0c4 	addi	r2,r2,-8573
81137704:	1888383a 	mulxuu	r4,r3,r2
81137708:	1885383a 	mul	r2,r3,r2
8113770c:	1013883a 	mov	r9,r2
81137710:	2015883a 	mov	r10,r4
81137714:	5006d4ba 	srli	r3,r10,18
81137718:	e0bffe17 	ldw	r2,-8(fp)
8113771c:	1893383a 	mul	r9,r3,r2
81137720:	e0ffff17 	ldw	r3,-4(fp)
81137724:	0090c734 	movhi	r2,17180
81137728:	10b7a0c4 	addi	r2,r2,-8573
8113772c:	1888383a 	mulxuu	r4,r3,r2
81137730:	1885383a 	mul	r2,r3,r2
81137734:	100f883a 	mov	r7,r2
81137738:	2011883a 	mov	r8,r4
8113773c:	4004d4ba 	srli	r2,r8,18
81137740:	010003f4 	movhi	r4,15
81137744:	21109004 	addi	r4,r4,16960
81137748:	1105383a 	mul	r2,r2,r4
8113774c:	1885c83a 	sub	r2,r3,r2
81137750:	e0fffe17 	ldw	r3,-8(fp)
81137754:	10c7383a 	mul	r3,r2,r3
81137758:	0090c734 	movhi	r2,17180
8113775c:	10b7a0c4 	addi	r2,r2,-8573
81137760:	1888383a 	mulxuu	r4,r3,r2
81137764:	1885383a 	mul	r2,r3,r2
81137768:	100b883a 	mov	r5,r2
8113776c:	200d883a 	mov	r6,r4
81137770:	3004d4ba 	srli	r2,r6,18
81137774:	4885883a 	add	r2,r9,r2
81137778:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
8113777c:	00000706 	br	8113779c <usleep+0xe0>
  {
    OSTimeDly(0xffff);
81137780:	013fffd4 	movui	r4,65535
81137784:	114034c0 	call	8114034c <OSTimeDly>
    ticks -= 0xffff;
81137788:	e0fffd17 	ldw	r3,-12(fp)
8113778c:	00bffff4 	movhi	r2,65535
81137790:	10800044 	addi	r2,r2,1
81137794:	1885883a 	add	r2,r3,r2
81137798:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
8113779c:	e0bffd17 	ldw	r2,-12(fp)
811377a0:	00ffffd4 	movui	r3,65535
811377a4:	18bff636 	bltu	r3,r2,81137780 <__reset+0xfb117780>
  {
    OSTimeDly(0xffff);
    ticks -= 0xffff;
  }

  OSTimeDly ((INT16U) (ticks));
811377a8:	e0bffd17 	ldw	r2,-12(fp)
811377ac:	10bfffcc 	andi	r2,r2,65535
811377b0:	1009883a 	mov	r4,r2
811377b4:	114034c0 	call	8114034c <OSTimeDly>
  /*
   * Now delay by the remainder using a busy loop. This is here in order to
   * provide very short delays of less than one clock tick.
   */

  alt_busy_sleep (us%(ALT_US/tick_rate));  
811377b8:	008003f4 	movhi	r2,15
811377bc:	10909004 	addi	r2,r2,16960
811377c0:	e0fffe17 	ldw	r3,-8(fp)
811377c4:	10c7203a 	divu	r3,r2,r3
811377c8:	e0bfff17 	ldw	r2,-4(fp)
811377cc:	10c9203a 	divu	r4,r2,r3
811377d0:	20c7383a 	mul	r3,r4,r3
811377d4:	10c5c83a 	sub	r2,r2,r3
811377d8:	1009883a 	mov	r4,r2
811377dc:	1135c480 	call	81135c48 <alt_busy_sleep>

  return 0;  
811377e0:	0005883a 	mov	r2,zero
}
811377e4:	e037883a 	mov	sp,fp
811377e8:	dfc00117 	ldw	ra,4(sp)
811377ec:	df000017 	ldw	fp,0(sp)
811377f0:	dec00204 	addi	sp,sp,8
811377f4:	f800283a 	ret

811377f8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811377f8:	defffe04 	addi	sp,sp,-8
811377fc:	de00012e 	bgeu	sp,et,81137804 <alt_get_errno+0xc>
81137800:	003b68fa 	trap	3
81137804:	dfc00115 	stw	ra,4(sp)
81137808:	df000015 	stw	fp,0(sp)
8113780c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81137810:	d0a01017 	ldw	r2,-32704(gp)
81137814:	10000326 	beq	r2,zero,81137824 <alt_get_errno+0x2c>
81137818:	d0a01017 	ldw	r2,-32704(gp)
8113781c:	103ee83a 	callr	r2
81137820:	00000106 	br	81137828 <alt_get_errno+0x30>
81137824:	d0a07804 	addi	r2,gp,-32288
}
81137828:	e037883a 	mov	sp,fp
8113782c:	dfc00117 	ldw	ra,4(sp)
81137830:	df000017 	ldw	fp,0(sp)
81137834:	dec00204 	addi	sp,sp,8
81137838:	f800283a 	ret

8113783c <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
8113783c:	defff904 	addi	sp,sp,-28
81137840:	de00012e 	bgeu	sp,et,81137848 <write+0xc>
81137844:	003b68fa 	trap	3
81137848:	dfc00615 	stw	ra,24(sp)
8113784c:	df000515 	stw	fp,20(sp)
81137850:	df000504 	addi	fp,sp,20
81137854:	e13ffd15 	stw	r4,-12(fp)
81137858:	e17ffe15 	stw	r5,-8(fp)
8113785c:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81137860:	e0bffd17 	ldw	r2,-12(fp)
81137864:	10000616 	blt	r2,zero,81137880 <write+0x44>
81137868:	e0bffd17 	ldw	r2,-12(fp)
8113786c:	10c00324 	muli	r3,r2,12
81137870:	00a04574 	movhi	r2,33045
81137874:	1085c004 	addi	r2,r2,5888
81137878:	1885883a 	add	r2,r3,r2
8113787c:	00000106 	br	81137884 <write+0x48>
81137880:	0005883a 	mov	r2,zero
81137884:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
81137888:	e0bffb17 	ldw	r2,-20(fp)
8113788c:	10002426 	beq	r2,zero,81137920 <write+0xe4>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
81137890:	e0bffb17 	ldw	r2,-20(fp)
81137894:	10800217 	ldw	r2,8(r2)
81137898:	108000cc 	andi	r2,r2,3
8113789c:	10001b26 	beq	r2,zero,8113790c <write+0xd0>
811378a0:	e0bffb17 	ldw	r2,-20(fp)
811378a4:	10800017 	ldw	r2,0(r2)
811378a8:	10800617 	ldw	r2,24(r2)
811378ac:	10001726 	beq	r2,zero,8113790c <write+0xd0>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);
811378b0:	e17fff17 	ldw	r5,-4(fp)
811378b4:	e13ffe17 	ldw	r4,-8(fp)
811378b8:	1136bbc0 	call	81136bbc <alt_log_write>

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
811378bc:	e0bffb17 	ldw	r2,-20(fp)
811378c0:	10800017 	ldw	r2,0(r2)
811378c4:	10800617 	ldw	r2,24(r2)
811378c8:	e0ffff17 	ldw	r3,-4(fp)
811378cc:	180d883a 	mov	r6,r3
811378d0:	e17ffe17 	ldw	r5,-8(fp)
811378d4:	e13ffb17 	ldw	r4,-20(fp)
811378d8:	103ee83a 	callr	r2
811378dc:	e0bffc15 	stw	r2,-16(fp)
811378e0:	e0bffc17 	ldw	r2,-16(fp)
811378e4:	1000070e 	bge	r2,zero,81137904 <write+0xc8>
      {
        ALT_ERRNO = -rval;
811378e8:	11377f80 	call	811377f8 <alt_get_errno>
811378ec:	1007883a 	mov	r3,r2
811378f0:	e0bffc17 	ldw	r2,-16(fp)
811378f4:	0085c83a 	sub	r2,zero,r2
811378f8:	18800015 	stw	r2,0(r3)
        return -1;
811378fc:	00bfffc4 	movi	r2,-1
81137900:	00000c06 	br	81137934 <write+0xf8>
      }
      return rval;
81137904:	e0bffc17 	ldw	r2,-16(fp)
81137908:	00000a06 	br	81137934 <write+0xf8>
    }
    else
    {
      ALT_ERRNO = EACCES;
8113790c:	11377f80 	call	811377f8 <alt_get_errno>
81137910:	1007883a 	mov	r3,r2
81137914:	00800344 	movi	r2,13
81137918:	18800015 	stw	r2,0(r3)
8113791c:	00000406 	br	81137930 <write+0xf4>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
81137920:	11377f80 	call	811377f8 <alt_get_errno>
81137924:	1007883a 	mov	r3,r2
81137928:	00801444 	movi	r2,81
8113792c:	18800015 	stw	r2,0(r3)
  }
  return -1;
81137930:	00bfffc4 	movi	r2,-1
}
81137934:	e037883a 	mov	sp,fp
81137938:	dfc00117 	ldw	ra,4(sp)
8113793c:	df000017 	ldw	fp,0(sp)
81137940:	dec00204 	addi	sp,sp,8
81137944:	f800283a 	ret

81137948 <__env_lock>:
/*
 *
 */

void __env_lock ( struct _reent *_r )
{
81137948:	deffde04 	addi	sp,sp,-136
8113794c:	de00012e 	bgeu	sp,et,81137954 <__env_lock+0xc>
81137950:	003b68fa 	trap	3
81137954:	dfc02115 	stw	ra,132(sp)
81137958:	df002015 	stw	fp,128(sp)
8113795c:	df002004 	addi	fp,sp,128
81137960:	e13fff15 	stw	r4,-4(fp)
  INT8U err;
  int id;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
81137964:	e0bfe104 	addi	r2,fp,-124
81137968:	100b883a 	mov	r5,r2
8113796c:	01003fc4 	movi	r4,255
81137970:	11401a80 	call	811401a8 <OSTaskQuery>
81137974:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
81137978:	e0bffe83 	ldbu	r2,-6(fp)
8113797c:	10803fcc 	andi	r2,r2,255
81137980:	10001e1e 	bne	r2,zero,811379fc <__env_lock+0xb4>
    return;

  id = tcb.OSTCBPrio;
81137984:	e0bfed83 	ldbu	r2,-74(fp)
81137988:	10803fcc 	andi	r2,r2,255
8113798c:	e0bfe015 	stw	r2,-128(fp)
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
81137990:	d0a08b17 	ldw	r2,-32212(gp)
81137994:	e0fffc04 	addi	r3,fp,-16
81137998:	180b883a 	mov	r5,r3
8113799c:	1009883a 	mov	r4,r2
811379a0:	113e9600 	call	8113e960 <OSSemQuery>
  if( semdata.OSEventGrp && id == lockid ) 
811379a4:	e0bffe03 	ldbu	r2,-8(fp)
811379a8:	10803fcc 	andi	r2,r2,255
811379ac:	10000726 	beq	r2,zero,811379cc <__env_lock+0x84>
811379b0:	d0a01617 	ldw	r2,-32680(gp)
811379b4:	e0ffe017 	ldw	r3,-128(fp)
811379b8:	1880041e 	bne	r3,r2,811379cc <__env_lock+0x84>
  {
    /* we do; just count the recursion */

    locks++;
811379bc:	d0a08a17 	ldw	r2,-32216(gp)
811379c0:	10800044 	addi	r2,r2,1
811379c4:	d0a08a15 	stw	r2,-32216(gp)
811379c8:	00000a06 	br	811379f4 <__env_lock+0xac>
  }
  else 
  {
    /* wait on the other task to yield, then claim ownership */

    OSSemPend( alt_envsem, 0, &err );
811379cc:	d0a08b17 	ldw	r2,-32212(gp)
811379d0:	e0fffe84 	addi	r3,fp,-6
811379d4:	180d883a 	mov	r6,r3
811379d8:	000b883a 	mov	r5,zero
811379dc:	1009883a 	mov	r4,r2
811379e0:	113e4c00 	call	8113e4c0 <OSSemPend>
    locks  = 1;
811379e4:	00800044 	movi	r2,1
811379e8:	d0a08a15 	stw	r2,-32216(gp)
    lockid = id;
811379ec:	e0bfe017 	ldw	r2,-128(fp)
811379f0:	d0a01615 	stw	r2,-32680(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
811379f4:	0001883a 	nop
811379f8:	00000106 	br	81137a00 <__env_lock+0xb8>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
811379fc:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
81137a00:	e037883a 	mov	sp,fp
81137a04:	dfc00117 	ldw	ra,4(sp)
81137a08:	df000017 	ldw	fp,0(sp)
81137a0c:	dec00204 	addi	sp,sp,8
81137a10:	f800283a 	ret

81137a14 <__env_unlock>:
/*
 *
 */

void __env_unlock ( struct _reent *_r )
{
81137a14:	defffd04 	addi	sp,sp,-12
81137a18:	de00012e 	bgeu	sp,et,81137a20 <__env_unlock+0xc>
81137a1c:	003b68fa 	trap	3
81137a20:	dfc00215 	stw	ra,8(sp)
81137a24:	df000115 	stw	fp,4(sp)
81137a28:	df000104 	addi	fp,sp,4
81137a2c:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
81137a30:	d0a08a17 	ldw	r2,-32216(gp)
81137a34:	10000b26 	beq	r2,zero,81137a64 <__env_unlock+0x50>
   /* 
    * release the environment once the number of locks == the number 
    * of unlocks 
    */

  if( (--locks) == 0 ) 
81137a38:	d0a08a17 	ldw	r2,-32216(gp)
81137a3c:	10bfffc4 	addi	r2,r2,-1
81137a40:	d0a08a15 	stw	r2,-32216(gp)
81137a44:	d0a08a17 	ldw	r2,-32216(gp)
81137a48:	1000071e 	bne	r2,zero,81137a68 <__env_unlock+0x54>
  {
    lockid = -1;
81137a4c:	00bfffc4 	movi	r2,-1
81137a50:	d0a01615 	stw	r2,-32680(gp)
    OSSemPost( alt_envsem );
81137a54:	d0a08b17 	ldw	r2,-32212(gp)
81137a58:	1009883a 	mov	r4,r2
81137a5c:	113e8480 	call	8113e848 <OSSemPost>
81137a60:	00000106 	br	81137a68 <__env_unlock+0x54>

void __env_unlock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
    return;
81137a64:	0001883a 	nop
  {
    lockid = -1;
    OSSemPost( alt_envsem );
  }
#endif /* OS_THREAD_SAFE_NEWLIB */
}
81137a68:	e037883a 	mov	sp,fp
81137a6c:	dfc00117 	ldw	ra,4(sp)
81137a70:	df000017 	ldw	fp,0(sp)
81137a74:	dec00204 	addi	sp,sp,8
81137a78:	f800283a 	ret

81137a7c <__malloc_lock>:
/*
 *
 */

void __malloc_lock ( struct _reent *_r )
{
81137a7c:	deffda04 	addi	sp,sp,-152
81137a80:	de00012e 	bgeu	sp,et,81137a88 <__malloc_lock+0xc>
81137a84:	003b68fa 	trap	3
81137a88:	dfc02515 	stw	ra,148(sp)
81137a8c:	df002415 	stw	fp,144(sp)
81137a90:	df002404 	addi	fp,sp,144
81137a94:	e13fff15 	stw	r4,-4(fp)
  OS_TCB tcb;
  OS_SEM_DATA semdata;
  INT8U err;
  int id;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81137a98:	e03fdc15 	stw	zero,-144(fp)
#endif  
  
  if (OSRunning != OS_TRUE)
81137a9c:	d0a09103 	ldbu	r2,-32188(gp)
81137aa0:	10803fcc 	andi	r2,r2,255
81137aa4:	10800060 	cmpeqi	r2,r2,1
81137aa8:	10003626 	beq	r2,zero,81137b84 <__malloc_lock+0x108>
      return;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
81137aac:	e0bfe104 	addi	r2,fp,-124
81137ab0:	100b883a 	mov	r5,r2
81137ab4:	01003fc4 	movi	r4,255
81137ab8:	11401a80 	call	811401a8 <OSTaskQuery>
81137abc:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
81137ac0:	e0bffe83 	ldbu	r2,-6(fp)
81137ac4:	10803fcc 	andi	r2,r2,255
81137ac8:	1000301e 	bne	r2,zero,81137b8c <__malloc_lock+0x110>
    return;

  id = tcb.OSTCBPrio;
81137acc:	e0bfed83 	ldbu	r2,-74(fp)
81137ad0:	10803fcc 	andi	r2,r2,255
81137ad4:	e0bfdd15 	stw	r2,-140(fp)
   
  /* see if we own the heap already */

  OSSemQuery( alt_heapsem, &semdata );
81137ad8:	d0a08d17 	ldw	r2,-32204(gp)
81137adc:	e0fffc04 	addi	r3,fp,-16
81137ae0:	180b883a 	mov	r5,r3
81137ae4:	1009883a 	mov	r4,r2
81137ae8:	113e9600 	call	8113e960 <OSSemQuery>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137aec:	0005303a 	rdctl	r2,status
81137af0:	e0bfe015 	stw	r2,-128(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137af4:	e0ffe017 	ldw	r3,-128(fp)
81137af8:	00bfff84 	movi	r2,-2
81137afc:	1884703a 	and	r2,r3,r2
81137b00:	1001703a 	wrctl	status,r2
  
  return context;
81137b04:	e0bfe017 	ldw	r2,-128(fp)
  
  OS_ENTER_CRITICAL();
81137b08:	e0bfdc15 	stw	r2,-144(fp)

  if( !semdata.OSCnt && id == lockid ) 
81137b0c:	e0bffc0b 	ldhu	r2,-16(fp)
81137b10:	10bfffcc 	andi	r2,r2,65535
81137b14:	10000b1e 	bne	r2,zero,81137b44 <__malloc_lock+0xc8>
81137b18:	d0a01717 	ldw	r2,-32676(gp)
81137b1c:	e0ffdd17 	ldw	r3,-140(fp)
81137b20:	1880081e 	bne	r3,r2,81137b44 <__malloc_lock+0xc8>
  {
    /* we do; just count the recursion */
    locks++;
81137b24:	d0a08c17 	ldw	r2,-32208(gp)
81137b28:	10800044 	addi	r2,r2,1
81137b2c:	d0a08c15 	stw	r2,-32208(gp)
81137b30:	e0bfdc17 	ldw	r2,-144(fp)
81137b34:	e0bfde15 	stw	r2,-136(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137b38:	e0bfde17 	ldw	r2,-136(fp)
81137b3c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
81137b40:	00000e06 	br	81137b7c <__malloc_lock+0x100>
81137b44:	e0bfdc17 	ldw	r2,-144(fp)
81137b48:	e0bfdf15 	stw	r2,-132(fp)
81137b4c:	e0bfdf17 	ldw	r2,-132(fp)
81137b50:	1001703a 	wrctl	status,r2
  else 
  {
    /* wait on the other task to yield the heap, then claim ownership of it */
    OS_EXIT_CRITICAL();

    OSSemPend( alt_heapsem, 0, &err );
81137b54:	d0a08d17 	ldw	r2,-32204(gp)
81137b58:	e0fffe84 	addi	r3,fp,-6
81137b5c:	180d883a 	mov	r6,r3
81137b60:	000b883a 	mov	r5,zero
81137b64:	1009883a 	mov	r4,r2
81137b68:	113e4c00 	call	8113e4c0 <OSSemPend>
    locks  = 1;
81137b6c:	00800044 	movi	r2,1
81137b70:	d0a08c15 	stw	r2,-32208(gp)
    lockid = id;
81137b74:	e0bfdd17 	ldw	r2,-140(fp)
81137b78:	d0a01715 	stw	r2,-32676(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
81137b7c:	0001883a 	nop
81137b80:	00000306 	br	81137b90 <__malloc_lock+0x114>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif  
  
  if (OSRunning != OS_TRUE)
      return;
81137b84:	0001883a 	nop
81137b88:	00000106 	br	81137b90 <__malloc_lock+0x114>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
81137b8c:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
81137b90:	e037883a 	mov	sp,fp
81137b94:	dfc00117 	ldw	ra,4(sp)
81137b98:	df000017 	ldw	fp,0(sp)
81137b9c:	dec00204 	addi	sp,sp,8
81137ba0:	f800283a 	ret

81137ba4 <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
81137ba4:	defff804 	addi	sp,sp,-32
81137ba8:	de00012e 	bgeu	sp,et,81137bb0 <__malloc_unlock+0xc>
81137bac:	003b68fa 	trap	3
81137bb0:	dfc00715 	stw	ra,28(sp)
81137bb4:	df000615 	stw	fp,24(sp)
81137bb8:	df000604 	addi	fp,sp,24
81137bbc:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB

#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81137bc0:	e03ffa15 	stw	zero,-24(fp)
#endif 

  if (OSRunning != OS_TRUE)
81137bc4:	d0a09103 	ldbu	r2,-32188(gp)
81137bc8:	10803fcc 	andi	r2,r2,255
81137bcc:	10800060 	cmpeqi	r2,r2,1
81137bd0:	10002326 	beq	r2,zero,81137c60 <__malloc_unlock+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137bd4:	0005303a 	rdctl	r2,status
81137bd8:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137bdc:	e0fffe17 	ldw	r3,-8(fp)
81137be0:	00bfff84 	movi	r2,-2
81137be4:	1884703a 	and	r2,r3,r2
81137be8:	1001703a 	wrctl	status,r2
  
  return context;
81137bec:	e0bffe17 	ldw	r2,-8(fp)
      return;

  OS_ENTER_CRITICAL();
81137bf0:	e0bffa15 	stw	r2,-24(fp)
  if (locks == 0)
81137bf4:	d0a08c17 	ldw	r2,-32208(gp)
81137bf8:	1000051e 	bne	r2,zero,81137c10 <__malloc_unlock+0x6c>
81137bfc:	e0bffa17 	ldw	r2,-24(fp)
81137c00:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137c04:	e0bffb17 	ldw	r2,-20(fp)
81137c08:	1001703a 	wrctl	status,r2
  {
      OS_EXIT_CRITICAL();
      return;
81137c0c:	00001506 	br	81137c64 <__malloc_unlock+0xc0>
  }

  /* release the heap once the number of locks == the number of unlocks */
  if( (--locks) == 0 ) 
81137c10:	d0a08c17 	ldw	r2,-32208(gp)
81137c14:	10bfffc4 	addi	r2,r2,-1
81137c18:	d0a08c15 	stw	r2,-32208(gp)
81137c1c:	d0a08c17 	ldw	r2,-32208(gp)
81137c20:	10000a1e 	bne	r2,zero,81137c4c <__malloc_unlock+0xa8>
  {
    lockid = -1;
81137c24:	00bfffc4 	movi	r2,-1
81137c28:	d0a01715 	stw	r2,-32676(gp)
81137c2c:	e0bffa17 	ldw	r2,-24(fp)
81137c30:	e0bffc15 	stw	r2,-16(fp)
81137c34:	e0bffc17 	ldw	r2,-16(fp)
81137c38:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSSemPost( alt_heapsem );
81137c3c:	d0a08d17 	ldw	r2,-32204(gp)
81137c40:	1009883a 	mov	r4,r2
81137c44:	113e8480 	call	8113e848 <OSSemPost>
81137c48:	00000606 	br	81137c64 <__malloc_unlock+0xc0>
81137c4c:	e0bffa17 	ldw	r2,-24(fp)
81137c50:	e0bffd15 	stw	r2,-12(fp)
81137c54:	e0bffd17 	ldw	r2,-12(fp)
81137c58:	1001703a 	wrctl	status,r2
81137c5c:	00000106 	br	81137c64 <__malloc_unlock+0xc0>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif 

  if (OSRunning != OS_TRUE)
      return;
81137c60:	0001883a 	nop
  {
      OS_EXIT_CRITICAL();
  }
  
#endif /* OS_THREAD_SAFE_NEWLIB */
}
81137c64:	e037883a 	mov	sp,fp
81137c68:	dfc00117 	ldw	ra,4(sp)
81137c6c:	df000017 	ldw	fp,0(sp)
81137c70:	dec00204 	addi	sp,sp,8
81137c74:	f800283a 	ret

81137c78 <OSEventNameGet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
81137c78:	defff704 	addi	sp,sp,-36
81137c7c:	de00012e 	bgeu	sp,et,81137c84 <OSEventNameGet+0xc>
81137c80:	003b68fa 	trap	3
81137c84:	dfc00815 	stw	ra,32(sp)
81137c88:	df000715 	stw	fp,28(sp)
81137c8c:	df000704 	addi	fp,sp,28
81137c90:	e13ffd15 	stw	r4,-12(fp)
81137c94:	e17ffe15 	stw	r5,-8(fp)
81137c98:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81137c9c:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81137ca0:	e0bfff17 	ldw	r2,-4(fp)
81137ca4:	1000021e 	bne	r2,zero,81137cb0 <OSEventNameGet+0x38>
        return (0);
81137ca8:	0005883a 	mov	r2,zero
81137cac:	00003706 	br	81137d8c <OSEventNameGet+0x114>
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
81137cb0:	e0bffd17 	ldw	r2,-12(fp)
81137cb4:	1000051e 	bne	r2,zero,81137ccc <OSEventNameGet+0x54>
        *perr = OS_ERR_PEVENT_NULL;
81137cb8:	e0bfff17 	ldw	r2,-4(fp)
81137cbc:	00c00104 	movi	r3,4
81137cc0:	10c00005 	stb	r3,0(r2)
        return (0);
81137cc4:	0005883a 	mov	r2,zero
81137cc8:	00003006 	br	81137d8c <OSEventNameGet+0x114>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81137ccc:	e0bffe17 	ldw	r2,-8(fp)
81137cd0:	1000051e 	bne	r2,zero,81137ce8 <OSEventNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
81137cd4:	e0bfff17 	ldw	r2,-4(fp)
81137cd8:	00c00304 	movi	r3,12
81137cdc:	10c00005 	stb	r3,0(r2)
        return (0);
81137ce0:	0005883a 	mov	r2,zero
81137ce4:	00002906 	br	81137d8c <OSEventNameGet+0x114>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81137ce8:	d0a0a103 	ldbu	r2,-32124(gp)
81137cec:	10803fcc 	andi	r2,r2,255
81137cf0:	10000526 	beq	r2,zero,81137d08 <OSEventNameGet+0x90>
        *perr  = OS_ERR_NAME_GET_ISR;
81137cf4:	e0bfff17 	ldw	r2,-4(fp)
81137cf8:	00c00444 	movi	r3,17
81137cfc:	10c00005 	stb	r3,0(r2)
        return (0);
81137d00:	0005883a 	mov	r2,zero
81137d04:	00002106 	br	81137d8c <OSEventNameGet+0x114>
    }
    switch (pevent->OSEventType) {
81137d08:	e0bffd17 	ldw	r2,-12(fp)
81137d0c:	10800003 	ldbu	r2,0(r2)
81137d10:	10803fcc 	andi	r2,r2,255
81137d14:	10bfffc4 	addi	r2,r2,-1
81137d18:	10800128 	cmpgeui	r2,r2,4
81137d1c:	10000526 	beq	r2,zero,81137d34 <OSEventNameGet+0xbc>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
81137d20:	e0bfff17 	ldw	r2,-4(fp)
81137d24:	00c00044 	movi	r3,1
81137d28:	10c00005 	stb	r3,0(r2)
             return (0);
81137d2c:	0005883a 	mov	r2,zero
81137d30:	00001606 	br	81137d8c <OSEventNameGet+0x114>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
81137d34:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137d38:	0005303a 	rdctl	r2,status
81137d3c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137d40:	e0fffb17 	ldw	r3,-20(fp)
81137d44:	00bfff84 	movi	r2,-2
81137d48:	1884703a 	and	r2,r3,r2
81137d4c:	1001703a 	wrctl	status,r2
  
  return context;
81137d50:	e0bffb17 	ldw	r2,-20(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return (0);
    }
    OS_ENTER_CRITICAL();
81137d54:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
81137d58:	e0bffd17 	ldw	r2,-12(fp)
81137d5c:	10800444 	addi	r2,r2,17
81137d60:	100b883a 	mov	r5,r2
81137d64:	e13ffe17 	ldw	r4,-8(fp)
81137d68:	11397640 	call	81139764 <OS_StrCopy>
81137d6c:	e0bffa05 	stb	r2,-24(fp)
81137d70:	e0bff917 	ldw	r2,-28(fp)
81137d74:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137d78:	e0bffc17 	ldw	r2,-16(fp)
81137d7c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81137d80:	e0bfff17 	ldw	r2,-4(fp)
81137d84:	10000005 	stb	zero,0(r2)
    return (len);
81137d88:	e0bffa03 	ldbu	r2,-24(fp)
}
81137d8c:	e037883a 	mov	sp,fp
81137d90:	dfc00117 	ldw	ra,4(sp)
81137d94:	df000017 	ldw	fp,0(sp)
81137d98:	dec00204 	addi	sp,sp,8
81137d9c:	f800283a 	ret

81137da0 <OSEventNameSet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
81137da0:	defff604 	addi	sp,sp,-40
81137da4:	de00012e 	bgeu	sp,et,81137dac <OSEventNameSet+0xc>
81137da8:	003b68fa 	trap	3
81137dac:	dfc00915 	stw	ra,36(sp)
81137db0:	df000815 	stw	fp,32(sp)
81137db4:	df000804 	addi	fp,sp,32
81137db8:	e13ffd15 	stw	r4,-12(fp)
81137dbc:	e17ffe15 	stw	r5,-8(fp)
81137dc0:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81137dc4:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81137dc8:	e0bfff17 	ldw	r2,-4(fp)
81137dcc:	10004026 	beq	r2,zero,81137ed0 <OSEventNameSet+0x130>
        return;
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
81137dd0:	e0bffd17 	ldw	r2,-12(fp)
81137dd4:	1000041e 	bne	r2,zero,81137de8 <OSEventNameSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
81137dd8:	e0bfff17 	ldw	r2,-4(fp)
81137ddc:	00c00104 	movi	r3,4
81137de0:	10c00005 	stb	r3,0(r2)
        return;
81137de4:	00003b06 	br	81137ed4 <OSEventNameSet+0x134>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81137de8:	e0bffe17 	ldw	r2,-8(fp)
81137dec:	1000041e 	bne	r2,zero,81137e00 <OSEventNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
81137df0:	e0bfff17 	ldw	r2,-4(fp)
81137df4:	00c00304 	movi	r3,12
81137df8:	10c00005 	stb	r3,0(r2)
        return;
81137dfc:	00003506 	br	81137ed4 <OSEventNameSet+0x134>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81137e00:	d0a0a103 	ldbu	r2,-32124(gp)
81137e04:	10803fcc 	andi	r2,r2,255
81137e08:	10000426 	beq	r2,zero,81137e1c <OSEventNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
81137e0c:	e0bfff17 	ldw	r2,-4(fp)
81137e10:	00c00484 	movi	r3,18
81137e14:	10c00005 	stb	r3,0(r2)
        return;
81137e18:	00002e06 	br	81137ed4 <OSEventNameSet+0x134>
    }
    switch (pevent->OSEventType) {
81137e1c:	e0bffd17 	ldw	r2,-12(fp)
81137e20:	10800003 	ldbu	r2,0(r2)
81137e24:	10803fcc 	andi	r2,r2,255
81137e28:	10bfffc4 	addi	r2,r2,-1
81137e2c:	10800128 	cmpgeui	r2,r2,4
81137e30:	10000426 	beq	r2,zero,81137e44 <OSEventNameSet+0xa4>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
81137e34:	e0bfff17 	ldw	r2,-4(fp)
81137e38:	00c00044 	movi	r3,1
81137e3c:	10c00005 	stb	r3,0(r2)
             return;
81137e40:	00002406 	br	81137ed4 <OSEventNameSet+0x134>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
81137e44:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137e48:	0005303a 	rdctl	r2,status
81137e4c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137e50:	e0fffc17 	ldw	r3,-16(fp)
81137e54:	00bfff84 	movi	r2,-2
81137e58:	1884703a 	and	r2,r3,r2
81137e5c:	1001703a 	wrctl	status,r2
  
  return context;
81137e60:	e0bffc17 	ldw	r2,-16(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return;
    }
    OS_ENTER_CRITICAL();
81137e64:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
81137e68:	e13ffe17 	ldw	r4,-8(fp)
81137e6c:	11397e00 	call	811397e0 <OS_StrLen>
81137e70:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
81137e74:	e0bffa03 	ldbu	r2,-24(fp)
81137e78:	10800830 	cmpltui	r2,r2,32
81137e7c:	1000081e 	bne	r2,zero,81137ea0 <OSEventNameSet+0x100>
81137e80:	e0bff817 	ldw	r2,-32(fp)
81137e84:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137e88:	e0bff917 	ldw	r2,-28(fp)
81137e8c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_NAME_TOO_LONG;
81137e90:	e0bfff17 	ldw	r2,-4(fp)
81137e94:	00c002c4 	movi	r3,11
81137e98:	10c00005 	stb	r3,0(r2)
        return;
81137e9c:	00000d06 	br	81137ed4 <OSEventNameSet+0x134>
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
81137ea0:	e0bffd17 	ldw	r2,-12(fp)
81137ea4:	10800444 	addi	r2,r2,17
81137ea8:	e17ffe17 	ldw	r5,-8(fp)
81137eac:	1009883a 	mov	r4,r2
81137eb0:	11397640 	call	81139764 <OS_StrCopy>
81137eb4:	e0bff817 	ldw	r2,-32(fp)
81137eb8:	e0bffb15 	stw	r2,-20(fp)
81137ebc:	e0bffb17 	ldw	r2,-20(fp)
81137ec0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81137ec4:	e0bfff17 	ldw	r2,-4(fp)
81137ec8:	10000005 	stb	zero,0(r2)
81137ecc:	00000106 	br	81137ed4 <OSEventNameSet+0x134>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
81137ed0:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
81137ed4:	e037883a 	mov	sp,fp
81137ed8:	dfc00117 	ldw	ra,4(sp)
81137edc:	df000017 	ldw	fp,0(sp)
81137ee0:	dec00204 	addi	sp,sp,8
81137ee4:	f800283a 	ret

81137ee8 <OSEventPendMulti>:
*********************************************************************************************************
*/
/*$PAGE*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
{
81137ee8:	deffed04 	addi	sp,sp,-76
81137eec:	de00012e 	bgeu	sp,et,81137ef4 <OSEventPendMulti+0xc>
81137ef0:	003b68fa 	trap	3
81137ef4:	dfc01215 	stw	ra,72(sp)
81137ef8:	df001115 	stw	fp,68(sp)
81137efc:	df001104 	addi	fp,sp,68
81137f00:	e13ffc15 	stw	r4,-16(fp)
81137f04:	e17ffd15 	stw	r5,-12(fp)
81137f08:	e1bffe15 	stw	r6,-8(fp)
81137f0c:	3805883a 	mov	r2,r7
81137f10:	e0bfff0d 	sth	r2,-4(fp)
#endif
    BOOLEAN     events_rdy;
    INT16U      events_rdy_nbr;
    INT8U       events_stat;
#if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
    OS_CPU_SR   cpu_sr = 0;
81137f14:	e03ff315 	stw	zero,-52(fp)
#endif



#if (OS_ARG_CHK_EN > 0)
    if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
81137f18:	e0800217 	ldw	r2,8(fp)
81137f1c:	1000021e 	bne	r2,zero,81137f28 <OSEventPendMulti+0x40>
        return (0);
81137f20:	0005883a 	mov	r2,zero
81137f24:	00015006 	br	81138468 <OSEventPendMulti+0x580>
    }
    if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
81137f28:	e0bffc17 	ldw	r2,-16(fp)
81137f2c:	1000051e 	bne	r2,zero,81137f44 <OSEventPendMulti+0x5c>
       *perr =  OS_ERR_PEVENT_NULL;
81137f30:	e0800217 	ldw	r2,8(fp)
81137f34:	00c00104 	movi	r3,4
81137f38:	10c00005 	stb	r3,0(r2)
        return (0);
81137f3c:	0005883a 	mov	r2,zero
81137f40:	00014906 	br	81138468 <OSEventPendMulti+0x580>
    }
    if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
81137f44:	e0bffd17 	ldw	r2,-12(fp)
81137f48:	1000051e 	bne	r2,zero,81137f60 <OSEventPendMulti+0x78>
       *perr =  OS_ERR_PEVENT_NULL;
81137f4c:	e0800217 	ldw	r2,8(fp)
81137f50:	00c00104 	movi	r3,4
81137f54:	10c00005 	stb	r3,0(r2)
        return (0);
81137f58:	0005883a 	mov	r2,zero
81137f5c:	00014206 	br	81138468 <OSEventPendMulti+0x580>
    }
    if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
81137f60:	e0bffe17 	ldw	r2,-8(fp)
81137f64:	1000051e 	bne	r2,zero,81137f7c <OSEventPendMulti+0x94>
       *perr =  OS_ERR_PEVENT_NULL;
81137f68:	e0800217 	ldw	r2,8(fp)
81137f6c:	00c00104 	movi	r3,4
81137f70:	10c00005 	stb	r3,0(r2)
        return (0);
81137f74:	0005883a 	mov	r2,zero
81137f78:	00013b06 	br	81138468 <OSEventPendMulti+0x580>
    }
#endif

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
81137f7c:	e0bffd17 	ldw	r2,-12(fp)
81137f80:	10000015 	stw	zero,0(r2)

    pevents     =  pevents_pend;
81137f84:	e0bffc17 	ldw	r2,-16(fp)
81137f88:	e0bfef15 	stw	r2,-68(fp)
    pevent      = *pevents;
81137f8c:	e0bfef17 	ldw	r2,-68(fp)
81137f90:	10800017 	ldw	r2,0(r2)
81137f94:	e0bff015 	stw	r2,-64(fp)
    while  (pevent != (OS_EVENT *)0) {
81137f98:	00001506 	br	81137ff0 <OSEventPendMulti+0x108>
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
81137f9c:	e0bff017 	ldw	r2,-64(fp)
81137fa0:	10800003 	ldbu	r2,0(r2)
81137fa4:	10803fcc 	andi	r2,r2,255
81137fa8:	10c000a0 	cmpeqi	r3,r2,2
81137fac:	1800071e 	bne	r3,zero,81137fcc <OSEventPendMulti+0xe4>
81137fb0:	108000e0 	cmpeqi	r2,r2,3
81137fb4:	1000071e 	bne	r2,zero,81137fd4 <OSEventPendMulti+0xec>
#endif

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
81137fb8:	e0800217 	ldw	r2,8(fp)
81137fbc:	00c00044 	movi	r3,1
81137fc0:	10c00005 	stb	r3,0(r2)
                 return (0);
81137fc4:	0005883a 	mov	r2,zero
81137fc8:	00012706 	br	81138468 <OSEventPendMulti+0x580>
            case OS_EVENT_TYPE_MBOX:
                 break;
#endif
#if ((OS_Q_EN   > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 break;
81137fcc:	0001883a 	nop
81137fd0:	00000106 	br	81137fd8 <OSEventPendMulti+0xf0>
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
#if (OS_SEM_EN  > 0)
            case OS_EVENT_TYPE_SEM:
                 break;
81137fd4:	0001883a 	nop
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
                 return (0);
        }
        pevents++;
81137fd8:	e0bfef17 	ldw	r2,-68(fp)
81137fdc:	10800104 	addi	r2,r2,4
81137fe0:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
81137fe4:	e0bfef17 	ldw	r2,-68(fp)
81137fe8:	10800017 	ldw	r2,0(r2)
81137fec:	e0bff015 	stw	r2,-64(fp)

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */

    pevents     =  pevents_pend;
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
81137ff0:	e0bff017 	ldw	r2,-64(fp)
81137ff4:	103fe91e 	bne	r2,zero,81137f9c <__reset+0xfb117f9c>
        }
        pevents++;
        pevent = *pevents;
    }

    if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
81137ff8:	d0a0a103 	ldbu	r2,-32124(gp)
81137ffc:	10803fcc 	andi	r2,r2,255
81138000:	10000526 	beq	r2,zero,81138018 <OSEventPendMulti+0x130>
       *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
81138004:	e0800217 	ldw	r2,8(fp)
81138008:	00c00084 	movi	r3,2
8113800c:	10c00005 	stb	r3,0(r2)
        return (0);
81138010:	0005883a 	mov	r2,zero
81138014:	00011406 	br	81138468 <OSEventPendMulti+0x580>
    }
    if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
81138018:	d0a08f03 	ldbu	r2,-32196(gp)
8113801c:	10803fcc 	andi	r2,r2,255
81138020:	10000526 	beq	r2,zero,81138038 <OSEventPendMulti+0x150>
       *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
81138024:	e0800217 	ldw	r2,8(fp)
81138028:	00c00344 	movi	r3,13
8113802c:	10c00005 	stb	r3,0(r2)
        return (0);
81138030:	0005883a 	mov	r2,zero
81138034:	00010c06 	br	81138468 <OSEventPendMulti+0x580>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138038:	0005303a 	rdctl	r2,status
8113803c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138040:	e0fffb17 	ldw	r3,-20(fp)
81138044:	00bfff84 	movi	r2,-2
81138048:	1884703a 	and	r2,r3,r2
8113804c:	1001703a 	wrctl	status,r2
  
  return context;
81138050:	e0bffb17 	ldw	r2,-20(fp)
    }

/*$PAGE*/
    OS_ENTER_CRITICAL();
81138054:	e0bff315 	stw	r2,-52(fp)
    events_rdy     =  OS_FALSE;
81138058:	e03ff105 	stb	zero,-60(fp)
    events_rdy_nbr =  0;
8113805c:	e03ff18d 	sth	zero,-58(fp)
    events_stat    =  OS_STAT_RDY;
81138060:	e03ff205 	stb	zero,-56(fp)
    pevents        =  pevents_pend;
81138064:	e0bffc17 	ldw	r2,-16(fp)
81138068:	e0bfef15 	stw	r2,-68(fp)
    pevent         = *pevents;
8113806c:	e0bfef17 	ldw	r2,-68(fp)
81138070:	10800017 	ldw	r2,0(r2)
81138074:	e0bff015 	stw	r2,-64(fp)
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
81138078:	00006406 	br	8113820c <OSEventPendMulti+0x324>
        switch (pevent->OSEventType) {
8113807c:	e0bff017 	ldw	r2,-64(fp)
81138080:	10800003 	ldbu	r2,0(r2)
81138084:	10803fcc 	andi	r2,r2,255
81138088:	10c000a0 	cmpeqi	r3,r2,2
8113808c:	18001f1e 	bne	r3,zero,8113810c <OSEventPendMulti+0x224>
81138090:	108000e0 	cmpeqi	r2,r2,3
81138094:	10004c26 	beq	r2,zero,811381c8 <OSEventPendMulti+0x2e0>
#if (OS_SEM_EN > 0)
            case OS_EVENT_TYPE_SEM:
                 if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
81138098:	e0bff017 	ldw	r2,-64(fp)
8113809c:	1080020b 	ldhu	r2,8(r2)
811380a0:	10bfffcc 	andi	r2,r2,65535
811380a4:	10001526 	beq	r2,zero,811380fc <OSEventPendMulti+0x214>
                     pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
811380a8:	e0bff017 	ldw	r2,-64(fp)
811380ac:	1080020b 	ldhu	r2,8(r2)
811380b0:	10bfffc4 	addi	r2,r2,-1
811380b4:	1007883a 	mov	r3,r2
811380b8:	e0bff017 	ldw	r2,-64(fp)
811380bc:	10c0020d 	sth	r3,8(r2)
                    *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
811380c0:	e0bffd17 	ldw	r2,-12(fp)
811380c4:	10c00104 	addi	r3,r2,4
811380c8:	e0fffd15 	stw	r3,-12(fp)
811380cc:	e0fff017 	ldw	r3,-64(fp)
811380d0:	10c00015 	stw	r3,0(r2)
                      events_rdy   =  OS_TRUE;
811380d4:	00800044 	movi	r2,1
811380d8:	e0bff105 	stb	r2,-60(fp)
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
811380dc:	e0bffe17 	ldw	r2,-8(fp)
811380e0:	10c00104 	addi	r3,r2,4
811380e4:	e0fffe15 	stw	r3,-8(fp)
811380e8:	10000015 	stw	zero,0(r2)
                      events_rdy_nbr++;
811380ec:	e0bff18b 	ldhu	r2,-58(fp)
811380f0:	10800044 	addi	r2,r2,1
811380f4:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
                 }
                 break;
811380f8:	00003e06 	br	811381f4 <OSEventPendMulti+0x30c>
                      events_rdy   =  OS_TRUE;
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
                      events_rdy_nbr++;

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
811380fc:	e0bff203 	ldbu	r2,-56(fp)
81138100:	10800054 	ori	r2,r2,1
81138104:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
81138108:	00003a06 	br	811381f4 <OSEventPendMulti+0x30c>
                 break;
#endif

#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 pq = (OS_Q *)pevent->OSEventPtr;
8113810c:	e0bff017 	ldw	r2,-64(fp)
81138110:	10800117 	ldw	r2,4(r2)
81138114:	e0bff515 	stw	r2,-44(fp)
                 if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
81138118:	e0bff517 	ldw	r2,-44(fp)
8113811c:	1080058b 	ldhu	r2,22(r2)
81138120:	10bfffcc 	andi	r2,r2,65535
81138124:	10002426 	beq	r2,zero,811381b8 <OSEventPendMulti+0x2d0>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++ = (void *)*pq->OSQOut++;
81138128:	e0bffe17 	ldw	r2,-8(fp)
8113812c:	10c00104 	addi	r3,r2,4
81138130:	e0fffe15 	stw	r3,-8(fp)
81138134:	e0fff517 	ldw	r3,-44(fp)
81138138:	18c00417 	ldw	r3,16(r3)
8113813c:	19400104 	addi	r5,r3,4
81138140:	e13ff517 	ldw	r4,-44(fp)
81138144:	21400415 	stw	r5,16(r4)
81138148:	18c00017 	ldw	r3,0(r3)
8113814c:	10c00015 	stw	r3,0(r2)
                     if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
81138150:	e0bff517 	ldw	r2,-44(fp)
81138154:	10c00417 	ldw	r3,16(r2)
81138158:	e0bff517 	ldw	r2,-44(fp)
8113815c:	10800217 	ldw	r2,8(r2)
81138160:	1880041e 	bne	r3,r2,81138174 <OSEventPendMulti+0x28c>
                         pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
81138164:	e0bff517 	ldw	r2,-44(fp)
81138168:	10c00117 	ldw	r3,4(r2)
8113816c:	e0bff517 	ldw	r2,-44(fp)
81138170:	10c00415 	stw	r3,16(r2)
                     }
                     pq->OSQEntries--;                  /* Update number of queue entries              */
81138174:	e0bff517 	ldw	r2,-44(fp)
81138178:	1080058b 	ldhu	r2,22(r2)
8113817c:	10bfffc4 	addi	r2,r2,-1
81138180:	1007883a 	mov	r3,r2
81138184:	e0bff517 	ldw	r2,-44(fp)
81138188:	10c0058d 	sth	r3,22(r2)
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
8113818c:	e0bffd17 	ldw	r2,-12(fp)
81138190:	10c00104 	addi	r3,r2,4
81138194:	e0fffd15 	stw	r3,-12(fp)
81138198:	e0fff017 	ldw	r3,-64(fp)
8113819c:	10c00015 	stw	r3,0(r2)
                      events_rdy   = OS_TRUE;
811381a0:	00800044 	movi	r2,1
811381a4:	e0bff105 	stb	r2,-60(fp)
                      events_rdy_nbr++;
811381a8:	e0bff18b 	ldhu	r2,-58(fp)
811381ac:	10800044 	addi	r2,r2,1
811381b0:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
                 }
                 break;
811381b4:	00000f06 	br	811381f4 <OSEventPendMulti+0x30c>
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
                      events_rdy   = OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
811381b8:	e0bff203 	ldbu	r2,-56(fp)
811381bc:	10800114 	ori	r2,r2,4
811381c0:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
811381c4:	00000b06 	br	811381f4 <OSEventPendMulti+0x30c>
811381c8:	e0bff317 	ldw	r2,-52(fp)
811381cc:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811381d0:	e0bff417 	ldw	r2,-48(fp)
811381d4:	1001703a 	wrctl	status,r2

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                 OS_EXIT_CRITICAL();
                *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
811381d8:	e0bffd17 	ldw	r2,-12(fp)
811381dc:	10000015 	stw	zero,0(r2)
                *perr        =  OS_ERR_EVENT_TYPE;
811381e0:	e0800217 	ldw	r2,8(fp)
811381e4:	00c00044 	movi	r3,1
811381e8:	10c00005 	stb	r3,0(r2)
                 return (events_rdy_nbr);
811381ec:	e0bff18b 	ldhu	r2,-58(fp)
811381f0:	00009d06 	br	81138468 <OSEventPendMulti+0x580>
        }
        pevents++;
811381f4:	e0bfef17 	ldw	r2,-68(fp)
811381f8:	10800104 	addi	r2,r2,4
811381fc:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
81138200:	e0bfef17 	ldw	r2,-68(fp)
81138204:	10800017 	ldw	r2,0(r2)
81138208:	e0bff015 	stw	r2,-64(fp)
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0;
    events_stat    =  OS_STAT_RDY;
    pevents        =  pevents_pend;
    pevent         = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
8113820c:	e0bff017 	ldw	r2,-64(fp)
81138210:	103f9a1e 	bne	r2,zero,8113807c <__reset+0xfb11807c>
        }
        pevents++;
        pevent = *pevents;
    }

    if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
81138214:	e0bff103 	ldbu	r2,-60(fp)
81138218:	10800058 	cmpnei	r2,r2,1
8113821c:	10000a1e 	bne	r2,zero,81138248 <OSEventPendMulti+0x360>
       *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
81138220:	e0bffd17 	ldw	r2,-12(fp)
81138224:	10000015 	stw	zero,0(r2)
81138228:	e0bff317 	ldw	r2,-52(fp)
8113822c:	e0bff615 	stw	r2,-40(fp)
81138230:	e0bff617 	ldw	r2,-40(fp)
81138234:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
       *perr        =  OS_ERR_NONE;
81138238:	e0800217 	ldw	r2,8(fp)
8113823c:	10000005 	stb	zero,0(r2)
        return (events_rdy_nbr);
81138240:	e0bff18b 	ldhu	r2,-58(fp)
81138244:	00008806 	br	81138468 <OSEventPendMulti+0x580>
    }
/*$PAGE*/
                                                        /* Otherwise, must wait until any event occurs */
    OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
81138248:	d0a0a217 	ldw	r2,-32120(gp)
8113824c:	d0e0a217 	ldw	r3,-32120(gp)
81138250:	19000c03 	ldbu	r4,48(r3)
81138254:	e0fff203 	ldbu	r3,-56(fp)
81138258:	20c6b03a 	or	r3,r4,r3
8113825c:	1809883a 	mov	r4,r3
81138260:	00ffe004 	movi	r3,-128
81138264:	20c6b03a 	or	r3,r4,r3
81138268:	10c00c05 	stb	r3,48(r2)
                               OS_STAT_MULTI;           /* ... pend on multiple events                 */
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113826c:	d0a0a217 	ldw	r2,-32120(gp)
81138270:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
81138274:	d0a0a217 	ldw	r2,-32120(gp)
81138278:	e0ffff0b 	ldhu	r3,-4(fp)
8113827c:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
81138280:	e13ffc17 	ldw	r4,-16(fp)
81138284:	1138e0c0 	call	81138e0c <OS_EventTaskWaitMulti>
81138288:	e0bff317 	ldw	r2,-52(fp)
8113828c:	e0bff915 	stw	r2,-28(fp)
81138290:	e0bff917 	ldw	r2,-28(fp)
81138294:	1001703a 	wrctl	status,r2

    OS_EXIT_CRITICAL();
    OS_Sched();                                         /* Find next highest priority task ready       */
81138298:	11396100 	call	81139610 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113829c:	0005303a 	rdctl	r2,status
811382a0:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811382a4:	e0fff717 	ldw	r3,-36(fp)
811382a8:	00bfff84 	movi	r2,-2
811382ac:	1884703a 	and	r2,r3,r2
811382b0:	1001703a 	wrctl	status,r2
  
  return context;
811382b4:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
811382b8:	e0bff315 	stw	r2,-52(fp)

    switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
811382bc:	d0a0a217 	ldw	r2,-32120(gp)
811382c0:	10800c43 	ldbu	r2,49(r2)
811382c4:	10803fcc 	andi	r2,r2,255
811382c8:	10000226 	beq	r2,zero,811382d4 <OSEventPendMulti+0x3ec>
811382cc:	108000a0 	cmpeqi	r2,r2,2
811382d0:	10001826 	beq	r2,zero,81138334 <OSEventPendMulti+0x44c>
        case OS_STAT_PEND_OK:
        case OS_STAT_PEND_ABORT:
             pevent = OSTCBCur->OSTCBEventPtr;
811382d4:	d0a0a217 	ldw	r2,-32120(gp)
811382d8:	10800717 	ldw	r2,28(r2)
811382dc:	e0bff015 	stw	r2,-64(fp)
             if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
811382e0:	e0bff017 	ldw	r2,-64(fp)
811382e4:	10000b26 	beq	r2,zero,81138314 <OSEventPendMulti+0x42c>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
811382e8:	e0bffd17 	ldw	r2,-12(fp)
811382ec:	10c00104 	addi	r3,r2,4
811382f0:	e0fffd15 	stw	r3,-12(fp)
811382f4:	e0fff017 	ldw	r3,-64(fp)
811382f8:	10c00015 	stw	r3,0(r2)
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
811382fc:	e0bffd17 	ldw	r2,-12(fp)
81138300:	10000015 	stw	zero,0(r2)
                  events_rdy_nbr++;
81138304:	e0bff18b 	ldhu	r2,-58(fp)
81138308:	10800044 	addi	r2,r2,1
8113830c:	e0bff18d 	sth	r2,-58(fp)

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
             }
			 break;
81138310:	00000d06 	br	81138348 <OSEventPendMulti+0x460>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
                  events_rdy_nbr++;

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
81138314:	d0a0a217 	ldw	r2,-32120(gp)
81138318:	00c00044 	movi	r3,1
8113831c:	10c00c45 	stb	r3,49(r2)
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
81138320:	d0a0a217 	ldw	r2,-32120(gp)
81138324:	e17ffc17 	ldw	r5,-16(fp)
81138328:	1009883a 	mov	r4,r2
8113832c:	11390240 	call	81139024 <OS_EventTaskRemoveMulti>
             }
			 break;
81138330:	00000506 	br	81138348 <OSEventPendMulti+0x460>

        case OS_STAT_PEND_TO:
        default:                                        /* ... remove task from events' wait lists     */
             OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
81138334:	d0a0a217 	ldw	r2,-32120(gp)
81138338:	e17ffc17 	ldw	r5,-16(fp)
8113833c:	1009883a 	mov	r4,r2
81138340:	11390240 	call	81139024 <OS_EventTaskRemoveMulti>
             break;
81138344:	0001883a 	nop
    }

    switch (OSTCBCur->OSTCBStatPend) {
81138348:	d0a0a217 	ldw	r2,-32120(gp)
8113834c:	10800c43 	ldbu	r2,49(r2)
81138350:	10803fcc 	andi	r2,r2,255
81138354:	10000326 	beq	r2,zero,81138364 <OSEventPendMulti+0x47c>
81138358:	108000a0 	cmpeqi	r2,r2,2
8113835c:	1000231e 	bne	r2,zero,811383ec <OSEventPendMulti+0x504>
81138360:	00002a06 	br	8113840c <OSEventPendMulti+0x524>
        case OS_STAT_PEND_OK:
             switch (pevent->OSEventType) {             /* Return event's message                      */
81138364:	e0bff017 	ldw	r2,-64(fp)
81138368:	10800003 	ldbu	r2,0(r2)
8113836c:	10803fcc 	andi	r2,r2,255
81138370:	0080100e 	bge	zero,r2,811383b4 <OSEventPendMulti+0x4cc>
81138374:	10c000d0 	cmplti	r3,r2,3
81138378:	1800071e 	bne	r3,zero,81138398 <OSEventPendMulti+0x4b0>
8113837c:	108000e0 	cmpeqi	r2,r2,3
81138380:	10000c26 	beq	r2,zero,811383b4 <OSEventPendMulti+0x4cc>
#if (OS_SEM_EN > 0)
                 case OS_EVENT_TYPE_SEM:
                     *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
81138384:	e0bffe17 	ldw	r2,-8(fp)
81138388:	10c00104 	addi	r3,r2,4
8113838c:	e0fffe15 	stw	r3,-8(fp)
81138390:	10000015 	stw	zero,0(r2)
                      break;
81138394:	00001206 	br	811383e0 <OSEventPendMulti+0x4f8>

#if ((OS_MBOX_EN > 0) ||                 \
    ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
                 case OS_EVENT_TYPE_MBOX:
                 case OS_EVENT_TYPE_Q:
                     *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
81138398:	e0bffe17 	ldw	r2,-8(fp)
8113839c:	10c00104 	addi	r3,r2,4
811383a0:	e0fffe15 	stw	r3,-8(fp)
811383a4:	d0e0a217 	ldw	r3,-32120(gp)
811383a8:	18c00917 	ldw	r3,36(r3)
811383ac:	10c00015 	stw	r3,0(r2)
                      break;
811383b0:	00000b06 	br	811383e0 <OSEventPendMulti+0x4f8>
811383b4:	e0bff317 	ldw	r2,-52(fp)
811383b8:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811383bc:	e0bff817 	ldw	r2,-32(fp)
811383c0:	1001703a 	wrctl	status,r2

                 case OS_EVENT_TYPE_MUTEX:                                       
                 case OS_EVENT_TYPE_FLAG:
                 default:           
                      OS_EXIT_CRITICAL();
                     *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
811383c4:	e0bffd17 	ldw	r2,-12(fp)
811383c8:	10000015 	stw	zero,0(r2)
                     *perr        =  OS_ERR_EVENT_TYPE;
811383cc:	e0800217 	ldw	r2,8(fp)
811383d0:	00c00044 	movi	r3,1
811383d4:	10c00005 	stb	r3,0(r2)
                      return (events_rdy_nbr);
811383d8:	e0bff18b 	ldhu	r2,-58(fp)
811383dc:	00002206 	br	81138468 <OSEventPendMulti+0x580>
             }
            *perr = OS_ERR_NONE;
811383e0:	e0800217 	ldw	r2,8(fp)
811383e4:	10000005 	stb	zero,0(r2)
             break;
811383e8:	00001006 	br	8113842c <OSEventPendMulti+0x544>

        case OS_STAT_PEND_ABORT:
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
811383ec:	e0bffe17 	ldw	r2,-8(fp)
811383f0:	10c00104 	addi	r3,r2,4
811383f4:	e0fffe15 	stw	r3,-8(fp)
811383f8:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
811383fc:	e0800217 	ldw	r2,8(fp)
81138400:	00c00384 	movi	r3,14
81138404:	10c00005 	stb	r3,0(r2)
             break;
81138408:	00000806 	br	8113842c <OSEventPendMulti+0x544>
                                                        
        case OS_STAT_PEND_TO:                                                
        default:        
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
8113840c:	e0bffe17 	ldw	r2,-8(fp)
81138410:	10c00104 	addi	r3,r2,4
81138414:	e0fffe15 	stw	r3,-8(fp)
81138418:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
8113841c:	e0800217 	ldw	r2,8(fp)
81138420:	00c00284 	movi	r3,10
81138424:	10c00005 	stb	r3,0(r2)
             break;
81138428:	0001883a 	nop
    }

    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
8113842c:	d0a0a217 	ldw	r2,-32120(gp)
81138430:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
81138434:	d0a0a217 	ldw	r2,-32120(gp)
81138438:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
8113843c:	d0a0a217 	ldw	r2,-32120(gp)
81138440:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
81138444:	d0a0a217 	ldw	r2,-32120(gp)
81138448:	10000815 	stw	zero,32(r2)
    OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
8113844c:	d0a0a217 	ldw	r2,-32120(gp)
81138450:	10000915 	stw	zero,36(r2)
81138454:	e0bff317 	ldw	r2,-52(fp)
81138458:	e0bffa15 	stw	r2,-24(fp)
8113845c:	e0bffa17 	ldw	r2,-24(fp)
81138460:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();

    return (events_rdy_nbr);
81138464:	e0bff18b 	ldhu	r2,-58(fp)
}
81138468:	e037883a 	mov	sp,fp
8113846c:	dfc00117 	ldw	ra,4(sp)
81138470:	df000017 	ldw	fp,0(sp)
81138474:	dec00204 	addi	sp,sp,8
81138478:	f800283a 	ret

8113847c <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
8113847c:	defffe04 	addi	sp,sp,-8
81138480:	de00012e 	bgeu	sp,et,81138488 <OSInit+0xc>
81138484:	003b68fa 	trap	3
81138488:	dfc00115 	stw	ra,4(sp)
8113848c:	df000015 	stw	fp,0(sp)
81138490:	d839883a 	mov	fp,sp
    OSInitHookBegin();                                           /* Call port specific initialization code   */
81138494:	114a9800 	call	8114a980 <OSInitHookBegin>

    OS_InitMisc();                                               /* Initialize miscellaneous variables       */
81138498:	11392840 	call	81139284 <OS_InitMisc>

    OS_InitRdyList();                                            /* Initialize the Ready List                */
8113849c:	11392d40 	call	811392d4 <OS_InitRdyList>

    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
811384a0:	11394580 	call	81139458 <OS_InitTCBList>

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
811384a4:	113919c0 	call	8113919c <OS_InitEventList>

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
811384a8:	113b4180 	call	8113b418 <OS_FlagInit>
#endif

#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
811384ac:	113bd600 	call	8113bd60 <OS_MemInit>
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
811384b0:	113e0300 	call	8113e030 <OS_QInit>
#endif

    OS_InitTaskIdle();                                           /* Create the Idle Task                     */
811384b4:	11393480 	call	81139348 <OS_InitTaskIdle>
#if OS_TASK_STAT_EN > 0
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
811384b8:	11393d00 	call	811393d0 <OS_InitTaskStat>
#endif

#if OS_TMR_EN > 0
    OSTmr_Init();                                                /* Initialize the Timer Manager             */
811384bc:	11413d40 	call	811413d4 <OSTmr_Init>
#endif

    OSInitHookEnd();                                             /* Call port specific init. code            */
811384c0:	114a9ac0 	call	8114a9ac <OSInitHookEnd>

#if OS_DEBUG_EN > 0
    OSDebugInit();
811384c4:	1139d340 	call	81139d34 <OSDebugInit>
#endif
}
811384c8:	0001883a 	nop
811384cc:	e037883a 	mov	sp,fp
811384d0:	dfc00117 	ldw	ra,4(sp)
811384d4:	df000017 	ldw	fp,0(sp)
811384d8:	dec00204 	addi	sp,sp,8
811384dc:	f800283a 	ret

811384e0 <OSIntEnter>:
*              5) You are allowed to nest interrupts up to 255 levels deep.
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
811384e0:	deffff04 	addi	sp,sp,-4
811384e4:	de00012e 	bgeu	sp,et,811384ec <OSIntEnter+0xc>
811384e8:	003b68fa 	trap	3
811384ec:	df000015 	stw	fp,0(sp)
811384f0:	d839883a 	mov	fp,sp
    if (OSRunning == OS_TRUE) {
811384f4:	d0a09103 	ldbu	r2,-32188(gp)
811384f8:	10803fcc 	andi	r2,r2,255
811384fc:	10800058 	cmpnei	r2,r2,1
81138500:	1000071e 	bne	r2,zero,81138520 <OSIntEnter+0x40>
        if (OSIntNesting < 255u) {
81138504:	d0a0a103 	ldbu	r2,-32124(gp)
81138508:	10803fcc 	andi	r2,r2,255
8113850c:	10803fe0 	cmpeqi	r2,r2,255
81138510:	1000031e 	bne	r2,zero,81138520 <OSIntEnter+0x40>
            OSIntNesting++;                      /* Increment ISR nesting level                        */
81138514:	d0a0a103 	ldbu	r2,-32124(gp)
81138518:	10800044 	addi	r2,r2,1
8113851c:	d0a0a105 	stb	r2,-32124(gp)
        }
    }
}
81138520:	0001883a 	nop
81138524:	e037883a 	mov	sp,fp
81138528:	df000017 	ldw	fp,0(sp)
8113852c:	dec00104 	addi	sp,sp,4
81138530:	f800283a 	ret

81138534 <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
81138534:	defffb04 	addi	sp,sp,-20
81138538:	de00012e 	bgeu	sp,et,81138540 <OSIntExit+0xc>
8113853c:	003b68fa 	trap	3
81138540:	dfc00415 	stw	ra,16(sp)
81138544:	df000315 	stw	fp,12(sp)
81138548:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113854c:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {
81138550:	d0a09103 	ldbu	r2,-32188(gp)
81138554:	10803fcc 	andi	r2,r2,255
81138558:	10800058 	cmpnei	r2,r2,1
8113855c:	10002f1e 	bne	r2,zero,8113861c <OSIntExit+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138560:	0005303a 	rdctl	r2,status
81138564:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138568:	e0ffff17 	ldw	r3,-4(fp)
8113856c:	00bfff84 	movi	r2,-2
81138570:	1884703a 	and	r2,r3,r2
81138574:	1001703a 	wrctl	status,r2
  
  return context;
81138578:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
8113857c:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
81138580:	d0a0a103 	ldbu	r2,-32124(gp)
81138584:	10803fcc 	andi	r2,r2,255
81138588:	10000326 	beq	r2,zero,81138598 <OSIntExit+0x64>
            OSIntNesting--;
8113858c:	d0a0a103 	ldbu	r2,-32124(gp)
81138590:	10bfffc4 	addi	r2,r2,-1
81138594:	d0a0a105 	stb	r2,-32124(gp)
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
81138598:	d0a0a103 	ldbu	r2,-32124(gp)
8113859c:	10803fcc 	andi	r2,r2,255
811385a0:	10001a1e 	bne	r2,zero,8113860c <OSIntExit+0xd8>
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
811385a4:	d0a08f03 	ldbu	r2,-32196(gp)
811385a8:	10803fcc 	andi	r2,r2,255
811385ac:	1000171e 	bne	r2,zero,8113860c <OSIntExit+0xd8>
                OS_SchedNew();
811385b0:	11396e80 	call	811396e8 <OS_SchedNew>
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
811385b4:	d0e09383 	ldbu	r3,-32178(gp)
811385b8:	d0a093c3 	ldbu	r2,-32177(gp)
811385bc:	18c03fcc 	andi	r3,r3,255
811385c0:	10803fcc 	andi	r2,r2,255
811385c4:	18801126 	beq	r3,r2,8113860c <OSIntExit+0xd8>
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
811385c8:	d0a09383 	ldbu	r2,-32178(gp)
811385cc:	10c03fcc 	andi	r3,r2,255
811385d0:	00a045f4 	movhi	r2,33047
811385d4:	10b1de04 	addi	r2,r2,-14472
811385d8:	18c7883a 	add	r3,r3,r3
811385dc:	18c7883a 	add	r3,r3,r3
811385e0:	10c5883a 	add	r2,r2,r3
811385e4:	10800017 	ldw	r2,0(r2)
811385e8:	d0a09c15 	stw	r2,-32144(gp)
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
811385ec:	d0a09c17 	ldw	r2,-32144(gp)
811385f0:	10c00e17 	ldw	r3,56(r2)
811385f4:	18c00044 	addi	r3,r3,1
811385f8:	10c00e15 	stw	r3,56(r2)
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
811385fc:	d0a09617 	ldw	r2,-32168(gp)
81138600:	10800044 	addi	r2,r2,1
81138604:	d0a09615 	stw	r2,-32168(gp)
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
81138608:	114a6400 	call	8114a640 <OSCtxSw>
8113860c:	e0bffd17 	ldw	r2,-12(fp)
81138610:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138614:	e0bffe17 	ldw	r2,-8(fp)
81138618:	1001703a 	wrctl	status,r2
                }
            }
        }
        OS_EXIT_CRITICAL();
    }
}
8113861c:	0001883a 	nop
81138620:	e037883a 	mov	sp,fp
81138624:	dfc00117 	ldw	ra,4(sp)
81138628:	df000017 	ldw	fp,0(sp)
8113862c:	dec00204 	addi	sp,sp,8
81138630:	f800283a 	ret

81138634 <OSSchedLock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedLock (void)
{
81138634:	defffc04 	addi	sp,sp,-16
81138638:	de00012e 	bgeu	sp,et,81138640 <OSSchedLock+0xc>
8113863c:	003b68fa 	trap	3
81138640:	df000315 	stw	fp,12(sp)
81138644:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81138648:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
8113864c:	d0a09103 	ldbu	r2,-32188(gp)
81138650:	10803fcc 	andi	r2,r2,255
81138654:	10800058 	cmpnei	r2,r2,1
81138658:	1000161e 	bne	r2,zero,811386b4 <OSSchedLock+0x80>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113865c:	0005303a 	rdctl	r2,status
81138660:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138664:	e0ffff17 	ldw	r3,-4(fp)
81138668:	00bfff84 	movi	r2,-2
8113866c:	1884703a 	and	r2,r3,r2
81138670:	1001703a 	wrctl	status,r2
  
  return context;
81138674:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
81138678:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
8113867c:	d0a0a103 	ldbu	r2,-32124(gp)
81138680:	10803fcc 	andi	r2,r2,255
81138684:	1000071e 	bne	r2,zero,811386a4 <OSSchedLock+0x70>
            if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
81138688:	d0a08f03 	ldbu	r2,-32196(gp)
8113868c:	10803fcc 	andi	r2,r2,255
81138690:	10803fe0 	cmpeqi	r2,r2,255
81138694:	1000031e 	bne	r2,zero,811386a4 <OSSchedLock+0x70>
                OSLockNesting++;                 /* Increment lock nesting level                       */
81138698:	d0a08f03 	ldbu	r2,-32196(gp)
8113869c:	10800044 	addi	r2,r2,1
811386a0:	d0a08f05 	stb	r2,-32196(gp)
811386a4:	e0bffd17 	ldw	r2,-12(fp)
811386a8:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811386ac:	e0bffe17 	ldw	r2,-8(fp)
811386b0:	1001703a 	wrctl	status,r2
            }
        }
        OS_EXIT_CRITICAL();
    }
}
811386b4:	0001883a 	nop
811386b8:	e037883a 	mov	sp,fp
811386bc:	df000017 	ldw	fp,0(sp)
811386c0:	dec00104 	addi	sp,sp,4
811386c4:	f800283a 	ret

811386c8 <OSSchedUnlock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedUnlock (void)
{
811386c8:	defff804 	addi	sp,sp,-32
811386cc:	de00012e 	bgeu	sp,et,811386d4 <OSSchedUnlock+0xc>
811386d0:	003b68fa 	trap	3
811386d4:	dfc00715 	stw	ra,28(sp)
811386d8:	df000615 	stw	fp,24(sp)
811386dc:	df000604 	addi	fp,sp,24
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
811386e0:	e03ffa15 	stw	zero,-24(fp)
#endif



    if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
811386e4:	d0a09103 	ldbu	r2,-32188(gp)
811386e8:	10803fcc 	andi	r2,r2,255
811386ec:	10800058 	cmpnei	r2,r2,1
811386f0:	1000281e 	bne	r2,zero,81138794 <OSSchedUnlock+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811386f4:	0005303a 	rdctl	r2,status
811386f8:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811386fc:	e0ffff17 	ldw	r3,-4(fp)
81138700:	00bfff84 	movi	r2,-2
81138704:	1884703a 	and	r2,r3,r2
81138708:	1001703a 	wrctl	status,r2
  
  return context;
8113870c:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
81138710:	e0bffa15 	stw	r2,-24(fp)
        if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
81138714:	d0a08f03 	ldbu	r2,-32196(gp)
81138718:	10803fcc 	andi	r2,r2,255
8113871c:	10001926 	beq	r2,zero,81138784 <OSSchedUnlock+0xbc>
            OSLockNesting--;                               /* Decrement lock nesting level             */
81138720:	d0a08f03 	ldbu	r2,-32196(gp)
81138724:	10bfffc4 	addi	r2,r2,-1
81138728:	d0a08f05 	stb	r2,-32196(gp)
            if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
8113872c:	d0a08f03 	ldbu	r2,-32196(gp)
81138730:	10803fcc 	andi	r2,r2,255
81138734:	10000e1e 	bne	r2,zero,81138770 <OSSchedUnlock+0xa8>
                if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
81138738:	d0a0a103 	ldbu	r2,-32124(gp)
8113873c:	10803fcc 	andi	r2,r2,255
81138740:	1000061e 	bne	r2,zero,8113875c <OSSchedUnlock+0x94>
81138744:	e0bffa17 	ldw	r2,-24(fp)
81138748:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113874c:	e0bffb17 	ldw	r2,-20(fp)
81138750:	1001703a 	wrctl	status,r2
                    OS_EXIT_CRITICAL();
                    OS_Sched();                            /* See if a HPT is ready                    */
81138754:	11396100 	call	81139610 <OS_Sched>
            }
        } else {
            OS_EXIT_CRITICAL();
        }
    }
}
81138758:	00000e06 	br	81138794 <OSSchedUnlock+0xcc>
8113875c:	e0bffa17 	ldw	r2,-24(fp)
81138760:	e0bffc15 	stw	r2,-16(fp)
81138764:	e0bffc17 	ldw	r2,-16(fp)
81138768:	1001703a 	wrctl	status,r2
8113876c:	00000906 	br	81138794 <OSSchedUnlock+0xcc>
81138770:	e0bffa17 	ldw	r2,-24(fp)
81138774:	e0bffd15 	stw	r2,-12(fp)
81138778:	e0bffd17 	ldw	r2,-12(fp)
8113877c:	1001703a 	wrctl	status,r2
81138780:	00000406 	br	81138794 <OSSchedUnlock+0xcc>
81138784:	e0bffa17 	ldw	r2,-24(fp)
81138788:	e0bffe15 	stw	r2,-8(fp)
8113878c:	e0bffe17 	ldw	r2,-8(fp)
81138790:	1001703a 	wrctl	status,r2
81138794:	0001883a 	nop
81138798:	e037883a 	mov	sp,fp
8113879c:	dfc00117 	ldw	ra,4(sp)
811387a0:	df000017 	ldw	fp,0(sp)
811387a4:	dec00204 	addi	sp,sp,8
811387a8:	f800283a 	ret

811387ac <OSStart>:
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
811387ac:	defffe04 	addi	sp,sp,-8
811387b0:	de00012e 	bgeu	sp,et,811387b8 <OSStart+0xc>
811387b4:	003b68fa 	trap	3
811387b8:	dfc00115 	stw	ra,4(sp)
811387bc:	df000015 	stw	fp,0(sp)
811387c0:	d839883a 	mov	fp,sp
    if (OSRunning == OS_FALSE) {
811387c4:	d0a09103 	ldbu	r2,-32188(gp)
811387c8:	10803fcc 	andi	r2,r2,255
811387cc:	10000f1e 	bne	r2,zero,8113880c <OSStart+0x60>
        OS_SchedNew();                               /* Find highest priority's task priority number   */
811387d0:	11396e80 	call	811396e8 <OS_SchedNew>
        OSPrioCur     = OSPrioHighRdy;
811387d4:	d0a09383 	ldbu	r2,-32178(gp)
811387d8:	d0a093c5 	stb	r2,-32177(gp)
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
811387dc:	d0a09383 	ldbu	r2,-32178(gp)
811387e0:	10c03fcc 	andi	r3,r2,255
811387e4:	00a045f4 	movhi	r2,33047
811387e8:	10b1de04 	addi	r2,r2,-14472
811387ec:	18c7883a 	add	r3,r3,r3
811387f0:	18c7883a 	add	r3,r3,r3
811387f4:	10c5883a 	add	r2,r2,r3
811387f8:	10800017 	ldw	r2,0(r2)
811387fc:	d0a09c15 	stw	r2,-32144(gp)
        OSTCBCur      = OSTCBHighRdy;
81138800:	d0a09c17 	ldw	r2,-32144(gp)
81138804:	d0a0a215 	stw	r2,-32120(gp)
        OSStartHighRdy();                            /* Execute target specific code to start task     */
81138808:	114a6dc0 	call	8114a6dc <OSStartHighRdy>
    }
}
8113880c:	0001883a 	nop
81138810:	e037883a 	mov	sp,fp
81138814:	dfc00117 	ldw	ra,4(sp)
81138818:	df000017 	ldw	fp,0(sp)
8113881c:	dec00204 	addi	sp,sp,8
81138820:	f800283a 	ret

81138824 <OSStatInit>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OSStatInit (void)
{
81138824:	defff904 	addi	sp,sp,-28
81138828:	de00012e 	bgeu	sp,et,81138830 <OSStatInit+0xc>
8113882c:	003b68fa 	trap	3
81138830:	dfc00615 	stw	ra,24(sp)
81138834:	df000515 	stw	fp,20(sp)
81138838:	df000504 	addi	fp,sp,20
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113883c:	e03ffb15 	stw	zero,-20(fp)
#endif



    OSTimeDly(2);                                /* Synchronize with clock tick                        */
81138840:	01000084 	movi	r4,2
81138844:	114034c0 	call	8114034c <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138848:	0005303a 	rdctl	r2,status
8113884c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138850:	e0fffc17 	ldw	r3,-16(fp)
81138854:	00bfff84 	movi	r2,-2
81138858:	1884703a 	and	r2,r3,r2
8113885c:	1001703a 	wrctl	status,r2
  
  return context;
81138860:	e0bffc17 	ldw	r2,-16(fp)
    OS_ENTER_CRITICAL();
81138864:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
81138868:	d0209215 	stw	zero,-32184(gp)
8113886c:	e0bffb17 	ldw	r2,-20(fp)
81138870:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138874:	e0bffd17 	ldw	r2,-12(fp)
81138878:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
8113887c:	01001904 	movi	r4,100
81138880:	114034c0 	call	8114034c <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138884:	0005303a 	rdctl	r2,status
81138888:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113888c:	e0fffe17 	ldw	r3,-8(fp)
81138890:	00bfff84 	movi	r2,-2
81138894:	1884703a 	and	r2,r3,r2
81138898:	1001703a 	wrctl	status,r2
  
  return context;
8113889c:	e0bffe17 	ldw	r2,-8(fp)
    OS_ENTER_CRITICAL();
811388a0:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
811388a4:	d0a09217 	ldw	r2,-32184(gp)
811388a8:	d0a09815 	stw	r2,-32160(gp)
    OSStatRdy    = OS_TRUE;
811388ac:	00800044 	movi	r2,1
811388b0:	d0a0a705 	stb	r2,-32100(gp)
811388b4:	e0bffb17 	ldw	r2,-20(fp)
811388b8:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811388bc:	e0bfff17 	ldw	r2,-4(fp)
811388c0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
811388c4:	0001883a 	nop
811388c8:	e037883a 	mov	sp,fp
811388cc:	dfc00117 	ldw	ra,4(sp)
811388d0:	df000017 	ldw	fp,0(sp)
811388d4:	dec00204 	addi	sp,sp,8
811388d8:	f800283a 	ret

811388dc <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
811388dc:	defff704 	addi	sp,sp,-36
811388e0:	de00012e 	bgeu	sp,et,811388e8 <OSTimeTick+0xc>
811388e4:	003b68fa 	trap	3
811388e8:	dfc00815 	stw	ra,32(sp)
811388ec:	df000715 	stw	fp,28(sp)
811388f0:	df000704 	addi	fp,sp,28
    OS_TCB    *ptcb;
#if OS_TICK_STEP_EN > 0
    BOOLEAN    step;
#endif
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
811388f4:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
811388f8:	114a92c0 	call	8114a92c <OSTimeTickHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811388fc:	0005303a 	rdctl	r2,status
81138900:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138904:	e0fffd17 	ldw	r3,-12(fp)
81138908:	00bfff84 	movi	r2,-2
8113890c:	1884703a 	and	r2,r3,r2
81138910:	1001703a 	wrctl	status,r2
  
  return context;
81138914:	e0bffd17 	ldw	r2,-12(fp)
#endif
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
81138918:	e0bffb15 	stw	r2,-20(fp)
    OSTime++;
8113891c:	d0a0a417 	ldw	r2,-32112(gp)
81138920:	10800044 	addi	r2,r2,1
81138924:	d0a0a415 	stw	r2,-32112(gp)
81138928:	e0bffb17 	ldw	r2,-20(fp)
8113892c:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138930:	e0bfff17 	ldw	r2,-4(fp)
81138934:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#endif
    if (OSRunning == OS_TRUE) {
81138938:	d0a09103 	ldbu	r2,-32188(gp)
8113893c:	10803fcc 	andi	r2,r2,255
81138940:	10800058 	cmpnei	r2,r2,1
81138944:	10006a1e 	bne	r2,zero,81138af0 <OSTimeTick+0x214>
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
81138948:	d0a09503 	ldbu	r2,-32172(gp)
8113894c:	10803fcc 	andi	r2,r2,255
81138950:	10c00060 	cmpeqi	r3,r2,1
81138954:	1800061e 	bne	r3,zero,81138970 <OSTimeTick+0x94>
81138958:	10c000a0 	cmpeqi	r3,r2,2
8113895c:	1800061e 	bne	r3,zero,81138978 <OSTimeTick+0x9c>
81138960:	10000a1e 	bne	r2,zero,8113898c <OSTimeTick+0xb0>
            case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                 step = OS_TRUE;
81138964:	00800044 	movi	r2,1
81138968:	e0bffa05 	stb	r2,-24(fp)
                 break;
8113896c:	00000b06 	br	8113899c <OSTimeTick+0xc0>

            case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                 step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
81138970:	e03ffa05 	stb	zero,-24(fp)
                 break;
81138974:	00000906 	br	8113899c <OSTimeTick+0xc0>

            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                 step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
81138978:	00800044 	movi	r2,1
8113897c:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_WAIT;
81138980:	00800044 	movi	r2,1
81138984:	d0a09505 	stb	r2,-32172(gp)
                 break;
81138988:	00000406 	br	8113899c <OSTimeTick+0xc0>

            default:                                       /* Invalid case, correct situation              */
                 step            = OS_TRUE;
8113898c:	00800044 	movi	r2,1
81138990:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_DIS;
81138994:	d0209505 	stb	zero,-32172(gp)
                 break;
81138998:	0001883a 	nop
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
8113899c:	e0bffa03 	ldbu	r2,-24(fp)
811389a0:	10005226 	beq	r2,zero,81138aec <OSTimeTick+0x210>
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
811389a4:	d0a09417 	ldw	r2,-32176(gp)
811389a8:	e0bff915 	stw	r2,-28(fp)
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
811389ac:	00004906 	br	81138ad4 <OSTimeTick+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811389b0:	0005303a 	rdctl	r2,status
811389b4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811389b8:	e0fffc17 	ldw	r3,-16(fp)
811389bc:	00bfff84 	movi	r2,-2
811389c0:	1884703a 	and	r2,r3,r2
811389c4:	1001703a 	wrctl	status,r2
  
  return context;
811389c8:	e0bffc17 	ldw	r2,-16(fp)
            OS_ENTER_CRITICAL();
811389cc:	e0bffb15 	stw	r2,-20(fp)
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
811389d0:	e0bff917 	ldw	r2,-28(fp)
811389d4:	10800b8b 	ldhu	r2,46(r2)
811389d8:	10bfffcc 	andi	r2,r2,65535
811389dc:	10003626 	beq	r2,zero,81138ab8 <OSTimeTick+0x1dc>
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
811389e0:	e0bff917 	ldw	r2,-28(fp)
811389e4:	10800b8b 	ldhu	r2,46(r2)
811389e8:	10bfffc4 	addi	r2,r2,-1
811389ec:	1007883a 	mov	r3,r2
811389f0:	e0bff917 	ldw	r2,-28(fp)
811389f4:	10c00b8d 	sth	r3,46(r2)
811389f8:	e0bff917 	ldw	r2,-28(fp)
811389fc:	10800b8b 	ldhu	r2,46(r2)
81138a00:	10bfffcc 	andi	r2,r2,65535
81138a04:	10002c1e 	bne	r2,zero,81138ab8 <OSTimeTick+0x1dc>
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
81138a08:	e0bff917 	ldw	r2,-28(fp)
81138a0c:	10800c03 	ldbu	r2,48(r2)
81138a10:	10803fcc 	andi	r2,r2,255
81138a14:	10800dcc 	andi	r2,r2,55
81138a18:	10000b26 	beq	r2,zero,81138a48 <OSTimeTick+0x16c>
                        ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
81138a1c:	e0bff917 	ldw	r2,-28(fp)
81138a20:	10c00c03 	ldbu	r3,48(r2)
81138a24:	00bff204 	movi	r2,-56
81138a28:	1884703a 	and	r2,r3,r2
81138a2c:	1007883a 	mov	r3,r2
81138a30:	e0bff917 	ldw	r2,-28(fp)
81138a34:	10c00c05 	stb	r3,48(r2)
                        ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
81138a38:	e0bff917 	ldw	r2,-28(fp)
81138a3c:	00c00044 	movi	r3,1
81138a40:	10c00c45 	stb	r3,49(r2)
81138a44:	00000206 	br	81138a50 <OSTimeTick+0x174>
                    } else {
                        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
81138a48:	e0bff917 	ldw	r2,-28(fp)
81138a4c:	10000c45 	stb	zero,49(r2)
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
81138a50:	e0bff917 	ldw	r2,-28(fp)
81138a54:	10800c03 	ldbu	r2,48(r2)
81138a58:	10803fcc 	andi	r2,r2,255
81138a5c:	1080020c 	andi	r2,r2,8
81138a60:	1000151e 	bne	r2,zero,81138ab8 <OSTimeTick+0x1dc>
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
81138a64:	e0bff917 	ldw	r2,-28(fp)
81138a68:	10c00d83 	ldbu	r3,54(r2)
81138a6c:	d0a09e03 	ldbu	r2,-32136(gp)
81138a70:	1884b03a 	or	r2,r3,r2
81138a74:	d0a09e05 	stb	r2,-32136(gp)
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81138a78:	e0bff917 	ldw	r2,-28(fp)
81138a7c:	10800d03 	ldbu	r2,52(r2)
81138a80:	10c03fcc 	andi	r3,r2,255
81138a84:	e0bff917 	ldw	r2,-28(fp)
81138a88:	10800d03 	ldbu	r2,52(r2)
81138a8c:	11003fcc 	andi	r4,r2,255
81138a90:	d0a09e44 	addi	r2,gp,-32135
81138a94:	2085883a 	add	r2,r4,r2
81138a98:	11000003 	ldbu	r4,0(r2)
81138a9c:	e0bff917 	ldw	r2,-28(fp)
81138aa0:	10800d43 	ldbu	r2,53(r2)
81138aa4:	2084b03a 	or	r2,r4,r2
81138aa8:	1009883a 	mov	r4,r2
81138aac:	d0a09e44 	addi	r2,gp,-32135
81138ab0:	1885883a 	add	r2,r3,r2
81138ab4:	11000005 	stb	r4,0(r2)
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
81138ab8:	e0bff917 	ldw	r2,-28(fp)
81138abc:	10800517 	ldw	r2,20(r2)
81138ac0:	e0bff915 	stw	r2,-28(fp)
81138ac4:	e0bffb17 	ldw	r2,-20(fp)
81138ac8:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138acc:	e0bffe17 	ldw	r2,-8(fp)
81138ad0:	1001703a 	wrctl	status,r2
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
81138ad4:	e0bff917 	ldw	r2,-28(fp)
81138ad8:	10800c83 	ldbu	r2,50(r2)
81138adc:	10803fcc 	andi	r2,r2,255
81138ae0:	10800a98 	cmpnei	r2,r2,42
81138ae4:	103fb21e 	bne	r2,zero,811389b0 <__reset+0xfb1189b0>
81138ae8:	00000106 	br	81138af0 <OSTimeTick+0x214>
                 step            = OS_TRUE;
                 OSTickStepState = OS_TICK_STEP_DIS;
                 break;
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
81138aec:	0001883a 	nop
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
81138af0:	e037883a 	mov	sp,fp
81138af4:	dfc00117 	ldw	ra,4(sp)
81138af8:	df000017 	ldw	fp,0(sp)
81138afc:	dec00204 	addi	sp,sp,8
81138b00:	f800283a 	ret

81138b04 <OSVersion>:
* Returns    : the version number of uC/OS-II multiplied by 100.
*********************************************************************************************************
*/

INT16U  OSVersion (void)
{
81138b04:	deffff04 	addi	sp,sp,-4
81138b08:	de00012e 	bgeu	sp,et,81138b10 <OSVersion+0xc>
81138b0c:	003b68fa 	trap	3
81138b10:	df000015 	stw	fp,0(sp)
81138b14:	d839883a 	mov	fp,sp
    return (OS_VERSION);
81138b18:	00804784 	movi	r2,286
}
81138b1c:	e037883a 	mov	sp,fp
81138b20:	df000017 	ldw	fp,0(sp)
81138b24:	dec00104 	addi	sp,sp,4
81138b28:	f800283a 	ret

81138b2c <OS_Dummy>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
void  OS_Dummy (void)
{
81138b2c:	deffff04 	addi	sp,sp,-4
81138b30:	de00012e 	bgeu	sp,et,81138b38 <OS_Dummy+0xc>
81138b34:	003b68fa 	trap	3
81138b38:	df000015 	stw	fp,0(sp)
81138b3c:	d839883a 	mov	fp,sp
}
81138b40:	0001883a 	nop
81138b44:	e037883a 	mov	sp,fp
81138b48:	df000017 	ldw	fp,0(sp)
81138b4c:	dec00104 	addi	sp,sp,4
81138b50:	f800283a 	ret

81138b54 <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
{
81138b54:	defff804 	addi	sp,sp,-32
81138b58:	de00012e 	bgeu	sp,et,81138b60 <OS_EventTaskRdy+0xc>
81138b5c:	003b68fa 	trap	3
81138b60:	dfc00715 	stw	ra,28(sp)
81138b64:	df000615 	stw	fp,24(sp)
81138b68:	df000604 	addi	fp,sp,24
81138b6c:	e13ffc15 	stw	r4,-16(fp)
81138b70:	e17ffd15 	stw	r5,-12(fp)
81138b74:	3007883a 	mov	r3,r6
81138b78:	3805883a 	mov	r2,r7
81138b7c:	e0fffe05 	stb	r3,-8(fp)
81138b80:	e0bfff05 	stb	r2,-4(fp)
    INT16U  *ptbl;
#endif


#if OS_LOWEST_PRIO <= 63
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
81138b84:	e0bffc17 	ldw	r2,-16(fp)
81138b88:	10800283 	ldbu	r2,10(r2)
81138b8c:	10c03fcc 	andi	r3,r2,255
81138b90:	00a04574 	movhi	r2,33045
81138b94:	10826304 	addi	r2,r2,2444
81138b98:	10c5883a 	add	r2,r2,r3
81138b9c:	10800003 	ldbu	r2,0(r2)
81138ba0:	e0bffa05 	stb	r2,-24(fp)
    x    = OSUnMapTbl[pevent->OSEventTbl[y]];
81138ba4:	e0bffa03 	ldbu	r2,-24(fp)
81138ba8:	e0fffc17 	ldw	r3,-16(fp)
81138bac:	1885883a 	add	r2,r3,r2
81138bb0:	108002c4 	addi	r2,r2,11
81138bb4:	10800003 	ldbu	r2,0(r2)
81138bb8:	10c03fcc 	andi	r3,r2,255
81138bbc:	00a04574 	movhi	r2,33045
81138bc0:	10826304 	addi	r2,r2,2444
81138bc4:	10c5883a 	add	r2,r2,r3
81138bc8:	10800003 	ldbu	r2,0(r2)
81138bcc:	e0bffa45 	stb	r2,-23(fp)
    prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
81138bd0:	e0bffa03 	ldbu	r2,-24(fp)
81138bd4:	100490fa 	slli	r2,r2,3
81138bd8:	1007883a 	mov	r3,r2
81138bdc:	e0bffa43 	ldbu	r2,-23(fp)
81138be0:	1885883a 	add	r2,r3,r2
81138be4:	e0bffa85 	stb	r2,-22(fp)
        x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
    }
    prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
#endif

    ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
81138be8:	e0fffa83 	ldbu	r3,-22(fp)
81138bec:	00a045f4 	movhi	r2,33047
81138bf0:	10b1de04 	addi	r2,r2,-14472
81138bf4:	18c7883a 	add	r3,r3,r3
81138bf8:	18c7883a 	add	r3,r3,r3
81138bfc:	10c5883a 	add	r2,r2,r3
81138c00:	10800017 	ldw	r2,0(r2)
81138c04:	e0bffb15 	stw	r2,-20(fp)
    ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
81138c08:	e0bffb17 	ldw	r2,-20(fp)
81138c0c:	10000b8d 	sth	zero,46(r2)
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
81138c10:	e0bffb17 	ldw	r2,-20(fp)
81138c14:	e0fffd17 	ldw	r3,-12(fp)
81138c18:	10c00915 	stw	r3,36(r2)
#else
    pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
81138c1c:	e0bffb17 	ldw	r2,-20(fp)
81138c20:	10800c03 	ldbu	r2,48(r2)
81138c24:	1007883a 	mov	r3,r2
81138c28:	e0bffe03 	ldbu	r2,-8(fp)
81138c2c:	0084303a 	nor	r2,zero,r2
81138c30:	1884703a 	and	r2,r3,r2
81138c34:	1007883a 	mov	r3,r2
81138c38:	e0bffb17 	ldw	r2,-20(fp)
81138c3c:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
81138c40:	e0bffb17 	ldw	r2,-20(fp)
81138c44:	e0ffff03 	ldbu	r3,-4(fp)
81138c48:	10c00c45 	stb	r3,49(r2)
                                                        /* See if task is ready (could be susp'd)      */
    if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
81138c4c:	e0bffb17 	ldw	r2,-20(fp)
81138c50:	10800c03 	ldbu	r2,48(r2)
81138c54:	10803fcc 	andi	r2,r2,255
81138c58:	1080020c 	andi	r2,r2,8
81138c5c:	1000111e 	bne	r2,zero,81138ca4 <OS_EventTaskRdy+0x150>
        OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
81138c60:	e0bffb17 	ldw	r2,-20(fp)
81138c64:	10c00d83 	ldbu	r3,54(r2)
81138c68:	d0a09e03 	ldbu	r2,-32136(gp)
81138c6c:	1884b03a 	or	r2,r3,r2
81138c70:	d0a09e05 	stb	r2,-32136(gp)
        OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
81138c74:	e0fffa03 	ldbu	r3,-24(fp)
81138c78:	e13ffa03 	ldbu	r4,-24(fp)
81138c7c:	d0a09e44 	addi	r2,gp,-32135
81138c80:	2085883a 	add	r2,r4,r2
81138c84:	11000003 	ldbu	r4,0(r2)
81138c88:	e0bffb17 	ldw	r2,-20(fp)
81138c8c:	10800d43 	ldbu	r2,53(r2)
81138c90:	2084b03a 	or	r2,r4,r2
81138c94:	1009883a 	mov	r4,r2
81138c98:	d0a09e44 	addi	r2,gp,-32135
81138c9c:	1885883a 	add	r2,r3,r2
81138ca0:	11000005 	stb	r4,0(r2)
    }

    OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
81138ca4:	e17ffc17 	ldw	r5,-16(fp)
81138ca8:	e13ffb17 	ldw	r4,-20(fp)
81138cac:	1138f640 	call	81138f64 <OS_EventTaskRemove>
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
81138cb0:	e0bffb17 	ldw	r2,-20(fp)
81138cb4:	10800817 	ldw	r2,32(r2)
81138cb8:	10000826 	beq	r2,zero,81138cdc <OS_EventTaskRdy+0x188>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
81138cbc:	e0bffb17 	ldw	r2,-20(fp)
81138cc0:	10800817 	ldw	r2,32(r2)
81138cc4:	100b883a 	mov	r5,r2
81138cc8:	e13ffb17 	ldw	r4,-20(fp)
81138ccc:	11390240 	call	81139024 <OS_EventTaskRemoveMulti>
        ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
81138cd0:	e0bffb17 	ldw	r2,-20(fp)
81138cd4:	e0fffc17 	ldw	r3,-16(fp)
81138cd8:	10c00715 	stw	r3,28(r2)
    }
#endif

    return (prio);
81138cdc:	e0bffa83 	ldbu	r2,-22(fp)
}
81138ce0:	e037883a 	mov	sp,fp
81138ce4:	dfc00117 	ldw	ra,4(sp)
81138ce8:	df000017 	ldw	fp,0(sp)
81138cec:	dec00204 	addi	sp,sp,8
81138cf0:	f800283a 	ret

81138cf4 <OS_EventTaskWait>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskWait (OS_EVENT *pevent)
{
81138cf4:	defffd04 	addi	sp,sp,-12
81138cf8:	de00012e 	bgeu	sp,et,81138d00 <OS_EventTaskWait+0xc>
81138cfc:	003b68fa 	trap	3
81138d00:	df000215 	stw	fp,8(sp)
81138d04:	df000204 	addi	fp,sp,8
81138d08:	e13fff15 	stw	r4,-4(fp)
    INT8U  y;


    OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
81138d0c:	d0a0a217 	ldw	r2,-32120(gp)
81138d10:	e0ffff17 	ldw	r3,-4(fp)
81138d14:	10c00715 	stw	r3,28(r2)

    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
81138d18:	d0a0a217 	ldw	r2,-32120(gp)
81138d1c:	10800d03 	ldbu	r2,52(r2)
81138d20:	10803fcc 	andi	r2,r2,255
81138d24:	d0e0a217 	ldw	r3,-32120(gp)
81138d28:	18c00d03 	ldbu	r3,52(r3)
81138d2c:	18c03fcc 	andi	r3,r3,255
81138d30:	e13fff17 	ldw	r4,-4(fp)
81138d34:	20c7883a 	add	r3,r4,r3
81138d38:	18c002c4 	addi	r3,r3,11
81138d3c:	19000003 	ldbu	r4,0(r3)
81138d40:	d0e0a217 	ldw	r3,-32120(gp)
81138d44:	18c00d43 	ldbu	r3,53(r3)
81138d48:	20c6b03a 	or	r3,r4,r3
81138d4c:	1809883a 	mov	r4,r3
81138d50:	e0ffff17 	ldw	r3,-4(fp)
81138d54:	1885883a 	add	r2,r3,r2
81138d58:	108002c4 	addi	r2,r2,11
81138d5c:	11000005 	stb	r4,0(r2)
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
81138d60:	e0bfff17 	ldw	r2,-4(fp)
81138d64:	10c00283 	ldbu	r3,10(r2)
81138d68:	d0a0a217 	ldw	r2,-32120(gp)
81138d6c:	10800d83 	ldbu	r2,54(r2)
81138d70:	1884b03a 	or	r2,r3,r2
81138d74:	1007883a 	mov	r3,r2
81138d78:	e0bfff17 	ldw	r2,-4(fp)
81138d7c:	10c00285 	stb	r3,10(r2)

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
81138d80:	d0a0a217 	ldw	r2,-32120(gp)
81138d84:	10800d03 	ldbu	r2,52(r2)
81138d88:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
81138d8c:	e0fffe03 	ldbu	r3,-8(fp)
81138d90:	e13ffe03 	ldbu	r4,-8(fp)
81138d94:	d0a09e44 	addi	r2,gp,-32135
81138d98:	2085883a 	add	r2,r4,r2
81138d9c:	10800003 	ldbu	r2,0(r2)
81138da0:	1009883a 	mov	r4,r2
81138da4:	d0a0a217 	ldw	r2,-32120(gp)
81138da8:	10800d43 	ldbu	r2,53(r2)
81138dac:	0084303a 	nor	r2,zero,r2
81138db0:	2084703a 	and	r2,r4,r2
81138db4:	1009883a 	mov	r4,r2
81138db8:	d0a09e44 	addi	r2,gp,-32135
81138dbc:	1885883a 	add	r2,r3,r2
81138dc0:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
81138dc4:	e0fffe03 	ldbu	r3,-8(fp)
81138dc8:	d0a09e44 	addi	r2,gp,-32135
81138dcc:	1885883a 	add	r2,r3,r2
81138dd0:	10800003 	ldbu	r2,0(r2)
81138dd4:	10803fcc 	andi	r2,r2,255
81138dd8:	1000071e 	bne	r2,zero,81138df8 <OS_EventTaskWait+0x104>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
81138ddc:	d0a0a217 	ldw	r2,-32120(gp)
81138de0:	10800d83 	ldbu	r2,54(r2)
81138de4:	0084303a 	nor	r2,zero,r2
81138de8:	1007883a 	mov	r3,r2
81138dec:	d0a09e03 	ldbu	r2,-32136(gp)
81138df0:	1884703a 	and	r2,r3,r2
81138df4:	d0a09e05 	stb	r2,-32136(gp)
    }
}
81138df8:	0001883a 	nop
81138dfc:	e037883a 	mov	sp,fp
81138e00:	df000017 	ldw	fp,0(sp)
81138e04:	dec00104 	addi	sp,sp,4
81138e08:	f800283a 	ret

81138e0c <OS_EventTaskWaitMulti>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
{
81138e0c:	defffb04 	addi	sp,sp,-20
81138e10:	de00012e 	bgeu	sp,et,81138e18 <OS_EventTaskWaitMulti+0xc>
81138e14:	003b68fa 	trap	3
81138e18:	df000415 	stw	fp,16(sp)
81138e1c:	df000404 	addi	fp,sp,16
81138e20:	e13fff15 	stw	r4,-4(fp)
    OS_EVENT **pevents;
    OS_EVENT  *pevent;
    INT8U      y;


    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
81138e24:	d0a0a217 	ldw	r2,-32120(gp)
81138e28:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
81138e2c:	d0a0a217 	ldw	r2,-32120(gp)
81138e30:	e0ffff17 	ldw	r3,-4(fp)
81138e34:	10c00815 	stw	r3,32(r2)

    pevents =  pevents_wait;
81138e38:	e0bfff17 	ldw	r2,-4(fp)
81138e3c:	e0bffc15 	stw	r2,-16(fp)
    pevent  = *pevents;
81138e40:	e0bffc17 	ldw	r2,-16(fp)
81138e44:	10800017 	ldw	r2,0(r2)
81138e48:	e0bffd15 	stw	r2,-12(fp)
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
81138e4c:	00002006 	br	81138ed0 <OS_EventTaskWaitMulti+0xc4>
        pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
81138e50:	d0a0a217 	ldw	r2,-32120(gp)
81138e54:	10800d03 	ldbu	r2,52(r2)
81138e58:	10803fcc 	andi	r2,r2,255
81138e5c:	d0e0a217 	ldw	r3,-32120(gp)
81138e60:	18c00d03 	ldbu	r3,52(r3)
81138e64:	18c03fcc 	andi	r3,r3,255
81138e68:	e13ffd17 	ldw	r4,-12(fp)
81138e6c:	20c7883a 	add	r3,r4,r3
81138e70:	18c002c4 	addi	r3,r3,11
81138e74:	19000003 	ldbu	r4,0(r3)
81138e78:	d0e0a217 	ldw	r3,-32120(gp)
81138e7c:	18c00d43 	ldbu	r3,53(r3)
81138e80:	20c6b03a 	or	r3,r4,r3
81138e84:	1809883a 	mov	r4,r3
81138e88:	e0fffd17 	ldw	r3,-12(fp)
81138e8c:	1885883a 	add	r2,r3,r2
81138e90:	108002c4 	addi	r2,r2,11
81138e94:	11000005 	stb	r4,0(r2)
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
81138e98:	e0bffd17 	ldw	r2,-12(fp)
81138e9c:	10c00283 	ldbu	r3,10(r2)
81138ea0:	d0a0a217 	ldw	r2,-32120(gp)
81138ea4:	10800d83 	ldbu	r2,54(r2)
81138ea8:	1884b03a 	or	r2,r3,r2
81138eac:	1007883a 	mov	r3,r2
81138eb0:	e0bffd17 	ldw	r2,-12(fp)
81138eb4:	10c00285 	stb	r3,10(r2)
        pevents++;
81138eb8:	e0bffc17 	ldw	r2,-16(fp)
81138ebc:	10800104 	addi	r2,r2,4
81138ec0:	e0bffc15 	stw	r2,-16(fp)
        pevent = *pevents;
81138ec4:	e0bffc17 	ldw	r2,-16(fp)
81138ec8:	10800017 	ldw	r2,0(r2)
81138ecc:	e0bffd15 	stw	r2,-12(fp)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */

    pevents =  pevents_wait;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
81138ed0:	e0bffd17 	ldw	r2,-12(fp)
81138ed4:	103fde1e 	bne	r2,zero,81138e50 <__reset+0xfb118e50>
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
        pevents++;
        pevent = *pevents;
    }

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
81138ed8:	d0a0a217 	ldw	r2,-32120(gp)
81138edc:	10800d03 	ldbu	r2,52(r2)
81138ee0:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
81138ee4:	e0fffe03 	ldbu	r3,-8(fp)
81138ee8:	e13ffe03 	ldbu	r4,-8(fp)
81138eec:	d0a09e44 	addi	r2,gp,-32135
81138ef0:	2085883a 	add	r2,r4,r2
81138ef4:	10800003 	ldbu	r2,0(r2)
81138ef8:	1009883a 	mov	r4,r2
81138efc:	d0a0a217 	ldw	r2,-32120(gp)
81138f00:	10800d43 	ldbu	r2,53(r2)
81138f04:	0084303a 	nor	r2,zero,r2
81138f08:	2084703a 	and	r2,r4,r2
81138f0c:	1009883a 	mov	r4,r2
81138f10:	d0a09e44 	addi	r2,gp,-32135
81138f14:	1885883a 	add	r2,r3,r2
81138f18:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
81138f1c:	e0fffe03 	ldbu	r3,-8(fp)
81138f20:	d0a09e44 	addi	r2,gp,-32135
81138f24:	1885883a 	add	r2,r3,r2
81138f28:	10800003 	ldbu	r2,0(r2)
81138f2c:	10803fcc 	andi	r2,r2,255
81138f30:	1000071e 	bne	r2,zero,81138f50 <OS_EventTaskWaitMulti+0x144>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
81138f34:	d0a0a217 	ldw	r2,-32120(gp)
81138f38:	10800d83 	ldbu	r2,54(r2)
81138f3c:	0084303a 	nor	r2,zero,r2
81138f40:	1007883a 	mov	r3,r2
81138f44:	d0a09e03 	ldbu	r2,-32136(gp)
81138f48:	1884703a 	and	r2,r3,r2
81138f4c:	d0a09e05 	stb	r2,-32136(gp)
    }
}
81138f50:	0001883a 	nop
81138f54:	e037883a 	mov	sp,fp
81138f58:	df000017 	ldw	fp,0(sp)
81138f5c:	dec00104 	addi	sp,sp,4
81138f60:	f800283a 	ret

81138f64 <OS_EventTaskRemove>:
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskRemove (OS_TCB   *ptcb,
                          OS_EVENT *pevent)
{
81138f64:	defffc04 	addi	sp,sp,-16
81138f68:	de00012e 	bgeu	sp,et,81138f70 <OS_EventTaskRemove+0xc>
81138f6c:	003b68fa 	trap	3
81138f70:	df000315 	stw	fp,12(sp)
81138f74:	df000304 	addi	fp,sp,12
81138f78:	e13ffe15 	stw	r4,-8(fp)
81138f7c:	e17fff15 	stw	r5,-4(fp)
    INT8U  y;


    y                       =  ptcb->OSTCBY;
81138f80:	e0bffe17 	ldw	r2,-8(fp)
81138f84:	10800d03 	ldbu	r2,52(r2)
81138f88:	e0bffd05 	stb	r2,-12(fp)
    pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
81138f8c:	e0bffd03 	ldbu	r2,-12(fp)
81138f90:	e0fffd03 	ldbu	r3,-12(fp)
81138f94:	e13fff17 	ldw	r4,-4(fp)
81138f98:	20c7883a 	add	r3,r4,r3
81138f9c:	18c002c4 	addi	r3,r3,11
81138fa0:	18c00003 	ldbu	r3,0(r3)
81138fa4:	1809883a 	mov	r4,r3
81138fa8:	e0fffe17 	ldw	r3,-8(fp)
81138fac:	18c00d43 	ldbu	r3,53(r3)
81138fb0:	00c6303a 	nor	r3,zero,r3
81138fb4:	20c6703a 	and	r3,r4,r3
81138fb8:	1809883a 	mov	r4,r3
81138fbc:	e0ffff17 	ldw	r3,-4(fp)
81138fc0:	1885883a 	add	r2,r3,r2
81138fc4:	108002c4 	addi	r2,r2,11
81138fc8:	11000005 	stb	r4,0(r2)
    if (pevent->OSEventTbl[y] == 0) {
81138fcc:	e0bffd03 	ldbu	r2,-12(fp)
81138fd0:	e0ffff17 	ldw	r3,-4(fp)
81138fd4:	1885883a 	add	r2,r3,r2
81138fd8:	108002c4 	addi	r2,r2,11
81138fdc:	10800003 	ldbu	r2,0(r2)
81138fe0:	10803fcc 	andi	r2,r2,255
81138fe4:	10000a1e 	bne	r2,zero,81139010 <OS_EventTaskRemove+0xac>
        pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
81138fe8:	e0bfff17 	ldw	r2,-4(fp)
81138fec:	10800283 	ldbu	r2,10(r2)
81138ff0:	1007883a 	mov	r3,r2
81138ff4:	e0bffe17 	ldw	r2,-8(fp)
81138ff8:	10800d83 	ldbu	r2,54(r2)
81138ffc:	0084303a 	nor	r2,zero,r2
81139000:	1884703a 	and	r2,r3,r2
81139004:	1007883a 	mov	r3,r2
81139008:	e0bfff17 	ldw	r2,-4(fp)
8113900c:	10c00285 	stb	r3,10(r2)
    }
}
81139010:	0001883a 	nop
81139014:	e037883a 	mov	sp,fp
81139018:	df000017 	ldw	fp,0(sp)
8113901c:	dec00104 	addi	sp,sp,4
81139020:	f800283a 	ret

81139024 <OS_EventTaskRemoveMulti>:
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                               OS_EVENT **pevents_multi)
{
81139024:	defffa04 	addi	sp,sp,-24
81139028:	de00012e 	bgeu	sp,et,81139030 <OS_EventTaskRemoveMulti+0xc>
8113902c:	003b68fa 	trap	3
81139030:	df000515 	stw	fp,20(sp)
81139034:	df000504 	addi	fp,sp,20
81139038:	e13ffe15 	stw	r4,-8(fp)
8113903c:	e17fff15 	stw	r5,-4(fp)
    INT16U     bity;
    INT16U     bitx;
#endif


    y       =  ptcb->OSTCBY;
81139040:	e0bffe17 	ldw	r2,-8(fp)
81139044:	10800d03 	ldbu	r2,52(r2)
81139048:	e0bffd05 	stb	r2,-12(fp)
    bity    =  ptcb->OSTCBBitY;
8113904c:	e0bffe17 	ldw	r2,-8(fp)
81139050:	10800d83 	ldbu	r2,54(r2)
81139054:	e0bffd45 	stb	r2,-11(fp)
    bitx    =  ptcb->OSTCBBitX;
81139058:	e0bffe17 	ldw	r2,-8(fp)
8113905c:	10800d43 	ldbu	r2,53(r2)
81139060:	e0bffd85 	stb	r2,-10(fp)
    pevents =  pevents_multi;
81139064:	e0bfff17 	ldw	r2,-4(fp)
81139068:	e0bffb15 	stw	r2,-20(fp)
    pevent  = *pevents;
8113906c:	e0bffb17 	ldw	r2,-20(fp)
81139070:	10800017 	ldw	r2,0(r2)
81139074:	e0bffc15 	stw	r2,-16(fp)
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
81139078:	00002506 	br	81139110 <OS_EventTaskRemoveMulti+0xec>
        pevent->OSEventTbl[y]  &= ~bitx;
8113907c:	e0bffd03 	ldbu	r2,-12(fp)
81139080:	e0fffd03 	ldbu	r3,-12(fp)
81139084:	e13ffc17 	ldw	r4,-16(fp)
81139088:	20c7883a 	add	r3,r4,r3
8113908c:	18c002c4 	addi	r3,r3,11
81139090:	18c00003 	ldbu	r3,0(r3)
81139094:	1809883a 	mov	r4,r3
81139098:	e0fffd83 	ldbu	r3,-10(fp)
8113909c:	00c6303a 	nor	r3,zero,r3
811390a0:	20c6703a 	and	r3,r4,r3
811390a4:	1809883a 	mov	r4,r3
811390a8:	e0fffc17 	ldw	r3,-16(fp)
811390ac:	1885883a 	add	r2,r3,r2
811390b0:	108002c4 	addi	r2,r2,11
811390b4:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y] == 0) {
811390b8:	e0bffd03 	ldbu	r2,-12(fp)
811390bc:	e0fffc17 	ldw	r3,-16(fp)
811390c0:	1885883a 	add	r2,r3,r2
811390c4:	108002c4 	addi	r2,r2,11
811390c8:	10800003 	ldbu	r2,0(r2)
811390cc:	10803fcc 	andi	r2,r2,255
811390d0:	1000091e 	bne	r2,zero,811390f8 <OS_EventTaskRemoveMulti+0xd4>
            pevent->OSEventGrp &= ~bity;
811390d4:	e0bffc17 	ldw	r2,-16(fp)
811390d8:	10800283 	ldbu	r2,10(r2)
811390dc:	1007883a 	mov	r3,r2
811390e0:	e0bffd43 	ldbu	r2,-11(fp)
811390e4:	0084303a 	nor	r2,zero,r2
811390e8:	1884703a 	and	r2,r3,r2
811390ec:	1007883a 	mov	r3,r2
811390f0:	e0bffc17 	ldw	r2,-16(fp)
811390f4:	10c00285 	stb	r3,10(r2)
        }
        pevents++;
811390f8:	e0bffb17 	ldw	r2,-20(fp)
811390fc:	10800104 	addi	r2,r2,4
81139100:	e0bffb15 	stw	r2,-20(fp)
        pevent = *pevents;
81139104:	e0bffb17 	ldw	r2,-20(fp)
81139108:	10800017 	ldw	r2,0(r2)
8113910c:	e0bffc15 	stw	r2,-16(fp)
    y       =  ptcb->OSTCBY;
    bity    =  ptcb->OSTCBBitY;
    bitx    =  ptcb->OSTCBBitX;
    pevents =  pevents_multi;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
81139110:	e0bffc17 	ldw	r2,-16(fp)
81139114:	103fd91e 	bne	r2,zero,8113907c <__reset+0xfb11907c>
            pevent->OSEventGrp &= ~bity;
        }
        pevents++;
        pevent = *pevents;
    }
}
81139118:	0001883a 	nop
8113911c:	e037883a 	mov	sp,fp
81139120:	df000017 	ldw	fp,0(sp)
81139124:	dec00104 	addi	sp,sp,4
81139128:	f800283a 	ret

8113912c <OS_EventWaitListInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventWaitListInit (OS_EVENT *pevent)
{
8113912c:	defffc04 	addi	sp,sp,-16
81139130:	de00012e 	bgeu	sp,et,81139138 <OS_EventWaitListInit+0xc>
81139134:	003b68fa 	trap	3
81139138:	df000315 	stw	fp,12(sp)
8113913c:	df000304 	addi	fp,sp,12
81139140:	e13fff15 	stw	r4,-4(fp)
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
81139144:	e0bfff17 	ldw	r2,-4(fp)
81139148:	10000285 	stb	zero,10(r2)
    ptbl               = &pevent->OSEventTbl[0];
8113914c:	e0bfff17 	ldw	r2,-4(fp)
81139150:	108002c4 	addi	r2,r2,11
81139154:	e0bffd15 	stw	r2,-12(fp)

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81139158:	e03ffe05 	stb	zero,-8(fp)
8113915c:	00000706 	br	8113917c <OS_EventWaitListInit+0x50>
        *ptbl++ = 0;
81139160:	e0bffd17 	ldw	r2,-12(fp)
81139164:	10c00044 	addi	r3,r2,1
81139168:	e0fffd15 	stw	r3,-12(fp)
8113916c:	10000005 	stb	zero,0(r2)


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81139170:	e0bffe03 	ldbu	r2,-8(fp)
81139174:	10800044 	addi	r2,r2,1
81139178:	e0bffe05 	stb	r2,-8(fp)
8113917c:	e0bffe03 	ldbu	r2,-8(fp)
81139180:	108001b0 	cmpltui	r2,r2,6
81139184:	103ff61e 	bne	r2,zero,81139160 <__reset+0xfb119160>
        *ptbl++ = 0;
    }
}
81139188:	0001883a 	nop
8113918c:	e037883a 	mov	sp,fp
81139190:	df000017 	ldw	fp,0(sp)
81139194:	dec00104 	addi	sp,sp,4
81139198:	f800283a 	ret

8113919c <OS_InitEventList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitEventList (void)
{
8113919c:	defffb04 	addi	sp,sp,-20
811391a0:	de00012e 	bgeu	sp,et,811391a8 <OS_InitEventList+0xc>
811391a4:	003b68fa 	trap	3
811391a8:	dfc00415 	stw	ra,16(sp)
811391ac:	df000315 	stw	fp,12(sp)
811391b0:	df000304 	addi	fp,sp,12
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
811391b4:	01434004 	movi	r5,3328
811391b8:	012045f4 	movhi	r4,33047
811391bc:	212a3004 	addi	r4,r4,-22336
811391c0:	11395440 	call	81139544 <OS_MemClr>
    pevent1 = &OSEventTbl[0];
811391c4:	00a045f4 	movhi	r2,33047
811391c8:	10aa3004 	addi	r2,r2,-22336
811391cc:	e0bffe15 	stw	r2,-8(fp)
    pevent2 = &OSEventTbl[1];
811391d0:	00a045f4 	movhi	r2,33047
811391d4:	10aa3d04 	addi	r2,r2,-22284
811391d8:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
811391dc:	e03ffd0d 	sth	zero,-12(fp)
811391e0:	00001306 	br	81139230 <OS_InitEventList+0x94>
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
811391e4:	e0bffe17 	ldw	r2,-8(fp)
811391e8:	10000005 	stb	zero,0(r2)
        pevent1->OSEventPtr     = pevent2;
811391ec:	e0bffe17 	ldw	r2,-8(fp)
811391f0:	e0ffff17 	ldw	r3,-4(fp)
811391f4:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
811391f8:	e0bffe17 	ldw	r2,-8(fp)
811391fc:	00c00fc4 	movi	r3,63
81139200:	10c00445 	stb	r3,17(r2)
        pevent1->OSEventName[1] = OS_ASCII_NUL;
81139204:	e0bffe17 	ldw	r2,-8(fp)
81139208:	10000485 	stb	zero,18(r2)
#endif
        pevent1++;
8113920c:	e0bffe17 	ldw	r2,-8(fp)
81139210:	10800d04 	addi	r2,r2,52
81139214:	e0bffe15 	stw	r2,-8(fp)
        pevent2++;
81139218:	e0bfff17 	ldw	r2,-4(fp)
8113921c:	10800d04 	addi	r2,r2,52
81139220:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
81139224:	e0bffd0b 	ldhu	r2,-12(fp)
81139228:	10800044 	addi	r2,r2,1
8113922c:	e0bffd0d 	sth	r2,-12(fp)
81139230:	e0bffd0b 	ldhu	r2,-12(fp)
81139234:	10800ff0 	cmpltui	r2,r2,63
81139238:	103fea1e 	bne	r2,zero,811391e4 <__reset+0xfb1191e4>
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
8113923c:	e0bffe17 	ldw	r2,-8(fp)
81139240:	10000005 	stb	zero,0(r2)
    pevent1->OSEventPtr             = (OS_EVENT *)0;
81139244:	e0bffe17 	ldw	r2,-8(fp)
81139248:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';
8113924c:	e0bffe17 	ldw	r2,-8(fp)
81139250:	00c00fc4 	movi	r3,63
81139254:	10c00445 	stb	r3,17(r2)
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
81139258:	e0bffe17 	ldw	r2,-8(fp)
8113925c:	10000485 	stb	zero,18(r2)
#endif
    OSEventFreeList                 = &OSEventTbl[0];
81139260:	00a045f4 	movhi	r2,33047
81139264:	10aa3004 	addi	r2,r2,-22336
81139268:	d0a0a015 	stw	r2,-32128(gp)
    OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
    OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
#endif
#endif
#endif
}
8113926c:	0001883a 	nop
81139270:	e037883a 	mov	sp,fp
81139274:	dfc00117 	ldw	ra,4(sp)
81139278:	df000017 	ldw	fp,0(sp)
8113927c:	dec00204 	addi	sp,sp,8
81139280:	f800283a 	ret

81139284 <OS_InitMisc>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitMisc (void)
{
81139284:	deffff04 	addi	sp,sp,-4
81139288:	de00012e 	bgeu	sp,et,81139290 <OS_InitMisc+0xc>
8113928c:	003b68fa 	trap	3
81139290:	df000015 	stw	fp,0(sp)
81139294:	d839883a 	mov	fp,sp
#if OS_TIME_GET_SET_EN > 0
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
81139298:	d020a415 	stw	zero,-32112(gp)
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
8113929c:	d020a105 	stb	zero,-32124(gp)
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
811392a0:	d0208f05 	stb	zero,-32196(gp)

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
811392a4:	d0209a45 	stb	zero,-32151(gp)

    OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
811392a8:	d0209105 	stb	zero,-32188(gp)

    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
811392ac:	d0209615 	stw	zero,-32168(gp)
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
811392b0:	d0209215 	stw	zero,-32184(gp)

#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
811392b4:	d020a815 	stw	zero,-32096(gp)
    OSIdleCtrMax  = 0L;
811392b8:	d0209815 	stw	zero,-32160(gp)
    OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
811392bc:	d020a705 	stb	zero,-32100(gp)
#endif
}
811392c0:	0001883a 	nop
811392c4:	e037883a 	mov	sp,fp
811392c8:	df000017 	ldw	fp,0(sp)
811392cc:	dec00104 	addi	sp,sp,4
811392d0:	f800283a 	ret

811392d4 <OS_InitRdyList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitRdyList (void)
{
811392d4:	defffd04 	addi	sp,sp,-12
811392d8:	de00012e 	bgeu	sp,et,811392e0 <OS_InitRdyList+0xc>
811392dc:	003b68fa 	trap	3
811392e0:	df000215 	stw	fp,8(sp)
811392e4:	df000204 	addi	fp,sp,8
#else
    INT16U  *prdytbl;
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
811392e8:	d0209e05 	stb	zero,-32136(gp)
    prdytbl       = &OSRdyTbl[0];
811392ec:	d0a09e44 	addi	r2,gp,-32135
811392f0:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
811392f4:	e03ffe05 	stb	zero,-8(fp)
811392f8:	00000706 	br	81139318 <OS_InitRdyList+0x44>
        *prdytbl++ = 0;
811392fc:	e0bfff17 	ldw	r2,-4(fp)
81139300:	10c00044 	addi	r3,r2,1
81139304:	e0ffff15 	stw	r3,-4(fp)
81139308:	10000005 	stb	zero,0(r2)
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
8113930c:	e0bffe03 	ldbu	r2,-8(fp)
81139310:	10800044 	addi	r2,r2,1
81139314:	e0bffe05 	stb	r2,-8(fp)
81139318:	e0bffe03 	ldbu	r2,-8(fp)
8113931c:	108001b0 	cmpltui	r2,r2,6
81139320:	103ff61e 	bne	r2,zero,811392fc <__reset+0xfb1192fc>
        *prdytbl++ = 0;
    }

    OSPrioCur     = 0;
81139324:	d02093c5 	stb	zero,-32177(gp)
    OSPrioHighRdy = 0;
81139328:	d0209385 	stb	zero,-32178(gp)

    OSTCBHighRdy  = (OS_TCB *)0;
8113932c:	d0209c15 	stw	zero,-32144(gp)
    OSTCBCur      = (OS_TCB *)0;
81139330:	d020a215 	stw	zero,-32120(gp)
}
81139334:	0001883a 	nop
81139338:	e037883a 	mov	sp,fp
8113933c:	df000017 	ldw	fp,0(sp)
81139340:	dec00104 	addi	sp,sp,4
81139344:	f800283a 	ret

81139348 <OS_InitTaskIdle>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTaskIdle (void)
{
81139348:	defff804 	addi	sp,sp,-32
8113934c:	de00012e 	bgeu	sp,et,81139354 <OS_InitTaskIdle+0xc>
81139350:	003b68fa 	trap	3
81139354:	dfc00715 	stw	ra,28(sp)
81139358:	df000615 	stw	fp,24(sp)
8113935c:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
81139360:	008000c4 	movi	r2,3
81139364:	d8800415 	stw	r2,16(sp)
81139368:	d8000315 	stw	zero,12(sp)
8113936c:	00810004 	movi	r2,1024
81139370:	d8800215 	stw	r2,8(sp)
81139374:	00a045f4 	movhi	r2,33047
81139378:	10a63004 	addi	r2,r2,-26432
8113937c:	d8800115 	stw	r2,4(sp)
81139380:	00bfffd4 	movui	r2,65535
81139384:	d8800015 	stw	r2,0(sp)
81139388:	01c00a84 	movi	r7,42
8113938c:	01a045f4 	movhi	r6,33047
81139390:	31aa2f04 	addi	r6,r6,-22340
81139394:	000b883a 	mov	r5,zero
81139398:	01204534 	movhi	r4,33044
8113939c:	21260f04 	addi	r4,r4,-26564
811393a0:	113f22c0 	call	8113f22c <OSTaskCreateExt>
                       OS_TASK_IDLE_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
811393a4:	e1bfff04 	addi	r6,fp,-4
811393a8:	01604574 	movhi	r5,33045
811393ac:	2942a304 	addi	r5,r5,2700
811393b0:	01000a84 	movi	r4,42
811393b4:	113fa5c0 	call	8113fa5c <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
#endif
#endif
}
811393b8:	0001883a 	nop
811393bc:	e037883a 	mov	sp,fp
811393c0:	dfc00117 	ldw	ra,4(sp)
811393c4:	df000017 	ldw	fp,0(sp)
811393c8:	dec00204 	addi	sp,sp,8
811393cc:	f800283a 	ret

811393d0 <OS_InitTaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
static  void  OS_InitTaskStat (void)
{
811393d0:	defff804 	addi	sp,sp,-32
811393d4:	de00012e 	bgeu	sp,et,811393dc <OS_InitTaskStat+0xc>
811393d8:	003b68fa 	trap	3
811393dc:	dfc00715 	stw	ra,28(sp)
811393e0:	df000615 	stw	fp,24(sp)
811393e4:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskStat,
811393e8:	008000c4 	movi	r2,3
811393ec:	d8800415 	stw	r2,16(sp)
811393f0:	d8000315 	stw	zero,12(sp)
811393f4:	00810004 	movi	r2,1024
811393f8:	d8800215 	stw	r2,8(sp)
811393fc:	00a045b4 	movhi	r2,33046
81139400:	109f7004 	addi	r2,r2,32192
81139404:	d8800115 	stw	r2,4(sp)
81139408:	00bfff94 	movui	r2,65534
8113940c:	d8800015 	stw	r2,0(sp)
81139410:	01c00a44 	movi	r7,41
81139414:	01a045f4 	movhi	r6,33047
81139418:	31a36f04 	addi	r6,r6,-29252
8113941c:	000b883a 	mov	r5,zero
81139420:	01204534 	movhi	r4,33044
81139424:	21262804 	addi	r4,r4,-26464
81139428:	113f22c0 	call	8113f22c <OSTaskCreateExt>
                       OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
8113942c:	e1bfff04 	addi	r6,fp,-4
81139430:	01604574 	movhi	r5,33045
81139434:	2942a704 	addi	r5,r5,2716
81139438:	01000a44 	movi	r4,41
8113943c:	113fa5c0 	call	8113fa5c <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
#endif
#endif
}
81139440:	0001883a 	nop
81139444:	e037883a 	mov	sp,fp
81139448:	dfc00117 	ldw	ra,4(sp)
8113944c:	df000017 	ldw	fp,0(sp)
81139450:	dec00204 	addi	sp,sp,8
81139454:	f800283a 	ret

81139458 <OS_InitTCBList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTCBList (void)
{
81139458:	defffb04 	addi	sp,sp,-20
8113945c:	de00012e 	bgeu	sp,et,81139464 <OS_InitTCBList+0xc>
81139460:	003b68fa 	trap	3
81139464:	dfc00415 	stw	ra,16(sp)
81139468:	df000315 	stw	fp,12(sp)
8113946c:	df000304 	addi	fp,sp,12
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
81139470:	01446e04 	movi	r5,4536
81139474:	012045f4 	movhi	r4,33047
81139478:	212d7004 	addi	r4,r4,-19008
8113947c:	11395440 	call	81139544 <OS_MemClr>
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
81139480:	01402b04 	movi	r5,172
81139484:	012045f4 	movhi	r4,33047
81139488:	2131de04 	addi	r4,r4,-14472
8113948c:	11395440 	call	81139544 <OS_MemClr>
    ptcb1 = &OSTCBTbl[0];
81139490:	00a045f4 	movhi	r2,33047
81139494:	10ad7004 	addi	r2,r2,-19008
81139498:	e0bffe15 	stw	r2,-8(fp)
    ptcb2 = &OSTCBTbl[1];
8113949c:	00a045f4 	movhi	r2,33047
811394a0:	10ad8b04 	addi	r2,r2,-18900
811394a4:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
811394a8:	e03ffd05 	stb	zero,-12(fp)
811394ac:	00001106 	br	811394f4 <OS_InitTCBList+0x9c>
        ptcb1->OSTCBNext = ptcb2;
811394b0:	e0bffe17 	ldw	r2,-8(fp)
811394b4:	e0ffff17 	ldw	r3,-4(fp)
811394b8:	10c00515 	stw	r3,20(r2)
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
811394bc:	e0bffe17 	ldw	r2,-8(fp)
811394c0:	00c00fc4 	movi	r3,63
811394c4:	10c01305 	stb	r3,76(r2)
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
811394c8:	e0bffe17 	ldw	r2,-8(fp)
811394cc:	10001345 	stb	zero,77(r2)
#endif
        ptcb1++;
811394d0:	e0bffe17 	ldw	r2,-8(fp)
811394d4:	10801b04 	addi	r2,r2,108
811394d8:	e0bffe15 	stw	r2,-8(fp)
        ptcb2++;
811394dc:	e0bfff17 	ldw	r2,-4(fp)
811394e0:	10801b04 	addi	r2,r2,108
811394e4:	e0bfff15 	stw	r2,-4(fp)

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
811394e8:	e0bffd03 	ldbu	r2,-12(fp)
811394ec:	10800044 	addi	r2,r2,1
811394f0:	e0bffd05 	stb	r2,-12(fp)
811394f4:	e0bffd03 	ldbu	r2,-12(fp)
811394f8:	10800a70 	cmpltui	r2,r2,41
811394fc:	103fec1e 	bne	r2,zero,811394b0 <__reset+0xfb1194b0>
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
81139500:	e0bffe17 	ldw	r2,-8(fp)
81139504:	10000515 	stw	zero,20(r2)
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
81139508:	e0bffe17 	ldw	r2,-8(fp)
8113950c:	00c00fc4 	movi	r3,63
81139510:	10c01305 	stb	r3,76(r2)
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
81139514:	e0bffe17 	ldw	r2,-8(fp)
81139518:	10001345 	stb	zero,77(r2)
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
8113951c:	d0209415 	stw	zero,-32176(gp)
    OSTCBFreeList           = &OSTCBTbl[0];
81139520:	00a045f4 	movhi	r2,33047
81139524:	10ad7004 	addi	r2,r2,-19008
81139528:	d0a09915 	stw	r2,-32156(gp)
}
8113952c:	0001883a 	nop
81139530:	e037883a 	mov	sp,fp
81139534:	dfc00117 	ldw	ra,4(sp)
81139538:	df000017 	ldw	fp,0(sp)
8113953c:	dec00204 	addi	sp,sp,8
81139540:	f800283a 	ret

81139544 <OS_MemClr>:
*                 of the alignment of the destination.
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
81139544:	defffd04 	addi	sp,sp,-12
81139548:	de00012e 	bgeu	sp,et,81139550 <OS_MemClr+0xc>
8113954c:	003b68fa 	trap	3
81139550:	df000215 	stw	fp,8(sp)
81139554:	df000204 	addi	fp,sp,8
81139558:	e13ffe15 	stw	r4,-8(fp)
8113955c:	2805883a 	mov	r2,r5
81139560:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
81139564:	00000706 	br	81139584 <OS_MemClr+0x40>
        *pdest++ = (INT8U)0;
81139568:	e0bffe17 	ldw	r2,-8(fp)
8113956c:	10c00044 	addi	r3,r2,1
81139570:	e0fffe15 	stw	r3,-8(fp)
81139574:	10000005 	stb	zero,0(r2)
        size--;
81139578:	e0bfff0b 	ldhu	r2,-4(fp)
8113957c:	10bfffc4 	addi	r2,r2,-1
81139580:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
81139584:	e0bfff0b 	ldhu	r2,-4(fp)
81139588:	103ff71e 	bne	r2,zero,81139568 <__reset+0xfb119568>
        *pdest++ = (INT8U)0;
        size--;
    }
}
8113958c:	0001883a 	nop
81139590:	e037883a 	mov	sp,fp
81139594:	df000017 	ldw	fp,0(sp)
81139598:	dec00104 	addi	sp,sp,4
8113959c:	f800283a 	ret

811395a0 <OS_MemCopy>:
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
811395a0:	defffc04 	addi	sp,sp,-16
811395a4:	de00012e 	bgeu	sp,et,811395ac <OS_MemCopy+0xc>
811395a8:	003b68fa 	trap	3
811395ac:	df000315 	stw	fp,12(sp)
811395b0:	df000304 	addi	fp,sp,12
811395b4:	e13ffd15 	stw	r4,-12(fp)
811395b8:	e17ffe15 	stw	r5,-8(fp)
811395bc:	3005883a 	mov	r2,r6
811395c0:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
811395c4:	00000b06 	br	811395f4 <OS_MemCopy+0x54>
        *pdest++ = *psrc++;
811395c8:	e0bffd17 	ldw	r2,-12(fp)
811395cc:	10c00044 	addi	r3,r2,1
811395d0:	e0fffd15 	stw	r3,-12(fp)
811395d4:	e0fffe17 	ldw	r3,-8(fp)
811395d8:	19000044 	addi	r4,r3,1
811395dc:	e13ffe15 	stw	r4,-8(fp)
811395e0:	18c00003 	ldbu	r3,0(r3)
811395e4:	10c00005 	stb	r3,0(r2)
        size--;
811395e8:	e0bfff0b 	ldhu	r2,-4(fp)
811395ec:	10bfffc4 	addi	r2,r2,-1
811395f0:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
811395f4:	e0bfff0b 	ldhu	r2,-4(fp)
811395f8:	103ff31e 	bne	r2,zero,811395c8 <__reset+0xfb1195c8>
        *pdest++ = *psrc++;
        size--;
    }
}
811395fc:	0001883a 	nop
81139600:	e037883a 	mov	sp,fp
81139604:	df000017 	ldw	fp,0(sp)
81139608:	dec00104 	addi	sp,sp,4
8113960c:	f800283a 	ret

81139610 <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
81139610:	defffb04 	addi	sp,sp,-20
81139614:	de00012e 	bgeu	sp,et,8113961c <OS_Sched+0xc>
81139618:	003b68fa 	trap	3
8113961c:	dfc00415 	stw	ra,16(sp)
81139620:	df000315 	stw	fp,12(sp)
81139624:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81139628:	e03ffd15 	stw	zero,-12(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113962c:	0005303a 	rdctl	r2,status
81139630:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139634:	e0ffff17 	ldw	r3,-4(fp)
81139638:	00bfff84 	movi	r2,-2
8113963c:	1884703a 	and	r2,r3,r2
81139640:	1001703a 	wrctl	status,r2
  
  return context;
81139644:	e0bfff17 	ldw	r2,-4(fp)
#endif



    OS_ENTER_CRITICAL();
81139648:	e0bffd15 	stw	r2,-12(fp)
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
8113964c:	d0a0a103 	ldbu	r2,-32124(gp)
81139650:	10803fcc 	andi	r2,r2,255
81139654:	10001a1e 	bne	r2,zero,811396c0 <OS_Sched+0xb0>
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
81139658:	d0a08f03 	ldbu	r2,-32196(gp)
8113965c:	10803fcc 	andi	r2,r2,255
81139660:	1000171e 	bne	r2,zero,811396c0 <OS_Sched+0xb0>
            OS_SchedNew();
81139664:	11396e80 	call	811396e8 <OS_SchedNew>
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
81139668:	d0e09383 	ldbu	r3,-32178(gp)
8113966c:	d0a093c3 	ldbu	r2,-32177(gp)
81139670:	18c03fcc 	andi	r3,r3,255
81139674:	10803fcc 	andi	r2,r2,255
81139678:	18801126 	beq	r3,r2,811396c0 <OS_Sched+0xb0>
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
8113967c:	d0a09383 	ldbu	r2,-32178(gp)
81139680:	10c03fcc 	andi	r3,r2,255
81139684:	00a045f4 	movhi	r2,33047
81139688:	10b1de04 	addi	r2,r2,-14472
8113968c:	18c7883a 	add	r3,r3,r3
81139690:	18c7883a 	add	r3,r3,r3
81139694:	10c5883a 	add	r2,r2,r3
81139698:	10800017 	ldw	r2,0(r2)
8113969c:	d0a09c15 	stw	r2,-32144(gp)
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
811396a0:	d0a09c17 	ldw	r2,-32144(gp)
811396a4:	10c00e17 	ldw	r3,56(r2)
811396a8:	18c00044 	addi	r3,r3,1
811396ac:	10c00e15 	stw	r3,56(r2)
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
811396b0:	d0a09617 	ldw	r2,-32168(gp)
811396b4:	10800044 	addi	r2,r2,1
811396b8:	d0a09615 	stw	r2,-32168(gp)
                OS_TASK_SW();                          /* Perform a context switch                     */
811396bc:	114a6400 	call	8114a640 <OSCtxSw>
811396c0:	e0bffd17 	ldw	r2,-12(fp)
811396c4:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811396c8:	e0bffe17 	ldw	r2,-8(fp)
811396cc:	1001703a 	wrctl	status,r2
            }
        }
    }
    OS_EXIT_CRITICAL();
}
811396d0:	0001883a 	nop
811396d4:	e037883a 	mov	sp,fp
811396d8:	dfc00117 	ldw	ra,4(sp)
811396dc:	df000017 	ldw	fp,0(sp)
811396e0:	dec00204 	addi	sp,sp,8
811396e4:	f800283a 	ret

811396e8 <OS_SchedNew>:
*              2) Interrupts are assumed to be disabled when this function is called.
*********************************************************************************************************
*/

static  void  OS_SchedNew (void)
{
811396e8:	defffe04 	addi	sp,sp,-8
811396ec:	de00012e 	bgeu	sp,et,811396f4 <OS_SchedNew+0xc>
811396f0:	003b68fa 	trap	3
811396f4:	df000115 	stw	fp,4(sp)
811396f8:	df000104 	addi	fp,sp,4
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
811396fc:	d0a09e03 	ldbu	r2,-32136(gp)
81139700:	10c03fcc 	andi	r3,r2,255
81139704:	00a04574 	movhi	r2,33045
81139708:	10826304 	addi	r2,r2,2444
8113970c:	10c5883a 	add	r2,r2,r3
81139710:	10800003 	ldbu	r2,0(r2)
81139714:	e0bfff05 	stb	r2,-4(fp)
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
81139718:	e0bfff03 	ldbu	r2,-4(fp)
8113971c:	100490fa 	slli	r2,r2,3
81139720:	1009883a 	mov	r4,r2
81139724:	e0ffff03 	ldbu	r3,-4(fp)
81139728:	d0a09e44 	addi	r2,gp,-32135
8113972c:	1885883a 	add	r2,r3,r2
81139730:	10800003 	ldbu	r2,0(r2)
81139734:	10c03fcc 	andi	r3,r2,255
81139738:	00a04574 	movhi	r2,33045
8113973c:	10826304 	addi	r2,r2,2444
81139740:	10c5883a 	add	r2,r2,r3
81139744:	10800003 	ldbu	r2,0(r2)
81139748:	2085883a 	add	r2,r4,r2
8113974c:	d0a09385 	stb	r2,-32178(gp)
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
    } else {
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
    }
#endif
}
81139750:	0001883a 	nop
81139754:	e037883a 	mov	sp,fp
81139758:	df000017 	ldw	fp,0(sp)
8113975c:	dec00104 	addi	sp,sp,4
81139760:	f800283a 	ret

81139764 <OS_StrCopy>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
{
81139764:	defffc04 	addi	sp,sp,-16
81139768:	de00012e 	bgeu	sp,et,81139770 <OS_StrCopy+0xc>
8113976c:	003b68fa 	trap	3
81139770:	df000315 	stw	fp,12(sp)
81139774:	df000304 	addi	fp,sp,12
81139778:	e13ffe15 	stw	r4,-8(fp)
8113977c:	e17fff15 	stw	r5,-4(fp)
    INT8U  len;


    len = 0;
81139780:	e03ffd05 	stb	zero,-12(fp)
    while (*psrc != OS_ASCII_NUL) {
81139784:	00000b06 	br	811397b4 <OS_StrCopy+0x50>
        *pdest++ = *psrc++;
81139788:	e0bffe17 	ldw	r2,-8(fp)
8113978c:	10c00044 	addi	r3,r2,1
81139790:	e0fffe15 	stw	r3,-8(fp)
81139794:	e0ffff17 	ldw	r3,-4(fp)
81139798:	19000044 	addi	r4,r3,1
8113979c:	e13fff15 	stw	r4,-4(fp)
811397a0:	18c00003 	ldbu	r3,0(r3)
811397a4:	10c00005 	stb	r3,0(r2)
        len++;
811397a8:	e0bffd03 	ldbu	r2,-12(fp)
811397ac:	10800044 	addi	r2,r2,1
811397b0:	e0bffd05 	stb	r2,-12(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
811397b4:	e0bfff17 	ldw	r2,-4(fp)
811397b8:	10800003 	ldbu	r2,0(r2)
811397bc:	10803fcc 	andi	r2,r2,255
811397c0:	103ff11e 	bne	r2,zero,81139788 <__reset+0xfb119788>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
811397c4:	e0bffe17 	ldw	r2,-8(fp)
811397c8:	10000005 	stb	zero,0(r2)
    return (len);
811397cc:	e0bffd03 	ldbu	r2,-12(fp)
}
811397d0:	e037883a 	mov	sp,fp
811397d4:	df000017 	ldw	fp,0(sp)
811397d8:	dec00104 	addi	sp,sp,4
811397dc:	f800283a 	ret

811397e0 <OS_StrLen>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrLen (INT8U *psrc)
{
811397e0:	defffd04 	addi	sp,sp,-12
811397e4:	de00012e 	bgeu	sp,et,811397ec <OS_StrLen+0xc>
811397e8:	003b68fa 	trap	3
811397ec:	df000215 	stw	fp,8(sp)
811397f0:	df000204 	addi	fp,sp,8
811397f4:	e13fff15 	stw	r4,-4(fp)
    INT8U  len;


    len = 0;
811397f8:	e03ffe05 	stb	zero,-8(fp)
    while (*psrc != OS_ASCII_NUL) {
811397fc:	00000606 	br	81139818 <OS_StrLen+0x38>
        psrc++;
81139800:	e0bfff17 	ldw	r2,-4(fp)
81139804:	10800044 	addi	r2,r2,1
81139808:	e0bfff15 	stw	r2,-4(fp)
        len++;
8113980c:	e0bffe03 	ldbu	r2,-8(fp)
81139810:	10800044 	addi	r2,r2,1
81139814:	e0bffe05 	stb	r2,-8(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
81139818:	e0bfff17 	ldw	r2,-4(fp)
8113981c:	10800003 	ldbu	r2,0(r2)
81139820:	10803fcc 	andi	r2,r2,255
81139824:	103ff61e 	bne	r2,zero,81139800 <__reset+0xfb119800>
        psrc++;
        len++;
    }
    return (len);
81139828:	e0bffe03 	ldbu	r2,-8(fp)
}
8113982c:	e037883a 	mov	sp,fp
81139830:	df000017 	ldw	fp,0(sp)
81139834:	dec00104 	addi	sp,sp,4
81139838:	f800283a 	ret

8113983c <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *p_arg)
{
8113983c:	defffa04 	addi	sp,sp,-24
81139840:	de00012e 	bgeu	sp,et,81139848 <OS_TaskIdle+0xc>
81139844:	003b68fa 	trap	3
81139848:	dfc00515 	stw	ra,20(sp)
8113984c:	df000415 	stw	fp,16(sp)
81139850:	df000404 	addi	fp,sp,16
81139854:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81139858:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113985c:	0005303a 	rdctl	r2,status
81139860:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139864:	e0fffd17 	ldw	r3,-12(fp)
81139868:	00bfff84 	movi	r2,-2
8113986c:	1884703a 	and	r2,r3,r2
81139870:	1001703a 	wrctl	status,r2
  
  return context;
81139874:	e0bffd17 	ldw	r2,-12(fp)



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    for (;;) {
        OS_ENTER_CRITICAL();
81139878:	e0bffc15 	stw	r2,-16(fp)
        OSIdleCtr++;
8113987c:	d0a09217 	ldw	r2,-32184(gp)
81139880:	10800044 	addi	r2,r2,1
81139884:	d0a09215 	stw	r2,-32184(gp)
81139888:	e0bffc17 	ldw	r2,-16(fp)
8113988c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139890:	e0bffe17 	ldw	r2,-8(fp)
81139894:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
81139898:	114a9d40 	call	8114a9d4 <OSTaskIdleHook>
    }
8113989c:	003fef06 	br	8113985c <__reset+0xfb11985c>

811398a0 <OS_TaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OS_TaskStat (void *p_arg)
{
811398a0:	defff804 	addi	sp,sp,-32
811398a4:	de00012e 	bgeu	sp,et,811398ac <OS_TaskStat+0xc>
811398a8:	003b68fa 	trap	3
811398ac:	dfc00715 	stw	ra,28(sp)
811398b0:	df000615 	stw	fp,24(sp)
811398b4:	dc400515 	stw	r17,20(sp)
811398b8:	dc000415 	stw	r16,16(sp)
811398bc:	df000604 	addi	fp,sp,24
811398c0:	e13ffd15 	stw	r4,-12(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811398c4:	e03ffa15 	stw	zero,-24(fp)
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
811398c8:	00000206 	br	811398d4 <OS_TaskStat+0x34>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
811398cc:	01003204 	movi	r4,200
811398d0:	114034c0 	call	8114034c <OSTimeDly>
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
811398d4:	d0a0a703 	ldbu	r2,-32100(gp)
811398d8:	10803fcc 	andi	r2,r2,255
811398dc:	103ffb26 	beq	r2,zero,811398cc <__reset+0xfb1198cc>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
    }
    OSIdleCtrMax /= 100L;
811398e0:	d0e09817 	ldw	r3,-32160(gp)
811398e4:	00947b34 	movhi	r2,20972
811398e8:	10a147c4 	addi	r2,r2,-31457
811398ec:	1888383a 	mulxuu	r4,r3,r2
811398f0:	1885383a 	mul	r2,r3,r2
811398f4:	1021883a 	mov	r16,r2
811398f8:	2023883a 	mov	r17,r4
811398fc:	8804d17a 	srli	r2,r17,5
81139900:	d0a09815 	stw	r2,-32160(gp)
    if (OSIdleCtrMax == 0L) {
81139904:	d0a09817 	ldw	r2,-32160(gp)
81139908:	1000031e 	bne	r2,zero,81139918 <OS_TaskStat+0x78>
        OSCPUUsage = 0;
8113990c:	d0209a05 	stb	zero,-32152(gp)
        (void)OSTaskSuspend(OS_PRIO_SELF);
81139910:	01003fc4 	movi	r4,255
81139914:	113ffbc0 	call	8113ffbc <OSTaskSuspend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139918:	0005303a 	rdctl	r2,status
8113991c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139920:	e0fffb17 	ldw	r3,-20(fp)
81139924:	00bfff84 	movi	r2,-2
81139928:	1884703a 	and	r2,r3,r2
8113992c:	1001703a 	wrctl	status,r2
  
  return context;
81139930:	e0bffb17 	ldw	r2,-20(fp)
    }
    for (;;) {
        OS_ENTER_CRITICAL();
81139934:	e0bffa15 	stw	r2,-24(fp)
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
81139938:	d0a09217 	ldw	r2,-32184(gp)
8113993c:	d0a0a815 	stw	r2,-32096(gp)
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
81139940:	d0209215 	stw	zero,-32184(gp)
81139944:	e0bffa17 	ldw	r2,-24(fp)
81139948:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113994c:	e0bffc17 	ldw	r2,-16(fp)
81139950:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
81139954:	d0e0a817 	ldw	r3,-32096(gp)
81139958:	d0a09817 	ldw	r2,-32160(gp)
8113995c:	1885203a 	divu	r2,r3,r2
81139960:	1007883a 	mov	r3,r2
81139964:	00801904 	movi	r2,100
81139968:	10c5c83a 	sub	r2,r2,r3
8113996c:	d0a09a05 	stb	r2,-32152(gp)
        OSTaskStatHook();                        /* Invoke user definable hook                         */
81139970:	114a9040 	call	8114a904 <OSTaskStatHook>
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
        OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
81139974:	11399840 	call	81139984 <OS_TaskStatStkChk>
#endif
        OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
81139978:	01001904 	movi	r4,100
8113997c:	114034c0 	call	8114034c <OSTimeDly>
    }
81139980:	003fe506 	br	81139918 <__reset+0xfb119918>

81139984 <OS_TaskStatStkChk>:
*********************************************************************************************************
*/

#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStatStkChk (void)
{
81139984:	defffa04 	addi	sp,sp,-24
81139988:	de00012e 	bgeu	sp,et,81139990 <OS_TaskStatStkChk+0xc>
8113998c:	003b68fa 	trap	3
81139990:	dfc00515 	stw	ra,20(sp)
81139994:	df000415 	stw	fp,16(sp)
81139998:	df000404 	addi	fp,sp,16
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
8113999c:	e03ffc05 	stb	zero,-16(fp)
811399a0:	00002406 	br	81139a34 <OS_TaskStatStkChk+0xb0>
        err = OSTaskStkChk(prio, &stk_data);
811399a4:	e0bffc03 	ldbu	r2,-16(fp)
811399a8:	e0fffe04 	addi	r3,fp,-8
811399ac:	180b883a 	mov	r5,r3
811399b0:	1009883a 	mov	r4,r2
811399b4:	113fdf40 	call	8113fdf4 <OSTaskStkChk>
811399b8:	e0bffc45 	stb	r2,-15(fp)
        if (err == OS_ERR_NONE) {
811399bc:	e0bffc43 	ldbu	r2,-15(fp)
811399c0:	1000191e 	bne	r2,zero,81139a28 <OS_TaskStatStkChk+0xa4>
            ptcb = OSTCBPrioTbl[prio];
811399c4:	e0fffc03 	ldbu	r3,-16(fp)
811399c8:	00a045f4 	movhi	r2,33047
811399cc:	10b1de04 	addi	r2,r2,-14472
811399d0:	18c7883a 	add	r3,r3,r3
811399d4:	18c7883a 	add	r3,r3,r3
811399d8:	10c5883a 	add	r2,r2,r3
811399dc:	10800017 	ldw	r2,0(r2)
811399e0:	e0bffd15 	stw	r2,-12(fp)
            if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
811399e4:	e0bffd17 	ldw	r2,-12(fp)
811399e8:	10000f26 	beq	r2,zero,81139a28 <OS_TaskStatStkChk+0xa4>
                if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
811399ec:	e0bffd17 	ldw	r2,-12(fp)
811399f0:	10800060 	cmpeqi	r2,r2,1
811399f4:	10000c1e 	bne	r2,zero,81139a28 <OS_TaskStatStkChk+0xa4>
#if OS_TASK_PROFILE_EN > 0
                    #if OS_STK_GROWTH == 1
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
811399f8:	e0bffd17 	ldw	r2,-12(fp)
811399fc:	10c00217 	ldw	r3,8(r2)
81139a00:	e0bffd17 	ldw	r2,-12(fp)
81139a04:	10800317 	ldw	r2,12(r2)
81139a08:	1085883a 	add	r2,r2,r2
81139a0c:	1085883a 	add	r2,r2,r2
81139a10:	1887883a 	add	r3,r3,r2
81139a14:	e0bffd17 	ldw	r2,-12(fp)
81139a18:	10c01115 	stw	r3,68(r2)
                    #else
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    #endif
                    ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
81139a1c:	e0ffff17 	ldw	r3,-4(fp)
81139a20:	e0bffd17 	ldw	r2,-12(fp)
81139a24:	10c01215 	stw	r3,72(r2)
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
81139a28:	e0bffc03 	ldbu	r2,-16(fp)
81139a2c:	10800044 	addi	r2,r2,1
81139a30:	e0bffc05 	stb	r2,-16(fp)
81139a34:	e0bffc03 	ldbu	r2,-16(fp)
81139a38:	10800af0 	cmpltui	r2,r2,43
81139a3c:	103fd91e 	bne	r2,zero,811399a4 <__reset+0xfb1199a4>
#endif
                }
            }
        }
    }
}
81139a40:	0001883a 	nop
81139a44:	e037883a 	mov	sp,fp
81139a48:	dfc00117 	ldw	ra,4(sp)
81139a4c:	df000017 	ldw	fp,0(sp)
81139a50:	dec00204 	addi	sp,sp,8
81139a54:	f800283a 	ret

81139a58 <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
81139a58:	defff204 	addi	sp,sp,-56
81139a5c:	de00012e 	bgeu	sp,et,81139a64 <OS_TCBInit+0xc>
81139a60:	003b68fa 	trap	3
81139a64:	dfc00d15 	stw	ra,52(sp)
81139a68:	df000c15 	stw	fp,48(sp)
81139a6c:	df000c04 	addi	fp,sp,48
81139a70:	e17ffc15 	stw	r5,-16(fp)
81139a74:	e1bffd15 	stw	r6,-12(fp)
81139a78:	3807883a 	mov	r3,r7
81139a7c:	e0800417 	ldw	r2,16(fp)
81139a80:	e13ffb05 	stb	r4,-20(fp)
81139a84:	e0fffe0d 	sth	r3,-8(fp)
81139a88:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81139a8c:	e03ff415 	stw	zero,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139a90:	0005303a 	rdctl	r2,status
81139a94:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139a98:	e0fffa17 	ldw	r3,-24(fp)
81139a9c:	00bfff84 	movi	r2,-2
81139aa0:	1884703a 	and	r2,r3,r2
81139aa4:	1001703a 	wrctl	status,r2
  
  return context;
81139aa8:	e0bffa17 	ldw	r2,-24(fp)
#endif



    OS_ENTER_CRITICAL();
81139aac:	e0bff415 	stw	r2,-48(fp)
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
81139ab0:	d0a09917 	ldw	r2,-32156(gp)
81139ab4:	e0bff615 	stw	r2,-40(fp)
    if (ptcb != (OS_TCB *)0) {
81139ab8:	e0bff617 	ldw	r2,-40(fp)
81139abc:	10009326 	beq	r2,zero,81139d0c <OS_TCBInit+0x2b4>
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
81139ac0:	e0bff617 	ldw	r2,-40(fp)
81139ac4:	10800517 	ldw	r2,20(r2)
81139ac8:	d0a09915 	stw	r2,-32156(gp)
81139acc:	e0bff417 	ldw	r2,-48(fp)
81139ad0:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139ad4:	e0bff817 	ldw	r2,-32(fp)
81139ad8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
81139adc:	e0bff617 	ldw	r2,-40(fp)
81139ae0:	e0fffc17 	ldw	r3,-16(fp)
81139ae4:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
81139ae8:	e0bff617 	ldw	r2,-40(fp)
81139aec:	e0fffb03 	ldbu	r3,-20(fp)
81139af0:	10c00c85 	stb	r3,50(r2)
        ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
81139af4:	e0bff617 	ldw	r2,-40(fp)
81139af8:	10000c05 	stb	zero,48(r2)
        ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
81139afc:	e0bff617 	ldw	r2,-40(fp)
81139b00:	10000c45 	stb	zero,49(r2)
        ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
81139b04:	e0bff617 	ldw	r2,-40(fp)
81139b08:	10000b8d 	sth	zero,46(r2)

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
81139b0c:	e0bff617 	ldw	r2,-40(fp)
81139b10:	e0c00317 	ldw	r3,12(fp)
81139b14:	10c00115 	stw	r3,4(r2)
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
81139b18:	e0bff617 	ldw	r2,-40(fp)
81139b1c:	e0c00217 	ldw	r3,8(fp)
81139b20:	10c00315 	stw	r3,12(r2)
        ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
81139b24:	e0bff617 	ldw	r2,-40(fp)
81139b28:	e0fffd17 	ldw	r3,-12(fp)
81139b2c:	10c00215 	stw	r3,8(r2)
        ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
81139b30:	e0bff617 	ldw	r2,-40(fp)
81139b34:	e0ffff0b 	ldhu	r3,-4(fp)
81139b38:	10c0040d 	sth	r3,16(r2)
        ptcb->OSTCBId            = id;                     /* Store task ID                            */
81139b3c:	e0bff617 	ldw	r2,-40(fp)
81139b40:	e0fffe0b 	ldhu	r3,-8(fp)
81139b44:	10c0048d 	sth	r3,18(r2)
        opt                      = opt;
        id                       = id;
#endif

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
81139b48:	e0bff617 	ldw	r2,-40(fp)
81139b4c:	10000dc5 	stb	zero,55(r2)
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
81139b50:	e0bffb03 	ldbu	r2,-20(fp)
81139b54:	1004d0fa 	srli	r2,r2,3
81139b58:	1007883a 	mov	r3,r2
81139b5c:	e0bff617 	ldw	r2,-40(fp)
81139b60:	10c00d05 	stb	r3,52(r2)
        ptcb->OSTCBX             = (INT8U)(prio & 0x07);
81139b64:	e0bffb03 	ldbu	r2,-20(fp)
81139b68:	108001cc 	andi	r2,r2,7
81139b6c:	1007883a 	mov	r3,r2
81139b70:	e0bff617 	ldw	r2,-40(fp)
81139b74:	10c00cc5 	stb	r3,51(r2)
        ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
81139b78:	e0bff617 	ldw	r2,-40(fp)
81139b7c:	10800d03 	ldbu	r2,52(r2)
81139b80:	10803fcc 	andi	r2,r2,255
81139b84:	00c00044 	movi	r3,1
81139b88:	1884983a 	sll	r2,r3,r2
81139b8c:	1007883a 	mov	r3,r2
81139b90:	e0bff617 	ldw	r2,-40(fp)
81139b94:	10c00d85 	stb	r3,54(r2)
        ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
81139b98:	e0bff617 	ldw	r2,-40(fp)
81139b9c:	10800cc3 	ldbu	r2,51(r2)
81139ba0:	10803fcc 	andi	r2,r2,255
81139ba4:	00c00044 	movi	r3,1
81139ba8:	1884983a 	sll	r2,r3,r2
81139bac:	1007883a 	mov	r3,r2
81139bb0:	e0bff617 	ldw	r2,-40(fp)
81139bb4:	10c00d45 	stb	r3,53(r2)
        ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
        ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
#endif

#if (OS_EVENT_EN)
        ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
81139bb8:	e0bff617 	ldw	r2,-40(fp)
81139bbc:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
        ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
81139bc0:	e0bff617 	ldw	r2,-40(fp)
81139bc4:	10000815 	stw	zero,32(r2)
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
81139bc8:	e0bff617 	ldw	r2,-40(fp)
81139bcc:	10000a15 	stw	zero,40(r2)
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
81139bd0:	e0bff617 	ldw	r2,-40(fp)
81139bd4:	10000915 	stw	zero,36(r2)
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
81139bd8:	e0bff617 	ldw	r2,-40(fp)
81139bdc:	10000e15 	stw	zero,56(r2)
        ptcb->OSTCBCyclesStart = 0L;
81139be0:	e0bff617 	ldw	r2,-40(fp)
81139be4:	10001015 	stw	zero,64(r2)
        ptcb->OSTCBCyclesTot   = 0L;
81139be8:	e0bff617 	ldw	r2,-40(fp)
81139bec:	10000f15 	stw	zero,60(r2)
        ptcb->OSTCBStkBase     = (OS_STK *)0;
81139bf0:	e0bff617 	ldw	r2,-40(fp)
81139bf4:	10001115 	stw	zero,68(r2)
        ptcb->OSTCBStkUsed     = 0L;
81139bf8:	e0bff617 	ldw	r2,-40(fp)
81139bfc:	10001215 	stw	zero,72(r2)
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
81139c00:	e0bff617 	ldw	r2,-40(fp)
81139c04:	00c00fc4 	movi	r3,63
81139c08:	10c01305 	stb	r3,76(r2)
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
81139c0c:	e0bff617 	ldw	r2,-40(fp)
81139c10:	10001345 	stb	zero,77(r2)
#endif

        OSTCBInitHook(ptcb);
81139c14:	e13ff617 	ldw	r4,-40(fp)
81139c18:	114a9fc0 	call	8114a9fc <OSTCBInitHook>

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
81139c1c:	e13ff617 	ldw	r4,-40(fp)
81139c20:	114a8840 	call	8114a884 <OSTaskCreateHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139c24:	0005303a 	rdctl	r2,status
81139c28:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139c2c:	e0fff517 	ldw	r3,-44(fp)
81139c30:	00bfff84 	movi	r2,-2
81139c34:	1884703a 	and	r2,r3,r2
81139c38:	1001703a 	wrctl	status,r2
  
  return context;
81139c3c:	e0bff517 	ldw	r2,-44(fp)

        OS_ENTER_CRITICAL();
81139c40:	e0bff415 	stw	r2,-48(fp)
        OSTCBPrioTbl[prio] = ptcb;
81139c44:	e0fffb03 	ldbu	r3,-20(fp)
81139c48:	00a045f4 	movhi	r2,33047
81139c4c:	10b1de04 	addi	r2,r2,-14472
81139c50:	18c7883a 	add	r3,r3,r3
81139c54:	18c7883a 	add	r3,r3,r3
81139c58:	10c5883a 	add	r2,r2,r3
81139c5c:	e0fff617 	ldw	r3,-40(fp)
81139c60:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
81139c64:	d0e09417 	ldw	r3,-32176(gp)
81139c68:	e0bff617 	ldw	r2,-40(fp)
81139c6c:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBPrev    = (OS_TCB *)0;
81139c70:	e0bff617 	ldw	r2,-40(fp)
81139c74:	10000615 	stw	zero,24(r2)
        if (OSTCBList != (OS_TCB *)0) {
81139c78:	d0a09417 	ldw	r2,-32176(gp)
81139c7c:	10000326 	beq	r2,zero,81139c8c <OS_TCBInit+0x234>
            OSTCBList->OSTCBPrev = ptcb;
81139c80:	d0a09417 	ldw	r2,-32176(gp)
81139c84:	e0fff617 	ldw	r3,-40(fp)
81139c88:	10c00615 	stw	r3,24(r2)
        }
        OSTCBList               = ptcb;
81139c8c:	e0bff617 	ldw	r2,-40(fp)
81139c90:	d0a09415 	stw	r2,-32176(gp)
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
81139c94:	e0bff617 	ldw	r2,-40(fp)
81139c98:	10c00d83 	ldbu	r3,54(r2)
81139c9c:	d0a09e03 	ldbu	r2,-32136(gp)
81139ca0:	1884b03a 	or	r2,r3,r2
81139ca4:	d0a09e05 	stb	r2,-32136(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81139ca8:	e0bff617 	ldw	r2,-40(fp)
81139cac:	10800d03 	ldbu	r2,52(r2)
81139cb0:	10c03fcc 	andi	r3,r2,255
81139cb4:	e0bff617 	ldw	r2,-40(fp)
81139cb8:	10800d03 	ldbu	r2,52(r2)
81139cbc:	11003fcc 	andi	r4,r2,255
81139cc0:	d0a09e44 	addi	r2,gp,-32135
81139cc4:	2085883a 	add	r2,r4,r2
81139cc8:	11000003 	ldbu	r4,0(r2)
81139ccc:	e0bff617 	ldw	r2,-40(fp)
81139cd0:	10800d43 	ldbu	r2,53(r2)
81139cd4:	2084b03a 	or	r2,r4,r2
81139cd8:	1009883a 	mov	r4,r2
81139cdc:	d0a09e44 	addi	r2,gp,-32135
81139ce0:	1885883a 	add	r2,r3,r2
81139ce4:	11000005 	stb	r4,0(r2)
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
81139ce8:	d0a09a43 	ldbu	r2,-32151(gp)
81139cec:	10800044 	addi	r2,r2,1
81139cf0:	d0a09a45 	stb	r2,-32151(gp)
81139cf4:	e0bff417 	ldw	r2,-48(fp)
81139cf8:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139cfc:	e0bff717 	ldw	r2,-36(fp)
81139d00:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
81139d04:	0005883a 	mov	r2,zero
81139d08:	00000506 	br	81139d20 <OS_TCBInit+0x2c8>
81139d0c:	e0bff417 	ldw	r2,-48(fp)
81139d10:	e0bff915 	stw	r2,-28(fp)
81139d14:	e0bff917 	ldw	r2,-28(fp)
81139d18:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NO_MORE_TCB);
81139d1c:	00801084 	movi	r2,66
}
81139d20:	e037883a 	mov	sp,fp
81139d24:	dfc00117 	ldw	ra,4(sp)
81139d28:	df000017 	ldw	fp,0(sp)
81139d2c:	dec00204 	addi	sp,sp,8
81139d30:	f800283a 	ret

81139d34 <OSDebugInit>:
*********************************************************************************************************
*/

#if OS_DEBUG_EN > 0
void  OSDebugInit (void)
{
81139d34:	defffe04 	addi	sp,sp,-8
81139d38:	de00012e 	bgeu	sp,et,81139d40 <OSDebugInit+0xc>
81139d3c:	003b68fa 	trap	3
81139d40:	df000115 	stw	fp,4(sp)
81139d44:	df000104 	addi	fp,sp,4
    void  *ptemp;

    
    ptemp = (void *)&OSDebugEn;
81139d48:	d0a01804 	addi	r2,gp,-32672
81139d4c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEndiannessTest;
81139d50:	d0a01904 	addi	r2,gp,-32668
81139d54:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEventMax;
81139d58:	d0a01a84 	addi	r2,gp,-32662
81139d5c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventNameSize;
81139d60:	d0a01b04 	addi	r2,gp,-32660
81139d64:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventEn;
81139d68:	d0a01a04 	addi	r2,gp,-32664
81139d6c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventSize;
81139d70:	d0a01b84 	addi	r2,gp,-32658
81139d74:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventTblSize;
81139d78:	d0a01c04 	addi	r2,gp,-32656
81139d7c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventMultiEn;
81139d80:	d0a01c84 	addi	r2,gp,-32654
81139d84:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSFlagEn;
81139d88:	d0a01d04 	addi	r2,gp,-32652
81139d8c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagGrpSize;
81139d90:	d0a01d84 	addi	r2,gp,-32650
81139d94:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNodeSize;
81139d98:	d0a01e04 	addi	r2,gp,-32648
81139d9c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagWidth;
81139da0:	d0a01e84 	addi	r2,gp,-32646
81139da4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagMax;
81139da8:	d0a01f04 	addi	r2,gp,-32644
81139dac:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNameSize;
81139db0:	d0a01f84 	addi	r2,gp,-32642
81139db4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSLowestPrio;
81139db8:	d0a02004 	addi	r2,gp,-32640
81139dbc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMboxEn;
81139dc0:	d0a02084 	addi	r2,gp,-32638
81139dc4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMemEn;
81139dc8:	d0a02104 	addi	r2,gp,-32636
81139dcc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemMax;
81139dd0:	d0a02184 	addi	r2,gp,-32634
81139dd4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemNameSize;
81139dd8:	d0a02204 	addi	r2,gp,-32632
81139ddc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemSize;
81139de0:	d0a02284 	addi	r2,gp,-32630
81139de4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemTblSize;
81139de8:	d0a02304 	addi	r2,gp,-32628
81139dec:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMutexEn;
81139df0:	d0a02384 	addi	r2,gp,-32626
81139df4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSPtrSize;
81139df8:	d0a02404 	addi	r2,gp,-32624
81139dfc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSQEn;
81139e00:	d0a02484 	addi	r2,gp,-32622
81139e04:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQMax;
81139e08:	d0a02504 	addi	r2,gp,-32620
81139e0c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQSize;
81139e10:	d0a02584 	addi	r2,gp,-32618
81139e14:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSRdyTblSize;
81139e18:	d0a02604 	addi	r2,gp,-32616
81139e1c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSSemEn;
81139e20:	d0a02684 	addi	r2,gp,-32614
81139e24:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSStkWidth;
81139e28:	d0a02704 	addi	r2,gp,-32612
81139e2c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTaskCreateEn;
81139e30:	d0a02784 	addi	r2,gp,-32610
81139e34:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskCreateExtEn;
81139e38:	d0a02804 	addi	r2,gp,-32608
81139e3c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskDelEn;
81139e40:	d0a02884 	addi	r2,gp,-32606
81139e44:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskIdleStkSize;
81139e48:	d0a02904 	addi	r2,gp,-32604
81139e4c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskProfileEn;
81139e50:	d0a02984 	addi	r2,gp,-32602
81139e54:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskMax;
81139e58:	d0a02a04 	addi	r2,gp,-32600
81139e5c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskNameSize;
81139e60:	d0a02a84 	addi	r2,gp,-32598
81139e64:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatEn;
81139e68:	d0a02b04 	addi	r2,gp,-32596
81139e6c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkSize;
81139e70:	d0a02b84 	addi	r2,gp,-32594
81139e74:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkChkEn;
81139e78:	d0a02c04 	addi	r2,gp,-32592
81139e7c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskSwHookEn;
81139e80:	d0a02c84 	addi	r2,gp,-32590
81139e84:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTCBPrioTblMax;
81139e88:	d0a02d04 	addi	r2,gp,-32588
81139e8c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTCBSize;
81139e90:	d0a02d84 	addi	r2,gp,-32586
81139e94:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTicksPerSec;
81139e98:	d0a02e04 	addi	r2,gp,-32584
81139e9c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTimeTickHookEn;
81139ea0:	d0a02e84 	addi	r2,gp,-32582
81139ea4:	e0bfff15 	stw	r2,-4(fp)

#if OS_TMR_EN > 0
    ptemp = (void *)&OSTmrTbl[0];
81139ea8:	00a045b4 	movhi	r2,33046
81139eac:	109bfc04 	addi	r2,r2,28656
81139eb0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrWheelTbl[0];
81139eb4:	00a045b4 	movhi	r2,33046
81139eb8:	1099e804 	addi	r2,r2,26528
81139ebc:	e0bfff15 	stw	r2,-4(fp)
    
    ptemp = (void *)&OSTmrEn;
81139ec0:	d0a02f84 	addi	r2,gp,-32578
81139ec4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgMax;
81139ec8:	d0a03004 	addi	r2,gp,-32576
81139ecc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgNameSize;
81139ed0:	d0a03084 	addi	r2,gp,-32574
81139ed4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgWheelSize;
81139ed8:	d0a03104 	addi	r2,gp,-32572
81139edc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgTicksPerSec;
81139ee0:	d0a03184 	addi	r2,gp,-32570
81139ee4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrSize;
81139ee8:	d0a03204 	addi	r2,gp,-32568
81139eec:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrTblSize;
81139ef0:	d0a03284 	addi	r2,gp,-32566
81139ef4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTmrWheelSize;
81139ef8:	d0a03304 	addi	r2,gp,-32564
81139efc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrWheelTblSize;
81139f00:	d0a03384 	addi	r2,gp,-32562
81139f04:	e0bfff15 	stw	r2,-4(fp)
#endif

    ptemp = (void *)&OSVersionNbr;
81139f08:	d0a02f04 	addi	r2,gp,-32580
81139f0c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSDataSize;
81139f10:	d0a03404 	addi	r2,gp,-32560
81139f14:	e0bfff15 	stw	r2,-4(fp)

    ptemp = ptemp;                             /* Prevent compiler warning for 'ptemp' not being used! */
}
81139f18:	0001883a 	nop
81139f1c:	e037883a 	mov	sp,fp
81139f20:	df000017 	ldw	fp,0(sp)
81139f24:	dec00104 	addi	sp,sp,4
81139f28:	f800283a 	ret

81139f2c <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)
{
81139f2c:	defff204 	addi	sp,sp,-56
81139f30:	de00012e 	bgeu	sp,et,81139f38 <OSFlagAccept+0xc>
81139f34:	003b68fa 	trap	3
81139f38:	df000d15 	stw	fp,52(sp)
81139f3c:	df000d04 	addi	fp,sp,52
81139f40:	e13ffc15 	stw	r4,-16(fp)
81139f44:	2807883a 	mov	r3,r5
81139f48:	3005883a 	mov	r2,r6
81139f4c:	e1ffff15 	stw	r7,-4(fp)
81139f50:	e0fffd0d 	sth	r3,-12(fp)
81139f54:	e0bffe05 	stb	r2,-8(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
81139f58:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81139f5c:	e0bfff17 	ldw	r2,-4(fp)
81139f60:	1000021e 	bne	r2,zero,81139f6c <OSFlagAccept+0x40>
        return ((OS_FLAGS)0);
81139f64:	0005883a 	mov	r2,zero
81139f68:	0000b006 	br	8113a22c <OSFlagAccept+0x300>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
81139f6c:	e0bffc17 	ldw	r2,-16(fp)
81139f70:	1000051e 	bne	r2,zero,81139f88 <OSFlagAccept+0x5c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
81139f74:	e0bfff17 	ldw	r2,-4(fp)
81139f78:	00c01b84 	movi	r3,110
81139f7c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81139f80:	0005883a 	mov	r2,zero
81139f84:	0000a906 	br	8113a22c <OSFlagAccept+0x300>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
81139f88:	e0bffc17 	ldw	r2,-16(fp)
81139f8c:	10800003 	ldbu	r2,0(r2)
81139f90:	10803fcc 	andi	r2,r2,255
81139f94:	10800160 	cmpeqi	r2,r2,5
81139f98:	1000051e 	bne	r2,zero,81139fb0 <OSFlagAccept+0x84>
        *perr = OS_ERR_EVENT_TYPE;
81139f9c:	e0bfff17 	ldw	r2,-4(fp)
81139fa0:	00c00044 	movi	r3,1
81139fa4:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81139fa8:	0005883a 	mov	r2,zero
81139fac:	00009f06 	br	8113a22c <OSFlagAccept+0x300>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
81139fb0:	e0fffe03 	ldbu	r3,-8(fp)
81139fb4:	00bfe004 	movi	r2,-128
81139fb8:	1884703a 	and	r2,r3,r2
81139fbc:	e0bff505 	stb	r2,-44(fp)
    if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
81139fc0:	e0bff503 	ldbu	r2,-44(fp)
81139fc4:	10000626 	beq	r2,zero,81139fe0 <OSFlagAccept+0xb4>
        wait_type &= ~OS_FLAG_CONSUME;
81139fc8:	e0bffe03 	ldbu	r2,-8(fp)
81139fcc:	10801fcc 	andi	r2,r2,127
81139fd0:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
81139fd4:	00800044 	movi	r2,1
81139fd8:	e0bff385 	stb	r2,-50(fp)
81139fdc:	00000106 	br	81139fe4 <OSFlagAccept+0xb8>
    } else {
        consume    = OS_FALSE;
81139fe0:	e03ff385 	stb	zero,-50(fp)
    }
/*$PAGE*/
    *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
81139fe4:	e0bfff17 	ldw	r2,-4(fp)
81139fe8:	10000005 	stb	zero,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139fec:	0005303a 	rdctl	r2,status
81139ff0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139ff4:	e0fffb17 	ldw	r3,-20(fp)
81139ff8:	00bfff84 	movi	r2,-2
81139ffc:	1884703a 	and	r2,r3,r2
8113a000:	1001703a 	wrctl	status,r2
  
  return context;
8113a004:	e0bffb17 	ldw	r2,-20(fp)
    OS_ENTER_CRITICAL();
8113a008:	e0bff415 	stw	r2,-48(fp)
    switch (wait_type) {
8113a00c:	e0bffe03 	ldbu	r2,-8(fp)
8113a010:	10c00060 	cmpeqi	r3,r2,1
8113a014:	18005f1e 	bne	r3,zero,8113a194 <OSFlagAccept+0x268>
8113a018:	10c00088 	cmpgei	r3,r2,2
8113a01c:	1800021e 	bne	r3,zero,8113a028 <OSFlagAccept+0xfc>
8113a020:	10003f26 	beq	r2,zero,8113a120 <OSFlagAccept+0x1f4>
8113a024:	00007706 	br	8113a204 <OSFlagAccept+0x2d8>
8113a028:	10c000a0 	cmpeqi	r3,r2,2
8113a02c:	1800031e 	bne	r3,zero,8113a03c <OSFlagAccept+0x110>
8113a030:	108000e0 	cmpeqi	r2,r2,3
8113a034:	10001e1e 	bne	r2,zero,8113a0b0 <OSFlagAccept+0x184>
8113a038:	00007206 	br	8113a204 <OSFlagAccept+0x2d8>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
8113a03c:	e0bffc17 	ldw	r2,-16(fp)
8113a040:	10c0020b 	ldhu	r3,8(r2)
8113a044:	e0bffd0b 	ldhu	r2,-12(fp)
8113a048:	1884703a 	and	r2,r3,r2
8113a04c:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
8113a050:	e0fff30b 	ldhu	r3,-52(fp)
8113a054:	e0bffd0b 	ldhu	r2,-12(fp)
8113a058:	18800d1e 	bne	r3,r2,8113a090 <OSFlagAccept+0x164>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113a05c:	e0bff383 	ldbu	r2,-50(fp)
8113a060:	10800058 	cmpnei	r2,r2,1
8113a064:	10000d1e 	bne	r2,zero,8113a09c <OSFlagAccept+0x170>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
8113a068:	e0bffc17 	ldw	r2,-16(fp)
8113a06c:	1080020b 	ldhu	r2,8(r2)
8113a070:	1007883a 	mov	r3,r2
8113a074:	e0bff30b 	ldhu	r2,-52(fp)
8113a078:	0084303a 	nor	r2,zero,r2
8113a07c:	1884703a 	and	r2,r3,r2
8113a080:	1007883a 	mov	r3,r2
8113a084:	e0bffc17 	ldw	r2,-16(fp)
8113a088:	10c0020d 	sth	r3,8(r2)
8113a08c:	00000306 	br	8113a09c <OSFlagAccept+0x170>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8113a090:	e0bfff17 	ldw	r2,-4(fp)
8113a094:	00c01c04 	movi	r3,112
8113a098:	10c00005 	stb	r3,0(r2)
8113a09c:	e0bff417 	ldw	r2,-48(fp)
8113a0a0:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a0a4:	e0bff617 	ldw	r2,-40(fp)
8113a0a8:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
8113a0ac:	00005e06 	br	8113a228 <OSFlagAccept+0x2fc>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
8113a0b0:	e0bffc17 	ldw	r2,-16(fp)
8113a0b4:	10c0020b 	ldhu	r3,8(r2)
8113a0b8:	e0bffd0b 	ldhu	r2,-12(fp)
8113a0bc:	1884703a 	and	r2,r3,r2
8113a0c0:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
8113a0c4:	e0bff30b 	ldhu	r2,-52(fp)
8113a0c8:	10000d26 	beq	r2,zero,8113a100 <OSFlagAccept+0x1d4>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113a0cc:	e0bff383 	ldbu	r2,-50(fp)
8113a0d0:	10800058 	cmpnei	r2,r2,1
8113a0d4:	10000d1e 	bne	r2,zero,8113a10c <OSFlagAccept+0x1e0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
8113a0d8:	e0bffc17 	ldw	r2,-16(fp)
8113a0dc:	1080020b 	ldhu	r2,8(r2)
8113a0e0:	1007883a 	mov	r3,r2
8113a0e4:	e0bff30b 	ldhu	r2,-52(fp)
8113a0e8:	0084303a 	nor	r2,zero,r2
8113a0ec:	1884703a 	and	r2,r3,r2
8113a0f0:	1007883a 	mov	r3,r2
8113a0f4:	e0bffc17 	ldw	r2,-16(fp)
8113a0f8:	10c0020d 	sth	r3,8(r2)
8113a0fc:	00000306 	br	8113a10c <OSFlagAccept+0x1e0>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8113a100:	e0bfff17 	ldw	r2,-4(fp)
8113a104:	00c01c04 	movi	r3,112
8113a108:	10c00005 	stb	r3,0(r2)
8113a10c:	e0bff417 	ldw	r2,-48(fp)
8113a110:	e0bff715 	stw	r2,-36(fp)
8113a114:	e0bff717 	ldw	r2,-36(fp)
8113a118:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
8113a11c:	00004206 	br	8113a228 <OSFlagAccept+0x2fc>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
8113a120:	e0bffc17 	ldw	r2,-16(fp)
8113a124:	1080020b 	ldhu	r2,8(r2)
8113a128:	0084303a 	nor	r2,zero,r2
8113a12c:	1007883a 	mov	r3,r2
8113a130:	e0bffd0b 	ldhu	r2,-12(fp)
8113a134:	1884703a 	and	r2,r3,r2
8113a138:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
8113a13c:	e0fff30b 	ldhu	r3,-52(fp)
8113a140:	e0bffd0b 	ldhu	r2,-12(fp)
8113a144:	18800b1e 	bne	r3,r2,8113a174 <OSFlagAccept+0x248>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113a148:	e0bff383 	ldbu	r2,-50(fp)
8113a14c:	10800058 	cmpnei	r2,r2,1
8113a150:	10000b1e 	bne	r2,zero,8113a180 <OSFlagAccept+0x254>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
8113a154:	e0bffc17 	ldw	r2,-16(fp)
8113a158:	10c0020b 	ldhu	r3,8(r2)
8113a15c:	e0bff30b 	ldhu	r2,-52(fp)
8113a160:	1884b03a 	or	r2,r3,r2
8113a164:	1007883a 	mov	r3,r2
8113a168:	e0bffc17 	ldw	r2,-16(fp)
8113a16c:	10c0020d 	sth	r3,8(r2)
8113a170:	00000306 	br	8113a180 <OSFlagAccept+0x254>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8113a174:	e0bfff17 	ldw	r2,-4(fp)
8113a178:	00c01c04 	movi	r3,112
8113a17c:	10c00005 	stb	r3,0(r2)
8113a180:	e0bff417 	ldw	r2,-48(fp)
8113a184:	e0bff815 	stw	r2,-32(fp)
8113a188:	e0bff817 	ldw	r2,-32(fp)
8113a18c:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
8113a190:	00002506 	br	8113a228 <OSFlagAccept+0x2fc>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
8113a194:	e0bffc17 	ldw	r2,-16(fp)
8113a198:	1080020b 	ldhu	r2,8(r2)
8113a19c:	0084303a 	nor	r2,zero,r2
8113a1a0:	1007883a 	mov	r3,r2
8113a1a4:	e0bffd0b 	ldhu	r2,-12(fp)
8113a1a8:	1884703a 	and	r2,r3,r2
8113a1ac:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
8113a1b0:	e0bff30b 	ldhu	r2,-52(fp)
8113a1b4:	10000b26 	beq	r2,zero,8113a1e4 <OSFlagAccept+0x2b8>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113a1b8:	e0bff383 	ldbu	r2,-50(fp)
8113a1bc:	10800058 	cmpnei	r2,r2,1
8113a1c0:	10000b1e 	bne	r2,zero,8113a1f0 <OSFlagAccept+0x2c4>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
8113a1c4:	e0bffc17 	ldw	r2,-16(fp)
8113a1c8:	10c0020b 	ldhu	r3,8(r2)
8113a1cc:	e0bff30b 	ldhu	r2,-52(fp)
8113a1d0:	1884b03a 	or	r2,r3,r2
8113a1d4:	1007883a 	mov	r3,r2
8113a1d8:	e0bffc17 	ldw	r2,-16(fp)
8113a1dc:	10c0020d 	sth	r3,8(r2)
8113a1e0:	00000306 	br	8113a1f0 <OSFlagAccept+0x2c4>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8113a1e4:	e0bfff17 	ldw	r2,-4(fp)
8113a1e8:	00c01c04 	movi	r3,112
8113a1ec:	10c00005 	stb	r3,0(r2)
8113a1f0:	e0bff417 	ldw	r2,-48(fp)
8113a1f4:	e0bff915 	stw	r2,-28(fp)
8113a1f8:	e0bff917 	ldw	r2,-28(fp)
8113a1fc:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
8113a200:	00000906 	br	8113a228 <OSFlagAccept+0x2fc>
8113a204:	e0bff417 	ldw	r2,-48(fp)
8113a208:	e0bffa15 	stw	r2,-24(fp)
8113a20c:	e0bffa17 	ldw	r2,-24(fp)
8113a210:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
8113a214:	e03ff30d 	sth	zero,-52(fp)
             *perr     = OS_ERR_FLAG_WAIT_TYPE;
8113a218:	e0bfff17 	ldw	r2,-4(fp)
8113a21c:	00c01bc4 	movi	r3,111
8113a220:	10c00005 	stb	r3,0(r2)
             break;
8113a224:	0001883a 	nop
    }
    return (flags_rdy);
8113a228:	e0bff30b 	ldhu	r2,-52(fp)
}
8113a22c:	e037883a 	mov	sp,fp
8113a230:	df000017 	ldw	fp,0(sp)
8113a234:	dec00104 	addi	sp,sp,4
8113a238:	f800283a 	ret

8113a23c <OSFlagCreate>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *perr)
{
8113a23c:	defff804 	addi	sp,sp,-32
8113a240:	de00012e 	bgeu	sp,et,8113a248 <OSFlagCreate+0xc>
8113a244:	003b68fa 	trap	3
8113a248:	df000715 	stw	fp,28(sp)
8113a24c:	df000704 	addi	fp,sp,28
8113a250:	2005883a 	mov	r2,r4
8113a254:	e17fff15 	stw	r5,-4(fp)
8113a258:	e0bffe0d 	sth	r2,-8(fp)
    OS_FLAG_GRP *pgrp;
#if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
    OS_CPU_SR    cpu_sr = 0;
8113a25c:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
8113a260:	e0bfff17 	ldw	r2,-4(fp)
8113a264:	1000021e 	bne	r2,zero,8113a270 <OSFlagCreate+0x34>
        return ((OS_FLAG_GRP *)0);
8113a268:	0005883a 	mov	r2,zero
8113a26c:	00003306 	br	8113a33c <OSFlagCreate+0x100>
    }
#endif
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
8113a270:	d0a0a103 	ldbu	r2,-32124(gp)
8113a274:	10803fcc 	andi	r2,r2,255
8113a278:	10000526 	beq	r2,zero,8113a290 <OSFlagCreate+0x54>
        *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
8113a27c:	e0bfff17 	ldw	r2,-4(fp)
8113a280:	00c00404 	movi	r3,16
8113a284:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAG_GRP *)0);
8113a288:	0005883a 	mov	r2,zero
8113a28c:	00002b06 	br	8113a33c <OSFlagCreate+0x100>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a290:	0005303a 	rdctl	r2,status
8113a294:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a298:	e0fffd17 	ldw	r3,-12(fp)
8113a29c:	00bfff84 	movi	r2,-2
8113a2a0:	1884703a 	and	r2,r3,r2
8113a2a4:	1001703a 	wrctl	status,r2
  
  return context;
8113a2a8:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113a2ac:	e0bff915 	stw	r2,-28(fp)
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
8113a2b0:	d0a0a617 	ldw	r2,-32104(gp)
8113a2b4:	e0bffb15 	stw	r2,-20(fp)
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
8113a2b8:	e0bffb17 	ldw	r2,-20(fp)
8113a2bc:	10001726 	beq	r2,zero,8113a31c <OSFlagCreate+0xe0>
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
8113a2c0:	d0a0a617 	ldw	r2,-32104(gp)
8113a2c4:	10800117 	ldw	r2,4(r2)
8113a2c8:	d0a0a615 	stw	r2,-32104(gp)
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
8113a2cc:	e0bffb17 	ldw	r2,-20(fp)
8113a2d0:	00c00144 	movi	r3,5
8113a2d4:	10c00005 	stb	r3,0(r2)
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
8113a2d8:	e0bffb17 	ldw	r2,-20(fp)
8113a2dc:	e0fffe0b 	ldhu	r3,-8(fp)
8113a2e0:	10c0020d 	sth	r3,8(r2)
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
8113a2e4:	e0bffb17 	ldw	r2,-20(fp)
8113a2e8:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
8113a2ec:	e0bffb17 	ldw	r2,-20(fp)
8113a2f0:	00c00fc4 	movi	r3,63
8113a2f4:	10c00285 	stb	r3,10(r2)
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
8113a2f8:	e0bffb17 	ldw	r2,-20(fp)
8113a2fc:	100002c5 	stb	zero,11(r2)
8113a300:	e0bff917 	ldw	r2,-28(fp)
8113a304:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a308:	e0bffa17 	ldw	r2,-24(fp)
8113a30c:	1001703a 	wrctl	status,r2
#endif
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_NONE;
8113a310:	e0bfff17 	ldw	r2,-4(fp)
8113a314:	10000005 	stb	zero,0(r2)
8113a318:	00000706 	br	8113a338 <OSFlagCreate+0xfc>
8113a31c:	e0bff917 	ldw	r2,-28(fp)
8113a320:	e0bffc15 	stw	r2,-16(fp)
8113a324:	e0bffc17 	ldw	r2,-16(fp)
8113a328:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_FLAG_GRP_DEPLETED;
8113a32c:	e0bfff17 	ldw	r2,-4(fp)
8113a330:	00c01c84 	movi	r3,114
8113a334:	10c00005 	stb	r3,0(r2)
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
8113a338:	e0bffb17 	ldw	r2,-20(fp)
}
8113a33c:	e037883a 	mov	sp,fp
8113a340:	df000017 	ldw	fp,0(sp)
8113a344:	dec00104 	addi	sp,sp,4
8113a348:	f800283a 	ret

8113a34c <OSFlagDel>:
*********************************************************************************************************
*/

#if OS_FLAG_DEL_EN > 0
OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *perr)
{
8113a34c:	defff204 	addi	sp,sp,-56
8113a350:	de00012e 	bgeu	sp,et,8113a358 <OSFlagDel+0xc>
8113a354:	003b68fa 	trap	3
8113a358:	dfc00d15 	stw	ra,52(sp)
8113a35c:	df000c15 	stw	fp,48(sp)
8113a360:	df000c04 	addi	fp,sp,48
8113a364:	e13ffd15 	stw	r4,-12(fp)
8113a368:	2805883a 	mov	r2,r5
8113a36c:	e1bfff15 	stw	r6,-4(fp)
8113a370:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       tasks_waiting;
    OS_FLAG_NODE *pnode;
    OS_FLAG_GRP  *pgrp_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8113a374:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113a378:	e0bfff17 	ldw	r2,-4(fp)
8113a37c:	1000021e 	bne	r2,zero,8113a388 <OSFlagDel+0x3c>
        return (pgrp);
8113a380:	e0bffd17 	ldw	r2,-12(fp)
8113a384:	00008006 	br	8113a588 <OSFlagDel+0x23c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
8113a388:	e0bffd17 	ldw	r2,-12(fp)
8113a38c:	1000051e 	bne	r2,zero,8113a3a4 <OSFlagDel+0x58>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113a390:	e0bfff17 	ldw	r2,-4(fp)
8113a394:	00c01b84 	movi	r3,110
8113a398:	10c00005 	stb	r3,0(r2)
        return (pgrp);
8113a39c:	e0bffd17 	ldw	r2,-12(fp)
8113a3a0:	00007906 	br	8113a588 <OSFlagDel+0x23c>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113a3a4:	d0a0a103 	ldbu	r2,-32124(gp)
8113a3a8:	10803fcc 	andi	r2,r2,255
8113a3ac:	10000526 	beq	r2,zero,8113a3c4 <OSFlagDel+0x78>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
8113a3b0:	e0bfff17 	ldw	r2,-4(fp)
8113a3b4:	00c003c4 	movi	r3,15
8113a3b8:	10c00005 	stb	r3,0(r2)
        return (pgrp);
8113a3bc:	e0bffd17 	ldw	r2,-12(fp)
8113a3c0:	00007106 	br	8113a588 <OSFlagDel+0x23c>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
8113a3c4:	e0bffd17 	ldw	r2,-12(fp)
8113a3c8:	10800003 	ldbu	r2,0(r2)
8113a3cc:	10803fcc 	andi	r2,r2,255
8113a3d0:	10800160 	cmpeqi	r2,r2,5
8113a3d4:	1000051e 	bne	r2,zero,8113a3ec <OSFlagDel+0xa0>
        *perr = OS_ERR_EVENT_TYPE;
8113a3d8:	e0bfff17 	ldw	r2,-4(fp)
8113a3dc:	00c00044 	movi	r3,1
8113a3e0:	10c00005 	stb	r3,0(r2)
        return (pgrp);
8113a3e4:	e0bffd17 	ldw	r2,-12(fp)
8113a3e8:	00006706 	br	8113a588 <OSFlagDel+0x23c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a3ec:	0005303a 	rdctl	r2,status
8113a3f0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a3f4:	e0fffc17 	ldw	r3,-16(fp)
8113a3f8:	00bfff84 	movi	r2,-2
8113a3fc:	1884703a 	and	r2,r3,r2
8113a400:	1001703a 	wrctl	status,r2
  
  return context;
8113a404:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113a408:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
8113a40c:	e0bffd17 	ldw	r2,-12(fp)
8113a410:	10800117 	ldw	r2,4(r2)
8113a414:	10000326 	beq	r2,zero,8113a424 <OSFlagDel+0xd8>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8113a418:	00800044 	movi	r2,1
8113a41c:	e0bff405 	stb	r2,-48(fp)
8113a420:	00000106 	br	8113a428 <OSFlagDel+0xdc>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8113a424:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
8113a428:	e0bffe03 	ldbu	r2,-8(fp)
8113a42c:	10000326 	beq	r2,zero,8113a43c <OSFlagDel+0xf0>
8113a430:	10800060 	cmpeqi	r2,r2,1
8113a434:	1000231e 	bne	r2,zero,8113a4c4 <OSFlagDel+0x178>
8113a438:	00004806 	br	8113a55c <OSFlagDel+0x210>
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == OS_FALSE) {
8113a43c:	e0bff403 	ldbu	r2,-48(fp)
8113a440:	1000161e 	bne	r2,zero,8113a49c <OSFlagDel+0x150>
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
8113a444:	e0bffd17 	ldw	r2,-12(fp)
8113a448:	00c00fc4 	movi	r3,63
8113a44c:	10c00285 	stb	r3,10(r2)
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
8113a450:	e0bffd17 	ldw	r2,-12(fp)
8113a454:	100002c5 	stb	zero,11(r2)
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
8113a458:	e0bffd17 	ldw	r2,-12(fp)
8113a45c:	10000005 	stb	zero,0(r2)
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
8113a460:	d0e0a617 	ldw	r3,-32104(gp)
8113a464:	e0bffd17 	ldw	r2,-12(fp)
8113a468:	10c00115 	stw	r3,4(r2)
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
8113a46c:	e0bffd17 	ldw	r2,-12(fp)
8113a470:	1000020d 	sth	zero,8(r2)
                 OSFlagFreeList       = pgrp;
8113a474:	e0bffd17 	ldw	r2,-12(fp)
8113a478:	d0a0a615 	stw	r2,-32104(gp)
8113a47c:	e0bff717 	ldw	r2,-36(fp)
8113a480:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a484:	e0bff817 	ldw	r2,-32(fp)
8113a488:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
8113a48c:	e0bfff17 	ldw	r2,-4(fp)
8113a490:	10000005 	stb	zero,0(r2)
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
8113a494:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
                 pgrp_return          = pgrp;
             }
             break;
8113a498:	00003a06 	br	8113a584 <OSFlagDel+0x238>
8113a49c:	e0bff717 	ldw	r2,-36(fp)
8113a4a0:	e0bff915 	stw	r2,-28(fp)
8113a4a4:	e0bff917 	ldw	r2,-28(fp)
8113a4a8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
8113a4ac:	e0bfff17 	ldw	r2,-4(fp)
8113a4b0:	00c01244 	movi	r3,73
8113a4b4:	10c00005 	stb	r3,0(r2)
                 pgrp_return          = pgrp;
8113a4b8:	e0bffd17 	ldw	r2,-12(fp)
8113a4bc:	e0bff615 	stw	r2,-40(fp)
             }
             break;
8113a4c0:	00003006 	br	8113a584 <OSFlagDel+0x238>

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
8113a4c4:	e0bffd17 	ldw	r2,-12(fp)
8113a4c8:	10800117 	ldw	r2,4(r2)
8113a4cc:	e0bff515 	stw	r2,-44(fp)
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
8113a4d0:	00000606 	br	8113a4ec <OSFlagDel+0x1a0>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
8113a4d4:	000b883a 	mov	r5,zero
8113a4d8:	e13ff517 	ldw	r4,-44(fp)
8113a4dc:	113b5000 	call	8113b500 <OS_FlagTaskRdy>
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
8113a4e0:	e0bff517 	ldw	r2,-44(fp)
8113a4e4:	10800017 	ldw	r2,0(r2)
8113a4e8:	e0bff515 	stw	r2,-44(fp)
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
8113a4ec:	e0bff517 	ldw	r2,-44(fp)
8113a4f0:	103ff81e 	bne	r2,zero,8113a4d4 <__reset+0xfb11a4d4>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
8113a4f4:	e0bffd17 	ldw	r2,-12(fp)
8113a4f8:	00c00fc4 	movi	r3,63
8113a4fc:	10c00285 	stb	r3,10(r2)
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
8113a500:	e0bffd17 	ldw	r2,-12(fp)
8113a504:	100002c5 	stb	zero,11(r2)
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
8113a508:	e0bffd17 	ldw	r2,-12(fp)
8113a50c:	10000005 	stb	zero,0(r2)
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
8113a510:	d0e0a617 	ldw	r3,-32104(gp)
8113a514:	e0bffd17 	ldw	r2,-12(fp)
8113a518:	10c00115 	stw	r3,4(r2)
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
8113a51c:	e0bffd17 	ldw	r2,-12(fp)
8113a520:	1000020d 	sth	zero,8(r2)
             OSFlagFreeList       = pgrp;
8113a524:	e0bffd17 	ldw	r2,-12(fp)
8113a528:	d0a0a615 	stw	r2,-32104(gp)
8113a52c:	e0bff717 	ldw	r2,-36(fp)
8113a530:	e0bffa15 	stw	r2,-24(fp)
8113a534:	e0bffa17 	ldw	r2,-24(fp)
8113a538:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8113a53c:	e0bff403 	ldbu	r2,-48(fp)
8113a540:	10800058 	cmpnei	r2,r2,1
8113a544:	1000011e 	bne	r2,zero,8113a54c <OSFlagDel+0x200>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8113a548:	11396100 	call	81139610 <OS_Sched>
             }
             *perr = OS_ERR_NONE;
8113a54c:	e0bfff17 	ldw	r2,-4(fp)
8113a550:	10000005 	stb	zero,0(r2)
             pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
8113a554:	e03ff615 	stw	zero,-40(fp)
             break;
8113a558:	00000a06 	br	8113a584 <OSFlagDel+0x238>
8113a55c:	e0bff717 	ldw	r2,-36(fp)
8113a560:	e0bffb15 	stw	r2,-20(fp)
8113a564:	e0bffb17 	ldw	r2,-20(fp)
8113a568:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                = OS_ERR_INVALID_OPT;
8113a56c:	e0bfff17 	ldw	r2,-4(fp)
8113a570:	00c001c4 	movi	r3,7
8113a574:	10c00005 	stb	r3,0(r2)
             pgrp_return          = pgrp;
8113a578:	e0bffd17 	ldw	r2,-12(fp)
8113a57c:	e0bff615 	stw	r2,-40(fp)
             break;
8113a580:	0001883a 	nop
    }
    return (pgrp_return);
8113a584:	e0bff617 	ldw	r2,-40(fp)
}
8113a588:	e037883a 	mov	sp,fp
8113a58c:	dfc00117 	ldw	ra,4(sp)
8113a590:	df000017 	ldw	fp,0(sp)
8113a594:	dec00204 	addi	sp,sp,8
8113a598:	f800283a 	ret

8113a59c <OSFlagNameGet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
8113a59c:	defff604 	addi	sp,sp,-40
8113a5a0:	de00012e 	bgeu	sp,et,8113a5a8 <OSFlagNameGet+0xc>
8113a5a4:	003b68fa 	trap	3
8113a5a8:	dfc00915 	stw	ra,36(sp)
8113a5ac:	df000815 	stw	fp,32(sp)
8113a5b0:	df000804 	addi	fp,sp,32
8113a5b4:	e13ffd15 	stw	r4,-12(fp)
8113a5b8:	e17ffe15 	stw	r5,-8(fp)
8113a5bc:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113a5c0:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113a5c4:	e0bfff17 	ldw	r2,-4(fp)
8113a5c8:	1000021e 	bne	r2,zero,8113a5d4 <OSFlagNameGet+0x38>
        return (0);
8113a5cc:	0005883a 	mov	r2,zero
8113a5d0:	00003906 	br	8113a6b8 <OSFlagNameGet+0x11c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
8113a5d4:	e0bffd17 	ldw	r2,-12(fp)
8113a5d8:	1000051e 	bne	r2,zero,8113a5f0 <OSFlagNameGet+0x54>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113a5dc:	e0bfff17 	ldw	r2,-4(fp)
8113a5e0:	00c01b84 	movi	r3,110
8113a5e4:	10c00005 	stb	r3,0(r2)
        return (0);
8113a5e8:	0005883a 	mov	r2,zero
8113a5ec:	00003206 	br	8113a6b8 <OSFlagNameGet+0x11c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8113a5f0:	e0bffe17 	ldw	r2,-8(fp)
8113a5f4:	1000051e 	bne	r2,zero,8113a60c <OSFlagNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
8113a5f8:	e0bfff17 	ldw	r2,-4(fp)
8113a5fc:	00c00304 	movi	r3,12
8113a600:	10c00005 	stb	r3,0(r2)
        return (0);
8113a604:	0005883a 	mov	r2,zero
8113a608:	00002b06 	br	8113a6b8 <OSFlagNameGet+0x11c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113a60c:	d0a0a103 	ldbu	r2,-32124(gp)
8113a610:	10803fcc 	andi	r2,r2,255
8113a614:	10000526 	beq	r2,zero,8113a62c <OSFlagNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
8113a618:	e0bfff17 	ldw	r2,-4(fp)
8113a61c:	00c00444 	movi	r3,17
8113a620:	10c00005 	stb	r3,0(r2)
        return (0);
8113a624:	0005883a 	mov	r2,zero
8113a628:	00002306 	br	8113a6b8 <OSFlagNameGet+0x11c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a62c:	0005303a 	rdctl	r2,status
8113a630:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a634:	e0fffc17 	ldw	r3,-16(fp)
8113a638:	00bfff84 	movi	r2,-2
8113a63c:	1884703a 	and	r2,r3,r2
8113a640:	1001703a 	wrctl	status,r2
  
  return context;
8113a644:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113a648:	e0bff815 	stw	r2,-32(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
8113a64c:	e0bffd17 	ldw	r2,-12(fp)
8113a650:	10800003 	ldbu	r2,0(r2)
8113a654:	10803fcc 	andi	r2,r2,255
8113a658:	10800160 	cmpeqi	r2,r2,5
8113a65c:	1000091e 	bne	r2,zero,8113a684 <OSFlagNameGet+0xe8>
8113a660:	e0bff817 	ldw	r2,-32(fp)
8113a664:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a668:	e0bff917 	ldw	r2,-28(fp)
8113a66c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
8113a670:	e0bfff17 	ldw	r2,-4(fp)
8113a674:	00c00044 	movi	r3,1
8113a678:	10c00005 	stb	r3,0(r2)
        return (0);
8113a67c:	0005883a 	mov	r2,zero
8113a680:	00000d06 	br	8113a6b8 <OSFlagNameGet+0x11c>
    }
    len   = OS_StrCopy(pname, pgrp->OSFlagName); /* Copy name from OS_FLAG_GRP                         */
8113a684:	e0bffd17 	ldw	r2,-12(fp)
8113a688:	10800284 	addi	r2,r2,10
8113a68c:	100b883a 	mov	r5,r2
8113a690:	e13ffe17 	ldw	r4,-8(fp)
8113a694:	11397640 	call	81139764 <OS_StrCopy>
8113a698:	e0bffb05 	stb	r2,-20(fp)
8113a69c:	e0bff817 	ldw	r2,-32(fp)
8113a6a0:	e0bffa15 	stw	r2,-24(fp)
8113a6a4:	e0bffa17 	ldw	r2,-24(fp)
8113a6a8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113a6ac:	e0bfff17 	ldw	r2,-4(fp)
8113a6b0:	10000005 	stb	zero,0(r2)
    return (len);
8113a6b4:	e0bffb03 	ldbu	r2,-20(fp)
}
8113a6b8:	e037883a 	mov	sp,fp
8113a6bc:	dfc00117 	ldw	ra,4(sp)
8113a6c0:	df000017 	ldw	fp,0(sp)
8113a6c4:	dec00204 	addi	sp,sp,8
8113a6c8:	f800283a 	ret

8113a6cc <OSFlagNameSet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
void  OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
8113a6cc:	defff504 	addi	sp,sp,-44
8113a6d0:	de00012e 	bgeu	sp,et,8113a6d8 <OSFlagNameSet+0xc>
8113a6d4:	003b68fa 	trap	3
8113a6d8:	dfc00a15 	stw	ra,40(sp)
8113a6dc:	df000915 	stw	fp,36(sp)
8113a6e0:	df000904 	addi	fp,sp,36
8113a6e4:	e13ffd15 	stw	r4,-12(fp)
8113a6e8:	e17ffe15 	stw	r5,-8(fp)
8113a6ec:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113a6f0:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113a6f4:	e0bfff17 	ldw	r2,-4(fp)
8113a6f8:	10004326 	beq	r2,zero,8113a808 <OSFlagNameSet+0x13c>
        return;
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
8113a6fc:	e0bffd17 	ldw	r2,-12(fp)
8113a700:	1000041e 	bne	r2,zero,8113a714 <OSFlagNameSet+0x48>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113a704:	e0bfff17 	ldw	r2,-4(fp)
8113a708:	00c01b84 	movi	r3,110
8113a70c:	10c00005 	stb	r3,0(r2)
        return;
8113a710:	00003e06 	br	8113a80c <OSFlagNameSet+0x140>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8113a714:	e0bffe17 	ldw	r2,-8(fp)
8113a718:	1000041e 	bne	r2,zero,8113a72c <OSFlagNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
8113a71c:	e0bfff17 	ldw	r2,-4(fp)
8113a720:	00c00304 	movi	r3,12
8113a724:	10c00005 	stb	r3,0(r2)
        return;
8113a728:	00003806 	br	8113a80c <OSFlagNameSet+0x140>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113a72c:	d0a0a103 	ldbu	r2,-32124(gp)
8113a730:	10803fcc 	andi	r2,r2,255
8113a734:	10000426 	beq	r2,zero,8113a748 <OSFlagNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
8113a738:	e0bfff17 	ldw	r2,-4(fp)
8113a73c:	00c00484 	movi	r3,18
8113a740:	10c00005 	stb	r3,0(r2)
        return;
8113a744:	00003106 	br	8113a80c <OSFlagNameSet+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a748:	0005303a 	rdctl	r2,status
8113a74c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a750:	e0fffc17 	ldw	r3,-16(fp)
8113a754:	00bfff84 	movi	r2,-2
8113a758:	1884703a 	and	r2,r3,r2
8113a75c:	1001703a 	wrctl	status,r2
  
  return context;
8113a760:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113a764:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
8113a768:	e0bffd17 	ldw	r2,-12(fp)
8113a76c:	10800003 	ldbu	r2,0(r2)
8113a770:	10803fcc 	andi	r2,r2,255
8113a774:	10800160 	cmpeqi	r2,r2,5
8113a778:	1000081e 	bne	r2,zero,8113a79c <OSFlagNameSet+0xd0>
8113a77c:	e0bff717 	ldw	r2,-36(fp)
8113a780:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a784:	e0bff817 	ldw	r2,-32(fp)
8113a788:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
8113a78c:	e0bfff17 	ldw	r2,-4(fp)
8113a790:	00c00044 	movi	r3,1
8113a794:	10c00005 	stb	r3,0(r2)
        return;
8113a798:	00001c06 	br	8113a80c <OSFlagNameSet+0x140>
    }
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
8113a79c:	e13ffe17 	ldw	r4,-8(fp)
8113a7a0:	11397e00 	call	811397e0 <OS_StrLen>
8113a7a4:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
8113a7a8:	e0bffa03 	ldbu	r2,-24(fp)
8113a7ac:	10800830 	cmpltui	r2,r2,32
8113a7b0:	1000081e 	bne	r2,zero,8113a7d4 <OSFlagNameSet+0x108>
8113a7b4:	e0bff717 	ldw	r2,-36(fp)
8113a7b8:	e0bff915 	stw	r2,-28(fp)
8113a7bc:	e0bff917 	ldw	r2,-28(fp)
8113a7c0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_FLAG_NAME_TOO_LONG;
8113a7c4:	e0bfff17 	ldw	r2,-4(fp)
8113a7c8:	00c01cc4 	movi	r3,115
8113a7cc:	10c00005 	stb	r3,0(r2)
        return;
8113a7d0:	00000e06 	br	8113a80c <OSFlagNameSet+0x140>
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
8113a7d4:	e0bffd17 	ldw	r2,-12(fp)
8113a7d8:	10800284 	addi	r2,r2,10
8113a7dc:	e17ffe17 	ldw	r5,-8(fp)
8113a7e0:	1009883a 	mov	r4,r2
8113a7e4:	11397640 	call	81139764 <OS_StrCopy>
8113a7e8:	e0bff717 	ldw	r2,-36(fp)
8113a7ec:	e0bffb15 	stw	r2,-20(fp)
8113a7f0:	e0bffb17 	ldw	r2,-20(fp)
8113a7f4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113a7f8:	e0bfff17 	ldw	r2,-4(fp)
8113a7fc:	10000005 	stb	zero,0(r2)
    return;
8113a800:	0001883a 	nop
8113a804:	00000106 	br	8113a80c <OSFlagNameSet+0x140>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
8113a808:	0001883a 	nop
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return;
}
8113a80c:	e037883a 	mov	sp,fp
8113a810:	dfc00117 	ldw	ra,4(sp)
8113a814:	df000017 	ldw	fp,0(sp)
8113a818:	dec00204 	addi	sp,sp,8
8113a81c:	f800283a 	ret

8113a820 <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *perr)
{
8113a820:	deffe104 	addi	sp,sp,-124
8113a824:	de00012e 	bgeu	sp,et,8113a82c <OSFlagPend+0xc>
8113a828:	003b68fa 	trap	3
8113a82c:	dfc01e15 	stw	ra,120(sp)
8113a830:	df001d15 	stw	fp,116(sp)
8113a834:	df001d04 	addi	fp,sp,116
8113a838:	e13ffc15 	stw	r4,-16(fp)
8113a83c:	2809883a 	mov	r4,r5
8113a840:	3007883a 	mov	r3,r6
8113a844:	3805883a 	mov	r2,r7
8113a848:	e13ffd0d 	sth	r4,-12(fp)
8113a84c:	e0fffe05 	stb	r3,-8(fp)
8113a850:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    INT8U         pend_stat;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8113a854:	e03fe515 	stw	zero,-108(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113a858:	e0800217 	ldw	r2,8(fp)
8113a85c:	1000021e 	bne	r2,zero,8113a868 <OSFlagPend+0x48>
        return ((OS_FLAGS)0);
8113a860:	0005883a 	mov	r2,zero
8113a864:	00015906 	br	8113adcc <OSFlagPend+0x5ac>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
8113a868:	e0bffc17 	ldw	r2,-16(fp)
8113a86c:	1000051e 	bne	r2,zero,8113a884 <OSFlagPend+0x64>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113a870:	e0800217 	ldw	r2,8(fp)
8113a874:	00c01b84 	movi	r3,110
8113a878:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113a87c:	0005883a 	mov	r2,zero
8113a880:	00015206 	br	8113adcc <OSFlagPend+0x5ac>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113a884:	d0a0a103 	ldbu	r2,-32124(gp)
8113a888:	10803fcc 	andi	r2,r2,255
8113a88c:	10000526 	beq	r2,zero,8113a8a4 <OSFlagPend+0x84>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
8113a890:	e0800217 	ldw	r2,8(fp)
8113a894:	00c00084 	movi	r3,2
8113a898:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113a89c:	0005883a 	mov	r2,zero
8113a8a0:	00014a06 	br	8113adcc <OSFlagPend+0x5ac>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
8113a8a4:	d0a08f03 	ldbu	r2,-32196(gp)
8113a8a8:	10803fcc 	andi	r2,r2,255
8113a8ac:	10000526 	beq	r2,zero,8113a8c4 <OSFlagPend+0xa4>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
8113a8b0:	e0800217 	ldw	r2,8(fp)
8113a8b4:	00c00344 	movi	r3,13
8113a8b8:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113a8bc:	0005883a 	mov	r2,zero
8113a8c0:	00014206 	br	8113adcc <OSFlagPend+0x5ac>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
8113a8c4:	e0bffc17 	ldw	r2,-16(fp)
8113a8c8:	10800003 	ldbu	r2,0(r2)
8113a8cc:	10803fcc 	andi	r2,r2,255
8113a8d0:	10800160 	cmpeqi	r2,r2,5
8113a8d4:	1000051e 	bne	r2,zero,8113a8ec <OSFlagPend+0xcc>
        *perr = OS_ERR_EVENT_TYPE;
8113a8d8:	e0800217 	ldw	r2,8(fp)
8113a8dc:	00c00044 	movi	r3,1
8113a8e0:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113a8e4:	0005883a 	mov	r2,zero
8113a8e8:	00013806 	br	8113adcc <OSFlagPend+0x5ac>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
8113a8ec:	e0fffe03 	ldbu	r3,-8(fp)
8113a8f0:	00bfe004 	movi	r2,-128
8113a8f4:	1884703a 	and	r2,r3,r2
8113a8f8:	e0bfe605 	stb	r2,-104(fp)
    if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
8113a8fc:	e0bfe603 	ldbu	r2,-104(fp)
8113a900:	10000626 	beq	r2,zero,8113a91c <OSFlagPend+0xfc>
        wait_type &= ~(INT8U)OS_FLAG_CONSUME;
8113a904:	e0bffe03 	ldbu	r2,-8(fp)
8113a908:	10801fcc 	andi	r2,r2,127
8113a90c:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
8113a910:	00800044 	movi	r2,1
8113a914:	e0bfe405 	stb	r2,-112(fp)
8113a918:	00000106 	br	8113a920 <OSFlagPend+0x100>
    } else {
        consume    = OS_FALSE;
8113a91c:	e03fe405 	stb	zero,-112(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a920:	0005303a 	rdctl	r2,status
8113a924:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a928:	e0fff617 	ldw	r3,-40(fp)
8113a92c:	00bfff84 	movi	r2,-2
8113a930:	1884703a 	and	r2,r3,r2
8113a934:	1001703a 	wrctl	status,r2
  
  return context;
8113a938:	e0bff617 	ldw	r2,-40(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
8113a93c:	e0bfe515 	stw	r2,-108(fp)
    switch (wait_type) {
8113a940:	e0bffe03 	ldbu	r2,-8(fp)
8113a944:	10c00060 	cmpeqi	r3,r2,1
8113a948:	1800921e 	bne	r3,zero,8113ab94 <OSFlagPend+0x374>
8113a94c:	10c00088 	cmpgei	r3,r2,2
8113a950:	1800021e 	bne	r3,zero,8113a95c <OSFlagPend+0x13c>
8113a954:	10006126 	beq	r2,zero,8113aadc <OSFlagPend+0x2bc>
8113a958:	0000bb06 	br	8113ac48 <OSFlagPend+0x428>
8113a95c:	10c000a0 	cmpeqi	r3,r2,2
8113a960:	1800031e 	bne	r3,zero,8113a970 <OSFlagPend+0x150>
8113a964:	108000e0 	cmpeqi	r2,r2,3
8113a968:	10002f1e 	bne	r2,zero,8113aa28 <OSFlagPend+0x208>
8113a96c:	0000b606 	br	8113ac48 <OSFlagPend+0x428>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
8113a970:	e0bffc17 	ldw	r2,-16(fp)
8113a974:	10c0020b 	ldhu	r3,8(r2)
8113a978:	e0bffd0b 	ldhu	r2,-12(fp)
8113a97c:	1884703a 	and	r2,r3,r2
8113a980:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
8113a984:	e0ffe80b 	ldhu	r3,-96(fp)
8113a988:	e0bffd0b 	ldhu	r2,-12(fp)
8113a98c:	1880171e 	bne	r3,r2,8113a9ec <OSFlagPend+0x1cc>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113a990:	e0bfe403 	ldbu	r2,-112(fp)
8113a994:	10800058 	cmpnei	r2,r2,1
8113a998:	1000091e 	bne	r2,zero,8113a9c0 <OSFlagPend+0x1a0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
8113a99c:	e0bffc17 	ldw	r2,-16(fp)
8113a9a0:	1080020b 	ldhu	r2,8(r2)
8113a9a4:	1007883a 	mov	r3,r2
8113a9a8:	e0bfe80b 	ldhu	r2,-96(fp)
8113a9ac:	0084303a 	nor	r2,zero,r2
8113a9b0:	1884703a 	and	r2,r3,r2
8113a9b4:	1007883a 	mov	r3,r2
8113a9b8:	e0bffc17 	ldw	r2,-16(fp)
8113a9bc:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8113a9c0:	d0a0a217 	ldw	r2,-32120(gp)
8113a9c4:	e0ffe80b 	ldhu	r3,-96(fp)
8113a9c8:	10c00b0d 	sth	r3,44(r2)
8113a9cc:	e0bfe517 	ldw	r2,-108(fp)
8113a9d0:	e0bfe715 	stw	r2,-100(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a9d4:	e0bfe717 	ldw	r2,-100(fp)
8113a9d8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8113a9dc:	e0800217 	ldw	r2,8(fp)
8113a9e0:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8113a9e4:	e0bfe80b 	ldhu	r2,-96(fp)
8113a9e8:	0000f806 	br	8113adcc <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8113a9ec:	e13ffd0b 	ldhu	r4,-12(fp)
8113a9f0:	e17ffe03 	ldbu	r5,-8(fp)
8113a9f4:	e0bfff0b 	ldhu	r2,-4(fp)
8113a9f8:	e0fff704 	addi	r3,fp,-36
8113a9fc:	d8800015 	stw	r2,0(sp)
8113aa00:	280f883a 	mov	r7,r5
8113aa04:	200d883a 	mov	r6,r4
8113aa08:	180b883a 	mov	r5,r3
8113aa0c:	e13ffc17 	ldw	r4,-16(fp)
8113aa10:	113b2b00 	call	8113b2b0 <OS_FlagBlock>
8113aa14:	e0bfe517 	ldw	r2,-108(fp)
8113aa18:	e0bfe915 	stw	r2,-92(fp)
8113aa1c:	e0bfe917 	ldw	r2,-92(fp)
8113aa20:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8113aa24:	00009206 	br	8113ac70 <OSFlagPend+0x450>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
8113aa28:	e0bffc17 	ldw	r2,-16(fp)
8113aa2c:	10c0020b 	ldhu	r3,8(r2)
8113aa30:	e0bffd0b 	ldhu	r2,-12(fp)
8113aa34:	1884703a 	and	r2,r3,r2
8113aa38:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
8113aa3c:	e0bfe80b 	ldhu	r2,-96(fp)
8113aa40:	10001726 	beq	r2,zero,8113aaa0 <OSFlagPend+0x280>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113aa44:	e0bfe403 	ldbu	r2,-112(fp)
8113aa48:	10800058 	cmpnei	r2,r2,1
8113aa4c:	1000091e 	bne	r2,zero,8113aa74 <OSFlagPend+0x254>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
8113aa50:	e0bffc17 	ldw	r2,-16(fp)
8113aa54:	1080020b 	ldhu	r2,8(r2)
8113aa58:	1007883a 	mov	r3,r2
8113aa5c:	e0bfe80b 	ldhu	r2,-96(fp)
8113aa60:	0084303a 	nor	r2,zero,r2
8113aa64:	1884703a 	and	r2,r3,r2
8113aa68:	1007883a 	mov	r3,r2
8113aa6c:	e0bffc17 	ldw	r2,-16(fp)
8113aa70:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8113aa74:	d0a0a217 	ldw	r2,-32120(gp)
8113aa78:	e0ffe80b 	ldhu	r3,-96(fp)
8113aa7c:	10c00b0d 	sth	r3,44(r2)
8113aa80:	e0bfe517 	ldw	r2,-108(fp)
8113aa84:	e0bfea15 	stw	r2,-88(fp)
8113aa88:	e0bfea17 	ldw	r2,-88(fp)
8113aa8c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8113aa90:	e0800217 	ldw	r2,8(fp)
8113aa94:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8113aa98:	e0bfe80b 	ldhu	r2,-96(fp)
8113aa9c:	0000cb06 	br	8113adcc <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8113aaa0:	e13ffd0b 	ldhu	r4,-12(fp)
8113aaa4:	e17ffe03 	ldbu	r5,-8(fp)
8113aaa8:	e0bfff0b 	ldhu	r2,-4(fp)
8113aaac:	e0fff704 	addi	r3,fp,-36
8113aab0:	d8800015 	stw	r2,0(sp)
8113aab4:	280f883a 	mov	r7,r5
8113aab8:	200d883a 	mov	r6,r4
8113aabc:	180b883a 	mov	r5,r3
8113aac0:	e13ffc17 	ldw	r4,-16(fp)
8113aac4:	113b2b00 	call	8113b2b0 <OS_FlagBlock>
8113aac8:	e0bfe517 	ldw	r2,-108(fp)
8113aacc:	e0bfeb15 	stw	r2,-84(fp)
8113aad0:	e0bfeb17 	ldw	r2,-84(fp)
8113aad4:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8113aad8:	00006506 	br	8113ac70 <OSFlagPend+0x450>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
8113aadc:	e0bffc17 	ldw	r2,-16(fp)
8113aae0:	1080020b 	ldhu	r2,8(r2)
8113aae4:	0084303a 	nor	r2,zero,r2
8113aae8:	1007883a 	mov	r3,r2
8113aaec:	e0bffd0b 	ldhu	r2,-12(fp)
8113aaf0:	1884703a 	and	r2,r3,r2
8113aaf4:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
8113aaf8:	e0ffe80b 	ldhu	r3,-96(fp)
8113aafc:	e0bffd0b 	ldhu	r2,-12(fp)
8113ab00:	1880151e 	bne	r3,r2,8113ab58 <OSFlagPend+0x338>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113ab04:	e0bfe403 	ldbu	r2,-112(fp)
8113ab08:	10800058 	cmpnei	r2,r2,1
8113ab0c:	1000071e 	bne	r2,zero,8113ab2c <OSFlagPend+0x30c>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
8113ab10:	e0bffc17 	ldw	r2,-16(fp)
8113ab14:	10c0020b 	ldhu	r3,8(r2)
8113ab18:	e0bfe80b 	ldhu	r2,-96(fp)
8113ab1c:	1884b03a 	or	r2,r3,r2
8113ab20:	1007883a 	mov	r3,r2
8113ab24:	e0bffc17 	ldw	r2,-16(fp)
8113ab28:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8113ab2c:	d0a0a217 	ldw	r2,-32120(gp)
8113ab30:	e0ffe80b 	ldhu	r3,-96(fp)
8113ab34:	10c00b0d 	sth	r3,44(r2)
8113ab38:	e0bfe517 	ldw	r2,-108(fp)
8113ab3c:	e0bfec15 	stw	r2,-80(fp)
8113ab40:	e0bfec17 	ldw	r2,-80(fp)
8113ab44:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8113ab48:	e0800217 	ldw	r2,8(fp)
8113ab4c:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8113ab50:	e0bfe80b 	ldhu	r2,-96(fp)
8113ab54:	00009d06 	br	8113adcc <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8113ab58:	e13ffd0b 	ldhu	r4,-12(fp)
8113ab5c:	e17ffe03 	ldbu	r5,-8(fp)
8113ab60:	e0bfff0b 	ldhu	r2,-4(fp)
8113ab64:	e0fff704 	addi	r3,fp,-36
8113ab68:	d8800015 	stw	r2,0(sp)
8113ab6c:	280f883a 	mov	r7,r5
8113ab70:	200d883a 	mov	r6,r4
8113ab74:	180b883a 	mov	r5,r3
8113ab78:	e13ffc17 	ldw	r4,-16(fp)
8113ab7c:	113b2b00 	call	8113b2b0 <OS_FlagBlock>
8113ab80:	e0bfe517 	ldw	r2,-108(fp)
8113ab84:	e0bfed15 	stw	r2,-76(fp)
8113ab88:	e0bfed17 	ldw	r2,-76(fp)
8113ab8c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8113ab90:	00003706 	br	8113ac70 <OSFlagPend+0x450>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
8113ab94:	e0bffc17 	ldw	r2,-16(fp)
8113ab98:	1080020b 	ldhu	r2,8(r2)
8113ab9c:	0084303a 	nor	r2,zero,r2
8113aba0:	1007883a 	mov	r3,r2
8113aba4:	e0bffd0b 	ldhu	r2,-12(fp)
8113aba8:	1884703a 	and	r2,r3,r2
8113abac:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
8113abb0:	e0bfe80b 	ldhu	r2,-96(fp)
8113abb4:	10001526 	beq	r2,zero,8113ac0c <OSFlagPend+0x3ec>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113abb8:	e0bfe403 	ldbu	r2,-112(fp)
8113abbc:	10800058 	cmpnei	r2,r2,1
8113abc0:	1000071e 	bne	r2,zero,8113abe0 <OSFlagPend+0x3c0>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
8113abc4:	e0bffc17 	ldw	r2,-16(fp)
8113abc8:	10c0020b 	ldhu	r3,8(r2)
8113abcc:	e0bfe80b 	ldhu	r2,-96(fp)
8113abd0:	1884b03a 	or	r2,r3,r2
8113abd4:	1007883a 	mov	r3,r2
8113abd8:	e0bffc17 	ldw	r2,-16(fp)
8113abdc:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8113abe0:	d0a0a217 	ldw	r2,-32120(gp)
8113abe4:	e0ffe80b 	ldhu	r3,-96(fp)
8113abe8:	10c00b0d 	sth	r3,44(r2)
8113abec:	e0bfe517 	ldw	r2,-108(fp)
8113abf0:	e0bfee15 	stw	r2,-72(fp)
8113abf4:	e0bfee17 	ldw	r2,-72(fp)
8113abf8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8113abfc:	e0800217 	ldw	r2,8(fp)
8113ac00:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8113ac04:	e0bfe80b 	ldhu	r2,-96(fp)
8113ac08:	00007006 	br	8113adcc <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8113ac0c:	e13ffd0b 	ldhu	r4,-12(fp)
8113ac10:	e17ffe03 	ldbu	r5,-8(fp)
8113ac14:	e0bfff0b 	ldhu	r2,-4(fp)
8113ac18:	e0fff704 	addi	r3,fp,-36
8113ac1c:	d8800015 	stw	r2,0(sp)
8113ac20:	280f883a 	mov	r7,r5
8113ac24:	200d883a 	mov	r6,r4
8113ac28:	180b883a 	mov	r5,r3
8113ac2c:	e13ffc17 	ldw	r4,-16(fp)
8113ac30:	113b2b00 	call	8113b2b0 <OS_FlagBlock>
8113ac34:	e0bfe517 	ldw	r2,-108(fp)
8113ac38:	e0bfef15 	stw	r2,-68(fp)
8113ac3c:	e0bfef17 	ldw	r2,-68(fp)
8113ac40:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8113ac44:	00000a06 	br	8113ac70 <OSFlagPend+0x450>
8113ac48:	e0bfe517 	ldw	r2,-108(fp)
8113ac4c:	e0bff015 	stw	r2,-64(fp)
8113ac50:	e0bff017 	ldw	r2,-64(fp)
8113ac54:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
8113ac58:	e03fe80d 	sth	zero,-96(fp)
             *perr      = OS_ERR_FLAG_WAIT_TYPE;
8113ac5c:	e0800217 	ldw	r2,8(fp)
8113ac60:	00c01bc4 	movi	r3,111
8113ac64:	10c00005 	stb	r3,0(r2)
             return (flags_rdy);
8113ac68:	e0bfe80b 	ldhu	r2,-96(fp)
8113ac6c:	00005706 	br	8113adcc <OSFlagPend+0x5ac>
    }
/*$PAGE*/
    OS_Sched();                                            /* Find next HPT ready to run               */
8113ac70:	11396100 	call	81139610 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ac74:	0005303a 	rdctl	r2,status
8113ac78:	e0bff115 	stw	r2,-60(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ac7c:	e0fff117 	ldw	r3,-60(fp)
8113ac80:	00bfff84 	movi	r2,-2
8113ac84:	1884703a 	and	r2,r3,r2
8113ac88:	1001703a 	wrctl	status,r2
  
  return context;
8113ac8c:	e0bff117 	ldw	r2,-60(fp)
    OS_ENTER_CRITICAL();
8113ac90:	e0bfe515 	stw	r2,-108(fp)
    if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
8113ac94:	d0a0a217 	ldw	r2,-32120(gp)
8113ac98:	10800c43 	ldbu	r2,49(r2)
8113ac9c:	10803fcc 	andi	r2,r2,255
8113aca0:	10001c26 	beq	r2,zero,8113ad14 <OSFlagPend+0x4f4>
        pend_stat                = OSTCBCur->OSTCBStatPend;
8113aca4:	d0a0a217 	ldw	r2,-32120(gp)
8113aca8:	10800c43 	ldbu	r2,49(r2)
8113acac:	e0bff305 	stb	r2,-52(fp)
        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113acb0:	d0a0a217 	ldw	r2,-32120(gp)
8113acb4:	10000c45 	stb	zero,49(r2)
        OS_FlagUnlink(&node);
8113acb8:	e0bff704 	addi	r2,fp,-36
8113acbc:	1009883a 	mov	r4,r2
8113acc0:	113b5fc0 	call	8113b5fc <OS_FlagUnlink>
        OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
8113acc4:	d0a0a217 	ldw	r2,-32120(gp)
8113acc8:	10000c05 	stb	zero,48(r2)
8113accc:	e0bfe517 	ldw	r2,-108(fp)
8113acd0:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113acd4:	e0bff217 	ldw	r2,-56(fp)
8113acd8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        flags_rdy                = (OS_FLAGS)0;
8113acdc:	e03fe80d 	sth	zero,-96(fp)
        switch (pend_stat) {
8113ace0:	e0bff303 	ldbu	r2,-52(fp)
8113ace4:	108000a0 	cmpeqi	r2,r2,2
8113ace8:	10000426 	beq	r2,zero,8113acfc <OSFlagPend+0x4dc>
            case OS_STAT_PEND_ABORT:
                 *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
8113acec:	e0800217 	ldw	r2,8(fp)
8113acf0:	00c00384 	movi	r3,14
8113acf4:	10c00005 	stb	r3,0(r2)
                 break;
8113acf8:	00000406 	br	8113ad0c <OSFlagPend+0x4ec>

            case OS_STAT_PEND_TO:
            default:
                 *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
8113acfc:	e0800217 	ldw	r2,8(fp)
8113ad00:	00c00284 	movi	r3,10
8113ad04:	10c00005 	stb	r3,0(r2)
                 break;
8113ad08:	0001883a 	nop
        }
        return (flags_rdy);
8113ad0c:	e0bfe80b 	ldhu	r2,-96(fp)
8113ad10:	00002e06 	br	8113adcc <OSFlagPend+0x5ac>
    }
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
8113ad14:	d0a0a217 	ldw	r2,-32120(gp)
8113ad18:	10800b0b 	ldhu	r2,44(r2)
8113ad1c:	e0bfe80d 	sth	r2,-96(fp)
    if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
8113ad20:	e0bfe403 	ldbu	r2,-112(fp)
8113ad24:	10800058 	cmpnei	r2,r2,1
8113ad28:	1000211e 	bne	r2,zero,8113adb0 <OSFlagPend+0x590>
        switch (wait_type) {
8113ad2c:	e0bffe03 	ldbu	r2,-8(fp)
8113ad30:	10001616 	blt	r2,zero,8113ad8c <OSFlagPend+0x56c>
8113ad34:	10c00090 	cmplti	r3,r2,2
8113ad38:	18000c1e 	bne	r3,zero,8113ad6c <OSFlagPend+0x54c>
8113ad3c:	10800108 	cmpgei	r2,r2,4
8113ad40:	1000121e 	bne	r2,zero,8113ad8c <OSFlagPend+0x56c>
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
8113ad44:	e0bffc17 	ldw	r2,-16(fp)
8113ad48:	1080020b 	ldhu	r2,8(r2)
8113ad4c:	1007883a 	mov	r3,r2
8113ad50:	e0bfe80b 	ldhu	r2,-96(fp)
8113ad54:	0084303a 	nor	r2,zero,r2
8113ad58:	1884703a 	and	r2,r3,r2
8113ad5c:	1007883a 	mov	r3,r2
8113ad60:	e0bffc17 	ldw	r2,-16(fp)
8113ad64:	10c0020d 	sth	r3,8(r2)
                 break;
8113ad68:	00001106 	br	8113adb0 <OSFlagPend+0x590>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
8113ad6c:	e0bffc17 	ldw	r2,-16(fp)
8113ad70:	10c0020b 	ldhu	r3,8(r2)
8113ad74:	e0bfe80b 	ldhu	r2,-96(fp)
8113ad78:	1884b03a 	or	r2,r3,r2
8113ad7c:	1007883a 	mov	r3,r2
8113ad80:	e0bffc17 	ldw	r2,-16(fp)
8113ad84:	10c0020d 	sth	r3,8(r2)
                 break;
8113ad88:	00000906 	br	8113adb0 <OSFlagPend+0x590>
8113ad8c:	e0bfe517 	ldw	r2,-108(fp)
8113ad90:	e0bff415 	stw	r2,-48(fp)
8113ad94:	e0bff417 	ldw	r2,-48(fp)
8113ad98:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
8113ad9c:	e0800217 	ldw	r2,8(fp)
8113ada0:	00c01bc4 	movi	r3,111
8113ada4:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
8113ada8:	0005883a 	mov	r2,zero
8113adac:	00000706 	br	8113adcc <OSFlagPend+0x5ac>
8113adb0:	e0bfe517 	ldw	r2,-108(fp)
8113adb4:	e0bff515 	stw	r2,-44(fp)
8113adb8:	e0bff517 	ldw	r2,-44(fp)
8113adbc:	1001703a 	wrctl	status,r2
        }
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
8113adc0:	e0800217 	ldw	r2,8(fp)
8113adc4:	10000005 	stb	zero,0(r2)
    return (flags_rdy);
8113adc8:	e0bfe80b 	ldhu	r2,-96(fp)
}
8113adcc:	e037883a 	mov	sp,fp
8113add0:	dfc00117 	ldw	ra,4(sp)
8113add4:	df000017 	ldw	fp,0(sp)
8113add8:	dec00204 	addi	sp,sp,8
8113addc:	f800283a 	ret

8113ade0 <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
8113ade0:	defffb04 	addi	sp,sp,-20
8113ade4:	de00012e 	bgeu	sp,et,8113adec <OSFlagPendGetFlagsRdy+0xc>
8113ade8:	003b68fa 	trap	3
8113adec:	df000415 	stw	fp,16(sp)
8113adf0:	df000404 	addi	fp,sp,16
    OS_FLAGS      flags;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8113adf4:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113adf8:	0005303a 	rdctl	r2,status
8113adfc:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ae00:	e0fffe17 	ldw	r3,-8(fp)
8113ae04:	00bfff84 	movi	r2,-2
8113ae08:	1884703a 	and	r2,r3,r2
8113ae0c:	1001703a 	wrctl	status,r2
  
  return context;
8113ae10:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
8113ae14:	e0bffc15 	stw	r2,-16(fp)
    flags = OSTCBCur->OSTCBFlagsRdy;
8113ae18:	d0a0a217 	ldw	r2,-32120(gp)
8113ae1c:	10800b0b 	ldhu	r2,44(r2)
8113ae20:	e0bffd0d 	sth	r2,-12(fp)
8113ae24:	e0bffc17 	ldw	r2,-16(fp)
8113ae28:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ae2c:	e0bfff17 	ldw	r2,-4(fp)
8113ae30:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (flags);
8113ae34:	e0bffd0b 	ldhu	r2,-12(fp)
}
8113ae38:	e037883a 	mov	sp,fp
8113ae3c:	df000017 	ldw	fp,0(sp)
8113ae40:	dec00104 	addi	sp,sp,4
8113ae44:	f800283a 	ret

8113ae48 <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)
{
8113ae48:	deffef04 	addi	sp,sp,-68
8113ae4c:	de00012e 	bgeu	sp,et,8113ae54 <OSFlagPost+0xc>
8113ae50:	003b68fa 	trap	3
8113ae54:	dfc01015 	stw	ra,64(sp)
8113ae58:	df000f15 	stw	fp,60(sp)
8113ae5c:	df000f04 	addi	fp,sp,60
8113ae60:	e13ffc15 	stw	r4,-16(fp)
8113ae64:	2807883a 	mov	r3,r5
8113ae68:	3005883a 	mov	r2,r6
8113ae6c:	e1ffff15 	stw	r7,-4(fp)
8113ae70:	e0fffd0d 	sth	r3,-12(fp)
8113ae74:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       sched;
    OS_FLAGS      flags_cur;
    OS_FLAGS      flags_rdy;
    BOOLEAN       rdy;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR     cpu_sr = 0;
8113ae78:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
8113ae7c:	e0bfff17 	ldw	r2,-4(fp)
8113ae80:	1000021e 	bne	r2,zero,8113ae8c <OSFlagPost+0x44>
        return ((OS_FLAGS)0);
8113ae84:	0005883a 	mov	r2,zero
8113ae88:	0000d106 	br	8113b1d0 <OSFlagPost+0x388>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
8113ae8c:	e0bffc17 	ldw	r2,-16(fp)
8113ae90:	1000051e 	bne	r2,zero,8113aea8 <OSFlagPost+0x60>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113ae94:	e0bfff17 	ldw	r2,-4(fp)
8113ae98:	00c01b84 	movi	r3,110
8113ae9c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113aea0:	0005883a 	mov	r2,zero
8113aea4:	0000ca06 	br	8113b1d0 <OSFlagPost+0x388>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
8113aea8:	e0bffc17 	ldw	r2,-16(fp)
8113aeac:	10800003 	ldbu	r2,0(r2)
8113aeb0:	10803fcc 	andi	r2,r2,255
8113aeb4:	10800160 	cmpeqi	r2,r2,5
8113aeb8:	1000051e 	bne	r2,zero,8113aed0 <OSFlagPost+0x88>
        *perr = OS_ERR_EVENT_TYPE;
8113aebc:	e0bfff17 	ldw	r2,-4(fp)
8113aec0:	00c00044 	movi	r3,1
8113aec4:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113aec8:	0005883a 	mov	r2,zero
8113aecc:	0000c006 	br	8113b1d0 <OSFlagPost+0x388>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113aed0:	0005303a 	rdctl	r2,status
8113aed4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113aed8:	e0fffb17 	ldw	r3,-20(fp)
8113aedc:	00bfff84 	movi	r2,-2
8113aee0:	1884703a 	and	r2,r3,r2
8113aee4:	1001703a 	wrctl	status,r2
  
  return context;
8113aee8:	e0bffb17 	ldw	r2,-20(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
8113aeec:	e0bff315 	stw	r2,-52(fp)
    switch (opt) {
8113aef0:	e0bffe03 	ldbu	r2,-8(fp)
8113aef4:	10000326 	beq	r2,zero,8113af04 <OSFlagPost+0xbc>
8113aef8:	10800060 	cmpeqi	r2,r2,1
8113aefc:	10000b1e 	bne	r2,zero,8113af2c <OSFlagPost+0xe4>
8113af00:	00001206 	br	8113af4c <OSFlagPost+0x104>
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
8113af04:	e0bffc17 	ldw	r2,-16(fp)
8113af08:	1080020b 	ldhu	r2,8(r2)
8113af0c:	1007883a 	mov	r3,r2
8113af10:	e0bffd0b 	ldhu	r2,-12(fp)
8113af14:	0084303a 	nor	r2,zero,r2
8113af18:	1884703a 	and	r2,r3,r2
8113af1c:	1007883a 	mov	r3,r2
8113af20:	e0bffc17 	ldw	r2,-16(fp)
8113af24:	10c0020d 	sth	r3,8(r2)
             break;
8113af28:	00001106 	br	8113af70 <OSFlagPost+0x128>

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
8113af2c:	e0bffc17 	ldw	r2,-16(fp)
8113af30:	10c0020b 	ldhu	r3,8(r2)
8113af34:	e0bffd0b 	ldhu	r2,-12(fp)
8113af38:	1884b03a 	or	r2,r3,r2
8113af3c:	1007883a 	mov	r3,r2
8113af40:	e0bffc17 	ldw	r2,-16(fp)
8113af44:	10c0020d 	sth	r3,8(r2)
             break;
8113af48:	00000906 	br	8113af70 <OSFlagPost+0x128>
8113af4c:	e0bff317 	ldw	r2,-52(fp)
8113af50:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113af54:	e0bff417 	ldw	r2,-48(fp)
8113af58:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
             *perr = OS_ERR_FLAG_INVALID_OPT;
8113af5c:	e0bfff17 	ldw	r2,-4(fp)
8113af60:	00c01c44 	movi	r3,113
8113af64:	10c00005 	stb	r3,0(r2)
             return ((OS_FLAGS)0);
8113af68:	0005883a 	mov	r2,zero
8113af6c:	00009806 	br	8113b1d0 <OSFlagPost+0x388>
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
8113af70:	e03ff205 	stb	zero,-56(fp)
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
8113af74:	e0bffc17 	ldw	r2,-16(fp)
8113af78:	10800117 	ldw	r2,4(r2)
8113af7c:	e0bff115 	stw	r2,-60(fp)
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
8113af80:	00007706 	br	8113b160 <OSFlagPost+0x318>
        switch (pnode->OSFlagNodeWaitType) {
8113af84:	e0bff117 	ldw	r2,-60(fp)
8113af88:	10800483 	ldbu	r2,18(r2)
8113af8c:	10803fcc 	andi	r2,r2,255
8113af90:	10c00060 	cmpeqi	r3,r2,1
8113af94:	18004a1e 	bne	r3,zero,8113b0c0 <OSFlagPost+0x278>
8113af98:	10c00088 	cmpgei	r3,r2,2
8113af9c:	1800021e 	bne	r3,zero,8113afa8 <OSFlagPost+0x160>
8113afa0:	10002f26 	beq	r2,zero,8113b060 <OSFlagPost+0x218>
8113afa4:	00005b06 	br	8113b114 <OSFlagPost+0x2cc>
8113afa8:	10c000a0 	cmpeqi	r3,r2,2
8113afac:	1800031e 	bne	r3,zero,8113afbc <OSFlagPost+0x174>
8113afb0:	108000e0 	cmpeqi	r2,r2,3
8113afb4:	1000171e 	bne	r2,zero,8113b014 <OSFlagPost+0x1cc>
8113afb8:	00005606 	br	8113b114 <OSFlagPost+0x2cc>
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8113afbc:	e0bffc17 	ldw	r2,-16(fp)
8113afc0:	10c0020b 	ldhu	r3,8(r2)
8113afc4:	e0bff117 	ldw	r2,-60(fp)
8113afc8:	1080040b 	ldhu	r2,16(r2)
8113afcc:	1884703a 	and	r2,r3,r2
8113afd0:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
8113afd4:	e0bff117 	ldw	r2,-60(fp)
8113afd8:	1080040b 	ldhu	r2,16(r2)
8113afdc:	10ffffcc 	andi	r3,r2,65535
8113afe0:	e0bff60b 	ldhu	r2,-40(fp)
8113afe4:	1880541e 	bne	r3,r2,8113b138 <OSFlagPost+0x2f0>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8113afe8:	e0bff60b 	ldhu	r2,-40(fp)
8113afec:	100b883a 	mov	r5,r2
8113aff0:	e13ff117 	ldw	r4,-60(fp)
8113aff4:	113b5000 	call	8113b500 <OS_FlagTaskRdy>
8113aff8:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
8113affc:	e0bff683 	ldbu	r2,-38(fp)
8113b000:	10800058 	cmpnei	r2,r2,1
8113b004:	10004c1e 	bne	r2,zero,8113b138 <OSFlagPost+0x2f0>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8113b008:	00800044 	movi	r2,1
8113b00c:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
8113b010:	00004906 	br	8113b138 <OSFlagPost+0x2f0>

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8113b014:	e0bffc17 	ldw	r2,-16(fp)
8113b018:	10c0020b 	ldhu	r3,8(r2)
8113b01c:	e0bff117 	ldw	r2,-60(fp)
8113b020:	1080040b 	ldhu	r2,16(r2)
8113b024:	1884703a 	and	r2,r3,r2
8113b028:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
8113b02c:	e0bff60b 	ldhu	r2,-40(fp)
8113b030:	10004326 	beq	r2,zero,8113b140 <OSFlagPost+0x2f8>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8113b034:	e0bff60b 	ldhu	r2,-40(fp)
8113b038:	100b883a 	mov	r5,r2
8113b03c:	e13ff117 	ldw	r4,-60(fp)
8113b040:	113b5000 	call	8113b500 <OS_FlagTaskRdy>
8113b044:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
8113b048:	e0bff683 	ldbu	r2,-38(fp)
8113b04c:	10800058 	cmpnei	r2,r2,1
8113b050:	10003b1e 	bne	r2,zero,8113b140 <OSFlagPost+0x2f8>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8113b054:	00800044 	movi	r2,1
8113b058:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
8113b05c:	00003806 	br	8113b140 <OSFlagPost+0x2f8>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8113b060:	e0bffc17 	ldw	r2,-16(fp)
8113b064:	1080020b 	ldhu	r2,8(r2)
8113b068:	0084303a 	nor	r2,zero,r2
8113b06c:	1007883a 	mov	r3,r2
8113b070:	e0bff117 	ldw	r2,-60(fp)
8113b074:	1080040b 	ldhu	r2,16(r2)
8113b078:	1884703a 	and	r2,r3,r2
8113b07c:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
8113b080:	e0bff117 	ldw	r2,-60(fp)
8113b084:	1080040b 	ldhu	r2,16(r2)
8113b088:	10ffffcc 	andi	r3,r2,65535
8113b08c:	e0bff60b 	ldhu	r2,-40(fp)
8113b090:	18802d1e 	bne	r3,r2,8113b148 <OSFlagPost+0x300>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8113b094:	e0bff60b 	ldhu	r2,-40(fp)
8113b098:	100b883a 	mov	r5,r2
8113b09c:	e13ff117 	ldw	r4,-60(fp)
8113b0a0:	113b5000 	call	8113b500 <OS_FlagTaskRdy>
8113b0a4:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
8113b0a8:	e0bff683 	ldbu	r2,-38(fp)
8113b0ac:	10800058 	cmpnei	r2,r2,1
8113b0b0:	1000251e 	bne	r2,zero,8113b148 <OSFlagPost+0x300>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8113b0b4:	00800044 	movi	r2,1
8113b0b8:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
8113b0bc:	00002206 	br	8113b148 <OSFlagPost+0x300>

            case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8113b0c0:	e0bffc17 	ldw	r2,-16(fp)
8113b0c4:	1080020b 	ldhu	r2,8(r2)
8113b0c8:	0084303a 	nor	r2,zero,r2
8113b0cc:	1007883a 	mov	r3,r2
8113b0d0:	e0bff117 	ldw	r2,-60(fp)
8113b0d4:	1080040b 	ldhu	r2,16(r2)
8113b0d8:	1884703a 	and	r2,r3,r2
8113b0dc:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
8113b0e0:	e0bff60b 	ldhu	r2,-40(fp)
8113b0e4:	10001a26 	beq	r2,zero,8113b150 <OSFlagPost+0x308>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8113b0e8:	e0bff60b 	ldhu	r2,-40(fp)
8113b0ec:	100b883a 	mov	r5,r2
8113b0f0:	e13ff117 	ldw	r4,-60(fp)
8113b0f4:	113b5000 	call	8113b500 <OS_FlagTaskRdy>
8113b0f8:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
8113b0fc:	e0bff683 	ldbu	r2,-38(fp)
8113b100:	10800058 	cmpnei	r2,r2,1
8113b104:	1000121e 	bne	r2,zero,8113b150 <OSFlagPost+0x308>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8113b108:	00800044 	movi	r2,1
8113b10c:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
8113b110:	00000f06 	br	8113b150 <OSFlagPost+0x308>
8113b114:	e0bff317 	ldw	r2,-52(fp)
8113b118:	e0bff515 	stw	r2,-44(fp)
8113b11c:	e0bff517 	ldw	r2,-44(fp)
8113b120:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
8113b124:	e0bfff17 	ldw	r2,-4(fp)
8113b128:	00c01bc4 	movi	r3,111
8113b12c:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
8113b130:	0005883a 	mov	r2,zero
8113b134:	00002606 	br	8113b1d0 <OSFlagPost+0x388>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
8113b138:	0001883a 	nop
8113b13c:	00000506 	br	8113b154 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
8113b140:	0001883a 	nop
8113b144:	00000306 	br	8113b154 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
8113b148:	0001883a 	nop
8113b14c:	00000106 	br	8113b154 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
8113b150:	0001883a 	nop
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
8113b154:	e0bff117 	ldw	r2,-60(fp)
8113b158:	10800017 	ldw	r2,0(r2)
8113b15c:	e0bff115 	stw	r2,-60(fp)
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
8113b160:	e0bff117 	ldw	r2,-60(fp)
8113b164:	103f871e 	bne	r2,zero,8113af84 <__reset+0xfb11af84>
8113b168:	e0bff317 	ldw	r2,-52(fp)
8113b16c:	e0bff715 	stw	r2,-36(fp)
8113b170:	e0bff717 	ldw	r2,-36(fp)
8113b174:	1001703a 	wrctl	status,r2
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
    if (sched == OS_TRUE) {
8113b178:	e0bff203 	ldbu	r2,-56(fp)
8113b17c:	10800058 	cmpnei	r2,r2,1
8113b180:	1000011e 	bne	r2,zero,8113b188 <OSFlagPost+0x340>
        OS_Sched();
8113b184:	11396100 	call	81139610 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b188:	0005303a 	rdctl	r2,status
8113b18c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b190:	e0fffa17 	ldw	r3,-24(fp)
8113b194:	00bfff84 	movi	r2,-2
8113b198:	1884703a 	and	r2,r3,r2
8113b19c:	1001703a 	wrctl	status,r2
  
  return context;
8113b1a0:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
8113b1a4:	e0bff315 	stw	r2,-52(fp)
    flags_cur = pgrp->OSFlagFlags;
8113b1a8:	e0bffc17 	ldw	r2,-16(fp)
8113b1ac:	1080020b 	ldhu	r2,8(r2)
8113b1b0:	e0bff90d 	sth	r2,-28(fp)
8113b1b4:	e0bff317 	ldw	r2,-52(fp)
8113b1b8:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b1bc:	e0bff817 	ldw	r2,-32(fp)
8113b1c0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr     = OS_ERR_NONE;
8113b1c4:	e0bfff17 	ldw	r2,-4(fp)
8113b1c8:	10000005 	stb	zero,0(r2)
    return (flags_cur);
8113b1cc:	e0bff90b 	ldhu	r2,-28(fp)
}
8113b1d0:	e037883a 	mov	sp,fp
8113b1d4:	dfc00117 	ldw	ra,4(sp)
8113b1d8:	df000017 	ldw	fp,0(sp)
8113b1dc:	dec00204 	addi	sp,sp,8
8113b1e0:	f800283a 	ret

8113b1e4 <OSFlagQuery>:
*********************************************************************************************************
*/

#if OS_FLAG_QUERY_EN > 0
OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *perr)
{
8113b1e4:	defff904 	addi	sp,sp,-28
8113b1e8:	de00012e 	bgeu	sp,et,8113b1f0 <OSFlagQuery+0xc>
8113b1ec:	003b68fa 	trap	3
8113b1f0:	df000615 	stw	fp,24(sp)
8113b1f4:	df000604 	addi	fp,sp,24
8113b1f8:	e13ffe15 	stw	r4,-8(fp)
8113b1fc:	e17fff15 	stw	r5,-4(fp)
    OS_FLAGS   flags;
#if OS_CRITICAL_METHOD == 3                       /* Allocate storage for CPU status register          */
    OS_CPU_SR  cpu_sr = 0;
8113b200:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
8113b204:	e0bfff17 	ldw	r2,-4(fp)
8113b208:	1000021e 	bne	r2,zero,8113b214 <OSFlagQuery+0x30>
        return ((OS_FLAGS)0);
8113b20c:	0005883a 	mov	r2,zero
8113b210:	00002306 	br	8113b2a0 <OSFlagQuery+0xbc>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
8113b214:	e0bffe17 	ldw	r2,-8(fp)
8113b218:	1000051e 	bne	r2,zero,8113b230 <OSFlagQuery+0x4c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113b21c:	e0bfff17 	ldw	r2,-4(fp)
8113b220:	00c01b84 	movi	r3,110
8113b224:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113b228:	0005883a 	mov	r2,zero
8113b22c:	00001c06 	br	8113b2a0 <OSFlagQuery+0xbc>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
8113b230:	e0bffe17 	ldw	r2,-8(fp)
8113b234:	10800003 	ldbu	r2,0(r2)
8113b238:	10803fcc 	andi	r2,r2,255
8113b23c:	10800160 	cmpeqi	r2,r2,5
8113b240:	1000051e 	bne	r2,zero,8113b258 <OSFlagQuery+0x74>
        *perr = OS_ERR_EVENT_TYPE;
8113b244:	e0bfff17 	ldw	r2,-4(fp)
8113b248:	00c00044 	movi	r3,1
8113b24c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113b250:	0005883a 	mov	r2,zero
8113b254:	00001206 	br	8113b2a0 <OSFlagQuery+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b258:	0005303a 	rdctl	r2,status
8113b25c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b260:	e0fffc17 	ldw	r3,-16(fp)
8113b264:	00bfff84 	movi	r2,-2
8113b268:	1884703a 	and	r2,r3,r2
8113b26c:	1001703a 	wrctl	status,r2
  
  return context;
8113b270:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113b274:	e0bffa15 	stw	r2,-24(fp)
    flags = pgrp->OSFlagFlags;
8113b278:	e0bffe17 	ldw	r2,-8(fp)
8113b27c:	1080020b 	ldhu	r2,8(r2)
8113b280:	e0bffb0d 	sth	r2,-20(fp)
8113b284:	e0bffa17 	ldw	r2,-24(fp)
8113b288:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b28c:	e0bffd17 	ldw	r2,-12(fp)
8113b290:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113b294:	e0bfff17 	ldw	r2,-4(fp)
8113b298:	10000005 	stb	zero,0(r2)
    return (flags);                               /* Return the current value of the event flags       */
8113b29c:	e0bffb0b 	ldhu	r2,-20(fp)
}
8113b2a0:	e037883a 	mov	sp,fp
8113b2a4:	df000017 	ldw	fp,0(sp)
8113b2a8:	dec00104 	addi	sp,sp,4
8113b2ac:	f800283a 	ret

8113b2b0 <OS_FlagBlock>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
8113b2b0:	defff804 	addi	sp,sp,-32
8113b2b4:	de00012e 	bgeu	sp,et,8113b2bc <OS_FlagBlock+0xc>
8113b2b8:	003b68fa 	trap	3
8113b2bc:	df000715 	stw	fp,28(sp)
8113b2c0:	df000704 	addi	fp,sp,28
8113b2c4:	e13ffb15 	stw	r4,-20(fp)
8113b2c8:	e17ffc15 	stw	r5,-16(fp)
8113b2cc:	3009883a 	mov	r4,r6
8113b2d0:	3807883a 	mov	r3,r7
8113b2d4:	e0800117 	ldw	r2,4(fp)
8113b2d8:	e13ffd0d 	sth	r4,-12(fp)
8113b2dc:	e0fffe05 	stb	r3,-8(fp)
8113b2e0:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
8113b2e4:	d0a0a217 	ldw	r2,-32120(gp)
8113b2e8:	d0e0a217 	ldw	r3,-32120(gp)
8113b2ec:	18c00c03 	ldbu	r3,48(r3)
8113b2f0:	18c00814 	ori	r3,r3,32
8113b2f4:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
8113b2f8:	d0a0a217 	ldw	r2,-32120(gp)
8113b2fc:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
8113b300:	d0a0a217 	ldw	r2,-32120(gp)
8113b304:	e0ffff0b 	ldhu	r3,-4(fp)
8113b308:	10c00b8d 	sth	r3,46(r2)
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
8113b30c:	d0a0a217 	ldw	r2,-32120(gp)
8113b310:	e0fffc17 	ldw	r3,-16(fp)
8113b314:	10c00a15 	stw	r3,40(r2)
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
8113b318:	e0bffc17 	ldw	r2,-16(fp)
8113b31c:	e0fffd0b 	ldhu	r3,-12(fp)
8113b320:	10c0040d 	sth	r3,16(r2)
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
8113b324:	e0bffc17 	ldw	r2,-16(fp)
8113b328:	e0fffe03 	ldbu	r3,-8(fp)
8113b32c:	10c00485 	stb	r3,18(r2)
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
8113b330:	d0e0a217 	ldw	r3,-32120(gp)
8113b334:	e0bffc17 	ldw	r2,-16(fp)
8113b338:	10c00215 	stw	r3,8(r2)
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
8113b33c:	e0bffb17 	ldw	r2,-20(fp)
8113b340:	10c00117 	ldw	r3,4(r2)
8113b344:	e0bffc17 	ldw	r2,-16(fp)
8113b348:	10c00015 	stw	r3,0(r2)
    pnode->OSFlagNodePrev     = (void *)0;
8113b34c:	e0bffc17 	ldw	r2,-16(fp)
8113b350:	10000115 	stw	zero,4(r2)
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
8113b354:	e0bffc17 	ldw	r2,-16(fp)
8113b358:	e0fffb17 	ldw	r3,-20(fp)
8113b35c:	10c00315 	stw	r3,12(r2)
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
8113b360:	e0bffb17 	ldw	r2,-20(fp)
8113b364:	10800117 	ldw	r2,4(r2)
8113b368:	e0bff915 	stw	r2,-28(fp)
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
8113b36c:	e0bff917 	ldw	r2,-28(fp)
8113b370:	10000326 	beq	r2,zero,8113b380 <OS_FlagBlock+0xd0>
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
8113b374:	e0bff917 	ldw	r2,-28(fp)
8113b378:	e0fffc17 	ldw	r3,-16(fp)
8113b37c:	10c00115 	stw	r3,4(r2)
    }
    pgrp->OSFlagWaitList = (void *)pnode;
8113b380:	e0bffb17 	ldw	r2,-20(fp)
8113b384:	e0fffc17 	ldw	r3,-16(fp)
8113b388:	10c00115 	stw	r3,4(r2)

    y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
8113b38c:	d0a0a217 	ldw	r2,-32120(gp)
8113b390:	10800d03 	ldbu	r2,52(r2)
8113b394:	e0bffa05 	stb	r2,-24(fp)
    OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
8113b398:	e0fffa03 	ldbu	r3,-24(fp)
8113b39c:	e13ffa03 	ldbu	r4,-24(fp)
8113b3a0:	d0a09e44 	addi	r2,gp,-32135
8113b3a4:	2085883a 	add	r2,r4,r2
8113b3a8:	10800003 	ldbu	r2,0(r2)
8113b3ac:	1009883a 	mov	r4,r2
8113b3b0:	d0a0a217 	ldw	r2,-32120(gp)
8113b3b4:	10800d43 	ldbu	r2,53(r2)
8113b3b8:	0084303a 	nor	r2,zero,r2
8113b3bc:	2084703a 	and	r2,r4,r2
8113b3c0:	1009883a 	mov	r4,r2
8113b3c4:	d0a09e44 	addi	r2,gp,-32135
8113b3c8:	1885883a 	add	r2,r3,r2
8113b3cc:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0x00) {
8113b3d0:	e0fffa03 	ldbu	r3,-24(fp)
8113b3d4:	d0a09e44 	addi	r2,gp,-32135
8113b3d8:	1885883a 	add	r2,r3,r2
8113b3dc:	10800003 	ldbu	r2,0(r2)
8113b3e0:	10803fcc 	andi	r2,r2,255
8113b3e4:	1000071e 	bne	r2,zero,8113b404 <OS_FlagBlock+0x154>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
8113b3e8:	d0a0a217 	ldw	r2,-32120(gp)
8113b3ec:	10800d83 	ldbu	r2,54(r2)
8113b3f0:	0084303a 	nor	r2,zero,r2
8113b3f4:	1007883a 	mov	r3,r2
8113b3f8:	d0a09e03 	ldbu	r2,-32136(gp)
8113b3fc:	1884703a 	and	r2,r3,r2
8113b400:	d0a09e05 	stb	r2,-32136(gp)
    }
}
8113b404:	0001883a 	nop
8113b408:	e037883a 	mov	sp,fp
8113b40c:	df000017 	ldw	fp,0(sp)
8113b410:	dec00104 	addi	sp,sp,4
8113b414:	f800283a 	ret

8113b418 <OS_FlagInit>:
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
8113b418:	defffb04 	addi	sp,sp,-20
8113b41c:	de00012e 	bgeu	sp,et,8113b424 <OS_FlagInit+0xc>
8113b420:	003b68fa 	trap	3
8113b424:	dfc00415 	stw	ra,16(sp)
8113b428:	df000315 	stw	fp,12(sp)
8113b42c:	df000304 	addi	fp,sp,12
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
8113b430:	01421004 	movi	r5,2112
8113b434:	012045b4 	movhi	r4,33046
8113b438:	2119ec04 	addi	r4,r4,26544
8113b43c:	11395440 	call	81139544 <OS_MemClr>
    pgrp1 = &OSFlagTbl[0];
8113b440:	00a045b4 	movhi	r2,33046
8113b444:	1099ec04 	addi	r2,r2,26544
8113b448:	e0bffe15 	stw	r2,-8(fp)
    pgrp2 = &OSFlagTbl[1];
8113b44c:	00a045b4 	movhi	r2,33046
8113b450:	1099f704 	addi	r2,r2,26588
8113b454:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
8113b458:	e03ffd0d 	sth	zero,-12(fp)
8113b45c:	00001306 	br	8113b4ac <OS_FlagInit+0x94>
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
8113b460:	e0bffe17 	ldw	r2,-8(fp)
8113b464:	10000005 	stb	zero,0(r2)
        pgrp1->OSFlagWaitList = (void *)pgrp2;
8113b468:	e0bffe17 	ldw	r2,-8(fp)
8113b46c:	e0ffff17 	ldw	r3,-4(fp)
8113b470:	10c00115 	stw	r3,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
8113b474:	e0bffe17 	ldw	r2,-8(fp)
8113b478:	00c00fc4 	movi	r3,63
8113b47c:	10c00285 	stb	r3,10(r2)
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
8113b480:	e0bffe17 	ldw	r2,-8(fp)
8113b484:	100002c5 	stb	zero,11(r2)
#endif
        pgrp1++;
8113b488:	e0bffe17 	ldw	r2,-8(fp)
8113b48c:	10800b04 	addi	r2,r2,44
8113b490:	e0bffe15 	stw	r2,-8(fp)
        pgrp2++;
8113b494:	e0bfff17 	ldw	r2,-4(fp)
8113b498:	10800b04 	addi	r2,r2,44
8113b49c:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
8113b4a0:	e0bffd0b 	ldhu	r2,-12(fp)
8113b4a4:	10800044 	addi	r2,r2,1
8113b4a8:	e0bffd0d 	sth	r2,-12(fp)
8113b4ac:	e0bffd0b 	ldhu	r2,-12(fp)
8113b4b0:	10800bf0 	cmpltui	r2,r2,47
8113b4b4:	103fea1e 	bne	r2,zero,8113b460 <__reset+0xfb11b460>
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
8113b4b8:	e0bffe17 	ldw	r2,-8(fp)
8113b4bc:	10000005 	stb	zero,0(r2)
    pgrp1->OSFlagWaitList = (void *)0;
8113b4c0:	e0bffe17 	ldw	r2,-8(fp)
8113b4c4:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
8113b4c8:	e0bffe17 	ldw	r2,-8(fp)
8113b4cc:	00c00fc4 	movi	r3,63
8113b4d0:	10c00285 	stb	r3,10(r2)
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
8113b4d4:	e0bffe17 	ldw	r2,-8(fp)
8113b4d8:	100002c5 	stb	zero,11(r2)
#endif
    OSFlagFreeList        = &OSFlagTbl[0];
8113b4dc:	00a045b4 	movhi	r2,33046
8113b4e0:	1099ec04 	addi	r2,r2,26544
8113b4e4:	d0a0a615 	stw	r2,-32104(gp)
#endif
}
8113b4e8:	0001883a 	nop
8113b4ec:	e037883a 	mov	sp,fp
8113b4f0:	dfc00117 	ldw	ra,4(sp)
8113b4f4:	df000017 	ldw	fp,0(sp)
8113b4f8:	dec00204 	addi	sp,sp,8
8113b4fc:	f800283a 	ret

8113b500 <OS_FlagTaskRdy>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
8113b500:	defffa04 	addi	sp,sp,-24
8113b504:	de00012e 	bgeu	sp,et,8113b50c <OS_FlagTaskRdy+0xc>
8113b508:	003b68fa 	trap	3
8113b50c:	dfc00515 	stw	ra,20(sp)
8113b510:	df000415 	stw	fp,16(sp)
8113b514:	df000404 	addi	fp,sp,16
8113b518:	e13ffe15 	stw	r4,-8(fp)
8113b51c:	2805883a 	mov	r2,r5
8113b520:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
8113b524:	e0bffe17 	ldw	r2,-8(fp)
8113b528:	10800217 	ldw	r2,8(r2)
8113b52c:	e0bffd15 	stw	r2,-12(fp)
    ptcb->OSTCBDly       = 0;
8113b530:	e0bffd17 	ldw	r2,-12(fp)
8113b534:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBFlagsRdy  = flags_rdy;
8113b538:	e0bffd17 	ldw	r2,-12(fp)
8113b53c:	e0ffff0b 	ldhu	r3,-4(fp)
8113b540:	10c00b0d 	sth	r3,44(r2)
    ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
8113b544:	e0bffd17 	ldw	r2,-12(fp)
8113b548:	10c00c03 	ldbu	r3,48(r2)
8113b54c:	00bff7c4 	movi	r2,-33
8113b550:	1884703a 	and	r2,r3,r2
8113b554:	1007883a 	mov	r3,r2
8113b558:	e0bffd17 	ldw	r2,-12(fp)
8113b55c:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
8113b560:	e0bffd17 	ldw	r2,-12(fp)
8113b564:	10000c45 	stb	zero,49(r2)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
8113b568:	e0bffd17 	ldw	r2,-12(fp)
8113b56c:	10800c03 	ldbu	r2,48(r2)
8113b570:	10803fcc 	andi	r2,r2,255
8113b574:	1000181e 	bne	r2,zero,8113b5d8 <OS_FlagTaskRdy+0xd8>
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
8113b578:	e0bffd17 	ldw	r2,-12(fp)
8113b57c:	10c00d83 	ldbu	r3,54(r2)
8113b580:	d0a09e03 	ldbu	r2,-32136(gp)
8113b584:	1884b03a 	or	r2,r3,r2
8113b588:	d0a09e05 	stb	r2,-32136(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113b58c:	e0bffd17 	ldw	r2,-12(fp)
8113b590:	10800d03 	ldbu	r2,52(r2)
8113b594:	10c03fcc 	andi	r3,r2,255
8113b598:	e0bffd17 	ldw	r2,-12(fp)
8113b59c:	10800d03 	ldbu	r2,52(r2)
8113b5a0:	11003fcc 	andi	r4,r2,255
8113b5a4:	d0a09e44 	addi	r2,gp,-32135
8113b5a8:	2085883a 	add	r2,r4,r2
8113b5ac:	11000003 	ldbu	r4,0(r2)
8113b5b0:	e0bffd17 	ldw	r2,-12(fp)
8113b5b4:	10800d43 	ldbu	r2,53(r2)
8113b5b8:	2084b03a 	or	r2,r4,r2
8113b5bc:	1009883a 	mov	r4,r2
8113b5c0:	d0a09e44 	addi	r2,gp,-32135
8113b5c4:	1885883a 	add	r2,r3,r2
8113b5c8:	11000005 	stb	r4,0(r2)
        sched                   = OS_TRUE;
8113b5cc:	00800044 	movi	r2,1
8113b5d0:	e0bffc05 	stb	r2,-16(fp)
8113b5d4:	00000106 	br	8113b5dc <OS_FlagTaskRdy+0xdc>
    } else {
        sched                   = OS_FALSE;
8113b5d8:	e03ffc05 	stb	zero,-16(fp)
    }
    OS_FlagUnlink(pnode);
8113b5dc:	e13ffe17 	ldw	r4,-8(fp)
8113b5e0:	113b5fc0 	call	8113b5fc <OS_FlagUnlink>
    return (sched);
8113b5e4:	e0bffc03 	ldbu	r2,-16(fp)
}
8113b5e8:	e037883a 	mov	sp,fp
8113b5ec:	dfc00117 	ldw	ra,4(sp)
8113b5f0:	df000017 	ldw	fp,0(sp)
8113b5f4:	dec00204 	addi	sp,sp,8
8113b5f8:	f800283a 	ret

8113b5fc <OS_FlagUnlink>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
{
8113b5fc:	defffa04 	addi	sp,sp,-24
8113b600:	de00012e 	bgeu	sp,et,8113b608 <OS_FlagUnlink+0xc>
8113b604:	003b68fa 	trap	3
8113b608:	df000515 	stw	fp,20(sp)
8113b60c:	df000504 	addi	fp,sp,20
8113b610:	e13fff15 	stw	r4,-4(fp)
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
8113b614:	e0bfff17 	ldw	r2,-4(fp)
8113b618:	10800117 	ldw	r2,4(r2)
8113b61c:	e0bffb15 	stw	r2,-20(fp)
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
8113b620:	e0bfff17 	ldw	r2,-4(fp)
8113b624:	10800017 	ldw	r2,0(r2)
8113b628:	e0bffc15 	stw	r2,-16(fp)
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
8113b62c:	e0bffb17 	ldw	r2,-20(fp)
8113b630:	10000b1e 	bne	r2,zero,8113b660 <OS_FlagUnlink+0x64>
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
8113b634:	e0bfff17 	ldw	r2,-4(fp)
8113b638:	10800317 	ldw	r2,12(r2)
8113b63c:	e0bffd15 	stw	r2,-12(fp)
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
8113b640:	e0bffd17 	ldw	r2,-12(fp)
8113b644:	e0fffc17 	ldw	r3,-16(fp)
8113b648:	10c00115 	stw	r3,4(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {
8113b64c:	e0bffc17 	ldw	r2,-16(fp)
8113b650:	10000b26 	beq	r2,zero,8113b680 <OS_FlagUnlink+0x84>
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
8113b654:	e0bffc17 	ldw	r2,-16(fp)
8113b658:	10000115 	stw	zero,4(r2)
8113b65c:	00000806 	br	8113b680 <OS_FlagUnlink+0x84>
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
8113b660:	e0bffb17 	ldw	r2,-20(fp)
8113b664:	e0fffc17 	ldw	r3,-16(fp)
8113b668:	10c00015 	stw	r3,0(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
8113b66c:	e0bffc17 	ldw	r2,-16(fp)
8113b670:	10000326 	beq	r2,zero,8113b680 <OS_FlagUnlink+0x84>
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
8113b674:	e0bffc17 	ldw	r2,-16(fp)
8113b678:	e0fffb17 	ldw	r3,-20(fp)
8113b67c:	10c00115 	stw	r3,4(r2)
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
8113b680:	e0bfff17 	ldw	r2,-4(fp)
8113b684:	10800217 	ldw	r2,8(r2)
8113b688:	e0bffe15 	stw	r2,-8(fp)
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
8113b68c:	e0bffe17 	ldw	r2,-8(fp)
8113b690:	10000a15 	stw	zero,40(r2)
#endif
}
8113b694:	0001883a 	nop
8113b698:	e037883a 	mov	sp,fp
8113b69c:	df000017 	ldw	fp,0(sp)
8113b6a0:	dec00104 	addi	sp,sp,4
8113b6a4:	f800283a 	ret

8113b6a8 <OSMemCreate>:
*                              free partition is available.
*********************************************************************************************************
*/

OS_MEM  *OSMemCreate (void *addr, INT32U nblks, INT32U blksize, INT8U *perr)
{
8113b6a8:	defff404 	addi	sp,sp,-48
8113b6ac:	de00012e 	bgeu	sp,et,8113b6b4 <OSMemCreate+0xc>
8113b6b0:	003b68fa 	trap	3
8113b6b4:	df000b15 	stw	fp,44(sp)
8113b6b8:	df000b04 	addi	fp,sp,44
8113b6bc:	e13ffc15 	stw	r4,-16(fp)
8113b6c0:	e17ffd15 	stw	r5,-12(fp)
8113b6c4:	e1bffe15 	stw	r6,-8(fp)
8113b6c8:	e1ffff15 	stw	r7,-4(fp)
    OS_MEM    *pmem;
    INT8U     *pblk;
    void     **plink;
    INT32U     i;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113b6cc:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0              
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113b6d0:	e0bfff17 	ldw	r2,-4(fp)
8113b6d4:	1000021e 	bne	r2,zero,8113b6e0 <OSMemCreate+0x38>
        return ((OS_MEM *)0);
8113b6d8:	0005883a 	mov	r2,zero
8113b6dc:	00006506 	br	8113b874 <OSMemCreate+0x1cc>
    }
    if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
8113b6e0:	e0bffc17 	ldw	r2,-16(fp)
8113b6e4:	1000051e 	bne	r2,zero,8113b6fc <OSMemCreate+0x54>
        *perr = OS_ERR_MEM_INVALID_ADDR;
8113b6e8:	e0bfff17 	ldw	r2,-4(fp)
8113b6ec:	00c01884 	movi	r3,98
8113b6f0:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113b6f4:	0005883a 	mov	r2,zero
8113b6f8:	00005e06 	br	8113b874 <OSMemCreate+0x1cc>
    }
    if (((INT32U)addr & (sizeof(void *) - 1)) != 0){  /* Must be pointer size aligned                  */
8113b6fc:	e0bffc17 	ldw	r2,-16(fp)
8113b700:	108000cc 	andi	r2,r2,3
8113b704:	10000526 	beq	r2,zero,8113b71c <OSMemCreate+0x74>
        *perr = OS_ERR_MEM_INVALID_ADDR;
8113b708:	e0bfff17 	ldw	r2,-4(fp)
8113b70c:	00c01884 	movi	r3,98
8113b710:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113b714:	0005883a 	mov	r2,zero
8113b718:	00005606 	br	8113b874 <OSMemCreate+0x1cc>
    }
    if (nblks < 2) {                                  /* Must have at least 2 blocks per partition     */
8113b71c:	e0bffd17 	ldw	r2,-12(fp)
8113b720:	108000a8 	cmpgeui	r2,r2,2
8113b724:	1000051e 	bne	r2,zero,8113b73c <OSMemCreate+0x94>
        *perr = OS_ERR_MEM_INVALID_BLKS;
8113b728:	e0bfff17 	ldw	r2,-4(fp)
8113b72c:	00c016c4 	movi	r3,91
8113b730:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113b734:	0005883a 	mov	r2,zero
8113b738:	00004e06 	br	8113b874 <OSMemCreate+0x1cc>
    }
    if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
8113b73c:	e0bffe17 	ldw	r2,-8(fp)
8113b740:	10800128 	cmpgeui	r2,r2,4
8113b744:	1000051e 	bne	r2,zero,8113b75c <OSMemCreate+0xb4>
        *perr = OS_ERR_MEM_INVALID_SIZE;
8113b748:	e0bfff17 	ldw	r2,-4(fp)
8113b74c:	00c01704 	movi	r3,92
8113b750:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113b754:	0005883a 	mov	r2,zero
8113b758:	00004606 	br	8113b874 <OSMemCreate+0x1cc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b75c:	0005303a 	rdctl	r2,status
8113b760:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b764:	e0fffb17 	ldw	r3,-20(fp)
8113b768:	00bfff84 	movi	r2,-2
8113b76c:	1884703a 	and	r2,r3,r2
8113b770:	1001703a 	wrctl	status,r2
  
  return context;
8113b774:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113b778:	e0bff815 	stw	r2,-32(fp)
    pmem = OSMemFreeList;                             /* Get next free memory partition                */
8113b77c:	d0a09b17 	ldw	r2,-32148(gp)
8113b780:	e0bffa15 	stw	r2,-24(fp)
    if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
8113b784:	d0a09b17 	ldw	r2,-32148(gp)
8113b788:	10000326 	beq	r2,zero,8113b798 <OSMemCreate+0xf0>
        OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
8113b78c:	d0a09b17 	ldw	r2,-32148(gp)
8113b790:	10800117 	ldw	r2,4(r2)
8113b794:	d0a09b15 	stw	r2,-32148(gp)
8113b798:	e0bff817 	ldw	r2,-32(fp)
8113b79c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b7a0:	e0bff917 	ldw	r2,-28(fp)
8113b7a4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
8113b7a8:	e0bffa17 	ldw	r2,-24(fp)
8113b7ac:	1000051e 	bne	r2,zero,8113b7c4 <OSMemCreate+0x11c>
        *perr = OS_ERR_MEM_INVALID_PART;
8113b7b0:	e0bfff17 	ldw	r2,-4(fp)
8113b7b4:	00c01684 	movi	r3,90
8113b7b8:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113b7bc:	0005883a 	mov	r2,zero
8113b7c0:	00002c06 	br	8113b874 <OSMemCreate+0x1cc>
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
8113b7c4:	e0bffc17 	ldw	r2,-16(fp)
8113b7c8:	e0bff615 	stw	r2,-40(fp)
    pblk  = (INT8U *)((INT32U)addr + blksize);
8113b7cc:	e0fffc17 	ldw	r3,-16(fp)
8113b7d0:	e0bffe17 	ldw	r2,-8(fp)
8113b7d4:	1885883a 	add	r2,r3,r2
8113b7d8:	e0bff515 	stw	r2,-44(fp)
    for (i = 0; i < (nblks - 1); i++) {
8113b7dc:	e03ff715 	stw	zero,-36(fp)
8113b7e0:	00000c06 	br	8113b814 <OSMemCreate+0x16c>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
8113b7e4:	e0bff617 	ldw	r2,-40(fp)
8113b7e8:	e0fff517 	ldw	r3,-44(fp)
8113b7ec:	10c00015 	stw	r3,0(r2)
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
8113b7f0:	e0bff517 	ldw	r2,-44(fp)
8113b7f4:	e0bff615 	stw	r2,-40(fp)
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
8113b7f8:	e0fff517 	ldw	r3,-44(fp)
8113b7fc:	e0bffe17 	ldw	r2,-8(fp)
8113b800:	1885883a 	add	r2,r3,r2
8113b804:	e0bff515 	stw	r2,-44(fp)
        *perr = OS_ERR_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0; i < (nblks - 1); i++) {
8113b808:	e0bff717 	ldw	r2,-36(fp)
8113b80c:	10800044 	addi	r2,r2,1
8113b810:	e0bff715 	stw	r2,-36(fp)
8113b814:	e0bffd17 	ldw	r2,-12(fp)
8113b818:	10bfffc4 	addi	r2,r2,-1
8113b81c:	e0fff717 	ldw	r3,-36(fp)
8113b820:	18bff036 	bltu	r3,r2,8113b7e4 <__reset+0xfb11b7e4>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
    }
    *plink              = (void *)0;                  /* Last memory block points to NULL              */
8113b824:	e0bff617 	ldw	r2,-40(fp)
8113b828:	10000015 	stw	zero,0(r2)
    pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
8113b82c:	e0bffa17 	ldw	r2,-24(fp)
8113b830:	e0fffc17 	ldw	r3,-16(fp)
8113b834:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
8113b838:	e0bffa17 	ldw	r2,-24(fp)
8113b83c:	e0fffc17 	ldw	r3,-16(fp)
8113b840:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
8113b844:	e0bffa17 	ldw	r2,-24(fp)
8113b848:	e0fffd17 	ldw	r3,-12(fp)
8113b84c:	10c00415 	stw	r3,16(r2)
    pmem->OSMemNBlks    = nblks;
8113b850:	e0bffa17 	ldw	r2,-24(fp)
8113b854:	e0fffd17 	ldw	r3,-12(fp)
8113b858:	10c00315 	stw	r3,12(r2)
    pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
8113b85c:	e0bffa17 	ldw	r2,-24(fp)
8113b860:	e0fffe17 	ldw	r3,-8(fp)
8113b864:	10c00215 	stw	r3,8(r2)
    *perr               = OS_ERR_NONE;
8113b868:	e0bfff17 	ldw	r2,-4(fp)
8113b86c:	10000005 	stb	zero,0(r2)
    return (pmem);
8113b870:	e0bffa17 	ldw	r2,-24(fp)
}
8113b874:	e037883a 	mov	sp,fp
8113b878:	df000017 	ldw	fp,0(sp)
8113b87c:	dec00104 	addi	sp,sp,4
8113b880:	f800283a 	ret

8113b884 <OSMemGet>:
*               A pointer to NULL if an error is detected
*********************************************************************************************************
*/

void  *OSMemGet (OS_MEM *pmem, INT8U *perr)
{
8113b884:	defff804 	addi	sp,sp,-32
8113b888:	de00012e 	bgeu	sp,et,8113b890 <OSMemGet+0xc>
8113b88c:	003b68fa 	trap	3
8113b890:	df000715 	stw	fp,28(sp)
8113b894:	df000704 	addi	fp,sp,28
8113b898:	e13ffe15 	stw	r4,-8(fp)
8113b89c:	e17fff15 	stw	r5,-4(fp)
    void      *pblk;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113b8a0:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113b8a4:	e0bfff17 	ldw	r2,-4(fp)
8113b8a8:	1000021e 	bne	r2,zero,8113b8b4 <OSMemGet+0x30>
        return ((void *)0);
8113b8ac:	0005883a 	mov	r2,zero
8113b8b0:	00002e06 	br	8113b96c <OSMemGet+0xe8>
    }
    if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
8113b8b4:	e0bffe17 	ldw	r2,-8(fp)
8113b8b8:	1000051e 	bne	r2,zero,8113b8d0 <OSMemGet+0x4c>
        *perr = OS_ERR_MEM_INVALID_PMEM;
8113b8bc:	e0bfff17 	ldw	r2,-4(fp)
8113b8c0:	00c01804 	movi	r3,96
8113b8c4:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113b8c8:	0005883a 	mov	r2,zero
8113b8cc:	00002706 	br	8113b96c <OSMemGet+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b8d0:	0005303a 	rdctl	r2,status
8113b8d4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b8d8:	e0fffd17 	ldw	r3,-12(fp)
8113b8dc:	00bfff84 	movi	r2,-2
8113b8e0:	1884703a 	and	r2,r3,r2
8113b8e4:	1001703a 	wrctl	status,r2
  
  return context;
8113b8e8:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113b8ec:	e0bff915 	stw	r2,-28(fp)
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
8113b8f0:	e0bffe17 	ldw	r2,-8(fp)
8113b8f4:	10800417 	ldw	r2,16(r2)
8113b8f8:	10001426 	beq	r2,zero,8113b94c <OSMemGet+0xc8>
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
8113b8fc:	e0bffe17 	ldw	r2,-8(fp)
8113b900:	10800117 	ldw	r2,4(r2)
8113b904:	e0bffb15 	stw	r2,-20(fp)
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
8113b908:	e0bffb17 	ldw	r2,-20(fp)
8113b90c:	10c00017 	ldw	r3,0(r2)
8113b910:	e0bffe17 	ldw	r2,-8(fp)
8113b914:	10c00115 	stw	r3,4(r2)
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
8113b918:	e0bffe17 	ldw	r2,-8(fp)
8113b91c:	10800417 	ldw	r2,16(r2)
8113b920:	10ffffc4 	addi	r3,r2,-1
8113b924:	e0bffe17 	ldw	r2,-8(fp)
8113b928:	10c00415 	stw	r3,16(r2)
8113b92c:	e0bff917 	ldw	r2,-28(fp)
8113b930:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b934:	e0bffa17 	ldw	r2,-24(fp)
8113b938:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;                          /*      No error                                 */
8113b93c:	e0bfff17 	ldw	r2,-4(fp)
8113b940:	10000005 	stb	zero,0(r2)
        return (pblk);                                /*      Return memory block to caller            */
8113b944:	e0bffb17 	ldw	r2,-20(fp)
8113b948:	00000806 	br	8113b96c <OSMemGet+0xe8>
8113b94c:	e0bff917 	ldw	r2,-28(fp)
8113b950:	e0bffc15 	stw	r2,-16(fp)
8113b954:	e0bffc17 	ldw	r2,-16(fp)
8113b958:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
8113b95c:	e0bfff17 	ldw	r2,-4(fp)
8113b960:	00c01744 	movi	r3,93
8113b964:	10c00005 	stb	r3,0(r2)
    return ((void *)0);                               /*      Return NULL pointer to caller            */
8113b968:	0005883a 	mov	r2,zero
}
8113b96c:	e037883a 	mov	sp,fp
8113b970:	df000017 	ldw	fp,0(sp)
8113b974:	dec00104 	addi	sp,sp,4
8113b978:	f800283a 	ret

8113b97c <OSMemNameGet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
INT8U  OSMemNameGet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
8113b97c:	defff704 	addi	sp,sp,-36
8113b980:	de00012e 	bgeu	sp,et,8113b988 <OSMemNameGet+0xc>
8113b984:	003b68fa 	trap	3
8113b988:	dfc00815 	stw	ra,32(sp)
8113b98c:	df000715 	stw	fp,28(sp)
8113b990:	df000704 	addi	fp,sp,28
8113b994:	e13ffd15 	stw	r4,-12(fp)
8113b998:	e17ffe15 	stw	r5,-8(fp)
8113b99c:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113b9a0:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113b9a4:	e0bfff17 	ldw	r2,-4(fp)
8113b9a8:	1000021e 	bne	r2,zero,8113b9b4 <OSMemNameGet+0x38>
        return (0);
8113b9ac:	0005883a 	mov	r2,zero
8113b9b0:	00002b06 	br	8113ba60 <OSMemNameGet+0xe4>
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
8113b9b4:	e0bffd17 	ldw	r2,-12(fp)
8113b9b8:	1000051e 	bne	r2,zero,8113b9d0 <OSMemNameGet+0x54>
        *perr = OS_ERR_MEM_INVALID_PMEM;
8113b9bc:	e0bfff17 	ldw	r2,-4(fp)
8113b9c0:	00c01804 	movi	r3,96
8113b9c4:	10c00005 	stb	r3,0(r2)
        return (0);
8113b9c8:	0005883a 	mov	r2,zero
8113b9cc:	00002406 	br	8113ba60 <OSMemNameGet+0xe4>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8113b9d0:	e0bffe17 	ldw	r2,-8(fp)
8113b9d4:	1000051e 	bne	r2,zero,8113b9ec <OSMemNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
8113b9d8:	e0bfff17 	ldw	r2,-4(fp)
8113b9dc:	00c00304 	movi	r3,12
8113b9e0:	10c00005 	stb	r3,0(r2)
        return (0);
8113b9e4:	0005883a 	mov	r2,zero
8113b9e8:	00001d06 	br	8113ba60 <OSMemNameGet+0xe4>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113b9ec:	d0a0a103 	ldbu	r2,-32124(gp)
8113b9f0:	10803fcc 	andi	r2,r2,255
8113b9f4:	10000526 	beq	r2,zero,8113ba0c <OSMemNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
8113b9f8:	e0bfff17 	ldw	r2,-4(fp)
8113b9fc:	00c00444 	movi	r3,17
8113ba00:	10c00005 	stb	r3,0(r2)
        return (0);
8113ba04:	0005883a 	mov	r2,zero
8113ba08:	00001506 	br	8113ba60 <OSMemNameGet+0xe4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ba0c:	0005303a 	rdctl	r2,status
8113ba10:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ba14:	e0fffb17 	ldw	r3,-20(fp)
8113ba18:	00bfff84 	movi	r2,-2
8113ba1c:	1884703a 	and	r2,r3,r2
8113ba20:	1001703a 	wrctl	status,r2
  
  return context;
8113ba24:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
8113ba28:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pmem->OSMemName);  /* Copy name from OS_MEM                              */
8113ba2c:	e0bffd17 	ldw	r2,-12(fp)
8113ba30:	10800504 	addi	r2,r2,20
8113ba34:	100b883a 	mov	r5,r2
8113ba38:	e13ffe17 	ldw	r4,-8(fp)
8113ba3c:	11397640 	call	81139764 <OS_StrCopy>
8113ba40:	e0bffa05 	stb	r2,-24(fp)
8113ba44:	e0bff917 	ldw	r2,-28(fp)
8113ba48:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ba4c:	e0bffc17 	ldw	r2,-16(fp)
8113ba50:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113ba54:	e0bfff17 	ldw	r2,-4(fp)
8113ba58:	10000005 	stb	zero,0(r2)
    return (len);
8113ba5c:	e0bffa03 	ldbu	r2,-24(fp)
}
8113ba60:	e037883a 	mov	sp,fp
8113ba64:	dfc00117 	ldw	ra,4(sp)
8113ba68:	df000017 	ldw	fp,0(sp)
8113ba6c:	dec00204 	addi	sp,sp,8
8113ba70:	f800283a 	ret

8113ba74 <OSMemNameSet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
void  OSMemNameSet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
8113ba74:	defff604 	addi	sp,sp,-40
8113ba78:	de00012e 	bgeu	sp,et,8113ba80 <OSMemNameSet+0xc>
8113ba7c:	003b68fa 	trap	3
8113ba80:	dfc00915 	stw	ra,36(sp)
8113ba84:	df000815 	stw	fp,32(sp)
8113ba88:	df000804 	addi	fp,sp,32
8113ba8c:	e13ffd15 	stw	r4,-12(fp)
8113ba90:	e17ffe15 	stw	r5,-8(fp)
8113ba94:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113ba98:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113ba9c:	e0bfff17 	ldw	r2,-4(fp)
8113baa0:	10003526 	beq	r2,zero,8113bb78 <OSMemNameSet+0x104>
        return;
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
8113baa4:	e0bffd17 	ldw	r2,-12(fp)
8113baa8:	1000041e 	bne	r2,zero,8113babc <OSMemNameSet+0x48>
        *perr = OS_ERR_MEM_INVALID_PMEM;
8113baac:	e0bfff17 	ldw	r2,-4(fp)
8113bab0:	00c01804 	movi	r3,96
8113bab4:	10c00005 	stb	r3,0(r2)
        return;
8113bab8:	00003006 	br	8113bb7c <OSMemNameSet+0x108>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8113babc:	e0bffe17 	ldw	r2,-8(fp)
8113bac0:	1000041e 	bne	r2,zero,8113bad4 <OSMemNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
8113bac4:	e0bfff17 	ldw	r2,-4(fp)
8113bac8:	00c00304 	movi	r3,12
8113bacc:	10c00005 	stb	r3,0(r2)
        return;
8113bad0:	00002a06 	br	8113bb7c <OSMemNameSet+0x108>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113bad4:	d0a0a103 	ldbu	r2,-32124(gp)
8113bad8:	10803fcc 	andi	r2,r2,255
8113badc:	10000426 	beq	r2,zero,8113baf0 <OSMemNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
8113bae0:	e0bfff17 	ldw	r2,-4(fp)
8113bae4:	00c00484 	movi	r3,18
8113bae8:	10c00005 	stb	r3,0(r2)
        return;
8113baec:	00002306 	br	8113bb7c <OSMemNameSet+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113baf0:	0005303a 	rdctl	r2,status
8113baf4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113baf8:	e0fffc17 	ldw	r3,-16(fp)
8113bafc:	00bfff84 	movi	r2,-2
8113bb00:	1884703a 	and	r2,r3,r2
8113bb04:	1001703a 	wrctl	status,r2
  
  return context;
8113bb08:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113bb0c:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
8113bb10:	e13ffe17 	ldw	r4,-8(fp)
8113bb14:	11397e00 	call	811397e0 <OS_StrLen>
8113bb18:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_MEM_NAME_SIZE - 1)) {          /* No                                                 */
8113bb1c:	e0bffa03 	ldbu	r2,-24(fp)
8113bb20:	10800830 	cmpltui	r2,r2,32
8113bb24:	1000081e 	bne	r2,zero,8113bb48 <OSMemNameSet+0xd4>
8113bb28:	e0bff817 	ldw	r2,-32(fp)
8113bb2c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113bb30:	e0bff917 	ldw	r2,-28(fp)
8113bb34:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_MEM_NAME_TOO_LONG;
8113bb38:	e0bfff17 	ldw	r2,-4(fp)
8113bb3c:	00c018c4 	movi	r3,99
8113bb40:	10c00005 	stb	r3,0(r2)
        return;
8113bb44:	00000d06 	br	8113bb7c <OSMemNameSet+0x108>
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
8113bb48:	e0bffd17 	ldw	r2,-12(fp)
8113bb4c:	10800504 	addi	r2,r2,20
8113bb50:	e17ffe17 	ldw	r5,-8(fp)
8113bb54:	1009883a 	mov	r4,r2
8113bb58:	11397640 	call	81139764 <OS_StrCopy>
8113bb5c:	e0bff817 	ldw	r2,-32(fp)
8113bb60:	e0bffb15 	stw	r2,-20(fp)
8113bb64:	e0bffb17 	ldw	r2,-20(fp)
8113bb68:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113bb6c:	e0bfff17 	ldw	r2,-4(fp)
8113bb70:	10000005 	stb	zero,0(r2)
8113bb74:	00000106 	br	8113bb7c <OSMemNameSet+0x108>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
8113bb78:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
8113bb7c:	e037883a 	mov	sp,fp
8113bb80:	dfc00117 	ldw	ra,4(sp)
8113bb84:	df000017 	ldw	fp,0(sp)
8113bb88:	dec00204 	addi	sp,sp,8
8113bb8c:	f800283a 	ret

8113bb90 <OSMemPut>:
*               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
*********************************************************************************************************
*/

INT8U  OSMemPut (OS_MEM *pmem, void *pblk)
{
8113bb90:	defff904 	addi	sp,sp,-28
8113bb94:	de00012e 	bgeu	sp,et,8113bb9c <OSMemPut+0xc>
8113bb98:	003b68fa 	trap	3
8113bb9c:	df000615 	stw	fp,24(sp)
8113bba0:	df000604 	addi	fp,sp,24
8113bba4:	e13ffe15 	stw	r4,-8(fp)
8113bba8:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113bbac:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
8113bbb0:	e0bffe17 	ldw	r2,-8(fp)
8113bbb4:	1000021e 	bne	r2,zero,8113bbc0 <OSMemPut+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
8113bbb8:	00801804 	movi	r2,96
8113bbbc:	00002806 	br	8113bc60 <OSMemPut+0xd0>
    }
    if (pblk == (void *)0) {                     /* Must release a valid block                         */
8113bbc0:	e0bfff17 	ldw	r2,-4(fp)
8113bbc4:	1000021e 	bne	r2,zero,8113bbd0 <OSMemPut+0x40>
        return (OS_ERR_MEM_INVALID_PBLK);
8113bbc8:	008017c4 	movi	r2,95
8113bbcc:	00002406 	br	8113bc60 <OSMemPut+0xd0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113bbd0:	0005303a 	rdctl	r2,status
8113bbd4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113bbd8:	e0fffd17 	ldw	r3,-12(fp)
8113bbdc:	00bfff84 	movi	r2,-2
8113bbe0:	1884703a 	and	r2,r3,r2
8113bbe4:	1001703a 	wrctl	status,r2
  
  return context;
8113bbe8:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113bbec:	e0bffa15 	stw	r2,-24(fp)
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
8113bbf0:	e0bffe17 	ldw	r2,-8(fp)
8113bbf4:	10c00417 	ldw	r3,16(r2)
8113bbf8:	e0bffe17 	ldw	r2,-8(fp)
8113bbfc:	10800317 	ldw	r2,12(r2)
8113bc00:	18800636 	bltu	r3,r2,8113bc1c <OSMemPut+0x8c>
8113bc04:	e0bffa17 	ldw	r2,-24(fp)
8113bc08:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113bc0c:	e0bffb17 	ldw	r2,-20(fp)
8113bc10:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_MEM_FULL);
8113bc14:	00801784 	movi	r2,94
8113bc18:	00001106 	br	8113bc60 <OSMemPut+0xd0>
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
8113bc1c:	e0bffe17 	ldw	r2,-8(fp)
8113bc20:	10c00117 	ldw	r3,4(r2)
8113bc24:	e0bfff17 	ldw	r2,-4(fp)
8113bc28:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = pblk;
8113bc2c:	e0bffe17 	ldw	r2,-8(fp)
8113bc30:	e0ffff17 	ldw	r3,-4(fp)
8113bc34:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
8113bc38:	e0bffe17 	ldw	r2,-8(fp)
8113bc3c:	10800417 	ldw	r2,16(r2)
8113bc40:	10c00044 	addi	r3,r2,1
8113bc44:	e0bffe17 	ldw	r2,-8(fp)
8113bc48:	10c00415 	stw	r3,16(r2)
8113bc4c:	e0bffa17 	ldw	r2,-24(fp)
8113bc50:	e0bffc15 	stw	r2,-16(fp)
8113bc54:	e0bffc17 	ldw	r2,-16(fp)
8113bc58:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
8113bc5c:	0005883a 	mov	r2,zero
}
8113bc60:	e037883a 	mov	sp,fp
8113bc64:	df000017 	ldw	fp,0(sp)
8113bc68:	dec00104 	addi	sp,sp,4
8113bc6c:	f800283a 	ret

8113bc70 <OSMemQuery>:
*********************************************************************************************************
*/

#if OS_MEM_QUERY_EN > 0
INT8U  OSMemQuery (OS_MEM *pmem, OS_MEM_DATA *p_mem_data)
{
8113bc70:	defffa04 	addi	sp,sp,-24
8113bc74:	de00012e 	bgeu	sp,et,8113bc7c <OSMemQuery+0xc>
8113bc78:	003b68fa 	trap	3
8113bc7c:	df000515 	stw	fp,20(sp)
8113bc80:	df000504 	addi	fp,sp,20
8113bc84:	e13ffe15 	stw	r4,-8(fp)
8113bc88:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113bc8c:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
8113bc90:	e0bffe17 	ldw	r2,-8(fp)
8113bc94:	1000021e 	bne	r2,zero,8113bca0 <OSMemQuery+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
8113bc98:	00801804 	movi	r2,96
8113bc9c:	00002c06 	br	8113bd50 <OSMemQuery+0xe0>
    }
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
8113bca0:	e0bfff17 	ldw	r2,-4(fp)
8113bca4:	1000021e 	bne	r2,zero,8113bcb0 <OSMemQuery+0x40>
        return (OS_ERR_MEM_INVALID_PDATA);
8113bca8:	00801844 	movi	r2,97
8113bcac:	00002806 	br	8113bd50 <OSMemQuery+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113bcb0:	0005303a 	rdctl	r2,status
8113bcb4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113bcb8:	e0fffc17 	ldw	r3,-16(fp)
8113bcbc:	00bfff84 	movi	r2,-2
8113bcc0:	1884703a 	and	r2,r3,r2
8113bcc4:	1001703a 	wrctl	status,r2
  
  return context;
8113bcc8:	e0bffc17 	ldw	r2,-16(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113bccc:	e0bffb15 	stw	r2,-20(fp)
    p_mem_data->OSAddr     = pmem->OSMemAddr;
8113bcd0:	e0bffe17 	ldw	r2,-8(fp)
8113bcd4:	10c00017 	ldw	r3,0(r2)
8113bcd8:	e0bfff17 	ldw	r2,-4(fp)
8113bcdc:	10c00015 	stw	r3,0(r2)
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
8113bce0:	e0bffe17 	ldw	r2,-8(fp)
8113bce4:	10c00117 	ldw	r3,4(r2)
8113bce8:	e0bfff17 	ldw	r2,-4(fp)
8113bcec:	10c00115 	stw	r3,4(r2)
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
8113bcf0:	e0bffe17 	ldw	r2,-8(fp)
8113bcf4:	10c00217 	ldw	r3,8(r2)
8113bcf8:	e0bfff17 	ldw	r2,-4(fp)
8113bcfc:	10c00215 	stw	r3,8(r2)
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
8113bd00:	e0bffe17 	ldw	r2,-8(fp)
8113bd04:	10c00317 	ldw	r3,12(r2)
8113bd08:	e0bfff17 	ldw	r2,-4(fp)
8113bd0c:	10c00315 	stw	r3,12(r2)
    p_mem_data->OSNFree    = pmem->OSMemNFree;
8113bd10:	e0bffe17 	ldw	r2,-8(fp)
8113bd14:	10c00417 	ldw	r3,16(r2)
8113bd18:	e0bfff17 	ldw	r2,-4(fp)
8113bd1c:	10c00415 	stw	r3,16(r2)
8113bd20:	e0bffb17 	ldw	r2,-20(fp)
8113bd24:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113bd28:	e0bffd17 	ldw	r2,-12(fp)
8113bd2c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
8113bd30:	e0bfff17 	ldw	r2,-4(fp)
8113bd34:	10c00317 	ldw	r3,12(r2)
8113bd38:	e0bfff17 	ldw	r2,-4(fp)
8113bd3c:	10800417 	ldw	r2,16(r2)
8113bd40:	1887c83a 	sub	r3,r3,r2
8113bd44:	e0bfff17 	ldw	r2,-4(fp)
8113bd48:	10c00515 	stw	r3,20(r2)
    return (OS_ERR_NONE);
8113bd4c:	0005883a 	mov	r2,zero
}
8113bd50:	e037883a 	mov	sp,fp
8113bd54:	df000017 	ldw	fp,0(sp)
8113bd58:	dec00104 	addi	sp,sp,4
8113bd5c:	f800283a 	ret

8113bd60 <OS_MemInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_MemInit (void)
{
8113bd60:	defffc04 	addi	sp,sp,-16
8113bd64:	de00012e 	bgeu	sp,et,8113bd6c <OS_MemInit+0xc>
8113bd68:	003b68fa 	trap	3
8113bd6c:	dfc00315 	stw	ra,12(sp)
8113bd70:	df000215 	stw	fp,8(sp)
8113bd74:	df000204 	addi	fp,sp,8
#if OS_MAX_MEM_PART >= 2
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
8113bd78:	01430c04 	movi	r5,3120
8113bd7c:	012045b4 	movhi	r4,33046
8113bd80:	211c6404 	addi	r4,r4,29072
8113bd84:	11395440 	call	81139544 <OS_MemClr>
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
8113bd88:	00a045b4 	movhi	r2,33046
8113bd8c:	109c6404 	addi	r2,r2,29072
8113bd90:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
8113bd94:	e03fff0d 	sth	zero,-4(fp)
8113bd98:	00001306 	br	8113bde8 <OS_MemInit+0x88>
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
8113bd9c:	e0bfff0b 	ldhu	r2,-4(fp)
8113bda0:	10800044 	addi	r2,r2,1
8113bda4:	10c00d24 	muli	r3,r2,52
8113bda8:	00a045b4 	movhi	r2,33046
8113bdac:	109c6404 	addi	r2,r2,29072
8113bdb0:	1887883a 	add	r3,r3,r2
8113bdb4:	e0bffe17 	ldw	r2,-8(fp)
8113bdb8:	10c00115 	stw	r3,4(r2)
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
8113bdbc:	e0bffe17 	ldw	r2,-8(fp)
8113bdc0:	00c00fc4 	movi	r3,63
8113bdc4:	10c00505 	stb	r3,20(r2)
        pmem->OSMemName[1]  = OS_ASCII_NUL;
8113bdc8:	e0bffe17 	ldw	r2,-8(fp)
8113bdcc:	10000545 	stb	zero,21(r2)
#endif
        pmem++;
8113bdd0:	e0bffe17 	ldw	r2,-8(fp)
8113bdd4:	10800d04 	addi	r2,r2,52
8113bdd8:	e0bffe15 	stw	r2,-8(fp)
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
8113bddc:	e0bfff0b 	ldhu	r2,-4(fp)
8113bde0:	10800044 	addi	r2,r2,1
8113bde4:	e0bfff0d 	sth	r2,-4(fp)
8113bde8:	e0bfff0b 	ldhu	r2,-4(fp)
8113bdec:	10800ef0 	cmpltui	r2,r2,59
8113bdf0:	103fea1e 	bne	r2,zero,8113bd9c <__reset+0xfb11bd9c>
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
        pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
8113bdf4:	e0bffe17 	ldw	r2,-8(fp)
8113bdf8:	10000115 	stw	zero,4(r2)
#if OS_MEM_NAME_SIZE > 1
    pmem->OSMemName[0]  = '?';                            /* Unknown name                              */
8113bdfc:	e0bffe17 	ldw	r2,-8(fp)
8113be00:	00c00fc4 	movi	r3,63
8113be04:	10c00505 	stb	r3,20(r2)
    pmem->OSMemName[1]  = OS_ASCII_NUL;
8113be08:	e0bffe17 	ldw	r2,-8(fp)
8113be0c:	10000545 	stb	zero,21(r2)
#endif

    OSMemFreeList       = &OSMemTbl[0];                   /* Point to beginning of free list           */
8113be10:	00a045b4 	movhi	r2,33046
8113be14:	109c6404 	addi	r2,r2,29072
8113be18:	d0a09b15 	stw	r2,-32148(gp)
#endif
}
8113be1c:	0001883a 	nop
8113be20:	e037883a 	mov	sp,fp
8113be24:	dfc00117 	ldw	ra,4(sp)
8113be28:	df000017 	ldw	fp,0(sp)
8113be2c:	dec00204 	addi	sp,sp,8
8113be30:	f800283a 	ret

8113be34 <OSMutexAccept>:
*********************************************************************************************************
*/

#if OS_MUTEX_ACCEPT_EN > 0
BOOLEAN  OSMutexAccept (OS_EVENT *pevent, INT8U *perr)
{
8113be34:	defff704 	addi	sp,sp,-36
8113be38:	de00012e 	bgeu	sp,et,8113be40 <OSMutexAccept+0xc>
8113be3c:	003b68fa 	trap	3
8113be40:	df000815 	stw	fp,32(sp)
8113be44:	df000804 	addi	fp,sp,32
8113be48:	e13ffe15 	stw	r4,-8(fp)
8113be4c:	e17fff15 	stw	r5,-4(fp)
    INT8U      pip;                                    /* Priority Inheritance Priority (PIP)          */
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113be50:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                          /* Validate 'perr'                              */
8113be54:	e0bfff17 	ldw	r2,-4(fp)
8113be58:	1000021e 	bne	r2,zero,8113be64 <OSMutexAccept+0x30>
        return (OS_FALSE);
8113be5c:	0005883a 	mov	r2,zero
8113be60:	00005b06 	br	8113bfd0 <OSMutexAccept+0x19c>
    }
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
8113be64:	e0bffe17 	ldw	r2,-8(fp)
8113be68:	1000051e 	bne	r2,zero,8113be80 <OSMutexAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113be6c:	e0bfff17 	ldw	r2,-4(fp)
8113be70:	00c00104 	movi	r3,4
8113be74:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113be78:	0005883a 	mov	r2,zero
8113be7c:	00005406 	br	8113bfd0 <OSMutexAccept+0x19c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
8113be80:	e0bffe17 	ldw	r2,-8(fp)
8113be84:	10800003 	ldbu	r2,0(r2)
8113be88:	10803fcc 	andi	r2,r2,255
8113be8c:	10800120 	cmpeqi	r2,r2,4
8113be90:	1000051e 	bne	r2,zero,8113bea8 <OSMutexAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
8113be94:	e0bfff17 	ldw	r2,-4(fp)
8113be98:	00c00044 	movi	r3,1
8113be9c:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113bea0:	0005883a 	mov	r2,zero
8113bea4:	00004a06 	br	8113bfd0 <OSMutexAccept+0x19c>
    }
    if (OSIntNesting > 0) {                            /* Make sure it's not called from an ISR        */
8113bea8:	d0a0a103 	ldbu	r2,-32124(gp)
8113beac:	10803fcc 	andi	r2,r2,255
8113beb0:	10000526 	beq	r2,zero,8113bec8 <OSMutexAccept+0x94>
        *perr = OS_ERR_PEND_ISR;
8113beb4:	e0bfff17 	ldw	r2,-4(fp)
8113beb8:	00c00084 	movi	r3,2
8113bebc:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113bec0:	0005883a 	mov	r2,zero
8113bec4:	00004206 	br	8113bfd0 <OSMutexAccept+0x19c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113bec8:	0005303a 	rdctl	r2,status
8113becc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113bed0:	e0fffd17 	ldw	r3,-12(fp)
8113bed4:	00bfff84 	movi	r2,-2
8113bed8:	1884703a 	and	r2,r3,r2
8113bedc:	1001703a 	wrctl	status,r2
  
  return context;
8113bee0:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
8113bee4:	e0bff815 	stw	r2,-32(fp)
    pip = (INT8U)(pevent->OSEventCnt >> 8);            /* Get PIP from mutex                           */
8113bee8:	e0bffe17 	ldw	r2,-8(fp)
8113beec:	1080020b 	ldhu	r2,8(r2)
8113bef0:	10bfffcc 	andi	r2,r2,65535
8113bef4:	1004d23a 	srli	r2,r2,8
8113bef8:	e0bffa05 	stb	r2,-24(fp)
    if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
8113befc:	e0bffe17 	ldw	r2,-8(fp)
8113bf00:	1080020b 	ldhu	r2,8(r2)
8113bf04:	10bfffcc 	andi	r2,r2,65535
8113bf08:	10803fcc 	andi	r2,r2,255
8113bf0c:	10803fd8 	cmpnei	r2,r2,255
8113bf10:	1000281e 	bne	r2,zero,8113bfb4 <OSMutexAccept+0x180>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
8113bf14:	e0bffe17 	ldw	r2,-8(fp)
8113bf18:	10c0020b 	ldhu	r3,8(r2)
8113bf1c:	00bfc004 	movi	r2,-256
8113bf20:	1884703a 	and	r2,r3,r2
8113bf24:	1007883a 	mov	r3,r2
8113bf28:	e0bffe17 	ldw	r2,-8(fp)
8113bf2c:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
8113bf30:	e0bffe17 	ldw	r2,-8(fp)
8113bf34:	10c0020b 	ldhu	r3,8(r2)
8113bf38:	d0a0a217 	ldw	r2,-32120(gp)
8113bf3c:	10800c83 	ldbu	r2,50(r2)
8113bf40:	10803fcc 	andi	r2,r2,255
8113bf44:	1884b03a 	or	r2,r3,r2
8113bf48:	1007883a 	mov	r3,r2
8113bf4c:	e0bffe17 	ldw	r2,-8(fp)
8113bf50:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex           */
8113bf54:	d0e0a217 	ldw	r3,-32120(gp)
8113bf58:	e0bffe17 	ldw	r2,-8(fp)
8113bf5c:	10c00115 	stw	r3,4(r2)
        if (OSTCBCur->OSTCBPrio <= pip) {              /*      PIP 'must' have a SMALLER prio ...      */
8113bf60:	d0a0a217 	ldw	r2,-32120(gp)
8113bf64:	10800c83 	ldbu	r2,50(r2)
8113bf68:	10803fcc 	andi	r2,r2,255
8113bf6c:	e0fffa03 	ldbu	r3,-24(fp)
8113bf70:	18800836 	bltu	r3,r2,8113bf94 <OSMutexAccept+0x160>
8113bf74:	e0bff817 	ldw	r2,-32(fp)
8113bf78:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113bf7c:	e0bff917 	ldw	r2,-28(fp)
8113bf80:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                        /*      ... than current task!                  */
            *perr = OS_ERR_PIP_LOWER;
8113bf84:	e0bfff17 	ldw	r2,-4(fp)
8113bf88:	00c01e04 	movi	r3,120
8113bf8c:	10c00005 	stb	r3,0(r2)
8113bf90:	00000606 	br	8113bfac <OSMutexAccept+0x178>
8113bf94:	e0bff817 	ldw	r2,-32(fp)
8113bf98:	e0bffb15 	stw	r2,-20(fp)
8113bf9c:	e0bffb17 	ldw	r2,-20(fp)
8113bfa0:	1001703a 	wrctl	status,r2
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
8113bfa4:	e0bfff17 	ldw	r2,-4(fp)
8113bfa8:	10000005 	stb	zero,0(r2)
        }
        return (OS_TRUE);
8113bfac:	00800044 	movi	r2,1
8113bfb0:	00000706 	br	8113bfd0 <OSMutexAccept+0x19c>
8113bfb4:	e0bff817 	ldw	r2,-32(fp)
8113bfb8:	e0bffc15 	stw	r2,-16(fp)
8113bfbc:	e0bffc17 	ldw	r2,-16(fp)
8113bfc0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113bfc4:	e0bfff17 	ldw	r2,-4(fp)
8113bfc8:	10000005 	stb	zero,0(r2)
    return (OS_FALSE);
8113bfcc:	0005883a 	mov	r2,zero
}
8113bfd0:	e037883a 	mov	sp,fp
8113bfd4:	df000017 	ldw	fp,0(sp)
8113bfd8:	dec00104 	addi	sp,sp,4
8113bfdc:	f800283a 	ret

8113bfe0 <OSMutexCreate>:
*                 to use to reduce priority inversion.
*********************************************************************************************************
*/

OS_EVENT  *OSMutexCreate (INT8U prio, INT8U *perr)
{
8113bfe0:	defff604 	addi	sp,sp,-40
8113bfe4:	de00012e 	bgeu	sp,et,8113bfec <OSMutexCreate+0xc>
8113bfe8:	003b68fa 	trap	3
8113bfec:	dfc00915 	stw	ra,36(sp)
8113bff0:	df000815 	stw	fp,32(sp)
8113bff4:	df000804 	addi	fp,sp,32
8113bff8:	2005883a 	mov	r2,r4
8113bffc:	e17fff15 	stw	r5,-4(fp)
8113c000:	e0bffe05 	stb	r2,-8(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113c004:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113c008:	e0bfff17 	ldw	r2,-4(fp)
8113c00c:	1000021e 	bne	r2,zero,8113c018 <OSMutexCreate+0x38>
        return ((OS_EVENT *)0);
8113c010:	0005883a 	mov	r2,zero
8113c014:	00006106 	br	8113c19c <OSMutexCreate+0x1bc>
    }
    if (prio >= OS_LOWEST_PRIO) {                          /* Validate PIP                             */
8113c018:	e0bffe03 	ldbu	r2,-8(fp)
8113c01c:	10800ab0 	cmpltui	r2,r2,42
8113c020:	1000051e 	bne	r2,zero,8113c038 <OSMutexCreate+0x58>
        *perr = OS_ERR_PRIO_INVALID;
8113c024:	e0bfff17 	ldw	r2,-4(fp)
8113c028:	00c00a84 	movi	r3,42
8113c02c:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
8113c030:	0005883a 	mov	r2,zero
8113c034:	00005906 	br	8113c19c <OSMutexCreate+0x1bc>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113c038:	d0a0a103 	ldbu	r2,-32124(gp)
8113c03c:	10803fcc 	andi	r2,r2,255
8113c040:	10000526 	beq	r2,zero,8113c058 <OSMutexCreate+0x78>
        *perr = OS_ERR_CREATE_ISR;                         /* ... can't CREATE mutex from an ISR       */
8113c044:	e0bfff17 	ldw	r2,-4(fp)
8113c048:	00c00404 	movi	r3,16
8113c04c:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
8113c050:	0005883a 	mov	r2,zero
8113c054:	00005106 	br	8113c19c <OSMutexCreate+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c058:	0005303a 	rdctl	r2,status
8113c05c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c060:	e0fffd17 	ldw	r3,-12(fp)
8113c064:	00bfff84 	movi	r2,-2
8113c068:	1884703a 	and	r2,r3,r2
8113c06c:	1001703a 	wrctl	status,r2
  
  return context;
8113c070:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113c074:	e0bff815 	stw	r2,-32(fp)
    if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {               /* Mutex priority must not already exist    */
8113c078:	e0fffe03 	ldbu	r3,-8(fp)
8113c07c:	00a045f4 	movhi	r2,33047
8113c080:	10b1de04 	addi	r2,r2,-14472
8113c084:	18c7883a 	add	r3,r3,r3
8113c088:	18c7883a 	add	r3,r3,r3
8113c08c:	10c5883a 	add	r2,r2,r3
8113c090:	10800017 	ldw	r2,0(r2)
8113c094:	10000926 	beq	r2,zero,8113c0bc <OSMutexCreate+0xdc>
8113c098:	e0bff817 	ldw	r2,-32(fp)
8113c09c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c0a0:	e0bff917 	ldw	r2,-28(fp)
8113c0a4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                /* Task already exist at priority ...       */
        *perr = OS_ERR_PRIO_EXIST;                         /* ... inheritance priority                 */
8113c0a8:	e0bfff17 	ldw	r2,-4(fp)
8113c0ac:	00c00a04 	movi	r3,40
8113c0b0:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
8113c0b4:	0005883a 	mov	r2,zero
8113c0b8:	00003806 	br	8113c19c <OSMutexCreate+0x1bc>
    }
    OSTCBPrioTbl[prio] = OS_TCB_RESERVED;                  /* Reserve the table entry                  */
8113c0bc:	e0fffe03 	ldbu	r3,-8(fp)
8113c0c0:	00a045f4 	movhi	r2,33047
8113c0c4:	10b1de04 	addi	r2,r2,-14472
8113c0c8:	18c7883a 	add	r3,r3,r3
8113c0cc:	18c7883a 	add	r3,r3,r3
8113c0d0:	10c5883a 	add	r2,r2,r3
8113c0d4:	00c00044 	movi	r3,1
8113c0d8:	10c00015 	stw	r3,0(r2)
    pevent             = OSEventFreeList;                  /* Get next free event control block        */
8113c0dc:	d0a0a017 	ldw	r2,-32128(gp)
8113c0e0:	e0bffb15 	stw	r2,-20(fp)
    if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available              */
8113c0e4:	e0bffb17 	ldw	r2,-20(fp)
8113c0e8:	1000101e 	bne	r2,zero,8113c12c <OSMutexCreate+0x14c>
        OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* No, Release the table entry              */
8113c0ec:	e0fffe03 	ldbu	r3,-8(fp)
8113c0f0:	00a045f4 	movhi	r2,33047
8113c0f4:	10b1de04 	addi	r2,r2,-14472
8113c0f8:	18c7883a 	add	r3,r3,r3
8113c0fc:	18c7883a 	add	r3,r3,r3
8113c100:	10c5883a 	add	r2,r2,r3
8113c104:	10000015 	stw	zero,0(r2)
8113c108:	e0bff817 	ldw	r2,-32(fp)
8113c10c:	e0bffa15 	stw	r2,-24(fp)
8113c110:	e0bffa17 	ldw	r2,-24(fp)
8113c114:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr              = OS_ERR_PEVENT_NULL;           /* No more event control blocks             */
8113c118:	e0bfff17 	ldw	r2,-4(fp)
8113c11c:	00c00104 	movi	r3,4
8113c120:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113c124:	e0bffb17 	ldw	r2,-20(fp)
8113c128:	00001c06 	br	8113c19c <OSMutexCreate+0x1bc>
    }
    OSEventFreeList        = (OS_EVENT *)OSEventFreeList->OSEventPtr;   /* Adjust the free list        */
8113c12c:	d0a0a017 	ldw	r2,-32128(gp)
8113c130:	10800117 	ldw	r2,4(r2)
8113c134:	d0a0a015 	stw	r2,-32128(gp)
8113c138:	e0bff817 	ldw	r2,-32(fp)
8113c13c:	e0bffc15 	stw	r2,-16(fp)
8113c140:	e0bffc17 	ldw	r2,-16(fp)
8113c144:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    pevent->OSEventType    = OS_EVENT_TYPE_MUTEX;
8113c148:	e0bffb17 	ldw	r2,-20(fp)
8113c14c:	00c00104 	movi	r3,4
8113c150:	10c00005 	stb	r3,0(r2)
    pevent->OSEventCnt     = (INT16U)((INT16U)prio << 8) | OS_MUTEX_AVAILABLE; /* Resource is avail.   */
8113c154:	e0bffe03 	ldbu	r2,-8(fp)
8113c158:	1004923a 	slli	r2,r2,8
8113c15c:	10803fd4 	ori	r2,r2,255
8113c160:	1007883a 	mov	r3,r2
8113c164:	e0bffb17 	ldw	r2,-20(fp)
8113c168:	10c0020d 	sth	r3,8(r2)
    pevent->OSEventPtr     = (void *)0;                                 /* No task owning the mutex    */
8113c16c:	e0bffb17 	ldw	r2,-20(fp)
8113c170:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent->OSEventName[0] = '?';
8113c174:	e0bffb17 	ldw	r2,-20(fp)
8113c178:	00c00fc4 	movi	r3,63
8113c17c:	10c00445 	stb	r3,17(r2)
    pevent->OSEventName[1] = OS_ASCII_NUL;
8113c180:	e0bffb17 	ldw	r2,-20(fp)
8113c184:	10000485 	stb	zero,18(r2)
#endif
    OS_EventWaitListInit(pevent);
8113c188:	e13ffb17 	ldw	r4,-20(fp)
8113c18c:	113912c0 	call	8113912c <OS_EventWaitListInit>
    *perr                  = OS_ERR_NONE;
8113c190:	e0bfff17 	ldw	r2,-4(fp)
8113c194:	10000005 	stb	zero,0(r2)
    return (pevent);
8113c198:	e0bffb17 	ldw	r2,-20(fp)
}
8113c19c:	e037883a 	mov	sp,fp
8113c1a0:	dfc00117 	ldw	ra,4(sp)
8113c1a4:	df000017 	ldw	fp,0(sp)
8113c1a8:	dec00204 	addi	sp,sp,8
8113c1ac:	f800283a 	ret

8113c1b0 <OSMutexDel>:
*********************************************************************************************************
*/

#if OS_MUTEX_DEL_EN
OS_EVENT  *OSMutexDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113c1b0:	defff004 	addi	sp,sp,-64
8113c1b4:	de00012e 	bgeu	sp,et,8113c1bc <OSMutexDel+0xc>
8113c1b8:	003b68fa 	trap	3
8113c1bc:	dfc00f15 	stw	ra,60(sp)
8113c1c0:	df000e15 	stw	fp,56(sp)
8113c1c4:	df000e04 	addi	fp,sp,56
8113c1c8:	e13ffd15 	stw	r4,-12(fp)
8113c1cc:	2805883a 	mov	r2,r5
8113c1d0:	e1bfff15 	stw	r6,-4(fp)
8113c1d4:	e0bffe05 	stb	r2,-8(fp)
    OS_EVENT  *pevent_return;
    INT8U      pip;                                        /* Priority inheritance priority            */
    INT8U      prio;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113c1d8:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113c1dc:	e0bfff17 	ldw	r2,-4(fp)
8113c1e0:	1000021e 	bne	r2,zero,8113c1ec <OSMutexDel+0x3c>
        return (pevent);
8113c1e4:	e0bffd17 	ldw	r2,-12(fp)
8113c1e8:	0000ad06 	br	8113c4a0 <OSMutexDel+0x2f0>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113c1ec:	e0bffd17 	ldw	r2,-12(fp)
8113c1f0:	1000051e 	bne	r2,zero,8113c208 <OSMutexDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113c1f4:	e0bfff17 	ldw	r2,-4(fp)
8113c1f8:	00c00104 	movi	r3,4
8113c1fc:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113c200:	e0bffd17 	ldw	r2,-12(fp)
8113c204:	0000a606 	br	8113c4a0 <OSMutexDel+0x2f0>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
8113c208:	e0bffd17 	ldw	r2,-12(fp)
8113c20c:	10800003 	ldbu	r2,0(r2)
8113c210:	10803fcc 	andi	r2,r2,255
8113c214:	10800120 	cmpeqi	r2,r2,4
8113c218:	1000051e 	bne	r2,zero,8113c230 <OSMutexDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113c21c:	e0bfff17 	ldw	r2,-4(fp)
8113c220:	00c00044 	movi	r3,1
8113c224:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113c228:	e0bffd17 	ldw	r2,-12(fp)
8113c22c:	00009c06 	br	8113c4a0 <OSMutexDel+0x2f0>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113c230:	d0a0a103 	ldbu	r2,-32124(gp)
8113c234:	10803fcc 	andi	r2,r2,255
8113c238:	10000526 	beq	r2,zero,8113c250 <OSMutexDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
8113c23c:	e0bfff17 	ldw	r2,-4(fp)
8113c240:	00c003c4 	movi	r3,15
8113c244:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113c248:	e0bffd17 	ldw	r2,-12(fp)
8113c24c:	00009406 	br	8113c4a0 <OSMutexDel+0x2f0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c250:	0005303a 	rdctl	r2,status
8113c254:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c258:	e0fffc17 	ldw	r3,-16(fp)
8113c25c:	00bfff84 	movi	r2,-2
8113c260:	1884703a 	and	r2,r3,r2
8113c264:	1001703a 	wrctl	status,r2
  
  return context;
8113c268:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113c26c:	e0bff415 	stw	r2,-48(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on mutex        */
8113c270:	e0bffd17 	ldw	r2,-12(fp)
8113c274:	10800283 	ldbu	r2,10(r2)
8113c278:	10803fcc 	andi	r2,r2,255
8113c27c:	10000326 	beq	r2,zero,8113c28c <OSMutexDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8113c280:	00800044 	movi	r2,1
8113c284:	e0bff205 	stb	r2,-56(fp)
8113c288:	00000106 	br	8113c290 <OSMutexDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8113c28c:	e03ff205 	stb	zero,-56(fp)
    }
    switch (opt) {
8113c290:	e0bffe03 	ldbu	r2,-8(fp)
8113c294:	10000326 	beq	r2,zero,8113c2a4 <OSMutexDel+0xf4>
8113c298:	10800060 	cmpeqi	r2,r2,1
8113c29c:	10002f1e 	bne	r2,zero,8113c35c <OSMutexDel+0x1ac>
8113c2a0:	00007406 	br	8113c474 <OSMutexDel+0x2c4>
        case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING --- */
             if (tasks_waiting == OS_FALSE) {
8113c2a4:	e0bff203 	ldbu	r2,-56(fp)
8113c2a8:	1000221e 	bne	r2,zero,8113c334 <OSMutexDel+0x184>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
8113c2ac:	e0bffd17 	ldw	r2,-12(fp)
8113c2b0:	00c00fc4 	movi	r3,63
8113c2b4:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
8113c2b8:	e0bffd17 	ldw	r2,-12(fp)
8113c2bc:	10000485 	stb	zero,18(r2)
#endif
                 pip                 = (INT8U)(pevent->OSEventCnt >> 8);
8113c2c0:	e0bffd17 	ldw	r2,-12(fp)
8113c2c4:	1080020b 	ldhu	r2,8(r2)
8113c2c8:	10bfffcc 	andi	r2,r2,65535
8113c2cc:	1004d23a 	srli	r2,r2,8
8113c2d0:	e0bff605 	stb	r2,-40(fp)
                 OSTCBPrioTbl[pip]   = (OS_TCB *)0;        /* Free up the PIP                          */
8113c2d4:	e0fff603 	ldbu	r3,-40(fp)
8113c2d8:	00a045f4 	movhi	r2,33047
8113c2dc:	10b1de04 	addi	r2,r2,-14472
8113c2e0:	18c7883a 	add	r3,r3,r3
8113c2e4:	18c7883a 	add	r3,r3,r3
8113c2e8:	10c5883a 	add	r2,r2,r3
8113c2ec:	10000015 	stw	zero,0(r2)
                 pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
8113c2f0:	e0bffd17 	ldw	r2,-12(fp)
8113c2f4:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
8113c2f8:	d0e0a017 	ldw	r3,-32128(gp)
8113c2fc:	e0bffd17 	ldw	r2,-12(fp)
8113c300:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt  = 0;
8113c304:	e0bffd17 	ldw	r2,-12(fp)
8113c308:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList     = pevent;
8113c30c:	e0bffd17 	ldw	r2,-12(fp)
8113c310:	d0a0a015 	stw	r2,-32128(gp)
8113c314:	e0bff417 	ldw	r2,-48(fp)
8113c318:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c31c:	e0bff517 	ldw	r2,-44(fp)
8113c320:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
8113c324:	e0bfff17 	ldw	r2,-4(fp)
8113c328:	10000005 	stb	zero,0(r2)
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
8113c32c:	e03ff315 	stw	zero,-52(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
                 pevent_return       = pevent;
             }
             break;
8113c330:	00005a06 	br	8113c49c <OSMutexDel+0x2ec>
8113c334:	e0bff417 	ldw	r2,-48(fp)
8113c338:	e0bff715 	stw	r2,-36(fp)
8113c33c:	e0bff717 	ldw	r2,-36(fp)
8113c340:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
8113c344:	e0bfff17 	ldw	r2,-4(fp)
8113c348:	00c01244 	movi	r3,73
8113c34c:	10c00005 	stb	r3,0(r2)
                 pevent_return       = pevent;
8113c350:	e0bffd17 	ldw	r2,-12(fp)
8113c354:	e0bff315 	stw	r2,-52(fp)
             }
             break;
8113c358:	00005006 	br	8113c49c <OSMutexDel+0x2ec>

        case OS_DEL_ALWAYS:                                /* ALWAYS DELETE THE MUTEX ---------------- */
             pip  = (INT8U)(pevent->OSEventCnt >> 8);                     /* Get PIP of mutex          */
8113c35c:	e0bffd17 	ldw	r2,-12(fp)
8113c360:	1080020b 	ldhu	r2,8(r2)
8113c364:	10bfffcc 	andi	r2,r2,65535
8113c368:	1004d23a 	srli	r2,r2,8
8113c36c:	e0bff605 	stb	r2,-40(fp)
             prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original prio */
8113c370:	e0bffd17 	ldw	r2,-12(fp)
8113c374:	1080020b 	ldhu	r2,8(r2)
8113c378:	e0bff905 	stb	r2,-28(fp)
             ptcb = (OS_TCB *)pevent->OSEventPtr;
8113c37c:	e0bffd17 	ldw	r2,-12(fp)
8113c380:	10800117 	ldw	r2,4(r2)
8113c384:	e0bffa15 	stw	r2,-24(fp)
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
8113c388:	e0bffa17 	ldw	r2,-24(fp)
8113c38c:	10000f26 	beq	r2,zero,8113c3cc <OSMutexDel+0x21c>
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
8113c390:	e0bffa17 	ldw	r2,-24(fp)
8113c394:	10800c83 	ldbu	r2,50(r2)
8113c398:	10c03fcc 	andi	r3,r2,255
8113c39c:	e0bff603 	ldbu	r2,-40(fp)
8113c3a0:	18800a1e 	bne	r3,r2,8113c3cc <OSMutexDel+0x21c>
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
8113c3a4:	e0bff903 	ldbu	r2,-28(fp)
8113c3a8:	100b883a 	mov	r5,r2
8113c3ac:	e13ffa17 	ldw	r4,-24(fp)
8113c3b0:	113cdec0 	call	8113cdec <OSMutex_RdyAtPrio>
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
8113c3b4:	00000506 	br	8113c3cc <OSMutexDel+0x21c>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
8113c3b8:	000f883a 	mov	r7,zero
8113c3bc:	01800404 	movi	r6,16
8113c3c0:	000b883a 	mov	r5,zero
8113c3c4:	e13ffd17 	ldw	r4,-12(fp)
8113c3c8:	1138b540 	call	81138b54 <OS_EventTaskRdy>
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
8113c3cc:	e0bffd17 	ldw	r2,-12(fp)
8113c3d0:	10800283 	ldbu	r2,10(r2)
8113c3d4:	10803fcc 	andi	r2,r2,255
8113c3d8:	103ff71e 	bne	r2,zero,8113c3b8 <__reset+0xfb11c3b8>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
8113c3dc:	e0bffd17 	ldw	r2,-12(fp)
8113c3e0:	00c00fc4 	movi	r3,63
8113c3e4:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
8113c3e8:	e0bffd17 	ldw	r2,-12(fp)
8113c3ec:	10000485 	stb	zero,18(r2)
#endif
             pip                 = (INT8U)(pevent->OSEventCnt >> 8);
8113c3f0:	e0bffd17 	ldw	r2,-12(fp)
8113c3f4:	1080020b 	ldhu	r2,8(r2)
8113c3f8:	10bfffcc 	andi	r2,r2,65535
8113c3fc:	1004d23a 	srli	r2,r2,8
8113c400:	e0bff605 	stb	r2,-40(fp)
             OSTCBPrioTbl[pip]   = (OS_TCB *)0;            /* Free up the PIP                          */
8113c404:	e0fff603 	ldbu	r3,-40(fp)
8113c408:	00a045f4 	movhi	r2,33047
8113c40c:	10b1de04 	addi	r2,r2,-14472
8113c410:	18c7883a 	add	r3,r3,r3
8113c414:	18c7883a 	add	r3,r3,r3
8113c418:	10c5883a 	add	r2,r2,r3
8113c41c:	10000015 	stw	zero,0(r2)
             pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
8113c420:	e0bffd17 	ldw	r2,-12(fp)
8113c424:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr  = OSEventFreeList;        /* Return Event Control Block to free list  */
8113c428:	d0e0a017 	ldw	r3,-32128(gp)
8113c42c:	e0bffd17 	ldw	r2,-12(fp)
8113c430:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt  = 0;
8113c434:	e0bffd17 	ldw	r2,-12(fp)
8113c438:	1000020d 	sth	zero,8(r2)
             OSEventFreeList     = pevent;                 /* Get next free event control block        */
8113c43c:	e0bffd17 	ldw	r2,-12(fp)
8113c440:	d0a0a015 	stw	r2,-32128(gp)
8113c444:	e0bff417 	ldw	r2,-48(fp)
8113c448:	e0bff815 	stw	r2,-32(fp)
8113c44c:	e0bff817 	ldw	r2,-32(fp)
8113c450:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8113c454:	e0bff203 	ldbu	r2,-56(fp)
8113c458:	10800058 	cmpnei	r2,r2,1
8113c45c:	1000011e 	bne	r2,zero,8113c464 <OSMutexDel+0x2b4>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8113c460:	11396100 	call	81139610 <OS_Sched>
             }
             *perr         = OS_ERR_NONE;
8113c464:	e0bfff17 	ldw	r2,-4(fp)
8113c468:	10000005 	stb	zero,0(r2)
             pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted                   */
8113c46c:	e03ff315 	stw	zero,-52(fp)
             break;
8113c470:	00000a06 	br	8113c49c <OSMutexDel+0x2ec>
8113c474:	e0bff417 	ldw	r2,-48(fp)
8113c478:	e0bffb15 	stw	r2,-20(fp)
8113c47c:	e0bffb17 	ldw	r2,-20(fp)
8113c480:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr         = OS_ERR_INVALID_OPT;
8113c484:	e0bfff17 	ldw	r2,-4(fp)
8113c488:	00c001c4 	movi	r3,7
8113c48c:	10c00005 	stb	r3,0(r2)
             pevent_return = pevent;
8113c490:	e0bffd17 	ldw	r2,-12(fp)
8113c494:	e0bff315 	stw	r2,-52(fp)
             break;
8113c498:	0001883a 	nop
    }
    return (pevent_return);
8113c49c:	e0bff317 	ldw	r2,-52(fp)
}
8113c4a0:	e037883a 	mov	sp,fp
8113c4a4:	dfc00117 	ldw	ra,4(sp)
8113c4a8:	df000017 	ldw	fp,0(sp)
8113c4ac:	dec00204 	addi	sp,sp,8
8113c4b0:	f800283a 	ret

8113c4b4 <OSMutexPend>:
*              2) You MUST NOT change the priority of the task that owns the mutex
*********************************************************************************************************
*/

void  OSMutexPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
8113c4b4:	deffee04 	addi	sp,sp,-72
8113c4b8:	de00012e 	bgeu	sp,et,8113c4c0 <OSMutexPend+0xc>
8113c4bc:	003b68fa 	trap	3
8113c4c0:	dfc01115 	stw	ra,68(sp)
8113c4c4:	df001015 	stw	fp,64(sp)
8113c4c8:	df001004 	addi	fp,sp,64
8113c4cc:	e13ffd15 	stw	r4,-12(fp)
8113c4d0:	2805883a 	mov	r2,r5
8113c4d4:	e1bfff15 	stw	r6,-4(fp)
8113c4d8:	e0bffe0d 	sth	r2,-8(fp)
    BOOLEAN    rdy;                                        /* Flag indicating task was ready           */
    OS_TCB    *ptcb;
    OS_EVENT  *pevent2;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113c4dc:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113c4e0:	e0bfff17 	ldw	r2,-4(fp)
8113c4e4:	10015626 	beq	r2,zero,8113ca40 <OSMutexPend+0x58c>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113c4e8:	e0bffd17 	ldw	r2,-12(fp)
8113c4ec:	1000041e 	bne	r2,zero,8113c500 <OSMutexPend+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113c4f0:	e0bfff17 	ldw	r2,-4(fp)
8113c4f4:	00c00104 	movi	r3,4
8113c4f8:	10c00005 	stb	r3,0(r2)
        return;
8113c4fc:	00015106 	br	8113ca44 <OSMutexPend+0x590>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
8113c500:	e0bffd17 	ldw	r2,-12(fp)
8113c504:	10800003 	ldbu	r2,0(r2)
8113c508:	10803fcc 	andi	r2,r2,255
8113c50c:	10800120 	cmpeqi	r2,r2,4
8113c510:	1000041e 	bne	r2,zero,8113c524 <OSMutexPend+0x70>
        *perr = OS_ERR_EVENT_TYPE;
8113c514:	e0bfff17 	ldw	r2,-4(fp)
8113c518:	00c00044 	movi	r3,1
8113c51c:	10c00005 	stb	r3,0(r2)
        return;
8113c520:	00014806 	br	8113ca44 <OSMutexPend+0x590>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113c524:	d0a0a103 	ldbu	r2,-32124(gp)
8113c528:	10803fcc 	andi	r2,r2,255
8113c52c:	10000426 	beq	r2,zero,8113c540 <OSMutexPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
8113c530:	e0bfff17 	ldw	r2,-4(fp)
8113c534:	00c00084 	movi	r3,2
8113c538:	10c00005 	stb	r3,0(r2)
        return;
8113c53c:	00014106 	br	8113ca44 <OSMutexPend+0x590>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
8113c540:	d0a08f03 	ldbu	r2,-32196(gp)
8113c544:	10803fcc 	andi	r2,r2,255
8113c548:	10000426 	beq	r2,zero,8113c55c <OSMutexPend+0xa8>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
8113c54c:	e0bfff17 	ldw	r2,-4(fp)
8113c550:	00c00344 	movi	r3,13
8113c554:	10c00005 	stb	r3,0(r2)
        return;
8113c558:	00013a06 	br	8113ca44 <OSMutexPend+0x590>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c55c:	0005303a 	rdctl	r2,status
8113c560:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c564:	e0fffc17 	ldw	r3,-16(fp)
8113c568:	00bfff84 	movi	r2,-2
8113c56c:	1884703a 	and	r2,r3,r2
8113c570:	1001703a 	wrctl	status,r2
  
  return context;
8113c574:	e0bffc17 	ldw	r2,-16(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
8113c578:	e0bff115 	stw	r2,-60(fp)
    pip = (INT8U)(pevent->OSEventCnt >> 8);                /* Get PIP from mutex                       */
8113c57c:	e0bffd17 	ldw	r2,-12(fp)
8113c580:	1080020b 	ldhu	r2,8(r2)
8113c584:	10bfffcc 	andi	r2,r2,65535
8113c588:	1004d23a 	srli	r2,r2,8
8113c58c:	e0bff305 	stb	r2,-52(fp)
                                                           /* Is Mutex available?                      */
    if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
8113c590:	e0bffd17 	ldw	r2,-12(fp)
8113c594:	1080020b 	ldhu	r2,8(r2)
8113c598:	10803fcc 	andi	r2,r2,255
8113c59c:	10803fd8 	cmpnei	r2,r2,255
8113c5a0:	1000271e 	bne	r2,zero,8113c640 <OSMutexPend+0x18c>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
8113c5a4:	e0bffd17 	ldw	r2,-12(fp)
8113c5a8:	10c0020b 	ldhu	r3,8(r2)
8113c5ac:	00bfc004 	movi	r2,-256
8113c5b0:	1884703a 	and	r2,r3,r2
8113c5b4:	1007883a 	mov	r3,r2
8113c5b8:	e0bffd17 	ldw	r2,-12(fp)
8113c5bc:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task        */
8113c5c0:	e0bffd17 	ldw	r2,-12(fp)
8113c5c4:	10c0020b 	ldhu	r3,8(r2)
8113c5c8:	d0a0a217 	ldw	r2,-32120(gp)
8113c5cc:	10800c83 	ldbu	r2,50(r2)
8113c5d0:	10803fcc 	andi	r2,r2,255
8113c5d4:	1884b03a 	or	r2,r3,r2
8113c5d8:	1007883a 	mov	r3,r2
8113c5dc:	e0bffd17 	ldw	r2,-12(fp)
8113c5e0:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB       */
8113c5e4:	d0e0a217 	ldw	r3,-32120(gp)
8113c5e8:	e0bffd17 	ldw	r2,-12(fp)
8113c5ec:	10c00115 	stw	r3,4(r2)
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
8113c5f0:	d0a0a217 	ldw	r2,-32120(gp)
8113c5f4:	10800c83 	ldbu	r2,50(r2)
8113c5f8:	10803fcc 	andi	r2,r2,255
8113c5fc:	e0fff303 	ldbu	r3,-52(fp)
8113c600:	18800836 	bltu	r3,r2,8113c624 <OSMutexPend+0x170>
8113c604:	e0bff117 	ldw	r2,-60(fp)
8113c608:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c60c:	e0bff217 	ldw	r2,-56(fp)
8113c610:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
            *perr = OS_ERR_PIP_LOWER;
8113c614:	e0bfff17 	ldw	r2,-4(fp)
8113c618:	00c01e04 	movi	r3,120
8113c61c:	10c00005 	stb	r3,0(r2)
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
        }
        return;
8113c620:	00010806 	br	8113ca44 <OSMutexPend+0x590>
8113c624:	e0bff117 	ldw	r2,-60(fp)
8113c628:	e0bff415 	stw	r2,-48(fp)
8113c62c:	e0bff417 	ldw	r2,-48(fp)
8113c630:	1001703a 	wrctl	status,r2
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
            *perr = OS_ERR_PIP_LOWER;
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
8113c634:	e0bfff17 	ldw	r2,-4(fp)
8113c638:	10000005 	stb	zero,0(r2)
        }
        return;
8113c63c:	00010106 	br	8113ca44 <OSMutexPend+0x590>
    }
    mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* No, Get priority of mutex owner   */
8113c640:	e0bffd17 	ldw	r2,-12(fp)
8113c644:	1080020b 	ldhu	r2,8(r2)
8113c648:	e0bff605 	stb	r2,-40(fp)
    ptcb  = (OS_TCB *)(pevent->OSEventPtr);                       /*     Point to TCB of mutex owner   */
8113c64c:	e0bffd17 	ldw	r2,-12(fp)
8113c650:	10800117 	ldw	r2,4(r2)
8113c654:	e0bff715 	stw	r2,-36(fp)
    if (ptcb->OSTCBPrio > pip) {                                  /*     Need to promote prio of owner?*/
8113c658:	e0bff717 	ldw	r2,-36(fp)
8113c65c:	10800c83 	ldbu	r2,50(r2)
8113c660:	10803fcc 	andi	r2,r2,255
8113c664:	e0fff303 	ldbu	r3,-52(fp)
8113c668:	1880b92e 	bgeu	r3,r2,8113c950 <OSMutexPend+0x49c>
        if (mprio > OSTCBCur->OSTCBPrio) {
8113c66c:	d0a0a217 	ldw	r2,-32120(gp)
8113c670:	10800c83 	ldbu	r2,50(r2)
8113c674:	10c03fcc 	andi	r3,r2,255
8113c678:	e0bff603 	ldbu	r2,-40(fp)
8113c67c:	1880b42e 	bgeu	r3,r2,8113c950 <OSMutexPend+0x49c>
            y = ptcb->OSTCBY;
8113c680:	e0bff717 	ldw	r2,-36(fp)
8113c684:	10800d03 	ldbu	r2,52(r2)
8113c688:	e0bff805 	stb	r2,-32(fp)
            if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0) {           /*     See if mutex owner is ready   */
8113c68c:	e0fff803 	ldbu	r3,-32(fp)
8113c690:	d0a09e44 	addi	r2,gp,-32135
8113c694:	1885883a 	add	r2,r3,r2
8113c698:	10c00003 	ldbu	r3,0(r2)
8113c69c:	e0bff717 	ldw	r2,-36(fp)
8113c6a0:	10800d43 	ldbu	r2,53(r2)
8113c6a4:	1884703a 	and	r2,r3,r2
8113c6a8:	10803fcc 	andi	r2,r2,255
8113c6ac:	10001e26 	beq	r2,zero,8113c728 <OSMutexPend+0x274>
                OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                  /*     Yes, Remove owner from Rdy ...*/
8113c6b0:	e0fff803 	ldbu	r3,-32(fp)
8113c6b4:	e13ff803 	ldbu	r4,-32(fp)
8113c6b8:	d0a09e44 	addi	r2,gp,-32135
8113c6bc:	2085883a 	add	r2,r4,r2
8113c6c0:	10800003 	ldbu	r2,0(r2)
8113c6c4:	1009883a 	mov	r4,r2
8113c6c8:	e0bff717 	ldw	r2,-36(fp)
8113c6cc:	10800d43 	ldbu	r2,53(r2)
8113c6d0:	0084303a 	nor	r2,zero,r2
8113c6d4:	2084703a 	and	r2,r4,r2
8113c6d8:	1009883a 	mov	r4,r2
8113c6dc:	d0a09e44 	addi	r2,gp,-32135
8113c6e0:	1885883a 	add	r2,r3,r2
8113c6e4:	11000005 	stb	r4,0(r2)
                if (OSRdyTbl[y] == 0) {                           /*          ... list at current prio */
8113c6e8:	e0fff803 	ldbu	r3,-32(fp)
8113c6ec:	d0a09e44 	addi	r2,gp,-32135
8113c6f0:	1885883a 	add	r2,r3,r2
8113c6f4:	10800003 	ldbu	r2,0(r2)
8113c6f8:	10803fcc 	andi	r2,r2,255
8113c6fc:	1000071e 	bne	r2,zero,8113c71c <OSMutexPend+0x268>
                    OSRdyGrp &= ~ptcb->OSTCBBitY;
8113c700:	e0bff717 	ldw	r2,-36(fp)
8113c704:	10800d83 	ldbu	r2,54(r2)
8113c708:	0084303a 	nor	r2,zero,r2
8113c70c:	1007883a 	mov	r3,r2
8113c710:	d0a09e03 	ldbu	r2,-32136(gp)
8113c714:	1884703a 	and	r2,r3,r2
8113c718:	d0a09e05 	stb	r2,-32136(gp)
                }
                rdy = OS_TRUE;
8113c71c:	00800044 	movi	r2,1
8113c720:	e0bff005 	stb	r2,-64(fp)
8113c724:	00002a06 	br	8113c7d0 <OSMutexPend+0x31c>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
8113c728:	e0bff717 	ldw	r2,-36(fp)
8113c72c:	10800717 	ldw	r2,28(r2)
8113c730:	e0bff915 	stw	r2,-28(fp)
                if (pevent2 != (OS_EVENT *)0) {                   /* Remove from event wait list       */
8113c734:	e0bff917 	ldw	r2,-28(fp)
8113c738:	10002426 	beq	r2,zero,8113c7cc <OSMutexPend+0x318>
                    if ((pevent2->OSEventTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX) == 0) {
8113c73c:	e0bff717 	ldw	r2,-36(fp)
8113c740:	10800d03 	ldbu	r2,52(r2)
8113c744:	10803fcc 	andi	r2,r2,255
8113c748:	e0fff717 	ldw	r3,-36(fp)
8113c74c:	18c00d03 	ldbu	r3,52(r3)
8113c750:	18c03fcc 	andi	r3,r3,255
8113c754:	e13ff917 	ldw	r4,-28(fp)
8113c758:	20c7883a 	add	r3,r4,r3
8113c75c:	18c002c4 	addi	r3,r3,11
8113c760:	18c00003 	ldbu	r3,0(r3)
8113c764:	1809883a 	mov	r4,r3
8113c768:	e0fff717 	ldw	r3,-36(fp)
8113c76c:	18c00d43 	ldbu	r3,53(r3)
8113c770:	00c6303a 	nor	r3,zero,r3
8113c774:	20c6703a 	and	r3,r4,r3
8113c778:	1809883a 	mov	r4,r3
8113c77c:	e0fff917 	ldw	r3,-28(fp)
8113c780:	1887883a 	add	r3,r3,r2
8113c784:	18c002c4 	addi	r3,r3,11
8113c788:	19000005 	stb	r4,0(r3)
8113c78c:	e0fff917 	ldw	r3,-28(fp)
8113c790:	1885883a 	add	r2,r3,r2
8113c794:	108002c4 	addi	r2,r2,11
8113c798:	10800003 	ldbu	r2,0(r2)
8113c79c:	10803fcc 	andi	r2,r2,255
8113c7a0:	10000a1e 	bne	r2,zero,8113c7cc <OSMutexPend+0x318>
                        pevent2->OSEventGrp &= ~ptcb->OSTCBBitY;
8113c7a4:	e0bff917 	ldw	r2,-28(fp)
8113c7a8:	10800283 	ldbu	r2,10(r2)
8113c7ac:	1007883a 	mov	r3,r2
8113c7b0:	e0bff717 	ldw	r2,-36(fp)
8113c7b4:	10800d83 	ldbu	r2,54(r2)
8113c7b8:	0084303a 	nor	r2,zero,r2
8113c7bc:	1884703a 	and	r2,r3,r2
8113c7c0:	1007883a 	mov	r3,r2
8113c7c4:	e0bff917 	ldw	r2,-28(fp)
8113c7c8:	10c00285 	stb	r3,10(r2)
                    }
                }
                rdy = OS_FALSE;                            /* No                                       */
8113c7cc:	e03ff005 	stb	zero,-64(fp)
            }
            ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
8113c7d0:	e0bff717 	ldw	r2,-36(fp)
8113c7d4:	e0fff303 	ldbu	r3,-52(fp)
8113c7d8:	10c00c85 	stb	r3,50(r2)
#if OS_LOWEST_PRIO <= 63
            ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3);
8113c7dc:	e0bff717 	ldw	r2,-36(fp)
8113c7e0:	10800c83 	ldbu	r2,50(r2)
8113c7e4:	10803fcc 	andi	r2,r2,255
8113c7e8:	1004d0fa 	srli	r2,r2,3
8113c7ec:	1007883a 	mov	r3,r2
8113c7f0:	e0bff717 	ldw	r2,-36(fp)
8113c7f4:	10c00d05 	stb	r3,52(r2)
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07);
8113c7f8:	e0bff717 	ldw	r2,-36(fp)
8113c7fc:	10800c83 	ldbu	r2,50(r2)
8113c800:	108001cc 	andi	r2,r2,7
8113c804:	1007883a 	mov	r3,r2
8113c808:	e0bff717 	ldw	r2,-36(fp)
8113c80c:	10c00cc5 	stb	r3,51(r2)
            ptcb->OSTCBBitY = (INT8U)(1 << ptcb->OSTCBY);
8113c810:	e0bff717 	ldw	r2,-36(fp)
8113c814:	10800d03 	ldbu	r2,52(r2)
8113c818:	10803fcc 	andi	r2,r2,255
8113c81c:	00c00044 	movi	r3,1
8113c820:	1884983a 	sll	r2,r3,r2
8113c824:	1007883a 	mov	r3,r2
8113c828:	e0bff717 	ldw	r2,-36(fp)
8113c82c:	10c00d85 	stb	r3,54(r2)
            ptcb->OSTCBBitX = (INT8U)(1 << ptcb->OSTCBX);
8113c830:	e0bff717 	ldw	r2,-36(fp)
8113c834:	10800cc3 	ldbu	r2,51(r2)
8113c838:	10803fcc 	andi	r2,r2,255
8113c83c:	00c00044 	movi	r3,1
8113c840:	1884983a 	sll	r2,r3,r2
8113c844:	1007883a 	mov	r3,r2
8113c848:	e0bff717 	ldw	r2,-36(fp)
8113c84c:	10c00d45 	stb	r3,53(r2)
            ptcb->OSTCBY    = (INT8U)((ptcb->OSTCBPrio >> 4) & 0xFF);
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x0F);
            ptcb->OSTCBBitY = (INT16U)(1 << ptcb->OSTCBY);
            ptcb->OSTCBBitX = (INT16U)(1 << ptcb->OSTCBX);
#endif
            if (rdy == OS_TRUE) {                          /* If task was ready at owner's priority ...*/
8113c850:	e0bff003 	ldbu	r2,-64(fp)
8113c854:	10800058 	cmpnei	r2,r2,1
8113c858:	1000161e 	bne	r2,zero,8113c8b4 <OSMutexPend+0x400>
                OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.       */
8113c85c:	e0bff717 	ldw	r2,-36(fp)
8113c860:	10c00d83 	ldbu	r3,54(r2)
8113c864:	d0a09e03 	ldbu	r2,-32136(gp)
8113c868:	1884b03a 	or	r2,r3,r2
8113c86c:	d0a09e05 	stb	r2,-32136(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113c870:	e0bff717 	ldw	r2,-36(fp)
8113c874:	10800d03 	ldbu	r2,52(r2)
8113c878:	10c03fcc 	andi	r3,r2,255
8113c87c:	e0bff717 	ldw	r2,-36(fp)
8113c880:	10800d03 	ldbu	r2,52(r2)
8113c884:	11003fcc 	andi	r4,r2,255
8113c888:	d0a09e44 	addi	r2,gp,-32135
8113c88c:	2085883a 	add	r2,r4,r2
8113c890:	11000003 	ldbu	r4,0(r2)
8113c894:	e0bff717 	ldw	r2,-36(fp)
8113c898:	10800d43 	ldbu	r2,53(r2)
8113c89c:	2084b03a 	or	r2,r4,r2
8113c8a0:	1009883a 	mov	r4,r2
8113c8a4:	d0a09e44 	addi	r2,gp,-32135
8113c8a8:	1885883a 	add	r2,r3,r2
8113c8ac:	11000005 	stb	r4,0(r2)
8113c8b0:	00001f06 	br	8113c930 <OSMutexPend+0x47c>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
8113c8b4:	e0bff717 	ldw	r2,-36(fp)
8113c8b8:	10800717 	ldw	r2,28(r2)
8113c8bc:	e0bff915 	stw	r2,-28(fp)
                if (pevent2 != (OS_EVENT *)0) {            /* Add to event wait list                   */
8113c8c0:	e0bff917 	ldw	r2,-28(fp)
8113c8c4:	10001a26 	beq	r2,zero,8113c930 <OSMutexPend+0x47c>
                    pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
8113c8c8:	e0bff917 	ldw	r2,-28(fp)
8113c8cc:	10c00283 	ldbu	r3,10(r2)
8113c8d0:	e0bff717 	ldw	r2,-36(fp)
8113c8d4:	10800d83 	ldbu	r2,54(r2)
8113c8d8:	1884b03a 	or	r2,r3,r2
8113c8dc:	1007883a 	mov	r3,r2
8113c8e0:	e0bff917 	ldw	r2,-28(fp)
8113c8e4:	10c00285 	stb	r3,10(r2)
                    pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113c8e8:	e0bff717 	ldw	r2,-36(fp)
8113c8ec:	10800d03 	ldbu	r2,52(r2)
8113c8f0:	10803fcc 	andi	r2,r2,255
8113c8f4:	e0fff717 	ldw	r3,-36(fp)
8113c8f8:	18c00d03 	ldbu	r3,52(r3)
8113c8fc:	18c03fcc 	andi	r3,r3,255
8113c900:	e13ff917 	ldw	r4,-28(fp)
8113c904:	20c7883a 	add	r3,r4,r3
8113c908:	18c002c4 	addi	r3,r3,11
8113c90c:	19000003 	ldbu	r4,0(r3)
8113c910:	e0fff717 	ldw	r3,-36(fp)
8113c914:	18c00d43 	ldbu	r3,53(r3)
8113c918:	20c6b03a 	or	r3,r4,r3
8113c91c:	1809883a 	mov	r4,r3
8113c920:	e0fff917 	ldw	r3,-28(fp)
8113c924:	1885883a 	add	r2,r3,r2
8113c928:	108002c4 	addi	r2,r2,11
8113c92c:	11000005 	stb	r4,0(r2)
                }
            }
            OSTCBPrioTbl[pip] = ptcb;
8113c930:	e0fff303 	ldbu	r3,-52(fp)
8113c934:	00a045f4 	movhi	r2,33047
8113c938:	10b1de04 	addi	r2,r2,-14472
8113c93c:	18c7883a 	add	r3,r3,r3
8113c940:	18c7883a 	add	r3,r3,r3
8113c944:	10c5883a 	add	r2,r2,r3
8113c948:	e0fff717 	ldw	r3,-36(fp)
8113c94c:	10c00015 	stw	r3,0(r2)
        }
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_MUTEX;         /* Mutex not available, pend current task        */
8113c950:	d0a0a217 	ldw	r2,-32120(gp)
8113c954:	d0e0a217 	ldw	r3,-32120(gp)
8113c958:	18c00c03 	ldbu	r3,48(r3)
8113c95c:	18c00414 	ori	r3,r3,16
8113c960:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113c964:	d0a0a217 	ldw	r2,-32120(gp)
8113c968:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store timeout in current task's TCB           */
8113c96c:	d0a0a217 	ldw	r2,-32120(gp)
8113c970:	e0fffe0b 	ldhu	r3,-8(fp)
8113c974:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
8113c978:	e13ffd17 	ldw	r4,-12(fp)
8113c97c:	1138cf40 	call	81138cf4 <OS_EventTaskWait>
8113c980:	e0bff117 	ldw	r2,-60(fp)
8113c984:	e0bffb15 	stw	r2,-20(fp)
8113c988:	e0bffb17 	ldw	r2,-20(fp)
8113c98c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
8113c990:	11396100 	call	81139610 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c994:	0005303a 	rdctl	r2,status
8113c998:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c99c:	e0fff517 	ldw	r3,-44(fp)
8113c9a0:	00bfff84 	movi	r2,-2
8113c9a4:	1884703a 	and	r2,r3,r2
8113c9a8:	1001703a 	wrctl	status,r2
  
  return context;
8113c9ac:	e0bff517 	ldw	r2,-44(fp)
    OS_ENTER_CRITICAL();
8113c9b0:	e0bff115 	stw	r2,-60(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
8113c9b4:	d0a0a217 	ldw	r2,-32120(gp)
8113c9b8:	10800c43 	ldbu	r2,49(r2)
8113c9bc:	10803fcc 	andi	r2,r2,255
8113c9c0:	10000326 	beq	r2,zero,8113c9d0 <OSMutexPend+0x51c>
8113c9c4:	108000a0 	cmpeqi	r2,r2,2
8113c9c8:	1000041e 	bne	r2,zero,8113c9dc <OSMutexPend+0x528>
8113c9cc:	00000706 	br	8113c9ec <OSMutexPend+0x538>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
8113c9d0:	e0bfff17 	ldw	r2,-4(fp)
8113c9d4:	10000005 	stb	zero,0(r2)
             break;
8113c9d8:	00000c06 	br	8113ca0c <OSMutexPend+0x558>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted getting mutex        */
8113c9dc:	e0bfff17 	ldw	r2,-4(fp)
8113c9e0:	00c00384 	movi	r3,14
8113c9e4:	10c00005 	stb	r3,0(r2)
             break;
8113c9e8:	00000806 	br	8113ca0c <OSMutexPend+0x558>
             
        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
8113c9ec:	d0a0a217 	ldw	r2,-32120(gp)
8113c9f0:	e17ffd17 	ldw	r5,-12(fp)
8113c9f4:	1009883a 	mov	r4,r2
8113c9f8:	1138f640 	call	81138f64 <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get mutex within TO   */
8113c9fc:	e0bfff17 	ldw	r2,-4(fp)
8113ca00:	00c00284 	movi	r3,10
8113ca04:	10c00005 	stb	r3,0(r2)
             break;
8113ca08:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
8113ca0c:	d0a0a217 	ldw	r2,-32120(gp)
8113ca10:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
8113ca14:	d0a0a217 	ldw	r2,-32120(gp)
8113ca18:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
8113ca1c:	d0a0a217 	ldw	r2,-32120(gp)
8113ca20:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8113ca24:	d0a0a217 	ldw	r2,-32120(gp)
8113ca28:	10000815 	stw	zero,32(r2)
8113ca2c:	e0bff117 	ldw	r2,-60(fp)
8113ca30:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ca34:	e0bffa17 	ldw	r2,-24(fp)
8113ca38:	1001703a 	wrctl	status,r2
8113ca3c:	00000106 	br	8113ca44 <OSMutexPend+0x590>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
        return;
8113ca40:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
8113ca44:	e037883a 	mov	sp,fp
8113ca48:	dfc00117 	ldw	ra,4(sp)
8113ca4c:	df000017 	ldw	fp,0(sp)
8113ca50:	dec00204 	addi	sp,sp,8
8113ca54:	f800283a 	ret

8113ca58 <OSMutexPost>:
*                                      what tasks will be using the Mutex.
*********************************************************************************************************
*/

INT8U  OSMutexPost (OS_EVENT *pevent)
{
8113ca58:	defff604 	addi	sp,sp,-40
8113ca5c:	de00012e 	bgeu	sp,et,8113ca64 <OSMutexPost+0xc>
8113ca60:	003b68fa 	trap	3
8113ca64:	dfc00915 	stw	ra,36(sp)
8113ca68:	df000815 	stw	fp,32(sp)
8113ca6c:	df000804 	addi	fp,sp,32
8113ca70:	e13fff15 	stw	r4,-4(fp)
    INT8U      pip;                                   /* Priority inheritance priority                 */
    INT8U      prio;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113ca74:	e03ff815 	stw	zero,-32(fp)
#endif



    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
8113ca78:	d0a0a103 	ldbu	r2,-32124(gp)
8113ca7c:	10803fcc 	andi	r2,r2,255
8113ca80:	10000226 	beq	r2,zero,8113ca8c <OSMutexPost+0x34>
        return (OS_ERR_POST_ISR);                     /* ... can't POST mutex from an ISR              */
8113ca84:	00800144 	movi	r2,5
8113ca88:	00007606 	br	8113cc64 <OSMutexPost+0x20c>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113ca8c:	e0bfff17 	ldw	r2,-4(fp)
8113ca90:	1000021e 	bne	r2,zero,8113ca9c <OSMutexPost+0x44>
        return (OS_ERR_PEVENT_NULL);
8113ca94:	00800104 	movi	r2,4
8113ca98:	00007206 	br	8113cc64 <OSMutexPost+0x20c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
8113ca9c:	e0bfff17 	ldw	r2,-4(fp)
8113caa0:	10800003 	ldbu	r2,0(r2)
8113caa4:	10803fcc 	andi	r2,r2,255
8113caa8:	10800120 	cmpeqi	r2,r2,4
8113caac:	1000021e 	bne	r2,zero,8113cab8 <OSMutexPost+0x60>
        return (OS_ERR_EVENT_TYPE);
8113cab0:	00800044 	movi	r2,1
8113cab4:	00006b06 	br	8113cc64 <OSMutexPost+0x20c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113cab8:	0005303a 	rdctl	r2,status
8113cabc:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113cac0:	e0fffe17 	ldw	r3,-8(fp)
8113cac4:	00bfff84 	movi	r2,-2
8113cac8:	1884703a 	and	r2,r3,r2
8113cacc:	1001703a 	wrctl	status,r2
  
  return context;
8113cad0:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113cad4:	e0bff815 	stw	r2,-32(fp)
    pip  = (INT8U)(pevent->OSEventCnt >> 8);          /* Get priority inheritance priority of mutex    */
8113cad8:	e0bfff17 	ldw	r2,-4(fp)
8113cadc:	1080020b 	ldhu	r2,8(r2)
8113cae0:	10bfffcc 	andi	r2,r2,65535
8113cae4:	1004d23a 	srli	r2,r2,8
8113cae8:	e0bffa05 	stb	r2,-24(fp)
    prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
8113caec:	e0bfff17 	ldw	r2,-4(fp)
8113caf0:	1080020b 	ldhu	r2,8(r2)
8113caf4:	e0bffa45 	stb	r2,-23(fp)
    if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
8113caf8:	e0bfff17 	ldw	r2,-4(fp)
8113cafc:	10c00117 	ldw	r3,4(r2)
8113cb00:	d0a0a217 	ldw	r2,-32120(gp)
8113cb04:	18800626 	beq	r3,r2,8113cb20 <OSMutexPost+0xc8>
8113cb08:	e0bff817 	ldw	r2,-32(fp)
8113cb0c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113cb10:	e0bff917 	ldw	r2,-28(fp)
8113cb14:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NOT_MUTEX_OWNER);
8113cb18:	00801904 	movi	r2,100
8113cb1c:	00005106 	br	8113cc64 <OSMutexPost+0x20c>
    }
    if (OSTCBCur->OSTCBPrio == pip) {                 /* Did we have to raise current task's priority? */
8113cb20:	d0a0a217 	ldw	r2,-32120(gp)
8113cb24:	10800c83 	ldbu	r2,50(r2)
8113cb28:	10c03fcc 	andi	r3,r2,255
8113cb2c:	e0bffa03 	ldbu	r2,-24(fp)
8113cb30:	1880051e 	bne	r3,r2,8113cb48 <OSMutexPost+0xf0>
        OSMutex_RdyAtPrio(OSTCBCur, prio);            /* Restore the task's original priority          */
8113cb34:	d0a0a217 	ldw	r2,-32120(gp)
8113cb38:	e0fffa43 	ldbu	r3,-23(fp)
8113cb3c:	180b883a 	mov	r5,r3
8113cb40:	1009883a 	mov	r4,r2
8113cb44:	113cdec0 	call	8113cdec <OSMutex_RdyAtPrio>
    }
    OSTCBPrioTbl[pip] = OS_TCB_RESERVED;              /* Reserve table entry                           */
8113cb48:	e0fffa03 	ldbu	r3,-24(fp)
8113cb4c:	00a045f4 	movhi	r2,33047
8113cb50:	10b1de04 	addi	r2,r2,-14472
8113cb54:	18c7883a 	add	r3,r3,r3
8113cb58:	18c7883a 	add	r3,r3,r3
8113cb5c:	10c5883a 	add	r2,r2,r3
8113cb60:	00c00044 	movi	r3,1
8113cb64:	10c00015 	stw	r3,0(r2)
    if (pevent->OSEventGrp != 0) {                    /* Any task waiting for the mutex?               */
8113cb68:	e0bfff17 	ldw	r2,-4(fp)
8113cb6c:	10800283 	ldbu	r2,10(r2)
8113cb70:	10803fcc 	andi	r2,r2,255
8113cb74:	10002e26 	beq	r2,zero,8113cc30 <OSMutexPost+0x1d8>
                                                      /* Yes, Make HPT waiting for mutex ready         */
        prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
8113cb78:	000f883a 	mov	r7,zero
8113cb7c:	01800404 	movi	r6,16
8113cb80:	000b883a 	mov	r5,zero
8113cb84:	e13fff17 	ldw	r4,-4(fp)
8113cb88:	1138b540 	call	81138b54 <OS_EventTaskRdy>
8113cb8c:	e0bffa45 	stb	r2,-23(fp)
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
8113cb90:	e0bfff17 	ldw	r2,-4(fp)
8113cb94:	10c0020b 	ldhu	r3,8(r2)
8113cb98:	00bfc004 	movi	r2,-256
8113cb9c:	1884703a 	and	r2,r3,r2
8113cba0:	1007883a 	mov	r3,r2
8113cba4:	e0bfff17 	ldw	r2,-4(fp)
8113cba8:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= prio;
8113cbac:	e0bfff17 	ldw	r2,-4(fp)
8113cbb0:	10c0020b 	ldhu	r3,8(r2)
8113cbb4:	e0bffa43 	ldbu	r2,-23(fp)
8113cbb8:	1884b03a 	or	r2,r3,r2
8113cbbc:	1007883a 	mov	r3,r2
8113cbc0:	e0bfff17 	ldw	r2,-4(fp)
8113cbc4:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB         */
8113cbc8:	e0fffa43 	ldbu	r3,-23(fp)
8113cbcc:	00a045f4 	movhi	r2,33047
8113cbd0:	10b1de04 	addi	r2,r2,-14472
8113cbd4:	18c7883a 	add	r3,r3,r3
8113cbd8:	18c7883a 	add	r3,r3,r3
8113cbdc:	10c5883a 	add	r2,r2,r3
8113cbe0:	10c00017 	ldw	r3,0(r2)
8113cbe4:	e0bfff17 	ldw	r2,-4(fp)
8113cbe8:	10c00115 	stw	r3,4(r2)
        if (prio <= pip) {                            /*      PIP 'must' have a SMALLER prio ...       */
8113cbec:	e0bffa43 	ldbu	r2,-23(fp)
8113cbf0:	e0fffa03 	ldbu	r3,-24(fp)
8113cbf4:	18800736 	bltu	r3,r2,8113cc14 <OSMutexPost+0x1bc>
8113cbf8:	e0bff817 	ldw	r2,-32(fp)
8113cbfc:	e0bffb15 	stw	r2,-20(fp)
8113cc00:	e0bffb17 	ldw	r2,-20(fp)
8113cc04:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                       /*      ... than current task!                   */
            OS_Sched();                               /*      Find highest priority task ready to run  */
8113cc08:	11396100 	call	81139610 <OS_Sched>
            return (OS_ERR_PIP_LOWER);
8113cc0c:	00801e04 	movi	r2,120
8113cc10:	00001406 	br	8113cc64 <OSMutexPost+0x20c>
8113cc14:	e0bff817 	ldw	r2,-32(fp)
8113cc18:	e0bffc15 	stw	r2,-16(fp)
8113cc1c:	e0bffc17 	ldw	r2,-16(fp)
8113cc20:	1001703a 	wrctl	status,r2
        } else {
            OS_EXIT_CRITICAL();
            OS_Sched();                               /*      Find highest priority task ready to run  */
8113cc24:	11396100 	call	81139610 <OS_Sched>
            return (OS_ERR_NONE);
8113cc28:	0005883a 	mov	r2,zero
8113cc2c:	00000d06 	br	8113cc64 <OSMutexPost+0x20c>
        }
    }
    pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available                   */
8113cc30:	e0bfff17 	ldw	r2,-4(fp)
8113cc34:	1080020b 	ldhu	r2,8(r2)
8113cc38:	10803fd4 	ori	r2,r2,255
8113cc3c:	1007883a 	mov	r3,r2
8113cc40:	e0bfff17 	ldw	r2,-4(fp)
8113cc44:	10c0020d 	sth	r3,8(r2)
    pevent->OSEventPtr  = (void *)0;
8113cc48:	e0bfff17 	ldw	r2,-4(fp)
8113cc4c:	10000115 	stw	zero,4(r2)
8113cc50:	e0bff817 	ldw	r2,-32(fp)
8113cc54:	e0bffd15 	stw	r2,-12(fp)
8113cc58:	e0bffd17 	ldw	r2,-12(fp)
8113cc5c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113cc60:	0005883a 	mov	r2,zero
}
8113cc64:	e037883a 	mov	sp,fp
8113cc68:	dfc00117 	ldw	ra,4(sp)
8113cc6c:	df000017 	ldw	fp,0(sp)
8113cc70:	dec00204 	addi	sp,sp,8
8113cc74:	f800283a 	ret

8113cc78 <OSMutexQuery>:
*********************************************************************************************************
*/

#if OS_MUTEX_QUERY_EN > 0
INT8U  OSMutexQuery (OS_EVENT *pevent, OS_MUTEX_DATA *p_mutex_data)
{
8113cc78:	defff704 	addi	sp,sp,-36
8113cc7c:	de00012e 	bgeu	sp,et,8113cc84 <OSMutexQuery+0xc>
8113cc80:	003b68fa 	trap	3
8113cc84:	df000815 	stw	fp,32(sp)
8113cc88:	df000804 	addi	fp,sp,32
8113cc8c:	e13ffe15 	stw	r4,-8(fp)
8113cc90:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113cc94:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113cc98:	d0a0a103 	ldbu	r2,-32124(gp)
8113cc9c:	10803fcc 	andi	r2,r2,255
8113cca0:	10000226 	beq	r2,zero,8113ccac <OSMutexQuery+0x34>
        return (OS_ERR_QUERY_ISR);                         /* ... can't QUERY mutex from an ISR        */
8113cca4:	00800184 	movi	r2,6
8113cca8:	00004c06 	br	8113cddc <OSMutexQuery+0x164>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113ccac:	e0bffe17 	ldw	r2,-8(fp)
8113ccb0:	1000021e 	bne	r2,zero,8113ccbc <OSMutexQuery+0x44>
        return (OS_ERR_PEVENT_NULL);
8113ccb4:	00800104 	movi	r2,4
8113ccb8:	00004806 	br	8113cddc <OSMutexQuery+0x164>
    }
    if (p_mutex_data == (OS_MUTEX_DATA *)0) {              /* Validate 'p_mutex_data'                  */
8113ccbc:	e0bfff17 	ldw	r2,-4(fp)
8113ccc0:	1000021e 	bne	r2,zero,8113cccc <OSMutexQuery+0x54>
        return (OS_ERR_PDATA_NULL);
8113ccc4:	00800244 	movi	r2,9
8113ccc8:	00004406 	br	8113cddc <OSMutexQuery+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
8113cccc:	e0bffe17 	ldw	r2,-8(fp)
8113ccd0:	10800003 	ldbu	r2,0(r2)
8113ccd4:	10803fcc 	andi	r2,r2,255
8113ccd8:	10800120 	cmpeqi	r2,r2,4
8113ccdc:	1000021e 	bne	r2,zero,8113cce8 <OSMutexQuery+0x70>
        return (OS_ERR_EVENT_TYPE);
8113cce0:	00800044 	movi	r2,1
8113cce4:	00003d06 	br	8113cddc <OSMutexQuery+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113cce8:	0005303a 	rdctl	r2,status
8113ccec:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ccf0:	e0fffd17 	ldw	r3,-12(fp)
8113ccf4:	00bfff84 	movi	r2,-2
8113ccf8:	1884703a 	and	r2,r3,r2
8113ccfc:	1001703a 	wrctl	status,r2
  
  return context;
8113cd00:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113cd04:	e0bffb15 	stw	r2,-20(fp)
    p_mutex_data->OSMutexPIP  = (INT8U)(pevent->OSEventCnt >> 8);
8113cd08:	e0bffe17 	ldw	r2,-8(fp)
8113cd0c:	1080020b 	ldhu	r2,8(r2)
8113cd10:	10bfffcc 	andi	r2,r2,65535
8113cd14:	1004d23a 	srli	r2,r2,8
8113cd18:	1007883a 	mov	r3,r2
8113cd1c:	e0bfff17 	ldw	r2,-4(fp)
8113cd20:	10c00245 	stb	r3,9(r2)
    p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
8113cd24:	e0bffe17 	ldw	r2,-8(fp)
8113cd28:	1080020b 	ldhu	r2,8(r2)
8113cd2c:	1007883a 	mov	r3,r2
8113cd30:	e0bfff17 	ldw	r2,-4(fp)
8113cd34:	10c00205 	stb	r3,8(r2)
    if (p_mutex_data->OSOwnerPrio == 0xFF) {
8113cd38:	e0bfff17 	ldw	r2,-4(fp)
8113cd3c:	10800203 	ldbu	r2,8(r2)
8113cd40:	10803fcc 	andi	r2,r2,255
8113cd44:	10803fd8 	cmpnei	r2,r2,255
8113cd48:	1000041e 	bne	r2,zero,8113cd5c <OSMutexQuery+0xe4>
        p_mutex_data->OSValue = OS_TRUE;
8113cd4c:	e0bfff17 	ldw	r2,-4(fp)
8113cd50:	00c00044 	movi	r3,1
8113cd54:	10c001c5 	stb	r3,7(r2)
8113cd58:	00000206 	br	8113cd64 <OSMutexQuery+0xec>
    } else {
        p_mutex_data->OSValue = OS_FALSE;
8113cd5c:	e0bfff17 	ldw	r2,-4(fp)
8113cd60:	100001c5 	stb	zero,7(r2)
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
8113cd64:	e0bffe17 	ldw	r2,-8(fp)
8113cd68:	10c00283 	ldbu	r3,10(r2)
8113cd6c:	e0bfff17 	ldw	r2,-4(fp)
8113cd70:	10c00185 	stb	r3,6(r2)
    psrc                      = &pevent->OSEventTbl[0];
8113cd74:	e0bffe17 	ldw	r2,-8(fp)
8113cd78:	108002c4 	addi	r2,r2,11
8113cd7c:	e0bff915 	stw	r2,-28(fp)
    pdest                     = &p_mutex_data->OSEventTbl[0];
8113cd80:	e0bfff17 	ldw	r2,-4(fp)
8113cd84:	e0bffa15 	stw	r2,-24(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113cd88:	e03ff805 	stb	zero,-32(fp)
8113cd8c:	00000b06 	br	8113cdbc <OSMutexQuery+0x144>
        *pdest++ = *psrc++;
8113cd90:	e0bffa17 	ldw	r2,-24(fp)
8113cd94:	10c00044 	addi	r3,r2,1
8113cd98:	e0fffa15 	stw	r3,-24(fp)
8113cd9c:	e0fff917 	ldw	r3,-28(fp)
8113cda0:	19000044 	addi	r4,r3,1
8113cda4:	e13ff915 	stw	r4,-28(fp)
8113cda8:	18c00003 	ldbu	r3,0(r3)
8113cdac:	10c00005 	stb	r3,0(r2)
        p_mutex_data->OSValue = OS_FALSE;
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
    psrc                      = &pevent->OSEventTbl[0];
    pdest                     = &p_mutex_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113cdb0:	e0bff803 	ldbu	r2,-32(fp)
8113cdb4:	10800044 	addi	r2,r2,1
8113cdb8:	e0bff805 	stb	r2,-32(fp)
8113cdbc:	e0bff803 	ldbu	r2,-32(fp)
8113cdc0:	108001b0 	cmpltui	r2,r2,6
8113cdc4:	103ff21e 	bne	r2,zero,8113cd90 <__reset+0xfb11cd90>
8113cdc8:	e0bffb17 	ldw	r2,-20(fp)
8113cdcc:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113cdd0:	e0bffc17 	ldw	r2,-16(fp)
8113cdd4:	1001703a 	wrctl	status,r2
        *pdest++ = *psrc++;
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113cdd8:	0005883a 	mov	r2,zero
}
8113cddc:	e037883a 	mov	sp,fp
8113cde0:	df000017 	ldw	fp,0(sp)
8113cde4:	dec00104 	addi	sp,sp,4
8113cde8:	f800283a 	ret

8113cdec <OSMutex_RdyAtPrio>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OSMutex_RdyAtPrio (OS_TCB *ptcb, INT8U prio)
{
8113cdec:	defffc04 	addi	sp,sp,-16
8113cdf0:	de00012e 	bgeu	sp,et,8113cdf8 <OSMutex_RdyAtPrio+0xc>
8113cdf4:	003b68fa 	trap	3
8113cdf8:	df000315 	stw	fp,12(sp)
8113cdfc:	df000304 	addi	fp,sp,12
8113ce00:	e13ffe15 	stw	r4,-8(fp)
8113ce04:	2805883a 	mov	r2,r5
8113ce08:	e0bfff05 	stb	r2,-4(fp)
    INT8U   y;


    y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pip'    */
8113ce0c:	e0bffe17 	ldw	r2,-8(fp)
8113ce10:	10800d03 	ldbu	r2,52(r2)
8113ce14:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
8113ce18:	e0fffd03 	ldbu	r3,-12(fp)
8113ce1c:	e13ffd03 	ldbu	r4,-12(fp)
8113ce20:	d0a09e44 	addi	r2,gp,-32135
8113ce24:	2085883a 	add	r2,r4,r2
8113ce28:	10800003 	ldbu	r2,0(r2)
8113ce2c:	1009883a 	mov	r4,r2
8113ce30:	e0bffe17 	ldw	r2,-8(fp)
8113ce34:	10800d43 	ldbu	r2,53(r2)
8113ce38:	0084303a 	nor	r2,zero,r2
8113ce3c:	2084703a 	and	r2,r4,r2
8113ce40:	1009883a 	mov	r4,r2
8113ce44:	d0a09e44 	addi	r2,gp,-32135
8113ce48:	1885883a 	add	r2,r3,r2
8113ce4c:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
8113ce50:	e0fffd03 	ldbu	r3,-12(fp)
8113ce54:	d0a09e44 	addi	r2,gp,-32135
8113ce58:	1885883a 	add	r2,r3,r2
8113ce5c:	10800003 	ldbu	r2,0(r2)
8113ce60:	10803fcc 	andi	r2,r2,255
8113ce64:	1000071e 	bne	r2,zero,8113ce84 <OSMutex_RdyAtPrio+0x98>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
8113ce68:	e0bffe17 	ldw	r2,-8(fp)
8113ce6c:	10800d83 	ldbu	r2,54(r2)
8113ce70:	0084303a 	nor	r2,zero,r2
8113ce74:	1007883a 	mov	r3,r2
8113ce78:	d0a09e03 	ldbu	r2,-32136(gp)
8113ce7c:	1884703a 	and	r2,r3,r2
8113ce80:	d0a09e05 	stb	r2,-32136(gp)
    }
    ptcb->OSTCBPrio         = prio;
8113ce84:	e0bffe17 	ldw	r2,-8(fp)
8113ce88:	e0ffff03 	ldbu	r3,-4(fp)
8113ce8c:	10c00c85 	stb	r3,50(r2)
#if OS_LOWEST_PRIO <= 63
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)3) & (INT8U)0x07);
8113ce90:	e0bfff03 	ldbu	r2,-4(fp)
8113ce94:	1004d0fa 	srli	r2,r2,3
8113ce98:	108001cc 	andi	r2,r2,7
8113ce9c:	1007883a 	mov	r3,r2
8113cea0:	e0bffe17 	ldw	r2,-8(fp)
8113cea4:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x07);
8113cea8:	e0bfff03 	ldbu	r2,-4(fp)
8113ceac:	108001cc 	andi	r2,r2,7
8113ceb0:	1007883a 	mov	r3,r2
8113ceb4:	e0bffe17 	ldw	r2,-8(fp)
8113ceb8:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY         = (INT8U)(1 << ptcb->OSTCBY);
8113cebc:	e0bffe17 	ldw	r2,-8(fp)
8113cec0:	10800d03 	ldbu	r2,52(r2)
8113cec4:	10803fcc 	andi	r2,r2,255
8113cec8:	00c00044 	movi	r3,1
8113cecc:	1884983a 	sll	r2,r3,r2
8113ced0:	1007883a 	mov	r3,r2
8113ced4:	e0bffe17 	ldw	r2,-8(fp)
8113ced8:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX         = (INT8U)(1 << ptcb->OSTCBX);
8113cedc:	e0bffe17 	ldw	r2,-8(fp)
8113cee0:	10800cc3 	ldbu	r2,51(r2)
8113cee4:	10803fcc 	andi	r2,r2,255
8113cee8:	00c00044 	movi	r3,1
8113ceec:	1884983a 	sll	r2,r3,r2
8113cef0:	1007883a 	mov	r3,r2
8113cef4:	e0bffe17 	ldw	r2,-8(fp)
8113cef8:	10c00d45 	stb	r3,53(r2)
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)4) & (INT8U)0x0F);
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x0F);
    ptcb->OSTCBBitY         = (INT16U)(1 << ptcb->OSTCBY);
    ptcb->OSTCBBitX         = (INT16U)(1 << ptcb->OSTCBX);
#endif
    OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
8113cefc:	e0bffe17 	ldw	r2,-8(fp)
8113cf00:	10c00d83 	ldbu	r3,54(r2)
8113cf04:	d0a09e03 	ldbu	r2,-32136(gp)
8113cf08:	1884b03a 	or	r2,r3,r2
8113cf0c:	d0a09e05 	stb	r2,-32136(gp)
    OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113cf10:	e0bffe17 	ldw	r2,-8(fp)
8113cf14:	10800d03 	ldbu	r2,52(r2)
8113cf18:	10c03fcc 	andi	r3,r2,255
8113cf1c:	e0bffe17 	ldw	r2,-8(fp)
8113cf20:	10800d03 	ldbu	r2,52(r2)
8113cf24:	11003fcc 	andi	r4,r2,255
8113cf28:	d0a09e44 	addi	r2,gp,-32135
8113cf2c:	2085883a 	add	r2,r4,r2
8113cf30:	11000003 	ldbu	r4,0(r2)
8113cf34:	e0bffe17 	ldw	r2,-8(fp)
8113cf38:	10800d43 	ldbu	r2,53(r2)
8113cf3c:	2084b03a 	or	r2,r4,r2
8113cf40:	1009883a 	mov	r4,r2
8113cf44:	d0a09e44 	addi	r2,gp,-32135
8113cf48:	1885883a 	add	r2,r3,r2
8113cf4c:	11000005 	stb	r4,0(r2)
    OSTCBPrioTbl[prio]      = ptcb;
8113cf50:	e0ffff03 	ldbu	r3,-4(fp)
8113cf54:	00a045f4 	movhi	r2,33047
8113cf58:	10b1de04 	addi	r2,r2,-14472
8113cf5c:	18c7883a 	add	r3,r3,r3
8113cf60:	18c7883a 	add	r3,r3,r3
8113cf64:	10c5883a 	add	r2,r2,r3
8113cf68:	e0fffe17 	ldw	r3,-8(fp)
8113cf6c:	10c00015 	stw	r3,0(r2)
}
8113cf70:	0001883a 	nop
8113cf74:	e037883a 	mov	sp,fp
8113cf78:	df000017 	ldw	fp,0(sp)
8113cf7c:	dec00104 	addi	sp,sp,4
8113cf80:	f800283a 	ret

8113cf84 <OSQAccept>:
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *perr)
{
8113cf84:	defff804 	addi	sp,sp,-32
8113cf88:	de00012e 	bgeu	sp,et,8113cf90 <OSQAccept+0xc>
8113cf8c:	003b68fa 	trap	3
8113cf90:	df000715 	stw	fp,28(sp)
8113cf94:	df000704 	addi	fp,sp,28
8113cf98:	e13ffe15 	stw	r4,-8(fp)
8113cf9c:	e17fff15 	stw	r5,-4(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113cfa0:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113cfa4:	e0bfff17 	ldw	r2,-4(fp)
8113cfa8:	1000021e 	bne	r2,zero,8113cfb4 <OSQAccept+0x30>
        return ((void *)0);
8113cfac:	0005883a 	mov	r2,zero
8113cfb0:	00004206 	br	8113d0bc <OSQAccept+0x138>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
8113cfb4:	e0bffe17 	ldw	r2,-8(fp)
8113cfb8:	1000051e 	bne	r2,zero,8113cfd0 <OSQAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113cfbc:	e0bfff17 	ldw	r2,-4(fp)
8113cfc0:	00c00104 	movi	r3,4
8113cfc4:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113cfc8:	0005883a 	mov	r2,zero
8113cfcc:	00003b06 	br	8113d0bc <OSQAccept+0x138>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
8113cfd0:	e0bffe17 	ldw	r2,-8(fp)
8113cfd4:	10800003 	ldbu	r2,0(r2)
8113cfd8:	10803fcc 	andi	r2,r2,255
8113cfdc:	108000a0 	cmpeqi	r2,r2,2
8113cfe0:	1000051e 	bne	r2,zero,8113cff8 <OSQAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
8113cfe4:	e0bfff17 	ldw	r2,-4(fp)
8113cfe8:	00c00044 	movi	r3,1
8113cfec:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113cff0:	0005883a 	mov	r2,zero
8113cff4:	00003106 	br	8113d0bc <OSQAccept+0x138>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113cff8:	0005303a 	rdctl	r2,status
8113cffc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d000:	e0fffd17 	ldw	r3,-12(fp)
8113d004:	00bfff84 	movi	r2,-2
8113d008:	1884703a 	and	r2,r3,r2
8113d00c:	1001703a 	wrctl	status,r2
  
  return context;
8113d010:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113d014:	e0bffa15 	stw	r2,-24(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
8113d018:	e0bffe17 	ldw	r2,-8(fp)
8113d01c:	10800117 	ldw	r2,4(r2)
8113d020:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
8113d024:	e0bffc17 	ldw	r2,-16(fp)
8113d028:	1080058b 	ldhu	r2,22(r2)
8113d02c:	10bfffcc 	andi	r2,r2,65535
8113d030:	10001926 	beq	r2,zero,8113d098 <OSQAccept+0x114>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
8113d034:	e0bffc17 	ldw	r2,-16(fp)
8113d038:	10800417 	ldw	r2,16(r2)
8113d03c:	11000104 	addi	r4,r2,4
8113d040:	e0fffc17 	ldw	r3,-16(fp)
8113d044:	19000415 	stw	r4,16(r3)
8113d048:	10800017 	ldw	r2,0(r2)
8113d04c:	e0bff915 	stw	r2,-28(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
8113d050:	e0bffc17 	ldw	r2,-16(fp)
8113d054:	1080058b 	ldhu	r2,22(r2)
8113d058:	10bfffc4 	addi	r2,r2,-1
8113d05c:	1007883a 	mov	r3,r2
8113d060:	e0bffc17 	ldw	r2,-16(fp)
8113d064:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
8113d068:	e0bffc17 	ldw	r2,-16(fp)
8113d06c:	10c00417 	ldw	r3,16(r2)
8113d070:	e0bffc17 	ldw	r2,-16(fp)
8113d074:	10800217 	ldw	r2,8(r2)
8113d078:	1880041e 	bne	r3,r2,8113d08c <OSQAccept+0x108>
            pq->OSQOut = pq->OSQStart;
8113d07c:	e0bffc17 	ldw	r2,-16(fp)
8113d080:	10c00117 	ldw	r3,4(r2)
8113d084:	e0bffc17 	ldw	r2,-16(fp)
8113d088:	10c00415 	stw	r3,16(r2)
        }
        *perr = OS_ERR_NONE;
8113d08c:	e0bfff17 	ldw	r2,-4(fp)
8113d090:	10000005 	stb	zero,0(r2)
8113d094:	00000406 	br	8113d0a8 <OSQAccept+0x124>
    } else {
        *perr = OS_ERR_Q_EMPTY;
8113d098:	e0bfff17 	ldw	r2,-4(fp)
8113d09c:	00c007c4 	movi	r3,31
8113d0a0:	10c00005 	stb	r3,0(r2)
        pmsg  = (void *)0;                       /* Queue is empty                                     */
8113d0a4:	e03ff915 	stw	zero,-28(fp)
8113d0a8:	e0bffa17 	ldw	r2,-24(fp)
8113d0ac:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d0b0:	e0bffb17 	ldw	r2,-20(fp)
8113d0b4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (pmsg);                               /* Return message received (or NULL)                  */
8113d0b8:	e0bff917 	ldw	r2,-28(fp)
}
8113d0bc:	e037883a 	mov	sp,fp
8113d0c0:	df000017 	ldw	fp,0(sp)
8113d0c4:	dec00104 	addi	sp,sp,4
8113d0c8:	f800283a 	ret

8113d0cc <OSQCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
8113d0cc:	defff404 	addi	sp,sp,-48
8113d0d0:	de00012e 	bgeu	sp,et,8113d0d8 <OSQCreate+0xc>
8113d0d4:	003b68fa 	trap	3
8113d0d8:	dfc00b15 	stw	ra,44(sp)
8113d0dc:	df000a15 	stw	fp,40(sp)
8113d0e0:	df000a04 	addi	fp,sp,40
8113d0e4:	e13ffe15 	stw	r4,-8(fp)
8113d0e8:	2805883a 	mov	r2,r5
8113d0ec:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113d0f0:	e03ff715 	stw	zero,-36(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
8113d0f4:	d0a0a103 	ldbu	r2,-32124(gp)
8113d0f8:	10803fcc 	andi	r2,r2,255
8113d0fc:	10000226 	beq	r2,zero,8113d108 <OSQCreate+0x3c>
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
8113d100:	0005883a 	mov	r2,zero
8113d104:	00005906 	br	8113d26c <OSQCreate+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d108:	0005303a 	rdctl	r2,status
8113d10c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d110:	e0fffd17 	ldw	r3,-12(fp)
8113d114:	00bfff84 	movi	r2,-2
8113d118:	1884703a 	and	r2,r3,r2
8113d11c:	1001703a 	wrctl	status,r2
  
  return context;
8113d120:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113d124:	e0bff715 	stw	r2,-36(fp)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
8113d128:	d0a0a017 	ldw	r2,-32128(gp)
8113d12c:	e0bff615 	stw	r2,-40(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
8113d130:	d0a0a017 	ldw	r2,-32128(gp)
8113d134:	10000326 	beq	r2,zero,8113d144 <OSQCreate+0x78>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
8113d138:	d0a0a017 	ldw	r2,-32128(gp)
8113d13c:	10800117 	ldw	r2,4(r2)
8113d140:	d0a0a015 	stw	r2,-32128(gp)
8113d144:	e0bff717 	ldw	r2,-36(fp)
8113d148:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d14c:	e0bff817 	ldw	r2,-32(fp)
8113d150:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
8113d154:	e0bff617 	ldw	r2,-40(fp)
8113d158:	10004326 	beq	r2,zero,8113d268 <OSQCreate+0x19c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d15c:	0005303a 	rdctl	r2,status
8113d160:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d164:	e0fff917 	ldw	r3,-28(fp)
8113d168:	00bfff84 	movi	r2,-2
8113d16c:	1884703a 	and	r2,r3,r2
8113d170:	1001703a 	wrctl	status,r2
  
  return context;
8113d174:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();
8113d178:	e0bff715 	stw	r2,-36(fp)
        pq = OSQFreeList;                        /* Get a free queue control block                     */
8113d17c:	d0a09d17 	ldw	r2,-32140(gp)
8113d180:	e0bffb15 	stw	r2,-20(fp)
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
8113d184:	e0bffb17 	ldw	r2,-20(fp)
8113d188:	10002d26 	beq	r2,zero,8113d240 <OSQCreate+0x174>
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
8113d18c:	d0a09d17 	ldw	r2,-32140(gp)
8113d190:	10800017 	ldw	r2,0(r2)
8113d194:	d0a09d15 	stw	r2,-32140(gp)
8113d198:	e0bff717 	ldw	r2,-36(fp)
8113d19c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d1a0:	e0bffa17 	ldw	r2,-24(fp)
8113d1a4:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pq->OSQStart           = start;               /*      Initialize the queue                 */
8113d1a8:	e0bffb17 	ldw	r2,-20(fp)
8113d1ac:	e0fffe17 	ldw	r3,-8(fp)
8113d1b0:	10c00115 	stw	r3,4(r2)
            pq->OSQEnd             = &start[size];
8113d1b4:	e0bfff0b 	ldhu	r2,-4(fp)
8113d1b8:	1085883a 	add	r2,r2,r2
8113d1bc:	1085883a 	add	r2,r2,r2
8113d1c0:	1007883a 	mov	r3,r2
8113d1c4:	e0bffe17 	ldw	r2,-8(fp)
8113d1c8:	10c7883a 	add	r3,r2,r3
8113d1cc:	e0bffb17 	ldw	r2,-20(fp)
8113d1d0:	10c00215 	stw	r3,8(r2)
            pq->OSQIn              = start;
8113d1d4:	e0bffb17 	ldw	r2,-20(fp)
8113d1d8:	e0fffe17 	ldw	r3,-8(fp)
8113d1dc:	10c00315 	stw	r3,12(r2)
            pq->OSQOut             = start;
8113d1e0:	e0bffb17 	ldw	r2,-20(fp)
8113d1e4:	e0fffe17 	ldw	r3,-8(fp)
8113d1e8:	10c00415 	stw	r3,16(r2)
            pq->OSQSize            = size;
8113d1ec:	e0bffb17 	ldw	r2,-20(fp)
8113d1f0:	e0ffff0b 	ldhu	r3,-4(fp)
8113d1f4:	10c0050d 	sth	r3,20(r2)
            pq->OSQEntries         = 0;
8113d1f8:	e0bffb17 	ldw	r2,-20(fp)
8113d1fc:	1000058d 	sth	zero,22(r2)
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
8113d200:	e0bff617 	ldw	r2,-40(fp)
8113d204:	00c00084 	movi	r3,2
8113d208:	10c00005 	stb	r3,0(r2)
            pevent->OSEventCnt     = 0;
8113d20c:	e0bff617 	ldw	r2,-40(fp)
8113d210:	1000020d 	sth	zero,8(r2)
            pevent->OSEventPtr     = pq;
8113d214:	e0bff617 	ldw	r2,-40(fp)
8113d218:	e0fffb17 	ldw	r3,-20(fp)
8113d21c:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
8113d220:	e0bff617 	ldw	r2,-40(fp)
8113d224:	00c00fc4 	movi	r3,63
8113d228:	10c00445 	stb	r3,17(r2)
            pevent->OSEventName[1] = OS_ASCII_NUL;
8113d22c:	e0bff617 	ldw	r2,-40(fp)
8113d230:	10000485 	stb	zero,18(r2)
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
8113d234:	e13ff617 	ldw	r4,-40(fp)
8113d238:	113912c0 	call	8113912c <OS_EventWaitListInit>
8113d23c:	00000a06 	br	8113d268 <OSQCreate+0x19c>
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
8113d240:	d0e0a017 	ldw	r3,-32128(gp)
8113d244:	e0bff617 	ldw	r2,-40(fp)
8113d248:	10c00115 	stw	r3,4(r2)
            OSEventFreeList    = pevent;
8113d24c:	e0bff617 	ldw	r2,-40(fp)
8113d250:	d0a0a015 	stw	r2,-32128(gp)
8113d254:	e0bff717 	ldw	r2,-36(fp)
8113d258:	e0bffc15 	stw	r2,-16(fp)
8113d25c:	e0bffc17 	ldw	r2,-16(fp)
8113d260:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pevent = (OS_EVENT *)0;
8113d264:	e03ff615 	stw	zero,-40(fp)
        }
    }
    return (pevent);
8113d268:	e0bff617 	ldw	r2,-40(fp)
}
8113d26c:	e037883a 	mov	sp,fp
8113d270:	dfc00117 	ldw	ra,4(sp)
8113d274:	df000017 	ldw	fp,0(sp)
8113d278:	dec00204 	addi	sp,sp,8
8113d27c:	f800283a 	ret

8113d280 <OSQDel>:
*********************************************************************************************************
*/

#if OS_Q_DEL_EN > 0
OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113d280:	defff204 	addi	sp,sp,-56
8113d284:	de00012e 	bgeu	sp,et,8113d28c <OSQDel+0xc>
8113d288:	003b68fa 	trap	3
8113d28c:	dfc00d15 	stw	ra,52(sp)
8113d290:	df000c15 	stw	fp,48(sp)
8113d294:	df000c04 	addi	fp,sp,48
8113d298:	e13ffd15 	stw	r4,-12(fp)
8113d29c:	2805883a 	mov	r2,r5
8113d2a0:	e1bfff15 	stw	r6,-4(fp)
8113d2a4:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113d2a8:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113d2ac:	e0bfff17 	ldw	r2,-4(fp)
8113d2b0:	1000021e 	bne	r2,zero,8113d2bc <OSQDel+0x3c>
        return (pevent);
8113d2b4:	e0bffd17 	ldw	r2,-12(fp)
8113d2b8:	00008e06 	br	8113d4f4 <OSQDel+0x274>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113d2bc:	e0bffd17 	ldw	r2,-12(fp)
8113d2c0:	1000051e 	bne	r2,zero,8113d2d8 <OSQDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113d2c4:	e0bfff17 	ldw	r2,-4(fp)
8113d2c8:	00c00104 	movi	r3,4
8113d2cc:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113d2d0:	e0bffd17 	ldw	r2,-12(fp)
8113d2d4:	00008706 	br	8113d4f4 <OSQDel+0x274>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
8113d2d8:	e0bffd17 	ldw	r2,-12(fp)
8113d2dc:	10800003 	ldbu	r2,0(r2)
8113d2e0:	10803fcc 	andi	r2,r2,255
8113d2e4:	108000a0 	cmpeqi	r2,r2,2
8113d2e8:	1000051e 	bne	r2,zero,8113d300 <OSQDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113d2ec:	e0bfff17 	ldw	r2,-4(fp)
8113d2f0:	00c00044 	movi	r3,1
8113d2f4:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113d2f8:	e0bffd17 	ldw	r2,-12(fp)
8113d2fc:	00007d06 	br	8113d4f4 <OSQDel+0x274>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113d300:	d0a0a103 	ldbu	r2,-32124(gp)
8113d304:	10803fcc 	andi	r2,r2,255
8113d308:	10000526 	beq	r2,zero,8113d320 <OSQDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
8113d30c:	e0bfff17 	ldw	r2,-4(fp)
8113d310:	00c003c4 	movi	r3,15
8113d314:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113d318:	e0bffd17 	ldw	r2,-12(fp)
8113d31c:	00007506 	br	8113d4f4 <OSQDel+0x274>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d320:	0005303a 	rdctl	r2,status
8113d324:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d328:	e0fffc17 	ldw	r3,-16(fp)
8113d32c:	00bfff84 	movi	r2,-2
8113d330:	1884703a 	and	r2,r3,r2
8113d334:	1001703a 	wrctl	status,r2
  
  return context;
8113d338:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113d33c:	e0bff615 	stw	r2,-40(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
8113d340:	e0bffd17 	ldw	r2,-12(fp)
8113d344:	10800283 	ldbu	r2,10(r2)
8113d348:	10803fcc 	andi	r2,r2,255
8113d34c:	10000326 	beq	r2,zero,8113d35c <OSQDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8113d350:	00800044 	movi	r2,1
8113d354:	e0bff405 	stb	r2,-48(fp)
8113d358:	00000106 	br	8113d360 <OSQDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8113d35c:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
8113d360:	e0bffe03 	ldbu	r2,-8(fp)
8113d364:	10000326 	beq	r2,zero,8113d374 <OSQDel+0xf4>
8113d368:	10800060 	cmpeqi	r2,r2,1
8113d36c:	1000301e 	bne	r2,zero,8113d430 <OSQDel+0x1b0>
8113d370:	00005506 	br	8113d4c8 <OSQDel+0x248>
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == OS_FALSE) {
8113d374:	e0bff403 	ldbu	r2,-48(fp)
8113d378:	10001e1e 	bne	r2,zero,8113d3f4 <OSQDel+0x174>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
8113d37c:	e0bffd17 	ldw	r2,-12(fp)
8113d380:	00c00fc4 	movi	r3,63
8113d384:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
8113d388:	e0bffd17 	ldw	r2,-12(fp)
8113d38c:	10000485 	stb	zero,18(r2)
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
8113d390:	e0bffd17 	ldw	r2,-12(fp)
8113d394:	10800117 	ldw	r2,4(r2)
8113d398:	e0bff815 	stw	r2,-32(fp)
                 pq->OSQPtr             = OSQFreeList;
8113d39c:	d0e09d17 	ldw	r3,-32140(gp)
8113d3a0:	e0bff817 	ldw	r2,-32(fp)
8113d3a4:	10c00015 	stw	r3,0(r2)
                 OSQFreeList            = pq;
8113d3a8:	e0bff817 	ldw	r2,-32(fp)
8113d3ac:	d0a09d15 	stw	r2,-32140(gp)
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113d3b0:	e0bffd17 	ldw	r2,-12(fp)
8113d3b4:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
8113d3b8:	d0e0a017 	ldw	r3,-32128(gp)
8113d3bc:	e0bffd17 	ldw	r2,-12(fp)
8113d3c0:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
8113d3c4:	e0bffd17 	ldw	r2,-12(fp)
8113d3c8:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
8113d3cc:	e0bffd17 	ldw	r2,-12(fp)
8113d3d0:	d0a0a015 	stw	r2,-32128(gp)
8113d3d4:	e0bff617 	ldw	r2,-40(fp)
8113d3d8:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d3dc:	e0bff717 	ldw	r2,-36(fp)
8113d3e0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
8113d3e4:	e0bfff17 	ldw	r2,-4(fp)
8113d3e8:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
8113d3ec:	e03ff515 	stw	zero,-44(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
8113d3f0:	00003f06 	br	8113d4f0 <OSQDel+0x270>
8113d3f4:	e0bff617 	ldw	r2,-40(fp)
8113d3f8:	e0bff915 	stw	r2,-28(fp)
8113d3fc:	e0bff917 	ldw	r2,-28(fp)
8113d400:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
8113d404:	e0bfff17 	ldw	r2,-4(fp)
8113d408:	00c01244 	movi	r3,73
8113d40c:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
8113d410:	e0bffd17 	ldw	r2,-12(fp)
8113d414:	e0bff515 	stw	r2,-44(fp)
             }
             break;
8113d418:	00003506 	br	8113d4f0 <OSQDel+0x270>

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
8113d41c:	000f883a 	mov	r7,zero
8113d420:	01800104 	movi	r6,4
8113d424:	000b883a 	mov	r5,zero
8113d428:	e13ffd17 	ldw	r4,-12(fp)
8113d42c:	1138b540 	call	81138b54 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
8113d430:	e0bffd17 	ldw	r2,-12(fp)
8113d434:	10800283 	ldbu	r2,10(r2)
8113d438:	10803fcc 	andi	r2,r2,255
8113d43c:	103ff71e 	bne	r2,zero,8113d41c <__reset+0xfb11d41c>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
8113d440:	e0bffd17 	ldw	r2,-12(fp)
8113d444:	00c00fc4 	movi	r3,63
8113d448:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
8113d44c:	e0bffd17 	ldw	r2,-12(fp)
8113d450:	10000485 	stb	zero,18(r2)
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
8113d454:	e0bffd17 	ldw	r2,-12(fp)
8113d458:	10800117 	ldw	r2,4(r2)
8113d45c:	e0bff815 	stw	r2,-32(fp)
             pq->OSQPtr             = OSQFreeList;
8113d460:	d0e09d17 	ldw	r3,-32140(gp)
8113d464:	e0bff817 	ldw	r2,-32(fp)
8113d468:	10c00015 	stw	r3,0(r2)
             OSQFreeList            = pq;
8113d46c:	e0bff817 	ldw	r2,-32(fp)
8113d470:	d0a09d15 	stw	r2,-32140(gp)
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113d474:	e0bffd17 	ldw	r2,-12(fp)
8113d478:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
8113d47c:	d0e0a017 	ldw	r3,-32128(gp)
8113d480:	e0bffd17 	ldw	r2,-12(fp)
8113d484:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
8113d488:	e0bffd17 	ldw	r2,-12(fp)
8113d48c:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
8113d490:	e0bffd17 	ldw	r2,-12(fp)
8113d494:	d0a0a015 	stw	r2,-32128(gp)
8113d498:	e0bff617 	ldw	r2,-40(fp)
8113d49c:	e0bffa15 	stw	r2,-24(fp)
8113d4a0:	e0bffa17 	ldw	r2,-24(fp)
8113d4a4:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8113d4a8:	e0bff403 	ldbu	r2,-48(fp)
8113d4ac:	10800058 	cmpnei	r2,r2,1
8113d4b0:	1000011e 	bne	r2,zero,8113d4b8 <OSQDel+0x238>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8113d4b4:	11396100 	call	81139610 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
8113d4b8:	e0bfff17 	ldw	r2,-4(fp)
8113d4bc:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
8113d4c0:	e03ff515 	stw	zero,-44(fp)
             break;
8113d4c4:	00000a06 	br	8113d4f0 <OSQDel+0x270>
8113d4c8:	e0bff617 	ldw	r2,-40(fp)
8113d4cc:	e0bffb15 	stw	r2,-20(fp)
8113d4d0:	e0bffb17 	ldw	r2,-20(fp)
8113d4d4:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
8113d4d8:	e0bfff17 	ldw	r2,-4(fp)
8113d4dc:	00c001c4 	movi	r3,7
8113d4e0:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
8113d4e4:	e0bffd17 	ldw	r2,-12(fp)
8113d4e8:	e0bff515 	stw	r2,-44(fp)
             break;
8113d4ec:	0001883a 	nop
    }
    return (pevent_return);
8113d4f0:	e0bff517 	ldw	r2,-44(fp)
}
8113d4f4:	e037883a 	mov	sp,fp
8113d4f8:	dfc00117 	ldw	ra,4(sp)
8113d4fc:	df000017 	ldw	fp,0(sp)
8113d500:	dec00204 	addi	sp,sp,8
8113d504:	f800283a 	ret

8113d508 <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0
INT8U  OSQFlush (OS_EVENT *pevent)
{
8113d508:	defffa04 	addi	sp,sp,-24
8113d50c:	de00012e 	bgeu	sp,et,8113d514 <OSQFlush+0xc>
8113d510:	003b68fa 	trap	3
8113d514:	df000515 	stw	fp,20(sp)
8113d518:	df000504 	addi	fp,sp,20
8113d51c:	e13fff15 	stw	r4,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113d520:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113d524:	e0bfff17 	ldw	r2,-4(fp)
8113d528:	1000021e 	bne	r2,zero,8113d534 <OSQFlush+0x2c>
        return (OS_ERR_PEVENT_NULL);
8113d52c:	00800104 	movi	r2,4
8113d530:	00002106 	br	8113d5b8 <OSQFlush+0xb0>
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
8113d534:	e0bfff17 	ldw	r2,-4(fp)
8113d538:	10800003 	ldbu	r2,0(r2)
8113d53c:	10803fcc 	andi	r2,r2,255
8113d540:	108000a0 	cmpeqi	r2,r2,2
8113d544:	1000021e 	bne	r2,zero,8113d550 <OSQFlush+0x48>
        return (OS_ERR_EVENT_TYPE);
8113d548:	00800044 	movi	r2,1
8113d54c:	00001a06 	br	8113d5b8 <OSQFlush+0xb0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d550:	0005303a 	rdctl	r2,status
8113d554:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d558:	e0fffd17 	ldw	r3,-12(fp)
8113d55c:	00bfff84 	movi	r2,-2
8113d560:	1884703a 	and	r2,r3,r2
8113d564:	1001703a 	wrctl	status,r2
  
  return context;
8113d568:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113d56c:	e0bffb15 	stw	r2,-20(fp)
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
8113d570:	e0bfff17 	ldw	r2,-4(fp)
8113d574:	10800117 	ldw	r2,4(r2)
8113d578:	e0bffc15 	stw	r2,-16(fp)
    pq->OSQIn      = pq->OSQStart;
8113d57c:	e0bffc17 	ldw	r2,-16(fp)
8113d580:	10c00117 	ldw	r3,4(r2)
8113d584:	e0bffc17 	ldw	r2,-16(fp)
8113d588:	10c00315 	stw	r3,12(r2)
    pq->OSQOut     = pq->OSQStart;
8113d58c:	e0bffc17 	ldw	r2,-16(fp)
8113d590:	10c00117 	ldw	r3,4(r2)
8113d594:	e0bffc17 	ldw	r2,-16(fp)
8113d598:	10c00415 	stw	r3,16(r2)
    pq->OSQEntries = 0;
8113d59c:	e0bffc17 	ldw	r2,-16(fp)
8113d5a0:	1000058d 	sth	zero,22(r2)
8113d5a4:	e0bffb17 	ldw	r2,-20(fp)
8113d5a8:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d5ac:	e0bffe17 	ldw	r2,-8(fp)
8113d5b0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113d5b4:	0005883a 	mov	r2,zero
}
8113d5b8:	e037883a 	mov	sp,fp
8113d5bc:	df000017 	ldw	fp,0(sp)
8113d5c0:	dec00104 	addi	sp,sp,4
8113d5c4:	f800283a 	ret

8113d5c8 <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
8113d5c8:	defff304 	addi	sp,sp,-52
8113d5cc:	de00012e 	bgeu	sp,et,8113d5d4 <OSQPend+0xc>
8113d5d0:	003b68fa 	trap	3
8113d5d4:	dfc00c15 	stw	ra,48(sp)
8113d5d8:	df000b15 	stw	fp,44(sp)
8113d5dc:	df000b04 	addi	fp,sp,44
8113d5e0:	e13ffd15 	stw	r4,-12(fp)
8113d5e4:	2805883a 	mov	r2,r5
8113d5e8:	e1bfff15 	stw	r6,-4(fp)
8113d5ec:	e0bffe0d 	sth	r2,-8(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113d5f0:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113d5f4:	e0bfff17 	ldw	r2,-4(fp)
8113d5f8:	1000021e 	bne	r2,zero,8113d604 <OSQPend+0x3c>
        return ((void *)0);
8113d5fc:	0005883a 	mov	r2,zero
8113d600:	00009106 	br	8113d848 <OSQPend+0x280>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
8113d604:	e0bffd17 	ldw	r2,-12(fp)
8113d608:	1000051e 	bne	r2,zero,8113d620 <OSQPend+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113d60c:	e0bfff17 	ldw	r2,-4(fp)
8113d610:	00c00104 	movi	r3,4
8113d614:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113d618:	0005883a 	mov	r2,zero
8113d61c:	00008a06 	br	8113d848 <OSQPend+0x280>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
8113d620:	e0bffd17 	ldw	r2,-12(fp)
8113d624:	10800003 	ldbu	r2,0(r2)
8113d628:	10803fcc 	andi	r2,r2,255
8113d62c:	108000a0 	cmpeqi	r2,r2,2
8113d630:	1000051e 	bne	r2,zero,8113d648 <OSQPend+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113d634:	e0bfff17 	ldw	r2,-4(fp)
8113d638:	00c00044 	movi	r3,1
8113d63c:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113d640:	0005883a 	mov	r2,zero
8113d644:	00008006 	br	8113d848 <OSQPend+0x280>
    }
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
8113d648:	d0a0a103 	ldbu	r2,-32124(gp)
8113d64c:	10803fcc 	andi	r2,r2,255
8113d650:	10000526 	beq	r2,zero,8113d668 <OSQPend+0xa0>
        *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
8113d654:	e0bfff17 	ldw	r2,-4(fp)
8113d658:	00c00084 	movi	r3,2
8113d65c:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113d660:	0005883a 	mov	r2,zero
8113d664:	00007806 	br	8113d848 <OSQPend+0x280>
    }
    if (OSLockNesting > 0) {                     /* See if called with scheduler locked ...            */
8113d668:	d0a08f03 	ldbu	r2,-32196(gp)
8113d66c:	10803fcc 	andi	r2,r2,255
8113d670:	10000526 	beq	r2,zero,8113d688 <OSQPend+0xc0>
        *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
8113d674:	e0bfff17 	ldw	r2,-4(fp)
8113d678:	00c00344 	movi	r3,13
8113d67c:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113d680:	0005883a 	mov	r2,zero
8113d684:	00007006 	br	8113d848 <OSQPend+0x280>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d688:	0005303a 	rdctl	r2,status
8113d68c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d690:	e0fffc17 	ldw	r3,-16(fp)
8113d694:	00bfff84 	movi	r2,-2
8113d698:	1884703a 	and	r2,r3,r2
8113d69c:	1001703a 	wrctl	status,r2
  
  return context;
8113d6a0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113d6a4:	e0bff615 	stw	r2,-40(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
8113d6a8:	e0bffd17 	ldw	r2,-12(fp)
8113d6ac:	10800117 	ldw	r2,4(r2)
8113d6b0:	e0bff815 	stw	r2,-32(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
8113d6b4:	e0bff817 	ldw	r2,-32(fp)
8113d6b8:	1080058b 	ldhu	r2,22(r2)
8113d6bc:	10bfffcc 	andi	r2,r2,65535
8113d6c0:	10001e26 	beq	r2,zero,8113d73c <OSQPend+0x174>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
8113d6c4:	e0bff817 	ldw	r2,-32(fp)
8113d6c8:	10800417 	ldw	r2,16(r2)
8113d6cc:	11000104 	addi	r4,r2,4
8113d6d0:	e0fff817 	ldw	r3,-32(fp)
8113d6d4:	19000415 	stw	r4,16(r3)
8113d6d8:	10800017 	ldw	r2,0(r2)
8113d6dc:	e0bff515 	stw	r2,-44(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
8113d6e0:	e0bff817 	ldw	r2,-32(fp)
8113d6e4:	1080058b 	ldhu	r2,22(r2)
8113d6e8:	10bfffc4 	addi	r2,r2,-1
8113d6ec:	1007883a 	mov	r3,r2
8113d6f0:	e0bff817 	ldw	r2,-32(fp)
8113d6f4:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
8113d6f8:	e0bff817 	ldw	r2,-32(fp)
8113d6fc:	10c00417 	ldw	r3,16(r2)
8113d700:	e0bff817 	ldw	r2,-32(fp)
8113d704:	10800217 	ldw	r2,8(r2)
8113d708:	1880041e 	bne	r3,r2,8113d71c <OSQPend+0x154>
            pq->OSQOut = pq->OSQStart;
8113d70c:	e0bff817 	ldw	r2,-32(fp)
8113d710:	10c00117 	ldw	r3,4(r2)
8113d714:	e0bff817 	ldw	r2,-32(fp)
8113d718:	10c00415 	stw	r3,16(r2)
8113d71c:	e0bff617 	ldw	r2,-40(fp)
8113d720:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d724:	e0bff717 	ldw	r2,-36(fp)
8113d728:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
8113d72c:	e0bfff17 	ldw	r2,-4(fp)
8113d730:	10000005 	stb	zero,0(r2)
        return (pmsg);                           /* Return message received                            */
8113d734:	e0bff517 	ldw	r2,-44(fp)
8113d738:	00004306 	br	8113d848 <OSQPend+0x280>
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
8113d73c:	d0a0a217 	ldw	r2,-32120(gp)
8113d740:	d0e0a217 	ldw	r3,-32120(gp)
8113d744:	18c00c03 	ldbu	r3,48(r3)
8113d748:	18c00114 	ori	r3,r3,4
8113d74c:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113d750:	d0a0a217 	ldw	r2,-32120(gp)
8113d754:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
8113d758:	d0a0a217 	ldw	r2,-32120(gp)
8113d75c:	e0fffe0b 	ldhu	r3,-8(fp)
8113d760:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
8113d764:	e13ffd17 	ldw	r4,-12(fp)
8113d768:	1138cf40 	call	81138cf4 <OS_EventTaskWait>
8113d76c:	e0bff617 	ldw	r2,-40(fp)
8113d770:	e0bffb15 	stw	r2,-20(fp)
8113d774:	e0bffb17 	ldw	r2,-20(fp)
8113d778:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                  /* Find next highest priority task ready to run       */
8113d77c:	11396100 	call	81139610 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d780:	0005303a 	rdctl	r2,status
8113d784:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d788:	e0fff917 	ldw	r3,-28(fp)
8113d78c:	00bfff84 	movi	r2,-2
8113d790:	1884703a 	and	r2,r3,r2
8113d794:	1001703a 	wrctl	status,r2
  
  return context;
8113d798:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
8113d79c:	e0bff615 	stw	r2,-40(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
8113d7a0:	d0a0a217 	ldw	r2,-32120(gp)
8113d7a4:	10800c43 	ldbu	r2,49(r2)
8113d7a8:	10803fcc 	andi	r2,r2,255
8113d7ac:	10000326 	beq	r2,zero,8113d7bc <OSQPend+0x1f4>
8113d7b0:	108000a0 	cmpeqi	r2,r2,2
8113d7b4:	1000071e 	bne	r2,zero,8113d7d4 <OSQPend+0x20c>
8113d7b8:	00000b06 	br	8113d7e8 <OSQPend+0x220>
        case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
             pmsg =  OSTCBCur->OSTCBMsg;
8113d7bc:	d0a0a217 	ldw	r2,-32120(gp)
8113d7c0:	10800917 	ldw	r2,36(r2)
8113d7c4:	e0bff515 	stw	r2,-44(fp)
            *perr =  OS_ERR_NONE;
8113d7c8:	e0bfff17 	ldw	r2,-4(fp)
8113d7cc:	10000005 	stb	zero,0(r2)
             break;
8113d7d0:	00000e06 	br	8113d80c <OSQPend+0x244>

        case OS_STAT_PEND_ABORT:
             pmsg = (void *)0;
8113d7d4:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
8113d7d8:	e0bfff17 	ldw	r2,-4(fp)
8113d7dc:	00c00384 	movi	r3,14
8113d7e0:	10c00005 	stb	r3,0(r2)
             break;
8113d7e4:	00000906 	br	8113d80c <OSQPend+0x244>

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
8113d7e8:	d0a0a217 	ldw	r2,-32120(gp)
8113d7ec:	e17ffd17 	ldw	r5,-12(fp)
8113d7f0:	1009883a 	mov	r4,r2
8113d7f4:	1138f640 	call	81138f64 <OS_EventTaskRemove>
             pmsg = (void *)0;
8113d7f8:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
8113d7fc:	e0bfff17 	ldw	r2,-4(fp)
8113d800:	00c00284 	movi	r3,10
8113d804:	10c00005 	stb	r3,0(r2)
             break;
8113d808:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
8113d80c:	d0a0a217 	ldw	r2,-32120(gp)
8113d810:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
8113d814:	d0a0a217 	ldw	r2,-32120(gp)
8113d818:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
8113d81c:	d0a0a217 	ldw	r2,-32120(gp)
8113d820:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8113d824:	d0a0a217 	ldw	r2,-32120(gp)
8113d828:	10000815 	stw	zero,32(r2)
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
8113d82c:	d0a0a217 	ldw	r2,-32120(gp)
8113d830:	10000915 	stw	zero,36(r2)
8113d834:	e0bff617 	ldw	r2,-40(fp)
8113d838:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d83c:	e0bffa17 	ldw	r2,-24(fp)
8113d840:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (pmsg);                                    /* Return received message                       */
8113d844:	e0bff517 	ldw	r2,-44(fp)
}
8113d848:	e037883a 	mov	sp,fp
8113d84c:	dfc00117 	ldw	ra,4(sp)
8113d850:	df000017 	ldw	fp,0(sp)
8113d854:	dec00204 	addi	sp,sp,8
8113d858:	f800283a 	ret

8113d85c <OSQPendAbort>:
*********************************************************************************************************
*/

#if OS_Q_PEND_ABORT_EN > 0
INT8U  OSQPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113d85c:	defff604 	addi	sp,sp,-40
8113d860:	de00012e 	bgeu	sp,et,8113d868 <OSQPendAbort+0xc>
8113d864:	003b68fa 	trap	3
8113d868:	dfc00915 	stw	ra,36(sp)
8113d86c:	df000815 	stw	fp,32(sp)
8113d870:	df000804 	addi	fp,sp,32
8113d874:	e13ffd15 	stw	r4,-12(fp)
8113d878:	2805883a 	mov	r2,r5
8113d87c:	e1bfff15 	stw	r6,-4(fp)
8113d880:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113d884:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113d888:	e0bfff17 	ldw	r2,-4(fp)
8113d88c:	1000021e 	bne	r2,zero,8113d898 <OSQPendAbort+0x3c>
        return (0);
8113d890:	0005883a 	mov	r2,zero
8113d894:	00004906 	br	8113d9bc <OSQPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113d898:	e0bffd17 	ldw	r2,-12(fp)
8113d89c:	1000051e 	bne	r2,zero,8113d8b4 <OSQPendAbort+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113d8a0:	e0bfff17 	ldw	r2,-4(fp)
8113d8a4:	00c00104 	movi	r3,4
8113d8a8:	10c00005 	stb	r3,0(r2)
        return (0);
8113d8ac:	0005883a 	mov	r2,zero
8113d8b0:	00004206 	br	8113d9bc <OSQPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
8113d8b4:	e0bffd17 	ldw	r2,-12(fp)
8113d8b8:	10800003 	ldbu	r2,0(r2)
8113d8bc:	10803fcc 	andi	r2,r2,255
8113d8c0:	108000a0 	cmpeqi	r2,r2,2
8113d8c4:	1000051e 	bne	r2,zero,8113d8dc <OSQPendAbort+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113d8c8:	e0bfff17 	ldw	r2,-4(fp)
8113d8cc:	00c00044 	movi	r3,1
8113d8d0:	10c00005 	stb	r3,0(r2)
        return (0);
8113d8d4:	0005883a 	mov	r2,zero
8113d8d8:	00003806 	br	8113d9bc <OSQPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d8dc:	0005303a 	rdctl	r2,status
8113d8e0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d8e4:	e0fffc17 	ldw	r3,-16(fp)
8113d8e8:	00bfff84 	movi	r2,-2
8113d8ec:	1884703a 	and	r2,r3,r2
8113d8f0:	1001703a 	wrctl	status,r2
  
  return context;
8113d8f4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113d8f8:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
8113d8fc:	e0bffd17 	ldw	r2,-12(fp)
8113d900:	10800283 	ldbu	r2,10(r2)
8113d904:	10803fcc 	andi	r2,r2,255
8113d908:	10002526 	beq	r2,zero,8113d9a0 <OSQPendAbort+0x144>
        nbr_tasks = 0;
8113d90c:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
8113d910:	e0bffe03 	ldbu	r2,-8(fp)
8113d914:	10800060 	cmpeqi	r2,r2,1
8113d918:	10000e26 	beq	r2,zero,8113d954 <OSQPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
8113d91c:	00000806 	br	8113d940 <OSQPendAbort+0xe4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
8113d920:	01c00084 	movi	r7,2
8113d924:	01800104 	movi	r6,4
8113d928:	000b883a 	mov	r5,zero
8113d92c:	e13ffd17 	ldw	r4,-12(fp)
8113d930:	1138b540 	call	81138b54 <OS_EventTaskRdy>
                     nbr_tasks++;
8113d934:	e0bff803 	ldbu	r2,-32(fp)
8113d938:	10800044 	addi	r2,r2,1
8113d93c:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
8113d940:	e0bffd17 	ldw	r2,-12(fp)
8113d944:	10800283 	ldbu	r2,10(r2)
8113d948:	10803fcc 	andi	r2,r2,255
8113d94c:	103ff41e 	bne	r2,zero,8113d920 <__reset+0xfb11d920>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
8113d950:	00000906 	br	8113d978 <OSQPendAbort+0x11c>
               
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on queue    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
8113d954:	01c00084 	movi	r7,2
8113d958:	01800104 	movi	r6,4
8113d95c:	000b883a 	mov	r5,zero
8113d960:	e13ffd17 	ldw	r4,-12(fp)
8113d964:	1138b540 	call	81138b54 <OS_EventTaskRdy>
                 nbr_tasks++;
8113d968:	e0bff803 	ldbu	r2,-32(fp)
8113d96c:	10800044 	addi	r2,r2,1
8113d970:	e0bff805 	stb	r2,-32(fp)
                 break;
8113d974:	0001883a 	nop
8113d978:	e0bff917 	ldw	r2,-28(fp)
8113d97c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d980:	e0bffa17 	ldw	r2,-24(fp)
8113d984:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                        /* Find HPT ready to run                    */
8113d988:	11396100 	call	81139610 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
8113d98c:	e0bfff17 	ldw	r2,-4(fp)
8113d990:	00c00384 	movi	r3,14
8113d994:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
8113d998:	e0bff803 	ldbu	r2,-32(fp)
8113d99c:	00000706 	br	8113d9bc <OSQPendAbort+0x160>
8113d9a0:	e0bff917 	ldw	r2,-28(fp)
8113d9a4:	e0bffb15 	stw	r2,-20(fp)
8113d9a8:	e0bffb17 	ldw	r2,-20(fp)
8113d9ac:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113d9b0:	e0bfff17 	ldw	r2,-4(fp)
8113d9b4:	10000005 	stb	zero,0(r2)
    return (0);                                            /* No tasks waiting on queue                */
8113d9b8:	0005883a 	mov	r2,zero
}
8113d9bc:	e037883a 	mov	sp,fp
8113d9c0:	dfc00117 	ldw	ra,4(sp)
8113d9c4:	df000017 	ldw	fp,0(sp)
8113d9c8:	dec00204 	addi	sp,sp,8
8113d9cc:	f800283a 	ret

8113d9d0 <OSQPost>:
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *pmsg)
{
8113d9d0:	defff604 	addi	sp,sp,-40
8113d9d4:	de00012e 	bgeu	sp,et,8113d9dc <OSQPost+0xc>
8113d9d8:	003b68fa 	trap	3
8113d9dc:	dfc00915 	stw	ra,36(sp)
8113d9e0:	df000815 	stw	fp,32(sp)
8113d9e4:	df000804 	addi	fp,sp,32
8113d9e8:	e13ffe15 	stw	r4,-8(fp)
8113d9ec:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113d9f0:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
8113d9f4:	e0bffe17 	ldw	r2,-8(fp)
8113d9f8:	1000021e 	bne	r2,zero,8113da04 <OSQPost+0x34>
        return (OS_ERR_PEVENT_NULL);
8113d9fc:	00800104 	movi	r2,4
8113da00:	00004a06 	br	8113db2c <OSQPost+0x15c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
8113da04:	e0bffe17 	ldw	r2,-8(fp)
8113da08:	10800003 	ldbu	r2,0(r2)
8113da0c:	10803fcc 	andi	r2,r2,255
8113da10:	108000a0 	cmpeqi	r2,r2,2
8113da14:	1000021e 	bne	r2,zero,8113da20 <OSQPost+0x50>
        return (OS_ERR_EVENT_TYPE);
8113da18:	00800044 	movi	r2,1
8113da1c:	00004306 	br	8113db2c <OSQPost+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113da20:	0005303a 	rdctl	r2,status
8113da24:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113da28:	e0fffd17 	ldw	r3,-12(fp)
8113da2c:	00bfff84 	movi	r2,-2
8113da30:	1884703a 	and	r2,r3,r2
8113da34:	1001703a 	wrctl	status,r2
  
  return context;
8113da38:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113da3c:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                     /* See if any task pending on queue             */
8113da40:	e0bffe17 	ldw	r2,-8(fp)
8113da44:	10800283 	ldbu	r2,10(r2)
8113da48:	10803fcc 	andi	r2,r2,255
8113da4c:	10000c26 	beq	r2,zero,8113da80 <OSQPost+0xb0>
                                                       /* Ready highest priority task waiting on event */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8113da50:	000f883a 	mov	r7,zero
8113da54:	01800104 	movi	r6,4
8113da58:	e17fff17 	ldw	r5,-4(fp)
8113da5c:	e13ffe17 	ldw	r4,-8(fp)
8113da60:	1138b540 	call	81138b54 <OS_EventTaskRdy>
8113da64:	e0bff817 	ldw	r2,-32(fp)
8113da68:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113da6c:	e0bff917 	ldw	r2,-28(fp)
8113da70:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                    /* Find highest priority task ready to run      */
8113da74:	11396100 	call	81139610 <OS_Sched>
        return (OS_ERR_NONE);
8113da78:	0005883a 	mov	r2,zero
8113da7c:	00002b06 	br	8113db2c <OSQPost+0x15c>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
8113da80:	e0bffe17 	ldw	r2,-8(fp)
8113da84:	10800117 	ldw	r2,4(r2)
8113da88:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
8113da8c:	e0bffb17 	ldw	r2,-20(fp)
8113da90:	10c0058b 	ldhu	r3,22(r2)
8113da94:	e0bffb17 	ldw	r2,-20(fp)
8113da98:	1080050b 	ldhu	r2,20(r2)
8113da9c:	18ffffcc 	andi	r3,r3,65535
8113daa0:	10bfffcc 	andi	r2,r2,65535
8113daa4:	18800636 	bltu	r3,r2,8113dac0 <OSQPost+0xf0>
8113daa8:	e0bff817 	ldw	r2,-32(fp)
8113daac:	e0bffa15 	stw	r2,-24(fp)
8113dab0:	e0bffa17 	ldw	r2,-24(fp)
8113dab4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
8113dab8:	00800784 	movi	r2,30
8113dabc:	00001b06 	br	8113db2c <OSQPost+0x15c>
    }
    *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
8113dac0:	e0bffb17 	ldw	r2,-20(fp)
8113dac4:	10800317 	ldw	r2,12(r2)
8113dac8:	11000104 	addi	r4,r2,4
8113dacc:	e0fffb17 	ldw	r3,-20(fp)
8113dad0:	19000315 	stw	r4,12(r3)
8113dad4:	e0ffff17 	ldw	r3,-4(fp)
8113dad8:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
8113dadc:	e0bffb17 	ldw	r2,-20(fp)
8113dae0:	1080058b 	ldhu	r2,22(r2)
8113dae4:	10800044 	addi	r2,r2,1
8113dae8:	1007883a 	mov	r3,r2
8113daec:	e0bffb17 	ldw	r2,-20(fp)
8113daf0:	10c0058d 	sth	r3,22(r2)
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
8113daf4:	e0bffb17 	ldw	r2,-20(fp)
8113daf8:	10c00317 	ldw	r3,12(r2)
8113dafc:	e0bffb17 	ldw	r2,-20(fp)
8113db00:	10800217 	ldw	r2,8(r2)
8113db04:	1880041e 	bne	r3,r2,8113db18 <OSQPost+0x148>
        pq->OSQIn = pq->OSQStart;
8113db08:	e0bffb17 	ldw	r2,-20(fp)
8113db0c:	10c00117 	ldw	r3,4(r2)
8113db10:	e0bffb17 	ldw	r2,-20(fp)
8113db14:	10c00315 	stw	r3,12(r2)
8113db18:	e0bff817 	ldw	r2,-32(fp)
8113db1c:	e0bffc15 	stw	r2,-16(fp)
8113db20:	e0bffc17 	ldw	r2,-16(fp)
8113db24:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113db28:	0005883a 	mov	r2,zero
}
8113db2c:	e037883a 	mov	sp,fp
8113db30:	dfc00117 	ldw	ra,4(sp)
8113db34:	df000017 	ldw	fp,0(sp)
8113db38:	dec00204 	addi	sp,sp,8
8113db3c:	f800283a 	ret

8113db40 <OSQPostFront>:
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *pmsg)
{
8113db40:	defff604 	addi	sp,sp,-40
8113db44:	de00012e 	bgeu	sp,et,8113db4c <OSQPostFront+0xc>
8113db48:	003b68fa 	trap	3
8113db4c:	dfc00915 	stw	ra,36(sp)
8113db50:	df000815 	stw	fp,32(sp)
8113db54:	df000804 	addi	fp,sp,32
8113db58:	e13ffe15 	stw	r4,-8(fp)
8113db5c:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113db60:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113db64:	e0bffe17 	ldw	r2,-8(fp)
8113db68:	1000021e 	bne	r2,zero,8113db74 <OSQPostFront+0x34>
        return (OS_ERR_PEVENT_NULL);
8113db6c:	00800104 	movi	r2,4
8113db70:	00004c06 	br	8113dca4 <OSQPostFront+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
8113db74:	e0bffe17 	ldw	r2,-8(fp)
8113db78:	10800003 	ldbu	r2,0(r2)
8113db7c:	10803fcc 	andi	r2,r2,255
8113db80:	108000a0 	cmpeqi	r2,r2,2
8113db84:	1000021e 	bne	r2,zero,8113db90 <OSQPostFront+0x50>
        return (OS_ERR_EVENT_TYPE);
8113db88:	00800044 	movi	r2,1
8113db8c:	00004506 	br	8113dca4 <OSQPostFront+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113db90:	0005303a 	rdctl	r2,status
8113db94:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113db98:	e0fffd17 	ldw	r3,-12(fp)
8113db9c:	00bfff84 	movi	r2,-2
8113dba0:	1884703a 	and	r2,r3,r2
8113dba4:	1001703a 	wrctl	status,r2
  
  return context;
8113dba8:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113dbac:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on queue              */
8113dbb0:	e0bffe17 	ldw	r2,-8(fp)
8113dbb4:	10800283 	ldbu	r2,10(r2)
8113dbb8:	10803fcc 	andi	r2,r2,255
8113dbbc:	10000c26 	beq	r2,zero,8113dbf0 <OSQPostFront+0xb0>
                                                      /* Ready highest priority task waiting on event  */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8113dbc0:	000f883a 	mov	r7,zero
8113dbc4:	01800104 	movi	r6,4
8113dbc8:	e17fff17 	ldw	r5,-4(fp)
8113dbcc:	e13ffe17 	ldw	r4,-8(fp)
8113dbd0:	1138b540 	call	81138b54 <OS_EventTaskRdy>
8113dbd4:	e0bff817 	ldw	r2,-32(fp)
8113dbd8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113dbdc:	e0bff917 	ldw	r2,-28(fp)
8113dbe0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find highest priority task ready to run       */
8113dbe4:	11396100 	call	81139610 <OS_Sched>
        return (OS_ERR_NONE);
8113dbe8:	0005883a 	mov	r2,zero
8113dbec:	00002d06 	br	8113dca4 <OSQPostFront+0x164>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
8113dbf0:	e0bffe17 	ldw	r2,-8(fp)
8113dbf4:	10800117 	ldw	r2,4(r2)
8113dbf8:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
8113dbfc:	e0bffb17 	ldw	r2,-20(fp)
8113dc00:	10c0058b 	ldhu	r3,22(r2)
8113dc04:	e0bffb17 	ldw	r2,-20(fp)
8113dc08:	1080050b 	ldhu	r2,20(r2)
8113dc0c:	18ffffcc 	andi	r3,r3,65535
8113dc10:	10bfffcc 	andi	r2,r2,65535
8113dc14:	18800636 	bltu	r3,r2,8113dc30 <OSQPostFront+0xf0>
8113dc18:	e0bff817 	ldw	r2,-32(fp)
8113dc1c:	e0bffa15 	stw	r2,-24(fp)
8113dc20:	e0bffa17 	ldw	r2,-24(fp)
8113dc24:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
8113dc28:	00800784 	movi	r2,30
8113dc2c:	00001d06 	br	8113dca4 <OSQPostFront+0x164>
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
8113dc30:	e0bffb17 	ldw	r2,-20(fp)
8113dc34:	10c00417 	ldw	r3,16(r2)
8113dc38:	e0bffb17 	ldw	r2,-20(fp)
8113dc3c:	10800117 	ldw	r2,4(r2)
8113dc40:	1880041e 	bne	r3,r2,8113dc54 <OSQPostFront+0x114>
        pq->OSQOut = pq->OSQEnd;
8113dc44:	e0bffb17 	ldw	r2,-20(fp)
8113dc48:	10c00217 	ldw	r3,8(r2)
8113dc4c:	e0bffb17 	ldw	r2,-20(fp)
8113dc50:	10c00415 	stw	r3,16(r2)
    }
    pq->OSQOut--;
8113dc54:	e0bffb17 	ldw	r2,-20(fp)
8113dc58:	10800417 	ldw	r2,16(r2)
8113dc5c:	10ffff04 	addi	r3,r2,-4
8113dc60:	e0bffb17 	ldw	r2,-20(fp)
8113dc64:	10c00415 	stw	r3,16(r2)
    *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
8113dc68:	e0bffb17 	ldw	r2,-20(fp)
8113dc6c:	10800417 	ldw	r2,16(r2)
8113dc70:	e0ffff17 	ldw	r3,-4(fp)
8113dc74:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
8113dc78:	e0bffb17 	ldw	r2,-20(fp)
8113dc7c:	1080058b 	ldhu	r2,22(r2)
8113dc80:	10800044 	addi	r2,r2,1
8113dc84:	1007883a 	mov	r3,r2
8113dc88:	e0bffb17 	ldw	r2,-20(fp)
8113dc8c:	10c0058d 	sth	r3,22(r2)
8113dc90:	e0bff817 	ldw	r2,-32(fp)
8113dc94:	e0bffc15 	stw	r2,-16(fp)
8113dc98:	e0bffc17 	ldw	r2,-16(fp)
8113dc9c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113dca0:	0005883a 	mov	r2,zero
}
8113dca4:	e037883a 	mov	sp,fp
8113dca8:	dfc00117 	ldw	ra,4(sp)
8113dcac:	df000017 	ldw	fp,0(sp)
8113dcb0:	dec00204 	addi	sp,sp,8
8113dcb4:	f800283a 	ret

8113dcb8 <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
{
8113dcb8:	defff504 	addi	sp,sp,-44
8113dcbc:	de00012e 	bgeu	sp,et,8113dcc4 <OSQPostOpt+0xc>
8113dcc0:	003b68fa 	trap	3
8113dcc4:	dfc00a15 	stw	ra,40(sp)
8113dcc8:	df000915 	stw	fp,36(sp)
8113dccc:	df000904 	addi	fp,sp,36
8113dcd0:	e13ffd15 	stw	r4,-12(fp)
8113dcd4:	e17ffe15 	stw	r5,-8(fp)
8113dcd8:	3005883a 	mov	r2,r6
8113dcdc:	e0bfff05 	stb	r2,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113dce0:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113dce4:	e0bffd17 	ldw	r2,-12(fp)
8113dce8:	1000021e 	bne	r2,zero,8113dcf4 <OSQPostOpt+0x3c>
        return (OS_ERR_PEVENT_NULL);
8113dcec:	00800104 	movi	r2,4
8113dcf0:	00007106 	br	8113deb8 <OSQPostOpt+0x200>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
8113dcf4:	e0bffd17 	ldw	r2,-12(fp)
8113dcf8:	10800003 	ldbu	r2,0(r2)
8113dcfc:	10803fcc 	andi	r2,r2,255
8113dd00:	108000a0 	cmpeqi	r2,r2,2
8113dd04:	1000021e 	bne	r2,zero,8113dd10 <OSQPostOpt+0x58>
        return (OS_ERR_EVENT_TYPE);
8113dd08:	00800044 	movi	r2,1
8113dd0c:	00006a06 	br	8113deb8 <OSQPostOpt+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113dd10:	0005303a 	rdctl	r2,status
8113dd14:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113dd18:	e0fffc17 	ldw	r3,-16(fp)
8113dd1c:	00bfff84 	movi	r2,-2
8113dd20:	1884703a 	and	r2,r3,r2
8113dd24:	1001703a 	wrctl	status,r2
  
  return context;
8113dd28:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113dd2c:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
8113dd30:	e0bffd17 	ldw	r2,-12(fp)
8113dd34:	10800283 	ldbu	r2,10(r2)
8113dd38:	10803fcc 	andi	r2,r2,255
8113dd3c:	10001d26 	beq	r2,zero,8113ddb4 <OSQPostOpt+0xfc>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
8113dd40:	e0bfff03 	ldbu	r2,-4(fp)
8113dd44:	1080004c 	andi	r2,r2,1
8113dd48:	10000b26 	beq	r2,zero,8113dd78 <OSQPostOpt+0xc0>
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
8113dd4c:	00000506 	br	8113dd64 <OSQPostOpt+0xac>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8113dd50:	000f883a 	mov	r7,zero
8113dd54:	01800104 	movi	r6,4
8113dd58:	e17ffe17 	ldw	r5,-8(fp)
8113dd5c:	e13ffd17 	ldw	r4,-12(fp)
8113dd60:	1138b540 	call	81138b54 <OS_EventTaskRdy>
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
8113dd64:	e0bffd17 	ldw	r2,-12(fp)
8113dd68:	10800283 	ldbu	r2,10(r2)
8113dd6c:	10803fcc 	andi	r2,r2,255
8113dd70:	103ff71e 	bne	r2,zero,8113dd50 <__reset+0xfb11dd50>
8113dd74:	00000506 	br	8113dd8c <OSQPostOpt+0xd4>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on queue             */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8113dd78:	000f883a 	mov	r7,zero
8113dd7c:	01800104 	movi	r6,4
8113dd80:	e17ffe17 	ldw	r5,-8(fp)
8113dd84:	e13ffd17 	ldw	r4,-12(fp)
8113dd88:	1138b540 	call	81138b54 <OS_EventTaskRdy>
8113dd8c:	e0bff717 	ldw	r2,-36(fp)
8113dd90:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113dd94:	e0bff817 	ldw	r2,-32(fp)
8113dd98:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
8113dd9c:	e0bfff03 	ldbu	r2,-4(fp)
8113dda0:	1080010c 	andi	r2,r2,4
8113dda4:	1000011e 	bne	r2,zero,8113ddac <OSQPostOpt+0xf4>
            OS_Sched();                               /* Find highest priority task ready to run       */
8113dda8:	11396100 	call	81139610 <OS_Sched>
        }
        return (OS_ERR_NONE);
8113ddac:	0005883a 	mov	r2,zero
8113ddb0:	00004106 	br	8113deb8 <OSQPostOpt+0x200>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
8113ddb4:	e0bffd17 	ldw	r2,-12(fp)
8113ddb8:	10800117 	ldw	r2,4(r2)
8113ddbc:	e0bffa15 	stw	r2,-24(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
8113ddc0:	e0bffa17 	ldw	r2,-24(fp)
8113ddc4:	10c0058b 	ldhu	r3,22(r2)
8113ddc8:	e0bffa17 	ldw	r2,-24(fp)
8113ddcc:	1080050b 	ldhu	r2,20(r2)
8113ddd0:	18ffffcc 	andi	r3,r3,65535
8113ddd4:	10bfffcc 	andi	r2,r2,65535
8113ddd8:	18800636 	bltu	r3,r2,8113ddf4 <OSQPostOpt+0x13c>
8113dddc:	e0bff717 	ldw	r2,-36(fp)
8113dde0:	e0bff915 	stw	r2,-28(fp)
8113dde4:	e0bff917 	ldw	r2,-28(fp)
8113dde8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
8113ddec:	00800784 	movi	r2,30
8113ddf0:	00003106 	br	8113deb8 <OSQPostOpt+0x200>
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
8113ddf4:	e0bfff03 	ldbu	r2,-4(fp)
8113ddf8:	1080008c 	andi	r2,r2,2
8113ddfc:	10001326 	beq	r2,zero,8113de4c <OSQPostOpt+0x194>
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
8113de00:	e0bffa17 	ldw	r2,-24(fp)
8113de04:	10c00417 	ldw	r3,16(r2)
8113de08:	e0bffa17 	ldw	r2,-24(fp)
8113de0c:	10800117 	ldw	r2,4(r2)
8113de10:	1880041e 	bne	r3,r2,8113de24 <OSQPostOpt+0x16c>
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
8113de14:	e0bffa17 	ldw	r2,-24(fp)
8113de18:	10c00217 	ldw	r3,8(r2)
8113de1c:	e0bffa17 	ldw	r2,-24(fp)
8113de20:	10c00415 	stw	r3,16(r2)
        }
        pq->OSQOut--;
8113de24:	e0bffa17 	ldw	r2,-24(fp)
8113de28:	10800417 	ldw	r2,16(r2)
8113de2c:	10ffff04 	addi	r3,r2,-4
8113de30:	e0bffa17 	ldw	r2,-24(fp)
8113de34:	10c00415 	stw	r3,16(r2)
        *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
8113de38:	e0bffa17 	ldw	r2,-24(fp)
8113de3c:	10800417 	ldw	r2,16(r2)
8113de40:	e0fffe17 	ldw	r3,-8(fp)
8113de44:	10c00015 	stw	r3,0(r2)
8113de48:	00001006 	br	8113de8c <OSQPostOpt+0x1d4>
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
8113de4c:	e0bffa17 	ldw	r2,-24(fp)
8113de50:	10800317 	ldw	r2,12(r2)
8113de54:	11000104 	addi	r4,r2,4
8113de58:	e0fffa17 	ldw	r3,-24(fp)
8113de5c:	19000315 	stw	r4,12(r3)
8113de60:	e0fffe17 	ldw	r3,-8(fp)
8113de64:	10c00015 	stw	r3,0(r2)
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
8113de68:	e0bffa17 	ldw	r2,-24(fp)
8113de6c:	10c00317 	ldw	r3,12(r2)
8113de70:	e0bffa17 	ldw	r2,-24(fp)
8113de74:	10800217 	ldw	r2,8(r2)
8113de78:	1880041e 	bne	r3,r2,8113de8c <OSQPostOpt+0x1d4>
            pq->OSQIn = pq->OSQStart;
8113de7c:	e0bffa17 	ldw	r2,-24(fp)
8113de80:	10c00117 	ldw	r3,4(r2)
8113de84:	e0bffa17 	ldw	r2,-24(fp)
8113de88:	10c00315 	stw	r3,12(r2)
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
8113de8c:	e0bffa17 	ldw	r2,-24(fp)
8113de90:	1080058b 	ldhu	r2,22(r2)
8113de94:	10800044 	addi	r2,r2,1
8113de98:	1007883a 	mov	r3,r2
8113de9c:	e0bffa17 	ldw	r2,-24(fp)
8113dea0:	10c0058d 	sth	r3,22(r2)
8113dea4:	e0bff717 	ldw	r2,-36(fp)
8113dea8:	e0bffb15 	stw	r2,-20(fp)
8113deac:	e0bffb17 	ldw	r2,-20(fp)
8113deb0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113deb4:	0005883a 	mov	r2,zero
}
8113deb8:	e037883a 	mov	sp,fp
8113debc:	dfc00117 	ldw	ra,4(sp)
8113dec0:	df000017 	ldw	fp,0(sp)
8113dec4:	dec00204 	addi	sp,sp,8
8113dec8:	f800283a 	ret

8113decc <OSQQuery>:
*********************************************************************************************************
*/

#if OS_Q_QUERY_EN > 0
INT8U  OSQQuery (OS_EVENT *pevent, OS_Q_DATA *p_q_data)
{
8113decc:	defff604 	addi	sp,sp,-40
8113ded0:	de00012e 	bgeu	sp,et,8113ded8 <OSQQuery+0xc>
8113ded4:	003b68fa 	trap	3
8113ded8:	df000915 	stw	fp,36(sp)
8113dedc:	df000904 	addi	fp,sp,36
8113dee0:	e13ffe15 	stw	r4,-8(fp)
8113dee4:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113dee8:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
8113deec:	e0bffe17 	ldw	r2,-8(fp)
8113def0:	1000021e 	bne	r2,zero,8113defc <OSQQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
8113def4:	00800104 	movi	r2,4
8113def8:	00004906 	br	8113e020 <OSQQuery+0x154>
    }
    if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
8113defc:	e0bfff17 	ldw	r2,-4(fp)
8113df00:	1000021e 	bne	r2,zero,8113df0c <OSQQuery+0x40>
        return (OS_ERR_PDATA_NULL);
8113df04:	00800244 	movi	r2,9
8113df08:	00004506 	br	8113e020 <OSQQuery+0x154>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
8113df0c:	e0bffe17 	ldw	r2,-8(fp)
8113df10:	10800003 	ldbu	r2,0(r2)
8113df14:	10803fcc 	andi	r2,r2,255
8113df18:	108000a0 	cmpeqi	r2,r2,2
8113df1c:	1000021e 	bne	r2,zero,8113df28 <OSQQuery+0x5c>
        return (OS_ERR_EVENT_TYPE);
8113df20:	00800044 	movi	r2,1
8113df24:	00003e06 	br	8113e020 <OSQQuery+0x154>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113df28:	0005303a 	rdctl	r2,status
8113df2c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113df30:	e0fffd17 	ldw	r3,-12(fp)
8113df34:	00bfff84 	movi	r2,-2
8113df38:	1884703a 	and	r2,r3,r2
8113df3c:	1001703a 	wrctl	status,r2
  
  return context;
8113df40:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113df44:	e0bffa15 	stw	r2,-24(fp)
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
8113df48:	e0bffe17 	ldw	r2,-8(fp)
8113df4c:	10c00283 	ldbu	r3,10(r2)
8113df50:	e0bfff17 	ldw	r2,-4(fp)
8113df54:	10c00385 	stb	r3,14(r2)
    psrc                 = &pevent->OSEventTbl[0];
8113df58:	e0bffe17 	ldw	r2,-8(fp)
8113df5c:	108002c4 	addi	r2,r2,11
8113df60:	e0bff815 	stw	r2,-32(fp)
    pdest                = &p_q_data->OSEventTbl[0];
8113df64:	e0bfff17 	ldw	r2,-4(fp)
8113df68:	10800204 	addi	r2,r2,8
8113df6c:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113df70:	e03ff705 	stb	zero,-36(fp)
8113df74:	00000b06 	br	8113dfa4 <OSQQuery+0xd8>
        *pdest++ = *psrc++;
8113df78:	e0bff917 	ldw	r2,-28(fp)
8113df7c:	10c00044 	addi	r3,r2,1
8113df80:	e0fff915 	stw	r3,-28(fp)
8113df84:	e0fff817 	ldw	r3,-32(fp)
8113df88:	19000044 	addi	r4,r3,1
8113df8c:	e13ff815 	stw	r4,-32(fp)
8113df90:	18c00003 	ldbu	r3,0(r3)
8113df94:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113df98:	e0bff703 	ldbu	r2,-36(fp)
8113df9c:	10800044 	addi	r2,r2,1
8113dfa0:	e0bff705 	stb	r2,-36(fp)
8113dfa4:	e0bff703 	ldbu	r2,-36(fp)
8113dfa8:	108001b0 	cmpltui	r2,r2,6
8113dfac:	103ff21e 	bne	r2,zero,8113df78 <__reset+0xfb11df78>
        *pdest++ = *psrc++;
    }
    pq = (OS_Q *)pevent->OSEventPtr;
8113dfb0:	e0bffe17 	ldw	r2,-8(fp)
8113dfb4:	10800117 	ldw	r2,4(r2)
8113dfb8:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {
8113dfbc:	e0bffc17 	ldw	r2,-16(fp)
8113dfc0:	1080058b 	ldhu	r2,22(r2)
8113dfc4:	10bfffcc 	andi	r2,r2,65535
8113dfc8:	10000626 	beq	r2,zero,8113dfe4 <OSQQuery+0x118>
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
8113dfcc:	e0bffc17 	ldw	r2,-16(fp)
8113dfd0:	10800417 	ldw	r2,16(r2)
8113dfd4:	10c00017 	ldw	r3,0(r2)
8113dfd8:	e0bfff17 	ldw	r2,-4(fp)
8113dfdc:	10c00015 	stw	r3,0(r2)
8113dfe0:	00000206 	br	8113dfec <OSQQuery+0x120>
    } else {
        p_q_data->OSMsg = (void *)0;
8113dfe4:	e0bfff17 	ldw	r2,-4(fp)
8113dfe8:	10000015 	stw	zero,0(r2)
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
8113dfec:	e0bffc17 	ldw	r2,-16(fp)
8113dff0:	10c0058b 	ldhu	r3,22(r2)
8113dff4:	e0bfff17 	ldw	r2,-4(fp)
8113dff8:	10c0010d 	sth	r3,4(r2)
    p_q_data->OSQSize = pq->OSQSize;
8113dffc:	e0bffc17 	ldw	r2,-16(fp)
8113e000:	10c0050b 	ldhu	r3,20(r2)
8113e004:	e0bfff17 	ldw	r2,-4(fp)
8113e008:	10c0018d 	sth	r3,6(r2)
8113e00c:	e0bffa17 	ldw	r2,-24(fp)
8113e010:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e014:	e0bffb17 	ldw	r2,-20(fp)
8113e018:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113e01c:	0005883a 	mov	r2,zero
}
8113e020:	e037883a 	mov	sp,fp
8113e024:	df000017 	ldw	fp,0(sp)
8113e028:	dec00104 	addi	sp,sp,4
8113e02c:	f800283a 	ret

8113e030 <OS_QInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
8113e030:	defffb04 	addi	sp,sp,-20
8113e034:	de00012e 	bgeu	sp,et,8113e03c <OS_QInit+0xc>
8113e038:	003b68fa 	trap	3
8113e03c:	dfc00415 	stw	ra,16(sp)
8113e040:	df000315 	stw	fp,12(sp)
8113e044:	df000304 	addi	fp,sp,12
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
8113e048:	0140c004 	movi	r5,768
8113e04c:	012045f4 	movhi	r4,33047
8113e050:	21237004 	addi	r4,r4,-29248
8113e054:	11395440 	call	81139544 <OS_MemClr>
    pq1 = &OSQTbl[0];
8113e058:	00a045f4 	movhi	r2,33047
8113e05c:	10a37004 	addi	r2,r2,-29248
8113e060:	e0bffe15 	stw	r2,-8(fp)
    pq2 = &OSQTbl[1];
8113e064:	00a045f4 	movhi	r2,33047
8113e068:	10a37604 	addi	r2,r2,-29224
8113e06c:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
8113e070:	e03ffd0d 	sth	zero,-12(fp)
8113e074:	00000c06 	br	8113e0a8 <OS_QInit+0x78>
        pq1->OSQPtr = pq2;
8113e078:	e0bffe17 	ldw	r2,-8(fp)
8113e07c:	e0ffff17 	ldw	r3,-4(fp)
8113e080:	10c00015 	stw	r3,0(r2)
        pq1++;
8113e084:	e0bffe17 	ldw	r2,-8(fp)
8113e088:	10800604 	addi	r2,r2,24
8113e08c:	e0bffe15 	stw	r2,-8(fp)
        pq2++;
8113e090:	e0bfff17 	ldw	r2,-4(fp)
8113e094:	10800604 	addi	r2,r2,24
8113e098:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
8113e09c:	e0bffd0b 	ldhu	r2,-12(fp)
8113e0a0:	10800044 	addi	r2,r2,1
8113e0a4:	e0bffd0d 	sth	r2,-12(fp)
8113e0a8:	e0bffd0b 	ldhu	r2,-12(fp)
8113e0ac:	108007f0 	cmpltui	r2,r2,31
8113e0b0:	103ff11e 	bne	r2,zero,8113e078 <__reset+0xfb11e078>
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
8113e0b4:	e0bffe17 	ldw	r2,-8(fp)
8113e0b8:	10000015 	stw	zero,0(r2)
    OSQFreeList = &OSQTbl[0];
8113e0bc:	00a045f4 	movhi	r2,33047
8113e0c0:	10a37004 	addi	r2,r2,-29248
8113e0c4:	d0a09d15 	stw	r2,-32140(gp)
#endif
}
8113e0c8:	0001883a 	nop
8113e0cc:	e037883a 	mov	sp,fp
8113e0d0:	dfc00117 	ldw	ra,4(sp)
8113e0d4:	df000017 	ldw	fp,0(sp)
8113e0d8:	dec00204 	addi	sp,sp,8
8113e0dc:	f800283a 	ret

8113e0e0 <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0
INT16U  OSSemAccept (OS_EVENT *pevent)
{
8113e0e0:	defffa04 	addi	sp,sp,-24
8113e0e4:	de00012e 	bgeu	sp,et,8113e0ec <OSSemAccept+0xc>
8113e0e8:	003b68fa 	trap	3
8113e0ec:	df000515 	stw	fp,20(sp)
8113e0f0:	df000504 	addi	fp,sp,20
8113e0f4:	e13fff15 	stw	r4,-4(fp)
    INT16U     cnt;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113e0f8:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113e0fc:	e0bfff17 	ldw	r2,-4(fp)
8113e100:	1000021e 	bne	r2,zero,8113e10c <OSSemAccept+0x2c>
        return (0);
8113e104:	0005883a 	mov	r2,zero
8113e108:	00001f06 	br	8113e188 <OSSemAccept+0xa8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113e10c:	e0bfff17 	ldw	r2,-4(fp)
8113e110:	10800003 	ldbu	r2,0(r2)
8113e114:	10803fcc 	andi	r2,r2,255
8113e118:	108000e0 	cmpeqi	r2,r2,3
8113e11c:	1000021e 	bne	r2,zero,8113e128 <OSSemAccept+0x48>
        return (0);
8113e120:	0005883a 	mov	r2,zero
8113e124:	00001806 	br	8113e188 <OSSemAccept+0xa8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e128:	0005303a 	rdctl	r2,status
8113e12c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e130:	e0fffe17 	ldw	r3,-8(fp)
8113e134:	00bfff84 	movi	r2,-2
8113e138:	1884703a 	and	r2,r3,r2
8113e13c:	1001703a 	wrctl	status,r2
  
  return context;
8113e140:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113e144:	e0bffb15 	stw	r2,-20(fp)
    cnt = pevent->OSEventCnt;
8113e148:	e0bfff17 	ldw	r2,-4(fp)
8113e14c:	1080020b 	ldhu	r2,8(r2)
8113e150:	e0bffd0d 	sth	r2,-12(fp)
    if (cnt > 0) {                                    /* See if resource is available                  */
8113e154:	e0bffd0b 	ldhu	r2,-12(fp)
8113e158:	10000626 	beq	r2,zero,8113e174 <OSSemAccept+0x94>
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
8113e15c:	e0bfff17 	ldw	r2,-4(fp)
8113e160:	1080020b 	ldhu	r2,8(r2)
8113e164:	10bfffc4 	addi	r2,r2,-1
8113e168:	1007883a 	mov	r3,r2
8113e16c:	e0bfff17 	ldw	r2,-4(fp)
8113e170:	10c0020d 	sth	r3,8(r2)
8113e174:	e0bffb17 	ldw	r2,-20(fp)
8113e178:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e17c:	e0bffc17 	ldw	r2,-16(fp)
8113e180:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (cnt);                                     /* Return semaphore count                        */
8113e184:	e0bffd0b 	ldhu	r2,-12(fp)
}
8113e188:	e037883a 	mov	sp,fp
8113e18c:	df000017 	ldw	fp,0(sp)
8113e190:	dec00104 	addi	sp,sp,4
8113e194:	f800283a 	ret

8113e198 <OSSemCreate>:
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
8113e198:	defff904 	addi	sp,sp,-28
8113e19c:	de00012e 	bgeu	sp,et,8113e1a4 <OSSemCreate+0xc>
8113e1a0:	003b68fa 	trap	3
8113e1a4:	dfc00615 	stw	ra,24(sp)
8113e1a8:	df000515 	stw	fp,20(sp)
8113e1ac:	df000504 	addi	fp,sp,20
8113e1b0:	2005883a 	mov	r2,r4
8113e1b4:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113e1b8:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113e1bc:	d0a0a103 	ldbu	r2,-32124(gp)
8113e1c0:	10803fcc 	andi	r2,r2,255
8113e1c4:	10000226 	beq	r2,zero,8113e1d0 <OSSemCreate+0x38>
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
8113e1c8:	0005883a 	mov	r2,zero
8113e1cc:	00002506 	br	8113e264 <OSSemCreate+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e1d0:	0005303a 	rdctl	r2,status
8113e1d4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e1d8:	e0fffe17 	ldw	r3,-8(fp)
8113e1dc:	00bfff84 	movi	r2,-2
8113e1e0:	1884703a 	and	r2,r3,r2
8113e1e4:	1001703a 	wrctl	status,r2
  
  return context;
8113e1e8:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113e1ec:	e0bffb15 	stw	r2,-20(fp)
    pevent = OSEventFreeList;                              /* Get next free event control block        */
8113e1f0:	d0a0a017 	ldw	r2,-32128(gp)
8113e1f4:	e0bffd15 	stw	r2,-12(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
8113e1f8:	d0a0a017 	ldw	r2,-32128(gp)
8113e1fc:	10000326 	beq	r2,zero,8113e20c <OSSemCreate+0x74>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
8113e200:	d0a0a017 	ldw	r2,-32128(gp)
8113e204:	10800117 	ldw	r2,4(r2)
8113e208:	d0a0a015 	stw	r2,-32128(gp)
8113e20c:	e0bffb17 	ldw	r2,-20(fp)
8113e210:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e214:	e0bffc17 	ldw	r2,-16(fp)
8113e218:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
8113e21c:	e0bffd17 	ldw	r2,-12(fp)
8113e220:	10000f26 	beq	r2,zero,8113e260 <OSSemCreate+0xc8>
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
8113e224:	e0bffd17 	ldw	r2,-12(fp)
8113e228:	00c000c4 	movi	r3,3
8113e22c:	10c00005 	stb	r3,0(r2)
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
8113e230:	e0bffd17 	ldw	r2,-12(fp)
8113e234:	e0ffff0b 	ldhu	r3,-4(fp)
8113e238:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
8113e23c:	e0bffd17 	ldw	r2,-12(fp)
8113e240:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
8113e244:	e0bffd17 	ldw	r2,-12(fp)
8113e248:	00c00fc4 	movi	r3,63
8113e24c:	10c00445 	stb	r3,17(r2)
        pevent->OSEventName[1] = OS_ASCII_NUL;
8113e250:	e0bffd17 	ldw	r2,-12(fp)
8113e254:	10000485 	stb	zero,18(r2)
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
8113e258:	e13ffd17 	ldw	r4,-12(fp)
8113e25c:	113912c0 	call	8113912c <OS_EventWaitListInit>
    }
    return (pevent);
8113e260:	e0bffd17 	ldw	r2,-12(fp)
}
8113e264:	e037883a 	mov	sp,fp
8113e268:	dfc00117 	ldw	ra,4(sp)
8113e26c:	df000017 	ldw	fp,0(sp)
8113e270:	dec00204 	addi	sp,sp,8
8113e274:	f800283a 	ret

8113e278 <OSSemDel>:
*********************************************************************************************************
*/

#if OS_SEM_DEL_EN > 0
OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113e278:	defff304 	addi	sp,sp,-52
8113e27c:	de00012e 	bgeu	sp,et,8113e284 <OSSemDel+0xc>
8113e280:	003b68fa 	trap	3
8113e284:	dfc00c15 	stw	ra,48(sp)
8113e288:	df000b15 	stw	fp,44(sp)
8113e28c:	df000b04 	addi	fp,sp,44
8113e290:	e13ffd15 	stw	r4,-12(fp)
8113e294:	2805883a 	mov	r2,r5
8113e298:	e1bfff15 	stw	r6,-4(fp)
8113e29c:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113e2a0:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113e2a4:	e0bfff17 	ldw	r2,-4(fp)
8113e2a8:	1000021e 	bne	r2,zero,8113e2b4 <OSSemDel+0x3c>
        return (pevent);
8113e2ac:	e0bffd17 	ldw	r2,-12(fp)
8113e2b0:	00007e06 	br	8113e4ac <OSSemDel+0x234>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113e2b4:	e0bffd17 	ldw	r2,-12(fp)
8113e2b8:	1000051e 	bne	r2,zero,8113e2d0 <OSSemDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113e2bc:	e0bfff17 	ldw	r2,-4(fp)
8113e2c0:	00c00104 	movi	r3,4
8113e2c4:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113e2c8:	e0bffd17 	ldw	r2,-12(fp)
8113e2cc:	00007706 	br	8113e4ac <OSSemDel+0x234>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
8113e2d0:	e0bffd17 	ldw	r2,-12(fp)
8113e2d4:	10800003 	ldbu	r2,0(r2)
8113e2d8:	10803fcc 	andi	r2,r2,255
8113e2dc:	108000e0 	cmpeqi	r2,r2,3
8113e2e0:	1000051e 	bne	r2,zero,8113e2f8 <OSSemDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113e2e4:	e0bfff17 	ldw	r2,-4(fp)
8113e2e8:	00c00044 	movi	r3,1
8113e2ec:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113e2f0:	e0bffd17 	ldw	r2,-12(fp)
8113e2f4:	00006d06 	br	8113e4ac <OSSemDel+0x234>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113e2f8:	d0a0a103 	ldbu	r2,-32124(gp)
8113e2fc:	10803fcc 	andi	r2,r2,255
8113e300:	10000526 	beq	r2,zero,8113e318 <OSSemDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
8113e304:	e0bfff17 	ldw	r2,-4(fp)
8113e308:	00c003c4 	movi	r3,15
8113e30c:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113e310:	e0bffd17 	ldw	r2,-12(fp)
8113e314:	00006506 	br	8113e4ac <OSSemDel+0x234>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e318:	0005303a 	rdctl	r2,status
8113e31c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e320:	e0fffc17 	ldw	r3,-16(fp)
8113e324:	00bfff84 	movi	r2,-2
8113e328:	1884703a 	and	r2,r3,r2
8113e32c:	1001703a 	wrctl	status,r2
  
  return context;
8113e330:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113e334:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
8113e338:	e0bffd17 	ldw	r2,-12(fp)
8113e33c:	10800283 	ldbu	r2,10(r2)
8113e340:	10803fcc 	andi	r2,r2,255
8113e344:	10000326 	beq	r2,zero,8113e354 <OSSemDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8113e348:	00800044 	movi	r2,1
8113e34c:	e0bff505 	stb	r2,-44(fp)
8113e350:	00000106 	br	8113e358 <OSSemDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8113e354:	e03ff505 	stb	zero,-44(fp)
    }
    switch (opt) {
8113e358:	e0bffe03 	ldbu	r2,-8(fp)
8113e35c:	10000326 	beq	r2,zero,8113e36c <OSSemDel+0xf4>
8113e360:	10800060 	cmpeqi	r2,r2,1
8113e364:	1000281e 	bne	r2,zero,8113e408 <OSSemDel+0x190>
8113e368:	00004506 	br	8113e480 <OSSemDel+0x208>
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == OS_FALSE) {
8113e36c:	e0bff503 	ldbu	r2,-44(fp)
8113e370:	1000161e 	bne	r2,zero,8113e3cc <OSSemDel+0x154>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
8113e374:	e0bffd17 	ldw	r2,-12(fp)
8113e378:	00c00fc4 	movi	r3,63
8113e37c:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
8113e380:	e0bffd17 	ldw	r2,-12(fp)
8113e384:	10000485 	stb	zero,18(r2)
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113e388:	e0bffd17 	ldw	r2,-12(fp)
8113e38c:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
8113e390:	d0e0a017 	ldw	r3,-32128(gp)
8113e394:	e0bffd17 	ldw	r2,-12(fp)
8113e398:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
8113e39c:	e0bffd17 	ldw	r2,-12(fp)
8113e3a0:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
8113e3a4:	e0bffd17 	ldw	r2,-12(fp)
8113e3a8:	d0a0a015 	stw	r2,-32128(gp)
8113e3ac:	e0bff717 	ldw	r2,-36(fp)
8113e3b0:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e3b4:	e0bff817 	ldw	r2,-32(fp)
8113e3b8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
8113e3bc:	e0bfff17 	ldw	r2,-4(fp)
8113e3c0:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
8113e3c4:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
8113e3c8:	00003706 	br	8113e4a8 <OSSemDel+0x230>
8113e3cc:	e0bff717 	ldw	r2,-36(fp)
8113e3d0:	e0bff915 	stw	r2,-28(fp)
8113e3d4:	e0bff917 	ldw	r2,-28(fp)
8113e3d8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
8113e3dc:	e0bfff17 	ldw	r2,-4(fp)
8113e3e0:	00c01244 	movi	r3,73
8113e3e4:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
8113e3e8:	e0bffd17 	ldw	r2,-12(fp)
8113e3ec:	e0bff615 	stw	r2,-40(fp)
             }
             break;
8113e3f0:	00002d06 	br	8113e4a8 <OSSemDel+0x230>

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
8113e3f4:	000f883a 	mov	r7,zero
8113e3f8:	01800044 	movi	r6,1
8113e3fc:	000b883a 	mov	r5,zero
8113e400:	e13ffd17 	ldw	r4,-12(fp)
8113e404:	1138b540 	call	81138b54 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
8113e408:	e0bffd17 	ldw	r2,-12(fp)
8113e40c:	10800283 	ldbu	r2,10(r2)
8113e410:	10803fcc 	andi	r2,r2,255
8113e414:	103ff71e 	bne	r2,zero,8113e3f4 <__reset+0xfb11e3f4>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
8113e418:	e0bffd17 	ldw	r2,-12(fp)
8113e41c:	00c00fc4 	movi	r3,63
8113e420:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
8113e424:	e0bffd17 	ldw	r2,-12(fp)
8113e428:	10000485 	stb	zero,18(r2)
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113e42c:	e0bffd17 	ldw	r2,-12(fp)
8113e430:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
8113e434:	d0e0a017 	ldw	r3,-32128(gp)
8113e438:	e0bffd17 	ldw	r2,-12(fp)
8113e43c:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
8113e440:	e0bffd17 	ldw	r2,-12(fp)
8113e444:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
8113e448:	e0bffd17 	ldw	r2,-12(fp)
8113e44c:	d0a0a015 	stw	r2,-32128(gp)
8113e450:	e0bff717 	ldw	r2,-36(fp)
8113e454:	e0bffa15 	stw	r2,-24(fp)
8113e458:	e0bffa17 	ldw	r2,-24(fp)
8113e45c:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8113e460:	e0bff503 	ldbu	r2,-44(fp)
8113e464:	10800058 	cmpnei	r2,r2,1
8113e468:	1000011e 	bne	r2,zero,8113e470 <OSSemDel+0x1f8>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8113e46c:	11396100 	call	81139610 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
8113e470:	e0bfff17 	ldw	r2,-4(fp)
8113e474:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
8113e478:	e03ff615 	stw	zero,-40(fp)
             break;
8113e47c:	00000a06 	br	8113e4a8 <OSSemDel+0x230>
8113e480:	e0bff717 	ldw	r2,-36(fp)
8113e484:	e0bffb15 	stw	r2,-20(fp)
8113e488:	e0bffb17 	ldw	r2,-20(fp)
8113e48c:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
8113e490:	e0bfff17 	ldw	r2,-4(fp)
8113e494:	00c001c4 	movi	r3,7
8113e498:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
8113e49c:	e0bffd17 	ldw	r2,-12(fp)
8113e4a0:	e0bff615 	stw	r2,-40(fp)
             break;
8113e4a4:	0001883a 	nop
    }
    return (pevent_return);
8113e4a8:	e0bff617 	ldw	r2,-40(fp)
}
8113e4ac:	e037883a 	mov	sp,fp
8113e4b0:	dfc00117 	ldw	ra,4(sp)
8113e4b4:	df000017 	ldw	fp,0(sp)
8113e4b8:	dec00204 	addi	sp,sp,8
8113e4bc:	f800283a 	ret

8113e4c0 <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/
/*$PAGE*/
void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
8113e4c0:	defff504 	addi	sp,sp,-44
8113e4c4:	de00012e 	bgeu	sp,et,8113e4cc <OSSemPend+0xc>
8113e4c8:	003b68fa 	trap	3
8113e4cc:	dfc00a15 	stw	ra,40(sp)
8113e4d0:	df000915 	stw	fp,36(sp)
8113e4d4:	df000904 	addi	fp,sp,36
8113e4d8:	e13ffd15 	stw	r4,-12(fp)
8113e4dc:	2805883a 	mov	r2,r5
8113e4e0:	e1bfff15 	stw	r6,-4(fp)
8113e4e4:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113e4e8:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113e4ec:	e0bfff17 	ldw	r2,-4(fp)
8113e4f0:	10007226 	beq	r2,zero,8113e6bc <OSSemPend+0x1fc>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113e4f4:	e0bffd17 	ldw	r2,-12(fp)
8113e4f8:	1000041e 	bne	r2,zero,8113e50c <OSSemPend+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113e4fc:	e0bfff17 	ldw	r2,-4(fp)
8113e500:	00c00104 	movi	r3,4
8113e504:	10c00005 	stb	r3,0(r2)
        return;
8113e508:	00006d06 	br	8113e6c0 <OSSemPend+0x200>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113e50c:	e0bffd17 	ldw	r2,-12(fp)
8113e510:	10800003 	ldbu	r2,0(r2)
8113e514:	10803fcc 	andi	r2,r2,255
8113e518:	108000e0 	cmpeqi	r2,r2,3
8113e51c:	1000041e 	bne	r2,zero,8113e530 <OSSemPend+0x70>
        *perr = OS_ERR_EVENT_TYPE;
8113e520:	e0bfff17 	ldw	r2,-4(fp)
8113e524:	00c00044 	movi	r3,1
8113e528:	10c00005 	stb	r3,0(r2)
        return;
8113e52c:	00006406 	br	8113e6c0 <OSSemPend+0x200>
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
8113e530:	d0a0a103 	ldbu	r2,-32124(gp)
8113e534:	10803fcc 	andi	r2,r2,255
8113e538:	10000426 	beq	r2,zero,8113e54c <OSSemPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
8113e53c:	e0bfff17 	ldw	r2,-4(fp)
8113e540:	00c00084 	movi	r3,2
8113e544:	10c00005 	stb	r3,0(r2)
        return;
8113e548:	00005d06 	br	8113e6c0 <OSSemPend+0x200>
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
8113e54c:	d0a08f03 	ldbu	r2,-32196(gp)
8113e550:	10803fcc 	andi	r2,r2,255
8113e554:	10000426 	beq	r2,zero,8113e568 <OSSemPend+0xa8>
        *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
8113e558:	e0bfff17 	ldw	r2,-4(fp)
8113e55c:	00c00344 	movi	r3,13
8113e560:	10c00005 	stb	r3,0(r2)
        return;
8113e564:	00005606 	br	8113e6c0 <OSSemPend+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e568:	0005303a 	rdctl	r2,status
8113e56c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e570:	e0fffc17 	ldw	r3,-16(fp)
8113e574:	00bfff84 	movi	r2,-2
8113e578:	1884703a 	and	r2,r3,r2
8113e57c:	1001703a 	wrctl	status,r2
  
  return context;
8113e580:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113e584:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
8113e588:	e0bffd17 	ldw	r2,-12(fp)
8113e58c:	1080020b 	ldhu	r2,8(r2)
8113e590:	10bfffcc 	andi	r2,r2,65535
8113e594:	10000d26 	beq	r2,zero,8113e5cc <OSSemPend+0x10c>
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
8113e598:	e0bffd17 	ldw	r2,-12(fp)
8113e59c:	1080020b 	ldhu	r2,8(r2)
8113e5a0:	10bfffc4 	addi	r2,r2,-1
8113e5a4:	1007883a 	mov	r3,r2
8113e5a8:	e0bffd17 	ldw	r2,-12(fp)
8113e5ac:	10c0020d 	sth	r3,8(r2)
8113e5b0:	e0bff717 	ldw	r2,-36(fp)
8113e5b4:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e5b8:	e0bff817 	ldw	r2,-32(fp)
8113e5bc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
8113e5c0:	e0bfff17 	ldw	r2,-4(fp)
8113e5c4:	10000005 	stb	zero,0(r2)
        return;
8113e5c8:	00003d06 	br	8113e6c0 <OSSemPend+0x200>
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
8113e5cc:	d0a0a217 	ldw	r2,-32120(gp)
8113e5d0:	d0e0a217 	ldw	r3,-32120(gp)
8113e5d4:	18c00c03 	ldbu	r3,48(r3)
8113e5d8:	18c00054 	ori	r3,r3,1
8113e5dc:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113e5e0:	d0a0a217 	ldw	r2,-32120(gp)
8113e5e4:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
8113e5e8:	d0a0a217 	ldw	r2,-32120(gp)
8113e5ec:	e0fffe0b 	ldhu	r3,-8(fp)
8113e5f0:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
8113e5f4:	e13ffd17 	ldw	r4,-12(fp)
8113e5f8:	1138cf40 	call	81138cf4 <OS_EventTaskWait>
8113e5fc:	e0bff717 	ldw	r2,-36(fp)
8113e600:	e0bffb15 	stw	r2,-20(fp)
8113e604:	e0bffb17 	ldw	r2,-20(fp)
8113e608:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
8113e60c:	11396100 	call	81139610 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e610:	0005303a 	rdctl	r2,status
8113e614:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e618:	e0fff917 	ldw	r3,-28(fp)
8113e61c:	00bfff84 	movi	r2,-2
8113e620:	1884703a 	and	r2,r3,r2
8113e624:	1001703a 	wrctl	status,r2
  
  return context;
8113e628:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
8113e62c:	e0bff715 	stw	r2,-36(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
8113e630:	d0a0a217 	ldw	r2,-32120(gp)
8113e634:	10800c43 	ldbu	r2,49(r2)
8113e638:	10803fcc 	andi	r2,r2,255
8113e63c:	10000326 	beq	r2,zero,8113e64c <OSSemPend+0x18c>
8113e640:	108000a0 	cmpeqi	r2,r2,2
8113e644:	1000041e 	bne	r2,zero,8113e658 <OSSemPend+0x198>
8113e648:	00000706 	br	8113e668 <OSSemPend+0x1a8>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
8113e64c:	e0bfff17 	ldw	r2,-4(fp)
8113e650:	10000005 	stb	zero,0(r2)
             break;
8113e654:	00000c06 	br	8113e688 <OSSemPend+0x1c8>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
8113e658:	e0bfff17 	ldw	r2,-4(fp)
8113e65c:	00c00384 	movi	r3,14
8113e660:	10c00005 	stb	r3,0(r2)
             break;
8113e664:	00000806 	br	8113e688 <OSSemPend+0x1c8>

        case OS_STAT_PEND_TO:
        default:        
             OS_EventTaskRemove(OSTCBCur, pevent);
8113e668:	d0a0a217 	ldw	r2,-32120(gp)
8113e66c:	e17ffd17 	ldw	r5,-12(fp)
8113e670:	1009883a 	mov	r4,r2
8113e674:	1138f640 	call	81138f64 <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
8113e678:	e0bfff17 	ldw	r2,-4(fp)
8113e67c:	00c00284 	movi	r3,10
8113e680:	10c00005 	stb	r3,0(r2)
             break;
8113e684:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
8113e688:	d0a0a217 	ldw	r2,-32120(gp)
8113e68c:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
8113e690:	d0a0a217 	ldw	r2,-32120(gp)
8113e694:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
8113e698:	d0a0a217 	ldw	r2,-32120(gp)
8113e69c:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8113e6a0:	d0a0a217 	ldw	r2,-32120(gp)
8113e6a4:	10000815 	stw	zero,32(r2)
8113e6a8:	e0bff717 	ldw	r2,-36(fp)
8113e6ac:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e6b0:	e0bffa17 	ldw	r2,-24(fp)
8113e6b4:	1001703a 	wrctl	status,r2
8113e6b8:	00000106 	br	8113e6c0 <OSSemPend+0x200>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
8113e6bc:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
8113e6c0:	e037883a 	mov	sp,fp
8113e6c4:	dfc00117 	ldw	ra,4(sp)
8113e6c8:	df000017 	ldw	fp,0(sp)
8113e6cc:	dec00204 	addi	sp,sp,8
8113e6d0:	f800283a 	ret

8113e6d4 <OSSemPendAbort>:
*********************************************************************************************************
*/

#if OS_SEM_PEND_ABORT_EN > 0
INT8U  OSSemPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113e6d4:	defff604 	addi	sp,sp,-40
8113e6d8:	de00012e 	bgeu	sp,et,8113e6e0 <OSSemPendAbort+0xc>
8113e6dc:	003b68fa 	trap	3
8113e6e0:	dfc00915 	stw	ra,36(sp)
8113e6e4:	df000815 	stw	fp,32(sp)
8113e6e8:	df000804 	addi	fp,sp,32
8113e6ec:	e13ffd15 	stw	r4,-12(fp)
8113e6f0:	2805883a 	mov	r2,r5
8113e6f4:	e1bfff15 	stw	r6,-4(fp)
8113e6f8:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113e6fc:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113e700:	e0bfff17 	ldw	r2,-4(fp)
8113e704:	1000021e 	bne	r2,zero,8113e710 <OSSemPendAbort+0x3c>
        return (0);
8113e708:	0005883a 	mov	r2,zero
8113e70c:	00004906 	br	8113e834 <OSSemPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113e710:	e0bffd17 	ldw	r2,-12(fp)
8113e714:	1000051e 	bne	r2,zero,8113e72c <OSSemPendAbort+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113e718:	e0bfff17 	ldw	r2,-4(fp)
8113e71c:	00c00104 	movi	r3,4
8113e720:	10c00005 	stb	r3,0(r2)
        return (0);
8113e724:	0005883a 	mov	r2,zero
8113e728:	00004206 	br	8113e834 <OSSemPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113e72c:	e0bffd17 	ldw	r2,-12(fp)
8113e730:	10800003 	ldbu	r2,0(r2)
8113e734:	10803fcc 	andi	r2,r2,255
8113e738:	108000e0 	cmpeqi	r2,r2,3
8113e73c:	1000051e 	bne	r2,zero,8113e754 <OSSemPendAbort+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113e740:	e0bfff17 	ldw	r2,-4(fp)
8113e744:	00c00044 	movi	r3,1
8113e748:	10c00005 	stb	r3,0(r2)
        return (0);
8113e74c:	0005883a 	mov	r2,zero
8113e750:	00003806 	br	8113e834 <OSSemPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e754:	0005303a 	rdctl	r2,status
8113e758:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e75c:	e0fffc17 	ldw	r3,-16(fp)
8113e760:	00bfff84 	movi	r2,-2
8113e764:	1884703a 	and	r2,r3,r2
8113e768:	1001703a 	wrctl	status,r2
  
  return context;
8113e76c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113e770:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
8113e774:	e0bffd17 	ldw	r2,-12(fp)
8113e778:	10800283 	ldbu	r2,10(r2)
8113e77c:	10803fcc 	andi	r2,r2,255
8113e780:	10002526 	beq	r2,zero,8113e818 <OSSemPendAbort+0x144>
        nbr_tasks = 0;
8113e784:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
8113e788:	e0bffe03 	ldbu	r2,-8(fp)
8113e78c:	10800060 	cmpeqi	r2,r2,1
8113e790:	10000e26 	beq	r2,zero,8113e7cc <OSSemPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
8113e794:	00000806 	br	8113e7b8 <OSSemPendAbort+0xe4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
8113e798:	01c00084 	movi	r7,2
8113e79c:	01800044 	movi	r6,1
8113e7a0:	000b883a 	mov	r5,zero
8113e7a4:	e13ffd17 	ldw	r4,-12(fp)
8113e7a8:	1138b540 	call	81138b54 <OS_EventTaskRdy>
                     nbr_tasks++;
8113e7ac:	e0bff803 	ldbu	r2,-32(fp)
8113e7b0:	10800044 	addi	r2,r2,1
8113e7b4:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
8113e7b8:	e0bffd17 	ldw	r2,-12(fp)
8113e7bc:	10800283 	ldbu	r2,10(r2)
8113e7c0:	10803fcc 	andi	r2,r2,255
8113e7c4:	103ff41e 	bne	r2,zero,8113e798 <__reset+0xfb11e798>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
8113e7c8:	00000906 	br	8113e7f0 <OSSemPendAbort+0x11c>
                 
            case OS_PEND_OPT_NONE:
            default:                                  /* No,  ready HPT       waiting on semaphore     */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
8113e7cc:	01c00084 	movi	r7,2
8113e7d0:	01800044 	movi	r6,1
8113e7d4:	000b883a 	mov	r5,zero
8113e7d8:	e13ffd17 	ldw	r4,-12(fp)
8113e7dc:	1138b540 	call	81138b54 <OS_EventTaskRdy>
                 nbr_tasks++;
8113e7e0:	e0bff803 	ldbu	r2,-32(fp)
8113e7e4:	10800044 	addi	r2,r2,1
8113e7e8:	e0bff805 	stb	r2,-32(fp)
                 break;
8113e7ec:	0001883a 	nop
8113e7f0:	e0bff917 	ldw	r2,-28(fp)
8113e7f4:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e7f8:	e0bffa17 	ldw	r2,-24(fp)
8113e7fc:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
8113e800:	11396100 	call	81139610 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
8113e804:	e0bfff17 	ldw	r2,-4(fp)
8113e808:	00c00384 	movi	r3,14
8113e80c:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
8113e810:	e0bff803 	ldbu	r2,-32(fp)
8113e814:	00000706 	br	8113e834 <OSSemPendAbort+0x160>
8113e818:	e0bff917 	ldw	r2,-28(fp)
8113e81c:	e0bffb15 	stw	r2,-20(fp)
8113e820:	e0bffb17 	ldw	r2,-20(fp)
8113e824:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113e828:	e0bfff17 	ldw	r2,-4(fp)
8113e82c:	10000005 	stb	zero,0(r2)
    return (0);                                       /* No tasks waiting on semaphore                 */
8113e830:	0005883a 	mov	r2,zero
}
8113e834:	e037883a 	mov	sp,fp
8113e838:	dfc00117 	ldw	ra,4(sp)
8113e83c:	df000017 	ldw	fp,0(sp)
8113e840:	dec00204 	addi	sp,sp,8
8113e844:	f800283a 	ret

8113e848 <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
8113e848:	defff804 	addi	sp,sp,-32
8113e84c:	de00012e 	bgeu	sp,et,8113e854 <OSSemPost+0xc>
8113e850:	003b68fa 	trap	3
8113e854:	dfc00715 	stw	ra,28(sp)
8113e858:	df000615 	stw	fp,24(sp)
8113e85c:	df000604 	addi	fp,sp,24
8113e860:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113e864:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113e868:	e0bfff17 	ldw	r2,-4(fp)
8113e86c:	1000021e 	bne	r2,zero,8113e878 <OSSemPost+0x30>
        return (OS_ERR_PEVENT_NULL);
8113e870:	00800104 	movi	r2,4
8113e874:	00003506 	br	8113e94c <OSSemPost+0x104>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113e878:	e0bfff17 	ldw	r2,-4(fp)
8113e87c:	10800003 	ldbu	r2,0(r2)
8113e880:	10803fcc 	andi	r2,r2,255
8113e884:	108000e0 	cmpeqi	r2,r2,3
8113e888:	1000021e 	bne	r2,zero,8113e894 <OSSemPost+0x4c>
        return (OS_ERR_EVENT_TYPE);
8113e88c:	00800044 	movi	r2,1
8113e890:	00002e06 	br	8113e94c <OSSemPost+0x104>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e894:	0005303a 	rdctl	r2,status
8113e898:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e89c:	e0fffe17 	ldw	r3,-8(fp)
8113e8a0:	00bfff84 	movi	r2,-2
8113e8a4:	1884703a 	and	r2,r3,r2
8113e8a8:	1001703a 	wrctl	status,r2
  
  return context;
8113e8ac:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113e8b0:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting for semaphore         */
8113e8b4:	e0bfff17 	ldw	r2,-4(fp)
8113e8b8:	10800283 	ldbu	r2,10(r2)
8113e8bc:	10803fcc 	andi	r2,r2,255
8113e8c0:	10000c26 	beq	r2,zero,8113e8f4 <OSSemPost+0xac>
                                                      /* Ready HPT waiting on event                    */
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
8113e8c4:	000f883a 	mov	r7,zero
8113e8c8:	01800044 	movi	r6,1
8113e8cc:	000b883a 	mov	r5,zero
8113e8d0:	e13fff17 	ldw	r4,-4(fp)
8113e8d4:	1138b540 	call	81138b54 <OS_EventTaskRdy>
8113e8d8:	e0bffa17 	ldw	r2,-24(fp)
8113e8dc:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e8e0:	e0bffb17 	ldw	r2,-20(fp)
8113e8e4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
8113e8e8:	11396100 	call	81139610 <OS_Sched>
        return (OS_ERR_NONE);
8113e8ec:	0005883a 	mov	r2,zero
8113e8f0:	00001606 	br	8113e94c <OSSemPost+0x104>
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
8113e8f4:	e0bfff17 	ldw	r2,-4(fp)
8113e8f8:	1080020b 	ldhu	r2,8(r2)
8113e8fc:	10ffffcc 	andi	r3,r2,65535
8113e900:	00bfffd4 	movui	r2,65535
8113e904:	18800c26 	beq	r3,r2,8113e938 <OSSemPost+0xf0>
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
8113e908:	e0bfff17 	ldw	r2,-4(fp)
8113e90c:	1080020b 	ldhu	r2,8(r2)
8113e910:	10800044 	addi	r2,r2,1
8113e914:	1007883a 	mov	r3,r2
8113e918:	e0bfff17 	ldw	r2,-4(fp)
8113e91c:	10c0020d 	sth	r3,8(r2)
8113e920:	e0bffa17 	ldw	r2,-24(fp)
8113e924:	e0bffc15 	stw	r2,-16(fp)
8113e928:	e0bffc17 	ldw	r2,-16(fp)
8113e92c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
8113e930:	0005883a 	mov	r2,zero
8113e934:	00000506 	br	8113e94c <OSSemPost+0x104>
8113e938:	e0bffa17 	ldw	r2,-24(fp)
8113e93c:	e0bffd15 	stw	r2,-12(fp)
8113e940:	e0bffd17 	ldw	r2,-12(fp)
8113e944:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    return (OS_ERR_SEM_OVF);
8113e948:	00800c84 	movi	r2,50
}
8113e94c:	e037883a 	mov	sp,fp
8113e950:	dfc00117 	ldw	ra,4(sp)
8113e954:	df000017 	ldw	fp,0(sp)
8113e958:	dec00204 	addi	sp,sp,8
8113e95c:	f800283a 	ret

8113e960 <OSSemQuery>:
*********************************************************************************************************
*/

#if OS_SEM_QUERY_EN > 0
INT8U  OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data)
{
8113e960:	defff704 	addi	sp,sp,-36
8113e964:	de00012e 	bgeu	sp,et,8113e96c <OSSemQuery+0xc>
8113e968:	003b68fa 	trap	3
8113e96c:	df000815 	stw	fp,32(sp)
8113e970:	df000804 	addi	fp,sp,32
8113e974:	e13ffe15 	stw	r4,-8(fp)
8113e978:	e17fff15 	stw	r5,-4(fp)
    INT16U    *psrc;
    INT16U    *pdest;
#endif
    INT8U      i;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113e97c:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113e980:	e0bffe17 	ldw	r2,-8(fp)
8113e984:	1000021e 	bne	r2,zero,8113e990 <OSSemQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
8113e988:	00800104 	movi	r2,4
8113e98c:	00003606 	br	8113ea68 <OSSemQuery+0x108>
    }
    if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
8113e990:	e0bfff17 	ldw	r2,-4(fp)
8113e994:	1000021e 	bne	r2,zero,8113e9a0 <OSSemQuery+0x40>
        return (OS_ERR_PDATA_NULL);
8113e998:	00800244 	movi	r2,9
8113e99c:	00003206 	br	8113ea68 <OSSemQuery+0x108>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
8113e9a0:	e0bffe17 	ldw	r2,-8(fp)
8113e9a4:	10800003 	ldbu	r2,0(r2)
8113e9a8:	10803fcc 	andi	r2,r2,255
8113e9ac:	108000e0 	cmpeqi	r2,r2,3
8113e9b0:	1000021e 	bne	r2,zero,8113e9bc <OSSemQuery+0x5c>
        return (OS_ERR_EVENT_TYPE);
8113e9b4:	00800044 	movi	r2,1
8113e9b8:	00002b06 	br	8113ea68 <OSSemQuery+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e9bc:	0005303a 	rdctl	r2,status
8113e9c0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e9c4:	e0fffd17 	ldw	r3,-12(fp)
8113e9c8:	00bfff84 	movi	r2,-2
8113e9cc:	1884703a 	and	r2,r3,r2
8113e9d0:	1001703a 	wrctl	status,r2
  
  return context;
8113e9d4:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113e9d8:	e0bffb15 	stw	r2,-20(fp)
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
8113e9dc:	e0bffe17 	ldw	r2,-8(fp)
8113e9e0:	10c00283 	ldbu	r3,10(r2)
8113e9e4:	e0bfff17 	ldw	r2,-4(fp)
8113e9e8:	10c00205 	stb	r3,8(r2)
    psrc                   = &pevent->OSEventTbl[0];
8113e9ec:	e0bffe17 	ldw	r2,-8(fp)
8113e9f0:	108002c4 	addi	r2,r2,11
8113e9f4:	e0bff815 	stw	r2,-32(fp)
    pdest                  = &p_sem_data->OSEventTbl[0];
8113e9f8:	e0bfff17 	ldw	r2,-4(fp)
8113e9fc:	10800084 	addi	r2,r2,2
8113ea00:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113ea04:	e03ffa05 	stb	zero,-24(fp)
8113ea08:	00000b06 	br	8113ea38 <OSSemQuery+0xd8>
        *pdest++ = *psrc++;
8113ea0c:	e0bff917 	ldw	r2,-28(fp)
8113ea10:	10c00044 	addi	r3,r2,1
8113ea14:	e0fff915 	stw	r3,-28(fp)
8113ea18:	e0fff817 	ldw	r3,-32(fp)
8113ea1c:	19000044 	addi	r4,r3,1
8113ea20:	e13ff815 	stw	r4,-32(fp)
8113ea24:	18c00003 	ldbu	r3,0(r3)
8113ea28:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
    psrc                   = &pevent->OSEventTbl[0];
    pdest                  = &p_sem_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113ea2c:	e0bffa03 	ldbu	r2,-24(fp)
8113ea30:	10800044 	addi	r2,r2,1
8113ea34:	e0bffa05 	stb	r2,-24(fp)
8113ea38:	e0bffa03 	ldbu	r2,-24(fp)
8113ea3c:	108001b0 	cmpltui	r2,r2,6
8113ea40:	103ff21e 	bne	r2,zero,8113ea0c <__reset+0xfb11ea0c>
        *pdest++ = *psrc++;
    }
    p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
8113ea44:	e0bffe17 	ldw	r2,-8(fp)
8113ea48:	10c0020b 	ldhu	r3,8(r2)
8113ea4c:	e0bfff17 	ldw	r2,-4(fp)
8113ea50:	10c0000d 	sth	r3,0(r2)
8113ea54:	e0bffb17 	ldw	r2,-20(fp)
8113ea58:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ea5c:	e0bffc17 	ldw	r2,-16(fp)
8113ea60:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113ea64:	0005883a 	mov	r2,zero
}
8113ea68:	e037883a 	mov	sp,fp
8113ea6c:	df000017 	ldw	fp,0(sp)
8113ea70:	dec00104 	addi	sp,sp,4
8113ea74:	f800283a 	ret

8113ea78 <OSSemSet>:
*********************************************************************************************************
*/

#if OS_SEM_SET_EN > 0
void  OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *perr)
{
8113ea78:	defff904 	addi	sp,sp,-28
8113ea7c:	de00012e 	bgeu	sp,et,8113ea84 <OSSemSet+0xc>
8113ea80:	003b68fa 	trap	3
8113ea84:	df000615 	stw	fp,24(sp)
8113ea88:	df000604 	addi	fp,sp,24
8113ea8c:	e13ffd15 	stw	r4,-12(fp)
8113ea90:	2805883a 	mov	r2,r5
8113ea94:	e1bfff15 	stw	r6,-4(fp)
8113ea98:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113ea9c:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113eaa0:	e0bfff17 	ldw	r2,-4(fp)
8113eaa4:	10003126 	beq	r2,zero,8113eb6c <OSSemSet+0xf4>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113eaa8:	e0bffd17 	ldw	r2,-12(fp)
8113eaac:	1000041e 	bne	r2,zero,8113eac0 <OSSemSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
8113eab0:	e0bfff17 	ldw	r2,-4(fp)
8113eab4:	00c00104 	movi	r3,4
8113eab8:	10c00005 	stb	r3,0(r2)
        return;
8113eabc:	00002c06 	br	8113eb70 <OSSemSet+0xf8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113eac0:	e0bffd17 	ldw	r2,-12(fp)
8113eac4:	10800003 	ldbu	r2,0(r2)
8113eac8:	10803fcc 	andi	r2,r2,255
8113eacc:	108000e0 	cmpeqi	r2,r2,3
8113ead0:	1000041e 	bne	r2,zero,8113eae4 <OSSemSet+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
8113ead4:	e0bfff17 	ldw	r2,-4(fp)
8113ead8:	00c00044 	movi	r3,1
8113eadc:	10c00005 	stb	r3,0(r2)
        return;
8113eae0:	00002306 	br	8113eb70 <OSSemSet+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113eae4:	0005303a 	rdctl	r2,status
8113eae8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113eaec:	e0fffc17 	ldw	r3,-16(fp)
8113eaf0:	00bfff84 	movi	r2,-2
8113eaf4:	1884703a 	and	r2,r3,r2
8113eaf8:	1001703a 	wrctl	status,r2
  
  return context;
8113eafc:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113eb00:	e0bffa15 	stw	r2,-24(fp)
    *perr = OS_ERR_NONE;
8113eb04:	e0bfff17 	ldw	r2,-4(fp)
8113eb08:	10000005 	stb	zero,0(r2)
    if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
8113eb0c:	e0bffd17 	ldw	r2,-12(fp)
8113eb10:	1080020b 	ldhu	r2,8(r2)
8113eb14:	10bfffcc 	andi	r2,r2,65535
8113eb18:	10000426 	beq	r2,zero,8113eb2c <OSSemSet+0xb4>
        pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
8113eb1c:	e0bffd17 	ldw	r2,-12(fp)
8113eb20:	e0fffe0b 	ldhu	r3,-8(fp)
8113eb24:	10c0020d 	sth	r3,8(r2)
8113eb28:	00000b06 	br	8113eb58 <OSSemSet+0xe0>
    } else {                                          /* No                                            */
        if (pevent->OSEventGrp == 0) {                /*      See if task(s) waiting?                  */
8113eb2c:	e0bffd17 	ldw	r2,-12(fp)
8113eb30:	10800283 	ldbu	r2,10(r2)
8113eb34:	10803fcc 	andi	r2,r2,255
8113eb38:	1000041e 	bne	r2,zero,8113eb4c <OSSemSet+0xd4>
            pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
8113eb3c:	e0bffd17 	ldw	r2,-12(fp)
8113eb40:	e0fffe0b 	ldhu	r3,-8(fp)
8113eb44:	10c0020d 	sth	r3,8(r2)
8113eb48:	00000306 	br	8113eb58 <OSSemSet+0xe0>
        } else {
            *perr              = OS_ERR_TASK_WAITING;
8113eb4c:	e0bfff17 	ldw	r2,-4(fp)
8113eb50:	00c01244 	movi	r3,73
8113eb54:	10c00005 	stb	r3,0(r2)
8113eb58:	e0bffa17 	ldw	r2,-24(fp)
8113eb5c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113eb60:	e0bffb17 	ldw	r2,-20(fp)
8113eb64:	1001703a 	wrctl	status,r2
8113eb68:	00000106 	br	8113eb70 <OSSemSet+0xf8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
8113eb6c:	0001883a 	nop
        } else {
            *perr              = OS_ERR_TASK_WAITING;
        }
    }
    OS_EXIT_CRITICAL();
}
8113eb70:	e037883a 	mov	sp,fp
8113eb74:	df000017 	ldw	fp,0(sp)
8113eb78:	dec00104 	addi	sp,sp,4
8113eb7c:	f800283a 	ret

8113eb80 <OSTaskChangePrio>:
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
8113eb80:	defff104 	addi	sp,sp,-60
8113eb84:	de00012e 	bgeu	sp,et,8113eb8c <OSTaskChangePrio+0xc>
8113eb88:	003b68fa 	trap	3
8113eb8c:	dfc00e15 	stw	ra,56(sp)
8113eb90:	df000d15 	stw	fp,52(sp)
8113eb94:	df000d04 	addi	fp,sp,52
8113eb98:	2007883a 	mov	r3,r4
8113eb9c:	2805883a 	mov	r2,r5
8113eba0:	e0fffe05 	stb	r3,-8(fp)
8113eba4:	e0bfff05 	stb	r2,-4(fp)
    INT16U     bitx_new;
    INT16U     bity_old;
    INT16U     bitx_old;
#endif
#if OS_CRITICAL_METHOD == 3
    OS_CPU_SR  cpu_sr = 0;                                  /* Storage for CPU status register         */
8113eba8:	e03ff515 	stw	zero,-44(fp)
#endif


/*$PAGE*/
#if OS_ARG_CHK_EN > 0
    if (oldprio >= OS_LOWEST_PRIO) {
8113ebac:	e0bffe03 	ldbu	r2,-8(fp)
8113ebb0:	10800ab0 	cmpltui	r2,r2,42
8113ebb4:	1000051e 	bne	r2,zero,8113ebcc <OSTaskChangePrio+0x4c>
        if (oldprio != OS_PRIO_SELF) {
8113ebb8:	e0bffe03 	ldbu	r2,-8(fp)
8113ebbc:	10803fe0 	cmpeqi	r2,r2,255
8113ebc0:	1000021e 	bne	r2,zero,8113ebcc <OSTaskChangePrio+0x4c>
            return (OS_ERR_PRIO_INVALID);
8113ebc4:	00800a84 	movi	r2,42
8113ebc8:	00012606 	br	8113f064 <OSTaskChangePrio+0x4e4>
        }
    }
    if (newprio >= OS_LOWEST_PRIO) {
8113ebcc:	e0bfff03 	ldbu	r2,-4(fp)
8113ebd0:	10800ab0 	cmpltui	r2,r2,42
8113ebd4:	1000021e 	bne	r2,zero,8113ebe0 <OSTaskChangePrio+0x60>
        return (OS_ERR_PRIO_INVALID);
8113ebd8:	00800a84 	movi	r2,42
8113ebdc:	00012106 	br	8113f064 <OSTaskChangePrio+0x4e4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ebe0:	0005303a 	rdctl	r2,status
8113ebe4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ebe8:	e0fffd17 	ldw	r3,-12(fp)
8113ebec:	00bfff84 	movi	r2,-2
8113ebf0:	1884703a 	and	r2,r3,r2
8113ebf4:	1001703a 	wrctl	status,r2
  
  return context;
8113ebf8:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113ebfc:	e0bff515 	stw	r2,-44(fp)
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
8113ec00:	e0ffff03 	ldbu	r3,-4(fp)
8113ec04:	00a045f4 	movhi	r2,33047
8113ec08:	10b1de04 	addi	r2,r2,-14472
8113ec0c:	18c7883a 	add	r3,r3,r3
8113ec10:	18c7883a 	add	r3,r3,r3
8113ec14:	10c5883a 	add	r2,r2,r3
8113ec18:	10800017 	ldw	r2,0(r2)
8113ec1c:	10000626 	beq	r2,zero,8113ec38 <OSTaskChangePrio+0xb8>
8113ec20:	e0bff517 	ldw	r2,-44(fp)
8113ec24:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ec28:	e0bff617 	ldw	r2,-40(fp)
8113ec2c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO_EXIST);
8113ec30:	00800a04 	movi	r2,40
8113ec34:	00010b06 	br	8113f064 <OSTaskChangePrio+0x4e4>
    }
    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
8113ec38:	e0bffe03 	ldbu	r2,-8(fp)
8113ec3c:	10803fd8 	cmpnei	r2,r2,255
8113ec40:	1000031e 	bne	r2,zero,8113ec50 <OSTaskChangePrio+0xd0>
        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
8113ec44:	d0a0a217 	ldw	r2,-32120(gp)
8113ec48:	10800c83 	ldbu	r2,50(r2)
8113ec4c:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[oldprio];
8113ec50:	e0fffe03 	ldbu	r3,-8(fp)
8113ec54:	00a045f4 	movhi	r2,33047
8113ec58:	10b1de04 	addi	r2,r2,-14472
8113ec5c:	18c7883a 	add	r3,r3,r3
8113ec60:	18c7883a 	add	r3,r3,r3
8113ec64:	10c5883a 	add	r2,r2,r3
8113ec68:	10800017 	ldw	r2,0(r2)
8113ec6c:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
8113ec70:	e0bff817 	ldw	r2,-32(fp)
8113ec74:	1000061e 	bne	r2,zero,8113ec90 <OSTaskChangePrio+0x110>
8113ec78:	e0bff517 	ldw	r2,-44(fp)
8113ec7c:	e0bff715 	stw	r2,-36(fp)
8113ec80:	e0bff717 	ldw	r2,-36(fp)
8113ec84:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_PRIO);
8113ec88:	00800a44 	movi	r2,41
8113ec8c:	0000f506 	br	8113f064 <OSTaskChangePrio+0x4e4>
    }
    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
8113ec90:	e0bff817 	ldw	r2,-32(fp)
8113ec94:	10800058 	cmpnei	r2,r2,1
8113ec98:	1000061e 	bne	r2,zero,8113ecb4 <OSTaskChangePrio+0x134>
8113ec9c:	e0bff517 	ldw	r2,-44(fp)
8113eca0:	e0bff915 	stw	r2,-28(fp)
8113eca4:	e0bff917 	ldw	r2,-28(fp)
8113eca8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_TASK_NOT_EXIST);
8113ecac:	008010c4 	movi	r2,67
8113ecb0:	0000ec06 	br	8113f064 <OSTaskChangePrio+0x4e4>
    }
#if OS_LOWEST_PRIO <= 63
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
8113ecb4:	e0bfff03 	ldbu	r2,-4(fp)
8113ecb8:	1004d0fa 	srli	r2,r2,3
8113ecbc:	e0bffb05 	stb	r2,-20(fp)
    x_new                 = (INT8U)(newprio & 0x07);
8113ecc0:	e0bfff03 	ldbu	r2,-4(fp)
8113ecc4:	108001cc 	andi	r2,r2,7
8113ecc8:	e0bffb45 	stb	r2,-19(fp)
    bity_new              = (INT8U)(1 << y_new);
8113eccc:	e0bffb03 	ldbu	r2,-20(fp)
8113ecd0:	00c00044 	movi	r3,1
8113ecd4:	1884983a 	sll	r2,r3,r2
8113ecd8:	e0bffb85 	stb	r2,-18(fp)
    bitx_new              = (INT8U)(1 << x_new);
8113ecdc:	e0bffb43 	ldbu	r2,-19(fp)
8113ece0:	00c00044 	movi	r3,1
8113ece4:	1884983a 	sll	r2,r3,r2
8113ece8:	e0bffbc5 	stb	r2,-17(fp)
    x_new                 = (INT8U)( newprio & 0x0F);
    bity_new              = (INT16U)(1 << y_new);
    bitx_new              = (INT16U)(1 << x_new);
#endif

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
8113ecec:	e0fffe03 	ldbu	r3,-8(fp)
8113ecf0:	00a045f4 	movhi	r2,33047
8113ecf4:	10b1de04 	addi	r2,r2,-14472
8113ecf8:	18c7883a 	add	r3,r3,r3
8113ecfc:	18c7883a 	add	r3,r3,r3
8113ed00:	10c5883a 	add	r2,r2,r3
8113ed04:	10000015 	stw	zero,0(r2)
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
8113ed08:	e0ffff03 	ldbu	r3,-4(fp)
8113ed0c:	00a045f4 	movhi	r2,33047
8113ed10:	10b1de04 	addi	r2,r2,-14472
8113ed14:	18c7883a 	add	r3,r3,r3
8113ed18:	18c7883a 	add	r3,r3,r3
8113ed1c:	10c5883a 	add	r2,r2,r3
8113ed20:	e0fff817 	ldw	r3,-32(fp)
8113ed24:	10c00015 	stw	r3,0(r2)
    y_old                 =  ptcb->OSTCBY;
8113ed28:	e0bff817 	ldw	r2,-32(fp)
8113ed2c:	10800d03 	ldbu	r2,52(r2)
8113ed30:	e0bffc05 	stb	r2,-16(fp)
    bity_old              =  ptcb->OSTCBBitY;
8113ed34:	e0bff817 	ldw	r2,-32(fp)
8113ed38:	10800d83 	ldbu	r2,54(r2)
8113ed3c:	e0bffc45 	stb	r2,-15(fp)
    bitx_old              =  ptcb->OSTCBBitX;
8113ed40:	e0bff817 	ldw	r2,-32(fp)
8113ed44:	10800d43 	ldbu	r2,53(r2)
8113ed48:	e0bffc85 	stb	r2,-14(fp)
    if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
8113ed4c:	e0fffc03 	ldbu	r3,-16(fp)
8113ed50:	d0a09e44 	addi	r2,gp,-32135
8113ed54:	1885883a 	add	r2,r3,r2
8113ed58:	10c00003 	ldbu	r3,0(r2)
8113ed5c:	e0bffc83 	ldbu	r2,-14(fp)
8113ed60:	1884703a 	and	r2,r3,r2
8113ed64:	10803fcc 	andi	r2,r2,255
8113ed68:	10002826 	beq	r2,zero,8113ee0c <OSTaskChangePrio+0x28c>
         OSRdyTbl[y_old] &= ~bitx_old;
8113ed6c:	e0fffc03 	ldbu	r3,-16(fp)
8113ed70:	e13ffc03 	ldbu	r4,-16(fp)
8113ed74:	d0a09e44 	addi	r2,gp,-32135
8113ed78:	2085883a 	add	r2,r4,r2
8113ed7c:	10800003 	ldbu	r2,0(r2)
8113ed80:	1009883a 	mov	r4,r2
8113ed84:	e0bffc83 	ldbu	r2,-14(fp)
8113ed88:	0084303a 	nor	r2,zero,r2
8113ed8c:	2084703a 	and	r2,r4,r2
8113ed90:	1009883a 	mov	r4,r2
8113ed94:	d0a09e44 	addi	r2,gp,-32135
8113ed98:	1885883a 	add	r2,r3,r2
8113ed9c:	11000005 	stb	r4,0(r2)
         if (OSRdyTbl[y_old] == 0) {
8113eda0:	e0fffc03 	ldbu	r3,-16(fp)
8113eda4:	d0a09e44 	addi	r2,gp,-32135
8113eda8:	1885883a 	add	r2,r3,r2
8113edac:	10800003 	ldbu	r2,0(r2)
8113edb0:	10803fcc 	andi	r2,r2,255
8113edb4:	1000061e 	bne	r2,zero,8113edd0 <OSTaskChangePrio+0x250>
             OSRdyGrp &= ~bity_old;
8113edb8:	e0bffc43 	ldbu	r2,-15(fp)
8113edbc:	0084303a 	nor	r2,zero,r2
8113edc0:	1007883a 	mov	r3,r2
8113edc4:	d0a09e03 	ldbu	r2,-32136(gp)
8113edc8:	1884703a 	and	r2,r3,r2
8113edcc:	d0a09e05 	stb	r2,-32136(gp)
         }
         OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
8113edd0:	d0e09e03 	ldbu	r3,-32136(gp)
8113edd4:	e0bffb83 	ldbu	r2,-18(fp)
8113edd8:	1884b03a 	or	r2,r3,r2
8113eddc:	d0a09e05 	stb	r2,-32136(gp)
         OSRdyTbl[y_new] |= bitx_new;
8113ede0:	e0fffb03 	ldbu	r3,-20(fp)
8113ede4:	e13ffb03 	ldbu	r4,-20(fp)
8113ede8:	d0a09e44 	addi	r2,gp,-32135
8113edec:	2085883a 	add	r2,r4,r2
8113edf0:	11000003 	ldbu	r4,0(r2)
8113edf4:	e0bffbc3 	ldbu	r2,-17(fp)
8113edf8:	2084b03a 	or	r2,r4,r2
8113edfc:	1009883a 	mov	r4,r2
8113ee00:	d0a09e44 	addi	r2,gp,-32135
8113ee04:	1885883a 	add	r2,r3,r2
8113ee08:	11000005 	stb	r4,0(r2)
    }

#if (OS_EVENT_EN)
    pevent = ptcb->OSTCBEventPtr;
8113ee0c:	e0bff817 	ldw	r2,-32(fp)
8113ee10:	10800717 	ldw	r2,28(r2)
8113ee14:	e0bff315 	stw	r2,-52(fp)
    if (pevent != (OS_EVENT *)0) {
8113ee18:	e0bff317 	ldw	r2,-52(fp)
8113ee1c:	10003326 	beq	r2,zero,8113eeec <OSTaskChangePrio+0x36c>
        pevent->OSEventTbl[y_old] &= ~bitx_old;             /* Remove old task prio from wait list     */
8113ee20:	e0bffc03 	ldbu	r2,-16(fp)
8113ee24:	e0fffc03 	ldbu	r3,-16(fp)
8113ee28:	e13ff317 	ldw	r4,-52(fp)
8113ee2c:	20c7883a 	add	r3,r4,r3
8113ee30:	18c002c4 	addi	r3,r3,11
8113ee34:	18c00003 	ldbu	r3,0(r3)
8113ee38:	1809883a 	mov	r4,r3
8113ee3c:	e0fffc83 	ldbu	r3,-14(fp)
8113ee40:	00c6303a 	nor	r3,zero,r3
8113ee44:	20c6703a 	and	r3,r4,r3
8113ee48:	1809883a 	mov	r4,r3
8113ee4c:	e0fff317 	ldw	r3,-52(fp)
8113ee50:	1885883a 	add	r2,r3,r2
8113ee54:	108002c4 	addi	r2,r2,11
8113ee58:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y_old] == 0) {
8113ee5c:	e0bffc03 	ldbu	r2,-16(fp)
8113ee60:	e0fff317 	ldw	r3,-52(fp)
8113ee64:	1885883a 	add	r2,r3,r2
8113ee68:	108002c4 	addi	r2,r2,11
8113ee6c:	10800003 	ldbu	r2,0(r2)
8113ee70:	10803fcc 	andi	r2,r2,255
8113ee74:	1000091e 	bne	r2,zero,8113ee9c <OSTaskChangePrio+0x31c>
            pevent->OSEventGrp    &= ~bity_old;
8113ee78:	e0bff317 	ldw	r2,-52(fp)
8113ee7c:	10800283 	ldbu	r2,10(r2)
8113ee80:	1007883a 	mov	r3,r2
8113ee84:	e0bffc43 	ldbu	r2,-15(fp)
8113ee88:	0084303a 	nor	r2,zero,r2
8113ee8c:	1884703a 	and	r2,r3,r2
8113ee90:	1007883a 	mov	r3,r2
8113ee94:	e0bff317 	ldw	r2,-52(fp)
8113ee98:	10c00285 	stb	r3,10(r2)
        }
        pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
8113ee9c:	e0bff317 	ldw	r2,-52(fp)
8113eea0:	10c00283 	ldbu	r3,10(r2)
8113eea4:	e0bffb83 	ldbu	r2,-18(fp)
8113eea8:	1884b03a 	or	r2,r3,r2
8113eeac:	1007883a 	mov	r3,r2
8113eeb0:	e0bff317 	ldw	r2,-52(fp)
8113eeb4:	10c00285 	stb	r3,10(r2)
        pevent->OSEventTbl[y_new] |= bitx_new;
8113eeb8:	e0bffb03 	ldbu	r2,-20(fp)
8113eebc:	e0fffb03 	ldbu	r3,-20(fp)
8113eec0:	e13ff317 	ldw	r4,-52(fp)
8113eec4:	20c7883a 	add	r3,r4,r3
8113eec8:	18c002c4 	addi	r3,r3,11
8113eecc:	19000003 	ldbu	r4,0(r3)
8113eed0:	e0fffbc3 	ldbu	r3,-17(fp)
8113eed4:	20c6b03a 	or	r3,r4,r3
8113eed8:	1809883a 	mov	r4,r3
8113eedc:	e0fff317 	ldw	r3,-52(fp)
8113eee0:	1885883a 	add	r2,r3,r2
8113eee4:	108002c4 	addi	r2,r2,11
8113eee8:	11000005 	stb	r4,0(r2)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
8113eeec:	e0bff817 	ldw	r2,-32(fp)
8113eef0:	10800817 	ldw	r2,32(r2)
8113eef4:	10004226 	beq	r2,zero,8113f000 <OSTaskChangePrio+0x480>
        pevents =  ptcb->OSTCBEventMultiPtr;
8113eef8:	e0bff817 	ldw	r2,-32(fp)
8113eefc:	10800817 	ldw	r2,32(r2)
8113ef00:	e0bff415 	stw	r2,-48(fp)
        pevent  = *pevents;
8113ef04:	e0bff417 	ldw	r2,-48(fp)
8113ef08:	10800017 	ldw	r2,0(r2)
8113ef0c:	e0bff315 	stw	r2,-52(fp)
        while (pevent != (OS_EVENT *)0) {
8113ef10:	00003906 	br	8113eff8 <OSTaskChangePrio+0x478>
            pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
8113ef14:	e0bffc03 	ldbu	r2,-16(fp)
8113ef18:	e0fffc03 	ldbu	r3,-16(fp)
8113ef1c:	e13ff317 	ldw	r4,-52(fp)
8113ef20:	20c7883a 	add	r3,r4,r3
8113ef24:	18c002c4 	addi	r3,r3,11
8113ef28:	18c00003 	ldbu	r3,0(r3)
8113ef2c:	1809883a 	mov	r4,r3
8113ef30:	e0fffc83 	ldbu	r3,-14(fp)
8113ef34:	00c6303a 	nor	r3,zero,r3
8113ef38:	20c6703a 	and	r3,r4,r3
8113ef3c:	1809883a 	mov	r4,r3
8113ef40:	e0fff317 	ldw	r3,-52(fp)
8113ef44:	1885883a 	add	r2,r3,r2
8113ef48:	108002c4 	addi	r2,r2,11
8113ef4c:	11000005 	stb	r4,0(r2)
            if (pevent->OSEventTbl[y_old] == 0) {
8113ef50:	e0bffc03 	ldbu	r2,-16(fp)
8113ef54:	e0fff317 	ldw	r3,-52(fp)
8113ef58:	1885883a 	add	r2,r3,r2
8113ef5c:	108002c4 	addi	r2,r2,11
8113ef60:	10800003 	ldbu	r2,0(r2)
8113ef64:	10803fcc 	andi	r2,r2,255
8113ef68:	1000091e 	bne	r2,zero,8113ef90 <OSTaskChangePrio+0x410>
                pevent->OSEventGrp    &= ~bity_old;
8113ef6c:	e0bff317 	ldw	r2,-52(fp)
8113ef70:	10800283 	ldbu	r2,10(r2)
8113ef74:	1007883a 	mov	r3,r2
8113ef78:	e0bffc43 	ldbu	r2,-15(fp)
8113ef7c:	0084303a 	nor	r2,zero,r2
8113ef80:	1884703a 	and	r2,r3,r2
8113ef84:	1007883a 	mov	r3,r2
8113ef88:	e0bff317 	ldw	r2,-52(fp)
8113ef8c:	10c00285 	stb	r3,10(r2)
            }
            pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
8113ef90:	e0bff317 	ldw	r2,-52(fp)
8113ef94:	10c00283 	ldbu	r3,10(r2)
8113ef98:	e0bffb83 	ldbu	r2,-18(fp)
8113ef9c:	1884b03a 	or	r2,r3,r2
8113efa0:	1007883a 	mov	r3,r2
8113efa4:	e0bff317 	ldw	r2,-52(fp)
8113efa8:	10c00285 	stb	r3,10(r2)
            pevent->OSEventTbl[y_new] |= bitx_new;
8113efac:	e0bffb03 	ldbu	r2,-20(fp)
8113efb0:	e0fffb03 	ldbu	r3,-20(fp)
8113efb4:	e13ff317 	ldw	r4,-52(fp)
8113efb8:	20c7883a 	add	r3,r4,r3
8113efbc:	18c002c4 	addi	r3,r3,11
8113efc0:	19000003 	ldbu	r4,0(r3)
8113efc4:	e0fffbc3 	ldbu	r3,-17(fp)
8113efc8:	20c6b03a 	or	r3,r4,r3
8113efcc:	1809883a 	mov	r4,r3
8113efd0:	e0fff317 	ldw	r3,-52(fp)
8113efd4:	1885883a 	add	r2,r3,r2
8113efd8:	108002c4 	addi	r2,r2,11
8113efdc:	11000005 	stb	r4,0(r2)
            pevents++;
8113efe0:	e0bff417 	ldw	r2,-48(fp)
8113efe4:	10800104 	addi	r2,r2,4
8113efe8:	e0bff415 	stw	r2,-48(fp)
            pevent                     = *pevents;
8113efec:	e0bff417 	ldw	r2,-48(fp)
8113eff0:	10800017 	ldw	r2,0(r2)
8113eff4:	e0bff315 	stw	r2,-52(fp)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
        pevents =  ptcb->OSTCBEventMultiPtr;
        pevent  = *pevents;
        while (pevent != (OS_EVENT *)0) {
8113eff8:	e0bff317 	ldw	r2,-52(fp)
8113effc:	103fc51e 	bne	r2,zero,8113ef14 <__reset+0xfb11ef14>
        }
    }
#endif
#endif

    ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
8113f000:	e0bff817 	ldw	r2,-32(fp)
8113f004:	e0ffff03 	ldbu	r3,-4(fp)
8113f008:	10c00c85 	stb	r3,50(r2)
    ptcb->OSTCBY    = y_new;
8113f00c:	e0bff817 	ldw	r2,-32(fp)
8113f010:	e0fffb03 	ldbu	r3,-20(fp)
8113f014:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX    = x_new;
8113f018:	e0bff817 	ldw	r2,-32(fp)
8113f01c:	e0fffb43 	ldbu	r3,-19(fp)
8113f020:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY = bity_new;
8113f024:	e0bff817 	ldw	r2,-32(fp)
8113f028:	e0fffb83 	ldbu	r3,-18(fp)
8113f02c:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX = bitx_new;
8113f030:	e0bff817 	ldw	r2,-32(fp)
8113f034:	e0fffbc3 	ldbu	r3,-17(fp)
8113f038:	10c00d45 	stb	r3,53(r2)
8113f03c:	e0bff517 	ldw	r2,-44(fp)
8113f040:	e0bffa15 	stw	r2,-24(fp)
8113f044:	e0bffa17 	ldw	r2,-24(fp)
8113f048:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
8113f04c:	d0a09103 	ldbu	r2,-32188(gp)
8113f050:	10803fcc 	andi	r2,r2,255
8113f054:	10800058 	cmpnei	r2,r2,1
8113f058:	1000011e 	bne	r2,zero,8113f060 <OSTaskChangePrio+0x4e0>
        OS_Sched();                                         /* Find new highest priority task          */
8113f05c:	11396100 	call	81139610 <OS_Sched>
    }
    return (OS_ERR_NONE);
8113f060:	0005883a 	mov	r2,zero
}
8113f064:	e037883a 	mov	sp,fp
8113f068:	dfc00117 	ldw	ra,4(sp)
8113f06c:	df000017 	ldw	fp,0(sp)
8113f070:	dec00204 	addi	sp,sp,8
8113f074:	f800283a 	ret

8113f078 <OSTaskCreate>:
*********************************************************************************************************
*/

#if OS_TASK_CREATE_EN > 0
INT8U  OSTaskCreate (void (*task)(void *p_arg), void *p_arg, OS_STK *ptos, INT8U prio)
{
8113f078:	deffee04 	addi	sp,sp,-72
8113f07c:	de00012e 	bgeu	sp,et,8113f084 <OSTaskCreate+0xc>
8113f080:	003b68fa 	trap	3
8113f084:	dfc01115 	stw	ra,68(sp)
8113f088:	df001015 	stw	fp,64(sp)
8113f08c:	df001004 	addi	fp,sp,64
8113f090:	e13ffc15 	stw	r4,-16(fp)
8113f094:	e17ffd15 	stw	r5,-12(fp)
8113f098:	e1bffe15 	stw	r6,-8(fp)
8113f09c:	3805883a 	mov	r2,r7
8113f0a0:	e0bfff05 	stb	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
8113f0a4:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
8113f0a8:	e0bfff03 	ldbu	r2,-4(fp)
8113f0ac:	10800af0 	cmpltui	r2,r2,43
8113f0b0:	1000021e 	bne	r2,zero,8113f0bc <OSTaskCreate+0x44>
        return (OS_ERR_PRIO_INVALID);
8113f0b4:	00800a84 	movi	r2,42
8113f0b8:	00005706 	br	8113f218 <OSTaskCreate+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f0bc:	0005303a 	rdctl	r2,status
8113f0c0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f0c4:	e0fffb17 	ldw	r3,-20(fp)
8113f0c8:	00bfff84 	movi	r2,-2
8113f0cc:	1884703a 	and	r2,r3,r2
8113f0d0:	1001703a 	wrctl	status,r2
  
  return context;
8113f0d4:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113f0d8:	e0bff315 	stw	r2,-52(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
8113f0dc:	d0a0a103 	ldbu	r2,-32124(gp)
8113f0e0:	10803fcc 	andi	r2,r2,255
8113f0e4:	10000626 	beq	r2,zero,8113f100 <OSTaskCreate+0x88>
8113f0e8:	e0bff317 	ldw	r2,-52(fp)
8113f0ec:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f0f0:	e0bff417 	ldw	r2,-48(fp)
8113f0f4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
8113f0f8:	00800f04 	movi	r2,60
8113f0fc:	00004606 	br	8113f218 <OSTaskCreate+0x1a0>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
8113f100:	e0ffff03 	ldbu	r3,-4(fp)
8113f104:	00a045f4 	movhi	r2,33047
8113f108:	10b1de04 	addi	r2,r2,-14472
8113f10c:	18c7883a 	add	r3,r3,r3
8113f110:	18c7883a 	add	r3,r3,r3
8113f114:	10c5883a 	add	r2,r2,r3
8113f118:	10800017 	ldw	r2,0(r2)
8113f11c:	1000391e 	bne	r2,zero,8113f204 <OSTaskCreate+0x18c>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
8113f120:	e0ffff03 	ldbu	r3,-4(fp)
8113f124:	00a045f4 	movhi	r2,33047
8113f128:	10b1de04 	addi	r2,r2,-14472
8113f12c:	18c7883a 	add	r3,r3,r3
8113f130:	18c7883a 	add	r3,r3,r3
8113f134:	10c5883a 	add	r2,r2,r3
8113f138:	00c00044 	movi	r3,1
8113f13c:	10c00015 	stw	r3,0(r2)
8113f140:	e0bff317 	ldw	r2,-52(fp)
8113f144:	e0bff515 	stw	r2,-44(fp)
8113f148:	e0bff517 	ldw	r2,-44(fp)
8113f14c:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
        psp = OSTaskStkInit(task, p_arg, ptos, 0);              /* Initialize the task's stack         */
8113f150:	000f883a 	mov	r7,zero
8113f154:	e1bffe17 	ldw	r6,-8(fp)
8113f158:	e17ffd17 	ldw	r5,-12(fp)
8113f15c:	e13ffc17 	ldw	r4,-16(fp)
8113f160:	114a7200 	call	8114a720 <OSTaskStkInit>
8113f164:	e0bff715 	stw	r2,-36(fp)
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
8113f168:	e0bfff03 	ldbu	r2,-4(fp)
8113f16c:	d8000215 	stw	zero,8(sp)
8113f170:	d8000115 	stw	zero,4(sp)
8113f174:	d8000015 	stw	zero,0(sp)
8113f178:	000f883a 	mov	r7,zero
8113f17c:	000d883a 	mov	r6,zero
8113f180:	e17ff717 	ldw	r5,-36(fp)
8113f184:	1009883a 	mov	r4,r2
8113f188:	1139a580 	call	81139a58 <OS_TCBInit>
8113f18c:	e0bff805 	stb	r2,-32(fp)
        if (err == OS_ERR_NONE) {
8113f190:	e0bff803 	ldbu	r2,-32(fp)
8113f194:	1000061e 	bne	r2,zero,8113f1b0 <OSTaskCreate+0x138>
            if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
8113f198:	d0a09103 	ldbu	r2,-32188(gp)
8113f19c:	10803fcc 	andi	r2,r2,255
8113f1a0:	10800058 	cmpnei	r2,r2,1
8113f1a4:	1000151e 	bne	r2,zero,8113f1fc <OSTaskCreate+0x184>
                OS_Sched();
8113f1a8:	11396100 	call	81139610 <OS_Sched>
8113f1ac:	00001306 	br	8113f1fc <OSTaskCreate+0x184>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f1b0:	0005303a 	rdctl	r2,status
8113f1b4:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f1b8:	e0fffa17 	ldw	r3,-24(fp)
8113f1bc:	00bfff84 	movi	r2,-2
8113f1c0:	1884703a 	and	r2,r3,r2
8113f1c4:	1001703a 	wrctl	status,r2
  
  return context;
8113f1c8:	e0bffa17 	ldw	r2,-24(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
8113f1cc:	e0bff315 	stw	r2,-52(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
8113f1d0:	e0ffff03 	ldbu	r3,-4(fp)
8113f1d4:	00a045f4 	movhi	r2,33047
8113f1d8:	10b1de04 	addi	r2,r2,-14472
8113f1dc:	18c7883a 	add	r3,r3,r3
8113f1e0:	18c7883a 	add	r3,r3,r3
8113f1e4:	10c5883a 	add	r2,r2,r3
8113f1e8:	10000015 	stw	zero,0(r2)
8113f1ec:	e0bff317 	ldw	r2,-52(fp)
8113f1f0:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f1f4:	e0bff617 	ldw	r2,-40(fp)
8113f1f8:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
8113f1fc:	e0bff803 	ldbu	r2,-32(fp)
8113f200:	00000506 	br	8113f218 <OSTaskCreate+0x1a0>
8113f204:	e0bff317 	ldw	r2,-52(fp)
8113f208:	e0bff915 	stw	r2,-28(fp)
8113f20c:	e0bff917 	ldw	r2,-28(fp)
8113f210:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
8113f214:	00800a04 	movi	r2,40
}
8113f218:	e037883a 	mov	sp,fp
8113f21c:	dfc00117 	ldw	ra,4(sp)
8113f220:	df000017 	ldw	fp,0(sp)
8113f224:	dec00204 	addi	sp,sp,8
8113f228:	f800283a 	ret

8113f22c <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
8113f22c:	deffec04 	addi	sp,sp,-80
8113f230:	de00012e 	bgeu	sp,et,8113f238 <OSTaskCreateExt+0xc>
8113f234:	003b68fa 	trap	3
8113f238:	dfc01315 	stw	ra,76(sp)
8113f23c:	df001215 	stw	fp,72(sp)
8113f240:	df001204 	addi	fp,sp,72
8113f244:	e13ffa15 	stw	r4,-24(fp)
8113f248:	e17ffb15 	stw	r5,-20(fp)
8113f24c:	e1bffc15 	stw	r6,-16(fp)
8113f250:	3809883a 	mov	r4,r7
8113f254:	e0c00217 	ldw	r3,8(fp)
8113f258:	e0800617 	ldw	r2,24(fp)
8113f25c:	e13ffd05 	stb	r4,-12(fp)
8113f260:	e0fffe0d 	sth	r3,-8(fp)
8113f264:	e0bfff0d 	sth	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
8113f268:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
8113f26c:	e0bffd03 	ldbu	r2,-12(fp)
8113f270:	10800af0 	cmpltui	r2,r2,43
8113f274:	1000021e 	bne	r2,zero,8113f280 <OSTaskCreateExt+0x54>
        return (OS_ERR_PRIO_INVALID);
8113f278:	00800a84 	movi	r2,42
8113f27c:	00006106 	br	8113f404 <OSTaskCreateExt+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f280:	0005303a 	rdctl	r2,status
8113f284:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f288:	e0fff917 	ldw	r3,-28(fp)
8113f28c:	00bfff84 	movi	r2,-2
8113f290:	1884703a 	and	r2,r3,r2
8113f294:	1001703a 	wrctl	status,r2
  
  return context;
8113f298:	e0bff917 	ldw	r2,-28(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113f29c:	e0bff115 	stw	r2,-60(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
8113f2a0:	d0a0a103 	ldbu	r2,-32124(gp)
8113f2a4:	10803fcc 	andi	r2,r2,255
8113f2a8:	10000626 	beq	r2,zero,8113f2c4 <OSTaskCreateExt+0x98>
8113f2ac:	e0bff117 	ldw	r2,-60(fp)
8113f2b0:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f2b4:	e0bff217 	ldw	r2,-56(fp)
8113f2b8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
8113f2bc:	00800f04 	movi	r2,60
8113f2c0:	00005006 	br	8113f404 <OSTaskCreateExt+0x1d8>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
8113f2c4:	e0fffd03 	ldbu	r3,-12(fp)
8113f2c8:	00a045f4 	movhi	r2,33047
8113f2cc:	10b1de04 	addi	r2,r2,-14472
8113f2d0:	18c7883a 	add	r3,r3,r3
8113f2d4:	18c7883a 	add	r3,r3,r3
8113f2d8:	10c5883a 	add	r2,r2,r3
8113f2dc:	10800017 	ldw	r2,0(r2)
8113f2e0:	1000431e 	bne	r2,zero,8113f3f0 <OSTaskCreateExt+0x1c4>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
8113f2e4:	e0fffd03 	ldbu	r3,-12(fp)
8113f2e8:	00a045f4 	movhi	r2,33047
8113f2ec:	10b1de04 	addi	r2,r2,-14472
8113f2f0:	18c7883a 	add	r3,r3,r3
8113f2f4:	18c7883a 	add	r3,r3,r3
8113f2f8:	10c5883a 	add	r2,r2,r3
8113f2fc:	00c00044 	movi	r3,1
8113f300:	10c00015 	stw	r3,0(r2)
8113f304:	e0bff117 	ldw	r2,-60(fp)
8113f308:	e0bff315 	stw	r2,-52(fp)
8113f30c:	e0bff317 	ldw	r2,-52(fp)
8113f310:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();

#if (OS_TASK_STAT_STK_CHK_EN > 0)
        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
8113f314:	e0bfff0b 	ldhu	r2,-4(fp)
8113f318:	100d883a 	mov	r6,r2
8113f31c:	e1400417 	ldw	r5,16(fp)
8113f320:	e1000317 	ldw	r4,12(fp)
8113f324:	11402d40 	call	811402d4 <OS_TaskStkClr>
#endif

        psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
8113f328:	e0bfff0b 	ldhu	r2,-4(fp)
8113f32c:	100f883a 	mov	r7,r2
8113f330:	e1bffc17 	ldw	r6,-16(fp)
8113f334:	e17ffb17 	ldw	r5,-20(fp)
8113f338:	e13ffa17 	ldw	r4,-24(fp)
8113f33c:	114a7200 	call	8114a720 <OSTaskStkInit>
8113f340:	e0bff515 	stw	r2,-44(fp)
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
8113f344:	e0fffd03 	ldbu	r3,-12(fp)
8113f348:	e13ffe0b 	ldhu	r4,-8(fp)
8113f34c:	e0bfff0b 	ldhu	r2,-4(fp)
8113f350:	d8800215 	stw	r2,8(sp)
8113f354:	e0800517 	ldw	r2,20(fp)
8113f358:	d8800115 	stw	r2,4(sp)
8113f35c:	e0800417 	ldw	r2,16(fp)
8113f360:	d8800015 	stw	r2,0(sp)
8113f364:	200f883a 	mov	r7,r4
8113f368:	e1800317 	ldw	r6,12(fp)
8113f36c:	e17ff517 	ldw	r5,-44(fp)
8113f370:	1809883a 	mov	r4,r3
8113f374:	1139a580 	call	81139a58 <OS_TCBInit>
8113f378:	e0bff605 	stb	r2,-40(fp)
        if (err == OS_ERR_NONE) {
8113f37c:	e0bff603 	ldbu	r2,-40(fp)
8113f380:	1000061e 	bne	r2,zero,8113f39c <OSTaskCreateExt+0x170>
            if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
8113f384:	d0a09103 	ldbu	r2,-32188(gp)
8113f388:	10803fcc 	andi	r2,r2,255
8113f38c:	10800058 	cmpnei	r2,r2,1
8113f390:	1000151e 	bne	r2,zero,8113f3e8 <OSTaskCreateExt+0x1bc>
                OS_Sched();
8113f394:	11396100 	call	81139610 <OS_Sched>
8113f398:	00001306 	br	8113f3e8 <OSTaskCreateExt+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f39c:	0005303a 	rdctl	r2,status
8113f3a0:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f3a4:	e0fff817 	ldw	r3,-32(fp)
8113f3a8:	00bfff84 	movi	r2,-2
8113f3ac:	1884703a 	and	r2,r3,r2
8113f3b0:	1001703a 	wrctl	status,r2
  
  return context;
8113f3b4:	e0bff817 	ldw	r2,-32(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
8113f3b8:	e0bff115 	stw	r2,-60(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
8113f3bc:	e0fffd03 	ldbu	r3,-12(fp)
8113f3c0:	00a045f4 	movhi	r2,33047
8113f3c4:	10b1de04 	addi	r2,r2,-14472
8113f3c8:	18c7883a 	add	r3,r3,r3
8113f3cc:	18c7883a 	add	r3,r3,r3
8113f3d0:	10c5883a 	add	r2,r2,r3
8113f3d4:	10000015 	stw	zero,0(r2)
8113f3d8:	e0bff117 	ldw	r2,-60(fp)
8113f3dc:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f3e0:	e0bff417 	ldw	r2,-48(fp)
8113f3e4:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
8113f3e8:	e0bff603 	ldbu	r2,-40(fp)
8113f3ec:	00000506 	br	8113f404 <OSTaskCreateExt+0x1d8>
8113f3f0:	e0bff117 	ldw	r2,-60(fp)
8113f3f4:	e0bff715 	stw	r2,-36(fp)
8113f3f8:	e0bff717 	ldw	r2,-36(fp)
8113f3fc:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
8113f400:	00800a04 	movi	r2,40
}
8113f404:	e037883a 	mov	sp,fp
8113f408:	dfc00117 	ldw	ra,4(sp)
8113f40c:	df000017 	ldw	fp,0(sp)
8113f410:	dec00204 	addi	sp,sp,8
8113f414:	f800283a 	ret

8113f418 <OSTaskDel>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDel (INT8U prio)
{
8113f418:	defff404 	addi	sp,sp,-48
8113f41c:	de00012e 	bgeu	sp,et,8113f424 <OSTaskDel+0xc>
8113f420:	003b68fa 	trap	3
8113f424:	dfc00b15 	stw	ra,44(sp)
8113f428:	df000a15 	stw	fp,40(sp)
8113f42c:	df000a04 	addi	fp,sp,40
8113f430:	2005883a 	mov	r2,r4
8113f434:	e0bfff05 	stb	r2,-4(fp)
#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FLAG_NODE *pnode;
#endif
    OS_TCB       *ptcb;
#if OS_CRITICAL_METHOD == 3                             /* Allocate storage for CPU status register    */
    OS_CPU_SR     cpu_sr = 0;
8113f438:	e03ff615 	stw	zero,-40(fp)
#endif



    if (OSIntNesting > 0) {                             /* See if trying to delete from ISR            */
8113f43c:	d0a0a103 	ldbu	r2,-32124(gp)
8113f440:	10803fcc 	andi	r2,r2,255
8113f444:	10000226 	beq	r2,zero,8113f450 <OSTaskDel+0x38>
        return (OS_ERR_TASK_DEL_ISR);
8113f448:	00801004 	movi	r2,64
8113f44c:	0000c006 	br	8113f750 <OSTaskDel+0x338>
    }
    if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
8113f450:	e0bfff03 	ldbu	r2,-4(fp)
8113f454:	10800a98 	cmpnei	r2,r2,42
8113f458:	1000021e 	bne	r2,zero,8113f464 <OSTaskDel+0x4c>
        return (OS_ERR_TASK_DEL_IDLE);
8113f45c:	00800f84 	movi	r2,62
8113f460:	0000bb06 	br	8113f750 <OSTaskDel+0x338>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
8113f464:	e0bfff03 	ldbu	r2,-4(fp)
8113f468:	10800ab0 	cmpltui	r2,r2,42
8113f46c:	1000051e 	bne	r2,zero,8113f484 <OSTaskDel+0x6c>
        if (prio != OS_PRIO_SELF) {
8113f470:	e0bfff03 	ldbu	r2,-4(fp)
8113f474:	10803fe0 	cmpeqi	r2,r2,255
8113f478:	1000021e 	bne	r2,zero,8113f484 <OSTaskDel+0x6c>
            return (OS_ERR_PRIO_INVALID);
8113f47c:	00800a84 	movi	r2,42
8113f480:	0000b306 	br	8113f750 <OSTaskDel+0x338>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f484:	0005303a 	rdctl	r2,status
8113f488:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f48c:	e0fffe17 	ldw	r3,-8(fp)
8113f490:	00bfff84 	movi	r2,-2
8113f494:	1884703a 	and	r2,r3,r2
8113f498:	1001703a 	wrctl	status,r2
  
  return context;
8113f49c:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif

/*$PAGE*/
    OS_ENTER_CRITICAL();
8113f4a0:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
8113f4a4:	e0bfff03 	ldbu	r2,-4(fp)
8113f4a8:	10803fd8 	cmpnei	r2,r2,255
8113f4ac:	1000031e 	bne	r2,zero,8113f4bc <OSTaskDel+0xa4>
        prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
8113f4b0:	d0a0a217 	ldw	r2,-32120(gp)
8113f4b4:	10800c83 	ldbu	r2,50(r2)
8113f4b8:	e0bfff05 	stb	r2,-4(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113f4bc:	e0ffff03 	ldbu	r3,-4(fp)
8113f4c0:	00a045f4 	movhi	r2,33047
8113f4c4:	10b1de04 	addi	r2,r2,-14472
8113f4c8:	18c7883a 	add	r3,r3,r3
8113f4cc:	18c7883a 	add	r3,r3,r3
8113f4d0:	10c5883a 	add	r2,r2,r3
8113f4d4:	10800017 	ldw	r2,0(r2)
8113f4d8:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
8113f4dc:	e0bff817 	ldw	r2,-32(fp)
8113f4e0:	1000061e 	bne	r2,zero,8113f4fc <OSTaskDel+0xe4>
8113f4e4:	e0bff617 	ldw	r2,-40(fp)
8113f4e8:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f4ec:	e0bff717 	ldw	r2,-36(fp)
8113f4f0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113f4f4:	008010c4 	movi	r2,67
8113f4f8:	00009506 	br	8113f750 <OSTaskDel+0x338>
    }
    if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
8113f4fc:	e0bff817 	ldw	r2,-32(fp)
8113f500:	10800058 	cmpnei	r2,r2,1
8113f504:	1000061e 	bne	r2,zero,8113f520 <OSTaskDel+0x108>
8113f508:	e0bff617 	ldw	r2,-40(fp)
8113f50c:	e0bff915 	stw	r2,-28(fp)
8113f510:	e0bff917 	ldw	r2,-28(fp)
8113f514:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
8113f518:	00800f44 	movi	r2,61
8113f51c:	00008c06 	br	8113f750 <OSTaskDel+0x338>
    }

    OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX;
8113f520:	e0bff817 	ldw	r2,-32(fp)
8113f524:	10800d03 	ldbu	r2,52(r2)
8113f528:	10c03fcc 	andi	r3,r2,255
8113f52c:	e0bff817 	ldw	r2,-32(fp)
8113f530:	10800d03 	ldbu	r2,52(r2)
8113f534:	11003fcc 	andi	r4,r2,255
8113f538:	d0a09e44 	addi	r2,gp,-32135
8113f53c:	2085883a 	add	r2,r4,r2
8113f540:	10800003 	ldbu	r2,0(r2)
8113f544:	1009883a 	mov	r4,r2
8113f548:	e0bff817 	ldw	r2,-32(fp)
8113f54c:	10800d43 	ldbu	r2,53(r2)
8113f550:	0084303a 	nor	r2,zero,r2
8113f554:	2084703a 	and	r2,r4,r2
8113f558:	1009883a 	mov	r4,r2
8113f55c:	d0a09e44 	addi	r2,gp,-32135
8113f560:	1885883a 	add	r2,r3,r2
8113f564:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[ptcb->OSTCBY] == 0) {                  /* Make task not ready                         */
8113f568:	e0bff817 	ldw	r2,-32(fp)
8113f56c:	10800d03 	ldbu	r2,52(r2)
8113f570:	10c03fcc 	andi	r3,r2,255
8113f574:	d0a09e44 	addi	r2,gp,-32135
8113f578:	1885883a 	add	r2,r3,r2
8113f57c:	10800003 	ldbu	r2,0(r2)
8113f580:	10803fcc 	andi	r2,r2,255
8113f584:	1000071e 	bne	r2,zero,8113f5a4 <OSTaskDel+0x18c>
        OSRdyGrp           &= ~ptcb->OSTCBBitY;
8113f588:	e0bff817 	ldw	r2,-32(fp)
8113f58c:	10800d83 	ldbu	r2,54(r2)
8113f590:	0084303a 	nor	r2,zero,r2
8113f594:	1007883a 	mov	r3,r2
8113f598:	d0a09e03 	ldbu	r2,-32136(gp)
8113f59c:	1884703a 	and	r2,r3,r2
8113f5a0:	d0a09e05 	stb	r2,-32136(gp)
    }
    
#if (OS_EVENT_EN)
    if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
8113f5a4:	e0bff817 	ldw	r2,-32(fp)
8113f5a8:	10800717 	ldw	r2,28(r2)
8113f5ac:	10000526 	beq	r2,zero,8113f5c4 <OSTaskDel+0x1ac>
        OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
8113f5b0:	e0bff817 	ldw	r2,-32(fp)
8113f5b4:	10800717 	ldw	r2,28(r2)
8113f5b8:	100b883a 	mov	r5,r2
8113f5bc:	e13ff817 	ldw	r4,-32(fp)
8113f5c0:	1138f640 	call	81138f64 <OS_EventTaskRemove>
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
8113f5c4:	e0bff817 	ldw	r2,-32(fp)
8113f5c8:	10800817 	ldw	r2,32(r2)
8113f5cc:	10000526 	beq	r2,zero,8113f5e4 <OSTaskDel+0x1cc>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
8113f5d0:	e0bff817 	ldw	r2,-32(fp)
8113f5d4:	10800817 	ldw	r2,32(r2)
8113f5d8:	100b883a 	mov	r5,r2
8113f5dc:	e13ff817 	ldw	r4,-32(fp)
8113f5e0:	11390240 	call	81139024 <OS_EventTaskRemoveMulti>
    }
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    pnode = ptcb->OSTCBFlagNode;
8113f5e4:	e0bff817 	ldw	r2,-32(fp)
8113f5e8:	10800a17 	ldw	r2,40(r2)
8113f5ec:	e0bffb15 	stw	r2,-20(fp)
    if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
8113f5f0:	e0bffb17 	ldw	r2,-20(fp)
8113f5f4:	10000226 	beq	r2,zero,8113f600 <OSTaskDel+0x1e8>
        OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
8113f5f8:	e13ffb17 	ldw	r4,-20(fp)
8113f5fc:	113b5fc0 	call	8113b5fc <OS_FlagUnlink>
    }
#endif

    ptcb->OSTCBDly      = 0;                            /* Prevent OSTimeTick() from updating          */
8113f600:	e0bff817 	ldw	r2,-32(fp)
8113f604:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
8113f608:	e0bff817 	ldw	r2,-32(fp)
8113f60c:	10000c05 	stb	zero,48(r2)
    ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
8113f610:	e0bff817 	ldw	r2,-32(fp)
8113f614:	10000c45 	stb	zero,49(r2)
    if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
8113f618:	d0a08f03 	ldbu	r2,-32196(gp)
8113f61c:	10803fcc 	andi	r2,r2,255
8113f620:	10803fe0 	cmpeqi	r2,r2,255
8113f624:	1000031e 	bne	r2,zero,8113f634 <OSTaskDel+0x21c>
        OSLockNesting++;
8113f628:	d0a08f03 	ldbu	r2,-32196(gp)
8113f62c:	10800044 	addi	r2,r2,1
8113f630:	d0a08f05 	stb	r2,-32196(gp)
8113f634:	e0bff617 	ldw	r2,-40(fp)
8113f638:	e0bffd15 	stw	r2,-12(fp)
8113f63c:	e0bffd17 	ldw	r2,-12(fp)
8113f640:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
    OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
8113f644:	1138b2c0 	call	81138b2c <OS_Dummy>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f648:	0005303a 	rdctl	r2,status
8113f64c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f650:	e0fffa17 	ldw	r3,-24(fp)
8113f654:	00bfff84 	movi	r2,-2
8113f658:	1884703a 	and	r2,r3,r2
8113f65c:	1001703a 	wrctl	status,r2
  
  return context;
8113f660:	e0bffa17 	ldw	r2,-24(fp)
    OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
8113f664:	e0bff615 	stw	r2,-40(fp)
    if (OSLockNesting > 0) {                            /* Remove context switch lock                  */
8113f668:	d0a08f03 	ldbu	r2,-32196(gp)
8113f66c:	10803fcc 	andi	r2,r2,255
8113f670:	10000326 	beq	r2,zero,8113f680 <OSTaskDel+0x268>
        OSLockNesting--;
8113f674:	d0a08f03 	ldbu	r2,-32196(gp)
8113f678:	10bfffc4 	addi	r2,r2,-1
8113f67c:	d0a08f05 	stb	r2,-32196(gp)
    }
    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
8113f680:	e13ff817 	ldw	r4,-32(fp)
8113f684:	114a8b00 	call	8114a8b0 <OSTaskDelHook>
    OSTaskCtr--;                                        /* One less task being managed                 */
8113f688:	d0a09a43 	ldbu	r2,-32151(gp)
8113f68c:	10bfffc4 	addi	r2,r2,-1
8113f690:	d0a09a45 	stb	r2,-32151(gp)
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
8113f694:	e0ffff03 	ldbu	r3,-4(fp)
8113f698:	00a045f4 	movhi	r2,33047
8113f69c:	10b1de04 	addi	r2,r2,-14472
8113f6a0:	18c7883a 	add	r3,r3,r3
8113f6a4:	18c7883a 	add	r3,r3,r3
8113f6a8:	10c5883a 	add	r2,r2,r3
8113f6ac:	10000015 	stw	zero,0(r2)
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
8113f6b0:	e0bff817 	ldw	r2,-32(fp)
8113f6b4:	10800617 	ldw	r2,24(r2)
8113f6b8:	1000071e 	bne	r2,zero,8113f6d8 <OSTaskDel+0x2c0>
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
8113f6bc:	e0bff817 	ldw	r2,-32(fp)
8113f6c0:	10800517 	ldw	r2,20(r2)
8113f6c4:	10000615 	stw	zero,24(r2)
        OSTCBList                  = ptcb->OSTCBNext;
8113f6c8:	e0bff817 	ldw	r2,-32(fp)
8113f6cc:	10800517 	ldw	r2,20(r2)
8113f6d0:	d0a09415 	stw	r2,-32176(gp)
8113f6d4:	00000a06 	br	8113f700 <OSTaskDel+0x2e8>
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
8113f6d8:	e0bff817 	ldw	r2,-32(fp)
8113f6dc:	10800617 	ldw	r2,24(r2)
8113f6e0:	e0fff817 	ldw	r3,-32(fp)
8113f6e4:	18c00517 	ldw	r3,20(r3)
8113f6e8:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
8113f6ec:	e0bff817 	ldw	r2,-32(fp)
8113f6f0:	10800517 	ldw	r2,20(r2)
8113f6f4:	e0fff817 	ldw	r3,-32(fp)
8113f6f8:	18c00617 	ldw	r3,24(r3)
8113f6fc:	10c00615 	stw	r3,24(r2)
    }
    ptcb->OSTCBNext   = OSTCBFreeList;                  /* Return TCB to free TCB list                 */
8113f700:	d0e09917 	ldw	r3,-32156(gp)
8113f704:	e0bff817 	ldw	r2,-32(fp)
8113f708:	10c00515 	stw	r3,20(r2)
    OSTCBFreeList     = ptcb;
8113f70c:	e0bff817 	ldw	r2,-32(fp)
8113f710:	d0a09915 	stw	r2,-32156(gp)
#if OS_TASK_NAME_SIZE > 1
    ptcb->OSTCBTaskName[0] = '?';                       /* Unknown name                                */
8113f714:	e0bff817 	ldw	r2,-32(fp)
8113f718:	00c00fc4 	movi	r3,63
8113f71c:	10c01305 	stb	r3,76(r2)
    ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
8113f720:	e0bff817 	ldw	r2,-32(fp)
8113f724:	10001345 	stb	zero,77(r2)
8113f728:	e0bff617 	ldw	r2,-40(fp)
8113f72c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f730:	e0bffc17 	ldw	r2,-16(fp)
8113f734:	1001703a 	wrctl	status,r2
#endif
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
8113f738:	d0a09103 	ldbu	r2,-32188(gp)
8113f73c:	10803fcc 	andi	r2,r2,255
8113f740:	10800058 	cmpnei	r2,r2,1
8113f744:	1000011e 	bne	r2,zero,8113f74c <OSTaskDel+0x334>
        OS_Sched();                                     /* Find new highest priority task              */
8113f748:	11396100 	call	81139610 <OS_Sched>
    }
    return (OS_ERR_NONE);
8113f74c:	0005883a 	mov	r2,zero
}
8113f750:	e037883a 	mov	sp,fp
8113f754:	dfc00117 	ldw	ra,4(sp)
8113f758:	df000017 	ldw	fp,0(sp)
8113f75c:	dec00204 	addi	sp,sp,8
8113f760:	f800283a 	ret

8113f764 <OSTaskDelReq>:
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDelReq (INT8U prio)
{
8113f764:	defff504 	addi	sp,sp,-44
8113f768:	de00012e 	bgeu	sp,et,8113f770 <OSTaskDelReq+0xc>
8113f76c:	003b68fa 	trap	3
8113f770:	df000a15 	stw	fp,40(sp)
8113f774:	df000a04 	addi	fp,sp,40
8113f778:	2005883a 	mov	r2,r4
8113f77c:	e0bfff05 	stb	r2,-4(fp)
    INT8U      stat;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113f780:	e03ff615 	stw	zero,-40(fp)
#endif



    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
8113f784:	e0bfff03 	ldbu	r2,-4(fp)
8113f788:	10800a98 	cmpnei	r2,r2,42
8113f78c:	1000021e 	bne	r2,zero,8113f798 <OSTaskDelReq+0x34>
        return (OS_ERR_TASK_DEL_IDLE);
8113f790:	00800f84 	movi	r2,62
8113f794:	00004506 	br	8113f8ac <OSTaskDelReq+0x148>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
8113f798:	e0bfff03 	ldbu	r2,-4(fp)
8113f79c:	10800ab0 	cmpltui	r2,r2,42
8113f7a0:	1000051e 	bne	r2,zero,8113f7b8 <OSTaskDelReq+0x54>
        if (prio != OS_PRIO_SELF) {
8113f7a4:	e0bfff03 	ldbu	r2,-4(fp)
8113f7a8:	10803fe0 	cmpeqi	r2,r2,255
8113f7ac:	1000021e 	bne	r2,zero,8113f7b8 <OSTaskDelReq+0x54>
            return (OS_ERR_PRIO_INVALID);
8113f7b0:	00800a84 	movi	r2,42
8113f7b4:	00003d06 	br	8113f8ac <OSTaskDelReq+0x148>
        }
    }
#endif
    if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
8113f7b8:	e0bfff03 	ldbu	r2,-4(fp)
8113f7bc:	10803fd8 	cmpnei	r2,r2,255
8113f7c0:	1000111e 	bne	r2,zero,8113f808 <OSTaskDelReq+0xa4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f7c4:	0005303a 	rdctl	r2,status
8113f7c8:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f7cc:	e0fff917 	ldw	r3,-28(fp)
8113f7d0:	00bfff84 	movi	r2,-2
8113f7d4:	1884703a 	and	r2,r3,r2
8113f7d8:	1001703a 	wrctl	status,r2
  
  return context;
8113f7dc:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
8113f7e0:	e0bff615 	stw	r2,-40(fp)
        stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
8113f7e4:	d0a0a217 	ldw	r2,-32120(gp)
8113f7e8:	10800dc3 	ldbu	r2,55(r2)
8113f7ec:	e0bff805 	stb	r2,-32(fp)
8113f7f0:	e0bff617 	ldw	r2,-40(fp)
8113f7f4:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f7f8:	e0bffe17 	ldw	r2,-8(fp)
8113f7fc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (stat);
8113f800:	e0bff803 	ldbu	r2,-32(fp)
8113f804:	00002906 	br	8113f8ac <OSTaskDelReq+0x148>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f808:	0005303a 	rdctl	r2,status
8113f80c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f810:	e0fff717 	ldw	r3,-36(fp)
8113f814:	00bfff84 	movi	r2,-2
8113f818:	1884703a 	and	r2,r3,r2
8113f81c:	1001703a 	wrctl	status,r2
  
  return context;
8113f820:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
8113f824:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
8113f828:	e0ffff03 	ldbu	r3,-4(fp)
8113f82c:	00a045f4 	movhi	r2,33047
8113f830:	10b1de04 	addi	r2,r2,-14472
8113f834:	18c7883a 	add	r3,r3,r3
8113f838:	18c7883a 	add	r3,r3,r3
8113f83c:	10c5883a 	add	r2,r2,r3
8113f840:	10800017 	ldw	r2,0(r2)
8113f844:	e0bffb15 	stw	r2,-20(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
8113f848:	e0bffb17 	ldw	r2,-20(fp)
8113f84c:	1000061e 	bne	r2,zero,8113f868 <OSTaskDelReq+0x104>
8113f850:	e0bff617 	ldw	r2,-40(fp)
8113f854:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f858:	e0bffa17 	ldw	r2,-24(fp)
8113f85c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
8113f860:	008010c4 	movi	r2,67
8113f864:	00001106 	br	8113f8ac <OSTaskDelReq+0x148>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
8113f868:	e0bffb17 	ldw	r2,-20(fp)
8113f86c:	10800058 	cmpnei	r2,r2,1
8113f870:	1000061e 	bne	r2,zero,8113f88c <OSTaskDelReq+0x128>
8113f874:	e0bff617 	ldw	r2,-40(fp)
8113f878:	e0bffc15 	stw	r2,-16(fp)
8113f87c:	e0bffc17 	ldw	r2,-16(fp)
8113f880:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
8113f884:	00800f44 	movi	r2,61
8113f888:	00000806 	br	8113f8ac <OSTaskDelReq+0x148>
    }
    ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
8113f88c:	e0bffb17 	ldw	r2,-20(fp)
8113f890:	00c00fc4 	movi	r3,63
8113f894:	10c00dc5 	stb	r3,55(r2)
8113f898:	e0bff617 	ldw	r2,-40(fp)
8113f89c:	e0bffd15 	stw	r2,-12(fp)
8113f8a0:	e0bffd17 	ldw	r2,-12(fp)
8113f8a4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113f8a8:	0005883a 	mov	r2,zero
}
8113f8ac:	e037883a 	mov	sp,fp
8113f8b0:	df000017 	ldw	fp,0(sp)
8113f8b4:	dec00104 	addi	sp,sp,4
8113f8b8:	f800283a 	ret

8113f8bc <OSTaskNameGet>:
*********************************************************************************************************
*/

#if OS_TASK_NAME_SIZE > 1
INT8U  OSTaskNameGet (INT8U prio, INT8U *pname, INT8U *perr)
{
8113f8bc:	defff404 	addi	sp,sp,-48
8113f8c0:	de00012e 	bgeu	sp,et,8113f8c8 <OSTaskNameGet+0xc>
8113f8c4:	003b68fa 	trap	3
8113f8c8:	dfc00b15 	stw	ra,44(sp)
8113f8cc:	df000a15 	stw	fp,40(sp)
8113f8d0:	df000a04 	addi	fp,sp,40
8113f8d4:	2005883a 	mov	r2,r4
8113f8d8:	e17ffe15 	stw	r5,-8(fp)
8113f8dc:	e1bfff15 	stw	r6,-4(fp)
8113f8e0:	e0bffd05 	stb	r2,-12(fp)
    OS_TCB    *ptcb;
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                              /* Allocate storage for CPU status register   */
    OS_CPU_SR  cpu_sr = 0;
8113f8e4:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                            /* Validate 'perr'                            */
8113f8e8:	e0bfff17 	ldw	r2,-4(fp)
8113f8ec:	1000021e 	bne	r2,zero,8113f8f8 <OSTaskNameGet+0x3c>
        return (0);
8113f8f0:	0005883a 	mov	r2,zero
8113f8f4:	00005406 	br	8113fa48 <OSTaskNameGet+0x18c>
    }
    if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
8113f8f8:	e0bffd03 	ldbu	r2,-12(fp)
8113f8fc:	10800af0 	cmpltui	r2,r2,43
8113f900:	1000081e 	bne	r2,zero,8113f924 <OSTaskNameGet+0x68>
        if (prio != OS_PRIO_SELF) {
8113f904:	e0bffd03 	ldbu	r2,-12(fp)
8113f908:	10803fe0 	cmpeqi	r2,r2,255
8113f90c:	1000051e 	bne	r2,zero,8113f924 <OSTaskNameGet+0x68>
            *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
8113f910:	e0bfff17 	ldw	r2,-4(fp)
8113f914:	00c00a84 	movi	r3,42
8113f918:	10c00005 	stb	r3,0(r2)
            return (0);
8113f91c:	0005883a 	mov	r2,zero
8113f920:	00004906 	br	8113fa48 <OSTaskNameGet+0x18c>
        }
    }
    if (pname == (INT8U *)0) {                           /* Is 'pname' a NULL pointer?                 */
8113f924:	e0bffe17 	ldw	r2,-8(fp)
8113f928:	1000051e 	bne	r2,zero,8113f940 <OSTaskNameGet+0x84>
        *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
8113f92c:	e0bfff17 	ldw	r2,-4(fp)
8113f930:	00c00304 	movi	r3,12
8113f934:	10c00005 	stb	r3,0(r2)
        return (0);
8113f938:	0005883a 	mov	r2,zero
8113f93c:	00004206 	br	8113fa48 <OSTaskNameGet+0x18c>
    }
#endif
    if (OSIntNesting > 0) {                              /* See if trying to call from an ISR          */
8113f940:	d0a0a103 	ldbu	r2,-32124(gp)
8113f944:	10803fcc 	andi	r2,r2,255
8113f948:	10000526 	beq	r2,zero,8113f960 <OSTaskNameGet+0xa4>
        *perr = OS_ERR_NAME_GET_ISR;
8113f94c:	e0bfff17 	ldw	r2,-4(fp)
8113f950:	00c00444 	movi	r3,17
8113f954:	10c00005 	stb	r3,0(r2)
        return (0);
8113f958:	0005883a 	mov	r2,zero
8113f95c:	00003a06 	br	8113fa48 <OSTaskNameGet+0x18c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f960:	0005303a 	rdctl	r2,status
8113f964:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f968:	e0fffc17 	ldw	r3,-16(fp)
8113f96c:	00bfff84 	movi	r2,-2
8113f970:	1884703a 	and	r2,r3,r2
8113f974:	1001703a 	wrctl	status,r2
  
  return context;
8113f978:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113f97c:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
8113f980:	e0bffd03 	ldbu	r2,-12(fp)
8113f984:	10803fd8 	cmpnei	r2,r2,255
8113f988:	1000031e 	bne	r2,zero,8113f998 <OSTaskNameGet+0xdc>
        prio = OSTCBCur->OSTCBPrio;
8113f98c:	d0a0a217 	ldw	r2,-32120(gp)
8113f990:	10800c83 	ldbu	r2,50(r2)
8113f994:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113f998:	e0fffd03 	ldbu	r3,-12(fp)
8113f99c:	00a045f4 	movhi	r2,33047
8113f9a0:	10b1de04 	addi	r2,r2,-14472
8113f9a4:	18c7883a 	add	r3,r3,r3
8113f9a8:	18c7883a 	add	r3,r3,r3
8113f9ac:	10c5883a 	add	r2,r2,r3
8113f9b0:	10800017 	ldw	r2,0(r2)
8113f9b4:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
8113f9b8:	e0bff817 	ldw	r2,-32(fp)
8113f9bc:	1000091e 	bne	r2,zero,8113f9e4 <OSTaskNameGet+0x128>
8113f9c0:	e0bff617 	ldw	r2,-40(fp)
8113f9c4:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f9c8:	e0bff717 	ldw	r2,-36(fp)
8113f9cc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* No                                         */
        *perr = OS_ERR_TASK_NOT_EXIST;
8113f9d0:	e0bfff17 	ldw	r2,-4(fp)
8113f9d4:	00c010c4 	movi	r3,67
8113f9d8:	10c00005 	stb	r3,0(r2)
        return (0);
8113f9dc:	0005883a 	mov	r2,zero
8113f9e0:	00001906 	br	8113fa48 <OSTaskNameGet+0x18c>
    }
    if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
8113f9e4:	e0bff817 	ldw	r2,-32(fp)
8113f9e8:	10800058 	cmpnei	r2,r2,1
8113f9ec:	1000091e 	bne	r2,zero,8113fa14 <OSTaskNameGet+0x158>
8113f9f0:	e0bff617 	ldw	r2,-40(fp)
8113f9f4:	e0bff915 	stw	r2,-28(fp)
8113f9f8:	e0bff917 	ldw	r2,-28(fp)
8113f9fc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* Yes                                        */
        *perr = OS_ERR_TASK_NOT_EXIST;
8113fa00:	e0bfff17 	ldw	r2,-4(fp)
8113fa04:	00c010c4 	movi	r3,67
8113fa08:	10c00005 	stb	r3,0(r2)
        return (0);
8113fa0c:	0005883a 	mov	r2,zero
8113fa10:	00000d06 	br	8113fa48 <OSTaskNameGet+0x18c>
    }
    len   = OS_StrCopy(pname, ptcb->OSTCBTaskName);      /* Yes, copy name from TCB                    */
8113fa14:	e0bff817 	ldw	r2,-32(fp)
8113fa18:	10801304 	addi	r2,r2,76
8113fa1c:	100b883a 	mov	r5,r2
8113fa20:	e13ffe17 	ldw	r4,-8(fp)
8113fa24:	11397640 	call	81139764 <OS_StrCopy>
8113fa28:	e0bffb05 	stb	r2,-20(fp)
8113fa2c:	e0bff617 	ldw	r2,-40(fp)
8113fa30:	e0bffa15 	stw	r2,-24(fp)
8113fa34:	e0bffa17 	ldw	r2,-24(fp)
8113fa38:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113fa3c:	e0bfff17 	ldw	r2,-4(fp)
8113fa40:	10000005 	stb	zero,0(r2)
    return (len);
8113fa44:	e0bffb03 	ldbu	r2,-20(fp)
}
8113fa48:	e037883a 	mov	sp,fp
8113fa4c:	dfc00117 	ldw	ra,4(sp)
8113fa50:	df000017 	ldw	fp,0(sp)
8113fa54:	dec00204 	addi	sp,sp,8
8113fa58:	f800283a 	ret

8113fa5c <OSTaskNameSet>:
* Returns    : None
*********************************************************************************************************
*/
#if OS_TASK_NAME_SIZE > 1
void  OSTaskNameSet (INT8U prio, INT8U *pname, INT8U *perr)
{
8113fa5c:	defff304 	addi	sp,sp,-52
8113fa60:	de00012e 	bgeu	sp,et,8113fa68 <OSTaskNameSet+0xc>
8113fa64:	003b68fa 	trap	3
8113fa68:	dfc00c15 	stw	ra,48(sp)
8113fa6c:	df000b15 	stw	fp,44(sp)
8113fa70:	df000b04 	addi	fp,sp,44
8113fa74:	2005883a 	mov	r2,r4
8113fa78:	e17ffe15 	stw	r5,-8(fp)
8113fa7c:	e1bfff15 	stw	r6,-4(fp)
8113fa80:	e0bffd05 	stb	r2,-12(fp)
    INT8U      len;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
8113fa84:	e03ff515 	stw	zero,-44(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
8113fa88:	e0bfff17 	ldw	r2,-4(fp)
8113fa8c:	10005c26 	beq	r2,zero,8113fc00 <OSTaskNameSet+0x1a4>
        return;
    }
    if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
8113fa90:	e0bffd03 	ldbu	r2,-12(fp)
8113fa94:	10800af0 	cmpltui	r2,r2,43
8113fa98:	1000071e 	bne	r2,zero,8113fab8 <OSTaskNameSet+0x5c>
        if (prio != OS_PRIO_SELF) {
8113fa9c:	e0bffd03 	ldbu	r2,-12(fp)
8113faa0:	10803fe0 	cmpeqi	r2,r2,255
8113faa4:	1000041e 	bne	r2,zero,8113fab8 <OSTaskNameSet+0x5c>
            *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
8113faa8:	e0bfff17 	ldw	r2,-4(fp)
8113faac:	00c00a84 	movi	r3,42
8113fab0:	10c00005 	stb	r3,0(r2)
            return;
8113fab4:	00005306 	br	8113fc04 <OSTaskNameSet+0x1a8>
        }
    }
    if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
8113fab8:	e0bffe17 	ldw	r2,-8(fp)
8113fabc:	1000041e 	bne	r2,zero,8113fad0 <OSTaskNameSet+0x74>
        *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
8113fac0:	e0bfff17 	ldw	r2,-4(fp)
8113fac4:	00c00304 	movi	r3,12
8113fac8:	10c00005 	stb	r3,0(r2)
        return;
8113facc:	00004d06 	br	8113fc04 <OSTaskNameSet+0x1a8>
    }
#endif
    if (OSIntNesting > 0) {                          /* See if trying to call from an ISR              */
8113fad0:	d0a0a103 	ldbu	r2,-32124(gp)
8113fad4:	10803fcc 	andi	r2,r2,255
8113fad8:	10000426 	beq	r2,zero,8113faec <OSTaskNameSet+0x90>
        *perr = OS_ERR_NAME_SET_ISR;
8113fadc:	e0bfff17 	ldw	r2,-4(fp)
8113fae0:	00c00484 	movi	r3,18
8113fae4:	10c00005 	stb	r3,0(r2)
        return;
8113fae8:	00004606 	br	8113fc04 <OSTaskNameSet+0x1a8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113faec:	0005303a 	rdctl	r2,status
8113faf0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113faf4:	e0fffc17 	ldw	r3,-16(fp)
8113faf8:	00bfff84 	movi	r2,-2
8113fafc:	1884703a 	and	r2,r3,r2
8113fb00:	1001703a 	wrctl	status,r2
  
  return context;
8113fb04:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113fb08:	e0bff515 	stw	r2,-44(fp)
    if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
8113fb0c:	e0bffd03 	ldbu	r2,-12(fp)
8113fb10:	10803fd8 	cmpnei	r2,r2,255
8113fb14:	1000031e 	bne	r2,zero,8113fb24 <OSTaskNameSet+0xc8>
        prio = OSTCBCur->OSTCBPrio;
8113fb18:	d0a0a217 	ldw	r2,-32120(gp)
8113fb1c:	10800c83 	ldbu	r2,50(r2)
8113fb20:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113fb24:	e0fffd03 	ldbu	r3,-12(fp)
8113fb28:	00a045f4 	movhi	r2,33047
8113fb2c:	10b1de04 	addi	r2,r2,-14472
8113fb30:	18c7883a 	add	r3,r3,r3
8113fb34:	18c7883a 	add	r3,r3,r3
8113fb38:	10c5883a 	add	r2,r2,r3
8113fb3c:	10800017 	ldw	r2,0(r2)
8113fb40:	e0bff715 	stw	r2,-36(fp)
    if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
8113fb44:	e0bff717 	ldw	r2,-36(fp)
8113fb48:	1000081e 	bne	r2,zero,8113fb6c <OSTaskNameSet+0x110>
8113fb4c:	e0bff517 	ldw	r2,-44(fp)
8113fb50:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113fb54:	e0bff617 	ldw	r2,-40(fp)
8113fb58:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* No                                             */
        *perr = OS_ERR_TASK_NOT_EXIST;
8113fb5c:	e0bfff17 	ldw	r2,-4(fp)
8113fb60:	00c010c4 	movi	r3,67
8113fb64:	10c00005 	stb	r3,0(r2)
        return;
8113fb68:	00002606 	br	8113fc04 <OSTaskNameSet+0x1a8>
    }
    if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
8113fb6c:	e0bff717 	ldw	r2,-36(fp)
8113fb70:	10800058 	cmpnei	r2,r2,1
8113fb74:	1000081e 	bne	r2,zero,8113fb98 <OSTaskNameSet+0x13c>
8113fb78:	e0bff517 	ldw	r2,-44(fp)
8113fb7c:	e0bff815 	stw	r2,-32(fp)
8113fb80:	e0bff817 	ldw	r2,-32(fp)
8113fb84:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* Yes                                            */
        *perr = OS_ERR_TASK_NOT_EXIST;
8113fb88:	e0bfff17 	ldw	r2,-4(fp)
8113fb8c:	00c010c4 	movi	r3,67
8113fb90:	10c00005 	stb	r3,0(r2)
        return;
8113fb94:	00001b06 	br	8113fc04 <OSTaskNameSet+0x1a8>
    }
    len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
8113fb98:	e13ffe17 	ldw	r4,-8(fp)
8113fb9c:	11397e00 	call	811397e0 <OS_StrLen>
8113fba0:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
8113fba4:	e0bffa03 	ldbu	r2,-24(fp)
8113fba8:	10800830 	cmpltui	r2,r2,32
8113fbac:	1000081e 	bne	r2,zero,8113fbd0 <OSTaskNameSet+0x174>
8113fbb0:	e0bff517 	ldw	r2,-44(fp)
8113fbb4:	e0bff915 	stw	r2,-28(fp)
8113fbb8:	e0bff917 	ldw	r2,-28(fp)
8113fbbc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_TASK_NAME_TOO_LONG;
8113fbc0:	e0bfff17 	ldw	r2,-4(fp)
8113fbc4:	00c01044 	movi	r3,65
8113fbc8:	10c00005 	stb	r3,0(r2)
        return;
8113fbcc:	00000d06 	br	8113fc04 <OSTaskNameSet+0x1a8>
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
8113fbd0:	e0bff717 	ldw	r2,-36(fp)
8113fbd4:	10801304 	addi	r2,r2,76
8113fbd8:	e17ffe17 	ldw	r5,-8(fp)
8113fbdc:	1009883a 	mov	r4,r2
8113fbe0:	11397640 	call	81139764 <OS_StrCopy>
8113fbe4:	e0bff517 	ldw	r2,-44(fp)
8113fbe8:	e0bffb15 	stw	r2,-20(fp)
8113fbec:	e0bffb17 	ldw	r2,-20(fp)
8113fbf0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113fbf4:	e0bfff17 	ldw	r2,-4(fp)
8113fbf8:	10000005 	stb	zero,0(r2)
8113fbfc:	00000106 	br	8113fc04 <OSTaskNameSet+0x1a8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
        return;
8113fc00:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
8113fc04:	e037883a 	mov	sp,fp
8113fc08:	dfc00117 	ldw	ra,4(sp)
8113fc0c:	df000017 	ldw	fp,0(sp)
8113fc10:	dec00204 	addi	sp,sp,8
8113fc14:	f800283a 	ret

8113fc18 <OSTaskResume>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskResume (INT8U prio)
{
8113fc18:	defff404 	addi	sp,sp,-48
8113fc1c:	de00012e 	bgeu	sp,et,8113fc24 <OSTaskResume+0xc>
8113fc20:	003b68fa 	trap	3
8113fc24:	dfc00b15 	stw	ra,44(sp)
8113fc28:	df000a15 	stw	fp,40(sp)
8113fc2c:	df000a04 	addi	fp,sp,40
8113fc30:	2005883a 	mov	r2,r4
8113fc34:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                   /* Storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
8113fc38:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
8113fc3c:	e0bfff03 	ldbu	r2,-4(fp)
8113fc40:	10800ab0 	cmpltui	r2,r2,42
8113fc44:	1000021e 	bne	r2,zero,8113fc50 <OSTaskResume+0x38>
        return (OS_ERR_PRIO_INVALID);
8113fc48:	00800a84 	movi	r2,42
8113fc4c:	00006406 	br	8113fde0 <OSTaskResume+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113fc50:	0005303a 	rdctl	r2,status
8113fc54:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113fc58:	e0fffe17 	ldw	r3,-8(fp)
8113fc5c:	00bfff84 	movi	r2,-2
8113fc60:	1884703a 	and	r2,r3,r2
8113fc64:	1001703a 	wrctl	status,r2
  
  return context;
8113fc68:	e0bffe17 	ldw	r2,-8(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113fc6c:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
8113fc70:	e0ffff03 	ldbu	r3,-4(fp)
8113fc74:	00a045f4 	movhi	r2,33047
8113fc78:	10b1de04 	addi	r2,r2,-14472
8113fc7c:	18c7883a 	add	r3,r3,r3
8113fc80:	18c7883a 	add	r3,r3,r3
8113fc84:	10c5883a 	add	r2,r2,r3
8113fc88:	10800017 	ldw	r2,0(r2)
8113fc8c:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
8113fc90:	e0bff817 	ldw	r2,-32(fp)
8113fc94:	1000061e 	bne	r2,zero,8113fcb0 <OSTaskResume+0x98>
8113fc98:	e0bff617 	ldw	r2,-40(fp)
8113fc9c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113fca0:	e0bff717 	ldw	r2,-36(fp)
8113fca4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_RESUME_PRIO);
8113fca8:	00801184 	movi	r2,70
8113fcac:	00004c06 	br	8113fde0 <OSTaskResume+0x1c8>
    }
    if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
8113fcb0:	e0bff817 	ldw	r2,-32(fp)
8113fcb4:	10800058 	cmpnei	r2,r2,1
8113fcb8:	1000061e 	bne	r2,zero,8113fcd4 <OSTaskResume+0xbc>
8113fcbc:	e0bff617 	ldw	r2,-40(fp)
8113fcc0:	e0bff915 	stw	r2,-28(fp)
8113fcc4:	e0bff917 	ldw	r2,-28(fp)
8113fcc8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113fccc:	008010c4 	movi	r2,67
8113fcd0:	00004306 	br	8113fde0 <OSTaskResume+0x1c8>
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
8113fcd4:	e0bff817 	ldw	r2,-32(fp)
8113fcd8:	10800c03 	ldbu	r2,48(r2)
8113fcdc:	10803fcc 	andi	r2,r2,255
8113fce0:	1080020c 	andi	r2,r2,8
8113fce4:	10003926 	beq	r2,zero,8113fdcc <OSTaskResume+0x1b4>
        ptcb->OSTCBStat &= ~(INT8U)OS_STAT_SUSPEND;           /* Remove suspension                     */
8113fce8:	e0bff817 	ldw	r2,-32(fp)
8113fcec:	10c00c03 	ldbu	r3,48(r2)
8113fcf0:	00bffdc4 	movi	r2,-9
8113fcf4:	1884703a 	and	r2,r3,r2
8113fcf8:	1007883a 	mov	r3,r2
8113fcfc:	e0bff817 	ldw	r2,-32(fp)
8113fd00:	10c00c05 	stb	r3,48(r2)
        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
8113fd04:	e0bff817 	ldw	r2,-32(fp)
8113fd08:	10800c03 	ldbu	r2,48(r2)
8113fd0c:	10803fcc 	andi	r2,r2,255
8113fd10:	1000281e 	bne	r2,zero,8113fdb4 <OSTaskResume+0x19c>
            if (ptcb->OSTCBDly == 0) {
8113fd14:	e0bff817 	ldw	r2,-32(fp)
8113fd18:	10800b8b 	ldhu	r2,46(r2)
8113fd1c:	10bfffcc 	andi	r2,r2,65535
8113fd20:	10001f1e 	bne	r2,zero,8113fda0 <OSTaskResume+0x188>
                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
8113fd24:	e0bff817 	ldw	r2,-32(fp)
8113fd28:	10c00d83 	ldbu	r3,54(r2)
8113fd2c:	d0a09e03 	ldbu	r2,-32136(gp)
8113fd30:	1884b03a 	or	r2,r3,r2
8113fd34:	d0a09e05 	stb	r2,-32136(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113fd38:	e0bff817 	ldw	r2,-32(fp)
8113fd3c:	10800d03 	ldbu	r2,52(r2)
8113fd40:	10c03fcc 	andi	r3,r2,255
8113fd44:	e0bff817 	ldw	r2,-32(fp)
8113fd48:	10800d03 	ldbu	r2,52(r2)
8113fd4c:	11003fcc 	andi	r4,r2,255
8113fd50:	d0a09e44 	addi	r2,gp,-32135
8113fd54:	2085883a 	add	r2,r4,r2
8113fd58:	11000003 	ldbu	r4,0(r2)
8113fd5c:	e0bff817 	ldw	r2,-32(fp)
8113fd60:	10800d43 	ldbu	r2,53(r2)
8113fd64:	2084b03a 	or	r2,r4,r2
8113fd68:	1009883a 	mov	r4,r2
8113fd6c:	d0a09e44 	addi	r2,gp,-32135
8113fd70:	1885883a 	add	r2,r3,r2
8113fd74:	11000005 	stb	r4,0(r2)
8113fd78:	e0bff617 	ldw	r2,-40(fp)
8113fd7c:	e0bffa15 	stw	r2,-24(fp)
8113fd80:	e0bffa17 	ldw	r2,-24(fp)
8113fd84:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
                if (OSRunning == OS_TRUE) {
8113fd88:	d0a09103 	ldbu	r2,-32188(gp)
8113fd8c:	10803fcc 	andi	r2,r2,255
8113fd90:	10800058 	cmpnei	r2,r2,1
8113fd94:	10000b1e 	bne	r2,zero,8113fdc4 <OSTaskResume+0x1ac>
                    OS_Sched();                               /* Find new highest priority task        */
8113fd98:	11396100 	call	81139610 <OS_Sched>
8113fd9c:	00000906 	br	8113fdc4 <OSTaskResume+0x1ac>
8113fda0:	e0bff617 	ldw	r2,-40(fp)
8113fda4:	e0bffb15 	stw	r2,-20(fp)
8113fda8:	e0bffb17 	ldw	r2,-20(fp)
8113fdac:	1001703a 	wrctl	status,r2
8113fdb0:	00000406 	br	8113fdc4 <OSTaskResume+0x1ac>
8113fdb4:	e0bff617 	ldw	r2,-40(fp)
8113fdb8:	e0bffc15 	stw	r2,-16(fp)
8113fdbc:	e0bffc17 	ldw	r2,-16(fp)
8113fdc0:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
            }
        } else {                                              /* Must be pending on event              */
            OS_EXIT_CRITICAL();
        }
        return (OS_ERR_NONE);
8113fdc4:	0005883a 	mov	r2,zero
8113fdc8:	00000506 	br	8113fde0 <OSTaskResume+0x1c8>
8113fdcc:	e0bff617 	ldw	r2,-40(fp)
8113fdd0:	e0bffd15 	stw	r2,-12(fp)
8113fdd4:	e0bffd17 	ldw	r2,-12(fp)
8113fdd8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NOT_SUSPENDED);
8113fddc:	00801104 	movi	r2,68
}
8113fde0:	e037883a 	mov	sp,fp
8113fde4:	dfc00117 	ldw	ra,4(sp)
8113fde8:	df000017 	ldw	fp,0(sp)
8113fdec:	dec00204 	addi	sp,sp,8
8113fdf0:	f800283a 	ret

8113fdf4 <OSTaskStkChk>:
*              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
8113fdf4:	defff304 	addi	sp,sp,-52
8113fdf8:	de00012e 	bgeu	sp,et,8113fe00 <OSTaskStkChk+0xc>
8113fdfc:	003b68fa 	trap	3
8113fe00:	df000c15 	stw	fp,48(sp)
8113fe04:	df000c04 	addi	fp,sp,48
8113fe08:	2005883a 	mov	r2,r4
8113fe0c:	e17fff15 	stw	r5,-4(fp)
8113fe10:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
    OS_STK    *pchk;
    INT32U     nfree;
    INT32U     size;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113fe14:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
8113fe18:	e0bffe03 	ldbu	r2,-8(fp)
8113fe1c:	10800af0 	cmpltui	r2,r2,43
8113fe20:	1000051e 	bne	r2,zero,8113fe38 <OSTaskStkChk+0x44>
        if (prio != OS_PRIO_SELF) {
8113fe24:	e0bffe03 	ldbu	r2,-8(fp)
8113fe28:	10803fe0 	cmpeqi	r2,r2,255
8113fe2c:	1000021e 	bne	r2,zero,8113fe38 <OSTaskStkChk+0x44>
            return (OS_ERR_PRIO_INVALID);
8113fe30:	00800a84 	movi	r2,42
8113fe34:	00005d06 	br	8113ffac <OSTaskStkChk+0x1b8>
        }
    }
    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
8113fe38:	e0bfff17 	ldw	r2,-4(fp)
8113fe3c:	1000021e 	bne	r2,zero,8113fe48 <OSTaskStkChk+0x54>
        return (OS_ERR_PDATA_NULL);
8113fe40:	00800244 	movi	r2,9
8113fe44:	00005906 	br	8113ffac <OSTaskStkChk+0x1b8>
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
8113fe48:	e0bfff17 	ldw	r2,-4(fp)
8113fe4c:	10000015 	stw	zero,0(r2)
    p_stk_data->OSUsed = 0;
8113fe50:	e0bfff17 	ldw	r2,-4(fp)
8113fe54:	10000115 	stw	zero,4(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113fe58:	0005303a 	rdctl	r2,status
8113fe5c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113fe60:	e0fffd17 	ldw	r3,-12(fp)
8113fe64:	00bfff84 	movi	r2,-2
8113fe68:	1884703a 	and	r2,r3,r2
8113fe6c:	1001703a 	wrctl	status,r2
  
  return context;
8113fe70:	e0bffd17 	ldw	r2,-12(fp)
    OS_ENTER_CRITICAL();
8113fe74:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
8113fe78:	e0bffe03 	ldbu	r2,-8(fp)
8113fe7c:	10803fd8 	cmpnei	r2,r2,255
8113fe80:	1000031e 	bne	r2,zero,8113fe90 <OSTaskStkChk+0x9c>
        prio = OSTCBCur->OSTCBPrio;
8113fe84:	d0a0a217 	ldw	r2,-32120(gp)
8113fe88:	10800c83 	ldbu	r2,50(r2)
8113fe8c:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113fe90:	e0fffe03 	ldbu	r3,-8(fp)
8113fe94:	00a045f4 	movhi	r2,33047
8113fe98:	10b1de04 	addi	r2,r2,-14472
8113fe9c:	18c7883a 	add	r3,r3,r3
8113fea0:	18c7883a 	add	r3,r3,r3
8113fea4:	10c5883a 	add	r2,r2,r3
8113fea8:	10800017 	ldw	r2,0(r2)
8113feac:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
8113feb0:	e0bff817 	ldw	r2,-32(fp)
8113feb4:	1000061e 	bne	r2,zero,8113fed0 <OSTaskStkChk+0xdc>
8113feb8:	e0bff617 	ldw	r2,-40(fp)
8113febc:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113fec0:	e0bff717 	ldw	r2,-36(fp)
8113fec4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113fec8:	008010c4 	movi	r2,67
8113fecc:	00003706 	br	8113ffac <OSTaskStkChk+0x1b8>
    }
    if (ptcb == OS_TCB_RESERVED) {
8113fed0:	e0bff817 	ldw	r2,-32(fp)
8113fed4:	10800058 	cmpnei	r2,r2,1
8113fed8:	1000061e 	bne	r2,zero,8113fef4 <OSTaskStkChk+0x100>
8113fedc:	e0bff617 	ldw	r2,-40(fp)
8113fee0:	e0bff915 	stw	r2,-28(fp)
8113fee4:	e0bff917 	ldw	r2,-28(fp)
8113fee8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113feec:	008010c4 	movi	r2,67
8113fef0:	00002e06 	br	8113ffac <OSTaskStkChk+0x1b8>
    }
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
8113fef4:	e0bff817 	ldw	r2,-32(fp)
8113fef8:	1080040b 	ldhu	r2,16(r2)
8113fefc:	10bfffcc 	andi	r2,r2,65535
8113ff00:	1080004c 	andi	r2,r2,1
8113ff04:	1000061e 	bne	r2,zero,8113ff20 <OSTaskStkChk+0x12c>
8113ff08:	e0bff617 	ldw	r2,-40(fp)
8113ff0c:	e0bffa15 	stw	r2,-24(fp)
8113ff10:	e0bffa17 	ldw	r2,-24(fp)
8113ff14:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_OPT);
8113ff18:	00801144 	movi	r2,69
8113ff1c:	00002306 	br	8113ffac <OSTaskStkChk+0x1b8>
    }
    nfree = 0;
8113ff20:	e03ff515 	stw	zero,-44(fp)
    size  = ptcb->OSTCBStkSize;
8113ff24:	e0bff817 	ldw	r2,-32(fp)
8113ff28:	10800317 	ldw	r2,12(r2)
8113ff2c:	e0bffc15 	stw	r2,-16(fp)
    pchk  = ptcb->OSTCBStkBottom;
8113ff30:	e0bff817 	ldw	r2,-32(fp)
8113ff34:	10800217 	ldw	r2,8(r2)
8113ff38:	e0bff415 	stw	r2,-48(fp)
8113ff3c:	e0bff617 	ldw	r2,-40(fp)
8113ff40:	e0bffb15 	stw	r2,-20(fp)
8113ff44:	e0bffb17 	ldw	r2,-20(fp)
8113ff48:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
8113ff4c:	00000306 	br	8113ff5c <OSTaskStkChk+0x168>
        nfree++;
8113ff50:	e0bff517 	ldw	r2,-44(fp)
8113ff54:	10800044 	addi	r2,r2,1
8113ff58:	e0bff515 	stw	r2,-44(fp)
    nfree = 0;
    size  = ptcb->OSTCBStkSize;
    pchk  = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
8113ff5c:	e0bff417 	ldw	r2,-48(fp)
8113ff60:	10c00104 	addi	r3,r2,4
8113ff64:	e0fff415 	stw	r3,-48(fp)
8113ff68:	10800017 	ldw	r2,0(r2)
8113ff6c:	103ff826 	beq	r2,zero,8113ff50 <__reset+0xfb11ff50>
#else
    while (*pchk-- == (OS_STK)0) {
        nfree++;
    }
#endif
    p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
8113ff70:	e0bff517 	ldw	r2,-44(fp)
8113ff74:	1085883a 	add	r2,r2,r2
8113ff78:	1085883a 	add	r2,r2,r2
8113ff7c:	1007883a 	mov	r3,r2
8113ff80:	e0bfff17 	ldw	r2,-4(fp)
8113ff84:	10c00015 	stw	r3,0(r2)
    p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
8113ff88:	e0fffc17 	ldw	r3,-16(fp)
8113ff8c:	e0bff517 	ldw	r2,-44(fp)
8113ff90:	1885c83a 	sub	r2,r3,r2
8113ff94:	1085883a 	add	r2,r2,r2
8113ff98:	1085883a 	add	r2,r2,r2
8113ff9c:	1007883a 	mov	r3,r2
8113ffa0:	e0bfff17 	ldw	r2,-4(fp)
8113ffa4:	10c00115 	stw	r3,4(r2)
    return (OS_ERR_NONE);
8113ffa8:	0005883a 	mov	r2,zero
}
8113ffac:	e037883a 	mov	sp,fp
8113ffb0:	df000017 	ldw	fp,0(sp)
8113ffb4:	dec00104 	addi	sp,sp,4
8113ffb8:	f800283a 	ret

8113ffbc <OSTaskSuspend>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskSuspend (INT8U prio)
{
8113ffbc:	defff504 	addi	sp,sp,-44
8113ffc0:	de00012e 	bgeu	sp,et,8113ffc8 <OSTaskSuspend+0xc>
8113ffc4:	003b68fa 	trap	3
8113ffc8:	dfc00a15 	stw	ra,40(sp)
8113ffcc:	df000915 	stw	fp,36(sp)
8113ffd0:	df000904 	addi	fp,sp,36
8113ffd4:	2005883a 	mov	r2,r4
8113ffd8:	e0bfff05 	stb	r2,-4(fp)
    BOOLEAN    self;
    OS_TCB    *ptcb;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113ffdc:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
8113ffe0:	e0bfff03 	ldbu	r2,-4(fp)
8113ffe4:	10800a98 	cmpnei	r2,r2,42
8113ffe8:	1000021e 	bne	r2,zero,8113fff4 <OSTaskSuspend+0x38>
        return (OS_ERR_TASK_SUSPEND_IDLE);
8113ffec:	008011c4 	movi	r2,71
8113fff0:	00006806 	br	81140194 <OSTaskSuspend+0x1d8>
    }
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
8113fff4:	e0bfff03 	ldbu	r2,-4(fp)
8113fff8:	10800ab0 	cmpltui	r2,r2,42
8113fffc:	1000051e 	bne	r2,zero,81140014 <OSTaskSuspend+0x58>
        if (prio != OS_PRIO_SELF) {
81140000:	e0bfff03 	ldbu	r2,-4(fp)
81140004:	10803fe0 	cmpeqi	r2,r2,255
81140008:	1000021e 	bne	r2,zero,81140014 <OSTaskSuspend+0x58>
            return (OS_ERR_PRIO_INVALID);
8114000c:	00800a84 	movi	r2,42
81140010:	00006006 	br	81140194 <OSTaskSuspend+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140014:	0005303a 	rdctl	r2,status
81140018:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114001c:	e0fffe17 	ldw	r3,-8(fp)
81140020:	00bfff84 	movi	r2,-2
81140024:	1884703a 	and	r2,r3,r2
81140028:	1001703a 	wrctl	status,r2
  
  return context;
8114002c:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif
    OS_ENTER_CRITICAL();
81140030:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
81140034:	e0bfff03 	ldbu	r2,-4(fp)
81140038:	10803fd8 	cmpnei	r2,r2,255
8114003c:	1000061e 	bne	r2,zero,81140058 <OSTaskSuspend+0x9c>
        prio = OSTCBCur->OSTCBPrio;
81140040:	d0a0a217 	ldw	r2,-32120(gp)
81140044:	10800c83 	ldbu	r2,50(r2)
81140048:	e0bfff05 	stb	r2,-4(fp)
        self = OS_TRUE;
8114004c:	00800044 	movi	r2,1
81140050:	e0bff705 	stb	r2,-36(fp)
81140054:	00000906 	br	8114007c <OSTaskSuspend+0xc0>
    } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
81140058:	d0a0a217 	ldw	r2,-32120(gp)
8114005c:	10800c83 	ldbu	r2,50(r2)
81140060:	10c03fcc 	andi	r3,r2,255
81140064:	e0bfff03 	ldbu	r2,-4(fp)
81140068:	1880031e 	bne	r3,r2,81140078 <OSTaskSuspend+0xbc>
        self = OS_TRUE;
8114006c:	00800044 	movi	r2,1
81140070:	e0bff705 	stb	r2,-36(fp)
81140074:	00000106 	br	8114007c <OSTaskSuspend+0xc0>
    } else {
        self = OS_FALSE;                                        /* No suspending another task          */
81140078:	e03ff705 	stb	zero,-36(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8114007c:	e0ffff03 	ldbu	r3,-4(fp)
81140080:	00a045f4 	movhi	r2,33047
81140084:	10b1de04 	addi	r2,r2,-14472
81140088:	18c7883a 	add	r3,r3,r3
8114008c:	18c7883a 	add	r3,r3,r3
81140090:	10c5883a 	add	r2,r2,r3
81140094:	10800017 	ldw	r2,0(r2)
81140098:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
8114009c:	e0bffa17 	ldw	r2,-24(fp)
811400a0:	1000061e 	bne	r2,zero,811400bc <OSTaskSuspend+0x100>
811400a4:	e0bff817 	ldw	r2,-32(fp)
811400a8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811400ac:	e0bff917 	ldw	r2,-28(fp)
811400b0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_SUSPEND_PRIO);
811400b4:	00801204 	movi	r2,72
811400b8:	00003606 	br	81140194 <OSTaskSuspend+0x1d8>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
811400bc:	e0bffa17 	ldw	r2,-24(fp)
811400c0:	10800058 	cmpnei	r2,r2,1
811400c4:	1000061e 	bne	r2,zero,811400e0 <OSTaskSuspend+0x124>
811400c8:	e0bff817 	ldw	r2,-32(fp)
811400cc:	e0bffb15 	stw	r2,-20(fp)
811400d0:	e0bffb17 	ldw	r2,-20(fp)
811400d4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
811400d8:	008010c4 	movi	r2,67
811400dc:	00002d06 	br	81140194 <OSTaskSuspend+0x1d8>
    }
    y            = ptcb->OSTCBY;
811400e0:	e0bffa17 	ldw	r2,-24(fp)
811400e4:	10800d03 	ldbu	r2,52(r2)
811400e8:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
811400ec:	e0fffd03 	ldbu	r3,-12(fp)
811400f0:	e13ffd03 	ldbu	r4,-12(fp)
811400f4:	d0a09e44 	addi	r2,gp,-32135
811400f8:	2085883a 	add	r2,r4,r2
811400fc:	10800003 	ldbu	r2,0(r2)
81140100:	1009883a 	mov	r4,r2
81140104:	e0bffa17 	ldw	r2,-24(fp)
81140108:	10800d43 	ldbu	r2,53(r2)
8114010c:	0084303a 	nor	r2,zero,r2
81140110:	2084703a 	and	r2,r4,r2
81140114:	1009883a 	mov	r4,r2
81140118:	d0a09e44 	addi	r2,gp,-32135
8114011c:	1885883a 	add	r2,r3,r2
81140120:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
81140124:	e0fffd03 	ldbu	r3,-12(fp)
81140128:	d0a09e44 	addi	r2,gp,-32135
8114012c:	1885883a 	add	r2,r3,r2
81140130:	10800003 	ldbu	r2,0(r2)
81140134:	10803fcc 	andi	r2,r2,255
81140138:	1000071e 	bne	r2,zero,81140158 <OSTaskSuspend+0x19c>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
8114013c:	e0bffa17 	ldw	r2,-24(fp)
81140140:	10800d83 	ldbu	r2,54(r2)
81140144:	0084303a 	nor	r2,zero,r2
81140148:	1007883a 	mov	r3,r2
8114014c:	d0a09e03 	ldbu	r2,-32136(gp)
81140150:	1884703a 	and	r2,r3,r2
81140154:	d0a09e05 	stb	r2,-32136(gp)
    }
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
81140158:	e0bffa17 	ldw	r2,-24(fp)
8114015c:	10800c03 	ldbu	r2,48(r2)
81140160:	10800214 	ori	r2,r2,8
81140164:	1007883a 	mov	r3,r2
81140168:	e0bffa17 	ldw	r2,-24(fp)
8114016c:	10c00c05 	stb	r3,48(r2)
81140170:	e0bff817 	ldw	r2,-32(fp)
81140174:	e0bffc15 	stw	r2,-16(fp)
81140178:	e0bffc17 	ldw	r2,-16(fp)
8114017c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
81140180:	e0bff703 	ldbu	r2,-36(fp)
81140184:	10800058 	cmpnei	r2,r2,1
81140188:	1000011e 	bne	r2,zero,81140190 <OSTaskSuspend+0x1d4>
        OS_Sched();                                             /* Find new highest priority task      */
8114018c:	11396100 	call	81139610 <OS_Sched>
    }
    return (OS_ERR_NONE);
81140190:	0005883a 	mov	r2,zero
}
81140194:	e037883a 	mov	sp,fp
81140198:	dfc00117 	ldw	ra,4(sp)
8114019c:	df000017 	ldw	fp,0(sp)
811401a0:	dec00204 	addi	sp,sp,8
811401a4:	f800283a 	ret

811401a8 <OSTaskQuery>:
*********************************************************************************************************
*/

#if OS_TASK_QUERY_EN > 0
INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
{
811401a8:	defff604 	addi	sp,sp,-40
811401ac:	de00012e 	bgeu	sp,et,811401b4 <OSTaskQuery+0xc>
811401b0:	003b68fa 	trap	3
811401b4:	dfc00915 	stw	ra,36(sp)
811401b8:	df000815 	stw	fp,32(sp)
811401bc:	df000804 	addi	fp,sp,32
811401c0:	2005883a 	mov	r2,r4
811401c4:	e17fff15 	stw	r5,-4(fp)
811401c8:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811401cc:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
811401d0:	e0bffe03 	ldbu	r2,-8(fp)
811401d4:	10800af0 	cmpltui	r2,r2,43
811401d8:	1000051e 	bne	r2,zero,811401f0 <OSTaskQuery+0x48>
        if (prio != OS_PRIO_SELF) {
811401dc:	e0bffe03 	ldbu	r2,-8(fp)
811401e0:	10803fe0 	cmpeqi	r2,r2,255
811401e4:	1000021e 	bne	r2,zero,811401f0 <OSTaskQuery+0x48>
            return (OS_ERR_PRIO_INVALID);
811401e8:	00800a84 	movi	r2,42
811401ec:	00003406 	br	811402c0 <OSTaskQuery+0x118>
        }
    }
    if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
811401f0:	e0bfff17 	ldw	r2,-4(fp)
811401f4:	1000021e 	bne	r2,zero,81140200 <OSTaskQuery+0x58>
        return (OS_ERR_PDATA_NULL);
811401f8:	00800244 	movi	r2,9
811401fc:	00003006 	br	811402c0 <OSTaskQuery+0x118>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140200:	0005303a 	rdctl	r2,status
81140204:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140208:	e0fffd17 	ldw	r3,-12(fp)
8114020c:	00bfff84 	movi	r2,-2
81140210:	1884703a 	and	r2,r3,r2
81140214:	1001703a 	wrctl	status,r2
  
  return context;
81140218:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8114021c:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
81140220:	e0bffe03 	ldbu	r2,-8(fp)
81140224:	10803fd8 	cmpnei	r2,r2,255
81140228:	1000031e 	bne	r2,zero,81140238 <OSTaskQuery+0x90>
        prio = OSTCBCur->OSTCBPrio;
8114022c:	d0a0a217 	ldw	r2,-32120(gp)
81140230:	10800c83 	ldbu	r2,50(r2)
81140234:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
81140238:	e0fffe03 	ldbu	r3,-8(fp)
8114023c:	00a045f4 	movhi	r2,33047
81140240:	10b1de04 	addi	r2,r2,-14472
81140244:	18c7883a 	add	r3,r3,r3
81140248:	18c7883a 	add	r3,r3,r3
8114024c:	10c5883a 	add	r2,r2,r3
81140250:	10800017 	ldw	r2,0(r2)
81140254:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
81140258:	e0bffa17 	ldw	r2,-24(fp)
8114025c:	1000061e 	bne	r2,zero,81140278 <OSTaskQuery+0xd0>
81140260:	e0bff817 	ldw	r2,-32(fp)
81140264:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140268:	e0bff917 	ldw	r2,-28(fp)
8114026c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO);
81140270:	00800a44 	movi	r2,41
81140274:	00001206 	br	811402c0 <OSTaskQuery+0x118>
    }
    if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
81140278:	e0bffa17 	ldw	r2,-24(fp)
8114027c:	10800058 	cmpnei	r2,r2,1
81140280:	1000061e 	bne	r2,zero,8114029c <OSTaskQuery+0xf4>
81140284:	e0bff817 	ldw	r2,-32(fp)
81140288:	e0bffb15 	stw	r2,-20(fp)
8114028c:	e0bffb17 	ldw	r2,-20(fp)
81140290:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81140294:	008010c4 	movi	r2,67
81140298:	00000906 	br	811402c0 <OSTaskQuery+0x118>
    }
                                                 /* Copy TCB into user storage area                    */
    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
8114029c:	01801b04 	movi	r6,108
811402a0:	e17ffa17 	ldw	r5,-24(fp)
811402a4:	e13fff17 	ldw	r4,-4(fp)
811402a8:	11395a00 	call	811395a0 <OS_MemCopy>
811402ac:	e0bff817 	ldw	r2,-32(fp)
811402b0:	e0bffc15 	stw	r2,-16(fp)
811402b4:	e0bffc17 	ldw	r2,-16(fp)
811402b8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
811402bc:	0005883a 	mov	r2,zero
}
811402c0:	e037883a 	mov	sp,fp
811402c4:	dfc00117 	ldw	ra,4(sp)
811402c8:	df000017 	ldw	fp,0(sp)
811402cc:	dec00204 	addi	sp,sp,8
811402d0:	f800283a 	ret

811402d4 <OS_TaskStkClr>:
* Returns    : none
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
811402d4:	defffc04 	addi	sp,sp,-16
811402d8:	de00012e 	bgeu	sp,et,811402e0 <OS_TaskStkClr+0xc>
811402dc:	003b68fa 	trap	3
811402e0:	df000315 	stw	fp,12(sp)
811402e4:	df000304 	addi	fp,sp,12
811402e8:	e13ffd15 	stw	r4,-12(fp)
811402ec:	e17ffe15 	stw	r5,-8(fp)
811402f0:	3005883a 	mov	r2,r6
811402f4:	e0bfff0d 	sth	r2,-4(fp)
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
811402f8:	e0bfff0b 	ldhu	r2,-4(fp)
811402fc:	1080004c 	andi	r2,r2,1
81140300:	10000d26 	beq	r2,zero,81140338 <OS_TaskStkClr+0x64>
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
81140304:	e0bfff0b 	ldhu	r2,-4(fp)
81140308:	1080008c 	andi	r2,r2,2
8114030c:	10000a26 	beq	r2,zero,81140338 <OS_TaskStkClr+0x64>
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
81140310:	00000706 	br	81140330 <OS_TaskStkClr+0x5c>
                size--;
81140314:	e0bffe17 	ldw	r2,-8(fp)
81140318:	10bfffc4 	addi	r2,r2,-1
8114031c:	e0bffe15 	stw	r2,-8(fp)
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
81140320:	e0bffd17 	ldw	r2,-12(fp)
81140324:	10c00104 	addi	r3,r2,4
81140328:	e0fffd15 	stw	r3,-12(fp)
8114032c:	10000015 	stw	zero,0(r2)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
81140330:	e0bffe17 	ldw	r2,-8(fp)
81140334:	103ff71e 	bne	r2,zero,81140314 <__reset+0xfb120314>
                *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
            }
#endif
        }
    }
}
81140338:	0001883a 	nop
8114033c:	e037883a 	mov	sp,fp
81140340:	df000017 	ldw	fp,0(sp)
81140344:	dec00104 	addi	sp,sp,4
81140348:	f800283a 	ret

8114034c <OSTimeDly>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT16U ticks)
{
8114034c:	defff904 	addi	sp,sp,-28
81140350:	de00012e 	bgeu	sp,et,81140358 <OSTimeDly+0xc>
81140354:	003b68fa 	trap	3
81140358:	dfc00615 	stw	ra,24(sp)
8114035c:	df000515 	stw	fp,20(sp)
81140360:	df000504 	addi	fp,sp,20
81140364:	2005883a 	mov	r2,r4
81140368:	e0bfff0d 	sth	r2,-4(fp)
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8114036c:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81140370:	d0a0a103 	ldbu	r2,-32124(gp)
81140374:	10803fcc 	andi	r2,r2,255
81140378:	1000311e 	bne	r2,zero,81140440 <OSTimeDly+0xf4>
        return;
    }
    if (ticks > 0) {                             /* 0 means no delay!                                  */
8114037c:	e0bfff0b 	ldhu	r2,-4(fp)
81140380:	10003026 	beq	r2,zero,81140444 <OSTimeDly+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140384:	0005303a 	rdctl	r2,status
81140388:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114038c:	e0fffe17 	ldw	r3,-8(fp)
81140390:	00bfff84 	movi	r2,-2
81140394:	1884703a 	and	r2,r3,r2
81140398:	1001703a 	wrctl	status,r2
  
  return context;
8114039c:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
811403a0:	e0bffb15 	stw	r2,-20(fp)
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
811403a4:	d0a0a217 	ldw	r2,-32120(gp)
811403a8:	10800d03 	ldbu	r2,52(r2)
811403ac:	e0bffd05 	stb	r2,-12(fp)
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
811403b0:	e0fffd03 	ldbu	r3,-12(fp)
811403b4:	e13ffd03 	ldbu	r4,-12(fp)
811403b8:	d0a09e44 	addi	r2,gp,-32135
811403bc:	2085883a 	add	r2,r4,r2
811403c0:	10800003 	ldbu	r2,0(r2)
811403c4:	1009883a 	mov	r4,r2
811403c8:	d0a0a217 	ldw	r2,-32120(gp)
811403cc:	10800d43 	ldbu	r2,53(r2)
811403d0:	0084303a 	nor	r2,zero,r2
811403d4:	2084703a 	and	r2,r4,r2
811403d8:	1009883a 	mov	r4,r2
811403dc:	d0a09e44 	addi	r2,gp,-32135
811403e0:	1885883a 	add	r2,r3,r2
811403e4:	11000005 	stb	r4,0(r2)
        if (OSRdyTbl[y] == 0) {
811403e8:	e0fffd03 	ldbu	r3,-12(fp)
811403ec:	d0a09e44 	addi	r2,gp,-32135
811403f0:	1885883a 	add	r2,r3,r2
811403f4:	10800003 	ldbu	r2,0(r2)
811403f8:	10803fcc 	andi	r2,r2,255
811403fc:	1000071e 	bne	r2,zero,8114041c <OSTimeDly+0xd0>
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
81140400:	d0a0a217 	ldw	r2,-32120(gp)
81140404:	10800d83 	ldbu	r2,54(r2)
81140408:	0084303a 	nor	r2,zero,r2
8114040c:	1007883a 	mov	r3,r2
81140410:	d0a09e03 	ldbu	r2,-32136(gp)
81140414:	1884703a 	and	r2,r3,r2
81140418:	d0a09e05 	stb	r2,-32136(gp)
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
8114041c:	d0a0a217 	ldw	r2,-32120(gp)
81140420:	e0ffff0b 	ldhu	r3,-4(fp)
81140424:	10c00b8d 	sth	r3,46(r2)
81140428:	e0bffb17 	ldw	r2,-20(fp)
8114042c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140430:	e0bffc17 	ldw	r2,-16(fp)
81140434:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
81140438:	11396100 	call	81139610 <OS_Sched>
8114043c:	00000106 	br	81140444 <OSTimeDly+0xf8>
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
        return;
81140440:	0001883a 	nop
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
    }
}
81140444:	e037883a 	mov	sp,fp
81140448:	dfc00117 	ldw	ra,4(sp)
8114044c:	df000017 	ldw	fp,0(sp)
81140450:	dec00204 	addi	sp,sp,8
81140454:	f800283a 	ret

81140458 <OSTimeDlyHMSM>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U ms)
{
81140458:	defff804 	addi	sp,sp,-32
8114045c:	de00012e 	bgeu	sp,et,81140464 <OSTimeDlyHMSM+0xc>
81140460:	003b68fa 	trap	3
81140464:	dfc00715 	stw	ra,28(sp)
81140468:	df000615 	stw	fp,24(sp)
8114046c:	df000604 	addi	fp,sp,24
81140470:	2015883a 	mov	r10,r4
81140474:	2809883a 	mov	r4,r5
81140478:	3007883a 	mov	r3,r6
8114047c:	3805883a 	mov	r2,r7
81140480:	e2bffc05 	stb	r10,-16(fp)
81140484:	e13ffd05 	stb	r4,-12(fp)
81140488:	e0fffe05 	stb	r3,-8(fp)
8114048c:	e0bfff0d 	sth	r2,-4(fp)
    INT32U ticks;
    INT16U loops;


    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81140490:	d0a0a103 	ldbu	r2,-32124(gp)
81140494:	10803fcc 	andi	r2,r2,255
81140498:	10000226 	beq	r2,zero,811404a4 <OSTimeDlyHMSM+0x4c>
        return (OS_ERR_TIME_DLY_ISR);
8114049c:	00801544 	movi	r2,85
811404a0:	00004106 	br	811405a8 <OSTimeDlyHMSM+0x150>
    }
#if OS_ARG_CHK_EN > 0
    if (hours == 0) {
811404a4:	e0bffc03 	ldbu	r2,-16(fp)
811404a8:	1000081e 	bne	r2,zero,811404cc <OSTimeDlyHMSM+0x74>
        if (minutes == 0) {
811404ac:	e0bffd03 	ldbu	r2,-12(fp)
811404b0:	1000061e 	bne	r2,zero,811404cc <OSTimeDlyHMSM+0x74>
            if (seconds == 0) {
811404b4:	e0bffe03 	ldbu	r2,-8(fp)
811404b8:	1000041e 	bne	r2,zero,811404cc <OSTimeDlyHMSM+0x74>
                if (ms == 0) {
811404bc:	e0bfff0b 	ldhu	r2,-4(fp)
811404c0:	1000021e 	bne	r2,zero,811404cc <OSTimeDlyHMSM+0x74>
                    return (OS_ERR_TIME_ZERO_DLY);
811404c4:	00801504 	movi	r2,84
811404c8:	00003706 	br	811405a8 <OSTimeDlyHMSM+0x150>
                }
            }
        }
    }
    if (minutes > 59) {
811404cc:	e0bffd03 	ldbu	r2,-12(fp)
811404d0:	10800f30 	cmpltui	r2,r2,60
811404d4:	1000021e 	bne	r2,zero,811404e0 <OSTimeDlyHMSM+0x88>
        return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
811404d8:	00801444 	movi	r2,81
811404dc:	00003206 	br	811405a8 <OSTimeDlyHMSM+0x150>
    }
    if (seconds > 59) {
811404e0:	e0bffe03 	ldbu	r2,-8(fp)
811404e4:	10800f30 	cmpltui	r2,r2,60
811404e8:	1000021e 	bne	r2,zero,811404f4 <OSTimeDlyHMSM+0x9c>
        return (OS_ERR_TIME_INVALID_SECONDS);
811404ec:	00801484 	movi	r2,82
811404f0:	00002d06 	br	811405a8 <OSTimeDlyHMSM+0x150>
    }
    if (ms > 999) {
811404f4:	e0bfff0b 	ldhu	r2,-4(fp)
811404f8:	1080fa30 	cmpltui	r2,r2,1000
811404fc:	1000021e 	bne	r2,zero,81140508 <OSTimeDlyHMSM+0xb0>
        return (OS_ERR_TIME_INVALID_MS);
81140500:	008014c4 	movi	r2,83
81140504:	00002806 	br	811405a8 <OSTimeDlyHMSM+0x150>
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
81140508:	e0bffc03 	ldbu	r2,-16(fp)
8114050c:	10c38424 	muli	r3,r2,3600
81140510:	e0bffd03 	ldbu	r2,-12(fp)
81140514:	10800f24 	muli	r2,r2,60
81140518:	1887883a 	add	r3,r3,r2
8114051c:	e0bffe03 	ldbu	r2,-8(fp)
81140520:	1885883a 	add	r2,r3,r2
81140524:	1100fa24 	muli	r4,r2,1000
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
81140528:	e0bfff0b 	ldhu	r2,-4(fp)
8114052c:	10c0fa24 	muli	r3,r2,1000
81140530:	008418b4 	movhi	r2,4194
81140534:	109374c4 	addi	r2,r2,19923
81140538:	188a383a 	mulxuu	r5,r3,r2
8114053c:	1885383a 	mul	r2,r3,r2
81140540:	1011883a 	mov	r8,r2
81140544:	2813883a 	mov	r9,r5
81140548:	4804d1ba 	srli	r2,r9,6
        return (OS_ERR_TIME_INVALID_MS);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
8114054c:	2085883a 	add	r2,r4,r2
81140550:	e0bffb15 	stw	r2,-20(fp)
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
81140554:	e0bffb17 	ldw	r2,-20(fp)
81140558:	1004d43a 	srli	r2,r2,16
8114055c:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
81140560:	e0bffb17 	ldw	r2,-20(fp)
81140564:	10bfffcc 	andi	r2,r2,65535
81140568:	e0bffb15 	stw	r2,-20(fp)
    OSTimeDly((INT16U)ticks);
8114056c:	e0bffb17 	ldw	r2,-20(fp)
81140570:	10bfffcc 	andi	r2,r2,65535
81140574:	1009883a 	mov	r4,r2
81140578:	114034c0 	call	8114034c <OSTimeDly>
    while (loops > 0) {
8114057c:	00000706 	br	8114059c <OSTimeDlyHMSM+0x144>
        OSTimeDly((INT16U)32768u);
81140580:	01200014 	movui	r4,32768
81140584:	114034c0 	call	8114034c <OSTimeDly>
        OSTimeDly((INT16U)32768u);
81140588:	01200014 	movui	r4,32768
8114058c:	114034c0 	call	8114034c <OSTimeDly>
        loops--;
81140590:	e0bffa0b 	ldhu	r2,-24(fp)
81140594:	10bfffc4 	addi	r2,r2,-1
81140598:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
8114059c:	e0bffa0b 	ldhu	r2,-24(fp)
811405a0:	103ff71e 	bne	r2,zero,81140580 <__reset+0xfb120580>
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_ERR_NONE);
811405a4:	0005883a 	mov	r2,zero
}
811405a8:	e037883a 	mov	sp,fp
811405ac:	dfc00117 	ldw	ra,4(sp)
811405b0:	df000017 	ldw	fp,0(sp)
811405b4:	dec00204 	addi	sp,sp,8
811405b8:	f800283a 	ret

811405bc <OSTimeDlyResume>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_RESUME_EN > 0
INT8U  OSTimeDlyResume (INT8U prio)
{
811405bc:	defff504 	addi	sp,sp,-44
811405c0:	de00012e 	bgeu	sp,et,811405c8 <OSTimeDlyResume+0xc>
811405c4:	003b68fa 	trap	3
811405c8:	dfc00a15 	stw	ra,40(sp)
811405cc:	df000915 	stw	fp,36(sp)
811405d0:	df000904 	addi	fp,sp,36
811405d4:	2005883a 	mov	r2,r4
811405d8:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                    /* Storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
811405dc:	e03ff715 	stw	zero,-36(fp)
#endif



    if (prio >= OS_LOWEST_PRIO) {
811405e0:	e0bfff03 	ldbu	r2,-4(fp)
811405e4:	10800ab0 	cmpltui	r2,r2,42
811405e8:	1000021e 	bne	r2,zero,811405f4 <OSTimeDlyResume+0x38>
        return (OS_ERR_PRIO_INVALID);
811405ec:	00800a84 	movi	r2,42
811405f0:	00006406 	br	81140784 <OSTimeDlyResume+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811405f4:	0005303a 	rdctl	r2,status
811405f8:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811405fc:	e0fffe17 	ldw	r3,-8(fp)
81140600:	00bfff84 	movi	r2,-2
81140604:	1884703a 	and	r2,r3,r2
81140608:	1001703a 	wrctl	status,r2
  
  return context;
8114060c:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
81140610:	e0bff715 	stw	r2,-36(fp)
    ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
81140614:	e0ffff03 	ldbu	r3,-4(fp)
81140618:	00a045f4 	movhi	r2,33047
8114061c:	10b1de04 	addi	r2,r2,-14472
81140620:	18c7883a 	add	r3,r3,r3
81140624:	18c7883a 	add	r3,r3,r3
81140628:	10c5883a 	add	r2,r2,r3
8114062c:	10800017 	ldw	r2,0(r2)
81140630:	e0bff915 	stw	r2,-28(fp)
    if (ptcb == (OS_TCB *)0) {
81140634:	e0bff917 	ldw	r2,-28(fp)
81140638:	1000061e 	bne	r2,zero,81140654 <OSTimeDlyResume+0x98>
8114063c:	e0bff717 	ldw	r2,-36(fp)
81140640:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140644:	e0bff817 	ldw	r2,-32(fp)
81140648:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
8114064c:	008010c4 	movi	r2,67
81140650:	00004c06 	br	81140784 <OSTimeDlyResume+0x1c8>
    }
    if (ptcb == OS_TCB_RESERVED) {
81140654:	e0bff917 	ldw	r2,-28(fp)
81140658:	10800058 	cmpnei	r2,r2,1
8114065c:	1000061e 	bne	r2,zero,81140678 <OSTimeDlyResume+0xbc>
81140660:	e0bff717 	ldw	r2,-36(fp)
81140664:	e0bffa15 	stw	r2,-24(fp)
81140668:	e0bffa17 	ldw	r2,-24(fp)
8114066c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
81140670:	008010c4 	movi	r2,67
81140674:	00004306 	br	81140784 <OSTimeDlyResume+0x1c8>
    }
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
81140678:	e0bff917 	ldw	r2,-28(fp)
8114067c:	10800b8b 	ldhu	r2,46(r2)
81140680:	10bfffcc 	andi	r2,r2,65535
81140684:	1000061e 	bne	r2,zero,811406a0 <OSTimeDlyResume+0xe4>
81140688:	e0bff717 	ldw	r2,-36(fp)
8114068c:	e0bffb15 	stw	r2,-20(fp)
81140690:	e0bffb17 	ldw	r2,-20(fp)
81140694:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
81140698:	00801404 	movi	r2,80
8114069c:	00003906 	br	81140784 <OSTimeDlyResume+0x1c8>
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
811406a0:	e0bff917 	ldw	r2,-28(fp)
811406a4:	10000b8d 	sth	zero,46(r2)
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
811406a8:	e0bff917 	ldw	r2,-28(fp)
811406ac:	10800c03 	ldbu	r2,48(r2)
811406b0:	10803fcc 	andi	r2,r2,255
811406b4:	10800dcc 	andi	r2,r2,55
811406b8:	10000b26 	beq	r2,zero,811406e8 <OSTimeDlyResume+0x12c>
        ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
811406bc:	e0bff917 	ldw	r2,-28(fp)
811406c0:	10c00c03 	ldbu	r3,48(r2)
811406c4:	00bff204 	movi	r2,-56
811406c8:	1884703a 	and	r2,r3,r2
811406cc:	1007883a 	mov	r3,r2
811406d0:	e0bff917 	ldw	r2,-28(fp)
811406d4:	10c00c05 	stb	r3,48(r2)
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
811406d8:	e0bff917 	ldw	r2,-28(fp)
811406dc:	00c00044 	movi	r3,1
811406e0:	10c00c45 	stb	r3,49(r2)
811406e4:	00000206 	br	811406f0 <OSTimeDlyResume+0x134>
    } else {
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
811406e8:	e0bff917 	ldw	r2,-28(fp)
811406ec:	10000c45 	stb	zero,49(r2)
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
811406f0:	e0bff917 	ldw	r2,-28(fp)
811406f4:	10800c03 	ldbu	r2,48(r2)
811406f8:	10803fcc 	andi	r2,r2,255
811406fc:	1080020c 	andi	r2,r2,8
81140700:	10001b1e 	bne	r2,zero,81140770 <OSTimeDlyResume+0x1b4>
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
81140704:	e0bff917 	ldw	r2,-28(fp)
81140708:	10c00d83 	ldbu	r3,54(r2)
8114070c:	d0a09e03 	ldbu	r2,-32136(gp)
81140710:	1884b03a 	or	r2,r3,r2
81140714:	d0a09e05 	stb	r2,-32136(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81140718:	e0bff917 	ldw	r2,-28(fp)
8114071c:	10800d03 	ldbu	r2,52(r2)
81140720:	10c03fcc 	andi	r3,r2,255
81140724:	e0bff917 	ldw	r2,-28(fp)
81140728:	10800d03 	ldbu	r2,52(r2)
8114072c:	11003fcc 	andi	r4,r2,255
81140730:	d0a09e44 	addi	r2,gp,-32135
81140734:	2085883a 	add	r2,r4,r2
81140738:	11000003 	ldbu	r4,0(r2)
8114073c:	e0bff917 	ldw	r2,-28(fp)
81140740:	10800d43 	ldbu	r2,53(r2)
81140744:	2084b03a 	or	r2,r4,r2
81140748:	1009883a 	mov	r4,r2
8114074c:	d0a09e44 	addi	r2,gp,-32135
81140750:	1885883a 	add	r2,r3,r2
81140754:	11000005 	stb	r4,0(r2)
81140758:	e0bff717 	ldw	r2,-36(fp)
8114075c:	e0bffc15 	stw	r2,-16(fp)
81140760:	e0bffc17 	ldw	r2,-16(fp)
81140764:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                            /* See if this is new highest priority  */
81140768:	11396100 	call	81139610 <OS_Sched>
8114076c:	00000406 	br	81140780 <OSTimeDlyResume+0x1c4>
81140770:	e0bff717 	ldw	r2,-36(fp)
81140774:	e0bffd15 	stw	r2,-12(fp)
81140778:	e0bffd17 	ldw	r2,-12(fp)
8114077c:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
    }
    return (OS_ERR_NONE);
81140780:	0005883a 	mov	r2,zero
}
81140784:	e037883a 	mov	sp,fp
81140788:	dfc00117 	ldw	ra,4(sp)
8114078c:	df000017 	ldw	fp,0(sp)
81140790:	dec00204 	addi	sp,sp,8
81140794:	f800283a 	ret

81140798 <OSTimeGet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
INT32U  OSTimeGet (void)
{
81140798:	defffb04 	addi	sp,sp,-20
8114079c:	de00012e 	bgeu	sp,et,811407a4 <OSTimeGet+0xc>
811407a0:	003b68fa 	trap	3
811407a4:	df000415 	stw	fp,16(sp)
811407a8:	df000404 	addi	fp,sp,16
    INT32U     ticks;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811407ac:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811407b0:	0005303a 	rdctl	r2,status
811407b4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811407b8:	e0fffe17 	ldw	r3,-8(fp)
811407bc:	00bfff84 	movi	r2,-2
811407c0:	1884703a 	and	r2,r3,r2
811407c4:	1001703a 	wrctl	status,r2
  
  return context;
811407c8:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
811407cc:	e0bffc15 	stw	r2,-16(fp)
    ticks = OSTime;
811407d0:	d0a0a417 	ldw	r2,-32112(gp)
811407d4:	e0bffd15 	stw	r2,-12(fp)
811407d8:	e0bffc17 	ldw	r2,-16(fp)
811407dc:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811407e0:	e0bfff17 	ldw	r2,-4(fp)
811407e4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (ticks);
811407e8:	e0bffd17 	ldw	r2,-12(fp)
}
811407ec:	e037883a 	mov	sp,fp
811407f0:	df000017 	ldw	fp,0(sp)
811407f4:	dec00104 	addi	sp,sp,4
811407f8:	f800283a 	ret

811407fc <OSTimeSet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
void  OSTimeSet (INT32U ticks)
{
811407fc:	defffb04 	addi	sp,sp,-20
81140800:	de00012e 	bgeu	sp,et,81140808 <OSTimeSet+0xc>
81140804:	003b68fa 	trap	3
81140808:	df000415 	stw	fp,16(sp)
8114080c:	df000404 	addi	fp,sp,16
81140810:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81140814:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140818:	0005303a 	rdctl	r2,status
8114081c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140820:	e0fffd17 	ldw	r3,-12(fp)
81140824:	00bfff84 	movi	r2,-2
81140828:	1884703a 	and	r2,r3,r2
8114082c:	1001703a 	wrctl	status,r2
  
  return context;
81140830:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
81140834:	e0bffc15 	stw	r2,-16(fp)
    OSTime = ticks;
81140838:	e0bfff17 	ldw	r2,-4(fp)
8114083c:	d0a0a415 	stw	r2,-32112(gp)
81140840:	e0bffc17 	ldw	r2,-16(fp)
81140844:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140848:	e0bffe17 	ldw	r2,-8(fp)
8114084c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
81140850:	0001883a 	nop
81140854:	e037883a 	mov	sp,fp
81140858:	df000017 	ldw	fp,0(sp)
8114085c:	dec00104 	addi	sp,sp,4
81140860:	f800283a 	ret

81140864 <OSTmrCreate>:
                      INT8U            opt,
                      OS_TMR_CALLBACK  callback,
                      void            *callback_arg,
                      INT8U           *pname,
                      INT8U           *perr)
{
81140864:	defff804 	addi	sp,sp,-32
81140868:	de00012e 	bgeu	sp,et,81140870 <OSTmrCreate+0xc>
8114086c:	003b68fa 	trap	3
81140870:	dfc00715 	stw	ra,28(sp)
81140874:	df000615 	stw	fp,24(sp)
81140878:	df000604 	addi	fp,sp,24
8114087c:	e13ffc15 	stw	r4,-16(fp)
81140880:	e17ffd15 	stw	r5,-12(fp)
81140884:	3005883a 	mov	r2,r6
81140888:	e1ffff15 	stw	r7,-4(fp)
8114088c:	e0bffe05 	stb	r2,-8(fp)
    INT8U     len;
#endif


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
81140890:	e0800417 	ldw	r2,16(fp)
81140894:	1000021e 	bne	r2,zero,811408a0 <OSTmrCreate+0x3c>
        return ((OS_TMR *)0);
81140898:	0005883a 	mov	r2,zero
8114089c:	00005d06 	br	81140a14 <OSTmrCreate+0x1b0>
    }
    switch (opt) {
811408a0:	e0bffe03 	ldbu	r2,-8(fp)
811408a4:	10c00060 	cmpeqi	r3,r2,1
811408a8:	1800091e 	bne	r3,zero,811408d0 <OSTmrCreate+0x6c>
811408ac:	108000a0 	cmpeqi	r2,r2,2
811408b0:	10000e26 	beq	r2,zero,811408ec <OSTmrCreate+0x88>
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
811408b4:	e0bffd17 	ldw	r2,-12(fp)
811408b8:	1000111e 	bne	r2,zero,81140900 <OSTmrCreate+0x9c>
                 *perr = OS_ERR_TMR_INVALID_PERIOD;
811408bc:	e0800417 	ldw	r2,16(fp)
811408c0:	00ffe0c4 	movi	r3,-125
811408c4:	10c00005 	stb	r3,0(r2)
                 return ((OS_TMR *)0);
811408c8:	0005883a 	mov	r2,zero
811408cc:	00005106 	br	81140a14 <OSTmrCreate+0x1b0>
             }
             break;

        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
811408d0:	e0bffc17 	ldw	r2,-16(fp)
811408d4:	10000c1e 	bne	r2,zero,81140908 <OSTmrCreate+0xa4>
                 *perr = OS_ERR_TMR_INVALID_DLY;
811408d8:	e0800417 	ldw	r2,16(fp)
811408dc:	00ffe084 	movi	r3,-126
811408e0:	10c00005 	stb	r3,0(r2)
                 return ((OS_TMR *)0);
811408e4:	0005883a 	mov	r2,zero
811408e8:	00004a06 	br	81140a14 <OSTmrCreate+0x1b0>
             }
             break;

        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
811408ec:	e0800417 	ldw	r2,16(fp)
811408f0:	00ffe104 	movi	r3,-124
811408f4:	10c00005 	stb	r3,0(r2)
             return ((OS_TMR *)0);
811408f8:	0005883a 	mov	r2,zero
811408fc:	00004506 	br	81140a14 <OSTmrCreate+0x1b0>
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
                 *perr = OS_ERR_TMR_INVALID_PERIOD;
                 return ((OS_TMR *)0);
             }
             break;
81140900:	0001883a 	nop
81140904:	00000106 	br	8114090c <OSTmrCreate+0xa8>
        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
                 *perr = OS_ERR_TMR_INVALID_DLY;
                 return ((OS_TMR *)0);
             }
             break;
81140908:	0001883a 	nop
        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
             return ((OS_TMR *)0);
    }
#endif
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
8114090c:	d0a0a103 	ldbu	r2,-32124(gp)
81140910:	10803fcc 	andi	r2,r2,255
81140914:	10000526 	beq	r2,zero,8114092c <OSTmrCreate+0xc8>
        *perr  = OS_ERR_TMR_ISR;
81140918:	e0800417 	ldw	r2,16(fp)
8114091c:	00ffe2c4 	movi	r3,-117
81140920:	10c00005 	stb	r3,0(r2)
        return ((OS_TMR *)0);
81140924:	0005883a 	mov	r2,zero
81140928:	00003a06 	br	81140a14 <OSTmrCreate+0x1b0>
    }
    OSTmr_Lock();
8114092c:	114181c0 	call	8114181c <OSTmr_Lock>
    ptmr = OSTmr_Alloc();                                   /* Obtain a timer from the free pool                      */
81140930:	11412bc0 	call	811412bc <OSTmr_Alloc>
81140934:	e0bffa15 	stw	r2,-24(fp)
    if (ptmr == (OS_TMR *)0) {
81140938:	e0bffa17 	ldw	r2,-24(fp)
8114093c:	1000061e 	bne	r2,zero,81140958 <OSTmrCreate+0xf4>
        OSTmr_Unlock();
81140940:	11418600 	call	81141860 <OSTmr_Unlock>
        *perr = OS_ERR_TMR_NON_AVAIL;
81140944:	e0800417 	ldw	r2,16(fp)
81140948:	00ffe184 	movi	r3,-122
8114094c:	10c00005 	stb	r3,0(r2)
        return ((OS_TMR *)0);
81140950:	0005883a 	mov	r2,zero
81140954:	00002f06 	br	81140a14 <OSTmrCreate+0x1b0>
    }
    ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet                 */
81140958:	e0bffa17 	ldw	r2,-24(fp)
8114095c:	00c00044 	movi	r3,1
81140960:	10c00c45 	stb	r3,49(r2)
    ptmr->OSTmrDly         = dly;
81140964:	e0bffa17 	ldw	r2,-24(fp)
81140968:	e0fffc17 	ldw	r3,-16(fp)
8114096c:	10c00615 	stw	r3,24(r2)
    ptmr->OSTmrPeriod      = period;
81140970:	e0bffa17 	ldw	r2,-24(fp)
81140974:	e0fffd17 	ldw	r3,-12(fp)
81140978:	10c00715 	stw	r3,28(r2)
    ptmr->OSTmrOpt         = opt;
8114097c:	e0bffa17 	ldw	r2,-24(fp)
81140980:	e0fffe03 	ldbu	r3,-8(fp)
81140984:	10c00c05 	stb	r3,48(r2)
    ptmr->OSTmrCallback    = callback;
81140988:	e0bffa17 	ldw	r2,-24(fp)
8114098c:	e0ffff17 	ldw	r3,-4(fp)
81140990:	10c00115 	stw	r3,4(r2)
    ptmr->OSTmrCallbackArg = callback_arg;
81140994:	e0bffa17 	ldw	r2,-24(fp)
81140998:	e0c00217 	ldw	r3,8(fp)
8114099c:	10c00215 	stw	r3,8(r2)
#if OS_TMR_CFG_NAME_SIZE > 0
    if (pname !=(INT8U *)0) {
811409a0:	e0800317 	ldw	r2,12(fp)
811409a4:	10001726 	beq	r2,zero,81140a04 <OSTmrCreate+0x1a0>
        len = OS_StrLen(pname);                             /* Copy timer name                                        */
811409a8:	e1000317 	ldw	r4,12(fp)
811409ac:	11397e00 	call	811397e0 <OS_StrLen>
811409b0:	e0bffb05 	stb	r2,-20(fp)
        if (len < OS_TMR_CFG_NAME_SIZE) {
811409b4:	e0bffb03 	ldbu	r2,-20(fp)
811409b8:	10800428 	cmpgeui	r2,r2,16
811409bc:	1000061e 	bne	r2,zero,811409d8 <OSTmrCreate+0x174>
            (void)OS_StrCopy(ptmr->OSTmrName, pname);
811409c0:	e0bffa17 	ldw	r2,-24(fp)
811409c4:	10800804 	addi	r2,r2,32
811409c8:	e1400317 	ldw	r5,12(fp)
811409cc:	1009883a 	mov	r4,r2
811409d0:	11397640 	call	81139764 <OS_StrCopy>
811409d4:	00000b06 	br	81140a04 <OSTmrCreate+0x1a0>
        } else {
#if OS_TMR_CFG_NAME_SIZE > 1
            ptmr->OSTmrName[0] = '#';                       /* Invalid size specified                                 */
811409d8:	e0bffa17 	ldw	r2,-24(fp)
811409dc:	00c008c4 	movi	r3,35
811409e0:	10c00805 	stb	r3,32(r2)
            ptmr->OSTmrName[1] = OS_ASCII_NUL;
811409e4:	e0bffa17 	ldw	r2,-24(fp)
811409e8:	10000845 	stb	zero,33(r2)
#endif
            *perr              = OS_ERR_TMR_NAME_TOO_LONG;
811409ec:	e0800417 	ldw	r2,16(fp)
811409f0:	00ffe304 	movi	r3,-116
811409f4:	10c00005 	stb	r3,0(r2)
            OSTmr_Unlock();
811409f8:	11418600 	call	81141860 <OSTmr_Unlock>
            return (ptmr);
811409fc:	e0bffa17 	ldw	r2,-24(fp)
81140a00:	00000406 	br	81140a14 <OSTmrCreate+0x1b0>
        }
    }
#endif
    OSTmr_Unlock();
81140a04:	11418600 	call	81141860 <OSTmr_Unlock>
    *perr = OS_ERR_NONE;
81140a08:	e0800417 	ldw	r2,16(fp)
81140a0c:	10000005 	stb	zero,0(r2)
    return (ptmr);
81140a10:	e0bffa17 	ldw	r2,-24(fp)
}
81140a14:	e037883a 	mov	sp,fp
81140a18:	dfc00117 	ldw	ra,4(sp)
81140a1c:	df000017 	ldw	fp,0(sp)
81140a20:	dec00204 	addi	sp,sp,8
81140a24:	f800283a 	ret

81140a28 <OSTmrDel>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrDel (OS_TMR  *ptmr,
                   INT8U   *perr)
{
81140a28:	defffc04 	addi	sp,sp,-16
81140a2c:	de00012e 	bgeu	sp,et,81140a34 <OSTmrDel+0xc>
81140a30:	003b68fa 	trap	3
81140a34:	dfc00315 	stw	ra,12(sp)
81140a38:	df000215 	stw	fp,8(sp)
81140a3c:	df000204 	addi	fp,sp,8
81140a40:	e13ffe15 	stw	r4,-8(fp)
81140a44:	e17fff15 	stw	r5,-4(fp)
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
81140a48:	e0bfff17 	ldw	r2,-4(fp)
81140a4c:	1000021e 	bne	r2,zero,81140a58 <OSTmrDel+0x30>
        return (OS_FALSE);
81140a50:	0005883a 	mov	r2,zero
81140a54:	00003f06 	br	81140b54 <OSTmrDel+0x12c>
    }
    if (ptmr == (OS_TMR *)0) {
81140a58:	e0bffe17 	ldw	r2,-8(fp)
81140a5c:	1000051e 	bne	r2,zero,81140a74 <OSTmrDel+0x4c>
        *perr = OS_ERR_TMR_INVALID;
81140a60:	e0bfff17 	ldw	r2,-4(fp)
81140a64:	00ffe284 	movi	r3,-118
81140a68:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81140a6c:	0005883a 	mov	r2,zero
81140a70:	00003806 	br	81140b54 <OSTmrDel+0x12c>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
81140a74:	e0bffe17 	ldw	r2,-8(fp)
81140a78:	10800003 	ldbu	r2,0(r2)
81140a7c:	10803fcc 	andi	r2,r2,255
81140a80:	10801920 	cmpeqi	r2,r2,100
81140a84:	1000051e 	bne	r2,zero,81140a9c <OSTmrDel+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81140a88:	e0bfff17 	ldw	r2,-4(fp)
81140a8c:	00ffe244 	movi	r3,-119
81140a90:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81140a94:	0005883a 	mov	r2,zero
81140a98:	00002e06 	br	81140b54 <OSTmrDel+0x12c>
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
81140a9c:	d0a0a103 	ldbu	r2,-32124(gp)
81140aa0:	10803fcc 	andi	r2,r2,255
81140aa4:	10000526 	beq	r2,zero,81140abc <OSTmrDel+0x94>
        *perr  = OS_ERR_TMR_ISR;
81140aa8:	e0bfff17 	ldw	r2,-4(fp)
81140aac:	00ffe2c4 	movi	r3,-117
81140ab0:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81140ab4:	0005883a 	mov	r2,zero
81140ab8:	00002606 	br	81140b54 <OSTmrDel+0x12c>
    }
    OSTmr_Lock();
81140abc:	114181c0 	call	8114181c <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
81140ac0:	e0bffe17 	ldw	r2,-8(fp)
81140ac4:	10800c43 	ldbu	r2,49(r2)
81140ac8:	10803fcc 	andi	r2,r2,255
81140acc:	10c000c8 	cmpgei	r3,r2,3
81140ad0:	1800031e 	bne	r3,zero,81140ae0 <OSTmrDel+0xb8>
81140ad4:	00800d16 	blt	zero,r2,81140b0c <OSTmrDel+0xe4>
81140ad8:	10001326 	beq	r2,zero,81140b28 <OSTmrDel+0x100>
81140adc:	00001806 	br	81140b40 <OSTmrDel+0x118>
81140ae0:	108000e0 	cmpeqi	r2,r2,3
81140ae4:	10001626 	beq	r2,zero,81140b40 <OSTmrDel+0x118>
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                            /* Remove from current wheel spoke                        */
81140ae8:	e13ffe17 	ldw	r4,-8(fp)
81140aec:	11417200 	call	81141720 <OSTmr_Unlink>
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
81140af0:	e13ffe17 	ldw	r4,-8(fp)
81140af4:	11413300 	call	81141330 <OSTmr_Free>
             OSTmr_Unlock();
81140af8:	11418600 	call	81141860 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81140afc:	e0bfff17 	ldw	r2,-4(fp)
81140b00:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
81140b04:	00800044 	movi	r2,1
81140b08:	00001206 	br	81140b54 <OSTmrDel+0x12c>

        case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...                           */
        case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time              */
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
81140b0c:	e13ffe17 	ldw	r4,-8(fp)
81140b10:	11413300 	call	81141330 <OSTmr_Free>
             OSTmr_Unlock();
81140b14:	11418600 	call	81141860 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81140b18:	e0bfff17 	ldw	r2,-4(fp)
81140b1c:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
81140b20:	00800044 	movi	r2,1
81140b24:	00000b06 	br	81140b54 <OSTmrDel+0x12c>

        case OS_TMR_STATE_UNUSED:                           /* Already deleted                                        */
             OSTmr_Unlock();
81140b28:	11418600 	call	81141860 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
81140b2c:	e0bfff17 	ldw	r2,-4(fp)
81140b30:	00ffe1c4 	movi	r3,-121
81140b34:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
81140b38:	0005883a 	mov	r2,zero
81140b3c:	00000506 	br	81140b54 <OSTmrDel+0x12c>

        default:
             OSTmr_Unlock();
81140b40:	11418600 	call	81141860 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
81140b44:	e0bfff17 	ldw	r2,-4(fp)
81140b48:	00ffe344 	movi	r3,-115
81140b4c:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
81140b50:	0005883a 	mov	r2,zero
    }
}
81140b54:	e037883a 	mov	sp,fp
81140b58:	dfc00117 	ldw	ra,4(sp)
81140b5c:	df000017 	ldw	fp,0(sp)
81140b60:	dec00204 	addi	sp,sp,8
81140b64:	f800283a 	ret

81140b68 <OSTmrNameGet>:

#if OS_TMR_EN > 0 && OS_TMR_CFG_NAME_SIZE > 0
INT8U  OSTmrNameGet (OS_TMR  *ptmr,
                     INT8U   *pdest,
                     INT8U   *perr)
{
81140b68:	defffa04 	addi	sp,sp,-24
81140b6c:	de00012e 	bgeu	sp,et,81140b74 <OSTmrNameGet+0xc>
81140b70:	003b68fa 	trap	3
81140b74:	dfc00515 	stw	ra,20(sp)
81140b78:	df000415 	stw	fp,16(sp)
81140b7c:	df000404 	addi	fp,sp,16
81140b80:	e13ffd15 	stw	r4,-12(fp)
81140b84:	e17ffe15 	stw	r5,-8(fp)
81140b88:	e1bfff15 	stw	r6,-4(fp)
    INT8U  len;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
81140b8c:	e0bfff17 	ldw	r2,-4(fp)
81140b90:	1000021e 	bne	r2,zero,81140b9c <OSTmrNameGet+0x34>
        return (0);
81140b94:	0005883a 	mov	r2,zero
81140b98:	00003e06 	br	81140c94 <OSTmrNameGet+0x12c>
    }
    if (pdest == (INT8U *)0) {
81140b9c:	e0bffe17 	ldw	r2,-8(fp)
81140ba0:	1000051e 	bne	r2,zero,81140bb8 <OSTmrNameGet+0x50>
        *perr = OS_ERR_TMR_INVALID_DEST;
81140ba4:	e0bfff17 	ldw	r2,-4(fp)
81140ba8:	00ffe204 	movi	r3,-120
81140bac:	10c00005 	stb	r3,0(r2)
        return (0);
81140bb0:	0005883a 	mov	r2,zero
81140bb4:	00003706 	br	81140c94 <OSTmrNameGet+0x12c>
    }
    if (ptmr == (OS_TMR *)0) {
81140bb8:	e0bffd17 	ldw	r2,-12(fp)
81140bbc:	1000051e 	bne	r2,zero,81140bd4 <OSTmrNameGet+0x6c>
        *perr = OS_ERR_TMR_INVALID;
81140bc0:	e0bfff17 	ldw	r2,-4(fp)
81140bc4:	00ffe284 	movi	r3,-118
81140bc8:	10c00005 	stb	r3,0(r2)
        return (0);
81140bcc:	0005883a 	mov	r2,zero
81140bd0:	00003006 	br	81140c94 <OSTmrNameGet+0x12c>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
81140bd4:	e0bffd17 	ldw	r2,-12(fp)
81140bd8:	10800003 	ldbu	r2,0(r2)
81140bdc:	10803fcc 	andi	r2,r2,255
81140be0:	10801920 	cmpeqi	r2,r2,100
81140be4:	1000051e 	bne	r2,zero,81140bfc <OSTmrNameGet+0x94>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81140be8:	e0bfff17 	ldw	r2,-4(fp)
81140bec:	00ffe244 	movi	r3,-119
81140bf0:	10c00005 	stb	r3,0(r2)
        return (0);
81140bf4:	0005883a 	mov	r2,zero
81140bf8:	00002606 	br	81140c94 <OSTmrNameGet+0x12c>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
81140bfc:	d0a0a103 	ldbu	r2,-32124(gp)
81140c00:	10803fcc 	andi	r2,r2,255
81140c04:	10000526 	beq	r2,zero,81140c1c <OSTmrNameGet+0xb4>
        *perr = OS_ERR_NAME_GET_ISR;
81140c08:	e0bfff17 	ldw	r2,-4(fp)
81140c0c:	00c00444 	movi	r3,17
81140c10:	10c00005 	stb	r3,0(r2)
        return (0);
81140c14:	0005883a 	mov	r2,zero
81140c18:	00001e06 	br	81140c94 <OSTmrNameGet+0x12c>
    }
    OSTmr_Lock();
81140c1c:	114181c0 	call	8114181c <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
81140c20:	e0bffd17 	ldw	r2,-12(fp)
81140c24:	10800c43 	ldbu	r2,49(r2)
81140c28:	10803fcc 	andi	r2,r2,255
81140c2c:	10000e26 	beq	r2,zero,81140c68 <OSTmrNameGet+0x100>
81140c30:	10001316 	blt	r2,zero,81140c80 <OSTmrNameGet+0x118>
81140c34:	10800108 	cmpgei	r2,r2,4
81140c38:	1000111e 	bne	r2,zero,81140c80 <OSTmrNameGet+0x118>
        case OS_TMR_STATE_RUNNING:
        case OS_TMR_STATE_STOPPED:
        case OS_TMR_STATE_COMPLETED:
             len   = OS_StrCopy(pdest, ptmr->OSTmrName);
81140c3c:	e0bffd17 	ldw	r2,-12(fp)
81140c40:	10800804 	addi	r2,r2,32
81140c44:	100b883a 	mov	r5,r2
81140c48:	e13ffe17 	ldw	r4,-8(fp)
81140c4c:	11397640 	call	81139764 <OS_StrCopy>
81140c50:	e0bffc05 	stb	r2,-16(fp)
             OSTmr_Unlock();
81140c54:	11418600 	call	81141860 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81140c58:	e0bfff17 	ldw	r2,-4(fp)
81140c5c:	10000005 	stb	zero,0(r2)
             return (len);
81140c60:	e0bffc03 	ldbu	r2,-16(fp)
81140c64:	00000b06 	br	81140c94 <OSTmrNameGet+0x12c>

        case OS_TMR_STATE_UNUSED:                      /* Timer is not allocated                                      */
             OSTmr_Unlock();
81140c68:	11418600 	call	81141860 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
81140c6c:	e0bfff17 	ldw	r2,-4(fp)
81140c70:	00ffe1c4 	movi	r3,-121
81140c74:	10c00005 	stb	r3,0(r2)
             return (0);
81140c78:	0005883a 	mov	r2,zero
81140c7c:	00000506 	br	81140c94 <OSTmrNameGet+0x12c>

        default:
             OSTmr_Unlock();
81140c80:	11418600 	call	81141860 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
81140c84:	e0bfff17 	ldw	r2,-4(fp)
81140c88:	00ffe344 	movi	r3,-115
81140c8c:	10c00005 	stb	r3,0(r2)
             return (0);
81140c90:	0005883a 	mov	r2,zero
    }
}
81140c94:	e037883a 	mov	sp,fp
81140c98:	dfc00117 	ldw	ra,4(sp)
81140c9c:	df000017 	ldw	fp,0(sp)
81140ca0:	dec00204 	addi	sp,sp,8
81140ca4:	f800283a 	ret

81140ca8 <OSTmrRemainGet>:
*/

#if OS_TMR_EN > 0
INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
                        INT8U   *perr)
{
81140ca8:	defffb04 	addi	sp,sp,-20
81140cac:	de00012e 	bgeu	sp,et,81140cb4 <OSTmrRemainGet+0xc>
81140cb0:	003b68fa 	trap	3
81140cb4:	dfc00415 	stw	ra,16(sp)
81140cb8:	df000315 	stw	fp,12(sp)
81140cbc:	df000304 	addi	fp,sp,12
81140cc0:	e13ffe15 	stw	r4,-8(fp)
81140cc4:	e17fff15 	stw	r5,-4(fp)
    INT32U  remain;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
81140cc8:	e0bfff17 	ldw	r2,-4(fp)
81140ccc:	1000021e 	bne	r2,zero,81140cd8 <OSTmrRemainGet+0x30>
        return (0);
81140cd0:	0005883a 	mov	r2,zero
81140cd4:	00005d06 	br	81140e4c <OSTmrRemainGet+0x1a4>
    }
    if (ptmr == (OS_TMR *)0) {
81140cd8:	e0bffe17 	ldw	r2,-8(fp)
81140cdc:	1000051e 	bne	r2,zero,81140cf4 <OSTmrRemainGet+0x4c>
        *perr = OS_ERR_TMR_INVALID;
81140ce0:	e0bfff17 	ldw	r2,-4(fp)
81140ce4:	00ffe284 	movi	r3,-118
81140ce8:	10c00005 	stb	r3,0(r2)
        return (0);
81140cec:	0005883a 	mov	r2,zero
81140cf0:	00005606 	br	81140e4c <OSTmrRemainGet+0x1a4>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
81140cf4:	e0bffe17 	ldw	r2,-8(fp)
81140cf8:	10800003 	ldbu	r2,0(r2)
81140cfc:	10803fcc 	andi	r2,r2,255
81140d00:	10801920 	cmpeqi	r2,r2,100
81140d04:	1000051e 	bne	r2,zero,81140d1c <OSTmrRemainGet+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81140d08:	e0bfff17 	ldw	r2,-4(fp)
81140d0c:	00ffe244 	movi	r3,-119
81140d10:	10c00005 	stb	r3,0(r2)
        return (0);
81140d14:	0005883a 	mov	r2,zero
81140d18:	00004c06 	br	81140e4c <OSTmrRemainGet+0x1a4>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
81140d1c:	d0a0a103 	ldbu	r2,-32124(gp)
81140d20:	10803fcc 	andi	r2,r2,255
81140d24:	10000526 	beq	r2,zero,81140d3c <OSTmrRemainGet+0x94>
        *perr = OS_ERR_TMR_ISR;
81140d28:	e0bfff17 	ldw	r2,-4(fp)
81140d2c:	00ffe2c4 	movi	r3,-117
81140d30:	10c00005 	stb	r3,0(r2)
        return (0);
81140d34:	0005883a 	mov	r2,zero
81140d38:	00004406 	br	81140e4c <OSTmrRemainGet+0x1a4>
    }
    OSTmr_Lock();
81140d3c:	114181c0 	call	8114181c <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
81140d40:	e0bffe17 	ldw	r2,-8(fp)
81140d44:	10800c43 	ldbu	r2,49(r2)
81140d48:	10803fcc 	andi	r2,r2,255
81140d4c:	10c00060 	cmpeqi	r3,r2,1
81140d50:	1800121e 	bne	r3,zero,81140d9c <OSTmrRemainGet+0xf4>
81140d54:	10c00088 	cmpgei	r3,r2,2
81140d58:	1800021e 	bne	r3,zero,81140d64 <OSTmrRemainGet+0xbc>
81140d5c:	10003026 	beq	r2,zero,81140e20 <OSTmrRemainGet+0x178>
81140d60:	00003506 	br	81140e38 <OSTmrRemainGet+0x190>
81140d64:	10c000a0 	cmpeqi	r3,r2,2
81140d68:	1800281e 	bne	r3,zero,81140e0c <OSTmrRemainGet+0x164>
81140d6c:	108000e0 	cmpeqi	r2,r2,3
81140d70:	10003126 	beq	r2,zero,81140e38 <OSTmrRemainGet+0x190>
        case OS_TMR_STATE_RUNNING:
             remain = ptmr->OSTmrMatch - OSTmrTime;    /* Determine how much time is left to timeout                  */
81140d74:	e0bffe17 	ldw	r2,-8(fp)
81140d78:	10c00517 	ldw	r3,20(r2)
81140d7c:	d0a0a317 	ldw	r2,-32116(gp)
81140d80:	1885c83a 	sub	r2,r3,r2
81140d84:	e0bffd15 	stw	r2,-12(fp)
             OSTmr_Unlock();
81140d88:	11418600 	call	81141860 <OSTmr_Unlock>
             *perr  = OS_ERR_NONE;
81140d8c:	e0bfff17 	ldw	r2,-4(fp)
81140d90:	10000005 	stb	zero,0(r2)
             return (remain);
81140d94:	e0bffd17 	ldw	r2,-12(fp)
81140d98:	00002c06 	br	81140e4c <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_STOPPED:                     /* It's assumed that the timer has not started yet             */
             switch (ptmr->OSTmrOpt) {
81140d9c:	e0bffe17 	ldw	r2,-8(fp)
81140da0:	10800c03 	ldbu	r2,48(r2)
81140da4:	10803fcc 	andi	r2,r2,255
81140da8:	108000a0 	cmpeqi	r2,r2,2
81140dac:	10000e26 	beq	r2,zero,81140de8 <OSTmrRemainGet+0x140>
                 case OS_TMR_OPT_PERIODIC:
                      if (ptmr->OSTmrDly == 0) {
81140db0:	e0bffe17 	ldw	r2,-8(fp)
81140db4:	10800617 	ldw	r2,24(r2)
81140db8:	1000041e 	bne	r2,zero,81140dcc <OSTmrRemainGet+0x124>
                          remain = ptmr->OSTmrPeriod;
81140dbc:	e0bffe17 	ldw	r2,-8(fp)
81140dc0:	10800717 	ldw	r2,28(r2)
81140dc4:	e0bffd15 	stw	r2,-12(fp)
81140dc8:	00000306 	br	81140dd8 <OSTmrRemainGet+0x130>
                      } else {
                          remain = ptmr->OSTmrDly;
81140dcc:	e0bffe17 	ldw	r2,-8(fp)
81140dd0:	10800617 	ldw	r2,24(r2)
81140dd4:	e0bffd15 	stw	r2,-12(fp)
                      }
                      OSTmr_Unlock();
81140dd8:	11418600 	call	81141860 <OSTmr_Unlock>
                      *perr  = OS_ERR_NONE;
81140ddc:	e0bfff17 	ldw	r2,-4(fp)
81140de0:	10000005 	stb	zero,0(r2)
                      break;
81140de4:	00000706 	br	81140e04 <OSTmrRemainGet+0x15c>

                 case OS_TMR_OPT_ONE_SHOT:
                 default:
                      remain = ptmr->OSTmrDly;
81140de8:	e0bffe17 	ldw	r2,-8(fp)
81140dec:	10800617 	ldw	r2,24(r2)
81140df0:	e0bffd15 	stw	r2,-12(fp)
                      OSTmr_Unlock();
81140df4:	11418600 	call	81141860 <OSTmr_Unlock>
                      *perr  = OS_ERR_NONE;
81140df8:	e0bfff17 	ldw	r2,-4(fp)
81140dfc:	10000005 	stb	zero,0(r2)
                      break;
81140e00:	0001883a 	nop
             }
             return (remain);
81140e04:	e0bffd17 	ldw	r2,-12(fp)
81140e08:	00001006 	br	81140e4c <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_COMPLETED:                   /* Only ONE-SHOT that timed out can be in this state           */
             OSTmr_Unlock();
81140e0c:	11418600 	call	81141860 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81140e10:	e0bfff17 	ldw	r2,-4(fp)
81140e14:	10000005 	stb	zero,0(r2)
             return (0);
81140e18:	0005883a 	mov	r2,zero
81140e1c:	00000b06 	br	81140e4c <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_UNUSED:
             OSTmr_Unlock();
81140e20:	11418600 	call	81141860 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
81140e24:	e0bfff17 	ldw	r2,-4(fp)
81140e28:	00ffe1c4 	movi	r3,-121
81140e2c:	10c00005 	stb	r3,0(r2)
             return (0);
81140e30:	0005883a 	mov	r2,zero
81140e34:	00000506 	br	81140e4c <OSTmrRemainGet+0x1a4>

        default:
             OSTmr_Unlock();
81140e38:	11418600 	call	81141860 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
81140e3c:	e0bfff17 	ldw	r2,-4(fp)
81140e40:	00ffe344 	movi	r3,-115
81140e44:	10c00005 	stb	r3,0(r2)
             return (0);
81140e48:	0005883a 	mov	r2,zero
    }
}
81140e4c:	e037883a 	mov	sp,fp
81140e50:	dfc00117 	ldw	ra,4(sp)
81140e54:	df000017 	ldw	fp,0(sp)
81140e58:	dec00204 	addi	sp,sp,8
81140e5c:	f800283a 	ret

81140e60 <OSTmrStateGet>:
*/

#if OS_TMR_EN > 0
INT8U  OSTmrStateGet (OS_TMR  *ptmr,
                      INT8U   *perr)
{
81140e60:	defffb04 	addi	sp,sp,-20
81140e64:	de00012e 	bgeu	sp,et,81140e6c <OSTmrStateGet+0xc>
81140e68:	003b68fa 	trap	3
81140e6c:	dfc00415 	stw	ra,16(sp)
81140e70:	df000315 	stw	fp,12(sp)
81140e74:	df000304 	addi	fp,sp,12
81140e78:	e13ffe15 	stw	r4,-8(fp)
81140e7c:	e17fff15 	stw	r5,-4(fp)
    INT8U  state;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
81140e80:	e0bfff17 	ldw	r2,-4(fp)
81140e84:	1000021e 	bne	r2,zero,81140e90 <OSTmrStateGet+0x30>
        return (0);
81140e88:	0005883a 	mov	r2,zero
81140e8c:	00002a06 	br	81140f38 <OSTmrStateGet+0xd8>
    }
    if (ptmr == (OS_TMR *)0) {
81140e90:	e0bffe17 	ldw	r2,-8(fp)
81140e94:	1000051e 	bne	r2,zero,81140eac <OSTmrStateGet+0x4c>
        *perr = OS_ERR_TMR_INVALID;
81140e98:	e0bfff17 	ldw	r2,-4(fp)
81140e9c:	00ffe284 	movi	r3,-118
81140ea0:	10c00005 	stb	r3,0(r2)
        return (0);
81140ea4:	0005883a 	mov	r2,zero
81140ea8:	00002306 	br	81140f38 <OSTmrStateGet+0xd8>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
81140eac:	e0bffe17 	ldw	r2,-8(fp)
81140eb0:	10800003 	ldbu	r2,0(r2)
81140eb4:	10803fcc 	andi	r2,r2,255
81140eb8:	10801920 	cmpeqi	r2,r2,100
81140ebc:	1000051e 	bne	r2,zero,81140ed4 <OSTmrStateGet+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81140ec0:	e0bfff17 	ldw	r2,-4(fp)
81140ec4:	00ffe244 	movi	r3,-119
81140ec8:	10c00005 	stb	r3,0(r2)
        return (0);
81140ecc:	0005883a 	mov	r2,zero
81140ed0:	00001906 	br	81140f38 <OSTmrStateGet+0xd8>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
81140ed4:	d0a0a103 	ldbu	r2,-32124(gp)
81140ed8:	10803fcc 	andi	r2,r2,255
81140edc:	10000526 	beq	r2,zero,81140ef4 <OSTmrStateGet+0x94>
        *perr = OS_ERR_TMR_ISR;
81140ee0:	e0bfff17 	ldw	r2,-4(fp)
81140ee4:	00ffe2c4 	movi	r3,-117
81140ee8:	10c00005 	stb	r3,0(r2)
        return (0);
81140eec:	0005883a 	mov	r2,zero
81140ef0:	00001106 	br	81140f38 <OSTmrStateGet+0xd8>
    }
    OSTmr_Lock();
81140ef4:	114181c0 	call	8114181c <OSTmr_Lock>
    state = ptmr->OSTmrState;
81140ef8:	e0bffe17 	ldw	r2,-8(fp)
81140efc:	10800c43 	ldbu	r2,49(r2)
81140f00:	e0bffd05 	stb	r2,-12(fp)
    switch (state) {
81140f04:	e0bffd03 	ldbu	r2,-12(fp)
81140f08:	1005883a 	mov	r2,r2
81140f0c:	10800128 	cmpgeui	r2,r2,4
81140f10:	1000031e 	bne	r2,zero,81140f20 <OSTmrStateGet+0xc0>
        case OS_TMR_STATE_UNUSED:   
        case OS_TMR_STATE_STOPPED:  
        case OS_TMR_STATE_COMPLETED:
        case OS_TMR_STATE_RUNNING:  
             *perr = OS_ERR_NONE;
81140f14:	e0bfff17 	ldw	r2,-4(fp)
81140f18:	10000005 	stb	zero,0(r2)
             break;
81140f1c:	00000406 	br	81140f30 <OSTmrStateGet+0xd0>
             
        default:
             *perr = OS_ERR_TMR_INVALID_STATE;
81140f20:	e0bfff17 	ldw	r2,-4(fp)
81140f24:	00ffe344 	movi	r3,-115
81140f28:	10c00005 	stb	r3,0(r2)
             break;
81140f2c:	0001883a 	nop
    }
    OSTmr_Unlock();
81140f30:	11418600 	call	81141860 <OSTmr_Unlock>
    return (state);
81140f34:	e0bffd03 	ldbu	r2,-12(fp)
}
81140f38:	e037883a 	mov	sp,fp
81140f3c:	dfc00117 	ldw	ra,4(sp)
81140f40:	df000017 	ldw	fp,0(sp)
81140f44:	dec00204 	addi	sp,sp,8
81140f48:	f800283a 	ret

81140f4c <OSTmrStart>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrStart (OS_TMR   *ptmr,
                     INT8U    *perr)
{
81140f4c:	defffc04 	addi	sp,sp,-16
81140f50:	de00012e 	bgeu	sp,et,81140f58 <OSTmrStart+0xc>
81140f54:	003b68fa 	trap	3
81140f58:	dfc00315 	stw	ra,12(sp)
81140f5c:	df000215 	stw	fp,8(sp)
81140f60:	df000204 	addi	fp,sp,8
81140f64:	e13ffe15 	stw	r4,-8(fp)
81140f68:	e17fff15 	stw	r5,-4(fp)
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
81140f6c:	e0bfff17 	ldw	r2,-4(fp)
81140f70:	1000021e 	bne	r2,zero,81140f7c <OSTmrStart+0x30>
        return (OS_FALSE);
81140f74:	0005883a 	mov	r2,zero
81140f78:	00004106 	br	81141080 <OSTmrStart+0x134>
    }
    if (ptmr == (OS_TMR *)0) {
81140f7c:	e0bffe17 	ldw	r2,-8(fp)
81140f80:	1000051e 	bne	r2,zero,81140f98 <OSTmrStart+0x4c>
        *perr = OS_ERR_TMR_INVALID;
81140f84:	e0bfff17 	ldw	r2,-4(fp)
81140f88:	00ffe284 	movi	r3,-118
81140f8c:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81140f90:	0005883a 	mov	r2,zero
81140f94:	00003a06 	br	81141080 <OSTmrStart+0x134>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
81140f98:	e0bffe17 	ldw	r2,-8(fp)
81140f9c:	10800003 	ldbu	r2,0(r2)
81140fa0:	10803fcc 	andi	r2,r2,255
81140fa4:	10801920 	cmpeqi	r2,r2,100
81140fa8:	1000051e 	bne	r2,zero,81140fc0 <OSTmrStart+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81140fac:	e0bfff17 	ldw	r2,-4(fp)
81140fb0:	00ffe244 	movi	r3,-119
81140fb4:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81140fb8:	0005883a 	mov	r2,zero
81140fbc:	00003006 	br	81141080 <OSTmrStart+0x134>
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
81140fc0:	d0a0a103 	ldbu	r2,-32124(gp)
81140fc4:	10803fcc 	andi	r2,r2,255
81140fc8:	10000526 	beq	r2,zero,81140fe0 <OSTmrStart+0x94>
        *perr  = OS_ERR_TMR_ISR;
81140fcc:	e0bfff17 	ldw	r2,-4(fp)
81140fd0:	00ffe2c4 	movi	r3,-117
81140fd4:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81140fd8:	0005883a 	mov	r2,zero
81140fdc:	00002806 	br	81141080 <OSTmrStart+0x134>
    }
    OSTmr_Lock();
81140fe0:	114181c0 	call	8114181c <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
81140fe4:	e0bffe17 	ldw	r2,-8(fp)
81140fe8:	10800c43 	ldbu	r2,49(r2)
81140fec:	10803fcc 	andi	r2,r2,255
81140ff0:	10c000c8 	cmpgei	r3,r2,3
81140ff4:	1800031e 	bne	r3,zero,81141004 <OSTmrStart+0xb8>
81140ff8:	00800e16 	blt	zero,r2,81141034 <OSTmrStart+0xe8>
81140ffc:	10001526 	beq	r2,zero,81141054 <OSTmrStart+0x108>
81141000:	00001a06 	br	8114106c <OSTmrStart+0x120>
81141004:	108000e0 	cmpeqi	r2,r2,3
81141008:	10001826 	beq	r2,zero,8114106c <OSTmrStart+0x120>
        case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
             OSTmr_Unlink(ptmr);                            /* ... Stop the timer                                     */
8114100c:	e13ffe17 	ldw	r4,-8(fp)
81141010:	11417200 	call	81141720 <OSTmr_Unlink>
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
81141014:	000b883a 	mov	r5,zero
81141018:	e13ffe17 	ldw	r4,-8(fp)
8114101c:	11415d00 	call	811415d0 <OSTmr_Link>
             OSTmr_Unlock();
81141020:	11418600 	call	81141860 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81141024:	e0bfff17 	ldw	r2,-4(fp)
81141028:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
8114102c:	00800044 	movi	r2,1
81141030:	00001306 	br	81141080 <OSTmrStart+0x134>

        case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
        case OS_TMR_STATE_COMPLETED:
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
81141034:	000b883a 	mov	r5,zero
81141038:	e13ffe17 	ldw	r4,-8(fp)
8114103c:	11415d00 	call	811415d0 <OSTmr_Link>
             OSTmr_Unlock();
81141040:	11418600 	call	81141860 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81141044:	e0bfff17 	ldw	r2,-4(fp)
81141048:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
8114104c:	00800044 	movi	r2,1
81141050:	00000b06 	br	81141080 <OSTmrStart+0x134>

        case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
             OSTmr_Unlock();
81141054:	11418600 	call	81141860 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
81141058:	e0bfff17 	ldw	r2,-4(fp)
8114105c:	00ffe1c4 	movi	r3,-121
81141060:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
81141064:	0005883a 	mov	r2,zero
81141068:	00000506 	br	81141080 <OSTmrStart+0x134>

        default:
             OSTmr_Unlock();
8114106c:	11418600 	call	81141860 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
81141070:	e0bfff17 	ldw	r2,-4(fp)
81141074:	00ffe344 	movi	r3,-115
81141078:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8114107c:	0005883a 	mov	r2,zero
    }
}
81141080:	e037883a 	mov	sp,fp
81141084:	dfc00117 	ldw	ra,4(sp)
81141088:	df000017 	ldw	fp,0(sp)
8114108c:	dec00204 	addi	sp,sp,8
81141090:	f800283a 	ret

81141094 <OSTmrStop>:
#if OS_TMR_EN > 0
BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
                    INT8U    opt,
                    void    *callback_arg,
                    INT8U   *perr)
{
81141094:	defff904 	addi	sp,sp,-28
81141098:	de00012e 	bgeu	sp,et,811410a0 <OSTmrStop+0xc>
8114109c:	003b68fa 	trap	3
811410a0:	dfc00615 	stw	ra,24(sp)
811410a4:	df000515 	stw	fp,20(sp)
811410a8:	df000504 	addi	fp,sp,20
811410ac:	e13ffc15 	stw	r4,-16(fp)
811410b0:	2805883a 	mov	r2,r5
811410b4:	e1bffe15 	stw	r6,-8(fp)
811410b8:	e1ffff15 	stw	r7,-4(fp)
811410bc:	e0bffd05 	stb	r2,-12(fp)
    OS_TMR_CALLBACK  pfnct;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                                     /* Validate arguments                               */
811410c0:	e0bfff17 	ldw	r2,-4(fp)
811410c4:	1000021e 	bne	r2,zero,811410d0 <OSTmrStop+0x3c>
        return (OS_FALSE);
811410c8:	0005883a 	mov	r2,zero
811410cc:	00006606 	br	81141268 <OSTmrStop+0x1d4>
    }
    if (ptmr == (OS_TMR *)0) {
811410d0:	e0bffc17 	ldw	r2,-16(fp)
811410d4:	1000051e 	bne	r2,zero,811410ec <OSTmrStop+0x58>
        *perr = OS_ERR_TMR_INVALID;
811410d8:	e0bfff17 	ldw	r2,-4(fp)
811410dc:	00ffe284 	movi	r3,-118
811410e0:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811410e4:	0005883a 	mov	r2,zero
811410e8:	00005f06 	br	81141268 <OSTmrStop+0x1d4>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure                         */
811410ec:	e0bffc17 	ldw	r2,-16(fp)
811410f0:	10800003 	ldbu	r2,0(r2)
811410f4:	10803fcc 	andi	r2,r2,255
811410f8:	10801920 	cmpeqi	r2,r2,100
811410fc:	1000051e 	bne	r2,zero,81141114 <OSTmrStop+0x80>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81141100:	e0bfff17 	ldw	r2,-4(fp)
81141104:	00ffe244 	movi	r3,-119
81141108:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8114110c:	0005883a 	mov	r2,zero
81141110:	00005506 	br	81141268 <OSTmrStop+0x1d4>
    }
    if (OSIntNesting > 0) {                                       /* See if trying to call from an ISR                */
81141114:	d0a0a103 	ldbu	r2,-32124(gp)
81141118:	10803fcc 	andi	r2,r2,255
8114111c:	10000526 	beq	r2,zero,81141134 <OSTmrStop+0xa0>
        *perr  = OS_ERR_TMR_ISR;
81141120:	e0bfff17 	ldw	r2,-4(fp)
81141124:	00ffe2c4 	movi	r3,-117
81141128:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8114112c:	0005883a 	mov	r2,zero
81141130:	00004d06 	br	81141268 <OSTmrStop+0x1d4>
    }
    OSTmr_Lock();
81141134:	114181c0 	call	8114181c <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
81141138:	e0bffc17 	ldw	r2,-16(fp)
8114113c:	10800c43 	ldbu	r2,49(r2)
81141140:	10803fcc 	andi	r2,r2,255
81141144:	10c000c8 	cmpgei	r3,r2,3
81141148:	1800031e 	bne	r3,zero,81141158 <OSTmrStop+0xc4>
8114114c:	00803516 	blt	zero,r2,81141224 <OSTmrStop+0x190>
81141150:	10003a26 	beq	r2,zero,8114123c <OSTmrStop+0x1a8>
81141154:	00003f06 	br	81141254 <OSTmrStop+0x1c0>
81141158:	108000e0 	cmpeqi	r2,r2,3
8114115c:	10003d26 	beq	r2,zero,81141254 <OSTmrStop+0x1c0>
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke                  */
81141160:	e13ffc17 	ldw	r4,-16(fp)
81141164:	11417200 	call	81141720 <OSTmr_Unlink>
             *perr = OS_ERR_NONE;
81141168:	e0bfff17 	ldw	r2,-4(fp)
8114116c:	10000005 	stb	zero,0(r2)
             switch (opt) {
81141170:	e0bffd03 	ldbu	r2,-12(fp)
81141174:	10c000e0 	cmpeqi	r3,r2,3
81141178:	1800041e 	bne	r3,zero,8114118c <OSTmrStop+0xf8>
8114117c:	10c00120 	cmpeqi	r3,r2,4
81141180:	1800121e 	bne	r3,zero,811411cc <OSTmrStop+0x138>
81141184:	10002326 	beq	r2,zero,81141214 <OSTmrStop+0x180>
81141188:	00001e06 	br	81141204 <OSTmrStop+0x170>
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
8114118c:	e0bffc17 	ldw	r2,-16(fp)
81141190:	10800117 	ldw	r2,4(r2)
81141194:	e0bffb15 	stw	r2,-20(fp)
                      if (pfnct != (OS_TMR_CALLBACK)0) {
81141198:	e0bffb17 	ldw	r2,-20(fp)
8114119c:	10000726 	beq	r2,zero,811411bc <OSTmrStop+0x128>
                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
811411a0:	e0bffc17 	ldw	r2,-16(fp)
811411a4:	10c00217 	ldw	r3,8(r2)
811411a8:	e0bffb17 	ldw	r2,-20(fp)
811411ac:	180b883a 	mov	r5,r3
811411b0:	e13ffc17 	ldw	r4,-16(fp)
811411b4:	103ee83a 	callr	r2
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;
811411b8:	00001706 	br	81141218 <OSTmrStop+0x184>
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
                      if (pfnct != (OS_TMR_CALLBACK)0) {
                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
811411bc:	e0bfff17 	ldw	r2,-4(fp)
811411c0:	00ffe3c4 	movi	r3,-113
811411c4:	10c00005 	stb	r3,0(r2)
                      }
                      break;
811411c8:	00001306 	br	81141218 <OSTmrStop+0x184>

                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
811411cc:	e0bffc17 	ldw	r2,-16(fp)
811411d0:	10800117 	ldw	r2,4(r2)
811411d4:	e0bffb15 	stw	r2,-20(fp)
                      if (pfnct != (OS_TMR_CALLBACK)0) {
811411d8:	e0bffb17 	ldw	r2,-20(fp)
811411dc:	10000526 	beq	r2,zero,811411f4 <OSTmrStop+0x160>
                          (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
811411e0:	e0bffb17 	ldw	r2,-20(fp)
811411e4:	e17ffe17 	ldw	r5,-8(fp)
811411e8:	e13ffc17 	ldw	r4,-16(fp)
811411ec:	103ee83a 	callr	r2
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;
811411f0:	00000906 	br	81141218 <OSTmrStop+0x184>
                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
                      if (pfnct != (OS_TMR_CALLBACK)0) {
                          (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
811411f4:	e0bfff17 	ldw	r2,-4(fp)
811411f8:	00ffe3c4 	movi	r3,-113
811411fc:	10c00005 	stb	r3,0(r2)
                      }
                      break;
81141200:	00000506 	br	81141218 <OSTmrStop+0x184>

                 case OS_TMR_OPT_NONE:
                      break;

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
81141204:	e0bfff17 	ldw	r2,-4(fp)
81141208:	00ffe104 	movi	r3,-124
8114120c:	10c00005 	stb	r3,0(r2)
                     break;
81141210:	00000106 	br	81141218 <OSTmrStop+0x184>
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;

                 case OS_TMR_OPT_NONE:
                      break;
81141214:	0001883a 	nop

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
                     break;
             }
             OSTmr_Unlock();
81141218:	11418600 	call	81141860 <OSTmr_Unlock>
             return (OS_TRUE);
8114121c:	00800044 	movi	r2,1
81141220:	00001106 	br	81141268 <OSTmrStop+0x1d4>

        case OS_TMR_STATE_COMPLETED:                              /* Timer has already completed the ONE-SHOT or ...  */
        case OS_TMR_STATE_STOPPED:                                /* ... timer has not started yet.                   */
             OSTmr_Unlock();
81141224:	11418600 	call	81141860 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_STOPPED;
81141228:	e0bfff17 	ldw	r2,-4(fp)
8114122c:	00ffe384 	movi	r3,-114
81141230:	10c00005 	stb	r3,0(r2)
             return (OS_TRUE);
81141234:	00800044 	movi	r2,1
81141238:	00000b06 	br	81141268 <OSTmrStop+0x1d4>

        case OS_TMR_STATE_UNUSED:                                 /* Timer was not created                            */
             OSTmr_Unlock();
8114123c:	11418600 	call	81141860 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
81141240:	e0bfff17 	ldw	r2,-4(fp)
81141244:	00ffe1c4 	movi	r3,-121
81141248:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8114124c:	0005883a 	mov	r2,zero
81141250:	00000506 	br	81141268 <OSTmrStop+0x1d4>

        default:
             OSTmr_Unlock();
81141254:	11418600 	call	81141860 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
81141258:	e0bfff17 	ldw	r2,-4(fp)
8114125c:	00ffe344 	movi	r3,-115
81141260:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
81141264:	0005883a 	mov	r2,zero
    }
}
81141268:	e037883a 	mov	sp,fp
8114126c:	dfc00117 	ldw	ra,4(sp)
81141270:	df000017 	ldw	fp,0(sp)
81141274:	dec00204 	addi	sp,sp,8
81141278:	f800283a 	ret

8114127c <OSTmrSignal>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
INT8U  OSTmrSignal (void)
{
8114127c:	defffd04 	addi	sp,sp,-12
81141280:	de00012e 	bgeu	sp,et,81141288 <OSTmrSignal+0xc>
81141284:	003b68fa 	trap	3
81141288:	dfc00215 	stw	ra,8(sp)
8114128c:	df000115 	stw	fp,4(sp)
81141290:	df000104 	addi	fp,sp,4
    INT8U  err;


    err = OSSemPost(OSTmrSemSignal);
81141294:	d0a09017 	ldw	r2,-32192(gp)
81141298:	1009883a 	mov	r4,r2
8114129c:	113e8480 	call	8113e848 <OSSemPost>
811412a0:	e0bfff05 	stb	r2,-4(fp)
    return (err);
811412a4:	e0bfff03 	ldbu	r2,-4(fp)
}
811412a8:	e037883a 	mov	sp,fp
811412ac:	dfc00117 	ldw	ra,4(sp)
811412b0:	df000017 	ldw	fp,0(sp)
811412b4:	dec00204 	addi	sp,sp,8
811412b8:	f800283a 	ret

811412bc <OSTmr_Alloc>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  OS_TMR  *OSTmr_Alloc (void)
{
811412bc:	defffe04 	addi	sp,sp,-8
811412c0:	de00012e 	bgeu	sp,et,811412c8 <OSTmr_Alloc+0xc>
811412c4:	003b68fa 	trap	3
811412c8:	df000115 	stw	fp,4(sp)
811412cc:	df000104 	addi	fp,sp,4
    OS_TMR *ptmr;


    if (OSTmrFreeList == (OS_TMR *)0) {
811412d0:	d0a08e17 	ldw	r2,-32200(gp)
811412d4:	1000021e 	bne	r2,zero,811412e0 <OSTmr_Alloc+0x24>
        return ((OS_TMR *)0);
811412d8:	0005883a 	mov	r2,zero
811412dc:	00001006 	br	81141320 <OSTmr_Alloc+0x64>
    }
    ptmr            = (OS_TMR *)OSTmrFreeList;
811412e0:	d0a08e17 	ldw	r2,-32200(gp)
811412e4:	e0bfff15 	stw	r2,-4(fp)
    OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
811412e8:	e0bfff17 	ldw	r2,-4(fp)
811412ec:	10800317 	ldw	r2,12(r2)
811412f0:	d0a08e15 	stw	r2,-32200(gp)
    ptmr->OSTmrNext = (OS_TCB *)0;
811412f4:	e0bfff17 	ldw	r2,-4(fp)
811412f8:	10000315 	stw	zero,12(r2)
    ptmr->OSTmrPrev = (OS_TCB *)0;
811412fc:	e0bfff17 	ldw	r2,-4(fp)
81141300:	10000415 	stw	zero,16(r2)
    OSTmrUsed++;
81141304:	d0a0930b 	ldhu	r2,-32180(gp)
81141308:	10800044 	addi	r2,r2,1
8114130c:	d0a0930d 	sth	r2,-32180(gp)
    OSTmrFree--;
81141310:	d0a0970b 	ldhu	r2,-32164(gp)
81141314:	10bfffc4 	addi	r2,r2,-1
81141318:	d0a0970d 	sth	r2,-32164(gp)
    return (ptmr);
8114131c:	e0bfff17 	ldw	r2,-4(fp)
}
81141320:	e037883a 	mov	sp,fp
81141324:	df000017 	ldw	fp,0(sp)
81141328:	dec00104 	addi	sp,sp,4
8114132c:	f800283a 	ret

81141330 <OSTmr_Free>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Free (OS_TMR *ptmr)
{
81141330:	defffe04 	addi	sp,sp,-8
81141334:	de00012e 	bgeu	sp,et,8114133c <OSTmr_Free+0xc>
81141338:	003b68fa 	trap	3
8114133c:	df000115 	stw	fp,4(sp)
81141340:	df000104 	addi	fp,sp,4
81141344:	e13fff15 	stw	r4,-4(fp)
    ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
81141348:	e0bfff17 	ldw	r2,-4(fp)
8114134c:	10000c45 	stb	zero,49(r2)
    ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
81141350:	e0bfff17 	ldw	r2,-4(fp)
81141354:	10000c05 	stb	zero,48(r2)
    ptmr->OSTmrPeriod      = 0;
81141358:	e0bfff17 	ldw	r2,-4(fp)
8114135c:	10000715 	stw	zero,28(r2)
    ptmr->OSTmrMatch       = 0;
81141360:	e0bfff17 	ldw	r2,-4(fp)
81141364:	10000515 	stw	zero,20(r2)
    ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
81141368:	e0bfff17 	ldw	r2,-4(fp)
8114136c:	10000115 	stw	zero,4(r2)
    ptmr->OSTmrCallbackArg = (void *)0;
81141370:	e0bfff17 	ldw	r2,-4(fp)
81141374:	10000215 	stw	zero,8(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr->OSTmrName[0]     = '?';                      /* Unknown name                                                */
81141378:	e0bfff17 	ldw	r2,-4(fp)
8114137c:	00c00fc4 	movi	r3,63
81141380:	10c00805 	stb	r3,32(r2)
    ptmr->OSTmrName[1]     = OS_ASCII_NUL;
81141384:	e0bfff17 	ldw	r2,-4(fp)
81141388:	10000845 	stb	zero,33(r2)
#endif

    ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
8114138c:	e0bfff17 	ldw	r2,-4(fp)
81141390:	10000415 	stw	zero,16(r2)
    ptmr->OSTmrNext        = OSTmrFreeList;
81141394:	d0e08e17 	ldw	r3,-32200(gp)
81141398:	e0bfff17 	ldw	r2,-4(fp)
8114139c:	10c00315 	stw	r3,12(r2)
    OSTmrFreeList          = ptmr;
811413a0:	e0bfff17 	ldw	r2,-4(fp)
811413a4:	d0a08e15 	stw	r2,-32200(gp)

    OSTmrUsed--;                                       /* Update timer object statistics                              */
811413a8:	d0a0930b 	ldhu	r2,-32180(gp)
811413ac:	10bfffc4 	addi	r2,r2,-1
811413b0:	d0a0930d 	sth	r2,-32180(gp)
    OSTmrFree++;
811413b4:	d0a0970b 	ldhu	r2,-32164(gp)
811413b8:	10800044 	addi	r2,r2,1
811413bc:	d0a0970d 	sth	r2,-32164(gp)
}
811413c0:	0001883a 	nop
811413c4:	e037883a 	mov	sp,fp
811413c8:	df000017 	ldw	fp,0(sp)
811413cc:	dec00104 	addi	sp,sp,4
811413d0:	f800283a 	ret

811413d4 <OSTmr_Init>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
void  OSTmr_Init (void)
{
811413d4:	defffa04 	addi	sp,sp,-24
811413d8:	de00012e 	bgeu	sp,et,811413e0 <OSTmr_Init+0xc>
811413dc:	003b68fa 	trap	3
811413e0:	dfc00515 	stw	ra,20(sp)
811413e4:	df000415 	stw	fp,16(sp)
811413e8:	df000404 	addi	fp,sp,16
    INT16U   i;
    OS_TMR  *ptmr1;
    OS_TMR  *ptmr2;


    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
811413ec:	01406804 	movi	r5,416
811413f0:	012045b4 	movhi	r4,33046
811413f4:	211bfc04 	addi	r4,r4,28656
811413f8:	11395440 	call	81139544 <OS_MemClr>
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */
811413fc:	01400404 	movi	r5,16
81141400:	012045b4 	movhi	r4,33046
81141404:	2119e804 	addi	r4,r4,26528
81141408:	11395440 	call	81139544 <OS_MemClr>

    ptmr1 = &OSTmrTbl[0];
8114140c:	00a045b4 	movhi	r2,33046
81141410:	109bfc04 	addi	r2,r2,28656
81141414:	e0bffd15 	stw	r2,-12(fp)
    ptmr2 = &OSTmrTbl[1];
81141418:	00a045b4 	movhi	r2,33046
8114141c:	109c0904 	addi	r2,r2,28708
81141420:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
81141424:	e03ffc0d 	sth	zero,-16(fp)
81141428:	00001606 	br	81141484 <OSTmr_Init+0xb0>
        ptmr1->OSTmrType    = OS_TMR_TYPE;
8114142c:	e0bffd17 	ldw	r2,-12(fp)
81141430:	00c01904 	movi	r3,100
81141434:	10c00005 	stb	r3,0(r2)
        ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive            */
81141438:	e0bffd17 	ldw	r2,-12(fp)
8114143c:	10000c45 	stb	zero,49(r2)
        ptmr1->OSTmrNext    = (void *)ptmr2;                            /* Link to next timer                         */
81141440:	e0bffd17 	ldw	r2,-12(fp)
81141444:	e0fffe17 	ldw	r3,-8(fp)
81141448:	10c00315 	stw	r3,12(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
        ptmr1->OSTmrName[0] = '?';                                      /* Unknown name                               */
8114144c:	e0bffd17 	ldw	r2,-12(fp)
81141450:	00c00fc4 	movi	r3,63
81141454:	10c00805 	stb	r3,32(r2)
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
81141458:	e0bffd17 	ldw	r2,-12(fp)
8114145c:	10000845 	stb	zero,33(r2)
#endif
        ptmr1++;
81141460:	e0bffd17 	ldw	r2,-12(fp)
81141464:	10800d04 	addi	r2,r2,52
81141468:	e0bffd15 	stw	r2,-12(fp)
        ptmr2++;
8114146c:	e0bffe17 	ldw	r2,-8(fp)
81141470:	10800d04 	addi	r2,r2,52
81141474:	e0bffe15 	stw	r2,-8(fp)
    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */

    ptmr1 = &OSTmrTbl[0];
    ptmr2 = &OSTmrTbl[1];
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
81141478:	e0bffc0b 	ldhu	r2,-16(fp)
8114147c:	10800044 	addi	r2,r2,1
81141480:	e0bffc0d 	sth	r2,-16(fp)
81141484:	e0bffc0b 	ldhu	r2,-16(fp)
81141488:	108001f0 	cmpltui	r2,r2,7
8114148c:	103fe71e 	bne	r2,zero,8114142c <__reset+0xfb12142c>
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
#endif
        ptmr1++;
        ptmr2++;
    }
    ptmr1->OSTmrType    = OS_TMR_TYPE;
81141490:	e0bffd17 	ldw	r2,-12(fp)
81141494:	00c01904 	movi	r3,100
81141498:	10c00005 	stb	r3,0(r2)
    ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive            */
8114149c:	e0bffd17 	ldw	r2,-12(fp)
811414a0:	10000c45 	stb	zero,49(r2)
    ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                                */
811414a4:	e0bffd17 	ldw	r2,-12(fp)
811414a8:	10000315 	stw	zero,12(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr1->OSTmrName[0] = '?';                                          /* Unknown name                               */
811414ac:	e0bffd17 	ldw	r2,-12(fp)
811414b0:	00c00fc4 	movi	r3,63
811414b4:	10c00805 	stb	r3,32(r2)
    ptmr1->OSTmrName[1] = OS_ASCII_NUL;
811414b8:	e0bffd17 	ldw	r2,-12(fp)
811414bc:	10000845 	stb	zero,33(r2)
#endif
    OSTmrTime           = 0;
811414c0:	d020a315 	stw	zero,-32116(gp)
    OSTmrUsed           = 0;
811414c4:	d020930d 	sth	zero,-32180(gp)
    OSTmrFree           = OS_TMR_CFG_MAX;
811414c8:	00800204 	movi	r2,8
811414cc:	d0a0970d 	sth	r2,-32164(gp)
    OSTmrFreeList       = &OSTmrTbl[0];
811414d0:	00a045b4 	movhi	r2,33046
811414d4:	109bfc04 	addi	r2,r2,28656
811414d8:	d0a08e15 	stw	r2,-32200(gp)
    OSTmrSem            = OSSemCreate(1);
811414dc:	01000044 	movi	r4,1
811414e0:	113e1980 	call	8113e198 <OSSemCreate>
811414e4:	d0a0a515 	stw	r2,-32108(gp)
    OSTmrSemSignal      = OSSemCreate(0);
811414e8:	0009883a 	mov	r4,zero
811414ec:	113e1980 	call	8113e198 <OSSemCreate>
811414f0:	d0a09015 	stw	r2,-32192(gp)

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSem,       (INT8U *)"uC/OS-II TmrLock",   &err);/* Assign names to semaphores                 */
811414f4:	d0a0a517 	ldw	r2,-32108(gp)
811414f8:	e0ffff04 	addi	r3,fp,-4
811414fc:	180d883a 	mov	r6,r3
81141500:	01604574 	movhi	r5,33045
81141504:	2942ab04 	addi	r5,r5,2732
81141508:	1009883a 	mov	r4,r2
8114150c:	1137da00 	call	81137da0 <OSEventNameSet>
    OSEventNameSet(OSTmrSem,       (INT8U *)"OS-TmrLock",         &err);
#endif
#endif

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"uC/OS-II TmrSignal", &err);
81141510:	d0a09017 	ldw	r2,-32192(gp)
81141514:	e0ffff04 	addi	r3,fp,-4
81141518:	180d883a 	mov	r6,r3
8114151c:	01604574 	movhi	r5,33045
81141520:	2942b004 	addi	r5,r5,2752
81141524:	1009883a 	mov	r4,r2
81141528:	1137da00 	call	81137da0 <OSEventNameSet>
#if OS_EVENT_NAME_SIZE > 10
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"OS-TmrSig",          &err);
#endif
#endif

    OSTmr_InitTask();
8114152c:	11415480 	call	81141548 <OSTmr_InitTask>
}
81141530:	0001883a 	nop
81141534:	e037883a 	mov	sp,fp
81141538:	dfc00117 	ldw	ra,4(sp)
8114153c:	df000017 	ldw	fp,0(sp)
81141540:	dec00204 	addi	sp,sp,8
81141544:	f800283a 	ret

81141548 <OSTmr_InitTask>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_InitTask (void)
{
81141548:	defff804 	addi	sp,sp,-32
8114154c:	de00012e 	bgeu	sp,et,81141554 <OSTmr_InitTask+0xc>
81141550:	003b68fa 	trap	3
81141554:	dfc00715 	stw	ra,28(sp)
81141558:	df000615 	stw	fp,24(sp)
8114155c:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OSTmr_Task,
81141560:	008000c4 	movi	r2,3
81141564:	d8800415 	stw	r2,16(sp)
81141568:	d8000315 	stw	zero,12(sp)
8114156c:	00808004 	movi	r2,512
81141570:	d8800215 	stw	r2,8(sp)
81141574:	00a045f4 	movhi	r2,33047
81141578:	10a43004 	addi	r2,r2,-28480
8114157c:	d8800115 	stw	r2,4(sp)
81141580:	00bfff54 	movui	r2,65533
81141584:	d8800015 	stw	r2,0(sp)
81141588:	01c00744 	movi	r7,29
8114158c:	01a045f4 	movhi	r6,33047
81141590:	31a62f04 	addi	r6,r6,-26436
81141594:	000b883a 	mov	r5,zero
81141598:	01204534 	movhi	r4,33044
8114159c:	21062704 	addi	r4,r4,6300
811415a0:	113f22c0 	call	8113f22c <OSTaskCreateExt>
                       OS_TASK_TMR_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 12
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"uC/OS-II Tmr", &err);
811415a4:	e1bfff04 	addi	r6,fp,-4
811415a8:	01604574 	movhi	r5,33045
811415ac:	2942b504 	addi	r5,r5,2772
811415b0:	01000744 	movi	r4,29
811415b4:	113fa5c0 	call	8113fa5c <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 6
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"OS-Tmr", &err);
#endif
#endif
}
811415b8:	0001883a 	nop
811415bc:	e037883a 	mov	sp,fp
811415c0:	dfc00117 	ldw	ra,4(sp)
811415c4:	df000017 	ldw	fp,0(sp)
811415c8:	dec00204 	addi	sp,sp,8
811415cc:	f800283a 	ret

811415d0 <OSTmr_Link>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Link (OS_TMR *ptmr, INT8U type)
{
811415d0:	defffa04 	addi	sp,sp,-24
811415d4:	de00012e 	bgeu	sp,et,811415dc <OSTmr_Link+0xc>
811415d8:	003b68fa 	trap	3
811415dc:	df000515 	stw	fp,20(sp)
811415e0:	df000504 	addi	fp,sp,20
811415e4:	e13ffe15 	stw	r4,-8(fp)
811415e8:	2805883a 	mov	r2,r5
811415ec:	e0bfff05 	stb	r2,-4(fp)
    OS_TMR       *ptmr1;
    OS_TMR_WHEEL *pspoke;
    INT16U        spoke;


    ptmr->OSTmrState = OS_TMR_STATE_RUNNING;
811415f0:	e0bffe17 	ldw	r2,-8(fp)
811415f4:	00c000c4 	movi	r3,3
811415f8:	10c00c45 	stb	r3,49(r2)
    if (type == OS_TMR_LINK_PERIODIC) {                            /* Determine when timer will expire                */
811415fc:	e0bfff03 	ldbu	r2,-4(fp)
81141600:	10800058 	cmpnei	r2,r2,1
81141604:	1000071e 	bne	r2,zero,81141624 <OSTmr_Link+0x54>
        ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
81141608:	e0bffe17 	ldw	r2,-8(fp)
8114160c:	10c00717 	ldw	r3,28(r2)
81141610:	d0a0a317 	ldw	r2,-32116(gp)
81141614:	1887883a 	add	r3,r3,r2
81141618:	e0bffe17 	ldw	r2,-8(fp)
8114161c:	10c00515 	stw	r3,20(r2)
81141620:	00001006 	br	81141664 <OSTmr_Link+0x94>
    } else {
        if (ptmr->OSTmrDly == 0) {
81141624:	e0bffe17 	ldw	r2,-8(fp)
81141628:	10800617 	ldw	r2,24(r2)
8114162c:	1000071e 	bne	r2,zero,8114164c <OSTmr_Link+0x7c>
            ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
81141630:	e0bffe17 	ldw	r2,-8(fp)
81141634:	10c00717 	ldw	r3,28(r2)
81141638:	d0a0a317 	ldw	r2,-32116(gp)
8114163c:	1887883a 	add	r3,r3,r2
81141640:	e0bffe17 	ldw	r2,-8(fp)
81141644:	10c00515 	stw	r3,20(r2)
81141648:	00000606 	br	81141664 <OSTmr_Link+0x94>
        } else {
            ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
8114164c:	e0bffe17 	ldw	r2,-8(fp)
81141650:	10c00617 	ldw	r3,24(r2)
81141654:	d0a0a317 	ldw	r2,-32116(gp)
81141658:	1887883a 	add	r3,r3,r2
8114165c:	e0bffe17 	ldw	r2,-8(fp)
81141660:	10c00515 	stw	r3,20(r2)
        }
    }
    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
81141664:	e0bffe17 	ldw	r2,-8(fp)
81141668:	10800517 	ldw	r2,20(r2)
8114166c:	1080004c 	andi	r2,r2,1
81141670:	e0bffb0d 	sth	r2,-20(fp)
    pspoke = &OSTmrWheelTbl[spoke];
81141674:	e0bffb0b 	ldhu	r2,-20(fp)
81141678:	100690fa 	slli	r3,r2,3
8114167c:	00a045b4 	movhi	r2,33046
81141680:	1099e804 	addi	r2,r2,26528
81141684:	1885883a 	add	r2,r3,r2
81141688:	e0bffc15 	stw	r2,-16(fp)

    if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
8114168c:	e0bffc17 	ldw	r2,-16(fp)
81141690:	10800017 	ldw	r2,0(r2)
81141694:	1000091e 	bne	r2,zero,811416bc <OSTmr_Link+0xec>
        pspoke->OSTmrFirst   = ptmr;
81141698:	e0bffc17 	ldw	r2,-16(fp)
8114169c:	e0fffe17 	ldw	r3,-8(fp)
811416a0:	10c00015 	stw	r3,0(r2)
        ptmr->OSTmrNext      = (OS_TMR *)0;
811416a4:	e0bffe17 	ldw	r2,-8(fp)
811416a8:	10000315 	stw	zero,12(r2)
        pspoke->OSTmrEntries = 1;
811416ac:	e0bffc17 	ldw	r2,-16(fp)
811416b0:	00c00044 	movi	r3,1
811416b4:	10c0010d 	sth	r3,4(r2)
811416b8:	00001206 	br	81141704 <OSTmr_Link+0x134>
    } else {
        ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke               */
811416bc:	e0bffc17 	ldw	r2,-16(fp)
811416c0:	10800017 	ldw	r2,0(r2)
811416c4:	e0bffd15 	stw	r2,-12(fp)
        pspoke->OSTmrFirst   = ptmr;
811416c8:	e0bffc17 	ldw	r2,-16(fp)
811416cc:	e0fffe17 	ldw	r3,-8(fp)
811416d0:	10c00015 	stw	r3,0(r2)
        ptmr->OSTmrNext      = (void *)ptmr1;
811416d4:	e0bffe17 	ldw	r2,-8(fp)
811416d8:	e0fffd17 	ldw	r3,-12(fp)
811416dc:	10c00315 	stw	r3,12(r2)
        ptmr1->OSTmrPrev     = (void *)ptmr;
811416e0:	e0bffd17 	ldw	r2,-12(fp)
811416e4:	e0fffe17 	ldw	r3,-8(fp)
811416e8:	10c00415 	stw	r3,16(r2)
        pspoke->OSTmrEntries++;
811416ec:	e0bffc17 	ldw	r2,-16(fp)
811416f0:	1080010b 	ldhu	r2,4(r2)
811416f4:	10800044 	addi	r2,r2,1
811416f8:	1007883a 	mov	r3,r2
811416fc:	e0bffc17 	ldw	r2,-16(fp)
81141700:	10c0010d 	sth	r3,4(r2)
    }
    ptmr->OSTmrPrev = (void *)0;                                   /* Timer always inserted as first node in list     */
81141704:	e0bffe17 	ldw	r2,-8(fp)
81141708:	10000415 	stw	zero,16(r2)
}
8114170c:	0001883a 	nop
81141710:	e037883a 	mov	sp,fp
81141714:	df000017 	ldw	fp,0(sp)
81141718:	dec00104 	addi	sp,sp,4
8114171c:	f800283a 	ret

81141720 <OSTmr_Unlink>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Unlink (OS_TMR *ptmr)
{
81141720:	defffa04 	addi	sp,sp,-24
81141724:	de00012e 	bgeu	sp,et,8114172c <OSTmr_Unlink+0xc>
81141728:	003b68fa 	trap	3
8114172c:	df000515 	stw	fp,20(sp)
81141730:	df000504 	addi	fp,sp,20
81141734:	e13fff15 	stw	r4,-4(fp)
    OS_TMR        *ptmr2;
    OS_TMR_WHEEL  *pspoke;
    INT16U         spoke;


    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
81141738:	e0bfff17 	ldw	r2,-4(fp)
8114173c:	10800517 	ldw	r2,20(r2)
81141740:	1080004c 	andi	r2,r2,1
81141744:	e0bffb0d 	sth	r2,-20(fp)
    pspoke = &OSTmrWheelTbl[spoke];
81141748:	e0bffb0b 	ldhu	r2,-20(fp)
8114174c:	100690fa 	slli	r3,r2,3
81141750:	00a045b4 	movhi	r2,33046
81141754:	1099e804 	addi	r2,r2,26528
81141758:	1885883a 	add	r2,r3,r2
8114175c:	e0bffc15 	stw	r2,-16(fp)

    if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning of list     */
81141760:	e0bffc17 	ldw	r2,-16(fp)
81141764:	10c00017 	ldw	r3,0(r2)
81141768:	e0bfff17 	ldw	r2,-4(fp)
8114176c:	18800b1e 	bne	r3,r2,8114179c <OSTmr_Unlink+0x7c>
        ptmr1              = (OS_TMR *)ptmr->OSTmrNext;
81141770:	e0bfff17 	ldw	r2,-4(fp)
81141774:	10800317 	ldw	r2,12(r2)
81141778:	e0bffd15 	stw	r2,-12(fp)
        pspoke->OSTmrFirst = (OS_TMR *)ptmr1;
8114177c:	e0bffc17 	ldw	r2,-16(fp)
81141780:	e0fffd17 	ldw	r3,-12(fp)
81141784:	10c00015 	stw	r3,0(r2)
        if (ptmr1 != (OS_TMR *)0) {
81141788:	e0bffd17 	ldw	r2,-12(fp)
8114178c:	10001126 	beq	r2,zero,811417d4 <OSTmr_Unlink+0xb4>
            ptmr1->OSTmrPrev = (void *)0;
81141790:	e0bffd17 	ldw	r2,-12(fp)
81141794:	10000415 	stw	zero,16(r2)
81141798:	00000e06 	br	811417d4 <OSTmr_Unlink+0xb4>
        }
    } else {
        ptmr1            = (OS_TMR *)ptmr->OSTmrPrev;       /* Remove timer from somewhere in the list                */
8114179c:	e0bfff17 	ldw	r2,-4(fp)
811417a0:	10800417 	ldw	r2,16(r2)
811417a4:	e0bffd15 	stw	r2,-12(fp)
        ptmr2            = (OS_TMR *)ptmr->OSTmrNext;
811417a8:	e0bfff17 	ldw	r2,-4(fp)
811417ac:	10800317 	ldw	r2,12(r2)
811417b0:	e0bffe15 	stw	r2,-8(fp)
        ptmr1->OSTmrNext = ptmr2;
811417b4:	e0bffd17 	ldw	r2,-12(fp)
811417b8:	e0fffe17 	ldw	r3,-8(fp)
811417bc:	10c00315 	stw	r3,12(r2)
        if (ptmr2 != (OS_TMR *)0) {
811417c0:	e0bffe17 	ldw	r2,-8(fp)
811417c4:	10000326 	beq	r2,zero,811417d4 <OSTmr_Unlink+0xb4>
            ptmr2->OSTmrPrev = (void *)ptmr1;
811417c8:	e0bffe17 	ldw	r2,-8(fp)
811417cc:	e0fffd17 	ldw	r3,-12(fp)
811417d0:	10c00415 	stw	r3,16(r2)
        }
    }
    ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
811417d4:	e0bfff17 	ldw	r2,-4(fp)
811417d8:	00c00044 	movi	r3,1
811417dc:	10c00c45 	stb	r3,49(r2)
    ptmr->OSTmrNext  = (void *)0;
811417e0:	e0bfff17 	ldw	r2,-4(fp)
811417e4:	10000315 	stw	zero,12(r2)
    ptmr->OSTmrPrev  = (void *)0;
811417e8:	e0bfff17 	ldw	r2,-4(fp)
811417ec:	10000415 	stw	zero,16(r2)
    pspoke->OSTmrEntries--;
811417f0:	e0bffc17 	ldw	r2,-16(fp)
811417f4:	1080010b 	ldhu	r2,4(r2)
811417f8:	10bfffc4 	addi	r2,r2,-1
811417fc:	1007883a 	mov	r3,r2
81141800:	e0bffc17 	ldw	r2,-16(fp)
81141804:	10c0010d 	sth	r3,4(r2)
}
81141808:	0001883a 	nop
8114180c:	e037883a 	mov	sp,fp
81141810:	df000017 	ldw	fp,0(sp)
81141814:	dec00104 	addi	sp,sp,4
81141818:	f800283a 	ret

8114181c <OSTmr_Lock>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Lock (void)
{
8114181c:	defffd04 	addi	sp,sp,-12
81141820:	de00012e 	bgeu	sp,et,81141828 <OSTmr_Lock+0xc>
81141824:	003b68fa 	trap	3
81141828:	dfc00215 	stw	ra,8(sp)
8114182c:	df000115 	stw	fp,4(sp)
81141830:	df000104 	addi	fp,sp,4
    INT8U  err;


    OSSemPend(OSTmrSem, 0, &err);
81141834:	d0a0a517 	ldw	r2,-32108(gp)
81141838:	e1bfff04 	addi	r6,fp,-4
8114183c:	000b883a 	mov	r5,zero
81141840:	1009883a 	mov	r4,r2
81141844:	113e4c00 	call	8113e4c0 <OSSemPend>
    (void)err;
}
81141848:	0001883a 	nop
8114184c:	e037883a 	mov	sp,fp
81141850:	dfc00117 	ldw	ra,4(sp)
81141854:	df000017 	ldw	fp,0(sp)
81141858:	dec00204 	addi	sp,sp,8
8114185c:	f800283a 	ret

81141860 <OSTmr_Unlock>:



#if OS_TMR_EN > 0
static  void  OSTmr_Unlock (void)
{
81141860:	defffe04 	addi	sp,sp,-8
81141864:	de00012e 	bgeu	sp,et,8114186c <OSTmr_Unlock+0xc>
81141868:	003b68fa 	trap	3
8114186c:	dfc00115 	stw	ra,4(sp)
81141870:	df000015 	stw	fp,0(sp)
81141874:	d839883a 	mov	fp,sp
    (void)OSSemPost(OSTmrSem);
81141878:	d0a0a517 	ldw	r2,-32108(gp)
8114187c:	1009883a 	mov	r4,r2
81141880:	113e8480 	call	8113e848 <OSSemPost>
}
81141884:	0001883a 	nop
81141888:	e037883a 	mov	sp,fp
8114188c:	dfc00117 	ldw	ra,4(sp)
81141890:	df000017 	ldw	fp,0(sp)
81141894:	dec00204 	addi	sp,sp,8
81141898:	f800283a 	ret

8114189c <OSTmr_Task>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Task (void *p_arg)
{
8114189c:	defff704 	addi	sp,sp,-36
811418a0:	de00012e 	bgeu	sp,et,811418a8 <OSTmr_Task+0xc>
811418a4:	003b68fa 	trap	3
811418a8:	dfc00815 	stw	ra,32(sp)
811418ac:	df000715 	stw	fp,28(sp)
811418b0:	df000704 	addi	fp,sp,28
811418b4:	e13fff15 	stw	r4,-4(fp)
    INT16U           spoke;


    (void)p_arg;                                                 /* Not using 'p_arg', prevent compiler warning       */
    for (;;) {
        OSSemPend(OSTmrSemSignal, 0, &err);                      /* Wait for signal indicating time to update timers  */
811418b8:	d0a09017 	ldw	r2,-32192(gp)
811418bc:	e0fffe04 	addi	r3,fp,-8
811418c0:	180d883a 	mov	r6,r3
811418c4:	000b883a 	mov	r5,zero
811418c8:	1009883a 	mov	r4,r2
811418cc:	113e4c00 	call	8113e4c0 <OSSemPend>
        OSTmr_Lock();
811418d0:	114181c0 	call	8114181c <OSTmr_Lock>
        OSTmrTime++;                                             /* Increment the current time                        */
811418d4:	d0a0a317 	ldw	r2,-32116(gp)
811418d8:	10800044 	addi	r2,r2,1
811418dc:	d0a0a315 	stw	r2,-32116(gp)
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
811418e0:	d0a0a317 	ldw	r2,-32116(gp)
811418e4:	1080004c 	andi	r2,r2,1
811418e8:	e0bffa0d 	sth	r2,-24(fp)
        pspoke = &OSTmrWheelTbl[spoke];
811418ec:	e0bffa0b 	ldhu	r2,-24(fp)
811418f0:	100690fa 	slli	r3,r2,3
811418f4:	00a045b4 	movhi	r2,33046
811418f8:	1099e804 	addi	r2,r2,26528
811418fc:	1885883a 	add	r2,r3,r2
81141900:	e0bffb15 	stw	r2,-20(fp)
        ptmr   = pspoke->OSTmrFirst;
81141904:	e0bffb17 	ldw	r2,-20(fp)
81141908:	10800017 	ldw	r2,0(r2)
8114190c:	e0bff915 	stw	r2,-28(fp)
        while (ptmr != (OS_TMR *)0) {
81141910:	00002206 	br	8114199c <OSTmr_Task+0x100>
            ptmr_next = (OS_TMR *)ptmr->OSTmrNext;               /* Point to next timer to update because current ... */
81141914:	e0bff917 	ldw	r2,-28(fp)
81141918:	10800317 	ldw	r2,12(r2)
8114191c:	e0bffc15 	stw	r2,-16(fp)
                                                                 /* ... timer could get unlinked from the wheel.      */
            if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires                   */
81141920:	e0bff917 	ldw	r2,-28(fp)
81141924:	10c00517 	ldw	r3,20(r2)
81141928:	d0a0a317 	ldw	r2,-32116(gp)
8114192c:	1880191e 	bne	r3,r2,81141994 <OSTmr_Task+0xf8>
                pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available            */
81141930:	e0bff917 	ldw	r2,-28(fp)
81141934:	10800117 	ldw	r2,4(r2)
81141938:	e0bffd15 	stw	r2,-12(fp)
                if (pfnct != (OS_TMR_CALLBACK)0) {
8114193c:	e0bffd17 	ldw	r2,-12(fp)
81141940:	10000626 	beq	r2,zero,8114195c <OSTmr_Task+0xc0>
                    (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);
81141944:	e0bff917 	ldw	r2,-28(fp)
81141948:	10c00217 	ldw	r3,8(r2)
8114194c:	e0bffd17 	ldw	r2,-12(fp)
81141950:	180b883a 	mov	r5,r3
81141954:	e13ff917 	ldw	r4,-28(fp)
81141958:	103ee83a 	callr	r2
                }
                OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke                   */
8114195c:	e13ff917 	ldw	r4,-28(fp)
81141960:	11417200 	call	81141720 <OSTmr_Unlink>
                if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
81141964:	e0bff917 	ldw	r2,-28(fp)
81141968:	10800c03 	ldbu	r2,48(r2)
8114196c:	10803fcc 	andi	r2,r2,255
81141970:	10800098 	cmpnei	r2,r2,2
81141974:	1000041e 	bne	r2,zero,81141988 <OSTmr_Task+0xec>
                    OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in wheel        */
81141978:	01400044 	movi	r5,1
8114197c:	e13ff917 	ldw	r4,-28(fp)
81141980:	11415d00 	call	811415d0 <OSTmr_Link>
81141984:	00000306 	br	81141994 <OSTmr_Task+0xf8>
                } else {
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
81141988:	e0bff917 	ldw	r2,-28(fp)
8114198c:	00c00084 	movi	r3,2
81141990:	10c00c45 	stb	r3,49(r2)
                }
            }
            ptmr = ptmr_next;
81141994:	e0bffc17 	ldw	r2,-16(fp)
81141998:	e0bff915 	stw	r2,-28(fp)
        OSTmr_Lock();
        OSTmrTime++;                                             /* Increment the current time                        */
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
        pspoke = &OSTmrWheelTbl[spoke];
        ptmr   = pspoke->OSTmrFirst;
        while (ptmr != (OS_TMR *)0) {
8114199c:	e0bff917 	ldw	r2,-28(fp)
811419a0:	103fdc1e 	bne	r2,zero,81141914 <__reset+0xfb121914>
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
                }
            }
            ptmr = ptmr_next;
        }
        OSTmr_Unlock();
811419a4:	11418600 	call	81141860 <OSTmr_Unlock>
    }
811419a8:	003fc306 	br	811418b8 <__reset+0xfb1218b8>

811419ac <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
811419ac:	defffd04 	addi	sp,sp,-12
811419b0:	de00012e 	bgeu	sp,et,811419b8 <alt_dev_reg+0xc>
811419b4:	003b68fa 	trap	3
811419b8:	dfc00215 	stw	ra,8(sp)
811419bc:	df000115 	stw	fp,4(sp)
811419c0:	df000104 	addi	fp,sp,4
811419c4:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
811419c8:	d1600d04 	addi	r5,gp,-32716
811419cc:	e13fff17 	ldw	r4,-4(fp)
811419d0:	1149c4c0 	call	81149c4c <alt_dev_llist_insert>
}
811419d4:	e037883a 	mov	sp,fp
811419d8:	dfc00117 	ldw	ra,4(sp)
811419dc:	df000017 	ldw	fp,0(sp)
811419e0:	dec00204 	addi	sp,sp,8
811419e4:	f800283a 	ret

811419e8 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
811419e8:	defffd04 	addi	sp,sp,-12
811419ec:	de00012e 	bgeu	sp,et,811419f4 <alt_irq_init+0xc>
811419f0:	003b68fa 	trap	3
811419f4:	dfc00215 	stw	ra,8(sp)
811419f8:	df000115 	stw	fp,4(sp)
811419fc:	df000104 	addi	fp,sp,4
81141a00:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_0, nios2_gen2_0);
81141a04:	114a6140 	call	8114a614 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
81141a08:	00800044 	movi	r2,1
81141a0c:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
81141a10:	0001883a 	nop
81141a14:	e037883a 	mov	sp,fp
81141a18:	dfc00117 	ldw	ra,4(sp)
81141a1c:	df000017 	ldw	fp,0(sp)
81141a20:	dec00204 	addi	sp,sp,8
81141a24:	f800283a 	ret

81141a28 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
81141a28:	defffe04 	addi	sp,sp,-8
81141a2c:	de00012e 	bgeu	sp,et,81141a34 <alt_sys_init+0xc>
81141a30:	003b68fa 	trap	3
81141a34:	dfc00115 	stw	ra,4(sp)
81141a38:	df000015 	stw	fp,0(sp)
81141a3c:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_1MS, timer_1ms);
81141a40:	01c0fa04 	movi	r7,1000
81141a44:	01800304 	movi	r6,12
81141a48:	000b883a 	mov	r5,zero
81141a4c:	01200034 	movhi	r4,32768
81141a50:	21022004 	addi	r4,r4,2176
81141a54:	1146d800 	call	81146d80 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_TIMER_INIT ( TIMER_1US, timer_1us);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
81141a58:	018002c4 	movi	r6,11
81141a5c:	000b883a 	mov	r5,zero
81141a60:	01204574 	movhi	r4,33045
81141a64:	21065104 	addi	r4,r4,6468
81141a68:	114606c0 	call	8114606c <altera_avalon_jtag_uart_init>
81141a6c:	01204574 	movhi	r4,33045
81141a70:	21064704 	addi	r4,r4,6428
81141a74:	11419ac0 	call	811419ac <alt_dev_reg>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS, sysid_qsys);
81141a78:	0001883a 	nop
    ALTERA_AVALON_UART_INIT ( RS232_UART, rs232_uart);
81141a7c:	018003c4 	movi	r6,15
81141a80:	000b883a 	mov	r5,zero
81141a84:	01204574 	movhi	r4,33045
81141a88:	210a6c04 	addi	r4,r4,10672
81141a8c:	1146f2c0 	call	81146f2c <altera_avalon_uart_init>
81141a90:	01204574 	movhi	r4,33045
81141a94:	210a6204 	addi	r4,r4,10632
81141a98:	11419ac0 	call	811419ac <alt_dev_reg>
    ALTERA_MSGDMA_INIT ( DMA_DDR_M1, dma_DDR_M1);
81141a9c:	00a04574 	movhi	r2,33045
81141aa0:	108a9604 	addi	r2,r2,10840
81141aa4:	10c00717 	ldw	r3,28(r2)
81141aa8:	00a04574 	movhi	r2,33045
81141aac:	108a9604 	addi	r2,r2,10840
81141ab0:	10800817 	ldw	r2,32(r2)
81141ab4:	100d883a 	mov	r6,r2
81141ab8:	180b883a 	mov	r5,r3
81141abc:	01204574 	movhi	r4,33045
81141ac0:	210a9604 	addi	r4,r4,10840
81141ac4:	11497b40 	call	811497b4 <alt_msgdma_init>
    ALTERA_MSGDMA_INIT ( DMA_DDR_M2, dma_DDR_M2);
81141ac8:	00a04574 	movhi	r2,33045
81141acc:	108aaf04 	addi	r2,r2,10940
81141ad0:	10c00717 	ldw	r3,28(r2)
81141ad4:	00a04574 	movhi	r2,33045
81141ad8:	108aaf04 	addi	r2,r2,10940
81141adc:	10800817 	ldw	r2,32(r2)
81141ae0:	100d883a 	mov	r6,r2
81141ae4:	180b883a 	mov	r5,r3
81141ae8:	01204574 	movhi	r4,33045
81141aec:	210aaf04 	addi	r4,r4,10940
81141af0:	11497b40 	call	811497b4 <alt_msgdma_init>
    ALTERA_UP_SD_CARD_AVALON_INTERFACE_INIT ( ALTERA_UP_SD_CARD_AVALON_INTERFACE_0, Altera_UP_SD_Card_Avalon_Interface_0);
81141af4:	01204574 	movhi	r4,33045
81141af8:	210ac804 	addi	r4,r4,11040
81141afc:	11419ac0 	call	811419ac <alt_dev_reg>
}
81141b00:	0001883a 	nop
81141b04:	e037883a 	mov	sp,fp
81141b08:	dfc00117 	ldw	ra,4(sp)
81141b0c:	df000017 	ldw	fp,0(sp)
81141b10:	dec00204 	addi	sp,sp,8
81141b14:	f800283a 	ret

81141b18 <Write_Sector_Data>:
///////////////////////////////////////////////////////////////////////////

        
bool Write_Sector_Data(int sector_index, int partition_offset)
// This function writes a sector at the specified address on the SD Card.
{
81141b18:	defffa04 	addi	sp,sp,-24
81141b1c:	de00012e 	bgeu	sp,et,81141b24 <Write_Sector_Data+0xc>
81141b20:	003b68fa 	trap	3
81141b24:	dfc00515 	stw	ra,20(sp)
81141b28:	df000415 	stw	fp,16(sp)
81141b2c:	df000404 	addi	fp,sp,16
81141b30:	e13ffe15 	stw	r4,-8(fp)
81141b34:	e17fff15 	stw	r5,-4(fp)
    bool result = false;
81141b38:	e03ffc15 	stw	zero,-16(fp)
    
    if (alt_up_sd_card_is_Present())
81141b3c:	11449000 	call	81144900 <alt_up_sd_card_is_Present>
81141b40:	10001e26 	beq	r2,zero,81141bbc <Write_Sector_Data+0xa4>
    {
        short int reg_state = 0xff;
81141b44:	00803fc4 	movi	r2,255
81141b48:	e0bffd0d 	sth	r2,-12(fp)

		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
         * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
81141b4c:	d0a0af17 	ldw	r2,-32068(gp)
81141b50:	e13ffe17 	ldw	r4,-8(fp)
81141b54:	e0ffff17 	ldw	r3,-4(fp)
81141b58:	20c7883a 	add	r3,r4,r3
81141b5c:	1806927a 	slli	r3,r3,9
81141b60:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_WRITE_BLOCK);
81141b64:	d0a0ae17 	ldw	r2,-32072(gp)
81141b68:	00c00604 	movi	r3,24
81141b6c:	10c0002d 	sthio	r3,0(r2)
        do {
            reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
81141b70:	d0a0ab17 	ldw	r2,-32084(gp)
81141b74:	1080002b 	ldhuio	r2,0(r2)
81141b78:	10bfffcc 	andi	r2,r2,65535
81141b7c:	e0bffd0d 	sth	r2,-12(fp)
        } while ((reg_state & 0x04)!=0);
81141b80:	e0bffd0b 	ldhu	r2,-12(fp)
81141b84:	10bfffcc 	andi	r2,r2,65535
81141b88:	1080010c 	andi	r2,r2,4
81141b8c:	103ff81e 	bne	r2,zero,81141b70 <__reset+0xfb121b70>
        // Make sure the request did not time out.
        if ((reg_state & 0x10) == 0)
81141b90:	e0bffd0b 	ldhu	r2,-12(fp)
81141b94:	10bfffcc 	andi	r2,r2,65535
81141b98:	1080040c 	andi	r2,r2,16
81141b9c:	1000071e 	bne	r2,zero,81141bbc <Write_Sector_Data+0xa4>
        {
            result = true;
81141ba0:	00800044 	movi	r2,1
81141ba4:	e0bffc15 	stw	r2,-16(fp)
            current_sector_modified = false;
81141ba8:	d020b415 	stw	zero,-32048(gp)
            current_sector_index = sector_index+partition_offset;
81141bac:	e0fffe17 	ldw	r3,-8(fp)
81141bb0:	e0bfff17 	ldw	r2,-4(fp)
81141bb4:	1885883a 	add	r2,r3,r2
81141bb8:	d0a0b515 	stw	r2,-32044(gp)
        }
    }
    return result;
81141bbc:	e0bffc17 	ldw	r2,-16(fp)
}
81141bc0:	e037883a 	mov	sp,fp
81141bc4:	dfc00117 	ldw	ra,4(sp)
81141bc8:	df000017 	ldw	fp,0(sp)
81141bcc:	dec00204 	addi	sp,sp,8
81141bd0:	f800283a 	ret

81141bd4 <Save_Modified_Sector>:


bool Save_Modified_Sector()
// If the sector has been modified, then save it to the SD Card.
{
81141bd4:	defffd04 	addi	sp,sp,-12
81141bd8:	de00012e 	bgeu	sp,et,81141be0 <Save_Modified_Sector+0xc>
81141bdc:	003b68fa 	trap	3
81141be0:	dfc00215 	stw	ra,8(sp)
81141be4:	df000115 	stw	fp,4(sp)
81141be8:	df000104 	addi	fp,sp,4
    bool result = true;
81141bec:	00800044 	movi	r2,1
81141bf0:	e0bfff15 	stw	r2,-4(fp)
    if (current_sector_modified)
81141bf4:	d0a0b417 	ldw	r2,-32048(gp)
81141bf8:	10000526 	beq	r2,zero,81141c10 <Save_Modified_Sector+0x3c>
    {
        result = Write_Sector_Data(current_sector_index, 0);
81141bfc:	d0a0b517 	ldw	r2,-32044(gp)
81141c00:	000b883a 	mov	r5,zero
81141c04:	1009883a 	mov	r4,r2
81141c08:	1141b180 	call	81141b18 <Write_Sector_Data>
81141c0c:	e0bfff15 	stw	r2,-4(fp)
    }
    return result;
81141c10:	e0bfff17 	ldw	r2,-4(fp)
}
81141c14:	e037883a 	mov	sp,fp
81141c18:	dfc00117 	ldw	ra,4(sp)
81141c1c:	df000017 	ldw	fp,0(sp)
81141c20:	dec00204 	addi	sp,sp,8
81141c24:	f800283a 	ret

81141c28 <Read_Sector_Data>:


bool Read_Sector_Data(int sector_index, int partition_offset)
// This function reads a sector at the specified address on the SD Card.
{
81141c28:	defffa04 	addi	sp,sp,-24
81141c2c:	de00012e 	bgeu	sp,et,81141c34 <Read_Sector_Data+0xc>
81141c30:	003b68fa 	trap	3
81141c34:	dfc00515 	stw	ra,20(sp)
81141c38:	df000415 	stw	fp,16(sp)
81141c3c:	df000404 	addi	fp,sp,16
81141c40:	e13ffe15 	stw	r4,-8(fp)
81141c44:	e17fff15 	stw	r5,-4(fp)
	bool result = false;
81141c48:	e03ffc15 	stw	zero,-16(fp)
    
	if (alt_up_sd_card_is_Present())
81141c4c:	11449000 	call	81144900 <alt_up_sd_card_is_Present>
81141c50:	10002726 	beq	r2,zero,81141cf0 <Read_Sector_Data+0xc8>
	{
		short int reg_state = 0xff;
81141c54:	00803fc4 	movi	r2,255
81141c58:	e0bffd0d 	sth	r2,-12(fp)
        
        /* Write data to the SD card if the current buffer is out of date. */
        if (current_sector_modified)
81141c5c:	d0a0b417 	ldw	r2,-32048(gp)
81141c60:	10000726 	beq	r2,zero,81141c80 <Read_Sector_Data+0x58>
        {
            if (Write_Sector_Data(current_sector_index, 0) == false)
81141c64:	d0a0b517 	ldw	r2,-32044(gp)
81141c68:	000b883a 	mov	r5,zero
81141c6c:	1009883a 	mov	r4,r2
81141c70:	1141b180 	call	81141b18 <Write_Sector_Data>
81141c74:	1000021e 	bne	r2,zero,81141c80 <Read_Sector_Data+0x58>
            {
                return false;
81141c78:	0005883a 	mov	r2,zero
81141c7c:	00001d06 	br	81141cf4 <Read_Sector_Data+0xcc>
            }
        }
		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
		 * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
81141c80:	d0a0af17 	ldw	r2,-32068(gp)
81141c84:	e13ffe17 	ldw	r4,-8(fp)
81141c88:	e0ffff17 	ldw	r3,-4(fp)
81141c8c:	20c7883a 	add	r3,r4,r3
81141c90:	1806927a 	slli	r3,r3,9
81141c94:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_READ_BLOCK);
81141c98:	d0a0ae17 	ldw	r2,-32072(gp)
81141c9c:	00c00444 	movi	r3,17
81141ca0:	10c0002d 	sthio	r3,0(r2)
		do {
			reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
81141ca4:	d0a0ab17 	ldw	r2,-32084(gp)
81141ca8:	1080002b 	ldhuio	r2,0(r2)
81141cac:	10bfffcc 	andi	r2,r2,65535
81141cb0:	e0bffd0d 	sth	r2,-12(fp)
		} while ((reg_state & 0x04)!=0);
81141cb4:	e0bffd0b 	ldhu	r2,-12(fp)
81141cb8:	10bfffcc 	andi	r2,r2,65535
81141cbc:	1080010c 	andi	r2,r2,4
81141cc0:	103ff81e 	bne	r2,zero,81141ca4 <__reset+0xfb121ca4>
		// Make sure the request did not time out.
		if ((reg_state & 0x10) == 0)
81141cc4:	e0bffd0b 	ldhu	r2,-12(fp)
81141cc8:	10bfffcc 	andi	r2,r2,65535
81141ccc:	1080040c 	andi	r2,r2,16
81141cd0:	1000071e 	bne	r2,zero,81141cf0 <Read_Sector_Data+0xc8>
		{
			result = true;
81141cd4:	00800044 	movi	r2,1
81141cd8:	e0bffc15 	stw	r2,-16(fp)
            current_sector_modified = false;
81141cdc:	d020b415 	stw	zero,-32048(gp)
            current_sector_index = sector_index+partition_offset;
81141ce0:	e0fffe17 	ldw	r3,-8(fp)
81141ce4:	e0bfff17 	ldw	r2,-4(fp)
81141ce8:	1885883a 	add	r2,r3,r2
81141cec:	d0a0b515 	stw	r2,-32044(gp)
		}
	}
	return result;
81141cf0:	e0bffc17 	ldw	r2,-16(fp)
}
81141cf4:	e037883a 	mov	sp,fp
81141cf8:	dfc00117 	ldw	ra,4(sp)
81141cfc:	df000017 	ldw	fp,0(sp)
81141d00:	dec00204 	addi	sp,sp,8
81141d04:	f800283a 	ret

81141d08 <get_cluster_flag>:


bool get_cluster_flag(unsigned int cluster_index, unsigned short int *flag)
// Read a cluster flag.
{
81141d08:	defffb04 	addi	sp,sp,-20
81141d0c:	de00012e 	bgeu	sp,et,81141d14 <get_cluster_flag+0xc>
81141d10:	003b68fa 	trap	3
81141d14:	dfc00415 	stw	ra,16(sp)
81141d18:	df000315 	stw	fp,12(sp)
81141d1c:	df000304 	addi	fp,sp,12
81141d20:	e13ffe15 	stw	r4,-8(fp)
81141d24:	e17fff15 	stw	r5,-4(fp)
    unsigned int sector_index = (cluster_index / 256) + fat_partition_offset_in_512_byte_sectors;
81141d28:	e0bffe17 	ldw	r2,-8(fp)
81141d2c:	1004d23a 	srli	r2,r2,8
81141d30:	d0e0b117 	ldw	r3,-32060(gp)
81141d34:	10c5883a 	add	r2,r2,r3
81141d38:	e0bffd15 	stw	r2,-12(fp)
    
    sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
81141d3c:	00a045f4 	movhi	r2,33047
81141d40:	10b20e04 	addi	r2,r2,-14280
81141d44:	10801117 	ldw	r2,68(r2)
81141d48:	e0fffd17 	ldw	r3,-12(fp)
81141d4c:	1885883a 	add	r2,r3,r2
81141d50:	e0bffd15 	stw	r2,-12(fp)
     
    if (sector_index != current_sector_index)
81141d54:	d0a0b517 	ldw	r2,-32044(gp)
81141d58:	e0fffd17 	ldw	r3,-12(fp)
81141d5c:	18800726 	beq	r3,r2,81141d7c <get_cluster_flag+0x74>
    {
        if (Read_Sector_Data(sector_index, 0) == false)
81141d60:	e0bffd17 	ldw	r2,-12(fp)
81141d64:	000b883a 	mov	r5,zero
81141d68:	1009883a 	mov	r4,r2
81141d6c:	1141c280 	call	81141c28 <Read_Sector_Data>
81141d70:	1000021e 	bne	r2,zero,81141d7c <get_cluster_flag+0x74>
        {
            return false;
81141d74:	0005883a 	mov	r2,zero
81141d78:	00000d06 	br	81141db0 <get_cluster_flag+0xa8>
        }
    }
    *flag = (unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256));
81141d7c:	e0bffe17 	ldw	r2,-8(fp)
81141d80:	10803fcc 	andi	r2,r2,255
81141d84:	1085883a 	add	r2,r2,r2
81141d88:	1007883a 	mov	r3,r2
81141d8c:	d0a0b317 	ldw	r2,-32052(gp)
81141d90:	10800a17 	ldw	r2,40(r2)
81141d94:	1885883a 	add	r2,r3,r2
81141d98:	1080002b 	ldhuio	r2,0(r2)
81141d9c:	10bfffcc 	andi	r2,r2,65535
81141da0:	1007883a 	mov	r3,r2
81141da4:	e0bfff17 	ldw	r2,-4(fp)
81141da8:	10c0000d 	sth	r3,0(r2)
    return true;
81141dac:	00800044 	movi	r2,1
}
81141db0:	e037883a 	mov	sp,fp
81141db4:	dfc00117 	ldw	ra,4(sp)
81141db8:	df000017 	ldw	fp,0(sp)
81141dbc:	dec00204 	addi	sp,sp,8
81141dc0:	f800283a 	ret

81141dc4 <mark_cluster>:


bool mark_cluster(unsigned int cluster_index, short int flag, bool first_fat)
// Place a marker on the specified cluster in a given FAT.
{
81141dc4:	defffa04 	addi	sp,sp,-24
81141dc8:	de00012e 	bgeu	sp,et,81141dd0 <mark_cluster+0xc>
81141dcc:	003b68fa 	trap	3
81141dd0:	dfc00515 	stw	ra,20(sp)
81141dd4:	df000415 	stw	fp,16(sp)
81141dd8:	df000404 	addi	fp,sp,16
81141ddc:	e13ffd15 	stw	r4,-12(fp)
81141de0:	2805883a 	mov	r2,r5
81141de4:	e1bfff15 	stw	r6,-4(fp)
81141de8:	e0bffe0d 	sth	r2,-8(fp)
    unsigned int sector_index = (cluster_index / 256) +  fat_partition_offset_in_512_byte_sectors;
81141dec:	e0bffd17 	ldw	r2,-12(fp)
81141df0:	1004d23a 	srli	r2,r2,8
81141df4:	d0e0b117 	ldw	r3,-32060(gp)
81141df8:	10c5883a 	add	r2,r2,r3
81141dfc:	e0bffc15 	stw	r2,-16(fp)
    
    if (first_fat)
81141e00:	e0bfff17 	ldw	r2,-4(fp)
81141e04:	10000726 	beq	r2,zero,81141e24 <mark_cluster+0x60>
    {
        sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
81141e08:	00a045f4 	movhi	r2,33047
81141e0c:	10b20e04 	addi	r2,r2,-14280
81141e10:	10801117 	ldw	r2,68(r2)
81141e14:	e0fffc17 	ldw	r3,-16(fp)
81141e18:	1885883a 	add	r2,r3,r2
81141e1c:	e0bffc15 	stw	r2,-16(fp)
81141e20:	00000606 	br	81141e3c <mark_cluster+0x78>
    }
    else
    {
        sector_index  = sector_index + boot_sector_data.second_fat_sector_offset;
81141e24:	00a045f4 	movhi	r2,33047
81141e28:	10b20e04 	addi	r2,r2,-14280
81141e2c:	10801217 	ldw	r2,72(r2)
81141e30:	e0fffc17 	ldw	r3,-16(fp)
81141e34:	1885883a 	add	r2,r3,r2
81141e38:	e0bffc15 	stw	r2,-16(fp)
    }
     
    if (sector_index != current_sector_index)
81141e3c:	d0a0b517 	ldw	r2,-32044(gp)
81141e40:	e0fffc17 	ldw	r3,-16(fp)
81141e44:	18800726 	beq	r3,r2,81141e64 <mark_cluster+0xa0>
    {
        if (Read_Sector_Data(sector_index, 0) == false)
81141e48:	e0bffc17 	ldw	r2,-16(fp)
81141e4c:	000b883a 	mov	r5,zero
81141e50:	1009883a 	mov	r4,r2
81141e54:	1141c280 	call	81141c28 <Read_Sector_Data>
81141e58:	1000021e 	bne	r2,zero,81141e64 <mark_cluster+0xa0>
        {
            return false;
81141e5c:	0005883a 	mov	r2,zero
81141e60:	00000d06 	br	81141e98 <mark_cluster+0xd4>
        }
    }
    IOWR_16DIRECT(device_pointer->base, 2*(cluster_index % 256), flag);
81141e64:	e0bffd17 	ldw	r2,-12(fp)
81141e68:	10803fcc 	andi	r2,r2,255
81141e6c:	1085883a 	add	r2,r2,r2
81141e70:	1007883a 	mov	r3,r2
81141e74:	d0a0b317 	ldw	r2,-32052(gp)
81141e78:	10800a17 	ldw	r2,40(r2)
81141e7c:	1885883a 	add	r2,r3,r2
81141e80:	1007883a 	mov	r3,r2
81141e84:	e0bffe0f 	ldh	r2,-8(fp)
81141e88:	1880002d 	sthio	r2,0(r3)
    current_sector_modified = true;
81141e8c:	00800044 	movi	r2,1
81141e90:	d0a0b415 	stw	r2,-32048(gp)
    return true;
81141e94:	00800044 	movi	r2,1
}
81141e98:	e037883a 	mov	sp,fp
81141e9c:	dfc00117 	ldw	ra,4(sp)
81141ea0:	df000017 	ldw	fp,0(sp)
81141ea4:	dec00204 	addi	sp,sp,8
81141ea8:	f800283a 	ret

81141eac <Check_for_Master_Boot_Record>:

bool Check_for_Master_Boot_Record(void)
// This function reads the first 512 bytes on the SD Card. This data should
// contain the Master Boot Record. If it does, then print
// relevant information and return true. Otherwise, return false. 
{
81141eac:	defff704 	addi	sp,sp,-36
81141eb0:	de00012e 	bgeu	sp,et,81141eb8 <Check_for_Master_Boot_Record+0xc>
81141eb4:	003b68fa 	trap	3
81141eb8:	dfc00815 	stw	ra,32(sp)
81141ebc:	df000715 	stw	fp,28(sp)
81141ec0:	df000704 	addi	fp,sp,28
	bool result = false;
81141ec4:	e03ff915 	stw	zero,-28(fp)
	int index;
	int end, offset, partition_size;

	/* Load the first 512 bytes of data from SD card. */
	if (Read_Sector_Data(0, 0))
81141ec8:	000b883a 	mov	r5,zero
81141ecc:	0009883a 	mov	r4,zero
81141ed0:	1141c280 	call	81141c28 <Read_Sector_Data>
81141ed4:	10005a26 	beq	r2,zero,81142040 <Check_for_Master_Boot_Record+0x194>
	{
		end =  (short int) IORD_16DIRECT(device_pointer->base,0x1fe);
81141ed8:	d0a0b317 	ldw	r2,-32052(gp)
81141edc:	10800a17 	ldw	r2,40(r2)
81141ee0:	10807f84 	addi	r2,r2,510
81141ee4:	1080002b 	ldhuio	r2,0(r2)
81141ee8:	10bfffcc 	andi	r2,r2,65535
81141eec:	10bfffcc 	andi	r2,r2,65535
81141ef0:	10a0001c 	xori	r2,r2,32768
81141ef4:	10a00004 	addi	r2,r2,-32768
81141ef8:	e0bffb15 	stw	r2,-20(fp)

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
81141efc:	e0bffb17 	ldw	r2,-20(fp)
81141f00:	10ffffcc 	andi	r3,r2,65535
81141f04:	00aa9554 	movui	r2,43605
81141f08:	18804d1e 	bne	r3,r2,81142040 <Check_for_Master_Boot_Record+0x194>
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
81141f0c:	e03ffa15 	stw	zero,-24(fp)
81141f10:	00004806 	br	81142034 <Check_for_Master_Boot_Record+0x188>
			{
				int partition_data_offset = (index * 16) + 0x01be;
81141f14:	e0bffa17 	ldw	r2,-24(fp)
81141f18:	1004913a 	slli	r2,r2,4
81141f1c:	10806f84 	addi	r2,r2,446
81141f20:	e0bffc15 	stw	r2,-16(fp)
				char type;
		        
				// Read Partition type
				type = (unsigned char) IORD_8DIRECT(device_pointer->base,partition_data_offset + 0x04);
81141f24:	d0a0b317 	ldw	r2,-32052(gp)
81141f28:	10c00a17 	ldw	r3,40(r2)
81141f2c:	e0bffc17 	ldw	r2,-16(fp)
81141f30:	1885883a 	add	r2,r3,r2
81141f34:	10800104 	addi	r2,r2,4
81141f38:	10800023 	ldbuio	r2,0(r2)
81141f3c:	10803fcc 	andi	r2,r2,255
81141f40:	e0bffd05 	stb	r2,-12(fp)

				// Check if this is an FAT parition
				if ((type == 1) || (type == 4) || (type == 6) || (type == 14))
81141f44:	e0bffd07 	ldb	r2,-12(fp)
81141f48:	10800060 	cmpeqi	r2,r2,1
81141f4c:	1000091e 	bne	r2,zero,81141f74 <Check_for_Master_Boot_Record+0xc8>
81141f50:	e0bffd07 	ldb	r2,-12(fp)
81141f54:	10800120 	cmpeqi	r2,r2,4
81141f58:	1000061e 	bne	r2,zero,81141f74 <Check_for_Master_Boot_Record+0xc8>
81141f5c:	e0bffd07 	ldb	r2,-12(fp)
81141f60:	108001a0 	cmpeqi	r2,r2,6
81141f64:	1000031e 	bne	r2,zero,81141f74 <Check_for_Master_Boot_Record+0xc8>
81141f68:	e0bffd07 	ldb	r2,-12(fp)
81141f6c:	10800398 	cmpnei	r2,r2,14
81141f70:	10002d1e 	bne	r2,zero,81142028 <Check_for_Master_Boot_Record+0x17c>
				{
					// Get partition offset and size.
					offset = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0A)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x08));
81141f74:	d0a0b317 	ldw	r2,-32052(gp)
81141f78:	10c00a17 	ldw	r3,40(r2)
81141f7c:	e0bffc17 	ldw	r2,-16(fp)
81141f80:	1885883a 	add	r2,r3,r2
81141f84:	10800284 	addi	r2,r2,10
81141f88:	1080002b 	ldhuio	r2,0(r2)
81141f8c:	10bfffcc 	andi	r2,r2,65535
81141f90:	1006943a 	slli	r3,r2,16
81141f94:	d0a0b317 	ldw	r2,-32052(gp)
81141f98:	11000a17 	ldw	r4,40(r2)
81141f9c:	e0bffc17 	ldw	r2,-16(fp)
81141fa0:	2085883a 	add	r2,r4,r2
81141fa4:	10800204 	addi	r2,r2,8
81141fa8:	1080002b 	ldhuio	r2,0(r2)
81141fac:	10bfffcc 	andi	r2,r2,65535
81141fb0:	10bfffcc 	andi	r2,r2,65535
81141fb4:	1884b03a 	or	r2,r3,r2
81141fb8:	e0bffe15 	stw	r2,-8(fp)
					partition_size = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0E)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0C));
81141fbc:	d0a0b317 	ldw	r2,-32052(gp)
81141fc0:	10c00a17 	ldw	r3,40(r2)
81141fc4:	e0bffc17 	ldw	r2,-16(fp)
81141fc8:	1885883a 	add	r2,r3,r2
81141fcc:	10800384 	addi	r2,r2,14
81141fd0:	1080002b 	ldhuio	r2,0(r2)
81141fd4:	10bfffcc 	andi	r2,r2,65535
81141fd8:	1006943a 	slli	r3,r2,16
81141fdc:	d0a0b317 	ldw	r2,-32052(gp)
81141fe0:	11000a17 	ldw	r4,40(r2)
81141fe4:	e0bffc17 	ldw	r2,-16(fp)
81141fe8:	2085883a 	add	r2,r4,r2
81141fec:	10800304 	addi	r2,r2,12
81141ff0:	1080002b 	ldhuio	r2,0(r2)
81141ff4:	10bfffcc 	andi	r2,r2,65535
81141ff8:	10bfffcc 	andi	r2,r2,65535
81141ffc:	1884b03a 	or	r2,r3,r2
81142000:	e0bfff15 	stw	r2,-4(fp)
		            
					// Check if the partition is valid
					if (partition_size > 0)
81142004:	e0bfff17 	ldw	r2,-4(fp)
81142008:	0080070e 	bge	zero,r2,81142028 <Check_for_Master_Boot_Record+0x17c>
					{
						result = true;
8114200c:	00800044 	movi	r2,1
81142010:	e0bff915 	stw	r2,-28(fp)
						fat_partition_size_in_512_byte_sectors = partition_size;
81142014:	e0bfff17 	ldw	r2,-4(fp)
81142018:	d0a0b215 	stw	r2,-32056(gp)
						fat_partition_offset_in_512_byte_sectors = offset;
8114201c:	e0bffe17 	ldw	r2,-8(fp)
81142020:	d0a0b115 	stw	r2,-32060(gp)
						break;
81142024:	00000606 	br	81142040 <Check_for_Master_Boot_Record+0x194>

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
81142028:	e0bffa17 	ldw	r2,-24(fp)
8114202c:	10800044 	addi	r2,r2,1
81142030:	e0bffa15 	stw	r2,-24(fp)
81142034:	e0bffa17 	ldw	r2,-24(fp)
81142038:	10800110 	cmplti	r2,r2,4
8114203c:	103fb51e 	bne	r2,zero,81141f14 <__reset+0xfb121f14>
				}
			}
		}
	}

	return result;
81142040:	e0bff917 	ldw	r2,-28(fp)
}
81142044:	e037883a 	mov	sp,fp
81142048:	dfc00117 	ldw	ra,4(sp)
8114204c:	df000017 	ldw	fp,0(sp)
81142050:	dec00204 	addi	sp,sp,8
81142054:	f800283a 	ret

81142058 <Read_File_Record_At_Offset>:


bool Read_File_Record_At_Offset(int offset, t_file_record *record, unsigned int cluster_index, unsigned int sector_in_cluster)
// This function reads a file record
{
81142058:	defff804 	addi	sp,sp,-32
8114205c:	de00012e 	bgeu	sp,et,81142064 <Read_File_Record_At_Offset+0xc>
81142060:	003b68fa 	trap	3
81142064:	dfc00715 	stw	ra,28(sp)
81142068:	df000615 	stw	fp,24(sp)
8114206c:	df000604 	addi	fp,sp,24
81142070:	e13ffc15 	stw	r4,-16(fp)
81142074:	e17ffd15 	stw	r5,-12(fp)
81142078:	e1bffe15 	stw	r6,-8(fp)
8114207c:	e1ffff15 	stw	r7,-4(fp)
	bool result = false;
81142080:	e03ffa15 	stw	zero,-24(fp)
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81142084:	e0bffc17 	ldw	r2,-16(fp)
81142088:	108007cc 	andi	r2,r2,31
8114208c:	10008d1e 	bne	r2,zero,811422c4 <Read_File_Record_At_Offset+0x26c>
81142090:	11449000 	call	81144900 <alt_up_sd_card_is_Present>
81142094:	10008b26 	beq	r2,zero,811422c4 <Read_File_Record_At_Offset+0x26c>
81142098:	d0a0aa17 	ldw	r2,-32088(gp)
8114209c:	10008926 	beq	r2,zero,811422c4 <Read_File_Record_At_Offset+0x26c>
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
811420a0:	e03ffb15 	stw	zero,-20(fp)
811420a4:	00001106 	br	811420ec <Read_File_Record_At_Offset+0x94>
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
811420a8:	e0fffc17 	ldw	r3,-16(fp)
811420ac:	e0bffb17 	ldw	r2,-20(fp)
811420b0:	1885883a 	add	r2,r3,r2
811420b4:	1007883a 	mov	r3,r2
811420b8:	d0a0b317 	ldw	r2,-32052(gp)
811420bc:	10800a17 	ldw	r2,40(r2)
811420c0:	1885883a 	add	r2,r3,r2
811420c4:	10800023 	ldbuio	r2,0(r2)
811420c8:	10803fcc 	andi	r2,r2,255
811420cc:	1009883a 	mov	r4,r2
811420d0:	e0fffd17 	ldw	r3,-12(fp)
811420d4:	e0bffb17 	ldw	r2,-20(fp)
811420d8:	1885883a 	add	r2,r3,r2
811420dc:	11000005 	stb	r4,0(r2)
	bool result = false;
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
811420e0:	e0bffb17 	ldw	r2,-20(fp)
811420e4:	10800044 	addi	r2,r2,1
811420e8:	e0bffb15 	stw	r2,-20(fp)
811420ec:	e0bffb17 	ldw	r2,-20(fp)
811420f0:	10800210 	cmplti	r2,r2,8
811420f4:	103fec1e 	bne	r2,zero,811420a8 <__reset+0xfb1220a8>
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
811420f8:	e03ffb15 	stw	zero,-20(fp)
811420fc:	00001306 	br	8114214c <Read_File_Record_At_Offset+0xf4>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
81142100:	e0fffc17 	ldw	r3,-16(fp)
81142104:	e0bffb17 	ldw	r2,-20(fp)
81142108:	1885883a 	add	r2,r3,r2
8114210c:	1007883a 	mov	r3,r2
81142110:	d0a0b317 	ldw	r2,-32052(gp)
81142114:	10800a17 	ldw	r2,40(r2)
81142118:	1885883a 	add	r2,r3,r2
8114211c:	10800204 	addi	r2,r2,8
81142120:	10800023 	ldbuio	r2,0(r2)
81142124:	10803fcc 	andi	r2,r2,255
81142128:	1009883a 	mov	r4,r2
8114212c:	e0fffd17 	ldw	r3,-12(fp)
81142130:	e0bffb17 	ldw	r2,-20(fp)
81142134:	1885883a 	add	r2,r3,r2
81142138:	10800204 	addi	r2,r2,8
8114213c:	11000005 	stb	r4,0(r2)

		for (counter = 0; counter < 8; counter++)
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
81142140:	e0bffb17 	ldw	r2,-20(fp)
81142144:	10800044 	addi	r2,r2,1
81142148:	e0bffb15 	stw	r2,-20(fp)
8114214c:	e0bffb17 	ldw	r2,-20(fp)
81142150:	108000d0 	cmplti	r2,r2,3
81142154:	103fea1e 	bne	r2,zero,81142100 <__reset+0xfb122100>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
		}        
		record->attributes          =   (char) IORD_8DIRECT(device_pointer->base, offset+11);
81142158:	d0a0b317 	ldw	r2,-32052(gp)
8114215c:	10c00a17 	ldw	r3,40(r2)
81142160:	e0bffc17 	ldw	r2,-16(fp)
81142164:	1885883a 	add	r2,r3,r2
81142168:	108002c4 	addi	r2,r2,11
8114216c:	10800023 	ldbuio	r2,0(r2)
81142170:	10803fcc 	andi	r2,r2,255
81142174:	1007883a 	mov	r3,r2
81142178:	e0bffd17 	ldw	r2,-12(fp)
8114217c:	10c002c5 	stb	r3,11(r2)
		/* Ignore reserved bytes at locations 12 and 13. */
		record->create_time         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+14);
81142180:	d0a0b317 	ldw	r2,-32052(gp)
81142184:	10c00a17 	ldw	r3,40(r2)
81142188:	e0bffc17 	ldw	r2,-16(fp)
8114218c:	1885883a 	add	r2,r3,r2
81142190:	10800384 	addi	r2,r2,14
81142194:	1080002b 	ldhuio	r2,0(r2)
81142198:	10bfffcc 	andi	r2,r2,65535
8114219c:	1007883a 	mov	r3,r2
811421a0:	e0bffd17 	ldw	r2,-12(fp)
811421a4:	10c0030d 	sth	r3,12(r2)
		record->create_date         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+16);
811421a8:	d0a0b317 	ldw	r2,-32052(gp)
811421ac:	10c00a17 	ldw	r3,40(r2)
811421b0:	e0bffc17 	ldw	r2,-16(fp)
811421b4:	1885883a 	add	r2,r3,r2
811421b8:	10800404 	addi	r2,r2,16
811421bc:	1080002b 	ldhuio	r2,0(r2)
811421c0:	10bfffcc 	andi	r2,r2,65535
811421c4:	1007883a 	mov	r3,r2
811421c8:	e0bffd17 	ldw	r2,-12(fp)
811421cc:	10c0038d 	sth	r3,14(r2)
		record->last_access_date    =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+18);
811421d0:	d0a0b317 	ldw	r2,-32052(gp)
811421d4:	10c00a17 	ldw	r3,40(r2)
811421d8:	e0bffc17 	ldw	r2,-16(fp)
811421dc:	1885883a 	add	r2,r3,r2
811421e0:	10800484 	addi	r2,r2,18
811421e4:	1080002b 	ldhuio	r2,0(r2)
811421e8:	10bfffcc 	andi	r2,r2,65535
811421ec:	1007883a 	mov	r3,r2
811421f0:	e0bffd17 	ldw	r2,-12(fp)
811421f4:	10c0040d 	sth	r3,16(r2)
		/* Ignore reserved bytes at locations 20 and 21. */
		record->last_modified_time  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+22);
811421f8:	d0a0b317 	ldw	r2,-32052(gp)
811421fc:	10c00a17 	ldw	r3,40(r2)
81142200:	e0bffc17 	ldw	r2,-16(fp)
81142204:	1885883a 	add	r2,r3,r2
81142208:	10800584 	addi	r2,r2,22
8114220c:	1080002b 	ldhuio	r2,0(r2)
81142210:	10bfffcc 	andi	r2,r2,65535
81142214:	1007883a 	mov	r3,r2
81142218:	e0bffd17 	ldw	r2,-12(fp)
8114221c:	10c0048d 	sth	r3,18(r2)
		record->last_modified_date  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+24);
81142220:	d0a0b317 	ldw	r2,-32052(gp)
81142224:	10c00a17 	ldw	r3,40(r2)
81142228:	e0bffc17 	ldw	r2,-16(fp)
8114222c:	1885883a 	add	r2,r3,r2
81142230:	10800604 	addi	r2,r2,24
81142234:	1080002b 	ldhuio	r2,0(r2)
81142238:	10bfffcc 	andi	r2,r2,65535
8114223c:	1007883a 	mov	r3,r2
81142240:	e0bffd17 	ldw	r2,-12(fp)
81142244:	10c0050d 	sth	r3,20(r2)
		record->start_cluster_index =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+26);
81142248:	d0a0b317 	ldw	r2,-32052(gp)
8114224c:	10c00a17 	ldw	r3,40(r2)
81142250:	e0bffc17 	ldw	r2,-16(fp)
81142254:	1885883a 	add	r2,r3,r2
81142258:	10800684 	addi	r2,r2,26
8114225c:	1080002b 	ldhuio	r2,0(r2)
81142260:	10bfffcc 	andi	r2,r2,65535
81142264:	1007883a 	mov	r3,r2
81142268:	e0bffd17 	ldw	r2,-12(fp)
8114226c:	10c0058d 	sth	r3,22(r2)
		record->file_size_in_bytes  =	(unsigned int) IORD_32DIRECT(device_pointer->base, offset+28);
81142270:	d0a0b317 	ldw	r2,-32052(gp)
81142274:	10c00a17 	ldw	r3,40(r2)
81142278:	e0bffc17 	ldw	r2,-16(fp)
8114227c:	1885883a 	add	r2,r3,r2
81142280:	10800704 	addi	r2,r2,28
81142284:	10800037 	ldwio	r2,0(r2)
81142288:	1007883a 	mov	r3,r2
8114228c:	e0bffd17 	ldw	r2,-12(fp)
81142290:	10c00615 	stw	r3,24(r2)
		record->file_record_cluster = cluster_index;
81142294:	e0bffd17 	ldw	r2,-12(fp)
81142298:	e0fffe17 	ldw	r3,-8(fp)
8114229c:	10c00a15 	stw	r3,40(r2)
		record->file_record_sector_in_cluster = sector_in_cluster;
811422a0:	e0bffd17 	ldw	r2,-12(fp)
811422a4:	e0ffff17 	ldw	r3,-4(fp)
811422a8:	10c00b15 	stw	r3,44(r2)
		record->file_record_offset = offset;
811422ac:	e0bffc17 	ldw	r2,-16(fp)
811422b0:	1007883a 	mov	r3,r2
811422b4:	e0bffd17 	ldw	r2,-12(fp)
811422b8:	10c00c0d 	sth	r3,48(r2)
		result = true;
811422bc:	00800044 	movi	r2,1
811422c0:	e0bffa15 	stw	r2,-24(fp)
	}
	return result;
811422c4:	e0bffa17 	ldw	r2,-24(fp)
}
811422c8:	e037883a 	mov	sp,fp
811422cc:	dfc00117 	ldw	ra,4(sp)
811422d0:	df000017 	ldw	fp,0(sp)
811422d4:	dec00204 	addi	sp,sp,8
811422d8:	f800283a 	ret

811422dc <Write_File_Record_At_Offset>:


bool Write_File_Record_At_Offset(int offset, t_file_record *record)
// This function writes a file record at a given offset. The offset is given in bytes.
{
811422dc:	defff904 	addi	sp,sp,-28
811422e0:	de00012e 	bgeu	sp,et,811422e8 <Write_File_Record_At_Offset+0xc>
811422e4:	003b68fa 	trap	3
811422e8:	dfc00615 	stw	ra,24(sp)
811422ec:	df000515 	stw	fp,20(sp)
811422f0:	df000504 	addi	fp,sp,20
811422f4:	e13ffe15 	stw	r4,-8(fp)
811422f8:	e17fff15 	stw	r5,-4(fp)
    bool result = false;
811422fc:	e03ffb15 	stw	zero,-20(fp)
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81142300:	e0bffe17 	ldw	r2,-8(fp)
81142304:	108007cc 	andi	r2,r2,31
81142308:	1000931e 	bne	r2,zero,81142558 <Write_File_Record_At_Offset+0x27c>
8114230c:	11449000 	call	81144900 <alt_up_sd_card_is_Present>
81142310:	10009126 	beq	r2,zero,81142558 <Write_File_Record_At_Offset+0x27c>
81142314:	d0a0aa17 	ldw	r2,-32088(gp)
81142318:	10008f26 	beq	r2,zero,81142558 <Write_File_Record_At_Offset+0x27c>
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
8114231c:	e03ffc15 	stw	zero,-16(fp)
81142320:	00001f06 	br	811423a0 <Write_File_Record_At_Offset+0xc4>
        {
            short int two_chars = (short int) record->name[counter+1];
81142324:	e0bffc17 	ldw	r2,-16(fp)
81142328:	10800044 	addi	r2,r2,1
8114232c:	e0ffff17 	ldw	r3,-4(fp)
81142330:	1885883a 	add	r2,r3,r2
81142334:	10800003 	ldbu	r2,0(r2)
81142338:	10803fcc 	andi	r2,r2,255
8114233c:	e0bffd0d 	sth	r2,-12(fp)
            two_chars = two_chars << 8;
81142340:	e0bffd0f 	ldh	r2,-12(fp)
81142344:	1004923a 	slli	r2,r2,8
81142348:	e0bffd0d 	sth	r2,-12(fp)
            two_chars = two_chars | record->name[counter];
8114234c:	e0ffff17 	ldw	r3,-4(fp)
81142350:	e0bffc17 	ldw	r2,-16(fp)
81142354:	1885883a 	add	r2,r3,r2
81142358:	10800003 	ldbu	r2,0(r2)
8114235c:	10c03fcc 	andi	r3,r2,255
81142360:	e0bffd0b 	ldhu	r2,-12(fp)
81142364:	1884b03a 	or	r2,r3,r2
81142368:	e0bffd0d 	sth	r2,-12(fp)
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
8114236c:	e0fffe17 	ldw	r3,-8(fp)
81142370:	e0bffc17 	ldw	r2,-16(fp)
81142374:	1885883a 	add	r2,r3,r2
81142378:	1007883a 	mov	r3,r2
8114237c:	d0a0b317 	ldw	r2,-32052(gp)
81142380:	10800a17 	ldw	r2,40(r2)
81142384:	1885883a 	add	r2,r3,r2
81142388:	1007883a 	mov	r3,r2
8114238c:	e0bffd0f 	ldh	r2,-12(fp)
81142390:	1880002d 	sthio	r2,0(r3)
    bool result = false;
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
81142394:	e0bffc17 	ldw	r2,-16(fp)
81142398:	10800084 	addi	r2,r2,2
8114239c:	e0bffc15 	stw	r2,-16(fp)
811423a0:	e0bffc17 	ldw	r2,-16(fp)
811423a4:	10800210 	cmplti	r2,r2,8
811423a8:	103fde1e 	bne	r2,zero,81142324 <__reset+0xfb122324>
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
811423ac:	e03ffc15 	stw	zero,-16(fp)
811423b0:	00001306 	br	81142400 <Write_File_Record_At_Offset+0x124>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
811423b4:	e0fffe17 	ldw	r3,-8(fp)
811423b8:	e0bffc17 	ldw	r2,-16(fp)
811423bc:	1885883a 	add	r2,r3,r2
811423c0:	1007883a 	mov	r3,r2
811423c4:	d0a0b317 	ldw	r2,-32052(gp)
811423c8:	10800a17 	ldw	r2,40(r2)
811423cc:	1885883a 	add	r2,r3,r2
811423d0:	10800204 	addi	r2,r2,8
811423d4:	1009883a 	mov	r4,r2
811423d8:	e0ffff17 	ldw	r3,-4(fp)
811423dc:	e0bffc17 	ldw	r2,-16(fp)
811423e0:	1885883a 	add	r2,r3,r2
811423e4:	10800204 	addi	r2,r2,8
811423e8:	10800003 	ldbu	r2,0(r2)
811423ec:	10803fcc 	andi	r2,r2,255
811423f0:	20800025 	stbio	r2,0(r4)
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
811423f4:	e0bffc17 	ldw	r2,-16(fp)
811423f8:	10800044 	addi	r2,r2,1
811423fc:	e0bffc15 	stw	r2,-16(fp)
81142400:	e0bffc17 	ldw	r2,-16(fp)
81142404:	108000d0 	cmplti	r2,r2,3
81142408:	103fea1e 	bne	r2,zero,811423b4 <__reset+0xfb1223b4>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
        }        
        IOWR_8DIRECT(device_pointer->base, offset+11, record->attributes);
8114240c:	d0a0b317 	ldw	r2,-32052(gp)
81142410:	10c00a17 	ldw	r3,40(r2)
81142414:	e0bffe17 	ldw	r2,-8(fp)
81142418:	1885883a 	add	r2,r3,r2
8114241c:	108002c4 	addi	r2,r2,11
81142420:	1007883a 	mov	r3,r2
81142424:	e0bfff17 	ldw	r2,-4(fp)
81142428:	108002c3 	ldbu	r2,11(r2)
8114242c:	10803fcc 	andi	r2,r2,255
81142430:	18800025 	stbio	r2,0(r3)
        /* Ignore reserved bytes at locations 12 and 13. */
        IOWR_16DIRECT(device_pointer->base, offset+14, record->create_time);
81142434:	d0a0b317 	ldw	r2,-32052(gp)
81142438:	10c00a17 	ldw	r3,40(r2)
8114243c:	e0bffe17 	ldw	r2,-8(fp)
81142440:	1885883a 	add	r2,r3,r2
81142444:	10800384 	addi	r2,r2,14
81142448:	1007883a 	mov	r3,r2
8114244c:	e0bfff17 	ldw	r2,-4(fp)
81142450:	1080030b 	ldhu	r2,12(r2)
81142454:	10bfffcc 	andi	r2,r2,65535
81142458:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+16, record->create_date);
8114245c:	d0a0b317 	ldw	r2,-32052(gp)
81142460:	10c00a17 	ldw	r3,40(r2)
81142464:	e0bffe17 	ldw	r2,-8(fp)
81142468:	1885883a 	add	r2,r3,r2
8114246c:	10800404 	addi	r2,r2,16
81142470:	1007883a 	mov	r3,r2
81142474:	e0bfff17 	ldw	r2,-4(fp)
81142478:	1080038b 	ldhu	r2,14(r2)
8114247c:	10bfffcc 	andi	r2,r2,65535
81142480:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+18, record->last_access_date);
81142484:	d0a0b317 	ldw	r2,-32052(gp)
81142488:	10c00a17 	ldw	r3,40(r2)
8114248c:	e0bffe17 	ldw	r2,-8(fp)
81142490:	1885883a 	add	r2,r3,r2
81142494:	10800484 	addi	r2,r2,18
81142498:	1007883a 	mov	r3,r2
8114249c:	e0bfff17 	ldw	r2,-4(fp)
811424a0:	1080040b 	ldhu	r2,16(r2)
811424a4:	10bfffcc 	andi	r2,r2,65535
811424a8:	1880002d 	sthio	r2,0(r3)
        /* Ignore reserved bytes at locations 20 and 21. */
        IOWR_16DIRECT(device_pointer->base, offset+22, record->last_modified_time);
811424ac:	d0a0b317 	ldw	r2,-32052(gp)
811424b0:	10c00a17 	ldw	r3,40(r2)
811424b4:	e0bffe17 	ldw	r2,-8(fp)
811424b8:	1885883a 	add	r2,r3,r2
811424bc:	10800584 	addi	r2,r2,22
811424c0:	1007883a 	mov	r3,r2
811424c4:	e0bfff17 	ldw	r2,-4(fp)
811424c8:	1080048b 	ldhu	r2,18(r2)
811424cc:	10bfffcc 	andi	r2,r2,65535
811424d0:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+24, record->last_modified_date);
811424d4:	d0a0b317 	ldw	r2,-32052(gp)
811424d8:	10c00a17 	ldw	r3,40(r2)
811424dc:	e0bffe17 	ldw	r2,-8(fp)
811424e0:	1885883a 	add	r2,r3,r2
811424e4:	10800604 	addi	r2,r2,24
811424e8:	1007883a 	mov	r3,r2
811424ec:	e0bfff17 	ldw	r2,-4(fp)
811424f0:	1080050b 	ldhu	r2,20(r2)
811424f4:	10bfffcc 	andi	r2,r2,65535
811424f8:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+26, record->start_cluster_index);
811424fc:	d0a0b317 	ldw	r2,-32052(gp)
81142500:	10c00a17 	ldw	r3,40(r2)
81142504:	e0bffe17 	ldw	r2,-8(fp)
81142508:	1885883a 	add	r2,r3,r2
8114250c:	10800684 	addi	r2,r2,26
81142510:	1007883a 	mov	r3,r2
81142514:	e0bfff17 	ldw	r2,-4(fp)
81142518:	1080058b 	ldhu	r2,22(r2)
8114251c:	10bfffcc 	andi	r2,r2,65535
81142520:	1880002d 	sthio	r2,0(r3)
        IOWR_32DIRECT(device_pointer->base, offset+28, record->file_size_in_bytes);
81142524:	d0a0b317 	ldw	r2,-32052(gp)
81142528:	10c00a17 	ldw	r3,40(r2)
8114252c:	e0bffe17 	ldw	r2,-8(fp)
81142530:	1885883a 	add	r2,r3,r2
81142534:	10800704 	addi	r2,r2,28
81142538:	1007883a 	mov	r3,r2
8114253c:	e0bfff17 	ldw	r2,-4(fp)
81142540:	10800617 	ldw	r2,24(r2)
81142544:	18800035 	stwio	r2,0(r3)
        current_sector_modified = true;                  
81142548:	00800044 	movi	r2,1
8114254c:	d0a0b415 	stw	r2,-32048(gp)
        result = true;
81142550:	00800044 	movi	r2,1
81142554:	e0bffb15 	stw	r2,-20(fp)
    }
    return result;
81142558:	e0bffb17 	ldw	r2,-20(fp)
}
8114255c:	e037883a 	mov	sp,fp
81142560:	dfc00117 	ldw	ra,4(sp)
81142564:	df000017 	ldw	fp,0(sp)
81142568:	dec00204 	addi	sp,sp,8
8114256c:	f800283a 	ret

81142570 <Check_for_DOS_FAT>:
// This function reads the boot sector for the FAT file system on the SD Card.
// The offset_address should point to the sector on the card where the boot sector is located.
// The sector number is specified either in the master Boot Record, or is 0 by default for a purely FAT
// based file system. If the specified sector contains a FAT boot sector, then this function prints the
// relevant information and returns 1. Otherwise, it returns 0. 
{
81142570:	defff904 	addi	sp,sp,-28
81142574:	de00012e 	bgeu	sp,et,8114257c <Check_for_DOS_FAT+0xc>
81142578:	003b68fa 	trap	3
8114257c:	dfc00615 	stw	ra,24(sp)
81142580:	df000515 	stw	fp,20(sp)
81142584:	df000504 	addi	fp,sp,20
81142588:	e13fff15 	stw	r4,-4(fp)
	bool result = false;
8114258c:	e03ffb15 	stw	zero,-20(fp)
	int counter = 0;
81142590:	e03ffc15 	stw	zero,-16(fp)
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
81142594:	e17fff17 	ldw	r5,-4(fp)
81142598:	0009883a 	mov	r4,zero
8114259c:	1141c280 	call	81141c28 <Read_Sector_Data>
811425a0:	e0bffb15 	stw	r2,-20(fp)
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
811425a4:	d0a0b317 	ldw	r2,-32052(gp)
811425a8:	10800a17 	ldw	r2,40(r2)
811425ac:	10807f84 	addi	r2,r2,510
811425b0:	1080002b 	ldhuio	r2,0(r2)
811425b4:	10bfffcc 	andi	r2,r2,65535
811425b8:	e0bffe0d 	sth	r2,-8(fp)
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
811425bc:	e0bffe0f 	ldh	r2,-8(fp)
811425c0:	10ffffcc 	andi	r3,r2,65535
811425c4:	00aa9554 	movui	r2,43605
811425c8:	1881841e 	bne	r3,r2,81142bdc <Check_for_DOS_FAT+0x66c>
811425cc:	e0bffb17 	ldw	r2,-20(fp)
811425d0:	10018226 	beq	r2,zero,81142bdc <Check_for_DOS_FAT+0x66c>
	{
		int num_clusters = 0;
811425d4:	e03ffd15 	stw	zero,-12(fp)

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
811425d8:	d0a0b317 	ldw	r2,-32052(gp)
811425dc:	10800a17 	ldw	r2,40(r2)
811425e0:	10800023 	ldbuio	r2,0(r2)
811425e4:	10803fcc 	andi	r2,r2,255
811425e8:	1007883a 	mov	r3,r2
811425ec:	00a045f4 	movhi	r2,33047
811425f0:	10b20e04 	addi	r2,r2,-14280
811425f4:	10c00005 	stb	r3,0(r2)
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
811425f8:	d0a0b317 	ldw	r2,-32052(gp)
811425fc:	10800a17 	ldw	r2,40(r2)
81142600:	10800044 	addi	r2,r2,1
81142604:	10800023 	ldbuio	r2,0(r2)
81142608:	10803fcc 	andi	r2,r2,255
8114260c:	1007883a 	mov	r3,r2
81142610:	00a045f4 	movhi	r2,33047
81142614:	10b20e04 	addi	r2,r2,-14280
81142618:	10c00045 	stb	r3,1(r2)
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
8114261c:	d0a0b317 	ldw	r2,-32052(gp)
81142620:	10800a17 	ldw	r2,40(r2)
81142624:	10800084 	addi	r2,r2,2
81142628:	10800023 	ldbuio	r2,0(r2)
8114262c:	10803fcc 	andi	r2,r2,255
81142630:	1007883a 	mov	r3,r2
81142634:	00a045f4 	movhi	r2,33047
81142638:	10b20e04 	addi	r2,r2,-14280
8114263c:	10c00085 	stb	r3,2(r2)
		for (counter = 0; counter < 8; counter++)
81142640:	e03ffc15 	stw	zero,-16(fp)
81142644:	00001106 	br	8114268c <Check_for_DOS_FAT+0x11c>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
81142648:	d0a0b317 	ldw	r2,-32052(gp)
8114264c:	10c00a17 	ldw	r3,40(r2)
81142650:	e0bffc17 	ldw	r2,-16(fp)
81142654:	1885883a 	add	r2,r3,r2
81142658:	108000c4 	addi	r2,r2,3
8114265c:	10800023 	ldbuio	r2,0(r2)
81142660:	10803fcc 	andi	r2,r2,255
81142664:	1009883a 	mov	r4,r2
81142668:	00a045f4 	movhi	r2,33047
8114266c:	10b20e04 	addi	r2,r2,-14280
81142670:	e0fffc17 	ldw	r3,-16(fp)
81142674:	10c5883a 	add	r2,r2,r3
81142678:	108000c4 	addi	r2,r2,3
8114267c:	11000005 	stb	r4,0(r2)
		int num_clusters = 0;

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
		for (counter = 0; counter < 8; counter++)
81142680:	e0bffc17 	ldw	r2,-16(fp)
81142684:	10800044 	addi	r2,r2,1
81142688:	e0bffc15 	stw	r2,-16(fp)
8114268c:	e0bffc17 	ldw	r2,-16(fp)
81142690:	10800210 	cmplti	r2,r2,8
81142694:	103fec1e 	bne	r2,zero,81142648 <__reset+0xfb122648>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
		}
		boot_sector_data.sector_size_in_bytes = (((unsigned char) IORD_8DIRECT(device_pointer->base, 12)) << 8 ) | ((char) IORD_8DIRECT(device_pointer->base, 11));
81142698:	d0a0b317 	ldw	r2,-32052(gp)
8114269c:	10800a17 	ldw	r2,40(r2)
811426a0:	10800304 	addi	r2,r2,12
811426a4:	10800023 	ldbuio	r2,0(r2)
811426a8:	10803fcc 	andi	r2,r2,255
811426ac:	1004923a 	slli	r2,r2,8
811426b0:	1007883a 	mov	r3,r2
811426b4:	d0a0b317 	ldw	r2,-32052(gp)
811426b8:	10800a17 	ldw	r2,40(r2)
811426bc:	108002c4 	addi	r2,r2,11
811426c0:	10800023 	ldbuio	r2,0(r2)
811426c4:	10803fcc 	andi	r2,r2,255
811426c8:	10803fcc 	andi	r2,r2,255
811426cc:	1080201c 	xori	r2,r2,128
811426d0:	10bfe004 	addi	r2,r2,-128
811426d4:	1884b03a 	or	r2,r3,r2
811426d8:	1007883a 	mov	r3,r2
811426dc:	00a045f4 	movhi	r2,33047
811426e0:	10b20e04 	addi	r2,r2,-14280
811426e4:	10c0030d 	sth	r3,12(r2)
		boot_sector_data.sectors_per_cluster = ((unsigned char) IORD_8DIRECT(device_pointer->base, 13));
811426e8:	d0a0b317 	ldw	r2,-32052(gp)
811426ec:	10800a17 	ldw	r2,40(r2)
811426f0:	10800344 	addi	r2,r2,13
811426f4:	10800023 	ldbuio	r2,0(r2)
811426f8:	10803fcc 	andi	r2,r2,255
811426fc:	1007883a 	mov	r3,r2
81142700:	00a045f4 	movhi	r2,33047
81142704:	10b20e04 	addi	r2,r2,-14280
81142708:	10c00385 	stb	r3,14(r2)
		boot_sector_data.reserved_sectors = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 14));
8114270c:	d0a0b317 	ldw	r2,-32052(gp)
81142710:	10800a17 	ldw	r2,40(r2)
81142714:	10800384 	addi	r2,r2,14
81142718:	1080002b 	ldhuio	r2,0(r2)
8114271c:	10bfffcc 	andi	r2,r2,65535
81142720:	1007883a 	mov	r3,r2
81142724:	00a045f4 	movhi	r2,33047
81142728:	10b20e04 	addi	r2,r2,-14280
8114272c:	10c0040d 	sth	r3,16(r2)
		boot_sector_data.number_of_FATs = ((unsigned char) IORD_8DIRECT(device_pointer->base, 16));
81142730:	d0a0b317 	ldw	r2,-32052(gp)
81142734:	10800a17 	ldw	r2,40(r2)
81142738:	10800404 	addi	r2,r2,16
8114273c:	10800023 	ldbuio	r2,0(r2)
81142740:	10803fcc 	andi	r2,r2,255
81142744:	1007883a 	mov	r3,r2
81142748:	00a045f4 	movhi	r2,33047
8114274c:	10b20e04 	addi	r2,r2,-14280
81142750:	10c00485 	stb	r3,18(r2)
		boot_sector_data.max_number_of_dir_entires = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 18)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 17));
81142754:	d0a0b317 	ldw	r2,-32052(gp)
81142758:	10800a17 	ldw	r2,40(r2)
8114275c:	10800484 	addi	r2,r2,18
81142760:	10800023 	ldbuio	r2,0(r2)
81142764:	10803fcc 	andi	r2,r2,255
81142768:	1004923a 	slli	r2,r2,8
8114276c:	1007883a 	mov	r3,r2
81142770:	d0a0b317 	ldw	r2,-32052(gp)
81142774:	10800a17 	ldw	r2,40(r2)
81142778:	10800444 	addi	r2,r2,17
8114277c:	10800023 	ldbuio	r2,0(r2)
81142780:	10803fcc 	andi	r2,r2,255
81142784:	10803fcc 	andi	r2,r2,255
81142788:	1884b03a 	or	r2,r3,r2
8114278c:	1007883a 	mov	r3,r2
81142790:	00a045f4 	movhi	r2,33047
81142794:	10b20e04 	addi	r2,r2,-14280
81142798:	10c0050d 	sth	r3,20(r2)
		boot_sector_data.number_of_sectors_in_partition = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 20)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 19));
8114279c:	d0a0b317 	ldw	r2,-32052(gp)
811427a0:	10800a17 	ldw	r2,40(r2)
811427a4:	10800504 	addi	r2,r2,20
811427a8:	10800023 	ldbuio	r2,0(r2)
811427ac:	10803fcc 	andi	r2,r2,255
811427b0:	1004923a 	slli	r2,r2,8
811427b4:	1007883a 	mov	r3,r2
811427b8:	d0a0b317 	ldw	r2,-32052(gp)
811427bc:	10800a17 	ldw	r2,40(r2)
811427c0:	108004c4 	addi	r2,r2,19
811427c4:	10800023 	ldbuio	r2,0(r2)
811427c8:	10803fcc 	andi	r2,r2,255
811427cc:	10803fcc 	andi	r2,r2,255
811427d0:	1884b03a 	or	r2,r3,r2
811427d4:	1007883a 	mov	r3,r2
811427d8:	00a045f4 	movhi	r2,33047
811427dc:	10b20e04 	addi	r2,r2,-14280
811427e0:	10c0058d 	sth	r3,22(r2)
		boot_sector_data.media_descriptor = ((unsigned char) IORD_8DIRECT(device_pointer->base, 21));
811427e4:	d0a0b317 	ldw	r2,-32052(gp)
811427e8:	10800a17 	ldw	r2,40(r2)
811427ec:	10800544 	addi	r2,r2,21
811427f0:	10800023 	ldbuio	r2,0(r2)
811427f4:	10803fcc 	andi	r2,r2,255
811427f8:	1007883a 	mov	r3,r2
811427fc:	00a045f4 	movhi	r2,33047
81142800:	10b20e04 	addi	r2,r2,-14280
81142804:	10c00605 	stb	r3,24(r2)
		boot_sector_data.number_of_sectors_per_table = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 22));
81142808:	d0a0b317 	ldw	r2,-32052(gp)
8114280c:	10800a17 	ldw	r2,40(r2)
81142810:	10800584 	addi	r2,r2,22
81142814:	1080002b 	ldhuio	r2,0(r2)
81142818:	10bfffcc 	andi	r2,r2,65535
8114281c:	1007883a 	mov	r3,r2
81142820:	00a045f4 	movhi	r2,33047
81142824:	10b20e04 	addi	r2,r2,-14280
81142828:	10c0068d 	sth	r3,26(r2)
		boot_sector_data.number_of_sectors_per_track = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 24));
8114282c:	d0a0b317 	ldw	r2,-32052(gp)
81142830:	10800a17 	ldw	r2,40(r2)
81142834:	10800604 	addi	r2,r2,24
81142838:	1080002b 	ldhuio	r2,0(r2)
8114283c:	10bfffcc 	andi	r2,r2,65535
81142840:	1007883a 	mov	r3,r2
81142844:	00a045f4 	movhi	r2,33047
81142848:	10b20e04 	addi	r2,r2,-14280
8114284c:	10c0070d 	sth	r3,28(r2)
		boot_sector_data.number_of_heads = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 26));
81142850:	d0a0b317 	ldw	r2,-32052(gp)
81142854:	10800a17 	ldw	r2,40(r2)
81142858:	10800684 	addi	r2,r2,26
8114285c:	1080002b 	ldhuio	r2,0(r2)
81142860:	10bfffcc 	andi	r2,r2,65535
81142864:	1007883a 	mov	r3,r2
81142868:	00a045f4 	movhi	r2,33047
8114286c:	10b20e04 	addi	r2,r2,-14280
81142870:	10c0078d 	sth	r3,30(r2)
		boot_sector_data.number_of_hidden_sectors = ((unsigned int) IORD_32DIRECT(device_pointer->base, 28));
81142874:	d0a0b317 	ldw	r2,-32052(gp)
81142878:	10800a17 	ldw	r2,40(r2)
8114287c:	10800704 	addi	r2,r2,28
81142880:	10800037 	ldwio	r2,0(r2)
81142884:	1007883a 	mov	r3,r2
81142888:	00a045f4 	movhi	r2,33047
8114288c:	10b20e04 	addi	r2,r2,-14280
81142890:	10c00815 	stw	r3,32(r2)
		boot_sector_data.total_sector_count_if_above_32MB = ((unsigned int) IORD_32DIRECT(device_pointer->base, 32));
81142894:	d0a0b317 	ldw	r2,-32052(gp)
81142898:	10800a17 	ldw	r2,40(r2)
8114289c:	10800804 	addi	r2,r2,32
811428a0:	10800037 	ldwio	r2,0(r2)
811428a4:	1007883a 	mov	r3,r2
811428a8:	00a045f4 	movhi	r2,33047
811428ac:	10b20e04 	addi	r2,r2,-14280
811428b0:	10c00915 	stw	r3,36(r2)
		boot_sector_data.drive_number = ((unsigned char) IORD_8DIRECT(device_pointer->base, 36));
811428b4:	d0a0b317 	ldw	r2,-32052(gp)
811428b8:	10800a17 	ldw	r2,40(r2)
811428bc:	10800904 	addi	r2,r2,36
811428c0:	10800023 	ldbuio	r2,0(r2)
811428c4:	10803fcc 	andi	r2,r2,255
811428c8:	1007883a 	mov	r3,r2
811428cc:	00a045f4 	movhi	r2,33047
811428d0:	10b20e04 	addi	r2,r2,-14280
811428d4:	10c00a05 	stb	r3,40(r2)
		boot_sector_data.current_head = ((unsigned char) IORD_8DIRECT(device_pointer->base, 37));
811428d8:	d0a0b317 	ldw	r2,-32052(gp)
811428dc:	10800a17 	ldw	r2,40(r2)
811428e0:	10800944 	addi	r2,r2,37
811428e4:	10800023 	ldbuio	r2,0(r2)
811428e8:	10803fcc 	andi	r2,r2,255
811428ec:	1007883a 	mov	r3,r2
811428f0:	00a045f4 	movhi	r2,33047
811428f4:	10b20e04 	addi	r2,r2,-14280
811428f8:	10c00a45 	stb	r3,41(r2)
		boot_sector_data.boot_signature = ((unsigned char) IORD_8DIRECT(device_pointer->base, 38));
811428fc:	d0a0b317 	ldw	r2,-32052(gp)
81142900:	10800a17 	ldw	r2,40(r2)
81142904:	10800984 	addi	r2,r2,38
81142908:	10800023 	ldbuio	r2,0(r2)
8114290c:	10803fcc 	andi	r2,r2,255
81142910:	1007883a 	mov	r3,r2
81142914:	00a045f4 	movhi	r2,33047
81142918:	10b20e04 	addi	r2,r2,-14280
8114291c:	10c00a85 	stb	r3,42(r2)
		boot_sector_data.first_fat_sector_offset = boot_sector_data.reserved_sectors;
81142920:	00a045f4 	movhi	r2,33047
81142924:	10b20e04 	addi	r2,r2,-14280
81142928:	1080040b 	ldhu	r2,16(r2)
8114292c:	10ffffcc 	andi	r3,r2,65535
81142930:	00a045f4 	movhi	r2,33047
81142934:	10b20e04 	addi	r2,r2,-14280
81142938:	10c01115 	stw	r3,68(r2)
		boot_sector_data.second_fat_sector_offset = boot_sector_data.first_fat_sector_offset + boot_sector_data.number_of_sectors_per_table;
8114293c:	00a045f4 	movhi	r2,33047
81142940:	10b20e04 	addi	r2,r2,-14280
81142944:	10c01117 	ldw	r3,68(r2)
81142948:	00a045f4 	movhi	r2,33047
8114294c:	10b20e04 	addi	r2,r2,-14280
81142950:	1080068b 	ldhu	r2,26(r2)
81142954:	10bfffcc 	andi	r2,r2,65535
81142958:	1887883a 	add	r3,r3,r2
8114295c:	00a045f4 	movhi	r2,33047
81142960:	10b20e04 	addi	r2,r2,-14280
81142964:	10c01215 	stw	r3,72(r2)
		boot_sector_data.root_directory_sector_offset = boot_sector_data.second_fat_sector_offset + boot_sector_data.number_of_sectors_per_table; 
81142968:	00a045f4 	movhi	r2,33047
8114296c:	10b20e04 	addi	r2,r2,-14280
81142970:	10c01217 	ldw	r3,72(r2)
81142974:	00a045f4 	movhi	r2,33047
81142978:	10b20e04 	addi	r2,r2,-14280
8114297c:	1080068b 	ldhu	r2,26(r2)
81142980:	10bfffcc 	andi	r2,r2,65535
81142984:	1887883a 	add	r3,r3,r2
81142988:	00a045f4 	movhi	r2,33047
8114298c:	10b20e04 	addi	r2,r2,-14280
81142990:	10c01315 	stw	r3,76(r2)
		boot_sector_data.data_sector_offset = boot_sector_data.root_directory_sector_offset + (32*boot_sector_data.max_number_of_dir_entires / boot_sector_data.sector_size_in_bytes);    
81142994:	00a045f4 	movhi	r2,33047
81142998:	10b20e04 	addi	r2,r2,-14280
8114299c:	10c01317 	ldw	r3,76(r2)
811429a0:	00a045f4 	movhi	r2,33047
811429a4:	10b20e04 	addi	r2,r2,-14280
811429a8:	1080050b 	ldhu	r2,20(r2)
811429ac:	10bfffcc 	andi	r2,r2,65535
811429b0:	1008917a 	slli	r4,r2,5
811429b4:	00a045f4 	movhi	r2,33047
811429b8:	10b20e04 	addi	r2,r2,-14280
811429bc:	1080030b 	ldhu	r2,12(r2)
811429c0:	10bfffcc 	andi	r2,r2,65535
811429c4:	2085283a 	div	r2,r4,r2
811429c8:	1887883a 	add	r3,r3,r2
811429cc:	00a045f4 	movhi	r2,33047
811429d0:	10b20e04 	addi	r2,r2,-14280
811429d4:	10c01415 	stw	r3,80(r2)
	    
		if (boot_sector_data.number_of_sectors_in_partition > 0)
811429d8:	00a045f4 	movhi	r2,33047
811429dc:	10b20e04 	addi	r2,r2,-14280
811429e0:	1080058b 	ldhu	r2,22(r2)
811429e4:	10bfffcc 	andi	r2,r2,65535
811429e8:	10000b26 	beq	r2,zero,81142a18 <Check_for_DOS_FAT+0x4a8>
		{
			num_clusters = (boot_sector_data.number_of_sectors_in_partition / boot_sector_data.sectors_per_cluster);
811429ec:	00a045f4 	movhi	r2,33047
811429f0:	10b20e04 	addi	r2,r2,-14280
811429f4:	1080058b 	ldhu	r2,22(r2)
811429f8:	10ffffcc 	andi	r3,r2,65535
811429fc:	00a045f4 	movhi	r2,33047
81142a00:	10b20e04 	addi	r2,r2,-14280
81142a04:	10800383 	ldbu	r2,14(r2)
81142a08:	10803fcc 	andi	r2,r2,255
81142a0c:	1885283a 	div	r2,r3,r2
81142a10:	e0bffd15 	stw	r2,-12(fp)
81142a14:	00000906 	br	81142a3c <Check_for_DOS_FAT+0x4cc>
		}
		else
		{
			num_clusters = (boot_sector_data.total_sector_count_if_above_32MB / boot_sector_data.sectors_per_cluster);
81142a18:	00a045f4 	movhi	r2,33047
81142a1c:	10b20e04 	addi	r2,r2,-14280
81142a20:	10c00917 	ldw	r3,36(r2)
81142a24:	00a045f4 	movhi	r2,33047
81142a28:	10b20e04 	addi	r2,r2,-14280
81142a2c:	10800383 	ldbu	r2,14(r2)
81142a30:	10803fcc 	andi	r2,r2,255
81142a34:	1885203a 	divu	r2,r3,r2
81142a38:	e0bffd15 	stw	r2,-12(fp)
		}
		if (num_clusters < 4087)
81142a3c:	e0bffd17 	ldw	r2,-12(fp)
81142a40:	1083fdc8 	cmpgei	r2,r2,4087
81142a44:	1000051e 	bne	r2,zero,81142a5c <Check_for_DOS_FAT+0x4ec>
		{
			boot_sector_data.bits_for_cluster_index = 12;
81142a48:	00a045f4 	movhi	r2,33047
81142a4c:	10b20e04 	addi	r2,r2,-14280
81142a50:	00c00304 	movi	r3,12
81142a54:	10c01085 	stb	r3,66(r2)
81142a58:	00000c06 	br	81142a8c <Check_for_DOS_FAT+0x51c>
		}
		else if (num_clusters <= 65517)
81142a5c:	e0bffd17 	ldw	r2,-12(fp)
81142a60:	00fffb54 	movui	r3,65517
81142a64:	18800516 	blt	r3,r2,81142a7c <Check_for_DOS_FAT+0x50c>
		{
			boot_sector_data.bits_for_cluster_index = 16;
81142a68:	00a045f4 	movhi	r2,33047
81142a6c:	10b20e04 	addi	r2,r2,-14280
81142a70:	00c00404 	movi	r3,16
81142a74:	10c01085 	stb	r3,66(r2)
81142a78:	00000406 	br	81142a8c <Check_for_DOS_FAT+0x51c>
		}
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
81142a7c:	00a045f4 	movhi	r2,33047
81142a80:	10b20e04 	addi	r2,r2,-14280
81142a84:	00c00804 	movi	r3,32
81142a88:	10c01085 	stb	r3,66(r2)
		}
	    
		for (counter = 0; counter < 4; counter++)
81142a8c:	e03ffc15 	stw	zero,-16(fp)
81142a90:	00001106 	br	81142ad8 <Check_for_DOS_FAT+0x568>
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
81142a94:	d0a0b317 	ldw	r2,-32052(gp)
81142a98:	10c00a17 	ldw	r3,40(r2)
81142a9c:	e0bffc17 	ldw	r2,-16(fp)
81142aa0:	1885883a 	add	r2,r3,r2
81142aa4:	108009c4 	addi	r2,r2,39
81142aa8:	10800023 	ldbuio	r2,0(r2)
81142aac:	10803fcc 	andi	r2,r2,255
81142ab0:	1009883a 	mov	r4,r2
81142ab4:	00a045f4 	movhi	r2,33047
81142ab8:	10b20e04 	addi	r2,r2,-14280
81142abc:	e0fffc17 	ldw	r3,-16(fp)
81142ac0:	10c5883a 	add	r2,r2,r3
81142ac4:	10800ac4 	addi	r2,r2,43
81142ac8:	11000005 	stb	r4,0(r2)
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
		}
	    
		for (counter = 0; counter < 4; counter++)
81142acc:	e0bffc17 	ldw	r2,-16(fp)
81142ad0:	10800044 	addi	r2,r2,1
81142ad4:	e0bffc15 	stw	r2,-16(fp)
81142ad8:	e0bffc17 	ldw	r2,-16(fp)
81142adc:	10800110 	cmplti	r2,r2,4
81142ae0:	103fec1e 	bne	r2,zero,81142a94 <__reset+0xfb122a94>
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
81142ae4:	e03ffc15 	stw	zero,-16(fp)
81142ae8:	00001106 	br	81142b30 <Check_for_DOS_FAT+0x5c0>
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
81142aec:	d0a0b317 	ldw	r2,-32052(gp)
81142af0:	10c00a17 	ldw	r3,40(r2)
81142af4:	e0bffc17 	ldw	r2,-16(fp)
81142af8:	1885883a 	add	r2,r3,r2
81142afc:	10800ac4 	addi	r2,r2,43
81142b00:	10800023 	ldbuio	r2,0(r2)
81142b04:	10803fcc 	andi	r2,r2,255
81142b08:	1009883a 	mov	r4,r2
81142b0c:	00a045f4 	movhi	r2,33047
81142b10:	10b20e04 	addi	r2,r2,-14280
81142b14:	e0fffc17 	ldw	r3,-16(fp)
81142b18:	10c5883a 	add	r2,r2,r3
81142b1c:	10800bc4 	addi	r2,r2,47
81142b20:	11000005 	stb	r4,0(r2)
	    
		for (counter = 0; counter < 4; counter++)
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
81142b24:	e0bffc17 	ldw	r2,-16(fp)
81142b28:	10800044 	addi	r2,r2,1
81142b2c:	e0bffc15 	stw	r2,-16(fp)
81142b30:	e0bffc17 	ldw	r2,-16(fp)
81142b34:	108002d0 	cmplti	r2,r2,11
81142b38:	103fec1e 	bne	r2,zero,81142aec <__reset+0xfb122aec>
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
81142b3c:	e03ffc15 	stw	zero,-16(fp)
81142b40:	00001106 	br	81142b88 <Check_for_DOS_FAT+0x618>
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
81142b44:	d0a0b317 	ldw	r2,-32052(gp)
81142b48:	10c00a17 	ldw	r3,40(r2)
81142b4c:	e0bffc17 	ldw	r2,-16(fp)
81142b50:	1885883a 	add	r2,r3,r2
81142b54:	10800d84 	addi	r2,r2,54
81142b58:	10800023 	ldbuio	r2,0(r2)
81142b5c:	10803fcc 	andi	r2,r2,255
81142b60:	1009883a 	mov	r4,r2
81142b64:	00a045f4 	movhi	r2,33047
81142b68:	10b20e04 	addi	r2,r2,-14280
81142b6c:	e0fffc17 	ldw	r3,-16(fp)
81142b70:	10c5883a 	add	r2,r2,r3
81142b74:	10800e84 	addi	r2,r2,58
81142b78:	11000005 	stb	r4,0(r2)
		}    
		for (counter = 0; counter < 11; counter++)
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
81142b7c:	e0bffc17 	ldw	r2,-16(fp)
81142b80:	10800044 	addi	r2,r2,1
81142b84:	e0bffc15 	stw	r2,-16(fp)
81142b88:	e0bffc17 	ldw	r2,-16(fp)
81142b8c:	10800210 	cmplti	r2,r2,8
81142b90:	103fec1e 	bne	r2,zero,81142b44 <__reset+0xfb122b44>
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
81142b94:	e03ffc15 	stw	zero,-16(fp)
81142b98:	00000a06 	br	81142bc4 <Check_for_DOS_FAT+0x654>
		{
			active_files[counter].in_use = false;
81142b9c:	00a045f4 	movhi	r2,33047
81142ba0:	10b22304 	addi	r2,r2,-14196
81142ba4:	e0fffc17 	ldw	r3,-16(fp)
81142ba8:	180691ba 	slli	r3,r3,6
81142bac:	10c5883a 	add	r2,r2,r3
81142bb0:	10800f04 	addi	r2,r2,60
81142bb4:	10000015 	stw	zero,0(r2)
		for (counter = 0; counter < 8; counter++)
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
81142bb8:	e0bffc17 	ldw	r2,-16(fp)
81142bbc:	10800044 	addi	r2,r2,1
81142bc0:	e0bffc15 	stw	r2,-16(fp)
81142bc4:	e0bffc17 	ldw	r2,-16(fp)
81142bc8:	10800510 	cmplti	r2,r2,20
81142bcc:	103ff31e 	bne	r2,zero,81142b9c <__reset+0xfb122b9c>
		{
			active_files[counter].in_use = false;
		}
		result = true;
81142bd0:	00800044 	movi	r2,1
81142bd4:	e0bffb15 	stw	r2,-20(fp)
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
	{
81142bd8:	00000106 	br	81142be0 <Check_for_DOS_FAT+0x670>
		}
		result = true;
	}
    else
    {
        result = false;
81142bdc:	e03ffb15 	stw	zero,-20(fp)
    }
	return result;
81142be0:	e0bffb17 	ldw	r2,-20(fp)
}
81142be4:	e037883a 	mov	sp,fp
81142be8:	dfc00117 	ldw	ra,4(sp)
81142bec:	df000017 	ldw	fp,0(sp)
81142bf0:	dec00204 	addi	sp,sp,8
81142bf4:	f800283a 	ret

81142bf8 <Look_for_FAT16>:


bool Look_for_FAT16(void)
// Read the SD card to determine if it contains a FAT16 partition.
{
81142bf8:	defffc04 	addi	sp,sp,-16
81142bfc:	de00012e 	bgeu	sp,et,81142c04 <Look_for_FAT16+0xc>
81142c00:	003b68fa 	trap	3
81142c04:	dfc00315 	stw	ra,12(sp)
81142c08:	df000215 	stw	fp,8(sp)
81142c0c:	df000204 	addi	fp,sp,8
	bool result = false;
81142c10:	e03ffe15 	stw	zero,-8(fp)

	if (alt_up_sd_card_is_Present())
81142c14:	11449000 	call	81144900 <alt_up_sd_card_is_Present>
81142c18:	10002e26 	beq	r2,zero,81142cd4 <Look_for_FAT16+0xdc>
	{
		short int csd_file_format = *CSD_register_w0;
81142c1c:	d0a0ad17 	ldw	r2,-32076(gp)
81142c20:	1080000b 	ldhu	r2,0(r2)
81142c24:	e0bfff0d 	sth	r2,-4(fp)
        
		fat_partition_offset_in_512_byte_sectors = 0;
81142c28:	d020b115 	stw	zero,-32060(gp)
		fat_partition_size_in_512_byte_sectors = 0;              
81142c2c:	d020b215 	stw	zero,-32056(gp)

		if (((csd_file_format & 0x8000) == 0) && ((csd_file_format & 0x0c00) != 0x0c00))
81142c30:	e0bfff0f 	ldh	r2,-4(fp)
81142c34:	10002716 	blt	r2,zero,81142cd4 <Look_for_FAT16+0xdc>
81142c38:	e0bfff0b 	ldhu	r2,-4(fp)
81142c3c:	10bfffcc 	andi	r2,r2,65535
81142c40:	1083000c 	andi	r2,r2,3072
81142c44:	10830020 	cmpeqi	r2,r2,3072
81142c48:	1000221e 	bne	r2,zero,81142cd4 <Look_for_FAT16+0xdc>
		{
			if ((csd_file_format & 0x0c00) == 0x0400)
81142c4c:	e0bfff0b 	ldhu	r2,-4(fp)
81142c50:	10bfffcc 	andi	r2,r2,65535
81142c54:	1083000c 	andi	r2,r2,3072
81142c58:	10810018 	cmpnei	r2,r2,1024
81142c5c:	1000031e 	bne	r2,zero,81142c6c <Look_for_FAT16+0x74>
			{
				/* SD Card contains files stored in a DOS FAT (floppy like) file format, without a partition table */
				result = Check_for_DOS_FAT(0);
81142c60:	0009883a 	mov	r4,zero
81142c64:	11425700 	call	81142570 <Check_for_DOS_FAT>
81142c68:	e0bffe15 	stw	r2,-8(fp)
			}
			if ((csd_file_format & 0x0c00) == 0x0000)
81142c6c:	e0bfff0b 	ldhu	r2,-4(fp)
81142c70:	10bfffcc 	andi	r2,r2,65535
81142c74:	1083000c 	andi	r2,r2,3072
81142c78:	1000061e 	bne	r2,zero,81142c94 <Look_for_FAT16+0x9c>
			{
				/* SD Card contains files stored in a Hard disk-like file format that contains a partition table */
				if (Check_for_Master_Boot_Record())
81142c7c:	1141eac0 	call	81141eac <Check_for_Master_Boot_Record>
81142c80:	10000426 	beq	r2,zero,81142c94 <Look_for_FAT16+0x9c>
				{
					result = Check_for_DOS_FAT(fat_partition_offset_in_512_byte_sectors);
81142c84:	d0a0b117 	ldw	r2,-32060(gp)
81142c88:	1009883a 	mov	r4,r2
81142c8c:	11425700 	call	81142570 <Check_for_DOS_FAT>
81142c90:	e0bffe15 	stw	r2,-8(fp)
				}                        
			}
			if (result == true)
81142c94:	e0bffe17 	ldw	r2,-8(fp)
81142c98:	10800058 	cmpnei	r2,r2,1
81142c9c:	10000d1e 	bne	r2,zero,81142cd4 <Look_for_FAT16+0xdc>
			{
				// Accept only FAT16, not FAT12.
				if (boot_sector_data.bits_for_cluster_index != 16)
81142ca0:	00a045f4 	movhi	r2,33047
81142ca4:	10b20e04 	addi	r2,r2,-14280
81142ca8:	10801083 	ldbu	r2,66(r2)
81142cac:	10803fcc 	andi	r2,r2,255
81142cb0:	10800420 	cmpeqi	r2,r2,16
81142cb4:	1000021e 	bne	r2,zero,81142cc0 <Look_for_FAT16+0xc8>
				{
					result = false;
81142cb8:	e03ffe15 	stw	zero,-8(fp)
81142cbc:	00000506 	br	81142cd4 <Look_for_FAT16+0xdc>
				}
				else
				{
					fat_partition_size_in_512_byte_sectors = boot_sector_data.number_of_sectors_in_partition;
81142cc0:	00a045f4 	movhi	r2,33047
81142cc4:	10b20e04 	addi	r2,r2,-14280
81142cc8:	1080058b 	ldhu	r2,22(r2)
81142ccc:	10bfffcc 	andi	r2,r2,65535
81142cd0:	d0a0b215 	stw	r2,-32056(gp)
				}
			}
		}
	}
	return result;
81142cd4:	e0bffe17 	ldw	r2,-8(fp)
}
81142cd8:	e037883a 	mov	sp,fp
81142cdc:	dfc00117 	ldw	ra,4(sp)
81142ce0:	df000017 	ldw	fp,0(sp)
81142ce4:	dec00204 	addi	sp,sp,8
81142ce8:	f800283a 	ret

81142cec <filename_to_upper_case>:
 

void filename_to_upper_case(char *file_name)
// Change file name to upper case.
{
81142cec:	defffb04 	addi	sp,sp,-20
81142cf0:	de00012e 	bgeu	sp,et,81142cf8 <filename_to_upper_case+0xc>
81142cf4:	003b68fa 	trap	3
81142cf8:	dfc00415 	stw	ra,16(sp)
81142cfc:	df000315 	stw	fp,12(sp)
81142d00:	df000304 	addi	fp,sp,12
81142d04:	e13fff15 	stw	r4,-4(fp)
    int index;
    int length = strlen(file_name);
81142d08:	e13fff17 	ldw	r4,-4(fp)
81142d0c:	1122b480 	call	81122b48 <strlen>
81142d10:	e0bffe15 	stw	r2,-8(fp)
    
    for (index = 0; index < length; index++)
81142d14:	e03ffd15 	stw	zero,-12(fp)
81142d18:	00001e06 	br	81142d94 <filename_to_upper_case+0xa8>
    {
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
81142d1c:	e0bffd17 	ldw	r2,-12(fp)
81142d20:	e0ffff17 	ldw	r3,-4(fp)
81142d24:	1885883a 	add	r2,r3,r2
81142d28:	10800003 	ldbu	r2,0(r2)
81142d2c:	10803fcc 	andi	r2,r2,255
81142d30:	1080201c 	xori	r2,r2,128
81142d34:	10bfe004 	addi	r2,r2,-128
81142d38:	10801850 	cmplti	r2,r2,97
81142d3c:	1000121e 	bne	r2,zero,81142d88 <filename_to_upper_case+0x9c>
81142d40:	e0bffd17 	ldw	r2,-12(fp)
81142d44:	e0ffff17 	ldw	r3,-4(fp)
81142d48:	1885883a 	add	r2,r3,r2
81142d4c:	10800003 	ldbu	r2,0(r2)
81142d50:	10803fcc 	andi	r2,r2,255
81142d54:	1080201c 	xori	r2,r2,128
81142d58:	10bfe004 	addi	r2,r2,-128
81142d5c:	10801ec8 	cmpgei	r2,r2,123
81142d60:	1000091e 	bne	r2,zero,81142d88 <filename_to_upper_case+0x9c>
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
81142d64:	e0bffd17 	ldw	r2,-12(fp)
81142d68:	e0ffff17 	ldw	r3,-4(fp)
81142d6c:	1885883a 	add	r2,r3,r2
81142d70:	e0fffd17 	ldw	r3,-12(fp)
81142d74:	e13fff17 	ldw	r4,-4(fp)
81142d78:	20c7883a 	add	r3,r4,r3
81142d7c:	18c00003 	ldbu	r3,0(r3)
81142d80:	18fff804 	addi	r3,r3,-32
81142d84:	10c00005 	stb	r3,0(r2)
// Change file name to upper case.
{
    int index;
    int length = strlen(file_name);
    
    for (index = 0; index < length; index++)
81142d88:	e0bffd17 	ldw	r2,-12(fp)
81142d8c:	10800044 	addi	r2,r2,1
81142d90:	e0bffd15 	stw	r2,-12(fp)
81142d94:	e0fffd17 	ldw	r3,-12(fp)
81142d98:	e0bffe17 	ldw	r2,-8(fp)
81142d9c:	18bfdf16 	blt	r3,r2,81142d1c <__reset+0xfb122d1c>
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
        }
    }
}
81142da0:	0001883a 	nop
81142da4:	e037883a 	mov	sp,fp
81142da8:	dfc00117 	ldw	ra,4(sp)
81142dac:	df000017 	ldw	fp,0(sp)
81142db0:	dec00204 	addi	sp,sp,8
81142db4:	f800283a 	ret

81142db8 <check_file_name_for_FAT16_compliance>:


bool check_file_name_for_FAT16_compliance(char *file_name)
// Check if the file complies with FAT16 naming convention.
{
81142db8:	defff804 	addi	sp,sp,-32
81142dbc:	de00012e 	bgeu	sp,et,81142dc4 <check_file_name_for_FAT16_compliance+0xc>
81142dc0:	003b68fa 	trap	3
81142dc4:	dfc00715 	stw	ra,28(sp)
81142dc8:	df000615 	stw	fp,24(sp)
81142dcc:	df000604 	addi	fp,sp,24
81142dd0:	e13fff15 	stw	r4,-4(fp)
    int length = strlen(file_name);
81142dd4:	e13fff17 	ldw	r4,-4(fp)
81142dd8:	1122b480 	call	81122b48 <strlen>
81142ddc:	e0bffe15 	stw	r2,-8(fp)
    int index;
    int last_dir_break_position = -1;
81142de0:	00bfffc4 	movi	r2,-1
81142de4:	e0bffb15 	stw	r2,-20(fp)
    int last_period = -1;
81142de8:	00bfffc4 	movi	r2,-1
81142dec:	e0bffc15 	stw	r2,-16(fp)
    bool result = true;
81142df0:	00800044 	movi	r2,1
81142df4:	e0bffd15 	stw	r2,-12(fp)
    
    for(index = 0; index < length; index++)
81142df8:	e03ffa15 	stw	zero,-24(fp)
81142dfc:	00006d06 	br	81142fb4 <check_file_name_for_FAT16_compliance+0x1fc>
    {
        if ((file_name[index] == ' ') ||
81142e00:	e0bffa17 	ldw	r2,-24(fp)
81142e04:	e0ffff17 	ldw	r3,-4(fp)
81142e08:	1885883a 	add	r2,r3,r2
81142e0c:	10800003 	ldbu	r2,0(r2)
81142e10:	10803fcc 	andi	r2,r2,255
81142e14:	1080201c 	xori	r2,r2,128
81142e18:	10bfe004 	addi	r2,r2,-128
81142e1c:	10800820 	cmpeqi	r2,r2,32
81142e20:	10003e1e 	bne	r2,zero,81142f1c <check_file_name_for_FAT16_compliance+0x164>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
81142e24:	e0bffa17 	ldw	r2,-24(fp)
81142e28:	10ffffc4 	addi	r3,r2,-1
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
81142e2c:	e0bffb17 	ldw	r2,-20(fp)
81142e30:	1880121e 	bne	r3,r2,81142e7c <check_file_name_for_FAT16_compliance+0xc4>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
81142e34:	e0bffa17 	ldw	r2,-24(fp)
81142e38:	e0ffff17 	ldw	r3,-4(fp)
81142e3c:	1885883a 	add	r2,r3,r2
81142e40:	10800003 	ldbu	r2,0(r2)
81142e44:	10803fcc 	andi	r2,r2,255
81142e48:	1080201c 	xori	r2,r2,128
81142e4c:	10bfe004 	addi	r2,r2,-128
81142e50:	10801720 	cmpeqi	r2,r2,92
81142e54:	1000311e 	bne	r2,zero,81142f1c <check_file_name_for_FAT16_compliance+0x164>
81142e58:	e0bffa17 	ldw	r2,-24(fp)
81142e5c:	e0ffff17 	ldw	r3,-4(fp)
81142e60:	1885883a 	add	r2,r3,r2
81142e64:	10800003 	ldbu	r2,0(r2)
81142e68:	10803fcc 	andi	r2,r2,255
81142e6c:	1080201c 	xori	r2,r2,128
81142e70:	10bfe004 	addi	r2,r2,-128
81142e74:	10800be0 	cmpeqi	r2,r2,47
81142e78:	1000281e 	bne	r2,zero,81142f1c <check_file_name_for_FAT16_compliance+0x164>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
81142e7c:	e0fffa17 	ldw	r3,-24(fp)
81142e80:	e0bffc17 	ldw	r2,-16(fp)
81142e84:	1885c83a 	sub	r2,r3,r2
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
81142e88:	10800258 	cmpnei	r2,r2,9
81142e8c:	1000091e 	bne	r2,zero,81142eb4 <check_file_name_for_FAT16_compliance+0xfc>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
81142e90:	e0bffa17 	ldw	r2,-24(fp)
81142e94:	e0ffff17 	ldw	r3,-4(fp)
81142e98:	1885883a 	add	r2,r3,r2
81142e9c:	10800003 	ldbu	r2,0(r2)
81142ea0:	10803fcc 	andi	r2,r2,255
81142ea4:	1080201c 	xori	r2,r2,128
81142ea8:	10bfe004 	addi	r2,r2,-128
81142eac:	10800b98 	cmpnei	r2,r2,46
81142eb0:	10001a1e 	bne	r2,zero,81142f1c <check_file_name_for_FAT16_compliance+0x164>
81142eb4:	e0fffb17 	ldw	r3,-20(fp)
81142eb8:	e0bffc17 	ldw	r2,-16(fp)
81142ebc:	18801926 	beq	r3,r2,81142f24 <check_file_name_for_FAT16_compliance+0x16c>
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
81142ec0:	e0fffa17 	ldw	r3,-24(fp)
81142ec4:	e0bffc17 	ldw	r2,-16(fp)
81142ec8:	1885c83a 	sub	r2,r3,r2
81142ecc:	10800110 	cmplti	r2,r2,4
81142ed0:	1000141e 	bne	r2,zero,81142f24 <check_file_name_for_FAT16_compliance+0x16c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
81142ed4:	e0bffa17 	ldw	r2,-24(fp)
81142ed8:	e0ffff17 	ldw	r3,-4(fp)
81142edc:	1885883a 	add	r2,r3,r2
81142ee0:	10800003 	ldbu	r2,0(r2)
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
            ((index - last_period == 9) && (file_name[index] != '.')) ||
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
81142ee4:	10803fcc 	andi	r2,r2,255
81142ee8:	1080201c 	xori	r2,r2,128
81142eec:	10bfe004 	addi	r2,r2,-128
81142ef0:	10801720 	cmpeqi	r2,r2,92
81142ef4:	10000b1e 	bne	r2,zero,81142f24 <check_file_name_for_FAT16_compliance+0x16c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
81142ef8:	e0bffa17 	ldw	r2,-24(fp)
81142efc:	e0ffff17 	ldw	r3,-4(fp)
81142f00:	1885883a 	add	r2,r3,r2
81142f04:	10800003 	ldbu	r2,0(r2)
81142f08:	10803fcc 	andi	r2,r2,255
81142f0c:	1080201c 	xori	r2,r2,128
81142f10:	10bfe004 	addi	r2,r2,-128
81142f14:	10800be0 	cmpeqi	r2,r2,47
81142f18:	1000021e 	bne	r2,zero,81142f24 <check_file_name_for_FAT16_compliance+0x16c>
           )
        {
            result = false;
81142f1c:	e03ffd15 	stw	zero,-12(fp)
            break;
81142f20:	00002706 	br	81142fc0 <check_file_name_for_FAT16_compliance+0x208>
        }
        if ((file_name[index] == '\\') || (file_name[index] == '/'))
81142f24:	e0bffa17 	ldw	r2,-24(fp)
81142f28:	e0ffff17 	ldw	r3,-4(fp)
81142f2c:	1885883a 	add	r2,r3,r2
81142f30:	10800003 	ldbu	r2,0(r2)
81142f34:	10803fcc 	andi	r2,r2,255
81142f38:	1080201c 	xori	r2,r2,128
81142f3c:	10bfe004 	addi	r2,r2,-128
81142f40:	10801720 	cmpeqi	r2,r2,92
81142f44:	1000091e 	bne	r2,zero,81142f6c <check_file_name_for_FAT16_compliance+0x1b4>
81142f48:	e0bffa17 	ldw	r2,-24(fp)
81142f4c:	e0ffff17 	ldw	r3,-4(fp)
81142f50:	1885883a 	add	r2,r3,r2
81142f54:	10800003 	ldbu	r2,0(r2)
81142f58:	10803fcc 	andi	r2,r2,255
81142f5c:	1080201c 	xori	r2,r2,128
81142f60:	10bfe004 	addi	r2,r2,-128
81142f64:	10800bd8 	cmpnei	r2,r2,47
81142f68:	1000041e 	bne	r2,zero,81142f7c <check_file_name_for_FAT16_compliance+0x1c4>
        {
            last_period = index;
81142f6c:	e0bffa17 	ldw	r2,-24(fp)
81142f70:	e0bffc15 	stw	r2,-16(fp)
            last_dir_break_position = index;
81142f74:	e0bffa17 	ldw	r2,-24(fp)
81142f78:	e0bffb15 	stw	r2,-20(fp)
        }
        if (file_name[index] == '.')
81142f7c:	e0bffa17 	ldw	r2,-24(fp)
81142f80:	e0ffff17 	ldw	r3,-4(fp)
81142f84:	1885883a 	add	r2,r3,r2
81142f88:	10800003 	ldbu	r2,0(r2)
81142f8c:	10803fcc 	andi	r2,r2,255
81142f90:	1080201c 	xori	r2,r2,128
81142f94:	10bfe004 	addi	r2,r2,-128
81142f98:	10800b98 	cmpnei	r2,r2,46
81142f9c:	1000021e 	bne	r2,zero,81142fa8 <check_file_name_for_FAT16_compliance+0x1f0>
        {
            last_period = index;
81142fa0:	e0bffa17 	ldw	r2,-24(fp)
81142fa4:	e0bffc15 	stw	r2,-16(fp)
    int index;
    int last_dir_break_position = -1;
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
81142fa8:	e0bffa17 	ldw	r2,-24(fp)
81142fac:	10800044 	addi	r2,r2,1
81142fb0:	e0bffa15 	stw	r2,-24(fp)
81142fb4:	e0fffa17 	ldw	r3,-24(fp)
81142fb8:	e0bffe17 	ldw	r2,-8(fp)
81142fbc:	18bf9016 	blt	r3,r2,81142e00 <__reset+0xfb122e00>
        if (file_name[index] == '.')
        {
            last_period = index;
        }
    }
    if ((file_name[length-1] == '\\') || (file_name[length-1] == '/'))
81142fc0:	e0bffe17 	ldw	r2,-8(fp)
81142fc4:	10bfffc4 	addi	r2,r2,-1
81142fc8:	e0ffff17 	ldw	r3,-4(fp)
81142fcc:	1885883a 	add	r2,r3,r2
81142fd0:	10800003 	ldbu	r2,0(r2)
81142fd4:	10803fcc 	andi	r2,r2,255
81142fd8:	1080201c 	xori	r2,r2,128
81142fdc:	10bfe004 	addi	r2,r2,-128
81142fe0:	10801720 	cmpeqi	r2,r2,92
81142fe4:	10000a1e 	bne	r2,zero,81143010 <check_file_name_for_FAT16_compliance+0x258>
81142fe8:	e0bffe17 	ldw	r2,-8(fp)
81142fec:	10bfffc4 	addi	r2,r2,-1
81142ff0:	e0ffff17 	ldw	r3,-4(fp)
81142ff4:	1885883a 	add	r2,r3,r2
81142ff8:	10800003 	ldbu	r2,0(r2)
81142ffc:	10803fcc 	andi	r2,r2,255
81143000:	1080201c 	xori	r2,r2,128
81143004:	10bfe004 	addi	r2,r2,-128
81143008:	10800bd8 	cmpnei	r2,r2,47
8114300c:	1000011e 	bne	r2,zero,81143014 <check_file_name_for_FAT16_compliance+0x25c>
    {
        result = false;
81143010:	e03ffd15 	stw	zero,-12(fp)
    }
    return result;
81143014:	e0bffd17 	ldw	r2,-12(fp)
}
81143018:	e037883a 	mov	sp,fp
8114301c:	dfc00117 	ldw	ra,4(sp)
81143020:	df000017 	ldw	fp,0(sp)
81143024:	dec00204 	addi	sp,sp,8
81143028:	f800283a 	ret

8114302c <get_dir_divider_location>:


int get_dir_divider_location(char *name)
// Find a directory divider location.
{
8114302c:	defffb04 	addi	sp,sp,-20
81143030:	de00012e 	bgeu	sp,et,81143038 <get_dir_divider_location+0xc>
81143034:	003b68fa 	trap	3
81143038:	dfc00415 	stw	ra,16(sp)
8114303c:	df000315 	stw	fp,12(sp)
81143040:	df000304 	addi	fp,sp,12
81143044:	e13fff15 	stw	r4,-4(fp)
    int index = 0;
81143048:	e03ffd15 	stw	zero,-12(fp)
    int length = strlen(name);
8114304c:	e13fff17 	ldw	r4,-4(fp)
81143050:	1122b480 	call	81122b48 <strlen>
81143054:	e0bffe15 	stw	r2,-8(fp)
    
    for(index = 0; index < length; index++)
81143058:	e03ffd15 	stw	zero,-12(fp)
8114305c:	00001506 	br	811430b4 <get_dir_divider_location+0x88>
    {
        if ((name[index] == '\\') || (name[index] == '/'))
81143060:	e0bffd17 	ldw	r2,-12(fp)
81143064:	e0ffff17 	ldw	r3,-4(fp)
81143068:	1885883a 	add	r2,r3,r2
8114306c:	10800003 	ldbu	r2,0(r2)
81143070:	10803fcc 	andi	r2,r2,255
81143074:	1080201c 	xori	r2,r2,128
81143078:	10bfe004 	addi	r2,r2,-128
8114307c:	10801720 	cmpeqi	r2,r2,92
81143080:	10000f1e 	bne	r2,zero,811430c0 <get_dir_divider_location+0x94>
81143084:	e0bffd17 	ldw	r2,-12(fp)
81143088:	e0ffff17 	ldw	r3,-4(fp)
8114308c:	1885883a 	add	r2,r3,r2
81143090:	10800003 	ldbu	r2,0(r2)
81143094:	10803fcc 	andi	r2,r2,255
81143098:	1080201c 	xori	r2,r2,128
8114309c:	10bfe004 	addi	r2,r2,-128
811430a0:	10800be0 	cmpeqi	r2,r2,47
811430a4:	1000061e 	bne	r2,zero,811430c0 <get_dir_divider_location+0x94>
// Find a directory divider location.
{
    int index = 0;
    int length = strlen(name);
    
    for(index = 0; index < length; index++)
811430a8:	e0bffd17 	ldw	r2,-12(fp)
811430ac:	10800044 	addi	r2,r2,1
811430b0:	e0bffd15 	stw	r2,-12(fp)
811430b4:	e0fffd17 	ldw	r3,-12(fp)
811430b8:	e0bffe17 	ldw	r2,-8(fp)
811430bc:	18bfe816 	blt	r3,r2,81143060 <__reset+0xfb123060>
        {
            break;
        }
    }
    
    if (index == length)
811430c0:	e0fffd17 	ldw	r3,-12(fp)
811430c4:	e0bffe17 	ldw	r2,-8(fp)
811430c8:	1880021e 	bne	r3,r2,811430d4 <get_dir_divider_location+0xa8>
    {
        index = -1;
811430cc:	00bfffc4 	movi	r2,-1
811430d0:	e0bffd15 	stw	r2,-12(fp)
    }
    
    return index;
811430d4:	e0bffd17 	ldw	r2,-12(fp)
}
811430d8:	e037883a 	mov	sp,fp
811430dc:	dfc00117 	ldw	ra,4(sp)
811430e0:	df000017 	ldw	fp,0(sp)
811430e4:	dec00204 	addi	sp,sp,8
811430e8:	f800283a 	ret

811430ec <match_file_record_to_name_ext>:


bool match_file_record_to_name_ext(t_file_record *file_record, char *name, char *extension)
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
811430ec:	defffa04 	addi	sp,sp,-24
811430f0:	de00012e 	bgeu	sp,et,811430f8 <match_file_record_to_name_ext+0xc>
811430f4:	003b68fa 	trap	3
811430f8:	df000515 	stw	fp,20(sp)
811430fc:	df000504 	addi	fp,sp,20
81143100:	e13ffd15 	stw	r4,-12(fp)
81143104:	e17ffe15 	stw	r5,-8(fp)
81143108:	e1bfff15 	stw	r6,-4(fp)
    bool match = true;
8114310c:	00800044 	movi	r2,1
81143110:	e0bffb15 	stw	r2,-20(fp)
	int index;

    for (index = 0; index < 8; index++)
81143114:	e03ffc15 	stw	zero,-16(fp)
81143118:	00004606 	br	81143234 <match_file_record_to_name_ext+0x148>
    {
        if (CHAR_TO_UPPER(file_record->name[index]) != CHAR_TO_UPPER(name[index]))
8114311c:	e0fffd17 	ldw	r3,-12(fp)
81143120:	e0bffc17 	ldw	r2,-16(fp)
81143124:	1885883a 	add	r2,r3,r2
81143128:	10800003 	ldbu	r2,0(r2)
8114312c:	10803fcc 	andi	r2,r2,255
81143130:	10801870 	cmpltui	r2,r2,97
81143134:	1000101e 	bne	r2,zero,81143178 <match_file_record_to_name_ext+0x8c>
81143138:	e0fffd17 	ldw	r3,-12(fp)
8114313c:	e0bffc17 	ldw	r2,-16(fp)
81143140:	1885883a 	add	r2,r3,r2
81143144:	10800003 	ldbu	r2,0(r2)
81143148:	10803fcc 	andi	r2,r2,255
8114314c:	10801ee8 	cmpgeui	r2,r2,123
81143150:	1000091e 	bne	r2,zero,81143178 <match_file_record_to_name_ext+0x8c>
81143154:	e0fffd17 	ldw	r3,-12(fp)
81143158:	e0bffc17 	ldw	r2,-16(fp)
8114315c:	1885883a 	add	r2,r3,r2
81143160:	10800003 	ldbu	r2,0(r2)
81143164:	10bff804 	addi	r2,r2,-32
81143168:	10c03fcc 	andi	r3,r2,255
8114316c:	18c0201c 	xori	r3,r3,128
81143170:	18ffe004 	addi	r3,r3,-128
81143174:	00000706 	br	81143194 <match_file_record_to_name_ext+0xa8>
81143178:	e0fffd17 	ldw	r3,-12(fp)
8114317c:	e0bffc17 	ldw	r2,-16(fp)
81143180:	1885883a 	add	r2,r3,r2
81143184:	10800003 	ldbu	r2,0(r2)
81143188:	10c03fcc 	andi	r3,r2,255
8114318c:	18c0201c 	xori	r3,r3,128
81143190:	18ffe004 	addi	r3,r3,-128
81143194:	e0bffc17 	ldw	r2,-16(fp)
81143198:	e13ffe17 	ldw	r4,-8(fp)
8114319c:	2085883a 	add	r2,r4,r2
811431a0:	10800003 	ldbu	r2,0(r2)
811431a4:	10803fcc 	andi	r2,r2,255
811431a8:	1080201c 	xori	r2,r2,128
811431ac:	10bfe004 	addi	r2,r2,-128
811431b0:	10801850 	cmplti	r2,r2,97
811431b4:	1000121e 	bne	r2,zero,81143200 <match_file_record_to_name_ext+0x114>
811431b8:	e0bffc17 	ldw	r2,-16(fp)
811431bc:	e13ffe17 	ldw	r4,-8(fp)
811431c0:	2085883a 	add	r2,r4,r2
811431c4:	10800003 	ldbu	r2,0(r2)
811431c8:	10803fcc 	andi	r2,r2,255
811431cc:	1080201c 	xori	r2,r2,128
811431d0:	10bfe004 	addi	r2,r2,-128
811431d4:	10801ec8 	cmpgei	r2,r2,123
811431d8:	1000091e 	bne	r2,zero,81143200 <match_file_record_to_name_ext+0x114>
811431dc:	e0bffc17 	ldw	r2,-16(fp)
811431e0:	e13ffe17 	ldw	r4,-8(fp)
811431e4:	2085883a 	add	r2,r4,r2
811431e8:	10800003 	ldbu	r2,0(r2)
811431ec:	10bff804 	addi	r2,r2,-32
811431f0:	10803fcc 	andi	r2,r2,255
811431f4:	1080201c 	xori	r2,r2,128
811431f8:	10bfe004 	addi	r2,r2,-128
811431fc:	00000706 	br	8114321c <match_file_record_to_name_ext+0x130>
81143200:	e0bffc17 	ldw	r2,-16(fp)
81143204:	e13ffe17 	ldw	r4,-8(fp)
81143208:	2085883a 	add	r2,r4,r2
8114320c:	10800003 	ldbu	r2,0(r2)
81143210:	10803fcc 	andi	r2,r2,255
81143214:	1080201c 	xori	r2,r2,128
81143218:	10bfe004 	addi	r2,r2,-128
8114321c:	18800226 	beq	r3,r2,81143228 <match_file_record_to_name_ext+0x13c>
        {
            match = false;
81143220:	e03ffb15 	stw	zero,-20(fp)
			break;
81143224:	00000606 	br	81143240 <match_file_record_to_name_ext+0x154>
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
    bool match = true;
	int index;

    for (index = 0; index < 8; index++)
81143228:	e0bffc17 	ldw	r2,-16(fp)
8114322c:	10800044 	addi	r2,r2,1
81143230:	e0bffc15 	stw	r2,-16(fp)
81143234:	e0bffc17 	ldw	r2,-16(fp)
81143238:	10800210 	cmplti	r2,r2,8
8114323c:	103fb71e 	bne	r2,zero,8114311c <__reset+0xfb12311c>
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
81143240:	e03ffc15 	stw	zero,-16(fp)
81143244:	00004a06 	br	81143370 <match_file_record_to_name_ext+0x284>
    {
        if (CHAR_TO_UPPER(file_record->extension[index]) != CHAR_TO_UPPER(extension[index]))
81143248:	e0fffd17 	ldw	r3,-12(fp)
8114324c:	e0bffc17 	ldw	r2,-16(fp)
81143250:	1885883a 	add	r2,r3,r2
81143254:	10800204 	addi	r2,r2,8
81143258:	10800003 	ldbu	r2,0(r2)
8114325c:	10803fcc 	andi	r2,r2,255
81143260:	10801870 	cmpltui	r2,r2,97
81143264:	1000121e 	bne	r2,zero,811432b0 <match_file_record_to_name_ext+0x1c4>
81143268:	e0fffd17 	ldw	r3,-12(fp)
8114326c:	e0bffc17 	ldw	r2,-16(fp)
81143270:	1885883a 	add	r2,r3,r2
81143274:	10800204 	addi	r2,r2,8
81143278:	10800003 	ldbu	r2,0(r2)
8114327c:	10803fcc 	andi	r2,r2,255
81143280:	10801ee8 	cmpgeui	r2,r2,123
81143284:	10000a1e 	bne	r2,zero,811432b0 <match_file_record_to_name_ext+0x1c4>
81143288:	e0fffd17 	ldw	r3,-12(fp)
8114328c:	e0bffc17 	ldw	r2,-16(fp)
81143290:	1885883a 	add	r2,r3,r2
81143294:	10800204 	addi	r2,r2,8
81143298:	10800003 	ldbu	r2,0(r2)
8114329c:	10bff804 	addi	r2,r2,-32
811432a0:	10c03fcc 	andi	r3,r2,255
811432a4:	18c0201c 	xori	r3,r3,128
811432a8:	18ffe004 	addi	r3,r3,-128
811432ac:	00000806 	br	811432d0 <match_file_record_to_name_ext+0x1e4>
811432b0:	e0fffd17 	ldw	r3,-12(fp)
811432b4:	e0bffc17 	ldw	r2,-16(fp)
811432b8:	1885883a 	add	r2,r3,r2
811432bc:	10800204 	addi	r2,r2,8
811432c0:	10800003 	ldbu	r2,0(r2)
811432c4:	10c03fcc 	andi	r3,r2,255
811432c8:	18c0201c 	xori	r3,r3,128
811432cc:	18ffe004 	addi	r3,r3,-128
811432d0:	e0bffc17 	ldw	r2,-16(fp)
811432d4:	e13fff17 	ldw	r4,-4(fp)
811432d8:	2085883a 	add	r2,r4,r2
811432dc:	10800003 	ldbu	r2,0(r2)
811432e0:	10803fcc 	andi	r2,r2,255
811432e4:	1080201c 	xori	r2,r2,128
811432e8:	10bfe004 	addi	r2,r2,-128
811432ec:	10801850 	cmplti	r2,r2,97
811432f0:	1000121e 	bne	r2,zero,8114333c <match_file_record_to_name_ext+0x250>
811432f4:	e0bffc17 	ldw	r2,-16(fp)
811432f8:	e13fff17 	ldw	r4,-4(fp)
811432fc:	2085883a 	add	r2,r4,r2
81143300:	10800003 	ldbu	r2,0(r2)
81143304:	10803fcc 	andi	r2,r2,255
81143308:	1080201c 	xori	r2,r2,128
8114330c:	10bfe004 	addi	r2,r2,-128
81143310:	10801ec8 	cmpgei	r2,r2,123
81143314:	1000091e 	bne	r2,zero,8114333c <match_file_record_to_name_ext+0x250>
81143318:	e0bffc17 	ldw	r2,-16(fp)
8114331c:	e13fff17 	ldw	r4,-4(fp)
81143320:	2085883a 	add	r2,r4,r2
81143324:	10800003 	ldbu	r2,0(r2)
81143328:	10bff804 	addi	r2,r2,-32
8114332c:	10803fcc 	andi	r2,r2,255
81143330:	1080201c 	xori	r2,r2,128
81143334:	10bfe004 	addi	r2,r2,-128
81143338:	00000706 	br	81143358 <match_file_record_to_name_ext+0x26c>
8114333c:	e0bffc17 	ldw	r2,-16(fp)
81143340:	e13fff17 	ldw	r4,-4(fp)
81143344:	2085883a 	add	r2,r4,r2
81143348:	10800003 	ldbu	r2,0(r2)
8114334c:	10803fcc 	andi	r2,r2,255
81143350:	1080201c 	xori	r2,r2,128
81143354:	10bfe004 	addi	r2,r2,-128
81143358:	18800226 	beq	r3,r2,81143364 <match_file_record_to_name_ext+0x278>
        {
            match = false;
8114335c:	e03ffb15 	stw	zero,-20(fp)
			break;
81143360:	00000606 	br	8114337c <match_file_record_to_name_ext+0x290>
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
81143364:	e0bffc17 	ldw	r2,-16(fp)
81143368:	10800044 	addi	r2,r2,1
8114336c:	e0bffc15 	stw	r2,-16(fp)
81143370:	e0bffc17 	ldw	r2,-16(fp)
81143374:	108000d0 	cmplti	r2,r2,3
81143378:	103fb31e 	bne	r2,zero,81143248 <__reset+0xfb123248>
        {
            match = false;
			break;
        }
    }
	return match;
8114337c:	e0bffb17 	ldw	r2,-20(fp)
}
81143380:	e037883a 	mov	sp,fp
81143384:	df000017 	ldw	fp,0(sp)
81143388:	dec00104 	addi	sp,sp,4
8114338c:	f800283a 	ret

81143390 <get_home_directory_cluster_for_file>:


bool get_home_directory_cluster_for_file(char *file_name, int *home_directory_cluster, t_file_record *file_record)
// Scan the directories in given in the file name and find the root directory for the file.
{
81143390:	deffe704 	addi	sp,sp,-100
81143394:	de00012e 	bgeu	sp,et,8114339c <get_home_directory_cluster_for_file+0xc>
81143398:	003b68fa 	trap	3
8114339c:	dfc01815 	stw	ra,96(sp)
811433a0:	df001715 	stw	fp,92(sp)
811433a4:	df001704 	addi	fp,sp,92
811433a8:	e13ffd15 	stw	r4,-12(fp)
811433ac:	e17ffe15 	stw	r5,-8(fp)
811433b0:	e1bfff15 	stw	r6,-4(fp)
    bool result = false;
811433b4:	e03fe915 	stw	zero,-92(fp)
    int home_dir_cluster = 0;
811433b8:	e03fea15 	stw	zero,-88(fp)
    int location, index;
    int start_location = 0;
811433bc:	e03fed15 	stw	zero,-76(fp)
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
811433c0:	e13ffd17 	ldw	r4,-12(fp)
811433c4:	114302c0 	call	8114302c <get_dir_divider_location>
811433c8:	e0bfeb15 	stw	r2,-84(fp)
    while (location > 0)
811433cc:	00012f06 	br	8114388c <get_home_directory_cluster_for_file+0x4fc>
    {
        char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
811433d0:	00800804 	movi	r2,32
811433d4:	e0bff905 	stb	r2,-28(fp)
811433d8:	00800804 	movi	r2,32
811433dc:	e0bff945 	stb	r2,-27(fp)
811433e0:	00800804 	movi	r2,32
811433e4:	e0bff985 	stb	r2,-26(fp)
811433e8:	00800804 	movi	r2,32
811433ec:	e0bff9c5 	stb	r2,-25(fp)
811433f0:	00800804 	movi	r2,32
811433f4:	e0bffa05 	stb	r2,-24(fp)
811433f8:	00800804 	movi	r2,32
811433fc:	e0bffa45 	stb	r2,-23(fp)
81143400:	00800804 	movi	r2,32
81143404:	e0bffa85 	stb	r2,-22(fp)
81143408:	00800804 	movi	r2,32
8114340c:	e0bffac5 	stb	r2,-21(fp)
        char extension[3] = { ' ', ' ', ' ' };
81143410:	00800804 	movi	r2,32
81143414:	e0bffb05 	stb	r2,-20(fp)
81143418:	00800804 	movi	r2,32
8114341c:	e0bffb45 	stb	r2,-19(fp)
81143420:	00800804 	movi	r2,32
81143424:	e0bffb85 	stb	r2,-18(fp)
        int ext_index = -1;
81143428:	00bfffc4 	movi	r2,-1
8114342c:	e0bfee15 	stw	r2,-72(fp)
        int new_cluster = home_dir_cluster;
81143430:	e0bfea17 	ldw	r2,-88(fp)
81143434:	e0bfef15 	stw	r2,-68(fp)
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
81143438:	e03fec15 	stw	zero,-80(fp)
8114343c:	00002d06 	br	811434f4 <get_home_directory_cluster_for_file+0x164>
        {
            if (file_name[index+start_location] == '.')
81143440:	e0ffec17 	ldw	r3,-80(fp)
81143444:	e0bfed17 	ldw	r2,-76(fp)
81143448:	1885883a 	add	r2,r3,r2
8114344c:	1007883a 	mov	r3,r2
81143450:	e0bffd17 	ldw	r2,-12(fp)
81143454:	10c5883a 	add	r2,r2,r3
81143458:	10800003 	ldbu	r2,0(r2)
8114345c:	10803fcc 	andi	r2,r2,255
81143460:	1080201c 	xori	r2,r2,128
81143464:	10bfe004 	addi	r2,r2,-128
81143468:	10800b98 	cmpnei	r2,r2,46
8114346c:	1000031e 	bne	r2,zero,8114347c <get_home_directory_cluster_for_file+0xec>
            {
                ext_index = index;
81143470:	e0bfec17 	ldw	r2,-80(fp)
81143474:	e0bfee15 	stw	r2,-72(fp)
81143478:	00001b06 	br	811434e8 <get_home_directory_cluster_for_file+0x158>
            }
            else if (ext_index < 0)
8114347c:	e0bfee17 	ldw	r2,-72(fp)
81143480:	10000c0e 	bge	r2,zero,811434b4 <get_home_directory_cluster_for_file+0x124>
            {
                name[index] = file_name[index+start_location];
81143484:	e0ffec17 	ldw	r3,-80(fp)
81143488:	e0bfed17 	ldw	r2,-76(fp)
8114348c:	1885883a 	add	r2,r3,r2
81143490:	1007883a 	mov	r3,r2
81143494:	e0bffd17 	ldw	r2,-12(fp)
81143498:	10c5883a 	add	r2,r2,r3
8114349c:	10c00003 	ldbu	r3,0(r2)
811434a0:	e13ff904 	addi	r4,fp,-28
811434a4:	e0bfec17 	ldw	r2,-80(fp)
811434a8:	2085883a 	add	r2,r4,r2
811434ac:	10c00005 	stb	r3,0(r2)
811434b0:	00000d06 	br	811434e8 <get_home_directory_cluster_for_file+0x158>
            }
            else
            {
                extension[index-ext_index] = file_name[index+start_location];
811434b4:	e0ffec17 	ldw	r3,-80(fp)
811434b8:	e0bfee17 	ldw	r2,-72(fp)
811434bc:	1885c83a 	sub	r2,r3,r2
811434c0:	e13fec17 	ldw	r4,-80(fp)
811434c4:	e0ffed17 	ldw	r3,-76(fp)
811434c8:	20c7883a 	add	r3,r4,r3
811434cc:	1809883a 	mov	r4,r3
811434d0:	e0fffd17 	ldw	r3,-12(fp)
811434d4:	1907883a 	add	r3,r3,r4
811434d8:	18c00003 	ldbu	r3,0(r3)
811434dc:	e13ffb04 	addi	r4,fp,-20
811434e0:	2085883a 	add	r2,r4,r2
811434e4:	10c00005 	stb	r3,0(r2)
        char extension[3] = { ' ', ' ', ' ' };
        int ext_index = -1;
        int new_cluster = home_dir_cluster;
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
811434e8:	e0bfec17 	ldw	r2,-80(fp)
811434ec:	10800044 	addi	r2,r2,1
811434f0:	e0bfec15 	stw	r2,-80(fp)
811434f4:	e0ffec17 	ldw	r3,-80(fp)
811434f8:	e0bfeb17 	ldw	r2,-84(fp)
811434fc:	18bfd016 	blt	r3,r2,81143440 <__reset+0xfb123440>
            {
                extension[index-ext_index] = file_name[index+start_location];
            }
        }
        
        if (home_dir_cluster == 0)
81143500:	e0bfea17 	ldw	r2,-88(fp)
81143504:	10005c1e 	bne	r2,zero,81143678 <get_home_directory_cluster_for_file+0x2e8>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
81143508:	00a045f4 	movhi	r2,33047
8114350c:	10b20e04 	addi	r2,r2,-14280
81143510:	1080050b 	ldhu	r2,20(r2)
81143514:	10bfffcc 	andi	r2,r2,65535
81143518:	1006917a 	slli	r3,r2,5
8114351c:	00a045f4 	movhi	r2,33047
81143520:	10b20e04 	addi	r2,r2,-14280
81143524:	1080030b 	ldhu	r2,12(r2)
81143528:	10bfffcc 	andi	r2,r2,65535
8114352c:	1885283a 	div	r2,r3,r2
81143530:	e0bff715 	stw	r2,-36(fp)
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81143534:	e03ff015 	stw	zero,-64(fp)
81143538:	00003b06 	br	81143628 <get_home_directory_cluster_for_file+0x298>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
8114353c:	00a045f4 	movhi	r2,33047
81143540:	10b20e04 	addi	r2,r2,-14280
81143544:	10c01317 	ldw	r3,76(r2)
81143548:	e0bff017 	ldw	r2,-64(fp)
8114354c:	1885883a 	add	r2,r3,r2
81143550:	1007883a 	mov	r3,r2
81143554:	d0a0b117 	ldw	r2,-32060(gp)
81143558:	100b883a 	mov	r5,r2
8114355c:	1809883a 	mov	r4,r3
81143560:	1141c280 	call	81141c28 <Read_Sector_Data>
81143564:	10003426 	beq	r2,zero,81143638 <get_home_directory_cluster_for_file+0x2a8>
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
81143568:	e03ff115 	stw	zero,-60(fp)
8114356c:	00002506 	br	81143604 <get_home_directory_cluster_for_file+0x274>
                    {
                       
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
81143570:	e0bff117 	ldw	r2,-60(fp)
81143574:	1004917a 	slli	r2,r2,5
81143578:	e0fff017 	ldw	r3,-64(fp)
8114357c:	180f883a 	mov	r7,r3
81143580:	000d883a 	mov	r6,zero
81143584:	e17fff17 	ldw	r5,-4(fp)
81143588:	1009883a 	mov	r4,r2
8114358c:	11420580 	call	81142058 <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
81143590:	e0bfff17 	ldw	r2,-4(fp)
81143594:	10800003 	ldbu	r2,0(r2)
81143598:	10803fcc 	andi	r2,r2,255
8114359c:	10803960 	cmpeqi	r2,r2,229
811435a0:	1000151e 	bne	r2,zero,811435f8 <get_home_directory_cluster_for_file+0x268>
811435a4:	e0bfff17 	ldw	r2,-4(fp)
811435a8:	10800003 	ldbu	r2,0(r2)
811435ac:	10803fcc 	andi	r2,r2,255
811435b0:	10001126 	beq	r2,zero,811435f8 <get_home_directory_cluster_for_file+0x268>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
811435b4:	e0fffb04 	addi	r3,fp,-20
811435b8:	e0bff904 	addi	r2,fp,-28
811435bc:	180d883a 	mov	r6,r3
811435c0:	100b883a 	mov	r5,r2
811435c4:	e13fff17 	ldw	r4,-4(fp)
811435c8:	11430ec0 	call	811430ec <match_file_record_to_name_ext>
811435cc:	e0bff815 	stw	r2,-32(fp)
                            if (match)
811435d0:	e0bff817 	ldw	r2,-32(fp)
811435d4:	10000826 	beq	r2,zero,811435f8 <get_home_directory_cluster_for_file+0x268>
                            {
                                new_cluster = file_record->start_cluster_index;
811435d8:	e0bfff17 	ldw	r2,-4(fp)
811435dc:	1080058b 	ldhu	r2,22(r2)
811435e0:	10bfffcc 	andi	r2,r2,65535
811435e4:	e0bfef15 	stw	r2,-68(fp)
                                file_record->file_record_cluster = 1; // Home directory is a subdirectory in the root directory.
811435e8:	e0bfff17 	ldw	r2,-4(fp)
811435ec:	00c00044 	movi	r3,1
811435f0:	10c00a15 	stw	r3,40(r2)
                                break;
811435f4:	00000606 	br	81143610 <get_home_directory_cluster_for_file+0x280>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
811435f8:	e0bff117 	ldw	r2,-60(fp)
811435fc:	10800044 	addi	r2,r2,1
81143600:	e0bff115 	stw	r2,-60(fp)
81143604:	e0bff117 	ldw	r2,-60(fp)
81143608:	10800410 	cmplti	r2,r2,16
8114360c:	103fd81e 	bne	r2,zero,81143570 <__reset+0xfb123570>
                }
                else
                {
                    break;
                }
                if (new_cluster != home_dir_cluster)
81143610:	e0ffef17 	ldw	r3,-68(fp)
81143614:	e0bfea17 	ldw	r2,-88(fp)
81143618:	1880091e 	bne	r3,r2,81143640 <get_home_directory_cluster_for_file+0x2b0>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8114361c:	e0bff017 	ldw	r2,-64(fp)
81143620:	10800044 	addi	r2,r2,1
81143624:	e0bff015 	stw	r2,-64(fp)
81143628:	e0fff017 	ldw	r3,-64(fp)
8114362c:	e0bff717 	ldw	r2,-36(fp)
81143630:	18bfc216 	blt	r3,r2,8114353c <__reset+0xfb12353c>
81143634:	00000306 	br	81143644 <get_home_directory_cluster_for_file+0x2b4>
                        }
                    }
                }
                else
                {
                    break;
81143638:	0001883a 	nop
8114363c:	00000106 	br	81143644 <get_home_directory_cluster_for_file+0x2b4>
                }
                if (new_cluster != home_dir_cluster)
                {
                    break;
81143640:	0001883a 	nop
                }
            }
            if (new_cluster != home_dir_cluster)
81143644:	e0ffef17 	ldw	r3,-68(fp)
81143648:	e0bfea17 	ldw	r2,-88(fp)
8114364c:	18800826 	beq	r3,r2,81143670 <get_home_directory_cluster_for_file+0x2e0>
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
81143650:	e0bfef17 	ldw	r2,-68(fp)
81143654:	e0bfea15 	stw	r2,-88(fp)
                start_location = start_location+location+1;
81143658:	e0ffed17 	ldw	r3,-76(fp)
8114365c:	e0bfeb17 	ldw	r2,-84(fp)
81143660:	1885883a 	add	r2,r3,r2
81143664:	10800044 	addi	r2,r2,1
81143668:	e0bfed15 	stw	r2,-76(fp)
8114366c:	00007d06 	br	81143864 <get_home_directory_cluster_for_file+0x4d4>
            }
            else
            {
                // Directory path is invalid. 
                return false;
81143670:	0005883a 	mov	r2,zero
81143674:	00009106 	br	811438bc <get_home_directory_cluster_for_file+0x52c>
            }
        } else {
            // This is a subdirectory that can have any number of elements. So scan through it as though it was a file
            // and see if you can find the directory of interest.
            int cluster = home_dir_cluster;
81143678:	e0bfea17 	ldw	r2,-88(fp)
8114367c:	e0bff415 	stw	r2,-48(fp)
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
81143680:	e0bff417 	ldw	r2,-48(fp)
81143684:	10ffff84 	addi	r3,r2,-2
81143688:	00a045f4 	movhi	r2,33047
8114368c:	10b20e04 	addi	r2,r2,-14280
81143690:	10800383 	ldbu	r2,14(r2)
81143694:	10803fcc 	andi	r2,r2,255
81143698:	1885383a 	mul	r2,r3,r2
8114369c:	1007883a 	mov	r3,r2
811436a0:	00a045f4 	movhi	r2,33047
811436a4:	10b20e04 	addi	r2,r2,-14280
811436a8:	10801417 	ldw	r2,80(r2)
811436ac:	1885883a 	add	r2,r3,r2
811436b0:	e0bff515 	stw	r2,-44(fp)
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
811436b4:	e03ff215 	stw	zero,-56(fp)
811436b8:	00003606 	br	81143794 <get_home_directory_cluster_for_file+0x404>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
811436bc:	e0fff217 	ldw	r3,-56(fp)
811436c0:	e0bff517 	ldw	r2,-44(fp)
811436c4:	1885883a 	add	r2,r3,r2
811436c8:	d0e0b117 	ldw	r3,-32060(gp)
811436cc:	180b883a 	mov	r5,r3
811436d0:	1009883a 	mov	r4,r2
811436d4:	1141c280 	call	81141c28 <Read_Sector_Data>
811436d8:	10003526 	beq	r2,zero,811437b0 <get_home_directory_cluster_for_file+0x420>
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
811436dc:	e03ff315 	stw	zero,-52(fp)
811436e0:	00002306 	br	81143770 <get_home_directory_cluster_for_file+0x3e0>
                        {                         
                            // Read file record.
                            Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
811436e4:	e0bff317 	ldw	r2,-52(fp)
811436e8:	1004917a 	slli	r2,r2,5
811436ec:	e0fff417 	ldw	r3,-48(fp)
811436f0:	e13ff217 	ldw	r4,-56(fp)
811436f4:	200f883a 	mov	r7,r4
811436f8:	180d883a 	mov	r6,r3
811436fc:	e17fff17 	ldw	r5,-4(fp)
81143700:	1009883a 	mov	r4,r2
81143704:	11420580 	call	81142058 <Read_File_Record_At_Offset>
                            if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
81143708:	e0bfff17 	ldw	r2,-4(fp)
8114370c:	10800003 	ldbu	r2,0(r2)
81143710:	10803fcc 	andi	r2,r2,255
81143714:	10803960 	cmpeqi	r2,r2,229
81143718:	1000121e 	bne	r2,zero,81143764 <get_home_directory_cluster_for_file+0x3d4>
8114371c:	e0bfff17 	ldw	r2,-4(fp)
81143720:	10800003 	ldbu	r2,0(r2)
81143724:	10803fcc 	andi	r2,r2,255
81143728:	10000e26 	beq	r2,zero,81143764 <get_home_directory_cluster_for_file+0x3d4>
                            {
								bool match = match_file_record_to_name_ext(file_record, name, extension);
8114372c:	e0fffb04 	addi	r3,fp,-20
81143730:	e0bff904 	addi	r2,fp,-28
81143734:	180d883a 	mov	r6,r3
81143738:	100b883a 	mov	r5,r2
8114373c:	e13fff17 	ldw	r4,-4(fp)
81143740:	11430ec0 	call	811430ec <match_file_record_to_name_ext>
81143744:	e0bff615 	stw	r2,-40(fp)
                                if (match)
81143748:	e0bff617 	ldw	r2,-40(fp)
8114374c:	10000526 	beq	r2,zero,81143764 <get_home_directory_cluster_for_file+0x3d4>
                                {
                                    new_cluster = file_record->start_cluster_index;                                   
81143750:	e0bfff17 	ldw	r2,-4(fp)
81143754:	1080058b 	ldhu	r2,22(r2)
81143758:	10bfffcc 	andi	r2,r2,65535
8114375c:	e0bfef15 	stw	r2,-68(fp)
                                    break;
81143760:	00000606 	br	8114377c <get_home_directory_cluster_for_file+0x3ec>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
81143764:	e0bff317 	ldw	r2,-52(fp)
81143768:	10800044 	addi	r2,r2,1
8114376c:	e0bff315 	stw	r2,-52(fp)
81143770:	e0bff317 	ldw	r2,-52(fp)
81143774:	10800410 	cmplti	r2,r2,16
81143778:	103fda1e 	bne	r2,zero,811436e4 <__reset+0xfb1236e4>
                    }
                    else
                    {
                        break;
                    }
                    if (new_cluster != home_dir_cluster)
8114377c:	e0ffef17 	ldw	r3,-68(fp)
81143780:	e0bfea17 	ldw	r2,-88(fp)
81143784:	18800c1e 	bne	r3,r2,811437b8 <get_home_directory_cluster_for_file+0x428>
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81143788:	e0bff217 	ldw	r2,-56(fp)
8114378c:	10800044 	addi	r2,r2,1
81143790:	e0bff215 	stw	r2,-56(fp)
81143794:	00a045f4 	movhi	r2,33047
81143798:	10b20e04 	addi	r2,r2,-14280
8114379c:	10800383 	ldbu	r2,14(r2)
811437a0:	10803fcc 	andi	r2,r2,255
811437a4:	e0fff217 	ldw	r3,-56(fp)
811437a8:	18bfc416 	blt	r3,r2,811436bc <__reset+0xfb1236bc>
811437ac:	00000306 	br	811437bc <get_home_directory_cluster_for_file+0x42c>
                            }
                        }
                    }
                    else
                    {
                        break;
811437b0:	0001883a 	nop
811437b4:	00000106 	br	811437bc <get_home_directory_cluster_for_file+0x42c>
                    }
                    if (new_cluster != home_dir_cluster)
                    {
                        break;
811437b8:	0001883a 	nop
                    }
                }
                // If this is the end of the cluster and the directory has not been found, then see if there is another cluster
                // that holds data for the current directory.
                if (new_cluster == home_dir_cluster)
811437bc:	e0ffef17 	ldw	r3,-68(fp)
811437c0:	e0bfea17 	ldw	r2,-88(fp)
811437c4:	1880141e 	bne	r3,r2,81143818 <get_home_directory_cluster_for_file+0x488>
                {
					unsigned short int next_cluster;

					if (get_cluster_flag(new_cluster, &next_cluster))
811437c8:	e0bfef17 	ldw	r2,-68(fp)
811437cc:	e0fffc04 	addi	r3,fp,-16
811437d0:	180b883a 	mov	r5,r3
811437d4:	1009883a 	mov	r4,r2
811437d8:	1141d080 	call	81141d08 <get_cluster_flag>
811437dc:	10000c26 	beq	r2,zero,81143810 <get_home_directory_cluster_for_file+0x480>
					{
						// The directory needs to be expanded to store more files.
						if ((next_cluster & 0x0000fff8) == 0x0000fff8)
811437e0:	e0bffc0b 	ldhu	r2,-16(fp)
811437e4:	10bfffcc 	andi	r2,r2,65535
811437e8:	10fffe0c 	andi	r3,r2,65528
811437ec:	00bffe14 	movui	r2,65528
811437f0:	1880021e 	bne	r3,r2,811437fc <get_home_directory_cluster_for_file+0x46c>
						{
							return false;
811437f4:	0005883a 	mov	r2,zero
811437f8:	00003006 	br	811438bc <get_home_directory_cluster_for_file+0x52c>
						}
						new_cluster = (next_cluster & 0x0000fff8);
811437fc:	e0bffc0b 	ldhu	r2,-16(fp)
81143800:	10bfffcc 	andi	r2,r2,65535
81143804:	10bffe0c 	andi	r2,r2,65528
81143808:	e0bfef15 	stw	r2,-68(fp)
8114380c:	00000206 	br	81143818 <get_home_directory_cluster_for_file+0x488>
					}
					else
					{
						// Directory path is invalid.                 
						return false;
81143810:	0005883a 	mov	r2,zero
81143814:	00002906 	br	811438bc <get_home_directory_cluster_for_file+0x52c>
					}
                }              
            } while ((cluster < 0x0000fff8) && (new_cluster == home_dir_cluster));
81143818:	e0bff417 	ldw	r2,-48(fp)
8114381c:	00fffdd4 	movui	r3,65527
81143820:	18800316 	blt	r3,r2,81143830 <get_home_directory_cluster_for_file+0x4a0>
81143824:	e0ffef17 	ldw	r3,-68(fp)
81143828:	e0bfea17 	ldw	r2,-88(fp)
8114382c:	18bf9426 	beq	r3,r2,81143680 <__reset+0xfb123680>
            if (new_cluster != home_dir_cluster)
81143830:	e0ffef17 	ldw	r3,-68(fp)
81143834:	e0bfea17 	ldw	r2,-88(fp)
81143838:	18800826 	beq	r3,r2,8114385c <get_home_directory_cluster_for_file+0x4cc>
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
8114383c:	e0bfef17 	ldw	r2,-68(fp)
81143840:	e0bfea15 	stw	r2,-88(fp)
                start_location = start_location+location+1;
81143844:	e0ffed17 	ldw	r3,-76(fp)
81143848:	e0bfeb17 	ldw	r2,-84(fp)
8114384c:	1885883a 	add	r2,r3,r2
81143850:	10800044 	addi	r2,r2,1
81143854:	e0bfed15 	stw	r2,-76(fp)
81143858:	00000206 	br	81143864 <get_home_directory_cluster_for_file+0x4d4>
            }
            else
            {
                // Directory path is invalid. 
                return false;
8114385c:	0005883a 	mov	r2,zero
81143860:	00001606 	br	811438bc <get_home_directory_cluster_for_file+0x52c>
            }            
        }
        location = get_dir_divider_location(&(file_name[start_location]));
81143864:	e0bfed17 	ldw	r2,-76(fp)
81143868:	e0fffd17 	ldw	r3,-12(fp)
8114386c:	1885883a 	add	r2,r3,r2
81143870:	1009883a 	mov	r4,r2
81143874:	114302c0 	call	8114302c <get_dir_divider_location>
81143878:	e0bfeb15 	stw	r2,-84(fp)
        if (location < 0)
8114387c:	e0bfeb17 	ldw	r2,-84(fp)
81143880:	1000020e 	bge	r2,zero,8114388c <get_home_directory_cluster_for_file+0x4fc>
        {
            // Directory has been located.
            result = true;
81143884:	00800044 	movi	r2,1
81143888:	e0bfe915 	stw	r2,-92(fp)
    int location, index;
    int start_location = 0;
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
    while (location > 0)
8114388c:	e0bfeb17 	ldw	r2,-84(fp)
81143890:	00becf16 	blt	zero,r2,811433d0 <__reset+0xfb1233d0>
            // Directory has been located.
            result = true;
        }
    }
    
    *home_directory_cluster = home_dir_cluster;
81143894:	e0bffe17 	ldw	r2,-8(fp)
81143898:	e0ffea17 	ldw	r3,-88(fp)
8114389c:	10c00015 	stw	r3,0(r2)
    if (home_dir_cluster == 0)
811438a0:	e0bfea17 	ldw	r2,-88(fp)
811438a4:	1000041e 	bne	r2,zero,811438b8 <get_home_directory_cluster_for_file+0x528>
    {
        file_record->file_record_cluster = 0; // Home directory is the root directory.
811438a8:	e0bfff17 	ldw	r2,-4(fp)
811438ac:	10000a15 	stw	zero,40(r2)
		result = true;
811438b0:	00800044 	movi	r2,1
811438b4:	e0bfe915 	stw	r2,-92(fp)
    }
    return result;
811438b8:	e0bfe917 	ldw	r2,-92(fp)
}
811438bc:	e037883a 	mov	sp,fp
811438c0:	dfc00117 	ldw	ra,4(sp)
811438c4:	df000017 	ldw	fp,0(sp)
811438c8:	dec00204 	addi	sp,sp,8
811438cc:	f800283a 	ret

811438d0 <find_file_in_directory>:


bool find_file_in_directory(int directory_start_cluster, char *file_name, t_file_record *file_record)
// Given a cluster and a file name, check if the file already exists. Return the file record if the file is found.
{
811438d0:	deffe804 	addi	sp,sp,-96
811438d4:	de00012e 	bgeu	sp,et,811438dc <find_file_in_directory+0xc>
811438d8:	003b68fa 	trap	3
811438dc:	dfc01715 	stw	ra,92(sp)
811438e0:	df001615 	stw	fp,88(sp)
811438e4:	df001604 	addi	fp,sp,88
811438e8:	e13ffd15 	stw	r4,-12(fp)
811438ec:	e17ffe15 	stw	r5,-8(fp)
811438f0:	e1bfff15 	stw	r6,-4(fp)
    int location = get_dir_divider_location( file_name );
811438f4:	e13ffe17 	ldw	r4,-8(fp)
811438f8:	114302c0 	call	8114302c <get_dir_divider_location>
811438fc:	e0bfea15 	stw	r2,-88(fp)
    int last_dir_separator = 0;
81143900:	e03feb15 	stw	zero,-84(fp)
    char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
81143904:	00800804 	movi	r2,32
81143908:	e0bff905 	stb	r2,-28(fp)
8114390c:	00800804 	movi	r2,32
81143910:	e0bff945 	stb	r2,-27(fp)
81143914:	00800804 	movi	r2,32
81143918:	e0bff985 	stb	r2,-26(fp)
8114391c:	00800804 	movi	r2,32
81143920:	e0bff9c5 	stb	r2,-25(fp)
81143924:	00800804 	movi	r2,32
81143928:	e0bffa05 	stb	r2,-24(fp)
8114392c:	00800804 	movi	r2,32
81143930:	e0bffa45 	stb	r2,-23(fp)
81143934:	00800804 	movi	r2,32
81143938:	e0bffa85 	stb	r2,-22(fp)
8114393c:	00800804 	movi	r2,32
81143940:	e0bffac5 	stb	r2,-21(fp)
    char extension[3] = { ' ', ' ', ' ' };
81143944:	00800804 	movi	r2,32
81143948:	e0bffb05 	stb	r2,-20(fp)
8114394c:	00800804 	movi	r2,32
81143950:	e0bffb45 	stb	r2,-19(fp)
81143954:	00800804 	movi	r2,32
81143958:	e0bffb85 	stb	r2,-18(fp)
    int ext_index = -1;
8114395c:	00bfffc4 	movi	r2,-1
81143960:	e0bfec15 	stw	r2,-80(fp)
    int cluster = directory_start_cluster;
81143964:	e0bffd17 	ldw	r2,-12(fp)
81143968:	e0bfed15 	stw	r2,-76(fp)
    int index;
	int length = strlen(file_name);
8114396c:	e13ffe17 	ldw	r4,-8(fp)
81143970:	1122b480 	call	81122b48 <strlen>
81143974:	e0bff415 	stw	r2,-48(fp)
    bool result = false;
81143978:	e03fef15 	stw	zero,-68(fp)
    
    // Skip through all directory separators.
    while (location > 0)
8114397c:	00000b06 	br	811439ac <find_file_in_directory+0xdc>
    {
        last_dir_separator = last_dir_separator+location+1;
81143980:	e0ffeb17 	ldw	r3,-84(fp)
81143984:	e0bfea17 	ldw	r2,-88(fp)
81143988:	1885883a 	add	r2,r3,r2
8114398c:	10800044 	addi	r2,r2,1
81143990:	e0bfeb15 	stw	r2,-84(fp)
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
81143994:	e0bfeb17 	ldw	r2,-84(fp)
81143998:	e0fffe17 	ldw	r3,-8(fp)
8114399c:	1885883a 	add	r2,r3,r2
811439a0:	1009883a 	mov	r4,r2
811439a4:	114302c0 	call	8114302c <get_dir_divider_location>
811439a8:	e0bfea15 	stw	r2,-88(fp)
    int index;
	int length = strlen(file_name);
    bool result = false;
    
    // Skip through all directory separators.
    while (location > 0)
811439ac:	e0bfea17 	ldw	r2,-88(fp)
811439b0:	00bff316 	blt	zero,r2,81143980 <__reset+0xfb123980>
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
811439b4:	e0bfeb17 	ldw	r2,-84(fp)
811439b8:	e0bfee15 	stw	r2,-72(fp)
811439bc:	00002706 	br	81143a5c <find_file_in_directory+0x18c>
    {
        if (file_name[index] == '.')
811439c0:	e0bfee17 	ldw	r2,-72(fp)
811439c4:	e0fffe17 	ldw	r3,-8(fp)
811439c8:	1885883a 	add	r2,r3,r2
811439cc:	10800003 	ldbu	r2,0(r2)
811439d0:	10803fcc 	andi	r2,r2,255
811439d4:	1080201c 	xori	r2,r2,128
811439d8:	10bfe004 	addi	r2,r2,-128
811439dc:	10800b98 	cmpnei	r2,r2,46
811439e0:	1000031e 	bne	r2,zero,811439f0 <find_file_in_directory+0x120>
        {
            ext_index = index;
811439e4:	e0bfee17 	ldw	r2,-72(fp)
811439e8:	e0bfec15 	stw	r2,-80(fp)
811439ec:	00001806 	br	81143a50 <find_file_in_directory+0x180>
        }
        else if (ext_index < 0)
811439f0:	e0bfec17 	ldw	r2,-80(fp)
811439f4:	10000b0e 	bge	r2,zero,81143a24 <find_file_in_directory+0x154>
        {
            name[index-last_dir_separator] = file_name[index];
811439f8:	e0ffee17 	ldw	r3,-72(fp)
811439fc:	e0bfeb17 	ldw	r2,-84(fp)
81143a00:	1885c83a 	sub	r2,r3,r2
81143a04:	e0ffee17 	ldw	r3,-72(fp)
81143a08:	e13ffe17 	ldw	r4,-8(fp)
81143a0c:	20c7883a 	add	r3,r4,r3
81143a10:	18c00003 	ldbu	r3,0(r3)
81143a14:	e13ff904 	addi	r4,fp,-28
81143a18:	2085883a 	add	r2,r4,r2
81143a1c:	10c00005 	stb	r3,0(r2)
81143a20:	00000b06 	br	81143a50 <find_file_in_directory+0x180>
        }
        else
        {
            extension[index-ext_index-1] = file_name[index];
81143a24:	e0ffee17 	ldw	r3,-72(fp)
81143a28:	e0bfec17 	ldw	r2,-80(fp)
81143a2c:	1885c83a 	sub	r2,r3,r2
81143a30:	10bfffc4 	addi	r2,r2,-1
81143a34:	e0ffee17 	ldw	r3,-72(fp)
81143a38:	e13ffe17 	ldw	r4,-8(fp)
81143a3c:	20c7883a 	add	r3,r4,r3
81143a40:	18c00003 	ldbu	r3,0(r3)
81143a44:	e13ffb04 	addi	r4,fp,-20
81143a48:	2085883a 	add	r2,r4,r2
81143a4c:	10c00005 	stb	r3,0(r2)
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
81143a50:	e0bfee17 	ldw	r2,-72(fp)
81143a54:	10800044 	addi	r2,r2,1
81143a58:	e0bfee15 	stw	r2,-72(fp)
81143a5c:	e0ffee17 	ldw	r3,-72(fp)
81143a60:	e0bff417 	ldw	r2,-48(fp)
81143a64:	18bfd616 	blt	r3,r2,811439c0 <__reset+0xfb1239c0>
            extension[index-ext_index-1] = file_name[index];
        }
    }

    // Look for the file.
    if (directory_start_cluster == 0)
81143a68:	e0bffd17 	ldw	r2,-12(fp)
81143a6c:	1000461e 	bne	r2,zero,81143b88 <find_file_in_directory+0x2b8>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
81143a70:	00a045f4 	movhi	r2,33047
81143a74:	10b20e04 	addi	r2,r2,-14280
81143a78:	1080050b 	ldhu	r2,20(r2)
81143a7c:	10bfffcc 	andi	r2,r2,65535
81143a80:	1006917a 	slli	r3,r2,5
81143a84:	00a045f4 	movhi	r2,33047
81143a88:	10b20e04 	addi	r2,r2,-14280
81143a8c:	1080030b 	ldhu	r2,12(r2)
81143a90:	10bfffcc 	andi	r2,r2,65535
81143a94:	1885283a 	div	r2,r3,r2
81143a98:	e0bff715 	stw	r2,-36(fp)
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81143a9c:	e03ff015 	stw	zero,-64(fp)
81143aa0:	00003506 	br	81143b78 <find_file_in_directory+0x2a8>
        {
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
81143aa4:	00a045f4 	movhi	r2,33047
81143aa8:	10b20e04 	addi	r2,r2,-14280
81143aac:	10c01317 	ldw	r3,76(r2)
81143ab0:	e0bff017 	ldw	r2,-64(fp)
81143ab4:	1885883a 	add	r2,r3,r2
81143ab8:	1007883a 	mov	r3,r2
81143abc:	d0a0b117 	ldw	r2,-32060(gp)
81143ac0:	100b883a 	mov	r5,r2
81143ac4:	1809883a 	mov	r4,r3
81143ac8:	1141c280 	call	81141c28 <Read_Sector_Data>
81143acc:	10009626 	beq	r2,zero,81143d28 <find_file_in_directory+0x458>
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
81143ad0:	e03ff115 	stw	zero,-60(fp)
81143ad4:	00002006 	br	81143b58 <find_file_in_directory+0x288>
                {
                    // Read file record.
                    Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
81143ad8:	e0bff117 	ldw	r2,-60(fp)
81143adc:	1004917a 	slli	r2,r2,5
81143ae0:	e0fff017 	ldw	r3,-64(fp)
81143ae4:	180f883a 	mov	r7,r3
81143ae8:	000d883a 	mov	r6,zero
81143aec:	e17fff17 	ldw	r5,-4(fp)
81143af0:	1009883a 	mov	r4,r2
81143af4:	11420580 	call	81142058 <Read_File_Record_At_Offset>
                    if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
81143af8:	e0bfff17 	ldw	r2,-4(fp)
81143afc:	10800003 	ldbu	r2,0(r2)
81143b00:	10803fcc 	andi	r2,r2,255
81143b04:	10803960 	cmpeqi	r2,r2,229
81143b08:	1000101e 	bne	r2,zero,81143b4c <find_file_in_directory+0x27c>
81143b0c:	e0bfff17 	ldw	r2,-4(fp)
81143b10:	10800003 	ldbu	r2,0(r2)
81143b14:	10803fcc 	andi	r2,r2,255
81143b18:	10000c26 	beq	r2,zero,81143b4c <find_file_in_directory+0x27c>
                    {
                        bool match = match_file_record_to_name_ext(file_record, name, extension);
81143b1c:	e0fffb04 	addi	r3,fp,-20
81143b20:	e0bff904 	addi	r2,fp,-28
81143b24:	180d883a 	mov	r6,r3
81143b28:	100b883a 	mov	r5,r2
81143b2c:	e13fff17 	ldw	r4,-4(fp)
81143b30:	11430ec0 	call	811430ec <match_file_record_to_name_ext>
81143b34:	e0bff815 	stw	r2,-32(fp)

                        if (match)
81143b38:	e0bff817 	ldw	r2,-32(fp)
81143b3c:	10000326 	beq	r2,zero,81143b4c <find_file_in_directory+0x27c>
                        {
                            result = true;
81143b40:	00800044 	movi	r2,1
81143b44:	e0bfef15 	stw	r2,-68(fp)
                            break;
81143b48:	00000606 	br	81143b64 <find_file_in_directory+0x294>
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
81143b4c:	e0bff117 	ldw	r2,-60(fp)
81143b50:	10800044 	addi	r2,r2,1
81143b54:	e0bff115 	stw	r2,-60(fp)
81143b58:	e0bff117 	ldw	r2,-60(fp)
81143b5c:	10800410 	cmplti	r2,r2,16
81143b60:	103fdd1e 	bne	r2,zero,81143ad8 <__reset+0xfb123ad8>
            }
            else
            {
                break;
            }
            if (result)
81143b64:	e0bfef17 	ldw	r2,-68(fp)
81143b68:	1000711e 	bne	r2,zero,81143d30 <find_file_in_directory+0x460>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81143b6c:	e0bff017 	ldw	r2,-64(fp)
81143b70:	10800044 	addi	r2,r2,1
81143b74:	e0bff015 	stw	r2,-64(fp)
81143b78:	e0fff017 	ldw	r3,-64(fp)
81143b7c:	e0bff717 	ldw	r2,-36(fp)
81143b80:	18bfc816 	blt	r3,r2,81143aa4 <__reset+0xfb123aa4>
81143b84:	00006b06 	br	81143d34 <find_file_in_directory+0x464>
        }
    }
    else
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
81143b88:	e0bfed17 	ldw	r2,-76(fp)
81143b8c:	10ffff84 	addi	r3,r2,-2
81143b90:	00a045f4 	movhi	r2,33047
81143b94:	10b20e04 	addi	r2,r2,-14280
81143b98:	10800383 	ldbu	r2,14(r2)
81143b9c:	10803fcc 	andi	r2,r2,255
81143ba0:	1885383a 	mul	r2,r3,r2
81143ba4:	1007883a 	mov	r3,r2
81143ba8:	00a045f4 	movhi	r2,33047
81143bac:	10b20e04 	addi	r2,r2,-14280
81143bb0:	10801417 	ldw	r2,80(r2)
81143bb4:	1885883a 	add	r2,r3,r2
81143bb8:	e0bff515 	stw	r2,-44(fp)
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81143bbc:	e03ff215 	stw	zero,-56(fp)
81143bc0:	00003306 	br	81143c90 <find_file_in_directory+0x3c0>
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
81143bc4:	e0fff217 	ldw	r3,-56(fp)
81143bc8:	e0bff517 	ldw	r2,-44(fp)
81143bcc:	1885883a 	add	r2,r3,r2
81143bd0:	d0e0b117 	ldw	r3,-32060(gp)
81143bd4:	180b883a 	mov	r5,r3
81143bd8:	1009883a 	mov	r4,r2
81143bdc:	1141c280 	call	81141c28 <Read_Sector_Data>
81143be0:	10003226 	beq	r2,zero,81143cac <find_file_in_directory+0x3dc>
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
81143be4:	e03ff315 	stw	zero,-52(fp)
81143be8:	00002106 	br	81143c70 <find_file_in_directory+0x3a0>
                    {
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
81143bec:	e0bff317 	ldw	r2,-52(fp)
81143bf0:	1004917a 	slli	r2,r2,5
81143bf4:	e0ffed17 	ldw	r3,-76(fp)
81143bf8:	e13ff217 	ldw	r4,-56(fp)
81143bfc:	200f883a 	mov	r7,r4
81143c00:	180d883a 	mov	r6,r3
81143c04:	e17fff17 	ldw	r5,-4(fp)
81143c08:	1009883a 	mov	r4,r2
81143c0c:	11420580 	call	81142058 <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
81143c10:	e0bfff17 	ldw	r2,-4(fp)
81143c14:	10800003 	ldbu	r2,0(r2)
81143c18:	10803fcc 	andi	r2,r2,255
81143c1c:	10803960 	cmpeqi	r2,r2,229
81143c20:	1000101e 	bne	r2,zero,81143c64 <find_file_in_directory+0x394>
81143c24:	e0bfff17 	ldw	r2,-4(fp)
81143c28:	10800003 	ldbu	r2,0(r2)
81143c2c:	10803fcc 	andi	r2,r2,255
81143c30:	10000c26 	beq	r2,zero,81143c64 <find_file_in_directory+0x394>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
81143c34:	e0fffb04 	addi	r3,fp,-20
81143c38:	e0bff904 	addi	r2,fp,-28
81143c3c:	180d883a 	mov	r6,r3
81143c40:	100b883a 	mov	r5,r2
81143c44:	e13fff17 	ldw	r4,-4(fp)
81143c48:	11430ec0 	call	811430ec <match_file_record_to_name_ext>
81143c4c:	e0bff615 	stw	r2,-40(fp)

                            if (match)
81143c50:	e0bff617 	ldw	r2,-40(fp)
81143c54:	10000326 	beq	r2,zero,81143c64 <find_file_in_directory+0x394>
                            {                               
                                result = true;
81143c58:	00800044 	movi	r2,1
81143c5c:	e0bfef15 	stw	r2,-68(fp)
                                break;
81143c60:	00000606 	br	81143c7c <find_file_in_directory+0x3ac>
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
81143c64:	e0bff317 	ldw	r2,-52(fp)
81143c68:	10800044 	addi	r2,r2,1
81143c6c:	e0bff315 	stw	r2,-52(fp)
81143c70:	e0bff317 	ldw	r2,-52(fp)
81143c74:	10800410 	cmplti	r2,r2,16
81143c78:	103fdc1e 	bne	r2,zero,81143bec <__reset+0xfb123bec>
                }
                else
                {
                    break;
                }
                if (result)
81143c7c:	e0bfef17 	ldw	r2,-68(fp)
81143c80:	10000c1e 	bne	r2,zero,81143cb4 <find_file_in_directory+0x3e4>
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81143c84:	e0bff217 	ldw	r2,-56(fp)
81143c88:	10800044 	addi	r2,r2,1
81143c8c:	e0bff215 	stw	r2,-56(fp)
81143c90:	00a045f4 	movhi	r2,33047
81143c94:	10b20e04 	addi	r2,r2,-14280
81143c98:	10800383 	ldbu	r2,14(r2)
81143c9c:	10803fcc 	andi	r2,r2,255
81143ca0:	e0fff217 	ldw	r3,-56(fp)
81143ca4:	18bfc716 	blt	r3,r2,81143bc4 <__reset+0xfb123bc4>
81143ca8:	00000306 	br	81143cb8 <find_file_in_directory+0x3e8>
                        }
                    }
                }
                else
                {
                    break;
81143cac:	0001883a 	nop
81143cb0:	00000106 	br	81143cb8 <find_file_in_directory+0x3e8>
                }
                if (result)
                {
                    break;
81143cb4:	0001883a 	nop
                }
            }
            // If this is the end of the cluster and the file has not been found, then see if there is another cluster
            // that holds data for the current directory.
            if (result == false)
81143cb8:	e0bfef17 	ldw	r2,-68(fp)
81143cbc:	1000141e 	bne	r2,zero,81143d10 <find_file_in_directory+0x440>
            {
				unsigned short int new_cluster;

				if (get_cluster_flag(cluster, &new_cluster))
81143cc0:	e0bfed17 	ldw	r2,-76(fp)
81143cc4:	e0fffc04 	addi	r3,fp,-16
81143cc8:	180b883a 	mov	r5,r3
81143ccc:	1009883a 	mov	r4,r2
81143cd0:	1141d080 	call	81141d08 <get_cluster_flag>
81143cd4:	10000c26 	beq	r2,zero,81143d08 <find_file_in_directory+0x438>
				{
					// The directory needs to be expanded to store more files.
					if ((new_cluster & 0x0000fff8) == 0x0000fff8)
81143cd8:	e0bffc0b 	ldhu	r2,-16(fp)
81143cdc:	10bfffcc 	andi	r2,r2,65535
81143ce0:	10fffe0c 	andi	r3,r2,65528
81143ce4:	00bffe14 	movui	r2,65528
81143ce8:	1880021e 	bne	r3,r2,81143cf4 <find_file_in_directory+0x424>
					{
						return false;
81143cec:	0005883a 	mov	r2,zero
81143cf0:	00001106 	br	81143d38 <find_file_in_directory+0x468>
					}
					cluster = (new_cluster & 0x0000fff8);
81143cf4:	e0bffc0b 	ldhu	r2,-16(fp)
81143cf8:	10bfffcc 	andi	r2,r2,65535
81143cfc:	10bffe0c 	andi	r2,r2,65528
81143d00:	e0bfed15 	stw	r2,-76(fp)
81143d04:	00000206 	br	81143d10 <find_file_in_directory+0x440>
				}
				else
                {
                    // Directory path is invalid.                 
                    return false;
81143d08:	0005883a 	mov	r2,zero
81143d0c:	00000a06 	br	81143d38 <find_file_in_directory+0x468>
                }
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
81143d10:	e0bfed17 	ldw	r2,-76(fp)
81143d14:	00fffdd4 	movui	r3,65527
81143d18:	18800616 	blt	r3,r2,81143d34 <find_file_in_directory+0x464>
81143d1c:	e0bfef17 	ldw	r2,-68(fp)
81143d20:	103f9926 	beq	r2,zero,81143b88 <__reset+0xfb123b88>
81143d24:	00000306 	br	81143d34 <find_file_in_directory+0x464>
                    }
                }
            }
            else
            {
                break;
81143d28:	0001883a 	nop
81143d2c:	00000106 	br	81143d34 <find_file_in_directory+0x464>
            }
            if (result)
            {
                break;
81143d30:	0001883a 	nop
                }
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
    }
    
    return result;   
81143d34:	e0bfef17 	ldw	r2,-68(fp)
}
81143d38:	e037883a 	mov	sp,fp
81143d3c:	dfc00117 	ldw	ra,4(sp)
81143d40:	df000017 	ldw	fp,0(sp)
81143d44:	dec00204 	addi	sp,sp,8
81143d48:	f800283a 	ret

81143d4c <find_first_empty_cluster>:


bool find_first_empty_cluster(unsigned int *cluster_number)
// Find the first empty cluster. It will be marked by a 0 entry in the File Allocation Table.
{
81143d4c:	defff504 	addi	sp,sp,-44
81143d50:	de00012e 	bgeu	sp,et,81143d58 <find_first_empty_cluster+0xc>
81143d54:	003b68fa 	trap	3
81143d58:	dfc00a15 	stw	ra,40(sp)
81143d5c:	df000915 	stw	fp,36(sp)
81143d60:	df000904 	addi	fp,sp,36
81143d64:	e13fff15 	stw	r4,-4(fp)
    unsigned int sector = boot_sector_data.first_fat_sector_offset;
81143d68:	00a045f4 	movhi	r2,33047
81143d6c:	10b20e04 	addi	r2,r2,-14280
81143d70:	10801117 	ldw	r2,68(r2)
81143d74:	e0bff715 	stw	r2,-36(fp)
    unsigned int cluster_index = 2;
81143d78:	00800084 	movi	r2,2
81143d7c:	e0bff815 	stw	r2,-32(fp)
    short int cluster = -1;
81143d80:	00bfffc4 	movi	r2,-1
81143d84:	e0bff90d 	sth	r2,-28(fp)
    bool result = false;
81143d88:	e03ffa15 	stw	zero,-24(fp)
	unsigned max_cluster_index = 0;
81143d8c:	e03ffb15 	stw	zero,-20(fp)
	unsigned int non_data_sectors = boot_sector_data.data_sector_offset;
81143d90:	00a045f4 	movhi	r2,33047
81143d94:	10b20e04 	addi	r2,r2,-14280
81143d98:	10801417 	ldw	r2,80(r2)
81143d9c:	e0bffc15 	stw	r2,-16(fp)
	unsigned int less_than_32 = boot_sector_data.number_of_sectors_in_partition;
81143da0:	00a045f4 	movhi	r2,33047
81143da4:	10b20e04 	addi	r2,r2,-14280
81143da8:	1080058b 	ldhu	r2,22(r2)
81143dac:	10bfffcc 	andi	r2,r2,65535
81143db0:	e0bffd15 	stw	r2,-12(fp)
	unsigned int greater_than_32 = boot_sector_data.total_sector_count_if_above_32MB;
81143db4:	00a045f4 	movhi	r2,33047
81143db8:	10b20e04 	addi	r2,r2,-14280
81143dbc:	10800917 	ldw	r2,36(r2)
81143dc0:	e0bffe15 	stw	r2,-8(fp)

	if (less_than_32 > greater_than_32)
81143dc4:	e0bffd17 	ldw	r2,-12(fp)
81143dc8:	e0fffe17 	ldw	r3,-8(fp)
81143dcc:	18800b2e 	bgeu	r3,r2,81143dfc <find_first_empty_cluster+0xb0>
	{
		max_cluster_index = ((less_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
81143dd0:	e0fffd17 	ldw	r3,-12(fp)
81143dd4:	e0bffc17 	ldw	r2,-16(fp)
81143dd8:	1887c83a 	sub	r3,r3,r2
81143ddc:	00a045f4 	movhi	r2,33047
81143de0:	10b20e04 	addi	r2,r2,-14280
81143de4:	10800383 	ldbu	r2,14(r2)
81143de8:	10803fcc 	andi	r2,r2,255
81143dec:	1885203a 	divu	r2,r3,r2
81143df0:	10800044 	addi	r2,r2,1
81143df4:	e0bffb15 	stw	r2,-20(fp)
81143df8:	00002a06 	br	81143ea4 <find_first_empty_cluster+0x158>
	}
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
81143dfc:	e0fffe17 	ldw	r3,-8(fp)
81143e00:	e0bffc17 	ldw	r2,-16(fp)
81143e04:	1887c83a 	sub	r3,r3,r2
81143e08:	00a045f4 	movhi	r2,33047
81143e0c:	10b20e04 	addi	r2,r2,-14280
81143e10:	10800383 	ldbu	r2,14(r2)
81143e14:	10803fcc 	andi	r2,r2,255
81143e18:	1885203a 	divu	r2,r3,r2
81143e1c:	10800044 	addi	r2,r2,1
81143e20:	e0bffb15 	stw	r2,-20(fp)
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
81143e24:	00001f06 	br	81143ea4 <find_first_empty_cluster+0x158>
    {
        if (Read_Sector_Data( sector, fat_partition_offset_in_512_byte_sectors))
81143e28:	e0bff717 	ldw	r2,-36(fp)
81143e2c:	d0e0b117 	ldw	r3,-32060(gp)
81143e30:	180b883a 	mov	r5,r3
81143e34:	1009883a 	mov	r4,r2
81143e38:	1141c280 	call	81141c28 <Read_Sector_Data>
81143e3c:	10001426 	beq	r2,zero,81143e90 <find_first_empty_cluster+0x144>
        {
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
81143e40:	e0bff817 	ldw	r2,-32(fp)
81143e44:	10803fcc 	andi	r2,r2,255
81143e48:	1085883a 	add	r2,r2,r2
81143e4c:	1007883a 	mov	r3,r2
81143e50:	d0a0b317 	ldw	r2,-32052(gp)
81143e54:	10800a17 	ldw	r2,40(r2)
81143e58:	1885883a 	add	r2,r3,r2
81143e5c:	1080002b 	ldhuio	r2,0(r2)
81143e60:	10bfffcc 	andi	r2,r2,65535
81143e64:	e0bff90d 	sth	r2,-28(fp)
                if (cluster == 0)
81143e68:	e0bff90f 	ldh	r2,-28(fp)
81143e6c:	10000726 	beq	r2,zero,81143e8c <find_first_empty_cluster+0x140>
                    // Free cluster found.
                    break;
                }
                else
                {
                    cluster_index++;
81143e70:	e0bff817 	ldw	r2,-32(fp)
81143e74:	10800044 	addi	r2,r2,1
81143e78:	e0bff815 	stw	r2,-32(fp)
                } 
            } while ((cluster_index % 256) != 0);
81143e7c:	e0bff817 	ldw	r2,-32(fp)
81143e80:	10803fcc 	andi	r2,r2,255
81143e84:	103fee1e 	bne	r2,zero,81143e40 <__reset+0xfb123e40>
81143e88:	00000106 	br	81143e90 <find_first_empty_cluster+0x144>
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
                if (cluster == 0)
                {
                    // Free cluster found.
                    break;
81143e8c:	0001883a 	nop
                {
                    cluster_index++;
                } 
            } while ((cluster_index % 256) != 0);
        }
        if (cluster == 0)
81143e90:	e0bff90f 	ldh	r2,-28(fp)
81143e94:	10000926 	beq	r2,zero,81143ebc <find_first_empty_cluster+0x170>
        {
            break;
        }
        sector++;
81143e98:	e0bff717 	ldw	r2,-36(fp)
81143e9c:	10800044 	addi	r2,r2,1
81143ea0:	e0bff715 	stw	r2,-36(fp)
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
81143ea4:	00a045f4 	movhi	r2,33047
81143ea8:	10b20e04 	addi	r2,r2,-14280
81143eac:	10c01217 	ldw	r3,72(r2)
81143eb0:	e0bff717 	ldw	r2,-36(fp)
81143eb4:	18bfdc1e 	bne	r3,r2,81143e28 <__reset+0xfb123e28>
81143eb8:	00000106 	br	81143ec0 <find_first_empty_cluster+0x174>
                } 
            } while ((cluster_index % 256) != 0);
        }
        if (cluster == 0)
        {
            break;
81143ebc:	0001883a 	nop
        }
        sector++;
    }
    if ((cluster == 0) && (cluster <= max_cluster_index))
81143ec0:	e0bff90f 	ldh	r2,-28(fp)
81143ec4:	1000081e 	bne	r2,zero,81143ee8 <find_first_empty_cluster+0x19c>
81143ec8:	e0bff90f 	ldh	r2,-28(fp)
81143ecc:	e0fffb17 	ldw	r3,-20(fp)
81143ed0:	18800536 	bltu	r3,r2,81143ee8 <find_first_empty_cluster+0x19c>
    {
        *cluster_number = cluster_index;
81143ed4:	e0bfff17 	ldw	r2,-4(fp)
81143ed8:	e0fff817 	ldw	r3,-32(fp)
81143edc:	10c00015 	stw	r3,0(r2)
		result = true;
81143ee0:	00800044 	movi	r2,1
81143ee4:	e0bffa15 	stw	r2,-24(fp)
    }
    return result;
81143ee8:	e0bffa17 	ldw	r2,-24(fp)
}
81143eec:	e037883a 	mov	sp,fp
81143ef0:	dfc00117 	ldw	ra,4(sp)
81143ef4:	df000017 	ldw	fp,0(sp)
81143ef8:	dec00204 	addi	sp,sp,8
81143efc:	f800283a 	ret

81143f00 <find_first_empty_record_in_a_subdirectory>:


int find_first_empty_record_in_a_subdirectory(int start_cluster_index)
// Search for a free spot in a subdirectory. Return an encoded location for the file record.
{
81143f00:	defff604 	addi	sp,sp,-40
81143f04:	de00012e 	bgeu	sp,et,81143f0c <find_first_empty_record_in_a_subdirectory+0xc>
81143f08:	003b68fa 	trap	3
81143f0c:	dfc00915 	stw	ra,36(sp)
81143f10:	df000815 	stw	fp,32(sp)
81143f14:	df000804 	addi	fp,sp,32
81143f18:	e13fff15 	stw	r4,-4(fp)
    int result = -1;
81143f1c:	00bfffc4 	movi	r2,-1
81143f20:	e0bff815 	stw	r2,-32(fp)
    int cluster = start_cluster_index;
81143f24:	e0bfff17 	ldw	r2,-4(fp)
81143f28:	e0bff915 	stw	r2,-28(fp)
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
81143f2c:	e0bff917 	ldw	r2,-28(fp)
81143f30:	10ffff84 	addi	r3,r2,-2
81143f34:	00a045f4 	movhi	r2,33047
81143f38:	10b20e04 	addi	r2,r2,-14280
81143f3c:	10800383 	ldbu	r2,14(r2)
81143f40:	10803fcc 	andi	r2,r2,255
81143f44:	1885383a 	mul	r2,r3,r2
81143f48:	1007883a 	mov	r3,r2
81143f4c:	00a045f4 	movhi	r2,33047
81143f50:	10b20e04 	addi	r2,r2,-14280
81143f54:	10801417 	ldw	r2,80(r2)
81143f58:	1885883a 	add	r2,r3,r2
81143f5c:	e0bffc15 	stw	r2,-16(fp)
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81143f60:	e03ffa15 	stw	zero,-24(fp)
81143f64:	00002c06 	br	81144018 <find_first_empty_record_in_a_subdirectory+0x118>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
81143f68:	e0fffa17 	ldw	r3,-24(fp)
81143f6c:	e0bffc17 	ldw	r2,-16(fp)
81143f70:	1885883a 	add	r2,r3,r2
81143f74:	d0e0b117 	ldw	r3,-32060(gp)
81143f78:	180b883a 	mov	r5,r3
81143f7c:	1009883a 	mov	r4,r2
81143f80:	1141c280 	call	81141c28 <Read_Sector_Data>
81143f84:	10002b26 	beq	r2,zero,81144034 <find_first_empty_record_in_a_subdirectory+0x134>
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
81143f88:	e03ffb15 	stw	zero,-20(fp)
81143f8c:	00001c06 	br	81144000 <find_first_empty_record_in_a_subdirectory+0x100>
                {
                    unsigned short int leading_char;
                    
                    // Read file record.
                    leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
81143f90:	e0bffb17 	ldw	r2,-20(fp)
81143f94:	1004917a 	slli	r2,r2,5
81143f98:	1007883a 	mov	r3,r2
81143f9c:	d0a0b317 	ldw	r2,-32052(gp)
81143fa0:	10800a17 	ldw	r2,40(r2)
81143fa4:	1885883a 	add	r2,r3,r2
81143fa8:	10800023 	ldbuio	r2,0(r2)
81143fac:	10803fcc 	andi	r2,r2,255
81143fb0:	10803fcc 	andi	r2,r2,255
81143fb4:	e0bffd0d 	sth	r2,-12(fp)
                    if ((leading_char == 0x00e5) || (leading_char == 0))
81143fb8:	e0bffd0b 	ldhu	r2,-12(fp)
81143fbc:	10803960 	cmpeqi	r2,r2,229
81143fc0:	1000021e 	bne	r2,zero,81143fcc <find_first_empty_record_in_a_subdirectory+0xcc>
81143fc4:	e0bffd0b 	ldhu	r2,-12(fp)
81143fc8:	10000a1e 	bne	r2,zero,81143ff4 <find_first_empty_record_in_a_subdirectory+0xf4>
                    {
                        result = (cluster) | ((sector_index*16 + file_counter) << 16);
81143fcc:	e0bffa17 	ldw	r2,-24(fp)
81143fd0:	1006913a 	slli	r3,r2,4
81143fd4:	e0bffb17 	ldw	r2,-20(fp)
81143fd8:	1885883a 	add	r2,r3,r2
81143fdc:	1006943a 	slli	r3,r2,16
81143fe0:	e0bff917 	ldw	r2,-28(fp)
81143fe4:	1884b03a 	or	r2,r3,r2
81143fe8:	e0bff815 	stw	r2,-32(fp)
                        return result;
81143fec:	e0bff817 	ldw	r2,-32(fp)
81143ff0:	00005306 	br	81144140 <find_first_empty_record_in_a_subdirectory+0x240>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
81143ff4:	e0bffb17 	ldw	r2,-20(fp)
81143ff8:	10800044 	addi	r2,r2,1
81143ffc:	e0bffb15 	stw	r2,-20(fp)
81144000:	e0bffb17 	ldw	r2,-20(fp)
81144004:	10800410 	cmplti	r2,r2,16
81144008:	103fe11e 	bne	r2,zero,81143f90 <__reset+0xfb123f90>
    int cluster = start_cluster_index;
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8114400c:	e0bffa17 	ldw	r2,-24(fp)
81144010:	10800044 	addi	r2,r2,1
81144014:	e0bffa15 	stw	r2,-24(fp)
81144018:	00a045f4 	movhi	r2,33047
8114401c:	10b20e04 	addi	r2,r2,-14280
81144020:	10800383 	ldbu	r2,14(r2)
81144024:	10803fcc 	andi	r2,r2,255
81144028:	e0fffa17 	ldw	r3,-24(fp)
8114402c:	18bfce16 	blt	r3,r2,81143f68 <__reset+0xfb123f68>
81144030:	00000106 	br	81144038 <find_first_empty_record_in_a_subdirectory+0x138>
                    }
                }
            }
            else
            {
                break;
81144034:	0001883a 	nop
            }
        }
        // If this is the end of the cluster and the file has not been found, then see if there is another cluster
        // that holds data for the current directory.
        if (result < 0)
81144038:	e0bff817 	ldw	r2,-32(fp)
8114403c:	1000390e 	bge	r2,zero,81144124 <find_first_empty_record_in_a_subdirectory+0x224>
        {
			unsigned short int new_cluster;
			if (get_cluster_flag(cluster, &new_cluster))
81144040:	e0bff917 	ldw	r2,-28(fp)
81144044:	e0fffd84 	addi	r3,fp,-10
81144048:	180b883a 	mov	r5,r3
8114404c:	1009883a 	mov	r4,r2
81144050:	1141d080 	call	81141d08 <get_cluster_flag>
81144054:	10003126 	beq	r2,zero,8114411c <find_first_empty_record_in_a_subdirectory+0x21c>
			{
                // The directory needs to be expanded to store more files.
				if ((new_cluster & 0x0000fff8) == 0x0000fff8)
81144058:	e0bffd8b 	ldhu	r2,-10(fp)
8114405c:	10bfffcc 	andi	r2,r2,65535
81144060:	10fffe0c 	andi	r3,r2,65528
81144064:	00bffe14 	movui	r2,65528
81144068:	18802e1e 	bne	r3,r2,81144124 <find_first_empty_record_in_a_subdirectory+0x224>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
8114406c:	e0bffe04 	addi	r2,fp,-8
81144070:	1009883a 	mov	r4,r2
81144074:	1143d4c0 	call	81143d4c <find_first_empty_cluster>
81144078:	10002326 	beq	r2,zero,81144108 <find_first_empty_record_in_a_subdirectory+0x208>
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
8114407c:	e0bff917 	ldw	r2,-28(fp)
81144080:	e0fffe17 	ldw	r3,-8(fp)
81144084:	18ffffcc 	andi	r3,r3,65535
81144088:	18e0001c 	xori	r3,r3,32768
8114408c:	18e00004 	addi	r3,r3,-32768
81144090:	01800044 	movi	r6,1
81144094:	180b883a 	mov	r5,r3
81144098:	1009883a 	mov	r4,r2
8114409c:	1141dc40 	call	81141dc4 <mark_cluster>
811440a0:	10001926 	beq	r2,zero,81144108 <find_first_empty_record_in_a_subdirectory+0x208>
811440a4:	e0bffe17 	ldw	r2,-8(fp)
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
811440a8:	01800044 	movi	r6,1
811440ac:	017fffc4 	movi	r5,-1
811440b0:	1009883a 	mov	r4,r2
811440b4:	1141dc40 	call	81141dc4 <mark_cluster>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
811440b8:	10001326 	beq	r2,zero,81144108 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
811440bc:	e0bff917 	ldw	r2,-28(fp)
811440c0:	e0fffe17 	ldw	r3,-8(fp)
811440c4:	18ffffcc 	andi	r3,r3,65535
811440c8:	18e0001c 	xori	r3,r3,32768
811440cc:	18e00004 	addi	r3,r3,-32768
811440d0:	000d883a 	mov	r6,zero
811440d4:	180b883a 	mov	r5,r3
811440d8:	1009883a 	mov	r4,r2
811440dc:	1141dc40 	call	81141dc4 <mark_cluster>
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
811440e0:	10000926 	beq	r2,zero,81144108 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
811440e4:	e0bffe17 	ldw	r2,-8(fp)
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
811440e8:	000d883a 	mov	r6,zero
811440ec:	017fffc4 	movi	r5,-1
811440f0:	1009883a 	mov	r4,r2
811440f4:	1141dc40 	call	81141dc4 <mark_cluster>
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
811440f8:	10000326 	beq	r2,zero,81144108 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
						{
							Save_Modified_Sector();
811440fc:	1141bd40 	call	81141bd4 <Save_Modified_Sector>
							// The new file will begin at the first entry of the directory.
							result = new_dir_cluster;                           
81144100:	e0bffe17 	ldw	r2,-8(fp)
81144104:	e0bff815 	stw	r2,-32(fp)
						}
					}
					cluster = (new_cluster & 0x0000fff8);
81144108:	e0bffd8b 	ldhu	r2,-10(fp)
8114410c:	10bfffcc 	andi	r2,r2,65535
81144110:	10bffe0c 	andi	r2,r2,65528
81144114:	e0bff915 	stw	r2,-28(fp)
81144118:	00000206 	br	81144124 <find_first_empty_record_in_a_subdirectory+0x224>
				}
			}
			else
			{
				// Error encountered.                 
				result = -1;
8114411c:	00bfffc4 	movi	r2,-1
81144120:	e0bff815 	stw	r2,-32(fp)
			}
        }              
    } while ((cluster < 0x0000fff8) && (result == -1)); 
81144124:	e0bff917 	ldw	r2,-28(fp)
81144128:	00fffdd4 	movui	r3,65527
8114412c:	18800316 	blt	r3,r2,8114413c <find_first_empty_record_in_a_subdirectory+0x23c>
81144130:	e0bff817 	ldw	r2,-32(fp)
81144134:	10bfffe0 	cmpeqi	r2,r2,-1
81144138:	103f7c1e 	bne	r2,zero,81143f2c <__reset+0xfb123f2c>
    return result; 
8114413c:	e0bff817 	ldw	r2,-32(fp)
}
81144140:	e037883a 	mov	sp,fp
81144144:	dfc00117 	ldw	ra,4(sp)
81144148:	df000017 	ldw	fp,0(sp)
8114414c:	dec00204 	addi	sp,sp,8
81144150:	f800283a 	ret

81144154 <find_first_empty_record_in_root_directory>:


int find_first_empty_record_in_root_directory()
// Find a first unused record location to use. Return -1 if none is found.
{
81144154:	defff904 	addi	sp,sp,-28
81144158:	de00012e 	bgeu	sp,et,81144160 <find_first_empty_record_in_root_directory+0xc>
8114415c:	003b68fa 	trap	3
81144160:	dfc00615 	stw	ra,24(sp)
81144164:	df000515 	stw	fp,20(sp)
81144168:	df000504 	addi	fp,sp,20
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
8114416c:	00a045f4 	movhi	r2,33047
81144170:	10b20e04 	addi	r2,r2,-14280
81144174:	1080050b 	ldhu	r2,20(r2)
81144178:	10bfffcc 	andi	r2,r2,65535
8114417c:	1006917a 	slli	r3,r2,5
81144180:	00a045f4 	movhi	r2,33047
81144184:	10b20e04 	addi	r2,r2,-14280
81144188:	1080030b 	ldhu	r2,12(r2)
8114418c:	10bfffcc 	andi	r2,r2,65535
81144190:	1885283a 	div	r2,r3,r2
81144194:	e0bffd15 	stw	r2,-12(fp)
    int sector_index;
    int result = -1;
81144198:	00bfffc4 	movi	r2,-1
8114419c:	e0bffe15 	stw	r2,-8(fp)
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
811441a0:	e03ffb15 	stw	zero,-20(fp)
811441a4:	00002d06 	br	8114425c <find_first_empty_record_in_root_directory+0x108>
    {
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
811441a8:	00a045f4 	movhi	r2,33047
811441ac:	10b20e04 	addi	r2,r2,-14280
811441b0:	10c01317 	ldw	r3,76(r2)
811441b4:	e0bffb17 	ldw	r2,-20(fp)
811441b8:	1885883a 	add	r2,r3,r2
811441bc:	1007883a 	mov	r3,r2
811441c0:	d0a0b117 	ldw	r2,-32060(gp)
811441c4:	100b883a 	mov	r5,r2
811441c8:	1809883a 	mov	r4,r3
811441cc:	1141c280 	call	81141c28 <Read_Sector_Data>
811441d0:	10002626 	beq	r2,zero,8114426c <find_first_empty_record_in_root_directory+0x118>
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
811441d4:	e03ffc15 	stw	zero,-16(fp)
811441d8:	00001a06 	br	81144244 <find_first_empty_record_in_root_directory+0xf0>
            {
                unsigned short int leading_char;
                
                // Read first character of the file record.
                leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
811441dc:	e0bffc17 	ldw	r2,-16(fp)
811441e0:	1004917a 	slli	r2,r2,5
811441e4:	1007883a 	mov	r3,r2
811441e8:	d0a0b317 	ldw	r2,-32052(gp)
811441ec:	10800a17 	ldw	r2,40(r2)
811441f0:	1885883a 	add	r2,r3,r2
811441f4:	10800023 	ldbuio	r2,0(r2)
811441f8:	10803fcc 	andi	r2,r2,255
811441fc:	10803fcc 	andi	r2,r2,255
81144200:	e0bfff0d 	sth	r2,-4(fp)
                if ((leading_char == 0x00e5) || (leading_char == 0))
81144204:	e0bfff0b 	ldhu	r2,-4(fp)
81144208:	10803960 	cmpeqi	r2,r2,229
8114420c:	1000021e 	bne	r2,zero,81144218 <find_first_empty_record_in_root_directory+0xc4>
81144210:	e0bfff0b 	ldhu	r2,-4(fp)
81144214:	1000081e 	bne	r2,zero,81144238 <find_first_empty_record_in_root_directory+0xe4>
                {
                    result = (sector_index*16 + file_counter) << 16;
81144218:	e0bffb17 	ldw	r2,-20(fp)
8114421c:	1006913a 	slli	r3,r2,4
81144220:	e0bffc17 	ldw	r2,-16(fp)
81144224:	1885883a 	add	r2,r3,r2
81144228:	1004943a 	slli	r2,r2,16
8114422c:	e0bffe15 	stw	r2,-8(fp)
                    return result;
81144230:	e0bffe17 	ldw	r2,-8(fp)
81144234:	00000f06 	br	81144274 <find_first_empty_record_in_root_directory+0x120>
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
81144238:	e0bffc17 	ldw	r2,-16(fp)
8114423c:	10800044 	addi	r2,r2,1
81144240:	e0bffc15 	stw	r2,-16(fp)
81144244:	e0bffc17 	ldw	r2,-16(fp)
81144248:	10800410 	cmplti	r2,r2,16
8114424c:	103fe31e 	bne	r2,zero,811441dc <__reset+0xfb1241dc>
{
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    int sector_index;
    int result = -1;
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81144250:	e0bffb17 	ldw	r2,-20(fp)
81144254:	10800044 	addi	r2,r2,1
81144258:	e0bffb15 	stw	r2,-20(fp)
8114425c:	e0fffb17 	ldw	r3,-20(fp)
81144260:	e0bffd17 	ldw	r2,-12(fp)
81144264:	18bfd016 	blt	r3,r2,811441a8 <__reset+0xfb1241a8>
81144268:	00000106 	br	81144270 <find_first_empty_record_in_root_directory+0x11c>
                }
            }
        }
        else
        {
            break;
8114426c:	0001883a 	nop
        }
    }
    return result;
81144270:	e0bffe17 	ldw	r2,-8(fp)
}
81144274:	e037883a 	mov	sp,fp
81144278:	dfc00117 	ldw	ra,4(sp)
8114427c:	df000017 	ldw	fp,0(sp)
81144280:	dec00204 	addi	sp,sp,8
81144284:	f800283a 	ret

81144288 <convert_filename_to_name_extension>:

void convert_filename_to_name_extension(char *filename, char *name, char *extension)
// This function converts the file name into a name . extension format.
{
81144288:	defffa04 	addi	sp,sp,-24
8114428c:	de00012e 	bgeu	sp,et,81144294 <convert_filename_to_name_extension+0xc>
81144290:	003b68fa 	trap	3
81144294:	df000515 	stw	fp,20(sp)
81144298:	df000504 	addi	fp,sp,20
8114429c:	e13ffd15 	stw	r4,-12(fp)
811442a0:	e17ffe15 	stw	r5,-8(fp)
811442a4:	e1bfff15 	stw	r6,-4(fp)
    int counter;
    int local = 0;
811442a8:	e03ffc15 	stw	zero,-16(fp)
    
    for(counter = 0; counter < 8; counter++)
811442ac:	e03ffb15 	stw	zero,-20(fp)
811442b0:	00002506 	br	81144348 <convert_filename_to_name_extension+0xc0>
    {
        if (filename[local] != '.')
811442b4:	e0bffc17 	ldw	r2,-16(fp)
811442b8:	e0fffd17 	ldw	r3,-12(fp)
811442bc:	1885883a 	add	r2,r3,r2
811442c0:	10800003 	ldbu	r2,0(r2)
811442c4:	10803fcc 	andi	r2,r2,255
811442c8:	1080201c 	xori	r2,r2,128
811442cc:	10bfe004 	addi	r2,r2,-128
811442d0:	10800ba0 	cmpeqi	r2,r2,46
811442d4:	1000141e 	bne	r2,zero,81144328 <convert_filename_to_name_extension+0xa0>
        {
            name[counter] = filename[local];
811442d8:	e0bffb17 	ldw	r2,-20(fp)
811442dc:	e0fffe17 	ldw	r3,-8(fp)
811442e0:	1885883a 	add	r2,r3,r2
811442e4:	e0fffc17 	ldw	r3,-16(fp)
811442e8:	e13ffd17 	ldw	r4,-12(fp)
811442ec:	20c7883a 	add	r3,r4,r3
811442f0:	18c00003 	ldbu	r3,0(r3)
811442f4:	10c00005 	stb	r3,0(r2)
            if (filename[local] != 0) local++;
811442f8:	e0bffc17 	ldw	r2,-16(fp)
811442fc:	e0fffd17 	ldw	r3,-12(fp)
81144300:	1885883a 	add	r2,r3,r2
81144304:	10800003 	ldbu	r2,0(r2)
81144308:	10803fcc 	andi	r2,r2,255
8114430c:	1080201c 	xori	r2,r2,128
81144310:	10bfe004 	addi	r2,r2,-128
81144314:	10000926 	beq	r2,zero,8114433c <convert_filename_to_name_extension+0xb4>
81144318:	e0bffc17 	ldw	r2,-16(fp)
8114431c:	10800044 	addi	r2,r2,1
81144320:	e0bffc15 	stw	r2,-16(fp)
81144324:	00000506 	br	8114433c <convert_filename_to_name_extension+0xb4>
        }
        else
        {
            name[counter] = ' ';
81144328:	e0bffb17 	ldw	r2,-20(fp)
8114432c:	e0fffe17 	ldw	r3,-8(fp)
81144330:	1885883a 	add	r2,r3,r2
81144334:	00c00804 	movi	r3,32
81144338:	10c00005 	stb	r3,0(r2)
// This function converts the file name into a name . extension format.
{
    int counter;
    int local = 0;
    
    for(counter = 0; counter < 8; counter++)
8114433c:	e0bffb17 	ldw	r2,-20(fp)
81144340:	10800044 	addi	r2,r2,1
81144344:	e0bffb15 	stw	r2,-20(fp)
81144348:	e0bffb17 	ldw	r2,-20(fp)
8114434c:	10800210 	cmplti	r2,r2,8
81144350:	103fd81e 	bne	r2,zero,811442b4 <__reset+0xfb1242b4>
        else
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
81144354:	e0bffc17 	ldw	r2,-16(fp)
81144358:	e0fffd17 	ldw	r3,-12(fp)
8114435c:	1885883a 	add	r2,r3,r2
81144360:	10800003 	ldbu	r2,0(r2)
81144364:	10803fcc 	andi	r2,r2,255
81144368:	1080201c 	xori	r2,r2,128
8114436c:	10bfe004 	addi	r2,r2,-128
81144370:	10800b98 	cmpnei	r2,r2,46
81144374:	1000031e 	bne	r2,zero,81144384 <convert_filename_to_name_extension+0xfc>
81144378:	e0bffc17 	ldw	r2,-16(fp)
8114437c:	10800044 	addi	r2,r2,1
81144380:	e0bffc15 	stw	r2,-16(fp)
    for(counter = 0; counter < 3; counter++)
81144384:	e03ffb15 	stw	zero,-20(fp)
81144388:	00001c06 	br	811443fc <convert_filename_to_name_extension+0x174>
    {
        if (filename[local] != 0)
8114438c:	e0bffc17 	ldw	r2,-16(fp)
81144390:	e0fffd17 	ldw	r3,-12(fp)
81144394:	1885883a 	add	r2,r3,r2
81144398:	10800003 	ldbu	r2,0(r2)
8114439c:	10803fcc 	andi	r2,r2,255
811443a0:	1080201c 	xori	r2,r2,128
811443a4:	10bfe004 	addi	r2,r2,-128
811443a8:	10000c26 	beq	r2,zero,811443dc <convert_filename_to_name_extension+0x154>
        {
            extension[counter] = filename[local];
811443ac:	e0bffb17 	ldw	r2,-20(fp)
811443b0:	e0ffff17 	ldw	r3,-4(fp)
811443b4:	1885883a 	add	r2,r3,r2
811443b8:	e0fffc17 	ldw	r3,-16(fp)
811443bc:	e13ffd17 	ldw	r4,-12(fp)
811443c0:	20c7883a 	add	r3,r4,r3
811443c4:	18c00003 	ldbu	r3,0(r3)
811443c8:	10c00005 	stb	r3,0(r2)
            local++;
811443cc:	e0bffc17 	ldw	r2,-16(fp)
811443d0:	10800044 	addi	r2,r2,1
811443d4:	e0bffc15 	stw	r2,-16(fp)
811443d8:	00000506 	br	811443f0 <convert_filename_to_name_extension+0x168>
        }
        else
        {
            extension[counter] = ' ';
811443dc:	e0bffb17 	ldw	r2,-20(fp)
811443e0:	e0ffff17 	ldw	r3,-4(fp)
811443e4:	1885883a 	add	r2,r3,r2
811443e8:	00c00804 	movi	r3,32
811443ec:	10c00005 	stb	r3,0(r2)
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
    for(counter = 0; counter < 3; counter++)
811443f0:	e0bffb17 	ldw	r2,-20(fp)
811443f4:	10800044 	addi	r2,r2,1
811443f8:	e0bffb15 	stw	r2,-20(fp)
811443fc:	e0bffb17 	ldw	r2,-20(fp)
81144400:	108000d0 	cmplti	r2,r2,3
81144404:	103fe11e 	bne	r2,zero,8114438c <__reset+0xfb12438c>
        {
            extension[counter] = ' ';
        }
    }

}
81144408:	0001883a 	nop
8114440c:	e037883a 	mov	sp,fp
81144410:	df000017 	ldw	fp,0(sp)
81144414:	dec00104 	addi	sp,sp,4
81144418:	f800283a 	ret

8114441c <create_file>:

bool create_file(char *name, t_file_record *file_record, t_file_record *home_dir)
// Create a file in a given directory. Expand the directory if needed.
{
8114441c:	defff504 	addi	sp,sp,-44
81144420:	de00012e 	bgeu	sp,et,81144428 <create_file+0xc>
81144424:	003b68fa 	trap	3
81144428:	dfc00a15 	stw	ra,40(sp)
8114442c:	df000915 	stw	fp,36(sp)
81144430:	df000904 	addi	fp,sp,36
81144434:	e13ffd15 	stw	r4,-12(fp)
81144438:	e17ffe15 	stw	r5,-8(fp)
8114443c:	e1bfff15 	stw	r6,-4(fp)
    unsigned int cluster_number;
    bool result = false;
81144440:	e03ff715 	stw	zero,-36(fp)
    
    if (find_first_empty_cluster(&cluster_number))
81144444:	e0bffc04 	addi	r2,fp,-16
81144448:	1009883a 	mov	r4,r2
8114444c:	1143d4c0 	call	81143d4c <find_first_empty_cluster>
81144450:	1000a026 	beq	r2,zero,811446d4 <create_file+0x2b8>
    {
        int record_index;
        
        if (home_dir->file_record_cluster == 0)
81144454:	e0bfff17 	ldw	r2,-4(fp)
81144458:	10800a17 	ldw	r2,40(r2)
8114445c:	1000031e 	bne	r2,zero,8114446c <create_file+0x50>
        {
            // Put a file in the root directory.
            record_index = find_first_empty_record_in_root_directory();
81144460:	11441540 	call	81144154 <find_first_empty_record_in_root_directory>
81144464:	e0bff815 	stw	r2,-32(fp)
81144468:	00000606 	br	81144484 <create_file+0x68>
        }
        else
        {
            // Put a file in a subdirectory.
            record_index = find_first_empty_record_in_a_subdirectory(home_dir->start_cluster_index);           
8114446c:	e0bfff17 	ldw	r2,-4(fp)
81144470:	1080058b 	ldhu	r2,22(r2)
81144474:	10bfffcc 	andi	r2,r2,65535
81144478:	1009883a 	mov	r4,r2
8114447c:	1143f000 	call	81143f00 <find_first_empty_record_in_a_subdirectory>
81144480:	e0bff815 	stw	r2,-32(fp)
        }
        if (record_index >= 0)
81144484:	e0bff817 	ldw	r2,-32(fp)
81144488:	10009216 	blt	r2,zero,811446d4 <create_file+0x2b8>
        {   
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
8114448c:	e13ffd17 	ldw	r4,-12(fp)
81144490:	114302c0 	call	8114302c <get_dir_divider_location>
81144494:	e0bff915 	stw	r2,-28(fp)
            int last_dir_separator = 0;
81144498:	e03ffa15 	stw	zero,-24(fp)

            // Skip through all directory separators.
            while (location > 0)
8114449c:	00000b06 	br	811444cc <create_file+0xb0>
            {
                last_dir_separator = last_dir_separator+location+1;
811444a0:	e0fffa17 	ldw	r3,-24(fp)
811444a4:	e0bff917 	ldw	r2,-28(fp)
811444a8:	1885883a 	add	r2,r3,r2
811444ac:	10800044 	addi	r2,r2,1
811444b0:	e0bffa15 	stw	r2,-24(fp)
                location = get_dir_divider_location( &(name[last_dir_separator]) );
811444b4:	e0bffa17 	ldw	r2,-24(fp)
811444b8:	e0fffd17 	ldw	r3,-12(fp)
811444bc:	1885883a 	add	r2,r3,r2
811444c0:	1009883a 	mov	r4,r2
811444c4:	114302c0 	call	8114302c <get_dir_divider_location>
811444c8:	e0bff915 	stw	r2,-28(fp)
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
            int last_dir_separator = 0;

            // Skip through all directory separators.
            while (location > 0)
811444cc:	e0bff917 	ldw	r2,-28(fp)
811444d0:	00bff316 	blt	zero,r2,811444a0 <__reset+0xfb1244a0>
            {
                last_dir_separator = last_dir_separator+location+1;
                location = get_dir_divider_location( &(name[last_dir_separator]) );
            }
            
            convert_filename_to_name_extension(&(name[last_dir_separator]), (char *)file_record->name, (char *)file_record->extension);
811444d4:	e0bffa17 	ldw	r2,-24(fp)
811444d8:	e0fffd17 	ldw	r3,-12(fp)
811444dc:	1887883a 	add	r3,r3,r2
811444e0:	e13ffe17 	ldw	r4,-8(fp)
811444e4:	e0bffe17 	ldw	r2,-8(fp)
811444e8:	10800204 	addi	r2,r2,8
811444ec:	100d883a 	mov	r6,r2
811444f0:	200b883a 	mov	r5,r4
811444f4:	1809883a 	mov	r4,r3
811444f8:	11442880 	call	81144288 <convert_filename_to_name_extension>
                         
            file_record->attributes = 0;
811444fc:	e0bffe17 	ldw	r2,-8(fp)
81144500:	100002c5 	stb	zero,11(r2)
            file_record->create_time = 0;
81144504:	e0bffe17 	ldw	r2,-8(fp)
81144508:	1000030d 	sth	zero,12(r2)
            file_record->create_date = 0;
8114450c:	e0bffe17 	ldw	r2,-8(fp)
81144510:	1000038d 	sth	zero,14(r2)
            file_record->last_access_date = 0;
81144514:	e0bffe17 	ldw	r2,-8(fp)
81144518:	1000040d 	sth	zero,16(r2)
            file_record->last_modified_time = 0;
8114451c:	e0bffe17 	ldw	r2,-8(fp)
81144520:	1000048d 	sth	zero,18(r2)
            file_record->last_modified_date = 0;
81144524:	e0bffe17 	ldw	r2,-8(fp)
81144528:	1000050d 	sth	zero,20(r2)
            file_record->start_cluster_index = cluster_number;
8114452c:	e0bffc17 	ldw	r2,-16(fp)
81144530:	1007883a 	mov	r3,r2
81144534:	e0bffe17 	ldw	r2,-8(fp)
81144538:	10c0058d 	sth	r3,22(r2)
            file_record->file_size_in_bytes = 0;
8114453c:	e0bffe17 	ldw	r2,-8(fp)
81144540:	10000615 	stw	zero,24(r2)
            file_record->current_cluster_index = cluster_number;
81144544:	e0fffc17 	ldw	r3,-16(fp)
81144548:	e0bffe17 	ldw	r2,-8(fp)
8114454c:	10c00715 	stw	r3,28(r2)
            file_record->current_sector_in_cluster = 0;
81144550:	e0bffe17 	ldw	r2,-8(fp)
81144554:	10000815 	stw	zero,32(r2)
            file_record->current_byte_position = 0;
81144558:	e0bffe17 	ldw	r2,-8(fp)
8114455c:	10000915 	stw	zero,36(r2)
            file_record->file_record_cluster = record_index & 0x0000ffff;
81144560:	e0bff817 	ldw	r2,-32(fp)
81144564:	10ffffcc 	andi	r3,r2,65535
81144568:	e0bffe17 	ldw	r2,-8(fp)
8114456c:	10c00a15 	stw	r3,40(r2)
            file_record->file_record_sector_in_cluster = ((record_index >> 16) & 0x0000ffff) / 16;
81144570:	e0bff817 	ldw	r2,-32(fp)
81144574:	1004d43a 	srli	r2,r2,16
81144578:	1000010e 	bge	r2,zero,81144580 <create_file+0x164>
8114457c:	108003c4 	addi	r2,r2,15
81144580:	1005d13a 	srai	r2,r2,4
81144584:	1007883a 	mov	r3,r2
81144588:	e0bffe17 	ldw	r2,-8(fp)
8114458c:	10c00b15 	stw	r3,44(r2)
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
81144590:	e0bff817 	ldw	r2,-32(fp)
81144594:	1004d43a 	srli	r2,r2,16
81144598:	1007883a 	mov	r3,r2
8114459c:	00a00034 	movhi	r2,32768
811445a0:	108003c4 	addi	r2,r2,15
811445a4:	1884703a 	and	r2,r3,r2
811445a8:	1000040e 	bge	r2,zero,811445bc <create_file+0x1a0>
811445ac:	10bfffc4 	addi	r2,r2,-1
811445b0:	00fffc04 	movi	r3,-16
811445b4:	10c4b03a 	or	r2,r2,r3
811445b8:	10800044 	addi	r2,r2,1
811445bc:	1004917a 	slli	r2,r2,5
811445c0:	1007883a 	mov	r3,r2
811445c4:	e0bffe17 	ldw	r2,-8(fp)
811445c8:	10c00c0d 	sth	r3,48(r2)
            file_record->home_directory_cluster = home_dir->start_cluster_index;
811445cc:	e0bfff17 	ldw	r2,-4(fp)
811445d0:	1080058b 	ldhu	r2,22(r2)
811445d4:	10ffffcc 	andi	r3,r2,65535
811445d8:	e0bffe17 	ldw	r2,-8(fp)
811445dc:	10c00d15 	stw	r3,52(r2)
            file_record->in_use = true;
811445e0:	e0bffe17 	ldw	r2,-8(fp)
811445e4:	00c00044 	movi	r3,1
811445e8:	10c00f15 	stw	r3,60(r2)
            file_record->modified = true;
811445ec:	e0bffe17 	ldw	r2,-8(fp)
811445f0:	00c00044 	movi	r3,1
811445f4:	10c00e15 	stw	r3,56(r2)
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
811445f8:	e0bffe17 	ldw	r2,-8(fp)
811445fc:	10800a17 	ldw	r2,40(r2)
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
81144600:	1000071e 	bne	r2,zero,81144620 <create_file+0x204>
81144604:	00a045f4 	movhi	r2,33047
81144608:	10b20e04 	addi	r2,r2,-14280
8114460c:	10c01317 	ldw	r3,76(r2)
81144610:	e0bffe17 	ldw	r2,-8(fp)
81144614:	10800b17 	ldw	r2,44(r2)
81144618:	1885883a 	add	r2,r3,r2
8114461c:	00000f06 	br	8114465c <create_file+0x240>
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
81144620:	00a045f4 	movhi	r2,33047
81144624:	10b20e04 	addi	r2,r2,-14280
81144628:	10c01417 	ldw	r3,80(r2)
8114462c:	e0bffe17 	ldw	r2,-8(fp)
81144630:	10800a17 	ldw	r2,40(r2)
81144634:	113fff84 	addi	r4,r2,-2
81144638:	00a045f4 	movhi	r2,33047
8114463c:	10b20e04 	addi	r2,r2,-14280
81144640:	10800383 	ldbu	r2,14(r2)
81144644:	10803fcc 	andi	r2,r2,255
81144648:	2085383a 	mul	r2,r4,r2
8114464c:	1887883a 	add	r3,r3,r2
                                     file_record->file_record_sector_in_cluster);
81144650:	e0bffe17 	ldw	r2,-8(fp)
81144654:	10800b17 	ldw	r2,44(r2)
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
            file_record->modified = true;
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
81144658:	1885883a 	add	r2,r3,r2
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
            file_record->modified = true;
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
8114465c:	e0bffb15 	stw	r2,-20(fp)
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
                                     file_record->file_record_sector_in_cluster);

			if (Read_Sector_Data(file_record_sector, fat_partition_offset_in_512_byte_sectors))
81144660:	e0bffb17 	ldw	r2,-20(fp)
81144664:	d0e0b117 	ldw	r3,-32060(gp)
81144668:	180b883a 	mov	r5,r3
8114466c:	1009883a 	mov	r4,r2
81144670:	1141c280 	call	81141c28 <Read_Sector_Data>
81144674:	10001726 	beq	r2,zero,811446d4 <create_file+0x2b8>
            {
                if (Write_File_Record_At_Offset(file_record->file_record_offset, file_record))
81144678:	e0bffe17 	ldw	r2,-8(fp)
8114467c:	10800c0b 	ldhu	r2,48(r2)
81144680:	10bfffcc 	andi	r2,r2,65535
81144684:	10a0001c 	xori	r2,r2,32768
81144688:	10a00004 	addi	r2,r2,-32768
8114468c:	e17ffe17 	ldw	r5,-8(fp)
81144690:	1009883a 	mov	r4,r2
81144694:	11422dc0 	call	811422dc <Write_File_Record_At_Offset>
81144698:	10000e26 	beq	r2,zero,811446d4 <create_file+0x2b8>
                {
                    Save_Modified_Sector();
8114469c:	1141bd40 	call	81141bd4 <Save_Modified_Sector>
                    // Mark the first cluster of the file as the last cluster at first.
                    mark_cluster(cluster_number, ((short int) (0xffff)), true);
811446a0:	e0bffc17 	ldw	r2,-16(fp)
811446a4:	01800044 	movi	r6,1
811446a8:	017fffc4 	movi	r5,-1
811446ac:	1009883a 	mov	r4,r2
811446b0:	1141dc40 	call	81141dc4 <mark_cluster>
                    if (mark_cluster(cluster_number, ((short int) (0xffff)), false))
811446b4:	e0bffc17 	ldw	r2,-16(fp)
811446b8:	000d883a 	mov	r6,zero
811446bc:	017fffc4 	movi	r5,-1
811446c0:	1009883a 	mov	r4,r2
811446c4:	1141dc40 	call	81141dc4 <mark_cluster>
811446c8:	10000226 	beq	r2,zero,811446d4 <create_file+0x2b8>
                    {
                        result = true;
811446cc:	00800044 	movi	r2,1
811446d0:	e0bff715 	stw	r2,-36(fp)
                }
            }
        }

    }
    return result;           
811446d4:	e0bff717 	ldw	r2,-36(fp)
}
811446d8:	e037883a 	mov	sp,fp
811446dc:	dfc00117 	ldw	ra,4(sp)
811446e0:	df000017 	ldw	fp,0(sp)
811446e4:	dec00204 	addi	sp,sp,8
811446e8:	f800283a 	ret

811446ec <copy_file_record_name_to_string>:


void copy_file_record_name_to_string(t_file_record *file_record, char *file_name)
/* Copy a file name from the file record to a given string */
{
811446ec:	defffb04 	addi	sp,sp,-20
811446f0:	de00012e 	bgeu	sp,et,811446f8 <copy_file_record_name_to_string+0xc>
811446f4:	003b68fa 	trap	3
811446f8:	df000415 	stw	fp,16(sp)
811446fc:	df000404 	addi	fp,sp,16
81144700:	e13ffe15 	stw	r4,-8(fp)
81144704:	e17fff15 	stw	r5,-4(fp)
	int index;
	int flength = 0;
81144708:	e03ffd15 	stw	zero,-12(fp)

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
8114470c:	e03ffc15 	stw	zero,-16(fp)
81144710:	00001506 	br	81144768 <copy_file_record_name_to_string+0x7c>
	{
		if (file_record->name[index] != ' ')
81144714:	e0fffe17 	ldw	r3,-8(fp)
81144718:	e0bffc17 	ldw	r2,-16(fp)
8114471c:	1885883a 	add	r2,r3,r2
81144720:	10800003 	ldbu	r2,0(r2)
81144724:	10803fcc 	andi	r2,r2,255
81144728:	10800820 	cmpeqi	r2,r2,32
8114472c:	10000b1e 	bne	r2,zero,8114475c <copy_file_record_name_to_string+0x70>
		{
			file_name[flength] = file_record->name[index];
81144730:	e0bffd17 	ldw	r2,-12(fp)
81144734:	e0ffff17 	ldw	r3,-4(fp)
81144738:	1885883a 	add	r2,r3,r2
8114473c:	e13ffe17 	ldw	r4,-8(fp)
81144740:	e0fffc17 	ldw	r3,-16(fp)
81144744:	20c7883a 	add	r3,r4,r3
81144748:	18c00003 	ldbu	r3,0(r3)
8114474c:	10c00005 	stb	r3,0(r2)
			flength = flength + 1;
81144750:	e0bffd17 	ldw	r2,-12(fp)
81144754:	10800044 	addi	r2,r2,1
81144758:	e0bffd15 	stw	r2,-12(fp)
{
	int index;
	int flength = 0;

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
8114475c:	e0bffc17 	ldw	r2,-16(fp)
81144760:	10800044 	addi	r2,r2,1
81144764:	e0bffc15 	stw	r2,-16(fp)
81144768:	e0bffc17 	ldw	r2,-16(fp)
8114476c:	10800210 	cmplti	r2,r2,8
81144770:	103fe81e 	bne	r2,zero,81144714 <__reset+0xfb124714>
		{
			file_name[flength] = file_record->name[index];
			flength = flength + 1;
		}
	}
	if (file_record->extension[0] != ' ')
81144774:	e0bffe17 	ldw	r2,-8(fp)
81144778:	10800203 	ldbu	r2,8(r2)
8114477c:	10803fcc 	andi	r2,r2,255
81144780:	10800820 	cmpeqi	r2,r2,32
81144784:	1000241e 	bne	r2,zero,81144818 <copy_file_record_name_to_string+0x12c>
	{
		file_name[flength] = '.';
81144788:	e0bffd17 	ldw	r2,-12(fp)
8114478c:	e0ffff17 	ldw	r3,-4(fp)
81144790:	1885883a 	add	r2,r3,r2
81144794:	00c00b84 	movi	r3,46
81144798:	10c00005 	stb	r3,0(r2)
		flength = flength + 1;
8114479c:	e0bffd17 	ldw	r2,-12(fp)
811447a0:	10800044 	addi	r2,r2,1
811447a4:	e0bffd15 	stw	r2,-12(fp)
		for (index = 0; index < 3; index++)
811447a8:	e03ffc15 	stw	zero,-16(fp)
811447ac:	00001706 	br	8114480c <copy_file_record_name_to_string+0x120>
		{
			if (file_record->extension[index] != ' ')
811447b0:	e0fffe17 	ldw	r3,-8(fp)
811447b4:	e0bffc17 	ldw	r2,-16(fp)
811447b8:	1885883a 	add	r2,r3,r2
811447bc:	10800204 	addi	r2,r2,8
811447c0:	10800003 	ldbu	r2,0(r2)
811447c4:	10803fcc 	andi	r2,r2,255
811447c8:	10800820 	cmpeqi	r2,r2,32
811447cc:	10000c1e 	bne	r2,zero,81144800 <copy_file_record_name_to_string+0x114>
			{
				file_name[flength] = file_record->extension[index];
811447d0:	e0bffd17 	ldw	r2,-12(fp)
811447d4:	e0ffff17 	ldw	r3,-4(fp)
811447d8:	1885883a 	add	r2,r3,r2
811447dc:	e13ffe17 	ldw	r4,-8(fp)
811447e0:	e0fffc17 	ldw	r3,-16(fp)
811447e4:	20c7883a 	add	r3,r4,r3
811447e8:	18c00204 	addi	r3,r3,8
811447ec:	18c00003 	ldbu	r3,0(r3)
811447f0:	10c00005 	stb	r3,0(r2)
				flength = flength + 1;
811447f4:	e0bffd17 	ldw	r2,-12(fp)
811447f8:	10800044 	addi	r2,r2,1
811447fc:	e0bffd15 	stw	r2,-12(fp)
	}
	if (file_record->extension[0] != ' ')
	{
		file_name[flength] = '.';
		flength = flength + 1;
		for (index = 0; index < 3; index++)
81144800:	e0bffc17 	ldw	r2,-16(fp)
81144804:	10800044 	addi	r2,r2,1
81144808:	e0bffc15 	stw	r2,-16(fp)
8114480c:	e0bffc17 	ldw	r2,-16(fp)
81144810:	108000d0 	cmplti	r2,r2,3
81144814:	103fe61e 	bne	r2,zero,811447b0 <__reset+0xfb1247b0>
				file_name[flength] = file_record->extension[index];
				flength = flength + 1;
			}
		}
	}
	file_name[flength] = 0;
81144818:	e0bffd17 	ldw	r2,-12(fp)
8114481c:	e0ffff17 	ldw	r3,-4(fp)
81144820:	1885883a 	add	r2,r3,r2
81144824:	10000005 	stb	zero,0(r2)
}
81144828:	0001883a 	nop
8114482c:	e037883a 	mov	sp,fp
81144830:	df000017 	ldw	fp,0(sp)
81144834:	dec00104 	addi	sp,sp,4
81144838:	f800283a 	ret

8114483c <alt_up_sd_card_open_dev>:
// Direct functions
///////////////////////////////////////////////////////////////////////////


alt_up_sd_card_dev* alt_up_sd_card_open_dev(const char* name)
{
8114483c:	defffc04 	addi	sp,sp,-16
81144840:	de00012e 	bgeu	sp,et,81144848 <alt_up_sd_card_open_dev+0xc>
81144844:	003b68fa 	trap	3
81144848:	dfc00315 	stw	ra,12(sp)
8114484c:	df000215 	stw	fp,8(sp)
81144850:	df000204 	addi	fp,sp,8
81144854:	e13fff15 	stw	r4,-4(fp)
	// find the device from the device list 
	// (see altera_hal/HAL/inc/priv/alt_file.h 
	// and altera_hal/HAL/src/alt_find_dev.c 
	// for details)
	alt_up_sd_card_dev *dev = (alt_up_sd_card_dev *) alt_find_dev(name, &alt_dev_list);
81144858:	d1600d04 	addi	r5,gp,-32716
8114485c:	e13fff17 	ldw	r4,-4(fp)
81144860:	1149cf80 	call	81149cf8 <alt_find_dev>
81144864:	e0bffe15 	stw	r2,-8(fp)

	if (dev != NULL)
81144868:	e0bffe17 	ldw	r2,-8(fp)
8114486c:	10001e26 	beq	r2,zero,811448e8 <alt_up_sd_card_open_dev+0xac>
	{
		aux_status_register = ((short int *) SD_CARD_AUX_STATUS(dev->base));
81144870:	e0bffe17 	ldw	r2,-8(fp)
81144874:	10800a17 	ldw	r2,40(r2)
81144878:	10808d04 	addi	r2,r2,564
8114487c:	d0a0ab15 	stw	r2,-32084(gp)
		status_register = ((int *) SD_CARD_STATUS(dev->base));
81144880:	e0bffe17 	ldw	r2,-8(fp)
81144884:	10800a17 	ldw	r2,40(r2)
81144888:	10808904 	addi	r2,r2,548
8114488c:	d0a0ac15 	stw	r2,-32080(gp)
		CSD_register_w0 = ((short int *) SD_CARD_CSD(dev->base, 0));
81144890:	e0bffe17 	ldw	r2,-8(fp)
81144894:	10800a17 	ldw	r2,40(r2)
81144898:	10808404 	addi	r2,r2,528
8114489c:	d0a0ad15 	stw	r2,-32076(gp)
		command_register = ((short int *) SD_CARD_COMMAND(dev->base));
811448a0:	e0bffe17 	ldw	r2,-8(fp)
811448a4:	10800a17 	ldw	r2,40(r2)
811448a8:	10808c04 	addi	r2,r2,560
811448ac:	d0a0ae15 	stw	r2,-32072(gp)
		command_argument_register = ((int *) SD_CARD_ARGUMENT(dev->base));
811448b0:	e0bffe17 	ldw	r2,-8(fp)
811448b4:	10800a17 	ldw	r2,40(r2)
811448b8:	10808b04 	addi	r2,r2,556
811448bc:	d0a0af15 	stw	r2,-32068(gp)
		buffer_memory = (char *) SD_CARD_BUFFER(dev->base, 0);
811448c0:	e0bffe17 	ldw	r2,-8(fp)
811448c4:	10800a17 	ldw	r2,40(r2)
811448c8:	d0a0b015 	stw	r2,-32064(gp)
		device_pointer = dev;
811448cc:	e0bffe17 	ldw	r2,-8(fp)
811448d0:	d0a0b315 	stw	r2,-32052(gp)
		initialized = false;
811448d4:	d020a915 	stw	zero,-32092(gp)
		is_sd_card_formated_as_FAT16 = false;
811448d8:	d020aa15 	stw	zero,-32088(gp)
		search_data.valid = false;
811448dc:	00a045f4 	movhi	r2,33047
811448e0:	10b20904 	addi	r2,r2,-14300
811448e4:	10000415 	stw	zero,16(r2)
	}
	return dev;
811448e8:	e0bffe17 	ldw	r2,-8(fp)
}
811448ec:	e037883a 	mov	sp,fp
811448f0:	dfc00117 	ldw	ra,4(sp)
811448f4:	df000017 	ldw	fp,0(sp)
811448f8:	dec00204 	addi	sp,sp,8
811448fc:	f800283a 	ret

81144900 <alt_up_sd_card_is_Present>:


bool alt_up_sd_card_is_Present(void)
// Check if there is an SD Card insterted into the SD Card socket.
{
81144900:	defffd04 	addi	sp,sp,-12
81144904:	de00012e 	bgeu	sp,et,8114490c <alt_up_sd_card_is_Present+0xc>
81144908:	003b68fa 	trap	3
8114490c:	df000215 	stw	fp,8(sp)
81144910:	df000204 	addi	fp,sp,8
    bool result = false;
81144914:	e03ffe15 	stw	zero,-8(fp)

    if ((device_pointer != NULL) && ((IORD_16DIRECT(aux_status_register,0) & 0x02) != 0))
81144918:	d0a0b317 	ldw	r2,-32052(gp)
8114491c:	10000826 	beq	r2,zero,81144940 <alt_up_sd_card_is_Present+0x40>
81144920:	d0a0ab17 	ldw	r2,-32084(gp)
81144924:	1080002b 	ldhuio	r2,0(r2)
81144928:	10bfffcc 	andi	r2,r2,65535
8114492c:	1080008c 	andi	r2,r2,2
81144930:	10000326 	beq	r2,zero,81144940 <alt_up_sd_card_is_Present+0x40>
    {
        result = true;
81144934:	00800044 	movi	r2,1
81144938:	e0bffe15 	stw	r2,-8(fp)
8114493c:	00001e06 	br	811449b8 <alt_up_sd_card_is_Present+0xb8>
    }
	else if (initialized == true)
81144940:	d0a0a917 	ldw	r2,-32092(gp)
81144944:	10800058 	cmpnei	r2,r2,1
81144948:	10001b1e 	bne	r2,zero,811449b8 <alt_up_sd_card_is_Present+0xb8>
	{
		int index;

		initialized = false;
8114494c:	d020a915 	stw	zero,-32092(gp)
		search_data.valid = false;
81144950:	00a045f4 	movhi	r2,33047
81144954:	10b20904 	addi	r2,r2,-14300
81144958:	10000415 	stw	zero,16(r2)
		is_sd_card_formated_as_FAT16 = false;
8114495c:	d020aa15 	stw	zero,-32088(gp)

		for(index = 0; index < MAX_FILES_OPENED; index++)
81144960:	e03fff15 	stw	zero,-4(fp)
81144964:	00001106 	br	811449ac <alt_up_sd_card_is_Present+0xac>
		{
			active_files[index].in_use = false;
81144968:	00a045f4 	movhi	r2,33047
8114496c:	10b22304 	addi	r2,r2,-14196
81144970:	e0ffff17 	ldw	r3,-4(fp)
81144974:	180691ba 	slli	r3,r3,6
81144978:	10c5883a 	add	r2,r2,r3
8114497c:	10800f04 	addi	r2,r2,60
81144980:	10000015 	stw	zero,0(r2)
			active_files[index].modified = false;
81144984:	00a045f4 	movhi	r2,33047
81144988:	10b22304 	addi	r2,r2,-14196
8114498c:	e0ffff17 	ldw	r3,-4(fp)
81144990:	180691ba 	slli	r3,r3,6
81144994:	10c5883a 	add	r2,r2,r3
81144998:	10800e04 	addi	r2,r2,56
8114499c:	10000015 	stw	zero,0(r2)

		initialized = false;
		search_data.valid = false;
		is_sd_card_formated_as_FAT16 = false;

		for(index = 0; index < MAX_FILES_OPENED; index++)
811449a0:	e0bfff17 	ldw	r2,-4(fp)
811449a4:	10800044 	addi	r2,r2,1
811449a8:	e0bfff15 	stw	r2,-4(fp)
811449ac:	e0bfff17 	ldw	r2,-4(fp)
811449b0:	10800510 	cmplti	r2,r2,20
811449b4:	103fec1e 	bne	r2,zero,81144968 <__reset+0xfb124968>
		{
			active_files[index].in_use = false;
			active_files[index].modified = false;
		}
	}
    return result;
811449b8:	e0bffe17 	ldw	r2,-8(fp)
}
811449bc:	e037883a 	mov	sp,fp
811449c0:	df000017 	ldw	fp,0(sp)
811449c4:	dec00104 	addi	sp,sp,4
811449c8:	f800283a 	ret

811449cc <alt_up_sd_card_is_FAT16>:
/* This function reads the SD card data in an effort to determine if the card is formated as a FAT16
 * volume. Please note that FAT12 has a similar format, but will not be supported by this driver.
 * If the card contains a FAT16 volume, the local data structures will be initialized to allow reading and writing
 * to the SD card as though it was a hard drive.
 */
{
811449cc:	defffd04 	addi	sp,sp,-12
811449d0:	de00012e 	bgeu	sp,et,811449d8 <alt_up_sd_card_is_FAT16+0xc>
811449d4:	003b68fa 	trap	3
811449d8:	dfc00215 	stw	ra,8(sp)
811449dc:	df000115 	stw	fp,4(sp)
811449e0:	df000104 	addi	fp,sp,4
	bool result = false;
811449e4:	e03fff15 	stw	zero,-4(fp)

	if (alt_up_sd_card_is_Present())
811449e8:	11449000 	call	81144900 <alt_up_sd_card_is_Present>
811449ec:	10000c26 	beq	r2,zero,81144a20 <alt_up_sd_card_is_FAT16+0x54>
	{
		// Check if an SD Card is in the SD Card slot.
		if (initialized == false)
811449f0:	d0a0a917 	ldw	r2,-32092(gp)
811449f4:	1000071e 	bne	r2,zero,81144a14 <alt_up_sd_card_is_FAT16+0x48>
		{
			// Now determine if the card is formatted as FAT 16.
			is_sd_card_formated_as_FAT16 = Look_for_FAT16();
811449f8:	1142bf80 	call	81142bf8 <Look_for_FAT16>
811449fc:	d0a0aa15 	stw	r2,-32088(gp)
			initialized = is_sd_card_formated_as_FAT16;
81144a00:	d0a0aa17 	ldw	r2,-32088(gp)
81144a04:	d0a0a915 	stw	r2,-32092(gp)
			search_data.valid = false;
81144a08:	00a045f4 	movhi	r2,33047
81144a0c:	10b20904 	addi	r2,r2,-14300
81144a10:	10000415 	stw	zero,16(r2)
		}
		result = is_sd_card_formated_as_FAT16;
81144a14:	d0a0aa17 	ldw	r2,-32088(gp)
81144a18:	e0bfff15 	stw	r2,-4(fp)
81144a1c:	00000206 	br	81144a28 <alt_up_sd_card_is_FAT16+0x5c>
	}
	else
	{
		// If not then you may as well not open the device.
		initialized = false;
81144a20:	d020a915 	stw	zero,-32092(gp)
		is_sd_card_formated_as_FAT16 = false;
81144a24:	d020aa15 	stw	zero,-32088(gp)
	}

	return result;
81144a28:	e0bfff17 	ldw	r2,-4(fp)
}
81144a2c:	e037883a 	mov	sp,fp
81144a30:	dfc00117 	ldw	ra,4(sp)
81144a34:	df000017 	ldw	fp,0(sp)
81144a38:	dec00204 	addi	sp,sp,8
81144a3c:	f800283a 	ret

81144a40 <alt_up_sd_card_find_first>:
 * "first/sub/." - look through a directory named "sub", that is located within the subdirectory named "first". "first" is located in the root directory.
 * Invalid examples include:
 * "/.", "/////." - this is not the root directory.
 * "/first/." - the first character may not be a '/'.
 */
{
81144a40:	deffea04 	addi	sp,sp,-88
81144a44:	de00012e 	bgeu	sp,et,81144a4c <alt_up_sd_card_find_first+0xc>
81144a48:	003b68fa 	trap	3
81144a4c:	dfc01515 	stw	ra,84(sp)
81144a50:	df001415 	stw	fp,80(sp)
81144a54:	df001404 	addi	fp,sp,80
81144a58:	e13ffe15 	stw	r4,-8(fp)
81144a5c:	e17fff15 	stw	r5,-4(fp)
	short int result = 2;
81144a60:	00800084 	movi	r2,2
81144a64:	e0bfec0d 	sth	r2,-80(fp)
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81144a68:	11449000 	call	81144900 <alt_up_sd_card_is_Present>
81144a6c:	10002426 	beq	r2,zero,81144b00 <alt_up_sd_card_find_first+0xc0>
81144a70:	d0a0aa17 	ldw	r2,-32088(gp)
81144a74:	10002226 	beq	r2,zero,81144b00 <alt_up_sd_card_find_first+0xc0>
	{
		int home_directory_cluster;
		t_file_record file_record;

		if (get_home_directory_cluster_for_file(directory_to_search_through, &home_directory_cluster, &file_record))
81144a78:	e0ffee04 	addi	r3,fp,-72
81144a7c:	e0bfed04 	addi	r2,fp,-76
81144a80:	180d883a 	mov	r6,r3
81144a84:	100b883a 	mov	r5,r2
81144a88:	e13ffe17 	ldw	r4,-8(fp)
81144a8c:	11433900 	call	81143390 <get_home_directory_cluster_for_file>
81144a90:	10001926 	beq	r2,zero,81144af8 <alt_up_sd_card_find_first+0xb8>
		{
			search_data.directory_root_cluster = home_directory_cluster;
81144a94:	e0bfed17 	ldw	r2,-76(fp)
81144a98:	1007883a 	mov	r3,r2
81144a9c:	00a045f4 	movhi	r2,33047
81144aa0:	10b20904 	addi	r2,r2,-14300
81144aa4:	10c00015 	stw	r3,0(r2)
			search_data.current_cluster_index = home_directory_cluster;
81144aa8:	e0bfed17 	ldw	r2,-76(fp)
81144aac:	1007883a 	mov	r3,r2
81144ab0:	00a045f4 	movhi	r2,33047
81144ab4:	10b20904 	addi	r2,r2,-14300
81144ab8:	10c00115 	stw	r3,4(r2)
			search_data.current_sector_in_cluster = 0;
81144abc:	00a045f4 	movhi	r2,33047
81144ac0:	10b20904 	addi	r2,r2,-14300
81144ac4:	10000215 	stw	zero,8(r2)
			search_data.file_index_in_sector = -1;
81144ac8:	00a045f4 	movhi	r2,33047
81144acc:	10b20904 	addi	r2,r2,-14300
81144ad0:	00ffffc4 	movi	r3,-1
81144ad4:	10c0030d 	sth	r3,12(r2)
			search_data.valid = true;
81144ad8:	00a045f4 	movhi	r2,33047
81144adc:	10b20904 	addi	r2,r2,-14300
81144ae0:	00c00044 	movi	r3,1
81144ae4:	10c00415 	stw	r3,16(r2)
			result = alt_up_sd_card_find_next(file_name);
81144ae8:	e13fff17 	ldw	r4,-4(fp)
81144aec:	1144b180 	call	81144b18 <alt_up_sd_card_find_next>
81144af0:	e0bfec0d 	sth	r2,-80(fp)
81144af4:	00000206 	br	81144b00 <alt_up_sd_card_find_first+0xc0>
		}
		else
		{
			result = 1;
81144af8:	00800044 	movi	r2,1
81144afc:	e0bfec0d 	sth	r2,-80(fp)
		}
	}
	return result;
81144b00:	e0bfec0b 	ldhu	r2,-80(fp)
}
81144b04:	e037883a 	mov	sp,fp
81144b08:	dfc00117 	ldw	ra,4(sp)
81144b0c:	df000017 	ldw	fp,0(sp)
81144b10:	dec00204 	addi	sp,sp,8
81144b14:	f800283a 	ret

81144b18 <alt_up_sd_card_find_next>:
 *		-1 - end of directory.
 *		0 - success
 *		2 - No card or incorrect card format.
 *		3 - find_first has not been called successfully.
 */
{
81144b18:	deffe404 	addi	sp,sp,-112
81144b1c:	de00012e 	bgeu	sp,et,81144b24 <alt_up_sd_card_find_next+0xc>
81144b20:	003b68fa 	trap	3
81144b24:	dfc01b15 	stw	ra,108(sp)
81144b28:	df001a15 	stw	fp,104(sp)
81144b2c:	df001a04 	addi	fp,sp,104
81144b30:	e13fff15 	stw	r4,-4(fp)
	short int result = 2;
81144b34:	00800084 	movi	r2,2
81144b38:	e0bfe60d 	sth	r2,-104(fp)
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81144b3c:	11449000 	call	81144900 <alt_up_sd_card_is_Present>
81144b40:	1000df26 	beq	r2,zero,81144ec0 <alt_up_sd_card_find_next+0x3a8>
81144b44:	d0a0aa17 	ldw	r2,-32088(gp)
81144b48:	1000dd26 	beq	r2,zero,81144ec0 <alt_up_sd_card_find_next+0x3a8>
	{
		if (search_data.valid)
81144b4c:	00a045f4 	movhi	r2,33047
81144b50:	10b20904 	addi	r2,r2,-14300
81144b54:	10800417 	ldw	r2,16(r2)
81144b58:	1000d726 	beq	r2,zero,81144eb8 <alt_up_sd_card_find_next+0x3a0>
		{
			t_file_record file_record;
			int cluster = search_data.current_cluster_index;
81144b5c:	00a045f4 	movhi	r2,33047
81144b60:	10b20904 	addi	r2,r2,-14300
81144b64:	10800117 	ldw	r2,4(r2)
81144b68:	e0bfe715 	stw	r2,-100(fp)

			if (cluster == 0)
81144b6c:	e0bfe717 	ldw	r2,-100(fp)
81144b70:	1000561e 	bne	r2,zero,81144ccc <alt_up_sd_card_find_next+0x1b4>
			{
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
81144b74:	00a045f4 	movhi	r2,33047
81144b78:	10b20e04 	addi	r2,r2,-14280
81144b7c:	1080050b 	ldhu	r2,20(r2)
81144b80:	10bfffcc 	andi	r2,r2,65535
81144b84:	1006917a 	slli	r3,r2,5
81144b88:	00a045f4 	movhi	r2,33047
81144b8c:	10b20e04 	addi	r2,r2,-14280
81144b90:	1080030b 	ldhu	r2,12(r2)
81144b94:	10bfffcc 	andi	r2,r2,65535
81144b98:	1885283a 	div	r2,r3,r2
81144b9c:	e0bfec15 	stw	r2,-80(fp)
				int sector_index = search_data.current_sector_in_cluster;
81144ba0:	00a045f4 	movhi	r2,33047
81144ba4:	10b20904 	addi	r2,r2,-14300
81144ba8:	10800217 	ldw	r2,8(r2)
81144bac:	e0bfe815 	stw	r2,-96(fp)
				int file_counter = search_data.file_index_in_sector+1;
81144bb0:	00a045f4 	movhi	r2,33047
81144bb4:	10b20904 	addi	r2,r2,-14300
81144bb8:	1080030b 	ldhu	r2,12(r2)
81144bbc:	10bfffcc 	andi	r2,r2,65535
81144bc0:	10a0001c 	xori	r2,r2,32768
81144bc4:	10a00004 	addi	r2,r2,-32768
81144bc8:	10800044 	addi	r2,r2,1
81144bcc:	e0bfe915 	stw	r2,-92(fp)
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
81144bd0:	00003606 	br	81144cac <alt_up_sd_card_find_next+0x194>
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
81144bd4:	00a045f4 	movhi	r2,33047
81144bd8:	10b20e04 	addi	r2,r2,-14280
81144bdc:	10c01317 	ldw	r3,76(r2)
81144be0:	e0bfe817 	ldw	r2,-96(fp)
81144be4:	1885883a 	add	r2,r3,r2
81144be8:	1007883a 	mov	r3,r2
81144bec:	d0a0b117 	ldw	r2,-32060(gp)
81144bf0:	100b883a 	mov	r5,r2
81144bf4:	1809883a 	mov	r4,r3
81144bf8:	1141c280 	call	81141c28 <Read_Sector_Data>
81144bfc:	10002f26 	beq	r2,zero,81144cbc <alt_up_sd_card_find_next+0x1a4>
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
81144c00:	00002306 	br	81144c90 <alt_up_sd_card_find_next+0x178>
						{
							if (Read_File_Record_At_Offset(file_counter*32, &file_record, 0, sector_index))
81144c04:	e0bfe917 	ldw	r2,-92(fp)
81144c08:	1004917a 	slli	r2,r2,5
81144c0c:	e13fe817 	ldw	r4,-96(fp)
81144c10:	e0ffef04 	addi	r3,fp,-68
81144c14:	200f883a 	mov	r7,r4
81144c18:	000d883a 	mov	r6,zero
81144c1c:	180b883a 	mov	r5,r3
81144c20:	1009883a 	mov	r4,r2
81144c24:	11420580 	call	81142058 <Read_File_Record_At_Offset>
81144c28:	10001626 	beq	r2,zero,81144c84 <alt_up_sd_card_find_next+0x16c>
							{
								if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
81144c2c:	e0bfef03 	ldbu	r2,-68(fp)
81144c30:	10803fcc 	andi	r2,r2,255
81144c34:	10001326 	beq	r2,zero,81144c84 <alt_up_sd_card_find_next+0x16c>
81144c38:	e0bfef03 	ldbu	r2,-68(fp)
81144c3c:	10803fcc 	andi	r2,r2,255
81144c40:	10803960 	cmpeqi	r2,r2,229
81144c44:	10000f1e 	bne	r2,zero,81144c84 <alt_up_sd_card_find_next+0x16c>
								{
									/* Update search structure. */
									search_data.file_index_in_sector = file_counter;
81144c48:	e0bfe917 	ldw	r2,-92(fp)
81144c4c:	1007883a 	mov	r3,r2
81144c50:	00a045f4 	movhi	r2,33047
81144c54:	10b20904 	addi	r2,r2,-14300
81144c58:	10c0030d 	sth	r3,12(r2)
									search_data.current_sector_in_cluster = sector_index;
81144c5c:	e0ffe817 	ldw	r3,-96(fp)
81144c60:	00a045f4 	movhi	r2,33047
81144c64:	10b20904 	addi	r2,r2,-14300
81144c68:	10c00215 	stw	r3,8(r2)

									/* Copy file name.*/
									copy_file_record_name_to_string(&file_record, file_name);
81144c6c:	e0bfef04 	addi	r2,fp,-68
81144c70:	e17fff17 	ldw	r5,-4(fp)
81144c74:	1009883a 	mov	r4,r2
81144c78:	11446ec0 	call	811446ec <copy_file_record_name_to_string>
									return 0;
81144c7c:	0005883a 	mov	r2,zero
81144c80:	00009006 	br	81144ec4 <alt_up_sd_card_find_next+0x3ac>
				for (; sector_index < max_root_dir_sectors; sector_index++)
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
81144c84:	e0bfe917 	ldw	r2,-92(fp)
81144c88:	10800044 	addi	r2,r2,1
81144c8c:	e0bfe915 	stw	r2,-92(fp)
81144c90:	e0bfe917 	ldw	r2,-92(fp)
81144c94:	10800410 	cmplti	r2,r2,16
81144c98:	103fda1e 	bne	r2,zero,81144c04 <__reset+0xfb124c04>
									copy_file_record_name_to_string(&file_record, file_name);
									return 0;
								}
							}
						}
						file_counter = 0;
81144c9c:	e03fe915 	stw	zero,-92(fp)
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
				int sector_index = search_data.current_sector_in_cluster;
				int file_counter = search_data.file_index_in_sector+1;
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
81144ca0:	e0bfe817 	ldw	r2,-96(fp)
81144ca4:	10800044 	addi	r2,r2,1
81144ca8:	e0bfe815 	stw	r2,-96(fp)
81144cac:	e0ffe817 	ldw	r3,-96(fp)
81144cb0:	e0bfec17 	ldw	r2,-80(fp)
81144cb4:	18bfc716 	blt	r3,r2,81144bd4 <__reset+0xfb124bd4>
81144cb8:	00000106 	br	81144cc0 <alt_up_sd_card_find_next+0x1a8>
						}
						file_counter = 0;
					}
					else
					{
						break;
81144cbc:	0001883a 	nop
					}
				}
				result = -1;
81144cc0:	00bfffc4 	movi	r2,-1
81144cc4:	e0bfe60d 	sth	r2,-104(fp)
81144cc8:	00007d06 	br	81144ec0 <alt_up_sd_card_find_next+0x3a8>
			}
			else
			{
				int file_counter = search_data.file_index_in_sector+1;
81144ccc:	00a045f4 	movhi	r2,33047
81144cd0:	10b20904 	addi	r2,r2,-14300
81144cd4:	1080030b 	ldhu	r2,12(r2)
81144cd8:	10bfffcc 	andi	r2,r2,65535
81144cdc:	10a0001c 	xori	r2,r2,32768
81144ce0:	10a00004 	addi	r2,r2,-32768
81144ce4:	10800044 	addi	r2,r2,1
81144ce8:	e0bfea15 	stw	r2,-88(fp)
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
81144cec:	e0bfe717 	ldw	r2,-100(fp)
81144cf0:	10ffff84 	addi	r3,r2,-2
81144cf4:	00a045f4 	movhi	r2,33047
81144cf8:	10b20e04 	addi	r2,r2,-14280
81144cfc:	10800383 	ldbu	r2,14(r2)
81144d00:	10803fcc 	andi	r2,r2,255
81144d04:	1885383a 	mul	r2,r3,r2
81144d08:	1007883a 	mov	r3,r2
81144d0c:	00a045f4 	movhi	r2,33047
81144d10:	10b20e04 	addi	r2,r2,-14280
81144d14:	10801417 	ldw	r2,80(r2)
81144d18:	1885883a 	add	r2,r3,r2
81144d1c:	e0bfed15 	stw	r2,-76(fp)
					int sector_index = search_data.current_sector_in_cluster;
81144d20:	00a045f4 	movhi	r2,33047
81144d24:	10b20904 	addi	r2,r2,-14300
81144d28:	10800217 	ldw	r2,8(r2)
81144d2c:	e0bfeb15 	stw	r2,-84(fp)
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81144d30:	00003806 	br	81144e14 <alt_up_sd_card_find_next+0x2fc>
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
81144d34:	e0ffeb17 	ldw	r3,-84(fp)
81144d38:	e0bfed17 	ldw	r2,-76(fp)
81144d3c:	1885883a 	add	r2,r3,r2
81144d40:	d0e0b117 	ldw	r3,-32060(gp)
81144d44:	180b883a 	mov	r5,r3
81144d48:	1009883a 	mov	r4,r2
81144d4c:	1141c280 	call	81141c28 <Read_Sector_Data>
81144d50:	10003726 	beq	r2,zero,81144e30 <alt_up_sd_card_find_next+0x318>
						{        
							for (; file_counter < 16; file_counter++)
81144d54:	00002806 	br	81144df8 <alt_up_sd_card_find_next+0x2e0>
							{
								if (Read_File_Record_At_Offset(file_counter*32, &file_record, cluster, sector_index))
81144d58:	e0bfea17 	ldw	r2,-88(fp)
81144d5c:	1004917a 	slli	r2,r2,5
81144d60:	e13fe717 	ldw	r4,-100(fp)
81144d64:	e17feb17 	ldw	r5,-84(fp)
81144d68:	e0ffef04 	addi	r3,fp,-68
81144d6c:	280f883a 	mov	r7,r5
81144d70:	200d883a 	mov	r6,r4
81144d74:	180b883a 	mov	r5,r3
81144d78:	1009883a 	mov	r4,r2
81144d7c:	11420580 	call	81142058 <Read_File_Record_At_Offset>
81144d80:	10001a26 	beq	r2,zero,81144dec <alt_up_sd_card_find_next+0x2d4>
								{
									if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
81144d84:	e0bfef03 	ldbu	r2,-68(fp)
81144d88:	10803fcc 	andi	r2,r2,255
81144d8c:	10001726 	beq	r2,zero,81144dec <alt_up_sd_card_find_next+0x2d4>
81144d90:	e0bfef03 	ldbu	r2,-68(fp)
81144d94:	10803fcc 	andi	r2,r2,255
81144d98:	10803960 	cmpeqi	r2,r2,229
81144d9c:	1000131e 	bne	r2,zero,81144dec <alt_up_sd_card_find_next+0x2d4>
									{
										/* Update search structure. */
										search_data.current_cluster_index = cluster;
81144da0:	e0ffe717 	ldw	r3,-100(fp)
81144da4:	00a045f4 	movhi	r2,33047
81144da8:	10b20904 	addi	r2,r2,-14300
81144dac:	10c00115 	stw	r3,4(r2)
										search_data.file_index_in_sector = file_counter;
81144db0:	e0bfea17 	ldw	r2,-88(fp)
81144db4:	1007883a 	mov	r3,r2
81144db8:	00a045f4 	movhi	r2,33047
81144dbc:	10b20904 	addi	r2,r2,-14300
81144dc0:	10c0030d 	sth	r3,12(r2)
										search_data.current_sector_in_cluster = sector_index;
81144dc4:	e0ffeb17 	ldw	r3,-84(fp)
81144dc8:	00a045f4 	movhi	r2,33047
81144dcc:	10b20904 	addi	r2,r2,-14300
81144dd0:	10c00215 	stw	r3,8(r2)

										/* Copy file name.*/
										copy_file_record_name_to_string(&file_record, file_name);
81144dd4:	e0bfef04 	addi	r2,fp,-68
81144dd8:	e17fff17 	ldw	r5,-4(fp)
81144ddc:	1009883a 	mov	r4,r2
81144de0:	11446ec0 	call	811446ec <copy_file_record_name_to_string>
										return 0;
81144de4:	0005883a 	mov	r2,zero
81144de8:	00003606 	br	81144ec4 <alt_up_sd_card_find_next+0x3ac>
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
						{        
							for (; file_counter < 16; file_counter++)
81144dec:	e0bfea17 	ldw	r2,-88(fp)
81144df0:	10800044 	addi	r2,r2,1
81144df4:	e0bfea15 	stw	r2,-88(fp)
81144df8:	e0bfea17 	ldw	r2,-88(fp)
81144dfc:	10800410 	cmplti	r2,r2,16
81144e00:	103fd51e 	bne	r2,zero,81144d58 <__reset+0xfb124d58>
										copy_file_record_name_to_string(&file_record, file_name);
										return 0;
									}
								}
							}
							file_counter = 0;
81144e04:	e03fea15 	stw	zero,-88(fp)
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
					int sector_index = search_data.current_sector_in_cluster;
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81144e08:	e0bfeb17 	ldw	r2,-84(fp)
81144e0c:	10800044 	addi	r2,r2,1
81144e10:	e0bfeb15 	stw	r2,-84(fp)
81144e14:	00a045f4 	movhi	r2,33047
81144e18:	10b20e04 	addi	r2,r2,-14280
81144e1c:	10800383 	ldbu	r2,14(r2)
81144e20:	10803fcc 	andi	r2,r2,255
81144e24:	e0ffeb17 	ldw	r3,-84(fp)
81144e28:	18bfc216 	blt	r3,r2,81144d34 <__reset+0xfb124d34>
81144e2c:	00000106 	br	81144e34 <alt_up_sd_card_find_next+0x31c>
							}
							file_counter = 0;
						}
						else
						{
							break;
81144e30:	0001883a 	nop
						}
					}
					// If this is the end of the cluster and the file has not been found, then see if there is another cluster
					// that holds data for the current directory.
					if (sector_index >= boot_sector_data.sectors_per_cluster)
81144e34:	00a045f4 	movhi	r2,33047
81144e38:	10b20e04 	addi	r2,r2,-14280
81144e3c:	10800383 	ldbu	r2,14(r2)
81144e40:	10803fcc 	andi	r2,r2,255
81144e44:	e0ffeb17 	ldw	r3,-84(fp)
81144e48:	18801716 	blt	r3,r2,81144ea8 <alt_up_sd_card_find_next+0x390>
					{
						unsigned short int new_cluster;

						if (get_cluster_flag(cluster, &new_cluster))
81144e4c:	e0bfe717 	ldw	r2,-100(fp)
81144e50:	e0ffee04 	addi	r3,fp,-72
81144e54:	180b883a 	mov	r5,r3
81144e58:	1009883a 	mov	r4,r2
81144e5c:	1141d080 	call	81141d08 <get_cluster_flag>
81144e60:	10000f26 	beq	r2,zero,81144ea0 <alt_up_sd_card_find_next+0x388>
						{
							if ((new_cluster & 0x0000fff8) == 0x0000fff8)
81144e64:	e0bfee0b 	ldhu	r2,-72(fp)
81144e68:	10bfffcc 	andi	r2,r2,65535
81144e6c:	10fffe0c 	andi	r3,r2,65528
81144e70:	00bffe14 	movui	r2,65528
81144e74:	1880051e 	bne	r3,r2,81144e8c <alt_up_sd_card_find_next+0x374>
							{
								result = -1;
81144e78:	00bfffc4 	movi	r2,-1
81144e7c:	e0bfe60d 	sth	r2,-104(fp)
								search_data.valid = false;
81144e80:	00a045f4 	movhi	r2,33047
81144e84:	10b20904 	addi	r2,r2,-14300
81144e88:	10000415 	stw	zero,16(r2)
							}
							cluster = ((new_cluster) & 0x0000fff8);
81144e8c:	e0bfee0b 	ldhu	r2,-72(fp)
81144e90:	10bfffcc 	andi	r2,r2,65535
81144e94:	10bffe0c 	andi	r2,r2,65528
81144e98:	e0bfe715 	stw	r2,-100(fp)
81144e9c:	00000206 	br	81144ea8 <alt_up_sd_card_find_next+0x390>
						}
						else
						{
							// Error encountered.                 
							result = -1;
81144ea0:	00bfffc4 	movi	r2,-1
81144ea4:	e0bfe60d 	sth	r2,-104(fp)
						}
					}              
				} while (cluster < 0x0000fff8);
81144ea8:	e0bfe717 	ldw	r2,-100(fp)
81144eac:	00fffdd4 	movui	r3,65527
81144eb0:	18bf8e0e 	bge	r3,r2,81144cec <__reset+0xfb124cec>
81144eb4:	00000206 	br	81144ec0 <alt_up_sd_card_find_next+0x3a8>
			}
		}
		else
		{
			// Call Find_First first.
			result = 3;
81144eb8:	008000c4 	movi	r2,3
81144ebc:	e0bfe60d 	sth	r2,-104(fp)
		}
	}
	return result;
81144ec0:	e0bfe60b 	ldhu	r2,-104(fp)
}
81144ec4:	e037883a 	mov	sp,fp
81144ec8:	dfc00117 	ldw	ra,4(sp)
81144ecc:	df000017 	ldw	fp,0(sp)
81144ed0:	dec00204 	addi	sp,sp,8
81144ed4:	f800283a 	ret

81144ed8 <alt_up_sd_card_fopen>:
 *      create - a flag set to true to create a file if it does not already exist
 * Output:
 *      An index to the file record assigned to the specified file. -1 is returned if the file could not be opened.
 *		Return -2 if the specified file has already been opened previously.
 */
{
81144ed8:	deffe904 	addi	sp,sp,-92
81144edc:	de00012e 	bgeu	sp,et,81144ee4 <alt_up_sd_card_fopen+0xc>
81144ee0:	003b68fa 	trap	3
81144ee4:	dfc01615 	stw	ra,88(sp)
81144ee8:	df001515 	stw	fp,84(sp)
81144eec:	df001504 	addi	fp,sp,84
81144ef0:	e13ffe15 	stw	r4,-8(fp)
81144ef4:	e17fff15 	stw	r5,-4(fp)
	short int file_record_index = -1;
81144ef8:	00bfffc4 	movi	r2,-1
81144efc:	e0bfeb0d 	sth	r2,-84(fp)

	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81144f00:	11449000 	call	81144900 <alt_up_sd_card_is_Present>
81144f04:	1000cf26 	beq	r2,zero,81145244 <alt_up_sd_card_fopen+0x36c>
81144f08:	d0a0aa17 	ldw	r2,-32088(gp)
81144f0c:	1000cd26 	beq	r2,zero,81145244 <alt_up_sd_card_fopen+0x36c>
	{
        unsigned int home_directory_cluster = 0;
81144f10:	e03fed15 	stw	zero,-76(fp)
         * Rules:
         *  - no spaces
         *  - at most 12 chatacters per name, with a period in 9th position.
         *  - a / or a \ every at most 12 characters.
         */
        filename_to_upper_case(name);
81144f14:	e13ffe17 	ldw	r4,-8(fp)
81144f18:	1142cec0 	call	81142cec <filename_to_upper_case>
        if (check_file_name_for_FAT16_compliance(name))
81144f1c:	e13ffe17 	ldw	r4,-8(fp)
81144f20:	1142db80 	call	81142db8 <check_file_name_for_FAT16_compliance>
81144f24:	1000c726 	beq	r2,zero,81145244 <alt_up_sd_card_fopen+0x36c>
        {
			int index;

            /* Get home directory cluster location for the specified file. 0 means root directory. */
            if (!get_home_directory_cluster_for_file(name, (int *) &home_directory_cluster, &home_dir))
81144f28:	e0ffee04 	addi	r3,fp,-72
81144f2c:	e0bfed04 	addi	r2,fp,-76
81144f30:	180d883a 	mov	r6,r3
81144f34:	100b883a 	mov	r5,r2
81144f38:	e13ffe17 	ldw	r4,-8(fp)
81144f3c:	11433900 	call	81143390 <get_home_directory_cluster_for_file>
81144f40:	1000021e 	bne	r2,zero,81144f4c <alt_up_sd_card_fopen+0x74>
            {
                return file_record_index;
81144f44:	e0bfeb0b 	ldhu	r2,-84(fp)
81144f48:	0000bf06 	br	81145248 <alt_up_sd_card_fopen+0x370>
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
81144f4c:	e03fec15 	stw	zero,-80(fp)
81144f50:	00000e06 	br	81144f8c <alt_up_sd_card_fopen+0xb4>
    		{
    			if (active_files[index].in_use == false)
81144f54:	00a045f4 	movhi	r2,33047
81144f58:	10b22304 	addi	r2,r2,-14196
81144f5c:	e0ffec17 	ldw	r3,-80(fp)
81144f60:	180691ba 	slli	r3,r3,6
81144f64:	10c5883a 	add	r2,r2,r3
81144f68:	10800f04 	addi	r2,r2,60
81144f6c:	10800017 	ldw	r2,0(r2)
81144f70:	1000031e 	bne	r2,zero,81144f80 <alt_up_sd_card_fopen+0xa8>
    			{
    				file_record_index = index;
81144f74:	e0bfec17 	ldw	r2,-80(fp)
81144f78:	e0bfeb0d 	sth	r2,-84(fp)
    				break;
81144f7c:	00000606 	br	81144f98 <alt_up_sd_card_fopen+0xc0>
            {
                return file_record_index;
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
81144f80:	e0bfec17 	ldw	r2,-80(fp)
81144f84:	10800044 	addi	r2,r2,1
81144f88:	e0bfec15 	stw	r2,-80(fp)
81144f8c:	e0bfec17 	ldw	r2,-80(fp)
81144f90:	10800510 	cmplti	r2,r2,20
81144f94:	103fef1e 	bne	r2,zero,81144f54 <__reset+0xfb124f54>
    			{
    				file_record_index = index;
    				break;
    			}
    		}
    		if (file_record_index >= 0)
81144f98:	e0bfeb0f 	ldh	r2,-84(fp)
81144f9c:	1000a916 	blt	r2,zero,81145244 <alt_up_sd_card_fopen+0x36c>
    		{
    			/* If file record is found, then look for the specified file. If the create flag is set to true 
    			 * and the file is not found, then it should be created in the current directory. 
    			 */
                
                if (find_file_in_directory(home_directory_cluster, name, &(active_files[file_record_index])))
81144fa0:	e0bfed17 	ldw	r2,-76(fp)
81144fa4:	1009883a 	mov	r4,r2
81144fa8:	e0bfeb0f 	ldh	r2,-84(fp)
81144fac:	100691ba 	slli	r3,r2,6
81144fb0:	00a045f4 	movhi	r2,33047
81144fb4:	10b22304 	addi	r2,r2,-14196
81144fb8:	1885883a 	add	r2,r3,r2
81144fbc:	100d883a 	mov	r6,r2
81144fc0:	e17ffe17 	ldw	r5,-8(fp)
81144fc4:	11438d00 	call	811438d0 <find_file_in_directory>
81144fc8:	10007b26 	beq	r2,zero,811451b8 <alt_up_sd_card_fopen+0x2e0>
                {
                    if (create)
81144fcc:	e0bfff17 	ldw	r2,-4(fp)
81144fd0:	10000226 	beq	r2,zero,81144fdc <alt_up_sd_card_fopen+0x104>
                    {
                        /* Do not allow overwriting existing files for now. */
                        return -1;
81144fd4:	00bfffc4 	movi	r2,-1
81144fd8:	00009b06 	br	81145248 <alt_up_sd_card_fopen+0x370>
                    }
                    active_files[file_record_index].current_cluster_index = active_files[file_record_index].start_cluster_index;
81144fdc:	e13feb0f 	ldh	r4,-84(fp)
81144fe0:	e0ffeb0f 	ldh	r3,-84(fp)
81144fe4:	00a045f4 	movhi	r2,33047
81144fe8:	10b22304 	addi	r2,r2,-14196
81144fec:	180691ba 	slli	r3,r3,6
81144ff0:	10c5883a 	add	r2,r2,r3
81144ff4:	10800584 	addi	r2,r2,22
81144ff8:	1080000b 	ldhu	r2,0(r2)
81144ffc:	10ffffcc 	andi	r3,r2,65535
81145000:	00a045f4 	movhi	r2,33047
81145004:	10b22304 	addi	r2,r2,-14196
81145008:	200891ba 	slli	r4,r4,6
8114500c:	1105883a 	add	r2,r2,r4
81145010:	10800704 	addi	r2,r2,28
81145014:	10c00015 	stw	r3,0(r2)
                    active_files[file_record_index].current_sector_in_cluster = 0;
81145018:	e0ffeb0f 	ldh	r3,-84(fp)
8114501c:	00a045f4 	movhi	r2,33047
81145020:	10b22304 	addi	r2,r2,-14196
81145024:	180691ba 	slli	r3,r3,6
81145028:	10c5883a 	add	r2,r2,r3
8114502c:	10800804 	addi	r2,r2,32
81145030:	10000015 	stw	zero,0(r2)
                    active_files[file_record_index].current_byte_position = 0;
81145034:	e0ffeb0f 	ldh	r3,-84(fp)
81145038:	00a045f4 	movhi	r2,33047
8114503c:	10b22304 	addi	r2,r2,-14196
81145040:	180691ba 	slli	r3,r3,6
81145044:	10c5883a 	add	r2,r2,r3
81145048:	10800904 	addi	r2,r2,36
8114504c:	10000015 	stw	zero,0(r2)
                    active_files[file_record_index].in_use = true;
81145050:	e0ffeb0f 	ldh	r3,-84(fp)
81145054:	00a045f4 	movhi	r2,33047
81145058:	10b22304 	addi	r2,r2,-14196
8114505c:	180691ba 	slli	r3,r3,6
81145060:	10c5883a 	add	r2,r2,r3
81145064:	10800f04 	addi	r2,r2,60
81145068:	00c00044 	movi	r3,1
8114506c:	10c00015 	stw	r3,0(r2)
    				active_files[file_record_index].modified = false;
81145070:	e0ffeb0f 	ldh	r3,-84(fp)
81145074:	00a045f4 	movhi	r2,33047
81145078:	10b22304 	addi	r2,r2,-14196
8114507c:	180691ba 	slli	r3,r3,6
81145080:	10c5883a 	add	r2,r2,r3
81145084:	10800e04 	addi	r2,r2,56
81145088:	10000015 	stw	zero,0(r2)

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
8114508c:	e03fec15 	stw	zero,-80(fp)
81145090:	00004506 	br	811451a8 <alt_up_sd_card_fopen+0x2d0>
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
81145094:	e0ffeb0f 	ldh	r3,-84(fp)
81145098:	e0bfec17 	ldw	r2,-80(fp)
8114509c:	18803f26 	beq	r3,r2,8114519c <alt_up_sd_card_fopen+0x2c4>
811450a0:	00a045f4 	movhi	r2,33047
811450a4:	10b22304 	addi	r2,r2,-14196
811450a8:	e0ffec17 	ldw	r3,-80(fp)
811450ac:	180691ba 	slli	r3,r3,6
811450b0:	10c5883a 	add	r2,r2,r3
811450b4:	10800f04 	addi	r2,r2,60
811450b8:	10800017 	ldw	r2,0(r2)
811450bc:	10800058 	cmpnei	r2,r2,1
811450c0:	1000361e 	bne	r2,zero,8114519c <alt_up_sd_card_fopen+0x2c4>
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
811450c4:	e0ffeb0f 	ldh	r3,-84(fp)
811450c8:	00a045f4 	movhi	r2,33047
811450cc:	10b22304 	addi	r2,r2,-14196
811450d0:	180691ba 	slli	r3,r3,6
811450d4:	10c5883a 	add	r2,r2,r3
811450d8:	10800a04 	addi	r2,r2,40
811450dc:	10c00017 	ldw	r3,0(r2)
811450e0:	00a045f4 	movhi	r2,33047
811450e4:	10b22304 	addi	r2,r2,-14196
811450e8:	e13fec17 	ldw	r4,-80(fp)
811450ec:	200891ba 	slli	r4,r4,6
811450f0:	1105883a 	add	r2,r2,r4
811450f4:	10800a04 	addi	r2,r2,40
811450f8:	10800017 	ldw	r2,0(r2)
811450fc:	1880271e 	bne	r3,r2,8114519c <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
81145100:	e0ffeb0f 	ldh	r3,-84(fp)
81145104:	00a045f4 	movhi	r2,33047
81145108:	10b22304 	addi	r2,r2,-14196
8114510c:	180691ba 	slli	r3,r3,6
81145110:	10c5883a 	add	r2,r2,r3
81145114:	10800b04 	addi	r2,r2,44
81145118:	10c00017 	ldw	r3,0(r2)
8114511c:	00a045f4 	movhi	r2,33047
81145120:	10b22304 	addi	r2,r2,-14196
81145124:	e13fec17 	ldw	r4,-80(fp)
81145128:	200891ba 	slli	r4,r4,6
8114512c:	1105883a 	add	r2,r2,r4
81145130:	10800b04 	addi	r2,r2,44
81145134:	10800017 	ldw	r2,0(r2)
					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
81145138:	1880181e 	bne	r3,r2,8114519c <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
8114513c:	e0ffeb0f 	ldh	r3,-84(fp)
81145140:	00a045f4 	movhi	r2,33047
81145144:	10b22304 	addi	r2,r2,-14196
81145148:	180691ba 	slli	r3,r3,6
8114514c:	10c5883a 	add	r2,r2,r3
81145150:	10800c04 	addi	r2,r2,48
81145154:	1100000b 	ldhu	r4,0(r2)
81145158:	00a045f4 	movhi	r2,33047
8114515c:	10b22304 	addi	r2,r2,-14196
81145160:	e0ffec17 	ldw	r3,-80(fp)
81145164:	180691ba 	slli	r3,r3,6
81145168:	10c5883a 	add	r2,r2,r3
8114516c:	10800c04 	addi	r2,r2,48
81145170:	1080000b 	ldhu	r2,0(r2)
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
81145174:	20ffffcc 	andi	r3,r4,65535
81145178:	18e0001c 	xori	r3,r3,32768
8114517c:	18e00004 	addi	r3,r3,-32768
81145180:	10bfffcc 	andi	r2,r2,65535
81145184:	10a0001c 	xori	r2,r2,32768
81145188:	10a00004 	addi	r2,r2,-32768
8114518c:	1880031e 	bne	r3,r2,8114519c <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
							{
								// file already in use.
								file_record_index = -2;
81145190:	00bfff84 	movi	r2,-2
81145194:	e0bfeb0d 	sth	r2,-84(fp)
								break;
81145198:	00002a06 	br	81145244 <alt_up_sd_card_fopen+0x36c>
                    active_files[file_record_index].current_byte_position = 0;
                    active_files[file_record_index].in_use = true;
    				active_files[file_record_index].modified = false;

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
8114519c:	e0bfec17 	ldw	r2,-80(fp)
811451a0:	10800044 	addi	r2,r2,1
811451a4:	e0bfec15 	stw	r2,-80(fp)
811451a8:	e0bfec17 	ldw	r2,-80(fp)
811451ac:	10800510 	cmplti	r2,r2,20
811451b0:	103fb81e 	bne	r2,zero,81145094 <__reset+0xfb125094>
811451b4:	00002306 	br	81145244 <alt_up_sd_card_fopen+0x36c>
							}
						}
					}

                }
                else if (create)
811451b8:	e0bfff17 	ldw	r2,-4(fp)
811451bc:	10001f26 	beq	r2,zero,8114523c <alt_up_sd_card_fopen+0x364>
                {
                    /* Create file if needed. */
                    if (create_file(name, &(active_files[file_record_index]), &home_dir))
811451c0:	e0bfeb0f 	ldh	r2,-84(fp)
811451c4:	100691ba 	slli	r3,r2,6
811451c8:	00a045f4 	movhi	r2,33047
811451cc:	10b22304 	addi	r2,r2,-14196
811451d0:	1885883a 	add	r2,r3,r2
811451d4:	e0ffee04 	addi	r3,fp,-72
811451d8:	180d883a 	mov	r6,r3
811451dc:	100b883a 	mov	r5,r2
811451e0:	e13ffe17 	ldw	r4,-8(fp)
811451e4:	114441c0 	call	8114441c <create_file>
811451e8:	10001126 	beq	r2,zero,81145230 <alt_up_sd_card_fopen+0x358>
                    {
                        active_files[file_record_index].in_use = true;
811451ec:	e0ffeb0f 	ldh	r3,-84(fp)
811451f0:	00a045f4 	movhi	r2,33047
811451f4:	10b22304 	addi	r2,r2,-14196
811451f8:	180691ba 	slli	r3,r3,6
811451fc:	10c5883a 	add	r2,r2,r3
81145200:	10800f04 	addi	r2,r2,60
81145204:	00c00044 	movi	r3,1
81145208:	10c00015 	stw	r3,0(r2)
    					active_files[file_record_index].modified = true;
8114520c:	e0ffeb0f 	ldh	r3,-84(fp)
81145210:	00a045f4 	movhi	r2,33047
81145214:	10b22304 	addi	r2,r2,-14196
81145218:	180691ba 	slli	r3,r3,6
8114521c:	10c5883a 	add	r2,r2,r3
81145220:	10800e04 	addi	r2,r2,56
81145224:	00c00044 	movi	r3,1
81145228:	10c00015 	stw	r3,0(r2)
8114522c:	00000506 	br	81145244 <alt_up_sd_card_fopen+0x36c>
                    }
                    else
                    {
                        /* If file creation fails then return an invalid file handle. */
                        file_record_index = -1;
81145230:	00bfffc4 	movi	r2,-1
81145234:	e0bfeb0d 	sth	r2,-84(fp)
81145238:	00000206 	br	81145244 <alt_up_sd_card_fopen+0x36c>
                    }                
                }
                else
                {
                    /* Otherwise the file could not be opened.*/
                    file_record_index = -1;
8114523c:	00bfffc4 	movi	r2,-1
81145240:	e0bfeb0d 	sth	r2,-84(fp)
                }
    		}
        }
	}

	return file_record_index;
81145244:	e0bfeb0b 	ldhu	r2,-84(fp)
}
81145248:	e037883a 	mov	sp,fp
8114524c:	dfc00117 	ldw	ra,4(sp)
81145250:	df000017 	ldw	fp,0(sp)
81145254:	dec00204 	addi	sp,sp,8
81145258:	f800283a 	ret

8114525c <alt_up_sd_card_set_attributes>:


void alt_up_sd_card_set_attributes(short int file_handle, short int attributes)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
8114525c:	defffd04 	addi	sp,sp,-12
81145260:	de00012e 	bgeu	sp,et,81145268 <alt_up_sd_card_set_attributes+0xc>
81145264:	003b68fa 	trap	3
81145268:	df000215 	stw	fp,8(sp)
8114526c:	df000204 	addi	fp,sp,8
81145270:	2007883a 	mov	r3,r4
81145274:	2805883a 	mov	r2,r5
81145278:	e0fffe0d 	sth	r3,-8(fp)
8114527c:	e0bfff0d 	sth	r2,-4(fp)
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
81145280:	e0bffe0f 	ldh	r2,-8(fp)
81145284:	10001416 	blt	r2,zero,811452d8 <alt_up_sd_card_set_attributes+0x7c>
81145288:	e0bffe0f 	ldh	r2,-8(fp)
8114528c:	10800508 	cmpgei	r2,r2,20
81145290:	1000111e 	bne	r2,zero,811452d8 <alt_up_sd_card_set_attributes+0x7c>
    {
        if (active_files[file_handle].in_use)
81145294:	e0fffe0f 	ldh	r3,-8(fp)
81145298:	00a045f4 	movhi	r2,33047
8114529c:	10b22304 	addi	r2,r2,-14196
811452a0:	180691ba 	slli	r3,r3,6
811452a4:	10c5883a 	add	r2,r2,r3
811452a8:	10800f04 	addi	r2,r2,60
811452ac:	10800017 	ldw	r2,0(r2)
811452b0:	10000926 	beq	r2,zero,811452d8 <alt_up_sd_card_set_attributes+0x7c>
        {
            active_files[file_handle].attributes = ((char)(attributes & 0x00ff));
811452b4:	e0fffe0f 	ldh	r3,-8(fp)
811452b8:	e0bfff0b 	ldhu	r2,-4(fp)
811452bc:	1009883a 	mov	r4,r2
811452c0:	00a045f4 	movhi	r2,33047
811452c4:	10b22304 	addi	r2,r2,-14196
811452c8:	180691ba 	slli	r3,r3,6
811452cc:	10c5883a 	add	r2,r2,r3
811452d0:	108002c4 	addi	r2,r2,11
811452d4:	11000005 	stb	r4,0(r2)
        }
    }
}
811452d8:	0001883a 	nop
811452dc:	e037883a 	mov	sp,fp
811452e0:	df000017 	ldw	fp,0(sp)
811452e4:	dec00104 	addi	sp,sp,4
811452e8:	f800283a 	ret

811452ec <alt_up_sd_card_get_attributes>:


short int alt_up_sd_card_get_attributes(short int file_handle)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
811452ec:	defffd04 	addi	sp,sp,-12
811452f0:	de00012e 	bgeu	sp,et,811452f8 <alt_up_sd_card_get_attributes+0xc>
811452f4:	003b68fa 	trap	3
811452f8:	df000215 	stw	fp,8(sp)
811452fc:	df000204 	addi	fp,sp,8
81145300:	2005883a 	mov	r2,r4
81145304:	e0bfff0d 	sth	r2,-4(fp)
	short int result = -1;
81145308:	00bfffc4 	movi	r2,-1
8114530c:	e0bffe0d 	sth	r2,-8(fp)
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
81145310:	e0bfff0f 	ldh	r2,-4(fp)
81145314:	10001416 	blt	r2,zero,81145368 <alt_up_sd_card_get_attributes+0x7c>
81145318:	e0bfff0f 	ldh	r2,-4(fp)
8114531c:	10800508 	cmpgei	r2,r2,20
81145320:	1000111e 	bne	r2,zero,81145368 <alt_up_sd_card_get_attributes+0x7c>
    {
        if (active_files[file_handle].in_use)
81145324:	e0ffff0f 	ldh	r3,-4(fp)
81145328:	00a045f4 	movhi	r2,33047
8114532c:	10b22304 	addi	r2,r2,-14196
81145330:	180691ba 	slli	r3,r3,6
81145334:	10c5883a 	add	r2,r2,r3
81145338:	10800f04 	addi	r2,r2,60
8114533c:	10800017 	ldw	r2,0(r2)
81145340:	10000926 	beq	r2,zero,81145368 <alt_up_sd_card_get_attributes+0x7c>
		{
			result = ((active_files[file_handle].attributes) & 0x00ff);
81145344:	e0ffff0f 	ldh	r3,-4(fp)
81145348:	00a045f4 	movhi	r2,33047
8114534c:	10b22304 	addi	r2,r2,-14196
81145350:	180691ba 	slli	r3,r3,6
81145354:	10c5883a 	add	r2,r2,r3
81145358:	108002c4 	addi	r2,r2,11
8114535c:	10800003 	ldbu	r2,0(r2)
81145360:	10803fcc 	andi	r2,r2,255
81145364:	e0bffe0d 	sth	r2,-8(fp)
		}
	}
	return result;
81145368:	e0bffe0b 	ldhu	r2,-8(fp)
}
8114536c:	e037883a 	mov	sp,fp
81145370:	df000017 	ldw	fp,0(sp)
81145374:	dec00104 	addi	sp,sp,4
81145378:	f800283a 	ret

8114537c <alt_up_sd_card_read>:

short int alt_up_sd_card_read(short int file_handle)
/* Read a single character from a given file. Return -1 if at the end of a file. Any other negative number
 * means that the file could not be read. A number between 0 and 255 is an ASCII character read from the SD Card. */
{
8114537c:	defffa04 	addi	sp,sp,-24
81145380:	de00012e 	bgeu	sp,et,81145388 <alt_up_sd_card_read+0xc>
81145384:	003b68fa 	trap	3
81145388:	dfc00515 	stw	ra,20(sp)
8114538c:	df000415 	stw	fp,16(sp)
81145390:	df000404 	addi	fp,sp,16
81145394:	2005883a 	mov	r2,r4
81145398:	e0bfff0d 	sth	r2,-4(fp)
    short int ch = -1;
8114539c:	00bfffc4 	movi	r2,-1
811453a0:	e0bffc0d 	sth	r2,-16(fp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
811453a4:	e0bfff0f 	ldh	r2,-4(fp)
811453a8:	1000ce16 	blt	r2,zero,811456e4 <alt_up_sd_card_read+0x368>
811453ac:	e0bfff0f 	ldh	r2,-4(fp)
811453b0:	10800508 	cmpgei	r2,r2,20
811453b4:	1000cb1e 	bne	r2,zero,811456e4 <alt_up_sd_card_read+0x368>
    {
        if (active_files[file_handle].in_use)
811453b8:	e0ffff0f 	ldh	r3,-4(fp)
811453bc:	00a045f4 	movhi	r2,33047
811453c0:	10b22304 	addi	r2,r2,-14196
811453c4:	180691ba 	slli	r3,r3,6
811453c8:	10c5883a 	add	r2,r2,r3
811453cc:	10800f04 	addi	r2,r2,60
811453d0:	10800017 	ldw	r2,0(r2)
811453d4:	1000c326 	beq	r2,zero,811456e4 <alt_up_sd_card_read+0x368>
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
811453d8:	e0ffff0f 	ldh	r3,-4(fp)
811453dc:	00a045f4 	movhi	r2,33047
811453e0:	10b22304 	addi	r2,r2,-14196
811453e4:	180691ba 	slli	r3,r3,6
811453e8:	10c5883a 	add	r2,r2,r3
811453ec:	10800904 	addi	r2,r2,36
811453f0:	10c00017 	ldw	r3,0(r2)
811453f4:	e13fff0f 	ldh	r4,-4(fp)
811453f8:	00a045f4 	movhi	r2,33047
811453fc:	10b22304 	addi	r2,r2,-14196
81145400:	200891ba 	slli	r4,r4,6
81145404:	1105883a 	add	r2,r2,r4
81145408:	10800604 	addi	r2,r2,24
8114540c:	10800017 	ldw	r2,0(r2)
81145410:	1880b42e 	bgeu	r3,r2,811456e4 <alt_up_sd_card_read+0x368>
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81145414:	00a045f4 	movhi	r2,33047
81145418:	10b20e04 	addi	r2,r2,-14280
8114541c:	10c01417 	ldw	r3,80(r2)
81145420:	e13fff0f 	ldh	r4,-4(fp)
81145424:	00a045f4 	movhi	r2,33047
81145428:	10b22304 	addi	r2,r2,-14196
8114542c:	200891ba 	slli	r4,r4,6
81145430:	1105883a 	add	r2,r2,r4
81145434:	10800704 	addi	r2,r2,28
81145438:	10800017 	ldw	r2,0(r2)
8114543c:	113fff84 	addi	r4,r2,-2
81145440:	00a045f4 	movhi	r2,33047
81145444:	10b20e04 	addi	r2,r2,-14280
81145448:	10800383 	ldbu	r2,14(r2)
8114544c:	10803fcc 	andi	r2,r2,255
81145450:	2085383a 	mul	r2,r4,r2
81145454:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;
81145458:	e13fff0f 	ldh	r4,-4(fp)
8114545c:	00a045f4 	movhi	r2,33047
81145460:	10b22304 	addi	r2,r2,-14196
81145464:	200891ba 	slli	r4,r4,6
81145468:	1105883a 	add	r2,r2,r4
8114546c:	10800804 	addi	r2,r2,32
81145470:	10800017 	ldw	r2,0(r2)
    {
        if (active_files[file_handle].in_use)
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81145474:	1885883a 	add	r2,r3,r2
81145478:	e0bffd15 	stw	r2,-12(fp)
                                  active_files[file_handle].current_sector_in_cluster;
                
                if ((active_files[file_handle].current_byte_position > 0) && ((active_files[file_handle].current_byte_position % 512) == 0))
8114547c:	e0ffff0f 	ldh	r3,-4(fp)
81145480:	00a045f4 	movhi	r2,33047
81145484:	10b22304 	addi	r2,r2,-14196
81145488:	180691ba 	slli	r3,r3,6
8114548c:	10c5883a 	add	r2,r2,r3
81145490:	10800904 	addi	r2,r2,36
81145494:	10800017 	ldw	r2,0(r2)
81145498:	10006826 	beq	r2,zero,8114563c <alt_up_sd_card_read+0x2c0>
8114549c:	e0ffff0f 	ldh	r3,-4(fp)
811454a0:	00a045f4 	movhi	r2,33047
811454a4:	10b22304 	addi	r2,r2,-14196
811454a8:	180691ba 	slli	r3,r3,6
811454ac:	10c5883a 	add	r2,r2,r3
811454b0:	10800904 	addi	r2,r2,36
811454b4:	10800017 	ldw	r2,0(r2)
811454b8:	10807fcc 	andi	r2,r2,511
811454bc:	10005f1e 	bne	r2,zero,8114563c <alt_up_sd_card_read+0x2c0>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
811454c0:	e0ffff0f 	ldh	r3,-4(fp)
811454c4:	00a045f4 	movhi	r2,33047
811454c8:	10b22304 	addi	r2,r2,-14196
811454cc:	180691ba 	slli	r3,r3,6
811454d0:	10c5883a 	add	r2,r2,r3
811454d4:	10800804 	addi	r2,r2,32
811454d8:	10c00017 	ldw	r3,0(r2)
811454dc:	00a045f4 	movhi	r2,33047
811454e0:	10b20e04 	addi	r2,r2,-14280
811454e4:	10800383 	ldbu	r2,14(r2)
811454e8:	10803fcc 	andi	r2,r2,255
811454ec:	10bfffc4 	addi	r2,r2,-1
811454f0:	1880401e 	bne	r3,r2,811455f4 <alt_up_sd_card_read+0x278>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
811454f4:	e0ffff0f 	ldh	r3,-4(fp)
811454f8:	00a045f4 	movhi	r2,33047
811454fc:	10b22304 	addi	r2,r2,-14196
81145500:	180691ba 	slli	r3,r3,6
81145504:	10c5883a 	add	r2,r2,r3
81145508:	10800704 	addi	r2,r2,28
8114550c:	10800017 	ldw	r2,0(r2)
81145510:	e0fffe04 	addi	r3,fp,-8
81145514:	180b883a 	mov	r5,r3
81145518:	1009883a 	mov	r4,r2
8114551c:	1141d080 	call	81141d08 <get_cluster_flag>
81145520:	10003226 	beq	r2,zero,811455ec <alt_up_sd_card_read+0x270>
                        {
                            if ((next_cluster & 0x0000fff8) == 0x0000fff8)
81145524:	e0bffe0b 	ldhu	r2,-8(fp)
81145528:	10bfffcc 	andi	r2,r2,65535
8114552c:	10fffe0c 	andi	r3,r2,65528
81145530:	00bffe14 	movui	r2,65528
81145534:	1880021e 	bne	r3,r2,81145540 <alt_up_sd_card_read+0x1c4>
                            {
                                /* End of file */
                                return -1;
81145538:	00bfffc4 	movi	r2,-1
8114553c:	00006a06 	br	811456e8 <alt_up_sd_card_read+0x36c>
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
81145540:	e13fff0f 	ldh	r4,-4(fp)
81145544:	e0bffe0b 	ldhu	r2,-8(fp)
81145548:	10ffffcc 	andi	r3,r2,65535
8114554c:	00a045f4 	movhi	r2,33047
81145550:	10b22304 	addi	r2,r2,-14196
81145554:	200891ba 	slli	r4,r4,6
81145558:	1105883a 	add	r2,r2,r4
8114555c:	10800704 	addi	r2,r2,28
81145560:	10c00015 	stw	r3,0(r2)
								active_files[file_handle].current_sector_in_cluster = 0;
81145564:	e0ffff0f 	ldh	r3,-4(fp)
81145568:	00a045f4 	movhi	r2,33047
8114556c:	10b22304 	addi	r2,r2,-14196
81145570:	180691ba 	slli	r3,r3,6
81145574:	10c5883a 	add	r2,r2,r3
81145578:	10800804 	addi	r2,r2,32
8114557c:	10000015 	stw	zero,0(r2)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81145580:	00a045f4 	movhi	r2,33047
81145584:	10b20e04 	addi	r2,r2,-14280
81145588:	10c01417 	ldw	r3,80(r2)
8114558c:	e13fff0f 	ldh	r4,-4(fp)
81145590:	00a045f4 	movhi	r2,33047
81145594:	10b22304 	addi	r2,r2,-14196
81145598:	200891ba 	slli	r4,r4,6
8114559c:	1105883a 	add	r2,r2,r4
811455a0:	10800704 	addi	r2,r2,28
811455a4:	10800017 	ldw	r2,0(r2)
811455a8:	113fff84 	addi	r4,r2,-2
811455ac:	00a045f4 	movhi	r2,33047
811455b0:	10b20e04 	addi	r2,r2,-14280
811455b4:	10800383 	ldbu	r2,14(r2)
811455b8:	10803fcc 	andi	r2,r2,255
811455bc:	2085383a 	mul	r2,r4,r2
811455c0:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;                                
811455c4:	e13fff0f 	ldh	r4,-4(fp)
811455c8:	00a045f4 	movhi	r2,33047
811455cc:	10b22304 	addi	r2,r2,-14196
811455d0:	200891ba 	slli	r4,r4,6
811455d4:	1105883a 	add	r2,r2,r4
811455d8:	10800804 	addi	r2,r2,32
811455dc:	10800017 	ldw	r2,0(r2)
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
811455e0:	1885883a 	add	r2,r3,r2
811455e4:	e0bffd15 	stw	r2,-12(fp)
811455e8:	00001406 	br	8114563c <alt_up_sd_card_read+0x2c0>
                                  active_files[file_handle].current_sector_in_cluster;                                
                            }
                        }
                        else
                        {
                            return -2;
811455ec:	00bfff84 	movi	r2,-2
811455f0:	00003d06 	br	811456e8 <alt_up_sd_card_read+0x36c>
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
811455f4:	e13fff0f 	ldh	r4,-4(fp)
811455f8:	e0ffff0f 	ldh	r3,-4(fp)
811455fc:	00a045f4 	movhi	r2,33047
81145600:	10b22304 	addi	r2,r2,-14196
81145604:	180691ba 	slli	r3,r3,6
81145608:	10c5883a 	add	r2,r2,r3
8114560c:	10800804 	addi	r2,r2,32
81145610:	10800017 	ldw	r2,0(r2)
81145614:	10c00044 	addi	r3,r2,1
81145618:	00a045f4 	movhi	r2,33047
8114561c:	10b22304 	addi	r2,r2,-14196
81145620:	200891ba 	slli	r4,r4,6
81145624:	1105883a 	add	r2,r2,r4
81145628:	10800804 	addi	r2,r2,32
8114562c:	10c00015 	stw	r3,0(r2)
                        data_sector = data_sector + 1;
81145630:	e0bffd17 	ldw	r2,-12(fp)
81145634:	10800044 	addi	r2,r2,1
81145638:	e0bffd15 	stw	r2,-12(fp)
                    }
                }
                // Reading te first byte of the file.
                if (current_sector_index != (data_sector + fat_partition_offset_in_512_byte_sectors))
8114563c:	d0e0b117 	ldw	r3,-32060(gp)
81145640:	e0bffd17 	ldw	r2,-12(fp)
81145644:	1885883a 	add	r2,r3,r2
81145648:	1007883a 	mov	r3,r2
8114564c:	d0a0b517 	ldw	r2,-32044(gp)
81145650:	18800726 	beq	r3,r2,81145670 <alt_up_sd_card_read+0x2f4>
                {
                    if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
81145654:	d0a0b117 	ldw	r2,-32060(gp)
81145658:	100b883a 	mov	r5,r2
8114565c:	e13ffd17 	ldw	r4,-12(fp)
81145660:	1141c280 	call	81141c28 <Read_Sector_Data>
81145664:	1000021e 	bne	r2,zero,81145670 <alt_up_sd_card_read+0x2f4>
                    {
						return -2;
81145668:	00bfff84 	movi	r2,-2
8114566c:	00001e06 	br	811456e8 <alt_up_sd_card_read+0x36c>
                    }
                }

                ch = (unsigned char) IORD_8DIRECT(buffer_memory, (active_files[file_handle].current_byte_position % 512));
81145670:	d0e0b017 	ldw	r3,-32064(gp)
81145674:	e13fff0f 	ldh	r4,-4(fp)
81145678:	00a045f4 	movhi	r2,33047
8114567c:	10b22304 	addi	r2,r2,-14196
81145680:	200891ba 	slli	r4,r4,6
81145684:	1105883a 	add	r2,r2,r4
81145688:	10800904 	addi	r2,r2,36
8114568c:	10800017 	ldw	r2,0(r2)
81145690:	10807fcc 	andi	r2,r2,511
81145694:	1885883a 	add	r2,r3,r2
81145698:	10800023 	ldbuio	r2,0(r2)
8114569c:	10803fcc 	andi	r2,r2,255
811456a0:	10803fcc 	andi	r2,r2,255
811456a4:	e0bffc0d 	sth	r2,-16(fp)
                active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
811456a8:	e13fff0f 	ldh	r4,-4(fp)
811456ac:	e0ffff0f 	ldh	r3,-4(fp)
811456b0:	00a045f4 	movhi	r2,33047
811456b4:	10b22304 	addi	r2,r2,-14196
811456b8:	180691ba 	slli	r3,r3,6
811456bc:	10c5883a 	add	r2,r2,r3
811456c0:	10800904 	addi	r2,r2,36
811456c4:	10800017 	ldw	r2,0(r2)
811456c8:	10c00044 	addi	r3,r2,1
811456cc:	00a045f4 	movhi	r2,33047
811456d0:	10b22304 	addi	r2,r2,-14196
811456d4:	200891ba 	slli	r4,r4,6
811456d8:	1105883a 	add	r2,r2,r4
811456dc:	10800904 	addi	r2,r2,36
811456e0:	10c00015 	stw	r3,0(r2)
            }
        }
    }
    
    return ch;
811456e4:	e0bffc0b 	ldhu	r2,-16(fp)
}
811456e8:	e037883a 	mov	sp,fp
811456ec:	dfc00117 	ldw	ra,4(sp)
811456f0:	df000017 	ldw	fp,0(sp)
811456f4:	dec00204 	addi	sp,sp,8
811456f8:	f800283a 	ret

811456fc <alt_up_sd_card_write>:


bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
811456fc:	defff804 	addi	sp,sp,-32
81145700:	de00012e 	bgeu	sp,et,81145708 <alt_up_sd_card_write+0xc>
81145704:	003b68fa 	trap	3
81145708:	dfc00715 	stw	ra,28(sp)
8114570c:	df000615 	stw	fp,24(sp)
81145710:	df000604 	addi	fp,sp,24
81145714:	2007883a 	mov	r3,r4
81145718:	2805883a 	mov	r2,r5
8114571c:	e0fffe0d 	sth	r3,-8(fp)
81145720:	e0bfff05 	stb	r2,-4(fp)
    bool result = false;
81145724:	e03ffa15 	stw	zero,-24(fp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
81145728:	e0bffe0f 	ldh	r2,-8(fp)
8114572c:	10017716 	blt	r2,zero,81145d0c <alt_up_sd_card_write+0x610>
81145730:	e0bffe0f 	ldh	r2,-8(fp)
81145734:	10800508 	cmpgei	r2,r2,20
81145738:	1001741e 	bne	r2,zero,81145d0c <alt_up_sd_card_write+0x610>
    {
        if (active_files[file_handle].in_use)
8114573c:	e0fffe0f 	ldh	r3,-8(fp)
81145740:	00a045f4 	movhi	r2,33047
81145744:	10b22304 	addi	r2,r2,-14196
81145748:	180691ba 	slli	r3,r3,6
8114574c:	10c5883a 	add	r2,r2,r3
81145750:	10800f04 	addi	r2,r2,60
81145754:	10800017 	ldw	r2,0(r2)
81145758:	10016c26 	beq	r2,zero,81145d0c <alt_up_sd_card_write+0x610>
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8114575c:	00a045f4 	movhi	r2,33047
81145760:	10b20e04 	addi	r2,r2,-14280
81145764:	10c01417 	ldw	r3,80(r2)
81145768:	e13ffe0f 	ldh	r4,-8(fp)
8114576c:	00a045f4 	movhi	r2,33047
81145770:	10b22304 	addi	r2,r2,-14196
81145774:	200891ba 	slli	r4,r4,6
81145778:	1105883a 	add	r2,r2,r4
8114577c:	10800704 	addi	r2,r2,28
81145780:	10800017 	ldw	r2,0(r2)
81145784:	113fff84 	addi	r4,r2,-2
81145788:	00a045f4 	movhi	r2,33047
8114578c:	10b20e04 	addi	r2,r2,-14280
81145790:	10800383 	ldbu	r2,14(r2)
81145794:	10803fcc 	andi	r2,r2,255
81145798:	2085383a 	mul	r2,r4,r2
8114579c:	1887883a 	add	r3,r3,r2
                              active_files[file_handle].current_sector_in_cluster;
811457a0:	e13ffe0f 	ldh	r4,-8(fp)
811457a4:	00a045f4 	movhi	r2,33047
811457a8:	10b22304 	addi	r2,r2,-14196
811457ac:	200891ba 	slli	r4,r4,6
811457b0:	1105883a 	add	r2,r2,r4
811457b4:	10800804 	addi	r2,r2,32
811457b8:	10800017 	ldw	r2,0(r2)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
811457bc:	1885883a 	add	r2,r3,r2
811457c0:	e0bffb15 	stw	r2,-20(fp)
                              active_files[file_handle].current_sector_in_cluster;
			short int buffer_offset = active_files[file_handle].current_byte_position % boot_sector_data.sector_size_in_bytes;
811457c4:	e0fffe0f 	ldh	r3,-8(fp)
811457c8:	00a045f4 	movhi	r2,33047
811457cc:	10b22304 	addi	r2,r2,-14196
811457d0:	180691ba 	slli	r3,r3,6
811457d4:	10c5883a 	add	r2,r2,r3
811457d8:	10800904 	addi	r2,r2,36
811457dc:	10c00017 	ldw	r3,0(r2)
811457e0:	00a045f4 	movhi	r2,33047
811457e4:	10b20e04 	addi	r2,r2,-14280
811457e8:	1080030b 	ldhu	r2,12(r2)
811457ec:	10bfffcc 	andi	r2,r2,65535
811457f0:	1889203a 	divu	r4,r3,r2
811457f4:	2085383a 	mul	r2,r4,r2
811457f8:	1885c83a 	sub	r2,r3,r2
811457fc:	e0bffc0d 	sth	r2,-16(fp)

			if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
81145800:	e0fffe0f 	ldh	r3,-8(fp)
81145804:	00a045f4 	movhi	r2,33047
81145808:	10b22304 	addi	r2,r2,-14196
8114580c:	180691ba 	slli	r3,r3,6
81145810:	10c5883a 	add	r2,r2,r3
81145814:	10800904 	addi	r2,r2,36
81145818:	10c00017 	ldw	r3,0(r2)
8114581c:	e13ffe0f 	ldh	r4,-8(fp)
81145820:	00a045f4 	movhi	r2,33047
81145824:	10b22304 	addi	r2,r2,-14196
81145828:	200891ba 	slli	r4,r4,6
8114582c:	1105883a 	add	r2,r2,r4
81145830:	10800604 	addi	r2,r2,24
81145834:	10800017 	ldw	r2,0(r2)
81145838:	1880672e 	bgeu	r3,r2,811459d8 <alt_up_sd_card_write+0x2dc>
            {
                if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
8114583c:	e0fffe0f 	ldh	r3,-8(fp)
81145840:	00a045f4 	movhi	r2,33047
81145844:	10b22304 	addi	r2,r2,-14196
81145848:	180691ba 	slli	r3,r3,6
8114584c:	10c5883a 	add	r2,r2,r3
81145850:	10800904 	addi	r2,r2,36
81145854:	10800017 	ldw	r2,0(r2)
81145858:	1000e126 	beq	r2,zero,81145be0 <alt_up_sd_card_write+0x4e4>
8114585c:	e0bffc0f 	ldh	r2,-16(fp)
81145860:	1000df1e 	bne	r2,zero,81145be0 <alt_up_sd_card_write+0x4e4>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
81145864:	e0fffe0f 	ldh	r3,-8(fp)
81145868:	00a045f4 	movhi	r2,33047
8114586c:	10b22304 	addi	r2,r2,-14196
81145870:	180691ba 	slli	r3,r3,6
81145874:	10c5883a 	add	r2,r2,r3
81145878:	10800804 	addi	r2,r2,32
8114587c:	10c00017 	ldw	r3,0(r2)
81145880:	00a045f4 	movhi	r2,33047
81145884:	10b20e04 	addi	r2,r2,-14280
81145888:	10800383 	ldbu	r2,14(r2)
8114588c:	10803fcc 	andi	r2,r2,255
81145890:	10bfffc4 	addi	r2,r2,-1
81145894:	18803d1e 	bne	r3,r2,8114598c <alt_up_sd_card_write+0x290>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
81145898:	e0fffe0f 	ldh	r3,-8(fp)
8114589c:	00a045f4 	movhi	r2,33047
811458a0:	10b22304 	addi	r2,r2,-14196
811458a4:	180691ba 	slli	r3,r3,6
811458a8:	10c5883a 	add	r2,r2,r3
811458ac:	10800704 	addi	r2,r2,28
811458b0:	10800017 	ldw	r2,0(r2)
811458b4:	e0fffc84 	addi	r3,fp,-14
811458b8:	180b883a 	mov	r5,r3
811458bc:	1009883a 	mov	r4,r2
811458c0:	1141d080 	call	81141d08 <get_cluster_flag>
811458c4:	10002f26 	beq	r2,zero,81145984 <alt_up_sd_card_write+0x288>
                        {
                            if (next_cluster < 0x0000fff8)
811458c8:	e0bffc8b 	ldhu	r2,-14(fp)
811458cc:	10bfffcc 	andi	r2,r2,65535
811458d0:	10bffe28 	cmpgeui	r2,r2,65528
811458d4:	1000c21e 	bne	r2,zero,81145be0 <alt_up_sd_card_write+0x4e4>
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
811458d8:	e13ffe0f 	ldh	r4,-8(fp)
811458dc:	e0bffc8b 	ldhu	r2,-14(fp)
811458e0:	10ffffcc 	andi	r3,r2,65535
811458e4:	00a045f4 	movhi	r2,33047
811458e8:	10b22304 	addi	r2,r2,-14196
811458ec:	200891ba 	slli	r4,r4,6
811458f0:	1105883a 	add	r2,r2,r4
811458f4:	10800704 	addi	r2,r2,28
811458f8:	10c00015 	stw	r3,0(r2)
								active_files[file_handle].current_sector_in_cluster = 0;
811458fc:	e0fffe0f 	ldh	r3,-8(fp)
81145900:	00a045f4 	movhi	r2,33047
81145904:	10b22304 	addi	r2,r2,-14196
81145908:	180691ba 	slli	r3,r3,6
8114590c:	10c5883a 	add	r2,r2,r3
81145910:	10800804 	addi	r2,r2,32
81145914:	10000015 	stw	zero,0(r2)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81145918:	00a045f4 	movhi	r2,33047
8114591c:	10b20e04 	addi	r2,r2,-14280
81145920:	10c01417 	ldw	r3,80(r2)
81145924:	e13ffe0f 	ldh	r4,-8(fp)
81145928:	00a045f4 	movhi	r2,33047
8114592c:	10b22304 	addi	r2,r2,-14196
81145930:	200891ba 	slli	r4,r4,6
81145934:	1105883a 	add	r2,r2,r4
81145938:	10800704 	addi	r2,r2,28
8114593c:	10800017 	ldw	r2,0(r2)
81145940:	113fff84 	addi	r4,r2,-2
81145944:	00a045f4 	movhi	r2,33047
81145948:	10b20e04 	addi	r2,r2,-14280
8114594c:	10800383 	ldbu	r2,14(r2)
81145950:	10803fcc 	andi	r2,r2,255
81145954:	2085383a 	mul	r2,r4,r2
81145958:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;                                
8114595c:	e13ffe0f 	ldh	r4,-8(fp)
81145960:	00a045f4 	movhi	r2,33047
81145964:	10b22304 	addi	r2,r2,-14196
81145968:	200891ba 	slli	r4,r4,6
8114596c:	1105883a 	add	r2,r2,r4
81145970:	10800804 	addi	r2,r2,32
81145974:	10800017 	ldw	r2,0(r2)
                        {
                            if (next_cluster < 0x0000fff8)
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81145978:	1885883a 	add	r2,r3,r2
8114597c:	e0bffb15 	stw	r2,-20(fp)
81145980:	00009706 	br	81145be0 <alt_up_sd_card_write+0x4e4>
                                  active_files[file_handle].current_sector_in_cluster;                                
                            }
                        }
                        else
                        {
                            return false;
81145984:	0005883a 	mov	r2,zero
81145988:	0000e106 	br	81145d10 <alt_up_sd_card_write+0x614>
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
8114598c:	e13ffe0f 	ldh	r4,-8(fp)
81145990:	e0fffe0f 	ldh	r3,-8(fp)
81145994:	00a045f4 	movhi	r2,33047
81145998:	10b22304 	addi	r2,r2,-14196
8114599c:	180691ba 	slli	r3,r3,6
811459a0:	10c5883a 	add	r2,r2,r3
811459a4:	10800804 	addi	r2,r2,32
811459a8:	10800017 	ldw	r2,0(r2)
811459ac:	10c00044 	addi	r3,r2,1
811459b0:	00a045f4 	movhi	r2,33047
811459b4:	10b22304 	addi	r2,r2,-14196
811459b8:	200891ba 	slli	r4,r4,6
811459bc:	1105883a 	add	r2,r2,r4
811459c0:	10800804 	addi	r2,r2,32
811459c4:	10c00015 	stw	r3,0(r2)
                        data_sector = data_sector + 1;
811459c8:	e0bffb17 	ldw	r2,-20(fp)
811459cc:	10800044 	addi	r2,r2,1
811459d0:	e0bffb15 	stw	r2,-20(fp)
811459d4:	00008206 	br	81145be0 <alt_up_sd_card_write+0x4e4>
                }
            }
			else
			{
				/* You are adding data to the end of the file, so increment its size and look for an additional data cluster if needed. */
				if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
811459d8:	e0fffe0f 	ldh	r3,-8(fp)
811459dc:	00a045f4 	movhi	r2,33047
811459e0:	10b22304 	addi	r2,r2,-14196
811459e4:	180691ba 	slli	r3,r3,6
811459e8:	10c5883a 	add	r2,r2,r3
811459ec:	10800904 	addi	r2,r2,36
811459f0:	10800017 	ldw	r2,0(r2)
811459f4:	10007a26 	beq	r2,zero,81145be0 <alt_up_sd_card_write+0x4e4>
811459f8:	e0bffc0f 	ldh	r2,-16(fp)
811459fc:	1000781e 	bne	r2,zero,81145be0 <alt_up_sd_card_write+0x4e4>
				{
					if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
81145a00:	e0fffe0f 	ldh	r3,-8(fp)
81145a04:	00a045f4 	movhi	r2,33047
81145a08:	10b22304 	addi	r2,r2,-14196
81145a0c:	180691ba 	slli	r3,r3,6
81145a10:	10c5883a 	add	r2,r2,r3
81145a14:	10800804 	addi	r2,r2,32
81145a18:	10c00017 	ldw	r3,0(r2)
81145a1c:	00a045f4 	movhi	r2,33047
81145a20:	10b20e04 	addi	r2,r2,-14280
81145a24:	10800383 	ldbu	r2,14(r2)
81145a28:	10803fcc 	andi	r2,r2,255
81145a2c:	10bfffc4 	addi	r2,r2,-1
81145a30:	18803e1e 	bne	r3,r2,81145b2c <alt_up_sd_card_write+0x430>
					{
						/* Find a new cluster if possible. */
						unsigned int cluster_number;

						if (find_first_empty_cluster(&cluster_number))
81145a34:	e0bffd04 	addi	r2,fp,-12
81145a38:	1009883a 	mov	r4,r2
81145a3c:	1143d4c0 	call	81143d4c <find_first_empty_cluster>
81145a40:	10003826 	beq	r2,zero,81145b24 <alt_up_sd_card_write+0x428>
						{
							// mark clusters in both File Allocation Tables.
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), true);
81145a44:	e0fffe0f 	ldh	r3,-8(fp)
81145a48:	00a045f4 	movhi	r2,33047
81145a4c:	10b22304 	addi	r2,r2,-14196
81145a50:	180691ba 	slli	r3,r3,6
81145a54:	10c5883a 	add	r2,r2,r3
81145a58:	10800704 	addi	r2,r2,28
81145a5c:	10800017 	ldw	r2,0(r2)
81145a60:	e0fffd17 	ldw	r3,-12(fp)
81145a64:	18ffffcc 	andi	r3,r3,65535
81145a68:	18e0001c 	xori	r3,r3,32768
81145a6c:	18e00004 	addi	r3,r3,-32768
81145a70:	01800044 	movi	r6,1
81145a74:	180b883a 	mov	r5,r3
81145a78:	1009883a 	mov	r4,r2
81145a7c:	1141dc40 	call	81141dc4 <mark_cluster>
							mark_cluster(cluster_number, 0xffff, true);
81145a80:	e0bffd17 	ldw	r2,-12(fp)
81145a84:	01800044 	movi	r6,1
81145a88:	017fffc4 	movi	r5,-1
81145a8c:	1009883a 	mov	r4,r2
81145a90:	1141dc40 	call	81141dc4 <mark_cluster>
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), false);
81145a94:	e0fffe0f 	ldh	r3,-8(fp)
81145a98:	00a045f4 	movhi	r2,33047
81145a9c:	10b22304 	addi	r2,r2,-14196
81145aa0:	180691ba 	slli	r3,r3,6
81145aa4:	10c5883a 	add	r2,r2,r3
81145aa8:	10800704 	addi	r2,r2,28
81145aac:	10800017 	ldw	r2,0(r2)
81145ab0:	e0fffd17 	ldw	r3,-12(fp)
81145ab4:	18ffffcc 	andi	r3,r3,65535
81145ab8:	18e0001c 	xori	r3,r3,32768
81145abc:	18e00004 	addi	r3,r3,-32768
81145ac0:	000d883a 	mov	r6,zero
81145ac4:	180b883a 	mov	r5,r3
81145ac8:	1009883a 	mov	r4,r2
81145acc:	1141dc40 	call	81141dc4 <mark_cluster>
							mark_cluster(cluster_number, 0xffff, false);
81145ad0:	e0bffd17 	ldw	r2,-12(fp)
81145ad4:	000d883a 	mov	r6,zero
81145ad8:	017fffc4 	movi	r5,-1
81145adc:	1009883a 	mov	r4,r2
81145ae0:	1141dc40 	call	81141dc4 <mark_cluster>
							// Change cluster index and sector index to compute a new data sector.
							active_files[file_handle].current_cluster_index = cluster_number;
81145ae4:	e13ffe0f 	ldh	r4,-8(fp)
81145ae8:	e0fffd17 	ldw	r3,-12(fp)
81145aec:	00a045f4 	movhi	r2,33047
81145af0:	10b22304 	addi	r2,r2,-14196
81145af4:	200891ba 	slli	r4,r4,6
81145af8:	1105883a 	add	r2,r2,r4
81145afc:	10800704 	addi	r2,r2,28
81145b00:	10c00015 	stw	r3,0(r2)
							active_files[file_handle].current_sector_in_cluster = 0;
81145b04:	e0fffe0f 	ldh	r3,-8(fp)
81145b08:	00a045f4 	movhi	r2,33047
81145b0c:	10b22304 	addi	r2,r2,-14196
81145b10:	180691ba 	slli	r3,r3,6
81145b14:	10c5883a 	add	r2,r2,r3
81145b18:	10800804 	addi	r2,r2,32
81145b1c:	10000015 	stw	zero,0(r2)
81145b20:	00001506 	br	81145b78 <alt_up_sd_card_write+0x47c>
						}
						else
						{
							return false;
81145b24:	0005883a 	mov	r2,zero
81145b28:	00007906 	br	81145d10 <alt_up_sd_card_write+0x614>
						}
					}
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
81145b2c:	e13ffe0f 	ldh	r4,-8(fp)
81145b30:	e0fffe0f 	ldh	r3,-8(fp)
81145b34:	00a045f4 	movhi	r2,33047
81145b38:	10b22304 	addi	r2,r2,-14196
81145b3c:	180691ba 	slli	r3,r3,6
81145b40:	10c5883a 	add	r2,r2,r3
81145b44:	10800904 	addi	r2,r2,36
81145b48:	10c00017 	ldw	r3,0(r2)
81145b4c:	00a045f4 	movhi	r2,33047
81145b50:	10b20e04 	addi	r2,r2,-14280
81145b54:	1080030b 	ldhu	r2,12(r2)
81145b58:	10bfffcc 	andi	r2,r2,65535
81145b5c:	1887203a 	divu	r3,r3,r2
81145b60:	00a045f4 	movhi	r2,33047
81145b64:	10b22304 	addi	r2,r2,-14196
81145b68:	200891ba 	slli	r4,r4,6
81145b6c:	1105883a 	add	r2,r2,r4
81145b70:	10800804 	addi	r2,r2,32
81145b74:	10c00015 	stw	r3,0(r2)
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81145b78:	00a045f4 	movhi	r2,33047
81145b7c:	10b20e04 	addi	r2,r2,-14280
81145b80:	10c01417 	ldw	r3,80(r2)
81145b84:	e13ffe0f 	ldh	r4,-8(fp)
81145b88:	00a045f4 	movhi	r2,33047
81145b8c:	10b22304 	addi	r2,r2,-14196
81145b90:	200891ba 	slli	r4,r4,6
81145b94:	1105883a 	add	r2,r2,r4
81145b98:	10800704 	addi	r2,r2,28
81145b9c:	10800017 	ldw	r2,0(r2)
81145ba0:	113fff84 	addi	r4,r2,-2
81145ba4:	00a045f4 	movhi	r2,33047
81145ba8:	10b20e04 	addi	r2,r2,-14280
81145bac:	10800383 	ldbu	r2,14(r2)
81145bb0:	10803fcc 	andi	r2,r2,255
81145bb4:	2085383a 	mul	r2,r4,r2
81145bb8:	1887883a 	add	r3,r3,r2
                          active_files[file_handle].current_sector_in_cluster;
81145bbc:	e13ffe0f 	ldh	r4,-8(fp)
81145bc0:	00a045f4 	movhi	r2,33047
81145bc4:	10b22304 	addi	r2,r2,-14196
81145bc8:	200891ba 	slli	r4,r4,6
81145bcc:	1105883a 	add	r2,r2,r4
81145bd0:	10800804 	addi	r2,r2,32
81145bd4:	10800017 	ldw	r2,0(r2)
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81145bd8:	1885883a 	add	r2,r3,r2
81145bdc:	e0bffb15 	stw	r2,-20(fp)
                          active_files[file_handle].current_sector_in_cluster;
				}
			}
            // Reading a data sector into the buffer. Note that changes to the most recently modified sector will be saved before
			// a new sector is read from the SD Card.
            if (current_sector_index != data_sector + fat_partition_offset_in_512_byte_sectors)
81145be0:	d0e0b117 	ldw	r3,-32060(gp)
81145be4:	e0bffb17 	ldw	r2,-20(fp)
81145be8:	1885883a 	add	r2,r3,r2
81145bec:	1007883a 	mov	r3,r2
81145bf0:	d0a0b517 	ldw	r2,-32044(gp)
81145bf4:	18800726 	beq	r3,r2,81145c14 <alt_up_sd_card_write+0x518>
            {
                if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
81145bf8:	d0a0b117 	ldw	r2,-32060(gp)
81145bfc:	100b883a 	mov	r5,r2
81145c00:	e13ffb17 	ldw	r4,-20(fp)
81145c04:	1141c280 	call	81141c28 <Read_Sector_Data>
81145c08:	1000021e 	bne	r2,zero,81145c14 <alt_up_sd_card_write+0x518>
                {
					return false;
81145c0c:	0005883a 	mov	r2,zero
81145c10:	00003f06 	br	81145d10 <alt_up_sd_card_write+0x614>
                }
            }
            // Write a byte of data to the buffer.
			IOWR_8DIRECT(buffer_memory, buffer_offset, byte_of_data);
81145c14:	d0e0b017 	ldw	r3,-32064(gp)
81145c18:	e0bffc0f 	ldh	r2,-16(fp)
81145c1c:	1885883a 	add	r2,r3,r2
81145c20:	e0ffff07 	ldb	r3,-4(fp)
81145c24:	10c00025 	stbio	r3,0(r2)
			active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
81145c28:	e13ffe0f 	ldh	r4,-8(fp)
81145c2c:	e0fffe0f 	ldh	r3,-8(fp)
81145c30:	00a045f4 	movhi	r2,33047
81145c34:	10b22304 	addi	r2,r2,-14196
81145c38:	180691ba 	slli	r3,r3,6
81145c3c:	10c5883a 	add	r2,r2,r3
81145c40:	10800904 	addi	r2,r2,36
81145c44:	10800017 	ldw	r2,0(r2)
81145c48:	10c00044 	addi	r3,r2,1
81145c4c:	00a045f4 	movhi	r2,33047
81145c50:	10b22304 	addi	r2,r2,-14196
81145c54:	200891ba 	slli	r4,r4,6
81145c58:	1105883a 	add	r2,r2,r4
81145c5c:	10800904 	addi	r2,r2,36
81145c60:	10c00015 	stw	r3,0(r2)

			// Modify the file record only when necessary.
			if (active_files[file_handle].current_byte_position >= active_files[file_handle].file_size_in_bytes)
81145c64:	e0fffe0f 	ldh	r3,-8(fp)
81145c68:	00a045f4 	movhi	r2,33047
81145c6c:	10b22304 	addi	r2,r2,-14196
81145c70:	180691ba 	slli	r3,r3,6
81145c74:	10c5883a 	add	r2,r2,r3
81145c78:	10800904 	addi	r2,r2,36
81145c7c:	10c00017 	ldw	r3,0(r2)
81145c80:	e13ffe0f 	ldh	r4,-8(fp)
81145c84:	00a045f4 	movhi	r2,33047
81145c88:	10b22304 	addi	r2,r2,-14196
81145c8c:	200891ba 	slli	r4,r4,6
81145c90:	1105883a 	add	r2,r2,r4
81145c94:	10800604 	addi	r2,r2,24
81145c98:	10800017 	ldw	r2,0(r2)
81145c9c:	18801736 	bltu	r3,r2,81145cfc <alt_up_sd_card_write+0x600>
			{
				active_files[file_handle].file_size_in_bytes = active_files[file_handle].file_size_in_bytes + 1;
81145ca0:	e13ffe0f 	ldh	r4,-8(fp)
81145ca4:	e0fffe0f 	ldh	r3,-8(fp)
81145ca8:	00a045f4 	movhi	r2,33047
81145cac:	10b22304 	addi	r2,r2,-14196
81145cb0:	180691ba 	slli	r3,r3,6
81145cb4:	10c5883a 	add	r2,r2,r3
81145cb8:	10800604 	addi	r2,r2,24
81145cbc:	10800017 	ldw	r2,0(r2)
81145cc0:	10c00044 	addi	r3,r2,1
81145cc4:	00a045f4 	movhi	r2,33047
81145cc8:	10b22304 	addi	r2,r2,-14196
81145ccc:	200891ba 	slli	r4,r4,6
81145cd0:	1105883a 	add	r2,r2,r4
81145cd4:	10800604 	addi	r2,r2,24
81145cd8:	10c00015 	stw	r3,0(r2)
				active_files[file_handle].modified = true;
81145cdc:	e0fffe0f 	ldh	r3,-8(fp)
81145ce0:	00a045f4 	movhi	r2,33047
81145ce4:	10b22304 	addi	r2,r2,-14196
81145ce8:	180691ba 	slli	r3,r3,6
81145cec:	10c5883a 	add	r2,r2,r3
81145cf0:	10800e04 	addi	r2,r2,56
81145cf4:	00c00044 	movi	r3,1
81145cf8:	10c00015 	stw	r3,0(r2)
			}
            // Invaldiate the buffer to ensure that the buffer contents are written to the SD card whe nthe file is closed.
            current_sector_modified = true;
81145cfc:	00800044 	movi	r2,1
81145d00:	d0a0b415 	stw	r2,-32048(gp)
			result = true;
81145d04:	00800044 	movi	r2,1
81145d08:	e0bffa15 	stw	r2,-24(fp)
		}
    }
    
    return result;
81145d0c:	e0bffa17 	ldw	r2,-24(fp)
}
81145d10:	e037883a 	mov	sp,fp
81145d14:	dfc00117 	ldw	ra,4(sp)
81145d18:	df000017 	ldw	fp,0(sp)
81145d1c:	dec00204 	addi	sp,sp,8
81145d20:	f800283a 	ret

81145d24 <alt_up_sd_card_fclose>:


bool alt_up_sd_card_fclose(short int file_handle)
// This function closes an opened file and saves data to SD Card if necessary.
{
81145d24:	defffb04 	addi	sp,sp,-20
81145d28:	de00012e 	bgeu	sp,et,81145d30 <alt_up_sd_card_fclose+0xc>
81145d2c:	003b68fa 	trap	3
81145d30:	dfc00415 	stw	ra,16(sp)
81145d34:	df000315 	stw	fp,12(sp)
81145d38:	df000304 	addi	fp,sp,12
81145d3c:	2005883a 	mov	r2,r4
81145d40:	e0bfff0d 	sth	r2,-4(fp)
    bool result = false;
81145d44:	e03ffd15 	stw	zero,-12(fp)
    if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81145d48:	11449000 	call	81144900 <alt_up_sd_card_is_Present>
81145d4c:	10006026 	beq	r2,zero,81145ed0 <alt_up_sd_card_fclose+0x1ac>
81145d50:	d0a0aa17 	ldw	r2,-32088(gp)
81145d54:	10005e26 	beq	r2,zero,81145ed0 <alt_up_sd_card_fclose+0x1ac>
    {
        if (active_files[file_handle].in_use) 
81145d58:	e0ffff0f 	ldh	r3,-4(fp)
81145d5c:	00a045f4 	movhi	r2,33047
81145d60:	10b22304 	addi	r2,r2,-14196
81145d64:	180691ba 	slli	r3,r3,6
81145d68:	10c5883a 	add	r2,r2,r3
81145d6c:	10800f04 	addi	r2,r2,60
81145d70:	10800017 	ldw	r2,0(r2)
81145d74:	10005626 	beq	r2,zero,81145ed0 <alt_up_sd_card_fclose+0x1ac>
        {
			if (active_files[file_handle].modified)
81145d78:	e0ffff0f 	ldh	r3,-4(fp)
81145d7c:	00a045f4 	movhi	r2,33047
81145d80:	10b22304 	addi	r2,r2,-14196
81145d84:	180691ba 	slli	r3,r3,6
81145d88:	10c5883a 	add	r2,r2,r3
81145d8c:	10800e04 	addi	r2,r2,56
81145d90:	10800017 	ldw	r2,0(r2)
81145d94:	10004526 	beq	r2,zero,81145eac <alt_up_sd_card_fclose+0x188>
			{
				unsigned int record_sector = active_files[file_handle].file_record_sector_in_cluster;
81145d98:	e0ffff0f 	ldh	r3,-4(fp)
81145d9c:	00a045f4 	movhi	r2,33047
81145da0:	10b22304 	addi	r2,r2,-14196
81145da4:	180691ba 	slli	r3,r3,6
81145da8:	10c5883a 	add	r2,r2,r3
81145dac:	10800b04 	addi	r2,r2,44
81145db0:	10800017 	ldw	r2,0(r2)
81145db4:	e0bffe15 	stw	r2,-8(fp)
				if (active_files[file_handle].file_record_cluster == 0)
81145db8:	e0ffff0f 	ldh	r3,-4(fp)
81145dbc:	00a045f4 	movhi	r2,33047
81145dc0:	10b22304 	addi	r2,r2,-14196
81145dc4:	180691ba 	slli	r3,r3,6
81145dc8:	10c5883a 	add	r2,r2,r3
81145dcc:	10800a04 	addi	r2,r2,40
81145dd0:	10800017 	ldw	r2,0(r2)
81145dd4:	1000071e 	bne	r2,zero,81145df4 <alt_up_sd_card_fclose+0xd0>
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
81145dd8:	00a045f4 	movhi	r2,33047
81145ddc:	10b20e04 	addi	r2,r2,-14280
81145de0:	10801317 	ldw	r2,76(r2)
81145de4:	e0fffe17 	ldw	r3,-8(fp)
81145de8:	1885883a 	add	r2,r3,r2
81145dec:	e0bffe15 	stw	r2,-8(fp)
81145df0:	00001406 	br	81145e44 <alt_up_sd_card_fclose+0x120>
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
81145df4:	00a045f4 	movhi	r2,33047
81145df8:	10b20e04 	addi	r2,r2,-14280
81145dfc:	10c01417 	ldw	r3,80(r2)
81145e00:	e0bffe17 	ldw	r2,-8(fp)
81145e04:	1887883a 	add	r3,r3,r2
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
81145e08:	e13fff0f 	ldh	r4,-4(fp)
81145e0c:	00a045f4 	movhi	r2,33047
81145e10:	10b22304 	addi	r2,r2,-14196
81145e14:	200891ba 	slli	r4,r4,6
81145e18:	1105883a 	add	r2,r2,r4
81145e1c:	10800a04 	addi	r2,r2,40
81145e20:	10800017 	ldw	r2,0(r2)
81145e24:	113fff84 	addi	r4,r2,-2
81145e28:	00a045f4 	movhi	r2,33047
81145e2c:	10b20e04 	addi	r2,r2,-14280
81145e30:	10800383 	ldbu	r2,14(r2)
81145e34:	10803fcc 	andi	r2,r2,255
81145e38:	2085383a 	mul	r2,r4,r2
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
81145e3c:	1885883a 	add	r2,r3,r2
81145e40:	e0bffe15 	stw	r2,-8(fp)
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
				}
				if (Read_Sector_Data(record_sector, fat_partition_offset_in_512_byte_sectors))
81145e44:	e0bffe17 	ldw	r2,-8(fp)
81145e48:	d0e0b117 	ldw	r3,-32060(gp)
81145e4c:	180b883a 	mov	r5,r3
81145e50:	1009883a 	mov	r4,r2
81145e54:	1141c280 	call	81141c28 <Read_Sector_Data>
81145e58:	10001426 	beq	r2,zero,81145eac <alt_up_sd_card_fclose+0x188>
				{
					if (Write_File_Record_At_Offset(active_files[file_handle].file_record_offset, &(active_files[file_handle])))
81145e5c:	e0ffff0f 	ldh	r3,-4(fp)
81145e60:	00a045f4 	movhi	r2,33047
81145e64:	10b22304 	addi	r2,r2,-14196
81145e68:	180691ba 	slli	r3,r3,6
81145e6c:	10c5883a 	add	r2,r2,r3
81145e70:	10800c04 	addi	r2,r2,48
81145e74:	1080000b 	ldhu	r2,0(r2)
81145e78:	113fffcc 	andi	r4,r2,65535
81145e7c:	2120001c 	xori	r4,r4,32768
81145e80:	21200004 	addi	r4,r4,-32768
81145e84:	e0bfff0f 	ldh	r2,-4(fp)
81145e88:	100691ba 	slli	r3,r2,6
81145e8c:	00a045f4 	movhi	r2,33047
81145e90:	10b22304 	addi	r2,r2,-14196
81145e94:	1885883a 	add	r2,r3,r2
81145e98:	100b883a 	mov	r5,r2
81145e9c:	11422dc0 	call	811422dc <Write_File_Record_At_Offset>
81145ea0:	10000226 	beq	r2,zero,81145eac <alt_up_sd_card_fclose+0x188>
					{
						// Make sure that the Data has been saved to the SD Card.
						result = Save_Modified_Sector();
81145ea4:	1141bd40 	call	81141bd4 <Save_Modified_Sector>
81145ea8:	e0bffd15 	stw	r2,-12(fp)
					}
				}
			}
			active_files[file_handle].in_use = false;
81145eac:	e0ffff0f 	ldh	r3,-4(fp)
81145eb0:	00a045f4 	movhi	r2,33047
81145eb4:	10b22304 	addi	r2,r2,-14196
81145eb8:	180691ba 	slli	r3,r3,6
81145ebc:	10c5883a 	add	r2,r2,r3
81145ec0:	10800f04 	addi	r2,r2,60
81145ec4:	10000015 	stw	zero,0(r2)
			result = true;
81145ec8:	00800044 	movi	r2,1
81145ecc:	e0bffd15 	stw	r2,-12(fp)
        }
    }
    
    return result;
81145ed0:	e0bffd17 	ldw	r2,-12(fp)
}
81145ed4:	e037883a 	mov	sp,fp
81145ed8:	dfc00117 	ldw	ra,4(sp)
81145edc:	df000017 	ldw	fp,0(sp)
81145ee0:	dec00204 	addi	sp,sp,8
81145ee4:	f800283a 	ret

81145ee8 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
81145ee8:	defffa04 	addi	sp,sp,-24
81145eec:	de00012e 	bgeu	sp,et,81145ef4 <altera_avalon_jtag_uart_read_fd+0xc>
81145ef0:	003b68fa 	trap	3
81145ef4:	dfc00515 	stw	ra,20(sp)
81145ef8:	df000415 	stw	fp,16(sp)
81145efc:	df000404 	addi	fp,sp,16
81145f00:	e13ffd15 	stw	r4,-12(fp)
81145f04:	e17ffe15 	stw	r5,-8(fp)
81145f08:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
81145f0c:	e0bffd17 	ldw	r2,-12(fp)
81145f10:	10800017 	ldw	r2,0(r2)
81145f14:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
81145f18:	e0bffc17 	ldw	r2,-16(fp)
81145f1c:	10c00a04 	addi	r3,r2,40
81145f20:	e0bffd17 	ldw	r2,-12(fp)
81145f24:	10800217 	ldw	r2,8(r2)
81145f28:	100f883a 	mov	r7,r2
81145f2c:	e1bfff17 	ldw	r6,-4(fp)
81145f30:	e17ffe17 	ldw	r5,-8(fp)
81145f34:	1809883a 	mov	r4,r3
81145f38:	114676c0 	call	8114676c <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
81145f3c:	e037883a 	mov	sp,fp
81145f40:	dfc00117 	ldw	ra,4(sp)
81145f44:	df000017 	ldw	fp,0(sp)
81145f48:	dec00204 	addi	sp,sp,8
81145f4c:	f800283a 	ret

81145f50 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
81145f50:	defffa04 	addi	sp,sp,-24
81145f54:	de00012e 	bgeu	sp,et,81145f5c <altera_avalon_jtag_uart_write_fd+0xc>
81145f58:	003b68fa 	trap	3
81145f5c:	dfc00515 	stw	ra,20(sp)
81145f60:	df000415 	stw	fp,16(sp)
81145f64:	df000404 	addi	fp,sp,16
81145f68:	e13ffd15 	stw	r4,-12(fp)
81145f6c:	e17ffe15 	stw	r5,-8(fp)
81145f70:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
81145f74:	e0bffd17 	ldw	r2,-12(fp)
81145f78:	10800017 	ldw	r2,0(r2)
81145f7c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
81145f80:	e0bffc17 	ldw	r2,-16(fp)
81145f84:	10c00a04 	addi	r3,r2,40
81145f88:	e0bffd17 	ldw	r2,-12(fp)
81145f8c:	10800217 	ldw	r2,8(r2)
81145f90:	100f883a 	mov	r7,r2
81145f94:	e1bfff17 	ldw	r6,-4(fp)
81145f98:	e17ffe17 	ldw	r5,-8(fp)
81145f9c:	1809883a 	mov	r4,r3
81145fa0:	1146a300 	call	81146a30 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
81145fa4:	e037883a 	mov	sp,fp
81145fa8:	dfc00117 	ldw	ra,4(sp)
81145fac:	df000017 	ldw	fp,0(sp)
81145fb0:	dec00204 	addi	sp,sp,8
81145fb4:	f800283a 	ret

81145fb8 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
81145fb8:	defffc04 	addi	sp,sp,-16
81145fbc:	de00012e 	bgeu	sp,et,81145fc4 <altera_avalon_jtag_uart_close_fd+0xc>
81145fc0:	003b68fa 	trap	3
81145fc4:	dfc00315 	stw	ra,12(sp)
81145fc8:	df000215 	stw	fp,8(sp)
81145fcc:	df000204 	addi	fp,sp,8
81145fd0:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
81145fd4:	e0bfff17 	ldw	r2,-4(fp)
81145fd8:	10800017 	ldw	r2,0(r2)
81145fdc:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
81145fe0:	e0bffe17 	ldw	r2,-8(fp)
81145fe4:	10c00a04 	addi	r3,r2,40
81145fe8:	e0bfff17 	ldw	r2,-4(fp)
81145fec:	10800217 	ldw	r2,8(r2)
81145ff0:	100b883a 	mov	r5,r2
81145ff4:	1809883a 	mov	r4,r3
81145ff8:	11466040 	call	81146604 <altera_avalon_jtag_uart_close>
}
81145ffc:	e037883a 	mov	sp,fp
81146000:	dfc00117 	ldw	ra,4(sp)
81146004:	df000017 	ldw	fp,0(sp)
81146008:	dec00204 	addi	sp,sp,8
8114600c:	f800283a 	ret

81146010 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
81146010:	defffa04 	addi	sp,sp,-24
81146014:	de00012e 	bgeu	sp,et,8114601c <altera_avalon_jtag_uart_ioctl_fd+0xc>
81146018:	003b68fa 	trap	3
8114601c:	dfc00515 	stw	ra,20(sp)
81146020:	df000415 	stw	fp,16(sp)
81146024:	df000404 	addi	fp,sp,16
81146028:	e13ffd15 	stw	r4,-12(fp)
8114602c:	e17ffe15 	stw	r5,-8(fp)
81146030:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
81146034:	e0bffd17 	ldw	r2,-12(fp)
81146038:	10800017 	ldw	r2,0(r2)
8114603c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
81146040:	e0bffc17 	ldw	r2,-16(fp)
81146044:	10800a04 	addi	r2,r2,40
81146048:	e1bfff17 	ldw	r6,-4(fp)
8114604c:	e17ffe17 	ldw	r5,-8(fp)
81146050:	1009883a 	mov	r4,r2
81146054:	11466740 	call	81146674 <altera_avalon_jtag_uart_ioctl>
}
81146058:	e037883a 	mov	sp,fp
8114605c:	dfc00117 	ldw	ra,4(sp)
81146060:	df000017 	ldw	fp,0(sp)
81146064:	dec00204 	addi	sp,sp,8
81146068:	f800283a 	ret

8114606c <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
8114606c:	deffef04 	addi	sp,sp,-68
81146070:	de00012e 	bgeu	sp,et,81146078 <altera_avalon_jtag_uart_init+0xc>
81146074:	003b68fa 	trap	3
81146078:	dfc01015 	stw	ra,64(sp)
8114607c:	df000f15 	stw	fp,60(sp)
81146080:	dc400e15 	stw	r17,56(sp)
81146084:	dc000d15 	stw	r16,52(sp)
81146088:	df000f04 	addi	fp,sp,60
8114608c:	e13ff715 	stw	r4,-36(fp)
81146090:	e17ff815 	stw	r5,-32(fp)
81146094:	e1bff915 	stw	r6,-28(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
81146098:	e0bff717 	ldw	r2,-36(fp)
8114609c:	10800c04 	addi	r2,r2,48
811460a0:	e0bff215 	stw	r2,-56(fp)
811460a4:	e03ff60d 	sth	zero,-40(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
811460a8:	e0bff60b 	ldhu	r2,-40(fp)
811460ac:	e0fff684 	addi	r3,fp,-38
811460b0:	180b883a 	mov	r5,r3
811460b4:	1009883a 	mov	r4,r2
811460b8:	113a23c0 	call	8113a23c <OSFlagCreate>
811460bc:	1007883a 	mov	r3,r2
811460c0:	e0bff217 	ldw	r2,-56(fp)
811460c4:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->read_lock, 1);
811460c8:	e0bff717 	ldw	r2,-36(fp)
811460cc:	10800a04 	addi	r2,r2,40
811460d0:	e0bff315 	stw	r2,-52(fp)
811460d4:	00800044 	movi	r2,1
811460d8:	e0bff58d 	sth	r2,-42(fp)
811460dc:	e0bff58b 	ldhu	r2,-42(fp)
811460e0:	1009883a 	mov	r4,r2
811460e4:	113e1980 	call	8113e198 <OSSemCreate>
811460e8:	1007883a 	mov	r3,r2
811460ec:	e0bff317 	ldw	r2,-52(fp)
811460f0:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->write_lock, 1);
811460f4:	e0bff717 	ldw	r2,-36(fp)
811460f8:	10800b04 	addi	r2,r2,44
811460fc:	e0bff415 	stw	r2,-48(fp)
81146100:	00800044 	movi	r2,1
81146104:	e0bff50d 	sth	r2,-44(fp)
81146108:	e0bff50b 	ldhu	r2,-44(fp)
8114610c:	1009883a 	mov	r4,r2
81146110:	113e1980 	call	8113e198 <OSSemCreate>
81146114:	1007883a 	mov	r3,r2
81146118:	e0bff417 	ldw	r2,-48(fp)
8114611c:	10c00015 	stw	r3,0(r2)

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
81146120:	e0bff717 	ldw	r2,-36(fp)
81146124:	00c00044 	movi	r3,1
81146128:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
8114612c:	e0bff717 	ldw	r2,-36(fp)
81146130:	10800017 	ldw	r2,0(r2)
81146134:	10800104 	addi	r2,r2,4
81146138:	1007883a 	mov	r3,r2
8114613c:	e0bff717 	ldw	r2,-36(fp)
81146140:	10800817 	ldw	r2,32(r2)
81146144:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
81146148:	e0bff817 	ldw	r2,-32(fp)
8114614c:	e0fff917 	ldw	r3,-28(fp)
81146150:	d8000015 	stw	zero,0(sp)
81146154:	e1fff717 	ldw	r7,-36(fp)
81146158:	01a04534 	movhi	r6,33044
8114615c:	31988f04 	addi	r6,r6,25148
81146160:	180b883a 	mov	r5,r3
81146164:	1009883a 	mov	r4,r2
81146168:	1149f840 	call	81149f84 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
8114616c:	e0bff717 	ldw	r2,-36(fp)
81146170:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
81146174:	e0bff717 	ldw	r2,-36(fp)
81146178:	10800204 	addi	r2,r2,8
8114617c:	d0e08817 	ldw	r3,-32224(gp)
81146180:	e1fff717 	ldw	r7,-36(fp)
81146184:	01a04534 	movhi	r6,33044
81146188:	31993e04 	addi	r6,r6,25848
8114618c:	180b883a 	mov	r5,r3
81146190:	1009883a 	mov	r4,r2
81146194:	1149ad40 	call	81149ad4 <alt_alarm_start>
81146198:	1000040e 	bge	r2,zero,811461ac <altera_avalon_jtag_uart_init+0x140>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
8114619c:	e0fff717 	ldw	r3,-36(fp)
811461a0:	00a00034 	movhi	r2,32768
811461a4:	10bfffc4 	addi	r2,r2,-1
811461a8:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
811461ac:	d0a08183 	ldbu	r2,-32250(gp)
811461b0:	10803fcc 	andi	r2,r2,255
811461b4:	10800058 	cmpnei	r2,r2,1
811461b8:	10000f1e 	bne	r2,zero,811461f8 <altera_avalon_jtag_uart_init+0x18c>
811461bc:	d0e08817 	ldw	r3,-32224(gp)
811461c0:	00b33374 	movhi	r2,52429
811461c4:	10b33344 	addi	r2,r2,-13107
811461c8:	1888383a 	mulxuu	r4,r3,r2
811461cc:	1885383a 	mul	r2,r3,r2
811461d0:	1021883a 	mov	r16,r2
811461d4:	2023883a 	mov	r17,r4
811461d8:	8804d0fa 	srli	r2,r17,3
811461dc:	e1fff717 	ldw	r7,-36(fp)
811461e0:	01a044f4 	movhi	r6,33043
811461e4:	319a5b04 	addi	r6,r6,26988
811461e8:	100b883a 	mov	r5,r2
811461ec:	012045b4 	movhi	r4,33046
811461f0:	2119e204 	addi	r4,r4,26504
811461f4:	1149ad40 	call	81149ad4 <alt_alarm_start>
811461f8:	d0a08203 	ldbu	r2,-32248(gp)
811461fc:	10803fcc 	andi	r2,r2,255
81146200:	10800058 	cmpnei	r2,r2,1
81146204:	1000051e 	bne	r2,zero,8114621c <altera_avalon_jtag_uart_init+0x1b0>
81146208:	e0bff717 	ldw	r2,-36(fp)
8114620c:	10800017 	ldw	r2,0(r2)
81146210:	100b883a 	mov	r5,r2
81146214:	e13ff717 	ldw	r4,-36(fp)
81146218:	1136b040 	call	81136b04 <alt_log_jtag_uart_startup_info>
}
8114621c:	0001883a 	nop
81146220:	e6fffe04 	addi	sp,fp,-8
81146224:	dfc00317 	ldw	ra,12(sp)
81146228:	df000217 	ldw	fp,8(sp)
8114622c:	dc400117 	ldw	r17,4(sp)
81146230:	dc000017 	ldw	r16,0(sp)
81146234:	dec00404 	addi	sp,sp,16
81146238:	f800283a 	ret

8114623c <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
8114623c:	defff204 	addi	sp,sp,-56
81146240:	de00012e 	bgeu	sp,et,81146248 <altera_avalon_jtag_uart_irq+0xc>
81146244:	003b68fa 	trap	3
81146248:	dfc00d15 	stw	ra,52(sp)
8114624c:	df000c15 	stw	fp,48(sp)
81146250:	df000c04 	addi	fp,sp,48
81146254:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
81146258:	e0bfff17 	ldw	r2,-4(fp)
8114625c:	e0bff615 	stw	r2,-40(fp)
  unsigned int base = sp->base;
81146260:	e0bff617 	ldw	r2,-40(fp)
81146264:	10800017 	ldw	r2,0(r2)
81146268:	e0bff715 	stw	r2,-36(fp)

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);
8114626c:	e0bff717 	ldw	r2,-36(fp)
81146270:	e17ff617 	ldw	r5,-40(fp)
81146274:	1009883a 	mov	r4,r2
81146278:	1136b580 	call	81136b58 <alt_log_jtag_uart_isr_proc>

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
8114627c:	e0bff717 	ldw	r2,-36(fp)
81146280:	10800104 	addi	r2,r2,4
81146284:	10800037 	ldwio	r2,0(r2)
81146288:	e0bff815 	stw	r2,-32(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
8114628c:	e0bff817 	ldw	r2,-32(fp)
81146290:	1080c00c 	andi	r2,r2,768
81146294:	10009126 	beq	r2,zero,811464dc <altera_avalon_jtag_uart_irq+0x2a0>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
81146298:	e0bff817 	ldw	r2,-32(fp)
8114629c:	1080400c 	andi	r2,r2,256
811462a0:	10004726 	beq	r2,zero,811463c0 <altera_avalon_jtag_uart_irq+0x184>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
811462a4:	00800074 	movhi	r2,1
811462a8:	e0bff415 	stw	r2,-48(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
811462ac:	e0bff617 	ldw	r2,-40(fp)
811462b0:	10800d17 	ldw	r2,52(r2)
811462b4:	10800044 	addi	r2,r2,1
811462b8:	1081ffcc 	andi	r2,r2,2047
811462bc:	e0bff915 	stw	r2,-28(fp)
        if (next == sp->rx_out)
811462c0:	e0bff617 	ldw	r2,-40(fp)
811462c4:	10c00e17 	ldw	r3,56(r2)
811462c8:	e0bff917 	ldw	r2,-28(fp)
811462cc:	18802726 	beq	r3,r2,8114636c <altera_avalon_jtag_uart_irq+0x130>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
811462d0:	e0bff717 	ldw	r2,-36(fp)
811462d4:	10800037 	ldwio	r2,0(r2)
811462d8:	e0bff415 	stw	r2,-48(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
811462dc:	e0bff417 	ldw	r2,-48(fp)
811462e0:	10a0000c 	andi	r2,r2,32768
811462e4:	10002326 	beq	r2,zero,81146374 <altera_avalon_jtag_uart_irq+0x138>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
811462e8:	e0bff617 	ldw	r2,-40(fp)
811462ec:	10800d17 	ldw	r2,52(r2)
811462f0:	e0fff417 	ldw	r3,-48(fp)
811462f4:	1809883a 	mov	r4,r3
811462f8:	e0fff617 	ldw	r3,-40(fp)
811462fc:	1885883a 	add	r2,r3,r2
81146300:	10801104 	addi	r2,r2,68
81146304:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81146308:	e0bff617 	ldw	r2,-40(fp)
8114630c:	10800d17 	ldw	r2,52(r2)
81146310:	10800044 	addi	r2,r2,1
81146314:	10c1ffcc 	andi	r3,r2,2047
81146318:	e0bff617 	ldw	r2,-40(fp)
8114631c:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
81146320:	e0bff617 	ldw	r2,-40(fp)
81146324:	10800c17 	ldw	r2,48(r2)
81146328:	e0bffb15 	stw	r2,-20(fp)
8114632c:	00800044 	movi	r2,1
81146330:	e0bffc0d 	sth	r2,-16(fp)
81146334:	00800044 	movi	r2,1
81146338:	e0bffc85 	stb	r2,-14(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
8114633c:	d0a09103 	ldbu	r2,-32188(gp)
81146340:	10803fcc 	andi	r2,r2,255
81146344:	103fd926 	beq	r2,zero,811462ac <__reset+0xfb1262ac>
  {
    OSFlagPost (group, flags, opt, &err);
81146348:	e0bffc0b 	ldhu	r2,-16(fp)
8114634c:	e0fffc83 	ldbu	r3,-14(fp)
81146350:	e13ffdc4 	addi	r4,fp,-9
81146354:	200f883a 	mov	r7,r4
81146358:	180d883a 	mov	r6,r3
8114635c:	100b883a 	mov	r5,r2
81146360:	e13ffb17 	ldw	r4,-20(fp)
81146364:	113ae480 	call	8113ae48 <OSFlagPost>
      }
81146368:	003fd006 	br	811462ac <__reset+0xfb1262ac>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
8114636c:	0001883a 	nop
81146370:	00000106 	br	81146378 <altera_avalon_jtag_uart_irq+0x13c>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
81146374:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
81146378:	e0bff417 	ldw	r2,-48(fp)
8114637c:	10bfffec 	andhi	r2,r2,65535
81146380:	10000f26 	beq	r2,zero,811463c0 <altera_avalon_jtag_uart_irq+0x184>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
81146384:	e0bff617 	ldw	r2,-40(fp)
81146388:	10c00817 	ldw	r3,32(r2)
8114638c:	00bfff84 	movi	r2,-2
81146390:	1886703a 	and	r3,r3,r2
81146394:	e0bff617 	ldw	r2,-40(fp)
81146398:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
8114639c:	e0bff717 	ldw	r2,-36(fp)
811463a0:	10800104 	addi	r2,r2,4
811463a4:	1007883a 	mov	r3,r2
811463a8:	e0bff617 	ldw	r2,-40(fp)
811463ac:	10800817 	ldw	r2,32(r2)
811463b0:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
811463b4:	e0bff717 	ldw	r2,-36(fp)
811463b8:	10800104 	addi	r2,r2,4
811463bc:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
811463c0:	e0bff817 	ldw	r2,-32(fp)
811463c4:	1080800c 	andi	r2,r2,512
811463c8:	103fac26 	beq	r2,zero,8114627c <__reset+0xfb12627c>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
811463cc:	e0bff817 	ldw	r2,-32(fp)
811463d0:	1004d43a 	srli	r2,r2,16
811463d4:	e0bff515 	stw	r2,-44(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
811463d8:	00002606 	br	81146474 <altera_avalon_jtag_uart_irq+0x238>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
811463dc:	e0bff717 	ldw	r2,-36(fp)
811463e0:	e0fff617 	ldw	r3,-40(fp)
811463e4:	18c01017 	ldw	r3,64(r3)
811463e8:	e13ff617 	ldw	r4,-40(fp)
811463ec:	20c7883a 	add	r3,r4,r3
811463f0:	18c21104 	addi	r3,r3,2116
811463f4:	18c00003 	ldbu	r3,0(r3)
811463f8:	18c03fcc 	andi	r3,r3,255
811463fc:	18c0201c 	xori	r3,r3,128
81146400:	18ffe004 	addi	r3,r3,-128
81146404:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81146408:	e0bff617 	ldw	r2,-40(fp)
8114640c:	10801017 	ldw	r2,64(r2)
81146410:	10800044 	addi	r2,r2,1
81146414:	10c1ffcc 	andi	r3,r2,2047
81146418:	e0bff617 	ldw	r2,-40(fp)
8114641c:	10c01015 	stw	r3,64(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);
81146420:	e0bff617 	ldw	r2,-40(fp)
81146424:	10800c17 	ldw	r2,48(r2)
81146428:	e0bffa15 	stw	r2,-24(fp)
8114642c:	00800084 	movi	r2,2
81146430:	e0bffd0d 	sth	r2,-12(fp)
81146434:	00800044 	movi	r2,1
81146438:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
8114643c:	d0a09103 	ldbu	r2,-32188(gp)
81146440:	10803fcc 	andi	r2,r2,255
81146444:	10000826 	beq	r2,zero,81146468 <altera_avalon_jtag_uart_irq+0x22c>
  {
    OSFlagPost (group, flags, opt, &err);
81146448:	e0bffd0b 	ldhu	r2,-12(fp)
8114644c:	e0fffd83 	ldbu	r3,-10(fp)
81146450:	e13ffe04 	addi	r4,fp,-8
81146454:	200f883a 	mov	r7,r4
81146458:	180d883a 	mov	r6,r3
8114645c:	100b883a 	mov	r5,r2
81146460:	e13ffa17 	ldw	r4,-24(fp)
81146464:	113ae480 	call	8113ae48 <OSFlagPost>

        space--;
81146468:	e0bff517 	ldw	r2,-44(fp)
8114646c:	10bfffc4 	addi	r2,r2,-1
81146470:	e0bff515 	stw	r2,-44(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
81146474:	e0bff517 	ldw	r2,-44(fp)
81146478:	10000526 	beq	r2,zero,81146490 <altera_avalon_jtag_uart_irq+0x254>
8114647c:	e0bff617 	ldw	r2,-40(fp)
81146480:	10c01017 	ldw	r3,64(r2)
81146484:	e0bff617 	ldw	r2,-40(fp)
81146488:	10800f17 	ldw	r2,60(r2)
8114648c:	18bfd31e 	bne	r3,r2,811463dc <__reset+0xfb1263dc>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
81146490:	e0bff517 	ldw	r2,-44(fp)
81146494:	103f7926 	beq	r2,zero,8114627c <__reset+0xfb12627c>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
81146498:	e0bff617 	ldw	r2,-40(fp)
8114649c:	10c00817 	ldw	r3,32(r2)
811464a0:	00bfff44 	movi	r2,-3
811464a4:	1886703a 	and	r3,r3,r2
811464a8:	e0bff617 	ldw	r2,-40(fp)
811464ac:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
811464b0:	e0bff617 	ldw	r2,-40(fp)
811464b4:	10800017 	ldw	r2,0(r2)
811464b8:	10800104 	addi	r2,r2,4
811464bc:	1007883a 	mov	r3,r2
811464c0:	e0bff617 	ldw	r2,-40(fp)
811464c4:	10800817 	ldw	r2,32(r2)
811464c8:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
811464cc:	e0bff717 	ldw	r2,-36(fp)
811464d0:	10800104 	addi	r2,r2,4
811464d4:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
811464d8:	003f6806 	br	8114627c <__reset+0xfb12627c>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
811464dc:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
811464e0:	0001883a 	nop
811464e4:	e037883a 	mov	sp,fp
811464e8:	dfc00117 	ldw	ra,4(sp)
811464ec:	df000017 	ldw	fp,0(sp)
811464f0:	dec00204 	addi	sp,sp,8
811464f4:	f800283a 	ret

811464f8 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
811464f8:	defff904 	addi	sp,sp,-28
811464fc:	de00012e 	bgeu	sp,et,81146504 <altera_avalon_jtag_uart_timeout+0xc>
81146500:	003b68fa 	trap	3
81146504:	dfc00615 	stw	ra,24(sp)
81146508:	df000515 	stw	fp,20(sp)
8114650c:	df000504 	addi	fp,sp,20
81146510:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
81146514:	e0bfff17 	ldw	r2,-4(fp)
81146518:	e0bffb15 	stw	r2,-20(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
8114651c:	e0bffb17 	ldw	r2,-20(fp)
81146520:	10800017 	ldw	r2,0(r2)
81146524:	10800104 	addi	r2,r2,4
81146528:	10800037 	ldwio	r2,0(r2)
8114652c:	e0bffc15 	stw	r2,-16(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
81146530:	e0bffc17 	ldw	r2,-16(fp)
81146534:	1081000c 	andi	r2,r2,1024
81146538:	10000b26 	beq	r2,zero,81146568 <altera_avalon_jtag_uart_timeout+0x70>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
8114653c:	e0bffb17 	ldw	r2,-20(fp)
81146540:	10800017 	ldw	r2,0(r2)
81146544:	10800104 	addi	r2,r2,4
81146548:	1007883a 	mov	r3,r2
8114654c:	e0bffb17 	ldw	r2,-20(fp)
81146550:	10800817 	ldw	r2,32(r2)
81146554:	10810014 	ori	r2,r2,1024
81146558:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
8114655c:	e0bffb17 	ldw	r2,-20(fp)
81146560:	10000915 	stw	zero,36(r2)
81146564:	00002106 	br	811465ec <altera_avalon_jtag_uart_timeout+0xf4>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
81146568:	e0bffb17 	ldw	r2,-20(fp)
8114656c:	10c00917 	ldw	r3,36(r2)
81146570:	00a00034 	movhi	r2,32768
81146574:	10bfff04 	addi	r2,r2,-4
81146578:	10c01c36 	bltu	r2,r3,811465ec <altera_avalon_jtag_uart_timeout+0xf4>
    sp->host_inactive++;
8114657c:	e0bffb17 	ldw	r2,-20(fp)
81146580:	10800917 	ldw	r2,36(r2)
81146584:	10c00044 	addi	r3,r2,1
81146588:	e0bffb17 	ldw	r2,-20(fp)
8114658c:	10c00915 	stw	r3,36(r2)
    
    if (sp->host_inactive >= sp->timeout) {
81146590:	e0bffb17 	ldw	r2,-20(fp)
81146594:	10c00917 	ldw	r3,36(r2)
81146598:	e0bffb17 	ldw	r2,-20(fp)
8114659c:	10800117 	ldw	r2,4(r2)
811465a0:	18801236 	bltu	r3,r2,811465ec <altera_avalon_jtag_uart_timeout+0xf4>
      /* Post an event to indicate host is inactive (for jtag_uart_read */
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
811465a4:	e0bffb17 	ldw	r2,-20(fp)
811465a8:	10800c17 	ldw	r2,48(r2)
811465ac:	e0bffd15 	stw	r2,-12(fp)
811465b0:	00800104 	movi	r2,4
811465b4:	e0bffe0d 	sth	r2,-8(fp)
811465b8:	00800044 	movi	r2,1
811465bc:	e0bffe85 	stb	r2,-6(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
811465c0:	d0a09103 	ldbu	r2,-32188(gp)
811465c4:	10803fcc 	andi	r2,r2,255
811465c8:	10000826 	beq	r2,zero,811465ec <altera_avalon_jtag_uart_timeout+0xf4>
  {
    OSFlagPost (group, flags, opt, &err);
811465cc:	e0bffe0b 	ldhu	r2,-8(fp)
811465d0:	e0fffe83 	ldbu	r3,-6(fp)
811465d4:	e13ffec4 	addi	r4,fp,-5
811465d8:	200f883a 	mov	r7,r4
811465dc:	180d883a 	mov	r6,r3
811465e0:	100b883a 	mov	r5,r2
811465e4:	e13ffd17 	ldw	r4,-12(fp)
811465e8:	113ae480 	call	8113ae48 <OSFlagPost>
811465ec:	d0a08817 	ldw	r2,-32224(gp)
    }
  }

  return alt_ticks_per_second();
}
811465f0:	e037883a 	mov	sp,fp
811465f4:	dfc00117 	ldw	ra,4(sp)
811465f8:	df000017 	ldw	fp,0(sp)
811465fc:	dec00204 	addi	sp,sp,8
81146600:	f800283a 	ret

81146604 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
81146604:	defffd04 	addi	sp,sp,-12
81146608:	de00012e 	bgeu	sp,et,81146610 <altera_avalon_jtag_uart_close+0xc>
8114660c:	003b68fa 	trap	3
81146610:	df000215 	stw	fp,8(sp)
81146614:	df000204 	addi	fp,sp,8
81146618:	e13ffe15 	stw	r4,-8(fp)
8114661c:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
81146620:	00000506 	br	81146638 <altera_avalon_jtag_uart_close+0x34>
    if (flags & O_NONBLOCK) {
81146624:	e0bfff17 	ldw	r2,-4(fp)
81146628:	1090000c 	andi	r2,r2,16384
8114662c:	10000226 	beq	r2,zero,81146638 <altera_avalon_jtag_uart_close+0x34>
      return -EWOULDBLOCK; 
81146630:	00bffd44 	movi	r2,-11
81146634:	00000b06 	br	81146664 <altera_avalon_jtag_uart_close+0x60>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
81146638:	e0bffe17 	ldw	r2,-8(fp)
8114663c:	10c01017 	ldw	r3,64(r2)
81146640:	e0bffe17 	ldw	r2,-8(fp)
81146644:	10800f17 	ldw	r2,60(r2)
81146648:	18800526 	beq	r3,r2,81146660 <altera_avalon_jtag_uart_close+0x5c>
8114664c:	e0bffe17 	ldw	r2,-8(fp)
81146650:	10c00917 	ldw	r3,36(r2)
81146654:	e0bffe17 	ldw	r2,-8(fp)
81146658:	10800117 	ldw	r2,4(r2)
8114665c:	18bff136 	bltu	r3,r2,81146624 <__reset+0xfb126624>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
81146660:	0005883a 	mov	r2,zero
}
81146664:	e037883a 	mov	sp,fp
81146668:	df000017 	ldw	fp,0(sp)
8114666c:	dec00104 	addi	sp,sp,4
81146670:	f800283a 	ret

81146674 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
81146674:	defffa04 	addi	sp,sp,-24
81146678:	de00012e 	bgeu	sp,et,81146680 <altera_avalon_jtag_uart_ioctl+0xc>
8114667c:	003b68fa 	trap	3
81146680:	df000515 	stw	fp,20(sp)
81146684:	df000504 	addi	fp,sp,20
81146688:	e13ffd15 	stw	r4,-12(fp)
8114668c:	e17ffe15 	stw	r5,-8(fp)
81146690:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
81146694:	00bff9c4 	movi	r2,-25
81146698:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
8114669c:	e0bffe17 	ldw	r2,-8(fp)
811466a0:	10da8060 	cmpeqi	r3,r2,27137
811466a4:	1800031e 	bne	r3,zero,811466b4 <altera_avalon_jtag_uart_ioctl+0x40>
811466a8:	109a80a0 	cmpeqi	r2,r2,27138
811466ac:	1000181e 	bne	r2,zero,81146710 <altera_avalon_jtag_uart_ioctl+0x9c>
      rc = 0;
    }
    break;

  default:
    break;
811466b0:	00002906 	br	81146758 <altera_avalon_jtag_uart_ioctl+0xe4>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
811466b4:	e0bffd17 	ldw	r2,-12(fp)
811466b8:	10c00117 	ldw	r3,4(r2)
811466bc:	00a00034 	movhi	r2,32768
811466c0:	10bfffc4 	addi	r2,r2,-1
811466c4:	18802126 	beq	r3,r2,8114674c <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
811466c8:	e0bfff17 	ldw	r2,-4(fp)
811466cc:	10800017 	ldw	r2,0(r2)
811466d0:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
811466d4:	e0bffc17 	ldw	r2,-16(fp)
811466d8:	10800090 	cmplti	r2,r2,2
811466dc:	1000061e 	bne	r2,zero,811466f8 <altera_avalon_jtag_uart_ioctl+0x84>
811466e0:	e0fffc17 	ldw	r3,-16(fp)
811466e4:	00a00034 	movhi	r2,32768
811466e8:	10bfffc4 	addi	r2,r2,-1
811466ec:	18800226 	beq	r3,r2,811466f8 <altera_avalon_jtag_uart_ioctl+0x84>
811466f0:	e0bffc17 	ldw	r2,-16(fp)
811466f4:	00000206 	br	81146700 <altera_avalon_jtag_uart_ioctl+0x8c>
811466f8:	00a00034 	movhi	r2,32768
811466fc:	10bfff84 	addi	r2,r2,-2
81146700:	e0fffd17 	ldw	r3,-12(fp)
81146704:	18800115 	stw	r2,4(r3)
      rc = 0;
81146708:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
8114670c:	00000f06 	br	8114674c <altera_avalon_jtag_uart_ioctl+0xd8>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
81146710:	e0bffd17 	ldw	r2,-12(fp)
81146714:	10c00117 	ldw	r3,4(r2)
81146718:	00a00034 	movhi	r2,32768
8114671c:	10bfffc4 	addi	r2,r2,-1
81146720:	18800c26 	beq	r3,r2,81146754 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
81146724:	e0bffd17 	ldw	r2,-12(fp)
81146728:	10c00917 	ldw	r3,36(r2)
8114672c:	e0bffd17 	ldw	r2,-12(fp)
81146730:	10800117 	ldw	r2,4(r2)
81146734:	1885803a 	cmpltu	r2,r3,r2
81146738:	10c03fcc 	andi	r3,r2,255
8114673c:	e0bfff17 	ldw	r2,-4(fp)
81146740:	10c00015 	stw	r3,0(r2)
      rc = 0;
81146744:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
81146748:	00000206 	br	81146754 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
8114674c:	0001883a 	nop
81146750:	00000106 	br	81146758 <altera_avalon_jtag_uart_ioctl+0xe4>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
81146754:	0001883a 	nop

  default:
    break;
  }

  return rc;
81146758:	e0bffb17 	ldw	r2,-20(fp)
}
8114675c:	e037883a 	mov	sp,fp
81146760:	df000017 	ldw	fp,0(sp)
81146764:	dec00104 	addi	sp,sp,4
81146768:	f800283a 	ret

8114676c <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
8114676c:	deffed04 	addi	sp,sp,-76
81146770:	de00012e 	bgeu	sp,et,81146778 <altera_avalon_jtag_uart_read+0xc>
81146774:	003b68fa 	trap	3
81146778:	dfc01215 	stw	ra,72(sp)
8114677c:	df001115 	stw	fp,68(sp)
81146780:	df001104 	addi	fp,sp,68
81146784:	e13ffc15 	stw	r4,-16(fp)
81146788:	e17ffd15 	stw	r5,-12(fp)
8114678c:	e1bffe15 	stw	r6,-8(fp)
81146790:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
81146794:	e0bffd17 	ldw	r2,-12(fp)
81146798:	e0bff015 	stw	r2,-64(fp)

  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);
8114679c:	e0bffc17 	ldw	r2,-16(fp)
811467a0:	10800a17 	ldw	r2,40(r2)
811467a4:	e0bff815 	stw	r2,-32(fp)
811467a8:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
811467ac:	e0bff90b 	ldhu	r2,-28(fp)
811467b0:	e0fffb04 	addi	r3,fp,-20
811467b4:	180d883a 	mov	r6,r3
811467b8:	100b883a 	mov	r5,r2
811467bc:	e13ff817 	ldw	r4,-32(fp)
811467c0:	113e4c00 	call	8113e4c0 <OSSemPend>

  while (space > 0)
811467c4:	00006106 	br	8114694c <altera_avalon_jtag_uart_read+0x1e0>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
811467c8:	e0bffc17 	ldw	r2,-16(fp)
811467cc:	10800d17 	ldw	r2,52(r2)
811467d0:	e0bff315 	stw	r2,-52(fp)
      out = sp->rx_out;
811467d4:	e0bffc17 	ldw	r2,-16(fp)
811467d8:	10800e17 	ldw	r2,56(r2)
811467dc:	e0bff415 	stw	r2,-48(fp)

      if (in >= out)
811467e0:	e0fff317 	ldw	r3,-52(fp)
811467e4:	e0bff417 	ldw	r2,-48(fp)
811467e8:	18800536 	bltu	r3,r2,81146800 <altera_avalon_jtag_uart_read+0x94>
        n = in - out;
811467ec:	e0fff317 	ldw	r3,-52(fp)
811467f0:	e0bff417 	ldw	r2,-48(fp)
811467f4:	1885c83a 	sub	r2,r3,r2
811467f8:	e0bff115 	stw	r2,-60(fp)
811467fc:	00000406 	br	81146810 <altera_avalon_jtag_uart_read+0xa4>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
81146800:	00c20004 	movi	r3,2048
81146804:	e0bff417 	ldw	r2,-48(fp)
81146808:	1885c83a 	sub	r2,r3,r2
8114680c:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
81146810:	e0bff117 	ldw	r2,-60(fp)
81146814:	10001e26 	beq	r2,zero,81146890 <altera_avalon_jtag_uart_read+0x124>
        break; /* No more data available */

      if (n > space)
81146818:	e0fffe17 	ldw	r3,-8(fp)
8114681c:	e0bff117 	ldw	r2,-60(fp)
81146820:	1880022e 	bgeu	r3,r2,8114682c <altera_avalon_jtag_uart_read+0xc0>
        n = space;
81146824:	e0bffe17 	ldw	r2,-8(fp)
81146828:	e0bff115 	stw	r2,-60(fp)

      memcpy(ptr, sp->rx_buf + out, n);
8114682c:	e0bffc17 	ldw	r2,-16(fp)
81146830:	10c01104 	addi	r3,r2,68
81146834:	e0bff417 	ldw	r2,-48(fp)
81146838:	1885883a 	add	r2,r3,r2
8114683c:	e1bff117 	ldw	r6,-60(fp)
81146840:	100b883a 	mov	r5,r2
81146844:	e13ff017 	ldw	r4,-64(fp)
81146848:	11220540 	call	81122054 <memcpy>
      ptr   += n;
8114684c:	e0fff017 	ldw	r3,-64(fp)
81146850:	e0bff117 	ldw	r2,-60(fp)
81146854:	1885883a 	add	r2,r3,r2
81146858:	e0bff015 	stw	r2,-64(fp)
      space -= n;
8114685c:	e0fffe17 	ldw	r3,-8(fp)
81146860:	e0bff117 	ldw	r2,-60(fp)
81146864:	1885c83a 	sub	r2,r3,r2
81146868:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
8114686c:	e0fff417 	ldw	r3,-48(fp)
81146870:	e0bff117 	ldw	r2,-60(fp)
81146874:	1885883a 	add	r2,r3,r2
81146878:	10c1ffcc 	andi	r3,r2,2047
8114687c:	e0bffc17 	ldw	r2,-16(fp)
81146880:	10c00e15 	stw	r3,56(r2)
    }
    while (space > 0);
81146884:	e0bffe17 	ldw	r2,-8(fp)
81146888:	00bfcf16 	blt	zero,r2,811467c8 <__reset+0xfb1267c8>
8114688c:	00000106 	br	81146894 <altera_avalon_jtag_uart_read+0x128>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
81146890:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
81146894:	e0fff017 	ldw	r3,-64(fp)
81146898:	e0bffd17 	ldw	r2,-12(fp)
8114689c:	18802e1e 	bne	r3,r2,81146958 <altera_avalon_jtag_uart_read+0x1ec>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
811468a0:	e0bfff17 	ldw	r2,-4(fp)
811468a4:	1090000c 	andi	r2,r2,16384
811468a8:	10002d1e 	bne	r2,zero,81146960 <altera_avalon_jtag_uart_read+0x1f4>
      break;

#ifdef __ucosii__
    /* OS Present: Pend on a flag if the OS is running, otherwise spin */
    if(OSRunning == OS_TRUE) {
811468ac:	d0a09103 	ldbu	r2,-32188(gp)
811468b0:	10803fcc 	andi	r2,r2,255
811468b4:	10800058 	cmpnei	r2,r2,1
811468b8:	1000161e 	bne	r2,zero,81146914 <altera_avalon_jtag_uart_read+0x1a8>
       * When running in a multi-threaded mode, we pend on the read event
       * flag set and timeout event flag set in the isr. This avoids wasting CPU
       * cycles waiting in this thread, when we could be doing something more
       * profitable elsewhere.
       */
      ALT_FLAG_PEND (sp->events,
811468bc:	e0bffc17 	ldw	r2,-16(fp)
811468c0:	10800c17 	ldw	r2,48(r2)
811468c4:	e0bff215 	stw	r2,-56(fp)
811468c8:	00800144 	movi	r2,5
811468cc:	e0bff98d 	sth	r2,-26(fp)
811468d0:	00bfe0c4 	movi	r2,-125
811468d4:	e0bffa05 	stb	r2,-24(fp)
811468d8:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
811468dc:	d0a09103 	ldbu	r2,-32188(gp)
811468e0:	10803fcc 	andi	r2,r2,255
811468e4:	10001526 	beq	r2,zero,8114693c <altera_avalon_jtag_uart_read+0x1d0>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
811468e8:	e0fff98b 	ldhu	r3,-26(fp)
811468ec:	e13ffa03 	ldbu	r4,-24(fp)
811468f0:	e17ffa8b 	ldhu	r5,-22(fp)
811468f4:	e0bffb44 	addi	r2,fp,-19
811468f8:	d8800015 	stw	r2,0(sp)
811468fc:	280f883a 	mov	r7,r5
81146900:	200d883a 	mov	r6,r4
81146904:	180b883a 	mov	r5,r3
81146908:	e13ff217 	ldw	r4,-56(fp)
8114690c:	113a8200 	call	8113a820 <OSFlagPend>
81146910:	00000a06 	br	8114693c <altera_avalon_jtag_uart_read+0x1d0>
                     OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                     0);
    }
    else {
      /* Spin until more data arrives or until host disconnects */
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
81146914:	0001883a 	nop
81146918:	e0bffc17 	ldw	r2,-16(fp)
8114691c:	10c00d17 	ldw	r3,52(r2)
81146920:	e0bff317 	ldw	r2,-52(fp)
81146924:	1880051e 	bne	r3,r2,8114693c <altera_avalon_jtag_uart_read+0x1d0>
81146928:	e0bffc17 	ldw	r2,-16(fp)
8114692c:	10c00917 	ldw	r3,36(r2)
81146930:	e0bffc17 	ldw	r2,-16(fp)
81146934:	10800117 	ldw	r2,4(r2)
81146938:	18bff736 	bltu	r3,r2,81146918 <__reset+0xfb126918>
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
8114693c:	e0bffc17 	ldw	r2,-16(fp)
81146940:	10c00d17 	ldw	r3,52(r2)
81146944:	e0bff317 	ldw	r2,-52(fp)
81146948:	18800726 	beq	r3,r2,81146968 <altera_avalon_jtag_uart_read+0x1fc>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
8114694c:	e0bffe17 	ldw	r2,-8(fp)
81146950:	00bf9d16 	blt	zero,r2,811467c8 <__reset+0xfb1267c8>
81146954:	00000506 	br	8114696c <altera_avalon_jtag_uart_read+0x200>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
81146958:	0001883a 	nop
8114695c:	00000306 	br	8114696c <altera_avalon_jtag_uart_read+0x200>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
81146960:	0001883a 	nop
81146964:	00000106 	br	8114696c <altera_avalon_jtag_uart_read+0x200>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
81146968:	0001883a 	nop
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
8114696c:	e0bffc17 	ldw	r2,-16(fp)
81146970:	10800a17 	ldw	r2,40(r2)
81146974:	1009883a 	mov	r4,r2
81146978:	113e8480 	call	8113e848 <OSSemPost>

  if (ptr != buffer)
8114697c:	e0fff017 	ldw	r3,-64(fp)
81146980:	e0bffd17 	ldw	r2,-12(fp)
81146984:	18801826 	beq	r3,r2,811469e8 <altera_avalon_jtag_uart_read+0x27c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81146988:	0005303a 	rdctl	r2,status
8114698c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81146990:	e0fff717 	ldw	r3,-36(fp)
81146994:	00bfff84 	movi	r2,-2
81146998:	1884703a 	and	r2,r3,r2
8114699c:	1001703a 	wrctl	status,r2
  
  return context;
811469a0:	e0bff717 	ldw	r2,-36(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
811469a4:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
811469a8:	e0bffc17 	ldw	r2,-16(fp)
811469ac:	10800817 	ldw	r2,32(r2)
811469b0:	10c00054 	ori	r3,r2,1
811469b4:	e0bffc17 	ldw	r2,-16(fp)
811469b8:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
811469bc:	e0bffc17 	ldw	r2,-16(fp)
811469c0:	10800017 	ldw	r2,0(r2)
811469c4:	10800104 	addi	r2,r2,4
811469c8:	1007883a 	mov	r3,r2
811469cc:	e0bffc17 	ldw	r2,-16(fp)
811469d0:	10800817 	ldw	r2,32(r2)
811469d4:	18800035 	stwio	r2,0(r3)
811469d8:	e0bff617 	ldw	r2,-40(fp)
811469dc:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811469e0:	e0bff517 	ldw	r2,-44(fp)
811469e4:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
811469e8:	e0fff017 	ldw	r3,-64(fp)
811469ec:	e0bffd17 	ldw	r2,-12(fp)
811469f0:	18800426 	beq	r3,r2,81146a04 <altera_avalon_jtag_uart_read+0x298>
    return ptr - buffer;
811469f4:	e0fff017 	ldw	r3,-64(fp)
811469f8:	e0bffd17 	ldw	r2,-12(fp)
811469fc:	1885c83a 	sub	r2,r3,r2
81146a00:	00000606 	br	81146a1c <altera_avalon_jtag_uart_read+0x2b0>
  else if (flags & O_NONBLOCK)
81146a04:	e0bfff17 	ldw	r2,-4(fp)
81146a08:	1090000c 	andi	r2,r2,16384
81146a0c:	10000226 	beq	r2,zero,81146a18 <altera_avalon_jtag_uart_read+0x2ac>
    return -EWOULDBLOCK;
81146a10:	00bffd44 	movi	r2,-11
81146a14:	00000106 	br	81146a1c <altera_avalon_jtag_uart_read+0x2b0>
  else
    return -EIO;
81146a18:	00bffec4 	movi	r2,-5
}
81146a1c:	e037883a 	mov	sp,fp
81146a20:	dfc00117 	ldw	ra,4(sp)
81146a24:	df000017 	ldw	fp,0(sp)
81146a28:	dec00204 	addi	sp,sp,8
81146a2c:	f800283a 	ret

81146a30 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
81146a30:	deffed04 	addi	sp,sp,-76
81146a34:	de00012e 	bgeu	sp,et,81146a3c <altera_avalon_jtag_uart_write+0xc>
81146a38:	003b68fa 	trap	3
81146a3c:	dfc01215 	stw	ra,72(sp)
81146a40:	df001115 	stw	fp,68(sp)
81146a44:	df001104 	addi	fp,sp,68
81146a48:	e13ffc15 	stw	r4,-16(fp)
81146a4c:	e17ffd15 	stw	r5,-12(fp)
81146a50:	e1bffe15 	stw	r6,-8(fp)
81146a54:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
81146a58:	e03ff015 	stw	zero,-64(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
81146a5c:	e0bffd17 	ldw	r2,-12(fp)
81146a60:	e0bff215 	stw	r2,-56(fp)

  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */
  ALT_SEM_PEND (sp->write_lock, 0);
81146a64:	e0bffc17 	ldw	r2,-16(fp)
81146a68:	10800b17 	ldw	r2,44(r2)
81146a6c:	e0bff815 	stw	r2,-32(fp)
81146a70:	e03ff90d 	sth	zero,-28(fp)
81146a74:	e0bff90b 	ldhu	r2,-28(fp)
81146a78:	e0fffb44 	addi	r3,fp,-19
81146a7c:	180d883a 	mov	r6,r3
81146a80:	100b883a 	mov	r5,r2
81146a84:	e13ff817 	ldw	r4,-32(fp)
81146a88:	113e4c00 	call	8113e4c0 <OSSemPend>

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
81146a8c:	00003706 	br	81146b6c <altera_avalon_jtag_uart_write+0x13c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
81146a90:	e0bffc17 	ldw	r2,-16(fp)
81146a94:	10800f17 	ldw	r2,60(r2)
81146a98:	e0bff415 	stw	r2,-48(fp)
      out = sp->tx_out;
81146a9c:	e0bffc17 	ldw	r2,-16(fp)
81146aa0:	10801017 	ldw	r2,64(r2)
81146aa4:	e0bff015 	stw	r2,-64(fp)

      if (in < out)
81146aa8:	e0fff417 	ldw	r3,-48(fp)
81146aac:	e0bff017 	ldw	r2,-64(fp)
81146ab0:	1880062e 	bgeu	r3,r2,81146acc <altera_avalon_jtag_uart_write+0x9c>
        n = out - 1 - in;
81146ab4:	e0fff017 	ldw	r3,-64(fp)
81146ab8:	e0bff417 	ldw	r2,-48(fp)
81146abc:	1885c83a 	sub	r2,r3,r2
81146ac0:	10bfffc4 	addi	r2,r2,-1
81146ac4:	e0bff115 	stw	r2,-60(fp)
81146ac8:	00000b06 	br	81146af8 <altera_avalon_jtag_uart_write+0xc8>
      else if (out > 0)
81146acc:	e0bff017 	ldw	r2,-64(fp)
81146ad0:	10000526 	beq	r2,zero,81146ae8 <altera_avalon_jtag_uart_write+0xb8>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
81146ad4:	00c20004 	movi	r3,2048
81146ad8:	e0bff417 	ldw	r2,-48(fp)
81146adc:	1885c83a 	sub	r2,r3,r2
81146ae0:	e0bff115 	stw	r2,-60(fp)
81146ae4:	00000406 	br	81146af8 <altera_avalon_jtag_uart_write+0xc8>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
81146ae8:	00c1ffc4 	movi	r3,2047
81146aec:	e0bff417 	ldw	r2,-48(fp)
81146af0:	1885c83a 	sub	r2,r3,r2
81146af4:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
81146af8:	e0bff117 	ldw	r2,-60(fp)
81146afc:	10001e26 	beq	r2,zero,81146b78 <altera_avalon_jtag_uart_write+0x148>
        break;

      if (n > count)
81146b00:	e0fffe17 	ldw	r3,-8(fp)
81146b04:	e0bff117 	ldw	r2,-60(fp)
81146b08:	1880022e 	bgeu	r3,r2,81146b14 <altera_avalon_jtag_uart_write+0xe4>
        n = count;
81146b0c:	e0bffe17 	ldw	r2,-8(fp)
81146b10:	e0bff115 	stw	r2,-60(fp)

      memcpy(sp->tx_buf + in, ptr, n);
81146b14:	e0bffc17 	ldw	r2,-16(fp)
81146b18:	10c21104 	addi	r3,r2,2116
81146b1c:	e0bff417 	ldw	r2,-48(fp)
81146b20:	1885883a 	add	r2,r3,r2
81146b24:	e1bff117 	ldw	r6,-60(fp)
81146b28:	e17ffd17 	ldw	r5,-12(fp)
81146b2c:	1009883a 	mov	r4,r2
81146b30:	11220540 	call	81122054 <memcpy>
      ptr   += n;
81146b34:	e0fffd17 	ldw	r3,-12(fp)
81146b38:	e0bff117 	ldw	r2,-60(fp)
81146b3c:	1885883a 	add	r2,r3,r2
81146b40:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
81146b44:	e0fffe17 	ldw	r3,-8(fp)
81146b48:	e0bff117 	ldw	r2,-60(fp)
81146b4c:	1885c83a 	sub	r2,r3,r2
81146b50:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81146b54:	e0fff417 	ldw	r3,-48(fp)
81146b58:	e0bff117 	ldw	r2,-60(fp)
81146b5c:	1885883a 	add	r2,r3,r2
81146b60:	10c1ffcc 	andi	r3,r2,2047
81146b64:	e0bffc17 	ldw	r2,-16(fp)
81146b68:	10c00f15 	stw	r3,60(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
81146b6c:	e0bffe17 	ldw	r2,-8(fp)
81146b70:	00bfc716 	blt	zero,r2,81146a90 <__reset+0xfb126a90>
81146b74:	00000106 	br	81146b7c <altera_avalon_jtag_uart_write+0x14c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
81146b78:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81146b7c:	0005303a 	rdctl	r2,status
81146b80:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81146b84:	e0fff717 	ldw	r3,-36(fp)
81146b88:	00bfff84 	movi	r2,-2
81146b8c:	1884703a 	and	r2,r3,r2
81146b90:	1001703a 	wrctl	status,r2
  
  return context;
81146b94:	e0bff717 	ldw	r2,-36(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
81146b98:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
81146b9c:	e0bffc17 	ldw	r2,-16(fp)
81146ba0:	10800817 	ldw	r2,32(r2)
81146ba4:	10c00094 	ori	r3,r2,2
81146ba8:	e0bffc17 	ldw	r2,-16(fp)
81146bac:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
81146bb0:	e0bffc17 	ldw	r2,-16(fp)
81146bb4:	10800017 	ldw	r2,0(r2)
81146bb8:	10800104 	addi	r2,r2,4
81146bbc:	1007883a 	mov	r3,r2
81146bc0:	e0bffc17 	ldw	r2,-16(fp)
81146bc4:	10800817 	ldw	r2,32(r2)
81146bc8:	18800035 	stwio	r2,0(r3)
81146bcc:	e0bff617 	ldw	r2,-40(fp)
81146bd0:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81146bd4:	e0bff317 	ldw	r2,-52(fp)
81146bd8:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
81146bdc:	e0bffe17 	ldw	r2,-8(fp)
81146be0:	00802a0e 	bge	zero,r2,81146c8c <altera_avalon_jtag_uart_write+0x25c>
    {
      if (flags & O_NONBLOCK)
81146be4:	e0bfff17 	ldw	r2,-4(fp)
81146be8:	1090000c 	andi	r2,r2,16384
81146bec:	10002a1e 	bne	r2,zero,81146c98 <altera_avalon_jtag_uart_write+0x268>
        break;

#ifdef __ucosii__
      /* OS Present: Pend on a flag if the OS is running, otherwise spin */
      if(OSRunning == OS_TRUE) {
81146bf0:	d0a09103 	ldbu	r2,-32188(gp)
81146bf4:	10803fcc 	andi	r2,r2,255
81146bf8:	10800058 	cmpnei	r2,r2,1
81146bfc:	1000161e 	bne	r2,zero,81146c58 <altera_avalon_jtag_uart_write+0x228>
         * more profitable elsewhere.
         */
#ifdef ALTERA_AVALON_JTAG_UART_IGNORE_FIFO_FULL_ERROR
        if(!sp->host_inactive)
#endif
        ALT_FLAG_PEND (sp->events,
81146c00:	e0bffc17 	ldw	r2,-16(fp)
81146c04:	10800c17 	ldw	r2,48(r2)
81146c08:	e0bff515 	stw	r2,-44(fp)
81146c0c:	00800184 	movi	r2,6
81146c10:	e0bff98d 	sth	r2,-26(fp)
81146c14:	00bfe0c4 	movi	r2,-125
81146c18:	e0bffa05 	stb	r2,-24(fp)
81146c1c:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81146c20:	d0a09103 	ldbu	r2,-32188(gp)
81146c24:	10803fcc 	andi	r2,r2,255
81146c28:	10001526 	beq	r2,zero,81146c80 <altera_avalon_jtag_uart_write+0x250>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81146c2c:	e0fff98b 	ldhu	r3,-26(fp)
81146c30:	e13ffa03 	ldbu	r4,-24(fp)
81146c34:	e17ffa8b 	ldhu	r5,-22(fp)
81146c38:	e0bffb04 	addi	r2,fp,-20
81146c3c:	d8800015 	stw	r2,0(sp)
81146c40:	280f883a 	mov	r7,r5
81146c44:	200d883a 	mov	r6,r4
81146c48:	180b883a 	mov	r5,r3
81146c4c:	e13ff517 	ldw	r4,-44(fp)
81146c50:	113a8200 	call	8113a820 <OSFlagPend>
81146c54:	00000a06 	br	81146c80 <altera_avalon_jtag_uart_write+0x250>
        /*
         * OS not running: Wait for data to be removed from buffer.
         * Once the interrupt routine has removed some data then we
         * will be able to insert some more.
         */
        while (out == sp->tx_out && sp->host_inactive < sp->timeout)
81146c58:	0001883a 	nop
81146c5c:	e0bffc17 	ldw	r2,-16(fp)
81146c60:	10c01017 	ldw	r3,64(r2)
81146c64:	e0bff017 	ldw	r2,-64(fp)
81146c68:	1880051e 	bne	r3,r2,81146c80 <altera_avalon_jtag_uart_write+0x250>
81146c6c:	e0bffc17 	ldw	r2,-16(fp)
81146c70:	10c00917 	ldw	r3,36(r2)
81146c74:	e0bffc17 	ldw	r2,-16(fp)
81146c78:	10800117 	ldw	r2,4(r2)
81146c7c:	18bff736 	bltu	r3,r2,81146c5c <__reset+0xfb126c5c>
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
81146c80:	e0bffc17 	ldw	r2,-16(fp)
81146c84:	10800917 	ldw	r2,36(r2)
81146c88:	1000051e 	bne	r2,zero,81146ca0 <altera_avalon_jtag_uart_write+0x270>
         break;
    }
  }
  while (count > 0);
81146c8c:	e0bffe17 	ldw	r2,-8(fp)
81146c90:	00bfb616 	blt	zero,r2,81146b6c <__reset+0xfb126b6c>
81146c94:	00000306 	br	81146ca4 <altera_avalon_jtag_uart_write+0x274>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
81146c98:	0001883a 	nop
81146c9c:	00000106 	br	81146ca4 <altera_avalon_jtag_uart_write+0x274>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
81146ca0:	0001883a 	nop

  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);
81146ca4:	e0bffc17 	ldw	r2,-16(fp)
81146ca8:	10800b17 	ldw	r2,44(r2)
81146cac:	1009883a 	mov	r4,r2
81146cb0:	113e8480 	call	8113e848 <OSSemPost>

  if (ptr != start)
81146cb4:	e0fffd17 	ldw	r3,-12(fp)
81146cb8:	e0bff217 	ldw	r2,-56(fp)
81146cbc:	18800426 	beq	r3,r2,81146cd0 <altera_avalon_jtag_uart_write+0x2a0>
    return ptr - start;
81146cc0:	e0fffd17 	ldw	r3,-12(fp)
81146cc4:	e0bff217 	ldw	r2,-56(fp)
81146cc8:	1885c83a 	sub	r2,r3,r2
81146ccc:	00000606 	br	81146ce8 <altera_avalon_jtag_uart_write+0x2b8>
  else if (flags & O_NONBLOCK)
81146cd0:	e0bfff17 	ldw	r2,-4(fp)
81146cd4:	1090000c 	andi	r2,r2,16384
81146cd8:	10000226 	beq	r2,zero,81146ce4 <altera_avalon_jtag_uart_write+0x2b4>
    return -EWOULDBLOCK;
81146cdc:	00bffd44 	movi	r2,-11
81146ce0:	00000106 	br	81146ce8 <altera_avalon_jtag_uart_write+0x2b8>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
81146ce4:	00bffec4 	movi	r2,-5
}
81146ce8:	e037883a 	mov	sp,fp
81146cec:	dfc00117 	ldw	ra,4(sp)
81146cf0:	df000017 	ldw	fp,0(sp)
81146cf4:	dec00204 	addi	sp,sp,8
81146cf8:	f800283a 	ret

81146cfc <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
81146cfc:	defffa04 	addi	sp,sp,-24
81146d00:	de00012e 	bgeu	sp,et,81146d08 <alt_avalon_timer_sc_irq+0xc>
81146d04:	003b68fa 	trap	3
81146d08:	dfc00515 	stw	ra,20(sp)
81146d0c:	df000415 	stw	fp,16(sp)
81146d10:	df000404 	addi	fp,sp,16
81146d14:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
81146d18:	0007883a 	mov	r3,zero
81146d1c:	e0bfff17 	ldw	r2,-4(fp)
81146d20:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
81146d24:	e0bfff17 	ldw	r2,-4(fp)
81146d28:	10800104 	addi	r2,r2,4
81146d2c:	10800037 	ldwio	r2,0(r2)

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
  ALT_LOG_SYS_CLK_HEARTBEAT();
81146d30:	1136cfc0 	call	81136cfc <alt_log_system_clock>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81146d34:	0005303a 	rdctl	r2,status
81146d38:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81146d3c:	e0fffd17 	ldw	r3,-12(fp)
81146d40:	00bfff84 	movi	r2,-2
81146d44:	1884703a 	and	r2,r3,r2
81146d48:	1001703a 	wrctl	status,r2
  
  return context;
81146d4c:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
81146d50:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
81146d54:	11375ac0 	call	811375ac <alt_tick>
81146d58:	e0bffc17 	ldw	r2,-16(fp)
81146d5c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81146d60:	e0bffe17 	ldw	r2,-8(fp)
81146d64:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
81146d68:	0001883a 	nop
81146d6c:	e037883a 	mov	sp,fp
81146d70:	dfc00117 	ldw	ra,4(sp)
81146d74:	df000017 	ldw	fp,0(sp)
81146d78:	dec00204 	addi	sp,sp,8
81146d7c:	f800283a 	ret

81146d80 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
81146d80:	defff804 	addi	sp,sp,-32
81146d84:	de00012e 	bgeu	sp,et,81146d8c <alt_avalon_timer_sc_init+0xc>
81146d88:	003b68fa 	trap	3
81146d8c:	dfc00715 	stw	ra,28(sp)
81146d90:	df000615 	stw	fp,24(sp)
81146d94:	df000604 	addi	fp,sp,24
81146d98:	e13ffc15 	stw	r4,-16(fp)
81146d9c:	e17ffd15 	stw	r5,-12(fp)
81146da0:	e1bffe15 	stw	r6,-8(fp)
81146da4:	e1ffff15 	stw	r7,-4(fp)
81146da8:	e0bfff17 	ldw	r2,-4(fp)
81146dac:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
81146db0:	d0a08817 	ldw	r2,-32224(gp)
81146db4:	1000021e 	bne	r2,zero,81146dc0 <alt_avalon_timer_sc_init+0x40>
  {
    _alt_tick_rate = nticks;
81146db8:	e0bffb17 	ldw	r2,-20(fp)
81146dbc:	d0a08815 	stw	r2,-32224(gp)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
81146dc0:	e0bffc17 	ldw	r2,-16(fp)
81146dc4:	10800104 	addi	r2,r2,4
81146dc8:	00c001c4 	movi	r3,7
81146dcc:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
81146dd0:	d8000015 	stw	zero,0(sp)
81146dd4:	e1fffc17 	ldw	r7,-16(fp)
81146dd8:	01a04534 	movhi	r6,33044
81146ddc:	319b3f04 	addi	r6,r6,27900
81146de0:	e17ffe17 	ldw	r5,-8(fp)
81146de4:	e13ffd17 	ldw	r4,-12(fp)
81146de8:	1149f840 	call	81149f84 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
81146dec:	0001883a 	nop
81146df0:	e037883a 	mov	sp,fp
81146df4:	dfc00117 	ldw	ra,4(sp)
81146df8:	df000017 	ldw	fp,0(sp)
81146dfc:	dec00204 	addi	sp,sp,8
81146e00:	f800283a 	ret

81146e04 <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
81146e04:	defffa04 	addi	sp,sp,-24
81146e08:	de00012e 	bgeu	sp,et,81146e10 <altera_avalon_uart_read_fd+0xc>
81146e0c:	003b68fa 	trap	3
81146e10:	dfc00515 	stw	ra,20(sp)
81146e14:	df000415 	stw	fp,16(sp)
81146e18:	df000404 	addi	fp,sp,16
81146e1c:	e13ffd15 	stw	r4,-12(fp)
81146e20:	e17ffe15 	stw	r5,-8(fp)
81146e24:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
81146e28:	e0bffd17 	ldw	r2,-12(fp)
81146e2c:	10800017 	ldw	r2,0(r2)
81146e30:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_read(&dev->state, buffer, space,
81146e34:	e0bffc17 	ldw	r2,-16(fp)
81146e38:	10c00a04 	addi	r3,r2,40
81146e3c:	e0bffd17 	ldw	r2,-12(fp)
81146e40:	10800217 	ldw	r2,8(r2)
81146e44:	100f883a 	mov	r7,r2
81146e48:	e1bfff17 	ldw	r6,-4(fp)
81146e4c:	e17ffe17 	ldw	r5,-8(fp)
81146e50:	1809883a 	mov	r4,r3
81146e54:	11474c40 	call	811474c4 <altera_avalon_uart_read>
      fd->fd_flags);
}
81146e58:	e037883a 	mov	sp,fp
81146e5c:	dfc00117 	ldw	ra,4(sp)
81146e60:	df000017 	ldw	fp,0(sp)
81146e64:	dec00204 	addi	sp,sp,8
81146e68:	f800283a 	ret

81146e6c <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
81146e6c:	defffa04 	addi	sp,sp,-24
81146e70:	de00012e 	bgeu	sp,et,81146e78 <altera_avalon_uart_write_fd+0xc>
81146e74:	003b68fa 	trap	3
81146e78:	dfc00515 	stw	ra,20(sp)
81146e7c:	df000415 	stw	fp,16(sp)
81146e80:	df000404 	addi	fp,sp,16
81146e84:	e13ffd15 	stw	r4,-12(fp)
81146e88:	e17ffe15 	stw	r5,-8(fp)
81146e8c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
81146e90:	e0bffd17 	ldw	r2,-12(fp)
81146e94:	10800017 	ldw	r2,0(r2)
81146e98:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_write(&dev->state, buffer, space,
81146e9c:	e0bffc17 	ldw	r2,-16(fp)
81146ea0:	10c00a04 	addi	r3,r2,40
81146ea4:	e0bffd17 	ldw	r2,-12(fp)
81146ea8:	10800217 	ldw	r2,8(r2)
81146eac:	100f883a 	mov	r7,r2
81146eb0:	e1bfff17 	ldw	r6,-4(fp)
81146eb4:	e17ffe17 	ldw	r5,-8(fp)
81146eb8:	1809883a 	mov	r4,r3
81146ebc:	11477780 	call	81147778 <altera_avalon_uart_write>
      fd->fd_flags);
}
81146ec0:	e037883a 	mov	sp,fp
81146ec4:	dfc00117 	ldw	ra,4(sp)
81146ec8:	df000017 	ldw	fp,0(sp)
81146ecc:	dec00204 	addi	sp,sp,8
81146ed0:	f800283a 	ret

81146ed4 <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
81146ed4:	defffc04 	addi	sp,sp,-16
81146ed8:	de00012e 	bgeu	sp,et,81146ee0 <altera_avalon_uart_close_fd+0xc>
81146edc:	003b68fa 	trap	3
81146ee0:	dfc00315 	stw	ra,12(sp)
81146ee4:	df000215 	stw	fp,8(sp)
81146ee8:	df000204 	addi	fp,sp,8
81146eec:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
81146ef0:	e0bfff17 	ldw	r2,-4(fp)
81146ef4:	10800017 	ldw	r2,0(r2)
81146ef8:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
81146efc:	e0bffe17 	ldw	r2,-8(fp)
81146f00:	10c00a04 	addi	r3,r2,40
81146f04:	e0bfff17 	ldw	r2,-4(fp)
81146f08:	10800217 	ldw	r2,8(r2)
81146f0c:	100b883a 	mov	r5,r2
81146f10:	1809883a 	mov	r4,r3
81146f14:	11474240 	call	81147424 <altera_avalon_uart_close>
}
81146f18:	e037883a 	mov	sp,fp
81146f1c:	dfc00117 	ldw	ra,4(sp)
81146f20:	df000017 	ldw	fp,0(sp)
81146f24:	dec00204 	addi	sp,sp,8
81146f28:	f800283a 	ret

81146f2c <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
81146f2c:	defff304 	addi	sp,sp,-52
81146f30:	de00012e 	bgeu	sp,et,81146f38 <altera_avalon_uart_init+0xc>
81146f34:	003b68fa 	trap	3
81146f38:	dfc00c15 	stw	ra,48(sp)
81146f3c:	df000b15 	stw	fp,44(sp)
81146f40:	df000b04 	addi	fp,sp,44
81146f44:	e13ffd15 	stw	r4,-12(fp)
81146f48:	e17ffe15 	stw	r5,-8(fp)
81146f4c:	e1bfff15 	stw	r6,-4(fp)
  void* base = sp->base;
81146f50:	e0bffd17 	ldw	r2,-12(fp)
81146f54:	10800017 	ldw	r2,0(r2)
81146f58:	e0bff615 	stw	r2,-40(fp)
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
81146f5c:	e0bffd17 	ldw	r2,-12(fp)
81146f60:	10800704 	addi	r2,r2,28
81146f64:	e0bffa15 	stw	r2,-24(fp)
81146f68:	e03ffb0d 	sth	zero,-20(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
81146f6c:	e0bffb0b 	ldhu	r2,-20(fp)
81146f70:	e0fffc84 	addi	r3,fp,-14
81146f74:	180b883a 	mov	r5,r3
81146f78:	1009883a 	mov	r4,r2
81146f7c:	113a23c0 	call	8113a23c <OSFlagCreate>
81146f80:	1007883a 	mov	r3,r2
81146f84:	e0bffa17 	ldw	r2,-24(fp)
81146f88:	10c00015 	stw	r3,0(r2)
  return err;
81146f8c:	e0bffc83 	ldbu	r2,-14(fp)
81146f90:	10803fcc 	andi	r2,r2,255
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
81146f94:	1000241e 	bne	r2,zero,81147028 <altera_avalon_uart_init+0xfc>
81146f98:	e0bffd17 	ldw	r2,-12(fp)
81146f9c:	10800804 	addi	r2,r2,32
81146fa0:	e0bff715 	stw	r2,-36(fp)
81146fa4:	00800044 	movi	r2,1
81146fa8:	e0bffb8d 	sth	r2,-18(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
81146fac:	e0bffb8b 	ldhu	r2,-18(fp)
81146fb0:	1009883a 	mov	r4,r2
81146fb4:	113e1980 	call	8113e198 <OSSemCreate>
81146fb8:	1007883a 	mov	r3,r2
81146fbc:	e0bff717 	ldw	r2,-36(fp)
81146fc0:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
81146fc4:	e0bff717 	ldw	r2,-36(fp)
81146fc8:	10800017 	ldw	r2,0(r2)
81146fcc:	10000226 	beq	r2,zero,81146fd8 <altera_avalon_uart_init+0xac>
81146fd0:	0005883a 	mov	r2,zero
81146fd4:	00000106 	br	81146fdc <altera_avalon_uart_init+0xb0>
81146fd8:	00bfffc4 	movi	r2,-1
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
81146fdc:	1000121e 	bne	r2,zero,81147028 <altera_avalon_uart_init+0xfc>
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);
81146fe0:	e0bffd17 	ldw	r2,-12(fp)
81146fe4:	10800904 	addi	r2,r2,36
81146fe8:	e0bff815 	stw	r2,-32(fp)
81146fec:	00800044 	movi	r2,1
81146ff0:	e0bffc0d 	sth	r2,-16(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
81146ff4:	e0bffc0b 	ldhu	r2,-16(fp)
81146ff8:	1009883a 	mov	r4,r2
81146ffc:	113e1980 	call	8113e198 <OSSemCreate>
81147000:	1007883a 	mov	r3,r2
81147004:	e0bff817 	ldw	r2,-32(fp)
81147008:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
8114700c:	e0bff817 	ldw	r2,-32(fp)
81147010:	10800017 	ldw	r2,0(r2)
81147014:	10000226 	beq	r2,zero,81147020 <altera_avalon_uart_init+0xf4>
81147018:	0005883a 	mov	r2,zero
8114701c:	00000106 	br	81147024 <altera_avalon_uart_init+0xf8>
81147020:	00bfffc4 	movi	r2,-1
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
81147024:	10000226 	beq	r2,zero,81147030 <altera_avalon_uart_init+0x104>
81147028:	00800044 	movi	r2,1
8114702c:	00000106 	br	81147034 <altera_avalon_uart_init+0x108>
81147030:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
81147034:	e0bff915 	stw	r2,-28(fp)
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
81147038:	e0bff917 	ldw	r2,-28(fp)
8114703c:	10000f1e 	bne	r2,zero,8114707c <altera_avalon_uart_init+0x150>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
81147040:	e0bffd17 	ldw	r2,-12(fp)
81147044:	00c32004 	movi	r3,3200
81147048:	10c00115 	stw	r3,4(r2)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
8114704c:	e0bff617 	ldw	r2,-40(fp)
81147050:	10800304 	addi	r2,r2,12
81147054:	e0fffd17 	ldw	r3,-12(fp)
81147058:	18c00117 	ldw	r3,4(r3)
8114705c:	10c00035 	stwio	r3,0(r2)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
81147060:	d8000015 	stw	zero,0(sp)
81147064:	e1fffd17 	ldw	r7,-12(fp)
81147068:	01a04534 	movhi	r6,33044
8114706c:	319c2504 	addi	r6,r6,28820
81147070:	e17fff17 	ldw	r5,-4(fp)
81147074:	e13ffe17 	ldw	r4,-8(fp)
81147078:	1149f840 	call	81149f84 <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
8114707c:	0001883a 	nop
81147080:	e037883a 	mov	sp,fp
81147084:	dfc00117 	ldw	ra,4(sp)
81147088:	df000017 	ldw	fp,0(sp)
8114708c:	dec00204 	addi	sp,sp,8
81147090:	f800283a 	ret

81147094 <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
81147094:	defffa04 	addi	sp,sp,-24
81147098:	de00012e 	bgeu	sp,et,811470a0 <altera_avalon_uart_irq+0xc>
8114709c:	003b68fa 	trap	3
811470a0:	dfc00515 	stw	ra,20(sp)
811470a4:	df000415 	stw	fp,16(sp)
811470a8:	df000404 	addi	fp,sp,16
811470ac:	e13fff15 	stw	r4,-4(fp)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
811470b0:	e0bfff17 	ldw	r2,-4(fp)
811470b4:	e0bffc15 	stw	r2,-16(fp)
  void* base               = sp->base;
811470b8:	e0bffc17 	ldw	r2,-16(fp)
811470bc:	10800017 	ldw	r2,0(r2)
811470c0:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
811470c4:	e0bffd17 	ldw	r2,-12(fp)
811470c8:	10800204 	addi	r2,r2,8
811470cc:	10800037 	ldwio	r2,0(r2)
811470d0:	e0bffe15 	stw	r2,-8(fp)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
811470d4:	e0bffd17 	ldw	r2,-12(fp)
811470d8:	10800204 	addi	r2,r2,8
811470dc:	0007883a 	mov	r3,zero
811470e0:	10c00035 	stwio	r3,0(r2)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
811470e4:	e0bffd17 	ldw	r2,-12(fp)
811470e8:	10800204 	addi	r2,r2,8
811470ec:	10800037 	ldwio	r2,0(r2)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
811470f0:	e0bffe17 	ldw	r2,-8(fp)
811470f4:	1080200c 	andi	r2,r2,128
811470f8:	10000326 	beq	r2,zero,81147108 <altera_avalon_uart_irq+0x74>
  {
    altera_avalon_uart_rxirq(sp, status);
811470fc:	e17ffe17 	ldw	r5,-8(fp)
81147100:	e13ffc17 	ldw	r4,-16(fp)
81147104:	11471380 	call	81147138 <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
81147108:	e0bffe17 	ldw	r2,-8(fp)
8114710c:	1081100c 	andi	r2,r2,1088
81147110:	10000326 	beq	r2,zero,81147120 <altera_avalon_uart_irq+0x8c>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
81147114:	e17ffe17 	ldw	r5,-8(fp)
81147118:	e13ffc17 	ldw	r4,-16(fp)
8114711c:	11472780 	call	81147278 <altera_avalon_uart_txirq>
  }
  

}
81147120:	0001883a 	nop
81147124:	e037883a 	mov	sp,fp
81147128:	dfc00117 	ldw	ra,4(sp)
8114712c:	df000017 	ldw	fp,0(sp)
81147130:	dec00204 	addi	sp,sp,8
81147134:	f800283a 	ret

81147138 <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
81147138:	defff904 	addi	sp,sp,-28
8114713c:	de00012e 	bgeu	sp,et,81147144 <altera_avalon_uart_rxirq+0xc>
81147140:	003b68fa 	trap	3
81147144:	dfc00615 	stw	ra,24(sp)
81147148:	df000515 	stw	fp,20(sp)
8114714c:	df000504 	addi	fp,sp,20
81147150:	e13ffe15 	stw	r4,-8(fp)
81147154:	e17fff15 	stw	r5,-4(fp)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
81147158:	e0bfff17 	ldw	r2,-4(fp)
8114715c:	108000cc 	andi	r2,r2,3
81147160:	10003f1e 	bne	r2,zero,81147260 <altera_avalon_uart_rxirq+0x128>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
81147164:	e0bffe17 	ldw	r2,-8(fp)
81147168:	10c00317 	ldw	r3,12(r2)
8114716c:	e0bffe17 	ldw	r2,-8(fp)
81147170:	10800217 	ldw	r2,8(r2)
81147174:	1880121e 	bne	r3,r2,811471c0 <altera_avalon_uart_rxirq+0x88>
  {
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, OS_FLAG_SET);
81147178:	e0bffe17 	ldw	r2,-8(fp)
8114717c:	10800717 	ldw	r2,28(r2)
81147180:	e0bffc15 	stw	r2,-16(fp)
81147184:	00800044 	movi	r2,1
81147188:	e0bffd0d 	sth	r2,-12(fp)
8114718c:	00800044 	movi	r2,1
81147190:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81147194:	d0a09103 	ldbu	r2,-32188(gp)
81147198:	10803fcc 	andi	r2,r2,255
8114719c:	10000826 	beq	r2,zero,811471c0 <altera_avalon_uart_rxirq+0x88>
  {
    OSFlagPost (group, flags, opt, &err);
811471a0:	e0bffd0b 	ldhu	r2,-12(fp)
811471a4:	e0fffd83 	ldbu	r3,-10(fp)
811471a8:	e13ffdc4 	addi	r4,fp,-9
811471ac:	200f883a 	mov	r7,r4
811471b0:	180d883a 	mov	r6,r3
811471b4:	100b883a 	mov	r5,r2
811471b8:	e13ffc17 	ldw	r4,-16(fp)
811471bc:	113ae480 	call	8113ae48 <OSFlagPost>
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
811471c0:	e0bffe17 	ldw	r2,-8(fp)
811471c4:	10800317 	ldw	r2,12(r2)
811471c8:	10800044 	addi	r2,r2,1
811471cc:	10800fcc 	andi	r2,r2,63
811471d0:	e0bffb15 	stw	r2,-20(fp)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
811471d4:	e0bffe17 	ldw	r2,-8(fp)
811471d8:	10800317 	ldw	r2,12(r2)
811471dc:	e0fffe17 	ldw	r3,-8(fp)
811471e0:	18c00017 	ldw	r3,0(r3)
811471e4:	18c00037 	ldwio	r3,0(r3)
811471e8:	1809883a 	mov	r4,r3
811471ec:	e0fffe17 	ldw	r3,-8(fp)
811471f0:	1885883a 	add	r2,r3,r2
811471f4:	10800a04 	addi	r2,r2,40
811471f8:	11000005 	stb	r4,0(r2)

  sp->rx_end = next;
811471fc:	e0bffe17 	ldw	r2,-8(fp)
81147200:	e0fffb17 	ldw	r3,-20(fp)
81147204:	10c00315 	stw	r3,12(r2)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
81147208:	e0bffe17 	ldw	r2,-8(fp)
8114720c:	10800317 	ldw	r2,12(r2)
81147210:	10800044 	addi	r2,r2,1
81147214:	10800fcc 	andi	r2,r2,63
81147218:	e0bffb15 	stw	r2,-20(fp)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
8114721c:	e0bffe17 	ldw	r2,-8(fp)
81147220:	10c00217 	ldw	r3,8(r2)
81147224:	e0bffb17 	ldw	r2,-20(fp)
81147228:	18800e1e 	bne	r3,r2,81147264 <altera_avalon_uart_rxirq+0x12c>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
8114722c:	e0bffe17 	ldw	r2,-8(fp)
81147230:	10c00117 	ldw	r3,4(r2)
81147234:	00bfdfc4 	movi	r2,-129
81147238:	1886703a 	and	r3,r3,r2
8114723c:	e0bffe17 	ldw	r2,-8(fp)
81147240:	10c00115 	stw	r3,4(r2)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
81147244:	e0bffe17 	ldw	r2,-8(fp)
81147248:	10800017 	ldw	r2,0(r2)
8114724c:	10800304 	addi	r2,r2,12
81147250:	e0fffe17 	ldw	r3,-8(fp)
81147254:	18c00117 	ldw	r3,4(r3)
81147258:	10c00035 	stwio	r3,0(r2)
8114725c:	00000106 	br	81147264 <altera_avalon_uart_rxirq+0x12c>
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
                  ALTERA_AVALON_UART_STATUS_FE_MSK))
  {
    return;
81147260:	0001883a 	nop
  if (next == sp->rx_start)
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
  }   
}
81147264:	e037883a 	mov	sp,fp
81147268:	dfc00117 	ldw	ra,4(sp)
8114726c:	df000017 	ldw	fp,0(sp)
81147270:	dec00204 	addi	sp,sp,8
81147274:	f800283a 	ret

81147278 <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
81147278:	defffa04 	addi	sp,sp,-24
8114727c:	de00012e 	bgeu	sp,et,81147284 <altera_avalon_uart_txirq+0xc>
81147280:	003b68fa 	trap	3
81147284:	dfc00515 	stw	ra,20(sp)
81147288:	df000415 	stw	fp,16(sp)
8114728c:	df000404 	addi	fp,sp,16
81147290:	e13ffe15 	stw	r4,-8(fp)
81147294:	e17fff15 	stw	r5,-4(fp)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
81147298:	e0bffe17 	ldw	r2,-8(fp)
8114729c:	10c00417 	ldw	r3,16(r2)
811472a0:	e0bffe17 	ldw	r2,-8(fp)
811472a4:	10800517 	ldw	r2,20(r2)
811472a8:	18804726 	beq	r3,r2,811473c8 <altera_avalon_uart_txirq+0x150>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
811472ac:	e0bffe17 	ldw	r2,-8(fp)
811472b0:	10800617 	ldw	r2,24(r2)
811472b4:	1080008c 	andi	r2,r2,2
811472b8:	10000326 	beq	r2,zero,811472c8 <altera_avalon_uart_txirq+0x50>
      (status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
811472bc:	e0bfff17 	ldw	r2,-4(fp)
811472c0:	1082000c 	andi	r2,r2,2048
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
811472c4:	10003226 	beq	r2,zero,81147390 <altera_avalon_uart_txirq+0x118>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
811472c8:	e0bffe17 	ldw	r2,-8(fp)
811472cc:	10c00417 	ldw	r3,16(r2)
811472d0:	e0bffe17 	ldw	r2,-8(fp)
811472d4:	10800517 	ldw	r2,20(r2)
811472d8:	10800044 	addi	r2,r2,1
811472dc:	10800fcc 	andi	r2,r2,63
811472e0:	1880121e 	bne	r3,r2,8114732c <altera_avalon_uart_txirq+0xb4>
      { 
        ALT_FLAG_POST (sp->events, 
811472e4:	e0bffe17 	ldw	r2,-8(fp)
811472e8:	10800717 	ldw	r2,28(r2)
811472ec:	e0bffc15 	stw	r2,-16(fp)
811472f0:	00800084 	movi	r2,2
811472f4:	e0bffd0d 	sth	r2,-12(fp)
811472f8:	00800044 	movi	r2,1
811472fc:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81147300:	d0a09103 	ldbu	r2,-32188(gp)
81147304:	10803fcc 	andi	r2,r2,255
81147308:	10000826 	beq	r2,zero,8114732c <altera_avalon_uart_txirq+0xb4>
  {
    OSFlagPost (group, flags, opt, &err);
8114730c:	e0bffd0b 	ldhu	r2,-12(fp)
81147310:	e0fffd83 	ldbu	r3,-10(fp)
81147314:	e13ffdc4 	addi	r4,fp,-9
81147318:	200f883a 	mov	r7,r4
8114731c:	180d883a 	mov	r6,r3
81147320:	100b883a 	mov	r5,r2
81147324:	e13ffc17 	ldw	r4,-16(fp)
81147328:	113ae480 	call	8113ae48 <OSFlagPost>
                       OS_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
8114732c:	e0bffe17 	ldw	r2,-8(fp)
81147330:	10800017 	ldw	r2,0(r2)
81147334:	10800104 	addi	r2,r2,4
81147338:	e0fffe17 	ldw	r3,-8(fp)
8114733c:	18c00417 	ldw	r3,16(r3)
81147340:	e13ffe17 	ldw	r4,-8(fp)
81147344:	20c7883a 	add	r3,r4,r3
81147348:	18c01a04 	addi	r3,r3,104
8114734c:	18c00003 	ldbu	r3,0(r3)
81147350:	18c03fcc 	andi	r3,r3,255
81147354:	10c00035 	stwio	r3,0(r2)

      sp->tx_start = (++sp->tx_start) & ALT_AVALON_UART_BUF_MSK;
81147358:	e0bffe17 	ldw	r2,-8(fp)
8114735c:	10800417 	ldw	r2,16(r2)
81147360:	10800044 	addi	r2,r2,1
81147364:	e0fffe17 	ldw	r3,-8(fp)
81147368:	18800415 	stw	r2,16(r3)
8114736c:	10c00fcc 	andi	r3,r2,63
81147370:	e0bffe17 	ldw	r2,-8(fp)
81147374:	10c00415 	stw	r3,16(r2)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
81147378:	e0bffe17 	ldw	r2,-8(fp)
8114737c:	10800117 	ldw	r2,4(r2)
81147380:	10c01014 	ori	r3,r2,64
81147384:	e0bffe17 	ldw	r2,-8(fp)
81147388:	10c00115 	stw	r3,4(r2)
8114738c:	00000e06 	br	811473c8 <altera_avalon_uart_txirq+0x150>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
81147390:	e0bffe17 	ldw	r2,-8(fp)
81147394:	10800017 	ldw	r2,0(r2)
81147398:	10800204 	addi	r2,r2,8
8114739c:	10800037 	ldwio	r2,0(r2)
811473a0:	e0bfff15 	stw	r2,-4(fp)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
811473a4:	e0bfff17 	ldw	r2,-4(fp)
811473a8:	1082000c 	andi	r2,r2,2048
811473ac:	1000061e 	bne	r2,zero,811473c8 <altera_avalon_uart_txirq+0x150>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
811473b0:	e0bffe17 	ldw	r2,-8(fp)
811473b4:	10c00117 	ldw	r3,4(r2)
811473b8:	00bfefc4 	movi	r2,-65
811473bc:	1886703a 	and	r3,r3,r2
811473c0:	e0bffe17 	ldw	r2,-8(fp)
811473c4:	10c00115 	stw	r3,4(r2)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
811473c8:	e0bffe17 	ldw	r2,-8(fp)
811473cc:	10c00417 	ldw	r3,16(r2)
811473d0:	e0bffe17 	ldw	r2,-8(fp)
811473d4:	10800517 	ldw	r2,20(r2)
811473d8:	1880061e 	bne	r3,r2,811473f4 <altera_avalon_uart_txirq+0x17c>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
811473dc:	e0bffe17 	ldw	r2,-8(fp)
811473e0:	10c00117 	ldw	r3,4(r2)
811473e4:	00beefc4 	movi	r2,-1089
811473e8:	1886703a 	and	r3,r3,r2
811473ec:	e0bffe17 	ldw	r2,-8(fp)
811473f0:	10c00115 	stw	r3,4(r2)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
811473f4:	e0bffe17 	ldw	r2,-8(fp)
811473f8:	10800017 	ldw	r2,0(r2)
811473fc:	10800304 	addi	r2,r2,12
81147400:	e0fffe17 	ldw	r3,-8(fp)
81147404:	18c00117 	ldw	r3,4(r3)
81147408:	10c00035 	stwio	r3,0(r2)
}
8114740c:	0001883a 	nop
81147410:	e037883a 	mov	sp,fp
81147414:	dfc00117 	ldw	ra,4(sp)
81147418:	df000017 	ldw	fp,0(sp)
8114741c:	dec00204 	addi	sp,sp,8
81147420:	f800283a 	ret

81147424 <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
81147424:	defffd04 	addi	sp,sp,-12
81147428:	de00012e 	bgeu	sp,et,81147430 <altera_avalon_uart_close+0xc>
8114742c:	003b68fa 	trap	3
81147430:	df000215 	stw	fp,8(sp)
81147434:	df000204 	addi	fp,sp,8
81147438:	e13ffe15 	stw	r4,-8(fp)
8114743c:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
81147440:	00000506 	br	81147458 <altera_avalon_uart_close+0x34>
    if (flags & O_NONBLOCK) {
81147444:	e0bfff17 	ldw	r2,-4(fp)
81147448:	1090000c 	andi	r2,r2,16384
8114744c:	10000226 	beq	r2,zero,81147458 <altera_avalon_uart_close+0x34>
      return -EWOULDBLOCK; 
81147450:	00bffd44 	movi	r2,-11
81147454:	00000606 	br	81147470 <altera_avalon_uart_close+0x4c>
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
81147458:	e0bffe17 	ldw	r2,-8(fp)
8114745c:	10c00417 	ldw	r3,16(r2)
81147460:	e0bffe17 	ldw	r2,-8(fp)
81147464:	10800517 	ldw	r2,20(r2)
81147468:	18bff61e 	bne	r3,r2,81147444 <__reset+0xfb127444>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
8114746c:	0005883a 	mov	r2,zero
}
81147470:	e037883a 	mov	sp,fp
81147474:	df000017 	ldw	fp,0(sp)
81147478:	dec00104 	addi	sp,sp,4
8114747c:	f800283a 	ret

81147480 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81147480:	defffe04 	addi	sp,sp,-8
81147484:	de00012e 	bgeu	sp,et,8114748c <alt_get_errno+0xc>
81147488:	003b68fa 	trap	3
8114748c:	dfc00115 	stw	ra,4(sp)
81147490:	df000015 	stw	fp,0(sp)
81147494:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81147498:	d0a01017 	ldw	r2,-32704(gp)
8114749c:	10000326 	beq	r2,zero,811474ac <alt_get_errno+0x2c>
811474a0:	d0a01017 	ldw	r2,-32704(gp)
811474a4:	103ee83a 	callr	r2
811474a8:	00000106 	br	811474b0 <alt_get_errno+0x30>
811474ac:	d0a07804 	addi	r2,gp,-32288
}
811474b0:	e037883a 	mov	sp,fp
811474b4:	dfc00117 	ldw	ra,4(sp)
811474b8:	df000017 	ldw	fp,0(sp)
811474bc:	dec00204 	addi	sp,sp,8
811474c0:	f800283a 	ret

811474c4 <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
811474c4:	deffec04 	addi	sp,sp,-80
811474c8:	de00012e 	bgeu	sp,et,811474d0 <altera_avalon_uart_read+0xc>
811474cc:	003b68fa 	trap	3
811474d0:	dfc01315 	stw	ra,76(sp)
811474d4:	df001215 	stw	fp,72(sp)
811474d8:	df001204 	addi	fp,sp,72
811474dc:	e13ffc15 	stw	r4,-16(fp)
811474e0:	e17ffd15 	stw	r5,-12(fp)
811474e4:	e1bffe15 	stw	r6,-8(fp)
811474e8:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             block;
  alt_u8          read_would_block = 0;
811474ec:	e03fef05 	stb	zero,-68(fp)
  int             count = 0;
811474f0:	e03ff015 	stw	zero,-64(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
811474f4:	e0bfff17 	ldw	r2,-4(fp)
811474f8:	1090000c 	andi	r2,r2,16384
811474fc:	1005003a 	cmpeq	r2,r2,zero
81147500:	10803fcc 	andi	r2,r2,255
81147504:	e0bff115 	stw	r2,-60(fp)
  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */

  ALT_SEM_PEND (sp->read_lock, 0);
81147508:	e0bffc17 	ldw	r2,-16(fp)
8114750c:	10800817 	ldw	r2,32(r2)
81147510:	e0bff815 	stw	r2,-32(fp)
81147514:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
81147518:	e0bff90b 	ldhu	r2,-28(fp)
8114751c:	e0fffb44 	addi	r3,fp,-19
81147520:	180d883a 	mov	r6,r3
81147524:	100b883a 	mov	r5,r2
81147528:	e13ff817 	ldw	r4,-32(fp)
8114752c:	113e4c00 	call	8113e4c0 <OSSemPend>
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
81147530:	00001306 	br	81147580 <altera_avalon_uart_read+0xbc>
    {
      count++;
81147534:	e0bff017 	ldw	r2,-64(fp)
81147538:	10800044 	addi	r2,r2,1
8114753c:	e0bff015 	stw	r2,-64(fp)
      *ptr++ = sp->rx_buf[sp->rx_start];
81147540:	e0bffd17 	ldw	r2,-12(fp)
81147544:	10c00044 	addi	r3,r2,1
81147548:	e0fffd15 	stw	r3,-12(fp)
8114754c:	e0fffc17 	ldw	r3,-16(fp)
81147550:	18c00217 	ldw	r3,8(r3)
81147554:	e13ffc17 	ldw	r4,-16(fp)
81147558:	20c7883a 	add	r3,r4,r3
8114755c:	18c00a04 	addi	r3,r3,40
81147560:	18c00003 	ldbu	r3,0(r3)
81147564:	10c00005 	stb	r3,0(r2)
      
      sp->rx_start = (sp->rx_start+1) & ALT_AVALON_UART_BUF_MSK;
81147568:	e0bffc17 	ldw	r2,-16(fp)
8114756c:	10800217 	ldw	r2,8(r2)
81147570:	10800044 	addi	r2,r2,1
81147574:	10c00fcc 	andi	r3,r2,63
81147578:	e0bffc17 	ldw	r2,-16(fp)
8114757c:	10c00215 	stw	r3,8(r2)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
81147580:	e0fff017 	ldw	r3,-64(fp)
81147584:	e0bffe17 	ldw	r2,-8(fp)
81147588:	1880050e 	bge	r3,r2,811475a0 <altera_avalon_uart_read+0xdc>
8114758c:	e0bffc17 	ldw	r2,-16(fp)
81147590:	10c00217 	ldw	r3,8(r2)
81147594:	e0bffc17 	ldw	r2,-16(fp)
81147598:	10800317 	ldw	r2,12(r2)
8114759c:	18bfe51e 	bne	r3,r2,81147534 <__reset+0xfb127534>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
811475a0:	e0bff017 	ldw	r2,-64(fp)
811475a4:	10003a1e 	bne	r2,zero,81147690 <altera_avalon_uart_read+0x1cc>
811475a8:	e0bffc17 	ldw	r2,-16(fp)
811475ac:	10c00217 	ldw	r3,8(r2)
811475b0:	e0bffc17 	ldw	r2,-16(fp)
811475b4:	10800317 	ldw	r2,12(r2)
811475b8:	1880351e 	bne	r3,r2,81147690 <altera_avalon_uart_read+0x1cc>
    {
      if (!block)
811475bc:	e0bff117 	ldw	r2,-60(fp)
811475c0:	1000071e 	bne	r2,zero,811475e0 <altera_avalon_uart_read+0x11c>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
811475c4:	11474800 	call	81147480 <alt_get_errno>
811475c8:	1007883a 	mov	r3,r2
811475cc:	008002c4 	movi	r2,11
811475d0:	18800015 	stw	r2,0(r3)
        read_would_block = 1;
811475d4:	00800044 	movi	r2,1
811475d8:	e0bfef05 	stb	r2,-68(fp)
        break;
811475dc:	00003006 	br	811476a0 <altera_avalon_uart_read+0x1dc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811475e0:	0005303a 	rdctl	r2,status
811475e4:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811475e8:	e0fff517 	ldw	r3,-44(fp)
811475ec:	00bfff84 	movi	r2,-2
811475f0:	1884703a 	and	r2,r3,r2
811475f4:	1001703a 	wrctl	status,r2
  
  return context;
811475f8:	e0bff517 	ldw	r2,-44(fp)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
811475fc:	e0bff415 	stw	r2,-48(fp)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
81147600:	e0bffc17 	ldw	r2,-16(fp)
81147604:	10800117 	ldw	r2,4(r2)
81147608:	10c02014 	ori	r3,r2,128
8114760c:	e0bffc17 	ldw	r2,-16(fp)
81147610:	10c00115 	stw	r3,4(r2)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81147614:	e0bffc17 	ldw	r2,-16(fp)
81147618:	10800017 	ldw	r2,0(r2)
8114761c:	10800304 	addi	r2,r2,12
81147620:	e0fffc17 	ldw	r3,-16(fp)
81147624:	18c00117 	ldw	r3,4(r3)
81147628:	10c00035 	stwio	r3,0(r2)
8114762c:	e0bff417 	ldw	r2,-48(fp)
81147630:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81147634:	e0bff617 	ldw	r2,-40(fp)
81147638:	1001703a 	wrctl	status,r2
        * flag set in the interrupt service routine. This avoids wasting CPU
        * cycles waiting in this thread, when we could be doing something more 
        * profitable elsewhere.
        */

       ALT_FLAG_PEND (sp->events, 
8114763c:	e0bffc17 	ldw	r2,-16(fp)
81147640:	10800717 	ldw	r2,28(r2)
81147644:	e0bff215 	stw	r2,-56(fp)
81147648:	00800044 	movi	r2,1
8114764c:	e0bff98d 	sth	r2,-26(fp)
81147650:	00bfe0c4 	movi	r2,-125
81147654:	e0bffa05 	stb	r2,-24(fp)
81147658:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
8114765c:	d0a09103 	ldbu	r2,-32188(gp)
81147660:	10803fcc 	andi	r2,r2,255
81147664:	10000a26 	beq	r2,zero,81147690 <altera_avalon_uart_read+0x1cc>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81147668:	e0fff98b 	ldhu	r3,-26(fp)
8114766c:	e13ffa03 	ldbu	r4,-24(fp)
81147670:	e17ffa8b 	ldhu	r5,-22(fp)
81147674:	e0bffb04 	addi	r2,fp,-20
81147678:	d8800015 	stw	r2,0(sp)
8114767c:	280f883a 	mov	r7,r5
81147680:	200d883a 	mov	r6,r4
81147684:	180b883a 	mov	r5,r3
81147688:	e13ff217 	ldw	r4,-56(fp)
8114768c:	113a8200 	call	8113a820 <OSFlagPend>
                      OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                      0);
      }
    }
  }
  while (!count && len);
81147690:	e0bff017 	ldw	r2,-64(fp)
81147694:	1000021e 	bne	r2,zero,811476a0 <altera_avalon_uart_read+0x1dc>
81147698:	e0bffe17 	ldw	r2,-8(fp)
8114769c:	103fb81e 	bne	r2,zero,81147580 <__reset+0xfb127580>
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
811476a0:	e0bffc17 	ldw	r2,-16(fp)
811476a4:	10800817 	ldw	r2,32(r2)
811476a8:	1009883a 	mov	r4,r2
811476ac:	113e8480 	call	8113e848 <OSSemPost>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811476b0:	0005303a 	rdctl	r2,status
811476b4:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811476b8:	e0fff717 	ldw	r3,-36(fp)
811476bc:	00bfff84 	movi	r2,-2
811476c0:	1884703a 	and	r2,r3,r2
811476c4:	1001703a 	wrctl	status,r2
  
  return context;
811476c8:	e0bff717 	ldw	r2,-36(fp)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
811476cc:	e0bff415 	stw	r2,-48(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
811476d0:	e0bffc17 	ldw	r2,-16(fp)
811476d4:	10800117 	ldw	r2,4(r2)
811476d8:	10c02014 	ori	r3,r2,128
811476dc:	e0bffc17 	ldw	r2,-16(fp)
811476e0:	10c00115 	stw	r3,4(r2)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
811476e4:	e0bffc17 	ldw	r2,-16(fp)
811476e8:	10800017 	ldw	r2,0(r2)
811476ec:	10800304 	addi	r2,r2,12
811476f0:	e0fffc17 	ldw	r3,-16(fp)
811476f4:	18c00117 	ldw	r3,4(r3)
811476f8:	10c00035 	stwio	r3,0(r2)
811476fc:	e0bff417 	ldw	r2,-48(fp)
81147700:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81147704:	e0bff317 	ldw	r2,-52(fp)
81147708:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
8114770c:	e0bfef03 	ldbu	r2,-68(fp)
81147710:	10000226 	beq	r2,zero,8114771c <altera_avalon_uart_read+0x258>
    return -EWOULDBLOCK;
81147714:	00bffd44 	movi	r2,-11
81147718:	00000106 	br	81147720 <altera_avalon_uart_read+0x25c>
  }
  else {
    return count;
8114771c:	e0bff017 	ldw	r2,-64(fp)
  }
}
81147720:	e037883a 	mov	sp,fp
81147724:	dfc00117 	ldw	ra,4(sp)
81147728:	df000017 	ldw	fp,0(sp)
8114772c:	dec00204 	addi	sp,sp,8
81147730:	f800283a 	ret

81147734 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81147734:	defffe04 	addi	sp,sp,-8
81147738:	de00012e 	bgeu	sp,et,81147740 <alt_get_errno+0xc>
8114773c:	003b68fa 	trap	3
81147740:	dfc00115 	stw	ra,4(sp)
81147744:	df000015 	stw	fp,0(sp)
81147748:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8114774c:	d0a01017 	ldw	r2,-32704(gp)
81147750:	10000326 	beq	r2,zero,81147760 <alt_get_errno+0x2c>
81147754:	d0a01017 	ldw	r2,-32704(gp)
81147758:	103ee83a 	callr	r2
8114775c:	00000106 	br	81147764 <alt_get_errno+0x30>
81147760:	d0a07804 	addi	r2,gp,-32288
}
81147764:	e037883a 	mov	sp,fp
81147768:	dfc00117 	ldw	ra,4(sp)
8114776c:	df000017 	ldw	fp,0(sp)
81147770:	dec00204 	addi	sp,sp,8
81147774:	f800283a 	ret

81147778 <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
81147778:	deffec04 	addi	sp,sp,-80
8114777c:	de00012e 	bgeu	sp,et,81147784 <altera_avalon_uart_write+0xc>
81147780:	003b68fa 	trap	3
81147784:	dfc01315 	stw	ra,76(sp)
81147788:	df001215 	stw	fp,72(sp)
8114778c:	df001204 	addi	fp,sp,72
81147790:	e13ffc15 	stw	r4,-16(fp)
81147794:	e17ffd15 	stw	r5,-12(fp)
81147798:	e1bffe15 	stw	r6,-8(fp)
8114779c:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
811477a0:	e0bffe17 	ldw	r2,-8(fp)
811477a4:	e0bfef15 	stw	r2,-68(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
811477a8:	e0bfff17 	ldw	r2,-4(fp)
811477ac:	1090000c 	andi	r2,r2,16384
811477b0:	e0bff015 	stw	r2,-64(fp)
  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */

  ALT_SEM_PEND (sp->write_lock, 0);
811477b4:	e0bffc17 	ldw	r2,-16(fp)
811477b8:	10800917 	ldw	r2,36(r2)
811477bc:	e0bff815 	stw	r2,-32(fp)
811477c0:	e03ff90d 	sth	zero,-28(fp)
811477c4:	e0bff90b 	ldhu	r2,-28(fp)
811477c8:	e0fffb44 	addi	r3,fp,-19
811477cc:	180d883a 	mov	r6,r3
811477d0:	100b883a 	mov	r5,r2
811477d4:	e13ff817 	ldw	r4,-32(fp)
811477d8:	113e4c00 	call	8113e4c0 <OSSemPend>
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
811477dc:	00005106 	br	81147924 <altera_avalon_uart_write+0x1ac>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
811477e0:	e0bffc17 	ldw	r2,-16(fp)
811477e4:	10800517 	ldw	r2,20(r2)
811477e8:	10800044 	addi	r2,r2,1
811477ec:	10800fcc 	andi	r2,r2,63
811477f0:	e0bff215 	stw	r2,-56(fp)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
811477f4:	e0bffc17 	ldw	r2,-16(fp)
811477f8:	10c00417 	ldw	r3,16(r2)
811477fc:	e0bff217 	ldw	r2,-56(fp)
81147800:	1880371e 	bne	r3,r2,811478e0 <altera_avalon_uart_write+0x168>
    {
      if (no_block)
81147804:	e0bff017 	ldw	r2,-64(fp)
81147808:	10000526 	beq	r2,zero,81147820 <altera_avalon_uart_write+0xa8>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
8114780c:	11477340 	call	81147734 <alt_get_errno>
81147810:	1007883a 	mov	r3,r2
81147814:	008002c4 	movi	r2,11
81147818:	18800015 	stw	r2,0(r3)
        break;
8114781c:	00004306 	br	8114792c <altera_avalon_uart_write+0x1b4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81147820:	0005303a 	rdctl	r2,status
81147824:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81147828:	e0fff517 	ldw	r3,-44(fp)
8114782c:	00bfff84 	movi	r2,-2
81147830:	1884703a 	and	r2,r3,r2
81147834:	1001703a 	wrctl	status,r2
  
  return context;
81147838:	e0bff517 	ldw	r2,-44(fp)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
8114783c:	e0bff415 	stw	r2,-48(fp)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
81147840:	e0bffc17 	ldw	r2,-16(fp)
81147844:	10800117 	ldw	r2,4(r2)
81147848:	10c11014 	ori	r3,r2,1088
8114784c:	e0bffc17 	ldw	r2,-16(fp)
81147850:	10c00115 	stw	r3,4(r2)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81147854:	e0bffc17 	ldw	r2,-16(fp)
81147858:	10800017 	ldw	r2,0(r2)
8114785c:	10800304 	addi	r2,r2,12
81147860:	e0fffc17 	ldw	r3,-16(fp)
81147864:	18c00117 	ldw	r3,4(r3)
81147868:	10c00035 	stwio	r3,0(r2)
8114786c:	e0bff417 	ldw	r2,-48(fp)
81147870:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81147874:	e0bff117 	ldw	r2,-60(fp)
81147878:	1001703a 	wrctl	status,r2
           * flag set in the interrupt service routine. This avoids wasting CPU
           * cycles waiting in this thread, when we could be doing something
           * more profitable elsewhere.
           */

          ALT_FLAG_PEND (sp->events, 
8114787c:	e0bffc17 	ldw	r2,-16(fp)
81147880:	10800717 	ldw	r2,28(r2)
81147884:	e0bff315 	stw	r2,-52(fp)
81147888:	00800084 	movi	r2,2
8114788c:	e0bff98d 	sth	r2,-26(fp)
81147890:	00bfe0c4 	movi	r2,-125
81147894:	e0bffa05 	stb	r2,-24(fp)
81147898:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
8114789c:	d0a09103 	ldbu	r2,-32188(gp)
811478a0:	10803fcc 	andi	r2,r2,255
811478a4:	10000a26 	beq	r2,zero,811478d0 <altera_avalon_uart_write+0x158>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
811478a8:	e0fff98b 	ldhu	r3,-26(fp)
811478ac:	e13ffa03 	ldbu	r4,-24(fp)
811478b0:	e17ffa8b 	ldhu	r5,-22(fp)
811478b4:	e0bffb04 	addi	r2,fp,-20
811478b8:	d8800015 	stw	r2,0(sp)
811478bc:	280f883a 	mov	r7,r5
811478c0:	200d883a 	mov	r6,r4
811478c4:	180b883a 	mov	r5,r3
811478c8:	e13ff317 	ldw	r4,-52(fp)
811478cc:	113a8200 	call	8113a820 <OSFlagPend>
                         ALT_UART_WRITE_RDY,
                         OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                         0);
        }
        while ((next == sp->tx_start));
811478d0:	e0bffc17 	ldw	r2,-16(fp)
811478d4:	10c00417 	ldw	r3,16(r2)
811478d8:	e0bff217 	ldw	r2,-56(fp)
811478dc:	18bfe726 	beq	r3,r2,8114787c <__reset+0xfb12787c>
      }
    }

    count--;
811478e0:	e0bfef17 	ldw	r2,-68(fp)
811478e4:	10bfffc4 	addi	r2,r2,-1
811478e8:	e0bfef15 	stw	r2,-68(fp)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
811478ec:	e0bffc17 	ldw	r2,-16(fp)
811478f0:	10c00517 	ldw	r3,20(r2)
811478f4:	e0bffd17 	ldw	r2,-12(fp)
811478f8:	11000044 	addi	r4,r2,1
811478fc:	e13ffd15 	stw	r4,-12(fp)
81147900:	10800003 	ldbu	r2,0(r2)
81147904:	1009883a 	mov	r4,r2
81147908:	e0bffc17 	ldw	r2,-16(fp)
8114790c:	10c5883a 	add	r2,r2,r3
81147910:	10801a04 	addi	r2,r2,104
81147914:	11000005 	stb	r4,0(r2)
    sp->tx_end = next;
81147918:	e0bffc17 	ldw	r2,-16(fp)
8114791c:	e0fff217 	ldw	r3,-56(fp)
81147920:	10c00515 	stw	r3,20(r2)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
81147924:	e0bfef17 	ldw	r2,-68(fp)
81147928:	103fad1e 	bne	r2,zero,811477e0 <__reset+0xfb1277e0>
  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);
8114792c:	e0bffc17 	ldw	r2,-16(fp)
81147930:	10800917 	ldw	r2,36(r2)
81147934:	1009883a 	mov	r4,r2
81147938:	113e8480 	call	8113e848 <OSSemPost>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114793c:	0005303a 	rdctl	r2,status
81147940:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81147944:	e0fff717 	ldw	r3,-36(fp)
81147948:	00bfff84 	movi	r2,-2
8114794c:	1884703a 	and	r2,r3,r2
81147950:	1001703a 	wrctl	status,r2
  
  return context;
81147954:	e0bff717 	ldw	r2,-36(fp)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
81147958:	e0bff415 	stw	r2,-48(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
8114795c:	e0bffc17 	ldw	r2,-16(fp)
81147960:	10800117 	ldw	r2,4(r2)
81147964:	10c11014 	ori	r3,r2,1088
81147968:	e0bffc17 	ldw	r2,-16(fp)
8114796c:	10c00115 	stw	r3,4(r2)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81147970:	e0bffc17 	ldw	r2,-16(fp)
81147974:	10800017 	ldw	r2,0(r2)
81147978:	10800304 	addi	r2,r2,12
8114797c:	e0fffc17 	ldw	r3,-16(fp)
81147980:	18c00117 	ldw	r3,4(r3)
81147984:	10c00035 	stwio	r3,0(r2)
81147988:	e0bff417 	ldw	r2,-48(fp)
8114798c:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81147990:	e0bff617 	ldw	r2,-40(fp)
81147994:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
81147998:	e0fffe17 	ldw	r3,-8(fp)
8114799c:	e0bfef17 	ldw	r2,-68(fp)
811479a0:	1885c83a 	sub	r2,r3,r2
}
811479a4:	e037883a 	mov	sp,fp
811479a8:	dfc00117 	ldw	ra,4(sp)
811479ac:	df000017 	ldw	fp,0(sp)
811479b0:	dec00204 	addi	sp,sp,8
811479b4:	f800283a 	ret

811479b8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811479b8:	defffe04 	addi	sp,sp,-8
811479bc:	de00012e 	bgeu	sp,et,811479c4 <alt_get_errno+0xc>
811479c0:	003b68fa 	trap	3
811479c4:	dfc00115 	stw	ra,4(sp)
811479c8:	df000015 	stw	fp,0(sp)
811479cc:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811479d0:	d0a01017 	ldw	r2,-32704(gp)
811479d4:	10000326 	beq	r2,zero,811479e4 <alt_get_errno+0x2c>
811479d8:	d0a01017 	ldw	r2,-32704(gp)
811479dc:	103ee83a 	callr	r2
811479e0:	00000106 	br	811479e8 <alt_get_errno+0x30>
811479e4:	d0a07804 	addi	r2,gp,-32288
}
811479e8:	e037883a 	mov	sp,fp
811479ec:	dfc00117 	ldw	ra,4(sp)
811479f0:	df000017 	ldw	fp,0(sp)
811479f4:	dec00204 	addi	sp,sp,8
811479f8:	f800283a 	ret

811479fc <alt_msgdma_write_standard_descriptor>:
 */
static int alt_msgdma_write_standard_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_standard_descriptor *descriptor)
{
811479fc:	defffc04 	addi	sp,sp,-16
81147a00:	de00012e 	bgeu	sp,et,81147a08 <alt_msgdma_write_standard_descriptor+0xc>
81147a04:	003b68fa 	trap	3
81147a08:	df000315 	stw	fp,12(sp)
81147a0c:	df000304 	addi	fp,sp,12
81147a10:	e13ffd15 	stw	r4,-12(fp)
81147a14:	e17ffe15 	stw	r5,-8(fp)
81147a18:	e1bfff15 	stw	r6,-4(fp)
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
81147a1c:	e0bffd17 	ldw	r2,-12(fp)
81147a20:	10800037 	ldwio	r2,0(r2)
81147a24:	1080010c 	andi	r2,r2,4
81147a28:	10000226 	beq	r2,zero,81147a34 <alt_msgdma_write_standard_descriptor+0x38>
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
		is non-blocking*/
        return -ENOSPC;
81147a2c:	00bff904 	movi	r2,-28
81147a30:	00001506 	br	81147a88 <alt_msgdma_write_standard_descriptor+0x8c>
    }

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base, 
81147a34:	e0bfff17 	ldw	r2,-4(fp)
81147a38:	10800017 	ldw	r2,0(r2)
81147a3c:	1007883a 	mov	r3,r2
81147a40:	e0bffe17 	ldw	r2,-8(fp)
81147a44:	10c00035 	stwio	r3,0(r2)
		(alt_u32)descriptor->read_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base, 
81147a48:	e0bffe17 	ldw	r2,-8(fp)
81147a4c:	10800104 	addi	r2,r2,4
81147a50:	e0ffff17 	ldw	r3,-4(fp)
81147a54:	18c00117 	ldw	r3,4(r3)
81147a58:	10c00035 	stwio	r3,0(r2)
	(	alt_u32)descriptor->write_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base, 
81147a5c:	e0bffe17 	ldw	r2,-8(fp)
81147a60:	10800204 	addi	r2,r2,8
81147a64:	e0ffff17 	ldw	r3,-4(fp)
81147a68:	18c00217 	ldw	r3,8(r3)
81147a6c:	10c00035 	stwio	r3,0(r2)
		descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_STANDARD(descriptor_base, 
81147a70:	e0bffe17 	ldw	r2,-8(fp)
81147a74:	10800304 	addi	r2,r2,12
81147a78:	e0ffff17 	ldw	r3,-4(fp)
81147a7c:	18c00317 	ldw	r3,12(r3)
81147a80:	10c00035 	stwio	r3,0(r2)
		descriptor->control);
        return 0;
81147a84:	0005883a 	mov	r2,zero
}
81147a88:	e037883a 	mov	sp,fp
81147a8c:	df000017 	ldw	fp,0(sp)
81147a90:	dec00104 	addi	sp,sp,4
81147a94:	f800283a 	ret

81147a98 <alt_msgdma_write_extended_descriptor>:
 */
static int alt_msgdma_write_extended_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_extended_descriptor *descriptor)
{
81147a98:	defffc04 	addi	sp,sp,-16
81147a9c:	de00012e 	bgeu	sp,et,81147aa4 <alt_msgdma_write_extended_descriptor+0xc>
81147aa0:	003b68fa 	trap	3
81147aa4:	df000315 	stw	fp,12(sp)
81147aa8:	df000304 	addi	fp,sp,12
81147aac:	e13ffd15 	stw	r4,-12(fp)
81147ab0:	e17ffe15 	stw	r5,-8(fp)
81147ab4:	e1bfff15 	stw	r6,-4(fp)
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
81147ab8:	e0bffd17 	ldw	r2,-12(fp)
81147abc:	10800037 	ldwio	r2,0(r2)
81147ac0:	1080010c 	andi	r2,r2,4
81147ac4:	10000226 	beq	r2,zero,81147ad0 <alt_msgdma_write_extended_descriptor+0x38>
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
	is non-blocking*/
        return -ENOSPC;
81147ac8:	00bff904 	movi	r2,-28
81147acc:	00003b06 	br	81147bbc <alt_msgdma_write_extended_descriptor+0x124>
    }

    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(
81147ad0:	e0bfff17 	ldw	r2,-4(fp)
81147ad4:	10800017 	ldw	r2,0(r2)
81147ad8:	1007883a 	mov	r3,r2
81147adc:	e0bffe17 	ldw	r2,-8(fp)
81147ae0:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	(alt_u32)descriptor->read_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(
81147ae4:	e0bffe17 	ldw	r2,-8(fp)
81147ae8:	10800104 	addi	r2,r2,4
81147aec:	e0ffff17 	ldw	r3,-4(fp)
81147af0:	18c00117 	ldw	r3,4(r3)
81147af4:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
		(alt_u32)descriptor->write_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(
81147af8:	e0bffe17 	ldw	r2,-8(fp)
81147afc:	10800204 	addi	r2,r2,8
81147b00:	e0ffff17 	ldw	r3,-4(fp)
81147b04:	18c00217 	ldw	r3,8(r3)
81147b08:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	descriptor->transfer_length);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(
81147b0c:	e0bffe17 	ldw	r2,-8(fp)
81147b10:	10800304 	addi	r2,r2,12
81147b14:	e0ffff17 	ldw	r3,-4(fp)
81147b18:	18c0030b 	ldhu	r3,12(r3)
81147b1c:	18ffffcc 	andi	r3,r3,65535
81147b20:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->sequence_number);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(
81147b24:	e0bffe17 	ldw	r2,-8(fp)
81147b28:	10800384 	addi	r2,r2,14
81147b2c:	e0ffff17 	ldw	r3,-4(fp)
81147b30:	18c00383 	ldbu	r3,14(r3)
81147b34:	18c03fcc 	andi	r3,r3,255
81147b38:	10c00025 	stbio	r3,0(r2)
		descriptor_base, 
    	descriptor->read_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(
81147b3c:	e0bffe17 	ldw	r2,-8(fp)
81147b40:	108003c4 	addi	r2,r2,15
81147b44:	e0ffff17 	ldw	r3,-4(fp)
81147b48:	18c003c3 	ldbu	r3,15(r3)
81147b4c:	18c03fcc 	andi	r3,r3,255
81147b50:	10c00025 	stbio	r3,0(r2)
		descriptor_base, 
    	descriptor->write_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(
81147b54:	e0bffe17 	ldw	r2,-8(fp)
81147b58:	10800404 	addi	r2,r2,16
81147b5c:	e0ffff17 	ldw	r3,-4(fp)
81147b60:	18c0040b 	ldhu	r3,16(r3)
81147b64:	18ffffcc 	andi	r3,r3,65535
81147b68:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->read_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(
81147b6c:	e0bffe17 	ldw	r2,-8(fp)
81147b70:	10800484 	addi	r2,r2,18
81147b74:	e0ffff17 	ldw	r3,-4(fp)
81147b78:	18c0048b 	ldhu	r3,18(r3)
81147b7c:	18ffffcc 	andi	r3,r3,65535
81147b80:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->write_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base, 0);
81147b84:	e0bffe17 	ldw	r2,-8(fp)
81147b88:	10800504 	addi	r2,r2,20
81147b8c:	0007883a 	mov	r3,zero
81147b90:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base, 0);
81147b94:	e0bffe17 	ldw	r2,-8(fp)
81147b98:	10800604 	addi	r2,r2,24
81147b9c:	0007883a 	mov	r3,zero
81147ba0:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(
81147ba4:	e0bffe17 	ldw	r2,-8(fp)
81147ba8:	10800704 	addi	r2,r2,28
81147bac:	e0ffff17 	ldw	r3,-4(fp)
81147bb0:	18c00717 	ldw	r3,28(r3)
81147bb4:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	descriptor->control);
    return 0;
81147bb8:	0005883a 	mov	r2,zero
}
81147bbc:	e037883a 	mov	sp,fp
81147bc0:	df000017 	ldw	fp,0(sp)
81147bc4:	dec00104 	addi	sp,sp,4
81147bc8:	f800283a 	ret

81147bcc <alt_msgdma_irq>:
 * alt_msgdma_irq()
 *
 * Interrupt handler for the Modular Scatter-Gather DMA controller.
 */
static void alt_msgdma_irq(void *context)
{
81147bcc:	defff804 	addi	sp,sp,-32
81147bd0:	de00012e 	bgeu	sp,et,81147bd8 <alt_msgdma_irq+0xc>
81147bd4:	003b68fa 	trap	3
81147bd8:	dfc00715 	stw	ra,28(sp)
81147bdc:	df000615 	stw	fp,24(sp)
81147be0:	df000604 	addi	fp,sp,24
81147be4:	e13fff15 	stw	r4,-4(fp)
    alt_msgdma_dev *dev = (alt_msgdma_dev *) context;
81147be8:	e0bfff17 	ldw	r2,-4(fp)
81147bec:	e0bffa15 	stw	r2,-24(fp)
    alt_irq_context cpu_sr;
    alt_u32 temporary_control;

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
81147bf0:	e0bffa17 	ldw	r2,-24(fp)
81147bf4:	10801783 	ldbu	r2,94(r2)
81147bf8:	10803fcc 	andi	r2,r2,255
81147bfc:	10001126 	beq	r2,zero,81147c44 <alt_msgdma_irq+0x78>
    {
        temporary_control = 
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
81147c00:	e0bffa17 	ldw	r2,-24(fp)
81147c04:	10800617 	ldw	r2,24(r2)
81147c08:	10800037 	ldwio	r2,0(r2)

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
    {
        temporary_control = 
81147c0c:	1007883a 	mov	r3,r2
81147c10:	00bffdc4 	movi	r2,-9
81147c14:	1884703a 	and	r2,r3,r2
81147c18:	e0bffb15 	stw	r2,-20(fp)
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				& ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
        
        IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
81147c1c:	e0bffa17 	ldw	r2,-24(fp)
81147c20:	10800617 	ldw	r2,24(r2)
81147c24:	e0fffb17 	ldw	r3,-20(fp)
81147c28:	10c00035 	stwio	r3,0(r2)
        		temporary_control);
        
        /* clear the IRQ status- W1C */
        IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base,
81147c2c:	e0bffa17 	ldw	r2,-24(fp)
81147c30:	10800617 	ldw	r2,24(r2)
81147c34:	10800404 	addi	r2,r2,16
81147c38:	00c00044 	movi	r3,1
81147c3c:	10c00035 	stwio	r3,0(r2)
81147c40:	00001106 	br	81147c88 <alt_msgdma_irq+0xbc>
        		ALT_MSGDMA_PREFETCHER_STATUS_IRQ_SET_MASK);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
81147c44:	e0bffa17 	ldw	r2,-24(fp)
81147c48:	10800317 	ldw	r2,12(r2)
81147c4c:	10800104 	addi	r2,r2,4
81147c50:	10800037 	ldwio	r2,0(r2)
81147c54:	1007883a 	mov	r3,r2
81147c58:	00bffbc4 	movi	r2,-17
81147c5c:	1884703a 	and	r2,r3,r2
81147c60:	e0bffb15 	stw	r2,-20(fp)
    			& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
81147c64:	e0bffa17 	ldw	r2,-24(fp)
81147c68:	10800317 	ldw	r2,12(r2)
81147c6c:	10800104 	addi	r2,r2,4
81147c70:	e0fffb17 	ldw	r3,-20(fp)
81147c74:	10c00035 	stwio	r3,0(r2)
    	/* clear the IRQ status */
    	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
81147c78:	e0bffa17 	ldw	r2,-24(fp)
81147c7c:	10800317 	ldw	r2,12(r2)
81147c80:	00c08004 	movi	r3,512
81147c84:	10c00035 	stwio	r3,0(r2)
    * Other interrupts are explicitly disabled if callbacks
    * are registered because there is no guarantee that they are 
    * pre-emption-safe. This allows the driver to support 
    * interrupt pre-emption.
    */
    if(dev->callback) 
81147c88:	e0bffa17 	ldw	r2,-24(fp)
81147c8c:	10800b17 	ldw	r2,44(r2)
81147c90:	10001226 	beq	r2,zero,81147cdc <alt_msgdma_irq+0x110>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81147c94:	0005303a 	rdctl	r2,status
81147c98:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81147c9c:	e0fffd17 	ldw	r3,-12(fp)
81147ca0:	00bfff84 	movi	r2,-2
81147ca4:	1884703a 	and	r2,r3,r2
81147ca8:	1001703a 	wrctl	status,r2
  
  return context;
81147cac:	e0bffd17 	ldw	r2,-12(fp)
    {
        cpu_sr = alt_irq_disable_all();
81147cb0:	e0bffc15 	stw	r2,-16(fp)
        dev->callback (dev->callback_context);
81147cb4:	e0bffa17 	ldw	r2,-24(fp)
81147cb8:	10800b17 	ldw	r2,44(r2)
81147cbc:	e0fffa17 	ldw	r3,-24(fp)
81147cc0:	18c00c17 	ldw	r3,48(r3)
81147cc4:	1809883a 	mov	r4,r3
81147cc8:	103ee83a 	callr	r2
81147ccc:	e0bffc17 	ldw	r2,-16(fp)
81147cd0:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81147cd4:	e0bffe17 	ldw	r2,-8(fp)
81147cd8:	1001703a 	wrctl	status,r2
        alt_irq_enable_all(cpu_sr);
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
81147cdc:	e0bffa17 	ldw	r2,-24(fp)
81147ce0:	10801783 	ldbu	r2,94(r2)
81147ce4:	10803fcc 	andi	r2,r2,255
81147ce8:	10000a26 	beq	r2,zero,81147d14 <alt_msgdma_irq+0x148>
    {
    	temporary_control = 
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
81147cec:	e0bffa17 	ldw	r2,-24(fp)
81147cf0:	10800617 	ldw	r2,24(r2)
81147cf4:	10800037 	ldwio	r2,0(r2)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
81147cf8:	10800214 	ori	r2,r2,8
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
    {
    	temporary_control = 
81147cfc:	e0bffb15 	stw	r2,-20(fp)
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
    	
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
81147d00:	e0bffa17 	ldw	r2,-24(fp)
81147d04:	10800617 	ldw	r2,24(r2)
81147d08:	e0fffb17 	ldw	r3,-20(fp)
81147d0c:	10c00035 	stwio	r3,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
    }

    return;
81147d10:	00000c06 	br	81147d44 <alt_msgdma_irq+0x178>
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
81147d14:	e0bffa17 	ldw	r2,-24(fp)
81147d18:	10800317 	ldw	r2,12(r2)
81147d1c:	10800104 	addi	r2,r2,4
81147d20:	10800037 	ldwio	r2,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
81147d24:	10800414 	ori	r2,r2,16
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
81147d28:	e0bffb15 	stw	r2,-20(fp)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
81147d2c:	e0bffa17 	ldw	r2,-24(fp)
81147d30:	10800317 	ldw	r2,12(r2)
81147d34:	10800104 	addi	r2,r2,4
81147d38:	e0fffb17 	ldw	r3,-20(fp)
81147d3c:	10c00035 	stwio	r3,0(r2)
    }

    return;
81147d40:	0001883a 	nop
}
81147d44:	e037883a 	mov	sp,fp
81147d48:	dfc00117 	ldw	ra,4(sp)
81147d4c:	df000017 	ldw	fp,0(sp)
81147d50:	dec00204 	addi	sp,sp,8
81147d54:	f800283a 	ret

81147d58 <alt_msgdma_construct_standard_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81147d58:	defffb04 	addi	sp,sp,-20
81147d5c:	de00012e 	bgeu	sp,et,81147d64 <alt_msgdma_construct_standard_descriptor+0xc>
81147d60:	003b68fa 	trap	3
81147d64:	df000415 	stw	fp,16(sp)
81147d68:	df000404 	addi	fp,sp,16
81147d6c:	e13ffc15 	stw	r4,-16(fp)
81147d70:	e17ffd15 	stw	r5,-12(fp)
81147d74:	e1bffe15 	stw	r6,-8(fp)
81147d78:	e1ffff15 	stw	r7,-4(fp)
    if(dev->max_byte < length ||
81147d7c:	e0bffc17 	ldw	r2,-16(fp)
81147d80:	10c01217 	ldw	r3,72(r2)
81147d84:	e0800117 	ldw	r2,4(fp)
81147d88:	18800436 	bltu	r3,r2,81147d9c <alt_msgdma_construct_standard_descriptor+0x44>
       dev->enhanced_features != 0
81147d8c:	e0bffc17 	ldw	r2,-16(fp)
81147d90:	10801703 	ldbu	r2,92(r2)
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
81147d94:	10803fcc 	andi	r2,r2,255
81147d98:	10000226 	beq	r2,zero,81147da4 <alt_msgdma_construct_standard_descriptor+0x4c>
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
81147d9c:	00bffa84 	movi	r2,-22
81147da0:	00000e06 	br	81147ddc <alt_msgdma_construct_standard_descriptor+0x84>
    }
    descriptor->read_address = read_address;
81147da4:	e0bffd17 	ldw	r2,-12(fp)
81147da8:	e0fffe17 	ldw	r3,-8(fp)
81147dac:	10c00015 	stw	r3,0(r2)
    descriptor->write_address = write_address;
81147db0:	e0bffd17 	ldw	r2,-12(fp)
81147db4:	e0ffff17 	ldw	r3,-4(fp)
81147db8:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
81147dbc:	e0bffd17 	ldw	r2,-12(fp)
81147dc0:	e0c00117 	ldw	r3,4(fp)
81147dc4:	10c00215 	stw	r3,8(r2)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81147dc8:	e0800217 	ldw	r2,8(fp)
81147dcc:	10e00034 	orhi	r3,r2,32768
81147dd0:	e0bffd17 	ldw	r2,-12(fp)
81147dd4:	10c00315 	stw	r3,12(r2)
    
    return 0;
81147dd8:	0005883a 	mov	r2,zero
}
81147ddc:	e037883a 	mov	sp,fp
81147de0:	df000017 	ldw	fp,0(sp)
81147de4:	dec00104 	addi	sp,sp,4
81147de8:	f800283a 	ret

81147dec <alt_msgdma_construct_extended_descriptor>:
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
81147dec:	defff604 	addi	sp,sp,-40
81147df0:	de00012e 	bgeu	sp,et,81147df8 <alt_msgdma_construct_extended_descriptor+0xc>
81147df4:	003b68fa 	trap	3
81147df8:	df000915 	stw	fp,36(sp)
81147dfc:	df000904 	addi	fp,sp,36
81147e00:	e13ff715 	stw	r4,-36(fp)
81147e04:	e17ff815 	stw	r5,-32(fp)
81147e08:	e1bff915 	stw	r6,-28(fp)
81147e0c:	e1fffa15 	stw	r7,-24(fp)
81147e10:	e1800317 	ldw	r6,12(fp)
81147e14:	e1400417 	ldw	r5,16(fp)
81147e18:	e1000517 	ldw	r4,20(fp)
81147e1c:	e0c00617 	ldw	r3,24(fp)
81147e20:	e0800717 	ldw	r2,28(fp)
81147e24:	e1bffb0d 	sth	r6,-20(fp)
81147e28:	e17ffc05 	stb	r5,-16(fp)
81147e2c:	e13ffd05 	stb	r4,-12(fp)
81147e30:	e0fffe0d 	sth	r3,-8(fp)
81147e34:	e0bfff0d 	sth	r2,-4(fp)
    if(dev->max_byte < length ||
81147e38:	e0bff717 	ldw	r2,-36(fp)
81147e3c:	10c01217 	ldw	r3,72(r2)
81147e40:	e0800117 	ldw	r2,4(fp)
81147e44:	18801936 	bltu	r3,r2,81147eac <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
81147e48:	e13ff717 	ldw	r4,-36(fp)
81147e4c:	20801317 	ldw	r2,76(r4)
81147e50:	20c01417 	ldw	r3,80(r4)
81147e54:	e13ffe0b 	ldhu	r4,-8(fp)
81147e58:	213fffcc 	andi	r4,r4,65535
81147e5c:	2015883a 	mov	r10,r4
81147e60:	0017883a 	mov	r11,zero
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
81147e64:	1ac01136 	bltu	r3,r11,81147eac <alt_msgdma_construct_extended_descriptor+0xc0>
81147e68:	58c0011e 	bne	r11,r3,81147e70 <alt_msgdma_construct_extended_descriptor+0x84>
81147e6c:	12800f36 	bltu	r2,r10,81147eac <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
81147e70:	e13ff717 	ldw	r4,-36(fp)
81147e74:	20801317 	ldw	r2,76(r4)
81147e78:	20c01417 	ldw	r3,80(r4)
81147e7c:	e13fff0b 	ldhu	r4,-4(fp)
81147e80:	213fffcc 	andi	r4,r4,65535
81147e84:	2011883a 	mov	r8,r4
81147e88:	0013883a 	mov	r9,zero
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
81147e8c:	1a400736 	bltu	r3,r9,81147eac <alt_msgdma_construct_extended_descriptor+0xc0>
81147e90:	48c0011e 	bne	r9,r3,81147e98 <alt_msgdma_construct_extended_descriptor+0xac>
81147e94:	12000536 	bltu	r2,r8,81147eac <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
81147e98:	e0bff717 	ldw	r2,-36(fp)
81147e9c:	10801703 	ldbu	r2,92(r2)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
81147ea0:	10803fcc 	andi	r2,r2,255
81147ea4:	10800060 	cmpeqi	r2,r2,1
81147ea8:	1000021e 	bne	r2,zero,81147eb4 <alt_msgdma_construct_extended_descriptor+0xc8>
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
81147eac:	00bffa84 	movi	r2,-22
81147eb0:	00002106 	br	81147f38 <alt_msgdma_construct_extended_descriptor+0x14c>
    }
    
    descriptor->read_address_low = read_address;
81147eb4:	e0bff817 	ldw	r2,-32(fp)
81147eb8:	e0fff917 	ldw	r3,-28(fp)
81147ebc:	10c00015 	stw	r3,0(r2)
    descriptor->write_address_low = write_address;
81147ec0:	e0bff817 	ldw	r2,-32(fp)
81147ec4:	e0fffa17 	ldw	r3,-24(fp)
81147ec8:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
81147ecc:	e0bff817 	ldw	r2,-32(fp)
81147ed0:	e0c00117 	ldw	r3,4(fp)
81147ed4:	10c00215 	stw	r3,8(r2)
    descriptor->sequence_number = sequence_number;
81147ed8:	e0bff817 	ldw	r2,-32(fp)
81147edc:	e0fffb0b 	ldhu	r3,-20(fp)
81147ee0:	10c0030d 	sth	r3,12(r2)
    descriptor->read_burst_count = read_burst_count;
81147ee4:	e0bff817 	ldw	r2,-32(fp)
81147ee8:	e0fffc03 	ldbu	r3,-16(fp)
81147eec:	10c00385 	stb	r3,14(r2)
    descriptor->write_burst_count = write_burst_count;
81147ef0:	e0bff817 	ldw	r2,-32(fp)
81147ef4:	e0fffd03 	ldbu	r3,-12(fp)
81147ef8:	10c003c5 	stb	r3,15(r2)
    descriptor->read_stride = read_stride;
81147efc:	e0bff817 	ldw	r2,-32(fp)
81147f00:	e0fffe0b 	ldhu	r3,-8(fp)
81147f04:	10c0040d 	sth	r3,16(r2)
    descriptor->write_stride = write_stride;
81147f08:	e0bff817 	ldw	r2,-32(fp)
81147f0c:	e0ffff0b 	ldhu	r3,-4(fp)
81147f10:	10c0048d 	sth	r3,18(r2)
    descriptor->read_address_high = NULL;
81147f14:	e0bff817 	ldw	r2,-32(fp)
81147f18:	10000515 	stw	zero,20(r2)
    descriptor->write_address_high = NULL;
81147f1c:	e0bff817 	ldw	r2,-32(fp)
81147f20:	10000615 	stw	zero,24(r2)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81147f24:	e0800217 	ldw	r2,8(fp)
81147f28:	10e00034 	orhi	r3,r2,32768
81147f2c:	e0bff817 	ldw	r2,-32(fp)
81147f30:	10c00715 	stw	r3,28(r2)

  return 0 ;
81147f34:	0005883a 	mov	r2,zero

}
81147f38:	e037883a 	mov	sp,fp
81147f3c:	df000017 	ldw	fp,0(sp)
81147f40:	dec00104 	addi	sp,sp,4
81147f44:	f800283a 	ret

81147f48 <alt_msgdma_descriptor_async_transfer>:
 */
static int alt_msgdma_descriptor_async_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
81147f48:	deffee04 	addi	sp,sp,-72
81147f4c:	de00012e 	bgeu	sp,et,81147f54 <alt_msgdma_descriptor_async_transfer+0xc>
81147f50:	003b68fa 	trap	3
81147f54:	dfc01115 	stw	ra,68(sp)
81147f58:	df001015 	stw	fp,64(sp)
81147f5c:	df001004 	addi	fp,sp,64
81147f60:	e13ffd15 	stw	r4,-12(fp)
81147f64:	e17ffe15 	stw	r5,-8(fp)
81147f68:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 control = 0;
81147f6c:	e03ff115 	stw	zero,-60(fp)
    alt_irq_context context = 0;
81147f70:	e03ff215 	stw	zero,-56(fp)
    alt_u16 counter = 0;
81147f74:	e03ff00d 	sth	zero,-64(fp)
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81147f78:	e0bffd17 	ldw	r2,-12(fp)
81147f7c:	10800317 	ldw	r2,12(r2)
81147f80:	10800204 	addi	r2,r2,8
81147f84:	10800037 	ldwio	r2,0(r2)
	alt_msgdma_extended_descriptor *extended_desc)
{
    alt_u32 control = 0;
    alt_irq_context context = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
81147f88:	10bfffcc 	andi	r2,r2,65535
81147f8c:	e0bff315 	stw	r2,-52(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81147f90:	e0bffd17 	ldw	r2,-12(fp)
81147f94:	10800317 	ldw	r2,12(r2)
81147f98:	10800204 	addi	r2,r2,8
81147f9c:	10800037 	ldwio	r2,0(r2)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
81147fa0:	1004d43a 	srli	r2,r2,16
81147fa4:	e0bff415 	stw	r2,-48(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
81147fa8:	e0bffd17 	ldw	r2,-12(fp)
81147fac:	10800917 	ldw	r2,36(r2)
81147fb0:	e0fff417 	ldw	r3,-48(fp)
81147fb4:	1880042e 	bgeu	r3,r2,81147fc8 <alt_msgdma_descriptor_async_transfer+0x80>
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
81147fb8:	e0bffd17 	ldw	r2,-12(fp)
81147fbc:	10800917 	ldw	r2,36(r2)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
81147fc0:	e0fff317 	ldw	r3,-52(fp)
81147fc4:	18800236 	bltu	r3,r2,81147fd0 <alt_msgdma_descriptor_async_transfer+0x88>
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
	{
		/*at least one write or read FIFO descriptor buffer is full,
		returning so that this function is non-blocking*/
		return -ENOSPC;
81147fc8:	00bff904 	movi	r2,-28
81147fcc:	0000a906 	br	81148274 <alt_msgdma_descriptor_async_transfer+0x32c>
	
	/*
	* When running in a multi threaded environment, obtain the "regs_lock"
	* semaphore. This ensures that accessing registers is thread-safe.
	*/
	ALT_SEM_PEND (dev->regs_lock, 0);
81147fd0:	e0bffd17 	ldw	r2,-12(fp)
81147fd4:	10801817 	ldw	r2,96(r2)
81147fd8:	e0bff615 	stw	r2,-40(fp)
81147fdc:	e03ffc0d 	sth	zero,-16(fp)
81147fe0:	e0bffc0b 	ldhu	r2,-16(fp)
81147fe4:	e0fffc84 	addi	r3,fp,-14
81147fe8:	180d883a 	mov	r6,r3
81147fec:	100b883a 	mov	r5,r2
81147ff0:	e13ff617 	ldw	r4,-40(fp)
81147ff4:	113e4c00 	call	8113e4c0 <OSSemPend>
	
	/* Stop the msgdma dispatcher from issuing more descriptors to the
	read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
81147ff8:	00800804 	movi	r2,32
81147ffc:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81148000:	0005303a 	rdctl	r2,status
81148004:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81148008:	e0fff717 	ldw	r3,-36(fp)
8114800c:	00bfff84 	movi	r2,-2
81148010:	1884703a 	and	r2,r3,r2
81148014:	1001703a 	wrctl	status,r2
  
  return context;
81148018:	e0bff717 	ldw	r2,-36(fp)
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8114801c:	e0bff215 	stw	r2,-56(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81148020:	e0bffd17 	ldw	r2,-12(fp)
81148024:	10800317 	ldw	r2,12(r2)
81148028:	10800104 	addi	r2,r2,4
8114802c:	e0fff117 	ldw	r3,-60(fp)
81148030:	10c00035 	stwio	r3,0(r2)
	/*
	* Clear any (previous) status register information
	* that might occlude our error checking later.
	*/
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
81148034:	e0bffd17 	ldw	r2,-12(fp)
81148038:	10800317 	ldw	r2,12(r2)
8114803c:	e0fffd17 	ldw	r3,-12(fp)
81148040:	18c00317 	ldw	r3,12(r3)
81148044:	18c00037 	ldwio	r3,0(r3)
81148048:	10c00035 	stwio	r3,0(r2)
8114804c:	e0bff217 	ldw	r2,-56(fp)
81148050:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81148054:	e0bffb17 	ldw	r2,-20(fp)
81148058:	1001703a 	wrctl	status,r2
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
8114805c:	e0bffe17 	ldw	r2,-8(fp)
81148060:	10001e26 	beq	r2,zero,811480dc <alt_msgdma_descriptor_async_transfer+0x194>
81148064:	e0bfff17 	ldw	r2,-4(fp)
81148068:	10001c1e 	bne	r2,zero,811480dc <alt_msgdma_descriptor_async_transfer+0x194>
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
8114806c:	00001106 	br	811480b4 <alt_msgdma_descriptor_async_transfer+0x16c>
		dev->csr_base, dev->descriptor_base, standard_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
81148070:	01000044 	movi	r4,1
81148074:	1135c480 	call	81135c48 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81148078:	e0bff00b 	ldhu	r2,-64(fp)
8114807c:	1084e230 	cmpltui	r2,r2,5000
81148080:	1000091e 	bne	r2,zero,811480a8 <alt_msgdma_descriptor_async_transfer+0x160>
            {
                alt_printf("time out after 5 msec while waiting" 
81148084:	01204574 	movhi	r4,33045
81148088:	2102dd04 	addi	r4,r4,2932
8114808c:	114a39c0 	call	8114a39c <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
81148090:	e0bffd17 	ldw	r2,-12(fp)
81148094:	10801817 	ldw	r2,96(r2)
81148098:	1009883a 	mov	r4,r2
8114809c:	113e8480 	call	8113e848 <OSSemPost>
				
                return -ETIME;
811480a0:	00bff084 	movi	r2,-62
811480a4:	00007306 	br	81148274 <alt_msgdma_descriptor_async_transfer+0x32c>
            }
            counter++; 
811480a8:	e0bff00b 	ldhu	r2,-64(fp)
811480ac:	10800044 	addi	r2,r2,1
811480b0:	e0bff00d 	sth	r2,-64(fp)

    if (NULL != standard_desc && NULL == extended_desc)
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
811480b4:	e0bffd17 	ldw	r2,-12(fp)
811480b8:	10c00317 	ldw	r3,12(r2)
811480bc:	e0bffd17 	ldw	r2,-12(fp)
811480c0:	10800417 	ldw	r2,16(r2)
811480c4:	e1bffe17 	ldw	r6,-8(fp)
811480c8:	100b883a 	mov	r5,r2
811480cc:	1809883a 	mov	r4,r3
811480d0:	11479fc0 	call	811479fc <alt_msgdma_write_standard_descriptor>
811480d4:	103fe61e 	bne	r2,zero,81148070 <__reset+0xfb128070>
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
811480d8:	00002706 	br	81148178 <alt_msgdma_descriptor_async_transfer+0x230>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
811480dc:	e0bffe17 	ldw	r2,-8(fp)
811480e0:	10001f1e 	bne	r2,zero,81148160 <alt_msgdma_descriptor_async_transfer+0x218>
811480e4:	e0bfff17 	ldw	r2,-4(fp)
811480e8:	10001d26 	beq	r2,zero,81148160 <alt_msgdma_descriptor_async_transfer+0x218>
    {
        counter = 0; /* reset counter */
811480ec:	e03ff00d 	sth	zero,-64(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
811480f0:	00001106 	br	81148138 <alt_msgdma_descriptor_async_transfer+0x1f0>
		dev->csr_base, 
		dev->descriptor_base, 
		extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
811480f4:	01000044 	movi	r4,1
811480f8:	1135c480 	call	81135c48 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
811480fc:	e0bff00b 	ldhu	r2,-64(fp)
81148100:	1084e230 	cmpltui	r2,r2,5000
81148104:	1000091e 	bne	r2,zero,8114812c <alt_msgdma_descriptor_async_transfer+0x1e4>
            {
                alt_printf("time out after 5 msec while waiting free FIFO buffer" 
81148108:	01204574 	movhi	r4,33045
8114810c:	2102f304 	addi	r4,r4,3020
81148110:	114a39c0 	call	8114a39c <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
81148114:	e0bffd17 	ldw	r2,-12(fp)
81148118:	10801817 	ldw	r2,96(r2)
8114811c:	1009883a 	mov	r4,r2
81148120:	113e8480 	call	8113e848 <OSSemPost>
				
                return -ETIME;
81148124:	00bff084 	movi	r2,-62
81148128:	00005206 	br	81148274 <alt_msgdma_descriptor_async_transfer+0x32c>
            }
            counter++; 
8114812c:	e0bff00b 	ldhu	r2,-64(fp)
81148130:	10800044 	addi	r2,r2,1
81148134:	e0bff00d 	sth	r2,-64(fp)
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
81148138:	e0bffd17 	ldw	r2,-12(fp)
8114813c:	10c00317 	ldw	r3,12(r2)
81148140:	e0bffd17 	ldw	r2,-12(fp)
81148144:	10800417 	ldw	r2,16(r2)
81148148:	e1bfff17 	ldw	r6,-4(fp)
8114814c:	100b883a 	mov	r5,r2
81148150:	1809883a 	mov	r4,r3
81148154:	1147a980 	call	81147a98 <alt_msgdma_write_extended_descriptor>
81148158:	103fe61e 	bne	r2,zero,811480f4 <__reset+0xfb1280f4>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
8114815c:	00000606 	br	81148178 <alt_msgdma_descriptor_async_transfer+0x230>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
81148160:	e0bffd17 	ldw	r2,-12(fp)
81148164:	10801817 	ldw	r2,96(r2)
81148168:	1009883a 	mov	r4,r2
8114816c:	113e8480 	call	8113e848 <OSSemPost>
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
81148170:	00bfffc4 	movi	r2,-1
81148174:	00003f06 	br	81148274 <alt_msgdma_descriptor_async_transfer+0x32c>
    * If a callback routine has been previously registered which will be
    * called from the msgdma ISR. Set up controller to:
    *  - Run
    *  - Stop on an error with any particular descriptor
    */
    if(dev->callback)
81148178:	e0bffd17 	ldw	r2,-12(fp)
8114817c:	10800b17 	ldw	r2,44(r2)
81148180:	10001c26 	beq	r2,zero,811481f4 <alt_msgdma_descriptor_async_transfer+0x2ac>
    {

        control |= (dev->control |
81148184:	e0bffd17 	ldw	r2,-12(fp)
81148188:	10c00d17 	ldw	r3,52(r2)
8114818c:	e0bff117 	ldw	r2,-60(fp)
81148190:	1884b03a 	or	r2,r3,r2
81148194:	10800514 	ori	r2,r2,20
81148198:	e0bff115 	stw	r2,-60(fp)
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
                    ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
        control &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
8114819c:	e0fff117 	ldw	r3,-60(fp)
811481a0:	00bff7c4 	movi	r2,-33
811481a4:	1884703a 	and	r2,r3,r2
811481a8:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811481ac:	0005303a 	rdctl	r2,status
811481b0:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811481b4:	e0fff917 	ldw	r3,-28(fp)
811481b8:	00bfff84 	movi	r2,-2
811481bc:	1884703a 	and	r2,r3,r2
811481c0:	1001703a 	wrctl	status,r2
  
  return context;
811481c4:	e0bff917 	ldw	r2,-28(fp)
    /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all(); 
811481c8:	e0bff215 	stw	r2,-56(fp)
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
811481cc:	e0bffd17 	ldw	r2,-12(fp)
811481d0:	10800317 	ldw	r2,12(r2)
811481d4:	10800104 	addi	r2,r2,4
811481d8:	e0fff117 	ldw	r3,-60(fp)
811481dc:	10c00035 	stwio	r3,0(r2)
811481e0:	e0bff217 	ldw	r2,-56(fp)
811481e4:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811481e8:	e0bff517 	ldw	r2,-44(fp)
811481ec:	1001703a 	wrctl	status,r2
811481f0:	00001b06 	br	81148260 <alt_msgdma_descriptor_async_transfer+0x318>
    *   - Stop on an error with any particular descriptor
    *   - Disable interrupt generation
    */
    else
    {
        control |= (dev->control |
811481f4:	e0bffd17 	ldw	r2,-12(fp)
811481f8:	10c00d17 	ldw	r3,52(r2)
811481fc:	e0bff117 	ldw	r2,-60(fp)
81148200:	1884b03a 	or	r2,r3,r2
81148204:	10800114 	ori	r2,r2,4
81148208:	e0bff115 	stw	r2,-60(fp)
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK );
        control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
8114820c:	e0fff117 	ldw	r3,-60(fp)
81148210:	00bff3c4 	movi	r2,-49
81148214:	1884703a 	and	r2,r3,r2
81148218:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114821c:	0005303a 	rdctl	r2,status
81148220:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81148224:	e0fffa17 	ldw	r3,-24(fp)
81148228:	00bfff84 	movi	r2,-2
8114822c:	1884703a 	and	r2,r3,r2
81148230:	1001703a 	wrctl	status,r2
  
  return context;
81148234:	e0bffa17 	ldw	r2,-24(fp)
                   (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
        /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all();
81148238:	e0bff215 	stw	r2,-56(fp)
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8114823c:	e0bffd17 	ldw	r2,-12(fp)
81148240:	10800317 	ldw	r2,12(r2)
81148244:	10800104 	addi	r2,r2,4
81148248:	e0fff117 	ldw	r3,-60(fp)
8114824c:	10c00035 	stwio	r3,0(r2)
81148250:	e0bff217 	ldw	r2,-56(fp)
81148254:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81148258:	e0bff817 	ldw	r2,-32(fp)
8114825c:	1001703a 	wrctl	status,r2

    /*
	 * Now that access to the registers is complete, release the registers
     * semaphore so that other threads can access the registers.
     */
    ALT_SEM_POST (dev->regs_lock);
81148260:	e0bffd17 	ldw	r2,-12(fp)
81148264:	10801817 	ldw	r2,96(r2)
81148268:	1009883a 	mov	r4,r2
8114826c:	113e8480 	call	8113e848 <OSSemPost>
    
    return 0;
81148270:	0005883a 	mov	r2,zero
}
81148274:	e037883a 	mov	sp,fp
81148278:	dfc00117 	ldw	ra,4(sp)
8114827c:	df000017 	ldw	fp,0(sp)
81148280:	dec00204 	addi	sp,sp,8
81148284:	f800283a 	ret

81148288 <alt_msgdma_descriptor_sync_transfer>:
 */
static int alt_msgdma_descriptor_sync_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
81148288:	deffee04 	addi	sp,sp,-72
8114828c:	de00012e 	bgeu	sp,et,81148294 <alt_msgdma_descriptor_sync_transfer+0xc>
81148290:	003b68fa 	trap	3
81148294:	dfc01115 	stw	ra,68(sp)
81148298:	df001015 	stw	fp,64(sp)
8114829c:	df001004 	addi	fp,sp,64
811482a0:	e13ffd15 	stw	r4,-12(fp)
811482a4:	e17ffe15 	stw	r5,-8(fp)
811482a8:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 control=0;
811482ac:	e03ff415 	stw	zero,-48(fp)
    alt_irq_context context=0;
811482b0:	e03ff515 	stw	zero,-44(fp)
    alt_u32 csr_status = 0;
811482b4:	e03ff015 	stw	zero,-64(fp)
    alt_u16 counter = 0;
811482b8:	e03ff10d 	sth	zero,-60(fp)
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
811482bc:	e0bffd17 	ldw	r2,-12(fp)
811482c0:	10800317 	ldw	r2,12(r2)
811482c4:	10800204 	addi	r2,r2,8
811482c8:	10800037 	ldwio	r2,0(r2)
{
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
811482cc:	10bfffcc 	andi	r2,r2,65535
811482d0:	e0bff215 	stw	r2,-56(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
811482d4:	e0bffd17 	ldw	r2,-12(fp)
811482d8:	10800317 	ldw	r2,12(r2)
811482dc:	10800204 	addi	r2,r2,8
811482e0:	10800037 	ldwio	r2,0(r2)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
811482e4:	1004d43a 	srli	r2,r2,16
811482e8:	e0bff315 	stw	r2,-52(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;
    alt_u32 error = ALTERA_MSGDMA_CSR_STOPPED_ON_ERROR_MASK | 
811482ec:	00807804 	movi	r2,480
811482f0:	e0bff615 	stw	r2,-40(fp)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
811482f4:	00001906 	br	8114835c <alt_msgdma_descriptor_sync_transfer+0xd4>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
    { 
        alt_busy_sleep(1); /* delay 1us */
811482f8:	01000044 	movi	r4,1
811482fc:	1135c480 	call	81135c48 <alt_busy_sleep>
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81148300:	e0bff10b 	ldhu	r2,-60(fp)
81148304:	1084e230 	cmpltui	r2,r2,5000
81148308:	1000051e 	bne	r2,zero,81148320 <alt_msgdma_descriptor_sync_transfer+0x98>
        {
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
8114830c:	01204574 	movhi	r4,33045
81148310:	21030904 	addi	r4,r4,3108
81148314:	114a39c0 	call	8114a39c <alt_printf>
				" for storing descriptor\n");
            return -ETIME;
81148318:	00bff084 	movi	r2,-62
8114831c:	0000d706 	br	8114867c <alt_msgdma_descriptor_sync_transfer+0x3f4>
        }
        counter++;  
81148320:	e0bff10b 	ldhu	r2,-60(fp)
81148324:	10800044 	addi	r2,r2,1
81148328:	e0bff10d 	sth	r2,-60(fp)
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
8114832c:	e0bffd17 	ldw	r2,-12(fp)
81148330:	10800317 	ldw	r2,12(r2)
81148334:	10800204 	addi	r2,r2,8
81148338:	10800037 	ldwio	r2,0(r2)
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
				" for storing descriptor\n");
            return -ETIME;
        }
        counter++;  
        fifo_read_fill_level = (
8114833c:	10bfffcc 	andi	r2,r2,65535
81148340:	e0bff215 	stw	r2,-56(fp)
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81148344:	e0bffd17 	ldw	r2,-12(fp)
81148348:	10800317 	ldw	r2,12(r2)
8114834c:	10800204 	addi	r2,r2,8
81148350:	10800037 	ldwio	r2,0(r2)
        counter++;  
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
81148354:	1004d43a 	srli	r2,r2,16
81148358:	e0bff315 	stw	r2,-52(fp)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
8114835c:	e0bffd17 	ldw	r2,-12(fp)
81148360:	10800917 	ldw	r2,36(r2)
81148364:	e0fff317 	ldw	r3,-52(fp)
81148368:	18bfe32e 	bgeu	r3,r2,811482f8 <__reset+0xfb1282f8>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
8114836c:	e0bffd17 	ldw	r2,-12(fp)
81148370:	10800917 	ldw	r2,36(r2)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
81148374:	e0fff217 	ldw	r3,-56(fp)
81148378:	18bfdf2e 	bgeu	r3,r2,811482f8 <__reset+0xfb1282f8>

     /*
     * When running in a multi threaded environment, obtain the "regs_lock"
     * semaphore. This ensures that accessing registers is thread-safe.
     */
	ALT_SEM_PEND (dev->regs_lock, 0);
8114837c:	e0bffd17 	ldw	r2,-12(fp)
81148380:	10801817 	ldw	r2,96(r2)
81148384:	e0bff815 	stw	r2,-32(fp)
81148388:	e03ffc0d 	sth	zero,-16(fp)
8114838c:	e0bffc0b 	ldhu	r2,-16(fp)
81148390:	e0fffc84 	addi	r3,fp,-14
81148394:	180d883a 	mov	r6,r3
81148398:	100b883a 	mov	r5,r2
8114839c:	e13ff817 	ldw	r4,-32(fp)
811483a0:	113e4c00 	call	8113e4c0 <OSSemPend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811483a4:	0005303a 	rdctl	r2,status
811483a8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811483ac:	e0fffb17 	ldw	r3,-20(fp)
811483b0:	00bfff84 	movi	r2,-2
811483b4:	1884703a 	and	r2,r3,r2
811483b8:	1001703a 	wrctl	status,r2
  
  return context;
811483bc:	e0bffb17 	ldw	r2,-20(fp)
    
    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();
811483c0:	e0bff515 	stw	r2,-44(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
811483c4:	e0bffd17 	ldw	r2,-12(fp)
811483c8:	10800317 	ldw	r2,12(r2)
811483cc:	10800104 	addi	r2,r2,4
811483d0:	00c00804 	movi	r3,32
811483d4:	10c00035 	stwio	r3,0(r2)
        ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
811483d8:	e0bffd17 	ldw	r2,-12(fp)
811483dc:	10800317 	ldw	r2,12(r2)
811483e0:	e0fffd17 	ldw	r3,-12(fp)
811483e4:	18c00317 	ldw	r3,12(r3)
811483e8:	18c00037 	ldwio	r3,0(r3)
811483ec:	10c00035 	stwio	r3,0(r2)
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
811483f0:	e0bffe17 	ldw	r2,-8(fp)
811483f4:	10001f26 	beq	r2,zero,81148474 <alt_msgdma_descriptor_sync_transfer+0x1ec>
811483f8:	e0bfff17 	ldw	r2,-4(fp)
811483fc:	10001d1e 	bne	r2,zero,81148474 <alt_msgdma_descriptor_sync_transfer+0x1ec>
    {
        counter = 0; /* reset counter */
81148400:	e03ff10d 	sth	zero,-60(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
81148404:	00001106 	br	8114844c <alt_msgdma_descriptor_sync_transfer+0x1c4>
			dev->csr_base, dev->descriptor_base, standard_desc))
        {     
            alt_busy_sleep(1); /* delay 1us */
81148408:	01000044 	movi	r4,1
8114840c:	1135c480 	call	81135c48 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81148410:	e0bff10b 	ldhu	r2,-60(fp)
81148414:	1084e230 	cmpltui	r2,r2,5000
81148418:	1000091e 	bne	r2,zero,81148440 <alt_msgdma_descriptor_sync_transfer+0x1b8>
            {
                alt_printf("time out after 5 msec while writing standard" 
8114841c:	01204574 	movhi	r4,33045
81148420:	21031d04 	addi	r4,r4,3188
81148424:	114a39c0 	call	8114a39c <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
81148428:	e0bffd17 	ldw	r2,-12(fp)
8114842c:	10801817 	ldw	r2,96(r2)
81148430:	1009883a 	mov	r4,r2
81148434:	113e8480 	call	8113e848 <OSSemPost>
				
                return -ETIME;
81148438:	00bff084 	movi	r2,-62
8114843c:	00008f06 	br	8114867c <alt_msgdma_descriptor_sync_transfer+0x3f4>
            }
            counter++;    
81148440:	e0bff10b 	ldhu	r2,-60(fp)
81148444:	10800044 	addi	r2,r2,1
81148448:	e0bff10d 	sth	r2,-60(fp)
    if (NULL != standard_desc && NULL == extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
8114844c:	e0bffd17 	ldw	r2,-12(fp)
81148450:	10c00317 	ldw	r3,12(r2)
81148454:	e0bffd17 	ldw	r2,-12(fp)
81148458:	10800417 	ldw	r2,16(r2)
8114845c:	e1bffe17 	ldw	r6,-8(fp)
81148460:	100b883a 	mov	r5,r2
81148464:	1809883a 	mov	r4,r3
81148468:	11479fc0 	call	811479fc <alt_msgdma_write_standard_descriptor>
8114846c:	103fe61e 	bne	r2,zero,81148408 <__reset+0xfb128408>
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
81148470:	00002706 	br	81148510 <alt_msgdma_descriptor_sync_transfer+0x288>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
81148474:	e0bffe17 	ldw	r2,-8(fp)
81148478:	10001f1e 	bne	r2,zero,811484f8 <alt_msgdma_descriptor_sync_transfer+0x270>
8114847c:	e0bfff17 	ldw	r2,-4(fp)
81148480:	10001d26 	beq	r2,zero,811484f8 <alt_msgdma_descriptor_sync_transfer+0x270>
    {
        counter = 0; /* reset counter */
81148484:	e03ff10d 	sth	zero,-60(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
81148488:	00001106 	br	811484d0 <alt_msgdma_descriptor_sync_transfer+0x248>
			dev->csr_base, dev->descriptor_base, extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
8114848c:	01000044 	movi	r4,1
81148490:	1135c480 	call	81135c48 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81148494:	e0bff10b 	ldhu	r2,-60(fp)
81148498:	1084e230 	cmpltui	r2,r2,5000
8114849c:	1000091e 	bne	r2,zero,811484c4 <alt_msgdma_descriptor_sync_transfer+0x23c>
            {
                alt_printf("time out after 5 msec while writing extended" 
811484a0:	01204574 	movhi	r4,33045
811484a4:	21032e04 	addi	r4,r4,3256
811484a8:	114a39c0 	call	8114a39c <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
811484ac:	e0bffd17 	ldw	r2,-12(fp)
811484b0:	10801817 	ldw	r2,96(r2)
811484b4:	1009883a 	mov	r4,r2
811484b8:	113e8480 	call	8113e848 <OSSemPost>
				
                return -ETIME;
811484bc:	00bff084 	movi	r2,-62
811484c0:	00006e06 	br	8114867c <alt_msgdma_descriptor_sync_transfer+0x3f4>
            }
            counter++;
811484c4:	e0bff10b 	ldhu	r2,-60(fp)
811484c8:	10800044 	addi	r2,r2,1
811484cc:	e0bff10d 	sth	r2,-60(fp)
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
811484d0:	e0bffd17 	ldw	r2,-12(fp)
811484d4:	10c00317 	ldw	r3,12(r2)
811484d8:	e0bffd17 	ldw	r2,-12(fp)
811484dc:	10800417 	ldw	r2,16(r2)
811484e0:	e1bfff17 	ldw	r6,-4(fp)
811484e4:	100b883a 	mov	r5,r2
811484e8:	1809883a 	mov	r4,r3
811484ec:	1147a980 	call	81147a98 <alt_msgdma_write_extended_descriptor>
811484f0:	103fe61e 	bne	r2,zero,8114848c <__reset+0xfb12848c>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
811484f4:	00000606 	br	81148510 <alt_msgdma_descriptor_sync_transfer+0x288>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
811484f8:	e0bffd17 	ldw	r2,-12(fp)
811484fc:	10801817 	ldw	r2,96(r2)
81148500:	1009883a 	mov	r4,r2
81148504:	113e8480 	call	8113e848 <OSSemPost>
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
81148508:	00bfffc4 	movi	r2,-1
8114850c:	00005b06 	br	8114867c <alt_msgdma_descriptor_sync_transfer+0x3f4>
    * Set up msgdma controller to:
    * - Disable interrupt generation
    * - Run once a valid descriptor is written to controller
    * - Stop on an error with any particular descriptor
    */
     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
81148510:	e0bffd17 	ldw	r2,-12(fp)
81148514:	10800317 	ldw	r2,12(r2)
81148518:	10800104 	addi	r2,r2,4
8114851c:	e0fffd17 	ldw	r3,-12(fp)
81148520:	19000d17 	ldw	r4,52(r3)
81148524:	00fff2c4 	movi	r3,-53
81148528:	20c6703a 	and	r3,r4,r3
8114852c:	18c00114 	ori	r3,r3,4
81148530:	10c00035 	stwio	r3,0(r2)
81148534:	e0bff517 	ldw	r2,-44(fp)
81148538:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114853c:	e0bff717 	ldw	r2,-36(fp)
81148540:	1001703a 	wrctl	status,r2
		(~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
		(~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK)) ;
	 
	alt_irq_enable_all(context);
     
    counter = 0; /* reset counter */ 
81148544:	e03ff10d 	sth	zero,-60(fp)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
81148548:	e0bffd17 	ldw	r2,-12(fp)
8114854c:	10800317 	ldw	r2,12(r2)
81148550:	10800037 	ldwio	r2,0(r2)
81148554:	e0bff015 	stw	r2,-64(fp)
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
81148558:	00001506 	br	811485b0 <alt_msgdma_descriptor_sync_transfer+0x328>
    {
        alt_busy_sleep(1); /* delay 1us */
8114855c:	01000044 	movi	r4,1
81148560:	1135c480 	call	81135c48 <alt_busy_sleep>
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81148564:	e0bff10b 	ldhu	r2,-60(fp)
81148568:	1084e230 	cmpltui	r2,r2,5000
8114856c:	1000091e 	bne	r2,zero,81148594 <alt_msgdma_descriptor_sync_transfer+0x30c>
        {
            alt_printf("time out after 5 msec while waiting for any pending" 
81148570:	01204574 	movhi	r4,33045
81148574:	21033f04 	addi	r4,r4,3324
81148578:	114a39c0 	call	8114a39c <alt_printf>
			
			/*
			* Now that access to the registers is complete, release the registers
			* semaphore so that other threads can access the registers.
			*/
			ALT_SEM_POST (dev->regs_lock);
8114857c:	e0bffd17 	ldw	r2,-12(fp)
81148580:	10801817 	ldw	r2,96(r2)
81148584:	1009883a 	mov	r4,r2
81148588:	113e8480 	call	8113e848 <OSSemPost>
			
            return -ETIME;
8114858c:	00bff084 	movi	r2,-62
81148590:	00003a06 	br	8114867c <alt_msgdma_descriptor_sync_transfer+0x3f4>
        }
        counter++;
81148594:	e0bff10b 	ldhu	r2,-60(fp)
81148598:	10800044 	addi	r2,r2,1
8114859c:	e0bff10d 	sth	r2,-60(fp)
        csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
811485a0:	e0bffd17 	ldw	r2,-12(fp)
811485a4:	10800317 	ldw	r2,12(r2)
811485a8:	10800037 	ldwio	r2,0(r2)
811485ac:	e0bff015 	stw	r2,-64(fp)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
811485b0:	e0fff017 	ldw	r3,-64(fp)
811485b4:	e0bff617 	ldw	r2,-40(fp)
811485b8:	1884703a 	and	r2,r3,r2
811485bc:	1000031e 	bne	r2,zero,811485cc <alt_msgdma_descriptor_sync_transfer+0x344>
811485c0:	e0bff017 	ldw	r2,-64(fp)
811485c4:	1080004c 	andi	r2,r2,1
811485c8:	103fe41e 	bne	r2,zero,8114855c <__reset+0xfb12855c>
    }
    

    /*Errors or conditions causing the dispatcher stopping issuing read/write 
      commands to masters*/
    if(0 != (csr_status & error))
811485cc:	e0fff017 	ldw	r3,-64(fp)
811485d0:	e0bff617 	ldw	r2,-40(fp)
811485d4:	1884703a 	and	r2,r3,r2
811485d8:	10000626 	beq	r2,zero,811485f4 <alt_msgdma_descriptor_sync_transfer+0x36c>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
811485dc:	e0bffd17 	ldw	r2,-12(fp)
811485e0:	10801817 	ldw	r2,96(r2)
811485e4:	1009883a 	mov	r4,r2
811485e8:	113e8480 	call	8113e848 <OSSemPost>
		
        return error;
811485ec:	e0bff617 	ldw	r2,-40(fp)
811485f0:	00002206 	br	8114867c <alt_msgdma_descriptor_sync_transfer+0x3f4>
    }

    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* stop issuing more descriptors */
    control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) | 
811485f4:	e0bffd17 	ldw	r2,-12(fp)
811485f8:	10800317 	ldw	r2,12(r2)
811485fc:	10800104 	addi	r2,r2,4
81148600:	10800037 	ldwio	r2,0(r2)
81148604:	10800814 	ori	r2,r2,32
81148608:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114860c:	0005303a 	rdctl	r2,status
81148610:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81148614:	e0fffa17 	ldw	r3,-24(fp)
81148618:	00bfff84 	movi	r2,-2
8114861c:	1884703a 	and	r2,r3,r2
81148620:	1001703a 	wrctl	status,r2
  
  return context;
81148624:	e0bffa17 	ldw	r2,-24(fp)
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();  
81148628:	e0bff515 	stw	r2,-44(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8114862c:	e0bffd17 	ldw	r2,-12(fp)
81148630:	10800317 	ldw	r2,12(r2)
81148634:	10800104 	addi	r2,r2,4
81148638:	e0fff417 	ldw	r3,-48(fp)
8114863c:	10c00035 	stwio	r3,0(r2)
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
81148640:	e0bffd17 	ldw	r2,-12(fp)
81148644:	10800317 	ldw	r2,12(r2)
81148648:	e0fffd17 	ldw	r3,-12(fp)
8114864c:	18c00317 	ldw	r3,12(r3)
81148650:	18c00037 	ldwio	r3,0(r3)
81148654:	10c00035 	stwio	r3,0(r2)
81148658:	e0bff517 	ldw	r2,-44(fp)
8114865c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81148660:	e0bff917 	ldw	r2,-28(fp)
81148664:	1001703a 	wrctl	status,r2

	/*
	* Now that access to the registers is complete, release the registers
	* semaphore so that other threads can access the registers.
	*/
    ALT_SEM_POST (dev->regs_lock);
81148668:	e0bffd17 	ldw	r2,-12(fp)
8114866c:	10801817 	ldw	r2,96(r2)
81148670:	1009883a 	mov	r4,r2
81148674:	113e8480 	call	8113e848 <OSSemPost>
    
    return 0;
81148678:	0005883a 	mov	r2,zero

}
8114867c:	e037883a 	mov	sp,fp
81148680:	dfc00117 	ldw	ra,4(sp)
81148684:	df000017 	ldw	fp,0(sp)
81148688:	dec00204 	addi	sp,sp,8
8114868c:	f800283a 	ret

81148690 <alt_msgdma_construct_standard_st_to_mm_descriptor>:
 */
int alt_msgdma_construct_standard_st_to_mm_descriptor (
    alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *write_address, alt_u32 length, alt_u32 control)
{
81148690:	defff804 	addi	sp,sp,-32
81148694:	de00012e 	bgeu	sp,et,8114869c <alt_msgdma_construct_standard_st_to_mm_descriptor+0xc>
81148698:	003b68fa 	trap	3
8114869c:	dfc00715 	stw	ra,28(sp)
811486a0:	df000615 	stw	fp,24(sp)
811486a4:	df000604 	addi	fp,sp,24
811486a8:	e13ffc15 	stw	r4,-16(fp)
811486ac:	e17ffd15 	stw	r5,-12(fp)
811486b0:	e1bffe15 	stw	r6,-8(fp)
811486b4:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, NULL, 
811486b8:	e0800217 	ldw	r2,8(fp)
811486bc:	d8800115 	stw	r2,4(sp)
811486c0:	e0bfff17 	ldw	r2,-4(fp)
811486c4:	d8800015 	stw	r2,0(sp)
811486c8:	e1fffe17 	ldw	r7,-8(fp)
811486cc:	000d883a 	mov	r6,zero
811486d0:	e17ffd17 	ldw	r5,-12(fp)
811486d4:	e13ffc17 	ldw	r4,-16(fp)
811486d8:	1147d580 	call	81147d58 <alt_msgdma_construct_standard_descriptor>
            write_address, length, control);
}
811486dc:	e037883a 	mov	sp,fp
811486e0:	dfc00117 	ldw	ra,4(sp)
811486e4:	df000017 	ldw	fp,0(sp)
811486e8:	dec00204 	addi	sp,sp,8
811486ec:	f800283a 	ret

811486f0 <alt_msgdma_construct_standard_mm_to_st_descriptor>:
    alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address,
	alt_u32 length,
	alt_u32 control)
{
811486f0:	defff804 	addi	sp,sp,-32
811486f4:	de00012e 	bgeu	sp,et,811486fc <alt_msgdma_construct_standard_mm_to_st_descriptor+0xc>
811486f8:	003b68fa 	trap	3
811486fc:	dfc00715 	stw	ra,28(sp)
81148700:	df000615 	stw	fp,24(sp)
81148704:	df000604 	addi	fp,sp,24
81148708:	e13ffc15 	stw	r4,-16(fp)
8114870c:	e17ffd15 	stw	r5,-12(fp)
81148710:	e1bffe15 	stw	r6,-8(fp)
81148714:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
81148718:	e0800217 	ldw	r2,8(fp)
8114871c:	d8800115 	stw	r2,4(sp)
81148720:	e0bfff17 	ldw	r2,-4(fp)
81148724:	d8800015 	stw	r2,0(sp)
81148728:	000f883a 	mov	r7,zero
8114872c:	e1bffe17 	ldw	r6,-8(fp)
81148730:	e17ffd17 	ldw	r5,-12(fp)
81148734:	e13ffc17 	ldw	r4,-16(fp)
81148738:	1147d580 	call	81147d58 <alt_msgdma_construct_standard_descriptor>
            NULL, length, control);

}
8114873c:	e037883a 	mov	sp,fp
81148740:	dfc00117 	ldw	ra,4(sp)
81148744:	df000017 	ldw	fp,0(sp)
81148748:	dec00204 	addi	sp,sp,8
8114874c:	f800283a 	ret

81148750 <alt_msgdma_construct_standard_mm_to_mm_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81148750:	defff804 	addi	sp,sp,-32
81148754:	de00012e 	bgeu	sp,et,8114875c <alt_msgdma_construct_standard_mm_to_mm_descriptor+0xc>
81148758:	003b68fa 	trap	3
8114875c:	dfc00715 	stw	ra,28(sp)
81148760:	df000615 	stw	fp,24(sp)
81148764:	df000604 	addi	fp,sp,24
81148768:	e13ffc15 	stw	r4,-16(fp)
8114876c:	e17ffd15 	stw	r5,-12(fp)
81148770:	e1bffe15 	stw	r6,-8(fp)
81148774:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
81148778:	e0800317 	ldw	r2,12(fp)
8114877c:	d8800115 	stw	r2,4(sp)
81148780:	e0800217 	ldw	r2,8(fp)
81148784:	d8800015 	stw	r2,0(sp)
81148788:	e1ffff17 	ldw	r7,-4(fp)
8114878c:	e1bffe17 	ldw	r6,-8(fp)
81148790:	e17ffd17 	ldw	r5,-12(fp)
81148794:	e13ffc17 	ldw	r4,-16(fp)
81148798:	1147d580 	call	81147d58 <alt_msgdma_construct_standard_descriptor>
            write_address, length, control);
}
8114879c:	e037883a 	mov	sp,fp
811487a0:	dfc00117 	ldw	ra,4(sp)
811487a4:	df000017 	ldw	fp,0(sp)
811487a8:	dec00204 	addi	sp,sp,8
811487ac:	f800283a 	ret

811487b0 <alt_msgdma_construct_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 write_burst_count, 
	alt_u16 write_stride)
{
811487b0:	defff004 	addi	sp,sp,-64
811487b4:	de00012e 	bgeu	sp,et,811487bc <alt_msgdma_construct_extended_st_to_mm_descriptor+0xc>
811487b8:	003b68fa 	trap	3
811487bc:	dfc00f15 	stw	ra,60(sp)
811487c0:	df000e15 	stw	fp,56(sp)
811487c4:	df000e04 	addi	fp,sp,56
811487c8:	e13ff915 	stw	r4,-28(fp)
811487cc:	e17ffa15 	stw	r5,-24(fp)
811487d0:	e1bffb15 	stw	r6,-20(fp)
811487d4:	e1fffc15 	stw	r7,-16(fp)
811487d8:	e1000317 	ldw	r4,12(fp)
811487dc:	e0c00417 	ldw	r3,16(fp)
811487e0:	e0800517 	ldw	r2,20(fp)
811487e4:	e13ffd0d 	sth	r4,-12(fp)
811487e8:	e0fffe05 	stb	r3,-8(fp)
811487ec:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
811487f0:	e0bffd0b 	ldhu	r2,-12(fp)
811487f4:	e0fffe03 	ldbu	r3,-8(fp)
811487f8:	e13fff0b 	ldhu	r4,-4(fp)
811487fc:	d9000615 	stw	r4,24(sp)
81148800:	d8000515 	stw	zero,20(sp)
81148804:	d8c00415 	stw	r3,16(sp)
81148808:	d8000315 	stw	zero,12(sp)
8114880c:	d8800215 	stw	r2,8(sp)
81148810:	e0800217 	ldw	r2,8(fp)
81148814:	d8800115 	stw	r2,4(sp)
81148818:	e0bffc17 	ldw	r2,-16(fp)
8114881c:	d8800015 	stw	r2,0(sp)
81148820:	e1fffb17 	ldw	r7,-20(fp)
81148824:	000d883a 	mov	r6,zero
81148828:	e17ffa17 	ldw	r5,-24(fp)
8114882c:	e13ff917 	ldw	r4,-28(fp)
81148830:	1147dec0 	call	81147dec <alt_msgdma_construct_extended_descriptor>
            NULL, write_address, length, control, sequence_number, 0, 
            write_burst_count, 0, write_stride);
}
81148834:	e037883a 	mov	sp,fp
81148838:	dfc00117 	ldw	ra,4(sp)
8114883c:	df000017 	ldw	fp,0(sp)
81148840:	dec00204 	addi	sp,sp,8
81148844:	f800283a 	ret

81148848 <alt_msgdma_construct_extended_mm_to_st_descriptor>:
	alt_u32 length,
	alt_u32 control,
	alt_u16 sequence_number,
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
81148848:	defff004 	addi	sp,sp,-64
8114884c:	de00012e 	bgeu	sp,et,81148854 <alt_msgdma_construct_extended_mm_to_st_descriptor+0xc>
81148850:	003b68fa 	trap	3
81148854:	dfc00f15 	stw	ra,60(sp)
81148858:	df000e15 	stw	fp,56(sp)
8114885c:	df000e04 	addi	fp,sp,56
81148860:	e13ff915 	stw	r4,-28(fp)
81148864:	e17ffa15 	stw	r5,-24(fp)
81148868:	e1bffb15 	stw	r6,-20(fp)
8114886c:	e1fffc15 	stw	r7,-16(fp)
81148870:	e1000317 	ldw	r4,12(fp)
81148874:	e0c00417 	ldw	r3,16(fp)
81148878:	e0800517 	ldw	r2,20(fp)
8114887c:	e13ffd0d 	sth	r4,-12(fp)
81148880:	e0fffe05 	stb	r3,-8(fp)
81148884:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, read_address, 
81148888:	e0bffd0b 	ldhu	r2,-12(fp)
8114888c:	e0fffe03 	ldbu	r3,-8(fp)
81148890:	e13fff0b 	ldhu	r4,-4(fp)
81148894:	d8000615 	stw	zero,24(sp)
81148898:	d9000515 	stw	r4,20(sp)
8114889c:	d8000415 	stw	zero,16(sp)
811488a0:	d8c00315 	stw	r3,12(sp)
811488a4:	d8800215 	stw	r2,8(sp)
811488a8:	e0800217 	ldw	r2,8(fp)
811488ac:	d8800115 	stw	r2,4(sp)
811488b0:	e0bffc17 	ldw	r2,-16(fp)
811488b4:	d8800015 	stw	r2,0(sp)
811488b8:	000f883a 	mov	r7,zero
811488bc:	e1bffb17 	ldw	r6,-20(fp)
811488c0:	e17ffa17 	ldw	r5,-24(fp)
811488c4:	e13ff917 	ldw	r4,-28(fp)
811488c8:	1147dec0 	call	81147dec <alt_msgdma_construct_extended_descriptor>
            NULL, length, control, sequence_number, read_burst_count, 0, 
            read_stride, 0);

}
811488cc:	e037883a 	mov	sp,fp
811488d0:	dfc00117 	ldw	ra,4(sp)
811488d4:	df000017 	ldw	fp,0(sp)
811488d8:	dec00204 	addi	sp,sp,8
811488dc:	f800283a 	ret

811488e0 <alt_msgdma_construct_extended_mm_to_mm_descriptor>:
    alt_u16 sequence_number, 
    alt_u8 read_burst_count, 
    alt_u8 write_burst_count,
    alt_u16 read_stride, 
    alt_u16 write_stride)
{
811488e0:	deffee04 	addi	sp,sp,-72
811488e4:	de00012e 	bgeu	sp,et,811488ec <alt_msgdma_construct_extended_mm_to_mm_descriptor+0xc>
811488e8:	003b68fa 	trap	3
811488ec:	dfc01115 	stw	ra,68(sp)
811488f0:	df001015 	stw	fp,64(sp)
811488f4:	df001004 	addi	fp,sp,64
811488f8:	e13ff715 	stw	r4,-36(fp)
811488fc:	e17ff815 	stw	r5,-32(fp)
81148900:	e1bff915 	stw	r6,-28(fp)
81148904:	e1fffa15 	stw	r7,-24(fp)
81148908:	e1800417 	ldw	r6,16(fp)
8114890c:	e1400517 	ldw	r5,20(fp)
81148910:	e1000617 	ldw	r4,24(fp)
81148914:	e0c00717 	ldw	r3,28(fp)
81148918:	e0800817 	ldw	r2,32(fp)
8114891c:	e1bffb0d 	sth	r6,-20(fp)
81148920:	e17ffc05 	stb	r5,-16(fp)
81148924:	e13ffd05 	stb	r4,-12(fp)
81148928:	e0fffe0d 	sth	r3,-8(fp)
8114892c:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
81148930:	e0bffb0b 	ldhu	r2,-20(fp)
81148934:	e0fffc03 	ldbu	r3,-16(fp)
81148938:	e13ffd03 	ldbu	r4,-12(fp)
8114893c:	e17ffe0b 	ldhu	r5,-8(fp)
81148940:	e1bfff0b 	ldhu	r6,-4(fp)
81148944:	d9800615 	stw	r6,24(sp)
81148948:	d9400515 	stw	r5,20(sp)
8114894c:	d9000415 	stw	r4,16(sp)
81148950:	d8c00315 	stw	r3,12(sp)
81148954:	d8800215 	stw	r2,8(sp)
81148958:	e0800317 	ldw	r2,12(fp)
8114895c:	d8800115 	stw	r2,4(sp)
81148960:	e0800217 	ldw	r2,8(fp)
81148964:	d8800015 	stw	r2,0(sp)
81148968:	e1fffa17 	ldw	r7,-24(fp)
8114896c:	e1bff917 	ldw	r6,-28(fp)
81148970:	e17ff817 	ldw	r5,-32(fp)
81148974:	e13ff717 	ldw	r4,-36(fp)
81148978:	1147dec0 	call	81147dec <alt_msgdma_construct_extended_descriptor>
            read_address, write_address, length, control, sequence_number, 
            read_burst_count, write_burst_count, read_stride, write_stride);

}
8114897c:	e037883a 	mov	sp,fp
81148980:	dfc00117 	ldw	ra,4(sp)
81148984:	df000017 	ldw	fp,0(sp)
81148988:	dec00204 	addi	sp,sp,8
8114898c:	f800283a 	ret

81148990 <alt_msgdma_construct_prefetcher_standard_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81148990:	defffb04 	addi	sp,sp,-20
81148994:	de00012e 	bgeu	sp,et,8114899c <alt_msgdma_construct_prefetcher_standard_descriptor+0xc>
81148998:	003b68fa 	trap	3
8114899c:	df000415 	stw	fp,16(sp)
811489a0:	df000404 	addi	fp,sp,16
811489a4:	e13ffc15 	stw	r4,-16(fp)
811489a8:	e17ffd15 	stw	r5,-12(fp)
811489ac:	e1bffe15 	stw	r6,-8(fp)
811489b0:	e1ffff15 	stw	r7,-4(fp)
    if(dev->max_byte < length ||
811489b4:	e0bffc17 	ldw	r2,-16(fp)
811489b8:	10c01217 	ldw	r3,72(r2)
811489bc:	e0800117 	ldw	r2,4(fp)
811489c0:	18800436 	bltu	r3,r2,811489d4 <alt_msgdma_construct_prefetcher_standard_descriptor+0x44>
       dev->enhanced_features != 0
811489c4:	e0bffc17 	ldw	r2,-16(fp)
811489c8:	10801703 	ldbu	r2,92(r2)
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
811489cc:	10803fcc 	andi	r2,r2,255
811489d0:	10000226 	beq	r2,zero,811489dc <alt_msgdma_construct_prefetcher_standard_descriptor+0x4c>
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
811489d4:	00bffa84 	movi	r2,-22
811489d8:	00001406 	br	81148a2c <alt_msgdma_construct_prefetcher_standard_descriptor+0x9c>
    }
    descriptor->read_address = read_address;
811489dc:	e0bffd17 	ldw	r2,-12(fp)
811489e0:	e0fffe17 	ldw	r3,-8(fp)
811489e4:	10c00015 	stw	r3,0(r2)
    descriptor->write_address = write_address;
811489e8:	e0bffd17 	ldw	r2,-12(fp)
811489ec:	e0ffff17 	ldw	r3,-4(fp)
811489f0:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
811489f4:	e0bffd17 	ldw	r2,-12(fp)
811489f8:	e0c00117 	ldw	r3,4(fp)
811489fc:	10c00215 	stw	r3,8(r2)
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
81148a00:	e0fffd17 	ldw	r3,-12(fp)
81148a04:	e0bffd17 	ldw	r2,-12(fp)
81148a08:	10c00315 	stw	r3,12(r2)
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81148a0c:	e0c00217 	ldw	r3,8(fp)
81148a10:	00900034 	movhi	r2,16384
81148a14:	10bfffc4 	addi	r2,r2,-1
81148a18:	1884703a 	and	r2,r3,r2
81148a1c:	10e00034 	orhi	r3,r2,32768
    descriptor->transfer_length = length;
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
81148a20:	e0bffd17 	ldw	r2,-12(fp)
81148a24:	10c00715 	stw	r3,28(r2)
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
81148a28:	0005883a 	mov	r2,zero
}
81148a2c:	e037883a 	mov	sp,fp
81148a30:	df000017 	ldw	fp,0(sp)
81148a34:	dec00104 	addi	sp,sp,4
81148a38:	f800283a 	ret

81148a3c <alt_msgdma_construct_prefetcher_extended_descriptor>:
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
81148a3c:	defff404 	addi	sp,sp,-48
81148a40:	de00012e 	bgeu	sp,et,81148a48 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc>
81148a44:	003b68fa 	trap	3
81148a48:	df000b15 	stw	fp,44(sp)
81148a4c:	df000b04 	addi	fp,sp,44
81148a50:	e13ff715 	stw	r4,-36(fp)
81148a54:	e17ff815 	stw	r5,-32(fp)
81148a58:	e1bff915 	stw	r6,-28(fp)
81148a5c:	e1fffa15 	stw	r7,-24(fp)
81148a60:	e1800517 	ldw	r6,20(fp)
81148a64:	e1400617 	ldw	r5,24(fp)
81148a68:	e1000717 	ldw	r4,28(fp)
81148a6c:	e0c00817 	ldw	r3,32(fp)
81148a70:	e0800917 	ldw	r2,36(fp)
81148a74:	e1bffb0d 	sth	r6,-20(fp)
81148a78:	e17ffc05 	stb	r5,-16(fp)
81148a7c:	e13ffd05 	stb	r4,-12(fp)
81148a80:	e0fffe0d 	sth	r3,-8(fp)
81148a84:	e0bfff0d 	sth	r2,-4(fp)
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
81148a88:	e0bff717 	ldw	r2,-36(fp)
81148a8c:	10c01217 	ldw	r3,72(r2)
81148a90:	e0800317 	ldw	r2,12(fp)
81148a94:	18801936 	bltu	r3,r2,81148afc <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
81148a98:	e13ff717 	ldw	r4,-36(fp)
81148a9c:	20801317 	ldw	r2,76(r4)
81148aa0:	20c01417 	ldw	r3,80(r4)
81148aa4:	e13ffe0b 	ldhu	r4,-8(fp)
81148aa8:	213fffcc 	andi	r4,r4,65535
81148aac:	2015883a 	mov	r10,r4
81148ab0:	0017883a 	mov	r11,zero
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
81148ab4:	1ac01136 	bltu	r3,r11,81148afc <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
81148ab8:	58c0011e 	bne	r11,r3,81148ac0 <alt_msgdma_construct_prefetcher_extended_descriptor+0x84>
81148abc:	12800f36 	bltu	r2,r10,81148afc <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
81148ac0:	e13ff717 	ldw	r4,-36(fp)
81148ac4:	20801317 	ldw	r2,76(r4)
81148ac8:	20c01417 	ldw	r3,80(r4)
81148acc:	e13fff0b 	ldhu	r4,-4(fp)
81148ad0:	213fffcc 	andi	r4,r4,65535
81148ad4:	2011883a 	mov	r8,r4
81148ad8:	0013883a 	mov	r9,zero
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
81148adc:	1a400736 	bltu	r3,r9,81148afc <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
81148ae0:	48c0011e 	bne	r9,r3,81148ae8 <alt_msgdma_construct_prefetcher_extended_descriptor+0xac>
81148ae4:	12000536 	bltu	r2,r8,81148afc <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
81148ae8:	e0bff717 	ldw	r2,-36(fp)
81148aec:	10801703 	ldbu	r2,92(r2)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
81148af0:	10803fcc 	andi	r2,r2,255
81148af4:	10800060 	cmpeqi	r2,r2,1
81148af8:	1000021e 	bne	r2,zero,81148b04 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc8>
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
81148afc:	00bffa84 	movi	r2,-22
81148b00:	00003106 	br	81148bc8 <alt_msgdma_construct_prefetcher_extended_descriptor+0x18c>
    }
    
    descriptor->read_address_high = read_address_high;
81148b04:	e0bff817 	ldw	r2,-32(fp)
81148b08:	e0fff917 	ldw	r3,-28(fp)
81148b0c:	10c00915 	stw	r3,36(r2)
    descriptor->read_address_low = read_address_low;
81148b10:	e0bff817 	ldw	r2,-32(fp)
81148b14:	e0fffa17 	ldw	r3,-24(fp)
81148b18:	10c00015 	stw	r3,0(r2)
    descriptor->write_address_high = write_address_high;
81148b1c:	e0bff817 	ldw	r2,-32(fp)
81148b20:	e0c00117 	ldw	r3,4(fp)
81148b24:	10c00a15 	stw	r3,40(r2)
    descriptor->write_address_low = write_address_low;
81148b28:	e0bff817 	ldw	r2,-32(fp)
81148b2c:	e0c00217 	ldw	r3,8(fp)
81148b30:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
81148b34:	e0bff817 	ldw	r2,-32(fp)
81148b38:	e0c00317 	ldw	r3,12(fp)
81148b3c:	10c00215 	stw	r3,8(r2)
    descriptor->sequence_number = sequence_number;
81148b40:	e0bff817 	ldw	r2,-32(fp)
81148b44:	e0fffb0b 	ldhu	r3,-20(fp)
81148b48:	10c0070d 	sth	r3,28(r2)
    descriptor->read_burst_count = read_burst_count;
81148b4c:	e0bff817 	ldw	r2,-32(fp)
81148b50:	e0fffc03 	ldbu	r3,-16(fp)
81148b54:	10c00785 	stb	r3,30(r2)
    descriptor->write_burst_count = write_burst_count;
81148b58:	e0bff817 	ldw	r2,-32(fp)
81148b5c:	e0fffd03 	ldbu	r3,-12(fp)
81148b60:	10c007c5 	stb	r3,31(r2)
    descriptor->read_stride = read_stride;
81148b64:	e0bff817 	ldw	r2,-32(fp)
81148b68:	e0fffe0b 	ldhu	r3,-8(fp)
81148b6c:	10c0080d 	sth	r3,32(r2)
    descriptor->write_stride = write_stride;
81148b70:	e0bff817 	ldw	r2,-32(fp)
81148b74:	e0ffff0b 	ldhu	r3,-4(fp)
81148b78:	10c0088d 	sth	r3,34(r2)
    /* have descriptor point to itself */
	node_addr.u64 = (uintptr_t)descriptor;
81148b7c:	e0bff817 	ldw	r2,-32(fp)
81148b80:	1019883a 	mov	r12,r2
81148b84:	001b883a 	mov	r13,zero
81148b88:	e33ff515 	stw	r12,-44(fp)
81148b8c:	e37ff615 	stw	r13,-40(fp)
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
81148b90:	e0fff517 	ldw	r3,-44(fp)
81148b94:	e0bff817 	ldw	r2,-32(fp)
81148b98:	10c00315 	stw	r3,12(r2)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
81148b9c:	e0fff617 	ldw	r3,-40(fp)
81148ba0:	e0bff817 	ldw	r2,-32(fp)
81148ba4:	10c00b15 	stw	r3,44(r2)
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81148ba8:	e0c00417 	ldw	r3,16(fp)
81148bac:	00900034 	movhi	r2,16384
81148bb0:	10bfffc4 	addi	r2,r2,-1
81148bb4:	1884703a 	and	r2,r3,r2
81148bb8:	10e00034 	orhi	r3,r2,32768
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
81148bbc:	e0bff817 	ldw	r2,-32(fp)
81148bc0:	10c00f15 	stw	r3,60(r2)
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
81148bc4:	0005883a 	mov	r2,zero
}
81148bc8:	e037883a 	mov	sp,fp
81148bcc:	df000017 	ldw	fp,0(sp)
81148bd0:	dec00104 	addi	sp,sp,4
81148bd4:	f800283a 	ret

81148bd8 <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address,
	alt_u32 write_address,
	alt_u32 length,
	alt_u32 control)
{
81148bd8:	defff804 	addi	sp,sp,-32
81148bdc:	de00012e 	bgeu	sp,et,81148be4 <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor+0xc>
81148be0:	003b68fa 	trap	3
81148be4:	dfc00715 	stw	ra,28(sp)
81148be8:	df000615 	stw	fp,24(sp)
81148bec:	df000604 	addi	fp,sp,24
81148bf0:	e13ffc15 	stw	r4,-16(fp)
81148bf4:	e17ffd15 	stw	r5,-12(fp)
81148bf8:	e1bffe15 	stw	r6,-8(fp)
81148bfc:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
81148c00:	e0800317 	ldw	r2,12(fp)
81148c04:	d8800115 	stw	r2,4(sp)
81148c08:	e0800217 	ldw	r2,8(fp)
81148c0c:	d8800015 	stw	r2,0(sp)
81148c10:	e1ffff17 	ldw	r7,-4(fp)
81148c14:	e1bffe17 	ldw	r6,-8(fp)
81148c18:	e17ffd17 	ldw	r5,-12(fp)
81148c1c:	e13ffc17 	ldw	r4,-16(fp)
81148c20:	11489900 	call	81148990 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		read_address, write_address, length, control);
}
81148c24:	e037883a 	mov	sp,fp
81148c28:	dfc00117 	ldw	ra,4(sp)
81148c2c:	df000017 	ldw	fp,0(sp)
81148c30:	dec00204 	addi	sp,sp,8
81148c34:	f800283a 	ret

81148c38 <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor>:
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *descriptor, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81148c38:	defff804 	addi	sp,sp,-32
81148c3c:	de00012e 	bgeu	sp,et,81148c44 <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor+0xc>
81148c40:	003b68fa 	trap	3
81148c44:	dfc00715 	stw	ra,28(sp)
81148c48:	df000615 	stw	fp,24(sp)
81148c4c:	df000604 	addi	fp,sp,24
81148c50:	e13ffc15 	stw	r4,-16(fp)
81148c54:	e17ffd15 	stw	r5,-12(fp)
81148c58:	e1bffe15 	stw	r6,-8(fp)
81148c5c:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
81148c60:	e0800217 	ldw	r2,8(fp)
81148c64:	d8800115 	stw	r2,4(sp)
81148c68:	e0bfff17 	ldw	r2,-4(fp)
81148c6c:	d8800015 	stw	r2,0(sp)
81148c70:	e1fffe17 	ldw	r7,-8(fp)
81148c74:	000d883a 	mov	r6,zero
81148c78:	e17ffd17 	ldw	r5,-12(fp)
81148c7c:	e13ffc17 	ldw	r4,-16(fp)
81148c80:	11489900 	call	81148990 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		0, write_address, length, control);
}
81148c84:	e037883a 	mov	sp,fp
81148c88:	dfc00117 	ldw	ra,4(sp)
81148c8c:	df000017 	ldw	fp,0(sp)
81148c90:	dec00204 	addi	sp,sp,8
81148c94:	f800283a 	ret

81148c98 <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor>:
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *descriptor, 
	alt_u32 read_address, 
	alt_u32 length, 
	alt_u32 control)
{
81148c98:	defff804 	addi	sp,sp,-32
81148c9c:	de00012e 	bgeu	sp,et,81148ca4 <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor+0xc>
81148ca0:	003b68fa 	trap	3
81148ca4:	dfc00715 	stw	ra,28(sp)
81148ca8:	df000615 	stw	fp,24(sp)
81148cac:	df000604 	addi	fp,sp,24
81148cb0:	e13ffc15 	stw	r4,-16(fp)
81148cb4:	e17ffd15 	stw	r5,-12(fp)
81148cb8:	e1bffe15 	stw	r6,-8(fp)
81148cbc:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
81148cc0:	e0800217 	ldw	r2,8(fp)
81148cc4:	d8800115 	stw	r2,4(sp)
81148cc8:	e0bfff17 	ldw	r2,-4(fp)
81148ccc:	d8800015 	stw	r2,0(sp)
81148cd0:	000f883a 	mov	r7,zero
81148cd4:	e1bffe17 	ldw	r6,-8(fp)
81148cd8:	e17ffd17 	ldw	r5,-12(fp)
81148cdc:	e13ffc17 	ldw	r4,-16(fp)
81148ce0:	11489900 	call	81148990 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		read_address, 0, length, control);
}
81148ce4:	e037883a 	mov	sp,fp
81148ce8:	dfc00117 	ldw	ra,4(sp)
81148cec:	df000017 	ldw	fp,0(sp)
81148cf0:	dec00204 	addi	sp,sp,8
81148cf4:	f800283a 	ret

81148cf8 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number,
	alt_u8 write_burst_count,
	alt_u16 write_stride)
{
81148cf8:	deffee04 	addi	sp,sp,-72
81148cfc:	de00012e 	bgeu	sp,et,81148d04 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor+0xc>
81148d00:	003b68fa 	trap	3
81148d04:	dfc01115 	stw	ra,68(sp)
81148d08:	df001015 	stw	fp,64(sp)
81148d0c:	df001004 	addi	fp,sp,64
81148d10:	e13ff915 	stw	r4,-28(fp)
81148d14:	e17ffa15 	stw	r5,-24(fp)
81148d18:	e1bffb15 	stw	r6,-20(fp)
81148d1c:	e1fffc15 	stw	r7,-16(fp)
81148d20:	e1000417 	ldw	r4,16(fp)
81148d24:	e0c00517 	ldw	r3,20(fp)
81148d28:	e0800617 	ldw	r2,24(fp)
81148d2c:	e13ffd0d 	sth	r4,-12(fp)
81148d30:	e0fffe05 	stb	r3,-8(fp)
81148d34:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor, 
81148d38:	e0bffd0b 	ldhu	r2,-12(fp)
81148d3c:	e0fffe03 	ldbu	r3,-8(fp)
81148d40:	e13fff0b 	ldhu	r4,-4(fp)
81148d44:	d9000815 	stw	r4,32(sp)
81148d48:	d8000715 	stw	zero,28(sp)
81148d4c:	d8c00615 	stw	r3,24(sp)
81148d50:	d8000515 	stw	zero,20(sp)
81148d54:	d8800415 	stw	r2,16(sp)
81148d58:	e0800317 	ldw	r2,12(fp)
81148d5c:	d8800315 	stw	r2,12(sp)
81148d60:	e0800217 	ldw	r2,8(fp)
81148d64:	d8800215 	stw	r2,8(sp)
81148d68:	e0bffc17 	ldw	r2,-16(fp)
81148d6c:	d8800115 	stw	r2,4(sp)
81148d70:	e0bffb17 	ldw	r2,-20(fp)
81148d74:	d8800015 	stw	r2,0(sp)
81148d78:	000f883a 	mov	r7,zero
81148d7c:	000d883a 	mov	r6,zero
81148d80:	e17ffa17 	ldw	r5,-24(fp)
81148d84:	e13ff917 	ldw	r4,-28(fp)
81148d88:	1148a3c0 	call	81148a3c <alt_msgdma_construct_prefetcher_extended_descriptor>
            0, 0, write_address_high, write_address_low, length, control, 
			sequence_number, 0, write_burst_count, 0, write_stride);
}
81148d8c:	e037883a 	mov	sp,fp
81148d90:	dfc00117 	ldw	ra,4(sp)
81148d94:	df000017 	ldw	fp,0(sp)
81148d98:	dec00204 	addi	sp,sp,8
81148d9c:	f800283a 	ret

81148da0 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
81148da0:	deffee04 	addi	sp,sp,-72
81148da4:	de00012e 	bgeu	sp,et,81148dac <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor+0xc>
81148da8:	003b68fa 	trap	3
81148dac:	dfc01115 	stw	ra,68(sp)
81148db0:	df001015 	stw	fp,64(sp)
81148db4:	df001004 	addi	fp,sp,64
81148db8:	e13ff915 	stw	r4,-28(fp)
81148dbc:	e17ffa15 	stw	r5,-24(fp)
81148dc0:	e1bffb15 	stw	r6,-20(fp)
81148dc4:	e1fffc15 	stw	r7,-16(fp)
81148dc8:	e1000417 	ldw	r4,16(fp)
81148dcc:	e0c00517 	ldw	r3,20(fp)
81148dd0:	e0800617 	ldw	r2,24(fp)
81148dd4:	e13ffd0d 	sth	r4,-12(fp)
81148dd8:	e0fffe05 	stb	r3,-8(fp)
81148ddc:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
81148de0:	e0bffd0b 	ldhu	r2,-12(fp)
81148de4:	e0fffe03 	ldbu	r3,-8(fp)
81148de8:	e13fff0b 	ldhu	r4,-4(fp)
81148dec:	d8000815 	stw	zero,32(sp)
81148df0:	d9000715 	stw	r4,28(sp)
81148df4:	d8000615 	stw	zero,24(sp)
81148df8:	d8c00515 	stw	r3,20(sp)
81148dfc:	d8800415 	stw	r2,16(sp)
81148e00:	e0800317 	ldw	r2,12(fp)
81148e04:	d8800315 	stw	r2,12(sp)
81148e08:	e0800217 	ldw	r2,8(fp)
81148e0c:	d8800215 	stw	r2,8(sp)
81148e10:	d8000115 	stw	zero,4(sp)
81148e14:	d8000015 	stw	zero,0(sp)
81148e18:	e1fffc17 	ldw	r7,-16(fp)
81148e1c:	e1bffb17 	ldw	r6,-20(fp)
81148e20:	e17ffa17 	ldw	r5,-24(fp)
81148e24:	e13ff917 	ldw	r4,-28(fp)
81148e28:	1148a3c0 	call	81148a3c <alt_msgdma_construct_prefetcher_extended_descriptor>
    		read_address_high, read_address_low, 0, 0, length, control, 
			sequence_number, read_burst_count, 0, read_stride, 0);
}
81148e2c:	e037883a 	mov	sp,fp
81148e30:	dfc00117 	ldw	ra,4(sp)
81148e34:	df000017 	ldw	fp,0(sp)
81148e38:	dec00204 	addi	sp,sp,8
81148e3c:	f800283a 	ret

81148e40 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor>:
	alt_u16 sequence_number,
	alt_u8 read_burst_count,
	alt_u8 write_burst_count, 
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
81148e40:	deffec04 	addi	sp,sp,-80
81148e44:	de00012e 	bgeu	sp,et,81148e4c <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0xc>
81148e48:	003b68fa 	trap	3
81148e4c:	dfc01315 	stw	ra,76(sp)
81148e50:	df001215 	stw	fp,72(sp)
81148e54:	df001204 	addi	fp,sp,72
81148e58:	e13ff715 	stw	r4,-36(fp)
81148e5c:	e17ff815 	stw	r5,-32(fp)
81148e60:	e1bff915 	stw	r6,-28(fp)
81148e64:	e1fffa15 	stw	r7,-24(fp)
81148e68:	e1800617 	ldw	r6,24(fp)
81148e6c:	e1400717 	ldw	r5,28(fp)
81148e70:	e1000817 	ldw	r4,32(fp)
81148e74:	e0c00917 	ldw	r3,36(fp)
81148e78:	e0800a17 	ldw	r2,40(fp)
81148e7c:	e1bffb0d 	sth	r6,-20(fp)
81148e80:	e17ffc05 	stb	r5,-16(fp)
81148e84:	e13ffd05 	stb	r4,-12(fp)
81148e88:	e0fffe0d 	sth	r3,-8(fp)
81148e8c:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
81148e90:	e0bffb0b 	ldhu	r2,-20(fp)
81148e94:	e0fffc03 	ldbu	r3,-16(fp)
81148e98:	e13ffd03 	ldbu	r4,-12(fp)
81148e9c:	e17ffe0b 	ldhu	r5,-8(fp)
81148ea0:	e1bfff0b 	ldhu	r6,-4(fp)
81148ea4:	d9800815 	stw	r6,32(sp)
81148ea8:	d9400715 	stw	r5,28(sp)
81148eac:	d9000615 	stw	r4,24(sp)
81148eb0:	d8c00515 	stw	r3,20(sp)
81148eb4:	d8800415 	stw	r2,16(sp)
81148eb8:	e0800517 	ldw	r2,20(fp)
81148ebc:	d8800315 	stw	r2,12(sp)
81148ec0:	e0800417 	ldw	r2,16(fp)
81148ec4:	d8800215 	stw	r2,8(sp)
81148ec8:	e0800317 	ldw	r2,12(fp)
81148ecc:	d8800115 	stw	r2,4(sp)
81148ed0:	e0800217 	ldw	r2,8(fp)
81148ed4:	d8800015 	stw	r2,0(sp)
81148ed8:	e1fffa17 	ldw	r7,-24(fp)
81148edc:	e1bff917 	ldw	r6,-28(fp)
81148ee0:	e17ff817 	ldw	r5,-32(fp)
81148ee4:	e13ff717 	ldw	r4,-36(fp)
81148ee8:	1148a3c0 	call	81148a3c <alt_msgdma_construct_prefetcher_extended_descriptor>
            read_address_high, read_address_low, write_address_high, 
			write_address_low, length, control, sequence_number, 
			read_burst_count, write_burst_count, read_stride, write_stride);

}
81148eec:	e037883a 	mov	sp,fp
81148ef0:	dfc00117 	ldw	ra,4(sp)
81148ef4:	df000017 	ldw	fp,0(sp)
81148ef8:	dec00204 	addi	sp,sp,8
81148efc:	f800283a 	ret

81148f00 <alt_msgdma_prefetcher_add_standard_desc_to_list>:
 *           descriptor.next_ptr not pointing back to itslef)
 */
int alt_msgdma_prefetcher_add_standard_desc_to_list (
	alt_msgdma_prefetcher_standard_descriptor** list,
	alt_msgdma_prefetcher_standard_descriptor* descriptor)
{
81148f00:	defffc04 	addi	sp,sp,-16
81148f04:	de00012e 	bgeu	sp,et,81148f0c <alt_msgdma_prefetcher_add_standard_desc_to_list+0xc>
81148f08:	003b68fa 	trap	3
81148f0c:	df000315 	stw	fp,12(sp)
81148f10:	df000304 	addi	fp,sp,12
81148f14:	e13ffe15 	stw	r4,-8(fp)
81148f18:	e17fff15 	stw	r5,-4(fp)
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	
	if (descriptor == NULL)
81148f1c:	e0bfff17 	ldw	r2,-4(fp)
81148f20:	1000021e 	bne	r2,zero,81148f2c <alt_msgdma_prefetcher_add_standard_desc_to_list+0x2c>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
81148f24:	00bffa84 	movi	r2,-22
81148f28:	00002f06 	br	81148fe8 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (descriptor->next_desc_ptr != (alt_u32)descriptor)
81148f2c:	e0bfff17 	ldw	r2,-4(fp)
81148f30:	10c00317 	ldw	r3,12(r2)
81148f34:	e0bfff17 	ldw	r2,-4(fp)
81148f38:	18800226 	beq	r3,r2,81148f44 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x44>
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
81148f3c:	00bffa84 	movi	r2,-22
81148f40:	00002906 	br	81148fe8 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (*list == NULL)
81148f44:	e0bffe17 	ldw	r2,-8(fp)
81148f48:	10800017 	ldw	r2,0(r2)
81148f4c:	1000051e 	bne	r2,zero,81148f64 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x64>
	{
		*list = descriptor;  /* make this root-node if list is empty */
81148f50:	e0bffe17 	ldw	r2,-8(fp)
81148f54:	e0ffff17 	ldw	r3,-4(fp)
81148f58:	10c00015 	stw	r3,0(r2)
		return 0;  /* successfully added */
81148f5c:	0005883a 	mov	r2,zero
81148f60:	00002106 	br	81148fe8 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (*list == descriptor)
81148f64:	e0bffe17 	ldw	r2,-8(fp)
81148f68:	10c00017 	ldw	r3,0(r2)
81148f6c:	e0bfff17 	ldw	r2,-4(fp)
81148f70:	1880021e 	bne	r3,r2,81148f7c <alt_msgdma_prefetcher_add_standard_desc_to_list+0x7c>
	{
		return -EINVAL;  /* this descriptor cannot already be root-node */
81148f74:	00bffa84 	movi	r2,-22
81148f78:	00001b06 	br	81148fe8 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
81148f7c:	e0bffe17 	ldw	r2,-8(fp)
81148f80:	10800017 	ldw	r2,0(r2)
81148f84:	e0bffd15 	stw	r2,-12(fp)
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
81148f88:	00000906 	br	81148fb0 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xb0>
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
81148f8c:	e0bffd17 	ldw	r2,-12(fp)
81148f90:	10c00317 	ldw	r3,12(r2)
81148f94:	e0bfff17 	ldw	r2,-4(fp)
81148f98:	1880021e 	bne	r3,r2,81148fa4 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xa4>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
81148f9c:	00bffa84 	movi	r2,-22
81148fa0:	00001106 	br	81148fe8 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
		}
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
81148fa4:	e0bffd17 	ldw	r2,-12(fp)
81148fa8:	10800317 	ldw	r2,12(r2)
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		last_descr_ptr = 
81148fac:	e0bffd15 	stw	r2,-12(fp)
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
81148fb0:	e0bffd17 	ldw	r2,-12(fp)
81148fb4:	10800317 	ldw	r2,12(r2)
81148fb8:	e0fffe17 	ldw	r3,-8(fp)
81148fbc:	18c00017 	ldw	r3,0(r3)
81148fc0:	10fff21e 	bne	r2,r3,81148f8c <__reset+0xfb128f8c>
		}
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* add this descriptor to end of list */
	last_descr_ptr->next_desc_ptr = (alt_u32)((uintptr_t)descriptor);
81148fc4:	e0ffff17 	ldw	r3,-4(fp)
81148fc8:	e0bffd17 	ldw	r2,-12(fp)
81148fcc:	10c00315 	stw	r3,12(r2)
	/* ensure new last pointer points the start of the list */
	descriptor->next_desc_ptr = (alt_u32)((uintptr_t)*list);  
81148fd0:	e0bffe17 	ldw	r2,-8(fp)
81148fd4:	10800017 	ldw	r2,0(r2)
81148fd8:	1007883a 	mov	r3,r2
81148fdc:	e0bfff17 	ldw	r2,-4(fp)
81148fe0:	10c00315 	stw	r3,12(r2)
	return 0; /* successfully added */
81148fe4:	0005883a 	mov	r2,zero
}
81148fe8:	e037883a 	mov	sp,fp
81148fec:	df000017 	ldw	fp,0(sp)
81148ff0:	dec00104 	addi	sp,sp,4
81148ff4:	f800283a 	ret

81148ff8 <alt_msgdma_prefetcher_add_extended_desc_to_list>:

int alt_msgdma_prefetcher_add_extended_desc_to_list (
	alt_msgdma_prefetcher_extended_descriptor** list,
	alt_msgdma_prefetcher_extended_descriptor* descriptor)
{
81148ff8:	defff804 	addi	sp,sp,-32
81148ffc:	de00012e 	bgeu	sp,et,81149004 <alt_msgdma_prefetcher_add_extended_desc_to_list+0xc>
81149000:	003b68fa 	trap	3
81149004:	df000715 	stw	fp,28(sp)
81149008:	df000704 	addi	fp,sp,28
8114900c:	e13ffe15 	stw	r4,-8(fp)
81149010:	e17fff15 	stw	r5,-4(fp)
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	msgdma_addr64 root_node_addr, next_node_addr;
	
	if (descriptor == NULL)
81149014:	e13fff17 	ldw	r4,-4(fp)
81149018:	2000021e 	bne	r4,zero,81149024 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x2c>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
8114901c:	00bffa84 	movi	r2,-22
81149020:	00005906 	br	81149188 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
81149024:	e13fff17 	ldw	r4,-4(fp)
81149028:	2015883a 	mov	r10,r4
8114902c:	0017883a 	mov	r11,zero
81149030:	e2bffc15 	stw	r10,-16(fp)
81149034:	e2fffd15 	stw	r11,-12(fp)
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
81149038:	e13fff17 	ldw	r4,-4(fp)
8114903c:	21400317 	ldw	r5,12(r4)
81149040:	e13ffc17 	ldw	r4,-16(fp)
81149044:	29000626 	beq	r5,r4,81149060 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x68>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
81149048:	e13fff17 	ldw	r4,-4(fp)
8114904c:	21400b17 	ldw	r5,44(r4)
81149050:	e13ffd17 	ldw	r4,-12(fp)
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
81149054:	29000226 	beq	r5,r4,81149060 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x68>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
81149058:	00bffa84 	movi	r2,-22
8114905c:	00004a06 	br	81149188 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	if (*list == NULL)
81149060:	e13ffe17 	ldw	r4,-8(fp)
81149064:	21000017 	ldw	r4,0(r4)
81149068:	2000051e 	bne	r4,zero,81149080 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x88>
	{
		*list = descriptor;  /* make this the root-node if list is empty */
8114906c:	e0bffe17 	ldw	r2,-8(fp)
81149070:	e0ffff17 	ldw	r3,-4(fp)
81149074:	10c00015 	stw	r3,0(r2)
		return 0;
81149078:	0005883a 	mov	r2,zero
8114907c:	00004206 	br	81149188 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	if (*list == descriptor)
81149080:	e13ffe17 	ldw	r4,-8(fp)
81149084:	21400017 	ldw	r5,0(r4)
81149088:	e13fff17 	ldw	r4,-4(fp)
8114908c:	2900021e 	bne	r5,r4,81149098 <alt_msgdma_prefetcher_add_extended_desc_to_list+0xa0>
	{
		return -EINVAL;  /* this descriptor cannot already be root-node */
81149090:	00bffa84 	movi	r2,-22
81149094:	00003c06 	br	81149188 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
81149098:	e13ffe17 	ldw	r4,-8(fp)
8114909c:	21000017 	ldw	r4,0(r4)
811490a0:	e13ff915 	stw	r4,-28(fp)
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
811490a4:	e13ffe17 	ldw	r4,-8(fp)
811490a8:	21000017 	ldw	r4,0(r4)
811490ac:	2011883a 	mov	r8,r4
811490b0:	0013883a 	mov	r9,zero
811490b4:	e23ffa15 	stw	r8,-24(fp)
811490b8:	e27ffb15 	stw	r9,-20(fp)
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
811490bc:	00001806 	br	81149120 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x128>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* first check if descriptor already in the list */
		next_node_addr.u64 = (uintptr_t)descriptor;
811490c0:	e13fff17 	ldw	r4,-4(fp)
811490c4:	200d883a 	mov	r6,r4
811490c8:	000f883a 	mov	r7,zero
811490cc:	e1bffc15 	stw	r6,-16(fp)
811490d0:	e1fffd15 	stw	r7,-12(fp)
		if ((last_descr_ptr->next_desc_ptr_low == next_node_addr.u32[0])
811490d4:	e13ff917 	ldw	r4,-28(fp)
811490d8:	21400317 	ldw	r5,12(r4)
811490dc:	e13ffc17 	ldw	r4,-16(fp)
811490e0:	2900061e 	bne	r5,r4,811490fc <alt_msgdma_prefetcher_add_extended_desc_to_list+0x104>
			&& (last_descr_ptr->next_desc_ptr_high == next_node_addr.u32[1]))
811490e4:	e13ff917 	ldw	r4,-28(fp)
811490e8:	21400b17 	ldw	r5,44(r4)
811490ec:	e13ffd17 	ldw	r4,-12(fp)
811490f0:	2900021e 	bne	r5,r4,811490fc <alt_msgdma_prefetcher_add_extended_desc_to_list+0x104>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
811490f4:	00bffa84 	movi	r2,-22
811490f8:	00002306 	br	81149188 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
811490fc:	e13ff917 	ldw	r4,-28(fp)
81149100:	21000317 	ldw	r4,12(r4)
81149104:	e13ffc15 	stw	r4,-16(fp)
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
81149108:	e13ff917 	ldw	r4,-28(fp)
8114910c:	21000b17 	ldw	r4,44(r4)
81149110:	e13ffd15 	stw	r4,-12(fp)
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
81149114:	e13ffc17 	ldw	r4,-16(fp)
81149118:	e17ffd17 	ldw	r5,-12(fp)
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
8114911c:	e13ff915 	stw	r4,-28(fp)
	last_descr_ptr = *list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
81149120:	e13ff917 	ldw	r4,-28(fp)
81149124:	21400317 	ldw	r5,12(r4)
81149128:	e13ffa17 	ldw	r4,-24(fp)
8114912c:	29000426 	beq	r5,r4,81149140 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x148>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
81149130:	e13ff917 	ldw	r4,-28(fp)
81149134:	21400b17 	ldw	r5,44(r4)
81149138:	e13ffb17 	ldw	r4,-20(fp)
8114913c:	293fe01e 	bne	r5,r4,811490c0 <__reset+0xfb1290c0>
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* add this descriptor to end of list */
	next_node_addr.u64 = (uintptr_t)descriptor;
81149140:	e13fff17 	ldw	r4,-4(fp)
81149144:	2005883a 	mov	r2,r4
81149148:	0007883a 	mov	r3,zero
8114914c:	e0bffc15 	stw	r2,-16(fp)
81149150:	e0fffd15 	stw	r3,-12(fp)
	last_descr_ptr->next_desc_ptr_low = next_node_addr.u32[0];
81149154:	e0fffc17 	ldw	r3,-16(fp)
81149158:	e0bff917 	ldw	r2,-28(fp)
8114915c:	10c00315 	stw	r3,12(r2)
	last_descr_ptr->next_desc_ptr_high = next_node_addr.u32[1];
81149160:	e0fffd17 	ldw	r3,-12(fp)
81149164:	e0bff917 	ldw	r2,-28(fp)
81149168:	10c00b15 	stw	r3,44(r2)
	/* ensure new last pointer points the beginning of the list */
	descriptor->next_desc_ptr_low = root_node_addr.u32[0];
8114916c:	e0fffa17 	ldw	r3,-24(fp)
81149170:	e0bfff17 	ldw	r2,-4(fp)
81149174:	10c00315 	stw	r3,12(r2)
	descriptor->next_desc_ptr_high = root_node_addr.u32[1];
81149178:	e0fffb17 	ldw	r3,-20(fp)
8114917c:	e0bfff17 	ldw	r2,-4(fp)
81149180:	10c00b15 	stw	r3,44(r2)
	return 0;
81149184:	0005883a 	mov	r2,zero
}
81149188:	e037883a 	mov	sp,fp
8114918c:	df000017 	ldw	fp,0(sp)
81149190:	dec00104 	addi	sp,sp,4
81149194:	f800283a 	ret

81149198 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>:
 * prefetcher since if used the create descriptor APIs the set_by_hw bits are
 * still set to SW owned. 
 */
int alt_msgdma_prefetcher_set_std_list_own_by_hw_bits (
	alt_msgdma_prefetcher_standard_descriptor *list)
{
81149198:	defffc04 	addi	sp,sp,-16
8114919c:	de00012e 	bgeu	sp,et,811491a4 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0xc>
811491a0:	003b68fa 	trap	3
811491a4:	df000315 	stw	fp,12(sp)
811491a8:	df000304 	addi	fp,sp,12
811491ac:	e13fff15 	stw	r4,-4(fp)
	alt_u32 descriptor_control_field = 0;
811491b0:	e03ffe15 	stw	zero,-8(fp)
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	if (list == NULL)
811491b4:	e0bfff17 	ldw	r2,-4(fp)
811491b8:	1000021e 	bne	r2,zero,811491c4 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x2c>
	{
		return -EINVAL;  /* this list cannot be empty */
811491bc:	00bffa84 	movi	r2,-22
811491c0:	00001906 	br	81149228 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x90>
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
811491c4:	e0bfff17 	ldw	r2,-4(fp)
811491c8:	e0bffd15 	stw	r2,-12(fp)
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
811491cc:	00000a06 	br	811491f8 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x60>
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
811491d0:	e0bffd17 	ldw	r2,-12(fp)
811491d4:	10800717 	ldw	r2,28(r2)
811491d8:	e0bffe15 	stw	r2,-8(fp)
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
811491dc:	e0bffe17 	ldw	r2,-8(fp)
811491e0:	10d00034 	orhi	r3,r2,16384
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
811491e4:	e0bffd17 	ldw	r2,-12(fp)
811491e8:	10c00715 	stw	r3,28(r2)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
811491ec:	e0bffd17 	ldw	r2,-12(fp)
811491f0:	10800317 	ldw	r2,12(r2)
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
811491f4:	e0bffd15 	stw	r2,-12(fp)
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
811491f8:	e0bffd17 	ldw	r2,-12(fp)
811491fc:	10c00317 	ldw	r3,12(r2)
81149200:	e0bfff17 	ldw	r2,-4(fp)
81149204:	18bff21e 	bne	r3,r2,811491d0 <__reset+0xfb1291d0>
		/* go to next node in list */
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
81149208:	e0bffd17 	ldw	r2,-12(fp)
8114920c:	10800717 	ldw	r2,28(r2)
81149210:	e0bffe15 	stw	r2,-8(fp)
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
81149214:	e0bffe17 	ldw	r2,-8(fp)
81149218:	10d00034 	orhi	r3,r2,16384
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
8114921c:	e0bffd17 	ldw	r2,-12(fp)
81149220:	10c00715 	stw	r3,28(r2)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	
	return 0;
81149224:	0005883a 	mov	r2,zero
}
81149228:	e037883a 	mov	sp,fp
8114922c:	df000017 	ldw	fp,0(sp)
81149230:	dec00104 	addi	sp,sp,4
81149234:	f800283a 	ret

81149238 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>:
 * prefetcher since if used the create descriptor APIs the set_by_hw bits are
 * still set to SW owned. 
 */
int alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits (
	alt_msgdma_prefetcher_extended_descriptor *list)
{
81149238:	defff804 	addi	sp,sp,-32
8114923c:	de00012e 	bgeu	sp,et,81149244 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xc>
81149240:	003b68fa 	trap	3
81149244:	df000715 	stw	fp,28(sp)
81149248:	df000704 	addi	fp,sp,28
8114924c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 descriptor_control_field = 0;
81149250:	e03ffa15 	stw	zero,-24(fp)
	msgdma_addr64 root_node_addr, next_node_addr;
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	
	if (list == NULL)
81149254:	e13fff17 	ldw	r4,-4(fp)
81149258:	2000021e 	bne	r4,zero,81149264 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x2c>
	{
		return -EINVAL;  /* this list cannot be empty */
8114925c:	00bffa84 	movi	r2,-22
81149260:	00002806 	br	81149304 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xcc>
	}
	
	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
81149264:	e13fff17 	ldw	r4,-4(fp)
81149268:	e13ff915 	stw	r4,-28(fp)
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;
8114926c:	e13fff17 	ldw	r4,-4(fp)
81149270:	2005883a 	mov	r2,r4
81149274:	0007883a 	mov	r3,zero
81149278:	e0bffb15 	stw	r2,-20(fp)
8114927c:	e0fffc15 	stw	r3,-16(fp)

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
81149280:	00001006 	br	811492c4 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x8c>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
81149284:	e0bff917 	ldw	r2,-28(fp)
81149288:	10800f17 	ldw	r2,60(r2)
8114928c:	e0bffa15 	stw	r2,-24(fp)
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
81149290:	e0bffa17 	ldw	r2,-24(fp)
81149294:	10d00034 	orhi	r3,r2,16384
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
81149298:	e0bff917 	ldw	r2,-28(fp)
8114929c:	10c00f15 	stw	r3,60(r2)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
811492a0:	e0bff917 	ldw	r2,-28(fp)
811492a4:	10800317 	ldw	r2,12(r2)
811492a8:	e0bffd15 	stw	r2,-12(fp)
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
811492ac:	e0bff917 	ldw	r2,-28(fp)
811492b0:	10800b17 	ldw	r2,44(r2)
811492b4:	e0bffe15 	stw	r2,-8(fp)
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
811492b8:	e0bffd17 	ldw	r2,-12(fp)
811492bc:	e0fffe17 	ldw	r3,-8(fp)
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
811492c0:	e0bff915 	stw	r2,-28(fp)
	last_descr_ptr = list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
811492c4:	e0bff917 	ldw	r2,-28(fp)
811492c8:	10c00317 	ldw	r3,12(r2)
811492cc:	e0bffb17 	ldw	r2,-20(fp)
811492d0:	18800426 	beq	r3,r2,811492e4 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xac>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
811492d4:	e0bff917 	ldw	r2,-28(fp)
811492d8:	10c00b17 	ldw	r3,44(r2)
811492dc:	e0bffc17 	ldw	r2,-16(fp)
811492e0:	18bfe81e 	bne	r3,r2,81149284 <__reset+0xfb129284>
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
811492e4:	e0bff917 	ldw	r2,-28(fp)
811492e8:	10800f17 	ldw	r2,60(r2)
811492ec:	e0bffa15 	stw	r2,-24(fp)
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
811492f0:	e0bffa17 	ldw	r2,-24(fp)
811492f4:	10d00034 	orhi	r3,r2,16384
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
811492f8:	e0bff917 	ldw	r2,-28(fp)
811492fc:	10c00f15 	stw	r3,60(r2)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	return 0;
81149300:	0005883a 	mov	r2,zero
}
81149304:	e037883a 	mov	sp,fp
81149308:	df000017 	ldw	fp,0(sp)
8114930c:	dec00104 	addi	sp,sp,4
81149310:	f800283a 	ret

81149314 <alt_msgdma_start_prefetcher_with_list_addr>:
int alt_msgdma_start_prefetcher_with_list_addr (
	alt_msgdma_dev *dev,
	alt_u64  list_addr,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
81149314:	deffeb04 	addi	sp,sp,-84
81149318:	de00012e 	bgeu	sp,et,81149320 <alt_msgdma_start_prefetcher_with_list_addr+0xc>
8114931c:	003b68fa 	trap	3
81149320:	dfc01415 	stw	ra,80(sp)
81149324:	df001315 	stw	fp,76(sp)
81149328:	df001304 	addi	fp,sp,76
8114932c:	e13ffb15 	stw	r4,-20(fp)
81149330:	e17ffc15 	stw	r5,-16(fp)
81149334:	e1bffd15 	stw	r6,-12(fp)
81149338:	3807883a 	mov	r3,r7
8114933c:	e0800217 	ldw	r2,8(fp)
81149340:	e0fffe05 	stb	r3,-8(fp)
81149344:	e0bfff05 	stb	r2,-4(fp)
	alt_u32 prefetcher_ctl = 0;
81149348:	e03fed15 	stw	zero,-76(fp)
	alt_u32 dispatcher_ctl = 0;
8114934c:	e03fee15 	stw	zero,-72(fp)
	alt_irq_context context = 0;
81149350:	e03fef15 	stw	zero,-68(fp)
	
	/* use helper struct to get easy access to hi/low address */
	msgdma_addr64 root_node_addr;
	root_node_addr.u64 = list_addr;  
81149354:	e0bffc17 	ldw	r2,-16(fp)
81149358:	e0bff815 	stw	r2,-32(fp)
8114935c:	e0bffd17 	ldw	r2,-12(fp)
81149360:	e0bff915 	stw	r2,-28(fp)
	
	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND (dev->regs_lock, 0);
81149364:	e0bffb17 	ldw	r2,-20(fp)
81149368:	10801817 	ldw	r2,96(r2)
8114936c:	e0bff615 	stw	r2,-40(fp)
81149370:	e03ff70d 	sth	zero,-36(fp)
81149374:	e0bff70b 	ldhu	r2,-36(fp)
81149378:	e0fffa04 	addi	r3,fp,-24
8114937c:	180d883a 	mov	r6,r3
81149380:	100b883a 	mov	r5,r2
81149384:	e13ff617 	ldw	r4,-40(fp)
81149388:	113e4c00 	call	8113e4c0 <OSSemPend>
	
	/* case where prefetcher already started, return busy error */ 
	prefetcher_ctl = IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base);
8114938c:	e0bffb17 	ldw	r2,-20(fp)
81149390:	10800617 	ldw	r2,24(r2)
81149394:	10800037 	ldwio	r2,0(r2)
81149398:	e0bfed15 	stw	r2,-76(fp)
	if(ALT_MSGDMA_PREFETCHER_CTRL_RUN_GET(prefetcher_ctl)){
8114939c:	e0bfed17 	ldw	r2,-76(fp)
811493a0:	1080004c 	andi	r2,r2,1
811493a4:	10000626 	beq	r2,zero,811493c0 <alt_msgdma_start_prefetcher_with_list_addr+0xac>
		/* release the registers semaphore */
		ALT_SEM_POST (dev->regs_lock);
811493a8:	e0bffb17 	ldw	r2,-20(fp)
811493ac:	10801817 	ldw	r2,96(r2)
811493b0:	1009883a 	mov	r4,r2
811493b4:	113e8480 	call	8113e848 <OSSemPost>
		return -EBUSY;
811493b8:	00bffc04 	movi	r2,-16
811493bc:	00009606 	br	81149618 <alt_msgdma_start_prefetcher_with_list_addr+0x304>
	}
		
	/* Stop the msgdma dispatcher from issuing more descriptors to the
	   read or write masters  */
	/* stop issuing more descriptors */
	dispatcher_ctl = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
811493c0:	00800804 	movi	r2,32
811493c4:	e0bfee15 	stw	r2,-72(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811493c8:	0005303a 	rdctl	r2,status
811493cc:	e0bff215 	stw	r2,-56(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811493d0:	e0fff217 	ldw	r3,-56(fp)
811493d4:	00bfff84 	movi	r2,-2
811493d8:	1884703a 	and	r2,r3,r2
811493dc:	1001703a 	wrctl	status,r2
  
  return context;
811493e0:	e0bff217 	ldw	r2,-56(fp)
	
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
811493e4:	e0bfef15 	stw	r2,-68(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
811493e8:	e0bffb17 	ldw	r2,-20(fp)
811493ec:	10800317 	ldw	r2,12(r2)
811493f0:	10800104 	addi	r2,r2,4
811493f4:	e0ffee17 	ldw	r3,-72(fp)
811493f8:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS( dev->csr_base, 
811493fc:	e0bffb17 	ldw	r2,-20(fp)
81149400:	10800317 	ldw	r2,12(r2)
81149404:	e0fffb17 	ldw	r3,-20(fp)
81149408:	18c00317 	ldw	r3,12(r3)
8114940c:	18c00037 	ldwio	r3,0(r3)
81149410:	10c00035 	stwio	r3,0(r2)
81149414:	e0bfef17 	ldw	r2,-68(fp)
81149418:	e0bff015 	stw	r2,-64(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114941c:	e0bff017 	ldw	r2,-64(fp)
81149420:	1001703a 	wrctl	status,r2
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up dispatcher to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if(dev->callback)
81149424:	e0bffb17 	ldw	r2,-20(fp)
81149428:	10800b17 	ldw	r2,44(r2)
8114942c:	10002326 	beq	r2,zero,811494bc <alt_msgdma_start_prefetcher_with_list_addr+0x1a8>
	{
		dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK 
81149430:	e0bffb17 	ldw	r2,-20(fp)
81149434:	10c00d17 	ldw	r3,52(r2)
81149438:	e0bfee17 	ldw	r2,-72(fp)
8114943c:	1884b03a 	or	r2,r3,r2
81149440:	10800514 	ori	r2,r2,20
81149444:	e0bfee15 	stw	r2,-72(fp)
				| ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
		dispatcher_ctl &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
81149448:	e0ffee17 	ldw	r3,-72(fp)
8114944c:	00bff7c4 	movi	r2,-33
81149450:	1884703a 	and	r2,r3,r2
81149454:	e0bfee15 	stw	r2,-72(fp)
		
		prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
81149458:	e0bfed17 	ldw	r2,-76(fp)
8114945c:	10800214 	ori	r2,r2,8
81149460:	e0bfed15 	stw	r2,-76(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81149464:	0005303a 	rdctl	r2,status
81149468:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114946c:	e0fff417 	ldw	r3,-48(fp)
81149470:	00bfff84 	movi	r2,-2
81149474:	1884703a 	and	r2,r3,r2
81149478:	1001703a 	wrctl	status,r2
  
  return context;
8114947c:	e0bff417 	ldw	r2,-48(fp)
	    /* making sure the read-modify-write below can't be pre-empted */
	    context = alt_irq_disable_all(); 
81149480:	e0bfef15 	stw	r2,-68(fp)
	    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
81149484:	e0bffb17 	ldw	r2,-20(fp)
81149488:	10800317 	ldw	r2,12(r2)
8114948c:	10800104 	addi	r2,r2,4
81149490:	e0ffee17 	ldw	r3,-72(fp)
81149494:	10c00035 	stwio	r3,0(r2)
		IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
81149498:	e0bffb17 	ldw	r2,-20(fp)
8114949c:	10800617 	ldw	r2,24(r2)
811494a0:	e0ffed17 	ldw	r3,-76(fp)
811494a4:	10c00035 	stwio	r3,0(r2)
811494a8:	e0bfef17 	ldw	r2,-68(fp)
811494ac:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811494b0:	e0bff117 	ldw	r2,-60(fp)
811494b4:	1001703a 	wrctl	status,r2
811494b8:	00002306 	br	81149548 <alt_msgdma_start_prefetcher_with_list_addr+0x234>
	  *   - Stop on an error with any particular descriptor
	  *   - Disable interrupt generation
	  */
	 else
	 {
		 dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
811494bc:	e0bffb17 	ldw	r2,-20(fp)
811494c0:	10c00d17 	ldw	r3,52(r2)
811494c4:	e0bfee17 	ldw	r2,-72(fp)
811494c8:	1884b03a 	or	r2,r3,r2
811494cc:	10800114 	ori	r2,r2,4
811494d0:	e0bfee15 	stw	r2,-72(fp)
		 dispatcher_ctl &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) 
811494d4:	e0ffee17 	ldw	r3,-72(fp)
811494d8:	00bff3c4 	movi	r2,-49
811494dc:	1884703a 	and	r2,r3,r2
811494e0:	e0bfee15 	stw	r2,-72(fp)
				 & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
811494e4:	e0ffed17 	ldw	r3,-76(fp)
811494e8:	00bffdc4 	movi	r2,-9
811494ec:	1884703a 	and	r2,r3,r2
811494f0:	e0bfed15 	stw	r2,-76(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811494f4:	0005303a 	rdctl	r2,status
811494f8:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811494fc:	e0fff517 	ldw	r3,-44(fp)
81149500:	00bfff84 	movi	r2,-2
81149504:	1884703a 	and	r2,r3,r2
81149508:	1001703a 	wrctl	status,r2
  
  return context;
8114950c:	e0bff517 	ldw	r2,-44(fp)
	     /* making sure the read-modify-write below can't be pre-empted */
	     context = alt_irq_disable_all();
81149510:	e0bfef15 	stw	r2,-68(fp)
	     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
81149514:	e0bffb17 	ldw	r2,-20(fp)
81149518:	10800317 	ldw	r2,12(r2)
8114951c:	10800104 	addi	r2,r2,4
81149520:	e0ffee17 	ldw	r3,-72(fp)
81149524:	10c00035 	stwio	r3,0(r2)
	     IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
81149528:	e0bffb17 	ldw	r2,-20(fp)
8114952c:	10800617 	ldw	r2,24(r2)
81149530:	e0ffed17 	ldw	r3,-76(fp)
81149534:	10c00035 	stwio	r3,0(r2)
81149538:	e0bfef17 	ldw	r2,-68(fp)
8114953c:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81149540:	e0bff317 	ldw	r2,-52(fp)
81149544:	1001703a 	wrctl	status,r2
	     alt_irq_enable_all(context);
	 }   
	
	 /* set next descriptor registers to point to the list root-node */
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_LOW(dev->prefetcher_base,
81149548:	e0bffb17 	ldw	r2,-20(fp)
8114954c:	10800617 	ldw	r2,24(r2)
81149550:	10800104 	addi	r2,r2,4
81149554:	e0fff817 	ldw	r3,-32(fp)
81149558:	10c00035 	stwio	r3,0(r2)
			 root_node_addr.u32[0]);
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_HIGH(dev->prefetcher_base,
8114955c:	e0bffb17 	ldw	r2,-20(fp)
81149560:	10800617 	ldw	r2,24(r2)
81149564:	10800204 	addi	r2,r2,8
81149568:	e0fff917 	ldw	r3,-28(fp)
8114956c:	10c00035 	stwio	r3,0(r2)
			 root_node_addr.u32[1]);
		
	 /* set park-mode */
	 if (park_mode_en){
81149570:	e0bffe03 	ldbu	r2,-8(fp)
81149574:	10000426 	beq	r2,zero,81149588 <alt_msgdma_start_prefetcher_with_list_addr+0x274>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_SET_MASK;
81149578:	e0bfed17 	ldw	r2,-76(fp)
8114957c:	10800414 	ori	r2,r2,16
81149580:	e0bfed15 	stw	r2,-76(fp)
81149584:	00000406 	br	81149598 <alt_msgdma_start_prefetcher_with_list_addr+0x284>
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_CLR_MASK;
81149588:	e0ffed17 	ldw	r3,-76(fp)
8114958c:	00bffbc4 	movi	r2,-17
81149590:	1884703a 	and	r2,r3,r2
81149594:	e0bfed15 	stw	r2,-76(fp)
	 }
	 
	 /* set poll-en */
	 if (poll_en){
81149598:	e0bfff03 	ldbu	r2,-4(fp)
8114959c:	10000e26 	beq	r2,zero,811495d8 <alt_msgdma_start_prefetcher_with_list_addr+0x2c4>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_MASK; 
811495a0:	e0bfed17 	ldw	r2,-76(fp)
811495a4:	10800094 	ori	r2,r2,2
811495a8:	e0bfed15 	stw	r2,-76(fp)
		 if(IORD_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
811495ac:	e0bffb17 	ldw	r2,-20(fp)
811495b0:	10800617 	ldw	r2,24(r2)
811495b4:	10800304 	addi	r2,r2,12
811495b8:	10800037 	ldwio	r2,0(r2)
811495bc:	10000a1e 	bne	r2,zero,811495e8 <alt_msgdma_start_prefetcher_with_list_addr+0x2d4>
				 dev->prefetcher_base) == 0){
			 /* set poll frequency to some non-zero default value */
			 IOWR_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
811495c0:	e0bffb17 	ldw	r2,-20(fp)
811495c4:	10800617 	ldw	r2,24(r2)
811495c8:	10800304 	addi	r2,r2,12
811495cc:	00c03fc4 	movi	r3,255
811495d0:	10c00035 	stwio	r3,0(r2)
811495d4:	00000406 	br	811495e8 <alt_msgdma_start_prefetcher_with_list_addr+0x2d4>
					 dev->prefetcher_base, 0xFF);
		 }
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_CLR_MASK; 
811495d8:	e0ffed17 	ldw	r3,-76(fp)
811495dc:	00bfff44 	movi	r2,-3
811495e0:	1884703a 	and	r2,r3,r2
811495e4:	e0bfed15 	stw	r2,-76(fp)
	 }
	 
	 /* set the prefetcher run bit */
	 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_RUN_SET_MASK;
811495e8:	e0bfed17 	ldw	r2,-76(fp)
811495ec:	10800054 	ori	r2,r2,1
811495f0:	e0bfed15 	stw	r2,-76(fp)
	 /* start the dma since run bit is set */
	 IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
811495f4:	e0bffb17 	ldw	r2,-20(fp)
811495f8:	10800617 	ldw	r2,24(r2)
811495fc:	e0ffed17 	ldw	r3,-76(fp)
81149600:	10c00035 	stwio	r3,0(r2)
	 
	 /*
	  * Now that access to the registers is complete, release the registers
	  * semaphore so that other threads can access the registers.
	  */
	 ALT_SEM_POST (dev->regs_lock);
81149604:	e0bffb17 	ldw	r2,-20(fp)
81149608:	10801817 	ldw	r2,96(r2)
8114960c:	1009883a 	mov	r4,r2
81149610:	113e8480 	call	8113e848 <OSSemPost>
	 
	 return 0;
81149614:	0005883a 	mov	r2,zero
}
81149618:	e037883a 	mov	sp,fp
8114961c:	dfc00117 	ldw	ra,4(sp)
81149620:	df000017 	ldw	fp,0(sp)
81149624:	dec00204 	addi	sp,sp,8
81149628:	f800283a 	ret

8114962c <alt_msgdma_start_prefetcher_with_std_desc_list>:
int alt_msgdma_start_prefetcher_with_std_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{	
8114962c:	defff704 	addi	sp,sp,-36
81149630:	de00012e 	bgeu	sp,et,81149638 <alt_msgdma_start_prefetcher_with_std_desc_list+0xc>
81149634:	003b68fa 	trap	3
81149638:	dfc00815 	stw	ra,32(sp)
8114963c:	df000715 	stw	fp,28(sp)
81149640:	dc400615 	stw	r17,24(sp)
81149644:	dc000515 	stw	r16,20(sp)
81149648:	df000704 	addi	fp,sp,28
8114964c:	e13ffa15 	stw	r4,-24(fp)
81149650:	e17ffb15 	stw	r5,-20(fp)
81149654:	3007883a 	mov	r3,r6
81149658:	3805883a 	mov	r2,r7
8114965c:	e0fffc05 	stb	r3,-16(fp)
81149660:	e0bffd05 	stb	r2,-12(fp)
	if (alt_msgdma_prefetcher_set_std_list_own_by_hw_bits(list) != 0){
81149664:	e13ffb17 	ldw	r4,-20(fp)
81149668:	11491980 	call	81149198 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>
8114966c:	10000226 	beq	r2,zero,81149678 <alt_msgdma_start_prefetcher_with_std_desc_list+0x4c>
		return -EINVAL;
81149670:	00bffa84 	movi	r2,-22
81149674:	00000b06 	br	811496a4 <alt_msgdma_start_prefetcher_with_std_desc_list+0x78>
	}
	
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list,
81149678:	e0bffb17 	ldw	r2,-20(fp)
8114967c:	1021883a 	mov	r16,r2
81149680:	0023883a 	mov	r17,zero
81149684:	e0fffc03 	ldbu	r3,-16(fp)
81149688:	e0bffd03 	ldbu	r2,-12(fp)
8114968c:	d8800015 	stw	r2,0(sp)
81149690:	180f883a 	mov	r7,r3
81149694:	800b883a 	mov	r5,r16
81149698:	880d883a 	mov	r6,r17
8114969c:	e13ffa17 	ldw	r4,-24(fp)
811496a0:	11493140 	call	81149314 <alt_msgdma_start_prefetcher_with_list_addr>
			park_mode_en, poll_en);
}
811496a4:	e6fffe04 	addi	sp,fp,-8
811496a8:	dfc00317 	ldw	ra,12(sp)
811496ac:	df000217 	ldw	fp,8(sp)
811496b0:	dc400117 	ldw	r17,4(sp)
811496b4:	dc000017 	ldw	r16,0(sp)
811496b8:	dec00404 	addi	sp,sp,16
811496bc:	f800283a 	ret

811496c0 <alt_msgdma_start_prefetcher_with_extd_desc_list>:
int alt_msgdma_start_prefetcher_with_extd_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_extended_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
811496c0:	defff704 	addi	sp,sp,-36
811496c4:	de00012e 	bgeu	sp,et,811496cc <alt_msgdma_start_prefetcher_with_extd_desc_list+0xc>
811496c8:	003b68fa 	trap	3
811496cc:	dfc00815 	stw	ra,32(sp)
811496d0:	df000715 	stw	fp,28(sp)
811496d4:	dc400615 	stw	r17,24(sp)
811496d8:	dc000515 	stw	r16,20(sp)
811496dc:	df000704 	addi	fp,sp,28
811496e0:	e13ffa15 	stw	r4,-24(fp)
811496e4:	e17ffb15 	stw	r5,-20(fp)
811496e8:	3007883a 	mov	r3,r6
811496ec:	3805883a 	mov	r2,r7
811496f0:	e0fffc05 	stb	r3,-16(fp)
811496f4:	e0bffd05 	stb	r2,-12(fp)
	if (alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits(list) != 0){
811496f8:	e13ffb17 	ldw	r4,-20(fp)
811496fc:	11492380 	call	81149238 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>
81149700:	10000226 	beq	r2,zero,8114970c <alt_msgdma_start_prefetcher_with_extd_desc_list+0x4c>
		return -EINVAL;
81149704:	00bffa84 	movi	r2,-22
81149708:	00000b06 	br	81149738 <alt_msgdma_start_prefetcher_with_extd_desc_list+0x78>
	}
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list, 
8114970c:	e0bffb17 	ldw	r2,-20(fp)
81149710:	1021883a 	mov	r16,r2
81149714:	0023883a 	mov	r17,zero
81149718:	e0fffc03 	ldbu	r3,-16(fp)
8114971c:	e0bffd03 	ldbu	r2,-12(fp)
81149720:	d8800015 	stw	r2,0(sp)
81149724:	180f883a 	mov	r7,r3
81149728:	800b883a 	mov	r5,r16
8114972c:	880d883a 	mov	r6,r17
81149730:	e13ffa17 	ldw	r4,-24(fp)
81149734:	11493140 	call	81149314 <alt_msgdma_start_prefetcher_with_list_addr>
			park_mode_en, poll_en);
}
81149738:	e6fffe04 	addi	sp,fp,-8
8114973c:	dfc00317 	ldw	ra,12(sp)
81149740:	df000217 	ldw	fp,8(sp)
81149744:	dc400117 	ldw	r17,4(sp)
81149748:	dc000017 	ldw	r16,0(sp)
8114974c:	dec00404 	addi	sp,sp,16
81149750:	f800283a 	ret

81149754 <alt_msgdma_open>:
 * Returns:
 * - Pointer to msgdma device instance structure, or null if the device
 *   could not be opened.
 */
alt_msgdma_dev* alt_msgdma_open (const char* name)
{
81149754:	defffc04 	addi	sp,sp,-16
81149758:	de00012e 	bgeu	sp,et,81149760 <alt_msgdma_open+0xc>
8114975c:	003b68fa 	trap	3
81149760:	dfc00315 	stw	ra,12(sp)
81149764:	df000215 	stw	fp,8(sp)
81149768:	df000204 	addi	fp,sp,8
8114976c:	e13fff15 	stw	r4,-4(fp)
    alt_msgdma_dev* dev = NULL;
81149770:	e03ffe15 	stw	zero,-8(fp)

    dev = (alt_msgdma_dev*) alt_find_dev (name, &alt_msgdma_list);
81149774:	d1603504 	addi	r5,gp,-32556
81149778:	e13fff17 	ldw	r4,-4(fp)
8114977c:	1149cf80 	call	81149cf8 <alt_find_dev>
81149780:	e0bffe15 	stw	r2,-8(fp)

    if (NULL == dev)
81149784:	e0bffe17 	ldw	r2,-8(fp)
81149788:	1000041e 	bne	r2,zero,8114979c <alt_msgdma_open+0x48>
    {
        ALT_ERRNO = ENODEV;
8114978c:	11479b80 	call	811479b8 <alt_get_errno>
81149790:	1007883a 	mov	r3,r2
81149794:	008004c4 	movi	r2,19
81149798:	18800015 	stw	r2,0(r3)
    }

    return dev;
8114979c:	e0bffe17 	ldw	r2,-8(fp)
}
811497a0:	e037883a 	mov	sp,fp
811497a4:	dfc00117 	ldw	ra,4(sp)
811497a8:	df000017 	ldw	fp,0(sp)
811497ac:	dec00204 	addi	sp,sp,8
811497b0:	f800283a 	ret

811497b4 <alt_msgdma_init>:
 * This routine disables interrupts, descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_msgdma_init (alt_msgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
811497b4:	defff604 	addi	sp,sp,-40
811497b8:	de00012e 	bgeu	sp,et,811497c0 <alt_msgdma_init+0xc>
811497bc:	003b68fa 	trap	3
811497c0:	dfc00915 	stw	ra,36(sp)
811497c4:	df000815 	stw	fp,32(sp)
811497c8:	df000804 	addi	fp,sp,32
811497cc:	e13ffd15 	stw	r4,-12(fp)
811497d0:	e17ffe15 	stw	r5,-8(fp)
811497d4:	e1bfff15 	stw	r6,-4(fp)
    extern alt_llist alt_msgdma_list;
    alt_u32 temporary_control;
    int error;

    if (dev->prefetcher_enable)
811497d8:	e0bffd17 	ldw	r2,-12(fp)
811497dc:	10801783 	ldbu	r2,94(r2)
811497e0:	10803fcc 	andi	r2,r2,255
811497e4:	10000b26 	beq	r2,zero,81149814 <alt_msgdma_init+0x60>
    {
    	/* start prefetcher reset sequence */
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, 
811497e8:	e0bffd17 	ldw	r2,-12(fp)
811497ec:	10800617 	ldw	r2,24(r2)
811497f0:	00c00104 	movi	r3,4
811497f4:	10c00035 	stwio	r3,0(r2)
    			ALT_MSGDMA_PREFETCHER_CTRL_RESET_SET_MASK);
    	/* wait until hw clears the bit */
    	while(ALT_MSGDMA_PREFETCHER_CTRL_RESET_GET(
811497f8:	0001883a 	nop
811497fc:	e0bffd17 	ldw	r2,-12(fp)
81149800:	10800617 	ldw	r2,24(r2)
81149804:	10800037 	ldwio	r2,0(r2)
81149808:	1080010c 	andi	r2,r2,4
8114980c:	1005d0ba 	srai	r2,r2,2
81149810:	103ffa1e 	bne	r2,zero,811497fc <__reset+0xfb1297fc>
    }    
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
81149814:	e0bffd17 	ldw	r2,-12(fp)
81149818:	10800317 	ldw	r2,12(r2)
8114981c:	10800104 	addi	r2,r2,4
81149820:	00c00084 	movi	r3,2
81149824:	10c00035 	stwio	r3,0(r2)
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
81149828:	0001883a 	nop
8114982c:	e0bffd17 	ldw	r2,-12(fp)
81149830:	10800317 	ldw	r2,12(r2)
81149834:	10800037 	ldwio	r2,0(r2)
    		& ALTERA_MSGDMA_CSR_RESET_STATE_MASK));
81149838:	1080100c 	andi	r2,r2,64
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
8114983c:	103ffb1e 	bne	r2,zero,8114982c <__reset+0xfb12982c>
    * Disable interrupts, halt descriptor processing,
    * and clear status register content
    */

    /* disable global interrupt */
    temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
81149840:	e0bffd17 	ldw	r2,-12(fp)
81149844:	10800317 	ldw	r2,12(r2)
81149848:	10800104 	addi	r2,r2,4
8114984c:	10800037 	ldwio	r2,0(r2)
81149850:	1007883a 	mov	r3,r2
81149854:	00bffbc4 	movi	r2,-17
81149858:	1884703a 	and	r2,r3,r2
8114985c:	e0bff915 	stw	r2,-28(fp)
    		& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    /* stopping descriptor */
    temporary_control |= ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
81149860:	e0bff917 	ldw	r2,-28(fp)
81149864:	10800814 	ori	r2,r2,32
81149868:	e0bff915 	stw	r2,-28(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
8114986c:	e0bffd17 	ldw	r2,-12(fp)
81149870:	10800317 	ldw	r2,12(r2)
81149874:	10800104 	addi	r2,r2,4
81149878:	e0fff917 	ldw	r3,-28(fp)
8114987c:	10c00035 	stwio	r3,0(r2)

    /* clear the CSR status register */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base, 
81149880:	e0bffd17 	ldw	r2,-12(fp)
81149884:	10800317 	ldw	r2,12(r2)
81149888:	e0fffd17 	ldw	r3,-12(fp)
8114988c:	18c00317 	ldw	r3,12(r3)
81149890:	18c00037 	ldwio	r3,0(r3)
81149894:	10c00035 	stwio	r3,0(r2)
    		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
    
    if (dev->prefetcher_enable)
81149898:	e0bffd17 	ldw	r2,-12(fp)
8114989c:	10801783 	ldbu	r2,94(r2)
811498a0:	10803fcc 	andi	r2,r2,255
811498a4:	10000826 	beq	r2,zero,811498c8 <alt_msgdma_init+0x114>
    {
    	/* clear all status bits that are set, since theyre W1C */
    	IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base, 
811498a8:	e0bffd17 	ldw	r2,-12(fp)
811498ac:	10800617 	ldw	r2,24(r2)
811498b0:	10800404 	addi	r2,r2,16
811498b4:	e0fffd17 	ldw	r3,-12(fp)
811498b8:	18c00617 	ldw	r3,24(r3)
811498bc:	18c00404 	addi	r3,r3,16
811498c0:	18c00037 	ldwio	r3,0(r3)
811498c4:	10c00035 	stwio	r3,0(r2)
    			IORD_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base));
    }

    /* Register this instance of the msgdma controller with HAL */
    alt_dev_llist_insert((alt_dev_llist*) dev, &alt_msgdma_list);
811498c8:	d1603504 	addi	r5,gp,-32556
811498cc:	e13ffd17 	ldw	r4,-12(fp)
811498d0:	1149c4c0 	call	81149c4c <alt_dev_llist_insert>

    /*
     * Creating semaphores used to protect access to the registers 
     * when running in a multi-threaded environment.
     */
    error = ALT_SEM_CREATE (&dev->regs_lock, 1);
811498d4:	e0bffd17 	ldw	r2,-12(fp)
811498d8:	10801804 	addi	r2,r2,96
811498dc:	e0bffb15 	stw	r2,-20(fp)
811498e0:	00800044 	movi	r2,1
811498e4:	e0bffc0d 	sth	r2,-16(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
811498e8:	e0bffc0b 	ldhu	r2,-16(fp)
811498ec:	1009883a 	mov	r4,r2
811498f0:	113e1980 	call	8113e198 <OSSemCreate>
811498f4:	1007883a 	mov	r3,r2
811498f8:	e0bffb17 	ldw	r2,-20(fp)
811498fc:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
81149900:	e0bffb17 	ldw	r2,-20(fp)
81149904:	10800017 	ldw	r2,0(r2)
81149908:	10000226 	beq	r2,zero,81149914 <alt_msgdma_init+0x160>
8114990c:	0005883a 	mov	r2,zero
81149910:	00000106 	br	81149918 <alt_msgdma_init+0x164>
81149914:	00bfffc4 	movi	r2,-1
81149918:	e0bffa15 	stw	r2,-24(fp)
            
    if (!error)
8114991c:	e0bffa17 	ldw	r2,-24(fp)
81149920:	1000081e 	bne	r2,zero,81149944 <alt_msgdma_init+0x190>
    {        
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
81149924:	d8000015 	stw	zero,0(sp)
81149928:	e1fffd17 	ldw	r7,-12(fp)
8114992c:	01a04534 	movhi	r6,33044
81149930:	319ef304 	addi	r6,r6,31692
81149934:	e17fff17 	ldw	r5,-4(fp)
81149938:	e13ffe17 	ldw	r4,-8(fp)
8114993c:	1149f840 	call	81149f84 <alt_ic_isr_register>
    else
    {
        alt_printf("failed to create semaphores\n");
    }
    
    return;
81149940:	00000406 	br	81149954 <alt_msgdma_init+0x1a0>
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
    }
    else
    {
        alt_printf("failed to create semaphores\n");
81149944:	01204574 	movhi	r4,33045
81149948:	21035104 	addi	r4,r4,3396
8114994c:	114a39c0 	call	8114a39c <alt_printf>
    }
    
    return;
81149950:	0001883a 	nop

}
81149954:	e037883a 	mov	sp,fp
81149958:	dfc00117 	ldw	ra,4(sp)
8114995c:	df000017 	ldw	fp,0(sp)
81149960:	dec00204 	addi	sp,sp,8
81149964:	f800283a 	ret

81149968 <alt_msgdma_register_callback>:
void alt_msgdma_register_callback(
	alt_msgdma_dev *dev,
	alt_msgdma_callback callback,
	alt_u32 control,
	void *context)
{
81149968:	defffb04 	addi	sp,sp,-20
8114996c:	de00012e 	bgeu	sp,et,81149974 <alt_msgdma_register_callback+0xc>
81149970:	003b68fa 	trap	3
81149974:	df000415 	stw	fp,16(sp)
81149978:	df000404 	addi	fp,sp,16
8114997c:	e13ffc15 	stw	r4,-16(fp)
81149980:	e17ffd15 	stw	r5,-12(fp)
81149984:	e1bffe15 	stw	r6,-8(fp)
81149988:	e1ffff15 	stw	r7,-4(fp)
    dev->callback         = callback;
8114998c:	e0bffc17 	ldw	r2,-16(fp)
81149990:	e0fffd17 	ldw	r3,-12(fp)
81149994:	10c00b15 	stw	r3,44(r2)
    dev->callback_context = context;
81149998:	e0bffc17 	ldw	r2,-16(fp)
8114999c:	e0ffff17 	ldw	r3,-4(fp)
811499a0:	10c00c15 	stw	r3,48(r2)
    dev->control          = control;
811499a4:	e0bffc17 	ldw	r2,-16(fp)
811499a8:	e0fffe17 	ldw	r3,-8(fp)
811499ac:	10c00d15 	stw	r3,52(r2)

    return ;
811499b0:	0001883a 	nop
}
811499b4:	e037883a 	mov	sp,fp
811499b8:	df000017 	ldw	fp,0(sp)
811499bc:	dec00104 	addi	sp,sp,4
811499c0:	f800283a 	ret

811499c4 <alt_msgdma_standard_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_standard_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
811499c4:	defffc04 	addi	sp,sp,-16
811499c8:	de00012e 	bgeu	sp,et,811499d0 <alt_msgdma_standard_descriptor_async_transfer+0xc>
811499cc:	003b68fa 	trap	3
811499d0:	dfc00315 	stw	ra,12(sp)
811499d4:	df000215 	stw	fp,8(sp)
811499d8:	df000204 	addi	fp,sp,8
811499dc:	e13ffe15 	stw	r4,-8(fp)
811499e0:	e17fff15 	stw	r5,-4(fp)
   /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
    return alt_msgdma_descriptor_async_transfer(dev, desc, NULL);
811499e4:	000d883a 	mov	r6,zero
811499e8:	e17fff17 	ldw	r5,-4(fp)
811499ec:	e13ffe17 	ldw	r4,-8(fp)
811499f0:	1147f480 	call	81147f48 <alt_msgdma_descriptor_async_transfer>

}
811499f4:	e037883a 	mov	sp,fp
811499f8:	dfc00117 	ldw	ra,4(sp)
811499fc:	df000017 	ldw	fp,0(sp)
81149a00:	dec00204 	addi	sp,sp,8
81149a04:	f800283a 	ret

81149a08 <alt_msgdma_extended_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_extended_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
81149a08:	defffc04 	addi	sp,sp,-16
81149a0c:	de00012e 	bgeu	sp,et,81149a14 <alt_msgdma_extended_descriptor_async_transfer+0xc>
81149a10:	003b68fa 	trap	3
81149a14:	dfc00315 	stw	ra,12(sp)
81149a18:	df000215 	stw	fp,8(sp)
81149a1c:	df000204 	addi	fp,sp,8
81149a20:	e13ffe15 	stw	r4,-8(fp)
81149a24:	e17fff15 	stw	r5,-4(fp)
    /*
    * Error detection/handling should be performed at the application
    * or callback level as appropriate.
    */
    return alt_msgdma_descriptor_async_transfer(dev, NULL, desc);
81149a28:	e1bfff17 	ldw	r6,-4(fp)
81149a2c:	000b883a 	mov	r5,zero
81149a30:	e13ffe17 	ldw	r4,-8(fp)
81149a34:	1147f480 	call	81147f48 <alt_msgdma_descriptor_async_transfer>
}
81149a38:	e037883a 	mov	sp,fp
81149a3c:	dfc00117 	ldw	ra,4(sp)
81149a40:	df000017 	ldw	fp,0(sp)
81149a44:	dec00204 	addi	sp,sp,8
81149a48:	f800283a 	ret

81149a4c <alt_msgdma_standard_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_standard_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
81149a4c:	defffc04 	addi	sp,sp,-16
81149a50:	de00012e 	bgeu	sp,et,81149a58 <alt_msgdma_standard_descriptor_sync_transfer+0xc>
81149a54:	003b68fa 	trap	3
81149a58:	dfc00315 	stw	ra,12(sp)
81149a5c:	df000215 	stw	fp,8(sp)
81149a60:	df000204 	addi	fp,sp,8
81149a64:	e13ffe15 	stw	r4,-8(fp)
81149a68:	e17fff15 	stw	r5,-4(fp)
    return alt_msgdma_descriptor_sync_transfer(dev, desc, NULL);
81149a6c:	000d883a 	mov	r6,zero
81149a70:	e17fff17 	ldw	r5,-4(fp)
81149a74:	e13ffe17 	ldw	r4,-8(fp)
81149a78:	11482880 	call	81148288 <alt_msgdma_descriptor_sync_transfer>
}
81149a7c:	e037883a 	mov	sp,fp
81149a80:	dfc00117 	ldw	ra,4(sp)
81149a84:	df000017 	ldw	fp,0(sp)
81149a88:	dec00204 	addi	sp,sp,8
81149a8c:	f800283a 	ret

81149a90 <alt_msgdma_extended_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_extended_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
81149a90:	defffc04 	addi	sp,sp,-16
81149a94:	de00012e 	bgeu	sp,et,81149a9c <alt_msgdma_extended_descriptor_sync_transfer+0xc>
81149a98:	003b68fa 	trap	3
81149a9c:	dfc00315 	stw	ra,12(sp)
81149aa0:	df000215 	stw	fp,8(sp)
81149aa4:	df000204 	addi	fp,sp,8
81149aa8:	e13ffe15 	stw	r4,-8(fp)
81149aac:	e17fff15 	stw	r5,-4(fp)
    return alt_msgdma_descriptor_sync_transfer(dev, NULL, desc);
81149ab0:	e1bfff17 	ldw	r6,-4(fp)
81149ab4:	000b883a 	mov	r5,zero
81149ab8:	e13ffe17 	ldw	r4,-8(fp)
81149abc:	11482880 	call	81148288 <alt_msgdma_descriptor_sync_transfer>
}
81149ac0:	e037883a 	mov	sp,fp
81149ac4:	dfc00117 	ldw	ra,4(sp)
81149ac8:	df000017 	ldw	fp,0(sp)
81149acc:	dec00204 	addi	sp,sp,8
81149ad0:	f800283a 	ret

81149ad4 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
81149ad4:	defff504 	addi	sp,sp,-44
81149ad8:	de00012e 	bgeu	sp,et,81149ae0 <alt_alarm_start+0xc>
81149adc:	003b68fa 	trap	3
81149ae0:	df000a15 	stw	fp,40(sp)
81149ae4:	df000a04 	addi	fp,sp,40
81149ae8:	e13ffc15 	stw	r4,-16(fp)
81149aec:	e17ffd15 	stw	r5,-12(fp)
81149af0:	e1bffe15 	stw	r6,-8(fp)
81149af4:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
81149af8:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81149afc:	d0a08817 	ldw	r2,-32224(gp)
  
  if (alt_ticks_per_second ())
81149b00:	10003c26 	beq	r2,zero,81149bf4 <alt_alarm_start+0x120>
  {
    if (alarm)
81149b04:	e0bffc17 	ldw	r2,-16(fp)
81149b08:	10003826 	beq	r2,zero,81149bec <alt_alarm_start+0x118>
    {
      alarm->callback = callback;
81149b0c:	e0bffc17 	ldw	r2,-16(fp)
81149b10:	e0fffe17 	ldw	r3,-8(fp)
81149b14:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
81149b18:	e0bffc17 	ldw	r2,-16(fp)
81149b1c:	e0ffff17 	ldw	r3,-4(fp)
81149b20:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81149b24:	0005303a 	rdctl	r2,status
81149b28:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81149b2c:	e0fff917 	ldw	r3,-28(fp)
81149b30:	00bfff84 	movi	r2,-2
81149b34:	1884703a 	and	r2,r3,r2
81149b38:	1001703a 	wrctl	status,r2
  
  return context;
81149b3c:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
81149b40:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81149b44:	d0a08917 	ldw	r2,-32220(gp)
      
      current_nticks = alt_nticks();
81149b48:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
81149b4c:	e0fffd17 	ldw	r3,-12(fp)
81149b50:	e0bff617 	ldw	r2,-40(fp)
81149b54:	1885883a 	add	r2,r3,r2
81149b58:	10c00044 	addi	r3,r2,1
81149b5c:	e0bffc17 	ldw	r2,-16(fp)
81149b60:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
81149b64:	e0bffc17 	ldw	r2,-16(fp)
81149b68:	10c00217 	ldw	r3,8(r2)
81149b6c:	e0bff617 	ldw	r2,-40(fp)
81149b70:	1880042e 	bgeu	r3,r2,81149b84 <alt_alarm_start+0xb0>
      {
        alarm->rollover = 1;
81149b74:	e0bffc17 	ldw	r2,-16(fp)
81149b78:	00c00044 	movi	r3,1
81149b7c:	10c00405 	stb	r3,16(r2)
81149b80:	00000206 	br	81149b8c <alt_alarm_start+0xb8>
      }
      else
      {
        alarm->rollover = 0;
81149b84:	e0bffc17 	ldw	r2,-16(fp)
81149b88:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
81149b8c:	e0bffc17 	ldw	r2,-16(fp)
81149b90:	d0e01404 	addi	r3,gp,-32688
81149b94:	e0fffa15 	stw	r3,-24(fp)
81149b98:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
81149b9c:	e0bffb17 	ldw	r2,-20(fp)
81149ba0:	e0fffa17 	ldw	r3,-24(fp)
81149ba4:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
81149ba8:	e0bffa17 	ldw	r2,-24(fp)
81149bac:	10c00017 	ldw	r3,0(r2)
81149bb0:	e0bffb17 	ldw	r2,-20(fp)
81149bb4:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
81149bb8:	e0bffa17 	ldw	r2,-24(fp)
81149bbc:	10800017 	ldw	r2,0(r2)
81149bc0:	e0fffb17 	ldw	r3,-20(fp)
81149bc4:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
81149bc8:	e0bffa17 	ldw	r2,-24(fp)
81149bcc:	e0fffb17 	ldw	r3,-20(fp)
81149bd0:	10c00015 	stw	r3,0(r2)
81149bd4:	e0bff817 	ldw	r2,-32(fp)
81149bd8:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81149bdc:	e0bff717 	ldw	r2,-36(fp)
81149be0:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
81149be4:	0005883a 	mov	r2,zero
81149be8:	00000306 	br	81149bf8 <alt_alarm_start+0x124>
    }
    else
    {
      return -EINVAL;
81149bec:	00bffa84 	movi	r2,-22
81149bf0:	00000106 	br	81149bf8 <alt_alarm_start+0x124>
    }
  }
  else
  {
    return -ENOTSUP;
81149bf4:	00bfde84 	movi	r2,-134
  }
}
81149bf8:	e037883a 	mov	sp,fp
81149bfc:	df000017 	ldw	fp,0(sp)
81149c00:	dec00104 	addi	sp,sp,4
81149c04:	f800283a 	ret

81149c08 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81149c08:	defffe04 	addi	sp,sp,-8
81149c0c:	de00012e 	bgeu	sp,et,81149c14 <alt_get_errno+0xc>
81149c10:	003b68fa 	trap	3
81149c14:	dfc00115 	stw	ra,4(sp)
81149c18:	df000015 	stw	fp,0(sp)
81149c1c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81149c20:	d0a01017 	ldw	r2,-32704(gp)
81149c24:	10000326 	beq	r2,zero,81149c34 <alt_get_errno+0x2c>
81149c28:	d0a01017 	ldw	r2,-32704(gp)
81149c2c:	103ee83a 	callr	r2
81149c30:	00000106 	br	81149c38 <alt_get_errno+0x30>
81149c34:	d0a07804 	addi	r2,gp,-32288
}
81149c38:	e037883a 	mov	sp,fp
81149c3c:	dfc00117 	ldw	ra,4(sp)
81149c40:	df000017 	ldw	fp,0(sp)
81149c44:	dec00204 	addi	sp,sp,8
81149c48:	f800283a 	ret

81149c4c <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
81149c4c:	defffa04 	addi	sp,sp,-24
81149c50:	de00012e 	bgeu	sp,et,81149c58 <alt_dev_llist_insert+0xc>
81149c54:	003b68fa 	trap	3
81149c58:	dfc00515 	stw	ra,20(sp)
81149c5c:	df000415 	stw	fp,16(sp)
81149c60:	df000404 	addi	fp,sp,16
81149c64:	e13ffe15 	stw	r4,-8(fp)
81149c68:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
81149c6c:	e0bffe17 	ldw	r2,-8(fp)
81149c70:	10000326 	beq	r2,zero,81149c80 <alt_dev_llist_insert+0x34>
81149c74:	e0bffe17 	ldw	r2,-8(fp)
81149c78:	10800217 	ldw	r2,8(r2)
81149c7c:	1000061e 	bne	r2,zero,81149c98 <alt_dev_llist_insert+0x4c>
  {
    ALT_ERRNO = EINVAL;
81149c80:	1149c080 	call	81149c08 <alt_get_errno>
81149c84:	1007883a 	mov	r3,r2
81149c88:	00800584 	movi	r2,22
81149c8c:	18800015 	stw	r2,0(r3)
    return -EINVAL;
81149c90:	00bffa84 	movi	r2,-22
81149c94:	00001306 	br	81149ce4 <alt_dev_llist_insert+0x98>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
81149c98:	e0bffe17 	ldw	r2,-8(fp)
81149c9c:	e0ffff17 	ldw	r3,-4(fp)
81149ca0:	e0fffc15 	stw	r3,-16(fp)
81149ca4:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
81149ca8:	e0bffd17 	ldw	r2,-12(fp)
81149cac:	e0fffc17 	ldw	r3,-16(fp)
81149cb0:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
81149cb4:	e0bffc17 	ldw	r2,-16(fp)
81149cb8:	10c00017 	ldw	r3,0(r2)
81149cbc:	e0bffd17 	ldw	r2,-12(fp)
81149cc0:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
81149cc4:	e0bffc17 	ldw	r2,-16(fp)
81149cc8:	10800017 	ldw	r2,0(r2)
81149ccc:	e0fffd17 	ldw	r3,-12(fp)
81149cd0:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
81149cd4:	e0bffc17 	ldw	r2,-16(fp)
81149cd8:	e0fffd17 	ldw	r3,-12(fp)
81149cdc:	10c00015 	stw	r3,0(r2)

  return 0;  
81149ce0:	0005883a 	mov	r2,zero
}
81149ce4:	e037883a 	mov	sp,fp
81149ce8:	dfc00117 	ldw	ra,4(sp)
81149cec:	df000017 	ldw	fp,0(sp)
81149cf0:	dec00204 	addi	sp,sp,8
81149cf4:	f800283a 	ret

81149cf8 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
81149cf8:	defffa04 	addi	sp,sp,-24
81149cfc:	de00012e 	bgeu	sp,et,81149d04 <alt_find_dev+0xc>
81149d00:	003b68fa 	trap	3
81149d04:	dfc00515 	stw	ra,20(sp)
81149d08:	df000415 	stw	fp,16(sp)
81149d0c:	df000404 	addi	fp,sp,16
81149d10:	e13ffe15 	stw	r4,-8(fp)
81149d14:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
81149d18:	e0bfff17 	ldw	r2,-4(fp)
81149d1c:	10800017 	ldw	r2,0(r2)
81149d20:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
81149d24:	e13ffe17 	ldw	r4,-8(fp)
81149d28:	1122b480 	call	81122b48 <strlen>
81149d2c:	10800044 	addi	r2,r2,1
81149d30:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
81149d34:	00000d06 	br	81149d6c <alt_find_dev+0x74>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
81149d38:	e0bffc17 	ldw	r2,-16(fp)
81149d3c:	10800217 	ldw	r2,8(r2)
81149d40:	e0fffd17 	ldw	r3,-12(fp)
81149d44:	180d883a 	mov	r6,r3
81149d48:	e17ffe17 	ldw	r5,-8(fp)
81149d4c:	1009883a 	mov	r4,r2
81149d50:	114ab0c0 	call	8114ab0c <memcmp>
81149d54:	1000021e 	bne	r2,zero,81149d60 <alt_find_dev+0x68>
    {
      /* match found */

      return next;
81149d58:	e0bffc17 	ldw	r2,-16(fp)
81149d5c:	00000706 	br	81149d7c <alt_find_dev+0x84>
    }
    next = (alt_dev*) next->llist.next;
81149d60:	e0bffc17 	ldw	r2,-16(fp)
81149d64:	10800017 	ldw	r2,0(r2)
81149d68:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
81149d6c:	e0fffc17 	ldw	r3,-16(fp)
81149d70:	e0bfff17 	ldw	r2,-4(fp)
81149d74:	18bff01e 	bne	r3,r2,81149d38 <__reset+0xfb129d38>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
81149d78:	0005883a 	mov	r2,zero
}
81149d7c:	e037883a 	mov	sp,fp
81149d80:	dfc00117 	ldw	ra,4(sp)
81149d84:	df000017 	ldw	fp,0(sp)
81149d88:	dec00204 	addi	sp,sp,8
81149d8c:	f800283a 	ret

81149d90 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
81149d90:	defffb04 	addi	sp,sp,-20
81149d94:	de00012e 	bgeu	sp,et,81149d9c <alt_find_file+0xc>
81149d98:	003b68fa 	trap	3
81149d9c:	dfc00415 	stw	ra,16(sp)
81149da0:	df000315 	stw	fp,12(sp)
81149da4:	df000304 	addi	fp,sp,12
81149da8:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
81149dac:	d0a00b17 	ldw	r2,-32724(gp)
81149db0:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
81149db4:	00003106 	br	81149e7c <alt_find_file+0xec>
  {
    len = strlen(next->name);
81149db8:	e0bffd17 	ldw	r2,-12(fp)
81149dbc:	10800217 	ldw	r2,8(r2)
81149dc0:	1009883a 	mov	r4,r2
81149dc4:	1122b480 	call	81122b48 <strlen>
81149dc8:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
81149dcc:	e0bffd17 	ldw	r2,-12(fp)
81149dd0:	10c00217 	ldw	r3,8(r2)
81149dd4:	e0bffe17 	ldw	r2,-8(fp)
81149dd8:	10bfffc4 	addi	r2,r2,-1
81149ddc:	1885883a 	add	r2,r3,r2
81149de0:	10800003 	ldbu	r2,0(r2)
81149de4:	10803fcc 	andi	r2,r2,255
81149de8:	1080201c 	xori	r2,r2,128
81149dec:	10bfe004 	addi	r2,r2,-128
81149df0:	10800bd8 	cmpnei	r2,r2,47
81149df4:	1000031e 	bne	r2,zero,81149e04 <alt_find_file+0x74>
    {
      len -= 1;
81149df8:	e0bffe17 	ldw	r2,-8(fp)
81149dfc:	10bfffc4 	addi	r2,r2,-1
81149e00:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
81149e04:	e0bffe17 	ldw	r2,-8(fp)
81149e08:	e0ffff17 	ldw	r3,-4(fp)
81149e0c:	1885883a 	add	r2,r3,r2
81149e10:	10800003 	ldbu	r2,0(r2)
81149e14:	10803fcc 	andi	r2,r2,255
81149e18:	1080201c 	xori	r2,r2,128
81149e1c:	10bfe004 	addi	r2,r2,-128
81149e20:	10800be0 	cmpeqi	r2,r2,47
81149e24:	1000081e 	bne	r2,zero,81149e48 <alt_find_file+0xb8>
81149e28:	e0bffe17 	ldw	r2,-8(fp)
81149e2c:	e0ffff17 	ldw	r3,-4(fp)
81149e30:	1885883a 	add	r2,r3,r2
81149e34:	10800003 	ldbu	r2,0(r2)
81149e38:	10803fcc 	andi	r2,r2,255
81149e3c:	1080201c 	xori	r2,r2,128
81149e40:	10bfe004 	addi	r2,r2,-128
81149e44:	10000a1e 	bne	r2,zero,81149e70 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
81149e48:	e0bffd17 	ldw	r2,-12(fp)
81149e4c:	10800217 	ldw	r2,8(r2)
81149e50:	e0fffe17 	ldw	r3,-8(fp)
81149e54:	180d883a 	mov	r6,r3
81149e58:	e17fff17 	ldw	r5,-4(fp)
81149e5c:	1009883a 	mov	r4,r2
81149e60:	114ab0c0 	call	8114ab0c <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
81149e64:	1000021e 	bne	r2,zero,81149e70 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
81149e68:	e0bffd17 	ldw	r2,-12(fp)
81149e6c:	00000706 	br	81149e8c <alt_find_file+0xfc>
    }
    next = (alt_dev*) next->llist.next;
81149e70:	e0bffd17 	ldw	r2,-12(fp)
81149e74:	10800017 	ldw	r2,0(r2)
81149e78:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
81149e7c:	e0fffd17 	ldw	r3,-12(fp)
81149e80:	d0a00b04 	addi	r2,gp,-32724
81149e84:	18bfcc1e 	bne	r3,r2,81149db8 <__reset+0xfb129db8>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
81149e88:	0005883a 	mov	r2,zero
}
81149e8c:	e037883a 	mov	sp,fp
81149e90:	dfc00117 	ldw	ra,4(sp)
81149e94:	df000017 	ldw	fp,0(sp)
81149e98:	dec00204 	addi	sp,sp,8
81149e9c:	f800283a 	ret

81149ea0 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
81149ea0:	defff904 	addi	sp,sp,-28
81149ea4:	de00012e 	bgeu	sp,et,81149eac <alt_get_fd+0xc>
81149ea8:	003b68fa 	trap	3
81149eac:	dfc00615 	stw	ra,24(sp)
81149eb0:	df000515 	stw	fp,20(sp)
81149eb4:	df000504 	addi	fp,sp,20
81149eb8:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
81149ebc:	00bffa04 	movi	r2,-24
81149ec0:	e0bffc15 	stw	r2,-16(fp)
  /* 
   * Take the alt_fd_list_lock semaphore in order to avoid races when 
   * accessing the file descriptor pool.
   */
  
  ALT_SEM_PEND(alt_fd_list_lock, 0);
81149ec4:	d0a07f17 	ldw	r2,-32260(gp)
81149ec8:	e0bffd15 	stw	r2,-12(fp)
81149ecc:	e03ffe0d 	sth	zero,-8(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
81149ed0:	e0bffe0b 	ldhu	r2,-8(fp)
81149ed4:	e0fffe84 	addi	r3,fp,-6
81149ed8:	180d883a 	mov	r6,r3
81149edc:	100b883a 	mov	r5,r2
81149ee0:	e13ffd17 	ldw	r4,-12(fp)
81149ee4:	113e4c00 	call	8113e4c0 <OSSemPend>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
81149ee8:	e03ffb15 	stw	zero,-20(fp)
81149eec:	00001906 	br	81149f54 <alt_get_fd+0xb4>
  {
    if (!alt_fd_list[i].dev)
81149ef0:	00a04574 	movhi	r2,33045
81149ef4:	1085c004 	addi	r2,r2,5888
81149ef8:	e0fffb17 	ldw	r3,-20(fp)
81149efc:	18c00324 	muli	r3,r3,12
81149f00:	10c5883a 	add	r2,r2,r3
81149f04:	10800017 	ldw	r2,0(r2)
81149f08:	10000f1e 	bne	r2,zero,81149f48 <alt_get_fd+0xa8>
    {
      alt_fd_list[i].dev = dev;
81149f0c:	00a04574 	movhi	r2,33045
81149f10:	1085c004 	addi	r2,r2,5888
81149f14:	e0fffb17 	ldw	r3,-20(fp)
81149f18:	18c00324 	muli	r3,r3,12
81149f1c:	10c5883a 	add	r2,r2,r3
81149f20:	e0ffff17 	ldw	r3,-4(fp)
81149f24:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
81149f28:	d0e00f17 	ldw	r3,-32708(gp)
81149f2c:	e0bffb17 	ldw	r2,-20(fp)
81149f30:	1880020e 	bge	r3,r2,81149f3c <alt_get_fd+0x9c>
      {
        alt_max_fd = i;
81149f34:	e0bffb17 	ldw	r2,-20(fp)
81149f38:	d0a00f15 	stw	r2,-32708(gp)
      }
      rc = i;
81149f3c:	e0bffb17 	ldw	r2,-20(fp)
81149f40:	e0bffc15 	stw	r2,-16(fp)
      goto alt_get_fd_exit;
81149f44:	00000606 	br	81149f60 <alt_get_fd+0xc0>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
81149f48:	e0bffb17 	ldw	r2,-20(fp)
81149f4c:	10800044 	addi	r2,r2,1
81149f50:	e0bffb15 	stw	r2,-20(fp)
81149f54:	e0bffb17 	ldw	r2,-20(fp)
81149f58:	10800810 	cmplti	r2,r2,32
81149f5c:	103fe41e 	bne	r2,zero,81149ef0 <__reset+0xfb129ef0>
  /*
   * Release the alt_fd_list_lock semaphore now that we are done with the
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);
81149f60:	d0a07f17 	ldw	r2,-32260(gp)
81149f64:	1009883a 	mov	r4,r2
81149f68:	113e8480 	call	8113e848 <OSSemPost>

  return rc;
81149f6c:	e0bffc17 	ldw	r2,-16(fp)
}
81149f70:	e037883a 	mov	sp,fp
81149f74:	dfc00117 	ldw	ra,4(sp)
81149f78:	df000017 	ldw	fp,0(sp)
81149f7c:	dec00204 	addi	sp,sp,8
81149f80:	f800283a 	ret

81149f84 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
81149f84:	defff904 	addi	sp,sp,-28
81149f88:	de00012e 	bgeu	sp,et,81149f90 <alt_ic_isr_register+0xc>
81149f8c:	003b68fa 	trap	3
81149f90:	dfc00615 	stw	ra,24(sp)
81149f94:	df000515 	stw	fp,20(sp)
81149f98:	df000504 	addi	fp,sp,20
81149f9c:	e13ffc15 	stw	r4,-16(fp)
81149fa0:	e17ffd15 	stw	r5,-12(fp)
81149fa4:	e1bffe15 	stw	r6,-8(fp)
81149fa8:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
81149fac:	e0800217 	ldw	r2,8(fp)
81149fb0:	d8800015 	stw	r2,0(sp)
81149fb4:	e1ffff17 	ldw	r7,-4(fp)
81149fb8:	e1bffe17 	ldw	r6,-8(fp)
81149fbc:	e17ffd17 	ldw	r5,-12(fp)
81149fc0:	e13ffc17 	ldw	r4,-16(fp)
81149fc4:	114a1540 	call	8114a154 <alt_iic_isr_register>
}  
81149fc8:	e037883a 	mov	sp,fp
81149fcc:	dfc00117 	ldw	ra,4(sp)
81149fd0:	df000017 	ldw	fp,0(sp)
81149fd4:	dec00204 	addi	sp,sp,8
81149fd8:	f800283a 	ret

81149fdc <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
81149fdc:	defff904 	addi	sp,sp,-28
81149fe0:	de00012e 	bgeu	sp,et,81149fe8 <alt_ic_irq_enable+0xc>
81149fe4:	003b68fa 	trap	3
81149fe8:	df000615 	stw	fp,24(sp)
81149fec:	df000604 	addi	fp,sp,24
81149ff0:	e13ffe15 	stw	r4,-8(fp)
81149ff4:	e17fff15 	stw	r5,-4(fp)
81149ff8:	e0bfff17 	ldw	r2,-4(fp)
81149ffc:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114a000:	0005303a 	rdctl	r2,status
8114a004:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114a008:	e0fffb17 	ldw	r3,-20(fp)
8114a00c:	00bfff84 	movi	r2,-2
8114a010:	1884703a 	and	r2,r3,r2
8114a014:	1001703a 	wrctl	status,r2
  
  return context;
8114a018:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
8114a01c:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
8114a020:	00c00044 	movi	r3,1
8114a024:	e0bffa17 	ldw	r2,-24(fp)
8114a028:	1884983a 	sll	r2,r3,r2
8114a02c:	1007883a 	mov	r3,r2
8114a030:	d0a08017 	ldw	r2,-32256(gp)
8114a034:	1884b03a 	or	r2,r3,r2
8114a038:	d0a08015 	stw	r2,-32256(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
8114a03c:	d0a08017 	ldw	r2,-32256(gp)
8114a040:	100170fa 	wrctl	ienable,r2
8114a044:	e0bffc17 	ldw	r2,-16(fp)
8114a048:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114a04c:	e0bffd17 	ldw	r2,-12(fp)
8114a050:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
8114a054:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
8114a058:	0001883a 	nop
}
8114a05c:	e037883a 	mov	sp,fp
8114a060:	df000017 	ldw	fp,0(sp)
8114a064:	dec00104 	addi	sp,sp,4
8114a068:	f800283a 	ret

8114a06c <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
8114a06c:	defff904 	addi	sp,sp,-28
8114a070:	de00012e 	bgeu	sp,et,8114a078 <alt_ic_irq_disable+0xc>
8114a074:	003b68fa 	trap	3
8114a078:	df000615 	stw	fp,24(sp)
8114a07c:	df000604 	addi	fp,sp,24
8114a080:	e13ffe15 	stw	r4,-8(fp)
8114a084:	e17fff15 	stw	r5,-4(fp)
8114a088:	e0bfff17 	ldw	r2,-4(fp)
8114a08c:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114a090:	0005303a 	rdctl	r2,status
8114a094:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114a098:	e0fffb17 	ldw	r3,-20(fp)
8114a09c:	00bfff84 	movi	r2,-2
8114a0a0:	1884703a 	and	r2,r3,r2
8114a0a4:	1001703a 	wrctl	status,r2
  
  return context;
8114a0a8:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
8114a0ac:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
8114a0b0:	00c00044 	movi	r3,1
8114a0b4:	e0bffa17 	ldw	r2,-24(fp)
8114a0b8:	1884983a 	sll	r2,r3,r2
8114a0bc:	0084303a 	nor	r2,zero,r2
8114a0c0:	1007883a 	mov	r3,r2
8114a0c4:	d0a08017 	ldw	r2,-32256(gp)
8114a0c8:	1884703a 	and	r2,r3,r2
8114a0cc:	d0a08015 	stw	r2,-32256(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
8114a0d0:	d0a08017 	ldw	r2,-32256(gp)
8114a0d4:	100170fa 	wrctl	ienable,r2
8114a0d8:	e0bffc17 	ldw	r2,-16(fp)
8114a0dc:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114a0e0:	e0bffd17 	ldw	r2,-12(fp)
8114a0e4:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
8114a0e8:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
8114a0ec:	0001883a 	nop
}
8114a0f0:	e037883a 	mov	sp,fp
8114a0f4:	df000017 	ldw	fp,0(sp)
8114a0f8:	dec00104 	addi	sp,sp,4
8114a0fc:	f800283a 	ret

8114a100 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
8114a100:	defffc04 	addi	sp,sp,-16
8114a104:	de00012e 	bgeu	sp,et,8114a10c <alt_ic_irq_enabled+0xc>
8114a108:	003b68fa 	trap	3
8114a10c:	df000315 	stw	fp,12(sp)
8114a110:	df000304 	addi	fp,sp,12
8114a114:	e13ffe15 	stw	r4,-8(fp)
8114a118:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
8114a11c:	000530fa 	rdctl	r2,ienable
8114a120:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
8114a124:	00c00044 	movi	r3,1
8114a128:	e0bfff17 	ldw	r2,-4(fp)
8114a12c:	1884983a 	sll	r2,r3,r2
8114a130:	1007883a 	mov	r3,r2
8114a134:	e0bffd17 	ldw	r2,-12(fp)
8114a138:	1884703a 	and	r2,r3,r2
8114a13c:	1004c03a 	cmpne	r2,r2,zero
8114a140:	10803fcc 	andi	r2,r2,255
}
8114a144:	e037883a 	mov	sp,fp
8114a148:	df000017 	ldw	fp,0(sp)
8114a14c:	dec00104 	addi	sp,sp,4
8114a150:	f800283a 	ret

8114a154 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
8114a154:	defff504 	addi	sp,sp,-44
8114a158:	de00012e 	bgeu	sp,et,8114a160 <alt_iic_isr_register+0xc>
8114a15c:	003b68fa 	trap	3
8114a160:	dfc00a15 	stw	ra,40(sp)
8114a164:	df000915 	stw	fp,36(sp)
8114a168:	df000904 	addi	fp,sp,36
8114a16c:	e13ffc15 	stw	r4,-16(fp)
8114a170:	e17ffd15 	stw	r5,-12(fp)
8114a174:	e1bffe15 	stw	r6,-8(fp)
8114a178:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
8114a17c:	00bffa84 	movi	r2,-22
8114a180:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
8114a184:	e0bffd17 	ldw	r2,-12(fp)
8114a188:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
8114a18c:	e0bff817 	ldw	r2,-32(fp)
8114a190:	10800808 	cmpgei	r2,r2,32
8114a194:	1000271e 	bne	r2,zero,8114a234 <alt_iic_isr_register+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114a198:	0005303a 	rdctl	r2,status
8114a19c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114a1a0:	e0fffb17 	ldw	r3,-20(fp)
8114a1a4:	00bfff84 	movi	r2,-2
8114a1a8:	1884703a 	and	r2,r3,r2
8114a1ac:	1001703a 	wrctl	status,r2
  
  return context;
8114a1b0:	e0bffb17 	ldw	r2,-20(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
8114a1b4:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = isr;
8114a1b8:	00a045f4 	movhi	r2,33047
8114a1bc:	10b36304 	addi	r2,r2,-12916
8114a1c0:	e0fff817 	ldw	r3,-32(fp)
8114a1c4:	180690fa 	slli	r3,r3,3
8114a1c8:	10c5883a 	add	r2,r2,r3
8114a1cc:	e0fffe17 	ldw	r3,-8(fp)
8114a1d0:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
8114a1d4:	00a045f4 	movhi	r2,33047
8114a1d8:	10b36304 	addi	r2,r2,-12916
8114a1dc:	e0fff817 	ldw	r3,-32(fp)
8114a1e0:	180690fa 	slli	r3,r3,3
8114a1e4:	10c5883a 	add	r2,r2,r3
8114a1e8:	10800104 	addi	r2,r2,4
8114a1ec:	e0ffff17 	ldw	r3,-4(fp)
8114a1f0:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
8114a1f4:	e0bffe17 	ldw	r2,-8(fp)
8114a1f8:	10000526 	beq	r2,zero,8114a210 <alt_iic_isr_register+0xbc>
8114a1fc:	e0bff817 	ldw	r2,-32(fp)
8114a200:	100b883a 	mov	r5,r2
8114a204:	e13ffc17 	ldw	r4,-16(fp)
8114a208:	1149fdc0 	call	81149fdc <alt_ic_irq_enable>
8114a20c:	00000406 	br	8114a220 <alt_iic_isr_register+0xcc>
8114a210:	e0bff817 	ldw	r2,-32(fp)
8114a214:	100b883a 	mov	r5,r2
8114a218:	e13ffc17 	ldw	r4,-16(fp)
8114a21c:	114a06c0 	call	8114a06c <alt_ic_irq_disable>
8114a220:	e0bff715 	stw	r2,-36(fp)
8114a224:	e0bffa17 	ldw	r2,-24(fp)
8114a228:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114a22c:	e0bff917 	ldw	r2,-28(fp)
8114a230:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
8114a234:	e0bff717 	ldw	r2,-36(fp)
}
8114a238:	e037883a 	mov	sp,fp
8114a23c:	dfc00117 	ldw	ra,4(sp)
8114a240:	df000017 	ldw	fp,0(sp)
8114a244:	dec00204 	addi	sp,sp,8
8114a248:	f800283a 	ret

8114a24c <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
8114a24c:	defff904 	addi	sp,sp,-28
8114a250:	de00012e 	bgeu	sp,et,8114a258 <alt_open_fd+0xc>
8114a254:	003b68fa 	trap	3
8114a258:	dfc00615 	stw	ra,24(sp)
8114a25c:	df000515 	stw	fp,20(sp)
8114a260:	df000504 	addi	fp,sp,20
8114a264:	e13ffc15 	stw	r4,-16(fp)
8114a268:	e17ffd15 	stw	r5,-12(fp)
8114a26c:	e1bffe15 	stw	r6,-8(fp)
8114a270:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
8114a274:	e1bfff17 	ldw	r6,-4(fp)
8114a278:	e17ffe17 	ldw	r5,-8(fp)
8114a27c:	e13ffd17 	ldw	r4,-12(fp)
8114a280:	11370fc0 	call	811370fc <open>
8114a284:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
8114a288:	e0bffb17 	ldw	r2,-20(fp)
8114a28c:	10001c16 	blt	r2,zero,8114a300 <alt_open_fd+0xb4>
  {
    fd->dev      = alt_fd_list[old].dev;
8114a290:	00a04574 	movhi	r2,33045
8114a294:	1085c004 	addi	r2,r2,5888
8114a298:	e0fffb17 	ldw	r3,-20(fp)
8114a29c:	18c00324 	muli	r3,r3,12
8114a2a0:	10c5883a 	add	r2,r2,r3
8114a2a4:	10c00017 	ldw	r3,0(r2)
8114a2a8:	e0bffc17 	ldw	r2,-16(fp)
8114a2ac:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
8114a2b0:	00a04574 	movhi	r2,33045
8114a2b4:	1085c004 	addi	r2,r2,5888
8114a2b8:	e0fffb17 	ldw	r3,-20(fp)
8114a2bc:	18c00324 	muli	r3,r3,12
8114a2c0:	10c5883a 	add	r2,r2,r3
8114a2c4:	10800104 	addi	r2,r2,4
8114a2c8:	10c00017 	ldw	r3,0(r2)
8114a2cc:	e0bffc17 	ldw	r2,-16(fp)
8114a2d0:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
8114a2d4:	00a04574 	movhi	r2,33045
8114a2d8:	1085c004 	addi	r2,r2,5888
8114a2dc:	e0fffb17 	ldw	r3,-20(fp)
8114a2e0:	18c00324 	muli	r3,r3,12
8114a2e4:	10c5883a 	add	r2,r2,r3
8114a2e8:	10800204 	addi	r2,r2,8
8114a2ec:	10c00017 	ldw	r3,0(r2)
8114a2f0:	e0bffc17 	ldw	r2,-16(fp)
8114a2f4:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
8114a2f8:	e13ffb17 	ldw	r4,-20(fp)
8114a2fc:	11373a00 	call	811373a0 <alt_release_fd>
  }
} 
8114a300:	0001883a 	nop
8114a304:	e037883a 	mov	sp,fp
8114a308:	dfc00117 	ldw	ra,4(sp)
8114a30c:	df000017 	ldw	fp,0(sp)
8114a310:	dec00204 	addi	sp,sp,8
8114a314:	f800283a 	ret

8114a318 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
8114a318:	defffb04 	addi	sp,sp,-20
8114a31c:	de00012e 	bgeu	sp,et,8114a324 <alt_io_redirect+0xc>
8114a320:	003b68fa 	trap	3
8114a324:	dfc00415 	stw	ra,16(sp)
8114a328:	df000315 	stw	fp,12(sp)
8114a32c:	df000304 	addi	fp,sp,12
8114a330:	e13ffd15 	stw	r4,-12(fp)
8114a334:	e17ffe15 	stw	r5,-8(fp)
8114a338:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
8114a33c:	01c07fc4 	movi	r7,511
8114a340:	01800044 	movi	r6,1
8114a344:	e17ffd17 	ldw	r5,-12(fp)
8114a348:	01204574 	movhi	r4,33045
8114a34c:	2105c304 	addi	r4,r4,5900
8114a350:	114a24c0 	call	8114a24c <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
8114a354:	01c07fc4 	movi	r7,511
8114a358:	000d883a 	mov	r6,zero
8114a35c:	e17ffe17 	ldw	r5,-8(fp)
8114a360:	01204574 	movhi	r4,33045
8114a364:	2105c004 	addi	r4,r4,5888
8114a368:	114a24c0 	call	8114a24c <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
8114a36c:	01c07fc4 	movi	r7,511
8114a370:	01800044 	movi	r6,1
8114a374:	e17fff17 	ldw	r5,-4(fp)
8114a378:	01204574 	movhi	r4,33045
8114a37c:	2105c604 	addi	r4,r4,5912
8114a380:	114a24c0 	call	8114a24c <alt_open_fd>
}  
8114a384:	0001883a 	nop
8114a388:	e037883a 	mov	sp,fp
8114a38c:	dfc00117 	ldw	ra,4(sp)
8114a390:	df000017 	ldw	fp,0(sp)
8114a394:	dec00204 	addi	sp,sp,8
8114a398:	f800283a 	ret

8114a39c <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
8114a39c:	defff204 	addi	sp,sp,-56
8114a3a0:	de00012e 	bgeu	sp,et,8114a3a8 <alt_printf+0xc>
8114a3a4:	003b68fa 	trap	3
8114a3a8:	dfc00a15 	stw	ra,40(sp)
8114a3ac:	df000915 	stw	fp,36(sp)
8114a3b0:	df000904 	addi	fp,sp,36
8114a3b4:	e13fff15 	stw	r4,-4(fp)
8114a3b8:	e1400215 	stw	r5,8(fp)
8114a3bc:	e1800315 	stw	r6,12(fp)
8114a3c0:	e1c00415 	stw	r7,16(fp)
	va_list args;
	va_start(args, fmt);
8114a3c4:	e0800204 	addi	r2,fp,8
8114a3c8:	e0bffe15 	stw	r2,-8(fp)
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
8114a3cc:	e0bfff17 	ldw	r2,-4(fp)
8114a3d0:	e0bff715 	stw	r2,-36(fp)
    while ((c = *w++) != 0)
8114a3d4:	00006f06 	br	8114a594 <alt_printf+0x1f8>
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
8114a3d8:	e0bff807 	ldb	r2,-32(fp)
8114a3dc:	10800960 	cmpeqi	r2,r2,37
8114a3e0:	1000041e 	bne	r2,zero,8114a3f4 <alt_printf+0x58>
        {
            alt_putchar(c);
8114a3e4:	e0bff807 	ldb	r2,-32(fp)
8114a3e8:	1009883a 	mov	r4,r2
8114a3ec:	114a5d00 	call	8114a5d0 <alt_putchar>
8114a3f0:	00006806 	br	8114a594 <alt_printf+0x1f8>
        }
        else
        {
            /* Get format character.  If none     */
            /* available, processing is complete. */
            if ((c = *w++) != 0)
8114a3f4:	e0bff717 	ldw	r2,-36(fp)
8114a3f8:	10c00044 	addi	r3,r2,1
8114a3fc:	e0fff715 	stw	r3,-36(fp)
8114a400:	10800003 	ldbu	r2,0(r2)
8114a404:	e0bff805 	stb	r2,-32(fp)
8114a408:	e0bff807 	ldb	r2,-32(fp)
8114a40c:	10006926 	beq	r2,zero,8114a5b4 <alt_printf+0x218>
            {
                if (c == '%')
8114a410:	e0bff807 	ldb	r2,-32(fp)
8114a414:	10800958 	cmpnei	r2,r2,37
8114a418:	1000041e 	bne	r2,zero,8114a42c <alt_printf+0x90>
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
8114a41c:	e0bff807 	ldb	r2,-32(fp)
8114a420:	1009883a 	mov	r4,r2
8114a424:	114a5d00 	call	8114a5d0 <alt_putchar>
8114a428:	00005a06 	br	8114a594 <alt_printf+0x1f8>
                } 
                else if (c == 'c')
8114a42c:	e0bff807 	ldb	r2,-32(fp)
8114a430:	108018d8 	cmpnei	r2,r2,99
8114a434:	1000081e 	bne	r2,zero,8114a458 <alt_printf+0xbc>
                {
                    int v = va_arg(args, int);
8114a438:	e0bffe17 	ldw	r2,-8(fp)
8114a43c:	10c00104 	addi	r3,r2,4
8114a440:	e0fffe15 	stw	r3,-8(fp)
8114a444:	10800017 	ldw	r2,0(r2)
8114a448:	e0bffd15 	stw	r2,-12(fp)
                    alt_putchar(v);
8114a44c:	e13ffd17 	ldw	r4,-12(fp)
8114a450:	114a5d00 	call	8114a5d0 <alt_putchar>
8114a454:	00004f06 	br	8114a594 <alt_printf+0x1f8>
                }
                else if (c == 'x')
8114a458:	e0bff807 	ldb	r2,-32(fp)
8114a45c:	10801e18 	cmpnei	r2,r2,120
8114a460:	1000341e 	bne	r2,zero,8114a534 <alt_printf+0x198>
                {
                    /* Process hexadecimal number format. */
                    unsigned long v = va_arg(args, unsigned long);
8114a464:	e0bffe17 	ldw	r2,-8(fp)
8114a468:	10c00104 	addi	r3,r2,4
8114a46c:	e0fffe15 	stw	r3,-8(fp)
8114a470:	10800017 	ldw	r2,0(r2)
8114a474:	e0bffb15 	stw	r2,-20(fp)
                    unsigned long digit;
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
8114a478:	e0bffb17 	ldw	r2,-20(fp)
8114a47c:	1000031e 	bne	r2,zero,8114a48c <alt_printf+0xf0>
                    {
                        alt_putchar('0');
8114a480:	01000c04 	movi	r4,48
8114a484:	114a5d00 	call	8114a5d0 <alt_putchar>
                        continue;
8114a488:	00004206 	br	8114a594 <alt_printf+0x1f8>
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
8114a48c:	00800704 	movi	r2,28
8114a490:	e0bff915 	stw	r2,-28(fp)
                    while (!(v & (0xF << digit_shift)))
8114a494:	00000306 	br	8114a4a4 <alt_printf+0x108>
                        digit_shift -= 4;
8114a498:	e0bff917 	ldw	r2,-28(fp)
8114a49c:	10bfff04 	addi	r2,r2,-4
8114a4a0:	e0bff915 	stw	r2,-28(fp)
                        continue;
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
8114a4a4:	00c003c4 	movi	r3,15
8114a4a8:	e0bff917 	ldw	r2,-28(fp)
8114a4ac:	1884983a 	sll	r2,r3,r2
8114a4b0:	1007883a 	mov	r3,r2
8114a4b4:	e0bffb17 	ldw	r2,-20(fp)
8114a4b8:	1884703a 	and	r2,r3,r2
8114a4bc:	103ff626 	beq	r2,zero,8114a498 <__reset+0xfb12a498>
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
8114a4c0:	00001906 	br	8114a528 <alt_printf+0x18c>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
8114a4c4:	00c003c4 	movi	r3,15
8114a4c8:	e0bff917 	ldw	r2,-28(fp)
8114a4cc:	1884983a 	sll	r2,r3,r2
8114a4d0:	1007883a 	mov	r3,r2
8114a4d4:	e0bffb17 	ldw	r2,-20(fp)
8114a4d8:	1886703a 	and	r3,r3,r2
8114a4dc:	e0bff917 	ldw	r2,-28(fp)
8114a4e0:	1884d83a 	srl	r2,r3,r2
8114a4e4:	e0bffc15 	stw	r2,-16(fp)
                        if (digit <= 9)
8114a4e8:	e0bffc17 	ldw	r2,-16(fp)
8114a4ec:	108002a8 	cmpgeui	r2,r2,10
8114a4f0:	1000041e 	bne	r2,zero,8114a504 <alt_printf+0x168>
                            c = '0' + digit;
8114a4f4:	e0bffc17 	ldw	r2,-16(fp)
8114a4f8:	10800c04 	addi	r2,r2,48
8114a4fc:	e0bff805 	stb	r2,-32(fp)
8114a500:	00000306 	br	8114a510 <alt_printf+0x174>
                        else
                            c = 'a' + digit - 10;
8114a504:	e0bffc17 	ldw	r2,-16(fp)
8114a508:	108015c4 	addi	r2,r2,87
8114a50c:	e0bff805 	stb	r2,-32(fp)
                        alt_putchar(c);
8114a510:	e0bff807 	ldb	r2,-32(fp)
8114a514:	1009883a 	mov	r4,r2
8114a518:	114a5d00 	call	8114a5d0 <alt_putchar>
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
8114a51c:	e0bff917 	ldw	r2,-28(fp)
8114a520:	10bfff04 	addi	r2,r2,-4
8114a524:	e0bff915 	stw	r2,-28(fp)
8114a528:	e0bff917 	ldw	r2,-28(fp)
8114a52c:	103fe50e 	bge	r2,zero,8114a4c4 <__reset+0xfb12a4c4>
8114a530:	00001806 	br	8114a594 <alt_printf+0x1f8>
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
8114a534:	e0bff807 	ldb	r2,-32(fp)
8114a538:	10801cd8 	cmpnei	r2,r2,115
8114a53c:	1000151e 	bne	r2,zero,8114a594 <alt_printf+0x1f8>
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);
8114a540:	e0bffe17 	ldw	r2,-8(fp)
8114a544:	10c00104 	addi	r3,r2,4
8114a548:	e0fffe15 	stw	r3,-8(fp)
8114a54c:	10800017 	ldw	r2,0(r2)
8114a550:	e0bffa15 	stw	r2,-24(fp)

                    while(*s)
8114a554:	00000906 	br	8114a57c <alt_printf+0x1e0>
                      alt_putchar(*s++);
8114a558:	e0bffa17 	ldw	r2,-24(fp)
8114a55c:	10c00044 	addi	r3,r2,1
8114a560:	e0fffa15 	stw	r3,-24(fp)
8114a564:	10800003 	ldbu	r2,0(r2)
8114a568:	10803fcc 	andi	r2,r2,255
8114a56c:	1080201c 	xori	r2,r2,128
8114a570:	10bfe004 	addi	r2,r2,-128
8114a574:	1009883a 	mov	r4,r2
8114a578:	114a5d00 	call	8114a5d0 <alt_putchar>
                else if (c == 's')
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);

                    while(*s)
8114a57c:	e0bffa17 	ldw	r2,-24(fp)
8114a580:	10800003 	ldbu	r2,0(r2)
8114a584:	10803fcc 	andi	r2,r2,255
8114a588:	1080201c 	xori	r2,r2,128
8114a58c:	10bfe004 	addi	r2,r2,-128
8114a590:	103ff11e 	bne	r2,zero,8114a558 <__reset+0xfb12a558>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
8114a594:	e0bff717 	ldw	r2,-36(fp)
8114a598:	10c00044 	addi	r3,r2,1
8114a59c:	e0fff715 	stw	r3,-36(fp)
8114a5a0:	10800003 	ldbu	r2,0(r2)
8114a5a4:	e0bff805 	stb	r2,-32(fp)
8114a5a8:	e0bff807 	ldb	r2,-32(fp)
8114a5ac:	103f8a1e 	bne	r2,zero,8114a3d8 <__reset+0xfb12a3d8>
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
8114a5b0:	00000106 	br	8114a5b8 <alt_printf+0x21c>
                      alt_putchar(*s++);
                }
            }
            else
            {
                break;
8114a5b4:	0001883a 	nop
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
8114a5b8:	0001883a 	nop
8114a5bc:	e037883a 	mov	sp,fp
8114a5c0:	dfc00117 	ldw	ra,4(sp)
8114a5c4:	df000017 	ldw	fp,0(sp)
8114a5c8:	dec00504 	addi	sp,sp,20
8114a5cc:	f800283a 	ret

8114a5d0 <alt_putchar>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
8114a5d0:	defffd04 	addi	sp,sp,-12
8114a5d4:	de00012e 	bgeu	sp,et,8114a5dc <alt_putchar+0xc>
8114a5d8:	003b68fa 	trap	3
8114a5dc:	dfc00215 	stw	ra,8(sp)
8114a5e0:	df000115 	stw	fp,4(sp)
8114a5e4:	df000104 	addi	fp,sp,4
8114a5e8:	e13fff15 	stw	r4,-4(fp)
    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
        return -1;
    }
    return c;
#else
    return putchar(c);
8114a5ec:	d0a00517 	ldw	r2,-32748(gp)
8114a5f0:	10800217 	ldw	r2,8(r2)
8114a5f4:	100b883a 	mov	r5,r2
8114a5f8:	e13fff17 	ldw	r4,-4(fp)
8114a5fc:	11224580 	call	81122458 <putc>
#endif
#endif
}
8114a600:	e037883a 	mov	sp,fp
8114a604:	dfc00117 	ldw	ra,4(sp)
8114a608:	df000017 	ldw	fp,0(sp)
8114a60c:	dec00204 	addi	sp,sp,8
8114a610:	f800283a 	ret

8114a614 <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
8114a614:	deffff04 	addi	sp,sp,-4
8114a618:	de00012e 	bgeu	sp,et,8114a620 <altera_nios2_gen2_irq_init+0xc>
8114a61c:	003b68fa 	trap	3
8114a620:	df000015 	stw	fp,0(sp)
8114a624:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
8114a628:	000170fa 	wrctl	ienable,zero
}
8114a62c:	0001883a 	nop
8114a630:	e037883a 	mov	sp,fp
8114a634:	df000017 	ldw	fp,0(sp)
8114a638:	dec00104 	addi	sp,sp,4
8114a63c:	f800283a 	ret

8114a640 <OSCtxSw>:

      /* 
       * Save the remaining registers to the stack. 
       */

      addi sp, sp, -44
8114a640:	defff504 	addi	sp,sp,-44

#ifdef ALT_STACK_CHECK

      bltu  sp, et, .Lstack_overflow
8114a644:	de002436 	bltu	sp,et,8114a6d8 <OSCtxSw+0x98>

#endif

#if OS_THREAD_SAFE_NEWLIB
      ldw r3, %gprel(_impure_ptr)(gp)   /* load the pointer */
8114a648:	d0e00517 	ldw	r3,-32748(gp)
#endif /* OS_THREAD_SAFE_NEWLIB */

      ldw r4, %gprel(OSTCBCur)(gp)
8114a64c:	d120a217 	ldw	r4,-32120(gp)

      stw ra,  0(sp)
8114a650:	dfc00015 	stw	ra,0(sp)
      stw fp,  4(sp)
8114a654:	df000115 	stw	fp,4(sp)
      stw r23, 8(sp)
8114a658:	ddc00215 	stw	r23,8(sp)
      stw r22, 12(sp)
8114a65c:	dd800315 	stw	r22,12(sp)
      stw r21, 16(sp)
8114a660:	dd400415 	stw	r21,16(sp)
      stw r20, 20(sp)
8114a664:	dd000515 	stw	r20,20(sp)
      stw r19, 24(sp)
8114a668:	dcc00615 	stw	r19,24(sp)
      stw r18, 28(sp)
8114a66c:	dc800715 	stw	r18,28(sp)
      stw r17, 32(sp)
8114a670:	dc400815 	stw	r17,32(sp)
      stw r16, 36(sp)
8114a674:	dc000915 	stw	r16,36(sp)
       * store the current value of _impure_ptr so it can be restored
       * later; _impure_ptr is asigned on a per task basis. It is used
       * by Newlib to achieve reentrancy.	
       */

      stw r3, 40(sp)                  /* save the impure pointer */
8114a678:	d8c00a15 	stw	r3,40(sp)
      /* 
       * Save the current tasks stack pointer into the current tasks OS_TCB.
       * i.e. OSTCBCur->OSTCBStkPtr = sp;
       */

      stw sp, (r4)                  /* save the stack pointer (OSTCBStkPtr */
8114a67c:	26c00015 	stw	sp,0(r4)

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
8114a680:	114a8dc0 	call	8114a8dc <OSTaskSwHook>
      /*
       * OSTCBCur = OSTCBHighRdy; 
       * OSPrioCur = OSPrioHighRdy; 
       */

      ldw r4, %gprel(OSTCBHighRdy)(gp)
8114a684:	d1209c17 	ldw	r4,-32144(gp)
      ldb r5, %gprel(OSPrioHighRdy)(gp)
8114a688:	d1609387 	ldb	r5,-32178(gp)

      stw r4, %gprel(OSTCBCur)(gp)     /* set the current task to be the new task */
8114a68c:	d120a215 	stw	r4,-32120(gp)
      stb r5, %gprel(OSPrioCur)(gp)    /* store the new task's priority as the current */
8114a690:	d16093c5 	stb	r5,-32177(gp)

      /*
       * Set the stack pointer to point to the new task's stack
       */

      ldw sp, (r4) /* the stack pointer is the first entry in the OS_TCB structure */
8114a694:	26c00017 	ldw	sp,0(r4)
      
#if defined(ALT_STACK_CHECK) && (OS_TASK_CREATE_EXT_EN > 0)

      ldw et, 8(r4)                  /* load the new stack limit */
8114a698:	26000217 	ldw	et,8(r4)
      /*
       * restore the value of _impure_ptr ; _impure_ptr is asigned on a 
       * per task basis. It is used by Newlib to achieve reentrancy.	
       */

      ldw r3, 40(sp)                  /* load the new impure pointer */
8114a69c:	d8c00a17 	ldw	r3,40(sp)

      /*
       * Restore the saved registers for the new task.
       */

      ldw ra,  0(sp)
8114a6a0:	dfc00017 	ldw	ra,0(sp)
      ldw fp,  4(sp)
8114a6a4:	df000117 	ldw	fp,4(sp)
      ldw r23, 8(sp)
8114a6a8:	ddc00217 	ldw	r23,8(sp)
      ldw r22, 12(sp)
8114a6ac:	dd800317 	ldw	r22,12(sp)
      ldw r21, 16(sp)
8114a6b0:	dd400417 	ldw	r21,16(sp)
      ldw r20, 20(sp)
8114a6b4:	dd000517 	ldw	r20,20(sp)
      ldw r19, 24(sp)
8114a6b8:	dcc00617 	ldw	r19,24(sp)
      ldw r18, 28(sp)
8114a6bc:	dc800717 	ldw	r18,28(sp)
      ldw r17, 32(sp)
8114a6c0:	dc400817 	ldw	r17,32(sp)
      ldw r16, 36(sp)
8114a6c4:	dc000917 	ldw	r16,36(sp)

#if OS_THREAD_SAFE_NEWLIB

      stw r3, %gprel(_impure_ptr)(gp) /* update _impure_ptr */
8114a6c8:	d0e00515 	stw	r3,-32748(gp)

#endif /* OS_THREAD_SAFE_NEWLIB */

#if defined(ALT_STACK_CHECK) && (OS_TASK_CREATE_EXT_EN > 0)

      stw et, %gprel(alt_stack_limit_value)(gp)
8114a6cc:	d6200015 	stw	et,-32768(gp)

#endif

      addi sp, sp, 44
8114a6d0:	dec00b04 	addi	sp,sp,44

      /*
       * resume execution of the new task.
       */

      ret
8114a6d4:	f800283a 	ret

#ifdef ALT_STACK_CHECK

.Lstack_overflow:
        break 3
8114a6d8:	003da0fa 	break	3

8114a6dc <OSStartHighRdy>:

      /*
       * disable interrupts so that the scheduler doesn't run while
       * we're initialising this task.
       */  
      rdctl r18, status
8114a6dc:	0025303a 	rdctl	r18,status
      subi  r17, zero, 2   /* r17 = 0xfffffffe */
8114a6e0:	047fff84 	movi	r17,-2
      and   r18, r18, r17
8114a6e4:	9464703a 	and	r18,r18,r17
      wrctl status, r18
8114a6e8:	9001703a 	wrctl	status,r18

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
8114a6ec:	114a8dc0 	call	8114a8dc <OSTaskSwHook>

      /* 
       * set OSRunning = TRUE.
       */

      movi r18, 1                    /* set r18 to the value 'TRUE' */
8114a6f0:	04800044 	movi	r18,1
      stb r18, %gprel(OSRunning)(gp) /* save this to OSRunning */
8114a6f4:	d4a09105 	stb	r18,-32188(gp)

      /*
       * start execution of the new task.
       */

      br 9b
8114a6f8:	003fe206 	br	8114a684 <__reset+0xfb12a684>

8114a6fc <OSStartTsk>:

OSStartTsk:
      /* This instruction is never executed.  Its here to make the
       * backtrace work right 
       */
      movi sp, 0
8114a6fc:	06c00004 	movi	sp,0

      /* Enable interrupts */
      rdctl r2, status
8114a700:	0005303a 	rdctl	r2,status
      ori   r2, r2, 0x1
8114a704:	10800054 	ori	r2,r2,1
      wrctl status, r2
8114a708:	1001703a 	wrctl	status,r2

      ldw r2, 4(sp)
8114a70c:	d8800117 	ldw	r2,4(sp)
      ldw r4, 0(sp)
8114a710:	d9000017 	ldw	r4,0(sp)

      addi sp, sp, 8
8114a714:	dec00204 	addi	sp,sp,8

      callr r2
8114a718:	103ee83a 	callr	r2

      nop
8114a71c:	0001883a 	nop

8114a720 <OSTaskStkInit>:
 *              been placed on the stack in the proper order.
 *
 ***********************************************************************************************/

OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *pstk, INT16U opt)
{
8114a720:	defff704 	addi	sp,sp,-36
8114a724:	de00012e 	bgeu	sp,et,8114a72c <OSTaskStkInit+0xc>
8114a728:	003b68fa 	trap	3
8114a72c:	dfc00815 	stw	ra,32(sp)
8114a730:	df000715 	stw	fp,28(sp)
8114a734:	df000704 	addi	fp,sp,28
8114a738:	e13ffc15 	stw	r4,-16(fp)
8114a73c:	e17ffd15 	stw	r5,-12(fp)
8114a740:	e1bffe15 	stw	r6,-8(fp)
8114a744:	3805883a 	mov	r2,r7
8114a748:	e0bfff0d 	sth	r2,-4(fp)
    * create and initialise the impure pointer used for Newlib thread local storage.
    * This is only done if the C library is being used in a thread safe mode. Otherwise
    * a single reent structure is used for all threads, which saves memory.
    */

   local_impure_ptr = (struct _reent*)((((INT32U)(pstk)) & ~0x3) - sizeof(struct _reent));
8114a74c:	e0fffe17 	ldw	r3,-8(fp)
8114a750:	00bfff04 	movi	r2,-4
8114a754:	1884703a 	and	r2,r3,r2
8114a758:	10bef704 	addi	r2,r2,-1060
8114a75c:	e0bff915 	stw	r2,-28(fp)

   _REENT_INIT_PTR (local_impure_ptr);
8114a760:	01810904 	movi	r6,1060
8114a764:	000b883a 	mov	r5,zero
8114a768:	e13ff917 	ldw	r4,-28(fp)
8114a76c:	11221a40 	call	811221a4 <memset>
8114a770:	e0bff917 	ldw	r2,-28(fp)
8114a774:	10c0bb04 	addi	r3,r2,748
8114a778:	e0bff917 	ldw	r2,-28(fp)
8114a77c:	10c00115 	stw	r3,4(r2)
8114a780:	e0bff917 	ldw	r2,-28(fp)
8114a784:	10c0d504 	addi	r3,r2,852
8114a788:	e0bff917 	ldw	r2,-28(fp)
8114a78c:	10c00215 	stw	r3,8(r2)
8114a790:	e0bff917 	ldw	r2,-28(fp)
8114a794:	10c0ef04 	addi	r3,r2,956
8114a798:	e0bff917 	ldw	r2,-28(fp)
8114a79c:	10c00315 	stw	r3,12(r2)
8114a7a0:	e0fff917 	ldw	r3,-28(fp)
8114a7a4:	00a04574 	movhi	r2,33045
8114a7a8:	10835904 	addi	r2,r2,3428
8114a7ac:	18800d15 	stw	r2,52(r3)
8114a7b0:	e0bff917 	ldw	r2,-28(fp)
8114a7b4:	00c00044 	movi	r3,1
8114a7b8:	10c02915 	stw	r3,164(r2)
8114a7bc:	10002a15 	stw	zero,168(r2)
8114a7c0:	e0bff917 	ldw	r2,-28(fp)
8114a7c4:	00ccc384 	movi	r3,13070
8114a7c8:	10c02b0d 	sth	r3,172(r2)
8114a7cc:	e0bff917 	ldw	r2,-28(fp)
8114a7d0:	00eaf344 	movi	r3,-21555
8114a7d4:	10c02b8d 	sth	r3,174(r2)
8114a7d8:	e0bff917 	ldw	r2,-28(fp)
8114a7dc:	00c48d04 	movi	r3,4660
8114a7e0:	10c02c0d 	sth	r3,176(r2)
8114a7e4:	e0bff917 	ldw	r2,-28(fp)
8114a7e8:	00f99b44 	movi	r3,-6547
8114a7ec:	10c02c8d 	sth	r3,178(r2)
8114a7f0:	e0bff917 	ldw	r2,-28(fp)
8114a7f4:	00f7bb04 	movi	r3,-8468
8114a7f8:	10c02d0d 	sth	r3,180(r2)
8114a7fc:	e0bff917 	ldw	r2,-28(fp)
8114a800:	00c00144 	movi	r3,5
8114a804:	10c02d8d 	sth	r3,182(r2)
8114a808:	e0bff917 	ldw	r2,-28(fp)
8114a80c:	00c002c4 	movi	r3,11
8114a810:	10c02e0d 	sth	r3,184(r2)
   /* 
    * create a stack frame at the top of the stack (leaving space for the 
    * reentrant data structure).
    */

   frame_pointer = (INT32U*) local_impure_ptr;
8114a814:	e0bff917 	ldw	r2,-28(fp)
8114a818:	e0bffa15 	stw	r2,-24(fp)
#else
   frame_pointer =   (INT32U*) (((INT32U)(pstk)) & ~0x3);
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk = frame_pointer - 13;
8114a81c:	e0bffa17 	ldw	r2,-24(fp)
8114a820:	10bff304 	addi	r2,r2,-52
8114a824:	e0bffb15 	stw	r2,-20(fp)

   /* Now fill the stack frame. */

   stk[12] = (INT32U)task;            /* task address (ra) */
8114a828:	e0bffb17 	ldw	r2,-20(fp)
8114a82c:	10800c04 	addi	r2,r2,48
8114a830:	e0fffc17 	ldw	r3,-16(fp)
8114a834:	10c00015 	stw	r3,0(r2)
   stk[11] = (INT32U) pdata;          /* first register argument (r4) */
8114a838:	e0bffb17 	ldw	r2,-20(fp)
8114a83c:	10800b04 	addi	r2,r2,44
8114a840:	e0fffd17 	ldw	r3,-12(fp)
8114a844:	10c00015 	stw	r3,0(r2)

#if OS_THREAD_SAFE_NEWLIB
   stk[10] = (INT32U) local_impure_ptr; /* value of _impure_ptr for this thread */
8114a848:	e0bffb17 	ldw	r2,-20(fp)
8114a84c:	10800a04 	addi	r2,r2,40
8114a850:	e0fff917 	ldw	r3,-28(fp)
8114a854:	10c00015 	stw	r3,0(r2)
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk[0]  = ((INT32U)&OSStartTsk) + 4;/* exception return address (ea) */  
8114a858:	00a04574 	movhi	r2,33045
8114a85c:	10a9bf04 	addi	r2,r2,-22788
8114a860:	10c00104 	addi	r3,r2,4
8114a864:	e0bffb17 	ldw	r2,-20(fp)
8114a868:	10c00015 	stw	r3,0(r2)
    */
   __asm__ (".set OSTCBNext_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBNext)));
   __asm__ (".set OSTCBPrio_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBPrio)));
   __asm__ (".set OSTCBStkPtr_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBStkPtr)));
  
   return((OS_STK *)stk);
8114a86c:	e0bffb17 	ldw	r2,-20(fp)
}
8114a870:	e037883a 	mov	sp,fp
8114a874:	dfc00117 	ldw	ra,4(sp)
8114a878:	df000017 	ldw	fp,0(sp)
8114a87c:	dec00204 	addi	sp,sp,8
8114a880:	f800283a 	ret

8114a884 <OSTaskCreateHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskCreateHook (OS_TCB *ptcb)
{
8114a884:	defffe04 	addi	sp,sp,-8
8114a888:	de00012e 	bgeu	sp,et,8114a890 <OSTaskCreateHook+0xc>
8114a88c:	003b68fa 	trap	3
8114a890:	df000115 	stw	fp,4(sp)
8114a894:	df000104 	addi	fp,sp,4
8114a898:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning */
}
8114a89c:	0001883a 	nop
8114a8a0:	e037883a 	mov	sp,fp
8114a8a4:	df000017 	ldw	fp,0(sp)
8114a8a8:	dec00104 	addi	sp,sp,4
8114a8ac:	f800283a 	ret

8114a8b0 <OSTaskDelHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskDelHook (OS_TCB *ptcb)
{
8114a8b0:	defffe04 	addi	sp,sp,-8
8114a8b4:	de00012e 	bgeu	sp,et,8114a8bc <OSTaskDelHook+0xc>
8114a8b8:	003b68fa 	trap	3
8114a8bc:	df000115 	stw	fp,4(sp)
8114a8c0:	df000104 	addi	fp,sp,4
8114a8c4:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
8114a8c8:	0001883a 	nop
8114a8cc:	e037883a 	mov	sp,fp
8114a8d0:	df000017 	ldw	fp,0(sp)
8114a8d4:	dec00104 	addi	sp,sp,4
8114a8d8:	f800283a 	ret

8114a8dc <OSTaskSwHook>:
*                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
*                 task being switched out (i.e. the preempted task).
*********************************************************************************************************
*/
void OSTaskSwHook (void)
{
8114a8dc:	deffff04 	addi	sp,sp,-4
8114a8e0:	de00012e 	bgeu	sp,et,8114a8e8 <OSTaskSwHook+0xc>
8114a8e4:	003b68fa 	trap	3
8114a8e8:	df000015 	stw	fp,0(sp)
8114a8ec:	d839883a 	mov	fp,sp
}
8114a8f0:	0001883a 	nop
8114a8f4:	e037883a 	mov	sp,fp
8114a8f8:	df000017 	ldw	fp,0(sp)
8114a8fc:	dec00104 	addi	sp,sp,4
8114a900:	f800283a 	ret

8114a904 <OSTaskStatHook>:
*
* Arguments  : none
*********************************************************************************************************
*/
void OSTaskStatHook (void)
{
8114a904:	deffff04 	addi	sp,sp,-4
8114a908:	de00012e 	bgeu	sp,et,8114a910 <OSTaskStatHook+0xc>
8114a90c:	003b68fa 	trap	3
8114a910:	df000015 	stw	fp,0(sp)
8114a914:	d839883a 	mov	fp,sp
}
8114a918:	0001883a 	nop
8114a91c:	e037883a 	mov	sp,fp
8114a920:	df000017 	ldw	fp,0(sp)
8114a924:	dec00104 	addi	sp,sp,4
8114a928:	f800283a 	ret

8114a92c <OSTimeTickHook>:
#ifdef ALT_INICHE
void cticks_hook(void);
#endif

void OSTimeTickHook (void)
{
8114a92c:	defffe04 	addi	sp,sp,-8
8114a930:	de00012e 	bgeu	sp,et,8114a938 <OSTimeTickHook+0xc>
8114a934:	003b68fa 	trap	3
8114a938:	dfc00115 	stw	ra,4(sp)
8114a93c:	df000015 	stw	fp,0(sp)
8114a940:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr++;
8114a944:	d0a0b60b 	ldhu	r2,-32040(gp)
8114a948:	10800044 	addi	r2,r2,1
8114a94c:	d0a0b60d 	sth	r2,-32040(gp)
    if (OSTmrCtr >= (OS_TICKS_PER_SEC / OS_TMR_CFG_TICKS_PER_SEC)) {
8114a950:	d0a0b60b 	ldhu	r2,-32040(gp)
8114a954:	10bfffcc 	andi	r2,r2,65535
8114a958:	10807d30 	cmpltui	r2,r2,500
8114a95c:	1000021e 	bne	r2,zero,8114a968 <OSTimeTickHook+0x3c>
        OSTmrCtr = 0;
8114a960:	d020b60d 	sth	zero,-32040(gp)
        OSTmrSignal();
8114a964:	114127c0 	call	8114127c <OSTmrSignal>
    
#ifdef ALT_INICHE
    /* Service the Interniche timer */
    cticks_hook();
#endif
}
8114a968:	0001883a 	nop
8114a96c:	e037883a 	mov	sp,fp
8114a970:	dfc00117 	ldw	ra,4(sp)
8114a974:	df000017 	ldw	fp,0(sp)
8114a978:	dec00204 	addi	sp,sp,8
8114a97c:	f800283a 	ret

8114a980 <OSInitHookBegin>:

void OSInitHookBegin(void)
{
8114a980:	deffff04 	addi	sp,sp,-4
8114a984:	de00012e 	bgeu	sp,et,8114a98c <OSInitHookBegin+0xc>
8114a988:	003b68fa 	trap	3
8114a98c:	df000015 	stw	fp,0(sp)
8114a990:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr = 0;
8114a994:	d020b60d 	sth	zero,-32040(gp)
#endif
}
8114a998:	0001883a 	nop
8114a99c:	e037883a 	mov	sp,fp
8114a9a0:	df000017 	ldw	fp,0(sp)
8114a9a4:	dec00104 	addi	sp,sp,4
8114a9a8:	f800283a 	ret

8114a9ac <OSInitHookEnd>:

void OSInitHookEnd(void)
{
8114a9ac:	deffff04 	addi	sp,sp,-4
8114a9b0:	de00012e 	bgeu	sp,et,8114a9b8 <OSInitHookEnd+0xc>
8114a9b4:	003b68fa 	trap	3
8114a9b8:	df000015 	stw	fp,0(sp)
8114a9bc:	d839883a 	mov	fp,sp
}
8114a9c0:	0001883a 	nop
8114a9c4:	e037883a 	mov	sp,fp
8114a9c8:	df000017 	ldw	fp,0(sp)
8114a9cc:	dec00104 	addi	sp,sp,4
8114a9d0:	f800283a 	ret

8114a9d4 <OSTaskIdleHook>:

void OSTaskIdleHook(void)
{
8114a9d4:	deffff04 	addi	sp,sp,-4
8114a9d8:	de00012e 	bgeu	sp,et,8114a9e0 <OSTaskIdleHook+0xc>
8114a9dc:	003b68fa 	trap	3
8114a9e0:	df000015 	stw	fp,0(sp)
8114a9e4:	d839883a 	mov	fp,sp
}
8114a9e8:	0001883a 	nop
8114a9ec:	e037883a 	mov	sp,fp
8114a9f0:	df000017 	ldw	fp,0(sp)
8114a9f4:	dec00104 	addi	sp,sp,4
8114a9f8:	f800283a 	ret

8114a9fc <OSTCBInitHook>:

void OSTCBInitHook(OS_TCB *ptcb)
{
8114a9fc:	defffe04 	addi	sp,sp,-8
8114aa00:	de00012e 	bgeu	sp,et,8114aa08 <OSTCBInitHook+0xc>
8114aa04:	003b68fa 	trap	3
8114aa08:	df000115 	stw	fp,4(sp)
8114aa0c:	df000104 	addi	fp,sp,4
8114aa10:	e13fff15 	stw	r4,-4(fp)
}
8114aa14:	0001883a 	nop
8114aa18:	e037883a 	mov	sp,fp
8114aa1c:	df000017 	ldw	fp,0(sp)
8114aa20:	dec00104 	addi	sp,sp,4
8114aa24:	f800283a 	ret

8114aa28 <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
8114aa28:	defffe04 	addi	sp,sp,-8
8114aa2c:	de00012e 	bgeu	sp,et,8114aa34 <alt_exception_cause_generated_bad_addr+0xc>
8114aa30:	003b68fa 	trap	3
8114aa34:	df000115 	stw	fp,4(sp)
8114aa38:	df000104 	addi	fp,sp,4
8114aa3c:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
8114aa40:	e0bfff17 	ldw	r2,-4(fp)
8114aa44:	10bffe84 	addi	r2,r2,-6
8114aa48:	10c00428 	cmpgeui	r3,r2,16
8114aa4c:	18001a1e 	bne	r3,zero,8114aab8 <alt_exception_cause_generated_bad_addr+0x90>
8114aa50:	100690ba 	slli	r3,r2,2
8114aa54:	00a04574 	movhi	r2,33045
8114aa58:	10aa9a04 	addi	r2,r2,-21912
8114aa5c:	1885883a 	add	r2,r3,r2
8114aa60:	10800017 	ldw	r2,0(r2)
8114aa64:	1000683a 	jmp	r2
8114aa68:	8114aaa8 	cmpgeui	r4,r16,21162
8114aa6c:	8114aaa8 	cmpgeui	r4,r16,21162
8114aa70:	8114aab8 	rdprs	r4,r16,21162
8114aa74:	8114aab8 	rdprs	r4,r16,21162
8114aa78:	8114aab8 	rdprs	r4,r16,21162
8114aa7c:	8114aaa8 	cmpgeui	r4,r16,21162
8114aa80:	8114aab0 	cmpltui	r4,r16,21162
8114aa84:	8114aab8 	rdprs	r4,r16,21162
8114aa88:	8114aaa8 	cmpgeui	r4,r16,21162
8114aa8c:	8114aaa8 	cmpgeui	r4,r16,21162
8114aa90:	8114aab8 	rdprs	r4,r16,21162
8114aa94:	8114aaa8 	cmpgeui	r4,r16,21162
8114aa98:	8114aab0 	cmpltui	r4,r16,21162
8114aa9c:	8114aab8 	rdprs	r4,r16,21162
8114aaa0:	8114aab8 	rdprs	r4,r16,21162
8114aaa4:	8114aaa8 	cmpgeui	r4,r16,21162
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
8114aaa8:	00800044 	movi	r2,1
8114aaac:	00000306 	br	8114aabc <alt_exception_cause_generated_bad_addr+0x94>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
8114aab0:	0005883a 	mov	r2,zero
8114aab4:	00000106 	br	8114aabc <alt_exception_cause_generated_bad_addr+0x94>

  default:
    return 0;
8114aab8:	0005883a 	mov	r2,zero
  }
}
8114aabc:	e037883a 	mov	sp,fp
8114aac0:	df000017 	ldw	fp,0(sp)
8114aac4:	dec00104 	addi	sp,sp,4
8114aac8:	f800283a 	ret

8114aacc <exit>:
8114aacc:	defffe04 	addi	sp,sp,-8
8114aad0:	000b883a 	mov	r5,zero
8114aad4:	de00012e 	bgeu	sp,et,8114aadc <exit+0x10>
8114aad8:	003b68fa 	trap	3
8114aadc:	dc000015 	stw	r16,0(sp)
8114aae0:	dfc00115 	stw	ra,4(sp)
8114aae4:	2021883a 	mov	r16,r4
8114aae8:	114ac740 	call	8114ac74 <__call_exitprocs>
8114aaec:	00a04574 	movhi	r2,33045
8114aaf0:	108ad704 	addi	r2,r2,11100
8114aaf4:	11000017 	ldw	r4,0(r2)
8114aaf8:	20800f17 	ldw	r2,60(r4)
8114aafc:	10000126 	beq	r2,zero,8114ab04 <exit+0x38>
8114ab00:	103ee83a 	callr	r2
8114ab04:	8009883a 	mov	r4,r16
8114ab08:	114adfc0 	call	8114adfc <_exit>

8114ab0c <memcmp>:
8114ab0c:	01c000c4 	movi	r7,3
8114ab10:	3980192e 	bgeu	r7,r6,8114ab78 <memcmp+0x6c>
8114ab14:	2144b03a 	or	r2,r4,r5
8114ab18:	11c4703a 	and	r2,r2,r7
8114ab1c:	10000f26 	beq	r2,zero,8114ab5c <memcmp+0x50>
8114ab20:	20800003 	ldbu	r2,0(r4)
8114ab24:	28c00003 	ldbu	r3,0(r5)
8114ab28:	10c0151e 	bne	r2,r3,8114ab80 <memcmp+0x74>
8114ab2c:	31bfff84 	addi	r6,r6,-2
8114ab30:	01ffffc4 	movi	r7,-1
8114ab34:	00000406 	br	8114ab48 <memcmp+0x3c>
8114ab38:	20800003 	ldbu	r2,0(r4)
8114ab3c:	28c00003 	ldbu	r3,0(r5)
8114ab40:	31bfffc4 	addi	r6,r6,-1
8114ab44:	10c00e1e 	bne	r2,r3,8114ab80 <memcmp+0x74>
8114ab48:	21000044 	addi	r4,r4,1
8114ab4c:	29400044 	addi	r5,r5,1
8114ab50:	31fff91e 	bne	r6,r7,8114ab38 <__reset+0xfb12ab38>
8114ab54:	0005883a 	mov	r2,zero
8114ab58:	f800283a 	ret
8114ab5c:	20c00017 	ldw	r3,0(r4)
8114ab60:	28800017 	ldw	r2,0(r5)
8114ab64:	18bfee1e 	bne	r3,r2,8114ab20 <__reset+0xfb12ab20>
8114ab68:	31bfff04 	addi	r6,r6,-4
8114ab6c:	21000104 	addi	r4,r4,4
8114ab70:	29400104 	addi	r5,r5,4
8114ab74:	39bff936 	bltu	r7,r6,8114ab5c <__reset+0xfb12ab5c>
8114ab78:	303fe91e 	bne	r6,zero,8114ab20 <__reset+0xfb12ab20>
8114ab7c:	003ff506 	br	8114ab54 <__reset+0xfb12ab54>
8114ab80:	10c5c83a 	sub	r2,r2,r3
8114ab84:	f800283a 	ret

8114ab88 <strncpy>:
8114ab88:	2906b03a 	or	r3,r5,r4
8114ab8c:	18c000cc 	andi	r3,r3,3
8114ab90:	2005883a 	mov	r2,r4
8114ab94:	18002c1e 	bne	r3,zero,8114ac48 <strncpy+0xc0>
8114ab98:	010000c4 	movi	r4,3
8114ab9c:	21802a2e 	bgeu	r4,r6,8114ac48 <strncpy+0xc0>
8114aba0:	033fbff4 	movhi	r12,65279
8114aba4:	02e02074 	movhi	r11,32897
8114aba8:	633fbfc4 	addi	r12,r12,-257
8114abac:	5ae02004 	addi	r11,r11,-32640
8114abb0:	100f883a 	mov	r7,r2
8114abb4:	2a000017 	ldw	r8,0(r5)
8114abb8:	3815883a 	mov	r10,r7
8114abbc:	4313883a 	add	r9,r8,r12
8114abc0:	0206303a 	nor	r3,zero,r8
8114abc4:	48c6703a 	and	r3,r9,r3
8114abc8:	1ac6703a 	and	r3,r3,r11
8114abcc:	1800261e 	bne	r3,zero,8114ac68 <strncpy+0xe0>
8114abd0:	39c00104 	addi	r7,r7,4
8114abd4:	52000015 	stw	r8,0(r10)
8114abd8:	31bfff04 	addi	r6,r6,-4
8114abdc:	3811883a 	mov	r8,r7
8114abe0:	29400104 	addi	r5,r5,4
8114abe4:	21bff336 	bltu	r4,r6,8114abb4 <__reset+0xfb12abb4>
8114abe8:	30001e26 	beq	r6,zero,8114ac64 <strncpy+0xdc>
8114abec:	29c00003 	ldbu	r7,0(r5)
8114abf0:	31bfffc4 	addi	r6,r6,-1
8114abf4:	40c00044 	addi	r3,r8,1
8114abf8:	41c00005 	stb	r7,0(r8)
8114abfc:	39c03fcc 	andi	r7,r7,255
8114ac00:	39c0201c 	xori	r7,r7,128
8114ac04:	39ffe004 	addi	r7,r7,-128
8114ac08:	29400044 	addi	r5,r5,1
8114ac0c:	38001026 	beq	r7,zero,8114ac50 <strncpy+0xc8>
8114ac10:	1811883a 	mov	r8,r3
8114ac14:	00000906 	br	8114ac3c <strncpy+0xb4>
8114ac18:	29c00003 	ldbu	r7,0(r5)
8114ac1c:	31bfffc4 	addi	r6,r6,-1
8114ac20:	29400044 	addi	r5,r5,1
8114ac24:	41c00005 	stb	r7,0(r8)
8114ac28:	39c03fcc 	andi	r7,r7,255
8114ac2c:	39c0201c 	xori	r7,r7,128
8114ac30:	39ffe004 	addi	r7,r7,-128
8114ac34:	1811883a 	mov	r8,r3
8114ac38:	38000526 	beq	r7,zero,8114ac50 <strncpy+0xc8>
8114ac3c:	18c00044 	addi	r3,r3,1
8114ac40:	303ff51e 	bne	r6,zero,8114ac18 <__reset+0xfb12ac18>
8114ac44:	f800283a 	ret
8114ac48:	1011883a 	mov	r8,r2
8114ac4c:	003fe606 	br	8114abe8 <__reset+0xfb12abe8>
8114ac50:	30000726 	beq	r6,zero,8114ac70 <strncpy+0xe8>
8114ac54:	198d883a 	add	r6,r3,r6
8114ac58:	18000005 	stb	zero,0(r3)
8114ac5c:	18c00044 	addi	r3,r3,1
8114ac60:	19bffd1e 	bne	r3,r6,8114ac58 <__reset+0xfb12ac58>
8114ac64:	f800283a 	ret
8114ac68:	3811883a 	mov	r8,r7
8114ac6c:	003fdf06 	br	8114abec <__reset+0xfb12abec>
8114ac70:	f800283a 	ret

8114ac74 <__call_exitprocs>:
8114ac74:	defff504 	addi	sp,sp,-44
8114ac78:	de00012e 	bgeu	sp,et,8114ac80 <__call_exitprocs+0xc>
8114ac7c:	003b68fa 	trap	3
8114ac80:	df000915 	stw	fp,36(sp)
8114ac84:	dd400615 	stw	r21,24(sp)
8114ac88:	dc800315 	stw	r18,12(sp)
8114ac8c:	dfc00a15 	stw	ra,40(sp)
8114ac90:	ddc00815 	stw	r23,32(sp)
8114ac94:	dd800715 	stw	r22,28(sp)
8114ac98:	dd000515 	stw	r20,20(sp)
8114ac9c:	dcc00415 	stw	r19,16(sp)
8114aca0:	dc400215 	stw	r17,8(sp)
8114aca4:	dc000115 	stw	r16,4(sp)
8114aca8:	d9000015 	stw	r4,0(sp)
8114acac:	2839883a 	mov	fp,r5
8114acb0:	04800044 	movi	r18,1
8114acb4:	057fffc4 	movi	r21,-1
8114acb8:	00a04574 	movhi	r2,33045
8114acbc:	108ad704 	addi	r2,r2,11100
8114acc0:	12000017 	ldw	r8,0(r2)
8114acc4:	45005217 	ldw	r20,328(r8)
8114acc8:	44c05204 	addi	r19,r8,328
8114accc:	a0001c26 	beq	r20,zero,8114ad40 <__call_exitprocs+0xcc>
8114acd0:	a0800117 	ldw	r2,4(r20)
8114acd4:	15ffffc4 	addi	r23,r2,-1
8114acd8:	b8000d16 	blt	r23,zero,8114ad10 <__call_exitprocs+0x9c>
8114acdc:	14000044 	addi	r16,r2,1
8114ace0:	8421883a 	add	r16,r16,r16
8114ace4:	8421883a 	add	r16,r16,r16
8114ace8:	84402004 	addi	r17,r16,128
8114acec:	a463883a 	add	r17,r20,r17
8114acf0:	a421883a 	add	r16,r20,r16
8114acf4:	e0001e26 	beq	fp,zero,8114ad70 <__call_exitprocs+0xfc>
8114acf8:	80804017 	ldw	r2,256(r16)
8114acfc:	e0801c26 	beq	fp,r2,8114ad70 <__call_exitprocs+0xfc>
8114ad00:	bdffffc4 	addi	r23,r23,-1
8114ad04:	843fff04 	addi	r16,r16,-4
8114ad08:	8c7fff04 	addi	r17,r17,-4
8114ad0c:	bd7ff91e 	bne	r23,r21,8114acf4 <__reset+0xfb12acf4>
8114ad10:	00800034 	movhi	r2,0
8114ad14:	10800004 	addi	r2,r2,0
8114ad18:	10000926 	beq	r2,zero,8114ad40 <__call_exitprocs+0xcc>
8114ad1c:	a0800117 	ldw	r2,4(r20)
8114ad20:	1000301e 	bne	r2,zero,8114ade4 <__call_exitprocs+0x170>
8114ad24:	a0800017 	ldw	r2,0(r20)
8114ad28:	10003226 	beq	r2,zero,8114adf4 <__call_exitprocs+0x180>
8114ad2c:	a009883a 	mov	r4,r20
8114ad30:	98800015 	stw	r2,0(r19)
8114ad34:	00000000 	call	80000000 <OSCtxSw_SWITCH_PC+0x7fffffbc>
8114ad38:	9d000017 	ldw	r20,0(r19)
8114ad3c:	a03fe41e 	bne	r20,zero,8114acd0 <__reset+0xfb12acd0>
8114ad40:	dfc00a17 	ldw	ra,40(sp)
8114ad44:	df000917 	ldw	fp,36(sp)
8114ad48:	ddc00817 	ldw	r23,32(sp)
8114ad4c:	dd800717 	ldw	r22,28(sp)
8114ad50:	dd400617 	ldw	r21,24(sp)
8114ad54:	dd000517 	ldw	r20,20(sp)
8114ad58:	dcc00417 	ldw	r19,16(sp)
8114ad5c:	dc800317 	ldw	r18,12(sp)
8114ad60:	dc400217 	ldw	r17,8(sp)
8114ad64:	dc000117 	ldw	r16,4(sp)
8114ad68:	dec00b04 	addi	sp,sp,44
8114ad6c:	f800283a 	ret
8114ad70:	a0800117 	ldw	r2,4(r20)
8114ad74:	80c00017 	ldw	r3,0(r16)
8114ad78:	10bfffc4 	addi	r2,r2,-1
8114ad7c:	15c01426 	beq	r2,r23,8114add0 <__call_exitprocs+0x15c>
8114ad80:	80000015 	stw	zero,0(r16)
8114ad84:	183fde26 	beq	r3,zero,8114ad00 <__reset+0xfb12ad00>
8114ad88:	95c8983a 	sll	r4,r18,r23
8114ad8c:	a0806217 	ldw	r2,392(r20)
8114ad90:	a5800117 	ldw	r22,4(r20)
8114ad94:	2084703a 	and	r2,r4,r2
8114ad98:	10000b26 	beq	r2,zero,8114adc8 <__call_exitprocs+0x154>
8114ad9c:	a0806317 	ldw	r2,396(r20)
8114ada0:	2088703a 	and	r4,r4,r2
8114ada4:	20000c1e 	bne	r4,zero,8114add8 <__call_exitprocs+0x164>
8114ada8:	89400017 	ldw	r5,0(r17)
8114adac:	d9000017 	ldw	r4,0(sp)
8114adb0:	183ee83a 	callr	r3
8114adb4:	a0800117 	ldw	r2,4(r20)
8114adb8:	15bfbf1e 	bne	r2,r22,8114acb8 <__reset+0xfb12acb8>
8114adbc:	98800017 	ldw	r2,0(r19)
8114adc0:	153fcf26 	beq	r2,r20,8114ad00 <__reset+0xfb12ad00>
8114adc4:	003fbc06 	br	8114acb8 <__reset+0xfb12acb8>
8114adc8:	183ee83a 	callr	r3
8114adcc:	003ff906 	br	8114adb4 <__reset+0xfb12adb4>
8114add0:	a5c00115 	stw	r23,4(r20)
8114add4:	003feb06 	br	8114ad84 <__reset+0xfb12ad84>
8114add8:	89000017 	ldw	r4,0(r17)
8114addc:	183ee83a 	callr	r3
8114ade0:	003ff406 	br	8114adb4 <__reset+0xfb12adb4>
8114ade4:	a0800017 	ldw	r2,0(r20)
8114ade8:	a027883a 	mov	r19,r20
8114adec:	1029883a 	mov	r20,r2
8114adf0:	003fb606 	br	8114accc <__reset+0xfb12accc>
8114adf4:	0005883a 	mov	r2,zero
8114adf8:	003ffb06 	br	8114ade8 <__reset+0xfb12ade8>

8114adfc <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
8114adfc:	defffc04 	addi	sp,sp,-16
8114ae00:	de00012e 	bgeu	sp,et,8114ae08 <_exit+0xc>
8114ae04:	003b68fa 	trap	3
8114ae08:	dfc00315 	stw	ra,12(sp)
8114ae0c:	df000215 	stw	fp,8(sp)
8114ae10:	df000204 	addi	fp,sp,8
8114ae14:	e13fff15 	stw	r4,-4(fp)
  /* ALT_LOG - please see HAL/inc/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
8114ae18:	d0a01217 	ldw	r2,-32696(gp)
8114ae1c:	10800058 	cmpnei	r2,r2,1
8114ae20:	1000031e 	bne	r2,zero,8114ae30 <_exit+0x34>
8114ae24:	01204574 	movhi	r4,33045
8114ae28:	21035a04 	addi	r4,r4,3432
8114ae2c:	113690c0 	call	8113690c <alt_log_printf_proc>
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
8114ae30:	d0a01217 	ldw	r2,-32696(gp)
8114ae34:	10800058 	cmpnei	r2,r2,1
8114ae38:	1000041e 	bne	r2,zero,8114ae4c <_exit+0x50>
8114ae3c:	e17fff17 	ldw	r5,-4(fp)
8114ae40:	01204574 	movhi	r4,33045
8114ae44:	21036504 	addi	r4,r4,3476
8114ae48:	113690c0 	call	8113690c <alt_log_printf_proc>
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
8114ae4c:	d0a01217 	ldw	r2,-32696(gp)
8114ae50:	10800058 	cmpnei	r2,r2,1
8114ae54:	1000031e 	bne	r2,zero,8114ae64 <_exit+0x68>
8114ae58:	01204574 	movhi	r4,33045
8114ae5c:	21037004 	addi	r4,r4,3520
8114ae60:	113690c0 	call	8113690c <alt_log_printf_proc>
  ALT_OS_STOP();
8114ae64:	d0209105 	stb	zero,-32188(gp)

  /* Provide notification to the simulator that we've stopped */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_SIM_HALT().\r\n");
8114ae68:	d0a01217 	ldw	r2,-32696(gp)
8114ae6c:	10800058 	cmpnei	r2,r2,1
8114ae70:	1000031e 	bne	r2,zero,8114ae80 <_exit+0x84>
8114ae74:	01204574 	movhi	r4,33045
8114ae78:	21037a04 	addi	r4,r4,3560
8114ae7c:	113690c0 	call	8113690c <alt_log_printf_proc>
8114ae80:	e0bfff17 	ldw	r2,-4(fp)
8114ae84:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
8114ae88:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
8114ae8c:	10000226 	beq	r2,zero,8114ae98 <_exit+0x9c>
    ALT_SIM_FAIL();
8114ae90:	002af070 	cmpltui	zero,zero,43969
8114ae94:	00000106 	br	8114ae9c <_exit+0xa0>
  } else {
    ALT_SIM_PASS();
8114ae98:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
8114ae9c:	d0a01217 	ldw	r2,-32696(gp)
8114aea0:	10800058 	cmpnei	r2,r2,1
8114aea4:	1000031e 	bne	r2,zero,8114aeb4 <_exit+0xb8>
8114aea8:	01204574 	movhi	r4,33045
8114aeac:	21038404 	addi	r4,r4,3600
8114aeb0:	113690c0 	call	8113690c <alt_log_printf_proc>
  while (1);
8114aeb4:	003fff06 	br	8114aeb4 <__reset+0xfb12aeb4>
